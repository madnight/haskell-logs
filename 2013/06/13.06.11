00:03:15 <Sonarpulse> has anybody used bitsets with the FFI?
00:09:37 <Prottey> well hello there
00:09:52 <yitz> hi Prottey
00:10:09 <Prottey> i've got a little question of, well, practical sort
00:11:09 <yitz> Sonarpulse: bitsets?
00:11:10 <sipa> i have bad news for you: i'm afraid it won't be answered until you ask it :)
00:11:36 <Sonarpulse> http://hackage.haskell.org/packages/archive/bitset/1.4.1/doc/html/Data-BitSet-Generic.html
00:11:46 <Sonarpulse> yitz ^
00:12:15 <Prottey> for instance, if a haskell implementation has definitions of functions a() and b() which can make a composition or other combined function (let us name it c())
00:12:33 <Sonarpulse> IMO enums should either be imported as sum types, or bit sets
00:12:40 <Sonarpulse> depending on how they are used
00:13:12 <Sonarpulse> only importing them as untyped/polymorphic numeric constants as a last resort
00:13:23 <Prottey> and the used CPU instruction set architecture has it own instructions to perform calculations identical to c()
00:13:40 <Prottey> that is, under certain conditions
00:14:42 <Prottey> is it hard to implement a "smart" way for the haskell implementation to "detect" such conditions and make use of this cpu instruction given for these conditions?
00:14:59 <Prottey> without coding anything in the application source code
00:15:54 <yitz> Sonarpulse: enums aren't really bitsets. you can only have one at a time.
00:16:38 <zRecursive> why need two $0 in : #!/bin/sh #| exec clisp -q -q -modern -ansi -norc $0 $0 ${1+"$@"} exit |#
00:17:21 <yitz> zRecursive: is that a haskell question?
00:17:34 <Prottey> for example, if the compiler detects that when a result of sqrt() is used in denominator, it would automatically make use of PFRSQRT instruction from 3DNow!
00:18:04 <zRecursive> yitz: just because #haskell is hot
00:18:12 <yitz> heh
00:18:23 <Prottey> any ideas?
00:19:36 <yitz> Prottey: if there are specific cases you want to detect, you can do that, but it's probably somewhat involved.
00:19:56 <Prottey> ok, but yet
00:20:14 <yitz> Prottey: obviously, it's impossible for any compiler to guarantee that it will automatically find every possible optimisation.
00:21:03 <Prottey> does "specific case" mean these optimizations may be done on... well, how would I explain that by words
00:23:02 <Prottey> if the compiler's job is to generate an abstract state machine from source code, and by using operations over it (e.g. detect and replace identical calculations), maps this state machine to hardware ISA
00:24:14 <yitz> Prottey: yes there is some of that kind of logic in the internal workings of ghc, and you can even get some manual control over it
00:24:55 <Prottey> I mean, when these operations are an integral part of compilation process, not just custom filter loaded into pipeline by user, you know
00:25:18 <Sonarpulse> yitz: C "enums" are often elemnts of a bitset
00:25:31 <yitz> Prottey: i think ghc does generate SIMD instructions in certain situations. (don't hold your breath for 3DNow! though, AMD has discontinued support for it)
00:25:38 <Sonarpulse> anyways
00:25:40 <Sonarpulse> sleep
00:25:48 <Prottey> 3DNow! is for example
00:25:56 <yitz> Sonarpulse: you can have a bitset of enums
00:27:55 <Prottey> also, is there a GC-less way of executing things, where malloc/free calls are inserted statically into code? or even stack allocations for embedded stuff, where heap is not available?
00:28:56 <yitz> Prottey: GC is wired deeply inside GHC's runtime
00:29:14 <Prottey> oh
00:29:19 <yitz> Prottey: the JHC compiler might be able to do that though
00:30:52 <mauke> http://en.wikipedia.org/wiki/Region-based_memory_management#Region_inference
00:30:53 <yitz> Prottey: GHC's GC is extremely fast though. it has its own memory allocation scheme - doesn't use the usual heap.
00:31:09 <Prottey> I think GC would be unnecessary if memory wasn't allocated for one-time value storage and use
00:31:26 <dolio> I think JHC abandoned the region-only memory manager.
00:31:37 <dolio> Maybe regions all together.
00:32:21 <yitz> Prottey: GHC knows about one-time values.
00:33:57 <Prottey> like: a=2*2; b=a+1 (a is no longer used), in which case the storage for a value may be "substituted" by b value, technically with an add CPU directive :P
00:34:15 <Pseudonym> In that case, Prottey, it's more likely that a will be optimised out.
00:34:22 <dolio> Also, people have had a lot of trouble getting region inference to do any better than garbage collection in general.
00:34:52 <Pseudonym> The thing with Haskell is that lazy evaluation complicates things a lot.
00:35:02 <Pseudonym> It means that liveness is a global property of the program.
00:35:05 <Pseudonym> Even more so than in ML
00:36:27 <Prottey> huh
00:36:48 <Pseudonym> We don't even have a good way to analyse space usage in the presence of separate compilation and lazy evaluation.
00:36:54 <Pseudonym> Not statically, anyway.
00:41:52 * hackagebot cassandra-cql 0.1.0.0 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.1.0.0 (StephenBlackheath)
00:42:26 <dolio> Also, one always has to cite Appel's Garbage Collection can be Faster than Stack Allocation.
00:43:00 <dolio> Where you can read "stack allocation" as, "always freeing your memory right away in little chunks."
00:44:20 <Pseudonym> One handy thing about strict evaluation is that you can often show there are no cycles in a data structure from the type alone.
00:44:51 <pxqr> is it possible to use lens with stm, Chans or MVars? For example I have a MonadReader (TVar Int, TVar Bool) => m () and I want to increment the Int.
00:45:17 <Prottey> still, there are problems for garbage collection in embedded stuff
00:46:04 <Prottey> especially when small memory footprint is required
00:46:52 * hackagebot Nomyx 0.2.1 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.2.1 (CorentinDupont)
00:49:09 <Prottey> many production controller models have address space for ROM and RAM, where code instructions are read and executed directly from ROM
00:49:23 <dolio> I think youtube just took a webm video I uploaded and re-encoded it with h264 as the only option, so I can't watch it back in firefox html5.
00:49:34 <Prottey> and RAM isn't just sufficient for dynamic allocation stuff
00:50:05 <Prottey> that's just single example
00:50:28 <dolio> If you can't afford any dynamic allocation, you're going to have to write in a rather restricted programming model to ensure that.
00:51:02 <aleator_> Anyone remember their favourite exercises when learning haskell? I need some neat ones for my course.
00:51:11 <dolio> If you know how things work, it's not hard to get GHC to avoid allocating (much) heap memory for some things, but it won't keep you from not doing that.
00:52:40 <Walther> aleator_: Project Euler, Real world Haskell, learn you a haskell
00:52:55 <johnw> Walther: in maybe the reverse order :)
00:53:15 <Walther> johnw: well, perhaps I was talking in heap?
00:53:16 <Prottey> ok, thanks
00:53:19 <Walther> (lol)(
00:53:22 <johnw> haha
00:54:17 <aleator_> Walther: Lyah doesn't really have exercises as such and project euler is not really nice.
00:54:54 <Walther> aleator_: RWH then perhaps
00:55:00 <Walther> then there was 99 haskell problems
00:55:15 <aleator_> Hm.. I'l then try to steal from there :)
00:55:18 <FreeFull> hackerrank.com maybe?
00:55:20 <Walther> not sure what would be "nice", but those are the biggest ones i've heard of
00:55:43 <FreeFull> 99 haskell problems is good
00:57:01 <aleator_> Are the 99 problems under what kind of license? I'm specifically looking to do machine checkable, simple, exercise sequences and those look quite nice.
00:57:29 <FreeFull> They aren't machine-checkable, but do provide a standard solution
00:57:38 <FreeFull> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
00:57:49 <FreeFull> I don't see anything about a license
01:03:57 <supki> pxqr: no, not really. It's hard to have efficient and correct monadic lenses
01:04:36 <supki> especially given that nobody knows what laws should be
01:32:00 <adnap> Hi
01:33:32 <johnw> hey adnap
01:34:27 <adnap> I'm having trouble again with ScopedTypeVariables
01:34:47 <adnap> The GHC errors are always so confusing to me
01:35:52 <johnw> Can you show me one of the errors you're having troubles with?
01:38:04 <adnap> johnw: http://hpaste.org/89751
01:39:44 <johnw> I've never used that library, so you've got me there
01:40:32 <adnap> Well, the fact that there is a phantom "t" type in this library has been a huge source of confusion for me
01:41:22 <supki> I think compile is polymorphic in t and b is monomorphic in t
01:41:41 <supki> also I have a feeling I've solved some similar problem for you earlier, adnap
01:41:54 * hackagebot concurrent-extra 0.7.0.6 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.7.0.6 (BasVanDijk)
01:42:52 <supki> yeah, compile is rank-2
01:45:12 <adnap> supki: So, do I need to use ScopedTypeVariables to indicate that Moment t being compiled is an instance of Frameworks t?
01:47:16 <johnw> adnap: I'm getting the feeling that you may not know exactly what ScopedTypeVariables does...?
01:47:45 <supki> I wonder how  (forall t. Frameworks t => Behavior t (Int -> String))  works without -XImpredicativeTypes
01:47:50 <adnap> johnw: I think so. It makes the type of something inside a function match the type in a signature
01:48:04 <johnw> I don't think so
01:48:15 <johnw> It lets you refer to an outer type variable within an inner type signature
01:48:31 <johnw> if you only have one type signature, I don't think it's having any effect at all
01:48:32 <Heffalump> supki: ImpredicativeTypes is just about allowing type variables to be instantiated with a polytype lke that
01:48:33 <adnap> That's what I said, essentially
01:49:10 <adnap> supki: Rank2Types
01:49:10 <johnw> in other words, it changes type variables from being local to their type signature, to being "scoped" over the whole function
01:49:30 <johnw> but what you said implies that you're expecting it to affect type inference
01:49:52 <adnap> johnw: Yes
01:51:19 <adnap> Also, I don
01:51:24 <adnap> don't understand "(forall a. [a] -> Int) -> Int really is different from forall a. ([a] -> Int) -> Int. "
01:51:34 <johnw> ok, that one is easy at least
01:51:47 <adnap> It's mentioned here: http://www.haskell.org/haskellwiki/Impredicative_types
01:52:11 <johnw> in the former, the callee decides the type; in the latter, the caller decides the type
01:52:42 <adnap> johnw: That doesn't make sense
01:52:56 <johnw> the first type expects a polymorphic function as its argument, a function that works for *any* a
01:53:08 <johnw> the second type expects a function that operators on some a, but not every a
01:53:24 <johnw> so, for the first type, you only have one choice: pass a function of type [a] -> Int
01:53:34 <adnap> Oh, I see
01:53:36 <johnw> for the second type, you can pass a function [Int] -> Int, [String] -> Int, etc.
01:54:04 <johnw> that's what I mean by "the caller decides the type" in the second case
01:54:36 <johnw> btw, we calls these rank-2 and rank-1 polymorphism, respectively
01:56:33 <adnap> So...
01:57:40 <adnap> "(forall t. Frameworks t => Behavior t (Int -> String))" means...
01:58:19 <adnap> Well, in this library, the Frameworks class doesn't seem to accomplish anything
01:59:03 <johnw> well, the thing about making a type polymorphic like that is so that you can't know anything about the phantom type
01:59:04 <adnap> But I guess it means this function takes a Behavior t where t can be any instance of Frameworks
01:59:18 <johnw> so you'd only be able to use that Behavior as an argument to other function that want a polymorphic Behavior
01:59:28 <johnw> you'd never be able to pass it to any function expecting a specific Behavior
01:59:36 <johnw> (well, any Behavior with the Framework type constraint, that is)
01:59:48 <johnw> (which is a smaller range of types that any possible Behavior)
02:00:08 <johnw> so, if you are trying to call a function that wants Behavior Foo ..., for example, you can't
02:00:15 <johnw> that would require inferring that b ~ Foo
02:00:16 <adnap> Well, I don't understand the author's reasoning for including the phantom type
02:00:31 <johnw> phantom types allow you to distinguish values that otherwise would be identical
02:00:33 <adnap> I don't understand why the type is not just Behavior a
02:01:17 <adnap> I understand the use of phantom types in other cases
02:01:23 <johnw> like, say I had two strings, "1" and "1.0".  I'm not going to convert these to numbers, I'm going to keep them as strings.  But I want some way for the type system to distinguish them for me.  So I could use this:
02:01:30 <johnw> data TaggedString a = TaggedString a String
02:01:36 <adnap> Right
02:01:38 <johnw> ok
02:02:01 <adnap> But in the case of this library, t is never instantiated
02:02:02 <supki> did you mean: data TaggedString a = TaggedString String
02:02:03 <supki> ?
02:02:09 <adnap> supki: YEs
02:02:09 <johnw> supki: yes, thank you
02:02:19 <johnw> TaggedString "1" :: TaggedString Int
02:02:32 <johnw> basically, just what the tagged library from edwardk does for you
02:03:34 <adnap> In the code I posted, the problem seems to be that the event created by fromAddHandler doesn't have a Frameworks t constraint or something
02:03:53 <johnw> yep
02:04:10 <johnw> what is the type of <@>?
02:05:06 <hamid> :t (<@>)
02:05:06 <lambdabot>     Not in scope: `<@>'
02:05:07 <lambdabot>     Perhaps you meant one of these:
02:05:07 <lambdabot>       `<+>' (imported from Control.Arrow),
02:05:07 <adnap> (Functor f, Functor g) => f (a -> b) -> g a -> g b
02:05:33 <johnw> oh, it's the operator someone else in here was thinking of writing
02:05:38 <johnw> or was that you?
02:06:22 <adnap> johnw: No idea
02:06:25 <adnap> johnw: http://hackage.haskell.org/packages/archive/reactive-banana/0.7.1.2/doc/html/Reactive-Banana-Combinators.html#v:-60--64--62-
02:06:59 <adnap> :t (<*>)
02:07:00 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:07:33 <johnw> looks like there's no Apply instance
02:07:51 <adnap> Well, the library provides Apply (Behavior t) (Event t)
02:07:59 <adnap> The problem is that in the code, the t's don't match I think
02:08:04 <johnw> right, but Int -> String isn't Event t, is it
02:08:57 <adnap> johnw: The first argument is Behavior t (Int -> String)
02:09:11 <adnap> The second is Event t Int
02:09:12 <johnw> right
02:09:21 <johnw> ah
02:09:24 <adnap> This matches  f (a -> b) -> g a -> g b
02:09:30 <johnw> I get it now
02:10:01 <adnap> The error is like "Could not deduce (Apply (Behavior t0) (Event t))"
02:10:08 <johnw> yes, I'm wondering where t0 is coming from
02:10:26 <adnap> Well, when I create a new Event with fromAddHandler...
02:10:41 <johnw> i think t0 is *your* t, and t is the t from fromAddHandler
02:10:48 <johnw> and those two t's aren't matching up
02:10:49 <adnap> it doesn't seem to implicily become an Event t which matches the t in the signature of the function
02:11:00 <adnap> Right
02:11:04 <johnw> because yours is a Rank-2 t, and the other is a Rank-1 t
02:11:09 <adnap> I thought I could use ScopedTypeVariables to fix this
02:11:16 <johnw> no, that is not what ScopedTypeVariables does
02:11:34 <johnw> what if you just drop the forall t?
02:12:38 <adnap> Well...
02:13:00 <adnap> the type of compile is "(forall t. Frameworks t => Moment t ()) -> IO EventNetwork"
02:13:11 <johnw> that's fine
02:13:22 <johnw> oh, no, hmm
02:13:36 <johnw> who designed this??
02:13:51 <johnw> using rank-2 polymorphic phantom types is a new one on me
02:13:51 <adnap> http://apfelmus.nfshost.com/
02:14:16 <johnw> what is the type of fromAddHandler?
02:14:36 <adnap> Frameworks t => AddHandler a -> Moment t (Event t a)
02:15:02 <johnw> does your code match any sample code for this library?
02:15:36 <johnw> i can't see how your use of compile can ever type check
02:15:53 <johnw> fromAddHandler is giving you a specific type, and compile wants a polymorphic type
02:16:54 <adnap> https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana/doc/examples/SlotMachine.hs
02:17:37 <johnw> so, that code isn't using fromAddHandler within the block passed to compile
02:18:26 <supki> johnw: ST uses rank-2 polymorphic phantom type, no?
02:18:29 <supki> also reflection
02:18:38 <johnw> i haven't used ST yet :)
02:18:49 <johnw> or reflection
02:18:53 <johnw> so, I believe you
02:19:23 <namoamitabuddha> Hi, folks! In summer holiday, I decide to learn a programming language. I want to know which one is appropriate, haskell or ocaml? I'm a mathematical undergraduate. I have no much time.
02:19:40 <johnw> namoamitabuddha: I would definitely suggest Haskell
02:19:50 <johnw> or, meet me in #ocaml and I'll definitely suggest O'Caml
02:19:56 <mauke> namoamitabuddha: do you have any programming experience?
02:20:01 <adnap> johnw: Notice the type, setupNetwork :: forall t. Frameworks t => (EventSource (), EventSource ()) -> Moment t ()
02:20:06 <adnap> In the example I posted
02:20:10 <johnw> yeah
02:20:14 <adnap> inside that function, fromAddHandler is called
02:20:20 <namoamitabuddha> mauke: I don't know how to describe, but roughly, yes. I have no industrial experience.
02:20:21 <johnw> ah
02:20:29 <mauke> namoamitabuddha: what language(s)?
02:20:31 <johnw> but it's not passed as an argument to putStrLn, is it?
02:20:46 <johnw> i bet you reactimate doesn't deal in rank-2 types
02:21:01 <namoamitabuddha> mauke: C, C++, scheme (learnt a bit from SICP)
02:21:08 <Ralith> namoamitabuddha: ocaml is relatively dead
02:21:15 <johnw> and Haskell plays nicely with maths
02:21:19 <Ralith> haskell is much livelier and quite possibly more widely used
02:21:23 <johnw> in fact, I'm learning math now because of Haskell
02:21:24 <mauke> then you will probably find OCaml easier to begin with
02:21:50 <mauke> on the other hand, I think Haskell is more fun
02:22:02 <adnap> johnw: putStrLn is just fmapped over an Event
02:22:29 <adnap> johnw: In fact, the example I linked does just that
02:22:36 <adnap> "reactimate $ putStrLn "Not enough credits!" <$ edenied"
02:22:36 <johnw> huh
02:22:57 <johnw> well, I'm out of ideas for the moment
02:23:39 <namoamitabuddha> mauke: In fact, I learnt a piece of Haskell (learnyouahaskell?) and OCaml (from manual) a year ago. Now I forgot most detailed grammars, but as far as I've experienced, there're no much essential difference.
02:23:53 <namoamitabuddha> This time, I decide to choose one to learn somewhat thoroughly
02:23:58 <johnw> namoamitabuddha: you might enjoy Haskell's emphasis on purity
02:24:03 <Ralith> johnw: ST is good times, you should find an excuse to use it asap
02:24:24 <nooodl> :t (<$)
02:24:25 <lambdabot> Functor f => a -> f b -> f a
02:24:34 <johnw> Ralith: yeah, I just learned that essentially State is for having a state of a single type, while ST is for having a bunch of state variables of many types
02:24:48 <Ralith> not how I'd put it
02:24:52 <johnw> like, pure IORefs
02:25:24 <nooodl> i'm guessing it's (<$>) . const?
02:25:35 <Ralith> you can implement the semantics of ST with State with very little code
02:25:43 <johnw> > 10 <$ Just 20
02:25:44 <lambdabot>   Just 10
02:25:49 <shachaf> Ralith: In Haskell?
02:26:04 <shachaf> I don't think you can implement ST in Haskell 98.
02:26:05 <johnw> Ralith: I thought it was the opposite that was true
02:26:08 <supki> ST is good, but reflection is life changing experience
02:26:14 <shachaf> Well, I mean, Haskell98+RankNTypes.
02:26:14 <johnw> supki: how so?
02:26:20 <namoamitabuddha> johnw: I have some extra explanations.
02:26:31 <supki> johnw: you should try it!
02:26:47 <johnw> i don't grok reflection yet; any pointers?
02:26:48 <Ralith> shachaf: oh, right, forgot the hard part
02:26:57 <Ralith> damn type safety.
02:27:00 <Ralith> always getting in the way.
02:27:13 <shachaf> johnw: Yes, pointers lifted to the type level. It's kind of ridiculous.
02:27:14 <supki> johnw: the paper is good
02:27:22 <Ralith> haha
02:27:34 <johnw> shachaf: you had me at pointer
02:27:51 <johnw> ah, implicit configurations, this is in my reading queue, I'll bump it up
02:27:53 <shachaf> johnw: The original reflection implementation works by lifting a StablePtr to the type level.
02:28:04 <Ralith> johnw: right, anyway, my point was more that ST is particularly nice for efficient pure implementations of mutation-based algorithms.
02:28:10 <Ralith> which you probably knew
02:28:36 <johnw> shachaf: huh, I don't know whether to be scared or excited
02:29:01 <shachaf> Fortunately the new implementation is much shorter.
02:29:08 <shachaf> (It's pretty much just unsafeCoerce.)
02:32:59 <jonkri> when i try to build the binary package 0.5.1.0 and above on ghc 7.2.1, i get a build failure: "base:Prelude can't be safely imported! The package (base) the module resides in isn't trusted". is there some way i can get around this?
02:33:32 <luite_> ghc-pkg trust base
02:34:32 <jonkri> luite_: why is this necessary?
02:34:45 <luite_> jonkri: i think it's a bug in ghc 7.2, fixed in 7.4
02:35:49 <jonkri> thanks luite_ :-)
02:37:54 <yuhbud888> FUCK HASKELL
02:37:56 <yuhbud888> C ftw
02:38:01 --- mode: ChanServ set +o johnw
02:38:04 --- mode: johnw set +b *!c1961afd@gateway/web/freenode/ip.193.150.26.253
02:38:04 --- kick: yuhbud888 was kicked by johnw (Kicked)
02:38:11 --- mode: johnw set -o johnw
02:41:42 <aleator_> How do you find out which exception is which? For example, I get "Non-exhaustive patterns in case" printed in GHCi and suppose that I want for some reason to catch it?
02:42:12 <jonkri> haha
02:42:29 <jonkri> yuhbud888 bored much?
02:42:48 <shachaf> Please don't feed the trolls. Not even after they've been kicked from the channel.
02:42:58 <jonkri> shachaf: understood
02:43:12 <shachaf> "catch it"? Are you sure about that?
02:43:54 <aleator_> shachaf: Well, yeah. I'm making a driver for testing student code.
02:43:55 <halfie> why does "ghc" needs an executable stack?
02:44:18 <jonkri> shachaf: i meant "i see :)"
02:44:20 <shachaf> halfie: It probably doesn't.
02:44:29 <aleator_> shachaf: Anyways, applies in general. If I get a printout of an exception, how do I find out which exception it is?
02:44:56 <shachaf> λ> catch (case Nothing of Just x -> x)  (\(e :: SomeException) -> case e of SomeException e' -> print (typeOf e'))
02:44:59 <shachaf> PatternMatchFail
02:45:00 <shachaf> That would be the awkward way to do it.
02:45:18 <shachaf> I bet there's a better way but I'd have to look up the documentation for that.
02:45:20 <aleator_> Well, but thats more than I had :)
02:47:46 <shachaf> catch (case Nothing of Just x -> x) (\(SomeException e) -> return (typeOf e))
02:47:59 <aleator_> shachaf: Ah. Thanks!
02:48:14 <shachaf> Probably there's a still better way. I don't know.
02:48:52 <aleator_> I considered someException to be magick and didn't think of looking inside..
02:50:48 <shachaf> Computers are full of magic. The correct response is to become a magician.
02:52:03 <namoamitabuddha> Well, any good manual for Haskell suggested?
02:52:28 <shachaf> Hutton's _Programming in Haskell_ is pretty good.
02:52:53 <namoamitabuddha> johnw: What kind of mathematics do you learn?
02:53:03 <aleator_> shachaf: I've almost completed my stepwise haskell evaluator, which I initially started from ekmetts example for bound library. I think I qualify for some sort of magic user by now :)
02:53:08 <johnw> namoamitabuddha: I am presently learning abstract algebra and category theory
02:53:34 <halfie> shachaf, I am pretty sure about ghc-compiler using exec-stack.
02:53:51 <namoamitabuddha> johnw: Sorry, I'm a freshman.
02:54:10 <shachaf> halfie: You asked why it "needs" it. I say it probably doesn't.
02:59:24 <halfie> shachaf, got you :). I will look into it.
02:59:55 <shachaf> halfie: The only place I know that GHC "needs" writable executable memory is foreign import "wrapper".
03:00:07 <shachaf> (And even there it doesn't have to be writable and executable at the same time.)
03:01:01 <mauke> wouldn't it need it for foreign import "dynamic" too?
03:01:28 <namoamitabuddha> I would relearn "Learn you a haskell"
03:01:45 <mauke> oh, I'm confused
03:03:05 <namoamitabuddha> johnw: Is that related to programming?
03:03:10 <namoamitabuddha> johnw: How is that ...?
03:03:20 <shachaf> It's not.
03:03:35 <johnw> Learn You A Haskell is a good place to start, it has an easy-going, relaxed pace
03:03:46 <namoamitabuddha> johnw: I mean, algebra.
03:04:01 <johnw> namoamitabuddha: Monoids, for example, occur often in Haskell programming
03:04:11 * shachaf sighs.
03:04:16 <johnw> which is a common algebraic structure
03:04:24 <johnw> shachaf: hey, he's asking the question shachaf
03:05:18 <namoamitabuddha> You mean, a semigroup?
03:05:26 <johnw> monoid = semigroup + identity
03:06:04 <shachaf> What do you call the kind of algebra where you write things like "monoid = semigroup + identity"?
03:06:08 <namoamitabuddha> Michael Artin defines semigroup with identity, well, that's only a difference of terminology.
03:06:27 <johnw> shachaf: I don't know, what?
03:06:49 <HugoDaniel> hi
03:06:52 <shachaf> I don't know.
03:07:00 <johnw> shachaf: is what I said incorrect?
03:07:13 <johnw> how would you have said it?
03:07:29 <mauke> shachaf: :-)
03:07:42 <mauke> shachaf: I call it algebralgebra
03:07:43 <shachaf> I didn't say it was incorrect.
03:07:53 <johnw> ah, I see, you are being funny :)
03:08:46 <namoamitabuddha> There are so many materials I will learn in summer holiday, therefore I chose a book easy-going.
03:08:56 <johnw> then you'd love LYAH
03:09:07 <namoamitabuddha> M.Artin's algebra is in my booklist.
03:09:14 <namoamitabuddha> Ah, maybe.
03:09:19 <namoamitabuddha> Since LYAH is free online.
03:09:55 <shachaf> I would love LYAH more if it didn't have all the misleading parts.
03:10:10 <namoamitabuddha> misleading?
03:10:26 <johnw> and a few of its examples are a bit overly oblique, I found
03:11:17 <namoamitabuddha> Incidentally, other than Haskell, do you code in imperative language?
03:11:37 <johnw> namoamitabuddha: I'm a long time user of C, C++ and Python
03:12:01 <johnw> sometimes, I wonder if I'd love Haskell less if I hadn't gone through what I had to get here
03:13:07 <namoamitabuddha> You mean, for example, astonishing side-effect and vexing address manipulation?
03:13:09 <mauke> I know C, Perl, JavaScript, plus various bits of C++, Lisp, Java, etc.
03:13:26 <HugoDaniel> i know nothing :/
03:13:58 <shaunmartin> can anyone help me with GHC Pragmas? Specifically, my x.hs file begins with the line {-# OPTIONS_GHC -O2 #-} and yet when I compile it with "ghc x.hs" the -O2 command is ignored
03:14:35 <HugoDaniel> char memoryManager[1024*1024*1024*4]; <- my initial approach to problems
03:14:38 <johnw> namoamitabuddha: spending hours, if not days, tracking down subtle memory overwrites that disappear when you add debug prints, yeah
03:15:01 <johnw> nowadays when I get a segfault, I actually do a double-take.  Whaaa, how can that even happen?
03:15:25 <namoamitabuddha> johnw: In fact, today, I'm considering methodology to ensure programs to be right.
03:15:38 <johnw> namoamitabuddha: well, there are languages that make that their focus
03:15:40 <shachaf> What does "ignored" mean?
03:15:49 <johnw> Coq, Agda, Idris, Epigram, etc.
03:15:52 <namoamitabuddha> johnw: For example, coq, etc?
03:16:13 <shachaf> If only people asked their questions in a way that allowed people to help them. :-(
03:16:16 <johnw> namoamitabuddha: I wonder if you'd appreciate http://www.cis.upenn.edu/~bcpierce/sf/
03:16:51 <namoamitabuddha> johnw: I'm not thinking about a pure logic way. I'm thinking a methodology, sketching the big picture of why something is true.
03:17:05 <shachaf> Perhaps #-overflow or #-blah would be appropriate for this conversation.
03:17:16 <namoamitabuddha> Thanks.
03:17:23 <johnw> shachaf: at this point, you are right
03:17:59 <namoamitabuddha> Come to shaunmartin's question. I fade.
03:18:02 <shachaf> If only transplanting conversations didn't kill them. I consider this a failure of IRC UIs.
03:18:14 <johnw> shachaf: it really is
03:18:16 <shachaf> That, too, is a #-blah topic.
03:18:20 <johnw> lol
03:18:29 <johnw> you just killed your own spinoff thread
03:18:43 <shaunmartin> shachaf: ignored means the resulting executable is compiled as though the flag -O2 was not specified
03:18:54 <shachaf> I also consider it a failure of people. But people don't want to be fixed.
03:18:57 <shachaf> shaunmartin: How can you tell?
03:18:58 <johnw> shaunmartin: how do you know that?
03:19:42 <shachaf> Ideally, when you ask a question, you specify: What you did; what you expected (and maybe why); what actually happened.
03:19:54 <shachaf> Ideally ideally, you ask it in such a way that other people can test it for themselves.
03:20:52 <shaunmartin> Maybe I'm misunderstanding how pragmas are supposed to work... I thought that you could either compile with the command "ghc -O2 x.hs" or you could put the line "{-# OPTIONS_GHC -O2 #-}" at the beginning of the file and comile with just "ghc x.hs" and you would end up with the same optimized executable
03:21:21 <shaunmartin> By timing the resulting executable.
03:21:42 <johnw> shaunmartin: even if OPTIONS_GHC -O2 compiled that file with -O2, it wouldn't cause the link to use -O2, would it?
03:21:53 <shachaf> johnw: ?
03:22:06 <johnw> i mean, I'm not sure how much effect -O2 has if applied to a single module
03:22:12 <johnw> but maybe I'm not saying anything meaningful
03:22:45 <shaunmartin> johnw My file is a single haskell program. Perhaps I should have called it Main.hs
03:22:50 <johnw> ah
03:23:16 <johnw> i've only ever used options that affect parsing in OPTIONS_GHC, not that affect code generation, so I cannot help; maybe shachaf knows?
03:23:32 <Eduard_Munteanu> I'd rather look at the md5sum of that, assuming it's deterministic.
03:23:37 <shaunmartin> (I'm on Mac OSX 10.6.8 with 32 bit Haskell Platform, just in case that makes any difference)
03:24:08 <shachaf> I've already said what I know.
03:24:36 <shachaf> Are you really going to make me make my *own* .hs file, with my own program, just to test -O2 behavior?
03:25:06 <johnw> shaunmartin: quick, paste a test file that shows the behavior, before shachaf implodes
03:25:07 <shachaf> (I already did, and my experience doesn't match yours, which was what I expected. That's why I kept asking for more information.)
03:29:03 <shachaf> http://slbkbs.org/iwe.txt
03:29:41 <shachaf> There is my experience. Nothing up my sleeves.
03:32:49 <shaunmartin> Oops sorry shachaf - and now I gotta run for an appointment! My humble apologies!
03:33:00 <johnw> lol
03:34:55 <shachaf> Well, so much for that.
03:35:19 <johnw> shachaf: you get an A for effort
03:35:42 <shachaf> I made the fatal mistake of giving up and answering the question.
03:35:53 <johnw> i know, you tried, you really did
03:35:55 <shachaf> I should never answer bad questions in #haskell. You can't win.
03:36:14 <shachaf> My goal is always to teach people how to ask questions, not to teach them Haskell.
03:36:16 <johnw> pretty soon, we're going to have to get a pool together and send you on a vacation to a better channel for a while
03:39:23 <johnw> shachaf: question: is there a CoCodensity?
03:40:39 <shachaf> CocoaDensity is one of the primary indicators of quality chocolate.
03:40:45 <johnw> :)
03:41:20 <shachaf> But if you're asking whether you can stick the word "Co" in front of things, the answer is yes.
03:41:46 <bitonic> one would expect CoCoDensity to be Density.
03:41:54 <johnw> i meant, is there a CoCodensity in edwardk's forest of types that does to Codensity what Coyoneda does to Yoneda?
03:41:58 <shachaf> I assume that johnw is aware of Density's existence.
03:42:01 <shachaf> Maybe not.
03:42:09 <johnw> I am no
03:42:10 <johnw> t
03:42:12 <shachaf> OK.
03:42:25 <shachaf> data Density w a = forall x. Density (w x) (w x -> a)
03:42:38 <shachaf> It is a left Kan extension, just like CoYoneda.
03:42:38 <johnw> why is the Co- flipped around between Density and Yoneda?
03:42:40 <Eduard_Munteanu> @faq Can CoCoHaskell answer this question?
03:42:40 <lambdabot> The answer is: Yes! Haskell can do that.
03:42:43 <bitonic> johnw: ‘Co’ means ‘flip the arrows, turn the compositions around in the laws’
03:42:55 <johnw> bitonic: yes, that part I knew
03:43:04 <bitonic> well then CoCoX = X :P
03:43:14 <johnw> i didn't realize that Density is Lan and Yoneda is Ran
03:43:34 <johnw> ok, I should have guessed that one better, thanks shachaf
03:45:17 <johnw> then I imagine Density can be used to right-associate =>> operations on a Comonad
03:46:05 <shachaf> I am not sure what "right-associate" means there.
03:46:09 <prophile> are there any interesting comonads which aren't either the identity or a data structure with a cursor?
03:46:17 <bitonic> prophile: automatas
03:46:22 <johnw> (a =>> b) =>> c to a =>> (b =>> c)
03:46:32 <prophile> intriguing
03:46:36 <prophile> I shall investigate this further
03:46:37 <shachaf> I think that is a type error.
03:47:13 <bitonic> prophile: well actually that might be the wrong term, but I mean stuff like the game o life
03:47:15 <shachaf> I think your best bet is to spend a while understanding what's going on with monads and Codensity.
03:47:31 <prophile> bitonic: oh
03:47:35 <johnw> with monads and Codensity, it's (a >=> b) >=> c to a >=> (b >=> c)
03:47:44 <prophile> bitonic: you mean a 2D grid, with a cursor? :)
03:48:18 <bitonic> prophile: I’m not sure I see the cursor.  a 2D grit where each cell spawns another little grid, or something like that
03:48:31 <shachaf> ((a >=>) . (b >=>) . (c >=>)) return
03:48:36 <johnw> right
03:48:41 <johnw> precisely that
03:48:43 <bitonic> prophile: there you go <http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html>
03:48:49 <shachaf> Not precisely that.
03:48:53 <johnw> no?
03:48:57 <bitonic> sigfpe to the rescue
03:48:59 <prophile> bitonic: yeah, but the comonadic cellular automaton implementation has its comonadic data structure as a 2D grid with a cursor
03:49:11 <shachaf> Well, I don't know what "precisely" means there...
03:49:13 <shachaf> But whatever.
03:49:17 <hpc> if only sigfpe updated more often than twice a year ;)
03:49:19 <shachaf> I'm going to sleep.
03:49:25 <johnw> me too
03:49:30 <bitonic> prophile: oh right, I guess it is a zipper.
03:49:38 <bitonic> damnit.
03:49:47 <prophile> ah well
03:49:49 <bitonic> I never saw them like that
03:50:06 <hpc> isn't Cont a comonad?
03:50:15 <shachaf> No.
03:50:18 <shachaf> prophile: In the sense that Codensity is "mother of all monads", Density is "mother of all comonads".
03:50:24 <Eduard_Munteanu> There's cocont.
03:50:25 <shachaf> Codensity is like Cont. Density is like Store.
03:50:28 <johnw> the Nt comonad
03:50:35 <shachaf> Store is this Comonad: data Store s a = Store s (s -> a)
03:50:56 <shachaf> In a sense that's "a data structure with a cursor".
03:50:59 <Eduard_Munteanu> Store is still pretty much like zippers / cursor thingy.
03:51:07 <shachaf> So in a sense every comonad is "a data structure with a cursor".
03:51:09 <bitonic> ah you see, they’re all cursors
03:51:21 <prophile> I see
03:51:30 <shachaf> In a sense I'm making all this up.
03:51:36 <prophile> and the identity has its "cursor" implicit
03:51:39 <johnw> bitonic: Store is a data structure with a cursor; I'm not sure if all Comonads fit that description
03:51:43 <prophile> because it contains exactly one element
03:51:49 <shachaf> Identity is Store (), of course.
03:52:11 <bitonic> johnw: given the dualities, ‘Store is the mother of all comonads’ is convincing :P
03:52:39 <shachaf> Oh, Identity is also Density Identity.
03:54:13 <Eduard_Munteanu> Also, Store is actually Costate.
03:54:28 <shachaf> FSVO "actually"
03:54:46 <shachaf> alt. FSVO "Co"
03:55:10 <Eduard_Munteanu> Same adjunction I mean.
03:56:56 <Eduard_Munteanu> By analogy, there's more to comonads than costate-ish stuff, one could argue.
03:57:27 * Eduard_Munteanu can't find an example off the top of his head :(
04:05:52 <SrPx> So a question about monads: they are supposed to allow IO, among other things, without compromising the purity of the language.
04:06:15 <SrPx> But what I'm noticing is that, in order to use them, you have to write your functions aware of them. Such as, a debbugable function that returns a float...
04:06:21 <int-e> . o O ( That IO is a monad is more of a happy side effect. ;-) )
04:06:41 <SrPx> you have to write it as a function that returns a M Float, where M is your type
04:06:54 <SrPx> Is not that bad? That you have to rewrite the function in a monad form?
04:07:07 <johnw> SrPx: I think you're confusing two meanings of the word purity
04:07:09 <int-e> SrPx: it keeps you honest.
04:07:56 <int-e> SrPx: If the function has effects it should have an IO type to begin with.
04:07:57 <SrPx> I think you should just write a function Float -> Float, and then update it to a function Float -> Debug Float if you wanted to debug it... not rewrite it to return a Debug Float, that seems weird
04:07:58 <johnw> Eduard_Munteanu: how about instance Monoid m => Comonad ((->) m), that doesn't feel much like a cursor into a data structure
04:08:42 <Eduard_Munteanu> Oh, hm.
04:08:47 <typoclass> SrPx: hm yeah ... in the simplest case you can just do "fooM = liftM foo" if foo is your pure function, and receive an "M" function from it. very roughly.
04:08:54 <typoclass> @type liftM
04:08:55 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
04:08:59 <typoclass> @type fmap
04:08:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:09:09 <Eduard_Munteanu> I forget if that's called something else than Coreader, but I've gotta go.
04:09:10 <int-e> SrPx: But for debugging we can cheat, using Debug.Trace.
04:09:37 <SrPx> liftM ?
04:09:44 <tdammers> :t liftM
04:09:45 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
04:09:54 <typoclass> SrPx: i think we should examine your debug float example more closely. what does it do? which floats are sent to the writer monad?
04:10:05 <supki> someone should fix that type
04:10:23 <tdammers> Monad m => (a -> b) -> m a -> m b
04:10:27 <supki> thanks
04:10:31 <SrPx> typoclass: I'm just reading on the monad tutorial
04:10:37 <tdammers> which one?
04:10:53 <typoclass> SrPx: oh, there's about a million of those :-)
04:10:56 <SrPx> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html it's actually the first thing I'm reading as of trying to learn haskell
04:11:07 <SrPx> after glaring the basics which I did already know from other langs
04:11:28 <supki> you definitely should not start learning haskell from monads
04:11:34 <tdammers> second that
04:11:37 <johnw> third
04:11:42 <tdammers> start with purity and lazy evaluation
04:11:47 <hpc> i just went through LYAH in order
04:11:48 <int-e> you-could-have-invented-monads is one of the better monad tutorials
04:11:57 <tdammers> those two are enough to mess with your brain for a considerable whil
04:12:01 <tdammers> *while
04:12:02 * hackagebot hsdns 1.6.1 - Asynchronous DNS Resolver  http://hackage.haskell.org/package/hsdns-1.6.1 (PeterSimons)
04:12:14 <int-e> because it starts from examples, rather than trying to explain that moands are like burritos.
04:12:44 <johnw> int-e: and monad trannsformers must be the equivalent to Taco Bell's seven-layer burrito
04:13:11 <tdammers> monad transformers are burrito-flavored burritos wrapped in a burrito
04:13:19 <typoclass> int-e: please refer to http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=1288212148&k=5KLHJ3V
04:13:20 <int-e> johnw: a monad transformer is like a leaf of lettuce? neat!
04:13:26 <johnw> ooh, I tend to prefer the burrito flavored burritos
04:13:35 <int-e> typoclass: cute.
04:13:55 <johnw> typoclass: lol
04:14:01 <int-e> johnw: you get out of that trap using 'join'. but the cat is stuck forever.
04:14:32 <SrPx> Hmm Okay
04:14:52 <typoclass> int-e: well, you've seen that, haven't you? http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960526421&k=tSKXkj9&lb=1&s=L
04:15:50 <int-e> typoclass: yes, I knew that one. (I may have seen the other one, too. I'm not sure.)
04:17:02 <johnw> SrPx: Monads retain purity, because so called "side-effects" are expressed in the result type (like your Debug Float).  lack of purity is when side-effects happen that literally come out of nowhere.  Then you can't trust that Float -> Float is just doing math; it may post your equation on Twitter for all the world to see
04:17:34 <johnw> now, Float -> IO Float, there is a function you need to worry about
04:18:11 <johnw> and the type IO Float is telling you, "Hey, I could do just about anything here..."
04:18:14 <tdammers> well, IO isn't that different from other monads, really, except that it gets "run" automatically
04:18:20 <johnw> right
04:18:27 <typoclass> SrPx: so, looking at the (Float, String) example from the tutorial, i don't think it's intended as an actually useful monad you'd use in your programs. it'd just give you long strings of the sort "g was called. f was called." ... i think it's intended as an example for the purpose of explanation
04:18:35 <tdammers> with State, you have to call runState; with IO, you merely have to bind to main
04:18:56 <SrPx> It is still pure but then you are just wrapping a type around a return value, it seems the same as just returning a tuple of 2 values and writting helper functions to combine functions on that form, really
04:19:22 <SrPx> But anyway forget that
04:19:24 <tdammers> SrPx: the tutorial takes a while to sink in
04:19:47 <tdammers> the first step is to accept the absence of side effects (ignoring IO for the time being)
04:19:52 <SrPx> just a little question, import Data.String.Utils = not found, is that the correct syntax?
04:20:03 <typoclass> SrPx: what i'm saying is -- in practice you don't too often take a pure function "... -> Something" and suddenly edit its source code to make it "-> M Something"
04:20:08 <SrPx> tdammers: ok
04:20:18 <elliott> I do!
04:20:22 <elliott> re: M Something
04:20:28 <SrPx> ...
04:20:47 <typoclass> elliott: alright :-) use moar liftM? fmap?
04:20:50 <tdammers> what the tutorial does, then, is explain how you can do typical "impure" things in pure code
04:21:18 <elliott> typoclass: I'd rather use eff or Frank :P
04:21:23 <tdammers> the Debug example explains how you can pass a "debug messages" string along your call graph, alongside the actual computation result
04:21:37 <tdammers> the other examples do similar things
04:22:01 <tdammers> similar in that their *structures* are the same; their functionality is not
04:22:04 <typoclass> SrPx: that would require that you have Data.String.Utils installed, because i don't think there's a module of that name in the packages that come with ghc
04:22:23 <elliott> (any lambdabot problems I should know about?)
04:22:28 <elliott> (modulo the not-restored-yet L.hs)
04:22:43 <tdammers> and that shared structure is really all there is to monads (only that haskell gives you some syntax sugar to make it easier to write)
04:23:47 <int-e> @type cuddleWarmAndFuzzyThing
04:23:48 <lambdabot> Not in scope: `cuddleWarmAndFuzzyThing'
04:23:49 <SrPx> typoclass: is it hard to install? It was just listed on Haskell site when I googled for "string replace"
04:23:52 <typoclass> SrPx: if you use hayoo to search for "Data.String.Utils", it'll show you the package that it's contained in (displayed in green) http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:data.string.utils you can then decide if you want to install that, by doing "cabal install MissingH"
04:24:18 <elliott> @tell ski note that @where L.hs is full of lies, and has been for quite some time (that darcs repo is not even updated any more)
04:24:19 <lambdabot> Consider it noted.
04:24:20 <tdammers> depending on taste, you might check your distro's repository first
04:24:59 <tdammers> older version, and system-wide, but faster install, because it doesn't have to compile locally
04:24:59 <elliott> @tell ski I'll be re-adding stuff from the old L.hs today, let me know if there is anything in particular you'd like added, and maybe I can see about getting it publicly viewable
04:24:59 <lambdabot> Consider it noted.
04:26:24 <typoclass> tdammers: yes, good point
04:27:26 <tdammers> I usually install "basic" libraries from debian, and the more specific stuff through cabal-dev, on a per-project basis
04:27:42 <tdammers> (where what constitutes "basic" is of course highly subjective)
04:29:23 <ski> @messages
04:29:25 <SrPx> typoclass: thank you very much
04:29:59 <SrPx> eh, MissingH-1.2.0.0 depends on hslogger-1.2.1 which failed to install.
04:30:00 * ski wonders why lambdabot doesn't retell private `tell's in private, and public `tells' in public
04:30:00 <SrPx> hslogger-1.2.1 failed during the building phase. The exception was:
04:30:10 <ski> @tell elliott well, i was missing `Data.Array',`Data.Ix' the other day. `asTypeIn' and `asTypeAppliedTo' might also be nice
04:30:10 <lambdabot> Consider it noted.
04:30:49 <typoclass> SrPx: you're welcome. anyway, if you're just starting out with haskell, consider lyah and also tryhaskell.org
04:30:51 <typoclass> @where lyah
04:30:51 <lambdabot> http://www.learnyouahaskell.com/
04:31:08 <ski> and perhaps `infixr 9 .:; (.:) = (.) . (.)'
04:31:14 <elliott> ski: ok, thanks. (re the privacy: that's an upstream lambdabot change (lambdabot was running on a quite old version of the codebase), you could open an issue in the github repo if you'd like it to change, or I might look into patching it to be public again if people don't like it...)
04:31:17 * ski suspects Caleskell `(.)',`flip',`(++)' might be too much to ask for
04:31:20 <SrPx> I'm reading lyah, tryhaskell.org nah
04:31:36 <elliott> ski: those just got fixed a few weeks ago! :P
04:31:40 <SrPx> Do you have any idea why MissingH won't install?
04:31:49 <ski> @type flip
04:31:50 <lambdabot> (a -> b -> c) -> b -> a -> c
04:33:05 * elliott wonders if "privacy" is the correct way to say "privateness"...
04:33:22 <tdammers> real world haskell is pretty OK too
04:33:24 * ski . o O ( <http://spl.smugmug.com/Humor/Lambdacats/i-6djpLdS/0/O/simon.jpg> )
04:33:30 <tdammers> @where rwh
04:33:30 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:33:34 <hodapp> elliott: Well... I'd treat 'privacy' as more of an abstract quality, 'privateness' as sort of... the quantity of it? I dunno.
04:33:49 <hodapp> tdammers: I'm reading RWH right now and finding it pretty accessible.
04:34:23 <typoclass> SrPx: could you paste the entire message that cabal printed? please use hpaste.org if it's more than one line
04:37:27 <SrPx> http://hpaste.org/89763
04:39:42 * elliott thinks of a possible solution to the hpaste bot spam problem: announce pastes, but only if their author is in the channel (this also encourages people to fill it out correctly!)
04:39:59 <Taneb> elliott, I keep getting it backwards
04:40:13 <SrPx> elliott: pardon, did I do something wrong?
04:40:39 <elliott> SrPx: no no
04:40:47 <elliott> just thinking to myself because I saw the explicit hpaste link
04:40:54 <elliott> those used to be announced by a bot
04:41:00 <elliott> but it is inactive due to spam
04:41:12 <SrPx> elliott: I see, I was expecting it to show up as I had to chose a channel
04:41:38 <typoclass> elliott: that's a good idea!
04:41:53 <ski> elliott : sounds nice and reasonable
04:42:10 <typoclass> SrPx: what does "ghc-pkg check" say?
04:42:15 <elliott> of course, the spam pastes are bad even unannounced (see http://hpaste.org/)...
04:44:16 <SrPx> typoclass: says cache is out of date, what now?
04:44:42 <typoclass> SrPx: erm, how weird. could you paste the entire message?
04:47:09 <SrPx> typoclass: http://hpaste.org/89764
04:47:44 <typoclass> hm. i don't know what that means. anyone else?
04:49:19 <SrPx> No probs :|
04:49:28 <alpounet> SrPx, doesn't ghc-pkg recache fix those warnings?
04:50:04 <SrPx> alpounet: only the first
04:50:38 <SrPx> but I guess the installation went right this time, thanks
04:51:59 <typoclass> @tell chrisdone idea about the spam arms-race on hpaste -- could you make the "report/delete" button actually delete the paste if (say) 3 people have clicked it? a spam paste would get deleted quite quickly. and we could re-enable announcing hpastes in #haskell, making each spam message go away in a few minutes. who knows, maybe the spammers will even learn that and stop.
04:51:59 <lambdabot> Consider it noted.
04:52:18 <elliott> we could _not_ re-enable announcing given a report after the fact mechanism
04:52:25 <elliott> once the announcement is made, the damage is done
04:53:34 <typoclass> elliott: well yes, #haskell would have to be the spam police for a short while. the hope is that if spammers notice hpaste won't keep their stuff for more than 5 minutes, they'll go somewhere else
04:53:42 <mauke> >maybe the spammers will even learn
04:54:13 <elliott> typoclass: it's not people doing this...
04:54:21 <elliott> in fact, I seriously doubt they are targetting hpaste specifically
04:54:29 <typoclass> mauke: well, they learned that hpaste can be used to host files *shrug*
04:54:45 <elliott> they use BBCode
04:54:49 <elliott> it's meant to be forum spam
04:55:01 <elliott> most likely their code sees hpaste.org and thinks it looks close enough to a forum
04:55:12 <mauke> s/forum/form/
04:55:23 <mauke> if it's a form, it needs to be submitted (obviously!)
04:56:29 <typoclass> elliott: hmm ...
04:57:28 <elliott> honestly, some kind of targetted denial (if the spammers behave predictably) or just a CAPTCHA of some kind would probably be the best solutions
04:58:21 <elliott> and btw -- I've learned that if you use simple text CAPTCHAs that require obscure domain knowledge to answer (that provide links to info about the question), they get broken
04:58:50 <elliott> I can only assume some poor person was paid to click the link and answer the question once and it gets stored
04:59:49 <typoclass> right now it might be enough to require people to input an author name. all the spam seems to be from anonymous coward
05:00:12 <randomclown> where is the source for the GHC.IO package?
05:00:37 <ski> <http://paste.lisp.org> uses a simple arithmetic captcha
05:02:00 <elliott> typoclass: wait, really?
05:02:04 <elliott> that means it's shachaf's fault all this spam is happening
05:02:08 <elliott> he got that feature added recently
05:02:29 <typoclass> ski: interesting. i've always wondered if those are effective. or how effective they are
05:02:39 <elliott> ski: looks like a type out the digits in an image cpatcha, not arithmetic
05:02:47 <mauke> elliott: hover the "image"
05:02:49 <elliott> (accessibility issues :( )
05:02:58 <elliott> oh, cute
05:03:44 <roconnor> Environment variables are on a per process basis as opposed to a per thread basis right?  i.e. threads could communicate through enviroment variables if they were inclined to.
05:04:16 <mauke> roconnor: environment variables are exec() parameters
05:04:27 <mauke> if you're not calling exec, it's not environment
05:04:31 <elliott> roconnor: environment variables are immutable
05:04:31 <typoclass> ski: er, simple captcha in the sense of "need to google it". it was 95 * 82 for me
05:04:35 <elliott> their mutability is an illusion
05:04:47 <elliott> the libc maintains a mutable environment for you, but that's just the libc
05:04:50 <fruitFly> hey :)
05:04:58 <elliott> environment only really exists at exec time
05:05:04 <randomclown> I'm fairly sure each thread had it's own environemntal variables
05:05:11 <fruitFly> the guys over in idris were saying idris makes haskell seem as safe as c++
05:05:23 <randomclown> but what about the **environ pointer?
05:05:37 <fruitFly> dependent types is definitely a interesting concept :)
05:05:46 <randomclown> Since thread share the same memory space can't they just use the **environ pointer?
05:05:59 <roconnor> elliott: okay is the mutable illusion of the enviroment variables on a per thread or per process basis (i.e. could threads communicate through enviroment variables)?
05:06:01 <typoclass> roconnor: sounds correct to me. all the threads in your program see the same list of env variables. they could even write into them, although who knows what race conditions or other stuff that will cause ...
05:06:10 <elliott> roconnor: that I don't know about
05:06:12 <mauke> roconnor: depends on the implementation of your "environment variables"
05:06:20 <elliott> roconnor: it is probably not specified by any standard
05:06:22 <roconnor> mauke: is that what POSIX says?
05:06:22 <elliott> and sounds evil
05:06:27 <roconnor> hmm
05:06:29 <mauke> roconnor: no idea
05:06:58 <luite_> fruitFly: bah those ivory tower academic idris programmers. at least haskell is a real programming language, used in industry for getting actual work done ;)
05:07:25 <fruitFly> luite_: haha... that's why I'm here :P
05:07:51 <luite_> fruitFly: was a joke obviously, since it's (was?) a common criticism about haskell
05:07:53 * magicman sporfles. Nice one XD
05:08:38 <roconnor> ``
05:08:39 <roconnor> For a C-language program, an array of strings called the environment shall be made available when a process begins. The array is pointed to by the external variable environ, which is defined as:
05:08:41 <roconnor> extern char **environ;
05:09:04 <roconnor> Sounds per process based; though there is some wiggle room
05:09:12 <fruitFly> luite_: I don't think it's a joke, maybe relative to the more main stream languages, but I'm learning haskell with the faith that I'll be able to accomplish about anything I want to do related to computing
05:09:37 <randomclown> roconnor: oh fml for some retarded reason I though fork madea a new thread lol
05:09:52 <randomclown> environmental variables are of course process based
05:09:57 <luite_> fruitFly: sure, but one of idris' goals is to make a practical dependently typed language, they're not as far as haskell obviously, but seem to be making good progress
05:10:02 <fruitFly> with my limited experience I feel like the time is over that haskell is merely just an academic language from how I hear it being applied
05:10:28 <randomclown> when you fork you can pick the environs for your new process. If you access **environ after you fork you'd only change the environs in the new process
05:10:48 <fruitFly> luite_: I know it's really exciting to me, but I think I'll continue to learn haskell and then maybe learn idris :)
05:10:50 <roconnor> randomclown: right
05:11:41 <roconnor> randomclown: this is very helpful.
05:11:59 <ski> elliott : hm, haven't noticed any image there ..
05:13:28 <typoclass> ski: it shows "captcha:" then an image of a 4-digit number. the mouse-hover-over-tool-tippy text says "what is 95 multiplied by 82". presumably you're supposed to comply to the text, not the image
05:13:40 <roconnor> boy POSIX is so terrible.  I mean, I understand the concept of taking all the terrible OS interfaces at the time and trying to unify them under a single terrible interface ...
05:14:00 <elliott> ski: perhaps your browser runs with images (or javascript??) disabled or something
05:14:08 <typoclass> i'm on a spree deleting hpaste spam right now, and it seems to be actually deleted within minutes. also, the spam all seems to be from this one source pasting always the same format. various metadata + a link to stooorage.com + several links to ryushare.com
05:14:14 <elliott> typoclass: I assume the image is the answer to the question
05:14:21 <roconnor> but people today shouldn't look at POSIX as some golden achivement that should be revered.
05:14:25 <elliott> i.e., the tooltip is for accessibility
05:14:34 <elliott> so blind people are allowed to make pastes as long as they're good at arithmetic :p
05:14:34 <typoclass> elliott: erm! oh, that's possible. i thought it was a decoy
05:14:36 <ski> elliott : no ECMAscript (though images)
05:14:38 <typoclass> > 95*82
05:14:38 <lambdabot>   7790
05:14:39 <ski> (w3m)
05:14:52 <typoclass> elliott: yeah, probably your theory =)
05:14:53 <roconnor> even C developers should be thinking, there has got to be a better way.
05:15:18 <mauke> typoclass: it's not an image
05:15:24 <halfie> shachaf, ghc-compiler as included in Fedora 19 has executable stack. Bug #703 was closed 4 years back. any ideas what might be causing ghc package to have exec. stack in fedora 19?
05:15:31 <mauke> it's a collection of interestingly positioned <div>s
05:15:44 <typoclass> mauke: heh :) wow
05:15:45 <halfie> shachaf, other packages (almost all of them) don't have exec stack!
05:16:01 <mauke> also, there's another div showing the plain text, but it's made invisible on screen with css
05:16:51 <elliott> that explains why ski can't see it
05:17:06 <typoclass> at any rate, i think the current spam problem could be solved simply by "if it includes 'stooorage.com', reject it"
05:18:34 <typoclass> elliott: or maybe ski is a highly sophisticated spam bot with lots of interest in haskell? can't see simple captchas but knows everything about every ghc language extension
05:18:36 <typoclass> =)
05:19:03 <roconnor> forkOS makes a new process fork?
05:19:19 <luite_> no
05:19:29 <luite_> forkProcess does
05:19:32 <roconnor> ah
05:19:39 <luite_> forkOS just runs the IO action in a bound thread
05:19:41 <roconnor> good good
05:20:25 <elliott> @tell chrisdone typoclass notes that all current spam seems to include "stooorage.com" -- could you special case that? that would be enough to let the hpastebot speak again I think
05:20:25 <lambdabot> Consider it noted.
05:21:32 <typoclass> roconnor: see System.Process, System.Cmd, System.Posix.Process
05:21:48 <randomclown> @ddos stooorage.com
05:21:48 <lambdabot> Maybe you meant: docs do
05:22:06 <randomclown> that's unfortunate
05:22:07 * hackagebot bson-generic 0.0.8 - Generic functionality for BSON  http://hackage.haskell.org/package/bson-generic-0.0.8 (PetrPilar)
05:22:36 <typoclass> @tell chrisdone relatedly, disregard my earlier message; it was probably a bad idea, discussion in #haskell has shown
05:22:36 <lambdabot> Consider it noted.
05:31:50 <Aetherspawn> @where mtl
05:31:50 <lambdabot> www.cs.brown.edu/~jwicks/mtl_reference/
05:32:33 <elliott> haha, wow
05:32:34 <elliott> nice @where
05:33:13 <Aetherspawn> uh
05:33:17 <Aetherspawn> this isn't haskell tml
05:33:21 <Aetherspawn> I'm confused.
05:33:36 <mauke> @hackage mtl
05:33:36 <lambdabot> http://hackage.haskell.org/package/mtl
05:33:38 <typoclass> yeah, it's something called matrix template library
05:33:48 <SrPx> putStrLn $ show $ (map (\x->x*x) [1..]) !! 999999
05:33:49 <SrPx> (=
05:33:57 <Aetherspawn> I vote we change that
05:33:59 <Aetherspawn> to link here: http://www.haskell.org/haskellwiki/Monad_Transformer_Library
05:34:13 <Aetherspawn> since this /is/ the haskell channel and not the C++ channel ;_;
05:34:23 <SrPx> Oh wait, that doesn't work for much bigger numbers... why?
05:35:03 <Aetherspawn> > putStrLn $ show $ (map (\x -> (x :: Integer) *x) [1..]) !! 999999
05:35:04 <mauke> @where+ mtl http://www.haskell.org/haskellwiki/Monad_Transformer_Library
05:35:04 <lambdabot> It is stored.
05:35:05 <lambdabot>   <hint>:1:6: lexical error at character '\FS'
05:35:10 <mauke> no vote necessary :-)
05:35:27 <Aetherspawn> > (map (\x -> (x :: Integer) *x) [1..]) !! 999999
05:35:28 <lambdabot>   1000000000000
05:35:33 <Aetherspawn> > (map (\x -> (x :: Integer) *x) [1..]) !! 9999999999999
05:35:36 <lambdabot>   mueval-core: Time limit exceeded
05:35:51 <Aetherspawn> SrPx, you need to explicit cast to Integer
05:35:56 <mauke> Aetherspawn: no, you don't
05:35:59 <elliott> mauke: now it's going to turn out that people in some C++ channel pointed people to that daily
05:36:00 <mauke> Aetherspawn: and there are no casts
05:36:06 <Aetherspawn> er, infer.
05:36:08 <elliott> mauke: and there will be a riot
05:36:12 <mauke> good.
05:36:21 <ski> there are type ascriptions
05:36:30 <mauke> > (map (\x->x*x) [1..]) !! (maxBound + 1)
05:36:31 <lambdabot>   *Exception: Prelude.(!!): negative index
05:36:49 <SrPx> I don't understand you guys...
05:36:52 <Aetherspawn> lol. what.
05:36:59 <Aetherspawn> Oh, right, yeah it wraps around w/ +1
05:37:20 <SrPx> > (map (\x->x*x) [1..]) !! (maxBound - 1)
05:37:24 <lambdabot>   mueval-core: Time limit exceeded
05:37:37 <nooodl> :t (!!)
05:37:38 <lambdabot> [a] -> Int -> a
05:37:38 <SrPx> Listen, shouldn't it only calculate the mapping once?
05:37:43 <nooodl> > maxBound :: Int
05:37:44 <lambdabot>   2147483647
05:37:59 <elliott> SrPx: maxBound is a very big number.
05:38:03 <Aetherspawn> It'll only calculate the thing you !!
05:38:07 <Aetherspawn> due to lazy evaluation
05:38:09 <elliott> you do not get enough time to traverse that many cons cells in lambdabot
05:38:18 <SrPx> > (\x->x*x) (maxBound - 1)
05:38:19 <lambdabot>   No instance for (GHC.Show.Show a0)
05:38:19 <lambdabot>    arising from a use of `M2018429616.sh...
05:38:19 <Aetherspawn> or no?
05:38:36 <SrPx> > (\x->x*x) 2147483647
05:38:36 <lambdabot>   4611686014132420609
05:38:41 <SrPx> seems not to be the problem
05:39:09 <Aetherspawn> mauke, is it a lazy evaluation win
05:39:15 <SrPx> elliott: why would you have to transverse it? If it's lazy then it should just calculate for the last index
05:39:36 <SrPx> > [1..] !! 2147483646
05:39:38 <elliott> @src (!!)
05:39:38 <lambdabot> xs     !! n | n < 0 = undefined
05:39:38 <lambdabot> []     !! _         = undefined
05:39:38 <lambdabot> (x:_)  !! 0         = x
05:39:38 <lambdabot> (_:xs) !! n         = xs !! (n-1)
05:39:39 <lambdabot>   mueval-core: Time limit exceeded
05:39:42 <elliott> SrPx: lists are linked lists
05:39:55 <elliott> if you look at the above definition of (!!) you will see it recurses (maxBound - 1) times when you pass that argument
05:40:01 <elliott> i.e., (!!) is O(n) in the index
05:40:12 <SrPx> elliott: I thought they were generators?
05:40:15 <elliott> if you want something with random access use an array
05:40:23 <SrPx> so it actually creates a enourm list of ints?
05:40:44 <elliott> not necessarily.
05:40:52 <mauke> SrPx: probably not, but it still has to go through the motions
05:40:57 <elliott> it runs in O(1) space, in theory, because of garbage collection.
05:41:04 <randomclown> for the purposes of -O0 yes
05:41:13 <Aetherspawn> > take 1 $ drop (maxBound :: Int) [x * x | x <- [1..]]
05:41:17 <lambdabot>   mueval-core: Time limit exceeded
05:41:20 <Aetherspawn> @src drop
05:41:20 <lambdabot> drop n xs     | n <= 0 =  xs
05:41:20 <lambdabot> drop _ []              =  []
05:41:20 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
05:41:24 <Aetherspawn> Ugh
05:41:25 <SrPx> Look it doesn't make sense, [1..] should be a generator. Accessing it should be instantly for any n
05:41:27 <Aetherspawn> nope.jpg
05:41:38 <mauke> SrPx: no, [1..] is a generator. accessing it takes n steps
05:41:41 <typoclass> SrPx: it does create a list, go to its first element, then the next, then the next, and so on, for thousands of times
05:41:47 <SrPx> ...
05:41:54 <elliott> "create a list" is misleading
05:41:58 <elliott> it doesn't create the entire list
05:42:09 <randomclown> elliott: well it acts like it creates an entire list
05:42:13 <typoclass> elliott: right, it creates the first cons cell
05:42:21 <elliott> it creates a cons cell, takes its tail (first cons cell now garbage so can be freed), creates a cons cell, takes its tail (second cons cell now garbage), creates a cons cell, takes its tail (third cons cell etc)
05:42:27 <randomclown> in this case anyway because of strictness
05:42:33 <randomclown> but we don't need to go there right now
05:42:39 <elliott> ..., creates a cons cell, and finally takes its head (ten kajillionth cons cell now garbage)
05:42:40 <SrPx> but why would it do that if you are generating the list with a predictable formula? elliott
05:42:44 <nooodl> Data.Array's arrays have O(1) indexing, [] lists don't
05:42:46 <elliott> the compiler is not a mind reader
05:42:48 <elliott> you are using the wrong structure
05:42:53 <elliott> if you want random access, don't use []
05:42:59 <randomclown> nooodl: that's untrue, O(log n) for arrays.
05:43:14 <SrPx> elliott: but if I create an array then it will allocate the entire array, which is worse
05:43:22 <elliott> SrPx: okay. so use a function
05:43:25 <Aetherspawn> the best way might be to express your "generator" like so
05:43:28 <mauke> randomclown: what
05:43:38 <elliott> SrPx: use a memoised function if you want
05:43:44 <SrPx> ):
05:43:47 <typoclass> SrPx: i suggest you write a simple function for that. 1 argument, multiplies the argument by itself
05:43:53 <elliott> but it's pointless memoising (x*x), most likely
05:44:02 <elliott> *\x ->
05:44:16 <typoclass> SrPx: what are you planning to do?
05:44:17 <Aetherspawn> > let helper u l = map (join . (*)) [u..l] in helper 3 10
05:44:17 <elliott> you should be smiling! functions are much nicer than lists and arrays :)
05:44:17 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a1
05:44:18 <lambdabot>  Expected t...
05:44:27 <Aetherspawn> @pl (\x -> x * x)
05:44:28 <lambdabot> join (*)
05:44:35 <Aetherspawn> > let helper u l = map (join (*)) [u..l] in helper 3 10
05:44:35 <lambdabot>   [9,16,25,36,49,64,81,100]
05:45:18 <SrPx> elliott: I just don't get the point of lazy evaluation if it doesn't take those shortcuts
05:45:31 <elliott> well, this has very little to do with lazy evaluation.
05:45:32 <Aetherspawn> could a rewrite rule be written
05:45:35 <Aetherspawn> which helps this along?
05:45:37 <supki> > (length "join(*)", length "\\x->x*x")
05:45:39 <lambdabot>   (7,7)
05:45:40 <elliott> in fact lazy evaluation does make your (!!) version much better than it would be in a strict language
05:45:45 <elliott> since you get O(1) space usage
05:45:54 <mauke> SrPx: lazy evaluation doesn't take shortcuts
05:45:55 <SrPx> indeed, but not as good as it could
05:45:59 <elliott> it's as good as it could
05:46:05 <elliott> you asked the wrong question
05:46:18 <Aetherspawn> ^ rewrite rule Q
05:46:23 <elliott> it has an inherently slow answer modulo the compiler completely replacing the data structures you use based on intelligence you can't rely on
05:46:34 <randomclown> mauke: read somehwere that haskell arrays are not O(1)
05:46:42 <mauke> randomclown: you read wrong
05:46:53 <randomclown> mauke: got a source?
05:46:54 <Aetherspawn> I could imagine a rule which states that anything recursing over (x:xs) just to find a specific element given a generator can be substituted with [x..]
05:46:57 <alpounet> Aetherspawn, help this how?
05:47:03 <mauke> randomclown: no
05:47:16 <Aetherspawn> making the generator specific, and thus simulating O(1) ?
05:47:17 <randomclown> mauke: I'm struggling to find a source as well
05:47:27 <typoclass> SrPx: fundamentally, [1..] is a list. with (!!), you're going through the list from the beginning to the desired index. i don't know where you got the idea of generators from, but you would probably do that with a function in haskell. (a function taking 1 argument, and giving back the 'generated' value for that)
05:47:33 <mauke> randomclown: memory access itself isn't O(1) but that's a different issue
05:48:00 <elliott> lists are similar to python generators
05:48:04 <randomclown> mauke: and we were never talking about that
05:48:08 <elliott> of course, doing this with a python generator would be exactly as slow
05:48:18 <elliott> because you'd have to go thru all the "yield"s
05:48:27 <Aetherspawn> is this something that can be optimized with attention by ghc
05:48:36 <mauke> maybe SrPx doesn't know what a generator is?
05:49:04 <typoclass> mauke: be nice
05:49:32 <elliott> mauke's question seems reasonable to me
05:49:48 <mauke> typoclass: stop being a dick
05:50:36 <randomclown> SrPx has already decided lazy evaulation is some form of extreme optimisation
05:50:47 <SrPx> I haven't decided anything
05:51:15 <typoclass> elliott: i've already asked him where he got the idea of generators from. until we have the answer to that, i don't see the point of insulting srpx. the source could be python (which i don't know), or some other place, or srpx just colloquially used the word with no attached programming language definition
05:51:38 <elliott> mauke's question is not what an insult looks like...
05:51:40 <typoclass> mauke: how is it being a dick to say "be nice"?
05:52:33 <randomclown> SrPx: are you familiar with python generators?
05:53:24 <Aetherspawn> I'm going to run a few benchmarks on [a..] !! n
05:53:42 <Aetherspawn> and if it's still a problem under -O2 I think I should put a suggestion on trac
05:53:50 <elliott> I think you shouldn't
05:54:12 <randomclown> Array access is O(1), sourced, http://www.haskell.org/pipermail/beginners/2011-May/006948.html
05:55:00 <Aetherspawn> its novel that the whole list is generated starting from 1 or whatever
05:55:07 <SrPx> randomclown: not at all
05:55:20 <randomclown> SrPx: what languages are you familar with?
05:55:30 <elliott> SrPx: what did you mean by "generator"?
05:55:38 <elliott> the only kind of generator I know of is the kind Python has
05:55:48 <SrPx> elliott: that's just how we call functions in my native language, pardon
05:55:59 <elliott> oh.
05:56:04 <elliott> ok, that makes much more sense then
05:56:20 <elliott> (...and it seems to me that mauke's question got it on the mark here)
05:56:21 <SrPx> I'm trying to elaborate a better question
05:56:54 <Aetherspawn> what reasoning is there against optimizing at compile time (_:xs) on a list [n..] to [(n+1)..] ?
05:57:29 <Aetherspawn> and hence [1..] !! n would turn into [n..] taking O1 time
05:57:45 <elliott> huh?
05:57:50 <elliott> [1..] !! n is not [n..]
05:58:15 <Aetherspawn> Oh, I expressed that wrong
05:58:29 <randomclown> Aetherspawn: won't work for all lists. See tying-the-knot trick
05:58:38 <Aetherspawn> it would be [(n+c)..] !! (n-c)
05:58:47 <Aetherspawn> randomclown, saw tying the knot - I'll read it over again, thanks :)
05:59:42 <gspr> Aetherspawn: Are you really just saying that you'd like GHC to optimize indexing into lists of the form [n..]?
05:59:55 <SrPx> My understanding of lazy evaluation is that in a traditional language, sqr ([1..] !! bignum) would create a very big list, then access it's bignum nth element, then take it's sqr. While on Haskell, [1..] would just be interpreted as (\n->if n>=1 then n), or something similar. Then sqr ([1..] !! bignum) would be (sqr (\n->n) bignum)) which would pretty much be O(1)
05:59:57 <roconnor> The general problem with compile time evaluation of closed expressions is that (a) you don't know beforehand it will terminate (maybe you can do it with some difficult analysis)  and (b) you don't know if there will be an explosiion in size of the value.
06:00:29 <gspr> OK, my question now goes to SrPx instead
06:00:33 <SrPx> that's what I'm trying to say. Now, I understand [1..] is a list, but why it is a list, then, if it's generated (I mean, created - not as in python's "generator") by a predictable formula?
06:00:39 <Aetherspawn> gspr, Im saying that when it's clear that (_:xs) pattern is required
06:00:52 <elliott> roconnor++
06:00:55 <Aetherspawn> the compiler could assume that its a waste of time generating the beginning of the list
06:01:01 <Aetherspawn> since is ignored anyway
06:01:11 <elliott> roconnor: you also don't necessarily want to spend all that time
06:01:12 <Aetherspawn> @src (!!)
06:01:12 <lambdabot> xs     !! n | n < 0 = undefined
06:01:12 <lambdabot> []     !! _         = undefined
06:01:12 <lambdabot> (x:_)  !! 0         = x
06:01:12 <lambdabot> (_:xs) !! n         = xs !! (n-1)
06:01:18 <Aetherspawn> see the (_:xs)
06:01:25 <elliott> roconnor: I generally expect my program to be run at runtime :)
06:01:33 <roconnor> elliott: well, maybe a flag to control this sort of optimization.
06:02:13 <Aetherspawn> Does it still sound like stupid rambling or is it justified
06:02:14 <Aetherspawn> ;_;
06:02:18 <SrPx> gspr: yes, why not?
06:02:27 <randomclown> I don't think people actually write code like this [1..] !! n
06:02:38 <roconnor> but if one had an anaysis that entailed that evaluating a paricular constant would not increase the size of the output and would terminate I wouldn't mind a flag than enabled such an optimization.
06:02:41 <randomclown> and people recognise that it's bad code and will be slow
06:02:44 <SrPx> gspr: not in the form [n..] but anything expressed as a list comprehension could be optimized this way
06:02:53 <gspr> SrPx: I have no comment on that, except to say that we're then not really talking about lazy evaluations or lists anymore, but rather specific compiler optimizations for specific cases.
06:02:55 <Aetherspawn> randomclown, it would work on tail too
06:03:11 <Aetherspawn> I think
06:03:12 <SrPx> gspr: I don't understand the point on lazy evaluation, then
06:03:12 <Aetherspawn> @src tail
06:03:13 <lambdabot> tail (_:xs) = xs
06:03:13 <lambdabot> tail []     = undefined
06:03:19 <Aetherspawn> yes, it woud
06:03:29 <SrPx> gspr: and it's not specific, at all
06:03:32 <roconnor> elliott: sometimes I write code that I wish would be run at compile time.  With Haskell I'm usually satified that it will be executed at most once per invokation.
06:03:42 <randomclown> SrPx: like we discussed before lazy (read: non strict) evaluation is not about optimisation
06:03:56 <elliott> roconnor: right
06:03:57 <SrPx> randomclown: what is it about?
06:04:07 <typoclass> elliott: maybe 'insult' wasn't the correct word. but a reasonable question would have been e.g. "what do you mean by generator". i found it condescending to suggest that we have some established definition of 'generator', and srpx has violated it. i also found the question unnecessary because at the point, i already had said "i don't know where you got the idea of generators from" to srpx
06:04:11 <typoclass> ... anyway. whatever
06:04:15 <roconnor> lazy evalation in my mind is about modularity, though the reasons for this are not obvious and Hughs had to write an entire paper about it.
06:04:49 <randomclown> SrPx: it's just a particular way of evaluating things, a particular way of doing computations.
06:05:10 <elliott> typoclass: maybe you should have said that instead of just "be nice"? I didn't interpret mauke's question as implying there is an established definition of "generator", fwiw. if I talk about sdkjfhsdkfs without defining them, it's quite possible I don't know what a sdkjfhsdkfs really is. that doesn't mean it is something at all
06:05:29 <SrPx> randomclown: if it doesn't make any difference to the programmer writing the code then it's an implementation detail
06:05:55 <randomclown> SrPx: exactly. But programmers care about implementation details for optimisation purposes
06:06:02 <SrPx> ...
06:06:24 <elliott> SrPx: your question is also an implementation detail...
06:06:31 <elliott> it does give the correct result if you wait long enough.
06:06:33 <gspr> SrPx: Well, it makes  take n [1..]  run in finite time...
06:06:38 <SrPx> elliott: I never said it is not
06:06:48 <gspr> *lets
06:06:56 <elliott> laziness does make a difference to the programmer
06:07:01 <elliott> in that it means haskell has non-strict semantics
06:07:06 <elliott> which is important to many things
06:07:18 <elliott> like how you can write control structures as functions.
06:07:29 <tdammers> :t when
06:07:30 <lambdabot> Monad m => Bool -> m () -> m ()
06:07:32 <tdammers> \o/
06:07:51 <Aetherspawn> take 3 $ drop n $ whatever [1..] gets optimized into take 3 $ drop 0 $ whatever [(1+n)..]
06:07:55 <SrPx> Listen, I think you guys got it wrong, if lists were O(1) access I think ([..1] !! bignum) would be O(1) because of lazy evaluation
06:08:00 <Aetherspawn> and thus the drop decays
06:08:07 <Aetherspawn> so I don't see it as being that specific.
06:09:01 <roconnor> SrPx: with lazy evaluation one can write a producer in a separate module from a consumer and the producer does not have to be told in advance how much will be needed.  Exactly why you use generators in Python; only in Haskell it isn't only lists that are lazy, but everything is.  So you can do the same producer/consumer games say on a decision tree.
06:09:02 <randomclown> SrPx: lists are O(1) if you are reading the head. Access to any particular element of the list is still O(n) due to the way lists are
06:09:11 <elliott> SrPx: when people are trying to help you, it helps to not insist they're wrong...
06:09:16 <elliott> SrPx: lists are not O(1) indexing
06:09:44 <SrPx> elliott: I didn't say any of those two
06:10:11 <typoclass> SrPx: to reiterate, in haskell, i would do that by writing a function, not with a list and (!!)
06:10:13 <elliott> "if lists were O(1) access"
06:10:17 <elliott> indexing into a list with (!!) is not O(1)
06:10:26 <elliott> which is  what your code sample (if corrected to say [1..]) does
06:10:37 <elliott> I said as much earlier, even
06:10:43 <randomclown> elliott: no clearly he wants [maxBound...1] !! maxBound
06:10:59 <elliott> [maxBound..1] is [] anyway
06:11:14 <randomclown> elliott: I figured you'd look past the [maxBound,maxBound -1, ..1]
06:12:09 * hackagebot test-framework-golden 1.1.2 - Golden tests support for test-framework  http://hackage.haskell.org/package/test-framework-golden-1.1.2 (RomanCheplyaka)
06:13:08 <typoclass> SrPx: anyway. lists in haskell, which you write with [], are O(n) for indexing. think of linked lists, not of arrays. haskell has other data structures that have O(1) indexing
06:19:10 <SrPx> typoclass: I know, but you don't get my question (and it's my fault)
06:19:23 <SrPx> typoclass: I guess I know how to ask it now:
06:19:38 <SrPx> why can't generators return functions instead of linked lists?
06:19:52 <SrPx> ... s/generators/list comprehensions
06:19:53 <typoclass> elliott: alright, i see your point on this. still, if you start talking about sfdsaffad, my instinct would be to ask for clarification what that is, instead of aggressively suggesting that you don't even know. i said 'be nice' in light of earlier unhelpful questions like the cryptic one consisting of only a single "what". i think shapr's ground rule ('be nice') is obvious and universally agreed on around here
06:20:10 <elliott> SrPx: they can if you use the MonadComprehensions extension.
06:20:12 <randomclown> SrPx: I think it's because they are called list comprehensions, so only lists
06:20:15 <elliott> [x*x | x <- ask]
06:20:22 <elliott> compare [x*x | x <- [1..]]
06:20:27 <elliott> then
06:20:30 <elliott> [x*x | x <- ask] (maxBound - 1)
06:21:00 <ski> SrPx : you'd also need to keep track of size, no ?
06:21:26 <randomclown> But that's more of a syntax hack to get it do something else though
06:21:36 <typoclass> SrPx: right, your question is indeed clearer now :-) ... and what elliott said. list comprehensions are a special case of something called monad comprehensions, which are slightly more flexible, and can give you a function (instead of a list)
06:21:47 <ski> or perhaps you meant a function of type like `s -> Maybe (a,s)' (for some type `s') instead of a list of type `[a]' ?
06:21:55 <elliott> typoclass: well, I think telling people to "be nice" all the time is quite rude to them, especially when they're not obviously not being nice (I don't see mauke's question as aggressive at all)
06:22:10 * hackagebot cassandra-cql 0.2.0.0 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.2.0.0 (StephenBlackheath)
06:23:21 <SrPx> ski: you could infer the length, not? (\x -> if abs(x)<5 then x*x) has a length of 9, obviously. But I'm not sure if it would be possible for more complex functions
06:23:44 <Aetherspawn> @src drop
06:23:44 <lambdabot> drop n xs     | n <= 0 =  xs
06:23:44 <lambdabot> drop _ []              =  []
06:23:44 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
06:23:46 <SrPx> typoclass: oh
06:24:26 <SrPx> people I'm not offended at all, please
06:25:36 <Aetherspawn> even drop uses (_:xs) pattern
06:25:40 <ski> SrPx : the syntactical problem is that to `if' and `then', there have to go an `else'
06:26:29 <thisiswei> hey folks, I've done some tutorial on school of haskell, now I've know some basic, where should I go next?
06:26:48 <ski> SrPx : the semantical problem is as you say, hard to compute number of integers (if finite number) that a boolean predicate will return `True' for
06:26:48 <typoclass> SrPx: ok fine. it's more about a systematic ongoing thing of unhelpful questions that i've noticed in the past
06:27:11 <applicativ> hi thisiswei which tutorial is this?
06:27:47 <thisiswei> introduction to haskell
06:27:58 <elliott> @where lyah
06:27:58 <lambdabot> http://www.learnyouahaskell.com/
06:28:03 <elliott> try that
06:28:05 <ski> SrPx : it would probably be simpler to (a) restrict to non-negative integers (corresponding to list indices), and to require that if the given function has a valid value (when thought of as a sequence) for a particular index, then it also has to have valid values for all lesser (non-negative) indices
06:28:07 <typoclass> elliott: i guess we disagree on those points then. i did find it more aggressive than necessary. and i'm not sure how it's rude to remind someone of the rule of being nice
06:28:14 <applicativ> oh i see it thisiswei
06:28:27 <thisiswei> applicativ: some other 12 weeks haskell courses
06:28:50 <quchen> "be nice" implies not being nice, which is not nice if the other person wasn't not being nice.
06:29:06 <quchen> (And I didn't find it offensive at all.)
06:29:09 <elliott> typoclass: because it may be a communication error. there may be different perceptions and readings of what you're objecting to. "be nice" says: I am totally sure that you are being malicious in saying what you just said
06:29:15 <SrPx> ...
06:29:35 <ski> SrPx : consider e.g. `data Seq a = S Integer (Integer -> a)' with e.g. `S 4 ([2,3,5,7] !!)' representing the sequence `[2,3,5,7]'
06:29:46 <thisiswei> lambdabot: cool.
06:29:52 <elliott> (and someone who's a regular, an op even, surely is expected to know what appropriate behaviour is -- they don't need reminding that some guideline exists... but anyway, this is off-topic, so I'll drop it)
06:30:02 <quchen> thisiswei: Lambdabot is a bot. :-)
06:30:09 <applicativ> thisiswei: hm, have you met with concepts like 'fmap' or Functor?
06:30:18 <int-e> @botsnack
06:30:18 <lambdabot> :)
06:30:20 <SrPx> ski: yes?
06:30:30 <thisiswei> applicativ: no
06:30:52 <applicativ> ah, then maybe 'learn you a haskell'.  the beginning will be familiar already though.
06:31:04 <applicativ> @where lyah
06:31:05 <lambdabot> http://www.learnyouahaskell.com/
06:31:14 <typoclass> elliott: i think "be nice" says "i think you phrased that less nice than it could be". i don't think it suggests malice. but ok
06:31:28 <ski> SrPx : we could write functions `fromList :: [a] -> Seq a; toList :: Seq a -> [a]; (++) :: Seq a -> Seq a -> Seq a; take :: Integral i => i -> Seq a -> Seq a',&c.
06:31:28 <thisiswei> applicativ: yeah, it's overlapping.
06:31:40 <applicativ> thisiswei: oh you're reading it.
06:31:53 <applicativ> thisiswei: let me see how the chapters go
06:32:02 <ski> SrPx : and we could possibly consider list comprehension syntax (or something similar) expanding into calls to such functions
06:32:07 <thisiswei> applicativ: I've read most of the book, couple week ago, I forgot some.
06:32:56 <thisiswei> applicativ: I relearning haskell.
06:33:05 <Aetherspawn> ski, that could be another optimization all together
06:33:57 <thisiswei> thanks applicativ, imma read it again. off here
06:33:59 <elliott> ski: I think monad comprehensions adequately cover this type, no?
06:34:20 <applicativ> thisiswei: well, you need things like the functor concept and so on, then maybe something more practical?
06:34:24 <applicativ> oh
06:35:29 <thisiswei> applicativ: yeah. more practical.
06:36:05 <SrPx> ski: I see what you are doing, wouldn't that be better?
06:36:16 <SrPx> or just drop the requeriment to know a size, I don't know, do we need it?
06:36:31 <typoclass> SrPx: anyway, here is how i would write what you wanted originally. in your case i wouldn't bother with map and lists and list comprehensions http://hpaste.org/89783
06:36:33 <Aetherspawn> (the list thing under -O2 still yields no optimization: see http://hpaste.org/89784 for benchmark)
06:36:59 <applicativ> thisiswei: but chapters 8-13 of learn you a haskell should be worthwhile
06:36:59 <applicativ> I mean, at this point, having gone through byorgey 's series
06:37:18 <thisiswei> applicativ: cool!
06:38:07 <SrPx> typoclass: yea the problem is your replacement wouldn't work for things such as [x*x | x <- [1..12] | odd x | (x != 4)]
06:38:22 <ski> SrPx : if we don't store the size, how will we know when the elements in the sequence has ended ?
06:38:43 <elliott> :t [x*x | Just x <- ask, odd x, x /= 4]
06:38:44 <lambdabot> (Integral t, MonadReader (Maybe t) []) => [t]
06:38:53 <elliott> oh, do I have monadcomprehension off :(
06:39:06 <typoclass> SrPx: ok erm ... i don't think that's legal haskell :)
06:39:17 <ski>   fromList as = S (genericLength as) (genericIndex as)
06:39:19 <SrPx> eh, use colons, right? typoclass
06:39:22 <typoclass> SrPx: but you're right, this produces a list of square numbers
06:39:24 <elliott> maybe I shouldn't turn it on - do they default properly...?
06:39:28 <elliott> I guess they do if you source from [1..] or whatever
06:39:34 <ski>   toList (S n f) = [f i | i <- [0 .. n-1]]
06:39:41 <Aetherspawn> > [x*x | x <- [1..12], odd x, x != 4]
06:39:42 <lambdabot>   Not in scope: `!='
06:39:42 <lambdabot>  Perhaps you meant one of these:
06:39:42 <lambdabot>    `IM.!' (imported fro...
06:39:43 <typoclass> SrPx: (vs the original question, which produced a single number, not a list)
06:39:47 <Aetherspawn> > [x*x | x <- [1..12], odd x, x /= 4]
06:39:47 <lambdabot>   [1,9,25,49,81,121]
06:39:52 <ski> SrPx : how to write `toList' if we can't use the size `n' ?
06:40:16 <SrPx> ski: hm fair
06:40:45 <SrPx> ski: how do we limit the domain of a function, anyway?
06:40:48 <typoclass> > [x*x   |   x <- [1..],   odd x,   x /= 4] -- srpx, here is how i'd write that. spaces added only for clarity
06:40:49 <lambdabot>   [1,9,25,49,81,121,169,225,289,361,441,529,625,729,841,961,1089,1225,1369,15...
06:41:21 <merijn> Doesn't "odd x" already imply "x /= 4"?
06:41:26 <ski> SrPx : we don't, we just make sure we only apply it to (non-negative) integers less than the "size" argument `n'
06:41:42 <Aetherspawn> merijn, I don't think that's important to the point being ade
06:41:47 <SrPx> meretrix: woops odd is not what I thought it was, indeed
06:41:50 <typoclass> merijn: oooh, you just want everyone to know you have a phd in math, don't you
06:41:50 <Aetherspawn> but yes :P
06:41:51 <typoclass> =)
06:42:00 <SrPx> meretrix: sorry wrong nick
06:42:32 <typoclass> SrPx: 'odd' is a function that checks a number and gives True if it's odd, False if even
06:42:34 <ski> SrPx : btw, for `Seq' we'd need to keep track of how many elements the sequence contains. for ordinary lists, we wouldn't (the size "keeps track of itself")
06:42:35 <merijn> typoclass: Except I don't have a phd, let alone in math :(
06:42:38 <typoclass> > odd 123
06:42:39 <lambdabot>   True
06:42:45 <SrPx> typoclass: no I actually mean, I confused odd with even
06:42:48 <SrPx> but nevermind
06:43:15 <thisiswei> applicativ: do you use vim?
06:43:18 <SrPx> ski: how do we limit the domain of a function in haskell
06:43:22 <typoclass> merijn: i know. i was just kidding :) it was the direct translation of what was asked for. i thought it was a syntax question about list comprehensions
06:43:38 <typoclass> > even 123 -- SrPx: that function is available as well
06:43:39 <lambdabot>   False
06:43:53 <SrPx> I know thanks!
06:44:18 <SrPx> > 6 % 2 == 0
06:44:19 <lambdabot>   False
06:44:44 <yitz> > let odd = even in odd 123
06:44:45 <lambdabot>   False
06:45:02 <SrPx> I don't know
06:45:06 <typoclass> yitz: very good. it's completely clear now =)
06:45:09 <Aetherspawn> > let (+) = (-) in 1+1
06:45:10 <lambdabot>   0
06:45:13 <Aetherspawn> lol'd
06:45:22 <SrPx> for example, shouldn't the compiler know that those are equivalent?
06:45:36 <SrPx> > (\x -> 2*x) == (\x -> x+x)
06:45:38 <SrPx> ^^
06:45:38 <lambdabot>   No instance for (GHC.Num.Num a0) arising from a use of `GHC.Num.*'
06:45:39 <lambdabot>  The typ...
06:46:34 <Aetherspawn> > foldWith (==) $ map (\n -> (\x -> 2*x) n == (\x -> x+x) n) [1..]
06:46:35 <lambdabot>   Not in scope: `foldWith'
06:47:53 <ski> SrPx : in general, it's impossible to decide whether two functions are equal or not
06:47:55 <fruitFly> what is &&&
06:47:57 <fruitFly> ?
06:48:28 <mr-> :t (&&&)
06:48:29 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
06:49:09 <ski>   (f &&& g) a = (f a,g a)
06:49:17 <ski> is the usual version of it that's used
06:49:20 <thisiswei> anybody use vim here, how do i make newline and ' | ' indent the right way, any haskell.vim I can clone ?
06:49:33 <ski> > (sum &&& length) [2,3,5,7]
06:49:34 <lambdabot>   (17,4)
06:51:56 <SrPx> ski: why?
06:52:41 <SrPx> ski: It's trivial for a human to determine that those are equivalent. Why is it so hard for a computer?
06:53:01 <elliott> you, the human, cannot determine whether any two pairs of functions are equal
06:53:04 <elliott> similarly for the computer
06:53:18 <elliott> it is possible to determine that *some* functions are equal
06:53:30 <elliott> for instance, I bet Mathematica can tell that 2*x = x+x for all x.
06:53:36 <elliott> Haskell is not in that business
06:53:41 <typoclass> SrPx: in a few cases, it's easy (like 2*x and x+x), but for most functions not
06:55:11 <Aetherspawn> > let x = 7 in (x*2, x+x, x<<1)
06:55:13 <lambdabot>   Not in scope: `<<'
06:55:13 <lambdabot>  Perhaps you meant one of these:
06:55:13 <lambdabot>    `=<<' (imported from...
06:55:22 <Aetherspawn> > let x = 7 in (x*2, x+x, x `shiftL` 1)
06:55:25 <lambdabot>   (14,14,14)
06:55:40 <Aetherspawn> I think the shiftL is fastest for the machine
06:55:49 <SrPx> typoclass: which are those cases and why are them easy?
06:56:36 <elliott> the easy cases are those that we have figured out how to do.
06:56:37 <typoclass> SrPx: i have no idea. i wouldn't be surprised if that's an open research problem, or involves the halting problem
06:56:45 <elliott> they are easy because we know how to do them
06:56:47 <Aetherspawn> supercompilation?
06:56:53 <SrPx> typoclass: probably ... interesting
06:57:22 <typoclass> SrPx: (this isn't a thing about haskell, it's about any programming language)
06:57:40 <SrPx> typoclass: true.
06:58:06 * Aetherspawn thinks that problem could actually be solved on an extremely low level by reducing everything to nand (including the operations of addition, multiplication, etc) then karnaugh mapping it and un-reducing it
06:58:10 <Aetherspawn> but it would be ineffecient.
06:58:25 <SrPx> typoclass: haskell does some dark magic just like that, that no other language does, though, so it's not surprising I'm trying to see how far it goes
06:58:51 <byorgey> even dark magic cannot accomplish the logically impossible =)
06:59:10 <elliott> Aetherspawn: it is not possible to decide whether two functions are equal
06:59:11 <SrPx> Aetherspawn: maybe?! That's cool, is a nand representation irredutible?
06:59:15 <typoclass> byorgey: well, except edwardk. his dark magic can.
06:59:16 <elliott> this holds no matter how you encode them.
06:59:21 <elliott> this is a proven theorem
06:59:33 <SrPx> elliott: which, please
06:59:38 <elliott> it's not, "we don't know how to tell whether two functions are equal", it's "we know there is no general way to tell whether two functions are equal"
06:59:39 <byorgey> Aetherspawn: that would would for functions with a finite set of inputs.
06:59:44 <byorgey> *would work
06:59:50 <elliott> rice's theorem
07:00:00 <Aetherspawn> it would work for numerics only maybe
07:00:08 <Aetherspawn> finite numerics.
07:00:11 <byorgey> sure.
07:00:15 <elliott> byorgey: and whose outputs have decidable equality
07:00:23 <byorgey> elliott: good point.
07:00:35 <elliott> (they could output computable reals, for example)
07:00:59 <SrPx> elliott: that could be true, but x+x and 2*x are certainly in a subset of functions where it is possible to determine wheter 2 functions are equal, though.
07:01:19 <elliott> this is true.
07:01:35 <SrPx> which is that subset would be an interesting question
07:01:52 <SrPx> and if a generic programming language could be done within it would be another
07:02:39 <gspr> Suppose I have a function with type  a -> b  that really needs to have signature  (Foo a) => a -> b. Is there a way to say to GHC "I know I'm missing a constraint, but please just compile anyway for now, and I swear I'll only use the function in cases where indeed a is an instance of Foo?"
07:02:43 <supki> how would you determine that \x -> x + x = \x -> 2 * x for computable reals?
07:02:54 <gspr> (my use case is debugging, not wanting to pepper my code with Show a temporarily)
07:03:19 <yitz> gspr: Debug.Trace
07:03:22 <enigmuriatic1> how do i use an applicative without mapping it over the values? for example, i'm trying to unpack a bytestring, but when i attempt to use the unpack function on the bytestring it wants to return a character rather than a string
07:03:33 <typoclass> gspr: hm, good question
07:03:46 <elliott> gspr: you can use cpp hacks.
07:03:55 <elliott> foo :: AUGH(a) a -> b
07:04:03 <elliott> and #define AUGH(a) appropriately.
07:04:04 <gspr> yitz: I use Debug.Trace, yes, but together with show. Hence the wish to temporarily pretend all my functions have an implicit Show a constraint
07:04:07 <SrPx> supki: you could start with a set of axioms and do the shuffling
07:04:13 <gspr> elliott: Alright, thanks
07:04:24 <elliott> supki: with a lot of proof.
07:04:31 <supki> well, like in coq?
07:04:41 <elliott> supki: with a lot of proof :)
07:04:43 <SrPx> I love when people throw googlable terms at me.
07:05:12 <elliott> supki: I could give a shot at writing up how to do it if you'd like. I recall it being quite easy, though of course opaque if you don't know Coq and how the standard computable reals defn work
07:05:15 <typoclass> gspr: i'm tempted to use the "u-" word in this case ...
07:05:24 <SrPx> supki: hm yea, kind of. Maybe restricting the language to a subset of functions which are easy to prove equal with the theorical background we got already
07:05:33 <supki> elliott: well, I believe that's possible :)
07:05:52 <enigmuriatic1> how do i use an applicative without mapping it over the values? for example, i'm trying to unpack a bytestring, but when i attempt to use the unpack function on the bytestring it wants to return a character rather than a string
07:06:00 <SrPx> elliott: oh I would definitedly enjoy that
07:06:53 <typoclass> enigmuriatic1: do you have some code for hpaste? include the error message please. it's a bit hard to tell based on your question
07:07:34 <enigmuriatic1> typoclass, for example this in GHCi: fmap BL.pack "hehehe"
07:08:13 <enigmuriatic1> typoclass, that one expects [[Char]] but gets [Char], i don't understand why
07:09:05 <supki> enigmuriatic1: what do you expect from  fmap BL.pack "hehehe" ?
07:09:06 <elliott> supki: actually, it is more annoying than I remember. but I bet one of the existing Coq formalisations of real numbers proves it
07:09:27 <typoclass> enigmuriatic1: well ... fmap works like map in this case
07:09:31 <typoclass> > fmap toUpper "lol"
07:09:32 <lambdabot>   "LOL"
07:09:44 <enigmuriatic1> typoclass, is there any way to prevent that?
07:09:52 <typoclass> enigmuriatic1: the string literal ("...") is a list of Chars, i.e. a [Char]
07:09:58 <enigmuriatic1> do i just put my string in brackets? that seems like a bit of a hack
07:10:33 <typoclass> enigmuriatic1: well you could just use «BL.pack "abc"» without the fmap
07:10:37 <enigmuriatic1> i understand how strings are represented in haskell, but i don't understand how to elegantly use applicatives on strings if they get mapped over each character
07:10:53 <enigmuriatic1> typoclass, does that do applicative?
07:11:20 <typoclass> enigmuriatic1: i'm still unclear what you mean by "use applicatives on strings". i think some example code on hpaste would help
07:11:57 <enigmuriatic1> typoclass, the example i gave you is what i want to do (albeit unpacking). I just want to take an IO Bytestring and turn it into an IO String
07:12:27 <elliott> enigmuriatic1: note that that operation is not very well-defined
07:12:41 <elliott> in particular, the Char8 unpack will produce invalid Strings
07:13:06 <enigmuriatic1> elliot, why?
07:13:23 <elliott> enigmuriatic1: because ByteString is not String
07:13:28 <elliott> ByteString is a flat blob of Word8s
07:13:34 <elliott> String is a lazy linked list of Chars
07:13:44 <elliott> Word8 is not Char; there are many more Chars, and the two types are not semantically equal
07:13:52 <elliott> for efficient text, you should use the Text type, not ByteString.
07:14:00 <enigmuriatic1> so how should i turn a bytestring into a string?
07:14:06 <enigmuriatic1> i need to do so to call a function
07:14:17 <elliott> perhaps decode it as UTF-8?
07:14:22 <typoclass> enigmuriatic1: oh, i see. "lifting" is the term =)
07:14:32 <elliott> you should think about the types you are using and what they mean. don't write broken code by assuming all the world's ASCII.
07:14:36 <typoclass> enigmuriatic1: have you seen this? http://hackage.haskell.org/packages/archive/utf8-string/0.3.4/doc/html/Data-ByteString-Lazy-UTF8.html specifically, function toString
07:15:03 <typoclass> enigmuriatic1: it'll work on utf8-encoded bytes, which most likely is what you have as the input. right?
07:15:21 <supki> I think utf8-string is deprecated?
07:15:35 <elliott> if you have to call a function which expects a String, maybe you should just use Strings all the way
07:15:37 <typoclass> supki: interesting! haven't heard of this
07:15:40 <elliott> since you are giving up a lot of the performance/space-use benefits
07:16:36 <enigmuriatic1> typoclass, i'm not sure. how would i apply toString to an IO ByteString though?
07:16:36 <typoclass> enigmuriatic1: and yes, elliott is asking a reasonable question. how did you end up using ByteStrings in the first place? you're reading from a network library or something ...?
07:16:50 <enigmuriatic1> typoclass, Aeson uses bytestring
07:17:05 <enigmuriatic1> but System.Process uses String
07:17:28 <typoclass> enigmuriatic1: ok, if aeson can't be made to decode that for you, then it's reasonable that you need to convert from ByteString to String. (which as we said requires you to specify the encoding)
07:17:41 <yitz> gspr: interesting. I tried this, with ScopedTypeVariables:
07:17:47 <yitz> traceShow (unsafeCoerce x :: Show a => a) x
07:18:09 <yitz> gspr: i get "Ambiguous type variable"
07:18:24 <typoclass> supki: what's the suggested replacement? on http://hackage.haskell.org/package/utf8-string-0.3.7 i can't find a deprecation notice or link to a new package
07:18:40 <yitz> gspr: seems like there should be some way to do it like that though
07:19:02 <enigmuriatic1> i really appreciate the help, but i need to get this done quickly. how do i convert an IO bytestring to an IO string?
07:19:12 <yitz> gspr: using unsafeCoerce seems to be saying exactly the "I promise..." that you said
07:19:14 <supki> typoclass: text and text-icu, I think
07:19:58 <yitz> supki: usually you shouldn't need text-icu, if you are just using utf-8
07:19:59 <typoclass> enigmuriatic1: try "fmap U.toString", if you have "import Data.ByteString.UTF8 as U"
07:20:55 <elliott> I think Aeson can use Tetx.
07:20:57 <elliott> Text
07:21:01 <elliott> which is easier to convert to String
07:21:16 <elliott> indeed it depends on text. and same author of course
07:21:18 <elliott> so you should try to do that
07:21:25 <typoclass> supki: hm i see. http://hackage.haskell.org/packages/archive/text/0.11.3.1/doc/html/Data-Text-Lazy-Encoding.html seems to suggest you'll end up with a Text, which you'd still have to convert to String
07:21:48 <elliott> yitz: a promise isn't enough
07:21:56 <elliott> it can't simply forget about the dictionary parameter
07:21:59 <elliott> it would still have to pass it
07:22:13 <elliott> coercing away the parameter is possible with ugly wrapper data types but all you will get is segfaults
07:22:59 <yitz> elliott: ah you say that the dictionary parameter - which did exist - has already been stripped away by the time we get there
07:23:35 <elliott> I mean that you can't just turn a into (Show a *> a), using ski's terminology
07:23:39 <elliott> and traceShow requires the latter
07:23:47 <elliott> s/terminology/notation/
07:23:56 <elliott> you would need the compiler to cooperate by filling in the instance dictionary
07:23:59 <elliott> if you want this evil to work
07:24:06 <yitz> elliott: aeson uses bytestring for its input, not text, but can produce Text for its output
07:24:16 <elliott> right
07:24:27 <elliott> so I think enigmuriatic1 should not need ByteString -> String at any point
07:24:43 <yitz> elliott: agreed
07:25:00 <typoclass> supki: anyway, i think we can continue using utf8-string until the author adds a deprecation warning to the package, and suggests a replacement package
07:26:10 <yitz> typoclass: i suggest you stay away from utf8-string. it is very old, not the right approach, not sure how well supported anymore. even without the official deprecation notice.
07:26:27 <typoclass> yitz: hm ok ...
07:26:29 <enigmuriatic1> http://hpaste.org/89786
07:26:34 <enigmuriatic1> that's what i'm getting
07:28:26 <yitz> enigmuriatic1: why <*> ?
07:28:34 <enigmuriatic1> ah right
07:28:44 <enigmuriatic1> i just took the IO out before pasting that
07:28:53 <yitz> got it :)
07:29:07 <typoclass> yitz: any ideas about a replacement? hayoo finds only utf8-string and various utility functions deep inside of darcs, pandoc and such http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:ByteString%20-%3EString
07:29:21 <enigmuriatic1> dear lord it compiled
07:29:26 <enigmuriatic1> that only took 2.5 hours
07:29:51 <yitz> typoclass: use Data.Text.Encoding. or text-icu if you anything fancier thant utf-2^n
07:30:02 <yitz> *need
07:30:45 <typoclass> yitz: ok. so ByteString to Text, then Text to String?
07:31:48 <elliott> enigmuriatic1: again, you should not have a ByteString here
07:31:48 <yitz> typoclass: if you really must have a String, then yes, use Data.Text.unpack.
07:31:52 <elliott> enigmuriatic1: aeson gives you Text
07:31:55 <typoclass> yitz: right
07:33:13 <enigmuriatic1> elliott, technically it's because i'm using bytestrings by default now. Block is a custom data type, so when i make a function call that returns a block's field, that field is returned as a Bytestring
07:33:39 <yitz> we are using text-icu, and it has really caused us problems. ffi bindings are a pain when you want to support linux mac and windows all at once.
07:33:45 <Porthos> breaker on the side
07:33:51 <enigmuriatic1> i guess i could make String the default and then convert to Bytestring before feeding System.Process data into Aeson, but that would be sort of the same thing
07:34:15 <yitz> on the other hand, re-inventing the gigantic wheel of the ICU library isn't really on our agenda either.
07:34:23 <supki> enigmuriatic1: what does that block's field contain?
07:34:32 <supki> enigmuriatic1: if it's text you should use Text
07:34:34 <enigmuriatic1> supki, text
07:34:39 <enigmuriatic1> why?
07:34:40 <supki> =)
07:34:55 <elliott> yitz: someone should do it so that Text can stop using UTF-16!
07:35:05 <enigmuriatic1> i'd have to convert the Text to a string anyway, right?
07:35:34 <supki> that's easier than converting bytestrings
07:35:34 <yitz> elliott: why?
07:35:54 <elliott> yitz: I hate UTF-16 :)
07:35:58 <elliott> a lot of the reason Text uses it is for ICU compatibility
07:36:55 <yitz> elliott: no. there was a lot of work done on that about two years ago. heavy benchmarking, etc. even with a heavy bias towards non-asian languages, utf-16 is still the best to use internally.
07:37:28 <yitz> elliott: and with asia becoming quickly dominant, it would be silly to move to utf-8 internally at this point.
07:37:44 <yitz> in my opinion anyway
07:38:29 <elliott> yitz: I would also be OK with a move to UTF-32; I didn't say UTF-8
07:38:42 * typoclass . o O ( as long as it's got a nice external interface as is fast, it can use anything it wants internally. it can use backwards multishredded utf-19.6 for all i care )
07:38:45 <yitz> elliott: ahh that's your issue. i see.
07:39:44 <yitz> elliott: yeah, once the internet finishes making everyone brain dead and writing only emoji, utf-16 will be quite inefficient
07:39:53 <elliott> (I'm not sure UTF-8 would inherently be slower than UTF-16 with lots of attention paid to it, though)
07:40:01 <elliott> (not that I'm offering to pay with my own attention :) )
07:40:19 <elliott> yitz: even lambdabot does emoji now
07:41:03 <elliott> > text [chr 0x1f300..]
07:41:04 <lambdabot>   🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌍🌎🌏🌐🌑...
07:41:06 <yitz> elliott: hard to imagine it wouldn't be slower if a high enough percentage of characters are exactly two bytes
07:41:37 <yitz> elliott: invisible in my font :(
07:41:49 <dmwit> I thought the benchmarks showed that UTF-8 and UTF-16 had basically identical performance in terms of speed, and therefore the cost of switching wasn't worth it.
07:41:53 <dmwit> Not that UTF-16 was *better*.
07:42:09 <elliott> yitz: and question marks in triangles in mine, though irssi or mosh may be to blame
07:42:22 <elliott> dmwit: that is also what I recall, and that ICU gave a compelling reason to keep the status quo
07:42:38 <dmwit> (Since the hypothesis before the benchmarks was that using UTF-8 internally would make blitting to web servers and such blazing fast.)
07:43:02 <yitz> > text $ "my font is a " ++ [chr 0x1f4a9]
07:43:03 <lambdabot>   my font is a 💩
07:43:20 <typoclass> heh, it seems to have cut in the middle of a character. there's 3 stray bytes shown as "?", then "..."
07:43:50 <dmwit> > text "α"
07:43:51 <lambdabot>   α
07:44:12 <yitz> elliott: yeah im also in irssi. running in urxvt.
07:44:22 <elliott> typoclass: it shows more in the logs. they overlap heavily in my terminal or something
07:44:25 <typoclass> lambdabot seems to have regained the ability to use non-ascii characters as input
07:44:32 <dmwit> Hooray, the official bot does UTF-8 now.
07:44:35 <elliott> yitz: irssi in mosh in Apple's crappy terminal, here
07:44:39 <elliott> dmwit: only partly, alas
07:44:43 <elliott> :t 'α'
07:44:44 <lambdabot>     lexical error in string/character literal at end of input
07:44:59 <dmwit> Why do > and :t go through such different paths? =(
07:45:03 <elliott> lambdabot's handling of text is broken beyond belief. it is complete nonsense
07:45:15 <elliott> dmwit: because > passes it to mueval and :t pipes it into GHCi
07:45:20 <yitz> elliott: switched from colloquy to limechat on my mac. seems ok so far. (have tried emoji yet though :))
07:45:21 <dmwit> why? =(
07:45:28 <elliott> and lambdabot stores its input as byte strings ... using String
07:45:41 <elliott> with the > path, it so happens that it gets decoded as UTF-8 on the other side, I guess.
07:45:42 <typoclass> elliott: for me it was a bunch of gtk's little rectangles with hex codes in them ("font doesn't have a character for that"), then "???", then "..."
07:45:45 <dmwit> Well, lambdabot predates bytestring, presumably.
07:45:50 <elliott> lambdabot uses ByteString.
07:45:54 <elliott> in fact it used to use ByteString to store text sometimes.
07:45:55 <elliott> maybe it still does.
07:46:02 <elliott> any mess you can have, lambdabot has had it
07:46:02 <yitz> elliott: it was state of the art when lambdabot's code was last being maintained
07:46:03 <dmwit> irrelevant
07:46:15 <dmwit> exactly
07:46:18 <elliott> well, lambdabot shouldn't even want to be storing IRC input as a byte string
07:46:26 <elliott> it should be using String or Text and decoding the damn things :)
07:46:26 <dmwit> What? Why?
07:46:32 <dmwit> IRC is ByteString
07:46:42 <dmwit> Any illusion otherwise is coming from your client.
07:46:53 <elliott> IRC transports ByteStrings. the agents on it give those ByteStrings meaning by decoding them as text
07:47:18 <fizbin> Does IRC specify an encoding?
07:47:22 <dmwit> no
07:47:37 <elliott> fizbin: no. but UTF-8 is on top (at least on freenode), followed by everything imaginable.
07:47:42 <typoclass> fizbin: i guess most people use utf8 these days, so that wouldn't be a bad default
07:47:53 <elliott> if you try to decode as UTF-8 and then a few common encodings if that fails, then you'll get 90% of stuff
07:47:57 <yitz> irc is a victim of microsoft-style embrace and extend. i'm not sure by who though.
07:48:07 <elliott> and the suffering of the rest is justified, because it may convince them to fix their client!
07:48:08 <geekosaur> by pretty much everyone
07:48:29 <geekosaur> "oh, IRC doesn't do that, guess we'll add our own extension"
07:49:01 <typoclass> we should write a 1-line rfc. "This updates the RFC that describes IRC. IRC uses UTF-8 as the encoding. Kthxbai."
07:49:24 <yitz> elliott: like big5 and jis, for example.
07:49:38 <elliott> yitz: yes
07:49:45 <elliott> yitz: those are in the list of "few common encodings" that you should try after UTF-8
07:49:47 <typoclass> geekosaur: you mean e.g. those sequences that most clients interpret as switching the text color?
07:49:58 * Aetherspawn , no offense to elliott, put a feature request on the trac outlining that thunk generation could be prevented for (_:xs) list matches
07:50:01 <geekosaur> among others, yes
07:50:04 <elliott> anyway, I would like to rationalise lambdabot's text handling by making it decode ASAP
07:50:07 <elliott> and preferably to Text
07:50:14 <elliott> it is on my list of things to look into
07:50:30 <fizbin> Huh. http://forum.xchat.org/viewtopic.php?t=3180
07:50:37 <elliott> and then when I do that -- I bet @run, one of the few commands handling Unicode correctly, will become one of the few that don't!
07:50:39 <geekosaur> and the fact that the IRC protocol only does octet streams, so anything even remotely resembling locale is done by clients (as current discussion)
07:50:50 <elliott> and I will cry.
07:51:01 <yitz> elliott: the easiest way to rationalise lambdabot's text handling would be by rewriting lambdabot
07:51:05 <elliott> fizbin: that XChat encoding is evil, eevil, eeevil!
07:51:09 <elliott> I hate it.
07:51:24 <fizbin> It's sending side is. It's receiving side not so much.
07:51:25 <elliott> yitz: eh. I don't think so. mokus has done a fine job of cleaning up and massively reorganising the code
07:51:36 <elliott> yitz: it almost looks like a half-respectable codebase now.
07:51:47 <elliott> I mean, a rewrite would be nice. but I don't think it's necessary
07:51:50 <yitz> elliott: oh? i didn't hear about that. it is very good news.
07:52:21 <elliott> yitz: take a look at https://github.com/mokus0/lambdabot (the lambdabot released on hackage also by mokus has some clean ups, but the git version has more (and is what lambdabot is running on, w/ patching))
07:52:39 <yitz> nice
07:53:09 <yitz> weird. why isn't the git version uploaded then?
07:53:31 <elliott> yitz: it's not ready for release yet
07:53:39 <fizbin> elliot: The sensible encoding I think you want (UTF-8 out, UTF-8 `catch` windows-1252 on the way in) is what xchat does with the "UTF-8" encoding.
07:53:46 <elliott> yitz: like, I found a few bugs related to the split of packages setting it up (they were fixed quickly)
07:53:57 <elliott> and it is patched because otherwise it would not respond to > in /msg
07:54:15 <elliott> fizbin: yes, that's how I configured XChat when I used it
07:54:34 <elliott> I have no idea why they thought sending non-UTF-8 but only sometimes by default was ever a good idea.
07:55:49 <geekosaur> because windows
07:56:11 <typoclass> geekosaur: probably more like "because mirc"?
07:56:17 <geekosaur> it's trying to accommodate windows IRC clients (probably mIRC) that don't support UTF8
07:58:40 <elliott> I bet mIRC can be configured to do UTF-8 these days
07:58:43 <geekosaur> typoclass, mainly, yes, but I imagine (older? since modern windows is unicode aware) other IRC clients have similar issues. and unixy irc clients are more likely to do encoding properly because more unixy devs care
07:59:47 <geekosaur> or should I say there are more people who have the ability to deal with it on unixy platform
07:59:48 <geekosaur> s
08:00:11 <typoclass> geekosaur: i dunno, that seems like a very broad claim ...
08:01:03 <elliott> (I wish unixy devs cared!)
08:01:14 <geekosaur> why? it's an expression that the most common windows irc clients are closed source and many of them expect the microsoft toolchain instead of cygwin/mingw
08:02:43 <fizbin> I'm a bit surprised that there didn't develop a convention in room messages saying "this channel uses utf-8" or similar.
08:04:44 <typoclass> geekosaur: mirc's changelog claims utf-8 decoding was added 7 years ago. i don't know if it defaults to that or if the user has to change a setting
08:05:15 <geekosaur> yes, but many people use versions of mirc from before that because they weren't shareware/payware
08:05:51 <elliott> so, it was added in the same year as XChat's abomination, heh
08:07:28 <typoclass> geekosaur: i don't know the reasoning of the xchat people, but if it was "let's not use utf8, let's first try cp-whatnot, only when that fails use utf8, this way some windows users don't need to change that setting", then in my opinion it wasn't very convincing reasoning. it's likely to prolong the mess, not promote the adoption of utf8
08:08:24 <geekosaur> I think the point of it was more that many attempts at trying to get masses of windows users to use utf8 had been overwhelming failures
08:08:40 <fizbin> To be fair, I remember that back in the early 2000s it wasn't clear that utf-8 was the way to go.
08:09:16 <elliott> I think UTF-8 isn't as dominant elsewhere as on freenode.
08:09:21 <elliott> but why would you want to be on another network.
08:09:53 <typoclass> fizbin: yeah, it's funny isn't it. the early adopters (windows, java) went with utf16 and got into a difficult place, while the late adopters (linux) went with utf8 and had it better
08:10:46 <enigmuriatic1> say i have a custom type Block, a value of type IO (Maybe Block), and a function that takes a parameter of type Maybe Block. how do i apply the function to the value?
08:11:03 <dmwit> Lift the function into the IO monad with fmap or (>>=).
08:11:04 <enigmuriatic1> i know i need an applicative but the syntax doesn't seem to work
08:11:05 <dmwit> :t fmap
08:11:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:11:07 <dmwit> :t (>>=)
08:11:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:11:21 <dmwit> Applicative is fine, too; you can use (<$>) as a synonym for fmap.
08:11:35 <fizbin> typoclass: it's not so much that java and windows went with UTF-16 as that they went with UCS-2, and then were left screwed when UCS-2 was insufficient.
08:12:24 <typoclass> fizbin: yes, a 2-byte encoding, then it turned out that wasn't enough space, the surrogates got added, and the "2 bytes per character" invariant was broken. at which point you might as well use utf8
08:12:43 <elliott> > 'I' < 'R'
08:12:43 <lambdabot>   True
08:13:33 <fizbin> Basically, they bought into early-1990s Unicode Consortium BS, and believed that all was fine after UniHan came out. (also known as the CJK unification)
08:13:40 <typoclass> enigmuriatic1: you don't need to do everything with fmap, there's no law against a do block with "<-" and stuff :)
08:13:59 <typoclass> enigmuriatic1: also, it'll help if you put code on hpaste.org
08:14:17 <Hafydd> You'd want to be on another network in order to engage in anything that isn't http://freenode.net/policy.shtml#ontopic
08:15:02 <elliott> :t first
08:15:03 <lambdabot>     Ambiguous occurrence `first'
08:15:03 <lambdabot>     It could refer to either `Control.Arrow.first',
08:15:03 <lambdabot>                              imported from `Control.Arrow' at /home/lambdabot/.lambdabot/State/L.hs:32:1-20
08:15:05 <elliott> :t (<>)
08:15:06 <lambdabot>     Ambiguous occurrence `<>'
08:15:06 <lambdabot>     It could refer to either `Data.Monoid.<>',
08:15:06 <lambdabot>                              imported from `Data.Monoid' at /home/lambdabot/.lambdabot/State/L.hs:60:1-18
08:15:09 <enigmuriatic1> i don't understand why fmap always wants a list. what if i want to apply a functor to only one value?
08:15:09 <elliott> yuck
08:15:49 <typoclass> enigmuriatic1: what do you mean by "apply a functor to only one value"?
08:16:04 <elliott> :t foldr'
08:16:05 <lambdabot>     Not in scope: foldr'
08:16:05 <lambdabot>     Perhaps you meant one of these:
08:16:05 <lambdabot>       BS.foldr' (imported from Data.ByteString),
08:16:08 <dmwit> enigmuriatic1: Presumably you are using the result of calling fmap as if it were a list somehow, and GHC is therefore inferring that its second argument must be a list.
08:16:09 <elliott> ...should do this in /msg
08:16:24 <enigmuriatic1> take a value of type IO (Maybe Block) and apply a function to it that takes a parameter Maybe Block
08:16:29 <dmwit> enigmuriatic1: If you instead use the result of calling fmap as if it were an IO action, then GHC will infer that its second argument must be an IO action.
08:16:44 <fizbin> Ironically, the computer language that seemed to come through the whole decades-long ASCII byte->ucs-2->oops, ucs-4 or utf-8 transition best is Common Lisp, because it was standardized when people still weren't totally and completely sold on the whole 8-bit byte thing.
08:16:51 <yitz> Hafydd: well the topic of #haskell-blah is anything that haskellers want to discuss with each other, if even totally unrelated to haskell. one could interpret that page as saying that #haskell-blah is still on topic.
08:16:56 <dmwit> Unfortunately, it's not really possible to say this more concretely without seeing the code you're trying to use.
08:16:57 <typoclass> enigmuriatic1: honestly, the discussion will be much easier if you just put your code (even if it's not working) on hpaste.org
08:18:07 <enigmuriatic1> hpaste.org/89786
08:18:13 <fruitFly> what is &&&
08:18:14 <fruitFly> ?
08:18:30 <typoclass> fruitFly: it applies two function on the same argument
08:18:30 <dmwit> fruitFly: The most common usage is to apply two functions to a single argument and tuple up the two results.
08:18:40 <dmwit> However, it's slightly more general than that.
08:18:43 <typoclass> > (succ &&& pred) 42 -- fruitFly, example
08:18:44 <lambdabot>   (43,41)
08:18:53 <elliott> fruitFly: you got serveral answers last time you asked...
08:18:56 <elliott> *several
08:19:10 <applicativ> are there several answers?
08:19:13 <yitz> fizbin: cobol came through ok too.
08:19:30 <Hafydd> yitz: I'm pretty sure I could come up with a topic that would get be banned from #haskell-blah.
08:19:38 <Hafydd> Before you ask, no, I'm not taking bets.
08:19:44 <yitz> haha
08:19:45 <fruitFly> elliott: I'm sorry, I missed it, didn't see it in my client. I'll try not to do that again
08:19:54 <dmwit> enigmuriatic1: That code doesn't match the error: it's complaining about line 25, which is empty in your paste. However, on line 24, you are using the result of fmap as if it were a list (because (:)'s second argument is always a list).
08:20:10 <fruitFly> dmwit: typoclass Thank you very much
08:20:20 <dmwit> enigmuriatic1: You will need to teach (:) about IO.
08:20:39 <elliott> hmph, asTypeIn/asAppliedTo aren't in any standard package?
08:20:40 <dmwit> One way to do this is to use a do block; another is to use liftM2 or similar.
08:20:48 <yitz> Hafydd: the credit card numbers of the operators of free node would be a nice topic
08:20:57 <Hafydd> Heh.
08:21:02 <dmwit> Alternately, fuse the first argument to (:) and the (:) and the blockLoop.
08:21:49 <elliott> I nominate... dmwit to fix that.
08:21:54 <elliott> mwahahaha.
08:22:06 <elliott> +data Nature a = Rock a | Stream (Nature a) | Bush (Nature a) (Nature a)
08:22:13 <dmwit> What am I being nominated to fix?
08:22:17 <elliott> i, uh... does anyone actually have a use for this type?
08:22:27 <elliott> dmwit: <elliott> hmph, asTypeIn/asAppliedTo aren't in any standard package?
08:22:38 <dmwit> aha
08:22:57 <elliott> I am trying to import things from packages rather than defining them wherever possible in L.hs
08:25:40 <SrPx> Damn, I'm perfectly capable of creating a product I am dying to create in node.js
08:25:50 <SrPx> And yet here I am, trying to create it in Haskell just because of reasons
08:25:55 <elliott> :t let a `asTypeIn` f = a where _ = f a; f `asAppliedTo` x = f `asTypeIn` \f -> f x in asAppliedTo
08:25:56 <lambdabot> Not in scope: `asAppliedTo'
08:26:02 <elliott> wut
08:26:08 <elliott> help
08:26:14 <elliott> oh
08:26:16 <elliott> hahaha
08:26:22 <elliott> :t let a `asTypeIn` f = a where { _ = f a }; f `asAppliedTo` x = f `asTypeIn` \f -> f x in asAppliedTo
08:26:22 <lambdabot> (t1 -> t) -> t1 -> t1 -> t
08:26:24 <SrPx> ... what ... the heck
08:26:38 <SrPx> nevermind I'm going back to node.js
08:27:08 <applicativ> node.js wow
08:27:09 <typoclass> SrPx: if you're more specific about your questions, there's a chance of answers :)
08:27:21 <SrPx> typoclass: I'm not asking any question :(
08:27:47 <dmwit> SrPx: If you ask some questions, you might get an answer and make progress.
08:27:49 <typoclass> SrPx: haskell does have a learning curve, but i think it's really worth it. like, i don't know, maybe vim
08:27:52 <SrPx> applicativ: wow as in, cool, or more like, "eek"
08:28:10 <Hafydd> While we're on the subject of "WTF", http://wtfjs.com/
08:28:12 <dmwit> This could potentially kick off some endorphins or similar drug, which is pretty much the goal of any human endeavor.
08:28:15 <SrPx> typoclass: that's my motivation, actually. I am too glad I had the arms to learn vim
08:28:15 <dmwit> So I say go for it.
08:28:18 <Hafydd> I think Node.js has Haskell beaten there.
08:28:56 <elliott> dmwit: I like this. endorphin-based community design..
08:29:00 <elliott> s/\.\././
08:29:22 <SrPx> Hafydd: I won't even try defending JS on *this* channel... but in my slight defense, JS is the most functional language of the ones on the wild world
08:29:39 <fruitFly> SrPx: i haven't read the bable yet, but I came from node.js.... don't do it!
08:29:51 <fruitFly> sit and relax here for a little bit
08:29:55 <elliott> +newtype Rec a = InR { outR :: Rec a -> a }
08:30:00 <elliott> hey, this looks like a monad to me.
08:30:11 <elliott> I wonder if it's MonadFix. I wonder if the MonadFix instance is interesting.
08:30:41 <applicativ> nice js they've got there Hafydd
08:30:43 <adinapoli> Talking about node.js, this video is pretty funny :) http://www.youtube.com/watch?v=bzkRVzciAZg
08:30:44 <typoclass> SrPx: i guess you could say it that way, but still, i prefer "\x -> x + 2" instead of "function (x) { return x + 2; }"
08:31:16 <SrPx> typoclass: livescript is just (-> it + 2) but yea, I won't try to defend js here at all, it's unfair
08:31:23 <nooodl> doesn't coffeescript have nice lambdas?
08:31:38 <nooodl> oops. yeah that
08:31:41 <elliott> lol, L.hs imports Control.Parallel{,.Strategies}
08:31:54 <elliott> I guess that's kind of useful for strictness/deepseq reasons
08:31:56 <SrPx> nooodl: yep, livescript is just a coffeescript inspirend in haskell and ml
08:32:34 <bartavelle> is there a way to use currentCallStack from a 'trace' in pure code ?
08:33:07 <bartavelle> or something equivalent, I am open to any suggestion, really :/
08:33:24 <niteria> :t (.:)
08:33:25 <lambdabot>     Not in scope: `.:'
08:33:25 <lambdabot>     Perhaps you meant `.' (imported from Data.Function)
08:33:38 <dmwit> bartavelle: trace is already using unsafePerformIO, so why not throw in a tad more of it?
08:33:45 <bartavelle> I did
08:33:56 <bartavelle> but the stack trace starts at my unsafePerformIO ...
08:34:02 <bartavelle> perhaps I should print !!!
08:34:07 * bartavelle goes back to it
08:34:39 <fruitFly> SrPx: so you wanna build web apps but r interesting in scalability and true computing skills?
08:34:47 <dmwit> bartavelle: Oh, that's funny. =)
08:34:54 <SrPx> fruitFly: pardon?
08:35:34 <fruitFly> SrPx: I thought you mentioned wanting to build some thing and were considering building it in haskell
08:36:08 <SrPx> fruitFly: yea, to learn it, you know... I think I'm missing in not knowing haskell. But that will make me take weeks instead of a days to make it, I guess
08:36:38 <bartavelle> dmwit, "Data.Log.Parse.MysqlSlowQuery.CAF:lvl44_r9aj (<no location info>)" doesn't fill my heart with laughter
08:37:37 <Hafydd> Hahahah.
08:37:59 <bartavelle> also "trace" isn't the best tool when debugging a parser, as it will only print "static" traces once
08:38:04 <dmwit> bartavelle: That's a shame! But it fills Hafydd's heart with laughter, so buck up, somebody's enjoying it. =P
08:38:09 <bartavelle> heh
08:38:35 <bartavelle> at least even when failing haskell is much more effective than java, that problem fills 8G of memory in less than 10 seconds
08:38:58 <SrPx> I don't find much about the charity language... texts, tutorials, anything... sad
08:39:52 <applicativ> node.js is faster than Charity
08:39:53 <byorgey> SrPx: it hasn't been developed since 1998.
08:40:38 <SrPx> applicativ: probably but why?
08:40:53 <applicativ> why is it faster?
08:41:06 <applicativ> surely because its
08:41:11 <applicativ> 'event-driven'
08:41:58 <SrPx> I mean, why did you point it
08:42:36 * applicativ is amusing himself watching > Talking about node.js, this video is pretty funny :) http://www.youtube.com/watch?v=bzkRVzciAZg
08:42:48 <applicativ> yipe paste disaster
08:43:13 <applicativ> i meant to say i was amusing myself watching adinopoli 's video on node.js
08:43:52 <applicativ> it has a heartbreaking ending, where the apparentle sensible pro apache speaker turns out to be a secret lisp fanatic
08:44:32 <adinapoli> applicativ: ahah yes that was the funniest part :D
08:44:38 <dmwit> Liking lisp is heartbreaking?
08:44:53 <applicativ> dmwit: no, on the contrary.
08:45:05 <SrPx> applicativ: oO haha
08:45:52 <applicativ> dmwit: the implicit suggestion is that whenever you have a sensible person who can take down moronic industry fad blather
08:46:07 <applicativ> you bumped into a lisp head
08:46:29 <dmwit> I see.
08:46:46 <applicativ> but the tragic quality is that he knows node.js moronism will win out over sense, as a person of experience
08:47:01 <pushpawpczyk> is node.js that bad applicativ ?
08:47:04 <elliott> about to break lambdabot, sorry
08:47:09 <elliott> @undefine
08:47:09 <lambdabot> Undefined.
08:47:11 <elliott> > ()
08:47:12 <lambdabot>   Could not find module `Data.Set.Lens'
08:47:12 <lambdabot>  Use -v to see a list of the files se...
08:47:15 <elliott> oh.
08:47:19 <elliott> I should have installed lens *before* trying this.
08:47:34 <elliott> > ()
08:47:36 <lambdabot>   ()
08:47:40 <elliott> ok, service temporarily restored :P
08:47:43 <applicativ> pushpawpczyk: I was representing the point of view of an anti node.js film
08:47:54 <pushpawpczyk> heh
08:48:07 <pushpawpczyk> it certainly is a pain to work with, at times, applicativ
08:48:34 <Taneb> > setOf folded "hello"
08:48:38 <lambdabot>   Not in scope: `setOf'Not in scope: `folded'
08:48:38 <lambdabot>  Perhaps you meant one of these...
08:48:50 <Taneb> elliott...
08:48:57 <Taneb> Oh
08:49:01 <Taneb> :t (.)
08:49:03 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:49:09 <Taneb> Not Control.Category?
08:49:24 <elliott> it hasn't been Control.Category since forever
08:49:25 <supki> Not fmap???
08:49:39 <elliott> er, right
08:49:42 <elliott> it hasn't been fmap forever
08:50:00 <elliott> I will not make it Control.Category.(.). at least not without significant lobbying effort from others that should be directed towards making Prelude's (.) that instead
08:50:39 <dmwit> ...the conversation in this video sounds made up.
08:50:40 <SrPx> applicativ: very cool video (;
08:50:51 <supki> :t (Control.Category..)
08:50:52 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
08:50:56 <supki> wow
08:51:12 <tac> cat cat cat meow
08:51:20 <elliott> huh
08:51:23 <elliott> > (Control.Category..)
08:51:24 <lambdabot>   Not in scope: `Control.Category..'
08:51:26 <elliott> right
08:51:29 <elliott> you can't trust :t
08:51:36 <supki> oh(
08:52:04 <applicativ> you used to be able to write Category (~>) => (b ~> c) -> (a ~> b) -> (a ~> c)  ; boo hoo
08:52:06 <elliott> ok, _now_ I will break lambdabot.
08:52:11 <dmwit> This is how I would tell the story about a totally reasonable exchange if I had been through it 30 times, expanding it each time, and I wanted to impress somebody with how awesome I was. I don't believe it really happened like that.
08:52:15 <elliott> @undefine
08:52:15 <lambdabot> Undefined.
08:52:17 <elliott> > ()
08:52:17 * hackagebot diffarray 0.1.1 - DiffArray  http://hackage.haskell.org/package/diffarray-0.1.1 (AndreasAbel)
08:52:18 <lambdabot>   L.hs:138:31:
08:52:18 <lambdabot>      Ambiguous occurrence `Rec'
08:52:18 <lambdabot>      It could refer to either ...
08:52:24 <elliott> ok! now we are getting somewhere
08:52:46 <elliott> @undefine
08:52:46 <lambdabot> Undefined.
08:52:47 <elliott> > ()
08:52:48 <lambdabot>   L.hs:138:31:
08:52:48 <lambdabot>      Ambiguous occurrence `Rec'
08:52:48 <lambdabot>      It could refer to either ...
08:52:52 <elliott> wut
08:52:52 <elliott> > ()
08:52:54 <lambdabot>   L.hs:138:31:
08:52:54 <lambdabot>      Ambiguous occurrence `Rec'
08:52:54 <lambdabot>      It could refer to either ...
08:53:04 <elliott> oh
08:53:08 <elliott> @undefine
08:53:09 <lambdabot> Undefined.
08:53:09 <elliott> > ()
08:53:11 <lambdabot>   L.hs:138:1:
08:53:14 <elliott> o_o
08:53:15 <lambdabot>      Illegal generalised algebraic data declaration for `Is'
08:53:19 <lambdabot>   ...
08:53:42 <elliott> @undefine
08:53:42 <lambdabot> Undefined.
08:53:42 <applicativ> new DiffArray uploaded by Andreas Abel.  hackagebot is freaking me out
08:53:48 * elliott crosses fingers
08:53:49 <elliott> > ()
08:53:50 <lambdabot>   L.hs:122:19:
08:53:50 <lambdabot>      Variable `f' occurs more often than in the instance head
08:53:50 <lambdabot> ...
08:53:58 <elliott> lordy. I am terrible.
08:54:09 <ski> It could refer to either `L.Rec', defined at L.hs:138:9 or `Lambdabot.Plugin.Haskell.Eval.Trusted.Rec', imported from `Lambdabot.Plugin.Haskell.Eval.Trusted' at L.hs:99:1-44
08:54:45 <dmwit> elliott: Surely there's a way to load this in ghci locally or something instead of roundtripping through IRC...
08:55:14 <typoclass> @where+ utf8 A ByteString containing UTF8 can be decoded into a String with "Data.Text.unpack $ Data.Text.Encoding.decodeUtf8 theByteString", from the 'text' package. (There's also the 'utf8-string' package, but that is old and apparently not recommended.)
08:55:14 <lambdabot> Done.
08:55:21 <typoclass> everyone happy with this? ^^
08:55:40 <elliott> dmwit: true. however: lambdabot's setup is idiosyncratic, I don't trust GHCi to match it. however: I could do it in /msg if people are bothered by the failure
08:55:48 <Taneb> typoclass, I would put the translation point-free
08:56:07 <Taneb> "Data.Text.unpack . Data.Text.Encoding.decodeUtf8"
08:56:19 <elliott> however however: I suspect it works this time
08:56:20 <elliott> @undefine
08:56:20 <lambdabot> Undefined.
08:56:21 <elliott> > ()
08:56:22 <lambdabot>   L.hs:40:1:
08:56:22 <lambdabot>      Control.Exception.Lens: Can't be safely imported!
08:56:22 <lambdabot>      The ...
08:56:27 <elliott> ok. I lost the bet. to /msg it is
08:56:29 <typoclass> Taneb: i used that, but i was unhappy with the clash with the module separators. it's pseudo-haskell anyway since you can't import modules that way :)
08:56:59 <typoclass> s/used/tried
08:57:38 <elliott> typoclass: you can import modules that way...
08:57:59 <typoclass> elliott: holy cow?
08:58:14 <elliott> in fact, "import A.B.C" gives you A.B.C.foo
08:59:18 <elliott> lambdabot: @flush
08:59:20 <elliott> lambdabot: @quit
08:59:52 <typoclass> elliott: ah that's what you mean. yes, you can refer to functions that way, but you still need the import line. "main = print $ Data.Text.something ..." won't work alone
08:59:53 <Taneb> > "hi"
09:00:01 <lambdabot>   "hi"
09:00:02 <elliott> typoclass: I think it works in GHCi :)
09:00:04 <elliott> > 2 * x
09:00:10 <elliott> > foldr f z [a,b,c,d]
09:00:11 <lambdabot>   2 * x
09:00:16 <elliott> > 123 & id *~ 2
09:00:17 <lambdabot>   f a (f b (f c (f d z)))
09:00:23 <lambdabot>   246
09:00:31 <Taneb> > setOf folded "hello"
09:00:34 <elliott> > F.foldMap Sum [1, 2, 3, 4]
09:00:41 <lambdabot>   Not in scope: `setOf'
09:00:43 <lambdabot>   Not in scope: `F.foldMap'
09:01:02 <elliott> what
09:01:16 <elliott> :t foldMap
09:01:22 <elliott> er, can't trust :t
09:01:24 <elliott> > foldMap
09:01:25 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
09:01:30 <Taneb> > sum
09:01:31 <lambdabot>   Ambiguous type variable `t0' in the constraint:
09:01:34 <elliott> > F.foldMap
09:01:37 <lambdabot>    (Data.Foldable.Foldable ...
09:01:39 <lambdabot>   *Exception: show: No overloading for function
09:01:44 <Taneb> > sum [1,2,3
09:01:45 <Taneb> > sum [1,2,3]
09:01:45 <lambdabot>   Not in scope: `F.foldMap'
09:01:47 <elliott> eeh, what?!?!
09:01:51 <lambdabot>   <hint>:1:11: parse error (possibly incorrect indentation)
09:01:53 <lambdabot>   6
09:01:54 <typoclass> elliott: well butter my butt. ghci does allow it
09:02:00 <typoclass> elliott: thanks a lot
09:02:02 <elliott> ok, let me look into this. something is wrong
09:02:04 <elliott> typoclass: :)
09:03:15 <elliott> it's right there: import qualified Data.Foldable as F
09:03:17 <elliott> so what is up?
09:03:22 <elliott> > F.foldMap
09:03:29 <lambdabot>   Not in scope: `F.foldMap'
09:05:06 <fruitFly> lololol... accidentally posted my question in idris but they stil insta solved lol
09:10:31 <elliott> can anyone figure out why http://hpaste.org/89790 is doing weird things like using a different show instance for functions (that errors out with "no overloading for function") rather than the one I import for ShowFun? am I getting overlapping instances from somewhere??
09:10:44 <elliott> and why, given that I import Control.Monad.Identity rather than Data.Functor.Identity,
09:10:47 <elliott> > Identity ()
09:10:49 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity ()))
09:10:49 <lambdabot>    aris...
09:10:54 <elliott> talks about the latter? (qualified, for some reason?)
09:13:15 <fizbin> @src Identity
09:13:16 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
09:13:24 <elliott>  @src is full of lies
09:13:47 <fizbin> True, but sometimes they're useful lies.
09:16:32 <fruitFly> is there a function lowerToUpperCase?
09:19:24 <joelteon> :t runIdentity
09:19:25 <lambdabot> Identity a -> a
09:19:44 <elliott> I wonder
09:19:46 <elliott> :t show . Identity
09:19:47 <lambdabot> Show (Identity a) => a -> String
09:19:54 <elliott> ok, thank god, at least they are consistently broken
09:21:04 <typoclass> > map toUpper "cat" -- fruitFly: yes, it's in Data.Char
09:21:06 <lambdabot>   "CAT"
09:21:18 <fruitFly> typoclass: THANKS! :)
09:22:08 <typoclass> what extension enables "deriving instance Show a => Show (Identity a)"?
09:22:16 <elliott> StandaloneDeriving
09:22:19 <elliott> hmmmm
09:22:26 <elliott> maybe the reason it's so messed up is some kind of weird Safe Haskell issue
09:22:34 <elliott> i'm having trouble loading it in GHCi (told you dmwit :P)
09:22:44 <elliott> :t setOf
09:22:46 <lambdabot> Not in scope: `setOf'
09:22:58 <elliott> :t base
09:23:00 <lambdabot> (Integral a, Applicative f, Choice p) => Int -> p a (f a) -> p String (f String)
09:23:10 <fruitFly> how to check the source of a function in prelude?
09:23:14 <fruitFly> info?
09:23:24 <elliott> :t Data.Set.lens.setOf
09:23:25 <lambdabot> Not in scope: `Data.Set.lens'
09:23:25 <lambdabot> Not in scope: `setOf'
09:23:26 <Botje> you can't
09:23:29 <elliott> :t Data.Set.Lens.setOf
09:23:31 <lambdabot> Getting (S.Set a) s a -> s -> S.Set a
09:23:34 <elliott> um.
09:23:45 <fruitFly> @src toLower
09:23:45 <lambdabot> Source not found. Wrong!  You cheating scum!
09:23:55 <elliott> > Data.Set.Lens.setOf folded ["a","b"]
09:23:57 <lambdabot>   Not in scope: `Data.Set.Lens.setOf'
09:23:57 <typoclass> fruitFly: on http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html , click the "source" link on the right side next to the function in question
09:24:05 <elliott> ok, right. I give up on understanding this for now
09:24:10 <typoclass> @type toUpper
09:24:11 <lambdabot> Char -> Char
09:24:17 <fruitFly> typoclass: thanks :) .. no way to do it in prelude?
09:25:31 <typoclass> fruitFly: not really, as far as i know. there's really no problem about an extra line "import Data.Char" at the top of your file (or in ghci). Data.Char is part of the base package, so nobody has to install that
09:25:55 <typoclass> fruitFly: (i.e., if you have ghc installed, you already have Data.Char as well)
09:26:48 <Sonarpulse> johnw?
09:26:51 <JordiGH> So, I think I'm getting ready for my Haskell Hello World program.
09:26:56 <fruitFly> typoclass: I get that, was just wondering for a quick peek into the func in ghci, not to save resources
09:26:58 <JordiGH> Namely, writing a blog post about monads. :-)
09:27:49 <fruitFly> JordiGH: Interesting, I'll look forward to reading it :). I have been learning haskell but haven't been formalized with monads yet
09:28:04 <typoclass> fruitFly: oh i see. well in general, the type signature of the function is informative. often more informative than the source code
09:28:05 <JordiGH> And here's what I'm gonna write about: I get the feeling that monads are just a way to get stuff done within the tight requirements of Haskell's type system. Since the extra context is actually en entirely new value, you need monads to handle that extra context? Is this completely a crack-headed idea?
09:28:08 <typoclass> :t toUpper
09:28:09 <lambdabot> Char -> Char
09:28:11 <typoclass> fruitFly: ^^
09:28:53 <fruitFly> typoclass: got it :)
09:29:39 <typoclass> JordiGH: not entirely sure what you're saying, but http://www.haskell.org/haskellwiki/Typeclassopedia#Functor describes how you can view Functor as a computational context. (every monad conceptually is a functor)
09:29:56 <elliott> JordiGH: I strongly encourage you to read http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
09:30:12 <JordiGH> typoclass: this is just what I'm gleaning from LYAHFGG. He goes on and about about values with contexts and that this is what monads are for.
09:30:30 <JordiGH> elliott: A blog post about monads? Why, yes, I'd love to read it
09:30:30 <JordiGH> !
09:32:51 <dolio> It's a blog post about writing blog posts about monads.
09:33:15 <srhb> But you should write a blog post about _that_
09:33:22 <srhb> For consistency.
09:34:17 <Hafydd> > fix (\x -> "blog posts about writing " ++ x)
09:34:18 <lambdabot>   "blog posts about writing blog posts about writing blog posts about writing...
09:35:04 <Hafydd> > fix ("blog posts about writing " ++) ++ "monads"
09:35:05 <lambdabot>   "blog posts about writing blog posts about writing blog posts about writing...
09:35:13 <Hafydd> There.
09:35:20 <typoclass> srhb: why don't you write a tutorial about writing monad tutorials
09:38:44 <yitz> > cycle "a recursive phrase about "
09:38:45 <lambdabot>   "a recursive phrase about a recursive phrase about a recursive phrase about...
09:38:49 <Sonarpulse> can storable for the FFI be derived at all?
09:38:51 <typoclass> srhb: by the way, ohai :-) long time no see
09:39:11 * typoclass purrs, walks over to srhb and shakes her front paw. i hope that's the correct terminology for humanfolk
09:40:22 <yitz> Sonarpulse: I doubt it.
09:41:19 <Sonarpulse> ah
09:41:22 <Sonarpulse> arg
09:42:01 <Sonarpulse> so johnw's tool, well he can figure it out, but who else can? and doing it manually will take a long while
09:55:25 <chrisdotcode_> hola, #haskell!
09:55:32 <chrisdotcode_> long time no see :)
09:55:45 * typoclass meows in the general direction of chrisdotcode
09:55:51 <chrisdotcode_> hi typoclass
09:55:58 <enigmuriatic1> can anyone help me decipher the logic errors behind these compile errors? http://hpaste.org/89793
09:57:18 <Botje> enigmuriatic1: [IO ...] is usually wrong
09:57:31 <typoclass> enigmuriatic1: what does blockLoop basically do? as its argument it receives a first block, then does getBlock on it, then recursively does prevHash ...? until you reach what?
09:57:49 <typoclass> enigmuriatic1: (or does it produce an infinite list?)
09:59:06 <enigmuriatic1> typoclass, it takes a block, makes another block with one of the block's fields (prevHash), and then conses the current block to a recursive call of blockLoop on the new block
09:59:42 <enigmuriatic1> typoclass, it isn't infinite because eventually the new block is Nothing and that ends the recursion
10:00:46 <chrisdotcode_> hey guys, how do I turn ["100"] into a number? I know that I can turn "100" into a number with `read "100" :: Int`.
10:01:18 <luite_> chrisdotcode_: do you know how to turn ["100"] into "100" ?
10:01:30 <enigmuriatic1> > read . head $ ["100"] :: Int
10:01:31 <lambdabot>   100
10:01:43 <enigmuriatic1> or for just "100":
10:01:45 <chrisdotcode_> luite_: I was *thinking* that I could treat [a] as a monad, and >>= out the "100"?
10:01:56 <luite_> chrisdotcode_: you can
10:02:01 <enigmuriatic1> chrisdotcode_, why not just use head?
10:02:02 <luite_> > join ["100"]
10:02:03 <typoclass> chrisdotcode_: i suggest you use "case ... of [x] -> read x". this matches "..." on a list that has exactly one element. for any other lists, it'll be a runtime error. (that's probably what you want)
10:02:03 <lambdabot>   "100"
10:02:12 <dmwit> > ["100"] >>= reads
10:02:14 <lambdabot>   []
10:02:19 <luite_> but if you have more numbers, then you'll get unexpected results :)
10:02:20 * hackagebot monadplus 1.3 - Haskell98 partial maps and filters over MonadPlus.  http://hackage.haskell.org/package/monadplus-1.3 (HansHoglund)
10:02:24 <dmwit> > ["100"] >>= reads :: [(Int, String)]
10:02:25 <lambdabot>   [(100,"")]
10:02:32 <enigmuriatic1> agreed, safety is key
10:02:34 <typoclass> chrisdotcode_: (the 'head' function is possible, as enigmuriatic1 suggested, but i'd recommend case-of)
10:02:59 <dmwit> I recommend (>>= reads).
10:03:04 <enigmuriatic1> typoclass, any idea how i should modify blockLoop?
10:03:14 <acube> What does reads return? I always forget
10:03:21 <Clint> :t reads
10:03:22 <lambdabot> Read a => ReadS a
10:03:31 <chrisdotcode_> well I'm working with a csv, and the first element of each row is a number, then I need to grab all of the lines with a first number greater than 453. it's a simplish problem, so I thought I"d try to improve my haskell with it.
10:03:36 <dmwit> reads :: Read a => String -> [(a, String)]
10:04:03 <acube> So it returns [(value_read,leftover)] ?
10:04:07 <elliott> :t par
10:04:08 <lambdabot> a -> b -> b
10:04:11 <dmwit> Okay. Given the problem description, I no longer recommend (>>= reads).
10:04:13 <dmwit> acube: right
10:04:15 <elliott> :t pseq
10:04:15 <chrisdotcode_> acube: yeah, it should.
10:04:16 <lambdabot> a -> b -> b
10:04:19 <typoclass> acube: a list of possible parses (i think?), which isn't used, so it's always 0 or 1 elements. and yes, leftovers. often you want to ensure the leftover is ""
10:04:19 <elliott> > pseq 1 2
10:04:21 <lambdabot>   2
10:04:24 <elliott> wtf wtf wtf.
10:04:34 <chrisdotcode_> I'm using splitOn to get the first element of the csv
10:04:40 <dmwit> elliott: ?
10:04:42 <chrisdotcode_> so it typoclass' case idea the best way?
10:04:46 <Clint> you could use csv-conduit
10:05:06 <dmwit> chrisdotcode_: Using a case or other method of pattern-matching seems best to me.
10:05:09 <typoclass> chrisdotcode_: in my opinion yes =)
10:05:18 <chrisdotcode_> Clint: yeah, but it's such a simple problem, I want to try pure haskell :)
10:05:29 <elliott> dmwit: ghci sez: Control.Parallel and Control.Parallel.Strategies aren't safe (with -fpackage-trust -trust parallel), so refuses to import. haddock sez: Safe-Inferred
10:05:33 <chrisdotcode_> dmwit, typoclass: yeah, because the case expression gives run-time safety, right?
10:05:37 <elliott> dmwit: lambdabot sez: sure, I'll import that!
10:05:47 <elliott> (ghci and lambdabot are on the same machine, same ghc install same pkg database etc.)
10:06:11 <elliott> I am becoming steadily convinced some higher power is messing with lambdabot and making sure it doesn't make any sense
10:06:20 <typoclass> chrisdotcode_: largely it's because on failure, 'head' will not tell you a line number and file name. case-of or another pattern match will tell you that
10:06:32 <dmwit> what
10:06:36 <dmwit> I no longer agree with typoclass.
10:06:45 <dmwit> You should use case or a pattern match, but it should still be total.
10:07:13 <dmwit> And no, case expressions don't guarantee run-time safety, really.
10:07:21 <luite_> chrisdotcode_: maybe 0 read . listToMaybe -- something like this if you don't want an explicit case
10:07:28 <dmwit> elliott: Huh. Is it possible that you have two versions of GHC installed?
10:07:45 <chrisdotcode_> (the code thus far:)
10:07:45 <chrisdotcode_> extractNumber :: String -> Int -- Maybe Int, for safety?
10:07:45 <chrisdotcode_> extractNumber line = case (take 1 $ splitOn "," line) of [x] -> read x :: Int
10:08:07 <elliott> dmwit: I consider that highly unlikely. it is in a chroot used only for lambdabot (yes, I am running these ghci commands inside a chroot, yes I've verified they're the same version (a version not available in Debian)), I installed GHC package in the chroot only to compile 7.6.3 and then uninstalled it
10:08:31 <dmwit> elliott: craziness
10:08:49 <elliott> the next step would be to see exactly what mueval command lambdabot is running, I suppose
10:09:13 <dmwit> extractNumber line = case map reads (splitOn "," line) of ((x, ""):_) -> Just x; _ -> Nothing -- how I would write it, probably
10:09:17 <typoclass> dmwit: yes sure, that's preferable. but sometimes the only thing you can reasonably do is crash the program to notify the user of the failure. in that case the question is "can i provide a reasonable message". if yes, use a total match with «error "the reasonable informative message"». if no, partial match is acceptable, i guess
10:09:43 <dmwit> err
10:09:54 <dmwit> (((x,""):_):_), I guess
10:10:27 <chrisdotcode_> :t reads
10:10:29 <lambdabot> Read a => ReadS a
10:10:33 <elliott> lambdabot: @flush
10:10:39 <elliott> lambdabot: @quit
10:10:41 <chrisdotcode_> dmwit: what's ReadS?
10:10:55 <ski>  type ReadS a = String -> [(a,String)]
10:11:17 <chrisdotcode_> okay, so a string with some context
10:11:25 <ski> > (reads :: ReadS Int) "100"
10:11:28 <enigmuriatic1> does anyone know how to fix the function blockLoop here? errors are included. http://hpaste.org/89793
10:11:29 <chrisdotcode_> it's a monad, right?
10:11:34 <lambdabot>   L.hs:41:1:
10:11:39 <typoclass> enigmuriatic1: so in principle you'd be happy if blockLoop returned a [Block], not [Maybe Block], because it would just be a list of "Just someBlock" with a single "Nothing" at the end? (ignoring IO for a moment)
10:11:46 <dmwit> chrisdotcode_: Hm. Yes, but not in the interesting way that you awnt it to be a monad.
10:12:00 <ski> enigmuriatic1 : presumably you want `blockLoop :: Maybe Block -> IO [Maybe Block]' ?
10:12:00 <enigmuriatic1> typoclass yes. that's a valid point
10:12:17 <yitz> chrisdotcode_: no. a way to convert a String into something, in zero or more ways, giving also the unused part of the original String in each case.
10:12:26 <typoclass> chrisdotcode_: nope, it's a simple type synonym. (keyword is 'type')
10:12:37 <FreeFull> > (reads "100") :: [(Int,String)]
10:12:38 <ski> chrisdotcode_ : "it's a monad, right?", "it" being specifically ?
10:12:44 <lambdabot>   L.hs:41:1:
10:12:46 <enigmuriatic1> so typoclass, IO [Block] is probably the best return type?
10:12:48 <elliott> uhh.
10:12:50 <FreeFull> I think lambdabot is broken again
10:12:50 <lambdabot>      Control.Lens: Can't be safely imported!
10:12:58 <yitz> elliott!
10:12:59 <typoclass> enigmuriatic1: yes i suppose so
10:13:01 <elliott> i'm so sorry.
10:13:03 <elliott> I did nothing!
10:13:08 <chrisdotcode_> ski: just in general. I probably don't need it as a monad for now, but I was just curious
10:13:10 <elliott> dmwit: but, hey, hey, this is progress. now it's failing in the same way
10:13:21 <elliott> @undefine
10:13:30 <lambdabot> Undefined.
10:13:35 <elliott> will take out the offending imports in a second
10:13:36 <enigmuriatic1> typoclass, i'm wondering how to do that with the type signature
10:13:39 <ski> chrisdotcode_ : still wondering what "it" referred to ..
10:13:51 <chrisdotcode_> ski: "it" referring to ReadS
10:13:57 <typoclass> yitz: just to confirm my recollection, reads in practice always gives a 0-element list or a 1-element list?
10:13:58 <ski> then, yes
10:14:02 <enigmuriatic1> i guess i could just keep explicitly passing a list and appending it but that seems like a hack. maybe there's a way to do it with folds
10:14:18 <FreeFull> > it
10:14:26 <lambdabot>   L.hs:41:1:
10:14:46 <yitz> Prelude> reads "100xyz" :: [(Int,String)]
10:14:46 <yitz> [(100,"xyz")]
10:14:59 <typoclass> ski: well ReadS can be losslessly converted to a Writer monad or some such, but it isn't itself a monad, is it?
10:15:04 <dmwit> typoclass: yes
10:15:21 <ski> @hoogle ReadS a -> ReadP a
10:15:21 <dmwit> typoclass: I mean, yes, reads in practice always returns 0 or 1 parses.
10:15:28 <lambdabot> Text.ParserCombinators.ReadP readS_to_P :: ReadS a -> ReadP a
10:15:30 <ski> @hoogle ReadP a -> ReadS a
10:15:39 <lambdabot> Text.ParserCombinators.ReadP readP_to_S :: ReadP a -> ReadS a
10:15:39 <dmwit> Right, ReadP is the type that's a monad in the way you want it to be for parsing.
10:15:40 <ski> typoclass : it's a monad, but it's not an instance of `Monad'
10:15:45 <lambdabot> Prelude readParen :: Bool -> ReadS a -> ReadS a
10:15:53 <lambdabot> Plugin `hoogle' failed with: <<timeout>>
10:15:56 <typoclass> ski: right
10:16:02 <ski> (simply because it's an unsaturated type synonym)
10:16:02 <typoclass> dmwit: thanks
10:16:11 <yitz> typoclass: but you could of course define your own ReadS things, or Read instances of your own types, that give more than one alternative
10:16:44 <typoclass> yitz: well i *could* also define a Functor for lists that always gives [] ... :)
10:16:49 <ski> typoclass : iirc, `ReadP' is just a `newtype' wrapper around `ReadS'
10:16:59 <typoclass> ski: i see, thanks
10:17:01 <dmwit> typoclass: fails the fmap id = id law
10:17:13 <yitz> typoclass: that's not your own type. [a] is in the public domain.
10:17:45 <typoclass> dmwit: yeah, that's what i'm saying. it's one of the Functors for which the townspeople will come at you with pitchforks and laser cannons
10:18:00 <dmwit> ski: I don't think so.
10:18:04 <dmwit> ski: It's a bit more exciting.
10:18:08 <ski> ok ?
10:18:26 <yitz> it's a parser combinator library that pre-dated Parsec
10:18:35 <dmwit> It's ContT P
10:18:36 <josephle> do most functors have trivial definitions? like the one for list that gives []
10:18:43 <yitz> it's used to implement some of the Prelude instances of Read
10:18:50 <dmwit> where P has Get, Look, Fail, Result, Final constructors
10:18:56 <yitz> dmwit: no no!
10:19:03 <elliott> lambdabot: @flush
10:19:09 <dmwit> no?
10:19:11 <elliott> lambdabot: @quit
10:19:12 <yitz> dmwit: not the classic ReadP, anyway
10:19:23 * dmwit is looking at the source of Text.ParserCombinators.ReadP
10:19:27 <dmwit> in base
10:19:29 <elliott> @undefine
10:19:38 <lambdabot> Undefined.
10:19:40 <elliott> > ()
10:19:48 <lambdabot>   mueval-core: GhcException "cannot satisfy -package lambdabot-haskell-plugin...
10:19:50 <yitz> http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-ParserCombinators-ReadP.html
10:19:52 <elliott> omg.
10:20:24 <elliott> sorry about having to keep restarting lambdabot: it is due to an unfortunate limitation
10:20:38 <elliott> (the packages it trusts cannot be changed without restarting)
10:20:39 <elliott> lambdabot: @flush
10:20:41 <elliott> lambdabot: @quit
10:20:41 <dmwit> yitz: Click "source" on the "data ReadP" and you will see I am right. =)
10:20:46 <typoclass> josephle: just to be clear, don't use what i said =) it's a Functor that doesn't comply with the functor laws. (see typeclassopedia.) the instance complies with the type signatures, it's ok as far as ghc is concerned, but it's confusing and dangerous as far as human readers are concerned
10:21:21 <ski> dmwit : hm, i suspect this is a variant of Koen Claessen's `Parsek'
10:21:24 <ski> see e.g.
10:21:29 <ski> @hackage cake
10:21:33 <ski> @hackage Encode
10:21:35 <magicman> ReadP. Free monad before it was cool.
10:21:36 <lambdabot> http://hackage.haskell.org/package/cake
10:21:43 <lambdabot> http://hackage.haskell.org/package/Encode
10:21:50 <FreeFull> Another functor instance for lists that doesn't obey the laws is   fmap = map . reverse
10:22:21 * hackagebot nicify 0.9 - Pretty print the standard output of show for algebraic datatypes  http://hackage.haskell.org/package/nicify-0.9 (JulianFleischer)
10:22:37 <elliott> hey, wait, 2600:3c00::f03c:91ff:fe70:53e1 is not my server...
10:22:44 <dmwit> josephle: That definition does not make [] a functor (though it does make it a Functor, since the compiler doesn't check the laws).
10:22:45 <ski> (or maybe `Parsek' is a variant of this ?)
10:23:03 <josephle> dmwit: oh, right. I forgot about the laws (d'oh)
10:23:16 <dmwit> Oh, I see typoclass also already said this. Apologies.
10:23:24 <yitz> dmwit: this does not appear to be the original ReadP either, though perhaps its API is designed to be somewhat compatible.
10:23:35 <elliott> oh, what. this is an old version, I guess running on Cale's server?
10:23:45 <elliott> Cale: ping? do you have some cron job starting \bot or something?
10:24:01 <elliott> omg
10:24:05 <elliott> this explains the issues I was having
10:24:10 <elliott> it was never my lambdabot I was testing!
10:24:17 <dmwit> elliott: But then how did you mucking about with L.hs change things?
10:24:20 <dmwit> I mean, it clearly did.
10:24:25 <elliott> dmwit: because I told Calebdabot to @quit
10:24:26 <yitz> elliott: it's not running on lispy's server anymore?
10:24:27 <elliott> and then started my lambdabot
10:24:29 <elliott> and it won the race
10:24:31 <shergill> johnw: you're working for fpcomplete, correct? is the code for the website on github?
10:24:35 <dmwit> elliott: oh, lol
10:24:44 <elliott> yitz: no, I took over running lambdabot on my server yesterday. but it seems like the old one is fighting back!
10:24:52 <yitz> hah
10:25:03 <elliott> ahahaha, it was when I rebooted it to try the L.hs originally that the old one came back
10:25:12 <elliott> so all the wonderful simple-reflect/lens tests I did were running on the old server
10:25:25 <FreeFull> =P
10:25:34 <elliott> this also explains the weird lines like [WARNING] : sending message to bogus server: IrcMessage {ircMsgServer = "freenode", ircMsgLBName = "urk!<outputmessage>", ircMsgPrefix = "", ircMsgCommand = "JOIN", ircMsgParams = ["#haskell.ru"]}
10:25:38 <elliott> in lambdabot.log
10:25:43 <yitz> elliott: you need a reboot script that fires a well-timed missile
10:26:06 * elliott has an idea
10:26:08 <typoclass> elliott: just be gentle with her
10:26:32 <elliott> usurped!
10:26:48 <elliott> uh, I was going to @tell Cale about the problem
10:27:01 <elliott> but I'd have to tell both lambdabots!
10:27:10 <Hafydd> Heh.
10:27:45 <elliott> oh wait, why is it Guest89222...
10:27:47 <dmwit> elliott: If you are a channel op, you could for the moment +q lambdabot and give your bot a slightly different nick.
10:27:51 <dmwit> Until things get sorted out.
10:28:01 <shergill> luite_: you there?
10:28:04 <elliott> dmwit: yes, that might be a good idea
10:28:10 <elliott> dmwit: though I will try one more time to displace it
10:28:15 <dolio> What exactly is the original ReadP?
10:28:24 <elliott> Guest89222: @quit
10:28:27 <elliott> uh
10:28:30 <dolio> The current version goes back to GHC 5.04 from what I can tell.
10:28:32 <elliott> lambdabot: @quit
10:28:36 <elliott> ...whatever
10:28:41 <dolio> And it just didn't exist in GHC before that.
10:28:41 <nooodl> hahaha
10:29:56 <dmwit> strange
10:30:08 <dmwit> Hoogling ContT gives ContT :: ((a -> m r) -> m r) -> ContT r a
10:30:10 <dmwit> that can't be right
10:30:59 <elliott> ok.
10:31:00 <elliott> @undefine
10:31:08 <lambdabot> Undefined.
10:31:13 <elliott> > ()
10:31:18 <lambdabot>   L.hs:83:1:
10:31:24 <lambdabot>      Data.Number.BigFloat: Can't be safely imported!
10:31:46 <luite_> shergill: yes
10:31:58 <DanBurton> dmwit: what's wrong with that?
10:32:12 <dmwit> DanBurton: Where'd the m go in the return type?
10:32:18 <DanBurton> ohhh
10:32:22 * hackagebot hist-pl-lexicon 0.6.0 - A binary representation of the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-lexicon-0.6.0 (JakubWaszczuk)
10:32:40 <enigmuriatic1> what can be used to cons to a list so that it doesn't change the list at all? like the equivalent of null in other languages?
10:33:06 <DanBurton> yeah that's creepy. My faith in hoogle has now been shaken :/
10:33:13 <geekosaur> wut
10:33:21 <ski> should be `ContT :: ((a -> m r) -> m r) -> ContT r m a' ..
10:33:41 <sellout-> enigmuriatic1: How is that the equivalent of null in other languages? Can you give an example?
10:33:49 <dmwit> enigmuriatic1: id
10:33:54 <geekosaur> enigmuriatic1, there is nothing you can cons (:) to a list. if you use (++) instead of (:), it's []
10:34:06 <sellout-> enigmuriatic1: do you mean concat/append?
10:34:12 <enigmuriatic1> x : [1, 2, 3] == [1, 2, 3]       what is x?
10:34:19 <ski> no such `x'
10:34:20 <elliott> ok
10:34:23 <elliott> lambdabot evaluation should work again
10:34:36 <elliott> no lens until I can figure out why it doesn't think it's safe, sorry
10:34:37 <sellout-> enigmuriatic1: There is nothing, and I don’t think there is in other languages either.
10:34:43 <elliott> but it has simple-reflect
10:34:53 <shergill> luite_: is the code for your haskell web ide available somewhere?
10:34:56 <DanBurton> enigmuriatic1: there is no such thing. x : [1,2,3] will always be a 4-element list, regardless of what x is
10:34:57 <Hafydd> > (cycle "a")
10:35:08 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
10:35:11 <Hafydd> > 'a' : (cycle "a")
10:35:17 <geekosaur> enigmuriatic1, (:) prepends a cell to a list. always. there is no magic value that makes (:) not do anything; it ALWAYS prepends a new cons cell.
10:35:20 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
10:35:28 <dmwit> Hafydd: But those still aren't (==). =P
10:35:36 <shergill> luite_: i'd like to implement a web ide for a different language, and i was wondering if there was some common architecture/boilerplate that could be reused
10:35:44 <chrisdotcode_> you can't pattern match on a lambda, right?
10:35:46 <shergill> (for personal project)
10:35:47 <Hafydd> They aren't /= either.
10:35:48 <DanBurton> dmwit: aren't they? By equational reasoning, does not the first expand to the second?
10:35:48 <ski> > length (x : [1,2,3])
10:35:50 <dmwit> chrisdotcode_: right
10:35:54 <lambdabot>   4
10:35:54 <chrisdotcode_> dmwit: thanks :D
10:35:55 <ski> > length [1,2,3]
10:35:57 <lambdabot>   3
10:36:03 <typoclass> enigmuriatic1: i've made an annotation showing some changes that i'd make http://hpaste.org/89793 there's other ways to write blockLoop, but this is the most basic one i can think of. (it compiles; i hope it works)
10:36:06 <dmwit> DanBurton: I'm reading (==) as a function in the language, not external to it.
10:36:17 <ski> enigmuriatic1 : they have different lengths, so must be different lists, can't be equal
10:36:19 <luite_> shergill: no not yet. it's not really a complete IDE though, more a wiki with runnable haskell code. fpcomplete is doing a proper web ide, but that won't be free or open source
10:36:23 <dmwit> chrisdotcode_: You can call seq to force it to WHNF.
10:36:34 <chrisdotcode_> WHNF?
10:36:41 <RichyB> Weak Head Normal Form
10:36:44 <luite_> shergill: i haven't spent much time hacking on it lately, since i'm working on ghcjs
10:36:47 <dmwit> chrisdotcode: You can evaluate it to the point where a lambda is outermost.
10:36:47 <tromp_> they are equal in the sense of (==) never finding a difference
10:36:47 <shergill> luite_: that's all i need actually. i'm thinking of a collaborative wiki with coq programs
10:36:51 <chrisdotcode_> *googles*
10:36:52 <FreeFull> > x
10:36:53 <lambdabot>   x
10:36:56 <RichyB> It means that the outermost constructor or lambda has been evaluated.
10:36:57 <dmwit> chrisdotcode_: e.g. turn f . g into \x -> f (g x)
10:36:59 <FreeFull> > x :: Int
10:37:01 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:37:01 <lambdabot>              with actual type ...
10:37:08 <chrisdotcode_> dmwit: oh! that's aweomse!
10:37:10 <Hafydd> > 1 :: Expr
10:37:10 <FreeFull> :t x
10:37:11 <lambdabot>   1
10:37:11 <dmwit> chrisdotcode_: or do any other computations necessary before the function could actually be run
10:37:12 <lambdabot> Expr
10:37:13 <chrisdotcode_> thanks for telling me about that :D
10:37:22 * hackagebot hist-pl-fusion 0.5.2 - Merging historical dictionary with PoliMorf  http://hackage.haskell.org/package/hist-pl-fusion-0.5.2 (JakubWaszczuk)
10:37:24 * hackagebot hist-pl-dawg 0.2.0 - A generic, DAWG-based dictionary  http://hackage.haskell.org/package/hist-pl-dawg-0.2.0 (JakubWaszczuk)
10:37:26 * hackagebot hist-pl 0.3.1 - Umbrella package for the historical dictionary of Polish  http://hackage.haskell.org/package/hist-pl-0.3.1 (JakubWaszczuk)
10:37:32 <luite_> shergill: oh cool :)
10:37:46 <shergill> luite_: specifically, i'm hoping/assuming you'd have smoothed out at least some of the client/server communication issues. and was hoping i didn't have to reinvent the wheel there
10:38:53 <luite_> shergill: oh i'm going to have to rework those actually, since i want to switch to ghcjs for some results. interactivity is a pain with a wiki, so i want to move more to the client. unfortunately that makes it a lot more haskell-specific
10:39:11 <RichyB> chrisdotcode_: e.g. the expression (\a -> a + 1 : []) is in WHNF. The expression ((\a -> a + 1 : []) 1) isn't because you could feed that 1 into the function but haven't yet (laziness!). The expression 2 is in WHNF because 2 is a constructor. :)
10:39:14 <RichyB> er
10:39:36 <dmwit> better example is that ((\a b -> a + b : []) 1) isn't yet WHNF
10:39:51 <RichyB> the expression [2] is in WHNF because it is (:) 2 [], and the (:) is a constructor and is evaluated
10:39:58 <shergill> luite_: right. so would the current version (without ghcjs) have any worth you think?
10:40:10 <RichyB> the expression [2] is actually in NF (normal form) because it's fully evaluated out to just constructors.
10:40:35 <typoclass> enigmuriatic1: does it make any sense?
10:40:38 <RichyB> The expression [1 + 1] is in WHNF, but not in NF, because it's actually (:) (1 + 1) []
10:40:56 <enigmuriatic1> typoclass, i think so. just read it and compiled, about to test, will read after
10:41:03 <RichyB> (:) (1 + 1) [] is in WHNF because the (:) is a constructor.
10:41:06 <enigmuriatic1> typoclass, thanks so much, by the way
10:41:06 <typoclass> enigmuriatic1: ok
10:41:25 <RichyB> (:) (1 + 1) [] -- is not in NF because you could potentially turn the (1 + 1) into a (2).
10:41:32 <RichyB> chrisdotcode_: does that make sense, please?
10:41:50 <typoclass> enigmuriatic1: you're welcome :) in general, don't juggle too much fmap and stuff if you're not sure. it's often best to write a simple do block with "<-". at least for the first draft of the program
10:42:18 <luite_> shergill: not much really, probably, sorry. i left it in a rather messy state and haven't worked on it for months
10:42:22 * hackagebot dawg 0.10 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.10 (JakubWaszczuk)
10:42:25 * hackagebot polimorf 0.7.2 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.7.2 (JakubWaszczuk)
10:42:36 <enigmuriatic1> typoclass, thanks. yeah, i always get too caught up trying to apply all of this stuff and sometimes end up ignoring the easy solution in the process
10:43:00 <fruitFly> sortPlainTexts :: [String] -> [String] ............... sortPlainTexts texts = sortBy (comparing (ratePlainText $ potentialPlainTextToData)) texts
10:43:11 <shergill> luite_: gotcha. you wouldn't have any other reference implementations in mind would you?
10:43:19 <fruitFly> I'm trying to sort a list by the the function potentialPlaintextToData then ratePlainText
10:44:05 <yitz> fruitFly: s/\$/./
10:44:20 <fruitFly> yitz: huh? :P
10:44:21 <dmwit> fruitFly: s/\$/++/
10:44:37 <fruitFly> wut
10:44:45 <yitz> fruitFly: change the $ to a .
10:44:47 <dmwit> sortBy (comparing ratePlainText ++ comparing potentialPlainTextToData)
10:44:48 <fruitFly> never seen anything that looks like that before
10:44:51 <dmwit> yitz: doubt it
10:44:52 <luite_> shergill: ipython notebooks might be interesting
10:44:53 <shachaf> dmwit: s/\+./<>/
10:44:54 <geekosaur> ($) is the wrong operator
10:44:55 <gspr> Does QuickCheck have some mechanism for randomly composing various monadic actions (in the ST monad, to be specific), all the while checking that certain properties hold after each composition?
10:45:01 <dmwit> ugh, yes, <>, not ++
10:45:02 <yitz> dmwit: that can't be, it needs tobe a functions
10:45:05 <fruitFly> dmwit: ooooooooooooh
10:45:13 <dmwit> yitz: functions are monoids when their return types are =)
10:45:27 <dmwit> fruitFly: But yes, I meant <> and not ++ in that snippet.
10:45:32 <yitz> oh you were speaking caleskell?
10:45:37 <fruitFly> what's with all your guys fancy notation lol.. I wanna learn some
10:45:41 <dmwit> Oh, is that not standard?
10:45:42 <geekosaur> sounds like it :p
10:45:43 <dmwit> It should be.
10:45:46 <gspr> (To be concrete: Imagine you've implemented graphs and various graph operations using STRefs, and want to check that various operations maintain certain invariants, or something)
10:45:52 <geekosaur> ++ is not mappend, sadly
10:46:24 <dmwit> Yeah, I didn't mean ++. That was a mistake.
10:46:35 <shachaf> Also you probably actually want two comparings?
10:46:36 <dmwit> But is the instance also not standard?
10:46:39 <fruitFly> what is this s/\+./<>/
10:46:40 <fruitFly> ?1
10:46:41 <lambdabot> Say again?
10:46:42 <fruitFly> !
10:46:45 <dmwit> I typed two comparings, did I not?
10:46:46 <shergill> luite_: thanks
10:46:59 <shachaf> Oh, you did.
10:47:03 <dmwit> fruitFly: It's sed syntax for replacing one thing with another.
10:47:07 <typoclass> fruitFly: do you want to sort by 2 criteria? like "sort by length of the string, and among all the strings of the same length, sort alphabetically". or do just want to sort by one criterion?
10:47:13 <yitz> fruitFly: like in the unix sed command. people often use that in irc channels.
10:47:18 <elliott> what is the non-standard thing dmwit relied on?
10:47:31 <shachaf> ++ = <>
10:47:32 <typoclass> elliott: assuming (++) is the same as (<>)
10:47:35 <dmwit> fruitFly: s/regex/text/ means find the maximal first occurrence of regex in the line and replace it with text.
10:47:37 <elliott> ah
10:47:44 <elliott> someone should propose that on libraries@
10:47:49 <elliott> seems like it'd go well with the Foldable changes
10:47:53 <geekosaur> fruitFly, there's a convention on IRC to correct things by using pretend "sed" commands.
10:48:12 <geekosaur> didn't ++ = mappend already get shot down multiple times? that's how we ended up with <>
10:48:16 <yitz> elliott: i'd be opposed. i like the traditional type-specific functions for lists.
10:48:31 <shachaf> "traditionally" (++) = mplus
10:48:44 <dmwit> fruitFly: (In fact, people often forget that you can use any character in place of /. / is traditional.)
10:48:45 <geekosaur> gotta cater to the folks who want to use a limited subset of haskell to teach something that's not even haskell, and demand that the Haskell Prelude stick to their limited subset, y'kow...
10:48:56 <rovar> Hey all.  I am trying to make a simple expression engine which handles multiple types (strings, floats, ints)
10:48:57 <rovar> https://gist.github.com/rrichardson/5759119
10:49:19 <rovar> I am not sure how to define an evaluator which can handle the disparate data types..
10:49:24 <fruitFly> typoclass: I have a [String] and I want to apply to each element a function, then another function that will return a double and then sort in ascending order... I guess I should use map then, right?
10:49:49 <elliott> yitz: well, the proposal to replace mapM etc. already passed by quite a long margin
10:49:56 <elliott> yitz: so base has already moved on from that notion.
10:50:08 <elliott> (maybe the margin wasn't that large. I forget.)
10:50:22 <yitz> geekosaur: ++ is part of haskell. why do you want to eject it, and use the symbol for something else? you are the one who wants a limited subset of haskell.
10:50:37 <dmwit> rovar: evaluate can't possibly hope to return a value of any old type I demand.
10:50:47 <geekosaur> wut
10:51:10 <fruitFly> typoclass: actually no, no mapping because I don't want to change the values, just sort by the values
10:51:12 <geekosaur> how is monoid more limited than a particular monoid. but in any case I think the reference flew well over your head
10:51:16 <typoclass> fruitFly: yes, i think map is a good choice first of all. when in doubt, try "map (\x -> anotherFunction (firstFunction x)) ..."
10:51:36 <yitz> elliott: did edwardk support it?
10:51:38 <elliott> I am sometimes forced to believe that people who want Haskell compilers to never advance beyond the Report don't understand that the original goal of Haskell was for experimental lazy pure language work, and that of course innovations of implementations should drive the Report, rather than all progress being blocked on it...
10:51:41 <typoclass> fruitFly: ok, then sortBy (comparing ...) instead of map =)
10:51:43 <elliott> yitz: yes.
10:51:48 <dmwit> rovar: The type annotation you wrote says, "You (the caller) gets to pick two types. Call them a and b. So long as you can prove that 'a' can be compared for equality, I can turn your Expr a into a b.".
10:51:50 <fruitFly> typoclass: :)
10:51:57 <yitz> elliott: ok it's very likely reasonable then.
10:52:09 <fruitFly> typoclass: thanks... you're like my haskell super hero... awwwwwwwwwwwwww
10:52:18 <elliott> yitz: it also involved generalising sum, foldr, etc.
10:52:23 * hackagebot stringtable-atom 0.0.6.2 - Memoize Strings as Atoms for fast comparison and sorting, with maps and sets  http://hackage.haskell.org/package/stringtable-atom-0.0.6.2 (JeffShaw)
10:52:25 * hackagebot pugs-DrIFT 2.2.3.20130611 - DrIFT with pugs-specific rules.  http://hackage.haskell.org/package/pugs-DrIFT-2.2.3.20130611 (JeffShaw)
10:52:27 <elliott> (from my recollection)
10:52:32 <yitz> elliott: i use haskell at work. i want it to keep advancing... but in a way that won't destroy a ton of our work.
10:53:04 <yitz> elliott: that's limiting, i know. haskell advanced much more quickly when it was only a research language.
10:53:12 <elliott> well, generalising functions is roughly the least destructive way to make *any* change
10:53:22 <elliott> the only time it can break is when it results in you having ambiguous types
10:53:26 <yitz> elliott: sometimes yes, sometimes no.
10:53:31 <dmwit> rovar: (Perhaps you mean to return a "Term a" instead.)
10:53:32 <elliott> for something like (++), the types of the arguments are usually known
10:53:41 <enigmuriatic1> typoclass, i'm just getting the print statements right and writing a test case so it finished faster
10:53:46 <enigmuriatic1> *finishes
10:53:47 <yitz> right. and ambiguous types can sometimes be extremely costly. but sometimes not.
10:54:09 <ski> fruitFly : Cale's <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> might be interesting
10:54:11 <shachaf> Next up: [] :: Monoid m => m
10:54:17 <rovar> dmwit:  I see what you're saying.  My problem is that I'm trying to figure out how to provide a way to combine expressions which might actually be of different types.  I think my problem is that I can't do it at compile time, so I need to leave out the parametric types entirely
10:54:22 <fruitFly> ski: thanks :)
10:54:29 <fruitFly> ski: why did you say that?
10:54:34 <dmwit> rovar: I think you can do it just fine. Use Term.
10:54:38 <fruitFly> and '<>' not in scope?
10:54:46 <typoclass> elliott: it can decrease readability. with "map", i know we're dealing with a list. with fmap, i may have to do type inference in my head, or put type annotations into the code and recompile, just to be clear what's going on ...
10:54:57 <dmwit> rovar: oh, wait
10:55:07 <yitz> ++ is one of the most fundamental operations on lists. morally part of the type class, even though it's not. generalizing its type would have vast consequences.
10:55:16 <dmwit> rovar: I'm suddenly confused. Why do Term and Expr take a type argument?
10:55:20 <dmwit> rovar: It's never used...
10:55:23 <typoclass> elliott: ... i'm not saying that this is the deciding factor in all cases. just that it should be considered
10:55:27 <rovar> dmwit: exactly :)
10:55:28 <elliott> typoclass: I reckon you have to do inference in your head to read any non-trivial amount of Haskell code. it would be nice if we had tools to do it for us
10:55:37 <elliott> we already do to some extent
10:55:38 <elliott> e.g. ghc-mod
10:55:44 <ski> fruitFly : because you were talking about moinoids and dmwit mentioned `comparing ratePlainText ++ comparing potentialPlainTextToData'
10:55:47 <rovar> dmwit:  I started with an expression evaluator that was fractional only
10:55:48 <typoclass> elliott: yes absolutely
10:56:03 <rovar> and am now trying to generalize to str float and int
10:56:08 * elliott wants to be more of a cyborg programmer! having to think is the enemy.
10:56:17 * ski . o O ( "On the Cale Property in Integral Domains And Monoids" by Scott T. Chapman,Ulrich Krause at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.15.665> )
10:56:19 <dmwit> rovar: Perhaps you would like to look at one of the introductions to GADTs that implements a simply-typed lambda calculus or similar.
10:56:31 <exFalso1> Hi, is there a way to see whether two file paths resolve to the same inode? i'm sure the Eq instance of Handle only checks descriptor numbers
10:56:43 <fruitFly> ski: ok cool does <> have something to do with a monoid? I don't formly know what monads or monoids are yet, so I'll give it a read.
10:56:45 <dmwit> rovar: Alternately, you will need a separate evaluator and type-checker for your language.
10:56:58 <dmwit> The evaluator may crash or do some other stupid thing when the type-checker says "no".
10:57:02 <fruitFly> how do I get <> in scope?
10:57:15 <yitz> import Data.Monoid ((<>))
10:57:15 <typoclass> fruitFly: import Data.Monoid (on a reasonably new ghc)
10:57:23 * hackagebot pugs-compat 0.0.6.20130611.0 - Portable Haskell/POSIX layer for Pugs  http://hackage.haskell.org/package/pugs-compat-0.0.6.20130611.0 (JeffShaw)
10:57:25 * hackagebot Pugs 6.2.13.20130611 - A Perl 6 Implementation  http://hackage.haskell.org/package/Pugs-6.2.13.20130611 (JeffShaw)
10:57:27 <dmwit> fruitFly: Yes, (<>) has something to do with monoids.
10:57:27 * hackagebot nicify 1.0 - Pretty print the standard output of show for algebraic datatypes  http://hackage.haskell.org/package/nicify-1.0 (JulianFleischer)
10:57:31 <fruitFly> typoclass: thanks :) .. that was my guess
10:57:37 <acube> :t (<>)
10:57:37 <lambdabot> Monoid m => m -> m -> m
10:57:40 <ski> fruitFly : it's alternatively called `mappend'
10:57:48 <ski> @hoogle Monoid m => m -> m -> m
10:57:48 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
10:57:48 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:57:48 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
10:58:05 <fruitFly> ski: thanks :)
10:58:24 <rovar> dmwit:  For now I'm going to go with simple coersion, as the intent is to make a javascript-esque language for collections
10:58:43 <rovar> e.g.  addTerm :: Term -> Term -> Term
10:58:44 <yitz> it actually has to do with semigroups. and Monoid should be class Semigroup m => Monoid m where ... but.. ah well ..
10:59:01 <elliott> yitz++
10:59:04 <johnw> yitz: edwardk's Option class does that
10:59:08 <elliott> someone should beat that dead horse on libraries@ too!!
10:59:51 <shachaf> I,I class (Semigroup m, Default m) => Monoid m
10:59:57 <dmwit> johnw: uh, Option is a bit different
11:00:23 <shachaf> A bit different from a class?
11:00:29 <johnw> i meant, newtype
11:00:37 <johnw> http://localhost:8687/file//Volumes/Data/Home/.cabal/share/doc/semigroups-0.9.2/html/Data-Semigroup.html#v:Option
11:00:38 <typoclass> sortBy (comparing length <> comparing sort) (words "yes no abc yo def") -- fruitFly, here is some example code that will give the result ["no","yo","abc","def","yes"]. it sorts by length, then when there's a tie, it sorts alphabetically
11:00:43 <johnw> well, in that package
11:00:49 <dmwit> But it has nothing to do with making Semigroup a superclass of Monoid!
11:00:53 <shachaf> Ah, that URl explains it.
11:00:54 <elliott> johnw: nice url
11:01:05 <yitz> haha
11:01:14 * elliott steals johnw's computer and then clicks it
11:01:32 <johnw> dmwit: oh, right, that just relates Semigroup to Maybe, n/m
11:01:38 <johnw> ok, let's beat that horse on libraries@!
11:01:40 <typoclass> fruitFly: this ^^ involves a monoid. but you need that if you don't want. also it depends if you actually *want* to sort by two criteria
11:02:02 <fruitFly> typoclass: ooooooooooooooh k
11:02:12 * typoclass looks up johnw's ip address and substitutes it into that url. that's surely gonna work
11:02:30 <ParahSailin> @type comparing
11:02:30 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:02:34 <johnw> i need to mod my Emacs so that it corrects those URLs
11:02:51 <exFalso1> hi, how can i check whether two file paths resolve to the same file?
11:03:20 <johnw> exFalso1: call canonicalizePath on both of them, and compare that result
11:03:43 <ski>   comparing f = compare `on` f
11:03:46 <johnw> there may be more efficient ways, by looking at the inode number or something
11:04:00 <exFalso1> johnw: thank you, will that follow symlinks too?
11:04:01 <DanBurton> @src on
11:04:01 <lambdabot> (*) `on` f = \x y -> f x * f y
11:04:07 <elliott> I nominate johnw to do the horse-beating.
11:04:08 <typoclass> i still think i misremembered that example code ...
11:04:22 <dmwit> Thank goodness IRC nominations are not binding.
11:04:27 <johnw> exFalso1: look up the definition; I'd paste a link, but that might not be too effective
11:04:27 <ParahSailin> typoclass: that sortBy, is that using the instance of Monoid for (-> r) or a special one
11:04:31 <elliott> dmwit: oh, they are now.
11:04:38 <elliott> everything has changed. I am in power now
11:04:49 <elliott> first it was lambdabot. now it's the world
11:04:52 * dmwit sticks some carefully chosen fingers up
11:04:59 <johnw> I don't bringing mind bringing that up in libraries@, but has it been proposed before?
11:05:07 <elliott> johnw: yes
11:05:13 <exFalso1> well it is a non-trivial problem it seems: "Note that it is impossible to guarantee that the  implication (same file/dir <=> same canonicalizedPath) holds  in either direction: this function can make only a best-effort  attempt. "
11:05:14 <elliott> I think it ended in "no consensus" for silly reasons.
11:05:22 <elliott> I think edwardk is still bitter that someone voted against because they didn't know what a semigroup is :)
11:05:40 <dmwit> Well, that is a pretty stupid reason.
11:05:44 <elliott> but Semigroup really does need to get into base and Monoid should be fixed.
11:06:19 <johnw> yep, ok, I'll write a letter now
11:06:47 <typoclass> ParahSailin: here you go http://stackoverflow.com/questions/11486436/composing-two-comparison-functions
11:06:58 <ParahSailin> @hoogle comparing
11:06:59 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
11:07:01 <elliott> dmwit: see? binding.
11:07:08 <elliott> johnw is quivering in fear.
11:07:09 <johnw> what is Semigroup to Moniod in that case, a "parent type class"?  Or just a constraint?
11:07:24 <ParahSailin> @hoogle sort
11:07:24 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
11:07:25 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
11:07:25 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
11:07:29 <dmwit> johnw: superclass
11:07:35 <RichyB> exFalso1: it depends on your operating system. For example, on any Unix, I can create a file, open() it, unlink() it, then create another file with the same name and open() that.
11:07:39 <johnw> ah, thanks
11:07:44 <elliott> johnw: the whole of http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-Semigroup.html should just go into base
11:07:50 <ParahSailin> huh, ok it's default instances
11:07:57 <elliott> well, iirc edwardk has said he can dispense with sconcat and times1p if it gets into base
11:08:07 <elliott> and then mappend should be removed from Monoid and a Semigroup superclass added
11:08:12 <ski> ParahSailin : actually `((->) r)', aka `(r ->)'
11:08:25 <elliott> well... you could do an "AMP" type thing keeping mappend. but I don't think compatibility with Monoid instances is as big a deal
11:08:36 <elliott> and there are no existing Semigroup instances to consider
11:09:04 <typoclass> ParahSailin: yes, they are all in the base package
11:09:11 <elliott> johnw: oh, and Maybe's Monoid instance should be fixed
11:09:15 <elliott> johnw: i.e., Option should just be Maybe
11:09:20 <elliott> the instance is much better when you have Semigroup
11:09:24 <Taneb> I think the SM proposal breaks more than the AMP proposal
11:09:39 <enigmuriatic1> typoclass, it works as far as i can tell
11:09:40 <elliott> I doubt it. Monad instances are more common than Monoid instances
11:10:10 <Taneb> elliott, but adding an Applicative instance is cheap. Adding a Semigroup instance requires a whole new dependency!
11:10:18 <RichyB> exFalso1: the only way on a Unix to tell if two file handles refer to the same file is to call fstat() on both, and compare the st_dev and st_ino fields.
11:10:21 <elliott> Taneb: ...er, no
11:10:29 <elliott> Taneb: you must move Semigroup into base for this proposal to make sense at all
11:10:37 <elliott> base can't depend on semigroups to give a Semigroup superclass to Monoid!
11:10:37 <Taneb> Okay, that makes more sense
11:10:50 <Taneb> I was thinking doing it all in one step
11:10:55 <RichyB> I'm not sure what results you'll get if you try that with file handles that are bound to sockets or anything odd like signalfds.
11:11:55 <Tene> exFalso1: You can have the same file with multiple distinct canonicalized paths if there is more than one hardlink for the file.
11:12:08 <typoclass> ParahSailin: here's an example use for the ((->) a) instance: «(map toUpper <> map toLower) "aB"» will give "ABab". it'll apply the two functions, and do (++) on the two results, giving a single String
11:13:25 <johnw> elliott: I does it rite?  https://gist.github.com/5759352
11:14:03 <elliott> johnw: drop mappend from Monoid IMO, the only advantage the "AMP" gets there is because Applicative already exists
11:14:15 <elliott> rip off the bandaid by just defining mappend = (<>) at the top level (with a Semigroup constraint)
11:14:18 <johnw> so mappend is just a function?
11:14:30 <elliott> mappend :: Semigroup a => a -> a -> a; mappend = (<>) outside of any class
11:14:42 <johnw> right
11:14:45 <johnw> done
11:14:52 <elliott> also, maybe omit the class defn of Semigroup so it doesn't necessarily rule out sconcat etc.?
11:14:57 <elliott> they'd be nice to have if they can get through the bikeshed process
11:14:58 <johnw> I would actually love to see NonEmpty in base too, but that's another battle I think
11:15:05 <typoclass> johnw: sorry, i missed that -- why does it single out the Monoid instance for Maybe?
11:15:12 <elliott> I'd just leave it unsaid so edwardk can comment on it
11:15:19 <elliott> typoclass: Maybe's Monoid instance sucks because we don't have Semigroup
11:15:22 <elliott> that's why Option exists
11:15:26 <elliott> to be "Maybe but with the right instance"
11:15:34 <dmwit> johnw: That's never going to pass with that rider.
11:15:35 <elliott> but yeah, maybe quote the semigroup docs for justification there
11:15:45 <dmwit> It will break way too much stuff.
11:15:50 <elliott> rider?
11:15:59 <dmwit> elliott: part (3)
11:16:03 <johnw> dmwit: what rider?
11:16:16 <elliott> johnw: btw, your first link is broken
11:16:21 <dmwit> https://en.wikipedia.org/wiki/Rider_(legislation)
11:16:28 <elliott> dmwit: I dunno, I'd really like to fix the Maybe instance.
11:16:33 <elliott> it's one of the major issues having Semigroup would solve.
11:16:46 <elliott> and I'm not sure people actually use the Maybe monoid instance itself much
11:16:49 <elliott> (because it sucks)
11:16:53 <johnw> ok, gist updated
11:17:39 <dmwit> If you want to propose it, I'm not opposed. But make it a separate proposal so people can approve the first part and reject the second if they want.
11:17:41 <johnw> yes, the monoid instance for Maybe seems pretty useless
11:17:43 <elliott> johnw: you want mconcat in Monoid
11:17:45 <elliott> for efficiency
11:17:47 <dmwit> Don't force them to reject the reasonable part just to get the nice part.
11:18:01 <AbigailBuccaneer> @pl \xm f mem -> let (x, mem') = xm mem in f x mem'
11:18:01 <lambdabot> (line 1, column 18):
11:18:01 <lambdabot> unexpected "("
11:18:01 <lambdabot> expecting "()", natural, identifier or "in"
11:18:03 <elliott> dmwit: ok, fair enough. +1 to adding "(optional, but recommended)" to (3) or such
11:18:08 <johnw> ok
11:18:37 <elliott> I wonder if rolling in the (++) = (<>) bikeshed would be a good idea. that way the Semigroup method could be (++) :P
11:18:45 <elliott> (probably not)
11:18:58 <johnw> gist updated
11:19:31 <elliott> LGTM
11:19:37 <Tene> elliott: What's next, map = fmap?
11:19:45 <johnw> Tene: don't even tempt me this early in my day
11:19:48 <dmwit> Might want to include the actual instance, just for completeness.
11:19:50 * elliott always reads LGTM as "let google that me", because of LMGTFY
11:20:06 <johnw> we're generalizing fold (I hope), generalizing map would fit right in!
11:20:21 <johnw> dmwit: good idea
11:20:39 <elliott> I like the recent abandon of libraries@. unfortunately, it seems that the successful radical proposals are not turning into patches
11:20:44 <elliott> so nothing has actually happened yet!
11:21:22 <dmwit> elliott: Oh, I didn't even... I literally read it as "Let Me Google That" despite the character order.
11:23:04 <foofunctor> would it be possible to dynamically add a library to be linked with a program from within the program itself?
11:23:18 <johnw> hmm... should mconcat be [a] -> a, or should it be Functor f => f a -> a?
11:23:30 <foofunctor> e.g., instead of specifying -lfoo to ghc, I want to add it from my program.
11:23:38 <elliott> johnw: er...
11:23:51 <dmwit> foofunctor: Do you want something different from dynamic linking?
11:23:54 <foofunctor> I am looking at the GHC API but can't figure out how.
11:24:09 <elliott> johnw: I claim that given f :: forall f. Functor f => f a -> a,
11:24:11 <dmwit> johnw: Functor surely isn't enough.
11:24:13 <elliott> johnw: f = const x for some x.
11:24:22 <johnw> right, I need Foldable
11:24:30 <elliott> anyway, mconcat is quite good because it goes from the free monoid to your monoid
11:24:35 <foofunctor> dmwit: no, dynamic linking should suffice.
11:24:37 <elliott> johnw: that makes Foldable a bit circular, I think
11:24:41 <elliott> maybe? I don't know
11:24:41 <johnw> ah, that's a good point
11:24:51 <elliott> you could argue for BinaryTree a -> a or something.
11:24:55 <elliott> I think mconcat is fine.
11:24:58 <johnw> ok, gist updated
11:25:04 <johnw> i added a default definition for mconcat
11:25:07 <dmwit> foofunctor: Okay. I don't know much about it, but I know GHC has recently worked vaguely hard at getting that to work, so you might want to investigate the manual to see how to do it.
11:25:13 <johnw> and instance bodies for Maybe
11:25:19 <elliott> johnw: that Semigroup instance looks very dodgy :P
11:25:45 <johnw> oh, hehe
11:25:53 <johnw> added Semigroup a =>
11:26:06 <elliott> no
11:26:06 <dmwit> _ <> _ = Nothing, too, please
11:26:09 <elliott> that's not the dodgy thing about it.
11:26:15 <elliott> right, that
11:26:24 <johnw> ah, glad I'm checking this with you guys
11:26:53 <johnw> ok, final gist update?
11:27:01 <elliott> johnw: maybe insert some justification about why the instance is better?
11:27:09 <elliott> i.e., the current one requires a Monoid but only uses a Semigroup
11:27:15 <elliott> in fact, I don't think dmwit is right that (3) breaks things.
11:27:24 <elliott> it's identical except for the looser constraint.
11:27:27 <johnw> i think byorgey has a good paragraph about that in is Monoids and Variantions paper
11:27:35 <elliott> so why should it be optional?
11:27:35 <dmwit> I thought you were going to propose a different instance. So I'm glad that I asked him to flesh it out. =P
11:27:38 <elliott> ah
11:27:43 <elliott> rip off the optional tag then :)
11:27:46 <dmwit> https://byorgey.wordpress.com/2011/04/18/monoids-for-maybe/
11:28:04 <elliott> ah, right
11:28:09 <elliott> Applicative lifting instances are a delicate thing.
11:28:16 <elliott> sometimes they feel like just a cry for idiom brackets
11:28:24 <fruitFly> what is the difference between 44 and 39?
11:28:26 <fruitFly> http://www.asciitable.com/
11:28:29 <fruitFly> in ascii?
11:28:31 <typoclass> dmwit: thanks a great deal, i have the source code of semigroups' Option open and i was failing to understand how it's better
11:28:47 <elliott> fruitFly: does this have anything to do with haskell?
11:28:58 <dmwit> fruitFly: One is a comma, one is a single quote?
11:29:06 <dmwit> > "\44\39"
11:29:07 <lambdabot>   ",'"
11:29:12 <typoclass> fruitFly: looks like apostrophe and comma to me. "," vs "'"
11:29:15 <fruitFly> elliott: It's in my haskell program.. but I guess not
11:29:17 <fruitFly> sorry
11:29:22 <fruitFly> typoclass: thanks
11:29:28 <dmwit> P.S. Haskell doesn't use ASCII
11:29:35 <johnw> elliott: at the end, should I excerpt byorgey's explanation of Semigroups and the brokenness of the Maybe instance as a clarifying appendix?
11:29:45 <fruitFly> dmwit: i'm making it use it ;)
11:29:51 <johnw> just so no one can say, "I don't know what a Semigroup is"
11:30:17 <elliott> I'd just put "(a semigroup is just like Monoid but with no mempty)" somewhere in the email
11:30:22 <elliott> and I'd clarify about the instance
11:30:39 <elliott> e.g. put "(this instance is identical to the current one, except that the Monoid constraint is weakened to Semigroup)"
11:31:38 <shergill> johnw: i'd like to see that excerpt if only in a private message
11:31:48 <johnw> ok
11:32:05 <CaptainK> Anyone know if Haskell has JavaScript abilities?  Obviously not natively.
11:32:22 <elliott> depends what you want
11:32:26 <dmwit> sclv has that jmacro package.
11:32:31 <elliott> there is a Haskell to JavaScript compiler
11:32:35 <elliott> and a Haskell subset to JavaScript compiler
11:33:42 <CaptainK> no, javascript sucks...in my not so humble opinion...so don't want to convert Haskell to garbage,  jmacro sounds interesting
11:34:02 <fruitFly> > asciiIIletters = (replicate 32 '0') ++ " !" ++ ('"':[]) ++ "#$%&'()*+,-./0123456789:;<=>?@" ++ ['A' .. 'Z'] ++ "[\]" ++ ('^' : []) "_`" ++ ['a' .. 'z'] ++ "{|}~"
11:34:06 <lambdabot>   mueval-core: Time limit exceeded
11:34:23 <ski> @hackage jmacro
11:34:23 <lambdabot> http://hackage.haskell.org/package/jmacro
11:34:25 <fruitFly> I'm getting an error at ']'?
11:34:36 <fruitFly> lexical error
11:34:48 <DanBurton> has anyone got some sample code up that uses pre-existing libraries (e.g. transformers) that compiles and runs nicely with ghcjs?
11:35:11 <dmwit> fruitFly: \ is for escape codes
11:35:12 <int-e> fruitFly: you probably should use "[\\]"
11:35:13 <dmwit> fruitFly: use \\
11:35:15 <elliott> DanBurton: there is a demo of the pong gloss/lens demo compiled to ghcjs!
11:35:15 <ski> > "[\\]"
11:35:17 <elliott> without any changes
11:35:17 <lambdabot>   "[\\]"
11:35:18 <dmwit> fruitFly: But also:
11:35:27 <dmwit> > ['\0'..'\127']
11:35:28 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
11:35:30 <elliott> DanBurton: luite_ has the link, I was astounded
11:35:37 <ski> > "\""
11:35:38 <lambdabot>   "\""
11:35:55 <fruitFly> I just want \ as a character in my string
11:35:57 <int-e> > [' '..]
11:35:58 <lambdabot>   " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg...
11:35:59 <CaptainK> jmacro is also still javascripting for Haskell...
11:36:01 <ski> > "^"
11:36:02 <lambdabot>   "^"
11:36:07 <dmwit> fruitFly: That is what "\\" does.
11:36:12 <ski> > length "\""
11:36:12 <lambdabot>   1
11:36:17 <ski> > head "\""
11:36:18 <lambdabot>   '"'
11:36:19 <CaptainK> ...is there a replacement for Javascript using Haskell
11:36:20 <DanBurton> elliott: yeah that's exactly the sort of thing I'd be interested to see.
11:36:20 <fruitFly> dmwit: ooooh ok thanks :)
11:36:21 <CaptainK> ?
11:36:32 <fruitFly> > "\\"
11:36:33 <lambdabot>   "\\"
11:36:42 <dmwit> > length "\\"
11:36:43 <lambdabot>   1
11:36:45 <dmwit> > text "\\"
11:36:46 <lambdabot>   \
11:36:47 <int-e> fruitFly: (and you can write \" to include the double quote.)
11:36:58 <fruitFly> dmwit:  :D thanks!
11:37:02 <johnw> shergill: https://gist.github.com/5759519
11:37:08 <DanBurton> CaptainK: you could always write a web browser that uses Haskell as its scripting language instead of JS
11:37:12 <fruitFly> int-e: thanks
11:37:33 <DanBurton> CaptainK: or write a plugin or patch for existing browsers. Other than that, you're pretty much stuck compiling Haskell to JS
11:37:51 <Hafydd> That would almost be worth it just for the tiny possibility it would catch on.
11:38:00 <CaptainK> Yes, that makes sense...because the interpreter for JS is INside the browser
11:38:21 <CaptainK> ...damn, wish JavaScript and Flash would die a horrible quick death
11:38:34 <Hafydd> Imagine the far-reaching consequences of Haskell being "the web language".
11:39:03 <dgpratt> js will die just about the same time C dies -- i.e. never
11:39:21 <CaptainK> Damit!  and 35mm film is still in production
11:39:45 <johnw> elliott: do you think the excerpt in https://gist.github.com/jwiegley/5759352 helps or hurts?
11:39:51 <CaptainK> even the tutorial web pages for Haskell use javascript.
11:40:06 <CaptainK> arggggg...
11:40:13 <dmwit> Saying "jmacro is still just writing javascript in Haskell" is a bit funny.
11:40:16 * CaptainK pulls hair out.
11:40:20 <dmwit> Just the tagline alone makes it clear that's wrong.
11:40:27 <elliott> johnw: LGTM
11:40:30 <dmwit> "hygienic names, compile-time guarantees of syntactic correctness, limited typechecking"
11:40:44 <CaptainK> llol
11:40:48 <elliott> CaptainK: OK, so what do you want in terms of "JavaScript abilities"?
11:40:59 <elliott> we get that you think javascript sucks but not what you want
11:40:59 <johnw> ok, here goes nothing
11:41:06 <johnw> let the bikeshed be painted!
11:43:49 <CaptainK> This page offers some ideas...but your still hooked to JavaScript..
11:43:51 <CaptainK> http://altjs.org/
11:44:20 <byorgey> johnw: wait, what?  Just x <> Just y = Just (x <> y); _ <> _ = Nothing  does not make sense
11:44:29 <byorgey> if you want Nothing to act as the identity
11:44:33 <johnw> uh oh
11:44:39 <dmwit> dmwit--
11:44:50 <elliott> ugh
11:44:54 <elliott> I was even going to propose the correct clauses
11:44:59 <elliott> but then dmwit said it and I thought
11:45:01 <elliott> "oh, that's simpler"
11:45:05 <byorgey> haha
11:45:10 <johnw> I need Nothing <> _ = Nothing and _ <> Nothing = Nothing?
11:45:13 <elliott> yes
11:45:14 <byorgey> no
11:45:16 <byorgey> no!!
11:45:17 <elliott> er
11:45:18 <elliott> no!
11:45:21 <byorgey> Nothing <> a = a
11:45:21 <johnw> lol
11:45:22 <elliott> oh my god, I'm so sorry.
11:45:25 <elliott> I resign
11:45:26 <johnw> ahhh
11:45:34 <dolio> :)
11:45:35 <dmwit> elliott --
11:45:39 <dolio> PROPOSAL REJECTED.
11:45:55 <fruitFly> holy logic error lol.. gotta take a little break. any advice for dealing with them?
11:46:00 <dmwit> CaptainK: So, you want to deploy something to the browser but you don't want it to compile to javascript?
11:46:11 <byorgey> fruitFly: dealing with logic errors?
11:46:12 <johnw> so just replace the previous with Nothing <> x = x?
11:46:13 <ion> fruitfly: Try to convince them to stop laughing.
11:46:13 <dmwit> Do you also want to avoid HTML?
11:46:15 <int-e> So  Just mempty  and  Nothing  are pretty much the same?
11:46:17 <typoclass> oh man. i wanted to comment "anything mappended to anything is Nothing??" a while back when dmwit said "also _ <> _ = Nothing please", but i didn't, because i attributed to my general lack of theoretical understanding
11:46:23 <byorgey> johnw: Nothing <> x = x,  x <> Nothing = x
11:46:27 * typoclass needs to trust his instincts moar
11:46:34 <fruitFly> byorgey: yes
11:46:40 <mapreduce> Hi.  I get that type is for creating type synonyms, e.g., type Person = (Name, Address) makes quite a lot of sense..
11:46:45 <int-e> (if so, what's the point of adding the maybe?)
11:46:49 <byorgey> fruitFly: go for a walk, take a shower, go to sleep
11:46:50 <johnw> ok, I sent a correction
11:46:51 <dmwit> johnw: You also need x <> Nothing = x, of course.
11:46:52 <CaptainK> exactly.  Want o be able to turn off scripting on the browser side but still have access
11:46:54 <mapreduce> However, type Datapoint (Bayes labelIndex dist) = Datapoint dist
11:46:57 <byorgey> then think about it again later =)
11:47:01 <fruitFly> byorgey: hahaha lol
11:47:08 <dmwit> CaptainK: Oh, well, that's a very different demand.
11:47:14 <mapreduce> that makes my head hurt.  Can anyone explain it?  It's from http://izbicki.me/blog/hlearns-code-is-shorter-and-clearer-than-wekas
11:47:16 <johnw> yeah, that wasn't a very useful Monoid instance was it
11:47:20 <johnw> 0 + anything is 0!
11:47:51 <RichyB> > 0 + (0/0::Float)
11:47:52 <lambdabot>   NaN
11:48:05 <ion> mapreduce: “type … = …” in an instance definitions is something completely different from type aliases.
11:48:15 <byorgey> johnw: it's a valid Semigroup instance, but doesn't extend to a monoid
11:48:15 <dmwit> CaptainK: I don't believe there are any libraries for doing Javascript in Haskell with graceful degradation as a goal.
11:48:31 <chrisdotcode_> :t Splitter
11:48:33 <lambdabot> Not in scope: data constructor `Splitter'
11:48:38 <chrisdotcode_> :i Splitter
11:48:45 <mapreduce> ion: Ah, ok.  That's probably enough to get me reading the right stuff, thank you.
11:49:07 <ion> mapreduce: http://www.haskell.org/haskellwiki/GHC/Type_families
11:49:26 <chrisdotcode_> @src Splitter
11:49:27 <lambdabot> Source not found. Take a stress pill and think things over.
11:49:44 <CaptainK> don't want to do javascript in haskell, want to do javascript "like" programs with Haskell instead
11:49:47 <CaptainK> http://www.haskell.org/haskellwiki/The_JavaScript_Problem
11:49:55 <elliott> mapreduce: the explanation of the magnitude of the claim is that it's a lie
11:50:07 <elliott> mapreduce: it's a handful of lines of code, plus a bunch of library code it intimately depends on to do what it wants :P
11:50:25 <elliott> (no doubt that the gains over the Java code in terms of concision and power are massive. but the claim is overstated)
11:50:32 <mapreduce> Right, and if you start competing with Java on lines of code someone gets reflection out.
11:51:14 <CaptainK> http://www.haskell.org/haskellwiki/The_JavaScript_Problem
11:51:18 <ion> mapreduce: That basically defines a type-level function named “Datapoint” for that instance. When applied to Bayes _ dist on type level, it’ll evaluate to Datapoint dist, which will again evaluate to something else.
11:51:25 <int-e> mapreduce: hah: don't shoot at java code with a laser.
11:52:35 <dmwit> I really don't understand what you are hoping Haskell can do.
11:52:48 <johnw> @faq Can Haskell do whatever one hopes it can?
11:52:48 <lambdabot> The answer is: Yes! Haskell can do that.
11:52:51 <dmwit> You are hoping Haskell can rewrite the user's browser to accept some scripting language that is not Javascript?
11:52:56 <dmwit> Like... no, you can't do that.
11:53:33 <dmwit> If you want a scripting language that works everywhere and isn't Javascript, well, you better start submitting patches to browser vendors.
11:54:15 <dolio> @faq Can Haskell join the Mozilla foundation and change their policy on pushing JavaScript as a shitty virtual machine language?
11:54:15 <lambdabot> The answer is: Yes! Haskell can do that.
11:54:36 <elliott> dmwit: hey, hey. we could compile Haskell to VBScript
11:54:38 <elliott> and run it in IE
11:54:43 <elliott> Javascript avoided!
11:54:56 <Botje> asm.js is within reach, actually :-)
11:55:12 <elliott> I am accepting donations for my "Compile Haskell To VBScript" kickstarter
11:55:58 <Hafydd> Hahah.
11:55:59 <dgpratt> CaptainK: I guess it's fine to 'want' what you want, but I do not find what you 'want' to be reasonable or rational
11:56:24 <int-e> elliott: why don't you target a serious programming language like cobol?
11:56:36 <elliott> int-e: unfortunately IE does not yet support COBOLScript
11:56:53 <CaptainK> dgpratt:  that is so true...I don't believe what I want is resonable either...but dam I sure want it!
11:58:55 <luite_> Botje: but it's pretty hard to compile haskell to that
11:59:00 <CaptainK> and with node.js getting popular...I can forget the dream of javascript free world
11:59:03 <CaptainK> http://en.wikipedia.org/wiki/Node.js
11:59:13 <dolio> I don't think it's unreasonable to not want to compile to javascript, but it's not going to be an option.
11:59:48 <CaptainK> seems not so pretty yet, but it is an option if you want a bar brawl in your code
11:59:56 <fruitFly> i cracked the code!
12:00:12 <dgpratt> dolio: why should one care if their code gets compiled to javascript?
12:00:30 <luite_> CaptainK: i find node.js quite useful
12:00:32 <dolio> dgpratt: Because javascript is a terrible target language.
12:00:36 * elliott uses the BSD3 plus No Compiling to JavaScript clause license for all his projects
12:00:44 <johnw> haha
12:00:48 <typoclass> dolio: i thought google was working on that subset of x86 assembly that was safe to run from untrusted sources. nacl or whatever it was called
12:00:52 <c_wraith> luite_: useful for what?
12:00:56 <johnw> also, asm.js
12:01:00 <dgpratt> dolio: well, that's a problem for the person writing the compiler, no?
12:01:03 <dolio> typoclass: They are. And no one else is going to support it.
12:01:03 <johnw> yes, nacl!
12:01:17 <luite_> c_wraith: for automated testing of ghcjs output
12:01:49 <c_wraith> luite_: Oh, because it has test frameworks available that don't assume a DOM?
12:01:57 <CaptainK> was hoping haskell would be the "one ring to rule them all"...what a fantasy :-(
12:02:09 <c_wraith> No language will ever be the best at everything.
12:02:11 <dolio> dgpratt: It's going to be a problem for users if their Haskell-like language is crippled because the target language doesn't support proper tail calls and such.
12:02:21 <CaptainK> I having to learn every frickin language out there!
12:02:48 <luite_> c_wraith: nah just because it's a relatively lightweight js environment that's easy to install, and can do file io, command line args and stdin/out/err easily
12:02:56 <ski> learn lambdaProlog ?
12:03:07 <CaptainK> ya, but from what I can tell, (albeit noobie perspective), haskell looks beautiful
12:03:11 <ion> captaink: You’ll notice all languages much with many others.
12:03:20 <johnw> CaptainK: if only ever other language could just become an EDSL in Haskell...
12:03:27 <dolio> But in general I don't even care if it shows up as a problem for users.
12:03:34 <elliott> if only Haskell would die and be replaced by Epigram 2
12:03:48 <josephle> elliott: if only Epigram 2 was actually released
12:03:52 <c_wraith> elliott: wouldn't that require epigram 2 existing?
12:04:02 <elliott> yes. that is why it is my fantasy
12:04:10 <ion> I have switched from Haskell to @. It is great.
12:04:11 <dolio> I think it's stupid to do stuff like design a dialect of JavaScript where you insert no-ops into your code to 'declare types' so an optimizer can make it run more like machine code.
12:04:16 <elliott> however, it is less fantastical than wishing for all other languages to be replaced by haskell
12:04:20 <catchmrbharath> Hi, I was learning haskell using 'Learn you a haskell for great good'. The problem I am bumping into is lack of exercises. Even though there are enough examples, I would like to get a little challenged with exercises. Can somebody recommend places to find exercises?
12:04:22 <elliott> and I think it's a better outcome!
12:04:34 <dolio> Instead of just designing a sane lower level representation and standardizing on that.
12:05:00 <CaptainK> http://c2.com/cgi/wiki?EmbeddedDomainSpecificLanguage
12:05:02 <johnw> elliott: how do you like Idris compared to E2?
12:05:12 <haasn`windows> So what's the most pain-free way of interacting with MySQL servers using Haskell?
12:05:23 <johnw> haasn`windows: persistent is pretty nice
12:05:34 <typoclass> @hackage persistent
12:05:34 <lambdabot> http://hackage.haskell.org/package/persistent
12:05:46 <dmwit> choice may depend on whether the schema predates your code or not
12:06:32 <elliott> johnw: I tried to use idris for toy purposes once or twice. it is certainly a commendable effort, and will hopefully mature well. however, in its current state, it is nowhere near as usable as Haskell (if you think GHC's errors are bad)...
12:06:34 <haasn`windows> it does
12:06:35 <ion> For low-level SQL, HDBC should work.
12:06:35 <ThatOtherPerson> catchmrbharath: try writing your own versions of Prelude functions (such as tail and ++)
12:06:40 <dmwit> catchmrbharath: Well, you could do the 99 Lisp Problems that are transliterated to Haskell on the wiki. Project Euler is another popular choice.
12:06:43 <elliott> johnw: ...and its ideal form isn't as good as Epigram 2's ideal form would be.
12:06:59 <haasn`windows> specifically, I need to fetch a list of users from a table, for each of them do some computing then update some result
12:07:02 <dmwit> Oh, yes, and reimplementing the Prelude is a great choice.
12:07:05 <elliott> it is certainly more expressive than Haskell, and its goals are modest enough that it might fail at avoiding success at all costs
12:07:16 <CaptainK> catchmrbharath: Try here, https://www.fpcomplete.com/school/haskell-fast-hard/haskell-fast-hard-part-1
12:07:27 <elliott> but I've drunk too much kool-aid to just "settle for less" when looking for a next-generation language to hope for :)
12:07:38 <johnw> true enough
12:08:01 <CaptainK> Was it the RED koolaid?  THe red dye is suppose to make ADHD people go crazy
12:08:04 <elliott> part of the problem is of course that it is easy to imagine away the flaws Epigram 2 would have by its vapourware status
12:08:19 <CaptainK> maybe that's why I'm having these rediculous fantasies
12:08:32 <elliott> but honestly, intensional equality is so awful. working with it is total hell, just having observational equality would be an amazing improvement
12:08:41 <catchmrbharath> dmwit: Thanks. 99 Haskell problems looks nice.
12:21:11 <rovar> this is giving me trouble:
12:21:15 <rovar> combine' :: Num a => (a -> a -> a) -> Value -> Value -> Value combine' fun (IntVal a)  (IntVal b)  = IntVal $ fun a b
12:21:45 <rovar> IntVal's constructor is   IntVal Integer
12:21:59 <dmwit> I guess you should take an (Integer -> Integer -> Integer), then.
12:22:09 <rovar> so if I'm passing what is obviously   Integer and Integer into fun
12:22:13 <dmwit> Otherwise you are letting the guy who calls combine' choose which Num instance to use.
12:22:43 <rovar> The problem is that there are other patterns..  (RealVal a) (RealVal b)
12:22:44 <rovar> etc
12:22:51 <dmwit> Alternately, you could use combine' :: (forall a. Num a => a -> a -> a) -> Value -> Value -> Value to demand that the function the caller uses works for every Num, rather than the Num they chose.
12:23:31 <dmwit> rovar: No problem, just take two functions. =)
12:23:47 <rovar> so how do I specify that if the user passes in   two Values,  an IntVal and a RealVal, the result is a RealVal?
12:23:49 <dmwit> combine' :: (Integer -> Integer -> Integer) -> (Double -> Double -> Double) -> (Value -> Value -> Value).
12:24:33 <latro`a> there's an "integer handler" and a "real handler", or else there's one handler that works for any Num
12:24:36 <latro`a> at least it sounds that way to me
12:24:46 <dmwit> rovar: Suppose you could write any code you wanted for that case. What would you write?
12:25:08 <dmwit> I mean, would you convert the Int to a Double first, or what?
12:25:40 * [swift] wishes all the standard functions in IO used MonadIO instead
12:25:51 <[swift]> sure would save a lot of lifting
12:25:59 <dmwit> Some have to use IO specifically. But for most, yeah, I wish that, too.
12:26:09 <johnw> dmwit: me too.  On to libraries@!
12:26:12 <dmwit> e.g. the exception-specific ones have to be IO.
12:26:20 <elliott> I don't wish taht precisely because some of them need to use IO
12:26:25 <johnw> dmwit: what about Control.Exception.Lifted?
12:26:31 <elliott> if we had a good set of classes such that exception machinery could use well-defined abstractions rather than IO directly then sure.
12:26:41 <elliott> johnw: monad-control is essentially evil.
12:26:48 <dmwit> johnw: What about it?
12:27:04 <rovar> dmwit: yes.  Your forall worked,  I still don't fully understand why
12:27:19 <dmwit> rovar: Would you like to understand why?
12:27:31 <rovar> except I should probably be using fractional instead of Num / Real, I guess.
12:27:34 <dmwit> johnw: Let me know when there's a paper explaining the semantics.
12:27:35 <rovar> dmwit: yes.
12:27:51 <dmwit> rovar: okay, one moment
12:27:52 <johnw> dmwit: i'm not aware of a paper, I'm just thinking of monad-control
12:28:13 <dmwit> I was under the understanding that basically every current approach to lifting exception handling to transformed monads was broken in one way or another.
12:28:42 <elliott> dmwit++ re paper
12:28:44 <[swift]> hmm... hadn't realized that issue existing
12:28:47 <[swift]> *existed
12:29:35 <dmwit> rovar: How do you feel about imagining that every polymorphic function is actually a function which takes a type and returns a monomorphic function using that type?
12:30:01 <johnw> dmwit: the top of this page has a nice summary: http://hackage.haskell.org/package/monad-exception
12:30:03 <rovar> dmwit, that seems fair
12:30:38 <dmwit> rovar: Cool. So, in Haskell 2010, we have to read all type variables as if there is some big outer type function.
12:30:54 <dmwit> e.g. (a -> b) -> [a] -> [b] is really "forall a b. (a -> b) -> [a] -> [b]".
12:31:12 <dmwit> where here the explicit "forall a b." essentially means "I am a function that takes two types".
12:31:41 <dmwit> But you might reasonably have such polymorphism in other places.
12:31:56 <[swift]> so is it safe to move functions that may throw an exception from IO to MonadIO? or are there just problems for things like catch?
12:32:03 <chrisdotcode_> hey guys, where can I read more about the logging monad that was described in LYAH?
12:32:04 <dmwit> For example, think about the type "(forall a. a -> a) -> String".
12:32:15 <dmwit> [swift]: Generally the problem is in functions that use IO in a negative position.
12:32:23 <rovar> but why can't the type system recognize that I'm taking a function that takes two values of the same type and should return a value of the same type?
12:32:32 <dmwit> rovar: One moment, we'll get to that.
12:32:40 <DanBurton> chrisdotcode_: you may be interested in this http://adit.io/posts/2013-06-10-three-useful-monads.html
12:32:53 <chrisdotcode_> DanBurton: thaaaank you :-)
12:33:42 <dmwit> rovar: So, this type, "(forall a. a -> a) -> String" says, "I am a function which takes a (function that takes a type and returns a function) and returns a String". Compare that to "forall a. (a -> a) -> String", which says, "I am a function that takes a type and another function and returns a String".
12:34:07 <[swift]> dmwit: i see, thanks
12:34:15 <dmwit> rovar: In the former, the person using this type has to hand off a polymorphic thing; in the latter, the person using this type gets to pick a specific type and hand off something that only works for that one type.
12:34:53 <dmwit> Are you with me so far, or am I butchering this explanation?
12:34:55 <dmwit> honestly can't tell
12:35:11 <dmwit> back in 45-60s
12:37:09 <typoclass> dmwit: as far as i'm concerned, that explanation is very good
12:37:31 <dmwit> We can make it even simpler. Compare "forall a. a -> Int" and "(forall a. a) -> Int".
12:37:44 <dmwit> The former says "pick a type, then pick a value of that type, and I will give you an Int".
12:38:01 <dmwit> The latter says "pick a value such that, when I pick a type, you have that type; then I will give you an Int".
12:38:55 <johnw> barring undefined, the possible definitions of (forall a. a) -> Int are extremely limited
12:39:30 <thoughtpolice> dmwit: how was hac phi?
12:39:54 <dmwit> johnw: (yes)
12:40:05 <rovar> dmwit:  so how can the caller specify the type in the case above?
12:40:08 <dmwit> thoughtpolice: It was busy, as ever!
12:40:42 <rovar> in either of your latest examples
12:40:54 <johnw> dmwit: actually, aren't the possible definitions of forall a. a -> Int exactly as limited?
12:41:13 <chrisdotcode_> guys, can you attach a function annotation to a type signature in ghci? I'm trying to make the function half work on Ints, not floats.
12:41:14 <dmwit> rovar: Well, Haskell makes all these type instantiations implicit, so we'll have to invent some syntax.
12:41:24 <chrisdotcode_> > half = (/2)
12:41:26 <lambdabot>   <hint>:1:6: parse error on input `='
12:41:26 <latro`a> are there more than one value of type (forall a. a)?
12:41:31 <chrisdotcode_> > let half = (/2)
12:41:32 <lambdabot>   not an expression: `let half = (/2)'
12:41:42 <Botje> chrisdotcode_: you cannot do that.
12:41:48 <Botje> chrisdotcode_: use the div function instead.
12:41:56 <Botje> :t (`div` 2)
12:41:56 <lambdabot> Integral a => a -> a
12:41:59 <chrisdotcode_>  Botje: ah, thank you :)
12:42:01 <dmwit> rovar: Let's invent some syntax like if "foo :: forall a. T" then "foo @ A" has type "T" with "A" substituted for "a".
12:42:07 <roconnor> jmcarthur: the name "darken" comes from Porter & Duff's paper: Compositing Digital Images.  That is my excuse, although it may not be a good excuse.
12:42:11 <chrisdotcode_> Botje: but there's no way to add a type signature in ghci?
12:42:25 <Botje> chrisdotcode_: let foo = definition :: Type
12:42:37 <Botje> chrisdotcode_: but you cannot force (/2) to work with Ints.
12:42:46 <Botje> as / requires your type to be Fractional. whereas Int is Integral
12:42:53 <chrisdotcode_> Botje: oh, okay. so it's a problem with (/). alright, thanks! :)
12:43:07 <Botje> chrisdotcode_: to see that in action
12:43:09 <Botje> try something like
12:43:10 <dmwit> johnw: "forall a. a -> Int" can be "undefined" or can be any constant function. "(forall a. a) -> Int" has those options plus the option "\x -> x".
12:43:10 <rovar> that @ seems to be the missing piece here.   I thought the instantiation for my code would have been implicit
12:43:14 <Botje> let foo = return 5 :: [Int]
12:43:21 <Botje> and let foo2 = return 5 :: Maybe Int
12:43:22 <dmwit> johnw: (and many more such things)
12:43:37 <elliott> rovar: it is
12:43:41 <elliott> dmwit invented the notation
12:43:41 <chrisdotcode_> okay, I think I get it. thanks for the help.
12:43:42 <dmwit> rovar: Yes, in Haskell, all instantiation is implicit.
12:43:56 <johnw> dmwit: ah, nice
12:44:00 <johnw> i didn't think of id
12:44:17 <rovar> then why did the type checker complain when I took a function   a -> a -> a and passed it two items which were obviously Integers and it couldn't figure out that it needed to return an integer?
12:44:25 <elliott> because your function was
12:44:29 <elliott> forall a. (a -> a -> a) -> ...
12:44:37 <elliott> (the outermost "forall"s are implicit in Haskell)
12:44:43 <elliott> or, dmwit is probably getting to that.
12:44:52 <elliott> however, it's not "couldn't figure out"
12:44:53 <dmwit> rovar: Before we get to your type, have you grokked how "forall a. a -> Int" and "(forall a. a) -> Int" are different?
12:45:01 <elliott> it's that you lied to the compiler, your type claimed wrong things :P
12:45:02 <rovar> yes
12:45:04 * elliott lets dmwit continue
12:45:11 <dmwit> rovar: The difference is whether the person who has a value of that type gets to instantiate the type or whether the value itself gets to instantiate the type.
12:45:21 <dmwit> rovar: Okay, good.
12:45:46 <dmwit> rovar: So now, "forall a. (a -> a -> a) -> Value -> Value -> Value" means that the person who has a value of that type gets to instantiate the type to *anything they like*.
12:45:50 <dmwit> Including things that are not Integer.
12:46:23 <dmwit> For comparison, "(forall a. a -> a -> a) -> Value -> Value -> Value" means that the person who implements a value of that type gets to instantiate the type, and in particular can choose to instantiate it to Integer.
12:47:05 <dmwit> ...and yes, as elliott says, the missing piece is that in Haskell 2010, all foralls are floated as high to the top level as they possibly can be, because type inference with higher rank types is undecidable.
12:47:35 <rovar> when you say person, do you mean the function that passes in the (a -> a -> a) function or the one that executes it?
12:47:46 <dmwit> So that "(a -> a -> a) -> Value -> Value -> Value" is internally "forall a. (a -> a -> a) -> Value -> Value -> Value" and not "(forall a. a -> a -> a) -> Value -> Value -> Value".
12:48:06 <dmwit> I feel that every time I said "person" I followed it up by a description of the person that should nail it down.
12:48:14 <dmwit> Can you quote an exact line where you'd like clarification?
12:49:09 <rovar> so if I had a function that was implicitly  "forall a. (a -> a -> a) -> Value -> Value -> Value.   How would I declare which type a should be?
12:49:21 <rovar> or can i?
12:50:04 <dmwit> When you use it, you will pass it a function as its first argument; the type of this function will (hopefully) determine which 'a' to use.
12:51:01 <dmwit> e.g. if you pass it a function of type "Int -> Int -> Int", then 'a' will be instantiated to "Int".
12:51:31 <rovar> ah, I think I got it.  Since the forall was floated to the highest level,  I can't pass it a function that is a -> a -> a
12:51:41 <rovar> it needs to be concrete
12:52:33 <rovar> but if I constrain it to the inner function, then it can infer by the params passed in.   the outer scope doesn't specify a type
12:52:40 <dmwit> Well, you can pass it a function that happens to be polymorphic. But it will be made monomorphic before it's passed.
12:53:04 <dmwit> If the forall is pushed inside, you can (will be forced to) pass something that is still polymorphic.
12:53:11 <rovar> if combine`  returned something that was explicitly Int,  like IntVal, if that were possible, then there would be no error
12:54:06 <dmwit> I think your line at :57 was right, but this last line (at :58) was not.
12:54:21 <typoclass> rovar: (combine` isn't a valid function name, but combine' is)
12:54:24 <dmwit> (your lines up to :57, even)
12:54:52 <rovar> it is combine',  I just missed my key by a column
12:55:09 <typoclass> rovar: alright :) just double-checking
12:55:56 <chrisdotcode_> hey dmwit, (sorry to bother you), but do you remember the problem I asked for help with a while back (getting the ID out of a csv row)? would the writer monad be good for that? (ID, rest of the line), right?
12:56:36 <dmwit> I... guess you could shoehorn it in. It doesn't seem like it would be particularly helpful to me.
12:56:36 <rovar> dmwit:  thanks for your help.
12:56:44 <dmwit> rovar: very welcome =)
12:56:57 <dmwit> rovar: If you like this, buy TAPL and become a programming languages researcher like I did. =D
12:57:26 <josephle> yay, type theory!
12:57:46 <mapreduce> I bought TAPL, it's very pretty on the bookshelf.
12:58:55 <chrisdotcode_> dmwit: yeah, I'm trying to find a proper abstraction for it...
12:59:18 <chrisdotcode_> because then I have to filter out rows that are less than a certain ID.
12:59:30 <elliott> dmwit: wow, #haskell even gives career advice now
12:59:34 <dmwit> chrisdotcode_: Have you mucked about with parser combinators?
12:59:53 <dmwit> If not, perhaps now is a good time to try. =)
12:59:59 <chrisdotcode_> dmwit: I only know combinators by name, and I'd eventually like to learn about parsers.
13:00:29 <chrisdotcode_> dmwit: I'd like to learn about combinators; are there resources on haskell.org?
13:00:30 <dmwit> chrisdotcode_: Also, when you're done, you might give a shot upgrading to one of the existing CSV-parsing libraries. ;-)
13:00:41 <dmwit> chrisdotcode_: err, hm
13:00:45 <josephle> elliott: see if you can send people to University of Nottingham and get Epigram 2 out :P
13:01:00 <dmwit> chrisdotcode_: Combinators themselves probably aren't worth studying too carefully.
13:01:18 <dmwit> I mean, the basic idea is you make big parsers out of little ones. That's a combinator.
13:01:36 <dmwit> (The technical definition is a bit different than that. But.)
13:01:59 <chrisdotcode_> I remember something about no fixed-point variables.
13:02:06 <chrisdotcode_> and const and id were combinators
13:02:18 <johnw> like, the SKI calculus?
13:02:21 <josephle> chrisdotcode_: no free variables
13:02:26 <chrisdotcode_> josephle: yeah, that's it!
13:02:32 <chrisdotcode_> free, not fixed-point, thanks
13:02:47 <chrisdotcode_> but when would you *ever* have free variables?
13:03:11 <josephle> chrisdotcode_: closures
13:03:13 <dgpratt> going through TaPL has been an excercise in frustration for me, but I haven't given up on it yet
13:04:06 <dolio> SKI doesn't have variables period, except the meta-variables in the reduction rules for S, K and I.
13:04:22 <chrisdotcode_> josephle: isn't everything in haskell a closure techincally?
13:04:24 <josephle> dgpratt: you can try PFPL, but that might frustrate you just as much :/
13:04:28 <chrisdotcode_> *technically
13:04:29 <dgpratt> most, if not all of the proofs made sense to me, but I could never come up with them on my own
13:05:08 <dmwit> chrisdotcode_: Anyway, I recommend the official Parsec tutorial.
13:05:11 <josephle> chrisdotcode_: now who gave you that idea?
13:05:12 <dolio> You just write stuff like SKK(SKK)
13:05:22 <dmwit> It's a bit out of date, but it's usually pretty easy to find the modern counterpart of the tutorial's old function names.
13:05:28 <exFalso1> is there a way to Lift a function in TH? that is is there a way to compute a closure at compile time to be used later at runtime?
13:05:31 <chrisdotcode_> josephle: I think I read it somewhere?
13:05:43 <carter> lispy the problem with -pgma clang is cabal ignores it
13:05:46 <chrisdotcode_> dmwit: so I'd learn how to both write a parser *and* learn about combinators at the same time?
13:05:48 <josephle> dolio: Challenge: write Y in terms of S, K, and I! no cheating and writing a lambda calculus to SKI translator :P
13:05:56 <dmwit> chrisdotcode_: yes
13:06:08 <chrisdotcode_> sound awesome. thanks a bunch
13:06:56 <josephle> chrisdotcode_: for future reference, not everything in haskell is a closure, but closures are very ubiquitous
13:06:57 <dcoutts> carter: using it how? it's not a flag to cabal of course, you're passing it through to ghc presumably
13:07:27 <dolio> Well, SII(SII) is the trivial loop, right?
13:07:27 <carter> dcoutts cabal doesn't pass ghc options to ghc when its using ghc as the build driver for c code
13:07:31 <chrisdotcode_> josephle: doesn't anything curried automatically create a closure? and all functions in haskell are curried?
13:07:37 <carter> dcoutts which is a huge pain for me
13:07:51 <dolio> Or S(SKK)(SKK)(S(SKK)(SKK)) if you don't like I.
13:08:16 <carter> because i'm writing SIMD codes, and -march=native + ghc on mac = sad times
13:08:25 <exFalso1> i'll answer my own question: no, silly boy
13:08:32 <carter> dcoutts becaue the system assembler doesn't know avx
13:08:40 <carter> but any newish gcc does
13:08:42 <josephle> chrisdotcode_: everything curried does create a closure, but single argument functions (like id x = x) don't create closures
13:08:43 <dcoutts> carter: are you sure? the --$PROG-options is a generic mechanism that passes options whenever the program is called, it's not done on a per-call basis
13:08:59 <carter> dcoutts is there any way to write that in the cabal file?
13:09:47 <carter> dcoutts lemme link you to the relevant tickets
13:09:51 <dcoutts> carter: no, that's something the builder can control, it's not for package authors
13:10:07 <carter> dcoutts well, then its broken
13:10:09 <dcoutts> because the builder can always do that anyway by using a wrapper script
13:10:14 <carter> i need to insist on clang on mac
13:10:25 <carter> or I need to write my own wee build driver hack
13:11:19 <carter> otherwise normal mortal uses will get crazy errors when they try to build my c codes via gcc
13:11:26 <carter> because the assembler will be sad
13:11:28 <carter> and barf
13:11:29 <dcoutts> that's not something cabal lets you demand as a package author
13:12:28 <carter> dcoutts well, then i have to do a crazy outside of cabal hack
13:12:48 <carter> because otherwise if a mac user tries to cabal install my code, they'll get an assembler error
13:13:01 <dcoutts> carter: this is .c files with embedded asm?
13:13:02 <carter> https://github.com/haskell/cabal/issues/1348
13:13:11 <carter> dcoutts nope, simd intrinsics functions
13:13:16 <dcoutts> ah ok
13:13:25 <carter> i just want to say --march=native
13:13:50 <carter> and maybe -pgma clang -pgmc clang
13:13:54 <carter> and move on with my life
13:14:00 <carter> every mac will have those installed
13:14:05 <carter> from dev tools
13:14:14 <dcoutts> you can hack it in the Setup.hs
13:14:19 <carter> nope
13:14:27 <carter> dcoutts oh
13:14:35 <carter> you mean write my own build driver embedded in setup.hs?
13:14:36 <carter> yeah
13:14:38 <carter> i have no choice
13:14:39 <dcoutts> yes, because there you can do more or less the same thing as the --ghc-options
13:14:40 <carter> and i'm not happy
13:14:56 <dcoutts> carter: no, much easier, just a matter of adjusting the program environment of the build
13:15:35 <carter> dcoutts… how do i do that without also accidentally essentially setting pgmcpp clang?
13:15:41 <dcoutts> carter: the general issue here is that you as a package author want this very detailed control, but that's in general not really compatible with what package builders need
13:16:00 <carter> dcoutts i need this so users on mac can have a build that just works
13:16:05 <dcoutts> I realise
13:16:08 <carter> and so i'm not supporting some weird fragile thing
13:16:18 <dcoutts> we let package authors specify constraints, but we don't have any way to express a constraint on the C toolchain
13:16:27 <carter> dcoutts … yes
13:16:53 <dcoutts> carter: I'm not sure I understand your question about pgmcpp
13:17:07 <carter> dcoutts how do i set the enviroment to point to clang
13:17:10 <carter> for c building
13:17:14 <carter> but not for cpp passes?
13:17:24 <carter> (c building and assembling)
13:17:34 <dcoutts> carter: the Setup.hs lets to get at the "program configuration" environment, which is the same mechanism that the --$PROG-options system uses
13:17:48 <dcoutts> that means every invocation of a program will use the flags you specify
13:17:57 <dcoutts> as if you were using a wrapper script for that program
13:18:13 <carter> dcoutts oh? how? the cabal library surface area is kinda huge so i've no idea where to look for this
13:18:25 <dcoutts> carter: it's not a mechanism that distinguishes between the different reasons that the program might be invoked
13:18:45 <dcoutts> it's just as if you were using a wrapper script for that program
13:18:46 <carter> dcoutts ok, so how do i set the pgma and pgmc flags to cang that way
13:18:49 <carter> *clang
13:19:03 <carter> via that mechanism?
13:19:29 <Frostix> Could anyone help me set up Leksah?
13:19:58 <Frostix> Nevermind.
13:20:26 <dcoutts> carter: I think the easiest way is to use the UserHooks, the hookedPrograms part.
13:20:37 <dcoutts> carter: http://hackage.haskell.org/packages/archive/Cabal/1.16.0.3/doc/html/Distribution-Simple-UserHooks.html
13:20:44 <carter> dcoutts thanks
13:21:08 <dcoutts> carter: override the programPostConf for the ghc program
13:21:34 <carter> dcoutts ok, thanks!
13:21:36 <joelteon> why is this happening with cabal ghci? https://gist.github.com/anonymous/5ed35a70dbc892bd02d8
13:21:37 <dcoutts> get the ghcProgram value from Distribution.Simple.Program.Builtin
13:21:51 <eacameron> Why isn't something like this available as a standard lib?? http://hackage.haskell.org/packages/archive/tagsoup/0.8/doc/html/Text-StringLike.html
13:22:08 <tunixman> Hello!
13:22:15 <tunixman> I was talking with carter at one point and he mentioned Machines. I've downloaded it and have the slides and was wondering if there's any code somewhere I could look at.
13:22:18 <tunixman> And I may have been in the wrong channel too.
13:22:35 * hackagebot io-streams 1.1.0.1 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.0.1 (GregoryCollins)
13:22:37 <carter> tunixman lens was the right channel :)
13:22:38 <ParahSailin> is there a better way to do read <$> digits? (digits from Parsec)
13:23:01 <dcoutts> eacameron: because it's the wrong approach to the abstraction
13:23:09 <tunixman> excellent! thank you sir :)
13:23:17 <carter> dcoutts thanks, i'd been asking people about this for the past few weeks and hadn't gotten this suggestion before
13:23:18 <carter> thanks
13:23:26 <dcoutts> eacameron: it's better to pick the appropriate string type and do any conversion on the boundary, almost certainly faster too
13:24:04 <edwardk> tunixman: pchiusano has some code using it, so does Apocalisp.
13:24:19 <edwardk> not sure how much is written using the Haskell machines or just the scala machines
13:24:42 <dcoutts> carter: it's also useful to realise that cabal has this notion of package author vs package builder, and they're separate roles. And the builder is ultimately the one running things so they get more control. But the Setup.hs is an escape hatch for hacky things
13:25:14 <carter> dcoutts ok, are there any good examples of using the postconf hooks in this way?
13:25:36 <eacameron> dcoutts: I'm annoyed by typing myByteString = beginning `B.append` "middle" `B.append` end
13:25:49 <johnw> eacameron: <> works too
13:25:51 <dcoutts> carter: none spring to mind, but that should be fairly straightforward
13:25:57 <dcoutts> eacameron: right, Monoid <>
13:26:25 <eacameron> johnw: dcoutts: whoa! where's that??
13:26:34 <elliott> Data.Monoid
13:26:36 <joelteon> Data.Monoid
13:26:41 <johnw> if your GHC is 7.4 or higher, it's in the Prelude
13:26:42 <elliott> perhaps soon to be Data.Semigroup
13:26:44 <dolio> josephle: S(K(SII))(S(K((S(K(SS))K)(SII)))K) is what I got. I didn't exactly do Y, though.
13:26:46 <elliott> johnw: wat
13:26:47 <dcoutts> carter: the examples I know of are using an older more verbose approach, so let me know if that works out ok
13:26:51 <dmwit> ParahSailin: http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Token.html#v:natural maybe?
13:26:53 <elliott> no it isn't
13:26:56 <elliott> I just tried
13:26:57 <johnw> I don't have to import Data.Monoid to use <>, do I?
13:27:02 <eacameron> thank you!
13:27:21 <dolio> Easy to see why everyone loves SKI programming.
13:27:33 <joelteon> I went on a SKI trip once
13:27:34 <johnw> oh, wow, maybe I do
13:27:37 <dcoutts> johnw: it's not in the Prelude, you do have to import it
13:27:39 <bitonic> johnw: we still don’t have Functor m => Monad m, and you hope for monoid!  anyway, I’m pretty sue you do need to import it
13:27:45 <bitonic> johnw: also, <> is a recent addition
13:27:49 <johnw> I guess I just reflexively import Data.Monoid everywhere, so I've never noticed that it wasn't in the Prelude!
13:27:57 <elliott> bitonic: Applicative m => Monad m is passing with flying colours on libraries@
13:28:04 <bitonic> elliott: ohhhhhhhh
13:28:15 <bitonic> I stopped reading those 100-messages threads
13:28:15 <DanBurton> exciting stuff
13:28:39 <johnw> i wish I had the whole haddocks from hackage as a single Texinfo file
13:28:41 <johnw> WISH
13:28:41 <carter> dcoutts ok, i'm mostly confused because i don't see how after I set the hooks, that cabal can see the settings
13:28:43 * elliott is too jaded to be excited by things that should have been done years ago
13:28:58 <DanBurton> lol
13:29:05 <johnw> elliott: C++ still doesn't have modules, but that doesn't stop people from getting excited about the possibility.... 30 years later
13:29:14 <dcoutts> carter: you need to use the build-type: Custom, or cabal will ignore your Setup.hs
13:29:17 <Taneb> dolio, did you see my factorial program I wrote a while back?
13:29:21 <carter> oh, i should use confhook?
13:29:33 <carter> postconfhook doesn't look like it gives anything back
13:29:40 <dcoutts> carter: should not be any need to use any other hooks
13:29:55 <dcoutts> carter: but you need to use main = defaultMainWithHooks
13:30:07 <dolio> Taneb: No.
13:30:15 <carter> yeah
13:30:24 <edwardk> johnw: re semigroups in base. i'm somewhat concerned that this proposal interacts poorly with the other changes that are in flight.
13:30:25 <Sonarpulse> johnw: did you see where I referenced you talking about my FFI struggles?
13:30:32 <Taneb> http://hpaste.org/71201 dolio
13:30:38 <johnw> Sonarpulse: no, where?
13:30:43 <johnw> edwardk: oh?
13:30:43 <Sonarpulse> in this channel
13:30:46 <dolio> Wow.
13:30:59 <Sonarpulse> last 24 hours or so while you were AFK
13:31:07 <johnw> edwardk: I'm fully OK with the change coming later, I would just like it to be "on the books" so to speak
13:31:12 <Taneb> dolio, that is SKI programming
13:31:16 <edwardk> johnw: notably the Foldable/Traversable generalization and Applicative/Monad proposal require adding a fair bit to the Prelude.
13:31:24 <johnw> even just getting pre-approval would be nice
13:31:27 <Sonarpulse> sorry to continuously seek you out, but you do know your own tool the best :)
13:31:45 <johnw> AMP+FT for Haskell 2013, SM for Haskell 2014!
13:31:51 <dcoutts> carter: there are several examples on hackage of packages using non-trivial Setup.hs scripts, that's perhaps what you want.
13:31:52 <dcoutts> http://www.haskell.org/cabal/users-guide/developing-packages.html#more-complex-packages
13:32:01 <edwardk> the former brings Monoid into the _Prelude_ via foldMap. the latter also brings in Applicative. so a lot of classes will go into Prelude with the current changeset
13:32:13 <johnw> ah, treu
13:32:14 <dmwit> Isn't batching breaking changes together better than spreading them out?
13:32:19 <johnw> dmwit++
13:32:26 <typoclass> edwardk: it seems perfectly reasonable to delay johnw's proposal until the dust has settled
13:32:37 <typoclass> dmwit: for breaking changes yes
13:32:44 <FreeFull> Applicative probably does belong in Prelude if Monad will be there
13:32:46 <carter> dcoutts my confusion is postconfhook doesn't seem to provide a way to change the ConfigFlags value
13:32:56 <typoclass> (how breaking is johnw's proposal?)
13:33:09 <johnw> it's pretty breaky
13:33:24 <dcoutts> carter: you don't need to change ConfigFlags
13:33:25 <edwardk> bringing in Semigroup means that _that_ would have to go into Prelude as well, (<>) changes to the semigroup operator, you wind up having to define a redundant (<>) or mappend = (<>), to avoid breaking existing instances and all existing Monoids break.
13:33:27 <johnw> any instance defining mappend won't compile
13:33:46 <edwardk> FreeFull: i'm fully on board with bringing Applicative in
13:33:53 <carter> dcoutts i thoughts that wha tyou had suggested
13:34:05 <johnw> edwardk: do you think AMP+FT can make it in for 7.8?
13:34:09 <edwardk> johnw: i'd rather punt semigroups to a later point
13:34:12 <dcoutts> carter: you'll do something like defaultUserHooks { hookedPrograms = [ghcProgram { programPostConf = ... }] }
13:34:16 <carter> ok
13:34:19 <edwardk> johnw: the general consensus is it'd be 7.10 for AMP+FT
13:34:26 <johnw> edwardk: fair enough, a deferral is better than killing the idea
13:34:27 <carter> dcoutts thanks
13:34:28 <dcoutts> carter: I said override programPostConf, the ConfigFlags is to do with command line parsing
13:34:31 <typoclass> johnw: didn't quchen did some work on estimating or measuring how breaky his AMP change was? didn't he search through all of hackage or something?
13:34:37 <typoclass> s/did/do
13:34:45 <carter> dcoutts why would i do that instead of the former?
13:34:52 <carter> defaultUserHooks { hookedPrograms = [ghcProgram { programPostConf = ... }] } seems simpler
13:34:59 <johnw> maybe even SM for 8.0
13:35:10 <carter> what am i not undrstanding?
13:35:13 <johnw> it might even open the door for other breaking changes
13:35:17 <dcoutts> carter: I'm not sure what you're asking
13:35:31 <johnw> 8.0 can be the "get the math right" version
13:35:32 <dcoutts> carter: and I'm not sure where you got ConfigFlags from. I didn't mention that.
13:35:46 <carter> dcoutts i'm trying to read the docs to understand what your suggesting
13:35:53 <carter> I want ghc to be passed the -pgma clang -pgmc clang when i'm building on a mc
13:35:59 <carter> when building c code
13:36:13 <johnw> edwardk: if we're going to pull Semigroup into Prelude, I would actually really like a Group class there too, with Monoid as a superclass
13:36:28 <Fuuzetsu> > let ' = 2 in '
13:36:29 <lambdabot>   <hint>:1:7: parse error on input `='
13:36:44 <edwardk> johnw: the problem is i just don't see that being a very popular proposal. Lots of people want Prelude to start getting _smaller_ not larger.
13:36:47 <johnw> and then at least Abelian
13:36:57 <edwardk> Lots of backlash
13:36:57 <dolio> That's a can of worms.
13:37:10 <johnw> but it would be nice if Prelude had the most fundamental math classes in it
13:37:10 <joelteon> > let 'a = 2 in 'a
13:37:11 <lambdabot>   <hint>:1:5: Parse error in pattern: 'a
13:37:13 <typoclass> Fuuzetsu: as i understood it, the first char of a function name (value name) has to be a lower-case letter. after that, upper-case is allowed, numbers, _ and '
13:37:20 <johnw> although, I can see Data.Algebra being a better place for things like Group
13:37:21 <edwardk> it'd be nice, but i don't see how to get there from here.
13:37:32 <johnw> or Data.Group
13:37:43 <johnw> ok, not in Prelude then
13:37:43 <edwardk> i can see us getting Foldable+Traversable+Applicative+Monoid in there. They are classes everyone knows and which have stood the test of time.
13:37:44 <sclv> i don't like this idea at all
13:37:52 <sclv> yes ftam and that's it!
13:38:02 <dcoutts> carter: as I said before, you can only pass options to all invocations of ghc, not selectively, at least not easily.
13:38:11 <carter> dcoutts i'm ok with that
13:38:17 <edwardk> I'd _like_  semigroup but it tends to carry with it a desire to bring along Apply/Bind, etc. and a bunch of crap nobody wants that doesn't work well without some kind of superclass default instance proposal.
13:38:30 <sclv> the "fundamental math classes" involve breaking out num, about which ew
13:38:30 <edwardk> so i can't bring myself to be for it, especially at this time
13:38:31 <carter> on mac i'm totally ok with throwing pgma clang pgmc clang everywhere :)
13:38:32 <dcoutts> carter: ok, so what I suggested should work. No need to use any other UserHooks stuff.
13:38:43 <carter> dcoutts thanks and I appreciate your patience
13:38:50 <carter> i find cabal the library pretty overhwleming
13:38:54 <johnw> edwardk: in CT is there even something like Bind?
13:38:56 <Taneb> johnw, I made a groups library
13:38:58 <dcoutts> carter: oh I see, you were looking at confHook
13:39:04 <elliott> edwardk: btw, johnw did already post a semigroups proposal to libraries@
13:39:05 <Taneb> @hackage groups
13:39:05 <lambdabot> http://hackage.haskell.org/package/groups
13:39:06 <elliott> a few hours ago
13:39:08 <elliott> (it's my fault!)
13:39:12 <edwardk> johnw: the notion of a 'semi-monad' arises when you talk about semigroupoids
13:39:19 <johnw> ah, yes, semigroupoids
13:39:20 <sclv> i could see factoring Num/Floating into "fromIntegral" and "fromRational" bits and then the rest
13:39:30 <sclv> so we have sugar that doesn't bring in possibly failing ops
13:39:37 <sclv> beyond that push things _out_ of the prelude
13:39:40 <Taneb> edwardk, is a semi-monad (>>=) without return?
13:39:42 <sclv> but possibly into the platform
13:39:42 <Fuuzetsu> >An identifier consists of a letter followed by zero or more letters, digits, underscores, and single quotes
13:39:43 <edwardk> sclv: the problem is the migration path for that has a lot of pain
13:39:54 <johnw> Taneb: yes, and Apply is for semi-applicatives
13:39:55 <edwardk> Taneb: yeah
13:40:18 <Taneb> Still need to work out why Hackage hasn't done the docs for Data.Group
13:40:19 <sclv> well if we had Num, with a FromIntegral superclass, e.g., how bad would it be?
13:40:24 <sclv> just break people's Num instances
13:40:51 <dolio> fromInteger actually makes sense in a hypothetical Ring class, if that's what you meant.
13:40:53 <sclv> sort of like splitting out Category from Arrow
13:40:57 <dolio> Because Integers are the initial ring.
13:41:01 <edwardk> sclv: most (actually all) of the other changes that are in flight don't require moving code from one instance to another and can be resolved without CPP by end-users.
13:41:05 <typoclass> Fuuzetsu: right. "a letter followed by ..." with the casing of that letter deciding if it's a type or a value
13:41:15 <sclv> edwardk: sure, i get what you mean
13:41:15 <Gracenotes> it's a nice syntactic thing
13:41:32 <sclv> its more breaky than the other proposals for sure.
13:41:38 <joelteon> imports have to come before declarations, right?
13:41:40 <edwardk> while that isn't a strict requirement on future changes it is a good guideline for when some big change really has to cross a big threshold of utility to be worth the pain
13:41:45 <sclv> its just a better ideal end point for me than dragging a full numeric hierarchy in
13:41:52 <sclv> when we can't even necessarily design the best one
13:42:05 <typoclass> joelteon: yes that's true
13:42:08 <sclv> as is we just get partial Num instances, which isn't horrible
13:42:51 <johnw> edwardk: I'd like NonEmpty in base too
13:43:03 <johnw> not Prelude, just base
13:43:21 <sclv> dolio: sure. Num just has negate/abs/signum
13:43:59 <typoclass> dolio: would the Ring class be pretty much like this one? http://hackage.haskell.org/packages/archive/numeric-prelude/latest/doc/html/Algebra-Ring.html#Ring (i have little clue, i just hayood for Ring)
13:44:02 <sclv> johnw: i like nonempty, but the fact that it relies on super partial nats is maddening
13:44:07 <johnw> and I guess with Stream as a newtype for NonEmpty
13:44:15 <sclv> and i don't think edwardk is going to change that :-)
13:44:36 <sclv> but wait nonempty can terminate and stream can't?
13:44:40 <sclv> so how is that a newtype
13:45:00 <dolio> typoclass: Something like that. But with better names.
13:45:13 <johnw> sclv: don't they have the same definition?
13:45:18 <johnw> just different semantics?
13:45:21 <typoclass> johnw: while we're on it, i wish there was a file "Base" or something that like Prelude gets imported by default and is empty, except re-exporting all the commonly used stuff. Data.Maybe, Data.List, and about 2 dozen of those
13:45:33 <typoclass> dolio: i see, thanks
13:45:33 <sclv> johnw: look it up :-P
13:45:39 <johnw> typoclass: yeah, that's what things like general-prelude and classy-prelude do
13:45:57 <ChongLi> anyone here use emacs?
13:46:03 <johnw> ChongLi: you bet
13:46:09 <ChongLi> I'm trying to get more info about setting up haskell-mode and ghc-mod
13:46:11 <typoclass> johnw: oh i see, hadn't heard of general-prelude
13:46:25 <johnw> sclv: oh, I see
13:46:33 <ChongLi> for example: how do I use autocomplete with haskell completions?
13:46:34 <johnw> sclv: NonEmpty is just element + list, Stream is a recursive type
13:46:39 <sclv> corporal-prelude is good enough for me :-)
13:46:41 <sclv> yep!
13:47:05 <johnw> typoclass: general-prelude is more like what I think you're looking for; classy-prelude takes a bit more radical approach
13:47:06 <Taneb> ChongLi, M-C-i or M-/
13:47:16 <johnw> although, I'm finding classy-prelude to be awfully convenient sometimes
13:47:24 <Taneb> Depending on what you want to autocomplete
13:47:34 <Taneb> Possibly M-t sometimes, I'm not sure
13:47:37 <elliott> classy-prelude :(
13:47:37 <ChongLi> Taneb: I've tried those but they just pop up a huge buffer of completions
13:47:44 <johnw> though in principal I like the concept of general-prelude more (i.e., just most of Prelude + a bunch of other imports)
13:47:48 <Taneb> :/
13:47:50 <carter> dcoutts i'm pretty sure this doesn't work
13:47:57 <carter> sadly
13:48:08 <typoclass> johnw: yeah
13:48:10 <johnw> sclv: ok, then I want both NonEmpty and Stream in base :)
13:48:11 <ChongLi> and they don't complete based on a qualified import
13:48:20 <sclv> why base?
13:48:22 <carter> dcoutts i'm getting the AVX confusion error i'd get before
13:48:24 <sclv> what's wrong with platform?
13:48:37 <sclv> you only need things in base if they tie to other things in base
13:48:40 <ChongLi> for exmaple, if I type D.M-C-i
13:48:43 <johnw> base because platform is kind of terrible once you start cabal installing lots of your own packages, unless they fix that
13:48:47 <carter> dcoutts /var/folders/py/wgp_hj9d2rl3cx48yym_ynj00000gn/T/ghc4816_0/ghc4816_0.s:16:0:
13:48:47 <carter>     no such instruction: `vmovapd %xmm1, %xmm0'
13:48:49 <johnw> if that gets fixed, I'm all for platform
13:48:52 <sclv> everyone should use platform
13:48:54 <ChongLi> it should only show completions from module D
13:49:03 <sclv> if their stuff doesn't work with platform then they have a no good package
13:49:05 <johnw> but Stream and NonEmpty are as much "core" data structures and [] and Map, in my opinion
13:49:14 <sclv> map isn't in base
13:49:15 <johnw> i don't use pltaform
13:49:19 <sclv> its in containers
13:49:19 <dcoutts> carter: you can check for sure if you build with -v, you'll be able to see what flags are being passed
13:49:22 <johnw> oh, right
13:49:25 <johnw> ok, then I retract
13:49:28 <carter> dcoutts https://github.com/haskell/cabal/issues/1348#issuecomment-18724561
13:49:32 <sclv> :-)
13:49:33 <elliott> johnw: I don't know how you mean it's terrible
13:49:35 <johnw> platform used to get in my way too much
13:49:41 <johnw> meaning, cabal hell
13:49:42 <carter> '/usr/bin/ghc' '-c' '-static' '-odir' 'dist/build' '-Idist/build/autogen' '-Idist/build' '-I/usr/local/opt/openblas/include' '-I/usr/local/include/' '-optc-march=native' '-optc-O3' '-optc-O2' '-package-db' 'dist/package.conf.inplace' '-package-id' 'abstract-par-0.3.1-8a475b0020d3c20f8fe26aa97d8b74c0' '-package-id' 'base-4.6.0.1-6c351d70a24d3e96f315cba68f3acf57' '-package-id' 'monad-par-0.3.4.2-24c4683b7379257d8ce5705752a09f8d' '-package-i
13:49:42 <carter> d' 'primitive-0.5.0.1-8e5f40b409f7bb31ae1acfb125279700' '-package-id' 'transformers-0.3.0.0-ff2bb6ac67241ebb987351a3db564af0' '-package-id' 'vector-0.10.0.1-c08d8d1f9706ca71ca433f9f5ecce7e3' 'cbits/testAppleBLAS.c'
13:49:49 <johnw> now I just install ghc, cabal, and then cabal install all the libraries I want to use
13:49:51 <elliott> I've never experienced that because of platform personally
13:49:53 <typoclass> johnw: hm, you mean cabal-installing tends to reinstall the platform's packages with newer ones?
13:49:57 <elliott> though I alternate between using it or not
13:50:01 <elliott> depending on whether it's out of date with GHC
13:50:01 <sclv> any package that breaks platform is a bad packge
13:50:05 <elliott> since I always want the latest GHC
13:50:06 <carter> dcoutts : if you look at the github ticket, it seems to indicate that cabal actually IGNORES these flags
13:50:06 <johnw> although, edsko has a blog post saying how to avoid those issues with platform
13:50:09 <johnw> I should just follow his advice
13:50:14 <elliott> johnw: you should use monochrom's constraint lines
13:50:22 <pantsman> @pl f x y = [x,y]
13:50:22 <johnw> yes, that's just what edsko did
13:50:25 <lambdabot> f = id (fix (const (flip ((.) . (:)) (: []))))
13:50:25 <lambdabot> optimization suspended, use @pl-resume to continue.
13:50:28 <johnw> wrote a script to generate the constraint lines
13:50:30 <dcoutts> carter: no that ticket is about the ghc-options field in the .cabal file
13:50:35 <ChongLi> the other issue I'm having is that haskell-mode doesn't seem to hs-source-dirs from my cabal file
13:50:37 <carter> dcoutts ok
13:51:06 <dcoutts> carter: if you hpaste your Setup.hs and .cabal file I'll have a look. Log of cabal configure -v; cabal build -v might help me too.
13:51:07 <ChongLi> so it doesn't know how to find any of my project's modules
13:51:11 <carter> dcoutts ok
13:51:12 <johnw> elliott: link to monochrom's?
13:51:30 <carter> dcoutts should i try useing simpleUserHooks first?
13:51:38 <epta> Could you please recommend some job scheduler like scala's chronos?
13:51:53 <elliott> @where haskell-platform.xhtml
13:51:53 <lambdabot> I know nothing about haskell-platform.xhtml.
13:51:55 <elliott> ugh
13:52:03 <elliott> johnw: http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
13:52:07 <elliott> @where+ haskell-platform.xhtml http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
13:52:07 <lambdabot> Done.
13:52:09 <sclv> teach the lambdabot, teach it well
13:52:32 <johnw> thanks
13:53:24 <carter> dcoutts please read the github ticket more closely: 23skiddo points at reasons why he thinks its not possible via setup.hs currently
13:53:29 <johnw> elliott: does HP still use Cabal 1.14?
13:53:47 <carter> johnw 1.16
13:54:04 <johnw> ah, then I think I will setup HP as my default config, and use hsenv when I need to get more experimental
13:54:09 <johnw> thanks!
13:54:16 <carter> johnw i'm using cabal head for the sandboxes
13:54:25 <carter> dcoutts i'll be back in a span
13:54:32 <johnw> nice, 2013.2 is in homebrew too
13:55:35 <dcoutts> carter: he's talking about the cc-options, because he's assuming you need to do this just for the .c files
13:55:43 <carter> dcoutts i do :)
13:55:58 <carter> thats alll i want
13:56:04 <carter> i'm ok with the flag being passed the rest of the time
13:56:04 <dcoutts> carter: you just told me it's ok to pass these flags for all ghc invocations
13:56:06 <carter> yes
13:56:09 <carter> because it doesn't matter
13:56:11 <carter> i'm doing -fllvm
13:56:30 <carter> for the haskell code
13:57:16 <carter> though you do suggest an intersting hack
13:57:20 <carter> of having a configure script
13:57:34 <carter> that sets ghc to be an alias for ghc -pgma clang -pgmc clang
13:57:45 <carter> I wonder if that would work
13:58:01 <sclv> @remember elliott it's impure but only depending on the environment! which is to say it is impure.
13:58:01 <lambdabot> I will remember.
13:58:20 <dcoutts> carter: that's more or less what we're doing here
13:58:25 <carter> ok
13:58:37 <carter> well, i'll post a gist in a second
13:59:26 <[swift]> i seem to recall reading somewhere that there was a proposal to update the prelude to e.g. fix the relationship of Functor and Monad that garnered a lot of support
13:59:33 <[swift]> i can't find it though
13:59:48 <carter> dcoutts heres the relevant snips https://gist.github.com/cartazio/5760660
14:00:04 <carter> [swift] because its not done yet
14:00:47 <enigmuriatic1> why am i getting this error? http://hpaste.org/89805
14:01:00 <geekosaur> [swift], it's on libraries@haskell.org
14:02:35 <geekosaur> enigmuriatic1, because in your first guard for txCommand you are producing a list, which establishes its type... then the other guard produces an IO list
14:02:35 <dcoutts> carter: oh ok, I see the problem. Sorry, we'll have to use a slightly more hacky method
14:02:51 <carter> dcoutts what i'm saying makes more sense now?
14:02:55 <dcoutts> carter: instead, we'll have to use the build hook and override the program in the environment there
14:03:05 <enigmuriatic1> geekosaur, should i make the type explicit with :: ?
14:03:11 <geekosaur> no
14:03:18 <carter> dcoutts to make the name of ghc be "ghc -pgma clang -pgmc clang" ?
14:03:27 <geekosaur> well, you could and that fould focus the error more tightly, but it wouldn't fix it
14:03:46 <geekosaur> the point is, you're missing something in that first guard. (hint: look at the end of the second guard)
14:03:49 <dcoutts> carter: I can see why overriding ghc in the hookedPrograms doesn't work
14:04:07 <geekosaur> *would focus
14:04:13 <carter> why doesn't it? I'm still learning cabal libary
14:04:51 <[swift]> geekosaur: thanks! found it
14:04:59 <dcoutts> carter: it's because the ghc config code uses the ghcProgram value directly, not getting it from the program environment
14:05:04 <enigmuriatic1> ah, return, geekosaur
14:05:08 <geekosaur> yes
14:05:20 <dcoutts> carter: ok, so we will do a similar thing, but with the configured program, and do that in the programs env in the build hook.
14:05:21 <geekosaur> lift the list into the monad with `return`
14:05:26 <dcoutts> carter: so same basic approach
14:06:16 <carter> ok,  and which constructors this time?
14:06:19 <rck> I want to partially apply the HDBC run function to remove a lot of code repetition. it looks like: run IOConnection String [SqlValues] and I want to somehow pass the function: run String [SqlValues] and apply the IOConnection later
14:06:26 <dcoutts> carter: use updateProgram to alter the withPrograms :: ProgramConfiguration, part of the LocalBuildInfo in the buildHook
14:06:28 <rck> how do I curry that way?
14:06:41 <dcoutts> carter: ie you override the buildHook, it'll call the original buildHook but with a modified LocalBuildInfo
14:07:44 <geekosaur> rck: that is ... difficult. I think the best you can do is
14:07:45 <dcoutts> carter: and you'll alter the  ConfiguredProgram  value for ghc to add more programDefaultArgs
14:07:47 <geekosaur> oops
14:08:13 <geekosaur> best you can do is something like: \conn -> run conn myString myValues
14:08:14 <carter> dcoutts so i project out the original one
14:08:21 <carter> and pass in the right info to the original one?
14:08:31 <dcoutts> carter: so same basic approach as before, but now on an already configured program, and altering an existing ProgramConfiguration environment
14:08:34 <rck> geekosaur: that's an idea, thanks!
14:08:42 <dcoutts> carter: yep
14:08:48 <geekosaur> haskell can only curry from the left in the specific case of binary infixes
14:09:50 <carter> dcoutts cool, i'll test it after my coffee break :)
14:17:45 <rck> geekosaur: please check out lines 44-60 (and 75) of hpaste.org/89806 if you have some time
14:17:53 <rck> or anyone really, I welcome feedback
14:29:01 <chrisdotcode_> test
14:29:27 <Botje> we read you loud and clear!
14:29:42 <chrisdotcode_> is this function idomatic?:
14:29:42 <chrisdotcode_> splitOnFirst delim list = case (delim `elemIndex` list) of
14:29:42 <chrisdotcode_> Just idx -> (Just (take idx list), list)
14:29:42 <chrisdotcode_> Nothing -> (Nothing, list)
14:29:43 <carter> dcoutts so i'd do a lookup program, then update program
14:29:52 <dcoutts> aye
14:30:27 <carter> dcoutts thanks, i needed this walk through
14:30:28 <chrisdotcode_> it takes a list, looks for a character, then returns a pair of the first and the second halfs of the list, split by the delimiter
14:30:46 <Botje> chrisdotcode_: you probably meant drop idx list in the first case.
14:31:00 <carter> i was worried i'd have to do some crazy thing like shim in running a Shake program or some other build tool before cabal and then say "oh look, theres a the right static lib there, link to it"
14:31:01 <Botje> chrisdotcode_: also, anything longer than three lines should go on hpaste. it's easier to refer back to it.
14:31:05 <carter> which would have been MUCH more complex
14:31:25 <chrisdotcode_> Botje: "this is the first half, this is the second" -> ("this is the first half", "this is the second") is what should happen
14:31:38 <Botje> chrisdotcode_: except your Just case returns the input list.
14:31:50 <Botje> in the second part of the pair.
14:32:11 <chrisdotcode_> Botje: right.
14:32:17 <chrisdotcode_> ...
14:32:22 <chrisdotcode_> Botje: okay, yes. that's what I wanted
14:32:39 <chrisdotcode_> I'm trying to extract a number from a csv, and it's the first element
14:33:05 <Botje> okay.
14:33:06 <chrisdotcode_> so splitOnFirst ',' "100, the string" should return: ("100", "the string)
14:33:13 <chrisdotcode_> so splitOnFirst ',' "100, the string" should return: ("100", "100, the string)
14:33:20 <Botje> (note: there's probably nice csv modules on hackage. going further, I assume this is for learning)
14:33:34 <Botje> chrisdotcode_: uh, what now?
14:33:36 <chrisdotcode_> (yeah, it is. I was talking to dmwit earlier, and he told me the same thing :) )
14:33:47 <Botje> why would you return the same list if you split off something?
14:34:12 <chrisdotcode_> Botje: because I need to filter rows in the csv, depending on that first number. I need all rows that have an id greater than 100
14:35:04 <Botje> so just make an extraction function for the first number and use it in a guard
14:35:20 <chrisdotcode_> Botje: I was going to use fst, but that's an even nicer solution. thanks :)
14:35:20 <DanBurton> ugh, curse Haskellisms, I keep forgetting to put the "end" keyword in my ruby now :P why isn't ruby Haskell?
14:36:05 <int80_h> DanBurton: it is, but only in imaginationland.
14:36:06 <chrisdotcode_> Botje: I was going to go with the writer monad initially, but I was told that it wasn't necessary.
14:36:15 <Botje> correct
14:36:42 <chrisdotcode_> Botje: so a pair is suitable for this, then?
14:36:45 <Botje> writer monad (imo) is best used if you want to return stuff aside from the main "channel", where there is no direct link between the two channels.
14:37:34 <Peaker> Botje, it's great at propagating data "upwards", as opposed to reader which is great at propagating it "downwards".  listen/censor for writer   and   local   for reader are part of their niceness
14:37:40 * hackagebot non-empty 0.1.1 - List-like structures with static checks on the number of elements  http://hackage.haskell.org/package/non-empty-0.1.1 (HenningThielemann)
14:37:50 <Botje> Peaker: that's a good explanation too, thanks
14:37:58 <Botje> s/too//
14:37:59 <chrisdotcode_> Botje: why would I use a guard instead of a pattern match?
14:38:23 <Botje> chrisdotcode_: yeah, nevermind. I was thinking about something else, it doesn't /quite/ work out.
14:38:54 <chrisdotcode_> extractNumber (num, csvrow) = read num and whatever else I need to do. is my pseudo code so far
14:38:56 <frerich> chrisdotcode: Minor thing regarding your function: you don't need the braces in 'case (delim `elemIndex` list) of'
14:39:17 <Botje> chrisdotcode_: fair enough.
14:39:19 <chrisdotcode_> frerich: I kept them because it makes them clearer, but are they still clear without it?
14:39:38 <frerich> chrisdotcode_: If they clarify things, no harm in keeping them. Just saying. :-)
14:39:39 <Botje> chrisdotcode_: a good tip for any program is to convert input into more usable data structures as soon as possible
14:40:04 <Botje> chrisdotcode_: so if you split each line on , first you can just assume a line is a list
14:40:05 <typoclass> rck: hello, i've written an annotation. hope it helps http://hpaste.org/89806 . not tested
14:41:27 <chrisdotcode_> Botje: yeah, my type signature is: Char -> String -> (Maybe String, String)
14:41:35 <Peaker> chrisdotcode_, I think having parens everywhere (what lisp does) adds tonnes of visual noise.  Adding parens to very certain things seems very arbitrary to me (why learn some precedence rules and not others?)  so I use the least arbitrary and noisy style I can think of -- least possible amount of brackets (hlint helps with that)
14:41:47 <Peaker> chrisdotcode_, why are you so Stringly-typed?
14:41:53 <chrisdotcode_> Peaker: that was just for now.
14:41:59 <chrisdotcode_> I'm going to change them back to type variables
14:42:06 <chrisdotcode_> I was trying to wrap my mind around the abstraction
14:42:16 <chrisdotcode_> and so Chars and Strings are concrete for me, in my head
14:42:17 <typoclass> rck: i've pulled the type annotations (BL.ByteString) into the function's type signature since i found it more natural. but you still have to fill in what "??" has to be (i didn't know). but ghc can help you with that; it'll print out the signatures if you compile with -Wall
14:44:32 <typoclass> rck: i hope it makes any sense :-)
14:50:09 <lispy> carter: huh. It worked for Ralith
14:55:32 <carter> lispy yes, if you pass it to ghc directly
14:59:33 <exFalso1> is the 'h' silent in "haskell"?
15:00:34 <frerich> Not unless you're from France. ;-)
15:00:52 <dsaa-temp> Ask Elle
15:01:12 <exFalso1> hmm ok thanks:)
15:01:22 <ion> In French, the “haskell” is silent in “haskell”.
15:01:37 <frerich> :-))
15:02:11 <bitonic`> the real question is: is it ‘an Haskell programmer’ or ‘a Haskell programmer’?
15:02:17 <joelteon> a
15:02:18 <ion> a
15:02:28 <Taneb> Depends how pretentious you're being
15:02:29 <johnw> Programmer a => a
15:02:33 <shachaf> A Naskell programmer.
15:02:42 <Taneb> Do you say "an historic castle"?
15:03:01 <bitonic> OK, OK :P
15:03:13 <johnw> let's reëxamine this concept of pretention
15:03:22 <ion> I am become an Haskell programmer.
15:03:36 <johnw> ion: most excellent
15:03:59 <typoclass> johnw: =)
15:05:42 <elliott> learn you an haskell for great good
15:05:44 <aristid> huh i didn't know the H in Haskell is silent
15:05:48 <typoclass> johnw: i mean, i love the new yorker, but i'm really not sure why they put dots on about 3 words, semi-randomly chosen. i see that you could do this on all kinds of words, but they seem to do it on "cooperation" and maybe two other ones. it seems very selective
15:06:18 <aristid> typoclass: it's not totally random
15:06:24 <aristid> typoclass: but i hate it too!
15:06:31 <aristid> shachaf also does it *grumble*
15:06:59 <typoclass> aristid: you mean in dutch? i hardly know any, but isn't it more systematic about it?
15:07:17 <aristid> no, in english.
15:07:19 <geekosaur> typoclass, it's obsolescent but used to be quite correct
15:07:23 <aristid> it's the same system as in dutch, though.
15:08:20 <koala_man> if I have something parsec that parses "foo `bar`" into something like ["foo ", ["bar"]], how could I start doing this recursively with escaping, like "foo `bar \`baz\``" -> ["foo", ["bar, ["baz"]]] while still retaining source positions and such?
15:09:06 <aristid> typoclass: if i understand it correctly, the logic is that with the non-umlaut-dots there, the second vowel is indicated as to be pronounced separately
15:09:52 <geekosaur> yes
15:10:02 <dsaa-temp> What would be the signature of a function that returns a string when it's called with an Int parameter and returns an int when it's called with a string parameter?
15:10:04 <geekosaur> diaeresis breaks up what would otherwise be a diphthong
15:10:15 <geekosaur> dsaa-temp, nonexistent
15:10:26 <kylcarte> koala_man: seems like you're trying to parse a tree, rather than a list. Your list ["foo", ["bar" ...]] is badly typed. "foo" is a String, and ["bar" ...] is [String]
15:11:42 <koala_man> kylcarte: yes. the question was really more about the parsec aspect than how to represent the AST
15:11:43 <kylcarte> If you're trying for something like an S-expression, you'd need a different datatype
15:13:09 <aristid> data SExpr = Nil | Atom Foo | Cons SExpr SExpr, i think
15:13:33 <typoclass> aristid: right, i understood it that way as well. question is, why only for "cooperat-" and a small number of others. they could use it on all kinds of words; preempt, reassociate, dealign
15:13:50 <aristid> typoclass: don't give shachaf ideas.
15:14:31 <typoclass> dsaa-temp: in haskell, that seems impossible. a function can't really examine the type of an argument that it got
15:14:35 <koala_man> ok, is this more clear?:  if I have something parsec that parses "foo `bar`" into something like Expr [Atom "foo ", Expr [Atom "bar"]], how could I start doing this recursively with escaping, like "foo `bar \`baz\``" -> Expr [Atom "foo", Expr [Atom "bar, Expr [Atom "baz"]]] while still retaining source positions and such?
15:14:42 <geekosaur> typoclass, the use of diaeresis in English has been gradually declining, with not a lot of rhyme or reason about it. why is the only real current usage the word "naïve"? this is not a question that is open to logic
15:14:58 <typoclass> aristid: well i kinda would like to see it done consistently, to see how far you could take it
15:15:24 <typoclass> geekosaur: fair enough
15:15:37 <geekosaur> *technically* it should be used any time the normal reading of a word would interpret a diphthong. but, who defines what a normal reading is?
15:15:48 <typoclass> (too many people have weird superstitions about some part of language needing to be completely logical)
15:16:34 <typoclass> geëkosaur
15:16:51 <geekosaur> a 1917 dictionary I used to use spelled "cooperate" with the diphthong.
15:16:59 <geekosaur> nope, the 'ee' is a diphthong
15:17:06 * shachaf notes that this conversation has been partly transplanted to #-blah already.
15:17:11 <typoclass> geekosaur: yeah i know :-) j/k
15:17:27 <geekosaur> (alternately: "how mëtal of you")
15:17:30 <aristid> now we just need to partly transplant geekosaur
15:17:40 <Taneb> I probably ought to join #-blah one day
15:17:44 * geekosaur going to drop the subject, actually
15:17:53 <aristid> Taneb: it will be a glorious day
15:18:08 <typoclass> Taneb: you're not in there? where are you even getting your daily supply of cat pictures from?
15:18:43 <Taneb> typoclass, I have alternative sources of cat pictures
15:18:49 <typoclass> Taneb: fiar
15:18:52 <typoclass> *fair
15:24:25 <ion> @tell lemmih Hi. acid-state seems great. Two things i would like to see: built-in error handling in terms of e.g. Either instead of just propagating exceptions, and a function to switch to a new event log file (before e.g. creating a checkpoint and archiving). Perhaps i'll manage to contribute a patch one day.
15:24:26 <lambdabot> Consider it noted.
15:29:42 <Sonarpulse> johnw: do you think you could try compiling https://github.com/Ericson2314/henet ?
15:30:05 <Sonarpulse> it fails at the pre-processing stage
15:46:57 <johnw> one sec, in a meeting
15:47:44 * hackagebot GLUtil 0.6.1.2 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.6.1.2 (AnthonyCowley)
15:48:24 <Sonarpulse> sure, np
15:48:29 <Sonarpulse> I've been in and out too
16:05:13 <hidenori> is there a function that takes a list and returns a pair which is like (smallest element of list, rest)?
16:06:37 <typoclass> hidenori: you mean like 'minimum', but also giving all the other elements?
16:06:38 <typoclass> > minimum [2,1,3]
16:06:40 <lambdabot>   1
16:06:52 <ion> \xs -> let x = minimum xs in (x, delete x xs)
16:07:05 <Peaker> hidenori, what do you need it for?
16:07:15 <typoclass> ion: had the same thought! probably traverses twice
16:07:20 <ion> typoclass: yeah
16:07:50 <hidenori> typoclass: yes
16:08:16 <elliott> that sounds hard to do without traversing twice
16:08:25 <elliott> you might discover the minimum on the last element
16:08:30 <hidenori> Peaker: I am writing a code for Graham scan.
16:09:01 <typoclass> elliott: yes, if you want to delete all the occurrences of the minimal element. if you only want to delete that one element, i think it's doable in O(n)
16:09:07 <josephle> hidenoti: yay, GC!
16:09:10 <Peaker> hidenori, maybe you want a Data.Set rather than a list, so you can more efficiently do this operation
16:09:12 <ion> Are you sure a list is the best data structure for that?
16:09:18 <typoclass> er not O(n), i mean "traversing once"
16:09:44 <elliott> typoclass: I don't quite believe it, but accept constructive proof to the contrary
16:09:48 <josephle> oops gc is cheney scans
16:09:51 <hidenori> Does Data.Set work for that?
16:10:02 <Peaker> hidenori, or maybe you could just sort it and then pattern match head/tail?
16:10:04 <frerich> hidenori: Couldn't you just sort the list and then take the first/rest of the list?
16:10:13 <elliott> I assume order-preservation is desired
16:10:14 <Peaker> hidenori, yes, Data.Set has an operation to get min and rest
16:10:28 * frerich ^5s Peaker
16:10:48 <hidenori> i think if i sort, its O(n*logn) but even if i traverse list twice its still O(n) so i would do that
16:12:17 <hidenori> Peaker: Which function is it?
16:13:10 <Peaker> frerich, ?
16:13:16 <Peaker> oh, high-fives :)
16:13:26 <frerich> :-)
16:13:43 <Peaker> hidenori, how many times do you have to extract the smallest element? Just once?
16:15:00 <hidenori> Peaker: Yea just once. my plan is to extract one element, and I will do  other operations on the rest of list based on the element i extracted
16:15:36 <Peaker> hidenori, ah, then maybe you should use the above method. Converting a list to a Set is also O(N*logN)
16:15:53 <Peaker> (unless you have a Set in the first place)
16:16:13 <hidenori> Peaker: I see. ah you mean traversing twice?
16:16:48 <Peaker> hidenori, Yeah, just finding the minimum once, and then deleting it once
16:17:11 <hidenori> Peaker: Okay thanks I'll do that =)
16:18:17 <supki> I think heap should work. It's O(n) fromList and O(log n) minView
16:18:48 <Peaker> supki, much more complicated than just minimum and delete, and O(N) anyway
16:19:03 <Peaker> probably worse constant, too
16:19:16 <johnw> Sonarpulse: I get a bazillion compile errors
16:22:46 * hackagebot graph-rewriting-ww 0.3.2 - Interactive reduction of lambda-calculus with explicit sharing  http://hackage.haskell.org/package/graph-rewriting-ww-0.3.2 (JanRochel)
16:23:34 <Sonarpulse> johnw: yeah
16:23:37 <Sonarpulse> gcc errors
16:23:44 <Sonarpulse> unfortunately i have to go now
16:23:56 <Sonarpulse> but if you have any idea what might cause them
16:23:59 <Sonarpulse> just post it here
16:24:02 <Sonarpulse> and I'll read it
16:24:05 <Sonarpulse> thanks again
16:37:20 <typoclass> the documentation for the Reducer typeclass states "A c-Reducer may also supply operations which tack-on another c to an existing Monoid m on the left or right." (see http://hackage.haskell.org/packages/archive/reducers/3.0.1/doc/html/Data-Semigroup-Reducer.html )
16:37:38 <typoclass> i'm probably misunderstanding, but how does Reducer relate to Monoid? via the Semigroup constraint, somehow ...? (class Semigroup m => Reducer c m where)
16:38:08 <elliott> i think it means Semigroup m
16:39:08 <typoclass> elliott: oh you mean Reducer is unrelated to Monoid?
16:42:39 <elliott> typoclass: well, m can easily be a Monoid too
16:42:41 <typoclass> hm ... several functions near the bottom of the page seem to be (Monoid m) => ... -> m
16:42:44 <johnw> the old monoids package defined Reducer, but then it was changed to just rely on semigroups
16:43:03 <typoclass> johnw: hm, i see
16:43:21 <edwardk> correct
16:43:52 <typoclass> elliott: sure. i meant, you think that it's a documentation typo and should just say Semigroup where it says Monoid?
16:45:04 <elliott> yes
16:45:08 <elliott> but you can ask edwardk :P
16:45:33 <edwardk> it should probably say semigroup nowadays
16:45:35 <elliott> is there a nice way to get the list of packages that depend on a given installed package?
16:45:41 <NerrZ> hey, can someone help me get wx-config working on windows 7
16:45:41 <edwardk> packdeps
16:45:48 <edwardk> http://packdeps.haskellers.com/reverse/tagged
16:45:54 <elliott> no i mean
16:45:58 <elliott> the installed packages that depend on it
16:46:06 <elliott> i.e. "what is going to mess up if I upgrade this" :)
16:46:16 <typoclass> edwardk: erm, ok. 'probably' ...
16:46:20 <typoclass> =)
16:46:25 <edwardk> cabal install foo -- it'll complain about breaking packages
16:46:30 <Clint> --dry-run
16:46:30 <edwardk> then just don't force ;)
16:47:45 <elliott> thank you
16:48:05 <elliott> nice, lambdabot depends on a web server
16:48:06 <elliott> because of hoogle
16:48:39 <typoclass> elliott: this is the 21st century. everything has a webserver in it
16:51:54 <blaenk> hey so I'm reading that m >>= f is always the same thing as join (fmap f m), but the implementation it showed earlier for join was in terms of >>=: do m <- mm; m
16:52:13 <blaenk> so if >>= were implemented in terms of join, would that definition of join still hold?
16:52:36 <blaenk> or would the definition of join be the one that changes
16:52:47 * hackagebot snaplet-redis 0.1.1 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.1 (DmitryDzhus)
16:53:27 <Cale> blaenk: Technically, the Monad class wants you to define >>= first, but you can go about it however you like.
16:53:33 <geekosaur> join is defined in terms of >>= because Haskell defines Monad in terms of >>= instead of join. if Monad were defined in terms of fmap and join then >>= would be defined using those instead of join being defined in terms of >>=
16:54:21 <blaenk> right, LYAH is basically saying that sometimes it can be simpler to define >>= as join (fmap f m), so if one were to do that, then you'd define join differently right
16:54:28 <blaenk> join would be where you would implement handling the context
16:54:34 <Cale> Yeah, you'd probably even give it another name
16:54:39 <blaenk> like with the Writer monad, mappending the log etc
16:54:59 <Cale> yes, if you like
16:55:03 <blaenk> ah okay
16:55:05 <Cale> Or with the list monad, join = concat
16:55:55 <typoclass> blaenk: if you're implementing a Monad instance, you have to either define a (>>=) or join. (or both). so you can't have an instance where you implement none of them
16:56:34 <blaenk> right
16:57:08 <Cale> It's somewhat unfortunate that the Monad class wasn't set up so that you really could simply define join (and fmap) along with return
16:57:27 <Cale> It could have been defined like:
16:57:30 <NerrZ> has anyone here installed wx-haskell on windows?
16:57:34 <Cale> class Functor m => Monad m where
16:57:44 <Cale>   return :: a -> m a
16:57:57 <Cale>   join :: m (m a) -> m a
16:58:07 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
16:58:17 <Cale>   join x = x >>= id
16:58:34 <Cale>   x >>= f = join (fmap f x)
16:58:45 <Cale> and that would give you the choice of which one to implement
16:58:55 <Cale> (in order to avoid the definitions being circular)
16:59:00 <blaenk> ohh, you mean if it had default definitions of both
16:59:03 <Cale> yeah
16:59:05 <blaenk> then you could define one, knowing the other would be handled
16:59:09 <Cale> right
16:59:09 <blaenk> that's kind of like Eq typeclass right?
16:59:10 <blaenk> I think?
16:59:13 <Cale> Yeah, it is
16:59:17 <blaenk> that'd be cool yeah
16:59:52 <Cale> But as it stands, you're just required to implement >>=  (and Monad isn't a subclass of Functor, though there's no good reason for that)
17:00:07 <blaenk> what do you guys tend to do, or what seems to be the convention, defining >>= or join?
17:00:20 <Cale> Depends on the monad, whichever's easier
17:00:29 <typoclass> blaenk: (right. my last message was assuming the hypothetical Monad class that Cale quoted. i forgot that the way things are, join is outside the class.)
17:00:34 <blaenk> oh it's not? LYAH often reiterates how unfortunate it is that Monad isnt a sublcass of Applicative because Applicative came around long after Monad was implemented or something
17:00:38 <typoclass> Cale: thanks
17:00:51 <blaenk> Cale: oh okay cool
17:01:02 <blaenk> typoclass: oh okay
17:02:31 <Cale> blaenk: Yeah, Monad's not presently a subclass of anything. The original thinking was that it would save people the trouble of writing Functor instances when they didn't need them. However, if it were a subclass of Functor, one could always just write  instance Functor MyMonad where fmap = liftM
17:02:42 <Cale> and alongside the Monad instance, that would be fine
17:03:04 <blaenk> oh okay, yeah
17:03:06 <geekosaur> hopefully some day Functor will be a prerequisite for Monad, and then Monad can be redone to be either >>= or join, and then the list monad can take its most natural form (which is: join = concat. fmap = map)
17:03:09 <elliott> well, it's going to be a subclass of Applicative.
17:03:15 <Cale> So it doesn't really save much trouble, and causes users of libraries which forget to provide an instance a little bit of a headache sometimes.
17:03:21 <elliott> that's what has been voted on the past few weeks and it's passed unanimously.
17:03:30 <elliott> just needs someone to do all the work.
17:03:33 <Cale> Oh, cool.
17:03:41 <elliott> which could take months, of course
17:03:43 <blaenk> so that would also make it instance of Functor right?
17:03:45 <NerrZ> sorry to interupt, but is wx-haskell good for 2d graphics?
17:03:54 <elliott> NerrZ: i've heard it used for the purpose
17:04:05 <elliott> consider also gloss, and uh that other one, something-drawingcombinators
17:04:23 <NerrZ> is there a better package though, because I am haveing trouble installing it in windows
17:05:09 <elliott> then I suggest gloss again
17:05:13 <elliott> no idea if it works on windows but seems likely
17:05:35 <NerrZ> thanks
17:05:42 <NerrZ> that on hackage?
17:05:59 <Cale> elliott: Why months? How many packages need to be updated before the change can go through?
17:06:02 <typoclass> NerrZ: hello :) the chances for getting an answer are best if you include the output that appeared when the package failed to install. run cabal with "-v3" to make it verbose, and copy-paste the complete output to hpaste.org
17:06:14 <Cale> blaenk: yeah, it would
17:06:26 <blaenk> nice
17:06:29 <Cale> blaenk: The Applicative class is already a subclass of Functor
17:06:39 <elliott> Cale: the months include the time it takes for someone to step up to do the task
17:06:41 <blaenk> yeah
17:06:44 <NerrZ> awesome, thank you, I am new here ^^
17:06:57 <elliott> Cale: also, it'll need a GHC release to be useful, of course
17:07:02 <elliott> and there are talks about waiting until the one after 7.8
17:07:06 <Cale> Well, right
17:07:14 <Cale> ah
17:07:31 <typoclass> elliott: i thought quchen was on it? or was he only involved in writing the proposal and surveying how hard it would be?
17:07:41 <elliott> maybe he is
17:07:47 <elliott> dunno
17:07:59 <elliott> I have a feeling people think the grunt work to make it happen is less tedious than it is :)
17:08:10 <geekosaur> IIRC someone was working on seeing how much of hackage would need to be modified?
17:08:26 <elliott> geekosaur: I think he gave up on that or something
17:09:11 <Cale> I'd expect the changes to any one library to be pretty minimal
17:09:16 <typoclass> geekosaur: i asked quchen if he's checking all of hackage, and he said no, he's checking ghc and the built-in packages
17:09:19 <Cale> It would just be like the Num change recently.
17:09:26 <elliott> Cale: yes, but GHC and the boot packages are pretty big.
17:10:47 <NerrZ> http://hpaste.org/89812 this is the verbose error when I tried cabal install wxc
17:10:50 <typoclass> he said currently there's about 100 monads in ghc that aren't applicatives
17:12:25 <DanBurton> wat
17:12:27 <geekosaur> I know it was raised, and I thoguht that it was going to be (a) check ghc/bootlibs first (b) originally proposed way to check hackage was dropped (c) because an alternative way was suggested
17:12:30 <geekosaur> (meanwhile my network just fell over and had to be restarted, sigh)
17:13:49 <typoclass> geekosaur: yes, i remembered some discussion about checking all of hackage, but i asked him today, and concluded i had misremembered that
17:14:36 <typoclass> NerrZ: oh, that seems to have gotten cut off. maybe your terminal supports only 300 lines? could you hpaste it again, this time without -v3? let's hope the relevant messages still show up
17:15:07 <NerrZ> thanks
17:16:16 <Aetherspawn> if 2 haskell dll's are loaded into a process and hs_init is called for one of them
17:16:26 <Aetherspawn> does the other dll need to call it, or does the garbage collector work for both?
17:16:30 <NerrZ> http://hpaste.org/89813 there is without -v3
17:18:17 <typoclass> NerrZ: oh, i bet you have to install prerequisites before you can install wxhaskell itself
17:18:43 <typoclass> NerrZ: this guide mentions wxWidgets as a prerequisite http://www.haskell.org/haskellwiki/WxHaskell/Windows
17:18:46 <NerrZ> which prereqs? I think I installed the wxWidgets
17:19:14 <typoclass> NerrZ: also see this http://www.haskell.org/haskellwiki/Wxhaskell it seems fairly well-maintained
17:20:07 <dmwit> NerrZ: Your path probably doesn't have wxwidget's stuff in it.
17:20:11 <dmwit> at a guess
17:20:21 <dmwit> It says it can't find wx-config.
17:20:33 <dmwit> The wiki page typoclass linked seems to have some tips about what to put in the path.
17:21:35 <NerrZ> oh my, I think I may not have installed wx properly, I am going to reinstall and retry
17:22:49 * hackagebot snaplet-redis 0.1.1.1 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.1.1 (DmitryDzhus)
17:29:44 <Frostix> Hello, can anyone tell me a good compiler for Haskell? I'm trying Leksah but it's not working properly
17:29:54 <hpc> leksah isn't a compiler
17:30:03 <Frostix> Err IDE
17:30:19 <Frostix> Just need something similar to it
17:30:31 <hpc> i didn't have much luck with leksah either, but that was a while ago
17:30:57 <dmwit> vim and emacs are popular.
17:31:01 <Frostix> Can you recommend anything?
17:31:36 <Cale> Frostix: Open whatever text editor you prefer in one window, and ghci in another
17:31:51 <Cale> Whenever you save your source, type :r in ghci to reload it
17:32:06 <Frostix> Hmm alright
17:32:51 <Cale> Any text editor which can convert tabs to spaces should do, though there are some nice Haskell modes for various text editors.
17:35:55 <dmwit> Dude.
17:36:02 <FreeFull> edud
17:36:11 <sm> EclipseFP is less widely used but supposed to be good
17:40:44 <Tene> I've been a little unhappy with how slow ghc-mod is for interactive editor use; I should really try hdevtools someday, but I'd have to switch from cabal-dev to hsenv.
17:52:13 <lispy> hdevtools?
17:52:34 <shachaf> hdevtools.
17:52:44 <hpc> hdevtools?
17:52:45 <lispy> I check /r/haskell everyday and check haskell-cafe sometimes. Yet I miss things like this.
17:52:54 <shachaf> hdevtools is pretty nice.
17:55:03 <Tene> "hdevtools is a backend for text editor plugins, to allow for things such as syntax and type checking of Haskell code, and retrieving type information, all directly from within your text editor.
17:55:07 <Tene> The advantage that hdevtools has over competitors, is that it runs silently in a persistent background process, and therefore is able to keeps all of your Haskell modules and dependent libraries loaded in memory. This way, when you change only a single source file, only it needs to be reloaded and rechecked, instead of having to reload everything." -- https://github.com/bitc/hdevtools
17:56:00 <lispy> sounds nice
17:56:55 <Tene> Yeah, except it doesn't work with cabal-dev
17:59:53 <Tene> https://github.com/bitc/hdevtools/issues/6 -- the only response so far is that the author uses hsenv instead of cabal-dev.
18:02:28 <kvda> for sublime users -> https://github.com/SublimeHaskell/SublimeHaskell
18:02:41 <kvda> uses hdevtools apparently, i'm trying it out now
18:04:13 <dmwit> Tene: "patches welcome" is a pretty common response to such requests.
18:04:26 <Tene> Yep!  I wasn't complaining; just mentioning.
18:04:49 <Tene> I think it's entirely reasonable.
18:18:58 <sohum> what's flip (>>=) called?
18:19:06 <shachaf> (=<<)
18:19:17 <sohum> I mean the text name
18:19:19 <sohum> like "bind"
18:19:33 <shachaf> (=<<) is the only standard name in base.
18:19:46 <sohum> in the literature?
18:20:03 <dolio> Superscript star.
18:20:41 <elliott> "bind"
18:21:33 <sohum> oh, right, that is bind
18:21:33 <zRecursive> Are there any softwares used to listen BBC ?
18:21:39 <sohum> >>= is flip bind
18:21:40 <sohum> heh
18:27:26 <JoeyA> :i >>
18:27:56 <JoeyA> :t >>
18:27:57 <lambdabot> parse error on input `>>'
18:28:02 <JoeyA> :t (>>)
18:28:02 <lambdabot> Monad m => m a -> m b -> m b
18:28:04 <JoeyA> :t (<<)
18:28:05 <lambdabot>     Not in scope: `<<'
18:28:05 <lambdabot>     Perhaps you meant one of these:
18:28:05 <lambdabot>       `=<<' (imported from Control.Monad.Writer),
18:28:20 <shachaf> There is no (<<)
18:28:25 <JoeyA> Not that I need it, but why isn't << defined in base?
18:29:11 <elliott> half of everybody would expect it to be flip (>>) and the other half would expect it to be (<*)
18:29:44 <tornetwork> Why do you guys not like Leksah?
18:29:45 <JoeyA> Ah
18:29:46 <shachaf> I,I (<<) :: CommutativeMonad m => m a -> m b -> m a
18:30:03 <JoeyA> So the order of effects is ambiguous.
18:30:45 <shachaf> Also, half would expect it to be like (=<<) and half would expect it to be like (<*)
18:30:48 <elliott> tornetwork: nobody said that
18:30:52 <shachaf> That issue doesn't exist for Applicative so much.
18:31:11 <tornetwork> elliott: never said they did. however most of the people on here I've talked to seem to strongly dislike it
18:31:30 <elliott> I don't share that experience. many prefer vim/emacs or whatever
18:31:31 <geekosaur> most of the people you'll talk to on here aren't much for IDEs in general
18:31:57 <tornetwork> then what do you use?
18:32:12 <geekosaur> part of this is because there aren't yet any IDEs that provide as good support for Haskell as IDEs for other languages do
18:32:20 <JoeyA> I find gvim + git + command line more direct and productive, though I haven't tried Leksah seriously.
18:32:43 --- mode: ChanServ set +o shachaf
18:32:48 <JoeyA> Oh, + Haddock
18:32:53 * hackagebot email-validator 0.0.1 - Perform basic syntax and deliverability checks on email addresses.  http://hackage.haskell.org/package/email-validator-0.0.1 (MichaelOrlitzky)
18:33:10 <JoeyA> I use Hoogle and such a lot.
18:33:29 <CODEtaku> I use Sublime Text 2... I'm am a total fanboy for it
18:33:54 --- mode: shachaf set +b *!*458e563a@*.69.142.86.58
18:33:54 --- kick: tornetwork was kicked by shachaf (ban evasion)
18:33:55 <JoeyA> Admittedly, putting together a bunch of big components is time consuming, having to jump from module to module.
18:34:51 <CODEtaku> I haven't even looked into the stuff that lets you run Haskell inside Sublime, but its general text editing and code navigation features are much to my liking
18:35:23 <JoeyA> I'd be nice to be able to open the documentation for a module in a quick command
18:35:26 <NerrZ> the sublime build has no command line so you cant pass command line IO
18:35:33 <JoeyA> hdoc Control.Monad
18:35:38 --- mode: shachaf set -b *!*458e563a@*.69.142.86.58
18:35:41 --- mode: shachaf set -b *!*@69.142.86.58
18:35:51 --- mode: shachaf set +b *!*@*69.142.86.58
18:35:54 --- mode: shachaf set -o shachaf
18:36:07 <CODEtaku> no?  That would be a little annoying.  I just keep a terminal window open and use ghc there
18:36:48 <JoeyA> Or better, print (or open) the documentation for a definition that a given identifier in the current module points to.
18:37:24 <JoeyA> By "open", I'm thinking open Haddock in a browser window.
18:37:36 <JoeyA> Of course, there's the problem of browser windows piling up.
18:37:51 <CODEtaku> the extensions for other languages enable that kind of thing JoeyA, but I don't know about the Haskell stuff
18:38:50 <CODEtaku> it doesn't look to me like the Haskell extensions are all that actively developed, there are multiple ones available like for other languages... I went looking for something like integrated lint and didn't see anything off hand
18:41:16 <tabemann> at least with Emacs, I'm not used to major modes, as they're called, typically having that
18:41:25 <tabemann> not every editor is Eclipse
18:41:41 <johnw> JoeyA: ghc-mod can do that in Emacs
18:42:33 * tabemann personally finds a lot of the extra stuff in Eclipse kind of annoying
18:43:24 <CODEtaku> yeah, I've always found Eclipse to be very clunky and fragile, but that's pretty much perfect for Java and fits right in ;)
18:44:01 <tabemann> I'm using it at work right now, and the way it scribbles red stuff all over the screen when your build environment is not fully set up is annoying
18:44:32 <JoeyA> I'd probably try Eclipse more seriously if I had one of those computers so many people seem to have that gets faster over time.
18:45:12 * tabemann is working on a project split into multiple separate source trees, and as the code in each tree cannot as of yet see the code in the other trees, Eclipse flags errors whenever code in one tree references code in another
18:46:03 <JoeyA> Figures
18:55:46 <NerrZ> Thank you so much for suggesting gloss over wx
18:56:03 <NerrZ> I now can get windows opening and displaying data ^^
18:58:54 <elliott> :)
19:05:55 <CaptainK> Looks like this program is fantastic for Haskell code entry: http://www.sublimetext.com/
19:06:10 <CaptainK> Anyone else using it?
19:06:45 <CODEtaku> yes, that is Sublime Text 2, the editor I mentioned I use
19:07:21 <CODEtaku> I love it dearly, and converted from vim entirely
19:08:27 <joelteon> you might have been vimming wrong
19:08:55 <CODEtaku> I don't think so... Sublime even has a full vim mode that gives you everything vim has if you want to ease the transition
19:09:11 <joelteon> huh
19:09:14 <joelteon> can it load vimscript?
19:09:32 <CODEtaku> I'm not sure, let me look, it wouldn't surprise me
19:12:01 <CODEtaku> it doesn't look like it can use vimscript directly
19:12:43 <CODEtaku> I haven't run into any sort of vim plugins that don't have a superior Sublime version though.  I certainly wasn't a vim wizard, though
19:15:09 <blaenk> "class (Monoid w, Monad m) => MonadWriter w m | m -> w where"
19:15:15 <frankbro> Can arrows be used to extract a field from a data?
19:15:18 <blaenk> what is that part "| m -> w" called again, so I can look it up?
19:15:22 <blaenk> to find out what it means
19:15:22 <shachaf> functional dependency
19:15:26 <blaenk> ok thanks
19:16:00 <shachaf> By the way, Hoogle can answer that!
19:16:07 <blaenk> oh can it
19:16:19 <shachaf> Type "|" into Hoogle, click the Keyword link.
19:16:27 <shachaf> "thanks Hoogle!"
19:17:16 <blaenk> awesome thanks
19:22:34 <CaptainK> CODEtaku: I love how Sublime has the entire code list in a graphic on the right...so perfect
19:23:07 <CaptainK> When I get the money..I will for sure be buying this product
19:31:15 <joelteon> vim can do that!
19:34:11 <frankbro> Is there anything vim cant do? be a proper haskell text editor apparently :I
19:35:01 <chirpsalot> frankbro: if it's any consolation I am a little disappointed with the haskell mode for emacs too :P. Maybe I just don't know how to use it, though.
19:35:42 <frankbro> A friend keeps saying emacs has an awesome haskell and erlang mode and hes a vim guy. I would try it but >emacs
19:35:56 <joelteon> neco-ghc is pretty great
19:36:10 <elliott> I use vim for Haskell. it is fine
19:36:12 <shachaf> Use whichever editor you like, but please keep editor wars out of here.
19:36:17 <Cale> imo no text editor really works properly for Haskell code
19:36:40 <elliott> Cale: yeah, most of them can even insert tabs.
19:36:41 <frankbro> I use it too but some things are counter-intuitive
19:36:47 <Cale> But it's not terribly important, you can get by with just about anything that'll automatically convert tabs to spaces.
19:36:49 <shachaf> My main requirement for an editor is that it work without a → key
19:36:51 <shachaf> And an End key.
19:36:55 <shachaf> Because I don't have those.
19:36:57 <shachaf> But this is offtopic.
19:37:00 <Cale> lol
19:37:13 <Cale> shachaf: Why are you missing those keys?
19:38:36 <shachaf> That's what happens when you spill things on your keyboard.
19:49:43 <DiegoNolan> what is the difference between haskelldb-hdbc and just HDBC on hackage?
19:50:43 <shachaf> What's haskelldb-hdbc is a thing to make haskelldb and HDBC work together, I'd assume.
19:51:16 <DiegoNolan> idk
19:51:29 <DiegoNolan> oh
19:51:31 <DiegoNolan> yes apparently
19:51:38 <enthropy> haskelldb is a way to have more strongly typed queries and such... hdbc does lots of bindings to actual databases
19:57:33 <DiegoNolan> ic
19:57:36 <DiegoNolan> ty
20:55:09 <frankbro> Can I make zip take a special field of data? (Ex. zip data.field [a])
20:55:48 <shachaf> What?
20:58:46 <frankbro> shachaf, http://hastebin.com/lunebenave.coffee, if data was accessible like a tuple
21:00:13 <shachaf> If you define a function :: Test -> Int, you can use it.
21:00:17 <dmwit> frankbro: field1 (Test a b) = a; c = zip (map field1 a) b.
21:00:21 <shachaf> You can have GHC autodefine a function like that for you by using record syntax.
21:00:54 <dmwit> perhaps even c = zipWith Test (map field1 a) b
21:01:14 <dmwit> or better yet
21:01:15 <shachaf> perhaps even c = c `mod` 2 == 0
21:01:43 <dmwit> c = zipWith (\x y -> x { field1 = y }) a b
21:01:48 <dmwit> (once you've upgraded to records)
21:01:49 <frankbro> aw, I didnt think about that. Thanks a lot
21:02:06 <dmwit> Then you have a smooth upgrade path to lens. ;-)
21:02:12 <shachaf> dmwit: That's not equivalent to what's being done with the tuples there.
21:02:28 <dmwit> no?
21:02:37 <shachaf> Is it?
21:02:39 <shachaf> Oh, maybe it is.
21:07:14 <NerrZ> Hey, is there a way to read raw keyboard input easily
21:07:24 <NerrZ> like  keyboard listener in java
21:08:07 <dmwit> getChar?
21:08:32 <NerrZ> that requires me to tell the program im done and then it echos it to the console
21:08:46 <NerrZ> in the context of a game, that is not so good
21:08:49 <dmwit> hSetBuffering stdin NoBuffering for the first
21:09:06 <dmwit> I don't recall the name of the function for the second, but it's like hSetEcho or something like that.
21:09:18 <NerrZ> thank you very much
21:09:59 <NerrZ> will that make it so no output can be printed to stdout though?
21:10:58 <dmwit> No it will not.
21:18:40 <NerrZ> it still waits for me to hit enter
21:20:04 <geekosaur> I am not sure why people think the hSetBuffering call will also make termios calls
21:20:45 <geekosaur> (possibly because it does work under ghci, but thats because ghci is already in raw mode and pretending to be in line mode)
21:21:21 <NerrZ> should I try compiling then
21:21:22 <NerrZ> ?
21:22:26 <dmwit> Huh. Does hSetBuffering not put it in raw mode?
21:22:36 <geekosaur> last I checked, it just did buffering
21:23:35 <NerrZ> do you know of a way to accomplish what I am looking for then?
21:23:55 <NerrZ> I am newer to haskell, so forgive me if it is simple
21:24:46 <elliott> Cale: oh, btw, you still have a cron job or something that's restarting lambdabot
21:24:47 <dmwit> when (is_tty && isReadableHandleType haType) $ case mode of NoBuffering -> IODevice.setRaw haDevice True
21:24:58 <Cale> elliott: errrr
21:24:58 <dmwit> geekosaur: seems it does, except on mingw32_HOST_OS
21:25:02 <Cale> elliott: I'll look
21:25:15 <geekosaur> huh
21:25:32 <Cale> elliott: ah, yeah, lambdabot was still running
21:25:36 <Cale> oddly enough
21:26:10 <elliott> Cale: I told it to @quit and it came back
21:26:22 <dmwit> NerrZ: Perhaps you could paste some code for us to try.
21:26:23 <elliott> Cale: in fact, I spent a while debugging its L.hs thinking it was my lambdabot and getting very confused
21:26:30 <dmwit> NerrZ: Also, please say your OS.
21:26:38 <NerrZ> windows 7 64 bit
21:26:45 <NerrZ> and I dont really have any code atm to work with
21:27:09 <dmwit> What is the "it" in "it still waits for me to hit enter", then?
21:27:18 <NerrZ> ghci
21:27:24 <elliott> Cale: did you run it in a shell script loop or something? that would explain it
21:27:30 <dmwit> I'm confused.
21:27:45 <Cale> elliott: Yeah, that's right.
21:27:50 <dmwit> Can you say exactly what you do, what you expect to happen, and what happens instead?
21:28:03 <elliott> Cale: ok, cool
21:28:21 <Cale> Though, the shell script loop was less useful than one might hope
21:28:30 <elliott> Cale: I even said at the time that it seemed like it was running a subtly different L.hs to the one it had :)
21:28:33 <elliott> and of course, it was
21:28:46 <Cale> > cake
21:28:46 <lambdabot>   Not in scope: `cake'
21:28:47 <lambdabot>  Perhaps you meant one of these:
21:28:47 <lambdabot>    `take' (imported f...
21:28:52 <Cale> ^^ one way to check ;)
21:29:09 <elliott> hehe
21:29:16 <elliott> maybe I should re-add cake :)
21:29:23 <NerrZ> I load my module in ghci, I load the function and type a character, I expect it to add it to a list instantly, but instead I need to press enter for it to read the input
21:29:49 <dmwit> Right. Your module is code, isn't it?
21:29:54 <NerrZ> yes
21:30:04 <dmwit> So. Perhaps you could paste some code for us to try.
21:30:36 <NerrZ> http://hpaste.org/89814
21:30:44 <Cale> elliott: I also had some handy data types and stuff in there.
21:31:05 <NerrZ> well, that just prints it, but same idea
21:31:06 <elliott> Cale: yeah, Mu/InR are still there because they're in upstream lambdabot's trusted module (for some reason)
21:31:48 <elliott> oh, I didn't re-add Nature because I didn't know what it was for and I'd never seen anyone use it (I'd like it if it could import all its data types from existing packages on Hackage so it gets fuller functionality etc.)
21:32:08 <Cale> elliott: Ah, that was just one that I added briefly while discussing something
21:32:18 <dmwit> NerrZ: Could not reproduce. It responds instantly when I whack a key here.
21:32:20 <Cale> (and then didn't remove it)
21:32:22 <elliott> Cale: hehe
21:32:39 <NerrZ> really? what os?
21:32:40 <elliott> Cale: hopefully I will look into overhauling the evaluation machinery soon so you could do @let data Nature a = ... :)
21:32:46 <dmwit> Linux x64
21:33:11 <dmwit> (Sorry, I don't have a Windows VM with GHC loaded on this machine.)
21:33:37 <dmwit> So I'm not sure what's wrong, unfortunately.
21:33:38 <Cale> That would be cool
21:33:49 <NerrZ> it's okay, I really should just stop using windows
21:38:47 <NerrZ> so that exact code worked like I wanted it to when you compiled it
21:38:57 <dmwit> strange
21:38:59 <dmwit> ...but good
21:39:17 <NerrZ> what's strange?
21:39:42 <dmwit> Strange that ghci and ghc-compiled programs behave differently in that way.
21:44:18 <NerrZ> hmm
21:44:58 <NerrZ> when I compiled it and ran it it still behaved the same
21:45:06 <NerrZ> maybe it is a problem with windows
21:49:48 <alpounet> NerrZ, for what it's worth, works smoothly on Mac OS X with both ghci and ghc
21:50:39 <NerrZ> damn, I wanted to make a game while avoiding graphics for as long as possible
21:51:40 <NerrZ> and I was hoping I could get raw inputs
21:51:59 <NerrZ> what about the System.win32 stuff, could I load the User32.dll and check key states that way?
21:53:06 <alpounet> NerrZ, may I suggest the 'gloss' library?
21:53:18 <alpounet> @hackage gloss
21:53:18 <lambdabot> http://hackage.haskell.org/package/gloss
21:53:28 <alpounet> and there's gloss-raster for more goodness
21:53:34 <alpounet> @hackage gloss-raster
21:53:34 <lambdabot> http://hackage.haskell.org/package/gloss-raster
21:54:15 <alpounet> if it's 2D at least
21:54:43 <NerrZ> someone earlier suggested that, and I had some luck with it, but I thought I could do it more simply another way
21:54:55 <NerrZ> does gloss raster add anything for 2d that is needed?
21:57:02 <alpounet> NerrZ, just parallel rendering of raster images
21:57:27 <NerrZ> what is a raster image
21:57:29 <alpounet> but since this can matter in some cases, i'm also pasting that link, just in case this might be useful
21:57:57 <alpounet> NerrZ, I guess http://en.wikipedia.org/wiki/Raster_graphics will explain better than me
21:58:33 <NerrZ> ty
21:58:41 <NerrZ> idk,, I just need blocky graphics really
21:58:49 <NerrZ> I am making a tetris game
22:01:25 <alpounet> NerrZ, just gloss should be fine then
22:01:41 <NerrZ> thank you
22:02:22 <alpounet> in about 30 minutes you'll have understood how to use gloss for a game and maybe have run an example or two
22:27:00 <NerrZ> I need to update gloss but cabal wants to download an older version, is there a way to force it to get the newest?
22:33:37 <johnw> --constraint "gloss == <VERSION>"
22:33:54 <johnw> However, that doesn't mean the build plan is viable
22:36:51 <halfie> Regarding http://hackage.haskell.org/trac/ghc/ticket/703 ... the official binary distribution still generates executables with executable stack.  what is going on?
22:38:03 <elliott> halfie: might be a regression, reopen the bug?
22:39:09 <halfie> elliott, will do, hoping that I don't get shouted for opening a 4 year old bug :(
22:39:22 <halfie> s/shouted/shouted on
22:40:25 <elliott> halfie: we try to be nice :P
22:41:11 <halfie> (I will not mention that I am learning Scala instead of haskell) ;)
22:41:50 <pxqr> I'm trying to use network-conduit. Why could Data.Conduit.await give Nothing? If socket is closed, right? Or there are some other reasons?
22:43:44 <johnw> i believe that means your source closed
22:43:50 <johnw> why, is another question
22:46:46 <halfie> re-opened http://hackage.haskell.org/trac/ghc/ticket/703
22:48:43 <pxqr> ok, all I need to know is what there is no more data
22:53:08 * hackagebot monoid-subclasses 0.2 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.2 (MarioBlazevic)
23:02:41 <dmwit> monoid-subclasses is cute
23:03:49 <johnw> at least it's not semigroup-subclasses
23:04:14 <kfish> i <3 semigroup
23:04:19 <dmwit> The names could use a bit of help.
23:06:27 <dmwit> hm
23:06:34 <dmwit> Actually, I'm not so sure about it any more.
23:07:13 <johnw> i did like MonoidNull
23:07:15 <johnw> but that was about it
23:07:31 <dmwit> I was excited about MonadFactorial until I read the laws.
23:08:35 <shachaf> Not enough laws for you, eh?
23:08:42 <dmwit> The amount of laws is fine.
23:08:53 <dmwit> But I was hoping for a law that said the factorization was "the best possible" in some sense.
23:09:34 <dmwit> The only law there is that factorizing is "idempotent"... but not that other factorizations are subsumed by the one chosen by the instance.
23:25:19 <dmwit> oh wow
23:26:32 <dmwit> Just revisited an old StackOverflow post about some obfuscated code. Before I wrote an answer I analyzed the code, then for the answer I played back my analysis in reverse. And now there's a second answer from the guy who wrote the obfuscated code saying his process of obfuscation pretty much matched my reversed de-obfuscation process.
23:27:03 <adnap> Can you import modules on the command line with ghc when compiling a source file as opposed to including them in the file?
23:27:22 <kfish> dmwit: url?
23:27:25 <dmwit> adnap: Oh, no, I don't think so.
23:27:38 <dmwit> http://stackoverflow.com/q/12659951/791604
23:32:30 <alpounet> adnap, i've never read about such an option -- do you have a solid use case for this?
23:32:32 <shachaf> Asking "how does this code work" about obfuscated code like that is kind of odd.
23:32:59 <dmwit> shachaf: Why's that?
23:33:02 <shachaf> You can simplify it step-by-step but the end result won't be obfuscated or give you much insight about the original code.
23:33:36 <dmwit> I dunno.
23:34:00 <dmwit> I recall that by the time I finished working out what was going on, I could squint at the original and see "map" and "(*2)" in it, at least.
23:34:51 <dmwit> But I guess asking somebody else to do that process indeed wouldn't give you as much insight. =P
23:39:53 <dmwit> Oh ho! (a `mplus` b) >>= f = (a >>= f) `mplus` (b >>= f) is a MonadPlus law?
23:40:41 <dmwit> hm
23:40:45 <dmwit> Not sure I believe that.
23:41:14 <frelux> does anyone have any ideas on cleaner ways to do this? http://hpaste.org/89815
23:42:08 <dmwit> Okay, I guess I believe it. But it still doesn't explain why mplus is so messed up for [].
23:42:25 <dmwit> no wait
23:42:58 <dmwit> > ([3] `mplus` [4]) >>= guard even
23:42:59 <lambdabot>   Couldn't match type `()' with `[b0]'
23:43:00 <lambdabot>  Expected type: a0 -> [b0]
23:43:00 <lambdabot>    Actual t...
23:43:51 <dmwit> > ([3] `mplus` [4]) >>= guard . even
23:43:52 <lambdabot>   [()]
23:44:10 <dmwit> > ([3] >>= guard . even) `mplus` ([4] >>= guard . even)
23:44:11 <lambdabot>   [()]
23:44:22 <dmwit> > [3] `mplus` [4]
23:44:23 <lambdabot>   [3,4]
23:44:25 <dmwit> oh
23:44:27 <dmwit> that's okay then
23:44:33 <dmwit> Why did I think that would be [3]?
23:44:39 <dmwit> > [3] <|> [4]
23:44:40 <lambdabot>   [3,4]
23:45:19 <Taneb> dmwit, perhaps you were thinking of Maybe?
23:45:26 <Taneb> > Just 3 `mplus` Just 4
23:45:28 <lambdabot>   Just 3
23:45:34 <dmwit> I certainly was not.
23:46:08 <Taneb> Oh, I see what you meant
23:46:15 <Taneb> Yeah, I just woke up
23:46:21 <Taneb> I'm going to wander off now, bye!
23:46:38 <dmwit> frelux: I doubt that's doing what you think it's doing.
23:47:10 <dmwit> In particular: if you think that's computing (+) and (++) in the thread that's executing startListener, you'll be disappointed.
23:47:48 <dmwit> As for cleaner, well, I don't see why you're mixing STM and standard concurrency. Pick one or the other and use it consistently.
23:48:11 <dmwit> And forget that Command nonsense. =P
23:48:34 <johnw> dmwit:  I've found at least one thing you can't do it in STM and need standard concurrency for
23:49:19 <johnw> using an MVar to guard a critical region you're going to do IO in.  Although, I suppose you can use an STM block before to fill a TMVar, and an STM block after to empty it...
23:53:39 <frelux> dmnwit: hehe thanks, I'm doing some IO that should force computations in the real code so I don't think I have strictness issues but that is a good call : )
23:53:52 <frelux> dmwit: what do you mean by "forget the Command nonsense"?
23:54:16 <dmwit> Instead of sending "Add 3 4 mvar", just send "(3 + 4, mvar)".
23:54:33 <frelux> aha.
23:58:37 <adinapoli> talking about concurrency, am I the only one looking forward for July, the 22nd? :D
23:59:03 <frelux> haha no sir : D, i'm really pumped too
23:59:16 <adinapoli> ahha good good :D
23:59:39 <Aetherspawn> what happens on july 22
