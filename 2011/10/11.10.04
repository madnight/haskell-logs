00:08:27 * hackagebot websockets 0.3.1.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.3.1.1 (JasperVanDerJeugt)
00:20:59 <erus`> > Just 1 >>= return
00:21:00 <lambdabot>   Just 1
00:21:29 <TNA-MichaelK> erus: interesting...
00:21:46 <Botje> monad laws..
00:21:57 <TNA-MichaelK> > just 4 >>= return
00:21:58 <lambdabot>   Not in scope: `just'
00:22:41 <erus`> > Just 1 >> fail "hi"
00:22:42 <lambdabot>   Nothing
00:23:23 <TNA-MichaelK> > "odd"
00:23:24 <lambdabot>   "odd"
00:23:53 <TNA-MichaelK> > '
00:23:54 <lambdabot>   <no location info>:
00:23:54 <lambdabot>      lexical error in string/character literal at end o...
00:24:55 <erus`> why does fail take a string?
00:25:15 <kmc> so that your monad can provide better error messages
00:25:20 <kmc> particularly in the case where fail = error
00:25:43 <kmc> the purpose of 'fail' is to be used in the desugaring of pattern-matches in 'do'
00:25:51 <kmc> @undo do { Just x <- y; return x }
00:25:51 <lambdabot> y >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
00:26:03 <kmc> a real compiler will provide some useful (implementation-dependent) message instead of ""
00:26:29 <rostayob> is it possible to derive 'succ' and 'pred' for enum, but to change the numbers ('fromEnum')?
00:27:12 <kmc> rostayob, i think 'succ' and 'pred' have default implementations in the definition of the Enum class
00:27:17 <kmc> in terms of fromEnum and toEnum
00:27:40 <rostayob> kmc: oh, cool. how would that works? it enumerates them all and then get the next one?
00:27:55 <erus`_> @undo do { Just x <- y; return x }
00:27:56 <lambdabot> y >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
00:28:02 <rostayob> kmc: succ                   = toEnum . (`plusInt` oneInt)  . fromEnum
00:28:05 <shachaf> > succ (123629346921417923::Integer)
00:28:06 <lambdabot>   123629346921417924
00:28:11 <shachaf> Oh, default implementations.
00:28:13 <rostayob> so it doesn't work if you have "holes"
00:28:20 <rostayob> in the numbers
00:28:32 <kmc> right
00:28:39 <kmc> so this won't work for you then?
00:28:50 <rostayob> but i don't think you're supposed to have holes anyway in Enum.. maybe I just shouldn't use it for what i need
00:29:03 <rostayob> kmc: no it wouldn't
00:29:13 <rostayob> i mean i'd never call succ and pred anyway
00:29:23 <rostayob> is there a typeclass with just 'a -> Int'?
00:29:50 <TNA-MichaelK> read, no?
00:30:10 <TNA-MichaelK> > read "24" + 2
00:30:11 <lambdabot>   26
00:30:33 <rostayob> TNA-MichaelK: ? Read is 'String -> [(a, String)]'
00:30:37 <erus`> :t toInteger
00:30:38 <lambdabot> forall a. (Integral a) => a -> Integer
00:31:09 <rostayob> erus`: (Real a, Enum a) => Integral a
00:33:50 <rostayob> in other words, how do you guys represent C enums?
00:36:26 <Aatch> I don't use enums in C much, but aren't they just represented as sequential integers?
00:36:33 <kmc> not always sequential
00:36:36 <rostayob> Aatch: not necessarely sequential
00:36:40 <QtPlatypus> What do you wish to do with it?
00:36:54 <rostayob> QtPlatypus: with enums? i'm writing bindings
00:37:05 <rostayob> QtPlatypus: is a great nickname btw.
00:37:22 <hpaste_> kmc pasted “enums (for rostayob)” at http://hpaste.org/52126
00:37:30 <Aatch> Ah, true
00:37:47 <Aatch> I forgot about the assigning syntax.
00:38:10 <rostayob> kmc: uhu, is that c2hs?
00:38:19 <kmc> hsc2hs
00:38:31 <rostayob> oh, i never knew! i have to read the docs
00:38:33 <rostayob> again
00:38:36 <rostayob> thanks a lot
00:38:39 <kmc> no prob :)
00:38:42 <kmc> hsc2hs is a useful tool
00:38:48 <kmc> it's well-integrated with cabal too
00:38:52 <kmc> painless to use
00:38:58 <Aatch> kmc seems to have beaten me to it.
00:39:02 <rostayob> kmc: yes i've used it before but never to its full potential it seems
00:39:27 <kmc> the downside is that you don't get e.g. a list of all valid enum values
00:39:37 <rostayob> kmc: yep, but it's ok
00:40:10 <rostayob> cool cool thanks
00:40:19 <kmc> in the same project i have a bash script which parses a huge enum of all x86 opcodes from a header in the C library
00:40:32 <kmc> and outputs a plain Haskell data type which derives Enum
00:40:34 <rostayob> kmc: bash?
00:40:37 <kmc> those are sequential though
00:40:38 <kmc> yeah
00:40:41 <rostayob> why bash
00:40:53 <kmc> why not, it was simple
00:41:08 <rostayob> mhm i've always been suspicious in bash
00:41:11 <rostayob> *of
00:41:16 <shachaf> bash + sed
00:41:17 <rostayob> i don't know why it doesn't feel right ehe
00:41:30 <rostayob> yeah i guess that's the unix way but whatever
00:41:39 <rostayob> OSs are ugly
00:43:03 <Aatch> OSs are also hard, I couldn't even manage simple keyboard input. hell, kprint was a mission and a half...
00:43:17 <rostayob> actually proper OS programming is fun
00:43:26 <rostayob> all that scripting is ugly
00:43:45 <rostayob> Aatch: i loved my OS coursework, on this http://en.wikipedia.org/wiki/Pintos
00:44:06 <Aatch> Depends on what language your scripting in.
00:44:36 <rostayob> you write syscalls, the paging system, all that stuff
00:44:45 <rostayob> probably the most educative thing i've ever done in uni
00:44:48 <Aatch> rostayob: I think I've heard of that, or something very similar. I was also trying to do all this by trial and error + internet
00:44:48 <rostayob> Aatch: i guess
00:45:03 <rostayob> Aatch: that's just a simple OS to play with
00:45:06 <rostayob> but it works
00:45:27 <Aatch> rostayob: and that was very educational, I know way more about how everything fits together now.
00:45:28 <rostayob> well it half works, you have to add a lot of stuff
00:45:43 <rostayob> the scheduling part was fun as well
00:47:10 <Aatch> I might have a look at it, when I saw how much work something as simple as getting KB input was, I kinda got scared.
00:47:33 <Aatch> I then lost the work I had done (OS reinstall) and just left it
00:48:24 <rostayob> Aatch: you don't do keyboard input
00:48:32 <rostayob> you don't really work with drivers
00:48:48 <rostayob> well you never type really, you just run C programs on it
00:48:59 <kmc> the labs from http://pdos.csail.mit.edu/6.828/2010/ are fun
00:49:09 <Aatch> I probably should have tried that.
00:49:22 <Aatch> When I don't have 30 other project ideas, I might get to it.
00:50:04 <rostayob> kmc: reading the overview, we did more or less those things
00:50:40 <rostayob> but with pintos, they use 'JOS', whatever it is eheh
00:50:45 <Aatch> Haven't done OS at uni yet though
00:51:12 <Aatch> From what I've seen other people do, they use some odd Windows stuff.
00:51:30 <Aatch> They have a lab with Dual boot Windows/Arch to accomodate
00:52:14 <rostayob> Aatch: mhm for us it was in the middle of the second year
00:52:17 <rostayob> it was a massacre
00:52:36 <rostayob> people not sleeping for the last week, it was great
00:53:32 <Aatch> I'm finishing my second year now. I meandered through alot of different courses before deciding that programming is the only thing I can focus on long enough to actually pass
00:53:43 <Aatch> third year sorry
00:54:05 <cheater> arch? lol
00:54:21 <Aatch> Hey, don't knock ArchLinux
00:54:28 <cheater> why :p
00:55:08 <Aatch> Because its good. At least, for control freaks like me. I was running gentoo, but I got tired of compiling my life away
00:55:28 <rostayob> Aatch: yeah you'll get tired of that eventually
00:55:46 <TNA-MichaelK> I hear there's a version of Arch built in Haskell?
00:56:09 <Aatch> TNA-MichaelK: Wait what?
00:56:16 <cheater> troll
00:56:18 <cheater> do not feed
00:56:37 <TNA-MichaelK> A friend mentioned something about Arch and Haskell a while ago, I don't quite remember
00:56:57 <kmc> my friend saw Elvis pumping gas in Idaho
00:57:13 <rostayob> TNA-MichaelK: what they have is a tool to translate cabal packages to archlinux packages, but that's another story
00:57:35 <rostayob> TNA-MichaelK: there is no used OS built in haskell
00:57:56 <kmc> nothing general-purpose and openly available, anyway
00:57:56 <rostayob> but there is this: http://web.cecs.pdx.edu/~kennyg/house/ !
00:58:05 <TNA-MichaelK> rostayob: Ah, I must have misunderstood or remembered incorrectly then, thanks.
00:58:11 <rostayob> because we can!
00:58:13 <kmc> presumably Galois's OS projects for the NSA etc. get used
00:58:36 <kmc> also Linspire wrote their package manager etc. in Haskell
00:58:41 <kmc> or something
00:59:35 <rostayob> kmc: what? galous os project for the nsa?
01:00:07 <rostayob> *galois
01:00:10 <rostayob> evariste
01:00:25 <kmc> yeah they've done a bunch of OS projects
01:00:28 <kmc> 's why they released http://halvm.org/wiki/
01:00:46 <frerich> Is anybody aware of something like System.INotify for Windows (probably implemented using FindFirstChangeNotification() etc.)?
01:01:09 <rostayob> kmc: well i knew about HaLVM, but i didn't know they were building an os over it
01:01:22 <kmc> i don't know specifically what they've done
01:01:40 <kmc> i know HaLVM was used internally as a platform for quickly accomplishing OS-type projects
01:01:42 <kmc> i don't know what exactly
01:01:48 <kmc> i assume some of it is classified
01:03:02 <rostayob> kmc: all this is extremely cool anyway. haskell. ns fucking a.
01:04:24 <erus`> nsa keeping secrets from the public. How is democracy supposed to work if we dont know what we are voting for?
01:05:14 <kmc> off topic
01:05:25 <kmc> but yeah i'm not sure we should cheer on the use of haskell in the military industrial complex
01:05:46 <osfameron> Monad guns!
01:05:46 <rostayob> it's not cheering really, i'm just saying that it's probably really cool
01:06:08 <rostayob> also, we wouldn't have computers, and internet, and all that, without wars, bot real and cold
01:06:23 <kmc> that's an unknowable counterfactual
01:06:24 <rostayob> a lot of research is done in that context
01:07:08 <rostayob> kmc: well the second word war and the cold war had a huge influence on CS research
01:07:30 <kmc> yeah but you can't say what would have happened without those wars
01:07:42 <rostayob> kmc: i'm just saying we wouldn't have what we have now, it'd be different
01:07:44 <osfameron> I heard it said that the last ice age was the biggest spur to human cognitive development
01:07:46 <rostayob> anyway that's off topic
01:09:00 <erus`> without the dark ages Haskell would have been invented maybe 100 years ago...
01:09:11 <cheater> haha
01:09:13 <cheater> who knows
01:09:16 <rostayob> erus`: that's an unknowable counterfactual
01:09:19 <kmc> this is so stupid
01:09:23 <cheater> maybe it's just that the alien space ship crashed in 1998
01:09:25 <erus`> yeah but is it on topic?
01:09:32 <kmc> Haskell is older than 1998
01:09:48 <cheater> maybe it's just that the alien space ship crashed in 1988
01:10:02 <rostayob> kmc: it's not stupid saying that the us military funded a big part of the cs research in the past century, it's just history
01:10:12 <erus`> haskell curry's mother bred with the alien visitor
01:10:13 <Aatch> maybe it's just that alien space ship crashed in <insert year here>
01:10:44 <Aatch> Military /= Military Industrial Complex
01:11:14 <TNA-MichaelK> rostayob: It's arguable that things could be further along.  Think, if we weren't funding a war effort we'd have more funds for CS and other research.  Or, perhaps we wouldn't be nearly bankrupt.
01:11:20 <cheater> osfameron: i've read a story that enhances on this idea (ice age/development)
01:11:30 <cheater> s/enhances/extends
01:11:31 <erus`> haskell curry fathered a son to a Glaswegian prostitute, and symon peyton jones was put up for adoption ...
01:11:43 <rostayob> anyway this is all for -blah, let's not clog this channel with this eheh
01:12:05 <dalaing_home> today I learned about acid-state
01:12:27 <rostayob> acid state is really cool
01:12:36 <dalaing_home> so many cool toys on the path to learning
01:12:36 <erus`> TNA-MichaelK: illegal war*
01:12:59 <dalaing_home> if only my day job wasn't C++
01:13:22 <cheater> are you a C/C++/C# programmer
01:13:55 <dalaing_home> yeah - C++, or at least the bits of it we use in Qt
01:14:00 <Aatch> cheater: C/C++ is nothing like C# btw
01:14:17 <cheater> C/C++/C# is like Haskell/HTML/HaXe
01:14:20 <Aatch> other than in name, and the fact that they all share a C-like syntax
01:14:33 <rostayob> cheater: what?
01:14:43 <cheater> Ruby/R/Rebol
01:14:46 <shachaf> Aatch: The point of "C/C++/C#" is that C and C++ aren't the same language either.
01:14:48 <Aatch> but so does Java and JavaScript
01:14:49 <cheater> @quote rebol
01:14:50 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
01:15:05 <rostayob> cheater: oh so you mean they're different
01:15:16 <rostayob> not that C++ is similar to HTML eheh
01:15:33 <cheater> oh yeah i love programming in J/Juce/JavaScript/Java
01:15:51 <cheater> did i mention Joomla
01:15:57 <rostayob> also, it's stupid but it's not completely stupid. C++ is a superset of C
01:16:04 <Aatch> But it is a smaller jump from C to C++ than C++ to C#, C++ was atleast indented to be an extension of C
01:16:10 <Aatch> Dammit, beaten
01:16:17 <cheater> or is it
01:16:29 <rostayob> well as long as valid C is valid C++...
01:16:37 <dankna> no longer true I don't believe
01:16:38 <cheater> i think both of you don't know C or C++
01:16:44 <dankna> C++ originally was a superset of C89, yes
01:16:46 <Aatch> C++ is a superset of C, just not a strict superset
01:16:53 <dankna> C++ today is definitely not a superset of C99
01:16:58 <cheater> haha "not a strict superset"
01:16:59 <rostayob> cheater:  I know C well, don't know much of C++
01:16:59 <Aatch> most valid C is valid C code, but not all.
01:17:04 <rostayob> but that's what i knew
01:17:14 <dankna> most valid C is valid C, haha?  yeah
01:17:20 <cheater> rostayob: "what i knew" is not good enough!
01:17:29 <dankna> well, the C standard is actually probably the best-written standard I've ever seen
01:17:34 <rostayob> so what C is invalid C++?
01:17:44 <cheater> dankna: except for INTERCAL?
01:17:45 <dankna> I refer to the quality of the prose; the best /formatted/ standard is the Common Lisp HyperSpec
01:18:07 <cheater> is it written as a lisp program
01:18:13 <cheater> no? sux.
01:18:15 <dankna> rostayob, well, the new __bool type; struct literals; ...
01:18:30 <dankna> struct initialization syntax with field labels in it
01:18:33 <shachaf> Aatch: So you're saying it's a superset of a subset of C?
01:18:41 <shachaf> Aatch: That's not what "strict superset" means...
01:18:45 <dankna> the semantics of pointer casts
01:19:01 <cheater> Haskell is a superset of C, just not a strict superset
01:19:04 <dankna> structs with variable-length arrays as their final elements
01:19:20 <dalaing_home> if you're talking about idiomatic C versus idiomatic C++ then they get _really_ different
01:19:20 <dankna> there's quite a lot of stuff added in C99 that C++ doesn't have at all
01:19:29 <rostayob> dankna: ok, so it's all C99 stuff
01:19:31 <rostayob> yeah
01:19:41 <dankna> rostayob, yeah.  but C99 was twelve years ago!!!
01:19:46 <dankna> it's not "new"
01:19:46 <rostayob> sure sure
01:19:47 <dalaing_home> assuming you're willing to dive into STL / boost to get some of the good stuff in there
01:19:51 <rostayob> i was honestly curious
01:19:53 <shachaf> dalaing_home: Speaking of "new"...
01:19:57 <dankna> in fact we're due for another one
01:20:01 <dankna> okay, sure thing then :)
01:20:02 <shachaf> s/laing_home/nkna/
01:20:13 <dankna> (the ISO reviews and updates standards every ten years)
01:21:38 <dankna> shachaf: while your substitution is correct, it took a minute for it to accomplish your intent because I didn't immediately see what it applied to :)
01:21:44 <dankna> shachaf: speaking of new, what?
01:21:52 <mux> I'm not even sure C++ has actually been a superset of C at some point.. weren't the (small but significant) differences there from day 1? such as sizeof(<literal_char>) being different
01:21:59 <dankna> rostayob: yeah, C++ was originally defined as a preprocessor over C89
01:22:03 <shachaf> dankna: "new" and "delete" and such are keywords in C++ and not in C.
01:22:10 <dankna> but that was before there was a written spec for it
01:22:24 <dankna> shachaf: oh, good call, but I was naming things that were the other way around.  to refute the "superset" idea.
01:22:27 <sipa> also: class, friend, operator, ...
01:22:33 <shachaf> Also the typedef struct thing.
01:22:34 <rostayob> dankna: that's all i knew :). i've always avoided C++
01:22:41 <shachaf> dankna: Right, but many C programs have variables called "delete".
01:22:42 <Aatch> I knew I shouldn't have revised my policy on fact-checking before I type.
01:22:43 <dankna> rostayob: fair enough :)
01:22:49 <dankna> shachaf: haha true enough haha
01:23:02 <dalaing_home> 2 months ago I would have loved to upgrade to working on something involving more idiomatic / modern C++ for work - now my daydream upgrade job is more in the ocaml / haskell direction...
01:23:37 <frerich> dalaing_home: Same here.
01:24:19 <dankna> mux: so pre-formalized C++ was a superset of C89, if you ignore the additional-keywords issue
01:24:33 <dalaing_home> considering my day job is working on a C++ library I don't think I'm going to be able to convince them to change...
01:24:36 <shachaf> dankna: And a bunch of other issues.
01:24:38 <mux> dankna: fair enough (I don't know about pre-formalized C++).
01:24:39 <dankna> mux: but standard C++ probably never was - there's the sizeof issue that you point out for example.
01:25:03 <dankna> shachaf: well, yes, I wouldn't be surprised to learn that there's more in that vein
01:25:17 <dalaing_home> did anyone else read the monads-in-c++ blog post from a while back?
01:25:30 <shachaf> dankna: Speaking of sizeof, did you see this program, courtesy of mauke? http://mauke.dyndns.org/stuff/c/sizeof.c
01:26:08 <dalaing_home> http://bartoszmilewski.wordpress.com/2011/07/11/monads-in-c/
01:26:13 <dankna> ahahahahaha
01:26:26 <dankna> combining the index[array] syntax
01:26:29 <dankna> with the sizeof operator
01:26:30 <dankna> nice trick!
01:26:38 <shachaf> dankna: So you know what it prints?
01:26:46 <frerich> That's just the C++ cocktail party trick of exploiting that a[i] <=> *(a+i) <=> *(i+a) <=> i[a]
01:27:02 <dankna> that should print the decimal ascii value of one of the lowercase letters, 'd' on a 32-bit platform or something-I-lost-count on 64-bits
01:27:07 <shachaf> frerich: First of all, that's C, not C++.
01:27:16 <shachaf> Second, no, that's not the trick.
01:27:22 <dankna> of course really it's undefined and would be perfectly allowed to print anything it wanted, or play Tetris or launch missiles
01:27:25 <shachaf> dankna: Nope.
01:27:30 <dankna> okay give me a minute
01:27:31 <dankna> don't tell me yet
01:28:11 <dankna> well sizeof() is an operator, the parens definitely bind as part of it
01:28:15 <mux> I was about to answer: UB
01:28:26 <dankna> so that's sizeof(0) for sure
01:28:55 <shachaf> Do you mean undefined or implementation-defined?
01:28:59 <dankna> sizeof(0) is something implementation-dependent
01:29:19 <dankna> I mean undefined, the pointer cast
01:29:34 <dankna> but still thinking
01:29:37 <mux> shachaf: aren't those two the same as far as the C spec is concerned?
01:29:39 <mux> it's all about UB
01:29:40 <shachaf> dankna: At any rate, it definitely doesn't print 'e' or 'i' or whatever it is.
01:29:49 <dankna> okay.  what does it print, and why?  I give up
01:30:02 <mux> it prints: Segementation fault: core dumped.
01:30:09 <mux> minus the typos :-P
01:30:16 <dankna> haha
01:30:23 <dankna> no it shouldn't segfault
01:30:35 <shachaf> dankna: You can run it if you want.
01:30:40 * shachaf >>= #haskell-blah
01:30:46 <dankna> but what if it launches missiles!
01:30:48 <mux> sizeof(0) should be 4 (literal integer constants are int)
01:31:01 <mux> so this is doing 4[some implementation-defined address]
01:31:05 <dankna> hmm
01:31:07 <dankna> it prints '1'
01:31:07 <mux> oh
01:31:16 <mux> the old trick of foo[bar] and bar[foo] being the same?
01:31:22 <dankna> mux: 8 you mean.  64-bit has arrived!
01:31:33 <mux> dankna: I'm still an ILP32 kinda guy ;-)
01:31:38 <dankna> haha
01:31:43 <shachaf> dankna: int is still 32-bit over here.
01:31:57 <mux> besides most 64-bit arches are LP64 indeed and only have 32bits ints
01:32:03 <dankna> so the type of that string literal is char *, so indexing into it ...
01:32:05 <dankna> no, I don't get this
01:32:08 <dankna> how the hell does it print 1?
01:32:28 <mux> > ord 'e'
01:32:29 <lambdabot>   101
01:32:37 <mux> mmm.
01:33:00 <dankna> mux: true
01:33:04 <frerich> Well, consider that 'sizeof(0)' might not be what's parsed.
01:33:16 <dankna> oh wait!
01:33:17 <dankna> I see
01:33:19 <dankna> hahahaha
01:33:20 <dankna> cuuuuuuuute
01:33:21 <dankna> sizeof
01:33:26 <dankna> wait no :(
01:33:27 <dankna> damn
01:33:29 <dankna> I was thinking
01:33:33 <frerich> but this is really just the old a[i] vs i[a] thing.
01:33:36 <dankna> that the body of the sizeof was
01:33:38 <mux> does it end up running sizeof('a') ?
01:33:38 <shachaf> frerich: dankna said no hints. :-(
01:33:53 <dankna> 0)["abc?"];printf(...
01:33:54 <shachaf> frerich: The fact that that thing is happening is obvious-ish.
01:33:57 <frerich> shachaf: Ergs, sorry.
01:33:57 <dankna> but that doesn't work
01:34:07 <dankna> frerich: yes I already am aware of a[i] i[a]
01:34:07 <mux> well that's not so fun, it just involves parsing rules that end up being surprising..
01:34:33 <dankna> but you're saying it interacts with the parser
01:34:43 <dankna> so an extra set of parens, (sizeof(0)), would change the output?
01:34:45 * dankna tries it
01:34:50 <TNA-MichaelK> mux: hmmm, why doesn't ord 'e' work in ghci?
01:35:08 <shachaf> TNA-MichaelK: Probably you need to import Data.Char?
01:35:11 <dankna> it does, yes
01:35:13 <dankna> okay
01:35:13 <mux> sizeof(0)["abcdefhij"] => sizeof(0["..."]) -> sizeof("abcdefghij"[0]) => sizeof('a') => 1
01:35:16 <mux> am I right?
01:35:21 <mux> TNA-MichaelK: yeah, import Data.Char
01:35:22 <shachaf> TNA-MichaelK: The error message should probably give you/us a clue. :-)
01:35:33 <dankna> mux: you must be
01:35:35 <TNA-MichaelK> "Not in scope:
01:35:40 <mux> it's not fun.
01:35:41 <TNA-MichaelK> so yeah...
01:35:43 <frerich> shachaf: Actually, I think that's the not-so-obvious part. I think 'sizeof' on the other hand is quite standard for C/C++ people (especially not using it like a function). Just like you use 'return' without parens in most cases
01:35:48 <dankna> mux: I had thought that the sizeof operator had mandatory parens as part of it
01:35:48 <mux> there is no pride to have in understanding this
01:35:50 <shachaf> mux is correct.
01:35:59 <shachaf> frerich: I've seen sizeof used like a function almost everywhere.
01:36:01 <mux> I don't like those puzzles, definitely.
01:36:07 <dankna> oh I love this puzzle
01:36:09 <frerich> shachaf: Really? So the same with 'return'?
01:36:09 <dankna> that was hilarious
01:36:12 <dankna> now I know a new one :)
01:36:16 <shachaf> frerich: The a[b] thing doesn't trick you. You see that it's something you don't understand immediately.
01:36:24 <shachaf> frerich: No, return is a statement.
01:36:55 <dankna> yeah, C has both expressions and statements, unlike sane languages like Hask---- oh wait :(
01:37:08 <dankna> that was one of the biggest sources of confusion to me as a new Haskell programmer
01:37:17 <dankna> nobody ever explained that "let" in "do" is a different syntax
01:37:25 <TNA-MichaelK> so "ord Char" Just gives the ascii value?
01:37:26 <dankna> let alone how "where" interacts with "do"
01:37:36 <dankna> TNA: no it gives the Unicode codepoint
01:37:44 <shachaf> dankna: That, of all things?
01:38:03 <dankna> shachaf: yes.  that, of all things.  it was a major barrier to using do-notation for me.
01:38:16 <dankna> which you can't really do IO without, as a beginner and not having a full set of tools.
01:38:33 * shachaf first read a guide that somehow put him under the assumption that let x = y in do-notation actually mutated x and was regular imperative programming.
01:38:35 <dankna> I mean, you don't have to understand monads on day one
01:38:41 <dankna> ouch!
01:39:03 <dankna> I was under the impression for a while that types were taken into account in parsing, so that for example
01:39:13 <Aatch> I appear to be quite lucky to have a guide that seems to put you in the right direction
01:39:18 <Saizan> the problem is doing IO on day one :P
01:39:26 <dankna> integerLiteral == integerLiteral && integerLiteral == integerLiteral
01:39:35 <dankna> would always parse correctly regardless of the precedences of the operators
01:39:37 <TNA-MichaelK> Aatch which guide?
01:39:41 <dankna> nobody actually gave me that impression
01:39:45 <Aatch> Real World Haskell
01:39:50 <dankna> Aatch: btw is your nick a reference to _Ready, Player One_?
01:40:02 <Aatch> dankna: Nope
01:40:05 <dankna> ah okay :)
01:40:13 <Aatch> dankna: I don't even know what that is
01:40:24 <shachaf> _Programming in Haskell_ is good. It would be nice if it was made publicly available online at one point so I could point people to it without feeling too guilty.
01:40:24 <dankna> it is a book!  about internet stuff.
01:40:28 <dankna> fiction novel.
01:40:38 <dankna> parable about present through lens of dystopian future.
01:41:12 <TNA-MichaelK> Aatch: Ah, thanks, I've been preferring this guide lately: http://learnyouahaskell.com/chapters
01:41:26 <dankna> it's good that we have two good guides now
01:41:32 <shachaf> preflex: seen GrahamHutton
01:41:32 <preflex>  GrahamHutton was last seen on #haskell 339 days, 11 hours, 50 minutes and 17 seconds ago, saying: thanks!
01:41:34 <dankna> I don't think either existed when I was starting
01:41:45 <Aatch> dankna: Just googled it, looks good
01:42:14 <dankna> Aatch: yeah, I think so.  it's not for everyone; the explanation of the 80s references gets a little tedious, if you in fact don't need it.
01:42:22 <dankna> but if you're a young 'un it's probably necessary, so hey.
01:42:41 <Aatch> I am one of those Young Un's though
01:42:54 * dankna nods
01:43:12 <Aatch> Child of the 90s? 00? I don't even know anymore
01:43:25 <dankna> if you were born in 2000 and are in here, I'm impressed
01:43:43 <TNA-MichaelK> From a Haskell guide: "If you still don't know what recursion is, read this sentence."
01:44:22 <dankna> hah!  nice twist on that old line.
01:44:48 <Aatch> TNA-MichaelK: Hopefully the reader does tail-call optimisation, I wouldn't like to see a brain stack-overflow
01:45:10 * kmc rolls eyes
01:45:30 <TNA-MichaelK> I can't remember what happened in the last 5 minutes
01:46:08 <Aatch> kmc: Sorry -.-
01:46:44 <Saizan> that's a particularly unfounded recursion though
01:57:29 <Aatch> I probably should have left learning Haskell until I had time to use it properly. Right now I'm getting annoyed at python for not being Haskell
01:57:37 <mauke> dankna: hay guise
01:57:43 <dankna> hihi mauke
01:58:03 <mauke> for reference, the syntax of 'sizeof' is sizeof EXPR or sizeof ( TYPE )
01:58:12 <mauke> standard unary prefix op precedence
01:58:45 <mauke> and I haven't read up that far but I don't believe C++ ever was a superset of C89
01:59:48 <Aatch> Are you commenting on the past hour or so of chat activity?
01:59:48 <TNA-MichaelK> Aatch: Why python?  What for?  Granted I'm using it for some challenges, but I'm trying to recode everything in Haskell now.
02:00:02 <mauke> yes
02:00:09 <Aatch> TNA-MichaelK: University project, I picked Python before learning Haskell
02:00:19 <mux> mauke: yeah that's what I said; and indeed it wasn't. (except for pre-formalized C++ as someone said, and even then, there are addition keywords)
02:00:25 <Aatch> TNA-MichaelK: Dont have time to recode it all before the dead line
02:00:26 <mux> additional*
02:00:32 <Aatch> mauke: ok ,just checking
02:00:38 <TNA-MichaelK> Aatch: Ah, what's the project?
02:00:50 <mauke> mux: even pre-standard C++
02:00:52 <Aatch> TNA-MichaelK: Chat Server.
02:01:16 <mux> mauke: yes, "even then[...]"
02:01:29 <mauke> mux: I'm not talking about keywords
02:02:27 <mux> mauke: yeah well whatever; it wasn't the same and that was the point. I don't really care about peculiarities of pre-formalized C++ nor do I think it has any significance
02:03:26 <TNA-MichaelK> Aatch: IM-ed, instead of clogging channel.
02:07:21 <melle> ?
02:10:25 <frerich3> mauke: Funky I was just talking to shachaf about whether 'sizeof' with or without parenthesis is 'common' and now you explaint hat it actually depends on whether you specify a type or an expression. I never realized this difference.
02:11:07 <mauke> well, in a way it's like sizeof EXPR and sizeof CAST
02:11:13 <mauke> and CAST = ( TYPE )
02:12:26 <frerich> Yeah, I was thinking of cases like 'char buf[sizeof myStruct]' where 'myStruct' is a variable, and I guess shachaf thought of it being a type. I never noticed that this makes a difference.
02:12:44 <erus`> can i do something like    type Meh = String    and then    f :: Meh -> Int     so f will only take a Meh and not a string?
02:12:54 <mauke> erus`: a Meh is a String
02:12:54 <erus`> do i have to use a constructor?
02:13:02 <mauke> 'type' doesn't have constructors
02:13:08 <frerich> erus`: Sounds like a job for 'newtype'?
02:15:19 <kmc> data Meh = MkMeh String
02:15:34 <kmc> (or 'newtype' instead of 'data', but that's mostly just an optimization)
02:21:44 <quicksilver> \o/, IsList, another proposal to make haskell's concrete syntax dissolve into a cornucopia of ambiguous type errors.
02:22:42 <ketil> If I have one thread returning a lazy data structure, and another thread causing it to be evaluated, which thread actually does the evaluation?  (I have a single thread constructing, and multiple threads reading, so I'd like the work to be distributed)
02:23:02 <quicksilver> evaluation is done when demanded
02:23:11 <quicksilver> by the thread that demands it.
02:24:18 <dankna> ketil: deepseq might be useful to force evaluation
02:24:22 <dankna> or just plain seq
02:24:33 <ketil> quicksilver, ok.  Sounds good to me.
02:24:37 <erus`> i would like haskell scripting in the browser
02:36:00 <Razz> I'm trying to built a simple daemon/server to get requests through a socket, put them in a queue and handle them using separate threads, any tips where I should look for some nice example code?
02:36:16 <Razz> s/built/build/
02:42:22 <int-e> Razz: is there a particular reason why you want to manage your own queue?
02:43:13 <Razz> int-e: don't want two queue requests to be handled concurrently, so I don't just want to fork a new process for each request, just handle each separately.
02:46:29 <int-e> Razz: I would probably start from http://www.haskell.org/haskellwiki/Implement_a_chat_server (disclaimer, I wrote that page) ... using forkIO to allow running requests concurrently (note that forkIO spawns a new Haskell thread, which are then mapped to a fixed number of OS threads). There's probably some ready-to-use package on hackage for the purpose, too.
02:47:51 <Razz> int-e: thank you
02:48:56 <mah_b> Razz: Maybe look at Control.Concurrent.Chan?
02:49:13 <Razz> mah_b: ok, I'll have a look at that :-)
02:58:50 <gienah> Phazorx: its necessary to unmask =dev-haskell/haskell-src-1.0.1.4* somehow (I use a sledgehammer approach, I have that line in both /etc/portage/package.keywords and /etc/portage/package.unmask)
02:59:01 <gienah> oops wrong channel sorry
03:02:53 <erus`> this is not the best channel but: I have ssh access the a box and i have to view files with vi. Whats the easiest way to view/browse files on my local machine with my own editor over the network?
03:03:10 <kmc> sshfs
03:04:34 <shachaf> vim can also edit using scp.
03:04:35 <dafis> what's the best way to find out whether some function is used by any package on hackage?
03:04:59 <Eduard_Munteanu> Or you can configure 'mc' to use vim as its editor I guess.
03:05:21 <shachaf> dafis: google.com/search?q=site:hackage.haskell.org+packagename might work.
03:05:26 <Eduard_Munteanu> ('mc' can connect through SSH and browse / operate on files)
03:06:03 <dafis> shachaf: wouldn't that search only one named package?
03:06:37 <shachaf> dafis: Hackage HTML pages have a dependencies: field.
03:06:43 <gienah> dafis: maybe hayoo: http://holumbus.fh-wedel.de/hayoo/hayoo.html
03:07:50 <Aatch> erus`: probably sshfs like has been said, you could always just copy them locally and then push them back later. I don't know your situation though...
03:08:13 <erus`> i will look at sshfs
03:09:02 <Aatch> sshfs just uses FUSE if I remember correctly, so you dont even need admin rights to mount the remote directory
03:09:24 <dafis> gienah: I want to know whether somebody uses the function, not whether some package exports it
03:10:11 <dafis> but I think I hav found the solution, sit:hackage.haskell.org inurl:doc/html/src
03:10:19 <dafis> have*
03:10:29 <Aatch> 'e' key failing?
03:10:35 <Eduard_Munteanu> Is the function name unique, or uncommon at least?
03:10:37 <alpounet>  sshfs is great
03:15:00 <dafis> Eduard_Munteanu: uncommon enough, it's scaleRat from GHC.Float, I want to know whether it can be removed
03:18:36 <shachaf> dafis: Oh, I thought you wanted to know whether someone depends on the package.
03:18:37 * hackagebot libcspm 0.1.2 - A library providing a parser, type checker and evaluator for CSPM.  http://hackage.haskell.org/package/libcspm-0.1.2 (ThomasGibsonRobinson)
03:18:39 * hackagebot cspmchecker 0.1.2 - A command line type checker for CSPM files.  http://hackage.haskell.org/package/cspmchecker-0.1.2 (ThomasGibsonRobinson)
03:19:13 <dafis> shachaf: no, whether anybody uses the function (apparently not)
03:19:34 <shachaf> dafis: Plenty of packages don't have documentation generated, so you can't be sure of that.
03:21:10 <dafis> shachaf: true, and not all packages are on hackage, but it's an indicator, and the function is (was) only useful in a very limited setting
03:22:35 <dafis> so, I can ask whether removing it seems a good idea
03:28:37 * hackagebot cake 0.1.1 - A build-system library and driver  http://hackage.haskell.org/package/cake-0.1.1 (JeanPhilippeBernardy)
03:36:32 <rvion_> any news from new hackage server?
03:36:48 <mm_freak> new hackage server?
03:37:05 <rvion_> HackageDB 2.. ?
03:53:40 * hackagebot BiobaseXNA 0.5.4.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.5.4.0 (ChristianHoener)
03:53:42 * hackagebot BiobaseFR3D 0.1.3.0 - Importer for FR3D resources  http://hackage.haskell.org/package/BiobaseFR3D-0.1.3.0 (ChristianHoener)
04:13:01 <donri> "Maybe" isn't a type, "Maybe Int" is, but is "Maybe a"?
04:13:19 <sipa> if a is a type, then Maybe a is a type as well :)
04:13:25 <shachaf> donri: That jsut depends on how you define "type".
04:13:37 <sipa> I asumme you define type as "something of kind *"
04:13:38 <donri> duno, just going by LYAH
04:14:23 <donri> haven't quite gotten to "kinds" yet
04:14:35 <sipa> ok, forget that i mentioned it
04:14:39 <engla> Maybe a is a type
04:14:40 <donri> :)
04:14:42 <shachaf> donri: There is more than one definition of "type".
04:14:55 <donri> And maybe "a" isn't a type... ohwait
04:15:11 <engla> > let m = Just undefined :: Maybe a
04:15:12 <lambdabot>   not an expression: `let m = Just undefined :: Maybe a'
04:15:13 <shachaf> donri: One is along the lines of "something that a value can be 'of type'"
04:15:23 <shachaf> donri: One is along the lines of "like a value, but on the type level".
04:15:41 <donri> but is [1,2,3] "of type [a]"?
04:15:47 <shachaf> Both are useful/used and the ambiguity is a bit unfortunate, but it's not any deep thing, just a matter of definitions.
04:15:56 <shachaf> It's of type forall a. Num a => a. :-)
04:15:57 <sipa> yes, with a a member of Num
04:16:01 <shachaf> [] is of type [a]
04:16:15 <kmc> i would say that Maybe is a "type constructor" and Int is a "type" and both are "type expressions"
04:16:20 <kmc> but that's just me
04:16:28 <parcs> yeah
04:16:44 <donri> well, that's more or less what LYAH says
04:16:48 <kmc> "a" is a type variable and depending on context might instantiate to a type or a type constructor
04:16:49 <donri> "And like, sometimes me and the boys say that Maybe is a type, but we don't mean that, cause every idiot knows Maybe is a type constructor."
04:16:50 <sipa> kmc: how do you call the argument m to StateT m a
04:16:53 <parcs> if you want to refer to the Maybe type constructor in terms of a type then say Maybe a
04:16:59 <sipa> sorry, StateT s m a
04:17:09 * shachaf kind of likes "types as analogous to values but on the type level".
04:17:12 <kmc> it's a type constructor, specifically a monad
04:17:44 <sipa> is it necessarily a type constructor, or can it be a type function as well?
04:17:48 <donri> looks like LYAH defines "concrete type" to include "polymorphic" aka "[a]"
04:17:52 <kmc> what's a "type function"?
04:18:08 <kmc> when the ability to have type class parameters of kind other than * was introduced, they called this feature "constructor classes"
04:19:03 <parcs> shachaf: haskell's type system isn't powerful enough to draw that correspondence
04:19:07 <shachaf> Hmm, it seems odd that that wasn't always the case.
04:20:07 <shachaf> Those poor early Haskell users who didn't even have monad tutorials.
04:20:26 <donri> but who were also category theorists anyway
04:20:33 <shachaf> Not really.
04:20:53 <shachaf> @quote kmc mathematicians
04:20:54 <lambdabot> No quotes match. Maybe you made a typo?
04:20:55 <shachaf> Hmph.
04:27:33 <donri> @quote kmc math
04:27:34 <lambdabot> kmc says: it's important to show that Haskell is usable not just for useless maths, but also for real-world tasks such as rendering teapots
04:29:27 <absence> i'm reading learn you a haskell, and in the second monad chapter it is suggested that foldr (.) id [(+1),(*100),(+1)] can be made monadic by using <=< instead of . and return instead of id. this causes an error about infinite types. what am i misunderstanding?
04:30:20 <ion> @type foldr (<=<) return
04:30:20 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
04:30:59 <sipa> :t (<=<)
04:31:00 <engla> absence: the list must be changed to a list of monadic functions
04:31:00 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
04:31:39 <ion> @type foldr (<=<) return [return . (+1), return . (*100), return . (+1)] 42
04:31:40 <lambdabot> forall (m :: * -> *) c. (Monad m, Num c) => m c
04:31:41 <ion> > foldr (<=<) return [return . (+1), return . (*100), return . (+1)] 42
04:31:42 <lambdabot>   No instance for (GHC.Show.Show (m c))
04:31:42 <lambdabot>    arising from a use of `M8747424315...
04:31:54 <ion> > foldr (<=<) return [return . (+1), return . (*100), return . (+1)] 42 :: Identity Integer
04:31:54 <lambdabot>   No instance for (GHC.Show.Show
04:31:54 <lambdabot>                     (Data.Functor.Identity.I...
04:32:00 <ion> > runIdentity $ foldr (<=<) return [return . (+1), return . (*100), return . (+1)] 42
04:32:02 <lambdabot>   4301
04:32:30 <absence> aha!
04:33:13 * shachaf wonders in what sense that's really "made monadic".
04:33:21 <absence> that makes sense, thanks
04:33:59 <absence> shachaf: that was my wording, not the book's. i don't remember exactly what it says
04:34:34 <shachaf> > fmap fix return 5 -- They'll make anything monadic these days.
04:34:35 <lambdabot>   5
04:38:06 <engla> that function should really use Control.Category and it would be generic
04:38:32 <ben> @type fmap fix return
04:38:33 <lambdabot> forall a. a -> a
04:39:41 <quicksilver> shachaf: "generalised to any monad" consider first the isomorphism "a -> b" ~~ "a -> Identity b", and then generalising Identity to m. I think.
04:40:11 <shachaf> Oh, that was Identity.
04:40:29 * shachaf thought it was in (r ->) for some reason, with the extra returns serving the role of const. Misread.
04:40:33 <shachaf> Never mind.
04:42:25 <whald> assume I've implemented unboxed vectors for my own data type as desribed in http://hackage.haskell.org/packages/archive/vector/0.9/doc/html/Data-Vector-Unboxed.html -- what would my module doing so have to export to make this available to other modoles?
04:47:09 <parcs> you mean you created an instance of Unbox for your data type?
04:50:18 <Aatch> I'm delving into Parsec, I have this: let parser = count 10 anyChar, it doesn't work, some very dense error messages about no instances arising. Can somebody point me in the right direction. I want to parse 10 characters of a string.
04:50:47 <kmc> did you import Text.Parsec.String
04:51:36 <parcs> Aatch: i think that's because of the monomorphism restriction
04:51:47 <Aatch> yes, still same result
04:52:00 <Aatch> Uhhh.. monomorphism restriction?
04:52:24 <kmc> put a type signature
04:52:31 <kmc> let parser :: Parser [Char]; parser = ...
04:54:33 <Aatch> Aha!, now, why couldn't haskell infer that type?
04:54:46 <Aatch> (it works btw, thank you very much)
04:54:46 <parcs> monomorphism restriction :P
04:54:58 <Aatch> parcs: Helpful...
04:55:31 <kmc> one can google it
04:55:33 <parcs> let bindings cannot be polymorphic
04:55:47 <parcs> unless explicitly given a type signature
04:55:59 <kmc> no, MMR only applies to pattern bindings
04:56:03 <Aatch> Its slightly reassuring that the first sentence of the HaskellWiki page on monomorphism restrictions is "The monomorphism restriction is probably the most annoying and controversial feature of Haskell's type system"
04:56:09 <kmc> so "f x = ..." is safe, "f = ..." is subject to MMR
04:56:23 <parcs> kmc: oh right
04:56:42 <Aatch> Ok, well I'm going to read the wiki now. Thanks for your help.
04:56:44 <raek> hmr, does Standard ML have a similar restriction?
04:56:47 <whald> parcs: sorry, I've been afk -- yes, I assume now I have an instance "Unbox Spectrum" (Spectrum is my data type)
04:57:03 <kmc> raek, it has a different restriction for a different purpose
04:57:14 <kmc> the value restriction
04:57:28 <whald> parcs: but where I inted to actually create an "Vector Spectrum" I still get "no instance for Unbox Spectrum"
04:58:07 <whald> parcs: so I thought maybe I have to export something from the module where I implemented the unboxing for Spectrum
04:59:09 <parcs> you are exporting the data type at least?
04:59:34 <whald> parcs: yes, but not it's (only) constructor
04:59:56 <whald> parcs: I export "Spectrum", but not "Spectrum(..)"
04:59:58 <parcs> ok what about the newtype instanes you created
05:00:29 <linduxed> i've got a variable named DNA that is defined as   DNA = "atcgATCG"  . i've already created a recursive function that checks if a string contains letters that are not a part of the DNA variable (called isDNA).
05:00:42 <linduxed> however it spans over 5 lines total
05:00:53 <whald> parcs: don't know how to export these, following the example given In the Vector documentation, I have an "V_Spectrum" newtype
05:01:00 <linduxed> is there some oneline magic one can compress it to? with foldl maybe?
05:01:29 <engla> linduxed: using any and elem from Data.List
05:01:35 <whald> when I try to export "V_Spectrum" I get "Not in scope: type constructor or class `V_Spectrum'", which is a bit confusing
05:01:36 <kmc> :t all (`elem` "atcgATCG")
05:01:37 <lambdabot> [Char] -> Bool
05:01:49 <hpc> > let dna = "atcgATCG" in all (`elem` dna) "gattaca"
05:01:50 <lambdabot>   True
05:01:51 <linduxed> engla: yeah i'm using elem, but i didn't think of all
05:02:00 <linduxed> *any
05:02:03 <linduxed> forgot about that
05:04:06 <parcs> whald: yeah, i'm not sure why it's not working. i was under the impression that type family definitions and type class instances get exported implicitly
05:04:11 <parcs> but apparently not
05:05:52 <whald> parcs: type class instances are exported implicitely, I've done that often, but I've never worked with type families before, so it seems there's something more to it. I'll keep digging... thanks anyway
05:06:17 <linduxed> hmmm
05:06:21 <linduxed> this didn't work http://paste.pocoo.org/show/487035/
05:06:27 <linduxed> oh wait
05:06:29 <linduxed> importing
05:06:58 <linduxed> hmm i still get textParse.hs:3:1: Not in scope: data constructor `DNA'
05:08:20 <parcs> whald: try exporting MVector(..) and Vector(..)
05:08:53 <parcs> or just MVector(YourNewtype) and Vector(YourNewType)
05:10:28 <whald> parcs: the latter gives
05:10:30 <whald> The export item `V.Vector(Spectrum)'
05:10:31 <whald>     attempts to export constructors or class methods that are not visible here
05:11:36 <whald> parcs: and the former still results in "No instance for Unbox Spectrum" where it's supposed to be used
05:12:23 <whald> parcs: but my instance for MVector is not yet complete, maybe I'll fix that first and see if it solves the "not visible here" problem
05:12:49 <parcs> ok
05:31:45 <whald> parcs: oh my, I was missing the "instance Unbox Spectrum" line. that's all. I thought that would be inferred... :-)
05:34:14 <parcs> oh wow
05:34:15 <parcs> :P
06:00:49 <mzero> anyone know the form for pushing to code.haskell.com -- Is it darks push me@code.haskell.com:/home/srv/code/<project> ?
06:01:23 <byorgey> drop the /home
06:01:32 <mzero> thanks
06:01:52 <byorgey> also s/k/c/ of course
06:16:51 <matthiasgorgens1> @djinn  Applicative f => f a -> f (f a->b) -> f b
06:16:52 <lambdabot> Error: Class not found: Applicative
06:17:00 <matthiasgorgens1> @djinn  Monad f => f a -> f (f a->b) -> f b
06:17:00 <lambdabot> -- f cannot be realized.
06:17:16 <rostayob> Is newCString (using the current system locale) equivalent to write a a string literal in C?
06:17:22 <matthiasgorgens1> @djinn  Maybe a -> Maybe (Maybe a->b) -> Maybe b
06:17:23 <lambdabot> f a b =
06:17:23 <lambdabot>     case a of
06:17:23 <lambdabot>     Nothing -> Nothing
06:17:23 <lambdabot>     Just c -> case b of
06:17:23 <lambdabot>               Nothing -> Nothing
06:17:25 <lambdabot>               Just d -> Just (d (Just c))
06:17:27 <matthiasgorgens1> hmm, too ugly.
06:18:00 <rostayob> @djinn  Maybe a -> (a -> Maybe b) -> Maybe b
06:18:00 <lambdabot> f a b =
06:18:00 <lambdabot>     case a of
06:18:00 <lambdabot>     Nothing -> Nothing
06:18:00 <lambdabot>     Just c -> b c
06:18:11 <rostayob> i like djinn
06:18:33 <dmwit> :t \m f -> do { f' <- f; f <*> m }
06:18:34 <lambdabot> forall (m :: * -> *) b a. (Monad m, Applicative m) => m a -> m (a -> b) -> m b
06:18:56 <dmwit> :t (<*>)
06:18:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:19:01 <byorgey> @type \x f -> f <*> pure x
06:19:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => a -> f (a -> b) -> f b
06:19:24 <byorgey> matthiasgorgens1: ^^^
06:19:56 <matthiasgorgens1> I was looking for something like <*>
06:20:00 <dmwit> byorgey: That doesn't quite unify to the type he asked for, does it?
06:20:17 <matthiasgorgens1> and that's solution with f <*> pure x is the one I also came up with.
06:20:24 <dmwit> :t \m f -> join f <*> m
06:20:25 <lambdabot> forall (f :: * -> *) a b. (Monad f, Applicative f) => f a -> f (f (a -> b)) -> f b
06:20:31 <dmwit> There we go.
06:20:37 <matthiasgorgens1> I was just trying to get rid of temporary variables.
06:21:39 <dmwit> :t \m f -> do { f' <- f; f' <*> m } -- duh, no wonder it was wrong before
06:21:40 <lambdabot> forall (m :: * -> *) b a. (Monad m, Applicative m) => m a -> m (m (a -> b)) -> m b
06:22:22 <byorgey> dmwit: sure it does, mine was more general.
06:22:38 <rostayob> or anyway, is there a way to get a const char * fro a literal in haskell? without having to pack the CString from the String each time
06:22:43 <dmwit> When I unify, I get a = Maybe a', and therefore f (a -> b) = f (Maybe a -> b)
06:22:46 <dmwit> No?
06:23:01 <dmwit> oh
06:23:04 <matthiasgorgens1> The code looks like
06:23:06 <matthiasgorgens1>     when closed $ do
06:23:06 <matthiasgorgens1>         a <- action
06:23:06 <matthiasgorgens1>         hostWhenIdleDoWithState (hostStateOfPmAction a) $ executePmActionInternal a False
06:23:07 <dmwit> Oh, that's what he wrote, and I just read it wrong.
06:23:17 <dmwit> So I was solving the wrong problem. =(
06:23:20 <matthiasgorgens1> at the moment.  and I was wondering whether I can get rid of `a'.
06:23:45 <matthiasgorgens1> And for the types: hostWhenIdleDoWithState :: HostState -> Rpc () -> Rpc ()
06:28:05 <hpc> rostayob: you might be able to do it with that polymorphic strings extension
06:28:09 <hpc> forget what it's called
06:28:29 <matthiasgorgens1> oops, no we can't easily, because we use a twice.
06:29:15 <rostayob> hpc: overloadedstrings?
06:29:22 <hpc> yes, that one
06:29:23 <rostayob> wait, CString is IsString? it can't be
06:29:32 <hpc> you can write the instance, if it isn't
06:29:42 <rostayob> OverloadedStrings just calls that method
06:29:50 <rostayob> ah and pack it unsafely?
06:29:58 <hpc> or something
06:30:01 <rostayob> the result would be the same
06:30:10 <rostayob> i want to avoid mallocing a string each time
06:30:16 <hpc> oh, it's a Ptr
06:30:19 <rostayob> yep
06:30:58 <rostayob> i just wrote a little C function that just returns that
06:31:09 <rostayob> but i felt stupid while doing it :P
06:31:40 <Yrogirg> what is the fixity of -> ?
06:32:09 <dmwit> It's right-associative, and binds losser than type application.
06:32:10 <quicksilver> Yrogirg: it's not an operator, it's syntax
06:32:18 <dmwit> s/losser/looser/
06:32:29 <saml> it's syntax babe. just like =
06:32:34 <dmwit> quicksilver: Might as well think of it as an operator, though. Why not?
06:32:37 <quicksilver> oh, the type-level -> is an operator
06:32:44 <Yrogirg> -> is not a type constructor?
06:32:49 <saml> no
06:32:52 <quicksilver> Yrogirg: I thought you meant the value level ->
06:32:56 <hpc> Yrogirg: they thought case syntax
06:33:01 <quicksilver> or expression level, I should say
06:33:08 <quicksilver> hpc: case and lambda
06:33:32 <saml> a -> b     means  a to b
06:33:38 <saml> a is domain and b is range
06:33:51 <saml> and kind is * -> *, right?
06:33:54 <Yrogirg> oh, so I meant the thing in the type of functions, Int -> Int.
06:34:24 <dmwit> I've never read about GHC's type-operator precedence mechanics.
06:34:27 <dmwit> Maybe it's time I do.
06:34:34 <saml> nevermind kind is different
06:34:35 <quicksilver> yes, it's right associative; I've no idea how strongly it binds compared to other type operators
06:34:49 <Yrogirg> is there a source for -> ?
06:34:53 <dmwit> No.
06:34:56 <quicksilver> Yrogirg: no.
06:35:00 <Yrogirg> "->" is quite unsearchable
06:35:00 <hpc> (->) is built-in
06:35:02 <saml> =>   forall.   are they type operators?
06:35:08 <quicksilver> saml: no.
06:35:19 <dmwit> saml: Sort of, with the new ConstraintKinds business. =)
06:35:22 <hpc> [] is built-in too, but possible to define if you stretch the syntax a bit
06:35:22 <saml> Yrogirg, if -> were type operator,  what is semantics?
06:35:24 <dmwit> Not forall, but =>.
06:36:37 <saml> what are other type operators?
06:36:41 <saml> (,)
06:36:54 <dmwit> They can be defined.
06:36:54 <quicksilver> there aren't any others in haskell core
06:36:55 <hpc> (,) isn't really an operator, because the parens around it are syntactic
06:36:59 <quicksilver> you can define your own though
06:37:01 <dmwit> e.g. data a :-> b = Foo a b
06:37:53 <Yrogirg> dmwit, that is the thing I'm doing now, but I need to prescribe the fixity of :->
06:37:58 <hpc> some people like to use (~>) to represent arrows as type variables
06:38:12 <hpc> "class Arrow (~>) where ..."
06:38:33 <dmwit> Yrogirg: I think by now it's clear you should be asking the GHC manual, not us.
06:39:53 <Yrogirg> and how is "->" called to search for it?
06:40:07 <quicksilver> Yrogirg: function types, maybe?
06:40:28 <dmwit> Search for the TypeOperators extension.
06:40:43 <mekeor> Yrogirg: http://haskell.org/haskellwiki/Keywords#-.3E
06:40:51 <dmwit> Or is it InfixTypeOperators?
06:41:00 <parcs> how is ~> even a valid type operator
06:41:02 <mekeor> Yrogirg: just hoogle it…
06:41:31 <hpc> parcs: it's lower-case, so it is a type variable
06:41:59 <quicksilver> Yrogirg: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1
06:42:04 <quicksilver> "4.1.2 Syntax of Types"
06:46:28 <parcs> hpc: what's a uppercase variant of ~
06:47:07 <parcs> > toUpper '~'
06:47:08 <lambdabot>   '~'
06:47:08 <quicksilver> parcs: :
06:47:14 <quicksilver> parcs: : is the only uppercase symbol
06:48:08 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons
06:48:18 * parcs shrugs
06:50:27 <parcs> oh ok
06:50:32 <parcs> thanks quicksilver
06:51:21 <quicksilver> it's not a brilliant solution (only having one uppercase symbol) but it's also not quite clear what to do.
06:51:51 <parcs> mixfix is obviously the answer
06:52:48 <quicksilver> mixfix doesn't help you distinguish between types and type variables does it?
06:53:15 <hpc> it would be interesting to try making all type variables quantified, and have case not matter
06:53:31 <Eidel> How can i view every test with QuickCheck?
06:53:32 <hpc> and by interesting, i mean unreadable :P
06:53:56 <parcs> oh _that's_ the issue
06:58:16 <k0ral> are there some gtk2hs users here ? I've got some question and the mailing list is unresponsive
06:58:35 <dcoutts> k0ral: it's always worth asking
06:59:00 <k0ral> I can't find the "notify::" signal in gtk2hs' API
06:59:21 <k0ral> this is the signal emitted whenever a GObject attribute has changed
06:59:22 <dcoutts> k0ral: oh yes, that. No it's not bound.
06:59:36 <k0ral> oh man
06:59:37 <dcoutts> k0ral: usually you don't need it because there are signals for most interesting things
06:59:46 <dcoutts> in fact I've never needed it
06:59:49 <k0ral> well, the point is "usually"
07:00:10 <dcoutts> in this case, usually for a very large value of usually :-)
07:00:37 <k0ral> well, as large as it may be, I've fallen into the exception case :(
07:00:45 <dcoutts> k0ral: what is that ooi?
07:00:59 <dcoutts> k0ral: I did think of a way to cover it, but it's a bit tricky to do nicely
07:01:30 <dcoutts> you'd want your attributes to be able to be used as signals via something like,  notify :: Attribute a -> Signal a
07:01:44 <k0ral> yes
07:01:46 <dcoutts> e.g. on obj (notify theAttr) $ \x -> do ...
07:01:52 <k0ral> indeed
07:02:07 <dcoutts> I can point you at the code if you want to have a go
07:02:16 <dcoutts> it's in the glib package
07:02:45 <k0ral> to answer you, it's in Graphics.UI.Gtk.WebKit.WebView
07:03:02 <k0ral> the attribute webViewZoomLevel
07:03:11 <dcoutts> ah, and it doesn't provide enough signals, and expects everyone to use notify
07:03:32 * dcoutts has never used the webkit binding
07:03:34 <k0ral> by the way, why would one have implemented every piece of notify attribute for each of them instead of providing the more general notify signal constructor ?
07:04:59 <dcoutts> k0ral: I'm not sure I follow exactly. We want to provide typed interfaces for everything rather than strings
07:05:21 <k0ral> yes but the notify function you've just described isn't based on strings
07:05:31 <dcoutts> no, but it also doesn't exist yet :-)
07:05:38 <k0ral> yet it is more general than defining every single notify signal
07:05:45 <k0ral> ah :)
07:05:49 <k0ral> then let's define it
07:05:50 <dcoutts> and notify doesn't cover all the cases that the large set of signals covers
07:06:27 <k0ral> but it covers a large enough group of them :)
07:06:56 <k0ral> are you suggesting me to implement it myself ?
07:07:01 <dcoutts> yes :-)
07:07:09 <k0ral> how hard is that ?
07:07:21 <k0ral> to know whether I will allocate time on it :)
07:08:49 <ststephen> i have a question about how to use the Foldable type class
07:09:37 <ststephen> suppose I have a type List a
07:09:38 <ststephen> or rather,
07:09:41 <ststephen> MyList a
07:09:51 <dcoutts> k0ral: there'd be two parts, one is adding the generic support in glib so that attributes can have a signal in addition to a read and a write. If you're lucky you will not need to change all the places where an attribute is defined.
07:09:55 <Yrogirg> I tend to think that -> is infixr 0
07:10:21 <ststephen> but I only want to be able to fold over it if the type "a" is an instance of Ord
07:10:42 <quicksilver> ststephen: you can't really do that with Foldable.
07:10:52 <ststephen> damn
07:10:58 <k0ral> dcoutts: I'm looking at that, but I have no experience in FFI
07:11:00 <ststephen> does what i'm saying make sense though?
07:11:11 <dcoutts> k0ral: it's really not related to FFI at all
07:11:19 <k0ral> dcoutts: ah ?
07:11:23 <dcoutts> k0ral: see glib/System/Glib/Attributes.hs
07:11:53 <ststephen> quicksilver: how would i do that?
07:12:49 <quicksilver> ststephen: well, just don't use Foldable, really
07:13:11 <quicksilver> myFold :: (Ord a) => ...
07:13:19 <ststephen> quicksilver: ok
07:13:21 <quicksilver> ststephen: yes, it makes some sense.
07:13:30 <ststephen> quicksilver: haha great, thank you
07:13:39 <quicksilver> ststephen: but the "promise" of Foldable is that it will work on all MyList a
07:13:48 <quicksilver> so restricting to just Ord a can't fulfill that promise.
07:13:50 <quicksilver> Roughly.
07:13:55 <ststephen> quicksilver: i see
07:14:41 <dmwit> ststephen: Why not implement Foldable on non-Ord types anyway?
07:15:10 <ststephen> quicksilver: well my REAL situation is that I have a type "BinomialHeap"
07:15:13 <ststephen> dmwit: to you, rather
07:15:15 <dmwit> :t foldMap
07:15:16 <Saulzar> Hmm - trying to find the easiest way to get a Ptr out of a Repa array (to pass a buffer to a C function),  so I figured Data.Vector.Unboxed would have something - can't seem to see it. Any clues?
07:15:17 <lambdabot> Not in scope: `foldMap'
07:15:58 <dmwit> ststephen: Yes, and?
07:16:00 <ststephen> dmwit: and it supports a findMin and deleteMin operation
07:16:17 <ststephen> dmwit: but only if the type it contains is an instance of Ord
07:16:21 <wolverian> the old-time package doesn't install from cabal on osx, saying "Not in scope: type constructor or class `CSUSeconds'". it's required for http-enumerator. any hints if I can bypass the issue somehow?
07:16:32 <dmwit> ststephen: Yes, so?
07:16:50 <dcoutts> wolverian: don't install a new instance of old-time, use the one you have installed already
07:16:58 <ststephen> dmwit: so i only can really do a "fold" over it if i know how to remove an element
07:17:12 <ststephen> dmwit: and deleteMin is the only way i do that
07:17:32 <wolverian> dcoutts: oh, right. thanks. :)
07:17:35 <dmwit> ststephen: Well, you can provide a Foldable instance that makes no promises about the ordering things will be folded in.
07:17:47 <dmwit> ststephen: And separately a fold that does make promises (and requires an Ord instance).
07:18:13 <ststephen> dmwit: can i have to implementations of foldr in the same Foldable instance declaration?
07:18:16 <ststephen> two*
07:18:19 <dmwit> No.
07:18:33 <dmwit> The Ord fold wouldn't be allowed to be named foldr.
07:18:37 <wolverian> 'cabal install http-enumerator' installs old-time 1.0.0.6, 'cabal install --upgrade-dependencies http-enumerator' installs 1.0.0.7. the former worked. thanks, dcoutts!
07:18:45 <ststephen> dmwit: yup
07:18:46 * hackagebot boomerang 1.1.1 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.1.1 (JeremyShaw)
07:18:48 <ststephen> dmwit: ok great thanks
07:19:07 <dcoutts> wolverian: --upgrade-dep is generally a bad idea, unless you know what it does
07:19:35 <dcoutts> wolverian: in fact, once you know what it does you'll realise it's a bad idea ;-)
07:20:03 <wolverian> dcoutts: indeed...
07:24:09 <k0ral> dcoutts: I've read your Attribute.hs, it's not that difficult, but are you sure I don't need to know FFI ? now I want to create "notify :: Attribute a -> Signal a" but I would have to understand how Signal works, which is a .chs file
07:25:35 <dcoutts> k0ral: I think we could get away with just using connectGeneric at the right type
07:27:06 <dcoutts> k0ral: unfortunately you cannot just use the string in the Attr because that's not guaranteed to be meaningful, it's just there for the Show instance
07:27:19 <dcoutts> k0ral: we have lots of attributes that do not correspond to gobject properties
07:27:51 <dcoutts> so we'd need to use a similar typing trick to the read-only/write-only attributes
07:28:58 <ststephen> ok i have one more question
07:29:06 <ststephen> if i have a type MyList a
07:29:15 <ststephen> and i put a class restriction in its declaration
07:29:24 <k0ral> dcoutts: I see what you mean, introduced like this it doesn't seem that difficult either :)
07:29:42 <ststephen> a la data (Ord a) => MyList a = ...
07:29:53 <quicksilver> ststephen: short answer : just don't do it.
07:30:03 <quicksilver> it's a bug in the haskell language definition that it's even permitted.
07:30:06 <quicksilver> since it's not useful.
07:30:17 <ststephen> quicksilver: yeah i know it's not kosher
07:30:28 <ststephen> quicksilver: but maybe you can humor me for just a minute
07:30:53 <ststephen> quicksilver: if i did that, so it was impossible to make a MyList with anything besides an instance of Ord
07:31:49 <ststephen> quicksilver: would i then be able to make MyList an instance of Foldable, and have the fold use something that required an instance of Ord?
07:31:54 <k0ral> dcoutts: so basically I would have to add a fourth component to ReadWriteAttr, which is either the name of the attribute, or ()
07:32:06 <k0ral> am I right ?
07:32:23 <ststephen> quicksilver: if not, then class restrictions on type defs are truly useless
07:33:01 <quicksilver> ststephen: it would not.
07:33:08 <k0ral> dcoutts: data ReadWriteAttr o a b = Attr String !(o -> IO a) !(o -> b -> IO ()) !String
07:33:40 <dcoutts> k0ral: so the type of the signal handler is always going to be GObjectClass self => Signal self (IO ())  right?
07:33:43 <k0ral> then I would have, for each signal that has a notify signal, to specify in its definition its name
07:33:49 <ststephen> quicksilver: man, that's bizarre
07:33:52 <ststephen> quicksilver: ok ty
07:34:04 <dcoutts> k0ral: that part should be easy, see Properties.hs in glib
07:35:02 <dcoutts> k0ral: I was thinking alternatively of putting the signal (rather than the name) in the Attr
07:35:16 <k0ral> dcoutts: GObjectClass self => Signal self (IO ()) seems fine to me
07:35:39 <k0ral> dcoutts: or IO Bool to stop propagating the signal
07:36:42 <k0ral> dcoutts: subsidiary question: why isn't there any #gtk2hs ?
07:37:09 <dcoutts> k0ral: it'd be too boring and not sufficiently discoverable for new users
07:37:30 <quicksilver> also, #gtk2hs chat is not offtopic here
07:37:31 <dcoutts> not every package deserves it's own channel
07:37:36 <quicksilver> and doesn't cause any problems
07:37:40 <quicksilver> actually I find it quite interesting.
07:37:48 <dmwit> ststephen, quicksilver: Hm. Would GADT's help there? e.g. data BinomialHeap a where Leaf :: BinomialHeap a; Bin :: Ord a => a -> BinomialHeap a -> BinomialHeap a -> BinomialHeap a
07:37:52 <quicksilver> (it's a big package, it had to solve some interesting desing problems)
07:37:54 <k0ral> dcoutts: well, new users don't like flooded chans
07:38:03 <k0ral> dcoutts: and #haskell is
07:38:21 <Aatch> #haskell's not too bad
07:38:30 <Aatch> This coming from a new user
07:38:35 <quicksilver> dmwit: if you actually hide the Ord dictionary inside the type, it can work
07:38:39 <dcoutts> k0ral: people can take longer technical discussions to #haskell-overflow
07:38:50 <dcoutts> or #haskell-in-depth
07:38:51 <k0ral> dcoutts: and for the discovery, that's quite easy, I've myself tried it before even checking its existence
07:39:00 <dmwit> quicksilver: Too bad ststephen left, then. =/
07:39:09 <dcoutts> k0ral: you're clearly an irc pro :-)
07:39:44 <k0ral> Aatch: there's always worse, but sometimes you come up here in a middle of a troll and your question just disappears from the screen in a matter of seconds
07:39:45 <dmwit> ?tell ststephen You might enjoy learning a bit about GADT's. Something like data BH a where Leaf :: BH a; Bin :: Ord a => a -> BH a -> BH a -> BH a might actually admit a Foldable instance.
07:39:45 <lambdabot> Consider it noted.
07:40:40 <dmwit> Yeah, the real risk in high-traffic channels is that you don't happen to be on at the same time as the people who know the answer and your question gets buried.
07:40:52 <Aatch> Hmm, true
07:40:56 <k0ral> dcoutts: :) anyway gtk2hs has a website, you could notify new users there
07:41:01 <Aatch> but I've not problem so far...
07:41:06 <Aatch> not had..
07:41:14 <Aatch> whatever...
07:49:58 <dcoutts> k0ral: ok, so the tricky thing is the type alias I think, so we don't have to modify too much other code or make the types too ugly
07:50:24 <dcoutts> k0ral: suppose we add an extra field like:
07:51:28 <dcoutts> data ReadWriteAttr o a b s = Attr String !(o -> IO a) !(o -> b -> IO ()) !s
07:51:57 <dcoutts> k0ral: and have notify :: ReadWriteAttr o a b (Signal o h) -> Signal o h
07:52:48 <dcoutts> k0ral: so attributes with no signal would use ReadWriteAttr o a b (), and you'd get a reasonable type error message when using notify on such an attribute
07:53:24 <k0ral> that makes sense
07:53:34 <dcoutts> k0ral: but the rest of the codebase mostly uses the type aliases Attr, ReadAttr and WriteAttr. However some of those are attributes with signals and some are not
07:54:03 <k0ral> creating new aliases would make them too numerous
07:54:30 <k0ral> (twice as many)
07:54:31 <dcoutts> you mean too many confusing aliases, I tend to agree
07:55:04 <dcoutts> but that means we have to add an extra type param to every definition of an attr in all the other modules in gtk and other packages
07:55:17 <dcoutts> which will be either () or NotifySignal
07:55:34 <dcoutts> where type NotifySignal = ... whatever
07:56:26 <k0ral> I think I'll spend some time in designing a simple yet unconfusing way to do that
07:56:47 <dcoutts> k0ral: ok great, post your thoughts and patches to the gtk2hs mailing list
07:57:12 <k0ral> dcoutts: as soon as you answer :)
07:57:19 <dcoutts> hmm?
07:57:27 <dcoutts> answer what?
07:58:12 <k0ral> just kidding because I usually don't get much of an answer from the mailing list
07:58:46 * hackagebot uglymemo 0.1.0.1 - A simple (but internally ugly) memoization function.  http://hackage.haskell.org/package/uglymemo-0.1.0.1 (LennartAugustsson)
08:05:12 <rtharper> have a student trying to use n+k patterns with ghc 7.0.3
08:05:15 <rtharper> and they get a parse error
08:05:19 <rtharper> on the pattern n+1
08:05:22 <rtharper> have they been disabled?
08:05:40 <copumpkin> yeah
08:06:11 <Guest22957> any way to enable them?
08:06:16 <copumpkin> trying to remember
08:06:19 <parcs> -XNPlusKPatterns
08:06:21 <dcoutts> NPlusKPatterns
08:06:27 <copumpkin> oh wait
08:06:31 <copumpkin> it should on by default
08:06:34 <copumpkin> or so the user's guide says
08:06:45 <copumpkin> maybe the guide is just out of date for that feature
08:06:46 <copumpkin> http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#n-k-patterns
08:06:59 <dcoutts> Guest22957: or use {-# LANGUAGE Haskell98 #-}
08:07:08 <dcoutts> default in 7.0 is Haskell2010
08:09:11 <Guest22957> cheers guys
08:42:26 <FUZxxl> Hello!
08:42:36 <FUZxxl> Is there a fast implementation of bitvectors?
08:42:47 <FUZxxl> (Is Integer good for this purpose?)
08:44:07 <Cale> FUZxxl: UArrays of Bool are bit vectors
08:44:45 <Cale> (Of course, it depends on what you mean by fast, but they're pretty fast.)
08:46:59 <FUZxxl> Cale I need the following operations to be performed fast:
08:47:00 <Cale> Also, probably Data.Vector.Unboxed does as well...
08:47:07 <FUZxxl> Looking up a single bit
08:47:14 <FUZxxl> XORing two vectors together
08:47:39 <Cale> newtype instance MVector s Bool = MV_Bool (P.MVector s Word8)
08:47:39 <Cale> newtype instance Vector    Bool = V_Bool  (P.Vector    Word8)
08:47:44 <Cale> ^^ yeah, it does
08:47:57 <Cale> er, hmm
08:47:59 <FUZxxl> Cale: Would an Integer be sufficient?
08:48:13 <Cale> FUZxxl: Oh, well, if that's all, then probably
08:48:13 <FUZxxl> I could use the instance in Data.Bits
08:48:41 <Cale> UArray also probably shouldn't be bad, and has a reasonable interface.
08:49:11 <Cale> How large are the bit vectors we're talking about?
08:49:18 <wolverian> 'cabal install hlint' fails with "cannot satisfy -package Cabal-1.10.2.0: [...] unusable due to missing or recursive dependencies", on osx haskell platform 2011.2.0.1. can I fix this?
08:49:47 <danr> hmm. try cabal update; cabal install Cabal
08:50:32 <FUZxxl> Cale: About 10 to 50 bits?
08:50:39 <FUZxxl> Maybe also 100
08:50:53 <Cale> FUZxxl: Oh, then it probably doesn't matter what data structure you use so much :)
08:51:05 <FUZxxl> It's about solving equation systems with bit-coefficients
08:51:09 <FUZxxl> na...
08:51:16 <FUZxxl> The algorithm is O(n³)
08:51:36 <FUZxxl> but if all bits fit into one word, one can go down to O(n²)
08:52:01 <roconnor> O_o
08:52:33 <FUZxxl> Na... Gauss' algorithm requires adding two rows.
08:52:38 <FUZxxl> That's O(n)
08:52:55 <FUZxxl> But if you can add two rows in one step (by xoring them) it's O(1)
08:53:09 <tromp> it would be sweet if GHC provided Int128 and Int256
08:53:39 <FUZxxl> tromp: It would be sweet if there was a hackage library for them (shouldn't be to difficult to implement)
08:54:27 <wavewave> Hi.
08:54:44 <roconnor> if n < C for any fixed constant then technically everything becomes O(1)
08:54:44 <tromp> doesn't ghc have some special support for Int64 to make it more efficient?
08:54:51 <FUZxxl> wavewave:  Hi
08:54:55 <wavewave> What year can be regarded as haskell birth year?
08:55:14 <FUZxxl> tromp: On x64, an Int64 fits into one word.
08:55:18 <danr> 89, first compiler 90
08:55:20 <FUZxxl> wavewave:  Wikipedia?
08:55:30 <parcs> wikipedia says 1900
08:55:35 <wavewave> 87? 90? 98?
08:55:43 <applicative> wolverian, something is wrong if you have to install the Cabal library, I think
08:55:52 <wavewave> Ahh.. I mean our language.
08:56:41 <wolverian> applicative: indeed. I just have no idea what. :)
08:56:46 <danr> http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/Haskell20years
08:57:24 <roconnor> haskell 1.0 report was released on April 1, 1990
08:57:26 <FUZxxl> Strange...
08:57:29 <applicative> wolverian, I'm trying to remember what ghc-pkg incantation might reveal something relevant
08:57:34 <FUZxxl> for Integer, bitSize is undefined.
08:57:38 <wavewave> danr: thanx for the link.
08:57:50 <roconnor> FUZxxl: what value did you expect?
08:57:58 <magicman> :t foldM
08:57:58 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:58:06 <danr> wavewave: The article Being Lazy With Class says first report 1st April 1990
08:58:11 <tromp> on April 1st? was it all meant as a joke?
08:58:12 <FUZxxl> It would be great, if that would give the number of words actually used or the minimal number of bits that are needed to represent that number
08:58:13 <danr> It's a very good article about the history of haskell
08:58:15 <roconnor> September 1987 was the initial meeting
08:58:23 <danr> tromp: ouch! I hope not ^^
08:58:30 <hpc> :t 0 / 0
08:58:30 <lambdabot> forall t. (Fractional t) => t
08:58:37 <tac-tics> > 0 / 0
08:58:38 <lambdabot>   NaN
08:58:44 <applicative> wolverian, does `ghc-pkg check` tell you anything interesting?
08:58:46 <tac-tics> :t NaN
08:58:47 <lambdabot> Not in scope: data constructor `NaN'
08:58:51 <monochrom> the semantics of bitSize is not the number of bits needed for a particular value
08:58:56 <roconnor> FUZxxl: that would be a different function
08:59:04 <tromp> so, conceived in 87, released in 90
08:59:11 <monochrom> oh, it would be nice to have a different method name for that, sure
08:59:14 <FUZxxl> roconnor: DOes that function exists anywhere?
08:59:22 <FUZxxl> It would be quite similar to log_2
08:59:24 <roconnor> I wish
08:59:40 <Cale> cats = cat : cats  http://26.media.tumblr.com/tumblr_lrtu08KXpE1qzf9gso1_400.gif
08:59:56 <wavewave> danr: I read the article some time ago. It was very nice.
09:00:05 <wolverian> applicative: hmm. yes. it complains that http-enumerator-0.6.5.6 is broken due to a bunch of missing dependencies.
09:00:05 <tac-tics> Cale: lol
09:00:08 <FUZxxl> Cale: :-ð
09:00:09 <monochrom> anyway this is yet another example of "meaningful name" not living up to its name
09:00:17 <wolverian> applicative: (I have installed a newer http-enumerator)
09:00:28 <wolverian> actually, I have no idea if that is interesting or not. :)
09:00:44 <wolverian> hmm. okay, a bunch of other packages are broken in the same way too.
09:00:45 <applicative> does `ghc-pkg list` show anything funny about Cabal
09:00:53 <roconnor> monochrom: having an unused parameter due to the way type classes work doesn't help much either
09:00:58 <roconnor> > fix bitSize
09:00:59 <lambdabot>   64
09:01:07 <wavewave> I wanted to know how community perceive haskell's age especially when comparing with other language. I will regard 90 as it's birth time.
09:01:09 <Cale> FUZxxl: Of course bitSize is undefined for Integer, because Integer is unbounded. bitSize is intended always to be a constant function.
09:01:35 <Cale> (maybe that's the wrong design for it...)
09:01:48 <parcs> wavewave: wha
09:01:53 <parcs> what do you mean?
09:02:21 <parcs> oh, you just wanted to know its age
09:02:35 <Cale> wavewave: It's been around since 1990 (or 1989), but for much of its life, it wasn't really intended for real world use.
09:02:41 <wolverian> applicative: it shows that Cabal-1.10.2.0 is installed
09:02:50 <wolverian> applicative: it does not appear broken.
09:02:51 <Cale> So there's Haskell-the-research-language, which has been around that long.
09:03:00 <applicative> hm, not in a funny color?
09:03:04 <wavewave> parcs: these days, I need to introduce haskell to some people around me. So I would like to be correct. ;-)
09:03:06 <wolverian> applicative: nope.
09:03:18 <wolverian> ghc-7.0.4 is blue.
09:03:26 <wolverian> I don't know what that means.
09:03:44 <Cale> But then there's Haskell-the-usable-for-real-work, whose birthdate is arguable, but certainly at some point after 2000.
09:04:04 <Cale> (2003? 2005?)
09:04:18 <dcoutts> wolverian: blue just means hidden, that's ok, only red is broken
09:04:22 <wavewave> Cale: yeah.. that's exactly what I see in history.. for practical use, at least after 98.
09:04:35 <earthy> cale: 2005 sounds better
09:04:44 <applicative> hm, what else can "cannot satisfy -package Cabal-1.10.2.0: [...] unusable due to missing or recursive dependencies" mean
09:04:58 <applicative> dcoutts is here, wolverian
09:05:03 <wavewave> earthy: what was special about 2005 by the way? were there any milestone?
09:05:11 <wolverian> hrm. haskell+platform+2011.2.0.1 is red.
09:05:15 <wolverian> s,+,-,
09:05:21 <monochrom> wolverian: paste your "ghc -v" output for applicative and dcoutts to marvel at. I would love to, too, but I have to go now
09:05:33 <copumpkin> haskell really became awesome when I started using it
09:05:37 <monochrom> actually also "ghc-pkg list -v"
09:05:40 <Cale> GHC 6.4 came out in 2005
09:05:52 <dcoutts> copumpkin: oh, well in that case, thanks! ;-)
09:06:05 <applicative> copumpkin, that's about when I started using I think
09:06:05 <copumpkin> dcoutts: no problem! let me know if you want me to make anything else awesome
09:06:09 <wavewave> I have used haskell from ghc 6.10
09:06:14 <copumpkin> applicative: dude, drugs are bad
09:06:38 * wavewave will be proud that I experienced ghc6 to ghc7 change era long time after. 
09:06:42 * monochrom still has GHC 4.08.1 archived somewhere!
09:06:43 <dcoutts> copumpkin: oh, could you please make hackage awesome :-)
09:06:54 <earthy> wavewave: don stewart's stuff started coming. :)
09:06:55 <copumpkin> dcoutts: but I already use hackage all the time! not sure what else I could do
09:07:05 <copumpkin> hackage is clearly already awesome
09:07:06 <roconnor> I joined #haskell in 2005
09:07:12 <dcoutts> monochrom: pah, that's nothing, oldest version of ghc I've used was 0.29 :-)
09:07:12 <roconnor> seems like a notable year :P
09:07:13 <Cale> When was Data.ByteString first released? It came with GHC 6.6, which was released in 2006
09:07:24 <Cale> That's a good milestone for real world use.
09:07:36 <dcoutts> roconnor: and first major releases of Cabal were in 2005
09:07:41 * earthy nods
09:07:55 <copumpkin> meeting time, sigh
09:08:00 <roconnor> dcoutts: wow, that early?
09:08:14 <wavewave> cabal must be regarded as a great achievement!
09:08:31 <roconnor> cabal beget hackage
09:08:37 <applicative> could wolverian have overwritten his Cabal-10.whatever with a new one? This happened to me once and was impossible to detect
09:08:37 <earthy> RWH was published in 2008
09:08:40 <dcoutts> ~2 years later
09:08:42 <earthy> so clearly before then ;)
09:08:51 <hpaste_> wolverian pasted “ghc -v and ghc-pkg list -v” at http://hpaste.org/52137
09:08:53 <Cale> Of course, 0.29 is still available on GHC's website, so anyone could conceivably download it and try to get it running :)
09:08:54 <dcoutts> roconnor: see the old release dates at http://www.haskell.org/cabal/download.html
09:09:14 <roconnor> impressive
09:09:18 <wolverian> applicative, dcoutts: http://hpaste.org/52137
09:09:28 <dcoutts> Cale: oh but this was a contemporary install, on the old sparc machines at the oxford comlab
09:09:50 <wavewave> cabal was born in August 2004. wow
09:10:16 <roconnor> dcoutts: was cabal part of ghc back then, or independent?
09:10:51 * wavewave started looking up ghc's history. 
09:11:01 <Veinor> is there a shorter way to write liftM f . g ?
09:11:03 <roconnor> the relationship between cabal and ghc-pkg always strikes me a somewhat tangled
09:11:18 <Cale> roconnor: cabal hasn't existed anywhere near that long
09:11:31 <Cale> I'm still thinking of cabal as practically brand new
09:11:36 <dcoutts> roconnor: the cabal lib has always been independent, but always bundled with ghc installs (since ghc 6.4)
09:11:52 <wolverian> applicative: I ran cabal install --upgrade-dependencies http-enumerator earlier, which might have maybe broken things.
09:12:16 <dcoutts> Cale: and 'cabal' the tool is considerably newer
09:14:08 <wavewave> according to http://www.haskell.org/ghc/docs    ghc 0.29 starts out on 12-Feb-1999 from last modified date.
09:14:10 <Cale> Yeah, though really it's been around for perhaps a bit more than half the time I've been using Haskell. :)
09:14:26 <roconnor> one must not confuse cabal, whose command-line name is "runhaskell Setup.hs", with cabal-install ... whose command line name is "cabal". :D
09:14:34 <Cale> My first GHC was 5.02, I believe.
09:14:41 <wolverian> unless someone has ideas, I will proceed to removing and reinstalling haskell-platform from homebrew
09:14:56 * dcoutts is going to rename them: Cabal -> cabal-lib; cabal-install -> cabal;
09:15:22 <wavewave> but since ghc 4.02 also has the same date 12-Feb-1999...
09:15:23 <Cale> wolverian: When I get into a situation like that, I'd usually just blow away ~/.ghc and start cabal installing things again.
09:15:25 <dcoutts> wolverian: the problem is only likely to be with your per-user packages
09:15:42 <wavewave> I guess the first version of ghc must be before.
09:15:45 <wolverian> okay. I'll do that then.
09:15:57 <wolverian> thanks, all.
09:16:13 <applicative> wolverian, I dont get it, but maybe you should kill off the user packages that shadow the global ones, together with whats built on them?
09:16:28 <dcoutts> wavewave: Simon PJ gave an after dinner speech at ICFP and talked about the early days of ghc. It's now over 20 years old.
09:16:39 <wavewave> it's a little difficult to find the history of ghc. hope someone summarize it well in a webpage.
09:17:18 <earthy> methinks GHC was 'that upstart from Glasgow' back when we were taught the concurrent language of east anglia and nijmegen
09:17:18 <wavewave> dcoutts: I see. I guessed so. If ghc started only in 1999, I would be surprised much.
09:17:18 <applicative> wolverian, or maybe that's equivalent to what dcoutts just said.
09:17:41 <earthy> (also known as Clean)
09:17:55 <Cale> I started using Haskell just a little before hierarchical modules :)
09:18:17 <applicative> renaming Cabal cabal-lib is an excellent idea.  'cabal' has already been taken, so to speak
09:18:23 <earthy> gofer was still a going concern back then. :)
09:18:45 <Cale> and to be honest, I still think a lot of our use of hierarchical modules is spurious and unnecessary
09:18:52 <wavewave> long time later, we may distinguish people by ghc generation. ;-P
09:19:11 * wavewave is proud of being ghc6-generation. 
09:19:16 <Cale> Data.* and Control.* are needless
09:19:36 <applicative> Cale, what you dont like the 'Control' vs 'Data' distinction?
09:19:38 <dankna> I disagree, Data.* and Control.* are a good distinction
09:19:44 <applicative> typed too late
09:19:46 <luite> what's the correct procedure for calling setSessionDynFlags for GHC? I use df <- getSessionDynFlags; setSessionDynFlags $ df { change some fields here }, but I get an error when calling initDynLinker after that?
09:20:00 <Cale> applicative: Data.Functor vs. Control.Applicative -- wtf?
09:20:07 <roconnor> finds Data.* and Control.* a useless distinction
09:20:16 <applicative> I marvel at it every time I type them
09:20:27 <applicative> Data.Traversable Control.Applicative
09:20:33 <Cale> Honestly, there's no reason for either of those categories. Most libraries will define at least one datatype, and a lot of them have higher order "control" structure.
09:21:01 <luite> let's make a new ControlData.* for libraries that do both ;)
09:21:11 <Cale> What's wrong with calling the standard implementation of sets Set?
09:21:37 <applicative> there is a certain charm to 'import List, import IO'
09:21:47 <Cale> indeed!
09:21:54 <Cale> That's how it used to be
09:21:56 <luite> import Org.Haskell.Platform.Data.Set
09:22:08 <mux> lol
09:22:20 <roconnor> luite: I'd be happy with that
09:22:26 <Cale> roconnor: rofl
09:22:44 <wavewave> import http://haskell.org/module/Org/Haskell/Platform/Data/Set
09:22:52 <Cale> import qualified Org.Haskell.Platform.Data.Set as S
09:22:59 <roconnor> wavewave: that may even be better
09:23:01 <Cale> import Org.Haskell.Platform.Data.Set (Set)
09:23:15 <danr> open import Relation.Binary.PropositionalEquality -- found in every other agda file
09:23:23 <wavewave> look like javascript..isn't it.
09:23:34 <roconnor> I don't know what javascript looks like
09:23:39 <Cale> Not javascript, Java.
09:23:42 <applicative> I always define equality for myself
09:23:51 <luite> is it possible to make GHC not warn about imports like: import Data.Text (Text), import qualified Data.Text as T ?
09:24:06 <roconnor> GHC warns about that?
09:24:07 <Cale> luite: It warns you about that?
09:24:13 <luite> oh that's with -Wall
09:24:19 <Cale> luite: I do that all the time without any warnings.
09:24:20 <roconnor> still
09:24:23 <Cale> Oh, -Wall is dumb
09:24:25 <wavewave> let all the haskell code be in the web!
09:24:37 <robert[]> internet programming
09:24:43 <Cale> (unfortunately)
09:25:10 <wavewave> or let's convert HTML to haskell.
09:25:13 <Cale> I find -Wall to be mostly unusable because it complains a lot about perfectly good code, and real warnings tends to get lost in the noise.
09:25:20 <Cale> tend to*
09:25:24 <luite> oh I have -Wall for flymake, I should prhaps try to find out how to disable some
09:26:05 <wolverian> hrm, now that I'm rerunning cabal install <a bunch of stuff>, I get lots of "ld: warning: text reloc in ..." lines
09:26:22 <dcoutts> wolverian: osx?
09:26:27 <wolverian> dcoutts: yes.
09:26:46 <christopherlord> hi, i want to build ghc 7 for linux ppc64, but am finding it difficult. 7 requires 6.10 or newer to build, but 6.10 won't build either due to an unrelated problem relating to junk prolog. anyone have success with this?
09:26:59 <dcoutts> wolverian: older ghc and newer xcode don't like each other, you can ignore it or either upgrade ghc or downgrade xcode
09:27:32 <dcoutts> christopherlord: what are the oldest binaries available?
09:27:35 <wavewave> christopherlord: is there no binary release?
09:27:43 <christopherlord> i have 6.4 binaries that seem to work
09:27:54 <christopherlord> nothing newer
09:28:06 * Aatch headdesk
09:28:09 <dcoutts> christopherlord: I'm pretty sure gentoo at least has linux ppc binaries for relatively recent releases, also check the ghc download pages
09:28:17 <wavewave> oh.. then you are doing all the ladder of compilation?
09:28:32 <wolverian> oh, 7.0.4. is old. :)
09:29:19 <christopherlord> dcoutts: I want to target one of the distros my employer supports on our systems :(
09:29:22 <wavewave> kind of interesting project if I watch somebody is doing that.. but not by myself.
09:30:18 <dcoutts> christopherlord: you're missing the point, you can use any suitable recent binary to bootstrap a source build of a recent version
09:30:44 <dcoutts> christopherlord: e.g. the gentoo builds were bootstrapped by stealing a debian binary
09:30:47 <christopherlord> assuming binary compat, that might work. i'll add it to the list of things to try
09:32:18 <christopherlord> dcoutts: i see a 6.12.3 build on gentoo. that should work for this. they also have an 'unstable' 7.0.4 build
09:33:43 <christopherlord> my hope is to get ibm to start supporting ghc, at least on linux, possibly aix too
09:34:23 <christopherlord> thanks dcoutts
09:34:48 <dcoutts> christopherlord: aix might be fun :-)
09:34:54 <dcoutts> (but probably not in a good way)
09:35:07 <dcoutts> christopherlord: it's certainly worked on aix in the distant past
09:35:33 <christopherlord> dcoutts: yep, am aware of some ancient ones. but the whole bootstrap process seems to have code rotted away completely
09:36:15 <dcoutts> christopherlord: right, your options are to go up the ladder from a really old version, or to follow the cross-porting procedure e.g. from linux ppc64
09:37:13 <christopherlord> dcoutts: the cross-port is hard, since the ABI differs between linux and aix
09:37:50 <dcoutts> christopherlord: there's a procedure for it, that's how ports to new arches work, so ABI doesn't matter
09:38:06 <dcoutts> but similarity is a bonus
09:39:27 <dcoutts> christopherlord: btw, if IBM want to outsource ghc maintenance on aix, I can point you to the right people
09:39:27 <christopherlord> dcoutts: as far as i can tell, the bootstrap is broken right now for cross-compiling, but could be wrong. something about ppc not being tier 1, so bugs keep getting returned wont-fix. but the difficulty sure makes it hard to convince anyone at ibm that we should work on making it tier 1!
09:40:57 <christopherlord> dcoutts: would love to hear more about outsourcing, clord somewhereat ca.ibm.com
09:42:45 <wavewave> christopherlord: it seems that debian also has powerpc version of ghc6.12
09:42:51 <dcoutts> christopherlord: full disclosure: by pointing you at the right people, I actually mean my Haskell consulting company. I'll email you. I presume somewhereat equals @
09:43:08 <wavewave> http://packages.debian.org/squeeze/ghc6
09:44:28 <wavewave> ghc6.12.1-13 : amd64 armel i386 kfreebsd-amd64 kfreebsd-i386 mips mipsel powerpc s390 sparc
09:45:06 <christopherlord> wavewave: thanks, noted. hopefully that gets us going
09:45:16 <wavewave> christopherlord: it may be worth to try debian before gentoo in terms of easiness.
09:45:20 <magicman> @hoogle Monad m => m (a -> b) -> [a] -> m [b]
09:45:21 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
09:45:21 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
09:45:21 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
09:45:49 <magicman> @type mapM . ap
09:45:49 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m (a -> b) -> [m a] -> m [b]
09:45:53 <akosch> hi, I have a problem with the following code: http://hpaste.org/52138
09:46:01 <magicman> Eh, close enough.
09:46:49 <akosch> I know that through the LANGUAGE pragma my strings get packed automatically (which is great), but I want them in utf8 and not ISO-8859
09:46:54 <akosch> how would I do that?
09:47:28 <wavewave> IsSting?
09:47:38 <wavewave> sorry IsString?
09:47:58 <dankna> might be possible to make a newtype wrapper on the string type you're using that passes different options
09:48:07 <Aatch> Ok, so I have a parsec problem/question. I have a parser that converts a String to a data, but the converter returns an Either, I want to just return the code on Right, but raise an unexpected on Left. I have done this, but the function seems to consume all the input. Is there something I'm overlooking?
09:48:10 <wavewave> reimplement IsString class .
09:48:49 <wavewave> akosch : if you still want to use OverloadedStrings conveniently.
09:49:06 <dmwit> Aatch: Don't you want the function to consume all the input?
09:49:58 <Aatch> The function that parses the string to data is part of a larger parser, the parser keeps going, but acts as if nothing was passed on.
09:50:20 <akosch> wavewave: yes, I do. I didn't think this wasn't "solved" yet: seems like a common problem
09:50:20 <wavewave> Aatch: probably you need to show us a snippet of your code.
09:50:44 <Aatch> Hmm, yeah
09:51:05 <Aatch> code :: CharParser () CmdCode 43 code = do 44     a <- liftM putCodeStr $ many1 (noneOf ":") 45     case a of 46          Right a -> return a 47          Left a -> unexpected a 48     <?> "command"
09:51:18 <Aatch> Dammit, irssi ate my formatting...
09:51:23 <wavewave> akosch: implementing IsString is not difficult though..
09:51:33 <dankna> by preference, you should use http://hpaste.org/ to paste things
09:51:34 <wavewave> Aatch: you can use hpaste.org
09:51:35 <dmwit> ?hpaste
09:51:35 <lambdabot> Haskell pastebin: http://hpaste.org/
09:51:36 <dankna> rather than pasting them to the channel
09:51:47 <dankna> STEREO!
09:52:03 <wavewave> so eager to tell something. ;-)
09:52:12 <akosch> wavewave: hm, it's just a fromString function?
09:52:17 <rwbarton> wavewave: well, he must have an instance IsString ByteString already, probably the one from Data.ByteString.Lazy.Char8
09:52:28 <dmwit> ?hackage encoding akosch, this package may help you
09:52:29 <lambdabot> http://hackage.haskell.org/package/encoding akosch, this package may help you
09:52:59 <hpaste_> aatch pasted “parsec help” at http://hpaste.org/52139
09:53:08 <akosch> wavewave: how do I tell ghc to use my version with OverloadedStrings?
09:53:19 <akosch> dmwit: thanks, I'll check it out
09:53:36 <Aatch> Ok, hpasted.
09:53:56 <dmwit> Aatch: ?src putCodeStr
09:54:00 <rwbarton> akosch: how about using encodeUtf8 from Data.Text
09:54:43 <rwbarton> responseLBS statusOK [headerContentType "text/plain"] $ encodeUtf8 "áéőűöüß"
09:55:13 <hpaste_> aatch annotated “parsec help” with “parsec help (annotation)” at http://hpaste.org/52139#a52140
09:55:26 <akosch> rwbarton: yeah, but I can't do this on everything: it would mess up my code :)
09:55:55 <rwbarton> let responseText status headers = responseLBS status headers . encodeUtf8
09:56:07 <wavewave> Aatch: probably you need "try" in somewhere.
09:56:08 <monochrom> wolverian: the problem is exemplified by "package process-1.0.1.5-107ac5b78a5845608025ca13d328fdc5 is shadowed by package process-1.0.1.5-a42e98ed45fca8d12250ca595a033c0b". this breaks the Cabal package. you have a million similar shadowings and a million similar breakages. the assessment of "erase ~/.ghc" is correct. for future reference, read my http://www.vex.net/~trebla/haskell/sicp.xhtml for several ways to run into the
09:56:08 <monochrom> same problem again
09:57:01 <akosch> rwbarton: point taken, thanks! (i'm still a bit new)
09:57:05 <rwbarton> akosch: mainly the problem here is that IsString and the rogue instance from Data.ByteString.Lazy.Char8 is tempting you to write wrong code
09:57:27 <dmwit> Aatch: Okay, now I understand the setup, but not the question. =)
09:57:51 <akosch> rwbarton: I see that now, thanks again
09:57:52 <Aatch> Yes, but I don't know where. I just want to stop parsing if the code is invalid, or continue if the code is valid, and return the CmdCode
09:58:05 <wavewave> Aatch: okay let me see.
09:58:52 <Aatch> I don't necessarily need a play by play of what to do, more pointers. I've spent hours trying to find more details on the web...
09:58:54 <wavewave> Aatch:  how about try before cmd  ..
09:59:29 <wavewave> (try cmd <|> some failure process)
09:59:45 <ion> edwardk: You have a name for *everything*. I can’t figure out a succinct name for this one (temporarily misnamed fix_): https://gist.github.com/1188115#L39 :-)
10:00:02 <dmwit> Aatch: What's a string that it does something unexpected for? What does it do? What did you expect it to do?
10:00:47 <Aatch> Well I have a list of Valid codes, so an unexpected string is one that isn't valid.
10:00:50 <edwardk> ion: well, if you just use fix, you get that, except the error becomes bottom by virtue of blackholing
10:01:42 <Aatch> What I expect it to do, is to parse the code, then continue onto the args.
10:01:43 <edwardk> but in general, why call fix?
10:01:44 <ion> edwardk: Yeah, but i like the safety of getting an actual error message instead of potential infinite recursion by accident.
10:01:47 <edwardk> er fix_
10:02:01 <dafis> Aatch: example input?
10:02:06 <ion> edwardk: As an alternative for ScopedTypeVariables
10:02:14 <Aatch> 1234567890Ping:arg1:arg2
10:02:31 <edwardk> use a data Proxy a or some such which avoids the risk of undefined
10:03:08 <Aatch> The beginning gets stripped fine, and the Ping gets returned ok, but the args don't go into a list
10:03:09 <wavewave> Aatch: So do you want to stop parsing if it's invalid and then Failure shows remaining unparsed data?
10:03:27 <dafis> Aatch: I think you would have to eat the ':' first
10:03:40 <Aatch> dafis: I was just thinking that now...
10:03:56 <wavewave> Aatch: yes.. you should consume ':'
10:04:05 <dafis> cmd = liftM2 code (char ':' >> args)
10:04:17 <Aatch> ...
10:04:25 * Aatch sigh
10:04:31 <wavewave> it consumes up to 1234567890:Ping   until code
10:04:48 <wavewave> many1 (noneOf ":") means consuming before ":"
10:05:04 <wavewave> so remaining is ":arg1:arg2"
10:06:10 <wavewave> sepBy1 (many1 $ noneOf ":") $ char ':' need an input without ':' at the starting.
10:06:23 <warpy> hey guys! can you help me with this issue with state monad: http://stackoverflow.com/questions/7652155/runstate-inside-a-state-monadic-function-not-working
10:06:26 <Aatch> I was hoping that sepBy1 would cause some sort of error though...
10:06:36 <ion> edwardk: Ah, thanks for the idea. A proxy type should be useful.
10:06:53 <edwardk_> not sure what the last thing you saw from me was
10:06:58 <edwardk_> it started eating my text
10:07:21 <wavewave> Aatch: Hmm your case is at the wrong place in fact.
10:07:31 <wavewave> Aatch: I mean in 'code'
10:07:45 <dmwit> Aatch: If you want an error when it doesn't consume the entire string, your top-level parser should end by calling the "eof" parser.
10:08:17 <wavewave> Aatch: basically, your code cause parsing error. that must be outside of your CharParser
10:08:34 <wavewave> so   in fact somewhere outside cmdParser
10:08:41 <Aatch> I think I get it..
10:08:46 <wavewave> Aatch: you can catch the error.
10:08:58 <ion> edwardk: “use a data Proxy a or some such which avoids the risk of undefined” was the last line.
10:09:01 <wavewave> your putCodeStr is a kind of parser inside a parser.
10:09:28 <wavewave> Aatch: but parsec already raise the error so it didn't hit your case statement in code.
10:09:31 <edwardk> ion: there is one in the 'tagged' package
10:09:50 <wavewave> Aatch: that's why you didn't have Right or Left kind of thing for that bug.
10:09:57 <ion> edwardk: Thanks
10:09:58 <Cale> warpy: Well, aside from what's actually going wrong with that code, it's very stylistically weird to be using runState in the middle of your computation
10:10:22 <edwardk> ion: you can make floatRadixProxy :: RealFloat a => Proxy a -> Integer, etc
10:10:28 <wavewave> Aatch: is it now understood?
10:10:33 <Cale> warpy: The whole point of the state monad is to avoid wiring up the state parameters by hand, and you've essentially elected to do it anyway :)
10:10:38 <Aatch> I think so
10:10:53 <Aatch> I picked up Haskell about 2-3 days ago
10:11:04 <Aatch> This is actually the first thing I've tried to write with it.
10:11:08 <Cale> (so you'd almost be better off in this case working with functions s -> (s,a) by hand)
10:11:18 <warpy> Cale: yes i feel so too, but i am just starting up in haskell and i could think of a better way to do so
10:11:22 <Cale> but we can probably avoid runState altogether
10:11:27 <warpy> cpuldnt*
10:11:30 <Cale> apart from the one at the top level :)
10:11:40 <warpy> how? please explaing
10:11:48 <wavewave> Aatch: very nice work in only three days. You wil definitely enjoy haskell programming ;-)
10:12:15 <Cale> Okay, so doAction GoForward cleaner :: State Grid Cleaner, yeah?
10:12:21 <edwardk> the good thing about programming with a -> (a, s) -style functions by hand is that once you grok state it's easy to go through and swap out for do sugar, and that helps monad click that much better
10:12:22 <wavewave> Aatch: parsec is a little bit hard at first since it is on top of many abstraction.
10:12:42 <warpy> Cale: ya
10:12:49 <Aatch> yeah, I noticed that when inspecting types in GHCi
10:12:54 <Cale> Oh, I see the problem.
10:13:11 <Cale> We're now in StateT Grid RandomState
10:13:22 <Cale> But you want to run a State Grid computation
10:13:33 <wavewave> Aatch: but try your best to grok parsec as much as possible.. actually I myself learn haskell a lot from use of parsec.
10:13:43 <warpy> yes. two state monads, one with Grid and another with StdGen
10:14:15 <Aatch> Its basically how I learn. Throw myself in the deep end
10:14:25 <tac-tics> Parsec is one of the "killer apps" of Haskell
10:14:50 <Aatch> though having #haskell as a lifeguard helps.
10:15:13 <wavewave> it's a typical powerful case of programming in denotational semantics
10:15:18 <Cale> (I kind of think this design is really awkward... we could avoid StateT altogether, if we just paired the two states together, but we can continue on this route, I guess...)
10:15:30 * edwardk has a visual of Aatch wearing a Cale-shaped pair of water-wings.
10:15:39 <Cale> rofl
10:15:40 <warpy> Cale: first of all, why does it get stuck at the runState line?
10:15:40 <Aatch> lol
10:15:41 <Twey> Heh
10:16:19 <warpy> Cale: i followed the article at http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html
10:16:21 <Cale> warpy: I'm pretty sure it doesn't really get stuck on that line
10:16:27 <wavewave> I need to run to a seminar now. See you guys.
10:16:32 <Cale> warpy: Because that line doesn't actually *do* anything
10:16:36 <Cale> It just declares a value
10:17:14 <warpy> but isnt runState supposed to run the stateful computation?
10:17:17 <ion> edwardk: Thanks. https://gist.github.com/1188115
10:17:24 <Cale> Yes, but only when you compute its value :)
10:17:40 <Cale> let doesn't cause any evaluation to occur
10:17:45 <Cale> it only defines things
10:17:56 <warpy> so how do i do it?
10:18:06 <Cale> So while it might get stuck on the 'put'
10:18:14 <Cale> it's not going to get stuck on the let
10:18:26 <warpy> how do i call "doAction GoForward cleaner" and get cleaner
10:18:38 * tac-tics wonders what a lazy Rube Goldberg machine would look like
10:18:44 <warpy> i tried various things but they kept throwing errors
10:18:47 <Cale> Let's reorganise things a bit if you don't mind...
10:18:54 <warpy> sure
10:19:05 <Twey> tac-tics: It would move really slowly, & you'd build bits on as the motion got to them
10:19:38 <edwardk> you can use unproxy and untagged to implement fixP
10:19:48 <warpy> Cale: except i dont want to modify the functions in the supporting code section
10:20:01 <Cale> warpy: hmm
10:20:08 <Cale> warpy: It would be easiest if we could.
10:20:29 <Cale> and we don't have to change them all that much :)
10:20:51 <warpy> doAction is used elsewhere too. and it seems pretty straightforward too
10:20:55 <tac-tics> It'd be like, you want coffee... therefore, the steel ball fell onto the ON button, therefore, the steel ball was hit by the egg timer, therefor the egg timer started to countdown, therefore, a sandbag landed on the trigger for the egg timer, therefore, the wire holding the sandbag was cut by a pair of scissors, etc etc
10:21:40 <warpy> Cale: also, the random grid is in only in one problem. rest have a static grid. so changing doaction to contain randomness does not make sense
10:22:03 <warpy> you can change chooseAction if you want
10:22:47 <monochrom> "let (cleaner, grid) = runState (doAction GoForward cleaner) grid" is an unintended recursion
10:22:50 <Cale> warpy: Well, one way to characterise the problem is that doAction doesn't work in an arbitrary state monad where there's a Grid state, it only works in State Grid
10:23:06 <Cale> warpy: So in particular, it doesn't work in StateT Grid m
10:23:19 <monochrom> similarly "let (action, gen) = blah blah gen" etc
10:23:27 <warpy> Cale: so is there a way to write a wrapper function to make it work?
10:23:32 <Cale> warpy: However, because it's written to work in State Grid, the inferred type for it is probably more general than the type you gave.
10:23:48 <Cale> We could make a wrapper function, but it's probably easier to just replace the type signature
10:24:00 <Cale> With:
10:24:01 <warpy> with what?
10:24:19 <Cale> doAction :: (MonadState Grid m) => Action -> Cleaner -> m Cleaner
10:24:52 <ion> edwardk: Thanks. Used fixP = untagSelf . unproxy
10:24:59 <warpy> Cale: that is more generic than the current one, right?
10:25:02 <Cale> yes
10:25:17 <warpy> ok. then how to i call it?
10:25:26 <Aatch> One more question, how can I get Parsec to catch the Exception prelude.read
10:25:33 <edwardk> ion: sounds right
10:25:46 <Cale> Now you can just   cleaner' <- doAction GoForward cleaner
10:25:49 <Aatch> since wrapping the call in try doesn't seem to do it
10:26:04 <Cale> (please don't shadow the definition of cleaner like you are -- it's valid, but confusing)
10:26:15 <monochrom> can't catch exceptions in Parsec. don't use read. use reads and your own pattern matching
10:26:29 <warpy> Cale: i see. let me make the changes and see if it works
10:26:44 <Cale> Now you won't have to get and put the grid all over the place :)
10:27:07 <Aatch> Ok, so how do I represent a failed match in Pattern matching? fail?
10:27:07 <dafis> Aatch: you can't (not cleanly), use reads instead of read
10:27:13 <Cale> also, for chooseAction, you just want to use lift
10:27:17 <Cale> So:
10:27:25 <Cale> action <- lift (chooseAction (head ph))
10:27:34 <warpy> cool!
10:27:36 <monochrom> do you know what reads does?
10:27:56 <Aatch> yes, I was using it before.
10:28:02 <Cale> If m is any monad, and t is any monad transformer, then lift :: m a -> t m a
10:28:08 <warpy> Cale: so i can get rid of all put gen and put grid, right?
10:28:22 <Cale> Here, StateT Grid is a monad transformer, and RandomState is a monad, so we have:
10:28:34 <Cale> lift :: RandomState a -> StateT Grid RandomState a
10:28:38 <Cale> yeah
10:28:44 <Cale> and all your gets too :)
10:28:47 * hackagebot statistics-linreg 0.2 - Linear regression between two samples, based on the 'statistics' package  http://hackage.haskell.org/package/statistics-linreg-0.2 (AlpMestanogullari)
10:29:06 <monochrom> then I don't understand the question
10:29:06 <Aatch> It returns a list of tuples, the first element of the tuple is the suggested value, and the second element is the rest of the string
10:29:20 <Cale> Which is really how it should be. You should avoid using get and put directly as much as possible.
10:29:43 <Cale> and instead build up a library of things for interacting with your state in well-formed ways
10:29:51 <rostayob> if i want a list with existentially quantified types ([forall a. Show a => a]), is wrapping the inner type in a separate existential type the only solution?
10:30:12 <Cale> rostayob: That wouldn't be an existential...
10:30:45 <Cale> rostayob: That type you wrote means that it's a list of polymorphic values, each of which could be any Show-able type.
10:30:53 <rostayob> Cale: yes, that's what i mean
10:30:56 <warpy> Cale: making the changes. give me few minutes
10:30:58 <Cale> It's not though :)
10:31:03 <rostayob> Cale: what is it called :P?
10:31:11 <monochrom> "data X = forall a. Show a => Ctor a" and the list has type [X]
10:31:20 <rostayob> monochrom: that's what i'm doing now
10:31:21 <Cale> That means that if I take the head of that list, I can treat it as a Char if I want, or I can treat it as an Integer
10:31:27 <monochrom> that's the only way
10:31:28 <rostayob> is there a less clumsy way to do it?
10:31:29 <rostayob> ok
10:31:30 <Cale> It's up to me what type it is.
10:31:32 <rostayob> thanks
10:31:53 <Cale> You want [exists a. Show a => a]
10:32:10 <Cale> (or, to be more accurate, we can use ski's notation:  [exists a. Show a *> a]
10:32:12 <Cale> )
10:32:17 <monochrom> less clumsy way is to solve the XY Problem and remove any reason to use an existential type to begin with
10:32:36 <rostayob> monochrom: well it fits really nicely in my case
10:32:43 <tac-tics> monochrom: Why don't you like existential types?
10:32:46 <Cale> That is, you want a list of values so that for each of them there is some type a, and a typeclass dictionary for Show for that type
10:33:02 <monochrom> oh I like them
10:33:08 <Cale> (they have a specific, unspecified type, not a polymorphic type)
10:33:21 <rostayob> a specific, unspecified type?
10:33:38 <Cale> rostayob: Yeah, because there aren't many values of type  forall a. Show a => a
10:33:46 <Cale> In particular, there's undefined and that's it.
10:33:59 <Cale> So you couldn't possibly want that
10:34:18 <tac-tics> @type "a" :: forall a. Show a => a
10:34:19 <lambdabot>     Couldn't match expected type `a' against inferred type `[Char]'
10:34:19 <lambdabot>       `a' is a rigid type variable bound by
10:34:20 <lambdabot>           an expression type signature at <interactive>:1:14
10:34:44 <Cale> forall a. Show a => a means that for *any* type a of my choosing, I can treat your value as having that type, so long as there's a Show instance for that type
10:35:13 <rostayob> Cale: yep that's what i want - and that's what i have right now, data Foo = forall a. Show a => Foo a, [Foo a]
10:35:24 <rostayob> the thing is that I need a list of that kind only once
10:35:35 <rostayob> so having that had-hoc type is kind of ugly
10:35:37 <Cale> So, for example, there's a Show instance for Char, and there's a Show instance for Integer, and so I can decide that I want to treat the same value as both an Integer and a Char at different times if I want.
10:35:47 <rostayob> Cale: mhm....
10:35:47 <Cale> But there are no values which are like that.
10:35:51 <Cale> except undefined
10:35:56 <Cale> and other nonterminating things
10:36:01 <warpy> Cale: i get this error after i made the changes you suggested: Couldn't match expected type `m' against inferred type `State Grid'
10:36:01 <warpy>       `m' is a rigid type variable bound by
10:36:01 <warpy>           the type signature for `doAction' at vacuum.hs:108:29
10:36:04 <ziman> if you write instance Show Void, it's immediately clear. :)
10:36:17 <monochrom> an existential type could contain any type. *any* type. a forall type could become any type. *any* type. (sarcasm on thinking that emphasizing "any" makes it any clearer. *any* clearer! see my http://www.vex.net/~trebla/weblog/any-all-some.html )
10:36:23 <Cale> warpy: hmm, can you put the code on hpaste.org?
10:36:49 <dafis> rostayob: if it's Show, all you can do with the values is calling show* on it, so you could directly use [String]
10:36:59 <Cale> monochrom: lol
10:37:02 <warpy> the whole code?
10:37:09 <Cale> warpy: If you would.
10:37:28 <rostayob> dafis: no it's not show, I have data ClassOption c = forall o. HasOption c o => ClassOption o
10:37:33 <Cale> warpy: You could also just paste the complete definition of doAction, I guess.
10:38:04 <rostayob> and then I have [ClassOption c] in a type signature
10:38:04 <dafis> rostayob: more than one method, I suppose?
10:38:15 <rostayob> dafis: no methods at all, it's a marker class
10:38:33 <Cale> warpy: It's saying that something inside the definition of doAction is forcing it to be State and not just any State monad. Did you use the State data constructor explicitly?
10:38:47 <hpaste_> warpy pasted “doAction” at http://hpaste.org/52141
10:39:01 <Cale> ah
10:39:19 <Cale> Now can I see the definitions of moveForward, turnRight and turnLeft?
10:40:04 <Cale> Probably they have type signatures which are forcing them to be in State Grid again
10:40:22 <Cale> rather than being polymorphic
10:40:34 <lysgaard> Haskell is known for new thinking. Does there exist some new thinking web-frameworks. Continuations maybe?
10:40:45 <hpaste_> warpy pasted “AI.Vacuum” at http://hpaste.org/52142
10:41:04 <warpy> Cale: i pasted the whole file
10:41:23 <Cale> warpy: Okay, so the problem is what I said
10:41:58 <Cale> warpy:  turnRight :: (MonadState Grid m) => Cleaner -> State Grid Cleaner
10:42:00 <Cale> though...
10:42:16 <Cale> You're almost better off with
10:42:27 <Cale> turnRight :: (Monad m) => Cleaner -> m Cleaner
10:42:36 <Cale> or even, if you remove the return
10:42:37 * warpy makes the changes
10:42:42 <Cale> turnRight :: Cleaner -> Cleaner
10:42:57 <Cale> There's nothing stateful about those functions
10:43:24 <Cale> they don't need access to the current state of the Grid, so there's no need to say that they have it in their types
10:43:36 <warpy> \o/ it worked
10:43:44 <warpy> at least the compilation
10:45:06 <warpy> Cale: it is working now! thanks a lot
10:45:10 <Cale> no problem
10:45:24 <tac-tics> warpy: And now you're a slightly better plumber
10:45:25 <warpy> but my chooseAction logic is flawed :(
10:45:33 <warpy> i'll work on it tomorrow morning
10:45:55 <warpy> tac-tics: that's all i ever wanted to be!
10:46:37 <antihoax> hiii
10:46:39 <warpy> Cale: can you explain in short, what do this change did : (MonadState Grid m) => Action -> Cleaner -> m Cleaner
10:46:53 <warpy> and how did it solve my problem
10:47:38 <Cale> warpy: The real types of get and put don't have State s in them. The functions get and put are part of a typeclass for monads that support those operations, called MonadState
10:47:50 <Cale> class MonadState s m where
10:47:54 <Cale>   get :: m s
10:47:59 <Cale>   put :: s -> m ()
10:48:08 <warpy> ok. and ..
10:48:16 <Cale> actually, there's also a functional dependency which I missed:
10:48:21 <Cale> class MonadState s m | m -> s where
10:48:29 <Cale> (there's at most one s for any type m)
10:48:37 <Cale> but yeah
10:48:44 <tac-tics> Cale: I remember hearing a long time ago that Functional Dependencies can be expressed as GADTs. Is that so?
10:48:51 <Cale> oh, and it's also a subclass of Monad:
10:48:56 <Cale> class (Monad m) => MonadState s m | m -> s where
10:49:00 <Cale> there we go :)
10:49:11 <Cale> tac-tics: I don't know how, if it's true
10:49:19 <warpy> i am not sure how this solved my problem
10:49:26 * warpy is a noob
10:49:29 <tromp> :t foldr
10:49:30 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:49:31 <Cale> warpy: Okay, so there's an instance of this class for State s
10:49:35 <Cale> specifically:
10:49:43 <dmwit> tac-tics: Perhaps you're thinking of type families.
10:49:54 <Cale> instance MonadState s (State s) where
10:49:59 <Cale>   get = ...
10:50:02 <Cale>   put = ...
10:50:12 <warpy> ok
10:50:17 <Cale> but there's also an instance for StateT
10:50:32 <Cale> instance (Monad m) => MonadState s (StateT s m) where
10:50:48 <dmwit> tac-tics: e.g. class Monad m => MonadState m where type StateOf m; get :: m (StateOf m); put :: StateOf m -> m ()
10:50:55 <Cale> This second instance is the one we want to be using with StateT
10:51:40 <Cale> But of course, your operations didn't use anything special about State Grid, apart from the fact that State Grid supports these get and put operations
10:51:51 <warpy> Cale: so we made the doAction flexible enough to work with any MonadState and it picked the right get function, right?
10:51:53 <Cale> So we can generalise their type
10:51:56 <Cale> yeah
10:52:04 <antihoax> hi
10:52:06 <warpy> it makes sense now
10:52:11 <ion> saizan: Thanks to input from edwardk, a more elegant version of the alternative-to-ScopedTypeVariables fix: fixP :: (Proxy a -> a) -> a; fixP = untagSelf . unproxy
10:52:39 <Cale> antihoax: hello
10:52:42 <warpy> Cale: but i had to add -XFlexibleContexts to ghci
10:52:46 * monochrom doesn't like to generalize so early
10:53:02 <antihoax> whats up?
10:53:02 <Saizan> ion: ah, yeah, Proxy is nice
10:53:04 <Cale> warpy: Oh, yes. That's a totally uncontroversial extension.
10:53:23 <Cale> warpy: You're probably better off adding {-# LANGUAGE FlexibleContexts #-} to the top of the file
10:53:32 <warpy> i see
10:53:45 <tac-tics> lol, is there a list of extensions and their corresponding controversialities somewhere?
10:54:04 <Cale> In fact, for years, GHC didn't even have a name for that extension, and just provided it with no additional flags.
10:54:12 <rahul_> Hi everyone. I have a series of computations. If any one of those fails, the result of entire computation is a failure. However on failure, I have to continue with the remaining computations in the series collecting the errors. What should I be using in this case?
10:54:36 <antihoax> successfully uninstalled 2 rootkits
10:54:49 <ion> antihoax: There’s no such thing except for a complete reinstall from scratch.
10:54:53 <Cale> antihoax: But are you sure that you really uninstalled them?
10:54:59 <antihoax> yep
10:55:00 <tac-tics> rahul_: What do you pass to the remaining computations if there's a failure?
10:55:03 <Reisen> How can I tell if a function is tail recursive?
10:55:06 <Cale> antihoax: How do you know?
10:55:11 <dmwit> rahul_: After a failed computation, what input do you plan on passing the remaining computations?
10:55:17 <antihoax> did wireshark
10:55:21 <dmwit> tac-tics++
10:55:24 <antihoax> and lsof
10:55:38 <ion> Oh yeah, lsof is definitely to be trusted on a compromised system.
10:55:46 <xil> hello. I'm reading up on Gtk2Hs and it says that it's a library BASED on Gtk+. Does that mean that it is not a binding to the C libraries, but a separate library entirely? So if my C libraries are updated then it won't change anything about my Haskell program, except indirectly by resulting in an update to Gtk2Hs
10:55:48 <antihoax> and reinstalled many systemtools
10:56:00 <rahul__> Sorry I was disconnected. Here is my question again:
10:56:01 <ion> Oh yeah, a package manager is definitely to be trusted on a compromised system.
10:56:01 <rahul__> Hi everyone. I have a series of computations. If any one of those fails, the result of entire computation is a failure. However on failure, I have to continue with the remaining computations in the series collecting the errors. What should I be using in this case?
10:56:03 <FUZxxl> What can I use to get beautiful formatting of Haskell code in (Xe)LaTeX?
10:56:07 <monochrom> why do we care what someone else's rootkit did to someone else's computer?
10:56:10 <dmwit> xil: gtk2hs is a binding to Gtk+.
10:56:10 <antihoax> hehe
10:56:12 <warpy> Cale: thanks a lot. i learned a lot today. i'll read up more about these tomorrow
10:56:39 <Cale> antihoax: Once your system is rootkitted, you can't trust anything, including anything which downloads files, or the compiler.
10:56:41 <xil> dmwit: great. Thank you. To be honest, I don't really know why that's a better thing, but I get the impression that it's better
10:56:46 <antihoax> well dcleaned up the crond and autostarts
10:56:54 <antihoax> rebooted
10:56:57 <tac-tics> rahul_: When you fail, what do you pass to the remaining computations?
10:57:15 <Cale> warpy: great :)
10:57:22 <tac-tics> rahul_: What do you expect as a result to something like:  1 + 0 / 0
10:57:32 <antihoax> even cp mv top ps pstree utils were altered...
10:57:57 <Cale> warpy: To be honest, I don't really like StateT, and I think most of its uses are excessive, with a few exceptions. Notably, StateT s [] is a really nice monad sometimes.
10:58:13 <Cale> warpy: This one isn't *so* bad, but StateT over State is a little funny :)
10:58:55 <antihoax> ion<< well i have found dome things inside a .jpg file that is a .tgz file...
10:59:00 <Cale> A lot of people end up with things like StateT s IO, which I think is usually just awkward.
10:59:28 <antihoax> it even had a hide function
10:59:52 <Reisen> Don't mean to push, but what is the best way to tell if a function is tail recursive?
11:00:16 <rahul__> tac-tics: Say I have a list of strings I have to convert to integers.
11:00:20 <Cale> Reisen: This is #haskell, we don't care if functions are tail recursive! :)
11:00:36 <rahul__> tac-tics: If there is any string that cannot be converted to integer, the result of computation is a failure.
11:00:50 <dmwit> Reisen: Tail-recursive-ness isn't necessarily a good thing in Haskell. But to answer your question: just check if the outer-most function call is the same as the function you're defining.
11:00:50 <dainanaki> What's the useful distinction between TVars and TMVars? Why would I want to use one over the other?
11:00:55 <Reisen> Cale, ok, why not?
11:01:16 <rahul__> tac-tics: However I have to continue parsing to the end of the list, because I am supposed to collect all erroneous cases in the list (in case of failure).
11:01:18 <Cale> Reisen: because a lazy evaluator evaluates expressions in the opposite order from a strict evaluator
11:01:20 <Reisen> dmwit, ah ok
11:01:26 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml for why tail recursion is irrelevant.
11:01:32 <Cale> and doesn't have a call stack
11:01:32 <tac-tics> rahul__: Sounds like you want a function like [a] -> (a -> Maybe b) -> [Either ErrorType b]
11:01:49 <Cale> So "tail recursion optimisation" is completely meaningless.
11:01:59 <Cale> because there's no call stack entry to elide
11:02:04 <dmwit> rahul__: In that case, just plain Either sounds perfect for you.
11:02:08 <Reisen> Cale, I'm a little confused, is there any chance you could give a short example to explain?
11:02:13 <Cale> Sure
11:02:20 <Cale> So, in a strict language, when you write:
11:02:23 <Cale> f (g x)
11:02:30 <dmwit> rahul__: map :: (String -> Either Error Int) -> [String] -> [Either Error Int]
11:02:32 <Cale> The evaluator will evaluate g x first
11:02:34 <rahul__> tac-tics: [a] -> (a -> Either a b) -> (Either [a] [b])
11:02:37 <Cale> and then pass the result of that to f
11:02:49 <tac-tics> rahul__: yeah, something like that
11:02:51 <Cale> f will wait on a stack for the pending result
11:02:54 <Cale> yes?
11:03:07 <Reisen> yes
11:03:11 <dmwit> rahul__: That type looks very suspect to me.
11:03:22 <antihoax> ion<< the funny part was the thing didn't let me delete its files as root ...
11:03:22 <Cale> In a lazy evaluator, f is evaluated first
11:03:25 <dmwit> rahul__: [a] -> (a -> Either b c) -> [Either b c] -- looks much better
11:03:26 <rahul__> dmwit: Maybe I wrote something wrong :/
11:03:33 <Cale> and it is passed the expression g x, unevaluated.
11:03:34 <dmwit> rahul__: [a] -> (a -> Either b c) -> ([b], [c]) -- or this
11:03:38 <dmwit> rahul__: e.g.:
11:03:41 <tac-tics> rahul__: err, yeah, you want a list of eithers, not an either of lists
11:03:46 <dmwit> :t \f -> partitionEithers . map f
11:03:47 <lambdabot> forall a b a1. (a1 -> Either a b) -> [a1] -> ([a], [b])
11:03:50 <rahul__> dmwit: Yes, correct.
11:04:02 <Cale> There is no call stack.
11:04:24 <Cale> Now, you might say "But I got a stack overflow in GHC!"
11:04:35 <Cale> But the stack which is being referred to there is not a call stack
11:04:37 <dmwit> rahul__: So, yes, the [Either b c] variant is just plain "map", and the ([b], [c]) is a map, then a partitionEithers.
11:04:41 * antihoax "frying rice ; cooking rice"
11:04:42 <Reisen> I'm assuming that's from all the lazy code being stored to be evaluated
11:04:43 <antihoax> :)
11:04:47 <dmwit> gotta run
11:05:09 <rahul__> dmwit: That seems to do the job. Thanks!
11:05:10 <Cale> It is a stack consisting of pattern matches (case expressions) which are waiting for their scrutinee to be sufficiently evaluated to be able to pattern match.
11:05:24 <antihoax> is this safe as root?  /usr/local/sbin/named -t "/var/named"
11:05:29 <Cale> So, not a call stack, but a case stack. :)
11:06:00 <Reisen> Hang on, just want to go and play with haskell a minute while I take this in, thanks Cale
11:06:06 <Cale> Reisen: In fact, under lazy evaluation, "tail recursion" can often backfire
11:06:19 <rahul__> dmwit: There is one problem. After first failure, I no more need to collect results that do not lead to failure.
11:06:38 <Cale> Reisen: For example, foldl will do nothing except to call itself immediately with new parameters, until the end of the list is reached
11:06:43 <mux> Cale: is this runtime evaluation model you're talking about actually Haskell or just GHC? Even if we'd always implement it that way
11:07:03 <monochrom> it's also Hugs's model
11:07:07 <Cale> mux: Well, the Haskell spec doesn't say anything about evaluation models at all.
11:07:13 <mux> (not the non-strictness, abstract bit of course)
11:07:21 <mux> Cale: alright that's what I thought
11:07:22 <Cale> mux: It only says what programs should mean, not how they get their results.
11:07:57 <Cale> But in practice, lazy evaluation is pretty close to what things actually do. GHC isn't really a lazy evaluator, and will evaluate some things strictly.
11:08:03 <Cale> But it's pretty close.
11:08:44 <Reisen> Cale, about foldl, where exactly does tail recursion backfire?
11:08:55 <Cale> Right, I was in the middle of explaining that :)
11:08:58 <Cale> let's evaluate:
11:09:05 <Cale> @src foldl
11:09:06 <lambdabot> foldl f z []     = z
11:09:06 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:09:10 <Cale> foldl (+) 0 [1,2,3]
11:09:20 <Cale> -> foldl (+) (0 + 1) [2,3]
11:09:27 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
11:09:34 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
11:09:47 <Cale> No stack up to this point, but we're building up a big expression
11:09:59 <Cale> -> ((0 + 1) + 2) + 3
11:10:14 <Cale> Now we need to evaluate this expression. It goes outermost first too.
11:10:26 <Cale> But the outermost + can't evaluate yet
11:10:32 <Cale> (at least with Integer)
11:10:41 <Cale> because it needs to know both its parameters
11:10:46 <Cale> (it "pattern matches" them)
11:10:52 <tac-tics> Cale: (+ can't evaluate at that point, but it still CHECKS that = spends times to figure that out, yeah?)
11:11:02 <Cale> yeah
11:11:11 <Cale> Well, in our mental model of things at least, it does
11:11:18 <Cale> I don't know about GHC :)
11:11:41 <Cale> Well, actually I do. In GHC it depends on how many optimisations are turned on :)
11:11:53 <monochrom> GHC-generated machine code checks too
11:12:20 <Cale> So the pattern match on the left parameter to (...) + 3 goes on a stack
11:12:27 <Cale> and we proceed with (0 + 1) + 2
11:12:50 <Cale> which again the outermost + can't evaluate right away, because (0 + 1) isn't evaluated enough to match yet
11:13:00 <Cale> So that goes on a stack as well
11:13:13 <Cale> and now finally we get to 0 + 1, and that evaluates to 1
11:13:19 <Cale> and then 1 + 2 evaluates to 3
11:13:25 <Cale> and then 3 + 3 evaluates to 6
11:13:45 <Reisen> Ah, that makes things a lot clearer
11:13:56 <Cale> Now, if our list had been millions of elements long, we get a giant stack evaluating the resulting huge expression.
11:14:05 <Reisen> I still wasn't sure about the lack of a call stack before
11:14:14 <Cale> It's not the fault of foldl per-se -- foldl didn't use any stack at all
11:14:35 <Cale> It's (+)'s fault for pattern matching
11:14:45 <Cale> but of course, (+) has to do that
11:15:05 <Cale> So we can avoid the problem of having this giant expression by forcing some evaluation as we walk down the list with foldl
11:15:10 <Cale> @src foldl'
11:15:11 <lambdabot> foldl' f a []     = a
11:15:11 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:15:16 <Cale> and that's what foldl' does
11:15:52 <tac-tics> And seq is only a shallow strict, right? Just enough to get the constructor tag?
11:15:55 <Reisen> Ah that's strictness right
11:15:57 <ion> > let readE str = case reads str of { (a,""):_ -> Right a; (a,err):_ -> Left ("Read failed at: " ++ show (a,err)); [] -> Left ("Read failed: " ++ show str) } in map readE ["foo", "42foo", "42", ""] :: [Either String Integer]
11:15:58 <lambdabot>   [Left "Read failed: \"foo\"",Left "Read failed at: (42,\"foo\")",Right 42,L...
11:16:03 <Cale> tac-tics: yes
11:16:19 <tac-tics> (which in the case of Integer, or whatever, is also deep)
11:16:26 <Cale> yeah
11:16:49 <monochrom> the Integer type isn't that deep to begin with
11:16:51 <Cale> seq x y will ensure that x is evaluated before the result of evaluating y can be pattern matched on
11:17:10 <Reisen> so you force (+) to not be put onto a stack right?
11:17:12 <Cale> (it results in y)
11:17:15 <tac-tics> Does that mean it's possible to create space leaks with a cleverly misengineered foldl'?
11:17:31 <tac-tics> Where the function you fold on matches against more than a shallow constructor tag?
11:17:46 <Cale> Well, just for clarity's sake, let's assume that seq x y means "evaluate x, then result in y", which it doesn't, but that's operationally easier to understand.
11:17:53 <Cale> then we get something like
11:17:56 <Cale> foldl' (+) 0 [1,2,3]
11:18:15 <Cale> -> let u = 0 + 1 in seq u (foldl' (+) u [2,3])
11:18:18 <monochrom> that's hard, but I can't say impossible yet
11:18:29 <Cale> -> let u = 1 in foldl' (+) u [2,3]
11:18:35 <Cale> -> foldl' (+) 1 [2,3]
11:18:47 <Cale> and you can see that we don't build up a large expression
11:18:51 <wavewave> tac-tics : yes, it's possible.
11:18:55 <monochrom> in fact I don't like the wording "space leak"
11:18:56 <dafis> tac-tics: foldl' (\(x,y) z -> (x+1,y+z)) (0,0) loong_list
11:19:10 <wavewave> dafis: exactly.. actually I was taking that example..
11:19:25 <dafis> wavewave: it's kind of famous
11:19:37 <Cale> Reisen: Now, for this example of addition, foldl' is probably the right thing
11:19:38 <wavewave> I was bitten by that several times.
11:19:50 <Cale> Reisen: but there's often another option available to us
11:20:04 <Cale> foldr is often better still
11:20:07 <wavewave> tac-tics: this is especially infamous because it's very easy to miss.
11:20:11 <Cale> @src foldr
11:20:11 <lambdabot> foldr f z []     = z
11:20:11 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:20:38 <wavewave> (,) has another level deeper lambda. but it is often to forget.
11:20:39 <Cale> The reason is that foldr f z applied to a nonempty list always passes control to f immediately
11:20:50 <wavewave> often easy to forget
11:21:00 <Cale> and so if f can finish, or produce part of its result without examining its second parameter
11:21:04 <Reisen> Cale, really sorry, phone rang, just catching up on your messages, I haven't been ignoring you
11:21:10 <Cale> oh, sorry :)
11:21:25 <Reisen> No don't be, just letting you know why I haven't responded so you know I haven't vanished
11:21:34 <Cale> okay
11:22:16 <Cale> So yeah, if f can produce part or all of its result without looking at its second parameter, then the recursive application of foldr may never get evaluated at all.
11:22:33 <Reisen> Cale, so about the seq x y, instead of sticking (+) on a pattern matching stack waiting for the left (...) to match, it evaluates it right there right?
11:22:46 <Cale> This means that foldr can work effectively with infinite lists, while foldl will not pass control to anything but itself until it finds the end of the list
11:23:02 <Cale> Reisen: pretty much
11:23:16 <Cale> Reisen: Though seq x y doesn't actually mean "evaluate x, then y"
11:23:24 <Reisen> Oh?
11:23:27 <Cale> The compiler is actually free to evaluate y first
11:23:42 <Cale> It just has to make sure that x is evaluated before the result of evaluating y can be used.
11:24:03 <Reisen> Ah ok, so basically the result would be the same whether the compiler decided to evaluate x first or not
11:24:06 <Reisen> seq is just an assurance
11:24:09 <wavewave> Reisen: to define the order, you need pseq
11:24:18 <paper_cc> (The compiler is free not to evaluate anything until (seq x y) is itself forced, isn't it?)
11:24:38 <Cale> yeah, and it's just enough to prevent large expressions from being evaluated in an order which requires lots of stack in this case
11:25:06 <Cale> The compiler might still build the large expression, but it won't need so much stack to evaluate it, because the seqs will tell it to evaluate the bottom first.
11:25:11 <Reisen> Cale, also if I'm understanding foldr and what you're saying
11:26:16 <Cale> (really, there's a graph in memory, and the seqs will hang on to pointers to the nodes near the leaves of that graph, allowing the evaluator to get there without building up a stack)
11:27:27 <alex-shpilkin> @seen conal
11:27:27 <lambdabot> Unknown command, try @list
11:27:28 <preflex>  conal was last seen on #haskell 20 hours, 46 minutes and 27 seconds ago, saying: oh, urg. i just noticed that LYAH reinforces the common confusion between functions and definitions. :(
11:27:32 <Reisen> Hang on, I'm a little confused by foldr, just expanding it to see
11:27:34 <Reisen> if it helps
11:28:23 <Cale> Let's look at this case:
11:28:33 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml has illustrations of foldr
11:28:38 <Cale> foldr (\x xs -> 2*x : xs) [] [1,2,3]
11:28:47 <monochrom> I'm so sorry I'm not an irc-text-wall kind of guy
11:28:52 <tarrasch> Hello, I just started to look at template haskell, I thought you could in a convenient way do $(q_anything), where q_anything :: Q a (a needs not be ~ Exp), but apperently "a" must be of type Exp?
11:29:10 <Cale> -> (\x xs -> 2*x : xs) 1 (foldr (\x xs -> 2*x : xs) [] [2,3])
11:29:21 <Cale> -> (\xs -> 2*1 : xs) (foldr (\x xs -> 2*x : xs) [] [2,3])
11:29:28 <alex-shpilkin> what's the current state of evolution of FRP? say,
11:29:32 <Cale> -> 2*1 : (foldr (\x xs -> 2*x : xs) [] [2,3])
11:29:37 <Cale> -> 2 : (foldr (\x xs -> 2*x : xs) [] [2,3])
11:29:52 <Cale> now the first element of our resulting list is available to pattern match on
11:29:59 <Cale> and we haven't touched the rest
11:30:18 <Cale> > foldr (\x xs -> 2 * x : xs) [] [1..]
11:30:19 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
11:30:27 <Cale> ^^ this even works for infinite lists
11:30:39 <Cale> > foldr (\x xs -> if even x then xs else x : xs) [] [1..]
11:30:40 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
11:30:52 <Reisen> Hang on Cale, your example is kind of hard for me to wrap my eyes around so
11:30:56 <Reisen> http://pastebin.com/9DmemBWd
11:30:58 <mauke> I have copied your paste 9DmemBWd to http://hpaste.org/52145 - pray I don't copy it any further.
11:31:24 <Reisen> This was how I tried to expand it, and I don't see how it helps, doesn't it still need the right hand side to evaluate all the way in order to evaluate the outermost?
11:31:34 <Cale> Reisen: With (+), of course, there's nothing which (+) can do without knowing its second parameter
11:31:38 <tarrasch> I thougt of I could calculate anything (IO-stuff most interesting) compile-time with $(q_something). Am I missing anything fundamental about TH?
11:31:44 <Cale> So, foldr is unhelpful in that case
11:32:43 <alex-shpilkin> what's the current state of evolution of FRP? for example, conal (seemingly) hasn't written about it for quite a long time. is Yampa with its Arrows approach the only library being developed now? [sorry for double-posting]
11:33:17 <Reisen> Ah I'm sorry Cale, then I'm finding it hard to understand, I don't want to steal all your time on this, so I'll read a bit more haskell and maybe I will be better equipped to understand in the future
11:33:32 <Cale> Reisen: well, I can spare a bit more ;)
11:33:47 <Cale> Reisen: Let's just look at the trivial case of foldr (:) []
11:33:53 <Reisen> Ok
11:34:06 <Cale> @src foldr
11:34:07 <lambdabot> foldr f z []     = z
11:34:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:34:17 <Cale> foldr (:) [] [1..]
11:34:33 <Cale> -> foldr (:) [] (1 : [2..])
11:34:47 <Cale> -> (:) 1 (foldr (:) [] [2..])
11:34:55 <Cale> But (:) is a data constructor
11:35:10 <Cale> So if there's a case expression matching on a pattern like x : xs
11:35:11 <tarrasch> Reisen, You might not know all haskell now, but I see you have a sound attitude towards learning it :)
11:35:22 <Cale> case foldr (:) [] [1..] of
11:35:24 <Cale>   [] -> ..
11:35:28 <Cale>   (x:xs) -> ...
11:35:31 <Cale> something like that
11:35:38 <Cale> then by this point in the evaluation, we're done
11:35:42 <Cale> we bind x to 1
11:35:44 <Reisen> tarrasch, thank you, I won't give up easily
11:35:47 <Cale> and xs to foldr (:) [] [2..]
11:36:03 <Cale> and proceed with the appropriate body of the case expression
11:36:19 <Cale> and only resume the foldr if we need to know what xs is
11:36:35 <Cale> (that is, if we pattern match on it using case)
11:36:39 <Reisen> Cale, ah I see, so we can get results out of that straight away, unlike with +
11:36:41 <Cale> yeah
11:36:57 <Reisen> one second then
11:37:08 <Cale> (+) will immediately "pattern match" both of its parameters
11:37:37 <Cale> so it won't get very far before the recursive foldr needs to be applied
11:37:54 <Cale> But (:) produces a result immediately (it *is* a result value)
11:38:42 <Reisen> Ok now the foldl problem makes sense, because the return of foldl is the result of foldl
11:38:49 <Reisen> It has to evaluate foldl until it has a result that isn't a function call to take things from
11:38:52 * hackagebot hamlet 0.10.3 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.10.3 (MichaelSnoyman)
11:39:05 <Cale> right
11:39:29 <Cale> The outermost thing in the result of foldl is just going to be foldl again, until the list is empty
11:39:30 <Reisen> Ok I see, is there ever a time where tail recursion is a good thing in Haskell?
11:39:41 <Reisen> Because it sounds almost like if you've written it right, lazy evaluation makes it pointless
11:39:47 <Cale> Reisen: Well, foldl' can be said to be tail recursive, and it can be a good thing
11:39:49 <wavewave> foldl = outside , foldr = inside ..
11:39:58 <Cale> wavewave: ???
11:40:04 <Cale> oh, yes
11:40:08 <Cale> In a way :)
11:40:13 <ion> foldM = in the burrito restaurant
11:40:14 <Reisen> Lost me there, outside inside?
11:40:18 <Cale> Where the recursive call is.
11:40:29 <Cale> (I guess)
11:40:30 <wavewave> Cale: oh, I am just murmuring.. that's how I remember what it is.
11:40:36 <wavewave> yes.
11:40:43 <Cale> foldr has a better characterisation
11:41:05 <Cale> foldr f z replaces each (:) in the list it is given with f, and the [] at the end, if any, with z
11:41:52 <Cale> So foldr is the 'real' one, and foldl is something more complicated :)
11:41:56 <ion> (Also, = stands for “is equal to” (and is symmetric), not “is”. :-P </nitpick>)
11:42:04 <Cale> http://cale.yi.org/share/Folds.svg -- here's a picture
11:42:19 <ion> Ah, good ol’ yi.org.
11:42:32 <wavewave> foldr f z (x:xs) = f x (foldr f z xs)   (so foldr is inside of f)    /   foldl f z (x:xs) = foldl ( f (f z x) xs)  ( so foldl is outside of f )
11:42:42 <trinithis> Is there a way to query how much memory my Haskell program is using? If it is using approx 2gb, I want to serialize the data and work with it out of core.
11:43:13 <Reisen> Cale, ah that's fantastic, the images for foldl/foldr make it easy to see now
11:43:15 <wavewave> foldl f z (x:xs) = foldl f (f z x) xs    (error in parenthesis before.)
11:43:24 <Reisen> Ok, thank you Cale
11:43:32 <ion> cale: What software was used to produce the graphs?
11:43:46 <Cale> ion: inkscape
11:43:55 <Cale> (I drew them by hand)
11:44:00 <ion> Ah, ok. Thanks.
11:46:56 <Cale> grr, people I don't know keep adding me on Google+ and I keep getting notifications about it which I don't care about.
11:47:05 <Cale> I think I'll just delete my account :P
11:47:15 <TNA-MichaelK> Is there a good way to do self generating lists?  I made a horribly inefficient solution to a Project Euler challenge and I'd like to see how I could have done it better.
11:47:45 <wavewave> x = x0 :  f x  ?
11:47:46 <Cale> TNA-MichaelK: recursion?
11:48:07 <TNA-MichaelK> "let fibon :: (Integral a) => a -> a; fibon 1 = 1; fibon 2 = 2; fibon n = fibon (n - 1) + fibon (n - 2)
11:48:07 <wavewave> f :: [a] -> [a]
11:48:07 <TNA-MichaelK> sum (filter even (map fibon [1..33])) "
11:48:35 <dafis> > let fibs = 0:1:zipWith (+) fibs (tail fibs)
11:48:36 <lambdabot>   not an expression: `let fibs = 0:1:zipWith (+) fibs (tail fibs)'
11:48:42 <dafis> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
11:48:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:49:17 <dafis> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs !! 200
11:49:18 <lambdabot>   280571172992510140037611932413038677189525
11:49:25 <tac-tics> TNA-MichaelK: Try making a list of fibs instead of a function for generating fibs
11:49:39 <wavewave> TNA-MichaelK : you basically want a solution with memoization in that case.
11:50:24 <wavewave> naive fibon has exponential call tree.
11:50:30 <TNA-MichaelK> Yes, exactly what I was looking for, I'm still learning the language, that's what I wanted to do, but I didn't know how.  I did that in Python, but didn't find the zipWith function
11:50:36 <wavewave> exponentially many.
11:50:52 <TNA-MichaelK> yeah, I could see how many operations, it was quite terrible
11:51:12 <wavewave> but if previous result is in scope of a function, then it does not calculate the same thing again.
11:51:56 <wavewave> that's why we suggest generating a list of fib sequences, not individual number only for each call.
11:52:10 <TNA-MichaelK> Right, self generating functions best not generate backwards all the way to the originating function or else you waste far too much time
11:52:28 <Cale> but see: http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.2/doc/html/src/Data-MemoCombinators.html
11:52:43 <Cale> For a handy way to memoise functions :)
11:52:50 <TNA-MichaelK> memoise?
11:53:12 <Cale> i.e. turn them into functions which remember their computed results to be used next time they are applied to the same parameter
11:53:33 <Cale> This can be achieved in a very clever way without any explicit use of mutation!
11:53:34 <wavewave> TNA-MichaelK: So you seem to understand it now.. also try to understand http://www.haskell.org/haskellwiki/Memoization
11:54:08 <Cale> You'll note that the operations in this library don't use the IO or ST monad or any mutation at all.
11:54:40 <Cale> They simply take advantage of the property that in a lazy evaluator (and GHC/Hugs/etc. in particular), parameters to a function are evaluated at most once.
11:54:49 <wavewave> TN-MichaelK: basically, memoization is remembering your call-tree in a data structure..
11:55:05 <Cale> So if we have a function Bool -> r
11:55:46 <TotoTitus> good evening
11:55:52 <wavewave> TN-MichaelK: the data structure is in scope during the computation, then the already evaluated results are not evaluated again in  haskell evaluation model
11:56:03 <Cale> well, we can write a function which memoises functions of that type, by passing h True and h False as parameters to another function which gives those results back:
11:56:14 <Cale> bool h = cond (h True) (h False)
11:56:17 <Cale>   where
11:56:23 <Cale>     cond t f True = t
11:56:33 <Cale>     cond t f False = f
11:56:48 <TotoTitus> Uhh, how could zipList be implemented in a non-recursive fashion ?
11:56:51 <wavewave> very functional and haskelly method
11:56:58 <Cale> h True and h False are parameters to cond, and so can only be evaluated at most once in any application of cond
11:58:00 <Cale> So: cond (h True) (h False) is like a version of h which remembers the results once they're computed
11:58:14 <engla> TotoTitus: is there any other way to run loops than through recursion in haskell? I don't know
11:58:23 <ion> > let zip [0,1,2,3] [4,5,6,7] = [(0,4),(1,5),(2,6),(3,7)] in zip [0,1,2,3] [4,5,6,7]
11:58:24 <lambdabot>   [(0,4),(1,5),(2,6),(3,7)]
11:58:47 <wavewave> TotoTitus: using zipWith is implemented in a non-recursive fashion or not?
11:59:31 <TotoTitus> wavewave:  uhh, as in ?
11:59:37 <TotoTitus> engla: neither do i
12:00:00 <Twey> @src zipWith
12:00:00 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:00:01 <lambdabot> zipWith _ _      _      = []
12:00:12 <Cale> engla: By using higher order functions (which maybe have recursive implementations, but you don't need to care)
12:00:16 <TNA-MichaelK> Cale: I don't quite get the mapping but I have an idea of what it does, and I saved it for later when I might better understand it, thanks.
12:00:25 <engla> Cale: well except that.
12:00:36 <Cale> engla: Then no ;)
12:00:37 <wavewave> TotoTitus: all down to lambda expression, it's always recursion.. so you need to define to what level you want.
12:00:49 <TotoTitus> i understand
12:01:03 <TotoTitus> i wanted to know if there is any low-level way to implement it without recursion
12:01:12 <TotoTitus> and there i go, i start worrying about the stack
12:01:16 <Cale> But yeah, I actually recommend avoiding recursion in Haskell when you can.
12:01:27 <Cale> Instead, use higher order functions to express things
12:01:32 <Cale> It's harder to screw up
12:01:51 <engla> TotoTitus: pattern matching is an alternative to recursion. But it's not general or practical
12:01:56 <wavewave> and also give rise to a better understanding in fact. ;-)
12:02:04 <engla> *nor
12:02:12 <TNA-MichaelK> Well, how would you solve something like summing the fib numbers below a certain number which are even then?
12:02:26 <wavewave> use filter  (< num)?
12:02:38 <TNA-MichaelK> Cale: Since the zipWith method is still recursion, right?
12:02:43 <Cale> Yeah, use  sum . takeWhile (< n) $ fibs
12:02:51 <wavewave> if you implement it using list.
12:02:57 <Cale> TNA-MichaelK: Well, in that case, it's excusable, perhaps :)
12:03:01 <wavewave> yes..  takeWhile
12:03:15 <TNA-MichaelK> This was my method " sum (filter even (map fibon [1..33])) " there's probably something a lot nicer
12:03:27 <Cale> TNA-MichaelK: But you don't need to use recursion to walk down the list of fibs and filter/takeWhile them
12:03:27 <Twey> Seems reasonable
12:03:38 <Cale> sum . filter even . takeWhile (< n) $ fibs
12:03:59 <TNA-MichaelK> is that more efficient or just better practice?
12:04:09 <Cale> the latter
12:04:15 <Cale> but it also does something a little different
12:04:18 <wavewave> TNA-MichaelK : filter (<n) is wrong. takeWhile (<n) is right. please note that.
12:04:37 <Cale> in that you said you wanted all the fibs less than n, and this determines where to stop on that condition
12:04:47 <TNA-MichaelK> wavewave: noted, thanks for pointing it out
12:04:48 <Cale> rather than just taking 33 of them and hoping for the best
12:05:28 <TNA-MichaelK> Cale: ah, right, good point
12:08:05 <TNA-MichaelK> Another question, in that implementation how does zipWith know to add the last two terms?
12:08:23 <TNA-MichaelK> (let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs) for reference
12:08:49 <wavewave> it add list to list in a sense.
12:09:15 <napping> zipWith isn't doing anything fancy there, the definition of fibs explicitly sticks on the first two terms
12:09:16 <wavewave> TNA-MichaelK : you can think you are adding a list and a list 2-shifted from original.
12:09:40 <wavewave> 0:1:x1:x2 .... + x1:x2: ....  = result
12:09:56 <wavewave> wait... the other way .
12:10:42 <wavewave> 0:1 : x1 :x2 ....   +  _ : _ : 0 : 1 : x1 : x2   = result in fact.
12:11:08 <wavewave> oh.. again wrong.
12:11:14 <luite> @hoogle lastFib
12:11:14 <lambdabot> No results found
12:11:18 <TNA-MichaelK> well, tail fibs would just take all but the last term...
12:11:20 <wavewave> what am i doing? :-(
12:11:22 <luite> oh bah it doesn't index that package
12:11:30 <trinithis> Is it a bad idea to fork ~200 threads at once in haskell?
12:11:42 <napping> nope, that's nothing
12:11:47 <wavewave> 1-shifted, not 2-shifted sorry.
12:11:49 <trinithis> cool
12:12:11 <TNA-MichaelK> wavewave: right, but I don't see how it's backwards
12:12:25 <applicative_> > let aztec = zipWith (+) `ap` tail ; fibs = 0:1: aztec fibs in take 10 fibs
12:12:26 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
12:13:06 <Cale> heh
12:13:25 <TNA-MichaelK> what is `ap` ?
12:13:47 <TNA-MichaelK> http://zvon.org/other/haskell/Outputglobal/index.html
12:13:54 <c_wraith> :t ap
12:13:55 <TNA-MichaelK> ^^^ failes
12:13:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:14:09 <Cale> In this case...
12:14:14 <wavewave> TNA-MichaelK: at the every level of n-th element.. tail fibs is 1-element off from original one. so it's seeing the last element.
12:14:18 <Cale> ap :: (e -> a -> b) -> (e -> a) -> (e -> b)
12:14:33 <Cale> ap f g x = f x (g x)
12:14:42 <Cale> (but ap is actually something more general)
12:15:18 <wavewave> think special cases later (0 and 1)    see zipWith fib (tail fib) only..
12:15:48 <luite> ah here it is. dunno why I find it funny that a package has a lastFib function :) http://hackage.haskell.org/packages/archive/gutenberg-fibonaccis/latest/doc/html/Gutenberg-Fibonaccis.html#v:lastFib
12:16:00 <ion> Yeah, that’s awesome.
12:16:15 <wavewave>  if fib = x0 : x1 : x2 : ...     then tail fib = x1 : x2 : x3 ... so zipWith (+) fib (tail fib) is x0+x1 : x1+x2 : x2+x3 : ....
12:16:42 <ion> The sauce has even more comedy value than just the documentation: http://hackage.haskell.org/packages/archive/gutenberg-fibonaccis/latest/doc/html/src/Gutenberg-Fibonaccis.html
12:17:04 <wavewave> now we need to provide the first conditions.. so we add 0 and 1  in the beginning.. the.. it's the end of the story.
12:17:39 <TNA-MichaelK> wavewave: Ahhh! I understand now, thanks.  It's not working how I thought it was working...  I thought it was doing [_,a,b, a+b] and not having to regenerate every term in the meantime.
12:18:21 <wavewave> TNA-MichaelK : you were thinking imperatively. ;-)
12:18:43 <TNA-MichaelK> Yes, you caught me, it's hard after C being my primary language ; )
12:18:46 <duaneb> hi guys
12:18:51 <duaneb> I have questions about cabal
12:18:57 <wavewave> TNA-MichaelK: just look at the definition as it is... as a real mathematical equation.
12:18:58 <duaneb> in particular, how do I get it to build c/objective-c modules?
12:19:01 <napping> Well, it doesn't recalculate terms, but that's about how it goes
12:19:07 <duaneb> I'd prefer to stick to one build system
12:19:21 <int-e> luite: heh, someone should write a program to verify that these numbers are correct :)
12:19:24 <wavewave> duaneb: you need Custom build in cabal.
12:19:26 <TNA-MichaelK> wavewave: So, the way Cale was suggesting a while ago with cond (h True)... was to further optimize what you've done?
12:19:35 <duaneb> I'd settle with cabal calling make that built the c/objective-c, but I'd prefer to do it all from cabal.
12:19:52 <dankna> duaneb: nag dcoutts to review my patches, I've been working towards what you want
12:20:02 <dankna> (I have it working for me, but it's rather complicated to set up)
12:20:04 <wavewave> TNA-MichaelK: not for optimization.  it's more generic.
12:20:09 <duaneb> yea
12:20:13 <dankna> (because of the requirement to build and install your own cabal)
12:20:31 <duaneb> ok, well in the meantime, are there any documents on custom build systems
12:20:33 <Cale> TNA-MichaelK: That library builds up a bunch of combinators which transform functions into ones that remember their results
12:20:35 <dankna> the API docs
12:20:40 <dankna> and the source code
12:20:44 <Cale> TNA-MichaelK: So we can start with the inefficient fib
12:20:47 <dankna> it's not that big a library, it should be readable, sort of
12:20:59 <Cale> TNA-MichaelK: and memoise it so that it becomes (moderately) efficient
12:21:00 <wavewave> duaneb: first change Build-Type in cabal file to Custom
12:21:11 <duaneb> wavewave: I've got there
12:21:12 <Cale> -- > fib = Memo.integral fib'
12:21:12 <Cale> -- >    where
12:21:12 <Cale> -- >    fib' 0 = 0
12:21:12 <Cale> -- >    fib' 1 = 1
12:21:12 <Cale> -- >    fib' x = fib (x-1) + fib (x-2)
12:21:16 <duaneb> but then there's this problem: http://www.haskell.org/cabal/libraries/Cabal/Distribution-PackageDescription.html#t:BuildType
12:21:18 <wavewave> duaneb: and change your Setup.lhs
12:21:34 <Cale> (note that the recursive calls call the memoised version)
12:22:42 <JoeyA> Is there a way to wait for a thread to complete?  Or should I have it throw an exception to the waiter instead?
12:22:51 <wavewave> duaneb: you need to change some hooks of simpleUserHooks
12:22:51 <int-e> phew. *Gutenberg.Fibonaccis> let fibs = 0 : 1 : zipWith (+) (tail fibs) fibs in take 1001 (tail fibs) == first1001Fibs --> True :)
12:23:48 <applicative_> trinithis: try modifying the number 503 (threads) to e.g. 50000 in the thread ring entry http://shootout.alioth.debian.org/u64q/program.php?test=threadring&lang=ghc&id=1
12:24:00 <hpc> int-e: lol
12:24:17 <Leemp> Is it recommended to install haskell on Ubuntu via compiling from source?
12:24:17 <applicative_> trinithis, it works fine, though it's not the best way of calculate n `mod` 50000
12:24:21 <int-e> hpc: well, I would not trust the source to not contain typos otherwise.
12:24:30 <applicative_> or rather, calculating
12:24:37 <tarrasch> Leemp, no
12:24:39 <Leemp> Ie: To not use ubuntu repositories
12:24:40 <wavewave> duaneb: I also suffered from lack of good tutorial for that in fact.
12:24:41 <trinithis> Alright. I'm just forking threads to concurrently lex an @ssload of files
12:25:13 <TNA-MichaelK> Cale: I think I get it now... Yeah, that's essentially how I'd be thinking if I were working in another language.  So, Memo.integral fib'... says, "Memorize fib'", right?
12:25:14 <wavewave> duaneb: In my case, I just look into some hackage package deeply.
12:25:16 <napping> You probably don't need a huge number for that
12:25:27 <duaneb> wavewave: that's what I'm doing now
12:25:54 <tarrasch> Leemp, usu Ubuntu repo if you do simple stuff (homework), otherwise download installing binary
12:26:14 <Cale> TNA-MichaelK: yeah, integral is a function which memoises any function of an integer-like parameter
12:26:23 <Leemp> tarrasch: Any idea what this means then? "cabal: cannot configure snap-0.5.4. It requires base >=4.3 && <5", i tried installing base and failed, tried installing base-4.4.0.0 and failed, so i started removing stuff once i realized cabal (from the repositories) was out of date
12:26:52 <Cale> http://en.wikipedia.org/wiki/Memoization -- explanation for no 'r'
12:26:54 <dmwit> ?tell rahul No problem. You only need evaluate the list of successes if the list of failures is empty.
12:26:55 <lambdabot> Consider it noted.
12:26:55 <JoeyA> I installed GHC 7 on Ubuntu 10.04 by downloading the haskell-platform tarball, and ghc-7.0.3-x86_64-unknown-linux.tar.bz2
12:26:56 <tarrasch> Leemp, do you have ghci from cabal?
12:27:10 <JoeyA> (Ubuntu 10.04 uses GHC 6.12, I think)
12:27:11 <tarrasch> Leemp, from repos*
12:27:15 <Leemp> (I'm very new to haskell, so pardon any obvious things)
12:27:18 <Leemp> tarrasch: Yes
12:27:31 <JoeyA> Leemp: sudo apt-get install haskell-platform
12:27:37 <duaneb> wavewave: does this look right? http://darcsden.com/scpmw/gosu/browse/Setup.hs
12:27:39 <Cale> Leemp: base can't be upgraded without replacing your ghc version
12:27:43 <Leemp> tarrasch: Well, i did, i started removing things (a bit hastily, i know heh)
12:27:46 <Leemp> Ah
12:28:08 <Cale> Leemp: It's more or less saying that you need a newer GHC
12:28:14 <Cale> to use that version of snap
12:28:16 <Leemp> JoeyA: That's probably my problem right there. I believe i installed ghci from the repo
12:28:17 <tarrasch> JoeyA, that wont help I think , that still provides old haskellplatform
12:28:17 <hpaste_> wavewave pasted “Custom cabal build example” at http://hpaste.org/52148
12:28:29 <Leemp> Ah, or not
12:28:33 <JoeyA> Does Leemp need the latest GHC?
12:28:52 <wavewave> duaneb: ah. you showed your code.
12:28:55 <JoeyA> If you don't mind waiting a week, you can install Ubuntu 11.10, which I think comes with GHC 7.
12:29:02 <duaneb> wavewave: not my code
12:29:02 <Cale> Well, 7.0.3 has base 4.3.1.0
12:29:06 <Cale> So that'll do
12:29:17 <Leemp> If the repo should work, i'll reinstall it all
12:29:27 <wavewave> see my example : http://hpaste.org/52148
12:29:50 <wavewave> I don't know why hpaste messed up coloring of my code.. hmm
12:29:58 <Leemp> Well, i'll be installing ubuntu fresh on a few machine when that comes, but in the meantime i'd like to get snap running so i can get some practice code going, while i learn haskell
12:29:59 <tarrasch> Leemp, I suggest looking at these instuctions (written by me), they apply for you aswell I believe: http://www.yesodweb.com/wiki/install-help
12:30:15 <Leemp> tarrasch: Will do, thank you
12:30:16 <JoeyA> Unless you plan on writing a high-performance web server right away, I don't think you'll need the latest and greatest GHC just yet.  I could be wrong.
12:30:22 <wavewave> duaneb: that is two files by the way.. Setup.lhs and Config.hs
12:30:39 <Leemp> I don't, not now at least. Still *very* much learning. I just want snap to run :)
12:30:43 <JoeyA> (I don't know how smoothly GHC 6.12 and its ilk work with cabal today)
12:30:50 <tarrasch> JoeyA, its simply that its easier to get stuff installing with a newer ghc
12:31:12 <JoeyA> Leemp: I'd say just install the haskell-platform package.
12:31:19 <JoeyA> In theory, installing packages with cabal might be hard.
12:31:31 <JoeyA> But you can learn an awful lot of Haskell without even touching cabal.
12:31:33 <JoeyA> That's what I did.
12:31:41 <Leemp> JoeyA: If it installs snap, that will do fine for now :)
12:31:49 <tarrasch> JoeyA, that package is also old as the ghc is in the repo
12:31:52 <duaneb> snap failed for me
12:31:57 <duaneb> I had to modify build file
12:33:03 <wavewave> duaneb: So basically you change original simpleUserHooks with your own hooks and in the hook function, you get your PackageDescription from the parameter.. then for the result of hook function, you can replace relevant part with your own addition.. in the meantime, you can compile your code.
12:33:36 <wavewave> there are many hook functions.. so you can decide where I should compile my external code.
12:33:59 <tarrasch> duaneb, sometimes packages break. If YOU fix it, it's nice towards the community to pull request your fix so everyone can benefit from it
12:34:21 <wavewave> duaneb: I found that it's not easy at all. You need to spend some time reading cabal documentation and source code...
12:34:40 <duaneb> wavewave: argh. This would be better if I weren't just learning haskell
12:34:51 <duaneb> now I need to be comfortable with the language just to build my code
12:35:20 <Leemp> JoeyA: Ok, trying platform now
12:35:36 <wavewave> duaneb: unfortunately, some necessary tools and documents are still under development.. but it gets better.. so please don't be too frustrated.
12:36:15 <wavewave> good cabal tutorial is quite urgent, I also think.
12:37:22 <wavewave> in this case, not just tutorial, but like a User's guide.
12:39:43 <cheater> hi
12:39:44 <cheater> guys
12:39:46 <wavewave> duaneb: if the problem is just a dependency problem, then it is relatively easy to fix BTW.
12:40:02 <cheater> what is that monad that allows you to abort all the functions after one that returned an empty value?
12:40:12 <cheater> or an error kind of vlaue or something like that
12:40:16 <cheater> is it the maybe monad?
12:40:28 <wavewave> yes. Maybe, Either, ErrorT
12:40:57 <wavewave> Maybe is the simplest.
12:41:11 <cheater> how do i use maybe to do that?
12:41:12 <wavewave> Either if you want to have some annotation on Failure.
12:41:16 <cheater> i created two functions in ghci
12:41:29 <cheater> f x = do return Nothing
12:41:35 <wavewave> just Nothing..
12:41:41 <wavewave> do not have to return Nothing.
12:41:54 <wavewave> because Nothing is already Maybe a type.
12:41:54 <cheater> ok
12:42:04 <cheater> let g x = do print "aaa"; reutrn (Just 2)
12:42:13 <wavewave> return Nothing will be Maybe (Maybe a) type.
12:42:15 <cheater> i did (f 0) >>= g
12:42:21 <cheater> and it printed and returned Just 2
12:42:27 <cheater> i expected g not to get called at all.
12:42:44 <rwbarton> that >>= is in the IO monad
12:42:46 <wavewave> hmm.... you are mixing IO and Maybe monad now.
12:42:48 <rwbarton> nothing to do with Maybe
12:42:58 <cheater> how do i make it be in the Maybe monad?
12:43:14 <wavewave> One way is using MaybeT
12:43:26 <cheater> and another way?
12:43:32 <wavewave> hmm but let us think easier way.
12:44:06 <applicative_> > [do {f <- Just (+); n <- Just 1; m <- Just 2 ; return (f n m)},do {f <- Just (+); n <- Just 1; m <- Nothing ; return (f n m)}]
12:44:07 <lambdabot>   [Just 3,Nothing]
12:44:28 <Leemp> JoeyA: Any thoughts? http://dpaste.com/627423/
12:44:33 <wavewave> I think he probably wants to use IO monad in the middle.
12:44:43 <JoeyA> Is there anything particularly awful about having a worker thread throw an exception to a master thread to indicate completion?
12:44:44 <Leemp> JoeyA: That's with the installation of haskall-platform
12:45:17 <cheater> applicative_: how can i do this with bind?
12:45:17 <napping> asynch exceptions are a bit strange, couldn't you just write an (T)MVar once you are done?
12:45:24 <Leemp> That's just a blurb, ofcourse
12:45:43 <wavewave> cheater: my another way is that like applicative, we can separate IO monad part from Maybe part..
12:45:51 <JoeyA> Leemp: You could try starting all over, at least as far as your home directory is concerned:
12:46:08 <wavewave> cheater: that's usually a better design.
12:46:27 <wavewave> cheater: but if you really want to use IO monad in the middle
12:46:29 <JoeyA> Leemp: mkdir cabal-throwaway && mv -i .cabal .ghc cabal-throwaway/ && cabal update && cabal install snap
12:46:44 <cheater> how can we separate them wavewave?
12:46:48 <JoeyA> That's sort of the nuclear option, though.
12:46:50 <Leemp> JoeyA: Is there something other than ~/.cabal? Because i fully deleted that (and uninstalled anything i could think of, cabal-install, ghc6, etc), before installing haskell-platform
12:46:53 <cheater> no that io monad is jsut for testing
12:46:55 <tarrasch> Leemp, I told you, haskell-platform from Ubuntu repo wont help, it only includes old stuff ...
12:46:55 <cheater> disregard
12:47:01 <JoeyA> Leemp: .ghc
12:47:12 <wavewave> cheater: ahh, in that case.. just do not use IO at all.
12:47:31 <cheater> ok
12:47:32 <wavewave> cheater: for debugging purpose, you can use Debug.Trace
12:47:37 <cheater> oh?
12:47:39 <wavewave> and trace function.
12:47:39 <JoeyA> "<napping> asynch exceptions are a bit strange, couldn't you just write an (T)MVar once you are done?" Is there a way to wait on an MVar with a timeout?
12:47:55 <Leemp> tarrasch: Sorry, two different people saying stuff, i thought his was the furthest along in the conversation :). Your link seems to start off with upgrading to ghc7 though, right?
12:47:58 <rwbarton> cheater: your example could be something like  let f x = Nothing; g x = Just (x+1) in f 0 >>= g
12:48:03 <applicative_> > Just 1 >>= \x -> Just 2 >>= \y -> Just (y + x)  -- not what cheater wants I guess
12:48:04 <lambdabot>   Just 3
12:48:05 <JoeyA> Granted, I could spawn yet another thread whose sole purpose is to send something to the MVar after N microseconds.
12:48:07 <napping> are you getting a result, or just waiting for things to finish?
12:48:14 <JoeyA> napping: Both
12:48:15 <wavewave> cheater: in fact, it's using unsafePerformIO inside. so  it's a kind of cheating. but you know.. this is just for debugging..
12:48:23 <cheater> hmm
12:48:27 <JoeyA> The worker may fail (with an exception) or succeed.
12:48:29 <cheater> how do i use trace?
12:48:40 <wavewave> trace (some string)  expression
12:48:52 <wavewave> then it shows that string before the expression.
12:48:55 <Leemp> tarrasch: So far all i can gather is that i need to either install 11.10, or build haskell from source?
12:49:00 <cheater> aha
12:49:03 <wavewave> trace (show a) $ f a
12:49:09 * ziman prefers "string" `trace` expression
12:49:11 <tarrasch> Leemp, yes, you'll definetly need new ghc for new haskell-platform (if doing haskell-platform from source)
12:49:22 <applicative_> foo n = trace "foo" (n + n)
12:49:23 <wavewave> then it shows the content of a when it calculates (f a)
12:49:38 * dafis prefers expression `debug` string, where debug = flip trace
12:49:42 <JoeyA> napping: I was thinking of having the master thread catch SomeException to handle all worker results.
12:49:47 <tarrasch> Leemp, only haskell-platform from source, and thats likely not neccesary
12:49:52 * wavewave likes dafis' solution. 
12:50:12 <dafis> definitely more comfortable to comment out
12:50:15 <cheater> is there a trace equivalent of "print"?
12:50:28 <wavewave> cheater: trace is a basic debugging technique.
12:50:36 <cheater> i mean so that i could display things such as tuples etc
12:50:38 <ziman> but I haven't used trace for a *long* time :)
12:50:40 <wavewave> cheater: it prints its first argument
12:50:43 <tarrasch> Leemp, Just install ghc via ghc homepage, like link I sent suggested
12:50:44 <cheater> oh right
12:51:00 <cheater> very obviously it does
12:51:00 <cheater> thanks
12:51:01 <wavewave> try some very simple code.
12:51:01 <tarrasch> Leemp, anyway, goodnight now :)
12:51:04 <ziman> cheater, I think there's traceShow
12:51:15 <cheater> traceShow is not it, i just needed "trace"
12:51:21 <Leemp> tarrasch: k, thank you :)
12:51:23 <applicative_> cheater, basically anything you can put parentheses around (...) you can replace with (trace "line 16 column 43" (...))
12:51:34 <napping> JoeyA: why do you need a timeout?
12:51:37 <cheater> heheh
12:51:39 <cheater> thanks app
12:51:45 <cheater> you guys are very helpful
12:52:11 <wavewave> cheater: anyway, coming back to your original question ...
12:52:25 <JoeyA> napping: It's performing a network operation that could potentially hang.
12:52:32 <cheater> original question has been answered :)
12:52:47 <cheater> i can just do Nothing >>= (Just 2) and get Nothing
12:52:47 <napping> in the server, or in the clients? In the clients, System.Timeout is perhaps closer to what you want
12:53:13 <cheater> i mean in terms of functions evaluating to those values
12:53:20 <wavewave> cheater: Good. you got that point. happy to help you! ;-)
12:53:26 <cheater> :)
12:53:35 <napping> anyway, orElse and registerDelay is the easy way to do a timeout in STM
12:53:38 <cheater> so now i have a new question
12:53:51 <cheater> how can i emulate something more complicated?
12:54:00 <cheater> i have come across this python framework called twisted web
12:54:11 <cheater> er just twisted
12:54:13 <cheater> they have those deferreds there
12:54:15 <napping> dunno about the asymptotic complexity, but you should be able to chain orElse to do a "select" over a bunch of things
12:54:21 <cheater> at first i thought it was just like the maybe monad
12:54:24 <cheater> but it's not!
12:54:30 <JoeyA> napping: Ah, thanks.
12:54:43 <JoeyA> Didn't know about System.Timeout
12:54:45 <wavewave> cheater: probably it's coroutine... I guess.
12:54:47 <napping> Also, you might get by with a simple Chan that's thrown to
12:54:53 <Leemp> On a side note, is there a haskell commandline package?
12:54:57 <cheater> wavewave: no let me finish
12:55:05 <Leemp> Eg, for creating commandline guis?
12:55:10 <cheater> basically, here you have a list of PAIRS of functions: imagine a top to bottom list in two columns, so a list of pairs basically
12:55:16 <wavewave> cheater: yep. please go ahead ;-)
12:55:21 <cheater> the left element of the pair is called the callback and the right is called the errback
12:55:49 <cheater> if the callback in a certain pair returns a normal value it gets bound to the next function
12:55:50 <cheater> and so on
12:55:52 <napping> sends to it, rather - and each client thread is wrapped in something that sends normal results in Right and catches any exception to send in Left, or something like that
12:56:05 <JoeyA> napping: System.Timeout.timeout uses exceptions internally.
12:56:24 <cheater> however if it returns an "error" type (think Nothing) then it gets put in the next pair's errback
12:56:51 <napping> hmm, well your IO should be nonblocking anyway
12:57:02 <wavewave> sounds like Either monad..
12:57:09 <cheater> similarly an errback can return an error type (say, Nothing) and it would go to the next errback as well, or it can return a normal value (think Just) and it would go to the callback on the next pairr
12:57:26 <cheater> how do i use the Either monad for that?
12:57:41 <cheater> btw, the "normal" type can be anything
12:57:45 <wavewave> cheater: trying to understand what you say now....
12:57:46 <cheater> so think of it as Just a
12:57:53 <cheater> http://twistedmatrix.com/documents/current/core/howto/defer.html
12:57:57 <cheater> look at the 2nd diagram here
12:58:04 <napping> wavewave: it also mixes in something about these being the points where you manaully CPS transform your code to fit into the event loop
12:58:55 <wavewave> cheater, napping: it's somewhat complicated.
12:59:47 <wavewave> cheater: if you want to have exactly same thing.. you need to make a little complicated code.. more like Coroutine.
12:59:51 <cheater> what is.. what twisted is doing?
13:00:00 <cheater> but this has nothing to do with coroutines
13:00:04 <cheater> it's just a list of functions
13:00:14 <cheater> the magic is in the order in which they are executed
13:00:31 <wavewave> cheater: in haskell coroutine is nothing but function with continuations.
13:00:35 <napping> JoeyA: wrapping exception delivery around a single socket call is much more controlled than getting random exceptions at random points in a listener thread
13:00:41 <cheater> aha
13:00:46 <wavewave> cheater: anyway, I am not adding any more terminology here.
13:00:54 <cheater> i thought you meant coroutine as in generator or something
13:00:58 <rwbarton> isn't  this whole setup just a weird way to get around a missing Either type constructor
13:01:03 <napping> you have to be very careful with blocking asynchronous exceptions to make sure you don't lose any
13:01:18 <rwbarton> @type either
13:01:19 <wavewave> cheater: I mentioned it because  basic pattern can be captured by that idea.
13:01:19 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:01:34 <cheater> wavewave: hmm
13:01:38 <cheater> wavewave: how would you do that?
13:01:43 <cheater> i trust you
13:01:47 <rwbarton> either callbackN errbackN . ... . either callback2 errback2 . either callback1 errback1
13:01:48 <cheater> but i don't see how
13:02:00 <napping> Anyway, it's built on the GHC.Event version which just arranges to call an IO() action at some point, and lets you cancel the callback with a key
13:02:02 <wavewave> cheater: don't trust me ;-P. but anyway. easiest way is using Either monad..
13:02:23 <wavewave> to first caption, two different cases.
13:02:34 <wavewave> s/caption/capture
13:02:40 <napping> JoeyA: also, there are socket options for setting timeouts, which might be enough for you
13:02:56 <cheater> but such chaining would mean that if an errback returns an error type then its return value gets put into the next pair's callback, not the errbak
13:03:01 <JoeyA> napping: I think I see where you're going.  I was actually planning on putting the listener's ThreadId in an MVar, so the listener can decide when it wants to receive exceptions.
13:03:08 <wavewave> Either A B : A = failure, B = success
13:03:22 <JoeyA> napping: I'm actually using http-enumerator.
13:03:43 <JoeyA> It does time out automatically at 20 seconds, but I do not want to rely on that.
13:03:59 <wavewave> cheater: you need to define a function such as 'next'
13:04:10 <cheater> yes
13:04:13 <cheater> and how does that work?
13:04:24 <cheater> i was hoping this could be done with monads *only*
13:04:28 <cheater> i do believe it can
13:05:02 <wavewave> cheater: hmm... you want to implement this using only >>= and return operator?
13:05:17 <cheater> i think it should be possible
13:05:35 <cheater> think it would be possible to bind pairs?
13:05:49 <wavewave> cheater: definitely possible. but it needs higher-order type. that's difficult at this stage.
13:06:02 <cheater> like (f, g) >>= (h, k)
13:06:18 <cheater> why is it difficult?
13:07:28 <wavewave> well.. I should say that I am currently thinking of some patterns already known. Okay.. never mind anything like that.
13:07:50 <wavewave> cheater: okay let's get back to your way.
13:08:17 <cheater> :)
13:08:20 <wavewave> define a type with two holders.
13:08:35 <cheater> yes go on
13:09:05 <wavewave> but now two results mean some 'future' computation.
13:09:16 <wavewave> result or failure.
13:11:25 <wavewave> so design it with function holders.
13:11:48 <wavewave> sounds like arrow..
13:12:47 <Kaidelong> @ty foldr
13:12:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:13:07 <Kaidelong> hmm
13:13:28 <Kaidelong> m (m a) -> ? -> m [a]
13:13:44 <Kaidelong> oh
13:14:19 <wavewave> cheater: I am trying to make a solution. some time needed. he.. ;-P
13:14:22 <RaptorRarr> Kaidelong: m (m a) -> Profit -> m [a]
13:14:33 <cheater> hmm
13:14:37 <Kaidelong> I guess you'd have to use arrows if you want to generalize foldr
13:14:41 <cheater> i think it would probably work just like the either monad
13:14:45 <rwbarton> you don't need arrows or even monads
13:14:46 <cheater> e
13:14:47 <cheater> er
13:14:51 <cheater> just like the Maybe monad
13:14:55 <cheater> let's consider this
13:14:57 <rwbarton> you have this result type Either FailureType SuccessType
13:14:58 <Kaidelong> rwbarton: You can do it with category?
13:15:02 <cheater> how is the Maybe monad built up?
13:15:20 <wavewave> rwbarton: I am thinking of iteratee like solution now.
13:15:36 <rwbarton> and callback :: SuccessType -> Either FailureType SuccessType, errback :: FailureType -> Either FailureType SuccessType
13:15:37 <monochrom> Nothing >>= blah = Nothing; Just x >>= f = f x
13:15:40 <rwbarton> yes?
13:15:42 <wavewave> rwbarton: we can split Step and Result case
13:15:50 <rwbarton> no
13:15:52 <rwbarton> all I am going to use is function composition
13:16:15 <rwbarton> I take callback and errback and I form  either errback callback :: Either FailureType SuccessType -> Either FailureType SuccessType
13:16:28 <rwbarton> and then I compose a bunch of these together using (.)
13:16:35 <wavewave> rwbarton: yeap, I just want to see how monad structure come out of this as cheater asked.
13:17:02 <wavewave> rwbarton: anyway.. let us try to think together in different ways.
13:17:53 <cheater> rwbarton: interesting
13:18:14 <cheater> rwbarton: so how would the actual code look?
13:18:44 <Kaidelong> oh
13:18:55 <Kaidelong> m (m a) -> m () -> m [a]
13:19:02 <Kaidelong> got it
13:20:09 <Kaidelong> now to see if I can implement that
13:20:46 <dafis> Kaidelong: foo _ _ = return []
13:20:50 <Kaidelong> oh of course I can't
13:20:57 <Kaidelong> well not the way I wanted to
13:22:57 <JoeyA> Does Haddock support nested bullets?
13:23:21 <Kaidelong> oh that's right. the thing I was working with isn't a covariant functor, but contravariant, so it's not actually a monad and reader works the opposite direction
13:24:07 <Kaidelong> I read in the docs that if I need ArrowApply I may as well just use monads
13:24:17 <Kaidelong> but I do not think it's going to work here because I need the input type parameter
13:24:24 <Kaidelong> and the output
13:24:40 <Kaidelong> if I want to make foldr work with things in the form (a -> IO b)
13:24:53 <Kaidelong> or well, (a -> b -> IO b)
13:25:40 <Kaidelong> @ty (>>>)
13:25:41 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
13:25:43 <tac-tics> @type liftM foldr
13:25:44 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b -> b) -> m (b -> [a] -> b)
13:25:54 <tac-tics> err something like that
13:27:01 <Kaidelong> @ty (\f x xs -> (foldr (>>>) (map f xs)) x)
13:27:02 <lambdabot>     Couldn't match expected type `cat a c' against inferred type `[b]'
13:27:02 <lambdabot>     In the second argument of `foldr', namely `(map f xs)'
13:27:02 <lambdabot>     In the expression: (foldr (>>>) (map f xs)) x
13:27:29 <Kaidelong> @ty (\f x xs -> (foldr (>>>) (returnA x) (map f xs)))
13:27:30 <lambdabot> forall (cat :: * -> * -> *) a c a1. (Control.Category.Category cat) => (a1 -> cat a a) -> cat a c -> [a1] -> cat a c
13:27:54 <Kaidelong> that doesn't look like the right type
13:30:02 <Kaidelong> @info (>>>)
13:30:03 <lambdabot> (>>>)
13:30:59 <Clint> is there no email-parsing library on hackage?
13:32:57 <Botje> @where email hates the living
13:32:57 <lambdabot> I know nothing about email.
13:32:59 <Botje> aww.
13:33:06 <mebaran151> I'm trying to play with Yesod a little bit, but I'm having trouble with the basic setup; cabal install complains about an ambiguity error on a fresh install.
13:33:32 <Kaidelong> @check (\f x xs y -> (foldr (>>>) (returnA x) (map f xs)) y == returnA x y) :: (a -> b -> b) -> b -> [a] -> b
13:33:33 <lambdabot>   Couldn't match expected type `(a -> b -> b) -> b -> [a] -> b'
13:33:47 <Kaidelong> oh
13:33:55 <Kaidelong> too polymorphic anyway
13:34:01 <Kaidelong> would have to specify types
13:34:07 <Kaidelong> for arbitrary
13:34:39 <mebaran151> Ambiguous Occurence: AppConfig, and Ambiguous Occurence appPort
13:36:17 <Kaidelong> @ty (\f x xs -> (foldr (>>>) (arr \() -> x) (map f xs)) ())
13:36:18 <lambdabot> parse error on input `\'
13:36:32 <Kaidelong> @ty (\f x xs -> (foldr (>>>) (arr (\_ -> x)) (map f xs)) ())
13:36:33 <lambdabot> forall c a. (a -> () -> ()) -> c -> [a] -> c
13:37:01 <Kaidelong> @ty foldl
13:37:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:38:27 <Clint> ah, there is
13:39:32 <Kaidelong> @ty (\f x xs -> (foldr (>=>) return (map f xs))) x)
13:39:33 <lambdabot> parse error on input `)'
13:39:41 <Kaidelong> @ty (\f x xs -> (foldr (>=>) return (map f xs)) x)
13:39:42 <lambdabot> forall (m :: * -> *) c a. (Monad m) => (a -> c -> m c) -> c -> [a] -> m c
13:39:49 <Kaidelong> yay
13:40:10 <Kaidelong> finally
13:41:04 <Kaidelong> foldr (>=>) return  looks like something you should see pretty frequently
13:42:16 <Kaidelong> @ty foldr' = (\f x xs -> (foldr (>=>) return (map f xs)) x) in foldr' (+) 0 [1..10]
13:42:17 <lambdabot> parse error on input `='
13:42:29 <Kaidelong> >let foldr' = (\f x xs -> (foldr (>=>) return (map f xs)) x) in foldr' (+) 0 [1..10]
13:42:51 <Kaidelong> > let foldr' = (\f x xs -> (foldr (>=>) return (map f xs)) x) in foldr' (+) 0 [1..10]
13:42:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
13:43:52 <Kaidelong> hmm I see, so that's a disadvantage over generalizing it to arrows
13:44:12 <Kaidelong> although I think this works for my purposes so I can stop here
13:45:23 <magicman> @type foldM
13:45:24 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:46:45 <magicman> > runIdentity $ foldM (\a b -> return (a ++ b)) "Hi" ["Banana","Shark"]
13:46:46 <lambdabot>   "HiBananaShark"
13:47:05 <magicman> > let foldr' = (\f x xs -> (foldr (>=>) return (map f xs)) x) in foldr' (\a b -> return (a ++ b)) "Hi" ["Banana","Shark"]
13:47:06 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
13:47:06 <lambdabot>    arising from a use ...
13:47:28 <magicman> > let foldr' = (\f x xs -> (foldr (>=>) return (map f xs)) x) in runIdentity $ foldr' (\a b -> return (a ++ b)) "Hi" ["Banana","Shark"]
13:47:29 <lambdabot>   "SharkBananaHi"
13:47:34 <ion> <=<
13:48:19 <magicman> *nod* Was looking at the difference between foldM and Kaidelong's foldr'.
13:50:02 <napping> JoeyA: I was thinking of Network.Socket.RecvTimeout/SendTimeout
13:50:29 <JoeyA> napping: http-enumerator doesn't expose the socket, apparently.
13:51:21 <mebaran151> is Yesod the best place to start for experimenting with Haskell Web Dev
13:52:26 <luite> mebaran151: not necessarily the best place, there are other frameworks worth checking out, you just have to choose one :)
13:55:03 <mebaran151> luite, I'm trying to get yesod running: got it installed via cabal but I'm having a little bit of difficulty just getting it to compile: complains of ambiguity errors
13:55:30 <luite> mebaran151: oh that's interesting, that same problem was reported earlier today in #yesod but I couldn't reproduce it
13:55:49 <mebaran151> I'm on windows if that changes anything
13:56:04 <luite> oh the other user was on linux, ubuntu
13:56:25 <mebaran151> surprisingly painless to get started with Haskell on windows; this is the first problem I've really encountered
13:56:49 <mebaran151> experimenting in Emacs is just as easy as working with Clojure
13:58:15 <boodie> hi all
13:58:20 <luite> mebaran151: do you use the haskell platform, latest version?
13:58:28 <mebaran151> most recent download
13:59:00 <boodie> can anybody give me a short apllication on haskell that for example prints hello world
13:59:01 <zirplio> ahhh its a wonderful day
13:59:03 <mebaran151> Haskell version 7.0.2
13:59:11 <Veinor> boodie: main = putStrLn "Hello world!"
13:59:13 <luite> mebaran151: ok, hang on, I'm going to try to install the same on my windows machine, maybe I can find the problem and commit a fix to the repository
13:59:22 <Axman6> boodie: sure, but it's not a very useful thing to show you
13:59:30 <luite> mebaran151: join #yesod if you want
13:59:47 <boodie> y?
14:00:01 <Axman6> because it doesn't show you anything about the language
14:00:10 <boodie> mmmm
14:00:24 <boodie> i got an error with the simple thing
14:00:34 <boodie> it says parse error on input
14:00:46 <boodie> '='
14:00:46 <Axman6> what did you do?
14:00:58 <boodie> ok
14:01:04 <Axman6> are you using ghci?
14:01:19 <boodie> can u give me anything that would help me to understand more about the language
14:01:36 <boodie> am using try haskell site
14:01:40 <Axman6> > map (^10) [1..10]
14:01:41 <lambdabot>   [1,1024,59049,1048576,9765625,60466176,282475249,1073741824,3486784401,1000...
14:01:47 <boodie> i dont have it download yet
14:02:01 <boodie> downloaded*
14:02:16 <zmv> boodie: read LYAH
14:02:55 <monochrom> if you're using the tryhaskell site, it already has exercises
14:03:04 <boodie> thnx axman6
14:03:15 <boodie> the map one is good
14:03:20 <boodie> can u give me moew
14:03:20 <monochrom> if you're done with all its exercises and lessons, then yeah LYAH next
14:03:22 <boodie> more
14:03:37 <boodie> n what's LYAH
14:03:40 <mebaran151> I really liked learnyouahaskell too
14:03:47 <monochrom> @where LYAH
14:03:48 <lambdabot> http://www.learnyouahaskell.com/
14:03:53 <trinithis> If I have a `class C a b`, where `a` implies `b`, is it possible to create a datatype that has only one parameter `a`, yet uses the `b` given by the class C?
14:04:12 <mebaran151> I learned to program Ruby from WhyTheLuckyStiff's Poignant Guide, so I think it's just my aesthetic sensibilities
14:04:19 <RaptorRarr> LYAH! You're a LYAH!
14:04:32 <RaptorRarr> trinithis: Maybe functional dependencies.
14:04:33 <sipa> trinithis: you want functional dependencies
14:04:43 <JoeyA> What happens if a thread receives an exception while it's executing an exception handler?
14:04:46 <sipa> or someone more intuitive (imho), associated types
14:05:08 <trinithis> I already do. I just dont want to type (MyType a b) over (MyType a)
14:05:25 <trinithis> becaise I can get b from a
14:05:40 <trinithis> I can submit some code...
14:05:43 <trinithis> will do in a sec
14:05:44 <sipa> ok, try associated types
14:05:48 <boodie> ok
14:05:56 <sipa> it allows you to put a type in the type class, and use that
14:06:13 <zmv> RaptorRarr: NO U
14:06:32 <Saizan> JoeyA: see the block/unblock primitives, catch wraps the handler in block iirc
14:07:02 <JoeyA> Saizan: block is deprecated.  Do you mean mask?  (as of GHC 7)
14:07:06 <boodie> am waiting for u, trinithis
14:07:08 <Eduard_Munteanu> mebaran151: mind Haskell might look/feel a bit more different than other (popular) languages.
14:07:13 <hpaste_> thomas pasted “implied param” at http://hpaste.org/52150
14:07:19 <trinithis> thats mine
14:07:23 <Saizan> JoeyA: my iirc was from before ghc 7 :)
14:07:38 <mebaran151> Eduard_Munteanu: I'm kind of attracted to the typedness of it; I'm a little sick of unit testing and functional testing
14:07:51 <boodie> thnx trinithis
14:08:02 <mebaran151> know Clojure too, so I thought it would be smart to branch into Haskell
14:09:21 <tac-tics> Clojure is the opposite of Haskell
14:09:32 <mebaran151> exactly :)
14:09:34 <trinithis> Actually Lleksah is
14:09:43 <mebaran151> nah, that's the reverse
14:09:47 <zmv> yeah
14:09:56 <trinithis> @let opposite = reverse
14:09:57 <lambdabot>  Defined.
14:09:59 <trinithis> haha
14:10:00 <mebaran151> I'm not sure the - operator can be properly ascribed to the domain of strings
14:10:11 <monochrom> generally, "opposite" is an ambiguous word for all kinds of involutions
14:10:22 <zmv> the opposite of haskell is unfxryy!\
14:10:40 <mebaran151> rot13?
14:11:04 <sipa> ʃʃǝʞsɐH
14:11:08 <ocharles> Fairly random question, but is there an operator that is the same as "." but with a different precedance? Mostly because I write foo . bar `fmap` whatever, but that doesn't compile due `fmap` having the same infixr as (.)
14:11:13 <Axman6> 'a' -> 'n', 'b' -> 'o', 'n' -> a'
14:11:23 <shachaf> ocharles: <$> = fmap
14:11:29 <Jafet> But . is `fmap`.
14:11:31 <ocharles> that doesn't have the same problem though?
14:11:34 <tac-tics> > oppositeOf "Haskell"
14:11:36 <lambdabot>   "Clojure"
14:11:37 <shachaf> And what Jafet said.
14:11:49 <sipa> > oppositeOf "C++"
14:11:51 <lambdabot>   "*Exception: <local>:2:0-65: Non-exhaustive patterns in function oppositeOf
14:11:53 <shachaf> Also, <$> doesn't have the same precendence.
14:11:57 <ocharles> ah
14:12:06 <Jafet> @quote C\+\+
14:12:07 <lambdabot> dforsyth says: "c++ can eat a dick imo"
14:12:25 <zmv> talking about C++
14:12:30 <zmv> @protontorpedo
14:12:30 <lambdabot> on the haskell site they compare haskell to a spreadsheet
14:12:37 <zmv> lolyeah
14:12:57 <Jafet> @forget dforsyth "c++ can eat a dick imo"
14:12:58 <lambdabot> Done.
14:13:07 <Jafet> @quote C\+\+
14:13:07 <lambdabot> qwe1234 says: c++ is the way it is for a very, very good reason.
14:13:09 <RaptorRarr> Monads are like a spreadsheet of endofunctors with...never mind.
14:13:41 <Jafet> RaptorRarr: travelling backwards in time
14:13:49 <Jafet> Mmm a spreadsheet monad
14:14:10 <hpc> it's a spreadsheet arrow
14:14:16 <hpc> everyone knows you do reactive programming with them
14:14:23 <Axman6> > let rot13 = map swap where swap x = case lookup x (zip ['a'..'z'] (['n'..'z'] ++ ['a'..'m'])) of Just y -> y; _ -> x in rot13 "hello"
14:14:24 <lambdabot>   "uryyb"
14:14:46 <sipa> > (rot13 . rot13) "hallo"
14:14:47 <lambdabot>   Not in scope: `rot13'Not in scope: `rot13'
14:15:03 <hpc> @let rot13 = map swap where swap x = case lookup x (zip ['a'..'z'] (['n'..'z'] ++ ['a'..'m'])) of Just y -> y; _ -> x
14:15:03 <lambdabot>  Defined.
14:15:14 <hpc> > rot13 . rot13 $ "ohai"
14:15:15 <lambdabot>   "ohai"
14:15:30 <hpaste_> DanBurton pasted “median” at http://hpaste.org/52151
14:15:31 <Jafet> @check ap (==) (rot13.rot13)
14:15:32 <lambdabot>   Not in scope: `rot13'Not in scope: `rot13'
14:15:49 <sipa> @check ap (==) (rot13 . rot13)
14:15:50 <lambdabot>   Not in scope: `rot13'Not in scope: `rot13'
14:16:09 <mebaran151> I'm not sure I like what I started... :)
14:16:16 <RaptorRarr> > let rot13 = map (chr . add 65 . flip mod 26 . add 12 . ord) in rot13 "hello"
14:16:17 <lambdabot>   Not in scope: `add'Not in scope: `add'
14:16:18 <tac-tics> @check let rot13 = map swap where swap x = case lookup x (zip ['a'..'z'] (['n'..'z'] ++ ['a'..'m'])) of Just y -> y; _ -> x in ap (==) (rot13 . rot13)
14:16:19 <lambdabot>   "OK, passed 500 tests."
14:16:30 <hpc> @undefine
14:16:32 <RaptorRarr> > let rot13 = map (chr . (+65) . flip mod 26 . (+12) . ord) in rot13 "hello"
14:16:32 <DanBurton> tac-tics beat me to it :)
14:16:33 <lambdabot>   "MJQQT"
14:17:06 <tac-tics> Does check only check finite examples?
14:17:21 <DanBurton> what do you guys think of my "median" code pasted above?
14:17:28 <tac-tics> @check ap (==) (reverse . reverse)
14:17:29 <lambdabot>   "OK, passed 500 tests."
14:18:23 <Jafet> check checks any arbitrary Arbitrary you write right.
14:20:03 <RaptorRarr> > let rot13 = map (chr . (+65) . flip mod 26 . (+12) . flip mod 32 . ord) in rot13 $ "hello"
14:20:04 <lambdabot>   "URYYB"
14:20:07 <DanBurton> @check \xs -> xs == (reverse . reverse) xs
14:20:08 <lambdabot>   "OK, passed 500 tests."
14:20:19 <RaptorRarr> > let rot13 = map (chr . (+65) . flip mod 26 . (+12) . flip mod 32 . ord) in take 10 $ iterate rot13 "hello"
14:20:21 <lambdabot>   ["hello","URYYB","HELLO","URYYB","HELLO","URYYB","HELLO","URYYB","HELLO","U...
14:20:22 <Jafet> @check \xs -> xs == reverse xs
14:20:23 <lambdabot>   "OK, passed 500 tests."
14:21:02 <DanBurton> :t (==>)
14:21:03 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
14:21:05 <donri> @check (<200) . length
14:21:06 <lambdabot>   "Falsifiable, after 488 tests:\n[(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
14:21:24 <Axman6> heh, that almost passed
14:21:44 <JoeyA> Saizan: I tested it.  Asynchronous exceptions are blocked in the catch handler.
14:21:49 <Jafet> @check (==) <*> sort
14:21:50 <lambdabot>   "OK, passed 500 tests."
14:22:11 <RaptorRarr> @check (\xs -> not (elem (length xs) xs))
14:22:12 <lambdabot>   "Falsifiable, after 4 tests:\n[3,-4,-4,5,-3]\n"
14:22:54 <RaptorRarr> @check (\xs -> all id . zipWith (==) [1..])
14:22:55 <lambdabot>   "Falsifiable, after 0 tests:\n()\n[0,-1]\n"
14:23:11 <RaptorRarr> @check (\xs -> not . any id . zipWith (==) [1..])
14:23:12 <lambdabot>   "Falsifiable, after 2 tests:\n()\n[0,2,-1]\n"
14:23:16 <hpaste_> “Joey Adams” pasted “Asynchronous exceptions are blocked in catch handlers” at http://hpaste.org/52152
14:23:17 <DanBurton> @check \xs -> length xs > 100 ==> sum xs > 10
14:23:18 <lambdabot>   No instance for (Test.QuickCheck.Testable
14:23:18 <lambdabot>                     (Test.QuickCh...
14:23:54 <DanBurton> kinda dropped off before saying anything useful about that error -_-
14:24:22 <DanBurton> :t \xs -> length xs > 100 ==> sum xs > 10
14:24:23 <lambdabot> forall a. (Num a, Ord a) => [a] -> Property
14:24:27 <RaptorRarr> @check length xs <= 100 || sum xs > 10
14:24:28 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
14:24:35 <RaptorRarr> @check \xs -> length xs <= 100 || sum xs > 10
14:24:36 <lambdabot>   "Falsifiable, after 240 tests:\n[15,40,115,-50,115,-6,-40,-85,-74,-75,-84,7...
14:24:54 <tac-tics> @check const False
14:24:55 <lambdabot>   "Falsifiable, after 0 tests:\n()\n"
14:25:12 <DanBurton> @check const True
14:25:13 <lambdabot>   "OK, passed 500 tests."
14:25:29 <RaptorRarr> @check \x -> (x :: Double) == x
14:25:30 <lambdabot>   "OK, passed 500 tests."
14:25:31 <tac-tics> @check \n -> n < 10000000000000
14:25:32 <lambdabot>   "OK, passed 500 tests."
14:25:35 <tac-tics> lol
14:25:35 <DanBurton> :t forall
14:25:36 <lambdabot> Not in scope: `forall'
14:25:41 <tac-tics> all numbers are tless than 100000000000000
14:25:49 <tac-tics> I proved it with science!
14:26:05 <DanBurton> tac-tics: with 500 tests ;)
14:26:07 <RaptorRarr> Science needs a few more tests.
14:26:15 <napping> mebaran151: looks like you were right about unit testing!
14:26:22 <RaptorRarr> @check (< 100000000000000000)
14:26:23 <lambdabot>   "OK, passed 500 tests."
14:26:24 <DanBurton> :t forAll
14:26:25 <lambdabot> forall a prop. (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
14:26:28 <Jafet> @check \n -> (n :: Integer) < 100000000000000
14:26:29 <lambdabot>   "OK, passed 500 tests."
14:26:33 <Janni> Hello.
14:26:41 <RaptorRarr> There we go. That should be enough to put it close to the same surety as gravity.
14:26:55 <napping> Hello
14:27:11 <RaptorRarr> Hello.
14:27:16 <DanBurton> @check forAll arbitrary \xs -> length xs > 100 ==> sum xs > 10
14:27:17 <lambdabot>   Parse error at "\xs" (column 18)
14:27:23 <Jafet> Gravity is caused by unrequited hugs.
14:27:35 <DanBurton> :t arbitrary
14:27:36 <lambdabot> forall a. (Arbitrary a) => Gen a
14:27:50 <RaptorRarr> @check flip div 0
14:27:51 <lambdabot>   Add a type signature
14:28:00 <RaptorRarr> @check (==5). flip div 0
14:28:01 <lambdabot>   "*Exception: divide by zero
14:28:31 <DanBurton> @check (==0) . (*0)
14:28:32 <lambdabot>   "OK, passed 500 tests."
14:28:50 <Axman6> @check even
14:28:51 <lambdabot>   "Falsifiable, after 0 tests:\n3\n"
14:28:54 <Axman6> @check odd
14:28:54 <RaptorRarr> Jafet: Well...I do like gravity.
14:28:55 <lambdabot>   "Falsifiable, after 0 tests:\n2\n"
14:29:02 <tac-tics> @check even
14:29:03 <lambdabot>   "Falsifiable, after 0 tests:\n3\n"
14:29:14 <donri> how come it starts at different numbers?
14:29:15 <RaptorRarr> Wow, it can tell right away which number to put first!
14:29:24 <RaptorRarr> That is amazing!
14:29:24 <ReinH> random seeds, how do they work
14:29:42 <RaptorRarr> @check even
14:29:43 <lambdabot>   "Falsifiable, after 1 tests:\n-1\n"
14:29:47 <RaptorRarr> Darn!
14:29:53 <ReinH> trolled ;)
14:30:18 <donri> oh ^_^
14:30:25 <RaptorRarr> By "after" in that, do they mean any time after or right after?
14:30:33 <donri> i thought quickcheck followed some predictable pattern
14:30:39 <Axman6> no
14:30:43 <RaptorRarr> No, it tries to be all random.
14:30:44 <Axman6> that wouldn't be very useful
14:30:56 <donri> so two runs can theoretically end differently?
14:31:01 <Axman6> the moar random, the moar bug findage!
14:31:09 <RaptorRarr> donri: They can.
14:31:12 <ReinH> donri: you just saw it...
14:31:15 <RaptorRarr> @check (<1000)
14:31:16 <lambdabot>   "OK, passed 500 tests."
14:31:17 <Axman6> not theoretically, almost certainly
14:31:19 <RaptorRarr> @check (<1000)
14:31:19 <lambdabot>   "OK, passed 500 tests."
14:31:23 <RaptorRarr> @check (<1000)
14:31:24 <lambdabot>   "OK, passed 500 tests."
14:31:28 <RaptorRarr> Hmmm...
14:31:30 <RaptorRarr> @check (<100)
14:31:31 <lambdabot>   "Falsifiable, after 275 tests:\n117\n"
14:31:35 <RaptorRarr> Wow.
14:31:53 <donri> but these all predictably either fail or pass
14:32:12 <RaptorRarr> > arbitrary :: Arbitrary Int
14:32:13 <lambdabot>   Not in scope: type constructor or class `Arbitrary'Not in scope: `arbitrary'
14:32:23 <RaptorRarr> > arbitrary :: Int
14:32:24 <lambdabot>   Not in scope: `arbitrary'
14:32:31 <RaptorRarr> @hoogle arbitrary
14:32:32 <lambdabot> Test.QuickCheck arbitrary :: Arbitrary a => Gen a
14:32:32 <lambdabot> Test.QuickCheck class Arbitrary a
14:32:32 <lambdabot> Test.QuickCheck coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
14:32:47 <DanBurton> :t sample
14:32:48 <lambdabot> forall a. (Show a) => Gen a -> IO ()
14:32:49 <donri> ohai 777 people in the room
14:33:11 <DanBurton> sample (arbitrary :: Gen Int)
14:33:12 <tac-tics> What is the name of the GHC core language?
14:33:15 <DanBurton> > sample (arbitrary :: Gen Int)
14:33:16 <lambdabot>   Not in scope: `sample'Not in scope: type constructor or class `Gen'Not in s...
14:33:16 <tac-tics> I remember it was some extension of System F
14:33:21 <RaptorRarr> donri: Jackpot!
14:33:28 <Axman6> tac-tics: Core =)
14:33:29 <RaptorRarr> MatrixFrog has ruined it!
14:34:00 <monochrom> GHC's core language is System Fω plus unlimited recursion. it's name it just "core"
14:34:22 <tac-tics> System F_c
14:34:24 <tac-tics> That was it
14:34:31 <tac-tics> The word I was thinking
14:34:40 <monochrom> hence, the phrase "dump the core" takes on a different meaning in the haskell world!
14:35:05 <byorgey> System Fw plus recursion plus algebraic data types plus type equality constraints, actually
14:35:29 <monochrom> does Fc have everything of Fω?
14:35:46 <byorgey> yes
14:36:01 <monochrom> alright, next time I will say Fc
14:36:11 <byorgey> oh! wait, no, it doesn't have type lambdas
14:36:19 <monochrom> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC
14:39:40 <tac-tics> Thanks monochrom
14:39:49 <tac-tics> But ack, :=: is a terrible name for an operator >_>
14:40:23 <Jafet> I like the :- type constructor
14:40:26 <zmv> better than ;=;, right?
14:40:38 <tac-tics> ;=; is how it makes me feel
14:40:38 <zmv> or ;-;
14:40:41 <tac-tics> ;_____;
14:40:43 <zmv> hahahahahahaha
14:41:12 <monochrom> I merely asked Google for "system fc" :)
14:41:52 <tac-tics> monochrom: You always make google do all your dirty work
14:42:13 <tac-tics> monochrom: That is, when you're not abusing my poor lambdabot
14:42:14 <tac-tics> @vixen
14:42:15 <lambdabot> In a flat choice between smoke and jobs, we're for jobs...But just keep me out of trouble on environmental issues.
14:42:29 <tac-tics> :( Damn you caaaaaaale
14:42:45 <monochrom> hahaha but it's byorgey :)
14:43:09 <monochrom> tips: you can get the same effect with @nixos
14:43:35 <hpaste_> wavewave pasted “twisted matrix” at http://hpaste.org/52153
14:44:18 <Jafet> @niven
14:44:19 <lambdabot> When the President does it, that means that it is not illegal.
14:44:23 <wavewave> cheater: I don't know why it takes so long.. but actually the implementation of twisted matrix in haskell is simple using state monad.
14:45:00 <wavewave> cheater: I was completely wrong in the first direction.
14:46:01 <Leemp2> Anyone know if there are any Haskell libraries for building command line GUIs?
14:46:10 <Jafet> @hackage vty
14:46:10 <lambdabot> http://hackage.haskell.org/package/vty
14:46:21 <monochrom> when niven does it, that means it is not illegal number theory :)
14:46:38 <Leemp2> Jafet: Lovely, thank you very much
14:46:45 <Leemp2> Jafet: Is that basically the only one?
14:46:55 <Jafet> Are you a masochist?
14:47:01 <Jafet> @hackage hscurses
14:47:01 <lambdabot> http://hackage.haskell.org/package/hscurses
14:47:43 <Leemp2> Jafet: Haha, no, i just like to see the various ways libraries have approached this. Thanks a ton :)
14:47:54 <wavewave> can I search inside hpaste?
14:48:14 <Jafet> HSCurses.Curses.beep :: IO ()
14:48:18 <Jafet> Oh dear
14:48:22 <tac-tics> hehe
14:48:56 <wavewave> it seems not having that feature yet. hm.
14:49:31 <DanBurton> @hackage twisted
14:49:32 <lambdabot> http://hackage.haskell.org/package/twisted
14:51:43 <wavewave> DanBurton: I was implementing http://twistedmatrix.com/documents/current/core/howto/defer.html if you want to know.
14:52:54 <DanBurton> wavewave: cool
14:53:20 <wavewave> cheater asked me if it is implemented as a monad.
14:53:46 <wavewave> From the figure, it looked like some kind of coroutine...thing..
14:54:01 <wavewave> that was completely stupid direction...
14:54:19 <wavewave> it's nothing but just state monad..
14:54:24 <wavewave> with boolean state.
14:54:47 <wavewave> and in this case, state monad is very good abstraction unlike other cases in haskell.
14:55:04 <DanBurton> Leemp2: that ^
14:55:14 <lambdanaut> I've got a list that I'm going to be dragging along through a program to different functions, and it's nescessary that many of these functions know the length of my list. The list's length won't change, but it's not known at runtime. How can I drag the list's length around without recomputing it for every function?
14:55:26 <wavewave> because.. state monad has the callback inside as a definition.
14:55:34 <lambdanaut> In any other language I'd set a global variable I guess
14:55:39 <DanBurton> Leemp2: wait nevermind :P accidentally scrolled up and thought it was new conversation o_O
14:55:42 <tac-tics> lambdanaut: How can a list's length not be known at runtime?
14:55:49 <Leemp2> DanBurton: Np :)
14:56:06 <tac-tics> lambdanaut: or did you mean compile time?
14:56:28 <lambdanaut> compile time
14:56:28 <wavewave> lambdanaut : just make a datatype like data LengthList = { len :: Int, list :: [a] }
14:56:30 <wavewave> lambdanaut : and pass them around.
14:56:33 <tac-tics> lambdanaut: what wavewave said. Make a length-aware datatype
14:56:50 <lambdanaut> That was my original thought, but it didn't seem very elegant. I guess it'll work though!
14:56:51 <wavewave> lambdanaut: haskell efficiently treat it.
14:56:52 <tac-tics> lambdanaut: You could also even probably use an array type, with O(1) lookup
14:57:04 <wavewave> lambda: actually that's elegant..
14:57:14 <DanBurton> lambdanaut: or use Data.Sequence
14:57:17 <tac-tics> Haskell elegance is a weird sort of elegance :)
14:57:26 <wavewave> lambdanaut: because when you use them... only one copy exists.
14:57:34 <wavewave> automatically.
15:01:15 <Janni> lambdanaut: Maybe I'm stating the obvious, but you can define the functions that are using this length value are all locally (e.g. within the same "where" clause)
15:01:15 <wavewave> in haskell, defining a 'temporary' structure as much as possible is always good.
15:01:15 <DanBurton> @pl \xs -> foo (bar xs) xs
15:01:15 <lambdabot> foo =<< bar
15:01:15 <wavewave> it doesn't cost.
15:01:15 <wavewave> also denotationally it makes sense..
15:01:15 <Janni> lambdanaut: That way all can make use of a single variable with the length of the list of the list as a value...
15:01:15 <wavewave> because a function you'd like to make is to have a precondition that I know already the length of the list.
15:01:15 <wavewave> so its argument should be different from a simple list.
15:01:43 <wavewave> by getting LengthList as your argument, you are explicitly saying that this function is taking a list for which we already know the length.
15:02:04 <Cale> http://www.smbc-comics.com/#comic -- haha
15:02:09 <lambdanaut> I dunno. I think because length is a property of the list, it should be the function's responsibility to (length $ list) it.
15:02:31 <lambdanaut> but yeah, I'll lug around a length. It'll probs be easier in the end anyways
15:02:38 <lambdanaut> especially since I'll make use of it so often
15:02:41 <RaptorRarr> Heheh
15:02:55 <wavewave> lambdanaut: yes. that's the responsiblity of length to calculate length of the list.
15:03:04 <Cale> lambdanaut: What are you using the length for?
15:03:22 <Cale> Often if you need to know the length of a list, then a list isn't quite the right thing to be using in the first place.
15:03:28 <wavewave> so that should not be the responsibility of your function which assumes the length already.
15:03:49 <DanBurton> imho we should be preaching the virtues of Data.Sequence more
15:03:53 <wavewave> so responsibility of LengthList is basically having correct length in it.
15:03:56 <lambdanaut> I'm using a [[],[],[]] to represent a grid
15:03:59 <wavewave> that's 'invarint'
15:04:11 <lambdanaut> so it's more like a matrix
15:04:16 * monochrom hugs data invariants
15:04:35 <wavewave> so not to violate the invariant, it is clever to use  'smart constructor'
15:05:30 <wavewave> hide the ordinary constructor, and create LengthList using a designated function.
15:06:21 <wavewave> lambdanaut: by this way, seemingly uglier solution at first sight becomes more safe and clever.
15:06:54 <wavewave> lambdanaut: so do not hesitate make a new datatype. that's our right entitled to us.
15:07:05 <lambdanaut> yessir!
15:07:14 <hpaste_> DanBurton pasted “length list” at http://hpaste.org/52154
15:07:43 <DanBurton> missed the opening d >,<
15:08:50 <lambdanaut> Oh hey, that is pretty. Thank you for the example!
15:08:53 <Peaker> Is Arbitrary a better name for the class than TestInput?
15:09:12 <Peaker> There are probably useful properties that Test Inputs have that other arbitrary values of a type don't have
15:11:33 * ddarius hugs data contravarmints.
15:13:28 * Saizan doesn't get the connection between ants and mints
15:13:43 <zmv> ants like mints.
15:16:30 <DukeDave> Is anyone here familiar with darcsden?
15:20:11 <DanBurton> heard of it
15:20:14 <DanBurton> that's about it
15:20:30 <DukeDave> I'm getting: darcs failed:  Not a repository: DukeDave@darcsden.com:wxhaskell-dev ((scp) failed to fetch: DukeDave@darcsden.com:wxhaskell-dev/_darcs/inventory)
15:20:48 <DukeDave> Which is a valid complaint, but a little sad :(
15:22:44 <DukeDave> Aha, didn't add my pubkey :)
15:25:18 <ocharles> Any digestive-functor users here? If I have the type "SnapForm m Html BlazeFormHtml (Maybe (Ref EditionFormat))" where m is a monad, I can't figure out how to run something in the 'm' monad, from that type
15:26:00 <ocharles> (I have a value :: m [Foo], for example)
15:33:12 <Eduard_Munteanu> ocharles: how did you get that thing? Does runForm help you?
15:34:15 <ocharles> hrm, I don't think so, because I'm inside the form; I'm trying to define the form
15:34:26 <ocharles> the call I'm making hits the DB to ask what rows to put inside a <select>
15:34:57 <ocharles> I'm not sure how possible that is though, because Form is not a monad (just an applicative functor)
15:40:29 <Eduard_Munteanu> ocharles: maybe you can stick the monadic parts into the Environment?
15:41:05 <Eduard_Munteanu> "The environment is where you get the actual input per form. The environment itself is optional"
15:41:15 <ocharles> interesting!
15:41:30 <Eduard_Munteanu> Environment (FormId -> m (Maybe i))
15:41:46 <Eduard_Munteanu> That's the data constructor.
15:42:09 <DukeDave> Hmm, here's one for you: I'm trying to put a darcs patch file on the Haskell wiki
15:42:13 <DukeDave> Possible?
15:45:17 <ocharles> Eduard_Munteanu: I don't think I want the environment
15:45:21 <ocharles> that's for getting user input into the form
15:46:05 <Eduard_Munteanu> Ah, so you need to do that from within the form I guess.
15:47:19 <ocharles> right
15:47:49 <BMeph> Has anyone here been following the latest round of "Haskell isn't that great" on HN?
15:48:31 <DanBurton> So in theory, monads can be defined in terms of return, fmap, and join. So why isn't "join" in the class definition? Why is it defined outside?
15:48:58 <shachaf> DanBurton: Because.
15:49:14 <shachaf> DanBurton: Monad can also be defined in terms of >=>, but that's also defined outside.
15:49:20 <DanBurton> shachaf: -______-
15:49:26 <Gracenotes> it could be. I think it ends up being less efficient in a bunch of cases for most of what you want to use it for
15:49:31 <shachaf> DanBurton: Why isn't Functor a superclass of Monad?
15:49:32 <Gracenotes> also, bind is so important, there's syntax for it
15:49:33 <Axman6> BMeph: link?
15:49:44 <Gracenotes> BMeph: is this related to the node.js business?
15:49:48 <Cale> Functor *should* be a superclass of Monad, but it's just a mistake that it's not.
15:50:06 <DanBurton> shachaf: because someone snuck in and vandalized Prelude while we weren't looking?
15:50:13 <Cale> I think it's from people not realising that it's valid to define superclass methods in terms of subclass methods.
15:50:15 <shachaf> DanBurton: I recommend Haskell 1.4.
15:50:19 <roconnor> was Functor a superclass in Haskell 1.4?
15:50:27 <Eduard_Munteanu> I think 'join' should also be.
15:50:37 <BMeph> Axman: Looking - I was reading it at work, so it's out of my queue. Now, if Google Reader ran on Haskell instead of Node... ;þ
15:50:38 <Eduard_Munteanu> You just need defauts.
15:50:45 <Eduard_Munteanu> s/faut/fault
15:50:50 <Axman6> heh
15:50:51 <shachaf> Cale: Those people being the Haskell committee?
15:50:56 <shachaf> roconnor: Oh, maybe it wasn't.
15:50:57 <ddarius> roconnor: It certainly was in Gofer.
15:51:03 * shachaf recommends Haskell 1.4 anyway.
15:51:03 * monochrom wrote a data type for which Eq methods call Ord methods :)
15:51:20 <Cale> It wasn't
15:51:33 <monochrom> because it's easier to define a partial order for that data type
15:51:34 <roconnor> I like how my recursive default instances for star and plus for StarSemiRing actually form valid instances in many cases.
15:51:34 <Cale> But Haskell 1.4 had:
15:51:38 <Cale> class Functor f where
15:51:45 <Cale>   map :: (a -> b) -> f a -> f b
15:51:51 <Eduard_Munteanu> What's that anyway? Haskell 1914? :)
15:51:54 <ddarius> As did Gofer.
15:52:02 <ddarius> Eduard_Munteanu: 1901.4
15:52:08 <Eduard_Munteanu> Oh, makes sense :P
15:52:09 <Cale> and no fail in the Monad class
15:52:14 <DevHC^> Cale: 1.4? what is the latest Haskell?
15:52:18 <Cale> and MonadZero/MonadPlus
15:52:24 <monochrom> Haskell Airport 1977
15:52:24 <Eduard_Munteanu> DevHC^: 2011
15:52:25 <Cale> DevHC^: 2010
15:52:25 <BMeph> Axman: "Is Haskell the Cure?" - http://news.ycombinator.com/item?id=3065672
15:52:30 <Eduard_Munteanu> Bah.
15:52:32 <roconnor> Cale: no fail?  How did pattern matching on in do expressions work?
15:52:37 <Axman6> i was just about to ask if it was that one
15:52:38 <Cale> roconnor: MonadZero
15:52:39 <ion> > 2010 - 1.4
15:52:39 <lambdabot>   2008.6
15:52:42 * Eduard_Munteanu forgets even recent stuff.
15:52:49 <Gracenotes> BMeph: ah that one
15:52:52 <Gracenotes> saw it on reddit
15:52:58 <DevHC^> Cale: which version number is the latest?
15:53:09 <ddarius> Eduard_Munteanu: That's nothing.  I forget the future.
15:53:23 <Eduard_Munteanu> Aww, that must be pretty bad.
15:53:31 <Cale> roconnor: If you matched against a failable pattern (i.e. a non-lazy match against a data constructor from a type with more than one constructor), then you got a MonadZero constraint
15:53:37 <Cale> DevHC^: Doesn't have one
15:53:47 <Cale> DevHC^: There was 1.4, then 98, then 2010
15:53:48 <roconnor> Cale: wow.  I can't beleive they removed that
15:53:57 <Cale> roconnor: Yes, it's retarded.
15:53:59 <monochrom> (if you try to watch the movie Memento and you keep forgetting the future, that will be quite a struggle...)
15:54:01 * hackagebot hledger-lib 0.16.1 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.16.1 (SimonMichael)
15:54:03 * hackagebot hledger 0.16.1 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.16.1 (SimonMichael)
15:54:05 * hackagebot hledger-vty 0.16.1 - A curses-style console interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-vty-0.16.1 (SimonMichael)
15:54:06 <Marco> hey, I'm struggling to figure out the most idiomatic way to do this.  I have a function that recursively generates a bunch of structures of a single type.  It makes several recursive calls for each call.  I want a flat list of structures at the end, not the nested mess I'm able to get right now.  Any advice?
15:54:07 * hackagebot hledger-chart 0.16.1 - A pie chart image generator for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-chart-0.16.1 (SimonMichael)
15:54:09 <roconnor> can we get a Haskell 1.4 mode in GHC?
15:54:27 <shachaf> Was there a justification for removing MonadZero?
15:54:28 <roconnor> I'm willing to give up Read and Show for this
15:54:30 <ocharles> what do things like classy prelude bring to the table?
15:54:32 <Cale> Marco: list comprehensions?
15:54:37 <Axman6> BMeph: what seemed to be missing in a lot of that dicussion is that GHC gives you the ability to write an event based system without you even really knowing it
15:54:57 <roconnor> Axman6: GHC.Event?
15:55:27 <Cale> Basically, what happened is they removed monad comprehensions because some people were complaining that their students were confused about non-list error messages, and they were too lazy to explain what the error messages meant
15:55:28 <DanBurton> Marco: can you hpaste it?
15:56:05 <Axman6> roconnor: no, just using the IO system and lots of threads makes writing high speed servers very easy. and you get it all for free, you just listen on sockets, read from handles, and everything under the hood acts like an event based system
15:56:08 <Cale> and once monad comprehensions were removed, someone figured that "hey, we don't need this MonadZero junk anymore, since all the MonadZero instances are also MonadPlus instances anyway"
15:56:15 <monochrom> write yet another recursion to flatten the structure...
15:56:21 <Cale> and that got moved into the Monad modules
15:56:21 <Cale> module*
15:56:46 <Cale> and then someone else noticed "oops! The translation of do-syntax needs zero in this case here..."
15:56:52 <DanBurton> we should make a BeginnerHaskell and a RealHaskell, where RealHaskell gets all the goodies while BeginnerHaskell gets the pretty error messages about lists
15:56:56 <Cale> and added 'fail' as an answer to taht
15:56:57 <Cale> that*
15:57:11 <Eduard_Munteanu> Eww.
15:57:23 <dalaing> BMeph: the discussion at that link was a lot better than I was expecting - the last thing I read on HN was the discussion under an article where the author complained about all the wannabe-entrepreneurs with terrible ideas on HN, half the comments where from self-described html programmers who were sick of not being taken seriously
15:57:31 <Eduard_Munteanu> Well, I guess they refuctored it.
15:57:43 <Cale> It was this big snowball of failure that got started with removing monad comprehensions :P
15:57:46 <BMeph> Cale: I think you put some superfluous quotes in that last sentence... ;)
15:57:57 <Axman6> dalaing: there's some great stuff on hackernews, if you avoid all the start up wank
15:58:16 <Cale> Now we have monad comprehensions back in GHC, but the surrounding mound of failure is still there
15:58:17 <ocharles> Cale: and is there anyway we can actually get out of this mess?
15:58:19 <DevHC^> Cale: the other solution would be bottomization
15:58:21 <ddarius> DanBurton: It's called Helium.
15:58:41 <Marco> DanBurton: https://gist.github.com/ea79b25e1d54a6aca8d8
15:58:41 <DevHC^> ie. "a <- f" would be "f >>= \a ->" :P
15:58:54 <shachaf> Cale: Well, monad comprehensions are back in GHC.
15:58:55 <DanBurton> From the HN discussion: "Haskell really requires you to understand before you code. Which in the end means your study to code ratio is very different than almost any other language."
15:59:01 <shachaf> That means it's going to snowball backwards, right?
15:59:14 <Marco> DanBurton: the way I'm doing it currently feels very unidiomatic, but I don't really have enough experience with haskell to know for sure
15:59:18 <Eduard_Munteanu> DevHC^: that looks more like a lobotomy
15:59:21 <dalaing> Axman6: I used to read it pretty regularly a fair while back, a lot less now - although someone sent me a link to a homemade GPS receiver yesterday that they found on HN, so it can't all be bad :)
15:59:29 <DevHC^> Eduard_Munteanu: :P
15:59:33 <Cale> shachaf: Unfortunately, I'm afraid not without a lot of kicking and screaming
15:59:47 <Cale> There's a lot of code which will break if we fix things.
16:00:00 <Axman6> the SNR of hackernews is quite a bit higher than reddit these days
16:00:21 <Eduard_Munteanu> Any sane alternate preludes out there?
16:00:43 <BMeph> Axman6: That's like saying it's higher than slashdot, though... :/
16:00:44 <DanBurton> Marco: is there a method, mergeGraphic :: [Graphic] -> Graphic, or something like that?
16:01:06 * Eduard_Munteanu would think Haskellers wouldn't mind using alternate preludes, they should be just another external dependency.
16:01:21 <ocharles> Eduard_Munteanu: there are alternatives
16:01:36 <ocharles> but remember that a "Monad" type class in one prelude wouldn't match the prelude in all your deps
16:01:38 <Eduard_Munteanu> Yeah, I know, but I haven't looked into them thoroughly.
16:01:40 <monochrom> the problem is that the do-notation is fairly hardwired
16:01:54 <Eduard_Munteanu> Argh, yeah.
16:02:10 <DanBurton> Marco: or perhaps simply mergeGraphic :: Graphic -> Graphic -> Graphic
16:02:43 <Marco> DanBurton: now that I look, there is
16:02:49 <Marco> called overGraphics
16:02:57 * Eduard_Munteanu wishes they stole Agda's 'syntax' construct and perhaps improved on it.
16:03:19 <Marco> DanBurton: in the absence of such a function though, is my current method any good?
16:03:23 <BMeph> Marco: Gave you some (small) help. ddarius/Cale would have completely re-written your function to be clearer and faster, but alas, I has teh Dumm... ;þ
16:03:38 <hpaste_> stribor pasted “myTitle” at http://hpaste.org/52156
16:03:47 <DanBurton> Marco: it looks pretty good. I think you could use concatMap to simplify a little
16:03:56 <DanBurton> @src concat
16:03:57 <lambdabot> concat = foldr (++) []
16:04:10 <stribor> i am trying to pattern match this and it is oblviosly not working....cna you guys point me on what i am doing wrong here with matching
16:04:40 <monochrom> myFunction Something = (0,0)
16:04:47 <monochrom> myFunction SomethingElse = (1,2)
16:04:53 <monochrom> that's about the only thing you can do
16:05:09 <stribor> well isnt (x,y) good?
16:05:09 <monochrom> and of course you miss two "data" keywords
16:05:20 <Kreole> are "min" and "minimum" functionally the same?
16:05:26 <DanBurton> Marco: so instead of "foldr (++) [] (map f xs)" you can just use "concatMap f xs" I think
16:05:31 <stribor> well return type is Type2
16:05:38 <stribor> Type2 = (Int,Int)
16:05:46 <stribor> i am trying to paramatch Type2
16:05:50 <Marco> DanBurton: great.  thanks for the help
16:05:55 <monochrom> oh, then you're missing one "data" keyword and one "type" keyword
16:06:00 <Axman6> Kreole: no. one is for finding the minimum of two arguments, the other finds the minimum value in a list
16:06:01 <DanBurton> @pl \f xs -> foldr (++) [] (map f xs)
16:06:01 <lambdabot> (foldr (++) [] .) . map
16:06:13 <Kreole> ohhhhh. Thanks.
16:06:15 <BMeph> Kreole: No; "minimum" takes a list (which you could find out from the types, BTW. Just saying... ;)
16:06:15 <stribor> monochrom: lost:)
16:06:18 <Axman6> :t min
16:06:19 <Eduard_Munteanu> stribor: you can't pattern-match on a result. What would that even mean?
16:06:19 <lambdabot> forall a. (Ord a) => a -> a -> a
16:06:21 <Axman6> :t minimum
16:06:22 <lambdabot> forall a. (Ord a) => [a] -> a
16:06:33 <monochrom> your function takes parameter Type1 so there is no such thing as paramatch Type2
16:06:54 <DanBurton> Marco: no problem :)
16:07:06 <dalaing> today I learned that minimum exists
16:07:19 <monochrom> if you write a Int->String function you don't go f "hello" = 5, do you?
16:07:20 <Axman6> dalaing: you need to read your prelude ;)
16:07:22 <stribor> wow...i made this the wrong way...let me rewrite example
16:07:24 <dalaing> I've been folding with min for the last month or two
16:07:24 * BMeph coughs *cough* ViewPatterns! *cough*
16:08:19 <DanBurton> @where prelude
16:08:19 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
16:08:33 <dalaing> Axman6: I've been putting it off until I convince myself I'm "intermediate" enough, might be prudent to put some time aside...
16:09:13 <Axman6> dalaing: http://ww2.cs.mu.oz.au/172/Haskell/tourofprelude.html get reading
16:09:48 <dalaing> Axman6: thanks - although I might read it once I get home from work
16:09:56 <Axman6> good idea
16:10:07 <dalaing> I might get burned for being a witch otherwise :)
16:10:51 <stribor> monochrom: you see now what i mean
16:11:01 <DanBurton> Axman6: cool, til about "exp"
16:11:05 <geheimdienst> Axman6: pretty cool page, never seen it before
16:11:10 <DanBurton> > exp (log 1)
16:11:11 <lambdabot>   1.0
16:11:18 <stribor> myfunction takes type1
16:11:30 <geheimdienst> (the question is why that isn't all in prelude's haddock, but whatever ...)
16:11:31 <DanBurton> @where tourofprelude
16:11:32 <lambdabot> I know nothing about tourofprelude.
16:11:42 <DanBurton> @where+ tourofprelude http://ww2.cs.mu.oz.au/172/Haskell/tourofprelude.html
16:11:43 <lambdabot> It is stored.
16:11:56 <DanBurton> @where tourofprelude
16:11:56 <lambdabot> http://ww2.cs.mu.oz.au/172/Haskell/tourofprelude.html
16:11:58 <stribor> so i want to return second element from Type1
16:12:00 <DanBurton> @botsnack
16:12:00 <lambdabot> :)
16:12:01 <Eduard_Munteanu> stribor: did you re-paste anything? I can't see it.
16:12:09 <monochrom> myFunction (Ty (f,(x,y))) = (x,y)
16:12:18 <stribor> http://hpaste.org/52157
16:12:40 <stribor> monochrom: why did you have to do it that way
16:12:44 <monochrom> and you're still missing a "data" keyword and a "type" keyword
16:12:51 <Eduard_Munteanu> stribor: note Type2 and Type3 are still broken, if those are intended as actual Haskell code.
16:12:57 <monochrom> because that's Type1.
16:13:14 <monochrom> because it's a Haskell rule.
16:13:25 <stribor> oh yeah i know that
16:13:30 <stribor> i was just typoing thjose fast'
16:13:36 <monochrom> because Haskell is designed by the Haskell Committee and they want it
16:13:52 <stribor> line 2 should have data keyword before
16:14:01 * hackagebot hledger-web 0.16.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.16.1 (SimonMichael)
16:14:18 <Eduard_Munteanu> Hm?
16:14:24 <monochrom> I don't know. don't ask me why the language makes me do things certain ways, especially syntactically. I didn't design and decide it to be that way. I wouldn't know.
16:14:26 <stribor> line 5 should have data keyword
16:14:32 <Eduard_Munteanu> Ah.
16:14:35 <stribor> line 6 should have type keyword
16:14:47 <stribor> sorry:)
16:16:02 <Eduard_Munteanu> You just need to use the newtype's constructor properly when pattern-matching, like monochrom said, then.
16:16:32 <monochrom> humans are too smart to understand computers
16:16:41 <stribor> yes i see that...thank you guys
16:17:10 <hpaste_> DanBurton annotated “change” with “change (annotation)” at http://hpaste.org/52157#a52158
16:19:52 <Kreole> are the things that constitute a type called constructors?
16:20:12 <Kreole> or, if not, what are they called?
16:20:14 <monochrom> some of them, not all of them
16:20:18 <dobblego> things that construct a type, such as "Maybe" are called type constructors, if that's what you mean
16:20:34 <monochrom> data X a = Y | Z a  Y,Z are constructors, "a" isn't
16:21:08 <Kreole> okay
16:21:14 <monochrom> generally, see the Haskell 2010 Report for what things are called
16:22:06 <Kreole> ok. I have another question but if it's something I should be able to find somewhere feel free to tell me so
16:22:38 <Kreole> I'm not sure how to make a function act differently for different constructors of a data type
16:22:41 <Kreole> does that make sense?
16:22:52 <monochrom> f Y = 0
16:22:59 <monochrom> f (Z _) = 1
16:23:00 <Eduard_Munteanu> By pattern-matching on your input.
16:23:11 <geheimdienst> @src fromJust
16:23:11 <lambdabot> fromJust Nothing  = undefined
16:23:11 <lambdabot> fromJust (Just x) = x
16:23:12 <monochrom> that's an example using my X type above
16:23:23 <DanBurton> fromJust is a good example
16:23:47 <DanBurton> @src maybe
16:23:47 <lambdabot> maybe n _ Nothing  = n
16:23:47 <lambdabot> maybe _ f (Just x) = f x
16:24:01 <geheimdienst> Kreole: ^^ that's an example of a type with 2 data constructors (Nothing and Just a) being consumed by a function. it uses pattern matching on the constructors
16:24:01 * hackagebot hledger-web 0.16.2 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.16.2 (SimonMichael)
16:24:21 <BMeph> fromJust is a good example...that sets a bad example. ;)
16:24:30 <monochrom> haha
16:24:46 <geheimdienst> cause of the undefined? well yeah, disregard that for the moment ...
16:24:55 <geheimdienst> :)
16:25:35 <Kreole> ok thanks I think I get it
16:25:57 <DanBurton> BMeph: "maybe" is a better example, then ;)
16:26:26 <BMeph> DanBurton: "True, true." :)
16:26:34 <Peaker> @src fromMaybe
16:26:34 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
16:26:47 <Peaker> who put that ridiculous definition in there?
16:26:52 <DanBurton> that's weird
16:26:52 <monochrom> http://www.vex.net/~trebla/haskell/testbed.cgi now has my X Y Z example!
16:27:27 <DanBurton> Peaker: I guess that's how it is in the real source: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Maybe.html#fromMaybe
16:28:13 <Peaker> DanBurton: that's so out of place
16:28:19 <DanBurton> Peaker: ikr
16:28:42 <Eduard_Munteanu> And badly indented.
16:29:43 <geheimdienst> documentation: "The 'fromMaybe' function takes a default value and and 'Maybe'"
16:29:45 <geheimdienst> *sigh*
16:30:00 <byorgey> I like how just above that, next to the 'error' call in the definition of fromJust, there is a comment  -- yuck
16:30:21 <byorgey> if it's so yucky, why not just remove it?
16:30:40 <Eduard_Munteanu> byorgey: maybe the "yuck" should go with the type signature :P
16:30:48 <byorgey> Eduard_Munteanu: indeed
16:30:59 <byorgey> I've half a mind to propose removing fromJust
16:31:05 <byorgey> unless it's specified by the Report?
16:31:16 <DanBurton> that would be like removing head
16:31:24 <byorgey> DanBurton: I'd like to remove head too.
16:31:24 <ddarius> Well in 2010 all of Data.Maybe is in the Report.
16:31:29 <byorgey> drat.
16:31:43 <ddarius> But fromJust is also in Haskell 98.
16:31:57 <DevHC^> why is there a List and a Data.List?
16:32:00 <ddarius> byorgey: You could propose fromJust get removed for Haskell 2012
16:32:20 <DanBurton> @let fromJustMonoid Nothing = mzero; fromJustMonoid (Just x) = x
16:32:21 <lambdabot>  Defined.
16:32:22 <Peaker> byorgey: I think fromJust is actually a nice way to encode partiality in general (though it would be nice if it took a "proof message" to output if it is Nothing)... remove all other partial functions, rather than fromJust, and have them return Maybe instead
16:32:38 <DanBurton> > fromJustMonoid Nothing :: Int
16:32:39 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:32:39 <lambdabot>         against inferred type ...
16:32:40 <Eduard_Munteanu> Hm, interesting.
16:32:50 <Peaker> byorgey: so if you want partial head -- you can do:  fromJust "list can't be empty because ...." . head
16:32:52 <byorgey> ddarius: yeah, but proposing a change to the Report is a lot more work than proposing a change to a library
16:32:56 <Eduard_Munteanu> Like a 'safeHead'.
16:33:13 <DanBurton> > fromJustMonoid Nothing + 3
16:33:14 <lambdabot>   No instance for (GHC.Num.Num (m a))
16:33:14 <lambdabot>    arising from a use of `e_13' at <int...
16:33:19 <DanBurton> boo
16:33:25 <BMeph> DevHC^: Because hierarchical modules is a new feature in Haskell. This is not a joke, BTW. :)
16:33:25 <byorgey> Peaker: hmm, that's not a bad idea
16:33:28 <DanBurton> :t mzero
16:33:29 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
16:33:34 <Eduard_Munteanu> Rather, head = fromJust . safeHead
16:33:45 <DanBurton> where's my monoid mzero? Is it called something else?
16:33:56 <byorgey> DanBurton: mempty
16:34:03 <DanBurton> ah yeah
16:34:05 <DevHC^> sounds counter-productive in many cases ... what will u do with a safeHead? case safeHead xs of (Just x) -> ... ; Nothing -> error "i suck @ programming"
16:34:18 <Peaker> Eduard_Munteanu: except "safeHead" should be "head", and "head" should be "off with your head"
16:34:26 <dankna> DevHC^: propagate it upwards
16:34:26 <DanBurton> @let fromJust2 Nothing = mempty; fromJust2 (Just x) = x
16:34:27 <lambdabot>  Defined.
16:34:28 <Eduard_Munteanu> mzero, mplus     mempty, mappend
16:34:30 <monochrom> safeFromJust :: Maybe a -> Maybe a; safeFromJust Nothing = Nothing; safeFromJust (Just x) = Just x  -- is my opinion on all the safeXXX police
16:34:35 <byorgey> DevHC^: yes, the point is it makes you consider that case and at the very least give a specific error message
16:34:37 <geheimdienst> but can we please give the nice short name (head) to the safe default function, and the longer uglier name to the unsafer function
16:34:37 <Eduard_Munteanu> Peaker: heh, yeah
16:34:47 <DanBurton> > fromJust Nothing + 3
16:34:48 <lambdabot>   *Exception: Maybe.fromJust: Nothing
16:34:54 <DanBurton> > fromJust2 Nothing + 3
16:34:56 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:34:56 <lambdabot>    `GHC.Num.Num a'
16:34:56 <lambdabot>      ari...
16:34:57 * BMeph is just grateful "fromMaybe" wasn't called "MaybeWithDefault"... ;þ
16:35:08 <DanBurton> le-sigh. lambdabot doesn't like me today
16:35:12 <Peaker> "safe" should be the default... "unsafe" is what should be in names
16:35:13 <DevHC^> byorgey: head a convenience in a lot of cases
16:35:27 <Peaker> "fromJust" should be named "unjust" :)
16:35:32 <ddarius> BMeph: That would be a constructor.
16:35:33 <DanBurton> :)
16:35:34 <DevHC^> Peaker: unsafe is reserved for really unsafe things :P
16:35:40 <Peaker> DevHC^: like partiality? :P
16:35:53 <Eduard_Munteanu> DevHC^: your point is everyone likes head? :P
16:35:54 <DevHC^> Peaker: no, like magic (IO a -> a)
16:36:05 <DevHC^> i <3 head
16:36:10 <geheimdienst> Peaker: i didn't really understand your earlier example. what is the function «fromJust "list can't be empty"» ...?
16:36:15 <Peaker> DevHC^: Partiality is very unsafe in Haskell, given that Haskell debugging sucks atm
16:36:31 <byorgey> DevHC^: I agree, it is convenient.  But after several experiences going "oh, using head is OK here" and then later having the program blow up, I am willing to trade a bit of convenience in order to force me to program more conscientiously
16:36:34 <Peaker> geheimdienst: it's what to error when it happens, esp. important when no stack traces
16:36:47 <Peaker> geheimdienst: and it incentivizes authors to think about and write a proof of why it can't be Nothing
16:36:54 <DevHC^> byorgey: the use ur own head
16:36:56 <DevHC^> :D
16:37:05 <byorgey> DevHC^: convenience is not a design principle of Haskell.
16:37:10 <DevHC^> WRONG
16:37:15 <Peaker> Always choose safety over convenience...
16:37:30 <Eduard_Munteanu> Convenience *is* safety, long-term ;)
16:37:30 <byorgey> DevHC^: hehe
16:37:34 <DanBurton> [citation needed]
16:37:40 <monochrom> at least it is not "WRONG(TM)" this time
16:37:41 * BMeph thinks "unsafePerformHead" may give people the wrong idea... ;)
16:37:52 <Eduard_Munteanu> Heh.
16:37:53 <geheimdienst> oh i see. so with today's functions it would be something like «fromMaybe (error "can't happen because ...") . safeHead»
16:37:57 <Peaker> I think one of the main sickness in the software world is that it repeatedly chooses convenience over safety, because the reward is immediate.. But the cost of the unsafety is orders of magnitude larger than the benefit of convenience
16:38:06 <DevHC^> monochrom: this time i did not use a proprietary definition, rather a common one :P
16:38:10 <byorgey> geheimdienst: right
16:39:06 <Eduard_Munteanu> Peaker: I'm not sure Haskell would use such proofs
16:39:20 <Eduard_Munteanu> wrt "and write a proof of why it can't be Nothing"
16:39:20 <Peaker> e.g: Not having exhaustiveness warnings by default in GHC is convenience over safety -- in the grand scheme, I venture a single bug due to that costs more to fix than the time saved by dozens of occurances where you did not have to enumerate that other constructor
16:39:28 <ddarius> The trick is to make the convenient thing the safe thing.
16:39:29 <Peaker> Eduard_Munteanu: of course it wouldn't
16:39:52 <Peaker> Eduard_Munteanu: the idea is to: A) have a nicer error message when you got it wrong  B) encourage thinking about a proof
16:39:54 <BMeph> Peaker: It's the imperative version of lazyness. As in, "Hard work pays off over time; lazyness pays off right now."
16:39:57 <Eduard_Munteanu> Erm, s/would/could/, if put into a suitable form
16:41:01 <Peaker> BMeph: Yeah.. I spent a week at work debugging a bug that could have been caught with slightly stricter (and thus less convenient) type checking in C  (e.g: enums are not ints)
16:41:07 <geheimdienst> by the way, i think that functions like head and fromJust technically are exhaustive 8-) they just do «error "blah"» in some cases
16:41:31 <DevHC^> lol ind33d they do
16:41:39 <Peaker> geheimdienst: they are partial on purpose, rather than by accident
16:41:45 <Eduard_Munteanu> head :: Vec a (suc n) -> a, I guess
16:41:53 <Eduard_Munteanu> (pseudohaskell, of course)
16:41:56 <Peaker> geheimdienst: not having exhaustiveness checks will give you lots of accidental partiality
16:42:05 <Eduard_Munteanu> Erm, pseudodependenthaskell.
16:42:55 <Eduard_Munteanu> Though it doesn't magically make that convenient.
16:43:08 <Peaker> Showing people how Haskell encourages writing safer code is nice, until you crash and burn on some use of "head", "undefined", etc -- and can't even fire up a debugger post-mortem
16:43:22 <Peaker> Also bad is when you get some stack overflow -- and no debugger
16:43:24 <Eduard_Munteanu> (it's probably even worse in terms of convenience than 'maybe', depending on the case)
16:43:36 <Peaker> (So Haskell isn't that safe despite all of these nice types, is it...)
16:43:38 <Cale> Well, don't use head so much then ;)
16:43:40 <geheimdienst> no, what i mean is: the source code actually has a line like «head [] =  errorEmptyList "empty head"». as far as the compiler can see, head is total
16:43:48 <Peaker> Cale: I use code that others write, though
16:43:53 <Cale> That's true
16:44:08 <geheimdienst> it has a case for [], only that this happens to do "error"
16:44:13 <Peaker> It would be OK if "error" and "undefined" were taboo in real code
16:44:17 <Cale> Some people can write bad code and you can get bitten perhaps harder by it than is justified.
16:44:36 <Peaker> and "unjust" with a reasonable proof explanation was the only way to get partiality in non-toy code
16:44:37 <geheimdienst> yeah, right now, it's a bit too easy to do the wrong thing
16:44:56 <Eduard_Munteanu> Peaker: but then I can say   head [] = head [], or even more elaborate schemes :)
16:45:10 <Peaker> Haskell's main appeal is safety -- and it should capitalize on that and not give convenience shortcuts that undermine its main appeal
16:45:29 <Peaker> Eduard_Munteanu: I don't mean to abolish "error", keep it there -- I mean to make it taboo.. a sign of bad programmer/code
16:45:30 <Eduard_Munteanu> And my "error message" will be non-termination :)
16:45:39 <Eduard_Munteanu> Ah, I see your point.
16:45:44 <geheimdienst> Peaker: i think we're all agreeing vigorously. question is, how can we improve head
16:45:58 <DevHC^> Peaker: what u're looking for is headWithAlternateErrorMessageForTheCasesWhichUThoughtWereImpossible :: String -> [a] -> a
16:46:01 <DanBurton> Peaker: what do you do in the case of "[1,2,3,4,5] !! (-1)"
16:46:10 <RaptorRarr> head [] = Nothing
16:46:20 <RaptorRarr> It's like English!
16:46:31 <DanBurton> should (!!) also return a `Maybe a`?
16:46:33 <dankna> I've always been of the opinion we needed a type Word
16:46:37 <RaptorRarr> Why, yes.
16:46:38 <dankna> same size as Int, but unsigned
16:46:43 <RaptorRarr> That's what Ruby does, for instance.
16:46:52 <Eduard_Munteanu> dankna: there is one
16:46:53 <RaptorRarr> nil for everything bad!
16:46:54 <dankna> but yes, !! should return Maybe a
16:46:56 <dankna> Eduard_Munteanu, oh :)
16:47:05 <dankna> confound those who have had our ideas before us
16:47:15 <monochrom> div, (/), sqrt, abs should return Maybe, too
16:47:24 <RaptorRarr> Yep.
16:47:27 <dankna> quite so
16:47:28 <RaptorRarr> And NaN should be Nothing.
16:47:32 <Cale> monochrom: kekekeke
16:47:34 <DanBurton> Ew; that's way too much Maybe for me.
16:47:40 <RaptorRarr> Since NaN is the work of SATAN!
16:47:43 <BMeph> dankna: I'm more of the opinion that 1) Word should be the fundamental internal type, not Int; 2) We should have a Natural type, analogous to Intger.
16:47:49 <Cale> Why abs?
16:47:52 <RaptorRarr> Just TooMuch
16:47:55 <dankna> BMeph: yes, I agree with that too
16:48:10 <RaptorRarr> Wordeger!
16:48:11 <geheimdienst> cale: negative machine ints have one more value than postive, or some such
16:48:19 <monochrom> because some Num instances do not have a natural abs
16:48:19 <Axman6> > 123 :: Word
16:48:19 <lambdabot>   123
16:48:22 <DanBurton> Natural == unsigned integer?
16:48:27 <Peaker> DevHC^: No, I want head to be in Maybe, and anything else that is partial to be in Maybe, and then to just have:  unjust :: Explanation -> Maybe a -> a  --   <-- only community-acceptable way to get partiality (except in toy code)
16:48:30 <RaptorRarr> Natural = Wordeger
16:48:37 <BMeph> dankna: Oh, and 3) Integer should have Infinity and NegInfinity values.
16:48:47 <dankna> BMeph: sometime I have an experiment I want to try? I came up with a good name for it finally.  the type would be called Exact, and it would represent a possibly-irrational number as the integers which define a Taylor series converging to it.
16:48:47 <ddarius> BMeph: Integer in GHC is built on GMP which builds it on an arbitrarily large natural type.
16:48:49 <RaptorRarr> BMeph: Yeah.
16:48:51 <geheimdienst> int's range is like "-1001 ... +1000"
16:48:58 <dankna> BMeph: not clear that arithmetic can be performed efficiently on it though
16:49:01 * hackagebot hledger-web 0.16.3 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.16.3 (SimonMichael)
16:49:20 <Eduard_Munteanu> Better make signed integers use sign-magnitude so we have just as many negatives as positives :P
16:49:25 <Peaker> DanBurton: Yes
16:49:25 <Peaker> DanBurton: unjust "List is always big enough because 0 < x < blah and blah must be < 4" $ [1,2,3,4,5] !! x
16:49:26 <Peaker> it would be nice if ghc had a warning flah: -Wpartiality  that warned about partial stuff that is NOT a justified unjust -- and would be mandatory for hackage
16:49:27 <Peaker> "Justify your partialities, Haskellers!"
16:49:30 <dankna> BMeph: yes, Infinity and NegInfinity might be nice, hmmmmm
16:49:39 <monochrom> negate and (-) should return Maybe too, because you need it for "instance Num Natural"
16:50:09 <RaptorRarr> I think negative numbers should just wrap around to infinity.
16:50:20 <Peaker> monochrom: Num should be refactored so that (-) can have some well defined semantics (which say if its partial or not)
16:50:22 <ddarius> instance CommutativeMonoid Natural where zero = 0; (+) = (Natural.+)
16:50:24 <DevHC^> Peaker: u'll get a lot of ujHead, ujIndex, etc. definitions, being, for example: ujHead expl = unjust expl . head
16:50:40 <RaptorRarr> let uj = unjust
16:50:45 <dankna> on an unrelated note
16:50:49 <dankna> has anybody used the llvm package?
16:51:03 <dankna> I am trying to figure out how to get it to spit out a native executable, if that's even possible which it seems like it should be
16:51:09 <monochrom> anyway I'm being sarcastic. if I continue, all of Num Real etc all return Maybes
16:51:19 * ddarius thinks DevHC^ meant to say ujHead = unjust "foo" . head
16:51:22 <RaptorRarr> As they should!
16:51:38 <RaptorRarr> We must have type safety for partial functions!
16:51:47 <Eduard_Munteanu> Yeah, pretty much all arrows should have Maybe stuck on them by default :P
16:51:51 <DanBurton> dankna: huh? you want it to spit out a native executable that runs your code on the llvm?
16:51:53 <ddarius> monochrom: Just might run out of memory, so Just should be a -> Maybe (Maybe a)
16:52:00 <DevHC^> ddarius: no, ujHead expl list = unjust expl (head list)
16:52:04 <Eduard_Munteanu> :)
16:52:10 <DevHC^> ddarius: where head :: [a] -> Maybe a
16:52:35 <monochrom> fix may run out of memory too, so fix :: (a->a) -> Maybe a
16:52:38 <ddarius> DevHC^: That's completely fine since you are still giving an explanation.
16:52:40 <geheimdienst> main :: Maybe (IO ()) -- universe might explode before main had a chance to run
16:52:54 <monochrom> but then some people want it to be (a -> Maybe a) -> Maybe a
16:53:13 <monochrom> so you satify both desires by a type class
16:53:16 * DanBurton thinks this "safe" conversation is getting a little ridiculous
16:53:18 <dankna> DanBurton, I was under the impression that the llvm backend library also included post-compilers from llvm into native machine code.  not so?
16:53:18 <Eduard_Munteanu> maybe :: b -> Maybe ((a -> b) -> Maybe (Maybe a -> Maybe b))
16:53:29 <dankna> are those separate, or do I have to write them myself, or what?
16:53:56 <DanBurton> dankna: no clue; but if you just want native code, why bother with llvm in the first place?
16:54:09 <dankna> DanBurton: because it's a convenient intermediate representation for which many backends have been writtne
16:54:11 <Axman6> dankna: i think the point of the LLVM package is to use LLVM to compile runtime code
16:54:17 <ddarius> DanBurton: Have you written a compiler backend for, say, x86?
16:54:18 <Eduard_Munteanu> And then we can have function application be some sort of sugar for the Maybe monad.
16:54:20 <dankna> sparing me the burden of maintaining my own thingies
16:54:25 <Axman6> so, you can generate new code at runtime, that's fully compiled
16:54:36 <dankna> Axman6: oh - so the underlying C library can do it, but the Haskell wrapper package cannot?
16:54:49 <Axman6> i'm not sure
16:54:50 <DanBurton> dankna: so you want to distribute the llvm bytecode, and then let people basically compile it to native on whatever architecture they have?
16:54:54 <Axman6> but i've never seen it used for that
16:55:18 <dankna> DanBurton: no, I actually want the llvm bitcode (as they call it, for whatever reason) to be hidden internally to my program :)
16:55:41 <dankna> Axman6: thanks for the info, I'll poke around more
16:55:42 <Eduard_Munteanu> dankna: mind bytecode doesn't automagically make things portable
16:55:53 <dankna> Eduard_Munteanu, oh, sure, I poked at GHC internals enough to know that! :)
16:56:01 <dankna> Eduard_Munteanu, but it's a great start
16:56:06 <DanBurton> dankna: erm...huh? which bitcode hidden from which program?
16:56:32 <mm_freak> is there an efficient way to get the 'next' index with respect to 'range' from Data.Ix?
16:56:41 <dankna> DanBurton: sorry, let me clarify.  I'm writing a small compiler to use as a testbed for ideas I have while reading _ATTPL_ or whatever its canonical nickname is
16:56:49 <DanBurton> Eduard_Munteanu: but llvm bitcode is portable to whatever architecture llvm supports, right?
16:57:07 <dankna> DanBurton: I don't fancy spending a year writing an ia64 backend, so I want to write an llvm backend instead and hook into the llvm C library to have it spit the native code out
16:57:26 <RaptorRarr> > fromEnum True
16:57:27 <lambdabot>   1
16:57:35 <dankna> DanBurton, in answer to your question to Eduard_Munteanu, it's one thing for the code to be generated - it's another for it to comply with platform ABI
16:57:49 <dankna> there are issues with name-mangling too, which LLVM also knows nothing about
16:58:17 <dankna> essentially the LLVM backends know the things defined by the CPU manufacturer but not the things defined by the OS vendor
16:58:24 <RaptorRarr> @pl let if' p x y = [y, x] !! fromEnum p in if'
16:58:25 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
16:58:42 <DanBurton> ahhhhhhhh that makes sense
16:58:52 <RaptorRarr> > flip (flip . ((!!) .) . flip (:) . return) . fromEnum $ True 1 57
16:58:53 <lambdabot>   Couldn't match expected type `t -> t1 -> a'
16:58:53 <lambdabot>         against inferred type `...
16:58:57 <RaptorRarr> Lies!
16:59:00 <Eduard_Munteanu> LLVM probably makes sense somewhere in the code emission stage.
16:59:33 <DanBurton> > let if' p x y = [y, x] !! fromEnum p in if' True 1 57
16:59:34 <DevHC^> Peaker: u say that u hate the current head because a lot of clueless nubcake codewriters (accidentally wrongly) use head, because they think that they should use head since it's a standard function?
16:59:34 <lambdabot>   1
16:59:45 <DanBurton> o_O
16:59:59 <dankna> Eduard_Munteanu, yeah, that's my thinking
17:00:00 <Peaker> DevHC^: and because it is considered acceptable even by non-newbies
17:00:06 <DanBurton> > let if' = flip (flip . ((!!) .) . flip (:) . return) . fromEnum in if' True 1 57
17:00:07 <RaptorRarr> > (flip (flip . ((!!) .) . flip (:) . return) . fromEnum) True 1 57
17:00:08 <lambdabot>   1
17:00:08 <lambdabot>   1
17:00:09 <Peaker> DevHC^: and shown in tutorials as legitimate/etc
17:00:14 <RaptorRarr> > (flip (flip . ((!!) .) . flip (:) . return) . fromEnum) False 1 57
17:00:16 <lambdabot>   57
17:00:31 <RaptorRarr> Take that, @pl not being able to do ifs properly!
17:00:42 <DevHC^> Peaker: and do u think that changing head to Maybe-ish would solve ur problems?
17:00:52 <Peaker> DevHC^: some of them, yeah :)
17:00:53 <DanBurton> RaptorRarr: ah the $ screwed it up
17:01:02 <RaptorRarr> Yeah, I'm not sure how.
17:01:04 <Peaker> DevHC^: it will educate people that partiality is bad and needs to be justified
17:01:06 <DevHC^> ie., others would write code that is more correct?
17:01:11 <Peaker> DevHC^: yeah
17:01:15 <RaptorRarr> I guess it takes the right side and evaluates it as function application.
17:01:16 <monochrom> very old tutorials promote head because they were still in the lisp-scheme null?-car-cdr tradition of lacking pattern matching
17:02:00 <monochrom> new tutorials should just teach pattern-matching and pretend there is no head, I agree
17:02:02 <DanBurton> RaptorRarr: yes that's right. "a $ b c d" is the same as "a (b c d)"
17:02:07 <DevHC^> Peaker: i'd say: no, they would only write less of useful code, most of their code will be "o shit i suck @ coding" error calls
17:03:11 <ddarius> DevHC^: But then you'd know.
17:03:13 <RaptorRarr> DanBurton: Is a b c $ d e f the same as (a b c) (d e f)?
17:03:18 * DanBurton laughs at the pun "Just-ified"
17:03:31 <DanBurton> RaptorRarr: yep
17:03:37 <RaptorRarr> Ahh, OK.
17:03:54 <Peaker> DevHC^: realization is the first step towards improvement :)
17:04:32 <DanBurton> RaptorRarr: also, due to currying, "(a b c) (d e f)" is the same as "a b c (d e f)"
17:04:40 <DevHC^> i think it can be proven, similar to the halting problem, that u can't surely write correct code by "propogating the not considered cases upward"
17:04:43 <RaptorRarr> So, a nice introduction to ($) is that it puts parentheses around everything on the left and everything on the right, I think.
17:04:49 <RaptorRarr> DanBurton: Ahh, Yes.
17:05:30 <DevHC^> the sketch of the proof should be something like: considering impossible cases and propogating them upwards increases the complexity of the code that u'll make coding errors in the propogation parts
17:06:29 <Peaker> monochrom: btw, I find that I mostly use "head" in infinite streams -- where a non-List type would be nice. But that comes to another gripe of mine with Haskell. Everything is so monomorphic that switching from list to any different type (even if it a sub-type that has many of the same opreations) is so painful
17:06:30 <DanBurton> RaptorRarr: you've got the right idea with parentheses. $ is basically defined with the sole purpose of cutting down on parenthesis, but also for its usefulness in higher-order functions
17:07:14 <Peaker> DanBurton: "for the sole purpose ... and also for ..." is self-contradicting :)
17:07:41 <kmc> ($) is just an infix operator of low precdence
17:07:43 <DanBurton> Peaker: yes, hence the "basically", which basically makes it ok
17:07:48 <kmc> it's not special syntax
17:07:48 <ddarius> ($) = id
17:08:03 <ddarius> 1 basically equals 0
17:08:06 <RaptorRarr> Well, there's purpose and accidental side effects.
17:08:16 <RaptorRarr> So, perhaps ($) has evil side effects!
17:08:26 <DanBurton> ddarius: now you're getting it
17:09:10 <kmc> n+1 basically equals n
17:09:15 <kmc> they differ only by O(1) constructors
17:09:22 <Eduard_Munteanu> Well, it is a bit special when used with stuff like runST, I guess.
17:09:51 <DevHC^> i've never got to completely understanding the exact parenthesization of $ and other operators with lower precedence, let-ins, and lambdas
17:09:54 <kmc> there was a special rule in GHC for typing runST $ do ...
17:09:59 <kmc> that's not Haskell, though
17:10:15 <Eduard_Munteanu> ST isn't Haskell :)
17:10:26 <Eduard_Munteanu> Erm, actually, just runST.
17:11:23 <monochrom> haskell is basically basic. both are just plain text files
17:11:33 <DevHC^> for example \x -> \y -> y $ 4. how would u parenthesize this? (\x -> \y -> y) $ 4 or \x -> (\y -> (y $ 4))?
17:11:54 <kmc> \x -> (\y -> (y $ 4))
17:11:54 <RaptorRarr> BASIC is basically evil. Both are words that are used to denote something that should never be used.
17:12:04 <kmc> lambdas extend as far as possible
17:12:18 <DevHC^> and $ is the highest precedence operator
17:12:26 <kmc> lowest
17:12:27 <Eduard_Munteanu> Least.
17:12:34 <DanBurton> This quote should go in the next HWN: http://news.ycombinator.com/item?id=3069307
17:12:34 <kmc> infixr 0 $
17:12:38 <DevHC^> lowest*
17:12:39 <DevHC^> even lower than -> as the statement would imply
17:12:50 <benmachine> -> isn't an operator as such
17:12:51 <benmachine> it's syntax
17:13:07 <DevHC^> which gives us a question: what is teh connection between operators and lambdas?
17:13:24 <kmc> what kind of connection are you looking for?
17:13:39 <DevHC^> the connection which defines parenthesization
17:13:40 <Eduard_Munteanu> Operators are just functions. You usually say "operator" when you mean infix functions.
17:13:43 <kmc> i think your example is resolved by the single rule "lambdas extend as far as possible"
17:14:05 <monochrom> I say "function" for both
17:14:20 <DanBurton> or rather, as far as layout allows
17:14:28 <monochrom> also, the only connection is the grammar
17:15:08 <monochrom> see the Haskell 2010 Report for Haskell's grammar, which "connect"s lambda, operators, and type constructors
17:15:10 <kmc> "The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible."
17:15:17 <kmc> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003
17:15:48 <DevHC^> where "possible" is defined as?
17:16:16 <kmc> the grammar allows n alternative parses; you take the one where the lambda body extends farthest
17:16:18 <monochrom> "possible" = "can be parsed"
17:17:01 <DevHC^> where "parsed" is defined by which element/level of a compiler?
17:17:10 <monochrom> parser. grammar.
17:17:19 <monochrom> see the Haskell 2010 Report for Haskell's grammar
17:17:31 * Eduard_Munteanu wonders about a left-associative ($)
17:17:47 <DevHC^> there's a GHC note related to fixity resolutions or whatever
17:17:57 <DevHC^> where it is noted that "arguably the report is buggy"
17:17:58 <monochrom> actually http://www.hck.sk/users/peter/HaskellEx.htm is a fun way to explore Haskell's grammar, though it's stuck in 98
17:18:14 * DanBurton thinks he saw a haskell wiki thing about left-associative ($) once upon a time
17:18:33 <Eduard_Munteanu> I think that might be useful in a few cases,
17:18:37 <Eduard_Munteanu> s/,/./
17:21:03 <Eduard_Munteanu> Hrm... http://hackage.haskell.org/trac/haskell-prime/wiki/ChangeDollarAssociativity
17:29:52 <mebaran151> what's the best haskell decimal type
17:30:36 <monochrom> pick one from Data.Fixed
17:36:03 <mjonsson> hirsch_, is there a way to parameterize typeclasses with runtime values? For example, creating a Monoid akin to Min/Max that would pick the value closest to x, where x is some runtime integer
17:36:21 <mjonsson> hmm, don't know why that got addressed to hirsh_
17:36:56 <monochrom> you wrote "hi," and auto nick completion
17:37:20 <mjonsson> okay, easy question answered :). On to the hard one
17:37:38 <kmc> mjonsson, "Functional Pearl: Implicit Configurations" by Kiselyov and Shan
17:37:56 <kmc> realized by http://hackage.haskell.org/package/reflection
17:38:15 <mjonsson> kmc, thanks!
17:38:46 <kmc> maybe it's not what you want but sounds vaguely related
17:38:49 <kmc> and it's cool!
17:41:03 <Cale> mjonsson: Not *quite*. Languages in which types can depend on values are known as dependently typed languages.
17:41:20 <Cale> Haskell isn't dependently typed yet, but is slowly moving in that direction.
17:41:59 <Eduard_Munteanu> Real *slow* :P
17:42:08 <dobblego> is there a technical hold-up (i.e. there is an agreed solution, but holding out due to haskell processes)?
17:42:12 <Cale> Not that slowly :)
17:42:31 <ansaksie> Can someone help me? I'm a bit new to all this, and can't figure out how to properly work WinHugs.
17:42:52 <ansaksie> I have a module that I need to load, and I have no idea where to put it so that I can load it without specifying the filename.
17:43:07 <Eduard_Munteanu> ansaksie: mind Hugs is (really) old, you might want to get the latest Haskell Platform instead.
17:43:08 <ansaksie> A minor problem I guess, but it would be really convenient.
17:43:31 <byorgey> dobblego: for what, dependent types?
17:43:35 <dobblego> yeah
17:43:50 <dobblego> clearer: what is the hold-up for introducing DTs?
17:43:53 <ansaksie> Eduard_Munteanu: Thanks, I'll likely do that. I am learning from a book that teaches using Hugs, as well as its own module.
17:43:56 <byorgey> dobblego: I strongly doubt Haskell will ever get true dependent types
17:44:01 <ansaksie> Will using a newer platform disrupt this?
17:44:09 <dobblego> byorgey: why do you believe this? a technical reason?
17:44:23 <byorgey> dobblego: there are several hold-ups: (1) type inference becomes MUCH harder
17:44:43 <Eduard_Munteanu> MUCH impossible, no? :)
17:44:51 <byorgey> dobblego: (2) Haskell has a lovely phase-separation property where types are erased before runtime, and that also becomes much more complicated with full dependent types
17:44:52 <dobblego> OK thanks -- I was hoping a barrier was crossed given the confidence :)
17:45:39 <Eduard_Munteanu> ansaksie: it might not, as long as the book teaches standard Haskell98, but I don't know much about Hugs - GHC differences.
17:45:49 <byorgey> basically what we are moving towards is a situation where you can conveniently "simulate" some aspects of dependent types
17:46:27 <wavewave> probably, agda will be maturized considerably and haskell and agda will have very nice interoperability.
17:46:36 <byorgey> yes, that would be nice.
17:47:17 <ansaksie> Eduard_Munteanu: Is there a difference between GHC and the "Haskell Platform for Windows" that the third hyperlink the topic has lead me to? If that is the case, does GHC work in Windows, and is it recommended over 2011.2?
17:47:22 <ansaksie> Or, wait...
17:47:32 <Eduard_Munteanu> byorgey: I just think it'd require lots of changes, no? Like, what do we do about kinds? Or about parametricity?
17:47:34 <ansaksie> That was a stupid question, I think.
17:47:39 <Cale> ansaksie: GHC comes with the Haskell Platform
17:47:48 <wavewave> finally all the ideas should be implemented in all layers.
17:47:53 <ansaksie> Ok, thanks.
17:48:00 <Cale> ansaksie: The Haskell Platform is just a potentially convenient bundle of Haskell-related packages and stuff
17:48:09 <Eduard_Munteanu> ansaksie: what Cale said, and HP is the recommended way to get a working GHC install along with libraries.
17:48:36 <byorgey> Eduard_Munteanu: it would require completely throwing away several core design principles of Haskell.
17:48:44 * dafis recommends compiling from source
17:48:55 <scooty-puff_> i need to have a stateful monad where i can lookup values at particular offsets quickly and merge them with new values, replacing the old values
17:49:13 <scooty-puff_> my first thought was a State (Array I E) or a ST s
17:49:28 <scooty-puff_> is there a better way, perhaps using laziness?
17:49:33 <Eduard_Munteanu> scooty-puff_: if you're going to use arrays you can use ST and STArrays
17:49:44 <wavewave> State (Array I E) doesn't sound good.
17:49:55 <Cale> Well, why do you say that you need a monad?
17:49:58 <scooty-puff_> is there a way, when using a newtype wrapper around ST, to hide s from the client?
17:50:06 <Eduard_Munteanu> It's ok, but those are immutable arrays, to modify them you have to recreate them.
17:50:21 <Cale> scooty-puff_: No, because that s is what prevents unrestricted side effects from leaking out of the computation
17:50:23 <Eduard_Munteanu> scooty-puff_: not really
17:50:32 <Cale> Well...
17:50:34 <Cale> :)
17:50:35 <wavewave> scooty-puff_ : in many cases, simple fold pattern is enough.. just check whether your problem is in fold pattern.
17:50:49 <Cale> If you want to constrain what sorts of computations you allow
17:50:51 <scooty-puff_> a monad mostly because it models a reader, but the read environment must be updateable, so a state monad, but maybe just forcing it to that
17:51:02 <Cale> and not let the user speak directly about mutable things
17:51:08 <Cale> then it's possible to hide the s
17:51:46 <scooty-puff_> though existential quantification?
17:51:48 <scooty-puff_> *through
17:51:53 <Eduard_Munteanu> scooty-puff_: a simple way to get rid of 's' (and ST) is to wrap that computation inside a 'runST'. :)
17:52:04 <Cale> Through higher rank polymorphism
17:52:05 <mebaran151> as a complete noob, how do you turn a float into a Data.Fixed type
17:52:09 <mebaran151> say for handling money
17:52:17 <Eduard_Munteanu> But yeah, I see why you might not want / be able to do that.
17:52:36 <Cale> mebaran151: realToFrac
17:53:10 <scooty-puff_> so to do it as a fold, would be of type (Successor, Env) -> (Successor, Env), or comparable, so maybe more a monoid?
17:53:20 <Cale> mebaran151: the Real class, kinda strangely named, is for numeric types which have a conversion to Rationals
17:53:37 <Cale> mebaran151: and the Fractional class gives a conversion *from* Rationals
17:54:00 <Eduard_Munteanu> scooty-puff_: if you need a functional structure that allows fast lookups like that you might want to use a Map or IntMap
17:54:04 <scooty-puff_> idea is to simulate instructions to verify them and infer properties about them, without actually executing them; the env holds the stack (its a stack machine), while Successor = Next | Target Offset
17:54:13 <Cale> So if you have a conversion t -> Rational, and Rational -> s, then you can put them together to get t -> s, and that's what realToFrac does in general.
17:54:14 <mebaran151> cool
17:54:53 <Cale> The other main numeric conversion function to know about is fromIntegral
17:54:58 <ansaksie> I have GHCi installed and running now, but where is it on my computer? Haskell Platform\2011.2.0.1? and where do I put my module so that I can load it?
17:54:59 <scooty-puff_> (actually its of type (Successor, Env) -> ([Successor], Env)
17:55:01 <scooty-puff_> )
17:55:05 <Cale> which converts from any integer-like type to any numeric type at all
17:55:17 <scooty-puff_> ansaksie, are you using windows?
17:55:22 <ansaksie> I am.
17:56:25 <scooty-puff_> i don't recall if this is completely correct, but it may update your PATH environment variable
17:56:25 <Eduard_Munteanu> ansaksie: in general, Foo.Bar.Baz should be in Foo/Bar/Baz.hs, as a relative path
17:56:25 <scooty-puff_> such that you can use Start -> Run -> type "cmd"
17:56:25 <Cale> scooty-puff_: Okay, using some form of monad makes a fair amount of sense for modelling a stack machine.
17:56:25 <scooty-puff_> then type ghci
17:56:28 <Eduard_Munteanu> I think it depends where you start your ghci / ghc from.
17:56:55 <wavewave> scooty-puff_ : hmm, i don't understand well, but is it a problem to use State monad with Data.Map or Data.IntMap in that case?
17:57:06 <scooty-puff_> you can use :load <file name> (the colon is required), the file name is relative to where you started ghci
17:57:14 <ansaksie> I can load GHCi from the cmd window, but I am trying to ":load" a module that is not included with the platform.
17:57:27 <ansaksie> But, where does Foo from Foo/Bar/Baz.hs start?
17:57:35 <scooty-puff_> wavewave, it is not - i assume IntMap has much better sharing (though i guess anything is better than Array)?
17:58:07 <dmwit> ansaksie: Put Foo anywhere; then cd to that directory and start ghci from there.
17:58:08 <Eduard_Munteanu> scooty-puff_: for plain lookups Array is faster
17:58:25 <dmwit> ansaksie: For a plain module, put the source anywhere, then cd to that directory, start ghci, and run :load FileName.hs
17:58:31 <Cale> You can also use the :cd command inside ghci to change directory
17:59:19 <scooty-puff_> so if you start ghci in C:\Users\ansakie, and the file is in C:\Users\ansakie\Foo\Bar\Baz.hs, you would type :load Foo\Bar\Baz.hs
17:59:23 <Cale> I don't know how people on Windows manage things, but you'll probably want to put source files somewhere near to whatever directory cmd windows start up in.
17:59:36 <ansaksie> Ah, I see now. Ok...
17:59:40 <ansaksie> now I'm getting an error >_<
17:59:51 <wavewave> scooty-puff_ : if it has a performance problem, later you can simply replace Data.IntMap with STUArray or Hashtable in State monad.
17:59:54 <ansaksie> "Parse error in pattern: n + 1"
17:59:54 <Cale> I guess you could also create a shortcut to ghci with the "Start in" path set appropriately
18:00:04 <Cale> ansaksie: ah, that's a feature that was removed
18:00:10 <Cale> ansaksie: But you can turn it back on
18:00:11 <ansaksie> figures :/
18:00:22 <Eduard_Munteanu> wavewave: UArray maybe
18:00:27 <Cale> {-# LANGUAGE NPlusKPatterns #-} at the top of your file, I think...
18:00:28 <dafis> ansaksie: :set -XNPlusKPatterns
18:00:42 <dmwit> scooty-puff_: Yes; additionally, you could add "module Foo.Bar.Baz" at the top of Foo\Bar\Baz.hs and type :load Foo.Bar.Baz instead.
18:00:43 <Eduard_Munteanu> Since STUArrays can only be inside ST.
18:00:47 <dafis> when you're in ghci
18:01:10 <dmwit> ansaksie: You probably need more parentheses. =)
18:01:11 <ansaksie> ok, neat
18:01:13 <dmwit> oh
18:01:14 <Cale> (It's much easier to put LANGUAGE annotations into the source files, so you don't have to keep setting them)
18:01:14 <Eduard_Munteanu> (runSTUArray executes something on a STUArray and freezes it to an UArray)
18:01:16 <ansaksie> it worked fine for me
18:01:20 <dmwit> Other people know better than me. =)
18:01:29 <ansaksie> Would adding Cale's example to the top of my file make it so I don't have to set that each time?
18:01:35 <Cale> ansaksie: yes
18:01:56 <scooty-puff_> Eduard_Munteanu, possibly unsafe to get to and from MArray? would have to be careful with seq then i imagine..
18:01:59 <wavewave> Eduard_Munteanu: I mean embedding whole setup in ST monad.. assuming update happens during the state monad execution.
18:02:02 <scooty-puff_> maybe anyways?
18:02:15 <ansaksie> Where would I add this line? And what should I use to edit it? I don't know if I trust notepad.
18:02:19 <dafis> ansaksie: the :set is mainly useful for the first time if you don't want to edit the source right now
18:02:23 <Cale> ansaksie: Alternately, you can avoid n+k patterns, and just write foo n = ... n - 1 ...
18:02:36 <Cale> (but sometimes it's nice to have them)
18:02:45 <dafis> ansaksie: the very top of the file
18:03:01 <Cale> ansaksie: you add the pragma right at the top, before any module declarations or anything else
18:03:07 <wavewave> scooty-puff_ : if update doesn't happen in state monad execution, you can just freeze STUArray to UArray and pass it to the State monad state.
18:03:10 <dafis> ansaksie: notepad++ is pretty decent, afaik
18:03:32 <Cale> ansaksie: Whatever editor you choose, just make sure that it has an option to automatically convert tabs to spaces
18:03:38 <scooty-puff_> wavewave, i may just go with a bare ST (the client is me, just wanted a clean separation among modules, maybe just move it all to one module)
18:04:11 <Eduard_Munteanu> StateT over ST might do
18:04:12 <Cale> ansaksie: You generally don't want physical tab characters ending up in your source files, because of how code is sensitive to how things line up.
18:04:25 <Eduard_Munteanu> (there's no (sane) STT, mind)
18:04:50 <Cale> (most decent editors have an option for this)
18:04:51 <wavewave> Eduard_Munteanu: *nod*
18:05:26 <dafis> Cale: I would go as far as to say it's a necessity for a decent editor
18:05:55 <Cale> yeah, it's really the only necessity for an editor to be able to edit Haskell source, imo
18:06:00 * Eduard_Munteanu used some Windows vim port on such occasions.
18:06:25 <Cale> Syntax colouring is nice too, but expanding tabs is #1 on the importance list
18:06:31 <Eduard_Munteanu> Cale: well, it's not like tabs *don't* work.
18:06:40 <Eduard_Munteanu> You just have to be careful.
18:06:50 <geheimdienst> tabs are evil and don't work!!1!
18:06:51 <aatch> Vim with the haskell-indent plugin works well, though there are some instances where it doesn't work properly
18:06:52 <scooty-puff_> as a general question, do you (anyone) use ST regularly?  When dealing with arrays?
18:07:02 <ansaksie> Ok, I have it working now.
18:07:06 <ansaksie> Thanks guys :)
18:07:11 <Eduard_Munteanu> Since they're always 8 spaces-equivalent so if you configure it to show them as 4 spaces things might break.
18:07:18 <Cale> #2 would be understanding layout and causing any edit which moves the first character after a layout keyword to move the remainder of the block analogously, but no editor does this, so it's a moot point.
18:07:26 <geheimdienst> Eduard_Munteanu: "it's not like confused spaghetti code doesn't work, you just have to be careful"
18:07:41 <wavewave> scooty-puff_ : quite a long time ago.... when I just moved from C++
18:07:57 <wavewave> scooty-puff_ : later.. less and less.... and almost nothing.
18:08:12 <scooty-puff_> if it weren't for the s would just use a type synonym, and change it out later
18:08:25 <scooty-puff_> though i understand the safety it provides
18:08:40 <wavewave> scooty-puff_ : simply because Data.Map is fast enough for my purpose. so it may be different in other critical cases.
18:08:51 <Eduard_Munteanu> Cale: GHC treats extra space between tabs as real space?
18:09:10 * hackagebot unix-time 0.0.0 - Unix time parser\/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.0.0 (KazuYamamoto)
18:09:33 <Cale> Eduard_Munteanu: Tabs are treated as aligning to the next multiple of 8 spaces
18:09:38 <Eduard_Munteanu> Ah.
18:09:50 <Eduard_Munteanu> Yeah, then it's not *that* awful.
18:09:56 <Cale> Eduard_Munteanu: It is awful.
18:09:59 <Eduard_Munteanu> :)
18:10:08 <wavewave> and if I really need a state ref very much.... mostly I use IORef as a cheat.. :-P
18:10:29 <Cale> It makes it impossible to communicate code between multiple people, because you can't rely on anyone's editor treating tab characters as 8 spaces.
18:10:33 <Eduard_Munteanu> Cale: I mean, look at Linux kernel code ;)
18:11:43 <shachaf> Eduard_Munteanu: C is different from Haskell.
18:11:52 <monochrom> @quote monochrom c
18:11:53 <lambdabot> monochrom says: Haskell already has natural language support. Just switch your natural language to simple-typed lambda calculus.
18:11:56 <Eduard_Munteanu> FTR, I'm not adamant about this, it's just it's not frowned upon in a lot of circles.
18:11:57 <monochrom> err
18:11:59 <Aatch> Eduard_Munteanu: but C is not whitespace dependent
18:12:00 <monochrom> @quote monochrom einstein
18:12:01 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
18:12:01 <shachaf> @quote monochrom einstein
18:12:02 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
18:12:03 <wavewave> IORef and unsafePerformIO combination... so temptful...
18:12:06 <monochrom> hehe
18:12:23 <scooty-puff_> Reader monad?
18:12:25 <monochrom> recently, we may have to say that haskell cannot be faster than neutrinos, too
18:12:29 <scooty-puff_> sort of..
18:12:51 <Eduard_Munteanu> Or light isn't as fast as c :P
18:13:01 <DanBurton> monochrom: does lambdabot draw from everything you've ever said in its presence, or do you have to tell lambdabot to remember specific quotes?
18:13:10 <wavewave> monochrom: haskell can travel in higher-order function space.. so it can reach somewhere faster than C
18:13:11 <monochrom> have to tell
18:13:25 <DanBurton> aw
18:13:43 <wavewave> if our problem space is quite curved and there is a shortcut by higher order function.
18:13:51 <Aatch> The lambdabot singularity will be when it decides what quotes to save by itself.
18:13:52 <monochrom> the idea is that 99% of what I say is not funny anyway
18:14:04 <DanBurton> true
18:14:05 <incluye> 99% is a little conservative
18:14:17 <Aatch> 98.7%?
18:14:30 <monochrom> 99% +/- 10%
18:14:59 * DanBurton suddenly got tempted to write the plusOrMinus function
18:15:21 <DanBurton> @let x `plusOrMinus` y = [x+y, x-y]
18:15:22 <lambdabot>  Defined.
18:15:22 <monochrom> plusOrMinus :: (Num a) -> a -> a -> Either a a
18:15:47 <Eduard_Munteanu> Aatch: it's not, but lots of C projects have coding styles which make it necessary to indent things nicely and according to some rules. So I guess these mismatches do get caught.
18:15:57 <incluye> @pl \a -> (a+b,a-b)
18:15:58 <lambdabot> liftM2 (,) (b +) (subtract b)
18:16:05 <shachaf> monochrom: plusOrMinus :: a -> a -> [a]
18:16:11 <shachaf> Er, wait.
18:16:13 <incluye> @pl \a b -> (a+b,a-b)
18:16:14 <lambdabot> ap (ap . ((,) .) . (+)) (-)
18:16:15 <DanBurton> > (2 `plusOrMinus` 3) / (1 `plusOrMinus` 3)
18:16:16 <lambdabot>   No instance for (GHC.Real.Fractional [t])
18:16:16 <lambdabot>    arising from a use of `e_12313...
18:16:28 <DanBurton> > (2 `plusOrMinus` 3) * (1 `plusOrMinus` 3)
18:16:29 <lambdabot>   No instance for (GHC.Num.Num [t])
18:16:29 <lambdabot>    arising from a use of `e_12313' at <in...
18:16:38 <incluye> uh, why does that never work.
18:16:39 <DanBurton> aw thought lambdabot had num instances for lists
18:16:48 <incluye> > (ap (ap . ((,) .) . (+)) (-)) 1 3
18:16:48 <Aatch> Eduard_Munteanu: but when the style is broken, its just an annoyance, the tree still builds. In haskell you get a quasi-cryptic "might be an indentation problem" error message
18:16:49 <lambdabot>   (4,-2)
18:17:29 <DanBurton> > 1 + [2,3]
18:17:30 <lambdabot>   No instance for (GHC.Num.Num [t])
18:17:30 <lambdabot>    arising from a use of `e_1123' at <int...
18:17:35 <DanBurton> > 1 + (2,3)
18:17:36 <lambdabot>   (3,4)
18:17:36 <hpaste_> scooty-puff pasted “Array monad, maybe?” at http://hpaste.org/52162
18:17:53 <scooty-puff_> so its a pretty horrible idea, but would mean no s leaks
18:17:58 <dafis> > 1 [2,3]
18:17:59 <lambdabot>   1
18:18:03 <scooty-puff_> but would scale like diffarray i imagine
18:18:19 <incluye> okay so I used that thing up there ^ for the point-free version of plusOrMinus
18:18:22 <incluye> and I get this in ghci
18:18:24 <incluye> No instance for (Monad ((->) a0))
18:18:29 <incluye> arising from a use of `ap'
18:18:31 <incluye> sup widdat
18:18:36 <scooty-puff_> (so its no correct, missing a few type vars in the newtype, but...)
18:18:39 <scooty-puff_> *not
18:18:50 <DanBurton> @let (+-) x y = (x+y,x-y)
18:18:51 <lambdabot>  Defined.
18:19:08 <DanBurton> > 1 +- 2 + 3 +- 1
18:19:10 <lambdabot>   (7,1)
18:19:15 <monochrom> you can, in fact, use the ± symbol
18:19:22 <DanBurton> gasp
18:19:35 <wavewave> scooty-puff_ : what is the purpose of this?
18:19:36 <DanBurton> but that aint on the keyboard :P
18:19:39 <incluye> @let (±) x = (x, -x)
18:19:40 <lambdabot>  Defined.
18:19:42 <incluye> > ±3
18:19:43 <lambdabot>   <no location info>: parse error on input `
18:19:46 <Eduard_Munteanu> scooty-puff_: there's no 's' there anyway
18:19:46 <incluye> okay
18:19:53 <incluye> > (±) 3
18:19:55 <lambdabot>   (3,-3)
18:20:46 <monochrom> if there is no s, there is no "s leak" too
18:20:54 <scooty-puff_> hmm, its rather incorrect
18:21:19 <scooty-puff_> but the idea is to have a data structure to store the actions, then in runArrayT, run an ST action, by parsing the Operation
18:21:20 <Eduard_Munteanu> Anyway, you can't *just* hide ST behind a wrapper.
18:21:41 <DanBurton> > do a <- 2 `plusOrMinus` 1; b <- 3 `plusOrminus` 1; return (a*b)
18:21:43 <lambdabot>   Not in scope: `plusOrminus'
18:21:48 <DanBurton> > do a <- 2 `plusOrMinus` 1; b <- 3 `plusOrMinus` 1; return (a*b)
18:21:50 <lambdabot>   [12,6,4,2]
18:21:56 <wavewave> scooty-puff_ : seems too many stack of monads.
18:22:01 <monochrom> well, this plan is in the vein of "IO semantics by interpreter"
18:22:04 <DanBurton> that's more what I was thinking: nondeterminism
18:22:08 <scooty-puff_> let me correct it (and complete it..)
18:23:31 <Axman6> > 3 ±
18:23:33 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:24:14 <wavewave> how about using simple StateT s m with s = array and rename it with type synonym (or make newtype) and alias get and put function with some meaningful names?
18:24:31 <tsuraan> I'm having problems with (rigid, skolem) types, or something like that
18:24:58 <scooty-puff_> tsuraan, usually it helps to add in a lot of lets and eliminate most (.) uses
18:25:08 <tsuraan> I have a function that returns IO (Either String (Enumerator Builder IO b)), and its result is being given to snap's handleMultipart
18:25:10 <dafis> tsuraan: escaping?
18:25:14 <Cale> tsuraan: that usually means that you have a definition which is less polymorphic than the type signature you gave
18:25:16 <tsuraan> dafis: yeah, that
18:25:24 <Cale> oh, hmm
18:25:43 <Cale> tsuraan: paste the code that it's in on hpaste
18:26:03 <tsuraan> I'll extract what I can...  it's embedded in a few thousand lines of code
18:26:23 * ddarius wonders how tsuraan ended up with a few thousand lines of code.
18:27:11 <tsuraan> several months of typing :-/
18:27:21 <dafis> ddarius: easy, you start with 'module Foo where', then add a noodle and jam it
18:28:22 * wavewave is searching what skolem means. 
18:28:53 <monochrom> beware, many things are called skolem
18:28:55 <ddarius> Skolem is a name.
18:29:07 <wavewave> ah . i see..
18:29:09 <ddarius> Like Thoralf
18:29:18 <monochrom> and Simon
18:29:41 <wavewave> hmm i couldn't find something yet in right context.
18:29:43 <DanBurton> mapM_ (\x -> putStrLn $ "print(" ++ show x ++ ")") [1..3000] -- produces 300 lines of Python code
18:29:50 <hpaste_> tsuraan pasted “skolem” at http://hpaste.org/52163
18:30:06 <DanBurton> *3000
18:30:15 <ddarius> Also, it produces Haskell code.
18:30:28 <tsuraan> and then, if I add a forall a to the download result, I get the next pastie
18:30:33 <monochrom> if you try to write type-incorrect code, you will eventually realize what is skolem here
18:31:05 <ddarius> Skolemization is wonderful, by the way.
18:31:37 <wavewave> tsuraan: seem that you're trying to escape existential type?
18:31:42 * DanBurton is confused by this: "(forall a. Enumerator Builder IO b)" - what's the point of "forall a" when "a" doesn't appear there?
18:31:44 <hpaste_> “not skolem” pasted “tsuraan” at http://hpaste.org/52164
18:31:45 <monochrom> (forall a. Enumerator Builder IO b) is strange
18:32:04 <tsuraan> hehe
18:32:16 <tsuraan> yeah, that was a "forall b." a few minutes ago...
18:32:32 <DanBurton> that would make more sense
18:32:38 <tsuraan> I'm trying to figure out what effect forall has on my errors.  I'm very scientific :-/
18:32:43 <wavewave> it also look like some impredicative types there..
18:33:07 <tsuraan> wavewave: what does that mean?
18:33:16 <wavewave> Either String (forall a. Enumerator Builder IO a)
18:33:34 <wavewave> I heard that recent ghc broke the support for it.
18:33:58 <tsuraan> I'm using 7.0.4
18:34:01 <monochrom> oh, right, Either Blah (forall a ...) won't fly. just won't
18:34:14 <Luke> http://hackage.haskell.org/packages/archive/attoparsec/0.9.1.2/doc/html/Data-Attoparsec-Char8.html I'm reading through the attoparsec docs but can't seem to figure out how to actually construct a Parser
18:34:20 <wavewave> Maybe (forall a. Something a) ... something like that... is called Impredicative types
18:34:33 <tsuraan> does it need to be (forall a. Either Blah (Thinger a)) ?
18:34:42 <wavewave> you need to wrap it in some concrete type.
18:34:53 <monochrom> well, IO (forall a ...) won't fly either
18:35:02 <tsuraan> urk
18:35:53 <wavewave> tsuraan: they are different.. forall outside and forall inside.
18:35:53 <tsuraan> ok, I can change things around a bit then.  I'll pull the entire Enumerator out of that function and build it right before I use it
18:35:57 <incluye> why is forall a not redundant
18:36:27 <monochrom> I actually don't understand why so many forall's
18:37:03 <incluye> doesn't "a" already match everything :|
18:37:10 <tsuraan> I don't know why snap has the forall in its function, because I don't know what forall does, really.  I put the forall's in my functions because I was trying to get ghc to not be angry about a vs. a0
18:37:13 <wavewave> tsuraan: for the time being, whenever you use some existential type, make it as a concrete type.. I am not sure when impredicative type will come back.
18:37:55 <tsuraan> wavewave: can I do that when a library's API has a forall?  Like, http://hackage.haskell.org/packages/archive/snap-core/0.5.4/doc/html/src/Snap-Internal-Http-Types.html#setResponseBody
18:38:00 <scooty-puff_> i assume array update is either O(n) for updates, or perhaps O(1) time, O(n) space?
18:38:09 <wavewave> I mean if you have Maybe (forall a. Some a), then make ExistSome = forall a. Some a and Maybe ExistSome
18:38:12 <monochrom> to begin with, "setResponseBody :: (forall a . Enumerator Builder IO a) -> stuff" is a great way to make your life very hard when you try to craft up an actual parameter. effectively you make "a" dummy.
18:38:31 <scooty-puff_> O(min(n, W)) makes me start to worry about constant factors, both in IntMap and Array
18:39:08 <Axman6> scooty-puff_: what sort fo arrays?
18:39:12 * hackagebot unix-time 0.0.1 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.0.1 (KazuYamamoto)
18:39:24 <monochrom> ok, perhaps setResponseBody really wants "a" to be dummy
18:39:41 <scooty-puff_> Axman6, not any MArray instance
18:39:44 <tsuraan> the "a" passes through to a list of [a] that it gives back to the user
18:40:03 <tsuraan> so it doesn't care about what a is, it just gives it back.  that's what the forall indicates, right?
18:40:12 <monochrom> I see no "[a]" anywhere
18:40:23 <scooty-puff_> speaking of ST s, does the Par monad need an s for similar reasons?
18:40:32 <Axman6> scooty-puff_: then depending on the array you chose, you it's either O(n) or.. something less if you use DiffArray
18:40:45 <tsuraan> monochrom: oops, thinking of a different function
18:41:01 <Axman6> scooty-puff_: no, the Par monad is pure (with schedualers implemented using IO, but not necessarilly)
18:41:14 <wavewave> tsuraan: I am somewhat confused. let me think a little bit
18:41:49 <scooty-puff_> ok
18:41:53 <DanBurton> scooty-puff_:  Data.Sequence update is O(log(i)) http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html#v:update
18:42:08 <Axman6> scooty-puff_: there are guarantees made by the schedualers for the Par monad that guarantee that the results are pure, with the main element of that being IVars (write once mutable variables)
18:43:10 <scooty-puff_> so if an IVar escapes the Par, doesn't matter, its a spark (or whatever) is ensured to have been joined to, so a get elsewhere for it doesn't really matter - just pulls the purely held value
18:44:07 <Axman6> i don't think they can escape, at least not easily. hmm
18:44:20 <Axman6> they're not really useful if they do escape
18:45:13 <Saizan> but it's not a problem if they do
18:45:26 <tsuraan> I changed my download to return the parameters mkEnum requires, and put the mkEnum right in the Snap setResponseBody, and that does work.  I even took out all my forall stuff, and it's happy.  So, at least that works
18:45:50 <wavewave> tsuraan: great.. happy to hear it.
18:46:33 <wavewave> tsuraan: so did you change a code in snap? or all in your code?
18:46:49 <Luke> https://bitbucket.org/bos/attoparsec/src/286c3d520c52/examples/RFC2616.hs#cl-39 in this case I think 'string' takes a ByteString but somehow is passed a [Char]. How does that conversion work?
18:46:59 <Luke> I can't seem to get it working with my compiler
18:47:08 <MatrixFrog> Luke: magic
18:47:13 <tsuraan> wavewave: I didn't change snap; just the function that was returning an enumerator now returns some stuff I use to make an enumerator
18:47:15 <MatrixFrog> Luke: and by that i mean, this: {-# LANGUAGE OverloadedStrings #-}
18:47:36 <Luke> oh thanks
18:47:37 <tsuraan> wavewave: so pretty much just moving my mkEnum call from inside the function to outside the function did the trick
18:47:38 <Luke> haha
18:48:43 <wavewave> tsuraan : I see.. I feel that the snap code will cause some problem to other people..
18:49:14 <DanBurton> @google email snap developer
18:49:15 <lambdabot> http://snaptortoise.com/
18:49:15 <lambdabot> Title: Web Design, development and other solutions in Portland, Oregon - Snaptortoise
18:49:26 <DanBurton> snaptortoise? o_O
18:49:39 <DanBurton> @google email snap developer haskell
18:49:40 <monochrom> I don't like setResponseWhatever being rank-2 this way. it is not like it really needs the effect of the negative forall
18:49:41 <lambdabot> http://snapframework.com/about
18:49:41 <lambdabot> Title: Snap: A Haskell Web Framework: About
18:49:49 <wavewave> tsuraan: it's impredicative type, so given the current ghc status, it will bite some people again with similar problem.
18:50:05 <bobzhang> hi, all, I have an annoying cases, when I generate a list as a result, I always have to reverse the result(which is unnecessary in impure world, here I was mainly concerned about the performance)
18:50:18 <bobzhang> for example : nat :: (Ord a, Num a) => a -> (st -> st) -> st -> [st]
18:50:18 <bobzhang> nat m f st = aux m st [] where
18:50:18 <bobzhang>   aux n x acc | n <= 0 = reverse acc
18:50:21 <bobzhang>               |otherwise = let v = f x in v `seq` aux (n-1) v (v:acc)
18:50:32 <tsuraan> the snap guys normally hang out here, but I don't see them now
18:50:43 <wavewave> bobzhang : would you paste it on hpaste.org?
18:50:50 <monochrom> whati is nat supposed to do?
18:51:00 <tsuraan> they also used to have a bot that relayed comments with the word "snap" to their channel, but that seems to have broken down
18:51:01 <bobzhang> wavewave: I see, thank you
18:51:18 <bobzhang> monochrom: it's just do some function n times, and collect the result
18:51:52 <wavewave> interesting.. this is the second time I saw impredicative type in production code.
18:52:01 <wavewave> first one was grapefruit.
18:52:10 <wavewave> second is snap..
18:52:13 <bobzhang> in impure world, the reverse can be reduced, how can I reduce such overhead in pure functional programing??
18:52:24 <monochrom> nat 0 f st = []; nat n f st = let v = f st in v `seq` v : nat (n-1) f v
18:52:40 <monochrom> sorry, wrong order
18:53:11 <monochrom> no, right order
18:53:36 <Axman6> bobzhang: looks a lot like:
18:53:37 <Axman6> nat :: (Ord a, Num a) => a -> (st -> st) -> st -> [st]
18:53:37 <Axman6> nat n _ _  | n <= 0 = []
18:53:37 <Axman6> nat n f st = let v = f st in  v `seq` v : nat (n-1) v
18:53:50 <bobzhang> monochrom: you are right, but there are cases, reverse can not be reduced
18:54:01 <monochrom> not this case
18:54:33 <Axman6> bobzhang: there's no need at all for the reverse
18:54:54 <Axman6> in fact, that functions is exactly: take n . iterate f
18:55:01 <Axman6> well, apart from the seq
18:55:03 <monochrom> [politician mode] I won't comment on hypothetical, unsaid cases [/politician mode]
18:55:06 <bobzhang> Axman6: I see, I should find another example
18:55:28 <ddarius> @google Recycling Continuations
18:55:30 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=817D008770D8BE9589D833943264F381?doi=10.1.1.34.4440&rep=rep1&type=pdf
18:55:30 <lambdabot> Title: Recycling Continuations fjsobel, dfriedg@cs.indiana.edu
18:56:32 <Axman6> > take 10 . iterate (^2) $ 2
18:56:34 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
18:57:20 <DanBurton> bobzhang: if you are inspecting the entirity of a list, then the time complexity will not increase if you also reverse the list
18:58:27 <bobzhang> DanBurton: I know lazy evaluation can rescue sometimes, but there are other cases it cannot
18:59:43 <Axman6> bobzhang: compilers will never be able to completely eliminate highly inefficient user written code
18:59:57 <monochrom> I know lazy evaluation, and I actively exploit it rather than blind-guess and hope it rescues me
19:00:02 <Axman6> there will always be a job for programmers to write efficient code
19:01:04 <DanBurton> correction - there will always be a job for programmers to write code to share pictures of cats
19:01:16 <monochrom> haha
19:01:39 <Axman6> @remember DanBurton correction - there will always be a job for programmers to write code to share pictures of cats
19:01:40 <lambdabot> Done.
19:02:35 <mikeplus64> a function from Graphics.UI.SDL.Primitives (pixel) is used like "pixel surface x y (Pixel somenumber)", how do I map a list (for the x and y coordinates (eg [0..512] and [0..512] for x and y)) to the x and y arguments of the function?
19:03:47 <wavewave> bobzhang: maybe this link is helpful to you : http://unspecified.wordpress.com/2010/03/30/a-doubly-linked-list-in-haskell
19:03:52 <DanBurton> mikeplus64: not sure I understand. What does your input list look like?
19:04:17 <bobzhang> wavewave: very useful, thanks!
19:04:34 <wavewave> bobzhang: you need to change fromList with your generator of the list.
19:04:36 <parcs> mikeplus64: forM_ xs $ \x -> forM_ ys $ \y -> pixel surface x y (Pixel somenumber)
19:04:48 <mikeplus64> DanBurton: what I'm trying to achieve is running pixel for every pixel on the screen
19:05:00 <mikeplus64> thanks parcs
19:05:54 <parcs> or forM [ (x, y) | x <- xs, y <- ys ] $ \(x, y) -> ..
19:05:58 <Axman6> mikeplus64: or sequence $ liftM2 (\x y -> pixel x y (Pixed somenumber) xs ys
19:06:04 <shachaf> forM_ (liftM2 (,) xs ys) $ \(x,y) -> ... Yes, that.
19:06:42 <mikeplus64> now I have some looking up to do on those functions :)
19:06:45 <Axman6> sequence $ liftM2 (\x y -> pixel x y (Pixed somenumber)) xs ys
19:06:58 <Axman6> @pl (\x y -> pixel x y (Pixed somenumber))
19:06:59 <parcs> lol
19:06:59 <lambdabot> flip flip (Pixed somenumber) . pixel
19:07:07 <Axman6> heh
19:07:12 <parcs> can you guys be more cryptic :P
19:07:28 * DanBurton loves it when lambdabot does flips
19:07:51 <shachaf> @unpl flip flop
19:07:51 <lambdabot> (\ b c -> flop c b)
19:07:59 <DanBurton> @pl (\x y z -> f z x y)
19:07:59 <lambdabot> flip . flip f
19:08:00 <ion> @unpl jump through the hoop
19:08:00 <lambdabot> jump through the hoop
19:08:01 <RaptorRarr> @unpl flip flip
19:08:02 <lambdabot> (\ b c f -> c f b)
19:08:10 <Axman6> what about: sequence $ (\x y -> pixel x y (Pixel somenumber)) <$> ys <*> ys
19:08:15 <Axman6> uh, xs <*> ys
19:08:31 <RaptorRarr> @unpl (flip .) flip
19:08:31 <lambdabot> (\ j b c -> j b c)
19:08:36 <RaptorRarr> Yay!
19:08:41 <ion> ys <*> ys is just fine (invariant: the image is square)
19:08:51 <Axman6> indeed
19:09:05 <RaptorRarr> @. pl unpl (flip .) flip
19:09:05 <lambdabot> id
19:09:12 <DanBurton> @pl \ys -> ys <*> ys
19:09:13 <lambdabot> join (<*>)
19:10:06 <ion> @pl \f xs ys -> (f <$> xs) <*> ys
19:10:06 <lambdabot> ((<*>) .) . (<$>)
19:10:34 <ion> @@ @unpl @pl \f xs ys -> f <$> xs <*> ys
19:10:34 <lambdabot>  (\ g m d -> g <$> (m <*> d))
19:10:46 <DanBurton> pretty good
19:11:00 <DanBurton> @botsnack
19:11:01 <lambdabot> :)
19:11:13 <ion> That’s actually incorrect. {,un}pl don’ seem to know the fixities of the operators.
19:11:22 <ion> @@ @unpl @pl \f xs ys -> (f <$> xs) <*> ys
19:11:23 <lambdabot>  (\ d g -> (<*>) (d <$> g))
19:12:23 <ion> @type ((\f x y -> f <$> x <*> y), (\f x y -> f <$> (x <*> y)))
19:12:24 <lambdabot> forall a a1 b (f :: * -> *) a2 b1 (f1 :: * -> *) a3. (Applicative f, Applicative f1) => ((a -> a1 -> b) -> f a -> f a1 -> f b, (a2 -> b1) -> f1 (a3 -> a2) -> f1 a3 -> f1 b1)
19:12:29 <DanBurton> ion: aren't they associative?  I thought "(a <$> b) <*> c" would be the same as "a <$> (b <*> c)"
19:12:57 <DanBurton> @type \a b c -> (a <$> b) <*> c
19:12:58 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
19:13:06 <DanBurton> @type \a b c -> a <$> (b <*> c)
19:13:07 <lambdabot> forall a b (f :: * -> *) a1. (Applicative f) => (a -> b) -> f (a1 -> a) -> f a1 -> f b
19:13:25 <DanBurton> guess not
19:13:27 <RaptorRarr> DanBurton: I think b <*> c requires that b be a wrapped function.
19:13:49 <RaptorRarr> Or something.
19:13:54 <shachaf> Wrapped in a burrito?
19:14:02 <DanBurton> yes
19:14:13 <DanBurton> an applicative burrito
19:14:41 <companion_cube> you tae a burrito of functions and apply them to a burrito of arguments
19:14:43 <companion_cube> take
19:14:46 <wavewave> bobzhang: http://www.haskell.org/pipermail/haskell-cafe/2009-January/052802.html : this is also useful..
19:14:56 <companion_cube> it's called "applicative mexican cooking"
19:15:45 <wavewave> implementing doubly linked list in haskell is fun.
19:16:18 <wavewave> in fact it's zipper.
19:17:16 <wavewave> ah.. I am hungry..
19:17:29 <wavewave> don't say about burrito. ;-P
19:18:54 <monochrom> should I say something gross to help you?
19:19:00 <ddarius> quesadilla?
19:19:02 <mizu_no_oto> @pl \x y-> max ((+1) x) ((+1) y)
19:19:03 <lambdabot> (. (1 +)) . max . (1 +)
19:19:10 <monochrom> such as C code and excretions...
19:20:50 * wavewave found grapes in the refrig. ;-D
19:21:52 <wavewave> I don't like Applicative burrito. I like FingerTree grape.
19:22:49 * DanBurton is hungry now >,<
19:23:44 <monochrom> C code and monads like nose excretions...
19:24:58 <wavewave> monochrom: you mean monad in C? or monad general?
19:25:15 <monochrom> monad in nose excretions
19:25:44 <RaptorRarr> I like this food-based metaphor for abstract topics.
19:25:56 * RaptorRarr sharpens his claws.
19:26:03 <monochrom> arrows are like tears
19:26:18 <RaptorRarr> Arrows are like claws!
19:27:08 <wavewave> monad is trousers.
19:27:15 <monochrom> applicative is like nose excretion in air-unpolluted places, i.e., white, not dark or green
19:27:40 <RaptorRarr> This is not helping my appetite.
19:27:43 * monochrom has lived both in Hong Kong and Canada. the constrast is stark
19:28:12 <monochrom> oh, I'm indeed helping people to become unhungry!
19:28:45 <monochrom> anyway, the idea is that applicative is cleaner than monad :)
19:29:23 <Clint> which one was the less-polluted place?
19:29:29 <monochrom> Cananda
19:29:39 <wavewave> absolutely.
19:31:18 <RaptorRarr> Canada is composed of people who like freezy cold places, so there aren't very many of them.
19:31:38 <RaptorRarr> Hong Kong is composed of people who like cities and Chinese food, so you know there are going to be lots of people packed in there.
19:32:48 <peng__> can it be possible using Haskell to write a 2D graphics engine
19:33:06 <RaptorRarr> Why yes.
19:33:10 <monochrom> have you already written a 2D graphics engine?
19:33:35 <peng__> no, i am just wondering...
19:33:50 <monochrom> will you write one?
19:34:08 <wavewave> check diagrams library.
19:35:03 <wavewave> http://projects.haskell.org/diagrams
19:35:31 <DanBurton> @faq can I use Haskell to write a 2D graphics engine?
19:35:31 <lambdabot> The answer is: Yes! Haskell can do that.
19:36:06 <DanBurton> @google gloss haskell
19:36:08 <lambdabot> http://hackage.haskell.org/package/gloss-1.0.0.1
19:36:08 <lambdabot> Title: HackageDB: gloss-1.0.0.1
19:36:14 <peng__> i don't know. What do you think? Will it be effeicient enough?
19:36:34 <wavewave> @google diagrams haskell
19:36:35 <lambdabot> http://hackage.haskell.org/package/diagrams
19:36:35 <lambdabot> Title: HackageDB: diagrams-0.3
19:36:40 <wavewave> aha.
19:36:57 <DanBurton> peng__: efficient enough for what?
19:37:25 <wavewave> peng__ : what would you like to do?
19:38:22 <monochrom> I think there are enough 2D graphics engines out there already. don't write one to compete. write one for self enjoyment. hence, speed is not important enough.
19:38:54 <wavewave> check also nikki and the robots : 2D game being written in haskell
19:39:03 <DanBurton> @where nikki
19:39:04 <lambdabot> I know nothing about nikki.
19:39:07 <DanBurton> boo
19:39:30 <DanBurton> @where+ nikki http://joyridelabs.de/game/
19:39:30 <lambdabot> It is stored.
19:39:31 <peng__> hum.. just curious about can use Haskell's laziness and other features to compensate its inefficiency in rendering...
19:40:08 <hpaste_> “Can anyone make this code less ugly?” pasted “elliott” at http://hpaste.org/52166
19:41:12 <peng__> have anyone written one before?
19:41:29 <wavewave> peng__ : I don't get its inefficiency in rendering.. in fact all 2d rendering library in many language is just foreign function interface to C lib or something.
19:41:45 <wavewave> haskell is not different.
19:42:01 <peng__> what about no FFI
19:42:41 <wavewave> peng__ : then no graphics library at all.
19:43:06 <wavewave> peng__ : at a certain point, it must access OS graphics library.
19:43:44 <DanBurton> elliott: still playing around trying to figure out the point of that function
19:44:01 <elliott> DanBurton: cutoff "..." 80 xs will format xs for an 80-column terminal
19:44:02 <wavewave> peng__ : I think practical question is whether there are many haskell library for graphics.
19:44:02 <peng__>  why?
19:44:09 <elliott> DanBurton: ending with an ellipsis if it would be too long
19:44:16 <elliott> I hoped the comment would be enough to make it clear :-)
19:44:35 <elliott> DanBurton: you might use a string other than "...": e.g. a unicode ellipsis
19:44:42 <wavewave> peng__  : because it's a program on OS. ?
19:44:50 <elliott> i'm fine swapping the end and n arguments, also
19:44:52 <elliott> if it makes it nicer
19:45:28 <elliott> argh, I mixed up author and title again
19:46:04 <DanBurton> elliott: I think that's about as good as it gets; I don't see any ways to do it better
19:46:11 <peng__> certainly, it has to cooperate with OS to get hardware resources, but what i mean is using Haskell to implement rendering.
19:46:25 <elliott> DanBurton: A shame. The case annoys me.
19:46:32 <DanBurton> elliott: besides perhaps putting the case in a where clause
19:47:12 <peng__> like drawing a line, there are lots of choises how to draw this.
19:49:40 <wavewave> peng__ : i think haskell can do fairly good job for some low-level operation.
19:50:08 <wavewave> peng__ : of course, it may not be its best area.
19:50:51 <mikeplus64> ok, so I have "sequence $ liftM2 (\x y -> pixel screen x y (Pixel 0xffffffff)) [0..512] [0..512]", but now I want to do make "0xffffffff" be say x*y, or x+y or some other rule. In C the code would be "for(x=0; x<512; x++){for(y=0; y<512; y++){pixelRGBA(screen, x, y, x*x*y, x*x*y, x*x*y, 255);}}"
19:50:52 <wavewave> peng__ : note that any numerically intensive code ends up with lots of FFI anyway.
19:51:02 <mikeplus64> but I can't get my head around how I would do this in haskell
19:51:10 <wavewave> especially matrix operation.
19:51:30 <wavewave> there are so good optimized near-assembly library.
19:51:41 <elliott> mikeplus64: sequence $ liftM2 (\x y -> pixel screen x y (Pixel (x*y)) [0..512] [0..512]
19:52:04 <elliott> mikeplus64: nicer: sequence [pixel screen x y $ Pixel (x*y) | x <- [0..512], y <- [0..512]]
19:52:11 <wavewave> and haskell is quite good in FFI in my opinion. so overally, not a bad choice for rendering.
19:52:17 <mikeplus64> elliott: doesn't work
19:52:20 <mikeplus64> (the first one)
19:52:20 <RaptorRarr> Yeah, list comprehensions are closer to C loops.
19:52:33 <elliott> mikeplus64: then the bug is not in 0xffffffff but in something else.
19:52:42 <RaptorRarr> You can also use forM_ with the list monad.
19:52:49 <RaptorRarr> forM
19:53:00 <elliott> you can use forM_ and skip the list monad entirely
19:53:02 <peng__> hum, good to hear that, wavewave.
19:53:04 <mikeplus64> x*y has to be Word32
19:53:12 <mikeplus64> how would I convert it?
19:53:17 <elliott> mikeplus64: fromIntegral
19:53:42 <wavewave> peng__ : although not now, in near-future, we will also have very nice support for parallel computation in haskell.
19:53:47 <mikeplus64> alright
19:53:50 <mikeplus64> thanks
19:53:50 <elliott> wavewave: Um.
19:53:52 <elliott> wavewave: We have that today.
19:54:47 <wavewave> my criterion is a little high. I think we need to get over some huddle.
19:54:49 <peng__> are you one of the developer?
19:55:18 <elliott> mikeplus64: ...note that if [0..512] really /is/ your data source, then that code /will/ work
19:55:25 <elliott> but presumably you have some list out of your control of the wrong type
19:56:30 <wavewave> my criterion on nice support in parallel computation will be : very consistent scale-up
19:57:02 <mikeplus64> elliott: nope, it is my data source
19:57:09 <wavewave> industry-ready.
19:57:13 <elliott> mikeplus64: then that code should work with no fromIntegral. what error are you getting?
19:57:17 <elliott> wavewave: Web scale?
19:57:20 <ddarius> Program sequentially.  That has extremely consistent scaling.
19:57:38 <rwbarton> it should be [0..511], btw, to match that C code
19:57:54 <wavewave> ddarius: yeah... that's true..
19:58:34 <mikeplus64> elliott: http://hpaste.org/52167
19:58:53 <elliott> mikeplus64: can you show me the actual line in question?
19:59:04 <mikeplus64> sequence [pixel screen x y $ Pixel (x*y) | x <- [0..512], y <- [0..512]]
19:59:09 <mikeplus64> that is literally the line
19:59:29 <mikeplus64> I'm running pixel for every pixel in the window (which is 512 wide, 512 high)
19:59:38 <mikeplus64> then doing SDL.flip
20:00:19 <rwbarton> looks like pixel expects arguments of type Int16
20:00:27 <elliott> oh, I see
20:00:28 <rwbarton> and Pixel a value of type Word32
20:00:31 <elliott> yeah ok
20:00:33 <mikeplus64> yeah
20:00:35 <elliott> I missed that x and y were used twice ther
20:00:35 <elliott> e
20:00:40 <Cale> fromIntegral
20:00:45 <elliott> Cale: yes, we established that :P
20:01:00 <wavewave> very stabilized Repa, Accelerate, DPH... may be the milestone.
20:01:06 <mikeplus64> that works
20:01:35 <hpaste_> DanBurton annotated “elliott” with “elliott (annotation)” at http://hpaste.org/52166#a52168
20:02:22 <RaptorRarr> For a little more separation: screenOPixelsUsing f = sequence [pixel screen x y $ Pixel (f x y) | x <- [0..512], y <- [0..512]]
20:02:24 <elliott> hpaste_: that looks a bit nicer, thanks
20:02:33 <RaptorRarr> Then, you can just do screenOPixelsUsing (*)
20:02:38 <elliott> mikeplus64: btw, you will find that rendering in this manner is incredibly slow
20:02:47 <mikeplus64> yeah
20:02:57 <mikeplus64> it's extremely slow compared to my C one
20:03:18 <elliott> mikeplus64: doesn't matter, it's not a viable rendering strategy in any language :P
20:03:21 <wavewave> also community-wide established idiom for Par monad or parallel strategies
20:03:22 <elliott> whether you can microoptimise it or not
20:03:33 <mikeplus64> what should I be doing then?
20:03:54 <elliott> mikeplus64: using drawing primitives from sdl? or, even better: using opengl?
20:04:16 <elliott> it depends on what you're doing
20:04:56 <mikeplus64> that's what I'm doing
20:05:09 <mikeplus64> using Graphics.UI.SDL.Primitives
20:05:26 <elliott> mikeplus64: primitives other than "pixel". :p
20:05:38 <DanBurton> so I tried to cabal install repa...but it says I need base-4.4.* :(
20:05:40 <elliott> still, sdl is not a very scalable design
20:05:56 <elliott> DanBurton: install a slightly older repa
20:06:15 <parcs> mikeplus64: try doing explicit recursion instead of creating a list [0..512]
20:06:42 <DanBurton> I wish cabal install was smart enough to find a sufficiently old version that is compatible with my current setup
20:06:43 <elliott> parcs: I doubt that will help much, if at all.
20:07:06 <parcs> i think it will help
20:07:09 <parcs> how much idk
20:07:23 <elliott> A loop like this, if mikeplus64 is expecting to animate things in real time or whatever, will only work in pathological cases, i.e. when it can be micro-optimised into oblivion.
20:08:04 <DanBurton> is there a way to see what version of base I have?
20:08:12 <mikeplus64> http://codepad.org/coVDFHAM basically I'm trying to get something similar to this, but in Haskell
20:08:15 <mikeplus64> (
20:08:26 <wavewave> ghc-pkg list base
20:08:27 <mikeplus64> (that's a horrible little C program that'll draw and animate a mandelbrot set)
20:08:59 <elliott> mikeplus64: You'll want to render to an array and then blit that rather than going through the primitives, if you really want to render like this.
20:09:23 <mikeplus64> well if there is a better way to render then sure
20:09:48 <mikeplus64> but I'm a complete noob and this is easy for me
20:10:09 <elliott> there is probably no better way to render a mandelbrot set that doesn't involve getting it to run on the gpu :P
20:10:15 * DanBurton is struggling with Haskell dependency hell right now :(
20:10:24 <mikeplus64> haha
20:10:54 <wavewave> DanBurton: post a log on the hpaste.
20:11:12 <wavewave> DanBurton: if you need some help.
20:11:23 <DanBurton> wavewave: finally got it installing with "cabal install 'repa < 2.0' "
20:11:57 <wavewave> ah. good. which library has that dependency?
20:12:02 <mikeplus64> the C version at least runs very fast (on my computer) it's just I have no clue how to translate it to Haskell
20:12:11 <elliott> davean_: umm
20:12:14 <elliott> erm
20:12:16 <elliott> DanBurton: umm
20:12:20 <elliott> DanBurton: enjoy your version from May 7 06:01:24 UTC 2010
20:12:36 <hpaste_> DanBurton pasted “dependency hell :(” at http://hpaste.org/52169
20:12:57 <elliott> DanBurton: upgrade ghc :P
20:13:19 <DanBurton> elliott: school computers ftl
20:13:32 <Cale> DanBurton: template-haskell-2.5.0.0 is what comes with ghc 7.0.3
20:14:02 <wavewave> you can install ghc on your own directory.
20:14:27 <DanBurton> TIL to get a package to install, just try slowly lowering the version number with "cabal install 'pkgname < version' "
20:14:31 <wavewave> I am always installing like that.
20:14:46 <DanBurton> really? nice
20:14:51 <Cale> I don't think you can install repa 2.x with ghc 6.x
20:15:18 <DanBurton> I am already pushing close to my limit though with my user-space cabal installs
20:15:27 <mikeplus64> does anybody know of some examples of drawing 2D in real-time in haskell? I feel like a headless chicken
20:15:48 <wavewave> DanBurton: install ghc separately from haskell-platform using ./configure --prefix=directory_you_want_to_install
20:15:53 <DanBurton> mikeplus64: as opposed to fake time?
20:16:06 <wavewave> and install haskell-platform from source (which does not have ghc)
20:16:14 <mikeplus64> DanBurton: as opposed to saving to an image instead of rendering it updating on the screen
20:16:34 <Cale> wavewave: I can give some examples of using gloss
20:19:01 <DanBurton> mikeplus64: are you trying to do 2D animation? or just 2D static images?
20:19:43 <mikeplus64> DanBurton: what I'm trying to do is render fractals and the like, but animated ones (see http://codepad.org/coVDFHAM for an example of what I mean)
20:19:51 <DanBurton> Cale: I want to see a simple example of animateInWindow
20:20:01 <wavewave> If your system is very old linux (like RHEL5), ghc 7 binary will not be installed.. then from ghc6, you can bootstrap it.
20:20:09 <wavewave> I learned it very recently.
20:21:08 <mikeplus64> DanBurton: if you want to compile the above you'll need SDL and SDL_gfx, btw
20:21:09 <DanBurton> wavewave: cool, thanks.
20:22:35 * wavewave feels that these days dependency hell problem became easier and easier...
20:22:56 <wavewave> worst time was mtl-1 / mtl-2 change period.
20:23:02 * DanBurton feels that all problems become easier with #haskell irc
20:23:58 * ddarius feels that all problems become easier with lachryma papaveris.
20:24:02 <cheater> wavewave: oh interesting, how would you do that?
20:24:11 <hpaste_> Cale pasted “Fun with gloss” at http://hpaste.org/52170
20:24:16 <Cale> wavewave: ^^
20:24:55 <wavewave> cheater: hmm, what is 'that' you mean?
20:25:27 <cheater> you said you came up with something using the state monad :)
20:25:40 <wavewave> ah..
20:26:18 <wavewave> cheater : hpaste.org/52153
20:26:34 <Cale> wavewave: did you try it? :)
20:26:42 <wavewave> cheater : Twisted is actually State monad.
20:27:06 <wavewave> Cale: I am downloading gloss. thanks. ;-)
20:27:14 <cheater> l@@king
20:29:25 * DanBurton is staring at the pretty colors of Cale's spinning gloss example
20:32:52 <ddarius> Cale: Not Newton-Raphson of the cubic?
20:33:02 <warpy> :O i had a good night's sleep and Cale is still up!
20:33:03 <Cale> hm?
20:33:19 <Cale> warpy: time zones
20:34:18 <elliott> OR, Cale is a robot.
20:34:27 <elliott> I'm sure we all can decide for ourselves which of these is more likely.
20:35:09 <DukeDave> Lol
20:35:19 <wavewave> Cale: oh this is cool.
20:35:40 <cheater> wavewave: how does unTwisted work?
20:35:41 <hpaste_> DanBurton annotated “Fun with gloss” with “Fun with gloss (spin different directions)” at http://hpaste.org/52170#a52171
20:36:17 <wavewave> cheater: this is a State monad.
20:36:22 <wavewave> @src State
20:36:23 <lambdabot> Source not found. stty: unknown mode: doofus
20:36:35 <wavewave> @src Control.Monad.State
20:36:36 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:37:03 <monochrom> State is now a typedef of StateT Identity
20:37:14 <wavewave> newtype State s a = State { runState :: s -> ( s, a ) }
20:37:29 <wavewave> unTwisted = runState
20:37:30 <MatrixFrog> http://learnyouahaskell.com/for-a-few-monads-more#state
20:37:33 <DanBurton> o_O is that how all the cool monads are going to work now, by simply being MyMonadT Identity?
20:37:52 <elliott> DanBurton: "are going to"?
20:37:59 <elliott> that's how they've worked for quite a while
20:38:09 <monochrom> yes in recent version of mtl
20:38:14 <MatrixFrog> that link claims it works like wavewave said, even though i guess it technically doesn't anymore
20:38:15 <elliott> even before they were literally that, they were semantically identical :P
20:38:27 <DanBurton> well sure
20:38:32 <MatrixFrog> DanBurton: all except IO, the coolest one of all
20:38:33 <cheater> wavewave: but you're not actually using the State monad there, right? you're building this whole thing from ground up?
20:38:35 <monochrom> yes, LYAH was written before the mtl switch
20:38:50 <cheater> monochrom: what is the mtl switch?
20:39:27 <monochrom> mtl version 1 uses "newtype State s a = State { runState :: s -> ( s, a ) }". mtl version 2 uses "type State s a = StateT s Identity a"
20:40:06 <wavewave> cheater: yeah.. stupidly I did it. since it was designed in some other way, finally I end up with just State monad..
20:40:21 <cheater> hmmmmm
20:40:38 <cheater> i'll have to think longer about it :D
20:41:05 <wavewave> so in practice, you just use state monad which has Success|Failure state.
20:42:06 <wavewave> cheater: anyway, point is that state monad carries oldstate -> (newstate, result) inside.
20:42:37 <wavewave> oldstate is Success | Failure, newstate is Success | Failure
20:42:52 <wavewave> so it has four possible cases in it.
20:43:50 <wavewave> and the new state is passed to next state monad's oldstate.
20:44:26 <wavewave> that's how >>= is implemented and it behaves the same as the twistedmatrix in python
20:44:48 <cheater> interesting
20:44:57 <wavewave> oldstate -> (newstate, result) is an analog of python callback in the python example.
20:45:05 <cheater> monochrom: what is mtL
20:45:09 <wavewave> callback+errback.
20:45:19 <cheater> monochrom: what is mtl? sorry typo
20:45:26 <kmc> cheater, http://hackage.haskell.org/package/mtl
20:45:34 <cheater> thx
20:45:41 <kmc> it's a standard monads library that comes with the Platform
20:45:59 <wavewave> cheater: so to understand this clearly, I recommend to read a book like LYAH or RWH.
20:46:03 <kmc> mtl-1 was a competitor to 'transformers' but mtl-2 is built on top of 'transformers'
20:46:15 <cheater> why was it a competitor
20:46:36 <wavewave> understanding state monad is a key to understand monad in general.
20:46:50 <kmc> Twisted is a burrito?
20:47:09 <wavewave> kmc: yes.
20:48:45 <wavewave> cheater: in fact using get and put method in State, I can write the action1 and action2 more clearly.. okay.. wait
20:51:45 <cheater> interesting
21:03:51 <hpaste_> wavewave pasted “twistedmatrix using state monad” at http://hpaste.org/52173
21:04:35 <wavewave> oops
21:06:26 <hpaste_> wavewave pasted “twistedmatrix using state monad” at http://hpaste.org/52174
21:07:37 <wavewave> cheater : see the code http://hpaste.org/52174
21:07:42 <wavewave> not 52173.
21:07:48 <wavewave> copy and paste mistake.
21:08:44 <wavewave> using just standard state monad.
21:09:05 * elliott wonders if wavewave is intentionally referencing the Python framework.
21:09:09 <elliott> And if so, what the relevance is.
21:09:25 <wavewave> elliott: ah... that was cheater's original question.
21:11:10 <milkpost> anyone know how to change the date/time output format of darks?
21:11:11 <wavewave> http://twistedmatrix.com/documents/current/core/howto/defer.html
21:11:15 <milkpost> darcs even
21:11:38 <wavewave> elliott : cheater asked if this can be implemented using monad in haskell.
21:11:45 <elliott> ah.
21:11:55 <elliott> wavewave: That looks like Cont, not State, to me.
21:12:06 <elliott> In which case the answer would be that it's completely unnecessary with GHC's event manager IO model.
21:12:21 <wavewave> elliott: in fact, that was exactly what I started from..
21:12:31 <wavewave> elliott: but in fact.. state is just good.
21:12:39 <elliott> If it's for some non-IO purpose then it literally just looks like manual continuation-passing style to me... which is of course horrible to write; thankfully we have the abstraction of the Cont monad to avoid that.
21:13:37 <wavewave> yes. that's true. Deferred object is generally continuation.
21:13:58 <wavewave> in twisted matrix.. simply there is a fixed boolean state in it
21:14:12 <wavewave> so implementation is isomorphic to state monad..
21:16:09 <wavewave> so i was scratching from type signatures of continuation and after concretize Result type, it just became state monad.
21:33:47 <shachaf> Is there a reasonable way to find the smallest key >= a certain key in a Map?
21:34:17 <shachaf> I guess there's split.
21:37:58 <wavewave> shachaf: what's a problem with using dropWhile (<k) . keys   something like that?
21:38:46 <wavewave> keys is O(n). sounds reasonable.
21:38:56 <shachaf> wavewave: That it'll scan through the entire Map?
21:39:04 <shachaf> Why is O(n) reasonable?
21:39:17 <wavewave> ah.. you need O(log n)?
21:40:22 <shachaf> Well, presumably that's the point of a Map.
21:40:59 <dolio> Not really.
21:41:09 <dolio> It's the point of a search tree.
21:41:19 <dolio> Which is how Data.Map happens to be implemented.
21:41:39 <srh> shachaf: haskell doesn't have high-quality libraries the way C++ does
21:42:14 <shachaf> srh: I know, it's a big problem. I wish Haskell was as cool as C++.
21:43:37 <Cale> srh: lol
21:43:56 <shachaf> srh: What are you doing in here, anyway?
21:43:58 <shachaf> @quote srh
21:43:59 <lambdabot> No quotes match. Are you on drugs?
21:44:18 <shachaf> @quote sarehu
21:44:19 <lambdabot> sarehu says: <magnus_> are there any recommendations for module names? <sarehu> how about "Trogdorothy"
21:44:32 * hackagebot wai-app-file-cgi 0.3.4 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.3.4 (KazuYamamoto)
21:44:34 <srh> shachaf: getting in touch with my functional side
21:44:35 * hackagebot webserver 0.4.6 - HTTP server library  http://hackage.haskell.org/package/webserver-0.4.6 (KazuYamamoto)
21:45:05 <Cale> You might find most C++ libraries to be pretty painful to have to use after learning Haskell.
21:46:01 <srh> Only other people's C++ libraries.
21:46:12 <shachaf> You can find most of the cool people using C++, though. In C++ syntax you can just chill and do whatever and totally relax.
21:46:57 <RaptorRarr> Type errors are a thing of the past.
21:47:23 <RaptorRarr> You just have to analyze the bit patterns that will be written and read them back properly.
21:47:24 <pikhq> RaptorRarr: Instead, you just get type-level _|_.
21:47:50 <RaptorRarr> Which is easy, since you're all techy and like puzzles like that.
21:48:14 <RaptorRarr> pikhq: Yeah, that's so that we can write fibonacci in the type system to precompile it.
21:48:37 <RaptorRarr> pikhq: Unfortunately, termination had to go.
21:49:16 <wavewave> is there a way to get the least number over a certain number in balanced tree anyway?
21:49:48 <srh> certainly
21:49:59 <kmc> :t Data.Map.splitLookup
21:50:00 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> (M.Map k a, Maybe a, M.Map k a)
21:50:41 <wavewave> oh... this looks good.
21:52:02 <wavewave> shachaf: then what's the problem of         head  .  keys . third . (split k) $ m ?
21:52:31 <wavewave> I guess keys is O(n) when retrieve all keys.
21:52:36 <Cale> shachaf: Is that a reference to something?
21:52:37 <kmc> :t \k m -> M.minView (fst (M.split k m))
21:52:38 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe (a, M.Map k a)
21:52:46 <kmc> :t \k m -> fmap fst $ M.minView (fst (M.split k m))
21:52:47 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
21:53:28 <srh> Cale: that's a topic i set on our employer's internal IRC channel
21:54:15 <wavewave> minViewWithKey
21:54:28 <srh> or part of it.
21:54:31 <cheater> hi
21:55:00 <wavewave> shachaf: so is your problem solved now?
21:56:54 <wavewave> fst . fst .  fromJust  . minViewWithKey .  snd . split k $ m
21:57:54 <wavewave> cheater: hi.
22:00:50 <cheater> wavewave: looking at your code
22:02:43 <cheater> wavewave: i think this syntax is still verbose
22:02:57 <cheater> i think it is probably a better idea to have "action" abstracted
22:03:20 <cheater> action f e = ..
22:03:38 <wavewave> cheater : sure.. you can define a convenience function.
22:03:50 <cheater> also, inside it i would assume success unless a failure is specifically returned
22:04:22 <cheater> if an errback is being called it is assumed the parameter with which it is being called is the error
22:04:30 <warpy> i am writing a robot simulation. so as the robot moves around it has to track the path it takes. what is a better design, a path field inside the robot record which is updated or carry the path as a state in a state monad?
22:04:39 <wavewave> cheater : That's possible.
22:04:44 <cheater> and if a callback is being called then it is assumed the parameter with which it is being called is a success
22:05:09 <cheater> let me try to mark up the code a bit and see what happens
22:07:13 <wavewave> warpy: I would rather use state monad in that case.
22:07:14 <shachaf> Cale: What srh said.
22:07:39 <wavewave> since anyway you have to pass robot record as a state.
22:07:42 <antihoax> hi
22:07:44 <antihoax> :)
22:08:20 <antihoax> did this: tar --xz -cvf ghc-7.0.3.tar.xz ghc-7.0.3
22:08:24 <warpy> wavewave: also, it has more history to carry, history of actions it takes, history of stimuli it gets. so it is getting messy to keep everything inside the robot itself
22:08:32 <antihoax> and got this: root root 75559908 Oct  5 08:07 ghc-7.0.3.tar.xz
22:08:57 <wavewave> warpy: then wrap all such states in robot record and in state.
22:09:24 <warpy> So use a "State Robot a" ?
22:09:29 <wavewave> yes.
22:09:53 <warpy> or rather "State RobotHistories Robot"
22:10:15 <wavewave> do not use too many monad stack
22:10:39 <warpy> i already have a State StdGen and a State Grid
22:10:42 <antihoax> 31% smaller than the bz2
22:10:50 <wavewave> warpy: first, its ugly and second, it may have some performance drawback.
22:11:17 <warpy> then what is the right way to handle multiple states?
22:12:01 <warpy> Robot has a state, the grid on which the robot moves has a state and i need State StdGen to generate random moves
22:12:32 <wavewave> HList?
22:12:44 <c_wraith> HList is rarely the answer. :)
22:12:55 <wavewave> some composable data type..
22:13:03 <wavewave> c_wraith: :-)
22:13:04 <dalaing> put it all in a big data structure and uses lenses to make dealing with it bearable?
22:13:29 <wavewave> yeah lenses..
22:14:00 <shachaf> GHC.Exts.Down++
22:15:04 <warpy> what are lenses?
22:15:54 <shachaf> warpy: Composable (get,set) function pairs.
22:15:56 <dalaing> warpy: like a pair of getters and setters for part of your data structure
22:16:04 <dalaing> but they compose
22:16:04 <wavewave> warpy: I would make a World state which has all of them .
22:16:50 <warpy> thanks. i'll look it up
22:16:53 <dalaing> I've been using data-lens, data-lens-template and data-lens-fd (which has some nice stuff for using lenses in state monads)
22:17:13 <cheater> hmmm...
22:17:25 <dalaing> no idea if I'm doing things the right way though
22:17:28 <warpy> i have another question, does haskell have something like copy constructors?
22:17:31 <cheater> i am getting an error:     Ambiguous module name `Control.Monad.State':      it was found in multiple packages: monads-tf-0.1.0.0 mtl-2.0.1.0                what can i do?
22:17:38 <cheater> do i get rid of monads-tf?
22:17:44 <shachaf> Probably, yes.
22:17:50 <shachaf> Unless you want to use monads-tf.
22:17:59 <dalaing> warpy: I don't think so
22:18:00 <wavewave> warpy: doesn't have to have that.
22:18:05 <cheater> i don't know
22:18:15 <cheater> how do i check if i want to use monads-tf?
22:18:17 <wavewave> ghc-pkg unregister monads-tf
22:18:27 <warpy> so i have a large record and i only want to update a certain field of it
22:18:28 <wavewave> and see what message
22:18:37 <dalaing> warpy: lenses help with that
22:18:55 <wavewave> warpy: it is totally efficient.
22:19:10 <warpy> they do? lenses seem to be the solution of all my problems
22:19:14 <shachaf> cheater: monads-tf is a competitor to mtl, but it looks like it lost the competition, sadly.
22:19:15 <wavewave> warpy: In haskell, everything is pointer in a sense.
22:19:26 * warpy searches for a tutorial
22:20:05 <wavewave> If you have C { a :: A, b :: B } and change C -> C' where b -> b'
22:20:10 <cheater> was monads-tf in any way better than mtl?
22:20:25 <shachaf> It uses type families instead of functional dependencies.
22:20:35 <cheater> is that better or worse?
22:20:41 <wavewave> then a remains the same as previous. No need to copy because of referential transparency.
22:20:47 <shachaf> > compare "tf" "fd"
22:20:49 <lambdabot>   GT
22:20:50 <shachaf> Looks like it's better.
22:21:05 <cheater> why?
22:21:07 <wavewave> shachaf: wow. .impressive
22:21:21 <wavewave> very creative use of compare.
22:21:24 <shachaf> Because 't' comes later in the alphabet than 'f'.
22:21:40 <cheater> no i was asking why you're a troll
22:21:47 <shachaf> There's a nice long answer on stackoverflow that cmccann wrote.
22:21:53 <shachaf> I'm sure you could find it if you looked.
22:21:54 <cheater> oh?
22:22:01 <cheater> let me search a bit
22:22:07 <shachaf> Some people consider type families clearer than functional dependencies.
22:22:12 <dalaing> warpy: if you have c inside b inside a then you can get/set c with (lc . lb . la) getL or (lc . lb . la) setL, where lc, lb, la are your lenses
22:22:23 <shachaf> However, they're less compatible with old code, and people didn't really care, so -tf won.
22:22:38 <dalaing> warpy: fclabels or data-lens-template will use TemplateHaskell to set them up for you pretty painlessly
22:22:50 <cheater> you mean mtl won
22:23:03 * wavewave thinks that  haskeller tends to forget the past so easily.. 
22:23:04 <shachaf> I mean functional dependencies more or less did. For now.
22:23:14 <cheater> so fd won not tf
22:23:19 <shachaf> "won"
22:23:36 <cheater> i'm just saying you named the wrong thing
22:23:52 <warpy> one line tutorials are not working. nvm. i'm checking out the lenses.
22:23:59 <shachaf> Instead of accusing people of being trolls when they're answering your questions, I recommend asking better questions.
22:24:11 <shachaf> I have no idea what you're talking about.
22:24:12 * shachaf sighs.
22:24:20 <cheater> i recommend trolling harder
22:24:44 <cheater> btw, is there a way to specify which package you want your module from?
22:24:52 <shachaf> Yes.
22:24:55 <cheater> i think you can do that in the .cabal
22:25:00 <cheater> but can you do that in the .hs?
22:25:01 <dalaing> warpy: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation
22:25:10 <dalaing> warpy: http://blog.ezyang.com/2010/04/inessential-guide-to-data-accessor/
22:25:17 <dalaing> warpy: http://blog.ezyang.com/2010/04/inessential-guide-to-fclabels/
22:25:19 <wavewave> --constraint flag
22:25:39 <cheater> hmm
22:25:45 <shachaf> @google ghc is there a way to specify which package you want your module from?
22:25:46 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html
22:25:46 <lambdabot> Title: 4.9.� Packages
22:25:54 <dalaing> warpy: first one gives you an idea about the various options, next two show you what you get from lenses in two of the popular implementations
22:26:01 <wavewave> hmm --constraint is for cabal.
22:26:13 <wavewave> -package and -ignore-package flag for ghc
22:26:23 <warpy> dalaing: thanks!
22:26:34 <cheater> hmm
22:26:35 <dalaing> warpy: I only found out about lenses recently, fclabels seems pretty popular so seems to have more googleable info
22:26:38 <wavewave> ghc -package mtl -ignore-package monad-fd
22:26:42 <wavewave> something like that
22:27:00 <cheater> reading the man on that
22:27:02 <cheater> thanks
22:27:04 <companion_cube> there may be symmetrical lenses soon
22:27:35 <wavewave> companion_cube: what's that?
22:27:50 <dalaing> warpy: I know more about data-lens than the others - data-lens-fd has been pretty nice for state monads etc...
22:27:54 <companion_cube> like lenses, but both sides are like sources
22:28:05 <companion_cube> you can update each side from the other, in some fashion
22:28:40 <cheater> yep just -ignore-package was enough!!
22:28:43 <cheater> thanks a lot wavewave!
22:28:53 <wavewave> welcome.
22:29:26 <warpy> another noob question: is there some convention to name record fields
22:30:14 <companion_cube> most of the time you should have them begin with "awesome"
22:30:15 <wavewave> warpy: you are probably interested in RecordWildCards
22:30:22 <companion_cube> like  awesomeField1, awesomeField2
22:30:41 <warpy> thanks companion_cube
22:31:02 <companion_cube> :]
22:31:12 <wavewave> warpy: if you have datatype   Test { test1 :: String, test2 :: String }
22:31:23 <hpaste_> warpy pasted “record name convention” at http://hpaste.org/52176
22:31:31 <wavewave> then you can use in function      f Test{..} =
22:31:50 <dalaing> warpy: I do stuff like your convention
22:31:52 <warpy> this is how i've done it currently
22:31:54 <wavewave> then rhs of = , you can use test1, test2 as variable name automatically.
22:32:08 <wavewave> that's GHC extension. RecordWildCards
22:33:15 <warpy> wavewave: that seems great! more stuff to learn
22:33:43 <hpaste_> wavewave pasted “RecordWildCards example” at http://hpaste.org/52178
22:33:59 <wavewave> like this. ;-)
22:34:13 <wavewave> extremely useful to me.
22:34:49 <warpy> nice and simple! immediately usable
22:35:21 <warpy> wavewave: what if i need to extract a field?
22:35:46 <warpy> wavewave: also does it define a function with name "name" or not?
22:36:12 <warpy> does RecordWildCards prevent such function to be defined automatically?
22:36:13 <Kreole> can someone clarify a homework assignment for me?
22:36:21 <wavewave> Ah... inside the function f, name means (name of the argument)
22:36:41 <wavewave> warpy: lexically scoped.. so it's only defined in f
22:36:42 <shachaf> Kreole: Probably, if you say what it is. :-)
22:36:52 <wavewave> where MyData{..} is used.
22:36:55 <Kreole> of course lol
22:37:01 <Kreole> the question is "Write primrec, the natural recursive function generator for NaturalNumber. Give implementations of (+) and (*) based on primrec."
22:37:17 <warpy> i get that. but in your example is there a global funtion named "title"?
22:37:22 <warpy> wavewave: ^
22:37:28 <Kreole> I'm not sure I understand what a natural recursive function generator would even do
22:37:44 <wavewave> warpy: yes. title is also used as a function outside of f .
22:37:55 <Kreole> though I do think I know what a natural recursive function is
22:38:02 <wavewave> you know f x = let x = 10 in x then f 9 = 10
22:38:17 <warpy> wavewave: but what if i have two records with fields called "title"?
22:38:18 <cheater> hey wavewave why do i need to use return at all in callbackn/errbackn?
22:38:18 <wavewave> because latter x shadows former x.
22:38:23 <Kreole> so I was just hoping someone could clarify the assignment for me
22:39:27 <wavewave> warpy: then you have a trouble... I guess.. I haven't test it.. so please make some use case and see what happens ;-)
22:39:56 <shachaf> Kreole: What's a natural recursive function? :-)
22:39:59 <wavewave> warpy: check GHC manual.
22:40:11 <warpy> wavewave: checking
22:40:12 <shachaf> (Also, what's NaturalNumber? Something like Nat = Z | S Nat?)
22:40:33 <wavewave> because callback and errback are in State monad.
22:40:59 <cheater> wavewave: mhm
22:42:34 <Kreole> I think it's when you take a list and replace all the : with +, -, etc
22:42:46 <Kreole> although that could of course be wrong haha
22:43:12 <Kreole> and yes, about NaturalNumber
22:43:18 <wavewave> cheater: do this exercise. try to guess the type of all functions in the code. action :: ???  <- fill this ???, and compile and see whether type checks.
22:43:38 <cheater> @undo do { x <- return (-3); y <- action callback1 errback1 x; action callback2 errback2 y }
22:43:38 <lambdabot> return (- 3) >>= \ x -> action callback1 errback1 x >>= \ y -> action callback2 errback2 y
22:43:54 <wavewave> cheater: it will not be an easy example at first.
22:44:03 <cheater> wavewave: hmm
22:45:13 <cheater> btw, i can do this now: main = (return $ run $ (return (-3)) >>= (action callback1 errback1) >>= (action callback2 errback2)) >>= (\x -> print x)
22:45:19 <shachaf> Kreole: You mean a fold?
22:45:38 <cheater> wavewave: i'm gonna try figuring it out
22:45:39 <wavewave> cheater: state monad is not easy at first indeed because it's not so intuitive.
22:46:48 <cheater> wavewave: i'm trying to figure out the type without looking at ghc's hints :p
22:47:34 <Kreole> er no, sorry, I think the idea is that a fold is an example of a naturally recursive function
22:48:05 <wavewave> read Monad chapter of Learn You A Haskell  and Real World Haskell. You probably need some hours.
22:49:08 <shachaf> Kreole: Well, "fold" is more general than folds on lists.
22:49:10 <hpaste_> “cheater and wavewave” pasted “current code” at http://hpaste.org/52179
22:49:40 <Kreole> oh okay. we've only done them on lists
22:51:04 <shachaf> Do you mean a catamorphism?
22:51:14 <shachaf> (Is there any context for that question?)
22:51:41 <cheater> canhazmorphism
22:52:09 * BMeph now wants a cheezmorphism...
22:53:21 <wavewave> shachaf: I guessed so : catamorphism = naturally recursive function in this context.
22:54:36 <wavewave> same recursion structure as its definition.
22:54:51 <cheater> @type >>=
22:54:52 <lambdabot> parse error on input `>>='
22:54:58 <cheater> @type (>>=)
22:54:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:56:01 <cheater> gah confusing
22:56:06 <wavewave> same function call recursion structure as the argument data structure definition recursion structure.
22:56:08 <cheater> i'll check out the monads chapter later (i have to do some work now)
22:57:18 <companion_cube> definition 1: recursion. See definition 1.
22:58:48 <wavewave> that's bottom
22:59:04 <wavewave> _|_
22:59:56 <cheater> are you flipping him off
23:00:28 <Axman6> flip flip flip
23:00:36 <wavewave> I am bottoming
23:00:47 <wavewave> bottomizer _|_ _|_
23:01:33 <wavewave> natural recursive function generator
23:02:37 <wavewave> f z s Z = z
23:03:03 <wavewave> f z s (S n) = s (f z s n)
23:03:34 <shachaf> So a catamorphism. I don't think you were supposed to provide an answer, but Kreole's gone anyway.
23:04:03 <wavewave> wavewave: ah.... this was a homework problem/
23:04:16 <wavewave> why I am adding wavewave
23:04:30 * wavewave becomes recursive.
23:05:31 <wavewave> data  X = A | B | C | D ...
23:06:16 <wavewave> f a b c d (   pattern )  = pattern (replace A B C D )...
23:06:56 <wavewave> hmm is this a definition of gfold?... hmm
23:07:33 <wavewave> data X = Sum [A,B,C,D] ...
23:08:38 <wavewave> S Z = ap S Z
23:09:00 <wavewave> S -> Z
23:12:52 <cheater> wavewave: hmm, we also forgot to implement a semantic detail
23:13:08 <cheater> wavewave: if callback1 errors out, we should next call errback1
23:13:21 <cheater> and then callback2 or errback2 depending.
23:16:41 <wavewave> cheater: hmm really? I think if callback1 errors out, then call errback2 next.
23:18:44 <wavewave> anyway, need to sleep now.. good night haskellers.
23:19:29 <cheater> nn :)
23:27:18 <antihoax> cabal: The program ghc version >=6.4 is required but it could not be found.
23:27:30 <antihoax> someone knows how to configure the "config" file ?
23:27:42 <shachaf> antihoax: Some more context would be helpful.
23:27:53 <antihoax> i have removed the -- and inserted prefix
23:28:34 <antihoax> -- verbose: 1
23:28:34 <antihoax> compiler: /mnt/a/ghc/ghc
23:28:34 <antihoax> -- with-compiler:
23:29:01 <antihoax> this does not work
23:29:33 <antihoax> Parse of field 'compiler' failed.
23:30:12 <phr> hey are there likely to be obstacles to installing both 64 and 32 bit x86 ghc on the same 64-bit box?  i want to cross compile some stuff for a 32 bit box
23:30:32 <kmc> i'd install the 32-bit ghc in its own prefix
23:30:46 <cheater> @tell wavewave sorry, i was wrong! the basic interface in twisted is .addCallbacks(callback, errback) where addCallback(callback) = addCallbacks(callback, id) and addErrback(errback) = addCallbacks(id, errback)
23:30:46 <lambdabot> Consider it noted.
23:31:02 <kmc> anyway that should work
23:31:25 <antihoax> @tell cheater hi ;>
23:31:26 <lambdabot> Consider it noted.
23:31:29 <phr> hm ok thanks
23:31:48 <cheater> omg
23:31:51 <cheater> a MESSAGE <3
23:35:02 <antihoax> someone would need to learn a little more using and creating config files ;/
23:35:31 <antihoax> regexp rulz as usual...
23:35:44 <antihoax> cabal is a fail
23:37:35 <earthy> ??
23:37:39 <applicative> ???
23:41:10 <kmc> > iterate ('?':) ""
23:41:11 <lambdabot>   ["","?","??","???","????","?????","??????","???????","????????","?????????"...
23:41:14 <antihoax> # what="compiler";sed -nr 's;[ -]*'"$what"':[ ]*([^ ][^ ]*).*;\1;p' ./config
23:41:14 <antihoax> /mnt/a/ghc/ghc
23:41:50 <antihoax> what="doc-index-file";sed -nr 's;[ -]*'"$what"':[ ]*([^ ][^ ]*).*;\1;p' ./config
23:41:50 <antihoax> $datadir/doc/index.html
23:41:50 <cheater> i thought this was just a lot of infix operators for a sec.
23:42:06 <cheater> @type iterate
23:42:09 <lambdabot> forall a. (a -> a) -> a -> [a]
23:42:28 <kmc> it's a list of infix operators, just poorly diagonalized
23:42:38 <cheater> haha
23:43:07 <cheater> kmc: did u know bash has the Maybe monad
23:43:11 <shachaf> > let ty = reverse . map reverse . tails . reverse in ty "iterate"
23:43:12 <cheater> kmc: it's called set -e
23:43:13 <lambdabot>   ["","i","it","ite","iter","itera","iterat","iterate"]
23:43:58 <shachaf> > let ty = reverse . map reverse . tails . reverse in ty "nachman meuman"
23:44:00 <lambdabot>   ["","n","na","nac","nach","nachm","nachma","nachman","nachman ","nachman m"...
23:44:08 <applicative> > inits "iterate"
23:44:09 <lambdabot>   ["","i","it","ite","iter","itera","iterat","iterate"]
23:44:21 * shachaf hmph
23:44:35 <Cale> iterat would be what it's called in lisp ;)
23:44:41 <Cale> (not true)
23:44:50 <Cale> Or maybe unix
23:44:57 <cheater> hey Cale
23:45:00 <applicative> nachman neuman wow
23:45:05 <cheater> do you know anything about parsers
23:45:05 <Cale> hey
23:45:11 <Cale> sure, I know some
23:45:23 <cheater> say i wanted to use language-python to write out python files
23:45:29 <antihoax> hi Cale <;
23:45:33 * applicative has been known to parse a thing or two
23:45:35 <Cale> hi antihoax
23:45:39 <shachaf> Cale: Do you know anything about C++ libraries?
23:45:42 <cheater> i.e. construct an AST in haskell and write it to a py file..
23:45:42 <shachaf> I hear they're cool.
23:45:47 <cheater> is that like.. difficult?
23:46:01 <antihoax> so i guess i'd have to triel-error what bits to flip so cabal gets my directory prefix ?
23:46:11 <cheater> shachaf: i wish haskell were cool like C++.
23:46:11 <Cale> cheater: That's the opposite of parsing :)
23:46:18 <cheater> Cale: oh
23:46:20 <cheater> Cale: well yeah
23:46:23 <cheater> how do you call that?
23:46:27 <cheater> composing?
23:46:35 <Cale> pretty printing
23:46:43 <Cale> It's probably reasonably easy to do
23:46:50 <cheater> hmm interesting
23:46:59 <shachaf> Emitting.
23:47:05 <shachaf> It's generally much easier than parsing.
23:47:08 <Cale> I've pretty printed a fair amount of Haskell code using haskell-src-exts, and while it's not ideal, it's pretty easy for the most part.
23:47:23 <Cale> I don't know anything about the language-python package
23:47:24 <antihoax> Cale<< i have succeded in "installing" the ghc with platform
23:47:24 <cheater> shachaf: can you show an article that calls it emitting?
23:47:30 <antihoax> but cabal wont work now
23:47:36 <antihoax> its not on path
23:47:38 <shachaf> @google parser vs emitter
23:47:40 <lambdabot> http://www.snakeyaml.org/
23:47:40 <lambdabot> Title: snakeyaml - YAML parser and emitter for Java - Google Project Hosting
23:47:46 <cheater> o ok
23:47:59 <antihoax> # ./cabal install Glosscabal: The program ghc version >=6.4 is required but it could not be found.
23:48:07 <antihoax> btw cabal and ghc is in same dir
23:48:08 <cheater> antihoax: you have to add ./cabal/bin to PATH
23:48:11 <cheater> do it in your .bashrc
23:48:25 <killerswan> Why does FilePath appear not to implement IsString?
23:48:42 <cheater> why would a path be a string?
23:48:42 <antihoax> i wanted to write it in cabal config file...
23:48:43 <shachaf> killerswan; FilePath is a synonym for String.
23:48:49 <killerswan> yeah
23:49:09 <shachaf> killerswan: It *is* a String, in a much simpler way than IsString. :-)
23:49:18 <shachaf> It implements IsString if String does.
23:49:34 <killerswan> so if i use -XOverloadedStrings, as I was trying earlier, and give it as an argument to a Data.Text function...
23:49:38 <antihoax> but cabal fails to get values from that
23:50:10 <antihoax> doing something like this passes... # what="compiler";sed -nr 's;[ -]*'"$what"':[ ]*([^ ][^ ]*).*;\1;p' ./config
23:50:12 <rwbarton> -XOverloadedStrings is just about string literals
23:50:23 <shachaf> killerswan: That's not how IsString works.
23:50:42 <shachaf> killerswan: IsString only works one way, from String to some data type.
23:50:56 <shachaf> killerswan: And all it does is overloading the same way integer literals are overloaded.
23:51:56 <donri> do you need to call fromString yourself then or is that handled by type inference?
23:52:32 <kmc> there are no implicit conversions in Haskell
23:52:33 <shachaf> donri: The extension makes it so that when you type "foo", it really means fromString ("foo" :: String)
23:52:39 <killerswan> If I do Data.Text.IO.putStrLn "ok" with -XOverloadedStrings, it works out
23:52:55 <applicative> donri, the IsString instance needs to be in scope then you can use the literal "hi" to mean whatever isString "hi" denotes
23:53:11 <killerswan> But if I create a FilePath named x, and call Data.Text.IO.putStrLn x, I get an error...
23:53:24 <kmc> correct
23:53:30 <kmc> -XOverloadedStrings is just about string literals
23:53:32 <rwbarton> > let x = 2 :: Int in sqrqt 2
23:53:33 <lambdabot>   Not in scope: `sqrqt'
23:53:34 <kmc> x is not a string literal there
23:53:35 <rwbarton> > let x = 2 :: Int in sqrt 2
23:53:36 <lambdabot>   1.4142135623730951
23:53:38 <applicative> instance IsString Int where where isString = length
23:53:42 <donri> yea, and it's figured out by the "context" of what type is expected right?
23:53:42 <rwbarton> > let x = 2 :: Int in sqrt x
23:53:44 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
23:53:44 <lambdabot>    arising from a use of...
23:53:46 <applicative> fromString rather
23:53:52 <kmc> killerswan, it's just like how you can write (3 :: Int) and (3 :: Float) but if you have an x :: Int and use it as a Float, you get an error
23:54:03 <applicative> donri, yes, it's like fromIntegral and all that
23:54:11 <donri> that is, a function doesn't need to know about fromString, but the expected type needs to implement IsString
23:54:29 <killerswan> ahhh
23:54:36 <killerswan> now i see
