00:07:00 <Quantumplation> in the let part of a let/in block, can I define a function multiple times with different pattern matchings? so, let a [] = blah a es = otherblah in?
00:07:09 <Quantumplation> (with newlines in there)
00:07:59 <Veinor> i think so
00:08:14 <shachaf> Yep.
00:08:26 <shachaf> let is a do block is just like let anywhere else, except without the in.
00:08:49 <Quantumplation> what about | guards? I seem to be getting a parse error
00:09:27 <shachaf> Probably something about your syntax.
00:09:36 <shachaf> It would be much easier to answer if you @pasted your code.
00:09:48 <Quantumplation> nevermind, i got it heh
00:10:23 <Quantumplation> I always feel bad pasting for such minor things, I feel like i'm "wasting" a paste.  Even though the logical part of my brain recognizes how rediculous that is for such small text files
00:11:03 <Veinor> is there any way to autogenerate hoogle docs for everything i have installed?
00:11:36 <shachaf> Set documentation: True in ~/.cabal/config, and then reinstall everything. :-)
00:11:50 <Veinor> haha
00:12:51 <shachaf> cat ~/.cabal/world | xargs -d '\n' -n 1 cabal install --reinstall
00:13:05 <Veinor> ugh, haddock isn't installing
00:13:30 <shachaf> Is there a reasonable way to make imperative C-ish programming in Haskell less awkward?
00:14:27 <Axman6> shachaf: doing what sorts of tasks?
00:15:12 <shachaf> Axman6: Classic imperative functions that are easily expressible in Haskell recursively.
00:15:21 <shachaf> (Or less easily.)
00:19:35 <Quantumplation> how would I write the a comprehension for an infinite list that is just repeated application of the same function?
00:19:54 <shachaf> Not everything has to be a comprehension. :-)
00:20:00 <shachaf> > iterate (*2) 1
00:20:01 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
00:20:35 <Quantumplation> heh, dunno why my brain goes straight to comprehensions all the time
00:21:08 <shachaf> Simple comprehensions are often more verbose than just using map/filter/etc.
00:22:58 <Axman6> > let xs = 1:[x * 2 | x <- drop 1 xs] in xs
00:23:02 <lambdabot>   mueval-core: Time limit exceeded
00:23:13 <Axman6> > let xs = 1:[x * 2 | x <- xs] in xs
00:23:14 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
00:23:17 <Axman6> better
00:24:44 <Axman6> > let iter f x = let xs = x:[f y | y <- xs] in iter (+1) 1
00:24:45 <lambdabot>   not an expression: `let iter f x = let xs = x:[f y | y <- xs] in iter (+1) 1'
00:24:55 <Axman6> > let iter f x = let xs = x:[f y | y <- xs] in xs in iter (+1) 1
00:24:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:27:57 <Quantumplation> f (Node _ []) = <-- can I bind that node to a variable for use in f?
00:28:17 <Veinor> f x@(Node _ [])
00:28:55 <Quantumplation> sweet, that's been one of the biggest obstacles to getting functions coded haha, because it was either get access to the node itself, or get access to the internals of the node (not a big fan of record syntax...)
00:30:21 <solrize> so does anyone know how a preforking web server (like old-school apache) works?  would it be sane for a haskell forkio-based server to also spawn processes so they could exit once in a while, taking any memory leaks with them?
00:30:47 <solrize> is it conceivable to connect two processes with an mvar?
00:31:00 <solrize> or tvar for that matter?
00:31:54 <solrize> i'm imagining migrating forkio threads across processes by serializing the pure data and passing open files thru unix domain sockets
00:37:07 * hackagebot googleplus 0.3.0 - Haskell implementation of the Google+ API v1  http://hackage.haskell.org/package/googleplus-0.3.0 (MichaelXavier)
00:38:21 <Quantumplation> hrm.  what if I wanted to alternate the function call?
00:38:32 <Quantumplation> iterate f . g won't work
00:39:09 <shachaf> What does "alternate the function call" mean?
00:39:35 <shachaf> solrize: That seems a little bit excessive... What memory leaks are you worried about?
00:39:36 <Quantumplation> like iterate, but swapping back and forth between two functions instead of 1
00:39:54 <Ke> > iterate ((+1).(+2)) 1
00:39:55 <lambdabot>   [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76...
00:40:28 <Quantumplation> that composes the two, not alternates the two for each element, no?
00:40:53 <Ke> why doesn't it work, do you want the intermediate results too
00:40:57 <solrize> shachaf, maybe the compacting gc is sufficient if you're careful about laziness
00:41:14 <Quantumplation> yea
00:41:53 <solrize> > map ((1+) &&& (2+)) [0..]
00:41:54 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
00:42:15 <tkahn> ok so i think i may have misconceptualized the problem: this is the type signature for that function I was talking about
00:42:22 <tkahn> FeedbackIndex -> IO (Maybe FeedbackIndex, [Data])
00:43:15 <shachaf> unfoldrM :: Monad m => (a -> m (Maybe (b, a))) -> a -> m [b]
00:43:37 <tkahn> i don't think that does what i want
00:43:49 <shachaf> Well, you haven't really said what you want. :-)
00:43:53 <tkahn> haha
00:43:57 <tkahn> well
00:44:19 <tkahn> here's kind of what i'm looking for
00:44:48 <tkahn> (FeedbackIndex -> IO (Maybe FeedbackIndex, [Data])) -> FeedbackIndex -> IO [Data]
00:45:14 <tkahn> i think it's similar to unfoldrM
00:45:42 <tkahn> in fact i would be fine with (FeedbackIndex -> IO (Maybe FeedbackIndex, [Data])) -> FeedbackIndex -> IO [[Data]]
00:45:52 <shachaf> Oh, I see.
00:46:04 <shachaf> Well, if it's sufficiently specialized, you might as well just write it yourself.
00:47:26 <tkahn> idk i feel like this is something that would be common. you have and initial index, give that to the internet, it gives you back some data and a index to send it to get the next piece of data
00:47:43 <tkahn> but maybe not
00:49:24 <tkahn> and when the internet wants to signal it has no more data, it doesn't give you an index back, just the final piece of data
00:49:39 <shachaf> It seems that you could express it in terms of unfoldrM easily enough.
00:49:56 <shachaf> Maybe by extending Index to have a "no more" value, or something.
00:50:15 <tkahn> well Index is an Int
00:50:24 <tkahn> i mean isn't that what Maybe is for?
00:50:35 <tkahn> it's either an int or nothing
00:51:12 <shachaf> Use Maybe (Maybe Int)! :-)
00:51:43 <tkahn> hmm i'll try that
00:51:57 <Quantumplation> from leksah, if I want to getLine, it's not accepting my typing...
00:52:01 <shachaf> (I don't know if that's actually a good idea.)
00:52:06 <tkahn> lol
00:52:19 <shachaf> Quantumplation: #leksah would probably know.
00:53:27 <tkahn> i really feel like there's a generalization here that can be made
00:53:37 <tkahn> maybe give StateT another look?
00:54:08 <shachaf> Well, generalizing to some differentUnfoldrM_'BonusEdition might be possible.
00:54:17 <tkahn> lol
00:54:19 <shachaf> You could also use StateT, though I doubt it'll give such a benefit.
00:56:02 <tkahn> @unmtl StateT (Maybe FeedbackIndex) IO Data
00:56:02 <lambdabot> Maybe FeedbackIndex -> IO (Data, Maybe FeedbackIndex)
00:56:07 <tkahn> tada
00:56:17 <tkahn> i think that's it right
00:56:40 <shachaf> Right, but you'll still need to express it in terms of explicit StateT operations.
00:58:17 <tkahn> btw is there a way to do @unmtl from ghci or something?
00:59:19 <shachaf> No, but you can just do :i StateT and figure it out.
00:59:29 <shachaf> Or you can get lambdabot-inside-ghci.
01:04:00 <Quantumplation> http://hpaste.org/52642 if you take a look at the second revision, i'm doing trace "n" and trace "e" before the data constructors, and the output i'm getting is on the bottom.  I'm not sure how to interpret that.  Does that mean that i'm likely tying the knot properly, since it doesn't trace n and e a ton of times?
01:04:47 <solrize> @hoogle Chan
01:04:47 <lambdabot> module Control.Concurrent.Chan
01:04:47 <lambdabot> Control.Concurrent.Chan data Chan a
01:04:48 <lambdabot> Control.Concurrent.Chan dupChan :: Chan a -> IO (Chan a)
01:12:06 * hackagebot pointedlist 0.4.0.3 - A zipper-like comonad which works as a list, tracking a position.  http://hackage.haskell.org/package/pointedlist-0.4.0.3 (JeffWheeler)
01:28:55 <User563> http://www.massuc.com/ !!! Come and play the best Mafia MMORPG in progress !!! http://www.massuc.com/
01:52:51 <k0ral> any gtk2hs maintainer here ?
02:00:07 <Axman6> k0ral: you
02:00:16 <Axman6> you'll do better to just ask your question*
02:06:04 <k0ral> Axman6: fine
02:06:26 <k0ral> so I'm trying to implement the "notify::" signal feature
02:06:59 <k0ral> and but I read that the signal name isn't part of the Signal type
02:07:22 <k0ral> so where is it stored ?
02:07:42 <k0ral> -and
02:27:07 * hackagebot mbox-tools 0.2.0.2 - A collection of tools to process mbox files  http://hackage.haskell.org/package/mbox-tools-0.2.0.2 (NicolasPouillard)
02:27:09 * hackagebot Paraiso 0.1.0.2 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.1.0.2 (TakayukiMuranushi)
02:28:53 <ader111> hello everyone
02:29:16 <ader111> can I ask a question about Iteratees? more precisely about Enumeratee
02:32:07 * hackagebot mbox-tools 0.2.0.3 - A collection of tools to process mbox files  http://hackage.haskell.org/package/mbox-tools-0.2.0.3 (NicolasPouillard)
02:33:07 <cheater> sure
02:33:15 <cheater> what do you need?
02:42:07 * hackagebot mbox-tools 0.2.0.4 - A collection of tools to process mbox files  http://hackage.haskell.org/package/mbox-tools-0.2.0.4 (NicolasPouillard)
02:43:43 <Axman6> ader111: hello?
02:54:24 <al-maisan> I would like to make use of MapM_ -- however ghc keeps complaining (Not in scope: data constructor `MapM_') although I have an "import Control.Monad" line ..
02:56:24 <Axman6> al-maisan: can you paste all the code?
02:56:30 <al-maisan> here's the code in question: http://paste.ubuntu.com/708463/
02:57:12 <Axman6> al-maisan: all functions start with a lower case letter, it's mapM_, not MapM_
02:57:31 <al-maisan> aaaaaaaaaah
02:57:35 <al-maisan> thank you!
03:12:11 * hackagebot timerep 1.0.0 - Parse and display time according to some RFCs (RFC3339, RFC2822)  http://hackage.haskell.org/package/timerep-1.0.0 (HugoGomes)
03:14:33 <HugoDaniel> \o/
03:14:38 <HugoDaniel> thats my package right there
03:15:07 <geheimdienst> HugoDaniel: nice :) congrats
03:22:19 <tkahn> do i care about monomorphism restriction?
03:23:04 <JuanDaugherty> yes
03:23:09 <tkahn> why?
03:23:12 <companion_cube> @vixen is monomorphism restriction a good thing?
03:23:12 <lambdabot> Your boys will be home for Christmas.
03:23:30 <tkahn> lol
03:23:32 <tkahn> wat
03:23:33 <geheimdienst> tkahn: you generally just turn it off and that's it :) LANGUAGE NoMonomorphismRestriction
03:23:49 <tkahn> geheimdienst: thanks
03:29:36 <Nicklas> i need help with searching in tries
03:30:48 <Nicklas> Anyone up for it? :)
03:34:22 <HugoDaniel> Nicklas: are you using any hackage pkg ?
03:34:55 <Nicklas> HugoDaniel: Im using hugs and it's not kind against packages,modules etc
03:35:14 <Nicklas> I can give you a more detailed explanation if you want
03:35:14 <HugoDaniel> oh
03:39:23 <Nicklas>  Let's say I have a trie with the keys "blue", "brown", "red" and "green".  If I write "b" I want all the keys starting with b to be put in a list. Example: restTrie "b" exampleTrie will give the output ["lue","rown"]    Data type for the tree: data Trie a = TrieNode (Maybe a) [(Char, Trie a)]  deriving Show
03:41:34 <mah_b> Nicklas, so restTrie :: String -> Trie -> [String]?
03:42:10 <shachaf> Nicklas: Is this a homework question?
03:42:35 <Nicklas> Yes its homework, thats why I dont want the whole answer
03:42:44 <Nicklas> I just want some pointers :)
03:42:49 <aristid> Nicklas: what is your question, then?
03:43:18 <bjrn> Nicklas: chalmers? :-)
03:43:41 <Nicklas> aristid: Well, thats what Im supposed to do. Maybe you could give me some pointers on where to start or what to think about
03:43:54 <shachaf> Nicklas: What have you tried so far?
03:44:08 <shachaf> Do you have some general idea of how the algorithm should work? Do you know how a trie works? :-)
03:44:26 <Nicklas> shachaf: I suck at tries >_>
03:44:36 <Nicklas> Lists are easy, tries...not so much
03:44:45 <aristid> trie harder *bad joke*
03:44:49 <tkahn> shachaf: i discovered the general version of what I was getting at
03:45:09 <Nicklas> lol :D
03:45:59 <hpaste> “Tyler Kahn” pasted “runUntil/runWhile” at http://hpaste.org/52647
03:47:11 <Nicklas> mah_b: Yes, thats how it should look like
03:47:42 <shachaf> tkahn: Do you gain much from expressing it in terms of StateT?
03:47:56 <tkahn> it looks the exact same
03:47:59 <tkahn> basically
03:48:39 <tkahn> but runUntil is the generalized version of what I was trying to express
03:49:04 <tkahn> so i just pass in a predicate, the StateT i created, and an initial state
03:49:41 <tkahn> and it returns a list of all steps in the computation
03:50:20 <tkahn> up until it reached a state which satisfied p
03:50:24 <tkahn> the predicate
03:54:21 <tsousa> does Haskell have a good librarys and tutorial to start on Gui Programming?
03:56:27 <Axman6> there are a few libraries, i'm not sure how many tutorials there are
03:56:27 <jedai_> Nicklas: among the functions that could help Data.List.lookup
03:56:39 <Axman6> some people seem to like haskell for GUI programming. see manatee
03:56:46 <Axman6> @google manatee haskell
03:56:47 <lambdabot> http://haskell.org/haskellwiki/Manatee
03:56:47 <lambdabot> Title: Manatee - HaskellWiki
03:57:13 <mah_b> Nicklas: Maybe you could build something similar to wikipedia's find on tries?
03:58:56 <Eduard_Munteanu> tsousa: I find gtk2hs quite nice
03:59:14 <tsousa> Eduard_Munteanu, but there is some nice tutorials?
03:59:32 <Eduard_Munteanu> Hm, I think so.
04:00:13 <Eduard_Munteanu> tsousa: http://projects.haskell.org/gtk2hs/docs/tutorial/glade/
04:01:37 <Eduard_Munteanu> But given it's GTK at heart, you might also want to look at GTK documentation and tutorials, that is C code.
04:03:20 <Eduard_Munteanu> ... and then figure out how that translates to the gtk2hs API. IIRC it's rather straightforward.
04:12:48 <shachaf> Oh, Nicklas is gone.
04:13:33 <mah_b> Nicklas: Maybe first define a subTrie and then a function to extract all keys?
04:14:46 <Nicklas> mah_b: Well...how would I extract all the keys? :P
04:15:42 <shachaf> Nicklas: Can you draw your trie out on paper and try to figure out how the algorithm would work on that?
04:15:56 <mah_b|afk> You recursively scan nodes while remembering their prefix and add all to the list when they have a value
04:16:43 <shachaf> By the way, your test case with "blue","brown","red","green" isn't big enough; you should at least have some element which is a prefix of another element.
04:19:51 <k0ral> Axman6: that's why I prefer first checking if anyone can answer me before bothering to describe my problem...
04:21:00 <Axman6> k0ral: that's usually a good way or not getting an answer, even if someone does know your the answer.
04:21:36 <shachaf> k0ral: How can someone know whether they can answer you without knowing your problem?
04:22:05 <shachaf> People don't want to say "yes, I'm here and can answer some unknown problem", because what if they end up being unable to answer it after they said they could? Then they feel bad.
04:22:30 <shachaf> Or what if it ends up being really time-consuming to answer? At least they don't feel responsible (i.e., trapped).
04:24:15 <Axman6> also, just asking the question gives uf the chance to tell you who you should be talking to, incase the relevant person is in the channel, but not looking when you happen to ask the question
04:24:47 <shachaf> Yes, go bug ddarius. He knows everything.
04:25:17 <Axman6> or dcoutts if it's a cabal/hackage thing :P
04:27:42 <k0ral> I disagree
04:27:55 <k0ral> sometimes I ask 4 or 5 times the same question
04:28:26 <k0ral> any way, I sense you're not to be convinced so nevermind
04:28:48 <Axman6> yep, it's possible that there's no one here who knows the answer to your problem once you've asked it. but 100% of people cannot give you the answer to a question you haven't asked
04:29:21 <k0ral> Axman6: give it a rest :)
04:31:04 <shachaf> k0ral: This is common IRC etiquette, particularly around these parts. Sadly, when you're trying to get help from people, it helps to do things in a way they like. :-)
04:31:44 <Eliel> yes, on irc, many people feel it's rude to ask if you can ask a question.
04:32:22 <shachaf> Eliel: If people consider it rude, that means you should ask whether it's OK before you do it, right?
04:33:07 <Eliel> shachaf: depends on the things in question. Some things aren't ok to even ask if it's OK :)
04:33:09 <harlekin_> Regarding heist, why isn't it possible to write <div style="$(heist:style type=foo)" />? Apparently attributes aren't allowed inside $(...). Is this by design?
04:34:12 <shachaf> Eliel: May I ask whether I can ask if I can ask about asking why?
04:34:59 <Eliel> shachaf: no :D
04:39:18 <plan_rich> hi, i have a question about hugs interperter: why does it not know the sort function? if i try to sort a string it says that this variable is not defined. also :t sort does fail...?
04:39:33 <Eliel> shachaf: out of curiosity, is there a different word for something that's rude no matter what?
04:40:11 <shachaf> Eliel: What do you mean?
04:40:32 <kmc> plan_rich, import Data.List
04:40:34 <Eliel> plan_rich: I'd be surprised if it's really necessary, but importing Data.List should help.
04:40:48 <kmc> it is in GHCi
04:41:13 <plan_rich> thx ill try that.
04:41:53 <Eliel> shachaf: I'm thinking I probably picked the wrong word when I picked "rude" in the sentence earlier :)
04:42:38 <Eliel> shachaf: so, I'm wondering if there's a word that would fit better.
04:43:22 <plan_rich> it worked but the interpretor only ate :l Data.List and not import Data.List? what is the difference? import only for text files?
04:43:59 <shachaf> plan_rich: Usually you use :m + to import in ghci pre-7.0
04:44:14 <bjrn> Eliel: If you mean the practice of fishing (questions like "can anyone help me?") then that's just very annoying
04:44:41 <Eliel> bjrn: yes, pretty much.
04:47:21 <bjrn> Eliel: Though my worst pet peeve is people who don't have a question but believe that if they just look pained enough someone will figure out the question for them _and_ then answer it.
04:49:00 <Philonous> I was wondering, since IO is our sin bin anyway, couldn't it contain primitives for delimited control effects as well? ;)
04:49:15 <Eliel> bjrn: oh yes, that's also annoying.
04:52:12 <sipa> à
04:54:59 <JuanDaugherty> our sin bin
04:59:55 <kmc> IO being the catch-all monad is bad, though
05:00:19 <kmc> it should suffice to use a delimited-continuations monad transformer on top of IO, right?
05:02:05 <shachaf> kmc: Is that post of yours going to talk about delimited continuations?
05:02:26 <aristid> kmc: is ContT that? *stupid question*
05:03:04 <Philonous> aristid:  Yes
05:03:12 <kmc> shachaf, no, because I don't understand them well enough
05:03:20 <Philonous> aristid:  Cont ist the Monad of delimited continuations
05:03:37 <shachaf> kmc: Aw. That's why I was hoping for it.
05:03:41 <kmc> sorry
05:04:07 <kmc> aiuu, Cont gives you delimited continuations, but the stdlib doesn't provide all the fun delimited control operators
05:06:25 <aristid> kmc: wasn't ContT r IO unsafe for some reason?
05:06:27 <Philonous> kmc:  There are some problems with that, though, for example all the control operators that are in continuation passing style (forkIO, withFile etc.) expect IO actions, not ContT IO
05:06:56 <kmc> aristid, is it?  you can define it without any unsafe operations
05:07:22 <aristid> kmc: something about violating monad laws? my memory is failing me
05:07:40 <kmc> ContT r IO a = (a -> IO r) -> IO r
05:07:45 <kmc> interesting
05:08:25 * Axman6 does not understand how that type can be a monad >_<
05:08:39 <Axman6> @src Cont (>>=)
05:08:39 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
05:09:20 <Axman6> :t runCont
05:09:21 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
05:09:32 <aristid> :t runContT
05:09:33 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
05:09:54 <aristid> @src ContT (>>=)
05:09:56 <lambdabot> m >>= k  = ContT $ \c -> runContT m (\a -> runContT (k a) c)
05:10:20 <Axman6> aristid: that doesn't help me much, given I don't understand the Cont monad =)
05:10:53 <Axman6> actually, does anyone have an article they feel is a good introduction to continuations and then the cont monad? (apart from the one kmc is currently writing)
05:11:05 <kmc> man now i'm on the hook to write it
05:11:17 <aristid> Axman6: second that
05:11:30 <Axman6> kmc: gogogo!
05:11:34 <kmc> what are some good examples of continuation-using code
05:11:38 <kmc> which i could use in my post
05:11:45 <plan_rich> im still getting some issues with the sort function. how would i write the import statement in my hs script loaded buy HUGS?
05:11:52 <Axman6> kmc: share it with me while you write it, and you can fix unclear bits as you write!
05:11:57 <kmc> plan_rich, put "import Data.List" at the top
05:11:58 <plan_rich> import Data.List doesnt do the job
05:12:02 <kmc> oh yeah?
05:12:10 <plan_rich> well i put it in the middle
05:12:18 <kmc> put it at the top
05:12:18 <Axman6> it has to be at the top plan_rich
05:13:02 <plan_rich> wow this did the difference! thx
05:13:02 <kmc> looking at (>=>) might be more helpful than looking at (>>=)
05:13:14 <kmc> if you understand composition of functions in CPS
05:13:25 <Axman6> not really...
05:13:45 * Axman6 knows probably next to nothing about CPS, apsrt from having used it once unsuccessfully
05:14:03 <kmc> in CPS every function takes an extra argument, a function
05:14:07 <shachaf> @djinn (a -> (b -> r) -> r) -> (b -> (c -> r) -> r) -> a -> (c -> r) -> r
05:14:07 <lambdabot> f a b c d = a c (\ e -> b e d)
05:14:11 <kmc> and instead of returning, it calls that function
05:14:40 <Axman6> plan_rich: GHC is the recommended platform for haskell these days. it comes with an interpreter like hugs, but it's god a lot more features
05:14:56 <kmc> so «map (<7) (filter odd xs)» becomes «filter odd xs (\v -> map (<7) v id)»
05:14:59 <Philonous> Axman6:  http://okmij.org/ftp/continuations/#tutorial The tutorial seems to be down at the moment, though
05:15:07 <Axman6> ah right, i think i knew that...
05:15:08 <kmc> (and you transform the code for 'filter' and 'map' too)
05:15:28 <kmc> so to compose functions it's like
05:15:31 <plan_rich> Axman6: well i know, but im kind of bound to hugs cause we do haskell for my course at university and in the test i will miss the confort of GHC
05:16:03 <Axman6> plan_rich: fair enough. though if you decide you like haskell (hint: you should!), ghc is the way to go :)
05:16:38 <Axman6> plan_rich: where are you learning haskell?
05:17:01 <plan_rich> university at vienna
05:17:04 <kmc> (f . g) x = \k -> g x (\y -> f y k)
05:17:07 <kmc> makes sense Axman6?
05:17:39 <MaskRay> 求 dropbox-lnx.x86_64 的 gz.tar
05:17:41 <plan_rich> i really like some features from haskell, but yet i did not find the true magic. but i think i will soon
05:17:47 <plan_rich> in haskell*
05:17:48 <Axman6> i think so... one sec, let me make sure =)
05:18:26 <Axman6> kmc: and the k is the continuation that f gives its result to right?
05:19:04 <kmc> yes
05:19:14 <kmc> it's the same continuation the composition received
05:19:18 <Axman6> so, once g has do its thing with x, it gives the result to f which does its things with the result (y) and when its done, passes its result to k, when it's provided
05:19:24 <kmc> yes
05:19:48 <kmc> and (>>=) is similar
05:19:50 <Axman6> now would be a great time for an example of why this is useful =)
05:20:03 <Axman6> @src Cont (>>=)
05:20:03 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
05:20:09 <kmc> m >>= f  =  \k -> m (\y -> f y k)
05:20:17 <kmc> removing the newtype wrapping
05:20:25 <Axman6> yeah, thanks
05:20:32 * shachaf starts the LEM timer.
05:20:38 <kmc> ;P
05:20:40 <shachaf> "useful"
05:21:06 <Axman6> LEM?
05:21:12 <kmc> law of the excluded middle
05:21:28 <kmc> there's a connection between continuations, classical logic, pierce's law, and LEM
05:21:39 <shachaf> Axman6: As it happens, transforming a Haskell program to continuation-passing style is pretty equivalent to embedding classical logic in intuitionistic logic.
05:21:43 <kmc> Axman6, have you ever wanted to 'map' a function which can decide to exit the 'loop' early?
05:21:43 <Axman6> ah...
05:21:49 <kmc> mapM in ContT can do that
05:21:54 <kmc> or just in Cont
05:21:57 <shachaf> kmc: So can Left in Either...
05:22:06 <benmachine> Cont can do Either >_>
05:22:10 <Philonous> Axman6:  It's useful because you can write a function that exposes it's continuation, and than you can do fun stuff with that
05:22:11 <shachaf> Cont can do it all.
05:22:16 <shachaf> @google sigfpe cont
05:22:17 <lambdabot> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
05:22:17 <lambdabot> Title: A Neighborhood of Infinity: The Mother of
05:22:21 <geheimdienst> shachaf: awesome. i can definitely see me using that in hacking up my next xmonad module
05:22:32 <shachaf> geheimdienst: Using what?
05:22:34 <kmc> Cont is like other monads -- if you only use 'return' and (>>=), you gain nothing
05:22:39 <geheimdienst> (re embedding classical logic)
05:22:47 <shachaf> geheimdienst: Oh. Right. As I said, useful.
05:23:06 <kmc> but you can access the current continuation by pattern-matching on the newtype, or by calling 'callCC'
05:23:21 <Axman6> :t callCC
05:23:22 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
05:23:28 <benmachine> and then do odd things like call it twice
05:23:32 <benmachine> or call it with different things
05:23:32 <Axman6> um
05:23:35 <benmachine> or not at all, indeed
05:23:51 <Axman6> @src callCC
05:23:52 <lambdabot> Source not found. :(
05:23:54 <kmc> yeah, a computation can return its own continuation, and then later code can call that continuation to go 'back in time'
05:23:58 <Axman6> @src Cont callCC
05:23:58 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
05:24:00 <Philonous> benmachine:  You can't call a continuation twice, once you call it, the context is aborted. You need delimited continuations for that
05:24:28 <shachaf> You can't implement all Cont operations in terms of callCC, can you?
05:24:36 <kmc> i think you need mapCont too
05:24:37 <Axman6> yeah, i think it was the sigfpe post that i read before which chowed the 'going back in time' nature
05:25:14 <Axman6> so, that callCC definition is completely misterious to me
05:25:23 <kmc> yeah, you just have to stare at it
05:25:32 <kmc> maybe remove the wrapping again
05:25:52 <Axman6> that would be helpful i think
05:25:55 <Philonous> Axman6: It takes a function and the continuation (as before) and exposes that continuation to the function it is given
05:26:00 <Axman6> i think i can start to see what's going on though
05:26:17 <kmc> callCC f = \k -> f (\a _ -> k a) k
05:26:20 <kmc> note that k is used twice
05:26:26 <kmc> it's the ordinary continuation to the function f
05:26:27 <geheimdienst> Philonous: sounds vaguely like fix if you put it like that :)
05:26:48 <Axman6> yep
05:27:00 <Axman6> what is the point of the inner lambda?
05:27:03 <kmc> f can invoke k by "returning" normally (wrt CPS) or by calling its argument
05:27:29 <kmc> the argument to f has type (a -> Cont r b)
05:27:46 <Axman6> callCC f = \k -> f (\a  -> (\_ -> k a)) k -- slightly clearer for me
05:27:54 <kmc> if f makes an ordinary CPS'd call to that argument, it's passed the "how to return to f" continuation
05:28:05 <kmc> but that will be discarded, since we call the continuation k instead
05:29:36 <Axman6> "how to return to f"?
05:29:48 <kmc> yeah
05:29:54 <Axman6> oh, as in the 'return value of f gets passes to k'
05:30:04 <Axman6> in stead of returning a value
05:30:06 <kmc> if the pre-CPS code to f is like
05:30:18 <kmc> f k = (k 3) + 2
05:30:37 <kmc> here k is the continuation passed by callCC, and not the CPS arg
05:30:41 <kmc> the CPS transform version is like
05:31:07 <kmc> f k c = k 3 (\v -> c (v + 2))
05:31:19 <kmc> (unless you want to transform (+) too)
05:31:27 <Axman6> no...
05:31:27 <Axman6> :P
05:31:29 <kmc> but that second arg to k is never used
05:31:43 <Axman6> it's not?
05:31:48 <Axman6> wha?
05:31:51 <kmc> calling the thing you get from callCC never returns
05:32:26 <Axman6> never returns?
05:32:30 <kmc> yeah
05:32:42 <kmc> you should understand how callCC is used before you try to understand how it's implemented
05:32:44 <Axman6> what is this i don't even
05:32:56 <Axman6> yeah, i think that's a good idea
05:33:08 <kmc> «callCC f» calls f with the "current continuation
05:33:11 <kmc> "
05:33:18 <shachaf> Axman6: callCC has type forall a. ((a -> Void) -> a) -> a
05:33:29 <shachaf> Or an equivalent of callCC has that type.
05:33:33 <kmc> callCC (\k -> ...)
05:33:47 <shachaf> Clearly your program should never get its hands on a value of type Void.
05:33:47 <kmc> if the body of f calls (k x), that call does not return;  instead callCC itself returns with x
05:34:04 <aristid> :t callCC
05:34:05 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
05:34:32 <Axman6> wait, which k are we talking about now...
05:34:47 <kmc> > flip runCont id $ callCC (\k -> fmap (+ 3) (k 2))
05:34:49 <lambdabot>   2
05:34:51 <Axman6> we had callCC f, and i assumed you expanded f to be (\k -> ...)?
05:34:55 <kmc> yes
05:35:14 <Axman6> oh, and x is the 'return' value of f?
05:35:31 <kmc> no i said "if the body of f calls (k x)"
05:35:34 <Axman6> ok, i think i see what's going on... sort of
05:36:06 <Axman6> yeah, that's a generalisation of what i was saying i guess :P (but i'm probably wrong)
05:36:38 <Axman6> so, in english, what is the purpose of callCC.
05:36:44 <kmc> if f calls the continuation passed to it by callCC, then computation in 'f' aborts and callCC returns immediately
05:36:55 <kmc> Axman6, to give you access to the current continuation
05:36:55 <Axman6> ok
05:37:13 <kmc> "the current continuation" is a conceptual thing which always exists in a functional program
05:37:30 <kmc> callCC makes it a first-class value that can be manipulated for, speaking generally, non-local control flow
05:37:31 <Axman6> yeah, i was about to ask what was meant by 'current'
05:37:49 <kmc> "current continuation" wrt a specific point in an evaluation
05:38:04 <kmc> (callCC f) gives f first-class access to the current continuation as of entry to f
05:38:11 <aristid> @src callCC
05:38:12 <lambdabot> Source not found. There are some things that I just don't know.
05:38:18 <kmc> @src Cont callCC
05:38:18 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
05:38:44 <Axman6> callCC f = \k -> f (\a  -> (\_ -> k a)) k -- from earlier
05:38:54 <shachaf> Bonus puzzle: What is ((call/cc call/cc) (call/cc call/cc))?
05:39:19 <Axman6> that sounds a lot like it's related to (\x -> x x) (\x -> x x)
05:39:38 <aristid> :t (callCC callCC) (callCC callCC)
05:39:38 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> m b1
05:39:39 <lambdabot>       Expected type: m (b -> m b1)
05:39:39 <lambdabot>       Inferred type: m b
05:39:40 <kmc> shachaf, the name of god
05:39:53 <shachaf> aristid: It won't type-check in Haskell.
05:40:10 <aristid> shachaf: i noticed
05:41:37 <kmc> does it type-check with a rank-3 callCC?
05:41:48 <shachaf> I don't think so.
05:43:07 <hpaste> kmc pasted “non-local exit from map” at http://hpaste.org/52648
05:43:32 <kmc> Axman6, here's my example of something vaguely useful you can do with Cont
05:44:01 <kmc> of course there are better ways to accomplish this particular toy example in Haskell
05:44:03 <kmc> e.g. Either
05:44:16 <kmc> but when your non-local escapes and escapes-from-escapes become complicated enough
05:44:17 <Axman6> huh, how interesting
05:44:19 <kmc> Cont always has enough rope
05:44:31 <kmc> in Haskell it's almost fair to say that needing Cont at all is a code smell
05:44:40 <Axman6> heh
05:44:47 <kmc> and that you can always refactor to avoid it
05:44:49 <kmc> *shrug*
05:45:03 <kmc> i do find explicit CPS in Haskell to be useful, to the point of using it without realizing you're using it
05:45:21 <kmc> like calling a function with a success continuation and a failure continuation
05:45:58 <Axman6> hmm, isn't that what iteratees often do?
05:46:11 <kmc> yeah
05:46:17 <kmc> usually iteratees are represented as algebraic data
05:46:30 <kmc> but you could transform them to a functional representation
05:46:50 <kmc> that's the idea behind http://hackage.haskell.org/packages/archive/monad-ran/0.1.0/doc/html/Control-Monad-Ran.html
05:47:17 <kmc> iirc Oleg's paper on LogicT also discusses implementations of that monad in terms of data vs. delimited control
05:47:51 <kmc> wow, an edwardk package which does not depend on any other edwardk packages
05:47:52 <shachaf> kmc: Every monad involves writing in explicit CPS, pretty much. :-)
05:47:58 <kmc> i guess because it's from 2009
05:48:01 <kmc> *nod*
05:48:10 <kmc> but if we admit that, it will destroy my arguments against node.js
05:48:32 <Axman6> heh
05:48:36 <shachaf> You should use it to write a "Haskell for node.js programmers" guide.
05:48:49 <kmc> that would require me to learn something about node.js
05:49:02 <deech> Hi all, is there a way to "cabal install" with the source? I checked ~/.cabal/config and couldn't find a setting.
05:49:07 <shachaf> Should be easy. "It's just like what you're used to, except you have to use it for almost *everything*, even setting variables and such, but we have this nice syntax for it"
05:49:17 <kmc> deech, not afaik, but you can fetch source with "cabal unpack"
05:49:37 <aristid> shachaf: for marketing reasons, i object to using the words "have to"
05:49:58 <kmc> shachaf, the big difference is that node.js code is only 'preemptible' at those continuation-passing points
05:50:03 <shachaf> I fetch quite a lot of packages with cabal unpack. I eventually gave up on deleting them.
05:50:10 <shachaf> shachaf@argon:~$ ls Hkg/ | wc -l
05:50:10 <shachaf> 56
05:50:21 <shachaf> kmc: Well, there's no fundamental reason Haskell couldn't be the same.
05:50:30 * shachaf gets a vague sense of déjà vu.
05:50:31 <kmc> yes, but GHC Haskell isn't
05:50:31 <deech> kmc: Thanks, basically I have cabal automatically generating Haddocks for every package I install but the "Source" link isn't there presumably because I don't have it. Is there some way around it?
05:50:32 <aristid> can Iteratee be completely replaced by Cont? :D
05:50:50 <deech> kmc: BTW nice slides.
05:51:03 <kmc> shachaf, so you can still argue that GHC's approach to async IO is fundamentally better than node's, and not just syntactically better
05:51:14 <aristid> wait, stupid question. of course they can.
05:51:15 <kmc> (you can also argue it's worse on the same grounds)
05:51:18 <shachaf> Because it has "preëmption"?
05:51:21 <aristid> Cont is the mother of all monads, after all
05:51:30 <kmc> there is some value in making explicit where your threads might be preempted
05:51:38 <kmc> yeah shachaf
05:51:45 <kmc> because preemption to do IO can occur even in pure computation
05:51:56 <kmc> which it can't in node, which was the source of much consternation lately
05:52:18 * shachaf wonders whether he should just give up on the diæresis.
05:52:25 <kmc> and of course it's the internet so the blog articles aren't like "node.js has this one flaw" but "node.js is cancer" and "node.js is for drooling idiot retard morons" and "haskell cures cancer and will give you a pony"
05:52:39 <aristid> what's the nicest monad for generating values? i don't like Enumerator, plus it's no monad
05:52:46 <kmc> I already have a bunch of source tarballs in ~/.cabal/packages/hackage.haskell.org
05:52:52 <kmc> deech, thanks
05:52:57 <kmc> generating values?
05:53:09 <shachaf> MonadSupply?
05:53:10 <aristid> kmc: like Enumerator. don't need more power than that.
05:53:16 <shachaf> Oh.
05:53:54 <kmc> shachaf, never give up
05:53:55 <aristid> i guess strictly speaking i want a monad transformer
05:55:27 <shachaf> kmc: node.js would still benefit from having some sort of monad syntax.
05:55:41 <shachaf> (And there are many source transformers to give it that sort of syntax, to various degrees.)
05:55:58 <kmc> *nod*
05:58:22 <kmc> shachaf, so what are some good examples of using continuations
05:58:27 <kmc> which i could use in my blog post
05:59:21 <shachaf> kmc: Didn't you just state that all examples of using continuations should be replaced with something less general?
06:01:35 <AJMurphy> newby question: what does it mean when ghc says that one package is shadowed by another?
06:01:45 <shachaf> @google site:okmij.org continuations
06:01:46 <lambdabot> http://okmij.org/ftp/continuations/index.html
06:01:47 <lambdabot> Title: Continuations and delimited control
06:04:59 <kmc> shachaf, no i used some weasel words like "could be argued"
06:05:21 <shachaf> Oh, true. Well, the wide world of Oleg awaits.
06:06:49 <kmc> :)
06:06:55 <kmc> i like http://okmij.org/ftp/continuations/shift-v-fork.html
06:07:08 <shachaf> kmc: http://www.haskell.org/pipermail/haskell-cafe/2008-February/038963.html
06:07:26 <kmc> i've thought about (but not implemented) full call/cc for C with fork(2)
06:07:37 <shachaf> Well, I just got to that from http://www.haskell.org/haskellwiki/Continuation , which has a bunch of other examples, I suppose.
06:07:57 <kmc> ok
06:07:58 <kmc> i'll check it out
06:08:28 <shachaf> Hmm, call/cc with fork wouldn't let you share state, would it?
06:08:29 <hpaste> ppp pasted “whats wrong” at http://hpaste.org/52649
06:08:43 <PopiT> why isn't this working? http://hpaste.org/52649
06:09:08 <shachaf> @type let doThis op p xs = filter p $ map op xs in doThis
06:09:09 <lambdabot> forall a a1. (a -> a1) -> (a1 -> Bool) -> [a] -> [a1]
06:09:18 <shachaf> PopiT: It seems fine to me. It's probably something about how you're using it.
06:09:33 <PopiT> i try entering "doThis sort (/= 't') "testing"
06:09:42 <kmc> shachaf, except for any explicitly shared state
06:09:47 <PopiT> for instance.
06:09:47 <shachaf> @let doThis op p xs = filter p $ map op xs
06:09:48 <lambdabot>  Defined.
06:10:04 <shachaf> PopiT: Well, you're mapping sort over that list.
06:10:06 <shachaf> > map sort "testing"
06:10:07 <lambdabot>   Couldn't match expected type `[a]'
06:10:07 <lambdabot>         against inferred type `GHC.Types...
06:10:13 <shachaf> That doesn't work unless you have a list of lists.
06:10:14 <kmc> it is pretty easy in POSIX / C to allocate a variable which will be shared over fork(2)
06:10:44 <shachaf> Hmm.
06:10:47 <shachaf> You should implement it!
06:11:06 <PopiT> ah you're right.. thanks shachaf.
06:13:58 <shachaf> Does GHC provide the asynchronous epoll etc. interface if you want to use it?
06:14:08 <shachaf> Or do you have to use threads?
06:14:22 <shachaf> (Not that threads are bad.)
06:14:31 <kmc> http://hackage.haskell.org/package/epoll
06:15:46 <shachaf> That binds to epoll, but not to GHC's I/O manager's interface to it.
06:16:03 <shachaf> Or to whatever kqueue/thread-pooly thing it does on other OSes.
06:16:16 <shachaf> Anyway, I guess using threads isn't a big deal.
06:17:28 <kmc> mm
06:17:38 <kmc> you could make a small wrapper library
06:19:19 <shachaf> Hmm, dolio wrote a nice article on continuations and delimited continuations: http://www.haskell.org/haskellwiki/Library/CC-delcont
06:21:02 <kmc> "If you've taken university courses in computer science... you've probably encountered continuations before"
06:21:05 <kmc> is that really true?
06:21:46 <Rotsor> not for me
06:21:47 <shachaf> Presumably it's true of dolio's university.
06:22:07 <shachaf> Or, rather, of dolio. He never says you'd encounter them *in* the course.
06:22:42 <ddarius> kmc: In one sense it probably is, but for Java schools, you'll probably never be explicitly exposed to them.
06:23:18 <shachaf> Or, rather, he does say that.
06:23:20 * shachaf sighs.
06:23:35 <kmc> heh
06:24:13 <hpc> the most interesting thing my uni has taught me is prolog
06:24:20 <kmc> i think even at a good school teaching real CS with a non-JavaSchool curriculum, it's rare that students would know about continuations in any depth
06:24:33 <ddarius> If you move the commas a bit, his statement becomes more true.
06:24:48 <ddarius> kmc: He never said anything about depth.
06:24:49 <kmc> or even "encounter" them
06:25:12 <hpc> kmc: it's even still fairly rare for haskell programmers to know about continuations
06:25:33 <ddarius> Know about /= understand
06:25:35 <hpc> they use them sure, but they don't realize what a continuation is as they do so
06:25:51 <shachaf> It's even rare for people who are experts on continuations to know about continuations.
06:25:57 <hpc> ^.^
06:25:59 <shachaf> Those cursed things.
06:26:09 <kmc> this CC-delcont article is good
06:26:53 * ddarius renames kmc to Keegan and Roeper.
06:27:26 <kmc> ?
06:27:49 <aristid> kmc: ddarius would never rename you without a good reason
06:31:10 <kmc> does anyone know what you would call the variant of the Traveling Salesman Problem where you are visiting line segments instead of points?
06:31:16 <kmc> (and traversing each segment as you do so)
06:31:49 <Clint> kmc: something about bridges?
06:32:18 <Clint> http://en.wikipedia.org/wiki/Seven_Bridges_of_Königsberg
06:32:40 <shachaf> kmc: http://en.wikipedia.org/wiki/Route_inspection_problem ?
06:36:38 <Axman6> kmc: where you're visiting edges instead of vertices?
06:36:53 <kmc> the edges aren't connected, though
06:37:13 <kmc> they're isolated line segments in R2
06:37:23 <kmc> i want to move along each line segment, and I can move freely between them
06:37:24 <shachaf> Oh.
06:37:38 <kmc> (i mean, sometimes they might be connected, but not in general)
06:37:49 * Axman6 is lost and goes away again
06:42:59 <Brandon_R> hi
06:43:59 <Axman6> 'lo
06:44:02 <kmc> hi Brandon_R
06:44:11 <Brandon_R> What's new
06:46:18 <aristid> Brandon_R: continuations. that's the topic du jour, anyways :)
06:46:31 <Axman6> a few days old, but this sounds like a great idea: http://www.reddit.com/r/haskell/comments/l9jvt/announce_vectorbytestring0000/
06:47:38 <Aymen> please where can i find a full tutorial about bnfc
06:48:18 <kmc> shachaf, the application i have in mind is lasering stuff
06:48:53 <shachaf> * kmc applies emergency "get people interested" maneuver.
06:49:11 <kmc> haha
06:49:23 <Axman6> Aymen: what is bnfc
06:49:58 <shachaf> kmc: Are there a significant number of edges to laser?
06:50:05 <kmc> i guess it is like http://en.wikipedia.org/wiki/Set_TSP_problem
06:50:08 <kmc> shachaf, sometimes?
06:50:54 <DevHC> /usr/bin/ld: build/M.o: relocation R_X86_64_PC32 against symbol `M_D_closure_tbl' can not be used when making a shared object; recompile with -fPIC
06:50:54 <DevHC> /usr/bin/ld: final link failed: Bad value
06:50:56 <DevHC> wtfbbq?
06:50:56 <Aymen> is a tool for creating domain specific languages including lexer , parser and ast generator and it is mainly used in haskell
06:52:10 <Nathan_> kmc: You helped me with the values a couple of days ago but I would like to get the keys aswell the same way
06:52:11 <Axman6> never heard of it :\
06:54:40 <kmc> okay
06:54:45 <kmc> Nathan_, what did you try?
06:56:06 <Nathan_> I've tried to convert it into a list and then just take the first with fst but that didnt work
06:56:15 <Nathan_> I'm pretty much stuck, even though the one you helped me with makes so much sense
06:56:19 <kmc> each node contains only one character of the key, right?
06:56:34 <Nathan_> Yeah
06:56:48 <Nathan_> so I need to somehow remember the characters that I've passed through
06:57:15 <kmc> yeah
06:57:21 <kmc> your recursive function can have another parameter for  this
06:57:51 <MarkDBlackwell> Is anyone using Coq (a proof assistant) to develop their Haskell programs? I came across a comment saying so: http://coq.inria.fr/a-short-introduction-to-coq
06:58:05 <Nathan_> The one Im using to get the values at the moment is values (TrieNode val children) = maybeToList val ++ concatMap (values . snd) children
06:58:11 <Nathan_> which makes perfect sence
06:58:20 <kmc> so this is your trie right?  data Trie a = TrieNode (Maybe a) [(Char, Trie a)]
06:58:41 <Nathan_> sure is
06:58:42 <kmc> with a list of subtries
06:58:51 <Nathan_> Yes
06:59:03 <Nathan_> so I was thinking if you could convert it into a list and then find the keys that way?
06:59:10 <Nathan_> or is i easier to do it the other way?
06:59:17 <kmc> that sounds like you're just restating the problem
06:59:24 <kmc> isn't any function which gets the keys going to return a list?
06:59:36 <Nathan_> oh...yeah >.<
06:59:39 <kmc> for a subtrie (x, t), get the keys of t, then stick x onto the beginning of each
06:59:58 <MarkDBlackwell> (in a comment by Luke Palmer).
07:00:03 <kmc> you might want to write it as a list comprehension
07:00:11 <kmc> MarkDBlackwell, http://hackage.haskell.org/package/meldable-heap
07:01:01 <Nathan_> Is the way we get the keys similar to the way we get the values?
07:01:19 <kmc> sort of
07:02:06 <Nathan_> since the one I showed you recursively calls the value on the subtries and since the subtries are the second ones in the pairs we use .snd
07:02:17 <shachaf> kmc: Getting the keys, particularly according to the specification you gave earlier, is a bit trickier.
07:02:17 <Nathan_> and then concatmap to add the lists together
07:02:32 <Nathan_> Yeah I've noticed
07:02:49 <kmc> you might want to write it as a list comprehension
07:03:14 <kmc> keys (TrieNode _ xs) = [ .... | (x, t) <- xs ]
07:03:15 <MarkDBlackwell> kmc, thank you! It seems I can google this kind of question on Hayoo: http://holumbus.fh-wedel.de/hayoo/hayoo.html
07:03:24 <co_dh> greeting. for the free theorem plugin, how can I enter a function of type 1+a -> a ? where 1 is the singleton set, + is the coproduct.
07:03:27 <aristid> all continuations in haskell are necessarily delimited, right?
07:03:30 <kmc> MarkDBlackwell, how?
07:03:47 <Nathan_> kmc: What does that code do?
07:04:03 <kmc> Nathan_, you should read about list comprehensions
07:04:15 <Nathan_> Doing it as we speak
07:04:32 <Nathan_> kmc: Is this one good? http://www.haskell.org/haskellwiki/List_comprehension
07:04:35 <Aymen> ok  , can i find a tutorial about functional style for solving problems ?
07:04:51 <kmc> maybe
07:04:53 <MarkDBlackwell> kmc, how do you mean? At Hackage, I found that link to search packages.
07:04:56 <kmc> they're also covered in every Haskell tutorial
07:05:05 <kmc> MarkDBlackwell, what does that have to do with Coq?
07:05:27 <MarkDBlackwell> kmc, or do you mean, how to use coq to develop Haskell programs?
07:05:34 <co_dh> oh, wait, I remember that coproduct is not supported by polymorphic lambda .
07:05:54 <kmc> MarkDBlackwell, your question was "which Haskell software is developed with the help of Coq"
07:05:57 <Nathan_> So after I've list comprehensed, it makes it easier to get the keys?
07:06:12 <kmc> i was wondering how Hayoo helps answer that question
07:06:35 <kmc> Nathan_, i don't understand your question
07:06:55 <kmc> list comprehension is a Haskell language feature which I think will help you write this function
07:07:05 <Nathan_> kmc: Hmmm...I think its better if I read the guide and then come back to you
07:07:05 <kmc> it's the feature I was using in the code fragment I gave
07:07:07 <kmc> yes
07:07:19 <Nathan_> Alright, Ill get back to you. Cheers
07:07:27 <kmc> Nathan_, http://learnyouahaskell.com/starting-out#im-a-list-comprehension
07:08:26 <MarkDBlackwell> kmc, yes, thanks for the specific code reference, so I guess Coq is useful for developing Haskell, then. I was humorously referring to the meme, 'Let me google that for you.' :)
07:08:37 <kmc> heh
07:09:31 <MarkDBlackwell> kmc, thanks, again.
07:09:33 <Axman6> MarkDBlackwell: i think the proof assisstant of choice for developing haskell is Agda these days
07:10:00 <Axman6> or Isabelle (sp?)
07:10:04 <mm_freak> Aymen: do you already know how to write simple programs in haskell?
07:10:29 <Aymen> yes just simple
07:10:54 <mm_freak> Aymen: then it's time to get your hands wet…  do exercises
07:10:59 <MarkDBlackwell> kmc, Axman6, well, interestingly, the Hayoo search for 'coq' did turn up Agda! :)
07:11:38 <mm_freak> Aymen: simple exercises like the Project Euler problems will help you…  as you go along, your style will become more functional
07:12:16 <mm_freak> Aymen: have you used a nonfunctional language before haskell?
07:12:16 <kmc> project euler is good for very beginning exercises
07:12:22 <MarkDBlackwell> kmc, Axman6, and meldable-heap, though not Isabelle.
07:12:23 <Aymen> no
07:12:24 <kmc> Aymen, I like these exercises:
07:12:26 <kmc> @where cs11
07:12:27 <lambdabot> http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
07:12:41 <Nathan_> Hmmmm
07:12:49 <kmc> hmm, there used to be five
07:12:50 <mm_freak> Aymen: perhaps surprisingly that's actually helpful…  people without exposure to other languages will have an easier time learning haskell
07:12:52 <kmc> check the wayback machine ;)
07:13:00 <Nathan_> kmc: Would I be able to take that trie and filter out everything except letters from it?
07:13:07 <jmcarthur> i don't like little exercise. i prefer small projects
07:13:10 <kmc> Nathan_, I don't understand
07:13:14 <jmcarthur> for learning
07:13:38 <jmcarthur> interpreters, bots, simple games, etc.
07:13:46 <hpaste> hato pasted “wx hsplitter and vsplitter help” at http://hpaste.org/52650
07:13:49 <Nathan_> Nvm, guess I was thinking wrong =(/
07:14:14 <mm_freak> kmc: some of the later PE problems can be solved very elegantly in haskell in a very idiomatic functional style using all features of the pure land
07:14:22 <mm_freak> you won't use IO land much, though
07:14:23 <Aymen> oh i'm sorry i learn many imperative languages before haskell
07:15:00 <rferranti> can someone suggest a piece of working opensource software written in haskell (possibly stylish and idiomatic)?
07:15:14 <MarkDBlackwell> Axman6, Agda: thanks. The Coq-referencing comment was from way back in 2008.
07:15:20 <mm_freak> Aymen: just try think in terms of data, not operations
07:15:23 <kmc> Nathan_, here's something to get you started
07:15:25 <kmc> keys (TrieNode _ xs) = [ (x:k) | (x,t) <- xs, k <- keys t ]
07:15:27 <Aymen> i dont see the non before functional :)
07:15:28 <kmc> it doesn't work, though
07:15:30 <mm_freak> Aymen: describe your solutions, not the steps to get there
07:16:16 <mm_freak> rferranti: GHC, darcs, xmonad, pandoc
07:16:32 <rferranti> mm_freak, thank you
07:16:39 <kmc> GHC code is terrible
07:16:45 <kmc> it's far from idiomatic Haskell
07:16:45 <mm_freak> rferranti: no idea how stylish/idiomatic they are…  xmonad is probably the worst in that regard, but that's not really the author's fault
07:16:53 <kmc> what, xmonad is the worst?
07:16:56 <kmc> i think xmonad code is pretty clean
07:16:58 <Axman6> rferranti: xmonad especially
07:17:10 <kmc> pandoc is also well-regarded, but I haven't read its code
07:17:11 <mm_freak> kmc: clean and very imperative…  that's X's nature
07:17:13 <kmc> it's a great tool too
07:17:21 <kmc> mm_freak, so? that's part of idiomatic Haskell too
07:17:32 <Axman6> yeah, i've heard xmonad used as an example of a decent sized project to look at several times
07:17:34 <Nathan_> Hmmm
07:17:49 <mm_freak> kmc: depends…  likely i would have written a better design pattern around X
07:17:58 <mm_freak> instead of using X directly
07:18:01 <kmc> in fact I learned a couple idiomatic tricks for working in IO from reading xmonad code
07:18:14 <kmc> mm_freak, can you speak in specifics?
07:18:25 <hpc> kmc: ooh, what sort of tricks?
07:18:36 <kmc> fix $ \again -> do .... when (foo) again
07:18:49 <hpc> oh, yeah i love that trick
07:18:52 <Axman6> ew :\
07:19:00 <Axman6> why is that good?
07:19:06 <mm_freak> kmc: well, nowadays i map everything to FRP if it makes sense…  for window managers it does
07:19:10 <shachaf> Axman6: Better than defining a name for the loop?
07:19:11 <kmc> ok
07:19:12 <mm_freak> or for X in general
07:19:18 <kmc> do you have a working window manager using FRP?
07:19:18 <shachaf> Axman6: I suppose you'd prefer runCont, eh?
07:19:27 <Axman6> i always feel that defining the name leads to clearer code
07:19:28 <hpc> Axman6: for when you really just need a while loop :P
07:19:29 <mm_freak> kmc: no, because i don't write window managers =)
07:19:44 <kmc> i'd love to see one, but I'm skeptical at this point in time
07:19:52 <Aymen> how can i describe the solution
07:20:02 <quackquack> Can anyone point me to an example where http-enumerator is used to stream HTTP?
07:20:03 <hpc> a trick ive found i can do with gtk is
07:20:09 <hpc> longIdleAction x = do
07:20:15 <hpc>   somethingShortWith x
07:20:16 * shachaf would love to see a window manager that was more... Static...
07:20:17 <kmc> I think it's harmful to act like all code doing IO is intrinsically ugly and un-idiomatic and un-Haskellish
07:20:18 <hpc>   idleAdd $ do
07:20:19 <hpc>   ...
07:20:40 <hpc> and it repeatedly queues short bursts of code, so the main loop never blocks
07:20:47 <Axman6> quackquack: yesod?
07:20:57 <kmc> we have this useful multi-paradigm language with a good implementation that handles massive concurrency and async IO and transactions and...
07:21:08 <mm_freak> Aymen: well, that's the question…  it really depends on the data structure you use for the specific problem…  for all data structures there are functions that generate them
07:21:10 <hpc> kmc: imo, haskell is a better C than C is, because of what you can do with first-class IO
07:21:23 <kmc> but the general perception is that Haskell is an impractical language advocated by ideological extremists
07:21:24 <mm_freak> Aymen: for example when you use haskell arrays there is the 'listArray' function
07:21:35 <shachaf> hpc: Can you write me a simple program that loops using variables in Haskell that doesn't look horrible compared to C?
07:21:37 <kmc> and I'd like that to change
07:21:40 <aristid> Axman6: yesod is server, http-enumerator is client
07:21:43 <shachaf> Say, an iterative factorial, with IORefs.
07:21:46 <mm_freak> Aymen: for example try to solve your problem with (!) and listArray only
07:22:05 <quackquack> Axman6: like aristid said, i want to stream as a client not server
07:22:07 <mm_freak> Aymen: that will give you an insight into how to wrap data structures around algorithms instead of the other way around
07:22:08 <Axman6> kmc:  me too, i love writing many things in haskell using IO
07:22:20 <Axman6> quackquack: ah, well the question mark was warranted =)
07:22:21 <mm_freak> kmc: no, i don't have any problem with IO
07:22:37 <mm_freak> kmc: but for non-batch programs i found FRP to be a very clean design pattern
07:22:59 <mm_freak> kmc: i use it in networking, web programming, graphics, etc.
07:23:10 <kmc> i've not done any FRP; what's the best place to start?
07:23:12 <rferranti> cough what FRP stands for?
07:23:21 <shachaf> fac :: Int -> IO Int; fac n = do { i <- newIORef 1; r <- newIORef 1; whileM_ ((<=) n <$> readIORef i) $ do {readIORef i >>= \v -> modifyIORef r (*v); modifyIORef i (+1)}; readIORef r } -- Horrible
07:23:22 <mm_freak> rferranti: functional reactive programming
07:23:57 <mm_freak> kmc: that's a good question…  there are many ways to implement FRP, though i think two of them are popular:  monadic FRP and arrowized FRP (AFRP)
07:24:09 <rferranti> ty
07:24:14 <mm_freak> kmc: i do AFRP and have written an own library for that called netwire
07:24:27 <mm_freak> before that i used yampa, but always hit its limitations
07:24:31 <Axman6> is it on hackage?
07:24:38 <mm_freak> Axman6: yes
07:24:42 <kmc> cool, I'll take a look :)
07:24:53 <mm_freak> go ahead =)
07:25:02 <Axman6> @hackage netwire
07:25:02 <lambdabot> http://hackage.haskell.org/package/netwire
07:25:10 <aristid> shachaf: write an instance of MonadState for (IORef s, IO a), and use MonadState?
07:25:18 <kmc> in my view "never use mutation" and "use mutation everywhere for no reason" are both untenable extremist positions, and what Haskell (or Clojure) encourages is a reasonable moderate position
07:25:39 <hatomic> could anyone help me find out whats wrong in this wxHaskell layout ? http://hpaste.org/52650
07:25:44 <shachaf> aristid: At that point you might as well just use MonadState to compute the whole thing. Anyway MonadState over IO is redundant.
07:25:46 <kmc> but the latter extremist position is the norm in programming, so the Overton window is shifted over
07:25:51 <mm_freak> kmc: actually AFRP is based a lot on mutations, but you don't mutate values…  you allow functions to mutate themselves
07:25:59 <Nathan_> I honestly cant see how I should fix it
07:26:09 <aristid> shachaf: it may be redundant, but you can use nicer combinators
07:26:19 <hpc> shachaf: http://hpaste.org/52651
07:26:20 <Nathan_> It gives an empty list so Im guessing its not remembering all the chars its passed?
07:26:34 <kmc> and also Haskell has been marketed poorly in the past as something much closer to "never use mutation" than the reality of code people write
07:26:45 <kmc> (avoid success!)
07:26:54 <mm_freak> kmc: the basic idea is this:  newtype Auto a b = Auto (a -> (b, Auto a b))  -- once you have written Category and Arrow instances for that type, you have effectively understood AFRP
07:27:01 <Aymen> ok the problem is implementing the classical simple "if" statement , using the imperative approach we say: if <eval_cond> then <do_stmts> end ; but how can i do that using functional approach ?
07:27:31 <shachaf> hpc: All that getting and setting...
07:27:33 <kmc> Aymen, you're not going to learn functional thinking if your approach is to take imperative constructs and implement them in a functional language
07:27:33 <Axman6> Aymen: it doesn't make any sense in a language like haskell
07:27:57 <kmc> Nathan_, the problem is that you get to a leaf of the trie and you have [ (x:k) | (x,t) <- [], k <- keys t ]
07:28:00 <hpc> shachaf: it's really not that much
07:28:01 <kmc> Nathan_, and that's just []
07:28:15 <Axman6> in a language like haskell, you don't say 'do this, then do this, then if this thing is true, do this, then do this'. you talk about the data you want to compute
07:28:24 <kmc> Nathan_, you need to do something different when you hit a (TrieNode (Just _)) i.e. a point at which the key might end
07:28:24 <mm_freak> Aymen: simple answer:  you use haskell's "if"…  better answer:  you won't need it a lot…  it's just a convenience
07:28:33 <kmc> I'm not exactly sure what myself
07:28:40 <mm_freak> Aymen: but the haskell 'if' corresponds to ?: from C-like languages
07:28:48 <Nathan_> Hmm
07:28:53 <mm_freak> not to the imperative "if this, then /do/ that"
07:29:08 <hpc> shachaf: haskell doesn't have mutable non-pointer values
07:29:14 <shachaf> hpc: I know.
07:29:21 <hpc> shachaf: if you wrote that C code with int*s, it would be uglier
07:29:27 <hpc> because mallocs
07:29:31 <mm_freak> Aymen: the if statement allows a value to depend on a condition…  it's really just a nicer way to write 'case' on booleans
07:29:49 <Aymen> no i mean i'm trying to make an interpreter
07:29:57 <shachaf> hpc: You can still say *x *= *y instead of "y_ = y; *x *= y_"
07:30:05 <Nathan_> There should honestly be a simpler solution to my problem :P
07:30:13 <brisingr> Aymen: can you elaborate on that?
07:30:14 <shachaf> Nathan_: Your problem isn't very hard.
07:30:15 <sipa> Aymen: an interpreter for an imperative language?
07:30:21 <shachaf> Nathan_: You just need a couple of helper functions.
07:30:35 <ader111> I got disconnected and I was asking a question about Iteratee/ Enumeratee
07:30:41 <Nathan_> shachaf: To me it is, my mind is stuck at imperative languages
07:30:46 <ader111> anyone here can answer me?
07:30:54 <hpc> shachaf: there's probably a nicer way to do that, but i couldn't think of it in 5 minutes :P
07:31:02 <kmc> Nathan_, okay, I have it working and can give additional hints
07:31:09 <shachaf> Nathan_: Right, that's why it's a good problem. Once you're experienced with Haskell and/or Tries, it won't be hard anymore. :-)
07:31:12 <mm_freak> ader111: please don't ask to ask…  everybody is welcome to ask their questions right away =)
07:31:21 <Axman6> Aymen: not without knowing what your question is
07:31:28 <Axman6> uh, ader111*
07:31:29 <Nathan_> shachaf: ikr? Can wait to that day :D
07:31:34 <ader111> thank you
07:31:42 <Aymen> the "if" i want is in my new interpreter not haskell
07:31:54 <kmc> Nathan_, are the keys of «TrieNode (Just _) xs» different from the keys of «TrieNode Nothing xs»?
07:32:06 <mm_freak> Aymen: i see…  do you have a syntax tree type defined for your language?
07:32:10 <sipa> Aymen: your interpreter will typically have a state that is being modified
07:32:14 <Aymen> yes
07:32:21 <shachaf> kmc: Does your implementation handle trieRest "bl" <trieOf ["bl","blue"]> as ["","ue"]?
07:32:27 <ader111> Actually I was wondering, an Enumeratee returns the inner iteratee, which is really nice but overwhelming for a lot of simple cases
07:32:28 <Nathan_> kmc: What do you mean?
07:32:42 <kmc> Nathan_, I mean if you call the "keys" function on those two tries, do you get the same result?
07:32:42 <sipa> Aymen: so you execution may be centered around a function: exec :: Command -> State -> State
07:32:46 <mm_freak> Aymen: your type is probably a lot similar to IO and there is a mapping from your type to an IO computation
07:33:05 <byorgey> Aymen: are you stuck writing some particular code?  if you show us what you have already we can probably provide more specific advice.
07:33:05 <mm_freak> Aymen: example:  exec (Print str) = putStr str
07:33:13 <ader111> Does it make sense to generalize a special case of Enumeratee for simple cases where EOF to the outer sends EOF to the inner?
07:33:24 <byorgey> Aymen: otherwise the advice you get is likely to be all over the map and not really addressing your particular confusion.
07:33:30 <mm_freak> Aymen: an 'if' without an 'else' would likely translate to a 'when' from Control.Monad
07:33:32 <sipa> Aymen: and if that Command is an If, you'd do: exec (If cond thenPart elsePart) = if (eval cond) then exec thenPart else exec elsePart
07:33:51 <Nathan_> kmc: I get an empty list when I try a tree with stuff in it and on an empty tree, if thats what you meant
07:34:10 <mm_freak> ader111: yes
07:34:26 <ader111> this will give a simpler type to these cases (returning directly the computed value in the outer)
07:34:27 <kmc> Nathan_, I'm not asking about the code you wrote, I'm asking about what the answer *should* be
07:34:30 <shachaf> I think keys (TrieNode (Just _) xs) = "" : keys (TrieNode Nothing xs)
07:34:40 <mm_freak> ader111: but it's probably not a good idea to do that…  are you sure you need an enumeratee?  perhaps you just need an enumerator
07:34:47 <shachaf> kmc: That's the most reasonable interpretation I can come up with of the specification he gave a while ago.
07:35:00 <Nathan_> kmc: It should return the keys in the trees? (Seems like Im not understand what you mean, excuse me if I dont)
07:35:09 <ader111> mm_freak: I need to map, transform, the input type
07:35:13 <hpaste> kmc pasted “trie keys” at http://hpaste.org/52653
07:35:17 <kmc> that's my full solution
07:35:32 <shachaf> kmc: Oh, that was only half his problem.
07:35:33 <kmc> Nathan_, I'm asking you to be more precise about what the keys of a trie are
07:35:45 <Nathan_> kmc: Oh, sorry
07:35:58 <kmc> Nathan_, before you write a function you should have some idea what outputs it will give on some inputs
07:36:02 <shachaf> Nathan_: Where did this Trie data type come from?
07:36:22 <Nathan_> shachaf: ?
07:36:24 <ader111> mm_freak: basically for implementing useful functions for transforming iteratees input
07:36:33 <shachaf> Nathan_: Is this Trie data type something that you defined yourself?
07:36:40 <mm_freak> ader111: sorry, i misread your question…  an enumeratee can send anything to its iteratee
07:36:41 <shachaf> Did it come from an assignment?
07:36:52 <Nathan_> shachaf: Naah my friend helped me
07:36:53 <kmc> Nathan_, if you don't know what the function should return, then you don't even know if it's correct
07:36:56 <shachaf> Do you understand what it's supposed to mean?
07:37:14 <mm_freak> ader111: an enumerator is a special case of an enumeratee, which ignores its input and just sends something to the iteratee
07:37:17 <shachaf> That's easy. It should return the right answer.
07:37:35 <mm_freak> ader111: the enumeratee /has to/ send EOF at some point, as long as the iteratee is in Continue state
07:38:31 <ader111> mm_freak: yes but it return the inner iteratee. And I would like generalize a case where a enumeratee like sends directly the computed value from the inner iteratee
07:38:42 <kmc> shachaf, only half? explain?
07:38:43 <Aymen> ok the problem is how can i tell haskell to fetch the statements if the condition is true "then" skip
07:39:01 <mm_freak> ader111: i'm not sure i understand this…  could you rephrase?
07:39:02 <Nathan_> kmc: Could you explain that code? I want to learn and write the function myself :P
07:39:02 <ader111> this can cover a lot of simple cases without need to run the outer, then run the inner
07:39:19 <kmc> Nathan_, yes
07:39:22 <Nathan_> So I can have that code as a reference when I try to write a function myself
07:39:23 <kmc> which part should i explain?
07:39:54 <Nathan_> childkeys :)
07:40:01 <kmc> okay
07:40:11 <kmc> maybe the Haskeller habit of using one-letter variable names is unhelpful here :)
07:40:15 <byorgey> Aymen: Your question does not make sense to me.  Do you have any code you can show us?
07:40:18 <kmc> also I should have added type signatures
07:40:20 <shachaf> kmc: I believe his assignment was to write a function f such that f "b" <the trie consisting of ["blue","brown","red","green"]> == ["lue","rown"]
07:40:31 <Aymen> ok
07:40:32 <kmc> shachaf, oh, I missed that
07:40:44 <kmc> Nathan_, anyway xs :: [(Char, Trie a)]
07:40:49 <ader111> mm_freak: ok.
07:40:53 <ader111> type Enumeratee aOut aIn m b = Step aIn m b -> Iteratee aOut m (Step aIn m b)
07:40:59 <shachaf> The implementation pretty clearly involves writing findRoot and keys, though
07:41:02 <byorgey> Aymen: you can paste your code on hpaste.org
07:41:03 <ader111> this is an example of Enumeratee type
07:41:08 <kmc> i.e. all the subtries of a TrieNode... each pair represents the trie you search after matching some character
07:41:40 <kmc> so if the pair (x,t) is in that list, and the keys of t are k, then (x:k) is a key of the original TrieNode
07:41:40 <ader111> type SimplerEnumeratee aOut aIn m b = Step aIn m b -> Iteratee aOut m b
07:41:41 <mm_freak> ader111: are you asking for something equivalent to 'Step aIn m b -> Iteratee aOut m (Either b (Step aIn m b))'?
07:41:46 <kmc> does it make sense Nathan_?
07:41:47 <ader111> does this mae sense?
07:42:00 <hpaste> Aymen pasted “bnfc?” at http://hpaste.org/52654
07:42:03 <Nathan_> Kind of
07:42:19 <Nathan_> I wrote it down and I'll try to understand it more after lunch
07:42:26 <monochrom> kmc: it is not like you can rename "k" to "keys" and "x" to "data" anyway
07:42:28 <mm_freak> ader111: well, it could make sense, but that's really just an enumerator, which has a different own input
07:42:33 <kmc> Nathan_, then for a full node, we just use that function
07:42:36 <Nathan_> still thinking that it should be an easier way to write it
07:42:49 <hpaste> hatomic annotated “wx hsplitter and vsplitter help” with “wx hsplitter and vsplitter help (correction)” at http://hpaste.org/52650#a52655
07:42:53 <kmc> Nathan_, except that a trie with a value (i.e.  Just something) also has "" (or []) as a key
07:42:58 <shachaf> Nathan_: The whole point of an assignment is that it's not easy when you don't understand it. :-)
07:43:01 <mm_freak> ader111: i wouldn't know what to call it though, and i think the different outer type would make things worse, not better
07:43:21 <Nathan_> shachaf ;)
07:43:21 <kmc> that base case is necessary; otherwise you get an empty list everywhere (as you noted before)
07:43:28 <kmc> Nathan_, if you find a simpler way, let us know :)
07:43:29 <Nathan_> kmc: Yeah
07:43:36 <mm_freak> ader111: try to write the function, which applies that enumerator to an iteratee
07:43:38 <Nathan_> kmc: I'll try to work on one lol :P
07:43:47 <ader111> mm_freak: is it, first the monad is inside
07:43:47 <Nathan_> kmc: Thank you very much though, I appreciate it
07:43:58 <Nathan_> Time for lunch and then work with some haskell :-D
07:44:00 <kmc> shachaf's with «keys (TrieNode (Just _) xs) = [] : keys (TrieNode Nothing xs)» is a bit simpler, but i think less clear
07:44:16 <kmc> or "a bit shorter" anyway
07:44:31 <shachaf> It's a bit of a hack, yes.
07:44:36 <shachaf> Not as much of a hack as my findRoot was.
07:45:02 <Aymen> ok transStmt is a function that take a statement and depend on it it take the decision and interpret the arguments
07:45:08 <byorgey> Aymen: 'map transStmt stmts' -- note that this has type [IO ()], but you need something of type  IO ()
07:45:23 <byorgey> Aymen: you can use mapM instead of map to sequentially run all the actions
07:45:40 <Aymen> how
07:45:43 <aristid> :t mspM
07:45:43 <lambdabot> Not in scope: `mspM'
07:45:45 <mm_freak> ader111: i suggest asking this question on the haskell-cafe mailing list…  there you will reach the authors of the various iteratee implementations
07:45:46 <byorgey> Aymen: so instead of  'let e = ... in return()' you can just say  'mapM transStmt stmts'
07:45:47 <aristid> :t mapM
07:45:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:45:59 <aristid> :t mapM id
07:45:59 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
07:46:04 <hpc> Aymen: note that mapM will give you IO [()]
07:46:07 <byorgey> Aymen: and the 'else return()' will take care of doing nothing in the case that the test is false.
07:46:10 <ader111> ok, I'll try that then
07:46:14 <byorgey> oh, right, sorry, I meant  mapM_
07:46:16 <alpounet> mapM_
07:46:20 <hpc> Aymen: mapM_ will give you IO ()
07:46:25 <ader111> thank you mm_freak
07:46:28 <aristid> :t sequence_
07:46:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
07:46:42 <hpc> Aymen: there's also sequence_, which mapM_ uses
07:46:47 <hpc> @src mapM_
07:46:47 <lambdabot> mapM_ f as = sequence_ (map f as)
07:46:53 <mm_freak> ader111: particularly the two Johns of iteratees (Lato and Millikin) may help you there
07:46:59 <byorgey> Aymen: let e = [transStmt (x)|x <- stmts] in return ()  -- note also, this does not do anything.  it defines 'e' and then does not use 'e'.
07:47:03 <aristid> @src sequence_
07:47:03 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:47:16 <byorgey> Aymen: you don't really need any of the  'let ... in ...'
07:47:20 <hpc> Aymen: and if you want a more imperative flavor, forM and forM_ are the same as the mapMs with the arguments reversed
07:47:33 <mm_freak> (i always read mapM_ as mm_freak and wonder why my highlighter doesn't work)
07:47:44 <Aymen> but what mapM do ?
07:47:58 <shachaf> It maps M.
07:48:15 <shachaf> Aymen: You should probably read some introduction to Haskell that explains these things rather than asking all of them in the channel.
07:48:23 <mm_freak> Aymen: it's like 'map', but your mapping function is monadic:  Monad m => (a -> m b) -> [a] -> m [b]
07:48:24 <shachaf> The guide is more in-depth than we can be in 80-character lines. :-)
07:48:34 <hpc> Aymen: it maps f over a list, then sequences the resulting list of actions
07:48:43 <hpc> @where lyah
07:48:43 <lambdabot> http://www.learnyouahaskell.com/
07:48:47 <brisingr> mapM is the ub3r h4x0r version of map
07:48:47 <hpc> ^ read that
07:49:20 <Aymen> ok
07:49:47 <shachaf> When I first encountered mapM_ I thought "there are so many variations of map in Haskell that they used up *all* the alphabet letters and had to resort to adding underscores?"
07:49:58 <kmc> Real Programmers use Data.Traversable.mapM
07:50:12 <aristid> :t sequenceA
07:50:12 <lambdabot> Not in scope: `sequenceA'
07:50:21 <mm_freak> aristid: Data.Traversable
07:50:22 <brisingr> Aymen: basically you want some sort of container for your variables etc. State does this nicely
07:50:31 <aristid> :t Data.Traversable.sequenceA
07:50:32 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
07:50:45 <aristid> :t Data.Foldable.sequenceA_
07:50:46 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Foldable.Foldable t, Applicative f) => t (f a) -> f ()
07:51:05 <aristid> lolwut i knew the module right this time
07:51:05 <brisingr> lyah has an awesome explanation of State
07:52:22 <DevHC> i am compiling with -fPIC, ffs! yet when i use ``ld -shared'', i get: relocation R_X86_64_PC32 against symbol `M_D_closure_tbl' can not be used when making a shared object; recompile with -fPIC
07:52:34 <shachaf> DevHC: Is this a GHC 7.2 thing?
07:52:40 <DevHC> no
07:52:43 <DevHC> 6.12.1
07:52:48 <shachaf> Is this a Mac OS thing?
07:52:52 <DevHC> no
07:53:04 <DevHC> x86_64 GNU/Linux
07:53:41 <geheimdienst> maybe it's trying to link against some library which was not compiled with -fPIC? (just a thought)
07:54:42 <DevHC> D is a data type in my hs file
07:55:32 <DevHC> all i am doing is: ``ld -shared M.o''
07:56:18 <shachaf> DevHC: Why are you linking manually?
07:57:04 <DevHC> 1. why not?
07:57:29 <shachaf> 1. Because it breaks.
07:57:46 <mm_freak> does anyone know an actual use case for pure State monads?
07:58:08 <DevHC> 2. because i have a big Makefile for a C program, in which i've added only 1 Haskell file
07:58:11 <DevHC> 1. why?
07:58:17 <hpc> mm_freak: yes :P
07:58:25 <shachaf> DevHC: Why don't you find out what flags GHC is calling ld with?
07:58:42 <DevHC> GHC is NOT calling ld, atm.
07:58:47 <mm_freak> hpc: i mean for State s Identity, not StateT in general
07:59:00 <mm_freak> s/State/StateT/
07:59:20 <hpc> ah
07:59:40 <hpc> it could be at the bottom of a transformer stack :P
07:59:49 <akosch> can I use cabal to do miscellaneous stuff during the build process, like running the google closure compiler on my javascript?
08:00:13 <DevHC> also, i get ``could not read symbols: Bad value''
08:00:34 <mm_freak> akosch: yes…  look into the cabal documentation
08:02:18 <DevHC> btw, ``ld -shared M_stub.o'' yields no error if an only if i specify -fPIC. but ``ld -shared M.o'' always yields the error
08:02:33 <shachaf> DevHC: GHC gives ld lots of flags when it links.
08:07:01 <_s1gma_> @hoogle forever
08:07:02 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
08:07:58 <aristid> @src forever
08:07:58 <lambdabot> Source not found. Do you think like you type?
08:08:08 <monochrom> actually ghc calls gcc to link, and so gcc calls ld (or there is even one more middleman). so eventually ld receives 3 tons of flags.
08:08:25 <aristid> forever x = let go = x >> go in go
08:08:35 <DevHC> GHC fails: /usr/bin/ld: /usr/lib/ghc-6.12.1/base-4.2.0.0/libHSbase-4.2.0.0.a(Base__3.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC
08:08:35 <monochrom> note that ghc already gives 1 ton of flags to gcc for that
08:08:55 <shachaf> Thanks to the wonders of strace, you can figure out all of them.
08:09:08 <ion> @fix forever x = let go = x >> go in go
08:09:08 <lambdabot> Maybe you meant: bid faq ft id thx
08:09:28 <aristid> ion: ?
08:09:42 <ion> There should be a bot command to change functions following that pattern to fix form. ;-)
08:09:49 <monochrom> there is the possibility that you have to build GHC yourself (basically to build all the libs yourself) and specify -fPIC there
08:09:57 <shachaf> ion: @pl will do that.
08:09:58 <ddarius> ion: @pl
08:09:58 <aristid> :t \x -> let go = x >> go in go
08:09:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
08:10:01 <shachaf> (Among other things.)
08:10:03 <DevHC> wtf? :S S:
08:10:09 <aristid> @pl \x -> let go = x >> go in go
08:10:10 <lambdabot> fix . (>>)
08:10:17 <aristid> yay.
08:10:19 <ion> Ah
08:10:50 <ion> @unpl fix . (>>)
08:10:50 <lambdabot> (\ c -> fix ((>>) c))
08:11:31 <_s1gma_> @src ($!)
08:11:31 <lambdabot> f $! x = x `seq` f x
08:17:07 <aristid> @let (f .! g) x = f $! g x
08:17:09 <lambdabot>  Defined.
08:20:26 <DevHC> where is clock_gettime defined?
08:21:20 <kmc> POSIX
08:21:35 <kmc> did you want http://hackage.haskell.org/package/clock ?
08:21:36 <aristid> librt in linux
08:28:21 <donri> how do i install or start the gtk interface for yi?
08:43:29 <hatomic> hoogle harr
08:43:50 <shachaf> @arr!
08:43:50 <lambdabot> Aye
08:44:55 <hatomic> @hoogle ho ha hoo
08:44:56 <lambdabot> No results found
08:45:20 <kmc> @. elite nixon
08:45:20 <lambdabot> Thi5 i5 4 9ReAt DaY 4 fRAN(3!
08:45:50 <PhilRod> as a welshman, that hurts a lot
08:47:12 <hatomic> :( http://haskell.org/hoogle/?hoogle=ho+ha+hoo
08:47:33 <lili973> hoogle map
09:06:02 <lili973> exi
09:06:49 <haskellelephant> Does anyone know what is the status of hackage 2.0?
09:08:18 <aristid> @nixon
09:08:19 <lambdabot> I don't want to see this country to go that way.  You know what happened to the Greeks.  Homosexuality destroyed them. Sure, Aristotle was a homo, we all know that, so was Socrates.
09:09:06 <haskellelephant> @nixon
09:09:06 <lambdabot> The press is the enemy.
09:09:16 <aristid> a man of pure wisdom
09:09:23 <haskellelephant> True dat
09:10:14 <byorgey> haskellelephant: the status is that it is once again being actively worked on.
09:11:41 <haskellelephant> I had a look at this: http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0 ,checked out the code and tried it out. I was just wondering if there was any todo list or the like...
09:12:26 <dmwit> haskellelephant: The status is they're looking for people to help and you should get involved!
09:12:36 <dmwit> There's a mailing list, you should get on it.
09:13:07 <dmwit> http://www.haskell.org/pipermail/cabal-devel/2011-October/007803.html
09:13:37 <byorgey> oh, cabal-devel, THAT's where I saw that message
09:13:42 <byorgey> I was looking on -cafe =P
09:13:46 <dmwit> =)
09:16:35 <colah> I've been trying to use the LANGUAGE pragma to enable some type classes, so that I don't have to use this insanely long ghc invocation, but it doesn't seem to work. For example, {-# LANGUAGE XMultiParamTypeClasses #-} . ghc still complains that I need to use -XMultiParamTypeClasses ... I've tried changing spacing in the pragma and using putting it before and after the module declaration. Any thoughts?
09:16:52 <hpc> colah: no X
09:16:57 <colah> Ah.
09:19:38 <colah> hpc: It's working now, thanks.
09:20:02 <colah> Another question: If I write a library using extensions, will people need to use them to use the library?
09:20:21 <colah> (The classes won't be exported)
09:21:00 <hpc> colah: they will need a version of GHC with those extensions, yeah
09:21:03 <shachaf> colah: I assume it depends on the extensions.
09:21:18 <hpc> just about every version has multiparam type classes though
09:21:45 <Saizan> they won't necessarily have to enable the extension in their modules though
09:21:50 <hpc> i personally work off the assumption that GHC 6.12 is as low as anybody will have
09:21:52 <shachaf> I wonder when they decide to abbreviate an extension's name.
09:22:06 <shachaf> -XGADTs, but not -XMPTCs, say.
09:22:25 <luite> is there a non-abbreviatated form of -XGADTs?
09:22:32 <shachaf> I don't think so.
09:22:43 <shachaf> > length "GeneralizedAlgebraicDataTypes"
09:22:44 <lambdabot>   29
09:22:44 <hpc> -XGeneralizedAlgebraicDataTypes?
09:23:02 <shachaf> > length "GeneralizedNewtypeDeriving"
09:23:03 <lambdabot>   26
09:23:17 <Saizan> MPTC wasn't (isn't?) as commonly used as GADT
09:23:28 <shachaf> It's pretty common.
09:23:31 <shachaf> Around here, at least.
09:23:46 <shachaf> I suppose it could be MultiParameterTypeClasses...
09:24:09 <dylukes> MPTC seems like genuinely good extension.
09:24:15 <dylukes> Are there any drawbacks to it?
09:24:29 <shachaf> Saizan: See?
09:24:48 <shachaf> As far as I know dylukes isn't an accomplice.
09:24:56 <dylukes> Accomplice in what?
09:25:29 <shachaf> Some "Multi", not even supporting nullary classes.
09:27:55 <luite> is it possible to specify a different ghc command in the cabal file? like ghc-6.12 or icantbelieveitsnotghc ?
09:28:19 <shachaf> You can specify it when you run cabal with -w.
09:29:27 <luite> shachaf: hmm that would work
09:30:08 <Saizan> shachaf: dylukes wan't here when they decided the name of the extension
09:30:09 <Phlogistique> hi. After running cabal update in Arch Linux I get the following errors when trying to run a program:
09:30:18 <Phlogistique>     Ambiguous module name `Control.Monad.Error':
09:30:18 <Phlogistique>       it was found in multiple packages: mtl-2.0.1.0 monads-fd-0.2.0.0
09:30:27 <Phlogistique> Any idea?
09:30:40 <kmc> nice nick!
09:30:47 <kmc> is your program built using Cabal?
09:31:02 <kmc> the best solution is to build with Cabal, and put one of mtl or monads-fd in your build-depends
09:31:14 <kmc> if you're building with ghc directly you can do something like:  ghc --make -hide-package mtl
09:31:30 <kmc> you can also set this policy 'permanently' using ghc-pkg
09:32:27 <kmc> the packages are not equivalent, though, so you'll have to establish which one is compatible with your code
09:32:48 <kmc> probably mtl, as it's been around longer
09:32:52 <JoeyA> If I have two threads A and B waiting on a socket with threadWaitRead, and input arrives, and A unblocks and consumes the input, is it possible that B might not be unblocked?
09:33:20 <kmc> i assume so
09:33:27 <Phlogistique> kmc: no it isn't
09:33:30 <kmc> but i do not have specific knowledge
09:33:34 <JoeyA> That is, could another thread snatch the input out from under threadWaitRead.
09:34:17 <kmc> why are you using threadWaitRead directly, by the way?
09:34:30 <JoeyA> As opposed to what?
09:34:37 <kmc> normal blocking I/O calls
09:34:50 <kmc> you're waiting for data to be available because you want to read it, right?
09:34:54 <kmc> so just read it
09:35:12 <kmc> or do you actually want a broadcast notify whenever any data comes in
09:35:15 <monochrom> two threads fighting for the same socket is insane to begin with
09:35:15 <JoeyA> Actually, in my case it wouldn't be threadWaitRead blocking.  One thread is an FFI call that does the blocking, and the other is a thread waiting for activity on the socket.
09:35:55 <Phlogistique> kmc: the one-line program  "import Control.Monad.Error" yields the same error
09:36:02 <kmc> yeah
09:36:03 <JoeyA> I don't have much of a choice.  libpq's API for asynchronous notifications requires waiting for activity on a socket, followed by calling PQconsumeInput and PQnotifies.
09:36:35 <kmc> but you're not supposed to read from that socket?
09:36:38 <kmc> just wait for availability?
09:36:47 <Phlogistique> km	the program I was trying to run is one I'm still writing. Why are there too installed packages  defining Control.Monad.Error?
09:36:52 <JoeyA> Correct.  The API function does the reading.
09:37:05 <JoeyA> Note that the database connection object is behind an MVar.
09:37:14 <kmc> Phlogistique, because there are two packages providing slightly different approaches to e.g. error monads
09:37:26 <kmc> for historical reasons, basically
09:37:39 <kmc> anyway i already told you how to fix this
09:37:59 <kmc> JoeyA, so why are these things happening in different threads?
09:38:41 <JoeyA> Because GHC's concurrency primitives don't support waiting for multiple things in one thread.
09:38:54 <kmc> oh, what are the two things you're waiting for?
09:38:57 <JoeyA> e.g. you can't wait on a socket and an MVar at the same time (without forking...)
09:39:17 <monochrom> that still does not imply two threads waiting on the same socket
09:40:01 <JoeyA> If I wanted to make a single thread managing the database connection (including listening for notifications), I would have to listen for two things: 1) activity on the socket, and 2) messages from other threads.
09:40:05 <Phlogistique> kmc: thanks (also, sorry for the poor writing; my connection is unstable and my terminal is lagging like hell)
09:40:35 <monochrom> don't use a terminal then
09:41:26 <JoeyA> I guess I'll just do the listening from a second database connection.
09:42:05 <JoeyA> <complain> I didn't have to do that in C where I did my own select() calls. </complain>
09:42:46 <Saizan> the solution is to fork and make "activity on the socket" just a message from another thread
09:42:47 <kmc> you can still do your own select calls from Haskell
09:43:08 <kmc> it just won't integrate with the GHC IO manager in a nice way
09:43:38 <kmc> i think Saizan's solution should work
09:44:37 <DevHC> monochrom: how would building HSbase/HSrts/etc. with -fPIC solve the issue? i will still most likely get the said error for M.o...
09:44:55 <donri> i've seen bindings (via ffi) use unsafePerformIO, is this common or considered a bad practice?
09:44:56 <JoeyA> But the "activity on the socket" is another thread waiting on the socket.  The problem is the same.
09:45:38 <luite> donri: unsafePerformIO is ok if you make sure that from the user's point of view, your function looks pure
09:45:58 <monochrom> DevHC, I only suggested it as a possibility, it may or may not help.
09:46:18 <luite> donri: it's perfectly ok to use it to allocate some memory, call a C function and then build a result from that, as long as you don't have real side effects
09:46:45 <donri> luite, in particular i'm thinking of the stemming package, which binds the snowball library
09:47:06 <JoeyA> If my main thread does stuff with the database, then we go back to my original question: when my main thread waits for activity from the DB socket (from an FFI call), and threadWaitRead waits on the same socket, is it possible that the FFI call will snatch up the input and keep threadWaitRead from even unblocking?
09:47:18 * hackagebot sednaDBXML 0.1.0 - Sedna Native XML Binding  http://hackage.haskell.org/package/sednaDBXML-0.1.0 (EricJones)
09:47:51 <monochrom> JoeyA, there is always http://hackage.haskell.org/package/epoll if you like the C "everything is a select" way.
09:47:52 <kmc> donri, it's a very *good* practice, for the FFI bindings to deal with ugliness once, rather than exposing C ugliness to every user
09:47:55 <donri> luite, supposedly it only runs some calculations in C, without any "actual" IO
09:48:17 <kmc> unsafePerformIO is part of that
09:48:26 <JoeyA> If the race condition I'm imagining does exist, the only solution I can think of would be to throw an exception to the thread doing threadWaitRead (and have it handle it accordingly).
09:48:49 <JoeyA> (any time another database operation needs to happen)
09:48:56 <kmc> donri, actually, H10 defines a function unsafeLocalState for this purpose
09:49:01 <kmc> http://hackage.haskell.org/packages/archive/haskell2010/1.1.0.0/doc/html/Foreign-Marshal.html#v:unsafeLocalState
09:49:12 <monochrom> in fact, the C "everything is a select, don't use multi-threading" way
09:49:47 <kmc> donri, in GHC it's currently equivalent to unsafePerformIO, but it has weaker guarantees and so might be replaced with something more efficient in the future
09:50:27 <kmc> donri, but it's impossible to say that unsafePerformIO in general is good or bad practice.  it depends on context
09:50:38 <brisingr> is it really that important to make unsafePerformIO efficient?
09:50:50 <luite> donri: note that the unsafe things are not exported in stemmer
09:51:16 <kmc> brisingr, yes, if you're using it for marshaling to C functions which are called in a tight inner loop
09:51:48 <brisingr> I see
09:51:58 <luite> donri: the library makes sure that it only calls withStemmer for things that are pure
09:51:59 <kmc> using highly tuned C routines for speed is a common FFI use case
09:52:10 <kmc> brisingr, GHC's unsafePerformIO involves a global lock
09:52:17 <brisingr> I'm still puzzled, tho. I thought it is extremely bad practice except for debugging purposes or quick hacks
09:52:46 <kmc> brisingr, say I have a C fast fourier transform library
09:52:54 <kmc> the FFT is a pure function
09:53:07 <kmc> but the actual C type is something like Ptr Double -> Ptr Double -> IO ()
09:53:19 <kmc> with an input and output array by pointer, with destructive update to the latter
09:53:36 <kmc> I want to hide this C ugliness from the Haskell user; they should just see Vector Double -> Vector Double
09:53:44 <kmc> so I have to do some allocation and marshaling and copying data in the IO monad
09:53:48 <kmc> but the overall result is a pure function
09:54:13 <kmc> this is actually why unsafePerformIO was added to the language
09:54:19 <kmc> the RWH chapter on FFI has some examples too
09:54:22 <brisingr> so you're saying that the impurity of C forces us to explicitly tell ghc to potentially unsafely interface with it
09:54:47 <hpc> can't you tell the FFI to consider a particular C function to be pure?
09:55:00 <luite> hpc: yes, but that won't work for this function
09:55:00 <kmc> brisingr, I don't really understand your summary of my point
09:55:04 <dolio> The C function isn't pure.
09:55:10 <hpc> ah
09:55:10 <dolio> But FFT is pure.
09:55:10 <ben> hpc: Can you implement unsafePerformIO doing that?
09:55:30 <luite> hpc: since this one isn't, Ptr Double -> Ptr Double -> Int would be a very different type of function
09:55:41 <brisingr> kmc: basically you have something external, impure and not guaranteed but you want to use it in a non-killing-brain-cells way
09:56:02 <kmc> i'm going to steer clear of these moralistic summaries
09:56:03 <brisingr> so you make an exception to "trust" it
09:56:24 <brisingr> by unsafePerformIO. if the external function is to be trusted, this should be no problem
09:56:27 <brisingr> right?
09:57:19 * hackagebot sednaDBXML 0.1.1 - Sedna Native XML Binding  http://hackage.haskell.org/package/sednaDBXML-0.1.1 (EricJones)
09:57:21 <kmc> you use unsafePerformIO to assert that a given IO action will always have the same result and will not have observable effects
09:57:26 <kmc> this assertion is not checked by the compiler
09:57:32 <kmc> it's a proof obligation to you
09:57:51 <kmc> in practice you can also use it in cases where that's not true, and get something like Debug.Trace
09:57:57 <kmc> but that's implementation-dependent behavior
09:58:09 <kmc> do you understand the specific FFI use case I described?
09:58:26 <brisingr> probably
09:58:35 <brisingr> I got it tho; thanks
09:58:38 <roconnor> @quote oasis
09:58:38 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
09:59:50 <monochrom> Debug.Trace's purpose is to reveal implementation-dependent behaviour
09:59:53 <kmc> yes
10:00:19 <kmc> brisingr, I think it's clearly better for an FFI binding to deal with these things once, than to expose some contingent C ugliness to every user
10:00:33 <kmc> I cringe whenever I see a "Haskell" library which is like "you must invoke initFoo from 'main' or your program will segfault"
10:00:55 <brisingr> kmc: true
10:01:00 <JoeyA> Or withSocketsDo...
10:01:07 <kmc> you can read some more of my thoughts about FFI at http://ugcs.net/~keegan/talks/high-level-ffi/talk.pdf
10:01:20 <brisingr> thanks
10:02:01 <dmwit> Asking for an initialization call seems pretty reasonable to me.
10:02:28 <kmc> Haskell libraries which will segfault if you use them wrong are not reasonable
10:02:44 <monochrom> IMO it is reasonable iff you have low standards
10:02:50 <kmc> brisingr, hdis86 has three layers.  they're basically:  unsafe C API,  safe IO API, safe pure API
10:03:09 <kmc> it's 'reasonable' in that I don't think it's morally wrong to split those layers into 3 packages
10:03:25 <kmc> and even to have them written by different people
10:03:36 <brisingr> right
10:03:39 <kmc> but you shouldn't stop at the lowest layer
10:03:59 <dmwit> kmc: So, you consider, e.g., gtk2hs to be a bad binding?
10:04:20 <hpc> dmwit: i think that one is more gtk's fault than the binding author's
10:04:21 <kmc> dmwit, I've not used it much... to what property do you refer?
10:04:31 <hpc> kmc: you need initGUI at the start of your program
10:04:45 <kmc> yes, that sucks
10:04:57 <kmc> maybe the alternatives are worse but it sucks
10:05:21 <dolio> monochrom: Having low standards isn't reasonable.
10:05:39 <dolio> Obviously.
10:05:53 <hpc> dolio: it can be reasonable
10:06:03 <monochrom> hahaha
10:06:06 <hpc> i would expect less from a raw binding to opengl than i would from hpipe or something
10:06:53 <hpc> (ive learned not to ever expect anything from opengl though, so take with salt)
10:12:02 <kmc> right, I'm just saying people should be honest with documentation
10:12:15 <kmc> OpenGLRaw purports to be a 1:1 mapping of OpenGL's C API and that's what it is
10:12:37 <kmc> gtk2hs purports to be a generally usable Haskell library for imperative GUI programming
10:12:49 <JuanDaugherty> the old saw is that documentation is like sex, even when it's bad it's better than nothing
10:12:58 <kmc> that's not true for either
10:13:40 <hpc> gtk isn't even really that imperative
10:13:43 <hpc> it's all signals
10:13:50 <kmc> especially in Haskell where even "nothing" documentation has type sigs
10:13:54 <JuanDaugherty> only in that it doesn't account for rape murder or documentation that purposesly tries to trip you up
10:13:59 <hpc> or, "signals", which are really just function pointers
10:14:09 <jmcarthur> i find that it's difficult to explain what a signal is without imperative terminology
10:14:44 <hpc> kmc: it's amazing how many modules on hackage get away with no documentation just because of type sigs
10:15:38 <aristid> hpc: and reasonably clear functio names
10:16:05 <aristid> lengthF :: Foldable f => f a -> Int
10:16:41 <kmc> yeah
10:17:14 <kmc> in those cases what you want from good docs is some working example programs
10:18:08 <kmc> adding {- | Get the length of a Foldable value -} to that function isn't helping anyone
10:18:17 <hpc> honestly, i think gtk2hs is very "usable", and just needs some more work put into "these are the modules to look at for doing the useful stuff"
10:18:26 <hpc> followed by "this is the other shit"
10:18:39 <aristid> yeah, a tree of modules can be very scary
10:18:41 <kmc> yeah, I agree it is — that one initGUI thing is not a big deal all considered
10:18:49 <aristid> "where do i click now?"
10:18:58 <kmc> but libraries which are full of that stuff are hard to use
10:19:13 <hpc> indeed
10:20:23 <kmc> tree of modules *cough*trifecta*cough*
10:23:59 <kmc> i'm excited for edwardk's trifecta talk
10:24:07 <ben> does gtk2hs do gtk+ 3?
10:24:19 <ben> gtk.org suggests so but i'm a bit vary because of, y'know, the name
10:24:23 <aristid> kmc: edwardk's libs are hard to use, but not for too many initGUIs
10:25:03 <hpc> from what i have seen, edwardk's libs are of the "no docs, no easy types" variety
10:25:06 <copumpkin> kmc: I'm not sure he'll be giving it
10:25:29 <copumpkin> oh, I guess he will
10:25:31 <copumpkin> nevermind :)
10:26:21 <kmc> i hope so
10:27:21 <kmc> 'speculation' and 'data-lens' are pretty obvious
10:27:59 <copumpkin> @hackage reactor
10:27:59 <lambdabot> http://hackage.haskell.org/package/reactor
10:28:14 <copumpkin> I dare you to figure that one out :)
10:28:19 <kmc> also 'tagged' and 'tag-bits'
10:28:26 <kmc> maybe the easiest edwardk library is http://hackage.haskell.org/packages/archive/void/0.5.5/doc/html/Data-Void.html
10:28:54 <kmc> i like that Void is a semigroup
10:29:44 <kmc> heh:  vacuous :: Functor f => f Void -> f a; vacuous = unsafeCoerce
10:30:18 <Rc43> > cast "1" :: Int
10:30:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:30:19 <lambdabot>         against inferred type ...
10:30:26 <Rc43> > cast "1" :: String
10:30:27 <lambdabot>   Couldn't match expected type `GHC.Base.String'
10:30:27 <lambdabot>         against inferred typ...
10:30:35 <aristid> :t cast
10:30:36 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
10:30:43 <Rc43> > cast "1" :: Maybe String
10:30:44 <lambdabot>   Just "1"
10:30:46 <aristid> > cast "1" :: Maybe Int
10:30:47 <lambdabot>   Nothing
10:30:57 <Rc43> Why Nothing?
10:31:03 <byorgey> because "1" is not an Int
10:31:09 <hpc> :t cast
10:31:10 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
10:31:14 <byorgey> cast does not actually change the type.
10:31:17 <hpc> cast only returns a Just if (a ~ b)
10:31:18 <Rc43> So for what we need `cast'?
10:31:18 <byorgey> it only returns Just when  a == b
10:31:36 <Rc43> For type declared as synonims?
10:31:45 <byorgey> Rc43: for when you dynamically don't know what type something is and need to ensure it is a certain type
10:31:47 <Rc43> I mean `type Example = String'.
10:31:58 <byorgey> it is really only needed in various advanced situations.
10:32:06 <Rc43> byorgey, so only for Dynamic using?
10:32:12 <byorgey> right.
10:34:03 <kmc> it's used for things other than Data.Dynamic
10:34:14 <kmc> like SYB's approach to generics
10:34:37 <kmc> Rc43, it's one way to make a polymorphic function less parametric
10:34:46 <kmc> i.e. to make it care more specifically about the type where it's used
10:35:08 <Rc43> kmc, could you give an example?
10:35:39 <kmc> > let f x = case cast x of { Just y -> y; Nothing -> show x } in (f 3, show 3, f "foo", show "foo")
10:35:40 <lambdabot>   ("3","3","foo","\"foo\"")
10:35:55 <kmc> this function 'f' acts like 'show' for every Show type other than String, and acts like 'id' for String
10:37:49 <Rc43> kmc, looks like rare thing
10:38:21 <Rc43> kmc, what if value doesn't derive Show and it is not a String?
10:38:40 <aavogt> you can do the same thing by writing some instances needing -XOverlappingInstances, to make it work on things which are not Typeable
10:39:18 <Kaidelong> Rc43: the use of show on x should put in a constraint for Show on the input type so it'll fail to compile
10:39:45 <hpaste> kmc pasted “Data.Void.vacuous is unsound with TypeFamilies” at http://hpaste.org/52660
10:40:08 <kmc> Rc43, yes, it's rare
10:40:27 <kmc> Rc43, and "derive" is not the right word, you can implement a class by ways other than "deriving"
10:41:13 <kmc> @tell edwardk bug in 'void'? http://hpaste.org/52660
10:41:13 <lambdabot> Consider it noted.
10:41:33 <kmc> i thought you couldn't write instances for unsaturated data families
10:41:36 <kmc>  but I guess that's only for type synonym families
10:42:53 <dolio> I'm sure you can construct that example with type families and newtype, as well.
10:44:52 <kmc> the inspiration was the comment "-- other haskell compilers are free to use less homogeneous representations"
10:47:09 <Rc43> lol, what is purpose of Data.Void?
10:47:31 <copumpkin> to have an emptyish type
10:48:03 <kmc> it's useful to indicate in a function's type that it will never return
10:48:16 <kmc> useful for documentation, and also makes the code nicer in certain cases
10:48:27 <kmc> e.g.:  callCC :: ((a -> Void) -> a) -> a
10:48:55 <Rc43> oh, somehow I have thought that haskell doesnt' need it :)
10:49:01 <Rc43> but I was wrong
10:49:04 <hpc> it doesn't, but it helps
10:49:08 <Rc43> have used such in java
10:49:10 <hpc> :t callCC -- note 'b'
10:49:11 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
10:49:52 <Rc43> (I mean somethin like "class Callback<X> extends Function<X,Void>")
10:50:07 <dolio> It isn't the same as void from Java.
10:50:17 <Rc43> not void, but Void
10:50:29 <Rc43> it is a custom class
10:50:53 <Rc43> (or it is standard, don't remember)
10:51:08 <hpc> i assume Void is a class with no constructor?
10:52:12 <jmcarthur> i wonder how sensible what i'm wanting to do really is. i find myself wanting a stream of things that form an instance of Category such that each successive element in the stream composes with the last, but without restricting each element to be the same type
10:52:50 <jmcarthur> and need to be able to both produce and consume such streams
10:52:55 <ben> is bytestring deprecated in favour of vectors?
10:53:04 <dolio> An infinite stream?
10:53:06 <Rc43> hpc, as i remember, yes
10:53:11 <jmcarthur> dolio: potentially
10:53:17 <jmcarthur> but not necessarily
10:53:22 <dolio> But not necessarily?
10:53:28 <dolio> Heh.
10:53:36 <jmcarthur> i'm using the word stream to mean lazily generated rather than infinite
10:53:56 <copumpkin> jmcarthur: you can easily make such a list/stream with a gadt
10:53:56 <jmcarthur> or even generated by an external source
10:54:01 <copumpkin> or an existential type
10:54:18 <jmcarthur> copumpkin: the problem is i'm really wanting to write a stream processor on these
10:54:24 <jmcarthur> with a parameterized state, i guess
10:54:25 <dolio> data S (~>) a b = Nil | forall c. Cons (a ~> c) (S (~>) c b)
10:54:37 <byorgey> jmcarthur: http://hackage.haskell.org/package/thrist ?
10:54:58 <jmcarthur> byorgey: cool!
10:55:18 * jmcarthur looks at the various folds and such
10:55:18 <copumpkin> jmcarthur: it seems like you can't really know anything about the intermediate states
10:55:18 <byorgey> dunno if that's exactly what you want but at least it should give you some interesting ideas.
10:55:20 <copumpkin> except pass them to the next one
10:55:33 <copumpkin> jmcarthur: unless you maintain more information at each step
10:56:01 <jmcarthur> copumpkin: more specifically, i'm wanting to define a mealy machine that takes these as inputs and gives these as outputs
10:56:50 <copumpkin> but if you forget all your intermediate types, you can't do anything with them except pass them onto the next state
10:57:45 <jmcarthur> but the input and output aren't actually even lazy data structures. they are fed in externally and then given back one at a time (along with the next state)
10:57:52 <jmcarthur> err
10:58:00 <jmcarthur> s/given back/outputs are given/
10:58:02 <byorgey> kmc: ah, nice catch re: vacuous.  Functor f => f Void -> f a  is only valid if f is parametric.
10:58:16 <byorgey> and in the presence of type families that is not guaranteed.
10:58:49 <hpc> byorgey: wouldn't it not be a functor then?
10:58:57 <hpc> since you couldn't fmap absurd
11:00:07 <byorgey> hpc: you *can* fmap absurd
11:00:41 <byorgey> I guess the problem is simply that absurd + type families --> unsoundness.
11:01:44 <byorgey> I need to think about it a bit more to be able to explain exactly what is going on...
11:02:42 <parcs> :t undefined :: Maybe (forall a. a)
11:02:43 <lambdabot>     Illegal polymorphic or qualified type: forall a. a
11:02:43 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
11:02:43 <lambdabot>     In an expression type signature: Maybe (forall a. a)
11:02:56 <parcs> lambdabot: you suck
11:04:03 <byorgey> hpc: aha, the problem is really edwardk's implementation
11:04:21 <byorgey> hpc: he has vacuous = unsafeCoerce for GHC and  'fmap absurd' otherwise
11:04:27 <copumpkin> he added that function at conor mcbride's request
11:04:33 <copumpkin> to avoid traversing the entire sturcture
11:04:39 <byorgey> but 'fmap absurd' would not terminate, whereas unsafeCoerce does terminate and is... well... unsafe.
11:05:09 <byorgey> if you are using the unsafeCoerce version you just have to be careful to only use 'vacuous' on parametric functors.
11:05:30 <copumpkin> oh
11:06:06 <copumpkin> if it's a functor it should be parametric
11:06:12 <copumpkin> why can Functor even be derived for it?
11:06:46 <copumpkin> oh, it can't be
11:06:49 <copumpkin> it's a fake instance
11:06:54 <kmc> absurd + type families should be fine, right?
11:06:56 <byorgey> functors are not required to be parametric
11:06:56 <copumpkin> I don't think there's a problem then
11:07:06 <copumpkin> byorgey: how would you define one that isn't?
11:07:07 <kmc> and yeah, 'fmap absurd' would be fine
11:07:18 <byorgey> copumpkin: oh, in Haskell, you're right, you can't
11:07:27 <copumpkin> the only reason this works
11:07:31 <byorgey> yeah, you're right, the problem is that Foo is not actually a Functor
11:07:33 <copumpkin> is because kmc didn't actually define a valid functor
11:07:55 <byorgey> right, and if vacuous = fmap absurd it would crash with an error about fmap not being defined
11:08:22 <kmc> yeah
11:08:23 <copumpkin> I still don't see that as a bug in void
11:08:40 <kmc> it's a bug in the practical sense that a user doing fairly reasonable things can accidentally write unsafeCoerce
11:08:44 <hpc> copumpkin: it violates the type of vacuous
11:09:05 <hpc> if you can use it on something that isn't really a functor
11:09:09 <copumpkin> he could've easily written instance Functor Foo where fmap = unsafeCoerce
11:09:16 <copumpkin> hpc: no, the type signature is still there
11:09:17 <kmc> no, because I didn't import System.Unsafe
11:09:21 <kmc> i'm not claiming it's a bug in the predicate calculus ;P
11:09:49 <byorgey> I don't see it as a bug in any sense, not even practical.
11:09:54 <copumpkin> vacuous expects you to be a functor
11:10:02 <copumpkin> if you lie about being a functor, then you get unexpected behavior
11:10:06 <byorgey> exactly.
11:10:24 <copumpkin> of course, it's the unexpected sort that you wouldn't normally get with that kind of lie
11:10:31 <copumpkin> :)
11:10:53 <kmc> Haskell functions will not typically allow you to implement unsafeCoerce if you break unchecked typeclass laws
11:11:23 <kmc> if your function behaves this way, it should be documented loud and clear
11:11:28 <byorgey> 'not implementing a type class method' is not the same as 'breaking unchecked class laws'
11:11:42 <kmc> fine i'll implement fmap _ _ = undefined
11:11:53 <byorgey> well, good point
11:12:18 <byorgey> of course I would never argue against better documentation.
11:12:20 <copumpkin> I don't see how you could avoid it though
11:12:24 <copumpkin> in code
11:12:53 * kirindave grumbles.
11:12:56 <copumpkin> maybe we should make it pointed ;)
11:13:13 <kmc> copumpkin, you avoid it by removing that GHC-specific optimization hack
11:13:14 <kirindave> Just had a dude argue to me that checked exceptions are great and Either is destined to be error handling soup.
11:13:20 <kmc> vacuous = fmap absurd
11:13:22 <kmc> that's fine
11:13:27 <copumpkin> vacuous :: Pointed f => f Void -> f a; vacuous f = fmap undefined (pure undefined) `seq` unsafeCoerce f
11:13:30 <kirindave> Therefore Java is better at writing fault tolerant software. :(
11:13:38 <copumpkin> kmc: the whole point of that function was to avoid it
11:13:51 <hpc> lol
11:14:04 <kmc> if we're going to make a big deal about Haskell's type system providing safety guarantees
11:14:07 <kmc> and even security guarantees
11:14:11 <kmc> then this is not acceptable
11:14:31 <copumpkin> let's just kill the function then
11:14:35 <copumpkin> you can write fmap absurd yourself
11:14:36 <kmc> fine by me
11:14:47 <copumpkin> unsafeVacuous
11:14:52 <kmc> i don't mean to get on your or edwardk's or anyone's case about this
11:17:14 <kmc> we expect Haskell's type system to prevent C-style memory-corruption bugs (which can have dire security consequences)
11:17:35 <kmc> even if you're doing something silly and wrong (like a beginner cluelessly playing around with TypeFamilies, and not knowing what the hell a 'parametric functor' is)
11:17:45 <kmc> you still don't expect to write unsafeCoerceAndRootMyBox
11:18:01 <jmcarthur> it is at least conventional for type classes to have certain requirements where the burden of proof is on the programmer, though
11:18:12 <jmcarthur> i see your point though
11:18:17 <copumpkin> he's saying that the penalty for violating those rules is usually less dire
11:18:22 <jmcarthur> indeed
11:18:22 <kmc> yes
11:18:44 <kmc> f x y z | (x < y) && (y < x) = unsafeCoerce z
11:19:05 <jmcarthur> whereas normally violating the rules simply results in difficult-to-reason-about code and some other invariants violated elsewhere, this case actually violates the type system itself
11:19:15 <copumpkin> oh wait
11:19:24 <jmcarthur> or makes it unsound, that is
11:19:36 <wavewave> kirindave: doesn't checked exception have error handling soup anyway?
11:19:44 <copumpkin> vacuous :: Functor f => f Void -> f a; vacuous xs = fmap undefined xs `seq` unsafeCoerce xs
11:19:45 <copumpkin> how's that? :P
11:19:49 <jmcarthur> oh god
11:19:52 <kmc> heh
11:20:19 <copumpkin> you could still write a bad fmap instance
11:20:22 <kmc> i worry about functors where (fmap undefined x) can be reduced to whnf
11:20:24 <kmc> yeah
11:20:26 <copumpkin> but it'd be a little safer
11:20:28 <kmc> most of them?
11:20:47 <kmc> anyway SafeHaskell is supposed to make these issues a bit clearer
11:20:53 <copumpkin> > fmap undefined [1..5] `seq` 5
11:20:54 <lambdabot>   5
11:21:00 <copumpkin> > fmap undefined (Just 7) `seq` 5
11:21:00 <lambdabot>   5
11:21:06 <kmc> as written it'd be clearly wrong to compile Data.Void with -XTrustworthy
11:21:09 <kmc> can we agree on that?
11:21:12 <copumpkin> yep
11:21:29 <copumpkin> next up
11:21:41 <copumpkin> instance Functor [] where fmap f xs = undefined : undefined
11:21:50 <copumpkin> :P
11:22:07 <wavewave> yeah. safeHaskelll is a great addition.
11:22:31 <kmc> and I think if you have a module which can't be compiled with -XTrustworthy, you should a) at minimum document how it can be used to break the type system, b) following common practice, name such things unsafeFoo or move them into a separate Foo.Unsafe module
11:22:52 <kmc> so that's why it's a "bug"
11:23:21 <copumpkin> fair enough
11:23:27 <DevHC_> is there a widely accepted meaning for the _ version of an (f :: IO a) function, ie., f_ ?
11:23:37 <kmc> again not trying to get on anyone's case, just my 2¢ towards maintaining the community consensus on safety etc
11:23:52 <kirindave> wavewave, it's basically identical
11:23:58 <wavewave> DevHC_ : ignore result.
11:24:11 <kirindave> wavewave, I couldn't figure out why he thought there were different.
11:24:14 <DevHC_> anything else?
11:24:19 <wavewave> kirindave: yes. so I do not get his point.
11:24:23 <scooty-puff_> is there a way to have closed type families?
11:24:49 <scooty-puff_> i imagine don't export the type family definition - but is there a way to do it such that the compiler can use it?
11:24:55 <DevHC_> no? ok
11:25:09 <wavewave> DevHC_ : I don't know any other cases.
11:25:09 <DevHC_> we must revolt against the misnamed newForeignPtr_ !
11:25:25 <scooty-puff_> how do you interact with lambdabot?
11:25:29 <scooty-puff_> >:t newForeignPtr_
11:25:50 <DevHC_> @google newForeignPtr_
11:25:51 <lambdabot> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Foreign-ForeignPtr.html
11:25:52 <lambdabot> Title: Foreign.ForeignPtr
11:25:54 <DevHC_> @hoogle newForeignPtr_
11:25:54 <lambdabot> Foreign.ForeignPtr newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
11:26:52 <wavewave> @google newForeignPtr
11:26:53 <lambdabot> http://www.haskell.org/pipermail/ffi/2003-February/001062.html
11:26:53 <lambdabot> Title: newForeignPtr
11:28:32 <wavewave> where is newForeignPtr defined? (without _)
11:29:39 <wavewave> ahh I got it.
11:29:53 <wavewave> :t newForeignPtr
11:29:53 <lambdabot> Not in scope: `newForeignPtr'
11:30:20 <copumpkin> scooty-puff_: no
11:30:25 <wavewave> newForeignPtr :: FinalizePtr a -> Ptr a -> IO (ForeignPtr a)
11:30:39 <wavewave> newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
11:31:08 <wavewave> so newForeignPtr_ ignores FinalizePtr a
11:32:01 <wavewave> finalizer will be executed after last reference of the pointer dropped.
11:32:33 <scooty-puff_> copumpkin, thanks - i currently have a GADT with data constructor ALOAD :: Index a -> Insn a, where Index a :: * is a type family - Insn Narrow would have defined Index Narrow, Insn should only have a ~ Narrow or Wide
11:32:35 <mm_freak> apropos finalizers…  is there a way to attach a finalizer to a pure value, i.e. not a ForeignPtr?
11:32:54 <scooty-puff_> is there a way to restrict the type parameter - perhaps encoding it in some other form
11:32:56 <wavewave> DevHC_ : so if we extend meaning _ to something ignored, then _ suffix still make sense.
11:33:14 <scooty-puff_> are class constratins on type parameters in data type definitions bad style?
11:33:41 <mm_freak> scooty-puff_: you would do that in instances and/or functions
11:33:57 <mm_freak> you /can/ also do it as a class constraint, but only if it makes sense
11:34:07 <mm_freak> in its generality that is
11:34:20 <mm_freak> for example class Functor f => Monad f would have made sense =)
11:34:36 <scooty-puff_> mostly its to enforce the existance of a type family instance as early as possible
11:34:54 <scooty-puff_> or maybe to make it more descriptive
11:37:00 <wavewave> scooty-puff_ : you can use constraint in the definition of data constructor.
11:37:13 <wavewave> scooty-puff_ : I don't think it is particularly bad style.
11:37:37 <wavewave> data A a = (C a ) => A a
11:38:38 <scooty-puff_> how do you have A a b | a -> b, b -> a using type families?
11:38:49 <c_wraith> wavewave: ghc 7.2 flags that as an error
11:38:50 <scooty-puff_> so say A a where type B a
11:38:50 <wavewave> scooty-puff_ : but data (C a) => A a =  A  a is depreciated.
11:39:02 <scooty-puff_> undecidable instance, right?
11:39:07 <c_wraith> wavewave: mostly because it doesn't *do* anything
11:39:21 <c_wraith> wavewave: at least, not anything useful.
11:39:40 <scooty-puff_> sometimes i use empty type classes and don't export the type class to enforce arbitrary constraints
11:41:37 <wavewave> c_wraith : ? I now tested the code with ghc 7.2. It needs ExistentialQuantification but it compiled.
11:41:55 <byorgey> c_wraith: no, wavewave is right.  constraints on data constructors are OK.  It's constraints on data type declarations themselves that is no longer allowed.
11:42:02 <scooty-puff_> for some reason "bijective" doesn't come readily to mind..
11:42:15 <scooty-puff_> (about tfs and fds)
11:42:15 <c_wraith> wavewave: if it required ExistentialQuantification, doesn't that mean you need a forall?
11:42:51 <byorgey> no
11:43:04 <dolio> scooty-puff: class (T1 a ~ b, T2 b ~ a) => A a b where T1 a :: * ; T2 b :: *
11:43:05 <byorgey> it's kind of strange that it needs ExistentialQuantification, actually, but it does
11:43:23 <c_wraith> Is it treated as an existential, then?
11:44:08 <hpaste> wavewave pasted “Datatype Contexts” at http://hpaste.org/52665
11:45:01 <c_wraith> Huh, no, it's not, since a is in the type.
11:45:04 <c_wraith> strange
11:45:17 <wavewave> c_wraith: it's quite awkward. but anyway.
11:45:28 <Rc43> Why we need type families? It seems that we can use type classes for same purposes. But it can be a little dirty.
11:45:47 <wavewave> Rc43: because you need a type-level function in some cases.
11:46:36 <wavewave> Rc43: Type classes itself cannot guarantee the uniqueness of a result of type-function
11:47:05 <wavewave> Rc43: either you need Functional Dependency with multiparam type classes or type family.
11:47:15 <Rc43> wavewave, what you are meanin by uniqueness of a result?
11:48:02 <wavewave> Rc43: suppose you have a stream type.  if you designate a stream type then your element type is deteremined.
11:48:55 <wavewave> Rc43: so you would like to have a type-level function ; type Element (StreamType) = ElementType
11:49:13 <scooty-puff_> "Alas, GHC 7.0 still cannot handle equality superclasses" - am i doing something wrong?
11:49:18 <scooty-puff_> will have hpaste in a sec
11:49:38 <wavewave> Rc43: you can define it using multiparam type class like class IsElementOf  element stream
11:49:38 <Rc43> wavewave, somewhy it's hard to understand =/
11:49:39 <mm_freak> does anyone have implemented monadic automaton-based FRP?  I've been working hard, but just can't turn my FRP arrow into a monad in a generally useful sense
11:50:08 <wavewave> Rc43: Okay.. probably. using example is not a good way..
11:50:22 <mm_freak> i managed to write an ArrowApply instance, but it really turns out to be a totally useless monad
11:50:49 <Rc43> wavewave, it is may be difficult because of my pure english and lack of haskell knowledge
11:50:54 <wavewave> Rc43: just imagine a case that you need to relate a type with another type in a unique way.
11:51:20 <jmcarthur> mm_freak: the only way to do it that i know of is to collect inputs for bind to feed into the result
11:51:38 <wavewave> Rc43: A is related to B...    so if I am considering A, then I am also considering B.
11:51:52 <jmcarthur> mm_freak: which makes it useful, but not very space efficient, of course
11:51:52 <wavewave> Rc43: this situation often happens.
11:52:13 <Rc43> wavewave, e.g. the one type need to know only length of list so we dont need to know elements of list?
11:52:38 <wavewave> Rc43: for that case, we don't need type function.
11:52:39 <Rc43> But how type families can help with it?
11:52:53 <Rc43> What is type function?
11:52:59 <wavewave> Rc43: so in many elementary cases, we don't need a type function.
11:53:41 <Rc43> You mean that we can give to this type only Int (length) without giving the list?
11:53:50 <jmcarthur> mm_freak: and if you are talking about the way that ArrowMonad forces the input type to be (), i think it is not as general as it could be
11:54:11 <jmcarthur> mm_freak: duplicating the input allows you to keep that parameter polymorphic
11:54:32 <Rc43> So we can build example, where one type uses other type but in such way that it needs only one substructure of latter. (difficult sentence =/)
11:54:33 <mm_freak> jmcarthur: the problem is:  the ArrowApply instance is not terribly useful either
11:54:46 <mm_freak> jmcarthur: i ended up writing three app-style combinators outside of ArrowApply
11:54:59 <jmcarthur> mm_freak: what semantics does you ArrowApply instance have?
11:55:01 <jmcarthur> *your
11:55:35 <aristid> @hackage transformers-compose
11:55:36 <wavewave> Rc43: hmm.. I am not sure whether I am following what you think in your mind now..
11:55:36 <wavewave> Rc43: anyway, length is not a good example of type function in fact.
11:55:36 <lambdabot> http://hackage.haskell.org/package/transformers-compose
11:55:40 <aristid> shameless plug.
11:56:01 <wavewave> Rc43: in fact, it's opposite. length is a good example of generic parametrized type.
11:56:23 <wavewave> Rc43: type function is more like specialization.
11:56:51 <wavewave> Rc43: I would like to recommend a paper.. wait a minute.
11:57:04 <Rc43> it would be good
11:57:16 <parcs> scooty-puff_: no you are not
11:57:17 <Rc43> (but i haven't finish the haskellwiki one)
11:58:22 <ben> help, vim is highlighting lines in red if they start with # in .hs files, what is going on
11:58:33 <wavewave> http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
11:59:01 <mm_freak> jmcarthur: i found that it's most useful, if 'app' always uses its left signal
11:59:20 <mm_freak> jmcarthur: so it uses a frozen variant of its left signal as the signal function, but doesn't allow it to evolve
11:59:35 <wavewave> Rc43: there, you can find a talk by Simon Peyton Jones. I think example there may be easier for you to understand.
11:59:51 <Quantumplation> Introducing a friend to haskell.  What would you say is the most beautiful example code showing off haskell's strengths?  I explained the basics of the type system (curried functions, algabraic data types, etc)
12:00:06 <jmcarthur> mm_freak: what do you mean by "left signal"?
12:00:12 <DasIch> ben: it's probably a syntax error
12:00:27 <ben> ghc is siding with me, though :/
12:00:52 <aristid> ben: use -- instead of # for comments
12:00:56 <ben> http://projects.haskell.org/diagrams/tutorial/DiagramsTutorial.html#attributes or rather with this code sample
12:00:59 <DasIch> ben: in that case vim thinks there is a syntax error
12:01:09 <DasIch> ben: or some other kind of error
12:01:15 <hpc> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs -- Quantumplation
12:01:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:01:25 <hpc> try doing that in any other language! :P
12:01:41 <mm_freak> jmcarthur: app :: ArrowApply a => a (a b c, b) c  -- the left signal is the 'a b c'
12:01:45 <jmcarthur> okay
12:01:58 <mm_freak> jmcarthur: in my case:  app :: Wire m a (Wire m a b, a) b
12:02:20 <wavewave> Quantumplation: quick sort is a classic example (I guess you already showed it to your friend )
12:02:20 <jmcarthur> so you just take the first input, hold on to the signal, then feed all the future 'b' values into that as time progresses?
12:02:22 <Rc43> wavewave, thanks
12:02:27 <hpc> mm_freak: Wire m (Wire m a b, a) b
12:02:32 <hpc> not Wire m a ...
12:02:35 <aristid> > fix $ (0:) . (1:) . ap (zipWith(+)) tail
12:02:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:02:48 <aristid> it never gets old
12:02:50 <mm_freak> jmcarthur: no, that was my first version, but it turned out not to be very useful
12:02:55 <jmcarthur> i agree
12:03:04 <wavewave> Quantumplation: I think that haskell is beautiful in expressiong algorithm. take examples from there..
12:03:14 <mm_freak> hpc: oh yes, sorry
12:03:54 <parcs_> ben: try adding `let hs_allow_hash_operator=1` to your vimrc
12:04:16 <wavewave> after writing down haskell code. it's just nothing but writing definitions in many cases.
12:04:34 <ben> parcs_: Oh, dear, that fixed it. Thank you.
12:04:46 <wavewave> Quantumplation: how about showing some sudoku solvers or something like that?
12:04:51 <jmcarthur> mm_freak: i think the most useful one would be such that it accumulates *all* of the 'b' values and, for each new signal, feeds them all into it to get the final result. sadly, this is going to take a lot of space in general
12:05:21 <jmcarthur> and also gradually slow down
12:05:37 <jmcarthur> obviously limiting its usefulness
12:06:00 <Quantumplation> wavewave: that fibs algorithm... i don't understand quite how it works
12:06:54 <mm_freak> jmcarthur: and personally i don't think it's very useful that way…  there are special combinators for that in my library, which give you more control over the created wire instances
12:06:55 <jmcarthur> i suspect, however, that there are exist useful cases where the time and space problems don't come up, and that where problems do arise there is probably an alternative way to express what you want
12:07:46 <jmcarthur> mm_freak: you mean where you are using an accumulation function of some sort?
12:07:47 <wavewave> Quantumplation: I did not show the fib algorithm (aristid did). but it's memoization example.
12:08:42 <mm_freak> jmcarthur: there are different ways to do it…  one useful wire transformer i have is the 'context' wire, which basically creates an own session for each possible input
12:08:51 <wavewave> Quantumplation: I am sure that it can be regarded as particularly beautiful though.
12:09:05 <wavewave> s/sure/not sure/
12:09:35 <jmcarthur> mm_freak: by that you mean you kind of run the sessions in parallel?
12:10:02 <mm_freak> jmcarthur: no, only one session is active at a time…  which one depends on the input signal…  it's kind of a more convenient way to perform parallel switching
12:10:08 <mm_freak> jmcarthur: i'm working on concurrent wires right now
12:10:12 <jmcarthur> oh i see
12:10:26 <wavewave> concise code does not always mean beautiful code in my opinion. but denotational semantics is beautiful in my opinion.
12:10:28 <scooty-puff_> why does MonadError e Either require Error e?
12:10:33 <jmcarthur> wavewave: :D
12:12:48 <wavewave> jmcarthur: :D
12:14:39 <wavewave> but ability to make concise code indicates that we can achieve more abstraction in haskell than in other languages.
12:14:44 <kmc> mm_freak, did your finalizers question get answered?
12:15:15 <wavewave> golfing often gives rise to discovery some abstract pattern.
12:15:27 <kmc> you can do it with http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/System-Mem-Weak.html afaik
12:15:50 <kmc> golfing teaches you to recognize patterns
12:15:57 <kmc> then you can apply those patterns in your own code, selectively
12:16:02 <hpc> scooty-puff_: afaik, just for the definition of 'fail'
12:16:37 <hpc> oh, MonadError
12:16:55 <wavewave> from my personal experience, showing haskell golf code doesn't get people's attraction. oppositely, it scares people away. remind them of perl.
12:17:08 <hpc> scooty-puff_: yeah, for the definition of throwError
12:18:17 <wavewave> but for haskell intermediate, showing golfing code or trying golf is very helpful, I think.
12:20:45 <kmc> yeah... for enticing people, there are enough examples where the code is short, expressive *and* clear, beautiful
12:21:00 <mm_freak> kmc: not yet
12:21:23 <kmc> well System.Mem.Weak might do what you want, but I've never used it
12:22:25 <mm_freak> kmc: i'm not sure it does…  i'd like to kill a thread, when a value of a certain type is garbage-collected
12:22:41 <mm_freak> kmc: at least if it has been created with a certain function
12:23:28 <Veinor> i heard someone was working on having actual stack traces in ghc
12:23:59 <wavewave> Simon Marlow said he figured out how to do that recently in google+
12:24:36 <monochrom> it may still take a while to appear in GHC stable releases
12:24:45 <wavewave> definitely.
12:24:52 <wavewave> so I have a question about that.
12:24:58 <Veinor> monochrom: oh, sure
12:25:06 <Veinor> maybe 7.4, 7.6
12:25:57 <wavewave> if we have the stack trace, then our heap profiler will also show where is the space cost happened exactly, right?
12:26:59 <monochrom> the profiler has an idea of "call stack" traditionally. just not a very precise one
12:27:11 <wavewave> currently, using +RTS options like -hr -hd -hy does not pinpoint where the problem is well enough.
12:27:29 <monochrom> this is why +RTS -xc already shows you something close to a call stack trace
12:27:46 <wavewave> xc... I didn't know about it.
12:28:17 * wavewave is looking for xc option in ghc manual.
12:28:50 <monochrom> yeah, try to write code to throw exceptions, turn on profiling, run with -xc, it will show you useful information about the exception
12:29:12 <monochrom> more information if you -O less
12:29:37 <wavewave> monochrom: I see, I haven't thought about doing profiling using exceptions.
12:31:36 <mm_freak> kmc: weak pointers indeed solve my problem…  thanks a lot
12:32:12 <kmc> :)
12:32:45 <wavewave> anyway, if we know which functions called the current function at a given point, then if we partition our space usage profiling using search call tree, then we can have very precise pinpointing for space leak. that's my guess.
12:34:37 <wavewave> currently, I need lots of SCC pragma for doing that... very painful.
12:35:31 <b_jonas> how come Standard ML doesn't have a spec freely available from the web whereas Haskell does? aren't they of about the same age?
12:35:37 <monochrom> oh, -xc is meant to help you debug exceptions, rather than use exceptions to help explain space :)
12:36:07 <b_jonas> is that OT here?
12:36:08 <wavewave> monochrom: yes. I understand it now. ;-)
12:36:17 <kmc> and SML has a formal semantics, too!
12:37:08 <monochrom> I don't know why, but the SML people decided to put out a printed book. the slippery slope then goes: find a publisher; give up copyright; can't distribute it any other way.
12:37:11 <kmc> what does the M in 'MVar' stand for?  'Mutable'? 'Maybe'?
12:37:23 <b_jonas> I mean, with C and C++ you at least have the final draft of the latest standard freely downloadable, and the final draft is almost the same as the actual standard.
12:37:28 <kmc> publishers require you to assign copyright??
12:37:49 <monochrom> my friend shelled out money to buy the book! I could borrow it from him if you want me to look up something. please allow 7 days... :)
12:37:58 <b_jonas> Obviously if it was also freely downloadable, I would't mind a printed book. I do like dead-tree.
12:37:59 <companion_cube> it's strange, i thought SML had a standard to allow people to look at it
12:38:06 <rotflcopter> MaybeVar
12:38:09 <rotflcopter> :)
12:38:12 <monochrom> publishers usually want to confiscate your copyright
12:38:26 <b_jonas> companion_cube: yep, it's strange how they even put "Standard" in their name
12:38:36 <rotflcopter> or MagicVar
12:38:40 <kmc> that's insane
12:38:46 <monochrom> so for example Algebra of Programming copyright is still in the hands of Prentice Hall
12:38:56 <b_jonas> I mean, if it was a decade older than Haskell, I could understand. Freely downloadable stuff wasn't in fashion back then.
12:39:32 <kmc> isn't a publisher just providing services such as printing, distribution, marketing?  can't these all be provided to the original copyright holder on a fee basis?
12:39:34 <Saizan> http://r6.ca/blog/20110930T012533Z.html <- on ACM confiscating copyright
12:39:48 <Clint> you can negotiate copyright and licenses, or you can choose to be screwed as much as they want to screw you
12:39:55 <kmc> and finally, doesn't the Internet make it easy to buy these services a la carte, rendering the old ways irrelevant?
12:39:55 <monochrom> after decades, sometimes a publisher is willing to return copyright to the author, if the author asks nicely, and if the publisher itself no longer print the book anyway (therefore the publisher doesn't feel that it hurts)
12:39:57 <mm_freak> kmc: MVar for MailVar would make sense
12:40:24 <monochrom> yes, kmc, you are right. but the Internet is fairly recent, in the grand scheme of things
12:40:58 <wavewave> probably MutualVar
12:41:07 <Clint> what you're saying is that the author needs a better lawyer
12:41:21 <Spockz> how much work would it be to put up hackage mirrors?
12:41:28 <mm_freak> wavewave: "mutual" is not very descriptive, though
12:41:35 <kmc> also having a 'real publisher' rather than self-publishing is seen as a mark of legitimacy, even if it shouldn't be
12:41:45 <kmc> so does O'Reilly have the copyright to RWH, and choses to allow online distribution out of the goodness of their hearts?  or they have copyright under a deal with the authors which obliges them to do so?
12:41:50 <kmc> or the authors keep copyright?
12:42:20 <donri> cute, my ghc install supports 142 language extensions
12:42:27 <wavewave> mm_freak: probably, but 'mutual' has some context in lock. semaphore stuff.
12:42:31 <copumpkin> kmc: mutable, I think
12:42:49 <copumpkin> kmc: http://snapplr.com/jbmp is the only etymology I can find :P
12:42:59 <Eduard_Munteanu> kmc: if only they provided some form of peer review
12:43:05 <mm_freak> wavewave: i wouldn't sell MVar for locking…  it makes people abuse it =)
12:43:06 <jmcarthur> mm_freak: so you mean the value carries the thread id or something?
12:43:10 * Eduard_Munteanu isn't sure how ACM stands on that
12:43:16 <monochrom> my thesis supervisor's book was first published before the Internet caught on. (just slimly before.) then, after a decade (and so the Internet has caught on), he wanted to put out a 2nd edition. He and the publisher disagreed on what should go into the 2nd edition, writing style, etc. Eventually, he and the publisher parted ways peacefully: the publisher returned the copyright to him, he put his 2nd edition on the web.
12:43:17 <jmcarthur> mm_freak: oh, your problem was solved, nevermind
12:43:29 <rotflcopter> can haskell do FPGA ?
12:43:31 <wavewave> mutual exclusion variable ?
12:43:38 <kmc> yeah i just found that copumpkin
12:43:46 <mm_freak> jmcarthur: yes, and in this case a with* style manager does not make sense and explicit killing would be very inconvenient
12:43:54 <kmc> donri, half of them are 'NoFoo' aren't they?
12:43:55 <jmcarthur> right
12:44:07 <jmcarthur> yeah a finalizer sounds right for this
12:44:12 <donri> kmc, ah
12:44:25 <kmc> rotflcopter, there's lots of work on hardware design in Haskell, and at least one company whose commercial product uses it (BlueSpec)
12:44:26 <wavewave> MutexVariable
12:44:33 <donri> 72 with grep -v ^No
12:44:55 <jmcarthur> although killing a thread only when something is garbage collected implies that a lot of work could be wasted running a thread that isn't needed anymore
12:45:26 <monochrom> but yes generally Knuth is infuriated that traditional journal publishers provide little added-value and charges an arm and a leg. (recall that the most important value, refereeing, is volunteer work.)
12:45:33 <wavewave> what about IVar?
12:45:36 <mm_freak> jmcarthur: that's an edge case, in which you can still kill the thread explicitly
12:45:47 <wavewave> iVar.
12:45:58 <rotflcopter> kmc<< but ghc not willing to compile logic function that can be run on FPGA yet ?
12:45:59 <wavewave> apple trademark.
12:46:02 <monochrom> in fact, charges an arm and a leg and confiscates copyrights
12:46:21 <mm_freak> iWar
12:46:21 <kmc> rotflcopter, not in mainline GHC.  if i understand your rather vague questions
12:47:08 <Clint> kmc: looks like the RWH authors retained copyright
12:47:15 <wavewave> rotflcopter: check Lava project
12:47:36 <monochrom> anyway, pretty sure many of the SML people resent the original decision to go with a traditional publisher, too
12:47:52 <kmc> you can google "Haskell hardware design" and find lots of links
12:48:23 <kmc> submitted "Why learn Haskell?" slides to /r/programming
12:48:27 <kmc> we'll see how this goes
12:48:32 <monochrom> otoh if you read the SML definition, you may resent reading it, too :)
12:48:52 <wavewave> it seems like haskell has most well-continuously-updating compiler these days among languages.
12:49:02 <b_jonas> monochrom: yep. let me tell a related tale.
12:49:47 <wavewave> is it my illusion or actually true?
12:49:54 <rotflcopter> thanks wil dig into that
12:50:00 <kmc> wavewave, GCC updates pretty often
12:50:03 * monochrom puts on a simulated Knuth voice and says "beware: we have only written an operational semantics, we haven't found a denotational semantics that is a full abstraction of it"
12:50:08 <kmc> i think C# and MS's other stuff do, too
12:50:29 <b_jonas> I'm working on a program that helps format bibliographical references in a scholar journal. One part of this is finding an entry to the referred article in a proprietary bibliographical database.
12:50:48 <kmc> Java is dead, but some other JVM language implementations like Scala, Clojure, Rhino see active development
12:51:02 <donri> are monad comprehensions new in 7.2 or somesuch? i don't have them in 7.0.4
12:51:02 <wavewave> how about python? it looks slowed down after python 2 and 3 divide to me.
12:51:13 <wavewave> donri: it's from 7.2
12:51:16 <kmc> PyPy is an active project
12:51:26 <kmc> are you looking only at language (incl. extension) changes, or also at implementation?
12:51:38 <kmc> i think people are starting to recognize that CPython is a dead end
12:51:46 <b_jonas> As I see, what this proprietary database does seems completely disadvantageous to the journal.  They charge a lot of money to allow the journal to enter their articles in this database, and require them to add links to their entry of any other reference.
12:52:08 <donri> cpython has moved on to python3
12:52:15 <dolio> wavewave: They're new in Haskell 1.2 or so. :)
12:52:20 <dolio> Er, donri.
12:52:21 <donri> which is largely a failure
12:52:29 <wavewave> kmc: I didn't have any specific thing in mind. just curious
12:52:36 <b_jonas> There doesn't seem anything the journal gains from it, given that their search interface is mostly broken, and you can almost always find articles easier in other ways than by using this database.
12:52:58 <donri> dolio, wha--, isn't 1.2 some really old haskell?
12:53:03 <dolio> Yeah.
12:53:10 <donri> or did you think i was talking about list comprehensions
12:53:13 <dolio> Monad comprehensions got removed in Haskell 98.
12:53:18 <donri> oh
12:53:25 <dolio> And now they're re-added to GHC.
12:53:41 <monochrom> those publishers etc are living on reputation alone. it is their quasi-stable state but it's fragile.
12:53:47 <wavewave> kmc: aha. CPython is now a dead-end.. I didn't know that.
12:53:50 <mm_freak> i never understood why they removed them anyway
12:54:07 <dolio> Lots of stuff got de-generalized in H98.
12:54:10 <JoeyA> "Types catch mistakes but stay out of your way otherwise"  The way I see it, types are a key documentation tool.  Haskell code is often not very readable, but Haskell types are very readable.
12:54:14 <donri> i like the idea of comprehensions as less tightly list-specific
12:54:16 <b_jonas> Well sure, GHC should house a lot of language extensions that are still experimental so we can decide which ones are actually worth to enter into the standard and in what exact ways.
12:54:32 <wavewave> JoeyA: yes, that's true..
12:54:35 <donri> you could either do without them completely, or have them be generic
12:54:40 <monochrom> basically "I tolerate your broken system just because current your database has the best reputation"
12:55:40 <bjrn> kmc: Nice slides, thanks.
12:55:41 <wavewave> haskell is continuously growing experiment lab of programming language.
12:57:27 <erus`> its like C++, they keep shoveling features ontop
12:57:38 * wavewave wonders if we will have LANGUAGE pragma like LanguageC, LanguagePython.. 
12:58:09 <JoeyA> At least in Haskell, polymorphism wasn't an afterthought.
12:58:25 <portnov1> hi all
12:58:28 <JoeyA> hi
12:58:35 <shirt> hey
12:58:35 <wavewave> hi
12:59:02 <erus`> how long until strong AI? I want decent NPCs in my computer RPGs
12:59:03 <portnov1> Q: is there any way to compile 32bit executable on 64bit machine using ghc? :/
12:59:32 <b_jonas> monochrom: but it's not "tolerate", the journal is actually paying them money for the "privilate" to enter to their database and to allow automatic search queries to their database (with a very broken search interface that I have to work around in thousand ways)
12:59:49 <b_jonas> oaky, maybe the part about working their search engine around is "tolerate"
12:59:54 <kmc> portnov1, install 32-bit ghc in a prefix
13:00:05 <monochrom> well, tolerate paying money :)
13:00:22 <JoeyA> Naming question: I have three functions for parsing a SQL result.  One returns a Vector of rows.  Another returns exactly one record (throwing an exception if the result set did not have exactly one row), and a Maybe version of the latter, returning Nothing if the SQL result had no rows.
13:00:27 <rotflcopter> portnov1<< you can probably do anything with chroot
13:00:43 <kmc> wavewave, it's a dead end because it will need a complete overhaul to support non-shitty threads
13:00:45 <JoeyA> Currently, I'm calling the first two readResult :: ReadResult record -> Result -> IO (Vector record) and readResult1 :: ReadResult record -> Result -> IO record
13:01:01 <JoeyA> What's a good name for ReadResult record -> Result -> IO (Maybe record) ?
13:01:19 <wavewave> kmc: oh.. that's sad.
13:01:20 <JoeyA> (which ensures that the Result set has exactly zero or one rows)
13:02:10 <kmc> JoeyA, yeah, I downplayed types in this talk on purpose
13:02:26 <kmc> JoeyA, because I think it's hard to convince people in a few slides that Haskell's types are a good thing
13:02:32 <kmc> and there's enough instantly compelling stuff to cover
13:02:47 <JoeyA> Ah
13:02:52 <kmc> i come back to it a little in the STM section though
13:03:58 <erus`> kmc url to your talk :)
13:04:00 <JoeyA> main = getContents >>= mapM_ putStrLn . reverse . lines
13:04:21 <kmc> http://mainisusuallyafunction.blogspot.com/2011/10/slides-from-why-learn-haskell.html
13:04:26 <wavewave> type is tricky. For type to be good, it needs to be expressive enough.
13:04:27 <JoeyA> (that is almost certainly shorter in Perl or Golfscript)
13:04:53 <wavewave> and also consistent.
13:05:13 <erus`> kmc no video?
13:05:34 <kmc> i guess i also mention the usefulness of types in the "parametric polymorphism" slide
13:05:42 <kmc> erus`, no, would video add anything to the experience?
13:05:48 <kmc> i tried very hard to make the slides self-contained
13:06:05 <erus`> pdf :( i have to upload to google docs to view
13:06:13 <kmc> you don't have a pdf viewer...?
13:06:25 <erus`> you should do one of those fancy html5 slideshows
13:06:35 <b_jonas> Of course, it's also possible that the journal gains something from this but I don't know about it.
13:06:45 <kmc> erus`, i used S5 before
13:07:06 <kmc> it would look wrong depending on screen/window size, and didn't work at all in Chrome
13:07:17 <kmc> i think Slidy or newer S5 is better
13:07:51 <kmc> but PDF is the standard for documents that preserve exact formatting
13:07:58 <erus`> was this on /r/haskell?
13:08:00 <kmc> it looks the same everywhere, which is important to me
13:08:02 <kmc> yes erus`
13:08:07 <kmc> erus`, why is PDF inconvenient for you? i'm curious
13:08:20 <wavewave> kmc: that's very important!
13:08:35 <kmc> i'd consider generating both PDF and Slidy HTML from the same Markdown, but it would be significantly more work
13:08:50 <erus`> kmc i dont have a pdf viewer installed
13:09:08 <erus`> i should get a firefox plugin or something
13:09:16 <erus`> but i hate adobe crap
13:09:20 <wavewave> erus' : if you use google-chrome, you can have it freely.
13:10:12 <wavewave> adobe is the worst pdf viewer.
13:10:24 <erus`> yeah but im scared google are getting too powerful
13:10:30 <engla> erus`: http://pdfreaders.org
13:10:36 <kmc> you should install a lightweight pdf viewer; there are many
13:10:39 <erus`> so i try not to use their stuff as much as possible
13:10:46 <wavewave> FoxIt is another good.
13:11:00 <kmc> then you can read haskell papers too ;)
13:12:04 <igstan> there was a firefox extension based on pdf.js, which is built by Mozilla. A future version of Firefox will probably include a built-in pdf reader
13:12:10 <igstan> https://github.com/andreasgal/pdf.js
13:13:03 <kmc> cool
13:15:19 <erus`> i remember seeing examples using foldr and stuff when  first saw haskell and being like wtf...
13:15:56 <erus`> "heres quicksort in one line isnt haskell great"... I dont have a clue what is going on here
13:17:33 <JoeyA> Here's mergesort in one line: sort
13:17:35 <JoeyA> Isn't Haskell great?
13:17:47 <Veinor> haha
13:18:21 <kmc> the canonical one-line "quicksort" doesn't use "foldr and stuff"
13:18:32 <kmc> http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
13:18:41 <Veinor> does hint work on ghc 7.2 yet?
13:19:17 <keep_learning> is there any function which convert ByteString of hex characters to Integer . Some thing like 0x1111 = 16^3 + 16^2 + 16 + 1
13:19:32 <kmc> i think the syntax and library functions in that example are pretty clear
13:19:37 <copumpkin> > read "0x1111"
13:19:38 <lambdabot>   *Exception: Prelude.read: no parse
13:19:39 <kmc> to someone with a bit of programming experience who doesn't know Haskell
13:19:42 <copumpkin> > read "0x1111" :: Int
13:19:43 <lambdabot>   4369
13:19:46 <mrbig1> Why does Haskell appear to be so much faster than OCaml?
13:19:48 <copumpkin> convert your bytestring to a string and call read on it
13:19:53 <kmc> erus`, however, it's not quicksort anyway
13:20:01 <kmc> mrbig1, appear? what benchmarks are you looking at?
13:20:05 <keep_learning> copumpkin, thank you
13:20:11 <wavewave> mrbig1: haskell is so much faster than OCaml?
13:20:12 <kmc> also this is a monster of a sentence
13:20:13 <copumpkin> mrbig1: haskell the language is way faster than ocaml the language, amirite kmc?
13:20:14 <kmc> "The first thing to know about Haskell's syntax is that parentheses are used just for grouping of operands and not for functional application, which is indicated just by a juxtaposition of a function and its arguments - which also has the highest priority, so is always applied before any operators: here, the ++ operator has lower precedence than the two quicksort calls (the parentheses around them are superfluous and are put here for clar
13:20:14 <kmc> ity):"
13:20:41 <kmc> comma, hyphen, colon, comma, parenthetical
13:21:22 <mrbig1> kmc the language shootout ones.
13:21:43 <hpc> mrbig1: more work is put into improving the code GHC generates
13:21:49 <kmc> mrbig1, probably because the large number of Haskell enthusiasts are more obsessive about tweaking shootout programs than the smaller number of OCaml enthusiasts
13:21:52 <hpc> and a lot of work goes into the runtime too
13:22:02 <hpc> and also that reason
13:22:05 <kmc> GHC is a good compiler which produces fast code, but I've heard the same of ocamlc
13:22:09 <mrbig1> ok, thanks
13:22:12 <wavewave> those benchmarks are misleading.
13:22:27 <kmc> I've also heard that ocamlc doesn't do crazy optimizations -- it just has good codegen for a language which is easy to implement efficiency
13:22:30 <mrbig1> yeah, I thought Ocaml was also optimized or whatever, not jut someone's toy thing
13:22:43 <kmc> it's definitely not just someone's toy thing
13:22:47 <wavewave> Ocaml is not toy thing.
13:22:50 <mrbig1> yeah that's why I was so surprised
13:22:51 <kmc> it's used in production high-frequency trading systems (at Jane St)
13:22:53 <copumpkin> that doesn't mean the individual programs people wrote for the shootout are good
13:23:00 <mrbig1> true
13:23:07 <wavewave> haskell is not toy thing either..
13:23:11 <kmc> i think those people are just more interested in making Wall St Megabux than winning some online pissing contest ;)
13:23:20 <kmc> Haskell has more of an evangelical tradition than ocaml
13:23:21 <Kaidelong> from what I understand, Haskell is more popular than OCaml but not by much
13:23:27 <wavewave> so it's not surprising that they both work well.
13:23:30 <Kaidelong> in industry, I mean
13:23:31 <copumpkin> we need moar wall st megabux too
13:23:32 <copumpkin> less evangelism
13:24:44 <mrbig1> more cowbell
13:24:59 <wavewave> I think one of main obstacle for haskell to be more widely used is GUI application.
13:25:10 <kmc> who writes GUIs nowadays?
13:25:13 <mrbig1> srsly
13:25:45 <wavewave> for people's attraction
13:26:08 <Kaidelong> I guess gateways, scripts, and glue code aren't compelling applications
13:26:10 <mrbig1> I wanted to read about Snap but I think I need to learn more syntax first.
13:26:14 <Kaidelong> but you could point to XMonad
13:26:43 <wavewave> simply many people are attracted by easy-to-make-some-decent-stuff.
13:26:55 <Kaidelong> it's not like OCaml is overflowing with shiny applications either. I mean, there's MLDonkey I guess
13:27:28 <Veinor> i don't agree with GUI applications being important
13:27:28 <Kaidelong> but as I understand most OCaml stuff is also unglamorous things like number crunching
13:27:34 <Veinor>  i think webapps are the Way Of The Future
13:27:44 <b_jonas> Are people attracted to Racket (former PLT scheme)? It promises easy graphical toys.
13:27:50 <wavewave> so for experts, haskell is appreciated, but for programming beginners, popularity falls down.
13:28:06 <Kaidelong> Veinor: well the distinction between the two is fading fast and probably never should have been notable to begin with
13:28:08 <Veinor> if for no other reason than the fact that you can compile for linux
13:28:20 <copumpkin> composable webapps!!
13:28:33 <kmc> i like how half of that confusing sentence is confusingly explaining that function application binds tighter than operators — and then that you don't need to know this to read the code example
13:28:45 <b_jonas> why would you even want programming beginners for Haskell?
13:28:49 <wavewave> Veinor: I agree it. So haskell rises again with decent web platform..
13:28:55 <Veinor> kmc: so... edit it? :P
13:28:59 <kmc> Veinor, in progress
13:29:14 <kmc> b_jonas, because it's easier to learn Haskell if your mind is not twisted by other languages
13:29:14 <b_jonas> maybe I'm old-style, but I think people should be tought procedural programming (appending elements to arrays in a for loop) first
13:29:19 <kmc> or so it is always claimed
13:29:19 <b_jonas> and functional programming only later
13:29:36 <igstan> guys, what would be the best FRP library play with on mac os x? I want to play around with some GUIs, not just command line stuff.
13:29:39 <Kaidelong> b_jonas: By complete accident, I learned functional programming in SML/NJ first, and it worked out well for me
13:29:45 <kmc> b_jonas, why?  functional programming is very natural; you talk about values and equations and results.  specifying individual steps to perform is a low-level implementation detail
13:29:56 <Veinor> i don't think i like the evangelism of 'other languages are twisted and their paradigms are Inferior and Wrong'
13:30:22 <wavewave> ....  let me say my point a little bit clearly... problem was that there were no simple way to do GUI at all in haskell until very recently.
13:30:24 <Kaidelong> Veinor: I think it'd be easier to teach basic haskell than basic java or visual basic though
13:30:52 <kmc> Veinor, by "twisted" I mean more specific confusion... like muddling evaluation and execution, value and state, argument dependence and delayed evaluation
13:31:02 <kmc> Haskell does a better job of separating concepts which elsewhere are married by historical accident
13:31:03 <mrbig1> what about basic scheme?
13:31:11 <b_jonas> kmc: I'm not quite sur in my reasons. I could be wrong.
13:31:14 <wavewave> so i think it was definitely an obstacle... Many people still like to play some visual stuff.
13:31:18 <Kaidelong> kmc: I actually think the most important thing haskell brings to the table is the simple syntax
13:31:39 <Kaidelong> less struggling with semicolons and other nonsense if you're just beginning
13:31:50 <Kaidelong> or that silly visual basic underscore
13:31:57 <Veinor> kmc: again, i'm not convinced that this is necessarily a bad thing
13:32:07 <kmc> which?
13:32:11 <Veinor> sometimes you just want to get stuff done, sometimes you want super-high-quality code
13:32:28 <levi> Kaidelong: It's deceptively simple-looking, but reading code is not always straightforward.
13:32:30 <Kaidelong> Veinor: the trouble with lax discipline is that it can be confusing when students get stuff wrong
13:32:35 <b_jonas> Simple syntax might be an advantage, but I'm talking about procedural programming versus functional programming in particular, not syntax.
13:32:36 <Kaidelong> I saw this all the time tutoring VB
13:32:49 <mrbig1> you must be ancient
13:32:50 <Kaidelong> students would get caught up because they did things wrong but it wasn't clear it was there fault
13:32:55 <kmc> Veinor, I argue that you want to learn the language which is clear about these concepts before the ones which mash them all together for expediency
13:33:01 <kmc> Veinor, not that the latter language is never useful
13:33:18 <Kaidelong> b_jonas: Procedural programming is probably a good thing to teach. Dunno if you have to teach it early though
13:33:21 <kmc> Haskell is also a fine language for "just get stuff done", but you have to invest a lot of time in learning it to get to that point
13:33:31 <kmc> maybe that would change if people learned Haskell first
13:33:33 <Kaidelong> I'd say it's fine to start students on something like ML
13:33:40 <Kaidelong> just teach them an assembler later
13:33:41 <Veinor> that's possible.
13:33:55 <mrbig1> Why not start on Prolog?
13:34:06 <Kaidelong> Prolog is also a wonderful language to begin with I think just
13:34:15 <b_jonas> I dunno. Here we teach our students procedural programming first.
13:34:18 <kk`> I always thought Scheme would be nice to start with.
13:34:19 <jmcarthur> i actually think prolog would be a great first language
13:34:19 <Kaidelong> you have to convince people to let go of their intuition a little
13:34:52 <b_jonas> I've learnt procedural programming first, but that's only because implementations of such were all that was readily available for me when I first learnt stuff.
13:34:54 <jmcarthur> it's really simple and gets you thinking in a certain way
13:35:05 <levi> I learned Prolog during a summer camp at a university.  Went to the same school a couple of years later, but they didn't teach it in the actual curriculum. :/
13:35:07 <wavewave> lots of different opinions.. ;-)
13:35:18 <Kaidelong> well functional programmers used procedural languages first
13:35:28 <Kaidelong> FORTRAN more specifically
13:35:48 <b_jonas> Prolog is actually the largest part of CS I've actually learnt in curriculum as opposed to self-thought.
13:35:52 <Kaidelong> doesn't mean you can't teach functional programming with a procedural language
13:36:07 <rferranti> you just miss the sugar
13:36:12 <b_jonas> By which I mean I learnt prolog to take an exam of it, not that I learnt prolog from professors.
13:36:18 <levi> Yeah, John Backus created both FORTRAN and FP. :)
13:36:38 <wavewave> i do not particularly think some language is much better than others as the first language.
13:36:57 <Kaidelong> wavewave: I do think there are some important things
13:36:58 <b_jonas> Dunno.
13:37:11 <Kaidelong> Syntax, and static type checking
13:37:15 <ion> Oh, the term “functional dependency” seems to come from database design (unless i’m mistaken). Didn’t know that.
13:37:25 <Kaidelong> and checked exceptions were also helpful when I was learning java
13:37:39 <Kaidelong> in terms of teaching me to think ahead
13:37:54 <jmcarthur> i just wish that more budding programmers were taught to think compositionally
13:37:57 <kmc> kk`, MIT and Caltech and many other top schools used to start with Scheme
13:37:59 <kmc> no longer :/
13:38:00 <Kaidelong> although I think test driven might be a better way to go than checked exceptions
13:38:00 <rferranti> someone said "languages shape the way we think and determine what we can think about
13:38:05 <b_jonas> jmcarthur: yes, that's very important
13:38:07 <rferranti> (b.worf)
13:38:14 <jmcarthur> it took quite some effort to get myself to think that way
13:38:18 <wavewave> well.. I started from Basic, pascal, c, c++, java, c#, scheme, haskell.... I do not think any language particularly bad in my experience.
13:38:20 <b_jonas> jmcarthur: I tried to teach them to reuse stuff as subroutines instead of copying code
13:38:22 <Kaidelong> b_jonas: Don't you think that's a good argument for using a declarative language?
13:38:22 <levi> jmcarthur: They do try to teach that these days in terms of composing objects.
13:38:23 <kk`> kmc, yeah, it's unfortunate. Scheme is nicely simple.
13:38:23 <jmcarthur> i don't think i was forced to, really, until i gave haskell a shot
13:38:25 <b_jonas> and to write subroutines
13:38:28 <kmc> they start with Scheme because you can cover the syntax in 1 hour total, and spend the rest of the course learning about deep concepts of CS
13:38:30 <b_jonas> Kaidelong: no
13:38:35 <Kaidelong> I'm pretty sure you could create declarative, procedural languages
13:38:39 <b_jonas> not as a first language at least
13:38:44 <jmcarthur> levi: i mean in the denotative sense
13:38:54 <mm_freak> wavewave: try writing PHP code productively
13:38:56 <Kaidelong> in which you can compose procedures much the way you can do for functions or predicates
13:39:02 <b_jonas> They can start to learn declarative after a short while though.
13:39:04 <mm_freak> then you can say that you know a bad language =)
13:39:23 <rferranti> mm_freak, depends on your definition of productivity
13:39:33 <mm_freak> rferranti: working, maintainable code
13:39:51 <jmcarthur> levi: or maybe a better contrast to what you said would be that i mean that i wish people were taught to program compositionally in a pervasive way. not just from some bird's eye view, but at every level of your code
13:39:54 <wavewave> mm_freak: I know PHP.. and used it for some project for a very short time.
13:39:58 <mm_freak> code that doesn't make you want to throw up
13:40:08 <rferranti> mm_freak, lol
13:40:10 <kmc> i think starting with Scheme is good, starting with Haskell is not crazy either
13:40:15 <b_jonas> Kaidelong: these first-year students barely understand how to treat mathematical functions as first-class objects. I don't think they'd find it easy to write programs that manipulate functions as first-class stuff.
13:40:26 <kmc> a simplified variant of Haskell for teaching would be even better
13:40:30 <kmc> (Helium aims to be this)
13:40:38 <rferranti> scheme is a nice choice for a first language imho
13:40:39 <b_jonas> They're like mathematicians from Newton/Leibniz time, using dependant variables, not functions.
13:40:39 <jmcarthur> b_jonas: all the more reason they need to learn it
13:40:40 <mrbig1> like Racket's simplified languages?
13:40:47 <kmc> sure
13:40:57 <Kaidelong> b_jonas: I learned about higher order functions in precalc, though
13:41:01 <Kaidelong> perhaps that's not normal
13:41:24 <rferranti> Kaidelong, i did when i learned c++ lol
13:41:26 <Kaidelong> and piecewise defined functions as well
13:41:30 <b_jonas> jmcarthur: yes, but not before learning the principles of programming, like reusing subroutines and how to read error messages and how to write code in small chunks printing intermediate results.
13:41:35 <dgpratt> got an easy question on propositional logic; not exactly on-topic for #haskell, but I'm guessing someone here could answer it easily...
13:41:53 <dgpratt> it comes from here: http://www.usingz.com/text/online/page-19.html
13:41:54 <wavewave> i guess if we all start functional programming, we will also rediscover the virtue of imperative programming again.
13:42:00 <jmcarthur> the point, to me, isn't to ease people into programming. it's to get them to the good stuff as quickly as possible. of course i'm not advocating that we leave stragglers in the dust, but i feel like most efforts are too entrenched in efforts to look "familiar"
13:42:06 <b_jonas> they can't learn abstractions all at once.
13:42:08 <jmcarthur> wavewave: yes!
13:42:19 <kmc> dgpratt, sure, what's your question?
13:42:36 <jmcarthur> i think that coming from a functional setting instead of an imperative setting would better highlight the virtues of both
13:42:36 <b_jonas> I'm not against introducing the basics functional programming in second year, which is in fact what we're doing.
13:42:39 <copumpkin> familiarity is the root of all evil
13:42:54 <Kaidelong> jmcarthur: And also, some imperative programming concepts like assignment and mutable references genuinely are confusing to beginners
13:43:00 <jmcarthur> Kaidelong: indeed!
13:43:02 <Kaidelong> or at least to some of the ones I worked with
13:43:04 <b_jonas> Kaidelong: sure, they _learn_ about functions in pre-calc, but don't understand them yet.
13:43:24 <wavewave> Kaidelong: then same argument to recursion.. in fact.
13:43:25 <kmc> Kaidelong, i'll second that, having TA'd a intro-programming-with-Scheme class where we introduced set! and such at a particular point
13:43:26 <dgpratt> kmc: In general, I'm wondering what's allowed when working backwards from conclusions to premises...
13:43:49 <b_jonas> Kaidelong: that (mutable variables being confusing) is however a good argument
13:43:56 <Kaidelong> wavewave: recursion can be hard to explain, I'll give you that
13:44:03 <b_jonas> though I am trying to teach a style with few mutations
13:44:04 <dgpratt> kmc: specifically, I'm wondering what is happening in the transformation from the first example on that linked page to the second example
13:44:04 <Kaidelong> but you encounter that in imperative programming too
13:44:10 <wavewave> teaching iterative process using recursion also make course slow..
13:44:32 <kmc> b_jonas, I'm still arguing that "what should the code do, step by step" is lower level than "what should the function output given this input"
13:44:34 <b_jonas> like, mutate the index in the loop, but don't mutate the array elements
13:44:35 <wavewave> Kaidelong: I mean in FP, we tend to hit recursion earlier.
13:44:38 <rferranti> recursion is pretty natural in the way of human thinking imho
13:44:54 <kmc> b_jonas, and you want to start with the high-level expressive ideas, and work your way down to machine code and CPU design
13:44:57 <wavewave> loop vs recursion.
13:45:05 <kmc> though a curriculum which is seriously committed to going the other direction would also be cool
13:45:15 <Kaidelong> wavewave: if you're going to teach proof by induction though, you'd have to get people to grasp recursion...
13:45:26 <dgpratt> the part where they write 'p => q    p' above q
13:45:26 <b_jonas> kmc: we don't (try to) start with machine code. we depend on the language allocating memory automatically and things like that.
13:45:26 <Kaidelong> so you may as well get recursion out of the way early
13:45:40 <kmc> yeah, you start somewhere in the middle
13:45:43 <Cale> Or, teach induction first, and then recursion? :)
13:45:47 <kmc> why is that best
13:45:48 <dgpratt> it makes sense in the forward direction...
13:45:56 <Kaidelong> Cale: That's actually how I was taught
13:45:59 <kmc> why not hide as many irrelevant implementation details as possible, to start with
13:46:02 <kmc> and introduce them one by one
13:46:04 <Kaidelong> I didn't grasp it at all until I was taught recursion
13:46:06 <wavewave> Kaidelong: yeah..  in fact, this discussion depends on which grade you are teaching now.
13:46:08 <Kaidelong> so that didn't work for me
13:46:12 <b_jonas> It could be that you're right and it's better to teach functional programming form the start
13:46:14 <jmcarthur> to me, mutating an index is a distraction from the heart of the algorithm. i note that in most algorithms classes i've seen that teach with imperative languages, the most tedious part when writing out the code always seems to be index manipulation
13:46:20 <b_jonas> I don't really know
13:46:21 <kmc> b_jonas, I'm just curious what your counter-arguments are
13:46:23 <b_jonas> it's hard to test
13:46:27 <Cale> I was taught induction via the well-ordering principle first.
13:46:36 <b_jonas> I thought a lot on what to teach because I had to teach _something_
13:46:37 <wavewave> Kaidelong: elem school level, middle school level or university level.
13:46:38 <kmc> b_jonas, I'd also emphasize "declarative programming" and not "functional programming"
13:46:40 <Kaidelong> b_jonas: It absolutely is something worth experimenting with and documenting
13:46:41 <b_jonas> but I'm not sure I did the right thing
13:46:43 <Cale> Any nonempty set of natural numbers has a least member => induction
13:46:48 <b_jonas> kmc: right
13:46:51 <kmc> "functional vs imperative" is a stupid false dichotomy, and nobody can agree on what counts as a "functional language"
13:46:52 <Anpheus_> Could someone help me understand the flaw in my attempt to parallelize a project euler problem? Specifically, I solved problem 31 and I thought, "gee, I wonder if it would solve faster with Strategies" and it's running slower than it was sequentially.
13:46:56 <b_jonas> kmc: so no first-class functions at first?
13:47:03 <kmc> b_jonas, what, no
13:47:07 <Cale> Anpheus_: I can have a look
13:47:12 <b_jonas> Kaidelong: I probably won't be in that position
13:47:17 <Cale> Anpheus_: put it on hpaste.org :)
13:47:18 <jmcarthur> kmc: join the ranks of "denotative" programmers! ;)
13:47:30 <b_jonas> kmc: yep
13:47:31 <Anpheus_> Cale: doing that right now
13:47:51 <b_jonas> kmc: common lisp is procedural, scheme is functional :-)
13:47:57 <kmc> for fuck's sake
13:48:02 <rferranti> there are so many books on patterns, why there isn't any book on idioms?
13:48:05 <Cale> Anpheus_: It's usually granularity. Making sparks is cheap, but it's not free.
13:48:06 <kmc> i'm not interested in arguing about whether language foo or bar is functional
13:48:10 <b_jonas> I prefer "procedural" over "imperative" though
13:48:24 <kmc> how much time is wasted with these "paradigms"
13:48:39 <kmc> b_jonas, my point re: "declarative" wasn't about avoiding FP features
13:48:45 <kmc> whatever those are
13:48:54 <rotflcopter> anybody seen things like this before?
13:48:54 <rferranti> kmc, idioms > paradigms
13:48:56 <rotflcopter> File descriptor 7 (pipe:[352923]) leaked on vgdisplay invocation. Parent PID 26907: bash
13:49:09 <b_jonas> kmc: what then?
13:49:09 <kmc> rotflcopter, yes, that's SELinux or AppArmor or something
13:49:26 <rotflcopter> kmc<< selinux prevents something?
13:49:34 <kmc> yes (or at least notices it)
13:49:40 <rotflcopter> ok thx
13:49:41 <kmc> it's also off topic, you can go to a linux help channel
13:49:48 <Anpheus_> Cale: http://hpaste.org/52667
13:49:50 <rotflcopter> i got no reply
13:49:56 <rotflcopter> and its not a kernel problem
13:50:00 <Anpheus_> Alternate commenting 18,19,20 or line 21
13:50:00 <Cale> It *might* be on topic, if it's a Haskell program causing the message :)
13:50:00 <kmc> it's still off-topic even if you got no reply there
13:50:15 <kmc> I'm pretty sure vgdisplay is not a Haskell program
13:50:20 <b_jonas> Also, we can't ever agree what ever should we teach about computers to these students. All people can agree on is that whatever we're doing is wrong so we change it like every two years.
13:50:20 <rotflcopter> yep
13:50:27 <rotflcopter> :)
13:50:27 <kmc> b_jonas, yeah :/
13:50:43 <rotflcopter> but if it makes you feel better, lvdisplay gives this too
13:50:49 <kmc> b_jonas, my point is that Haskell isn't better because it's "functional" (whatever that means), it's better because it's more declarative
13:50:58 <Anpheus_> Cale: Lines 18-20 split the problem into chunks, solve subsolutions, then concatenate those. I've tried various "n ==" and "n <" and the like to minimize sparking *every* subsolution, but to no avail.
13:51:15 <kmc> b_jonas, (it's better for both reasons, actually, but I'm talking about what's relevant to beginning programmers)
13:51:45 <Cale> Anpheus_: Of course, there's also memoisation...
13:51:52 <b_jonas> Our mathematician program is quite new (only like 12 years old), so I informally call it "experimental mathematics" (as opposed to the "theoratical mathematics" (actually called just "mathematics") and the "applied mathematics" programs on the other university)
13:52:01 <Anpheus_> Cale: Yeah, and there's also other better solutions
13:52:14 <Cale> but yeah, let's try...
13:52:16 <b_jonas> though formally it's just "mathematics" (or "applied mathematics" in a few years when they made some error)
13:52:17 <Anpheus_> Cale: But I'm curious why splitting the problem like this and doing subproblems in parallel did not yield any speedup at all
13:52:22 <kmc> in other words, I think the strongest arguments for FP are stronger if you cast it as "declarative programming"
13:52:32 <kmc> it's also a term that gets more respect in The Industry
13:52:41 <rferranti> sql is soooo declarative
13:52:54 <rferranti> now i want to see you saying you like it :p
13:53:10 <b_jonas> kmc: yep
13:53:46 <b_jonas> But isn't recursion more difficult for beginners than simple for-loops?
13:53:53 <kmc> is it?
13:53:56 <jmcarthur> my algorithms teacher in particular made working with indices even more excruciating because he insisted that everyone must abide by his personal choice to index arrays from 1 instead of from 0
13:53:59 <kmc> do you have evidence or arguments to support that claim?
13:54:17 <b_jonas> kmc: you need to pass the variables back
13:54:18 <rferranti> b_jonas, for real beginners i don't think it is
13:54:31 <kmc> i think if you teach it properly, recursion is more natural
13:54:42 <jmcarthur> i don't think i found either more difficult to get used to than the other
13:54:50 <Anpheus_> kmc: I have loads of anecdotal evidence from teaching other people programming, and recursion tends to require more mental juggling at first
13:55:00 <Cale> Anpheus_: It finishes so quickly on my machine that I can't actually tell if it's using more than one CPU :P
13:55:15 <b_jonas> I don't have evidence, because I don't know anyone around here who'se started with declarative programming.
13:55:15 <kmc> at my school, freshman learning Scheme and recursion were also taking core math with lots of proofs and induction
13:55:24 <td123> kmc: same
13:55:29 <Anpheus_> Cale: Well yeah it should run in 1-2 seconds, hence I use "-s" to look at runtime stats and # of sparks
13:55:37 <dgpratt> I guess my question is: if "q" is the conclusion and "p" is an assumption, does that allow me to infer a premise of "p => q"? (does that even make sense?)
13:55:38 <kmc> b_jonas, "functional" is the wrong thing to emphasize... you can use first-class functions in a very imperative, procedural, non-declarative style... and it's actually a good thing, if you're stuck using that style.  but it misses the wider point
13:55:51 <b_jonas> kmc: yep
13:56:03 <b_jonas> I agree with that much
13:56:06 <Anpheus_> Cale: If you increase the problemSize variable you can easily make it run much, much longer :)
13:56:10 <kmc> there's a big difference between idiomatic Javascript code and idiomatic Haskell code which isn't particularly about first-class functions (which both languages have)
13:56:11 <jmcarthur> my wife knows much more declarative than imperative, but she has been subjected to my biases, so the fact that she thinks mutation sounds crazy doesn't say much, i think
13:56:26 <kmc> the idiomatic Haskell program looks like a set of rules regarding inputs and outputs
13:56:40 <kmc> the idiomatic Javascript code looks like a sequence of steps to follow, even if some of those steps involve higher-order programming
13:56:43 <jmcarthur> that is, i don't think her opinion is formed as much from her own experiences as from my accounts of my own
13:56:56 <kmc> anyway I think I've beat this dead horse enough
13:57:00 <Cale> Okay, so it's using 150% cpu here
13:57:30 <b_jonas> kmc: where you say "lots of proofs and induction", does that include understanding how strong induction on N (where you depend on all previous steps" is a special case of induction on N where the statement starts with "for all k < n" ?
13:57:54 <b_jonas> kmc: I mean, some mathematicians find strong induction more basic, but weak induction is more analogous to what you're doing in programming.
13:57:54 <kmc> b_jonas, i don't remember if that was covered
13:58:02 <kmc> ah
13:58:10 <kmc> i think they're both close enough to be a useful parallel to recursion, though
13:58:19 <rotflcopter> nahm btw im still freeing up diskspace for ghc
13:58:34 <rotflcopter> and installing a new system that takes less
13:58:38 <rotflcopter> ;/
13:58:41 <kmc> maybe recursion does require more mental juggling than for loops
13:58:46 <kmc> it's after all a vastly more general concept
13:58:55 <Cale> kmc: Indeed -- lots of divide-and-conquer recursive strategies are explained more naturally with strong induction :)
13:59:00 <b_jonas> I mean, if you're trying to build arrays in a loop, then strong induction is sort of like appending to a mutable array, whereas weak induction is growing an immutable array.
13:59:15 <rotflcopter> my / is 8GB ! without /swap,/hom,/var
13:59:40 <Cale> Recursion and loops are both unnatural ways of thinking. Higher order functions are natural :)
14:00:01 <kmc> b_jonas, I could get behind a program of "teach map/fold before recursion"
14:00:06 <kmc> both in a declarative setting
14:00:18 <b_jonas> kmc: sure, but there are things you can't write with map
14:00:24 <jmcarthur> that sounds pretty awesome actually
14:00:25 <kmc> there are things you can't write with "for" loops
14:00:39 <b_jonas> kmc: sure, we also have while loops
14:00:40 <Cale> Nobody numbers their dishes and increments a counter while washing them, nor do they divide the dishes into even piles recursively to wash them. They just wash all the dishes.
14:00:56 <b_jonas> rotflcopter: my /usr is 8G too
14:00:59 <Kaidelong> kmc: Didn't people in the old days and even now have declarative ways of specifying procedural programs as well?
14:01:01 <kmc> Cale, I know someone who does the first
14:01:05 <rotflcopter> ;<
14:01:07 <b_jonas> I could delete half of it, but why bother
14:01:13 <Cale> Which is a lot closer to "map wash dishes" than the other options :)
14:01:16 <Kaidelong> flowcharts usually
14:01:21 <b_jonas> Cale: they use a for loop on the array of dishes
14:01:32 <FUZxxl> Is there any semantical difference between MonadPlus and Alternative?
14:01:36 <hpc> Cale: it would be fmap wash dishes; it's a stack ;)
14:01:37 <kmc> the problem with teaching procedural "for loops" before recursion is that you're pulling in a mess of additional concepts like mutation and syntactic statements
14:01:42 <b_jonas> Cale: no map
14:01:46 <b_jonas> Cale: just a for loop
14:01:53 <Cale> FUZxxl: MonadPlus is a subclass of Monad, Alternative is a subclass of Applicative
14:02:05 <b_jonas> mutating the dishes
14:02:05 <Anpheus_> More like a while loop.
14:02:06 <Cale> hpc: yeah
14:02:06 <kmc> like I said, procedural is a totally different and more low-level way of programming
14:02:07 <Kaidelong> b_jonas: what language are you teaching?
14:02:14 <Cale> hpc: map wash dishes in Haskell 1.4 ;)
14:02:16 <kmc> whereas 'map' is just another function you can use declaratively
14:02:28 <Anpheus_> while (stillDirtyDishes) { wash dish }
14:02:38 <Cale> People use lots of things which would be higher order functions in their natural language.
14:02:45 <b_jonas> Kaidelong: I was teaching python in the most successful year, but it's not quite my decision. I might have tought ruby instead. I'm not really sure.
14:03:21 <Kaidelong> python has map...
14:03:31 <Cale> If I hand you a bunch of glue and ask you to glue a bunch of sheets of paper together end to end, there's nothing in that description of mine which specifies the order in which you should do it, but you'll be able to get it done anyway
14:03:34 <b_jonas> Kaidelong: sure, but it's not the language that's important but the style
14:03:54 <Kaidelong> seems to be better style to tell the students to use map in that situation rather than a loop though
14:03:55 <wavewave> allocate memory, put dish pointers there, and replaced it with cleaned wash, check next dish pointer while next point is null. clear memory allocation.
14:04:00 <b_jonas> Kaidelong: if you want, you can look at the style I was trying to teach at http://russell2.math.bme.hu/~ambrus/sc/info1/
14:04:11 <b_jonas> though that doesn't tell everything of course
14:04:18 <Kaidelong> hmm I can't read hungarian
14:04:21 <Kaidelong> oh
14:04:24 <Anpheus_> Cale: Any clue why my divide and conquer doesn't work, by the way? :(
14:04:24 <b_jonas> Kaidelong: you can read the code
14:04:28 <Kaidelong> I'll open it in chrome
14:04:49 <b_jonas> I think the better thing for beginners is to try to teach very few construnctions at first from which they can assemble anything
14:04:59 <b_jonas> in my case, I tried to teach for and while loops
14:05:32 <b_jonas> if you tried to teach everything, including maps and folds, they couldn't follow how stuff is general but just tried to find the right function for every task from the libraries
14:05:40 <b_jonas> which doesn't really teach programming
14:05:45 <Kaidelong> I'm not sure I mean, it's frustrating to have to implement Sum in visual basic if you can just go ".Sum"
14:05:49 <Cale> Anpheus_: I'm still looking :)
14:05:54 <b_jonas> it's an important skills, but understanding how you can build all programs from a few basics should come first
14:06:12 <Kaidelong> when I was TAing I was clear to inform people when they didn't have to do work so that they could get on with being creative
14:06:26 <Cale> Anpheus_: This is a bit of a strange style for me...
14:06:59 <b_jonas> Kaidelong: note that I didn't write the first four files of those
14:07:01 <b_jonas> so ignore those
14:07:06 <b_jonas> they're not completely in my style
14:07:12 <Anpheus_> Cale: I'm very bad at idiomatic haskell :D
14:07:12 <b_jonas> that's unfortunate
14:07:20 * hackagebot numeric-tools 0.1.0.1 - Collection of numerical tools for integration, differentiation etc.  http://hackage.haskell.org/package/numeric-tools-0.1.0.1 (AlexeyKhudyakov)
14:08:25 <b_jonas> Kaidelong: better look at http://russell2.math.bme.hu/~ambrus/sc/info1/info1-gy4.html and http://russell2.math.bme.hu/~ambrus/sc/info1/info1-gyx-spoiled.html for they're the most illustrative
14:08:52 <Cale> solve n xs = go denominations 0 xs -- n is unused here :)
14:09:02 <b_jonas> Kaidelong: also note that these pages have some more difficult examples that I don't expect most students to be able to produce, but they're there so that the few better students have something to do
14:09:09 <jmcarthur> b_jonas: i think that MonadPlus also has some additional laws, but nobody agrees on what they are
14:09:32 <Cale> and... what is xs for? Let's see...
14:09:32 <jmcarthur> and in fact different instances adhere to different laws :\
14:10:16 <b_jonas> so basically only the first working solution for the trianular numbers problem of http://russell2.math.bme.hu/~ambrus/sc/info1/info1-gy4.html counts, the rest counts as extra material, except that the stuff at the beginning on finding roots is in again
14:11:36 <b_jonas> Kaidelong: if you don't understand the exposition and have questions, feel free to ask me
14:11:39 <Anpheus_> Cale: You are correct, I've been editing the code constantly to play with different things, so it's had some haphazard edits along the way.
14:12:03 <jmcarthur> man, the more ocaml code i write the more my haskell code suffers
14:12:16 <jmcarthur> i'm getting used to the absense of things like ($)
14:12:18 <Cale> (+) <$> [x] <*> [0,c..(problemSize - x)] = map (+x) [0,c..(problemSize - x)] = [x,x+c..problemSize]
14:12:39 <b_jonas> Kaidelong: oh, and http://www.perlmonks.com/index.pl?node_id=927735 has translations fo the code in http://russell2.math.bme.hu/~ambrus/sc/info1/info1-gy4.html
14:12:39 <Kaidelong> Felparamterezzk the circle 30 degrees
14:12:40 <jmcarthur> at least in the ocaml code i normally write
14:12:50 <Anpheus_> Cale: The thousand mile view is that the program solves euler problem 31 by creating lists of all the currency combinations you can get from 2 pence, 5 pence, ... 2 pound denominations.
14:12:56 <Anpheus_> Cale: Neat catch
14:13:03 <hpc> jmcarthur: try writing agda code sometime, and find yourself constantly wanting GADTs, even if you won't use their power
14:13:16 <jmcarthur> hpc: i do write agda ;)
14:13:26 <jmcarthur> hpc: ocaml is getting gadts soon
14:13:46 <Cale> jmcarthur: I forget if O'Caml defines (.) as composition...
14:13:54 <jmcarthur> Cale: not by default, at least
14:13:58 <Cale> :/
14:13:59 <b_jonas> SML uses o I think
14:14:17 <jmcarthur> Cale: we have this |! thing for reverse composition
14:14:42 <jmcarthur> (it looks ugly in isolation, i know, but it makes more sense in context)
14:15:16 <jmcarthur> for the most part, it doesn't get used, though
14:16:37 <Cale> You can judge the character of a functional programming language by how it treats function composition :)
14:17:54 <Kaidelong> Cale: http://caml.inria.fr/pub/old_caml_site/caml-list/0838.html
14:18:00 <Kaidelong> pretty discouraging actually
14:18:19 <Kaidelong> F# decided to use << for function composition and even with the value restriction the results are often polymorphic
14:18:36 <Kaidelong> although you generally use flipped function composition (>>) instead
14:19:51 <Kaidelong> like "List.map (fun x -> x*x) >> (fun x -> x.Average) >> System.Double.sqrt"
14:19:52 <Kaidelong> or something
14:19:56 <hpc> Kaidelong: i can't tell how the logic works that leads to 'h' being less general when defined as f . g
14:19:59 <Kaidelong> err
14:20:17 <Kaidelong> hpc: It had something to do with impurity ruining the soundness of the type system
14:20:23 <Kaidelong> if you allow polymorphic values
14:20:36 <hpc> oh, bleh
14:20:42 <Kaidelong> essentially you are able to define "cast :: a -> b"
14:20:45 <b_jonas> isn't it like that in Haskell too if you use higher-order types?
14:20:56 <Kaidelong> I think the F# guys were less concerned about preventing that since you can do it in .NET anyway
14:21:09 <b_jonas> the impurity ruining the *soundness* of the type system? wtf
14:21:41 <hpc> :t fix ($) -- b_jonas
14:21:41 <lambdabot> forall a b. a -> b
14:21:50 <Kaidelong> b_jonas: I think there are ways to make haskell types unsound too, but it's not as simple as allowing polymorphic values
14:21:54 <hpc> it doesn't do scary casting stuff though, it's just a bottom value
14:22:11 <b_jonas> Kaidelong: I hear UnsafePerformIO allows that
14:22:17 <hpc> you can write a proper unsafeCoerce with unsafePerformIO
14:22:26 <b_jonas> I never understood how that worked
14:22:26 <Kaidelong> b_jonas: Yeah. But that also means you've thrown away purity
14:22:29 <hpc> by writing to a polymorphic pointer, then reading from it again
14:22:39 <b_jonas> hmm
14:22:52 <Kaidelong> b_jonas: Honestly, I don't either. It was a tradeoff though, and that's why ML programmers often don't do stuff point free
14:22:59 <hpc> b_jonas: polyPointer :: Ptr a; polyPointer = unsafePerformIO (newIORef undefined)
14:23:45 <Kaidelong> but basically purity means you want to avoid things like "mempty :: (Monoid m) => m"
14:23:48 <hpc> b_jonas: cast x = unsafePerformIO $ do {writeIORef polyPointer (x :: a); readIORef (polyPointer :: Ptr b)}
14:23:49 <Kaidelong> and prefer things in the form of
14:23:54 <Kaidelong> err
14:23:58 <Kaidelong> impurity I meant there above
14:24:00 <Kaidelong> not purity
14:24:13 <jmcarthur> that type is fine for certain things
14:24:13 <Kaidelong> "getMempty :: (Monoid m) => () -> m"
14:24:25 <jmcarthur> oh you mean polymorphically
14:24:34 <hpc> yeah, with impurity you could mutate a polymorphic mempty, then use it with a different type and get strangeness
14:24:40 <b_jonas> hpc: don't you want something else than newIORef there? I think newIORef doesn't do Ptr stuff
14:24:53 <hpc> b_jonas: something like that
14:24:56 <jmcarthur> you don't need Ptr. IORef is sufficient
14:24:58 <hpc> just showing you the general idea
14:25:07 <b_jonas> jmcarthur: that's what I don't understand
14:25:31 <b_jonas> I mean, with Ptr thingies, you can break the type system even without unsafePerformIO I think
14:26:02 <b_jonas> how does it work with IORef? those aren't polymorphic, are they?
14:26:33 <b_jonas> I'm not even sure what actually counts as breaking the type system once we get to this stuff
14:26:34 <hpc> IORef is just like Ptr, only with some implementation detail stuff
14:26:52 <hpc> you use them the same way in haskell code afaik
14:27:03 <Saizan> b_jonas: you can write unsafeCoerce with IORef+unsafePerformIO
14:27:35 <hpc> what i pasted above was unsafeCoerce, if the types were right
14:27:52 <hpc> you put an 'a' into a global pointer, then read from it, asking for type 'b'
14:28:12 <Saizan> b_jonas: because let r = unsafePerformIO (newIORef undefined) gives you r :: forall a. IORef a
14:28:33 <hpaste> jmcarthur pasted “unsafeCoerce” at http://hpaste.org/52669
14:28:37 <b_jonas> Saizan: ah, that's the trick
14:28:43 <jmcarthur> b_jonas: ^^
14:30:25 <hpc> Saizan: wait, how does that typecheck?
14:30:40 <hpc> wouldn't 'a' and 'b' unify because the pointer is in the function definition?
14:31:04 <hpc> er, IORef
14:31:24 <Saizan> what do you mean?
14:31:41 <hpc> oh, it does typecheck
14:31:57 <hpc> Saizan: ref :: IORef a
14:32:14 <Saizan> ref :: IORef a is really ref :: forall a. IORef a
14:32:15 <hpc> readIORef ref :: IO b
14:32:19 <hpc> oh
14:32:20 * hackagebot lhs2TeX-hl 0.1.4.5 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.4.5 (AlessandroVermeulen)
14:32:38 <Saizan> (the code was from jmcarthur btw)
14:32:46 <hpc> oooh
14:33:05 <hpc> i see what it does, i think
14:34:11 <hpc> > let zero :: Monoid m => m; zero = mempty in (zero, zero) :: ([Int], (Maybe Char))
14:34:12 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
14:34:12 <lambdabot>    arising from a use o...
14:34:21 <hpc> > let zero :: Monoid m => m; zero = mempty in (zero, zero) :: ([Int], (Maybe String))
14:34:22 <lambdabot>   ([],Nothing)
14:34:28 <hpc> it's the same reason that typechecks
14:34:47 <b_jonas> well, even if I probably won't teach programming to beginners soon, I'll still think about whether it makes sense to start with declarative programming.
14:34:59 <b_jonas> thanks for the discussion and good night to everyone.
14:35:11 <hpc> ta
14:35:26 <Kaidelong> good night b_jonas
14:37:54 <SmartViking> red_wine + haskell_tutorial = ¿profitable?
14:40:01 <donri> profit RedWine HaskellTutorial = True
14:40:26 <SmartViking> Ah, I come from python.
14:40:31 <donri> me too :)
14:40:35 <SmartViking> :)
14:41:05 <mekeor> lol; sound's like a village or a country :)
14:41:37 <donri> I have come from the land of Pythons and I come in peace. I will now sing for you the song of my people.
14:42:17 <mgsloan> the song of your people has too much dynamic range!
14:42:32 <mgsloan> but we welcome you anyway :D
14:42:36 <donri> your song just sounds like static to me
14:43:39 <Kaidelong> this is great
14:43:55 <mgsloan> only after meditating upon the static for years in far away mountain caves does the true beauty arise
14:44:08 <SmartViking> I'm looking forward to know Haskell, I've never done functional programming before apart from a little lisp, which isn't hard at all. I've already failed learning Haskell one time before, but from previous experience I know that it's failing is a part of the process :)
14:44:34 <SmartViking> s/it\is\ //
14:44:49 <SmartViking> ok, that doesn't work at all. sorry. Alcohol.
14:45:22 <SmartViking> s/it\'s\ //  <-*
14:46:20 <Tim``> @help
14:46:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:46:33 <mgsloan> In time, the way shall become clear
14:46:38 <Tim``> @list
14:46:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:47:34 <donri> SmartViking, it is typical to have "failed" two or three times first, meaning this current attempt of yours is destined to fail as well. but only for the sake of eventual success!
14:48:17 <bobzhang> hi, after I compiled and installed successfully ghc-7.3.*, where is cabal?
14:48:29 <Tim``> @help hoogle
14:48:29 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
14:48:32 <bobzhang> ./configure --prefix==~/ghc
14:48:34 <SmartViking> donri: Yeah, it's worth it anyways. AFAIK, "really" understanding the difference between imparative and functional programming is a really important milestone for any programmer
14:48:56 <donri> at least if your'e going to program in a functional language :P
14:50:29 <timbaum> > until (>10) (*2) 1
14:50:30 <lambdabot>   16
14:50:35 <cads> > :t  swap
14:50:36 <lambdabot>   <no location info>: parse error on input `:'
14:51:33 <silver> @type swap
14:51:34 <lambdabot> Not in scope: `swap'
14:51:37 <timbaum> excuse me, a few months ago, the bot made quizz questions on function signatures. Can it still do this?
14:51:58 <silver> @hoogle swap
14:51:59 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
14:51:59 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
14:52:40 <donri> SmartViking, anyway we're happy to answer questions here (hah, "we", i'm quite the beginner myself)
14:55:19 <JuanDaugherty> at least you have the decency to check yourself in use of that sense of the 1st person plural
14:56:18 <Cale> Anpheus_: I think part of the problem is that as you start evaluating the list in parallel, more and more of it builds up in memory, and the garbage collector has harder work to do
14:56:42 <cads> Blast, I've forgotten how to load haskell modules... again. I blame category theory.
14:56:48 <Cale> Anpheus_: btw, you'll want to use something like  withStrategy (parListChunk 100000 rseq)
14:56:55 <Cale> Or 10000 or something
14:57:28 <Cale> cads: import?
14:58:47 <SmartViking> donri: Thanks, I'll certainly have questions later in time about Haskell :)
14:59:01 <donri> SmartViking, i assume you know about LYAH already?
14:59:24 <kmc> beginners can answer questions for other beginners :)
14:59:31 <rferranti> i bought the book, it's in black and white. i cried.
14:59:52 <kmc> there are so many different things to learn that skill level isn't really one-dimensional, anyway
15:00:05 <kmc> so two people of comparable skill can learn a lot from each other
15:00:28 <donri> certainly, it can even help to be a beginner yourself because you can relate more easily
15:00:33 <kmc> yeah
15:00:44 <donri> and your own gotchas are more fresh in mind
15:00:44 <kmc> that's one thing i really like about this channel, there's no sense of "you must know X amount of Haskell before you give advice"
15:00:51 <kmc> at least I never felt that way when I was hanging out here as a beginner
15:00:59 <Cale> rferranti: oh really? That's kinda sad.
15:01:27 <JuanDaugherty> because it was in b&w, or were you just moved?
15:03:34 <Cale> Though when beginners start writing tutorials straight away sometimes it can result in cringing :)
15:04:19 <mroman> Yeah, but as a beginner sometimes tutorial written by beginners are much more understandable ;)
15:04:43 <Cale> mroman: Maybe, though you want to be sure that it's actually right as well ;)
15:05:03 <mroman> Just one level higher than a tutorial you have to read research paper to be able to understand what someone is talking about.
15:05:16 <mroman> (and you have to understand the research papers :D)
15:05:25 <donri> sometimes, an incorrect notion can aid learning and later be corrected
15:05:47 <Cale> Yeah, that's kind of a cute thing about Haskell, that a lot of the best explanations of things are actually in research papers.
15:05:54 <mroman> Haskell is very easy to learn (on the surface).
15:06:10 <mroman> But things can get very complex very soon.
15:06:18 <ddarius> People should stop being afraid of reading research papers.
15:06:32 <mroman> ddarius: Well.
15:06:35 <Kaidelong> ddarius: A lot of them are genuinely atrociously written
15:06:40 <Cale> So, you have to not be too scared to open them up. Most of the research papers by SPJ, for instance, have an easy section at the beginning, and then that's followed by more technical aspects.
15:06:40 <ddarius> Kaidelong: I agree.
15:06:42 <Kaidelong> I slog through them anyway
15:06:42 <mroman> Normal guys (like me) can not understand research paper.
15:06:43 <Phlogistique> the language itself is not hard, but using the language is like being back to square one, back the you were struggling to understand pointer indirection and stuff
15:06:54 <rferranti> i print em and color charts with my pencils
15:06:55 <mroman> I don't know anything about logic, higher mathematics, type theory
15:07:07 <Cale> You don't usually have to understand the whole thing in order to learn quite a bit from most of them.
15:07:07 <mroman> Zero.
15:07:07 <Kaidelong> mroman: You don't have to understand it the first read over
15:07:10 <ddarius> Kaidelong: But people can recommend good ones.  Most of Wadler's are very well written and very readable even for a relative beginner.
15:07:20 <Cale> mroman: Yeah, that's okay :)
15:07:22 <mroman> Kaidelong: But you need some pre-knowledge to understand research papers.
15:07:34 <ddarius> mroman: No, you are assuming you do.
15:07:36 <mroman> And that pre-knowledge is far away from the knowledge of a normal guy
15:07:48 <Kaidelong> mroman: YOu can actually pick up that pre-knowledge from reading the papers
15:08:00 <mroman> Kaidelong: Hardly.
15:08:03 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf -- I bet you can still understand much of this, even if you don't get the bit about formal semantics.
15:08:11 <Kaidelong> Conal used denotative semantics notation in one of his papers and from the context I was able to learn a bit of that notation
15:08:17 <mroman> Cale: That paper, yes.
15:08:29 <Cale> :)
15:08:30 <ddarius> mroman: Certainly many, probably most, research papers require a good amount of specialized knowledge, but that doesn't mean all of them do.
15:08:35 <donri> i don't have the attention span to read research papers
15:08:42 <donri> but i've skimmed many
15:08:43 <mroman> ddarius: Of course.
15:08:55 <donri> like arrows and hxt
15:09:09 <ddarius> donri: They are usually less than 15 pages and that's counting abstract and bibliography and those atrocious sections that just tell you what every other section has.
15:09:12 <mroman> arrows. I still don't understand them.
15:09:25 <Cale> mroman: Do you already understand monads?
15:09:27 <Kaidelong> mroman: do you understand Category?
15:10:00 <donri> i eventually realized i didn't need to understand arrows fully to use them (with arrow notation)
15:10:19 <Kaidelong> anyway Arrow just adds two concepts to category
15:10:23 <Phlogistique> I have the intuitive and vague idea that arrows are the continuous versions of monads, which are discrete
15:10:33 <Cale> mroman: A prime motivation for Arrow comes from the fact that with a monad, whenever you have x >>= f, the f is completely opaque, because it is a function, and the only way you can inspect functions in Haskell is to apply them
15:10:39 <mroman> Cale: Not really @Monads
15:10:42 <mroman> I know how to use them
15:10:50 <Kaidelong> the ability to turn aribitrary functions into arrows and some stuff for tuples
15:10:51 <mroman> like the IO Monad, CGI Monad, State Monad
15:11:00 <mroman> but I wouldn't be able to write a state monad myself.
15:11:10 <Cale> mroman: With arrows, you have a combiner f >>> g where f and g are not necessarily functions, but instead are values of a type that you have some control over.
15:11:13 <Kaidelong> the state monad is actually pretty simple to write
15:11:26 <dgpratt> besides going back to school, how can I gain a good understanding of formal logic systems?
15:11:30 <Cale> and so it becomes possible at least in part to inspect computations before carrying them out and perform optimisations at runtime
15:12:09 <Kaidelong> dgpratt: Which systems to you want to cover?
15:12:10 <Cale> dgpratt: If you want to approach them in a computer sciency way, I'd say start with Types and Programming Languages (TaPL) by Pierce.
15:12:10 <donri> monadic bind (>>=) is much like functor (fmap) except the mapped function produce a value of the same type as the value it is mapped over
15:12:42 <Cale> dgpratt: and then when you get a book on mathematical logic proper, you'll see that the notation is all the same as the notation for type theory, pretty much :)
15:13:06 <dgpratt> Cale: I'll check that out, thanks
15:13:26 <ousado> dgpratt: it's the coolest book ever
15:13:37 <ousado> dgpratt: examples in ocaml
15:13:52 <Cale> Yeah, that's the only problem I have with it ;)
15:14:08 <Cale> It would be nicer if the examples were in Haskell and didn't abuse exceptions quite so much ;)
15:14:08 * ddarius thinks going back to school would be an extremely inefficient and possibly ineffective method of developing an understanding of formal logic systems.
15:14:09 <donri> hey, is (fmap return . f $ x == x >>= f) a law?
15:14:20 <ousado> aren't there haskell version(s) too?
15:14:43 <ddarius> donri: No.
15:14:43 <mroman> I'm still at school.
15:14:44 <donri> uh, + some parenthesis
15:14:44 <ousado> I think I saw them when searching for the code
15:14:48 <Cale> donri: does that typecheck?
15:14:50 <dgpratt> Kaidelong: my present motivation is that I'm reading this: http://www.usingz.com/text/online/index.html and wishing for a more...in depth coverage of the topics therein
15:14:53 <mroman> But school is inefficient anyway ;)
15:15:05 <Cale> :t \f x -> fmap return . f $ x
15:15:06 <lambdabot> forall a (m :: * -> *) (f :: * -> *) a1. (Monad m, Functor f) => (a1 -> f a) -> a1 -> f (m a)
15:15:07 <donri> fmap (return . f) x
15:15:12 <Cale> :t \f x -> x >>= f
15:15:12 <mroman> Doesn't teach you what you really wanna know, doesn't teach you in the pace you want to learn.
15:15:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
15:15:21 <Kaidelong> okay, I had a book I could recommend on fuzzy and multivalent logic systems
15:15:21 <Cale> they're not the same type
15:15:30 <Kaidelong> but that doesn't seem to be what you want to cover
15:15:36 <donri> i meant fmap (return . f) x
15:15:38 <mroman> It's like prison, except you get a diploma.
15:15:49 <mroman> A useful diploma ;)
15:15:50 <ddarius> mroman: And there are a lot more attractive women.
15:15:54 <Cale> mroman: Well, that's sad. I can't say I felt that way about my university.
15:16:10 <ion> @type \f x -> fmap (return . f) x
15:16:11 <lambdabot> forall a (m :: * -> *) a1 (f :: * -> *). (Monad m, Functor f) => (a1 -> a) -> f a1 -> f (m a)
15:16:15 <mroman> I'm not exactly at a university.
15:16:17 <donri> oh wait i meant return . fmap $ x, didn't i
15:16:27 <mroman> More like a technical college of applied siences.
15:16:34 <ddarius> donri: It's the right side you need to worry about.
15:16:36 <mroman> *sciences
15:16:40 <ddarius> You can't implement (>>=) with just fmap.
15:17:07 <donri> ddarius, the point was that for a certain case of fmap with return, they're the same?
15:17:25 <Kaidelong> are they?
15:17:34 <Cale> donri: x >>= f = join (fmap f x)
15:17:36 <donri> or am i thinking backwards
15:17:52 <ddarius> donri: Again, you have to fiddle with the right hand side or else that either doesn't make sense, or gives a definition of (>>=) in terms of just fmap and return, which is impossible.
15:17:53 <Kaidelong> @ty (join .) . fmap
15:17:54 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
15:18:08 <shi> hi all!
15:18:17 <Cale> It's impossible to construct >>= or join with just return and fmap
15:18:36 <Cale> because there's no way to reduce the number of occurrences of the functor in your type if you have only return and fmap
15:18:46 <donri> x >>= return . f == fmap f x ?
15:18:50 <ion> fmap f x ≡ return . f =<< x
15:18:54 <Cale> fmap keeps it the same, and return increases it
15:19:15 <Cale> But join reduces it, and join can be written as (\x -> x >>= id)
15:19:25 <Cale> (so >>= can reduce it as well)
15:19:43 <donri> yes, i do see my error
15:19:47 <donri> i was brainfarting so to speak
15:19:51 <Kaidelong> (>>=) = (join .) . fmap
15:19:58 <donri> but does the revised version hold?
15:20:06 <Cale> Which one?
15:20:12 <donri> x >>= return . f == fmap f x
15:20:16 <Cale> yes
15:20:22 <donri> that's a law?
15:20:22 <ddarius> @src liftM
15:20:22 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
15:20:30 <ddarius> @. @undo @src liftM
15:20:31 <lambdabot> Plugin `compose' failed with: Unknown command: "@undo"
15:20:31 <Cale> yes
15:20:41 <donri> cool, that's what i meant :D
15:20:42 <ddarius> @. @redo @src liftM
15:20:42 <lambdabot> Plugin `compose' failed with: Unknown command: "@redo"
15:20:43 <donri> thanks
15:20:46 <mroman> The problem is, if you learn stuff at home in your free time.
15:20:50 <mroman> You don't get a diploma.
15:20:59 <ion> return . f =<< x = join (fmap (return . f) x)
15:21:05 <ddarius> mroman: Don't worry.  CS diplomas aren't worth anything anyway.
15:21:12 <Cale> mroman: That's true, but diplomas are only so useful.
15:21:14 <donri> but you can buy diplomas on the internets right
15:21:19 <ddarius> donri: Yes.
15:21:29 <mroman> so you have to go to school (3 years) to learn, what you already mostly know
15:21:37 <mroman> just to get the formalities to study ,what you actually wanted.
15:22:05 <Cale> To the extent I think that if you really could learn as effectively at home, then you should do so, because it's not worth the price for just the piece of paper.
15:22:09 <ddarius> mroman: Just start writing research papers and getting them published in the field you are interested in and start collaborating with people in that field.
15:22:09 <donri> @check \x -> x >>= return . f == fmap f x
15:22:10 <lambdabot>   Couldn't match expected type `a -> a1 -> b'
15:22:17 <mroman> It's like that
15:22:21 <Cale> But most universities are actually really helpful...
15:22:23 <donri> @check \x -> (x >>= return . f) == fmap f x
15:22:24 <lambdabot>   No instances for (Test.QuickCheck.Arbitrary (m a),
15:22:24 <lambdabot>                    GHC.S...
15:22:36 <Cale> Well, I have a sample size of 1, so I really shouldn't say that.
15:22:42 <donri> @check \x -> (x >>= return . f) == fmap f x :: Maybe a
15:22:43 <Cale> But it seems that way :)
15:22:43 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
15:22:45 <mroman> You're given a problem and you have to solve it in java (yes, java)
15:22:59 <mroman> But you are actually not allowed to use your full knowledge.
15:23:16 <mroman> like using Lists (because Lists are next semester)
15:23:17 <ion> @type \f x -> join (fmap (return . f) x)
15:23:18 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => (a1 -> a) -> m a1 -> m a
15:23:27 <Cale> I only took 2 CS courses at university though. I studied pure mathematics.
15:23:58 <Cale> (CS courses cost more and you had to ask permission from the dean to take more than 2 of them, so I couldn't be bothered)
15:24:00 * ddarius suggests, if you are going to get a degree, get it in something other than CS.
15:24:08 <mroman> and that just reminds me of kindergarden :)
15:24:17 <hpc> Cale: you predate CS?
15:24:24 <Cale> hpc: ?
15:24:26 <hpc> (CS as a mainstream degree rather)
15:24:29 <dgpratt> having only the briefest of encounters with higher education, this is something I think about not infrequently
15:24:34 <ddarius> Cale is not that old.
15:24:52 <Cale> hpc: The BCS was introduced when I was in 3rd year at UW, iirc.
15:24:58 * ddarius should go meet Cale in person some time.
15:25:03 <Cale> But there was still BMath in CS
15:25:21 <Cale> (which is the real thing you should take unless you were getting a double degree with a science or something)
15:25:46 <Cale> My degree is a BMath in pure mathematics.
15:25:54 <mgsloan> university of washington?
15:25:59 <Cale> Waterloo
15:26:13 <mgsloan> gotcha, I'm at UW
15:26:21 <ddarius> Cale is a Canuck.
15:26:31 <mroman> I'd like to study theoretical computer science and not being teached "Java for dummies" or "How to use the input-Tag in HTML5" (because if I wouldn't already know that, I could just look that up online. I don't need a course for that)
15:26:40 <ion> Is waterloo a toilet?
15:26:40 <mgsloan> :D
15:26:48 <Cale> heh
15:26:48 <mroman> but sadly, there's no way to study that directly.
15:27:02 <ddarius> mroman: Go to a different school.
15:27:09 <hpc> mroman: the 400-level CS courses are pretty good here
15:27:10 <mroman> Not an option.
15:27:13 <mgsloan> I'd agree to getting a degree in something other than CS.  The dept is great, but its mostly just sucked motivation from my autodidactism :/
15:27:15 <hpc> and most of the 300s too
15:27:20 <MatrixFrog> and/or complain to your current school, that what they're calling "CS" is not CS
15:27:21 * hackagebot effects 0 - Computational Effects  http://hackage.haskell.org/package/effects-0 (SjoerdVisscher)
15:27:23 <ddarius> mroman: Then save your money and spend it elsewise.
15:27:35 <MatrixFrog> a version 0? :)
15:27:41 <ion> matrixfrog: Why not?
15:27:41 <MatrixFrog> not even like, 0.0.0.1
15:27:42 <dgpratt> although I've learned quite a lot 'on my own', I find there are gaps in my knowledge that are hard to fill
15:27:51 <Cale> I like that
15:27:56 <ion> matrixfrog: Or 0.0.0.0.0.0.1
15:27:57 <dgpratt> such as formal logic systems :)
15:27:59 <mroman> Studying is actually pretty cheap here ;)
15:28:02 <MatrixFrog> ion: if it's what mroman described, that's not really CS
15:28:02 <Cale> I wonder if hackage accepts negative version numbers?
15:28:02 <mgsloan> I should have done math instead
15:28:03 <mroman> 600 bucks a semester or so.
15:28:05 <MatrixFrog> it's software engineering
15:28:11 <Cale> You could start at -30 and work your way down to 0
15:28:17 <Cale> or up :)
15:28:17 <mroman> the state pays the rest.
15:28:24 <sjoerd_visscher> I did get a 500 Internal Server Error when uploading it
15:28:24 <ddarius> dgpratt: That's probably one of the easiest things to learn online or from books readily available.
15:28:24 <ion> matrixfrog: I was referring to the version number.
15:28:42 <MatrixFrog> ion: oh i see. yeah, no reason not to use 0, just amusing
15:28:59 <MatrixFrog> if there's one thing we've learned from mozilla, it's that people can get way too worked up about version numbers
15:29:11 <Cale> MatrixFrog: hah
15:29:24 <dgpratt> ddarius: don't be coy! where are these resources you speak of?
15:29:25 <hpc> i thought we learned that "version inflation makes authoring plugins hard"
15:29:26 <Cale> MatrixFrog: Yeah, I don't understand what's going on with Firefox's version number
15:29:27 <MatrixFrog> well and apple actually
15:29:39 <MatrixFrog> cale: it goes up by 1 every 6 weeks
15:29:40 <byorgey> sjoerd_visscher: oooh, neat
15:29:48 <Cale> MatrixFrog: Pretty soon it'll be OVER 9000
15:29:50 <ddarius> dgpratt: TAPL was already mentioned.
15:30:03 <MatrixFrog> people were super disappointed that apple announced the iphone 4s instead of the iphone 5
15:30:07 <sjoerd_visscher> byorgey: thanks!
15:30:16 <MatrixFrog> if it had been called "5" but with the same features, i think you'd have heard less disappointment
15:30:29 <ddarius> From there you should have no problem whatsoever moving into research papers or reading things like "Lectures on the Curry-Howard Isomorphism" which has some great exercises and is nicely detailed.
15:30:47 <Cale> Does anyone know a good introductory book on model theory to recommend to people?
15:30:51 <byorgey> sjoerd_visscher: I looked at eff a while back, I'm glad to see the cool ideas ported to Haskell
15:30:56 <Cale> I didn't have a textbook for the course I took.
15:31:00 <MatrixFrog> cale: and when it's over 9000 it will still be just a number
15:31:06 <Cale> MatrixFrog: indeed
15:31:38 <Cale> MatrixFrog: They should try to make it converge to pi^2
15:31:41 <ddarius> Cale: I think all my original model theory experience came from just general formal logic texts.
15:31:47 <dgpratt> ddarius: you mentioned 'online' resources...anything you'd recommend?
15:32:11 <ion> Imaginary version numbers are great.
15:32:13 <sjoerd_visscher> byorgey: It's not as cool as Eff, the regular limits of an EDSL vs. a purpose built language apply
15:32:44 <hpc> ion: a version number that rotates a unit vector through the complex plane?
15:33:04 <Cale> Whenever online mathematics textbooks come up, I sorta feel obligated to mention http://www.indiana.edu/~mathwz/PRbook.pdf even if it has nothing to do with the topics being discussed. It's a really good free textbook focusing more on the measure theory side of real analysis.
15:33:12 <sjoerd_visscher> byorgey: see https://github.com/sjoerdvisscher/effects/blob/master/examples.hs how it turned out
15:33:26 <Cale> At least, I found it quite helpful when I was taking a course on measures.
15:34:15 <byorgey> sjoerd_visscher: sure
15:34:20 <byorgey> sjoerd_visscher: thanks, I'll take a look
15:34:42 <ion> hpc: That would be cool.
15:35:10 <ion> The program is finished and bugfree when you reach a full circle.
15:36:38 <donri> i find it confusing how (>>) is often said to "throw away" the left-hand value, even though it depends on both (e.g. Nothing >> Just 5)
15:36:55 <Cale> donri: It throws away the *result* of that action.
15:37:00 <Cale> It still executes it.
15:37:16 <hpc> > (Just 4 >> Just 5) -- the 4 is what gets thrown away
15:37:17 <lambdabot>   Just 5
15:37:23 <donri> yea, i understand the difference; just noting that it's been a gotcha in the past
15:38:03 <donri> the 4 is not used to compute the 5, but the selection of 5 depends on the Just 4 not being Nothing
15:38:09 <ddarius> dgpratt: Lectures on the Curry-Howard Isomorphism is online.  Give me more time to find some other links.
15:38:18 <ion> Awesome, there’s a place called La Butte du Lion in Watertoilet, Belgium..
15:38:28 <dgpratt> ddarius: ok, thanks
15:38:30 <ddarius> For more introductory material.  That said, TAPL is very concentrated and highly recommended by others.
15:38:53 <ddarius> dgpratt: Probably most things you'd find for "introduction to formal logic" will be useful enough.
15:39:27 <donri> does do-notation without <- expand to >>?
15:39:56 <MatrixFrog> donri, yes, i think so
15:40:03 <ben> Is there a way to get do-notation to expand to >>==?
15:40:10 <MatrixFrog> donri: there's a good section in rwh on how to desugar do notation
15:40:23 <donri> ok thanks
15:40:25 <MatrixFrog> ben: do you mean >>=?
15:40:44 <ben> No, that's fairly trivial
15:40:56 <donri> @hoogle (>>==)
15:40:56 <lambdabot> No results found
15:41:05 <MatrixFrog> http://book.realworldhaskell.org/read/monads.html#monads.do
15:41:09 <aavogt> ben: you can -XNoImplicitPrelude, then define (>>=) = (>>==)
15:41:11 <Cale> ben: are you talking about the funny parametrised monads thing?
15:41:27 <MatrixFrog> @hoogle funny parametrised monads thing
15:41:28 <lambdabot> No results found
15:41:29 <ben> I'm thinking of Data.Enumerator's >>==
15:41:41 <ben> which probably is a special case of funny parametrised monads
15:41:55 <hpc> type-indexed monads?
15:42:00 <donri> aavogt, is that different from explicit prelude import?
15:42:12 <ddarius> dgpratt: I believe I read this almost a decade ago and found it useful at the time.  It's mostly basic set theory.
15:42:15 <donri> aka. import Prelude ()
15:42:15 <ddarius> dgpratt: http://www.trillia.com/zakon1.html
15:42:16 <ben> but lead me to some fairly awkward construction involving Control.Monad.Transformer.lift before I figured out where to hide the >>==
15:42:18 <aavogt> donri: yes
15:42:34 <hpc> 'import Prelude ()' still gives you instances
15:42:35 <MatrixFrog> http://hackage.haskell.org/packages/archive/enumerator/0.4.14/doc/html/Data-Enumerator.html#v:-62--62--61--61-
15:43:15 <aavogt> and "import Prelude ()" makes do notation still use the methods in class Prelude.Monad
15:43:45 <ben> Cale: Is there some discussion on a generic parametrised monad >>= to replace default >>=?
15:44:10 <hpc> what is this parameterized monad stuff?
15:44:29 <ddarius> dgpratt: I found this list (which was previously elsewhere) rather enjoyable: http://www.trillia.com/online-math/index.html
15:44:50 <hpc> oh, i see now
15:44:51 <aavogt> with parameterized monads you can write something like     modify (\x -> case x of 'a' -> "a")
15:45:16 <hpc> :t modify
15:45:16 <dgpratt> ddarius: checking those out, thanks!
15:45:17 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
15:46:01 <ddarius> dgpratt: This section has a whole subsection of online mathematical logic and set theory texts: http://www.trillia.com/online-math/general-mathematics.html  I don't know how good they are.
15:46:40 <ddarius> dgpratt: Also, if you get a chance, read "Proofs and Refutations" by Lakatos.  It's an enjoyable, tiny book.
15:47:08 <dgpratt> ddarius: ok, I'll see if I can get that
15:53:34 <roconnor> @google france country code
15:53:35 <lambdabot> http://www.howtocallabroad.com/france/
15:53:36 <lambdabot> Title: How to call France: country code, area codes, phone books
15:55:32 <mgsloan> Hello! Has anyone seen any work on edit-and-continue in haskell?
15:56:08 <Cale> ben: Parametrised monads are sufficiently uncommon that I don't think that'll happen. However, we may want a monad class which has an associated constraint in the future...
15:56:27 <Cale> (With a default of () of course)
15:57:05 <mgsloan> seems like it'd be a program transformation that'd replace elements of the code that should be editable with "unsafePerformIO $ readIORef _editable_foo"
15:57:10 <Cale> mgsloan: What is that?
15:57:21 <hpc> mgsloan: you mean the way in lisp interpreters you can stop when it throws an error, edit some values, then continue?
15:57:26 <Cale> (sounds extremely dangerous?)
15:57:32 <mgsloan> it is extremely dangerous
15:57:34 <mgsloan> but useful :)
15:57:39 <hpc> Cale: it's as dangerous as the rest of CL :P
15:57:45 <mgsloan> it's where you can edit your code while the program is running
15:57:53 <mgsloan> as long as the types stay the same, it should be /OK/
15:57:53 <Cale> Terrible :P
15:58:17 <mgsloan> haha, I think it's very useful
15:58:18 <hpc> mgsloan: as long as the types are staying the same, why not use a higher-order function? :P
15:58:38 <hpc> @quote lisp.*static
15:58:38 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
15:58:38 <lambdabot> true functional programming), and you've got haskell
15:58:40 <Cale> That means your program can be in a state which is actually unattainable from running it from the beginning, making all further testing useless until you restart it.
15:58:42 <mgsloan> hpc: I did consider plumbing the ref through params
15:58:49 <hpc> @quote lisp.*static analysis
15:58:49 <lambdabot> No quotes for this person. You type like i drive.
15:59:01 <mgsloan> Cale - yup, it's a use-at-your-own-risk tool
15:59:09 <hpc> @quote static analysis
15:59:09 <lambdabot> No quotes for this person. You type like i drive.
15:59:10 <ddarius> Cale: Image-based systems are far worse than that.
15:59:12 <hpc> pah
15:59:23 <mgsloan> It'd be very interesting to make datatypes editable as well
15:59:32 <ddarius> mgsloan: There is nothing wrong with retypechecking the system thus allowing type changes as well.
15:59:58 <mgsloan> it'd instantiate a new ADT, and have defaulting conversions from the old
16:00:02 <hpc> ddarius: except the part where it doesn't work on compiled code
16:00:10 <hpc> totally defeating the point of GHC's power :P
16:00:22 <ddarius> hpc: Why would it not work on compiled code?
16:00:27 <mgsloan> ddarius - right, but you couldn't have type changes at the place where the "this can be edited" IORef was inserted
16:00:57 <Kaidelong> ddarius: type erasure?
16:01:37 <hpc> once you have a binary, any resemblance to source code is pretty much gone
16:01:49 <hpc> from various strictness checking, optimization, etc
16:01:50 <Cale> ddarius: Well, at least with image-based systems you have no expectation that the system will ever need to be restarted.
16:02:12 <Cale> ddarius: (which sucks, but I guess that's what they've committed to)
16:03:23 <ddarius> It doesn't make sense to "restart" an image-based system.  However, you can readily get into situations where there isn't a way to even actually serialize the "code."  You -have- to use the image.
16:03:45 <ddarius> It is interesting, though, that you can have code that lives forever.
16:04:20 <mgsloan> well, I'm not going to try to do this anytime soon, but it's on the far-out portion of the agenda for the tool I'm working on
16:05:16 <jmcarthur> Cale: funny that you say that about parameterized monads. i seem to want them quite frequently...
16:05:43 <jmcarthur> actually, i'm never sure if i'm talking about parameterized monads or indexed monads... or whether people even commonly say there is a difference
16:06:10 <ddarius> Neither are well-defined.  (Or rather there are multiple potential "well-definitions.")
16:06:14 <mgsloan> instrumenting to allow for interposing to intercept / modify values like hpc's suggestion comes first
16:06:35 <dylukes> Is there a good way to determine whether a recursive function terminates in all cases?
16:06:45 <dylukes> I have a recursive definition which seems to terminate for 0-9... but not for 10 :\.
16:06:50 <ddarius> dylukes: Yes, you just have to solve the halting problem first.
16:06:56 <dylukes> Oh, wonderful.
16:07:00 <dylukes> Well I was hoping this was simple enough.
16:07:03 <jmcarthur> there is no general method, but for specific cases it is possible
16:07:07 <dylukes> f' 1 = 4f' n = 3 * f (((2*n + 2) `mod` 11) - 1)
16:07:09 <dylukes> er
16:07:13 <dylukes> f 1 = 4
16:07:14 <dylukes> f n = 3 * f (((2*n + 2) `mod` 11) - 1)
16:07:16 <dylukes> its pretty simple.
16:07:21 <dylukes> For 10 it does not terminate.
16:07:24 <dylukes> It seems.
16:07:41 <dylukes> oh, probably because of them negative numbers :)
16:08:23 <ddarius> f 1 = (); f n | even n = f (n `div` 2) | otherwise = f(3*n+1)  simple enough
16:08:41 <hpc> dylukes: f 10 = 3 * f (22 `mod` 11) - 1
16:08:45 <dylukes> what?
16:08:49 <hpc>  = 3 * f (-1)
16:09:02 <hpc>  = 3 * f (0 `mod` 11) - 1
16:09:11 <hpc>  = 3 * f ( f (...
16:09:15 <dylukes> yeah, I see the problem.
16:09:45 <dylukes> I'll add an exception case for 2 * n + 2 `mod` 11 being 0
16:09:56 <dylukes> just to make this slightly easier :P
16:11:22 <dylukes> hpc: https://gist.github.com/1290302
16:11:27 <dylukes> this seem like a reasonable approach for the moment
16:11:28 <dylukes> ?
16:12:54 <dylukes> actually
16:13:07 <dylukes> I could just factor this out into my own version of `mod` that excepts on a zero result.
16:17:06 <shachaf> dylukes: Exceptions are evil.
16:17:19 <dylukes> Yes... I know :<
16:17:42 <shachaf> Maybe isn't evil.
16:18:27 <tactics> > init [1,2,3]
16:18:28 <lambdabot>   [1,2]
16:18:30 <tactics> > init []
16:18:31 <lambdabot>   *Exception: Prelude.init: empty list
16:20:32 <dylukes> :\
16:20:39 <dylukes> trying to solve these with Haskell
16:20:40 <dylukes> http://i.imgur.com/JHGle.png
16:20:56 <dylukes> https://gist.github.com/1290311
16:20:59 <shachaf> dylukes: Where are those from?
16:21:07 <shachaf> I looks like the sort of thing you're supposed to do wih pencil-and-paper.
16:21:09 <dylukes> idk, they were linked earlier
16:21:43 <dylukes> brb
16:21:55 <dylukes> shachaf: yeah, except the term expansions would take forever >_>
16:22:02 <dylukes> I'm trying to brute force
16:22:05 <dylukes> but there must be a cleaner way
16:22:28 <shachaf> "Calculators, log tables and other aids are not permitted."
16:23:02 <dylukes> meh
16:23:04 <dylukes> >.>
16:23:08 <dylukes> but yeah
16:23:14 <dylukes> g 4 isn't terminating any time soon
16:25:15 <MatrixFrog> s/two/too
16:29:00 <eichi> hello ;) I know the function words [String] to get a list of words. but how can I count the number of "mywords" which are in the list? Something like counting elements from list. cant find anything like tha
16:29:12 <kmc> :t length
16:29:13 <lambdabot> forall a. [a] -> Int
16:29:21 <kmc> > length (words "like this eichi")
16:29:22 <lambdabot>   3
16:29:46 <XWisdom> I'm trying to return all values from a trie into a list, but can't figure the syntax for what to do with the branch?
16:29:59 <XWisdom> valuesTrie TrieBranch =
16:30:31 <eichi> yeah but I want something like this:   count "eichi" ["test","what","eichi","not","eichi"] with output 2 because there are 2 times "eichi" in it
16:31:07 <ion> length . filter (== "eichi") . words
16:31:36 <shachaf> XWisdom: Chalmers? :-)
16:32:05 <XWisdom> No, Borås :-)
16:32:16 <shachaf> Oh.
16:32:22 * hackagebot epass 0.2.1 - Baisc, Erlang-like message passing supporting sockets.  http://hackage.haskell.org/package/epass-0.2.1 (AndreasBaldeau)
16:32:36 <shachaf> Someone was here yesterday with the same question and someone mentioned Chalmers, I think.
16:32:46 <XWisdom> oh
16:33:07 <XWisdom> yes, seems like Haskell is very popular in swedish colleges right now :-)
16:33:24 <shachaf> Anyway, the syntax for pattern-matching is the same as the syntax for application.
16:33:40 <shachaf> What you're typing is the same as saying "f Just = ..." -- do you see why that wouldn't work?
16:34:49 <XWisdom> so, something like valueTrie TrieBranch (x, y) = valueTrie y
16:34:54 <XWisdom> ?
16:35:12 <dylukes> shachaf: ugh
16:35:30 <dylukes> it seems g 4 is non-terminating in some weird way.
16:35:55 <dylukes> Is there any way, a-la-lisp
16:35:59 <dylukes> to actually watch the term expansions?
16:36:02 <shachaf> dylukes: Write "_|_". Done.
16:36:03 <dylukes> or step through them?
16:36:10 <shachaf> Maybe the ghci debugger can do it.
16:36:18 <rotflcopter> can someone tell me how to make ripemd-320 function work?
16:36:18 <shachaf> Or you can write your own mini-interpreter to do it. :-)
16:36:21 <dylukes> shachaf: yeah except the result of g(4) is supposed to be "3"
16:36:27 <rotflcopter> in linux
16:36:51 <dylukes> I can follow it backwards a bit... that entire right bit needs to be 1 then...
16:36:54 <eichi> ion: thanks!
16:36:55 <dylukes> so the inside needs to be 2... etc
16:37:59 <dylukes> eek
16:38:19 <monochrom> I have finished modifying my xml processor so that certain elements in the input xml contain #! scripts, and my processor will run those scripts to obtain more xml to include in the output. Except the input xml contains a million such scripts, and they are all #! /usr/bin/env runghc, so now the whole thing takes forever. :)
16:38:21 <dylukes> ill go do elsewhere
16:38:58 <dylukes> monochrom: can you parallelize D:?
16:39:15 <monochrom> ah, I could, but I have only 2 cores anyway
16:39:26 <monochrom> would want to reserve 1 core for IRC!
16:39:40 <dylukes> heh
16:39:49 <dylukes> it'd still cut the runtime by almost half
16:40:44 <monochrom> I currently use HXT which is inherently sequential. a bit hard to forkIO it.
16:41:02 <dylukes> no...
16:41:22 <aristid> monochrom: xml-enumerator!
16:41:24 <dylukes> Can you take the entire XML file, build a Map of path to the #! scripts to the scripts themselves (or IO actions that run them)
16:41:35 <dylukes> and then parMapIO over the map or something
16:41:39 <dylukes> (using a pool)
16:42:00 <dylukes> ?
16:43:10 <monochrom> I don't know. not a priority now.
16:59:06 <monochrom> the output is http://www.vex.net/~trebla/haskell/lazy.xhtml .
16:59:48 <monochrom> the input is http://www.vex.net/~trebla/haskell/src/lazy.xml , that's what I write by hand and how I avoid becoming insane. you can also find IEG.hs in that directory
17:00:07 <monochrom> so, marvel at the reams after reams of SVG!
17:00:54 <monochrom> scripts are contained in <extern> ... </extern> elements in the input file
17:01:03 <brunobpc> hello! is anyone available to answer me a question about haskell i/o system?
17:01:11 <monochrom> there are likely 10 of them
17:01:30 <Axman6> brunobpc: not if you don't ask your questions first ;)
17:01:32 <ddarius> monochrom: Use xml combinators in Haskell (or some kind of xml-template thing for Haskell) so that you just have a source file.
17:02:16 <monochrom> use xml combinators in haskell => a lot of \" and generally a lot of unreadable \'s
17:03:13 <ddarius> monochrom: Hence template or a simple quasiquoter.
17:03:27 <monochrom> well, actually, most of the \'s are readable. but unwritable. too easy to get them wrong.
17:05:32 <brunobpc> I have been reading the "learn you a haskell" tutorial, and I'm stuck at this part of the text: "Well, when we evaluate an I/O action in GHCI, it's performed and then its result is printed out, unless that result is (), in which case it's not printed out. That's why evaluating putStrLn "hehe" in GHCI just prints out hehe (because the contained result in putStrLn "hehe" is ()). But when we do getLine in GHCI, the result of that I/O action
17:05:32 <brunobpc>  is printed out, because getLine has a type of IO String."
17:05:37 <brunobpc> I really didn't get what he meant with "result" and didn't understand why the result contained in putStrLn "hehe" is ().
17:06:13 <kmc> it's not "contained in"
17:06:24 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO is a good introduction
17:06:32 <shachaf> Also, it's not really true that evaluating an IO action in ghci performs it.
17:06:47 <shachaf> I guess ghci is kind of strange about that.
17:06:49 <Axman6> :t putStrLn
17:06:50 <lambdabot> String -> IO ()
17:06:56 <brunobpc> hmm
17:06:58 <Axman6> :t getLine
17:06:59 <lambdabot> IO String
17:07:05 <kmc> putStrLn is a function that takes a string and returns an imperative program
17:07:13 <kmc> an imperative program as a first-class value, aka an IO action
17:07:30 <kmc> applying the function does not perform any IO, it just constructs this IO action
17:07:48 <kmc> when the action is actually executed, it can produce a value to be used by other Haskell code
17:07:49 <monochrom> ghci type-checks then type-specialises then evaluate then execute then print. it can be misleading.
17:08:10 <kmc> putStrLn has no useful result to produce, so it returns (), which is the only value in the type ()
17:08:14 <kmc> :t ()
17:08:15 <lambdabot> ()
17:08:19 <Axman6> kmc: i'm not sure that's a useful explanation for someone who's just learning haskell (sometimes lying is ok)
17:08:21 <ddarius> monochrom: TCTSEEP loop doesn't have the same ring.
17:08:23 <monochrom> your learning may be sped up twice if you delete ghci
17:08:31 <Axman6> ok, that's better, heh
17:08:52 <Axman6> brunobpc: do you know any other programming languages?
17:09:02 <kmc> Axman6, which lie would you prefer?
17:09:13 <brunobpc> Got it! by the way, I'll read that introduction someone sent me here
17:09:21 <brunobpc> yes, intermediate C..
17:09:23 <kmc> i think the educational value of lies is overstated
17:09:40 <Axman6> kmc: sure, btu they can bootstrap learning
17:09:42 * ddarius violently agrees with kmc here.
17:09:43 <kmc> you have to keep inventing new bogus rules to make the lie square with observed reality
17:09:43 <Axman6> but*
17:10:13 <kmc> the truth about IO is not very complicated
17:10:31 <kmc> it may be a tough pill to swallow but it's not like it takes hours to explain
17:10:42 <Axman6> sure, but it's quite complicated to someone who's used to languages where you can call printf anywhere you want
17:10:55 <kmc> yes, and pretending that Haskell is one of those languages will not get you very far
17:11:06 <mauke> I don't think it's complicated
17:11:06 <kmc> (i think i did a decent job up there in a handful of lines, and Cale's article is a page or two long)
17:11:14 <mauke> at least I didn't think it was when I learned about it
17:11:44 <kmc> when I was learning I had this "impure functions", "taint bit" idea of IO
17:11:47 <kmc> and I was constantly confused
17:12:09 <kmc> and would cargo cult move things between "let", "do", add "return", whatever made the type checker happy
17:12:21 <kmc> and then I got the IO actions idea and it all made sense
17:12:34 <Axman6> fair enough
17:12:38 <kmc> I do not think this is an example of "bootstrapping"
17:13:01 <ion> @faq Can Haskell have a taint bit?
17:13:02 <lambdabot> The answer is: Yes! Haskell can do that.
17:14:08 <kmc> we have the good fortune that most people learning Haskell are not only okay with the fact that it's different and weird, but actively seek it out for this reason
17:15:15 <gwern> @quote Neo
17:15:16 <lambdabot> gwern says: Unfortunately Neo, no one can be *told* what the Monad is.
17:15:54 <kmc> in other words they *expect* there to be points where you have to sit and think and absorb a new concept
17:16:14 <kmc> "how IO works" is one of those, and it's pretty small compared to the others
17:16:16 <ddarius> Dammit kmc, I just want to sling out web apps.
17:16:25 <kmc> you'd better use Personal Haskell Pages
17:16:27 <mauke> heh, web shooters
17:16:34 <kmc> haha
17:16:37 <kmc> was that intentional?
17:20:49 <monochrom> thank you for the great name Personal Haskell Pages. I have been looking for a better name for my xml processor!
17:21:50 <mauke> Personal Haskell Documents
17:22:00 * monochrom opens his Makefile, s/xmlrender/php/
17:22:36 <brunobpc> thank you all for your help ! :). I think I got a bit of how it works.
17:23:36 <kmc> cool :)
17:26:01 <ion> Professional Haskell Users’ Collective Knowledge
17:26:47 <kmc> that's the new name for Hackage right
17:28:02 <donri> > let 2 + 2 = 5 in 2 + 2
17:28:03 <lambdabot>   5
17:28:07 <donri> naughty
17:30:54 <mdxbhmt> @faq is it worth it?
17:30:54 <lambdabot> The answer is: Yes! Haskell can do that.
17:31:03 <aristid> > let 2 + k = 5 in k
17:31:04 <lambdabot>   k
17:31:23 <aristid> > let k + 2 = 5 in k
17:31:24 <lambdabot>   k
17:31:34 <aristid> confused
17:31:42 <parcs> you are defining +
17:31:54 <monochrom> @type k
17:31:55 <lambdabot> Expr
17:32:02 <monochrom> from the simple-reflect package
17:32:10 <monochrom> it is what enables:
17:32:18 <monochrom> > foldr (+) a [b,c,d]
17:32:19 <lambdabot>   b + (c + (d + a))
17:32:22 <monochrom> \∩/
17:32:45 <aristid> parcs: oh, of course.
17:33:15 <donri> hahaha http://ro-che.info/ccc/02.html
17:34:52 <quackquack> How do i use Network.Curl.curlGetString with the CurlWriteFunction option? why does it have so many arguments?
17:35:04 <iFire> How doing is these list of functions on GHC 7 on Windows 7?
17:35:05 <iFire> http://git-annex.branchable.com/install/#comment-87eeeabc26e66bd965bea3ca66f7140d
17:41:30 <monochrom> haha, thanks donri for the CCC!
17:46:52 <donri> monochrom, yes, it's certainly useful to learn how to really optimize the performance of a haskell program
17:47:20 <kmc> :D
17:47:48 <shachaf> @quote email.*oleg
17:47:48 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
17:47:58 <shachaf> That's not the one.
17:48:58 <aristid> @quote oleg
17:48:59 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
17:49:15 <aristid> @quote oleg
17:49:15 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
18:04:50 <Gracenotes> > let removeOne [] = [[]]; removeOne (x:xs) = xs:(map (x:) removeOne xs) in removeOne [1,2,3,4]
18:04:51 <lambdabot>   Couldn't match expected type `[[t]]'
18:04:51 <lambdabot>         against inferred type `[t] -> ...
18:05:06 <Gracenotes> > let removeOne [] = [[]]; removeOne (x:xs) = xs:(map (x:) (removeOne xs)) in removeOne [1,2,3,4]
18:05:07 <lambdabot>   [[2,3,4],[1,3,4],[1,2,4],[1,2,3],[1,2,3,4]]
18:05:50 <donri> i don't understand from [1] how (***) differs from (&&&)? [1] http://blog.romanandreg.com/post/2755301358/on-how-haskells-arrows-might-just-be-function
18:06:04 <shachaf> @ty (***)
18:06:05 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:06:06 <shachaf> @ty (&&&)
18:06:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:06:22 <Gracenotes> > let removeOne [] = []; removeOne (x:xs) = xs:(map (x:) removeOne xs) in concatMap (init . removeOne) [[0,2,3,7],[0,2,6,7],[0,4,6,7],[0,6,1,2],[0,6,1,4],[5,6,1,4]]
18:06:23 <lambdabot>   Couldn't match expected type `[[t]]'
18:06:23 <lambdabot>         against inferred type `[t] -> ...
18:06:45 <byorgey> donri: &&& runs two arrows on the same input.  *** puts two arrows together into one arrow that operates on tuples.
18:06:55 <donri> shachaf, but is the post misleading or am i misinterpreting it?
18:07:06 <byorgey> donri: also, that post is probably misleading/unhelpful
18:07:27 <shachaf> Monads are a lot like boxes, if you think about it.
18:07:32 <kmc> oh dear
18:07:35 <shachaf> But don't think too much, please.
18:07:37 <donri> i found it helpful to gain some intuition about arrows
18:07:59 <ion> > (pred &&& succ) 42
18:08:00 <lambdabot>   (41,43)
18:08:04 <ion> > (pred *** succ) (42,42)
18:08:04 <lambdabot>   (41,43)
18:08:17 <donri> ah, thanks
18:09:36 <ddarius> donri: Always the first thing you should do when you are wondering "what is different about these two things" is check the types.
18:09:39 <Gracenotes> http://ro-che.info/ccc/12.html
18:09:54 <donri> Gracenotes, that's where i got it from yes :)
18:10:49 <shachaf> What is the difference between seq and (flip const)?
18:10:58 <donri> ddarius, certainly, only in the case of arrows it's a little too abstract for me
18:11:06 <Gracenotes> :)
18:11:07 <shachaf> donri: Just let "a" be "(->)".
18:11:17 <shachaf> And there you go.
18:11:31 <kmc> better yet let it be (~>)
18:11:34 <kmc> which is actually a type variable
18:11:36 <shachaf> Of course, that's only helpful for that article, which is using all those combinators only for functions anyway.
18:12:11 <kmc> :t (***) :: (Arrow (~>)) => (b ~> c) -> (b' ~> c') -> ((b, b') ~> (c, c'))
18:12:12 <lambdabot> forall (~> :: * -> * -> *) b c b' c'. (Arrow (~>)) => (~>) b c -> (~>) b' c' -> (~>) (b, b') (c, c')
18:12:21 <ddarius> Yes.  Using (->) to explain arrows is exactly like using the Identity monad to explain monads.
18:12:29 <kmc> :t (&&&) :: (Arrow (~>)) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
18:12:30 <lambdabot> forall (~> :: * -> * -> *) b c c'. (Arrow (~>)) => (~>) b c -> (~>) b c' -> (~>) b (c, c')
18:12:42 <kmc> ddarius, except people actually use monads other than Identity
18:13:16 <donri> so how come you can use the result of an arrow application as a function, when the type signature doesn't hint at that?
18:13:28 <donri> :t pred &&& suc
18:13:29 <lambdabot> Not in scope: `suc'
18:13:32 <donri> :t pred &&& succ
18:13:33 <lambdabot> forall b. (Enum b) => b -> (b, b)
18:13:34 <shachaf> @ty undefined :: (Monad (+!), Num v') => (+!) a -> v' -> v' -> (+!) v' -- Just look at the types.
18:13:35 <lambdabot> forall (+! :: * -> *) a v'. (Num v', Monad (+!)) => (+!) a -> v' -> v' -> (+!) v'
18:13:49 <kmc> donri, you can instantiate the type variable (~>) to the concrete type constructor (->)
18:13:49 <donri> i clearly misread the signature somehow
18:13:57 <kmc> (or the type variable 'a' in the original types)
18:14:03 <shachaf> Apparently GHC doesn't support PostfixOperators for types.
18:14:03 <kmc> but look at the types i fed to lambdabot
18:14:09 <kmc> and not the ones lambdabot spit back out
18:14:17 <kmc> that was just to prove that i wasn't lying about those types
18:14:31 <ion> @type (***) `asAppliedTo` (undefined :: a -> b)
18:14:32 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
18:14:38 <ddarius> If it wasn't for lambdabot, we'd never be able to trust kmc.
18:14:43 <ion> @type (&&&) `asAppliedTo` (undefined :: a -> b)
18:14:44 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
18:14:54 <kmc> ghc -XTrustworthy kmc.hs
18:15:22 <kmc> hmm nobody has the .hs country code do they
18:17:44 <donri> ok i feel ya
18:18:14 <donri> but i still don't see how something that isn't (->) can be "passed a parameter"
18:18:48 <donri> or why it ends up being (->), rather
18:19:00 <kmc> it ends up being (->) because you passed it a parameter
18:19:02 <shachaf> It doesn't end up being (->).
18:19:11 <shachaf> Oh, well, unless you use it as (->).
18:19:13 <kmc> :t id
18:19:14 <lambdabot> forall a. a -> a
18:19:38 <donri> oh, because for (->), (->) *is* "a"
18:19:47 <donri> kinda, sorta?
18:19:53 * kmc fails to come up with compelling followup to ":t id"
18:20:22 <kmc> if you write (f x) then f must have a type like (s -> t)
18:20:32 <kmc> which is sugar for ((->) s t)
18:20:43 <ion> @type succ
18:20:44 <lambdabot> forall a. (Enum a) => a -> a
18:20:50 <ion> @type succ `asAppliedTo` 'a'
18:20:51 <lambdabot> Char -> Char
18:20:55 <ion> @type fmap
18:20:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:21:03 <ion> @type fmap `asAppliedTo` []
18:21:04 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
18:21:05 <lambdabot>     In the second argument of `asAppliedTo', namely `[]'
18:21:05 <lambdabot>     In the expression: fmap `asAppliedTo` []
18:21:09 <ion> @type fmap `asAppliedTo` ['a']
18:21:10 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
18:21:10 <lambdabot>     In the second argument of `asAppliedTo', namely `['a']'
18:21:10 <lambdabot>     In the expression: fmap `asAppliedTo` ['a']
18:21:10 <aristid> :t id `asAppliedTo` undefined
18:21:11 <kmc> so if 'f' had a more polymorphic type, it gets unified with (s -> t)
18:21:11 <lambdabot> forall t. t -> t
18:21:21 <kmc> (a s t) unified with (s t) sets a = (->)
18:21:23 <ion> Ah, stupid me.
18:21:34 <kmc> > (Left 'x') 3
18:21:34 <lambdabot>   Couldn't match expected type `t1 -> t'
18:21:34 <ion> @type fmap `asTypeIn` \fmap -> fmap undefined [undefined]
18:21:35 <lambdabot>         against inferred type `Data....
18:21:35 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:21:44 <ion> @type fmap  -- again
18:21:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:21:48 <ion> See the pattern?
18:35:05 <donri> is "flip id" defined to any standard infix operator?
18:35:26 <shachaf> No. Sometimes people call it (|>)
18:35:42 <mauke> sometimes €
18:35:51 <wavewave> :t flip id
18:35:52 <lambdabot> forall a b. a -> (a -> b) -> b
18:36:19 <shachaf> More commonly known as flip ($)
18:36:30 <wavewave> :t id
18:36:31 <lambdabot> forall a. a -> a
18:36:34 <wavewave> :t flip
18:36:35 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
18:36:39 <donri> "flip id" is what @pl gave me :)
18:36:59 <shachaf> donri: Don't listen to @pl
18:37:03 <donri> @pl \x f -> f x
18:37:03 <lambdabot> flip id
18:37:24 <wavewave> interesting.
18:37:29 <shachaf> Think for yourself, man! Fight the 47%!
18:37:41 <donri> hahaha
18:37:57 <wavewave> it's like (.) in OOP, btw.
18:38:04 <wavewave> x.f
18:38:08 <donri> yes, that's the idea
18:38:24 <donri> also see TDNR
18:38:29 <donri> @where TDNR
18:38:29 <lambdabot> I know nothing about tdnr.
18:38:34 <donri> :(
18:38:42 <donri> @google TDNR
18:38:45 <lambdabot> http://www.acronymfinder.com/TDNR.html
18:38:45 <lambdabot> Title: TDNR - Definition by AcronymFinder
18:38:51 <donri> no!
18:39:05 <byorgey> I often use (>$>) = flip id
18:39:13 <byorgey> it works well in conjunction with >>>
18:39:21 <donri> yes, i saw that in a blog post, is it your blog perhaps?
18:39:22 <wavewave> http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
18:39:25 <donri> mathlesstraveled
18:39:32 <byorgey> donri: yes, that's me
18:39:36 <donri> ohai
18:39:41 <byorgey> =)
18:39:57 <wavewave> :t >>>
18:39:57 <lambdabot> parse error on input `>>>'
18:40:05 <wavewave> :t (>>>)
18:40:06 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
18:40:19 <wavewave> :t (.)
18:40:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:40:58 <donri> wavewave, "arrows"
18:40:58 <wavewave> by the way, how is SHE-like extension in haskell going?
18:41:22 <wavewave> donri: I know.. just checked it using lambdabot.
18:42:01 <wavewave> didn't know (>>>) was defined in Category, though.
18:43:00 <wavewave> So, it was worth to check.
18:43:11 <donri> @where+ TDNR http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
18:43:11 <lambdabot> It is stored.
18:43:17 <donri> @where TDNR
18:43:18 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
18:43:21 <donri> yay
18:43:23 <wavewave> donri: great donri++
18:44:36 <wavewave> btw, I don't like to use (.) for TDNR. (.) is used for other things.
18:45:32 <wavewave> we had better use other operator for this record field accessor.
18:45:43 <donri> it's already used both for qualification and composition
18:45:49 <donri> disambiguated by whitespace
18:46:15 <donri> so i think it makes sense for tdnr because it's a form of qualification
18:46:46 <kmc> there's a huge number of symbol characters which have never been used in any published haskell code
18:47:03 <donri> but i also think that the exact syntax is the least interesting part of the proposal
18:48:18 <wavewave> different meaning by 'whitespace' can be very annoying...
18:49:43 <wavewave> I had been bitten by difference between A.x and A .  x before when I didn't understand haskell well.
18:51:10 <JoeyA> What's a nice package to use for managing IO threads such that I can start, stop, and reload workers, as well as restart a whole bunch of workers occasionally?
18:51:34 <Axman6> pool? maybe that's something else
18:51:45 <wavewave> JoeyA: have you tried to use orc ?
18:51:54 <JoeyA> No; /me looks
18:52:00 <wavewave> JoeyA: although that's different thing.
18:52:06 <kmc> by my count there's about 4700 characters you can use for Haskell operators
18:52:26 <wavewave> kmc: great count!
18:54:44 <donri> would you say that TDD in whatever form is noticably less common in haskelland compared to other camps?
18:54:50 <wavewave> JoeyA: I think that orc is different from what you are doing. but it provides simplest form of map-reduce in some sense. I often use it for some concurrent batch-job-like tasks
18:55:16 <kmc> donri, test driven development?
18:55:17 <donri> i see it used more than i thought it was used when i knew less haskell, but still
18:55:17 <donri> kmc, yes
18:55:17 <kmc> well, QuickCheck is a lot more convenient than any other test framework I've used
18:55:27 <wavewave> donri: we are doing type-driven development. seriously.  ;-)
18:55:48 <wavewave> many unit tests are what type-checkers are doing.
18:55:50 <kmc> I'd say it's quite common to sketch out the properties of your program with QuickCheck, when you have no implementation or only a naive implementation
18:55:50 <donri> it would seem haskell gets rid of many of the needs for tests
18:56:00 <donri> but not all, of course
18:56:03 <wavewave> but QuickCheck is definitely our friend.
18:56:06 <kmc> haskell gets rid of a lot of dumb tests, so you can focus on the important ones
18:56:07 <kmc> yes
18:56:11 <donri> no love for hunit then?
18:56:18 <kmc> ideally you can use type-driven and test-driven design together
18:56:22 <hpaste> “Mukesh Tiwari” pasted “Data.ByteString” at http://hpaste.org/52676
18:56:24 <kmc> of course quick-check is a type-driven library
18:56:29 <kmc> in a very specific sense
18:56:54 <wavewave> what's merit of hunit compared to QuickCheck?
18:57:06 <wavewave> just curious
18:57:16 <donri> testing impure code, for one
18:57:22 <kmc> "impure"
18:57:27 <kmc> QuickCheck can check IO actions now
18:57:32 <wavewave> I see..
18:57:34 <kmc> i used this recently, it was pretty pleasant
18:57:50 <donri> but hunit still covers other ground that quickcheck just isn't about
18:57:53 <copumpkin> in haskell, if I have the type equality GADT, and complicated functions for producing such equalities, would it make sense to add a rewrite rule that rewrites any value of an equality to (unsafeCoerce) Refl
18:57:54 <copumpkin> ?
18:58:04 <donri> e.g. testing against a preset of expected values/outcomes
18:58:05 <copumpkin> to avoid actually computing the equalities at runtime
18:58:10 <wavewave> from name, hunit is more like translation from other xUnit.. quickcheck is more haskell-originated.
18:58:12 <dolio> copumpkin: No.
18:58:20 <kmc> copumpkin, and what if i write (undefined :: Int :=: Bool)
18:58:21 <donri> i personally like HTF for making hunit and quickcheck both easy to use and together
18:58:33 <copumpkin> kmc: ignoring stuff like that :)
18:58:35 <keep_learning> Hello every one
18:58:44 <wavewave> donri: what's HTF?
18:58:44 <donri> though it seems weird to use a custom preprocessor over template haskell
18:58:53 <donri> "haskell testing framework"
18:58:55 <kmc> copumpkin, Real Programmers don't make mistakes ;)
18:58:59 <keep_learning> I am trying to parse chunk of bytestring but some thing is not working
18:59:03 <donri> there's also a similar package called simply testing-framework
18:59:22 <copumpkin> kmc: I'm thinking of it more in terms of how a language like haskell that is total but has rewrite rules might operate
18:59:30 <kmc> ah
18:59:31 <dolio> It only makes sense if you're certain you have no bottoms being used as equalities.
18:59:34 <kmc> sounds good to me then
18:59:39 <keep_learning> could some one please tell me what is wrong in this parsing http://hpaste.org/52676
18:59:39 <kmc> donri, if i'm trying to sell someone on Haskell, I'll focus on "QuickCheck is so awesome" and not "we don't need as many tests because of types"
18:59:46 <kmc> you can show on one slide why quickcheck is awesome
18:59:51 <copumpkin> dolio: yeah
18:59:52 <wavewave> I don't do testing much (because I am a poor programmer, or "Real Programmer" ;-P )
18:59:56 <dolio> copumpkin: You also have to be careful with dependent types.
18:59:58 <donri> but HTF is more informative, injecting information about file:lineno, pretty-printing Show's and diffing nested data
19:00:04 <dolio> If you have them.
19:00:05 <copumpkin> if you use bottom as equality, then you can write unsafeCoerce easily
19:00:15 <copumpkin> dolio: oh, I don't, but can you elaborate?
19:00:16 <kmc> in fact I've heard multiple people say that QuickCheck is *the* killer feature for Haskell
19:00:28 <kmc> and that if your language does not have something similar, you should drop everything and write it
19:00:35 <dolio> copumpkin: It's the same problem as making equality elimination irrelevant.
19:00:42 <dolio> You can write loops under false premises.
19:00:43 <kmc> (bos said that in one of his talks)
19:00:58 <kmc> it's hard to write in a dynamically typed language, though
19:00:58 <donri> well, quickcheck makes less sense in languages that are less like haskell
19:01:01 <dolio> And if you have to normalize in false contexts, you can hit those loops.
19:01:17 <copumpkin> yeah
19:01:23 <copumpkin> okay
19:01:27 <wavewave> kmc: yeah, I saw bos' talk. I didn't use QuickCheck seriously until now, and now I am thinking to use it after looking at it.
19:01:30 <kmc> and yeah, it's useful in proportion to the proportion of pure functions
19:01:40 <kmc> but that's a strong argument for using pure functions in whatever language
19:02:02 <kmc> i think you'll even find such advice from mainstream TDD people
19:02:07 <kmc> (probably under some change of notation)
19:02:15 <donri> i also like (the idea of, not having used it yet) the "checkers" package which implements quickchecks for the "laws" for common types such as Monad
19:02:33 <kmc> ooh, I didn't know about that one
19:02:37 <wavewave> like concurrency. haskell can embrace different idea of safety..
19:02:46 <kmc> is it named after Richard Nixon's dog?
19:02:50 <kmc> @. elite nixon
19:02:50 <lambdabot> thiz0rz Iz0rz A 9r3at D4y 4 fRAnce!
19:03:03 <wavewave> runtime level safety  to type-level safety.
19:03:22 <donri> saywhatnow
19:03:42 <kmc> ¡
19:04:21 <wavewave> so anyone knows SHE implementation in recent ghc head?
19:05:28 <dolio> What?
19:05:31 <donri> isn't quickcheck sort of "design by contract" [on steroids]?
19:05:35 <wavewave> I remember just before ghc 7.0, spj talked about what's coming in ghc7 and SHE was one of the list.
19:05:44 <donri> with fuzzing, uh
19:05:51 <kmc> donri, kind of...
19:05:53 <dolio> I don't remember that. It would be sweet, though.
19:05:55 <roconnor> > 0x201c
19:05:56 <lambdabot>   8220
19:05:56 <kmc> properties tend to be more ad-hoc than contracts
19:06:03 <dolio> They are working on some fancier type/kind level stuff.
19:06:18 <wavewave> let me check the talk file...
19:06:19 <dolio> Allegedly 7.4 is going to have kind polymorphism.
19:07:12 <wavewave> http://vimeo.com/15467880
19:07:27 <wavewave> fun to look at where we were just one year ago.
19:08:18 <wavewave> dolio: probably such big thing first and convenience like SHE later in priority
19:08:31 <dylukes> So, for my STG compiler, in terms of advice... Could anyone reflect on my thoughts?
19:08:53 <dolio> wavewave: SHE has lots of little things I'd like to see go into GHC proper.
19:09:02 <dolio> Pattern synonyms.
19:09:11 <dylukes> Basically, what I'm seeing is that the codegen will produce symbols for functions, but the actual "machine" itself will have to be separate, and could probably include the entry point.
19:09:17 <wavewave> dolio: oh. that would be sweet!!
19:09:21 <dylukes> (essentially like crt0)
19:09:26 <dolio> The dependent type stuff I could probably continue living without.
19:09:39 <dylukes> but, should I probably link crt0 in?
19:09:45 <dylukes> and then have my entry code come after it?
19:09:50 <dylukes> Or do I not care for it at all :\?
19:09:52 <dolio> The superclass default stuff is also good. And something that might make it into GHC.
19:10:25 <wavewave> I would like to see haskell has full range from untyped to dep type... kk
19:10:49 <wavewave> so people start programming with less proof when prototyping
19:11:05 <wavewave> and more and more prove things and make them safer in dep types.
19:11:31 <wavewave> I am not sure whether that's consistently working well though.
19:12:36 <wavewave> dylukes : are you making your own compiler now?
19:12:47 <dylukes> wavewave: Yep, :).
19:13:00 <dylukes> STG, targeting LLVM.
19:13:08 <wavewave> dylukes: is it public? like in github?
19:13:10 <dylukes> yeah
19:13:25 <dylukes> https://github.com/DylanLukes/STGMA
19:13:31 <dylukes> I've only finished the parser (mostly...)
19:13:34 <wavewave> ahh yeah.. I was following you. ;-)
19:13:44 <dylukes> (I still haven't put in primitive operators and whatnot)
19:14:05 <wavewave> dylukes: do you have any specific goal now?
19:14:13 <dylukes> Uh, generating LLVM :P.
19:14:28 <wavewave> I mean compared with ghc LLVM backend.
19:14:33 <Axman6> you're not the one who was after the simple LLVM library are you?
19:14:35 <dylukes> I'm not competing with that.
19:14:41 <dylukes> Axman6: Nope.
19:14:45 <Axman6> ok
19:14:51 <dylukes> wavewave: this is for personal use and fun. It's my first shot and something like this.
19:15:07 <wavewave> dylukes: I see... very impressive stuff.
19:15:12 <dylukes> wavewave: I'm going to do two things
19:15:16 <Axman6> well, there's some work being done to make one that's simpler than the current llvm package (which is really cool, but necessarilly complex)
19:15:21 <dylukes> Firstly I'm going to get code generation for each function going.
19:15:32 <dylukes> Then my goal is going to be, rather than jump straight to compiled binaries,
19:15:46 <dylukes> to use the LLVM unsafePurify stuff and what not to interact with the LLVM'd functions from Haskell
19:15:54 <dylukes> as a pseudo-interpreter :P
19:16:04 <dylukes> That way I can play with the machine design in haskell, rather than write it in C and link it is.
19:16:07 <dylukes> link it in*
19:16:31 <dylukes> I'm also making FFI-to-C primitive to my STG flavor at some point.
19:17:10 <wavewave> dylukes: if you make the interface general enough, you can also create a haskell RTS on jvm, too.
19:17:25 <dylukes> It's not for Haskell though >_<
19:17:34 <dylukes> I felt that would be constraining, and this is just a personal project.
19:17:48 <dylukes> The ultimate goal (though maybe not achievable) is to build a simple dependently-typed language on top of this when it's done.
19:17:59 <wavewave> great.
19:17:59 <dylukes> Codegen is really intimidating as it is though.
19:18:07 <dylukes> And I have zero familiarity with the LLVM bindings, and little with LLVM
19:18:12 <dylukes> :|
19:18:54 <wavewave> but sounds fun and you enjoy it. ;-) hope that it goes well.
19:19:18 <dylukes> Oh, this reminds me,
19:19:29 <dylukes> is there a good haskell library for describing in memory structures?
19:19:48 <dylukes> I want to preferably define my closure representation in the Haskell code.
19:20:39 <wavewave> recently cloud haskell paper talked about serializing haskell closure, am I right?
19:20:48 <Axman6> yes
19:20:58 <dylukes> Very different.
19:21:02 <luite> really? that would be awesome
19:21:09 <dylukes> When I say closure I mean a STG closure.
19:21:10 <luite> where can I find this paper?
19:21:17 <Axman6> @google cloud haskell
19:21:18 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
19:21:19 <lambdabot> Title: Towards Haskell in the Cloud
19:21:34 <wavewave> yeah that one.
19:21:38 <Axman6> basically making efforts to be able to do erlang like stuff in haskell, but type safe
19:22:10 <luite> hmm, great, I must read that later, could really help interactivity in my web app
19:22:20 <wavewave> haskell masters are genius..
19:22:43 * dylukes would not consider himself a Haskell master in the least.
19:22:49 <dylukes> Just a kid learning what he can :).
19:24:01 <luite> next step for me is to get a real cloud instead of a single server ;p
19:25:07 <donri> kid?
19:25:15 <dylukes> 17.
19:25:23 <dylukes> I guess I'm not much of a kid anymore.
19:25:44 <donri> ^_^
19:26:31 <kmc> Malcolm Gladwell says you have to write Haskell for 10,000 hours
19:26:49 <geheimdienst> ... without shaving
19:26:54 <dylukes> Seems a bit conservative to me.
19:26:57 <kmc> no no no
19:27:02 <kmc> Unix : beard :: Haskell : bowtie
19:27:06 <dylukes> Wait, what?
19:27:12 <dylukes> I'm not wearing a bowtie.
19:27:17 <kmc> http://en.wikipedia.org/wiki/File:Simon_Peyton_Jones_01.jpg
19:27:21 <geheimdienst> "look at my huge huge bowtie"?
19:27:27 <dylukes> speej!
19:28:38 <geheimdienst> i think he represents a compromise. beard and bowtie http://homepages.inf.ed.ac.uk/wadler/Pics/philtiebig.jpg
19:28:50 <shachaf> Hmm, http://en.wikipedia.org/wiki/File:Wadler2.JPG
19:28:59 <shachaf> The Haskell-UNIX bridge, I suppose.
19:51:48 <lb_user> > min [3,4,5]
19:51:49 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
19:51:49 <lambdabot>    arising from a use ...
19:52:07 <Axman6> > minimum [3,4,5]
19:52:08 <lambdabot>   3
19:52:08 <donri> > minimum [3, 4, 5]
19:52:09 <lambdabot>   3
19:52:11 <Axman6> > min 1 2
19:52:11 <lambdabot>   1
19:52:14 <donri> > min 3 4
19:52:16 <lambdabot>   3
19:52:16 <donri> ^_^
19:52:41 <lb_user> I love you all <3
19:52:46 <donri> lambdabot should have some guard against repeated similar input
19:53:12 <Cale> > foldr1 min [3,4,5]
19:53:13 <lambdabot>   3
19:53:28 <donri> @src foldr1
19:53:29 <lambdabot> foldr1 _ [x]    = x
19:53:29 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
19:53:29 <lambdabot> foldr1 _ []     = undefined
19:53:41 <Axman6> > iterate (2^) 2
19:53:42 <lambdabot>   [2,4,16,65536,2003529930406846464979072351560255750447825475569751419265016...
19:54:12 <Veinor> > iterate (1^) 1
19:54:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:54:14 <Axman6> > map (length . show) $ iterate (2^) 2
19:54:24 <lambdabot>   [1
19:54:31 <lb_user> > f x = x*x
19:54:34 <lambdabot>   <no location info>: parse error on input `='
19:54:39 * tgeeky gently reminds people that lambdabot responds to PMs
19:54:43 <lb_user> > let f x = x * x in f 4
19:54:44 <lambdabot>   16
19:55:08 <lb_user> oh sorry
19:55:08 <Cale> Hey, that's interesting...
19:55:08 <Cale> > 1 :: ()
19:55:08 <lambdabot>   No instance for (GHC.Num.Num ())
19:55:08 <lambdabot>    arising from the literal `1' at <intera...
19:55:10 <Cale> nope
19:55:11 <Cale> hmm
19:55:17 <tgeeky> Cale: wrang!
19:55:24 <Cale> > map show $ iterate (2^) 2
19:55:24 <lambdabot>   ["2","4","16","65536","2003529930406846464979072351560255750447825475569751...
19:55:35 <Cale> oh, I see
19:55:35 <tgeeky> now *that*'s numberwang
19:55:49 <Cale> too many people sending queries at once, they get jumbled :)
19:55:58 <Cale> haha, numberwang
19:56:46 <kmc> hahaha
19:57:20 <Cale> > take 5 . map (length . show) $ iterate (2^) 2
19:57:23 <lambdabot>   [1,1,2,5,19729]
19:57:28 <dylukes> That's numberwang!
19:57:34 <dylukes> Congratulations Cale.
19:57:43 <Cale> heh
19:57:56 <kmc> http://hpaste.org/52533
19:57:59 <Cale> Too bad @oeis is broken :/
19:58:01 <dylukes> kmc++
19:58:10 <Cale> oeis is the ultimate numberwang
19:58:23 <dylukes> oeis?
19:58:26 <dylukes> oh
19:58:30 <Cale> http://oeis.org/
19:58:33 <dylukes> online encyclopedia of integer sequences?
19:58:36 <Cale> yes
19:58:38 <dylukes> yep
19:58:40 <dylukes> thought so
19:59:16 <byorgey> oh noes, @oeis is broken? =(
19:59:26 <dylukes> @oeis 1,2,3
19:59:29 <dylukes> D:
19:59:30 <byorgey> did they change the format again or something?
19:59:33 <dylukes> @nixon what do we do sir?
19:59:41 <shachaf> Works for me.
19:59:42 <lambdabot> Plugin `oeis' failed with: thread killed
19:59:42 <lambdabot> I believe in the battle-whether it's the battle of a campaign or the battle of this office, which is a continuing battle.
19:59:45 <shachaf> @oeis 1,2,4,8
19:59:49 <Cale> Also referred to as Sloane, after its original author
19:59:53 <lambdabot>  Powers of 2: a(n) = 2^n.
19:59:53 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
20:00:05 <Cale> oh, it's started working again!
20:00:10 <Cale> That's good :)
20:00:12 <byorgey> \o/
20:00:12 <dylukes> @oeis 1,2,1,2,1,2
20:00:15 <kmc> @oeis filfteenhundredneep
20:00:20 <dylukes> It's laggy though, it should probably fork.
20:00:25 <lambdabot>  Number of distinct primes dividing n (also called omega(n)).
20:00:25 <lambdabot>  [0,1,1,1,1,2,1,1,1,2,1,2,1,2,2,1,1,2,1,2,2,2,1,2,1,2,1,2,1,3,1,1,2,2,2,2,1,2...
20:00:25 <lambdabot>  Sequence not found.
20:00:58 <Cale> @oeis 4,8,15
20:01:00 <lambdabot>  Tetranacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) + a(n-4) with a(0)=a(1)=...
20:01:01 <lambdabot>  [0,0,0,1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536,10671,20569,39648,7...
20:01:04 <Cale> @oeis 4,8,15,16
20:01:08 <lambdabot>  Table of Whitney numbers W(n,k) read by antidiagonals, where W(n,k) is maxim...
20:01:08 <lambdabot>  [1,1,1,1,2,1,1,2,3,1,1,2,4,4,1,1,2,4,7,5,1,1,2,4,8,11,6,1,1,2,4,8,15,16,7,1,...
20:01:15 <dylukes> Tetranacci?
20:01:17 <dylukes> XD
20:01:20 <Cale> @oeis 4,8,15,16,23
20:01:21 <lambdabot>  The Lost Numbers.
20:01:22 <lambdabot>  [4,8,15,16,23,42]
20:01:25 <Cale> heh
20:01:39 <dylukes> What happens if you generalize fibonacci to arbitrary n?
20:01:47 <shachaf> Doesn't change much.
20:01:59 <Veinor> but the closed form isn't algebraic, probably
20:02:05 <Veinor> (because of abel's theorem)
20:02:11 <dylukes> T(n,m) = Tn-1 ... Tn-m
20:02:14 <dylukes> Abel's Theorem?
20:02:26 <Veinor> you can't solve the general quintic exactly
20:02:34 <dylukes> Quintic?
20:02:43 <bobzhang> hi, does anyone try to compile ghc-7.4? I compiled it successfully, then how can I get cabal installed?
20:02:48 <Veinor> polynomial of degree 5
20:02:50 <Cale> dylukes: Degree 5 polynomial
20:03:18 <byorgey> 7.4 is out??
20:03:21 <dylukes> :0
20:03:23 <dylukes> que?!
20:03:28 <kmc> nope
20:03:29 <Veinor> finding a closed form for a recurrence that goes back k terms involves solving a degree k polynomial
20:03:32 <bobzhang> byorgey: I compiled from cvs
20:03:32 <dylukes> kmc: fuck
20:03:39 <dylukes> bobzhang: TT_TT
20:03:41 <kmc> cvs??
20:03:47 <dylukes> Way to get my hopes up.
20:03:56 <kmc> the current version of GHC is 7.3.20111015
20:03:58 <dylukes> And also yeah, isn't GHC on git now?
20:04:06 <kmc> or maybe 7.3.20111016 if they use GMT ;P
20:04:13 <bobzhang> kmc: I rename it 7.4 T_T
20:04:18 <kmc> i'll bet it hasn't been on CVS in a long time if ever
20:04:27 <kmc> though, the commits mailing list has 'cvs' in the name, no?
20:04:55 <bobzhang> sorry, then how could I get cabal installed?
20:05:12 <byorgey> bobzhang: download cabal-install-0.10.2.tar.gz from here: http://www.haskell.org/cabal/download.html
20:05:20 <byorgey> bobzhang: untar it and run the 'bootstrap.sh' script
20:05:46 <byorgey> if that doesn't work let us know and paste the error log.
20:05:49 <bobzhang> byorgey: ok, let me have a try, thanks
20:05:58 <Cale> Mathematica refuses to convert the roots of x^5 - x^4 - x^3 - x^2 - x - 1 to radicals, so it's probably impossible.
20:06:18 <shachaf> Proof by Mathematica-won't-do-it.
20:06:23 <bobzhang> byorgey: the latest is June 2010?
20:06:24 <Cale> yeah, lol
20:06:41 <byorgey> bobzhang: latest what?
20:06:50 <byorgey> oh, stable Cabal release
20:06:51 <bobzhang> byorgey: cabal
20:06:54 <byorgey> bobzhang: yeah, that's fine
20:06:58 <bobzhang> ok
20:07:12 <byorgey> bobzhang: I don't know for sure whether it still works with ghc 7.3 but it's the firts thing to try
20:08:14 <Cale> It gives 1/4 + 1/(4*Sqrt[3/(11 - 56*(2/(-65 + 3*Sqrt[1689]))^(1/3) + 2*2^(2/3)*(-65 + 3*Sqrt[1689])^(1/3))]) - Sqrt[11/6 + (14*(2/(-65 + 3*Sqrt[1689]))^(1/3))/3 - ((-65 + 3*Sqrt[1689])/2)^(1/3)/3 + (13*Sqrt[3/(11 - 56*(2/(-65 + 3*Sqrt[1689]))^(1/3) + 2*2^(2/3)*(-65 + 3*Sqrt[1689])^(1/3))])/2]/2 as one of the roots of x^4 - x^3 - x^2 - x - 1
20:09:01 <byorgey> bobzhang: actually, that's an error: Cabal-1.10.2.0 was released in June 2011, not 2010
20:09:39 <byorgey> dcoutts: dates are wrong on http://www.haskell.org/cabal/download.html, several years listed as '2010' should really be '2011'
20:10:10 <kmc> does anyone know the name of the Traveling Salesman Problem variant where you are visiting (possibly disjoint) line segments rather than individual points?
20:10:11 <byorgey> dcoutts: both under the 'Cabal library' section and 'Older releases' section
20:10:58 <Cale> kmc: as in TSP on a dual graph?
20:11:07 <Cale> er, line graph, sorry
20:11:39 <kmc> i'm not sure
20:11:47 <kmc> the input is a set of line segments in R2
20:12:13 <Cale> oh
20:12:15 <Cale> like that
20:12:25 <kmc> they might be totally disjoint, or might intersect each other, or could end up nicely end-to-end
20:12:47 <kmc> you want to traverse each line segment at least once, and you can move freely between other points, but want to minimize the time spent doing so
20:12:52 <shachaf> Ooh, ooh, give the motivation!
20:12:54 <luite> do you have to walk along the whole segments, or just visit a point on every one?
20:12:59 <kmc> the whole segment
20:13:02 <kmc> shachaf knows the motivation
20:13:10 <Cale> Controlling a laser?
20:13:13 <kmc> yes
20:14:43 <byorgey> like, for most efficiently cutting through bank vaults etc.?
20:14:53 <kmc> yeah
20:14:54 <Cale> You might be able to convert it to an ordinary TSP by having a graph whose vertices are the endpoints and intersection points of the line segments.
20:14:59 <kmc> *nod*
20:15:21 <kmc> and you can move between the ends of a line segment
20:15:23 <Cale> (and the weights are just the Euclidean distances, or angular distances)
20:15:23 <byorgey> that doesn't sound right
20:15:25 <kmc> at zero cost
20:15:30 <kmc> but only once
20:15:38 <Cale> eh?
20:15:38 <kmc> but maybe modeling that "only once" is not important to get good solutions
20:15:45 <bobzhang> byorgey: dependency missing base >=4 && <3 && >=2 && <5
20:15:48 <Cale> Why is that zero cost?
20:15:54 <kmc> because you have to do it no matter what
20:16:05 <bobzhang> byorgey: I have base-4.4.0.0
20:16:06 <kmc> maybe that doesn't matter either
20:16:07 <Cale> Well, you have to visit all the vertices no matter what
20:16:14 <Cale> er, hmm
20:16:19 <theDUBBER> i see this: www.thedubber.altervista.org
20:16:27 <Cale> Oh, right, this doesn't quite work
20:16:49 <Cale> because you actually have to travel along each segment, not just to each vertex
20:16:51 <bobzhang> byorgey: how should I modify Cabal.cabal?
20:16:59 <kmc> *nod*
20:17:00 <byorgey> bobzhang: ah, try following the instructions here: https://gist.github.com/1169332
20:19:36 <Cale> Hmm, there's a heuristic version which is easy: a graph whose vertices are the line segments, and whose edges are the intersections between those, weighted by the greater distance from the two endpoints.
20:20:21 <Cale> hmm, hmm...
20:26:42 <byorgey> Cale: what if the line segments are disjoint?
20:27:02 <Cale> byorgey: then it's obviously impossible to traverse the graph
20:27:36 <Cale> You can do a connectedness test beforehand to make sure that it's connected.
20:27:44 <byorgey> I thought the point was to visit all the segments, meaning you may have to travel some distance *not* on a segment in order to reach another one.
20:28:21 <byorgey> (23:20) <       kmc> they might be totally disjoint, or might intersect each other, or could end up nicely end-to-end
20:28:24 <byorgey> (23:21) <       kmc> you want to traverse each line segment at least once, and you can move freely between other points, but want to minimize the time spent doing so
20:28:29 <Cale> okay
20:29:19 <Cale> So, that's kind of like a min-cut problem, isn't it?
20:29:35 <Cale> Well...
20:29:39 <Cale> That's overthinking it
20:30:16 <Cale> You can define the distance between two connected components as the minimum distance between any pair of their vertices
20:30:34 <luite> min-cut? sounds wrong, since it's harder than TSP
20:31:16 <Cale> luite: Well, it would be a special case...
20:31:27 <Cale> But it's not necessary to look at it that way
20:32:17 <luite> but I mean that the usualy polynomial time solutions for min-cut will obviously not work here
20:32:53 <Veinor> what do category theorists call cocoa puffs
20:33:05 <luite> don't know how useful it is to look at it that way then :)
20:33:06 <Veinor> puffs
20:38:08 <kmc> you can reduce TSP to my problem easily, by using small line segments
20:43:30 <byorgey> Veinor: a-puffs, actually
20:44:10 <n00b> Guys, anyone know research papers
20:44:26 <n00b> about relation btw haskell and lamda calculus?
20:44:38 <n00b> I'm dying with my homework ...
20:44:39 <shachaf> byorgey: I think Veinor was going by pronunciation.
20:44:45 <byorgey> shachaf: I know =)
20:45:01 <byorgey> n00b: what's your homework?
20:45:02 <kmc> n00b, what do you want to know about it?
20:45:10 <n00b> Well, I need to know
20:45:14 <n00b> what 'mathematical'
20:45:20 <n00b> basis is applied in haskell
20:45:37 <n00b> kind of broad topic, but
20:45:40 <n00b> you know
20:45:42 <kmc> you should read _Types and Programming Languages_ by Benjamin C. Pierce
20:46:01 <n00b> any pdf availiable?
20:46:19 <wavewave> kmc: sounds too much..
20:46:24 <n00b> oh I found one
20:46:27 <kmc> it's a book, not generally freely available, but you can pirate it probably
20:46:30 <kmc> @yarr
20:46:30 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
20:46:43 <n00b> thanks kmc! :>
20:46:58 * monochrom certainly pirated it. but it won't answer the question. not even remotely.
20:50:25 <monochrom> in answering the question, one should start with the linguistic-conceptual analysis: what is meant by haskell? I'm serious, because that quickly leads to the official answer.
20:50:56 <n00b> uh inguistic-conceptual?
20:51:09 <n00b> You mean terminology or something?
20:51:29 <monochrom> what is meant by haskell? that is answered by the Haskell 2010 Report. Section 1.2 "The Haskell Kernel": "Although the kernel is not formally specified, it is essentially a slightly sugared variant of the lambda calculus with a straightforward denotational semantics."
20:51:43 <monochrom> That is the relation with the lambda calculus.
20:52:11 <n00b> So, you mean Haskell is just another 'representation' for lambda calculus?
20:52:25 <n00b> with more readable form or smth?
20:52:40 <monochrom> And it is stated officially in the language's definition. There is no persuasion necessary, no essay writing necessary, no further discussion necessary. By definition.
20:53:18 <n00b> Hmm, yeap.
20:53:23 <n00b> But still my teacher
20:53:27 <n00b> want some 'specific'
20:53:31 <n00b> examples
20:53:33 <monochrom> screw the teacher
20:53:49 <monochrom> but the rest of the Haskell 2010 Report probably has examples.
20:53:53 <erasmas> the "wider theory" section of the Haskell wiki book does a good job with these topics, though it assumes some prior knowledge: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
20:53:57 <monochrom> http://www.haskell.org/onlinereport/haskell2010/
20:54:07 * wavewave is wondering if any language with mutable state can be regarded as lambda calculus. 
20:54:20 <n00b> thanks man
20:54:32 <monochrom> or if it doesn't have enough examples, you can still understand what it says, then create your own examples
20:55:17 <n00b> Great! thanks monochrom
20:56:33 <wavewave> can't wait for ghc-7.4 more eagerly...
21:03:22 <kmc> screw the teacher, receive automatic A
21:03:28 <wavewave> do we have some good documentation about ContT monad other than haddock page of Control.Monad.Cont ?
21:05:10 <wavewave> wikibook page on cps looks good.
21:15:25 <hpaste> edwardk pasted “a very evil monad” at http://hpaste.org/52678
21:15:45 <mdxbhmt> @quote evil monad
21:15:45 <lambdabot> No quotes for this person. You type like i drive.
21:15:57 <mdxbhmt> aw
21:16:04 <edwardk> been playing around with a rather hideous form of a particular monad
21:16:07 <monochrom> wavewave: my http://www.vex.net/~trebla/haskell/cont-monad.xhtml may help?
21:16:16 <kmc> edwardk, are you writing a haskell compiler named THC?
21:16:42 <edwardk> in particular doing so such that StateT Int (ErrorT String (Writer Diagnostics)) doesn't need to do heap allocation (for the most part)
21:16:50 <edwardk> kmc: er.. maybe
21:17:09 <wavewave> monochrom: oh cool. very nice!
21:17:11 <edwardk> right now its just a toy type checker
21:17:46 <edwardk> if i get bored i may wire said type checker up to my toy parser and see about wiring it up to a toy backend that may or may not exist, but i don't really want to promise such a thing at this point ;)
21:18:17 <edwardk> anyways i was just trying to gauge the general level of disgust over this approach =)
21:18:46 <kmc> haha
21:19:01 <edwardk> considering its using state to model writer, unboxing and smashing everything flat to avoid allocation, and generally doing evil things
21:19:49 <edwardk> kmc: and yes, your counterexample holds. vacuous is an unsound optimization in the presence of GADTs and type families
21:20:32 <kmc> *nod*
21:20:53 <kmc> should it be named unsafeVacuous then?
21:20:54 <dolio> edwardk: What's wrong with that monad?
21:21:15 <edwardk> though i would argue that your Functor is a lie so it isn't my fault ;)
21:21:26 <edwardk> dolio: nothing that i've determined so far
21:21:34 <edwardk> just seems fairly grungy =)
21:22:12 <dolio> It's no worse than stuff like PutM.
21:22:19 <edwardk> it does make me very happy at how much stuff it avoids allocating in the interim though
21:22:30 <edwardk> i need benchmarks though
21:22:44 <dolio> If you need hardcore unboxing and stuff, your hands are kind of tied.
21:23:21 <edwardk> i probably don't need it, but i started with a nice little unboxed state monad, and then needed to add some stuff to get better error reporting
21:23:28 <edwardk> and wound up here after a couple of hours of work
21:23:47 <fazzone> Is there an easy way to write a function with type    (Ord a, Eq a) => [(a,b)] -> [(a,[b])]    that collects values with the same a?
21:24:04 <kmc> you want to use ordering for efficiency?
21:24:07 <dolio> Eq a is implied by Ord a.
21:25:16 <kmc> :t M.toList . M.fromListWith (++) . map (second (:[]))
21:25:17 <lambdabot> forall k a. (Ord k) => [(k, a)] -> [(k, [a])]
21:25:18 <fazzone> kmc: efficiency doesn't really matter, i just wanted to make it clear that a is something nice and neat like String or Int or something
21:25:24 <edwardk> fazzone: Data.Map.toList . Data.Map.fromListWith (++) . map (second return)
21:25:31 <edwardk> or something like that
21:26:15 <dolio> :t fromListWith
21:26:16 <lambdabot> Not in scope: `fromListWith'
21:26:22 <dolio> :t Data.Map.fromListWith
21:26:23 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
21:26:55 <fazzone> kmc, edwardk: thanks!
21:27:33 <kmc> is there a module which exports a similar API to Data.List but uses Map / Set internally?
21:27:50 <edwardk> kmc: sounds like you have a weekend project ;)
21:28:02 <kmc> too many already
21:28:21 <edwardk> some kind of Data.List.Ord or something?
21:28:37 <kmc> you could call it that, yeah
21:29:29 <edwardk> i did enjoy the fact that i was able to do things like run both branches of *> using the same fresh variable seed because there is no communication path between them
21:29:45 <edwardk> yay for parametricity
21:33:49 <edwardk> kmc: mostly because a similar Data.List.Hashable could be built with unordered-containers
21:34:05 <shachaf> kmc: What API do you want?
21:34:57 <edwardk> shachaf: the stuff from Data.List, with an extra Ord or Hashable constraint where it would make the algorithm faster
21:47:19 <kniu> guys
21:47:26 * hackagebot googleplus 0.3.1 - Haskell implementation of the Google+ API v1  http://hackage.haskell.org/package/googleplus-0.3.1 (MichaelXavier)
21:48:02 <kniu> what if somebody made a language like Haskell, except strict and bare-to-the-metal?
21:48:13 <Axman6> there are a few
21:48:33 <kniu> which ones?
21:48:40 <Axman6> timbre is one. Disciple is another (sort of)
21:48:46 <edwardk> kniu: ATS, various ML derivatives, etc.
21:48:57 <edwardk> kniu: DDC
21:48:58 <kmc> for some values of "like haskell"
21:49:11 <kmc> kniu, anyway, what if?
21:49:13 <edwardk> kniu: personally i find giving up laziness misses the point of haskell
21:49:19 <Axman6> edwardk: that's just the compiler =)
21:49:33 <kmc> Haskell doesn't have one single point
21:49:54 <edwardk> well, 'laziness is better as a default than an option' is the lesson i've taken to heart from haskell
21:49:55 <kniu> huh
21:49:58 <kniu> haven't heard of timbre
21:50:39 <Axman6> uh, Timber actually
21:50:42 <shachaf> edwardk likes his eta-reduction
21:50:50 <edwardk> very much =)
21:50:50 <kniu> well, DDC and ATS still have garbage collection
21:50:59 <kniu> so do the ML derivatives
21:51:07 <Axman6> does ATS have garbage collection?
21:51:19 <kniu> BitC is the closest to what I'm thinking of.
21:51:31 <Axman6> that was the other one i was thinking of
21:51:38 <edwardk> ditching GC destroys your ability to get anywhere near something haskell like. you lose the ability to partially apply, because you need to put the closure SOMEWHERE
21:51:52 <luite> hmm, it might be a type checking or code generation bug, if I inline the function manually it works fine, if I call the polymorphic one, it segfaults
21:51:58 <shachaf> Wait, it's called conversion?
21:51:58 <edwardk> BitC exists. one of my coworkers has another little strict type-and-effect system language. i forget its name
21:52:00 <luite> oh wron chan
21:52:02 * shachaf can never get those straight.
21:52:31 <kniu> > Concurrent programming. ATS, equipped with a multicore-safe implementation of garbage collection, can support multithreaded programming through the use of pthreads.
21:52:31 <lambdabot>   <no location info>: parse error on input `,'
21:52:55 <kniu> also, all these languages are impure in some way
21:53:11 <Axman6> so is haskell
21:53:26 <edwardk> kniu: ATS has a bunch of code for dealing with non-gc'd stuff as well IIRC
21:53:34 <bobzhang> hi all, all I have 2 cabals, but they share the same configure file ~/.cabal/config, how to make them have different configure files?
21:53:51 <Axman6> ATS is just a (really complicated) layer on top of C isn't it?
21:54:06 <edwardk> Axman6: most compilers are ;)
21:54:20 <Axman6> i mean, you can embed C in ATS
21:54:33 <Axman6> if you look at the shootout, a lot of the ATS entries are mostly C
21:54:35 <edwardk> dunno. i go crosseyed whenever i try to read ATS source
21:54:47 <edwardk> i can never figure out which random muddle of _'s and words are supposed to be keywords
21:54:49 <bobzhang> I need help T_T
21:55:10 <shachaf> I like how it has keywords like "t@ype".
21:55:51 <Axman6> wut o.O
21:56:17 <edwardk> fun{a:t@ype} ref_set_elt (r: ref a, x: a):<!ref> void
21:56:25 <edwardk> or
21:56:27 <edwardk> fun{a:viewt@ype} ref_make_elt (x: a):<> ref a
21:57:14 <edwardk> from http://www.ats-lang.org/DOCUMENT/TUTORIALATS/HTML/c594.html
21:57:38 <kniu> well anyway
21:57:47 <kniu> reason I brought this up
21:57:55 <kniu> is that I've been working on yet another one of these
21:58:31 <wavewave> bobzhang: i don't understand that you have two cabals. would you explain more?
21:58:31 <kniu> An unholy combination of C and Haskell
21:58:56 <wavewave> bobzhang: two versions of cabal install?
21:58:57 <kmc> two cabal-install binaries for different ghc installs?
21:59:03 <bobzhang> wavewave: yes
21:59:15 <bobzhang> two versions  ghc
21:59:43 <bobzhang> I did not see any way to change the location of cabal config path
22:00:22 <bobzhang> I have (ghc-7.2 + cabal) (ghc-7.3+cabal)
22:00:32 <luite> bobzhang: why must they have different configs?
22:00:43 <wavewave> bobzhang: download cabal-install src and change inside.
22:01:11 <bobzhang> otherwise cabal will always choose ghc-7.2
22:01:12 <wavewave> in Main.hs of cabal-install, there is defaultConfigFile
22:01:20 <kniu> I have no idea how novel my language is.
22:01:42 <wavewave> bobzhang: defaultConfigFile is defined in Distribution.Client.Config .
22:01:58 <dolio> What the hell is t@ype?
22:02:06 <bobzhang> wavewave: that means I need to recompile it again?
22:02:16 <wavewave> just cabal-install only.. that's simple.
22:02:54 <bobzhang> wavewave: thank you. It takes me 4 hours to make all done ...
22:03:01 <Axman6> dolio: someone's idea of a terrible joke?
22:03:05 <wavewave> defaultConfigFile seeks defaultCabalDir.. change defaultCabalDir to your preferred directory.
22:03:46 <wavewave> bobzhang: do not hesitate to look inside the source code.. it is often simple.
22:03:48 <dolio> "The unusual symbol t@ype is a sort for static terms representing types of unspecified size, where the size of a type is the number of bytes needed for representing a value of the type. There is another sort type in ATS, which is for static terms representing types of size equal to one word exactly, that is, 4 bytes on a 32-bit machine or 8 bytes on a 64-bit machine."
22:04:28 <bobzhang> wavewave: thank you, I found it
22:04:28 <wavewave> bobzhang: because haskell has referential transparency and denotational semantics!
22:04:58 <bobzhang> wavewave: when I want to write some machine learning algorithms, I always think pure sucks..
22:05:27 <dolio> The more I learn about ATS, the more I dislike it.
22:05:42 <wavewave> that's state machine. you can do that in state monad in pure way.
22:06:08 <bobzhang> wavewave: I want first-class mutability T_T
22:06:09 <kmc> haskell has denotational semantics?
22:06:41 <wavewave> kmc: I retreat to ''relatively denotational" ;-P
22:10:49 <wavewave> bobzhang: why? isn't state monad simple enough?
22:11:10 <kmc> you know what's simpler than state monad?
22:11:12 <kmc> functions
22:11:15 <mauke> bobzhang: haskell has first-class mutability
22:11:27 <mauke> you can take a mutation and store it in a variable
22:12:03 <kmc> i've not seen a formal semantics for Haskell.  i'd expect it to be an axiomatic semantics based on the β-reduction rule of the lambda calculus, and other rules for pattern matching etc
22:12:08 <bobzhang> mauke: really? not a joke?
22:12:17 <kmc> not a denotational semantics
22:12:23 <mauke> bobzhang: depends on your point of view
22:12:43 <kmc> you can take a mutation, i.e. a description of the act of mutating something, and store it in a variable
22:12:50 <wavewave> kmc: i regard state monad as just funciton. common pattern of input parameter  and output parameter.
22:13:06 <bobzhang> mauke: I know ST monad, but I don't want to..
22:13:15 <kmc> merely storing the description of an effect in a variable does not cause an effect, that would be madness
22:13:17 <bobzhang> wavewave: imagine you just write a ID3 algorithm
22:14:21 <wavewave> bobzhang: ST monad is completely valid good simple solution. no reason to avoid.
22:14:45 <kmc> state monad ≠ ST monad
22:14:48 <shachaf> There are plenty of reasons to avoid ST.
22:14:54 <wavewave> although what we mean state monad is different ffom ST
22:15:01 <kmc> reason to avoid ST: it's built-in magic; you have to learn new rules for it
22:15:01 <wavewave> kmc: you fast.
22:15:11 <kmc> reason to avoid State: it's only a little syntactic sugar
22:15:22 <kmc> this is why I propose "functions" as an alternative to both
22:15:33 <shachaf> unfoldr
22:15:37 <bobzhang> I am not joking, I feel much more comfortable when writing machine learning algorithms in CL than haskell
22:15:45 <kmc> we're not joking either
22:16:05 <kmc> i realize that functional programming is unpopular in Haskell circles
22:16:41 <shachaf> kmc: That's why we need to banish IO to ever more obscure crevices of the language.
22:16:48 <bobzhang> I have an algorithm course this semester
22:17:10 <shachaf> Is that like an obstacle course?
22:17:20 <bobzhang> I found most algorithms will need mutability
22:17:32 <kmc> bobzhang, frustration dealing with state in Haskell is totally reasonable and normal
22:17:33 <bobzhang> I read pfd
22:17:49 <wavewave> bobzhang: that's true.. and if you want to translate it, just use state or ST monad.
22:17:53 <bobzhang> but it's not most efficient, so I feel uncomfortable
22:18:07 <kmc> why do you need "most efficient"
22:18:14 <wavewave> bobzhang: it's efficient.
22:18:19 <bobzhang> just unhappy T_T
22:18:22 <kmc> also, "most efficient" according to an irrelevant theoretical asymptotic analysis?
22:18:33 <kmc> or did you run benchmarks?
22:18:49 <bobzhang> theoretically
22:19:08 <companion_cube> ST is pretty efficient, isn't it?
22:19:12 <kmc> yes
22:19:16 <wavewave> yes.
22:19:31 <Eduard_Munteanu> For an algorithms course, asymptotics will probably matter a lot.
22:19:42 <wavewave> although I want to see some extensive benchmarks.
22:19:53 <kmc> for an algorithms course you write proofs on paper
22:20:15 <kmc> and you prove things about how many CPU instructions they would take, which tells you how fast they'd run on a computer from the 1960's
22:20:18 <bobzhang> are there any materials for most popular efficient data structures in Haskell?
22:20:23 <kmc> what does that mean
22:20:27 <Eduard_Munteanu> Maybe they might be assigned algorithms to implement in actual languages, dunno.
22:20:34 <kmc> libraries? books? guides?
22:20:35 <shachaf> kmc: Computers from the 1960s are great!
22:20:44 <shachaf> What was the simple embedded CPU you talked about a while ago?
22:20:44 <bobzhang> libraries
22:20:57 <bobzhang> I think this is more important for real world programming
22:20:59 <kmc> bobzhang, just browse the standard library
22:21:02 <Eduard_Munteanu> @where okasaki
22:21:02 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
22:21:12 <kmc> Data.Map, Data.Set, Data.IntMap, Data.IntSet, Data.Sequence
22:21:18 <Eduard_Munteanu> That might be helpful if you're looking for a functional POV ^
22:21:19 <bobzhang> Eduard_Munteanu: I have read it
22:21:26 <kmc> more sophisticated associative data structures in http://hackage.haskell.org/package/unordered-containers
22:21:41 <kmc> and please don't say hash tables are so much faster because they're "O(1)"
22:21:43 <kmc> which is a lie anyway
22:21:54 <kmc> those unordered-containers are just as "O(1)" as hash tables
22:21:59 <kmc> but they also work with pure functional code
22:22:00 <bobzhang> I know in Haskell it's not O(1), haha
22:22:06 <kmc> it's not O(1) anywhere, period
22:22:17 <shachaf> It's O(2^64) everywhere, though.
22:22:24 <kmc> you can't address an arbitrary amount of memory in constant anything
22:22:29 <shachaf> kmc: Oh, AVR.
22:22:31 <wavewave> bobzhang: I do not get what is a real problem here. If you need to use fast known imperative algorithm, just implement it using ST or state monad. if you want to use some functional algorithm, then you can use functional data structure.
22:22:42 <companion_cube> tries are also O(1) then
22:22:43 <wavewave> haskell is just able to do both.
22:23:01 <bobzhang> wavewave: I will follow your advice, try to use ST
22:23:07 <kniu> just wondering, wavewave
22:23:10 <kmc> no, try to write functional code first
22:23:11 <kniu> what country are you from?
22:23:15 <Eduard_Munteanu> You get O(1) under limiting assumptions such as limited number of inserts (amounting to perfect hashing in some sense I guess).
22:23:17 <shachaf> wavewave: ST and State are completely different.
22:23:18 <bobzhang> wavewave: I read the original paper, understand it, but just don't want to use it
22:23:25 <kmc> bobzhang, use ST if you actually need speed
22:23:27 <kmc> actually
22:23:28 <kmc> need
22:23:29 <Draconx> kmc, for asymptotic analysis, you need to say what you're counting.  For comparison-based data structures, one usually counts the number of comparisons.
22:23:33 <bobzhang> I donot know why
22:23:35 <kmc> not "if some book scared you into thinking it might be too slow"
22:23:50 <shachaf> kmc: I NEED that speed, man.
22:23:55 <bobzhang> does anyone have the same experience with me?
22:23:56 <shachaf> This is an industry-strength applicatio.
22:24:01 <kmc> what experience bobzhang?
22:24:03 <wavewave> kniu:  are you asking my original home country?
22:24:06 <kniu> yes
22:24:17 <wavewave> from Korea.
22:24:21 <kniu> okay
22:24:38 <wavewave> kniu: are you?
22:24:48 <bobzhang> kmc: Just feared that it may be too slow and don't use it
22:24:55 <kmc> what the fuck
22:24:58 <kniu> wavewave, I'm Chinese.
22:25:02 <kmc> why don't you see if it's actually too slow
22:25:12 <kniu> kmc is right
22:25:20 <kniu> profile first, THEN optimie.
22:25:24 <kniu> *optimize
22:25:32 <bobzhang> I have benchmarked it before, when I start an ocaml, just 1MB memory
22:25:33 <Eduard_Munteanu> It will probably be slower than C for CPU-intensive tasks, as in the case of many theoretical algorithms.
22:25:39 <shachaf> kmc: Worrying about whether something is too slow before you spend X hours/weeks/months learning it isn't *completely* unreasonable.
22:25:46 <bobzhang> start ghc, 30~40M memory
22:25:49 <shachaf> Too slow for a specific thing you want to do, that is.
22:25:55 <kmc> bobzhang, it sounds like you want to write code which is complex and ugly and broken, but really fast!  except you don't measure the speed, you assume it's fast based on a 1960's understanding of computer architecture
22:25:58 <kmc> C is the ideal language for that
22:26:00 <kmc> you should use C
22:26:21 <kmc> or hey, use ocaml
22:26:23 <bobzhang> don't get me wrong, I love haskell..
22:26:24 <geheimdienst> 1. code the simplest thing that could possibly work 2. profile it, measure it 3. optimize the parts that actually matter
22:26:36 <wavewave> shachaf: I know ST and State are completely different. Thank you for pointing this out.
22:26:39 <kmc> i don't want to deal with people who say "it's too slow" without even trying
22:26:48 <kmc> that's basically just trolling
22:27:00 <Hayshi> quick noob-y question: my professor is asking us to run a program using $ ./filename but that just gives me an error message. I think I wrote it down wrong- how does this work?
22:27:01 <companion_cube> kmc: C is convenient for dealing with cache issues, though
22:27:06 <companion_cube> when you really need speed
22:27:24 <Eduard_Munteanu> Hayshi: you're not supposed to type the '$'
22:27:46 <Eduard_Munteanu> That's your prompt, in case that was the confusion.
22:28:00 <Hayshi> then it tells me: parse error on input  './'
22:28:10 <wavewave> kmc: do not be too harsh on this... he probably just want to initiate some discussion about speed.
22:28:16 <companion_cube> are you using a shell, Hayshi ?
22:28:17 <Eduard_Munteanu> Hayshi: where are you typing that?
22:28:25 <kmc> yeah trolling is "initiating a discussion"
22:28:45 <Hayshi> well it says that in ghci; if I do that after quitting ghci it just tells me "Permission denied"
22:29:01 <shachaf> Joining an IRC channel and asking "I want to write a thing that has so-and-so performance constraints, and I'm considering using X, but I'm worried that I won't be able to make it fast enough after expending a significant amount of energy; is X known to be usable for this sort of thing?" isn't really trolling.
22:29:17 <Eduard_Munteanu> That's supposed to run 'filename' from the current directory when typed into a terminal running an (orthodox) shell.
22:29:24 <kmc> that's not what i saw
22:29:28 <wavewave> kmc: how to start question about some vague idea can be difficult.
22:29:39 <shachaf> Of course, bobzhang didn't specify his requirements at all, just some abstract "too slow" criterion.
22:29:48 <kmc> what i saw is repeatedly saying "it's too slow, i won't use it" without a) evidence b) stating a problem at hand c) believing anyone who says it's fast enough
22:29:54 <kmc> right
22:30:07 <kmc> the lack of specificity is one sign that the discussion will go nowhere
22:30:08 <bobzhang> ok, sorry for what I said.
22:30:13 <Eduard_Munteanu> Hayshi: you either load the Haskell source file in ghci, or compile it if you want to run it like './foo'
22:30:26 <kmc> "can haskell be used to make programs, i heard it was too slow"
22:30:56 <Eduard_Munteanu> Hayshi: to compile, you need to   ghc --make foo.hs
22:30:59 <geheimdienst> Hayshi: what your professor meant was to run "./filename" after you quit ghci. if you get "permission denied", probably you need to do "chmod 755 filename" to make the file executable
22:31:07 <bobzhang> I must sleep now, good night~~ haskell will be faster, isn't it?
22:31:10 <shachaf> Haskell's speed is O(1/number of PhDs you have)
22:31:12 <Eduard_Munteanu> Then run the resulting executable, not the source file.
22:31:27 <kmc> bobzhang, faster than what? faster than not benchmarking it?
22:32:12 <Eduard_Munteanu> TBH, I don't like the "Haskell is fast" mantra either :)
22:32:26 <kmc> both are useless generalizations
22:32:26 <Hayshi> aah! now it gives me a ton of "line 1: module: command not found" etc etc
22:32:32 <Hayshi> but the program compiles in ghci
22:32:33 <Eduard_Munteanu> It's fast where certain things don't matter, which may be the case with lots of apps.
22:32:40 <shachaf> Hayshi: Are you running it as a shell script?
22:33:18 <kmc> i don't understand why people focus on performance before even a vague idea of correctness
22:33:26 <Hayshi> I'm not sure what that means  :(
22:33:44 <shachaf> Hayshi: Don't run your source file with "./".
22:33:56 <shachaf> Compile it and run the resulting binary, or run it with runghc (or ghci).
22:34:08 <Eduard_Munteanu> kmc: I'd guess because refining the "spec" to an optimized version might be a bitch
22:34:12 <mauke> geheimdienst: bad advice :-(
22:34:26 <wavewave> by the way, since the topic came up anyway, would you summarize why ST monad should be avoided for me? I basically understand ST monad needs special magic inside ghc. (but not detail.)
22:34:26 <geheimdienst> kmc, skepticism is just something that doesn't come easily to humans. measuring and gathering evidence is more difficult than following your gut feeling or believing what you hear
22:35:18 <kmc> because declarative functional programming is nicer than imperative programming
22:35:36 <dolio> You can implement ST (almost) in GHC yourself.
22:35:43 <shachaf> dolio: With type safety?
22:35:45 <kmc> without the performance, though
22:35:46 <Eduard_Munteanu> kmc: in some cases getting the correct-but-slow solution is pretty painful as well, so I guess that's one reason people avoid refinement / progressive optimization
22:35:52 <dolio> It will just have asymptotically worse performance.
22:35:54 <dolio> shachaf: Yes.
22:36:01 <Hayshi> well here's my issue- I just wrote a rot13 program; and I need to rot13 the text of the program, but I can't figure out how to do that haha
22:36:02 <shachaf> dolio: Hmm, I haven't come across that.
22:36:05 <shachaf> How does taht work?
22:36:10 <kniu> Hayshi,
22:36:14 <kniu> you have a source file
22:36:22 <kniu> it probably ends with a ".hs"
22:36:25 <mauke> Hayshi: what part are you having problems with?
22:36:27 <kniu> run
22:36:40 <Eduard_Munteanu> He's probably trying to run the source file directly.
22:36:41 <kniu> ghc --make <source_file>.hs -o executable
22:36:42 <dolio> Define a type rep GADT with all the types you care about storing.
22:36:43 <kniu> now
22:36:46 <kniu> run
22:36:51 <kniu> ./executable input_file
22:36:58 <companion_cube> or use runhaskell
22:37:06 <shachaf> dolio: Oh, but not for arbitrary types.
22:37:11 <kniu> you get what I'm saying here?
22:37:13 <dolio> Right.
22:37:15 <companion_cube> runhaskell rot13.hs rot13.hs
22:37:29 <wavewave> kmc: so basically no practical issue once I decide to use the algorithm anyway?
22:37:35 <kmc> what?
22:37:37 <dolio> Arbitrary types requires unsafeCoercing with the knowledge that your implementation is correct by construction.
22:37:39 <kniu> the source file is not the program; the source file is processed by the compiler to create the program, and then you run the program.
22:38:51 <Hayshi> now it just returns "usage: rot13.hs n"
22:39:03 <kmc> wavewave, if you want to implement an imperative algorithm in Haskell then ST is an attractive option
22:39:09 <Eduard_Munteanu> Hayshi: then it works
22:39:20 <kmc> wavewave, but many algorithms are not inherently imperative
22:39:22 <Eduard_Munteanu> You just need to supply the right arguments now.
22:39:26 <kmc> they are just presented in that style
22:39:36 <shachaf> Hayshi: Did you actually write this program? Do you understand how it works? :-)
22:39:36 <wavewave> kmc: I understand that point definitely..
22:39:39 <kmc> by tradition and by the biases of people who write and read algorithms texts
22:39:54 <wavewave> kmc: I just want to know any practical issue which I might not know now.
22:39:57 <kmc> before I read it I was hoping Okasaki's book would be like a traditional algorithms text but with a pure treatment of everything
22:40:04 <kmc> but it's not really
22:40:05 <kniu> Hayshi, run
22:40:07 <Hayshi> yes, I wrote it. No need to be snide. I'm a third week computer science student.
22:40:18 <kniu> > no need to be snide
22:40:19 <lambdabot>   Not in scope: `no'Not in scope: `need'Not in scope: `to'Not in scope: `be'N...
22:40:28 <kmc> wavewave, GHC implementation of ST is very similar to the implementation of IO
22:40:33 <kmc> and STRef is like IORef
22:40:49 <kmc> except runST has compiletime safety checks through a type system trick
22:40:57 <kmc> at runtime, runST and unsafePerformIO are basically the same
22:40:59 <Eduard_Munteanu> Hayshi: how did you test it in ghci? Did you go through 'main' there as well?
22:41:15 <kniu> Hayshi, we reserve the right snide the hell out of you, since you don't even know the basics of compiling and running a program.
22:41:16 <mauke> Hayshi: then why do you not know how it works?
22:41:18 <wavewave> kmc: I see.. thanks for elaboration.
22:41:19 <Eduard_Munteanu> It might make a difference if you just ran a function.
22:41:31 <Eduard_Munteanu> s/ran/computed/
22:41:33 <mauke> Hayshi: or rather, what it does
22:41:35 <kniu> Attitude won't get people to help you.
22:41:47 <shachaf> Presumably this "usage: rot13.hs n" message is something that you wrote yourself?
22:42:06 <kmc> shachaf, I definitely agree about needing to guess performance characteristics before you structure code
22:42:18 <Hayshi> (again: three weeks of computer science. ever. I apologize for not knowing everything about it. I am legitimately grateful for the help, though)
22:42:27 <kniu> (you're welcome)
22:42:51 <wavewave> one real question I encountered as for functional / imperative algorithm before was whether there are good graph isomorphism algorithm in functional way.
22:43:13 <kniu> programs usually output "usage: [executable_name] [arguments ...]" when you run them without supplying the correct set of arguments
22:43:24 <Eduard_Munteanu> First year Haskell course? :)
22:43:29 <Hayshi> yes indeed
22:43:42 <kniu> from your usage string, it seems like that your program needs "n"
22:43:46 <Hayshi> + first programming experience
22:43:53 <kniu> try replacing "n" with the name of a file
22:43:53 <Eduard_Munteanu> Interesting.
22:44:00 <kniu> or a number
22:44:11 <kmc> shachaf, and asking #haskell for advice on that is totally legit
22:44:18 <kniu> if you're stuck, read the code to determine what kind of argument it expects.
22:44:40 <shachaf> kmc: Right, bobzhang didn't really ask the question in a way that a useful answer could be provided.
22:44:52 <kmc> he didn't really ask a question, either
22:45:08 <kmc> "Haskell is too slow"  "no, it's fast enough, why don't you try it"  "but it's too slow"
22:45:13 <shachaf> I was just saying the general concept of "if you ask whether X is fast before writing and benchmarking it yourself you're a troll" doesn't always hold.
22:45:19 <shachaf> I guess that's not what you were saying, though.
22:45:29 <kmc> maybe I said that by accident, but it's not something I believe
22:45:53 <Eduard_Munteanu> Well, mentioning a general algorithms course means those things might not be straightforward to encode in Haskell efficiently.
22:45:57 <kmc> assertions of slowness are subject to different rules from questions about which might be faster
22:46:14 <kmc> yes, if you're making a positive claim about performance, I will ask if you have evidence
22:46:14 <Eduard_Munteanu> Or, should I say, idiomatically at least.
22:46:27 <kmc> if that evidence is "hash tables are O(1)!!!!!!" i will fail to be convinced
22:47:45 * Eduard_Munteanu finds simple hashtables are relatively easy to encode in imperative languages, though, so that might explain their attractiveness as well.
22:47:59 <Eduard_Munteanu> (if you intend on reinventing the wheel, of course)
22:48:16 <shachaf> Aren't hash tables typically O(k), not O(1), anyway?
22:48:33 <mauke> yes
22:48:40 <kmc> Eduard_Munteanu, yeah, they're popular in C because every project is expected to reimplement all data structures from scratch
22:48:43 <companion_cube> O(k) = O(1), asymptotically, isn't it?
22:48:44 <fazzone> Isn't O(k) the same as O(1)
22:48:50 <mauke> fazzone: only if k is 1
22:48:56 <shachaf> "k" being "length of key"
22:48:57 <Eduard_Munteanu> Or 2 :P
22:48:58 <kmc> in C it's a lot easier to write a hash table which doesn't suck than a tree shaped thing which doesn't suck
22:49:10 <companion_cube> oh, i thought "k" was a constant
22:49:35 <Eduard_Munteanu> Yeah, an RB tree is relative more verbose to code in C.
22:49:37 <shachaf> Presumably a reasonable hash function will often hash the entire key, wouldn't it?
22:49:39 <Eduard_Munteanu> *relatively
22:50:42 <Eduard_Munteanu> It has to do with collisions, rather than key length, no?
22:51:18 <Eduard_Munteanu> Because collisions require you to reshape the hashtable or otherwise introduce indirection.
22:51:21 <kniu> kmc, I sense some animosity towards C programming from you.
22:51:25 <mauke> Eduard_Munteanu: no
22:51:28 <kmc> haha
22:51:36 <kmc> I think it's a decent language for writing an OS kernel
22:51:47 <kmc> writing applications software in C is stupidity bordering on criminal negligence
22:52:02 <companion_cube> what about solvers for hard problems?
22:52:05 <kniu> and I think there should exist a better language for writing an OS kernel.
22:52:06 <shachaf> I think there could prob ably be much better languages for writing an OS kernel than C.
22:52:12 <kmc> yes
22:52:12 <Eduard_Munteanu> mauke: admittedly, if you could guarantee no collisions, it'd be O(1)
22:52:12 <kniu> Unfortunately, I have not come across one.
22:52:17 <kmc> this is a language where minor mistakes in routine string handling will let an attacker take over your computer
22:52:23 <mauke> Eduard_Munteanu: why?
22:52:29 <kniu> So I made one.
22:52:37 <kniu> https://github.com/Nenmin/Hammer
22:52:41 <kmc> Eduard_Munteanu, it is physically impossible to address n memory locations in O(1)
22:52:55 * shachaf >> threadDelay n
22:53:10 <kmc> you can't scale up storage arbitrarily without scaling up the resources devoted to dealing with it
22:53:17 <Eduard_Munteanu> mauke: let's take insertion. If I have no collisions, then after I compute the hash of the key I can lookup the bucket in O(1) (say an array) and store the value there.
22:53:24 <mauke> Eduard_Munteanu: correct
22:53:29 <kniu> kmc, arrays don't exist?
22:53:36 <kmc> arrays aren't really O(1)
22:53:38 <mauke> Eduard_Munteanu: key point: "after I compute the hash"
22:53:56 <kmc> you'll find your array starts to perform much slower once it outgrows your L1 cache
22:53:56 <Eduard_Munteanu> mauke: oh, you mean the hash isn't O(1)? :/
22:54:06 <mauke> Eduard_Munteanu: it usually isn't
22:54:16 <mauke> Eduard_Munteanu: hence O(key length)
22:54:33 <kmc> in real systems you have cache hierarchies, memory bandwidth contention, coherence protocols, NUMA, caching, swap
22:54:37 <Eduard_Munteanu> Oh, hrm, good point.
22:54:40 <kmc> all of it a consequence of this law
22:54:59 <kmc> that you can't scale up storage arbitrarily without losing performance
22:55:08 <Eduard_Munteanu> Though simple hashes (which aren't that bad) are "pretty much" O(1).
22:55:20 <mauke> no, they're O(k)
22:55:27 <kmc> again, asymptotic analysis is great if you want to predict which algorithm will run faster on a computer from the 1960's
22:55:46 <kmc> when compute time dominated and memories were basically flat arrays attached to the CPU
22:55:48 <mauke> IIRC there are hashes that are O(log k)
22:56:02 <kmc> though even then machines had core and drum and disk and tape
22:56:03 <dolio> You don't get to hash arbitrarily large strings in O(1).
22:56:10 <dolio> Unless you simply throw away most of the string.
22:56:19 <Eduard_Munteanu> Oh, I think I'm always seeing the key being the same size as some machine word or something.
22:56:25 <mauke> dolio: sure, why not?
22:56:42 <Eduard_Munteanu> Yeah, I get it now.
22:56:51 <kniu> kmc, asymptotic analysis is _less_ valid, but it's not _invalid_
22:57:19 <kniu> if you profile your program, find an O(n^2) loop, then get it down to O(log n)
22:57:20 <kmc> my fuzzy rule of thumb is that O(n^2) versus O(n) is worth paying attention to, but O(1) vs O(log n) is irrelevant
22:57:22 <kniu> you're gonna see a speedup
22:57:39 <kmc> maybe, or maybe your O(n^2) loop had better cache behavior
22:58:09 <kmc> anyway I was addressing the specific claim that hash tables are O(1), which is physically impossible
22:58:19 <mauke> maybe your O(log n) has a constant overhead of 9000
22:58:27 <kmc> i hope i have explained how it is physically impossible
22:58:40 <kmc> this does not invalidate all asymptotic analysis everywhere
22:58:53 <Eduard_Munteanu> kmc: wouldn't there be an upper bound on penalties from alignment, contention etc. wrt memory access? I wonder.
22:58:55 <kniu> you sure made it sound that way.
22:59:27 <kmc> that's just, like, your opinion, man
22:59:51 <luite> kmc: hmm, often that log n stuff indicates that you have some chain of pointers to follow, which could give you a bad cache miss penalty (of course with every O(1) you're also ignoring all kinds of log factors)
23:00:06 <kmc> yeah
23:00:19 <kmc> hashing deliberately destroys locality
23:00:37 <kmc> binary trees suck for this chain-of-pointers reason
23:00:48 <kmc> fat trees perform much better
23:01:06 <Eduard_Munteanu> It also depends on how you allocate memory I guess.
23:01:15 <kmc> there's a branch of unordered-containers which uses 16-ary packed nodes
23:01:36 <kmc> and unordered-containers is "O(1)" in the same bogus way as hash tables
23:01:48 <levi> Algorithmic analysis works much better in pure computational theory than with those dirty programs that run on those wretched 'computers'.
23:02:30 <kmc> Judy arrays are another fat-tree structure which is extensively optimized for cache performance
23:02:52 <kmc> anyway, if you want to count indirections or cache misses, count indirections or cache misses, not asymptotic CPU instructions
23:03:40 <kmc> hash tries incur a constant number of cache misses per lookup, whether they're 2-ary or 16-ary
23:05:35 <kmc> but the particular constant matters a lot
23:19:34 * shachaf return
23:20:40 <shachaf> In what sense is a hash table "O(1)" in which a trie isn't "O(1)"?
23:21:55 <edwardk> shachaf: expected number of instructions
23:22:01 <kmc> a hash trie?
23:22:04 <wavewave> hash table is amortized O(const), isn't it?
23:22:34 <kmc> for the nth time I will point out that it is physically impossible to address an arbitrary amount of memory using a constant amount of resources
23:22:43 <MatrixFrog> wavewave: i'm not familiar with haskell hash tables, but generally yes
23:22:58 <edwardk> kmc: and for the nth time the world will shrug and move on =)
23:23:15 <wavewave> MatrixFrog: haskell hash table must be the same as general one.
23:23:22 <edwardk> kmc: how about 'under the simplifications implied by the pointer machine model' it is O(1)
23:23:27 <edwardk> but that gets tedious to say =P
23:23:59 <kmc> under the same assumptions, lookup in a balanced binary tree is also O(1)
23:24:01 <MatrixFrog> wavewave: well yeah, otherwise it wouldn't be a hash table. good point
23:24:09 <kmc> but yeah this is being pedantic
23:24:12 <kmc> almost nobody uses flat hash tables in Haskell
23:24:18 <kmc> because they're not nice to use from pure functions
23:24:22 <MatrixFrog> kmc: how does that work? wouldn't it be O(log n)?
23:24:41 <kmc> the idea that fixed size pointers address all of your memory implies that you have a finite amount of memory
23:24:43 <edwardk> actually the pointer machine model doesn't get you O(1) there, just O(log n) it says nothing about how 'pointers' are structured =)
23:24:57 <kmc> heh okay, maybe I am not familiar with the pointer machine model
23:25:24 <kmc> almost nobody uses flat hash tables in Haskell because they're not nice to use from pure functions
23:25:40 <kmc> and there are alternatives which are nice to use from pure functions
23:25:43 <kmc> and are plenty fast
23:25:47 <wavewave> memory address operation becomes O(1) because we have 32 or 64 parallel addressing transistors.
23:25:54 <MatrixFrog> ok but they're still fun to reason about
23:25:57 <kmc> but they're only fast if you actually write the code and run it
23:26:09 <shachaf> kmc: That's what I was doing wrong? :-(
23:26:22 * shachaf has always found operations to be fast if you don't write the code.
23:26:23 <kmc> they're not fast if you make sweeping assumptions based on sophomore algorithms class
23:26:32 <kmc> which is why I'm always railing against asymptotic analysis and such
23:26:44 <pikhq> wavewave: Except memory addressing is not even vaguely constant time. :)
23:26:48 <edwardk> basically counter machines have no addressing, pointer machines, give you pointers you can dereference, so you can get what you draw on a blackboard when talking about lispish things. random access machine gives you pointer-relative addressing (which is what is needed for a hash table)
23:27:14 <edwardk> http://en.wikipedia.org/wiki/Register_machine
23:27:31 <MatrixFrog> pikhq, memory addressing could be constant wrt to the size of some particular hash table, couldn't it?
23:27:36 <pikhq> wavewave: A memory access can potentially cost *seconds*.
23:27:50 <pikhq> MatrixFrog: If and only if the entire hash table fits in L1 cache.
23:27:59 <wavewave> pikhq: just curious. in what situation?
23:28:07 <pikhq> wavewave: If the page is swapped out.
23:28:14 <pikhq> Say, your working set is larger than physical RAM.
23:28:25 <levi> wavewave: Clearly you have not experienced the joy of a heavily swap-thrashing machine... :)
23:28:28 <edwardk> wavewave: whenever a memory access isn't really a memory access ;)
23:28:31 <kmc> hard drives are incredibly slow
23:28:42 <wavewave> ah..yes... ..okay...
23:28:55 <pikhq> More commonly, a memory access can cost several thousand clock cycles *easily*.
23:29:01 <pikhq> If it's not in CPU cache.
23:29:08 <kmc> scale it up to human scale: if an arithmetic operation takes 1 second, then a hard drive access takes about 2 years
23:29:17 <djahandarie> It's the future guys, everyone has 10 gajillion terrabytes of RAM, who cares!
23:29:21 <kmc> imagine doing some maths on pencil and paper and then waiting 2 years for  the next number to add
23:29:30 <edwardk> levi: of course not. i'm prescient enough to magically set all my heap sizes and maintain perfect process control such that they never touch that damn dirty disk. *cough*
23:29:41 <pikhq> In the above analogy, RAM access would take a week.
23:29:45 <pikhq> (I think)
23:30:00 <levi> djahandarie: Yeah, except for that cheap virtual host out there where my web software runs...
23:30:17 <edwardk> djahandarie: to fake that i usually just try to live in a world where i keep everything in ram and farm it out across as many machines as needed to maintain that invariant. i'd rather pay for network than disk
23:31:07 <pikhq> And an L2 cache access, what, an hour?
23:34:36 <ddarius> edwardk's computer doesn't have a disk.
23:34:41 <ddarius> +even
23:34:45 <edwardk> ddarius: =)
23:35:04 <edwardk> SSD all the way ;)
23:35:10 <kmc> so hash tables aren't "O(1)", and they're not even any nice function of size, but rather something horrible that falls off a cliff at particular points
23:35:12 <wavewave> yeah.
23:35:24 <kmc> because the exact point of the hash is to destroy locality
23:35:40 <hpaste> o-_-o pasted “hsshellscript compile error” at http://hpaste.org/52679
23:35:43 <kmc> so as soon as it's bigger than L1 cache, you have tons of cache misses
23:35:55 <kmc> and likewise at each level of the hierarchy
23:36:08 <edwardk> kmc: well, you can retain some semblance of locality with tiered sorted linear hash tables.
23:36:15 <manjunaths> I got the above compile error when compiling hsshellscript, I am using latest ubuntu. Anyone know what might be wrong ?
23:36:23 <kmc> edwardk, I'll take your word for it :)
23:36:38 <Veinor> kmc: but if they're bounded above, then they're still O(1)
23:36:39 <edwardk> kmc: check my blog for 'sorted linear bloom filters'
23:36:56 <kmc> Veinor, yes, the universe is finite, blah blah
23:37:00 <edwardk> kmc: then extrapolate by dropping the bloom bits =)
23:37:05 <Veinor> i'm not saying 'the universe is finite'
23:37:21 <Veinor> i mean 'at worst you're going to hit disk and do a bounded amount of computation'
23:37:29 <edwardk> i tend to use hashing for things like bloom filters where i do get nice space guarantees
23:37:36 <edwardk> rather than for hash tables per se
23:37:58 <Veinor> like the performance does get worse as the size gets larger, but only up to a point
23:38:01 <kmc> at worst you're going to hit disk and waste 60,000,000 clock cycles
23:38:18 <wavewave> manjunaths: some shared library problem.
23:38:31 <Veinor> so? that's still O(1)
23:38:34 <Veinor> just with an annoyingly large constant
23:38:41 <edwardk> kmc writes all of his code in carefully structured van emde boas trees to maximize the performance of all his cache layers =P
23:38:49 <kmc> haha
23:38:58 <kmc> more like I use Data.HashMap and it's fast enough
23:39:03 <Veinor> man, veb trees are cool
23:39:04 <kmc> Veinor, I think you are proving my point quite well
23:39:17 <edwardk> actually that is a lie, he goes through and hand tunes for all the cache layers in his system
23:39:51 <MatrixFrog> manjunaths: as it says, it's using a deprecated ghc command line arg
23:40:08 <edwardk> kmc: well, i don't think anyone is arguing that you can ignore constant factors. hash tables do work for certain ranges of input sizes very nicely. other structures work well for different ranges of sizes, benchmark and test =P
23:40:10 <levi> He envisions his programs as Haskell code, and then compiles them to hand-tuned assembly in his mind before entering them in on an old-fashioned switch panel.
23:40:31 <MatrixFrog> manjunaths: i assume that line "ghc -ibuild:..." is coming from a makefile?
23:40:35 <kmc> i don't think anyone is disagreeing with anyone at this point
23:40:44 <Veinor> i do!
23:40:49 <kmc> oh yeah?
23:40:51 <edwardk> we're in violent agreement =P
23:40:54 * Veinor recurses
23:41:14 <Veinor> also it's a lot weirder discussing things on the internet with someone you've met in person
23:41:15 <mauke> manjunaths: it's missing a package in the command line
23:41:30 <edwardk> veinor: just so long as you do so with a small enough portion of your input that by the master theorem you will be done recursing in O(1) we're fine ;)
23:41:30 <mauke> manjunaths: probably easily fixable by editing the makefile
23:41:45 <MatrixFrog> "easily" being a relative term
23:42:04 <shachaf> Veinor: Whom did you meet in person?
23:42:28 <Veinor> i talked a bit with kmc and copumpkin at the last boshac; i saw edwardk but i didn't really talk with him
23:42:44 <shachaf> Are you going to the next BostonHaskell?
23:43:00 <edwardk> Veinor: next time say hello so i can put a face to a nick!
23:43:02 <Veinor> depends on when it is, but probably
23:43:11 <edwardk> (unless you did then i apologize) =)
23:43:16 <shachaf> Veinor: Oct 24
23:43:17 <Veinor> i didn't, no
23:43:39 <djahandarie> edwardk, he said hi to me and copumpkin :P
23:43:51 <Veinor> oh yeah, and djahandarie :P
23:43:54 <Veinor> anyway
23:43:56 <djahandarie> Oh
23:44:00 <djahandarie> Thanks for not listing me
23:44:02 <edwardk> djahandarie: great then between you two you can get me a composite sketch =)
23:44:07 * djahandarie looks hurt
23:44:08 <Veinor> haha
23:44:17 <Veinor> 24th is probably doable? depends on how well this group project goes
23:44:24 <djahandarie> Work on it harder!
23:44:32 <djahandarie> Group projects are stupid.
23:44:41 <djahandarie> Everyone else always sucks.
23:44:48 <Veinor> well, we haven't even started! so i have no clue
23:45:01 <shachaf> djahandarie: Try a semigroup project sometime. You need to lose your identity.
23:45:09 <kmc> haha bravo shachaf
23:45:11 <Veinor> ugggh
23:45:13 <djahandarie> Hahahah
23:45:27 <djahandarie> Man that nailed it
23:45:27 <kmc> i've had good and bad group projects
23:46:17 <Veinor> the project is basically to build a player for a subset of abc notation in java
23:46:23 <geheimdienst> @remember djahandarie Group projects are stupid <shachaf> Try a semigroup project sometime. You need to lose your identity.
23:46:24 <lambdabot> Okay.
23:46:30 <MatrixFrog> @google abc notation
23:46:31 <lambdabot> http://abcnotation.com/
23:46:31 <lambdabot> Title: abcnotation.com | home
23:46:40 <edwardk> Veinor: you should come next time, I'll be talking about trifecta =)
23:46:56 <kmc> edwardk, will you have slides?
23:46:56 <MatrixFrog> i guess that's a decent project :-/
23:46:56 <edwardk> shachaf: =)
23:47:01 <edwardk> kmc: probably
23:47:08 <kmc> cool, how will you make them?
23:47:13 <djahandarie> And dolio will be talking about homotopy type theory!!!! YES!!!!
23:47:19 * djahandarie dances
23:47:21 <Veinor> oh man
23:47:35 <Veinor> i really hope i can make it, in any case
23:47:36 <edwardk> kmc: but my slide decks tend not to have everything i'm going to say pasted up, just trees and diagrams, code and bullet points that i need to refer to
23:47:40 <edwardk> kmc: probably keynote
23:47:56 <kmc> ah yeah
23:47:59 <Veinor> it doesn't help that i have to leave for palo alto the day before the project's due
23:48:02 <kmc> mac weenie ;)
23:48:03 <Veinor> (the 28th)
23:48:06 <edwardk> kmc: =)
23:48:07 <shachaf> Veinor: You're coming to Palo Alto?
23:48:13 <shachaf> Veinor: What are you doing here?
23:48:16 <Veinor> palantir interview
23:48:25 <djahandarie> He's meeting up with you shachaf, didn't anyone tell you?
23:48:28 <Veinor> for a summer internship
23:48:29 <shachaf> Oh, pft. Palantir.
23:48:47 <shachaf> Do they even use Haskell?
23:49:01 <Veinor> doing QA work, which isn't exactly what i was gunning for but hey
23:49:04 <edwardk> kmc: i mostly use the mac because carrying the air doesn't throw out my bad shoulder ;)
23:49:17 <kmc> heh
23:49:22 <kmc> does keynote have good pdf export?
23:49:26 <Veinor> internship's an internship.
23:49:34 <edwardk> kmc: its decent, but it loses all the shiny transitions =)
23:50:01 <Veinor> there's probably a way to preserve those transitions in pdf
23:50:10 <Veinor> which i consider a bug, not a feature
23:50:14 <edwardk> you can export to a quicktime video with transitions, etc.
23:50:19 <kmc> haha
23:50:31 <Veinor> i had to digitally sign something for google in adobe reader
23:50:43 <kmc> yeah these days i don't bother with transitions or even sequential bullets
23:50:54 <edwardk> Veinor: well the problem is some of the slides wind up with 2-3 copies of the same slide in sequence if you do trickier transitions or want to hide certain text until you talk about it to avoid distracting the audience
23:51:17 <Veinor> ahhh
23:51:17 <edwardk> some of those things are actually more useful than just bouncing text into the screen and back out =)
23:52:02 <edwardk> most power point presentations suck because the presenter tries to put everything he is going to say on the slide so he can give the slides out later as a proxy for the talk
23:52:16 <edwardk> so you wind up with an audience half paying attention to you and half to the slides
23:52:37 <edwardk> i admit i do the same thing some times, but at least i know that i'm compromising the talk to shovel all the crap on the slides =)
23:52:40 <geheimdienst> "nice slides, but who was the clown standing there stammering"
23:52:46 <edwardk> geheimdienst: =)
23:53:38 <kmc> i prioritize the quality of slides because I figure more people will see them online
23:53:55 <kmc> and because it's a lot easier to tweak a document than to practice my oral presentation
23:54:10 <kmc> if the audience wants to ignore my yammering that's fine
23:54:12 <arcatan> solution: do a two set of slides, one for talking and one for online
23:54:13 <kmc> they can still ask me questions
23:54:16 <kmc> too much work
23:54:23 <arcatan> yeah
23:55:55 <geheimdienst> do your slides in deck.js or s5, export them for online by doing exactly nothing
23:56:32 <geheimdienst> (actually looks neat, i thought the other day http://imakewebthings.github.com/deck.js/ )
23:56:38 <kmc> that doesn't solve the problem edwardk was talking about, does it?
23:56:51 <kmc> maybe you did not suggest it does
23:57:29 <edwardk> kmc: one approach is to make the powerpoint slide deck you are going to use and then in the presenter's notes include what you want to say, and all the elaboration
23:57:43 <edwardk> kmc: that when someone downloads the slides they can read the notes associated with each slide
23:57:49 <edwardk> i used to do that when i was lecturing
23:57:55 <kmc> geheimdienst, ooh, pretty
23:58:27 <kmc> the problem I had with S5 is that the slides would only look good in the one browser at the one window/screen size I tuned for
23:58:58 <kmc> it had some crappy font autoscaling which would wreck the slide layout
23:59:06 <kmc> I want something that looks the same on every machine
