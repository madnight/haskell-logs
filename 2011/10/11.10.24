00:00:06 <byorgey> copumpkin: which paper are you talking about?
00:00:22 <copumpkin> the unpublished one someone linked to a few days ago
00:00:22 <copumpkin> hmm
00:00:34 <copumpkin> :P
00:00:57 <byorgey> copumpkin: yes, you can do that, but with [*] instead of List * of course
00:01:01 <copumpkin> oh yeah
00:01:09 <copumpkin> that sounds excellent
00:01:33 <byorgey> copumpkin: http://www.cis.upenn.edu/~byorgey/papers/haskell-promotion.pdf ?
00:01:45 <copumpkin> yeah, although it wasn't on your site
00:01:54 <copumpkin> I think I found it on dimitrios' one?
00:01:57 <byorgey> if it defined data List = ...  it was an old version
00:02:06 <copumpkin> yeah, it did
00:02:30 <copumpkin> http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
00:03:03 <copumpkin> oh
00:03:07 <copumpkin> looks like it's fixed now :P
00:04:04 <copumpkin> thanks!
00:04:05 <byorgey> hehe
00:05:25 <elliott> http://sprunge.us/cHaE ;; oh dear, this is starting to look worryingly useful :(
00:05:42 <elliott> I almost provided a runSupply until I realised it has a rather ridiculous type
00:05:48 <elliott> Supply s a -> s -> a
00:07:39 <byorgey> elliott: yes, this looks great =)
00:08:08 <byorgey> elliott: if you want to turn it into a Hackage package go right ahead
00:08:14 <elliott> except that i used existential quantification rather than rank-two types, oops...
00:08:39 <Cale> I don't understand why that type for runSupply is ridiculous
00:08:41 <byorgey> elliott: but if you want I would also be happy to do the dirty work of turning it into a proper package, adding instances for other mtl classes, etc.
00:08:55 <elliott> Cale: well, the idea of a supply is to have more than one value :-)
00:09:10 <tsanhwa> hi, how to convert Int type into Floating class
00:09:19 <Cale> oh, yeah, you'll need Enum at least for that :)
00:09:24 <byorgey> @quote fromIntegral
00:09:25 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
00:09:27 <byorgey> @quote fromIntegral
00:09:27 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
00:09:28 <Cale> Or an (s -> s) of course
00:09:46 <byorgey> tsanhwa: fromIntegral =)
00:09:57 <byorgey> @quote gonna.call
00:09:57 <lambdabot> No quotes match. I've seen penguins that can type better than that.
00:09:58 <Cale> > fromIntegral (67 :: Int) :: Float
00:09:59 <lambdabot>   67.0
00:10:02 <tsanhwa> byorgey: thanks :D
00:10:03 <Cale> > fromIntegral (67 :: Int) :: Double
00:10:04 <lambdabot>   67.0
00:10:29 <byorgey> @quote want.a.Double
00:10:29 <lambdabot> No quotes match. :(
00:10:34 * byorgey gives up
00:10:53 <elliott> byorgey: I'll play with this for a little longer to prove to myself that the added generality is worth it first :-)
00:11:02 <byorgey> elliott: ok, sounds good =)
00:11:48 <elliott> I like that it subsumes the monad for random values, though
00:13:09 <Cale> MonadPrompt should be more popular
00:13:16 <Blkt> good morning everyone
00:13:30 <Saizan> @quote who.do.you.call
00:13:30 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
00:13:38 <Cale> How can people like iteratees and not like MonadPrompt? It has crazy type signatures!
00:14:12 <byorgey> elliott: yeah, that's neat
00:14:45 <Cale> runRecPromptT :: forall p r b m. (r -> b) -> (forall a . p (RecPromptT p m) a -> (a -> b) -> b) -> (forall a . m a -> (a -> b) -> b) -> RecPromptT p m r -> b
00:14:51 <byorgey> ah, monochrom's quote was subtly different than my memory of it in just the right ways to thwart my search =P
00:15:18 <elliott> Cale: beautiful
00:15:26 <elliott> Cale: just needs a few typeclasses
00:16:30 <Cale> actually, with a few typeclasses, you could possibly make that easy to use
00:17:48 <elliott> hmm... maybe runSupplyT should actually have the more general type with Provide
00:18:00 <elliott> and runSupplyT should be called runSupplyTAction or something
00:18:15 <elliott> at least, everything in transformers seems to have a single field called runFooT
00:21:57 * byorgey -> bed
00:22:19 <elliott> oh, hey, Provide s m ~ m (s, Provide s m)
00:22:23 <elliott> no rank-whatever types required
00:22:36 <kmc> not even rank-1? ;)
00:22:41 <elliott> rank-0 :D
00:22:51 <kmc> rank-⊥
00:23:46 * hackagebot dns 0.3.0 - DNS libary in Haskell  http://hackage.haskell.org/package/dns-0.3.0 (KazuYamamoto)
00:25:56 <elliott> ah... something is very wrong here... my types are doing the impossible
00:26:55 <elliott> yeah... oops
00:27:14 <DanBurton> are you using -XAbsurdInstances again?
00:27:42 <elliott> :D
00:29:05 <yitz> @remember DanBurton are you using -XAbsurdInstances again?
00:29:05 <lambdabot> It is forever etched in my memory.
00:32:34 <ddarius> elliott: You may want to look at left Kan extensions.
00:33:14 <elliott> ddarius: Hey, I got no complaint, the impossible is happening.
00:33:18 <elliott> Nothing wrong with that.
00:42:07 <elliott> newtype SupplyT s m a = SupplyT (StateT (SupplyT s m s) m a) -- this has officially become confusing
00:46:22 <ddarius> Non-positive recursion is the best.
01:07:33 <fasta> Is there some rounding library where I can specify the number of digits to round to and that it needs to round 0.5 to 1 and 0.49 to 0 (or the same functionality in a more general way such that it works for any paritioning of one unit (e.g. 0.1, 0.25, etc.)?
01:11:16 <Sgeo|web> Is it possible to end up using the State monad in such a way that you end up violating a monad law?
01:11:53 <mm_freak> Sgeo|web: if you take semantics into account, then yes
01:12:11 <Saizan> mm_freak: how so?
01:12:52 <mm_freak> Saizan: just recently i found this on reddit:  http://www.reddit.com/r/haskell/comments/ll7y3/io_is_not_a_monad/
01:12:57 <Saizan> the monads laws talk about >>= and return, their properties won't change depending on how you use them
01:13:18 <yitz> fasta: it's pretty easy to do with existing prelude functions. i've never bothered even to look for a library.
01:14:31 <yitz> mm_freak: that discussion comes up over and over again. i started a long thread about that soon after i started learning haskell.
01:14:36 <Saizan> mm_freak: yeah, but either you care about that and the laws don't hold for State or you don't and they do, how you use State doesn't matter
01:14:39 <Cale> fasta: but do you want to round 1.5 to 1 or 0? :)
01:14:45 <Cale> er, 1 or 2
01:14:52 <fasta> Cale: 2
01:15:11 <fasta> Cale: no, 1.5
01:15:19 <Cale> Okay, so you're rounding up, not rounding to odd
01:15:21 <yitz> > map round [0.5,1.5..10.5]
01:15:22 <lambdabot>   [0,2,2,4,4,6,6,8,8,10,10]
01:15:31 <Cale> round will round to even
01:15:40 <Cale> (which reduces bias)
01:15:58 <yitz> > map (floor . (+ 0.5)) [0.5,1.5..10.5]
01:15:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
01:16:08 <yitz> > map (ceiling . (+ 0.5)) [0.5,1.5..10.5]
01:16:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
01:16:21 <yitz> oh
01:16:33 <Sgeo|web> Can I put into Hackage a package that depends on an opaque .dll or .so from another source?
01:16:36 <yitz> > floor (-0.5)
01:16:37 <lambdabot>   -1
01:16:55 <Cale> Sgeo|web: yes
01:17:08 <fasta> yitz: 0.5 should map to 0.5.
01:17:10 <mm_freak> yitz, Saizan: yes, just like said in the thread, it depends on how far you go with the scope of the laws
01:17:12 <Cale> (there are many such things on hackage)
01:17:14 <yitz> > map (ceiling . subtract 0.5) [0.5,1.5..10.5]
01:17:15 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
01:17:45 <mm_freak> i find them useful, but wouldn't bet my head on them…  at least for function-based monads
01:17:55 <mm_freak> the laws hold in presence of seq for Maybe
01:18:01 <mm_freak> but they don't hold for State/Reader
01:18:31 <yitz> mm_freak: i used to think that using .! instead of . makes Hask a category, but i'm not sure even about that anymore
01:18:54 <mm_freak> yitz: what's wrong with (.)?
01:19:15 <yitz> where (.!) f g x = f `seq` g `seq` f (g x)
01:20:19 <yitz> mm_freak: the category laws don't hold when you throw in undefined and seq
01:20:38 <yitz> mm_freak: i think. need to remember exactly what goes wrong...
01:21:09 <Cale> If you allow seq on functions, it breaks lots of stuff semantically
01:21:18 <Cale> But you're meant to ignore that :)
01:22:21 <quicksilver> I think you're supposed to (1) ignore seq and (2) assume the only equality which matters is observational equality of non-_|_ values
01:22:26 <quicksilver> (for the purpose of checking laws)
01:22:32 <yitz> Cale: if there were a way to make it work by modifying . i would be happier, but i'm not sure it's possible anymore.
01:23:11 <Cale> well, there's obviously no identity then
01:23:26 <Cale> hmm
01:23:51 <Cale> Oh, I just saw your strict version, hrm
01:25:24 <mm_freak> i'm not even sure what seq on functions does, when the function is defined
01:25:39 <Cale> It forces it to be a lambda, basically
01:26:00 <mm_freak> yes, but can a function be unevaluated?
01:26:25 <yitz> mm_freak: yes
01:26:27 <Cale> A term is in weak head normal form if it is a lambda, or consists of a data constructor applied to some arguments.
01:28:00 <Cale> Operationally, seq x y causes x to be put in weak head normal form before making the result of evaluating y available as its result
01:28:01 <mm_freak> seems like composition is the only case, where a lambda can be unevaluated, at least in GHC
01:28:19 <Cale> lots of functions can be unevaluated
01:28:23 <Cale> map head
01:28:34 <mm_freak> > foldl (.) id (repeat sin) `seq` ()
01:28:37 <Cale> this isn't a lambda, it's an application
01:28:38 <lambdabot>   mueval-core: Time limit exceeded
01:28:45 <Cale> so it needs to be expanded
01:28:50 <mm_freak> i see
01:28:59 <mm_freak> ok, it makes sense
01:30:34 <quicksilver> case x of Foo -> \x -> 1
01:30:40 <mm_freak> is there a difference between NF and WHNF for functions?
01:30:43 <quicksilver> well, bad choice to use x in both places :)
01:30:51 <quicksilver> but that's another example.
01:30:54 <quicksilver> mm_freak: yes
01:31:07 <quicksilver> in NF you reduce under lambdas as well
01:31:21 <mm_freak> > map undefined `seq` ()
01:31:21 <Cale> as well as reducing the arguments to a constructor
01:31:22 <lambdabot>   ()
01:31:24 <mm_freak> > map undefined `deepseq` ()
01:31:25 <lambdabot>   Not in scope: `deepseq'
01:31:36 <quicksilver> \x -> 4+5 -- in WHNF but not NF
01:31:41 <fasta> mm_freak: \x -> y + y vs \x -> 6
01:31:45 <quicksilver> NF would be \x -> 9, but haskell never does that
01:32:17 <mm_freak> is there a formal definition of NF for lambdas?
01:32:27 <quicksilver> of course.
01:32:37 <mm_freak> NF = fully beta-reduced?
01:32:40 <fasta> quicksilver: can't that lead to problems, btw?
01:32:41 <kmc> the formal definition of normal form is a term in which no reduction rule applies anywhere
01:32:49 <mm_freak> ok, i see
01:32:52 <kmc> (a general definition that works for all term-rewriting systems)
01:32:52 <quicksilver> but it's not a special definition for lambdas
01:32:59 <yitz> > let r = (/2) . floor . (+ 0.5) . (*2) in map r [0.25,0.5..10]
01:32:59 <quicksilver> it's the same definition for all shapes of term
01:33:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:33:00 <lambdabot>    `GHC.Real.Fractional a'
01:33:00 <lambdabot> ...
01:33:11 <fasta> quicksilver: I never had them, but I can imagine huge expressions to possibly cause issues.
01:33:16 <quicksilver> fasta: probably :)
01:33:25 <yitz> > let r = (/2) . floor . (+ 0.5) . (*2) in map r [0.25,0.5..10] :: [Float]
01:33:25 <Cale> Nobody is talking about head normal form :)
01:33:26 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Float)
01:33:26 <lambdabot>    arising from a use o...
01:33:28 <mm_freak> so in a strict language, running the program is actually evaluating to NF?
01:33:39 <fasta> Look at the abstractions! Oh, look at the memory leaks!
01:33:42 <kmc> not necessarily
01:33:49 <kmc> "strict languages" usually have some special-case lazy stuff
01:33:49 <yitz> > let r = (/2) . fromIntegral . floor . (+ 0.5) . (*2) in map r [0.25,0.5..10]
01:33:49 <Cale> mm_freak: No, even strict languages tend not to evaluate underneath lambdas
01:33:50 <quicksilver> fasta: certainly putting \x -> repeat 1 into normal form would be a waste of space
01:33:51 <lambdabot>   [0.5,0.5,1.0,1.0,1.5,1.5,2.0,2.0,2.5,2.5,3.0,3.0,3.5,3.5,4.0,4.0,4.5,4.5,5....
01:33:51 <kmc> like boolean operators
01:33:55 <Cale> because it's a bitch to implement
01:34:07 <quicksilver> fasta: (unless you are very careful to put it into cyclic form, but for more complex examples)
01:34:13 <mm_freak> i see
01:34:33 <quicksilver> strict languages also do not reduce under lambdas
01:34:35 <quicksilver> in my experience.
01:35:50 <yitz> > let r = (/2) . fromIntegral . round . (*2) in map r [0.25,0.5..10]
01:35:52 <lambdabot>   [0.0,0.5,1.0,1.0,1.0,1.5,2.0,2.0,2.0,2.5,3.0,3.0,3.0,3.5,4.0,4.0,4.0,4.5,5....
01:36:20 <yitz> > let r = (/2) . fromIntegral . ceiling . subtract 0.5 . (*2) in map r [0.25,0.5..10]
01:36:22 <lambdabot>   [0.0,0.5,0.5,1.0,1.0,1.5,1.5,2.0,2.0,2.5,2.5,3.0,3.0,3.5,3.5,4.0,4.0,4.5,4....
01:36:44 <mm_freak> Cale, quicksilver:  is that because of some non-strict functions (or rather constructs) like (&&)?
01:36:56 <mm_freak> or is there a deeper reason?
01:37:08 <quicksilver> I'm not sure it's deep, it's just practical
01:37:21 <quicksilver> even in strict languages people do not expect functions to be evaluted before they are called
01:37:33 <quicksilver> perhaps that's "especially" in strict languages.
01:37:42 <quicksilver> in strict languages people use functions to control what gets evaluated when.
01:37:55 <quicksilver> although you can make the same comment about the two branches of an 'if' statement.
01:39:47 <fasta> quicksilver: why is if an analogue?
01:40:12 <mm_freak> suppose that you have only the pure lambda calculus with strict evaluation…  is there still a difference between running and reducing to normal form?  i'd say that "running" is actually this beta-reduction, at least that was my intuition
01:41:08 <fasta> mm_freak: running means reducing to a normal form via some algorithm.
01:41:43 <fasta> mm_freak: beta-reduction is just one kind of reduction, there are more.
01:42:09 <quicksilver> fasta: because (even in a strict language) you don't expect the then/else branches to be reduced early
01:42:30 <mm_freak> alright
01:42:34 <quicksilver> fasta: you expect to wait until the condition is ready to evaluate and check, and then you only reduce one branch.
01:42:47 <quicksilver> this is particular important in impure strict languages (i.e. all of them)
01:42:49 <fasta> quicksilver: on a many core system, I would actually expect it.
01:43:05 <quicksilver> that's at completely the wrong level of abstraction
01:43:11 <dolio> 'Running' typically doesn't evaluate under binders.
01:43:12 <quicksilver> I'm not going to talk about branch prediction.
01:43:39 <dolio> Normalization does.
01:44:04 <mm_freak> quicksilver: how could you completely reduce early anyway, if the reduction depends on the bound variable?  when does early reduction improve things?  reducing both branches of an 'if' early sounds like wasting computation time for a result, which you drop away anyway
01:44:07 <fasta> quicksilver: as a space optimization Haskell could possibly even overwrite its own code if it can prove that some code will run at most once.
01:44:24 <quicksilver> mm_freak: I'm not arguing you *should* do it.
01:44:25 <mm_freak> ok, parallelism is a good point
01:44:37 <quicksilver> mm_freak: I'm just pointing out to you it's yet another case in which running a program is not reducing to NF.
01:44:59 <quicksilver> because normalization would reduce even under the branches of an if, where possible.
01:45:31 <quicksilver> there certainly are limited interesting cases where it's possible, and modern out-of-order CPUs are one such case
01:45:40 <quicksilver> but they can isolate and rollback the sideeffects
01:45:57 <quicksilver> and really execution on a modern CPU is not much like normalizing lambda calculus
01:46:13 <mm_freak> quicksilver: is it required to reduce everything for it to be an NF reduction?
01:46:28 <quicksilver> I don't know what "an NF reduction" means.
01:46:35 <mm_freak> a reduction to NF
01:46:41 <quicksilver> Normal Form means every rule which can be applied is applied.
01:46:49 <quicksilver> so, yes, *everything* is precisely what is required.
01:47:05 <quicksilver> "a reduction" normally means a single step, btw. Just for clarity of communication.
01:47:05 <mm_freak> is it because of the possibility for infinite recursion?
01:47:15 <quicksilver> is what because of that possibility?
01:47:26 <mm_freak> that you need to reduce everything
01:47:30 <quicksilver> no.
01:47:34 <quicksilver> it's not because anything.
01:47:36 <quicksilver> it just is.
01:47:38 <quicksilver> that's what NF means.
01:47:41 <mm_freak> alright
01:47:46 <quicksilver> if it was anythign else, it would be something else.
01:48:57 <elliott> Well... it's almost a library now: https://github.com/ehird/supply-monad/blob/master/Control/Monad/Trans/Supply.hs
01:49:04 <quicksilver> a term rewritign system admits a normal form if every possible sequence of reduction steps ultimately leads to a place where you can't get any further - a 'normal form'
01:49:24 <quicksilver> if it doesn't matter which steps you take first it's called 'strongly normalizing'
01:49:29 <quicksilver> which is closely related to 'confluent'
01:49:43 <mm_freak> i'm asking because of this:  if True then x else undefined
01:49:47 <Sgeo|web> I'm still not sure what the use of Supply is?
01:49:54 <elliott> Cale: Turns out the generalised form is actually: newtype SupplyT s m a = SupplyT (StateT (SupplyT s m s) m a)
01:50:02 <elliott> Cale: As mind-bending as that is :-)
01:50:03 <mm_freak> in a strict language, i would guess that the NF is undefined
01:50:05 <dolio> You can have normal forms without being strongly normalizing.
01:50:14 <elliott> Sgeo|web: Consider, e.g. allocating unique identifiers.
01:50:14 <mm_freak> in a lazy language given your rules it's also undefined
01:50:22 <mm_freak> s/lazy/non-strict/
01:50:31 <Sgeo|web> As in, what it does
01:50:47 <quicksilver> dolio: yes, I tried to say "if it doesn't matter which step you take first" then it's strong normalizing
01:50:50 <mm_freak> Sgeo|web: is it comonadic?
01:50:53 <dolio> Ah, okay.
01:50:58 <quicksilver> meaning, if you always get to the same normal form whichever way you go
01:51:16 <quicksilver> mm_freak: I think it's strange to try to distinguish strict/lazy here
01:51:30 <quicksilver> mm_freak: the normal form of that term is 'x' in most sensible languages
01:51:37 <dolio> I'm actually not sure if strongly normalizing implies confluent.
01:51:39 <kmc> "strict" and "lazy" don't even refer to the same kind of thing
01:51:52 <Sgeo|web> mm_freak: What's a comonad?
01:51:53 <quicksilver> because the if-reduction rule applies, so you apply it.
01:51:55 <dolio> You could conceivably have every reduction strategy reach a normal form, but not necessarily the same normal form.
01:52:36 <kmc> strict and non-strict are different denotational semantics for the lambda calculus — in particular, some terms have denotation ⊥ under strict semantics which have another denotation under non-strict
01:52:36 <quicksilver> dolio: hmm you're right. Too many related definitions and I'm rusty.
01:52:37 <dolio> Of course, people typically try to have confluence.
01:53:18 <kmc> eager and lazy are different operational semantics, i.e. implementation strategies, for implementing strict and non-strict semantics respectively
01:53:26 <kmc> but they're not the only possible implementation strategies
01:54:01 <dolio> You can have (arguably) eager non-strict strategies, too.
01:54:09 <dolio> Where you evaluate for a while, and then give up.
01:54:15 <kmc> *nod*
01:54:33 <kmc> i think those are often called "speculative"
01:55:06 <blackdog> kmc: or lenient? or is that something different?
01:55:14 <kmc> i don't know that one
01:55:37 <blackdog> http://www.haskell.org/haskellwiki/Lazy_vs._non-strict
01:55:42 <blackdog> "Lenient, or optimistic, evaluation is an implementation approach that lies somewhere between lazy and strict, and combines eager evaluation with non-strict semantics. "
01:55:47 <dolio> "Optimistic" was one of the coined terms, I think.
01:56:00 <kmc> interesting
01:56:54 <dolio> That's one of the eager Haskells I'd actually be interested in seeing.
01:57:11 <dolio> Since it seems to cover a lot of common cases where people sprinkle in seq.
01:57:30 <kmc> so you compute eagerly (and probably in parallel), but you don't actually commit to that ⊥ until it's forced by non-strict semantics
01:57:53 <dolio> Without ruining all the nice infinite stuff.
01:58:06 <kmc> that idea also reminds me of lub / glb, but I don't know what the precise connection is
01:58:08 <dolio> Maybe it ruins a lot of common infinite cases, though.
01:58:48 <dolio> "Let me force 1 gig of your input list for you."
01:58:55 <kmc> i'm afraid that instead of sprinkling seq you'd now have to sprinkle annotations to the effect of "don't force this, it's a waste of time"
01:59:21 <kmc> i wonder if these things could be profile-directed
01:59:29 <quicksilver> it sounds hard to get the heurtistics right
01:59:37 <quicksilver> but I think you'd have to play with it to see
01:59:39 <elliott> kmc: unseq?
01:59:45 <mm_freak> Sgeo|web: a comonad is like a monad, but with the arrows turned around…  where a monad is (a -> m a, m a -> (a -> m b) -> m b), a comonad is (w a -> a, w a -> (w a -> b) -> w b)
01:59:45 <elliott> (unseq a b) evaluates b without evaluating a
01:59:47 <kmc> so that over time it develops a better heuristic idea of what to force and when
01:59:50 <fasta> Debugging something like that would likely also be 'fun'.
02:00:05 <elliott> profile-directed strictness sounds awesome
02:00:11 <elliott> someone give ghc that :p
02:00:23 <kmc> i wish we had a good model implementation of an STG-like machine
02:00:26 <mm_freak> Sgeo|web: in a monad it's always safe to "put in" (return :: a -> m a), in a comonad it's always safe to "pull out" (extract :: w a -> a)
02:00:31 <mm_freak> that's the basic idea
02:00:33 <kmc> which was easy to hack on
02:01:05 <elliott> kmc: I suspect that it's hard to tell where seqs are _missing_ from a profile though
02:01:07 <kmc> something which is not intended for great performance, but for performance which will accurately predict GHC performance
02:01:12 <elliott> it seems easy enough to tell where they shouldn't have been done
02:01:12 <fasta> Can ghc already be loaded into ghci?
02:01:19 <elliott> but unless you actually try, how can you know seq would have helped...
02:01:34 <kmc> so that you can easily try out weird evaluation models, and know whether they're worth the effort of hacking into ghc
02:02:06 <kmc> wishes & fishes & etc.
02:02:10 <kmc> going to sleep now, 'night all
02:02:15 <ddarius> elliott: Profiling would not really help much for strictness analysis.
02:02:29 <mm_freak> Sgeo|web: for example a function of type 'a -> b' together with a value of type 'a' is a store comonad…  extraction is just application of the value
02:02:33 <elliott> Ruining my dreams :(
02:02:48 <mm_freak> Sgeo|web: a fixed size array with an index is also a comonad
02:02:59 <mm_freak> another form of store
02:03:58 <Sgeo|web> I think I understand what a comonad is but not those examples
02:03:58 * hackagebot splot 0.2.4 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.2.4 (EugeneKirpichov)
02:04:01 <fasta> I think it is a step in the wrong direction, if you have to let the run-time system figure out what you want.
02:04:19 <fasta> Programming is about telling the computer what to do, not telling it to figure out what to do.
02:04:50 <fasta> If you are building a NLP system as a front-end, that's OK, but it still has to compile to actual instructions in the end.
02:05:06 <olsner> programming is about getting something done, the "telling a computer what to do" part is the thing we're trying to minimize really
02:05:08 <fasta> Mathematica has implemented something like that.
02:05:20 <Sgeo|web> http://hackage.haskell.org/packages/archive/unamb/0.2.4/doc/html/Data-Unamb.html
02:05:23 <fasta> olsner: but it is a flawed concept.
02:05:25 <Sgeo|web> Is unamb unsafe?
02:05:39 <fasta> olsner: there are no 'high-level' or 'low-level' languages.
02:06:03 <dolio> Yes.
02:06:14 <Sgeo|web> Why isn't it called unsafeUnamb?
02:06:15 <olsner> well, hmm, not "programming is about", but the reason someone embarks on programming is usually/sometimes because something needs getting done
02:06:38 <fasta> olsner: and a simple run-time model is useful for that.
02:06:48 <fasta> (exactly the reason like C)
02:07:14 <fasta> Well, with all the fragmentation, there already is some problem with C.
02:08:05 <elliott> Sgeo|web: unamb is safe if you satisfy the precondition. Like a lot of things.
02:08:15 <elliott> But it's easier to satisfy unamb's precondition than, e.g. unsafePerformIO's, by a long shot.
02:08:32 <fasta> elliott: unsafePerformIO has no known precondition.
02:08:44 <elliott> fasta: Yes it does: the computation has no side-effects.
02:09:05 <elliott> unsafePerformIO (return ()) is certainly safe.
02:09:21 <fasta> elliott: where is this specification?
02:09:35 <Sgeo|web> But there may be cases where the computation has side-effects yet it's still safe enough?
02:09:44 <Sgeo|web> e.g. Debug.Trace.trace
02:09:50 <Sgeo|web> Has an unobservable side-effect
02:10:04 <elliott> ?quote unsafePerformPrintfDebugging
02:10:04 <lambdabot> No quotes match. Just try something else.
02:10:06 <elliott> darn
02:10:08 <o-_-o1> Hello
02:10:14 <Sgeo|web> elliott: I just saw that somewhere
02:10:39 <Sgeo|web> http://stackoverflow.com/questions/3893202/departmental-restriction-against-unsafeperformio
02:10:48 <Sgeo|web> unsafePerformPrintfDebugging
02:10:51 <o-_-o1> Why doesn't this work ? map (=~ "[0-9]+"::String) (lines a)
02:11:02 <elliott> fasta: Well, there's a long list of preconditions in base's System.IO.Unsafe documentation, if you want the GHC implementation point of view.
02:11:15 <elliott> Finding the official word now...
02:11:15 <fasta> elliott: GHC!=Haskell
02:11:29 <elliott> fasta: Yes, that would be why I explicitly qualified my statement.
02:11:36 <elliott> And then said I was searching for the spec's POV.
02:11:44 <o-_-o1> Rather this : map (=~ ("[0-9]+"::String)) (lines a)
02:11:51 <fasta> elliott: you didn't say that the first time.
02:12:01 <elliott> o-_-o1: Because that's ((=~ "[0-9]+") :: String)
02:12:03 <elliott> fasta: Which first time?
02:12:10 <elliott> "if you want the GHC implementation point of view" is pretty clear if you ask me...
02:12:14 <fasta> elliott: also, unless Haskell 2010 changed it, unsafePerformIO has no semantics.
02:12:39 <fasta> elliott: "Yes it does: the computation has no side-effects."
02:12:46 <fasta> elliott: no, it doesn't.
02:12:58 <elliott> fasta: I said that because I was pretty sure I've read that in the Report or the FFI addendum.
02:13:36 <mm_freak> a (IOVector a, Set Int) makes a fixed size map with O(1) lookup, O(log n) insert and O(n) space usage…  is there a name for this structure?
02:13:40 <fasta> elliott: you can be sure and wrong at the same time. Perhaps I am wrong, but again, that's only the case if they changed it in 2010.
02:14:16 <fasta> Symbols without specification are such a bad idea.
02:14:33 <fasta> It will get you right into Python territory.
02:14:46 <ddarius> @where ffi
02:14:46 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
02:14:53 <fasta> "We didn't like the previous semantics, so now we are going to break all your programs."
02:14:56 <elliott> fasta: unsafePerformIO :: IO a -> a
02:14:56 <elliott> Return the value resulting from executing the IO action. This value should be independent of the environment; otherwise, the system behaviour is undefined.
02:14:56 <elliott> If the IO computation wrapped in unsafePerformIO performs side effects, then the relative order in which those side effects take place (relative to the main IO trunk, or other calls to unsafePerformIO) is indeterminate. Moreover, the side effects may be performed several times or not at all, depending on lazy evaluation and whether the compiler unfolds an enclosing definition.
02:14:56 <elliott> Great care should be exercised in the use of this primitive. Not only because of the danger of introducing side effects, but also because unsafePerformIO may compromise typing; to avoid this, the programmer should ensure that the result of unsafePerformIO has a monomorphic type.
02:15:17 <elliott> Looks like semantics to me.
02:15:29 <elliott> And that's from the FFI addendum, so _not_ 2010.
02:15:55 <ddarius> The FFI addendum is part of 2010.
02:15:55 <saulzar> > parse (many (many letter >> eol) >> string "done" >> eof) "test" "test\test\ndone"
02:15:56 <lambdabot>   Not in scope: `parse'Not in scope: `letter'Not in scope: `eol'Not in scope:...
02:16:19 <o-_-o1> Figured it out thanks
02:16:22 <fasta> elliott: ok, in your case of returning a pure value, that's the case, but for its main use case, it has no semantics.
02:16:23 <elliott> ddarius: I meant re: "Perhaps I am wrong, but again, that's only the case if they changed it in 2010."
02:16:59 <elliott> fasta: Well, if you're just going to change the goalposts... but anyway, the definition I quoted clearly addresses the cafe of the IO action passed to unsafePerformIO having side-effects.
02:17:30 <fasta> elliott: and it says that it can be executed _zero_ times.
02:17:41 <fasta> elliott: which is not what you want.
02:17:42 <elliott> fasta: Obviously referring to the case where the value isn't forced...
02:17:49 <fasta> elliott: it doesn't say that.
02:18:10 <elliott> fasta: The Haskell Reports are not exactly the most formal things on earth; if you want to be a pedant you can make the language say whatever you want.
02:18:13 <fasta> elliott: you won't find crappy definitions like that in the C++ standard.
02:18:19 <elliott> OK, you're just trolling ...
02:18:29 <quicksilver> he is, yes.
02:18:34 <quicksilver> I would stop taking the bait.
02:18:38 <elliott> I intend to.
02:18:52 <fasta> I am just stating facts.
02:19:27 <fasta> That you happen to prefer some 'but everyone knows what it means'-semantics is a different issue entirely.
02:19:49 * elliott notes, for anyone listening in, that if the value unsafePerformIO returns is forced, then the IO action must be performed once, since the value is defined to be the result of executing the IO action.
02:19:57 <elliott> Now, on to other things.
02:20:15 * Sgeo|web buys fasta a DeathStation 9000
02:21:07 <ddarius> If someone was going to point at a language standard that actually doesn't have "meaningless" definitions, the obvious (and pretty much only) choice is SML.
02:21:39 <Sgeo|web> I've heard good things about SML
02:21:43 * elliott thinks unsafePerformIO is pretty rigorously defined there; more than I was expecting, actually.
02:21:43 <Sgeo|web> SML's module system
02:21:48 <fasta> ddarius: strictly speaking even that is not completely true.
02:22:05 <fasta> ddarius:(since many bugs are known)
02:22:28 <fasta> ddarius: perhaps now there is a correct version somewhere, but you cannot just read it if you want.
02:22:39 <fasta> You have to apply errata on top of errate to check that.
02:22:46 <fasta> errata*
02:23:37 <fasta> x86 and perhaps some other machine languages are the only completely formalized languages that I know of.
02:26:22 <fasta> It's quite amazing that 30+ years of PL research didn't even result in one bug-free language specification.
02:27:03 <Sgeo|web> http://dspace.dial.pipex.com/town/green/gfd34/art/ I love this
02:44:24 <JuanDaugherty> kmc, you're not a ghc developer are you?
02:44:26 * Sgeo|web ponders writing ([a] -> b) -> a -> a -> a -> a -> ... -> b
02:44:44 <Sgeo|web> It wouldn't look like that, presumably, but use a typeclass, right?
02:44:54 <rostayob> Sgeo|web: you want to write an infinite type?
02:45:09 <rostayob> i missed the first part of the discussion i'm afraid :P
02:45:26 <Sgeo|web> What first part of the discussion?
02:45:41 <rostayob> well i just joined this channel and you probably said something before i did
02:45:50 <Sgeo|web> No, I didnt
02:45:59 <Sgeo|web> Well, I did, but nothing relevant to what I just said
02:46:39 <rostayob> oh. so, you want to write a typeclass to apply functions with the same number of aruments of the given list?
02:46:59 <ivanm> dammit, I just realised why MPTC+FDs are better than TFs: I want to use the same associated type alias in two different classes! :p
02:47:05 <erus`> fasta: what does PL mean in that context?
02:47:25 <Sgeo|web> Maybe I should write my code and see what happens
02:47:26 <rostayob> you have to encode the list length that way, which is tricky. you're better off with tuples if i understand what you mean
02:48:18 <fasta> erus`: have you heard of this thing called Google?
02:48:25 <Sgeo|web> Can I have an empty class definition, no, I can't, I think
02:48:27 <Sgeo|web> Bluh
02:48:43 <Sgeo|web> Well, I probably can, but that makes me realize my thoughts are useless
02:48:45 <JuanDaugherty> rostayob, it's a (publicly) logged channel
02:48:54 <Sgeo|web> Tempted to cheat and peek at printf
02:48:59 <thoughtpolice> erus`: PL = programming language, generally people say 'PL research' or 'PLT' (the 'T' is for 'theory' in that case)
02:49:13 <Sgeo|web> PLT reminds me of Racket
02:49:33 <erus`> fasta: Who hurt you?
02:49:33 <rostayob> with tuples it's easy
02:49:57 <rostayob> Sgeo|web: mhm? I'm pretty sure you can generalize function application with the tuple elements as arguments with type classes
02:49:59 <Sgeo|web> rostayob: but not as fun
02:50:04 <Sgeo|web> Oh
02:50:10 <fasta> erus`: are you a woman?
02:50:10 <Sgeo|web> That was for your with tuples
02:50:28 <rostayob> Sgeo|web: i don't follow you :P
02:51:11 <Sgeo|web> rostayob: I'm doing this for entertainment
02:51:18 <Sgeo|web> Although I nreally should be sleeping right now
02:52:05 <rostayob> Sgeo|web: wait i'm writing it down :P
02:53:09 <elliott> erus`: don't feed the troll
02:56:53 <saulzar> I'm trying to parse a bunch of lines of settings - a string followed by values, terminated by "ready"  - struggling, I assume because the string part overlaps with "ready"
02:57:05 <saulzar> parse (many (many (letter >> spaces >> number >> eol)) >> string "ready" >> eof) "test" test 4\ntest 3\nready"
02:58:11 <ClaudiusMaximus> @hoogle endBy
02:58:12 <lambdabot> Text.Parsec.Combinator endBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
02:58:12 <lambdabot> Text.ParserCombinators.ReadP endBy :: ReadP a -> ReadP sep -> ReadP [a]
02:58:12 <lambdabot> Text.ParserCombinators.Parsec.Combinator endBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
02:58:30 <hpaste> elliott pasted “magic” at http://hpaste.org/53054
02:58:34 <elliott> Sgeo|web: see above
02:58:39 <elliott> it's hard to make polymorphic though
02:59:14 <hpaste> rostayob pasted “whatever” at http://hpaste.org/53055
02:59:22 <saulzar> ClaudiusMaximus: Ahh - thanks!
02:59:25 <rostayob> Sgeo|web: http://hpaste.org/53055 voila!
03:00:11 <saulzar> I assume I would need to use something lower level than the "many" to resolve the issue
03:00:30 <saulzar> But I guess that does exactly what I want
03:00:48 <elliott> rostayob: that's not variadic though
03:00:50 <elliott> mine is
03:00:55 <elliott> (but not polymorphic)
03:00:58 <ClaudiusMaximus> it might do what you want, i'm a bit of a parsec n00b so i don't know how it handles overlap
03:01:13 <rostayob> elliott: with lists it's ugly
03:01:15 <rostayob> but yes
03:01:28 <Sgeo|web> How long do hpastes stay?
03:01:33 <Sgeo|web> And what's FlexibleInstances?
03:01:49 <rostayob> elliott: I think that what he wanted is to apply a n-elements list to a n-arguments function
03:01:54 <elliott> Sgeo|web: forever
03:02:14 <elliott> Sgeo|web: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html
03:02:20 <elliott> grep /FlexibleInstances/
03:02:47 <rostayob> btw, is there a way to express (a -> b ->)?
03:02:47 <elliott> rostayob: that's the opposite of what he says
03:02:51 <elliott> rostayob: esp. since he mentioned looking at printf
03:02:58 <rostayob> elliott: ah, ok. i misunderstood then
03:03:09 <elliott> <rostayob> btw, is there a way to express (a -> b ->)?
03:03:12 <elliott> not without a data-type wrapper
03:03:15 <rostayob> elliott: ok
03:03:37 <ClaudiusMaximus> hmm, there are anchors in the html like http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#flexible-instance-head but seems no way to find them without looking at the source
03:03:57 <elliott> *Main> case magic' concat of Step f -> case f "Hello, " of Step g -> case g "world!" of End r -> r
03:03:58 <elliott> "Hello, world!"
03:03:59 <Sgeo|web> Ok, so the functiont aht does that conversion is written as the class function, that makes sens
03:04:01 <Sgeo|web> e
03:04:05 <elliott> Sgeo|web: I feel this example may be less compelling to you
03:04:08 <elliott> (but it's polymorphic :p)
03:04:21 <elliott> ooh, I bet I could do something with type families...
03:04:44 <Sgeo|web> I should go do homework or something
03:04:56 <Sgeo|web> Since I've decided to not sleep and stuff
03:05:11 <donri> ClaudiusMaximus: or http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
03:05:39 <rostayob> Sgeo|web: http://okmij.org/ftp/Haskell/polyvariadic.html
03:05:44 <rostayob> enter oleg
03:06:14 <ClaudiusMaximus> donri: ah thanks; still would be nice to have a little "link to this section" right on the page
03:06:34 <donri> sure, like sphinx does
03:06:50 <donri> also i friggin hate the section body tooltips docbook does for html
03:07:01 <TaTonka> hey, can anyone help me? i'm new to haskell, and i have to learn it for university. I have to do an excercise task, and now i am confronted with rigid type variables. What does this mean?
03:07:22 <Mauke> TaTonka: is this an error message?
03:07:30 <elliott> bah, no dice
03:07:48 <TaTonka> Mauke: yes. i get it when i try to load the module in ghci
03:07:56 <Sgeo|web> Ooh, arguments don't have to be the same type
03:07:58 <Sgeo|web> But is that safe?
03:08:21 <saulzar> ClaudiusMaximus: Hmm - manyTill seems like the one which works here, endBy gives the same error. Not quite sure what the distinction is
03:08:23 <Mauke> TaTonka: I don't know what rigid type variables are, but I can interpret error messages. can you post the source and error message somewhere?
03:08:37 <donri> likely http://stackoverflow.com/questions/4629883/rigid-type-variable-error
03:09:34 <saulzar> Oh I see - endBy is separated by the parser, manyTill just uses it to end the list
03:10:21 <TaTonka> Mauke: http://hpaste.org/53056
03:10:45 <Cale> TaTonka: A rigid type variable during type inference is one which can't be substituted for a more concrete type, probably because some explicit type signature the user gave insists that it remain polymorphic.
03:11:42 <TaTonka> well, the type signature of prependNTimesToList is the signature, which ghci gave me with :t
03:12:07 <donri> TaTonka: in (xs:x) "x" is a list
03:12:10 <Cale> TaTonka: In this case, one problem is that you're using x :: a as a parameter to prependNTimesToList, but there's no guarantee that a is a type of number
03:12:17 <Cale> yeah, that too :)
03:12:53 <TaTonka> donri: that means i can't extract the last element of a list with xs:x like i can extract the first one with x:xs?
03:13:05 <ivanm> dammit, what's going on with my net tonight that I keep getting kicked off of IRC? :/
03:13:06 <donri> more typically you do (x:xs) - the names are merely conventions and don't change the semantics
03:13:21 <TaTonka> ah, okay.
03:13:26 <Cale> x and xs are just naming conventions for an element and a list, they're not syntax. Whenever you see (u:v), v is always a list, and u is always an element of the appropriate type to go in the list (because it's the first element of the list u:v)
03:13:51 <Mauke> TaTonka: : is what lists are actually made of
03:14:01 <Mauke> when you write [1,2,3] it actually means 1 : (2 : (3 : []))
03:14:03 <Cale> You can write  multReverse (foo:bar) just as well as multReverse (x:xs)
03:14:37 <ivanm> Mauke: you've learnt how to capitalise your nick? :o
03:14:39 <ivanm> :p
03:14:46 <Mauke> Yes
03:15:18 <donri> Mauke: fought any starfleet officer's recently?
03:15:27 <ivanm> what's the current preference about MPTCs+FDs vs TFs ?
03:15:34 <TaTonka> the second problem i have is that the automatic signature of prependNTimesToList has type variables like a0. i don't know why there is the 0. in the tutorials i read there are only type variables like a and b. i think, haskell detected this type as a0 because it is not a, but why a0 then, and not b?
03:16:12 <elliott> TaTonka: the names are irrelevant
03:16:15 <elliott> digits can be parts of names too
03:16:21 <elliott> they have no special meanings
03:16:26 <Cale> TaTonka: The names of the type variables don't actually matter... I'm a little surprised at a0, but often ghc will use t, t1, t2, ...
03:16:38 <ivanm> I'm splitting out the serialisation stuff from the graph library I'm hacking on, which requires two type-classes with some form of constraints
03:16:58 <donri> the names only matter inasmuch that the same name means the same type
03:17:11 <donri> but a and a0 are not the same name
03:17:20 <Cale> TaTonka: There will be points during type inference where it has to invent a name for a type variable, and it's not too creative in how it chooses them
03:17:36 <TaTonka> okay, i was surprised, too, because last year i tried haskell, too, and there were only variables without digits. so i was not sure if it would be a difference, why haskell detected it as a0 and not as b
03:17:53 <elliott> TaTonka: Digits have always been acceptable parts of identifiers.
03:18:13 <TaTonka> elliott: yes, but this is the first time they appeared to me during type inference
03:18:14 <hpaste> rostayob pasted “fundeps error?” at http://hpaste.org/53058
03:18:21 <elliott> Yeah. GHC picks pretty arbitrarily.
03:18:24 <rostayob> why do I get an error with that thing?
03:18:29 <rostayob> http://hpaste.org/53058
03:18:30 <donri> youCouldEvenHaveaATypeVariableLikeThisIThink
03:18:39 <elliott> rostayob: you skipped "e"
03:18:44 <elliott> donri: yep
03:18:53 <elliott> rostayob: (this might not actually be why it errors out but it should be)
03:18:56 <donri> but then you should go program objective-c instead
03:18:58 <rostayob> elliott: oh, I did. still, why do I get the error?
03:19:03 <quicksilver> I think GHC uses the same variable names which have been used in explicit signatures
03:19:05 <TaTonka> okay, thank you. i'll try it then.
03:19:08 <elliott> rostayob: what error is it
03:19:15 <quicksilver> and then appends digits if needed for uniqueness
03:19:17 <quicksilver> :t map
03:19:17 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:19:21 <quicksilver> :t (map,map)
03:19:22 <lambdabot> forall a b a1 b1. ((a -> b) -> [a] -> [b], (a1 -> b1) -> [a1] -> [b1])
03:19:23 <ivanm> did my question come through before?
03:19:28 * ivanm glares at his net connection
03:19:38 <TaTonka> donri: well, i only do haskell because my university forces me to. and when you come from ruby, it's quite confusing.
03:19:45 <hpaste> rostayob annotated “fundeps error?” with “fundeps error? (annotation)” at http://hpaste.org/53058#a53059
03:19:50 <rostayob> elliott: ^^
03:20:06 <elliott> oh
03:20:14 <elliott> rostayob: I think it's because you can specialise d to be (d -> e)
03:20:20 <elliott> and therefore
03:20:24 <elliott> the first one can result in
03:20:25 <rostayob> oh, right.
03:20:27 <elliott> (a, b, c) -> d -> e
03:20:29 <donri> TaTonka: hey what do you know, maybe you'll learn to love it in time
03:20:31 <ivanm> what's the current preference about MPTCs+FDs vs TFs ?
03:20:33 <ivanm> I'm splitting out the serialisation stuff from the graph library I'm hacking on, which requires two type-classes with some form of constraints
03:20:33 <rostayob> yes, makes sense. irritating
03:20:34 <TaTonka> but haskell is a clean language, and i'm starting to like it. if only it wasn't so hard at first
03:20:42 <elliott> ivanm: I like TFs a lot more
03:20:54 <ivanm> elliott: yeah, I started using them and did the first type class...
03:21:02 <elliott> ivanm: I think fds are only still big because mtl is :-)
03:21:04 <rostayob> is there a way to say "not an arrow type" :P?
03:21:07 <ivanm> then I realised that I wanted to use the same associated type names for the second class... :s
03:21:08 <elliott> ...if they can even be said to be big
03:21:18 <ivanm> elliott: well, TFs don't work well with generalized newtype deriving :(
03:21:26 <donri> TaTonka: read learn you a haskell?
03:21:29 <elliott> ivanm: mm...
03:21:50 <ivanm> also, TFs lead to atrocities like this: prettyPrint :: (SerialisableGraph g, Show (Node g), Show (Edge g), Show (NodeLabel g), Show (EdgeLabel g)) => g -> IO ()
03:22:08 <elliott> ivanm: as opposed to atrocities like this:
03:22:24 <elliott> ivanm: prettyPrint :: (SerialisableGraph g n e nl el, Show n, Show e, Show nl, Show el) => g -> IO ()
03:22:33 <elliott> at least I can figure out wtf the first one is saying :p
03:22:42 <elliott> and not all signatures have to pull in all those vars
03:22:48 <TaTonka> donri: i did last year, and failed the final test of the "functional programming" lecture. it is a great tutorial for learning all the relevant functions, but it does not show you how to write "real" programs in haskell. i'm reading realworldhaskell right now
03:23:07 <donri> they complement each other nicely
03:23:35 <ivanm> great, looks like my connection died again... :s
03:23:58 <TaTonka> yes, i think, too. i hope this helps, because our professor is not very good at telling us his knowledge
03:25:27 <elliott> <ivanm> great, looks like my connection died again... :s
03:25:27 <ivanm> elliott: did you happen to say anything to me after "mmm..." (or whatever you actually said after my generalized newtype deriving comment)?
03:25:33 <elliott> ivanm: yep
03:25:33 <ivanm> wait, that came up? :o
03:25:37 <elliott> <elliott> ivanm: as opposed to atrocities like this:
03:25:39 <elliott> <elliott> ivanm: prettyPrint :: (SerialisableGraph g n e nl el, Show n, Show e, Show nl, Show el) => g -> IO ()
03:25:39 <ivanm> nothing was happening here... >_>
03:25:39 <elliott> <elliott> at least I can figure out wtf the first one is saying :p
03:25:39 <elliott> <elliott> and not all signatures have to pull in all those vars
03:25:43 <Saizan> rostayob: class IsFunction t b | t -> b; instance b ~ HTrue => IsFunction (x -> y) b; instance b ~ HFalse => IsFunction x b, requires OverlappingInstances, UndecidableInstances
03:25:58 <ivanm> elliott: hmmm, true
03:26:50 <ivanm> elliott: that's one class; my other class is similar but has the Node and Edge types fixed, so I was thinking of using NodeLabel and EdgeLabel again...
03:27:04 <elliott> ivanm: you know you can have type families outside of a class, right?
03:27:09 <elliott> if you want to share them, that might work.
03:27:11 <ivanm> but they're not permitted to be the same because of scoping :s
03:27:20 <ivanm> so now I have to think of new AT names...
03:27:27 <elliott> ...unless you share them :)
03:27:48 <ivanm> hmmmm....
03:27:51 <ivanm> that might work
03:28:05 <ivanm> though I could think off possibilities where it _won't_ ...
03:28:33 <elliott> well, does it ever make sense to give different associations for the same type?
03:28:38 <ivanm> (what makes it even more fun is that the methods of the second class are also just specialised variants of the first class but with better defined behaviour)
03:28:49 <rostayob> Saizan: HTrue?
03:29:07 <elliott> rostayob: data HTrue; data HFalse
03:29:10 <elliott> ivanm: that sounds awful
03:29:10 <rostayob> Saizan: ah
03:29:11 <ivanm> elliott: it will in most cases; I'm just wondering how pathological I should consider crazy use-cases to be :p
03:29:18 <elliott> ivanm: can't you just make the class an empty subclass? :p
03:29:28 <Saizan> rostayob: that's the name oleg uses for True at the type level :)
03:29:29 <elliott> ivanm: you can always newtype wrapper for truly pathological cases
03:29:40 <ivanm> true
03:30:28 <ivanm> elliott: I'm dealing with graph stuff: I originally developed the notion of having a list-based SerialiasedGraph type to separate the notion of serialising a graph from the actual serialisation format used
03:30:35 <IvdSangen> hi, i just ran the latest ghc testsuite on current openbsd, i get 69 "unexpected failures"
03:30:37 <rostayob> Saizan: why do you need to do type equality like that? Can't you say IsFunction (x -> y) HTrue?
03:30:47 <IvdSangen> is this expected?
03:31:15 <dafis> IvdSangen: maybe, maybe not
03:32:15 <dafis> IvdSangen: some tests depend on packages you may not have installed, if those fail, that's expected
03:32:22 <Saizan> rostayob: maybe you could for the (x -> y) case but you can't for the other because otherwise it wouldn't be more general
03:32:26 <rostayob> Saizan: ah, fundeps conflicts
03:32:26 <ivanm> elliott: it turns out that this notion of a SerialisedGraph type is also useful for pretty-printing and Show/Read instances... but for these use cases, you a) don't need (and probably want) to do the pre-processing before serialising, and b) for actual binary serialisation, you want to convert all nodes/edges to Ints (for location in a BFS traversal); for this case you want to use the actual type used for debugging purposes
03:32:39 <Saizan> rostayob: yeah, that too
03:32:48 <elliott> ivanm: hmm, right
03:33:20 <rostayob> Saizan: actually, I don't need OverlappingInstances to do that
03:33:39 <IvdSangen> dafis: the tests are part of the source tree, i assume all dependencies are either contained in the tree or checked for during build
03:33:42 <dafis> IvdSangen: some tests are "currently broken, but it's not a big deal", those are expected to unexpectedly fail too
03:33:46 <ivanm> elliott: so the pathological case was: some user may wish to add the original node/edge ID to the node/edge label for the binary serialisation case
03:33:47 <rostayob> the thing is that, why doesn't b ~ HFalse => IsFunction x b conflicts with IsFunction (x -> y) b?
03:34:01 <rostayob> does this have to do with how UndecidableInstances work?
03:34:06 <ivanm> but atm, all the serialisations that I know of require the labels to be () anyway *shrug*
03:34:10 <IvdSangen> dafis: how can i check the status of those test cases, then I have a measure of performance
03:34:15 <ivanm> so I guess i can just ignore that potential use case
03:34:42 <elliott> ivanm: yeah it sounds ignorable
03:34:42 <dafis> IvdSangen: no, some tests depend on e.g. parsec, there are some checks, but they're rather superficial
03:34:48 <elliott> ivanm: mostly because I don't even fully get the usecase :>
03:34:50 * ivanm remembers the dramas that came about when he proposed making FGL node IDs to be abstract, when some people wanted them to be arbitrary
03:34:58 <ivanm> elliott: neither do I :p
03:35:14 <ivanm> some people just seemed to be really hung up on the values used for node IDs
03:35:35 <ivanm> whereas I see them as arbitrary values used for relative positioning in the graph, and the node label contains the information you actually care about
03:37:23 <dafis> IvdSangen: if you have (and are willing to take) the time, run the testsuite and '2>&1 | tee testlog' the output, then go find "unexpected" in the log, and decide on a case-by-case basis whether it looks serious, report what seems serious as a bug (if not reported before)
03:38:02 <IvdSangen> i will do that
03:38:58 <dafis> IvdSangen: when you said latest, didi you mean HEAD or ghc-7.2.1?
03:39:05 <dafis> did*
03:39:14 <ivanm> could it be because you're running the testsuite on the HEAD version of ghc, and the testsuite hasn't been updated to match some deliberate changes?
03:39:23 <IvdSangen> HEAD
03:39:44 <IvdSangen> 7.3.2#
03:40:20 <dafis> ah, yeah, I tend to get around 11 unexpected for that normally
03:40:59 <dafis> but, yes, the testsuite isn't always quite up to day
03:42:31 <IvdSangen> would be nice to have an overview of which cases are severe and which are considered not an issue
03:42:49 <dafis> indeed
03:43:12 <JuanDaugherty> anybody know of any haskell adoption statistics distinct from ranking as a PL?
03:44:43 <JuanDaugherty> (i.e. popularity rankings based on web stats)
03:51:54 <gienah> JuanDaugherty: it seems pretty mediocre to use a methodology like some programming language ranking websites of how many google searches there are for "X programming"
03:52:31 <ivanm> especially when you're not using some special unique name all the time
03:52:43 <ivanm> e.g. searching for "golang" vs just "go"
03:52:45 <gienah> JuanDaugherty: it might be interesting to look at what programmers choose to write stuff in, so another indicator is the popularity ranking on github
03:55:04 <ivanm> how do you create a top-level associated type? "type family NodeLabel g" and then "type instance NodeLabel (Gr a b) = a" ?
03:55:26 <gienah> JuanDaugherty: info is a little out of date: http://www.dataists.com/2010/12/ranking-the-popularity-of-programming-langauges/
03:55:48 <ivanm> oh, wait, just found where that's specified on the haskell wiki page
03:56:46 <gienah> JuanDaugherty: http://www.r-chart.com/2010/08/github-stats-on-programming-languages.html
03:59:03 <erus`> haskell needs to triple its repository count before it is in the top 10 languages :'(
03:59:07 <JuanDaugherty> gienah, thx, yes, the github data is the sort of thing I was looking for, matches about what I expected
03:59:30 <ivanm> a lot of Haskellers still use darcs
03:59:36 <JuanDaugherty> actuall use much greater than web measured popularity but still not in the top 10
03:59:36 <Sgeo|web>      iterate2 f x n | seq f $ seq x $ seq n $ False = undefined
03:59:37 <ivanm> git pisses me off too much
03:59:41 <Sgeo|web> ^^^trick from Oleg
03:59:56 <ivanm> Sgeo|web: yeah, I've done stuff like that before
04:00:01 <ivanm> but I used trace instead
04:00:17 <gienah> ivanm: yes so that skews the results, and also github's history of being very popular with ruby projects early on
04:00:38 <ivanm> tracer a = trace (show a) a; foo x y | tracer a `seq` tracer b `seq` False = undefined; foo x y = ...
04:01:02 <Cale> I'm not sure if that's really due to Oleg...
04:01:38 <ivanm> gienah: yeah, I never understood the seeming mentality of "hey all rubyists! we've decided that we're going to use a private company's resources to do hosting of all repos of stuff in ruby, so you better use it!"
04:01:43 <Cale> But I do recall him writing something about it
04:01:59 <ivanm> (since from what I can tell, rubygems has special case stuff for github)
04:02:37 <Cale> I've been using a similar trick with Debug.Trace almost since Debug.Trace existed.
04:03:15 * quicksilver is disappointed to hear Cale has used Debug.Trace.
04:03:21 <Cale> heh
04:04:35 <osfameron> github has a nice UI and lots of mindshare
04:04:50 <dafis> but github uses git
04:05:00 <Cale> It can be quite handy really, if you have complicated bits of data going through your program and the case in which things fail is obscure.
04:05:30 * osfameron used darcs once to check some haskell project out that didn't have a git repo...
04:05:36 <ben> github can also use svn, can't it
04:05:54 <dafis> maybe, but then I'd rather use git
04:06:01 <quicksilver> Cale: I can believe that, because I never work with finished programs
04:06:04 <ivanm> quicksilver: because he's dabbled with the Dark Side? :p
04:06:08 <quicksilver> Cale: I only ever start things :)
04:06:09 <docTony> I got a question which should have a simple answer but I seem not to get there being still rather new at Haskell:  I have a function, say: fun f, which does IO such as reading a file etc. I have a list of fs, and I want to write a loop that takes an f from fs, and gives it to fun. I guess I need sequence or something, but I'm stuck at it...
04:06:18 <quicksilver> Cale: and then debugging is much more natural in ghci
04:06:44 <ivanm> @type mapM
04:06:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:06:47 <ivanm> docTony: ^^ ?
04:06:48 <dibblego> docTony: mapM or sequence
04:06:51 <ivanm> @type mapM readFile
04:06:52 <lambdabot> [FilePath] -> IO [String]
04:06:54 <Cale> quicksilver: Yeah, I use Debug.Trace to print the arguments to the function so that I can go and test it by hand in ghci :)
04:07:13 <quicksilver> Cale: Ah, that's the best use of it I've ever heard of :)
04:07:30 <Cale> foo x y z | trace (concat ["foo ", show x, ...]) False = undefined
04:08:00 <osfameron> could you derive that trace statement automagically?
04:08:07 <hpaste> “Mukesh Tiwari” pasted “Learning Haskell Class” at http://hpaste.org/53064
04:08:10 <Cale> Yeah, probably :)
04:08:34 <keep_learning> hello all
04:08:46 <docTony> as in: mapM fun fs , that's the monadic way of map?
04:09:08 <dibblego> docTony: what are the types of your values?
04:09:16 <keep_learning> i am trying to learn class but getting error when i am trying to execute a function from class on ghci .
04:09:27 <rotflcopter> hi
04:09:33 <rotflcopter> somebody in squid?
04:09:33 <Cale> keep_learning: hpaste :)
04:09:48 <dafis> keep_learning: ghci can't know which type to choose
04:09:54 <rotflcopter> having minor reload redirecting issues
04:10:00 <keep_learning> Cale, http://hpaste.org/53064
04:10:02 <Cale> That'd be one big squid, to swallow a human.
04:10:14 <docTony> FilePath -> IO ()
04:10:22 <rotflcopter> ;>
04:10:25 <dafis> keep_learning: maxDim ((...) :: Rect)
04:10:37 <keep_learning> dafis,
04:10:42 <docTony> fun:: FilePath -> IO ()
04:10:43 <keep_learning> dafis, thank you
04:11:16 <docTony> dibblego, and then I want to use [FilePath] and call the function
04:11:36 <dibblego> mapM_ fun files :: IO ()
04:11:38 <Cale> keep_learning: The problem is that 1, 1.0 and 10 are all polymorphic, so it doesn't know if the first 1 is an Int or Double or Float or Complex CReal, and so it can't tell that the instance you wrote applies.
04:11:53 <docTony> mapM_  ,  thnx!
04:12:03 <dibblego> np
04:12:36 <Sgeo|web> Hmmmmmmmmmmmmmmmm
04:12:36 <Cale> keep_learning: One thing which would really help here is if instead of using nested tuples, you went with something like  data Rect = Rect Int (Double, Double) (Double, Double)
04:12:42 * Sgeo|web starts thinking weird thoughts
04:12:42 <Cale> for example
04:12:46 <ivanm> Cale: ooohh, I like your way of using it rather than what I put up earlier
04:12:57 <ivanm> keep_learning: are you Mukesh Tiwari?
04:13:08 <Sgeo|web> Would it be possible to write a function like:
04:13:27 <ivanm> with your question being about a Geometry class?
04:13:38 <Sgeo|web> :: (b -> b -> b -> ... -> c) -> (a b -> a b -> a b -> a b -> ... -> a c)
04:13:50 <Cale> ivanm: yeah, he linked to that paste :)
04:13:57 <Sgeo|web> Using typeclasses for polyvariadicity?
04:14:03 <ivanm> if so, try: maxDom ( ( 1 , ((1.0 , 1.0 ) , ( 10 , 10 ))) :: Rect )
04:14:42 <keep_learning> ivanm, yes
04:14:47 <ivanm> Cale: ugh, I'm having some weird buffering issues with IRC tonight, which means I had a whole bunch of messages suddenly pop up after saying that :s
04:15:21 <Sgeo|web> I have a feeling that if I were less tired, and looked more closely at Oleg's work, I could do such a thing
04:15:45 <Sgeo|web> Type-safe pattern matching polyvariadic etc.
04:16:56 <Sgeo|web> Potential use case: General form of liftM2 etc.
04:17:25 <keep_learning> Cale, thank you
04:18:53 <liyang> Just in case it has eluded me, there's no way to say “Export everything except for these symbols.” in a module, is there?
04:19:13 <liyang> (and if not, why not? ¬_¬)
04:19:42 <Cale> liyang: I've often wished that existed.
04:19:42 <ivanm> Sgeo|web: that's called `ap` I believe ;)
04:20:27 <ivanm> Cale: so do I
04:20:29 <liyang> Cale: doing some foreign bindings. I want to export everything (from the excessively large API) except for a small handful of helper functions.
04:21:27 <Sgeo|web> ivanm: but don't you have to intersperse that or something like that between arguments?
04:21:29 <Sgeo|web> :t p
04:21:30 <lambdabot> Expr
04:21:31 <Sgeo|web> :t ap
04:21:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:22:01 <IvdSangen> dafis: http://pastebin.com/dqjqWX19 - these are the test cases that had unexpected results
04:22:04 <Mauke> The paste dqjqWX19 has been copied to http://hpaste.org/53065
04:22:27 <Sgeo|web> Why is pastebin.com hated?
04:22:30 <Sgeo|web> @where pastebin.com
04:22:30 <lambdabot> I know nothing about pastebin.com.
04:22:43 <ivanm> liyang: one way of doing it is to have it all in an internal module
04:22:44 <Cale> Mauke just has a script to do that
04:22:52 <ivanm> tell haddock to hide that module
04:23:11 <ivanm> then, in your "real" module, use "import Foo hiding (...)" and export "module Foo"
04:23:23 <ivanm> that way, the docs are all in the real module
04:23:33 <Mauke> Sgeo|web: because it's made of evil
04:24:34 <ivanm> Sgeo|web: yeah, you do
04:24:39 <ivanm> or the Applicative version of it
04:24:51 <ivanm> polyvariadic functions are difficult to debug though
04:24:57 <ivanm> e.g. problems with using printf
04:26:00 <Saizan> printf has the problem of not checking the format strict statically
04:26:24 <Mauke> TH!
04:26:26 <Saizan> liftMN would just have the problem of requiring type annotations sometimes
04:26:38 <Saizan> s/strict/string/
04:27:24 <mercury^> Is Haskell dependent enough to do strict printf without TH?
04:27:42 <Mauke> not if you use a format string
04:27:45 <quicksilver> well, if you replace the format "string" with a format structure, sure
04:27:49 <mux> if the format string is an ADT rather than a string then yes
04:27:52 <dafis> IvdSangen: doesn't say why these failed. However, a fat lot of ghci failures, that looks like ghci is not quite up to snuff on openbsd
04:27:53 <quicksilver> but with a string, certainly not
04:27:59 <mantovani> morning
04:28:05 <mercury^> How would it work with the format structure?
04:28:13 <elliott> woot, my supply-monad has mtl now \o/
04:28:32 <flux> @faq Can haskell do statically typed format strings?
04:28:33 <lambdabot> The answer is: Yes! Haskell can do that.
04:28:37 <quicksilver> printf (PFInt :*: PFConst " foo " :*: PFString) 4 "hi"
04:28:38 <IvdSangen> dafis: im moving this discussion to #ghc
04:28:41 <quicksilver> mercury^: something like that
04:28:43 <flux> so, I don't see a problem with that?
04:28:47 <elliott> quicksilver: it can be much nicer than that
04:28:49 <elliott> you can do it with combinators
04:28:52 <quicksilver> sure
04:28:59 <mercury^> quicksilver: what's the type of that printf?
04:29:03 <Sgeo|web> :t (:*:)
04:29:03 <lambdabot> forall a b. a -> b -> a :*: b
04:29:07 <elliott> printf (int % " foo " % string) 4 "hi"
04:29:13 <Sgeo|web> ..?
04:29:14 <elliott> mercury^: printf then looks like :: Formatter r -> r
04:29:16 <elliott> except it's actually liek
04:29:19 <Sgeo|web> WHat's a :*: ?
04:29:20 <hpaste> Schalken pasted “The last statement in a 'do' construct must be an expression” at http://hpaste.org/53066
04:29:21 <elliott> Formatter s q r -> r
04:29:25 <elliott> because you need more type variables :p
04:29:39 <elliott> Schalken: you can't use "where" clauses like that
04:29:40 <yitz> Mauke: you've done great things here. it's about time that your nick became Capitalized.
04:29:42 <elliott> Schalken: put them on main itself
04:29:43 <quicksilver> mercury^: in the one paramter case Format a -> a -> String
04:29:51 <Schalken> elliott: Wow, that was quick!
04:30:01 <quicksilver> mercury^: and the type paramter to 'Format' is tracking the type of parameter expected next.
04:30:04 <elliott> Schalken: :)
04:30:27 <quicksilver> mercury^: in the more than one arg case, well it's a combination of the trick the existing Printf uses with this one.
04:30:34 <Saizan> "Fun with type functions" for the full code
04:30:42 <Schalken> elliott: So if I didn't want to put it on main itself, I'd have to use a "let"?
04:30:50 <Saizan> (one version at least)
04:30:53 <elliott> Schalken: Yeah. Or just put it in a top-level declaration :p
04:31:08 <quicksilver> elliott: I really don't see that that is "much nicer" than what I wrote?
04:31:15 <elliott> quicksilver: well, it's extensible :)
04:31:26 <quicksilver> elliott: you think replacing :*: with % and getting rid of some upper case chars makes it much nicer?
04:31:26 <Schalken> elliott: So basically "where" is only allowed on top level declerations?
04:31:30 <ivanm> hmmm.... I need a name for the type alias of SerialisedGraph which is meant to represent the serialised form of a BFS traversal
04:31:33 <ivanm> any suggestions?
04:31:33 <quicksilver> yes, but I was only giving the simple case.
04:31:48 <Mauke> Schalken: no, 'where' is allowed on all declarations
04:31:56 <elliott> quicksilver: I think yours is harder to explain because it needs gadts
04:32:27 <flux> there's a great white paper on the subject, if one wants an explanation.
04:32:42 <Schalken> Mauke: Is it not allowed within a "let" declaration, then? http://hpaste.org/53066
04:33:01 <Mauke> Schalken: it is
04:33:03 <Schalken> Mauke: Or not within pattern match in a "do"?
04:33:07 <Mauke> Schalken: I don't see "let" in that code, though
04:33:31 <flux> http://www.brics.dk/RS/98/12/BRICS-RS-98-12.pdf - Functional Unparsing
04:33:46 <Schalken> Mauke: Right, sorry, I meant the pattern match in the "do". Is "where" not allowed there.
04:34:00 <Mauke> that's not a pattern match :-|
04:34:10 <Mauke> Schalken: no, because that's just an expression
04:34:29 <Mauke> or maybe: no, because <- doesn't work that way
04:34:57 <Schalken> Mauke: So what's the rule which disallows the "where" where I've used it? I'm trying to understand in general because I get this error a lot a just end up moving code around until it goes away.
04:35:14 <Mauke> Schalken: 'where' is only allowed on declarations
04:36:21 <Mauke> Schalken: do you know how do-notation works?
04:36:24 <Schalken> Mauke: So the problem is "a <- ..." isn't a declaration, because it translates into ">>= $ \a ->"?
04:36:26 <Mauke> i.e. how it's desugared?
04:36:36 <Mauke> well, without the $
04:36:54 <Schalken> Mauke: Yeah, but I didn't think I needed to think about it, really. :P
04:37:03 <Schalken> Mauke: So that's the cause, then?
04:37:15 <Mauke> yes
04:37:37 <Schalken> elliott: Mauke: Thank you very much for your time.
04:37:42 <elliott> np :)
04:38:53 <yitz> Schalken: not because of how it desugars, because it's just not part of Haskell's syntax there
04:39:05 <yitz> Schalken: it's only allowed in a certain fixed list of places
04:39:57 <dafis> yitz: but the desugaring shows clearly that that is not one of them, I think that's what was Mauke's point
04:40:01 <yitz> Schalken: it can apply to a top-level binding, a binding which is part of an enclosing let or where, or a case binding. that's it. not anywhere else.
04:40:10 <yitz> dafis: yes
04:41:25 <yitz> Schalken: the most important places that it is tempting to try to use it but it doesn't work are a binding inside of a do block (like your case), and on a guard.
04:42:07 <yitz> Schalken: also, even though it is allowed on case bindings, i personally find that very confusing and don't use them there.
04:42:39 <Schalken> yitz: I get it now! "where" applies to declarations. "let" applies to expressions. I can do "let ... in a" where "a" is an expression. But I can only do "a = b where ..." not "a where ..." in general.
04:43:29 <elliott> Schalken: yep
04:43:45 <elliott> Schalken: (fun fact: let...in expressions did not use to exist, and "where" applied to expressions instead)
04:43:52 <elliott> in haskell 1.2
04:43:56 <fasta> Is there some existing TH which basically turns "\" into "\\", etc.?
04:44:15 <yitz> Schalken: you can't do "let ... in a where ...". you can only do it on a specific *binding* in the let, like "let { a = ... where ...; b = ... where ...; }"
04:44:26 <fasta> In Perl, I think they call that qw() or something like that.
04:44:39 <yitz> Schalken: i used curly braces here because i can't do indentation here in IRC.
04:44:49 <Schalken> yitz: Right.
04:45:05 <Mauke> fasta: qw(foo bar baz) is ["foo", "bar", "baz"]
04:45:25 <fasta> Mauke: then I meant a different symbol.
04:45:41 <fasta> But anyway, you don't have to quote everything then.
04:45:52 <fasta> er escape
04:45:59 <Mauke> words "foo bar baz"
04:45:59 <Schalken> elliott: Do you know the reason? Because until now I thought "where" and "let" were equivalent, and even though I get it now I think my prior expectation was intuitive.
04:46:05 <yitz> fasta: how about "show"?
04:46:16 <elliott> Schalken: it's convenient to have "wheres" that scope over multiple guards
04:46:19 <fasta> > show "\"
04:46:20 <lambdabot>   <no location info>:
04:46:20 <lambdabot>      lexical error in string/character literal at end o...
04:46:28 <elliott> Schalken: and the indentation ends up nicer with it being scoped at declaration level
04:46:30 <fasta> yitz: doesn't fit what I specified.
04:46:43 <Mauke> fasta: perl doesn't have anything like that
04:46:57 <fasta> $show("\") => "\\"
04:47:10 <yitz> > show [fromEnum 92]
04:47:11 <lambdabot>   "[92]"
04:47:24 <Schalken> elliott: Ahh, since guards are left of the "=" the "where" has to apply to the entier declaration for them to be accessible to the guards.
04:47:30 <elliott> Schalken: Right.
04:47:31 <Schalken> entire*
04:47:33 <yitz> > show ([fromEnum 92] :: String)
04:47:33 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:47:34 <lambdabot>         against inferred type...
04:47:40 <fasta> Mauke: ok, forget Perl entirely then.
04:47:42 <Mauke> > show [chr 92]
04:47:43 <yitz> > show ([toEnum 92] :: String)
04:47:44 <lambdabot>   "\"\\\\\""
04:47:44 <lambdabot>   "\"\\\\\""
04:47:59 <Schalken> elliott: yitz: Thanks.
04:48:01 <Mauke> > show "\92"
04:48:02 <lambdabot>   "\"\\\\\""
04:48:09 <elliott> :)
04:48:17 <yitz> haha
04:48:40 <yitz> > show "\\"
04:48:41 <lambdabot>   "\"\\\\\""
04:48:58 <yitz> > text $ show "\\"
04:48:59 <lambdabot>   "\\"
04:50:04 <yitz> fasta: anyway, let's say you get a string from a user and want to add some backslash escaping. show will do some of that.
04:50:16 <yitz> fasta: however it's unlikely to be exactly what you need in real life
04:50:18 <fasta> yitz: the 'user' is the programmer.
04:50:33 <yitz> fasta: oh i see, that's why you said TH
04:50:57 <fasta> yitz: writing \\ where the domain only understands \ means that \\ is a suboptimal solution.
04:51:23 <fasta> When you define optimality as depending on the readability of the code.
04:51:42 <yitz> fasta: oh so like you want to have some Windows path literals and you want them to be actually readable
04:51:59 <fasta> yitz: for example.
04:52:18 <yitz> fasta: good idea. don't think there's a package like that yet. write it and publish!
04:52:26 <dafis> but windows understands "/", I think, so why not use that?
04:52:36 <yitz> dafis: just an example
04:53:01 <yitz> dafis: and not always does it understand /, only in certain contexts
04:53:16 <dafis> yes, but perhaps a better example would be LaTeX commands?
04:53:22 <yitz> dafis: sure
04:53:35 <dafis> yitz: oh, where doesn't it understand "/"?
04:53:47 <Mauke> dafis: cmd.exe
04:53:57 <mike-burns> #haskell doesn't always care about real-world use cases, but when they do they get pedantic.
04:54:11 <Mauke> command line parsing on windows will eat your soul
04:54:25 <dafis> s/command line parsing//
04:54:40 <dafis> s/ on//
04:54:52 <ion> > iterate show "\\"
04:54:53 <lambdabot>   ["\\","\"\\\\\"","\"\\\"\\\\\\\\\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\\\\\\...
04:55:04 <ion> > iterate show "\""
04:55:04 <yitz> > fix show
04:55:05 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
04:55:05 <lambdabot>   ["\"","\"\\\"\"","\"\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\...
04:55:52 <ion> Nobody said you need to use cmd as the CLI on Windows™.
04:56:40 <ivanm> elliott: any suggestions on what I can call the version of my SerialisableGraph class that requires output in a certain order (namely a BFS traversal) ?
04:56:41 <fasta> I wonder why people zoom in on Windows, while that was an example, not the general case.
04:56:54 <elliott> ivanm: BFSSerialisableGraph? :-)
04:57:27 <fasta> ivanm: why not make it a MPTC?
04:57:36 <yitz> fasta: try it on slashdot
04:57:38 <fasta> ivanm: Seria. BFS a
04:58:07 <dafis> fasta: because it was a *concrete* example
04:58:40 <fasta> dafis: but a solution which only works for the concrete example is not a solution.
04:58:51 <elliott> What's the real problem?
04:59:06 <fasta> elliott: you have a scrollback, right?
04:59:17 <elliott> Yep. I'm asking you to clarify.
04:59:36 <fasta> "Everyone" already understands it.
04:59:48 <Mauke> I don't
04:59:50 <elliott> You're not even an interesting troll. :(
04:59:57 <yitz> elliott: fasta suggests a new syntax for string literals for when you don't need backslash quoting, and backslash quoting interferes with the human-readability of your code.
05:00:15 <yitz> elliott: it can be implemented as a quasi-quoter
05:00:33 <elliott> There are tons of string-interpolation quasiquoters on Hackage that would fit the bill.
05:00:37 <fasta> I like the way sed works in this regard.
05:00:46 <elliott> I mean, obviously you wouldn't use the string interpolation part, but it would fit the bill.
05:00:50 <fasta> You can specify the escape character there easily.
05:00:50 <yitz> elliott: oh there are?
05:00:57 <Mauke> fasta: how?
05:00:58 <elliott> Yes. Great numbers of them.
05:01:06 <elliott> Mauke: sed lets you use any character after s
05:01:14 <Mauke> elliott: that's not the escape character
05:01:17 <elliott> Well, yeah.
05:01:23 <yitz> elliott: and we return to perl
05:01:27 <elliott> It's an avoidance mechanism, like heredocs.
05:01:35 <elliott> yitz: How comforting.
05:01:36 <Mauke> heredocs would actually work
05:01:56 <yitz> or python triple-quotes
05:01:59 <Mauke> that's the one place in perl where \ means just that character
05:02:32 <yitz> or r" quotes
05:02:36 <elliott> yitz: triple quotes have escapes i think
05:02:47 <yitz> elliott: yeah i meant r" quotes
05:02:50 <elliott> Right.
05:03:06 <Mauke> r"\" is a syntax error in python
05:04:27 <donri> What's this ~(x,y) syntax I see sometimes?
05:04:34 <Mauke> lazy patterns
05:04:41 <ion> A.k.a. irrefutable patterns
05:06:04 <donri> audreyt has a string-qq hackage or something like that, which does string quasi-quoting without interpolation
05:06:07 <ion> > case undefined of (a,b) -> ()
05:06:08 <lambdabot>   *Exception: Prelude.undefined
05:06:10 <ion> > case undefined of ~(a,b) -> ()
05:06:11 <lambdabot>   ()
05:06:13 <ion> > case undefined of ~(a,b) -> a
05:06:14 <lambdabot>   *Exception: Prelude.undefined
05:06:21 <ion> donri: ↑
05:06:30 <Mauke> > case undefined of ~(a,b) -> ("hi", a)
05:06:31 <lambdabot>   ("hi",*Exception: Prelude.undefined
05:06:42 <donri> ah, thanks
05:06:59 <donri> how come that isn't the standard behavior?
05:06:59 <Mauke> > case "" of ~[a,b] -> ("hi", a)
05:07:00 <lambdabot>   ("hi",*Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed fo...
05:07:09 <donri> oh wait nevermind
05:07:18 <dafis> > let foo x ~(ys,zs) = (x:zs,ys) in take 5 . fst $ foldr foo undefined [1 .. ]
05:07:20 <lambdabot>   [1,3,5,7,9]
05:07:28 <dafis> > let foo x (ys,zs) = (x:zs,ys) in take 5 . fst $ foldr foo undefined [1 .. ]
05:07:29 <lambdabot>   *Exception: stack overflow
05:09:18 <ion> > case Nothing of ~(Just a) -> ("hi", a)
05:09:19 <lambdabot>   ("hi",*Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed fo...
05:12:26 <ivanm> dammit, IRC disconnected _again_... did anyone happen to answer me this time? :p
05:12:47 <elliott> I did
05:12:52 <elliott> <elliott> ivanm: BFSSerialisableGraph? :-)
05:12:56 <elliott> but it wasn't very serious :p
05:13:06 <ivanm> heh
05:13:20 <ivanm> I suck at naming things, can you tell? :p
05:14:18 <fasta> ivanm: SerializableGraph FormatType a
05:14:21 <elliott> ivanm: bfserialisableapth
05:14:26 <elliott> bfsg
05:14:43 <fasta> ivanm: you can run IRC also on a server.
05:15:19 <ivanm> what's the "apth" for?
05:15:30 <elliott> it tried to be graph but then collapsed on my keyboard
05:15:42 <int-e> apathy
05:15:47 <mantovani> oh hell, 1 week without haskell
05:15:58 <mantovani> and I forgot everething.
05:16:02 <elliott> ivanm: call it Bob
05:16:05 <elliott> class Bob g where ...
05:16:09 <ivanm> fasta: I think it's easier to just specify the format that should be adhered to in the methods than to try and make it parameter-based
05:16:26 <Mauke> all classes should be called C
05:17:08 <ivanm> fasta: yeah, but I'm having other connection problems (web pages arbitrarily taking a while to load, etc.)
05:17:17 <ivanm> also, that requires me to have a server to run IRC on :p
05:17:25 <ivanm> elliott: heh
05:17:31 <ivanm> @slap Mauke
05:17:31 * lambdabot puts on her slapping gloves, and slaps Mauke
05:18:07 <elliott> I use what I call Henning++ style, I put every single definition in its own module, and call it x or X depending on the namespace
05:18:20 <HugoDaniel> :D
05:18:45 <elliott> Data.List.Map.x :: (a -> b) -> Data.List.Type.X a -> Data.List.Type.X b
05:19:11 <yitz> elliott: that's fine, as long as you don't confuse errors and exceptions
05:19:21 <elliott> yitz: eh?
05:19:45 <int-e> season with some qualified imports. import qualified Data.List.Map as AssociativeArray
05:19:55 <yitz> elliott: henning's most sensitive issue
05:20:00 <Mauke> Data.List.Map.x :: (x -> x') -> Data.List.Type.X x -> Data.List.Type.X x'
05:20:01 <elliott> yitz: oh, heh
05:20:10 <elliott> Mauke: we need type variable modules
05:20:25 <elliott> int-e: no no no, if you do "import qualified Foo as Bar"
05:20:27 <elliott> that becomes
05:20:33 <HugoDaniel> Mauke: 3> (because i dont know how to rotate 3 to the other side)
05:20:45 <elliott> Foo aliased as My.Module.Imports.Bar.X
05:20:57 <elliott> I... I think we need a better language to achieve this
05:21:20 <int-e> elliott: yeah, it's a pity that you can't give imports qualified names. Right? :-P
05:21:50 <elliott> Mauke: X.X.X.x :: (x -> xx) -> X.X.X.X x -> X.X.X.X xx
05:21:53 <elliott> everybody go home
05:22:49 <Sgeo|web> I am home!
05:22:53 <int-e> I'll call it Xxxxx Xxxxxxxx -- which stands for Unary Haskell.
05:23:00 <Sgeo|web> Unfortunately. I should be heading to school
05:23:12 <int-e> uhm. make that Xxxxx Xxxxxxx
05:25:40 <yitz> somebody's been doing too much debruijn indexing lately
05:26:33 <int-e> You know that's actually true. I blame tromp.
05:32:30 <yitz> mantovani: you're lucky. most of us would get serious withdrawal sickness if we had a week without haskell.
05:38:22 <donri> hey does gtk2hs mean "gtk to haskell" or "gtk2 for haskell"? :P
05:39:23 <dqd> "Gtk2Hs is a Haskell binding to Gtk+ 2.x."
05:39:54 <donri> so http://www.gtk.org/language-bindings.php is wrong?
05:41:28 <dqd> I'm not sure.
05:42:52 <yitz> donri: what's wrong on that page?
05:42:56 <elliott> donri: the name is a lot older than gtk3 :p
05:43:11 <donri> yitz: it lists gtk2hs as supporting gtk3
05:43:13 <yitz> ah, 3.0?
05:43:19 <yitz> ok
05:43:23 <donri> i can't find any information on that on the gtk2hs end
05:44:04 <yitz> donri: if so, we should fix that quickly, by helping the gtk2hs team support gtk3 immediately. ;)
05:44:10 <donri> elliott: i realize that, thus the tongue-in-cheek :) still wondering if gtk3 is actually supported or not yet though
05:44:21 <elliott> i think it's in a dev version?
05:54:07 <docTony> I have a general question: I have a function and I have to give it a large amount of arguments (as in 10 or more arguments). Of course this is ugly (at least to me). Is there a good design pattern to not have to give many arguments to a function?
05:55:28 <ibid> one way to make it look a bit less bad is to use a record
05:58:00 <Axman6> docTony: does this need to be one large function? that's usually a sign of bad design in haskell
05:58:02 <docTony> but then I would be creating a record for just one function...
05:58:56 <docTony> well, it's an IO function, and it needs the information for loading, checking, parsing and then saving some data file
05:59:18 <mah_b> docTony: maybe some of the arguments get combined together in the function? then you could create a second function and pass its result into the big function.
05:59:24 <Axman6> those sound like they should all be their own functions
05:59:40 <docTony> I guess I could split it into many smaller IO functions... but it does not really make sense although it looks better
05:59:59 <docTony> so I should make many small IO functions
06:00:03 <docTony> ?
06:00:18 <mah_b> docTony: looking better/being more understandable is some kind of `sense' :)
06:00:24 <Peaker> kmc: You there?
06:00:25 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
06:00:30 <Axman6> is it clearer if main says: load the file, then check it, then parse it, then save the results? i mean, that is what the program does at the top level really
06:00:30 <docTony> that's right :-)
06:01:05 <docTony> at the top level it is mapping a directory of files over the function
06:03:16 <int-e> docTony: maybe the mapping function just knows too many details -- couldn't it just take a single IO action that takes a file name as its argument? (i.e., a parameter of type (FileName -> IO ())
06:04:37 <Peaker> @message kmc Can I use your slides at http://ugcs.net/~keegan/talks/why-learn-haskell/talk.pdf for a Haskell talk?
06:04:37 <lambdabot> Maybe you meant: messages messages?
06:04:43 <Peaker> @tell kmc Can I use your slides at http://ugcs.net/~keegan/talks/why-learn-haskell/talk.pdf for a Haskell talk?
06:04:43 <lambdabot> Consider it noted.
06:09:54 * Baughn falls head over heels in love with quickcheck
06:10:24 <elliott> Baughn: what took you so long?
06:11:13 <Baughn> elliott: I was always writing IO-heavy, nondeterministic code before
06:12:14 <elliott> :-(
06:15:05 <docTony> The function only takes a filename, but then in that function there is a group of related actions (as in, done with the file? then do the following standard actions) that I wanted to group together that require data from the previous function
06:16:01 <docTony> perhaps I should group them in a map or something, and then hand over the map...
06:19:24 <dafis> @ty foldM
06:19:25 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
06:19:50 <dafis> docTony: maybe you need foldM then rather than mapM(_)
06:23:11 <docTony> what would be the advantage? How can I give 10 arguments to a foldM ?
06:23:51 <elliott> you don't want to give ten arguments to anything
06:24:10 <docTony> indeed, that was my problem. I was just discussing how to avoid that
06:24:26 <int-e> you can incorporate them all into the a -> b -> m a argument.
06:26:16 <int-e> But we're still discussing this completely academically without a concrete task at hand. This is not (and can not be, IMHO) effective.
06:28:28 <erus`> why cant haskell use raii or reference counting instead of GC?
06:29:36 <elliott> reference counting is slow and broken, raii is not a memory management strategy
06:30:10 <Peaker> erus`: RAII still has explicit resource deletion and brackets.  Haskell supports the latter, and the former requires imperative style
06:30:21 <erus`> is smart_ptr reference counting?
06:30:30 <Peaker> reference counting is a form of (broken) GC, and not efficient nor deterministic
06:31:39 <int-e> in what sense is it not deterministic?
06:33:36 <engla> erus`: normally yes
06:34:09 <erus`> so i can do a cyclic reference with smart_ptr :(
06:35:00 <engla> erus`: yep, you need weak_ptr to not make cycles.. for the parts you "know"
06:35:27 <rotflcopter> ahaha
06:35:28 <rotflcopter> http://www.youtube.com/watch?feature=player_detailpage&v=Q_NMxazFqCA
06:35:31 <int-e> That's not viable for a generic graph reduction machine.
06:36:02 <rotflcopter> create a transfer function on this
06:36:59 <erus`> rotflcopter: staged...
06:37:27 <erus`> engla: why not just a normal pointer?
06:37:31 <rotflcopter> maybe ;<
06:39:17 <engla> erus`: then you can have a dangling pointer. shared_ptr manages the resource and a normal ptr would allow you to escape that safety
06:39:36 <extrados> How do I check the type of a variable within a program? (I want to write a polymorphic function)
06:40:24 <engla> extrados: you can use a typeclass
06:41:35 <Peaker> extrados: to write polymorphic functions, you don't generally "check their types".. What do you want to do?
06:43:43 <extrados> Most basically I just want something like 'division a b = a / b' if a and b are Fractional and 'division a b = (fromIntegral a) / (fromIntegral b)' if a and b are Integral
06:46:57 <Peaker> extrados: I don't think there's a valid H98 way to do that. But you can make a new class for division and just make a whole lot of instances for the various cases
06:50:26 <bfig> how can i make something of kind * be an instance of a class?
06:50:51 <extrados> Peaker: I just found Data.Typeable which looks like it allows for type-based guards
06:50:54 <yitz> bfig: you don't
06:51:09 <yitz> extrados: you usually don't do things that way in Haskell
06:51:36 <yitz> extrados: Haskell is intentionally not an OO language
06:51:36 <bfig> yitz, it is irrelevant whether it will be for a nice purpose, i'm trying to make some weird function
06:52:10 <bfig> extrados, check phantom types :)
06:52:15 <yitz> bfig: but to create an instance you need it to have kind * -> * or higher
06:52:42 <bfig> this is allegedly doable without any extensions
06:52:59 <bfig> i'm checking Text.Printf function and it does the kind of stuff i want to do
06:53:28 <Peaker> extrados: I am not sure if that will work the way you want it to
06:54:34 <dgpratt> a question was posted on SO recently that got me to thinking: if I could somehow understand what the heck was going on in the code, I would level up massively on my understanding of Haskell's type system
06:54:36 <bfig> extrados, if you want to pattern match against types you're looking at some form of simulated dependent typing -> phantom types
06:55:03 <dgpratt> alas, after staring at it for some time, I'm getting nowhere
06:55:10 <dgpratt> this: http://stackoverflow.com/questions/7866375/why-does-ghc-think-that-this-type-variable-is-not-injective
06:55:14 <bfig> dgpratt, what are you having problem with?
06:55:40 <rangless> OK, a web search hasn't answered this question conclusively, so I'll ask it here: where is the standard Either Monad instance defined (i.e. how do I import it)?
06:55:42 <dgpratt> I can't figure out what is being accomplished by the type system contortions
06:56:44 <dgpratt> I've seen examples of both fundeps and GADTs that I thought I understood, but altogether like this...I'm lost
06:58:45 <engla> yitz: which instance? instance Monoid Int where  is fine and Int is *
06:58:49 <Schalken> Where can I get an instance of NFData for Data.Text.Text? (In fact in general, how do I search for class instances?)
06:59:17 <bfig> Schalken, try hayoo?
06:59:36 <dafis> rangless: That depends. In newr ghc & packages, import Control.Monad.Instances; previously, import Control.Monad.Error, assuming you use mtl-1.*
07:00:24 <bfig> is there a class every first class object belongs to? i need to range over all *'s
07:00:32 <Schalken> bfig: What do I type? I'm not sure it searches for class instances.
07:00:52 <bfig> Schalken, why don't you try instance NFData
07:00:55 <bfig> or just NFData?
07:01:20 <rangless> dafis: thanks
07:01:40 <bfig> Schalken, hoogle leads to a single page when writing NFData
07:01:43 <bfig> http://hackage.haskell.org/packages/archive/deepseq/latest/doc/html/Control-DeepSeq.html#t:NFData
07:02:31 <yitz> engla: Monoid has kind * -> *
07:02:49 <Schalken> bfig: Which I know doesn't mention Data.Text. But there might be an instance in another module, I just need to find it...
07:03:10 <bfig> yitz, Monoid Int has type *
07:03:45 <bfig> i need something like ' instance forall a. Whatever a where '
07:04:31 <engla> Monoid has a kind? that's outside my range
07:05:18 <yitz> bfig: why do you need a class then? just write the function.
07:05:37 <Schalken> bfig: Wait. There is an instance of NFData in the Data.Text module itself. So if I have NFData Text, NFData Double and (NFData k, NFData v) => NFData HashMap k v, why don't I have "No instance for (NFData (HashMap Text Double))"? :(
07:06:10 <Schalken> why do I have*
07:06:20 <bfig> why do you have?
07:07:04 <bfig> yitz, i need to make a recursive function on the size of the arg list: instance (VarArg a) => VarArg b->a where
07:07:40 <yitz> bfig: ah that sort of thing. oleg has an article about how to do that.
07:09:34 <bfig> yitz, thanks! found the page
07:13:21 <fasta> How do I get todays date in some pretty format? One would expect a function like 'today'.
07:14:07 <sipa> if it's a function, what would be its argument?
07:14:42 <fasta> sipa: the RealWorld?
07:14:58 <fasta> sipa: today::IO()
07:15:11 <fasta> er IO Day
07:15:50 <Schalken> How come when I "cabal install text", in installs text-0.11.1.5, then I have no module found on Data.Aeson, so I install "cabal install aeson" and it reinstalls text-0.11.1.5 and aeson works, then I do "cabal install text" again and it reinstalls text-0.11.1.5 and aeson doesn't work again. :(
07:16:10 <fasta> Never mind.
07:16:13 <zax> http://haskell.org/haskellwiki/Date
07:16:14 <zax> ?:)
07:16:14 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
07:17:11 <mah_b> @type Data.Time.Clock.getCurrentTime
07:17:12 <lambdabot> IO time-1.1.4:Data.Time.Clock.UTC.UTCTime
07:17:25 <Schalken> I don't understand what's going on. It's like "aeson" doesn't like the version of "text" that gets installed when I do "cabal install text", so it reinstalls it, even though they are the same version, 0.11.1.5.
07:18:20 <dcoutts> Schalken: try: cabal install --dry-run -v aeson
07:18:27 <dcoutts> it'll say what it's reinstalling and why
07:19:10 <yitz> fasta: dateFmt defaultTimeLocale from the old-locale package.
07:19:40 <Schalken> dcoutts: "text-0.11.1.5 (reinstall) changes: deepseq-1.2.0.1 -> 1.1.0.2" So the problem is it has to reinstall it because it wants another version of deepseq to be used with it?
07:20:00 <yitz> fasta: or use the format characters to make it pretty however you'd like
07:20:29 <dcoutts> Schalken: right
07:20:47 <Schalken> This would explain why I can't get an instance of DeepSeq Text. :(
07:21:08 <Schalken> dcoutts: Is there anything I can do besides waiting for a package update?
07:21:09 <dcoutts> Schalken: you can try: cabal install --dry-run -v aeson text
07:21:35 <dcoutts> Schalken: in general, cabal install a; cabal install b;  /=  cabal install a b;
07:21:37 <Schalken> dcoutts: Same output.
07:22:09 <dcoutts> Schalken: if you ask for both to be installed together then it will ensure they can be installed together with consistent deps, or die trying
07:22:35 <dcoutts> if you ask for a single package then it just tries to install that one package (and generally prefers to use the installed or latest version of other packages)
07:22:50 <dcoutts> and currently it doesn't tell you when installing something will break other installed packages
07:22:59 <Schalken> dcoutts: Aha. If I do "cabal install --dry-run -v text aeson deepseq-1.2.0.1" I get "cabal: cannot configure aeson-0.3.2.12. It requires deepseq <1.2"
07:23:00 <dcoutts> which is what is happening to you with the aeson package
07:23:45 <dcoutts> Schalken: right, so you can try using older versions of them, e.g. cabal install --dry-run -v text 'aeson < x.y'
07:24:02 <Schalken> dcoutts: And sure enough there "deepseq < 1.2" is in the list of dependencies for aeson.
07:24:12 <dcoutts> Schalken: otherwise, wait for an update, or cabal unpack and update it yourself (if you do this, bump the minor version)
07:25:38 <Schalken> dcoutts: "aeson-0.3.2.11 deepseq-1.2.0.1" installs. But surely there's a reason the latest package depends on deepseq < 1.2?  I can't just go installing old version of packages throwing away whatever bug fixing was since done.
07:25:58 <elliott> if it installs then aeson is OK with it
07:26:09 <elliott> oh, i see
07:26:10 <Schalken> Hmm.
07:26:15 <elliott> yes, IIRC that was intentional
07:26:23 <elliott> I think deepseq changed some API?
07:26:27 <elliott> I might be wrong, ignore me :)
07:26:31 <dcoutts> Schalken: yeah, you have to use your nouse to decide if it makes any sense
07:26:52 <dcoutts> sometimes using older versions is fine, they just updated to become compatible with newer stuff
07:27:18 <Schalken> dcoutts: I take that back. It was accepted by --dry-run, but an actual install fails with "No instance for (NFData Object)".
07:27:22 <elliott> restricting a dependency is a rather intentional thing though :p
07:27:31 <dcoutts> Schalken: ah ok
07:27:47 <Schalken> So I'm basically screwed. :P
07:28:14 <dcoutts> the latest text only needs deepseq (≥1.1.0.0)
07:28:22 <dcoutts> Schalken: what am I missing?
07:29:19 <Schalken> dcoutts: Sorry, the original problem was I can't get an NFData Text instance.
07:29:42 <Schalken> dcoutts: I was thinking not having the latest version of deepseq had something to do with it.
07:30:17 <Schalken> dcoutts: Data.Text defines an instance according to hackage, but I don't have access to it for some reason, even with the latest version of text.
07:30:49 <dafis> Schalken: the NFData instance for Text is in text, so if you have both, text and aeson depend on deepseq-1.1.*, it should be fine
07:32:18 <Schalken> dafis: That's what I thought. But I import Data.Text and Control.DeeqSeq and do "deepseq ((Text.pack "") :: Text) 0" and I get "No instance for (NFData Text)".
07:32:32 <Schalken> dafis: Even though I have the latest version of text.
07:33:20 * Baughn tries and fails to get \bot working locally
07:33:29 <dafis> Schalken: that's probably because Control.DeepSeq is loaded from another version of deepseq than text was built against
07:34:19 <Schalken> dafis: Errr, well, how do I import a specific version of Control.DeeqSeq then? :/
07:35:42 <dafis> Schalken: specify package version in .cabal file, use -hide-package and -package on the command line
07:40:47 <Schalken> dafis: Whooooo! ghc unregister deepseq-1.2.0.1 did it. Here I was thinking "Oh, I should install the latest version of deepseq" thinking it could only help, but it broke everything and wasted an hour of my time :(.
07:41:21 <Schalken> dafis: dcoutts: bfig: Thanks for your help.
07:42:10 <dcoutts> Schalken: note also that using cabal to build your code would have helped, since it'd pick consistent versions of packages (which on it's own, ghci does not)
07:43:05 <dafis> Schalken: if you install a newer version of a package near the root of the dependency graph, like deepseq, you'll have to rebuild a lot of packages to avoid such breakage
07:44:19 <dafis> Schalken: so, install such only if the update fixes a serious bug
07:44:40 <dafis> (or you're rebuilding a lot anyway)
07:44:48 <mirari_> I talked to some people today about the potential disadvantages of lazy evaluation w.r.t. creating huge thunks in the heap. As a newbie to Haskell, is this a real problem, or only a problem for some special applications? And what are the potential solutions?
07:45:11 <fasta> mirari_: a completely theoretical problem.
07:45:16 <bfig> mirari_, you can do some special programming styles that avoid building huge thunks
07:45:28 <fasta> bfig: that's not what he is talking about.
07:45:39 <Schalken> mirari_: seq is your friend.
07:45:45 <Polarina> mirari_, in my experience, you will only see such problems the first time you run your program. Then you fix it and never bother with that again.
07:45:51 <fasta> mirari_: or rather that's not what we were talking about.
07:46:15 <fasta> mirari_: the lazyness issue is a real problem which only requires that you know what you are doing.
07:46:15 <bfig> mirari_, for example, folding from the left or from the right? or folding from the left, in strict way?
07:46:57 <mirari_> wow, lot of feedback, thanks
07:47:26 <Schalken> mirari_: It's a controversial topic. ;)
07:47:30 <bfig> mirari_, i suggest you experiment with the list and folding sums, profile the stack
07:47:48 <mirari_> I haven't run into it yet, but somebody just mentioned it today, and I was reading about 'seq' in Real World Haskell
07:47:49 <bfig> fold from the left, from the right, from the left strict, from the right strict, and reason about your code
07:48:08 <bfig> mmm there is no 'fold from the right strict' i think >_>
07:48:20 <Schalken> bfig: Yeah I don't think there is.
07:49:18 <mirari_> I guess I should just have it in the back of my head, and if the heap explodes, then I know where to start.
07:49:35 <mirari_> bfig: yeah, it might be a good idea to write some programs just to play around with it.
07:49:43 <bfig> it's sometimes more than just about exploding, sometimes you get huge efficiency gains
07:49:52 <bfig> same with list memoization
07:50:18 <bfig> consider the difference of using a list, from a memoized list, from a memoized, treelike structure
07:50:54 <bfig> from a memoized treelike structure of a bigger base
07:51:39 <mirari_> I don't quite follow. I know memoization in the context of dynamic programming, but what do you mean when you say "list memoization" ?
07:53:11 <bfig> if i define fibo = 1:2:fibs 2; fibs n = fibo (n-1) + fibo (n-2) : fibs (n+1) i'm memoizing
07:53:28 <bfig> because the list fibo is constant, it will always evaluate to the same
07:54:41 <bfig> if i define fibo n = if n < 2 then 1 else fibo (n-1) + fibo (n-2) : fibo (n+1) then you use it as fibo n
07:54:55 <bfig> (the first fibo should be 1:1: instead of 1:2:...)
07:55:28 <bfig> which one do you think will be more efficient? take n fibo (the first) or  fibo n (the second) ?
07:56:00 <bfig> (change to the first: fibo (k) ==> fibo!!k
07:56:44 <bfig> mirari_, do you understand the difference?
07:56:56 <eichi> hello! why cant I do Prelude> sort "helloworld" ? I get "sort" not in scope
07:57:39 <dafis> eichi: import Data.List
07:57:40 <int-e> bfig: sorry, what is the : fibo (n+1) supposed to do in the second version?
07:57:40 <mirari_> bfig: Yes, I think so
07:58:10 <eichi> dafis: oh okay, thanks
07:58:14 <elliott> Is there an efficient way of doing (init xs, last xs)?
07:58:17 <bfig> int-e, recursively build itself
07:58:21 <elliott> Apart from writing the function manually.
07:59:09 <bfig> ohh yes it is still a !!
08:01:16 <bfig> you need a way to use the last argument, w/e. fibN n = if n < 2 then 1 else fibN (n-1) + fibN (n-2); fibs = map fibN [0..]
08:02:10 <bfig> now you're not memoizing, and are recomputing every time the arguments
08:02:29 <yitz> elliott: you mean the problem that you might then cause the entire list to be held in memory so that you can call last separately?
08:02:44 <profmakx> lle
08:02:48 <elliott> yitz: the problem that it traverses the list twice... just a pet peeve, really :)
08:03:36 <yitz> elliott: there's not much difference in speed between traversing the list twice and checking two different things as you traverse it once
08:03:51 <elliott> "checking two different things"?
08:03:58 <quicksilver> on a modern system with caches, that could be all the difference in the world yitz :)
08:04:13 <elliott> yitz: f [x] = ([],x); f (x:xs) = (x:xs',y) where (xs',y) = f xs
08:04:15 <yitz> quicksilver: true
08:04:55 <shachaf_> The GC issue is also significant.
08:05:30 <yitz> elliott: so you check whether the list has exactly one element, and then again whether it is empty, at each step.
08:06:07 <elliott> fair enough... I still feel bad doing multiple traversals over [] though
08:06:30 <shachaf_> init and last both check that anyway, don't they?
08:06:31 <yitz> elliott: so if you're worried about memory retension, or as quicksilver points out, chache hits, that's one thing. but just "not traversing twice" just for the sake of it? why?
08:06:50 <elliott> shachaf_ is right though
08:07:44 <yitz> elliott: people were taught that as a fundamental value in programming in the 1960's when computers were pretty slow. nowadays, just the fact that you are traversing twice may be a very minor issue, or none at all, especially in a lazy language.
08:08:09 <elliott> no matter how you wall me in, I can escape with the gc issue :)
08:08:15 <yitz> yes shachaf_ is right
08:08:30 <yitz> elliott: yes gc is an issue
08:08:34 <shachaf_> On the other hand you have to deconstruct a bunch of tuples. I don't know if that's significant or not.
08:09:17 <yitz> shachaf_: you have to be pretty deep into optimization before that becomes an issue. by then you'll probably be using unboxed tuples anyway.
08:09:20 <elliott> shachaf_: f k [x] = k [] x; f k (x:xs) = f (\xs' y -> k (x:xs') y) xs
08:09:20 <elliott> :p
08:09:58 <shachaf_> Yep.
08:10:36 <shachaf_> The Yep was for yitz, by the way. elliott probably deserves more of a Nope.
08:18:18 <eichi> I did this: sort . group $ "sort and group this string an then count length if grouped lists because I want to have the count of every character"
08:18:45 <eichi> but I need the length if the groups in the list now, something with fold, but I dont understand
08:19:04 <xivix> ah
08:19:07 <eichi> oh sorry, I mean group . sort
08:19:26 <eichi> then I have ["aaaaaaaaaaaaaa","bbbbbbbbbbbbb","ddd...... and so on
08:19:28 <dafis> eichi: map length . group . sort $ "..." ?
08:19:30 <eichi> but need length now
08:19:59 <hpaste> rostayob pasted “oh well” at http://hpaste.org/53070
08:20:00 <dafis> or map (\grp@(h:_) -> (h, length grp))
08:20:13 <rostayob> what was this bug again: http://hpaste.org/53070 ?
08:20:24 <rostayob> if you try to compile that ghc goes nuts
08:20:37 <rostayob> i just stumbled upon it but i remember reading it somewhere
08:20:56 <Jafet> map (head &&& length)
08:21:41 <geheimdienst> Jafet: oh, handing arrows to the newbies are we
08:22:26 <Jafet> Piercing clarity.
08:23:06 <Baughn> @pl f (a,b) (_,c) -> (a,b+c)
08:23:06 <lambdabot> (line 1, column 10):
08:23:06 <lambdabot> unexpected "_"
08:23:07 <lambdabot> expecting lambda abstraction or expression
08:23:12 <Baughn> @pl f (a,b) (_,c) = (a,b+c)
08:23:12 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . (. (+)) . (.) . (,))
08:24:01 <Baughn> Hm. Was hoping for something simpler. Arrow.second /almost/ does what I want..
08:25:13 <Yacoby> A stupid question, but how would I convert ParsecT s0 u0 m0 [[Char]]
08:25:18 <Yacoby> to ParsecT s0 u0 m0 [Char]
08:25:20 <dafis> rostayob: constraint not smaller than instance head, except for the context-stack, I'd expect it to loop
08:25:34 <Baughn> Yacoby: liftM concat?
08:25:57 <Yacoby> Baughn: Cheers
08:26:22 <Yacoby> I don't know why I was doing what I was trying to do
08:26:34 <dafis> @ty const *** (+)
08:26:35 <lambdabot> forall b b1 b'. (Num b') => (b, b') -> (b1 -> b, b' -> b')
08:28:22 <eichi> dafis: I try now this one: map (\grp@(h:_) -> (h, (fromInteger (length grp))/ (fromInteger 654))) but I get Couldn't match expected type `Integer' with actual type `Int'
08:28:49 <dafis> eichi: fromIntegral for things /= Integer
08:28:54 <dafis> :t fromIntegral
08:28:55 <lambdabot> forall a b. (Integral a, Num b) => a -> b
08:29:51 <eichi> okay, but how to divide length and a number then?
08:30:41 <dafis> fromIntegral (length "numerator") / fromIntegral (length "denominator")
08:30:46 <dafis> > fromIntegral (length "numerator") / fromIntegral (length "denominator")
08:30:47 <lambdabot>   0.8181818181818182
08:31:23 <dafis> > length "length" `div` 3
08:31:24 <lambdabot>   2
08:32:25 <dafis> eichi: by the way, if you're using a numeric literal, you don't need a fromInteger, that's implicit in the literal
08:32:36 <dafis> > 123 / 17
08:32:36 <lambdabot>   7.235294117647059
08:33:20 <eichi> map (\grp@(h:_) -> (h,  fromIntegral(length grp)/ 654)        gives parse error (possibly incorrect indentation)
08:34:09 <dafis> eichi: missing a closing )
08:34:10 <eichi> oh okay
08:34:49 <dafis> eichi: configure your editor to highlight brackets
08:34:59 <dafis> (stuff between)
08:35:14 <nominolo> @users
08:35:15 <lambdabot> Unknown command, try @list
08:35:25 <nominolo> preflex: @users
08:36:02 <yitz> preflex: users
08:39:06 <Athas> I have a question about weak pointers (as in Sys.Mem.Weak).  If I associate a key with some weak value, what guarantee do I have that the key will actually be kept alive?
08:39:31 <Athas> This seems to attach a notion of "identity" to the key, but does GHC guarantee that this identity will be kept, or do I risk my weak pointer being freed before I expect?
08:39:53 <Athas> I mean, GHC might choose to internally copy the key for some reason, and I don't know whether that maintains its identity.
08:40:05 <Athas> I could not really find much information about this in the docs.
08:41:20 <nominolo> Athas: what do you mean by identity?
08:41:27 <nominolo> Do you want to use IORefs as keys?
08:43:31 <Athas> nominolo: how do keys work wrt. weak pointers if there is no notion of identity?
08:44:40 <Athas> According to the module documentation, a weak pointer V is kept alive (by the GC) as long as its associated key K is also alive.  Surely this implies some sort of identity on behalf of K?
08:45:05 <nominolo> Athas: yes, but that's not observable
08:45:35 <nominolo> I guess that might cause problems for some finalisers, if it's not actually unique
08:45:42 <rostayob> dafis: yes, it loops
08:46:11 <Athas> nominolo: it is observable, as V dies when K does, and K is only kept alive as long as its identity remains constant.
08:46:19 <Athas> Thus I wonder under which circumstances identity is kept.
08:46:49 <kosmikus> you have no guarantee that V dies immediately
08:47:35 <Athas> That's not the issue.
08:47:36 <kosmikus> but I admit that I don't fully understand the question
08:48:13 <dafis> rostayob: I don't think that's a bug
08:48:34 <Athas> The problem is that as per observable Haskell semantics, I keep K alive (by putting it in a data structure and passing it around - usual stuff).  But which guarantee do I have that, under the covers, the storage manager will not implement one of these operations by *copying* K, and thus destroy its identity, and freeing my weak pointer?
08:49:55 <nominolo> Athas: if it copies K it also needs to copy the association with V
08:49:56 <Athas> The usage examples for weak pointers mention memoization and things, in which case this would not be a problem (all you'd end up with is recomputing some values more than necessary), but if I desperately need what the weak pointer points at...
08:50:10 <Athas> nominolo: thanks.  That was not explicit in the documentation.
08:50:37 <nominolo> Athas: well, that's what I would expect
08:50:49 <Athas> I'm reading a paper on the GHC storage manager now.  I want to be sure...
08:50:50 <dafis> rostayob: ah, wait it actually loops, doesn't cop out with context-stack exhausted?
08:51:08 <rostayob> dafis: no, it actually loops
08:51:11 <nominolo> feel free to send a message requesting clarifcation on glasgow-haskell-users
08:51:18 <rostayob> and it is a bug, those statements are well typed as far as i can see
08:51:26 <rostayob> and even if they weren't it just goes on forever ehe
08:52:21 <nominolo> Athas: also look at https://github.com/ghc/ghc/blob/master/rts/sm/MarkWeak.c
08:52:30 <dafis> rostayob: it needs Inferable a ~> Inferable (a -> a) ~> Inferable ((a -> a) -> (a -> a)) ~> ...
08:53:07 <rostayob> dafis: right...
08:53:57 <rostayob> it should still output some error right?
08:53:58 <nominolo> Athas: actually, small Ints and Chars (7bit ASCII) do not preserve their identity, so you could write some stress tests by using those as keys
08:54:30 <Athas> nominolo: hm.
08:55:42 <nominolo> Athas: actually, that's quite an interesting problem:  the GC rewrites any (I# n) (where n >= -128 && n <= 127) to a pre-allocated cache
08:55:51 <nominolo> which might mean that such a key never dies
08:55:59 <dafis> rostayob: it does, if you pass it a small enough context-stack, the default may just take very long to produce the error since the size of the context grows exponentially
08:56:00 <nominolo> hence no finalisation ever happens
08:56:33 <nominolo> Athas: pretty much anything else is internally identity preserving due to forwarding pointers by used by the GC
08:56:33 <rostayob> dafis: ah, so if i let it run long enough it should terminate?
08:58:16 <dafis> rostayob: if you have enough memory, it'll finally print a loooong diagnosis and terminates (not in the sense of completes) the compilation
08:58:39 <dafis> rostayob: try -fcontext-stack=14 for example
08:58:55 <Athas> nominolo: alright, that's good to know.  My keys are newtyped things so it would work, but it sounds brittle.
08:58:59 <Athas> I'll have to think hard on this.
08:59:15 <nominolo> Athas: yes, ask Simon M about this
08:59:32 <rostayob> dafis: yep, that stops quickly
09:01:37 * Baughn wonders how to get "integer between 2 and 7" for one of his quickcheck test parameters
09:01:38 <dafis> rostayob: were you trying with HEAD?
09:03:04 <Athas> nominolo: you wouldn't happen to know offhand if System.Mem.Weak.finalize will also ensure that the finalizer is never run again, would you?
09:03:15 <Athas> What happens if the weak pointer is already scheduled for finalization.  Hm.
09:05:04 <quicksilver> Baughn: use an explicit Gen with forAll
09:05:19 <rostayob> dafis: no, with 7.0.3
09:05:48 <rostayob> dafis: btw, is there a detailed description on how UndecidableInstances/OverlappingInstances/IncoherentInstances algorithms work?
09:06:41 <quicksilver> Baughn: forAll (choose (2,7)) $ \n -> {- property which depends on n being between 2 and 7 -}
09:07:07 <Baughn> Ooh
09:08:47 <quicksilver> something somewhere has to pin down the type of n otherwise you'll get an ambiguity error
09:08:50 <yitz> rostayob: the ghc user manual
09:08:53 <quicksilver> obviously you can add a type annotation
09:13:37 <rostayob> yitz: right, I couldn't find incoherent instances, it's under overlapping instances
09:23:16 <nominolo> Athas: sorry, no
09:25:25 <Peaker> @seen kmc
09:25:25 <preflex>  kmc was last seen on #haskell 7 hours, 23 minutes and 25 seconds ago, saying: going to sleep now, 'night all
09:25:25 <lambdabot> Unknown command, try @list
09:25:41 <Peaker> 7 hours and 23 minutes of sleep ought to be enough for anybody...
09:30:44 <ololo_> @pl \ f-> (id ~> id ~> ((put $!) . f =<< get))
09:30:44 <lambdabot> (line 1, column 11):
09:30:44 <lambdabot> unexpected "~"
09:30:44 <lambdabot> expecting variable, "(", operator or ")"
09:31:03 <ololo_> @pl \ f -> (id + id + ((put $!) . f =<< get))
09:31:03 <lambdabot> ((id + id) +) . (get >>=) . ((put $!) .)
09:32:07 <yitz> Peaker: i would say count on using the slides, the chances of him saying no are inifinitesimal
09:32:23 <Ololo> @pl \ v k -> (id + id +) . (get >>=) . ((put $!) .) $ alter ((<|> pure (singleton v)) . fmap (insert v)) k
09:32:23 <lambdabot> ((((id + id) +) . (get >>=) . ((put $!) .)) .) . alter . ap ((.) . flip (<|>) . pure . singleton) (fmap . insert)
09:33:06 <Peaker> yitz: heh :) I also need to get up to speed with threadscope, which is shown there and I haven't used
09:33:17 <yitz> mm
09:34:16 <elliott> Is there a nicer way to write "StateT . const . return"?
09:35:31 <dmwit> :t StateT . const . return
09:35:32 <lambdabot> forall s (m :: * -> *) a. (Monad m) => (a, s) -> StateT s m a
09:35:56 <dmwit> :t \(a, s) -> put s >> return a
09:35:57 <lambdabot> forall t t1 (m :: * -> *). (MonadState t1 m) => (t, t1) -> m t
09:36:15 <dmwit> ?pl \(a, s) -> put s >> return a
09:36:16 <lambdabot> uncurry (flip ((>>) . put) . return)
09:36:29 <dmwit> I don't think I'd use the point-free version for that one. ^_^
09:36:51 <dmwit> But the pointful version looks quite readable to me.
09:36:58 <yitz> Peaker: JaffaCake has pretty good instructions on the Threadscope page
09:38:05 <elliott> dmwit: Yeah, I'm just trying to convince myself that this slightly-more-correct-seeming variant on SupplyT is actually more elegant...
09:38:07 <Chaze> does anyone have some inspiration for a Haskell-related Bachelor thesis topic? Basically anything that you could write a little paper on
09:38:19 <Chaze> ..i hope i'm not annoying you guys by asking this over and over^^
09:41:09 <Ololo> Chaze: do some codegen
09:41:27 <Chaze> Ololo: meaning? compiling another language back and forth to haskell?
09:41:53 <Peaker> yitz: thanks, will take a look
09:42:11 <Jafet> Generate HTML code!
09:42:35 <byorgey> Chaze: is it supposed to be original research? or just summarizing/explaining/synthesizing some existing topic?
09:42:39 <Ololo> Chaze: meaning you write something like print $ runCG $ do { ... }, and get something like whats inside the brackets, but in C++
09:42:54 <Chaze> byorgey: it can be the latter
09:43:04 <Chaze> i would prefer something with light implementation of something new
09:43:16 <Ololo> Chaze: just take a look at this http://tom.lokhorst.eu/2010/02/awesomeprelude-presentation-video
09:44:51 <Ololo> Chaze: HTML generation would be somewhat useful. Especially if you could make it to generate columns etc. It's the pain to do it by hand.
09:45:23 <Chaze> Ololo: i'm afraid that's not "scientific" enough for a thesis project
09:45:38 <Chaze> watching that video later, btw. thanks
09:46:34 <byorgey> Chaze: you could explain the new ConstraintKinds extension, and collect some good examples of its use (and maybe make some new examples of your own)
09:46:41 <Ololo> Chaze: yep, could be a problem making serious dudes to believe it was scientific
09:48:06 <byorgey> Chaze: are you looking for something theoretical, practical, or in between...?
09:48:19 <Chaze> in between would be perfect
09:48:32 <Chaze> i *have* to write about it (50-100 pages)
09:48:39 <Ololo> byorgey: I have a rare chance to ask haskell master, so here I go: what are the reasons for all of the modern type system extensions?
09:48:40 <Chaze> but i would like to do some implementation
09:49:03 <Jafet> Ololo: thesis projects!
09:49:07 <elliott> oh, hi byorgey
09:50:05 <Ololo> byorgey: I mean why shouldn't one just get into something Turing-complete and stop imaginating?
09:50:18 <monochrom> every extension has a different reason. you should ask each one specifically
09:53:39 <monochrom> as for why not use a language unrestrictive: take assembly code for example. I know that smart people can use it effectively, write by hand and get stuff done quickly and 0 bugs. I am dumb, I can't do that, I need restrictions to catch my mistakes, and I need abstraction mechanisms (lambda, modules, polymorphism...) to speed me up
09:53:56 <Ololo> monochrom: to test, whether the program in Turing-complete language has certain behaviour, one should use Turing-complete language. The only reason for typing is type inference. The reasons behind modern extensions are quite unclear: type inference is usually undecidable  there.
09:56:41 <elliott> Ololo: huh?
09:59:37 <yitz> Ololo: if you use enough extensions, it *is* turing complete. which is why we often avoid doing that.
10:00:45 <Ololo> elliott: don't you think typechecking all that extensions could be regarded as usual compile-time computation? why should one extend type system, losing type inference etc, but do not use dependent typing, which does just the same, but 10 times simplier?
10:01:10 <Eliel> what's the reason the bounds function for IArray class is defined generally for all boxed arrays but is only defined for specific cases for unboxed arrays?
10:01:15 <elliott> Ololo: have you ever used a dependently-typed language? i'm guessing not
10:01:33 <byorgey> hi elliott
10:02:23 <sm> +RTS -s will show output every so often, when a GC happens, right ?
10:02:34 <elliott> byorgey: :) -- I fixed my model of and implemented the generalised supply monad, plus full mtl support, but then I realised that my definition of the monad is slightly semantically wrong... I'll probably put something on Hackage tomorrow after I stop wavering over which to go with :)
10:02:51 <elliott> sm: unless you have a non-allocating loop, I guess
10:02:51 <byorgey> hah, ok =)
10:02:56 <Ololo> elliott: You're guessing right. What's wrong with them?
10:03:11 <byorgey> Ololo: nothing is wrong, but they are not "ten times simpler"
10:03:29 <elliott> Ololo: nothing "wrong", it's just about tradeoffs
10:03:46 <elliott> if they were easier and simpler than haskell in their current state, we'd all be using them :-)
10:03:54 <elliott> (for general programming)
10:04:37 <Ololo> elliott: Umm, okay.
10:05:37 <sm> elliot: thx
10:06:56 <dmwit> Ololo: Often, with a dependently typed program, you must provide a proof that something has a specific type.
10:07:23 <dmwit> Ololo: With many of the extensions available in GHC today, the type inference is undecidable, but providing the proof that a thing has a specific type *is* doable.
10:07:41 <dmwit> So this can save a lot of programmer effort when the full generality of dependent types is not needed.
10:08:12 <dmwit> So "type inference" is not the only reason to use a less-than-dependent type system.
10:09:22 <elliott> Ololo: (...and dependent type system =/= turing-complete type system; the latter are inconsistent)
10:10:25 <companion_cube> really? A turing complete type system must be inconsistent?
10:10:53 <dmwit> Turing completeness implies the ability to write a loop.
10:11:19 <sipa> yes, how does that equal inconsistency?
10:11:23 <Ololo> dmwit: one cannot go recursive with dependent types?
10:11:41 <dmwit> Ololo: Sorry, what?
10:12:14 <Ololo> dmwit: Umm. Recursive computation on values, which are used inside types
10:12:23 <dmwit> sipa, companion_cube: Hrm. Good question. =)
10:12:50 <dmwit> Ololo: That sounds fine. What did I say that implied that would not be okay?
10:13:08 <elliott> hmm, well
10:13:11 <elliott> it might not be inconsistent
10:13:18 <elliott> but if your proof checker doesn't terminate...
10:13:34 <dmwit> sipa, companion_cube: Typically, it's possible to give a loop the type "forall a. a" or equivalent. Which is definitely inconsistent.
10:13:40 <elliott> yeah but that's TC language
10:13:45 <elliott> I guess if a TC language makes the type system's logic inconsistent, then a TC type system makes the kind system inconsistent :-D
10:14:10 <dmwit> yes =)
10:14:56 <dmwit> Anyway, dependent type system =/= TC value system. =)
10:16:43 <companion_cube> dmwit: and what if you don't have a loop?
10:16:52 <companion_cube> in you language
10:17:05 <dmwit> Then it's not Turing complete.
10:17:27 <Ololo> dmwit: haskell doesn't have loops. It's not TC? )
10:17:34 <dmwit> Haskell does have loops.
10:17:34 * companion_cube meant "recursion instead of loop"
10:17:35 <dmwit> ?src undefined
10:17:36 <lambdabot> undefined =  error "Prelude.undefined"
10:17:40 <Mauke> :t forever
10:17:41 <dmwit> ick
10:17:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:17:43 <dmwit> undefined = undefined
10:17:45 <companion_cube> like, unlambda, let say
10:17:46 <dmwit> Is a loop.
10:18:00 <dmwit> And, you'll notice:
10:18:05 <dmwit> :t let undefined = undefined in undefined
10:18:06 <lambdabot> forall t. t
10:18:12 <dmwit> inconsistency, right there =)
10:18:30 <Ololo> OH, SHI~
10:18:54 <dafis> sm: +RTS -s will only orint the stats after the run is over, to get informed on each GC, use +RTS -S
10:19:09 <companion_cube> so you mean that if you have _|_ as a value, it is untypable
10:19:26 <dmwit> Nonsense. _|_ is typable at any type.
10:19:29 <sm> dafis: ahh, that's what I suspected but didn't detect from the help. thanks!
10:19:55 <Ololo> dmwit: _|_ is a value?
10:20:09 <byorgey> companion_cube: if you have _|_ as a value then the type system is not logically consistent.
10:20:10 <dmwit> Ololo: Different people mean different things when they say the word "value".
10:20:42 <sadger> hi i want to sort a list of Sets from biggest to smallest (reverse $ sort) isn't working, is there some way to group sets from biggest to smallest in a list?
10:21:14 <dmwit> sadger: reverse . sort
10:21:23 <byorgey> sadger: sortBy (comparing S.size) ?
10:21:28 <dmwit> sadger: Or, better, sortBy (flip compare)
10:21:29 <Ololo> dmwit: ВTW, why _|_ is a value in Haskell? :)
10:21:32 <byorgey> 'sort' by itself won't sort sets by size anyway
10:21:40 <dmwit> oh
10:21:45 <dmwit> Good point. =P
10:21:51 <sadger> dmwit: your approach doesn't work but let me try yours byorgey thanks
10:21:57 <dmwit> Ololo: Because Haskell has loops.
10:22:12 <sadger> where is comparing take from?
10:22:18 <byorgey> sadger: Data.Ord
10:22:20 <dmwit> ?hoogle comparing
10:22:20 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:22:20 <Mauke> @hoogle comparing
10:22:20 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:22:22 <sadger> thanks
10:22:53 <dmwit> lunchtime
10:23:04 <sadger> thanks I think that's done it byorgey
10:23:13 <sadger> it's defintely dinner time here
10:23:14 <sadger> :)
10:23:16 <Ololo> dmwit: _|_ is non-terminating computation. The non-terminating computation cannot have a value, because it doesn't terminate.
10:23:48 <byorgey> Ololo: hence why dmwit said 'different people mean different things by "value"' =)
10:24:27 <byorgey> Ololo: if by 'value' you mean 'well-typed expression which does not reduce any further', then _|_ is not a value.
10:24:59 <Ololo> byorgey: so if one think about programs with equational reasoning, _|_ is a value?
10:25:06 <yrlnry> Yes.
10:25:07 <byorgey> Ololo: if by 'value' you mean 'element of the semantic domain' then _|_ is a value, because it is the meaning of some programs
10:25:19 <elliott> hmph... newtype SupplyT s m a = SupplyT (StateT (SupplyT s m s) m a) makes everything go so much better than newtype SupplyT s m a = SupplyT (StateT (ProviderT m s) m a); newtype ProviderT m s = ProviderT (m (s, ProviderT m s))
10:25:34 <byorgey> elliott: hehe
10:25:41 <elliott> (but the former definitely isn't _right_, unless there's actually some generic transformations on the supply that makes sense...)
10:25:53 * byorgey is disappointed there are no more continuations
10:26:07 <Mauke> template<typename T> T foo() { while (true) ; }
10:26:07 <yrlnry> What? Did we use them all up already?
10:26:24 <companion_cube> byorgey: oh, right, i meant "not consistenly typable"
10:26:26 <byorgey> yrlnry: tell me why you want to know and then I will answer your question.
10:26:45 <Mauke> hah
10:26:59 <elliott> byorgey: me too :p
10:27:00 <Ololo> Mauke: STOP USING while(true);!
10:27:12 <Ololo> Mauke: it's for(;;);
10:27:15 <Mauke> template<typename T> T foo() { return foo<T>(); }
10:27:43 <Mauke> template<typename T> T foo() { throw "while (true) ;"; }
10:27:56 <Ololo> Mauke: when you use while(true), you rely on optimizations
10:27:58 <elliott> byorgey: the worst thing about the second one is that I have to hide SupplyT's constructor because you can use it to break things :-(
10:28:01 <Peaker> Are you talking about the undefined behavior thing from that in-academia blog?
10:28:01 <Mauke> Ololo: what
10:28:11 <elliott> whereas I can't figure out what on earth is illegal in the first place for the former one :P
10:29:39 <elliott> Ololo: ... when you use for(;;), you're relying on the compiler not to insert NOPs in all the relevant locations too ...
10:30:37 <yrlnry> When you use either one you are relying on the compiler to compile the code correctly.  geez louise.
10:30:53 <int-e> surely you should write do { } while (true) to avoid the forward jump ;-)
10:31:04 <elliott> yrlnry: when you use either one you're relying on a COMPILER!!! what if you don't have one of those??
10:31:35 <yrlnry> I have known people who seriously advocated using while (1==1) { ... } for some reason having to do with superstitious fear of the compiler and the language definition.
10:31:53 <elliott> haha
10:32:32 <int-e> oh superstitions ... while (NULL == 0) { ... }.
10:32:32 <yrlnry> I personally use while ("Cogito, ergo sum") { ... } because since that is a priori true, it is true in all possible universes, and therefore ensures maximum portability.
10:33:22 <yitz> foreach (repeat ()) {...}
10:35:01 <kmc> #define ever (;;)
10:35:02 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
10:39:49 <yrlnry> kmc: I used to #define forever for (;;) .  Your suggestion was a little too twee for me.
10:40:28 <yrlnry> The beginner often indulges in such cosmetic macroizing, to disguise his discomfort with the language.
10:40:55 <yrlnry> I believe the source for csh has #define BEGIN {   and #define END }
10:41:01 <elliott> bourne sh has a whole host of those
10:41:07 <elliott> including "IF"/"FI"
10:41:10 <elliott> it's famously awful
10:41:11 <yrlnry> Maybe that's what I am thinking of.
10:41:11 <Mauke> yeah, the bourne shell is legendary
10:41:19 <Mauke> #define unless(X) if (!(X))
10:41:41 <yrlnry> That I still do.
10:41:46 <Mauke> http://ioccc.org/1990/tbr.c
10:41:51 <ion> Does Network.URL really have no function for joining e.g. ‘http://example.net/foo’ and ‘/bar’ to get ‘http://example.net/bar’? :-(
10:42:26 <elliott> I wish there wasn't a too-many-dependencies vs. orphan instances tradeoff...
10:42:41 <yrlnry> I am unwilling to give up unless().
10:42:56 <kmc> oh dear
10:42:59 <Mauke> #define until(X) while (!(X))
10:43:14 <yrlnry> That I do not do.
10:43:17 <elliott> #define whilst while
10:43:22 <Mauke> #define do not do
10:43:32 <geheimdienst> #define do or do not, there is no try
10:43:37 <Mauke> #include <iso646.h>
10:44:13 <elliott> oh well, I'll just lie to myself that these orphan instances are ok
10:44:51 <Mauke> <_0x44> "Cogito, ergo sum" may not be a priori true across all universes...
10:45:01 <dafis> elliott: what sort of orphans are you creating?
10:45:16 <monochrom> orphan instances are ok. just makes separate compilation harder
10:45:32 * hackagebot hledger-web 0.16.4 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.16.4 (SimonMichael)
10:45:34 <elliott> dafis: A foo package (just depends on transformers, no mtl instances) + foo-mtl package containing all the (orphaned) mtl instances
10:45:40 <yrlnry> Mauke:  if 0x44 wants to submit a bug report from a universe where my program works incorrectly, I will give it due consideration.
10:45:46 <elliott> it's pretty benign but still kind of awful
10:46:06 <Mauke> <_0x44> If you consider the P-Zombie universe argument of the qualia of consciousness... there exist universes that have inhabitants that can assert "cogito, ergo sum" that do not actually think.
10:46:31 <dafis> elliott: yeah, but not easy to avoid
10:46:40 <monochrom> sorry, I don't want to hear more about 0x44
10:50:32 * hackagebot scion-browser 0.1.3 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.1.3 (AlejandroSerrano)
10:56:17 <lpsmith> quicksilver: http://blog.melding-monads.com/2011/10/24/concurrency-and-foreign-functions-in-the-glasgow-haskell-compiler/
10:56:52 <sm> hm! %GC time  88.0%  is bad, right ?
10:57:07 <dafis> sm: yes
10:57:48 * sm todos more investigation
10:57:52 <dafis> unless you have reason to believe it isn't, it's *very* bad
10:58:22 <dafis> sm: profile (-hT first)?
10:58:39 <lpsmith> Profile,  reduce allocation,  avoid data structures,  replace data with control when possible.
10:59:41 <maurer> Is there a way to define a typeclass instance for a parameterized typeclass on a type alias?
10:59:52 <sm> lpsmith: avoid data structures ?
11:00:36 <lpsmith> well, for example,  are you rewriting a list a bunch?
11:01:03 <lpsmith> can you re-express some of your list functions as a foldr and make better use of list fusion, etc
11:01:18 <lpsmith> Would it make sense to replace a list with a vector?
11:02:17 <lpsmith> Or,   you can win by avoiding a function such as    a -> Maybe b   and replacing it with something like    a -> (b -> c) -> c -> c
11:02:31 <lpsmith> (not necessarily though)
11:08:02 <monochrom> lpsmith beats me to an article on GHC threading.
11:08:23 <lpsmith> hah
11:08:27 <lpsmith> what did you think?
11:08:39 <lpsmith> pretty basic
11:08:57 <monochrom> I will have to make mine better. (under construction)
11:09:04 <lpsmith> though making all the links I discovered some outdated documentation in forkOS
11:09:53 <Cope> Hello; Is there a way to serve pre-compiled packages/libraries?  I'm finding that I need more than 2G of memory to build some of the packages, which is slow, and not always practical.
11:10:20 <Cope> ie i could build them once on a machine with plenty of memory
11:10:34 <Cope> and than cabal install the packages that I built
11:12:45 <kmc> nice article lpsmith
11:12:55 <kmc> I'm not sure about the claim that GHC tries to make Haskell threads look like OS threads
11:13:01 <kmc> at least, that's not how I think of it
11:15:12 <kmc> if I'm trying to advocate Haskell to others, I repeat the phrase "lightweight threads" as much as possible, and avoid the comparison to OS threads
11:15:33 <kmc> Go goes even further; they renamed "threads" to "goroutines" for marketing purposes
11:16:20 <monochrom> depends on what the audience wants to hear: faster to run, faster to reason
11:17:06 <monochrom> of course, smart programmers just want to hear "faster to run"; they are smart, they know it, they don't want to hear "faster to reason"
11:17:59 <kmc> yeah they don't make mistakes ;)
11:18:15 <hpaste> Cope pasted “Cabal / gitit dependency issues” at http://hpaste.org/53076
11:18:44 <Cope> ^^ all a bit new to me, but what's the recommended approach to deal with the above?
11:18:46 <monochrom> I am dumb, I want to hear "faster to reason" first, and "it gives you a 1:1 illusion" makes me happy. and then "faster to run because it is not 1:1 underneath" is just a happy bonus.
11:19:48 <kmc> haskell has this problem where Everyone Knows types suck and Everyone Knows threads suck etc.
11:19:55 <monochrom> I am in formal methods. My friend is in computational complexity etc. He asked me, "why formal methods, why prove programs correct, don't you just... go code it up?"
11:20:02 <kmc> so the languages with weird hacks to get around these things look better than the languages which just do them properly
11:20:36 <Eduard_Munteanu> monochrom: interesting. Out of curiosity, what are you working on?
11:21:25 <monochrom> His question made me understand: he is very smart (so smart he gets into computational complexity!), he doesn't need formal methods. all these formal methods and type systems and static analyses and catch-errors mechanisms are for dumb people like me.
11:22:25 <xrl> how do I return error in a attoparsec parser? I'm doing a check whether a byte is 0x00 or 0x01 and I'd like to fail on all else
11:22:46 <Eduard_Munteanu> Well, how many smart math people are comfortable writing formal proofs?
11:22:47 <dgpratt> please correct me if I'm wrong: in a class/type declaration involving multiple type variables, there is no relationship expressed or implied at the point where the type variables are declared, but relationships between type variables can be implied via type signatures
11:24:08 <Eduard_Munteanu> dgpratt: do you mean class contexts, rather than type signatures?
11:24:19 <Peaker> dgpratt: in a MultiParamTypeClass -- you can add fundeps that give relationships between the type vars
11:24:24 <Eduard_Munteanu> Also, depending on how you use those variables, their kinds might get fixed.
11:24:25 <monochrom> So if you talk to for example Google employees (especially the top ones), if you talk to opinion leaders... well, they're the extremely smart bunch, top 0.001% smart, they are going to say all your type system restrictions get into the way. And they are right, they are too smart to need checks.
11:24:28 <elliott> What's a good step up from tagsoup if I'd still like to handle bad HTML and the like, but my scraping needs are slightly more structured than tagsoup? (I'd have to maintain some unholy zipper structure to find the stuff I need in this page)
11:24:41 <dafis> Eduard_Munteanu: depends on your definition of formal
11:24:46 <Peaker> dgpratt: also type or class contexts can add relationships.. But generally that's true
11:25:14 <Eduard_Munteanu> dafis: I guess anything computer-checked, like Coq or Agda proofs.
11:25:18 <monochrom> The tragedy is that they, smart opinion leaders, think that it holds for us the bottom 99.999%, and moreover we agree.
11:25:33 <kmc> Google employees in general are not top 0.001% smart
11:25:38 <dafis> Eduard_Munteanu: that formal, I think for all practical purposes none
11:26:01 <Eduard_Munteanu> Oh, heh.
11:26:08 <kmc> i think the set of programmers who never make mistakes is very very very small
11:26:21 <kmc> so static checking has some value to almost everyone
11:26:24 <Eduard_Munteanu> S = { Linus }    :P
11:26:30 <kmc> hahahahaha
11:26:30 <dgpratt> Peaker: is there a trivial example of a type or class context specifying a relationship?
11:26:31 <kmc> no.
11:26:32 <Eduard_Munteanu> (or so he says)
11:26:36 <dafis> formal as in 'checkable by a sufficiently smart mathematician', more or less all
11:26:38 <kmc> it's then a matter of the effort / reward tradeoff
11:26:47 <monochrom> oh, not "never make mistakes", but rather "makes few mistakes and can correct them quickly"
11:27:09 <monochrom> no, formal as in computer-checkable
11:27:36 * dafis never makes mistakes in programming, it's just his stupid twin
11:27:40 <kmc> monochrom, even with those few mistakes they could theoretically be more productive with a sufficiently amazing static checker
11:27:45 <Peaker> dgpratt: class Blah a b => SomeClass a b ...     the context of Blah may imply a relationship between a and b (by the set of existing instances or via fundeps)
11:27:48 <kmc> that's my point about the tradeoff
11:27:53 <Eduard_Munteanu> dafis: yeah, but that sort of formal is what formal methods are about, more or less, AFAIK
11:27:54 <monochrom> or, in the absence of a computer, checkable by a sufficiently *dumb* mathematician
11:27:58 <elliott> hmm... it looks like my options are xmlhtml and hexpat-tagsoup
11:28:02 <elliott> does anyone have any other recommendations?
11:28:10 <Eduard_Munteanu> That, or certain subsets of "proving", like PCC.
11:28:15 <kmc> maybe Java types are more trouble than they're worth for 20% of programmers, and Haskell types (once you understand them) more trouble than they're worth for 2%...
11:28:44 <dgpratt> Peaker: ok, got it
11:28:53 <kmc> and some super lightweight super powerful static analysis (symbolic execution via SMT solvers?) more trouble than it's worth for 0.2%
11:28:53 <kmc> etc
11:29:26 <monochrom> formal as in formulas, symbolic, let the symbols do the work, don't trust meanings or intuition. so, an opposite of smart mathematicians, because smart mathematicians preciely disdain symbols and praise meaning and intution
11:29:27 <dgpratt> you think I would've figured this out a while ago, but multiple parameter type classes don't seem terribly common
11:30:04 <FUZxxl> Does anyone here knows, why GHC manages its own stack rather than using the default C-stack?
11:30:07 <mightybyte> elliott: xmlhtml isn't really designed for scraping.
11:30:21 <monochrom> it is important, because the underlying theme is that smart people's method aren't applicable for us
11:30:25 <Eduard_Munteanu> monochrom: so it isn't about computers, programs and proving after all? :/
11:30:36 <elliott> mightybyte: oh, I see, it expects compliant documents
11:30:37 * hackagebot reactive-banana 0.4.3.0 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.4.3.0 (HeinrichApfelmus)
11:30:39 * hackagebot reactive-banana-wx 0.4.3.0 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.4.3.0 (HeinrichApfelmus)
11:30:44 <elliott> mightybyte: thanks for the reminder :)
11:31:02 <mightybyte> elliott: Yeah, although compliant is a little different in its case because we're targeting a hybrid of xml and html.
11:31:20 <monochrom> well, a computer is an objective standard for what means "dumb mathematician" or "symbolic"
11:31:28 <elliott> I guess hexpat-tagsoup is pretty much my only option then?
11:31:37 <parcs> xrl: fail "this is the error message"
11:32:08 <mightybyte> elliott: I guess so.  I'm actually not opposed to having someone contribute a much more lenient parser to xmlhtml.
11:32:34 <elliott> mightybyte: I'm no expert myself I'm afraid :)
11:32:48 <xrl> parcs: so should I do a "test <- anyWord" then do an if/else on "test"?
11:33:17 <yrlnry> FUZxxl:  Since nobody is saying, I speculate it's so they can use continuation techniques that C does not support.
11:33:38 <mightybyte> elliott: But as you can see when comparing it to tagsoup, there's always the possibility that xmlhtml's DOM representation might be unsuitable if the documents are really nonconformant.
11:33:47 <Eduard_Munteanu> FUZxxl: yeah, it doesn't use a C-like stack conventions
11:33:47 <elliott> mightybyte: Right, yeah.
11:33:54 <FUZxxl> yrlnry: Hm... but what?
11:33:57 <elliott> mightybyte: I guess what I really want is Beautiful Soup: the Haskell Port. :p
11:34:02 <yrlnry> but what what?
11:34:12 <parcs> xrl: i.e. if test == "foo" then ... else fail "...." ?
11:34:13 <sm> lpsmith: thanks. Does using control instead of data amount to storing things in stack instead of heap ?
11:34:49 <FUZxxl> As far as I saw by now, there is not really anything that the usual stack can't do, but maybe I did not understand the execution model completely.
11:34:50 <mightybyte> elliott: Yep, I understand.
11:34:54 <xrl> if state_val == 0x00 then else fail "bad state"
11:34:59 <yrlnry> FUZxxl:  continuations.
11:35:01 <xrl> parcs: err, that was for you
11:35:16 <yrlnry> FUZxxl:  coroutines.
11:35:24 <FUZxxl> yrlnry: How are those implemented?
11:35:24 <lpsmith> sm: umm... I haven't thought that through.   In OCAML and Scheme,  yes.   But Haskell's stacks don't work the same
11:35:25 <kmc> GHC does not have first-class continuations
11:35:28 <kmc> FUZxxl, did you read the STG paper?
11:35:38 <FUZxxl> kmc: Umh...
11:35:38 <lpsmith> kmc: thanks :)
11:35:45 <FUZxxl> @where stg-paper
11:35:45 <lambdabot> I know nothing about stg-paper.
11:35:48 <FUZxxl> @where stg
11:35:48 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
11:35:49 <Eduard_Munteanu> FUZxxl: the C stack is tailored according to some requirements / standards regarding debugging and such, for instance.
11:36:02 <lpsmith> I do see your point about emphasizing lightweight
11:36:03 <kmc> GHC's stack isn't even a stack of function calls
11:36:06 <FUZxxl> Eduard_Munteanu: But, how about just dropping those conventions?
11:36:22 <kmc> lpsmith, your audience is likely different from what I described
11:36:30 <kmc> sounds like your post is for people already using Haskell
11:36:30 <FUZxxl> Hm... that link is paywalled.
11:36:43 <parcs> xrl: the more idiomatic approach would be 'guard (state_val == 0x00) <?> "state check"'
11:36:43 <kmc> research.microsoft.com/pubs/67083/spineless-tagless-gmachine.ps.gz
11:36:51 <Eduard_Munteanu> FUZxxl: it's also an ABI problem, when interfacing with libraries.
11:36:56 <xrl> parcs: ahhh, sweet
11:37:22 <FUZxxl> Eduard_Munteanu: Wouldn't it be possible to just restore the stack to a sane state when calling into C?
11:37:30 <Eduard_Munteanu> And a lot of historical stuff wrt how compilers work.
11:37:41 <yrlnry> What's "ABI"?
11:37:56 <Eduard_Munteanu> Application Binary Interface.
11:38:05 <yrlnry> thanks.
11:38:09 <Cale> wtf citeseer
11:38:18 <Cale> why is it asking for a login now?
11:38:33 <Eduard_Munteanu> FUZxxl: well, Haskell can call into C code.
11:38:55 <FUZxxl> Ah... I kind of saw that paper before...
11:39:19 <Eduard_Munteanu> @where stg
11:39:20 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
11:39:28 <FUZxxl> kmc: I have a question to you.
11:39:29 <Eduard_Munteanu> Oh, it's been done.
11:39:34 <kmc> yes?
11:39:49 <FUZxxl> I am writing a solution for a highschool CS competition.
11:39:57 <FUZxxl> I use Haskell to solve that stuff.
11:40:14 <FUZxxl> Where can I get a good introduction and maybe some examples about lhs2tex?
11:40:16 <Eduard_Munteanu> It's just for kmc? :P
11:40:40 <FUZxxl> hm... It seems that he already worked with lhs2tex...
11:40:41 <monochrom> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
11:40:48 <monochrom> perhaps...
11:40:55 <monochrom> @where+ stg http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
11:40:55 <lambdabot> Done.
11:40:58 <monochrom> @where stg
11:40:59 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
11:41:11 <monochrom> old url is old, I think that's it
11:41:45 <FUZxxl> uhw.... It's difficult to read that on my machine, since the paper seems to use bitmap fonts....
11:41:51 <monochrom> although not sure the significance of "version 2.5" :)
11:41:59 <monochrom> http://citeseer.ist.psu.edu/search?q=title%3A%28implementing+functional%29+AND+author%3A%28simon+peyton+jones%29&sort=cite&t=doc
11:43:05 <romildo> Does the Haskell standard libraries have a function that is the inverse of (intercalate x)? Let's it is called split. Then the value of (split ',' "abc,def,,end") would be ["abc","def","","end"].
11:43:27 <monochrom> no, but on hackage
11:43:46 <monochrom> http://hackage.haskell.org/package/split/
11:44:32 <Peaker> intercalate does not have a strict inverse, btw
11:45:01 <kmc> i did?
11:45:03 <hpaste> DanBurton pasted “A little too unsafe? Memoization with limited memory” at http://hpaste.org/53078
11:45:27 <xrl> parcs: thanks for that tip! it works as expected!
11:45:31 <kmc> FUZxxl, aren't the docs here enough? http://people.cs.uu.nl/andres/lhs2tex/
11:45:39 <FUZxxl> kmc: Well... maybe I mixed that up...
11:45:48 <xrl> parcs: guard(state_val == 0x00 || state_val == 0x01) AP.<?> "state check"
11:46:50 <parcs> xrl: nice :)
11:46:58 <DanBurton> note that my memoization library pasted above doesn't actually work :( it hangs
11:47:20 <FUZxxl> kmc: uff... yeah. I usually like to see some real-world examples.....
11:47:23 <DanBurton> any ideas why?
11:47:26 <FUZxxl> I am going to try it out.
11:49:42 <Cale> Oh, signing up for citeseer is apparently free. But... why?
11:50:13 <monochrom> I say it's because of the old url
11:50:18 <monochrom> @where stg
11:50:18 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
11:50:36 <monochrom> try that one. no login. I never signed up, and will not.
11:50:42 <Cale> My guess is that citeseer wants to track what papers we look at now so that it can sell the information to advertisers.
11:51:07 <monochrom> well it failed to track me, and I still suceeded in searching and downloading
11:51:39 <Cale> yeah, I just created an account only to have the login page it gave for the old url turn into a 404 :P
11:52:07 <monochrom> stale url is stale
11:52:14 <Cale> Their new URL scheme sucks a whole lot more though.
11:52:19 <monochrom> or rather s/stale/deprecated/
11:53:32 <monochrom> not agreeing because "peytonjones92implementing" is not sustainable
11:53:38 <Cale> sure it is :)
11:54:09 <monochrom> the best of both worlds is what amazon does
11:54:12 <Cale> Well, if you allow the year to increase
11:54:49 <monochrom> http://www.amazon.com/Java-In-21-Minutes/dp/1593272839/
11:55:02 <Cale> that's not memorable
11:55:41 <monochrom> right. but I agree to disagree. I screw memorable.
11:55:55 <Cale> It just has to map distinct papers to distinct URLs. I know Java is popular, but I'm pretty sure there are nowhere near 1593272839 books called Java in 21 Minutes.
11:56:19 <monochrom> Cale, please click on that url, you will be surprised
11:56:33 <Cale> ah, lol
11:56:42 <Cale> they're ignoring that whole part of the URL?
11:57:08 <monochrom> because that part is just for human-to-human communication
11:57:18 <FUZxxl> wow...!
11:57:44 <FUZxxl> That is a good way to rick-roll someone.
11:57:49 <Cale> honestly, at that point, I'd be happier with just the number
11:58:27 <monochrom> the holy grail of "meaningful" identifiers
11:58:49 <fenix> @pl (\x -> maybe (f x) const $ g x)
11:58:49 <lambdabot> ap (flip maybe const . f) g
11:59:46 <monochrom> we can start LYAH-rolling newbies
11:59:59 <elliott> Cale: you can just go for the number:
12:00:01 <FUZxxl> monochrom: :D
12:00:02 <elliott> http://www.amazon.com/dp/1593272839/
12:00:22 <Cale> Yeah. It's not great though.
12:01:29 <Cale> I'm not saying there shouldn't be some number attached to the things which you can look them up with, but that there ought to also be meaningful URLs for them which don't involve large numbers.
12:01:48 <paolino> @pl \f g t -> f t . g t
12:01:48 <lambdabot> liftM2 (.)
12:02:07 <ciaranm> you need a URN thingie, not a URL
12:02:15 <tristes_tigres> Hello, anyone has good understanding of xmonad? I have a question about resizing
12:02:20 <paolino> :t (.)
12:02:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:02:21 <Cale> http://xkcd.com/936/ -- it's kinda like this, only in another setting
12:02:41 <paolino> :t liftA2 (fmap)
12:02:42 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
12:04:58 <fenix> @pl (\x -> msum [f x, g x])
12:04:58 <lambdabot> msum . liftM2 (:) f (return . g)
12:05:00 <Eduard_Munteanu> tristes_tigres: there's #xmonad if you don't find help here
12:05:15 <Eduard_Munteanu> Also, you should just ask your question directly.
12:05:23 <tristes_tigres> Eduard: Thanks
12:05:49 <fenix> @pl (\x -> msum . map ($ x) [f, g])
12:05:49 <lambdabot> (msum .) . flip map [f, g] . flip id
12:06:13 <absentia> when will haskell become forth?
12:06:31 <absentia> (joke, don't crucify me)
12:06:59 <FUZxxl> absentia: Hm... I think that it is not too difficult to embed a forth-like dsl into Haskell using some Monads...
12:07:25 <FUZxxl> and posibly templates and of course a lot of generalized prepohistozygomorphisms...
12:07:38 <absentia> I'm sure.  I was just making a quick commend on the pervasive use of "." ... ya, the statements in between may not be forth, but if they're single words, it sure starts to LOOK like forth.
12:07:43 <tristes_tigres> Can xmonad resize a client window "proportionally"? I.e. with all fonts and layout within a window resizing to the same ratio.
12:08:00 <byorgey> tristes_tigres: no
12:08:10 <tristes_tigres> byorgey:thanks
12:08:13 <fenix> @pl (\x -> mplus (f x) (g x))
12:08:13 <lambdabot> liftM2 mplus f g
12:08:42 <byorgey> tristes_tigres: you'd need some sort of compositing WM to do that, I guess
12:08:43 <tristes_tigres> byorgey: is it a fundamental limitation, or it just was not implemented?
12:09:04 <fenix> @pl (\x -> mplus (f x y) (f x' y))
12:09:04 <lambdabot> flip mplus (f x' y) . flip f y
12:09:16 <byorgey> tristes_tigres: it's a fundamental limitation.  xmonad does not know anything about, nor can it have any effect on, how windows are actually rendered to the screen
12:09:27 <byorgey> only on their location and size
12:09:32 <elliott> I'm really tempted to just write my own HTML scraping library... afaict hexpat is not any more convenient to query than tagsoup (which is painful to query).
12:09:41 <absentia> dup 0 18 at-xy ." PAD ODDS=[" . ." ] " 5 spaces
12:09:44 <byorgey> then given the size, it's up to the application to decide how to fill that rectangle
12:09:51 <monochrom> you would need OpenGL to scale windows
12:10:13 <DasIch> how do I express something like a{1,6} with parsec? do i have to write a combinator for that myself?
12:10:36 <tristes_tigres> byorgey: I kind of suspected that
12:10:57 <monochrom> you can express a{6} with parsec
12:11:05 <DasIch> monochrom: i'm aware of that
12:11:28 <monochrom> then yeah you have to write one yourself
12:11:50 <byorgey> DasIch: you have to write your own combinator.  But now that you mention it, I don't know why such a combinator is not already defined in terms of Alternative
12:11:56 <byorgey> I mean, it could be.
12:12:35 <byorgey> it's just a slight generalization of 'some'/'many'
12:12:54 <Cale> countRange n m p = do replicateM n p; count (m-n) (optional p); return ()
12:12:56 <DasIch> huh, I thought I was missing something. I expected this to be a relatively common requirement
12:13:10 <Cale> ^^ something like that
12:13:23 <Cale> Parsing between 1 and 6 occurrences of something isn't too common ;)
12:13:36 <tristes_tigres> http://offog.org/ideas/compositing-tiling-wm.html
12:13:42 <tristes_tigres> that's what I would like
12:14:09 <tristes_tigres> I wonder if it can be added to xmonad
12:14:12 <elliott> Oh no, now I'm having all sorts of grand HTML scraping library plans.
12:14:58 <monochrom> implement the easiest plan first
12:15:16 <byorgey> tristes_tigres: adding compositing support to xmonad has certainly been discussed.  I don't actually know how hard it would be.
12:15:33 <DasIch> Cale: you need that for colors in css, escaped characters in strings etc.
12:15:53 <elliott> monochrom: It is easy, it's just probably not quite easy enough for me to bother :-)
12:15:57 <Cale> Do you?
12:16:00 <elliott> Although I suppose I could use practice binding C libraries.
12:16:23 <Cale> If you were parsing a colour in CSS, I suspect that you'd parse one of a handful of formats, each of which has a specific length.
12:16:30 <Cale> and you'd combine them with <|>
12:16:34 <byorgey> elliott: please don't tell me you need to do HTML scraping to implement Supply.
12:16:41 <monochrom> the compiz people know how hard. on the surface it just seems one afternoon's opengl job. then you realize that people run into tons of hardware incompatibilities, unready drivers...
12:16:49 <Cale> I'm not sure what you mean about the escaped character example...
12:17:07 <Cale> > length "\NAK\SYN"
12:17:08 <lambdabot>   2
12:17:18 <Cale> but there are only so many valid escapes
12:17:22 <elliott> byorgey: You got me!
12:17:32 <elliott> byorgey: It's going to download the latest model off the web and compile it dynamically.
12:17:42 <byorgey> hahaha
12:18:05 <Cale> you're more likely to take a list of the escapes, turn each one into a parser for that escaped character, and then combine those parsers together
12:19:05 <tristes_tigres> So, I guess, no one is likely to do compositing xmonad anytime soon
12:19:39 <DasIch> Cale: in Python or C "\1", "\12" and "\123" are all valid escape sequences of one up to three octal digits
12:20:12 <monochrom> I suppose color talks about "# followed by 1-6 hex digits". but I would parse that as "# followed by huge hex number", afterwards check the number
12:20:32 <Cale> oh, sure, but that's just backslash followed by a number between 0 and the maximum number of characters (in octal?)
12:20:47 <Cale> The number of digits is irrelevant, isn't it?
12:21:13 <DasIch> Cale: how so?
12:21:29 <DasIch> Cale: "\1111" would be valid to
12:21:39 <elliott> monochrom: Cale: that's not even valid
12:21:41 <Cale> In that the upper bound on characters will determine where to stop :)
12:21:41 <elliott> it's three or six digits
12:21:43 <elliott> no exceptions
12:21:53 <Cale> Oh, okay
12:22:02 <Cale> (I'm unfamiliar with that system :)
12:22:03 <fenix> @pl (\ (x, y) -> (f x, f y))
12:22:03 <lambdabot> f *** f
12:22:12 <Cale> > maxBound :: Char
12:22:13 <lambdabot>   '\1114111'
12:22:50 <Cale> Oh, elliott is talking about colours
12:23:00 <Cale> yeah, there are only a couple of valid colour formats
12:23:11 <elliott> oh i think you can also have like sixteen chars
12:23:13 <elliott> but who uses that :P
12:23:59 <Cale> and I would just parse each of them separately, returning a colour datastructure, rather than trying to chop out a string of digits of some arbitrary length and then figure out what to do with it after the fact
12:24:12 <monochrom> C and Python parsers are uncommon. I mean sure common in deployment. not common in "I want to write yet another one"
12:24:15 <aditya`> I'd like to get some run-time hot code swapping going on my Haskell application. At some point I read about "plugins" but heard that it only worked on Windows. Is there anything currently in this space?
12:24:46 <Cale> aditya`: plugins worked on windows? :) (Well, it probably might have ;)
12:25:10 <Cale> aditya`: But yeah, plugins is probably aging by now. Try hint.
12:25:21 <Cale> http://hackage.haskell.org/package/hint
12:26:10 <Cale> I'm really only familiar with how things work on Linux. Plugins certainly worked here. :)
12:26:22 <monochrom> haskell explicitly defines "numeric escape characters in strings consist of all consecutive digits and may be of arbitrary length"
12:26:25 <aditya`> Cale: Thanks! I hadn't heard of Hint!
12:26:38 <Cale> > '\759810758934075930'
12:26:39 <lambdabot>   <no location info>:
12:26:39 <lambdabot>      lexical error in string/character literal at chara...
12:27:02 <Cale> right :)
12:27:05 <monochrom> > '\00000000000000000000000000000041'
12:27:06 <lambdabot>   ')'
12:27:11 <monochrom> works
12:27:23 <aditya`> Cale: Crap, my brain page faulted. I mean only worked on Linux.
12:27:27 <Cale> Haskell, y u so sensible?
12:27:57 <monochrom> of course 759810758934075930 is too big
12:28:30 <Cale> monochrom: Right, but at least it didn't parse it as '\759810' followed by a string of digits :)
12:29:09 <monochrom> that is the point and the difference between Haskell escapes and C escapes.
12:31:25 <Cale> > length "\SOH"
12:31:26 <lambdabot>   1
12:31:28 <yitz> > '\x00000000000000000000000000000041'
12:31:28 <Cale> > length "\SO"
12:31:28 <lambdabot>   'A'
12:31:29 <lambdabot>   1
12:31:35 <Cale> > length "\SO\&H"
12:31:37 <lambdabot>   2
12:31:49 <Cale> > drop 1 "\SO\&H"
12:31:50 <lambdabot>   "H"
12:32:04 <Cale> ^^ there's some attention to detail ;)
12:32:31 <monochrom> I have no preference in either way, actually. technical constraint is enough to decide. C wants bytes, an escape needs only 3 octal digits. Haskell wants Unicode, which keeps lengthening the number of digits required, no safe bound.
12:33:14 <Cale> > length "\&\&\&\&\&\&\&\&"
12:33:15 <lambdabot>   0
12:34:02 <monochrom> the Haskell committee was pretty smart
12:34:12 <Cale> > length "\&\&\&\&\                        \\&\&\&\&"
12:34:13 <lambdabot>   0
12:34:41 <tkahn> > show "\&"
12:34:41 <lambdabot>   "\"\""
12:34:53 <monochrom> Cale! Are you playing with "1001 ways to express the empty string"?!
12:34:53 <Cale> > "\&"
12:34:56 <lambdabot>   ""
12:34:57 <tkahn> ^
12:35:16 <Cale> Pretty much :)
12:35:29 <monochrom> > "\   \"
12:35:31 <lambdabot>   ""
12:35:39 <FUZxxl> Why is ther "\&" anyway?
12:35:45 <FUZxxl> "\"\"\"
12:35:46 <yitz> monochrom: in python, "\u00041" is equal to Haskell's "\x0004\&1". they want unicode too, but the escape sequence requires exactly four hex digits.
12:35:49 <FUZxxl> > "\"\"\"
12:35:51 <lambdabot>   <no location info>:
12:35:52 <lambdabot>      lexical error in string/character literal at end o...
12:35:57 <FUZxxl> > "\"\""
12:35:57 <Cale> FUZxxl: In part because of that ambiguity I showed with \SOH and \SO
12:36:00 <lambdabot>   "\"\""
12:36:07 <FUZxxl> ah,okay.
12:36:17 <monochrom> the Python committee was not very smart
12:36:18 * int-e wonders what the reason for \& is.
12:36:24 <yitz> FUZxxl: it does nothing, but it can be used to end other escape sequences.
12:36:30 <Cale> But also whenever you have a numeric escaped character followed by numbers
12:36:31 <FUZxxl> okay.
12:36:43 <Cale> you'll need a way to say where that escape stops and the next begins
12:36:48 <Cale> So \& can separate
12:36:59 <Taejo> monochrom: there is \Uxxxxxxxx for astral characters
12:37:01 <Cale> > "\123\&45"
12:37:02 <lambdabot>   "{45"
12:37:10 <Cale> > "\12345"
12:37:12 <lambdabot>   "\12345"
12:37:25 <Cale> > map length ["\123\&45", "\12345"]
12:37:26 <lambdabot>   [3,1]
12:37:26 <int-e> yeah, reading the report. and I guess somebody had just explained it but I missed the point.
12:38:14 <int-e> s/somebody/you/
12:38:47 <Cale> The syntax of string literals was a little detail which I found quite impressive when I was first learning Haskell :)
12:39:19 <yitz> Taejo: i guess it won't happen for a while, but if unicode ever goes beyond 4 bytes, python will need something else.
12:39:45 <yitz> Cale: did you like the part about continued strings? i'm not so sure about that one.
12:39:47 <int-e> Funny, I was aware of \<whitespace>\, but not \&.
12:39:49 <monochrom> I anticipate the Python committee to be forced to add a \UUxxxxxxxxxx when Unicode 10.0 comes out and requires 10 digits
12:39:59 <Mauke> I think perl did it better
12:40:11 <Cale> yitz: string gaps?
12:40:15 <yitz> yes
12:40:21 <Cale> I didn't mind it
12:40:30 <Cale> It's a nice feature to have
12:40:39 <Mauke> perl has '\x' followed by one or more hex digits or '\x{' digits '}' if you need to mark the end
12:40:55 <monochrom> yes, that works nicely too
12:41:07 <Cale> It's a nice feature of Haskell that almost any long line can be broken up and continued on the next line
12:41:18 <Cale> and I guess string gaps fit nicely into that scheme of things
12:41:33 <monochrom> that one is learned from shell script's ${un}bound
12:41:37 <ClaudiusMaximus> > show "\SO\&H"
12:41:38 <lambdabot>   "\"\\SO\\&H\""
12:41:47 <brisingr> Cale: which begs the question, what is appropriate style? couldn't find a comprehensive guide
12:41:49 <Eduard_Munteanu> Well, you can break up lines like that in C as well.,
12:41:49 <yitz> Cale: unless you define some stupidly long variable name
12:42:00 <Mauke> > "\1H"
12:42:01 <lambdabot>   "\SOHH"
12:42:09 <Mauke> > "\14H"
12:42:09 <Taejo> ClaudiusMaximus: lambdabot already applies show to the result
12:42:10 <lambdabot>   "\SO\&H"
12:42:16 <Eduard_Munteanu> Even in preprocessor directives.
12:42:25 <ClaudiusMaximus> :)
12:42:33 <Cale> brisingr: Mostly to ensure that things which are at the same level line up with each other, and things which are children of other things begin in a deeper column
12:42:42 <Cale> brisingr: also, don't use tab characters ;)
12:42:55 <yrlnry> I have just been informed that John McCarthy died last night.
12:43:01 <Cale> brisingr: If you follow that rule, you'll be able to infer all the common idiomatic layouts for Haskell code.
12:43:03 <brisingr> Cale: if I'm gonna use tab chars I'll make sure to randomly mix them with spaces
12:43:08 <Cale> heh
12:43:18 <yrlnry> He was 84.
12:43:57 <DanBurton> weird question. Say I have memo :: (a -> b) -> a -> b (a memoizer), and pseudo-recursive function f :: (a -> b) -> a -> b (fix f produces the recursive function). How do I write recMemo :: ((a -> b) -> a -> b) -> (a ->b)? recMemo f = memo tieTheKnotHere?
12:44:11 <brisingr> Cale: also, do you recommend the "when splitting lists begin lines with a comma" thing?
12:44:36 <monochrom> wikipedia agrees that McCarthy died
12:44:40 <Cale> brisingr: sometimes.
12:44:41 <yrlnry> {{cn}}
12:44:53 <dolio> @type let memo :: (a -> b) -> a -> b ; memo = undefined in fix . memo
12:44:54 <lambdabot> forall a. (a -> a) -> a
12:45:01 <Cale> brisingr: I do that if I anticipate adding and removing lines a bunch, or wanting to comment some of them out
12:45:25 <Cale> brisingr: But otherwise, I'll end lines with a comma
12:45:28 <Cale> or ]
12:45:35 <brisingr> I suppose the sure-fire way to learn good style is to wait for people to yell at you
12:45:37 <DanBurton> @hoogle fix
12:45:38 <lambdabot> Data.Function fix :: (a -> a) -> a
12:45:38 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
12:45:38 <lambdabot> module Control.Monad.Fix
12:45:49 <DanBurton> I always forget where fix is :) cool dolio I'll give it a try
12:45:58 <Cale> brisingr: People are pretty style-agnostic in Haskell as long as you follow that golden rule.
12:46:07 <Cale> (and you don't use tabs)
12:46:07 <dolio> I think that's the right answer. But you'll have to verify.
12:46:09 <DanBurton> although wait, that type is weird
12:46:34 <Cale> I can't even tell you how much I indent by usually, because I don't do it consistently.
12:46:35 <dmwit> Yeah. He meant this:
12:46:45 <dolio> It's possible it should be fix .: memo
12:46:46 <dmwit> :t let memo :: (a -> b) -> a -> b; memo = undefined in memo . fix
12:46:46 <Cale> I just line things up and don't worry about how much the shift width is.
12:46:47 <lambdabot> forall a b. ((a -> b) -> a -> b) -> a -> b
12:46:50 <brisingr> Cale: sorry to be bugging you so much, but
12:46:59 <dmwit> dolio: You just got them backwards, I think. =)
12:47:06 <Cale> My tab key is set to insert 2 spaces, which makes it like a faster spacebar
12:47:07 <dolio> Nah, I definitely didn't mean that.
12:47:08 <brisingr> what's the best way to begin learning from actual code
12:47:18 <brisingr> like start maintaining small projects or something
12:47:22 <brisingr> or submit patches
12:47:22 <DanBurton> :t let memo :: (a -> b) -> a -> b; memo = undefined in fix .: memo
12:47:23 <lambdabot> forall a a1. (a1 -> a -> a) -> a1 -> a
12:47:42 <Cale> brisingr: Um, hmm. Well, there's a lot of code on hackage which you can look through for stuff which interests you, I suppose.
12:47:42 <dolio> dmwit: At least, I thought the point was to memoize such that recursive calls refer to memoized results.
12:47:56 <DanBurton> dolio: yes that's the point
12:47:58 <dmwit> DanBurton: I'm not sure I understand the question. If "fix f" is the function you want to memoize, then wouldn't "recMemo f = memo (fix f)" be just what you want?
12:48:05 <dmwit> ...ah
12:48:10 <dmwit> Yes, I see.
12:48:16 <Cale> I didn't learn from real code apart from my own. The other-people's-code I learned from was all toy examples.
12:48:24 <DanBurton> so then memo . fix has the right type but doesn't work as desired
12:48:32 <Cale> at least for the first 6 years or so :)
12:48:53 <dmwit> :t let memo :: (a -> b) -> (a -> b); memo = undefined in memo . fix . memo
12:48:54 <lambdabot> forall a b. ((a -> b) -> a -> b) -> a -> b
12:48:55 <brisingr> It's just that.. I'm kinda freaked out
12:49:03 <dolio> fix . memo is wrong, though, I guess.
12:49:05 <dmwit> there
12:49:13 <brisingr> if I spend enough hours any intermediate class assignment can be solved in under 5 lines
12:49:14 <Cale> But yeah, there's lots of real code you can look at and dig into out there :)
12:49:24 <Cale> brisingr: heh, yeah
12:49:28 <DanBurton> dmwit: o_O wait a minute...whaaaaat
12:49:44 <DanBurton> dmwit: what exactly does that even mean?
12:49:45 <tgeeky> Cale: that's one reason why I like Functional Pearls, a lot.
12:49:50 <dolio> \f -> fix (\rec -> memo (f rec)) = \f -> fix (memo . f) = fix . (memo .)
12:49:58 <Cale> If you're willing to dump arbitrary amounts of time into thinking about what your program does, you can compress it a lot in Haskell.
12:50:13 <dolio> @type let memo :: (a -> b) -> a -> b ; memo = undefined in fix . (memo .)
12:50:14 <lambdabot> forall a b. ((a -> b) -> a -> b) -> a -> b
12:50:16 <dolio> There we go.
12:50:38 <tgeeky> Cale: to me, a very good definition of a functional pearl is 'a programming lesson which will go underappreciated if gleaned from a published API'
12:50:39 <Cale> > nubBy(((>1).).gcd)[2..]
12:50:43 <lambdabot>   mueval-core: Time limit exceeded
12:50:53 <Cale> oh right, nubBy is still broken
12:51:15 <brisingr> Cale: I remember going from a huge cartesian product function, to foldr (liftM2 (:)) [[]], to sequence
12:51:19 <Ololo> Cale: sort + unique?
12:52:14 <Cale> nubBy takes a function f and a list, and picks elements x from the list one by one, eliminating any following elements y which satisfy f x y
12:52:16 <dolio> @free fix
12:52:16 <lambdabot> f . g = h . f => f (fix g) = fix h
12:52:19 <Cale> normally
12:52:24 <Cale> but right now it's f y x
12:52:29 <Cale> which is infuriating
12:53:01 <Cale> > nubBy (flip (((>1).).gcd)) [2..]
12:53:04 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:53:12 <FUZxxl> ?!?
12:53:14 <incluye> hm
12:53:28 <Ololo> WUT
12:53:39 <brisingr> Cale: when did the nubBy change?
12:53:44 <Cale> (the Report only defines it on equivalence relations, which means that the predicate is supposed to be symmetric, but it's really useful on asymmetric relations too...)
12:53:51 <aristid> :t nubBy
12:53:52 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
12:53:55 <Cale> brisingr: It's been this way in GHC for a few versions now
12:54:01 <Cale> I don't recall exactly
12:54:02 <tgeeky>  > nubBy (flip (((>1).).gcd)) ([1,3,12] ++ [1..])
12:54:08 <aristid> how was it before?
12:54:15 <Cale> It was what I said before
12:54:28 <Cale> The function parameter wasn't flipped
12:54:31 <incluye> so nub = nubBy (==)
12:54:33 <FUZxxl> okay....
12:54:40 <erus`> i got called a faggot on 4chan :'(
12:54:41 <Cale> and it behaved according to the Report's example implementation
12:54:48 <Cale> erus`: boo hoo
12:55:11 <Cale> erus`: Everyone is a faggot on 4chan, isn't that the custom there?
12:55:43 <erus`> (s)he meant it in a horrid way
12:55:58 * ddarius also finds cigarettes horrid.
12:56:26 <Taejo> ddarius: are you mixing up your slang?
12:56:36 * Taejo finds meatballs horrid
12:56:53 <Ololo> > nubBy (flip (((>1).).gcd)) [2..]
12:56:55 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:56:57 <DanBurton> whoaaaaa it works. hpaste coming soon
12:57:09 <Ololo> damnit
12:57:24 <FUZxxl> Is there a shorter way to generate prime numbers?
12:57:29 * ddarius doesn't know why the "keys to adoption" snake oil sales men are out in force today.
12:57:29 <brisingr> > nubBy (\x y -> gcd x y > 1) [2..]
12:57:30 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:57:31 <aristid> oO
12:57:38 <brisingr> it's way more readable that way
12:57:59 <ClaudiusMaximus> @oeis 2,3,5,7
12:58:04 <FUZxxl> > map (1/) $nubBy (\x y -> gcd x y > 1) [2..]
12:58:06 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:58:06 <lambdabot>    `GHC.Real.Fractional t'
12:58:06 <lambdabot> ...
12:58:07 <lambdabot>  The prime numbers.
12:58:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:58:15 <FUZxxl> > map (1::Double/) $nubBy (\x y -> gcd x y > 1) [2..]
12:58:15 <lambdabot>   <no location info>: parse error on input `)'
12:58:26 <FUZxxl> > map ((1::Double)/) $nubBy (\x y -> gcd x y > 1) [2..]
12:58:27 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
12:58:27 <lambdabot>    arising from a use ...
12:58:37 <ddarius> > nubBy((>1).).gcd)[2..]
12:58:38 <lambdabot>   <no location info>: parse error on input `)'
12:58:44 <FUZxxl> > map recip $nubBy (\x y -> gcd x y > 1) [2..]
12:58:44 <ddarius> > nubBy(((>1).).gcd)[2..]
12:58:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:58:46 <lambdabot>    `GHC.Real.Integral a'
12:58:46 <lambdabot>   ...
12:58:47 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:58:58 <FUZxxl> > map recip $nubBy (\x y -> gcd x y > 1) [2..] :: [Rational]
12:58:59 <lambdabot>   No instance for (GHC.Real.Integral GHC.Real.Rational)
12:58:59 <lambdabot>    arising from a use...
12:59:11 <Taejo> :t gcd
12:59:12 <lambdabot> forall a. (Integral a) => a -> a -> a
12:59:17 <FUZxxl> > map (recip . fromIntegral) $nubBy (\x y -> gcd x y > 1) [2..] :: [Rational]
12:59:19 <lambdabot>   [1 % 2,1 % 3,1 % 5,1 % 7,1 % 11,1 % 13,1 % 17,1 % 19,1 % 23,1 % 29,1 % 31,1...
12:59:26 <FUZxxl> > sum $ map (recip . fromIntegral) $nubBy (\x y -> gcd x y > 1) [2..] :: [Rational]
12:59:27 <lambdabot>   No instance for (GHC.Real.Fractional [GHC.Real.Rational])
12:59:28 <lambdabot>    arising from a...
12:59:41 <brisingr> :t sum
12:59:42 <lambdabot> forall a. (Num a) => [a] -> a
12:59:44 <FUZxxl> > sum . take 100 $ map (recip . fromIntegral) $nubBy (\x y -> gcd x y > 1) [2..]
12:59:47 <lambdabot>   2.10634212147262
12:59:54 <FUZxxl> > sum . take 10 $ map (recip . fromIntegral) $nubBy (\x y -> gcd x y > 1) [2..]
12:59:56 <lambdabot>   1.5334387718720317
12:59:59 <FUZxxl> > sum . take 1000 $ map (recip . fromIntegral) $nubBy (\x y -> gcd x y > 1) [2..]
13:00:03 <lambdabot>   mueval-core: Time limit exceeded
13:00:38 <brisingr> Prelude Data.Ratio Data.List> sum . take 1000 $ map (recip . fromIntegral) $nubBy (\x y -> gcd x y > 1) [2..]
13:00:42 <brisingr> 2.457411276711362
13:02:36 <FUZxxl> Data.Numbers.Primes> primes
13:02:57 <brisingr> where's the fun in that?
13:08:14 <hpaste> DanBurton pasted “Crazy memoization stuff” at http://hpaste.org/53088
13:12:09 <ddarius> DanBurton: Why not have MutableCache just be a record that is passed in?
13:15:02 <DanBurton> ddarius: not sure what you are suggesting.
13:15:06 <DanBurton> ddarius: passed in to what?
13:19:37 <DanBurton> Anyways, I wanted to be able to make arbitrarily complicated instances of MutableCache
13:20:04 <DanBurton> and as long as they support the interface, they can then be plugged into the memoizer functions
13:23:40 <looopy> would you all say that haskell is based on 'abstraction'?
13:24:29 <byorgey> I would say that all programming languages are based on abstraction.
13:25:20 <looopy> ...very true
13:25:21 <DasIch> looopy: that's kind of the point, for any programming language
13:25:25 <byorgey> Haskell supports more forms of abstraction than many other languages, but I wouldn't say that is a defining characteristic of Haskell
13:25:29 <DasIch> apart from brainfuck, maybe
13:25:34 <Ololo> @pl fix (1+)
13:25:35 <lambdabot> fix (1 +)
13:25:59 <looopy> i'm not a haskell user but i'm arguing with a friend that believes haskell is pointless and people use it simply to feel superior
13:26:21 <Ololo> @pl fix (\f -> (2 : (filter (\n -> all (\d -> n `mod` d /= 0) (takeWhile (\m -> m * m <= n) f)) [3..])))
13:26:21 <lambdabot> fix ((2 :) . flip filter [3..] . ap (all . flip flip 0 . ((/=) .) . mod) . flip (takeWhile . flip ((<=) . join (*))))
13:26:26 <tromp> do you like arguing with trolls?
13:26:45 <Ololo> > fix ((2:) . flip filter [3..] . ap (all . flip flip 0 . ((/=) .) . mod) . flip (takeWhile . flip ((<=) . join (*))))
13:26:47 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:26:57 <Ololo> Hooray :)
13:26:59 * DanBurton laughs at the pun "haskell is pointless"
13:27:10 <incluye> And they say it's hard to generate an infinite list of primes
13:27:16 <incluye> some people!
13:27:20 <Saizan> i'd wonder about typical assembly languages, but it's easy enough to build some mechanism for abstraction and think as if that was part of the language :)
13:27:34 <conal> looopy: i'd let him believe it.
13:27:46 <looopy> conal: but that's no fun =)
13:27:51 <tromp> it only takes a 21 byte program to generate all primes
13:27:56 <conal> looopy: could be! :)
13:28:02 <incluye> every single prime
13:28:26 <conal> looopy: or you might invite him to put some substance behind his conjecture. and don't accept proof by lack of imagination.
13:28:49 <arcatan> i, for one, use Haskell purely to feel superior
13:29:02 <arcatan> unfortunately Haskell is getting a bit too popular, so I'm now setting my sights on Agda
13:29:21 <incluye> okay so running that code up thar in lambdabot, I get this error
13:29:25 <looopy> conal: those are fighting words.  we started when i made a php joke.  he uses php and vb.net only. which is fine...he's very productive
13:29:35 <incluye> No instance for (Monad ((->) b0))
13:29:38 <incluye>       arising from a use of `join'
13:29:51 <looopy> arcatan: LOL! we both agreed on that...once haskell became popular people would change
13:29:58 <dafis> incluye: import Control.Monad.Instances
13:30:02 <incluye> okay
13:30:24 <incluye> and how do you set the prompt in ghci again
13:30:29 <incluye> it's getting a little long
13:30:38 <dafis>  :set prompt, iirc
13:30:55 <incluye> oh, duh
13:31:03 <applicative> :set prompt --->
13:31:59 <applicative> the better question is, how do you set the prompt so that it includes a space at the end?
13:32:11 <dafis>  :set prompt "ghci> "
13:32:36 <applicative> I guess that's obvious... thanks
13:32:45 <dafis> welcome
13:33:16 <Ololo> > flip 0
13:33:17 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> f b)
13:33:17 <lambdabot>    arising from a use of...
13:33:29 <Ololo> ^_^
13:34:01 <applicative> @type flip 0
13:34:02 <lambdabot> forall (f :: * -> *) a b. (Num (f (a -> b)), Functor f) => a -> f b
13:35:09 <dafis> > flip 0 1 2
13:35:10 <lambdabot>   0
13:36:05 <Ololo> @type 0
13:36:06 <lambdabot> forall t. (Num t) => t
13:36:24 <Ololo> @type flip flip 0
13:36:25 <lambdabot> forall (f :: * -> *) a b. (Functor f, Num a) => f (a -> b) -> f b
13:37:21 <Ololo> @type foldl1 (.) (replicate 5 flip) 0
13:37:22 <lambdabot> forall a b. (Num b) => a -> a -> b
13:38:00 <Ololo> wtf is this s**t
13:38:44 <applicative> > flip id 3 even
13:38:44 <lambdabot>   False
13:40:00 <dafis> @type Prelude.flip Prelude.flip 0
13:40:01 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
13:49:01 <applicative> > let some_combinators = flip id zip ap tail in some_combinators [1..10]
13:49:05 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
13:59:41 <DanBurton> for those of you following our memoization adventures earlier, you might be interested in my brief summary I posted on reddit: http://www.reddit.com/r/haskell/comments/lnk1b/magical_recursive_memoization/
14:05:21 * applicative affirms that Data.MemoUgly is well named
14:08:32 <Louis11> I'm trying to get this parser for comma separated items to work. I've got it working on two items, but generalizing it to n items is eluding me. http://hpaste.org/53092
14:10:03 <DanBurton> Louis11: what parser library are you using? Parsec?
14:10:43 <Louis11> DanBurton: I believe it's based off parsec, however it's a custom parser for a project I'm working on (we had to implement the rest of it)
14:12:08 <DanBurton> I believe in Parsec what you are looking for is "sepBy"
14:12:25 <DanBurton> "sepBy p sep parses zero or more occurrences of p, separated by sep. Returns a list of values returned by p."
14:12:29 <Botje> Louis11: you want to repeat the bit after the first p >>= for as long as it matches.
14:12:39 <Botje> or that.
14:13:03 <Louis11> Botie: How does one do that? I'm not sure how to formulate a "while" condition in this instance (coming from a C background, obviously)
14:13:17 <Louis11> do I recursively call commaSep1?
14:13:29 <DanBurton> yeah
14:13:41 <DanBurton> recursion is Haskell's analogue to "while"
14:13:55 <Louis11> alright, i'll give that a shot then. Will probably be back when I screw up the syntax :) Thanks
14:14:03 <shachaf> Recursion is more like Haskell's analogue to goto, or something.
14:14:22 <shachaf> goto with a stack.
14:14:28 <Botje> p >>= rep where rep = (aToken TokComma >> p >>= \p' -> rep >>= \rest -> return (p' : rest) ) <|> return []
14:14:32 <shachaf> Really, recursion is Haskell's analogue to recursion.
14:14:42 <Botje> uh. except that doesn't /quite work.
14:14:49 <malc_> recursion is recursion
14:14:51 <malc_> that does work
14:15:05 <DanBurton> :t while
14:15:06 <lambdabot> Not in scope: `while'
14:15:09 <Botje> p >>= \p' -> rep >>= \rep' -> return (p' : rep') where rep = ...
14:15:34 <Botje> liftM2 (:) p rep -- much nicer :]
14:16:13 <DanBurton> :t until
14:16:14 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
14:16:21 <DanBurton> that's what I was thinking of
14:16:34 <DanBurton> > until (>10) (+1) 0
14:16:34 <lambdabot>   11
14:16:55 <DanBurton> not sure how directly applicable it is to your parser though
14:17:10 <applicative> Louis1 do you have 'many' in your parser library?
14:17:32 <Louis11> applicative: yes, many is there
14:18:17 <Louis11> though i'm not sure how to use many to be honest
14:18:54 <applicative> the parsec definitionis something like p >>= \x -> many (char ',' >> p ) >>= \xs -> return (x:xs)
14:19:41 <applicative> (somehow parsec always looks better with do notation)
14:20:09 <Louis11> yea, i tried something similar earlier. I thought the use of many might be somewhat intuitive. I'll give that a try as well
14:22:02 <Louis11> hah, many worked :) My parenthesis were off the first time
14:22:06 <Louis11> thanks guys
14:25:14 <kmc> dolio, what are the prerequisites for understanding your talk about homotopy type theory, and can I learn them in an hour?
14:31:29 <dolio> kmc: You know some Agda, right?
14:31:37 <dolio> Pi, sigma, inductive types, identity types.
14:32:07 <kmc> yeah
14:32:15 <dolio> I think you're good, then.
14:32:53 <shachaf> I know very little Agda. Should I quickly learn about those things?
14:32:59 <kmc> Π and Σ are dependent function spaces and dependent sums, right?
14:33:08 * kmc forgot which is which, but suspects Σ might be "sum"
14:33:15 <kmc> or is it functions and products
14:33:19 <dolio> I'm going to go over that stuff some at the start.
14:33:22 <copumpkin> yeah, pi for product, sigma for sum
14:33:27 <copumpkin> worst nomenclature ever
14:33:42 <kmc> and functions are products?
14:33:46 <copumpkin> yeah
14:33:51 <byorgey> it makes sense from the right point of view.
14:33:53 <copumpkin> infinite products
14:33:53 <copumpkin> yeah
14:33:58 <copumpkin> or potentially infinite, anyway
14:33:59 <kmc> mm right
14:34:02 <byorgey> I agree it's confusing though.
14:34:15 <copumpkin> I generally call them dependent functions and dependent pairs
14:34:15 <dolio> I'm not going to try to get too in-depth about any of the homotopy or directed stuff. Mainly hit the highlights about why anyone would care about them.
14:34:41 <kmc> shachaf, copumpkin did an intro to Agda talk a while back
14:34:55 <copumpkin> ugh
14:35:17 <luite> what's the first company that's going to do an iPhone game in Agda? ;)
14:35:19 <shachaf> I'd feel silly watching a video of a bostonhaskell talk as a prerequisite to attending a bostonhaskell talk.
14:37:10 <Gracenotes> shachaf: where are you at the moment?
14:37:30 <shachaf> Gracenotes: Right next to where bostonhaskell will be.
14:40:47 <Gracenotes> !
14:41:17 <Louis11> Alright, trying to parse: a + b. My code currently is as follows: http://hpaste.org/53095 However, it doesn't seem to work (complains about the presence of the '+'; looking for a } instead). Any glaring errors in my attempt?
14:41:30 <kmc> shachaf, that seems the opposite of silly
14:41:37 <kmc> shachaf, it's, like, recursion, man
14:42:33 <u_quark> tromp: could I have that 21 byte program to generate all primes?
14:45:45 * hackagebot dclabel 0.0.2 - The Disjunction Category Label Format  http://hackage.haskell.org/package/dclabel-0.0.2 (DeianStefan)
14:48:54 <tromp> it's on my webpage http://homepages.cwi.nl/~tromp/cl/cl.html
14:50:47 * hackagebot lio 0.0.2 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.0.2 (DeianStefan)
14:54:25 <u_quark> tromp: thanks, cool!
15:01:23 <Peaker> where does "hoogle data" put the result?
15:03:09 <DanBurton> Not sure, but you can apparently use --datadir=DIR to put it wherever you want
15:11:11 <blackdog> McCarthy's dead?
15:11:34 <monochrom> seems to be, but no more source
15:11:45 <blackdog> http://techcrunch.com/2011/10/24/creator-of-lisp-john-mccarthy-dead-at-84/
15:11:58 <blackdog> nothing more solid though
15:12:01 <Gracenotes> jeez
15:12:19 <Gracenotes> :(
15:12:41 <BrianHV> on hacker news Paul Graham claims to have confirmed it with Peter Norvig.
15:18:15 <gtirloni> is there a compiler flag to catch 'Non-exhaustive patterns in function' errors before runtime?
15:18:31 <hpc> yes
15:18:37 <sm>  -Wall I expect
15:18:52 <hpc> it won't be able to catch guards with perfect accuracy
15:19:09 <hpc> i expect it will err on the side of "cover your bases, and use 'otherwise' for the last case" or something
15:20:47 <gtirloni> ah Wall, ok thanks!
15:23:27 <gtirloni> another quick question.. i can achieve the same results with:
15:23:32 <gtirloni> main = putStr (show (fac 2))
15:23:33 <gtirloni> or
15:23:39 <gtirloni> main = putStr . show . fac $ 2
15:23:43 <gtirloni> is there a preference?
15:23:55 <hpc> main = print . fac $ 2 -- :P
15:24:10 <aavogt> @src print
15:24:10 <lambdabot> print x = putStrLn (show x)
15:24:48 <gtirloni> didn't know about print.. but anyway, is it better to use . and $ to do function composition/application or the () ?
15:25:00 <hpc> imagine the parens are like bananas
15:25:02 <gtirloni> i think i'm looking for a style guide or something
15:25:06 <hpc> leave them in the code for too long and they go bad
15:25:11 <gtirloni> lol
15:30:41 <shapr> Can we kickban JamesTaggart?
15:30:53 <hpc> already notified -ops
15:30:56 <DanBurton> someone should write up the "Zen of Haskell" akin to the zen of python
15:31:21 <shapr> @ops
15:31:21 <lambdabot> Maybe you meant: docs oeis pl
15:31:24 <shapr> @where ops
15:31:25 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:31:32 <Gracenotes> there is haskelly-zen stuff
15:31:36 <Gracenotes> on the wiki
15:31:44 <DanBurton> @wiki zen
15:31:45 <lambdabot> http://www.haskell.org/haskellwiki/zen
15:31:45 <Gracenotes> somewhere
15:32:07 <Cale> shapr: um, you're an op, you can do it :)
15:32:16 --- mode: ChanServ set +o shapr
15:32:19 --- kick: JamesTaggart was kicked by shapr (Kicked by shapr)
15:32:24 <hpc> you're the first op even :P
15:32:29 <shapr> Cale: I can't remember how to ban people
15:32:35 <Cale> hehe
15:32:36 <hpc> /mode +b nick
15:32:42 <hpc> iirc
15:32:44 <Gracenotes> with great vengeance
15:32:46 <Cale> Yeah, I always forget the parameters to /mode
15:32:49 --- mode: shapr set +b JamesTaggart!*@*
15:32:53 --- kick: JamesTaggart was kicked by shapr (Kicked by shapr)
15:32:55 <Cale> and how to construct hostmasks
15:33:16 <shapr> Yah, I do that so rarely the past few years.
15:33:45 <Cale> You'd think that in the 16 years I've been on IRC, I'd have learned it pretty well by now :P
15:33:50 --- mode: ChanServ set +o mauke
15:33:50 --- mode: mauke set +b $a:JamesTaggart
15:34:07 --- mode: mauke set -b JamesTaggart!*@*
15:34:10 --- mode: shapr set +b *!*@*.sex0r.com
15:34:57 --- mode: mauke set -o mauke
15:35:02 --- mode: shapr set -o shapr
15:35:22 <mauke> shapr: so script it :-)
15:35:43 <shapr> Yah, that would solve it permanently.
15:36:12 <Veinor> why'd taggard get kickbanned?
15:36:19 <hpc> trolling in PM
15:36:39 <gtirloni> i for one reported him to a ircop..
15:36:56 <gtirloni> if that's the name we still use these days
15:37:02 <mauke> "trolling in PM" is close to meaningless
15:37:03 <gtirloni> or 'staff'
15:37:10 <mauke> what actually happened?
15:37:25 <gtirloni> talking nonsense on PM (sex stuff)
15:38:02 <monochrom> /msg mauke hi, would you like a threesome in haskell? you, me, and lambdabot
15:38:27 <hpc> hey baby, your effective topos has a well-defined bottom
15:38:29 <luite> you realize that lambdabot is nixon now, and not vixen, right?
15:38:49 <Veinor> i'd like to reify your types
15:39:09 <hpc> you can kiss my ASCII
15:42:00 <mm_freak> does Kleisli have any noticable overhead?
15:42:08 <hpc> nope; it's a newtype
15:42:43 <mm_freak> hpc: GLdouble is a newtype for CDouble, yet CDouble is way faster than GLdouble
15:43:08 <hpc> mm_freak: oh, because rewrite rules?
15:43:12 <mm_freak> i don't know
15:43:19 <hpc> that's strange
15:43:34 <mm_freak> i'm in the designing phase of a new library, and i want to avoid performance bottlenecks
15:44:34 <mm_freak> my choice is between making an arrow transformer, an arrow with an underlying monad or both
15:45:19 <mm_freak> arrow transformer would be elegant, but then i would have to use Kleisli in certain applications, and i don't know how well that behaves performancewise
15:46:08 <yitz> Cale: how can we get @vixen back?
15:46:50 <Cale> yitz: People complained to have it removed
15:46:55 <Cale> I don't know
15:47:05 <Cale> I'm lazy, I don't want to switch it back and forth every few days
15:47:21 <yitz> ?
15:47:29 <Cale> I really don't care whether or not @vixen stays or goes
15:47:44 <yitz> Cale: i thought it was a bug, where it is doing @nixon instead
15:47:53 <mauke> no, @vixen was simply removed
15:47:56 <Cale> No, that's not a bug, that's spell correction
15:48:08 <dmwit> I know this is a really inefficient way to disseminate information, so you can just say "no" if you don't want to answer, but... what were the complaints about?
15:48:14 <Cale> But it seems to me that it's not really *useful*, and it seems to bother some folks, so I didn't really mind removing it.
15:48:29 <monochrom> @lego lego = ()
15:48:30 <lambdabot>  Defined.
15:48:43 <mauke> @define lego
15:48:54 <Cale> dmwit: The content of the responses.
15:48:54 <yitz> Cale: it's actually a useful promotion tool on our channels, due to the AI.
15:49:10 <monochrom> iirc, @undefine erases all, does not matter whether you add an argument
15:49:11 <yitz> Cale: even though i agree some of the content could be toned down a bit
15:49:16 <monochrom> @let lego = ()
15:49:17 <lambdabot>  Defined.
15:49:22 <monochrom> @let mono = ()
15:49:22 <Cale> dmwit: Specifically the perspective on women seemed to offend some people.
15:49:22 <lambdabot>  Defined.
15:49:26 <monochrom> @undefine lego
15:49:30 <monochrom> > mono
15:49:30 <lambdabot>   Not in scope: `mono'
15:49:31 <mwc> vixen isn't just a bot that chirps lines from a fortune-like file?
15:49:31 <dmwit> I see.
15:49:42 <mwc> news to me.
15:49:42 <Cale> mwc: It basically is
15:49:55 <mwc> So then the AI aspect is what?
15:50:00 <mauke> regexes
15:50:06 <Cale> mwc: It looks in your line for keywords, and responds randomly from a list of responses associated with each
15:50:07 <mwc> didn't seem to be as adaptive even as an Eliza clone
15:50:34 <Cale> It's pretty unimpressive as far as AI goes :)
15:50:44 <mwc> Well, AI in the sense of an association list :)
15:51:02 <monochrom> hahahaha
15:51:03 <yitz> mwc: yet even that level was good enough to surprise and entertain people often enough
15:51:03 <mwc> depending on your writing that could like like AL
15:52:01 <mauke> Cale: wait, why did you disable @vixen when @list is still causing errors?
15:54:04 <blackdog> yitz: it's a tree of weighted regexes. no AI at all.
15:54:16 <yitz> blackdog: that's a rudimentary AI
15:54:31 <blackdog> the real cleverness was that the dude who wrote it originally spent a lot of time thinking up responses
15:54:38 <blackdog> i just translated it to a non-insane format :)
15:54:50 <blackdog> (was originally a Visual Basic AIM bot)
15:55:02 <yitz> interesting
15:55:56 * monochrom envisions "visual basic haskell"
15:56:13 <blackdog> and i can understand people getting upset - there's some pretty shocking stuff in there
15:56:55 <mwc> True, and granted we don't all live in civilized countries
15:57:10 <yitz> blackdog: i thought some of the worst of it had already been removed
15:57:10 <mwc> I could see some of those pointing being enough to get somebody fired in the USA if they come up on a work PC
15:57:11 <blackdog> the translation was a fascinating thing to do, actually. externalising the data set took it from thousands of lines of code to about 20.
15:57:37 <mwc> heh
15:58:14 <geheimdienst> maybe my picture is incomplete, but those responses that i've seen were i'd say edgy. "shocking" is a bit much
15:59:01 <yitz> geheimdienst: there were some that were "shocking" - though as i said i haven't seen too many of those lately
15:59:05 <luite> I'm curious now what the removed responses where :)
15:59:13 <luite> were
15:59:40 <Cale> The source code for it is still available with lambdabot
15:59:43 * JoeyA joined at an awkward time, it seems
15:59:43 <yitz> besides that, the ones that were in the "dumb blonde" genre were indeed offensive
16:00:06 <Cale> I only disabled the plugin, I didn't remove it altogether, and I don't maintain the lambdabot package as a matter of policy ;)
16:00:23 <yitz> but i'd really like to see *some* clever bot here. it's a huge loss.
16:00:35 <Cale> Make an interface to CleverBot :)
16:01:26 <Cale> lol, cleverbot: "What do you think of Haskell?" -> "I don't have time for you right now."
16:01:32 <JoeyA> @faq Can Haskell be used to write politically incorrect programs?
16:01:33 <lambdabot> The answer is: Yes! Haskell can do that.
16:01:44 <mwc>  @smartass: hlints all code given to lambdabot
16:01:59 <Cale> Honestly, half of the stuff in @nixon is more offensive than anything that @vixen had to offer
16:02:13 <mwc> Well, Nixon actually existed
16:02:19 <Cale> But hey, that's the point, I guess.
16:02:19 <Cale> yeah
16:02:19 <yitz> Cale: and Nixon actually said those :)
16:02:21 <Cale> yes
16:02:28 <megajosh2> ...oh my did I join twice?
16:02:46 <megajosh2> Wow wrong network altogether
16:02:49 <Cale> megajosh, Megajosh, MEGAJOSH
16:02:50 <yitz> someone should write a casey stengel plugin
16:05:37 <monochrom> part of the original wording: <byorgey> Cale: it's a chatbot that simulates a horny 19 year old girl.  it is inappropriate and I imagine does not make women feel very welcome in #haskell.
16:06:35 <monochrom> I take it to mean that it is like a movie that makes fun of blonde girls, for example
16:06:35 <yitz> monochrom: not all of the content is like that. the really bad stuff could be taken out/replaced and it would still server the purpose.
16:06:52 <mauke> what purpose?
16:06:59 <c_wraith> but that's a lie.  It was actually a chat bot that simulated a sleazy guy pretending to be a 19 year old girl.
16:07:11 <yitz> c_wraith: true
16:07:39 <blackdog> i think my favourite line had her coming out with a ringing denunciation of the patriarchy. lots of references to foucault i don't pretend to understand.
16:07:56 <yitz> mauke: making this channel a lot more fun and thereby adding positive karma to haskell
16:08:14 <geheimdienst> we should have a plugin that pretends to be a cat
16:08:31 <mwc> meow
16:08:38 <mauke> yitz: I don't find @vixen very fun
16:08:41 <mwc> > putStrLn "Meow"
16:08:41 <lambdabot>   <IO ()>
16:08:44 <yitz> blackdog: there were comments about haskell curry and alonzo church which obviously didn't come from the VB bot
16:08:57 <gtirloni> geheimdienst: not very useful.. it'd be caught in a sleep loop forever
16:08:58 <blackdog> yitz: yeah, I added that.
16:11:17 <kfish> "haskell-pkg: it's long for hackage"
16:11:53 <yitz> mauke: i didn't like the riske and chauvinist parts. those weren't fun. but very often some of the other almost-relevant accidentally-wise responses elicited smiles and laughs from newcomers to the channel.
16:16:28 <mattp_> what si the difference between => and -> in a type declaration?
16:16:56 <blackdog> yitz: at least when i left it, the text format was pretty obvious. you could probably clean it up in half an hour.
16:16:57 <blackh> mattp_: The stuff on the left of => is the type class context.
16:17:25 <mattp_> blackh: what does that mean? :) im reading through learn yourself a haskell now
16:18:08 <blackh> mattp_: Well, start by pretending it isn't there. So, for example, Map.insert :: Ord k => k -> v -> Map k v -> Map k v
16:18:37 <blackh> mattp_: Ignoring the type class context, this means that it takes a key, a value, a map, and returns a new map
16:19:06 <blackdog> blackh: oh hey, long time no see :) was NZ crazy after the game?
16:19:07 <blackh> mattp_: The Ord k => means that type 'k' can be compared with < > <= >= etc
16:19:40 <mattp_> ah, so its a hint to what type class the given type is?
16:19:41 <blackh> blackdog: New Zealand is definitely in a state of rubgy euphoria!
16:20:12 <blackdog> blackh: can't imagine many of you have fingernails left
16:20:25 <blackh> mattp_: A type class says that it can be any type that is a member of that class. For example, Int is a member of Ord, because comparison functions like < and > are defined for it.
16:20:38 <Cale> mattp_: Well, less a hint, and more an outright constraint on what type k is.
16:20:52 <blackh> mattp_: I meant to say... A type class *constraint* says that it can be any type that is in that type class.
16:21:36 <mattp_> makes sense! and you can define a context for v as well (or any parameter)?
16:21:40 <Cale> yeah
16:21:43 <blackh> blackdog: Clearly you saw the NZ vs France match. Definitely a nail-biter, with NZ winning by 1 point!
16:22:06 <mattp_> understood. thanks guys
16:22:09 <Cale> and with extensions, there are even multiparameter constraints which can say how types are supposed to relate to one another
16:22:35 <mattp_> not quite there yet :)
16:22:49 <Cale> (like VectorSpace f v for saying that f is the type of scalar for a vector type v)
16:23:46 <Cale> and that class might define a scalar multiplication operation like  (*.) :: f -> v -> v
16:23:54 <blackh> mattp_: You've got the idea. If you defined a function that used < on a value of type 'a', then the compiler would complain, so you'd have to add Ord a => to your function's type signature.
16:24:32 <Cale> Yeah, single parameter type classes are certainly enough to get you a long way, so I won't drag you any farther afield :)
16:25:10 <Cale> One interesting thing about typeclasses is that they can introduce functions which are polymorphic in just their result type
16:25:14 <Cale> for example
16:25:18 <Cale> class Read a where
16:25:23 <Cale>   read :: String -> a
16:25:27 <Cale>   ... other stuff ...
16:25:37 <Cale> :t read
16:25:38 <lambdabot> forall a. (Read a) => String -> a
16:25:58 <Cale> > read "123" :: Integer -- the parser to use is determined by the type of result we ask for
16:25:59 <lambdabot>   123
16:26:10 <Cale> > read "[123,4,5]" :: [Integer]
16:26:11 <lambdabot>   [123,4,5]
16:26:18 <Peaker> It's a bit sad there's no simple   read :: Read a => String -> Maybe a   in the prelude
16:26:25 <Peaker> @type reads
16:26:26 <lambdabot> forall a. (Read a) => String -> [(a, String)]
16:26:48 <Cale> Yeah, though you can chain uses of reads together really nicely with list comprehensions or the list monad
16:27:07 <rekahsoft> hi all..was just wondering if it was possible to have ghci open with a prompt of my choosing instead of me having to type ":set prompt "ghci> "
16:27:20 <yitz> Peaker: there was a library proposal to add maybeRead, it got enthusiastic support, but there was some bikeshedding about the type
16:27:24 <Cale> rekahsoft: write that command into your .ghci
16:27:35 <Cale> (I actually have the very same thing)
16:28:03 <rekahsoft> my .ghci? where is that?
16:28:10 <yitz> Peaker: some people wanted (Read a, MonadPlus m) => String -> m a
16:28:10 <Cale> What OS are you using?
16:28:23 <rekahsoft> Cale: linux of course my friend :)
16:28:30 <Cale> Ah, then just in your home directory
16:28:30 <rekahsoft> i assume somewhere in ~/?
16:28:36 <Cale> ~/.ghci
16:28:37 <yitz> Cale: or unfoldr :)
16:29:19 <Cale> yitz: Or even StateT String [], with a little wrapping ;)
16:29:20 <yitz> Cale: i meant, list comprehensions or the list monad or unfoldr
16:29:27 <yitz> Cale: right!
16:29:54 <yitz> Cale: but most of the time you really want maybeRead, not reads, and it's just a pain in the neck.
16:30:00 <Cale> true
16:30:05 <Peaker> yitz: I thought that generalizing Maybe and such was recognized as an anti-pattern (e.g: replacing monadic lookup with Maybe instead)
16:30:20 <Cale> I'm pretty used to just casing on (x,""):_
16:30:35 <yitz> Peaker: yes that was the side of the shed i took :)
16:31:05 <Cale> Peaker: Well, particularly abusing the presence of fail in the Monad class.
16:31:14 <Peaker> @hoogle MonadPlus m => Maybe a -> m a
16:31:15 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
16:31:15 <Cale> Peaker: If we still had MonadZero, it wouldn't be so bad
16:31:15 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
16:31:15 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
16:31:25 <Cale> and MonadPlus is kinda okay, but not quite right
16:31:26 <yitz> Peaker: have you seen Manuel's video about DPH? even if you aren't talking much about parallelism, you should see at least the first 15 minutes or so. it will help your talk.
16:32:18 <yitz> Cale: even if MonadPlus were right, Maybe is its universal object, so it's just as general and easier to work with.
16:32:51 <Cale> Yeah, I pretty much agree with that
16:33:45 <dpiponi> Anyone have experience profiling Haskell code using GLUT/OpenGL. My main.prof ends up empty. I wonder if it's because the code doesn't terminate cleanly due to quitting via a C exit.
16:33:48 --- mode: ChanServ set +o mauke
16:33:49 --- mode: mauke set -b $a:JamesTaggart
16:34:38 --- mode: mauke set -o mauke
16:34:40 <monochrom> is it possible to modify the program to exit via haskell?
16:34:47 <Cale> dpiponi: Can you exit using exitWith ExitSuccess explicitly?
16:35:15 <yitz> dpiponi: hey what happened to your world-famous nick?
16:35:20 <dpiponi> Cale: monochrom: Unfortunately no. GLUT code uses mainLoop which (as per spec) never terminates!
16:35:44 <Cale> dpiponi: Yeah, but you could still hook up a callback to do it...
16:35:49 <dpiponi> yitz: I need to negotiate with the current owner of 'sigfpe'. He did offer it to me but I use IRC so rarely I haven't sorted it out yet.
16:36:06 <yitz> dpiponi: ahhhh....
16:36:16 <dpiponi> Cale: Of course! Does exitWith trigger the profile dump?
16:36:38 <Cale> dpiponi: I'm not sure in this case, but I have had luck with similar issues in the past
16:36:39 <mwc> dpiponi: set GLUT_ACTION_ON_WINDOW_CLOSE to GLUT_ACTION_CONTINUE_EXECUTION, so that after the mainloop terminates the control is returned to whatever called glutMainLoop
16:36:43 <mwc> at least for FreeGlut
16:37:10 <monochrom> that sounds saner
16:38:14 <dpiponi> mwc: That's a FreeGLUT extension. Not available to me :-(
16:38:28 <mwc> Why do you need to use crappy GLUT?
16:38:44 <mwc> Almost anything is better and just as portable in practice
16:38:49 <dpiponi> mwc: Can I build the Haskell lib with FreeGLUT?
16:38:54 <mwc> dpiponi: what platform?
16:39:08 * monochrom embarks on a crazy experiment. from haskell call C, from C call haskell's exitWith :)
16:39:18 <monochrom> that, and threading, too :)
16:39:23 <dpiponi> mwc: MacOS X Lion+ghc 7.0.3
16:39:36 <mwc> Well, the Haskell GLUT bindings probably don't expose the additional FreeGLUT functionality
16:39:45 <mwc> Actually, I think Glut on OS X is based on freeGLUT
16:39:59 <mwc> basically, GLUT is suitable only for toys, and crappy ones at that
16:40:06 <blackh> dpiponi: I don't think exiting from GLUT works on the Mac.
16:40:23 <mwc> FreeGLUT is GLUT + enough fixes to actually make it a reasonable API for playing around with OpeNGL or writing a small game project
16:40:40 <dpiponi> mwc: I'm writing a toy! Or at least a prototype for something that might eventually not be a toy.
16:40:41 <mm_freak> why are there ArrowZero and ArrowPlus, but only a MonadZero containing mzero?
16:40:52 <mm_freak> historical reasons?
16:41:01 <mm_freak> uhm
16:41:04 <mm_freak> s/MonadZero/MonadPlus/
16:42:04 <Cale> mm_freak: You mean, why did they remove MonadZero?
16:42:10 <mwc> mm_freak: precisely
16:42:27 <Cale> mm_freak: It was one of a string of bad decisions made when monad comprehensions were removed in Haskell 98.
16:42:38 <mwc> MonadZero used to be Monads that could fail. fail wasn't part of the original Monad, you used mzero
16:42:55 <mwc> fail is another one IMAO
16:42:59 <Cale> yeah
16:43:04 <dpiponi> exitSuccess successfully triggers the profile dump. Thanks guys!
16:43:48 <dpiponi> I thought it was just a wrapper for C exit but obviously it does more.
16:44:07 <mm_freak> Cale: i didn't know it used to be there…  thanks
16:44:25 <Cale> mm_freak: Also, it used to be  map :: (Functor f) => (a -> b) -> f a -> f b
16:44:39 <ion> So sad
16:44:43 <mwc> sigh.
16:44:45 <mm_freak> yeah, i've heard that one…  unfortunate
16:44:49 <HugoDaniel> rip john McCarthy :(
16:44:58 <mwc> Were type classes really seen as being that difficult for newcomers?
16:45:22 <mm_freak> mwc: i guess not the type classes themselves, but the error messages you tend to get
16:45:33 <Cale> iirc, it's all John Hughes' fault ;)
16:45:56 <Cale> (But don't quote me on that, it's just a vague recollection of reading the mailing list history years ago)
16:45:58 <mm_freak> mwc: the the purpose of teaching there is even helium, a haskell-like language without type classes
16:46:02 <BMeph> dpiponi: Maybe you should learn more, and blog about it... ;)
16:46:05 <mwc> I mean, they're all through the arithmetic portion of the language, Ord, Num, RealFloat, etc, yet we had to take them from the functional part of the library as well?
16:46:37 <Cale> I highly recommend reading the Haskell 1.4 prelude :)
16:47:16 <Cale> ++ used to be the name for mplus too
16:47:41 <dpiponi> BMeph: I might blog about one aspect of GLUT programming though it's a bit of a dirty hack really.
16:47:45 <Cale> and concat :: MonadPlus m => [m a] -> m a
16:48:04 <megajosh2> That actually sounds nice
16:48:07 <megajosh2> Why was it changed?
16:48:38 * BMeph petitions Haskell 2012 to have "map :: (Functor f) => (a -> b) -> f a -> f b" and "lmap :: (a -> b) -> [a] -> [b]" :)
16:48:39 <Cale> because waaah my students are confused and I don't want to teach them about typeclasses
16:48:58 <megajosh2> That's all?
16:49:01 <Cale> Pretty much
16:49:14 <megajosh2> some compromise
16:49:22 <monochrom> hmm, -threaded kills the profiling. also "warning: too many hs_exit()s"
16:49:59 <monochrom> perhaps because the C side doesn't try to loop
16:52:08 <Cale> Also, Haskell 1.3 had  zeroOrMore, oneOrMore :: (MonadPlus m) => m a -> m [a]
16:52:30 <Cale> Not sure why those got dropped
16:52:58 <yitz> Cale, megajosh2: there is something to be said for type-specialized versions for list, because that case is common. but i agree with BMeph about the choice of name.
16:52:59 <monochrom> the C side loops. still too many hs_exit()s and no profiling output
16:53:15 <Cale> oh sure, I'd be fine with a list-specialised lmap
16:53:24 <monochrom> perhaps because my haskell main forks a thread and waits
16:55:00 <blackh> Cale: Everyone talks about fixing Prelude and there seems to be a lot of agreement. Backwards compatibility is surely fixable if it's done right - by giving it a name other than Prelude.
16:55:01 <monochrom> now it outputs if I have main call the C side
16:55:01 <Peaker> the problem with type-specialized functions, is that they encourage writing type-specialized code
16:55:21 <Cale> blackh: yeah, or just using the system of packages that we already have
16:55:47 <monochrom> well, I suppose in practice, you use haskell main to call the C side event loop anyway
16:56:17 <blackh> Cale: Obviously the first step is to implement a replacement Prelude.
16:56:32 <monochrom> there is still one possibility I haven't tried: main forks a thread to call the C side, but use forkOS for that
16:56:37 <yitz> Peaker: true. but list is so fundamental, you often do really want code "specialized" to it.
16:56:43 <rekahsoft> whats the difference between a "strict" version of a function and a non-strict version? eg whats the difference between foldr and foldr
16:56:48 <rekahsoft> foldr'
16:56:53 <rekahsoft> srry for the typo :s lol
16:56:55 <Cale> I'm not sure if they were ever in the report, but some implementation's prelude also at one point had takeUntil and dropUntil (which are like takeWhile and dropWhile, but shift the point where they cut the list by one)
16:57:01 <Peaker> yitz: yeah, but Data.List's monomorphism is very sad, imo.. It's the excuse behind the String type, for example
16:57:10 <Peaker> yitz: or rather, the monomorphism of Prelude's Data.List functions
16:57:27 <monochrom> no, "warning: too many hs_exit()s" again, and no profiler output
16:57:59 <monochrom> that one bugs me because "too many hs_exit()s" just shouldn't happen
16:58:24 <rekahsoft> and oops i meant foldl not foldr
16:58:33 <yitz> Cale: yeah it sure is annoying when you need those and have to write them by hand.
16:58:55 <Cale> I think they were in the gofer prelude at some point
16:59:17 <Cale> takeUntil :: (a -> Bool) -> [a] -> [a]
16:59:18 <Cale> yep
16:59:28 <blackh> rekahsoft: Well, if you use foldl (+) 0 [1..100000] you'll get a long chain of unevaluated values.
16:59:32 <Cale> (from version 2.30 of gofer)
16:59:49 <Cale> no dropUntil, but that's reasonable
16:59:53 <blackh> rekahsoft: This is generally not what you want. foldl' will cause it to perform the addition at each step, and that'll just give you the value.
17:00:24 <monochrom> ok, exitWith simply raises an exception to the calling thread, not the main thread. but then, no one should be calling hs_exit()? or at least, the main thread shouldn't be killed?
17:01:10 <Cale> foldl will race down the list not performing any of the additions and building up a large expression which looks like ((...((0 + 1) + 2)...)+99999)+100000
17:01:37 <Cale> and then when it gets to the end, evaluating this expression will cost a lot of stack space
17:01:47 <Cale> (because (+) is strict on integers)
17:02:20 <rekahsoft> blackh: so essential use in scheme what we would call an accumulator? aka haskell won't be lazy and keep building the expression 1+2+...+100000 but instead force the evaluation of the expression somehow?
17:02:31 <Cale> yeah
17:02:35 <megajosh2>  Exactly
17:02:45 <rekahsoft> ..need to go take a look at the source..i wonder how they (foldl and foldl') are implemented differently..
17:02:50 <Cale> @src foldl
17:02:51 <lambdabot> foldl f z []     = z
17:02:51 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:02:52 <mwc> rekahsoft: seq
17:03:00 <megajosh2> seq forces evaluation
17:03:08 <Cale> foldl' replaces that second line with something like:
17:03:14 <rekahsoft> Cale: sweet..didn't know you could do that ^ lol
17:03:28 <Cale> foldl' f z (x:xs) = let y = f z x in y `seq` foldl f y xs
17:03:32 <mwc> seq is a magic trapdoor into the Haskell RTS that basically evaluates the first argument far enough to pattern match one level of it, (so for a number it evaluates it) then takes on the value of the second without evaluating it at all
17:03:33 <Cale> er, foldl'
17:03:36 <Cale> foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
17:03:36 <rekahsoft> mwc: awe cool :D
17:03:57 <blackh> rekahsoft: There is a little bit of a learning curve with seq, so please keep asking us about it till you understand.
17:03:59 <rekahsoft> @src foldl'
17:03:59 <lambdabot> foldl' f a []     = a
17:03:59 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:04:01 <Cale> rekahsoft: You should note that while there is a stack in GHC's evaluator, it's not a call stack
17:04:36 <Cale> rekahsoft: The stack is used to hold pattern matches whose scrutinee isn't evaluated enough yet to be able to match
17:05:15 <Cale> (+) for Integer will pattern match on both its arguments, so if one of them isn't evaluated, it'll go on the stack
17:05:32 <mwc> > undefined `seq` 5
17:05:34 <lambdabot>   *Exception: Prelude.undefined
17:05:43 <mwc> > (Just undefined) `seq` 5
17:05:44 <lambdabot>   5
17:05:48 <monochrom> unless every thread is built to react to that exception by calling hs_exit(), which in turn goes kill the main thread, which in turn calls hs_exit() again...
17:05:56 <Cale> You should also note how foldl and foldl' in their recursive case immediately call foldl, and never pass control to anything else.
17:06:03 <rekahsoft> Cale: alright good to know..i don't see whats so tough about seq..the types seem pretty simple..seq :: a -> b -> b
17:06:04 <Cale> until they get to the end of the list
17:06:07 <megajosh2> mwc: ...what just happened there?
17:06:13 <Cale> rekahsoft: well, it's magic ;)
17:06:15 <megajosh2> The first argument is forced to evaluate before the second one?
17:06:45 <Cale> rekahsoft: seq _|_ y = _|_ where _|_ means a nonterminating or undefined value, and seq x y = y otherwise
17:06:47 <mwc> megajosh2: basically seq in the second example only evalues (Just undefined) to tell that it could be matched by a pattern of the form (Just _)
17:06:56 <rekahsoft> Cale: is there some wiki for all the handy commands your issueing to the irc bot (lambdabot)
17:07:11 <Cale> rekahsoft: there really ought to be, but I don't think there is
17:07:12 <Cale> @help
17:07:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:07:15 <mwc> seq isn't deep, it doesn't evaluate the whole structure, it just performs the same evaluation that would be forced if you tried to match a case statement on it
17:07:16 <Cale> @list
17:07:16 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:07:20 <rekahsoft> > map (\x -> x^2) [1..10]
17:07:21 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
17:07:27 <Cale> ^^ that list is a bit out of date (some commands removed)
17:07:38 <rekahsoft> sooo sweet! lol
17:08:07 <Cale> rekahsoft: So, seq x (seq y z) is the same as seq y (seq x z)
17:08:09 <Peaker> > map (^2) [1..10]
17:08:10 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
17:08:26 <Cale> rekahsoft: (which may seem unintuitive at first)
17:08:34 <Cale> and seq x x = x
17:08:43 <monochrom> wait, when haskell calls C, and then C calls haskell back, that's another haskell thread, exitWith from there shouldn't work either
17:09:04 <megajosh2> Hmm
17:09:08 <megajosh2> So when this case happens
17:09:10 <megajosh2> osh2 +i] [2:Freenode/#haskell +CLcnpt]
17:09:12 <rekahsoft> Peaker: lol yes..much nicer way to do it..still used to scheme/lispy stuff..just been working on learning mroe and more haskell..so sexy..love how it reminds me / is so based in math :D
17:09:13 <megajosh2> #haskell»
17:09:14 <megajosh2> wow
17:09:16 <megajosh2> ...
17:09:25 <megajosh2> foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
17:09:26 <megajosh2> ^ this case
17:09:26 <Cale> So seq x y doesn't really sequence the evaluation of x and y, but it does place a constraint on evaluation order -- it means that x has to be evaluated before the result of evaluating y can be used
17:09:46 <rekahsoft> Cale: and hmm..that does seem a little odd..
17:09:54 <megajosh2> Ah
17:09:57 <mwc> rekahsoft: keep in mind that it only really makes sense for pure types
17:10:10 <blackh> rekahsoft: The only thing that actually forces evaluation is the execution of IO actions.
17:10:11 <Cale> rekahsoft: Yeah, if it helps, you can just think of it as "evaluate x, then y", but you should be aware that it's not really what the compiler will do. :)
17:10:23 <Cale> blackh: and pattern matching from there :)
17:10:27 <Peaker> why does everyone use seq and not $! ?
17:10:41 <Peaker> or bang patterns?
17:10:51 <Cale> case is the primitive construct in the GHC intermediate language for forcing evaluation
17:11:13 <Cale> Peaker: probably has something to do with $! having the wrong associativity (and for these explanations, not being primitive)
17:11:18 <dafis> Peaker: bang patterns are unfortunately not portable, $! only works nice for the last argument
17:11:41 <Cale> Having to write (f $! x) $! y is really awkward
17:12:08 <Peaker> x `seq` y `seq` f x y   is somewhat awkward too
17:12:11 <Cale> sure
17:12:14 <mwc> rekahsoft: if it helps you sort out your confusion:
17:12:29 <mwc> > (putStrLn "Hello World") `seq` 53
17:12:35 <lambdabot>   53
17:13:05 <Cale> (doesn't print "Hello World", it just evaluates the action for doing so, doesn't execute it)
17:13:07 <mwc> remember that when you have a value in the IO Monad, say IO a, evaluating it just gives you another value
17:13:10 <mwc> precisely
17:13:12 <Cale> but that's sort of separate from this discussion
17:13:14 <rekahsoft> Cale: also fully gotcha on the seq x (seq y z) == seq y (seq x z)
17:13:27 <mwc> well, it explains why seq x (seq y z) == seq y (seq x z)
17:13:30 <megajosh2> So it merely made sure that (putStrLn "Hello World") was fully evaluated before 53 was?
17:13:38 <mwc> if effects could escape then it certainly wouldn't be an identity
17:13:44 <mwc> megajosh2: right
17:13:52 <megajosh2> This I need to remember
17:14:19 <Cale> rekahsoft: yeah, because if both x and y are terminating, then the result is z, and if either is nonterminating, the result is nontermination. So the compiler is free to do anything which ensures that x and y are both terminating before it'll let you use z.
17:14:35 <Cale> It's even allowed to evaluate z first, and then x and y if it wants
17:14:41 <rekahsoft> @src foldl'
17:14:41 <lambdabot> foldl' f a []     = a
17:14:42 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:14:44 <mwc> again, remember evaluating something of type IO a just gives you a value of type IO a, it doesn't evaluate it. To do that you need >>= to chain it onto the end of an IO computation.
17:14:53 <Cale> It just can't let you see what the result of evaluating z is until x and y have been checked :)
17:15:19 <Peaker> though people generally want eagerness, not strictness, so seq is wrong anyway... :P
17:15:28 <Cale> Peaker: I totally disagree
17:15:31 <Cale> er
17:15:34 <blackh> Another thing to note: let x' = x+1 in seq x' x' works as expected, but seq (x+1) (x+1) is wrong and does nothing useful.
17:15:37 <mwc> Dunno, having IO actions being values taht I can carry around until I "use them" is very handy
17:15:47 <Cale> Well, I'm not sure whether I agree :)
17:15:56 <Peaker> Cale: if you write x `seq` y `seq` ... it may be because the order matters for performance
17:16:03 <monochrom> you partially agree. or, you safeMaybe agree.
17:16:04 <mwc> in fact, the only time strictness by default really makes sense is in IO-like monads anyways, at least to me, so it's not much of a loss
17:16:17 <megajosh2> blackh: Because the first and second argument are entirely separate expressions?
17:16:23 <Peaker> Cale: people use seq for the operational semantics, but seq doesn't have them
17:16:26 <Cale> I misread your statement at first and totally disagreed with the statement that I misread ;)
17:16:56 <blackh> megajosh2: That's right. It's important to remember that seq is magic.
17:17:01 <mwc> yeah, I misread that too
17:17:02 <rekahsoft> btw Peaker i did a google for bangPatterns and didn't come up with much..mind pointing me to a good explanation?
17:17:06 <mwc> very much a garden path sentence
17:17:07 <Cale> The weaker semantics that seq has are usually enough to guarantee what's required for not killing the stack, anyway :)
17:17:16 <mwc> rekahsoft: google for "ghc bang pattern"
17:17:49 <Peaker> Cale: unless some advanced optimizer shows that it can be lazy in your case because your input is total or what not :)
17:18:10 <Peaker> if people want their function to be eager due to performance/operational concerns, they want pseq, and not seq
17:18:10 <Cale> rekahsoft: basically, pattern matching like  f !x = y  will translate into f x = x `seq` y
17:18:36 <megajosh2> Ah
17:18:39 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/ is still my favourite example of seq
17:18:40 <megajosh2> Makes sense
17:19:25 <Cale> Peaker: You might be right about that. I think there's something semantically weaker than pseq (and operationally equivalent to the current seq) which will usually do though.
17:19:44 <Cale> GHC will sometimes evaluate y first with seq x y as it stands
17:20:10 <Cale> But it's okay in a lot of cases, because the operational constraint is that checking that x is nonbottom is the same as evaluating it.
17:21:21 <monochrom> I would love to see what this weaker semantics is.
17:21:32 <yitz> Cale: usually
17:21:42 <Cale> monochrom: I guess it's a nondeterministic operational semantics :)
17:22:01 <megajosh2> if x can be evaluated first then what exactly does seq guarantee?
17:22:06 <monochrom> we already know that "check that x is nonbottom" doesn't cut it if it is done too late
17:22:08 <rekahsoft> also another question now that i understand what seq does..how is it defined..
17:22:11 <rekahsoft> @src seq
17:22:11 <lambdabot> Source not found. My brain just exploded
17:22:19 <Cale> megajosh2: that x is evaluated before you can use the result of evaluating y
17:22:40 <Cale> rekahsoft: It's a language primitive, but it could be defined on specific datatypes using case
17:22:46 <monochrom> we already know that nondeterminism implies that there is still a stack-overflowing behaviour.
17:22:47 <rekahsoft> is it a built in?
17:22:50 <Cale> yeah
17:23:05 <rekahsoft> Cale: oops you beat me to it..
17:23:10 <Cale> (notably, it couldn't be defined on functions, but a number of people don't think it should work on functions anyway)
17:23:11 <Draconx> it can be defined on _some_ specific datatypes.
17:23:16 <rekahsoft> how does it function under the hood?
17:23:34 <megajosh2> Hmm
17:23:38 <Cale> for Maybe, for example,  seq x y = case x of Nothing -> y; Just _ -> y
17:24:11 <monochrom> the current words from the GHC people is that seq is highly probable to be eager. this is why so far it holds up
17:24:26 <Cale> It just pattern matches on x, causing its evaluation to occur before y can be used
17:25:03 <monochrom> (note "probable" is not "nondeterministic". "probable" means you can still ask for a probability distribution. "nondeterministic" means you can't even ask for that.)
17:25:11 <Cale> monochrom: I'm pretty sure that the expression consisting of lots of seqs which builds up in the case that seq works the other way around is still in a form which won't blow the stack up.
17:25:33 <monochrom> (this is why in formal methods, there are many failed attempts at modeling probability using nondeterminism.)
17:25:42 <Cale> It's just heap-inefficient in that case
17:25:57 <Cale> Honestly, I think the distinction between stack and heap is annoying and pointless.
17:26:33 <Cale> But I guess it does cause runaway programs to fail earlier instead of getting memkilled
17:26:43 <Peaker> There are probably many cases where stack blowup can be "fixed" to be large-heap-use - and the program is fine
17:27:12 <Peaker> Cale: there's a big issue with lack of memory sandboxing in modern OS's -- so if you go wild on the heap, you can kill the entire machine
17:27:30 <Cale> right
17:29:12 <Cale> I think GHC should try as hard as possible to make some graph reduction semantics a decent mental model for performance. (and it does a fairly good job of that, modulo some things with the stack)
17:29:18 <yitz> Cale: whether the distinction between heap and stack is pointless is an issue of compiler implementation. the current implementors seem to find it useful.
17:31:15 <monochrom> an easy way to eliminate the current stack is to accept a quadratic blow-up in time. at every step, search from the root (again) for the right node to reduce.
17:31:19 <megajosh2> > foldr1 (-) [1,5,2]
17:31:21 <lambdabot>   -2
17:32:06 <megajosh2> > foldl1 (-) [1,5,2]
17:32:09 <lambdabot>   -6
17:32:41 <bfig> is there a way to type prettily haskell through lstlistings environment?
17:32:52 <monochrom> indeed, same for eager programming languages
17:32:59 <Peaker> you could also have the stack grow indefinitely as the heap?
17:34:03 <Cale> Peaker: yeah, and in fact, the ability to do this is implemented but inaccessible
17:34:23 <megajosh2> > 1 - 5 - 2
17:34:27 <lambdabot>   -6
17:34:27 <Cale> (you can choose a bound on stack size with an RTS option, but there's no option to disable the bound altogether)
17:35:05 <monochrom> eventually, you want to not blow the stack and not blow the heap either
17:35:10 <Cale> I think the main rationale for not having one is that when programs blow up the stack, they tend to do so extremely rapidly.
17:35:25 <megajosh2> > (1 - 5) - 2
17:35:29 <lambdabot>   -6
17:35:31 <Cale> (but this isn't always true)
17:35:54 * hackagebot cabal-file-th 0.2 - Template Haskell expressions for reading fields from a project's cabal file.  http://hackage.haskell.org/package/cabal-file-th-0.2 (NickPartridge)
17:35:56 * hackagebot cabal-file-th 0.2.1 - Template Haskell expressions for reading fields from a project's cabal file.  http://hackage.haskell.org/package/cabal-file-th-0.2.1 (NickPartridge)
17:37:33 <monochrom> already, people also choose to limit heap size because linux is too much a yes-man on overbooking memory
17:37:38 <Peaker> a visualizing debugger/tracer could be awesome
17:38:21 <Peaker> monochrom: all OS's are at fault -- the problem IMO is not that it lets you allocate too much virtual memory -- that's fine. The problem is that it steals physical memory from everybody else to satisfy your incessant craving for more
17:38:47 <monochrom> not DOS  <duck>
17:39:06 <monochrom> (have you used CP/M, too? :) )
17:39:20 <Peaker> so a process that consumed 99% of all physical memory resources wants the extra 1%, it fights with everybody else on that 1% and the entire system grinds..  the root of the problem is dumb page eviction choices, and is shared by OSX, Linux, Windows
17:39:45 <telexicon> most operating systems dont handle 99% memory usage well
17:40:51 <monochrom> I wouldn't know how to do it better, either.
17:41:16 <ivanm> preflex: seen Cale
17:41:16 <preflex>  Cale was last seen on #haskell 5 minutes and 46 seconds ago, saying: (but this isn't always true)
17:42:12 <monochrom> in reality, I haven't used the swap partition for a long time on linux
17:42:26 <ivanm> Cale: do you know if it's possible to define some form of canonical traversal for graphs with no ordering on edges such that - no matter how you create it - when you start traversing on a specific edge, the traversal will always be the same?
17:42:28 <Peaker> monochrom: I have a general idea -- generally it is to punish the evil-doers more.. If a process has a large working set, force it to spread its "memory credits" thin, so its pages are the first candidates for eviction
17:42:49 <Peaker> monochrom: unfortunately, even if you disable swap, your OS will still swap memory-mapped files (executables, shared libraries, etc)
17:42:58 <jmcarthur> if i have a bunch of Word8 fields that i tell ghc to unpack, will it word align them or byte align them?
17:43:05 <Cale> ivanm: There's a way to choose a canonical labelling of vertices of an arbitrary simple graph.
17:43:24 <ivanm> Cale: what is it?
17:43:26 <Cale> ivanm: which can be used to prove that two graphs are isomorphic, for example
17:43:34 <ivanm> and is it possible to have a canonical labelling of the edges as well?
17:43:39 <Cale> I don't actually understand the algorithm
17:43:44 <Cale> but it's used by a program called nauty
17:43:44 <ivanm> heh, fair enough
17:43:49 <ivanm> oh, right...
17:43:52 <Cale> http://cs.anu.edu.au/~bdm/nauty/
17:43:58 <ivanm> dammit, you _had_ to mention nauty!
17:44:00 <telexicon> well ram is pretty cheap
17:44:17 <telexicon> how about buying 16GB for $80 and problem solved
17:44:36 <Peaker> telexicon: that's not a solution.. the problem in many cases is thrashing
17:44:38 <Cale> Well, once you can canonically label the vertices, edges are easy
17:44:39 <ivanm> telexicon: you can buy 16 GB of RAM for $80? :o
17:44:51 <Peaker> telexicon: a misbehaved process will consume any amount of RAM you throw at it, and kill your machine
17:45:03 <Cale> You can label them with the vertices at their ends, in increasing order :)
17:45:06 <Peaker> telexicon: the problem is lack of proper sandboxing in modern OS's..
17:45:10 <ivanm> Cale: oh, right
17:45:12 <telexicon> Peaker, oh, isnt that what the OOM killer is supposed to deal with
17:45:29 <ivanm> maybe I need to think through what I'm wanting to do more...
17:45:32 <monochrom> yeah, I agree about disadvantaging large footprint processes
17:45:40 <Peaker> telexicon: The OOM killer is activated after the system already ground to a halt, it will first evict all useful pages away from RAM
17:45:44 <telexicon> ivanm, hm, it must've been a sale, all i can find is $90 for 16GB http://www.newegg.com/Product/Product.aspx?Item=N82E16820231309
17:46:01 <megajosh2> @src $!
17:46:03 <ivanm> my idea was: it's a PITA to have to implement graph serialisation methods for different types; why not define a common intermediary type?
17:46:04 <lambdabot> f $! x = x `seq` f x
17:46:14 <megajosh2> Ah that makes sense
17:46:32 <ivanm> telexicon: oh, 4 x 4GB, that makes more sense
17:46:49 <telexicon> oh yeah, i dont think they'd sell a single 16GB stick for that little
17:49:24 <ivanm> telexicon: also, every saying something like "but you can get <x> for $<y>" assumes everyone you're talking to lives in the same country as you do...
17:49:27 <megajosh2> @src foldr
17:49:28 <lambdabot> foldr f z []     = z
17:49:28 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:50:34 <ivanm> e.g. I can get kangaroo rump steak for $16/kg
17:50:37 <ivanm> can _you_ ?
17:50:57 <monochrom> I want that!
17:50:57 <ivanm> http://www.jordoschopshop.com/kangaroo-rump-2.html
17:50:59 <megajosh2> I tried to order that from the Outback Steakhouse
17:51:12 <ivanm> just happened to google it, and coincidentally came back with an online butcher in my area! :o
17:51:19 <monochrom> heh Outback is not so outback afterall
17:51:35 <ivanm> megajosh2: from what I've heard, the only real Australian thing at the outback steakhouse is the foster's beer, and they brewed that in canada anyway
17:51:43 <ivanm> (no-one drinks fosters here anymore)
17:51:50 <monochrom> canada++
17:52:16 <monochrom> but the fried onion thing is still unique
17:53:01 <kfish> http://en.wikipedia.org/wiki/Blooming_onion
17:53:02 <megajosh2> ivanm: The last time I read the menu online with a guy from Australia I was almost in tears
17:53:30 <ivanm> http://ars.userfriendly.org/cartoons/?id=20050428
17:53:52 <Peaker> monochrom: btw, I sent a mail to the Linux kernel mailing list about the awful eviction behavior.  The MM guy in there said implementing it would be difficult, so never mind
17:54:02 <ivanm> oh, and the one before it as well
17:54:28 <Peaker> I'm venturing that if MS fixed Windows in this regard and commissioned some Benchmark to show how much better performing Windows is, Linux would get that fixed in months
17:55:13 * monochrom snickers at "chocolate thunder from down under"
17:55:32 <megajosh2> Clearly "down under" refers to the septic tank
17:55:59 <kfish> the septic tank reading the menu?
17:59:13 <ivanm> megajosh2: nope
17:59:50 <ivanm> megajosh2: dig a hole in the ground, shove a wooden wooden box with a hole to sit on on top
18:00:19 <ivanm> wait, I thought you said "thunderbox"
18:00:26 <ivanm> "down under" is just Australia in general...
18:01:13 <megajosh2> Err
18:01:23 <megajosh2> ivanm: I think I might get addicted to this comic
18:01:27 <ivanm> heh
18:01:31 <ivanm> I used to be
18:01:47 <ivanm> but then the writer's father got cancer, so he hasn't done updates for about a year :s
18:02:23 <monochrom> I have two userfriend books
18:02:23 <ivanm> Cale: duh, I just realised that what I was after was the graph canonisation problem... :s
18:03:09 <ivanm> Cale: so I guess I won't be splitting this serialisation stuff outside of the library then :s
18:04:26 <ivanm> megajosh2: huh, make that over 2 years... time flies :s
18:07:21 <BMeph> Is there such a concept, as a "co-effect"?
18:11:48 <c_wraith> I'm not sure it would be anything different than an effect
18:12:17 <telexicon> its an effect that co-happens
18:21:00 <Eduard_Munteanu> An effect in the OI comonad? :)
18:21:44 <kfish> the chicken is just an effect of the egg it lays etc.
18:23:32 <monochrom> my presence is evidence of a cause C1 before me. C1 is evidence of a cause C2 before it. etc. So, we talk not of a 1st cause, but a 1st effect and infinitely many causes!
18:24:47 <kfish> s/1st cause/self/ s/1st effect/present/ s/cause/turtle/
18:25:16 <shapr> o hai dashe
18:25:54 <shapr> k bye
18:26:32 <monochrom> haha
18:26:57 <monochrom> member 46359913! come back!
18:27:43 <monochrom> wait, member 46359913 was also called subb
18:27:53 <subb> hello
18:28:45 <subb> k bye
18:38:24 <Phlogistique> Hi
18:38:40 <Phlogistique> I know there are a lot of tutorials trying to explain monds "for dummies"
18:38:50 <Phlogistique> are there similar tutorials for Arrows?
18:39:42 <ivanm> not really
18:40:11 <ivanm> AFAIK, most people just use the tuple instance of Arrow
18:40:13 <ivanm> @instances Arrow
18:40:14 <lambdabot> (->), Kleisli m
18:40:21 <ivanm> s/tuple/function/
18:40:40 <ivanm> > first show (1,2)
18:40:41 <lambdabot>   ("1",2)
18:41:51 <byorgey> Phlogistique: try Paterson "Arrows and Computation" or Hughes "Programming with Arrows".
18:41:57 <mm_freak> is Data.Time.Clock.POSIX portable?  it's part of the 'time' package
18:41:58 <byorgey> Phlogistique: both are linked from http://haskell.org/arrows/biblio.html
18:41:59 <RarrRaptor> > afterwards destroy (1,2)
18:42:01 <lambdabot>   (1,Nothing)
18:42:31 <Phlogistique> byorgey: byorgey indeed, I was reading the second one
18:43:05 <ivanm> RarrRaptor: did you just @let those?
18:43:07 <byorgey> Phlogistique: did you find it difficult to follow?
18:43:49 <dafis> preflex: seen bos
18:43:50 <preflex>  bos was last seen on #haskell 5 days, 7 hours, 9 minutes and 31 seconds ago, saying: shachaf: thanks! i can't tell you how much fun it is teaching the class. funnest thing since ... something else that was very fun!
18:44:00 * RarrRaptor whistles innocently.
18:44:21 <Phlogistique> byorgey: not impossible, but not easy either
18:44:49 <Phlogistique> byorgey: I was wondering if there was something similar to "Of Monads and Spacesuits"
18:45:03 <Sic58> just make something up
18:45:05 <mm_freak> Phlogistique: i found that i understood arrows best by first understanding the (->) arrow and then implementing the automaton arrow
18:45:06 <byorgey> Phlogistique: "not impossible, but not easy either" is the optimal level of difficulty for learning.
18:45:06 <ivanm> Phlogistique: bah, jump straight to the point:
18:45:10 <RarrRaptor> Of Monads and Spaghetti!
18:45:12 <RarrRaptor> For eating!
18:45:14 <ivanm> what's the burrito equivalent of arrows?!?!?!
18:45:35 <mwc> fajitas.
18:46:53 <mm_freak> arrows aren't hard…  it's just that there are far less useful arrows, which are not monads
18:47:51 <byorgey> can we please stop this "X isn't hard" meme? It doesn't actually help anyone. Almost everything is hard the first time.
18:47:59 <byorgey> (not picking on mm_freak in particular, I just hear this a lot)
18:48:29 <Phlogistique> actually I didn't think that arrows were that hard; at my current level I found my understanding of them to be easier than monad
18:48:32 <Phlogistique> s
18:48:58 <byorgey> Phlogistique: excellent
18:49:12 <ivanm> byorgey: yeah, what's with this addition stuff? I mean, zomg, what's the point of that!
18:49:13 <ivanm> :p
18:49:30 <Phlogistique> but I had to go through the "Write your Scheme of 48 hours" tutorial to drill the meaning of "monad" in my head; I don't think I ever really understood them before
18:49:58 <ivanm> I like RWH's take on monads
18:50:05 <mm_freak> byorgey: i'm saying this, because my main difficulty with arrows was that i searched a long time to find a real use for them
18:50:06 <Phlogistique> I guess I'll print out "Programmin with Arrows"
18:50:15 <ivanm> admittedly, I haven't read the scheme in 48hrs tutorial
18:50:20 <byorgey> ivanm: and if you met a six-year-old who was struggling with addition, you should not say to them, "oh, addition? addition isn't that hard"
18:50:47 <parcs> mm_freak: what is the automaton arrow again?
18:50:54 <byorgey> that is precisely the wrong way to motivate them.  it makes them feel stupid for not getting it immediately.
18:51:03 <Phlogistique> ivanm: it isn't anything incredible really; but it's a lot of using monads and encountering the same problems again and again, so I have found it a very efficient way of learning
18:51:04 <mm_freak> parcs: in its simplest form:  newtype Auto a b = Auto (a -> (b, Auto a b))
18:51:11 <kmc> byorgey, perhaps one should say "monads are simple but tricky"
18:51:22 <luite> byorgey++
18:51:22 <kmc> i think people expect there to be more meat to the concept than there is
18:51:26 <byorgey> kmc: sure, that sounds reasonable
18:51:29 <mwc> Huh, that's a monad?
18:51:32 <kmc> so some encouragement towards simple models is useful
18:51:40 <mwc> Er, an arrow?
18:51:51 <byorgey> kmc: yeah, I agree
18:51:57 <kmc> they're tricky precisely because there's so little to them... there are few statements you can make which are true of monads in general
18:52:06 <mm_freak> mwc: yes…  it's a type for functions, which can mutate themselves
18:52:15 <mwc> I was dealing with that this summer in the context of a stream generator, I had all sorts of my own combinators for dealing with it
18:52:19 <mwc> huh.
18:52:21 <byorgey> I suppose that's often what people mean when they say "monads aren't hard"; so perhaps I'm really just begging for more careful choice of words
18:52:33 <kmc> *nod* I think that's worth pointing out, yes
18:53:07 <Nafai> btw, I really enjoyed the recent Google Tech Talk on Haskell
18:53:08 <mm_freak> mwc: Auto f . Auto g = Auto $ \x -> let (y, a1) = g x; (z, a2) = f y in (z, a2 . a1)
18:53:19 <mm_freak> that's the basic idea
18:53:38 <mm_freak> mwc: you would usually call this in a loop, always using the most recent version
18:54:17 <tnks> reading McCarthy's Lisp paper, particularly when he introduces "label" claiming the "lambda-notation is inadequate for naming functions defined recursively."
18:54:27 <tnks> I feel this isn't true in light of fixed-point combinators.
18:54:39 <tnks> am I misunderstanding something?
18:55:15 <mwc> mm_freak: yep, I was using it in the context of a tokenizer/scanner for "nexting" the stream in response to the current state
18:56:04 <Phlogistique> 04:05:15 < kmc> they're tricky precisely because there's so little to them... <- the english word for that is "abstract" I think
18:56:06 <mm_freak> mwc: then perhaps you've been using a non-monad arrow without realizing it =)
18:56:11 <mwc> so given an entry state it produced a token
18:56:25 <mwc> yeah, except I had it defined in terms of fixed-point types and all sorts of gruesomeness
18:56:29 <mwc> knowledge.
18:56:51 <mm_freak> mwc: btw, a transformer version of it is defined in the arrows package
18:57:03 <mwc>  should not say to them, "oh, addition? addition
18:57:19 <mm_freak> newtype AutoT (>~) a b = AutoT (a >~ (b, AutoT (>~) a b))
18:57:24 <mm_freak> that's more useful than Auto in general
18:57:35 <mwc> I'll keep that in mind in case I ever decide that a hand-written Iteratee-based scanner is called for :)
19:03:46 <mm_freak> mwc: well, you can have 'Iteratee i (StateT s m) b' or 'AutoT (Kleisli (Iteratee i m)) a b', which are basically equally powerful, but for many iteratee applications i'd probably prefer the StateT variant
19:04:28 <mm_freak> it's also not that unnatural to use the AutoT (Kleisli (StateT s m)) arrow
19:05:50 <mwc> Well, the arrow portion of it was just to return a token as well as a function to analyze the next character
19:05:55 <mwc> so the iteratee part of it wasn't tied too tightly in
19:06:12 <mwc> since I didn't really like either API that much but wanted to play with the ocncept
19:06:40 <mwc> AutoT (Kleisli (StateT s m)) makes the most sense to me actually
19:07:23 <mm_freak> yeah, and if the 's' contains some notion of time, you get arrowized FRP
19:07:51 <mm_freak> AutoT is extremely powerful
19:35:38 <bfig> what's a common example of a recursive function of a single variable?
19:35:53 <bfig> ie, f n = g $ f (n-1)
19:36:08 <bfig> (ie, fibonacci but for a single var)
19:36:18 <napping> how about sum?
19:36:36 <mwc> bfig: well, fixed point iteration is the obvious candidate
19:36:45 <mwc> how about a sequence of Netwon's iterates?
19:36:46 <monochrom> not sure about common. f n = f (n-1); f 0 = 0  is my favourite
19:37:10 <monochrom> eventually, I may go Goodstein altogether
19:37:59 <monochrom> @src repeat
19:37:59 <lambdabot> repeat x = xs where xs = x : xs
19:38:03 <ddarius> f n t = f (n-1) (t, t); f 0 t = show t
19:38:03 <monochrom> is another one
19:38:12 <ddarius> Ah, but not a single variable.
19:38:22 <ddarius> An interesting function though.
19:39:00 <mwc> N(x) = x - f(x)/f'(x), Iteration of N(x) near a simple zero of f converges quite rapidly
19:39:32 <megajosh2> @src build
19:39:32 <lambdabot> build g = g (:) []
19:39:37 <megajosh2> :t build
19:39:38 <lambdabot> Not in scope: `build'
19:40:05 <bfig> guess i'll just use fibonacci and ackermann's
19:40:21 <byorgey> Ackermann's is not of a single variable.
19:40:54 <bfig> i said it wrong, it was of a single recursive step, not of a single var
19:41:02 <bfig> ie, not fibonacci
19:41:24 <ddarius> Then my example
19:42:02 <byorgey> > let f n t = f (n-1) (t,t); f 0 t = show t in f 3 1
19:42:03 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t, t)
19:42:31 <ddarius> byorgey: It's polymorphically recursive so it must have a type signature.
19:42:43 <monochrom> http://en.wikipedia.org/wiki/Goodstein%27s_theorem
19:42:44 <byorgey> > let f :: Show a => Int -> a -> String; f n t = f (n-1) (t,t); f 0 t = show t in f 3 1
19:42:50 <lambdabot>   mueval-core: Time limit exceeded
19:42:50 <lambdabot>  mueval: ExitFailure 1
19:42:54 <byorgey> right
19:42:57 <monochrom> beats Ackermann and single-variable
19:43:51 <byorgey> oh, hehe whoops
19:44:09 <byorgey> > let f :: Show a => Int -> a -> String; f 0 t = show t; f n t = f (n-1) (t,t) in f 3 1
19:44:12 <lambdabot>   "(((1,1),(1,1)),((1,1),(1,1)))"
19:45:22 <ddarius> That was my fault, but a strange mistake.
19:45:58 <monochrom> I had the same fault with f n = f (n-1); f 0 = 0. perhaps I infected you.
19:46:11 * ddarius conveniently shifts all blame to monochrom.
19:50:47 <kmc> dolio, are your slides online?
19:55:08 <meric> I am trying to use Criterion to benchmark a program, but whenever the program takes an argument, the program would end after it is testing clock cycles but before it starts to benchmark. The benchmarking works if the program was not given an argument. Can anyone enlighten me?
19:58:52 <kmc> are you using criterion's defaultMain? maybe it's reading your arguments
20:03:33 <mattp_> when you define the input type parameters, ie a -> b -> c
20:04:47 <mattp_> in the actual function definition, do the variables auto vivify?
20:05:32 <ddarius> Do you mean do they come to life and start terrorizing the country-side?
20:06:22 <napping> It is that time of year!
20:06:34 <mwc> mattp_: vivify doesn't mean what you think it does. What are you trying to ask?
20:06:42 <napping> they are implicitly quantified, if that's what you mean
20:06:52 <mattp_> ddarius: no haha. im just reading learn you a haskell http://pastie.org/2754130
20:07:56 <mattp_> how does f x y g map to a b c?
20:07:59 <napping> any free variables gathered up like forall a b c . a -> b -> c
20:08:19 <monochrom> I can see that LYAH vivifies a lot of things
20:08:45 <mattp_> so the variables just map first come first serve?
20:08:48 <napping> x has type a, and y has type b, and then c is a problem, because it's supposed to be a free variable, but you've clearly got another argument incoming
20:09:39 <monochrom> f :: a -> b -> c
20:09:58 <monochrom> therefore, in "f y x", y :: a, x :: b, f y x :: c
20:11:30 <napping> It's the arrows that match to the arguments
20:12:32 <napping> If you write f x y = .. as f = \x -> (\y -> ..), the outer \ -> matches the outer -> in the type, so x matches a, and the inner arrow in the type is the type for the \y -> ... part
20:12:34 <ddarius> It's that Γ ⊢ f : A → B ∧ Γ ⊢ x : A ⇒ Γ ⊢ f x : B
20:12:43 <napping> You could say f :: (a, b) -> [c] -> d
20:12:57 <napping> then x :: (a,b) and y :: [c], and the body should still return d
20:17:33 * ddarius tries to decide what the simplest type system that he'd be disturbed if he could quote the rules.
20:18:18 <napping> simply typed lambda calculus?
20:18:38 <napping> MLF?
20:18:41 <mattp_> napping: you lost me a little bit :)
20:18:43 <napping> UTT?
20:19:17 <dolio> 2DTT is definitely over the line.
20:19:29 <napping> mattp_: I was making an example to show that function arguments don't necessarily match up with type variables
20:19:44 <napping> 2DTT?
20:20:04 <dolio> 2 dimensional directed type theory.
20:20:09 * ddarius missed dolio 2DTT talk.
20:20:10 <napping> mattp_: the others are suggestions for darius
20:20:12 <ddarius> dolio: How'd it go?
20:20:14 <meric> kmc: Yes i was
20:20:36 <ddarius> napping: Everyone should be able to quote the rules for the simply typed lambda calculus.
20:21:19 <dolio> Went okay.
20:21:33 <dolio> STLC barely has any rules.
20:23:02 <djahandarie> I missed it too. :(
20:23:10 <djahandarie> Did ed manage to get a camera there?
20:24:09 <dolio> Nope.
20:24:31 <ddarius> dolio needs to maintain his secret identity.
20:24:58 <ddarius> dolio: Speaking of which, we should hang out some time after I read that thesis.  And how is your place?
20:25:56 <djahandarie> dolio, have slides or something?
20:25:59 <dolio> Hanging out at my place you mean? I still have essentially no furniture.
20:26:11 <djahandarie> You should re-present it to me and ddarius :(
20:27:28 <dolio> I have slides, but if you're actually interested in understanding the stuff, they probably won't be of much help.
20:27:51 <djahandarie> I'm fairly interested in how you structured the talk
20:27:55 <dolio> I aimed more at the high points of what is going on, and why you'd care as a non-mathematician.
20:28:33 <ddarius> Yes, the proposal paper did a reasonable job motivating it assuming you were vaguely in that area already.
20:29:30 <djahandarie> Was it all 2DTT or did you also talk about HTT?
20:29:38 <dolio> Licata and Harper's stuff is better in that arena than the univalent foundations guys.
20:29:51 <djahandarie> I think I have a neat way of explaining HTT after reading a lot about it a few weeks ago
20:29:52 <dolio> It was mostly HTT with some 2DTT toward the end.
20:30:03 <djahandarie> Need to write it down to make sure it makes sense though
20:30:33 <ddarius> Making sure things make sense is for losers.
20:30:48 <napping> dnolen: your pattern matcher inspired me to perpetrate this - example at the end https://gist.github.com/1311214
20:37:06 <dnolen> napping: heh, not following that at all … what is that letting you do?
20:38:19 <napping> Kinda messy, isn't it? case, cons, wild, ||, ⇒ are all functions data types defined there - it's building a baby pattern matcher
20:39:39 <dnolen> napping: heh, ok, just to see if it can be done? instead of using the built in syntax?
20:39:48 <napping> The pattern ingredients have types reflecting what they match against and what (if anything) they bind, and ⇒ calculates a corresponding function type to receive the arguments
20:40:55 <embwbam> noob question here - when the compiler says it can't match type a0 - what does a0 mean? I only put "a" in my function declaration, not "a0"
20:41:06 <embwbam> does it mean it thinks its a number?
20:42:31 <blackh> embwbam: The compiler does a pass of disambiguating everything by adding numbers on  the end.  I assume you must have another 'a' in an enclosing scope.
20:42:46 <embwbam> oh, ok
20:43:04 <embwbam> that makes sense. so it's just saying the a's don't match each other
20:43:08 <blackh> So if it talks about a and a0, it means they're two different variables both called 'a'.
20:43:15 <embwbam> thanks!
20:43:32 <blackh> Oh, right - yes - if a doesn't match a0, it means two things were called 'a', but they are not the same 'a'.
20:44:27 <dnolen> napping: anything in particular about core.match that inspired you?
20:44:33 <napping> dnolen: more or less. Partly to see that patterns can have types, and to see how well extensible patterns can be handled, but it is a bit heavy and doesn't play nicely with the termination checker. (Also, agda doesn't quite have a case expression)
20:46:29 <dnolen> napping: heh, I missed the agda. interesting!
20:46:33 <napping> Well, looking at the extensible pattern matching, and thinking it was a nice use of macros.
20:48:43 <dnolen> napping: very cool, tho agda is quite over my head. thanks for sharing that!
20:48:45 <napping> And also looking into changing the matchers to be able to return an error message rather than just a false value, realizing you can't attach metadata to false or nil, and wishing there was a nice type-checker to help verify that all the code would be prepared to consider [:mismach "why it won't work"] as a failure
20:56:29 <dnolen> napping: so that can match conses, anything else?
20:56:34 <eyu100> if I want to say that something is equal to 0 or 1, is there a better way to do it than (\x -> (x == 0) || (x == 1))
20:56:34 <eyu100> ?
20:56:48 <eyu100> something with type Int -> Bool
20:56:50 <kmc> :t (`elem` [0,1])
20:56:53 <lambdabot> forall a. (Num a) => a -> Bool
20:57:00 <napping> dnolen: anything you define a Matcher for, I think
20:57:23 <eyu100> whoops, I meant how do you combine two conditions
20:57:46 <eyu100> (filter (\a -> testValid a && elem a possibleActions) actions)
20:57:50 <eyu100> ^^ looks horrible
20:58:32 <dnolen> napping: is it possible to optimize for random access data structures? or does the code focus on the extensible part?
20:58:54 <blackh> eyu100: I think (`elem` [0,1]) is your best bet, though there are various other ways.
21:01:31 <blackh> eyu100: (uncurry (||) <<< (==0) &&& (==1))
21:01:34 <blackh> (yecch!)
21:01:41 <eyu100> ouch
21:01:47 <eyu100> at least that works for any general condition
21:02:25 <shachaf_> @ty liftM2 (||) (==0) (==1)
21:02:26 <lambdabot> forall a. (Num a) => a -> Bool
21:02:41 <eyu100> win
21:02:45 <eyu100> thanks =D
21:04:27 <eyu100> shachaf_: so liftM for functions is just (.), and liftM2 is the analogous version for binary funcs?
21:04:32 <blackh> That's great! Monad (->) wins again. Here's an Applicative version of it: (||) <$> (==0) <*> (==1)
21:04:48 <eyu100> yeah I was thinking of Monad (->), but I didn't know how to use it T_T
21:05:04 <Sic58> liftM2 for functions has this type: (a -> b -> c) -> (t -> a) -> (t -> b) -> t -> c
21:05:16 <shachaf_> eyu100: Yep.
21:05:29 <shachaf_> Just replace "m a" with "r -> a)".
21:05:34 <shachaf_> s/\)//
21:07:44 <napping> dnolen: it doesn't try to optimize at all. I just added booleans and a "view": https://gist.github.com/1311214
21:20:40 <DevHC> http://www.theregister.co.uk/2011/10/24/father_lisp_ai_john_mccarthy_dies/
21:21:02 <DevHC> in honor, let's type some parentheses !
21:21:09 <DevHC> )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
21:22:28 <ivanm> > repeat ')'
21:22:29 <lambdabot>   "))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))...
21:22:39 <ivanm> DevHC: the lazy way ^^ ;-)
21:23:38 <dnolen> napping: ah ok I'm following a little better now. there's no analysis phase or anything (which is where most of the core.match complexity comes from).
21:24:44 <byorgey> woo, I've got 'cabal init' dependency detection working =)
21:25:05 <napping> yeah, it's not anywhere near useful code - it doesn't handle dependent types, or enrich you assumptions with information about what you matched so it's much weaker than the built-in pattern matching
21:25:10 <kmc> DevHC, congratulations, you are the one billionth person to make a comment about Lisp and parentheses on the Internet
21:25:58 <ivanm> byorgey: how? going through all the source files and seeing what they import?
21:26:07 <DevHC> ololololololo https://plus.google.com/u/0/101960720994009339267/posts/ENuEDDYfvKP?hl=en
21:26:13 <ivanm> how does it deal with e.g. mtl vs monads-tf ?
21:26:20 <napping> I didn't really follow the table construction, so I'm not sure how hard that would be to follow
21:26:25 <byorgey> ivanm: yep! kinda dirty but it works =)
21:26:31 <DevHC> what's up with ppl dying so often nowadays? r we nearing 2012? xD
21:26:53 <byorgey> ivanm: if it finds multiple packages providing a module you import, it just prints a warning and tells you to decide which you want manually
21:26:57 <kmc> off topic + annoying
21:26:58 <ivanm> I would be more interested in validation: e.g. cabal install says "looks like this import isn't needed anymore"
21:27:00 <napping> Does match try to notice when several patterns have a common outer constructor, and re-use the results?
21:27:37 <byorgey> ivanm: yes, that would be nice too.
21:27:47 <ivanm> byorgey: though of course, your feature implies people code first and add .cabal later... doesn't everyone create the .cabal file first so that they can test that it builds? :p
21:28:03 <dnolen> napping: yes it tries to group tests together. but it also looks to see which "columns" have the greatest number of tests (non wildcards), and tests that column first.
21:28:29 <dnolen> fancier heuristics are possible, but that I've far as I've taken it, and it seems pretty good.
21:28:45 <byorgey> I tend to do a bunch of hacking in excitement, testing in ghci, then when I come to a stopping point I generate a .cabal
21:28:54 <byorgey> and at that point it might already have a bunch of deps
21:28:58 <napping> If two rows use [:key :a]  and [:key :b], will it share the test on :key?
21:29:21 <dnolen> napping: yes
21:29:28 <byorgey> ivanm: anyway, for my next trick I'm going to try to get it to automatically fill in the repository information
21:29:42 <ivanm> as in remote repo? :o
21:29:44 <ivanm> how?
21:29:47 <byorgey> by detecting whether the current dir looks like a darcs repo, git, svn, or whatever
21:30:00 <ivanm> oh, and then trying to find the remote location for them?
21:30:05 <byorgey> yeah
21:30:13 <ivanm> _that_ is cool
21:30:33 <byorgey> although your criticism about timing is still valid: what if you haven't set up a remote repo yet?
21:30:35 <ivanm> but again, it requires someone to have a remote repo before they cabalise :s
21:30:39 <ivanm> heh, yeah
21:30:40 <byorgey> yeah.
21:31:06 <byorgey> ultimately I would love for cabal init to evolve into something that lets you *modify* the .cabal file as well as generate it
21:31:19 <ivanm> taking darcs for an example, what would you then do, find the default push location? (since most people AFAIk _start_ on their local machines and then eventually put it somewhere)
21:31:23 <eyu100> what happened to the Data.Array documentation?
21:31:24 <ivanm> byorgey: definitely
21:31:28 <ivanm> but formatting will be an issue
21:31:28 <byorgey> ivanm: yeah
21:31:35 <ivanm> eyu100: what's wrong with it?
21:31:40 <byorgey> ivanm: right, it would require first writing a round-tripping .cabal parser
21:31:41 <eyu100> can't find it
21:31:44 <byorgey> which doesn't exist yet
21:31:50 <ivanm> eyu100: http://hackage.haskell.org/packages/archive/array/0.3.0.3/doc/html/Data-Array.html
21:31:59 <ivanm> it's in the array package, not base or containers (if you were looking there)
21:32:02 <eyu100> lol oops
21:32:12 <eyu100> yeah, I thought it would be in base since it is in haskell 98
21:32:14 <ivanm> byorgey: as in complete round-tripping for comments, spaces, etc.?
21:32:18 <byorgey> ivanm: right.
21:32:31 <ivanm> eyu100: Array is in haskell98, not Data.Array
21:33:00 <ivanm> off-tangent, but I wish cabal had some kind of "documentation" field
21:33:04 <napping> dnolen: I missed that. Is it specialize-matrix?
21:33:18 <byorgey> ivanm: oh, to link to external documentation?
21:33:28 <ivanm> I recently discovered by chance that it seems fgl used to be packed manually, because the README, changelog, test-suite, etc. aren't listed in the .cabal file but are in old tarballs :s
21:33:40 <ivanm> byorgey: to bundle extra documentation rather than using other-files, etc.
21:33:51 <ivanm> ideally with some form of "this entire sub-directory"
21:33:59 <ivanm> rather than having to list every single damn file
21:34:11 <byorgey> ivanm: you know other-files supports wildcards
21:34:18 <ivanm> it does? :o
21:34:25 <byorgey> ivanm: but I agree a 'documentation' field would be great
21:34:28 <ivanm> still, "other-files" indicates source-files to me, not documentation
21:34:41 <ivanm> dedicated changelog, readme, etc. fields would be even better
21:34:43 <dnolen> napping: yeah, and each type that extends the pattern matcher have pretty different opportunities for optimization.
21:34:53 <byorgey> ivanm: only certain forms of wildcards.  I forget what the restrictions are.
21:34:59 <dnolen> napping: seqs, maps, vectors quite different.
21:35:17 <ivanm> possibly start splitting out the documentation from the .cabal file and having a README file in markdown that hackage uses instead
21:35:29 <eyu100> I just spent a lot of time adding ix instances to my program when I realized I only needed a list of tuples *facepalm*
21:35:35 <byorgey> ivanm: yeah, like github does
21:36:06 <byorgey> ivanm: well, given the renewed excitement + progress on Hackage 2, this sort of thing may just happen
21:36:06 <ivanm> because currently, you typically need to copy everything (and haddock markup sucks, especially since .cabal files don't let you have blank lines)
21:36:32 <byorgey> You can have blank lines, you just use a single period
21:36:38 <ivanm> right, but it's a PITA
21:36:40 <byorgey> (agree that's annoying though)
21:36:47 <ivanm> it means word-wrapping in text editors doesn't work, etc.
21:36:53 <byorgey> yeah =P
21:37:21 <monochrom> xml or s-expression would have less of this problem
21:37:33 <bfig> is it correct to say that a datatype is something of kind * ?
21:37:40 <monochrom> but McCarthy recommends m-expression!
21:38:08 <ivanm> bfig: ... possibly
21:38:32 <ivanm> depends on how you define "datatype" :p
21:38:54 <monochrom> exact wording from the Haskell 2010 Report: "the Maybe type"
21:39:22 <monochrom> otoh, the exact wording is not "the Maybe datatype", so you may be safe
21:39:42 <bfig> i am not thinking about haskell in particular
21:39:58 <byorgey> I would usually interpret "datatype" to mean "something of kind *", but wouldn't rely on that interpretation when conversing with others
21:40:09 <napping> gtk2(hs) does not trying to make a widget a child of itself
21:40:10 <monochrom> but whatever you do should be compatible with Haskell at least
21:40:19 <dolio> Not all things of kind * are data.
21:40:23 <bfig> just trying to get to recursive datatypes, so i'll start with non recursive datatypes (this is what i'll be using as something of kind *)
21:40:58 <bfig> non recursive datatypes + type combinators (+, *) => datatypes. fixpoint => recursive datatypes
21:41:25 <bfig> just making sure it makes sense from the mathematical point of view
21:42:44 <copumpkin> what's the story for non-regular data?
21:43:21 <copumpkin> I think that adjoint folds paper went over it at some point
21:43:25 <copumpkin> but I can't remember
21:43:41 <monochrom> from the mathematical point of view, names and definitions are more balkanized as you go higher, so just define things your way and put it up front
21:43:50 <dolio> What do you mean story?
21:43:54 <byorgey> copumpkin: eh?
21:44:02 <dolio> Initial Algebras are Enough! gives semantics for them.
21:44:03 <ddarius> copumpkin: You can do them as initial algebras in functor categories as well as other ways.
21:44:08 <copumpkin> ah, okay
21:44:41 <bfig> well it would be 'ideal' to get to that but i have just 20-40 mins to put together a presentation so i'll have to skim over a lot of stuff :)
21:46:22 <monochrom> oh, in a talk, you just handwave :)
21:46:59 <ivanm> and say "these aren't the droid's you're looking for"
21:48:04 <bfig> the idea is not handwaving but presenting a motivation to study universal properties of recursive datatypes (instead of recursion) :)
21:49:58 <monochrom> "by datatype I mean things like <example 1>, <example 2>, <example 3>" is short and enough
21:50:04 <ddarius> bfig: "Initial Algebras are Enough!"
21:51:15 <monochrom> let's modify lambdabot so that @faq replies with that.
21:55:20 <eyu100> I have two very similar datatypes with four common field names, how do I resolve this conflict?
21:55:40 <ddarius> eyu100: The same way you resolve all naming conflicts.
21:55:52 <monochrom> rename fields. or merge the two types.
21:56:18 <monochrom> data X = C1 { f::Int} | C2 { f::Int }  is allowed
21:56:26 <ddarius> That's not how I solve all naming conflicts.
21:56:41 <monochrom> not me either, but it is an option
21:56:53 <eyu100> will try, my types are *very* similar
21:57:21 <monochrom> in this age when the XY problem runs amok, how could you guess which way is better
21:58:15 <ArchGT> hello, if I do a cabal install xml as root the package is installed system-wide?
21:58:34 <blackh> ArchGT: That's not the best way to do it.
21:58:46 <oscarvarto> Help! I'm starting with haskell, and I can't import a module (I just installed it with cabal install)
21:58:46 <ddarius> I like executing arbitrary code from the internet as root.
21:58:53 <monochrom> not system-wide, even with root
21:59:09 <ArchGT> ok, so any url to clarify the thing?
21:59:32 <monochrom> my url: http://www.vex.net/~trebla/haskell/sicp.xhtml
21:59:39 <blackh> ArchGT: Best way is to type this: cabal install --root-cmd=sudo --global <packagename>
21:59:47 <monochrom> in short, --global is how you get system-wide
21:59:57 <blackh> That way, it won't mess up any of your user's permissions.
22:00:08 <ArchGT> great
22:00:13 <blackh> oscarvarto: What are you trying to do?
22:00:43 <ArchGT> i think he's mocking me
22:00:58 <ArchGT> anyway, thanks for your help
22:01:33 <oscarvarto> ArchGT: I'm not mocking you. Seriously, its my first day with haskell
22:01:46 <monochrom> coincidence is more likely than mocking
22:01:46 <oscarvarto> and my first day with irc too
22:01:46 <ArchGT> oh, sorry then
22:01:49 <bfig> oscarvarto, you should be able to import things using 'import What.Ever'. what do you want to import?
22:02:18 <bfig> oscarvarto, also, if you are not sure where is what, check hoogle/hayoo
22:02:30 <blackh> oscarvarto: Welcome to Haskell and to IRC!
22:02:43 <oscarvarto> bfig: I'm trying import Boolean.Algebra
22:02:59 <blackh> oscarvarto: What's the package name?
22:03:07 <blackh> (i.e. what did you 'cabal install ..'?)
22:03:17 <oscarvarto> the package is Boolean
22:03:49 <oscarvarto> Maybe I have to use what blackh suggested
22:03:55 <oscarvarto> cabal install --root-cmd=sudo --global <packagename>
22:03:58 <blackh> oscarvarto: For that package, the import statement should be 'import Data.Boolean'
22:04:21 <blackh> oscarvarto: No - that's not needed.
22:04:47 <blackh> oscarvarto: It's best to install into the user, unless you really need to install a package system-wide.
22:04:51 <ivanm> @ask chrisdone what do you do when you accidentally kill the project buffer? (i.e. how to recreate it)
22:04:51 <lambdabot> Consider it noted.
22:04:53 <monochrom> don't use --global unless you know why and you accept the consequences
22:05:42 <ivanm> oscarvarto: the only time I would use cabal-install on a global basis is if you're setting up a workstation for students or something so that they all have the packages installed
22:05:48 <blackh> oscarvarto: If you typed just 'cabal install Boolean', and your source file says 'import Data.Boolean' then it will definitely work.
22:06:11 <ivanm> for personal development, cabal-install should be a per-user thing
22:07:03 <PatrickRobotham> Hi all, I'm having trouble install Yi. Terminfo won't install, it's complaining about "curses header could not be found".
22:07:13 <oscarvarto> when I use import Data.Boolean
22:07:24 <blackh> PatrickRobotham: What operating system are you using?
22:07:27 <ivanm> PatrickRobotham: you need the ncurses C library to be installed probably
22:07:37 <PatrickRobotham> black: Linux Mint
22:07:44 <sploop> Hello.  Is anyone in here familiar with functional reactive programming?  I'm working on building some discrete event simulation stuff and am interested in FRP, however (aside from some papers) I am not well-versed...I was hoping fom FRP gurus might be awake.
22:07:59 <blackh> PatrickRobotham: I don't know that one, but you probably need to type something equivalent to 'sudo apt-get install libncurses-dev'
22:08:10 <oscarvarto> I keep receiving an error message
22:08:21 <ivanm> blackh: mint is based off of ubuntu or debian (depending on the version)
22:08:26 <oscarvarto> There are files missing in the `Boolean-0.0.1' package
22:08:26 <oscarvarto> try running 'ghc-pkg check'
22:08:31 <Cale> Unless you really need the package to be available to all your users, I'd usually recommend against installing packages as root.
22:08:36 <ivanm> oscarvarto: what does "ghc-pkg check" say?
22:08:43 <blackh> sploop: I know a bit about FRP.
22:08:50 <PatrickRobotham> blackh: thanks!
22:09:03 <oscarvarto> I The following packages are broken: Boolean-0.0.1, etc
22:09:17 <Cale> (it's much easier to clean up dependency messes if you really need to by blowing away .ghc than having to uninstall and reinstall ghc)
22:09:18 <ivanm> Cale: well, if your distro has good Haskell support, then installing packages as root via your package manager would help automate package management
22:09:24 <ivanm> oscarvarto: sure, but _how_ is it broken?
22:09:32 <blackh> oscarvarto: It sounds to me like something got corrupted. Try typing this: cabal install --reinstall Boolean
22:09:41 <PatrickRobotham> Cale: How do you install packages if you're not root?
22:09:53 <Cale> PatrickRobotham: Just plain cabal install as user
22:09:57 <ivanm> PatrickRobotham: "cabal install xml" or something
22:10:01 <PatrickRobotham> Oh.
22:10:05 <ivanm> installs it to ~/.cabal rather than /usr/local
22:10:13 <blackh> PatrickRobotham: Note - libncurses-dev is an OS package, not a Haskell package.
22:10:14 <Cale> ~/.cabal and ~/.ghc
22:10:17 <PatrickRobotham> Cale: Ah, I thought you meant debian packages.
22:10:22 <Cale> ~/.cabal is just a cache of downloaded packages
22:10:27 <Cale> and your cabal settings
22:10:31 <sploop> blackh: have you applied any of the current implementations (reactive, yampa, reactive-banana etc.) to anything?
22:10:36 <ivanm> Cale: and where the actual libraries are installed
22:10:40 <Cale> ~/.ghc is where the actual installed stuff goes
22:10:41 <ivanm> (I think)
22:10:43 <Cale> (usually)
22:11:00 <ivanm> Cale: the actual libraries are in ~/.cabal/share/
22:11:03 <blackh> sploop: I've spent a lot of time on Yampa and have helped develop two commercial FRP systems.
22:11:08 <ivanm> ~/.ghc just has the package conf files
22:11:11 <Cale> You can do ghc-pkg list to see
22:11:18 <sploop> blackh: awesome.
22:11:30 <ivanm> make that ~/.cabal/lib
22:11:33 <Cale> oh, right
22:11:37 <blackh> sploop: The only problem is, I have to go in about 5-10 minutes.
22:11:43 <sploop> blackh: understood.
22:11:58 <Cale> The package binaries are under ~/.cabal yes
22:12:15 <blackh> sploop: But I can talk to you about FRP now and I'd be happy to talk at length later. It's a favourite subject of mine. :)
22:12:24 <byorgey> oscarvarto: sounds like something got messed up in your .ghc or .cabal directory
22:12:32 <byorgey> oscarvarto: try  cabal install --reinstall Boolean
22:12:36 <oscarvarto> blackh: I did "cabal install --reinstall Boolean" as you suggested but I keep receiving the same error
22:13:06 <byorgey> oh, I missed that blackh already suggested that
22:13:12 <blackh> oscarvarto: I think something is wrong. Do you mind erasing all your installed cabal packages and starting again?
22:13:25 <ivanm> oscarvarto: can you paste the output of ghc-pkg check for us somewhere?
22:13:32 <oscarvarto> No, I don't mind.
22:13:47 <oscarvarto> Sure
22:14:00 <sploop> blackh: i've been screwing around with discrete event simulation stuff, trying to build or work with a nice, purely functional (if possible) framework.  the primary problem domain is operations research, so I tend to be dealing with discrete rather than continous time.
22:14:03 <blackh> oscarvarto: In that case, I suggest you delete your ~/.ghc directory, then re-install the Boolean package with 'cabal install Boolean'.
22:14:15 <Cale> (this kind of thing is exactly why I recommend against installing packages as root ;)
22:14:28 <blackh> oscarvarto: Or talk to ivanm about 'ghc-pkg check' etc if you don't want to blow everything away.
22:14:29 <oscarvarto> I guess I have to use something else (not the irc channel), but what?
22:14:35 <ivanm> @hpaste
22:14:35 <lambdabot> Haskell pastebin: http://hpaste.org/
22:14:37 <ivanm> ^^
22:15:04 <sploop> blackh:  read conal elliot (sp?) series on FRP, as well as houdak, and just started digesting yampa/lambda arcade.  seems the FRP state-of-the art has drifted towards arrows (which I am new to as well).
22:15:39 <oscarvarto> I don't mind blow everything
22:15:41 <blackh> sploop: I've been working on video games, and I've figured out that FRP is very useful for embedded event-driven software as well. In fact, FRP is useful for any situation where mainstream programmers would use the observer pattern.
22:15:48 <oscarvarto> I just want it to work
22:15:51 <sploop> blackh: ah....yes..
22:16:12 <blackh> sploop: Arrows are not necessary for FRP, but they appear to have some compelling optimization advantages.
22:16:33 <blackh> sploop: I know nothing at all about operations research.
22:16:42 <sploop> blackh:  I built a rudimentary devs framework inspired by game design, using the observer pattern.  however, it's a bit ugly to me.
22:17:03 <blackh> sploop: The simplest FRP model, IMO, is an applicative one.
22:17:11 <sploop> blackh:  i.e. fran?
22:17:51 <sploop> blackh:  define behaviors as fns of time -> 'a, etc. ?
22:18:12 <blackh> sploop: Well, there are two basic views of time: the Conal Elliot view where your events are seen as a lazy list of pairs [(t, a)], and the Yampa model where only one event is handled by the implementation at a time.
22:18:29 <blackh> All my work has been the second style.
22:18:59 <oscarvarto> blackh: I tried everything before. Should I delete /root/.cabal too?
22:19:10 <blackh> sploop: FRP is essentially a way of taking all the suckage out of the observer pattern.
22:19:25 <oscarvarto> (i tried as root, as user, with cabal install as user, with sudo cabal install....)
22:19:30 <sploop> blackh:  that's kind of what I thought, and what's started attracting me to it
22:19:32 <monochrom> /root/.cabal shouldn't matter unless you're root
22:20:09 <blackh> sploop: I think FRP could completely revolutionize the industry, when the industry actually notices it. :)
22:20:41 * ddarius is pretty damn sure FRP will not "revolutionize" the industry.
22:20:43 <blackh> oscarvarto: Well, you don't really want to have a /root/.cabal directory, but it won't matter for your purpose, if you are not logged in as root.
22:20:47 <sploop> blackh:  you mentioned optimization opportunities in yampa that were not present in classic frp
22:20:51 <monochrom> "sudo cabal install" results in installing things for root's personal enjoyment only
22:21:18 <monochrom> in root's home directory, /root
22:21:39 <blackh> sploop: Well, there are two advantages with using arrows: One is that the syntax can be a little nicer, and the other is that it's at least partially possible to "recover" the underlying graph, which can help with optimization.
22:22:04 <sploop> blackh:  are you implicitly defining a dependency graph via arrows then?
22:22:05 <ivanm> oscarvarto: check /usr/local though...
22:22:27 <monochrom> /usr/local not touched unless "cabal install --global"
22:22:54 <blackh> sploop: The problem with Conal Elliot's reactive was that it was a little ambitious and I don't think he quite managed to get it working completely.
22:24:10 <blackh> sploop: Yeah. Really the optimization is potential, since nobody has actually achieved it yet. The point is that in theory you should be able to remove huge amounts of implementation overhead statically.
22:24:26 <blackh> sploop: Still - it's early days in FRP and speed is not the top priority.
22:24:29 <ivanm> monochrom: well, he did say he did it as root; wasn't sure if he tried --global or not
22:24:51 <monochrom> beginners probably never heard of "--global"
22:25:09 <monochrom> or the config file either
22:25:12 <sploop> blackh:  From your experience, is the optimization necessary at this point? Or is it fast enough for the problem domains you were tackling?
22:26:08 <oscarvarto> I'm using Archlinux
22:26:25 <blackh> sploop: One of the commercial FRP systems I am involved in is pretty advanced now. It's for iPwn Studios. One day it will be released, but in what form, I can't say.
22:26:40 <blackh> sploop: For a video game, FRP speed is very important.
22:26:45 <sploop> blackh: I understand we're probably coming up on the 5-10 minute mark too btw.  appreciate the conversation.
22:26:54 <sploop> blackh:  that's what I figured.
22:26:56 <oscarvarto> I erased .ghc as suggested. But seems ~/.cabal is the right place to
22:27:08 <oscarvarto> look at.
22:27:31 <oscarvarto> I modified ~/.cabal/config this way:
22:27:45 <sploop> blackh:  got to manage entity behavior, pathfinding, rendering, etc.  effeciently
22:27:51 <oscarvarto> user-install: False
22:28:00 <oscarvarto> root-cmd: sudo
22:28:09 <blackh> sploop: I'd better go, or my wife will kill me. I ought to be on here a bit over the next while.
22:28:12 <amstan> hey
22:28:14 <monochrom> oh, then ivanm is right, /usr/local/lib
22:28:37 <amstan> someone brought lambdabot in a channel i op, problem is that we already have a bot that responds to @ commands in there already
22:28:41 <oscarvarto> and erased all -- (comments) under install-dirs global
22:28:47 <amstan> it's a little annoying at this point
22:28:48 <ivanm> oscarvarto: if you're using archlinux, why not just use their packages?
22:29:02 <byorgey> amstan: which channel? talk to Cale
22:29:11 <monochrom> and moreover /usr/local/lib/ghc-version/package.conf.d
22:29:12 <amstan> byorgey: #aichallenge
22:29:14 <sploop> blackh:  no problem.  don't want to cause you to be a victim of spousal abuse.  I know a bit more than I did before :)
22:29:33 <Cale> @part #aichallenge
22:29:43 <amstan> i don't mind lambdabot, i'm just looking if there's a way to change the character it responds to
22:29:52 <monochrom> unlikely that archlinux has every package under the sun
22:29:56 <ivanm> amstan: I don't think on a per-channel basis
22:30:07 <amstan> ivanm: aww, ok
22:30:10 <ivanm> monochrom: no, but will he need every package under the sun? and if not, it's meant to be easy to add
22:30:25 <ivanm> monochrom: though they come close to having every package: they include packages for other linux distros, etc. :s
22:30:32 <amstan> Cale: well, thanks
22:30:37 <sploop> ugh not used to web irc client.
22:30:42 <monochrom> we need every package under the sun.
22:30:58 <oscarvarto> ivanm: I tried Archlinux packages, but I can't import Boolean.Algebra
22:31:00 <monochrom> I mean, otherwise hackage wouldn't exist to begin with
22:31:12 <ddarius> You mean every package under the oracle.
22:31:18 <monochrom> hahaha
22:31:40 <ivanm> oscarvarto: which package is that from?
22:32:06 <ivanm> oscarvarto: seeing as how hayoo can't find that module makes me suspicious that it doesn't exist...
22:33:01 <oscarvarto> http://repetae.net/recent/out/Boolean.html
22:34:10 <monochrom> and it is on hackage?
22:34:53 <oscarvarto> I installed it with cabal install Boolean
22:35:07 <monochrom> that's different. http://hackage.haskell.org/package/Boolean/
22:35:13 <oscarvarto> I tried also (as root) # pacman -S haskell-boolean
22:35:21 <monochrom> Data.Boolean and no Boolean.Algebra, no fuzzy
22:36:15 <monochrom> not on hackage at all. no amount of cabal install will help
22:36:19 <Saizan> yeah, J. Meacham doesn't like cabal so he doesn't put his stuff on hackage
22:36:28 <ivanm> Saizan: any idea why?
22:36:36 <monochrom> and most likely not on pacman therefore
22:36:37 <oscarvarto> monochrom: http://repetae.net/recent/out/Boolean.html
22:36:53 <monochrom> yes I know the url
22:36:56 <oscarvarto> I can't understand why official documentation is wrong then
22:37:13 <oscarvarto> to use properly:
22:37:13 <oscarvarto>  import Boolean.Algebra
22:37:13 <oscarvarto>  import Prelude hiding((&&),(||),not,and,or,any,all)
22:37:21 <Saizan> ivanm: lots of the discussions on the matter in the mailing lists, i don't remember exactly
22:37:45 <ivanm> oscarvarto: he's talking about a different Boolean than the one on hackage
22:38:09 <monochrom> it is not on hackage. "cabal install Boolean" gets you an unrelated package. "pacman" too.
22:38:19 <Saizan> oscarvarto: you've to download the sourcens from here http://repetae.net/recent/src/Boolean/Boolean.tar.gz directly
22:38:22 <ivanm> oscarvarto: if you want to use Boolean.Algebra, you'll have to manually download that, build it and install it
22:38:28 * ivanm guesses it will use a makefile
22:38:33 <ArchGT> oscarvarto: what about cabal install boolean?
22:38:49 <monochrom> "boolean" does not exist on hackage
22:38:58 <Saizan> "This is not the boolean you're looking for"
22:39:13 <monochrom> so much for meaningful names
22:41:59 <ArchGT> oscarvarto: there is a haskell-boolean in aur
22:42:09 <oscarvarto> I tried that
22:42:13 <ivanm> ArchGT: it's a different package!
22:42:24 <ArchGT> o.0
22:42:25 <ivanm> haskell-boolean corresponds to Boolean on hackage, which isn't what oscarvarto is after
22:42:34 <ivanm> what he wants isn't cabalised
22:43:57 <oscarvarto> Thanks a lot. My wife is not killing me but I should be with her now. It's late. Tomorrow I got to work...
22:44:30 <ivanm> cya oscarvarto
22:44:44 <oscarvarto> I believe I have to learn how to manually download that, build it and install it
22:44:54 <oscarvarto> as ivanm suggested.
22:44:57 <ivanm> yup
22:45:02 <ivanm> if you really need to use that for some reason
22:45:17 <monochrom> no makefile either
22:45:19 <ivanm> oscarvarto: note: that will make it harder for you to release code using that package
22:45:33 <ivanm> monochrom: what, he expects you to do direct GHC and Haddock invocations? :o
22:45:40 <ivanm> that's what Cabal is _for_!
22:46:01 * ivanm has never worked out how to call haddock itself, and has previously created a fake .cabal file just to use "cabal haddock"
22:46:02 <oscarvarto> Thanks a lot. It has been a frustrating start
22:46:28 <monochrom> I guess he expects you to untar under your working directory and that's it. (later on, ghc will find itself compiling it by dependency chasing)
22:46:43 <ivanm> monochrom: oh, rather than separate libraries?
22:46:49 <ivanm> that sounds really maintainable...
22:47:03 <monochrom> right, not meant to be "ghc-pkg register"ed at all
22:49:59 <monochrom> it is actually fine if: (A) you are not keen on sharing it among many many projects of yours; and/or (B) you actually believe in locking a project of yours with a version of this package for stability purposes
22:51:34 <ivanm> monochrom: and believe there are no bugs/security holes to worry about
22:51:41 <monochrom> it certainly solves the a large class of the diamond butterfly problems
22:51:52 <ivanm> which is why distro maintainers hate bundled libraries (not to mention disk space)
22:52:32 <monochrom> security holes is a non-concern for a mere boolean algebra library
22:53:16 <monochrom> bugs belongs to the "after a while, you actually don't want the bugs to be fixed, because you now rely on their presence" stability purpose
22:53:50 <ivanm> heh, yeah
22:53:53 <ddarius> The harbinger of the Apocalypse.
22:59:07 <zeiris> Oh my god, I found some awesome information on using Uniplate and it's so easyeeeeeeeee :D:DDDD
22:59:19 <ddarius> Uniplate is simple.
22:59:49 <zeiris> I can't believe I wrote a Core Erlang AST traversal by hand - if only I'd known about this a year ago!
23:00:00 <zeiris> This is amazing.
23:00:26 <ddarius> zeiris: I recommend not doing anything to avoid that situation.
23:02:18 <zeiris> ddarius: eh? I don't follow.
23:04:00 <monochrom> not (doing anything to avoid that situation)? (not doing anything) to (avoid that situation)?
23:04:33 <zeiris> Ahhh.
23:04:34 <zeiris> Heh.
23:05:34 <monochrom> next: on to Englist AST traversal by hand...
23:06:32 <zeiris> I'm actually kind of tempted to post a blog post about the tool I wrote to do it. The actual problem solved is fairly simple, but the fact that I hacked it together over several late nights when starting a new job, and could rely on the typesystem to keep bugs out was pretty amazing.
23:07:04 <zeiris> It was a ridiculously useful use of Haskell, which I couldn't have done in any other language. And was very "real world", given the time + sleep constraints.
23:07:58 <zeiris> Then again, "avoid success at all costs" suggests I just ignore the stupid people claiming Haskell isn't "real world" enough.
23:08:40 <companion_cube> what is it doing?
23:09:04 <zeiris> Extracting  module/function call dependencies from code and graphing via graphviz, and later protovis.
23:09:15 <companion_cube> oh, nice
23:10:00 <zeiris> Output: http://amtal.github.com/erlang-templates/misultin/xr.html
23:12:26 <companion_cube> neat!
23:12:42 <companion_cube> reminds me (graphically) of gource
23:13:36 <zeiris> Heh, I hacked together a uniplate one-liner in the shell that does pretty much the same thing as my laborious code :D
23:14:25 <companion_cube> uniplate looks like magic to me ôO
23:14:48 <bfig> how would you describe the generic fold for the fixpoint of a polynomial functor?
23:15:04 <bfig> (i'm not sure that is even correctly said)
23:15:51 <bfig> ie, i have a fixpoint equation for a datatype  x = p(x) with p a polynomial in x, how do you define the generic fold over that polynomial?
23:16:24 <ivanm> zeiris: I take it protovis is a javascript-based visualisation tool?
23:19:12 <zeiris> ivanm: yeah, it's a fairly declarative/functional library for building arbitrary visualizations. It's pretty unique in that instead of giving you a bunch of primitive graph types to work with, it gives you drawing primitives to make your own from input data.
23:19:27 <ivanm> hmmmm.....
23:19:45 <zeiris> Support for IE is I think borderline non-existat, so it's hard to justify in commercial settings. Really great for exploration/hackery/internal tools, though.
23:20:16 <ivanm> which language were you getting the call graph from?
23:20:31 <zeiris> Erlang. (Compiled to CoreErlang and parsed via the package on hackage.)
23:20:41 <ivanm> *nod*
23:21:37 <kmc> using Haskell code to process Erlang code and visualize the result with Javascript
23:21:38 <kmc> :D
23:21:57 <zeiris> A semi-recent version of the Haskell code: https://github.com/amtal/erlang-templates/blob/master/xr/xr.hs
23:22:43 <zeiris> I've also used Haskell+QuickCheck to test an Erlang system. (Which eventually didn't work out due to the correctness measure of the system being "does it work with everyone elses broken code?")
23:25:27 <kmc> it's nice to know all these tools and be able to use them together
23:30:04 <ivanm> anyone know if Matthias Bartsch hangs out around here? (erdwolf on github) ?
23:47:36 <ddarius> :t \alg -> alg . fmap alg . out
23:47:37 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
23:47:38 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
23:47:38 <lambdabot>       Expected type: Mu f -> f (f b)
23:48:05 <ddarius> :t let fold alg = alg . fmap (fold alg) . out in fold
23:48:06 <lambdabot> forall (f :: * -> *) b. (Functor f) => (f b -> b) -> Mu f -> b
