00:14:50 <Blkt> good morning everyone
00:15:14 <elliott> It's acceptable to use unsafePerformIO to get a top-level FunPtr, right?
00:15:29 <elliott> I never free this one (it's a constant).
00:15:38 <ddarius> Why do you need a top-level FunPtr?
00:16:17 <elliott> ddarius: To pass to foreign functions. I could just create it every time I call them, but that's an unnecessary allocation per call *shrug*
00:16:20 <yitz> elliott: give in a NOINLINE pragma
00:16:32 <elliott> yitz: Well, yes.
00:30:22 <qnikst> hello
00:31:08 <qnikst> I have following code: result <- (try $ action ht m) :: IO (Either SomeException Responce) >>= \x -> case x of Right a -> ... ; Left _ -> ...;
00:31:37 <qnikst> but when I'm compiling it  I get     Ambiguous type variable `e' in the constraint:
00:31:37 <qnikst>       `Exception e'
00:31:38 <qnikst>         arising from a use of `try'
00:31:55 <qnikst> can smbd explain why it happens?
00:34:40 <mah_b> @type try
00:34:40 <lambdabot> Not in scope: `try'
00:34:55 <qnikst> try from Control.Exception
00:35:11 <mah_b> @type Control.Exception.try
00:35:12 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
00:37:00 <Quantumplation> x :: (a -> a -> a) -> a -> a, is there such a way to curry x such that you pass it (a->a), and it curries THAT function with a?  So, for example, to curry x in some way y that y :: (a -> a) -> a -> a?  Not sure how to word this clearly.
00:37:22 <Quantumplation> er, that didn't line up exactly, since i started rephrasing it half way through
00:37:54 <mah_b> qnikst: maybe http://stackoverflow.com/questions/431527/ambiguous-type-variable-error-msg?
00:38:38 <Quantumplation> but essentially... x :: (a -> a) -> a -> a, curry so that you can do y * 1 2, and it would replace * with 4*?
00:38:52 <Quantumplation> er, minus the last 2 on the y
00:39:31 <Quantumplation> nevermind, i'll come back when I can properly phrase/communicate my question >.<
00:40:05 <hpaste> Harishankar pasted “Check if string is integer or not” at http://hpaste.org/53191
00:40:53 <vharishankar> I cannot believe I wrote that on my own...
00:41:47 <vharishankar> Still not 100% sure if it is "correct" though it appears to work.
00:42:07 <Halabund> playing on tryhaskell.org :)
00:42:55 <vharishankar> Halabund: not quite playing. But even though I wrote that, I am confused about WHY it works...
00:44:37 <elliott> Is it safe to castFunPtr :: FunPtr (... -> IO CInt) -> FunPtr (... -> IO ())? (Where the two ...s are identical.)
00:45:06 <vharishankar> I think I meant "if the head of the list is a number then check if the tail is also a number, but if not return False". Still, it's my first major break from iteratively analyzing the problem
00:51:15 <aspiers> hi all, any idea why cabal install template-haskell-2.6.0.0 fails with 7.0.2 on Fedora 15? "Language/Haskell/TH/PprLib.hs:55:10: Illegal instance declaration for `Show Doc'"
00:51:52 <aspiers> unfortunately I'm still a Haskell newbie :(
00:52:19 <yitz> vharishankar: i think it works, except it will error out if it is fed an empty string. Add another case for that.
00:52:36 <vharishankar> yitz: thanks.
00:53:30 <hpaste> Harishankar annotated “Check if string is integer or not” with “Check if string is integer or not (annotation)” at http://hpaste.org/53191#a53192
00:55:28 <yitz> vharishankar: ah, ok. i thought you would just say False if it's empty. But sure, you can give it its own error message if that's appropriate.
00:55:36 <vharishankar> I now begin to understand the concept of using recursion instead of iteration.
00:56:03 <vharishankar> yitz Thanks. I wanted to start writing a simple calculator application, but realized I would need to master string parsing first
00:58:13 <yitz> vharishankar: a few small style points: you never need to write "== True"; just leave that our, the value is already a boolean.
00:58:42 <Halabund> I'm on tryhaskell.org , trying the language for the first time.  It says, "Note that a tuple is different to a list because you can do this: (1,"George")"  I didn't quite get this bit, what's special about (1,"George")?
00:58:47 <qnikst> mah_b|afk: thanks for link, but I've found that my problem was in other place
00:58:48 <yitz> vharishankar: if you write "otherwise = if ..." that means you really wanted to add another case to the guards instead.
00:58:54 <vharishankar> yitz, OK
00:59:33 <Halabund> Is it about the type of the items inside?
01:00:00 <yitz> vharishankar: usually in haskell we avoid things like "length st == 1", because it will force reading all the way to the end of st if it is very large.
01:00:21 <vharishankar> yitz thanks.
01:00:40 <yitz> vharishankar: if you are doing this with functions, you are better off using combinations of the functions null, drop, and not instead.
01:00:43 <Halabund> OK, I got that
01:01:01 <Halabund> What is the underlying data structure of a "list"?  Is it a linked list?
01:01:21 <yitz> vharishankar: however, this sort of thing would usually not be done with functions, but rather with pattern matching, once you learn about that.
01:01:22 <vharishankar> yitz, I will figure that one out.
01:01:32 <ibid> Halabund: singly linked list, for the most part
01:01:50 <Halabund> ibid: thanks!
01:02:10 <vharishankar> yitz: isn't pattern matching part of functions?
01:02:38 <yitz> vharishankar: well it's a kind of syntax you can use when defining functions, yes.
01:03:09 <ibid> vharishankar: not really part.  they're different things, though they are often used together
01:03:33 <yitz> ibid: well yeah, that syntax can also be used in other contexts, right.
01:03:36 <vharishankar> Ok, it's like f 1  = 1 and after that typing f x = (f x)  + 1
01:03:40 <mah_b> @type all
01:03:41 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
01:04:05 <yitz> vharishankar: that's also important - multiple equations for a function.
01:04:10 <mah_b> @type all isNumber
01:04:11 <lambdabot> [Char] -> Bool
01:04:18 <vharishankar> Any examples of pattern matching outside functions?
01:04:31 <ibid> yitz: well, pattern matching really "is part of" cases, but there's widely used (and useful) syntactic sugar at function definiton time :)
01:04:57 <yitz> vharishankar: pattern matching is something like f (c:cs) = "The first character is " ++ [c] ++ " and the rest are " ++ cs
01:05:11 <ibid> > case [1,2] of 1:_ -> 42 ; _ -> 69
01:05:13 <lambdabot>   42
01:05:18 <ibid> vharishankar: ^^
01:05:47 <yitz> vharishankar: you usually need to combine that with multiple equations, as you said, so that you can define what happens when various patterns match.
01:06:11 <vharishankar> yitz, thanks...
01:07:10 <vharishankar> I need to get my head wrapped around the syntactical elements of haskell because often I understand the concept but not necessarily the syntax to do it
01:07:29 <vharishankar> Most tutorials don't seem to have a page dedicated to syntax.
01:07:33 <yitz> vharishankar: right the two go in parallel :)
01:08:25 <yitz> vharishankar: did you see this:
01:08:28 <yitz> @where lyah
01:08:29 <lambdabot> http://www.learnyouahaskell.com/
01:08:31 <Philippa> vharishankar: read the Report directly?
01:08:31 <vharishankar> yitz: yes of course. Another thing is learning how two things that fetch the same result aren't necessarily the same.
01:08:53 <erus`> does GHC core language allow multiple function definitions? eg    f 1 = "one"    f 2 = "two"
01:08:55 <vharishankar> I am going through lyah
01:08:55 <Philippa> (it's not ideal because the way it handles operators is a bit messy, but even so)
01:09:16 <yitz> vharishankar: great!
01:09:37 <vharishankar> Philippa: I will once I am more comfortable with the concepts.
01:10:05 <yitz> Philippa: yeah that's how we learned haskell in the old days. the Report together with the Gentle Introduction. i still remember the pain.
01:10:16 <ibid> what pain? :-)
01:10:19 <vharishankar> erus` yes
01:10:25 <ibid> (i did it that way as well:)
01:10:35 <yitz> ibid: well actually it was fun, but it sure took a lot of hard work.
01:10:46 <ibid> yeah, true
01:11:01 <ibid> it took me years of not-so-much-hard-work to get a hang of it
01:11:06 <Saizan> mh, maybe that would have worked out better than YAHT for me
01:11:12 <elliott> Is the overhead of Foreign.Concurrent.newForeignPtr over Foreign.newForeignPtr significant?
01:11:24 <vharishankar> It's actually easier for people totally new to programming I figure.
01:11:35 <ibid> of course, the language and libraries were simpler in those times
01:11:52 <vharishankar> But for those entrenched in the procedural programming it's a pain to re-condition
01:12:11 <Saizan> yeah, i couldn't understand how to use parentheses because i was too used to C-like syntax for function application
01:12:30 <yitz> vharishankar: i think you're right about that
01:12:32 <Saizan> a lisp tutorial solved that
01:13:13 <A1kmm> It was lazy-by-default that me the longest to used to.
01:13:15 <kmc> @where haskell cheat sheet
01:13:15 <lambdabot> http://haskell.org
01:13:16 <vharishankar> yitz: actually the basics are fine. It's when you need to solve something on your own that the brain begins to creak :-P
01:13:19 <kmc> derp
01:13:21 <kmc> @google haskell cheat sheet
01:13:23 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
01:13:24 <lambdabot> Title: Haskell Cheat Sheet
01:14:26 <Ferdirand> erus`: I thought core did not even allow function arguments, just lambdas
01:14:27 <yitz> vharishankar: yes, but once you get past that, the world looks brighter than it ever did before
01:15:22 <vharishankar> yitz: I am usually a "get things working" type of person. Haskell was a way to freshen my programming perspectives.
01:15:55 * ddarius needs to reread the Synthesis OS paper for the ILL and FLL loop parts.
01:16:36 <quicksilver> erus`: no, in core that would be f = case x of 1 -> "one"; 2 -> "two"
01:16:52 <quicksilver> except that 1 and 2 aren't really constructors but I assume that wasn't your point.
01:16:53 <erus`> cool
01:17:20 <erus`> f = \x -> case ... ?
01:17:30 <ibid> quicksilver: are you missing a lambda?
01:17:34 <quicksilver> yes
01:17:35 <quicksilver> :)
01:17:42 <ibid> :)
01:19:49 <aspiers> ugh, Cabal hates me
01:21:10 <yitz> aspiers: it may seem that way, but really Cabal means it for your own good
01:21:27 * hackagebot happindicator 0.0.2 - Binding to the appindicator library.  http://hackage.haskell.org/package/happindicator-0.0.2 (AndrewMiller)
01:26:13 <aspiers> yitz: I had to do 'cabal install Cabal' twice to get 'cabal install time' to stop complaining "The package requires Cabal library version -any && >=1.6 but no suitable version is installed"
01:26:34 <aspiers> I don't know why it couldn't follow the dependency itself
01:27:18 <aspiers> and the first time it claimed to install Cabal OK, but then complained "Cabal-1.10.2.0-808f698dae0dee2e057ac633d8d7ad88 is unusable due to missing or recursive dependencies"
01:27:31 <aspiers> even though the two dependencies listed were installed fine
01:28:40 <aspiers> additionally there were bugs with old-time-1.0.0.7 and template-haskell both failing to install
01:29:33 <aspiers> This is my first experience with building software in Haskell and it's been pretty horrific - but I'm going to put it down to very bad luck, I'm sure it's a great language :-/
01:31:31 <Saizan> well, you're not meant to build a template-haskell version that differs from the one your ghc is shipped with
01:31:47 <Saizan> also, it's better to learn a bit about cabal: http://www.vex.net/~trebla/haskell/sicp.xhtml
01:32:16 <aspiers> Saizan: I didn't want to, but the dependency tree of the software I'm trying to build (git-annex) required it
01:32:27 <aspiers> Saizan: I'll check out that link, thanks
01:32:39 <Saizan> aspiers: you'd better use a differnt version of ghc then
01:34:14 <aspiers> Saizan: why? template-haskell.cabal has build-depends: base >= 4.2 && < 5, and I have base-4.3.1.0
01:35:50 <aspiers> surely if it clashed with my version of ghc (7.0.2) then the .cabal file would encode that dependency?
01:36:01 <Saizan> template-haskell is special because it has to match stuff that built into the compiler itself
01:36:03 <aspiers> rather than just letting the install proceed and then causing mysterious errors down the line?
01:36:28 * hackagebot happindicator 0.0.3 - Binding to the appindicator library.  http://hackage.haskell.org/package/happindicator-0.0.3 (AndrewMiller)
01:37:04 <Saizan> "surely" is too optimistic here :)
01:37:25 <aspiers> Saizan: well, that would seem to me to be the sensible approach
01:37:53 <aspiers> Haskell's been around for ages, so I'm assuming cabal is pretty mature by now
01:38:06 <ibid> cabal's way younger than haskell
01:38:08 <Saizan> cabal is fairly recent
01:38:27 <Saizan> template-haskell is fairly recent too, older than cabal though
01:38:42 <aspiers> so you are saying that with a simple 'cabal install foo', it won't necessarily spot crucial dependency issues?
01:38:44 <kmc> if you ask a cabal question there is a decent chance dcoutts will appear and answer it
01:39:45 <Saizan> it works with the info it has, but e.g. .cabal files might be incorrect or have incomplete information
01:39:49 <ibid> aspiers: that would depend on how well the dependencies are marked
01:39:52 <kmc> in my experience cabal will just refuse to upgrade the packages like template-haskell and base which come from ghc
01:40:01 <aspiers> cabal refused to upgrade base
01:40:05 <aspiers> but not template-haskell
01:40:11 <aspiers> for me, I mean
01:40:30 <aspiers> ahah, I think I realised a problem
01:40:58 <ibid> i think i argued against cabal when it was being proposed
01:41:03 <ibid> not very forcefully but still
01:41:06 <aspiers> cabal install foo --prefix=~/local will install all the recursive dependencies to ~/local too, right?
01:41:26 <dcoutts> ibid: what do you think in retrospect?
01:42:06 <vharishankar> I'm breaking my head, but is there any way to change this http://hpaste.org/53191 without using length?
01:42:20 <quicksilver> cabal has taught me that optional libraries are a mistake and everyone should just use GHC, base, and reinvent any other wheels they need ;)
01:42:31 <aspiers> hah :)
01:42:57 <quicksilver> vharishankar: yes. Use pattern matching.
01:43:28 <quicksilver> vharishankar: isInteger "" = error "empty string"; isInteger [c] = isNumber c;
01:43:59 <ibid> dcoutts: the main issues i was worried about exist.  the sicp link above mentions at least one of them.  but it's been competently implemented, as far as that goes :)
01:44:08 <ibid> dcoutts: and i believe it's been net positive for haskell
01:44:21 <vharishankar> quicksilver I fixed that one (for nul strings)
01:44:43 <kmc> ibid, what was your proposed alternative (if any)?
01:45:00 <kmc> aspiers, btw, did someone mention cabal-dev already?
01:45:05 <quicksilver> vharishankar: also "if isInteger num == True then" is more simply written as "if isInteger num then"
01:45:12 <quicksilver> vharishankar: I'm not really sure what else you are asking?
01:45:13 <aspiers> kmc: no, thanks
01:45:19 <kmc> it lets you set up isolated universes of packages
01:45:20 <yitz> ibid, dcoutts: i think cabal is very important. there are still some crucial improvements that need to be made.
01:45:25 <kmc> it won't solve all your problems but might help
01:45:27 <vharishankar> quicksilver: point taken. Yes, I fixed that one.
01:45:31 <dcoutts> yitz: certainly
01:45:37 <dcoutts> yitz: the latter I mean
01:45:48 <ibid> kmc: i believed (and still believe, so far as it goes) that packages should be installed using the distribution's tools.  the main counterargument was windows, and it still applies to an extent
01:45:50 <yitz> ibid, dcoutts: but certainly we would never get there if all the work so far hadn't been done
01:45:55 <aspiers> kmc: sounds like rvm gemset. as a complete newbie I was hoping to avoid that level of complexity
01:46:01 <aspiers> kmc: all I want to do is install git-annex :-/
01:46:18 <ibid> kmc: but note, i've been a debia developer longer than i've known haskell :)
01:46:24 <quicksilver> ibid: it is possible to hold that view and still believe cabal has a place.
01:46:26 <ibid> *debian
01:46:29 * hackagebot digestive-functors 0.2.0.0 - A general way to consume input using applicative functors  http://hackage.haskell.org/package/digestive-functors-0.2.0.0 (JasperVanDerJeugt)
01:46:31 * hackagebot digestive-functors-happstack 0.1.1.0 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.1.1.0 (JasperVanDerJeugt)
01:46:33 * hackagebot digestive-functors-snap 0.1.1.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.1.1.0 (JasperVanDerJeugt)
01:46:36 <ibid> quicksilver: 11:58  <ibid> dcoutts: and i believe it's been net positive for haskell
01:46:41 <quicksilver> ibid: cabal is primarily a tool for building and specifying package dependencies
01:46:52 <quicksilver> ibid: it's not necessarily the best way to actually install packages.
01:47:06 <quicksilver> AFAIK, cooperating/supporting distribution packages has always been a goal
01:47:07 <yitz> quicksilver: is its place to remind you that you should re-invent your own wheels whenever you forget that?
01:47:14 <dcoutts> ibid: yeah, and we did design the format to make translation possible, and there are tools that do it semi-automatically.
01:47:17 <quicksilver> yitz: ;)
01:47:40 <ibid> dcoutts: yeah, i know.  i believe i had something to do with the choice of the .cabal file format :)
01:47:53 <dcoutts> ibid: but it has not really caught on. The people making the distro packages use those tools for their own processes, but it's never caught on.
01:48:04 <dcoutts> caught on with users I mean
01:48:08 <ibid> true
01:48:43 <ibid> the main issue is, i believe, that distro packages should have distro competent maintainers, but there are too many haskell packages to do that well
01:48:45 <dcoutts> the cabal-install tool was then originally intended for hackers, not end users who'd get their packages from their distro
01:49:01 <dcoutts> but the gap between what's on hackage and what's in the distro remains huge
01:49:19 <dcoutts> ibid: right, distro packages need appropriate QA
01:49:19 <ibid> dcoutts: in any case, i'm not that interested in debating cabal any more.  it's won already :-)
01:49:20 <yitz> i've given up on the idea of using distro packages. i now just use cabal manually. actually mostly cabal-dev nowadays.
01:49:49 <dcoutts> ibid: I'm not against distro packages, on the contrary
01:50:06 * dcoutts wrote one of the cabal -> native tools
01:50:51 <dcoutts> I think part of the problem is that the people packaging the distros don't encourage end users to use their native package generation tools
01:51:06 * aspiers reads the end of http://www.vex.net/~trebla/haskell/sicp.xhtml
01:51:07 <dcoutts> because they want to just provide the end users with pre-prepared packages
01:51:08 <kmc> ibid, yeah, I'd prefer a world where I can install everything through dpkg
01:51:24 <kmc> there's already some cabal->dpkg tool but I haven't tried it
01:51:25 <aspiers> so it looks like my problems are probably due to mixing and matching cabal with Fedora rpms
01:51:39 <aspiers> hrm
01:51:48 <ibid> dcoutts: being a DD, i'm wary of having people install debs they created themselves, especially if it was created by the use of a tool they don't understand
01:51:54 <dcoutts> but of course that's impossible, so at least some advanced users need to be able to generate their own native packages
01:51:57 <ibid> dcoutts: so i understand that very well
01:52:20 <ibid> dcoutts: but yeah, the world's not perfect and we deal with it :)
01:52:24 <dcoutts> ibid: right, most end users will just mess it up, but e.g. people maintaining a big deployment of machines
01:52:31 <ibid> true
01:52:46 <dcoutts> they want to manage it via deb, because that's a sensible thing to do
01:52:59 <dcoutts> and not try to cabal install from source on each box or whatever
01:53:04 <ibid> dcoutts: yeah, and they should be able to become competent
01:53:15 <dcoutts> and such users don't even know that cabal2deb exists, apparently
01:53:26 <aspiers> that page says "Fedora, Debian, and Ubuntu packages for GHC libraries do not call ghc-pkg --global register. They modify the metadata themselves and completely circumvent the safety check."
01:53:31 <aspiers> Why can't that be fixed?
01:53:46 <dcoutts> aspiers: that's a feature, not a bug.
01:53:49 <ibid> dcoutts: one of the issues is that sysadmins aren't necessarily interested in haskell at all
01:53:58 <vharishankar> http://hpaste.org/53193
01:54:04 <vharishankar> Is that a better version?
01:54:09 <aspiers> dcoutts: sounds like a bug in those distros to me
01:54:20 <dcoutts> aspiers: no it works fine
01:54:29 <ibid> dcoutts: and thus will learn haskell tools only if there are enough users that they get enough haskell related tickets
01:54:33 <aspiers> dcoutts: so that webpage is inaccurate?
01:54:56 <dcoutts> aspiers: no it's accurate, what you misunderstand is that what those distros are doing works fine.
01:55:12 <ibid> our university admins had a lot of trouble getting gtk2hs installed in our windows machines a couple of years ago.  and i understand they didn't get the platform up and running at all
01:55:37 <ibid> dcoutts: so the article is misguided?
01:55:37 <dcoutts> ibid: sure, but there was one at the Haskell implementors workshop complaining about these management issues and was unaware (or had been unable to get cabal2deb to work)
01:55:48 <ibid> dcoutts: ah
01:56:07 <ibid> (the platform was for this fall semester)
01:56:17 <dcoutts> ibid: on windows?
01:56:17 <aspiers> dcoutts: works fine as long as you only need to install cabal packages which are provided by the distro?
01:56:29 * hackagebot digestive-functors-blaze 0.2.1.0 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.2.1.0 (JasperVanDerJeugt)
01:56:30 <ibid> dcoutts: on windows, yes
01:57:06 <dcoutts> ibid: hmm, feel free to forward any emails from the sysadmis to the platform list.
01:57:07 <ibid> dcoutts: the teacher in question ended up setting up virtual machine images with a linux distro and the platform preinstalled
01:57:18 <dcoutts> ibid: do you know what they found hard?
01:57:23 <ibid> dcoutts: i'll tell the teacher that
01:57:33 <ibid> dcoutts: i've just been following from the side. i'm not directly involved
01:57:55 <dcoutts> it'd be interesting to hear what it is about the windows installer not usable in their uni context
01:58:15 <ibid> dcoutts: i'll see if i can get some info to you at some point
01:58:34 <dcoutts> aspiers: sorry I'm now not quite sure what the context of your question is
01:58:58 <aspiers> dcoutts: I'm talking about http://www.vex.net/~trebla/haskell/sicp.xhtml
01:59:08 <aspiers> dcoutts: the final section in particular
01:59:39 <quicksilver> vharishankar: better, yes. Better still to use pattern matching instead of head.
01:59:48 <aspiers> dcoutts: suggests that interleaving install order can completely break  a system (or at least, a user account)
01:59:58 <quicksilver> isInteger (x:xs) | isNumber x = isInteger xs | otherwise = False
02:00:04 <quicksilver> for our last case.
02:00:07 <vharishankar> quicksilver: thanks.
02:00:39 <blackdog> so, i just spent a few minutes running frequency analysis on byorgey's editorial and came up with bupkis. anyone know what's going on?
02:01:40 <dcoutts> aspiers: some of that is fundamental and some just bugs.
02:02:14 <thoughtpolice> blackdog: http://www.google.com/search?q=define:bupkis
02:02:38 <blackdog> thoughtpolice: ... i mean i didn't come up with anything useful.
02:02:41 <blackdog> not literally bupkis:)
02:02:49 <dcoutts> aspiers: the main thing is that user packages can depend on system ones and not the other way around. Upgrading system packages can break users ones since upgrading distro packages involved deleting the old version.
02:02:56 <thoughtpolice> blackdog: lol oh
02:03:06 <dcoutts> aspiers: the thing about installing the same version twice is "just" a bug in cabal
02:03:18 <aspiers> dcoutts: that's the same with Perl, Ruby, Python ...
02:03:40 <vharishankar> The pattern matching version is a bit more confusing, but still Ok with me.
02:03:41 <dcoutts> aspiers: right
02:03:53 <vharishankar> Why is it preferred over using head or tail function?
02:04:21 <zeiris> head is partial, and fails with a nasty nasty exception on empty lists.
02:04:26 <ibid> vharishankar: head and tail can fail in a confusing manner
02:04:40 <aspiers> dcoutts: it looks like my particular problem is that somehow I've ended up with the wrong ABI versions of directory and process
02:04:50 <vharishankar> ibid: OK
02:05:16 <ibid> vharishankar: you'll understand the first time a large program crashes with ...
02:05:19 <ibid> > head []
02:05:21 <lambdabot>   *Exception: Prelude.head: empty list
02:05:25 <dcoutts> aspiers: cabal currently has particular problems when you end up with two instances of the same version of a package installed.
02:05:36 <ibid> vharishankar: there won't be any indication as to where the issue lies
02:05:43 <aspiers> dcoutts: but AFAICS, I only have *one* version of directory and process
02:05:50 <vharishankar> ibid: Thanks.
02:05:59 <dcoutts> aspiers: are you sure? use ghc-pkg list, see global and user sections.
02:06:07 <aspiers> dcoutts: yes, I just checked
02:06:12 <vharishankar> Pattern matching is preferable because it won't fail, right? And if it does, it just matches the next pattern and so on.
02:06:14 <aspiers> dcoutts: and yet my user local metadata for haskell98 depends on a different ABI version
02:06:19 <ibid> vharishankar: pattern matching forces you to think about the abnormal conditions and gives you a chance to handle them with more grace
02:06:40 <ibid> vharishankar: it'll fail if you don't cover all cases, but there's a compiler warning available to detect that
02:06:42 <dcoutts> aspiers: can you paste your ghc-pkg list output somewhere
02:06:48 <vharishankar> ibid: so we move from specialized cases, down to general
02:07:02 <vharishankar> ibid: you answered me before I asked. :-)
02:07:13 <aspiers> dcoutts: sure - but I suspect this could have been due to a 'cabal install git-annex --prefix=~/local'
02:07:40 <dcoutts> aspiers: na, that just changes where the files are installed, now where the package is registered.
02:07:43 <dcoutts> now/not
02:09:41 <vharishankar> ok all. Thanks. I've overheated my brain enough for one day. :-P
02:12:10 <hpaste> aspiers pasted “ghc-pkg list -v output” at http://hpaste.org/53194
02:12:24 <aspiers> dcoutts: there you go
02:13:12 <dcoutts> aspiers: ok, odd indeed. You don't have haskell98 registered in the global db.
02:13:33 <dcoutts> aspiers: this was from a distro package?
02:13:59 <aspiers> dcoutts: Fedora 15, ghc and many other packages installed via rpm but not ghc-haskell98
02:14:02 <dcoutts> aspiers: I wonder if the reason you were having so much trouble is because your distro provided you with an absolutely minimal set of packages
02:14:19 <dcoutts> and so then you were trying to use cabal to install h98 and template-haskell etc etc
02:14:35 <dcoutts> which will of course try to use the latest versions, rather than the versions that ship with ghc
02:14:51 <aspiers> dcoutts: cabal install git-annex certainly tried to pull template-haskell in, yes
02:14:52 <dcoutts> with your particular version of ghc
02:14:56 <aspiers> probably haskell98 too
02:15:07 <aspiers> so I should deinstall the local template-haskell and haskell98?
02:15:10 <aspiers> and install from rpm?
02:15:29 <dcoutts> aspiers: go take a look if your distro has an rpm for the haskell platform
02:15:33 <aspiers> it does
02:15:40 <dcoutts> or any other kind of haskell/ghc meta-package
02:15:43 <aspiers> ghc-haskell98.i686                            1.1.0.1-16.5.fc15
02:15:57 <aspiers> ghc-template-haskell.i686                           2.5.0.0-16.5.fc15
02:16:00 <dcoutts> aspiers: it's a bit like you installed gcc but not glibc :-)
02:16:11 <aspiers> so it's a bug with Fedora's ghc.spec?
02:16:17 <aspiers> should require those packages
02:16:20 <dcoutts> well not strictly speaking
02:16:30 * hackagebot timeplot 0.3.10 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.10 (EugeneKirpichov)
02:16:41 <dcoutts> it's reasonable in principle to package them separately, but it's a bit confusing
02:17:13 <aspiers> I still don't understand why my local haskell98 depends on versions of directory/process with ABI hashs totally absent from my system
02:17:41 <aspiers> I mean my ~/.ghc/i386-linux-7.0.2/package.conf.d/haskell98-1.1.0.1-7a47131463f5668d33636b0f729516d7.conf
02:18:14 <dcoutts> aspiers: oh that's because while you've been hacking around, cabal has installed and reinstalled packages.
02:18:26 <dcoutts> reinstalling packages can break other packages
02:18:37 <dcoutts> and cabal doesn't currently warn you that it's going to do that
02:18:41 <aspiers> ahhh
02:18:45 <aspiers> that sounds like a bug :)
02:18:45 <gu> hi, how can i pass a function a randomly generated int? i'm trying with generateCode (randomIO :: Int) but with no luck
02:18:57 <aspiers> for sure
02:19:12 <aspiers> silently introducing breakage is always bad :)
02:19:16 <dcoutts> aspiers: which makes everyone chortle
02:19:20 <gienah> aspiers: there are likely to be some global ABI hashes in a directory like: /usr/lib64/ghc-7.0.2/package.conf.d
02:19:34 <aspiers> gienah: yes, I saw those via ghc-pkg list -v
02:19:43 <aspiers> gienah: there aren't many in my case
02:20:05 <aspiers> why aren't multiple (package, version, ABI hash) tuples allowed to coexist?
02:20:43 <aspiers> dcoutts: so how to fix this? uninstall the local haskell98 / template-haskell and install from distro rpms?
02:20:55 <aspiers> or reinstall the local ones?
02:22:27 <dcoutts> aspiers: yes, rm -r /home/adam/.ghc/i386-linux-7.0.2/package.conf.d; install your rpms and then cabal install just the packages you're interested in.
02:23:52 <aspiers> dcoutts: need to nuke ~/.cabal too?
02:23:57 <dcoutts> aspiers: no
02:24:32 <dcoutts> don't need to, you can reclaim some disk space by nuking ~/.cabal/lib if you care
02:24:39 <aspiers> ok
02:25:28 <aspiers> ok, now my global package.cache seems stale
02:25:34 <aspiers> as per that webpage, the rpms don't update it
02:25:50 <aspiers> ghc-pkg list doesn't show haskell98 which I just installed via rpm
02:26:17 <gienah> aspiers: not sure if it would help or not, but there is: ghc-pkg recache
02:26:55 <aspiers> gienah: didn't appear to, even with --global
02:27:28 <gu> hi, how can i pass a function a randomly generated int? i'm trying with generateCode (randomIO :: Int) but with no luck
02:27:54 <quicksilver> randomIO does not (cannot) have the type Int.
02:28:14 <quicksilver> do n <- randomIO; return (generateCode n)
02:28:19 <quicksilver> in an IO do block
02:29:18 <gienah> aspiers: ghc-pkg list haskell98 on my gentoo box does list it (for ghc 7.0.4): haskell98-1.1.0.1
02:29:44 <gienah> aspiers: you could run: ghc-pkg check
02:30:06 <aspiers> gienah: I tried that
02:30:12 <aspiers> gienah: no output
02:30:28 <gienah> aspiers: no news is good news
02:30:34 <aspiers> gienah: I wish :-/
02:31:31 * hackagebot uu-parsinglib 2.7.2 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.2 (DoaitseSwierstra)
02:31:40 <aspiers> dcoutts: it's still not working
02:31:49 <aspiers> dcoutts: I think I must be hitting a cabal bug?
02:31:57 <aspiers> dcoutts: pasting the output ...
02:33:00 <ibid> one possibility is to uninstall everything haskell-related and then reinstall
02:33:05 <hpaste> aspiers pasted “cabal install git-annex fails with fresh ~/.ghc” at http://hpaste.org/53196
02:33:29 <aspiers> ibid: OK, I'll try that
02:33:51 <dcoutts> aspiers: oh I thought you said there was a haskell-platform rpm
02:33:56 <luite> that's a lot of buzzwords for uu-parsinglib :)
02:34:00 <aspiers> dcoutts: yes, I installed it
02:34:11 <aspiers> dcoutts: but as per above, package.cache doesn't know about it even after a recache
02:34:17 <dcoutts> aspiers: the haskell-platform would be a metapackage that would include bytestring, time and a bunch of things besides
02:34:26 <aspiers> dcoutts: oh I see
02:34:29 <aspiers> dcoutts: checking
02:34:38 <dcoutts> this isn't the same thing as haskell98
02:34:58 <aspiers> dcoutts: apparently not
02:35:02 <geheimdienst> dcoutts: what service compiles newly-uploaded hackage packages and writes the "build failure" logs? is it a cronjob? i couldn't find anything in the hackage-scripts repo
02:35:44 <aspiers> dcoutts: haskell-platform rpm pulls in 70 rpms, haskell98 doesn't pull in any others!
02:35:52 <dcoutts> aspiers: that's better
02:35:53 <geheimdienst> (i was wondering if hackagebot could be haxxored to only announce things after the haddock docs are in place ... would be more useful)
02:36:08 <dcoutts> geheimdienst: yes, it's a box that sits under Ross Patterson's desk
02:36:22 <dcoutts> geheimdienst: the scripts for it are not in the hackage-scripts repo
02:37:12 <geheimdienst> oh i see ... does it put out some rss feed of recent builds, or similar?
02:37:19 <dcoutts> no
02:37:32 <dcoutts> it just scp's stuff into the filesystem served by apache
02:37:59 <luite> are the scripts available anywhere?
02:38:14 <dcoutts> geheimdienst: trying to make a buildbot for the new hackage-server?
02:38:25 <dcoutts> luite: you'd have to ask Ross
02:38:38 <dcoutts> luite: the scripts that run on the hackage site itself are available
02:39:02 <luite> yeah I know that :) I was interested in building docs
02:39:21 <geheimdienst> dcoutts, no, i just randomly got it into my head yesterday to see if hackagebot in here could be made to announce things a little later, once the haddocks are available. it'd be more useful
02:39:36 <dcoutts> luite: Max has written a docs build bot for the new server, it's in the hackage-server repo
02:40:12 <luite> dcoutts: ah good, thanks
02:40:23 <dcoutts> geheimdienst: you'll like the package candidates feature in the new server
02:40:37 <geheimdienst> you mean in hackage 2.0?
02:40:40 <dcoutts> yes
02:40:56 <dcoutts> allows packages to be uploaded, get tested, built, docs uploaded etc, and later published in the main index
02:41:08 <geheimdienst> oh, very nice :)
02:42:32 <salisbury> geheimdienst: there is a twitter feed I think
02:43:24 <geheimdienst> salisbury: interesting, does it post packages that were uploaded or packages that were compiled?
02:44:32 <salisbury> geheimdienst: uploaded it seems
02:44:55 <salisbury> geheimdienst: here is a link http://twitter.com/#!/Hackage
02:45:42 <geheimdienst> that's what i suspected. it probably broadcasts the rss feed. the feed is updated by a shell script when a package has been uploaded, and it's not so easy to change that :)
02:46:10 <salisbury> ahh, my mistake
02:46:14 <salisbury> sorry
02:46:33 <geheimdienst> no no, it's interesting, i hadn't seen the twitter thing before :)
02:46:51 <Phyx-> geheimdienst: you don't actually need to change the feed do you?
02:47:45 <geheimdienst> Phyx-: not change the feed itself, only the time that it's updated. it should be a little bit later, once compilation has happened
02:48:11 <geheimdienst> but really, it was just a silly idea i had yesterday. i've concluded it's not really feasible currently :)
02:48:34 <Phyx-> geheimdienst: I thought you only wanted to change hackagebot
02:49:17 <Saizan> yeah, you could this by making hackagebot monitor the webpage of the package too
02:49:33 <Saizan> +do
02:49:34 <Phyx-> yeah, That's what I was thinking
02:49:51 <Saizan> using the rss to know which ones to watch
02:50:04 <Phyx-> maybe Hackage 3.0 can have some kind of API like a webservice
02:50:11 <Phyx-> that allows you to submit packages, check status
02:50:12 <Phyx-> etc
02:50:19 <Phyx-> get stats
02:50:23 <geheimdienst> hm ... i guess that'd be possible. thanks for the idea guys :)
02:50:23 <Phyx-> would be handy
02:50:30 <Saizan> we haven't seen 2.0 yet!
02:50:45 * dcoutts notes that it's getting closer
02:50:49 <Phyx-> Saizan: oh, lol
02:51:03 <QinGW> >2^64
02:51:17 <QinGW> @2&64
02:51:17 <lambdabot> Unknown command, try @list
02:51:26 <QinGW> @2^32
02:51:26 <lambdabot> Unknown command, try @list
02:51:36 <aspiers> > 2^64
02:51:37 <lambdabot>   18446744073709551616
02:51:40 <Saizan> > 2^54
02:51:41 <lambdabot>   18014398509481984
02:51:49 <QinGW> > 2^32
02:51:50 <lambdabot>   4294967296
02:52:13 <QinGW> Thanks, Saizan
03:06:47 * hackagebot uu-parsinglib 2.7.2.1 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.2.1 (DoaitseSwierstra)
03:21:49 <frerich> Hm, if marriage with functions was allowed here, I'd have proposed to QuickCheck by now.
03:28:46 <ben> How do I foreign-import-unsafe a function and then call it without blocking all haskell threads?
03:30:08 <erus`> :t Monad
03:30:09 <lambdabot> Not in scope: data constructor `Monad'
03:30:16 <erus`> :t Maybe
03:30:16 <lambdabot> Not in scope: data constructor `Maybe'
03:31:17 <basvandijk> ben: To my knowledge, you can't.
03:31:23 <zeiris> :i Monad
03:32:25 <erus`> how can i represent a type with a type specifier like Maybe
03:32:28 <basvandijk> ben: Can't you just use a safe foreign import?
03:34:29 <basvandijk> ben: Note that it's also possible to use both a safe and unsafe foreign import. If you know that for certain arguments your foreign function returns quickly, you can use the unsafe import, for others use the safe import.
03:35:13 <erus`> @src Maybe
03:35:13 <lambdabot> data Maybe a = Nothing | Just a
03:35:59 <erus`> algebraic types are hard :(
03:36:25 <basvandijk> Quick question: is it always safe to replace: "atomicModifyIORef ref (\_ -> (newValue, ()))" by: "writeIORef ref newValue" ?
03:36:53 <ben> basvandijk: I was just reading http://blog.melding-monads.com/2011/10/24/concurrency-and-foreign-functions-in-the-glasgow-haskell-compiler/ and it saidthat unafe calls blocking the entire haskell runtime are a myth :(
03:38:26 <basvandijk> ben: True, but that article also explains that all Haskell threads in the capability get blocked when one of them makes an unsafe foreign call.
03:40:54 <ben> basvandijk: Ah, I thought the rts would move the threads to another capability. I forgot that the main thread is bound by default.
03:41:07 <ben> Thanks. :)
03:42:47 <DrTeggy> ((x1 + x2 + abs (x1 - x2)) / 2
03:45:09 <basvandijk> ben: to quote the article: "When GHC performs a safe call, it performs the call inside the current OS thread, which is a capability. The capability then moves to another OS thread. If no other threads are available, GHC will transparently create a new OS thread."
03:46:30 <ben> Yeah, but it seems like non-bound threads easily escape to another capability, so all is well.
03:49:35 <leod> @check \x1 x2 -> (x1 + x2 + abs (x1 - x2)) `div` 2 == max x1 x2
03:49:35 <lambdabot>   "OK, passed 500 tests."
03:53:23 <DrTeggy> lead :-)
03:54:38 <DrTeggy> (leod, sorry)
04:05:09 <leod> DrTeggy: I was curious because I have to prove that equation as homework :p
04:08:17 <erus`> wow some people on C++...
04:08:27 <erus`> #haskell is really nice
04:09:50 <Jeanne-Kamikaze> the last time I asked something about the STL they said my question was ambiguous and listed 4-5 possible definitions of STL
04:09:58 <Jeanne-Kamikaze> if you need help with c++ it's better to ask in #boost :)
04:10:11 <DrTeggy> leod: uh, you do?
04:10:21 <DrTeggy> The proof is actually a two-liner.
04:10:25 <leod> I know :)
04:10:28 <DrTeggy> OK :-)
04:11:06 <telexicon> lol erus`
04:11:11 <leod> it's my first semester, so it's been mostly trivial stuff so far
04:11:25 <jcf> Got another basic question. http://compsoc.dur.ac.uk/~jcf/squarecube.txt this runs fine in ghci but compiling it doesn't seem to work at all. Possibly because I'm misunderstanding types.
04:11:59 <DrTeggy> leod, where do you study?
04:12:02 <jcf> I'll pastebin the error I get, and thanks for anyone who can help me.
04:12:06 <leod> DrTeggy: aachen, germany
04:12:15 <kosmikus> jcf: you cannot just put an expression into a file
04:12:16 <DrTeggy> Aachen.
04:12:17 <erus`> telexicon: I dont think telling someone to read a book is as helpfull as pointing out the problem :)
04:12:19 <DrTeggy> Great.
04:12:23 <leod> yeah it's nice :)
04:12:24 <DrTeggy> <-- Tübingen.
04:12:28 <kosmikus> jcf: you'll have to give the expression a name
04:12:30 <leod> cool :D
04:12:38 <telexicon> erus`, i think it comes from, people  being asked too many questions with no compensation
04:12:39 <DrTeggy> But I am teaching the 1st year students here.
04:12:40 <DrTeggy> ;-)
04:12:44 <leod> hah!
04:12:47 <jcf> kosmikus: I thought it might be something silly like that.
04:13:03 <kosmikus> jcf: try prefixing that line with "x = "
04:13:10 <telexicon> erus`, a lot of people come in asking people to do their homework for them
04:13:15 <telexicon> it can be frustrating
04:13:22 <kosmikus> jcf: then load it into ghci, and then type "x" to get it evaluated
04:13:47 <telexicon> and sometimes people are in a bad mood or confuse things, but its also a point where people could improve to help the community
04:13:57 <leod> DrTeggy: teaching them any Haskell too? we'll do prolog and haskell later in the programming class, but we started with java
04:14:31 <erus`> I'm gonna make #c++friendly
04:14:59 <erus`> ive heard other people moan about C++ but never seen it myself until now
04:15:31 <DrTeggy> leod, I am teaching Scheme this year.  But my assistants read Advanced Functional Programming (using Haskell)
04:15:43 <leod> ah, Scheme is sweet too
04:16:23 <jcf> kosmikus: That works within ghci.
04:16:33 * DrTeggy nods towards Matthias Felleisen and the entire DrRacket team.
04:16:34 <DrTeggy> Cool stuff.
04:19:22 <DrTeggy> But I'm off for the lecture now.
04:19:24 <DrTeggy> bbl
04:19:38 <leod> ok
04:19:39 <mirari> Is there an easy way to have ghci output the result of some expression to a file?
04:22:35 <profmakx> mirari writeFile?
04:22:50 <profmakx> provided you have a show instance
04:25:51 <mirari> I have show instance
04:27:03 <mirari> profmakx: Works excellent, thanks
04:47:19 <e98> using ghc-7.2.1 on Darwin 7.2.1 cabal-dev install failed for package unix with the following error
04:47:22 <e98> dist/build/System/Posix/Signals.hs:124:0: error: Signals.h: No such file or directory
04:49:06 <geheimdienst> e98: the "unix" package is part of ghc. you already have a version of unix installed (unless something is terribly messed up). check with "ghc-pkg list"
04:49:22 <geheimdienst> use "-v2" or similar to try to find out how cabal got it into its head to install unix. it really shouldn't try that
04:49:32 <Cale> Where'd you get the Darwin package of GHC?
04:49:40 <e98> from the official binaries
04:49:58 <Cale> oh, interesting
04:50:14 <e98> odd enough install darcs wants to install unix-2.3
04:50:15 <e98> hmm
04:50:19 <Cale> I guess that's the same as the MacOS version then
04:50:49 <e98> shouldn't it use unix-2.4
04:51:19 <e98> I'm glad I have cabal-dev, though
04:51:34 <e98> also need to fix the following errors from cabal-dev built sandboxed Xmonad
04:52:03 <e98>     Could not find module `XMonad'
04:52:03 <e98>     Perhaps you meant
04:52:03 <e98>       Monad (needs flag -package haskell98-2.0.0.0)
04:52:03 <e98>       CgMonad (needs flag -package ghc-7.2.1)
04:52:04 <e98>       DsMonad (needs flag -package ghc-7.2.1)
04:52:18 <geheimdienst> e98: yeah, it should probably use unix-2.4. try to make cabal more verbose, it will tell you why it is trying to install unix-2.3
04:53:07 <e98> $ cabal-dev -s $PWD install darcs -v > LOG
04:53:09 <e98> waiting
04:53:21 <e98> gah
04:53:27 <e98> should have redirected all fds
04:54:51 <e98> Resolving dependencies...
04:54:51 <e98> In order, the following would be installed:
04:54:51 <e98> unix-2.3.2.0 (new version)
04:54:52 <e98> directory-1.1.0.1 (reinstall) changes: unix-2.5.0.0 -> 2.3.2.0
04:55:29 <e98> I can't wait for the version-ignoring type-based dependency resolver for ghc and cabal to appear
04:55:48 <e98> it's a pity that with ghc we're using version strings as hard deps
04:56:30 <dcoutts> it would not solve the problem that you need to use consistent versions of packages
04:56:49 <dcoutts> ie that all your packages need to be built against the same version of the unix package
04:57:53 <e98> DSO version string mismatch with dyn linker?
04:57:58 <geheimdienst> e98: to reiterate, if you have multiple versions of unix installed, then most likely something is wrong. try to find out why cabal is not going with the already present unix package
04:58:08 <geheimdienst> also, please use hpaste for snippets longer than 1 line
04:58:10 <geheimdienst> @where hpaste
04:58:11 <lambdabot> http://hpaste.org/
04:58:40 <dcoutts> e98: no, type errors like unix-2.5.0.0:System.Posix.Types.Fd /= unix-2.3.0.0:System.Posix.Types.Fd
04:58:51 <dcoutts> e98: it would not compile, not a linker problem.
04:58:59 <e98> dcoutts: ok
04:59:28 <e98> I've used a minimally patched cabal-install to use right versions of deps with 7.2.1
04:59:32 <e98> just fyi
05:00:13 <e98> ignoring this for the moment, how do I tell the cabal-dev sandboxed xmonad to find its libs from the sandbox?
05:00:21 <dcoutts> e98: you might like to try http://darcs.haskell.org/cabal-branches/cabal-modular-solver/
05:00:23 <e98> any environment var?
05:00:51 <dcoutts> e98: use cabal-dev to build xmonad in the same sandbox
05:01:49 <e98> dcoutts: I did use a separate sandbox for xmonad and when I put the $XMONAD_SANDBOX/bin on path and start it it cannot find module XMonad as you see from the multiline paste above
05:02:24 <e98> dcoutts: what is cabal-modular-solver about?
05:03:25 <dcoutts> e98: it's a new and improved cabal dependency solver
05:03:55 <dcoutts> http://haskell.org/haskellwiki/HaskellImplementorsWorkshop/2011/Loeh
05:04:14 <e98> dcoutts: if the changes are in Cabal, how do I use it? I mean Cabal is bundled in ghc
05:04:25 <dcoutts> no it's in cabal-install
05:04:59 <e98> does it have the 7.2.1 bootstrap and cabal-install.cabal version bumps?
05:05:08 <dcoutts> no
05:05:41 <dcoutts> well, the cabal-install.cabal builds with Cabal HEAD
05:05:58 <dcoutts> but I've not touched the bootstrap, patches accepted
05:10:33 <luite> what's happening with the parallel cabal builder? is that going to be included soon?
05:11:04 <dcoutts> luite: it's in my review in-tray
05:11:23 <dcoutts> I've had a first look, it's going to take a bit of work to integrate
05:14:16 <luite> dcoutts: ah I hope it won't be too much work, it looks really useful :)
05:14:41 <dcoutts> yes clearly a good feature to have
05:15:34 <e98> wait, cabal has no -jN, yet?
05:16:04 <e98> I have to vote +1, then, I suppose
05:23:18 <erus`> haskell is so much nicer than scheme :P
05:23:56 <erus`> Just because you can write type sigs and stuff to help you think
05:23:57 <e98> haskell has syntax
05:24:01 <e98> LISPs don't
05:24:41 <e98> it's the gist of the joke that you can write a custom lisp in lisp
05:26:21 <hpc> lisps do have syntax, it's just that the syntax is lisp
05:26:46 * hpc has had professors say in the same breath that macros modify syntax and that lisp has no syntax
05:27:36 <erus`> strings arnt lists :(
05:29:37 <khs> is ghc backwards compatible with earlier versions?
05:30:22 <blackdog> khs: ABI compatible, do you mean?
05:30:31 <blackdog> (because if so: no.)
05:32:17 <ketil> Anybody know if Microsoft's .net implementation of STM is published anywhere?
05:32:31 <khs> blackdog: ABI?
05:32:32 <ketil> Or any other "real" implementations of STM?
05:33:21 <ketil> (I put real in quotes, as the value of "real" is degrading faster than Greek national debt at the moment.)
05:34:17 <blackdog> khs: application binary interface
05:34:45 <blackdog> ie, you can link object files together produced by different compilers if they have compatible ABIs
05:35:02 <blackdog> what are you actually trying to do?
05:38:04 <khs> blackdog: I'm just wondering if source files compiled with a new version will be compatible with older versions of ghc
05:38:32 <khs> blackdog: the source files will compile on older versions...
05:39:12 <blackdog> khs: i don't think it's guaranteed. some things change.
05:39:22 <blackdog> if your source code is haskell98 you should be fine.
05:39:31 <geheimdienst> khs: source compatibility is kind of good, unless you use very new experimental things. you should be fine most of the time
05:42:02 <khs> Ok, I'm using the GHC api from 7.0.3 to dump Core to another format, but as long as the version I'm using is compatible with future versions, I can still work with files "written for" a newer version.
05:58:48 <hpc> how long does it usually take to run hp2ps?
05:59:00 <hpc> i have a 220mb heap profile
06:00:26 <ClaudiusMaximus> hpc: try hp2pretty - latest version is significantly faster than hp2ps [/promo]
06:01:18 <hpc> heh
06:01:36 <ClaudiusMaximus> hpc: i benchmarked it on a 37MB .hp, hp2ps took 30s, hp2pretty took 10s
06:02:25 <hpc> sweet
06:02:34 <hpc> > 37 / 30 * 200
06:02:35 <lambdabot>   246.66666666666669
06:02:56 <hpc> well it's clearly not a linear algorithm :P
06:03:37 <ClaudiusMaximus> it probably depends on various things like number of distinct cost centers etc
06:04:04 <hpc> ClaudiusMaximus: indeed; i don't feel like dependency hunting right now, or i would definitely try it
06:04:29 <hpc> ill just give it an hour or so
06:04:34 <ClaudiusMaximus> heh, ok
06:06:04 <statusfailed> How do I import a data constructor?
06:06:19 <ClaudiusMaximus> import Module(DataType(Constructor))
06:06:23 <hpc> yes
06:06:27 <basvandijk> dcoutts: Hi Duncan, I thought about package logo's and XSS a bit more. It turns out you can load SVG images using the img tag as in: <img src="logo.svg"/>. Most browsers will disable scripts in SVGs loaded via the img tag thus reducing the threat of XSS.
06:06:53 <basvandijk> Unfortunately, I noticed that both Firefox and Chrome currently have a bug which causes SVG images which are loaded via the img tag to be rasterized instead of scaled using vector graphics.
06:07:32 <statusfailed> ClaudiusMaximus: oh, thanks!
06:07:44 <statusfailed> ClaudiusMaximus: does that also import all the field names and functions on that type?
06:08:26 <dcoutts> basvandijk: that's ok isn't it?
06:08:59 <ClaudiusMaximus> you can import Module(DataType(..)) to import all constructors and field accessors iirc, but other functions won't be; you can be fast/loose and just import Module to get everything
06:09:15 <basvandijk> dcoutts: Yes, both the bug in FF as in Chrome is reported, so hopefully it's fixed soon.
06:09:32 <Abraxas> i started to write this function: string :: String -> Parser ()...base case: string [] = \inp -> Just((), inp)...works with this type definition: type Parser a = String -> Maybe (a, String)
06:09:41 <Abraxas> but no longer with this: newtype Parser a = P {unP :: ParserCore.Parser a}
06:09:43 <basvandijk> dcoutts: I think I modify the logo patch to only use an img tag
06:09:47 <dcoutts> basvandijk: but is that bug a problem, assuming it's rasterised at the right size
06:10:00 <Abraxas> ParserCore.Parser a is (or should be) the old def
06:10:12 <basvandijk> dcoutts: No, it's only a problem when you scale the page
06:10:24 <dcoutts> ok
06:10:31 <Abraxas> error: The lambda expression `\ inp -> Just ...' has one argument,
06:10:31 <Abraxas>     but its type `Parser ()' has none
06:10:36 <Abraxas> sorry
06:14:55 <basvandijk> dcoutts: I was also thinking about using the pngload and svgutils packages to check if the logo's are really PNGs or SVGs. And for determining the real size of the logo so we can correctly scale the logo in the HTML page. However, what do you think is best: the easy solution: parse the logo file each time the page is rendered, or the hard but more efficient solution: parse the logo when the package is uploaded and store the result in
06:14:55 <basvandijk> the PkgInfo ?
06:15:31 <dcoutts> basvandijk: if we did it, we'd have to do the latter.
06:15:39 <byorgey> ddarius: if you have examples of things you'd like to do that run afoul of the restrictions, please send them along!
06:15:48 <basvandijk> dcoutts: ok
06:15:51 <ClaudiusMaximus> random thought - it's trivial to create a tiny (in terms of bytes) PNG file representing a huge (in terms of megapixels) images
06:16:01 <dcoutts> basvandijk: and PkgInfo wouldn't be the appropriate place, it would go in the same place as where we keep the changelog info
06:16:11 <hpc> ClaudiusMaximus: png is just a quadtree, isn't it?
06:16:12 <byorgey> ddarius: it's good to collect motivating examples, and we're definitely not done -- those restrictions may be lifted in the future
06:16:23 <yitz> basvandijk: just parse the first 10 bytes or so for that, so what's the difference?
06:16:38 <hpc> so you could theoretically just give it a huge size and single color and you're done
06:17:15 <statusfailed> ClaudiusMaximus: ok, cheers!
06:18:02 <ClaudiusMaximus> hpc: it has various interlacing/compression, maybe RLE - but yeah
06:18:37 <erus`> @hoogle (Int -> Int) -> Int -> Int
06:18:37 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
06:18:38 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
06:18:38 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
06:18:44 <erus`> @hoogle (Int -> Int, Int)
06:18:44 <lambdabot> No results found
06:19:21 <basvandijk> yitz: What do you mean? How can parsing only the first few bytes determine the size of the image or if the image is a valid SVG or PNG?
06:19:24 <erus`> > let f :: (Int -> Int, Int); f = undefined in 1
06:19:25 <lambdabot>   1
06:24:36 <erus`> :t (\x -> x x 1)
06:24:37 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
06:24:37 <lambdabot>     Probable cause: `x' is applied to too many arguments
06:24:37 <lambdabot>     In the expression: x x 1
06:25:35 <erus`> do you ever get a type sig like this: Int -> (Int -> Int) ?
06:25:41 <quicksilver> yes
06:25:47 <quicksilver> that is the type signature of (+)
06:25:54 <quicksilver> at least, the Int-version of (+)
06:25:54 <erus`> T: (+)
06:26:01 <hpc> :t (+)
06:26:01 <lambdabot> forall a. (Num a) => a -> a -> a
06:26:10 <Abraxas> i have written other parser functions that used the same newtype def, but no lambda in the function def and no problem there...it seems to be the lambda, but no idea how to get around it or cast it to a newtype or whatever?
06:26:33 <erus`> int -> (int -> int) == int -> int -> int        then?
06:26:36 <quicksilver> yes.
06:26:59 <erus`> (int -> int) -> int   is the same?
06:27:01 <hpc> no
06:27:10 <erus`> how does it know :|
06:27:12 <erus`> lol
06:27:13 <Abraxas> can i make the compiler tell me
06:27:25 <hpc> (->) associates to the right
06:27:38 <hpc> so if you put parens around the right of an arrow, it does nothing
06:27:58 <quicksilver> erus`: well "a -> a -> a" doesn't mean anything inherently.
06:28:04 <quicksilver> somebody has to decide
06:28:05 <hpc> x -> (x -> x) ~~ 5 + (3 + 7)
06:28:20 <quicksilver> if it means "(a -> a) -> a" or "a -> (a -> a)"
06:28:20 <hpc> ... bad example
06:28:25 <Phyx-> erus`: usually by how the abstract syntax is constructed. the parenthesis is only for us the humans
06:28:38 <quicksilver> for a variety of good reasons people decided the second one
06:28:45 <quicksilver> i.e. they made -> associate to the right.
06:29:09 <Phyx-> and for parsing obviously
06:29:25 <haskellbeginner> hello
06:29:34 <Phyx-> hi
06:29:47 <hpc> > 5 - 3 - 2
06:29:48 <lambdabot>   0
06:29:56 <hpaste> erus` pasted “types” at http://hpaste.org/53211
06:30:29 <hpc> erus`: your indentation and spacing is wonky
06:30:39 <hpc> (unrelated to your actual problem)
06:30:43 <erus`> its firefox windows pasting
06:31:19 <haskellbeginner> hi im trying write a function called doubleList2 with takes a list of integers and doubles them
06:31:43 <erus`> haskellbeginner: use a map
06:31:49 <mm_freak> @hoogle Functor f => f a -> (a -> b) -> f b
06:31:49 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
06:31:50 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
06:31:50 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
06:31:59 <hpc> > map (* 2) [1..10]
06:31:59 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
06:32:36 <haskellbeginner> I'm just suppose guards with let and in
06:33:14 <haskellbeginner> I have this: doubleList2 :: Num t => [t] -> [t] doubleList2 xs         | xs == [] = []         | otherwise =                 let dl (x:xs) =  x * 2 : dl xs                 in  dl (xs)
06:33:56 <hpc> you need a base case for dl
06:34:08 <hpc> or better
06:34:15 <haskellbeginner> which runs but gives me: Exception: <interactive>:1:5-30: Non-exhaustive patterns in function dl
06:34:27 <hpc> let dl (x:xs) = (x * 2):(doubleList2 xs) in dl xs
06:35:04 <haskellbeginner> hmmm ok , like when it reaches an empty list []
06:35:09 <hpc> haskellbeginner: what happens if you call dl []?
06:35:17 <hpc> er, s/call/evaluate/
06:35:20 <erus`> hpc so if the last thing in the type signature of a function is a function i can flatten it?
06:35:34 <hpc> erus`: basically, yeah
06:35:57 <hpc> erus`: it's how currying works, if you ever wondered
06:37:27 <quicksilver> that makes it sound more important than it is :P
06:37:29 <haskellbeginner> thanks <hpc> that worked
06:37:33 <quicksilver> it's just a convention, that's all.
06:37:47 <hpc> a convenient convention
06:38:04 <quicksilver> a -> b -> c -> d by convention means a -> (b -> (c -> d)).  If it meant ((a -> b) -> c) -> d, currying would still work
06:38:12 <quicksilver> we'd just wear out our ( and ) keys a bit sooner
06:38:16 <quicksilver> we'd be like lisp programmers.
06:38:19 <hpc> :P
06:39:13 <koala_man> haha
06:39:45 <hpc> my '(' key is actually worn out from this AI class
06:40:24 <Phyx-> quicksilver: yeah, but partial application would become less useful wouldn't it
06:41:14 <Abraxas> if i have: intlist :: Parser [Int]  intlist = many1 int and i need a case for the empty input, can i get it without a lambda?
06:41:16 <Abraxas> many1 int :: Parser [Int]
06:41:17 <hpc> quicksilver: it would make types like callCC hellish to parse
06:41:20 <hpc> :t callCC
06:41:21 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
06:41:36 <hpc> ...whoa
06:41:47 <Abraxas> cause lambda not working, see last problem
06:41:51 <hpc> callCC almost looks like (=<<) with the parens moved
06:42:26 <Abraxas> so this is currently not working: intlist = \inp -> if inp == [] then [] else many1 int
06:42:53 <hpc> Abraxas: what's the type of []
06:42:59 <hpc> Abraxas: and what's the type of "many1 int"
06:43:15 <hpc> Abraxas: and what's the type of intlist supposed to be
06:43:28 <Abraxas> many1 int i have writtne
06:43:31 <Abraxas> [] :: [a]
06:43:51 <Abraxas> intlist :: Parser [Int]
06:44:00 <Abraxas> many1 int :: Parser [Int]
06:44:16 <Abraxas> newtype Parser a = P {unP :: ParserCore.Parser a}
06:44:25 <hpc> :t many
06:44:25 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
06:44:41 <hpc> Abraxas: it looks like intlist = many int
06:45:14 <Abraxas> and ParserCore.Parser contains: type Parser a = String -> Maybe (a, String)
06:45:44 <quicksilver> Phyx-: no.
06:45:54 <quicksilver> Phyx-: it's just a convention about how you write types. How many () you need to write types.
06:46:02 <quicksilver> Phyx-: it makes no differences at the value level at all
06:46:07 <Abraxas> many int :: Parser [Int]
06:46:11 <alex___> why does import Data.Maybe cant find function from that moddule
06:46:15 <quicksilver> you have the choice now, if you want, to write all your types fully ()ed.
06:46:44 <hpc> many1 foo = "match at least one foo"
06:46:50 <hpc> many foo = "match at least zero foo"
06:46:59 <hpc> which is what your intlist is doing in a roundabout way
06:47:07 <Abraxas> both the same, but i had many before, same problem
06:47:11 <hpc> or, what it appears to be supposed to do
06:48:01 <Abraxas> intlist = many int does not accept the empty input
06:48:46 <Abraxas> uhm
06:48:49 <Abraxas> now it does
06:48:52 <Abraxas> :D
06:49:27 * raek just realized that "()ed" can be read both as "parenthesized" and as "united"
06:50:11 <tromp> ()ed we stand /ed we fall
06:50:29 <Abraxas> but it's not the solution
06:51:01 <hpc> 9 rings to rule them all, and in the darkness (>>=) them?
06:52:09 <raek> parenthesized we stand slashed we fall :-)
06:53:17 <hpc> :%ed we fall?
06:54:41 <dino-> Ran into something interesting with cabal, Hackage and Windows
06:55:36 <dino-> HP doesn't strip binaries in Windows, but does if I use -optl-s in ghc-options
06:55:45 <Abraxas> the quickcheck that's supposed to check the task says it fails because of "empty input accepted"...huh
06:56:01 <Abraxas> not "" or [] but empty...empty how
06:56:17 <dino-> But cabal sdist complains about that and Hackage rejects it outright, saying that binaries are stripped by default.
06:56:31 <sm> morning all
06:56:34 <dino-> And using an if os(windows) block around it does not help, still rejected by Hackage.
06:56:52 <dino-> So resorting to commented-out lines in .cabal as a workaround
06:57:08 <sm> I'm getting a heap profile with -hT.. it always seems to be 0.1s long. Is it logging only the main thread ?
06:57:37 <dcoutts> dino-: it will strip it if strip.exe is available
06:58:01 <dino-> dcoutts: I was looking for that for a little while as another possibility.
06:58:14 <dino-> Was proving to be annoyingly difficult to find
06:58:19 <dcoutts> dino-: ah, but I bet strip.exe is not on the path
06:58:46 <dcoutts> dino-: we could patch cabal to look for strip along with ghc, in the mingwn dir, like we do for ar.exe
06:59:24 <dino-> dcoutts: Is that basically what it's doing in *nix, running strip on the resulting binaries?
06:59:25 <dcoutts> dino-: if you'd like to test a patch on windows, take a look at Distribution/Simple/GHC.hs configureToolchain function
06:59:45 <dcoutts> dino-: that's exactly what it's doing, see stripProgram in the file I mentioned
06:59:56 <dino-> dcoutts: Ok, will look at this. Thank you
07:00:09 <dcoutts> dino-: you'd want to extend configureToolchain to find strip the same way it finds ld.exe, ar.exe etc
07:00:35 <dcoutts> dino-: that's assuming of course that strip.exe is actually shipped with ghc / platform, you'll have to check that
07:02:44 <dino-> dcoutts: Ok, will dig into this later. Fixing it the right way would be much better than any if os(windows) yada nonsense.
07:03:07 <Abraxas> hpc: any idea why this is not working: string :: String -> Parser ()...base case: string [] = \inp -> Just((), inp)...works with this type definition: type Parser a = String -> Maybe (a, String)...not with this one: newtype Parser a = P {unP :: ParserCore.Parser a}
07:03:57 <Abraxas> because of newtype i cannot access the Parser any more? no lambda for the input string can be used?
07:04:48 <geheimdienst> any way to prevent a function from calling itself? the situation is roughly "f g = do ... ; _ <- g ; ..." and i want to ensure the user doesn't pass f itself to f
07:05:06 <geheimdienst> statically ensuring that would be awesome :) but i guess that's a long shot
07:06:20 <quicksilver> geheimdienst: well generically, make sure f and g don't have the same type
07:06:39 <quicksilver> evil trickery with secret newtypes if you have to.
07:08:31 <geheimdienst> oh, mess with the types ... i guess that would work :) thanks. right now they're still both in the X monad
07:09:47 <khs> how can i import unexported functionality ?
07:09:56 <quicksilver> you can't.
07:10:13 <EvanR-work> its private
07:11:30 <erus`> 'Maybe' is a data type. What is the name for 'Maybe Int'? applied data type?
07:11:56 <EvanR-work> Maybe Int has kind *
07:12:04 <EvanR-work> Maybe has kind * -> *
07:12:14 <geheimdienst> i thought Maybe was a type constructor
07:12:52 <erus`> static typed language are hard to model :(
07:13:14 <EvanR-work> as opposed to untyped? ;)
07:13:20 <EvanR-work> lisp, js
07:13:31 <erus`> yeh dynamic was easy
07:13:40 <EvanR-work> dynamic is another word for 'no types'
07:13:59 <EvanR-work> anything can be anythinged
07:14:07 <EvanR-work> though youd never use it that way
07:14:29 <EvanR-work> so you end up putting checks everywhere to make sure the data is consistent
07:14:44 <EvanR-work> not that easy in my opinion
07:15:30 <erus`> ah hang on
07:16:16 <erus`> the generic stuff is inferred at compile time
07:16:29 <erus`> oh but modules can export generic functions... damn
07:16:50 <EvanR-work> luckily theres interface files
07:17:25 <EvanR-work> but its all behind the scenes
07:18:27 <quicksilver> EvanR-work: yes, but erus` is trying to *implement* a haskell-like language.
07:18:33 <EvanR-work> oh
07:18:37 <erus`> so does modeling generic types and applied/static types sound like a good way to solve the issue?
07:18:40 <EvanR-work> GLWT lol
07:18:43 <quicksilver> as you said, dynamic languages are not that easy to use
07:18:52 <quicksilver> but he said dynamic langauges are easier to model
07:18:56 <quicksilver> which is probably true ;)
07:19:02 <EvanR-work> yeah dynamic is easier to design and implement
07:19:11 <EvanR-work> it also sucks
07:19:26 <quicksilver> erus`: if you want to support types like Maybe Int you will need to implement kinds and kind inference
07:20:16 <quicksilver> as EvanR-work said, glwt ;)
07:20:30 <erus`> time to read then :(
07:23:26 <erus`> oh jesus
07:27:26 <sm> how do I get around this "dynamic linking required" error in order to do profiling with ghc 7.0 ? it's not mentioned in the ghc manual: https://gist.github.com/1319728
07:29:13 <erus`> who wants generics anyway
07:29:19 <erus`> right guys
07:29:44 <sm> and, which program accepts the suggested -osuf option ? Not ghc afaict
07:30:11 <EvanR-work> erus`: yeah lists arent important
07:31:22 <quicksilver> erus`: maybe you mean polymorphism? At least in a haskell context, generics means something else.
07:31:28 <sm> perhaps this is related to TH
07:31:52 <zzing> I am attempting to convert a numerical method of root finding using the secant method from C++ to Haskell using some of my dusty knowledge. I get a syntax error on line 5, but it appears to be triggered for anything after a line: let ε = 10e-7 -- does ghc not like ε? My code is here, https://gist.github.com/1319734   it might not be pretty :P.
07:32:24 <zzing> evil c (,,,) stuff fixed :-(
07:32:26 <zzing> I am possessed
07:32:31 <sm> yes, it works without TH :|
07:33:35 <dcoutts> sm: did you let cabal know that your package is using TH?
07:33:46 <dcoutts> cabal will do the right thing if it knows you're using TH
07:34:35 <sm> dcoutts: just using ghc directly right now, but I'll try that and see
07:34:57 <dcoutts> sm: ah ok, yes you need to build a vanilla version, since TH needs that
07:35:12 <dcoutts> and your profiled .o files will of course have to not clash
07:35:19 <dcoutts> cabal will do that
07:35:39 <sm> I'll use -v3 and see how it does that. Thanks!
07:36:37 <yitz> > let ε = 10e-7 in ε
07:36:37 <lambdabot>   1.0e-6
07:36:49 <yitz> zzing: works here in lambdabot at least
07:37:09 <zzing> yeah, I am definitely having trouble narrowing this error now
07:37:43 <zzing> I wonder if this thing thinks line 5 is secant f xLast x = if (abs (xNext - x) <= ε
07:37:49 <sm> y'know I wish ghc could list all of its zillion options at the command line
07:37:55 <yitz> zzuremove let from line 3
07:38:07 <yitz> zzing ^
07:38:09 <zzing> much better
07:38:16 <zzing> I though tI could use let there
07:38:39 <Axman6> yitz: you count that example as working?
07:38:41 <yitz> zzing: let is not used in top level declarations
07:38:45 <zzing> ok, now it doesn't like my 'then' :p
07:38:47 <yitz> hmm?
07:38:54 <whald> for profiling with GHC, when using the auto-all parameter, i get cost centres for my top-level functions. but when placing the SCCs manually for a function which uses guards, I can't just put an SCC for that function but as it seems I have to annotate each guard separatly. is that correct? can I just use the same SCC name for each guard?
07:38:54 <Axman6> because... it's literally an order of magnitude off...
07:39:04 <yitz> > 10e-7
07:39:05 <lambdabot>   1.0e-6
07:39:15 <Axman6> oh, right
07:39:18 <Axman6> 10 not 1
07:39:21 <yitz> right
07:39:30 <sm> dohhh it's -osuf SUF, not -oSUF
07:39:33 <zzing> oh, actually I do want 1.0e-7 because 10^-7 = 1.0*10^-7
07:40:11 <dingfeng> ohm
07:40:12 <yitz> actually didn't think the exact ε was the issue yet
07:40:17 <zzing> updated gist
07:40:20 <zzing> no, it isn't
07:40:27 <zzing> right now it seems to be the if then else
07:40:36 <death1> www.l2death.com new [Server RPG][High Five] XP/7 SP/7 Adena/ 7 Drop/ Spoil: x7Party XP/ SP: x1.5Max Safe Enchant : 3 Max Enchant : 20
07:40:46 <yitz> zzing: count parens
07:40:48 <ion> zzing: Try removing the redundant (
07:40:54 <zzing> good catch :P
07:41:09 <zzing> ok, now I have a meaningful long error
07:41:19 <llano> when define a class, does the compiler automaticly translate this class into a data type? namely, class Eq a where ... is actually: data Eq a = MkEq (a -> a -> Bool) ?
07:41:42 <zzing> I think I need to narrow the class because of the <=
07:42:29 <ion> More likely because of the /
07:42:54 <ion> @type (/) `asAppliedTo` (undefined :: Num a => a)
07:42:55 <lambdabot> forall t. (Fractional t) => t -> t -> t
07:42:55 <zzing> In the second argument of `(<=)', namely `ε'
07:43:02 <ion> @type (<=) `asAppliedTo` (undefined :: Num a => a)
07:43:03 <lambdabot> forall t. (Ord t, Num t) => t -> t -> Bool
07:43:05 <zzing> Of course, I could just get rid of it altogether :P
07:43:13 <ion> Oh, because of both, actually.
07:43:39 <ion> Num doesn’t depend on Ord indeed, only on Eq.
07:43:39 <zzing> Does Fractional cover the cases where I would normally in C++ use a double?
07:43:53 <Axman6> Double covers those cases exactly
07:44:03 <zzing> I will now be using double I guess
07:44:47 <ion> Double is an instance of Floating, Fractional, Num, RealFloat and RealFrac among others.
07:45:01 <Axman6> Show too!
07:45:02 <Axman6> >_>
07:45:32 <EvanR-work> Enum!
07:45:37 <Axman6> Eq!
07:45:41 <whald> Read!
07:45:45 <EvanR-work> Bounded
07:45:48 <Axman6> no!
07:45:50 <zzing> There was a function I saw at one point that would allow me to inspect via output each iteration of a function without using monads explicitly. Does anyone happen to remember what that was called?
07:45:50 <EvanR-work> lol
07:45:59 <ion> Floating: pi, sqrt, log, sin etc. Fractional: (/), fromRational etc. Num: (+), (*), (-), fromInteger etc. RealFloat: floatRadix, floatDigits, encodeFloat etc. RealFrac: truncate, round, ceiling, floor etc.
07:46:09 <Axman6> zzing: Debug.Trace.trace?
07:46:16 <zzing> I think that was it
07:46:22 <Axman6> zzing: don't do it!
07:46:54 <Axman6> Debug.Trace is the weapon of last resort. if you find that you think you need to use it, you're probably doing something wrong
07:47:39 <zzing> Axman6: I want the ability to insert it in there if I want to track what the function does, not for regular operation
07:47:51 <ion> I don’t see the problem with temporarily shoving Debug.Trace.trace inside a pure function that computes a value via iteration to see what numbers it’s working with.
07:48:21 <zzing> Especially when it is foobaring
07:48:41 <ion> It’s one of the less evil forms of impurity.
07:48:58 <koala_man> if you ever use something unpure in a function, it'll still be kinda dirty after it's removed
07:49:28 <zzing> koala_man: That sounds like .... *Religion*
07:49:47 <zzing> "koala_man the pure"
07:50:20 <zzing> ok, last call of getting this thing to work I believe: https://gist.github.com/1319734   it doesn't like putStrLn, I have tried to bracket it without luck... what is my sin?
07:50:28 <geheimdienst> are there drawbacks associated with trace? i thought it's quite nice, and quite safe because it only produces some stuff on stderr. it doesn't change the behavior of pure code. evil would be a "pure" function that e.g. changes behavior depending on something read from stdin
07:50:42 <geheimdienst> (evil in the sense of confusing to the programmer)
07:50:55 <erus`> http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf -> page 6: wow it makes so much sense now!
07:51:03 <quicksilver> zzing: it's your indentation which is wrong.
07:51:15 <quicksilver> zzing: mixing tabs and spaces can lead to confusion
07:51:26 <quicksilver> configure your editor to use only spaces I suggest.
07:51:27 <zzing> I thought I told this thing to use spaces!
07:52:28 <quicksilver> (in particular you have one TAB before 'let', but four spaces before 'putStrLn')
07:53:16 <koala_man> zzing: http://www.vidarholen.net/~vidar/themonadbewithyou.jpg hail the lambda
07:53:32 <ion> I’d also indent “then …” and “else …” one step further than the associated “if …” for clarity even though that’s not often necessary.
07:53:35 <zzing> koala_man: very nice
07:53:40 <zzing> Roots of sqrt(7) are 2.6457513110645907
07:53:42 <zzing> It works!
07:53:50 <zzing> Now, I can work on improvement!
07:54:39 <zzing> Is there a reasonable way I can eliminate the xLast parameter on the original call while allowing me to pass it on to the next inside the function?
07:54:54 <zzing> I think if is ugly too :P
07:56:02 <ion> secant = go initialLast where go xLast f x = …
07:57:22 * hackagebot hyperpublic 0.1.0 - A thin wrapper for the Hyperpublic API  http://hackage.haskell.org/package/hyperpublic-0.1.0 (MichaelCraig)
08:00:01 <zzing> Some how the 'if' seems ugly
08:03:03 <ion> Use pattern guards.
08:04:09 <zzing> ion, can I call abs in them?
08:04:25 <quicksilver> I think pattern guards are less clear
08:04:31 <quicksilver> although I guess that's familiarity
08:04:59 <quicksilver> this one could just use plain guards tho unless I'm missing something?
08:07:22 * hackagebot hyperpublic 0.1.1 - A thin wrapper for the Hyperpublic API  http://hackage.haskell.org/package/hyperpublic-0.1.1 (MichaelCraig)
08:09:28 <ketil> I think I've just written the worst monad tutorial to date :-)
08:10:48 <zzing> I have updated it, https://gist.github.com/1319734    but it isn't quite giving the right value. I will have to look at it later, class time now
08:14:17 <mm_freak> given an arrow transformer MyArrowT (>~), which has an ArrowApply constraint on (>~) in its Arrow instance, i could just as well turn it into an arrow-to-monad transformer MyArrow m, right?
08:18:22 <zzing_> I think I want to make a version of this that produces the steps in a list for output
08:22:00 <darkangel> hi all. Please help me with build setup. I can't figure out how to build some project with it dependencies using cabal. How big project trees should be organized and what tools i shoud use to build projects with its dependencies?
08:22:28 <quicksilver> zzing_: you might like to read "why functional programming matters" since it uses similar things in its examples; I think you'd find it interesting.
08:23:21 <mm_freak> darkangel: i think, all of those have the same answer:  use Cabal
08:23:24 <quicksilver> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html - examples aren't haskell but they are a similar language.
08:24:25 <darkangel> msieradzki: so cabcal is able to do what i need?
08:24:40 <darkangel> ups
08:28:02 <zzing_> quicksilver: shall do
08:41:08 <haskellNewbie> hello
08:43:12 <haskellNewbie> Im trying to write a function called selectApply where it takes a condtion function1 function2 Integer and if the condition is met will apply function1 else function2 but using guards instead of if statements.
08:43:50 <haskellNewbie> I have this so far: selectApply cond f1 f2 x  | cond == x = f1 x  | otherwise = f2 x
08:44:17 <Axman6> haskellNewbie: what is 'a condition'?
08:44:17 <mah_b> haskellNewbie: what type is cond?
08:44:30 <Axman6> it is a function that returns a bool? or is it just a bool?
08:44:37 <haskellNewbie> <mah_h> boolean
08:44:55 <mah_b> haskellNewbie: then just do | cond = f1 x
08:44:58 <Axman6> then why are you trying to see whether a bool is equal to an integer?
08:45:10 <haskellNewbie> Something like this: selectApply (>5) (+3) ((-)1) 6
08:45:38 <mah_b> haskellNewbie: but then cond is Integer -> Bool.
08:45:47 <mah_b> @type (> 5)
08:45:48 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
08:45:50 <Axman6> haskellNewbie: so it's not a boolean, it's a function that returns a boolean
08:46:16 <mah_b> haskellNewbie: then you have to apply to that function: `| cond x = f1 x'.
08:46:21 <haskellNewbie> <Axman6> yes
08:46:45 <Axman6> haskellNewbie: in your irc client, type ax<tab> and see what happens
08:46:56 <Axman6> just to make your life easier ;)
08:47:21 <haskellNewbie> Axman6:
08:48:46 <haskellNewbie> Axman6:  thanks that worked
08:49:48 <Axman6> haskellNewbie: do you understand why it works?
08:54:05 <Calvin> Hi !
08:54:21 <Axman6> 'lo
08:58:43 <Calvin> According to this : http://www.haskell.org/haskellwiki/Constructor (2.1), Data constructor are first class values
09:00:00 <mightybyte> Anyone know how to run something after test-framework's defaultMain finishes?
09:00:19 <Calvin> Let say we have data Maybe a = Just a | Nothing
09:00:44 <Calvin> Hum bad exemple
09:01:09 <Calvin> I would like to pass as argument a data constructor
09:02:23 <Calvin> If I have data Stat = Health Int | Attack Int (yes TomMD , i'm back with my enum :) )
09:02:34 <quicksilver> Calvin: data constructors are not first class.
09:02:55 <mauke> but they are first class values
09:03:01 <Calvin> :(
09:03:05 <quicksilver> they are values; or they have values associated with them
09:03:11 <quicksilver> but the value is not the constructor.
09:03:23 <quicksilver> the value is just a function - it can only construct.
09:03:37 <Calvin> So if it a function
09:03:42 <Calvin> if it is a function
09:03:46 <quicksilver> > map Just [1,2,3]
09:03:47 <lambdabot>   [Just 1,Just 2,Just 3]
09:03:47 <mah_b> > map Just [1..5]
09:03:48 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
09:03:49 <mauke> in ocaml, constructors aren't values
09:04:01 <Calvin> Oh
09:04:05 <quicksilver> yeah, in ocaml you have to write map (\x -> Just x) [1,2,3]
09:04:11 <quicksilver> (well, the ML syntax for that)
09:04:17 <quicksilver> which is annoying.
09:05:22 <ajnsit> is the current Phooey library totally broken?
09:05:25 <Ferdirand> > map ($ 42) [Left,Right]
09:05:26 <lambdabot>   [Left 42,Right 42]
09:05:36 <Calvin> Hum can I pattern-match a data constructor
09:05:45 <ajnsit> and by broken I mean logical errors, not compilation errors
09:06:05 <hean> มาเลียให้หน่อย
09:06:37 <Calvin> A function that take a (Maybe) constructor and, do something if it is Just or do an other thing if it is Nothing
09:06:45 <quicksilver> Calvin: no.
09:06:52 <mah_b> @type Nothing
09:06:53 <lambdabot> forall a. Maybe a
09:06:58 <mah_b> @type const Nothing
09:06:59 <lambdabot> forall a b. b -> Maybe a
09:07:00 <quicksilver> Calvin: that is the kind of thing I was getting at when I said they aren't first class.
09:07:04 <mah_b> @type Just
09:07:05 <lambdabot> forall a. a -> Maybe a
09:07:15 <quicksilver> although you could take a Maybe value and do that....
09:08:09 <sm> I'm running PROFILEBUILD ARGS +RTS -hc and getting a .hp file with no samples. What have I done wrong ?
09:08:47 <sm> https://gist.github.com/1320038
09:08:47 <quicksilver> Calvin: if you step a little further back and tell us what you actually want to do perhaps we can be more constructive ;)
09:09:05 <luite> sm:  do you use some nonstandard way to exit the application?
09:09:26 <sm> luite: hmm.. exitSuccess I'm pretty sure
09:09:35 <rotflcopter> # -1/0
09:09:42 <rotflcopter> @ -1/0
09:09:49 <rotflcopter> ;<
09:10:13 <rotflcopter> > -1/0
09:10:14 <lambdabot>   -Infinity
09:10:23 <rotflcopter> in numbers please?
09:10:34 <mauke> that is a number
09:10:50 <rotflcopter> i remember infinity equals maxvalue of type
09:11:49 <sm> luite: the main thread forks off workers and then delays forever until an exception is thrown to it. Maybe the child threads aren't profiled ?
09:12:02 <mah_b> rotflcopter: no, its a special IEEE number, similar to NaN.
09:12:38 <nuncanada>  /join #varnish
09:13:00 <luite> sm: hmm, I'm not sure
09:13:18 <rotflcopter> ahm
09:13:27 <rotflcopter> and 2/0 = 3/0 ?
09:13:37 <mah_b> > 2/0
09:13:38 <lambdabot>   Infinity
09:13:39 <rotflcopter> > 2/0 = 3/0
09:13:40 <lambdabot>   <no location info>: parse error on input `='
09:13:56 <rotflcopter> > 2/0 == 3/0
09:13:56 <lambdabot>   True
09:14:02 <rotflcopter> yeah
09:14:03 <rotflcopter> so 2=3
09:14:07 <rotflcopter> <;
09:15:50 <mah_b> rotflcopter: but NaN != NaN
09:15:59 <sm> no difference when I add -xt
09:16:09 * sm is following http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
09:16:13 <mah_b> > ((1/0)/(1/0)) == ((1/0)/(1/0))
09:16:13 <lambdabot>   False
09:18:08 <rotflcopter> ;/
09:18:16 <rotflcopter> > (2/0) == (3/0)
09:18:17 <lambdabot>   True
09:18:24 <rotflcopter> what makes difference?
09:18:49 <rotflcopter> > 0/0
09:18:50 <lambdabot>   NaN
09:18:51 <sm> well it's a mystery. But in fact maybe I just need a time and allocation profile since I'm debugging excessive GC
09:18:53 <rotflcopter> ;/
09:19:00 <rotflcopter> > 0/0 != 1
09:19:01 <lambdabot>   Not in scope: `!='
09:19:08 <rotflcopter> > 0/0 /= 1
09:19:09 <lambdabot>   True
09:19:30 <quicksilver> rotflcopter: it's just a bunch of rules in a standard (IEEE)
09:19:43 <rotflcopter> > a=0;a/a /= 1
09:19:44 <lambdabot>   <no location info>: parse error on input `='
09:19:47 <quicksilver> I'd call them arbitrary, but that's not entirely fair - the rules were made that way for a reason.
09:19:50 <rotflcopter> > let a=0;a/a /= 1
09:19:51 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:19:53 <quicksilver> however they seem arbitrary to me
09:20:04 <quicksilver> and they have very little to do with accepted mathmetical notions.
09:20:11 <mah_b> quicksilver: imho all other possible rules would have made less sense
09:20:24 <zzing_> quicksilver: That pdf you linked me talks about sum = reduce add 0    - does haskell have reduce?
09:22:20 <mm_freak> zzing_: foldl
09:22:31 <zzing_> ah, that explains it, I have seen that one
09:22:32 <mm_freak> or actually foldl'
09:23:07 <quicksilver> mah_b: I disagree. There are a lot of ways it could have made more sense. However I don't have time to discuss it now :)
09:23:20 <zzing_> Why does it say 'reduce' in the document and miranda, but foldl here?
09:23:32 <rotflcopter> > 0/0 /= 1/1
09:23:33 <lambdabot>   True
09:23:42 <Eidel> Can i compile my haskell-program (on ubuntu) to work in windows?
09:23:46 <rotflcopter> > 2/2 /= 1/1
09:23:47 <lambdabot>   False
09:24:41 <Ikarus> rotflcopter: 0/0 is even allowed *blink*
09:25:11 <rotflcopter> why isnt it 1 ?
09:25:20 <rotflcopter> any number / itself == 1
09:25:29 <rotflcopter> 0 is a number no?
09:25:59 <Ikarus> rotflcopter: 0/0 is either invalid, or 0 because the left side is 0
09:26:06 <Ikarus> depending on the branch of mathematics
09:26:41 <rotflcopter> i always lold on division by zero error
09:26:54 <Calvin> quicksilver http://pastebin.com/qLKCk1jy This is an exemple of what i'm trying to do
09:26:56 <mauke> The paste qLKCk1jy has been copied to http://hpaste.org/53213
09:27:22 <rotflcopter> when old games did that in some delay
09:29:10 <Calvin> this is mainly to compute things, I don't need to store data, so I prefer to represent my champ and item with function instead of data structure
09:41:10 <mah_b> Calvin: what's wrong with that?
09:41:28 <rotflcopter> > 0 /= 0
09:41:29 <lambdabot>   False
09:41:39 <rotflcopter> > 0/0 /= 0/0
09:41:40 <lambdabot>   True
09:41:45 <rotflcopter> > 0/0 /= 1
09:41:46 <lambdabot>   True
09:41:56 <rotflcopter> > 0/0 /= 1/0
09:41:57 <lambdabot>   True
09:42:49 <brisingr> > 1/0 /= -1/0
09:42:50 <lambdabot>   True
09:42:53 <brisingr> > 1/-0 /= -1/0
09:42:54 <lambdabot>   Not in scope: `/-'
09:42:57 <brisingr> > 1/(-0) /= -1/0
09:42:58 <lambdabot>   False
09:43:41 <rotflcopter> haha -0
09:44:26 <rotflcopter> > -0/-0 /= -0/-0
09:44:26 <lambdabot>   Not in scope: `/-'Not in scope: `/-'
09:44:39 <rotflcopter> > (-0)/(-0) /= (-0)/(-0)
09:44:40 <lambdabot>   True
09:44:48 <brisingr> > 0/0
09:44:49 <lambdabot>   NaN
09:44:52 <brisingr> > 1/0
09:44:53 <lambdabot>   Infinity
09:44:54 <Calvin> mah_b technically nothing, it is the "Health 0" that is ugly
09:44:56 <brisingr> there you go
09:45:01 <brisingr> > -1/0
09:45:01 <lambdabot>   -Infinity
09:45:04 <rotflcopter> > -0/-0
09:45:05 <lambdabot>   Not in scope: `/-'
09:45:10 <rotflcopter> > (-0)/(-0)
09:45:11 <lambdabot>   NaN
09:45:13 <rotflcopter> > 0/(-0)
09:45:14 <lambdabot>   NaN
09:45:20 <mauke> rotflcopter: you can stop now
09:45:25 <brisingr> > exp (0/0)
09:45:26 <lambdabot>   NaN
09:45:28 <brisingr> > exp (1/0)
09:45:29 <lambdabot>   Infinity
09:45:37 <brisingr> > exp (-1/0)
09:45:38 <mauke> you can play with ghci at home or /msg lambdabot
09:45:38 <lambdabot>   0.0
09:45:42 <Calvin> the fact that champ1 should take a data contructor as argument, but simply can't because data constructor aren't first class values
09:45:56 <rotflcopter> i meant this as a bugreport
09:46:05 <saati> rotflcopter: it's not a bug
09:46:07 <rotflcopter> 0/0 /= 1
09:46:07 <mauke> rotflcopter: what bug?
09:46:11 <rotflcopter> ;/
09:46:13 <saati> NaN != NaN
09:46:36 <mah_b> rotflcopter: http://754r.ucbtest.org/standards/754.pdf
09:46:37 <brisingr> > isNumber NaN
09:46:37 <rotflcopter> any number / itself = 1 no?
09:46:38 <lambdabot>   Not in scope: data constructor `NaN'
09:47:02 <brisingr> Inf/Inf and 0/0 are nondetermination cases
09:47:06 <mauke> rotflcopter: no
09:47:15 <brisingr> take lim (n -> inf) n / n = 1
09:47:22 <brisingr> lim (n -> inf) 2n / n = 2
09:47:29 <brisingr> they're both inf per inf
09:47:39 <brisingr> or, if n -> 0
09:47:44 <brisingr> then they're both 0/0
09:48:00 <brisingr> so that's why haskell also has the concept of (-0), and nondetermination cases are nan
09:48:48 <rotflcopter> if we make it lim (n -> inf) 2(n / n) = 2 | n/n == 1 then its true
09:49:28 <brisingr> the idea is if you specify 0 it doesn't know "which" 0 it is
09:49:34 <brisingr> so to speak
09:49:34 <mah_b> Calvin: why should champ1 just get the data constructor? it is dependent on the value the constructor wraps.
09:51:04 <Calvin> mah_b Yea, I think I simply badly designed this
09:52:30 <danr> What is the negated pattern in Haskell src exts? http://hackage.haskell.org/packages/archive/haskell-src-exts/1.11.1/doc/html/Language-Haskell-Exts-Syntax.html#t:Pat
09:52:36 <Calvin> I have to go, thank you mah_b and quicksilver
09:53:45 <Eelis> what package do people normally use for non-Unicode-borked regexes?
09:54:04 <mah_b> Calvin: yw (you still can build a general getStat function btw).
09:55:10 <danr> oh it is if you pattern match against a negative integer
09:58:16 <rotflcopter> actually
09:58:36 <Berengal> Are there any parser libraries capable of parsing ambiguous grammars?
09:58:43 <rotflcopter> if 2*0 = 2(0) then (2*0/0) can be 2
09:59:12 <rotflcopter> just didint assume 2*0=1*0
10:00:00 <hpc> Berengal: would it return a list of parses?
10:00:05 <Berengal> hpc: Yes
10:00:16 <hpc> i think there is one, but not sure what the name is
10:00:40 <hpc> there was some discussion in here a week or so ago
10:00:50 <Berengal> Mainly I'm just a bit angry that all my parser combinator libraries refuse to backtrack the way I want to
10:01:26 <rotflcopter> so this is the problem in the logic
10:01:37 <rotflcopter> > 2*0 == 1*0
10:01:38 <lambdabot>   True
10:01:54 <td123> hi, I'm trying to go through lyah and I'm getting stuck on understanding the flip function
10:02:02 <gtirloni> are there any proposal to split cabal into stable/dev/test branches? tried to install haddock with latest HP (ghc 7.0.4) and had to keep decreasing the version until i found something that compiled.
10:02:34 <monochrom> haddock comes with ghc already
10:02:43 <mauke> how would splitting cabal change anything?
10:03:16 <td123> my biggest mental block is that the function type signature is: flip' :: (a -> b -> c) -> (b -> a -> c) but you can define it as flip' f y x = f x y
10:03:23 <gtirloni> monochrom: didn't know that.. thx. guess i should have tried to use it first.
10:03:38 <td123> is the y x pattern matching f's arguments?
10:03:53 <monochrom> flip's
10:03:59 <gtirloni> mauke: stick a 'stable' tag on ghc-something and have a set of packages (almost) guaranteed to compile comes to mind.
10:04:04 <mauke> td123: (b -> a -> c) is b -> (a -> c) is b -> a -> c
10:04:05 <rotflcopter> > 0*0
10:04:06 <lambdabot>   0
10:04:17 <mauke> gtirloni: so don't split cabal?
10:04:20 <rotflcopter> > 0*0 == 1*0
10:04:21 <lambdabot>   True
10:04:30 <rotflcopter> this doesnt sound good either
10:04:44 <gtirloni> mauke: s/split/add tags or whatever/
10:05:03 <rotflcopter> 0*0 should be NAN no?
10:05:10 <mauke> gtirloni: but to ghc-something, not cabal?
10:05:15 <brisingr> 0*0 is 0
10:05:16 <saati> td123: it just reverses the arguments of a two argument function
10:05:22 <brisingr> the nans are
10:05:26 <gtirloni> mauke: no, to the cabal packages. extend it. i think you got it.
10:05:34 <brisingr> 0/0 inf/inf 1^inf inf^0
10:05:35 <rotflcopter> 1*0 = one zero 0*0 = zero zero
10:05:36 <gavri> could someone explain how maxBound :: (Int, Char) works? I'm not sure how a function could be defined for tuples of arbitrary length. I'm only just learning haskell, but would like to understand how this works
10:05:37 <brisingr> inf - inf
10:05:41 <td123> saati: i know what it does, I'm trying to understand how :P
10:05:48 <mauke> gtirloni: what exactly do you count as "cabal packages"? I can think of two
10:05:50 <td123> mauke: thanks, I think that makes sesne
10:05:50 <brisingr> 0*inf
10:05:55 <brisingr> and
10:05:56 <brisingr> hmm
10:05:59 <brisingr> there was one more
10:06:01 <saati> td123: flip f returns a new function
10:06:14 <gtirloni> mauke: http://hackage.haskell.org/packages/archive/pkg-list.html
10:06:16 <td123> saati: thanks, I already figured it out
10:06:17 <brisingr> 0^0
10:06:22 <mauke> gtirloni: so you mean hackage
10:06:26 <saati> td123: what's the problem?
10:06:26 <gtirloni> ok
10:06:28 <brisingr> I think
10:06:30 <brisingr> > 0^0
10:06:31 <lambdabot>   1
10:06:34 <brisingr> nope
10:06:35 <mauke> > maxBound :: (Int, Char)
10:06:35 <lambdabot>   (9223372036854775807,'\1114111')
10:06:39 <brisingr> that's convention one
10:06:58 <brisingr> yes, it's indeterminate
10:07:00 <brisingr> on limits
10:07:03 <mauke> gavri: I don't see what maxBound has to do with functions or tuples of arbitrary length
10:07:54 <rotflcopter> 0*inf should be NaN i guess
10:08:13 <monochrom> gtirloni: haddock version is tied to ghc version. no amount of "stable"/"unstable" distinction would have helped you.
10:08:14 <rotflcopter> anyting ^0 = 1 if im mistaken right
10:08:16 <brisingr> it's 0
10:08:20 <gavri> mauke: isn't maxBound defined for every type that is of typeclass Bounded?
10:08:23 <brisingr> 0^inf
10:08:25 <monochrom> it is also why haddock comes with ghc.
10:08:25 <mauke> gavri: it is
10:08:26 <brisingr> oh wait
10:08:29 <Cale> 0^0 = 1
10:08:36 <Cale> x^0 = 1 in general
10:08:39 <brisingr> Cale: only in classical arithmetic
10:08:48 <brisingr> in calculus it's indeterminate
10:08:59 <rotflcopter> Cale<< save the day ;>
10:09:00 <Cale> "Indeterminate form" is not the same thing as "undefined"
10:09:04 <gavri> mauke: in that case, how could it also be defined for every type of tuple that could exist?
10:09:07 <rotflcopter> readbackpls
10:09:13 <mauke> gavri: huh?
10:09:22 <Cale> "Indeterminate form" is an antiquated term for "discontinuous"
10:09:39 <Cale> more or less
10:09:43 <alex404> Does anyone know where I can find good information on arrow loops and delays?
10:09:44 <brisingr> yes
10:09:52 <alex404> Or a good tutorial, anyway?
10:10:00 <Cale> Just because a function is discontinuous at a point doesn't mean it's undefined there :)
10:10:12 <Cale> alex404: hmmm...
10:10:32 <Cale> alex404: Maybe some of the FRP papers?
10:10:34 <brisingr> It's funny
10:10:39 <brisingr> wait, I've just got an idea
10:10:50 <brisingr> every day when I come in here, I'll ask a stupid question
10:11:03 <brisingr> something like
10:11:09 <rotflcopter> brisingr 0^inf | that looks like NaN to me
10:11:38 <brisingr> when you raise to the power a number smaller than 1 it gets smaller
10:11:45 <Cale> brisingr: It's also required that 0^0 = 1 for many equations from Calculus, like exp(x) = sum over k = 0 to infinity of x^k / k! to work properly. If you have an aversion to defining 0^0, you have to split off the first term of that sum :)
10:11:53 <brisingr> > map (0.5^) [1..10]
10:11:53 <monochrom> oh bother, why do people press enter before their sentence is complete
10:11:54 <lambdabot>   [0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.953125e-3...
10:11:57 <alex404> Cale: So I guess I'm going to just have to wade into some heavy stuff. I would like to model a program as a synchronous circuit... can arrows allow me to do this?
10:13:14 <brisingr> "I want to make a one-line function that does [stuffHere] and [moreStuffHere] and uses (Monad|Arrow|MonadT|MonadPlus|Monoid|ZygoHistoMorphic PreProMorphisms)"
10:13:25 <rotflcopter> Cale<< your opinion about 0/0 ?
10:13:25 <Cale> alex404: Tentatively yes. Appropriate Arrows with loop can basically work like sequential circuits (on interesting values)
10:13:33 <Cale> rotflcopter: That we'll leave undefined
10:13:45 <alex404> Cale: Cheers.
10:13:45 <rotflcopter> > 0*0 == 1*0
10:13:46 <lambdabot>   True
10:13:54 <mauke> rotflcopter: stop. it.
10:14:03 <alex404> Cale: And theoretically I shouldn't need anything more than the 'arrows' package?
10:14:10 <gavri> mauke: thanks! figured this out. they've defined it for tuples from 0 elements to 12 elements. guess it'll break for tuples with more than 12 elements http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:maxBound
10:14:14 <Cale> rotflcopter: Just because a/b is defined as a b^-1, and if 0^-1 is defined, then you want it to have the property that 0 * 0^-1 = 1, but no such number exists.
10:14:46 <Cale> alex404: Uhh, if you want to write your own implementation of Arrow, then you shouldn't.
10:14:52 <monochrom> #math is the proper place to argue over 0 and arithmetic
10:15:06 <Cale> alex404: But you may also be interested in Yampa/Animas
10:15:10 <brisingr> #math hates haskellers
10:15:17 <rotflcopter> im used to calculating with non-existent numbers
10:15:20 <brisingr> which is ironical
10:15:36 <rotflcopter> take imaginary part
10:15:41 <monochrom> just don't tell them you're a haskeller. besides, I don't see why arguing about 0 and arithmetic has anything to do with #haskell
10:15:44 <alex404> Cale: That's sort of what I was getting at. I just hope I can get where I want with only loop and delay.
10:15:55 <Cale> Well, okay, let's suppose we add such a multiplicative inverse for 0 to our set of numbers.
10:16:03 <Cale> and see what kind of disaster happens ;)
10:16:13 <Cale> (assuming we keep the ring axioms)
10:16:44 <brisingr> Cale: just a question, out of curiosity
10:16:49 <rotflcopter> brisbin<< no, actually solving problems
10:16:51 <Cale> Suppose that 0*z = 1. Then 1 = 0*z = (0+0)*z = 0*z + 0*z = 1 + 1
10:17:04 <Cale> So 1 = 2
10:17:05 <Cale> and 0 = 1
10:17:06 <rotflcopter> brisingr<< no, actually solving problems
10:17:09 <brisingr> are you a professor? cause you explain almost perfectly
10:17:22 <Cale> and we'll be able to show that any two numbers are equal (we have the trivial ring)
10:17:26 * hackagebot epub-metadata 2.2.0.1 - Library for parsing and manipulating ePub files and OPF package data  http://hackage.haskell.org/package/epub-metadata-2.2.0.1 (DinoMorelli)
10:17:28 * hackagebot epub-tools 1.0.0.1 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-1.0.0.1 (DinoMorelli)
10:17:31 <Cale> I just have an undergraduate degree in pure mathematics.
10:17:36 <brisingr> rotflcopter: what did I ask you
10:17:50 <brisingr> Cale: that's cool
10:17:56 <rotflcopter> [192808] brisingr which is ironical
10:18:01 <brisingr> oh
10:18:05 <brisingr> I was referring to me
10:18:08 <monochrom> (wouldn't contradict with "you're a professor". afterall, SPJ was a professor and just had an undergrad degree in ...)
10:18:11 <brisingr> *#math
10:18:28 <d-snp> I have this line: (one, two) = function ((length chunk) - 16) (data chunk) -- is there some way to have less parentheses?
10:18:29 <monochrom> (come to think of it, probably Tony Hoare too)
10:19:10 <Cale> (because if 1 = 0, then a = a*1 = a*0 = 0 = b*0 = b*1 = b, for any a and b)
10:19:13 <c_wraith> d-snp: sure.  function application always takes precedence over binary operators
10:19:26 <c_wraith> d-snp: (one, two) = function (length chunk - 16) (data chunk)
10:19:39 <c_wraith> and while you could go further than that, I wouldn't
10:19:44 <d-snp> ah alright
10:20:22 <Cale> So, assuming that we want to keep the property that 0 is an additive identity, that multiplication distributes over addition, and a small handful of other reasonable things like that, 0 having a multiplicative inverse is disastrous.
10:21:17 <brisingr> this is true of any given ring right
10:21:20 <Cale> yeah
10:22:01 <Cale> (might not need all of the ring axioms even, I haven't checked that closely, and I've been awake 22 hours)
10:22:39 <monochrom> beats "been awake 2 minutes"
10:22:39 <captainObvious> sounds like you need, like, some sleep
10:23:18 <Eelis> basvandijk: in the case-insensitive package, why doesn't the FoldCase instance for String do the right thing? it's really weird to have a package specifically devoted to case insensitive string comparison and then purposely have it do the wrong thing.. :)
10:23:27 <rotflcopter> but (0+0) /= 0
10:23:33 <brisingr> really
10:23:36 <Cale> I can't remember who it was that said that I never sleep, but I have to live up to that ideal now.
10:23:38 <brisingr> > 0+0 /= 0
10:23:39 <Cale> ;)
10:23:39 <lambdabot>   False
10:23:45 <brisingr> > (0+0) /= 0
10:23:46 <lambdabot>   False
10:23:56 <rotflcopter> yeah
10:24:10 <Cale> rotflcopter: x + 0 = x is practically the defining property of 0. If your number doesn't have that property, you shouldn't name it 0
10:24:42 <brisingr> in general (at least here in romania where we have odd renaming of stuff) we call it "e"
10:24:51 <d-snp> if I use $ inside a do block, does it apply to the end of the line, or to the entire do block? I'm a bit confused by the do block's syntax
10:25:14 <basvandijk> Eelis: you mean it's better to have foldCase = T.unpack . T.toCaseFold . T.pack ?
10:25:26 <Eelis> basvandijk: if that's what it takes to be correct, yes.
10:25:27 <monochrom> but if you call it e, then e^(i*pi) = -1
10:25:40 <Cale> d-snp: $ is an infix operator like any other. The lines of a do-block are separated by semicolons, or using layout, by the fact that they start in the same column.
10:26:07 <brisingr> monochrom: we can call it C0FFeE
10:27:00 <d-snp> ah thanks Cale
10:27:13 <Eelis> basvandijk: and if one considers that to be too inefficient, then there should simply not be an instance of FoldCase for String. instances that knowingly do the wrong thing should be taboo in Haskell
10:27:58 <basvandijk> Eelis: you're right. The String instance isn't used anyway. It's the ByteString instance which is used a lot
10:28:28 <Cale> d-snp: yeah, so when a $ occurs inside a do-block, it'll just be part of an expression which is (or is inside) one of the statements of the do-block
10:28:28 <Eelis> i actually looked at the package precisely because i needed something that did the right thing for String :)
10:28:48 <Eelis> hence my disappointment
10:29:11 <rotflcopter>  Suppose that 0*z = 1. Then 1 = 0*z = (0/2+0/2)*z = (0/2)*z + (0/2)*z = 1/2 + 1/2
10:29:14 <rotflcopter> :P
10:29:15 <d-snp> I hadn't thought of starting at the same column as a separator yet, that clears some stuff up for me :)
10:29:17 <basvandijk> Eelis: I'm fixing it now...
10:29:25 <Eelis> basvandijk: great, thanks!
10:29:57 <Cale> d-snp: yeah, generally, starting at the same column is a separator, starting in a deeper column is a continuation, and starting in a shallower column closes things
10:30:31 <rotflcopter> so 0 is nothing or number?
10:30:39 <basvandijk> Eelis: I do realize that the (T.unpack . T.toCaseFold . T.pack) implementation is strict. Is that a problem?
10:30:42 <Cale> 0 is a number.
10:30:45 <rotflcopter> isnt NaN is not a number?
10:30:45 <Eelis> basvandijk: not for me
10:30:51 <rotflcopter> and 0 is zero?
10:31:02 * basvandijk wonders if there's a lazy foldCase for Strings?
10:31:09 <Eelis> don't know :/
10:31:43 <hpaste> Dodek pasted “lazy” at http://hpaste.org/53218
10:31:52 <Cale> rotflcopter: NaN is an element of floating point representations of numbers which doesn't itself correspond to a number, and which is used to indicate an error condition.
10:32:07 <Dodek> so basically i wrote a function
10:32:27 <Cale> (though floating point "numbers" don't satisfy many of the properties we usually demand of things we call "numbers" too)
10:32:30 <Dodek> that reads commands from socket and converts it to an infinite list of packets
10:32:52 <Dodek> but the computation turns out not to be lazy
10:33:04 <Cale> They're sort of a badly behaved rough approximation which is still a decent compromise for a lot of practical tasks.
10:33:13 <Dodek> could anyone tell me why it is not the case?
10:33:38 <elliott> Is there a supported way to get a (Ptr CChar) out of a ByteString /without/ the memcpy? I don't need the terminating NUL byte.
10:33:50 <Cale> Dodek: execution of the parts of an IO computation is carried out in sequence, and they are allowed to block
10:34:36 <Cale> Dodek: This picture is confused somewhat by primitives like readFile and getContents, which do some magic to be lazy.
10:34:41 <Danl2620> NaN != NaN
10:34:44 <Cale> (black magic)
10:34:54 <Dodek> oh.
10:35:05 <Cale> In particular, they make use of a thing called unsafeInterleaveIO :: IO a -> IO a
10:35:40 <Dodek> so, basically, what i wanted to do is not what i should do, right?
10:35:40 <Cale> which takes an IO action, and turns it into one which returns a result immediately, but it's a magic result whose evaluation causes the original IO action to occur
10:35:49 <elliott> Aha, there's unsafeUseAsCStringLen.
10:36:16 <Cale> (this evaluation happens at an undetermined time, out of sequence with the rest of the execution of the IO program)
10:36:53 <Cale> It *can* be useful to do this sort of thing, but with sockets you do usually want to be kinda careful about it
10:37:22 <Cale> If you're writing a server, for instance
10:37:55 <Cale> You really want to be sure that sockets get properly closed in a timely fashion, because the OS will eventually choke.
10:39:56 <Cale> But using unsafeInterleaveIO can mean that you've given up any sane way to sequence reading those sockets with the rest of the program, and thus you have to jump through hoops to be very careful that you've done all the reading you'll ever want to do by the time you get to closing them
10:40:21 <wavewave> hi``
10:40:41 <Cale> Dodek: You actually can use hGetContents on your handle there
10:40:59 <wavewave> is Repa using nested data parallelism?
10:41:14 <Cale> Dodek: but it's perhaps not the most advisable thing to do in a production program. It'll work for really simple things
10:41:19 <Hydrant_> hey all, I'm learning haskell and I'm stuck on understanding one example... concat xss = [x | xs <- xss, x <- xs]... which takes a lists of lists and just gets a list... I don't understand how this works... does removing one s always mean "head of the list" ?
10:41:43 <Cale> Hydrant_: that's just a naming convention
10:41:56 <Cale> x is singular xs is plural, xss is really plural ;)
10:42:13 <Dodek> Cale: ok, thanks
10:42:15 <Hydrant_> I understand this as meaning "iterate over xss... as xs"... then "iterate over x as xs"
10:42:16 <Cale> You can name the variables however you want and the program will run the same
10:42:21 <wavewave> Hydrant_ :  xss :: [[a]] , xs  :: [a] , x :: a   in this case
10:42:25 <Hydrant_> but that doesn't make sense to me for some reason
10:42:43 <Cale> x <- l  means to pick x from the list l in all possible ways (in order)
10:42:55 <Cale> So it picks a list xs from the list of lists xss
10:43:01 <Hydrant_> I guess maybe it does make sense... I'm giving a list for iteration in each case
10:43:03 <wavewave> Hydrant_ : you understand what [x| x <- xs ]  means.
10:43:04 <Cale> and then it picks an element x from the list xs
10:43:13 <Hydrant_> wavewave: yes
10:43:26 <Hydrant_> it's just this example confused me, but I'm starting to think I get it now
10:43:35 <Cale> and it does this in all possible ways
10:44:05 <Cale> (such that the later choices change "more frequently" as you run down the resulting list)
10:44:05 <dmwit> foreach(xs in xss) foreach(x in xs) yield(x)
10:44:16 <Hydrant_> okay, I think I get it now... I was overcomplicating it :-)
10:44:18 <Hydrant_> thx
10:44:19 <wavewave> Hydrant_ : is it more clear if it means [x | x <- xs ] where xs is from  [xs| xs <- xss ]
10:44:48 <dmwit> wavewave: That's an incorrect transformation, though.
10:44:56 <dmwit> [xs | xs <- xss] is just xss
10:45:18 <wavewave> dmwit: I know.. I am trying to explain to make sense.
10:45:30 <Cale> Heh, it would be funny to allow a syntax where you could chain the <-'s
10:45:40 <Cale> [x | x <- xs <- xss]
10:45:47 <Hydrant_> for some reason I only unrolled one interation in my head, but I get it now
10:45:48 <Cale> (I'm sleepy)
10:46:00 <Hydrant_> *iteration
10:46:08 <mah_b> Hi, I'm searching for a topic I could write a homework about (~ 15 pages) about physics. I'd like to use Haskell/some programming to support that. Do you know some good topic?
10:46:34 <wavewave> Hydrant_ : [x| ] is a syntatic sugar
10:47:12 <hpaste> synonymous pasted “GADTs type arguments” at http://hpaste.org/53219
10:47:15 <synonymous> Hi channel..I have a question about GADTs
10:47:37 <dmwit> synonymous: You probably didn't want to bind a there.
10:47:42 <Cale> mah_b: heh, there was a cool animation made by kmc recently of a planar quasicrystal pattern formed as the result of summed waves, simulated in Haskell :)
10:47:45 <synonymous> In the above paste, do we refer to the same a?
10:47:47 <dmwit> Foo :: forall b. a -> b -> Foo a
10:47:59 <Cale> http://mainisusuallyafunction.blogspot.com/2011/10/quasicrystals-as-sums-of-waves-in-plane.html
10:48:05 <synonymous> dmwit: exactly
10:48:06 <imphasing> Someday, I'm going to understand all these 'forall' shenanigans :|
10:48:15 <Cale> I don't know if it's a good fit for your assignment, but you reminded me of it :)
10:48:16 <wavewave> synonymous: it's not a GADT in fact...
10:48:17 <dmwit> synonymous: "a" is already bound by the "data Foo a where" syntax.
10:48:30 <synonymous> dmwit: but then i get Not in scope: type variable `a'
10:48:34 <wavewave> synonymous: you are defining an existential type.
10:49:16 <wavewave> data Foo a = forall b. Foo a b
10:49:20 <mah_b> Cale: yes, I've seen that. But I don't think that it is sth they want me to do :(
10:49:35 <dmwit> synonymous: uh... quite
10:49:48 <dmwit> synonymous: Well "Foo :: a -> b -> Foo a" seems to work, too. =P
10:49:50 <copumpkin> dmwit: you need to bind both anyway
10:49:58 <synonymous> dmwit, wavewave: so how could i combine if i need to use GADT features for some other constructor of Foo
10:50:07 <copumpkin> there's no difference in how those are bound
10:50:22 <Eelis> i got this diagnostic when i "cabal install"-d the setlocale package: http://codepad.org/nTh3VKc3 . the package seems to have been installed though. can i ignore the diagnostic or could something malfunction when i use the package?
10:50:28 <dmwit> copumpkin: Yeah, it turns out I'm wrong. Not big surprise.
10:50:37 <wavewave> synonymous: just define another constructor below Foo line?
10:50:46 <copumpkin> :)
10:50:58 <synonymous> dmwit: you are quite right =) forall wasn't req'd
10:53:17 <d-snp> hmm this is weird, I have: data Payload {chunkType :: Word8}; data Chunk {chunkType :: Word8} --, and the compiler complains these are a double declaration of chunkType
10:53:30 <d-snp> how do you usually solve this?
10:53:56 <hpaste> wavewave annotated “GADTs type arguments” with “GADTs type arguments (annotation)” at http://hpaste.org/53219#a53221
10:54:08 <Eduard_Munteanu> By using different names for record fields.
10:54:11 <wavewave> synonymous: just add a new constructor like this
10:54:28 <wavewave> synonymous: and now it is a true GADT.
10:56:33 <synonymous> wavewave: yeh, sure, that was not an issue, i was more looking for getting rid of `forall a` like so (but it never occurred to me that i didn't need `forall b` either):
10:56:44 <hpaste> synonymous annotated “GADTs type arguments” with “GADTs type arguments (annotation) (annotation)” at http://hpaste.org/53219#a53223
10:59:47 <Cale> d-snp: data Payload {pChunkType :: Word8}; data Chunk {chunkType :: Word8} -- PROBLEM SOLVED
11:00:13 <basvandijk> Eelis: the fix of case-insensitive is almost done. I just use the lazy Text functions to case fold a String which means you can use it on infinite Strings: take 5 (foldCase (repeat 'A')) = "aaaaa".
11:00:17 <basvandijk> Eelis: One question: The instance FoldCase Char is actually also broken because it just uses toLower which may not be correct for some languages that map to multiple characters. So I think it's best to just remove the instance. Agreed?
11:00:21 <Cale> d-snp: If you really need the polymorphism, you can define a typeclass for things with a chunkType
11:00:30 <principito> hi
11:00:34 <Cale> like, define data Chunk {cChunkType :: Word8}
11:00:36 <Cale> and then
11:00:36 <Eelis> basvandijk: agreed :)
11:00:43 <Cale> class ChunkType t where
11:00:52 <Cale>   chunkType :: t -> Word8
11:00:53 <wavewave> synonymous : from my viewpoint, eliminating forall a makes sense, but eliminating forall b is rather misleading although it's allowed.
11:01:03 <Cale> instance ChunkType Payload where
11:01:10 <Cale>   chunkType = pChunkType
11:01:17 <Cale> and similar for Chunk
11:01:31 <d-snp> ah
11:01:43 <d-snp> thanks Cale I'll read up on polymorphism then :)
11:01:47 <d-snp> seems to be what I need
11:01:50 <principito> hi
11:02:56 <Cale> d-snp: But if at each point in your program, you will always know whether you have a Chunk or a Payload and don't need to write code which works with either one simultaneously, then just prefixing the field names is the standard answer.
11:03:02 <rotflcopter> > sqrt(-1)
11:03:03 <lambdabot>   NaN
11:03:06 <Eduard_Munteanu> The type-directed name resolution proposal might provide a solution for that sometime.
11:03:08 <rotflcopter> lold
11:03:13 <Cale> > sqrt (-1) :: Complex Double
11:03:14 <lambdabot>   (-0.0) :+ 1.0
11:03:23 <rotflcopter> > sqrt(-1)*sqrt(-1)
11:03:24 <lambdabot>   NaN
11:03:28 <rotflcopter> its -1
11:03:34 <Cale> > sqrt(-1)*sqrt(-1) :: Complex Double
11:03:34 <lambdabot>   (-1.0) :+ (-0.0)
11:03:35 <rotflcopter> so i cannot use ghc for electronics?
11:03:44 <Eduard_Munteanu> rotflcopter: what's -1?
11:03:45 <Cale> rotflcopter: Use the Complex type constructor
11:03:50 <wavewave> rotflcopter : with Complex, you can
11:04:05 <Eduard_Munteanu> The result should be 'i'.
11:04:10 <Eduard_Munteanu> (and it is)
11:04:14 <rotflcopter> coll
11:04:17 <Cale> rotflcopter: You're getting defaulted to Double because you're requesting a floating point operation, and not specifying what type you want
11:04:18 <rotflcopter> whats the syntax?
11:04:26 <wavewave> rotflcopter  : type annotation
11:04:27 <copumpkin> rotflcopter: CAle's just been showing you
11:04:31 <Cale> Look at what I wrote
11:04:36 <rotflcopter> ahm thanks
11:04:52 <Cale> rotflcopter: In a real program, you probably won't even need to annotate your expressions like that
11:05:13 <Cale> rotflcopter: It just needs to be able to infer from somewhere in your program that you're talking about complex numbers
11:05:54 <Cale> (i.e. from one of the type signatures, or by applying an operation which only applies to Complex values)
11:05:57 <wavewave> Cale: but probably we need to hide Prelude.sqrt, don't we?
11:06:00 <Cale> no
11:06:06 <Cale> That is the Prelude sqrt
11:06:09 <Cale> :t sqrt
11:06:09 <lambdabot> forall a. (Floating a) => a -> a
11:06:17 <Cale> Complex Double is an instance of Floating
11:06:19 <wavewave> Cale: oh, right.. good..
11:06:32 <wavewave> nice Prelude design.
11:06:54 <Cale> even things like pi :)
11:06:56 <Cale> :t pi
11:06:56 <lambdabot> forall a. (Floating a) => a
11:07:03 <Cale> > pi :: Complex Double
11:07:04 <lambdabot>   3.141592653589793 :+ 0.0
11:07:28 <brisingr> > sqrt (-1) :: Complex Int
11:07:29 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
11:07:29 <lambdabot>    arising from a use o...
11:07:32 <Cale> > exp (0 :+ pi)
11:07:33 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
11:07:36 <brisingr> > sqrt (-1) :: Complex Float
11:07:37 <lambdabot>   (-0.0) :+ 1.0
11:07:39 <synonymous> wavewave: i agree, but it won't compile with just `forall b`…that was my initial problem :(
11:07:54 <brisingr> what's with the negative zero in i?
11:08:03 <Cale> brisingr: Rounding error
11:08:12 <mkscrg> does anyone know how often the hackage haddock batch job runs?
11:08:21 <Cale> Floating point has a negative zero in it
11:08:46 <Cale> and it's used to indicate the direction from which things were rounded to zero, when it can
11:09:17 <Cale> > isNegativeZero (-0)
11:09:18 <lambdabot>   True
11:09:24 <Cale> > isNegativeZero 0
11:09:25 <lambdabot>   False
11:09:29 <Cale> > 0 == (-0)
11:09:30 <lambdabot>   True
11:09:36 <wavewave> synonymous: I see what's point of your question, now ;-)
11:09:38 <Cale> ^^ comparisons will treat it as equal to 0
11:10:20 <brisingr> Cale: oh
11:10:36 <brisingr> interesting rounding error
11:10:47 <brisingr> I get it they won't when you do x / (-0)
11:10:58 <brisingr> > 1 / (-0)
11:10:58 <Cale> Yeah, it'll be specific to whatever algorithm for computing the square root they did.
11:10:58 <lambdabot>   -Infinity
11:11:10 <tac-tics> @type Infinity
11:11:11 <lambdabot> Not in scope: data constructor `Infinity'
11:11:43 <Cale> Looks like a data constructor when printed, not a data constructor (Scumbag Steve Hat)
11:11:43 <brisingr> @type (1/0)
11:11:44 <lambdabot> forall t. (Fractional t) => t
11:12:29 <monochrom> > (0 :: Double) == (-0)
11:12:31 <lambdabot>   True
11:12:52 <wavewave> synonymous : my way of understanding the scope of type variable from forall is that the type variable had a scoe in parenthesis starting from before forall and the end of it..
11:12:53 <monochrom> > 1/0 == 1/(-0)
11:12:53 <brisingr> > (1/0) == (1/(-0))
11:12:54 <lambdabot>   False
11:12:54 <lambdabot>   False
11:12:57 <monochrom> hehehe
11:13:13 <elliott> :(
11:13:47 <Eelis> can someone with ghc 7.2 check to see if this weird diagnostic is still emitted?: http://codepad.org/sbAXxSzV
11:13:57 <Eelis> i only have 7.0 here
11:14:03 <brisingr> I never could learn the operation priority so I tend to use superfluous parantheses
11:14:11 <Cale> Yeah, floating point has some really sad properties which are nonetheless the result of quite sensible compromises.
11:14:39 <copumpkin> Eelis: yeah, they forgot that debug message on
11:14:41 <brisingr> > (1/0) :: Rational -- I bet $10 that it will get me a type error
11:14:42 <lambdabot>   *Exception: Ratio.%: zero denominator
11:14:45 <copumpkin> Eelis: it's fixed now
11:14:48 <brisingr> damn
11:14:50 <Eelis> copumpkin: ah, great! thanks :)
11:15:09 <tac-tics> Eep! Partial functions! D:
11:15:33 <brisingr> > Just (1/0) :: Maybe Rational
11:15:34 <lambdabot>   Just *Exception: Ratio.%: zero denominator
11:15:36 <tac-tics> Cale: You mean FP in general? Or Haskell's impl?
11:15:37 <Cale> Eelis: but it's safe to ignore anyway
11:15:38 <brisingr> hehe
11:15:45 <Cale> tac-tics: floating point in general
11:15:46 <Eelis> Cale: ok, good :)
11:15:49 <brisingr> > Just Just (1/0) ::Maybe  Maybe Rational
11:15:50 <lambdabot>   `Data.Maybe.Maybe' is applied to too many type arguments
11:15:53 <tac-tics> Cale: Ah yeah, for sure
11:15:55 <brisingr> > Just Just (1/0) ::Maybe ( Maybe Rational)
11:15:56 <lambdabot>   Couldn't match expected type `t
11:15:56 <lambdabot>                                -> Data.Mayb...
11:16:00 <Cale> tac-tics: These things happen in every programming language just the same.
11:16:01 <brisingr> aaahh
11:16:05 <basvandijk> Eelis: case-insensitive-0.4 is released
11:16:07 <brisingr> > Just( Just (1/0)) ::Maybe ( Maybe Rational)
11:16:07 <lambdabot>   Just (Just *Exception: Ratio.%: zero denominator
11:16:10 <Eelis> basvandijk: thanks!
11:16:22 <brisingr> > fix (\x -> Just x)
11:16:22 <Cale> (every one which includes floating point support, anyway)
11:16:23 <lambdabot>   Occurs check: cannot construct the infinite type:
11:16:23 <lambdabot>    a = Data.Maybe.Maybe a
11:16:27 <brisingr> > fix (\x -> Just x) 2
11:16:28 <lambdabot>   Occurs check: cannot construct the infinite type:
11:16:28 <lambdabot>    a = Data.Maybe.Maybe a
11:16:30 <brisingr> aahh
11:16:51 <brisingr> please please
11:16:55 <tac-tics> brisingr: At some point, maybe you could ask lambdabot for an expression that properly evaluates to a value >__>
11:16:56 <brisingr> how do I Just Just Just Just
11:17:02 <brisingr> > 1+1
11:17:03 <lambdabot>   2
11:17:05 <elliott> > Just (Just (Just Just))
11:17:06 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> Data.Maybe.Maybe a)
11:17:07 <lambdabot>    arisin...
11:17:09 <tac-tics> @let onlyJust = Just onlyJust
11:17:10 <lambdabot>  <local>:4:11:
11:17:10 <lambdabot>      Occurs check: cannot construct the infinite type: a = May...
11:17:14 <tac-tics> damn
11:17:27 * hackagebot case-insensitive 0.4 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-0.4 (BasVanDijk)
11:17:34 <brisingr> tac-tics: see? --also, I just noticed the irssi tab completion
11:17:35 <Cale> brisingr: It's possible to allow infinite types like that, but doing so makes a very large number of common typos and small mistakes pass the typechecker and fall on their face at runtime with infinite loops
11:17:40 <monochrom> it is as hopeless as trying to x = [x]
11:17:52 <brisingr> Cale: can you have mutually recursive types?
11:17:57 <Cale> You can
11:18:09 <Cale> data A = A B
11:18:14 <Cale> data B = B A
11:18:22 <monochrom> data Me = Ctor Me
11:18:24 * brisingr takes his time to process that idea
11:18:29 <Cale> a = A b
11:18:32 <Cale> b = B a
11:18:35 <wavewave>  we can do recursive type using newtype, can't we?
11:18:39 <Eduard_Munteanu> Mu Maybe
11:18:43 <Cale> (that's a pretty minimal example of one)
11:19:01 <elliott> brisingr: Imagine if you couldn't -- given "data A = A String [A]" you couldn't have a list of As
11:19:14 <monochrom> clearly, Maybe is not written to be self-recursive
11:19:18 <elliott> Err, unless I've messed that up :)
11:19:27 <Cale> elliott: Well, that's a little different
11:19:35 <Cale> elliott: It's not like the definition of a list depends on A
11:19:36 <Eduard_Munteanu> :t undefined :: Mu Maybe
11:19:37 <lambdabot> Mu Maybe
11:19:43 <Cale> (it's just polymorphic in that case)
11:19:49 <elliott> Cale: Bah, every idea should work up to and beyond polymorphism :P
11:19:52 <Eduard_Munteanu> :t Just undefined :: Mu Maybe
11:19:53 <lambdabot>     Couldn't match expected type `Mu Maybe'
11:19:53 <lambdabot>            against inferred type `Maybe a'
11:19:53 <lambdabot>     In the expression: Just undefined :: Mu Maybe
11:19:53 <synonymous> wavewave: well, apparently yes, i just checked, for regular functions it doesn't work either (e.g. fun :: forall a . a -> b -> b). It simply makes no sense to quantify one type variable explicitely, and another one implicitely
11:20:02 <elliott> > fix (Mu . Just)
11:20:03 <lambdabot>   Not in scope: data constructor `Mu'
11:20:06 <elliott> > fix (In . Just)
11:20:07 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
11:20:11 <monochrom> s/Mu/Rec/
11:20:16 <copumpkin> synonymous: it does if they're quantified in different places
11:20:19 <brisingr> am I right by saying that elliott's example is a recursive data constructor (pretty comon) and yours is a recursive type constructor?
11:20:28 <brisingr> *common
11:20:29 <elliott> my example is not so good :)
11:20:39 <Cale> @let injustice = fix (In . Just)
11:20:39 <monochrom> err sorry, I mean s/Mu/Rec/ for the type name, certainly s/Mu/In/ for the ctor name
11:20:39 <lambdabot>  Defined.
11:21:02 <copumpkin> Cale: what happened to the Natural type that used to be in scope in lambdabot?
11:21:09 <tac-tics> Mu requires an extension, right?
11:21:14 <copumpkin> tac-tics: nope
11:21:15 <Eduard_Munteanu> No.
11:21:16 <Nimatek> question: Does the >> operator determine the order in which the computations are executed?
11:21:19 <Eduard_Munteanu> @src Mu
11:21:19 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
11:21:21 <Cale> copumpkin: I forget what the problems with it were...
11:21:22 <copumpkin> Cale: also, could we lose the overlapping instances for showing functions?
11:21:25 <tac-tics> huh, I learned something then.
11:21:26 <elliott> copumpkin: the Caleskell committee voted to remove it
11:21:30 <copumpkin> > (+1)
11:21:30 <synonymous> copumpkin: indeed…then i don't know why it wouldn't be allowed to do it in one line, or, as before in the case of a GADT
11:21:30 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
11:21:31 <lambdabot>    arising from a use of `...
11:21:40 <Cale> copumpkin: I'd like to lose them, but it's hard to avoid importing instances...
11:21:49 * tac-tics never paid much attention to that chapter in TaPL
11:22:11 <Eduard_Munteanu> tac-tics: it's just a type-level fixpoint operator
11:22:16 <elliott> Cale: Couldn't you just remove lambdabot's instance and let whichever one is imported take over?
11:22:20 <elliott> Assuming it's reasonable.
11:22:27 * hackagebot imgurder 1.2 - Uploader for Imgur  http://hackage.haskell.org/package/imgurder-1.2 (DanColish)
11:22:28 <Cale> elliott: It's not lambdabot's instance in either case
11:22:34 <tac-tics> Eduard_Munteanu: Yeah. I just never played around with it much.
11:22:35 <elliott> Heh
11:22:36 <Cale> (Is it?)
11:22:39 <elliott> Cale: I would expect so
11:22:43 <tac-tics> (It doesn't seem very useful for programming, IMO)
11:22:45 <elliott> Not many things define Show instances for functions
11:23:05 <Eduard_Munteanu> e.g. List = Mu ListF   where   data ListF a f = Nil | Cons a f
11:23:12 <Cale> smallcheck-0.4:Test.SmallCheck
11:23:17 <brisingr> I'm afraid of being wrong so I use question form in anything I say around here?
11:23:18 <Cale> vector-space-0.7.2:Data.NumInstances
11:23:20 <monochrom> equi-recursive vs iso-recursive. yes there is a TaPL paragraph on that. equi-recursive means allows a = [a]. Haskell does iso-recursive
11:23:54 <elliott> Cale: Does anyone use smallcheck in lambdabot?
11:24:03 <tac-tics> Yeah. And I pretty much thumbed past that chapter and never went back :)
11:24:06 <Cale> Not that I've seen in a long time, I think I'll drop that one
11:24:13 <elliott> instance Show (a->b) where
11:24:13 <elliott>   show      = noFun "show"
11:24:13 <elliott>   showsPrec = noFun "showsPrec"
11:24:13 <elliott>   showList  = noFun "showList"
11:24:17 <elliott> Cale: You don't want to do that.
11:24:22 <elliott> Cale: Above is vector-space's instance.
11:24:27 <Cale> I guess I could lose the Data.NumInstances, but they're a lot of fun and are semi-required for vector-space to work sanely.
11:24:27 <elliott> Not very helpful :P
11:24:35 <monochrom> drop them both
11:24:38 * elliott would support losing them too.
11:24:49 <Eduard_Munteanu> Actually List a = Mu (ListF a)
11:24:52 <elliott> Num (a,b) and the like is awful.
11:25:02 <Nimatek> more precise question: Does IO monad (>>) execute the actions sequentially?
11:25:07 <elliott> Nimatek: yes
11:25:08 <monochrom> yes
11:25:15 <Nimatek> Thanks.
11:25:37 <Cale> Nimatek: x >> y is an action which when executed, will execute x, (discarding its result), and then execute y (producing its result as the result of the overall action)
11:25:56 <monochrom> unless it's unsafeInterleaveIO (haha) >> now
11:26:08 <Cale> even if it's unsafeInterleaveIO
11:26:36 <elliott> unsafeInterleaveIO just happens to do very little on execution.
11:26:39 <Nimatek> Yeah, I was just wondering because the Gentle Introduction to Haskell mentions sequential execution only for >>=.
11:26:42 <Cale> (It's just that unsafeInterleaveIO x will do something silly when it executes)
11:27:00 <Cale> Nimatek: x >> y is equivalent in all cases to x >>= (\k -> y)
11:27:06 <elliott> Nimatek: Has anyone pointed you at LYAH yet? :p
11:27:12 <brisingr> @where lyah
11:27:12 <lambdabot> http://www.learnyouahaskell.com/
11:27:12 <elliott> (You can of course read the Gentle Introduction if you wish.)
11:27:18 <elliott> (Just checking.)
11:27:24 <monochrom> better to use x >>= (\_ -> y) to avoid variable capture
11:27:26 <elliott> Cale: Unless k is used in y :p
11:27:36 <elliott> de-Bruijn++
11:27:47 <monochrom> de-Bruijn++
11:28:00 <brisingr> de-Bruijn++
11:28:29 <brisingr> well you know it's a Gentle Introduction™ when you see monads halfway through the first chapter
11:28:31 <Eduard_Munteanu> Assuming that's literally a 'y', it won't capture.
11:28:35 <wavewave> Nimatek: if you want to have more understanding, compare Control.Monad.State.Strict and Control.Monad.State.Lazy
11:29:10 <monochrom> tee hee hee!
11:29:19 <Cale> I've somehow never *loved* the wildcard pattern. (I do use it sometimes.) When I started programming Haskell, I developed a severe aversion to typing underscores which apparently went beyond using them in identifiers.
11:29:25 <monochrom> http://hpaste.org/41790/controlmonadstatelazy
11:30:10 <wavewave> monochrom: good. ;-)
11:30:26 * monochrom is an expert in blowing minds
11:30:38 <brisingr> Cale: if we don't acually use the thing haskell will automatically realise that right?
11:30:48 <brisingr> I am stating everything in question form?
11:30:52 <elliott> monochrom: the most useful code
11:31:02 <Cale> brisingr: Yeah, it makes no real difference. Semantically the _ pattern is equivalent to using a fresh variable.
11:31:28 <Cale> (and probably translates into one)
11:31:32 <Nimatek> Yeah, I know about LYAH, but I was just playing around and suddenly went "hey, is sequential execution guaranteed for this?" and the first google link was the Gentle Introduction page that didn't specify it :p
11:32:04 <dmwit> What's that property called that says any sufficiently powerful logic is broken somehow?
11:32:08 <wavewave> Nimatek: >>= does not guarantee sequential operation. That's common misunderstanding.
11:32:18 <yitz> @karma de-Bruijn
11:32:18 <lambdabot> de-Bruijn has a karma of 3
11:32:23 <Nimatek> wavewave: specifically in the IO monad.
11:32:24 <Cale> Nimatek: yeah, the point of IO actions is to represent sequences of, well, input and output actions whose order matters
11:32:36 <wavewave> Nimatek: but IO is implemented as sequential. right.
11:32:51 * monochrom 's masterpiece of blowing minds is probably http://www.mail-archive.com/haskell-cafe@haskell.org/msg38338.html
11:32:53 <elliott> wavewave: specified as, rather
11:33:12 <wavewave> Nimatek: and getting around the sequential operation is unsafeInterleaveIO
11:33:26 <wavewave> elliott: *nod*
11:33:32 <Cale> They're values which encode what to do and in what order in such a way that evaluating them does nothing (and is pure), but they can be executed (by an impure interpreter) to produce real effects on the world
11:33:48 <elliott> monochrom: I don't even want to know.
11:33:50 <Nimatek> wavewave: That looks fun.
11:33:58 <elliott> Nimatek: Noooo don't do it don't DO it
11:34:01 <sm> dmwit: Goedel's Incompleteness Theorem ?
11:34:02 <Nimatek> Ahaha.
11:34:10 <elliott> Nimatek: It's bad enough that the standard libraries do it!
11:34:36 <wavewave> Nimatek: and since IO is a big black box, I recommend you to compare the difference between Control.Monad.State.Strict and Control.Monad.State.Lazy.
11:34:46 <dmwit> sm: thanks
11:34:58 <Cale> Nimatek: There are a handful of low-level hooks included in GHC (and most other implementations) you can use to do some things as libraries where you'd otherwise end up modifying the compiler.
11:35:10 <Cale> Nimatek: (but they're not for general programming use)
11:35:24 <Nimatek> I shall check them out.
11:35:26 <Cale> They mostly start with 'unsafe'
11:35:52 <wavewave> I personally found the terminology about lazy IO is quite confusing.
11:36:04 <Cale> Quite useful while using the FFI for example, and wrapping impure C libraries up into pure Haskell interfaces
11:36:35 <wavewave> Really StrictIO, Lazy IO but strict in >>= chaining, Lazy IO (with unsafeInterleaveIO )
11:36:52 <wavewave> there are at least three classes like this.
11:36:52 <brisingr> basically when you use unsafeXXX you tell the compiler that you "trust" the function, right?
11:37:04 <thoughtpolice> no, you're telling the compiler to trust YOU
11:37:09 <geheimdienst> iKnowWhatImDoingPerformIO
11:37:18 <c_wraith> Huh.  I've got a case where I want to vary behavior in such a way that type class dependencies will change.
11:37:26 <brisingr> yes, but I wouldn't do that if I weren't trusting the function
11:37:43 <monochrom> "it's trusts all the way down"
11:38:15 <monochrom> (how banks work :) )
11:38:20 <wavewave> by really strict IO, I am referring to strict library.. SIO monad.
11:39:22 <wavewave> wait., strict-io library
11:40:41 <c_wraith> To break it down...  I want to write a single implementation of a data structure that can be backed by Data.Map or Data.HashMap (the new pure one, not the old impure one).  When the backing changes, the type class the keys need to satisfy changes.  There's really no way to address this without making a new type class where different instances depend on the correct class for the key type, is there?
11:45:23 <Saizan> c_wraith: how would you do this if it wasn't for the constraint on the key type?
11:46:32 <elliott> c_wraith: ConstraintKinds?
11:46:50 <c_wraith> Saizan: that's a matter for some experimentation anyway, regarding performance..  But my first choice would be a record type that would be passed in at construction time containing functions to use for the different required behaviors.
11:48:05 <Saizan> c_wraith: then i think it won't be a problem, the constraint will be needed to build this record and that's it
11:48:44 <c_wraith> Saizan: that's not true at all.  the data structure has functions like insert :: key -> val -> S key val -> S key val
11:49:21 <Saizan> so?
11:49:35 <c_wraith> Saizan: and the implementation will need to call functions that have constraints on them in the implementation.
11:49:38 <Saizan> ah, i guess it depends on how the record will look like
11:49:40 <c_wraith> err, that was a bit redundant
11:50:12 <c_wraith> I can't keep the constraint from escaping to the signature for that, can I?
11:50:19 <Saizan> if the record contains methods non-polymorphic on keys/values you can
11:50:36 <c_wraith> Hmm.  Interesting.  That's true.
11:50:59 <c_wraith> But then wouldn't that require a different record type for each (key, value) type pair?
11:51:32 <c_wraith> Hmm.  Not if the record type was polymorphic, I suppose.
11:52:07 <c_wraith> err, now I'm confusing myself
11:52:44 <Saizan> data Methods map k v = M { insert :: k -> v -> map k v -> map k v, ... }
11:53:27 <Saizan> then you can make dataMapMethods :: (Ord k) => Methods Map k v
11:54:35 <Saizan> but the code implementing S only has to care about Methods, not how it's constructed
11:55:54 <c_wraith> hmm.  That sounds right.  I should try this out.  Unfortunately, it's likely that it will be slower than the current version that achieves the same thing by making Methods a type class instead.
11:56:29 <c_wraith> still.  I have benchmarks in place now.  I can measure the overhead.
11:56:42 <Saizan> well, the typing situation doesn't change even if you make Methods a typeclass
11:56:52 <Hydrant_> hey all... quick question... I'm attempting to write last as an exercise, and I defined it this way: last' [] = [] ; last' [x] = x; last; (x:xs) = last xs... unfortunately the type is not what I expect, it's http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a->[a] and it should be [a]->a
11:56:58 <Hydrant_> hrrm
11:57:06 <Hydrant_> hey all... quick question... I'm attempting to write last as an exercise, and I defined it this way: last' [] = [] ; last' [x] = x; last; (x:xs) = last xs... unfortunately the type is not what I expect, it's [ [a] ]->[a] and it should be [a]->a
11:57:19 <c_wraith> well, it does in that you can just make all of S's functions depend on the type class, and not worry about what type classes various instances depend on
11:57:39 <tac-tics> Hydrant_: Did you type (x:xs) or [x:xs]?
11:57:52 <tac-tics> (x:xs) is a List, [x:xs] is a list of lists
11:57:57 <Hydrant_> tac-tics: (x:xs)
11:58:01 <c_wraith> but GHC 7's ability to inline and specialize calls involving typeclasses probably means they will be more efficient, even if somewhat uglier.
11:58:07 <Saizan> c_wraith: which is the same as my record type :)
11:58:08 <Hydrant_> it works when I remove the case of the empty list...
11:58:28 <tac-tics> @let last' [] = []; last' [x] = x; last' (x:xs) = last' xs
11:58:29 <lambdabot>  Defined.
11:58:30 <Saizan> c_wraith: why uglier btw?
11:58:33 <tac-tics> > last' [1,2,3]
11:58:34 <lambdabot>   No instance for (GHC.Num.Num [a])
11:58:34 <lambdabot>    arising from a use of `e_1123' at <int...
11:58:40 <tac-tics> @type last'
11:58:41 <lambdabot> forall a. [[a]] -> [a]
11:58:53 <tac-tics> oh
11:58:54 <tac-tics> lol
11:58:55 <tac-tics> yeah
11:59:01 <tac-tics> last' [] = [] is wrong
11:59:02 <Hydrant_> I'm not sure how to tell it "match one element in a list"
11:59:02 <c_wraith> Saizan: just because it requires that any new behavior have a new type associated with it.  Also, in this case, that the type has 5 type parameters just to cover all the different ways behavior can vary.
11:59:05 <tac-tics> because you're returning a list
11:59:09 <tac-tics> you need to return an "a"
11:59:15 <tac-tics> (which you can't, so the function must be partial)
11:59:26 <tac-tics> @let last' [] = error "last of an empty list"; last' [x] = x; last' (x:xs) = last' xs
11:59:26 <lambdabot>  <local>:6:0:
11:59:26 <lambdabot>      Warning: Pattern match(es) are overlapped
11:59:26 <lambdabot>               In...
11:59:28 <Hydrant_> ah, right.... so it's just going to be undefined on empty list, you're right
11:59:37 <tac-tics> @type last
11:59:37 <lambdabot> forall a. [a] -> a
11:59:41 <tac-tics> @type last'
11:59:42 <lambdabot> forall a. [[a]] -> [a]
11:59:46 <Hydrant_> okay, makes sense... I was the bug
11:59:52 <tac-tics> whatever, that's what you need to do >__>
12:00:28 <Saizan> c_wraith: in this case it seems pretty likely that different maps will be tied to different datatypes anyway, to cope with type parameters you might want to use associated types
12:01:09 <c_wraith> Saizan: well, it's not just the data store that can vary, but also a couple different policies.
12:03:52 <tac-tics> Hydrant_: @let last_new [] = undefined; last_new [x] = x; last_new (x:xs) = last_new xs
12:03:55 <tac-tics> @type last_new
12:03:56 <lambdabot> forall a. [a] -> a
12:05:24 <amgarchIn9> Hi, is there some formalizm or monad-foo to derive a permutation relating two list comprehensions? http://pastebin.com/1HacyNKe Or should it be derived for each case separately?
12:05:26 <mauke> The paste 1HacyNKe has been copied to http://hpaste.org/53227
12:05:42 <Dodek> hey, i'm using GLUT with OpenGL. i want to create a nonresizable window. how can i do that?
12:05:57 <DanBurton> @let safeLast [] = Nothing; safeLast [x] = Just x; safeLast (x:xs) = safeLast xs
12:05:58 <lambdabot>  Defined.
12:06:03 <c_wraith> Saizan: Basically, there are 3 independent ways the data structure can vary, in addition to the key and value types.  I've come to the conclusion I'm not 100% happy with those being part of the type, because it doesn't really add any more semantic content to make them part of the type.  I can use what you suggested to benchmark, anyway.  I suspect it will be notably slower due to lack of inlining ability, sadly.
12:06:09 <DanBurton> > (safeLast [], safeLast [1..5])
12:06:11 <lambdabot>   (Nothing,Just 5)
12:09:01 <Hydrant_> tac-tics: thx
12:10:23 <c_wraith> I guess the one big advantage of having it in the type is that if you know the concrete type at compile-time, you know the exact implementation to use, and can inline it.  Hmm.  Supercompilation would let you do the same thing, if you knew the exact record at runtime.  Come on, supercompilation!  Reach us consumers!
12:14:38 <mm_freak> given an arrow transformer MyArrowT (>~), which has an ArrowApply constraint on (>~) in its Arrow instance, i could just as well turn it into an arrow-to-monad transformer MyArrow m, right? (second trial)
12:20:18 <backpage_com> can anyone plz help me bypassing the textarea on backpage.com?
12:21:57 <DanBurton> backpage_com: um what? Does that have anything to do with Haskell?
12:22:13 <rotflcopter> hit ņ run
12:22:19 <parcs_> mm_freak: an arrow with an arrowapply instance is a monad so yes that should be the case
12:23:19 <mm_freak> parcs_: that's what i think
12:24:57 <mm_freak> parcs_: btw, i'm working on netwire 2.0, which will change a lot, introducing wire checkpoints (for rollbacks) and nondeterministic wires =)
12:25:21 <parcs_> cool
12:26:11 <mm_freak> only downside is that it will invalidate most of the current wiki page
12:28:32 <mkscrg> trying this one again: does anyone know how often the hackage haddock batch job runs?
12:28:43 <c_wraith> every 6 hours, I think.
12:28:48 <c_wraith> At least, that's what it used to be.
12:30:14 <mkscrg> c_wraith: thanks. i must have uploaded soon after the last one
12:30:42 <c_wraith> mkscrg: last time I paid attention (a few months ago), it was every 6 hours, with the last run being about 45 minutes ago.
12:30:52 <MHD> hmm, how fast does Agda compile?
12:31:07 <MHD> I mean with all the operator syntax definitons
12:31:16 <parcs_> hmm actually if the arrow argument requires a arrowapply instance then the arrow transformer can be turned into a monad-to-arrow transformer. it's not guaranteed that the new arrow will have an arrowapply instance (or is it?) so it can't be turned into an arrow-to-monad transformer
12:31:39 <mkscrg> c_wraith: hmm i guess the schedule was shifted
12:32:12 <mkscrg> c_wraith: i'll know in about 90 minutes if six hours is still the interval
12:32:14 <mm_freak> parcs_: the arrow transformer is definitely not a monad
12:32:27 <mm_freak> you can turn it into one, but it wouldn't be very useful
12:32:27 * hackagebot texmath 0.5.0.2 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.5.0.2 (JohnMacFarlane)
12:33:10 <elliott> Is there a way to detect Hackage in a cabal file? It would be nice if I could omit the C library dependency I have and use cpp to stub out the FFI-imported functions, to get documentation on Hackage...
12:33:33 <mm_freak> also i wouldn't know how to make a monad-to-arrow transformer, at least not with a type of kind (* -> * -> *) -> * -> *
12:33:44 <tehgeekmeister> is there a way to get a program with this pattern to use stream fusion?  it seems the splitting and rejoining kills stream fusion, unfortunately.
12:33:44 <tehgeekmeister> main = TI.putStrLn =<< return . T.unlines . L.filter (T.isInfixOf "date_time_string") . T.split (==',') =<< TI.getContents
12:34:44 <parcs_> mm_freak: well it wouldn't be a transformer at all, just an arrow parameterized by a monad
12:34:48 <elliott> Or, actually... does Hackage compile C that's bundled with the package?
12:34:55 <elliott> I'm considering bundling the C library dependency with the package anyway.
12:36:30 <DanBurton> elliott: I think I recall a StackOverflow question relating to the same
12:36:31 <mm_freak> parcs_: oh, then we mean the same…  to me this is an arrow-to-monad transformer
12:36:42 <mm_freak> given an arrow computation it turns it into a monadic computation
12:37:16 <mm_freak> tehgeekmeister: just as it is it looks fine to me, if you are using Data.Text.Lazy
12:37:28 <tehgeekmeister> mm_freak: i am
12:38:24 <tehgeekmeister> mm_freak: it goes much slower than the equivalent in perl, enough so that i can tell there's some subtle inefficiency.  unfortunately, i don't have time to profile it and look into it immediately, so i figured i'd just see if there was something obvious i could do.
12:38:40 <tehgeekmeister> hmm.  maybe i don't have the right flags to make stream fusion happen on?
12:38:49 <tehgeekmeister> will O3 make stream fusion happen?
12:38:59 <elliott> -O3 == -O2, iirc
12:39:02 <mm_freak> i don't know how well Data.Text fuses
12:39:19 <mm_freak> i doesn't really depend on optimization, AFAIK, so -O should suffice
12:39:19 <tehgeekmeister> mm_freak: it lists which functions fuse.  unlines and split do not.
12:39:48 <mm_freak> oh, then of course you don't get fusion
12:40:09 <tehgeekmeister> that blows.  if i used strings, instead, then i might?
12:40:20 <elliott> lol, not likely
12:41:02 <elliott> I don't think there's any fusion for lists at all
12:41:12 <tehgeekmeister> oh, that sucks.
12:41:21 <mm_freak> in some rare cases you might end up with faster code, when using strings, but this is really only when you need to process individual characters heavily
12:41:53 <mm_freak> if you want to get fast stream processing, use an iteratee
12:41:55 <tehgeekmeister> i wanted to see if i could use haskell for some of my log analysis stuff, but this kills it, unless i find a way around it.  but i am determined!
12:42:03 <tehgeekmeister> oh, that'll do it?
12:42:11 <tehgeekmeister> i'll play with those some at home, soon, then
12:42:41 <mm_freak> iteratees give you about the fastest stream processing
12:43:15 <mm_freak> the only faster way is to do it low level, read a block, process it, write it, etc.
12:44:03 <mm_freak> but that's really inconvenient and the speed difference doesn't justify the extra overhead
12:44:13 <tehgeekmeister> cool
12:44:28 <tehgeekmeister> has the community standardized at all on one iteratee implementation?
12:44:39 <earthy> one thing to note though is that you are still fucked if you build up a lazily evaluated summary over your entire input
12:44:56 <tehgeekmeister> i'm not doing that
12:45:03 <tehgeekmeister> i'm basically doing a more complicated grep
12:45:27 <mm_freak> tehgeekmeister: no, the two well known ones are 'enumerator' and 'iteratee' (alphabetically)
12:45:28 <earthy> then be careful when implementing -c. :)
12:45:43 <earthy> enumerator in my mind is the simpler of the two
12:46:07 <mm_freak> tehgeekmeister: there is also a more powerful library called iterIO, but it's quite new and has quite a few extra dependencies (it has predefined enumeratees for SSL, etc.)
12:46:23 <mm_freak> enumerator is the simplest one, yes
12:46:28 <tehgeekmeister> enumerator will be good for me, for now
12:46:32 <tehgeekmeister> i can learn another later
12:46:42 <tehgeekmeister> i'm just trying to find a way to sneak a bit of haskell into the day job
12:46:43 <mm_freak> enumerator is fine, i'm using it, too =)
12:47:59 <parcs_> mm_freak: can you elaborate on your original quesion? you say you have an instance ArrowApply (>~) => Arrow (MyArrowT (>~)) and you're asking if it's possible to convert that into an instance ArrowApply m => Monad (MyArrowT m a) ?
12:48:45 <mm_freak> parcs_: no, i'm pondering about a design choice in netwire 2
12:49:12 <mm_freak> (ArrowChoice (>~) => Wire e (>~) a b) vs. (Monad m => Wire e m a b)
12:49:51 <mm_freak> i can generalize support for nondeterministic wires by turning ArrowChoice into ArrowApply
12:50:20 <mm_freak> but i decided that this generalization is really not necessary
12:50:35 <parcs_> and that you may as well require the Monad constraint?
12:51:20 <mm_freak> parcs_: if i require ArrowApply it seems to me that there is really no point in having an arrow transformer at all…  i could just go back to the old kind
12:52:13 <mm_freak> parcs_: but the arrow transformer variant makes things really simple…  particularly you can have pure wires without an explicit Identity monad
12:52:45 <mm_freak> stepWire :: Wire e (>~) a b -> (a >~ [(Either e b, Wire e (>~) a b)])
12:52:56 <mm_freak> this is really simple…  and it's the full type…  no constraints needed =)
12:54:27 <mm_freak> in netwire 1 there is a type synonym 'type SF = Wire Identity', which personally i find really ugly…  it requires an own module for wire sessions and generally makes things really complicated
12:55:49 <jophish> Yo yo yo!
12:56:15 <jophish> If I have a type synonym for float, it isn't possible to define == for it, right?
12:56:29 <Cale> jophish: right
12:56:37 <Cale> jophish: Because it's already defined
12:56:51 <Cale> (type synonyms don't define new types, just new names for existing types)
12:57:03 <jophish> awesome, thanks Cale
12:57:08 <quicksilver> type synonyms are mostly useful to save typing a really long and fiddly type name
12:57:23 <jophish> gotcha
12:57:34 <quicksilver> if you're trying to actually do something different with the new name, use a newtype
12:57:46 <quicksilver> (which can have its own instances and functions and won't match the old)
12:58:22 <jophish> brilliant, thanks
13:11:53 <elliott> If I use Bool with the FFI, will it be passed as a char or an int?
13:12:43 <copumpkin> it lets you do that?
13:14:07 <elliott> copumpkin: Yep
13:14:21 <elliott> I have a bad feeling it's the former, since I think sizeOf (undefined :: Bool) == 1
13:14:28 <elliott> Which sucks :/
13:14:41 <copumpkin> what's the difference?
13:15:00 <elliott> copumpkin: sizeof(char) == 1, sizeof(int) == probably more than that?
13:15:11 <copumpkin> yes, but how does that affect your foreign function?
13:15:23 <elliott> Well, it might on some architectures :)
13:15:30 <elliott> Nothing says char and int have to be passed in the same way.
13:15:47 <monochrom> Haskell Bool --> C HsBool (in HsFFI.h) == C int.  See Haskell 2010 Report section 8.7
13:16:01 <elliott> oh, thanks :)
13:16:10 * elliott gets that section up
13:16:16 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1700008.7
13:18:18 <monochrom> I would write like "#include <HsFFI.h> ... HsBool my_c_func(HsBool b) { if (b) ... else ... }" in my C side
13:18:46 <monochrom> (just in case Haskell 2037 changes the rules! :) )
13:19:08 <linduxed> if i've got a set of strings that i want to join to one string separated by tabs, how could i do that?
13:19:22 <linduxed> kinda like unwords, but instead of spaces, tabs
13:19:22 <d-snp> hmm such a pity.. there's no way to class fields? :(
13:20:09 <copumpkin> to class fields?
13:20:12 <copumpkin> is classing a verb?
13:20:13 <elliott> monochrom: I'm trying to avoid writing any C :-)
13:22:55 <thoughtpolice> linduxed: you can say (concat . intersperse) "\t" $ ["a","b","c"]
13:23:06 <thoughtpolice> as an example. you have to import intersperse from Data.List
13:23:26 <copumpkin> why not intercalate?
13:23:28 <copumpkin> :t intercalate
13:23:29 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:23:42 <copumpkin> > intercalate "\t" ["a", "b", "c"]
13:23:43 <lambdabot>   "a\tb\tc"
13:24:41 <MHD> Open Question Time: What features do you think Haskell lacks, what do you think it could do without?
13:24:43 <thoughtpolice> well look at that :P
13:24:55 <monochrom> better records!
13:24:58 <linduxed> intercalate seems to do what i need
13:25:01 <copumpkin> better modules!
13:25:08 <linduxed> thx
13:25:19 <blackdog> OTP-like remote coordination system!
13:25:22 <copumpkin> better standard libraries, default superclass instances
13:25:26 <parcs_> mm_freak: that's quite nice actually!
13:25:27 <monochrom> yes, both records and modules!
13:25:34 <thoughtpolice> i think someone has plans for a newer module system actually, don't they?
13:25:40 <monochrom> hackage 2.99999.... !
13:25:50 <blackdog> (wow, we're enthusiastic this morning)
13:26:05 <monochrom> iHaskell !
13:26:06 <MHD> Anything you think haskell really doesn't need?
13:26:13 <copumpkin> subtyping
13:26:20 <mm_freak> parcs_: well, it will take some time…  i'm hoping to make my first release next week
13:26:21 <monochrom> success
13:26:24 <thoughtpolice> copumpkin: doesn't agda have parametric modules?
13:26:28 <copumpkin> yep
13:26:32 <mm_freak> parcs_: i'm basically rewriting it from scratch
13:26:33 <monochrom> fail
13:26:38 <thoughtpolice> that would be awesome
13:26:40 <Taejo> is there a way to enumerate the output of a subprocess with the enumerator family of libraries? enumHandle almost does the job, but it leaves the process as a zombie
13:26:46 <thoughtpolice> (do they allow modules parametrized by modules?)
13:26:56 <copumpkin> nope :) modules don't have a type
13:27:08 <parcs_> mm_freak: heh, and it was only two months old
13:27:31 <mm_freak> Taejo: after the enumeration wait for the process to die
13:27:47 <monochrom> debate topic: do you want a Siri-like thing that writes Haskell for you upon your voice commands?
13:27:51 <mm_freak> Taejo: (enumWhatever =$ iter) <* waitForDeath
13:27:57 <Taejo> mm_freak: I pass the enumerator off to Yesod
13:27:57 <augur> ski: ping
13:28:27 <thoughtpolice> copumpkin: ah so just parametrized by other types. that would still be awesome
13:28:31 <mm_freak> Taejo: oh, in that case you will have to use enumerator concatenation…  just concatenate an enumerator, which doesn't enumerate anything and just waits for the death
13:28:37 <copumpkin> thoughtpolice: yeah, or in the case of agda, values
13:28:51 <Taejo> mm_freak: ok
13:28:51 <mm_freak> parcs_: partly because i'm using it in production
13:29:21 <parcs_> cool
13:29:34 <parcs_> so about that darcs repo... :)
13:29:56 <mm_freak> parcs_: still not online =)
13:30:01 <mm_freak> sorry
13:31:31 <parcs_> heh, no pressure. i just love watching interesting projects evolve :P
13:32:33 <Taejo> mm_freak: any hints on how to do that? I'm struggling to understand enumerators :(
13:33:32 <mm_freak> Taejo: there is a readymade combinator for that, but i don't remember what it's called
13:33:41 <mm_freak> catEnums, concatEnums, something like that
13:34:06 <parcs_> i have like 30 repos that i watch regularly. i _may_ have a problem..
13:34:26 <mm_freak> parcs_: perhaps you are more like the maintainer kind of guy
13:35:07 <elliott> Aww, there's no insatnce (Storable a, Storable b) => Storable (a,b)
13:35:42 <Taejo> mm_freak: yeah, I can see how to concat, it's making the enumerator that has me stuck
13:36:03 <parcs_> nah, i'm more like the "too much free time, has to find a job" kind of guy :P
13:36:14 * Taejo is stuck in a maze of twisty type synonyms, all of the form {enum,it}erat{ee,or}
13:37:06 <elliott> Taejo: the iterIO package's model of things helped me greatly in understanding iteratees; it reduces everything to two types (conceptually, an iterator, and transformers of iterators) and one base composition operator
13:37:21 <mm_freak> Taejo: your enumerator would perform the cleanup and then immediately switch to the Yield state
13:37:22 <elliott> unfortunately it has a few awkward dependencies that make it less attractive for actual use (e.g. unix, HsOpenSSL)...
13:37:40 <mm_freak> Taejo: without the cleanup it's really just one line
13:37:56 <ybit> why does the use of desctructive updates enable clean to generate faster code than haskell?
13:38:01 <Taejo> elliott: because I'm using yesod, I'm stuck with enumerator, but maybe I'll look at it for conceptual help
13:38:08 <elliott> does Clean even still beat Haskell these days?
13:38:14 <ybit> yes
13:38:21 <elliott> Taejo: I recommend it - the documentation is _very_ thorough (http://hackage.haskell.org/packages/archive/iterIO/0.2/doc/html/Data-IterIO.html)
13:39:10 <monochrom> cache locality
13:39:55 <ybit> thanks monochrom
13:40:35 <mm_freak> elliott: in the enumerator framework there is only a single type
13:40:58 <mm_freak> (two types, if you count the minor difference between Iteratee and Step)
13:41:33 <elliott> mm_freak: that's a bit disingenuous: "type"s are types too
13:42:01 <elliott> in iterIO, there's just Iter and Inum -- Onum is just a trivial specialisation of Inum
13:42:27 <elliott> in enumerator, there's Iteratee, Enumerator, Enumeratee...
13:42:36 <mm_freak> elliott: basically in enumerator you have only an iteratee, a consumer, and iteratee transformers (enumerators, enumeratees)
13:42:47 <mm_freak> enumerator is just a special case of enumeratee
13:43:00 <elliott> sure; not saying it's hugely complex, just saying that iterIO is slightly simpler
13:43:07 <elliott> anyway, enumerator unquestionably has many more composition operators than iterIO
13:43:21 <elliott> which was one of my main stumbling blocks with iteratees
13:43:29 <mm_freak> i don't know…  the more interesting part of iterIO is its higher flexibility
13:43:45 <mm_freak> but that doesn't really help Taejo, because Yesod is entirely based on enumerator
13:50:17 <d-snp> argh, namespacing in haskell is a total hell :(
13:50:22 <d-snp> or rather scoping
13:50:49 <acowley> how so?
13:51:54 <acowley> The only limitation that I run into is a desire for first class modules, which could make some factoring/argument passing simpler
13:53:58 <Cale> acowley: Did I tell you about my trick with type families by any chance?
13:54:17 <Cale> (I know I told some people about it in this context, I don't remember who)
13:56:35 <Taejo> mm_freak: turns out Network.Wai.Enumerator has fromHandleFinally which does exactly what I'm after
13:56:50 <acowley> Cale: no, but I'm all ears
13:56:52 <Cale> But yeah, in my experience, a lot of the desire for first class modules comes when you start getting code which is parameterised with a lot of type variables, and you can alleviate a lot of that pain by using a bunch of type families which take a phantom type parameter specifying which type configuration to use.
13:57:32 <acowley> that's an interesting idea
13:57:33 <mm_freak> Taejo: ah, good to know, thanks
13:57:33 <Cale> If you find that all your types are parameterised over what is conceptually the same set of types
13:58:00 <acowley> actually, that's very interesting
13:58:03 <Cale> (which you might otherwise fill in with a module parameter)
13:58:23 <acowley> shoot, I'm not going to be able to spend any time trying it out today, but now I'm itching to do so
13:59:31 <mm_freak> (OT: what does that expression mean, to be itching to do something?)
13:59:54 <acowley> Cale: in my experience with SML and PLT Scheme/Racket, I came to really like first class modules, so I will be a tough sale on this type families approach, but it does sound promising
14:00:16 <acowley> mm_freak: you have an urge that you have trouble getting out of your head
14:00:29 <acowley> mm_freak: like an itch that you can't ignore
14:00:36 <mm_freak> thanks
14:01:07 <Taejo> mm_freak: or rather, it *had*... I'm trying to figure out where it is now
14:01:43 <Cale> acowley: Well, apart from that, you just have all the function and value declarations which would have gone in your argument module, yeah? and normal typeclasses handle that :)
14:01:56 <Taejo> it's not there any more and hayoo doesn't find it
14:02:02 <Cale> acowley: (for which you can use the very same phantom type)
14:02:17 <acowley> Cale: yes, but it's still an extra parameter on every function
14:02:26 <Cale> Yeah, possibly.
14:02:53 <Cale> Ideally, the functions mostly are going to operate on the types which are parametrised on this same phantom
14:03:07 <Cale> and so you won't need extra proxy value parameters
14:03:45 <acowley> Cale: what I like about module parameters is how they cut back on keyboard typing, not necessarily that there's no other way to accomplish the same things
14:04:30 <ybit> re: is clean still faster than haskell, this isn't as up-to-date as the shootout, but still a nice graphical representation taken from the shootout in 2009: http://blog.gmarceau.qc.ca/2009/05/speed-size-and-dependability-of.html
14:05:01 <Cale> acowley: Yeah, this does do that to a decent extent, provided you were going to have more than one type in your configuration
14:05:53 <Cale> acowley: (if you didn't, then ordinary typeclasses without this trick can probably suffice)
14:06:15 <Athas> Bikeshed painting: I'm wrapping a C library 'libfoo'.  What would be a good name for the Haskell package?  'libfoo', 'hs-libfoo', or something more imaginative?
14:06:31 <Cale> Athas: foo?
14:06:42 <Athas> Something feels off about that.
14:06:59 <Cale> Depends on exactly what foo is :)
14:07:01 <acowley> there's a foo oof joke somewhere in there
14:07:11 <Athas> I'm wrapping libxft.
14:07:24 <Cale> Oh, then I'd probably just call it xft
14:07:32 <acowley> Athas: is there an xft executable that could be confused with libxft if you dropped the lib prefix?
14:07:41 <Athas> acowley: not that I know of.
14:07:45 <Cale> http://hackage.haskell.org/package/X11-xft
14:07:56 <Athas> Yes, I know, but I don't think the X11-xft package is very good.
14:08:10 <Athas> And the improvements would be backwards-imcompatible.
14:08:43 <acowley> I will say that while just naming it "foo" is appealing, it is a bit confusing to have to explain to users that typing "cabal install foo" won't actually install the foo library
14:09:11 <Athas> That is a good point.
14:09:28 <acowley> I suppose I lean towards hs-foo for the package name, but just xft everywhere else (i.e. module names)
14:09:46 <Athas> Looking over the Hackage list of packages, 'lib'-prefixes seem to be very rare too.
14:09:48 <ben> It's also fairly annoying because then distributions will put your package into their package manager and suddenly you get "did you mean to install zlib, or the ruby zlib bindings, or the perl zlib bindings, or" situations
14:10:16 <ben> You should make a pun that involves the letter h in a prominent position
14:10:18 <Athas> hs-xft would be a good name, I think.
14:10:29 <Athas> Then distribution packages and the cabal package could have the same name.
14:10:31 <acowley> we're big on puhns
14:10:48 <ben> huge. we're huge.
14:10:55 <elliott> Athas: except no distribution uses that naming scheme to my knowledge :p
14:11:08 <ClaudiusMaximus> distributions have names like libghc-gtk-dev for hackage package gtk
14:11:28 <kmc> Athas, I would name it 'foo'
14:11:30 <Athas> elliott: but at least they have the option!
14:11:31 <acowley> please tell me there's a libuge out there
14:11:45 <kmc> libiberty
14:12:01 <acowley> hackage package: hiberty-hop
14:12:23 <acowley> we will confound any attempt at an alphabetical listing of packages!
14:12:31 <monochrom> hibghc-gtk-dev
14:12:44 <DanBurton> monochrom: needs more acronyms
14:12:55 <monochrom> hgd
14:13:44 <DanBurton> random challenge: make a backronym out of HASKELL. Ready, go.
14:13:49 <acowley> Haskell: staHtically tyHped prograHmming
14:13:54 <Cale> X FreeType -> ForgetfulHype?
14:14:42 <acowley> Higher-order Applicative SK Engineering Language LOL
14:14:44 <acowley> ahem
14:14:48 * acowley goes back to work
14:15:02 <Cale> Gotta work in category theoretic puns somehow
14:15:03 <DanBurton> Hacking And Safe Kleisley Endofunctors Lifting Libraries
14:15:31 <monochrom> DanBurton++
14:15:43 <d-snp> this is weird,     Couldn't match expected type `Int' with actual type `Word16'
14:15:53 <d-snp> isn't Word16 an Int?
14:15:57 <applicative> no
14:16:03 <MHD> d-snp: Int is Int
14:16:05 <DanBurton> d-snp: Of course not, silly. Word16 is a Word16
14:16:09 <d-snp> :(
14:16:09 <MHD> Word16 is Word16
14:16:13 <applicative> > maxBound :: Int
14:16:14 <lambdabot>   9223372036854775807
14:16:15 <Eduard_Munteanu> Kleisli?
14:16:22 <DanBurton> > maxBound :: Word16
14:16:23 <lambdabot>   65535
14:16:28 <MHD> d-snp: They are both Integral class
14:16:42 <d-snp> hmm, so why does this method expect an Int instead of an Integral I guess..
14:16:43 <DanBurton> Eduard_Munteanu: spelling! yes.
14:16:43 <applicative> > minBound :: Word16
14:16:44 <lambdabot>   0
14:17:07 <applicative> d-snp ^^^ minBound is the main point of course
14:17:10 <MHD> > let w :: Word16; w = 1; i :: Int; i = fromIntegral w in print i
14:17:11 <lambdabot>   <IO ()>
14:17:19 * Eduard_Munteanu wonders how you'd pronounce that... I guess Clays-lee
14:17:23 <MHD> > let w :: Word16; w = 1; i :: Int; i = fromIntegral w in i
14:17:25 <lambdabot>   1
14:17:26 <DanBurton> MHD: leave off the print
14:17:37 <MHD> DanBurton: figgured ^^
14:17:41 <Taejo> ok, I'm as confused as a very confused person
14:17:51 <Taejo> so I shall go to bed and try again another day
14:18:45 <DanBurton> > let word16toInt :: Word16 -> Int; word16toInt = fromIntegral in word16ToInt (1 :: Word16)
14:18:47 <lambdabot>   Not in scope: `word16ToInt'
14:18:52 <DanBurton> do
14:18:54 <DanBurton> h
14:18:56 <applicative> d-snp did you figure out the function?
14:19:02 <DanBurton> > let word16toInt :: Word16 -> Int; word16toInt = fromIntegral in word16toInt (1 :: Word16)
14:19:04 <lambdabot>   1
14:19:04 <acowley> I thought it was Kly-slee
14:19:12 <d-snp> ok that fixed it, thanks applicative and MHD :)
14:19:15 <DanBurton> @google kleisli
14:19:17 <lambdabot> http://en.wikipedia.org/wiki/Heinrich_Kleisli
14:19:17 <lambdabot> Title: Heinrich Kleisli - Wikipedia, the free encyclopedia
14:19:22 <applicative> d-snp, oh good
14:19:40 <DanBurton> That is a pretty sad, small little article.
14:19:55 * Eduard_Munteanu proposes Haskell Ain't Some Kludgy Enterprisey Lame Language
14:20:10 * d-snp kludges along in haskell
14:20:18 <sirvaliance> Hi, I am new to haskell and just playing around with some tutorials.  On this section http://learnyouahaskell.com/starting-out#babys-first-functions
14:20:27 <DanBurton> Eduard_Munteanu++
14:20:29 <applicative> excellent section
14:20:30 <sirvaliance> I get this:
14:20:35 <sirvaliance> Prelude> :1 baby
14:20:36 <sirvaliance> unknown command ':1'
14:20:36 <sirvaliance> use :? for help.
14:20:49 <applicative> what did you want to do?
14:20:51 <acowley> Kind of weird nobody's worked in a Lambda
14:21:02 <sirvaliance> Curious as to the stupid mistake I am making :)
14:21:10 <DanBurton> sirvaliance: it's colon L, not colon One
14:21:35 <DanBurton> sirvaliance: can't quite tell with this font which you had there, but :l should work in ghci
14:21:46 <applicative> you can type :load.
14:21:53 <sirvaliance> Just realized it one you said that when I control+f ":1"
14:21:53 <sirvaliance> Thanks
14:21:54 <Eduard_Munteanu> Taejo: what's confusing you?
14:22:13 <sirvaliance> Ahh, so :l is shorthand
14:22:19 <applicative> sirvaliance, yes
14:22:21 <sirvaliance> Thanks guys, will continue working through it
14:22:36 <DanBurton> :) Learn You a Haskell is a great way to start
14:22:45 <applicative> sirvaliance: you might take a look at the options with :?  there are a pile of them, but some are obvious
14:22:56 <Taejo> Eduard_Munteanu: turning an enumerator into a response in Yesod
14:22:57 <DanBurton> @quote Eduard_Munteanu Haskell Ain't Some Kludgy Enterprisey Lame Language
14:22:58 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
14:23:05 <DanBurton> @remember Eduard_Munteanu Haskell Ain't Some Kludgy Enterprisey Lame Language
14:23:05 <sirvaliance> applicative: Will do, thanks
14:23:06 <lambdabot> Done.
14:26:08 <dradtke> hey, I'm having trouble getting ghc to build from source. can anyone help out?
14:26:08 <acowley> I tried this out the other day but didn't get any bites: has anyone encountered a right associative version of (<*>)? I found a use for it and have a nagging feeling I'm missing something
14:33:20 <Ferdirand> @type (<*>)
14:33:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:33:47 <byorgey> acowley: I recall a discussion of something like that in the paper "Tillmann Rendel and Klaus Ostermann. Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing. In Proc. of Haskell Symposium, 2010."
14:36:16 <acowley> byorgey: Thanks! Impressive memory
14:36:34 <acowley> that's very close to how I'm using it, so I guess I'm not doing anything silly
14:42:57 <zzo38> One idea I have for a Haskell extension is to have a function type that can only hold bijective functions; it would be useful with reversible computing, as well as to represent numeric equality in types as propositional logic. Other suggestion I have is to support empty case blocks!
14:44:24 <MHD> empty case blocks?
14:45:07 <ion> > case 42 of { }
14:45:08 <lambdabot>   <no location info>: parse error on input `}'
14:45:18 <ion> What would that return?
14:45:22 <copumpkin> zzo38: how would you enforce the bijection?
14:45:38 <copumpkin> zzo38: empty case matches are okay, for EmptyDataDecls, but I'm not sure there's a huge benefit in a non-total language
14:45:39 <zzo38> MHD: For example:   data Zero; contradiction :: Zero -> a; contradiction x = case x of { };
14:46:46 <zzo38> copumpkin: I am not sure how to enforce the bijection, there would be some kind of syntax for it, I suppose. As well as a way to automatically compute the inverse of the function at compile-time.
14:47:09 <copumpkin> zzo38: that's moving into the realm of dependent types, though
14:47:13 <copumpkin> you want the type system to be aware of your values
14:47:29 <copumpkin> of the values of your values, I mean, rather than their types :)
14:47:45 <copumpkin> and even dependently typed languages can't automatically figure out a bijection for you
14:47:55 <copumpkin> if it were to work, it'd have to be extremely restricted
14:48:04 <copumpkin> like maybe you only map between constructors or something like that
14:48:08 <MHD> what would an empty case statement accomplish again?
14:48:20 <copumpkin> MHD: it's the natural way to pattern match on an empty type
14:48:33 <acowley> MHD: it gives the type checker an explicit marker to demonstrate case exhaustion
14:48:35 <copumpkin> but you only get empty types with an extension (EmptyDataDecls) and even they aren't truly empty
14:48:41 <monochrom> if you allow empty type, you should allow empty case
14:48:43 <MHD> and return undefined?
14:49:00 <copumpkin> MHD: effectively, yeah
14:49:07 <kmc> why do certain modules, like GHC.IO, not show up in the online haddocks?
14:49:07 <copumpkin> MHD: but the idea is that it would never happen
14:49:13 <MHD> that's... stupid?
14:49:23 <copumpkin> MHD: it's used all the time in agda, for example
14:49:25 <MHD> I see the empty type business
14:49:30 <monochrom> if you allow empty type, you should allow empty case
14:49:41 <kmc> oh, it seems GHC.IO uses {-# OPTIONS_HADDOCK hide #-}, but why?
14:49:45 <copumpkin> I don't really see the benefit
14:49:49 <copumpkin> sure, if it took no effort
14:50:00 <copumpkin> but there's literally almost no win for the effort of changing the syntax to support it
14:50:28 <blackh> kmc: To discourage the use of compiler-specific packages in programs?
14:50:42 <monochrom> it is just cognitive consistency. empty type and empty case go hand in hand
14:50:56 <kmc> blackh, plenty of GHC.* modules have docs
14:51:44 <kmc> "discouraging" its use that way is dumb
14:51:52 <kmc> if you actually want to prevent people from using the module, hide it
14:52:06 <kmc> if you want to "discourage" them, document it with sufficient warnings
14:52:17 <blackh> I am only guessing.
14:52:24 <kmc> but intentionally hiding the docs is just wasting people's time and causing them to make additional mistakes
14:52:32 * hackagebot regex-applicative 0.1.4 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.1.4 (RomanCheplyaka)
14:52:33 <kmc> right, I do not think that's the actual reason
14:52:54 <copumpkin> http://hackage.haskell.org/packages/archive/base/3.0.3.2/doc/html/GHC-IO.html
14:53:00 <copumpkin> I think the docs are just broken
14:53:01 <MHD> Is there a DAWG package in haskell?
14:53:02 <copumpkin> sometimes haddock fails
14:53:06 <copumpkin> MHD: no, but I've wanted one
14:53:11 <MHD> yeah
14:53:12 <kmc> copumpkin, it has {-# OPTIONS_HADDOCK hide #-}
14:53:18 <copumpkin> oh, I see
14:53:24 <copumpkin> kmc: file a bug :)
14:53:30 <kmc> bah
14:53:37 <MHD> actually "data DAG a" would be even better
14:53:40 <copumpkin> I'll file a bug?
14:53:48 <copumpkin> MHD: that's tricky to do
14:53:57 <monochrom> to discourage spreading redundant docs all over the place
14:54:33 <kmc> i think the reason it's hidden is that these things are re-exported by other modules
14:54:38 <kmc> and you're supposed to read the docs there
14:54:44 <kmc> which module re-exports unsafeDupablePerformIO?
14:54:53 <copumpkin> System.IO.Unsafe?
14:55:01 <kmc> oh, it is there
14:55:10 <kmc> sigh, I should pay more attention
14:56:14 <acowley> I think I recall seeing some a clever haskell snippet for producing an identity matrix, anyone remember it?
14:56:51 <copumpkin> acowley: as a list of lists?
14:56:58 <MHD> acowley: what matrix size?
14:57:00 <acowley> copumpkin: yes
14:57:09 <acowley> MHD: that's a parameter
14:57:16 <MHD> hmmm
14:57:33 <acowley> I have a lame zipWith to do it in some code and its lameness irks me
14:57:59 <copumpkin> hmm
14:58:00 <kmc> > let i n = [ fromEnum (x==y) | x <- [1..n], y <- [1..n] ] in i 3
14:58:02 <lambdabot>   [1,0,0,0,1,0,0,0,1]
14:58:44 <Eduard_Munteanu> acowley: with hmatrix you can probably get that really easy
14:59:09 <acowley> kmc: that's not bad! I never think of using list comprehensions
14:59:48 <acowley> Eduard_Munteanu: I was thinking of golfier approaches
15:00:41 <MHD> any of you guys know code bowling?
15:01:08 <mike-burns> I've written Java, yes.
15:01:12 <copumpkin> golfing mode engaged
15:01:17 <acowley> kmc: now work in the one-list-per-row aspect in 5 characters or less without adding a dependency
15:01:32 <monochrom> code bowling is when you smash down code?
15:01:36 <MHD> mike-burns: that comment suited you nick
15:01:58 <MHD> monochrom: golf is as few points as possible, bowling is as many~.
15:02:12 <MHD> basically, convulted and weird ways of doing things
15:02:29 <MHD> haskell submissions are usually rife with unary arithmetic
15:02:52 <acowley> convoluted and weird actually go hand-in-hand with golfing when things work out
15:04:07 <MHD> acowley: in bowling your code needs to be incomprehensible and extrememly verbose
15:04:15 <applicative> > > iterate succ 10 !! 5
15:04:16 <lambdabot>   <no location info>: parse error on input `>'
15:04:18 <applicative> > iterate succ 10 !! 5
15:04:19 <lambdabot>   15
15:04:50 <copumpkin> > let f n = reverse . take n . map (take n) . tails . cycle . reverse . (1:) $ replicate (n - 1) 0 in f 5 -- acowley
15:04:51 <lambdabot>   [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]]
15:04:52 <monochrom> bowling code is a job for computers
15:05:09 <MHD> acowley: Got an algebraic data type? "show" it and case-match the resulting string...
15:05:13 <copumpkin> the same approach will probably work without all the reversing
15:05:13 <acowley> copumpkin: you have a gift
15:05:30 <copumpkin> :D
15:06:00 <acowley> copumpkin: mine was: zipWith ((take n .) . drop) (0:[n,n-1,1]) (repeat (cycle (1:replicate (n-1) 0)))
15:06:10 <MHD> also, in bowling you never go wrong with peano arithmetic.
15:06:20 <acowley> s/bowling/life
15:06:24 <copumpkin> ah, cute
15:06:29 <copumpkin> wait
15:06:31 <monochrom> in bowling, you only need to count from 0 to 10.
15:06:31 <copumpkin> zipWith and repeat
15:06:34 <copumpkin> combine to make map
15:06:39 <acowley> !
15:07:36 <MHD> In a challenge with testing for congurent natural numbers I saw an agda snippet that would only compile if the given numbers were congurent
15:08:06 <copumpkin> > let f n = reverse . take n . tail . map (take n) . tails . cycle . (1:) $ replicate (n - 1) 0 in f 5 -- one less reverse
15:08:11 <lambdabot>   [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]]
15:08:20 <acowley> I actually added a typo in what I typed, too
15:08:27 <kmc> one of the first programming exercises i ever did was a program to compute bowling scores
15:09:28 * monochrom has fun with template haskell and quasi quoting
15:10:02 <monochrom> [lit|  skjdf  [|  sdkjf  |]
15:10:14 <acowley> > let g n = map (take n . flip drop (cycle (1:replicate (n-1) 0))) (0:[n-1,n-2,1]) in g 5
15:10:16 <lambdabot>   [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,0,1]]
15:10:16 <applicative> > let os = 0:os ; oos = 1:os  ; master = iterate (0:)  oos ; crop n = take n . map (take n) in crop 5 master
15:10:18 <lambdabot>   [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]]
15:11:04 <copumpkin> applicative: cute!
15:11:25 <copumpkin> fix (0:)
15:11:29 <copumpkin> instead of os
15:11:32 <applicative> oh indeed
15:11:39 <copumpkin> 1:fix(0:)
15:12:13 <copumpkin> > take 5 . map (take 5) $ iterate (0:) (1:fix(0:))
15:12:14 <lambdabot>   [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]]
15:12:19 <copumpkin> and applicative wins the day
15:12:41 <mmos1127> I want an instance of Enum, but I don't want it to have values 0, 1, 2, ... instead I want -2, -1, 0, 1, 2. what must I implement in an instance of enum?
15:12:48 <acowley> yeah that is pretty fantastic
15:13:15 <copumpkin> it's so simple too
15:13:24 * MHD applauds applicative
15:13:26 <acowley> as it should be
15:13:27 <zzo38> I don't know exactly how a syntax for bijective functions would work, though.
15:13:28 <copumpkin> does exactly what you'd expect it to do, except nobody thought of it
15:13:43 <copumpkin> zzo38: that's because bijectivity can't really be checked syntactically
15:14:15 <monochrom> nice, $( blahblah [lit| sdkjf |] )  also works
15:14:30 <zzo38> But it seem to me, if there can be such a type, that it could be used to represent equality of numbers in logic (similar to Curry-Howard)
15:14:36 <copumpkin> @pl \n -> take n . map (take n) $ iterate (0:) (1:fix(0:))
15:14:36 <lambdabot> ($ iterate (0 :) (1 : fix (0 :))) . liftM2 (.) take (map . take)
15:14:38 <copumpkin> there
15:14:40 <mm_freak> :t map (\(xs,ys) -> xs ++ 1:ys) . liftA2 zip inits tails . flip replicate 0 . pred
15:14:41 <lambdabot> forall a. (Num a) => Int -> [[a]]
15:14:41 <copumpkin> ;)
15:14:45 <mm_freak> > map (\(xs,ys) -> xs ++ 1:ys) . liftA2 zip inits tails . flip replicate 0 . pred $ 5
15:14:46 <lambdabot>   [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]]
15:15:42 <mm_freak> :t liftA2 (zipWith (\xs ys -> xs ++ 1:ys)) inits tails . flip replicate 0 . pred
15:15:43 <lambdabot> forall a. (Num a) => Int -> [[a]]
15:15:46 <zzo38> For example, if <-> is type of bijective functions then you can have:   (Maybe (Maybe Zero), Maybe (Maybe (Maybe Zero))) <-> Maybe (Maybe (Maybe (Maybe (Maybe (Maybe Zero)))))  I would think
15:15:48 <mm_freak> better =)
15:16:34 <copumpkin> mm_freak: you can pl that lambda not too badly
15:16:42 <copumpkin> @pl liftA2 (zipWith (\xs ys -> xs ++ 1:ys)) inits tails . flip replicate 0 . pred
15:16:42 <lambdabot> liftA2 (zipWith ((. (1 :)) . (++))) inits tails . flip replicate 0 . pred
15:16:47 <copumpkin> there, beauty
15:16:53 <copumpkin> I gotta say, I still prefer the other one though :P
15:16:55 <mm_freak> > map (arr (uncurry (++)) . second (1:)) . liftA2 zip inits tails . flip replicate 0 . pred $ 4
15:16:57 <lambdabot>   [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]
15:16:58 <zzo38> I think a successor monad is like a Maybe monad
15:16:58 <copumpkin> it's short and clear!
15:17:12 <mm_freak> yeah, the other one is nicer
15:17:15 <mm_freak> i just like arrows =)
15:17:20 <monochrom> @arr shorter
15:17:21 <lambdabot> Har de har har!
15:17:25 <copumpkin> I wouldn't use arr there
15:17:32 <acowley> yeah it's actually one of the least convoluted ones, oddly enough
15:17:39 <copumpkin> > map (uncurry (++) . second (1:)) . liftA2 zip inits tails . flip replicate 0 . pred $ 4
15:17:40 <lambdabot>   [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]
15:17:41 <mm_freak> copumpkin: habit
15:17:44 <copumpkin> pff
15:17:48 <zzo38> But would you be able to prove non-equality using the system of bijective functions like that?
15:18:08 <mmos1127> Okay I found it on the web-- minimal complete definition of Enum is 'toEnum' and 'fromEnum'
15:21:26 <mm_freak> found a nicer solution
15:21:38 <mm_freak> :t liftA2 (zipWith (++)) inits (map (1:) . tails) . flip replicate 0 . pred
15:21:39 <lambdabot> forall a. (Num a) => Int -> [[a]]
15:21:59 <mm_freak> > liftA2 (zipWith (++)) inits (map (1:) . tails) . flip replicate 0 . pred $ 4
15:22:01 <lambdabot>   [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]
15:36:20 <MHD> man, deciding on a consistent  syntax is haaaaaaaaaaaaard
15:36:31 <MHD> i don't want to commit to any method names
15:36:43 <MHD> hmmmm
15:46:54 <tyrantul> exit
15:54:07 <ski> augur : SYN
15:58:49 <gwern> @quote
15:58:49 <lambdabot> kmc_ says: Haskell may have syntactic sugar, but C++ has syntactic strychnine
16:08:35 <gtirloni> when newbies like me complain about cabal and things that don't build.. i think it'd be nice to point them to this: http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
16:10:58 <gtirloni> just saying because it clear a lot of doubts :)
16:11:05 <gtirloni> s/clear/cleared/
16:20:58 <HugoDaniel> hi
16:38:40 <mm_freak> is there a list monad transformer with a MonadFix instance?
16:39:08 <Axman6> @instances MonadFix
16:39:10 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
16:39:24 <Axman6> heh, i didn't expect that to actually work =)
16:39:29 <mm_freak> it's not in transformers, mtl, monadLib or logict
16:39:58 <mm_freak> lambdabot does what you want, not what you command ;)
16:40:41 <mm_freak> you could have written @icecreamcakes and it would have come up with the same answer
16:42:34 <kfish> chocolate, honey, mango, potato, cabbage, lambda, asparagus, kliesli
16:42:53 <blackdog> that's one weird-arse shopping list
16:43:05 <kfish> i'm not really into ice-cream
16:44:13 <dradtke> hey, can anyone help me with building haskell-platform from source?
16:44:23 <kfish> what platform?
16:44:31 <kfish> ie. what os/distro
16:44:31 <dradtke> I keep getting an error asking if I've installed the profiling libraries for package `base'
16:44:36 <dradtke> opensuse
16:44:51 <kfish> which ghc?
16:44:59 <dradtke> 7.2.1
16:45:06 <dradtke> I built it from source
16:45:10 <dradtke> trying to do the same with the full platform
16:48:30 <dradtke> this is platform 2011.2.0.1, btw
16:50:05 <dradtke> ah, I might've found the reason it's failing. I build ghc with recommended settings, which is no profiling
16:50:27 <dradtke> how do I disable library profiling for haskell-platform?
16:51:41 <td123> does haskell have any matrix libraries?
16:51:50 <Axman6> yes
16:51:53 <Axman6> see hmatrix
16:52:10 <td123> will do thanks
16:52:15 <dradtke> awesome, --disable-profiling flag worked; it's building now.
16:52:24 <Axman6> there's also some pure haskell libraries which can be used for pretty high efficiency matrix computations like repa
16:55:52 <td123> oh wow, it has some APL like functions
17:03:40 <stribor> can someone exmplain this paramethars for parseTest function ....Parsec s () a -> s -> IO ()
17:03:54 <stribor> so parseTest takes parser s?
17:04:05 <stribor> and a is for input string?
17:04:25 <kmc> (Parsec s () a) is a parser of 'a's
17:04:35 <kmc> the Parsec type constructor takes a few other parameters
17:04:35 <Twey> s is the type of the internal state of the parser
17:04:52 <Twey> () is… the return value, I think
17:05:00 <kmc> i think s is the type of the stream it will read from, and () is the type of the user-provided state
17:05:02 <kmc> here the uninteresting type ()
17:05:14 <Twey> Oh, perhaps, yes
17:05:18 <stribor> in (Parsec s() a)...what is s and what is () and a
17:05:18 * Twey should really remember this stuff
17:05:28 <kmc> s is the type of the stream it will read from
17:05:33 <kmc> which you will probably instantiate to String
17:05:45 <kmc> () is the type of user-provided state; you're not using that so it's the uninteresting type ()
17:06:13 <kmc> a is the type of values the parser will produce
17:06:13 <kmc> stribor, you should import Text.Parsec.String
17:06:13 <kmc> it has this synonym:   type Parser = Parsec String ()
17:06:13 <kmc> then you can just say (Parser a)
17:06:14 <stribor> kmc: ok
17:07:11 <dradtke> I'm running into issues building alex-2.3.5
17:09:35 <ezyang> Hey, anyone want to help me pre-read a blog post? It's about F* and self-certifying type checkers.
17:12:35 <Eduard_Munteanu> ezyang: hm, maybe, you could post a link
17:12:48 <dradtke> anyone here have experience building haskell-platform from source?
17:13:09 <Eduard_Munteanu> dradtke: why not ask about your specific problem?
17:13:21 <monochrom> yes, see my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
17:13:23 <Eduard_Munteanu> Like, why isn't Alex building.
17:13:40 <dradtke> Eduard_Munteanu: I wasn't sure if anyone had heard me =)
17:13:58 <dradtke> Eduard_Munteanu: I'm not actually sure why it's not building, there really isn't a descriptive error. Trying to narrow that down right now
17:14:03 <monochrom> but I have no experience running into problems
17:14:38 <acowley> you lead a blessed life
17:15:21 <dradtke> there was initially an error that I fixed by manually applying this patch (http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=635113), but now it keeps complaining about an error with no real description
17:15:23 <monochrom> yes, software works 100% for me all the time, and it is just me. I can't even reproduce all sorts of problems that people say happened. even if I try.
17:15:48 <monochrom> I applied no patch and I did not use debian at all.
17:16:08 <dradtke> monochrom: I'm on openSUSE, but the issue is in the current release of haskell-platform
17:16:48 <acowley> I wish more things form hackage would just work
17:16:49 <dradtke> monochrom: I can't disable it, either. using ./configure --without-alex does nothing
17:17:21 <stribor> can anyone help me with example of using this function char :: Char -> ReadP Char
17:17:30 <monochrom> you know that haskell platform versions work best with matching ghc versions, don't you?
17:18:00 <kmc> stribor, why are you using ReadP?
17:18:03 <kmc> it's not generally recommended
17:18:16 <dradtke> monochrom: is there a haskell platform that corresponds with the most recent ghc, or should I try downgrading ghc?
17:18:30 <acowley> why do you need the platform?
17:18:31 <stribor> kmc: just trying to follow up on this tutorial->http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
17:18:41 <Eduard_Munteanu> ezyang: isn't "typechecker" / "typechecks" more common than "type checker" ... ?
17:18:41 <monochrom> no haskell platform for ghc 7.2.1, but you can try. some hacking required
17:19:04 <monochrom> lastest haskell platform is 2011.2.0.1 matching ghc 7.0.3
17:19:44 <monochrom> (ghc 7.0.4 should be ok too)
17:20:04 <acowley> Eduard_Munteanu: I don't think so
17:20:05 <ezyang> Oh, you're right.
17:20:34 <acowley> in my email, at least, I have many more instances of "type checker" than "typechecker"
17:20:53 <monochrom> acowley: the platform is a workaround to your "wish more things from hackage would just work" :)
17:21:00 <acowley> monochrom: :/
17:21:11 <ezyang> Eduard_Munteanu: Fixored.
17:21:27 <elliott> Text is lower-overhead than String even for small strings, right? (< 6 chars)
17:21:33 <Eduard_Munteanu> Hm, I'm unsure, I don't disagree with acowley
17:21:51 <elliott> acowley: I'd prefer type-checker
17:22:03 <elliott> Typechecker isn't much of a word, but type checker is upsettingly disconnected
17:22:45 <monochrom> type-checker
17:22:48 <acowley> Well, BCP seems to use typechecker in formal writing
17:22:58 <Danl2620`> TypeChecker
17:23:08 <monochrom> haha camel case
17:23:14 <acowley> It's entirely possible I derail the spelling in email conversations on the matter
17:23:15 <monochrom> ZomboCom
17:23:31 <elliott> type~checker
17:23:59 <acowley> perhaps you could typeset the two words in different colors
17:24:26 <acowley> I'm also partial to the Seinfeldian overtones of typeCHECKER
17:24:30 <Eduard_Munteanu> Wouldn't that make them seem even more disconnected from each other?
17:24:45 <acowley> Eduard_Munteanu: not if it's printed in monochrome!
17:25:14 <Eduard_Munteanu> Oh, no space but different colors
17:25:21 <Eduard_Munteanu> :/
17:27:00 <dradtke> do I have to install the ghc binary? It doesn't look like it comes pre-compiled
17:27:19 <monochrom> yes you have to install ghc separately
17:27:28 <monochrom> (have you read my article yet?)
17:27:45 <Eduard_Munteanu> You do need a compiler to bootstrap GHC, it's self-hosted after all
17:28:21 <ezyang> Usually your distro has a GHC binary. Or you can just download one for your platform.
17:28:34 <dradtke> monochrom: yes, I read the article, but I assumed a "binary" wouldn't need to be compiled
17:28:37 <Eduard_Munteanu> ezyang: anyway, I can't find typos or other problems
17:28:38 <monochrom> usually your distro has the wrong version
17:29:09 <ezyang> Eduard_Munteanu: Cool. Anything about content?
17:29:21 <monochrom> yes, there are ghc binaries and they don't need to be compiled
17:29:41 <dradtke> monochrom: I just downloaded one and can't find the executable anywhere
17:30:08 <napping> dradtke: it's the other way around - you probably have to download a binary, because it's hard to compile GHC without GHC
17:30:24 <monochrom> Unpack the binary tarball and change directory into the unpacked. Then
17:30:24 <monochrom> ./configure --prefix=chosen-directory
17:30:24 <monochrom> make install
17:30:29 <monochrom> straight from my article
17:30:34 <dradtke> napping: I did download a binary, but the tarball it contained doesn't appear to have an executable in it
17:30:38 <dradtke> monochrom: for the binaries too?
17:30:42 <napping> does it have a configure script?
17:30:46 <monochrom> yes
17:30:52 <napping> you configure a prefix, and do make install
17:31:04 <monochrom> "make install" copies files. no building.
17:31:26 * monochrom shakes head. are you a skeptic?
17:31:31 <Eduard_Munteanu> ezyang: hm, not really, though I didn't think this through
17:32:09 <dradtke> it says it can't find "libgmp.so.3"; I have libgmp.so installed. should I just symlink it?
17:32:39 <elliott> bah, I should give up on not using hsc2hs for this
17:32:46 <elliott> peeking and poking structs is just too painful
17:32:49 <monochrom> strange opensuse, but yes
17:33:26 <napping> dradtke: what libgmp.so? if you.ve got a libgmp.so.3.x.y it might work
17:33:34 <dradtke> monochrom: shouldn't packages request the non-versioned library?
17:33:36 <kmc> i've been very pleased with hsc2hs
17:33:37 <napping> (might work to just symlink it, I mean)
17:33:38 <monochrom> I have a friend who used to use red hat, then opensuse, then windows
17:33:43 <kmc> it integrates well with cabal; everything just works
17:33:48 <monochrom> I don't care.
17:33:54 <Danl2620`> anyone here familiar with parsec?
17:33:57 <elliott> kmc: yeah, it looks fine -- I was just thinking maybe everything was simple enough that I could avoid a dependency and make things more "native"
17:33:58 <dradtke> I just have "/lib64/engines/libgmp.so" installed
17:34:11 <elliott> kmc: this is known as the "programmers never learn that it's never that simple" mistake
17:34:15 <kmc> heh yes
17:34:16 <napping> libgmp.so.3 is the minimally versioned name, isn't it?
17:34:18 <kmc> i am familiar with this one :)
17:34:30 <dradtke> napping: but the unversioned name is what I have installed
17:34:34 <elliott> hsc2hs wrapping time, then
17:34:48 <monochrom> debates on versioning are for theologians
17:34:54 <napping> You only have the unversioned name?
17:34:59 <dradtke> napping: yeah
17:35:01 <napping> it's not a symlink to something else?
17:35:14 <napping> dunno, gmp is pretty important if you like Integers
17:35:15 <dradtke> napping: I don't think so, but I don't know exactly how to check =/
17:36:00 <acowley`> I've never used hsc2hs and always peek/poke my own structs. I worry I am missing out
17:36:26 <napping> acowley`: {# get Type->field #} ptr
17:36:47 <napping> and maybe it even doesn't break if the struct layout changes
17:37:11 <napping> Danl2620`: lots
17:37:13 <elliott> acowley`: that doesn't even handle padding
17:37:17 <elliott> how can you LIVE with yourself???
17:37:39 <dylukes> Danl2620`: sure, whats up?
17:37:48 <napping> The pango binding internals have some odd stuff
17:37:48 <dradtke> just curious, who handles packaging haskell for openSUSE? The most recently packaged version is 6.12.3
17:37:53 <Danl2620`> so I'm parsing an integer with many1 digit
17:37:54 <acowley`> elliott: I think it's that the level of frustration I would experience if hsc2hs did something wrong is worse than if I messed up something myself
17:37:55 <dylukes> I mean, I think a good number of people in here are relatively familiar, so just ask. Don't ask to ask :).
17:38:03 <dylukes> uhuh.
17:38:11 <td123> lol, going through lyah and I found an error/inconsistency :)
17:38:12 <Danl2620`> i'd like to parse a negative integer too... i don't know how to properly consume the '-'
17:38:29 <dylukes> Danl2620`: I would suggest looking in Text.Parsec.Token
17:38:39 <dylukes> there are prebuilt combinators for this :)
17:38:45 <dylukes> specifically "integer"
17:38:50 <dylukes> "This lexeme parser parses an integer (a whole number). This parser is like natural except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in decimal, hexadecimal or octal. The number is parsed according to the grammar rules in the Haskell report."
17:39:10 <Danl2620`> ah, I see... you mean I don't have to do it the hard way?  How boring.. ;]
17:39:21 <dylukes> "lexeme parser" means whiteSpace is consumed first btw.
17:39:28 <dylukes> so "     blah" == "blah" == " blah"
17:39:58 <dylukes> You can make your own with myParser = lexeme $ ...
17:40:11 <dylukes> I would also like to shamelessly plug edwardk's trifecta package.
17:40:15 <dylukes> It's like Parsec but nicer, imo.
17:41:12 <napping> System.Glib defines it's own utf conversion - at type String->String
17:41:46 <kmc> dylukes, you should write the trifecta tutorial!
17:41:56 <dylukes> kmc: I really should. I need an easy first blog post.
17:42:10 <dylukes> How about tomorrow during school I write a simple tutorial then. :\
17:42:14 <dylukes> any thoughts on what I should actually do?
17:42:16 <kmc> yes!
17:42:20 <kmc> dunno
17:42:24 <dylukes> maybe CSV for part 1?
17:42:33 <dylukes> dunno if that's too simple.
17:42:35 <kmc> do something simple which shows off at least one of trifecta's novel features
17:42:39 <kmc> csv isn't sexy
17:42:50 <Danl2620`> parse haskell ;)
17:42:53 <napping> pangoItemize kind of skipped the part where each PangoItem corresponds to a substring of the input
17:42:54 <kmc> maybe you can do XML and have a "you forgot to close this tag" highlight
17:43:08 <dylukes> Danl2620`: too easy. Tect.Trifecta.Parser.Language with haskellDef...
17:43:25 <kmc> probably the main things you could show off are the error message spans and the automatic syntax highlighting
17:43:29 <dylukes> You need to write the AST stuff, but thats boring as hell.
17:43:32 <dylukes> kmc: so XML maybe?
17:43:41 <dylukes> I think that would probably be best.
17:43:41 <kmc> dylukes, do you have a good setup for Haskell blogging?
17:43:47 <dylukes> I have a blogger account.
17:43:56 <kmc> ok
17:43:58 <dylukes> I'd probably do LHS -> Pandoc
17:44:00 <dylukes> to html
17:44:03 <kmc> yeah
17:44:05 <dylukes> then just paste it in and dick with formatting
17:44:06 <kmc> lhs markdown :)
17:44:12 <kmc> you can steal stuff off my blog if you like
17:44:13 <kmc> css etc
17:44:16 <dylukes> I just made this a while back. Haven chosen a title.
17:44:17 <dylukes> http://dylukes.blogspot.com/
17:44:18 <kmc> or ask me about it and tweak to taste
17:44:27 <dylukes> I tweaked the theme to red, because I like it more >_>.
17:44:39 <dylukes> 8B0000 is a nice color.
17:45:23 <dylukes> Bah, now I want to do this now ;~;
17:45:27 <dylukes> but I should be writing an essay >.<
17:45:41 <dylukes> Wow. I've actually done really well in terms of the amount of work I did on that without procrastination...
17:45:55 <dylukes> rhetorical analysis of a Leonard Pitts commentary article.
17:46:17 <dylukes> Oh, I talked to a linguistics professor from CMU today.
17:46:45 <dylukes> Whoever I was arguing with about whether or not English has a notion of (non-periphrastic) future... her stance is no as well.
17:47:05 <stribor> does anyone have totorial on creating parsers ..i followed this one but just dont get it  http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
17:47:36 <dylukes> stribor: kmc just asked me to write one :)
17:47:50 <stribor> dylukes: lol
17:48:00 <dylukes> but, I found the first part of this good
17:48:00 <dylukes> http://jonathan.tang.name/files/scheme_in_48/tutorial/parser.html
17:48:01 <Danl2620`> i think stribor is talking about parsec
17:48:12 <dylukes> It's a practical case.
17:48:29 <Danl2620`> dylukes: I'm working on that one, trying to add negative integers! ;)
17:48:31 <dylukes> Just, use Text.Parsec.---, not Text.ParserCombinators.Parsec.---
17:48:39 <dylukes> Danl2620`: Included in "integer"
17:48:54 <stribor> dylukes: ill look at that one
17:48:57 <dylukes> parseNumber = liftM (Number . read) $ integer
17:48:59 <dylukes> alternatively
17:49:04 <Danl2620`> it must be converted to use token parsing....?
17:49:05 <dylukes> parseNumber = Number . read <$> integer
17:49:08 <dylukes> nope.
17:49:12 <stribor> why it ius called Write Yourself a Scheme in 48 Hours
17:49:15 <dylukes> "token" parsing is a misnomer. It doesn't tokenize.
17:49:23 <dylukes> stribor: Because it's a tutorial for writing a scheme interpreter.
17:49:24 <incluye> > let parseNumber = Number . read <$> integer in parseNumber "3"
17:49:26 <lambdabot>   Not in scope: data constructor `Number'
17:49:28 <incluye> darn
17:49:35 <dylukes> incluye: No Parsec in lambdabot, sorry :P
17:49:41 <coppro> Why Number?
17:49:49 <incluye> oh well I don't know what I'm doing most of the time anyway
17:49:52 <dylukes> coppro: that's the AST data type he's using.
17:49:55 <coppro> ah
17:49:57 <dylukes> It's specific to his work.
17:50:01 <dylukes> <$> is just fmap.
17:50:04 <Danl2620`> coppro: Number is part of the tutorial
17:50:09 <dylukes> @src (<$>)
17:50:10 <lambdabot> f <$> a = fmap f a
17:50:11 <stribor> dylukes: i need tut on haskell parser
17:50:17 <dylukes> stribor: I just linked one .__.
17:50:24 <dylukes> the first 20% of it is parsing.
17:50:42 <stribor> dylukes: tx
17:50:46 <dylukes> All of section 3
17:51:07 <dylukes> kmc: Do you think I should do Lisp or XML?
17:51:20 <dylukes> Assuming I'm not going beyond parsing, they could both be good, but Lisp might be more varied.
17:51:31 <dylukes> And a more practical use case for the kinds of people looking for how to use trifecta. A bit "cooler".
17:52:26 <dylukes> (plus I could potentially expand from just a parser to evaluation if it took my fancy)
17:52:32 <dylukes> (but I doubt I'd have time...)
17:53:25 <Danl2620`> dylukes: it doesn't like liftM (Number . read) $ integer
17:53:35 <Danl2620`>     Couldn't match expected type `[Char]'
17:53:35 <Danl2620`>            against inferred type `Text.Parsec.Prim.ParsecT s u m Integer'
17:53:35 <Danl2620`>  
17:53:42 <dylukes> oh
17:53:43 <dylukes> derp
17:53:47 <dylukes> just do
17:53:49 <dylukes> Number <$> integer
17:54:06 <dylukes> Number <$> integer == Number `fmap` integer == liftM Number $ integer
17:54:19 <Danl2620`> dylukes: Not in scope: `<$>'
17:54:21 <dylukes> the first is applicative notation, which is generally preferred for parsers, but its a little arcane at first.
17:54:28 <dylukes> you need to import Control.Applicative
17:54:35 <dylukes> hiding (<|>) because Parsec is silly.
17:54:46 <dylukes> it should just use Applicative's (<|>)... oh well.
17:54:52 <elliott> no, hide Parsec's (<|>)
17:55:01 <elliott> many, too
17:55:04 <dylukes> elliott: Does Parsec declare an Alternative instance?
17:55:07 <elliott> yes
17:55:11 <dylukes> ah, then yeah.
17:55:12 <dylukes> well
17:55:14 <dylukes> lets not confuse him for now.
17:55:17 <elliott> parsec3 that is :-)
17:55:19 <dylukes> Just use liftM or `fmap` for now :)
17:55:33 <dylukes> Applicative notation will only make it harder for you to read your own code for the time being.
17:55:39 <dylukes> Eventually it's rather pleasant.
17:56:06 <napping> whew, much less recompilation in gtk than I feared:
17:56:11 <napping> Building gtk-0.12.1...
17:56:12 <dylukes> Danl2620`: essentially though
17:56:14 <napping> [207 of 207] Compiling Graphics.UI.Gtk  ( dist/build/Graphics/UI/Gtk.hs, dist/build/Graphics/UI/Gtk.o )
17:56:15 <dylukes> :t fmap
17:56:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:56:20 <napping> Registering gtk-0.12.1...
17:56:21 <napping> :)
17:56:39 <dylukes> Danl2620`: (a -> b) is Number (which is Int -> Number)
17:57:01 <dylukes> f a is integer (which is Parser ... Int)
17:57:08 <dylukes> and remember Parser ... is a functor.
17:57:24 <dylukes> So it's applying the Number constructor INSIDE the functor, mapping it to f b... which is
17:57:26 <dylukes> Parser ... Number
17:57:35 <dylukes> Follow the types young padawan.
17:57:43 <Danl2620`> ok i'm still lost. parseNumber = Number `fmap` integer doesn't compile either.....
17:57:53 <dylukes> error?
17:58:58 <hpaste> Danl2620` pasted “parsec issue #2” at http://hpaste.org/53233
17:58:59 <dylukes> oooh, integer needs a GenTokenParser or w/e...
17:59:05 <dylukes> forgot about that...
17:59:11 <dylukes> the one in Trifecta doesn't >_>
17:59:24 <Danl2620`> yes, GetTokenParser...
18:00:04 <dylukes> uh, then maybe just use your own hand rolled one unless you want to muck with that
18:00:07 <Danl2620`> no 'read' required?
18:00:17 <dylukes> no, integer's type parses an integer
18:00:26 <dylukes> here, use your old method
18:00:27 <dylukes> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Combinator.html
18:00:31 <dylukes> look at the "option" combinator
18:00:54 <dylukes> optional/optionMaybe
18:01:11 <dylukes> you want to maybe parse a negative sign... and then parse a number... then...
18:01:14 <Danl2620`> > yeah, I tried: parseNumber = liftM (Number . read) $ ((char '-' >> many1 digit) <|> many1 digit)
18:01:14 <Danl2620`>  
18:01:15 <lambdabot>   <no location info>: parse error on input `,'
18:01:21 <dylukes> if there was a negative sign, just multiply by negative one.
18:01:36 <Danl2620`> ack... I was trying (vainly) to avoid that
18:01:48 <dylukes> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/Text-Parsec-Token.html
18:01:49 <Danl2620`> since read can parse the '-'
18:01:56 <dylukes> oh, then
18:02:08 <dylukes> char '-' is reading a char
18:02:14 <dylukes> and many1 digit is parsing a list of chars...
18:02:24 <dylukes> Char -> [Char] -> [Char]
18:02:30 <dylukes> Look familiar?
18:02:37 <dylukes> hint it's :
18:02:41 <stribor> dylukes: can you guve me example to run symbol :: Parser Char
18:02:44 <napping> where did you get a ,? a number like 1,000,000?
18:03:16 <Danl2620`> ok, i get : certainly
18:03:19 <dylukes> stribor: all of those parsers are RECORD FIELDS of a GenTokenParser
18:03:24 <dylukes> so you have to have a tokenparser
18:03:36 <dylukes> then do `symbol mytokenparser ...`
18:03:42 <dylukes> note the example at the very end...
18:03:53 <stribor> how do i define tokenparser
18:03:53 <dylukes> maybe just look at the source of how integer is implemented :)
18:03:59 <dylukes> there are some predefined ones
18:04:39 <dylukes> int             = do{ f <- lexeme sign
18:04:40 <dylukes>                         ; n <- nat
18:04:41 <dylukes>                         ; return (f n)
18:04:41 <dylukes>                         }
18:04:42 <dylukes> sign            =   (char '-' >> return negate)
18:04:43 <dylukes>                     <|> (char '+' >> return id)
18:04:44 <dylukes>                     <|> return id
18:04:58 <dylukes> http://hackage.haskell.org/packages/archive/parsec/3.1.0/doc/html/src/Text-Parsec-Token.html#GenLanguageDef
18:05:06 <dylukes> look through here, it has all the examples you might want :)
18:05:06 <Danl2620`> yeah... i see it....
18:05:08 <DukeDave> Wah, so (+ 1) and (- 1) have different kinds, this does not please me; I thought 'negate' was supposed to be there for negation :|
18:05:16 <dylukes> hm? what do you mean?
18:05:20 <elliott> DukeDave: we don't talk about the negative literal syntax
18:05:23 <elliott> they have the same kind btw
18:05:25 <elliott> just not the same arity
18:05:32 <dylukes> sign is a parser that parses a FUNCTION
18:05:37 <DukeDave> elliott Ah
18:05:37 <napping> success! Now "*bold* plain" renders as "*bold* plain" rather than "*bold plain*bold plain"
18:05:41 <elliott> ...even if arity is hard to define in the face of currying
18:05:42 <dylukes> of type Num a => a -> a
18:05:44 <elliott> dylukes: DukeDave is saying something unrelated
18:05:59 <DukeDave> :t (+ 1)
18:06:00 <lambdabot> forall a. (Num a) => a -> a
18:06:01 <elliott> DukeDave: The worst part is, what we have is already a special case.
18:06:04 <DukeDave> :t (- 1)
18:06:04 <lambdabot> forall a. (Num a) => a
18:06:10 <elliott> A special case with the complete wrong precedence and everything.
18:06:15 <DukeDave> :t negate
18:06:16 <lambdabot> forall a. (Num a) => a -> a
18:06:23 <Danl2620`> :t id
18:06:24 <lambdabot> forall a. a -> a
18:06:40 <DukeDave> elliott: What is the special case?
18:06:43 <DukeDave> (-)  ?
18:06:49 <elliott> DukeDave: Yes, unary (-).
18:07:23 <DukeDave> Bleugh, I thought I was going to have a beautiful code moment with:  if foo then (+1) else (-1)
18:07:57 <napping> ((-)1)
18:07:58 <DukeDave> Is there a nice way to get the function which subtracts one?
18:08:06 <napping> and ((+)1), if you want it to match
18:08:11 <DukeDave> napping: Isn't that "one minus" ?
18:08:20 <napping> oh, so it is
18:08:34 <napping> > subtract 1
18:08:35 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
18:08:35 <lambdabot>    arising from a use of `...
18:08:39 <DukeDave> napping: Yeah, so all I've got is flip, or a lambda
18:08:53 <dylukes> DukeDave: or use pred
18:08:54 <DukeDave> :t subtract
18:08:55 <lambdabot> forall a. (Num a) => a -> a -> a
18:08:56 <Eduard_Munteanu> @type pred   -- might also do
18:08:56 <dylukes> :t pred
18:08:56 <lambdabot> forall a. (Enum a) => a -> a
18:08:57 <dylukes> :t succ
18:08:57 <lambdabot> forall a. (Enum a) => a -> a
18:08:58 <lambdabot> forall a. (Enum a) => a -> a
18:09:09 <dylukes> if foo then succ else pred
18:09:13 <DukeDave> dylukes: Wow, that's obvious
18:09:18 <DukeDave> But, your mind..
18:09:21 * elliott prefers subtract 1
18:09:28 <DukeDave> :t add
18:09:29 <lambdabot> Not in scope: `add'
18:09:29 <elliott> partially because
18:09:32 <DukeDave> ARGH
18:09:33 <elliott> e.g. Integer should not be Enum
18:09:40 <shachaf> elliott: Prefer it to (-1+)?
18:09:43 <dylukes> elliott: why not? :<
18:09:45 <elliott> shachaf: wow does that work
18:09:47 <elliott> dylukes:
18:09:48 <elliott> :t fromEnum
18:09:49 <shachaf> Sure.
18:09:49 <lambdabot> forall a. (Enum a) => a -> Int
18:09:52 <shachaf> (-1 +)
18:10:04 <shachaf> > (-1+) 5
18:10:04 <elliott> note: integers should be usable in list range syntax
18:10:04 <lambdabot>   4
18:10:05 <dylukes> > fromEnum 99999999999999999999999999::Integer
18:10:06 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
18:10:06 <Danl2620`> :t negate
18:10:06 <lambdabot>         against inf...
18:10:08 <lambdabot> forall a. (Num a) => a -> a
18:10:09 <elliott> but Enum is basically awfully broken in every way so
18:10:22 <DukeDave> shachaf: Oh yeah, I thought of that too, and then I was a little sick in my mouth :|
18:10:37 <dylukes> > fromEnum (99999999999999999999999999::Integer)
18:10:38 <shachaf> @let (+-) = (-)
18:10:38 <lambdabot>   -2537764290115403777
18:10:39 <lambdabot>  Defined.
18:10:40 <shachaf> > (+-1)
18:10:41 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:10:41 <lambdabot>    arising from a use of `...
18:10:42 <dylukes> Hmmm...
18:10:43 <shachaf> > (+-1) 5
18:10:44 <lambdabot>   4
18:10:46 <dylukes> seems to be a problem here huh :)
18:10:48 <DukeDave> I think it (-1+) is actually my preferred one, but it doesn't read too well imho
18:11:05 <shachaf> evilFromEnum
18:11:09 <DukeDave> Unless you're an APL programmer..
18:11:13 <dylukes> pred/succ are fine here I think :\
18:11:31 <elliott> DukeDave: ((-1) +) :p
18:11:39 <dylukes> :t incr
18:11:40 <dylukes> :t decr
18:11:40 <lambdabot> Not in scope: `incr'
18:11:41 <lambdabot> Not in scope: `decr'
18:11:42 <napping> (+1+) and (-1+) is nicely symmetric
18:12:34 <dylukes> napping: and amusing...
18:12:36 <elliott> napping: doesn't do what you think
18:12:38 <elliott> :t (+1+)
18:12:39 <lambdabot> parse error on input `)'
18:12:44 <elliott> :t (-1+)
18:12:45 <lambdabot> forall a. (Num a) => a -> a
18:12:51 <dylukes> + isn't unary...
18:12:55 <dylukes> :t (id 1 +)
18:12:55 <napping> aww
18:12:56 <lambdabot> forall t. (Num t) => t -> t
18:13:01 <dylukes> :t (neg 1 +)
18:13:03 <lambdabot> Not in scope: `neg'
18:13:10 <dylukes> :t (negate 1 +)
18:13:11 <lambdabot> forall t. (Num t) => t -> t
18:13:13 <dylukes> might be nicer?
18:13:15 <shachaf> Sure it is.
18:13:17 <shachaf> > ((+1) + (+2)) 0
18:13:18 <lambdabot>   3
18:13:22 <shachaf> > (+3) 0
18:13:23 <lambdabot>   3
18:13:25 <shachaf> > (3) 0
18:13:26 <lambdabot>   3
18:13:27 * shachaf QED
18:13:32 <dylukes> > (3) 0
18:13:34 <lambdabot>   3
18:13:34 <dylukes> wait
18:13:35 <dylukes> what
18:13:36 <dylukes> :t 3
18:13:37 <lambdabot> forall t. (Num t) => t
18:13:39 <dylukes> :t (3)
18:13:40 <lambdabot> forall t. (Num t) => t
18:13:41 <dylukes> the
18:13:42 <dylukes> fuck
18:13:46 <shachaf> ,
18:13:57 <dylukes> > 1 2
18:13:58 <lambdabot>   1
18:14:03 <dylukes> that's messed up ;_;
18:14:03 <Danl2620`> heh
18:14:10 <dylukes> oh, this is CALESKELL.
18:14:14 <dylukes> >:(
18:14:16 <shachaf> dylukes: lambdabot has instance Num a => Num (a -> a) where fromInteger x = const x
18:14:19 <shachaf> 3 _ = 3
18:14:23 <dylukes> shachaf: _why_?
18:14:24 <shachaf> Like void in unlambda.
18:14:43 <shachaf> dylukes: So that you get a Num instance for functions.
18:14:47 <DukeDave> Wait.. I have it..
18:14:51 <shachaf> > ((*2) + (*3)) 5
18:14:52 <lambdabot>   25
18:14:53 <DukeDave> > (iterate succ 0) !! 10
18:14:54 <lambdabot>   10
18:14:56 <dylukes> shachaf: Why would you need that? We aren't #godel.
18:14:58 <shachaf> > ((*2) + 1) 5
18:15:00 <lambdabot>   11
18:15:10 <shachaf> dylukes: ...It's not that sort of Num instance.
18:15:24 <shachaf> It's just auto-lifting numbers to functions.
18:15:26 <kfish>  let (⇮)=succ
18:15:29 <shachaf> People do it in mathematics all the time.
18:15:36 <dylukes> ...Cale...
18:15:37 <dylukes> >_>
18:15:48 <shachaf> Cale didn't write it.
18:15:54 <dylukes> ...lambdabot authors...
18:15:57 <shachaf> Nope.
18:16:03 <shachaf> I think it was augustss or something.
18:16:07 <dylukes> Oh, that explains it.
18:16:13 <shachaf> augustss++
18:16:16 <shachaf> preflex: seen augustss
18:16:16 <preflex>  augustss was last seen on #haskell 54 days, 15 hours, 31 minutes and 25 seconds ago, saying: yo
18:16:52 <elliott> kmc: oh, did you say you had a good experience with hsc2hs or c2hs? I forget :)
18:17:16 <shachaf> elliott: Probably hsc2hs.
18:17:29 <shachaf> IANAkmc
18:18:24 <hpaste> Danl2620` pasted “parsec issue #3” at http://hpaste.org/53234
18:18:39 <Danl2620`> dylukes: could you take a gander...
18:19:01 <kmc> elliott, 'twas hsc2hs
18:19:03 <kmc> i've not tried c2hs
18:19:26 <dylukes> what are you negating :)
18:19:31 <dylukes> n <- many1 digit
18:19:35 <dylukes> what's the type of 'n' here?
18:20:07 <Danl2620`> hmmm... ah, [Char]?
18:20:09 <dylukes> You'd want to do return Number . f $ read n
18:20:15 <Danl2620`> i see
18:20:23 <elliott> hmm
18:20:25 <dylukes> or rather,
18:20:28 <elliott> can hsc2hs handle poking fields of an anonymous struct?
18:20:32 <elliott> i.e. struct{int x; int y;}blah;
18:20:46 <dylukes> Number `fmap` .... return . f $ read n
18:21:02 <dylukes> Silly as it is, I always remember that a $ b $ c -> a . b $ c with the mnemonic "dot dot goose"
18:21:03 <dylukes> :|
18:21:08 <dylukes> @quote dot dot goose
18:21:09 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
18:21:10 <dylukes> who said that
18:21:14 <dylukes> @quote goose
18:21:15 <lambdabot> No quotes match. Sorry.
18:21:49 <Danl2620`> huh. that worked.
18:21:54 <Danl2620`> f'in black magic.
18:22:12 <shachaf> Danl2620`: Don't use it if it's black magic!
18:22:55 <Danl2620`> hmm... doesn't appear to work anyway (it compiles, but doesn't parse...?)
18:22:58 <dylukes> It's not f'in black magic, but, if you don't get why it works, figure it out.
18:23:00 <shachaf> Anyway, use <*> or something.
18:23:10 <dylukes> shachaf: Don't confuse him with applicative notation.
18:23:22 <dylukes> It's easier to start with do.
18:24:11 <dylukes> :t return
18:24:12 <dylukes> f :: (Int -> Int)
18:24:13 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:24:13 <dylukes> :t read -- remember, 'a' here is Int
18:24:14 <lambdabot> forall a. (Read a) => String -> a
18:24:15 <dylukes> put it together
18:24:16 <dylukes> :)
18:25:07 <dylukes> (String -> Int) + (Int -> Int) + (Int -> ParsecT s u m Int)
18:25:13 <dylukes> read + f + return
18:25:20 <dylukes> Types help.
18:25:23 <dylukes> Use them.
18:25:24 <Danl2620`> yeah I think that part makes a little sense
18:25:39 <Danl2620`> it doesn't want to consume the '-' or the '+' for some reason
18:25:50 <dylukes> can you paste your parser as it is?
18:26:22 <hpaste> Danl2620` pasted “parsec issue #4” at http://hpaste.org/53235
18:26:58 <Danl2620`> oh i got it  :/
18:27:17 <Danl2620`> there's a symbol parser that consumes '-' and '+' interfereing
18:27:51 <Danl2620`> it works!
18:27:52 <dylukes> is it working?
18:27:55 <dylukes> great :)
18:28:00 <Danl2620`> many thanks :]
18:28:00 <dylukes> now try to write it more succinctly :D
18:28:16 <Danl2620`> yeah... maybe just lump the '-' and '+' in for read to handle......
18:29:35 <dylukes> :t (char '-' *> pure negate <|> char '+' > pure id) <*> (read <$> many1 digit)
18:29:36 <lambdabot> Not in scope: `many1'
18:29:36 <lambdabot> Not in scope: `digit'
18:31:04 <Danl2620`> i see.  there must be a way to parse a '-' then digits and return the whole thing!
18:31:56 <elliott> meh... it feels too heavy to define a type and Storable instance for trivial structs, but it feels gross to manually poke the fields
18:32:03 <elliott> why isn't there a Storable instance for tuples
18:32:07 <dylukes> Generic will hopefully make it nicer?
18:32:32 <elliott> maybe
18:35:06 <dylukes> God I hate Parsec now that I try it again.
18:35:19 <dylukes> XD
18:37:02 <dylukes> parseNumber :: MonadParser m => m Int
18:37:02 <dylukes> parseNumber = ((char '-' *> pure negate) <|> (char '+' *> pure id)) <*> (read <$> some digit)
18:37:04 <dylukes> works here.
18:37:06 <dylukes> (some == many1)
18:37:13 <irene-knapp> dylukes: congratulations on your Parsec-cynicism.
18:37:15 <dylukes> should be identical in parsec...
18:37:18 <dylukes> irene-knapp: hm?
18:37:26 <dylukes> Why congrats?
18:37:28 * irene-knapp is not a fan of LL parsers in general
18:37:33 <dylukes> Oh, I like Trifecta :<
18:37:47 <edwardk> =)
18:37:49 <irene-knapp> heh, okay.  I'm certain that Trifecta is the best that a parser with that algorithm class can possibly be.
18:37:58 <dylukes> edwardk: I can write trivial parsers out of context and
18:37:59 <dylukes> THEY
18:38:00 <dylukes> FUCKING
18:38:00 <irene-knapp> I don't have another opinion on it because I haven't tried it myself
18:38:01 <dylukes> TYPECHEKC
18:38:13 <dylukes> irene-knapp: Pratt parsers are fun, I've been messing with those recently.
18:38:17 * irene-knapp nods
18:38:28 <dylukes> It strikes me that in combination with IterIO, they could make for some nice parsers.
18:38:29 <edwardk> irene-knapp: i have a class of parsers for dealing with GLL as well, but I haven't shoehorned it into a common baseclass
18:38:40 <irene-knapp> edwardk: fair enough!
18:39:15 <edwardk> and a parser for a parallel parseable subset of LR
18:39:22 <dylukes> What exactly is the deal with GLR?
18:39:24 <irene-knapp> hmm, right, you mentioned something about that
18:39:27 <dylukes> It seems scary and complex compared to LL.
18:39:42 <dylukes> And involves parallel parsing.
18:39:46 <irene-knapp> GLR?  GLR is a misnomer, it's actually an algorithm for /running/ a parse automaton generated by an LR table-generation algorithm.
18:39:57 <dylukes> irene-knapp: ah, okay.
18:40:12 <irene-knapp> it's not parallel actually, not in the sense of concurrency
18:40:16 <irene-knapp> it's for parsing ambiguity
18:40:17 <edwardk> LL(1) is scanning left to right choosing which branch using a single token of lookahead, LR(1) is doing the same thing but you're allowed to defer the decision until you need to 'shift' or 'reduce'
18:40:31 <dylukes> shift or reduce? :\
18:40:40 <irene-knapp> shift = more input, reduce = consolidate what you've got
18:40:42 <dylukes> reduce makes me think of crunching the top of a stack or something
18:40:50 <irene-knapp> yes, it's a stack
18:40:56 <edwardk> GLR is tomita's algorithm for recognizing any context free grammar in O(n^3) time while keeping O(n) for the LR case
18:41:11 <irene-knapp> yes.
18:41:15 <edwardk> however, the algorithm as specified doesn't preserve those asymptotics when applied to the problem of generating parse trees so you have to be careful
18:41:20 <irene-knapp> note that any CFG means even ambiguous ones
18:41:26 <edwardk> GLR basically gets rid of the deterministic shift/reduce issue
18:41:39 <dylukes> This stuff is slightly going over my head, but I'm trying to grok what I can.
18:41:56 <edwardk> Scott and Johnstone's GLL does the same thing from an LL perspective. O(n) for LL(1) but O(n^3) worst case for recognition (or parsing) of arbitrary CFGs
18:41:58 <irene-knapp> yes - you typically use it with a modified data structure that lets you do ambiguity packing
18:42:06 <irene-knapp> whereby the forest of possible parse trees has shared structure
18:42:07 <edwardk> since LL is smaller than LR this is less beneficial
18:42:13 <Danl2620`> how do I do a import Control.Applicative hiding (<|>) ?
18:42:13 <Danl2620`>  
18:42:13 <edwardk> but its easier to make into a combinator set
18:42:28 <edwardk> Danl2620: hiding ((<|>))
18:43:21 <edwardk> basically its just the graph stack applied to a fairly straightforward LL implementation
18:43:31 * irene-knapp nods
18:43:56 <Danl2620`> parseNumber = Number `fmap` (((char '-' *> pure negate) <|> (char '+' *> pure id) <|> pure id) <*> (read <$> some digit))
18:44:28 <dylukes> Danl2620`: oh man, don't actually use that.
18:44:30 <edwardk> one thing i've been playing with lately is that peter pepper has an algorithm for emulating LR with LL, which has the benefit of using the same number of states as an LALR parser, which has a few niggling restrictions on it
18:44:39 <dylukes> Unless you can read Applicative notation easily, there's no benefit to you ;__;
18:44:39 <Danl2620`> yeah it's ugly
18:44:46 <dylukes> and yeah, it needs to be factored out.
18:44:49 * irene-knapp took a moment to realize that Peter Pepper was a real person and not a rhyme
18:44:59 <irene-knapp> hmmm, that does sound interesting
18:45:08 <Danl2620`> certainly `fmap` should become... <*>?
18:45:11 <dylukes> I have no idea what that means, but sure.
18:45:14 <edwardk> when applied to a GLL parser it gives you a GLR parser with the same number of states as an LALR parser, but with the reset machinery i need for the 'smaller than LR class' of parallel languages
18:45:17 <dylukes> Danl2620`: `fmap` = <$>
18:45:18 <monochrom> fmap becomes <$>
18:45:19 <dylukes> :t (<$>)
18:45:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:45:25 <dylukes> :t (<*>)
18:45:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:45:32 <irene-knapp> hmm, neat
18:45:39 <edwardk> while being able to handle any CFG
18:45:51 <irene-knapp> that sounds almost ideal
18:45:57 <edwardk> and the parser effectively gives you a left corner parser set of states
18:46:03 <edwardk> which is also idealized
18:46:04 <Danl2620`> ah yes
18:46:06 <dylukes> edwardk: You seem deadset on replacing Parsec at this rate :).
18:46:09 <irene-knapp> I still think LR has some benefits, or rather, shift-reduce does, in terms of making more "natural" stuff
18:46:16 <dylukes> I mean, I'd already say Trifecta is a much nicer library as it is.
18:46:27 <irene-knapp> there is at least some reason to think that the human brain actually does something shift-reduce-like
18:46:27 <edwardk> well, the emulated parser uses LL in the backend but parses LR
18:46:33 <dylukes> irene-knapp: where do pratt parsers fall in all this mind you?
18:46:43 <dylukes> they're kind of neat, but not really "grammars"
18:46:47 <edwardk> i mostly care about being able to parallelize, even if that means i have to express grammars somewhat unnaturally
18:47:02 <dylukes> idk, hybrid procedural/declarative... kind of fun. They seem LL to me.
18:47:03 <irene-knapp> dylukes: I haven't previously heard the term, but if it's basically an operator-precedence parser, I don't think that's a very strong formalism
18:47:19 <dylukes> irene-knapp: essentially. Not very formal at all, but easy.
18:47:26 <edwardk> given a GLL/GLR or mixed Earley-LALR parser something that can handle any CFG i can build a cheaply parallelizing parser
18:47:32 <irene-knapp> yeah, I agree that ability to parallelize is a fair tradeoff
18:47:42 <dylukes> What do you mean "unnaturally" though?
18:47:58 <irene-knapp> well, edwardk was responding to my assertion that it's easier to write LR grammars and so forth
18:47:59 <edwardk> pratt parsers are just convenient toys
18:48:24 <edwardk> they handle the operator precedence layer that emerges in practice in the middle of many programming languages
18:48:46 <irene-knapp> right, okay.
18:48:53 <edwardk> so they can help mitigate the overhead of dealing with recursive descent style LL'ish parsing
18:48:54 <irene-knapp> unfortunately that's not really the challenging thing to express :)
18:49:04 <edwardk> sure, but its convenient
18:49:10 <irene-knapp> yeah, I see that
18:49:13 <edwardk> one table, easy to refactor, etc.
18:49:27 <irene-knapp> right
18:49:51 <dylukes> irene-knapp: http://javascript.crockford.com/tdop/tdop.html
18:49:52 <edwardk> trifecta is mostly focused on making parsing easier, and on providing all the crap AROUND the parser that nobody bothers with
18:50:07 <dylukes> highlighting/diagnostics/errors... all very useful btw.
18:50:19 <dylukes> It'd be a pain in the ass to glue all that stuff on afterwards.
18:50:44 <irene-knapp> yes, I know, I was present for your excited talk about it in here when you were first starting on it :)
18:50:47 <edwardk> so it deals with syntax highlighting, typeahead completion, c preprocessing-with-support-in-the-diagnostics, nice diagnostics that show you ranges in your source code, ctags file generation, etc.
18:50:49 <irene-knapp> I agree that those are important things
18:51:03 <edwardk> ah, the original one was a bit different
18:51:17 <irene-knapp> I didn't realize you had typeahead completion in it, that's quite nice
18:51:34 <edwardk> its in a working branch
18:51:52 <edwardk> it also deals with things like haskell-style layout, lets you apply monad transformers, etc.
18:52:00 * irene-knapp nods
18:52:18 <dylukes> in short:
18:52:21 <dylukes> trifecta kicks ass :)
18:52:27 <edwardk> well it needs some work still
18:52:39 <dylukes> (and will report a nicely highlighted error if it cannot kick some ass for some readon)
18:52:39 <edwardk> but its a heck of a lot nicer to work with than parsec at least
18:52:49 <dylukes> edwardk: As I said, the litmus test for me,
18:52:59 <dylukes> is that I can write a single trivial parser and it type checks out of context
18:53:05 <edwardk> ah
18:53:11 <dylukes> with parsec if you don't have all the other routines there so it can infer all the crap... it fails.
18:53:25 <dylukes> Really obnoxious.
18:53:26 <edwardk> the stream type?
18:53:29 <dylukes> Yeah...
18:53:37 <dylukes> MonadParser m => is a lot nicer too.
18:53:40 <kmc> edwardk, I finished the last of the pizza today :D
18:53:44 <edwardk> kmc: =)
18:53:46 <dylukes> Makes it much easier to throw transformers in.
18:53:48 <dylukes> kmc: sounds delicious.
18:54:04 <kmc> i decided that pizza is extra delicious if you put on some red wine vinegar
18:54:13 <kmc> you see, bread with oil and vinegar is a thing
18:54:14 <edwardk> dylukes: we ordered a bit too much for the last boston haskell. grossly overestimated the interest folks woud have in homotopy and directed type theory
18:54:16 <dylukes> that doesn't sound bad.
18:54:18 <kmc> and pizza is already bread with oil, to first approximation
18:54:18 <irene-knapp> kmc: I concur!
18:54:30 <dylukes> edwardk: ...but its... like a year...
18:54:32 <kmc> yay, concurrency
18:54:32 <dylukes> how much pizza...
18:54:40 <dylukes> ._______.
18:54:54 <kmc> dylukes, you should come sometime!
18:54:55 <edwardk> didn't overshoot by too much just ~3 pizzas
18:55:08 <kmc> i hear that Random Hall also enjoyed said pizza
18:55:12 <dylukes> I'd love to. I'd listen to the stuff on homotopy and dtt... though i wouldn't get much of it.
18:55:15 <kmc> dylukes, are you gonna be at the Hackathon?
18:55:22 <edwardk> so we donated some to starving grad students and to kmc
18:55:27 <dylukes> which Hackathon
18:55:30 <kmc> Random is undergrads, I think
18:55:36 <edwardk> hac boston
18:55:40 <edwardk> ah
18:55:41 <dylukes> Oh, idk. :\
18:55:49 <edwardk> you can sneak away
18:55:54 <edwardk> just say you're going over to a friends house
18:55:59 <kmc> the stuff I understood of HTT/DTT is pretty cool... wondering if dolio's slides will appear online so I can look through carefully
18:56:02 <kmc> haha
18:56:02 <dylukes> I'm in Pittsburgh. Not so easy.
18:56:04 <Danl2620`> dylukes: Trifecta sounds quite nice. so we'll have that tutorial in the morning? ;]
18:56:16 <dylukes> Danl2620`: If I finish this essay, I'll write it today/tomorrow.
18:56:17 <dylukes> :)
18:56:19 <kmc> you're going to college 8ish months after that, right?
18:56:22 <Danl2620`> awesome
18:56:23 <edwardk> they might not let you out of the house again until college, but then thats when? a few weeks away? =)
18:56:25 <kmc> so no biggie
18:56:30 <dylukes> kmc	Yeah something like that.
18:56:38 <dylukes> College is next september.
18:56:42 <kmc> i mean, the hackathon is highly relevant to your senior project
18:56:52 <dylukes> Yeah. True.
18:56:53 <kmc> you can come hack on trifecta
18:56:56 <dylukes> :D
18:56:58 <edwardk> yep
18:57:00 <kmc> in fact I think it's the only concrete project listing at the moment :)
18:57:04 <edwardk> =)
18:57:06 <edwardk> muahahaha
18:57:07 <dylukes> Ooh, if I get my school to sponsor the idea,
18:57:12 <dylukes> I might be able to make my parents more willing.
18:57:19 <dylukes> OH
18:57:22 <dylukes> I JUST REMEMBERED
18:57:31 <dylukes> the school got a $10,000 grant for competitions and shit like that.
18:57:31 <edwardk> i would happily write up a review of your progress or what not
18:57:37 <edwardk> even better
18:57:44 <dylukes> they had an announcement that said they were offering it to any student for travel expenses and shit.
18:57:47 <kmc> hell yeah
18:57:48 <dylukes> I should see if I can tap into that :0
18:57:52 <edwardk> there ya go
18:57:53 <kmc> tap that grant
18:58:19 <edwardk> a proven ability to tap grant money is a must for any college student ;)
18:58:31 <kmc> it indicates aptitude for an academic career
18:58:32 <irene-knapp> haha
18:58:33 <irene-knapp> quite
18:58:42 <Danl2620`> yeah that's grad student material there
18:58:43 <dylukes> Misogynistic non-representative comment of the night: Research grants are like women. Hard to get, you can tap them, and they only last a couple years.
18:58:44 <kmc> i will put my most highly skilled transit nerd friends to work figuring out the cheapest way from pbgh to boston
18:59:03 <dylukes> kmc: oh god no. I don't want to die.
18:59:12 <edwardk> dylukes: you may regret saying that on #haskell rather than #haskell-blah ;)
18:59:12 <dylukes> No but honestly probably just amtrak.
18:59:20 <dylukes> edwardk: oh crap. logs.
18:59:25 <irene-knapp> yeah, Amtrak is what you want
18:59:38 <dylukes> DEAR READER OF LOGS. I DIDN'T MEAN THAT IN ANY WAY. IT WAS A JOKE. NOTE THE "NON-REPRESENTATIVE".
18:59:40 <edwardk> pbgh?
18:59:41 <irene-knapp> if you take the bus, go Grayhound, not Chinatown/no-name
18:59:45 <Danl2620`> dylukes: you're career is over before it started. :(
18:59:49 <irene-knapp> but seriously, don't take  the bus
18:59:50 <kmc> powned
18:59:51 <Danl2620`> you're -> your
18:59:55 <elliott> <interactive>: oh
18:59:55 <elliott> <interactive>: interrupted
18:59:55 <elliott> <interactive>: warning: too many hs_exit()s
18:59:55 <elliott> oh _goody_
18:59:59 <dylukes> I've taken Grayhound before.... to Mexico.
19:00:03 <kmc> haha
19:00:04 <irene-knapp> O_O
19:00:06 <elliott> this will be _fun_
19:00:11 <kmc> i took the "greyhound" to "mexico" once
19:00:13 <edwardk> it was cheaper for me to fly to pennsylvania than take amtrak
19:00:16 <kmc> flying is likely cheaper
19:00:16 <edwardk> like $39
19:00:17 <kmc> yeah
19:00:18 * irene-knapp nods
19:00:21 <dylukes> edwardk: dayum sun.
19:00:31 <dylukes> I worry we may be off topic btw.
19:00:36 <dylukes> Then again, I may be being shachaf.
19:00:43 <edwardk> its about a hackathon =)
19:00:44 <kmc> hackathon is never off topic!
19:00:48 <dylukes> :P
19:00:54 * shachaf : ?
19:00:54 <kmc> i think BOS to anywhere on the northeast corridor is roughly $50 by air
19:00:59 <kmc> and more or less by train
19:01:03 <dylukes> Well, I'll talk to CS school guy tomorrow about if the school could fund it.
19:01:11 <dylukes> If the school can fund it, then I'd just need to convince le'parents.
19:01:15 <shachaf> You're going to the hackathon?
19:01:22 <dylukes> if I can get my school to pay for it, maybe.
19:01:54 <dylukes> Read up.
19:02:01 <edwardk> i don't think bos can get to anywhere in the northeast corridor for less than $400. he has to fly up from california after all
19:02:04 <dylukes> Some kids at my school won this big math competition, and the school got a $10,000 grant.
19:02:09 <shachaf> It's offtopic up there.
19:02:12 <shachaf> edwardk: Hah.
19:02:13 <dylukes> And the kids who won decided it should be used to fund competitions and whatnot in the future.
19:02:14 <kmc> by the way, if y'all can form groups of 4 and book in advance, there are some $30 / night / person hostels
19:02:37 <dylukes> kmc: We can't sleep in the upper rows of MIT lecture halls?
19:02:38 * shachaf is a group of 4 all by himself.
19:02:42 <irene-knapp> which competition was it?
19:02:47 <kmc> dylukes, give it a shot...
19:02:48 <dylukes> irene-knapp: I dunno. :<
19:02:54 * irene-knapp was big into highschool math stuff, once upon a time
19:02:55 <irene-knapp> ah okay
19:03:03 <dylukes> irene-knapp: I don't really like high school math competitions ;~;
19:03:08 <shachaf> dylukes: Isn't convincing a school to fund something like that typically almost futile?
19:03:09 <irene-knapp> awww!  but they're fun!
19:03:19 <dylukes> shachaf: I got my school to buy me an Arduino.
19:03:26 <kmc> you can also get an actual nice hotel room for not much more than 4*$30
19:03:27 <shachaf> Ah. Maybe not your school.
19:03:30 <kmc> and sneak 4 people into it
19:03:46 <dylukes> shachaf: As long as they can use it for their own public image afterwards, it's k.
19:03:50 <shachaf> kmc: Are you coming to BayHac?
19:03:53 <hpaste> stribor pasted “parser” at http://hpaste.org/53236
19:03:54 <kmc> beware of the Cambridge Gateway Inn, i hear it's full of pubic hair and bedbugs
19:03:56 <dylukes> this amuses me btw
19:03:57 <dylukes> http://www.winchesterthurston.org/cf_news/view.cfm?newsid=392
19:04:00 <elliott> hmm, so is it not OK for a Haskell FunPtr called from C to call error?
19:04:02 <kmc> shachaf, when is?
19:04:13 <stribor> i am following tutorial....and above the code is from there
19:04:24 <shachaf> kmc: Not sure. Maybe February?
19:04:26 <ksf> http://www.infoq.com/presentations/We-Really-Dont-Know-How-To-Compute
19:04:27 <stribor> so author suggest to try the code by doing this....char "1"
19:04:30 <kmc> shachaf, quite possibly
19:04:39 <shachaf> kmc: By the way, you added yourself as an attendee to Hac Boston more than two months in advance.
19:04:43 <kmc> i know
19:04:44 <shachaf> That must be a new record.
19:04:50 <kmc> no i was the 4th
19:04:51 <stribor> but by doing char "1" gives errors
19:04:55 <elliott> that's a shame if so :/
19:04:59 <shachaf> kmc: Personal record, I mean.
19:05:09 <dylukes> ooh ooh
19:05:09 <dylukes> http://www.winchesterthurston.org/uploaded/News_11-12/NationalMeritWEB.jpg
19:05:11 <dylukes> guess which one is me.
19:05:34 <kmc> shachaf, given that it's the first hackathon i've attended... yes
19:06:09 <shachaf> dylukes: Leftmost one.
19:06:15 <dylukes> no...
19:06:24 <kmc> dylukes, looks like PIT↔BOS is about $123 on USAir or JetBlue, at fairly convenient times
19:06:29 <elliott> dylukes: You're the gate.
19:06:33 <dylukes> JetBlue is nice.
19:06:42 <dylukes> elliott: damn how'd you know. Must have been my steely gaze.
19:07:01 <dylukes> I'm actually the guy in the dress with the yellow tie.
19:07:12 <dylukes> (nope)
19:07:22 <irene-knapp> dylukes: I was about to say that
19:07:33 <kmc> jetblue is double nice if you're stoned
19:07:44 * dylukes points out this is a logged room.
19:07:52 <shachaf> All rooms are logged.
19:08:04 <dylukes> Well, more visibly publicly logged.
19:08:14 <shachaf> And?
19:08:17 <dylukes> w/e
19:08:25 <dylukes> irene-knapp: Grace is wearing a suit.
19:08:31 <dylukes> But there are no men in dresses.
19:08:59 <irene-knapp> dylukes: heh, okay
19:09:00 * shachaf has a great picture of himself in a dress and make up and wig.
19:09:09 <edwardk> kmc: copumpkin has some site that gives really cheap rates
19:09:09 <dylukes> :D
19:09:24 <kmc> on air travel?
19:09:27 <edwardk> yeah
19:09:31 <shachaf> edwardk: Oh, which one?
19:09:32 <copumpkin> I think they mostly all get the same data now
19:09:35 <copumpkin> but I like the UI at http://www.hipmunk.com/
19:09:41 <shachaf> hipmunk.com is good, yes.
19:09:41 <copumpkin> most of the data comes from the matrix
19:09:41 <edwardk> thats what it was
19:09:44 <copumpkin> by ITA I think
19:09:46 * shachaf has a collection of them.
19:09:47 <copumpkin> which is here in boston
19:09:57 <shachaf> hipmunk.com has a great UI, but not always the best prices, in my experience.
19:09:58 <copumpkin> I think ITA has a visualization like hipmunk's now
19:10:11 <shachaf> google.com/flights and adioso.com are also good.
19:10:18 <copumpkin> http://matrix.itasoftware.com/
19:10:22 <shachaf> And that one.
19:10:23 <copumpkin> I think that's where all the data comes from
19:10:29 <copumpkin> for most of the other sites
19:10:34 <shachaf> There are some airlines that don't let those website collect data from them.
19:10:38 <shachaf> I think Southwest is among them.
19:10:56 <kmc> isn't there matrix2 also
19:11:05 <edwardk> and hipmunk seems to come in at $123 as well
19:11:17 <kmc> dylukes, you can probably do cheaper if you take Megabus and transfer in New York
19:11:20 <kmc> and book way in advance
19:11:24 <dylukes> I don't even know if I can go.
19:11:28 <dylukes> :P
19:11:31 <shachaf> Sure you can go.
19:11:36 <kmc> but whether you can go does depend on how much it costs, no?
19:11:44 <dylukes> No, whether I can go depends on whether my parents are okay with it.
19:11:50 <kmc> i mean if you want to use the school's grant money, "how much" will be their first question
19:12:02 <shachaf> adioso.com is finding <$119
19:12:04 <dylukes> My stepfather is a professor who is all-for conferences and symposiums and what not.
19:12:18 <dylukes> I think he values these kind of things a lot. And he likes that I'm academia focused.
19:12:24 <elliott> I wish peek and poke were in separate typeclasses so I could be lazy and not implement the one I don't need.
19:12:25 <shachaf> s/19/20/
19:12:31 <edwardk> sweet, so agree to give a talk at boston haskell about your experience using trifecta
19:12:32 <edwardk> =)
19:12:34 <kmc> that's what "error" is for
19:12:35 <dylukes> They likely would *not* like the staying in a hotel bit.
19:12:38 <kmc> or "return 0" or "return ()"
19:12:44 <elliott> kmc: Morally wrong!!!
19:12:47 <coppro> dylukes: see if you have a student body or endowment fund
19:12:48 <copumpkin> dylukes: you could sleep on a stranger's couch
19:12:51 <dylukes> edwardk: I could not give a talk XD. I doubt I'd have much to say.
19:12:55 <edwardk> i'm sure some creepy dude on the internet woud put you up
19:13:02 <dylukes> I don't think my parents are pro-couchsurfing.
19:13:07 <shachaf> dylukes: Come up with something to say, and then give a talk.
19:13:10 <coppro> dylukes: meh, you're  big boy now
19:13:14 <kmc> elliott, do what thou wilt shall be the whole of the law
19:13:35 <dylukes> coppro: I already said, theres a potential fund for this stuff of $10,000
19:13:44 <dylukes> It's for "competitions", but I think this qualifies.
19:13:55 <shachaf> edwardk: Did you upload dolio's slides somewhere, by the way?
19:13:56 <edwardk> we're doing pretty well for registrations, about half full so far
19:13:59 <kmc> dylukes, we can arrange a competition if necessary
19:14:03 <edwardk> shachaf: oh yeah i was going to do that
19:14:05 <kmc> edwardk, really? 15 people?
19:14:10 <edwardk> yeah
19:14:17 <kmc> sweeeet
19:14:27 <kmc> i guess none of them have wiki accounts
19:14:37 * shachaf refuses to edit wikis on moral grounds.
19:14:40 <edwardk> i may post the info to the wiki
19:14:43 <shachaf> I didn't register, though.
19:14:51 <shachaf> edwardk: After saying you wouldn't? You wouldn't!
19:15:02 <edwardk> i said i wouldn't?
19:15:15 <dylukes> kmc: haha, that'd be amusing XD.
19:15:27 <dylukes> arrange some sort of small competition to appease the fund management
19:15:39 <shachaf> Who can get to Hac Boston fastest?
19:15:45 <dylukes> I wish there was a Haskell user group in pittsburgh. :\
19:15:50 <shachaf> dylukes: Start one!
19:15:50 <augur> ski: which part of which paper mentions use/discard stuff?
19:15:59 <shachaf> dylukes: There are plenty of Haskell people in PGH.
19:16:00 <dylukes> shachaf: If I end up at Pitt or CMU,
19:16:03 <dylukes> I'm absolutely starting one.
19:16:08 <shachaf> Why not do it now?
19:16:15 <dylukes> time/funds/etc
19:16:22 <dylukes> mostly a lack of freedom/free time
19:16:29 <dylukes> We have at least six universities here, there are plenty of haskellers.
19:17:10 <dylukes> (well, I'm sure somewhere :P)
19:17:21 <shachaf> They definitely exist.
19:17:26 * shachaf has met a couple.
19:17:32 <dylukes> Just need to pull 'em out of the woodwork.
19:17:48 <dylukes> He have a pretty successful Ruby group here.
19:17:51 <dylukes> Something similar would be good.
19:17:51 <shachaf> FSVO "Haskeller"
19:18:36 <dylukes> The other reason is because once I'm a student it'll be easier to potentially get meeting space from CMU/Pitt.
19:18:46 <dylukes> Maybe someday there will be a HacPGH
19:18:59 <elliott> I really wish hsc2hs supported anonymous structs :(
19:19:24 <shachaf> elliott: Anonymous structs are the devil.
19:19:34 <shachaf> dylukes: What you really ought to do is learn SML.
19:19:38 <shachaf> SML is the real deal.
19:19:42 <elliott> shachaf: If the thing I was binding to didn't suck, it would be written in Haskell in the first place.
19:20:01 <dylukes> shachaf: I might at some point, to broaden my language knowledge.
19:21:07 <dylukes> kmc: edwardk: copumpkin: If in a few years I had a haskell user group here, a hackathon here would be fun.
19:21:18 <shachaf> So is there a data type for a collection of things where ordering isn't important, but you don't want constraints on them?
19:21:23 <edwardk> dylukes: there as always hac-phi
19:21:27 <dylukes> Yeah, true.
19:21:37 <shachaf> You could use a list but that has too much structure, I think.
19:21:45 <dylukes> I think it would be interesting to have an open invitation policy for local students though.
19:21:55 <shachaf> For instance, it's a bit difficult to parallelize list operations like folds.
19:21:55 <dylukes> There are a LOT of students here :|.
19:22:03 <dylukes> Like, if you're in oakland, 9/10 people are students.
19:23:20 <Eduard_Munteanu> shachaf: like sets?
19:23:30 <stribor> can someone help me with this tutorial please -> http://www.google.ca/url?sa=t&rct=j&q=parsing%20with%20haskell&source=web&cd=8&ved=0CFUQFjAH&url=http%3A%2F%2Fthor.info.uaic.ro%2F~grigoras%2Fdiplome%2F9.pdf&ei=bxWqTr6jAYXq0gGB6s28Dw&usg=AFQjCNFuHJyPQ2UyJRX6WqfE_4lXdAxdDg&cad=rja
19:23:37 <shachaf> Eduard_Munteanu: That has an Ord constraint.
19:23:49 <Eduard_Munteanu> shachaf: I mean like math sets
19:24:01 <dylukes> edwardk: To be honest, what would be really fun
19:24:17 <dylukes> would be to hold as many sort of hackthon/festival type things as possible at once, with the explicit goal,
19:24:18 <shachaf> Eduard_Munteanu: Well, sure. Or multisets, or something.
19:24:19 <shachaf> ,
19:24:22 <kmc> in these cases I often use Set with a more or less arbitrary Ord
19:24:38 <stribor> anyone wiling to explain somehting please
19:24:46 <dylukes> To bring as many people from high-profile colleges together at once as is possible.
19:24:51 <edwardk> dylukes: well hac phi had a simulcast version from some place in germany or something
19:24:55 <shachaf> kmc: That seems a bit silly. You introduce a newtype for it?
19:24:58 <kmc> yeah
19:24:59 <edwardk> but it wasn't really effective
19:25:00 <copumpkin> stribor: we won't know until you tell us what you want explained
19:25:04 <dylukes> edwardk: that's too bad.
19:25:13 <elliott> Hmm, I don't think there's even a way to use offsetof() with anonymous structs. :/
19:25:13 <shachaf> Hac Phi and Hac PDX and Hac Aus and so on were all happening around the same time.
19:25:19 <kmc> sillier still is «data Ordered a = Ordered (a -> a -> Ordering) a»
19:25:26 <dylukes> Of course there's a Hac PDX :<
19:25:32 * dylukes wants to move back to Portland some time.
19:25:41 <kmc> you run into trouble if your values don't all specify the same ordering
19:25:42 <stribor> copumpkin: part where author says (at close to top)..."Basics parsers are almost trivial"
19:25:43 <shachaf> New York is the place to be.
19:26:03 <dylukes> stribor: except they have to be in context otherwise it can't infer the Stream type and it ALL BREAKS.
19:26:04 <stribor> copumpkin: char::Parser Char
19:26:09 <Eduard_Munteanu> Sillier, but more set-like, would be having a function pose as your set. Like a membership predicate.
19:26:21 <shachaf> I don't want a membership predicate.
19:26:30 <Eduard_Munteanu> Although that does have internal structure too.
19:26:31 <shachaf> I want to do things like sum the set in parallel. Or something.
19:26:33 <dylukes> oh wow, looked at their food list.
19:26:38 <dylukes> Taco del Mar and Hot Lips pizza.
19:26:40 <stribor> copumpkin: i copied that function and author suugest to try it like this char "1"
19:26:40 <dylukes> That takes me back.
19:27:14 <ClaudiusMaximus> gnarg.  openBinaryFile: invalid argument (File name too long)
19:27:23 <Eduard_Munteanu> shachaf: why not use an array then? Or something similar. I think that's what DPH does.
19:27:23 <edwardk> stribor: char :: String -> Maybe (Char, String)     -- char (x:xs) = Just (x,xs); char [] = Nothing
19:27:43 <shachaf> Eduard_Munteanu: That's not particularly good for creating functionally...
19:27:44 <edwardk> dylukes: he's playing around with a very basic parser type
19:27:47 <stribor> edwardk: id like to try it on my interpretert but i get error
19:27:53 <shachaf> I just want a balanced tree or something, I guess.
19:28:01 <stribor> edwardk: i am trying it like this char "1"
19:28:01 <edwardk> stribor: what parser type are you using?
19:28:09 <shachaf> With no Ord constraint. :-)
19:28:20 <dylukes> shachaf: Couldn't you sum a tree representation by descending the branches in parallel till the bottom, then summing up...?
19:28:20 <Eduard_Munteanu> Yeah that'd do. :/
19:28:25 <dylukes> assuming the elements are monoids.
19:28:29 <stribor> edwardk: ?
19:28:36 <dylukes> recursive descent with `par` and `pseq`
19:28:39 <shachaf> dylukes: Semigroups, as long as you're at it.
19:28:42 <edwardk> stribor: type Parser a = ??
19:28:46 <dylukes> Oh, true.
19:28:50 <shachaf> dylukes: My point is that I want a data structure to do that with.
19:28:57 <stribor> edwardk: i didnt know i need one to try that function
19:29:00 <shachaf> The point is that very often you have a collection of things that you store as lists, but the list structure is only incidental.
19:29:06 <dylukes> shachaf: You just need to put a constraint on the collection items no?
19:29:10 <shachaf> An Ord constraint is also incidental.
19:29:11 <stribor> edwardk: author doesnt say anything about that
19:29:12 <edwardk> stribor: you can define the body of it i suppose
19:29:16 <shachaf> What if they're IO actions?
19:29:19 <shachaf> Or functions?
19:29:21 <edwardk> the author gives two definitions of Parser on page 2
19:29:28 <shachaf> Or IO functions, like getLine?!
19:29:32 <stribor> edwardk: can you show me example how i would use that function please
19:29:47 <Eduard_Munteanu> How about a Seq?
19:29:50 <edwardk> you would write a bunch of parser combinators to glue it together with other parsers
19:30:10 <Eduard_Munteanu> IIRC you don't need ordering for that.
19:30:16 <shachaf> You don't?
19:30:20 <shachaf> The name would suggest otherwise...
19:30:42 <elliott> Seq is just a list.
19:30:44 <Eduard_Munteanu> fromList :: [a] -> Seq a
19:30:45 <elliott> Well, a strict list.
19:30:49 <elliott> On speed.
19:30:54 <Eduard_Munteanu> elliott: it's a tree AFAIK
19:31:03 <Eduard_Munteanu> Some sort of tree, I don't remember.
19:31:05 <shachaf> It's represented as a tree.
19:31:10 <elliott> 2-3 finger tree.
19:31:16 <Eduard_Munteanu> Ah, right.
19:31:18 <elliott> That's not very many fingers.
19:31:22 <edwardk> stribor: char "hello"    would yield Just ('h',"ello")
19:31:26 <dylukes> edwardk: Have you played with IterIO?
19:31:27 <shachaf> elliott: It's enough for me.
19:31:29 <kmc> it's a fun weird ADT by the way
19:31:30 <edwardk> dylukes: yes
19:31:32 <kmc> if you look at the implementation
19:31:33 <dylukes> thoughts?
19:31:46 * kmc spent a while staring at Seq guts the other day
19:31:49 <stribor> edwardk: i dont get that
19:32:01 <edwardk> what do you get?
19:32:04 <dylukes> I like it so far myself. Seems more practical and the core abstraction makes more sense to me.
19:32:12 <hpaste> stribor pasted “parser” at http://hpaste.org/53237
19:32:20 <Eduard_Munteanu> Well, if you get O(log n) or so access to the middle so you can split it and so on... I think it's ok.
19:32:21 <edwardk> dylukes: "meh"
19:32:24 <stribor> Eduard_Munteanu: thats my code
19:32:30 <stribor> edwardk: thats my code
19:32:32 <dylukes> To each their own :)
19:32:51 <edwardk> stribor: that code is NOT using parsec
19:32:57 <edwardk> lennart is describing how to make its own parser
19:32:59 <edwardk> remove the imports
19:33:17 <Eduard_Munteanu> The next question is whether its fromList fuses alright.
19:33:32 <edwardk> without the import lines its self contained
19:33:41 <stribor> edwardk: i removed imports.,...whats next
19:33:51 <edwardk> you defined a type Parser, and a function with the right type
19:34:04 <edwardk> you've built a parsing combinator library in the old 'world before monads' sort of way
19:34:06 <stribor> edwardk: ok it works now
19:34:17 <Eduard_Munteanu> (might matter depending on how you want to get a Seq in the first place)
19:34:27 <edwardk> now you can follow the rest of lennart's examples and get a feel for how parsing combinators fit together
19:34:36 <edwardk> he describes a series of more complicated parsers
19:34:42 <edwardk> then once you have worked through that paper
19:34:47 <stribor> edwardk: why is parsing string so copmlicated
19:34:58 <edwardk> its not
19:34:58 <edwardk> http://eprints.nottingham.ac.uk/223/1/pearl.pdf
19:35:02 <edwardk> makes a prettier version
19:35:23 <edwardk> but it gives you more newtype noise so its harder to define, even though easier to use
19:35:33 <edwardk> lennart's approach is easy to see what is happening
19:35:41 <Eduard_Munteanu> splitAt :: Int -> Seq a -> (Seq a, Seq a)    O(log(min(i,n-i))).    ... they say.
19:35:47 <stribor> edwardk: why when you defining these parser different syntax is used
19:36:07 <edwardk> stribor: what do you mean?
19:36:21 <stribor> edwardk: for example in function "item" in the paper you just linked
19:36:41 <edwardk> stribor: they just made up different functions, and different names for things
19:36:53 <edwardk> the parsers used in that paper have a different parser type
19:36:59 <edwardk> newtype Parser a = Parser (String -> [(a,String)]
19:37:15 <edwardk> which means that they have to wrap the function in a 'Parser' constructor
19:37:26 <edwardk> otherwise its very similar to lennart's
19:37:32 <edwardk> [] instead of Maybe
19:37:50 <edwardk> so you can succeed multiple different ways yielding multiple parses
19:37:54 <stribor> edwardk: is one you just linked harder to learn
19:38:17 <edwardk> i would recommend continuingthrough lennart's paper, then trying out erik's
19:38:35 <stribor> edwardk: ok thanks
19:38:36 <edwardk> lennart's will give you a good intuition for how all the parts fit together
19:38:49 <edwardk> erik's version will teach you something closer to how you would implement it in practice
19:39:27 <edwardk> since because lennart is using 'type' instead of 'newtype' you have to make up names for all the concepts and can't use standard classes, etc.
19:40:40 <stribor> edwardk: i dont get in lendar paper whats the point of parser thats reads one char.....in "char" function
19:40:55 <edwardk> stribor: you stitch it together with other parsers
19:41:08 <edwardk> so if you had a parser that ran a parser many times, you could use it to recognize a string
19:41:23 <edwardk> or one that tested a condition you could use it to parse a particular char or set of chars
19:41:37 <stribor> edwardk: so you would need one parser that would take in another parser to read string???
19:43:00 <stribor> edwardk: can you write exampkle of another parser that would use char function to read string
19:43:34 <edwardk> many p xs = do (a,xs') <- p xs; (as, ys') <- many p xs; return (a:as, ys')
19:43:39 <edwardk> then string = many char
19:44:09 <edwardk> that would consume all of the remaining input and give it to you as a string
19:44:21 <edwardk> you could of course implement  that special case directly
19:44:32 <stribor> edwardk: thanks
19:44:34 <edwardk> rest xs = Just (xs, xs) -- which makes it kinda boring
19:44:41 <edwardk> actually i probably screwed that up
19:45:02 <edwardk> many p xs = (do (a,xs') <- p xs; (as, ys') <- many p xs; return (a:as, ys')) <|> return []
19:45:12 <edwardk> er return ([],xs)
19:45:25 <edwardk> though that uses a bunch of stuff you don't currently have in scope
19:45:34 <edwardk> but i did so to keep it on one line
19:46:21 <edwardk> usually i'd call the parser lennart called 'char' anyChar
19:46:33 <edwardk> and then make a parser char :: Char -> Parser () -- which only recognized a given char
19:46:55 <stribor> this seems so complicated
19:47:07 <edwardk> it makes more sense once the problems become harder
19:48:07 <edwardk> here is an example of parser combinators parsing an RFC
19:48:17 <edwardk> https://github.com/ekmett/trifecta/blob/master/examples/RFC2616.hs
19:48:19 <stribor> seems so easy to read string in Java  or C
19:48:46 <edwardk> that is dealing with parsing and syntax highlighting and error reporting for RFC2616
19:49:00 <stribor> edwardk: thats too comlicated for me now...lol
19:49:04 <sagelywizard> So, I'm trying to parse JSON using Aeson and am having some difficulty with parsing from text to a recursive data type. Here's an example of the type of JSON I'm parsing from and the data types I'm parsing into. http://hpaste.org/53239
19:49:13 <edwardk> i'm just showing you can stitch these small parsers together
19:49:20 <edwardk> some (satisfy (not . isHSpace))
19:49:22 <edwardk> for instance
19:49:34 <edwardk> is saying use 'satisfy' which takes a character and checks a predicate on it
19:49:40 <edwardk> and then use 'some' of those
19:49:55 <edwardk> so it gets multiple characters that satisfy the not . isHSpace predicate
19:50:09 <edwardk> so many characters that are not ' ' or '\t'
19:50:16 <kmc> stribor, what does "read string" mean in this context?
19:50:25 <kmc> in Haskell you don't need a parser just to read a string
19:50:40 <kmc> you use parsers to convert some kind of syntax to complex structured data
19:50:52 <kmc> what is it that you actually want to do
19:50:56 <shachaf> Or, hopefully, simple structured data!
19:51:13 <stribor> kmc: ?
19:51:24 <kmc> stribor, ??
19:51:24 <stribor> kmc: i thought parsers are just to et input
19:51:29 <kmc> no
19:51:40 <stribor> kmc: oh..
19:51:42 <kmc> maybe you want
19:51:43 <kmc> :t getLine
19:51:45 <lambdabot> IO String
19:51:56 <edwardk> stribor: he is trying to figure out why you want to use parser combinators. many usecases can be handled with just getLine or read, etc.
19:52:10 <kmc> stribor, parsers are not about IO
19:52:15 <shachaf> "read" is so a parser!
19:52:24 <elliott> id is the best parser.
19:52:27 <edwardk> shachaf: yes but it is one defined FOR you
19:52:27 <kmc> stribor, parsers are about converting data between formats
19:52:36 <kmc> stribor, specifically, converting data from String to some more structured type
19:52:36 <shachaf> edwardk: Fine, ReadP.
19:52:39 <edwardk> :t interact
19:52:40 <lambdabot> (String -> String) -> IO ()
19:53:19 <stribor> kmc: so you mean like taking input of type string and converting to some type which is arbitrary typwe
19:53:38 <kmc> maybe
19:54:04 <edwardk> > read "423" :: Int
19:54:05 <lambdabot>   423
19:54:17 <edwardk> > read "[1,2,3]" :: [Int]
19:54:18 <kmc> stribor, have you used parsers in C or Java?
19:54:19 <lambdabot>   [1,2,3]
19:54:58 <stribor> no...never....i thought parsers are just for input read...i got this all wrong
19:55:18 <kmc> you didn't use parsers in C just to read a string
19:55:23 <kmc> and you don't need them in Haskell either
19:55:42 <edwardk> parsers are usually used in haskell when you need to read in some kind of config file or source code or some such
19:56:48 <stribor> no i didnt
19:56:50 <stribor> lol
20:04:19 <jtannenbaum> I'm new to haskell, and I tried my hand at a function. It probably already exists, but if it does, don't tell me; rather, I'd like to know if there's something I was overlooking in making it that would make it less complicated: http://paste.pound-python.org/show/14326/
20:04:33 <jtannenbaum> for educational purposes
20:05:00 <jtannenbaum> also, it'll probably have bugs
20:05:04 <shachaf> jtannenbaum: "is a" just returns a.
20:05:17 <jtannenbaum> yea, because the function all wants a function
20:05:28 <shachaf> Oh.
20:05:30 <shachaf> @src all
20:05:30 <lambdabot> all p =  and . map p
20:05:30 <aavogt> such a function already exists
20:05:33 <shachaf> You can just use and.
20:05:39 <shachaf> Also, there's a function "id" that returns its argument.
20:05:59 <kmc> booleans are first-class values
20:06:00 <jtannenbaum> oh, nice
20:06:06 <kmc> you can use them in contexts other than conditionals
20:06:17 <kmc> (a == True) == a
20:06:26 <shachaf> Yes -- something like "a == True" can always be replaced with "a".
20:06:29 <kmc> @check \a -> (a == True) == a
20:06:31 <lambdabot>   "OK, passed 500 tests."
20:07:02 <kmc> jtannenbaum, a more direct way to write "is" would be «is True = True; is _ = False»
20:07:03 <aavogt> you might get an ambiguous type variable
20:07:05 <kmc> though it's still silly
20:07:15 <jtannenbaum> ah, true
20:07:18 <dylukes> kmc: Writing the actual "post" part of a blog post is hard :<
20:07:20 <jtannenbaum> on both counts
20:07:27 <dylukes> Specifically, how to introduce it.
20:07:27 <kmc> yeah, (== True) functions kind of like (:: Bool)
20:07:51 <aavogt> but there's possibly some runtime overhead
20:07:54 <kmc> dylukes, "READ MY KODE"
20:08:10 <dylukes> Subtle.
20:08:21 <dylukes> I'll just write the code as lhs and fill it in later...
20:09:03 <shachaf> Maybe ilhs would do too.
20:12:35 <shachaf> jtannenbaum: You function is also pretty inefficient, by the way.
20:12:39 * hackagebot ascii 0.0.3 - Type-safe, bytestring-based ASCII values.  http://hackage.haskell.org/package/ascii-0.0.3 (MichaelSnoyman)
20:12:41 <jtannenbaum> I'm sure it is
20:12:59 <shachaf> I mean, asymptotically
20:13:18 <jtannenbaum> you can tell me if there's a built-in now, and I'm also interested in the best way to implement it
20:13:45 <shachaf> There's a function in the standard library called "maximum".
20:13:47 <shachaf> @src maximum
20:13:48 <lambdabot> maximum [] = undefined
20:13:48 <lambdabot> maximum xs = foldl1 max xs
20:14:28 <jtannenbaum> I guess the key is knowing what foldl1 is/how it works
20:14:34 <shachaf> foldl1 captures the recursion pattern that's (usually, though not always?) optimal for this.
20:14:50 <shachaf> It folds a list -- do you know what that is -- using an accumulator.
20:15:03 <shachaf> s/is /is? /
20:15:05 <shachaf> > foldl f z [a,b,c,d]
20:15:06 <lambdabot>   f (f (f (f z a) b) c) d
20:15:21 <jtannenbaum> ah, like python's reduce sort of
20:15:33 <shachaf> Yep, almost exactly like Python's reduce. :-)
20:15:37 <shachaf> In Haskell foldr is also important:
20:15:42 <shachaf> > foldr f z [a,b,c,d]
20:15:43 <lambdabot>   f a (f b (f c (f d z)))
20:16:01 <jtannenbaum> I'm coming from python, getting used to the paradigms
20:16:15 <shachaf> In fact foldr is more fundamental than foldl for various reasons.
20:16:55 <shachaf> (foldr just replaces the structure of a list with your values. It's more useful in a lazy language than in a strict one.)
20:17:02 <kmc> could someone explain to me how GHC's WHITEHOLE closures work?  i thought that they were used instead of BLACKHOLEs and that each one has a waitqueue for threads to be notified when that thunk is done evaluating
20:17:17 <dylukes> It seems pandoc wants json-0.4.4, which doesn't compile for me :\
20:17:24 <shachaf> jtannenbaum: "max" is a good function to know about.
20:17:26 <kmc> but reading the code it looks more like WHITEHOLE is only used transiently in a spinlocky way, on the way to blackholing a thunk
20:17:31 <shachaf> (You could easily write it yourself, of course.)
20:17:45 <jtannenbaum> yea, I know about max
20:17:52 <kmc> which would imply that with THREADED_RTS, BLACKHOLE handles the waitqueue and does not kill threads on entry
20:17:57 <kmc> but I'm still investigating
20:18:00 <jtannenbaum> going through LYaHfGG
20:18:31 <shachaf> jtannenbaum: Try reimplementing maxList using max.
20:18:58 <elliott> maxList? is that different to maximum?
20:19:02 <shachaf> There are at least two implementations, both of them more efficient than your current one.
20:19:11 <shachaf> elliott: That's the name of the function jtannenbaum @pasted.
20:19:21 <elliott> oh
20:23:27 <jtannenbaum> http://paste.pound-python.org/show/14327/ this version uses max and is a bit more lazy, I venture to say
20:25:00 <aavogt>  max x a == a  should be the same as    x <= a
20:25:13 <shachaf> jtannenbaum: "more lazy" in what way?
20:25:27 <shachaf> Anyway, "any id" === "all"
20:25:33 <shachaf> And you're still doing an O(n^2) thing.
20:26:08 <jtannenbaum> I would hope any f [x] would return False as soon as not f(a) for an a in x, rather than exhausting the whole list
20:26:23 <dylukes> edwardk: What would you recommend as the most elegant way to parse string literals?
20:26:39 <dylukes> (perhaps including escapes, since it'd be nice to one-up as much as possible)
20:26:40 <shachaf> dylukes: id?
20:26:51 <kmc> hmm and what of these BLOCKING_QUEUEs
20:26:51 <shachaf> Oh.
20:27:06 <jtannenbaum> I'm probably not up on algorithms enough to implement something better without just copying maximum's src
20:27:18 <shachaf> jtannenbaum: Oh, I see what you meant, I think.
20:27:32 <kmc> f [x] = x; f (x:xs) = max x (f xs)
20:27:42 <shachaf> jtannenbaum: Don't copy maximum's src. Just -- yes, what kmc said works.
20:27:57 <jtannenbaum> ooh, darn yea
20:28:33 <shachaf> maximum does something almost equivalent, except that it uses an accumulator and does it "tail-recursively".
20:29:19 <aavogt> are there any implementations such that    max maxBound undefined == maxBound?
20:29:37 <EvanR> > maximum []
20:29:39 <lambdabot>   *Exception: Prelude.maximum: empty list
20:29:40 <copumpkin> aavogt: no
20:29:59 <copumpkin> :t max
20:30:00 <lambdabot> forall a. (Ord a) => a -> a -> a
20:30:11 <copumpkin> it can't know about Bounded
20:30:19 <copumpkin> or wait, is it a method?
20:30:20 <shachaf> @src max
20:30:20 <lambdabot> max x y = if x <= y then y else x
20:30:25 <copumpkin> okay, it isn't
20:30:34 <kmc> :t maximum . (maxBound :)
20:30:35 <lambdabot> forall a. (Ord a, Bounded a) => [a] -> a
20:30:41 <aavogt> I mean you could write the specific Ord instance to do that
20:30:42 <shachaf> copumpkin: Presumably (<=) could know about maxBound
20:30:58 <copumpkin> shachaf: fair enough
20:31:22 <aavogt>  x <= y | x == maxBound = x | otherwise = ...
20:31:36 <aavogt> oops,
20:31:57 <copumpkin> actually
20:32:36 <aavogt>  x <= y =  y == maxBound || ...
20:32:39 * hackagebot snap-core 0.6.0 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.6.0 (DougBeardsley)
20:32:41 * hackagebot snap-server 0.6.0 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.6.0 (DougBeardsley)
20:34:33 <parcs> cool, 0.6 is out
20:37:11 <parcs> "cabal: dependencies conflict: heist-0.6.0.0 requires an installed instance of time ==1.4 however: <blank>"
20:37:27 <parcs> thanks cabal
20:37:43 * hackagebot heist 0.6.0 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.6.0 (DougBeardsley)
20:37:45 * hackagebot snap 0.6.0 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.6.0 (DougBeardsley)
20:37:53 <elliott> ?remember parcs <parcs> "cabal: dependencies conflict: heist-0.6.0.0 requires an installed instance of time ==1.4 however: <blank>"  <parcs> thanks cabal
20:37:54 <lambdabot> Done.
20:38:24 <mightybyte> Anyone know when the hackage server's next documentation run happens?
20:39:05 <parcs> it seems to run like every four hours
20:39:23 <mightybyte> Hmmmmm, do I get lucky and get it at the top of the next hour?
20:39:32 <parcs> maybe!
20:39:48 <edwardk> dylukes: stringLiteral ;)
20:39:52 <dylukes> yeah found it already
20:40:08 <dylukes> I'm taking some liberties and making this a good bit "better" than the WYSi48
20:40:24 <dylukes> Would you mind if I emailed it to you for a quick edit?
20:40:32 <edwardk> ?
20:40:34 <dylukes> Assuming I finish tomorrow.
20:40:46 <edwardk> which project is this?
20:40:49 <dylukes> Writing a Trifecta example/intro/tutorial.
20:40:56 <dylukes> A few people said they'd be interested.
20:41:05 <edwardk> ah
20:41:26 * kfish wonders why hackage's documentation doesn't run on every new upload, or check every 5 min instead of 4 hrs ...
20:45:23 <DanBurton> dylukes: be sure to let us know when it is finished :)
20:45:32 <dylukes> Debating what level to put it at.
20:45:57 <dylukes> I kind of just want to introduce the features assuming trifecta knowledge.
20:46:07 <dylukes> not give a parser combinator tutorial. I'm not really qualified for that anyways.
20:47:09 * dylukes wonders if its a good thing or not that he's using the 1967 Lisp Primer as his source.
20:47:11 <DanBurton> just do whatever flows out of your fingers
20:47:14 * dylukes Scheme? Common Lisp?
20:47:46 <dylukes> One debate I'm having is that I'd like to try to make the AST close to the actual Lisp representation.
20:48:01 <dylukes> i.e, SExpr = [(SExpr | Atom)]
20:48:15 <dylukes> but that'd require existential types and what not.
20:48:54 <kmc> why?
20:49:08 <dylukes> For a heterogenous list.
20:49:19 <kmc> data Expr = Atom String | Comb [Expr]
20:49:31 <kmc> (you can add more atom types, of course)
20:49:42 <shachaf> dylukes: It's a closed sum, isn't it?
20:50:13 <dylukes> actually, never mind I think it's fine this way...
20:50:19 <dylukes> :)
20:50:22 <dylukes> I got it.
20:50:26 <dylukes> (without an existential, don't worry)
20:51:20 <shachaf> dylukes: Anyway, an SExpr is actually either an atom or a pair of SExprs.
20:51:37 <dylukes> Yeah, that's what I was thinking... list syntax is just sugar really.
20:52:02 <dylukes> but it might be nice to include List so its bearable to look at.
20:53:15 <shachaf> That seems like a pretty-printing thing.
20:53:32 <elliott> kfish: server load, presumably
20:54:08 <kfish> elliott, yeah, i just mean that it would be the same amount of work regardless of when you do it
20:54:27 <elliott> yeah, but compare "system is unusable for half an hour starting at 6 am" with "system is always noticably slower" :p
20:54:49 <dylukes> data SExpr = DottedPair SExpr SExpr | List [SExpr] | SymbolicAtom String | NumericAtom Double | StringAtom String
20:54:57 <dylukes> seems like a fair compromise and easy enough to me.
20:55:13 <dylukes> I'm just looking for something to parse. :)
20:55:21 <kfish> cool, as long as that's 6am in GMT+7 i'm ok with it
20:56:33 <sagelywizard> I've been trying to figure out JSON parsing using the Aeson library. I've been going off the example here: http://tinyurl.com/3dk37sl What if the data type "Coord" (in the example) had another value "3DCoord {x :: Double, y :: Double, z :: Double}"? How would you tell (parseJSON) to parse {"x": 1.1, "y": 2.2} as a Coord value and {"x": 1.1, "y": 2.2, "z": 3.3} as a 3DCoord value?
20:57:08 <kfish> (we could avoid the load / documentation servers issue entirely by having "cabal upload" run haddock ...)
20:57:16 <luite> I have a large number of yesod handlers for a JSON service, and want to catch any exception occurring in those, wrapping the result in a JSON reply. does anyone know how to do that?
20:57:23 <shachaf> sagelywizard: Hah, the author of Aeson joined the channel within a few seconds of you asking the question. :-)
20:57:50 <elliott> kfish: that's problematic
20:57:54 <elliott> you could put arbitrary html up
20:58:02 <elliott> ... with a sanitiser, though...
20:58:09 <elliott> it would also allow C bindings and the like to get docs...
20:58:11 <copumpkin> proof-carrying html
20:58:31 <elliott> heh
20:58:32 <sagelywizard> shachaf: A few seconds before or after? :P
20:58:42 <elliott> ddosing hackage by giving it a particularly computationally-expensive proof
20:59:09 <shachaf> Before.
20:59:35 <elliott> shachaf: no, after
20:59:44 <shachaf> elliott: ?
20:59:49 <elliott> <sagelywizard> I've been trying to figure out JSON parsing using the Aeson library. I've been going off the example here: http://tinyurl.com/3dk37sl What if the data type "Coord" (in the example) had another value "3DCoord {x :: Double, y :: Double, z :: Double}"? How would you tell (parseJSON) to parse {"x": 1.1, "y": 2.2} as a Coord value and {"x": 1.1, "y": 2.2, "z": 3.3} as a 3DCoord value?
20:59:50 <elliott> * bos (~bos@c-71-202-84-228.hsd1.ca.comcast.net) has joined #haskell
20:59:52 <elliott> at least here
21:00:01 <shachaf> elliott: Er. He asked the question before.
21:00:05 <elliott> oh. right.
21:00:10 * shachaf 's answer wasn't very helpful.
21:00:18 <shachaf> Just listen to elliott. elliott knows.
21:29:57 <prototrout> Huh. Hoogle doesn't like "a -> b -> c -> d -> e -> f -> g -> h -> i" (it hangs (or at least takes a very, very long time in) both the prototrout command-line utility and the website. Without the "-> i" it's fairly quick with an answer.
21:30:12 <prototrout> )
21:30:24 <shachaf> @hoogle a -> b -> c -> d -> e -> f -> g -> h -> i
21:30:42 <shachaf> Like, whoa, man.
21:30:44 <lambdabot> thread killed
21:30:45 <shachaf> File a bug report.
21:30:49 <mzero> you expect to find a function like that?
21:31:06 <prototrout> No, I was just playing with it.
21:31:24 <mzero> (I seem to recall once profiling the Smalltalk tree trying to find the histogram of argument counts... and the max -- I think 16 args was the most)
21:31:33 <mzero> (or 19 -- in that range)
21:31:37 <luite> is there a somewhat generic way to do exception handling in a monad transformer stack with an iteratee?
21:31:48 <kmc> haha, i worked somewhere that had a 20-argument C++ constructor
21:31:56 <kmc> most of the args were bools, some defaulted to true, some to false
21:32:10 <kmc> and you had to be very careful because they'd get added on branches in one order and then merged in another order
21:57:34 <Quantumplation> hrm, i don't quite get the haskell fix function.
21:57:54 <kmc> did you see http://www.vex.net/~trebla/haskell/fix.xhtml
21:58:25 <Quantumplation> nope, thanks :D
21:58:58 <shachaf> I sometimes wish there was a dynamically-typed lazy language that was just like Haskell.
21:59:07 <shachaf> For demonstrating Y in, for instance.
21:59:14 <bfig> shachaf, you mean like lisp?
21:59:31 <shachaf> No.
21:59:36 <shachaf> I don't like S-expressions much.
21:59:41 <shachaf> And I *do* like laziness.
21:59:47 <bfig> :|
21:59:51 <shachaf> In particular, eta-reduction makes Y much clearer, I think.
22:00:01 <copumpkin> shachaf
22:00:05 <copumpkin> you can write Y in haskell
22:00:10 <shachaf> copumpkin: Using Rec?
22:00:20 <copumpkin> not sure what Rec is, but probably
22:00:25 <shachaf> @src rec
22:00:25 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:00:28 <shachaf> @src Rec
22:00:28 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
22:00:32 <copumpkin> okay :)
22:00:33 <copumpkin> yep
22:00:33 <shachaf> @where y
22:00:34 <lambdabot> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
22:00:48 <shachaf> copumpkin: I did say for *demonstrating* it.
22:00:54 <shachaf> I.e., for pedagogical purposes, and all.
22:01:05 <copumpkin> looks clear as <something clear> to me
22:02:00 <shachaf> copumpkin: Does it look as clear as Y f = (\x -> f (x x)) (\x -> f (x x))?
22:02:07 <copumpkin> yep
22:02:14 <copumpkin> why'd you post the same thing twice?
22:02:25 <shachaf> Y f = (\x -> x x) (\x -> f (x x))
22:03:15 <bfig> shachaf, you can always hide that in a recursive functor type. newtype Fix f = In{Out:: f (Fix f)}
22:03:25 <copumpkin> shachaf: why'd you drop the f?
22:03:33 <shachaf> copumpkin: Because it's shorter and still works?
22:03:47 <shachaf> It's arguably not Y, though.
22:04:02 <shachaf> But it reduces to Y in one reduction.
22:04:31 <shachaf> bfig: In order to do what?
22:05:25 <bfig> shachaf, recursion :) you need to put whatever you want inside though
22:33:26 <osfameron> @where e
22:33:27 <lambdabot> I know nothing about e.
22:33:39 <osfameron> meh
22:40:15 <elliott> osfameron: exp
22:40:47 <kmc> > iterate exp 1
22:40:52 <lambdabot>   mueval-core: Time limit exceeded
22:41:09 <Insolsence> Hey there
22:41:12 <Insolsence> I had a question
22:41:18 <Insolsence> what does <|> mean?
22:41:51 <kmc> well it's a user-defined operator, it could mean anything
22:41:55 <kmc> depending on your imports
22:42:01 <kmc> but probably http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/Control-Applicative.html#v:-60--124--62-
22:42:22 <osfameron> elliott: ah, thanks
22:43:01 <smoge> hello
22:43:06 <kmc> can provide more information if you tell me about the context in which it occurs
22:43:21 <smoge> any good source ot tutorial aboug random and probability in Haskell?
22:43:33 <osfameron> > (exp 1) ^ (-1)
22:43:35 <lambdabot>   *Exception: Negative exponent
22:43:45 <osfameron> why doesn't it do negative exponents?
22:43:55 <bfig> Insolsence, parsec?
22:43:58 <kmc> > exp 1 ^^ (-1)
22:44:00 <lambdabot>   0.36787944117144233
22:44:28 <osfameron> ah
22:44:33 <kmc> :t (^)
22:44:36 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
22:44:36 <kmc> :t (^^)
22:44:38 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
22:44:43 <bfig> Insolsence, in that case it will give you a 'try if before failed' iirc
22:44:52 <kmc> only Fractional things are guaranteed to support negative exponents
22:45:03 <kmc> > (2 :: Int) ^ (-1)
22:45:04 <lambdabot>   *Exception: Negative exponent
22:45:10 <kmc> buh
22:45:17 <kmc> right, it's a runtime error :/
22:45:20 <kmc> :t (**)
22:45:21 <lambdabot> forall a. (Floating a) => a -> a -> a
22:47:40 * hackagebot snap 0.6.0.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.6.0.1 (DougBeardsley)
22:51:49 <applicative> >liftM2 (**) exp negate $ 1
22:51:55 <applicative> > liftM2 (**) exp negate $ 1
22:51:57 <lambdabot>   0.36787944117144233
22:52:26 * applicative arbitrarily swats another common subexpression
22:56:43 <shachaf> applicative: You could just...
22:57:36 <applicative> let a = 1 in expr a ^ (-1) :)
22:57:46 <applicative> not enough chaos
22:58:15 <applicative> let a = 1 in expr a ^ (-a) :)
22:58:20 <shachaf> > exp (-1)
22:58:21 <lambdabot>   0.36787944117144233
22:58:23 <applicative> rather
22:58:59 <applicative> we were studying (**) above. just being foolish
22:59:57 <applicative> my improve addition is iterate succ n !! m
23:00:03 <applicative> improved
23:00:15 <applicative> it's lazier than +
23:06:39 <Quantumplation> Is there a monad that's the opposite of Maybe? like, where a context of "Nothing" will get ignored?
23:07:42 <Tordek> I can start a detached screen session with -d -m (I do it so if the IRC machine reboots, my client autoconnects). can
23:07:45 <Tordek> er
23:07:46 <Tordek> sorry
23:09:11 <qqqq> Is there any documentation on how exceptions are handled in Haskell FunPtrs called from C?
23:09:24 <kmc> Quantumplation, can you elaborate?
23:09:31 <qqqq> GHC seems to send my code into a silent tight loop if any are raised.
23:09:54 <qqqq> Which is not too surprising -- I'm not sure how the C library is meant to know about Haskell exceptions -- but it would be nice to know what I can do about it.
23:09:55 <Quantumplation> essentially I want 3 state Bool: True, False, Nothing.  things like and and or behave like normal on True and False, but any time nothing shows up, it simplifies to the other one as if no comparison was made.
23:10:16 <qqqq> (I guess smuggle out exceptions into an MVar and re-raise them outside of the C function?)
23:10:21 <shachaf> Quantumplation: That sounds like the regular Maybe to me.
23:10:28 <shachaf> With lifted operations.
23:10:34 <Quantumplation> Maybe is "nothing corrupting", meaning if a nothing shows up anywhere in the chain, it corrupts it and shows up as Nothing
23:10:44 <qqqq> Oh wait, I forgot to change my nick back.
23:11:14 <shachaf> Oh, it's elliott.
23:11:19 <kmc> Quantumplation, maybe you want to use the MonadPlus or Alternative functions with Maybe
23:11:23 <elliott> I know. Isn't it disappointing?
23:11:47 <shachaf> Quantumplation: Oh, maybe I misunderstood.
23:12:53 <Quantumplation> I'm writing a generic graph library, I want to be able to apply some predicate over the graph.  Each node has a state, and if it's already been marked as one or the other, I want to perform an and with it, but if the state is "Nothing", it's a "clean" node.
23:13:00 <Quantumplation> I'm having trouble verbalizing my requirements
23:13:42 <kmc> Quantumplation, my general advice is that you should define a data type which makes sense in your problem's terms
23:14:31 <kmc> and define whatever functions are convenient for working with that
23:16:15 <kmc> and then you can stare at it and decide whether it's an instance of something which already exists
23:17:16 <kmc> actually writing the code is a good way to figure out what you really want
23:17:25 <kmc> even if you end up throwing it out later
23:17:57 <Quantumplation> I'm new to this whole coding in Haskell thing, so I've barely gotten off the ground with my program.  Perhaps if I state my problem domain, you can help me figure out what kinds of things I need?  I've gone back and forth between 4 or 5 different data structures and such.
23:18:29 <Quantumplation> I'm very good at defining things in the context of, say, an object oriented language, that's a well defined domain for me.  But haskell kind of turns things inside out. :)
23:18:47 <kmc> sure
23:19:58 <Quantumplation> So, essentially I'm doing research in graph theory, particularly with the "Thrackle" problem.  it involves specific embeddings of  graphs (positions for the nodes, arcs between the nodes that meet certain conditions), and I can't find a nice, mathematically rigorous programming library that gives me control over the specific embedding, only the abstract structure of the graph
23:19:59 <elliott> hmm... nobody else seems to have the FFI problem I'm having :)
23:20:16 <Quantumplation> I figured this sounds like a great thing for haskell, and I've been a fan of the language for several years, just never written anything serious in it
23:21:03 <shachaf> elliott: I vaguely recall that you were doing bad things to the RTS.
23:21:04 <Quantumplation> So I figured I'd start with a graph library, and then expand it with an "embedding context" wrapped around the graph/edge/node
23:21:10 <shachaf> So you probably deserve whatever you're getting.
23:21:23 <elliott> shachaf: Nope, just using the FFI normally.
23:22:39 <Quantumplation> If you don't want to clutter the main room with this discussion, I made a room for it over at #thraskell
23:23:14 <Jafet> @instances Monoid
23:23:16 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:23:43 <Jafet> > Any (Just True) `mappend` Any Nothing
23:23:44 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
23:23:45 <lambdabot>         against inferred type ...
23:24:17 <elliott> Jafet: it's on lists
23:24:40 <elliott> ...so are exceptions meant to work with Haskell FunPtrs called from C? :p
23:24:41 <Jafet> > Any True `mappend` Any False `mappend` Any False
23:24:42 <lambdabot>   Any {getAny = True}
23:25:03 <elliott> oh, not on lists
23:26:43 <kmc> Quantumplation, I don't know if existing graph libraries support what you want
23:27:34 <kmc> the graph-theoretic operations you need are fairly simple, no?
23:27:57 <kmc> as for working with the edge arcs, it sounds like you'd want a computational geometry library and I don't know of any for Haskell
23:28:24 <copumpkin> it seems like most of CGAL could be translated to haskell fairly easily
23:28:26 <copumpkin> but you couldn't bind to it
23:28:32 <copumpkin> since it's all C++ templates
23:28:55 <kmc> you would have to pick specific instantiations of those templates ahead of time
23:29:04 <copumpkin> yeah
23:29:09 <kmc> i think binding to any given small subset of CGAL under strong assumptions would not be very hard
23:29:20 <copumpkin> oh yeah, sure
23:29:26 <kmc> but it's a huge collection of libraries and binding all of it in a general way will be a ton of work
23:32:17 <Quantumplation> essentially I want to be able to define graphs/embeddings, and be able to say "which of these lists of predicates are true for the graphs" in real time, as I move around the nodes/arcs
23:32:17 <elliott> I'm assuming that the same rules apply to foreign import ccall "wrapper"-generated FunPtrs as do regular foreign export'd functions, right?
23:32:27 <elliott> That would confirm that I need to handle exceptions myself.
23:34:29 <kmc> Quantumplation, which means you need to deal with arcs of complicated shapes, and decide whether they intersect, right?
23:35:44 <Quantumplation> in some cases.  Sometimes it's more complicated, like take the line graph and determine whether it's planar, or do this transform on the graph (for each edge, produce a node, adjacency determined by intersection) and then check if htat's planar, or if that's complementary to the line graph
23:35:45 <Quantumplation> stuff like that
23:36:05 <kmc> yeah
23:36:23 <kmc> it sounds like most of the problems you will need to solve are geometry problems, not graph theoretic problems
23:36:24 <Quantumplation> also want to ask questions about the specific intersections themselves, be able to define my own "properties" like how the intersection "winds up", etc, and monitor those as the graph changes when I drag things around
23:36:32 <Quantumplation> this is all down the road though
23:36:53 <Quantumplation> kmc: well, I'd like to be able to do both really
23:37:27 <kmc> let me rephrase: it sounds like the hard part will be geometry
23:37:27 <Quantumplation> "what's the minimum coloring of a thrackle?" "Does the line graph of the thrackle have any snarks?" "Does the line graph of the thrackle have any claws? triangles?" etc.
23:37:33 <Quantumplation> indeed
23:37:45 <Quantumplation> and i'm rather new to haskell, so I figured I'd start with the graph theory stuff
23:37:50 <Quantumplation> to get myself acquainted
23:39:03 <kmc> i'm suggesting that finding a geometry library you can tack some graph theory onto is a better approach than finding a graph theory library you can tack some geometry onto
23:39:13 <kmc> but maybe there are no good geometry libraries for Haskell anyway
23:39:18 <kmc> so what graph theory stuff do you need?
23:40:26 <Quantumplation> *shrug* anything is really fair game.  It's research, so i'm not sure where it will take me.
23:41:11 <Quantumplation> I might end up defining my own "concepts of graph theory" (been playing around with how to categorize an intersection based on some kind of ordering, and there's no concise tools that I know of in graph theory or geometry for playing with that...)
23:41:22 <Quantumplation> and obviously I wouldn't want to rewrite my whole library to support it
23:43:35 <kmc> okay
23:45:24 <Quantumplation> (side note: it'd be interesting to start a weekly blog about my adventures in haskell towards this goal so people could follow along as I learn more and more complex concepts in haskell hehe)
23:46:07 * frerich reads the blog article about "Constraint programming", all sounds interesting - and the first section after "Some basic definitions" starts with: "Okay, first let’s pick a constraint domain. I’m going to go for a classic: equality on the Herbrand universe of terms." :-}
23:46:16 <frerich> Of course! That would've been my choice as well. :-}
23:46:41 * applicative was mildly taken aback by that line too
23:46:49 <kmc> Quantumplation, I'm afraid it's all too vague for me to give specific implementation advice, though
23:47:01 <Quantumplation> *nods* I understand =/
