00:00:03 <kmc> cheater, Erlang processes (threads, whatever) don't share variables
00:00:04 <cheater> so what do you do in erlang if you want to share variables
00:00:05 <kmc> they use message-passing
00:00:08 <cheater> ok
00:00:10 <ddarius> STM makes no sense in a distributed environment.
00:00:14 <kmc> and they share access to a database, which might have transactions?
00:00:14 <cheater> k
00:00:23 <cheater> ya might do
00:00:31 <ddarius> @google mnesia erlang
00:00:33 <lambdabot> http://www.erlang.org/doc/apps/mnesia/
00:00:33 <lambdabot> Title: Erlang -- Mnesia Reference Manual
00:00:37 <cheater> i'm not looking for the "transactional" part, i'm just looking for the "sharing" part
00:01:05 <kmc> cheater, GHC Haskell has non-transactional shared variables too
00:01:15 <cheater> yeah, but why would you use them
00:01:33 <kmc> in some cases, locking performs better than GHC's lockless STM
00:01:49 <cheater> hmm, true, i can imagine that happening
00:02:11 <cheater> speaking of performance and locking
00:02:27 <cheater> i wish there was a way to have like.. garbage collector "domains"
00:03:21 <td123> btw, is lyah still the best tutorial for a nooby?
00:03:23 <cheater> like if your whole code is being garbage-collected (like right now), define a function which manages its own memory, and have that function manage its own memory and have the GC resume its work after that function is done (perhaps cleaning up garbage from that function)
00:03:26 <elliott> td123: yes
00:03:36 <kmc> td123, LYAH and RWH are both recommended
00:03:42 <td123> rwh?
00:03:45 <ddarius> It depends on the "nooby"
00:03:45 <kmc> @where rwh
00:03:45 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:04:15 <cheater> and if you have a function like that which is not being GC'd, then you can make a function called from inside of it be GC'd but only have the GC touch that part.
00:04:16 <kmc> they're very different in style and tone
00:04:18 <ddarius> I've always wanted my garbage collectors to fail to terminate.
00:04:31 <cheater> ddarius: what do you mean?
00:05:21 <td123> kmc: k, I'll probably give it another go and probably try implementing kmeans myself
00:05:31 <kmc> cool :)
00:06:08 <elliott> td123: if you have performance problems you should come here before disowning the language again, at least :P
00:06:09 <td123> kmc: though tbh, when I tried to think about implementing it, it was hard coming up with an algorithm for kmeans in the functional sense
00:06:22 <kmc> learning to write fast Haskell code takes a long time
00:06:29 <kmc> you should definitely feel free to ask questions here
00:06:36 <kmc> we can help you with interpreting profiling results etc.
00:06:37 <td123> elliott: I was just frustrated and had a deadline for a project at the time
00:06:42 <cheater> yeah i get a lot of help here too
00:06:44 <elliott> td123: You can probably write the imperative version directly with ST.
00:06:51 <cheater> especially when i ask questions like "what does kmeans do"
00:06:53 <cheater> :p
00:06:53 <ddarius> elliott: There is no probably.
00:07:14 <elliott> ddarius: Yes there is: td123 might not be able to for reasons unrelated to ST.
00:07:20 <cheater> but really, i get lots of help
00:07:21 <elliott> I probably couldn't write a program without bugs, for instance.
00:07:46 <cheater> does haskell have something similar to erlang's message passing?
00:07:55 <kmc> you can do message passing between  threads with Chan
00:08:06 <kmc> message passing between different machines or separate Haskell processes is harder
00:08:15 <kmc> the Cloud Haskell stuff attempts to make that nicer
00:08:26 <kmc> there's also an implementation of (some of?) Erlang's message-passing network protocol
00:08:30 <td123> elliott: I've written programs were I just sat down, written them all out, and it compiled and ran the first time and they needed no modification :P
00:08:31 <kmc> td123, it seems pretty straightforward.  you have a data structure representing a set of points and a choice of center for each one
00:08:47 <kmc> you have two functions that take and return that data structure
00:08:49 <td123> elliott: but calling them bug free is just crazy :P
00:08:58 <kmc> one moves each point to the nearest center; one finds the new centers
00:09:05 <kmc> but they're pure functions; each one returns a new data structure
00:09:18 <kmc> then you iterate the composition of those functions until it doesn't change
00:09:31 <cheater> the problem with k means clustering is that the standard algorithm is imperative
00:09:33 <td123> kmc: ya, that's what I didn't like about it, since it seemed like such a waste of memory
00:09:50 <td123> since you're creating a lot of huge arrays
00:09:57 <kmc> td123, they don't need to be arrays
00:09:59 <cheater> so you're not going to be able to leverage haskell's efficiency in a productive way
00:10:09 <ddarius> cheater: The "standard algorithms" for practically everything are imperative.
00:10:14 <kmc> td123, with a good functional data structure, your updated copies share most of the memory with the old copy
00:10:37 <cheater> yeah that's because mathematicians mean that "algorithm" means "iterative loop"
00:10:38 <ddarius> Providing a possibility for parallelism.
00:10:45 <kmc> td123, like Data.Map is a map from keys to values, implemented as a balanced binary tree.  when you insert a key and get a "new map", you're only copying O(log n) nodes; those nodes mostly point back into the old tree
00:11:05 <kmc> that's why functional languages emphasize tree and graph structures and not flat arrays
00:11:55 <td123> kmc: balanced binary trees? I would expect at least fibonacci heaps in haskell :)
00:12:23 <kmc> ok, then implement them
00:12:28 <kmc> make some real-world benchmarks
00:12:58 <ddarius> IntMaps are Patricia tries.
00:13:02 <kmc> the fastest data structure is the one that's actually fastest, not the one with the fanciest name or the best irrelevant asymptotic analysis in CLRS
00:13:16 <kmc> and yeah, it's not like Data.Map is the most sophisticated associative container avaliable
00:13:41 <kmc> for example see http://hackage.haskell.org/package/unordered-containers
00:13:56 <kmc> which combines the IntMap-style Patricia trees with hashing
00:14:06 <kmc> to give hash table like asymptotics, but also allows those functional updates i talked about
00:14:06 <td123> kmc: sure, I'll put that on my todo list right after lyah & rwh
00:14:29 <ddarius> Usually simpler is better in every way.
00:14:31 <kmc> there's a branch on github which reworks them to be hash-array mapped tries, with packed 32-ary nodes
00:14:41 <kmc> using some clever bitwise ops to index those nodes efficiently
00:14:44 <kmc> is that enough buzzwords for you?
00:14:54 <elliott> kmc: i think td123 was joking with the fibonacci heap thing :p
00:15:11 <kmc> ;P
00:15:32 <edwardk> hrmm strike 2. andrej can't remember the talk either
00:15:58 <edwardk> i emailed thorsten and the speaker himself to see if either of them can remember
00:16:07 <td123> elliott: I was, although they do exist and do provide a theoretically better asymptotic runtime
00:16:34 <kmc> the way algorithms and data structures are typically taught is heavily biased against functional languages
00:16:38 <elliott> We're Haskellers, we don't care about theoreticals. What do you take us for, PHP programmers?
00:16:45 <kmc> i'm a bit touchy because of that ;P
00:17:20 <edwardk> td123: i have asymptotically optimal brodal-okasaki heaps in haskell actually =)
00:17:23 <kmc> sorry for flipping out
00:17:26 <cheater> edwardk: talk?
00:17:35 <edwardk> cheater: ?
00:17:41 <cheater> edwardk: what's going on with remembering a talk?
00:17:51 <ddarius> edwardk: Do you use them?
00:17:56 <cheater> did someone forget you had a talk scheduled (?)
00:18:00 <companion_cube> kmc: some algorithms are harder for functional languages, some are easier
00:18:04 <td123> edwardk: I always hear random bits about brodal queues, but I never see them.. anywhere
00:18:15 <companion_cube> like, union find is so typically imperative
00:18:21 <ddarius> edwardk: Re the paper, everyone has moved on.
00:18:23 <cheater> companion_cube: good thing haskell is a very good imperative language then
00:18:37 <edwardk> cheater: trying to dig up a set of objections that someone had to the equational equivalence machinery used by wadler's arrow calculus paper
00:18:53 <companion_cube> cheater: having to wrap everything in ST?
00:19:12 <td123> edwardk: according to wikipedia, brodal queues are slightly better than fib. heaps
00:19:26 <cheater> edwardk: oh
00:19:32 <edwardk> td123: http://hackage.haskell.org/packages/archive/heaps/0.2/doc/html/Data-Heap.html implements brodal-okasaki heaps
00:19:44 <cheater> here's a joke
00:19:58 <MaskRay> array accessing is cumbersome
00:20:00 <td123> edwardk: do you maintain that?
00:20:15 <edwardk> which have the same asymptotics as brodal heaps, but are persistent/purely functional and use a relaxed boostrapped skew binomial heap as the backend implementation strategy
00:20:17 <cheater> The bartender says, "we don't serve faster-than-light particles here". A neutrino walks into a bar.
00:20:17 <edwardk> yes
00:20:30 <td123> that's really awesome :)
00:20:47 <edwardk> thanks =)
00:20:52 <cheater> oh wrong win
00:20:56 <edwardk> and ddarius: yes, i do occasionally use them =)
00:21:21 <edwardk> i was using them in trifecta for all of a week or so ;)
00:24:18 <edwardk> td123: the main thing you win out of brodal-okasaki over brodal is that since they aren't ephemeral you can keep references to old versions of the heap around for free, while maintaining the non-amortized asymptotic bounds that brodal wins over fib heaps
00:25:40 <td123> yes that is nice
00:25:41 <edwardk> and unlike a lot of tarjan-style structures you can take those old references and mutate them, and merge them together
00:26:27 <edwardk> lots of tarjan-style structures while they offer a notion of persistence the persistence is often incompatible with merging (and functional implementation)
00:26:54 <cwl> ghci dies after reporting "floating point exception"
00:27:00 <td123> not sure what that means, but ok :P
00:27:05 <cwl> http://stackoverflow.com/questions/7695240/floating-point-exception-occurred-while-encoding-to-json-in-ghci-ghci-quits
00:29:23 <edwardk> @ask copumpkin do the comments in http://hackage.haskell.org/trac/ghc/ticket/5386 hint at a way to make sure your initializer gets called in the right order for the precision gmp gc-hook hack?
00:29:23 <lambdabot> Consider it noted.
00:29:39 <elliott> There's an @ask?
00:29:45 <elliott> @ask elliott hi
00:29:45 <lambdabot> You can tell yourself!
00:29:52 <edwardk> ask = tell
00:30:08 <elliott> It should enforce using @ask for things ending "?" and @tell for everything else.
00:30:12 <edwardk> @ask elliot is the sky blue?
00:30:12 <lambdabot> Consider it noted.
00:30:16 <cheater> @yell edwardk stop being silly!
00:30:16 <lambdabot> Consider it noted.
00:30:26 <elliott> edwardk: elliot will probably never see your question.
00:30:34 <edwardk> @whisper cheater eep
00:30:35 <lambdabot> Unknown command, try @list
00:30:41 <cheater> hah
00:30:41 <cheater> a
00:30:47 <td123> I think I will learn haskell mainly for the purity and consistency of the language rather than expecting it to replace all my work
00:31:05 <edwardk> td123: i started there. then it consumed my life
00:31:05 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:31:07 <elliott> td123: I think you'll find well-written Haskell consistently does much better than Python in the speed arena.
00:31:10 <cheater> that will make you another zombie user
00:31:11 <edwardk> @messages
00:31:12 <lambdabot> ddarius said 3h 41m 19s ago: I imagine you'd have some fun with this: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.156.7931
00:31:12 <lambdabot> cheater said 56s ago: stop being silly!
00:31:27 <cheater> haskell is in many ways able to replace a lot of the work you do in python
00:31:42 <edwardk> td123: mind you this is very much a good thing
00:31:47 <td123> cheater: well dunno, I use a lot of libs
00:32:01 <elliott> td123: Hackage has a lot of libs. Admittedly a lot of them are bad, but a lot of them are really good too.
00:32:11 <td123> cheater: I doubt there is a scipy or many of its toolkits available to haskell :P
00:32:17 <cheater> many libs you tend to use in python end up being oneliners in haskell.
00:32:28 <elliott> td123: There's definitely lots of numeric libraries like hmatrix.
00:32:35 <elliott> I'm not sure exactly what scipy adds on top of numpy though.
00:32:38 <kmc> cheater, omg, did you hear they observed neutrinos traveling faster than light?
00:32:43 <edwardk> td123: well. we have automatic differentiation, my algebra library, hmatrix, blas bindings, etc.
00:32:51 <joevandyk> download url = do
00:32:51 <joevandyk>   contents <- simpleHttp url
00:32:52 <joevandyk>   return $ UTF8.toString contents
00:32:58 <joevandyk> how do i get that function to return a pure string?
00:32:58 <cheater> td123: you missed out on wolfgang lambda
00:33:11 <elliott> joevandyk: You don't.
00:33:20 <cheater> kmc: hey, so i heard neutrinos are the new meme, ever hear anything about that?
00:33:26 <kmc> nope
00:33:40 <td123> well like I said, I'll approach this from a more "have fun" perspective
00:33:40 <cheater> u broke it
00:33:42 <edwardk> td123: we'll also have code for building taylor models and chebyshev-pade approximants when i get off my ass
00:33:58 <cheater> you were supposed to say something that precludes what i say, not concludes
00:34:15 <joevandyk> elliott: huh.  so how is http://bos.github.com/strange-loop-2011/slides/slides.html#(92) supposed to work?
00:34:17 <cheater> it
00:34:37 <ddarius> "The bacteria report when they have solved the problem by becoming antibiotic resistant."
00:34:40 <elliott> joevandyk: An action in this context is something that looks like (IO a).
00:34:58 <elliott> joevandyk: (Spoiler: The answer is "download :: String -> IO String".)
00:35:14 <edwardk> ddarius: =)
00:35:18 <elliott> joevandyk: As in: Give me a URL, and I'll give you an action that, when executed, produces a string (the page's contents).
00:35:21 <ddarius> td123: You should approach everything from the "have fun" perspective.
00:37:13 <joevandyk> elliott: isn't that what i wrote above?
00:37:20 <td123> easier said than done
00:37:25 <elliott> joevandyk: You gave an implementation, yes.
00:38:09 <tnks> trying to read up more on elementary category theory: a little confused about what equality means for arrows/morphisms.
00:38:33 <tnks> sometimes it seems arrows are equal if they have the same objects a domain and codomain.
00:38:56 <td123> anyways, goodnight, it's really late here
00:39:03 <kmc> tnks, that's definitely not the case
00:39:12 <kmc> any more than all (Int -> Int) functions in Haskell are the same function
00:39:26 <tnks> kmc: okay, that's exactly how I feel too.
00:39:46 <kmc> in particular, there can be morphisms (A -> A) other than the identity
00:39:53 <kmc> e.g. all non-identity elements in a monoid
00:39:59 <tnks> let me find a statement (reading Pierces book) that seems to indicate the alternative read on "="
00:40:11 <tnks> but I'm following your stance.
00:40:27 <tnks> even back to the discussion we had about a monoid category.
00:40:28 <cheater> = can mean a lot of stuff in mathematics
00:40:38 <cheater> often it's lifted to congruence classes etc
00:40:53 <tnks> there's possibly many distinct arrows, even with the one object.
00:43:01 <tnks> kmc, my confusion starts with the definition he uses for describing category diagrams that "commute"
00:43:41 <tnks> "if all paths from any object X to any object Y are equal"
00:43:55 <ddarius> tnks: Those paths are labelled by arrows.
00:43:59 <ddarius> specific arrows
00:44:20 <ddarius> (Though it is extremely common to leave those implicit when "clear" from context.)
00:46:06 <ddarius> At any rate, the "if" already dispels your erroneous interpretation.
00:46:42 <tnks> ddarius: okay, so that makes sense, I think.
00:47:18 <tnks> I think a diagram that commutes might assert things like how many instances a type has.
00:48:18 <ddarius> A commutative diagram is just a notation for a system of equations.
00:48:47 <cheater> a non-commutative diagram has the same amount of instances of a type as a diagram that does commute
00:48:48 <ddarius> All of the form f . g . ... . h = j . k . ... . l
00:49:18 <cheater> what you are talking about is that a commutative diagram shows you in how many ways you can compose the same *value* of a certain type from other non-equal values
00:49:46 <cheater> a path across arrows is not a type, it's a composition of arrows
00:49:52 <cheater> a composition of arrows is an arrow
00:50:47 <tnks> also, just to be clear, nothing about the diagrams structure indicates whether it's commutative or non-commutative, right?
00:50:56 <tnks> that needs to be defined, right?
00:51:23 <ddarius> tnks: It's not defined.  It's either asserted or it is proven.
00:52:22 <tnks> ddarius: okay, sounds good.
01:32:59 <dalaing_home> I'm thinking of learning a bit more about type theory - what do people think of the various texts out there?
01:34:25 <dalaing_home> the table of contents of type theory and functional programming by Thompson and types and programming languages by Pierce look alright
01:34:49 <dalaing_home> is one better than the other? or should one be read after the other? or should I be looking at other books entirely?
01:35:29 <kmc> TaPL is great
01:35:43 <kmc> i've only read part of TTFP, so I can't compare them
01:38:39 <DevHC_> what and when gets copied when using ++?
01:39:26 <kmc> the (:) cells of the left hand list get copied, as they are demanded
01:40:06 <kmc> @src (++)
01:40:06 <lambdabot> []     ++ ys = ys
01:40:07 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:40:07 <lambdabot> -- OR
01:40:07 <lambdabot> xs ++ ys = foldr (:) ys xs
01:40:18 <DevHC_> ok, so just storing a thunk of (++) s t in itself does not result in significant copying
01:41:13 <kmc> that's true no matter what the code for (++) says
01:41:37 <dalaing_home> kmc: thanks - I'll add it to the queue :)
01:41:41 <kmc> it will however prevent s or t from being garbage collected, as long as that thunk is reachable
01:42:13 <moriramar> Why can "forM [1,2,3] print" output 1 2 3? I remember forM xs f = sequence $ map f xs. But where is the (print 1) called during the process?
01:42:18 <moriramar> Thanks.
01:42:34 <DevHC_> @src forM
01:42:34 <lambdabot> forM = flip mapM
01:42:40 <kmc> map print [1,2,3]  ≡  [print 1, print 2, print 3]
01:42:44 <kmc> it's a list of IO actions
01:42:54 <kmc> 'sequence' takes a list of IO actions and returns a single action which performs those actions in order
01:43:10 <kmc> sequence_ [print 1, print 2, print 3] ≡ print 1 >> print 2 >> print 3
01:43:32 <kmc> (sequence_ is simpler  than sequence, because it does not save the results of the IO actions, which here are trivial anyway)
01:45:20 <moriramar> kmc, Thanks.
01:45:41 <kmc> makes sense?
01:46:17 <moriramar> kmc, wait. Then what about the result of sequence (i see sequnce_), m[()]
01:46:28 <kmc> what about it?
01:47:05 <moriramar> Oh, i got a little confused. I am finding a paper and a pen. Thanks a lot, kmc.
01:47:09 <kmc> «forM [1,2,3] print :: IO [()]»; when executed it will print 1,2,3 (on separate lines) and produce the result value [(), (), ()]
01:47:23 <kmc> that's a useless result so we'd typically use forM_ instead, which uses sequence_
01:47:25 <kmc> @src sequence_
01:47:26 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
01:47:27 <kmc> @src sequence
01:47:27 <lambdabot> sequence []     = return []
01:47:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:47:28 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
01:48:29 <moriramar> kmc, so print is executed on the line "v <- x".
01:48:44 <kmc> kind of
01:49:16 <moriramar> kmc, thank you.
01:49:21 <kmc> expressions of IO type are just describing IO which could be performed
01:49:42 <kmc> if you see it that way, it's hard to say which line the print actually occurs
01:50:03 <kmc> it should be clear though why «print 1 >> print 2 >> print 3» works and therefore why «foldr (>>) (return ()) [print 1, print2, print 3]» works
01:51:09 <engla> moriramar: the only IO action you have is the main function, and all actions have to be combined with main to execute. Just like sequence combines a list of actions into one action
01:51:22 <kmc> yeah
01:51:28 <kmc> you can build IO actions anywhere, they're just values
01:51:33 <kmc> but they don't get executed unless they are part of 'main'
01:52:30 <moriramar> ahhh. sequence_ [1,2,3] print = print 1 >> print 2 >> print 3 >> return ()  ?
01:52:36 <kmc> (or if you type them at the ghci prompt)
01:52:41 <kmc> moriramar, no
01:52:53 <kmc> sequence_ [print 1, print 2, print 3] ≡ print 1 >> print 2 >> print 3 >> return ()
01:52:55 <moriramar> return () >> print 1 >> print 2 >> print 3?
01:52:58 <moriramar> ....
01:53:05 <kmc> sequence_ [a, b, c] ≡ a >> b >> c > return ()
01:53:13 <moriramar> sorry, i should type forM_
01:53:14 <kmc> that's why you combine sequence_ with map to make mapM_ (or forM_)
01:53:16 <kmc> *nod*
01:53:22 <elliott> c sure is greater than return () :-)
01:53:29 <kmc> forM_ f [a, b, c] ≡ f a >> f b >> f c >> return ()
01:53:39 <kmc> er, flip the args on that
01:53:42 <kmc> or call it mapM_
01:53:59 <kmc> elliott, whoops
01:54:27 <kmc> moriramar, sequence takes a list of IO actions and returns a single IO action which produces a list
01:54:39 <kmc> it does this by gluing the IO actions together in left-to-right order
01:54:57 <kmc> you could write other functions with the same type signature as 'sequence' which choose a different order, or omit some elements, etc.
01:55:10 <shachaf> > compare (рrint 1) (return ())
01:55:11 <lambdabot>   LT
01:55:31 <moriramar> kmc, okay. so sequence [a, b ,c] = a >>= \x -> b >>= \y -> c >>= \z -> return [x,y,z] ?
01:55:42 <kmc> moriramar, that looks right
01:55:55 <kmc> or do { x <- a; y <- b; z <- c; return [x,y,z] }
01:55:56 <elliott> shachaf: Ouch.
01:56:03 <elliott> shachaf: Wait, why doesn't it at least error out?
01:56:09 <elliott> > print 1 == return ()
01:56:10 <lambdabot>   No instance for (GHC.Classes.Eq (GHC.Types.IO ()))
01:56:10 <lambdabot>    arising from a use of...
01:56:15 <moriramar> kmc, great, got it. engla, kmc, thank you very much.
01:56:18 <elliott> Heyyy, this is one of shachaf's Clever Tricks.
01:56:18 <kmc> cool :)
01:56:26 <kmc> "compare (рrint 1) (return ())'
01:56:29 <kmc> > "compare (рrint 1) (return ())'
01:56:30 <lambdabot>   <no location info>:
01:56:30 <lambdabot>      lexical error in string/character literal at end o...
01:56:45 <engla> someone put more coffee in kmc
01:57:00 <moriramar> engle, :)
01:57:10 <kmc> > "compare (рrint 1) (return ())"
01:57:10 <lambdabot>   "compare (\1088rint 1) (return ())"
01:57:21 <elliott> Wow, jhc depends on both haskell98 (CPUTime) and modern base (Data.Foldable).
01:57:27 <elliott> Not sure how that ever managed to compile.
01:57:32 <kmc> Unicode Character 'CYRILLIC SMALL LETTER ER' (U+0440)
01:57:48 <elliott> > рrint 0
01:57:50 <lambdabot>   Nothing
01:59:22 <Ishad> noobish q - I got IO String and now I want filter it, but filter function want String, not IO String. how do I solve this?
01:59:33 <elliott> :t (>>=)
01:59:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:59:45 <elliott> Or alternatively
01:59:52 <elliott> do myString <- myIOActionProducingAString; ...
02:00:10 <kmc> Ishad, http://haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F http://haskell.org/haskellwiki/Introduction_to_IO
02:00:12 <elliott> Note that you cannot escape from the IO monad: if you use any IO actions, your final result must be in IO.
02:01:07 <elliott> "Note that there is no function:
02:01:07 <elliott> unsafe :: IO a -> a
02:01:07 <elliott> as this would defeat the referential transparency of Haskell -- applying unsafe to the same IO action might return different things every time, and Haskell functions aren't allowed to behave that way."
02:01:10 <elliott> I like how [[Introduction to IO]] just lies.
02:01:29 <c_wraith> eh.
02:01:40 <kmc> you can edit it!
02:01:40 <c_wraith> define "haskell" as "haskell98" and that's true.
02:01:47 <c_wraith> the FFI is not part of the haskell98 spec
02:01:48 <elliott> c_wraith: GHC would disagree :-)
02:01:48 <c_wraith> :)
02:01:52 <kmc> the FFI is a ratified addendum
02:02:09 <elliott> kmc: That would involve, like, filling in a captcha.
02:02:12 <elliott> Wait, I think I have an account.
02:02:14 <c_wraith> but honestly, it's better to tell the lie.
02:02:17 <elliott> It would involve remembering what my password is.
02:02:23 <kmc> you can play semantics and argue that unsafePerformIO is not a function
02:02:27 <c_wraith> The lie is more instructive than the truth.
02:02:44 <kmc> it's officially undefined behavior in cases where it's not referentially transparent
02:02:52 <kmc> personally i don't like lying to people in order to teach them
02:03:01 <elliott> kmc: Aww, so unsafeCoerce isn't quite standard?
02:03:22 <Ishad> ehm
02:03:23 <kmc> i think it would be better to say "there's this unsafePerformIO thing but you probably shouldn't use it; here are a few real use cases though"
02:03:43 <kmc> the thing is, most people learning Haskell today are doing it for fun, and are *trying* to do things the Right way
02:03:47 <c_wraith> kmc: I've seen too many people ignore *every* warning and do exactly the wrong thing because it's available.
02:03:53 <elliott> kmc: I think unsafePerformIO is probably bad to mention early on because it promotes the idea that (IO a) has an a inside it.
02:03:55 <kmc> c_wraith, in Haskell too?
02:04:01 <elliott> kmc: Is teaching with lies by omission OK?
02:04:02 <engla> kmc: you can't tell the whole story in an introduction
02:04:05 <c_wraith> yes, with unsafePerformIO in particular
02:04:10 <kmc> elliott, good point
02:04:30 <Ishad> let s = read "file.dat" in filter Char.isDigit x
02:04:30 <kmc> maybe it's best to mention it without explaining it
02:04:32 <Ishad> need smth like this
02:04:46 <kmc> do { s <- read "file.dat"; return (filter Char.isDigit x) }
02:04:53 <c_wraith> readFile, not read
02:05:01 <Ishad> readFile, ofc
02:05:04 <c_wraith> read is entirely the wrong thing :)
02:05:09 <kmc> Ishad, «let s = readFile "file.dat"» is just making a local name for that same IO action; it isn't performing any IO
02:05:17 <kmc> Ishad, did you read the Introduction to IO?
02:05:40 <elliott> Introduction to IO is popular this minute, I see.
02:06:06 <kmc> eventually if Haskell is popular then there will be lots of people learning who don't give a fuck and are just after a paycheck
02:06:14 <kmc> and people will want to lie to them to minimize the harm they do
02:06:17 <Ishad> kmc, guilty, no
02:06:23 <kmc> but thankfully we do not have this problem at current :)
02:06:34 <kmc> Ishad, ah, it's a short article and is about precisely your question :)
02:06:53 <Ishad> ok (yes, I'm lazy)
02:07:01 <elliott> kmc: Well, I still think there's this strange tendency of people to think they know the language better than the people trying to help them, early on.
02:07:04 <engla> kmc: maybe there should be a real "checklist" for when it's ok to use unsafePerformIO
02:07:21 <kmc> engla, there's not much consensus on that
02:07:25 <elliott> I mean, I definitely see outrage like "I can't escape IO ever??? but that'll make programming impossible!!"
02:07:37 <kmc> elliott, i don't see that very often, other than from people who are obvious trolls
02:07:39 <elliott> "oh, wait, you mean I _can_? problem solved, then"
02:07:46 <elliott> well, I'm exaggerating :P
02:07:54 <kmc> i think people come to Haskell because they hear it promises a new way of thinking and is exactingly precise
02:07:56 <engla> elliott: main = interact f; now the whole program (function f) escapes IO
02:08:02 <c_wraith> contrast that to the opposite:  "functions always have to return the same thing?  That makes programming impossible!"
02:08:03 <kmc> if anything, it turns out to be a lot more forgiving
02:08:10 <elliott> engla: FSVO escape
02:08:28 <elliott> c_wraith: Is that the opposite? That sounds like the same thing to me.
02:08:43 <kmc> if you see IO as a "taint tag" that one must "escape" then you've already lost at understanding it
02:08:55 <kmc> those discussions always become hopelessly confused
02:09:13 <kmc> whereas talking about evaluation vs. execution and IO actions as descriptions of programs is simple and precise
02:09:16 <c_wraith> elliott: that's the one that people actually say like it's an indictment of haskell.  Good god, the comments on that /. article were bad.
02:09:48 <kmc> people on the internet are clueless about programming languages
02:09:49 <kmc> film at 11
02:09:57 <elliott> c_wraith: I have this built-in reflex that prevents me from reading any Haskell commentary in "general" programming fora.
02:10:01 <elliott> It's super great.
02:10:05 <kmc> we should not allow ourselves to be trolled by Slashdot by proxy
02:10:10 <c_wraith> well.  the problem is "people who program are clueless about programming languages"
02:10:24 <kmc> i'm not convinced the readers of /r/programming etc. actually do much programming
02:10:32 <c_wraith> "and happy to be clueless"
02:10:42 <c_wraith> "and actively reject trying anything new"
02:11:04 <kmc> i don't think it's just rejecting anything new
02:11:24 <c_wraith> I guess it's more different than new.
02:11:40 <c_wraith> They'll happily accept the next language with the exact same set of features as the ones they already have.
02:12:19 <kmc> elliott, yep... clueless outsiders breed a smug, insular community
02:12:26 <kmc> anyway!
02:12:33 <kmc> i do not think the situation is as bleak as we make it out to be
02:12:36 <Ishad> ok. read article,
02:12:45 <kmc> total beginners show up here all the time wanting to learn
02:12:48 <newsham> just part of avoiding success
02:12:53 <kmc> the growth rate of interest in Haskell is high
02:12:54 <c_wraith> wow.  this channel's up to 750 at off hours?
02:12:57 <elliott> kmc: Well, intelligent criticisms of Haskell certainly exist and are numerous but they're not going to be in the aforementioned "general" programming fora.
02:13:06 <kmc> in other interesting languages like Scala is even higher
02:13:15 <Ishad> managed to compose following function - getData = do {x <- readFile "data"; return $ filter Char.isDigit x}
02:13:18 <kmc> you don't have to love Scala or F# but some of our beloved ideas are gaining wider acceptance
02:13:25 <kmc> looks all right Ishad
02:13:32 <kmc> there are more concise ways, but that's fine
02:13:39 <Boney_> wom 1
02:13:51 <kmc> in particular «  do { x <- a; return (f x) } »  ≡  « fmap f a »
02:13:52 <elliott> Inside every #haskeller is a hyperactive @pl implementation desperately trying to claw its way out.
02:13:55 <newsham> ?type filter Char.isDigit <$> readFile "data"
02:13:56 <lambdabot> IO [Char]
02:14:06 <newsham> ?type filter Char.isDigit `fmap` readFile "data"
02:14:06 <elliott> And there it goes!
02:14:06 <lambdabot> IO [Char]
02:14:32 <c_wraith> .... newsham, given that (<$>) and fmap are the same, why did you just ask the same thing twice? :)
02:14:49 <Ishad> but this getData still returns IO [Char] ;)
02:14:54 <kmc> right Ishad
02:14:58 <Ishad> so, I can't escape IO monad
02:15:03 <newsham> cwraith: because kmc said it was fmap and ishad probably doesnt yet know that its the same thing
02:15:04 <kmc> right
02:15:16 <kmc> Ishad, functions can't do IO; they can only build up descriptions of IO which *could* be done
02:15:22 <kmc> an «IO [Char]» value is such a description
02:15:26 <Ishad> I understand this
02:15:33 <Ishad> IO will be done when it's needed
02:15:40 <newsham> ishad: you can use do { x <- ...; putStrLn x }   to get the [Char] and print it
02:15:42 <kmc> IO will be done when you run the program
02:16:18 <kmc> elliott, the problem is that you have to learn quite a bit about Haskell in order to make intelligent criticisms of it, and you're unlikely to learn something if you hate it, and so there's heavy bias in the intelligent criticisms one does read
02:16:29 <newsham> do { x <- readFile "data"; let y = filter Char.isDigit x; putStr y }
02:16:29 <elliott> yeah
02:16:30 <newsham> for example
02:17:00 * elliott thinks that, in general, trying to please people outside the Haskell community is a waste of time, at least at this stage in Haskell's growth.
02:17:00 <newsham> ?type putStr =<< (filter Char.isDigit `fmap` readFile "data")
02:17:01 <lambdabot> IO ()
02:17:22 <kmc> elliott, I think one should advocate to receptive outsider audiences, without trying to actively convert hostile ones
02:17:36 <elliott> kmc: Well yeah, I don't mean we should turn people away at the door or anything
02:17:41 <sipa> your main evaluates to a complex IO action that defines your entire program - without any side effects ; this action is given to the runtime system which executes it
02:17:42 <kmc> one advantage of IRL talks over arguing on the Internet is that people generally don't show up to troll an IRL talk
02:17:43 <elliott> I just don't think it's worth worrying about in general
02:17:48 <kmc> (there are exceptions!)
02:18:20 <kmc> i think it *is* worth worrying about, because bad software is a big social problem, and Haskell provides a small piece of the answer to that problem
02:18:58 <kmc> (directly, but also because it shows people that a language *could* be different, or even better, than what they know)
02:19:01 <elliott> Haskell 2012 turns out to define dialect of PHP; witnesses said that the newest committee member was heard yelling "Are you mad, brother?" as the document was finalised.
02:19:08 <elliott> (Re: Troll IRL talk.)
02:21:04 <kmc> what's the best way to indicate (in my cabal file) that my library should only be used on unix platforms?
02:21:12 <kmc> depending on the 'unix' library seems like a bit of a hack
02:21:43 <newsham> kmc: whats the reason
02:21:47 <elliott> if !os(unix) build-depends: pony > 99999999999
02:22:10 <newsham> build-depends: developer-with-free-time ? :)
02:22:20 <elliott> pony 99999999999.9 implements a full Unix layer for all operating systems, I suppose.
02:22:28 <kmc> newsham, i'm doing custom shell escaping, which is not correct on Windows
02:22:43 <kmc> ok, looks like Cabal supports an 'os' conditional
02:23:00 <newsham> kmc: what if someone is using cygwin, though?
02:23:10 <elliott> Then os will =/= windows, I believe.
02:23:16 <elliott> Otherwise it'd be a rather useless conditional.
02:23:23 <newsham> it wont be unix either
02:23:29 <kmc> newsham, then I expect it's fine because System.Process will go through the unix shell
02:23:34 <elliott> newsham: You sure?
02:23:51 <elliott> Tests if the current operating system is name. The argument is tested against System.Info.os on the target system. There is unfortunately some disagreement between Haskell implementations about the standard values of System.Info.os. Cabal canonicalises it so that in particular os(windows) works on all implementations. If the canonicalised os names match, this test evaluates to true, otherwise false. The match is case-insensitive.
02:23:51 <elliott> Well that's not helpful.
02:23:54 <newsham> i'm not.  but i would wager money :)
02:24:31 <newsham> i would think it best to document that its for unix envs and leave it to the user to try it or not on their system
02:24:46 <newsham> (sorry for the off topic.. i dont know the real answer to your question)
02:24:57 <elliott> That's off-topic?
02:25:08 <newsham> for his question it is
02:25:33 <newsham> always frustrates me when i ask a question and people go on about how i shouldnt do it that way instead of answering what i asked
02:25:42 <newsham> which i realize is sorta what i just did
02:26:10 <engla> sometimes a question is so strange that it reveals a misunderstanding. sometimes it just needs context
02:26:54 <c_wraith> newsham: very often, when people ask strange questions, the answer *is* "why do you even want to do that?"
02:27:05 <c_wraith> especially if they're inexperienced in the field.
02:27:14 <Ishad> ok. got this (working!) main = do {s <- readFile "data"; print $ processData (read (filter isDigit s) :: Integer)}
02:27:19 <newsham> and sometimes the person who is answerint is inexperienced in the field
02:27:35 <Ishad> I understand ::Integer is optional as haskell can infer it
02:27:45 <Ishad> but any other ways to write it nicer?
02:28:00 <newsham> ishad: if you use an applicative style.
02:28:21 <elliott> Ishad: main = readFile "data" >>= print . processData . read . filter isDigit
02:28:32 <newsham> print =<< ((processData . filter isDigit) `fmap` readFile "data")
02:28:45 <c_wraith> ...  Both of those are horrible, for the question asked. :)
02:28:50 <newsham> err yah, better elliotts way
02:28:57 <elliott> c_wraith: Ishad said nicer. Nicer means more point-free. Always.
02:29:03 <newsham> print . processData . read . filter isDigit =<< readFile "data"
02:29:10 <elliott> ?pl \a b c d e -> e (b c) d (a b c (e (d e)))
02:29:10 <lambdabot> liftM2 ap ((ap . (ap .) . flip . flip id) .) . flip flip (ap id) . ((flip . (((.) . (.)) .)) .)
02:29:13 <elliott> Always.
02:29:15 <c_wraith> yes
02:29:32 <newsham> ishad: you can read my last line from right to left (int he direction of the "=<<" arrow)
02:30:00 <elliott> I wish we could all collectively decide on a name for flip (.) and add it to base.
02:30:18 <elliott> "main = readFile "data" >>= filter isDigit .> read .> processData .> print" would be the nicest of all the solutions.
02:30:34 <c_wraith> uh.  you mean other than (>>>) ?
02:30:41 <newsham> how about ".|" reminiscent of a pipe?
02:30:44 <c_wraith> that's certainly in base.
02:31:03 <elliott> >>> is about one character too long.
02:31:12 <elliott> newsham: The iterIO library uses that, but it's a nice pipeline operator, yes.
02:31:20 <elliott> Something like (>|) would be pretty good too.
02:31:30 <newsham> ?type readFile "data" >>= filter isDigit >>> read >>> (+ 5) >>> print
02:31:31 <lambdabot>     Precedence parsing error
02:31:31 <lambdabot>         cannot mix `>>=' [infixl 1] and `>>>' [infixr 1] in the same infix expression
02:31:36 <elliott> (|>) is I think what F# calls flip ($).
02:31:39 <newsham> ?type readFile "data" >>= (filter isDigit >>> read >>> (+ 5) >>> print)
02:31:40 <lambdabot> IO ()
02:31:50 <elliott> c_wraith: And it also needs a better precedence :P
02:32:00 <Ishad> nice! I like last newsham version
02:32:01 <c_wraith> huh.  why isn't it infixl 9?
02:32:06 <elliott> Wait, >>= is infixl? What?
02:32:14 <Ishad> still - how do I make read be read :: Integer
02:32:23 <elliott> Ishad: read :: Integer doesn't make much sense.
02:32:27 <elliott> Ishad: You can say (read :: String -> Integer).
02:32:29 <elliott> Ishad: BUT
02:32:36 <elliott> Ishad: If processData takes an Integer, this is not necessary at all. Just say read.
02:32:48 <newsham> as long as your "processData" is  Integer -> something   you're good
02:32:50 <elliott> You should give processData a type signature (all top-level declarations, in fact).
02:33:11 <newsham> ?let processData x = x + 5
02:33:11 <lambdabot>  Defined.
02:33:18 <newsham> ?type readFile "data" >>= (filter isDigit >>> read >>> processData >>> print)
02:33:19 <lambdabot> IO ()
02:33:33 <Ishad> yes, it's getting infered, I understand
02:33:39 <Ishad> happy now
02:33:56 <kmc> type inference information can flow forward or backward in time, with respect to the run-time computation of values
02:34:04 <newsham> another thing you could do is   "readInt :: String -> Integer; readInt = read"
02:34:09 <kmc> a function's return type can be inferred based on how it's used subsequently
02:34:11 <newsham> and then use "readInt"
02:34:17 <elliott> readInt?
02:34:21 <elliott> readInteger, more like.
02:34:25 <elliott> ?hoogle readInt
02:34:25 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
02:34:25 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
02:34:25 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
02:34:33 <elliott> That's definitely confusing since readInt already exists.
02:34:45 <smexhy345> heya
02:34:51 <kmc> hi smexhy345
02:34:54 <newsham> elliott: you're missing the point :)
02:35:02 <elliott> Howso?
02:35:09 <elliott> Name clashes are pretty confusing.
02:35:09 <smexhy345> i need some help with my pascal program if someone is willing to help me :D
02:35:11 <newsham> by arguing about the specifics
02:35:20 <kmc> > "pascal" == "haskell"
02:35:21 <lambdabot>   False
02:35:21 <elliott> smexhy345: This channel is about Haskell, not Pascal.
02:35:25 <elliott> Even if they are pronounced similarly.
02:35:33 <smexhy345> oh
02:35:34 <elliott> newsham: Well, sure. :p
02:35:42 <smexhy345> where can i find pascal?
02:35:46 <smexhy345> pascal channel
02:35:50 <elliott> Well... I dunno... maybe #pascal? :-P
02:35:51 <newsham> pascal and haskell do not rhyme
02:36:01 <elliott> Looks a bit empty.
02:36:01 <kmc> there's a #pascal
02:36:03 <kmc> it has 7 people in it
02:36:07 <smexhy345> #pascal
02:36:07 <kmc> you could try #haskell-blah
02:36:09 <smexhy345> ?
02:36:12 <elliott> I bet Free Pascal has a channel.
02:36:14 <elliott> If you're using that.
02:36:23 <smexhy345> ium using lazarus
02:36:23 <kmc> yeah #fpc
02:36:31 <kmc> there's also a #lazarus-ide
02:36:32 <osfameron> or a delphi one
02:36:35 <smexhy345> how i connect to another channell
02:36:43 <kmc> /join #lazarus-ide
02:36:49 <elliott> kmc: You know a suspicious lot about Pascal channels.
02:36:50 <smexhy345> thanks
02:36:59 <kmc> i know a suspicious lot about using the channel list feature
02:37:10 <elliott> heh
02:37:38 <spiff_> anyone know a thorough and good tutorial on monads that will make sense to an experienced C-programmer?
02:38:02 <kmc> spiff_, the LYAH chapter on monads has a good reputation
02:38:11 <kmc> spiff_, there's not much to monads, once you understand all the prerequisite concepts
02:38:26 <kmc> type classes, higher-order functions, polymorphism over type constructors
02:38:31 <spiff_> specifically for (former) imperative programmers?
02:38:35 <kmc> so asking for a monad tutorial in isolation is probably missing the point
02:38:54 <spiff_> ok, I'll give it a shot, thanks
02:39:03 <elliott> spiff_: Monads aren't scary. Don't try to learn monads, just learn Haskell; it'll be fine. :p
02:39:06 <kmc> @where burrito
02:39:06 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
02:39:07 <engla> spiff_: did you read LYAH yet?
02:39:08 <kmc> see also ^^^^
02:39:11 <newsham> spiff: here's something short that tries to explain it in terms of C: http://www.thenewsh.com/~newsham/haskell/monad.html
02:39:27 <elliott> But yeah, seriously, even if you are going to use a Monad Tutorial(tm), at least read LYAH _first_.
02:40:16 <spiff_> I'm at chapter 8 or so in LYAH, jumping to and from RWH
02:40:21 <Axman6> spiff_: don't expect monads as a concept to map nicely to anything you know from C, it's far too general for that to work (the IO and list monads are completely different things, but are still both monads)
02:40:21 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
02:40:46 <elliott> spiff_: LYAH covers monads only about four chapters further.
02:41:02 <elliott> Best to just continue on; it's a well-structured book.
02:41:20 <spiff_> I will, thanks again
02:41:43 <elliott> :)
02:45:43 <smexhy> what channels should i look for pascal programming?
02:45:44 <smexhy> D:
02:46:13 <smexhy> anyone there?
02:46:26 <kmc> smexhy, are you also smexhy345?
02:46:26 <newsham> smexhy: i dunno.. what channels exist in 1989?  :)
02:46:30 <kmc> we gave a few suggestions before
02:46:40 <spiff_> newsham: that tutorial above was actually quite enlightening. Thanks.
02:46:40 <kmc> #pascal #fpc #lazarus-ide
02:47:08 <newsham> spiff: glad it helped.  but as axman pointed out there are cases where monads are used for things that are a little diff than what i talked about ;)
02:47:15 <smexhy> yrs
02:47:15 <newsham> but might as well start somewhere
02:47:44 <elliott> Hey guys, what's a good channel for Pascal? I bet kmc knows.
02:48:07 <newsham> #modula3?
02:48:09 <newsham> #oberon?
02:48:26 <spiff_> yeah. I sort of started at the usual place, wikipedia->monad...which was confusing to say the least ;)
02:48:45 <smexhy> any pascal chanell that actually has people not afk on it?
02:48:48 <kmc> spiff_, why did you decide to learn monads right now, out of the normal flow of the Haskell tutorial you're following?
02:48:52 <kmc> smexhy, we don't know
02:48:57 <elliott> newsham: #oberon is upsettingly empty.
02:49:09 <kmc> smexhy, note that it's early in the USA
02:49:17 <kmc> people might show up later
02:50:04 <spiff_> kmc: oh, mostly because I didn't have a clue what it was about. No reason for the diversion other than curiosity.
02:50:04 <kmc> spiff_, there's a lot of hype and misinformation about monads, which leads people to believe there's more to learn than there really is, or that they've got to run out and learn it right now
02:50:08 <kmc> ah
02:50:34 <newsham> > runState get 5
02:50:34 <lambdabot>   (5,5)
02:50:35 <kmc> really Monad is just another generic API in the vein of Num, Show, etc.
02:50:38 <newsham> > runState (put 8) 5
02:50:39 <lambdabot>   ((),8)
02:50:51 <kmc> it has a lot of different implementations, but there's not so much you can say about all of them together
02:50:53 <newsham> > runState (get >>= succ . put) 5
02:50:54 <lambdabot>   No instance for (GHC.Enum.Enum
02:50:54 <lambdabot>                     (Control.Monad.Trans.Sta...
02:51:05 <newsham> > runState (get >>= (succ >>> put)) 5
02:51:06 <lambdabot>   ((),6)
02:51:17 <kmc> people get the impression that monads are like the key idea in Haskell, which is totally untrue
02:51:41 <kmc> they also get the impression that monads are the key to understanding how IO works in Haskell, which is also false
02:51:57 <kmc> IO is an unusual monad, and the fact that it's a monad is only tangentially relevant to how it works
02:52:16 <newsham> kmc: right but you have to get the mechanics of IO down to do IO in haskell
02:52:22 <kmc> yep
02:52:32 <kmc> but reading about spacesuit burritos isn't going to help with those mechanics
02:52:33 <newsham> which means you need the mechanics of monads
02:52:50 <newsham> i always thought that people should learn IO first without being told about monads
02:52:54 <newsham> and then later told about monads
02:53:04 <kmc> yeah, I recommend the Introduction to IO article for this reason
02:53:43 <elliott> Teaching monads before you teach the IO type is like teaching before addition.
02:54:24 <spiff_> I think much of it is due to the nomenclature which is matemathic, and somewhat exotic-sounding for (imperative) programmers (i.e me). It was for me, but now it seems a little simpler.
02:55:01 <kmc> *nod*
02:55:04 <elliott> spiff_: To be fair, a lot of "normal" imperative programming terminology sounds pretty technobabbley to those on the outside :)
02:55:15 <newsham> unfort when a beginner gets to ">>=" or "fmap" and tries to ?type it, it wont tell him something like   IO a -> (a -> IO b) -> b
02:55:20 <epsilonhalbe> we could call monads schroedinger boxes from now on ;)
02:55:26 <AfC> heh
02:55:35 <elliott> epsilonhalbe: But that promotes the monads-as-containers model. :(
02:55:41 <elliott> Monad naming jokes are very serious business.
02:55:45 <spiff_> ofcource, but the concepts are repeated across all (or many) platforms and languages
02:55:55 <kmc> also, a lot of people give up early on learning Haskell and blame monads, when they've really hit a more general but harder-to-describe problem with understanding abstraction in general
02:56:14 <newsham> most people quit before writing their first three monad tutorials.
02:56:23 <kmc> which means monads have a reputation as hard-to-learn
02:56:35 <kmc> it's probably true that abstraction is hard to learn!
02:56:36 <elliott> spiff_: Well, from our point of view, monads are present in pretty much all imperative code; the languages just aren't powerful enough to abstract it away, so you never notice. :P
02:57:02 <spiff_> It definitely activates an underutilized part of my brain to think functionally as opposed to imperatively :)
02:57:14 <kmc> yeah :)
02:57:16 <elliott> I don't think we've talked about how much better Haskell is than every other language enough today. Quick, let's do it some more.
02:57:18 <spiff_> although I've had some experience with CUDA/OpenCL
02:57:19 <kmc> that's one of the best reasons to learn this stuff
02:57:35 <epsilonhalbe> abstraction is generally hard - and strange names are often a "reason" to quit
02:57:47 <spiff_> it's a little like the feeling I got when first learning regexps: "whoa." ;)
02:57:47 <newsham> elliott: pfftt.  still has those pesky non-terminating programs.
02:58:04 <elliott> newsham: Not if you're good enough.
02:58:23 <newsham> elliott: your haskell rejects nonterminating code?
02:58:26 <newsham> mine does not.
02:58:30 <elliott> newsham: No, I just don't write it. Ever.
02:58:31 <newsham> how do I get better?
02:58:50 <elliott> newsham: First you have to get a tattoo with the entire text of the Gentle Introduction.
02:59:06 <newsham> elliott: if you're so good, why bother with a statically typed language?
02:59:13 <newsham> dynamic typing is more powerfu.
02:59:18 <elliott> Because Haskell is better than every other language, as previously established.
02:59:24 <epsilonhalbe> powerfuuuuu
02:59:36 <kmc> just use C, real programmers don't make mistakes
02:59:38 <kmc> amirite
02:59:49 <newsham> kmc: C is still statically typed.
02:59:54 <engla> use python
03:00:00 <elliott> Python is strongly typed.
03:00:05 <elliott> I suggest Forth.
03:00:07 <kmc> it's statically typed, but you're encouraged to subvert the type system at every turn
03:00:13 <GreaseMonkey> assembler is untyped, go for your life
03:00:18 <GreaseMonkey> and yes.
03:00:24 <elliott> GreaseMonkey: Not entirely.
03:00:28 <GreaseMonkey> actually assembler is still somewhat typed
03:00:29 <engla> my computer includes a forth interpreter, quite neat
03:00:30 <kmc> types in C exist to specify machine representations
03:00:30 <elliott> GreaseMonkey: Not entirely.
03:00:34 <engla> (Open Firmware)
03:00:36 <kmc> engla, OLPC XO-1?
03:00:41 <elliott> GreaseMonkey: You can't just put a memory location where a register is expected.
03:00:44 <kmc> New World PowerMac?
03:00:45 <engla> kmc: my old mac
03:00:48 <kmc> cool
03:00:50 <elliott> kmc: or a PPC- yeah
03:00:56 <elliott> bit more likely than an OLPC :P
03:01:01 <kmc> i'm not sure honestly
03:01:03 <elliott> although i guess not so much these days.
03:01:09 <kmc> i know a lot of people with XO-1's
03:01:16 <kmc> maybe because I know people who work at OLPC ;P
03:01:17 <newsham> i have an xo
03:01:21 <elliott> One laptop per hacker.
03:01:43 <kmc> i'm interested in the upcoming XO-1.75, which will be ARM-based and have low enough power consumption that you can *actually* run it from a hand crank
03:01:46 <Skola> what's a concise lib for generating xml?
03:02:13 <elliott> kmc: Didn't they abandon their OS for Windows or something ridiculous like that?
03:02:26 <kmc> they made it possible to install Windows
03:02:30 <newsham> http://www.thenewsh.com/~newsham/x/machine/olpc9.jpg
03:02:38 <kmc> i don't think they're giving up on their alternative free OS
03:03:06 <newsham> it was pretty odd that they went x86 in the first place
03:03:09 <engla> I thought it was up in the air
03:03:17 <newsham> when they wanted low power
03:03:28 <kmc> the project is pretty old
03:03:38 <kmc> i don't think the ARM smartphone processors of today existed when they started
03:03:44 <newsham> we should just send $80 amazon readers to third world kids
03:03:53 <newsham> and have them hack it up into something useful
03:04:00 <kmc> yeah then they can pay $10 a pop for ebooks
03:04:02 <kmc> ;P
03:04:18 <elliott> kmc: s/ebooks/revocable licenses to read ebooks/
03:04:20 <elliott> Or did they fix that? :p
03:04:29 <kmc> good point
03:05:15 <newsham> in a few years the worlds trash binds will be overflowing with used ipads
03:05:25 <newsham> maybe we can teach 3rd world kids to compute with those
03:05:36 <kmc> or at least to melt them down for trace minerals
03:06:07 <newsham> they already do that
03:06:38 <kmc> http://www.wired.com/gamelife/2011/09/phone-story/
03:35:41 <kmc> can i use GHC's threaded runtime with 'runhaskell'?
03:35:59 <elliott> runhaskell -threaded? dunno
03:36:32 <kmc> "Warning: -debug, -threaded, and -ticky are ignored by GHCi"
03:36:51 <elliott> heh
03:47:10 * hackagebot midi 0.1.6 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.1.6 (HenningThielemann)
03:51:30 <erus`> > (/ 2) 10
03:51:31 <lambdabot>   5.0
03:51:55 <erus`> (\ 2) = (\ x -> x \ 2)
03:52:22 <erus`> clever haskell
03:55:29 <Phyx-> erus`: speaking to yourself again?
03:56:45 <erus`> maybe
03:57:16 <Phyx-> erus`: aha, carry on
03:59:24 <kmc> you can't use (\) as an operator
04:00:36 <erus`> i meant /
04:01:10 <erus`> i joke woke up, leave me alone
04:06:25 <erus`> wow
04:06:38 <erus`> I have a bad cold too :P
04:12:01 <Phyx-> :t 7
04:12:02 <lambdabot> forall t. (Num t) => t
04:12:25 <Phyx-> :t \f -> (f 1, f 'a')
04:12:26 <lambdabot>     No instance for (Num Char)
04:12:26 <lambdabot>       arising from the literal `1' at <interactive>:1:9
04:12:26 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
04:12:45 <Phyx-> :t \(f::forall a. a -> Int) -> (f 1, f 'a')
04:12:46 <lambdabot> (forall a. a -> Int) -> (Int, Int)
04:13:10 <Phyx-> :t \(f::forall a. a -> Int) -> (f 1, f 'a') (const 0)
04:13:11 <lambdabot>     Couldn't match expected type `t1 -> t'
04:13:11 <lambdabot>            against inferred type `(Int, Int)'
04:13:12 <lambdabot>     In the expression: (f 1, f 'a') (const 0)
04:13:22 <Phyx-> :t (\(f::forall a. a -> Int) -> (f 1, f 'a')) (const 0)
04:13:23 <lambdabot> (Int, Int)
04:14:07 <Phyx-> :t (\(f::forall a. a -> Int) -> [f 1, f 'a', f f]) (const 0)
04:14:07 <lambdabot> [Int]
04:15:06 <kmc> erus`, :( i'm getting over a bad cold myself
04:15:09 <kmc> hope you feel better
04:15:19 <Phyx-> vitamins people!
04:15:30 <erus`> i just popped a multi
04:15:36 <Phyx-> i pop one daily
04:15:42 <erus`> me too
04:16:12 <Phyx-> :t (\(f::forall a. a -> Int) -> f f)
04:16:13 <lambdabot> (forall a. a -> Int) -> Int
04:43:47 <hpaste_> angstrom pasted “how to avoid the "hack" in the last pattern?” at http://hpaste.org/52315
04:47:21 <ion> angstrom: const False
04:47:56 <angstrom> ah. that's nice
04:48:03 <ion> Shouldn’t those be <=s?
04:48:20 <angstrom> actually, yes :-)
04:48:42 <shachaf> Alternatively, take out the -1s.
04:48:53 <shachaf> It doesn't look like such a hack to me, anyway.
04:49:20 <angstrom> well. I was trying to do 'checkRange _ _ = False' which didn't work because of wrong number of arguments
04:49:21 <ion> aye
04:49:24 <shachaf> However, you could write a function to fold over a list of the form [(Int,2^15),(UInt,2^16)], etc.
04:49:34 <shachaf> Might be cleaner.
04:50:17 <elliott> angstrom: Does it even make sense to pass a non-integral type as the first argument to checkRange?
04:51:26 <angstrom> elliott: good point
04:51:48 <elliott> You might want checkRange _ = error "oh no you don't". :)
04:52:19 * elliott would make it typeRange :: Type -> Integer, anyway, and move the (<) to the call site. But maybe that doesn't work for you.
04:52:25 * hackagebot iteratee-stm 0.1 - Concurrent iteratees using STM  http://hackage.haskell.org/package/iteratee-stm-0.1 (JohnLato)
04:55:19 <angstrom> shachaf: how'd I go about folding over such a list?
04:56:33 <kmc> hmm, my library uses Control.Exception.block which is deprecated in favor of 'mask', but 'mask' does not work on GHC 6.12 and earlier
04:56:34 <kmc> advice?
04:56:46 <kmc> should i ifdef it, or just break compatibility, or ignore the deprecation warning?
05:03:08 <shachaf> Kind of strange to deprecate it so early.
05:03:08 * Clint nods.
05:03:23 <kmc> ifdef'ing is not too bad, I think I'll do that
05:03:54 <shachaf> Make a compatibility library!
05:04:12 <luite> 6.12 is still used on the latest ubuntu, I'd wait at least six months before removing support entirely
05:04:12 <kmc> hmm, it's not clear why i'm even blocking async exceptions
05:04:20 <kmc> i think i got the idea from another similar lib ;P
05:05:48 <kmc> i have «forkIO (try foo >>= putMVar v)»
05:06:25 <kmc> which I changed to «mask $ \restore -> forkIO (try (restore foo) >>= putMVar v)»
05:06:44 <hey_lu> hehe, ES6 gains sort-of pattern matching? http://www.slideshare.net/BrendanEich/jslol-9539395 :D
05:06:54 <hey_lu> (slide 27)
05:06:56 <kmc> oh, the important part is to block it for the putMVar part
05:07:00 <kmc> i understand why i wrote this now
05:07:01 <shachaf> angstrom: Actually, you're doing something simpler than I thought. It's probably overkill.
05:07:33 <kmc> hey_lu, eh, looks like the stuff Python etc. have had for a long time
05:07:45 <jlouis> ion: do you honestly think that the code I made should be extracted into a package of its own?
05:08:13 <angstrom> shachaf: ok
05:08:42 <shachaf> @let fun tipe x = maybe False (x <) . lookup tipe $ [("Int",5),("UInt",10)]
05:08:43 <lambdabot>  Defined.
05:09:10 <kmc> what I really should use is bracket (return v) putMVar
05:09:33 <kmc> but not quite
05:09:36 <shachaf> > (fun "Int" 3, fun "Int" 5, fun "UInt" 9, fun "blah" 1)
05:09:36 <lambdabot>   Ambiguous occurrence `fun'
05:09:37 <lambdabot>  It could refer to either `L.fun', defined at <l...
05:09:46 <shachaf> "fun" is predefined?
05:09:49 <shachaf> @undefine
05:10:00 <shachaf> @ty fun
05:10:01 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
05:10:02 <shachaf> Oh.
05:10:08 <shachaf> angstrom: Anyway, you could do something like that.
05:10:21 <hey_lu> kmc: i've only seen python from a distance...
05:12:08 <angstrom> shachaf: makes sense. also, 'tipe' seems to be good alternative to 'typ' (even though 'typ' is german for 'type' :-) )
05:12:10 <Axman6> > fun "lol" 3
05:12:11 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:12:11 <lambdabot>    `SimpleReflect.FromExpr ...
05:12:15 <Axman6> > fun "lol" 3 :: Expr
05:12:16 <lambdabot>   lol 3
05:12:24 <Axman6> > fun "\nlol" 3 :: Expr
05:12:25 <lambdabot>   lol 3
05:12:29 <Axman6> > fun "a\nlol" 3 :: Expr
05:12:30 <lambdabot>   a
05:12:31 <lambdabot>  lol 3
05:12:35 <Axman6> heh, good
05:13:30 <kmc> @quote quine
05:13:30 <lambdabot> quine says: A quine is a computer program which produces a copy of its own source code as its only output. The standard terms for these programs in the computability theory and computer science
05:13:31 <lambdabot> scalabot: println("@quote quine")
05:14:08 <Axman6> @quote seen
05:14:08 <lambdabot> kyevan says: I haven't tried learning C++, from what I've seen, simple c++ is readable pretty easily, complex C++ makes me want to hide in the closet.  (I'm not referring to my sexuality, either)
05:14:12 <Axman6> @quote seen
05:14:12 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
05:14:22 <Axman6> seen foo
05:14:27 <Axman6> @seen foo
05:14:27 <preflex>  foo was last seen on #css 2 days, 14 hours, 46 minutes and 2 seconds ago, saying: oksushi: ah, whoops, I see it now, my bad. :)
05:14:28 <lambdabot> Unknown command, try @list
05:14:44 <Axman6> hmm, i'm sensing another bot loop vector
05:15:00 <Axman6> @seen >
05:15:00 <preflex>  what
05:15:00 <lambdabot> Unknown command, try @list
05:15:07 <Axman6> heh, or not
05:15:42 <shachaf> Axman6: There's a space in front of "foo".
05:21:16 <Axman6> oh so there is
05:35:13 <FUZxxl> hi there!
05:35:27 <shachaf> @ahoy FUZxxl
05:35:28 <lambdabot> "FUZxxl"
05:35:45 <kmc> hi FUZxxl!
05:36:11 <kmc> @hoogle (|*|)
05:36:12 <lambdabot> No results found
05:37:08 <elliott> Axman6: do we need another one when ?so still works?
05:37:39 <shachaf> elliott: ?so
05:37:40 <Axman6> hmm?
05:37:45 <Axman6> ?s0
05:37:45 <lambdabot> Maybe you meant: . ? @ ask bf do ft id msg pl rc src v wn
05:37:47 <Axman6> ?so
05:37:48 <lambdabot>  not available
05:37:52 <elliott> ?so foo
05:37:53 <Axman6> ?so foo
05:37:53 <lambdabot> foo not available
05:37:53 <lambdabot> foo not available
05:37:57 <shachaf> Oh.
05:38:02 <shachaf> ?source foo
05:38:02 <lambdabot> foo not available
05:38:03 <Axman6> ?so > 1 + 1
05:38:04 <lambdabot> > 1 + 1 not available
05:38:07 <shachaf> ?where ?where
05:38:07 <lambdabot> ?where ?where
05:38:11 <Axman6> ?so seen foo
05:38:12 <lambdabot> seen foo not available
05:38:18 <elliott> ?so !c char *s="?so !c char *s=%c%s%c; printf(s,34,s,34);//"; printf(s,34,s,34);//
05:38:18 <lambdabot> !c char *s="?so !c char *s=%c%s%c; printf(s,34,s,34);//"; printf(s,34,s,34);// not available
05:38:19 <cicatristeza> hello how do i install a package from hackage?
05:38:20 <Axman6> ?so @seen foo
05:38:20 <lambdabot>  @seen foo not available
05:38:21 <shachaf> I believe preflex ignores lambdabot.
05:38:29 <elliott> That works with a bot that does !c.
05:38:33 <elliott> Which this channel lacks.
05:39:09 <FUZxxl> Where is the Haskell Platform 2011.4.0.0 ¶
05:39:35 <FUZxxl> ?
05:40:00 <elliott> not out yet
05:40:59 <FUZxxl> strange...
05:41:38 <elliott> "Waiting a month or so till the 7.2 release stabilises." -- dons, two months ago
05:41:49 <FUZxxl> Is there an ETA?
05:42:52 <elliott> dunno
05:43:05 <shachaf> elliott: But then they "corrected" the announcement of GHC 7.2 to say it was a preview-only release.
05:43:10 <FUZxxl> okay
05:43:19 <shachaf> We have always been at war with  OCaml.
05:43:22 <cicatristeza> which is the simplest and best explanation of monads?
05:43:36 <FUZxxl> :D
05:43:37 <kmc> cicatristeza, whichever one follows naturally in the Haskell tutorial you're reading
05:43:43 <shachaf> @quote think.of.a.monad
05:43:43 <lambdabot> dons says: Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
05:43:44 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
05:43:52 <kmc> cicatristeza, monads aren't a big deal but it doesn't make sense to learn them in isolation
05:43:57 <kmc> there are lots of prerequisite concepts
05:44:07 <shachaf> cicatristeza: Usually people worry about "what monads are" too much and try to figure the topic out out of context with strange analogies.
05:44:07 <elliott> kmc: I have this strange sense of deja vu.
05:44:12 <kmc> indeed
05:44:14 <FUZxxl> Hey... monads are like burritos
05:44:16 <cicatristeza> kmc, how did you learn haskell
05:44:24 <kmc> i don't remember, it was a long time ago
05:44:29 <elliott> cicatristeza: lyah is good
05:44:31 <elliott> @where lyah
05:44:31 <lambdabot> http://www.learnyouahaskell.com/
05:44:33 <kmc> i read the Gentle Introduction and dicked around a lot in ghci
05:44:38 <Phyx-> kmc: how long? :P
05:44:38 <kmc> i would recommend you read LYAH
05:44:41 <shachaf> kmc is old and weary.
05:44:43 <cicatristeza> i am reading lyah
05:44:46 <kmc> it has a good chapter on monads, and it does not get to them too early
05:44:49 <FUZxxl> I read Real World Haskell; That was my first and most succesful attempt
05:44:49 <kmc> why do you want to jump ahead?
05:44:50 <elliott> cicatristeza: great; it covers monads
05:45:01 <Phyx-> Haskell was beaten into me with a stick
05:45:18 <cicatristeza> who wrote Math.OEIS in hackage? i'd like to talk to them
05:45:26 <kmc> Phyx-, about 5 years
05:45:41 <cicatristeza> kmc: curiosity
05:45:48 <Phyx-> kmc: ah
05:46:05 <elliott> http://hackage.haskell.org/package/oeis → "Author	Brent Yorgey" "Maintainer	Brian Lewis <brian@lorf.org>"
05:46:33 <shachaf> @oeis [Brent Yorgey, Brian Lewis]
05:46:33 <lambdabot>  Sequence not found.
05:46:35 <shachaf> Curses.
05:46:41 <kmc> cicatristeza, don't believe all the hype about monads; it's just another concept you'll get to in due course
05:47:06 <cicatristeza> kmc: ok. i guess its cos i run xmonad and i wondered about the name
05:47:11 <kmc> hehe
05:47:38 <elliott> People should get all hyped up about applicative functors instead.
05:47:42 <shachaf> A monads is a lot like a box that contains simple answers to every last one of your questions, if only you could open it. Which you can't.
05:47:49 <elliott> Those have a more awkward name, so they'd be harder to create an aura of mystery around.
05:47:53 <FUZxxl> @oesis [1,2,4,7,12,20]
05:47:54 <lambdabot>  Sequence not found.
05:47:58 <FUZxxl> @oesis [1,2,4,7,12,20
05:47:58 <lambdabot>  Sequence not found.
05:48:03 <FUZxxl> @oesis 1,2,4,7,12,20
05:48:05 <lambdabot>  Fibonacci numbers - 1.
05:48:06 <lambdabot>  [0,0,1,2,4,7,12,20,33,54,88,143,232,376,609,986,1596,2583,4180,6764,10945,17...
05:48:16 <shachaf> elliott: I think "monoid" has a more mysterious name than "monad".
05:48:21 <elliott> @oeis 1,1,1,1,1,1
05:48:24 <kmc> monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
05:48:33 <FUZxxl> @oesis 1,2,4,7,12,20,33,54
05:48:36 <lambdabot> Plugin `oeis' failed with: thread killed
05:48:37 <lambdabot>  Fibonacci numbers - 1.
05:48:38 <lambdabot>  [0,0,1,2,4,7,12,20,33,54,88,143,232,376,609,986,1596,2583,4180,6764,10945,17...
05:48:39 <shachaf> @oasis 1,2,4,0,0,0
05:48:42 <alem0lars> hi, i'm tidying my xmonad config, and i would need to find a way to put my layouts in a list. I tried to sign the list with universal type extension but it still complains :(
05:48:46 <lambdabot>  Excess of number of divisors of 2n+1 of form 12k+1, 12k+5 over those of form...
05:48:46 <lambdabot>  [1,1,2,0,1,0,2,2,2,0,0,0,3,1,2,0,0,0,2,2,2,0,2,0,1,2,2,0,0,0,2,0,4,0,0,0,2,3...
05:48:59 <FUZxxl> That's fun
05:49:04 <FUZxxl> Now a hard one
05:49:14 <FUZxxl> @oasis [0,1,1,0,1,0,0,1
05:49:15 <lambdabot>  Sequence not found.
05:49:18 <FUZxxl> @oasis 0,1,1,0,1,0,0,1
05:49:30 <FUZxxl> @oasis 0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0
05:49:31 <lambdabot>  Thue-Morse sequence: let A_k denote the first 2^k terms; then A_0 = 0 and fo...
05:49:31 <lambdabot>  [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1...
05:49:37 <FUZxxl> what the
05:49:39 <elliott> alem0lars: there's an #xmonad, I think
05:49:45 <lambdabot> Plugin `oeis' failed with: thread killed
05:49:55 <elliott> FUZxxl: did you just accidentally get thue-morse? :D
05:49:55 <shachaf> FUZxxl: You can /msg lambdabot, by the way. :-)
05:49:57 <Axman6> is that just n & 0x02?
05:50:11 <FUZxxl> No.
05:50:30 <FUZxxl> You start with 0, dann always negate it and append
05:50:34 <alem0lars> elliott: i posted here because the issue is strictly related to typing.. I'll try there, thanks
05:50:34 <FUZxxl> so you get
05:50:50 <elliott> alem0lars: oh, oka
05:50:51 <FUZxxl> 0 01 0110 01101001 0110100110010110...
05:50:53 <elliott> y
05:50:59 <FUZxxl> repeat to infinity....
05:51:01 <elliott> alem0lars: well, you could hpaste the code that has a type error
05:51:15 <cicatristeza> there is an oeis bot?
05:51:23 <kmc> lambdabot has an oeis plugin
05:51:31 <cicatristeza> @oasis 15, 21, 27
05:51:32 <lambdabot>  First differences of Y-toothpick numbers A160120.
05:51:32 <lambdabot>  [1,3,3,9,3,9,9,21,9,9,9,21,15,21,27,51,27,9,9,21,15,21,27,51,33,21,27,51,51,...
05:51:40 <cicatristeza> how lovely
05:51:54 <kmc> @oeis 14, 23, 28, 33, 42, 51, 59, 68
05:51:54 <lambdabot>  Numbered stops in Manhattan on the Lexington Avenue subway.
05:51:54 <lambdabot>  [8,14,23,28,33,42,51,59,68,77,86,96,103,110,116,125]
05:52:03 <elliott> very mathematical
05:52:42 <cicatristeza> kmc, that was a joke right?
05:52:48 <cicatristeza> surely that isnt in the oeis
05:53:02 <kmc> it is
05:53:15 <Clint> it's technically incorrect
05:53:23 <kmc> http://oeis.org/A001049
05:53:27 <cicatristeza> i love the oeis so much
05:53:42 <cicatristeza> so many interesting papers
05:53:45 <Clint> 8 isn't numbered
05:54:05 <kmc> yeah
05:54:26 <kmc> it is on the BMT Broadway Line, though
05:54:49 <kmc> @oeis 8, 14, 23, 28, 34, 42, 49, 57
05:54:50 <lambdabot>  Sequence not found.
05:55:03 <irykna> lol what the hell "numbered stops in Manhattan on the Lexington Avenue subway"
05:55:08 <irykna> not disputing that it's an important sequence
05:55:15 <irykna> but what uber-completist put it in there?
05:55:22 <kmc> it's not complete
05:55:25 <kmc> as i demonstrated ;)
05:55:25 <irykna> by the way
05:55:31 <irykna> s/dankna/irykna/g in your brains please
05:55:32 <cicatristeza> is there anyone here who does things with the oeis?
05:55:56 <irykna> I intentionally am choosing a new nick that resembles my old one to ease the transition
05:56:14 <FUZxxl> @oasis 836, 4030, 5830, 7192, 7912, 9272, 10430
05:56:14 <lambdabot>  Weird numbers: abundant (A005101) but not pseudoperfect (A005835).
05:56:14 <lambdabot>  [70,836,4030,5830,7192,7912,9272,10430,10570,10792,10990,11410,11690,12110,1...
05:56:58 <FUZxxl> @acme
05:57:00 <lambdabot> Local time for FUZxxl is Sa 08 Okt 2011 15:01:20 CEST
05:57:26 <irykna> @oasis 12 13 1980
05:57:27 <lambdabot>  Sequence not found.
05:57:29 <irykna> haha
05:58:51 <Phyx-> anyone here ever compile a static lib using ghc on linux?
06:00:06 <dcoutts> Phyx-: you probably need to ask a more specific Q, everyone here using linux does that all the time (since the default is building static libs)
06:01:06 <Phyx-> dcoutts: huh? I thought the default was building an executable
06:01:27 <dcoutts> Phyx-: well everytime they cabal install a lib, they're building a static lib
06:02:12 <hpaste_> alem0lars pasted “layouts in list” at http://hpaste.org/52317
06:02:15 <Phyx-> dcoutts: http://stackoverflow.com/questions/7652799/compiling-ghc-with-fpic-support that's the question I can't seem to get any answers on, lol
06:03:10 <elliott> alem0lars: you can't do that
06:03:18 <dcoutts> Phyx-: I thought you were interested in static libs, not dynamic libs
06:03:20 <elliott> you'll need an existential
06:03:39 <dcoutts> Phyx-: the fedora ghc rpm packages all use dynamic libs, if that's what you're after
06:04:20 <alem0lars> elliott: so exists instead of forall ?
06:04:24 <elliott> alem0lars: No.
06:04:32 <elliott> alem0lars: I'll annotate your paste.
06:04:41 <dcoutts> Phyx-: and cabal will build shared/dynamic libs if you --enable-shared
06:04:58 <kmc> you can't actually write 'exists' with GHC, sadly
06:05:05 <Phyx-> dcoutts: no. I want to build a shared lib by exporting my functions using FFI. I assume since I don't use the -dynamic flag that ghc is building a static and not dynamic lib
06:05:06 <hpaste_> elliott annotated “layouts in list” with “layouts in list (annotation)” at http://hpaste.org/52317#a52318
06:05:10 <elliott> alem0lars: Something like that.
06:05:16 <kmc> probably there is a simpler way, alem0lars
06:05:27 <kmc> why do you want this list?
06:05:50 <Phyx-> dcoutts: my question comes down to this, compiling with -shared seems to force -fPIC on linux, but the ghc core libs are not compiled with it. so it's kinda moot
06:05:51 * elliott thinks it's probably the simplest way and that this LayoutClass is likely a design flaw in xmonad
06:06:12 <kmc> well it's hard to say without any context for how the list is used
06:06:31 <elliott> Oh
06:06:33 <elliott> Hey alem0lars
06:06:37 <alem0lars> yes?
06:06:37 <elliott> You don't need to define Layout
06:06:40 <elliott> data Layout a = forall l. (LayoutClass l a, Read (l a)) => Layout (l a)
06:06:43 <elliott> It already exists, in XMonad.Core
06:06:48 <dcoutts> Phyx-: are you trying to build one massive shared lib that includes the rts, base etc etc? Or are you happy with making a shared lib that dynamically links to the rts, base etc as separate shared libs?
06:06:51 <alem0lars> elliott: yes, thanks
06:06:58 <elliott> With one extra type param, but w/e
06:07:09 <kmc> figures
06:07:18 <elliott> kmc: looking at XMonad.Core, it seems like LayoutClass is Yet Another Typeclass That Should Be a Record
06:07:19 <Phyx-> dcoutts: trying to create a massive one.
06:07:20 <kmc> i guess people are probably sick of me linking http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
06:07:46 <kmc> elliott, i think the rationale here is that they need to serialize layouts across program restart
06:07:49 <elliott> I said the same things before I saw you doing it. Get off my lawn. (Admittedly this is just because I didn't pay much attention to this channel.)
06:07:51 <alem0lars> i'm putting layouts in a list to zipWith onWorkspace
06:08:03 <dcoutts> Phyx-: ok, that's the hard case because it means you need the rts, base etc to have been built with -fPIC but to be built as ordinary static libs.
06:08:07 <elliott> kmc: Just include serialise/deserialise functions in the Layout type?
06:08:23 <dcoutts> Phyx-: doing it all as separate shared libs, one per package is easier.
06:08:24 <elliott> kmc: Hmm, it looks like the constraint is basically Show and Read
06:08:33 <elliott> So all you probably need is -> String and String -> :p
06:09:35 <kmc> yep, i'm sure you can still do it without type classes
06:09:40 <kmc> but it might tilt the balance of which solution is nicer
06:10:06 <Phyx-> dcoutts: well, i've tried telling it to build everything with -fPIC. What flag do i need to use to make separate libs?
06:10:09 <dcoutts> Phyx-: note that in that command line you're using -shared -static, which doesn't make sese
06:10:10 * elliott wonders why the Show is a constraint of the typeclass but Read a constraint of the existential
06:10:43 <dcoutts> Phyx-: plus, you're not actually building with -fPIC
06:11:09 <alem0lars> elliot: Expected kind *, but Layout has kind * -> *  :(
06:11:10 <dcoutts> Phyx-: in that command line you're compiling /tmp/Hs2lib924498/Hs2lib.hs, but you're not using -fPIC (unless I'm being blind)
06:11:25 <Phyx-> dcoutts: that seems to be the default, so i ommitted it. adding it made no difference. but the error is in GHC-Prim not my invocation
06:11:25 <elliott> alem0lars: <elliott> With one extra type param, but w/e
06:11:30 <elliott> alem0lars: Just change [Layout] to [Layout a]
06:11:31 <dcoutts> Phyx-: plus you're trying to output to -oHs2lib.a which is not what you want
06:11:35 <alem0lars> thanks
06:12:10 <dcoutts> Phyx-: it's complaining about a relocation in your module, against something in ghc-prim.
06:12:12 <Phyx-> dcoutts: don't static libs have a .a ?
06:12:32 <dcoutts> Phyx-: yes, but ghc doesn't make .a files, and you don't want a .a file, you want a shared lib.
06:12:37 <erus`> does 7.* use the llvm backend by default?
06:13:00 <dcoutts> erus`: no, default is -fasm, use -fllvm to use llvm
06:14:10 <alem0lars> elliott: now he cannot deduce LayoutClass Accordion a from the context, but things are getting complicated i guess.
06:14:10 <dcoutts> Phyx-: .a is for ordinary static libs, but you want to make a .so shared lib, right?
06:14:13 <erus`> ghc: could not execute: opt ?
06:14:26 <elliott> alem0lars: Add it to the context -P
06:14:27 <elliott> :-P
06:14:33 <elliott> alem0lars: But I'm starting to agree with kmc, you don'tw ant this list.
06:14:36 <Clint> http://oeis.org/A104175
06:14:53 <dcoutts> erus`: you need llvm installed
06:15:21 <erus`> is it gonna be part of ghc soon?
06:15:26 <erus`> i mean the platform
06:15:28 <elliott> no
06:15:31 <dcoutts> erus`: what llvm?
06:15:36 <benmachine> ghc is part of the platform, isn't it? :P
06:15:37 <erus`> yeah
06:15:38 <benmachine> sorta
06:15:45 <Phyx-> dcoutts: either one would do. But a shared lib would do
06:15:48 <benmachine> er, wait, misparse
06:15:50 * benmachine shh
06:15:51 <alem0lars> elliott, kmc: thanks  for the help
06:15:53 <dcoutts> erus`: probably not soon
06:16:00 <Phyx-> dcoutts: so the -static should be removed
06:16:13 <elliott> dcoutts: There are plans of any sort to merge the Platform into GHC?
06:16:34 <dcoutts> elliott: no, that'd defy the point of the platform
06:16:47 <elliott> dcoutts: So s/soon/ever/? :p
06:17:08 <kmc> i thought the question is "will LLVM toolchain be part of Platform"
06:17:18 <elliott> Oh.
06:17:20 <elliott> I misparsed.
06:17:29 <elliott> <dcoutts> erus`: you need llvm installed | <erus`> is it gonna be part of ghc soon? <erus`> i mean the platform
06:17:40 <dcoutts> kmc: right, which would really mean "will LLVM toolchain be shipped with ghc binaries?"
06:18:00 <dcoutts> like how ghc binaries on windows ship gcc
06:18:02 <kmc> probably better if it isn't
06:18:15 <dcoutts> kmc: yeah, we'd only do it on platforms like windows
06:18:22 <kmc> "broken platforms"
06:18:23 <dcoutts> on linux, osx, we'd rely on the system instance
06:18:26 <kmc> it's okay, I don't work for MSR, I can say it :)
06:18:43 <kmc> a good bit of the value of the LLVM backend is that LLVM is Someone Else's Problem
06:19:13 <dcoutts> erus`: at the moment the llvm backend isn't faster, so there's no great pressure to move, that may change one day
06:19:16 <Ke> sadly llvm does not support too many arches
06:19:39 <kmc> it's faster for certain things
06:20:02 <Axman6> Ke: much more than GHC does
06:20:14 <Ke> for ncg yes
06:20:14 <dcoutts> kmc: yes, more accurately I should have said isn't generally faster
06:20:47 <dcoutts> Phyx-: first thing, compile your Hs2lib.hs to Hs2lib.o using -fPIC
06:21:12 <dcoutts> Phyx-: then link all your .o files and packages using -shared  -o hs2lib.so
06:21:12 <benmachine> kmc: it's SEP except for when we write big feature patches to make it work :P
06:21:20 <benmachine> kmc: I think "not /just/ our problem" would be fairer
06:21:26 <kmc> well yeah
06:21:37 <Phyx-> dcoutts: so unlike on windows, you can't do this in one go?
06:21:39 <Ke> it seems that llvm is missing IA64 and mips64 which are both far from totally irrelevant
06:21:50 <Phyx-> but i'll try
06:21:51 <dcoutts> Phyx-: probably can, but just get it working first
06:21:59 <Phyx-> dcoutts: ok
06:22:11 <dcoutts> Phyx-: it's good to understand which flags apply to compilation vs linking
06:22:28 <dcoutts> Phyx-: and to understand what -shared -dynamic and -fPIC mean (they're all orthogonal)
06:23:01 <dcoutts> sprinkling them around will just get you into trouble
06:24:05 <Phyx-> i know what fPIC does, and a pretty good idea what -dynamic does (doesn't link everything in one monolithical thing). but the meaning of -shared was hazy
06:24:10 <Phyx-> but it's clear now
06:26:32 <Ke> dynamic linkinf without anything else sounds a bit silly
06:26:50 <Ke> I would not say orthogonal in that sense
06:27:16 <Ke> it's like "let's make this program run slower"
06:27:47 <kmc> fPIC is useful without -shared though
06:28:07 <kmc> e.g. for executable ASLR
06:29:42 <dcoutts> Phyx-: -dynamic is a compiler and linker flag, it says to compile and link against dynamic libs. -shared is only a linker flag, it says to make a shared lib.
06:30:37 <dcoutts> Ke: -dynamic without -fPIC also makes sense
06:30:53 <dcoutts> as does -fPIC without dynamic
06:31:10 <Ke> well to some, ffmpeg uses it iirc
06:31:45 <dcoutts> right, that's a good example, ffmpeg links agsinst glibc dynamically, but the ffmpeg code itself is not built with fPIC
06:32:01 <dcoutts> because they think it makes their code slower
06:32:49 <kmc> (which it probably does, on i386 anyway)
06:33:03 <dcoutts> right, and we have a similar issue on 32bit x86
06:33:05 <kmc> x86_64 is more friendly to PIC
06:33:11 <dcoutts> which is why -fPIC is not the default
06:34:38 <angstrom> how can I check which parser succeeded in a function like `foo = do { x <- parse1 <|> parse2 <|> parse3 ; return x }' ?
06:35:43 <FUZxxl> I am annoyed by the limitations of the Bits class...
06:35:44 <kmc> data Which t = Which String t;  foo = (Which "one" <$> parse1) <|> (Which "two" <$> parse2) <|> (Which "three" <$> parse3)
06:35:52 <kmc> but you can probably come up with a more appropriate data type for your situation
06:36:02 <kmc> angstrom, by the way,  «do { x <- m; return x }» is equivalent to just m
06:36:29 <FUZxxl> Why is there no function to calculate the hammington weight? Or the least / most signifficant bit set to 1?
06:36:38 <angstrom> kmc: I see. thanks
06:36:58 <elliott> FUZxxl: You can build that last one trivially.
06:37:06 <elliott> With bitSize.
06:37:06 <FUZxxl> how?
06:37:12 <Axman6> FUZxxl: because those are easy to build using the functions provided by the Bits class
06:37:17 <FUZxxl> bitSize is undefined for Integer
06:37:24 <elliott> FUZxxl: Integer has no most significant bit.
06:37:28 <elliott> Least significant bit is always 0.
06:37:41 <elliott> So... yeah, it's true, you can't do the impossible to Integers using the methods in Bits :P
06:37:42 <FUZxxl> no... the least signifficant bit that is SET TO 1
06:37:44 <kmc> this is only tangentially relevant, but there was work recently to add a hamming weight primitive to GHC, backed by the POPCNT instruction on CPUs which support it
06:37:52 <elliott> Oh. Well you don't need bitSize for that.
06:37:54 <FUZxxl> so for 12 ( 1 1 0 0) that would be 2.
06:38:03 <elliott> Let's see:
06:38:07 <FUZxxl> kmc: really?
06:38:10 <FUZxxl> That's great
06:38:11 <elliott> > map (testBit 99) [0..]
06:38:12 <lambdabot>   Ambiguous type variable `t' in the constraint:
06:38:12 <lambdabot>    `Data.Bits.Bits t'
06:38:12 <lambdabot>      a...
06:38:17 <elliott> > map (testBit (99 :: Integer)) [0..]
06:38:18 <lambdabot>   [True,True,False,False,False,True,True,False,False,False,False,False,False,...
06:38:24 <elliott> > find id . map (testBit (99 :: Integer)) [0..]
06:38:25 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
06:38:25 <lambdabot>         against inferred typ...
06:38:30 <elliott> > find id $ map (testBit (99 :: Integer)) [0..]
06:38:30 <lambdabot>   Just True
06:38:35 <elliott> Oops
06:38:35 <kmc> FUZxxl, yeah, as part of the project to convert unordered-containers to use packed 16-ary internal nodes
06:38:37 <elliott> ?hoogle findIndex
06:38:37 <lambdabot> Data.ByteString findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
06:38:37 <FUZxxl> elliott: That's damn inefficient
06:38:38 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
06:38:38 <lambdabot> Data.Map findIndex :: Ord k => k -> Map k a -> Int
06:38:40 <benmachine> FUZxxl: there are magic ways to do that, iirc
06:38:40 <kmc> hash-array mapped trie
06:38:53 <elliott> > findIndex (testBit (99 :: Integer)) [0..]
06:38:54 <lambdabot>   Just 0
06:38:57 <kmc> see https://github.com/tibbe/unordered-containers/tree/hamt
06:39:00 <benmachine> FUZxxl: although I don't know what the MSB set to 1 is in (-1 :: Integer)
06:39:01 <elliott> FUZxxl: So write your own implementation for your type
06:39:10 <FUZxxl> elliottt: You can get at least O(log n) y using kind of binary search
06:39:12 <elliott> FUZxxl: It will always be slow with Integer unless you bind to gmp
06:39:18 <elliott> FUZxxl: Sure, so do a binary search if bitSize is defined
06:39:28 <benmachine> FUZxxl: x & (x-1) is x with the lsb unset
06:39:48 <FUZxxl> elliott: I want to implement gauss-jordan-elimination for bit-matrices
06:40:30 <FUZxxl> I represent a matrix as a list of Integers... each integer is one line.
06:40:48 <FUZxxl> That's actually okay since most operations are easy....
06:40:51 <Phyx-> dcoutts: did it your way, ended up with the exact same error http://pastebin.com/SiNnSmuu
06:40:53 <mauke> The paste SiNnSmuu has been copied to http://hpaste.org/52319
06:41:01 <elliott> FUZxxl: Well, if you know the type, then you don't need to restrict yourself to what Bits has.
06:41:09 <FUZxxl> yes...
06:41:19 <FUZxxl> I just wondered why Bits don't has it....
06:41:24 <elliott> FUZxxl: The Bits instance couldn't do anything you couldn't write yourself, since it'd be written in Haskell. So you're guaranteed to be able to do as well as it would be in your ideal world.
06:41:33 <elliott> Well, I'd prefer a simple interface to a huge one.
06:41:47 <FUZxxl> it has so many things, so trivial is not that much of an excuse
06:41:58 <elliott> It doesn't have that many things, really.
06:42:39 <elliott> Especially not if you go by the minimal definitions.
06:42:53 <FUZxxl> elliottt: It has 17 or so functions.... that's prety much
06:44:14 <FUZxxl> elliottt: It has 17 or so functions.... that's pretty much
06:44:25 <elliott> I'm not the guy with three ts :-)
06:44:33 <FUZxxl> elliott: oops
06:44:42 <JoeyA> In Crypto.Cipher.RSA, what is the HashASN1 argument to sign and verify supposed to be?
06:44:44 <elliott> But you only actually have to define eight functions to get it going, the rest are just optimisations.
06:44:49 <JoeyA> ( http://hackage.haskell.org/packages/archive/cryptocipher/0.2.14/doc/html/Crypto-Cipher-RSA.html )
06:44:52 <FUZxxl> Something else: popcount is easy to implement efficiently if you know the wordsize.
06:45:11 <elliott> That's why bitSize is there :P
06:45:24 <elliott> It works for anything you can give a meaningful size to, so...
06:45:26 <FUZxxl> elliottt: It's undefined for Integer
06:45:37 <elliott> FUZxxl: Integers do not have a bit width.
06:45:43 <FUZxxl> I know
06:45:53 <elliott> FUZxxl: So you can't use your popcount strategy.
06:46:07 <FUZxxl> :i Integer
06:46:13 <FUZxxl> > :i Integer
06:46:14 <lambdabot>   <no location info>: parse error on input `:'
06:46:19 <FUZxxl> @i Integer
06:46:19 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
06:46:24 <elliott> @info Integer
06:46:25 <lambdabot> Integer
06:46:27 <elliott> @src Integer
06:46:27 <FUZxxl> @info Integer
06:46:27 <lambdabot> data Integer = S# Int#
06:46:27 <lambdabot>              | J# Int# ByteArray#
06:46:28 <lambdabot> Integer
06:46:34 <FUZxxl> okay
06:46:39 <elliott> It's a bignum
06:47:10 <FUZxxl> You could still calculate it in O(n), but much better than with your approach that counts every bit.
06:47:34 <FUZxxl> You could decompose it into 64 bit chunks and calculate their popcounts separatly.
06:47:40 <FUZxxl> Then sum...
06:47:41 <elliott> That's a constant-factor optimisation.
06:47:51 <FUZxxl> should be quite good for that purpose
06:47:59 <dcoutts> Phyx-: I think you need to link in the rts
06:48:28 <FUZxxl> elliott: Better than nothing. For my application I need an efficient determination of the least significant byte set...
06:48:40 <FUZxxl> Or maybe my implementation of the algorithm is flawed
06:49:17 <elliott> FUZxxl: Well, constant-factor microoptimisations tend to require knowledge of the type in question, so I wouldn't expect it to be part of a generic interface :-)
06:49:50 <elliott> FUZxxl: But you can split into sixty-four bit chunks with Num or Integral, I should think.
06:50:02 <elliott> Actually doing it directly on the gmp representation will be really painful and non-portable to integer-simple.
06:50:44 <FUZxxl> yeah
06:50:53 <kmc> meh, nobody uses integer-simple
06:50:57 <kmc> but the "really painful" part, yes
06:51:05 <FUZxxl> That's why I'd appreciate it to have such a function in the Bits interface or so
06:51:06 <elliott> Don't the iPhone guys?
06:51:08 <kmc> you'll have to deal with ghc's hacked version of gmp
06:51:14 <FUZxxl> Maybe there is something on hackage
06:51:27 <FUZxxl> @todo
06:51:27 <lambdabot> 0. SamB: A way to get multiple results from a google search
06:51:28 <lambdabot> 1. dons: improve formatting of @dict
06:51:28 <lambdabot> 2. dons: write Haskell Manifesto
06:51:28 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
06:51:28 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
06:51:29 <lambdabot> [31 @more lines]
06:51:30 <elliott> FUZxxl: Specialised purposes like that don't really belong in simple generic interfaces, I wouldn't think
06:51:38 <FUZxxl> @help todo
06:51:38 <lambdabot> todo. List todo entries
06:51:39 <Phyx-> dcoutts: i'll try
06:51:41 <dcoutts> kmc: ghc doesn't have a hacked version of gmp
06:51:51 <dcoutts> kmc: but it might be easier if it did
06:51:54 <elliott> FUZxxl: Especially since you basically have fast implementations for Int, and Integer, and nothing else will have a particularly fast way to do it because they'll be screwy :)
06:51:57 <kmc> well it hooks gmp to use a custom allocator
06:52:04 <kmc> it also ships with, builds, and links its own copy of gmp
06:52:07 <kmc> but i guess it's a stock tarball
06:52:11 <dcoutts> right
06:52:24 <elliott> FUZxxl: Have you considered just using Vector Bool or whatever?
06:52:36 <FUZxxl> @more
06:52:43 <elliott> kmc: gmp actually has official support for custom allocators in the api
06:52:44 <dcoutts> kmc: I blame gmp though, it provides an interface that makes it impossible to use by multiple clients
06:52:51 <FUZxxl> elliott:
06:53:00 <kmc> *nod*
06:53:04 <dcoutts> elliott: right, it's just not a good api
06:53:24 <elliott> dcoutts: You could say that about gmp in general.
06:53:32 <elliott> (OK, it's certainly very /complete/...)
06:53:38 <FUZxxl> elliott: Yes... But I also need fast XOR between two rows.
06:53:38 <dcoutts> oh the rest of it is ok as far as C apis go
06:53:49 <elliott> FUZxxl: That's just a zip.
06:53:55 <elliott> FUZxxl: You could even use repa and get MOAR PARALLELISM.
06:54:01 <FUZxxl> elliott: :D
06:54:13 <FUZxxl> Na...
06:54:21 <elliott> FUZxxl: I guess it's probably still not as fast as a vector of Ints, though.
06:54:28 <elliott> FUZxxl: I don't think you want Integer, though.
06:54:32 <FUZxxl> The Algorithm does O(n³) XOR operations...
06:54:51 <elliott> FUZxxl: Something like (Vector Word) sounds like a much more reasonable array-of-bits-with-efficient-xor-and-the-like representation.
06:54:51 <FUZxxl> I use Integer as a primitive BitSet
06:55:04 <elliott> Or at least I would think gmp is optimised for arithmetic, not bit twiddling.
06:55:44 <Axman6> agreed
06:56:25 <dcoutts> FUZxxl: or you could try UArray Bool, it's represented as a bitarray
06:56:27 <FUZxxl> elliottt: Hm... If the representation is a flat array, efficient bit-fiddling is not that much a problem
06:56:41 <elliott> dcoutts: Yeah, but then he'd have to use the array interface.
06:56:59 <FUZxxl> dcoutts: Does it support XORing two rows using 32bit XOR operations?
06:57:01 <elliott> FUZxxl: How many bits are you dealing with in one of these?
06:57:15 <FUZxxl> elliott: I don't know... Maybe 100 or so
06:57:31 <FUZxxl> It's kind of a competition.
06:57:31 <elliott> FUZxxl: Oh. Hell, you could just use a tuple.
06:57:32 <Axman6> > xor True False
06:57:33 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
06:57:33 <lambdabot>    arising from a use of `Da...
06:57:42 <elliott> That's, what, four Ints on a thirty-two bit platform?
06:57:43 <dcoutts> FUZxxl: not conveniently, you'd have to cast it to a UArray Word32
06:57:44 <FUZxxl> I don't know what input they will feed into my program.
06:57:48 <Axman6> > True != False
06:57:49 <lambdabot>   Not in scope: `!='
06:57:53 <Axman6> > True /= False
06:57:54 <lambdabot>   True
06:58:19 <elliott> FUZxxl: Well, the advantage of (Vector Word) is (a) no signedness issues, and (b) you can easily and efficiently get its size to do binary searching.
06:58:19 <Axman6> > liftM2 (/=) [True,False] [True,False]
06:58:20 <lambdabot>   [False,True,True,False]
06:58:24 <FUZxxl> elliottt: Yes... ALso thought about that...
06:58:39 <elliott> Poor elliottt, getting all these nickpings.
06:59:04 <Phyx-> dcoutts: http://pastebin.com/98smBfg8 after trying to link the rts aswell
06:59:05 <mauke> The paste 98smBfg8 has been copied to http://hpaste.org/52320
07:00:15 <dcoutts> Phyx-: ah, excellent, it works. So all you need to do is to link in all those libs. -package rts -package base etc should work
07:01:19 <dcoutts> Phyx-: though you might have a problem with the ffi lib, you might not have compiled that with -fPIC
07:01:45 <dcoutts> Phyx-: it gets built as part of ghc, but it uses its own build system, so not sure if your mk/build.mk hacking will have worked.
07:01:47 <FUZxxl> elliott: The problem is that the task states that my cose must work with arbitrary many bits
07:02:09 <FUZxxl> elliott: The problem is that the task states that my code must work with arbitrary many bits
07:02:27 <elliott> FUZxxl: Sure, and a Vector can hold an arbitrary number of Words.
07:02:41 <elliott> I dunno, it definitely seems more suitable than an Integer because it has a size that's readily accessible without, like, taking the log.
07:02:46 <FUZxxl> elliott: Yes.
07:03:19 <FUZxxl> elliottt: I don't really need to know the size of the Integer since I know that only bytes 0 to n may be set...
07:03:48 <elliott> Fair enough
07:03:57 <FUZxxl> Maybe I just use your O(n) approach and think of Knuth's quote about premature optimization...
07:04:13 <Phyx-> dcoutts: what works? I got a relocation error in both cases. Hm.. I'll have to find out where it's build then
07:04:44 <elliott> FUZxxl: You might be irritated to hear that gmp has native popcount support.
07:05:18 <elliott> Based on machine instructions for it, looks like.
07:05:42 <dcoutts> Phyx-: the error about a relocation in Hs2lib.o went away
07:06:19 <Phyx-> dcoutts: true
07:06:20 <FUZxxl> elliott: ?!?
07:06:36 <FUZxxl> elliottt: Is it available for the Haskell port?
07:06:44 <jmcarthur> it would be nice if Vector Bool was packed
07:06:44 <FUZxxl> I mean for the Haskell binding
07:06:49 <dcoutts> Phyx-: because instead of it being an external reference to a symbol not in the shared lib, the symbol is now resolved against the definition in the rts that is now linked in.
07:06:53 <elliott> FUZxxl: Doesn't look like it.
07:07:03 <jmcarthur> with rewrite rules for various vector operations
07:07:12 <elliott> I don't support you can just foreign import gmp functions and use them with Integers?
07:07:20 <elliott> I know there's a lot of troubles with other libraries using gmp but I dunno if you can do that.
07:07:25 <dcoutts> Phyx-: and so the fact that it's an absolute relocation does not matter, because it's resolved within the same DSO
07:08:00 <dcoutts> Phyx-: which is exactly what you're trying to do. That's why you're not compiling using -dynamic.
07:08:56 <Phyx-> dcoutts: guess I'll go find where the ffi lib is build.
07:09:39 <Phyx-> It seems rather complicated to get the right version of everything build. In contrast to building the shared libs on windows though
07:09:48 <dcoutts> Phyx-: lemme know how it goes. I've never seen people actually build like this before, so I'll be interested to see how it goes.
07:10:10 <Phyx-> dcoutts: will do
07:10:41 <dcoutts> Phyx-: that's because the expectation on linux is that you actually want to build each package as a separate .so lib. On windows historically it couldn't do that, so the only option was to link everything into one massive .dll
07:11:55 <FUZxxl> jmcarthur: That would be a good project for an actually useful library.
07:13:06 <Phyx-> dcoutts: hmm ok
07:13:58 <elliott> FUZxxl: It sounds like what we really need is just better gmp support.
07:14:16 <elliott> These implementations are pretty ridiculously optimised.
07:14:35 <jmcarthur> or an optimizer that makes native haskell code competitive with it :D
07:14:41 <jmcarthur> (unlikely)
07:15:53 <FUZxxl> jmcarthur: There is LLVM... that can happen any time.
07:16:15 <elliott> FUZxxl: Considering these gmp functions are all hand-written assembly...
07:16:22 <FUZxxl> elliott: ?!?
07:16:30 <FUZxxl> elliottt: o.O
07:16:42 <elliott> (With C fallbacks.)
07:16:56 <elliott> FUZxxl: gmp is the fastest bignum library AFAIK
07:17:03 <FUZxxl> elliott: okay... that's kind od ... crazy
07:17:06 <elliott> I didn't expect its bit-twiddling stuff to be as heavily optimised as the rest of it but turns out I was wrong
07:17:08 <FUZxxl> elliott: okay... that's kind of ... crazy
07:17:17 <JoeyA> In cryptohash, why are the hash types (e.g. SHA1, MD5) opaque, rather than exporting their data constructors?  Currently, if I want to use Crypto.HMAC in crypto-api, I can't get at the digest...
07:17:29 <FUZxxl> elliott: How do you come to this conclusion?
07:17:34 <JoeyA> (though it does have a Serialize instance)
07:17:37 <elliott> FUZxxl: Which conclusion?
07:17:48 <FUZxxl> »I didn't expect its bit-twiddling stuff to be as heavily optimised as the rest of it but turns out I was wrong«
07:18:00 <elliott> FUZxxl: I downloaded the code and looked at it.
07:18:10 <FUZxxl> elliott: Okay...
07:18:20 <elliott> FUZxxl: If that's not the result of heavy optimisation and asm twiddling it's the result of someone trying really hard to make it look like it is :-)
07:18:34 <FUZxxl> Is there assembly only for x86 or also for ARM and friends?
07:18:48 <FUZxxl> elliott: yeah...
07:19:02 <elliott> Didn't look at every platform but there's definitely more than x86 there. I think I saw a mention of Cray in comments.
07:19:16 <elliott> Anyone run Haskell on Crays?
07:19:23 <elliott> Proper Crays, before they started shipping Intel.
07:19:27 <Ke> cray produces mostly x86 I bet
07:19:29 <FUZxxl> elliott: No...
07:19:34 <Ke> =oP
07:19:47 <elliott> Ke: Yeah, but that doesn't need asm specialcasing, so this was the old Crays :-)
07:26:26 <FUZxxl> Is there a GHC.* package that exposes additional functionality of GMP?
07:26:41 <elliott> ISTR that adding another gmp intrinsic is a pain.
07:27:14 <dcoutts> FUZxxl: yes, see the integer-gmp package
07:27:22 <elliott> dcoutts: does it expose popcount? :p
07:27:26 <dcoutts> that's everything that's bound
07:28:18 <dcoutts> you can send in a patch to integer-gmp
07:28:54 <FUZxxl> Where is the doc?
07:29:25 * Phyx- sits and watches ghc build
07:30:05 <dcoutts> FUZxxl: look at the source
07:31:04 <FUZxxl> haha
07:31:13 <elliott> Source is my favourite kind of doc.
07:31:42 <Phyx-> hah, make -j is actually working
07:31:48 <Phantom_Hoover> JaffaCake, you are named after a bad thing you are bad.
07:32:17 <FUZxxl> Phyx-: Uuhh... But never forgot the number after it...
07:36:02 <Phyx-> FUZxxl: doesn't it default to one per core or something without the number?
07:36:32 <elliott> Phyx-: It defaults to no limit.
07:36:54 <elliott> Phyx-: Sound the alarm, you're going to be UNCOMFORTABLY PARALLEL. (http://www.youtube.com/watch?v=1yH_j8-VVLo)
07:38:08 <Phyx-> elliott: oh, I did not know that. Though I rarely use make :P learn something enw everyday
07:38:33 <Phyx-> and rofl at link
07:38:54 <FUZxxl> Phyx-: It freezed my computer so fast, I couldn't even use Alt-SysRq-B
07:39:11 <Phyx-> oh mine i still going fine
07:40:07 <hpc> elliott: lol
07:40:11 <Phyx-> hmm for some reason, i notice subtile flickering when i'm in linux
07:40:15 <Phyx-> drivers must be borked
07:40:32 <Phyx-> screen flickering, brightness
07:40:42 <JoeyA> Alt-SysRq-B actually does something these days?
07:40:48 <JoeyA> (watch, I'll ping out)
07:40:57 <FUZxxl> JoeyA: It reboots the computer
07:41:05 <FUZxxl> Or something like that
07:41:17 <FUZxxl> without unmounting disks and cleaning up
07:41:29 <elliott> JoeyA: Well, it's the last step of REISUB...
07:41:32 <FUZxxl> It's similiar to pressing the RESET button
07:41:35 <Phyx-> that the linux three fingers salute?
07:41:38 <elliott> So it does something quite drastic indeed :-)
07:41:49 <elliott> Phyx-: Only if you're really irresponsible.
07:41:55 <Phyx-> lol
07:42:13 <mauke> what's REI?
07:42:26 <elliott> mauke: the first half of REISUB
07:42:33 <mauke> ...
07:42:37 <Phyx-> ...
07:42:47 <mauke> I know SUB is sync, umout, boot
07:42:50 <mauke> *umount
07:43:08 <cicatristeza> hello, i want to take some user input on a webpage, and draw some svgs based on that input. how would you suggest i go about doing this?
07:43:21 <FUZxxl> > ma (\c -> printf "[Alt] + [SysRq] + [%c]" c) "REISUB"
07:43:22 <lambdabot>   Not in scope: `ma'
07:43:24 <mauke> cicatristeza: I'd write a program
07:43:28 <FUZxxl> > map (\c -> printf "[Alt] + [SysRq] + [%c]" c) "REISUB"
07:43:29 <lambdabot>   Ambiguous type variable `b' in the constraints:
07:43:30 <lambdabot>    `GHC.Show.Show b'
07:43:30 <lambdabot>      a...
07:44:12 <cicatristeza> mauke: thanks that was extremely helpful. how would yo uimplement it in haskell? what packages? what framework?
07:44:12 <FUZxxl> > putStr $ map (\c -> printf "[Alt] + [SysRq] + [%c]\n" c) "REISUB"
07:44:13 <lambdabot>   No instance for (Text.Printf.PrintfType GHC.Types.Char)
07:44:14 <lambdabot>    arising from a u...
07:44:24 <FUZxxl> Ah screw it..
07:44:27 <mauke> cicatristeza: I wouldn't use Haskell
07:44:42 <FUZxxl> cicatristeza: Try cairo
07:45:06 <FUZxxl> Or just output SVG code using printf
07:45:13 <Axman6> cicatristeza: you should have a loot at haskell for kids, it's almost exactly what you've described
07:45:17 <Axman6> look*
07:45:29 <Axman6> FUZxxl: that is a horrible idea
07:45:29 <cicatristeza> mauke: why
07:45:46 <FUZxxl> Axman6: I know
07:46:02 <Axman6> cicatristeza: http://cdsmith.wordpress.com/2011/08/15/haskell-for-kids-web-based-environment-goes-public/
07:46:03 <cicatristeza> why is that a bad idea
07:46:54 <Axman6> because there are infinitely better ways to prduce structured text like SVG
07:47:03 <cicatristeza> Axman6: for example
07:47:08 <Axman6> than printf*
07:47:21 <Axman6> well, for one, there's the blaze framework for outputting HTML
07:47:25 <kmc> cicatristeza, popular Haskell web frameworks include happstack, snap, and yesod
07:47:34 <kmc> doesn't blaze do xml too
07:47:43 <benmachine> http://hackage.haskell.org/package/ there seem to be a lot of svg-related things here, although I'm not sure which are good
07:47:45 <Axman6> probably
07:47:53 <cicatristeza> which framework comes with the least headache
07:47:59 <cicatristeza> and which is the fastest
07:48:12 <Axman6> they're all pretty damn fast
07:48:47 <Axman6> thousands of requests served per second on an average desktop is certainly not unheard of
07:49:17 <alpounet> :t accumArray
07:49:18 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
07:50:01 <cicatristeza> pardon my ignorance, but to setup a web framework, do i need haskell installed on my server?
07:50:11 <cicatristeza> i mean the haskel-platform
07:50:30 <kmc> no, you can compile your code on another machine and copy the binaries over
07:50:33 <hpc> cicatristeza: you don't need the platform, but it helps
07:50:47 <hpc> (develop on the same machine you run on, etc)
07:51:07 <alpounet> cicatristeza, you'llneed it to build your code, so more generally for the development
07:51:14 <cicatristeza> i mean can i develop on my archlinux machine, and then dump the inaries on my freebsd server sitting somewhere else?
07:51:25 <cicatristeza> *binaries
07:51:27 <dcoutts> cicatristeza: yes
07:51:28 <dschoepe> Is it generally a good idea to give your functions the type "MonadIO m => .. -> m a" instead of ".. -> IO a" even if, at the moment, they will always be run where m = IO?
07:51:39 <cicatristeza> thank you all
07:51:50 <Axman6> cicatristeza: possibly, but it will rely on FreeBSD's linux compat
07:52:00 <hpc> dschoepe: i don't, mainly because i can just liftIO it if i need to
07:52:04 <cicatristeza> Axman6: i understand a bit better now
07:52:09 <elliott> cicatristeza: you'll want a cross compiler probably
07:52:36 <hpc> if i know exactly what 'm' i want to lift into, i will usually liftIO and give it a specific type signature
07:53:16 <kmc> dschoepe, I usually don't
07:53:36 <kmc> generalizing the type means you can't use e.g. threads or exceptions
07:53:42 <kmc> that might be a good thing, depending on context
07:53:59 <elliott> well, you can, just those force you back into IO land
07:54:21 <dschoepe> Yes, trying to use exceptions is where I run into problems and made me question the point of lifting everything preemptively
07:54:28 <kmc> the code which is polymorphic over all MonadIO cannot use forkIO or catch
07:54:30 <dschoepe> *where I ran
07:54:36 <elliott> Complicated monad transformer stacks are a bad idea anyway; especially ones with IO at the bottom.
07:54:38 <kmc> or other useful functions-on-IO-actions
07:54:40 <kmc> *nod*
07:54:46 <kmc> ContT IO is the One True Monad :D
07:54:55 <elliott> There are things like MonadControlIO or whatever for doing exceptions but ehh.
07:55:03 <elliott> kmc: I sometimes wish IO came with a free Reader :)
07:55:14 <elliott> ... except lexically scoped somehow.
07:55:17 <hpc> dschoepe: when i have to deal with exceptions, i put 'catch' in the definition of (>>=) and lift over Either
07:55:43 <dschoepe> hpc: Ah, thanks
07:56:13 <hpc> for instance, the monad for my website is:
07:56:14 <hpc> newtype CGI a = CGI {runCGI :: CGIData -> IO (Either String (a, CGIData))}
07:56:26 <dschoepe> elliott, hpc, kmc: thanks for your answers, I guess I'll lift it when I actually need to.
07:56:49 <elliott> hpc: Is there any advantage to the Either there over IO's exception handling?
07:57:09 <hpc> elliott: i don't have to throw my own excepions, and i can use fail in a non-bullshit way
07:57:26 <elliott> That Either has about as much overhead as defining your own exception type :-)
07:57:38 <hpc> it "puts everything in one place" so to speak
07:58:13 <erus`> why isnt cabal in the platform?
07:58:21 <kmc> it is
07:58:40 <erus`> i had to download the binary on windows :|
07:58:54 <kmc> hmm i have not used Platform on Windows
07:58:56 <elliott> you have PATH issues
07:59:05 <kmc> but it's specified as coming with Cabal 1.10.1.0 and cabal-install 0.10.2
07:59:14 <hpc> i tried to use the platform on windows and had a lt of problems with just getting it to install
07:59:15 <elliott> it does. path issues :P
07:59:29 <cicatristeza> is there a haskell syntax lookup?
07:59:41 <kmc> @google haskell cheat sheet
07:59:43 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
07:59:44 <lambdabot> Title: Haskell Cheat Sheet
08:02:07 <cicatristeza> thanks
08:02:34 <elliott> Is there any convenient preexisting library that offers a forkIO where the thread is killed whenever its parent thread dies?
08:03:01 * JuanDaugherty 's statement that "most people are stupid" elicited a strong negative reaction a channel for a program by the lead programmer. I wonder what reaction it would get here?
08:03:44 <JuanDaugherty> *in a channel (#taskwarrior)
08:04:10 <azorius> Greetings
08:04:11 <cicatristeza> most people are ignorant
08:04:12 <JuanDaugherty> elliott, you mean somekina zombie clean up I take it as you've said the thread was dead
08:04:22 <elliott> JuanDaugherty: What?
08:04:41 <elliott> I just mean that when the thread that the forkIO was run in dies, the forkIO'd thread dies automatically.
08:04:43 <JuanDaugherty> and normally zombie state only applies at the process level
08:04:57 <elliott> Haskell's threads are lightweight, the OS' idea of processes doesn't matter.
08:04:57 <JuanDaugherty> and processes are the things that a forked
08:05:10 <elliott> JuanDaugherty: Are you unfamiliar with Haskell's concurrency support?
08:05:27 <elliott> JuanDaugherty: See Control.Concurrent.forkIO for what I'm talking about
08:05:36 <alpounet> hah
08:05:42 <JuanDaugherty> no, not really but I'm very familiar with the things it must be based on
08:06:06 <elliott> Well, they're lightweight threads, so I don't see how the concept of zombie processes matters.
08:06:59 <JuanDaugherty> in general, regardless of the lang, whatever, when the containing task construct dies, so do all it's lowever level subconstruct children
08:07:14 <JuanDaugherty> if haskell doesn't do the same I'll be surprised
08:07:25 <kmc> it doesn't
08:07:31 <kmc> UNIX doesn't either
08:07:44 <dschoepe> I don't think forkIO-threads are in any kind of parent-child-relation anyway.
08:07:51 <JuanDaugherty> the same level spawning an independent runner is different
08:08:05 <kmc> ok, well then all GHC has are "independent runners"
08:08:11 <elliott> Prelude Control.Concurrent> forkIO (forkIO (threadDelay 1000000 >> putStrLn "hi") >> return ())
08:08:12 <elliott> ThreadId 194
08:08:13 <elliott> [one second pause[
08:08:14 <elliott> hi
08:08:16 <elliott> JuanDaugherty: So no, it doesn't.
08:08:34 <kmc> however when the 'main' thread exits, the whole program dies
08:08:38 <kmc> even if t here are other live threads
08:10:07 <elliott> I guess I might want some kind of kill-switch MVar per thread instead.
08:10:15 <elliott> Or maybe something with TVar so I only need one of them.
08:11:40 <JuanDaugherty> cicatristeza, yes, I was referring to the kind that is the result of willful ignorance, not the other kind
08:12:19 <JuanDaugherty> *are forked
08:13:09 <cicatristeza> juan: what is your point my friend
08:14:18 <JuanDaugherty> in re stupdity or task constructs?
08:14:34 <JuanDaugherty> *stupidity
08:14:57 <JuanDaugherty> on the former there was a query, no point
08:15:10 <kmc> I don't know how to register an action to run when a thread dies
08:15:15 <kmc> maybe you can play some games with finalizers
08:15:22 <elliott> kmc: Yeah, I wanted that for another thing earlier too.
08:15:32 <elliott> kmc: Obviously you can just wrap the rest of the code in a "finally", but...
08:15:52 <elliott> Maybe I just need to twiddle with my design if nobody has found the lack of those particularly problematic before.
08:17:23 <JuanDaugherty> the point made on the latter could be useful if haskell has thread groups
08:17:45 <robert[]> does anyon know the De Bruijn incidecs
08:17:56 <robert[]> data L = Var Nat | App L L | Lam L
08:18:09 <elliott> Plenty of people  do.
08:18:12 <robert[]> I need beta substition on it
08:18:23 <robert[]> I've been wokring on it 3 days and I cant get it
08:18:34 <kmc> elliott, i guess you do it by wrapping forkIO
08:18:47 <Saizan> i'd go with data L n where Var :: Fin n -> L n; App :: L n -> L n -> L n; Lam :: L (suc n) -> L n
08:18:54 <elliott> kmc: yeah
08:19:24 <robert[]> substitute :: L -> L -> L
08:19:34 <robert[]> wait
08:19:36 <Saizan> and i'd define substitution for all the variables at once
08:19:38 <robert[]> substitute :: L -> L -> Nat -> L
08:19:56 <Saizan> substitute :: L n -> (Fin n -> L m) -> L m
08:21:07 <Saizan> given data Fin n where FZero :: Fin (Suc n); FSuc :: Fin n -> Fin (Suc n)
08:21:43 <jorrik> floor (1/0)
08:21:46 <jorrik> what gives?
08:21:55 <Saizan> > floor (1/0)
08:21:56 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:22:00 <elliott> wow
08:22:11 <elliott> > floor (1/0 :: Float)
08:22:12 <lambdabot>   340282366920938463463374607431768211456
08:22:15 <elliott> > floor (1/0 :: Double)
08:22:15 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:22:17 <elliott> neat
08:22:43 <jorrik> > ceiling (1/0)
08:22:44 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:22:51 <jorrik> > 2^2^10
08:22:52 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:23:25 <jorrik> > (2^2^10) == (1/0)
08:23:26 <lambdabot>   True
08:23:33 <jorrik> LMAO
08:23:50 <benmachine> er
08:23:57 <benmachine> that'll be Infinity = Infinity
08:24:05 <benmachine> because 1/0 will type-default to Float
08:24:11 <Saizan> robert[]: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.1516 <- this is a nice paper per se, but it's also good as a treatment of substitution
08:24:15 <benmachine> > (2^2^10) == (2^2^11)
08:24:16 <lambdabot>   False
08:24:19 <benmachine> > (2^2^12) == (2^2^11)
08:24:20 <lambdabot>   False
08:24:24 <benmachine> oh, huh
08:24:28 <benmachine> oh, duh
08:24:35 <benmachine> > (2^2^12) == (2^2^11 :: Double)
08:24:36 <lambdabot>   True
08:24:39 <kmc> > (2^2^12) == (2^2^11) * 1.0
08:24:40 <lambdabot>   True
08:24:46 <robert[]> thanks
08:25:12 <Saizan> ..assuming you're ok with dependent types :)
08:25:42 <jorrik> > (2^2^2^5) == (2/0)
08:25:43 <lambdabot>   True
08:26:24 <Saizan> robert[]: ah, sorry, those terms don't contain lambdas so it doesn't show the most interesting part
08:26:59 <robert[]> I awant to use L
08:27:03 <robert[]> not L n
08:27:20 <robert[]> but if you define it for L n you can erase it to L so it doesn't matter
08:27:22 <elliott> L isn't statically guaranteed to be a valid LC term.
08:27:22 <elliott> :(
08:27:33 <Saizan> yeah, i'll paste how i'd do it
08:27:34 <elliott> Well, it matters, you can't erase L to L n :P
08:28:17 <jorrik> so what's the special thing about 2^2^10 ?
08:28:28 <robert[]> static guaratnees are  undecidable or (with full fleged theoremk proving) impractical
08:29:16 <kmc> jorrik, just that it's huge
08:29:19 <elliott> robert[]: uh, not the static guarantee that Saizan's L n gives you.
08:29:21 <kmc> too big for Double to represent
08:29:37 <elliott> robert[]: are you really saying that all static guarantees are impractical? because that's what a type system is :-)
08:29:57 <kmc> "them's fightin' words 'round here"
08:30:39 <jorrik> kmc: but in ghci i can type 2^2^12 and it stil gives me results, is it using a different type than double?
08:30:47 <kmc> yes
08:30:51 <mauke> > 2^2^12
08:30:52 <lambdabot>   104438888141315250669175271071662438257996424904738378038423348328395390797...
08:30:53 <kmc> :t (2^2^12)
08:30:53 <lambdabot> forall t. (Num t) => t
08:30:58 <elliott> jorrik: defaults to Integer
08:31:03 <elliott> Double only comes in because you use (/)
08:31:11 <kmc> :t (2^2^12) * (1/2)
08:31:11 <lambdabot> forall t. (Fractional t) => t
08:31:29 <kmc> that's the difference
08:31:33 <jmcarthur> defaulting can be surprising
08:31:41 <jmcarthur> i am not a fan of it
08:31:42 <jorrik> so Num==Integer and Fraction==Double?
08:31:53 <jorrik> Fractional*
08:31:54 <kmc> not that simple
08:31:59 <kmc> Num is a constraint on types
08:32:08 <kmc> it's an interface satisfied by Integer, Double, Int, etc.
08:32:23 <kmc> but Haskell has some ad-hoc rules that come into play when you don't specify which particular numeric type you want
08:32:25 <jorrik> how do i see a list of types satisfied by a constraint?
08:32:29 <jmcarthur> there is a warning for defaulting that you can enable, but i wish i could just remove it from the language
08:32:33 <kmc> :i num
08:32:53 <kmc> they're called "type classes" and a Haskell tutorial will cover them
08:33:04 <kmc> jmcarthur, you can put "default ()" in your file
08:33:08 <jorrik> > :i Nomad
08:33:09 <lambdabot>   <no location info>: parse error on input `:'
08:33:15 <jmcarthur> yeah but that's a hack
08:33:18 <jorrik> :i Nomad
08:33:21 <kmc> jorrik, in ghci
08:33:28 <jmcarthur> requires me to remember to do it
08:34:05 <kmc> programming without defaulting can be annoying
08:34:07 <jorrik> okay so what cool typeclasses should I bother with?
08:34:18 <kmc> simple things like (^5) become ambiguous
08:34:21 <kmc> jorrik, that's a weird question ;P
08:34:23 * elliott uses -Werror and so doesn't get defaulting, never causes him problems
08:34:23 <robert[]> jorrik: VIP quality
08:34:27 <kmc> jorrik, pick a good Haskell tutorial and read it
08:35:27 <jmcarthur> my pov on (^5) is that it's written in an ambiguous way and defaulting just silently resolves it whether or not you intend for it to be Integer
08:35:49 <jmcarthur> although i might be willing to allow defaulting for literals only
08:35:59 <aristid> :t (^)
08:36:00 <jmcarthur> defaulting is more of a pain when it's variables
08:36:01 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
08:36:03 <kmc> *nod*
08:36:21 <kmc> i'd be fine with a lightweight syntax for type annotations on literal
08:36:27 <kmc> sort of like C's 2.0f
08:36:33 <jorrik> but there's so much tutorials out there... i'm serious... i want to know how to write down "idiomatic" haskell... using the vocab that everyone is using... all the tutorials i find are either simpler than monads or more difficult that "heliokataisoanamorhpismisms"
08:36:40 <kmc> jorrik, read LYAH
08:36:43 <jmcarthur> i like polymorphic literals by default though :)
08:36:50 <robert[]> read SICP
08:36:55 <jmcarthur> i also like OverloadedStrings and such
08:37:02 <kmc> jorrik, it has a chapter on monads
08:37:18 <kmc> jorrik, read LYAH and then RWH, or maybe the other way around if you like
08:37:25 <FUZxxl> Is there any language similiar to Haskell? I always have the impression, that Haskell is a unique language.
08:37:32 <elliott> kmc: RWH then LYAH would be... weird.
08:37:32 <jmcarthur> if you get through RWH i doubt LYAH will add much more
08:37:36 <elliott> FUZxxl: Clean is very similar.
08:37:39 <jorrik> i already read through RWH
08:37:49 <elliott> FUZxxl: Mercury is like Prolog designed by Haskell fanatics.
08:37:49 <kmc> jorrik, ok, then you should know about things like Num and Monad
08:37:56 <elliott> FUZxxl: And there's always OCaml and F# and the like.
08:38:11 <kmc> FUZxxl, there are some languages which are explicitly advertised as "Haskell dialects"
08:38:15 <kmc> like Habit and Disciple
08:38:22 <kmc> (well, I don't know if Disciple advertises itself that way)
08:38:30 <jmcarthur> FUZxxl: there aren't many. agda is a pretty natural direction from haskell, imo
08:38:31 <kmc> there's also Haskell's precursors, like Miranda and Lazy ML
08:38:45 <kmc> F# and OCaml are pretty distant all things considered
08:38:46 <aristid> jorrik: hackage has a lot of "real world" code, and some of it should be quite readable after you have finished rwh
08:38:59 <elliott> kmc: oh yeah, Disciple
08:39:00 <kmc> the measure of programming language distance is warped depending on what you know and use
08:39:09 * elliott thinks Clean is still the closest though
08:39:26 <kmc> to many programmers Haskell, Lisp, and OCaml are all indistinguishable points off in some weirdo FP land
08:39:38 <FUZxxl> kmc: Okay....
08:39:46 <FUZxxl> Maybe I should specify...
08:39:53 <kmc> conversely Haskell enthusiasts tend to treat Ruby, Python, and Javascript as more or less the same language
08:40:33 <jmcarthur> there are two languages. haskell and everything else
08:40:39 <FUZxxl> Is there any language that has laziness, purity, a sophisticated type system, (type classes), (nice syntax), etc
08:40:41 <Saizan> robert[]: http://hpaste.org/52322
08:40:50 <jmcarthur> FUZxxl: there are many
08:41:07 <robert[]> thanks
08:41:08 <FUZxxl> jmcarthur: Select those with more than 100 users
08:41:10 <jmcarthur> IMO, laziness is less critical than those other things
08:41:26 <kmc> FUZxxl, the way people talk about purity in Haskell emphasizes the wrong thing, imo.  the interesting thing isn't that Haskell enforces purity (which it doesn't very well) but that the standard libraries are designed to take pure code seriously
08:41:32 <jmcarthur> FUZxxl: that drops the numbers down quite a bit then ;)
08:41:41 <FUZxxl> ;-)
08:41:47 <FUZxxl> That's what I thought, too
08:41:56 <kmc> FUZxxl, you can model lazy data in most languages, and some even have special syntax for it, but few languages are lazy by default
08:42:06 <jmcarthur> i bet agda has >100 users
08:42:12 <jmcarthur> for some definition of "users"
08:42:15 <FUZxxl> jmcarthur: Of course
08:42:38 <kmc> #agda has 61 users
08:42:51 <jmcarthur> i bet less than 50% of agda users are in #agda
08:43:09 <benmachine> I bet not everyone in #agda is an agda user
08:43:14 <jmcarthur> touche
08:43:15 <erus`> how do i check my version of the haskell platform?
08:43:24 <elliott> <FUZxxl> Is there any language that has laziness, purity, a sophisticated type system, (type classes), (nice syntax), etc
08:43:27 <elliott> FUZxxl: Clean has all of those :P
08:43:29 <elliott> Well.
08:43:37 <monochrom> ghc-pkg list haskell-platform
08:43:38 <elliott> I don't like all its syntax differences from Haskell.
08:43:43 <kmc> one strange fact is that high-level languages with non-JIT native-code compilers tend to be "weirdo FP languages"
08:43:46 <kmc> i don't understand why
08:43:49 <jmcarthur> i'd still say clean fits the bill
08:44:01 <FUZxxl> Is it worth learning? (clean, agda)
08:44:08 <benmachine> kmc: you mean, it's weird that there's no compiled python?
08:44:10 <FUZxxl> I heard AGDA has dependant types
08:44:11 <jmcarthur> clean is so much like haskell that i'd say no
08:44:17 <benmachine> (or similar)
08:44:23 <jmcarthur> agda is crazy awesome if you are okay with academia
08:44:26 <benmachine> FUZxxl: you heard correctly
08:44:28 <kmc> you can go through a whole CS education and come away with the idea that all high-level languages run on JVM or .NET
08:44:37 <kmc> or have boring slow interpreters
08:44:42 <aristid> kmc: maybe because high-level OOP doesn't lend itself well to JIT?
08:44:46 <FUZxxl> jmcarthur: I love academia! Is there a good introduction / paper?
08:44:54 <aristid> kmc: maybe because high-level OOP doesn't lend itself well to native code compilation
08:44:55 <aristid> gah
08:44:59 <FUZxxl> I learned most of my Haskell from digesting papers
08:45:03 <kmc> aristid, I don't think that's true
08:45:12 <kmc> FUZxxl, www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
08:45:18 <jmcarthur> there's this one paper i forget the name of that motivates dependent types with three awesome use cases
08:45:18 <elliott> Saizan: Are you sure the type of subs- oh, you hpasted an implementation
08:45:28 <jmcarthur> i'll try to find it
08:45:34 <benmachine> kmc: does D count?
08:45:41 <kmc> aristid, it's probably more suited to ahead-of-time compilation than Haskell
08:45:43 <benmachine> not that I've ever actually used D
08:45:48 <kmc> benmachine, yes, but it's not very popular
08:45:52 <kmc> and you might never hear about it
08:46:55 <FUZxxl> There seems to be https://github.com/liamoc/learn-you-an-agda
08:47:12 <kmc> i couldn't figure out how to get LYAA in readable form
08:47:15 <kmc> do let me know if you figure it out
08:48:00 <FUZxxl> Wow...
08:48:08 <FUZxxl> Is agda written in Haskell?
08:48:12 <kmc> yes
08:48:24 <kmc> http://hackage.haskell.org/package/Agda
08:48:30 <FUZxxl> kmc: One more argument for learning it
08:48:40 <kmc> and Agda has a Haskell FFI
08:48:44 <kmc> much as Haskell has a C FFI
08:48:52 <hpaste_> erus` pasted “leksah help please” at http://hpaste.org/52324
08:48:54 <kmc> you can use Haskell's IO etc. from Agda
08:49:09 <FUZxxl> kmc: Great!
08:49:19 <jmcarthur> doesn't agda has a C FFI too, with the epic backend?
08:49:21 <FUZxxl> Is it an interpreted language?
08:49:23 <kmc> maybe
08:49:26 <kmc> FUZxxl, no such thing
08:49:27 <jmcarthur> FUZxxl: compiled
08:49:32 <Saizan> hah, i've a program where i need fancier types to increase sharing, otherwise i can't abstract over the right function
08:49:35 <jmcarthur> although the lines are blurred
08:49:46 <kmc> FUZxxl, any language can have both an interpreter and a compiler
08:50:02 <jmcarthur> FUZxxl: for dependent types, some interpretation may be necessary for compilation anyway
08:50:15 <kmc> FUZxxl, anyway, the standard Agda implementation can compile through Haskell or through this epic thing that I don't know anything about
08:50:21 <jmcarthur> depending on how you go about implementing the compiler, i guess...
08:50:40 <jmcarthur> dang i can't find this paper
08:51:10 <FUZxxl> kmc: I guess they meant Haskell with »epic thing«, because... well... Haskel IS epic
08:51:25 <kmc> ;P
08:52:09 <kmc> take that shit to reddit
08:52:31 <FUZxxl> I don't use reddit
08:55:18 <FUZxxl> Wow... I am at the page where they introduce the syntax and I can't stop thinking "wow, that awsome"
08:55:26 <hpaste_> elliott annotated “substitution” with “substitution (annotation)” at http://hpaste.org/52322#a52325
08:55:32 <elliott> Saizan: look what you've driven me to
09:01:39 <Saizan> elliott: you like folds so much?
09:01:46 <elliott> Saizan: Apparently.
09:02:20 <elliott> Saizan: Now I'm defining some newtype-package-esque typeclass trickery so I can avoid all that explicit wrapping/unwrapping of MapLC. What a waste of time :/
09:04:18 <jmcarthur> FUZxxl: http://www.cs.ru.nl/~wouters/Publications/ThePowerOfPi.pdf
09:05:18 <jmcarthur> FUZxxl: i like the above paper because it actually motivates dependent types pretty well with three fairly simple examples
09:05:27 <desaiu> from YAHT: "Infix functions are ones that are composed of symbols, rather than letters." Is that the exact definition?
09:05:28 <jmcarthur> practical ones
09:05:47 <jmcarthur> desaiu: the exact definition should be in the spec somewhere
09:06:17 <desaiu> jmcarthur: By the spec, do you mean Haskell 2010 report?
09:07:30 <jmcarthur> yes
09:08:04 <jmcarthur> deavid: "symbol" is defined here http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2
09:08:38 <jmcarthur> dang
09:08:50 <jmcarthur> desaiu left. apologies, deavid
09:16:39 <desaiu> Sorry about that
09:16:49 <desaiu> jmcarthur: By the spec, do you mean the 2010 report?
09:17:56 <gwern> @quote
09:17:56 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
09:18:28 <dmwit> Does that not need another unsafePerformIO there at the end?
09:20:12 <jmcarthur> :t peek
09:20:13 <lambdabot> Not in scope: `peek'
09:20:16 <jmcarthur> :t Foreign.peek
09:20:17 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
09:21:12 <jmcarthur> :t unsafePerformIO $ Foreign.peek . intPtrToPtr . fromIntegral =<< randomRIO (0, 2^32)
09:21:13 <lambdabot> Not in scope: `unsafePerformIO'
09:21:13 <lambdabot> Not in scope: `intPtrToPtr'
09:21:48 <jmcarthur> :t Unsafe.unsafePerformIO $ Foreign.peek . Foreign.intPtrToPtr . fromIntegral =<< randomRIO (0, 2^32)
09:21:49 <lambdabot> Couldn't find qualified module.
09:21:57 <elliott> jmcarthur: good luck with that
09:22:06 <jmcarthur> :t Unsafe.unsafePerformIO
09:22:07 <lambdabot> Couldn't find qualified module.
09:22:11 <jmcarthur> :(
09:22:24 <jmcarthur> i teh dum
09:22:32 <jmcarthur> :t System.IO.Unsafe.unsafePerformIO $ Foreign.peek . Foreign.intPtrToPtr . fromIntegral =<< randomRIO (0, 2^32)
09:22:33 <lambdabot> forall a. (Foreign.Storable.Storable a) => a
09:22:42 <jmcarthur> i was thinking Unsafe.Coerce
09:23:07 <desaiu> >infixr
09:23:11 <elliott> jmcarthur: it's in Unsafe.Coerce btw
09:23:14 <desaiu> > infixr
09:23:14 <elliott> right
09:23:15 <lambdabot>   <no location info>: parse error on input `infixr'
09:23:22 <elliott> desaiu: infixr is not a valid part of an expression.
09:23:30 <elliott> ...well, I guess in a let clause.
09:23:35 <jmcarthur> oh i didn't know it was in there
09:36:27 <desaiu> What's the poing of embedded block comments?
09:36:34 <desaiu> s/poing/point
09:36:52 <mauke> fear and suffering
09:36:54 <desaiu> I mean nested block commens
09:38:21 <kmc> desaiu, sometimes you want to comment out some code which contains a comment
09:38:46 <kmc> this *usually* works
09:38:46 <mauke> putStr "-}"
09:38:53 <kmc> i was about to say ;)
09:39:09 <mauke> "nested" comments add the additional failure case of putStr "{-"
09:39:16 <kmc> ocaml makes an opposite design decision here
09:39:25 <kmc> and people say the lexical syntax of multi-line comments is uninteresting
09:39:44 <kmc> in ocaml (* "*)" *) is a single valid comment, but (* " *) is invalid
09:39:55 <kmc> in other words even the contents of comments are lexed to some level
09:42:44 <erus`> > "{-"
09:42:45 <lambdabot>   "{-"
09:42:56 <erus`> > {- -} 1
09:42:58 <lambdabot>   1
09:43:09 <erus`> > {- "-}" "
09:43:09 <lambdabot>   " "
09:43:27 <elliott> Saizan: actually, I'm not convinced your substitute works at all... at least, afaict "substituteFirst (Lam (Var Fz)) x" == Lam (Var Fz) for all x
09:45:16 <mekeor> >
09:46:02 <elliott> >
09:48:27 <mekeor> > {-{--} 5
09:48:28 <lambdabot>   <no location info>: unterminated `{-'
09:48:38 <mekeor> > {--}
09:48:39 <lambdabot>   not an expression: `{--}'
09:48:47 <mekeor> > {- -}
09:48:47 <lambdabot>   not an expression: `{- -}'
09:48:54 <mekeor> > {--} 4
09:48:55 <lambdabot>   4
09:48:59 <mekeor> > {-{--} 4
09:49:00 <lambdabot>   <no location info>: unterminated `{-'
09:49:04 <MatrixFrog> comments nest in haskell:
09:49:14 <wavewave> hi
09:49:16 <mekeor> in C, they arent…
09:49:18 <mekeor> wavewave: hi
09:49:18 <MatrixFrog> > {- outer {- inner -} outer -} "hello world"
09:49:19 <lambdabot>   "hello world"
09:49:29 <MatrixFrog> haskell is the only language that does this, that i know of
09:49:31 <mekeor> MatrixFrog: cool. thanks
09:49:43 <MatrixFrog> (i'm sure there are others, just none that i've used)
09:50:09 <wavewave> mekeor: I complain all the time C does not have nested comment.
09:50:51 <gwern> @quote
09:50:52 <lambdabot> cwillu_at_work says: the novice has a data corruption problem, and says "I know, I'll use error correcting codes!".  He then has either no or two problems
09:51:19 <gwern> very true
09:51:20 <Guest87762> lol
09:51:33 <MatrixFrog> so if you say @quote without a name, it just picks a name at random?
09:51:34 <MatrixFrog> @quote
09:51:35 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
09:51:37 <MatrixFrog> nice
09:51:49 <wavewave> @quote
09:51:49 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
09:52:10 <monochrom> unsafeCoerce :: Madness -> b
09:52:11 <mauke> preflex: quote
09:52:17 <preflex>  <ndm> As always, the most useful thing in the error message is the line number.
09:52:25 <wavewave> how can i insert quote?
09:52:29 <mekeor> @quote
09:52:29 <lambdabot> b7j0c says: the haskell community should take out life insurance on dons
09:52:33 <mekeor> @quote
09:52:33 <lambdabot> cjs says: In what other language could I have learned so much about Win32 programming (summary: basically, the Windows 3.0 API but with all sorts of hacks to deal with having more than one thread in
09:52:33 <lambdabot> the system), and come out having *enjoyed* myself? Praise to the Lord!
09:52:34 <mekeor> @quote
09:52:34 <lambdabot> your_mom says: Will you stop telling dumb jokes about me
09:52:34 <mekeor> @quote
09:52:34 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:52:35 <parcs> that's not true
09:52:35 <mekeor> @quote
09:52:35 <lambdabot> lispy|web says: This curses binding appears to be terminally broken
09:52:43 <shepheb> you're highlighting lots of people.
09:53:02 <mekeor> oh, right, hehe :)
09:53:27 * mauke takes it to #haskell-blah
09:53:34 <monochrom> haha terminally
09:54:04 <kmc> :t filter ((>1) . length) . map snd . M.toList . foldr (\(v,k) -> M.insertWith (++) k [v]) M.empty
09:54:05 <lambdabot> forall a a1. (Ord a1) => [(a, a1)] -> [[a]]
09:55:01 <aristid> kmc: wtf? ((>1) . length)??
09:55:19 <kmc> yeah i'm aware you can do it more efficiently
09:55:25 <kmc> in this case the lists will be small
09:55:26 <kmc> and it's less code
09:55:31 <aristid> not . null . drop 2
09:55:38 <aristid> not . null . drop 1
09:55:49 <kmc> hmm, that's all right i guess
09:56:07 <kmc> thanks
09:56:27 <aristid> :)
09:56:32 * elliott wishes length :: [a] -> LazyNat
09:56:46 <parcs> :t genericLength
09:56:47 <lambdabot> forall b i. (Num i) => [b] -> i
09:56:51 <parcs> go wild :P
09:56:55 <elliott> parcs: ugly :P
09:57:01 <kmc> i use this «M.insertWith (++) k [v]» pattern a lot
09:57:04 <kmc> i wonder if there's a better way
09:57:04 <elliott> parcs: also doesn't work, does it
09:57:05 <aristid> elliott: just build it :)
09:57:07 <elliott> I thought genericLength used fromIntegral
09:57:12 <parcs> no
09:57:17 <aristid> elliott: no, genericLength is recursive
09:57:20 <elliott> oh, cool
09:57:21 <parcs> it's exactly the same definition as length
09:57:25 <parcs> just more general
09:57:34 <parcs> its type is*
09:57:35 <elliott> now can we replace all the Prelude versions with their generic equivalents?
09:57:47 <kmc> you can make an alternative Prelude
09:57:49 <aristid> kmc: maybe build a Multimap wrapper around Map to deal with that more conveniently?
09:57:53 <kmc> and then advocate loudly here for it
09:58:00 <kmc> aristid, yeah
09:58:05 <kmc> in fact i bet such a thing exists already
09:58:08 <Saizan> uh, genericLength is a foldl? i thought it was a foldr
09:58:09 <kmc> but hackage is too damn crowded to find anything
09:58:21 <aristid> kmc: good problem to have :)
09:58:22 <mauke> @src genericLength
09:58:22 <lambdabot> genericLength []    = 0
09:58:22 <lambdabot> genericLength (_:l) = 1 + genericLength l
09:58:22 <kmc> the lazy version would only work with a foldr
09:58:29 <kmc> aristid, yeah, but still a problem ;)
09:58:53 <aristid> kmc: lisp never had this problem, even in its heyday :D
09:59:21 <kmc> i'd have to think pretty hard to get it right
09:59:22 <elliott> It surprises me that there's no lazy Peano natural tpe on Hackage.
09:59:23 <elliott> type
09:59:26 <elliott> That I can find.
09:59:29 <elliott> I guess it's just too obvious ;-)
09:59:37 <elliott> Maybe I'll write one so I don't have to keep writing compareLength functions.
10:00:08 <kmc> sometimes i want Map k [v], sometimes Map k (Set v)
10:00:11 <kmc> probably sometimes Map k (Seq v)
10:00:38 <wavewave> elliott: lazy natural number has lazy (+)?
10:00:45 <kmc> yep
10:00:46 <elliott> wavewave: Naturally.
10:00:49 <elliott> Oh, wow.
10:00:51 <elliott> That was not even intentional.
10:01:04 <kmc> Natural ~ [()],  (+) = (++)
10:01:10 <kmc> not really isomorphic but good enough
10:01:33 <kmc> add (S n) m = S (add n m);  add Z m = m
10:01:49 <kmc> so it's strict in its first argument
10:01:54 <kmc> but it's productive
10:02:20 <kmc> you can say something like «let ω = S ω in (ω + ω) > 7» and get True
10:02:21 <elliott> kmc: With unamb you can make it strict in whichever of its arguments is a better one to be strict in for each application :-)
10:02:26 <kmc> yes :)
10:02:40 <elliott> "Think you can trick me? Ha, I'll just look at the other one!"
10:02:46 <kmc> who's the caretaker of this stenobot2011?
10:03:30 <Eduard_Munteanu> The trick would be mapping that to machine integers where appropriate, I guess.
10:04:17 <wavewave> kmc : stenobot2011?
10:04:22 <Eduard_Munteanu> Or otherwise finding a fast representation.
10:04:41 <kmc> it's been quitting and re-joining rapidly for days
10:05:04 <elliott> kmc: It might be a person.
10:05:24 <wavewave> person bot.
10:05:38 <kmc> yep
10:05:43 <kmc> a person is a bot which is its own caretaker
10:07:45 <edwardk> preflex: xseen ezyang
10:07:45 <preflex>  ezyang was last seen on freenode/#haskell 1 day, 22 hours, 37 minutes and 57 seconds ago, saying: Hmm, gonna try to install threadscope again
10:08:14 <MatrixFrog> "in a functional language, you don't DO anything. so you certainly wouldn't want to DO one thing before another" (http://www.youtube.com/watch?v=faJ8N0giqzw)
10:08:27 <MatrixFrog> love it
10:10:05 <wavewave> is preflex a bot?
10:10:09 <kmc> yes
10:10:12 <wavewave> preflex: xseen wavewave
10:10:12 <preflex>  wavewave was last seen on freenode/#haskell 6 seconds ago, saying: is preflex a bot?
10:10:17 <wavewave> i see.
10:10:20 <elliott> No, just a really swift-typing human.
10:12:23 <MatrixFrog> with an excellent memory
10:12:29 <desaiu> my_length [] = 0
10:12:40 <desaiu> my_length (x:xs) = 1 + my_length xs
10:12:58 <desaiu> I'm having a difficult time grasping the meaning of (x:xs)
10:13:26 <desaiu> I don't know why the author put x:xs in parens
10:13:28 <Eduard_Munteanu> desaiu: it breaks (rather matches) a list into an element and another list
10:13:30 <wavewave> it's pattern matching.
10:14:00 <wavewave> desaiu: without ( ), you will get syntax error.
10:14:05 <Eduard_Munteanu> desaiu: because application binds tightest, so it'd parse as (my_length x):xs otherwise
10:14:08 <MatrixFrog> if xs=[2,3,4] and x=1, then (x:xs) is [1,2,3,4]
10:14:12 <desaiu> Is my_lengt expecting two arguments or just one?
10:14:21 <Eduard_Munteanu> Just one.
10:14:34 <desaiu> Is that in the form of a Num?
10:14:39 <wavewave> (x:xs) is the argument.
10:14:53 <kmc> desaiu, it's pattern-matching a list
10:14:58 <kmc> every list is either empty or non-empty
10:15:00 <desaiu> Would the user supply something like 3 or 3:4
10:15:09 <kmc> if it's non-empty, it has a first element and a remaining list
10:15:27 <kmc> desaiu, they'd supply something like [3,4], which is special syntax for (3 : 4 : [])
10:15:30 <monochrom> a list can look like 3:(4:[])  which is syntactic sugar for [3,4]
10:15:47 <desaiu> s/Would the user supplysomething like /Is it expecting input in the form of
10:15:51 <kmc> that would match the second case, with x = 3 and xs = (4 : [])
10:16:01 <houeland> Has anyone compiled GHC under Wine?
10:16:06 <kmc> the recursive call matches the second case again, with x = 4 and xs = []
10:16:11 <kmc> the recursive call matches the first case []
10:16:23 <Eduard_Munteanu> > let my_length xss = case xss of [] -> 0; (x:xs) -> 1 + my_length xs in my_length [1,2,3,4]
10:16:23 <lambdabot>   4
10:16:47 <monochrom> a list has only two possibilities. the two patterns [] and x:xs cover them all. I don't know what else to expect.
10:17:04 <Eduard_Munteanu> It expects a list, so you can't give it just an element.
10:17:57 <MatrixFrog> houeland, that sounds kind of silly. why would you want to do that?
10:18:30 <Eduard_Munteanu> I can think of reasons one would use GHC under Wine.
10:18:52 <Eduard_Munteanu> I used it for "cross-compiling" stuff for Windows.
10:18:57 <MatrixFrog> ok yeah i can too i guess. still sounds kind of silly :P
10:18:59 <kmc> maybe you're forced to do Windows development (ninjas have kidnapped your family, etc) but you would rather not actually touch Windows
10:19:06 <desaiu> I don't understand how, from just that code, the interpreter knows that xs should be a list
10:19:14 <kmc> desaiu, type inference
10:19:20 <Eduard_Munteanu> desaiu: look at the type of (:)
10:19:23 <kmc> :t (:)
10:19:24 <lambdabot> forall a. a -> [a] -> [a]
10:19:30 <kmc> the right-hand argument to (:) is always a list
10:19:36 <monochrom> type checking makes sure that no code is even run otherwise
10:19:38 <kmc> (first element of list : remaining list)
10:20:06 <monochrom> in fact, if you use the compiler, no code is even generated
10:20:08 <Eduard_Munteanu> Pseudo-Haskell: data [a] = [] | a : [a]
10:20:35 <kmc> yeah, aside from the special syntax it's equivalent to the ordinary data type «data List a = Nil | Cons a (List a)»
10:20:35 <Eduard_Munteanu> Or, if you want actual Haskell,    data List a = Nil | Cons a (List a)
10:20:36 <houeland> Yeah, I just want to compile windows binaries, without GMP
10:20:46 <danmaftei> Hello. I'm unable to figure out why ghci won't display Unicode encodings. Simply typing, e.g., '∅' at the prompt shows '\8709'
10:20:49 <desaiu> Could you do something like 3:4,2,5 or would the input have to be like 3:4:2:5
10:20:55 <desaiu> for x:xs
10:21:01 <kmc> danmaftei, putChar 'ø'
10:21:07 <Eduard_Munteanu> houeland: can't you just use the Haskell Platform binary?
10:21:11 <MatrixFrog> 3:4:2:5 doesn't typecheck because 5 is not a list
10:21:16 <MatrixFrog> 3:4:2:5:[] does
10:21:19 <kmc> desaiu, maybe you mean 3:4:2:5:[]
10:21:21 <danmaftei> thanks kmc!
10:21:28 <kmc> which is 3 : (4 : (2 : (5 : [])))
10:21:28 <monochrom> "3:4,2,5" is a parse error. "3:4:2:5" is a type error
10:21:30 <houeland> Hmm, can I make that not use GMP?
10:21:30 <Eduard_Munteanu> Or 3:[4,2,5]
10:21:39 <kmc> desaiu, in each case, the right-hand argument to (:) is a list
10:21:42 <Entroacceptor> desaiu: 3:[4,5,6] works, too
10:21:47 <Eduard_Munteanu> Oh, hrm, GMP.
10:21:55 <desaiu> In 3:4:2:5:[], 3 is the x and 4:2:5:[] is xs?
10:22:02 <kmc> yes
10:22:08 <kmc> if you match it against the pattern (x:xs)
10:22:14 <kmc> of course you could use any two variable names you like
10:22:15 <Eduard_Munteanu> houeland: btw, how is GMP a problem?
10:22:26 <kmc> you could even match against (_:_), which checks the list is non-empty but does not bind any variables
10:22:33 <desaiu> I think x:xs is the common example used for pattern matching, though, right?
10:22:38 <kmc> it's a common example
10:22:48 <kmc> you can pattern-match things that aren't lists, too
10:22:58 <kmc> x:xs , y:ys, etc. is a common naming convention for lists
10:23:12 <kmc> patterns nest, too.  if you have a list of lists you can say (x:xs):xss
10:23:42 <danmaftei> I've a Map with Char keys, many of which aren't ASCII. If I want to print it without writing my own function, do I have to re-define the show function? Currently, it outputs Unicode characters as '\xyz'
10:23:57 <kmc> > let headOfHead ((x:_):_) = Just x; headOfHead _ = Nothing in map headOfHead [ [], [[], []], [[2,3]] ]
10:23:57 <lambdabot>   [Nothing,Nothing,Just 2]
10:24:08 <houeland> Eduard_Munteanu: Because of licensing. I suppose I could try to get it to work on windows as just a dll if that works now (but I'd prefer not to)
10:24:10 <kmc> danmaftei, write your own function
10:24:16 <Eduard_Munteanu> Ah.
10:24:16 <desaiu> Haskell is so... powerful and expressive, it's going to take me years to really get a firm grasp. I'm excited!
10:24:22 <kmc> yep!
10:24:57 <danmaftei> thanks kmc.
10:25:10 <kmc> desaiu, the parts combine in flexible yet well-defined ways
10:25:16 <kmc> it feels like there are fewer arbitrary limitations
10:25:31 <kmc> and more principled limitations ;)
10:26:58 <parcs> :t 5 `id` 5 `id` 5
10:26:59 <lambdabot> forall t t1. (Num (t -> t1), Num t) => t1
10:27:22 <elliott> Also, Haskell is not only the best thing since sliced bread, it literally obsoletes sliced bread.
10:27:27 <elliott> Haskell makes me toast every morning.
10:27:27 <desaiu> I know it sounds baseless to say that it's powerful and expressive without backing it up
10:27:48 <desaiu> What are some cases where this is the case?
10:28:09 <desaiu> I'm new, I would attempt to list some, but I will probably sound foolish since I'm a terrible programmer
10:28:33 <kmc> you've just asked #haskell "why do you think Haskell is good"
10:28:38 <kmc> i'm afraid we'll be here a while ;P
10:28:50 <elliott> Finally, an excuse to become even more insular!
10:28:52 <Eduard_Munteanu> houeland: anyway, I didn't build GHC under Wine myself. Maybe this helps you http://code.google.com/p/hmpfr/wiki/GHCWithoutGMP but I suspect you'll need a working msys/mingw install to build it. That, or a cross-GCC.
10:29:03 <kmc> desaiu, I've recently put quite some thought into that question, since I'm preparing a "Why learn Haskell?" talk
10:29:09 <kmc> the "final" version of the slides will be posted in a day or two
10:29:22 <monochrom> haskell is not powerful or expressive. rather, take scheme for example, it has castrated pattern matching
10:30:01 <kmc> the reasons Haskell is good are somewhat subtle, because (contrary to popular opinion) it's a pragmatic, compromise design
10:30:19 <desaiu> I would like to look at some examples of where Haskell is better able to express ideas than other languages. I read that it is powerful and that it is expressive, and I feel the exact same way when I work through some of these problems. I unfortunately am bad at expressiving myself and backing up my claims, I was hoping some of you could give a few examples.
10:30:39 <desaiu> Also, are Haskell programmers called Haskellians or Haskellites? :)
10:30:48 <elliott> The treatment of imperative IO actions as first-class values that can be transformed is one obvious one.
10:30:51 <monochrom> C++ has castrated operator overloading.
10:30:52 <Eduard_Munteanu> desaiu: maybe this... http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
10:31:01 <kmc> also, a lot of the reasons have nothing to do with the big ideological positions
10:31:08 <kmc> but are just like... dumb shit that other languages could get right, but don't
10:31:11 <desaiu> 12:33 < elliott> Finally, an excuse to become even more insular! :P
10:31:24 <kmc> you don't need pure FP to have algebraic data with pattern matching... you don't even need static types
10:31:33 <kmc> this is something Python, Ruby, Javascript could all do
10:31:35 <MatrixFrog> i believe "haskeller" is the standard
10:31:38 <monochrom> C has castrated function definitions
10:31:40 <elliott> desaiu: That tongue is inaccurately represented; it was in cheek at the time.
10:31:42 <kmc> with minimal effort and they'd be much nicer to use
10:31:51 <desaiu> kmc: I look forward to the slides! Are we going to be treated to a video as well?
10:31:53 <zmv> MatrixFrog: "haskellite"?
10:31:54 <MatrixFrog> as in http://www.haskellers.com/
10:31:54 <kmc> maybe
10:32:01 <kmc> you don't need pure FP to have lightweight threads with transparent event-based IO, either
10:32:07 <elliott> Haskelloquode.
10:32:19 <elliott> We need something at least as obnoxious as "Pythonista".
10:32:26 <desaiu> monochrom: Are you saying it has castrated pattern matching compared to scheme? I didn't quite understand your comment.
10:32:30 <monochrom> haskell is not powerful or expressive. it's just so-so satisfactory. rather, most other languages castrate themselves, that provides the stark contrast.
10:32:41 <monochrom> scheme has castrated pattern matching.
10:33:20 <elliott> So if Haskell isn't good, other languages are just worse, what exactly are you basing your standards on? :p
10:33:30 <Eduard_Munteanu> Haskell castrated some other things as well.
10:33:48 <desaiu> elliott: Can you give me an example of this: "The treatment of imperative IO actions as first-class values that can be transformed is one obvious one."
10:33:49 <Eduard_Munteanu> Yeah, yet less than other languages, I guess.
10:34:00 <elliott> desaiu: Sure: IO String. :p
10:34:07 <monochrom> scheme patterns allow no variable. you must fill them with hardcoded literals. it lets you write "case 0:1:[] of ..." but not "case x:y:z of ..."
10:34:08 <elliott> desaiu: Take for instance
10:34:11 <desaiu> Eduard_Munteanu: I'm sending that page to my ebook reader now.
10:34:14 <elliott> liftM :: (a -> b) -> IO a -> IO b
10:34:18 <elliott> (type simplified for example purposes)
10:34:34 <elliott> desaiu: That /transforms/ an imperative action into another one that runs its output through a pure function.
10:34:36 <monochrom> C++ operator overloading is castrated because you can't coin new operator names.
10:34:44 <elliott> desaiu: That action can then be executed zero, one, or many times.
10:34:48 <Eduard_Munteanu> > sequence_ [putStrLn "Hello", putStrLn "World"]
10:34:49 <lambdabot>   <IO ()>
10:34:53 <monochrom> C function definition is castrated because you can't nest function definitions
10:35:03 <lambdanaut> kmc: Where will those slides you mentioned be posted?
10:35:04 <elliott> desaiu: You can make lists of actions, transform all of them with map, and combine them with a fold, producing one big action out of all the little pieces.
10:35:13 <kmc> on the World Wide Web
10:35:14 <elliott> desaiu: do notation is just a simple application of that.
10:35:20 <kmc> lambdanaut, I will spam the link far and wide
10:35:22 <lambdanaut> But it's so big, I'll never find them!
10:35:24 <lambdanaut> Oh ok
10:35:24 <kmc> I am shamelessly self-promoting
10:35:25 <monochrom> Python lambda is castrated because it doesn't allow I/O inside
10:35:49 <elliott> desaiu: It means that things like for loops in Haskell can be defined in terms of the actions they run and not require any special language extension or simila.
10:35:50 <elliott> r
10:35:57 <Eduard_Munteanu> monochrom: I remember the nested functions GCC extension needs to use some tricks
10:36:01 <elliott> (I'm conflating "IO action" and "general monadic action" a bit here.)
10:36:10 <elliott> (But IO is the most obvious example where this first-classness helps.)
10:37:08 <Eduard_Munteanu> I guess it makes it harder to see how code translates to asm.
10:37:24 <elliott> desaiu: Of course, higher-order functions in general aren't really common in non-functional languages...
10:37:28 <kmc> GCC only supports downward funarg
10:37:38 <kmc> elliott, that sounds like a tautology to me
10:37:41 <elliott> And without those you're very limited in terms of what abstraction you can achieve.
10:37:42 <elliott> kmc: Indeed.
10:37:56 <kmc> i would ask you to define "functional"
10:37:59 <elliott> kmc: But most people don't use functional languages; if desaiu didn't, that might help explain what they're getting out of Haskell that they can't articulate.
10:38:04 <kmc> but that's one of the main useless #haskell discussions
10:38:24 <elliott> And sure, it's vague, but the point is that higher-order programming isn't really common, and it's ubiquitous in Haskell :-)
10:38:32 <kmc> most people use at least one language which competently supports higher-order functions
10:38:37 <Eduard_Munteanu> 10s ETA until somebody mentions C is functional too :P
10:38:40 <kmc> this includes all the popular "scripting languages"
10:38:53 <companion_cube> hey, C is functional too !
10:38:55 <elliott> kmc: Not... really.
10:38:55 <kmc> HOFs are very common in Ruby and Javascript, pretty common in Python too
10:38:59 <Eduard_Munteanu> Heh.
10:39:00 <elliott> I wouldn't call Python's support for higher-order functions tolerable.
10:39:09 <kmc> yeah it's nicer in Haskell but the basic concepts are there
10:39:11 <elliott> This is evidenced by the fact that basically nobody but Twisted uses it heavily.
10:39:14 <kmc> and they /are/ used
10:39:23 <elliott> kmc: Sure, but Haskell's use is in a totally different league.
10:39:26 <kmc> no, first-class function tricks in Python are very common
10:39:35 <kmc> remember every object is just a dict holding function values
10:39:40 <desaiu> 12:40 < elliott> desaiu: It means that things like for loops in Haskell can be defined in terms of the actions they run and not require any special language extension or  simila.
10:39:45 <elliott> kmc: That's more of an implementation detail :P
10:39:46 <desaiu> THat was the last message I saw
10:39:47 <kmc> in fact bound object methods are closures over that' self' parameter
10:39:54 <desaiu> Anyway mind pasting so I can catch up?
10:39:56 <kmc> elliott, it's not, because people play dynamic language tricks with that dict all the time
10:39:58 <elliott> desaiu: http://tunes.org/~nef/logs/haskell/11.10.08 :-)
10:40:03 <desaiu> Thank you!
10:44:07 <sm> morning ddarius, jlouis, gienah. How does https://gist.github.com/1272609 look as a little thread/process supervisor package ?
10:45:39 <kmc> sm, does the subthread do anything with the watchdog other than say "I'm still alive"?
10:45:46 <kmc> if not, you might as well just pass the IO action that does that
10:45:55 <elliott> sm: watchProcess definitely needs to take something other than a String.
10:45:58 <elliott> See System.Process.
10:46:07 <sm> kmc: yes not sure about that. I thought it might query it so see how often it needs to kick
10:46:17 <sm> elliott: right
10:46:53 <sm> Watchdog might be (Interval, IO ())
10:49:05 <kmc> do y'all think a concurrent version of (<*>) for IO is a reasonable idea?
10:49:36 <kmc> i'm considering adding it to http://hackage.haskell.org/package/spawn under the name (|*|)
10:49:50 <kmc> mf |*| mx = spawn mx >>= (mf <*>)
10:50:25 <kmc> this lets you build parallel/concurrent liftM2, liftM3, etc. for IO
10:54:28 <sm> for Watchdog, System.Timeout looks like just the thing, except it's not resettable
10:57:34 <robert[]> help
10:57:42 <robert[]> I need de bruijn indices
10:57:52 <robert[]> does anyon eknow about the theory?
10:58:38 <newsham> amazing what turns up when you google for 'debruijn indices haskell'
11:00:45 <kmc> i can get you de bruijn indices cheap
11:00:51 <kmc> $50 / kg
11:00:53 <kmc> slightly used
11:01:16 <kmc> robert[], you were looking for the algorithm for substitution?
11:01:18 <kmc> I know it's in TaPL
11:01:35 <kmc> i'd bet it's somewhere online as well, but I don't have a link
11:02:02 <kmc> http://en.wikipedia.org/wiki/De_Bruijn_index#Formal_definition seems to discuss it
11:02:04 <wavewave> kmc: BTW, sounds like what your package do is similar to orc
11:02:27 <kmc> *nod*
11:02:35 <kmc> there are a lot of similar packages
11:02:39 <kmc> i didn't know about that one though, thanks
11:02:44 <jmcarthur> i like orc
11:02:45 <kmc> mine is simpler than the rest (and therefore also more limited)
11:02:47 <Saizan> http://hpaste.org/52322 <- yep, it's here for example
11:02:52 <kmc> orc looks pretty fancy
11:03:36 <kmc> looks like it supports a lot of different control-flow primitives
11:03:58 <jmcarthur> i've been working on an orc-alike for ocaml as a little side-project at work, but it's weird due to ocaml's lack of real concurrency
11:04:00 <robert[]> i dont have tapl
11:04:03 <robert[]> kmc
11:04:05 <robert[]> thanks though
11:04:17 <chr1s_> hey all
11:04:35 <wavewave> kmc: yeah.. I used orc in haskell  and I like it.
11:04:39 <chr1s_> is there a simple way to suppress the 'warning text reloc' warnings on Lion?
11:05:13 <alpounet> jmcarthur, hah, you were warned :p
11:05:53 <jmcarthur> alpounet: we do at least have a pretty nice library for asynchronous IO
11:06:13 <kmc> jmcarthur, what concurrency is avaliable in ocaml?
11:06:15 <jmcarthur> but for parallelism we have to resort to multiple processes :(
11:06:35 <jmcarthur> kmc: ocaml does support threads, but it has a global lock :\
11:06:39 <parcs> when should one use a Socket over a Handle?
11:06:43 <kmc> sigh
11:06:49 <alpounet> kmc, pthread-like ones iirc
11:06:51 <kmc> jmcarthur, is the lock dropped during foreign calls?
11:07:01 <alpounet> it probably actually uses pthread on linux
11:07:09 <jmcarthur> kmc: you can use the threads for a cheesy kind of non-blocking IO, yeah
11:07:15 <kmc> *nod*
11:07:17 <kmc> sounds like CPython, then
11:07:57 <jmcarthur> alpounet: it uses real OS threads. it's just that only one may really run at a time, safely
11:08:32 <alpounet> yeah
11:08:39 <alpounet> jmcarthur, have you heard of LWT ?
11:08:40 <jmcarthur> parcs: if you need it you'll know you need it
11:09:12 <kmc> what's a good introduction to orc?
11:10:05 <parcs> jmcarthur: hehe, alrighty
11:10:46 <jmcarthur> alpounet: i know *of* it but not much about it
11:11:02 <jmcarthur> alpounet: isn't it basically like a message passing kind of thing?
11:11:11 <parcs> i usually used Sockets because i never knew that there was a higher level interface in the Network module. now that i found it i just feel confused as to which i should use :P
11:11:37 <jmcarthur> parcs: as a general rule, if i can use a higher level interface, i do :)
11:12:07 <sm> nice, mueval has a watchdog in it
11:12:10 <parcs> jmcarthur: i recall you suggesting OpenGLRaw over OpenGL ;)
11:12:23 <jmcarthur> parcs: i don't believe that OpenGL is really higher level than OpenGLRaw
11:12:35 <alpounet> jmcarthur, i only remember what the acronym means, which is still more appealing than standard OCaml threads
11:12:38 <jmcarthur> layers of abstraction do not necessarily make something higher level
11:12:42 <alpounet> LightWeight Threads
11:12:43 <anandjeyahar> what does an instance in Haskell stand for?
11:12:58 <companion_cube> it's cooperative threading
11:12:58 <jmcarthur> alpounet: the issue with ocaml is that the gc isn't at all thread safe
11:13:02 <anandjeyahar> i understand types and typeclasses.
11:13:03 <robert[]> I need help with de bruijn indices
11:13:06 <sm> or no.. it's just a timeout
11:13:07 <kmc> anandjeyahar, says that a particular type implements a particular type class
11:13:22 <kmc> type classes are generic interfaces; instances are the implementations of those interfaces for specific types
11:13:26 <alpounet> jmcarthur, yup, remember the email from X. Leroy i showed you a few months back ? :P
11:13:30 <monochrom> "instance" is how you use type class. do you know type class? then you know instance.
11:13:37 <hpc> anandjeyahar: an instance is a particular... instance of a type class
11:13:38 <jmcarthur> yeah
11:13:55 <tauntaun> I'm a bit puzzled by the logs for #haskell.  Google says the thing I'm looking for is in the log for a certain date, but the log itself doesn't contain what I'm looking for.  Any ideas?
11:14:00 <hpc> or implementation
11:14:13 <anandjeyahar> hpc: Thanks. let me try and make sense of the no instance error now..
11:14:40 <alpounet> jmcarthur, there must still be some pretty fun stuffs to do though with OCaml
11:14:54 <hpc> tauntaun: google is doing this thing with rel links that might be what's screwing up the results
11:15:15 <mm_freak> parcs: if you work with iteratees, use sockets (ready-made libraries and faster)
11:15:18 <jmcarthur> alpounet: there are a few minor features of ocaml that i kind of wish were in haskell in some form, but overall they are nothing game-changing
11:15:34 <alpounet> what are these ?
11:15:39 <mm_freak> parcs: if you don't use iteratees, then use the high level module, whenever it suffices
11:15:39 <hpc> it treats a sequence of rel-linked pages as one document, so you are at the start of a sequence of logs
11:15:53 <alpounet> (to see if you enjoyed the same things i did)
11:15:59 <jmcarthur> alpounet: the ability to marshal arbitrary data, including closures, is kind of neat. i like some of the module system and dislike other bits of it. polymorphic variants are also kind of cool
11:16:08 <elliott> <Saizan> http://hpaste.org/52322 <- yep, it's here for example
11:16:08 <parcs> mm_freak: i am using iteratees, but are sockets really faster?
11:16:13 <elliott> Saizan: did you see my scepticism of that algorithm? :-)
11:16:17 <parcs> and i can just use enumHandle/iterHandle on them
11:16:18 <mm_freak> parcs: slightly
11:16:26 <alpounet> yeah, kinda the same here
11:16:27 <parcs> on handles*
11:16:33 <mm_freak> parcs: there is a ready-made socket enumerator, which is handy
11:16:45 <mm_freak> parcs: with Handle you get double buffering, which is probably not so optimal
11:16:48 <parcs> what i mean is that there is a ready-made handle enumerator too
11:16:51 <parcs> oh
11:17:07 <robert[]>  elliott  Lam (Var 0) is identiyy fgunction
11:17:12 <mm_freak> parcs: when using Handle network connections with iteratees i always disable the buffering entirely
11:17:18 <elliott> robert[]: yes, yes it is
11:17:39 <parcs> mm_freak: they are block-buffered by default right?
11:17:59 <mm_freak> parcs: the usual enumerators have block buffering, yes
11:18:16 <mm_freak> (in that they read in blocks)
11:18:23 * hackagebot parsec 3.1.2 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.2 (AntoineLatter)
11:18:25 <parcs> no i mean the handles are block-buffered
11:18:34 <mm_freak> parcs: also with network connections you really don't want to use the naive enumHandle
11:18:49 <mm_freak> parcs: enumHandle doesn't work well with stuff that can time out
11:19:02 <mm_freak> your enumerator will just wait forever
11:19:03 <parcs> interesting
11:19:18 <mm_freak> parcs: i have written a enumHandleTimeout and enumHandleSession in my netlines library
11:19:28 <mm_freak> but you really should use sockets and the socket enumerator
11:19:37 <tauntaun> Any recommendations for how to search the logs, then?
11:20:12 <elliott> I wonder what the overhead of unamb is like
11:20:21 <jmcarthur> it's pretty bad
11:20:26 <elliott> heh
11:20:27 <robert[]> 100%
11:20:28 <jmcarthur> at least if you use it pervasively
11:20:37 <jmcarthur> or in a recursive algorithm
11:20:58 <parcs> mm_freak: alright, thanks for the info
11:21:35 <robert[]> lets talk about de bruijn
11:22:05 <companion_cube> well, what's your problem with de brujin?
11:22:17 <robert[]> companion_cube: I have worked 3 days trying to write substitutions, and its wqrong
11:22:48 <robert[]> I want to derive the function from a specification, so I know its right
11:22:59 <robert[]> but I don't know what the specification is
11:23:32 <jmcarthur> elliott: if you are willing to deal with a monad it's implementable in pure code. you have to program your algorithms in "steps" though in order to be able to interleave the computations
11:24:12 <elliott> jmcarthur: I don't think that's quite true: you can't do functions that are strict in "either" of their arguments like that
11:24:20 <jmcarthur> the monad is basically    data Computation a = Now a | Later (Computation a)
11:24:54 <jmcarthur> elliott: the result of mplus basically interleaves the Laters until it comes across a Now on either side, at which point the result is Now
11:24:59 <companion_cube> robert[]: it's like    subst i newt (Lambda t) = subst (i+1) newt t; subst i newt j = if j==i then newt else j
11:25:09 <elliott> jmcarthur: well, it means you have to change your data types, at least :-)
11:25:10 <robert[]> i of newt
11:25:11 <robert[]> I like it
11:25:14 <jmcarthur> yeah
11:25:34 <companion_cube> subst i newt t meaning 'replace index i by newt in t"
11:25:35 <jmcarthur> elliott: i've implemented that monad with stream fusion before. it generated really tight code, actually
11:25:50 <companion_cube> i think it's something like  that
11:26:05 <robert[]> yes
11:26:09 <robert[]> it is
11:27:18 <companion_cube> ifyou want to perform multiple substitutions at once, either you naively compose primitive substitutions
11:27:34 <companion_cube> like (subst i1 t1) . (subst i2 t2) . (subst i3 t3)
11:27:57 <robert[]> yes but the thing is
11:27:58 <companion_cube> or you can do something smarter with a map of substitutions
11:28:06 <robert[]> my code is wrong
11:29:09 <elliott> jmcarthur: I'm just not sure how to transform data types appropriately -- just turn X into Computation X, including recursive occurrences?
11:29:24 <elliott> That works, but means that all code using the type must use Computation directly to have it all work... I guess that's to be expected
11:29:29 <jmcarthur> elliott: each recursive step in your algorithm would be wrapped in Later, basically
11:29:32 <elliott> Right
11:29:35 <jmcarthur> yeah, that's the tradeoff
11:29:57 <monochrom> "lazy evaluation has a future"
11:33:04 <robert[]> anyonw
11:40:59 <hugh> Any one can help me coding  this haskell small application?
11:41:27 <hugh> hello
11:42:46 <hugh> any one?
11:42:59 <hugh> OMG
11:43:35 <Eduard_Munteanu> hugh: hi. Just ask your question directly.
11:45:12 <hugh> Eduard_Munteanu:thanks. problem solved by other
11:46:58 <erus`> http://i.imgur.com/4us0v.png
11:47:20 <kmc> sucks
11:47:51 <kmc> this reddit meme shit is going to take over everything i care about
11:47:52 <kmc> isn't it
11:48:20 <kmc> omg funnay haskell epic fail lol bacon zombie narwhals
11:48:32 <erus`> >implying memes are born in reddit
11:48:51 <kmc> no
11:49:03 <kmc> i'm annoyed because /r/haskell is sliding towards this kind of "content"
11:50:18 <erus`> kmc you know how to beat trolls
11:50:53 <kmc> yeah but i'm not an op
11:51:16 <erus`> i wish /r/haskell was busier
11:52:28 <erus`> and i wish leksah would build on a vanilla haskell platform. These are my two wishes in the world.
11:52:35 <kmc> :D
11:52:43 <kmc> presumably you care about something other than the raw number of posts in /r/haskell
11:53:29 * hackagebot monadlist 0.0.2 - Monadic versions of list functions  http://hackage.haskell.org/package/monadlist-0.0.2 (ThomasEding)
11:53:57 <monochrom> how do you beat trolls? I don't know and I like to know
11:54:08 <erus`> monochrom: you ignore them...
11:54:29 <monochrom> not sure if it beats them, but I can do that
11:54:39 <robert[]> the problem is trolls make fake accounts where they pretend to be offended by themselves
11:55:18 <erus`> people who get offended by ones and zeros are fools too so ignore those also
11:55:37 <robert[]> erus`: I don't think that is a correct usse of reduction
11:56:18 <erus`> robert[]: no thats right, people who get offended are fools so ignore them
11:56:36 <kmc> haha
11:57:22 <kmc> that sounds like a great philosophy, if your goal is to be an asshole and blame other people for it
11:58:13 <kmc> and feel morally superior while doing so
11:59:03 <Saizan> it has some truth though
11:59:14 <kmc> yeah
11:59:25 <erus`> some feel offended by swearing, this is a voluntary response. If we all just treated swear words as we treat normal words there would be no offended parties anymore
12:00:03 <robert[]> the use of swear word is for an authority figure to assert what sins are worse
12:00:11 <kmc> erus`, yeah most people figure that out in their mid-teens
12:00:12 <monochrom> pretty sure erus` is speaking under the gentleman assumption that your post is un-offensive within reason
12:00:26 <robert[]> for example giving a blind eye to some swear words and harsly punishing the use of othrs
12:01:34 <kmc> let's take this to #haskell-blah
12:02:06 <erus`> wow i do talk about off topic stuff too much... stopping now
12:02:11 <kmc> yeah you do erus`
12:20:07 <robert[]> anyone with insight into the de bruijhn indices probelm?
12:20:48 <kmc> what's the problem?
12:26:01 <wavewave> how does nixos hackage packages treat diamond dependency problem?
12:34:59 <DevHC_> so um
12:35:07 <DevHC_> why is there a List and a Data.List?
12:35:24 <wavewave> one is Prelude, the other is extended version
12:35:36 <wavewave> one is haskell98
12:36:13 <DevHC_> and the other one is 2010?
12:36:26 <ddarius> Technically, yes.
12:36:27 <DevHC_> or just a GHC-specific extension?
12:36:42 <ddarius> But Data.List has existed for most of a decade.
12:36:46 <wavewave> http://www.haskell.org/onlinereport
12:37:01 <wavewave> DevHC_ : this is haskell98
12:37:03 <mauke> DevHC_: List is H98, Data.List is what everyone uses
12:38:35 <wavewave> http://www.haskell.org/definition/haskell2010.pdf
12:38:46 <wavewave> haskell2010 has officially Data.List .
12:38:55 <elliott> DevHC: hierarchical models predate haskell 2010 by a loooongw ay
12:39:08 <elliott> i dunno exactly how long they've been around, but it's a long time
12:39:17 <parcs> what exports List?
12:39:19 <parcs> base?
12:39:28 <elliott> haskell98
12:39:45 <wavewave> DevHC: probably you miss this during reconnection. http://www.haskell.org/definition/haskell2010.pdf
12:39:51 <parcs> oh
12:39:58 <parcs> that's a package! neat
12:40:15 <benmachine> you can use it instead of base entirely
12:40:19 <benmachine> to ensure compatibility
12:40:36 <DevHC> i've had the report linked to me like N times already
12:40:45 <wavewave> haskell2010 report officially mandate Data.List. see section 20.
12:41:22 <wavewave> DevHC: On the contrary, haskell98 report has List in its library section.
12:41:48 <DevHC> zomfg, i've searched for Data.List, and ended up at the monomorphism restriction definition D:
12:41:54 <benmachine> also, List has a more sensible name
12:41:59 <benmachine> just sayin'
12:42:39 <jampart> newbie q: Have two module M1 and M2.M3.  How do i get M2.M3 to import M1?
12:42:51 <parcs> import M1
12:42:57 <jampart> parcs: doesn't work.
12:43:08 <benmachine> jampart: doesn't work how
12:43:10 <parcs> you have to load the file from the basedir of M1
12:43:22 <jampart> ahh...
12:43:23 <parcs> everything is relative to the cwd
12:43:23 <benmachine> or use -i/path/to/dir
12:44:54 <jampart> thanks
12:45:36 <tsousa> what is the difference between a value contructor and a type contructor?
12:45:56 <parcs> a type construct is used it type annotations
12:46:03 <parcs> a value constructor in expressions
12:46:06 <wavewave> value constructor is a function/ type constructor is a type function (not a function)
12:46:17 <parcs> Maybe is a type constructor, Just is a value constructor
12:46:38 <tsousa> sorry i didnt understand
12:46:46 <parcs> do you understand now?
12:47:01 <wavewave> tsousa: so you can redefine f = Just but you cannot redefine f = Maybe
12:47:25 <wavewave> tsousa: haskell has very strictly separted two worlds : Value & Type
12:48:01 <hpaste_> desaiu pasted “my_length” at http://hpaste.org/52345
12:48:04 <parcs> a type constructor is used in type annotations*
12:48:08 <parcs> damn this heat
12:48:21 <desaiu> I don't understand that
12:48:29 <mauke> desaiu: why?
12:48:29 <tsousa> parcs, type annotations?
12:48:59 <mauke> tsousa: Int is a type constructor, 42 is a value constructor
12:49:13 <tsousa> humm
12:49:18 <parcs> tsousa: in foo :: Maybe Int, the stuff to the right of the :: is a type annotation
12:49:21 <wavewave> f :: Maybe a       .. here :: Maybe a is type annotation.
12:49:21 <nooodl> hey, i need to somehow form an infinite list, and i don't really know the clearest way to do it
12:49:22 <desaiu> mauke: I'm not sure yet, I'm still trying to formulate my confusion
12:49:37 <benmachine> nooodl: there are loads of ways, what do you want the list to contain?
12:49:43 <tsousa> mauke, parcs welterde thanks i know understand
12:49:47 <nooodl> starting with [0], apply (\x -> x ++ map (+1) x) an infinite amount of times
12:49:52 <parcs> great :)
12:50:15 <nooodl> so [0] -> [0, 1] -> [0, 1, 1, 2] -> [0, 1, 1, 2, 1, 2, 2, 3]...
12:50:19 <mauke> > iterate (\x -> x ++ map (+1) x) [0]
12:50:21 <lambdabot>   [[0],[0,1],[0,1,1,2],[0,1,1,2,1,2,2,3],[0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4],[0...
12:50:23 <tsousa> i will do more exercices
12:50:28 <nooodl> mauke, i tried that
12:50:50 <nooodl> but i can't take the last, infinite element of that
12:51:00 <mauke> nooodl: oh, I thought you wanted a list of all intermediates
12:51:13 <nooodl> ah. nope
12:51:41 <benmachine> that sounds quite tricky actually
12:51:54 <nooodl> this is, by the way, a list of the amounts of bits in the natural number x
12:52:04 <nooodl> so i could just calculate that for each element in [0..]
12:52:41 <benmachine> > fix (\x -> x ++ map (+1) x) -- wild guess
12:52:45 <lambdabot>   mueval-core: Time limit exceeded
12:52:47 <benmachine> oh of course that doesn't work
12:52:55 <benmachine> > fix (\x -> 0 : x ++ map (+1) x) -- wilder guess
12:52:56 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:53:00 <benmachine> hah
12:53:01 * benmachine silly
12:53:43 <nooodl> i tried "x = 0 : map (+1) x", which is just [0..] of course :(
12:53:50 <benmachine> yeah
12:55:02 <nooodl> i'm pretty sure there's some really neat way to do this, like the canonical fibs implementation
12:55:06 <mauke> :t let diag ((x : xs) : xss) = x : diag (map tail xss); diag _ = [] in diag
12:55:07 <lambdabot> forall a. [[a]] -> [a]
12:55:11 <benmachine> yeah, it feels like that
12:55:23 <mauke> > let diag ((x : xs) : xss) = x : diag (map tail xss); diag _ = [] in diag ["foo", "bar", "baz"]
12:55:24 <lambdabot>   "faz"
12:55:41 <mauke> > let diag ((x : xs) : xss) = x : diag (map tail xss); diag _ = [] in diag (iterate (\x -> x ++ map (+1) x) [0])
12:55:42 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
12:55:43 <benmachine> mauke: won't that be rather inefficient?
12:55:53 <nooodl> ingenious :)
12:55:55 <mauke> yes, but at least it works
12:56:37 <ddarius> Now one can calculate.
12:56:58 <mauke> @oeis 0,1,1,2,1,2,2,3
12:57:06 <lambdabot>  1's-counting sequence: number of 1's in binary expansion of n (or the binary...
12:57:07 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
12:57:18 <wavewave> wow.
13:01:08 <mauke> > let diag ((x : xs) : xss) = x : diag (map tail xss); diag _ = [] in (`mod` 2) <$> diag (iterate (\x -> x ++ map (+1) x) [0])
13:01:10 <lambdabot>   [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,...
13:01:14 <ion> jlouis: A supervisor implementation for Cloud Haskell might be the way to go in the long run, but that doesn’t exist at the moment and i for one would find your process/IPC/supervisor stuff useful at this very moment. :-)
13:01:37 <nooodl> > let f 0 = Nothing; f x = Just (mod x 2, div x 2) in map (sum . unfoldr f) [0..]
13:01:38 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
13:01:59 <ddarius> :t quotRem
13:02:00 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
13:02:17 <nooodl> yeah, divMod is the other way around :/
13:02:26 <mauke> :t (snd &&& fst)
13:02:27 <lambdabot> forall a c. (a, c) -> (c, a)
13:02:48 <nooodl> :t (&&&)
13:02:48 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:02:57 <nooodl> ...say what?
13:03:10 <robert[]> is anyone knowledagble about de bruikjn  incides?
13:03:18 <mauke> nooodl: Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
13:03:21 <robert[]> I have a lot of trouble with the simple function 'substitute'
13:04:08 <ion> @type (&&&) `asAppliedTo` (undefined :: a -> b)
13:04:09 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
13:04:29 <ion> @@ @djinn @type (&&&) `asAppliedTo` (undefined :: a -> b)
13:04:30 <lambdabot>  -- f cannot be realized.
13:04:39 <mauke> > let bits 0 = 0; bits n = succ (bits (n .&. pred n)) in bits 1
13:04:40 <lambdabot>   Ambiguous type variable `t' in the constraints:
13:04:41 <lambdabot>    `Data.Bits.Bits t'
13:04:41 <lambdabot>      ...
13:05:03 <mauke> > let bits n@0 = n; bits n = succ (bits (n .&. pred n)) in bits 1
13:05:04 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:05:04 <lambdabot>    `Data.Bits.Bits a'
13:05:04 <lambdabot>      ...
13:05:08 <mauke> > let bits n@0 = n; bits n = succ (bits (n .&. pred n)) in bits 1 :: Integer
13:05:09 <lambdabot>   1
13:05:36 <mauke> > let bits n@0 = n :: Integer; bits n = succ (bits (n .&. pred n)) in map bits [0 ..]
13:05:37 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
13:06:02 <JoeyA> Is there a function for converting a lazy ByteString to a strict ByteString?
13:06:10 <JoeyA> Or will I just have to do B.concat . C.toChunks every time?
13:06:10 <Philippa> does anyone know if there's a good way to put Haskell code on Wordpress.com, where good is defined as "has syntax highlighting, takes advantage of their line-numbered code widgetry"?
13:06:18 <nooodl> "n@0" huh
13:06:22 <mauke> JoeyA: no and no
13:06:24 <Philippa> (specifically wordpress.com, I don't want to run my own install)
13:06:36 <mauke> nooodl: I was too lazy to write bits :: Integer -> Integer
13:06:44 <nooodl> haha
13:07:15 <benmachine> :t let bits 0 = 0 :: Integer; bits n = succ (bits n) in bits
13:07:16 <lambdabot> forall t. (Num t) => t -> Integer
13:07:20 <benmachine> oh right
13:08:02 <mauke> > let bits n@0 = n :: Integer; bits n = succ (bits (n .&. pred n)) in bits (2^100)
13:08:03 <lambdabot>   1
13:08:07 <mauke> > let bits n@0 = n :: Integer; bits n = succ (bits (n .&. pred n)) in bits (2^100 - 1)
13:08:08 <lambdabot>   100
13:08:35 <quackquack> how do I see where haskell's import paths? `-v` doesnt work... (I am using runhaskell)
13:08:50 <nooodl> can lambdabot time results?
13:09:34 <robert[]> no
13:12:21 <benmachine> nooodl: ghci can, with :set +s
13:12:29 <nooodl> oh, neat
13:13:09 <mauke> relatively pointless, though
13:13:17 <mauke> if you're going to benchmark code, compile with -O2
13:13:49 <nooodl> man, finding a recursive and cool way to do this really isn't working out
13:14:03 <shirt> haskell's line buffering does /not/ work well with multilog! i just spent way to long tracking this down
13:14:24 <mauke> shirt: how does it fail?
13:15:16 <shirt> mauke: the output simply does not show up in multilog
13:15:31 <mauke> shirt: how do you know it's line buffered?
13:16:03 <shirt> mauke: i called hGetBuffering to check. when i set it to NoBuffering everything works
13:16:21 <mauke> that sounds like a terrible solution
13:16:23 <incluye> > fix (+0)
13:16:26 <mauke> you should never use NoBuffering
13:16:27 <lambdabot>   mueval-core: Time limit exceeded
13:16:31 <incluye> I must be misunderstanding fix
13:16:45 <shirt> mauke: the default of stderr seems to be NoBuffering
13:16:51 <incluye> x + 0 = x
13:16:53 <incluye> always
13:16:55 <mauke> shirt: yes :-/
13:17:06 <mauke> incluye: so which x do you want returned?
13:17:22 <incluye> > fix sqrt
13:17:24 <wavewave> x + 0 + 0 + 0 + 0 ....
13:17:26 <lambdabot>   mueval-core: Time limit exceeded
13:17:28 <incluye> Hm.
13:17:41 <incluye> How many numbers are there where sqrt(x) = x?
13:17:41 <mauke> incluye: fix gives you the least defined fixpoint
13:17:47 <mauke> so that's undefined here
13:17:52 <benmachine> if bottom is a fixed point, then fix gives you bottom
13:17:52 <wavewave> mathematically same but computationally different.
13:17:54 <incluye> oh
13:18:15 <mauke> incluye: undefined, 0, 1
13:18:29 <incluye> hmm
13:18:47 <incluye> so the fixed point of any function is undefined?
13:18:51 <mauke> no
13:19:00 <mauke> incluye: consider (const 42)
13:19:10 <benmachine> const 42 undefined is not undefined
13:19:16 <wavewave> to define fixed point of those functions, you need to have a concept of neighborhood.
13:19:17 <benmachine> therefore undefined is not a fixed point of const 42
13:19:19 <incluye> oh
13:19:24 <pinko> hallo
13:19:30 <benmachine> hello
13:19:46 <pinko> trying haskell out?
13:19:54 <incluye> what's an example of a non-const function with a defined least fixed point?
13:20:00 <wavewave> to finish computation within finite operation.
13:20:04 <benmachine> > fix (\x -> 0 : x)
13:20:05 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:20:07 <mauke> incluye: (0 :)
13:20:10 <incluye> oh
13:20:16 <incluye> infinite 0s
13:20:18 <incluye> okay
13:20:21 <incluye> makes sense
13:20:29 <benmachine> > fix (\x -> take 2 (0 : x))
13:20:30 <lambdabot>   [0,0]
13:20:46 <incluye> neat
13:20:50 <pinko> what do you guys are gonna use hskell for?
13:20:51 <mauke> incluye: \f -> (\n -> if n < 2 then 1 else n * f (n - 1))
13:21:00 <mauke> :t fix (\f -> (\n -> if n < 2 then 1 else n * f (n - 1)))
13:21:01 <lambdabot> forall a. (Num a, Ord a) => a -> a
13:21:13 <mauke> > fix (\f -> (\n -> if n < 2 then 1 else n * f (n - 1))) 5
13:21:14 <lambdabot>   120
13:21:22 <mauke> pinko: writing factorial
13:21:49 <pinko> oh yeah?! how about fibonacci numbers ?
13:21:58 <mauke> old hat
13:22:27 <benmachine> incluye: I recommend http://www.vex.net/~trebla/haskell/fix.xhtml for understanding fix
13:22:28 <wavewave> >fix (0:)
13:22:35 <pinko> i am trying to understand if its worth to write a proper client server software using a functional language
13:22:39 <wavewave> > fix (0:)
13:22:40 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:22:47 <wavewave> fix (0+)
13:22:54 <mauke> pinko: oh, I also have an irc bot written in haskell
13:22:55 <wavewave> > fix (0+)
13:22:58 <lambdabot>   mueval-core: Time limit exceeded
13:23:15 <wavewave> difference is strictness.
13:23:25 <pinko> in my job they are starting to use SCALA
13:23:32 <pinko> but haskell looks more fun
13:23:55 <pinko> just because we have JAva they picked Scala
13:24:06 <ddarius> sqrt(x) = x <=> x = x^2 <=> x^2 - x = 0 <=> x(x-1) = 0 so x = 0 or x = 1.
13:24:07 <wavewave> pinko: I didn't use Scala.. but I absolutely can say haskell is much more fun.
13:24:53 <pinko> can you write client code as well?
13:24:53 <robert[]> ddarius: prove it
13:25:00 <wavewave> pinko: well, I should refrain from judging before experience though..
13:25:12 <elliott> robert[]: he just did
13:25:19 <robert[]> elliott: prove it
13:25:24 <pinko> i am trying basic stuff right now
13:25:34 <mauke> <mauke> pinko: oh, I also have an irc bot written in haskell
13:25:37 <elliott> robert[]: troll
13:26:39 <robert[]> prove it
13:26:48 <wavewave> pinko: haskell is not just an academic language any more..
13:26:53 <mauke> robert[]: do you have a point somewhere?
13:27:29 <wavewave> pinko: I think it's now very productive.
13:27:47 <ddarius> Haskell was never an academic language, and plenty of academic languages can write "client code."
13:27:48 <Philippa> there's a Haskell-like language for JVM that's being worked on too, though I forget the name?
13:27:52 <Philippa> was announced recently
13:27:54 <pinko> <wavewave> yeah it looks cool
13:28:01 <ddarius> CAL ?
13:28:11 <elliott> frege
13:28:16 <wavewave> frege..
13:28:18 <wavewave> yeah.
13:28:28 <companion_cube> able to use jvm libs ?
13:28:40 <Philippa> companion_cube: I'd hope so or it's a waste of time
13:28:43 <wavewave> companion_cube: aimed so.
13:28:54 <hpc> is there an alternative library to mueval?
13:28:59 <companion_cube> ok, it wouldn't make much sense otherwise, indeed
13:29:03 <Philippa> wavewave: point. Take my statement as "modulo current level of development" :-)
13:29:04 <wavewave> it's still early.. we need to wait and see for that.
13:29:13 <elliott> hpc: hint directly?
13:29:37 <hpc> elliott: hint is actually what is giving me trouble
13:29:44 <hpc> it requires haskell-src, which requires base 3
13:29:49 <hpc> i have base 4
13:30:34 <pinko> could you guys paste an example of a simple program that for instance in java would take lots of LOCs but in haskell would be written in just a few lines...li...
13:30:52 <mauke> main = putStr "Hello, world!\n"
13:31:11 <mauke> that's at least 5 lines in java
13:31:16 <robert[]> print "hello world"
13:31:18 <pinko> for instance something to r count the number of lines of a text file
13:31:22 <hpc> oh, the latest version of haskell-src can work with base 4
13:31:27 <nooodl> > fix (concatMap (\x -> [x, x+1])) [0]
13:31:28 <wavewave> pinko: see some parsing library like parsec.
13:31:30 <lambdabot>   Couldn't match expected type `[t1] -> t'
13:31:31 <rwbarton> main = interact $ show . length . lines
13:31:32 <lambdabot>         against inferred type `[a]'
13:31:36 <nooodl> ^ what's wrong with that
13:31:44 <companion_cube> main = unlines . reverse . lines
13:31:45 <gcabrita> reverse . take 10 . reverse . show $ sum [ x^x | x<-[1..1000]]
13:32:02 <companion_cube> it's a reversing version of cat
13:32:17 <ddarius> companion_cube: It's a type error.
13:32:17 <mauke> companion_cube: like tac?
13:32:20 <alpounet> nooodl, its type
13:32:22 <wavewave> pinko: I guess you will definitely be impressed by parsec tutorial
13:32:28 <mauke> :t (concatMap (\x -> [x, x+1]))
13:32:29 <lambdabot> forall a. (Num a) => [a] -> [a]
13:32:31 <alpounet> nooodl, fix only takes a function
13:32:52 <pinko> ok  ill take a look
13:32:57 <mauke> > fix (concatMap (\x -> [x, x+1]))
13:33:01 <pinko> how about writing a little http server
13:33:01 <lambdabot>   mueval-core: Time limit exceeded
13:33:07 <companion_cube> ddarius: oh i forget "interact"
13:33:17 <companion_cube> :t interact $ unlines . reverse . lines
13:33:18 <lambdabot> IO ()
13:33:35 <wavewave> pinko: also read an article : why functional programming matters by John Hughes
13:33:44 <aristid> :t (concatMap (\x -> [0, x, x+1]))
13:33:45 <lambdabot> forall a. (Num a) => [a] -> [a]
13:33:50 <aristid> > fix (concatMap (\x -> [0, x, x+1]))
13:33:54 <lambdabot>   mueval-core: Time limit exceeded
13:34:01 <parcs> companion_cube: that wouldn't work, interact already works line-by-line
13:34:05 <parcs> @src interact
13:34:05 <lambdabot> interact f = do s <- getContents; putStr (f s)
13:34:10 <mauke> parcs: what
13:34:12 <parcs> oh wait never mind
13:34:28 <aristid> parcs: lazy i/o to the evil rescue
13:34:40 <parcs> quite the misleading name >_>
13:34:48 <ddarius> Why?
13:35:14 <companion_cube> parcs: it works
13:35:14 <parcs> dunne
13:35:35 <companion_cube> it reverses the order of lines, but not the lines themselves
13:36:05 <parcs> ddarius: dunno. the fact that stdin is LineBuffered by default i would assume interact would work line-by-line
13:36:42 <mauke> ?!
13:36:42 <lambdabot> Maybe you meant: . ? @ v
13:36:52 <companion_cube> and just replace "reverse" by "sort" from Data.List \o/
13:37:16 <alpounet> pinko, we have quite many of them (http servers) around, now
13:37:33 <ddarius> Writing an HTTP server is stupid easy.
13:37:43 <alpounet> it's only tiresome
13:38:46 <pinko> oh yeah definitely..it would be interesting to use it as an example of  conciseness of haskell
13:39:12 <desaiu> fib (1 || 2) = 1
13:39:15 <desaiu> >fib (1 || 2) = 1
13:39:18 <mauke> desaiu: no
13:39:19 <desaiu> > fib (1 || 2) = 1
13:39:20 <lambdabot>   <no location info>: parse error on input `='
13:39:54 <desaiu> Hmmm
13:40:15 <mauke> > let fib ((`elem` [1, 2]) -> True) = 1 in fib 2
13:40:16 <lambdabot>   1
13:40:33 <gwern> @quote fib
13:40:34 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
13:41:34 <desaiu> I don't know what `elem` is
13:41:43 <mauke> @src elem
13:41:43 <lambdabot> elem x    =  any (== x)
13:42:09 <desaiu> > let fib (1 || 2) = 1
13:42:09 <lambdabot>   <no location info>: Parse error in pattern
13:42:22 <mauke> desaiu: ignore my 'fib' above, btw; it was meant to scare other haskellers
13:43:41 <robert[]> will someone help me with de bruijhn inde
13:43:42 <robert[]> ?
13:44:05 <mauke> robert[]: have you ever explained your problem?
13:44:14 <mauke> also, how many ways can you misspell that name?
13:44:22 <desaiu> F_{n-2}, I'm unfamiliar with that syntax, is that f = n-2?
13:44:34 <monochrom> yes, he/she has. well, minimally. unwilling to show code, while keep saying "my code doesn't work"
13:44:51 <mauke> desaiu: that looks like TeX syntax
13:44:53 <robert[]> that's LaTeX
13:45:26 <desaiu> I'm looking at the recursion exercise in YAHT
13:45:58 <monochrom> F_{n-2} is an ASCII way to write F, subscript n-2
13:46:13 <monochrom> F, subscript n-2 is an archaic way to write F (n-2)
13:46:49 <desaiu> Is that f * (n-2)?
13:46:51 <mauke> Fᵢ₋₂
13:46:58 <desaiu> or just f of n-2
13:47:01 <monochrom> no, function application, like haskell
13:47:11 <robert[]> desaiu:
13:47:15 <robert[]> show me
13:47:24 <desaiu> http://upload.wikimedia.org/math/a/6/1/a618a6be07a7cae94d2638a4a12167d7.png
13:47:28 <mauke> robert[]: show me your problem
13:48:14 <quackquack> can someone give me an example use of foldr?
13:48:15 <robert[]> F_n = F_{n-2} + F_{n-1}
13:48:27 <mauke> desaiu: in haskell: f n | n == 1 || n == 2 = 1 | otherwise = f (n - 2) + f (n - 1)
13:48:33 <monochrom> > foldr (&&) True [False, True, False]
13:48:34 <lambdabot>   False
13:48:37 <robert[]> fibonccia numb4ers
13:48:44 <quackquack> monochrom: ty
13:48:47 <mauke> robert[]: hello?
13:48:57 <desaiu> f (n - 2)
13:49:02 <desaiu> is that f * (n-2)?
13:49:02 <monochrom> foldr (&&) x0 [y0, y1]  is  x0 && (y0 && y1)
13:49:05 <mauke> desaiu: no
13:49:40 <monochrom> sorry, that's wrong. I'll write a right one
13:49:59 <monochrom> foldr (&&) x0 [y0, y1, y2]  is  y0 && (y1 && (y2 && x0))
13:50:09 <desaiu> monochrom: Is that for me?
13:50:16 <monochrom> no
13:50:18 <desaiu> Okay
13:50:30 <desaiu> I'm tired, going to take a nap and look at this problem again in a few mins
13:50:43 <desaiu> Will review the logs as well
13:50:53 <parcs> who naps for a few minutes? :P
13:51:48 <pinko>  fst (29,3­,3) Couldn't match expected type `(a, b)' against inferred type `(t, t1, t2)'
13:52:02 <pinko> why isnt the above working while the follwoing does?
13:52:09 <pinko> fst (28,"­chris") => 28
13:52:18 <mauke> :t fst
13:52:19 <lambdabot> forall a b. (a, b) -> a
13:52:23 <mauke> @src fst
13:52:23 <lambdabot> fst (x,_) =  x
13:53:00 <pinko> isnt fst a function that returns the first element of a tuple
13:53:03 <pinko> ?
13:53:26 <koninkje> first element of a 2-tuple
13:53:34 <koninkje> not of an n-tuple in general
13:54:20 <pinko> ok ..what do we use for an n-tuple then?
13:54:41 <koninkje> there's nothing standard. you'd need to define a typeclass
13:54:46 <monochrom> I don't even use fst and snd all that often. I just pattern match.
13:55:02 <monochrom> myfun (x,y) = ... x ... y ....  no fst, no snd
13:55:25 <monochrom> myfun3 (a, b, c) = ... a ... b ... c ...  no extra "accessors" needed
13:55:52 <pinko> what do you mean
13:55:54 <aristid> monochrom: how unpointfree
13:56:11 <monochrom> someotherfun x = case someonesfun (x*x) of (s,t) -> ... s ... t ...
13:56:21 <pinko> head works for lists right?  > head [1,2,­3,4] => 1
13:56:21 <koninkje> pinko: another option besides type classes is to use one of the lens packages
13:56:27 <monochrom> I mean what I just said.
13:57:02 <monochrom> @let myfun (x, y) = show x ++ " " ++ show y
13:57:03 <lambdabot>  Defined.
13:57:08 <pinko> in the above [1,2,3,4] is a list
13:57:11 <monochrom> > myfun (True, 'x')
13:57:12 <lambdabot>   "True 'x'"
13:57:18 <monochrom> does not need fst or snd
13:57:43 <monochrom> I don't use head and tail all that often, either. same reason. just use pattern matching
13:57:52 <pinko> (1,2,3,4) is a 4-tuple ...right? what do you normally use then-tuples for i nhaskell?
13:58:11 <monochrom> I just said. pattern matching
13:58:36 <monochrom> > myfun4 (a,b,c,d) = show c ++ " " ++ show (a+b+d)
13:58:37 <lambdabot>   <no location info>: parse error on input `='
13:58:45 <jlouis> ion: heh
13:58:45 * hackagebot hashed-storage 0.5.9 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5.9 (PetrRockai)
13:58:45 <monochrom> @let myfun4 (a,b,c,d) = show c ++ " " ++ show (a+b+d)
13:58:45 <lambdabot>  Defined.
13:58:53 <pinko> @<monochrom> I am just trying to understand the anguage not trying to solve a specific problem..
13:58:54 <lambdabot> Unknown command, try @list
13:58:56 <monochrom> > myfun (1, 2, 'x', 3)
13:58:57 <lambdabot>   Couldn't match expected type `(t, t1)'
13:58:57 <lambdabot>         against inferred type `(t11,...
13:59:02 <monochrom> > myfun4 (1, 2, 'x', 3)
13:59:02 <lambdabot>   "'x' 6"
13:59:16 <monochrom> I'm giving you examples of the language, not solving any problem.
13:59:26 <jlouis> ion: it should not be that hard to separate out. Process.hs is what needs to be extracted
13:59:29 <monochrom> look at myfun4
14:00:34 <monochrom> if I were solving a specific problem, I would have made you made a payment first.
14:00:38 <pinko> but yo need to implement yourself that function
14:01:00 <monochrom> you are implementing some function too.
14:01:25 <pinko> no i m trying o use a predefined haskell function
14:01:46 <pinko> to get the first element of a n-tuple if it exists
14:01:52 <monochrom> sure. but you have to write your own function to use a predefined function
14:02:01 <pinko> if not you clearly have to implement it yourself
14:02:32 <pinko> even to use it in the command inrterperter
14:02:39 <monochrom> please don't talk about n-tuples. please pick one specific number for n, like 4, and talk about 4-tuples
14:02:40 <pinko> like head [1,2,3,4]?
14:02:48 <monochrom> [1,2,3,4] is not a tuple
14:03:19 <pinko> i got that but you can use head in the command iterpreter
14:03:33 <pinko> no need to define a function to use head as you stated previously
14:03:34 <monochrom> sure.
14:04:47 <monochrom> tuple does not work like list
14:04:52 <pinko> i am asking this elementary questions because i am going through the online tutorial
14:05:21 <pinko> trying to understand the difference between using (1,2,3,4) rther than  [1,2,3,4]
14:05:29 <monochrom> you can write one function that works for 2-tuple. you can write one function that works for 3-tuple. you can't write a function that works for both.
14:05:45 <monochrom> different type. that is all.
14:06:19 <pinko> ok .. so when do you use one the tuples then.. in which scenarios?
14:06:22 <monochrom> deeper than different type. different data structures altogether
14:07:06 <monochrom> when I want to use a record but too lazy to define my own record type.
14:07:30 <pinko> ok got it
14:07:42 <monochrom> the type (Int, Bool) is a record with an Int field and a Bool field but they have no names and I'm too lazy to name them.
14:12:25 <applicative> pinko, the difference between (1,2,3,4) and [1,2,3,4] is that there is such a thing as (1,"two", [(),(),()], Data.Text.pack "IV"), but no such thing as [1,"two", [(),(),()], Data.Text.pack "IV"]
14:15:11 <DrSyzygy> applicative: Also that (1,2,3) is not the same type as (1,2,3,4); while [1,2,3] and [1,2,3,4] do have the same type.
14:16:25 <monochrom> I highly recommend the stance "things are unrelated until proven related" and against "things are related until proven unrelated"
14:16:50 <monochrom> the latter is royally inefficient and painful for others
14:17:31 <applicative> DrSyzygy, yes, and (1,2,3) is to (1,2,3,4) as (1,2,3) is to (1,2,3,"four""), etc.
14:19:29 <applicative> monochrom, I suppose the relation between (...,...,...) and [...,...,...] is close, for familiar reasons, though I'm not sure how to state them
14:20:01 <monochrom> they are both data structures. that's one weak relation
14:20:29 <hpc> so i have mueval installed now, but when i compile my website i get the following linker error:
14:20:29 <monochrom> they are both containers, very broadly speaking. that's another weak relation.
14:20:32 <hpc> error: undefined reference to 'pthread_sigmask'
14:20:34 <applicative> a list is an any-length-tuple.
14:20:39 <applicative>  but you can only consider the sum type : tuple of any length, by committing to a type that's being tupled.
14:20:52 <applicative> or something like that, no?
14:21:00 <aristid> applicative: lists also restrict all elements to have the same type
14:21:04 <hpc> the problem is something to do with HDBC-mysql-0.6.5.0
14:21:10 <hpc> when i run the scripts in ghci they run fine
14:21:20 <applicative> aristid, that's what I'm saying, maybe ineptly
14:21:37 <Philippa> applicative: When you do the n-tuple to 2-tuple+() conversion, you get a cons list
14:21:51 <monochrom> if you know statically that you want a sequential container of 100 things, no more no less, and the elements are all of the same type, you have the choice of using either 100-tuple or 100-list, both can be made to work. that's another weak relation.
14:21:52 <aristid> applicative: certainly not in a way that i understood :)
14:21:59 <Philippa> (but one that's reflected at the type level as well)
14:22:25 <monochrom> those are all the relations, and they are pretty weak boring ones.
14:23:28 <applicative> data Pair a b = Pair a b , newtype List a = List (Pair a (List a))
14:23:47 <applicative> wrong sorry, how to put it right
14:23:48 <Philippa> applicative: doesn't quite work, you've got no nil
14:23:52 <applicative> yes
14:23:59 <DanBurton> That would be an infinite stream
14:24:03 <monochrom> if you go to Perl, you unify tuple and list. that's a stronger relation. but it sucks.
14:24:12 <Philippa> you need a typeclass to encode the right "kind" at the moment
14:24:15 <applicative> it's a muddle yes
14:24:26 <mauke> monochrom: perl has neither tuples nor lists in the haskell sense
14:24:50 <Philippa> it's got no static types, so how could it? :p
14:25:01 <mauke> it has syntactic types
14:25:26 <mauke> Philippa: as for how, see lisp or python
14:25:44 * applicative was only wanting to say that it's not silly for pinko to fret about the list vs. tuple question, about the connection
14:25:51 <Philippa> eh, I was just prodding you about the need to state what kinds of encodings are allowed and how natural they have to be
14:25:54 <applicative> and disconnection
14:26:14 <mauke> np: Air - Alpha Beta Gaga
14:26:27 <Philippa> the static typing bit being about the former, of course
14:26:34 <monochrom> silly no. inefficient and painful.
14:26:53 <Philippa> (see lisp? I've implemented one)
14:27:48 <hpc> can anyone here help me figure out how to get hdbc-mysql to link properly? it works in ghci but not when i compile
14:27:48 <monochrom> especially painful to those who bother to answer the questions.
14:28:33 <mauke> hpc: what's the error?
14:28:53 <hpc> /usr/bin/ld: /usr/local/lib/HDBC-mysql-0.6.5.0/ghc-6.12.1/libHSHDBC-mysql-0.6.5.0.a(RTS.o):(.text+0x366): error: undefined reference to 'pthread_sigmask'
14:29:15 <hpc> (and again at (.text+0x3c7))
14:29:41 <mauke> does compiling with -threaded make a difference?
14:29:50 <monochrom> someone answers the question honestly and truthfully. it is mean of the asker to cross-interrogate the answerer "but look over there for that 'related' thing, doesn't fit what you say" like a defense lawyer trying to prove the witness lying
14:30:04 <hpc> trying
14:30:22 <hpc> mauke: oh cool! thanks
14:30:25 <Philippa> monochrom: eh. Copping that there's a relationship and then moving to the differences is the right thing
14:30:51 <mauke> hpc: it worked? cool
14:30:54 <Philippa> it may be mean of the asker, but it's mean of an answerer to claim there's no relationship when there's as strong a one as there is here
14:31:06 <hpc> mauke: you sound surprised lol
14:31:15 <mauke> it was a blind guess
14:32:28 <applicative> pinko,  List a = () | (a,(List a) is the best I can do to bring them together, in half-Haskell. Maybe monochrom is right.... :)
14:32:34 <Philippa> (stating early on "there is no type of n-tuples" would've been a good move)
14:32:44 <monochrom> oh, copping that there is a relationship and then moving to the differences is right, sure. but what happens is that the asker is not moving to the differences, only the answerer is.
14:33:24 <monochrom> when the answerer says "my answer is not supposed to fit the other thing" he/she is moving to the differences
14:33:29 <Philippa> applicative: you need GADTs or type classes to do better
14:33:51 <applicative> Philippa, yes. I was thinking ineptly : you could make something like the sum type: "n tuples, for any n" on condition that only one type is being 'tupled'
14:34:02 <monochrom> when the asker says "your answer does not fit the other thing, I reject your answer" he/she is not moving to the differences
14:34:23 <Philippa> monochrom: yeah, but there's a difference between "not supposed to" and "can't". Taking the former to mean the latter is often a bad idea given the prevalence of "lies to children"
14:34:32 <Philippa> (that is: untruths and half-truths used for teaching purposes)
14:35:11 <monochrom> oh, you like "can't"? then I'll use "can't"
14:35:24 <alpounet> or just continue this to -blah
14:35:25 <applicative> monochrom, but this means you are forgetting learning about it yourself, it seems to me.  I remember being mystified.
14:35:25 <monochrom> when the answerer says "my answer can't fit the other thing" he/she is moving to the differences
14:35:50 <Philippa> alpounet: -overflow, but fair comment
14:35:55 <Philippa> monochrom: -overflow?
14:35:59 <monochrom> I remember learning about it myself. I assumed no relation between tuple and list since day 0.
14:36:33 <applicative> you must have seen it often enough to know that this is a private peculiarity
14:36:36 <hpaste_> alexdavey pasted “Factors” at http://hpaste.org/52351
14:38:17 <Eidel> why cant i do "div 2.0 1.0" ?
14:38:47 * hackagebot splaytree 0.1.1 - Provides an annotated splay tree  http://hackage.haskell.org/package/splaytree-0.1.1 (JohnLato)
14:38:56 <alpounet> Eidel, div words on Integrals
14:39:06 <alpounet> works*
14:39:22 <alpounet> Eidel, don't you want / ?
14:39:47 <Eidel> alpounet: seems to work
14:40:03 <alexdavey> Hi, this is my first day using haskell, so I apologise if this is a stupid question: I have written a simple function (http://hpaste.org/52351) which works, however is there a way to call the recurring function directly, with only the one argument instead of proxying through a second function?
14:40:31 <alpounet> Eidel, div is more for "integer-like types"
14:41:06 <Eidel> alpounet: ok. Good to know :)
14:41:58 <alpounet> alexdavey, you can use "where" to define factors' inside factors
14:42:52 <alpounet> that's usually how it's done: the "helper" function that actually does the recursion gets to be defined inside a bigger one that will be exposed
14:43:30 <desaiu> let f 1 = 1
14:43:32 <desaiu> let f 2 = 1
14:43:42 <ion> jlouis: What i’d like to implement is a wrapper that keeps a Minecraft server running (a system command: java -jar …) and controls it via its stdin and stdout. It should tell the Minecraft server to stop writing to its world database for the time it takes to make a periodical backup of the world (one thread/process) as well as a graphical world map (another thread/process). Those two should be killed if the Minecraft server dies for any reason and restarted when the
14:43:49 <desaiu> let f _ = f (n-2) + f (n-1)
14:43:51 <ion> server is running again. I’d also like to have an process that maintains a connection to IRC and another process that depends on that and the Minecraft process in order to send the discussion and other messages from one to another. I have no need for multiple nodes. Erlang has the process/IPC/supervisor stuff but i haven’t found a good way to supervise a system command and provide an interface to its stdin/stdout. open_port/spawn_executable doesn’t make sure the
14:43:56 <hpaste_> applicative annotated “Factors” with “Factors (annotation)” at http://hpaste.org/52351#a52352
14:43:59 <ion> system process is killed if a linked Erlang process dies and erlexec doesn’t provide an interface to stdin/stdout (and apparently doesn’t want to compile either), and Erlang itself doesn’t seem to provide low-level interfaces like System.Process. I guess your Haskell process/supervisor stuff should work well enough for this if it works well enough for CombinaTorrent.
14:44:07 <ion> Wow. That was a long message. Sorry for the flood. :-)
14:44:11 <desaiu> <interactive>:1:23: Not in scope: `n'
14:44:32 <alpounet> desaiu, replace "_" by "n"
14:45:18 <desaiu> I wish I knew how to verify this does what I want it to
14:45:29 <desaiu> Also, thank you alpounet
14:46:02 <hpaste_> applicative annotated “Factors” with “Factors (annotation) (annotation)” at http://hpaste.org/52351#a52353
14:46:45 <applicative> alexdavey: I couldn't get the first one to type check which accounts for my first revision.  Are you trying to avoid 'where' as well?
14:48:23 <alexdavey> I'm not trying to avoid 'where'.
14:49:20 <desaiu> let f n = print (f (n-2) + f (n-1)))
14:49:24 <desaiu> > let f n = print (f (n-2) + f (n-1)))
14:49:25 <lambdabot>   <no location info>: parse error on input `)'
14:49:36 <desaiu> > let f n = print (f (n-2) + f (n-1))
14:49:37 <lambdabot>   not an expression: `let f n = print (f (n-2) + f (n-1))'
14:49:49 <ski> alpounet : "the \"helper\" function .." -- this is sometimes called "worker-wrapper"
14:50:25 <alpounet> yeah right, thanks
14:50:27 <applicative> alexdavey, there might be a more direct approach in this case, but the kind of definition you are making is very sound,
14:51:10 <alexdavey> Your revision works, thank you for all of the replies. Out of interest, does defining the worker-wrapper inside the parent function have an increased overhead?
14:52:24 <hpaste_> b pasted “mauke's code” at http://hpaste.org/52354
14:52:41 <applicative> alexdavey, rather than have two top level functions as you first did?
14:53:01 <desaiu> That was my translation of mauke's code
14:53:10 <hpaste_> mauke annotated “mauke's code” with “mauke's code (annotation)” at http://hpaste.org/52354#a52355
14:53:34 <alexdavey> @applicative Yes. Isn't the worker-wrapper being defined on every function application?
14:53:34 <lambdabot> Unknown command, try @list
14:54:16 <quackquack> Is there any way to apply parameters to QuickCheck's randomization? for example, only use integers greater than 0 for a certain function?
14:54:44 <mauke> wasn't there something like x > 0 ==> f x?
14:54:59 <applicative> alexdavey, on the simple model of unoptimized execution that gives the 'meaning' the only difference is that you can also use the separately defined function elsewhere
14:55:21 <quackquack> mauke: would that be right after the definition of `f`?
14:55:49 <mauke> quackquack: no, in the test
14:56:05 <applicative> alexdavey, either way, to calculate factors 1882 I'm going to have to calculate a lot of commonFactors
14:57:41 <alpounet> applicative, won't the worker-wrapper most likely get inlined anyway ?
14:58:06 <jlouis> rawr
14:58:15 <quackquack> mauke: could you link to an example use case? im having trouble getting the usage right
14:58:36 <mauke> quackquack: sorry, I've never used quickcheck
14:58:56 <jlouis> ion: it should work, but since it is Haskell, processes are not dying at the same rate as in Erlang :P
14:59:00 <applicative> alpounet: you can put INLINE pragmas over things introduced by where, or maybe I'm not following.
15:00:18 <hpc> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
15:00:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:00:28 <alpounet> applicative, no i mean wouldn't ghc inline this by itself ?
15:00:35 <alpounet> quackquack, see the first answer here http://stackoverflow.com/questions/7693930/generating-a-lists-of-a-specific-length-with-haskells-quickcheck
15:00:39 <ion> jlouis: “Make sure the dependent processes are killed and restarted when necessary, i don’t care about the rate” is enough for me. And i’m only going to need a small number of processes overall.
15:01:10 <quackquack> alpounet: ty!
15:02:53 <applicative> alpounet, but it inlines all kinds of things. I was only thinking of this case, since I don't know enough about the general principles.  I will make a half baked test...
15:04:08 <alpounet> http://hackage.haskell.org/trac/ghc/wiki/Inlining
15:05:43 <dschoepe> If I wanted to "index" an existing data type with some additional type information (e.g. whether a FilePath is absolute or not), is there a more convenient way than wrapping it in a new data type and having to wrap/unwrap it everywhere else?
15:08:11 <alpounet> dschoepe, iirc edwardk has written a package for this
15:08:54 * hackagebot splaytree 0.1.2 - Provides an annotated splay tree  http://hackage.haskell.org/package/splaytree-0.1.2 (JohnLato)
15:09:11 <alpounet> dschoepe, here it is: http://hackage.haskell.org/packages/archive/tagged/0.2.3.1/doc/html/Data-Tagged.html
15:11:26 <dschoepe> alpounet: Thanks, that does what I'm currently doing as well. I still have to call unTagged everywhere the untagged type is expected though. I think what I'm looking for would require a language extension anyway..
15:11:56 <dschoepe> (And I'm not really sure I really thought it through)
15:12:10 <alpounet> yeah or with some typeclass hackery
15:12:31 <applicative> alpounet I can't seem to make it matter in this case
15:15:03 <alpounet> ok
15:15:13 <alpounet> with -O it should get inlined though
15:15:35 <alpounet> or maybe not, since it's recursive
15:15:40 <alpounet> don't remember the precise rules
15:15:58 <alpounet> i put an INLINE pragma when it matters anyway
15:21:22 <saml> hello can i help u
15:22:26 <applicative> yes, the auxiliary is recursive. nice page from the ghc wiki.
15:23:09 <erus`> It would be really great if the talks from this years icfp were put of the haskell vimeo channel
15:23:42 <quackquack> is their any way to get a list of the functions in a module?
15:25:41 <erus`> quackquack: if your lucky it will name them at the top
15:25:47 <erus`> inside the brackets
15:25:59 <geheimdienst> quackquack: in ghci, try ":browse Control.Applicative". another approach would be to get your hoogle db up-to-date (if necessary) and use that
15:26:00 <applicative> quackquack, how do you mean, there is :browse inside ghci
15:26:11 <geheimdienst> "hoogle --dump" or some such
15:26:31 <quackquack> the reason I want it is I have test cases in multiple files and I just want to iterate the functions from the main module
15:29:08 <monochrom> probably use :browse and then manually cut, paste, write test for each function shown
15:30:51 <geheimdienst> quackquack: programmatically getting a list of functions sounds like you'd need the ghc api, and for that use you probably don't want that
15:31:14 <monochrom> ghc api may be overkill. unless you do it everyday
15:31:36 <monochrom> ghc api has its learning curve, too
15:31:37 <geheimdienst> however this thing seems to be able to help you via a preprocessor. i haven't used it myself yet, but have a look at it: http://hackage.haskell.org/packages/archive/HTF/0.3/doc/html/Test-Framework-Tutorial.html
15:31:43 <quackquack> ok, thanks
15:31:52 <geheimdienst> monochrom: yeah, that's what i'm saying
15:37:14 <Cale> @bot
15:37:14 <lambdabot> :)
15:38:01 <saml> @tob
15:38:02 <lambdabot> Maybe you meant: do thx todo yow
15:38:11 <saml> @plus
15:38:12 <lambdabot> Maybe you meant: flush pl
15:39:32 <applicative> quackquack: hah, here is a little command line export browser, following the typeof package
15:39:45 <hpaste_> applicative pasted “export browser (cp typeof)” at http://hpaste.org/52357
15:40:07 <saml> that's not good haskell
15:40:11 <saml> you are mixing IO
15:48:40 <parcs> what's UnkSkol?
15:48:50 <parcs> i'm getting that in some fundep code
15:49:02 <parcs> in an error in some fundep code*
15:53:37 <monochrom> haven't heard of it. may be defined by the library author
15:54:49 <parcs> i'm not using any library
15:55:44 <monochrom> "unknown skolem"? but I still don't know what it means
15:57:35 <augur> koninkje: are you non-away?
15:58:58 <augur> koninkje: yes, (14) was supposed to be an example of how english necessitates gapping -- 14 doesn't have gapping of the verb, and is horrible, but if you gap the verb, its fine
15:59:08 <cads> Has anyone played around with the CUDA binding?
15:59:54 <applicative> parcs, check out 'data SkolemInfo' https://github.com/ghc/ghc/blob/66a733f23eebbd69f6e2d00a9f73c4d5541b5c39/compiler/typecheck/TcRnTypes.lhs
16:00:14 <applicative> "  | UnkSkol             -- Unhelpful info (until I improve it)"
16:01:01 <cads> was reading a paper on data parallel arrays in haskell, and that reminded me of cuda. A quick check found this library: http://hackage.haskell.org/package/cuda
16:01:35 <parcs> applicative: cool
16:01:40 <parcs> does that mean i broke ghc?
16:01:54 <ddarius> Probably.
16:02:42 <applicative> I was just thinking you should lay off the skolem.
16:04:57 <cads> The paper I read is described here http://justtesting.org/regular-shape-polymorphic-parallel-arrays-in
16:05:06 <parcs> ok so i know what breaks it
16:05:12 <applicative> parcs is it the error mentioned in the next bit, "pprSkolInfo: UnkSkol"
16:05:59 <parcs> applicative: no, it's Couldn't match type `True' with `False' When using functional dependencies to combine Not True False, arising from UnkSkol at <interactive>:1:1-33 ...
16:05:59 <cads> it's kind of impressive, they get safe multidimensional arrays that tacitly make use of whatever number of processors are available (if I understand things correctly)
16:06:41 <parcs> and i fixed it by changing a fundep from | -> a b to | a -> b
16:06:44 <applicative> I see, so not the warning that comes up a few lines on, line 1075
16:07:24 <parcs> no
16:09:11 <cads> I see that the cuda library is mostly a wrapper for nvidia's API, and I that makes me wonder a rather naive question.
16:09:40 <cads> Naive because I don't know much about either cuda or data parallel haskell.
16:10:12 <cads> But, do you guys think it could be possible use the data parallel haskell approach to directly compile code for the cuda machine?
16:18:55 <ddarius> @google accelerate Chakravarty
16:18:57 <lambdabot> http://www.cse.unsw.edu.au/~chak/project/accelerate/
16:18:57 <lambdabot> Title: Manuel M T Chakravarty - Data.Array.Accelerate
16:25:58 <shirt> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#v:catch
16:26:14 <shirt> '... see the previous section "Catching all exceptions"'
16:26:19 <shirt> There is no such section in that page!
16:26:29 <cads> thanks ddarius :)
16:27:26 <cads> 'm watching one of Chakravarty's talks, and he's doing a great job at getting me really excited about this stuff :D
16:28:42 <gtirloni> hi, i've just started learning Haskell and I'm confused about something in type signatures.. what are the [a] and [b] I often see instead of a type?
16:28:51 <Twey> gtirloni: Types
16:29:05 <Twey> [a] is the type of lists with elements of type a
16:29:40 <Twey> :t [1 :: Int, 2 :: Int, 3 :: Int]
16:29:41 <lambdabot> [Int]
16:29:48 <Twey> :t [1, 2, 3]
16:29:49 <lambdabot> forall t. (Num t) => [t]
16:30:09 <monochrom> another example:
16:30:18 <monochrom> :t [True, False, False]
16:30:19 <lambdabot> [Bool]
16:30:30 <quackquack> are there any projects on github that use quickcheck? im looking for some examples..
16:30:35 <monochrom> [Bool] is the type of [True, False, False]
16:30:40 <gtirloni> ah ok, got it. thanks a lot Twey and monochrom
16:32:08 <ski>   length :: [a] -> Int
16:32:38 <ski> gtirloni : that means that `length' can take an argument of type `[a]' (i.e. a list with elements of type `a'), for *any* type `a'
16:33:23 <ski> e.g. `a' can be `Int' or `Bool', as above, but also other types, and more complicated things like `(String,[(Bool,Int,Int -> IO ())])'
16:33:59 <ski> gtirloni : the `a' itself it a "type variable", it can stand in for any (concrete) type, like the examples just mentioned
16:34:34 <jampart> is there a rule against making a synonym for a record type?
16:34:43 <ski> no
16:35:46 <gtirloni> ski: thx. is 'a' a convention or it's defined in the language? would [b] have the same effect?
16:35:52 <gtirloni> or [z] for that matter
16:36:20 <dschoepe> gtirloni: anything starting with a lowercase letter is a type variable
16:36:44 <dschoepe> (or an underscore, I believe)
16:37:36 <jampart> then why doesn't this work: type hi = { bye :: String } ?
16:37:43 <jampart> s/hi/Hi
16:37:47 <dschoepe> gtirloni: Everything else is convention, so yes, [b] would work just as well.
16:38:00 <Twey> jampart: Because that's defining a new type, not creating a synonym
16:38:09 <ddarius> That's just a syntax error.
16:38:15 <Twey> And a syntax error.
16:38:31 <ski> gtirloni : the only important part about type variables in a type signature is where you use the same type variable, and where you don't
16:38:32 <gtirloni> ok
16:38:35 <Twey> data Hi = Hi { bye :: String }; type Hello = Hi
16:38:41 <ski> gtirloni : e.g.
16:38:45 <jampart> sorry, I meant :  type Hi = { bye :: String }.  This still doesn't work.
16:38:50 <ski>   take :: Int -> [a] -> [a]
16:38:52 <ski> is the same as
16:38:53 <Twey> Still a syntax error
16:38:56 <ski>   take :: Int -> [b] -> [b]
16:39:03 <ski> but is *not* the same as
16:39:05 <ski>   take :: Int -> [b] -> [a]
16:39:06 <dschoepe> jampart: record types are only allowed in conjunction with a constructor.
16:39:12 <ski> gtirloni : ok ?
16:39:28 <gtirloni> ok, thx for the example. perfectly clear now
16:39:28 <Twey> You can't have a bunch of fields that aren't associated with any constructor
16:39:52 <jampart> Well that's what I was asking in my original question. :-)
16:39:59 <dschoepe> jampart: data Foo = Foo { x :: a, ... } can be thought of as syntactic sugar for data Foo = Foo a and f (Foo a) = a
16:40:16 <Twey> (plus the update magic)
16:40:21 <ski> gtirloni : also, the type variables in one type signature are unrelated to the ones in another (normally, there's some not so common exceptions, when having definitions inside other definitions .. also `class' declarations are relevant here)
16:40:32 <jampart> dschoepe: yes fine.  But my original question was answered 'no' when it should have been answered 'yes'.
16:40:38 <jampart> Anyhow, I'm good to go now.  Thanks to all.
16:40:59 <ddarius> ski: There isn't an exception with definitions inside of other definitions.
16:41:19 <ddarius> Unless you enable lexically scoped type variables.
16:41:27 <ski> ddarius : yes, that was what i had in mind
16:41:40 <dschoepe> jampart: I think there was confusion on what was meant by record type.
16:42:02 <jampart> dschoepe: I'm curious about what else it could have meant (?)
16:42:13 <shirt> i'm confused about Data.Text.Encoding, the docs seem to hint that encoding cannot fail, but there are types for dealing with encoding errors. what's going on?
16:42:21 <ddarius> Really, I think it was/is a mistake that type variables aren't lexically scoped.  I also think that Haskell should have just always required explicit foralls.
16:42:22 <dschoepe> jampart: A type defined using the special record syntax Haskell offers.
16:42:39 <jampart> Is { bye :: String} not an example of that special record syntax?
16:42:46 <dschoepe> Haskell doesn't have "actual" record types as in, e.g. TAPL
16:43:02 <ddarius> jampart: It's an example of a constructor using record syntax, but it isn't a type.
16:43:03 <dschoepe> jampart: yes, but not a type.
16:43:07 <erus`> why are record syntax functions not first class?
16:43:18 <ddarius> erus`: They are.
16:43:24 <jampart> So you're both saying that the curly-brace syntax is just sugar.
16:43:28 <ddarius> I think you want to know why the fields aren't.
16:43:50 <ddarius> jampart: { bye :: String } doesn't have meaning on its own.
16:43:50 <jampart> (Right?)
16:43:58 <dschoepe> jampart: Yes
16:44:03 <erus`> ddarius: is it not the same thing?
16:44:14 <jampart> OK, thanks for clarifying.
16:44:26 <ski> jampart : there *is* no rule against making a synonym for a record type .. the `data Hi = Hi { bye :: String }; type Hello = Hi' example by Twey shows that
16:45:02 <jampart> I'm sorry I missed that ... could you show it to me again?
16:45:15 <jampart> "data Hi etc" is not a type synonym.
16:45:20 <ski> jampart : but you have to understand that the current record type system in Haskell is just syntactic sugar over ordinary algebraic `data'-types (well, `newtype' works as well)
16:45:41 <ski> jampart : `Hi' is a record type, `Hello' is a synonym of that record type
16:45:42 <dschoepe> Was there ever discussion about why there are no "first-class" record types in Haskell? By first class record type I mean { foo :: String } being a type just like e.g. (String, String) is?
16:45:53 <mm_freak> erus`: fields create functions, which are first class, but you can't say, for example:  f field x = x { field = something }
16:45:53 <jampart> Ah... I see.
16:46:00 <dschoepe> (I can't imagine them being particularly useful anyway, though)
16:46:04 <ddarius> erus`: The accessors of a record type generated by the fields are just functions like any other.  It's only in record construction/matching/update that the fields are special and in those place they aren't "first-class" since you can't put expressions or arbitrary patterns there.
16:46:10 <mm_freak> erus`: though it would be great if you could
16:46:30 <erus`> yeah thats what i mean :)
16:47:04 <mm_freak> erus`: you have to work either with selectors/modifiers or with lenses
16:47:08 <erus`> i haven't needed to use record syntax for a while lately though... I think my programming style has changed
16:47:14 <mm_freak> the fclabels package provides lenses, which is convenient
16:47:18 <ddarius> dschoepe: To do stuff like that reasonably requires adding quite a bit more to the language.  See Hugs' TREX for a simple example.
16:47:43 <mm_freak> erus`: lenses allow you to isolate parts of a structure like individual record fields
16:47:47 <jampart> ski: OK, but I'm still tempted to disagree, as I wouldn't really call Hi a record type.
16:48:09 <ddarius> jampart: Why not?
16:48:21 <jampart> It looks more like a *wrapper* for a record type.
16:48:37 <ski> dschoepe : see "The Hugs 98 User Manual - 7.2 - Extensible records: Trex" at <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.2> for an example of an alternative (and more flexible) record system
16:49:22 <jampart> But I guess you're saying that the Hi-like construction is really the only way to define record types.  So I guess I should concede the point...
16:49:25 <ddarius> jampart: Then you don't understand what is going on, though the use of Hi as both the type and data constructor may be adding to your confusion here.
16:50:09 <jampart> ddarius: No, I'm clear about the two different roles that Hi plays (as type and as constructor).  But I think my previous line shows that I sort of understand now.
16:50:23 <ion> :q
16:50:27 <ski> dschoepe : btw, "{ foo :: String } being a type just like e.g. (String, String) is" would be an example of a *light-weight* record system (of which TREX is an example)
16:50:27 <ion> whoops
16:50:52 <ski> ion : trying to QUIT on us, ARE YOU ?!?
16:50:57 <ddarius> ZZ
16:51:20 <ion> ski: No, trying to quit on a completely unrelated file. :-P
16:51:30 <dschoepe> ski, ddarius: Thanks for the information; Trex looks like what I had in mind (and a bit more).
16:51:34 <ion> With me being too tired to notice which window is active.
16:52:19 <ion> sleep →
16:52:55 <ski> dschoepe : also check out (the cool) "The Hugs 98 User Manual - 7.3.5 - Restricted type synonyms" at <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5>, while you're at it ! :)
16:53:36 <dschoepe> ski: Yeah, I was just reading that, since it surprised me that Hugs had features GHC didn't. :)
17:01:57 <quackquack> any good high-level http clients for haskell?
17:02:07 <saml> HTTP
17:02:14 <tkahn6> http-enumerator
17:02:29 <saml> http://hackage.haskell.org/package/HTTP
17:02:36 <saml>  rsp <- Network.HTTP.simpleHTTP (getRequest "http://www.haskell.org/")
17:02:39 <koninkje> augur: yes, though apparently I'm not exactly here either...
17:02:50 <augur> koninkje: !
17:02:51 <augur> hey :)
17:02:58 <koninkje> augur: I'd mark #14 with an * then
17:03:01 <tkahn6> http-enuemrator is much better than network.http
17:03:10 <koninkje> or a #, %, etc
17:03:12 <tkahn6> it handles redirects for you
17:03:18 <augur> koninkje: yeah, i realized its confusing when you said that earlier
17:03:19 <tkahn6> and handles https
17:03:26 <augur> anyway, koninkje, i want your opinion on determiner sharing
17:03:41 <koninkje> On the paper's analysis you mean?
17:04:22 <koninkje> I think you're right that it's closely connected to gapping constructs
17:04:22 <byorgey> @tell cicatristeza hey, I hear you were interested in talking to me (author of the oeis package).  Feel free to ping me anytime.
17:04:22 <lambdabot> Consider it noted.
17:04:47 <koninkje> Though, the way I think about it is more like an "anti-gapping" if that makes sense
17:05:03 <augur> koninkje: no i just mean on how you would handle it
17:05:07 <saml> byorgey, are you author of LLVM?
17:05:17 <augur> i mean, we know empirically its connected to gapping
17:05:20 <koninkje> i.e., the second conjunct is a copy of the first, but with the changes highlighted (and pronounced)
17:05:37 <saml> http://hackage.haskell.org/package/llvm  this one. it does not compile on windows
17:05:38 <koninkje> I'd just handle it in CCG :)
17:05:39 <augur> koninkje: sure, however you want to construe gapping.
17:05:43 <augur> koninkje: yeah, but _how_
17:05:56 <Twey> Does LLVM work on Windows?
17:06:02 <augur> i dont have a CCG parser so i cant play with it to see if CCG can even parse these D-sharing sentences
17:06:15 <koninkje> augur: how do you mean? On the semantic side or the syntactic side?
17:06:22 <koninkje> ah
17:06:40 <koninkje> You could check out OpenCCG or CnC's parser
17:06:55 <saml> Twey, yes. if i use C++
17:07:10 <saml> i can compile LLVM with mingw gcc distribution
17:07:15 <quackquack> tkahn6: ty!
17:07:19 <saml> with cmake to generate mingw makefiles
17:07:22 <augur> koninkje: care to guide me through them? :x
17:07:37 <ski> koninkje : which paper is this ?
17:07:39 <tkahn6> quackquack: np gl
17:07:43 <koninkje> augur: I haven't used them myself, but I can try :)
17:07:48 <saml> it looks like haskell llvm binding needs MS VisualStudio libraries  on windows
17:07:53 <augur> koninkje: well what do you use?
17:07:54 <koninkje> ski: it's augur's paper
17:08:05 <augur> koninkje: we should make a web-based CCG parser btw.
17:08:18 <koninkje> augur: So far I haven't actually run a CCG parser; so it's all in my head / on paper
17:08:22 <augur> ahh
17:08:30 <ski> augur : whence to get that paper ?
17:08:32 <augur> well! try to find a parse!
17:08:43 * ski wonders whether that's correct english
17:08:43 <koninkje> augur: Indeed. Larry Moss was looking for one of those this semester, to show to his students
17:08:44 <stribor> guys is it posible that using guards one can do following | a == 1    = 5 | otherwise    = "some error message"
17:08:48 <augur> ski: im rewriting, but the original is at http://wellnowwhat.net/linguistics/paper.full.pdf
17:09:35 <monochrom> yes it is possible
17:09:51 <monochrom> @undefine
17:10:10 <monochrom> @let myfun a | a==1 = 5 | otherwise = error "success"
17:10:11 <lambdabot>  Defined.
17:10:18 <monochrom> so, just put "error" there
17:10:25 <monochrom> > myfun 2
17:10:26 <lambdabot>   *Exception: success
17:10:31 <monochrom> success!
17:10:33 <augur> koninkje: we's probably want to permit modalities no?
17:11:00 <koninkje> augur: Now that I look at it, I'd probably want to adopt the continuation-based work of Ken Shan and Chris Barker for this; to match the intuition I presented earlier
17:11:20 <koninkje> augur: Modalities would be the standard answer, no doubt
17:11:22 <augur> koninkje: type lifting is continuizing
17:11:34 <koninkje> but I'm not especially fond of modalities; it feels too hackish
17:11:47 <ski> @let yourFun 1 = 5; yourFun _ = error "success"
17:11:48 <lambdabot>  Defined.
17:11:52 <stribor> monochrom: thank you
17:11:53 <augur> tho maybe you mean continuizing at the core denotations
17:11:54 <ski> > yourFun 2
17:11:55 <lambdabot>   *Exception: success
17:11:57 <ski> stribor ^
17:12:07 <augur> koninkje: but i dont care about the denotations right now, i just want to make it parse, sans semantics
17:12:08 <koninkje> augur: I was meaning more the parasitic scope type things
17:12:20 <monochrom> well, there are times it's really a guard rather than rewritable as patterns
17:12:25 <ski> augur : ty
17:12:38 <augur> ski: np
17:12:52 <monochrom> funny x | a==1 = 5 | otherwise = error "success" where a = x*x
17:13:32 <monochrom> also camel case die die die
17:13:54 <edwardk> whyDon'tYouLikeCamelCase?
17:14:25 <edwardk> are_you_more_inclined_to_underscores?
17:14:28 <edwardk> or-to-dashes?
17:14:29 * ski was thinking a little on sentences like "Suroth drinks only *kaf*." and "Galgan leads all ships.", lately
17:14:39 <monochrom> underscore or dash or '
17:15:13 <monochrom> space too, if allowed
17:15:16 <Twey> camelCaseIsPrettyReaderUnfriendly
17:15:25 <Twey> hyphens-are-much-nicer
17:15:46 <tensorpudding> i_prefer_underscores
17:15:47 <ski> (or rather, about expressions which (very roughly) have "multiple solutions", for which those sentences would be natural language approximants)
17:16:04 <Twey> underscores_unbalance_the_typographical_colour
17:16:24 <monochrom> sometimes I have code "getChar" initially, later I change that to "hGetChar blah". to have to change "g" to "G" is annoying
17:16:34 * ski . o O ( `web-server/insta' )
17:16:44 <monochrom> similarly the reverse direction
17:16:46 <ski> monochrom : i agree that's ennerving
17:17:44 <monochrom> camel case is great for those who release only one version of their projects, ever.
17:17:56 <newsham> :%s/getChar/hGetChar/g
17:17:57 <BlackHawk> hello
17:18:28 <BlackHawk> %s/getChar/hGetChar/g
17:18:29 <DanBurton> monochrom: what do you prever over camel case then? lisp-style hyphenated all lowercase?
17:18:43 <DanBurton> or python-style underscore lowercase
17:19:24 <monochrom> if space is allowed, I use space; else if - is allowed, I use -; else if ' is allowed, I use '; else if _ is allowed, I use _
17:19:30 <dmwit> monochrom: The key is to only ever add suffixes. ;-)
17:19:32 <dmwit> getCharH
17:19:40 <monochrom> heh
17:19:47 * ski was just thinking exactly that
17:19:48 <newsham> you would rather type h get char ?
17:20:17 <ski> (dim minds think alike ?)
17:20:33 <monochrom> newsham, oftentimes %s/.../.../g is not what I want, either
17:20:34 <newsham> charGetH
17:21:11 <monochrom> actually, getchar and hgetchar are just fine.
17:21:48 <monochrom> so, if the empty string makes sense, I use the empty string; else if space is allowed, I use space; else if - is allowed, I use -; else if ' is allowed, I use '; else if _ is allowed, I use _
17:23:01 <mm_freak> getchar is not so fine for editors
17:23:15 <monochrom> eh? why?
17:23:23 <mm_freak> i have caps mode in emacs, which recognizes camelCase
17:23:36 <mm_freak> so i can jump word by word
17:23:56 <monochrom> not convinced of the benefit of jumping into the middle of getchar
17:24:20 <monochrom> I want the editor to jump from token to token, sure.
17:24:23 <mm_freak> you never jump into the middle of a word?
17:25:12 <mm_freak> i do that a lot, especially when removing prefixes or suffices or inserting something in the middle
17:25:18 <monochrom> not never, but the scenerio has to be peculiar
17:25:19 <mm_freak> or splitting camelcased words 
17:25:50 <mm_freak> i'm left of SomeWord, i press C-right, then C-del to delete the "Word"
17:26:26 <koninkje> augur: for a CCG parse you're going to need some way of explicitly characterizing gapping (that is, true gapping, as opposed to things rezulting from non-traditional constituents)
17:26:36 <mm_freak> similarly i'm right of SomeWord, C-left, C-bksp
17:26:52 <augur> koninkje: well, if you read my paper, non-traditional constituents _also_ come from gapping ;)
17:27:14 <monochrom> well, then, like I said, if the empty string doesn't make sense for the situation, I still have several other choices lined up
17:28:03 <koninkje> augur: If you have a gapping composition rule that takes B\A and C\B\G and returns C\A (with the semantics handling the threading of G) then it'll work by just applying the determinier last, after conjunction
17:28:34 <augur> koninkje: show me a proof tree?
17:28:48 <koninkje> augur: Things like "John made and Mary ate the cake" don't require a gapping analysis
17:29:00 <augur> koninkje: no they dont _require_ one
17:29:02 <augur> certainly
17:29:02 * hackagebot ruff 0.2 - relatively useful fractal functions  http://hackage.haskell.org/package/ruff-0.2 (ClaudeHeilandAllen)
17:29:04 * hackagebot gruff 0.2 - fractal explorer GUI using the ruff library  http://hackage.haskell.org/package/gruff-0.2 (ClaudeHeilandAllen)
17:29:20 <augur> and im not trying to address the sort of non-traditional constituents you get in right node raising
17:29:23 <mm_freak> monochrom: in any case, i think it's good to give the editor some clue of word bounds, if not for yourself, then for others
17:29:57 <monochrom> sure, I agree up to that much
17:31:01 <monochrom> whether "getchar" should be 1 or 2 words is like whether "programmensprachen" should be 1 or 2 words!
17:32:25 <mm_freak> programmiersprachen
17:32:44 <mm_freak> and yeah, german is kinda messed up in that regard
17:32:56 <mm_freak> but it's valid to write Programmier-Sprachen
17:33:10 * ski . o O ( swedish also does that thing )
17:34:41 <ski> (.. and some people get upset when others insert spaces in the middle of combined words, imitating english in that regard)
17:34:48 * ski is one of those
17:35:13 <geheimdienst> mm_freak: i think "word segmentation problem" is the name. i bet there's algorithms for that. it's needed for chinese and stuff on account of them not using spaces
17:35:23 * BrianHV is trying to program in haskell in obj-c. it's not working too well.
17:35:35 <byorgey> saml: uh, no, why would you think that?
17:36:08 <ddarius> The perennial question.
17:36:24 <BrianHV> am I saml?
17:36:36 <mm_freak> BrianHV: actually that can work…  though make your objects threads and turn your messages into a type, then you can use MVars, Chans, etc.
17:36:45 <ddarius> BrianHV: I would think you'd be able to answer that question yourself.
17:37:25 <mm_freak> BrianHV: the 'real' object oriented programming as it was originally meant is supported quite well in haskell
17:37:42 <BrianHV> mm_freak: as cool as that sounds, I think that requires more haskell-fu and obj-c-fu than I have at the moment. :)
17:37:45 <ddarius> I would not say that at all.
17:38:11 <ddarius> What object-oriented programming should have been is reasonably well supported by Haskell.
17:38:33 <BrianHV> I want an ADT and a pattern match. I'm ending up with a ton of classes. I don't think it's clearly better than the unfactored version of the code I was trying to refactor.
17:38:53 <mm_freak> BrianHV: it's not like you can send anyone anything
17:38:58 <mm_freak> you need to specify who can receive what
17:39:14 <mm_freak> of course you can make one giant message type, but then you could just as well use obj-c or erlang
17:39:51 <mm_freak> btw, you don't need any classes for that
17:40:18 <monochrom> a record of functions/values/IO-actions is usually pretty sufficient
17:40:21 <mm_freak> classes can be useful, if you want to create message families or abstract things out
17:40:35 <mm_freak> i agree…  passing actions is useful
17:40:48 <BrianHV> what I intended to communicate is that I'm writing obj-c, but I'm tempted to do it in a haskellish style. that's what's not working.
17:41:40 <monochrom> inheritance is where haskell becomes cumbersome. but then inheritance has much fewer legitimate use cases
17:41:49 <ddarius> BrianHV: I understood you, though your original statement wasn't the clearest.
17:42:00 <BrianHV> agreed. :)
17:42:02 <mm_freak> oh
17:42:23 <mm_freak> ok, then scratch my words =)
17:42:40 <mm_freak> monochrom: does obj-c even support inheritance?  does it even make sense?
17:43:27 <BrianHV> it does
17:43:55 <mm_freak> hmm, feels like mixing two almost unrelated concepts
17:44:35 <BrianHV> obj-c is pretty fully OO, in what I understand to be a pretty smalltalkish manner.
17:44:38 <monochrom> objective-c has inheritance. I know because I looked at a famous haskell binding of cocoa. template haskell was summoned to finish up the inheritance part
17:49:09 <JoeyA> When does the http://haskell.org/hoogle index get updated?
17:53:16 <monochrom> oh naughty naughty. System.Process.readProcess implements "output is read strictly" by... evaluate (length string)
17:54:03 <JoeyA> How is that naughty?
17:54:29 <ddarius> monochrom has refined sensibilities.
17:54:56 <monochrom> I don't like using length for that. I would rather write a specific consumer
17:55:29 <monochrom> the "evaluate" part is fairly OK
17:55:41 <JoeyA> Makes sense.
17:55:47 <JoeyA> If you have to store a list, you're doing it wrong.
17:56:07 <ClaudiusMaximus> > genericLength [1..500] :: Word8 -- wonder what the behaviour of length would be when it overflows, probably similar?
17:56:08 <lambdabot>   244
17:56:22 <JoeyA> ClaudiusMaximus: Word8 is overflowing
17:56:24 <JoeyA> > 500 :: Word8
17:56:24 <lambdabot>   244
17:56:31 <JoeyA> err
17:56:33 <JoeyA> right
17:56:43 <JoeyA> nvm
18:01:25 <ClaudiusMaximus> > let o LT = '-' ; o EQ = '0' ; o GT = '+' in map (o . flip compare 0) . iterate (* (18%19)) $ (15%17 :: Ratio Int)
18:01:27 <lambdabot>   "++++++++++++++++-+---+++---+-+-+----+-++-----+-+++--+-+-+++-+-------------...
18:04:54 <JoeyA> Is there an ASCII toLower function?  Or will I have to roll my own?
18:05:26 <JoeyA> Data.ByteString.Char8.toLower also changes a few characters in the 8-bit range that aren't ASCII.
18:05:30 <JoeyA> err, Char.toLower does
18:05:41 <JoeyA> > [x | x <- map toEnum [0..255], x /= toLower x]
18:05:42 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ\192\193\194\195\196\197\198\199\200\201\202\203...
18:05:58 <JoeyA> It's easy enough to write, I guess...
18:06:38 <ddarius> Char is a Unicode codepoint.
18:06:49 <JoeyA> Indeed.
18:07:04 <JoeyA> But the dns package switched from String to ByteString for its Domain type, and dnscache fails to build now.
18:07:25 <JoeyA> (which the ismtp package depends on)
18:07:42 <ClaudiusMaximus> > let isASCII c = ord c < bit 7 ; toLowerASCII c | isASCII c = toLower c | otherwise = c in [x | x <- map toEnum [0..255], x /= toLowerASCII x]
18:07:43 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
18:07:51 <ddarius> @hoogle isAscii
18:07:52 <lambdabot> Data.Char isAscii :: Char -> Bool
18:07:52 <lambdabot> Data.Char isAsciiLower :: Char -> Bool
18:07:52 <lambdabot> Data.Char isAsciiUpper :: Char -> Bool
18:08:19 <JoeyA> It makes a toLower call.  I'm not sure what encoding is used for the Domain type now, so I'm assuming ASCII.
18:09:02 <ddarius> > text ['\192' ..]
18:09:03 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
18:09:29 <ddarius> I don't think I've seen that one befoer.
18:10:58 <ClaudiusMaximus> ... Invalid or incomplete mueval-core error message ?
18:11:30 <rwbarton> > text ['\192']
18:11:30 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
18:19:06 * hackagebot knob 0.1 - Memory-backed handles  http://hackage.haskell.org/package/knob-0.1 (JohnMillikin)
18:24:00 <augur> tromp: ping
18:32:06 <ski> > findIndex ('0' ==) $ let o LT = '-' ; o EQ = '0' ; o GT = '+' in map (o . flip compare 0) . iterate (* (18%19)) $ (15%17 :: Ratio Int)
18:32:10 <lambdabot>   mueval-core: Time limit exceeded
18:42:03 <ClaudiusMaximus> @check (\xs -> findIndex ('0' ==) xs == elemIndex '0' xs)
18:42:04 <lambdabot>   "OK, passed 500 tests."
18:44:52 <parcs> > sqrt (fromIntegral (maxBound :: Int64))
18:44:53 <lambdabot>   3.03700049997605e9
18:45:49 <parcs> oh right
18:45:59 <parcs> > maxBound :: Int32
18:46:00 <lambdabot>   2147483647
18:46:07 <ClaudiusMaximus> > elemIndex '0' $ let o LT = '-' ; o EQ = '0' ; o GT = '+' in map (o . flip compare 0) . iterate (* (18%19)) $ (15%17 :: Ratio Int8)
18:46:09 <lambdabot>   *Exception: arithmetic overflow
18:46:20 <ClaudiusMaximus> that's... unexpected
18:52:13 <dmwit> parcs: maxBound :: Int32 is 2^31-1; maxBound :: Int64 is 2^63-1; therefore, sqrt (maxBound :: Int64) is not (maxBound :: Int32).
18:52:16 <ski> ClaudiusMaximus : ah, i thought there ought to be such an operation, but i couldn't recall the name (and didn't bother enough to hoogle)
18:52:30 <dmwit> ...though sqrt (maxBound :: Word64) is very nearly maxBound :: Word32. =)
18:52:57 <ski> (unsurprisingly ..)
18:53:00 <dmwit> > sqrt 2 * 2147483647
18:53:01 <lambdabot>   3.0370004985618362e9
18:53:10 <dmwit> look familiar? =)
18:54:00 <ski> > elemIndex '0' $ let o LT = '-' ; o EQ = '0' ; o GT = '+' in map (o . flip compare 0) . iterate (* (18%19)) $ (15%17 :: Ratio Word8)
18:54:01 <lambdabot>   Just 8
18:56:18 <parcs> dmwit: ah i didn't see the e9 at the end
18:56:35 <parcs> i thought there was some crazy overflow thing going on
18:58:20 <parcs> > sqrt $ sqrt (fromIntegral (maxBound :: Int64))
18:58:21 <lambdabot>   55108.98747006744
18:59:28 <ddarius> > sqrt (maxBound :: Word64)
18:59:28 <lambdabot>   No instance for (GHC.Float.Floating GHC.Word.Word64)
18:59:29 <lambdabot>    arising from a use ...
18:59:36 <ddarius> > sqrt (fromIntegral (maxBound :: Word64))
18:59:36 <lambdabot>   4.294967296e9
18:59:45 <ddarius> > maxBound :: Word32
18:59:46 <lambdabot>   4294967295
19:00:25 <parcs> > sqrt 4294967295
19:00:26 <lambdabot>   65535.999992370605
19:00:33 <parcs> oh rite
19:13:49 <JoeyA> In recent-enough GHC, withCString uses a function called foreignEncoding.  Does that decode UTF-8, or is it locale-dependent?
19:15:12 <rwbarton> Is there a mirror of what used to be at www.galois.com/~dons somewhere? (specifically, I'm looking for yices-painless docs)
19:49:32 <wavewave> preflex: xseen dons
19:49:32 <preflex>  dons was last seen on freenode/#haskell 33 days, 11 hours, 24 minutes and 53 seconds ago, saying: cheers byorgey
19:50:09 <byorgey> it's nice, every time someone looks for dons he says 'cheers' to me again =)
19:51:43 <jmcarthur> i know it's cliche at this point, but...
19:51:46 <jmcarthur> preflex: seen mmorrow
19:51:47 <preflex>  mmorrow was last seen on #ghc 1 year, 263 days, 23 hours, 59 minutes and 5 seconds ago, saying: * mmorrow is rtfm'ing
19:52:13 <jmcarthur> i'm confused how/why one just completely disappears from the internet
19:54:00 <wavewave> jmcarthur : that can just happen.
20:02:22 <jampart> newbie Q: how might one 'uncurry' a function?
20:02:37 <geheimdienst> :t uncurry
20:02:38 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
20:02:49 <geheimdienst> > uncurry (+) (3,4)
20:02:50 <lambdabot>   7
20:02:56 <geheimdienst> > (+) 3 4
20:02:56 <lambdabot>   7
20:03:15 <jampart> looks nice, but not sure it's what I need.  Lemme spell it out a bit.
20:03:16 <geheimdienst> notice the "3 4" is wrapped into a tuple: (3,4)
20:03:24 <jampart> Yeah, it's the tuple I'd like to avoid.
20:03:29 <jampart> The context is this:
20:03:51 <jampart> data A = A String Int
20:04:09 <jampart> data B = B A [String]
20:04:24 <jampart> I want to define makeB :: String Int -> B
20:04:42 <rwbarton> "String Int"?
20:04:43 <jampart> such that makeB s i = B (A s i) []
20:04:44 <shachaf> jampart: What does that mean? "String Int" is an invalid type.
20:04:50 <jampart> correction:
20:04:53 <Boney_> makeB s i = B (A s i) []
20:04:56 <jampart> makeB :: String -> Int -> B
20:05:08 <shachaf> Oh.
20:05:10 <geheimdienst> jampart: yo, that looks better :)
20:05:11 <jampart> I'd like to curry away the s & the i in makeB
20:05:19 <jampart> with flip and with composition, I imagine.
20:05:22 <parcs> @pl makeB s i = B (A s i) []
20:05:23 <lambdabot> makeB = flip flip [] . (B .) . A
20:05:37 <jampart> wow
20:05:40 <jampart> what's @pl?
20:05:42 <shachaf> That's one way to do it...
20:05:51 <parcs> @pl
20:05:52 <lambdabot> (line 1, column 1):
20:05:52 <lambdabot> unexpected end of input
20:05:52 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
20:05:54 <shachaf> jampart: Converts things to "point-free" style, with nonamed arguments.
20:05:56 <parcs> @help pl
20:05:56 <lambdabot> pointless <expr>. Play with pointfree code.
20:06:09 <jampart> sweet
20:06:12 <geheimdienst> jampart: pl = "pointless". use sparingly. often it makes things less readable (as in this case)
20:06:19 <jampart> Indeed
20:06:47 <parcs> it's pointless in two ways most of the time
20:06:48 <jampart> Is lambdabot guaranteed to give us the *simplest* pointless solution?
20:06:55 <incluye> no
20:07:06 <shachaf> Of course not.
20:07:14 <shachaf> That's impossible.
20:07:20 <shachaf> Sadly.
20:07:39 <jampart> hmmm, well thanks all the same.
20:08:45 <shachaf> For example, a simpler version is makeB = flip B [] .: A
20:08:46 <shachaf> I think?
20:08:55 <shachaf> (Where (.:) = (.) . (.))
20:09:48 * BMeph agrees with shachaf (for all that it matters...)
20:10:15 <parcs> :t [ flip ?b [] .: ?a, flip flip [] . (?b .) . ?a ]
20:10:16 <lambdabot> forall (f :: * -> *) b a a1 (f1 :: * -> *). (?a::f1 (f a1), ?b::a1 -> [a] -> b, Functor f, Functor f1) => [f1 (f b)]
20:10:44 <shachaf> lambdabot is by definition guaranteed to give you the simplest solution, where "simplest" is defined as "the one that's easiest for lambdabot to give you". :-)
20:10:55 <shachaf> @pl (\x -> x x) (\x -> x x)
20:10:59 <lambdabot> ap id id (ap id id)
20:10:59 <lambdabot> optimization suspended, use @pl-resume to continue.
20:11:18 <geheimdienst> > length "makeB s i = B (A s i) []" - length "makeB = flip B [] .: A"
20:11:19 <lambdabot>   2
20:11:37 <geheimdienst> it's only 2 chars less, and i'd argue that it's much less readable
20:11:49 <shachaf> geheimdienst: Oh, absolutely.
20:11:58 <shachaf> More readable that what lambdabot gave, though.
20:11:59 <jampart> shachaf: that doesn't seem to work
20:12:04 <geheimdienst> i see we agree vigorously then
20:12:15 <shachaf> jampart: Why not?
20:13:02 <shachaf> s/Why/How/
20:13:14 <jampart> type error
20:13:18 <BMeph> I suspect it's because one is not allowed to use "flip" on a value constructor.
20:13:31 <jampart> BMeph: that would be surprising, no?
20:13:33 <shachaf> Works for me.
20:13:34 <mauke> shachaf: s/How/What/
20:14:21 <shachaf> jampart: By the way, if you want to get serious about point-free style, you should consider using a concatenative language. :-)
20:14:43 <jampart> shachaf: dunno what that means.  Any examples?
20:15:06 <shachaf> @google concatenative language
20:15:07 <lambdabot> http://en.wikipedia.org/wiki/Concatenative_programming_language
20:15:07 <lambdabot> Title: Concatenative programming language - Wikipedia, the free encyclopedia
20:15:11 <shachaf> jampart: What's the actual type error?
20:15:22 <jampart>   Couldn't match expected type `A'
20:15:23 <jampart>            against inferred type `(b -> c) -> (a -> b) -> a -> c'
20:15:23 <jampart>     In the third argument of `flip', namely `(.)'
20:15:23 <jampart>     In the first argument of `(.)', namely `flip B [] (.)'
20:15:24 <jampart>     In the expression: flip B [] (.) . (.) A
20:15:36 <jampart> oh crap
20:15:40 <jampart> wait
20:15:43 <shachaf> jampart: You can't just s/\.:/(.) . (.)/ like that.
20:16:02 <shachaf> Define a function (.:) = (.) . (.), or inline it respecting infix syntax and so on.
20:16:05 <mauke> shachaf++
20:16:25 <shachaf> ?
20:16:32 <rprije> Does anyone know of any simple way to have ghc watch files for changes and automatically retry compilation?
20:16:36 <mauke> excellent regex skillz
20:17:31 <shachaf> mauke: It would actually have worked without the \ in front of the . , so I antigolfed it by one character. :-(
20:18:13 <BMeph> shachaf: Better safe than sorry - that's a very Haskellish attitude. :)
20:18:36 <byorgey> rprije: ghc definitely doesn't do that.  you'd have to write your own script to watch for changes and call ghc.
20:18:50 <byorgey> rprije: EclipseFP has a continuous compile mode, perhaps you can see how it does it
20:19:12 <parcs> i have a patch for ghci that implements such a feature
20:19:20 <antihoax> hi
20:19:35 <byorgey> parcs: neat
20:19:37 <shachaf> rprije: On Linux you can use inotifywait to do it pretty easily.
20:19:38 <thoughtpolice> parcs: inotify?
20:19:40 <byorgey> hi antihoax
20:20:01 <parcs> thoughtpolice: no, periodic polling :P
20:20:16 <thoughtpolice> ah
20:21:19 <parcs> think of the windows users!
20:22:02 <luite> parcs: a cross-platform one?
20:22:03 <dmwit> Windows users get what they paid for.
20:22:10 <parcs> luite: yep
20:22:28 <parcs> well it should be
20:22:35 <parcs> it just uses getModificationTime
20:23:32 <luite> ok ok, that's what we already use in the yesod devel server (although it could be implemented more efficiently)
20:24:31 <byorgey> dmwit: and linux users get what they didn't?
20:25:09 <luite> it would be useful to have a cross platform file watching lib
20:29:33 <luite> there is something for python, but I don't know any for haskell
20:31:24 <rprije> Thanks shachaf
20:35:56 <mm_freak> what's easier to build on windows?  wx or gtk2hs?
20:37:40 <ski> > ((uncurry . flip) (flip . (flip (-) `graph`) . (^ 2)) `bayes` isqrt) `graph` (maxBound :: Int64)
20:37:41 <lambdabot>   (9223372036854775807,(3037000499,(9223372030926249001,5928526806)))
20:37:44 <ski> > ((uncurry . flip) (flip . (flip (-) `graph`) . (^ 2)) `bayes` isqrt) `graph` (maxBound :: Word64)
20:37:46 <lambdabot>   (18446744073709551615,(4294967295,(18446744065119617025,8589934590)))
20:37:50 <ski> > ((uncurry . flip) (flip . (flip (-) `graph`) . (^ 2)) `bayes` isqrt) `graph` (maxBound :: Word8)
20:37:51 <lambdabot>   (255,(15,(225,30)))
20:38:48 <ski> > ((uncurry . flip) (flip . (subtract `graph`) . (^ 2)) `bayes` isqrt) `graph` (maxBound :: Word32)
20:38:49 <lambdabot>   (4294967295,(65535,(4294836225,131070)))
20:43:37 <bru`> Hi
20:43:54 <bru`> How does Haskell deal with real random generators?
20:44:11 <bru`> I have trouble imaginating how it can be used in Haskell
20:44:32 <xil> hello. Does anyone know the prescribed method for initiating a redraw on the entirety of a Gtk2Hs DrawableArea?
20:44:50 <luite> bru`: what does real mean?
20:45:16 <bru`> luite:  not generating pseudo-random numbers
20:45:21 <bru`> but random numbers
20:45:42 <ezyang> Hmm... I wonder if QuickCheck should be written in a logic language.
20:45:48 <luite> bru`: there's random-source that can use a system entropy source
20:46:12 <ski> ezyang : whyfore ?
20:46:27 <bru`> luite:  but it is impure, right?
20:46:35 <ezyang> You can very naturally express nondeterministic choice.
20:46:46 <monochrom> use IO to read /dev/random for "real" random numbers
20:46:59 <luite> bru`: yes, that's what it would typically be
20:47:04 <xil> monochrom: why the quotes around "real"?
20:47:13 <ezyang> I mean, of course, you can do it in Haskell with monads, but some fo the syntactic niceties help.
20:47:16 <ezyang> *of
20:47:27 <mm_freak> bru`: generating real random numbers is outside the scope of a programming language, so it's not really a haskell question…  you can of course access the /dev/random file, for which convenient interfaces exist, if you consider this a source of truly random numbers
20:47:27 <ski> bru` : it wouldn't be anymore impure than other I/O in Haskell (i.e. not at all)
20:47:48 <monochrom> because at most we only know to get randomness from quantum phenomena, and even that is not proven random yet
20:47:49 <luite> bru`: you could of course read some data ahead and do pure computations with that, perhaps requesting more data in an enumerator style
20:47:50 <ddarius> ezyang: I'm pretty certain quickcheck inspired libraries have been made for logic languages, with some improvements no less.
20:48:02 <ezyang> ddarius: Not surprised.
20:48:14 <ezyang> In fact, I just wrote a tiny one in Coq :-)
20:48:18 <ski> ezyang : do you have any example ?
20:48:29 <xil> monochrom: oh I was unaware that /dev/random's randomness was in question, but I can understand why now that you mention it
20:48:31 <ski> (ddarius : i'd still like to see one :)
20:49:05 <bru`> luite, monochrom, mm_freak: but then... it does not seem as powerful as StdGen: you cannot request new random numbers in the middle of your program
20:49:13 <ezyang> I can paste mine. It's not that impressive though :^)
20:49:16 <monochrom> well, and then /dev/random may or may not have quantum phenonmena behind it
20:49:18 <mm_freak> monochrom: bell's inequalities prove quite a bit that quantum randomness is really random
20:49:31 <bru`> Wait, the randomness of /dev/random is not assured...?
20:49:55 <mm_freak> bru`: again it's not really a haskell question…  once you have access to a system resource producing truly random numbers, you can build any interface to it you like
20:50:01 <ski> bru` : i think monochrom means the randomness of the universe is not assured
20:50:04 <xil> mm_freak: but a lot of quantum mechanics is probably based on the speed of light being a limit...
20:50:04 <luite> bru`: that's true, you could work around it with lazy IO, but many people don't like that and prefer iteratees
20:50:14 <monochrom> in practice you get one or two seeds from /dev/random and then it's all pure afterwards
20:50:29 <monochrom> and this holds for every program, not just haskell programs
20:50:33 <parcs> where can i find that blog post that talks about computing the overhead of data structures?
20:50:54 <mm_freak> xil: my knowledge isn't that deep
20:51:03 <ddarius> http://www-ps.informatik.uni-kiel.de/~sebf/pub/flops08.html
20:51:15 <xil> mm_freak: mine either, I was just making a crack about the LHC stuff, haha
20:51:30 <mm_freak> ah, alright =)
20:51:31 <ski> bru` : anyway, i think you should be able to lazily read a stream of bits, which you can then use pretty much as `StdGen'
20:51:33 <hpaste_> e pasted “Simple Coq Quickcheck” at http://hpaste.org/52363
20:51:37 <luite> bru`: (although I guess just a simple IO action would be enough here, it's not really a stream you're insterested in, you just need some bits of entropy)
20:51:57 <parcs> never mind. it is here: http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html
20:52:14 <mm_freak> bru`: if you need random numbers for cryptographic purposes, i suggest the three packages 'entropy', 'crypto-api' and 'cprng-aes'
20:52:24 <bru`> mhh tank you
20:52:38 <bru`> mm_freak:  nope, it was just a question that I had in mind
20:52:57 <luite> ski: just a single lazy stream is often very inconvenient in haskell programs
20:53:06 <ski> indeed
20:53:27 <bru`> I'm still learning haskell (with learnyouahaskell - 1 chapter left, then I'll probably read real world haskell)
20:53:39 <luite> at least StdGen has split... although the theory about that is shaky at best
20:53:44 * ski forgot about `split' for a while, there
20:55:35 <mm_freak> bru`: ok, then technically there is little difference between reading bytes from a truly random number source and from a file
20:55:41 <luite> ski: for this use case, since you assume tht the numbers are truly random, you could just implement everything with unsafePerformIO without changing the semantics
20:55:45 <mm_freak> some problems, same solutions
20:55:46 <luite> for split
20:55:50 <mm_freak> s/some/same/
20:57:02 <bru`> mm_freak:  yes (well... except that /dev/random will hang fast!)
20:58:31 <mm_freak> bru`: you should be prepared for hangs in reading files, too
20:58:45 <bru`> why?
20:58:56 <mm_freak> just that in the case of /dev/random you probably want to display a message asking the user to generate entropy
20:59:19 <mm_freak> because a hard disk takes time, and the file may well be on a remote filesystem
20:59:29 <bru`> oh
20:59:38 <mm_freak> the system may be under load…  there can be many reasons why reading a file could hang
20:59:50 <ski> luite : *nod*, since they're presumably not repeatable anyway
21:09:53 <edwardk> ezyang: around?
21:22:23 <shirt> why does valgrind report memory leaks for haskell hello world?
21:23:14 <monochrom> how does valgrind know?
21:23:43 <shirt> it checks that all calls to malloc have a matching free
21:24:24 <monochrom> that is a fairly archaic method
21:25:04 <shirt> it's actually a bit more advanced than that. i'm not sure about the details
21:25:58 <monochrom> the runtime mallocs. if it needs more memory later, it mallocs again. if it collects garbage later, it does not necessarily free, in anticipation that it needs memory later anyway
21:26:58 <monochrom> so it deliberately does not pair a malloc with a free, even when it uses Θ(1) memory
21:27:57 <monochrom> do you observe real memory leak in hello world? if not, valgrind is wrong
21:30:12 <shirt> yeah i guess valgrinds leak checker is kind of useless for haskell. but maybe its massif tool could be useful
21:31:53 <shachaf> shirt: I imagine that the GHC profiler could be more useful.
21:33:04 <shirt> shachaf: can that show a timeline of memory use?
21:33:16 <monochrom> yes
21:33:49 <shirt> cool
21:45:18 <edwardk> shirt: the main problem is that memory allocation in haskell is managed by the garbage collector. the gc _can_ let pages go, but why bother at the end of the process when the whole space you are in is being discarded anyways?
21:45:59 <shachaf> You'll probably find similar behaviors even in C programs that use custom allocators.
21:52:04 <shirt> yeah. even the gcc c++ standard libraries do this
21:55:45 <Philippa> edwardk: there's such a thing as a Sufficiently Shitty OS, of course
21:56:26 <Philippa> (old versions of windows, a fair number of others from an age where memory protection wasn't a thing)
21:56:39 <edwardk> Philippa: well, i shall defer to digital darwinism to weed out both those operating systems and their practitioners from the ecosystem ;)
21:57:19 <Philippa> heh. At least DOS gets this one right? :-)
22:06:48 <jchia> hi
22:13:31 <parcs> does anyone else think that the memory statistic shown in ghci (with +s) should be in kilobytes?
22:14:46 <parcs> and possibly pretty printed (with commas and stuff)
22:50:37 <kmc> shirt, Haskell allocation doesn't use anything like malloc()
22:54:45 <shachaf> kmc: It doesn't use a custom allocator on top of malloc?
22:56:05 <kmc> no
23:00:11 <kmc> GHC gets memory from the OS in 1MB chunks (aligned)
23:02:09 <kmc> on UNIX this is done with mmap()
23:05:21 <Jafet> Well, you can use malloc to get memory from the OS in 1MB chunks (aligned)
23:05:29 <Jafet> It's just dumb
23:08:27 <Jafet> parcs, commas!? (admittedly, +RTS -s shows commas)
23:20:42 <huangyi> Is there an api to monitor number of threads running?
23:23:45 <Cale> huangyi: You mean like the worker threads spawned by the -N RTS option?
23:24:01 <Cale> huangyi: or forkIO'd Haskell threads?
23:24:07 <huangyi> Cale: forkIO thread
23:24:20 <Cale> hmm, not that I'm aware of in that case
23:24:30 <Cale> There might be a way...
23:26:42 <Cale> If your program is sufficiently simple, it might be easier just to increment an MVar or something as each thread runs.
23:27:37 <huangyi> But thread termination and blocking seems not so easy to track.
23:28:15 <Jafet> forkMyIO a = bracket_ (modifyIORef nThreads succ) (modifyIORef nThreads pred) a
23:30:26 <kmc> Jafet, it's not what GHC does though
23:30:47 <huangyi> I want to write a server with haskell, it would be great if i can track these performance status at runtime, how many threads waiting, how many threads runnable.
23:31:10 <Jafet> Okay, GHC doesn't let you know which other threads are blocked.
23:33:53 <Jafet> It would be nice if there was an API to reflect any profiling statistics into the program.
23:34:08 * hackagebot hastache 0.1.4 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.1.4 (SergeyLymar)
23:34:10 * hackagebot monad-lrs 0.0.2 - a monad to calculate linear recursive sequence  http://hackage.haskell.org/package/monad-lrs-0.0.2 (BinJin)
