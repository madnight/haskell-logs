00:04:20 <Cale> ohwow: http://paste.lisp.org/display/125152#2
00:05:06 <Cale> oh, oops
00:06:28 <Cale> serves me right for not running a typechecker over it first ;)
00:06:47 <ohwow> hm
00:06:57 <ohwow> What does select do?
00:07:04 <ohwow> Sorry, I find it kinda obscure :S
00:07:14 <Cale> picks one element out of the list in all possible ways, and gives the remainder of the list
00:07:27 <ohwow> why do you need it
00:07:32 <ohwow> and you dont have sum..
00:07:32 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
00:07:33 <lambdabot>  Defined.
00:07:39 <Cale> yeah, that's what I'm missing :)
00:07:47 <Cale> > select [1,2,3,4,5]
00:07:48 <lambdabot>   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
00:07:56 <ohwow> ah I see
00:08:37 <Cale> there, http://paste.lisp.org/display/125152#3 should work
00:08:44 <Cale> (just forgot the sum)
00:09:19 <Cale> So ps' is all the *other* pairs, other than (xj,yj)
00:09:50 <Cale> So when we write (xk,yk) <- ps', we automatically don't get (xj,yj), and we can avoid equality testing.
00:10:53 <ohwow> yes i get it now
00:11:05 <ohwow> Is equality testing bad?
00:11:43 <Cale> Well, I tend to avoid it wherever I can. It's possible to imagine instances of Fractional which aren't instances of Eq
00:11:46 <Botje> equality is for people! not for types :P
00:11:58 <Cale> Like, you could write an instance of Fractional for functions :)
00:12:07 <Cale> > (sin/cos) 1
00:12:08 <lambdabot>   1.557407724654902
00:12:15 <Cale> ^^ like that
00:12:32 <companion_cube> all functions are equal, but some are more equal than the others
00:12:44 <Cale> That might be considered a bit of a bizarre space to be doing Lagrange interpolation in though.
00:12:47 <tdammers> equality testing is also bad if you use it on floats
00:13:10 <Cale> Though in this case, not quite as bad, because you're guaranteed to find that float
00:13:19 <Cale> (but in general, yes)
00:13:23 <tdammers> I mean for quite practical reasons
00:13:31 <ohwow> Ok, how do I guarantee (with types) that my Fraction is a number
00:13:40 <Cale> Well, it is :)
00:13:58 <Cale> In that Fractional guarantees that you can do with it all the things that you can do with numbers.
00:14:08 <tdammers> Duck typing a la Haskell :)
00:14:22 <Cale> (technically it also guarantees that there's an instance of Eq, but everyone hates that)
00:15:15 <Axman6> it is certainly not duck typing
00:15:54 <Axman6> :t sin / cos
00:15:55 <lambdabot> forall a. (Floating a) => a -> a
00:16:00 <Cale> Well, it's what we use instead of duck typing or ad-hoc polymorphism, even if it's none of those things.
00:16:02 <Axman6> bah -_-
00:16:52 <companion_cube> > (sin / cos) 1
00:16:53 <lambdabot>   1.557407724654902
00:16:58 <Cale> > tan 1
00:16:59 <lambdabot>   1.5574077246549023
00:17:36 <Axman6> god damnit, i frigging hate gtk/cairo/everything!
00:17:43 <Cale> wat
00:17:59 <Cale> > log^2 5
00:18:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
00:18:00 <lambdabot>    arising from a use of `...
00:18:07 <Cale> > (log^2) 5
00:18:08 <lambdabot>   2.5902903939802346
00:18:10 <Cale> kekeke
00:18:20 <Cale> > (log 5)^2
00:18:21 <lambdabot>   2.5902903939802346
00:18:45 <companion_cube> > 2 ** 3
00:18:46 * Axman6 gives up on threadscope for the 2309723409723'th time
00:18:46 <lambdabot>   8.0
00:19:05 <companion_cube> (** 3) ** 2 $ 2
00:19:06 <Cale> Axman6: lol, trying to mix threads and C libraries? :)
00:19:10 <companion_cube> > (** 3) ** 2 $ 2
00:19:10 <lambdabot>   63.99999999999998
00:19:16 <Axman6> trying to just bloody install gtk
00:19:21 <companion_cube> oops
00:19:23 <Cale> oh
00:19:30 <Cale> Doesn't your distribution do that?
00:19:38 <Cale> Or do you mean the Haskell binding?
00:19:41 <Axman6> well, i can get gtk installed (both the C and haskell libraries) but they can't run because they fail to load libraries at runtime with the correct versions
00:22:10 <srh> > (2 * sin * cos) (pi / 8)
00:22:11 <lambdabot>   0.7071067811865476
00:22:13 <srh> yay
00:24:08 <shachaf> > 2 3 4
00:24:09 <lambdabot>   2
00:26:28 <KirinDave> dmwit: Your xmonad config on file is pretty amazing.
00:30:04 <t11> :U :o :0
00:32:02 <Blkt> good morning everyone
00:33:11 <kmc> hi Blkt
00:33:46 <ohwow> Anyone here uses gnuplot under Windows?
00:36:33 <Blkt> hi kmc
00:36:57 <applicative> what is the flag that makes ghc forget about SAFE ?
00:38:08 <sipa> safe?
00:40:12 <monochrom> -XOcaml :)
00:40:25 <applicative> oh I mean the Safe Haskell extension, it kills me every time I try to build ghc from a repository
00:41:26 <applicative> "base:Data.List can't be safely imported! The package (base) the module resides in isn't trusted."
00:42:16 <kmc> maybe -XNoSafeHaskell
00:42:33 <kmc> the GHC trac page about SafeHaskell has an explanation of all the flags
00:42:35 <kmc> it's pretty complicated
00:44:10 <applicative> yes, someone had an incantation on here. but it occurs to me I'm not seeing  how to pass the flag to ghc using the ./configure mechanism anyway
00:48:30 <applicative> aha, I can evade it by building with a pre-SafeHaskell ghc.  of course it will collapse over gmp or something later....
01:04:01 <applicative> grrr libiconv, you are the very devil!
01:34:58 <mm_freak> parcs: there are still a few informations out of date in the Netwire wiki page
01:35:22 <mm_freak> most notably we now do have an ArrowLoop instance and the semantics of local time have been changed a lot
01:36:04 <mm_freak> since a recent version clocks don't stop anymore, even if the wire is not reached…  instead the framerate drops, because the deltas become larger
02:25:13 <Ishad> quick q - let's assume we have f (g (h x y)) - what's "better" (f . g $ h x y) or (f $ g $ h x y)
02:25:38 <shachaf> Ishad: The former, or (f . g . h x $ y)
02:25:45 <shachaf> At least, that's generally preferred style.
02:25:53 <Ishad> why so?
02:26:02 <shachaf> It means you can take the function (...) and split it off into its own thing easily.
02:26:22 <Ishad> point taken, thanks
02:27:21 <Ishad> so, if you got more than one $ in expression, you most likely doing smth not "idiomatic", right?
02:27:28 <frerich> Ishad: I also think that f . g . h x $ y is preferrable because it's less 'line noise', simply because the '.' operator isn't as noisy as '$' :-}
02:28:30 * frerich always starts writing "f (g (h x y))" first, then realizes he could use $, then realizes he could use '.'. I don't manage to write the "tidy" version on first try.
02:29:58 <applicative> (f . g . h x) y
02:29:58 <Ishad> I'm only ocassiona haskell user (small tools for myself), fun - so just trying to make it look nice
02:30:55 <frerich> applicative: Err yes
02:31:35 <applicative> frerich, just thought I'd post my favorite, or sometime favorite...
02:31:39 <applicative> for f (g (h x y))
02:32:00 <shachaf> Ishad: Some people say that $ should be infixl.
02:32:15 <shachaf> Ishad: That would allow you to do things like f (g x) (h y) without parentheses.
02:32:37 <shachaf> (While still using (f . g h . x $ y) for (f (g h (x y)).)
02:33:11 <frerich> Ishad: What's the argument(s) in favor of right-associativity?
02:33:28 <frerich> argument$s har har (sorry)
02:33:56 <frerich> shachaf: Sorry, that was for you.
02:34:03 <shachaf> Oh.
02:34:14 <shachaf> Well, the main one is that that's how it is and it would break a lot of code to change it.
02:34:50 <shachaf> There are other justifications you could come up with -- for example, right now you can almost always just stick "f $" in front of something to get f of that something.
02:34:51 <mm_freak> depending on what x and y are and what h does to them, i'd prefer:  f . g $ h x y
02:34:59 <Ishad> simple solution - create eur-sign-here func for yourself ;)
02:35:04 <shachaf> Whereas if it was infixl you might need to worry about whether to use f . or f $.
02:35:59 * frerich just had the brilliant idea of introducing an 'upside-down $' which is like $ except that it's left-assiocative...
02:36:21 <frerich> Not so smart, ahem.
02:37:03 <mm_freak> i'd rather use parentheses than a left-associative ($)
02:37:24 <mm_freak> f (my long expression) (and my other long expression)
02:37:44 <mm_freak> in fact i try to avoid the ugly dollar sign
02:38:11 <frerich> Hm I guess you could also say that if you need parentheses like that, you should consider moving those long expressions into seperate values using where or let or the like.
02:38:22 <frerich> Might make the code more self-documenting, too
02:38:30 <mm_freak> yeah, that's a much nicer method to deal with that
02:38:42 <mm_freak> but sometimes that would make the code harder to read
02:39:31 <shachaf> I've grown to like $ less and less over the decades.
02:39:34 <mm_freak> f (sin abc ^ 2) (cos abc ^ 2)  -- i'd find that easier to read than with let/where
02:39:42 <mm_freak> shachaf: i never liked it
02:40:06 <mm_freak> i really prefer to write:  print (1 + 1)
02:41:03 <quicksilver> I think (a . b . c . d $ e) looks slightly nicer than ((a . b . c . d) e)
02:41:35 <mm_freak> quicksilver: that's about the only case where i use ($)
02:42:30 <danr> Anyone used Codec.TPTP here? I'm getting :=>: in the prettyprinted formula instead of =>, which is quite undesirable.
02:48:32 <erus`> if i wanna try a language with dependant types is agda a good place to start?
02:49:18 <kmc> yeah
02:49:19 <kmc> see www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
02:49:32 <kmc> you could also use Coq and follow http://www.cis.upenn.edu/~bcpierce/sf/
02:49:42 <kmc> the latter has more material, and Coq is in general more mature and better documented
02:49:49 <kmc> but Agda is (imo) a nicer programming language, and is more Haskell-like
02:52:40 <erus`> types can have different types :O
02:56:16 <erus`> why did agda swap :: and :
02:57:03 <kmc> because you write types more often than you write lists
02:57:05 <kmc> there's less type inference
02:57:07 <int-e> because agda has many more type signatures
02:57:35 <int-e> meh. where's the stereo quote when you need it?
02:57:38 <shachaf> I think that that would have been good for Haskell too, actually.
02:57:50 <int-e> @quote fugue
02:57:50 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
02:58:00 <kmc> technically agda uses ∷ for lists, not ::
02:58:05 <shachaf> Of course, there's Larry Wall's law of programming syntax design.
02:58:12 <kmc> but it's just defined in a library, so you could change that
02:58:45 <int-e> there's also a precedent in the ML family of languages.
02:59:08 <kmc> yeah, I assume a deliberate decision was made to change this somewhere in the progression of ML → Lazy ML → Haskell
03:00:21 <kmc> erus`, if you want some formal proof exercises, check out http://as305.dyndns.org/aps/problem
03:00:25 <shachaf> Miranda uses Haskell-style : and ::.
03:01:29 <shachaf> Lazy ML apparently uses "." for cons.
03:01:52 <danr> shachaf: If I remember correctry, Prolog does too
03:01:59 <danr> correctly, even
03:02:10 <shachaf> Hmm, it uses . for other things too.
03:02:48 <shachaf> Hmm, no, apparently :: for cons?
03:02:52 <shachaf> I don't know.
03:03:04 <solrize> wow that proof site is great
03:03:13 <solrize> i've been wanting to read software foundations
03:03:18 <solrize> and those look like good exercises
03:03:39 <kmc> SF has tons of exercises too
03:03:47 <kmc> and they're well integrated with the text
03:03:56 <kmc> you basically load each chapter into coqide
03:04:13 <danr> kmc: what is SF?
03:04:17 <kmc> Software Foundations
03:04:22 <kmc> i linked it a sec ago
03:04:30 <kmc> and the green highlighting tells you how much of the text you've read and understood
03:04:33 <kmc> it's great
03:04:43 <kmc> it's totally unlike any other reading-a-textbook-by-yourself experience i've had
03:04:43 <solrize> neat
03:04:52 <erus`> apply : (A : Set)(B : A -> Set) -> ((x : A) -> B x) -> (a : A) -> B a
03:04:54 <erus`> apply A B f a = f a
03:04:59 <kmc> automated proof checking makes the exercises into an addictive puzzle game
03:05:03 <erus`> A B is a single arguement?
03:05:09 <kmc> no
03:05:09 <shachaf> erus`: No, it's just shorthand.
03:05:14 <kmc> two args, just like Haskell
03:05:18 <shachaf> It explains the syntax in that PDF, I think.
03:05:21 <solrize> i looked at smerdyakov's book and could sort of make sense of it but not enough to really code anything
03:05:24 <mm_freak> unfortunately at that corner of the lambda cube i haven't found a language, which is suitable for pratical programming
03:05:50 <kmc> erus`, that example doesn't have it, but you can say (A B : Set) as shorthand for (A : Set) (B : Set)
03:05:55 <mm_freak> practical
03:06:03 <kmc> which is the same as (A : Set) → (B : Set)
03:06:04 <danr> kmc: The last links I see from you are kik314's coq's problems and ulf norell's agda tutorial
03:06:12 <erus`> ah ok thank kmc.
03:06:19 <kmc> oh i guess it's buried up there
03:06:19 <kmc> http://www.cis.upenn.edu/~bcpierce/sf/
03:06:27 <mm_freak> for real world applications agda would probably stand in your way more often than it would help you…  it's a proof assistant after all
03:06:43 <danr> kmc: thanks
03:06:46 <kmc> mm_freak, it's explicitly designed to be more of a programming language than say Coq
03:06:57 <kmc> definitely still in the earliest stages though
03:07:12 <kmc> danr, :)
03:07:50 <kmc> erus`, the argument type syntax in Agda is weirdly flexible
03:07:52 <mm_freak> kmc: for critical code it's probably great
03:08:14 <kmc> mm_freak, my hope is that eventually we have a system where you can program like Haskell, but also prove *some* things
03:08:17 <kmc> prove the things you care about
03:08:25 <kmc> without paying the price everywhere
03:08:32 <ohwow> Hmm
03:08:33 <solrize> somebody implemented a pdf checker in coq after reading sf
03:08:33 <kmc> and Agda might become that system, but it's still in the earliest stages
03:08:35 <shachaf> Do you think the right direction to approach that is Agda->Haskell rather than Haskell->Agda?
03:08:44 <shachaf> I suppose there's a parallel to that graph SPJ always shows.
03:08:45 <ohwow> like adding user-defined contracts to Haskell?
03:09:03 <mm_freak> kmc: regarding real world applications you can prove a great deal in haskell, and i don't think agda would improve that…  it would just make it easier
03:09:11 <kmc> you cannot prove very much in Haskell
03:09:16 <ohwow> ^
03:09:18 <kmc> not formally
03:09:22 <kmc> you can prove things about haskell code, on paper
03:09:40 <ohwow> but it could be done automatically\
03:09:42 <mm_freak> kmc: you can prove that 'head' never receives an empty list
03:09:44 <ohwow> have you guys seen VCC?
03:09:49 <kmc> > head []
03:09:50 <lambdabot>   *Exception: Prelude.head: empty list
03:09:56 <kmc> mm_freak, i don't follow
03:10:05 <mm_freak> kmc: not the standard 'head' and not standard lists
03:10:08 <ohwow> it's a verificator + contract system for C
03:10:58 <mm_freak> kmc: of course when it comes to real world applications we're not talking about haskell anymore, but about haskell + RankNTypes
03:11:23 <mm_freak> and likely also GADTs
03:11:25 <kmc> mm_freak, sure, you can sometimes encode a few simple invariants in the structure of a Haskell data type
03:11:37 <kmc> it's pretty simplistic compared to what Coq and Agda can do
03:11:59 <mm_freak> kmc: care to give me an example of what agda can do that haskell can't?
03:12:17 <kmc> prove that complicated functions always terminate
03:12:22 <mm_freak> not the sort of "in agda it's easier", but rather, "you can't do it in haskell"
03:12:38 <kmc> in Haskell there's very little you can prove about your *code*
03:12:45 <ohwow> kmc: are you saying that Agda developers solved the termination problem?
03:12:59 <kmc> i can write a function on naturals in Agda and then prove that it's monotonically increasing
03:13:03 <ohwow> or they only can reason about some functions, like simple loops?
03:13:12 <solrize> ohwow, yes, agda solves the halting problem.  all agda functions halt
03:13:13 <kmc> ohwow, no, I should be more precise: you provide a proof that the function terminates, and Agda checks the proof
03:13:14 <ohwow> ah well, that's another tihng
03:13:29 <kmc> you can use complicated recursion in Agda as long as you can prove it halts
03:13:31 <ohwow> solrize: that means that Agda is not turing-complete
03:13:39 <solrize> ohwow, correct.
03:13:41 * applicative dimly remembers an amusing scene in his video lectures on agda where mcbride says something like 'if you have to prove a theorem, you're doing it wrong'
03:13:44 <ohwow> I see
03:13:46 <solrize> @google total functional programming
03:13:48 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.109.1950&rep=rep1&type=pdf
03:13:49 <lambdabot> Title: Total Functional Programming
03:13:50 <ohwow> That's more interesting
03:13:54 <solrize> that is a great paper
03:13:59 <Saizan> OTOH Agda is not turing complete in the same sense that Haskell can't do I/O
03:14:05 <solrize> it says turing completeness in languages is overrated  :)
03:14:24 <ohwow> I agree
03:14:56 * dcoutts bangs the drum for the hackage server
03:14:57 <lambdabot> dcoutts: You have 4 new messages. '/msg lambdabot @messages' to read them.
03:14:58 <dcoutts> http://www.reddit.com/r/haskell/comments/l3zye/want_to_help_with_the_new_hackage_server_jump_in/
03:15:01 <ohwow> can  the reachability problem be solved in agda?
03:15:02 <kmc> Saizan, you mean in the sense of "false things people say on Reddit"? ;)
03:15:39 <applicative> you can do IO in Haskell?
03:16:22 <mm_freak> kmc: indeed the termination promise is good…  for haskell you can only do that on paper, but what i'm really talking about is when impure code comes into play
03:16:36 <mm_freak> let's assume you have a kind of iteratees or a request/response style IO system in agda
03:16:39 <mm_freak> with codata
03:16:45 <Saizan> kmc: more specifically in the sense that you can represent turing complete stuff and ask a RTS handle it
03:16:54 <Saizan> *to handle
03:17:19 <dcoutts> @tell Axman6 re gtk2hs/c2hs, the version you want is actually out. It's the latest version on hackage, been out for a few weeks.
03:17:20 <lambdabot> Consider it noted.
03:17:56 <mm_freak> about the non-turing completeness of agda:  for some function it's not mathematically proven that they will terminate for some inputs…  how can you express those in agda?
03:18:38 <kmc> iirc, you can disable the termination checker for specific functions
03:19:05 <mm_freak> that's not a real solution, is it?  i'd think that you could cheat by using codata without leaving the language's framework
03:19:40 <solrize> the type system would separate data from codata, i'd expect
03:19:52 <mm_freak> it does
03:22:55 <applicative> agda doesn't distinguish them as Turner was imagining, or as eg cpl does
03:23:30 <Saizan> mm_freak: yes, you can express those, there's e.g. a partiality monad made with codata and other approaches too
03:23:46 <mm_freak> i see
03:24:11 <mm_freak> well, i'll give agda a shot again, when it reaches the point where i can do my work with it
03:24:48 <mm_freak> mostly networking stuff, so agda right now doesn't have the pragmatic tools i need
03:25:59 <kmc> i'm learning Agda not because i think it's a practical tool now, but to be ahead of the curve
03:26:05 <kmc> and to have a challenge comparable to learning Haskell
03:26:23 <kmc> because i'm afraid of Haskell being my Blub
03:27:10 <mm_freak> i don't think you can ever say that you have mastered all challenges of haskell
03:27:53 <mm_freak> i'm exploring the couniverse right now (comonads, etc.)
03:28:31 <fabbomelker> hello!
03:28:51 <mm_freak> let alone truly mastering all of agda
03:29:10 <mm_freak> hi there fabbomelker
03:29:14 <applicative> there is a pleasantly brief proof of False with agda's coinductive ♯ ♭ ∞ that Prof. Abel hpasted the other day. http://hpaste.org/52127
03:29:39 <applicative> i seem to have busted my agda again so I couldn't study it
03:30:21 <erus`> we need to solve the halting problem
03:30:52 <mm_freak> erus`: the problem doesn't exist in agda
03:30:53 <erus`> maybe quantum computers ?
03:31:17 <applicative> why?
03:31:33 <mm_freak> the halting problem exists in all turing-complete languages, and is even amplified in a generic quantum language
03:31:55 <mm_freak> so quantum computers can't solve it, they'll in fact make it worse
03:32:11 <applicative> why not say that methods that lead to might-be-non-halting 'functions' aren't genuine methods of definition
03:33:03 <erus`> can we implement any method that cant be proved as non halting in halting methods?
03:33:46 <kmc> F♯A♯∞
03:33:53 <applicative> if the method of definition is a method of defining 'halting' total functions, then when you write the definition, you are writing such a proof
03:34:12 <kmc> erus`, there's no reason to think quantum computers can compute things classical computers can't
03:34:20 <erus`> i meant the other way round
03:34:26 <kmc> or that
03:34:29 <kmc> that makes even less sense
03:34:39 <erus`> not you kmc
03:34:43 <kmc> there's not even a proof that quantum computers are exponentially faster
03:34:48 <kmc> though there is some reason to believe they are
03:34:51 <mm_freak> quantum computers are right now known to solve certain already-solved problems faster
03:35:00 <mm_freak> they don't solve new problems
03:35:05 <ohwow> yea
03:35:27 <kmc> mm_freak, there are problems where the best possible quantum algorithm is better than the best possible classical algorithm?
03:35:29 <kmc> or just best known?
03:35:30 <ohwow> Some people think that quantum computing would somehow be able solve NP problems
03:35:33 <erus`> prime factors?
03:35:33 <ohwow> in polynomial time
03:35:39 <mm_freak> kmc: best known
03:36:02 <kmc> BQP lies between P and NP, so if you showed BQP ≠ P then you'd also prove P ≠ NP
03:36:28 <ohwow> hm
03:36:28 <mm_freak> kmc: but it might be even best possible, because for example a quantum computer can invert a generic function with domain of size n in O(sqrt(n))
03:36:31 <ohwow> what's BQP?
03:36:31 <mm_freak> see grover's algorithm
03:36:55 <kmc> ohwow, http://qwiki.stanford.edu/index.php/Complexity_Zoo:B#bqp
03:37:15 <kmc> basically it's problems efficiently solvable on a quantum computer in polynomial time
03:37:29 <ohwow> ah
03:37:52 <ohwow> I didn't know there were classes for boundeed-error vs unbounded-error
03:38:01 <mm_freak> kmc: i don't see how a regular turing machine could invert functions in O(sqrt(n)) or better
03:38:54 <kmc> ohwow, yeah, the key is that the error is low enough that you can make it exponentially smaller with polynomial repetitions
03:38:59 <erus`> i thought the whole point of quantum stuff was that computation was instant :|
03:39:18 <mm_freak> erus`: nowhere near instant =)
03:39:37 <kmc> that's the key difference between PP and BPP
03:39:39 <ohwow> instant computations are possible only in algebra, not in real world
03:39:44 <kmc> (both of which deal with classical turing machines)
03:39:54 <ohwow> at least with our level of understanding of physics
03:39:59 <fabbomelker> what I've noticed is that there seems to be a lot of people interested in haskell. well to put it formally it seems to have a high (devoted users)/user ratio. Is this true? in that case how come?
03:40:01 <kmc> a PP machine only needs to be right slightly more often than it's wrong, so it's not really practical
03:40:18 <mm_freak> erus`: just consider that particles need to travel for the computation to take place
03:40:33 <kmc> a BPP machine is right often enough that you can get exponentially small error in polynomially many tries
03:40:41 <ohwow> WE SHOULD MAKE A NEUTRINO COMPUTER
03:40:47 <ohwow> FASTER THAN LIGHT COMPUTATIONS
03:40:53 <kmc> hurr durr
03:41:04 <ohwow> heh
03:41:05 <ohwow>  :p
03:41:14 <erus`> might as well stick to silicon then guys. Pack up your stuff lets go home
03:41:38 <ohwow> I hope we are not disrupting usuall channel activity with this semi-offtopic
03:41:47 <mekeor> ohwow: haha
03:41:49 <mm_freak> fabbomelker: haskell takes a different and very interesting approach to solving real problems
03:41:54 <kmc> there's also RP (false negatives with no false positives) and coRP (false positives with no false negatives)
03:42:02 <kmc> and ZPP is the intersection of the two
03:42:16 <ohwow> man i am looking forward for my computational theory & algorithms class
03:42:27 <applicative> fabbomelker there is a high devoted-user/user ratio because it is so wonderful
03:42:28 <kmc> a ZPP machine always gives the right answer, but only in *expected* polynomial time, not guaranteed
03:42:35 <kmc> and it requires a source of randomness, which a P machine does not
03:43:14 <mm_freak> fabbomelker: it's an extremely expressive, high level language, which does wonderful things to your mind =)
03:43:39 <kmc> i'd counter by saying Haskell also has a high ratio of enthusiastic beginners to experts
03:43:54 <kmc> don't get me wrong, enthusiastic beginners are a very good thing!
03:44:13 <kmc> but few people would write a blog post about how great Java or PHP is when they're only one week into learning Java or PHP
03:44:16 <fabbomelker> mm_freak: Im kind of getting the feeling of that, but still could it produce code that is not only nice to write but also nice to use. hehe
03:44:26 <applicative> yes the ratio is 100%
03:44:31 <kmc> fabbomelker, pandoc is nice to use
03:44:55 <mm_freak> fabbomelker: i'm producing real world code using haskell on a daily basis
03:45:25 <ohwow> Is there a haskell textbook with excercices
03:45:35 <erus`> you could say the same about ruby
03:45:36 <ohwow> so you are actually forced to do something?
03:46:20 <fabbomelker> anybody wrapped C-code into Haskell?
03:46:27 <kmc> yes, it's a common thing to do
03:46:36 <fabbomelker> does it work well?
03:46:41 <kmc> yes
03:46:42 <kmc> http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
03:46:43 <int-e> Haskell has a great FFI.
03:46:44 <applicative> ohwow: there are exercises in Real World Haskell.
03:46:50 <kmc> fabbomelker, see that link
03:46:54 <MjrTom> in windows eclipseFP how can I fix this: cabal.exe: dependencies conflict: ghc-7.0.3 requires directory ==1.1.0.1 however directory-1.1.0.1 was excluded because ghc-7.0.3 requires directory ==1.1.0.0
03:47:05 <ohwow> oh
03:47:06 <mm_freak> well, i'd say that the popular languages are the same, and i'd go as far as stating that there is little difference between ruby, java, PHP, python, C and C#…  they all have the same underlying concept, but express it with varying language power
03:47:07 <ohwow> hm
03:47:10 <mm_freak> haskell is conceptually different
03:47:18 <int-e> And there are tools like c2hs to deal with tedious tasks like marshalling of records.
03:47:21 <ohwow> then i should read RWH instead of LYAH
03:47:29 <mekeor> the sence of the "do"-"loop" isn't only being able to handle with monads easily, but also (but probably not particulary) just call multiple/several functions one after the other.  isn't it?
03:47:29 <dcoutts> MjrTom: blow away the offending instance of directory (the per-user one)
03:47:39 <fabbomelker> is it fast? I mean say you have some iterative linear system solver written in C and at every new iteration you want to communicate with the haskell code, would that slow it down much you think?
03:47:50 <MjrTom> oh ok thx dcoutts
03:48:15 <mekeor> s/sence/sense/
03:48:16 <mm_freak> fabbomelker: interfacing with C code is usually done for data structures or foreign libraries…  for example i have never interfaced to C
03:48:23 <applicative> ohwow, they're both excellent
03:48:37 <kmc> fabbomelker, not that much.  Haskell-to-C function call overhead is on the order of 250 nanoseconds on my laptop
03:48:39 <mm_freak> properly written haskell gives you about 50-80% of C performance, which is enough for most purposes
03:49:09 <int-e> kmc: for unsafe calls?
03:49:15 <kmc> for safe calls
03:49:20 <kmc> unsafe calls are like 13 nanoseconds
03:49:38 <kmc> so unsafe is faster, but it will only make a difference for the very smallest foreign functions
03:49:40 <int-e> kmc: oh. sorry, got the order of magnitude wrong. sigh.
03:49:45 <kmc> and otherwise you should default to safety
03:49:48 <erus`> mm_freak: once you start writing code like that though it might aswel be in C
03:49:53 <mm_freak> mekeor: could you rephrase that question?
03:49:57 <kmc> even calling "sin" the difference is only like a factor of 2
03:50:00 <int-e> kmc: sounds plausible now
03:50:03 <mm_freak> erus`: not at all
03:50:12 <mm_freak> erus`: my code is very idiomatic haskell
03:50:23 <mekeor> mm_freak: well. it's not that important that i expect an answer, thanks anyway. =)
03:50:51 <kmc> mekeor, i didn't understand your question either
03:51:27 <mm_freak> mekeor: an answer doesn't have to be important for one to be /interested/ in the answer ;)
03:51:35 <kmc> yeah, for reference light travels less than 75 meters in 250 nanoseconds
03:51:44 <mekeor> that's probably because i like complicated sentences/questions (regarding grammer) but my english isn't very good (compared to my german)
03:52:04 <kmc> less than an American football field ;)
03:52:07 <fabbomelker> I was thinking of building of a library/program of multigrid methods for PDE's. My idea was to write the different choices of discretization, number of cycles, smoothers, solvers as compositions of haskell functions, which hopefully would enable quite modular code. Some of these functions might then be wrapping C-code, e.g. for linear solvers.
03:52:24 <kmc> fabbomelker, that sounds great!
03:52:31 <mm_freak> perhaps there should be a german haskell channel
03:52:48 <kmc> fabbomelker, you can follow the "domain-specific language" approach
03:52:49 <ohwow> http://stallman.org/archives/2011-jul-oct.html#06_October_2011_(Steve_Jobs)
03:52:50 <ohwow> oops
03:52:51 <ohwow> srry
03:52:53 <ohwow> wrong chan
03:53:07 <kmc> where your functions build a Haskell data structure describing the solver to use
03:53:12 <fabbomelker> domain specific language?
03:53:24 <kmc> then you can implement the data structure in a variety of ways
03:53:29 <kmc> from a simple interpreter that calls into C code
03:53:39 <kmc> to generating custom unrolled inlined C or LLVM code
03:54:13 <kmc> DSLs embedded in Haskell are used for all kinds of things that Haskell itself wouldn't be
03:54:16 <fabbomelker> hmm, the last sentence.. what does that mean.
03:54:25 <kmc> e.g. realtime machine control, realtime digital signal processing
03:54:28 <fabbomelker> I mean inlined C or LLVM
03:54:56 <kmc> fabbomelker, i mean that once you have a description of the PDE solver to use, you can implement it by generating code
03:55:13 <kmc> it's not the easiest way but might give the best performance
03:55:35 <kmc> if you design things right you can start with the simple interpreter
03:55:43 <kmc> and then do code generation if necessary, without changing everything else
03:55:46 <fabbomelker> so I write it in haskell and then generate code in some other language?
03:56:09 <kmc> yeah
03:57:36 <kmc> it's the approach used e.g. by http://hackage.haskell.org/package/atom and http://hackage.haskell.org/package/feldspar-compiler
03:57:50 <kmc> which are real projects in use in industry
03:58:03 <danr> and Lava, compiles to VHDL
03:58:12 <kmc> ah yeah
03:58:28 <kmc> in fact i'd say DSLs are the #1 industrial application of Haskell
03:58:36 <kmc> of course every library looks like a domain-specific language if you take the right viewpoint
03:58:54 <kmc> fabbomelker, are you new to Haskell in general?
03:59:22 <fabbomelker> yeah I am.
03:59:39 <kmc> cool! welcome
03:59:53 <fabbomelker> thanx xD
04:00:11 <fabbomelker> Ive been asking quite a lot of questions here though ;)
04:00:22 <kmc> that's what it's for :)
04:00:44 <fabbomelker> my ratio of programming in haskell/asking and reading about haskell is quite low ;)
04:01:22 <zipace> hey, anyone know what's wrong with hpaste.org? that site appears to have been down since quite a while
04:01:28 <mm_freak> fabbomelker: that's nothing unusual =)
04:01:33 <fabbomelker> Im not an expert in programming, so I wanna make sure it could be worthwhile learing Haskell.
04:01:34 <kmc> works for me zipace
04:01:42 <mm_freak> zipace: works for me
04:01:53 <zipace> kmc: really? i get a 502 Bad Gateway
04:02:05 <mm_freak> fabbomelker: it will be much easier to understand haskell, when you have no background in programming in other languages
04:02:17 <kmc> maybe your gateway is bad :D
04:02:20 <zipace> must be something firefox related, because curl works. oh well
04:02:32 <mm_freak> zipace: nginx proxy?
04:02:46 <mm_freak> perhaps your local proxy is messed up
04:02:57 <zipace> i don't use any proxy
04:03:22 <fabbomelker> actually after studying five years of applied maths and computer science, haskell is the only the only language I have tried to learn on my own.
04:03:26 <zipace> but i'm pretty sure it's just my local firefox cache that wants to get cleared
04:04:03 * mekeor just worte hist first Hello-World-programm using HGL!! yay! hooray!
04:05:02 <mm_freak> mekeor: great…  next step:  write a hello world server…  shouldn't be longer than a few lines of code =)
04:05:27 <zipace> ugh, i swear firefox is trying to kid me. it works with curl and chrome
04:05:35 * zipace raises fist at firefox
04:06:20 <mm_freak> zipace: works for me with firefox 7.0.1
04:06:25 <mekeor> mm_freak: hehe =)
04:06:37 <zipace> i've got firefox 8 (maybe that's the reason?)
04:06:44 <mekeor> mm_freak: actually, IMO for web-servers (and similar thing) erlang would be better, no?
04:06:49 <kmc> firefox 8 is so outdated
04:06:52 <kmc> you need firefox 9000
04:06:53 <mekeor> lol
04:07:00 <mm_freak> mekeor: i don't think so
04:07:24 <kmc> mekeor, Haskell and Erlang are pretty different
04:07:34 <kmc> i think the tradeoff is more subtle than that
04:07:46 <kmc> with Haskell you have a lot more static checking
04:07:48 <mekeor> Yea, but Erlang is designed/developed for network-things
04:07:56 <kmc> eh, that's a simplistic marketing point
04:07:56 <mm_freak> kmc: their ideas of concurrency are very similar
04:08:01 <kmc> they're not that similar
04:08:17 <mm_freak> sure, haskell is just more generic
04:08:22 <kmc> they look similar because they're remarkably less terrible than the average language's idea of concurrency
04:08:22 <mekeor> kmc: okay, that's right; – i'm still a noob, so don't read my messages seriously
04:08:36 <kmc> GHC Haskell allows thread-shared mutable state, which has big effects on the runtime system etc.
04:08:39 <kmc> Erlang doesn't
04:08:45 <kmc> with Erlang it's message passing or nothing
04:08:54 <kmc> (afaik, and keep in mind I don't know much about Erlang)
04:08:57 <kalven> or ets
04:09:05 <mekeor> huh?
04:09:15 <kmc> hmm, that's true.  i guess shared databases count as shared state
04:09:22 <kmc> GHC gives you lots of different approaches to concurrency and parallelism
04:09:37 <mm_freak> i have tried erlang once…  it's based on message passing only…  you don't get nifty stuff like STM
04:10:11 <kmc> there's traditional lightweight threads (with automatic event-based IO), message passing, STM, pure parallelism, Cloud Haskell, DPH, monad-par, CHP, ...
04:10:12 <mekeor> mm_freak: anyway. actually, i weren't planning to write a haskell-(hello-world-)webserver yet, instead, i wanted to try to draw sierpinski-triangle using HGL.
04:10:24 <mm_freak> mekeor: not /web/ server
04:10:26 <mm_freak> just server
04:10:30 <mekeor> oh, i see.
04:10:34 <kmc> if i had to write a *distributed* system I would seriously consider Erlang (and also consider Haskell-based approaches like Cloud Haskell or Thrift)
04:10:35 <mm_freak> hPutStrLn h "Hello world!"
04:10:38 <mekeor> mm_freak: aah, i see.
04:10:54 <mm_freak> mekeor: but go ahead and do whatever is fun =)
04:10:58 <kmc> Erlang also gives you more fault tolerance and dynamic code reloading, at the expense of catching errors ahead of time
04:11:02 <kmc> otherwise, for systems running on a single machine, I am quite happy with Haskell
04:11:30 <mm_freak> kmc: i'd probably do distributed stuff with haskell, too
04:11:54 <mekeor> mm_freak: yea. i wanted to as you guys, how i can draw a sierpinski-triangle, because i can't directly use recursion in that case, afaik
04:12:05 <mm_freak> haskell gives you dynamic loading, which is not quite as convenient, but it's enough to change code in running applications
04:12:24 <fabbomelker> kmc, the parallelism support does it allow arbitrarily many cores? There is some reasearch at my Uni about using the cores in the graphic card for all sort of calculations (only floating point I think)
04:12:25 <kmc> why cant you use recursion mekeor?
04:12:38 <kmc> fabbomelker, yeah, there is some research on using the GPU in Haskell as well
04:12:43 <mm_freak> mekeor: no idea how to do that, but recursion would be my first guess
04:12:57 <kmc> fabbomelker, as for the support built into GHC, it uses arbitrarily many CPU cores
04:13:11 <kmc> on a single shared-memory system
04:13:16 <mekeor> kmc: maybe i can, but i don't know HOW…
04:13:35 <kmc> the classic description of the sierpinski triangle is recursive
04:13:38 <mm_freak> mekeor: well, obviously you should know how to compute that triangle first =)
04:13:44 <kmc> a sierpinski triangle is three sierpinski triangles arranged in a triangular shape
04:13:52 <mekeor> yea
04:13:58 <mm_freak> mekeor: but it really calls for either a lazy data structure or recursion
04:14:00 <fabbomelker> kmc: thanks a lot man, you seem to know a lot about Haskell indeed. What is your background?
04:14:02 <kmc> there are other interesting descriptions (like the stochastic iterative algorithm)
04:14:12 <applicative> fabblemelker, you can e.g. instruct the program to use a certain number of cores ./myprogram +RTS -N3 or whatever.
04:14:19 <mekeor> kmc: so, i have to do `triangle = draw three triangles'
04:14:31 <kmc> mekeor, you probably want to keep track of some depth
04:14:42 <kmc> and bail out at that depth
04:14:51 <mekeor> hm
04:14:51 <kmc> you'll also need to pass through parameters that say where to draw the triangle
04:14:57 <kmc> i.e. a 2D displacement and a 2D scale factor
04:15:00 <kmc> an affine transformation
04:15:21 <mekeor> wtf
04:15:21 <kmc> there's a whole general class of fractals which are defined as n affine-transformed copies of themselves
04:15:37 <kmc> fabbomelker, I've used Haskell on and off for various projects in the past 5 years
04:15:42 <mekeor> not comprehensable for me (yet)
04:15:44 <kmc> mostly for fun but I did some GHC hacking for pay
04:15:59 <kmc> alongside my education in CS and working at various software companies
04:16:16 <fabbomelker> ok I see, nice.
04:16:32 <mekeor> kmc: thank you for that inspirations.
04:16:35 <kmc> (actually the GHC hacking was mostly coding in shell and C, and not Haskell ;)
04:16:57 <mekeor> kmc: i'll first implement a function which draws a triangle (given three points)
04:17:04 <kmc> that sounds good
04:17:15 <mekeor> =)
04:17:51 <kmc> in fact in 3 steps you can generalize from that description of a sierpinski triangle to the beautiful fractals of http://electricsheep.org/
04:17:55 * applicative once again declares defeat trying to build the "ghc-kinds" branch of ghc
04:18:31 <mm_freak> mekeor: i think for this purpose it would be easier to write a function, which takes a point and a size and draws an equilateral triangle
04:18:44 <mm_freak> instead of three ponts
04:18:45 <mm_freak> points
04:18:48 <mekeor> hm.
04:21:35 <mm_freak> mekeor: just as a suggestion:  you probably know the fractal, which is obtained by recursively dividing a line into halves
04:21:57 <mm_freak> start with [0, 1], then [0, 0.5, 1], then [0, 0.25, 0.5, 0.75, 1], etc.
04:22:05 <mm_freak> try to solve that recursively
04:22:26 <ClaudiusMaximus> mapM_ drawTriangle . (!! depth) . iterate (concatMap subTriangles) $ [seedTriangle]  -- is one possibility, but 3^depth triangles might take some time to draw
04:22:30 <mm_freak> the sierspinski triangle is really an instance of this class of recursions
04:35:49 <mekeor``> cool: http://upload.wikimedia.org/wikipedia/de/7/7a/Koch-rekursiv.png
04:36:57 <ClaudiusMaximus> now i'm wondering how you might find the distance from a point to the nearest point in the sierpinski triangle - maybe some magic bittwiddling could do the trick
04:37:48 <mm_freak> ClaudiusMaximus: the centers of the sides of the surrounding triangle
04:38:54 <mm_freak> given vectors x and y for the vertices, that's just (x + y)/2
04:42:51 <ClaudiusMaximus> if it's a right angled triangle, maybe something like;  d x y = if (x + y) > 1 then minimum [1-x, 1-y, distance to x+y=1] else d (frac (2 * x)) (frac (2 * y)) where frac z = z - fromIntegral (floor z)
04:45:58 <mm_freak> ClaudiusMaximus: in the simple case it's an equilateral triangle
04:46:12 <hey_lu> hi there, what does the error 'ghc-cabal: Installed package ID not registered: "deepseq-1.2.0.1-inplace"' mean?
04:46:40 <mm_freak> and you really just need (x+y)/2, because the sierpinski triangle is very related to this:
04:46:58 <mm_freak> let fractal 0 x y = []; fractal n' x y = let n = pred n'; m = (x+y)/2 in fractal n x m ++ [m] ++ fractal n m y in fractal 3 0 1
04:47:02 <mm_freak> > let fractal 0 x y = []; fractal n' x y = let n = pred n'; m = (x+y)/2 in fractal n x m ++ [m] ++ fractal n m y in fractal 3 0 1
04:47:03 <lambdabot>   [0.125,0.25,0.375,0.5,0.625,0.75,0.875]
04:47:14 <mm_freak> just in two dimensions
04:47:29 <kmc> hey_lu, hmm, where are you getting that error message?
04:48:50 <hey_lu> kmc: on 'make install' in a recent ghc-7.3-2011... tarball
04:49:19 <mm_freak> wow, that code seems to be very lazy
04:49:42 <mm_freak> > let fractal 0 x y = []; fractal n' x y = let n = pred n'; m = (x+y)/2 in fractal n x m ++ [m] ++ fractal n m y in fractal 10000 0 1
04:49:44 <lambdabot>   [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0....
04:51:55 <ClaudiusMaximus> mm_freak: hm..  suppose instead take the cantor middle third fractal, because your example doesn't have the large gaps that the sierpinski triangle does
04:52:22 <mm_freak> ClaudiusMaximus: look at the edges only
04:52:32 <mm_freak> the edges are divided exactly like in that rule
04:52:44 <ClaudiusMaximus> mm_freak: right, i see that
04:55:14 <ClaudiusMaximus> mm_freak: but if you're somewhere off-center in an empty triangle, how does (x+y)/2 (with x,y being vectors) help find the distance
04:55:47 <erus`> :t putStr
04:55:48 <lambdabot> String -> IO ()
04:56:44 <mm_freak> ClaudiusMaximus: where a, b and c are the vertices of an up-pointing triangle, (a+b)/2, (b+c)/2 and (a+c)/2 are the vertices of the inner down-pointing triangle
04:57:35 <ClaudiusMaximus> mm_freak: yes.
04:59:41 <mm_freak> that gives you three new triangles, one of them being (a/2 + (a+b)/4, (a+b+c)/2, a/2 + (a+c)/4)
05:01:07 <mm_freak> or actually more easily:  it gives you three new up-pointing triangles, one of them being (a, (a+b)/2, (a+c)/2)
05:01:40 <mm_freak> the others are (b, (a+b)/2, (c+b)/2) and (c, (a+c)/2, (b+c)/2)
05:01:42 <mm_freak> you get the idea
05:03:16 <ClaudiusMaximus> > let cd x | x < 1/3 = cd (frac (3 * x)) / 3 | x > 2/3 = cd (frac (3 * x - 2)) / 3 | otherwise = (x - 1/3) `min` (2/3 - x) where frac z = z - fromIntegral (floor z) in cd (1/19 :: Rational)
05:03:17 <lambdabot>   8 % 513
05:06:35 <ClaudiusMaximus> > [ 1/19 + 8/513, 1/19 - 8/513] :: [Rational]
05:06:36 <lambdabot>   [35 % 513,1 % 27]
05:07:05 <tdammers> > 4/3 :: Rational
05:07:06 <lambdabot>   4 % 3
05:07:08 <tdammers> heh
05:07:22 <tdammers> hadn't occurred to me that you could do that
05:07:23 <tdammers> :P
05:09:26 <ClaudiusMaximus> 4 / 3 :: Rational = (4 :: Rational) / (3 :: Rational) = (4 % 1) / (3 % 1) = see the relevant source for what happens next, probably complicated :)
05:09:52 <antihoax> hey
05:10:32 <tdammers> complicated? why?
05:11:03 <tdammers> (4 % 1) / (3 % 1) == (4 % 1) * (1 % 3) == (4 % 3)
05:11:17 <hpc> tdammers: it was sarcasm, i think :P
05:12:20 <mekeor``> antihoax: hello
05:12:43 <ClaudiusMaximus> hpc: well, probably in cases like (4%3) * (3%4) it has to reduce to (1%1) isntead of (12%12) - that's more complicated than otherwise
05:12:55 <tdammers> yup
05:13:08 <tdammers> that's the complicated part
05:13:31 <tdammers> but for n/m, where n and m are integers, it's just as trivial as n%m
05:14:00 <hpc> ClaudiusMaximus: it just divides both sides by the gcd of the numerator and denominator
05:20:04 <hpaste_> “Ertugrul Söylemez” pasted “Sierpinski triangle renderer” at http://hpaste.org/52273
05:20:20 <mm_freak> ClaudiusMaximus, mekeor``: see the paste
05:21:43 <mm_freak> doesn't evenn have to be equilateral…  the code can render sierpinski triangles of any shape
05:23:05 <kmc> bad bot stenobot2011 :(
05:39:21 <erus`> > fix id
05:39:24 <lambdabot>   mueval-core: Time limit exceeded
05:39:28 <erus`> @hoogle fix
05:39:28 <lambdabot> Data.Function fix :: (a -> a) -> a
05:39:28 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
05:39:28 <lambdabot> module Control.Monad.Fix
05:41:21 <kmc> > fix error
05:41:22 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:41:40 <erus`> take 10 $ fix (1:)
05:41:44 <erus`> > take 10 $ fix (1:)
05:41:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
05:42:25 <erus`> i dont even wanna think about how to implement partially applied infix operators...
05:43:15 <hpaste_> ClaudiusMaximus annotated “Sierpinski triangle renderer” with “Sierpinski triangle renderer (annotation)” at http://hpaste.org/52273#a52277
05:43:45 <luite> > fix id
05:43:49 <lambdabot>   mueval-core: Time limit exceeded
05:43:50 <hpaste_> applicative annotated “Sierpinski triangle renderer” with “trashy Sierpinski triangle renderer (annotation)” at http://hpaste.org/52273#a52278
05:43:54 <erus`> errr actually, if its missing a l/r value then erm
05:44:21 <ClaudiusMaximus> mm_freak: paste has my approach, i think i didn't explain it well in irc
05:45:54 <erus`> i really like agda's if_then_else_ infix notation
05:46:17 <flux> erus`, what's it like?
05:46:33 <flux> or is it one of those 2d expressions.. ?-)
05:47:00 <erus`> just reads where the underscores are
05:47:01 <applicative> it's just that if_then_else is a defined expression.
05:49:25 <mm_freak> ClaudiusMaximus: uhm…  that renders a triangle?
05:52:16 <ClaudiusMaximus> mm_freak: did you try it?
05:54:37 <mm_freak> ClaudiusMaximus: not yet, let me try it out
05:58:58 <erus`> "a function can be tail recursive if the last statement in the function is a function call" Every haskell function is a single statement right? so every function can be tail recursive?
05:59:34 <mm_freak> ClaudiusMaximus: oh, i get it now
05:59:43 <mm_freak> interesting approach
05:59:49 <Eelis> erus`: the key thing is that the result of the recursive call is also the result of the current call
06:00:12 <erus`> ah ok
06:00:13 <Eelis> erus`: if additional processing is needed to turn the result of the recursive call into the result of the current call, then tail recursion won't work
06:00:15 <mm_freak> ClaudiusMaximus: i wouldn't know how to convert this into actual renderable triangles though
06:01:56 * applicative liked ClaudiusMaximus's triangles when he rendered them
06:02:13 * hackagebot parallel 3.2.0.0 - Parallel programming library  http://hackage.haskell.org/package/parallel-3.2.0.0 (SimonMarlow)
06:03:14 <mm_freak> applicative: i'm thinking of vector based drawing libraries like OpenGL
06:03:20 <mm_freak> or gloss for that matter
06:03:31 <ClaudiusMaximus> mm_freak: right, it generates a raster straight off, instead of rasterizing triangles
06:03:37 <Eidel> I have an if-else in a list comprehension, i dont want the else part but the compiler refuses to accept it. What am i supposed to do?
06:03:55 <Eelis> Eidel: show the code
06:04:09 <mm_freak> Eidel: if without else does not make sense in haskell
06:04:20 * applicative knew that, but somehow pixel k = "Xo,. " !! (floor k `min` 4) had a special delight to it
06:04:25 <mm_freak> what's the expression's value, if the condition is not met?
06:04:25 <Twey> Eidel: Perhaps you want to pattern-match instead
06:04:30 <Twey> Or use a filter condition
06:04:38 <hpaste_> Eidel pasted “Prime” at http://hpaste.org/52279
06:04:46 <Twey> > [ x | x <- xs, conditionIsMet x ]
06:04:47 <lambdabot>   Not in scope: `xs'Not in scope: `conditionIsMet'
06:04:54 <Twey> Er
06:05:01 <mm_freak> Eidel: use 'when' from Control.Monad
06:05:02 <Twey> I didn't mean to add that >, but yes :þ
06:05:12 <mm_freak> :t when
06:05:13 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:05:45 <ClaudiusMaximus> > [ x | x <- [1..10], even x ]
06:05:46 <lambdabot>   [2,4,6,8,10]
06:05:57 <mekeor``> :t filter
06:05:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:05:59 <mm_freak> Eidel: you can also write an IO action, which doesn't do anything and just results in ():  return ()
06:06:10 <Eidel> Thanks guys. I have some options now :)
06:06:10 <mekeor``> filter even [1..10]
06:06:12 <donri> > filter even [1..10]
06:06:12 <mekeor``> > filter even [1..10]
06:06:13 <lambdabot>   [2,4,6,8,10]
06:06:13 <lambdabot>   [2,4,6,8,10]
06:06:13 <mm_freak> so you don't have to do putStr ""
06:06:22 <donri> :)
06:06:25 <mekeor``> :)
06:06:40 <donri> > [2,4..10]
06:06:41 <lambdabot>   [2,4,6,8,10]
06:06:43 <applicative> main = sequence_ [ putStrLn (show k) | k <- [2..], isPrime k (k-1) ]
06:06:48 <mm_freak> let even 5 = True; even n = Prelude.even n in filter even [1..10]
06:06:51 <mm_freak> > let even 5 = True; even n = Prelude.even n in filter even [1..10]
06:06:52 <lambdabot>   [2,4,5,6,8,10]
06:06:58 <ClaudiusMaximus> > do{ x <- [1 .. 10] ; guard (even x) ; return x }
06:06:59 <lambdabot>   [2,4,6,8,10]
06:07:04 <Twey> main = sequence_ [ if (isPrime k (k-1)) then putStrLn (show k) else return () | k <- [2 ..] ] is equivalent to main = sequence_ [ when (isPrime k (k - 1)) (print k) | k <- [2 ..] ] is equivalent to main = mapM_ print [ k | k <- [2 ..], isPrime k (k - 1) ]
06:07:34 <Eidel> Twey: okay
06:07:42 <Eidel> Nice
06:07:44 <shirt> can i initialize a TVar with undefined or will bad things happen?
06:07:49 <erus`> how is Data.Vector implemented in haskell
06:07:53 <erus`> is it a native thing?
06:07:53 <Eidel> Never seen when before.
06:08:17 <mm_freak> shirt: you can, but you don't want to
06:08:26 <mm_freak> shirt: you may want to have TMVar instead
06:08:26 <Twey> Eidel: ‘return ()’ means ‘do nothing’ in IO.
06:08:34 <mm_freak> shirt: or TVar (Maybe Type)
06:08:37 <ClaudiusMaximus> @hoogle newEmpty
06:08:38 <lambdabot> Control.Concurrent.MVar newEmptyMVar :: IO (MVar a)
06:08:38 <lambdabot> Control.Concurrent.SampleVar newEmptySampleVar :: IO (SampleVar a)
06:08:38 <lambdabot> Control.Concurrent.STM.TMVar newEmptyTMVar :: STM (TMVar a)
06:08:52 <shirt> mm_freak: i promise i won't read from it until i write a real value to it
06:08:53 <applicative> Eidel you need to import Control.Monad to use when, if I remember
06:09:04 <mm_freak> shirt: then use TMVar or MVar
06:09:07 <Twey> Yes, Control.Monad.when, Control.Monad.mapM_
06:09:10 <mm_freak> :t newEmptyMVar
06:09:11 <lambdabot> Not in scope: `newEmptyMVar'
06:09:24 <Twey> Control.Monad.sequence_, for that matter
06:09:25 <ClaudiusMaximus> initialize it with: error "you broke my promise" instead of undefined
06:09:31 <Twey> Oh, and putStrLn . show = print
06:09:50 <ClaudiusMaximus> but i never used STM in anger, so i don't know if it's advisable
06:09:50 <mm_freak> shirt: then in one thread you can compute something, the other thread reads from the variable using takeMVar/takeTMVar
06:10:06 <Twey> Eidel: when cond act = if cond then act else return ()
06:10:07 <mm_freak> shirt: the latter thread is suspended, until a value is putMVar/putTMVar-d into the variable
06:10:11 <applicative> Twey, but sequence_ etal are in Prelude, thats all I meant
06:10:17 <shirt> mm_freak: but i am sure that the other thread won't read from it until the first read has finished computing
06:10:23 <Twey> applicative: They are?  o.@
06:10:31 <Twey> Woah, they are
06:10:31 <Eidel> Twey: oki
06:10:35 <mm_freak> shirt: even then i'd still not use undefined/error
06:10:36 <Twey> I did not know that
06:10:40 <applicative> maybe im hallucinating
06:10:52 <shirt> mm_freak: hm...
06:10:55 <donri> I thought only mapM* were
06:10:57 <hirsch_> I have a Problem with c2hs enums, how can I return an enum value, I used: {#fun pure PvInitialize as ^
06:10:57 <hirsch_>     {} -> `PvErr' toEnum  #} but I get the error:Couldn't match expected type `Int' with actual type `CInt'
06:10:57 <hirsch_>   
06:10:57 <Twey> Is this a new thing?
06:11:08 <mm_freak> shirt: an empty MVar is perfectly fine for waiting for a value, even if you don't read from it, until the value is there
06:11:11 <Twey> I don't remember any of these being in Prelude.  I've always imported Control.Monad for them.  o.@
06:11:13 <donri> guess not
06:11:21 <mm_freak> shirt: or TMVar, if you are calculating in a transaction
06:11:24 <applicative> maybe it is, they seem to be there at the moment, I'm using 7.2's base
06:11:55 <mm_freak> shirt: btw, what concurrent application would not read from a variable, until the value is computed?  that sounds very serial to me
06:12:10 <quicksilver> Twey: it's not new; http://www.haskell.org/onlinereport/prelude-index.html
06:12:22 <Twey> Weird.  Okay.
06:12:28 <ClaudiusMaximus> Twey: you might get warnings if you use explicit import lists like "import of x from Y is redundant" if the same x is already implicitly imported from Prelude - but i haven't checked
06:12:41 <Twey> ClaudiusMaximus: I've never had one
06:13:10 <donri> might need to enable warnings?
06:13:32 <shirt> mm_freak: this is serial. it's a program where events get fired. each event handler has a reference to the TVar. the initial value of the TVar will be set by event A, which will always fire before event B which will read the TVar. but there is no good default/initial value to set for the TVar before event A gets fired
06:14:22 <hpaste_> ClaudiusMaximus pasted “redundant imports” at http://hpaste.org/52280
06:15:36 <donri> Twey: perchance you don't use -Wall?
06:15:49 <kmc> erus`, GHC provides some primitive types for arrays; Data.Vector is several layers of wrapping on top of those
06:15:55 <Twey> Could be, could be
06:16:02 * Twey makes a note to do so in the future.
06:16:42 <mm_freak> shirt: you should try to rethink your concept…  it should always be possible to make this dependency static
06:16:54 <mm_freak> then you don't need that initial value anymore
06:17:18 <shirt> mm_freak: yeah, i'm trying to think about how to refactor this, but it's not trivial :/
06:18:19 <kmc> shirt, you can also have a TVar that holds a Maybe value
06:18:21 <kmc> or use TMVar
06:18:56 <ClaudiusMaximus> shirt: i had a similar issue with gtk/glext - the gl context gets created on realize event, so i can't initialize things until then, and i didn't want to have to unwrap maybes all the time in the display callback..
06:19:38 <shirt> ClaudiusMaximus: this sounds very similar to my situation
06:19:39 <ClaudiusMaximus> so at the moment i'm hoping that realize always gets called before display
06:19:43 <kmc> using (error "whatever") should work though, if that turns out to be cleaner
06:20:04 <mm_freak> shirt: you can enter a new loop after the initial event
06:21:10 <shirt> ClaudiusMaximus: so you initialize the context variable to undefined/error ?
06:21:31 <shirt> mm_freak: not quite that simple with my code :/
06:22:06 <mm_freak> shirt: considered using FRP?
06:22:42 <shirt> mm_freak: i actually have but i'm not advanced enough to figure out how to apply it to my problem
06:22:53 <ClaudiusMaximus> shirt: essentially yes, though the context variable is kept behind the scenes inside gtk2hs or something
06:23:13 <mm_freak> shirt: who sends the events?
06:24:01 <shirt> mm_freak: a bunch of haskell threads that read from sockets
06:25:25 <mm_freak> shirt: have two event channels…  one for waiting for the initialization only
06:25:50 <mm_freak> wait on the first channel, until the initialization is complete, then go on to the second variable for the run-time events
06:26:57 <mm_freak> written properly the first channel will be garbage-collected as soon as the initialization is done
06:28:03 * frerich skims planet.haskell.org, reads "What the Hell is a Monad?" and notices that he has a reflex of skipping this article in its entirety.
06:28:08 <mm_freak> the first channel can be a simple MVar…  the main thread waits for one of the other threads to send an initialization…  this is a simple takeMVar operation
06:29:34 <Eidel> Can i have a function that works with one or no arguments?
06:29:46 <kmc> no, you can't have a function with no arguments at all
06:29:56 <kmc> every function in Haskell has exactly one argument
06:30:19 <Eidel> When i execute my main function, what argument does it take? Oo
06:30:24 <kmc> main isn't a function
06:30:29 <kmc> it's an IO action
06:30:37 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
06:30:43 <mm_freak> Eidel: a function always involves a (->) in the type
06:30:55 <mm_freak> an object of type Int -> Int is a function
06:30:58 <shirt> mm_freak: hm.... thanks i'll try to figure something out
06:31:09 <kmc> Eidel, most languages use functions for three unrelated purposes:  argument dependence, side effects, and deferred evaluation
06:31:18 <kmc> Haskell has separate constructs for all three
06:31:50 <EvanR-work> Eidel: if you want 'zero or one' values, use Maybe
06:31:51 <Eidel> kmc: that seems like a good thing to do
06:32:07 <kmc> Eidel, to separate them?
06:32:08 <Eidel> EvanR-work: Ah! Thx
06:32:14 <Eidel> kmc: yes
06:32:23 <Eidel> I just had a lecture about that =P
06:32:48 <donri> no, if you want zero or more you want lists
06:32:53 <donri> Maybe is zero or one :)
06:32:57 <EvanR-work> i said that
06:32:58 <mekeor``> is "round a/sqrt 3*h" equal to "round(a/(sqrt 3)*h)" ?
06:33:09 <KitB> Anyone know a fast way of finding out whether something is a binary power?
06:33:26 <donri> in deed you did, and i misread it three times
06:33:31 <donri> moar coffee
06:33:36 <Eidel> donri: thats what i want. But i want the main IO action to take arguments Oo
06:33:47 <kmc> IO actions don't take arguments; functions take arguments
06:33:50 <EvanR-work> main IO action cant take arguments
06:33:53 <donri> Eidel: then refactor your IO action "factory" and call it in main
06:33:55 <kmc> but functions can return IO actions, because IO actions are like any other value
06:34:06 <kmc> Eidel, 'main' is more like a data value than a function.  it's an inert description of how to perform some IO
06:34:09 <EvanR-work> for programs to take arguments you need to read command line argments
06:34:20 <kmc> evaluating the description won't perform the IO
06:34:20 <donri> System.Environment.getArgs
06:34:30 <Eidel> Ok
06:34:31 <kmc> but the runtime system knows how to interpret such an IO action and execute the steps so described
06:34:42 <Eidel> Sounds messy :(
06:34:52 <kmc> it's not, i promise :)
06:34:57 <mekeor``> is "round a/sqrt 3*h" equal to "round((a/(sqrt 3))*h)" ?
06:35:21 <kmc> but i probably shouldn't try to convince you of that
06:35:30 <kmc> you'll understand it as you learn more haskell
06:35:56 <kmc> Eidel, do note that this is a *conceptual* model; under the hood, the implementation is free to blur the distinction between functions and IO actions in the name of performance
06:36:00 <kmc> (as GHC does)
06:36:50 <applicative> Eidel, what kind of arguments do you want, what are you going to do with them?
06:37:31 <frerich> KitB: You mean, where something is a power of two? You could check if the number of bits set is exactly one.
06:37:47 <EvanR-work> kmc: nah, everything is haskell is magic
06:37:54 <kmc> false ;)
06:37:54 <EvanR-work> its running on pure math
06:37:58 <KitB> frerich: In haskell?
06:38:15 <sipa> @faq can Haskell solve the halting problem?
06:38:15 <lambdabot> The answer is: Yes! Haskell can do that.
06:38:31 <Eidel> applicative: a number, like 17. Find every prime number <=17
06:38:44 <kmc> Eidel, are you trying to read command-line arguments?
06:38:45 <mekeor``> > primes
06:38:45 <lambdabot>   Not in scope: `primes'
06:38:55 <kmc> @hoogle getArgs
06:38:56 <applicative> so the user enters a numeral, then you print the primes below it?
06:38:56 <lambdabot> System.Environment getArgs :: IO [String]
06:39:21 <Eidel> kmc: yes i'm using getArgs atm
06:39:28 <Eidel> not finished though =P
06:39:46 <kmc> ok
06:39:47 <ClaudiusMaximus> mekeor``: no, it's ((round a) / (sqrt 3)) * h
06:39:51 <kmc> then 'main' is not taking function arguments
06:40:01 <mekeor``> ClaudiusMaximus: oh, right. thank you!
06:40:19 <ClaudiusMaximus> mekeor``: which won't typecheck, needs more fromIntegrals
06:40:54 <applicative> main = getArgs >>= putStrLn . head   is a sort of echo    your operation would be main = getArgs >>= print . primesBelow . head
06:41:21 <mekeor``> ClaudiusMaximus: thank you. i got it working
06:41:29 <kmc> maybe:  getArgs >>= print . primesBelow . read . head
06:41:37 <kmc> this is not robust to malformed input of course
06:41:41 <applicative> right, like kmc said
06:42:21 <applicative> my thought was Eidel shouldn't be getting too involved with IO nonsense unless he has to.
06:42:34 <applicative> Eidel, check out my favorite
06:42:41 <applicative> @type interact
06:42:42 <lambdabot> (String -> String) -> IO ()
06:43:14 <hpaste_> Eidel pasted “Prime2” at http://hpaste.org/52282
06:43:25 <Eidel> I did it like that. :)
06:43:31 <applicative> so main = interact (show . primesBelow . read)
06:43:41 <Eidel> hmm
06:43:52 <applicative> the user does something like echo 17 | ./Eidelsprimes
06:44:00 <applicative> and gets the primes.
06:44:12 <Eidel> cool
06:44:17 <frerich> KitB: Yes; there is a Data.Bits module which lets you tinker with bits of values.
06:44:45 <KitB> frerich: Cool
06:45:05 <applicative> with interact you just focus on getting the types to fit so that its all String -> String (as I was failing to do above where kmc pointed out I forgot `read`)
06:45:13 <absence> is there a library that lets you load and save images, and map over pixels (e.g. converting integer pixels to floating point, doing calculations, etc)
06:46:00 <applicative> Eidel, it's somehow conceptually nice, you move from a raw string into you data structure, do your pure haskelly manipulations, then move out into string-land again.
06:46:22 <shirt> is it acceptable to use existential types?
06:46:23 <applicative> there is also Data.ByteString.interact and Data.Text.interact
06:46:50 <EvanR-work> foo :: (String -> a) -> (b -> String) -> (a -> b) -> IO ()
06:47:28 <applicative> main = foo read show (+1)
06:47:35 <ClaudiusMaximus> absence: i think repa has some image io functions in a support library
06:48:05 <applicative> repa has a bmp library.  there is also repa-devil, but I couldn't build it the other day
06:48:45 <EvanR-work> types are the shit
06:49:03 <kmc> shirt, in general? yeah
06:49:12 <kmc> do you have a specific use case in mind?
06:49:35 <applicative> absence http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial look at the simple examples toward the bottom.  you need the libdevil C library
06:50:03 <shirt> kmc: yeah, but it's complicated to explain. i'm not sure if existentials will help me here, i'm reading about them... do you always use existentials together with type classes?
06:50:11 <kmc> no, you don't always
06:50:35 <shirt> kmc: ok thanks that's all i need to know for now :)
06:51:24 <hpaste_> kmc pasted “existentials for generic containers (for shirt)” at http://hpaste.org/52283
06:52:15 <shirt> kmc: thanks that looks good
06:52:18 * hackagebot WebBits 2.1 - JavaScript analysis tools  http://hackage.haskell.org/package/WebBits-2.1 (ArjunGuha)
06:52:28 <kmc> shirt, this looks something like object-oriented programming, with Haskell types as interfaces, and ordinary Haskell values taking the role of classes, constructors, "factories", and any number of silly things
06:52:39 <kmc> in other words it's an encoding of OOP with very high abstraction potential
06:53:07 <kmc> contrast with the more common and (in my view) inferior encoding where each OOP class is a new data type, and they're all tied together with some type class
06:53:21 <kmc> see also http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
06:54:08 <EvanR-work> structural typing seems cool
06:54:21 <shirt> kmc: i've basicly run into the problem where i have a type "Foo x", and i need a list containing "Foo Int", "Foo Char", etc...
06:54:22 <applicative> absence there are some illustrations of the use of repa's bmp library in the Canny and Blur examples in http://hackage.haskell.org/package/repa-examples
06:54:26 <frerich> I currently use '(>= 2) . length . filter (== True)' to test that some list has at least two value 'True'. Is it possible to make this bail out early (and thus work on infinite lists) without using raw recursion or folds but some higher level functions?
06:54:26 <EvanR-work> but the idea of subtyping is bunk
06:54:49 <Twey> EvanR-work: {{cn}}
06:54:58 <kmc> shirt, why do you need a list of all of those?
06:55:03 <EvanR-work> Twey: eh?
06:55:12 <Twey> EvanR-work: [citation needed]
06:55:14 <applicative> absence: there are of course a number of libraries on hackage for reading and writing specific image types by way of particular data structures.
06:55:16 <ClaudiusMaximus> frerich: lazy natural numbers and genericLength - or pattern match on the list
06:55:27 <EvanR-work> Twey: liskov substitution principle ;)
06:55:34 <Twey> Accepted :þ
06:55:55 <kmc> EvanR-work, the Liskov substitution principle is a lot easier to satisfy with immutable data
06:55:59 <hpc> i would go with lazy natural numbers, which have applications elsewhere in exploiting laziness
06:56:09 <shirt> kmc: not sure if i explain it easily :/
06:56:29 <kmc> shirt, that's okay
06:56:33 <kmc> hopefully what i said is useful
06:56:42 <shirt> kmc: it was, i'll read those links. thanks!
06:57:25 <kmc> i think the reason people encode OOP classes and interfaces as Haskell types and type classes has nothing to do with OOP and everything to do with limitations of certain popular OOP languages
06:57:37 <kmc> in Java you are expected to make a new type for each new behavior
06:58:01 <kmc> this is madness in Haskell -- behaviors are functions or IO actions, and are first-class values
06:58:45 <kmc> but the limits on functional abstraction in languages like Java cause us to think of OOP in this more cumbersome form
06:59:36 <EvanR-work> java is messed up. and its touted as being great
06:59:36 <kmc> it's also the case that my example isn't "really" OOP, just abstract data types
06:59:55 <kmc> (which is something the OOP crowd tries to retroactively take credit for, but actually existed long before)
07:00:25 <kmc> EvanR-work, I don't think it's touted as being great
07:00:36 <EvanR-work> in the book store it is
07:00:44 <EvanR-work> 'way better than c++'
07:00:44 <kmc> eh and RWH touts Haskell as being great
07:00:50 <kmc> i suppose the authors of books want to sell their books
07:01:20 <kmc> but a lot of the users of Java -- even respectable, conservative, industrial users -- are voicing their displeasure with the language's stagnation, and looking for something new
07:01:24 <EvanR-work> not just books, but practitioners, noobs, and the java channel
07:01:33 <kmc> oh wow the Java channel likes Java ;P
07:01:50 <EvanR-work> yes
07:01:51 <erus`> vb < java < C++ < scheme < haskell < lambdurp
07:01:53 <EvanR-work> people who like java like java
07:01:57 <kmc> there seem to be roughly three camps
07:01:57 <EvanR-work> and saying theyre idiots
07:01:57 <Nimatek> They can just switch to Scala then. Allows them to keep the codebase, too.
07:02:10 <kmc> one wants something really new with a heap of new concepts, like Scala
07:02:20 <EvanR-work> c++ has the property of being at the bottom of all lists
07:02:29 <ohwow> wtf is lambdurp
07:02:34 <kmc> one wants something 10% better than Java, with a few small syntactic fixes only
07:02:43 <ohwow> and why the hell you think that c++ is better than java
07:02:48 <kmc> Red Hat's "Ceylon" language falls in this category, and it has a few competitors
07:02:48 <tdammers> ...haskell < unlambda < INTERCAL
07:03:02 <ohwow> sure, java is kinda bad, but c++ is just a real fucking mess
07:03:06 <int-e> INTERCAL < unlambda
07:03:09 <kmc> the third push is to run existing popular dynamic languages on JVM
07:03:13 <kmc> Jython, JRuby, Rhino
07:03:24 <kmc> guys let's argue about which language is the best, completely devoid of any context about where it's being used
07:03:26 <ohwow> lol EvanR-work, agree
07:03:28 <tdammers> unlambda doesn't let me write PLEASE DO GIVE UP
07:03:32 <kmc> spoiler alert: Haskell is the best
07:03:35 <tdammers> so unlambda < INTERCAL
07:03:35 <kmc> go home everyone, we figured it out
07:03:47 <EvanR-work> yes
07:03:51 <int-e> tdammers: INTERCAL lacks call/cc.
07:04:16 <tdammers> you don't need that when you have COME FROM
07:04:21 <kmc> people who argue Java sucks because it lacks hyperplasmomorphic semixylogroupisms are missing the point
07:04:32 <EvanR-work> it lacks functions o_O
07:04:47 <sipa> it lacks polymorphic operators
07:05:02 <kmc> Java isn't supposed to be the sexy functional language you all know and love
07:05:14 <kmc> it's supposed to be a simple glue language so that output of many average programmers can be combined
07:05:17 <kmc> to form boring business software
07:05:19 <EvanR-work> so instead it was supposed to be barely turing complete
07:05:29 <int-e> tdammers: I admit that I like the way threaded INTERCAL extends the language.
07:05:41 <kmc> however I think that low expectations breed low results -- especially since Java has defined the CS curriculum for many people
07:06:09 <EvanR-work> thats a really sad development
07:06:23 <EvanR-work> but the market has spoken
07:06:58 <erus`> > let f 1 = 2; g 1 = 2; f 2 = 1 in f 2
07:06:59 <lambdabot>   Conflicting definitions for `f'
07:06:59 <lambdabot>  Bound at: <interactive>:1:4
07:06:59 <lambdabot>            <in...
07:07:29 <erus`> all function defs have to be together ?
07:07:57 <sipa> > let { f 1 = 2; g 1 = 2; f 2 = 1} in f 2
07:07:58 <lambdabot>   Conflicting definitions for `f'
07:07:58 <lambdabot>  Bound at: <interactive>:1:6
07:07:58 <lambdabot>            <in...
07:08:27 <quicksilver> erus`: yes.
07:08:28 <EvanR-work>  > let { f 1 = 2; f 2 = 1; g 1 = 2; } in f 2
07:08:36 <EvanR-work> > let { f 1 = 2; f 2 = 1; g 1 = 2; } in f 2
07:08:37 <lambdabot>   1
07:08:40 <quicksilver> all the equations defining a single function must be adjacaent.
07:09:16 <erus`> lambdurp doesnt have this 'limitation' :P
07:10:46 <sipa> what is lambdurp?
07:16:38 <kmc> annoyingly also all function equations must have the same number of formal parameters
07:16:48 <kmc> so you can't say «f 3 = 7; f = id»
07:18:25 <parcs> yeah why is that
07:18:37 <mekeor``> why does "main = do a <- sqrt 2" not work?
07:18:48 <kmc> the Haskell report has a lot of little limitations that make life easier for implementors
07:18:49 <sipa> mekeor``: what type has "sqrt 2" ?
07:18:51 <mux> because sqrt is a pure function, not a monadic one
07:18:55 <EvanR-work> :t sqrt 2
07:18:56 <lambdabot> forall t. (Floating t) => t
07:19:13 <kmc> "pure function" vs "monadic function" is a silly and misleading way to put it
07:19:24 <kmc> they're all pure functions
07:19:30 <sipa> sqrt is not an action that can be bound
07:19:31 <EvanR-work> or values
07:19:35 <erus`> do x = x
07:19:47 <mekeor``> what should i do instead?
07:19:48 <kmc> mekeor``, in that context the thing to the right of '<-' should be an IO action
07:20:02 <tdammers> do let a = sqrt 2
07:20:02 <kmc> mekeor``, depends on what you're trying to do
07:20:17 <mekeor``> tdammers: do i need a "in" afterwards then?
07:20:22 <kmc> not within "do"
07:20:24 <tdammers> no
07:20:27 <mekeor``> okay. perfect.
07:20:28 <kmc> there is a special "let" syntax inside "do"
07:20:30 <mekeor``> thanks :)
07:20:39 <mekeor``> like in the interpreter…
07:20:43 <EvanR-work> > do let a = sqrt 2
07:20:44 <lambdabot>   <no location info>:
07:20:44 <kmc> yep
07:20:44 <lambdabot>      The last statement in a 'do' construct must be an ...
07:20:57 <kmc> > do { let a = sqrt 2; return a } :: [Int]
07:20:58 <lambdabot>   <no location info>: parse error on input `}'
07:21:10 <erus`> > do let a = sqrt 2; ()
07:21:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:21:16 <erus`> > do let a = sqrt 2; return ()
07:21:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:21:17 <kmc> > do { let { a = sqrt 2 }; return a } :: [Int]
07:21:18 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
07:21:18 <lambdabot>    arising from a use of...
07:21:21 <kmc> bleh
07:21:22 <EvanR-work> kmc: not Int
07:21:23 <kmc> > do { let { a = sqrt 2 }; return a } :: [Double]
07:21:24 <lambdabot>   [1.4142135623730951]
07:22:07 <absence> ClaudiusMaximus, applicative: thanks, i'll check them out :)
07:23:14 <mux> kmc: maybe so, but it's a widely used terminology and it makes the point get through...
07:23:40 <mux> especially for people who are not necessarily category theory scientists
07:24:00 <erus`> my stupid brain longs for more simplicity and minimalism in programming languages
07:24:17 <erus`> until im stuck with turing tarpits
07:24:32 <kmc> erm, this has nothing to do with "category theory"
07:24:50 <parcs> hyperbole is the most annoying thing ever
07:24:58 <kmc> popularity does not mean it's either correct or a good idea
07:25:13 <EvanR-work> popularity is inversely proportional to goodness
07:25:20 <kmc> it's fundamentally wrong to think of IO as a scheme for tagging "impure functions"
07:25:25 <quicksilver> it is quite widespread even formally.
07:25:30 <kmc> it encourages all kinds of other wrong thinking
07:25:47 <quicksilver> the process "a -> b" ==> "a -> m b" is called "monadification"
07:25:49 <mux> kmc: my point being that as much as I love the haskell community, it has a clear tendency to get slightly pendantic with respect to a fair number of things; and I think that was a good example of it
07:26:02 <khs> anyone know of a place to get documentation for the language-python package?
07:26:23 <EvanR-work> mux: you mean people in haskell like to be right rather than wrong?
07:26:49 <erus`> someone is wrong on #haskell !
07:26:59 <EvanR-work> the thing to the right of <- doesnt need to be a function
07:27:02 <erus`> brace yourselves!
07:27:17 <kmc> it's not pedantry; it's a substantive difference in how you think about the language
07:27:43 <mux> sure, but a difference that soemone who is writing "do foo <- sqrt 2" has little chances of understanding anyways
07:27:50 <parcs> there kmc goes being pedantic again :P
07:27:55 <kmc> no, i don't think that's true mux
07:28:01 <EvanR-work> mux: great reason to help him
07:28:05 <mux> and yeah, that last comment in itself was pedantic :-P
07:28:16 <kmc> i think Cale's "Introduction to IO" document lays out the model of IO actions in a simple way that's accessible to beginners
07:28:24 <kmc> it's really not any more difficult than "impure functions"
07:28:28 <kmc> and has the advantage of being correct
07:28:30 <quicksilver> I think monadic function is a reasonable term for kleisli functions.
07:28:44 <quicksilver> using "pure" in apposition is the problem
07:28:47 <EvanR-work> beginners might think of getChar as a monadic function
07:28:49 <mux> saying "pure functions" to refer to non-monadic ones is what kmc objected to, and I understand it
07:28:52 <mux> yes.
07:29:21 <kmc> mux, time and time again i've seen that the critical point for beginners is to understand that evaluation and execution are distinct processes
07:29:26 <EvanR-work> but we dont encourage them to call the values true, null, "" in javascript functions
07:29:27 <kmc> the "impure function" model deliberately hides that
07:29:36 <mux> in the meantime, it didn't seem to me that such a choice of terms was likely to mislead mekeor`` and it conveyed the problem to him too, I believe
07:30:15 <mekeor``> huh?
07:30:21 <parcs> look what you have caused, mekeor``
07:30:26 <mekeor``> ^^
07:30:35 <mekeor``> oops
07:30:47 <mekeor``> i'm sorry, guys.
07:30:52 <kmc> i don't think we deserve accusations of pedantry and vague insinuations that we're out of touch "category theory scientists"
07:30:52 <mux> don't be
07:31:00 <hpc> how dare you come in here thinking you could learn something :P
07:31:04 <kmc> just for trying to teach the language in a way that's clear and correct
07:31:33 <kmc> i'll continue to advocate my approach to teaching, without resorting to name-calling
07:31:42 <EvanR-work> its mux's fault
07:31:43 * mekeor`` supports kmc
07:31:58 <mux> kmc: and I don't think I deserve accusations of silliness to have incorrectly used the term "pure function" either. so I guess we're even?
07:33:14 <EvanR-work> sqrt 2 isnt a pure function, getChar isnt a monadic function
07:33:15 <kmc> mux, i said your model was silly, not you
07:33:29 <mux> kmc: and I said the community had a tendency to get slightly pedantic, not you
07:33:34 <benmachine> sqrt is a pure function
07:33:47 * mekeor`` supports benmachine
07:33:48 <mux> but it was pretty clear what each of us meant, so let's just be done with it.
07:34:01 * mekeor`` supports mux
07:34:03 * quicksilver supports spurs
07:34:23 * benmachine supports bandwagons
07:34:30 <kmc> yeah this happens periodically
07:34:41 * frerich guesses that people who enjoy writing programs in non-mainstream languages really *do* have some opinion on language in general and hence are quick to point out imprecisions. :-}
07:35:08 <frerich> I mean, in C++, many people don't really care about programming languages in general or the distinction of members of methods or whatever in general :)
07:35:10 <quicksilver> people who've been here a long time have seen a *lot* of misunderstandings about how monads work.
07:35:16 <benmachine> heh
07:35:23 <mux> I don't even dare to talk about monads anymore, heh
07:35:23 <quicksilver> so they tend to form strong opinions about the best way to clear up those misunderstandings
07:35:38 <kmc> [pedantic]this isn't even about monads[/pedantic]
07:35:55 <mux> kmc: we know, I think everyone already moved on to new topics here...
07:35:58 <benmachine> kmc: it's SORT of about monads. inasmuch as we're making the point "monads are just as pure as all else"
07:36:08 <kmc> that's a stronger point than i was making
07:36:40 <kmc> programming languages are precisely specified mathematical constructs used to precisely specify instructions to an unforgiving machine
07:36:47 <Philippa> I don't see talking about "monadic functions" as being any worse than talking about n-ary functions in haskell, personally
07:36:48 <kmc> you can expect a good deal of pedantry surrounding them
07:37:04 <erus`> kmc is putStr pure?
07:37:07 <kmc> yep
07:37:13 <sipa> its evaluation is
07:37:16 <sipa> its execution isn't
07:37:20 <kmc> Philippa, the evaluation/execution distinction is important, and talking about "impure functions" hides that distinction
07:37:21 <erus`> because it takes a world state?
07:37:23 <kmc> that's the core of why it's bad
07:37:26 <benmachine> kmc: where do you stand on conal's "C is purely functional" thing
07:37:26 <EvanR-work> putStr cant be executed, its not IO ;)
07:37:34 <kmc> erus`, no, the world state business is just an analogy, and a bad one
07:37:55 <mekeor``> :t putStr
07:37:56 <lambdabot> String -> IO ()
07:38:04 <quicksilver> Philippa: the objection was on using 'pure function' in antonym to 'monadic function' as if the monadic ones weren't pure.
07:38:05 <kmc> erus`, putStr is pure because for any x, (putStr x) always evaluates to the same IO action, and has no side effect
07:38:18 <kmc> (where "the same" means "observably identical", since IO is after all an abstract type not supporting Eq)
07:38:33 <erus`> ok getStr
07:38:48 <kmc> getLine is a pure value
07:38:51 <kmc> it's not even a function
07:38:52 <kmc> it's an IO action
07:38:54 <Philippa> quicksilver: yeah, I know. Parsing it as a strict antonym and then correcting in full pedantry isn't necessarily the best response for someone's mindset though
07:38:55 <kmc> it's always the same IO action
07:39:07 <kmc> i really cannot recommend highly enough this article: http://www.haskell.org/haskellwiki/Introduction_to_IO
07:39:36 <quicksilver> Philippa: indeed.
07:39:55 <kmc> the key is to understand what an IO action is, and that execution differs from evaluation
07:39:56 <Philippa> to put it another way: read such things fuzzily and /refine/ rather than refute, then spell out the full mapping if you feel the need to go into that much detail
07:40:17 <erus`> so a program is just a sequence of IO actions
07:40:26 <kmc> it's a single IO action, named 'main'
07:40:41 <kmc> IO actions can be built by gluing together other IO actions, using the (>>=) operator
07:41:11 <Philippa> but >>= does indeed provide sequencing (monoidally, even), and rewarding that intuition is a good idea...
07:41:14 <tdammers> an IO action is not a
07:41:21 <EvanR-work> erus`: for one thread, its a non deterministic sequence ;)
07:41:21 <tdammers> 'function' in the Haskell sense
07:41:40 <tdammers> but it has a lot in common with a function in, say, Python or C.
07:41:40 * mekeor`` really would like to be able to define new data-types with conditions ;( e.g. he'd like to be able to write something like: newtype Degree = D a where 0<=a<=360  -- isn't that possible?
07:41:53 <kmc> tdammers, yeah
07:42:07 <kmc> but I think the Python or C concept of a function is more muddled than the Haskell or maths concept
07:42:07 <EvanR-work> mekeor``: nope
07:42:20 <kmc> in as much as the Python or C concept fills three unrelated roles, and somewhat awkwardly
07:42:21 <EvanR-work> also i would exclude 360 to avoid double representation
07:42:25 <Twey> I prefer to call Python/C functions ‘procedures’
07:42:27 <Philippa> tdammers: exactly, "execution" is the running of an embedded language that has the flavour of imperative functions
07:42:27 <mekeor``> @faq newtype Degree = D a where 0<=a<=360  -- isn't that possible?
07:42:28 <lambdabot> The answer is: Yes! Haskell can do that.
07:42:32 <Twey> (also IO actions)
07:42:51 <kmc> mekeor``, about the best you can do is define that in a module, don't export the constructor "D", and instead export some "smart constructor" functions which maintain the invariant
07:43:06 <EvanR-work> mekeor``: you can make an abstract data type with that property, but its not that simple
07:43:09 <tdammers> kmc: 'function' is actually a bit of a misnomer in those languages
07:43:18 <tdammers> 'routine' or 'procedure' would be more appropriate
07:43:19 <kmc> yeah, some languages say "procedure"
07:43:20 <mekeor``> kmc: i see.
07:43:23 <sipa> 'function' is usually used in the meaning of "definition"
07:43:26 <sipa> in those languages
07:43:46 <sipa> which is a property of a piece of code
07:43:47 <mekeor``> EvanR-work: pls explain that more precisely ;) (or give a link, pls)
07:43:47 <EvanR-work> subroutine
07:43:50 <tdammers> pascal and most SQL dialects make a distinction between functions and procedures...
07:44:04 <EvanR-work> mekeor``: basically kmc said
07:44:06 <tdammers> ...a function has a return value, but a procedure doesn't
07:44:07 <sipa> while in haskell it is the semantic property of a value
07:44:08 <mekeor``> ok
07:44:37 <quicksilver> tdammers: but they don't enforce the more important point of not having side effects, unfortunately.
07:44:48 <Twey> tdammers: That's not the real distinction, though — a function is a transformation of a value (i.e. pure), whereas a procedure is a list of instructions to execute
07:44:49 <EvanR-work> tdammers: procedures have return values
07:44:59 <quicksilver> well some SQL dialects partially enforce that.
07:45:01 <mekeor``> speaking to all haskell-developer: please implement that feature. thank you.
07:45:07 <Philippa> EvanR-work: that depends muchly on the language in question
07:45:32 <Twey> That list may include ‘return a value’
07:45:36 <EvanR-work> int getc(FILE *stream);
07:46:49 <erus`> is there a visual programming tool for haskell with flow diagrams and stuff?
07:47:02 <tdammers> Twey: it should be
07:47:05 <erus`> that would be cool
07:47:17 <Philippa> mekeor``: do it yourself with Template Haskell if it's really bothering you that much
07:47:30 <Philippa> there's not a good general solution to it, though
07:47:39 <tdammers> EvanR-work: not in pascal
07:47:53 <Philippa> (at least, not one that doesn't require turning Haskell into a language that's substantially something else)
07:47:57 <ClaudiusMaximus> erus`: see Alex McLean's "Text", perhaps
07:48:03 <EvanR-work> im not familiar with pascal
07:48:09 <EvanR-work> how does that work
07:48:22 <tdammers> a procedure is like a void function in C
07:48:35 <EvanR-work> is there any other difference
07:48:42 <tdammers> not really, no
07:48:46 <dmwit> mekeor``: But... why limit rotations to a mere 360 degrees?
07:48:49 <EvanR-work> seems like a silly distinction
07:48:52 <tdammers> pascal has no way of enforcing purity
07:48:56 <EvanR-work> a nonprocedure can have side effects?
07:49:00 <tdammers> yep
07:49:02 <EvanR-work> meh
07:49:03 <tdammers> just like in C
07:49:07 <dmwit> It's perfectly meaningful (and often done, for example in skateboarding) to talk about larger rotations than that. =)
07:49:09 <mekeor``> dmwit: it was rather a general question…
07:49:13 <Twey> C's are procedures
07:49:18 <tdammers> the distinction is necessary because pascal doesn't have void or ()
07:49:30 <Philippa> kmc: I think by the time you're playing with categories the notion of "function" generalises appropriately anyway
07:49:42 <dmwit> mekeor``: Anyway, can you articulate clearly what feature you would want Haskell to support that would make your life easier?
07:49:56 <Philippa> (it does open up the "do we have nullary functions by an extension of currying?" can of worms again, of course)
07:50:00 <dmwit> (You've already been told one way of achieving what you want; what makes that way unsatisfactory?)
07:50:08 <tdammers> my point is, someone decided to call them "functions" some time in the 1960s, and that's where the confusion started
07:50:18 <Philippa> tdammers: 50s
07:50:24 <Philippa> FORTRAN
07:50:29 <tdammers> ^ :D
07:50:31 <mekeor``> dmwit: conditioned data-types
07:50:43 <EvanR-work> its a function. it makes the computer perform some function ;)
07:50:46 <dmwit> mekeor``: Ah, so you want full dependent types?
07:50:53 <dmwit> mekeor``: You might be interested in Agda, then!
07:51:10 <tdammers> EvanR-work: by that logic, all code should be called 'function'.
07:51:13 <dmwit> (Or Coq, but that "feels" more like a theorem prover than a programming language to me every time I try to use it.)
07:51:15 <Philippa> dmwit: I'm pretty sure mekeor`` just wants smart constructors that fail
07:51:17 <tdammers> as should most hardware
07:51:28 <mekeor``> dmwit: i heared of it, but the haskell-community is much nicer =)
07:51:31 <dmwit> Philippa: That was suggested, and he seems unsatisfied. So... maybe not?
07:51:46 <EvanR-work> tdammers: lots of data sheets actually call the abilities functions
07:51:49 <Philippa> dmwit: a matter of syntax
07:52:04 <EvanR-work> i think the math people are to blame in the first place
07:52:18 <EvanR-work> why would you use the word function for what we now use it for?
07:52:27 <Athas> Is the Yi project still alive?
07:52:50 <tdammers> yeah, but the math people were first
07:53:00 <tdammers> beat the IT crowd by at least 3 centuries
07:53:13 <EvanR-work> stuff functioned before computers and math functions
07:53:36 <erus`> how did mathematicians test things?
07:53:43 <hpc> erus`: on paper
07:53:47 <EvanR-work> on clay
07:53:47 <tdammers> mathematicians don't test. they prove.
07:53:56 <Philippa> hpc: mathematics predates paper
07:53:58 <mekeor``> Athas: the git repository was updated on 18 september 2011
07:53:59 <int-e> they test proofs.
07:54:30 <mekeor``> Athas: https://github.com/yi-editor/yi
07:54:36 <tdammers> you can't really test a proof
07:55:12 <mekeor``> tdammers: you can. depending on the proof
07:55:16 <int-e> yes, you can. you follow each step and convince your self that it follows the rules of logical reasoning.
07:55:18 <Philippa> you can test its' (and its underlying axioms') soundness as a model of something specific
07:55:32 <Philippa> int-e: that's normally called checking rather than testing
07:55:42 <tdammers> verify/falsify, yes.
07:55:52 <tdammers> but not actually testing
07:55:58 <int-e> Philippa: the point I was trying to make is that it's typically not a deterministic process.
07:56:30 <tdammers> because a proof doesn't DO anything, it merely makes statements about something - along the lines of, "If A, then B follows"
07:57:13 <Philippa> mmm. Ultimately mathematics as practiced by humans is generally one or both of a modelling activity and a social activity
07:57:16 <EvanR-work> 'perfect induction'
07:58:12 <EvanR-work> maybe 'function' stuck because in french it means something totally else
07:59:25 <Athas> mekeor``: do you use it?
07:59:52 <tdammers> in other branches of science you can test a hypothesis by setting up an experiment and check if your results match the theory
08:00:04 <tdammers> but you can't perform mathematical experiments, really
08:00:10 <EvanR-work> yes you can
08:00:19 <tdammers> how?
08:00:25 <mekeor``> Athas: no. i use haskell-mode within GNU Emacs. it's very recommendable.
08:00:29 <sipa> finding a counterexample
08:00:31 <EvanR-work> look at research in chaotic dynamics
08:00:34 <luite> why not? programmable computers even make it much easier :)
08:02:02 <applicative> why would you call it mathematics? is it mathematics if I say three pebbles put two pebbles is five pebbles, having counted the five?
08:02:14 <applicative> three pebbles plust two pebbles
08:03:12 <applicative> if my method is empirical I don't have reason to expect the same result with oranges
08:03:38 <tdammers> mathematics is not about pebbles or oranges
08:03:44 <tdammers> it's about abstract concepts
08:03:59 <tdammers> if three plus two equals five, then that's that
08:04:26 <tdammers> whether you can apply this fact to oranges and pebbles is not something mathematics has anything to say about
08:04:30 <applicative> yes but how can there be experiment without something in the way of oranges or pebbles (I was agreeing with you of course)
08:04:34 <quicksilver> I don't know why you all find mathematics so hard to understand. Mathematics is like burritos.
08:04:48 <tdammers> applicative: kind of my point.
08:04:50 <applicative> its like a taco salad
08:04:57 <Philippa> quicksilver: get the mix wrong and the result involves lots of shit?
08:05:17 <luite> quicksilver: but you can't perform experiments with burrito's, really!
08:05:20 <EvanR-work> you can set up the mathematic system, and not be able to tell, on paper, wtf it means. but with computers we can drill in there and get some insight
08:05:23 <hpc> Philippa: good in theory, not in practice? :P
08:05:31 <EvanR-work> thats experimentation
08:05:52 * applicative was just watching a film of the great Kripke beating up on a crowd of computer scientists, so he's in a platonistic mood
08:05:52 <tdammers> it doesn't mean anything
08:06:16 <EvanR-work> its a hard to sell to tell an entire field of research that what they are doing isnt math
08:06:23 <Philippa> EvanR: right, you can effectively do science on a system that (depending on your philosophy) isn't part of the "real world"
08:06:32 <EvanR-work> at the same time as trying to convince computer scientists that what they are doing is math ;)
08:06:40 <tdammers> applied math
08:07:02 <tdammers> anyway, of course you can use computers to visualize mathematical concepts
08:07:14 <tdammers> and it can definitely help come up with insights
08:07:22 <EvanR-work> and it can prove theorems
08:08:12 <tdammers> you're automating the dull part of proving theorems, and you use computers to perform complex proof evaluations which would take way too long to do by hand
08:08:13 * applicative thinks the world could do with a bit more kripke http://www.vanleer.org.il/eng/videoShow.asp?id=317 e.g. on Churchs thesis
08:08:14 <tdammers> but you
08:08:24 <tdammers> 're not actually experimenting
08:09:06 <EvanR-work> tdammers: whether you prove or disprove by hand or by computer, seems fairly empirical to me
08:09:25 <Philippa> tdammers: you pretty much have to assume either a platonic realm of maths or a special exception for maths to make that claim
08:10:00 <tdammers> how are those experiments when you're not studying real-world objects?
08:10:25 <hpc> tdammers: same way a simulation would be?
08:10:35 <EvanR-work> conways life
08:10:55 <quicksilver> experimentation is a very natural part of mathematics
08:11:12 <quicksilver> the thing about maths is that after you've got some experimental data you may hope to actually *prove* your theory
08:11:14 <Philippa> tdammers: how is mathematics as performed by humans not embedded in the real world?
08:11:23 <donri> should you trust a paper that uses the word "determenistic"?
08:11:24 <Philippa> are you a cartesian dualist?
08:11:26 <quicksilver> where in more purely-empirical studies, you can't do that.
08:11:57 <tdammers> Philippa: Maybe :)
08:12:09 <tdammers> thing is, a number is just that, a number
08:12:37 <Philippa> then from here on out, remember that you have to prefix all your statements about what mathematics is with your philosophical leanings for them to actually be valid
08:12:50 <tdammers> ^ will do :)
08:14:55 <Philippa> it's perfectly possible to envisage the whole thing as just being embedded in the real world with the systems we study really being something akin to equivalences across various parts of the real world that in some sense model the same "thing". At which point you can't say /from within that system/ with certainty that anything that'll serve as an approximation of a platonic realm of maths
08:14:56 <Philippa> exists
08:15:35 <Philippa> ("an approximation of" - it so happens I read Anathem recently, which has the cute idea of a series of universes being other universes' "platonic realms" in some sense)
08:16:04 <tdammers> well, philosophically speaking, many ideas in mathematics stem from real-world necessities, so in a way, it's not all platonic
08:16:19 <tdammers> if it weren't for counting sheep, we'd never have invented numbers :)
08:16:32 <EvanR-work> god made numbers
08:16:33 <Philippa> I believe I already stated that maths-as-done-by-people is a mixture of a modelling process and a /social/ process, yes :-)
08:17:04 <Philippa> remembering the social part is important when you're doing applied maths for scientific purposes
08:17:18 <tdammers> hm, yah
08:17:40 <tdammers> I was talking more about core math, the part that basically ignores that a real world exists
08:18:06 <EvanR-work> which part doesnt ?
08:18:38 <EvanR-work> what distinguishes a model of the world from a purely 'fantastic' system
08:18:40 <Philippa> applied maths fundamentally does: you chose what for the sake of it being hopefully a good model, but after that you just crank it and see if you're getting results that look like the data you have for whatever you're modelling. But you might not know what a good one would look like...
08:19:02 <Philippa> EvanR: the 'fantastic' system only models the bits of the world that are attempts to embed itself? :-)
08:19:15 <EvanR-work> wuuuh
08:19:19 <erus`> is there a pure functional language that doesn't allow recursion (or just blocking) and is useful for anything?
08:19:39 <koala_man> excel
08:19:47 <sipa> blocking?
08:19:56 <saml> recursion?
08:20:02 <Philippa> erus`: there're quite a number that don't allow unguarded general recursion
08:20:05 <Philippa> saml: recursion
08:20:18 <EvanR-work> Philippa: you say any system unavoidably models something about the world? ;)
08:20:22 <applicative> excel has 'random numbers' doesn't it
08:20:29 <koala_man> does it?
08:20:43 <saml> excel is not language
08:20:46 <erus`> applicative: kmc says that random is just an IO action and thats pure :)
08:20:48 <Philippa> EvanR: any system /that we build something of in the world/ does :p
08:21:17 <EvanR-work> Philippa: sounds preposterous ;)
08:21:18 <tdammers> EvanR: kind of a philosophical question - can a human come up with something that isn't connected to the real world AT ALL?
08:21:20 <applicative> RAND and RANDBETWEEN are the 'functions'
08:21:31 <saml> tdammers, I N C E P T I O N
08:21:33 <benmachine> erus`: random :: IO Integer is (technically) pure, random :: Integer would not be
08:21:36 <EvanR-work> tdammers: well we can enumerate all models
08:21:51 <saml> if you use human language, you are bound to the world
08:21:56 <applicative> saml, why isn't excel a language? because of the graphical element?
08:21:56 <Philippa> EvanR: I've got this idea. Every time I feel like it, I'll make a mark on the wall. How can you check how often I've felt like it? :p
08:22:06 <benmachine> tdammers: seems to me that humans exist in the real world and so anything we come up with becomes connected to the real world by virtue of us coming up with it
08:22:15 <saml> applicative, excel  is a program, afaik
08:22:20 <EvanR-work> Philippa: count the marks
08:22:34 <tdammers> the crux is finding a meaningful definition of 'connected'
08:22:35 <koala_man> excel is an IDE for an anonymous language
08:22:41 <Y_Less> If you had a functional language then surely, as functions are first class objects, you could just pass a function itself to get recursion, so you can't not have recursion? f x a = x x 1; f f 4
08:22:48 <saml> excel is a part of MS Office Suite
08:22:57 <tdammers> see, natural numbers behave like countable real-world objects
08:23:04 <benmachine> Y_Less: you can make your language reject that
08:23:13 <benmachine> Y_Less: indeed, that would be rejected by haskell
08:23:16 <tdammers> 2 + 3 = 5, 2 pebbles plus 3 pebbles is 5 pebbles
08:23:20 <benmachine> because it wouldn't type check
08:23:21 <Philippa> Y_Less: actually no. The lambda calculus requires more trickery than that, and you can construct type systems that prevent said trickery
08:23:29 <saml> what's real world?
08:23:37 <hpc> the /typed/ lambda calculus, at least
08:23:46 <Philippa> benmachine: yeah, see also my earlier "are you a cartesian dualist?" question
08:23:50 <applicative> saml, xls files are read by a lot of applications, not just excel. I wish .hs files were read by so many
08:23:55 <tdammers> but you could probably come up with a mathematical system that does not model any real-world entities in an obvious way
08:24:00 <benmachine> Philippa: if it helps, I'm not
08:24:07 <saml> gvim reads .hs file well
08:24:09 <benmachine> (if it doesn't help then I am)
08:24:18 <tdammers> maybe you
08:24:20 <tdammers> 're both?
08:24:35 <Philippa> tdammers: yeah, but the moment you "explore" the system's behaviour, you're embedding bits of it in the real world somehow
08:24:40 <applicative> saml, i didn't mean render, i meant interpret, but maybe interpreting isnt what you do with them
08:24:40 <Philippa> hence being able to experiment with it
08:24:59 * benmachine uses this to prove false, and then derives an arbitrary proposition A, then instantiates A to "lunch"
08:25:10 <saml> what r u talking about dawg
08:25:13 <Philippa> (whether it's mere gedanken or you're moving actual oranges about)
08:25:26 <Athas> Is anyone here a developer on the x11 package?
08:25:35 <Philippa> benmachine: I'm not either, though I do talk about my mind as a subsystem of myself
08:25:54 <erus`> friday afternoon... everyones talking about abstract maths on #haskell instead of doing work
08:25:54 <Philippa> (occasionally I have to point out to other people that this isn't an inherently bullshitty construction for a materialist...)
08:25:58 <applicative> saml: excel (the program) interprets xls files, it knows what they mean if you like
08:25:58 <Y_Less> Ahh true
08:26:03 <benmachine> Philippa: I talk about my stomach as a subsystem of myself, too?
08:26:22 <benmachine> possibly I've misunderstood your use of the term subsystem
08:26:29 <saml> Excel is a program
08:26:33 <Philippa> benmachine: quite, although we have a better idea of how that one manifests concretely - contrast mind with brain
08:26:34 <saml> do not confuse
08:26:50 <tdammers> that's the thing - is the human mind capable of inventing things out of thin air, or are we ultimately bound by laws of the real world?
08:26:55 <Philippa> (I also deliberately further deconstruct 'mind' for reasons -blah regulars will be plenty familiar with)
08:26:58 <benmachine> Philippa: ah, true.
08:27:40 <applicative> saml i don't see that you have any real objection to the standard thought that excel users are operating with a (restricted) functional programming language
08:27:54 <Philippa> tdammers: any notion of free will that's not compatible with being embedded in a deterministic universe is useless
08:28:07 <saml> "the standard thought" WTF
08:28:20 <saml> stop making errors by assumption and generalizations
08:28:21 <benmachine> I've never understood any notion of free will that was anything other than useless >_>
08:29:05 <applicative> saml, one can object, of course, I don't know what to make of the claim myself, but I don't see that you have framed an objection
08:29:07 <benmachine> saml: it's definitely an idea I've heard before; I don't know enough about excel to comment on if it's truly functional
08:29:16 <Philippa> benmachine: they can be useful for the purpose of demonstrating that they don't apply, but for purposes of eg justice discussions I'm inclined to frame it in terms of agency and reasoning power
08:29:41 <Philippa> obviously that requires being able to define a specific agent adequately in order to black-box the rest of the universe from it
08:29:53 <applicative> saml, hah, check this out http://research.microsoft.com/en-us/um/people/simonpj/papers/excel/
08:29:53 <tdammers> let me rephrase it then...
08:29:55 <benmachine> Philippa: well isn't that rather a different kettle of fish? but really I meant to put the emphasis on the other bit, where I've never understood the things
08:30:15 <applicative> not that an appeal to authority decides anything
08:30:18 <saml> Excel is programmable, yes.
08:30:31 <tdammers> Can a formal system, implemented inside the constraints of the real world, describe concepts that are not compatible with that real world?
08:30:39 <saml> tdammers, no
08:30:44 <tdammers> saml: why not?
08:30:50 <Philippa> benmachine: yeah, the other notions that've been put forward've mostly been philosophers trying to construct something else first, invoking "free will" as a magic missing component and then trying to figure out whether an implementation makes any sense at all
08:30:58 <saml> what do you mean by "compatible with that real world" ?
08:31:02 <Philippa> tdammers: in what sense "not compatible with that real world"?
08:31:05 <saml> what does compatible mean?
08:31:07 <saml> can it exist?
08:31:26 <tdammers> let's say, contradicting something that is provably true in the real world
08:31:34 <saml> this real world allows computers to exist
08:31:47 <saml> silicons and stuff. electronics
08:31:54 <tdammers> exactly
08:32:00 <saml> this real world allows. so it's compatible, i guess
08:32:10 <applicative> philosophers are the last people likely to believe in 'free will
08:32:12 <Philippa> tdammers: "describing" isn't a causal relationship, so yes
08:32:13 <benmachine> can't you just make a formal system which contains the axiom "False" and therefore contradicts everything including itself?
08:32:23 <saml> and logic is allowed to exist, too
08:32:25 <Philippa> applicative: these days, yes
08:32:29 <saml> evolution and stuff
08:32:33 <benmachine> I should stop commenting on topics I know so little about
08:32:44 <dolio> rwbarton: Yo.
08:32:56 <Philippa> benmachine: yep, there're some very simple "obviously bullshit" formal systems
08:32:59 <Philippa> the thing is, they're /formal/
08:33:09 <tdammers> Philippa: so is mathematics
08:33:17 <saml> everything exists exist.
08:33:18 <Philippa> any descriptive power is... well, an accident
08:33:21 <applicative> the way the word is used now, "do you believe in free will", no philosopher in the canon ever believed in anything like it.
08:33:41 <Philippa> that's not the same thing as the effect that embedding that formal system in the real world
08:33:43 <saml> i can't comment on something that (seemingly) does not exist
08:34:07 <Philippa> the effect of embedding a formal system? Well, the heat coming off my laptop's a good example
08:34:17 <monochrom> I can make a formal system that has only one axiom and no inference rule. the axiom is the Unicode string "there is no real world". is that compatible with the real world?
08:34:40 <jystic> does anyone know a good way to make cabal test-suites for code which is in an executable? (as opposed to a library)
08:34:46 <monochrom> or does the real world care about what a Unicode string says?
08:34:54 <Philippa> the fact I can (layeredly) encode descriptions of infinities I'm /damn/ certain I can't "construct" in any meaningful sense doesn't break anything
08:34:58 <dcoutts> jystic: that's the easiest kind
08:35:08 <jystic> dcoutts: oh yeah?
08:35:16 <roconnor_> If we loosely translate "compatible with the real world" to mean "sound", then there are lots of unsound formal system.
08:35:17 <dcoutts> jystic: indeed it's the only kind that's supported in released versions of cabal
08:35:27 <dcoutts> jystic: just use the type exitcode-stdio-1.0
08:35:28 <applicative> monochrom it's a little hard to see it as an axiom if I can't make an inference from it. e.g. 'if there is a real world, then there is no real world' ought to follow....
08:35:32 <Philippa> tdammers: basically, you seem to be confused by the difference between "A is embedded in B" and "A makes statements about B"
08:36:00 <jystic> dcoutts: oh, i meant that i have an executable my-app, which has some modules i want to test
08:36:01 <Philippa> applicative: and of course being a formal system "real world" is just syntax
08:36:18 <jystic> dcoutts: so i have in the same cabal file, test-suite my-tests
08:36:24 <dylukes> Does anyone know the nicest way to write a sepBy2 combinator?
08:36:26 <Philippa> the *only* semantics a formal system has is how it behaves. The rest is a question of whether something else behaves like it too
08:36:34 <dcoutts> jystic: ah I see, well just make a new test main that imports those same tests and runs them
08:36:35 <dylukes> I want to ensure there are at least two of something, not just one like with sepBy1.
08:37:20 <jystic> dcoutts: the problem seems to be that i can't reference my-app in the build-depends
08:38:03 <jystic> dcoutts: although i guess i can just say that hs-source-dirs for the test-suite also includes my 'src' for the app, but then i need to duplicate my build-depends
08:38:10 <sanyi> hi, how would I go about doing stuff with elements of a list and then return the last element?
08:38:17 <dcoutts> jystic: right, you're not depending on it (it's not a lib), just make a Main module that imports the modules that export tests.
08:38:25 <sanyi> i mean: how could I detect that it's the last one?
08:39:09 <ClaudiusMaximus> :t foldM
08:39:09 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:39:19 <sanyi> can I pattern match on x:[] ?
08:39:37 <jystic> dcoutts: are you saying that i should mix my quickcheck properties in with my module code? or i am i misunderstanding?
08:39:45 <ClaudiusMaximus> yep, or [x], which is the same thing
08:40:14 <sanyi> ClaudiusMaximus: thanks, is there another way too?
08:40:15 <dcoutts> jystic: oh, I thought that's the situation you had. If you test modules are separate that's even easier. Just import those in your test Main module.
08:40:41 <tdammers> Philippa: not confused, no
08:40:44 <hpaste_> mekeor`` pasted “monadic problem… -- why doesn't that work?” at http://hpaste.org/52286
08:41:01 <mekeor``> ^ my paste. pls help me. i'm a monad-noob.
08:41:12 <tdammers> it's perfectly easy to come up with nonsense systems that are not embeddable into the real world
08:41:15 <jystic> dcoutts: ok, so the problem is that the functions which my tests are testing are a part of the application source code and so i can't import them, if they were part of a library i would be able to import them.
08:41:25 <tdammers> start with 1 + 1 = 1 as an axiom, and you're already there
08:41:35 <tdammers> but those are generally not interesting
08:42:02 <mekeor``> tdammers: then 1=0
08:42:08 <tdammers> ^ exactly.
08:42:17 <tdammers> not interesting for longer than 5 minutes.
08:42:30 <tdammers> everything is true and false.
08:42:43 <parcs> dylukes: sepBy2 p sep = (:) <$> p ((:) <$> p <*> many (sep *> p))
08:42:51 <dylukes> heh
08:42:53 <applicative> dylukes: is something like this wrong" sep2 sep parser = liftM2 (:) (parser <* sep) (sepBy1 sep parser)
08:42:53 <dylukes> I just wrote
08:42:53 <dylukes> sepBy2 p sep = (:) <$> (p <* sep) <*> sepBy1 p sep
08:42:54 <mekeor``> anyway. guys, PLEASE help me with my problems concerning monads :(
08:42:54 <dylukes> :)
08:43:03 <osfameron> mekeor``: the type error says "cannot construct the infinite type"  Does that help?
08:43:03 <dcoutts> jystic: no, you can import them. They are just modules. The fact that your main exe imports them too is not important.
08:43:04 <applicative> hah, parcs
08:43:04 <ClaudiusMaximus> sanyi: it depends on what "doing stuff with" means - maybe a map or a fold would work
08:43:06 <dylukes> applicative style is getting more natural, happily.
08:43:07 <monochrom> you know what, you are using far more than one axiom 1 + 1 = 1.
08:43:17 <osfameron> mekeor``: it looks like you're trying to return (f s) as the result of f s.
08:43:20 <tdammers> yes, I know
08:43:24 <dylukes> mekeor``: Monads? or one specific monad :P.
08:43:40 <mekeor``> osfameron: well, it's just an example
08:43:41 <dcoutts> jystic: if the tests are exported by any module anywhere in the source code then you can import them
08:43:55 <mekeor``> osfameron: the error i get is: Couldn't match expected type `[Char]' with actual type `IO String'
08:43:56 <dylukes> applicative: no but its not applicative style which makes it not as cool :
08:43:58 <monochrom> you basically need half of Peano axioms and combine with 1 + 1 = 1
08:44:29 <monochrom> and in fact you need those Peano axioms written exactly symbol for symbol as the convention notation
08:44:32 <applicative> oh mine has the <* flipped
08:44:34 <jystic> dcoutts: ok, so do test-suites inherit build-depends somehow to make this happen, or do i need to duplicate my build-depends? (so that my executable and my test-suite have basically the same dependencies listed)
08:44:36 <osfameron> mekeor``: oh, I'm running in ghci, so perhaps I'm getting a different error, 1 sec
08:44:44 <mekeor``> ok
08:44:51 <tdammers> what I'm wondering is, would it be possible to come up with a formal system that is equally expressive and consistent as traditional math, yet not fitting any real-world entities
08:45:08 <tdammers> I don't really see a theoretical reason
08:45:21 <monochrom> for if I rewrite the Peano axioms so as to swap the symbols "+" and "*", then adding 1 + 1 = 1 is just fine
08:45:21 <Philippa> tdammers: what does "equally expressive" mean?
08:45:29 <tdammers> ah yeah
08:45:32 <tdammers> touché
08:45:45 <tdammers> maybe I should say equally complex
08:45:48 <tdammers> or something like that
08:46:07 <osfameron> mekeor``: ok, if you remove the type signature, and try again, you get the error about infinite types
08:46:14 <tdammers> powerful enough to be subject to Gödel's theorem might be a good measurement
08:46:18 <dcoutts> jystic: right, you'd repeat whatever build depends are needed
08:46:22 <monochrom> this is why I ask if my formal system contains the theorem a Unicode string "there is not real world", is it incompatible with the real world?
08:46:43 <osfameron> mekeor``: (f s) would return an IO string.  but f *takes* a String
08:46:47 <monochrom> to start with, you don't even know what the letter "t" at the beginning does.
08:46:56 <osfameron> mekeor``: what do you want the function to do?
08:47:28 <jystic> dcoutts: ok, that's cool, as long as i'm not missing something :) that's one nice thing about having test-suites for a library, you can just have the library itself in the build-depends so you don't have to list the dependencies twice
08:47:37 <mekeor``> osfameron: thank you so far. i'll try to solve it myself for some seconds… w8…
08:47:49 <monochrom> until you bring in the whole English lexicon and grammar, my axiom doesn't cause any contradiction. yet the whole English lexicon and grammar is not part of my formal system. I ensure it by construction.
08:47:53 <jystic> dcoutts: of course you can't test internal functions then
08:48:34 <dcoutts> jystic: right, you get to choose if your test suite goes via the lib interface, or directly to the internal modules.
08:48:40 <mekeor``> osfameron: okay. i got it working… one sec
08:48:48 <monochrom> indeed, why English? what's so distinguished about English that all "meaningful" identifiers must be understood under the framework of English?
08:49:08 <hpaste_> mekeor`` pasted “solved monadic problem” at http://hpaste.org/52288
08:49:44 <mekeor``> osfameron: ^
08:49:49 <jystic> dcoutts: so i was considering making a myapp-lib which has everything in it and that is used by the executable and the test-suite, but i think duplicating the build-depends might be a lesser evil
08:50:25 <mekeor``> osfameron: oh, and the suggestion, which you can see on hpaste, is also very helpful. thanks, osfameron
08:50:45 <dcoutts> jystic: note that this way you don't have to have your main exe depend on quickcheck etc
08:51:20 <jystic> dcoutts: yeah, that's nice
08:52:10 <monochrom> eh? that's a nice infinite loop there
08:53:04 <jystic> dcoutts: in some ways it would be nice to have quickcheck properties side by side with the functions they test, but i don't know how you could strip them out cleanly
08:53:32 <monochrom> #ifdef :)
08:53:45 <jystic> cleanly :)
08:54:30 <jystic> i suppose you can put them all at the bottom, but then you might as well have them in a separate file
08:54:47 <danols_work> does 0 == false in haskell ?
08:54:59 <donri> danols_work: nope
08:55:17 <jystic> you could get away without exporting them fairly cleanly with an #ifdef, but you can't really get away with not linking quickcheck unless you also ifdef all the properties
08:55:35 <donri> danols_work: that doesn't even type match
08:56:01 <c_wraith> > 0 == False  -- danols_work
08:56:02 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
08:56:02 <lambdabot>    arising from the literal `0'...
08:56:19 <donri> danols_work: however, for fun see http://learnyouahaskell.com/making-our-own-types-and-typeclasses#a-yes-no-typeclass
08:56:52 <KirinDave> Man, the illustrations in lyah never cease to amaze
08:56:56 <mekeor``> > otherwise == True
08:56:57 <lambdabot>   True
08:56:58 <KirinDave> Sometimes I get the pop cultural reference
08:57:15 <KirinDave> Sometimes it gets pretty damn obscure.
08:58:47 <danols_work> > 0 == False
08:58:48 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
08:58:49 <lambdabot>    arising from the literal `0'...
09:00:25 <danols_work> any python converts here ? or more so any django converts ?
09:00:36 * Twey raises a hand
09:00:38 <Twey> … technically
09:00:42 <danols_work> I have taste of Haskell way back and loved it
09:01:39 <danols_work> let me ask another question --- anyone here uses haskell as a webframework as a main source of income ?
09:01:56 * parcs tumbleweed
09:02:14 <ohwow> Is book.realworldhaskell.org still being maintained?
09:02:29 * jystic thinks bos uses snap at his startup?
09:03:00 <danols_work> hmm
09:03:17 * danols_work man python's gotchas and crap is making me want to cry
09:03:18 <alpounet> ohwow, what do you mean by "maintained" ?
09:04:03 <danols_work> do any of you have had a gotcha moment in haskell ?
09:04:27 <Twey> Off the language itself?  Don't think so…
09:04:32 <Twey> Oh, maybe the negation stuff
09:04:33 <danols_work> off langauge itself
09:04:38 <jystic> danols_work: misunderstanding lazy evaluation, leading to a space leak, but that doesn't happen to me anymore
09:04:40 <Twey> That's a bit weird
09:04:42 <danols_work> those are the worst and leave a bad taste in my moind
09:04:48 <frigga> danols_work: Yeah, after awhile programming haskell I had the gotcha of not wanting to program in any other language.
09:04:53 <Twey> Heh.
09:05:13 <jystic> frigga: yep :)
09:05:30 <benmachine> 'forever putStrLn "hello"' I think was a bit of a gotcha for me
09:05:49 <osfameron> mekeor``: cool, I still don't see what you're trying to *do* there though ;-)
09:05:58 <ohwow> alpounet: corrections are still being made?
09:06:39 <Ice-cold> yo sup
09:06:54 <ohwow> hello
09:07:26 * hackagebot xtest 0.1 - Thin FFI bindings to X11 XTest library  http://hackage.haskell.org/package/xtest-0.1 (IlyaPortnov)
09:07:48 <donri> one gotcha for me was realizing the difference between types and typeclasses, specifically the need for typeclass constraints
09:08:30 <donri> and that haskell doesn't (yet) do "type-directed name resolution"
09:08:52 <tac-tics> donri: what's type-directed name resolution?
09:08:53 <alpounet> ohwow, ask one of the authors, or leave a comment maybe, but i don't see why they wouldn't make them, it should not take much time
09:09:14 <donri> (i expected all functions to be polymorphic by default)
09:09:25 <benmachine> @google type directed name resolution
09:09:27 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
09:09:27 <lambdabot> Title: TypeDirectedNameResolution – Haskell Prime
09:09:50 <parcs> donri: yeah it does
09:09:51 <donri> tac-tics: auto-qualification by type of value
09:09:52 <jystic> dcoutts: what is the advantage of the detailed test-suite type?
09:09:55 <parcs> see type classes
09:10:00 <tac-tics> donri: ah, yeah
09:10:08 <donri> parcs: but not for functions not defined in a class
09:10:39 <donri> (which is probably part of why type classes confused me - they didn't really seem to add anything)
09:11:55 <parcs> on an unrelated note, when should a module export another module?
09:12:00 <donri> e.g. map vs fmap, i thought i could just add a pattern matching definition for map for other types; map f (Just x) = Just (f x)
09:12:26 * hackagebot cereal-enumerator 0.2 - Deserialize things with cereal and enumerator  http://hackage.haskell.org/package/cereal-enumerator-0.2 (PatrickPalka)
09:12:54 <dolio> Type classes add type directed name resolution that isn't a complete mess.
09:12:58 <dolio> Like every other language.
09:13:24 <donri> I'm not sure about TDNR, but i think it's an interesting idea that might be worth an extension for trying it out
09:13:52 <dylukes> hey guys
09:13:56 <donri> solves issues with records and unqualified imports
09:13:59 <dylukes> I have a friend who's learning FORTRAN.
09:14:01 <dolio> I'm sure I don't want it.
09:14:05 <dylukes> What would you guys recommend for a tutorial?
09:14:11 <donri> @where LYAH
09:14:11 <lambdabot> http://www.learnyouahaskell.com/
09:14:30 <donri> oh, fortran? no idea, wrong channel? :)
09:14:42 <rwbarton> @where LYAF
09:14:42 <lambdabot> I know nothing about lyaf.
09:15:08 <jystic> @where FORTRAN
09:15:08 <lambdabot> I know nothing about fortran.
09:15:48 <tdammers> ^ good boy
09:16:20 <dolio> lambdabot is female.
09:16:33 <dylukes> dolio: only in your sick and twisted mind
09:16:34 <tdammers> I assumed asexual...
09:16:54 <tdammers> kind of a spiritual being, one with the zen of lambda calculus
09:17:07 <donri> silly heteronormative sexist geeks must always prescribe female gender to bots
09:17:09 <roconnor_> the product of two monad transfomers is a monad transformer, yes?
09:17:31 <quicksilver> roconnor: if they are genuinely monad transformers then yes, by definition.
09:17:45 <quicksilver> however some popular monad transformers don't always work.
09:17:49 <roconnor> mt1 ::*:: mt2 m = mt1 m :*: mt2 m
09:18:13 <roconnor> quicksilver: other than the ListT non-monad transformer, which monad tranformers are not?
09:18:20 <tdammers> robots are machine
09:18:25 <tdammers> +s
09:18:42 <tdammers> according to English grammar, machines are grammatically female
09:19:01 <tdammers> well, vehicles at least...
09:20:19 <quicksilver> roconnor: I don't know.
09:20:58 <dylukes> tdammers: english grammar doesnt have gender though :\
09:21:32 <tdammers> say what?
09:21:37 <tdammers> she == female
09:21:39 <tdammers> he == male
09:21:43 <tdammers> it == neutral
09:22:07 <tdammers> articles and nouns do not reflect gender, but pronouns do
09:22:14 <dylukes> But we only use she and he for people :P.
09:22:21 <dylukes> Our nouns don't have intrinsic genders.
09:22:25 <dylukes> Like, say spanish.
09:22:45 <tdammers> they don't /reflect/ genders, but they do /have/ them.
09:22:50 <tdammers> Ships are female.
09:22:52 <dylukes> We only use he and she for people, sometimes animals... and endearingly to personify things sometimes.
09:22:57 <dylukes> No, they're not haha.
09:22:59 <tdammers> A ship is not 'it', a ship is 'she'.
09:23:03 <engla> english must have had genders before
09:23:06 <tdammers> grammatically, they are.
09:23:06 <dylukes> No, a shop is "it" :P.
09:23:09 <dylukes> No, its not haha.
09:23:12 <donri> needs moar lojban
09:23:18 <dylukes> People just say "she" for fun. It's not part of the language.
09:23:22 <dylukes> Objects are all "it".
09:23:27 <dylukes> Without exception.
09:23:33 <tdammers> you are wrong.
09:23:50 <dylukes> Using "he" or "she" for cars ,vehicles, etc, is just endearing personification.
09:24:10 <EvanR-work> hurricanes are equal opportunity anthropnymic entities
09:24:25 <EvanR-work> (but used to be female only)
09:24:31 <EvanR-work> male power
09:24:41 <tdammers> https://en.wikipedia.org/wiki/Gender_in_English
09:24:55 <dylukes> "Gender is no longer an inflectional category in Modern English."
09:25:07 <dylukes> "continents, nations, many cities, ships, airplanes, cars, and some organizations are sometimes referred to as she "
09:25:12 <tdammers> ^ that part.
09:25:20 <dylukes> Yeah, that doesn't mean its grammatically correct haha.
09:25:24 <dylukes> English has no gender inflection.
09:25:29 <dylukes> It's just a cultural artifact.
09:25:49 <donri> tldr large things are female, because your mom is fat
09:25:54 <dylukes> In other languages (notably greek-derived languages), words have implicit gender and you inflect as such.
09:26:20 <tdammers> English words also have implicit gender, it just doesn't show unless you refer to them through a pronoun
09:26:43 <tdammers> other languages inflect adjectives, articles, and the noun itslef
09:27:03 <tdammers> but just because it's hidden most of the time, doesn't mean it's not there
09:27:17 <dylukes> tdammers: No, haha, you're wrong :P.
09:27:22 <dylukes> English simply does not have implicit gender.
09:27:25 <dylukes> People have gender.
09:27:27 <dylukes> Words do not.
09:27:29 <rwbarton> hidden most of the time and also can be described fairly accurately as 'const "it"'
09:27:31 <dolio> Do you have something Haskell-related to talk about?
09:27:37 <dylukes> yeah, can we move to -blah
09:27:48 <dylukes> Join #haskell-blah tdammers
09:28:05 <dolio> rwbarton: By the way, were you planning to talk at the next Boston Haskell?
09:30:39 <rwbarton> Possibly, though I'm not actually sure how well what I was planning to talk about at the last one fits into the scope of Boston Haskell
09:31:10 <ddarius> Were you planning on giving a talk about Patterns in Java?
09:31:37 <dolio> rwbarton: You should get back to Ed, then.
09:32:13 <rwbarton> I also haven't been to one of these before, so maybe I'll just see what one is like before giving a talk.
09:32:30 <ddarius> rwbarton: That's the wusses way of doing things.
09:34:15 <rwbarton> Oh hey, there are videos on youtube of some of these.
09:35:32 <dolio> I don't think the topic is a problem.
09:35:45 <ddarius> What is the topic?
09:35:45 <dolio> You're not any more out there than categorical databases.
09:35:55 <ddarius> That was a good talk.
09:36:08 <ddarius> Much better than Spivak's first version at Galois, in my opinion.
09:36:45 <rwbarton> ddarius: Using category theory to model merging in version control systems
09:37:14 <rwbarton> Yeah, I was about to watch that talk but I think mine would be of a pretty similar nature.
09:37:17 <roconnor> rwbarton: where?
09:37:23 <ddarius> rwbarton: I doubt it.
09:37:37 <rwbarton> Well, let me watch the talk and get back to you on that :)
09:38:06 <edwardk> rwbarton: your talk would fit very well within the purview if boston haskell
09:38:07 <rwbarton> roconnor: Boston Haskell potentially, and/or I might just write up some notes and put them online somewhere
09:38:23 <edwardk> the purview is basically 'stuff i find interesting' and occasionally stuff to draw in new people ;)
09:38:31 <edwardk> i find categorical stuff very interesting ;)
09:38:33 <rwbarton> where i = edwardk
09:38:36 <rwbarton> all right then
09:38:41 <ddarius> rwbarton: Your talk will probably be more coherent and useful than my talk on fibrations.
09:38:59 <roconnor> fibrations for version control?
09:39:20 <edwardk> if you would rather wait a session, then dolio and i can talk this next time, and I could book you for november
09:39:38 <ddarius> What do dolio and you have in mind to talk about?
09:40:12 <edwardk> i'll talk about trifecta and parsing stuff, more introductory level, and then dan is going to cover an intro to homotopy and directed type theory
09:40:36 <ddarius> dolio: Did you actually read that DTT thesis then?
09:40:44 <edwardk> he just stepped away, but yes
09:40:58 <alpounet> parcs, hey, cereal-enumerator looks nice! (you're the author right ?)
09:41:05 <edwardk> he's been all fanboy about it here at the office
09:41:06 <edwardk> ;)
09:41:32 <edwardk> in as much as he gets excited about anything. he deadpans almost as well as you =P
09:41:34 <ddarius> I've been meaning to read that thesis, and I think I would be interested I just keep forgetting and/or not having time.
09:41:42 <parcs> alpounet: yep :)
09:42:06 <ddarius> edwardk: Don't worry.  I'm imagining dolio in my head as giddy as a school girl.
09:43:24 <ion> pe185954 < c_wraith> > 0 == False  -- danols_work
09:43:29 <shirt> @help
09:43:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:43:39 <ion> λ> 0 == False
09:43:39 <ion> True
09:43:51 <danols_work> ion: ?
09:43:56 <ddarius> Just need an instance of Num for Bool.
09:43:58 <c_wraith> ion has added an instance
09:44:15 <danols_work> sorry I wasn't paying attention --- yes?
09:44:27 <ion> I made a Num instance where a mod-2 algebra is implemented with False and True. :-P
09:44:42 <danols_work> I understand so you explicitly 'casted' it ?
09:45:20 <danols_work> that's why I wish I could get paid to use haskell :P
09:45:48 <ion> All integer literals mean “fromInteger x” where x is the Integer value corresponding to the literal such as 42.
09:46:15 <roconnor> > signum True
09:46:16 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
09:46:16 <lambdabot>    arising from a use of `GHC.N...
09:46:38 <ion> > (1000 :: Rational, 1000 :: Word8, 1000 :: Integer)
09:46:39 <lambdabot>   (1000 % 1,232,1000)
09:47:01 <ion> Each one of those types implements a Num instance, and therefore implements fromInteger.
09:47:29 <dolio> ddarius: I haven't read the thesis. I've read some of Harper and Licata's recent paper on it.
09:47:41 <ddarius> dolio: Name of the paper?
09:48:26 <dolio> Foundations and Applications of Higher-Dimensional Directed Type Theory
09:48:38 <ddarius> Thanks.  I don't think I've seen that one before.
09:56:58 <ddarius> edwardk: Any planned date for the next Boston Haskell by the way?
09:58:02 <saml> tomorrow
09:58:09 <saml> i have to work tomorrow. and monday, too
09:58:56 <edwardk> as soon as nirav gets me the room there will be, but it looks like the 24th
09:59:07 <dolio> We're going to need you to go ahead and come in on Sunday, too.
09:59:16 <edwardk> and clarifi should be supplying pizza again
10:07:13 <desaiu> I'm looking for some videos to watch while I eat
10:07:22 <desaiu> Recommendations?
10:07:33 <Luke> Not in scope: data constructor `Int' -- This is GHCi... any idea why I can't use in't in (Int, Int) ?
10:07:51 <ion> Int is a type, not a function.
10:08:26 <ion> They’re in entirely separate namespaces.
10:09:01 <ion> s/function/value/ actually
10:12:32 <tsousa> Map from Data.Map is a function right? and it is also a type contructor?
10:12:40 <tsousa> i am not getting that
10:13:35 <benmachine> it's not a function
10:13:40 <benmachine> just a type constructor
10:15:17 <EvanR-work> i have a probability question. you are reading a choose your own adventure book. the page says X. at the bottom it says, if you choose Y turn to page A. if you choose Z turn to page B. exactly one of A and B will result in your death, the other doesnt
10:15:25 <ion> data Foo a = Bar a: Foo is a type constructor (a type level function which returns a type when applied to a type). Bar is both a value, a function and a data constructor. It can be used in pattern matching.
10:15:36 <EvanR-work> is the probability of dying 50%?
10:16:19 <ion> Foo exists in the namespace of types, Bar exists in the namespace of values.
10:16:41 <roconnor> EvanR-work: According to Basyians yes
10:16:46 <benmachine> EvanR-work: do you choose randomly?
10:17:01 <alpounet> EvanR, without any prior knowledge, etc, if you choose uniformly, yes
10:17:06 <EvanR-work> you choose based on X Y and Z
10:17:07 <benmachine> also, the probability of dying is always 100% eventually :P
10:17:24 <ion> tsousa: ↑
10:17:47 <roconnor> EvanR-work: is Y = X or Z = X?
10:17:49 <EvanR-work> benmachine: heat death of universe?
10:18:08 <roconnor> EvanR-work: is Y = Z?
10:18:08 <benmachine> EvanR-work: I imagine before then, but sure
10:18:14 <EvanR-work> roconnor: no X is your given information, Y and Z are courses of action
10:18:26 <roconnor> EvanR-work: I thought X Y and Z were page numbers
10:18:32 <EvanR-work> A and B are page numbers
10:18:42 <roconnor> ah oops
10:19:01 <benmachine> EvanR-work: I don't see that this is necessarily a probability question
10:19:02 <tsousa> ion, so how can i know if it is a function or a type constructor? and how it is not a function if we can use it?
10:19:05 <aristid> this code to generate permutations is probably quite inefficient, isn't it? https://gist.github.com/1270845
10:19:13 <alpounet> EvanR-work, then it depends on how X influences things
10:19:19 <benmachine> your choice process is presumably deterministic (ish) and will have some degree of accuracy
10:19:25 <alpounet> (and your probability law)
10:19:29 <roconnor> EvanR-work: right, unless you use your prior information to distinguish Y and Z given X, then the probability is 50%
10:19:30 <aristid> i wonder if it would be hard to generate the permutation forest more efficiently
10:19:51 <benmachine> EvanR-work: why are you asking this question, anyway?
10:19:51 <roconnor> EvanR-work: but if you have prior information about X Y and Z, then that can affect your probability
10:20:38 <EvanR-work> if you have ever read these books, you may think differently about either the information on the page will help you avoid death
10:20:43 <EvanR-work> about whether*
10:21:13 <benmachine> EvanR-work: in some cases it will, in some cases it won't. everyone knows what you do is look at both A and B anyway :P
10:21:20 <EvanR-work> the author could have randomly chose whether A or B kills you, and made up a nice story about it
10:21:34 <ion> tsousa: You could run “:i foo” in ghci (where foo is the name you wonder about).
10:21:39 <roconnor> EvanR-work: This is why prior information is useful
10:22:21 <EvanR-work> so were distinguishing between 'real information' and 'made up information (on the page) ' ? :)
10:22:28 * hackagebot cereal-enumerator 0.2.1 - Deserialize things with cereal and enumerator  http://hackage.haskell.org/package/cereal-enumerator-0.2.1 (PatrickPalka)
10:22:33 <EvanR-work> one affects your probability, one is just decoration
10:23:53 <benmachine> EvanR-work: ok, so you're in a train and there are buttons by the door that say 'open' and 'close' on them. is the chance of you opening the doors on your first try 50%?
10:24:01 <EvanR-work> hehe
10:24:05 <EvanR-work> exactly
10:24:14 <EvanR-work> maybe we need experimental evidence
10:24:15 <tsousa>  ion Eq (Map k a) Map in here is like having (Int k a) ?
10:24:17 <roconnor> benmachine: depends on if you have any prior information about 'open' and 'close'
10:24:33 <benmachine> roconnor: sure, and we do, don't we?
10:24:36 <benmachine> well, *I* do
10:24:40 <benmachine> dunno about you guys
10:24:40 <roconnor> I do to
10:24:44 <roconnor> not so sure about EvanR-work
10:24:53 <benmachine> heh
10:24:54 <EvanR-work> we know what is acceptable for the meaning of open and close
10:25:06 <EvanR-work> but we DONT know exactly how this train is built
10:25:28 <EvanR-work> this train
10:25:33 <roconnor> I'm wouldn't say for certain that the open button would open the door, but I would give it a high prior probability
10:26:01 <ion> tsousa: “data Map k a = …”: Map takes two types as parameters. “data Int = …”: Int takes no parameters.
10:26:05 <EvanR-work> also, we need a weird version of probability right, because this isnt a repeatable experiment
10:26:24 <EvanR-work> mystic probability
10:26:30 <roconnor> EvanR-work: Basian probablity isn't so weird
10:26:39 <EvanR-work> yeah baysian is mystic ;)
10:26:39 <ion> tsousa: Map is a type constructor. When applied to two types, it returns a type. Int is just a type.
10:26:59 <ion> tsousa: The analogy on value leve: (+) is a function. When applied to two values, it returns a value. 42 is just a value.
10:27:22 <roconnor> EvanR-work: but yes, baysian probability theory is find with this sort of scenario
10:27:46 <EvanR-work> can we correlate your open close response with a question about how much you would bet on open opening the door
10:28:17 <roconnor> that is one way to estimate your prior
10:28:53 * ddarius is only familiar with Bayesian probability theory.
10:29:12 <roconnor> I don't know how to spell Bayesian
10:29:44 * tac-tics is convinced Bayesian probability theory is just a made up thing
10:29:50 <EvanR-work> lol
10:29:58 <EvanR-work> math isnt real, its made up
10:30:02 <roconnor> tac-tics: Apparently it is a simple application of Cox's theorem.
10:30:30 <tac-tics> Whenever someone brings up Bayesian probability theory, they immediate bring up the idea of an "interpretation" of probability theory
10:30:46 <tac-tics> Leave that **** to the philosophers, thanks!
10:30:56 <tsousa> ion, yes but what type is it? and why do i need another type?
10:31:08 <ion> tsousa: What type is what?
10:31:45 <tsousa> ion, i am sorry if i am boring you. bit i am not really understantind why do i need a type to give me another type
10:32:04 <ddarius> In Bayesian probability theory you are working off your prior information.  It can be wrong.
10:32:09 <ion> tsousa: You can’t just have a map, you need a map from some type to another type. For instance, Map Integer String.
10:32:54 <ion> tsousa: In that map, keys are of type Integer and values are of type String.
10:33:07 <tac-tics> ddarius: isn't the defining point of probability (more accurately, randomness) is that you don't have all the information, and guessing actual random values can always be wrong?
10:33:31 <tsousa> ion, like map (+2) [1,2,3,4,] ?
10:33:43 <EvanR-work> tac-tics: good call
10:33:45 <ddarius> tac-tics: You don't guess your prior information.
10:33:49 <ion> tsousa: map is a completely different thing from Map.
10:34:11 <ion> tsousa: Data.List.map is a list function, Data.Map defines a data structure.
10:34:19 <ddarius> Randomness is completely irrelevant.
10:34:54 <ion> Map (type) :: * -> * -> * (kind, i.e. the type of a type)
10:34:57 <ion> Map Integer :: * -> *
10:35:00 <ion> Map Integer String :: *
10:35:08 <ion> (+) :: Integer -> Integer -> Integer
10:35:16 <ion> (+) 3 :: Integer -> Integer
10:35:24 <tsousa> ion, it maps key to values. ok. another question Map like "key" 10 which type will Map create?
10:35:27 <ion> (+) 3 4 (a value) :: Integer (a type)
10:36:11 <tac-tics> You know you've been in #haskell too long when someone says Map and the first thing you think about is a functor
10:36:27 <ion> @type :t Data.Map.fromList [(10 :: Integer, "foo")]
10:36:28 <lambdabot> parse error on input `:'
10:36:31 <ion> @type Data.Map.fromList [(10 :: Integer, "foo")]
10:36:32 <lambdabot> M.Map Integer [Char]
10:36:54 <ion> The type is Map Integer String in that case.
10:37:37 <tsousa> ion, so Map doesnt create another weird type?
10:38:56 <EvanR-work> roconnor: lets say you gave a 99.999999999999% chance that the door opens, then it doesnt open. whats the chance that your assigned probability was too high ;)
10:39:12 <ion> tsousa: Map is a type-level function which takes two parameters (the key type and the value type, e.g. Integer and String) and results in a type.
10:39:19 <ion> tsousa: such as Map Integer STring
10:39:39 <roconnor> EvanR-work: I'm not sure what that question means.
10:39:41 <tsousa> humm ok
10:39:59 <EvanR-work> roconnor: its possible you picked the right number, but probably not. right?
10:40:04 <ion> tsousa: The kind of Map is * -> * -> *, indicating it’s a type-level function of two parameters.
10:40:04 <tsousa> Haskell is a bit different from the other languages
10:40:14 <ion> tsousa: You can query the kind in GHCi with :k
10:40:16 <benmachine> EvanR-work: in the "real world", there is no such thing as probability
10:40:18 <benmachine> quantum aside
10:40:20 <tsousa> ion, yes that i know
10:40:25 <benmachine> it's all deterministic
10:40:35 <tac-tics> benmachine: What's so random about QM?
10:40:38 <tsousa> what i was not understanding was the type thing
10:40:40 <roconnor> EvanR-work: The prior is just a quantification of prior information.  In a certain sense it cannot be wrong.
10:40:48 <EvanR-work> benmachine: even if what you just said made sense, how does it help
10:41:03 <EvanR-work> roconnor: thats nuts
10:41:05 <tac-tics> benmachine: How do you know that QM doesn't operate on perfect, hidden (and necessarily non-local) information?
10:41:06 <benmachine> tac-tics: I don't understand it well enough to answer that question, but I don't want it cluttering up the discussion
10:41:14 <roconnor> EvanR-work: are you asking if I screwed up my computation of the prior?
10:41:28 <roconnor> EvanR-work: why is it nuts?
10:41:31 <benmachine> EvanR-work: well, I mean, there's no such thing as a "right number" objectively
10:41:46 <EvanR-work> if a probability model cant be wrong, then how can it ever be right
10:42:55 <benmachine> probability, it seems to me, is an abstraction, and so its properties depend on what you are abstracting
10:43:50 <ion> tsousa: What languages are you familiar with?
10:44:24 <tsousa> ion, python and C
10:44:44 <ion> tsousa: Both have types, although not as powerful as Haskell’s.
10:45:43 <tsousa> ion, yes both have types but i dont think that is any of those languages types can return other types
10:45:54 <roconnor> EvanR-work: I don't know of a process for determining if a model is poor not.  It seems like it might be out of scope.  ddarius might know better than me.
10:47:02 <ion> tsousa: Yeah, you can dump keys and values of any type into a Python dict for instance. Map requires the type of the key and the value to be known.
10:47:44 <ion> tsousa: I recommend reading http://learnyouahaskell.com/
10:48:02 <tsousa> ion, yes i am reading this book
10:49:45 <DukeDave> Hmm, there's a 'nice' way to do this isn't there?   a -> (a -> b) -> (a, b)
10:50:09 <rwbarton> @. pl djinn a -> (a -> b) -> (a, b)
10:50:09 <lambdabot> f = liftM2 (.) (,) (flip id)
10:50:18 <ClaudiusMaximus> :t id &&& (+1)
10:50:19 <lambdabot> forall b. (Num b) => b -> (b, b)
10:50:25 <c_wraith> :t (id &&& flip id)
10:50:25 <lambdabot> forall b b1. b -> (b, (b -> b1) -> b1)
10:50:36 <DukeDave> Closer still :)
10:50:39 <c_wraith> oh, whoops
10:50:46 <rwbarton> @. pl djinn (a -> b) -> a -> (a, b)
10:50:46 <lambdabot> f = ap (,)
10:50:57 <ion> @pl \a f -> (a, f a)
10:50:57 <lambdabot> liftM2 (.) (,) (flip id)
10:51:01 <ion> @pl \f a -> (a, f a)
10:51:01 <lambdabot> ap (,)
10:51:05 <roconnor> EvanR-work: I mean by definition your prior information yields the best prediction possible given the information that you know.  The fact the door doesn't open doesn't mean that there was something that you could have done to make a better prediction.
10:51:08 <c_wraith> yeah, reversing the argument orders makes that one a lot better
10:51:13 <benmachine> :t flip (ap (,))
10:51:14 <lambdabot> forall a a1. a -> (a -> a1) -> (a, a1)
10:51:59 <DukeDave> Wow, that's an interesting use of ap
10:52:00 <roconnor> EvanR-work: Knowing that the door doesn't open allows you to incorpoate that information, and would product a new prediction (depending on your prior) of a much lower probability of the door opening if you press the button again.
10:52:02 <ion> > show <*> (,) $ 42
10:52:03 <lambdabot>   Couldn't match expected type `a -> b'
10:52:03 <lambdabot>         against inferred type `GHC.Ba...
10:52:07 <ion> err
10:52:12 <ion> > (,) <*> show $ 42
10:52:12 <lambdabot>   (42,"42")
10:52:31 <DukeDave> Hmm, perhaps I'll keep the lambda form ;)
10:52:39 <c_wraith> DukeDave: it's the S combinator.  That's a natural use if you've studied SK or SKI calculus.  Which I haven't.
10:52:59 <ion> dukedave: http://heh.fi/haskell/functors/#function-instance
10:53:38 <monochrom> Haskell has the ap store
10:54:33 <DukeDave> monochrom: Speechless.
10:57:29 * hackagebot cereal-enumerator 0.3 - Deserialize things with cereal and enumerator  http://hackage.haskell.org/package/cereal-enumerator-0.3 (PatrickPalka)
10:57:31 * hackagebot Pugs 6.2.13.20111008 - A Perl 6 Implementation  http://hackage.haskell.org/package/Pugs-6.2.13.20111008 (AudreyTang)
11:02:42 <}ElectrowolF{> > [1..5]
11:02:43 <lambdabot>   [1,2,3,4,5]
11:04:50 <Luke> how do I get a lazy char8 bytestring? Data.ByteString.Lazy.Char8
11:06:11 <Luke> it keeps trying to include some internal bytestring?
11:06:26 <alpounet> parcs, it would be nice to have the changes since the last version in the description of the package
11:06:32 <alpounet> (if significant)
11:06:37 <monochrom> Data.ByteString.Lazy.Char8 is correct. don't worry about the name "Internal" leaking out.
11:07:01 <Luke> oh ok thanks
11:07:51 <Luke> can I use that with attoparsec then? the types aren't lining up when I use lazy char8 bytestring
11:07:54 <monochrom> if a type is defined in module X.Internal and re-exported by X, and you just import X, in some cases GHC and GHCi leaks out the information that the type originates from X.Internal
11:08:28 <Luke> I don't know how to make it work though... to make sure I have the right lazy type
11:08:36 <Luke> i can't get the types to lign up
11:08:38 <Luke> line*
11:09:06 <ski> shachaf : `.(A,As)' in Prolog, though there's sugar `[A|As]' (Clean and Erlang uses more or less that latter syntax, as well) -- i think the `.' probably comes from Lisp
11:09:29 <monochrom> the type Data.ByteString.Lazy.Char8.ByteString and the type Data.ByteString.Lazy.ByteString are identical
11:09:30 <ski> mekeor``,mm_freak : #haskell.de
11:09:48 <Luke> monochrom: one is char8 and one is word8 based
11:09:58 <ski> rwbarton : hm, would you know if there's a central place to get links to those videos ?
11:10:10 <ski> (ddarius : (re fibrations) reading Bart Jacobs' Categorical Type Theory ?)
11:10:12 <monochrom> no.
11:10:16 <ski> ddarius : what's the author and title of "that DTT thesis" ?
11:11:35 <monochrom> Data.ByteString.Lazy.Char8 gives you Char-centred API. Data.ByteString.Lazy gives you Word8-centred API. I hope you do not believe that API change must reflect internal representation change.
11:11:42 <ski> roconnor : (re bayesians and 50%) hmm .. it doesn't distinguish between not having any prior information and knowing (with high certainty) that the (prior) probability is near a half ?
11:11:57 <ski> DukeDave : aka `(arr id &&&)'
11:12:39 <Luke> monochrom: i don't care - I just want the types to work out
11:12:48 <monochrom> the types already work out
11:12:56 <Luke> no
11:13:09 <Luke> Couldn't match expected type `ByteString' with actual type `Data.ByteString.Internal.ByteString'
11:13:47 <monochrom> that is the non-lazy bytestring
11:14:09 <Luke> monochrom: I'm importing ByteString from Lazy though
11:14:46 <monochrom> but perhaps you're using an attoparsec function that wants a non-lazy bytestring?
11:14:51 <Luke> monochrom: oh I think the problem is I didn't change atto
11:14:52 <Luke> yeah
11:14:53 <Luke> thanks
11:15:36 <monochrom> lazy bytestring's fully qualified type is Data.ByteString.Lazy.Internal.ByteString
11:15:43 <ski> @where+ SF "Software Foundations" by Pierce,Casinghino,Greenberg,Sj�berg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages","It develop basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
11:15:43 <lambdabot> I will remember.
11:15:48 <ski> @where+ CPDT "Certified Programming with Dependent Types" by Adam Chlipala (aka Smerdyakov) (in progress) at <http://adam.chlipala.net/cpdt/>, "about practical engineering with the Coq proof assistant"
11:15:49 <lambdabot> I will remember.
11:16:17 <benmachine> ski: it develop basic concepts?
11:16:22 <monochrom> if you do enough exploration and not enough presumption, you will find that both Data.ByteString.Lazy and Data.ByteString.Lazy.Char8 refer to Data.ByteString.Lazy.Internal.ByteString for the real type
11:16:56 <rwbarton> ski: not sure, but http://www.youtube.com/user/edwardkmett seems to have a bunch.
11:16:57 <tac-tics> What part of Coq is practical again?
11:17:51 <monochrom> another victory of the XY Problem
11:18:47 <mm_freak> ski: oh, ok
11:18:48 <ski> benmachine : hm, copied from preface
11:19:07 <ski> @where+ SF "Software Foundations" by Pierce,Casinghino,Greenberg,Sj�berg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages","It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
11:19:07 <lambdabot> Done.
11:19:13 <benmachine> monochrom: the XY problem is nontrivial to solve
11:19:19 <roconnor> tac-tics: the part used to verify software running the French train system.
11:19:33 <monochrom> I completely disbelieve that.
11:19:49 <ski> rwbarton : ty
11:20:25 <monochrom> In fact, the problem is created because people try too hard to be nontrivial
11:20:30 <benmachine> monochrom: if you don't understand a problem, it's pretty hard to know which bit of it to tell people about
11:20:39 <ski> "XY problem" ?
11:20:56 <benmachine> ski: http://mywiki.wooledge.org/XyProblem this is what google turned up
11:20:59 <monochrom> the XY Problem : http://www.perlmonks.org/index.pl?node_id=542341
11:21:12 <benmachine> which incidentally is seemingly mostly IRC logs of people being dicks to people who want help
11:21:52 <roconnor> ski: Having "lots" of prior information that the probabiity is nearly a half and being completing ignorant will likely cause the basian updates to yield different results;  This implies that they will yield different predictions to some questions I believe.
11:22:27 <ski> roconnor : yeah, that's what i would hope as well ..
11:22:55 <roconnor> ski: for example having "lots" of prior information would probably say that the probability of the same thing happening if you press the button twice is about 50%
11:22:59 * ski is attempting to understand the basics of bayesian networks and updating by looking at two AIMA chapters
11:23:19 <ski> monochrom,benmachine : btw, ty
11:23:23 <roconnor> ski: where as the "ignorant" person might conclude that the same thing happening twice is very high
11:23:32 <monochrom> take a typical #math session for example. it is trivial to just copy out the homework question verbatim "solve x-5=6". it takes nontrivial thinking to infer "I should ask about how to solve equations in total generality" and so ask "how do I solve equations?"
11:23:42 <monochrom> therefore it is really the asker being a dick
11:23:55 <roconnor> ski: granted the very ignorant person who doesn't even know what the phase "the same thing" means, might revert back to 50% for all binary problems.
11:25:41 <benmachine> monochrom: being stupid is very different from being a dick
11:26:03 <ski> roconnor : hm, i'm assuming a generally reasonable and educated (about basic things) person, but who happens to now have any prior experience (or other data) on some phenomenon
11:26:34 <monochrom> a typical #haskell session is even more extreme. it is trivial to state the original job of "I have a datum, it could be one of 3 cases X, Y, Z; function f applied to that datum should give different results depending on the case".
11:27:11 <monochrom> but it takes one nontrivial thinking to decide "among the whole design space, I choose ad-hoc polymorphism"
11:27:38 <monochrom> and then it takes one more nontrival thinking to decide "among the whole design space of ad-hoc polymorphism, I choose existential types"
11:27:53 <ski> roconnor : i'm not sure i follow your "in the know" vs. "ignorant" person example though, in my ignorant/not-wholle-formed opinion i would expect the opposite outcomes
11:27:55 <benmachine> monochrom: at the same time, when you have GHC whining at you about problems you don't understand, it's easy to think "oh, this is a type error" when actually it's an indentation error
11:27:59 <benmachine> or whatever
11:28:04 <monochrom> and finally come out to ask in the blue "how can I get this existential type to work"
11:28:27 <benmachine> and then go "who can fix my type error"; it's not until we dig deeper that we find out that the problem statement was wrong, but that's actually no-one's fault
11:28:46 <monochrom> when GHC gives you an error message, the most trivial thing to do is to pastebin it verbatim
11:29:20 <monochrom> it takes several nontrivial steps to infer and infer and infer about the error message and come out asking "what does a->b mean?"
11:29:45 <benmachine> well, that's because people ARE going to try to understand things by themselves
11:29:50 <benmachine> this is a good thing :P
11:29:54 <benmachine> but sometimes they get the wrong idea
11:30:01 <benmachine> this isn't because they are bad people
11:30:19 <roconnor> ski: I guess I'm considering 3 people. (I originally was trying to consider 2 people, but I think 3 is instructive) ...
11:30:55 <shirt> how do i get rid of the warning "Defined but not used" that i get on record fields?
11:30:57 * ski . o O ( "tell us EXACTLY 1) what you typed; 2) what you saw; and 3) what you expected to see." )
11:30:59 <monochrom> and to answer your stupid-vs-dick: sure, at the beginning, the asker doesn't seem to be a dick, it doesn't show yet.
11:31:08 <roconnor> ski: the first person knows a lot about this door button.  He has prior information that the button is wonky and the door only opens about 50% of the time when pressed.
11:31:30 <benmachine> shirt: you can prefix them with an underscore
11:32:14 <roconnor> ski: Person 1) predicts that if you press the button once, then the door will open with 50% probability, and that if you press the button twice, the door will either open both times or close both times with 50% probability
11:32:24 <ski> ok
11:32:42 <roconnor> ski: Person (2) knows nothing about this door, but is aware of doors and buttons and usual things
11:32:53 <monochrom> but after the answerer answers the asked question (as opposed to the unasked real question), the answer to which clearly cannot possibly resolve the unasked real question, the asker begins arguing and interrogation and cross-examining, like a defense lawyer cross-examining a plaintiff witness. that's when the asker shows being a dick
11:32:53 <shirt> benmachine: cool thanks :) any other ways?
11:32:54 <ski> i'm not sure why an ignorant person should assing `50%', though
11:32:54 <benmachine> shirt: I think so anyway?
11:33:00 <roconnor> ski:  in particular he knows that usually when you press a button twice the same thing happens the second time.
11:33:05 <benmachine> shirt: er, disable the relevant warning? I guess?
11:33:10 <benmachine> or, you know, use it :P
11:33:15 <roconnor> ski: but knows nothing about this button and door
11:33:20 <ski> sorry, no ignore that line
11:34:08 <roconnor> ski: so this ignorant person would predict that if you press the button the door will open with 50% probability, but predicts that if you press the button twice, the door with either open both times or not open both times with very high probability.
11:34:08 <ski> i'm not sure why an ignorant person should assume any particular probability (with anything more than zero confidence) -- it seems unstable wrt introduction of more choices (however unlikely)
11:34:33 <shirt> benmachine: i'm using it, just not by name
11:34:52 <monochrom> and I happen to disagree that trying to understand is a good thing. at least, prematurely trying to understand is not a good thing.
11:34:59 <benmachine> shirt: well, those are all the ways I know
11:35:01 <roconnor> ski: He predicts 50% because it is the uniform prior and the uniform prior is used because of some reason.  Let me look it up.
11:35:20 <shirt> benmachine: thanks :) underscore works for now i guess
11:36:00 <monochrom> the scientific method includes a phase of "trying to understand", sure. but it is a late stage. you have to pile up a whole lot of empirical evidence, and it must also show a fairly clear pattern, before there is anything to understand.
11:36:22 <ski> roconnor : but if we invent a new choice "door opens partially, but gets stuck", now it seems we should then assign `1/3' instead
11:36:24 <monochrom> whereas most askers base everything on less-than-anecdotal evidence
11:36:59 <roconnor> ski: yes
11:37:32 <monochrom> which is what ski says. when you're still close to the ignorant stage, it is not very helpful to assume even a probability distribution yet
11:37:48 <monochrom> (let alone to assume a law)
11:38:06 <roconnor> ski: the rule is that the state of knowledge of two problems is equivalent (except upto the labeling of propositions) then the predictions will be the same.
11:39:25 <ski> roconnor : hm, can that intuition be formalized (to some degree) ?
11:39:32 <roconnor> ski: yes
11:40:19 <ski> (obviously being formalizable is distinct from being "correct" -- i'm just trying to determine whether there's and formal theory in bayesian probability and/or statistics to account for that intuition)
11:40:32 <ski> (s/and/any/)
11:41:01 <ski> roconnor : ok, ty
11:41:03 <roconnor> ski: yes, Bayesian reasoning is just applied Cox's theorem.
11:41:36 * ski would still like to account in some way for the uncertainty of the priors, though
11:42:22 * ski possibly should try to read E. T. Jaynes book again ..
11:42:40 <roconnor> ski: Jaynes says that the standard devation of parameter estimation tells you the uncertanty of the prediction.
11:43:08 <roconnor> or at least an easy way to compute a value that is somehow related to the uncertanty of the prediction.
11:43:57 <roconnor> ski: I'm not sure how to apply it to confidence of prediting events :/
11:44:28 * roconnor should write a cron job to automatically renew Jaynes' book from the library indefinitely
11:45:24 <ski> (<http://en.wikipedia.org/wiki/Cox%27s_theorem> i assume)
11:45:50 <trinithis_> Should be Cock's Thm (Cock as in a bird, not a ... you know)
11:46:02 <ski> roconnor : hehe, doesn't work here anymore
11:46:52 <roconnor> ski: that is the right wikipedia link, though the article appears to be terrible.
11:47:27 <ski> (btw, to clarify, the "i'm just trying to determine .." above was specifically wrt to the "to account for that intuition" part)
11:48:54 <bfig__> i've just 'read' Hinze's paper on adjoint folds, and i have *several* questions :p. anyone around understands what's going on there?
11:49:26 <ski> what's the paper about ?
11:49:38 <bfig> adjoint folds :|
11:49:47 <ski> which are ?
11:49:51 <trinithis_> so basically oragomi?
11:49:56 <ski> any relation to adjunctions ?
11:50:07 <ski> (galois connections ?)
11:50:50 <bfig> yes
11:51:04 <byorgey> bfig: I might be able to answer your questions.
11:51:18 <byorgey> I read it a few weeks ago and followed most of it.
11:51:59 <bfig> really? that is awesome, i have read it with the intention of starting to get close to the CT behind functional programming constructs but i think it was a bit too much
11:52:34 <byorgey> yeah, it is not a good starting point if you want to understand the relationship of CT to FP.
11:52:50 <bfig> how would you summarize the main point of the paper? for what i could understand, you have certain recursive datatypes and you want to describe computations on them
11:52:52 <byorgey> I have been reading this sort of paper for a few years now, and I still found it difficult going
11:53:51 <bfig> then given a computation you transform it to a context where you have terminating total functions
11:54:39 <bfig> what would you suggest i should read before? i won't be able to make much of this even if you explain it to me i think :p. there was a paper about bananas and lenses and whatnot, i downloaded it a while ago and started reading, it seemed more accessible
11:55:19 <byorgey> bfig: there is a well-known theory of folds (resp. unfolds) for data types viewed as initial algebras (resp. final coalgebras) of some functor
11:55:40 <byorgey> this paper observes that there are some functions which seem kind of like folds/unfolds but do not quite fit the well-known pattern.
11:56:19 <byorgey> but it turns out that there are adjunctions hiding there, and they exploit the properties of adjunctions to give a somewhat more general theory
11:56:49 <byorgey> bfig: yeah, the bananas and lenses paper is good.
11:56:53 <DanBurton> Apparently the 322 people over at #scala are all asleep. Anybody here familiar with how I do this Haskell in Scala? http://pastie.org/2657037
11:57:11 * trinithis_ is going to get pretty faded soon
11:57:18 <bfig> how does that apply to the theory of functional programming? what do this adjuntions give? ways to write folds for not-so-foldish structures?
11:57:46 <ski> bfig : "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf> might be interesting
11:57:56 * bfig downloads it
11:58:19 <byorgey> bfig: I have one very excellent recommendation for you but I am trying to find a link...
11:58:48 <bfig> byorgey, what is the name of the paper?
11:58:55 <byorgey> I don't remember =)
11:58:58 <erus`> anyone know of a purely functional language on .NET ?
11:59:06 <bfig> erus`, F#
11:59:14 <erus`> not pure
11:59:32 <erus`> i think?
12:00:28 <bfig> don't think .NET is a framework allowing pure computations
12:00:42 <ski> bfig : there's also a book called "The Algebra of Programming", by Richard Bird and Oege de Moor, which talks much of folds -- your resident university library might have it
12:00:51 <wyfrn> is there a "official" / common way to force mapM to do things strict?
12:00:52 <byorgey> bfig: ah, here it is: "Calculating functional programs" by Gibbons. http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/acmmpc-calcfp.pdf
12:01:02 <EvanR-work> ski: im interested
12:01:11 <bfig> thanks to both for the recommendations, gonna check them
12:01:27 <byorgey> bfig: yes, ski's suggestion (Algebra of Programming) is good too.  A bit dated but of course the math hasn't changed.
12:01:27 <ski> erus` : hm, iirc there's a .NET backend for Mercury, which is a purely logic/functional language
12:01:37 <EvanR-work> folds sound superficially like a very peaceful way to roll
12:02:05 <Saizan> the adjoint folds paper seems to be about mangling the theory of folds to handle a larger class of recursive definitions instead of mangling those definitions to make them fit the theory of folds
12:02:22 <byorgey> Saizan: yes, that's a good way to put it =)
12:02:28 <trinithis_> *CRACKING OPEN BEER*  cheers
12:02:41 <byorgey> the theory isn't really mangled though, it's actually quite beautiful (IMO)
12:02:43 * EvanR-work is jelly at trinithis_ 
12:03:08 <Saizan> yeah, but i had to respect the symmetry :)
12:03:17 <byorgey> hehe, of course =)
12:03:49 <byorgey> ok, back to work...
12:03:50 <trinithis_> I finished my Control.Monad.List package.. need to upload to hackage... if I can remember my pw. It's the list functions but on monads
12:04:42 <wyfrn> is there a "official" / common way to force mapM to do things strict?
12:04:42 <ski> @where evolution
12:04:42 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
12:05:02 <ski> bfig : that ^ also has some fun fold examples .. maybe you've seen them before, though
12:05:16 <trinithis_> http://www.ariel.com.au/jokes/The_Evolution_of_a_Programmer.html
12:05:42 <ski> EvanR-work : hm, interested in what ?
12:06:28 <EvanR-work> ski: 'theory of folds' with respect to 'programming'
12:08:10 <DanBurton> wyfrn: what exactly do you mean "do things strict"?
12:08:29 <byorgey> bfig, EvanR-work: I also recommend reading Jeremy Gibbons' blog starting at the beginning: http://patternsinfp.wordpress.com/2010/09/03/functional-programming/
12:09:18 <byorgey> he also lists a bunch of references + further reading here: http://patternsinfp.wordpress.com/2010/09/18/story-so-far/
12:09:47 <maxamillion> hello all, I'm following along with http://learnyouahaskell.com/starting-out (I plan to buy a copy of the book this weekend, its quite awesome) and I'm trying to run the example "length' xs = sum [1 | _ <- xs]" in the interactive interpreter and its giving me the error: <interactive>:1:12: parse error on input `='
12:09:53 <maxamillion> any help would be greatly appreciated
12:10:14 <EvanR-work> trinithis_: lol
12:10:32 <byorgey> maxamillion: the interpreter does not (yet) allow you to create new definitions like that
12:10:46 <ski> maxamillion : either (a) enter it into a file, e.g. `Test.hs', and load the file by `:l Test'; or (b) prefix a `let ' before the line
12:10:47 <DanBurton> :t mapM
12:10:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:10:50 <byorgey> maxamillion: instead, put the definition(s) in a .hs file, and then load the file into ghci with :load
12:11:03 <maxamillion> ahhhh ok
12:11:08 <maxamillion> awesome, many thanks
12:11:23 <Skola> What's a nice way to do string interpolation in Haskell?
12:11:28 <ski> maxamillion : the (b) is in case you're using GHCi (which was just an assumption)
12:11:41 <EvanR-work> Skola: concat
12:12:19 <Skola> But it's like a multiline string with multiple interpolated parts
12:12:40 <EvanR-work> "this is a \n\
12:12:42 <maxamillion> ski: yes, I am .... I mentioned the interactive interpreter, are there more than ghci? (*extremely* new to haskell, so apologies if that was a stupid question)
12:12:48 <Skola> and I have to wrap it into a function because I use it a couple of times
12:12:48 <EvanR-work> \multiline string in\n\
12:12:51 <EvanR-work> \haskell"
12:13:10 <tac-tics> maxamillion: GHCi is the defacto interpreter.
12:13:18 <tac-tics> Other Haskell implementations probably furnish their own
12:13:19 <Skola> \I know but isn't there\n\
12:13:26 <ski> maxamillion : for larger pieces of code you probably want to put it in a file anyway (though you can enter multiple lines into GHCi if you delimit with `:{' and `:}' (sad and satisfied smileys, yay !))
12:13:26 <Skola> \a prettier solution?\
12:13:42 <EvanR-work> Skola: theres template engines, but really, do you need one?
12:13:54 <EvanR-work> and thats what functions are for
12:14:16 <zzo38> Can you review this program please?   http://sprunge.us/YNJW
12:14:18 <maxamillion> tac-tics: ah
12:14:20 <monochrom> try not to do string interpolation
12:14:22 <maxamillion> ski: certainly
12:14:26 <maxamillion> ski: thanks again :)
12:14:38 <ski> maxamillion : also, currently you can't define modules, types, type classes in GHCi (though i understand people are attempting to fix that) -- so you need a file for those anyway
12:14:39 <Skola> it's for writing config files etc
12:14:40 <tac-tics> maxamillion: GHC (Glasgow Haskell Compiler) is the "standard" Haskell implementation, and the one almost everyone uses
12:14:51 <tac-tics> maxamillion: But there are others, as well
12:15:01 <zzo38> ski: Yes I agree they should fix that
12:15:02 <Skola> EvanR-work: I don't think I need a template engine, no
12:15:20 <maxamillion> tac-tics: ah ok, makes sense ... kinda like CPython in python land?
12:15:27 <ski> zzo38 : incicentally, the first haskell compiler supported that ..
12:15:28 <tac-tics> maxamillion: yup
12:15:28 <EvanR-work> Skola: php style string interpolation, it seems to me, is purely porcelain for the sake of being cool looking
12:15:35 <maxamillion> tac-tics: awesome, thanks again :)
12:16:02 <Skola> yeah you might be right
12:16:14 <monochrom> I agree that string interpolation is convenient. I observe that it fits badly with other concerns of Haskell though.
12:16:16 <tech2> Purely out of interest, why would one choose to use a Haskell compiler other than GHC?
12:16:34 * ski agrees with monochrom
12:16:48 <tac-tics> maxamillion: It's probably more degenerate than that, though. GHC defines so many extensions to haskell. You can write GHC programs that are simply aren't possible in Hugs or YHC
12:16:59 <EvanR-work> Skola: http://codepad.org/y5iRQCuF
12:17:02 <monochrom> just explaining why Haskell doesn't have string interpolation yet
12:17:05 <zzo38> tech2: Possibly, testing, to test that it works with all Haskell compiler it is more likely to be a correct program, you can know if there is a bug in GHC too.
12:17:08 <cheater> tech2: JIT, of course.
12:17:10 <maxamillion> tac-tics: always fun
12:17:45 <Skola> yeah EvanR sure ;)
12:17:47 <zzo38> Did you look at my program please, and suggestion/comment/complain/question?
12:18:00 <ski> tac-tics : .. you can also write Hugs programs that aren't possible in GHC
12:18:08 <erus`> how would you define compose and fix (functions that work on other functions)?
12:18:14 <erus`> functional functions?
12:18:19 <tac-tics> ski: Honestly, I've never used hugs. But GHC is kinda crazy with all the extensions it provides
12:18:20 * ski is thinking about TREX and restricted type synonyms
12:18:40 <Eduard_Munteanu> @src fix
12:18:40 <lambdabot> fix f = let x = f x in x
12:18:59 <Eduard_Munteanu> Or fix f = f (fix f)
12:19:03 <EvanR-work> Skola: its actually pretty cool, that expression will be 'built' lazily, letter by letter
12:19:13 <monochrom> at certain times, string interpolation is also inconvenient. that is, in Haskell, if I mean "$4", I just write "$4". in languages with string interpolation and stealing $ for that, I have to remember to write "\$4", it's annoying.
12:19:50 <EvanR-work> $$4
12:19:50 <engla> there is printf
12:19:55 <EvanR-work> four double dollars
12:20:07 <EvanR-work> printf doesnt give you as much control as concat
12:20:33 <engla> printf gives you control like %.4f  etc
12:20:46 <ski> tac-tics : see "The Hugs 98 User Manual - 7.3.5 - Restricted type synonyms" at <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> -- this is something i've wanted in GHC
12:20:54 <EvanR-work> id rather have more expressive formatting than a dedicated esoteric language
12:20:57 <monochrom> printf is frown upon in the string interpolation community too, because the argument is written far far away
12:21:05 <ski> tac-tics : also see TREX on the same page for an example of a more flexible record system
12:21:05 <EvanR-work> regex etc considered harmful
12:21:13 <little_zanooda> hello, i extensivly use amazon's web services, usually i use boto (python module) to write my cloud scripts, does haskell have anything for amazon ec2?
12:21:27 <EvanR-work> concat is pretty declarative
12:21:40 <Skola> EvanR-work: I need really simple stuff like http://codepad.org/WndAsQdP
12:22:06 <EvanR-work> did you even read my paste? ;)
12:22:30 <Skola> yeah I did : )
12:22:34 <monochrom> otoh the haskell pretty-printing libraries beat all other approaches if indenting the output is important (and also if word-wrapping is important)
12:22:42 <Skola> and it's fine for my purposes, thanks
12:22:54 <EvanR-work> Skola: yeah. and using ++ instead of concat is equivalent, i think
12:22:58 <EvanR-work> in terms of evaluation
12:23:11 <ski> monochrom : *nod*, and for some uses it would be better if you didn't escape a backslash as `\\' (or at least if an additional way was provided)
12:23:16 <monochrom> yeah, x++y++z will do the right thing
12:23:29 <monochrom> I really hate escaping.
12:24:39 <EvanR-work> http://codepad.org/S1JE8lpT
12:24:52 <zzo38> ski: Will quasiquotation do?
12:25:08 <monochrom> regex has its escaping. emacs lisp its escaping too. now write a regex in an emacs lisp string. up to 4 \'s to stand for 1 \ . it's ridiculous. I hate escaping.
12:25:17 <EvanR-work> Skola: if you find yourself writing a lot of xml, then you might want to not use strings directly
12:25:31 <Skola> EvanR-work: that looks ok, somewhat better than ++
12:25:40 <Luke> monochrom: you can change the regexp style in emacs
12:25:56 <Skola> Yeah I could look at an xml lib but these are just small sys admin scripts
12:26:33 <zzo38> monochrom: And, what would be, if you have a syntax, that a string lasts to end of line, or using the Hollerith notation (put the length at first, and then enter the characters of the string with no escaping)
12:26:43 <EvanR-work> Skola: vhost [DocumentRoot "path" x, ServerName "domain"]
12:26:47 <EvanR-work> example
12:26:59 <EvanR-work> er x instead of "domain"
12:27:13 <EvanR-work> where functions and constructors are defined in your config module
12:27:39 <ski> monochrom : i.e. assume it was escaped as `\e' for the sake of argument, then doing `(show . show . show . show) ""' would yield `"\"\e\"\ee\e\"\eee\ee\e\"\eee\ee\e\"\ee\e\"\e\"\""' instead of `"\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""'
12:27:52 <EvanR-work> if you find yourself writing admin scripts in haskell and needing the same sort of support, make a library
12:28:02 <Skola> hm yeah perhaps
12:28:03 <ski> zzo38 : will quasiquotation do what ?
12:28:04 <EvanR-work> if you find yourself writing admin scripts in haskell and needing different support each time
12:28:07 <EvanR-work> maybe you need bash
12:28:24 <Skola> yeah I thought about that
12:28:38 <Skola> but generally Haskell is just fine for what I need
12:29:00 <Skola> I'm not hitting any limit
12:29:18 <Skola> but was curious about how others would do these strings
12:29:25 <zzo38> ski: For example, string without escaping; although you still need delimiters so it still is not always work
12:29:45 <ski> monochrom : "printf is frown upon .." -- yes, that's why some kind of quotation&unquotation mechanism is superior (to that) -- using `(++)' and `concat' of course also achieves this locality, though somewhat more ugly/noisily
12:30:13 <monochrom> a regex has a corresponding AST. I want to write that AST. I don't want to write a string. string is dry.
12:30:31 <ski> zzo38 : i'm not sure i understand what you mean by "string without escaping" here, elaborate ?
12:30:46 <monochrom> the AST is unambiguous, does not need parentheses, and does not need escaping
12:31:00 <ski> monochrom : *nod* .. e.g. Racket has a native syntax for regex
12:31:43 <tac-tics> ski: Also, why don't languages provide regex composition? (And string concatenation isn't good enough!)
12:32:00 <monochrom> anyway, to output a complicated string in Haskell, usually I just use ++, and then if indentation is important, I go all out for a pretty-printing library.
12:32:29 <zzo38> Is there a Template Haskell program to convert regular expressions to Parsec?
12:32:35 <tac-tics> Instead of [A-Za-z0-9\.]+@[A-Za-z0-9\.]+\.(com|net|org), why isn't it name + regex '@' + domain?
12:33:26 <didier> @version
12:33:26 <lambdabot> lambdabot 4.2.2.1
12:33:27 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:33:46 <josiah_> im learning haskell, and i have just a quick question
12:33:59 <josiah_> how do most of you get around using boxed arrays since they slow things down so much
12:34:19 <zzo38> Do any of you know how to check the program that I have posted, please?
12:34:27 <monochrom> firstly they may be fast enough for me
12:34:41 <monochrom> secondly if they are not fast enough, I go unboxed array
12:36:11 <dafis> josiah_: unboxed arrays, STUArray for example if you need mutable arrays, UArray if it's create once and after that only read
12:37:28 * ski is partial though to something like Scsh's SRE (Symbolic-expression Regular Expression) syntax, as in <http://www.scsh.net/docu/html/man-Z-H-7.html#node_chap_6>,<http://www.ccs.neu.edu/home/shivers/papers/sre.txt> and <http://synthcode.com/scheme/irregex/>
12:37:32 <zzo38> Does nobody else know my program please?
12:37:39 <ski> (as opposed to the traditional string syntax)
12:37:57 <josiah_> Thanks monochrom and dafis for the quick responses.  The whole boxed and unboxed issue is new to me, coming from C++
12:38:09 <ski> tac-tics : see the links above ^
12:38:30 <josiah_> quite a learning curve going from imperative to functional
12:38:51 <ski> tac-tics : hm, what do you mean by "regex composition"
12:39:04 <DanBurton> josiah_: unlearning curve, rather
12:39:10 <tac-tics> ski: I mean I'm venting because I'm stuck in PHP land
12:39:16 <tac-tics> (or any mainstream language land)
12:39:26 <tac-tics> where regexes are strings for some ungodful reason
12:39:50 <ski> Matt Might's "Pattern-matching regular expressions in Scheme using derivatives" at <http://matt.might.net/articles/implementation-of-regular-expression-matching-in-scheme-with-derivatives/> might also be interesting
12:39:53 <josiah_> its a big one, I went Assembly -> C++ -> Haskell
12:40:03 <monochrom> boxed array buys you laziness. you would do exactly the same thing in C if you wanted laziness
12:40:05 <ski> (cf. derivatives of types)
12:40:15 <josiah_> technically VHDL before assembly, per my college curriculum
12:40:21 <tac-tics> josiah_: You should throw a Lisp in there between C++ and Haskell. It makes the jump less horrible.
12:40:42 <monochrom> lazy array buys you no-brainer dynamic programming
12:41:13 <DanBurton> tac-tics: disagree. All you have to do is clear your mind of your old programming ways, and then the Haskell zen will distill upon you like dew from heaven
12:41:19 <josiah_> thats one way of looking at it, but I chose haskell because I wanted to be forced into the functional way of doing things.  I do well if the difficulty forces me to meditate a bit on the tougher issues
12:41:26 <ddarius> ski: Developing a what a prior should be mathematically is non-trivial, but usually doesn't matter as long as its roughly "right."  If the precise details do matter, it usually means you have too little information.  Maximum entropy and group transformations (symmetry) provide two methods, with rather wide applicability, of assigning priors that don't "bias" the prior except as indicated by the data and the assumptions
12:41:26 <ddarius>  built in to those techniques.
12:41:36 <tac-tics> DanBurton: It helps to break free of your fear of lambda first, IMO
12:42:34 <DanBurton> tac-tics: I suppose I wouldn't really know. I started learning Haskell last December, and simultaneously learned Racket in class from Jan-Apr. It was actually quite beneficial to learn both interleaved like that
12:42:42 <ddarius> ski: In particular, to apply maximum entropy, you have to have an exhaustive list of possibilities (though one could certainly be "or something else happens") and that's (part of) why you'd get the 1/N uniform distribution in the no-data case.
12:42:49 <monochrom> lisp is not regular enough. do scheme if you want to do something along that line
12:43:09 <tac-tics> Is racket just what they call Scheme nowadays?
12:43:19 <DanBurton> Racket == PLT-Scheme
12:43:22 <DevHC^> josiah_: u know what's true love?
12:43:26 <tac-tics> monochrom: I wouldn't dare suggest any human being with a soul use common lisp
12:43:52 <DanBurton> the name change was actually right around the beginning of this year, I believe.
12:43:59 <ski> DanBurton : well, one should still learn Scheme for the hygienic macros
12:43:59 <DevHC^> josiah_: it's when u find something which u seem to be in love with first, and then find something better, which makes u consider dropping the old thing and be in love with the new thing
12:44:00 <josiah_> In all reality, once I learn Haskell, I'll probably apply what I've learned about how to do things functionally to OCaml since the benchmarks in footprint and speed outdo Haskell
12:44:18 <ski> (DanBurton : and possibly also for continuations)
12:44:22 <ddarius> Incidentally, a "normal" person walking up to a door actuated by a button, would have a much higher than 50/50 prior expectation of the door opening when the button is pressed.
12:44:35 <DevHC^> josiah_: so if u found that u were in love with C++ when u first learned C++, and then dropped C++ when u first learned Haskell, then that is true love xD
12:44:36 <josiah_> so what do you do when your love is finding new and interesting ways to solve a problem?? lol
12:44:45 <bgamari> What is the current state of context synonyms support in GHC?
12:44:45 <DanBurton> ski: yeah, call/cc is a little easier to swallow when you don't have to be in the Cont monad
12:44:46 <josiah_> haha
12:44:47 <EvanR-work> lool ocaml
12:44:54 <EvanR-work> because its higher performance than haskell
12:44:58 <tac-tics> josiah_: Ocaml seems nice, too. Really, most FP langs are working together to break out of obscurity.
12:45:13 <josiah_> yah
12:45:30 <bgamari> Is there any reasonable way to deal with repetitive context declarations?
12:45:30 <josiah_> after reading a lot of them, on certain tasks, they are way more readable and should be more mainstream
12:45:31 <EvanR-work> ocaml is impure, has no type classes...
12:45:31 <tac-tics> Haskell is pretty much the sanctuary of FP programmers because they've undoubtedly got the best community
12:45:36 <josiah_> thats the conclusion I've drawn
12:45:40 <tac-tics> impurity isn't a crime. It's a sin.
12:45:44 <tac-tics> And sins can be absolved
12:45:51 <tac-tics> by a priest... or a careful engineer
12:46:07 <tac-tics> Lack of type classes is just silly though :P
12:46:11 <DanBurton> bgamari: I believe context synonyms were in recent news..or something like htat
12:46:18 <DanBurton> *that
12:46:39 <ski> ddarius : hm, but why should we assume that our division of the possibilities divide the outcome space in equal parts, sans symmetry arguments ? -- i.e. how can be be reasonably sure our divison is "natural" ?
12:46:52 <bgamari> DanBurton: Any references?
12:47:02 <ddarius> ski: I've read Bart Jacobs' thesis several times.  I've never read his book.  I'm not currently reading it.
12:47:20 <bgamari> If there is one feature I'd like at the moment it would be context synonyms (and perhaps improvement of record namespacing)
12:47:31 <bgamari> DanBurton: It was worked on at Hac5 I guess
12:47:32 <josiah_> I dont think any applicable idea in programming could be a sin.  Theres just advantages and disadvantages to using each different language which makes them better for some tasks and worse for others
12:47:53 <bgamari> Seems like it was dropped before being finished, which is a shame
12:47:54 <parcs> bgamari: class (Foo a, Bar a) => Baz a; instance (Foo a, Bar a) => Baz a creates a pseudo type-class synonym
12:48:01 <DanBurton> @google haskell type synonym
12:48:01 <EvanR-work> thats like saying lack of types is a feature not a design inability
12:48:02 <monochrom> in the beginning, some people got tired of repeating the type "a -> m b" all the time, and so they invented "type synonyms": you declare "type Kelsy m a b = a -> m b", now you can write "(>=>) :: (Monad m) => Kelsy m a b -> Kelsy m b c -> Kelsy m a c
12:48:03 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Type_declarations
12:48:03 <lambdabot> Title: Haskell/Type declarations - Wikibooks, open books for an open world
12:48:53 <monochrom> but after a while, it backfires. to understand Kelsy m a b, you expand it back to a -> m b all the time in your head. the synonym obscures rather than helps.
12:48:54 <ski> ddarius : ok (i was asking since i've looked a little at it, and it talks a lot about fibrations)
12:49:00 <josiah_> thats y i mix and match languages when I write my programs.  When I want speed, I use C++, when I want readability and conciseness I pick Python or Ruby, and Haskell will probably fit in there somewhere
12:49:06 <ddarius> ski: And the DTT thesis I'm refering to, I'm pretty sure is Dan Licata's as you've probably guessed by now.
12:49:15 <EvanR-work> josiah_: im fairly suspicious of cautious 'balanced approaches' to analyses ;)
12:49:28 <josiah_> lol
12:49:40 <EvanR-work> as in we need a balance between haskell awesomeness and phps shittiness
12:50:06 <monochrom> oh, you can say something about "meaningful" names. the great news is that a "meaningful" name means different things to different people, so every "meaingful" name is lost on some large group of people, who must always expand it back to a -> m b, which is the real meaning.
12:50:07 <josiah_> haha
12:50:18 <EvanR-work> or a balance between science and creationism ;)
12:50:22 <tac-tics> josiah_: Haskell (and ML-derived languages in general) are really good when you want to talk about tree structured data
12:50:25 <monochrom> And now, people want to repeat the mistake and ask for constraint synonyms.
12:50:47 <tac-tics> josiah_: when you want to write a small DSL, functional programming is king.
12:50:55 <ddarius> ski: The division is part of your prior information, you "know" it, or you can use symmetry to come to the conclusion.  A coin flip has 50/50 probability of coming up heads if we know nothing about it, simply because the cases a symmetric.
12:51:06 <josiah_> So, like navigating a filesystem
12:51:13 <josiah_> or DSL i can see that
12:51:18 <bgamari> monochrom: In the case you are using a very general library with a small subset of its potential type domain, context synonyms could be very helpful
12:51:23 <josiah_> I'm right now working on a scientific application
12:51:25 <bgamari> This is the situation I find myself in
12:51:34 <tac-tics> josiah_: If you look at ANY paper on Haskell or type theory, the first thing they do is define a small minimal language in about 2 pages then start proving shit about it
12:51:44 <bgamari> There's far too much yanking and pasting go on
12:51:45 <ddarius> ski: But still, you can be "wrong" and your prior information will be updated as you gain more data, and you will not make very "confident" statements using an uninformative prior.
12:52:33 * hackagebot monadlist 0.0.1 - Monadic versions of list functions  http://hackage.haskell.org/package/monadlist-0.0.1 (ThomasEding)
12:53:32 <josiah_> tac-tics, why is that the case with these papers?
12:54:01 <DanBurton> bgamari: see if the Constraint Synonyms is relevant to you: http://blog.omega-prime.co.uk/?p=127
12:54:13 <DanBurton> *the section
12:54:23 <ddarius> ski: Jaynes' derivation of the Jeffreys prior is a decent demonstration of the transformation groups approach which generalizes the concept of symmetry.
12:54:36 <monochrom> GHC already has something close enough to constraint synonym. declare "class (Monad a, Num a, Show a) => Tea a", you don't even need the word "where". then write some instances. if that is your cup of tea.
12:55:20 <monochrom> it will backfire. in fact it has already backfired. did you know that by including "Num" there, you also need an "Eq" instance?
12:55:29 <tac-tics> It's just the way things are. The tools of (typed) functional programming: recursive data types, pattern matching, recursion, etc are all very suited for talking about structured data. And programs are just a special kind of structured data.
12:55:53 <bgamari> DanBurton: Thanks!
12:56:06 <monochrom> in a sense, Num is a combination of providing arithmetic methods and synonyming Eq.
12:56:29 <EvanR-work> tac-tics: i find most web programming just moving data around
12:56:45 <EvanR-work> so well defined data and obvious tools to move it makes things way easier
12:56:51 <DanBurton> monochrom: and a Show instance. I got snagged on that earlier when I made numeric continuations an instance of Num, which may or may not have been a good idea in the first place
12:57:01 <tac-tics> EvanR-work: Web is mostly "Yet another crud app"
12:57:13 <EvanR-work> i reject all 'delete' operations
12:57:24 <EvanR-work> and most updates
12:57:30 <DanBurton> bgamari: yeah, wasn't as recent as I had thought. I had to dig a few pages deep into my reddit comments to find it :)
12:57:36 <tac-tics> EvanR-work: So as long as your mutability is all well tracked (UD in CRUD), then yeah FP is good for that too
12:57:42 <ddarius> ski: Probability theory (Bayesian or otherwise) does not protect you from having an "incorrect" assumption in your prior information or (more commonly) omitting relevant prior information.  All you can do in those cases (unless the prior information is outright contradictory) is use "common sense"/experience to judge whether the results seem reasonable.
12:58:15 <josiah__> hmm
12:58:27 <EvanR-work> tac-tics: everything can be reduced to inserts
12:58:33 <EvanR-work> assuming infinite harddisk
12:58:50 <tac-tics> EvanR-work and assuming infinite customer patience ;)
12:58:54 <EvanR-work> nah
12:59:01 <EvanR-work> i tell them its O(log n)
12:59:10 <DanBurton> not the best assumptions :P
12:59:28 <EvanR-work> lol
12:59:28 <monochrom> no theory protects you from misuse due to ignorance or dishonesty
13:00:58 <monochrom> if you have the theory of "real numbers as a group under addition", you can misapply it as "10% increase this year, 10% increase next year, therefore 10%+10%=20% increase altogether"
13:01:26 <ski> ddarius : ok, "2-Dimensional Directed Dependent Type Theory" with Robert Harper -- no i hadn't figured that out yet (i was getting too many links to "Foundations and Applications of Higher-Dimensional Directed Type Theory")
13:01:38 <ddarius> ski: No, his thesis.
13:02:02 <ski> ddarius : the coin flip case i can understand, because we can reason that the two cases are mostly equivalent
13:02:15 <ddarius> They aren't "mostly equivalent."
13:02:16 <ski> i don't see why that would apply to the door case, though
13:02:20 <dafis> monochrom: for small values of 10
13:02:33 <ddarius> They are, if you know nothing else, exactly symmetrical.
13:02:35 <ski> (typically the engravings on the two sides differ)
13:03:06 <ddarius> ski: That's only relevant if I know how those would impact the flip and know enough about them to make such a decision.
13:04:38 <ddarius> One formal way of seeing it is, if you can flip "heads" with "tails" with all the (relevant) prior information that you know (or more precisely that you are "inputting") and everything still holds, then the cases are symmetric.
13:05:24 <EvanR-work> haha i started a huge discussion on prior knowledge
13:05:40 <dankna> gahhhhhh freaking typechecker ><
13:05:43 <dankna> why can't it read my mind
13:05:57 <EvanR-work> do what i mean, not what i say
13:05:58 <ddarius> dankna: It can.  Your mind is self-contradictory.
13:06:07 <dankna> yeah, what ddarius said is probably about right
13:06:50 <monochrom> your mind is wrong. the typechecker doesn't want to read it
13:07:01 <ski> ddarius : hmm
13:07:22 <dankna> tough, maybe some typecheckers need to quit complaining and do their jobs
13:07:27 <ski> ddarius : i (partially, and probably somewhat erroneously) recall an anecdote about someone who had collected a kind of polygon-conic shells, and sorted them according to the number of sides the polygon had, this appeared to tend to a gaussian distribution. later someone realized that it was skewed to the side, and suggested that it was actually the angle that was roughly gaussian distributed
13:07:27 * monochrom certainly wouldn't want to read wrong blogs. a computer is yet smarter than me
13:07:33 <ski> (monochrom : s/Kelsy/Kleisli/ :)
13:07:53 <monochrom> yeah, Klesili is too hard to spell right
13:08:50 <ski> (hm, too bad he died)
13:09:20 <erus`> @hoogle  (a -> m b) ->  [a] -> m [b]
13:09:20 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:09:20 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:09:21 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
13:10:13 <hpaste_> dankna pasted “subDeserializer no workie” at http://hpaste.org/52293
13:10:31 <dankna> I know this is a long paste, but I'd really appreciate help with this one.  I've got some sort of conceptual failing that I can't wrap my mind around.
13:10:47 <ddarius> Why are you trying to wrap your mind around conceptual failings?
13:11:07 <dankna> well, I'm trying to wrap my mind around THE TRUTH
13:11:14 <dankna> which is, naturally free of them
13:11:20 <dankna> but it has some in it at present
13:11:23 <monochrom> don't take "wrap my mind" too seriously
13:11:26 <dankna> which need to be untangled before? yeah
13:11:39 <ski> ddarius : so, my worry is : it seems to me that there ought to be a way of saying that one prior that is "more correct" that the other, e.g. the symmetry analysis here shouldn't require global properties (number of sides) (cf. the pressure related to the angle being a local property)
13:11:42 <dankna> is subSeserializer even possible?
13:11:55 <dankna> is there a standard monad or transformer that does what I want instead of writing this custom one?
13:12:09 <ski> ddarius : it seems to me that one prior here is more correct than the other -- maybe i'm confused, though
13:12:46 <ski> (or more accurately, i am confused, the question is to which degree, and about what)
13:13:24 <ddarius> ski: There is.  It's model selection.  You can choose the prior (which will include the model) that most accurately produces the outcome and also factor in the fact that more flexible models can match more things and thus are less compelling when they succeed (a form of Ockham's razor.)
13:14:17 <monochrom> which line is line 477?
13:14:40 <dankna> monochrom: oh, one sec
13:15:02 <dankna> the one labelled 264
13:16:03 <dankna> and thanks for even looking at it, I know it's a lot of code
13:16:40 <dankna> so what it's saying as I understand it is that it's expecting an outerContext there, but is getting an innerContext
13:16:56 <dankna> but I believe it should be expecting an innerContext, since action should be of type Deserializer innerContext a
13:17:44 <dankna> which means the continuation contained within action and returned by unDeserializer action should be of type (DeserializerState innerContext -> ...)
13:18:03 <ski> ddarius : hmm, ok
13:18:06 <dankna> now I would understand if it were to give me an error that the /result/ is of the wrong type
13:18:13 <dankna> but so far it's not even getting to that
13:18:35 <ddarius> Basically, you have data D, two hypothesis H1 and H2, other prior information I.  You simply want to know which is higher P(H1|D,I) or P(H2|D,I).  P(H1|D,I) = P(D|H1,I)P(H1|I)/P(D|I).  P(D|H1,I) is "given that H1 is correct, how well does it model the data."  P(H1|I) is "how much do I believe in H1."  And P(D|I) is "how much would I expect D to occur without making assumptions."
13:19:25 <monochrom> have you tried omitted the type signature of subDeserializer?
13:19:59 <dankna> hmm, I haven't.  let me try that.
13:20:15 <dankna> huh.  it? compiles without that signature.
13:20:20 <dankna> no warnings.
13:20:28 <monochrom> indeed a type sig of the form (MyType i -> MyType o) is fairly suspicious, especially if i,o turn out not to be just phantum types
13:20:40 <dankna> they're not just phantom types, yeah
13:20:50 <dankna> subDeserializer's job is to adapt between them
13:21:07 <dankna> which may turn out to not be possible, but if so I'd like to understand why not so I can figure out a workaround
13:21:37 <monochrom> there is enough free theorems that say you can't do that
13:21:41 <ddarius> (The more "flexible model stuff" is clearer when the hypothesis is explictily parameterized.
13:21:45 <ddarius> )
13:21:57 <dankna> in general, sure, but I have specific knowledge of the types here, don't I?
13:22:26 <dankna> it's like, I could write
13:22:45 <monochrom> "Deserializer innerContext a -> ... -> Deserializer outerContext a" has no knowledge
13:23:17 <dankna> (\maybeInt char = case maybeInt of { Nothing -> Nothing ; Just _ -> Just char }) :: Maybe Int -> Char -> Maybe Char
13:23:40 <dankna> now I do see that the difference is that I'm passing an innerContext not an outerContext
13:23:59 <dankna> but then I'm inside a continuation that takes the outerContext that's missing
13:25:29 <dankna> (the parameter overallOuterState on the line marked 205 is a DeserializerState outerContext, which contains an outerContext as one of its fields)
13:25:55 <ski> ddarius : hm, i probably have to think about that example, comparing with the examples given in AIMA -- (i can see how it follows from the laws, that's not a problem)
13:26:10 <dankna> are you saying that the type signature doesn't know that I'm going to do that?  if so, is there some way I can tell it, haha?
13:26:40 <dankna> I find it difficult to believe that the code I get by simply omitting the type signature is correct :)
13:26:48 <ddarius> ski: I would recommend the model selection (may be called something else) / parameter estimation sections of Jaynes' book.
13:27:16 <ski> ddarius : ty, will try to look up
13:27:17 <monochrom> I see. then some piece of code is pinning overallOuterState back to innercontext
13:27:26 <dankna> hmm
13:27:43 <dankna> oh, I think I might see it, then
13:27:51 <dankna> in computeInnerState I use record-update syntax on it
13:27:56 <dankna> I wasn't sure that would work
13:28:10 <dankna> perhaps it doesn't and I need to construct an entirely new record, copying the fields by hand
13:28:13 <dankna> let me try that
13:28:34 <monochrom> record-update syntax usually allows type change, actually. but you have to make sure nothing else gets in the way.
13:28:40 <dankna> hmmm okay
13:28:56 <erus`> > head $ fix ((++) [1])
13:28:57 <lambdabot>   1
13:29:16 <dankna> what if I put type signatures on computeOuterState and computeInnerState?  might I get more helpful errors then?  hmm
13:29:20 <monochrom> one way to get into the way: you update one field only, some other fields still pin the type.
13:29:30 <dankna> hmmm, let me see
13:29:32 <ion> > head (fix (1:))
13:29:33 <lambdabot>   1
13:30:04 <dankna> if you look at the definition of DeserializerState context above (line marked 39), it indeed only has the one field
13:30:07 <dankna> that depends on context
13:30:14 <tromp> @hoogle showIntAtBase
13:30:14 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
13:31:28 <dankna> okay different errors indeed, give me a moment to understand them
13:31:41 <dankna> (I can only write those type signatures because I'm using ScopedTypeVariables, of course)
13:33:41 <hpaste_> dankna annotated “subDeserializer no workie” with “subDeserializer no workie (annotation)” at http://hpaste.org/52293#a52294
13:33:52 <ski> monochrom : hm, i wonder whether any of the lens-like libraries support that kind of updating
13:34:14 <ClaudiusMaximus> needs more forall for the ScopedTypeVariabless ?
13:34:30 <dankna> ClaudiusMaximus, I thought of that but I confess to not understanding it quite.
13:34:31 <ski> i.e. the possibility to compose several "parallel" updates into a single one which, for type-checking purposes, have to all be done at the same time
13:35:08 <tromp> :t ord
13:35:09 <lambdabot> Char -> Int
13:35:14 <ClaudiusMaximus> line 10 is using a different type variable, because no forall on line 2 to activate the scoping extension
13:35:26 <dankna> oh!
13:35:37 <dankna> so I should just do forall innerContext outerContext a . blah blah blah?
13:35:45 <dankna> in the type signature on the whole function?
13:35:51 <monochrom> yes
13:35:57 <ClaudiusMaximus> i think so - i never used it much but that's what i gather from #haskell osmosis
13:36:01 <dankna> okay, good to have that confirmed
13:36:11 <dankna> I guessed at it earlier but because I wasn't sure I didn't pursue that line of investigation
13:36:19 <dankna> put that there, again a different error, absorbing the new one now
13:36:32 <shirt> how can i use cabal to build a binary .deb package?
13:36:39 <tromp> > ($ "") . (showIntAtBase 2 intToDigit) . ord $ '\n'
13:36:40 <lambdabot>   "1010"
13:37:30 <dcoutts> shirt: you can translate from a cabal package to a deb source package and then you build that in the usual way
13:37:42 <hpaste_> dankna annotated “subDeserializer no workie” with “subDeserializer no workie (annotation)” at http://hpaste.org/52293#a52295
13:37:53 <dankna> this looks a lot like the first error I was getting
13:38:05 <dankna> wait
13:38:15 <dcoutts> shirt: there are tools that can help automate the translation (though I think the ones available for .deb are the least automated of the distros)
13:38:59 <shirt> dcoutts: thanks. do you know the name of the tool?
13:39:11 <dcoutts> shirt: cabal2deb iirc
13:40:39 * DanBurton is bending his brain with covariance and contravariance in Scala. Not sure whether to praise Haskell for being easier, or to praise Scala for being more mathy-theoretical.
13:41:14 <tac-tics> Scala? MORE mathy?
13:41:36 <erus`> yey i have fix working in lambdurp IR code :D
13:41:37 <tac-tics> DanBurton: Haskell *would* have co/contra-variance if it had subtyping.
13:41:44 <erus`> lazy list building with fix
13:41:47 <tac-tics> I believe OCaml does
13:42:11 <dcoutts> and the co/contra thing more or less just goes away when objects are immutable
13:42:28 <shirt> dcoutts: awesomeness, thanks
13:42:31 <EvanR-work> cocontravariables is stupid
13:42:35 <EvanR-work> er variance
13:43:14 <monochrom> you mean like "a -> r -> r"? :)
13:43:18 <tac-tics> dcoutts: to some extent. I guess you don't have to annotate it, and it works intuitively (because co/contra-variance is pretty intuitive when you think about what it means)
13:43:29 <dankna> ah NOW we're getting somewhere.  I put in some more type signatures and got different errors.
13:43:33 <erus`> https://github.com/tm1rbrt/lambdurp source code
13:43:36 <tac-tics> EvanR-work: Coconut-variance?
13:44:10 <DanBurton> The explicit annotations were kinda annoying, but it was also rather educational. For those interested, here's the dumb little bit of Scala code I was working on: http://pastie.org/2657037
13:44:23 <tac-tics> erus`: cute. (But the prelude needs typing annotations! :D)
13:44:55 <ski> @where O'Haskell
13:44:56 <lambdabot> extension to Haskell adding subtyping and records, plus non-blocking reactive communication, by Johan Nordlander, Magnus Carlsson, and Bjrn von Sydow, at <http://web.archive.org/web/20090517021445/
13:44:56 <lambdabot> http://www.cs.chalmers.se/~nordland/ohaskell/>, also see `Timber'
13:44:58 <ski> @where Timber
13:44:58 <lambdabot> concurrent, reactive, event-driven language that was inspired by O'Haskell, <http://timber-lang.org/home.html>. also see `O'Haskell'
13:45:07 <ski> DanBurton : see those ^ before ?
13:45:41 <DanBurton> ski: heard of O'Haskell, that's about all though
13:46:49 <DanBurton> ski: trying to check out the ohaskell links. School blocks web.archive.org, and the cs.chalmers.se link is broken =/
13:50:01 <hpaste_> dankna annotated “subDeserializer no workie” with “subDeserializer no workie (annotation) (annotation)” at http://hpaste.org/52293#a52296
13:50:33 <dankna> the first error is the one I've been getting all along
13:50:43 <dankna> the second error sorta makes half-sense to me
13:51:02 <dankna> OH HEY
13:51:10 <DanBurton> hey?
13:51:12 <dankna> I wrote the type of the closure wrong in the definition of newtype
13:51:15 <ski> DanBurton : re subtyping, you might also be interested in looking at "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version in 2001 at <http://www.cs.ru.nl/E.Poll/papers/i
13:51:18 <dankna> s/a/r/ heh
13:51:41 <dankna> okay!  fixing that and now I've got some different and very interesting errors to chew on
13:51:55 <dankna> in fact all over the file
13:52:01 <monochrom> eh? what's Deserializer supposed to look?
13:52:18 <dankna> monochrom: looking at the original paste, line 13
13:52:23 <dankna> see that it says a there?  that should be r
13:52:38 <dankna> wait
13:52:38 <monochrom> hrm interesting
13:52:41 <dankna> maybe not
13:52:42 <dankna> hmm
13:52:48 <monochrom> no, it's "a" alright
13:53:09 <monochrom> at least it follows the spirit of CPS
13:53:11 <dankna> should that type signature even have an r in it?
13:53:26 <dankna> yeah, it's supposed to be CPS, but it's CPS-as-I-understand-it :)
13:54:35 <monochrom> this may be more complicated that CPS, but it has all the CPS essence, and most importantly the covariance and contravariance of all type variables are correct
13:54:40 <wavewave> hi.
13:54:54 <dankna> okay.  thank you for that.  (I have no idea what covariance and contravariance are, but I'm glad they're correct!  haha)
13:55:44 <dankna> yeah, it's CPS-plus-stuff, basically.  it's sorta Cont and State rolled together, with the added wrinkle that the run* functions actually recurse on the result, calling the continuation contained in it, until they get a final result.
13:56:02 <monochrom> for example the "answer type" "a" is supposed to be in the negative position (a -> blah), and you have done it. r is supposed to be both negative and positive (r -> r), and you have done it too.
13:56:15 <dankna> ah, yes, good
13:57:06 <monochrom> sorry, "a" is in double-negation position "(a -> r) -> r", and you have done it.
13:57:14 <dankna> er, yeah, indeed
13:57:50 <erus`> anyone got good docs for testing haskell code?
13:57:54 * DanBurton thinks monochrom is making stuff up now
13:57:57 <dankna> so is my problem that I can't write the wrapper (a -> r') -> (a -> r) ?
13:58:01 <erus`> any testing tools in the prelude?
13:58:04 <dankna> because of the r being forall'd?
13:58:45 <monochrom> I don't think that's disallowed
13:58:55 <wavewave> erus`: what do you mean by testing haskell code?
13:59:13 <erus`> like setting up a test suite
13:59:25 <dankna> ghc tests it.  it says "yep, that's Haskell code all right."
13:59:25 <wavewave> erus` : if you want to check some properties, try QuickCheck.
13:59:40 <dankna> there's experimental support for a test suite in cabal, but I believe it's not fully in place yet, so it probably would confuse you
14:00:21 <wavewave> erus` : in many cases, type checker reduces your work to make test-suites compared to other dynamically typed language.
14:00:22 <dcoutts> dankna: the basics work, it's only the "detailed" test suite type that's not ready
14:00:28 <dylukes> I have a sort of random "discussion" type question.
14:00:47 <dylukes> Applicative style is really nice, but what would people claim are its DISadvantages?
14:00:47 <dankna> dcoutts: oh!  okay, good to know.
14:00:49 <wavewave> dylukes: always welcom
14:01:03 <dylukes> In the same vein, pros are good too, if they're something non-obvious, I suppose :P.
14:01:19 <dankna> dcoutts: btw, consider this your monthly reminder regarding my patches that are prep work for the .app-building stuff
14:01:27 <wavewave> dylukes : maybe people complain it looks a little scary :-P
14:01:29 <dylukes> Just curious. I personally really like writing in applicative style. I don't think its inherently any more confusing or unclear than imperative style.
14:01:34 <dylukes> ^
14:01:56 <dylukes> But it's actually not too hard to read as a fold in your head :P.
14:02:09 * EvanR-work folds dylukes head
14:02:16 <dylukes> you fold up the applicative functor bits with the combinators and it all comes together.
14:02:17 <wavewave> dylukes : I think it's something like that once you know, it's great but it's very obscure before knowing it.
14:02:23 <dylukes> Yeah, definitely. :
14:02:25 <dcoutts> dankna: thanks :-), my current excuse is I had ICFP + holiday + lots of other cabal+hackage patches
14:02:36 <dylukes> dcoutts: theres a typo on the cabal site.
14:02:36 <wavewave> dylukes: monad is similar.
14:02:38 <dylukes> you're missing a period.
14:02:39 <dankna> dcoutts: I know, don't worry :) you don't owe me an excuse anyhow, it's your time, not mine
14:02:43 <dylukes> monad is easier.
14:02:54 <EvanR-work> monad is easier because of do notation
14:02:59 <dylukes> EvanR-work: ^
14:03:07 <dcoutts> dylukes: where?
14:03:09 <EvanR-work> wheres ap notation
14:03:37 <wavewave> dylukes : I personally find Applicative is easier in some sense.. but it's after I got used to it.. so it doesn't count.
14:03:47 <dylukes> http://www.haskell.org/cabal/
14:03:50 <dylukes> first sentence of the introduction
14:03:52 <dylukes> missing a period.
14:04:20 <erus`> @hoogle [m a] -> m a
14:04:21 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
14:04:21 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
14:04:21 <lambdabot> Data.IntMap unions :: [IntMap a] -> IntMap a
14:04:23 <wavewave> Applicative := monad without binding
14:04:29 <dcoutts> dylukes: ta
14:04:31 <dylukes> I just see applicatives as a way to structure control flow within a context.
14:04:46 <erus`> @hoogle m [a] -> m a
14:04:46 <lambdabot> Prelude concat :: [[a]] -> [a]
14:04:47 <lambdabot> Data.List concat :: [[a]] -> [a]
14:04:47 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
14:05:09 <dylukes> @hoogle m (m a) -> m a
14:05:10 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
14:05:10 <lambdabot> Prelude concat :: [[a]] -> [a]
14:05:10 <lambdabot> Data.List concat :: [[a]] -> [a]
14:05:10 <dylukes> :)
14:05:11 <erus`> @hoogle Monad m => m [a] -> m a
14:05:11 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
14:05:11 <lambdabot> Prelude concat :: [[a]] -> [a]
14:05:12 <lambdabot> Data.List concat :: [[a]] -> [a]
14:05:21 <dylukes> ~generalize
14:05:24 <ski> @type Control.Monad.ap
14:05:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:06:32 <wavewave> dylukes: I do not think it is particularly important to hear some people's opinion who did not understand Applicative yet when talking Applicative.
14:06:46 <ski> EvanR-work : i have some ideas about a notation that would simultaneously work for `Functor',`Applicative' and `Monad'
14:07:10 <dylukes> wavewave: No, maybe not important, but it can be interesting I suppose.
14:07:14 <dylukes> ski: ?
14:07:22 <wavewave> dylukes: idea is just propagating .
14:07:36 <tac-tics> What are the applicative functor laws?
14:07:36 <erus`> @hoogle (a -> m b) -> [a] -> (o m b)
14:07:36 <lambdabot> Data.Map update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
14:07:43 <erus`> i need a FindM
14:07:47 <erus`> findM*
14:08:16 <wavewave> dylukes: it's interesting in a sense that it's interesting to watch my old video. ;-)
14:08:20 <ion> I wonder why https://github.com/jepst/CloudHaskell doesn’t seem to be on Hackage?
14:08:26 <dylukes> ion: because it's incomplete
14:08:35 <dylukes> ion: it depends on hawkishness until static is in GHC.
14:08:38 <dylukes> hackishness*
14:08:42 <dylukes> plus its just a PoC
14:08:53 <dylukes> It also has some unfortunate naming conventions >_>...
14:09:11 <ion> Yeah, every other package on Hackage is fully complete indeed. ;-)
14:09:16 <EvanR-work> ski: wondering what notation there could be for functor
14:09:17 <ski> dylukes : i haven't decided on the *concrete* syntax, but i have the abstract syntax mostly worked out, together with type system rules, plus implementation
14:09:27 <dylukes> ski: Explain what you mean though?
14:09:35 <dylukes> ion: oh well, pull it from github, so hard :P
14:09:45 <dylukes> brb snack
14:09:58 <little_zanooda> hello, i extensivly use amazon's web services, usually i use boto (python module) to write my cloud scripts, does haskell have anything for amazon ec2?
14:10:26 <ski> EvanR-work,dylukes : well, it's a kind of "quote & unquote" syntax -- have any of you seen how quasi-quotation works in the Lisps ?
14:10:33 <wavewave> little_zanooda: you can just install ghc there, I guess.
14:10:37 <EvanR-work> not i
14:10:44 <dylukes> ski: yeah, sure
14:10:50 <dylukes> commas, apostrophes, etc
14:10:56 <little_zanooda> wavewave: I guess u misunderstood my question
14:10:59 <dylukes> is that what you mean?
14:11:06 <ski> yes
14:11:09 <dylukes> k
14:11:30 <erus`> @src Find
14:11:31 <lambdabot> Source not found. My mind is going. I can feel it.
14:11:35 <erus`> @src find
14:11:35 <lambdabot> find p          = listToMaybe . filter p
14:11:41 <ski> so, i'll use that syntax for explaining (actually using that syntax would clash with other syntax in Haskell, i think)
14:11:43 <little_zanooda> wavewave: u know pythons boto module? it is a module to remotely connect to your cloud (amazon aws) and perfrom scripted actions
14:11:43 <wavewave> little_zanooda: it seems so ;-). could you elaborate a little bit of your use case? ;-)
14:12:12 <dylukes> ski: well, feel free to just replace the symbols
14:12:14 <erus`> @src listToMaybe
14:12:14 <lambdabot> listToMaybe []        =  Nothing
14:12:15 <lambdabot> listToMaybe (a:_)     =  Just a
14:12:15 <ski> so, a simplistic example
14:12:15 <dylukes> I think I can follow.
14:12:26 <ski>   data Person = MkP Name Age
14:12:36 <ski>   parseName :: Parser Name
14:12:46 <wavewave> little_zanooda: you probably want to see some recent work on CloudHaskell.
14:12:47 <ski>   parseAge :: Parser Age
14:12:54 <dylukes> I think I see where this is going.
14:12:56 <ski>   parsePerson :: Parser Person
14:13:14 <dylukes> You want parsePerson = ,MkP 'parseName 'parseAge
14:13:16 <ski>   parsePerson = `(MkP ,parseAge ,parseName)
14:13:23 <wavewave> little_zanooda: boto looks very specific to Amazon.. I am not aware of any haskell equivalent.
14:13:23 <dylukes> :P
14:13:25 <little_zanooda> wavewave: is it related to amazon aws?
14:13:30 <dylukes> well, we switched the symbols, but...
14:13:40 <leod> is that.. lisp haskell?
14:13:45 <ski> now, how does this get typed, you may ask ?
14:13:47 <dylukes> so, that translates to
14:13:53 <ion> So annoying. There seems to be no complete implementation of Erlang-like process supervision and messaging for Haskell and there seems to be no reliable ways to have the Erlang supervisor supervise a system process while having an interface for its stdin and stdout via message passing (Haskell would make the system process stuff considerably less painful as it has lower-level interfaces for the OS stuff).
14:13:54 <dylukes> MkP <$> parseAge <*> parseName
14:14:01 <wavewave> little_zanooda : not really. though first targetting platform may be amazon.
14:14:03 <ski> yes, basically
14:14:09 <ski> it types as
14:14:29 <ski>   parseName :: Parser Name
14:14:44 <little_zanooda> wavewave: I hope so .. haskell people should do something like it.. there are ones for python, php, .net, java, and many other languages..
14:14:59 <wavewave> little_zanooda: I found aws package on hackage BTW.
14:15:08 <ski>   ,parseName :: Name  -- with `Parser', side-effects ! (these should be present in the formal type, just not in the usual way with monads)
14:15:11 <wavewave> @google aws
14:15:12 <lambdabot> http://www.aws.org/
14:15:13 <lambdabot> Title: American Welding Society (AWS) - Home Page
14:15:16 <ski>   parseAge :: Parser Age
14:15:16 <wavewave> hmm
14:15:19 <dylukes> ion: I've been trying to write an OTP-alike, but i haven't had time right now.
14:15:20 <wavewave> @hackage aws
14:15:20 <lambdabot> http://hackage.haskell.org/package/aws
14:15:30 <ski>   ,parseAge :: Age  -- with `Parser'-side-effects
14:15:41 <ski>   MkP :: Name -> Age -> Person
14:15:52 <wavewave> little_zanooda: is it an answer to you?
14:15:56 <dylukes> if you see it as "Parser" being a "class of side effects"
14:15:57 <ski>   MkP ,parseName :: Age -> Person  -- with `Parser'-side-effects
14:16:04 <dylukes> then really you could write your types nicely as
14:16:09 <ski>   MkP ,parseName ,parseAge :: Person  -- with `Parser'-side-effects
14:16:18 <dylukes> Parser => ,parseAge :: Age
14:16:19 <ski>   `(MkP ,parseName ,parseAge) :: Parser Person
14:16:19 <dylukes> or something
14:16:20 <little_zanooda> wavewave: seeems ya! :D
14:16:35 <little_zanooda> wavewave: Let me check it! :)
14:16:37 <Cale> er, someone highlighted me here, but apparently my scrollback isn't large enough
14:16:43 <wavewave> little_zanooda: good to help you using my googling skill ! :-D
14:16:53 <dylukes> ski: you could do a mechanical translation to applicative style probably
14:17:13 <little_zanooda> wavewave: hahaha ya i guess i did not do my homework :p
14:17:16 <ski> dylukes : yeah, i haven't decided exactly how to notate this, but there can't be more than one of these "side-effect" annotations on a signature
14:17:28 <ddarius> Cale: It was probably an elegant proof of Riemann's Hypothesis.
14:17:31 <ski> (though they may be nested, of course, as in monad transformers)
14:17:37 <wavewave> little_zanooda: nono.. I am just happy to help you.
14:17:39 <dylukes> ski: Really all you're doing is lifting the context up. :\
14:17:43 <dylukes> out of the type signature.
14:17:56 <wavewave> good to know aws for me, too.
14:17:56 <little_zanooda> wavewave: k thanks ^_^
14:18:00 <dylukes> what would cases like
14:18:08 <dylukes> parseReserved :: String -> Parser Reserved
14:18:14 <dylukes> ,parseReserved :: ?
14:18:16 <ski> dylukes : btw, note that a very important property in my design is that all side-effects are *lexically* apparent
14:18:31 <monochrom> Cale: [10:32:07] <kmc> i think Cale's "Introduction to IO" document lays out the model of IO actions in a simple way that's accessible to beginners
14:18:36 <ski> dylukes : i.e., it's still impossible to define side-effectful operations
14:18:42 <Cale> ah, thanks monochrom :)
14:19:08 <dylukes> ski: try implementing a translation to applicative style in a haskell quasiquote :P?
14:19:26 <ski> dylukes : i'm only weakening the system by allowing side-effectful *expressions* .. and you can always tell by a glance at such a one whether it might be side-effectful or not (i.e. does it contain an unquote or not)
14:19:37 <monochrom> 10 hours later, kmc will ask "who invoked me" and I will paste that again. another 10 hours later, it will be Cale's turn... ad infinitum
14:19:40 <ski> dylukes : i already have a translation (on paper)
14:19:54 <dylukes> , :: (f a) -> a -- with ctx f
14:20:10 <ski> dylukes : it was inspired by an idiom/applicative paper, by ross paterson and someone else
14:20:16 <dylukes> you're basically saying "any expression can have a context associated with it"
14:20:25 <dylukes> "within the scope of '"
14:20:33 <ski> dylukes : but my syntax is better than their "idiom brackets", and *also* handles monads :)
14:20:34 <dylukes> and , is the operator that lifts a functor to context
14:20:38 <Cale> ddarius: More likely someone asking how zeta(s) = sum over n >= 1 of n^(-s) has any zeroes at all
14:20:57 <dylukes> then,
14:21:06 <dylukes> ' :: a {-with ctx f -} -> f a
14:21:11 <dylukes> see where I'm getting here?
14:21:17 <monochrom> how do I prove Riemann thesis with IO?
14:21:19 <ski> dylukes : e.g.  `let a = ,ma in ,(amb a)  translates to  do a <- ma; amb a
14:21:26 <dylukes> the fact that it's 'a -- with ctx f'
14:21:29 <dylukes> is irrelevant
14:21:37 <dylukes> you could implement this in pure haskell I think
14:21:42 <dylukes> as operators.
14:21:57 <Cale> `___, HAY GUYS
14:22:10 <dylukes> you'd have to lift the constructor too.
14:22:18 <dylukes> :\
14:22:41 <ski> dylukes :  ,parseReserved  would be incorrect (well, unless you have an `(String ->)' `Functor'/`Applicative'/`Monad' in scope :)
14:23:24 <ski> monochrom : "10 hours later ..." hahahah !
14:23:27 <dylukes> then this is somewhat like my ~> impure arrow idea.
14:23:40 <dylukes> its less general and has "special rules" for usage within the type signautre
14:23:46 <dylukes> in the end that might detract from the value :\
14:24:00 <Cale> `___, I`M MR ,QUASIDERP
14:24:08 <dylukes> Cale: oh shut it :P
14:24:11 <monochrom> is Cale alright?
14:24:13 <ski> dylukes : also  ' :: a {-with ctx f -} -> f a  is incorrect, as this is a syntactic construction, not a function value
14:24:17 <wavewave> is haskell-platform 2011.2.0.1 compilable using ghc-7.2.1?
14:24:19 <Cale> hehe, I'm fine
14:24:30 <dylukes> ski: idk if it needs to be a syntactic construction :\]
14:24:31 <dylukes> :\*
14:24:53 <dylukes> well, good luck anyways
14:24:57 <dylukes> try to do it in template haskell
14:25:00 <dylukes> see how it turns out
14:25:28 <wavewave> just finished building ghc-7.2 on my machine.
14:25:31 <ski> dylukes : btw, note that   `(foo ,(bar :: Maybe Bar) ,(baz :: IO Baz))  would be a type error
14:25:47 <Cale> wavewave: What kind of machine? Why'd you have to compile it yourself?
14:26:21 <ski> dylukes : hm, one might be able to have a type construction like `a {-with ctx f -}'  but i'm not sure i'd want to do that
14:26:22 <wavewave> Cale: it's old machine, glibc is too old so binary cannot be installed.
14:27:03 <wavewave> I guess it's RHEL5.
14:27:09 <ski> dylukes : i suspect that would violate my principle of always being able to tell by inspecting an expression whether it is side-effectful (by checking for unquotes)
14:27:48 <dylukes> also,
14:27:55 <dylukes> what if I want to parse something like "x = y" as a binding
14:28:13 <ski> how do you mean ?
14:28:24 <dylukes> parseBinding = Binding <$> parseIdentifier <* parseSymbol "=" <*> parseIdentifier
14:28:50 <dylukes> how would you write that in your syntax nicely?
14:28:51 <ski> dylukes : btw, i haven't seen/heard your "~> impure arrow idea" .. any link ?
14:28:59 <dylukes> no, it was just a thought a few months back.
14:29:13 <dylukes> a ~> b  => a -> IO b
14:29:14 <dylukes> essentially
14:29:37 <dylukes> Doesn't account for i.e read :: IO a
14:29:41 <dylukes> you'd need to go ML style
14:29:47 <dylukes> read :: () ~> IO a
14:29:51 <dylukes> er read :: () ~> a
14:30:14 <benmachine> dylukes: how is it used?
14:30:15 <rata_> do you know how I can impose a class constrain in a type synonim?
14:30:29 <benmachine> presumably it's "infectious"
14:31:07 <ddarius> ski: Have you looked at Disciple?
14:31:22 <wavewave> hmm haskell-platform just requires ghc-7.0.3.. okay...
14:31:23 <ski>   parseBinding = `(Binding (const ,parseIdentifier ,(parseSymbol "=")) ,parseIdentifier)  -- is one way
14:31:34 <rata_> I mean, I'd like to have something like "type myType typeVar = typeVar -> [typeVar]" and typeVar must be an instance of class Num for example
14:31:39 <dylukes> benmachine: that was the thought ,kinda.
14:31:44 <ddarius> ski: How do you handle writeIORef and such?
14:31:56 <wavewave> now question is what is the best way of installing cabal-install without haskell-platform.
14:31:56 <ski>   parseBinding = `(Binding ,parseIdentifier (flip const ,(parseSymbol "=") ,parseIdentifier))  -- is another
14:31:59 <dylukes> ski: That's not much cleaner than just using applicative combinators.
14:32:00 <dylukes> :P
14:32:14 <ski> ddarius : i haven't looked at Disciple, though i keep meaning to
14:32:22 <dylukes> (const ,a ,b) is just a *> b
14:32:23 <dylukes> :\
14:32:28 <dylukes> its longer and less clear too.
14:32:45 <dylukes> er, (const ,b ,a) is a *> b
14:32:58 <dafis> wavewave: download the appropriate .tar.gz from hackage, unpack it and run ./bootstrap.sh in the directory
14:33:18 <ski> ddarius : i don't handle `writeIORef' in any special way -- this is not a fine-grained effect system, it's just another surface syntax (with relatively thin translatation) on the `Functor',`Applicative',`Monad' system we all know
14:33:35 <wavewave> dafis: yes. thanks.
14:34:10 <ddarius> I figured, and anyway that's the "right" thing to do.
14:34:10 <ski>   parseBinding = `((Binding ,parseIdentifier `const` ,(parseSymbol "=")) ,parseIdentifier))  -- is yet another
14:34:42 <dylukes> I'm not really seeing the benefit :\
14:34:54 <dylukes> like, I could accomplish the same thing by lifting Binding
14:34:59 <ski>   parseBinding = `(Binding ,parseIdentifier $| ,(parseSymbol "=")) $ ,parseIdentifier))  -- might work, if we defined `$|' with the right precedence
14:35:16 <hpaste_> erus` pasted “help plox” at http://hpaste.org/52297
14:35:46 <erus`> ignore that liftM
14:35:54 <erus`> i put that in just to test
14:35:58 <dylukes> liftA2 Binding $ (parseIdentifier) (parseSymbol "=" `seq` parseIdentifier)
14:36:05 <dylukes> ion: wouldn't this be just as good?
14:36:11 <dylukes> liftA2 is having the same effect
14:36:24 <dylukes> except inverted
14:37:03 <acowley> I'm fighting with Arrows, how can I get the behavior of "f <$> a <*> b <*> c" ?
14:37:05 <ski> dylukes : btw, i've pondered a "maximal eat" variant instead, which would have it like  parseBinding = [> Binding ([< parseIdentifier) $| ([< parseSymbol "=") $ ([< parseIdentifier)  -- i'm not sure whether you like that variant better
14:37:19 <dylukes> ski: ML strikes again :P?
14:37:34 <dylukes> Im just not seeing this syntax as... better.
14:37:40 <ski> dylukes : but yes, one would have to ponder the case of doing a side-effect while ignoring the result more
14:38:01 <dylukes> brb
14:38:04 <ski> dylukes : imagine a large expression with a few sub-expressions having unquotes
14:38:25 <dylukes> I would take those sub expressions out into their own function.
14:38:33 <dylukes> I generally don't like letting large expressions accumulate :3
14:38:34 <dylukes> brb
14:39:11 <ski> dylukes : with the current `liftA',&c. and `(<*>)' approach, you would need to make sure the whole path down to the subexpression used those (while not needing to use them in the "pure" part)
14:39:47 <ski> dylukes : otoh, with my version, you only need to insert unquotes at the exact spots where you want to have a side-effect, as opposed to annotating the whole path down to it
14:40:04 <erus`> get yer free karma http://stackoverflow.com/questions/7693137/is-this-function-possible
14:40:46 <ski> dylukes : this is more robust in that if you need to add side-effects to another part of the expression, you don't have to do anything more than just add it wherever you wanted it
14:41:19 <acowley> erus`: shouldn't that return type be m (Maybe a) instead?
14:42:25 <ski> dylukes : btw, i'm not claiming this would be superior to the traditional `liftM' and `(<*>)' style all the time -- but i do think it would be worthwhile to try it out, to better appreciate the trade-offs
14:43:18 <dylukes> sure I s'pose.
14:43:23 <dylukes> try TH'ing it then!
14:43:27 <dylukes> or better yet!
14:43:45 <dylukes> use Generics somehow :P
14:44:03 <alpounet> cabal-dev saved the day, yay
14:44:12 <ski> dylukes : btw, you might like  `case ,getChar of '\n' -> (); c -> ,(foo c)  things, instead of the tedious  getChar >>= \x -> case x of '\n' -> return (); c -> foo x
14:44:34 <dafis> erus`: what acowley said, going from IO [a] to Maybe (IO a) for example must use the unspeakable or be trivial
14:44:43 <dylukes> I usually use where clauses and try to make meaningful functions from the clauses.
14:44:44 <dylukes> :P
14:44:53 <dylukes> from the cases*
14:45:08 <erus`> ah ok
14:46:49 <ski> sure, i try to do that as well, but sometimes no natural name&semantics suggests itself for such "throw-away functions", and then one should be able to write it inline in the expression, with as little hassle as possible
14:48:22 * ski should probably try to do this in TH (even though he wants a prefix syntax, not a delimiter at each side)
14:48:39 <acowley> Because nobody suggested anything better, I have now manually defined arr9: an insidious thing whose type is the shame of my whole village.
14:48:54 <ski> last time i pondered this idea, i was trying to figure out how to make this work nicely together with monad transformers, as well
14:48:57 <mononofu_> is there a way to enter numbers in binary? (eg 1010101 )
14:49:03 <mononofu_> like 0xAF for hex
14:49:04 <dylukes> usually when they're throw away functions it works better to just use a transformer or functor or something
14:49:42 <dylukes> i.e if its just a case, EitherT works
14:49:43 <dylukes> etc
14:50:02 <benmachine> so guys, how should idiom brackets work with operator sections?
14:50:05 <Ferdirand> mononofu_: well you can learn the hex<->binary table by heart
14:50:17 <ion> dylukes: Was this message meant for me? < dylukes> ion: wouldn't this be just as good?
14:50:36 <mononofu_> well, I wanted to check if I made mistakes in doing it by hand ^^
14:51:11 <dylukes> ?
14:51:13 <mononofu_> you know, start of computer science course, calculate in binary, conversions, etc
14:51:20 <dylukes> dunno I need to go do homework
14:52:36 <ClaudiusMaximus> :t readInt
14:52:37 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
14:53:19 <sqrtI> hello. can i use "let" or "where" in a lambda function?
14:53:27 <simon> yes
14:53:49 <sqrtI> simon: both?
14:54:06 <simon> I think so...
14:54:10 <sqrtI> ok. thank you, simon.
14:54:20 <rwbarton> you can't use "where" like this: \x -> y where y = x * x
14:54:32 <sqrtI> rwbarton: why not?
14:54:43 <ClaudiusMaximus> 'where' attaches to definitions (things with an '='), let is an expression
14:54:47 <ddarius> where is part of the syntax of function declarations.  It is not an expression form.4
14:54:53 <ion> > let f = \x -> y where y = 42 in f "foo"
14:54:53 <lambdabot>   42
14:55:11 <rwbarton> > let f = (\x -> y where y = 42) in f "foo"
14:55:11 <lambdabot>   <no location info>: parse error on input `where'
14:55:18 <ion> > let f = (\x -> y) where y = 42 in f "foo"
14:55:19 <lambdabot>   42
14:55:57 <acowley> Well, after almost being convinced that arrows are okay, I'm now back to being mildly against them. HXT forces the issue, and the warm fuzzies from first getting used to it have faded to a dull mental bruise.
14:56:16 <sqrtI> thanks, guys
14:56:54 <ski> mononofu_ : hm, there's `readDec',`readHex',`readOct' (and `showHex',`showOct'), but no `readBin' (or `showBin')
14:57:00 <ski> > (readInt 2 (\c -> '0' <= c && c <= '1') digitToInt :: ReadS Integer) "01101101"
14:57:01 <lambdabot>   [(109,"")]
14:57:07 <ski> mononofu_ : ^ works ..
14:57:14 <ddarius> ski: Don't want to make homework -too- easy.
14:57:43 * hackagebot cereal-enumerator 0.3.1 - Deserialize things with cereal and enumerator  http://hackage.haskell.org/package/cereal-enumerator-0.3.1 (PatrickPalka)
14:57:58 <mononofu_> ddarius: haha, don't worry about homework being a problem
14:58:05 * ski didn't notice any course mention until now
14:58:08 <mononofu_> ddarius: after all, this is the haskell channel ;)
14:58:48 * ski ponders the mysterious lack of a `showDec'
14:59:36 <mononofu_> ski: showIntAtBase 10 ;)
15:00:15 <ski> yeah, i know there's that -- that doesn't explain the hole, though
15:00:18 <sqrtI> can i do: `(\x->(f x a, g x a) where a = h x)' ?  it doesnt seem so…
15:00:36 <ski> you can't
15:00:40 <sqrtI> argh
15:00:48 <mononofu_> well, dec is the default, so no need for any function
15:01:05 <ski> you can do `\x -> let a = h x in (f x a, g x a)', however
15:01:14 <ski> mononofu_ : but why is there a `readDec', in that case ?
15:01:23 <mononofu_> hm, good question
15:02:38 <ski>   \x -> (f x &&& g x) (h x)
15:03:20 <dafis> > (\x -> case x of { y -> f a y } where { a = h y; f  = (+); h = (*2); }) 4
15:03:21 <lambdabot>   <no location info>: parse error on input `where'
15:03:28 <ion> @pl \x -> (f x &&& g x) (h x)
15:03:28 <lambdabot> ap (liftM2 (&&&) f g) h
15:03:42 <ion> liftA2 (&&&) f g <*> h ;-)
15:04:17 <dafis> > (\x -> case x of { y -> f a y  where { a = h y; f  = (+); h = (*2); }}) 4
15:04:18 <lambdabot>   12
15:04:49 <ski>   (uncurry (&&&) . (f &&& g)) <$> id <*> h
15:05:45 <simon> how is it you make lambdabot give :t results
15:05:54 <ski> you type
15:05:56 <simon> > :t (&&&)
15:05:57 <lambdabot>   <no location info>: parse error on input `:'
15:06:01 <ski> @type undefined
15:06:01 <ion> :t (&&&)
15:06:01 <lambdabot> forall a. a
15:06:02 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:06:06 <dafis> :t (&&&)
15:06:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:06:08 <dylukes> or just :t (&&&)
15:06:12 <simon> oh.
15:06:20 <dafis> @ty (&&&)
15:06:20 <dylukes> This simon doesn't know nearly as much as the others.
15:06:21 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:06:22 <ski> also, for some reason `:t' doesn't work in PRIVMSG
15:06:23 <dylukes> :\
15:06:40 <ddarius> ski: Yes, lambdabot has been like that forever.
15:06:40 * ski always uses `@type' anyway ..
15:06:46 * ski knows
15:06:49 <schell> hi guys - can someone describe how side effects (like rendering graphics) happen in haskell?
15:07:15 <joevandyk> When is the haskell platform going to be updated so OS X doesn't spit out a zillion "ld: warning: text reloc" warnings?
15:07:32 <JoeyA> > putStrLn "<IO ()>"
15:07:33 <lambdabot>   <IO ()>
15:07:34 <dylukes> https://gist.github.com/1169332
15:07:39 <ski> schell : side-effects don't happen in haskell, period
15:07:41 <Twey> schell: They don't — they happen outside Haskell (the language) in the Haskell runtime
15:07:59 <ski> schell : however, *effects* may happen :) (there's an important distinction)
15:08:27 <schell> huh, okay. interesting
15:08:32 <JoeyA> Is it possible to install MSYS and have it point to the MinGW distributed with Haskell Platform?
15:08:32 <dafis> joevandyk: I think I saw a patch to get rid of the text_reloc warnings the other day, so it may be soon
15:08:57 <ski> schell : side-effects is roughly any deviation from an expression evaluating to a single result
15:09:15 <ddarius> ski is making up his own terminology here
15:09:33 <JoeyA> schell: main is a value of type IO ().  Values are bound together with the >>= operator (underneath all the layers of conveniece you will normally be using)
15:09:41 <JoeyA> Err, actions are bound together.
15:09:46 * ski has been doing that in this case for a long time
15:09:48 <JoeyA> getLine >>= putStrLn
15:09:53 <hpaste_> erus` pasted “refactor tips please” at http://hpaste.org/52298
15:10:06 <JoeyA> This returns an action that gets a line, then prints it.
15:10:15 <ski> (but i find it consistent with talk in papers on effect systems e.g.)
15:10:17 <ddarius> ski: I agree you've been making up your own terminology in this case for a long time.
15:10:20 <schell> ok
15:10:21 <JoeyA> getLine >>= (\x -> putStrLn x >> putStrLn x)
15:10:28 <JoeyA> That gets a line and prints it twice.
15:10:31 <ciaranm> ski: if you call things deviatiomorphisms then people won't notice
15:10:39 <dafis> joevandyk: http://hackage.haskell.org/trac/ghc/changeset/20705dff179ed09f37a7db474109cccef6f9afec
15:11:08 <ciaranm> ski: you can also try "zygo", and sticking "co" in front of everything
15:11:18 <ski> schell : so if an expression is depending on state which may change, that is a side-effect, just as changing state, or throwing exceptions, or jumping around with continuations are a side-effect
15:11:26 <joevandyk> dafis: woohoo
15:11:42 <JoeyA> Although a program consists of actions bound together, pure Haskell code gets to say what will happen next, thanks to the >>= operator letting it do that.
15:11:46 <ski> schell : but note that this only holds if the effects aren't declared as part of the *type* of the expression
15:11:50 <erus`> oo i think i found a hlint bug
15:12:00 <ski> ddarius : *nod*
15:12:32 <ciaranm> ski: but what you call side effects are iso to effects plus a larger return type, no?
15:12:55 <JoeyA> So although Haskell code isn't effectful per se, it gets to pull the strings.
15:13:08 <ski> schell : anyway, e.g. `getChar :: IO Char', is not *side*-effectful, because it's declaring upfront in the type that it will perform I/O when executed
15:13:21 <roconnor> I've noticed that functional languages seem to be very good at giving a high-level definition that includes cross cutting concerns to produce a low level executable: Haskell produces an IO tree, Nix produces a build derivation, etc.
15:13:24 <ciaranm> that's not what IO means!
15:13:43 <ski> schell : there's no way to write a function `IO a -> a' that gives the "result" of the action, btw
15:13:50 <dafis> erus`: that it suggests fmap and not liftM?
15:13:50 <sqrtI> ski: thanks again and again. =)  my code now worx :)
15:14:10 <ski> schell : also, note that there's an important difference between "evaluation of expressions" and "execution of actions"
15:14:29 <schell> okay, i think i need more depth on the definition of an action
15:14:49 <schell> i haven't reached the IO portion of learnyouahaskell
15:14:55 <ddarius> something whose type is of the form IO A for some A.
15:15:02 <schell> just thinking past my skill level
15:15:08 <ski> ciaranm : indeed, whether you have side-effects or not depends on the syntax you use (unsurprisingly, since we all know GHC for a long time compiled via C)
15:15:26 <JoeyA> let x = slapSchnellWithATrout
15:15:32 <JoeyA> That line of code won't actually do anything.
15:15:37 <schell> ddarius: right, that makes sense
15:15:39 <ski> ciaranm : i'm occasionally sticking "co" in front of things, yes :)
15:15:55 <JoeyA> But it's an action that, *if you executed it*, would not be very comfortable.
15:16:09 <JoeyA> It gets executed if you bind it to main.
15:16:14 <schell> JoeyA: thank god it doesn't actually do anything
15:16:15 * ddarius calls ski "cocoski" to give his name a more Russian ring to it.
15:16:29 <JoeyA> e.g. main = slapSchnellWithATrout -- running the program will do it
15:17:01 <ski> ciaranm : "that's not what IO means!" -- was that re what i said ?
15:17:14 <schell> so is all IO bound to main in one way or another?
15:17:23 <JoeyA> If executed, yes.
15:17:25 <ddarius> Anything that gets executed is, yes.
15:17:30 <ddarius> Modulo evilness.
15:17:31 <ciaranm> ski: yup. although that can be yelled at anyone really.
15:17:35 <ski> (ddarius : hehe :)
15:17:41 <ion> > let foo = putStrLn "not bound to main" in 42
15:17:42 <lambdabot>   42
15:17:49 <ski> ciaranm : well, what did you want to complain about, then ?
15:18:28 <schell> cool, thanks - i'm going to keep reading ;)
15:18:51 <ciaranm> ski: it doesn't mean it'll perform IO. it means it can be strung together in an IO-like way.
15:18:51 <ski> (ciaranm : hm, that might have come across as accusing you of whining -- i intended nothing of the sort)
15:19:16 <ski> ciaranm : it means it will perform `IO'-effects, when *executed*
15:19:42 <ciaranm> ski: but you can have stuff -> IO blah that doesn't do any IO at all
15:20:11 <ski> ciaranm : just as `natural :: Parser Integer' means it will perform `Parser'-effects when executed, and `"hello" :: [Char]' means it will perform `[]'-effects when executed
15:20:50 <ski> ciaranm : sure, included in `m'-effects are always the trivial effect of doing nothing (but yielding an answer)
15:21:28 <ciaranm> "IO" is a really misleading name
15:21:41 <ski> i agree with that
15:21:55 <ski> it's a sin-bin of various different things, all tucked together
15:22:03 <ski> (ask conal about it)
15:22:21 <benmachine> it should be renamed "Magic"
15:22:40 <ciaranm> who's conal? is it nal on opposites day?
15:22:45 <ski> it's not really any more magic than `Integer' or `Float' or `(->)' is
15:23:02 <tac-tics> Int is pretty magical in GHC
15:23:03 <ddarius> It should be named "NotMagic"
15:23:11 <tac-tics> With all them boxings and unboxings
15:23:15 <ski> Conal Elliott <http://conal.net/blog>
15:23:28 <ski> preflex: xseen conal
15:23:28 <preflex>  conal was last seen on freenode/#haskell 1 day, 11 minutes and 9 seconds ago, saying: i mean *the accurate* explanation.
15:23:34 <sqrtI> how can i do sth like "main = do when (a==b) (putStrLn "hello world"; exitSuccess)" ?
15:23:50 <sqrtI> (sorry for those stupid questions…)
15:23:53 <ddarius> Replace ; with >>
15:24:00 <sqrtI> okay, thanks
15:24:21 <nooodl> why is "fmap (*2) (Left 3)" not "Left 6"?
15:24:25 <ski> sqrtI : *or* add `do' in front of `putStrLn'
15:24:51 <sqrtI> ski: a "do" "loop" in a "do" "loop" ?? cool!
15:25:00 <ski>   main = when (a == b) $ do
15:25:03 <ski>     putStrLn "hello world"
15:25:04 <ski>     exitSuccess
15:25:41 <ski> sqrtI : s/loop/block (or expression)/
15:25:58 <sqrtI> oh, yes
15:26:48 <ciaranm> nooodl: Either is a functor on its right parameter, not its left (as is everything else that looks like Either)
15:26:52 <ski> `do' introduces a "flat" sequence of commands, terminated by an expression -- it doesn't nest by itself
15:26:56 <ClaudiusMaximus> nooodl: because Functor (Either l)  makes   fmap :: (r -> r') -> Either l r -> Either l r'  -- so there's no way to change the values inside Left
15:27:47 <ski> so you'll need to use `do' again if you are using `case' or `if' (or indeed, a custom function like `when'), if you want to have commands inside them
15:27:58 <nooodl> oh. that makes sense
15:28:25 <ciaranm> nooodl: think about what happens if you have an Either String Int and try to fmap an Int -> Int onto it
15:28:27 <sqrtI> ski: thanks :)
15:28:31 <nooodl> yeah
15:28:37 <ski> one could imagine this being lifted a bit, but this is the way it is, currently
15:28:41 <ion> nooodl: Profunctor has lmap for that.
15:29:29 <ion> Oh, wait. I don’t think it has after all.
15:29:32 <nooodl> hmm, maybe a function :: (l -> l') -> (r -> r') -> Either l r -> Either l' r' -- would be nice
15:29:35 <ion> I misread the type.
15:29:50 <ddarius> That's usually called bimap.
15:29:54 <ski> sqrtI : btw, you do not need to apologize for asking typical newbie questions
15:30:18 <ddarius> But you could spice things up by asking atypical newbie questions.
15:30:39 <ddarius> ion: But then you start to get into a whole world of different variances.
15:32:07 <nooodl> @hoogle bimap
15:32:07 <lambdabot> No results found
15:32:14 <ion> @type \l r -> either (Left . l) (Right . r)
15:32:15 <lambdabot> forall a b a1 b1. (a1 -> a) -> (b1 -> b) -> Either a1 b1 -> Either a b
15:32:28 <sqrtI> ski: hehe, ok =)
15:32:38 <ski> (however, if you had asked a question about how to do something ill-adviced (in your situation) instead of asking a more general question about how to do what you're *really* trying to accomplish, and *then* getting nasty about arnings and/or attempts to figure out what you really wanted to do, *then* you ought to apologize ;)
15:33:03 <ion> Relevant: http://mywiki.wooledge.org/XyProblem
15:33:04 <ski> (apropos nothing :)
15:33:07 <sqrtI> :)
15:33:09 <ddarius> No, you just ought not do that.
15:33:38 <ski> ddarius : that too, yes
15:34:23 <tac-tics> Why is there IRC drama today in #haskell
15:34:43 <ciaranm> there is?
15:34:54 <tac-tics> the xy problem has come up twice
15:35:09 <lambdanaut> let x = [ [1,2,3],[4,5,6],[9,8,7] ]; let result = map (map (+1) x
15:35:11 <ski> @type curry (uncurry either . ((Left .) *** (Right .)))
15:35:12 <lambdabot> forall a b a1 a2. (a -> a1) -> (b -> a2) -> Either a b -> Either a1 a2
15:35:14 <ion> I don’t think anyone was guilty of it now.
15:35:21 <lambdanaut> is this a good way to do mappings over 2dimensional lists?
15:35:27 <lambdanaut> just double map em?
15:35:48 <ski> tac-tics : oh, noone overstepped here, i just recalled the earlier discussion
15:36:05 <tac-tics> kk
15:36:07 <ski> lambdanaut : sure
15:36:19 <ciaranm> lambdanaut: depends upon how you're defining mappings
15:36:23 <ion> > (+1) .: [ [1,2,3],[4,5,6],[9,8,7] ]
15:36:24 <lambdabot>   [[2,3,4],[5,6,7],[10,9,8]]
15:36:31 <ski> lambdanaut : or `(map . map) (+ 1) x' if you think that's nicer
15:36:42 <lambdanaut> Oh yes that looks much nicer
15:36:43 <lambdanaut> thank you!
15:36:47 <JoeyA> @hoogle .:
15:36:47 <lambdabot> No results found
15:36:54 <ski> @type (.:)
15:36:55 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
15:36:58 <ski> @src (.:)
15:36:58 <lambdabot> Source not found. Maybe you made a typo?
15:37:02 <ion> > fmap fmap fmap (+1) [ [1,2,3],[4,5,6],[9,8,7] ]
15:37:03 <JoeyA> @hoogle (.:)
15:37:03 <lambdabot>   [[2,3,4],[5,6,7],[10,9,8]]
15:37:03 <lambdabot> No results found
15:37:16 <ion> (.:) = (.).(.)
15:37:30 <ski>   (.:) = (.) . (.)  -- an old invention of mine, now generalized by Caleskell
15:38:07 <benmachine> (.:) = fmap fmap fmap
15:38:16 <dylukes> :t (.:)
15:38:17 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
15:38:18 <ski> @type let (.) = (Prelude..) in (.) . (.)  -- original type
15:38:19 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:38:35 <dylukes> :t fmap fmap
15:38:36 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
15:38:44 <dylukes> :t fmap fmap fmap
15:38:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:38:56 <benmachine> @let result = (Prelude..) in result . result
15:38:56 <lambdabot>   Parse error: in
15:39:04 <dylukes> :t . .
15:39:04 <lambdabot> parse error on input `.'
15:39:07 <dylukes> :t (.) (.)
15:39:08 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
15:39:15 <dylukes> :t (.) (.) (.)
15:39:16 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:39:23 <schell> > [ (x, y) | x <-[0,1,2,3], y <-[0,1,2,3], x /= y ]
15:39:24 <lambdabot>   [(0,1),(0,2),(0,3),(1,0),(1,2),(1,3),(2,0),(2,1),(2,3),(3,0),(3,1),(3,2)]
15:39:33 <schell> awesome
15:39:47 <schell> who wrote lambdabot?
15:39:56 <benmachine> schell: several people
15:39:57 <benmachine> long ago
15:39:59 <ski> > [ (x, y) | x <- [0,1,2,3,4] | y <- [4,3,2,1,0], x /= y ]
15:40:00 <lambdabot>   [(0,4),(1,3),(2,2),(3,1),(4,0)]
15:40:08 <benmachine> her insides are quite untidy
15:40:17 <tac-tics> @where lambdabot
15:40:17 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
15:40:29 <ski> originally dons, i think, though several other people have contributed parts
15:40:43 <ski> @version
15:40:43 <lambdabot> lambdabot 4.2.2.1
15:40:43 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:40:50 <tac-tics> Does dons not hang out in #haskell any more
15:41:00 <ski> preflex: xseen dons
15:41:00 <preflex>  dons was last seen on freenode/#haskell 32 days, 7 hours, 15 minutes and 42 seconds ago, saying: cheers byorgey
15:41:21 <ciaranm> more importantly, BONUS is gone too :(
15:41:34 <dylukes> yeah where'd BONUS go :\
15:41:48 <ski> ciaranm : let's hope he hasn't gone and done a mmorrow or a TheHunter ..
15:41:55 <schell> is lambdabot running in someone's home, or at a datacenter like linode?
15:42:02 <benmachine> who's thehunter?
15:42:13 <ski> schell : Cale runs it, currently
15:42:15 <benmachine> 23:46:10 [Freenode] -!- lambdabot [~lambdabot@li85-105.members.linode.com]
15:42:23 <angstrom> can somebody critique this code, please: http://ideone.com/b0juE it's a C integer constant parser. also, it's the first time I'm using parsec, so the code might suck :-)
15:42:28 <schell> hehe
15:43:24 <incluye> so I want to iterate forever and emit values into an infinite list
15:43:33 <hpc> angstrom: it's funny seeing 'Int' on the value side of the namespace
15:43:43 <incluye> what's the best way to do that
15:43:58 <schell> what is 'a vixen/eliza personality' ?
15:44:12 <angstrom> hpc: I figured it's valid, since 'write yourself a scheme' uses it as well
15:44:19 <simon> incluye, iterate perhaps
15:44:23 <ski> benmachine : TheHunter wrote the cool/fun <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> in The Monad.Reader, Issue 2
15:44:48 <incluye> simon: I don't need to calculate new values based on previous ones
15:45:03 <hpc> angstrom: yeah, just entertaining to see it highlighted; your code looks solid
15:45:24 <hpc> even i understand it without having used parsec before
15:45:35 <angstrom> hpc: lines 54 through 76 bug me a little
15:45:43 <angstrom> hpc: oh. nice :-)
15:46:29 <simon> incluye, so iterate $ \_ -> ...? :P
15:46:36 * ddarius commonly uses String/Integer/Float etc. as data constructors.
15:46:43 <schell> @vixen
15:46:44 <lambdabot> I can take it. The tougher it gets, the cooler I get.
15:46:55 <incluye> simon: touche
15:47:13 <hpc> angstrom: is C really agnostic in the order it gets those suffixes in?
15:47:22 <hpc> "123ull" vs "123llu"
15:47:29 <angstrom> yes
15:47:37 <ski> schell : unfortunately, for some reason `vixen' was disabled (removed ?), you're actually running `nixon' there
15:47:46 <shirt> should i strip executables compiled with ghc?
15:47:56 <schell> ski: haha, ok
15:47:56 <ciaranm> you should go for c++11 integers. user defined suffixes!
15:48:04 <hpc> angstrom: i think you could try writing parsers for each individual type suffix
15:48:17 <schell> ski: does it just match to the closest command found?
15:48:52 <hpc> uSuff = do choice blahblah ["u", "U"]; return U
15:49:23 <hpc> it wouldn't be fewer lines though
15:49:28 <angstrom> hpc: in fact, that's what I tried first. but it got kindof ugly
15:49:30 <angstrom> yeah
15:49:45 <benmachine> angstrom: is there any particular reason why you have Suff instead of just using the type directly?
15:49:50 <ski> (benmachine : hm, TheHunter was at least here in 2005 -- i can't recall exactly when he disappeared (but it was definitely before mmorrow))
15:50:00 <benmachine> ski: oh, waaay before my time :)
15:50:08 <hpc> in a situation like that, i would say "that spec isn't ever changing, and this works, so i am never reading it again"
15:51:00 <benmachine> angstrom: also, is 10Lu allowed, or Ll, or lul?
15:51:13 <benmachine> (just ooi; not suggesting anyone sane would actually *use* those)
15:51:33 <ski> benmachine : see <http://webcache.googleusercontent.com/search?q=cache:OcmHud8p7OAJ:www.cse.unsw.edu.au/~dons/irc/haskell/05.02.15&strip=1> for where he first talks about the idea in that Monad.Reader issue, here on #haskell
15:51:41 <angstrom> benmachine: yes. I need to add bounds checking for the integers next. e.g., 32768 isn't a valid type if INT_MAX is 32767
15:51:56 <angstrom> benmachine: those aren't allowed, fortunately :-)
15:52:07 <benmachine> angstrom: I'm confused; I don't see how that helps you
15:52:14 <ski> benmachine : heh, i can't recall when you came aboard -- i just know that you've been here some while
15:52:31 * ski found #haskell some time in 2000 or 2001
15:52:34 <benmachine> ski: years, but not many of them :P
15:52:39 <conal> hi all
15:52:46 <ski> hi conal
15:52:48 <angstrom> benmachine: I seperate the integer value from the suffix. those combined yield a valid type, or an invalid one. I thought it'd make things easier
15:52:51 <ddarius> esap comes around much more rarely as well.
15:52:58 <ddarius> preflex: seen esap
15:52:58 <preflex>  esap was last seen on #haskell 152 days, 11 hours, 33 minutes and 5 seconds ago, saying: edwardk: but in a non-bijective case, it could be choosing another representative of the equivalence class.
15:53:24 <benmachine> angstrom: one sec, I'll show you what I mean
15:53:46 <ski> (ciaranm remarked how "IO" is a really misleading name)
15:53:51 <conal> how's trick in #haskell? i haven't paid much attention here since starting a new job recently.
15:53:55 <ski> ddarius : yeah :/
15:54:15 <ciaranm> i want the normal conal, not the opposite one
15:54:19 <conal> ski: yeah, i see. it's *way* more than I/O.
15:55:05 <conal> moreover, tons of "I/O" goes on under the hood in getting information into and out of pure functions.
15:55:07 <ski> ciaranm : this *is* the normal one, which other were you thinking about ?
15:55:12 <joevandyk> I have this (silly) code:
15:55:14 <joevandyk> element_at xs x = xs !! x
15:55:14 <joevandyk> prop_3a xs x = (length xs > x && x >= 0) ==> element_at xs (x::Int) == (xs !! x::Int)
15:55:28 <joevandyk> when running quickCheck, it says "Gave up! Passed only 16 tests."
15:55:38 <tromp> > fromList [42,3] :: Maybe Int
15:55:39 <lambdabot>   No instance for (Control.Monad.Random.Class.MonadRandom
15:55:39 <lambdabot>                    ...
15:55:45 <ski> (conal : though i would be hesitant to call it even "I/O")
15:55:58 <ciaranm> ski: the one in the regular category of Haskellers, not the one in Haskellers^OP
15:56:24 <conal> just as we've raised the level of discourse by moving things like stack-frame munging from the programming model to the implementation, i want to see us do the same with other forms of I/O, like file systems & user interfaces.
15:56:40 <dafis> joevandyk: quickcheck generates too short lists, you have to give it a larger size
15:56:49 <tromp> > listToMaybe [42,3]
15:56:50 <lambdabot>   Just 42
15:56:54 <conal> ski: me too, since those details are no longer in the programing model.
15:57:02 <ski> ciaranm : well, i find e.g. `Codensity' easier to understand than `Density'
15:57:20 <joevandyk> dafis: how?
15:58:13 <benmachine> angstrom: hmm, it might enable nicer code if you stored signed-ness and long-ness as separate bits
15:58:17 <benmachine> but that's for another day
15:58:21 * benmachine fiddles a bit
15:58:26 <dafis> joevandyk: quickChexkWith (stdArgs{maxSize=10000}) prop_foo
15:58:46 <dafis> the 10000 is pulled from ym rear of course
15:58:54 <angstrom> benmachine: "bits" as in 0/1 ?
15:58:54 <dafis> my*
15:58:56 <ski> conal : i've for a long time tried to make a distinction between "effects" and "side-effects" -- where "side-effects" is "effects" that happen on the "side", i.e. which aren't properly accounted for in the type; roughly : "any (observable) deviation from terminating and returning a single value"
15:59:08 <dafis> quickCheckWith*
15:59:11 <joevandyk> dafis: hm, wouldn't that randomly fail?
15:59:25 <joevandyk> dafis: if quickCheck for whatever reason couldn't generate a test that matched the condition?
15:59:31 <ski> conal : in that vein, i talk about `IO'-effects, just as well as `Parser'-effects and `[]'-effects
15:59:31 <dafis> joevandyk: why should it?
15:59:36 <benmachine> angstrom: no "bits" as in "pieces" :P
15:59:51 <benmachine> angstrom: sorry, that was careless wording
15:59:53 <ciaranm> ski: i think "effect" is a bad term, since it implies that you're doing something
16:00:09 <angstrom> benmachine: also, the grammar for integer-constants in the C-std doesn't deal with signedness, somehow. I have yet to figure out how that comes into play..
16:00:12 <dafis> joevandyk: ah, that may happen, that's why quickCheck gave up on your original
16:00:46 <conal> ski: do you have a clear notion of "effects"? i never know what people mean by that term in the abstract.
16:00:52 <hpaste_> benmachine pasted “angstrom's thing” at http://hpaste.org/52300
16:00:55 <ski> ciaranm : i think it's good. compare with how the work is used in effect systems, and e.g. in Filinski's papers about reflecting arbitrary (computable) effects into side-effects, using composable continuations
16:01:08 <benmachine> angstrom: follow the hpaste_
16:01:13 <td123> angstrom: you mean the lexer? or the language grammer?
16:01:34 <joevandyk> dafis: hm, i tried your example with this property:
16:01:35 <joevandyk> prop_3a xs x = (x < length xs && x >= 0) ==> element_at xs (x::Int) == (xs !! x::Int)
16:01:41 <joevandyk> says it gave up! passed only one test.
16:01:42 <ddarius> ski: I consider that the difference between reifying an (side-)effect into a value (that models the effect) and reflecting that model into an actual (side-)effect.
16:01:43 <angstrom> td123: the language grammar
16:01:53 <benmachine> angstrom: all I meant was having data Type = MkType Bool Length; data Length = Short | Normal | Long | LongLong
16:01:58 <benmachine> something like that
16:01:58 <angstrom> td123: the section about integer constants, at least
16:02:14 <dafis> joevandyk: to avoid having QC generate out-of range indices, you can also provide a custom generator by using forAll
16:02:41 <td123> angstrom: ok sorry, for some weird reason I thought you referred to the lexer
16:03:02 <ciaranm> ski: but your functions don't have effects. they're
16:03:05 <ciaranm> gah
16:03:18 <ciaranm> ski: they're just things that can be combined with things you don't see that do have effects
16:03:19 <ski> conal : sadly no. the best i have (i think) would be something like any `f a' value which isn't `point x'/`pure x'/`return x' for some value `x' of type `a' has `f'-effects
16:03:49 <dafis> joevandyk: yeah, I guess the size increase allows much larger x and doesn't so much for the length of the generated lists
16:03:52 <conal> ski: ah. thx.
16:03:52 <benmachine> angstrom: one reason I still don't like the code I pasted is that the pattern match in integerSuff is still inexhaustive
16:03:58 <benmachine> er, non-exhaustive
16:04:01 <ski> conal : of course, in the case of `Pointed', this is a mostly empty concept; in case of `Applicative' and `Monad' it gets more interesting
16:04:09 <conal> yeah
16:04:34 <benmachine> ski: but Pointed is mostly an empty concept anyway :>
16:05:03 <ski> conal : in any case, i use the word "effect" to describe what any monadic action "does", and i think it's useful to generalize to at least the `Applicative' case
16:05:25 <benmachine> well, ok, that's not quite fair, but the only use of it I can recall is a generalised filter, or something like that
16:05:55 <angstrom> benmachine: "llll" should somehow error of course. thanks for the post, anyways :-)
16:05:55 <ski> ddarius,(conal) : *nod*, what you call "models the effect", i call "has effects"
16:06:09 <conal> ski: do you have a sense of what you get out of using those words ("effect" and "does")? it's a mystery to me.
16:06:23 <joevandyk> http://cseweb.ucsd.edu/classes/wi11/cse230/lectures/quickcheck.html is an awesome introduction to quickCheck, btw
16:06:25 <benmachine> angstrom: oh, btw, don't use head
16:06:29 <joevandyk> it's the best i've found by far
16:07:00 <angstrom> benmachine: what's the alternative?
16:07:17 <benmachine> angstrom: well, since you're working in a parser monad, there are some quite good alternatives
16:07:32 <ski> ciaranm : in my terminology, that is what it means to have effects
16:07:39 <benmachine> you can (ab)use pattern-matching in do-notation
16:07:46 <benmachine> I'll paste the least awkward example
16:07:58 <ddarius> ski: So Just 3 has effects?
16:08:05 <ski> conal : i mostly find it useful when "thinking in the Kleisli category", i.e composing morphisms there
16:08:19 <ski> ddarius : yes (trivial such, since it is `return 3')
16:08:36 <ddarius> Well then Nothing, but you answered my question.
16:08:37 <ski> while `Nothing' has a non-trivial `Maybe'-effect
16:08:52 <ciaranm> ski: so under Maybe, does fmapping over a Nothing rather than a Just have an effect?
16:09:18 <conal> btw, yesterday i started facilitating a haskell-learning group at work. we're using LYAH, since i wanted to encourage a playful orientation. they're enjoying the book so far.
16:09:34 <conal> kudos to BONUS
16:09:59 <ion> @karma+ BONUS
16:09:59 <lambdabot> BONUS's karma raised to 10.
16:10:13 <ski> ciaranm : the `fmap' by itself doesn't have any (non-trivial) effects, it just composes the effectful `Maybe Foo' computation with a non-effectful one
16:10:17 <appamatto> Do languages with continuations ever allow you to modify the continuation? Say, change the definition of a global function represented in the continuation and then reify?
16:10:34 <conal> i winced at the part early on that mixed up "functions" and "definitions" and (consequently perhaps) described non-functions as 0-ary functions.
16:11:02 <conal> when i wrote him, he replied that he regretted it going to print that way.
16:11:05 <ddarius> Continuations don't capture state, so if you change the definition of a global function, it will affect the execution of the continuation.
16:11:07 <shachaf> Wait, LYAH does that?
16:11:19 <conal> shachaf: yeah. almost immediately :(
16:11:21 <ciaranm> wait, BONUS is alive?
16:11:33 <ddarius> Wait, ?
16:11:33 <shachaf> Yes, he's online on other IRC networks.
16:11:56 <hpaste_> benmachine annotated “angstrom's thing” with “avoiding head” at http://hpaste.org/52300#a52301
16:12:01 <benmachine> angstrom: ^
16:12:11 <angstrom> "avoiding head" :->
16:12:21 <appamatto> ddarius, why wouldn't continuations capture state?
16:12:27 <ddarius> He just got tired of us criticizing his use of "functions."
16:12:28 <benmachine> angstrom: shh :P
16:12:35 <ski> conal : btw, i appreciate you trying to pick apart my halfway-formed intutions :)
16:12:41 <appamatto> Don't they need to capture everything vital to resuming the current execution?
16:12:42 <ciaranm> ski: i think i understand what you're getting at if you replace "side effect" with "lying naughty evil" and "effect" with "does what it says on the tin"
16:13:00 <ddarius> appamatto: Because that's not what they do.  They capture the lexical context.
16:13:14 <ski> appamatto : the traditional implementations of continuations in languages with state didn't capture state in the continuations
16:13:17 <ciaranm> ski: but "effect" is confusing. at least most people don't think they know what a monad is when they start out. but they do think they know what an effect is...
16:13:25 <ddarius> appamatto: Anyway, you don't expect a continuation to save an entire copy of the heap do you?
16:13:40 <appamatto> Hmm, isn't a global function definition part of the lexical context?
16:13:56 * shachaf expects callCC to clone the entire universe.
16:14:00 <angstrom> benmachine: I couldn't have come up with those, at this point :x thanks again
16:14:05 <appamatto> shachaf, I as well :)
16:14:14 * ciaranm hands shachaf lots of cows
16:14:32 <benmachine> angstrom: the last one at least should involve at most one new trick :P
16:14:47 <benmachine> angstrom: also, the way they deal with errors is subtly different
16:15:06 <ciaranm> i have a sneaking suspicion that linux's clone syscall would actually allow you to do continuations that way...
16:15:15 <ski> ciaranm : yes, one would need to acquire the understanding of "effect" part by part. however, already knowing monads, i think it makes perfectly sense (cf. how `IO' isn't any more impure in Haskell than using `Either MyError' for exceptions)
16:15:43 <ddarius> The bindings are could be, but, in mutable cases, the values referenced are not.  You have a binding to a reference.  That binding may be in the continuation, but what it references can change as always.
16:15:56 <angstrom> benmachine: is fail the way to do "erroring" in parsec? I read about <:> somewhere, but that's only for overwriting error-messages, iirc
16:16:03 <benmachine> angstrom: but you can have fun working that out, I need sleep
16:16:14 <angstrom> fair enough :-)
16:16:17 <benmachine> angstrom: I don't know about "the"; I'm pretty sure it's at least /a/ way of doing it
16:16:38 <angstrom> I'll investigate, then
16:16:44 * ski suspects people want continuations to restore state because they have heard of thinking about them as a kind of time machine
16:16:47 <ciaranm> ski: terminology matters! half of the difficulty in topology for example is dealing with the stupid way they define words
16:16:58 <ddarius> ski: I agree.
16:17:00 <ciaranm> "open" and "closed" aren't opposite, for example
16:17:15 <ddarius> ciaranm: The logic of a topology isn't (necessarily) boolean.
16:17:34 * ddarius is perfectly fine with the terms "open" and "closed" in topology.
16:17:37 <ski> ciaranm : i agree ! .. that's why i'm attempting (probably not very successfully) for the use of "effect" mentioned above
16:17:52 <ciaranm> http://www.youtube.com/watch?v=SyD4p8_y8Kw
16:18:10 <ddarius> ciaranm: I'm aware.
16:18:46 <ski> s/for the/argue for the/
16:18:52 <ciaranm> ski: call it a skiism or something. not a word that has a meaning.
16:18:56 <conal> ciaranm: related: "A problem well stated is a problem half solved." - Charles F. Kettering
16:19:12 <ski> ciaranm : i'm not sure what the difference would be :)
16:19:30 * ddarius just tells anyone that comes up to him with a problem that it is ill-conditioned and then walks away.
16:19:58 <ski> go, go, ddarius ! :)
16:20:38 <joevandyk> dafis: I'm having problems with the syntax of forAll generating lists for quickCheck.  In this case, I want quickCheck to generate lists that are the same length or larger than the other generated number
16:20:43 <dylukes> :D
16:20:45 <dylukes> I DID IT.
16:20:55 <dylukes> My rubyist friend just messaged me.
16:21:02 <dylukes> He's installed the haskell platform.
16:21:04 <dylukes> now for dinner.
16:21:14 * ski grins
16:21:26 <ddarius> That's the easy part.
16:21:29 <ddarius> (Hopefully...)
16:21:38 <appamatto> Do continuations interfere with referential transparency?
16:21:51 <ski> ciaranm : also, we want a topology where not every space is overt
16:21:54 <ddarius> appamatto: Yes.
16:21:55 <ski> appamatto : depends
16:22:08 <ski> appamatto : linear continuations need not, i think
16:22:12 <ddarius> It takes a good amount of restriction to avoid them not wreaking havoc.
16:23:38 * ddarius double negated his sentence.
16:23:40 * ski recalls `argfc :: () -> a -> a', such that `map argfc [0,1,2,3]' yields `[0,0,0,0]' (if you happen to look at the first element of the list before any of the others)
16:23:58 <ski> you can write that, using continuations-side-effects only (no state needed)
16:25:26 <hpc> ski: would that typecheck?
16:25:31 <ddarius> No.
16:25:47 <hpc> map argfc :: [()] -> [a -> a]
16:26:13 <appamatto> Hmm, I was thinking of using continuations to allow a program to change function definitions as it's running
16:26:21 <ski> hpc : sorry, that should be `map (argfc ()) [0,1,2,3]'
16:26:45 <ddarius> appamatto: Why do you need continuations to allow that?
16:27:13 <ski> appamatto : well, what `argfc ()' does is when it is first called with `a' as argument, it jumps back and replaces itself with `const a'
16:27:20 <ddarius> Incidentally, you can implement at least single-shot continuations in Haskell with an appropriate amount of unsafePerformIO.
16:27:31 <appamatto> ddarius, well, I'm having a hard time imagining doing it without continuations
16:27:32 <ski> appamatto : so it will execute that part of the code twice
16:27:47 <ddarius> appamatto: f := g, where do continuations come in?
16:27:52 <ski> appamatto : why not just state ?
16:28:29 <antihoax> :)
16:28:38 <ski> the `argfc' ("argument of first call") way is really just to show a suprising thing you can do with solely continuation-side-effects
16:28:41 <dafis> joevandyk: forAll is not for generating the lists, you pass a generator to it, like: forAll listIndexGen (\(xs,i) -> elem_at xs i == xs !! i)
16:28:58 <joevandyk> dafis: what does listIndexGen look like?
16:29:05 <dafis> joevandyk: now, writing listIndexGen is a tad harder
16:29:06 <appamatto> Hmm, I'm writing an image-based language where the intention is to do all of the programming inside a live system
16:29:08 <joevandyk> lol
16:29:15 <ddarius> With delimited continuations (or alternatively, normal continuations and a piece of mutable state), you can have any effect you want.
16:29:31 <appamatto> I don't think it really works to just store, say, global function definitions in mutable state
16:29:48 <ddarius> appamatto: That's exactly what all extant image-based languages do.
16:29:53 * ski just attempted to write (a version of) `argfc' here in lambdabot, but `unsafeInterleaveST' isn't in scope ;)
16:29:58 <ddarius> I fail to see how you think that wouldn't work.
16:30:11 <incluye> > show 10 ++ repeat '0'
16:30:12 <lambdabot>   "10000000000000000000000000000000000000000000000000000000000000000000000000...
16:30:39 <dylukes> ddarius: He read the introduction to my research paper
16:30:49 <dylukes> which was just a basic intro to typing and the lambda calculus... very very simple stuff
16:30:54 <dylukes> but he seemed genuinely interested
16:31:03 <dylukes> I had some "look how much clearer this than ruby" examples...
16:31:13 <dafis> joevandyk: listIndexGen = do { len <- arbitrary; xs <- replicateM arbitrary; i <- iforgot; return (xs,i); }
16:31:19 * ddarius should dig up the quote from Luke Palmer, I believe.
16:31:30 <ski> (ddarius : thinking about TheHunter's hack, or something else ?)
16:31:30 <dylukes> @quote Luke Palmer
16:31:31 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
16:31:55 <appamatto> ddarius, I'm guessing the interpreter would manage that mutable state?
16:32:36 <ddarius> No, not Luke Palmer, that wouldn't be interesting, Luke Gorrie.
16:32:53 <dafis> joevandyk: the iforgot can be written by using the Gen constructor, there's probably a neater way, but I forgot, I don't use QuickCheck too much with custom generators
16:33:20 * ski wonders where he's seen the name "Luke Gorrie" before
16:33:39 <ddarius> http://lambda-the-ultimate.org/node/92#comment-524
16:33:48 <incluye> > succ 1
16:33:49 <lambdabot>   2
16:34:07 <ski> dafis : what would `listIndexGen' do ?
16:34:13 <dylukes> :t succ
16:34:14 <lambdabot> forall a. (Enum a) => a -> a
16:34:20 <ddarius> ski: To what are you referring when you said "thinking about TheHunter's hack" ?
16:34:23 <dylukes> yay
16:34:26 <dylukes> Enum
16:34:35 <dylukes> > pred 0
16:34:35 <lambdabot>   -1
16:34:40 <appamatto> ddarius, I think the current execution of the system can't be affected by new definitions
16:34:52 <appamatto> For one thing we aren't sure if they've been executed or not
16:35:14 <dylukes> > pred (0 :: Word8)
16:35:15 <lambdabot>   *Exception: Enum.pred{Word8}: tried to take `pred' of minBound
16:35:15 <ski> ddarius : the "single-shot continuations" one
16:35:30 <monochrom> ♥ Wadler
16:35:50 <ddarius> ski: He may have done the same thing, but the idea is common enough and was common enough a decade ago.
16:35:54 <ddarius> monochrom: Don't we all?
16:36:04 <monochrom> yes! :)
16:36:05 <ddarius> Other than the comprehensive comprehensions thing, but everyone is flawed.
16:36:34 <monochrom> at any rate, everyone must love every title, at the very least!
16:36:41 <dafis> ski: it would generate a list of some length (longer than what QuickCheck usually produces) and an index within the range of the list
16:36:42 <ddarius> monochrom: Agreed.
16:36:47 <monochrom> @quote monochrom change
16:36:47 <lambdabot> No quotes match. The more you drive -- the dumber you get.
16:36:55 <JoeyA> Binaries built on Windows with GHC default to statically linking GMP.  Is there a way to dynamically link them?
16:37:01 <JoeyA> http://haskell.forkio.com/gmpwindows
16:37:07 <monochrom> preflex: quote monochrom change
16:37:08 <preflex>  no quotes found for monochrom
16:37:23 <JoeyA> That appears to be outdated.  The current Haskell platform distributes binutils 2.20, iirc
16:37:29 <ski> ddarius : TheHunter was abusing linear implicit parameters (and `unsafePerformIO') to implement more or less Filinski's monadic reflection (<http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters>, if you care to look)
16:37:33 <monochrom> hrm, I had one that says "linear types can change the world! record updates can change the type!"
16:37:37 <ddarius> One of my favorite Wadler titles is "How to be lazy without even being odd"
16:38:08 <JoeyA> I tried the same basic procedure, but the binary is the exact same size, and it does not depend on the gmp dll.
16:38:14 <ski> that one always makes me smile :)
16:38:24 <ddarius> ski: Same here.
16:38:45 <monochrom> unprecedent puns
16:38:57 * monochrom ♥ puns
16:39:12 <monochrom> in math channels I say "to take logs you must cut branches"
16:39:51 <ski> "How to Add Laziness to a Strict Language Without Even Being Odd" by Philip Wadler,Walid Taha,David Macqueen at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.9427>
16:40:15 <monochrom> well-typed programs can't be blamed
16:40:34 <monochrom> (although I haven't looked at blame analysis)
16:41:24 <ski> dafis : ah, ok
16:43:42 <quackquack> what is the recommended way to get haskell 7 on ubuntu 10.04?
16:44:15 <mauke> http://lambda-the-ultimate.org/node/1760
16:44:17 <ddarius> GHC 7
16:44:21 <Cale> quackquack: You mean GHC 7
16:44:31 <quackquack> Cale: sorry, yes
16:44:33 <Cale> quackquack: Honestly, I don't use Ubuntu's packages for any Haskell stuff
16:44:45 <Cale> quackquack: The generic linux binary of GHC is easy enough to install
16:44:51 <Cale> and works more consistently
16:45:04 <quackquack> Cale: i have downloaded it, but im not sure how to get it working
16:45:14 <Cale> http://haskell.org/ghc/download_ghc_7_0_4#x86linux
16:45:20 <Cale> (that package?)
16:45:31 <quackquack> yes
16:45:36 <Cale> So, you unpack it somewhere, and then ./configure && make install
16:45:46 <Cale> oh, sudo make install, rather :)
16:46:03 <monochrom> "./configure --prefix=/usr/local" and "make install" etc. change "/usr/local" to whichever directory you like
16:46:19 <quackquack> Cale: does that give me Cabal also?
16:46:20 <monochrom> there is also a text file "INSTALL" with similar instructions
16:46:29 <Cale> I'm pretty sure the default prefix is /usr/local, so if you want to install there, you don't need to include that option
16:46:41 <Cale> quackquack: It doesn't, but once you have that...
16:46:52 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.10.2/cabal-install-0.10.2.tar.gz
16:46:56 <monochrom> I like to always show the --prefix explicitly to tell people they have a choice
16:47:03 <Cale> get the tarball for cabal-install from hackage
16:47:12 <Cale> and then run the bootstrap.sh from it
16:47:16 <quackquack> Cale: ok, thanks!
16:47:17 <ddarius> With Visual Studio, you have no choice (except for the very first time)
16:47:17 <Cale> and you should be all set :)
16:48:25 <monochrom> experience shows that a few years later people always regret the /usr/local default
16:48:43 <ddarius> In a few years, most people will be using a different computer.
16:49:00 <shachaf> monochrom: What do you recommend over /usr/local?
16:49:36 <monochrom> /usr/local/ghc-7.0.4
16:50:41 <monochrom> in fact I use /usr/local/haskell-platform-2011.2.0.1 because I put the whole haskell platform there
16:50:48 <dylukes> monochrom: Why do people regret /usr/local/
16:50:53 <dylukes> I mean, I wouldn't put it DIRECTLY there but...
16:51:11 <dylukes> I usually put stuff in /usr/local/.../foo/bar, then symlink binaries to /usr/local/bin, libs to /usr/local/lib, etc
16:51:25 <dylukes> that way I can easily add/remove versions and just redo the symlinks
16:51:27 <dylukes> works well for me.
16:51:50 <monochrom> first sign of regret: "how do I have multiple different versions?" (OK this one doesn't pose too big a problem, but there is a small problem)
16:51:58 <parcs> i put stuff in $HOME/local and have adjust my path to include $HOME/local/*/bin
16:52:05 <monochrom> second sign of regret: "how do I erase GHC?"
16:52:13 <dylukes> i have /usr/local/bin in my path
16:52:17 <shachaf> monochrom: By default?
16:52:18 <dylukes> monochrom: I just delete the GHC install directory >_>
16:52:20 <ion> dylukes: Sounds like you want stow.
16:52:23 <shachaf> monochrom: Multiple versions, I mean.
16:52:40 <shachaf> They're called ghc-7.0.1, ghc-7.1.20xxxxxx, etc.
16:52:51 <Saizan> docs aren't versioned like that though
16:53:05 <dylukes> ion: ah nice.
16:53:06 <shachaf> Who reads docs?
16:53:14 <Saizan> i surely don't
16:53:17 <dylukes> I'll have to ensure it doesn't conflict with my brew install, but that puts everything in /Cellar
16:53:23 <shachaf> No real programmer reads the documentation.
16:53:25 <monochrom> cabal exe is not versioned either
16:53:26 <dylukes>  /usr/local/Cellar*
16:53:43 <shachaf> Actually, I find Haddock-generated documentation relatively unhelpful.
16:53:45 <dylukes> ion: brew does the same thing for package managing
16:53:55 <dylukes> its essentially stow + basic apt-get with git based hosting
16:53:56 <shachaf> I more often just look at the .hs files.
16:53:57 <monochrom> I write helpful haddocks
16:54:05 <dafis> shachaf: is that haddock's fault?
16:54:06 * gienah uses chroots on linux, one chroot per ghc version
16:54:22 <dylukes> I find haddock to be fine usually... its the authors fault if stuff is missing :\
16:54:25 <Saizan> gienah: that's pretty extreme :D
16:54:27 <dylukes> examples are always really helpful.
16:54:30 <shachaf> dafis: Maybe partly. I'm not sure.
16:54:30 <monochrom> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html  the haddock is longer than the implementation
16:54:51 <shachaf> monochrom: Great, so I'll read your helpful haddocks while I'm looking at the .hs file. :-)
16:55:12 <dylukes> .hs files are good documentation :D
16:55:33 <monochrom> I will write like &#65;&#119; to confound you
16:56:03 <dylukes> urlencode .hs files
16:56:07 <dylukes> send them in get requests
16:57:11 <shachaf> > "\65\119"
16:57:12 <lambdabot>   "Aw"
16:59:09 <monochrom> to refute "people change computers in a few years": they retain hard disk content, even hard disk physically, across the change
16:59:30 <ddarius> I don't.
16:59:35 <monochrom> in fact some of them go so far as yanking out the hard disk altogether as NAS and never change it
16:59:49 <dylukes> I wipe my hard drive when I reinstall, with the exception of some files.
16:59:54 <dylukes> and when I replace my hard drive,
16:59:59 <dylukes> it looks a little like Jimmy Hendrix live.
17:00:36 <dylukes> (I keep music collection on an external, as well as some license files)
17:01:35 <monochrom> regardless, my "a few years" in the regret I mentioned is usually just 0.7-1.5 years
17:01:42 <ddarius> While network attached storage will probably rise, you probably won't have /usr/bin there.  Also, mobile devices will "encourage" a more throw-away approach for hard disks (or rather people change computers but they don't usually get rid of the old ones soon.)
17:02:17 <antihoax> yes sata is cool
17:03:05 <parcs> is there any way to change the prefix of my compiled source tree. is there any way to do so without having to recompile everything?
17:03:33 <antihoax> i think you dont wanna know
17:03:34 <antihoax> :)
17:03:41 <monochrom> depends on whether the prefix goes into the *.o files
17:03:52 <antihoax> im just deciding to chroot it
17:04:07 <monochrom> but most build tools just play safe and say "let's assume it does. need rebuild"
17:04:09 <antihoax> instead of trying to run with prefix...
17:04:20 <antihoax> because it was not designed for that
17:04:31 <parcs> well i'm talking about the ghc tree
17:04:54 <antihoax> everything is possible.
17:05:03 <quackquack> I am trying to install Cabal, but there is no "bootstrap.sh". when I run the Setup.hs file, i get this error: "Linking Setup ... \n /usr/bin/ld: cannot find -lgmp \n collect2: ld returned 1 exit status"
17:05:12 <monochrom> the prefix goes into several shell scripts that will be installed. (/usr/local/bin/ghc-7.0.3 is a shell script, has prefix)
17:05:20 <antihoax> you can even write a script that moves the source tree to anywhere you want
17:05:35 <sm> hey all.. rss2irc needs to keep a couple of processes up and talking to each other, reliably and as simply as possible. Any recommendations for libs or patterns that might help ? Are netwire or cloud haskell ready ?
17:06:10 <monochrom> quackquack: apt-get install libgmp3-dev
17:06:12 <parcs> how would netwire help you?
17:06:34 <monochrom> in fact, you also need apt-get install zlib1g-dev later for cabal-install
17:07:00 <sm> parcs: I had the idea netwire is for building net services in an FRP style
17:07:04 <quackquack> monochrom: ty!
17:07:54 <monochrom> do you know that "Cabal" and "cabal-install" are different? and what they refer to?
17:08:06 <ddarius> sm: Just do what Erlang does.
17:08:20 <parcs> sm: no it's jus
17:08:34 <monochrom> "Cabal" especially with capital C refers to a library. but it already comes with GHC. you shouldn't install it yourself
17:08:55 <monochrom> "cabal-install" refers to the exe. the exe name is confusingly just "cabal"
17:09:21 <dafis> fortunately that is going to change
17:09:25 <ddarius> cabal-install install cabal-install isn't as pleasant as cabal install cabal-install.
17:09:26 <monochrom> you want cabal-install and it has a bootstrap.sh
17:09:41 <parcs> sm: netwire is a just an arrowized frp implementation, nothing specific to networks (except for its name)
17:10:22 <sm> parcs: the main haddock mentions networking ?
17:10:46 <sm> and tis in the Network category
17:11:14 <monochrom> netwire is a networking library
17:11:18 <parcs> i think that's a different kind of network
17:11:34 <monochrom> it is the internet socket kind
17:11:35 <quackquack> monochrom: where is cabal-install? i got the source im using from http://www.haskell.org/cabal/download.html
17:12:03 <monochrom> Cale said http://hackage.haskell.org/packages/archive/cabal-install/0.10.2/cabal-install-0.10.2.tar.gz
17:12:49 <gienah> sm: the parallel haskell project is working on testing and enhancing cloud haskell for production applications (but of course cloud haskell is not on hackage yet)
17:12:50 <monochrom> although http://www.haskell.org/cabal/download.html also has "cabal-install tool"
17:13:22 <quackquack> monochrom: ok, thanks!
17:14:13 <quackquack> haskell is a lot harder to set up than ruby :P
17:14:34 <sm> gienah: thanks. I suspect it might be overkill for a 2-3 process irc bot
17:15:09 <alpounet> installing the haskell-platform isn't hard :P
17:15:21 <ddarius> sm: Just fork another process that monitors those and restarts them if they die.
17:16:36 <sm> ddarius: I think that's what I've got, but it's buggy. I thought it might be more productive/energising to use a lib/framework that does it right
17:17:32 <ddarius> In what way is it buggy?
17:18:24 <gienah> sm: an article comparing Erlang and Haskell messaging, suggests using STM channels: http://jlouisramblings.blogspot.com/2010/04/haskell-vs-erlang-for-bittorent-clients.html
17:19:48 <sm> ddarius: I don't remember the specifics, it might be that certain exceptions/failure modes aren't handled properly
17:19:58 <sm> I seem to have collected a long list of issues: http://joyful.com/darcsden/simon/rss2irc/browse/NOTES#L-3
17:21:02 <sm> and the code isn't obviously correct to me
17:21:34 <sm> it starts here, if anyone's in the mood for review: http://joyful.com/darcsden/simon/rss2irc/browse/rss2irc.hs#L-235
17:22:04 <sm> gienah: thx
17:25:38 <ddarius> sm: I said another process, not another thread.
17:27:28 <sm> ddarius: I see, well that is more or less working too: supervisord restarts my bots when they die
17:28:04 <sm> but, once in a while they hang instead of dying. So I also force a restart every so often with cron. It's a bit unsatisfying
17:28:45 <JoeyA> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/win32-dlls.html says that multi-DLL Haskell programs don't work on Windows.  However, I compiled a simple program and its dependency with -dynamic, gathered up the DLLs it needed, and it worked.
17:29:10 <JoeyA> (I'm using GHC 7.0.3 on the current Haskell Platform)
17:30:18 <ddarius> sm: Just add a simple watchdog rather than forcibly restarting and you should be set.
17:30:54 <sm> ddarius: what do you mean ?
17:31:03 <sm> I thought supervisord was that
17:31:40 <sm> you mean ping them for an irc response ?
17:31:57 <ddarius> http://en.wikipedia.org/wiki/Watchdog_timer
17:32:42 <sm> I see, good idea, thx
17:42:55 <ion> jlouis: It would be nice to have a version of your process/supervisor stuff separated from CombinaTorrent. :-)
17:47:04 <zzo38> When trying to send a private message to ski I get an error message.
17:47:08 <dylukes> data SupervisorMsg = IAmDying ThreadId
17:47:09 <dylukes>                    | PleaseDie ThreadId
17:47:09 <dylukes>                    | SpawnNew Child
17:47:10 <dylukes> :3
17:47:44 <hpc> | OhGodWhatHaveYouDone UserId
17:47:47 <hpc> :D
17:48:44 <ski> zzo38 : not an error message, i just forgot to disable my `away' status
17:49:18 <zzo38> Yes, I realized that now.
17:49:44 <gwern> @quote away
17:49:44 <lambdabot> jmob| says: I want the world to stop at that point, go away, and give me it's argument..
17:50:06 <ski> zzo38 : anyway, you might want to try to hunt down info on stream processors, and possibly also info on iteratees and enumerators (enumeratees ?)
17:50:54 <zzo38> ski: Hopefully now you should know what Fail is for. And yes I did look at those things, and they do have some similarities. Another similarity is to generator functions in JavaScript (which is why the "yield" function has its name).
17:51:02 <ski> and edwardk (who's not here atm) also had something that i think was similar/related to your `Barrier' at <http://sprunge.us/YNJW>
17:51:37 <zzo38> OK, what was it?
17:51:46 <zzo38> Do you have more information?
17:51:51 <ski> zzo38 : if i wanted `Alternative', i would add an `Zero' constructor, without any argument
17:52:12 <sm> after SourceGraph rss2irc.cabal, how come http://joyful.com/darcsden/simon/rss2irc/raw/SourceGraph/rss2irc.html seems to be unrelated to http://joyful.com/darcsden/simon/rss2irc/browse/rss2irc.hs ?
17:52:20 * ski idly wonders why zzo38 called this `Barrier'
17:52:22 <zzo38> ski: Yes, that is also one way.
17:52:47 <zzo38> ski: I forget now. But I had a reason when I started writing it on paper
17:52:52 <Luke> I'm trying to trace a fail in my code to see how it happens. Does anyone have a good guide on using the GHCi debugger?
17:53:31 <ski> zzo38 : anyway, i'm a bit too tired to be able to give the code good thought, so i think i'll stop attempting to comment more on it today
17:53:44 <Luke> nm found the comprehensive user guide
17:53:47 <zzo38> ski: OK.
17:54:02 <ski> i'll try to look at it in the days to come (you're welcome to remind me, if i forget)
17:54:16 <zzo38> OK
17:54:58 <zzo38> But I am curious to know what edwardk was discussing that is related.
17:55:11 * ski can't recall exactly
17:55:49 <sm> hmm, from the bittorrent article: "We just to get the number of errors below a certain threshold. Rather than waste time fixing a bug which only occurs once every year, we can concentrate on the things that matter." Maybe I should leave well enough alone
17:55:56 <ski> (i might be wrong, but istr seeing him talk about something like that .. maybe it was on his blog `comonad.com)
17:56:45 <zzo38> If it was, can you tell me what is the URL for that article?
17:59:44 <ski> hm, maybe i do misremember, confusedly thinking what you did was similar to <http://comonad.com/reader/2011/a-parsec-full-of-rats/> -- or maybe it was something he talked about on IRC
17:59:53 * ski can't tell, and is going to bed
18:03:35 <jlouis> ion: perhaps
18:03:35 <lambdabot> jlouis: You have 1 new message. '/msg lambdabot @messages' to read it.
18:04:15 <jlouis> ion: I think cloud haskell has a better API
18:04:27 <jlouis> and my supervisor stuff isn't full fledged
18:04:37 <jlouis> more like the quick hack :P
18:05:35 <ion> jlouis: There’s no supervisor stuff at all for Cloud Haskell AFAIU. dylukes has been meaning to implement it, but it’s still TBD. And i probably won’t have the extra energy to work on that myself. Your stuff at least *works* right now. :-)
18:05:56 <dylukes> I have stgma to work on atm
18:06:00 <dylukes> as well as, you know, school
18:06:03 <dylukes> and college applications
18:07:15 <jlouis> ion: iff you take my process monad, yes :P
18:07:25 <jlouis> I better find a bed
18:07:59 <ion> jlouis: Indeed
18:08:22 <jlouis> I have a brain malfunction due to needing sleep :P
18:08:55 <ion> We all have the brain malfunction of needing sleep. :-)
18:09:27 <ddarius> ion: Speak for yourself.
18:10:58 <quackquack> can you have a type in a module that has the same name as the module?
18:11:17 <monochrom> yes
18:11:29 <quackquack> ok, ty
18:11:50 <tickle`> is it premature optimization to use Data.Text for all string types, or is that a good practice?
18:11:50 <ion> @kind Data.Map.Map
18:11:51 <lambdabot> * -> * -> *
18:12:21 <hpaste_> ClaudiusMaximus annotated “Sierpinski triangle renderer” with “Sierpinski triangle renderer (integer for animgif)” at http://hpaste.org/52273#a52303
18:12:44 <parcs> is Control.Monad.Trans.Writer.Lazy the laziest that a Writer it could be? i have a Iteratee a (WriterT w IO) and the
18:12:51 <monochrom> it goes further. module X where data X = X
18:13:04 <monochrom> module name, type name, value name
18:13:22 <parcs> damn you ^M, why do you return
18:13:35 <monochrom> too bad type name and type class name can't be the same, else it would be complete :)
18:13:48 <monochrom> "the return of ^M"? :)
18:14:54 <tgeeky> does anyone have GHCJS "hello world" code? I know chrisdone posted it on hpaste a long time ago...
18:15:09 <monochrom> Character Wars trilogy? "A New Code" "The ^H Strikes Back" "Return of ^M"
18:15:19 <ion> monochrom: It isn’t enough. We need to go deeper. It’s like having a data constructor within a data constructor.
18:15:26 <tgeeky> monochrom: you missed an opportunity to say "Char Wars"
18:15:39 <monochrom> damn. yes. Char Wars is better :)
18:15:47 <parcs> anyway with an Iteratee a (WriterT String IO) stack the Writer doesn't seem to be lazy enough, ie execWriterT doesn't return anything until the Iteratee finishes
18:17:10 <tkahn6> any way to totally nuke my cabal thing and start over?
18:17:25 <monochrom> something like nuking ~/.ghc
18:17:26 <tkahn6> like my user local cabal repository or something
18:17:30 <tgeeky> tkahn6: that ^
18:17:33 <tkahn6> thanks
18:17:41 <tgeeky> ~/.cab in my (custom) case
18:17:47 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml has the full story
18:18:37 <tkahn6> tl;dr rm -Rf ~/.ghc ~/.cabal
18:18:38 <tkahn6> ?
18:18:49 <tkahn6> :)
18:19:05 <monochrom> in fact, ~/.cabal does not need to be nuked. totally harmless.
18:19:12 <tkahn6> interesting
18:19:21 <tkahn6> thanks i shall try this
18:19:24 <tgeeky> (in my case, it does, but I'm on windows with some nonstandard stuff)
18:19:47 <tkahn6> i'm on mac, i installed haskell-platform using homebrew
18:19:52 <parcs> i am disappoint, this would've been so awesome if it actually did what i want :(
18:19:54 <monochrom> well, if you essentially merge .ghc and .cabal by a cunning setting, sure
18:21:06 <tgeeky> monochrom: I think '.ghc' is in C:\Program Files(...)
18:21:41 <tgeeky> monochrom: but I am on msys/mingw, and my cabal config is in the "default" place, but all of my cabal files and downloads are inside the msys /home/username/.cabal
18:22:07 <tgeeky> you probably don't want to be tainted by Windows scum though
18:22:39 <monochrom> look for \Users\you\AppData\Roaming\ghc
18:23:15 <elliott> Is there a convenient way to install a handler to run when the current thread exits? Like wrapping the rest of the code in the thread with a "finally".
18:24:05 <monochrom> wrap the code with a "catch"
18:24:10 <tgeeky> monochrom: sure enough, thanks for that.
18:24:37 <elliott> monochrom: I could also just wrap it with a finally, like I said :P
18:25:18 <monochrom> that works too, if you don't distinguish different exceptions
18:25:22 <cads> hey monochrom, do you have time for a short, somewhat naive category theory question?
18:25:47 <monochrom> then again, the XY Problem suggest that maybe you mean "install a cleaner" not "install a handler"
18:26:00 <monochrom> I probably have time
18:26:31 <elliott> monochrom: Well, it is clean up of a sort, and it's not absolutely mandatory that it be run straight after the thread exits, but it should be run in a relatively timely manner after that, and having it not run at all isn't OK.
18:27:16 <visof> hello
18:28:01 <monochrom> I admit that "cleaner" and "handler" are not too different. prototypical XY Problems are of the scale of "how to solve x-5=6" and "how to solve math problems"
18:32:56 <cads> In the category of endofunctors we have a monad as a triple (F, m, u), were F is an endofunctor, m is a natural transform from F.F to F, and u is a natural transform from the identity functor to F. This is formally similar to a monoid object (A, m, u) in a category, except the monoid object morphisms are between products of the object.
18:33:13 <monochrom> interesting, the "hit" package reimplements git low-level operations
18:33:28 <cads> so eg. instead of m: F.F -> F we have m: AxA -> A
18:34:17 <cads> what I was wondering is if horizontal functor composition can be seen as taking a product
18:34:58 <cads> since then monads really _are_ monoid objects in the category of endomorphisms ;)
18:35:20 <monochrom> I actually don't know, but I heard that it's true
18:35:32 <rwbarton> cads, there is a kind of structure called a monoidal category
18:35:37 <cads> but I can't see that yet (what would be the projection arrows)
18:35:47 <rwbarton> there are no projection arrows, no
18:36:02 <monochrom> @quote monoidal
18:36:03 <lambdabot> lament says: category theory is just a fibered coproduct of the epimorphic functors in the category of categories of monoidal categories enriched with calcium
18:36:10 <monochrom> err
18:36:24 <tkahn6> how easy is it to learn category theory if you have taken a course on group theory?
18:36:44 <tgeeky> totally unrelated
18:36:48 <tkahn6> well shit
18:37:00 <cads> tkahn6: groups are basic kinds of categories
18:37:12 <monochrom> @quote PhilipWadler monoid
18:37:12 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
18:37:14 <tgeeky> for the most part, they aren't related
18:37:19 <monochrom> that one :)
18:37:33 <cads> you'd see them as basic examples, and it's illustrating to see how a group is specified in terms of diagrams
18:37:51 <tkahn6> i see
18:37:53 <tgeeky> the catsters has acceptable discussion of the (monad is a monoid in endo)
18:38:00 <rwbarton> cads: take a look at http://en.wikipedia.org/wiki/Monoid_%28category_theory%29 and http://en.wikipedia.org/wiki/Monoidal_category
18:39:09 <cads> rwbarton: so in a monoidal category we have another kind of multiplication from the usual products, allowing us to define monoid objects in a more general setting?
18:39:30 <rwbarton> but in brief, the cartesian product (assuming it exists) is one way to make a category into a monoidal category, but there can be others, and we can talk about monoid objects with respect to any chosen monoidal structure
18:39:48 <cads> and we can define that monoid product for functor categories as horizontal composition between functors?
18:40:09 <rwbarton> for endofunctor categories, yes
18:40:17 <cads> ah, cool
18:40:34 <cads> okay, that makes perfect sense
18:40:37 <Cale> cads: Yeah, so, instead of having a unit 1 -> M (where 1 is the terminal object) and multiplication M x M -> M (where x is categorical product), you have an arbitrary unit object and "monoidal product" functor
18:40:58 <Cale> (satisfying some obvious laws)
18:41:48 <Cale> and yeah, so in the endofunctor categories, 1 becomes the identity functor, and x becomes composition
18:42:44 <cads> I might be using the term 'horizontal composition' wrong
18:42:59 <Cale> Well, it's just the usual composition of functors
18:43:21 <Cale> Usually the distinction of horizontal/vertical is made for natural transformatiosn
18:44:16 <tkahn6> where did you guys learn category theory?
18:44:22 <Cale> (because if you have natural transformations F -> G and H -> K, you can glue them together to form a natural transformation FH -> GK
18:44:27 <ddarius> tkahn6: From the internet.
18:44:27 <Cale> )
18:44:28 <dolio> The streets.
18:44:33 <tkahn6> school (undergrad or grad) or on your own
18:44:41 <tkahn6> dolio, ddarius: lol
18:44:53 <Cale> Mostly from the internet. I took a course in algebraic topology at one point which gave me some basic stuff.
18:44:53 <tkahn6> street smart category theory
18:45:05 <Cale> and algebraic graph theory gave me some more
18:45:08 <tkahn6> can you guys recommend any good resources?
18:45:18 <monochrom> I read a book
18:45:24 <Cale> Awodey's text is my favourite intro
18:45:24 <Saizan> algebraic graph theory sounds cool
18:45:35 <ddarius> Algebraic graph theory sounds boring.
18:45:47 <Cale> It's got lots of colourful problems :)
18:45:52 <cads> Haha, it's interesting to note that Mac Lane says something slightly different than the quote attributed to him.
18:45:59 <Cale> (pun intended?)
18:46:14 <Cale> http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
18:46:17 <Cale> ^^ book
18:46:28 <tkahn6> thanks Cale
18:46:57 <cads> He actually defines monads in the chapter before he introduces monoidal categories
18:47:00 <dylukes> I own it in paper :<
18:47:03 <cads> "All told, a monad in X is just a monoid in the category of endofunctors of X, with product 'x' replaced by composition of endofunctors and unit set by the identity endofunctor" - Mac Lane pp. 135
18:47:09 <dylukes> I'm not a terrible person like you cale >:0
18:47:12 <dylukes> (:P)
18:47:15 <dylukes> (I jest)
18:47:21 <Cale> dylukes: wat
18:47:25 <dylukes> dead tree*
18:47:32 <Cale> http://cale.yi.org/share/Godsil,Royle-Algebraic%20Graph%20Theory-2001.djvu
18:47:41 <cads> he defines monoid objects in categories with finite product back near page 75
18:47:42 <Cale> ^^ algebraic graph theory text :)
18:47:47 <ddarius> cads: Those weren't quotes attributed to Mac Lane.  It's just a well-known fact.
18:47:56 <Cale> That book has lots of nice problems in it
18:48:00 <dylukes> brb
18:48:17 <tgeeky> brb, copyright infringing
18:48:28 <Cale> lololol
18:48:31 <rwbarton> hey, that's what IRC is for right?
18:48:35 <tgeeky> hehe
18:48:47 <tgeeky> i'll add that to my 300 GB collection of .e-book.technical
18:48:57 <ddarius> @quote lax.functor
18:48:58 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
18:49:00 <tgeeky> they should make a show about me called "Nerd Hoarders"
18:49:04 <ddarius> See how low I've brought copumpkin.
18:49:12 <Cale> I bought a copy of the textbook. Only fair that I can share it with 750 of my best friends.
18:49:22 <tgeeky> Cale: hehe
18:49:49 <monochrom> do you also share it with lambdabot and preflex?
18:49:49 <ddarius> Education institutions do it, and Cale probably qualifies as an educational institution.
18:49:56 <monochrom> hahaha
18:49:57 <Cale> Actually, the guy who wrote the textbook was my prof, and he followed the text closely enough that I didn't have to take notes :)
18:50:21 <cads> ddarius: hah, you're right; the quote was jokingly attributed to philip wadler; http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
18:51:09 <cads> rather, according to the first answer: http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem/3870310#3870310
18:51:15 <tgeeky> i get the feeling that such a definition would be improved by /s/just//
18:52:31 <monochrom> logicians write definitions like "x is a category just when ..." "just" and "when" combine to give you "iff"
18:52:34 <Cale> "Just" is a wonderfully pointless word introduced here simply for the air of superiority it lends to the definition.
18:52:53 <tgeeky> ^ and ^^ seem contradictory
18:53:16 <ion> ^_^
18:53:27 <cads> tkahn6: lawvere and shanuel wrote a very introductory book to categories called "Conceptual Mathematics", and a slightly more advanced book that builds a categorical version of set theory, called "Sets for Mathematics"
18:53:36 <monochrom> old-school british mathematicians write "when and only when", but that's just for theorems, not definitions.
18:53:36 <tgeeky> but that's just, like, my opinion, man, iff you give a shit
18:53:57 <Cale> whenn
18:53:59 <cads> tkahn6: if you've used categories before, the first is a bit boring, but it's at a level that can be taught even to highschoolers
18:54:04 <dylukes> Cale: this aggression will not stand.
18:54:11 <Cale> also, one and only one -> onee
18:54:12 <ion> How do you pronounce iff, btw? “if and only if”? “ifffffffffffff”?
18:54:23 <tgeeky> ion: angry!
18:54:25 <Cale> You pronounce it "if and only if"
18:54:33 <ion> cale: Alright, thanks.
18:54:43 <tkahn6> cads: interesting. I will check that out. probably should study for my stochastic processes exam tho :)
18:54:49 <cads> tkahn6: if you're comfortable with set theory, Sets for Mathematics is pretty good
18:54:49 <monochrom> you pronounce "s.t." and "ST" differently
18:55:09 <cads> tkahn6: probably :D
18:55:26 <tkahn6> cads: i'll check that out as well
18:55:34 <Cale> Lawvere's Sets for Mathematics is very heavily biased philosophically, but it's interesting nonetheless.
18:58:46 <monochrom> recursion is the best thing since recursion
18:59:27 <centrinia> That is almost tautological.
18:59:41 <JoeyA> How do you pronounce s.t. ?  ess-tee?
18:59:47 <monochrom> "such that"
18:59:51 <JoeyA> oh
19:00:37 <monochrom> fortunately, "TPS Report" is pronounced as "tee pee ess report" as expected :)
19:00:54 <cads> Cale: why do you say that? (I do know that lawvere really loves him some toposes - he even writes a paper about how to replace the foundations of general relativity with 'em)
19:02:27 <cads> monochrom: heh, I read that TPS reports are just "testing procedure specification" reports, and I though "hmm, sounds like a pretty sensible report."
19:03:12 <ddarius> Cale: Wouldn't you expect it to be very heavily biased philosophically?
19:03:53 <ddarius> Synthetic differential geometry is pretty slick.
19:04:40 <Cale> ddarius: Well, it was the first thing I'd read by Lawvere, so I didn't really have any expectations one way or the other. I guess it's not that surprising.
19:08:07 <Saizan> is there a good way to do synthetic stuff in type theory? (i.e. it seems to be a bad fit because it won't exploit evaluation)
19:10:52 <Eduard_Munteanu> ion: or "just in case", I guess :)
19:14:33 <cads> cale, I'm a little naive when it comes to what mainstream math philosophy is like. When I read something like Lawvere's Sets for Mathematics it seems normal to me; is it really biased against mainstream mathematical philosophy?
19:16:03 <cads> Do you remember any stances in particular that really stood out to you?
19:16:17 <tkahn6> are there any html scraping/parsing libraries besides tag soup?
19:22:32 <MatrixFrog> the quietest #haskell i've ever seen
19:23:15 <ion> You have never seen six minutes of silence of #haskell?
19:23:24 <MatrixFrog> perhaps only because i wasn't paying attention
19:23:27 <MatrixFrog> and i'm not in here that much
19:25:36 <iway> morning every one
19:25:42 <lambdanaut> Good morning!
19:26:15 <desaiu> Morning lambdanaut!
19:26:17 <monochrom> #haskell is quiet because I'm reading old mails
19:26:26 <MatrixFrog> mmk
19:26:43 <MatrixFrog> i'll go play portal 2 then. back in a while :P
19:27:07 <iway> cya MatrixFrog hf
19:29:00 <iway> somone of you using vim to programm in haskell? need a proper config any tips?
19:29:37 <dmwit> :set ai
19:30:01 <desaiu> Why is foldr called fold? I intuitively understand what map and filter list functions do, but I'm not quite grasping the reasoning for the world fold.
19:30:14 <dmwit> I also :set noet, ts=4, sts=4, and sw=4, but I imagine that would be a somewhat unpopular stance around here.
19:30:35 <shachaf> dmwit: noet?!
19:30:35 <dmwit> :set et (with the remainder the same) would probably get more applause.
19:30:38 <dmwit> Yes.
19:30:40 <dmwit> Really.
19:30:46 <JoeyA> What is noet?
19:30:52 <shachaf> Tabs instead of spaces.
19:30:53 <dmwit> noexpandtab -- use real tab characters
19:31:01 <JoeyA> *shudder*
19:31:08 * elliott likes tabs, but not for Haskell.
19:31:09 <dmwit> Not tabs instead of spaces. That's inaccurate.
19:31:10 <elliott> Too much alignment.
19:31:14 <dmwit> Tabs for indentation, spaces for alignment.
19:31:30 <hpaste_> tkahn6 pasted “errors” at http://hpaste.org/52305
19:31:36 <shachaf> dmwit: What's the point of sts=4 when ts=4?
19:31:44 <dmwit> shachaf: backspace
19:31:55 <JoeyA> When I started using spaces for indentation, I became more comfortable with things like case statements.
19:32:02 <JoeyA> Death to tabs!
19:32:15 <tkahn6> hey i'm having errors with assigning a value when using http-enumerator
19:32:25 <sal23> anyone knows about this error in cabal install of pango-0.12.1 (ghc 7.0.3, mac 10.7) - I googled it but didn't find anything relevant -  setup: The pkg-config package pango version <1.26.0 || >1.26.2 is required but
19:32:25 <sal23> it could not be found
19:32:26 <parcs> what's a good abbreviation for enumeratee?
19:32:38 <tkahn6> No instance for (Failure HttpException m0)
19:32:44 <parcs> maybe enumtee
19:32:49 <shachaf> dmwit: Oh, when you have tabs-then-spaces.
19:32:49 <parcs> or enumt
19:33:04 <tkahn6> numtee
19:33:42 <elliott> JoeyA: Eh?
19:33:52 <elliott> JoeyA: Indentation width is a separate issue from using tabs or not.
19:34:11 <shachaf> > sequence [head,last] "enumeratee"
19:34:12 <elliott> parcs: enumeratee
19:34:12 <lambdabot>   "ee"
19:34:12 <gienah> sal23: you can check the version with: pkg-config --modversion pango
19:34:30 <elliott> parcs: iterIO calls 'em Inums :P
19:34:34 <dmwit> JoeyA: I'm not sure I understand what spaces have to do with case statements.
19:35:53 <sal23> gienah: it says no package 'pango' found. But, I am trying to install pango, and that is where I get pkg-config error
19:36:19 <elliott> sal23: you need to install libpango-dev or similar
19:36:25 <dmwit> sal23: Did you install pango-dev from your (non-Haskell) package manager?
19:36:40 <sal23> that might be it…let me try
19:36:41 <gienah> sal23: you need the C pango library, as elliot and dmwit just advised
19:36:49 <cads> rwbarton, Cale, thanks for your answers to my questions earlier.
19:37:02 <cads> Gnite, all!
19:37:53 <iway> dmwit: you use 4 spaces? is this the recommendet size for haskell?
19:38:39 <dmwit> iway: No, I use tabs. However, most people use either two or four spaces.
19:38:44 <gienah> sal23: the haskell pango uses FFI to the C library pango, the pkg-config --modversion pango obtains information about the C pango
19:38:59 <iway> dmwit: ok thx
19:39:13 <sal23> gienah: cabal doesn't seem to have pango-dev in the list…no way to do cabal install of that?
19:39:28 <dmwit> iway: Note that the compiler treats literal tabs are treated as filler up to the next eight-space tabstop. I consider this a bug.
19:39:47 <gienah> sal23: you will need to use some macos specific method to install the pango C library
19:41:20 <sal23> gienah: any wiki/blog with step-by-step information on how to install pango C library on mac? installing threadscope is turning out to be more involved than I thought
19:41:50 <dmwit> sal23: Isn't there a gtk2hs binary installer for Mac on the gtk2hs website that includes the C libraries?
19:42:06 <gienah> sal23: I don't know anything about macos, I run gentoo, there are lots of haskellers that use macos
19:42:42 <dmwit> sal23: Hm, apparently not, but they do claim to be in MacPorts, whatever that means.
19:42:54 <sal23> dmwit: I ran into this issue when trying to build of gtk2hs
19:43:26 <dmwit> sal23: Do you need to build it yourself?
19:43:42 <dmwit> (Are you planning to modify gtk2hs?)
19:43:46 <sal23> dmwit: no
19:44:27 * gienah bumped threadscope and gtk to the current versions on gentoo
19:45:06 <dmwit> sal23: Okay, then I'd go with the website's recommendation of looking in MacPorts.
19:45:16 <kmc> dmwit, GHC treats the tabs as specified in the Report
19:45:16 <dmwit> Presumably that is supposed to take care of installing the required libraries for you.
19:45:23 <kmc> how would you rather it treat them?
19:45:36 <dmwit> kmc: Tabs and all other characters should have incomparable width.
19:45:54 <sal23> dmwit: what about fink install? I see it in fink list but which one - C++ interface for pango library or GTK+ dev headers etc.?
19:45:57 <kmc> *nod*
19:45:59 <kmc> that would be sensible
19:46:10 <kmc> it would enforce the only circumstances under which tab indentation is reasonable
19:46:15 <dmwit> Yes.
19:46:18 <companion_cube> dmwit: like, non-rational widths for tabs ?
19:46:26 <dmwit> companion_cube: No, like incomparable width.
19:47:05 <kmc> meaning if you have a line indented with tabs and another indented with spaces, and the layout algorithm wants to compare their indentation, it's a parse error
19:47:12 <ion> I use two spaces but i would switch to flexible tabs immediately if i could. http://en.wikipedia.org/wiki/Elastic_tabstop
19:47:24 <kmc> the rule of "don't use tabs, ever" is simpler and has served me well :)
19:47:32 <JoeyA> Why might cabal install start building a dependency, even though that dependency is available (and of the same version) ?
19:48:30 * dmwit -> bed
19:48:56 <ddarius> http://www.google.com/url?sa=t&source=web&cd=3&ved=0CDAQFjAC&url=http%3A%2F%2Fhomepages.inf.ed.ac.uk%2Fals%2FSCT%2Faltenkirch.pdf&rct=j&q=monads%20need%20not%20be%20endofunctors&ei=4LqPTqH7DYr00gHgzfEe&usg=AFQjCNHK2L1gKwuEVGMdDB17CVCdJ86wHA&cad=rja
19:49:01 <gienah> JoeyA: I don't know, maybe this *might* be worth a try: ghc-pkg check
19:49:17 <JoeyA> gienah: Prints nothing.
19:49:30 <gienah> JoeyA: nothing is good
19:49:40 <JoeyA> That's what I figured.
19:49:53 <gienah> JoeyA: not sure why cabal wants to rebuild the library of the same version
19:49:53 * ddarius needs to become a Google employee so he can find and kill the person who though putting hidden, indirect links for everything was a good idea.
19:50:49 <ion> It’s a good idea for *them*. :-P
19:51:22 <JoeyA> ddarius: When you find him, he'll just redirect you to someone else.
19:52:29 <JoeyA> And track your query to improve overall search results.
19:53:12 <Cale> cads: well, it's not *too* far out, in that he discusses the properties of sets which are probably important to most mathematicians. He's blatantly disregarding all the existing formalisms with respect to sets as he does it though, and ends up with something close to, but probably not quite equivalent to standard set theory.
20:00:48 <ddarius> Arrows = relative monads on Yoneda
20:09:30 <desaiu> As I was saying earlier, I can intuitively understand what map and filter do, but what does fold represent?
20:09:55 <tac> desaiu: fold is an aggregation
20:10:14 <kmc> > foldr f z [a, b, c]
20:10:15 <lambdabot>   f a (f b (f c z))
20:10:20 <kmc> @where folds
20:10:21 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
20:10:51 <tac> desaiu: Another way to say it is that folds transform the (:) into a function of your choice
20:11:09 <tac> with a suitable value for when you do it to the empty list
20:11:27 <kmc> desaiu, it reduces a list to a single value by applying a binary operator to every pair of elements
20:11:31 <tac> desaiu: The classic example is sum, which turns (:) into (+) and [] into 0
20:11:46 <tac> > foldr (+) [1,2,3]
20:11:47 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
20:11:47 <lambdabot>    arising from a us...
20:11:52 <kmc> so you can sum a list with «foldr (+)» or take the product of all elements with «foldr (*)»
20:11:57 <tac> > foldr (+) 0 [1,2,3]
20:11:58 <lambdabot>   6
20:12:09 <kmc> but you have to give a "base case" value for the empty list, which is usually an identity for whatever operation you're using
20:12:23 <edwardk> preflex: xseen ezyang
20:12:23 <preflex>  ezyang was last seen on freenode/#haskell 1 day, 8 hours, 42 minutes and 16 seconds ago, saying: Hmm, gonna try to install threadscope again
20:12:23 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
20:12:24 <kmc> > let sum = foldr (+) 0; product = foldr (*) 1 in (sum [1..10], product [1..10])
20:12:25 <lambdabot>   (55,3628800)
20:12:59 <desaiu> Ah, "reduces a list" or "folds it" into one value
20:13:17 <desaiu> I can visualize this
20:13:37 <kmc> desaiu, those diagrams are great, by the way
20:13:49 <kmc> among other things, it demonstrates why foldr is the more natural fold for lists
20:14:11 <kmc> foldr is just replacing the data structure of the list with a function of your choice
20:14:21 <kmc> while foldl implicitly reverses the list first
20:14:42 <shachaf> > foldr' (+) 0 [1..1000000]
20:14:45 <lambdabot>   500000500000
20:14:55 <desaiu> I'm confused with row 3 and 4 in column 1
20:15:09 <kmc> :t foldr1
20:15:10 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
20:15:12 <desaiu> I would have thought the f's on the right side would have been replaced with "1"
20:15:14 <kmc> it's a separate function
20:15:42 <kmc> desaiu, once you understand the simple examples, consider this identity:  map f = foldr ((:) . f) []
20:15:44 <shachaf> desaiu: foldr1 and foldl1 work on non-empty lists only, by taking the first/last element as the base case.
20:16:04 <desaiu> Oh wait, that's foldr for row 3 and foldl for row4
20:16:08 <desaiu> I thought they were both foldl
20:16:17 <kmc> desaiu, you can write 'map' and 'filter' using foldr... in fact, you can write *every* list function using foldr
20:16:29 <cwl> @src fix
20:16:29 <lambdabot> fix f = let x = f x in x
20:16:45 <desaiu> fold 1 f is confusing
20:16:50 <desaiu> foldr 1 f
20:16:56 <kmc> it's not foldr 1, it's foldr1
20:17:01 <cwl> > fix (\x -> 1: zipWith (+) (tail x) x)
20:17:01 <kmc> a different function named foldr1
20:17:04 <lambdabot>   mueval-core: Time limit exceeded
20:17:05 <kmc> :t foldr1
20:17:08 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
20:17:15 <shachaf> > foldr 1 f [a,b,c,d,e] :: Expr
20:17:16 <lambdabot>   1
20:17:40 <desaiu> I'll bookmark the diagrams and come back to them later
20:17:49 <desaiu> Going to make sure I finish this chpater in YAHT
20:17:58 <kmc> just note that it's not foldr 1, it's foldr1
20:18:04 <ion> > foldr 1f []
20:18:05 <lambdabot>   Ambiguous type variable `b' in the constraints:
20:18:05 <lambdabot>    `SimpleReflect.FromExpr ...
20:18:07 <desaiu> Also, thumbs up to this tutorial, it's an efficient use of my time
20:18:09 <ion> > foldr 1f [] :: Expr
20:18:09 <lambdabot>   f
20:18:29 <kmc> desaiu, you can do functional programming without data types at all.. you can represent any data by its fold function
20:18:34 <kmc> which is like http://en.wikipedia.org/wiki/Church_encoding
20:18:48 <shachaf> ion: You can do that?
20:18:52 <desaiu> bookmarked
20:19:04 <shachaf> > let blah = 'a' in 1blah
20:19:04 <lambdabot>   1
20:19:22 <elliott> ouch
20:20:01 <shachaf> Sadly I doubt there are many golfing opportunities that arise from that corner case of syntax.
20:20:01 <mauke> > 0xf0rd
20:20:02 <lambdabot>   Not in scope: `rd'
20:20:30 <ion> > let x = 42 in 0x0x
20:20:31 <lambdabot>   0
20:20:42 <ion> > let x = 42 in 0x0x0x0x0x0x0x
20:20:43 <lambdabot>   Not in scope: `x0x0x0x0x0x'
20:20:43 <mauke> > 0xz
20:20:44 <lambdabot>   Not in scope: `xz'
20:20:49 <ion> Oh, of course.
20:20:52 <desaiu> Can you do functional programming by replace data types with type classes?
20:21:02 <desaiu> s/replace/replacing
20:21:10 <shachaf> desaiu: What does that mean?
20:21:13 <mauke> desaiu: I don't think that question makes sense
20:21:14 <tkahn6> am i doing it wrong or is scraping content from html really tedious in haskell?
20:21:22 <desaiu> Great, it didn't make sense to me either
20:21:27 <tkahn6> python with pyquery is so nice
20:21:31 <desaiu> Glad we're all on the same page
20:21:45 <ion> tkahn6: There was something like Network.HTTP.Browser that may or may not be useful. I’ve been meaning to check it out.
20:21:47 <kmc> desaiu, not really; what would your class instances be?
20:21:50 <desaiu> I'm a few behind everyone, but I guess we're on the same book :)
20:22:01 <kmc> desaiu, type classes are not generally part of functional programming, anyway
20:22:07 <kmc> they're a weird side thing Haskell throws in
20:22:11 <kmc> useful, but I think they're overrated
20:22:24 <tkahn6> ion: i'd prefer to not have to do something like mechanize. i'd like to seperate pulling the raw html and parsing it
20:22:31 <desaiu> There was a video on replacing data types with type classes in Prelude. The vide is on vimeo.
20:22:46 <kmc> i don't think it's "replacing"
20:22:49 <joevandyk> where is NonEmpty defined?
20:22:53 <joevandyk> what package provides it?
20:22:54 <tkahn6> ion: i've been using tagsoup but it seems like a really primitive interface
20:23:04 <tkahn6> to traversing the DOM
20:23:05 <kmc> desaiu, the data types would still exist; you'd access them through a generic interface
20:25:04 <ddarius> kmc: With constraint kinds we could have the instances be other classes !! !! !!!
20:25:28 <kmc> omggggg
20:25:39 * MatrixFrog is back
20:25:43 <kmc> i have a feeling that extension is a big can of worms
20:25:44 <ion> tkahn6: Actually, Network.Browser does seem to separate HTTP from parsing the contents. I haven’t done any HTML parsing either yet.
20:25:54 <tkahn6> ion: i'll check that out then
20:25:59 <kmc> perhaps they are friendly, helpful, delicious worms
20:26:55 <ddarius> kmc: From at least one conceptual perspective, it rather straightforward.
20:28:46 <ddarius> "Men's God Encounter Weekend"
20:28:54 <shirt> is it still the case in ghc 7.2 that haskell programs don't free memory back to the os?
20:29:08 <ion> tkahn6: http://hackage.haskell.org/package/Webrexp perhaps
20:29:19 <kmc> shirt, i think that was fixed in 7.0, but I don't have any evidence
20:29:27 <tkahn6> ion: that could be exactly what i'm looking for
20:30:01 <shirt> kmc: ok. btw i successfully used existential types in my program :)
20:30:23 <kmc> cool
20:30:36 <kmc> shirt, was the code nice?
20:31:09 <ddarius> or was it naughty?
20:31:15 <shirt> kmc: yeah, it was just what i needed. just had to use existentials in a small isolated place
20:31:30 <kmc> cool
20:33:35 <LuisRicardo> 1
20:34:43 <tnks> It feels like both a category and a monoid share identity, associativity, and closure.
20:34:56 <tnks> how does one meaningfully separate the abstractions?
20:34:57 <ddarius> Composition in a category is not closed.
20:35:17 <ddarius> That is what distinguishes a (small) category from a monoid.
20:35:43 <kmc> tnks, categories are "typed monoids"
20:36:26 <kmc> in a monoid you can compose any two elements;  in a category the elements (morphisms) have "types" of the form (A -> B), and you can only compose when the types match in the manner of ordinary function composition
20:36:47 <kmc> viz.:  (B -> C) composes with (A -> B)  to form a morphism of "type" (A -> C)
20:37:06 <kmc> "type" Is not the standard terminology, but it's the terminology that made the most sense to me as a programmer
20:37:30 <kmc> tnks, then you can think of a monoid as a category with only one type
20:38:04 <tnks> kmc: catching up.
20:38:04 <ddarius> I think many categorists would readily understand using the term "type" for "object."
20:38:29 <kmc> sure, people may understand my wrong terminology even if it's not what they'd use ;)
20:39:11 <LuisRicardo> .part
20:39:14 <LuisRicardo> sorry
20:40:41 <tnks> kmc: ddarius: both responses made sense.
20:41:13 <kmc> cool :)
20:41:56 <tnks> Actually, this connects with Pierce's description of the "Mon" category in his book.
20:42:45 <ddarius> "This rule states that the substitution into the derivation shows that the substitution into the context entails the substitution into the proposition."
20:42:54 <tnks> which is just one object with an infinite number of morphisms connecting it to itself.
20:43:41 <kmc> doesn't have to be infinite
20:43:46 <kmc> some monoids have a finite number of elements
20:44:05 <tnks> kmc: right, I over extended it.
20:44:39 <tnks> I don't have the book open in front of me.
20:46:15 <ddarius> It is nevertheless odd that you would jump to that conclusion.
20:46:40 <sal23> is there any option in cabal to tell it where a library is installed? I installed pango through macports. I tried --libdir option but that didn't work
20:46:46 <kmc> (indeed, some monoids have one element)
20:47:09 <ddarius> One monoid, up to isomorphism.
20:47:19 <JoeyA> sal23: Stealing the example from http://hackage.haskell.org/trac/ghc/wiki/Builder   :  cabal install --extra-include-dirs="c:/OpenSSL/include" --extra-lib-dirs="c:/OpenSSL"
20:47:20 <kmc> right
20:47:24 <ddarius> (up to unique isomorphism no less)
20:49:58 <ddarius> @tell edwardk I imagine you'd have some fun with this: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.156.7931
20:49:59 <lambdabot> Consider it noted.
20:50:08 <edwardk> ?
20:50:08 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
20:50:15 <edwardk> ah yes
20:50:17 <edwardk> read that one
20:50:28 <sal23> JoeyA: thanks…that didn't work either…still getting same error "The pkg-config package pango version <1.26.0 || >1.26.2 is required"
20:50:49 <JoeyA> :(
20:51:53 <ddarius> edwardk: I imagined you might've.
20:53:01 <edwardk> dolio and copumpkin mentioned it at work a few months ago. we were playing with a few things that at the time we thought might fit that profile
20:55:44 <hpaste_> gienah pasted “pango gentoo pkgconfig” at http://hpaste.org/52306
20:55:56 <gienah> sal23: you need to make the pkg-config stuff work
20:56:10 <tnks> is an idiom a synonym for an applicative functor?
20:56:26 <elliott> gienah: they /quit
20:57:00 <gienah> elliott: thanks
20:59:42 <ddarius> edwardk: I need to return your books some time.
20:59:46 <dolio> It's kind of odd. I think all the examples in that paper fall into the 'restricted monad' class.
20:59:57 <edwardk> fair nuff
21:00:13 <edwardk> i'm heading up to the gym now, maybe this weekend?
21:00:16 <dolio> Despite the theory being more general than that.
21:00:24 <edwardk> yeah
21:00:24 <ddarius> Is an arrow a restricted monad?
21:01:51 <dolio> Which meaning of arrow?
21:02:14 <ddarius> As in the Freyd category kind.
21:02:57 <dolio> Not off the top of my head.
21:03:50 <DanBurton> @where arrow
21:03:51 <lambdabot> I know nothing about arrow.
21:03:58 <DanBurton> boo
21:04:09 <dolio> A restricted monad is a relative monad from the paper, where the source category is a subcategory of the target category, and the monad is relative to the inclusion functor.
21:04:09 <DanBurton> @botsmack
21:04:10 <lambdabot> :)
21:04:12 <ddarius> Relative adjunctions seem a bit grotty to me.  Next we'll be talking about birelative adjunctions Hom(FX,JY) ~ Hom(KX,UY)
21:04:54 <ddarius> dolio: Well an arrow is a relative monad on Yoneda which is an embedding, though not an identity-on-object inclusion.
21:05:07 <dolio> So it's rather close to still being an endofunctor.
21:05:46 <ddarius> Well, I guess the next thing would be to consider monads on functors like !.
21:05:46 <desaiu> How can I find subroutines, or whatever they're called, for a function? e.g. Char.toUpper, I wouldn't have been aware of that without YAHT
21:05:58 <dolio> Does that paper have that example? I don't remember it.
21:05:59 <desaiu> even when I type out Char.<tab> nothing is shown
21:06:16 <ddarius> It doesn't have a relative monad on !.
21:06:18 <desaiu> Are they called methods?
21:06:23 <ddarius> Oh man.
21:06:28 <Rotaerk> lol
21:06:33 <JoeyA> desaiu: They're functions defined in a module
21:06:42 <desaiu> Ah!
21:06:56 <dolio> ddarius: Does it have the arrow one?
21:06:59 <ddarius> Yes.
21:07:04 <dolio> Oh, okay.
21:07:23 <ddarius> dolio: What have you been up to?
21:07:43 <kmc> desaiu, you can search on Hoogle, or browse the docs at http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html
21:07:43 <dolio> Not too much. I finally got a bed.
21:08:07 <dolio> So now I can lie around 3 1/2 feet above the floor.
21:08:57 <desaiu> isUpper :: Char -> Bool
21:09:01 <ddarius> What were you using before?
21:09:07 <dolio> An air mattress.
21:09:25 <DanBurton> > (isUpper 'A', isUpper 'a')
21:09:26 <lambdabot>   (True,False)
21:09:33 <shachaf> dolio: Calcium?
21:09:36 <shachaf> Oh, just a bed.
21:09:47 <dolio> I also bought some cast iron cookware, so I've been playing around with that off and on.
21:09:55 <ddarius> Nice.
21:10:02 <dolio> The seasoning on one is chipping, though.
21:10:17 <dolio> Hopefully I don't have to restart it.
21:10:18 <desaiu> If they are functions defined in a module, isUpper would have incorrect case since functions start with upper case characters
21:10:24 <kmc> desaiu, no they don't
21:10:43 <ddarius> desaiu: Where are you getting this nonsense?
21:11:04 <desaiu> > map Char.isUpper [1,2,3]
21:11:05 <lambdabot>   Not in scope: `Char.isUpper'
21:11:23 <kmc> "Char" there is a module name
21:11:27 <kmc> a qualified name
21:11:37 <kmc> if you import Char (or probably Data.Char) you can use it without the qualifier
21:11:38 <tkahn6> > map Data.Char.isUpper [1..3]
21:11:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
21:11:39 <lambdabot>    arising from the literal `1...
21:12:29 <desaiu> Oh, I'm wrong. "Haskell requires that the names given to functions and values begin with a lower-case letter and that the names given to types begin with an upper-case letter"
21:12:39 <kmc> yes
21:12:49 <ddarius> dolio: Want to spend $150 to "Come make JavaScript the language for business, from top to bottom."
21:12:52 <kmc> though instead of "functions or values" i would say "variables"
21:12:58 <kmc> especially because functions are values
21:13:01 <kmc> > map isUpper "AБจדε"
21:13:02 <lambdabot>   [True,True,False,False,False]
21:13:15 <dolio> ddarius: Probably not.
21:13:44 <elliott> desaiu: Have I mentioned you should really read LYAH instead? :-)
21:13:44 <desaiu> > map isUpper ['a','b','c','D']
21:13:45 <lambdabot>   [False,False,False,True]
21:13:49 <desaiu> > map Char.isUpper ['a','b','c','D']
21:13:50 <lambdabot>   Not in scope: `Char.isUpper'
21:14:08 <DanBurton> > map Data.Char.isUpper "abcD"
21:14:09 <lambdabot>   [False,False,False,True]
21:14:14 <kmc> desaiu, data constructors also get upper-case letters.  they can act like functions, but they don't have any code attached, and you can pattern-match against them
21:14:47 <desaiu> elliott: it's not for me, i prefer straight to the point
21:14:55 <desaiu> I'm not a fan of its style
21:15:19 <elliott> shrug -- RWH is pretty straight to the point :P
21:15:25 <kmc> sort of
21:15:33 <elliott> a bit too much, perhaps :p
21:15:49 <ddarius> dolio: But you could help promote "JavaScript as a singular language for business solutions, throughout the application stack."  Don't you want to see "JavaScript on the back-end, in the datastore, and in between: JavaScript everywhere?"
21:15:57 <kmc> RWH is kind of "here's an ugly three page program because we're insecure about the fact that everyone thinks Haskell is not useful for practical programs"
21:16:01 <desaiu> I like YAHT's style better than RWH, I'll probably read the reports afterward
21:16:12 <ddarius> All of them?
21:16:14 <kmc> desaiu, you could read the Gentle Introduction after YAHT or whatever
21:16:15 <desaiu> Yes
21:16:23 <elliott> desaiu: All of them?
21:16:26 <elliott> Why?
21:16:27 <desaiu> Yes
21:16:33 <elliott> There's tons and all but one are obsolete.
21:16:36 <joevandyk> Can someone explain to me why this is reverse?  foldl (flip (:)) [] xs
21:16:39 <dolio> ddarius: Are you required to be involved in this or something?
21:16:40 <elliott> And all of them are largely identical.
21:16:45 <kmc> @where folds
21:16:45 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
21:16:47 <kmc> joevandyk, ^^^^
21:16:54 <DanBurton> @where typeclassopedia
21:16:54 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
21:16:55 <desaiu> elliott: I want an intimate knowledge of the language
21:17:04 <kmc> desaiu, then read the Haskell 2010 report
21:17:06 <elliott> desaiu: The language is defined by the latest report.
21:17:14 <elliott> The other reports define other, obsolete languages, that people do not use any more.
21:17:16 <desaiu> I'm thinking of going 98 -> 2010
21:17:26 <elliott> 2010 is a very minor variation on 98.
21:17:27 <shachaf> desaiu: Courageous and innovative!
21:17:28 <ddarius> dolio: Good God no.
21:17:36 <dolio> Well, that's a relief.
21:17:38 <elliott> _Very_ minor.
21:17:52 <kmc> i'm getting the feeling people consider YAHT of low quality
21:18:04 <desaiu> I don't think it is.
21:18:13 <DanBurton> 2010 is 98 without n+1 patterns but with the ffi
21:18:26 <elliott> DanBurton: View patterns and that parsing bugfix too.
21:18:28 <kmc> there are a few other differences
21:18:35 <kmc> 2010 does not have view patterns
21:18:37 <kmc> it has pattern guards
21:18:39 <elliott> Erm.
21:18:39 <ddarius> DanBurton: The FFI was already a ratified addendum to Haskell 98.
21:18:41 <elliott> Pattern guards, yeah.
21:18:43 <kmc> we definitely should have more than two high-quality tutorials
21:18:49 <desaiu> I read quite a ways into 98 before I realized, I need to start out a little easier
21:18:56 <kmc> LYAH and RWH both have strong styles and I can see that people might be annoyed with both
21:19:03 <kmc> desaiu, what would you like to see in a Haskell tutorial?
21:19:05 <elliott> desaiu: but seriously, just skip 98 and go straight to 2010, you'll barely be able to tell the difference between the two, and at least one of the differences is what every implementation did all along
21:19:11 <ddarius> kmc: We have the Gentle Introduction.
21:19:25 <tkahn6> tangentially related to isUpper discussion: if you xor an ascii letter with 32 it will flip the case
21:19:43 <dolio> edwardk: You still here?
21:19:55 <desaiu> kmc: What's I'm seeing in YAHT, straight to the point of stuff that matters
21:20:19 <tnks> I don't really look at RWH as a "high quality tutorial"
21:20:20 <desaiu> LYAH seems like it would appeal to people completely new to programming
21:20:37 <tnks> I feel Graham Hutton's book is pretty good for an introduction.
21:20:40 <tkahn6> RWH gets boring real fast
21:20:48 <shachaf> tnks: Yes. It's not aavailable online, though.
21:20:51 <ddarius> Read the Gentle Introduction.
21:21:04 <desaiu> I get distracted easily in RWH with the comments, I learn a lot from them, but I still get distracted
21:21:40 <desaiu> It also takes longer to get to the points than YAHT
21:21:55 <desaiu> Speaking of YAHT, I'm going to try and finish this chapter :)
21:22:08 <desaiu> Thanks for the help concerning isUpper and finding documentation on modules
21:22:40 <kmc> i like RWH's topics chapters
21:22:44 <JoeyA> HsOpenSSL depends on both GMP and OpenSSL.  GMP is LGPL, while OpenSSL has a copyleft license (according to http://www.gnu.org/licenses/license-list.html ) that is not compatible with the GPL.
21:22:51 <tnks> actually, someone gave me a copy of Bird's book for free, but I haven't really gone through it.
21:22:52 <kmc> it has the best intro to FFI and best intro to STM i've seen
21:22:59 <tnks> I forgot it was on the shelf.
21:23:00 <desaiu> I'm going to pick and choose my chapters from RWH later on
21:23:00 <kmc> and some good advice on performance tuning etc
21:23:26 <desaiu> Thanks for that kmc, I'll make a note to check those out
21:23:33 <JoeyA> This means binaries built with HsOpenSSL need to distribute source or object files as well.  Is my assessment correct?
21:23:47 <JoeyA> need to be distributed with*
21:25:59 <kmc> JoeyA, if the OpenSSL license is truly incompatible with LGPL, then you couldn't distribute them at all
21:26:33 <kmc> maybe GNU is using "incompatible" to mean something different
21:26:48 <kmc> the bottom line is just that you need to comply with the terms of all those licenses
21:26:55 <JoeyA> Note that I said "not compatible with the GPL", not LGPL
21:27:22 <JoeyA> If gmp were licensed under the GPL, then HsOpenSSL would not be distributable at all.
21:27:28 <JoeyA> (if I understand correctly)
21:28:33 <kmc> well HsOpenSSL itself is probably fine
21:28:53 <kmc> but binaries built with HsOpenSSL and its dependencies
21:29:25 <kmc> it's a common misconception that a library must inherit the licenses of its dependencies
21:29:38 <kmc> i've received hate mail for writing a library under a less restrictive license that depends on one with a more restrictive license
21:29:43 <kmc> it's a totally reasonable thing to do
21:30:01 <kmc> one reason is that the depended-on library might change license
21:30:04 <kmc> (this has happened to me)
21:30:46 <kmc> another is that someone might create a work-alike replacement (which has happened many times in the history of free software)
21:31:23 <kmc> another is that people might want to study and use bits of your code that don't depend on the more-restrictive library
21:32:05 <desaiu> Bad internet connection, sorry about that.
21:32:28 <JoeyA> I understand that the effective license of a package (including dependencies) is distinct from the license of the code itself.
21:32:32 <desaiu> I downloaded the Haskell platform to look at the source code of Data.Char
21:32:52 <kmc> the source probably isn't in  what you downloaded
21:32:52 <desaiu> Is packages/parsec-3.1.1/Text/Parsec/Char.hs what I need to be looking at?
21:32:59 <elliott> no
21:33:15 <kmc> desaiu, the docs at http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html have 'source' links
21:33:30 <kmc> as do the individual packgaes on Hackage
21:33:34 <kmc> e.g. http://hackage.haskell.org/package/base
21:33:57 <kmc> if you really want to download a source tarball, you'll find it on that page
21:34:10 <kmc> though 'base' is distributed with GHC, so you can't actually build and upgrade it without upgrading GHC
21:34:25 <JoeyA> http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/src/Data-Char.html
21:34:28 <JoeyA> That's part of the story
21:34:53 <JoeyA> You can find the source for what it imports by following links starting from: http://hackage.haskell.org/package/base-4.4.0.0
21:35:29 <desaiu> Thanks kmc
21:36:07 <desaiu> I would like to grab them for viewing offline as well, is the Haskell platform not what I need?
21:36:27 <JoeyA> Grab the source, or the documentation?
21:36:29 <desaiu> JoeyA: Sorry, didn't see your link, but that's what I was viewing
21:36:40 <desaiu> Is the Haskell platform the source?
21:36:48 <desaiu> If I grab the .tar.gz
21:36:54 <kmc> there's more than one .tar.gz
21:36:58 <desaiu> And if it is, where is that file located?
21:37:05 <kmc> the Haskell Platform is a specification for a set of libraries
21:37:14 <desaiu> haskell-platform-2011.2.0.1 is what was fetched
21:37:15 <kmc> it does not mandate whether you download those libraries in source or binary form
21:37:40 <kmc> desaiu, that will contain the source for the libraries in Platform which *don't* come with GHC
21:37:43 <kmc> like parsec, as you found
21:38:10 <kmc> if you want everything, you can also fetch http://haskell.org/ghc/dist/7.0.4/ghc-7.0.4-src.tar.bz2
21:38:27 <kmc> depending on how you installed GHC, you may already have hyperlinked source like the one online installed
21:38:57 <kmc> if you install Platform through Debian you get file:///usr/share/doc/ghc-doc/html/libraries/index.html
21:40:04 * ddarius doesn't know why anyone would knit American style.
21:46:37 <joevandyk> for checking if a list is not empty, "not (null list)" is the way to go, right?
21:46:53 <kmc> pattern matching is probably better
21:47:06 <kmc> if you actually need a Bool, then what you wrote is fine
21:47:48 <kmc> but if you're doing control flow, pattern matching is probably better
22:22:22 <__d__> quit
22:22:59 <joevandyk> > :t enumFromTo 1
22:23:00 <lambdabot>   <no location info>: parse error on input `:'
22:23:09 <joevandyk> > enumFromTo 1
22:23:10 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> [t])
22:23:10 <lambdabot>    arising from a use of...
22:23:20 <hpaste_> DanBurton pasted “IO Int is a Monoid?” at http://hpaste.org/52307
22:24:37 <joevandyk> @type enumFromTo 1
22:24:38 <lambdabot> forall t. (Num t, Enum t) => t -> [t]
22:25:03 <joevandyk> @type enumFromTo 'a'
22:25:04 <lambdabot> Char -> [Char]
22:25:38 <joevandyk> i'm unclear why the type of the first is (Num t, Enum t) => t -> [t]
22:25:42 <DanBurton> Do you guys think this is just due to UndecidableInstances...not being able to decide, even though it should be able to?
22:25:44 <joevandyk> Why the Enum t ?
22:26:11 <DanBurton> joevandyk: beeeeeecayse of the "enum" part of "enumFromTo"
22:26:20 <DanBurton> *cause
22:26:24 <shachaf> DanBurton: IO is a monoid in the category of endofunctors.
22:26:27 <shachaf> DanBurton: IO Int isn't a monoid.
22:26:38 <joevandyk> DanBurton: why not just a Num?
22:26:52 <DanBurton> joevandyk: other stuff can be enumerated
22:27:05 <DanBurton> > enumFromTo 'a' 'e'
22:27:06 <lambdabot>   "abcde"
22:27:15 <DanBurton> > enumFromTo False True
22:27:16 <lambdabot>   [False,True]
22:27:28 <joevandyk> DanBurton: yes, i get that.   but enumFromTo 1 'z' doesn't make sense
22:27:43 <joevandyk> @type enumFromTo 'a'
22:27:43 <lambdabot> Char -> [Char]
22:27:47 <joevandyk> that type is different
22:27:57 <joevandyk> i was expecting the type to be Num -> [Num]
22:28:15 <kmc> Num isn't a type
22:28:26 <DanBurton> shachaf: so can you describe why the "overlapping instance" for getMultLines' ?
22:28:45 <DanBurton> He means (Num t) => t -> [t]
22:29:02 <DanBurton> instead of (Num t, Enum t) => t -> [t]
22:29:05 <DanBurton> oh I know though
22:29:16 <DanBurton> I guess not all Nums are enumerable?
22:29:19 <kmc> correct
22:29:26 <wavewave> yeah~~ succeeded in installing cabal-install with ghc 7.2.1
22:29:30 <kmc> real numbers are not enumerable
22:29:31 <shachaf> Only Nums that have an 'E'.
22:29:39 <kmc> cool wavewave
22:29:45 <DanBurton> >enumFromTo 1.1 1.3
22:29:50 <joevandyk> shachaf: that what?
22:29:51 <DanBurton> > enumFromTo 1.1 1.3
22:29:51 <lambdabot>   [1.1]
22:30:05 <kmc> the Enum instances for Float / Double are such a bad idea
22:30:06 <shachaf> joevandyk: «have an 'E'»
22:30:09 <shachaf> As in 'E'Num
22:30:10 <DanBurton> yeah..
22:30:11 <wavewave> bootstrap.sh in the recent version of cabal-install is not compatible with ghc 7.2
22:30:23 <DanBurton> > succ (1/7)
22:30:24 <lambdabot>   1.1428571428571428
22:30:42 <wavewave> @src succ
22:30:42 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:30:42 <NemesisD> anyone know why hackagedb tries to build on 7.2? i thought platform wasn't even at that version
22:30:44 <joevandyk> oh.. i see
22:30:55 <DanBurton> :t succ
22:30:56 <lambdabot> forall a. (Enum a) => a -> a
22:30:57 <joevandyk> @type enumFromTo (1::Int)
22:30:58 <lambdabot> Int -> [Int]
22:31:03 <kmc> NemesisD, do you think they should only build on Platform versions?
22:31:13 <wavewave> NemesisD : to support the newest version of ghc.
22:31:13 <rwbarton> DanBurton: contexts in instance declarations do not guide instance selection
22:31:20 <NemesisD> kmc: does it build on multiple versoins or just 7.2?
22:31:21 <kmc> NemesisD, the point of releasing GHC before the accompanying Platform is so that library maintainers can deal with breakage before it affects end-users
22:31:27 <wavewave> NemesisD: in fact, that is very important information
22:31:28 <kmc> i think it only builds on 7.2
22:31:32 <kmc> it would be nice to do both 7.0 and 7.2
22:31:40 <DanBurton> rwbarton: ahhhhhh thanks. Why not, though?
22:31:42 <NemesisD> well it makes it hard for me to troubleshoot if i use platform
22:32:26 <rwbarton> well ideally adding new, nonoverlapping instances should not cause your program to stop compiling
22:33:00 <NemesisD> hmm, would that prevent docs form being compiled?
22:33:03 <rwbarton> conceptually there may well be an instance for Monoid (IO Int) that this particular part of your program just doesn't know about
22:33:04 <wavewave> NemesisD: I cannot imagine hackageDB strategy can make somebody using platform hard to troubleshoot. would you explain your problem?
22:33:19 <NemesisD> evidently the rfc3339 package hits the dirt on 7.2
22:33:28 <wavewave> ahh. documentation.
22:34:03 <desaiu> I have one more question before I call it a night, I created a Test.hs file as prescribed in YAHT. In it, there are five lines, 1: module Main 2: where 3: x = 5 4: y = (6, "Hello") 5: z = x * fst y
22:34:13 <desaiu> How do I import this file as a module in ghci?
22:34:26 <shachaf> ghci Test.hs
22:34:29 <shachaf> Oh, import?
22:34:32 <shachaf> You can't, I think.
22:34:33 * wavewave is now building yesod on top of fresh new ghc-7.2
22:35:17 <shachaf> desaiu: That file won't compile, by the way.
22:35:19 * wavewave thinks yesod has very big dependency of packages, so good for checking. 
22:35:31 <desaiu> Also, when I load the file using ghci Test.hs from the command line, the prompt is *Module>, why is there a star there, and why isn't it Test>
22:36:04 <NemesisD> giess i have to wait on the author to fix their stuff
22:36:17 <rwbarton> the * means the module is "open" so that you can see even definitions that are not exported
22:36:34 <desaiu> Oh sorry, I meant, module Test
22:36:37 <rwbarton> and, what is the actual first line of your file
22:36:39 <desaiu> and it reads *Test>
22:36:46 <rwbarton> well there you go
22:36:46 <wavewave> NemesisD: rfc3339 is built on ghc 7.0. Does it make a trouble for you to use platform and rfc3339?
22:36:47 <desaiu> instead of the expected Test>
22:37:30 <desaiu> What is the star and why can't I import the file by doing :m Test
22:37:45 <rwbarton> I just said what the * means
22:38:03 <desaiu> I see, sorry for missing that
22:38:34 <NemesisD> wavewave: nope. works great on my system, just kinda irked someone viewing the package page can't see any docs
22:38:41 <rwbarton> as for why :m Test doesn't work, no idea, sorry.  I just use :load or the equivalent
22:38:54 <desaiu> Lastly, then, why am I not able to import it using :m Test
22:39:05 <desaiu> Oh
22:39:23 <desaiu> That works
22:39:52 <desaiu> Maybe :m is set to look at a certain directory indicated by some ghci environment variables
22:40:13 <rwbarton> what version of ghci are you using?
22:40:23 <desaiu> 6.12.3
22:41:30 <wavewave> NemesisD: right now, rfc3339 page shows documentation correctly. If the documentation couldn't be shown due to ghc 7.2, for the time being, one need to go back to hackage webpage of previous version of the library for checking the documentation. a little cumbersome, but not serious though in most cases.
22:42:20 <wavewave> NemesisD: it seems that new hackage2.0 server will be ready soon.. so we will have very smooth workflow then.
22:42:27 <elliott> IMO it's a feature if packages broken on latest ghc have a downgraded experience :-)
22:42:54 <desaiu> I forget the command to see the env variables
22:43:13 <wavewave> elliott: alerting maintainer. ;-)
22:43:40 <ddarius> IO Int is a monoid in several ways.
22:43:44 <elliott> desaiu: "env"?
22:43:47 <elliott> or "set" on windows
22:43:55 <elliott> ddarius: I was just about to point that out :(
22:45:06 <wavewave> about this, I would like to have some options that FFI library can be compiled on hackage without required external library so to provide only documentation.
22:45:13 <kmc> yes
22:45:33 <wavewave> many library has broken documentation indeed.
22:45:56 <wavewave> I guess it's not searchable, either in hoogle.
22:47:28 <desaiu> import System
22:47:39 <desaiu> --Wait I mean
22:47:47 <desaiu> import System.Environment
22:48:00 <desaiu> System.Environment.getEnvironment
22:48:14 <kmc> you don't use the full name once you've imported it
22:48:19 <kmc> you'd just say getEnvironment
22:48:25 * hackagebot googleplus 0.2.2 - Haskell implementation of the Google+ API  http://hackage.haskell.org/package/googleplus-0.2.2 (MichaelXavier)
22:48:34 <kmc> you can do "import qualified" but it's more common to do that with a shortname
22:48:36 <desaiu> Those aren't specific to ghc though
22:48:56 <desaiu> I use the tab completion, so that's why I do it
22:48:58 <kmc> import qualified System.Environment as E
22:49:03 <kmc> then you use E.getEnvironment
22:49:11 <desaiu> Very nice!
22:49:21 <kmc> your code will not be readable if you use full module names everywhere
22:49:40 <ddarius> import qualified Monad as Because.I.Can
22:50:49 <wavewave> Because.I.Can.liftM
22:50:58 <wavewave> Because.I.Can.ap
22:51:32 <desaiu> import GHC.Environment as GE
22:51:33 <desaiu> <interactive>:1:0: parse error on input `import'
22:51:49 <kmc> you can't use "import" at the GHCi prompt in GHC 6
22:51:52 <kmc> you can in GHC 7
22:52:00 <kmc> instead do:   :m + GHC.Environment
22:52:05 <kmc> (why GHC.Environment not System.Environment?)
22:52:11 <wavewave> kmc: oh.. can we? didn't know that ;-D
22:52:34 <kmc> desaiu, it's not so common to use the GHC.* modules yourself
22:52:44 <kmc> they're mostly used in implementing the "standard" modules
22:52:54 <desaiu> It didn't show anything I was wanting anyway
22:53:13 <desaiu> I'm looking for a module.function which shows the module paths
22:53:22 * wavewave think that GHC modules are very dangerous unsafe place. ;-)
22:53:29 <kmc> desaiu, meaning what?
22:53:41 <desaiu> system paths
22:53:50 <desaiu> I'm wanting to know where ghc is looking for the modules
22:53:55 <shachaf> Does anything reëxport the functions in GHC.Exts?
22:54:23 <shachaf> desaiu: Why?
22:54:29 <kmc> desaiu, look into the 'ghc-pkg' command
22:54:31 <wavewave> desaiu: do you need any special use case?
22:54:40 <shachaf> desaiu: It's not going to let you import a module from inside ghci, as far as I know.
22:54:41 <desaiu> I'm trying to figure out why Test.hs wasn't an option to import
22:54:53 <shachaf> desaiu: Just :load it.
22:54:55 <shachaf> Or "ghci Test.hs".
22:55:14 <desaiu> I understand that, but I want to know _why_ it didn't :)
22:55:53 <NemesisD> hmm, versioning semantics question. for a library package, if there are new API functions, additive only, would it bump the minor version or the patch version
22:56:09 <desaiu> kmc: Do you know why 7.* is going to be available in cabal?
22:56:27 <kmc> desaiu, you don't get GHC through Cabal; that's backwards
22:57:21 <wavewave> NemesisD : are you asking about PVP ?
22:57:24 <desaiu> apt-get install cabal-install && cabal update && cabal install cabal-install
22:57:32 <NemesisD> wavewave: pvp?
22:57:42 <desaiu> That's backwards as well, so I figured, it couldn't hurt to download ghc
22:57:43 <shachaf> desaiu: Because it doesn't.
22:57:47 <desaiu> It's listed as a package
22:58:03 <rwbarton> that's the ghc package
22:58:03 <wavewave> http://www.haskell.org/haskellwiki/Package_versioning_policy
22:58:05 <kmc> you can't upgrade ghc (or base, or ghc-prim, etc.) through cabal
22:58:11 <kmc> any of the packages that come with ghc
22:58:18 <rwbarton> which is the API to bits of the ghc compiler itself
22:58:53 <wavewave> NemesisD: that's common consensus. it's a good article to read.
22:59:23 <kmc> cabal-install doesn't come with ghc
22:59:45 <NemesisD> ah that is a good one. and it looks like additive changes fall under minor
23:00:03 <wavewave> NemesisD: about your specific question, if it just add new interfaces only, then you can version up, say, from 1.1.2 to 1.1.3
23:01:00 <kmc> that's annoying because people who depend on those new features need to depend on a third-component number
23:01:01 <wavewave> NemesisD: yes.
23:01:08 <kmc> i like to specify deps to only 2 places
23:01:38 <kmc> it's not like version numbers are a scarce resource
23:01:42 <NemesisD> i didn't look it like that
23:01:46 <kmc> seems like the average cabal package is on version 0.0.something
23:01:53 <kmc> seems like we're not making effective use of the top numbers ;)
23:02:32 <NemesisD> well when i write a package i usually grab the latest version and lock it in my cabal file and make the upper bound the next B number in A.B.C
23:02:42 <wavewave> kmc: basically PVP is rather too strict for applying for earlier development and later development. I think.
23:03:27 <wavewave> anyway, until some new good reasonable suggestion, we had better follow it in my opinion.
23:03:31 <elliott> kmc: i specified a dependency as 0.0.* recently
23:03:48 <elliott> kinda just stared at what i'd written for a while
23:04:47 <desaiu> I've learned *something* today and I guess that counts
23:04:54 <desaiu> I'm calling it a night
23:05:10 <desaiu> Thanks to everyone for being helpful
23:05:22 <tac> @hpaste
23:05:22 <lambdabot> Haskell pastebin: http://hpaste.org/
23:05:24 <desaiu> I enjoy the discussion here
23:05:40 <desaiu> Bye
23:05:42 <edwardk> dolio: back
23:06:01 <dolio> The paper you were talking about earlier was the arrow calculus one?
23:06:37 <edwardk> at lunch? yeah
23:06:50 <edwardk> the series of papers wadler and lindley wrote
23:08:02 <dolio> Well, they also wrote the idioms, arrows and monads one.
23:08:07 <dolio> Does that also have problems?
23:08:08 <edwardk> the equational correspondence they established wasn't enough
23:08:29 <edwardk> that was the issue raised when they did the conference presentation
23:08:33 <edwardk> nah
23:08:43 <edwardk> its just the equational correspondence to traditional arrows
23:09:25 <edwardk> same kinda problem that the first "rule 110 is turing complete" proof had iirc
23:09:29 <dolio> Wasn't enough for what?
23:10:37 <edwardk> i'm trying to recall the details of the objection
23:12:23 <edwardk> "Lind-
23:12:24 <edwardk> ley, Wadler and Yallop (2008b) give forward and backward translations between
23:12:24 <edwardk> variants of idioms, arrows, and monads, and only some turn out to be equational
23:12:24 <edwardk> correspondences; we had to invent a more general notion of equational equivalence
23:12:24 <edwardk> to characterize the others."
23:12:50 <dolio> Oh, so it is the idiom, arrow, monad paper.
23:13:09 <edwardk> the 'equational equivalence' plumbing was what folks objected to, there was a nice simple example someone rattled off of why that wasn't good enough
23:13:23 <edwardk> yeah i guess i had the papers swapped
23:14:43 <edwardk> iirc, it was either bauer or gibbons who popped up with the counter-example
23:17:52 <edwardk> i just emailed jeremy to see if he remembers
23:18:16 <edwardk> coz now its bugging me =)
23:18:30 <kmc> NemesisD, i don't use upper bounds at all... what's the point?
23:19:31 <kmc> i guess the point is "making sure your code is correct"
23:19:32 <kmc> ;P
23:19:35 <shachaf> kmc: I think the point is to be conservative enough that your package will always compile.
23:19:58 <kmc> but i think it causes spurious breakage much more than useful breakage
23:22:29 <shachaf> At least it provides a clear error message.
23:22:43 <shachaf> People probably also worry about silent breakage more than spurious breakage.
23:23:47 <dolio> edwardk: The idioms... paper does have some other stuff in it.
23:23:48 <rwbarton> but when I encounter spurious breakage, I'm just going to fix it by updating the versions anyways, so then I have to deal with possible silent breakage either way
23:23:59 <dolio> They have an equational embedding in addition to equivalence and correspondence.
23:24:21 <dolio> Maybe the former is bad.
23:24:22 <edwardk> the msfp one or the later one?
23:24:26 <shachaf> rwbarton: Sure, but then you've violated the .cabal contract. :-)
23:24:36 <kmc> i just hope the types will save me from dependency upgrades
23:24:36 <rwbarton> shachaf: Whoop-dee-doo. ;)
23:24:41 <dolio> Whichever is on Wadler's web site.
23:25:08 <edwardk> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf is the one in the proceedings
23:25:52 <cwl> /qut
23:26:15 <edwardk> i pinged gibbons and bauer to see if either of them could remember the substance of the objection
23:27:36 <hpaste_> cwl pasted “"Floating point exception ” at http://hpaste.org/52310
23:27:57 <cwl> floating point exception
23:28:06 <edwardk> thorsten was there as well, he might remember, if he pops into the agda channel at all
23:28:08 <cwl> while decode json data
23:28:18 <edwardk> or conor
23:28:26 <ddarius> edwardk: You'll be lying in wait?
23:28:28 <cwl> http://hpaste.org/52310
23:28:48 <edwardk> just trying to think of who else might remember the issue that was raised
23:29:08 <ddarius> You could probably grep the logs.
23:29:12 <dolio> What does Thorsten call himself?
23:29:42 <edwardk> dunno. not sure i've ever run into him on irc
23:29:49 <dolio> Ah.
23:30:41 <ddarius> preflex: seen thorsten
23:30:42 <preflex>  Sorry, I haven't seen thorsten
23:30:44 <ddarius> preflex: seen thorstena
23:30:44 <preflex>  Sorry, I haven't seen thorstena
23:31:00 <edwardk> conor was chair for that conference though, so he was definitely present =)
23:32:03 <dolio> He hasn't been around here lately.
23:37:24 <edwardk> hrmm gibbons doesn't even remember the talk let alone the counter-example. trying farther afield ;)
23:37:43 <dolio> Well, you can tell me later. I'm beat.
23:39:59 <Evrim> What would be a fast and reliable method to receive key presses?
23:40:20 <elliott> On what platform? What windowing system? (If any?)
23:40:45 <Evrim> Windows
23:41:04 <elliott> Oh. Maybe someone else knows, then.
23:41:31 <Evrim> I'm new to the whole Haskell thing
23:41:49 <Evrim> Why is the reason that one method won't work in all the OS
23:41:52 <kmc> it's mostly not a Haskell question
23:42:05 <elliott> Evrim: Well, there are relatively portable APIs for such input things.
23:42:21 <kmc> different OSes have different interfaces for input
23:42:22 <elliott> There are also platform-specific APIs. What you want to use is dependent on your situation and like kmc said, not really that related to Haskell.
23:42:30 <Evrim> Thanks, I'll be checking them
23:42:33 <kmc> Haskell doesn't have a single preferred abstraction over them
23:42:34 <elliott> Although certainly which APIs have good Haskell bindings is likely to be high on the list of criteria.
23:42:41 <kmc> it has bindings to various GUI libraries like GTK and wx
23:42:52 <kmc> and things like SDL and GLUT
23:43:09 <kmc> it also has direct bindings to the Windows API
23:43:13 <Evrim> SDL has a Haskell port?
23:43:13 <kmc> and X Windows libraries
23:43:24 <kmc> and probably whatever is used on OS X
23:43:26 <elliott> Not port, bindings.
23:43:34 <kmc> http://hackage.haskell.org/packages/archive/pkg-list.html search for "SDL"
23:43:35 <Evrim> Hmm...
23:43:43 <elliott> It still uses the same SDL API.
23:43:46 <elliott> It just offers a Haskell interface.
23:51:34 <td123> has there been much speedup between ghc 6.12 and 7.0?
23:52:00 <shachaf> For some things.
23:52:04 <shachaf> > 7.0/6.12
23:52:04 <lambdabot>   1.1437908496732025
23:52:12 <shachaf> Looks like it's about 14% faster.
23:52:25 <kmc> 7.0 has the new IO manager, right?
23:52:29 <shachaf> td123: It depends on what you're doing. GHC 7 has the fancy new I/O manager.
23:52:53 <td123> I'm mainly interested in just data crunching
23:53:09 <td123> I'm specifically referring to http://hackage.haskell.org/package/kmeans
23:53:11 <kmc> i think the inliner got a rewrite too
23:53:31 <kmc> inlining is a big deal for GHC Haskell performance
23:53:38 <td123> this package was the one that turned me off from haskell, since it ran a lot slower than my python implementation
23:54:02 <kmc> well, perhaps the package is poorly written
23:54:14 <cheater> what does it do
23:54:21 <kmc> k-means clustering
23:54:26 <kmc> "what's k-means clustering"
23:54:28 <cheater> what does that do
23:54:28 <kmc> why don't you google it cheater
23:54:34 <td123> haha
23:54:35 <cheater> why don't *you* google it
23:54:40 <kmc> because i know what it is
23:54:41 <cheater> and come back with the first result
23:54:45 <cheater> ok then tell me
23:54:47 <cheater> be my google
23:54:49 <cheater> be my all.
23:54:55 <kmc> td123, were you building with ghc --make -O2 ?
23:55:15 <kmc> it's common that the same algorithm competently implemented in Haskell and Python will run much faster in Haskell
23:55:26 <kmc> but a bad algorithm will still be slow
23:55:33 <kmc> it's also easier to choose data structures poorly in Haskell
23:56:02 <td123> kmc: I didn't use those flags
23:56:06 <kmc> ok
23:56:17 <kmc> well you definitely want to compile code (not run it in ghci) and use -O or -O2
23:56:17 <cheater> yeah that's a factor
23:56:19 <kmc> if you care about performance
23:56:36 <cheater> i bet the python version is C or something
23:56:37 <td123> kmc: I was just turned off because I did a basic straightforward implementation in python, and sort of expected a lot more from haskell
23:56:44 <cheater> ah ok
23:56:54 <td123> cheater: no, it was pure python
23:57:08 <elliott> td123: you're probably more experienced with python than haskell :)
23:57:08 <cheater> td123: it's easy to mess up haskell, just like it's easy with python
23:57:12 <kmc> td123, you expected more from a random library you got off of Hackage
23:57:15 <cheater> you just do it in a different way.
23:57:18 <kmc> or did you write that library?
23:57:21 <td123> kmc: yes
23:57:22 <td123> :P
23:57:32 <cheater> hackage libs are often a bit shit
23:57:34 <shachaf> Looks like the .cabal file doesn't specify -O2.
23:57:34 <td123> no, I didn't write it myself
23:57:38 <elliott> oh
23:57:41 <elliott> well that's silly then
23:57:49 <kmc> yeah, there's like 3,300 libraries on Hackage; many of them are low quality
23:57:54 <shachaf> So it compiles with -O.
23:58:04 <cheater> i don't think python has 3300 modules..
23:58:23 <companion_cube> python has a lot of libs on pypi
23:58:26 <kmc> maybe i'll find a crap Python library and tell #python how disappointed i am with their language
23:58:30 <td123> kmc: err to be clear, I didn't write the haskell version, only the python version
23:58:34 <kmc> *nod*
23:59:15 <td123> no need to punish python for my mistakes :P
23:59:21 <cheater> o btw
23:59:35 <cheater> what is erlang's "answer" to haskell's STM?
23:59:39 <ddarius> Oi.  That kmeans code was definitely not written by an experienced Haskeller.
23:59:45 <cheater> for syncing threads
23:59:52 <ddarius> cheater: Nothing.
