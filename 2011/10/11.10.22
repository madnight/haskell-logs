00:00:45 <augur> hmm
00:02:58 <harlekin_> { "hw" : document.getElementById("hw").innerHTML };
00:03:12 <harlekin_> It is not possible to have this in haskell's json data type, right?
00:03:26 <ion> What does that have to do with JSON?
00:03:45 <mauke> that's not valid JSON
00:03:46 <Gracenotes> it's not valid JSON
00:03:47 <Gracenotes> :o
00:04:08 <harlekin_> I figured. Thanks for confirmation.
00:04:14 <Gracenotes> if you plugged it into JavaScript it might give you valid JSON
00:04:32 <Gracenotes> with .toSource()
00:04:59 <sipa> js != json
00:05:11 <harlekin_> Is there a type-safe way to write those objects that when plugged into JS give valid JSON types, in Haskell of course?
00:05:31 <mauke> "when plugged into JS give valid JSON types"? what
00:06:50 <Gracenotes> plugged in = evaluated, give = yield a value of the subset of JavaScript types which are in JSON
00:07:09 <mauke> what are javascript types?
00:08:33 <Gracenotes> the ones which are defined in the ECMA-262 standard
00:08:46 <Gracenotes> and in vender-specific add-ons, like the DOM
00:09:21 <ion> They’re a bit like this:
00:09:21 <ion> *Main> "foo" + 42 + "bar"
00:09:21 <ion> "foo42bar"
00:09:23 <mauke> JSON doesn't contain any javascript or types
00:09:26 <mauke> it's a string format
00:10:26 <Gracenotes> valid JSON strings have semantic value. I don't see why you can't model that trivially with a type system.
00:10:50 <ddarius> Gracenotes: What you'd need to model with a type system is Javascript.
00:11:02 <ddarius> And to do that would require making a lot of assumptions.
00:11:50 <augur> ddarius: for a let expression, what should the rules be, do you think?
00:11:54 <augur> my intuition is something like...
00:13:09 <Gracenotes> ddarius: yeah. JS's type system is ridiculously complicated; look at the ECMA-262 definition of ==. ridiclously ad-hoc. but still well-defined.
00:13:46 <augur> G :- let x = y in z : T | C U C'    <=    G, x : T' :- y : T' | C    G, x : T' :- z : T | C'
00:14:33 <augur> but that cant work because T' has to be present both downwards and upwards
00:14:56 <augur> so i'd need to introduce a new variable for x and then add a constraint
00:15:16 <augur> so i guess like...
00:15:32 <augur> G :- let x = y in z : T | C U C' U {X = T'}   <=    G, x : X :- y : T' | C    G, x : X :- z : T | C'
00:15:48 <Gracenotes> harlekin_: anyhow. if you're writing something which is going to be parsed as JavaScript by a browser, JSON won't fit. Maybe there are some JS AST libraries. So define a JSON->JS mapping. Or just write out the whole thing as a string.
00:15:48 <ddarius> augur: What type system are you hoping to capture?  For the simply typed lambda calculus, you can define let in terms of lambda from which you could derive the appropriate rule.
00:15:57 <augur> ddarius: haskell, pretty much
00:16:25 <augur> so lets have to be different from lambdas
00:16:39 <harlekin_> Gracenotes: Okay. Thank you. :)
00:18:13 <Gracenotes> heck, there might be a Haskell analogue to V8 or spidermonkey
00:19:27 <Louis11> I'm trying to write a parser that can parse parenthesized expressions i.e. (((1)==((2))). However, I can't quite seem to get it. I've tried several, several things, but nothing seems to be working. Any ideas what might be wrong with my code? http://hpaste.org/52953
00:20:39 <mauke> parenExpression = literal <|> (openParen *> parenExpression <* closeParen)
00:20:55 <mauke> hmm, no
00:21:00 <mauke> parenExpression = literal <|> (openParen *> expression <* closeParen)
00:21:51 <Louis11> hm, could you perhaps explain that to me?
00:21:54 <Louis11> particularly the *>
00:22:20 <mauke> a *> b = do { a; b }
00:22:42 <Sgeo|web> Huh? WHat's the difference between *> and >>?
00:22:46 <mauke> none
00:23:13 <Louis11> hm, I thought I had tried something similar to that earlier (in the do notation). Lemme try again
00:23:36 <mauke> I wonder why you're not asking about <*
00:23:54 <Louis11> Oh good point O_O what's <* do?
00:24:08 <mauke> a <* b = do { x <- a; b; return x }
00:25:25 <Louis11> hm, I feel sad about my convoluted attempts at this :/
00:25:50 <Gracenotes> does your many1 work?
00:26:02 <Louis11> Gracenotes: I hope so, it was provided to me by my professor
00:26:04 <Gracenotes> if it doesn't, chances are, the paren-parsing will not :x
00:26:12 <mauke> it should, that's the "standard" definition
00:26:41 <mauke> many1 p = liftA2 (:) p (many p)
00:26:41 <Gracenotes> if it doesn't work, that might also imply a problem with the underlying parser
00:27:28 <Louis11> I've spent hours on this parser, I really hope there aren't any inherent problems in the framework I was provided
00:28:15 <Gracenotes> hm probably not. your thing will match '(((((4', no?
00:28:45 <Louis11> my code?
00:28:48 <Louis11> or mauke?
00:28:49 <Gracenotes> yeah.
00:29:15 <Louis11> uhm, at best I could get ((1)) to work, any more parenthesis than that and it would fail
00:30:57 <Louis11> What's *> called?
00:31:05 <mauke> *>
00:31:06 <ddarius> Oi vey.
00:31:41 * hackagebot buildwrapper 0.1 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.1 (JeanPhilippeMoresmau)
00:31:53 <ddarius> @src many1
00:31:53 <lambdabot> Source not found.
00:31:57 <ddarius> @src many
00:31:57 <lambdabot> Source not found.
00:32:03 <ddarius> Stupid bot.
00:33:03 <ddarius> Pineapple yoghurt is big success.
00:35:17 <Louis11> do I need to do anything in particular to make use of the *> and <*?
00:35:27 <mauke> import Control.Applicative
00:36:42 <Louis11> ah I take it <|> is already defined in Applicative?
00:39:01 <ddarius> "Those who do not know parsing theory are doomed to fail to reinvent it."
00:39:56 <Louis11> ddarius: <|> was defined in the framework I was provided :/ I didn't rewrite <|> (this time)
00:40:20 <ddarius> I'm not referring to that at all.
00:40:23 <Louis11> But it seems like many, if not all of the functions in the "framework" are in Applicative. I wonder why they just didn't import that
00:40:31 <Louis11> ah, my mistake :)
00:40:52 <ddarius> Applicative provides a type class Alternative which provides the (<|>) method.
00:41:07 <ddarius> It would still need to be implemented for your particular Parser type.
00:41:30 <ddarius> But yes, a lot of the common combinators for parsing are just special cases of Applicative/Alternative combinators.
00:41:31 <Louis11> Perhaps this is an insipid question, but is there anyway to "ignore", if you will, the <|> in Applicative?
00:41:46 <ddarius> You can hide it, or you can just not import it.
00:42:07 <Louis11> What do you mean hide it?
00:42:21 <ddarius> import Control.Applicative hiding ((<|>))
00:43:10 <Louis11> import Control.Applicative hiding ((<|>), many)?
00:43:16 <Louis11> not sure if that's valid
00:43:24 <mauke> it is
00:43:34 <ddarius> There's a quick way to find out.
00:43:44 <mauke> you could even do: import Control.Applicative ((*>), (<*))
00:44:08 <Louis11> ddarius: Hah, yes. I often ask questions "out loud", sorry :)
00:44:17 <ddarius> ((<*),(*>))
00:47:03 <Louis11> hm, so is expression also in Applicative?
00:49:45 <augur> ddarius: i feel that type variables and type classes with constraints will be .. an interesting challenge
00:50:20 <Sgeo|web> Constraints?
00:50:26 <augur> Sgeo|web: foo x => ...
00:53:15 <Sgeo|web> Oh
00:58:42 <augur> also, parametric types
00:58:47 <augur> thats going to be tricky too i think
00:59:47 <Louis11> so this is likely extremely convoluted, however *> and <* didn't seem to work with what's already in my Parser framework (types were all strange). I attempted to convert it to do's . . .  http://hpaste.org/52955
01:06:57 <ddarius> Great googly moogly.
01:08:01 <Louis11> sorry O_O . . . 3AM and I haven't really slept in 2 days, heh
01:08:21 <ddarius> Why not go to sleep then?
01:09:51 <Louis11> eh, well I had a midterm last wed, a midterm friday, I have to be in a wedding on Saturday, this parser project is due on Sunday, and I have an advanced calc midterm on monday
01:10:21 <Louis11> so, I've gotta try and get as much done on this parser before tomorrow, so that hopefully tomorrow I can finish it up, and allot myself time to study for my advanced calc exam on sunday . . .
01:11:05 <ddarius> "I need to deprive myself of sleep so I end up failing at everything instead of just one thing."
01:12:34 <Louis11> hm, the quote is surprisingly relevant
01:13:27 <Sgeo|web> I should probably read an Iteratee tutorial
01:13:40 <Sgeo|web> What good ones are there?
01:14:37 <aristid> Sgeo|web: maybe this? http://www.yesodweb.com/book/enumerator
01:16:15 <Louis11> hm, what's the best way to debug code? In C, I'd usually throw in a few prints, or use gdb. I'd imagine there's something similar in haskell?
01:16:21 <Sgeo|web> ty
01:16:27 <Sgeo|web> Louis11: Debug.Trace.trace
01:17:00 <Sgeo|web> Though I don't know how much of best debugging practice that is. GHCi is probably a good help
01:17:08 <aristid> Louis11: if you have small functions, you can test them in ghci
01:17:30 <aristid> the first step of good debugging is getting enough sleep, of course :P
01:18:21 <Louis11> aristid: yea, sleep is good. A few more tries, and then I'm definitely off to bed :P
01:18:42 <Axman6> the second is writing easily testable and understandable code, which usually means small functions
01:19:27 <Cale> Louis11: Break things into smaller parts, see if the parts work. If they work independently (and they're pure), they probably also work together, because of referential transparency :)
01:20:03 <Louis11> Cale: Yea, I'm not really sure how I'd go about breaking up this function
01:20:34 <aristid> how big is it?
01:20:57 <Louis11> aristid: As of this moment, one convoluted line
01:21:15 <aristid> how long is the line?
01:21:42 <Louis11> 100 it looks like
01:21:50 <Louis11> though I could technically break that up into a few lines
01:21:57 <aristid> so it's not really huge
01:22:13 <Louis11> no, not at all
01:22:25 <aristid> does it give a type error?
01:22:35 <Louis11> nope, types seem to be alright
01:22:42 <Louis11> runtime seems to be the issue
01:23:42 <aristid> in that case, the trusty way to solve it is probably by thinking hard and seeing the problem right in your head :)
01:24:31 <Louis11> I have an intuitive idea of what's correct, however my haskell experience has proven quite limiting, unfortunately
01:24:45 <Cale> Louis11: What does the function do?
01:25:24 <Louis11> parses parenthised expressions, i.e. (((1))==((1)))
01:26:45 <Cale> Are you using parsec or another parsing library, or is it just a function on strings?
01:27:19 <Louis11> uhm, I believe we are using parsec, however I was given a framework with quite a bit of code to work off of
01:27:40 <ddarius> Cale: The (current) problem with his code is blatant.
01:28:10 <Cale> ddarius: ?
01:28:14 <Louis11> it's terrible
01:28:23 <ddarius> Cale: http://hpaste.org/52955
01:28:29 <Cale> oh, there's a paste
01:28:30 <ddarius> Cale: I give you ten seconds to see it.
01:29:01 <Cale> why two expressions?
01:29:05 <Louis11> the expression; val <- expression?
01:30:03 <Louis11> I noticed that too, I changed it to parenExpression; val <- expression. Testing that atm
01:30:33 <aristid> Louis11: that doesn't make any sense either
01:30:52 <aristid> where does "expression" come from?
01:31:38 <hpaste> louis11 pasted “blah” at http://hpaste.org/52956
01:31:43 <Cale> Currently the code says that a parenExpression is either a literal, or it is an open paren followed by an expression, followed by another expression called val, followed by a close paren
01:32:03 <aristid> and the first expression is discarded and not put into the AST
01:32:45 <aristid> Louis11: which of those functions are your own code?
01:32:48 <Sgeo|web> Why isn't do notation being used in 18-22? I know some people hate it
01:32:58 <Louis11> the most recent paste is part of the framework
01:33:08 <Louis11> the parenExpression is my doing, unfortunately
01:33:28 <Cale> ;__; the Yesod book is teaching people to chain $'s
01:33:48 <Sgeo|web> Cale: hmm, what's wrong with that? Is it better to chain mostly . and one $?
01:33:58 <Sgeo|web> Someone told me to do that after they saw my chained $
01:34:23 <Cale> Sgeo|web: I think so.
01:34:29 <Cale> For a couple of reasons
01:34:37 <aristid> Louis11: ok, pro-tip: you only need one expression. nuff said, this is your homework
01:34:52 <Louis11> yea I just took it out, and it seemed to work
01:35:00 <Cale> One is that if you write f . g . h $ x, then g . h is meaningful, but g $ h is likely just a type error
01:35:07 <aristid> the code is still wrong though
01:35:13 <Axman6> the only time when i almost always use $ where i could use . is when i'm calling forkIO
01:35:36 <Cale> So, it puts your code in the right form to be chopped up and thought about in smaller pieces
01:35:51 <Axman6> imo it makes it clearer that forkIO $ f . g . h $ x forks f . g . h $ x
01:36:02 <aristid> Cale: in f $ g $ x, (g x) might be more meaningful than f . g, no? :)
01:36:08 <Cale> why not  forkIO . f . g . h $ x ? :)
01:36:17 <Louis11> aristid: How so? I just don't get it . . .
01:36:20 <shachaf> Cale: To foil infixl $
01:36:23 <Axman6> because it's ugly
01:36:24 <mauke> why not forkIO (f . g . h $ x)?
01:36:32 <aristid> Louis11: look at primary and see the redundancy.
01:36:43 <Cale> aristid: well, g $ x is still a well-typed subexpression :)
01:36:52 <Cale> and you can still chop that bit out
01:37:23 <Cale> We're talking about f . g . h $ x versus f $ g $ h $ x, just to be clear
01:37:39 <aristid> Cale: i guess that works because . is associative
01:37:42 <Cale> aristid: yeah
01:38:05 <shachaf> Even fmap is associative.
01:38:05 <aristid> Cale: i do catch myself sometimes preferring nested $ over ., though
01:38:15 <Cale> indeed ;)
01:38:36 <aristid> "associative" if you ignore the different types, at least
01:38:44 <Cale> fmap (f . g) x = fmap f (fmap g x), so if we write (.) = fmap, that becomes (f . g) . x = f . (g . x)
01:39:43 <Cale> So anyway, another reason is that it would be really nice at some point to flip the associativity of $
01:39:57 <Cale> (and $! along with it)
01:40:35 <Cale> So then you coulf write f $ g x $ h y $ k z  for f (g x) (h y) (k z)
01:40:40 <Cale> could*
01:40:45 <aristid> Cale: that will never happen :P
01:40:55 <Louis11> alright, i think i'm headed to bed. Thanks for the help, and the patience :)
01:41:16 <Cale> and replace $ with $! to make the application strict without having to awkwardly parenthesise things where you want to make more than one parameter strict
01:41:18 <aristid> Cale: but despair not, you can write a module with your own associativity of $. you could even put it in lambdabot to fool people
01:41:23 <Cale> heh
01:43:59 <Rc43> Hi.
01:44:43 <Axman6> 'lo Rc43
01:44:51 <Rc43> Anybody knows hot to link C object files with System.Plugins? I can do it with haskell plugin, but not with C one.
01:46:44 <Sgeo|web> What's wrong with:
01:46:53 <Sgeo|web> newtype Nomic a = Nomic (State Nomic a)
01:46:55 <Sgeo|web> Oh, duh
01:48:01 <aristid> :k State
01:48:02 <lambdabot> * -> * -> *
01:48:16 <Gracenotes> :t (.)
01:48:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:48:28 <Sgeo|web> newtype Nomic a = Nomic (State (Nomic a) a)
01:48:29 <Sgeo|web> That compiled
01:48:38 <Sgeo|web> Not sure if I want the inner a to be a b though
01:48:39 <Axman6> o.O
01:48:43 <Axman6> what an odd type
01:48:47 <aristid> Sgeo|web: yeah, Nomic had kind *->*, but State wants *
01:49:15 <aristid> Axman6: it's State all the way down!
01:49:20 <Sgeo|web> It's a state-altering computation describing how to change the state-altering computation
01:49:25 <Sgeo|web> Unless I'm wrong
01:49:57 <aristid> i don't even know how you would go about using runState on that
01:50:06 <Gracenotes> what happens if you feed it into itself
01:50:44 <Sgeo|web> (Well, almost certainly, there'd be other state in there, so more like Nomic (State (Nomic a, Stuff) a)
01:50:50 <Axman6> let state = runState state state?
01:51:28 <Axman6> :t let state = runState state state in state
01:51:30 <lambdabot>     Occurs check: cannot construct the infinite type: s = State s a
01:51:30 <lambdabot>       Expected type: s
01:51:30 <lambdabot>       Inferred type: State s a
01:51:57 <Sgeo|web> Why did my newtype compile then?
01:52:11 <Sgeo|web> (Note: I did it in codepad)
01:52:16 <aristid> Sgeo|web: who said it wouldn't?
01:52:24 <Sgeo|web> The occurs check
01:52:32 <Sgeo|web> Although I guess that's separate
01:52:35 <aristid> newtype Nomic a = Nomic (State (Nomic a) a) is clearly valid haskell
01:52:45 <aristid> doesn't mean you can use it for anything meaningful
01:53:37 <Sgeo|web> Can I use it for something meaningful if I include other state in there, such as, say, a list of pairs of Nomic a's and votes on those?
01:54:34 <aristid> i didn't say you can't use it for something meaningful
01:54:41 <aristid> i just don't know how, because i'm a noob
01:54:54 <Gracenotes> let nom@(Nomic res) = Nomic $ State (val, nom) in runState res
01:55:14 <aristid> Gracenotes: does that typecheck?
01:55:20 <Gracenotes> ...maybe
01:55:32 <Gracenotes> you could also layer it 2 deep.
01:55:49 <Gracenotes> or arbitrarily deep.
01:56:06 <aristid> but not infinitely deep
01:56:18 <aristid> because ghc sadly doesn't accept infinitely sized programs
01:56:34 <Sgeo|web> I wonder if lazy I/O could be used for this
01:56:35 * Sgeo|web gets shot
01:56:54 <aristid> wtf? lazy i/o is completely unrelated to this
01:57:05 <Sgeo|web> To construct more functions
01:57:09 <Gracenotes> let countNom x = Nomic $ State (x, countNom $ x+1); countNom :: Int -> Nomic
01:57:11 <Sgeo|web> That get nested in the Nomic
01:58:13 <Gracenotes> runState (do { x <- get; y -> gets get; return (x, y) }) (countNom 1) == (1, 2). maybe.
01:58:24 <Gracenotes> s/->/<-/
01:58:39 <Sgeo|web> gets get?
01:58:46 <Axman6> :t gets get
01:58:47 <lambdabot> forall s a (m :: * -> *). (MonadState a ((->) s), MonadState s m) => m a
01:58:52 <Sgeo|web> :t gets
01:58:53 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
01:59:09 <Sgeo|web> :t get
01:59:10 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
01:59:17 <aristid> :t gets ask
01:59:18 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
01:59:19 <Sgeo|web> Oh, gets takes a function to use
01:59:34 <aristid> i think gets get is a mistake tho
01:59:36 <Gracenotes> hm. it might need a join.
01:59:37 <Axman6> it's useful when your state is a record
01:59:46 <Gracenotes> but you get the idea
01:59:58 <aristid> :t gets <=< get
01:59:59 <lambdabot> forall s c (m :: * -> *) a. (MonadState s m, MonadState (m (s -> c)) ((->) a)) => a -> m c
02:00:16 <Axman6> data Foo = Foo {a :: String, b :: Int}, then you can use gets a in a State Foo c to get the string in the Foo
02:00:32 <Sgeo|web> That reminds me
02:00:37 <Sgeo|web> Suppose I have a record
02:00:55 <Sgeo|web> data Record = Record { a :: Int, b :: String }
02:00:57 <Sgeo|web> Or whatever
02:01:18 <Sgeo|web> What is the function :: Record -> Int -> Record
02:01:27 <Sgeo|web> To return a new Record with a different a?
02:01:46 <ion> You’ll want one of the lens packages.
02:01:46 <Axman6> foo x n = x { a = n }
02:02:23 <Sgeo|web> That's ugly. I guess if I wanted to use such a function inline somewhere, I'd use a lambda?
02:02:44 <Axman6> probably
02:02:50 <shachaf> Sgeo|web: <ion> You’ll want one of the lens packages.
02:02:54 <shachaf> In particular, data-lens.
02:03:02 <ion> http://hackage.haskell.org/package/data-lens or http://hackage.haskell.org/package/fclabels
02:03:03 <shachaf> And data-lens-template to autogenerate lenses for you.
02:04:05 <aristid> it's an edwardk(tm) package
02:04:32 <augur> whats the function that gives you an list of x's?
02:04:45 <ion> > repeat x
02:04:46 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
02:04:49 <dalaing_home> data-lens-fd as well, if you want some sugar for state monads etc...
02:04:53 <augur> huh.. didnt work for me
02:04:55 <augur> > repeat "1"
02:04:56 <lambdabot>   ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1...
02:05:05 <augur> oh i see
02:05:05 <augur> ok
02:05:21 <mauke> > repeat '1'
02:05:22 <lambdabot>   "11111111111111111111111111111111111111111111111111111111111111111111111111...
02:06:05 * Axman6 wishes edwardk's packages came with more documentation than "this is what the type says but in english"
02:06:35 <aristid> Axman6: clearly you just need to learn to read the type, then
02:06:51 <Axman6> well, i can read the type, but i can't see how it's useful
02:06:55 <aristid> > cycle "edwardk"
02:06:56 <lambdabot>   "edwardkedwardkedwardkedwardkedwardkedwardkedwardkedwardkedwardkedwardkedwa...
02:07:25 <aristid> Axman6: in the case of data-lens it should be more obvious though?
02:08:15 <Axman6> not really. i can't see what any of the functions are supposed to do, or more importantly, how one is supposed to use them
02:08:36 <ion>  unfoldr (\xs -> Just (take 7 xs, drop 1 xs)) . cycle $ "edwardk"
02:08:38 <ion> > unfoldr (\xs -> Just (take 7 xs, drop 1 xs)) . cycle $ "edwardk"
02:08:40 <lambdabot>   ["edwardk","dwardke","wardked","ardkedw","rdkedwa","dkedwar","kedward","edw...
02:09:34 <aristid> Axman6: what do you think does this function do? iso :: (a -> b) -> (b -> a) -> Lens a b
02:09:50 <Axman6> creates a lens... but what's a lens?
02:10:10 <aristid> a lens is a function that returns a Store, duh
02:10:12 <Axman6> it's not mentioned anywhere what a lens is, nor where to go to find out
02:10:18 <Axman6> what is a Store?
02:10:18 <Sgeo|web> Presumably a structure that lets you translate from one thing to another
02:10:21 <Sgeo|web> ?
02:10:29 <shachaf> Axman6: He does explain this elsewhere.
02:10:30 <aristid> Axman6: you already know what a lense is, no? from packages like fclabels
02:10:36 <Axman6> no
02:10:38 <shachaf> @google stackoverflow edward kmett lens
02:10:39 <lambdabot> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
02:10:39 <lambdabot> Title: haskell - lenses, fclabels, data-accessor - which library for structure access a ...
02:10:50 <shachaf> Axman6: A lens is like a pair of getter and setter functions.
02:11:11 <shachaf> Axman6: The nice thing about keeping the getter and setter functions grouped together is that you can compose them (a lot like function composition).
02:11:37 <Axman6> hmm, ok
02:11:48 <shachaf> Normally when you make a record type, you get getter functions automatically but have to use weird syntax to set things.
02:12:15 <Axman6> that stackoverflow link is quite helpful =)
02:12:18 <shachaf> data Foo = Foo { a :: Int, b :: Bar }; data Bar = Bar { x :: Char }
02:12:47 <shachaf> A lens for "a" would have a type like (Foo -> Int, Int -> Foo -> Foo)
02:12:57 <shachaf> A lens for "b" would have a type like (Foo -> Bar, Bar -> Foo -> Foo)
02:13:15 <shachaf> A lens for "x" would have a type like (Bar -> Char, Char -> Bar -> Bar)
02:13:22 <aristid> or, if you reorder things a bit: Foo (Int, Int -> Foo)
02:13:31 <shachaf> given the latter two, you can easily compose them to get a lens straight from a Foo to a Char.
02:13:45 <shachaf> aristid: Sure, but that's an implementation detail.
02:14:09 <Sgeo|web> If record syntax improved, would lenses still have a use?
02:14:12 <ion> AFAIU the only thing fclabels has over data-lens is that it handles the case of data Foo = Foo { a :: Integer, b :: Integer } | Bar { b :: Integer, c :: Integer } where a and c aren’t defined for all values of type Foo.
02:14:15 <shachaf> Sgeo|web: Surely.
02:14:24 <shachaf> Sgeo|web: lenses are also useful for things that aren't accessors.
02:14:37 <ion> If the record syntax improved, it probably would *use* lenses in the first place. :-P
02:14:45 <shachaf> ion: data-lens doesn't? Or do you mean data-lens-template?
02:15:11 <ion> shachaf: Sorry, i was ambiguous. The TH magic.
02:16:12 <shachaf> ion: Well, fix it, then. :-)
02:16:29 <ion> I might one day. :-P
03:06:35 <skatez> i was wondering if anyone could tell me if this is allowed in pattern matching?
03:06:36 <hpaste> skatez pasted “Allowed Pattern Matching?” at http://hpaste.org/52961
03:08:03 <skatez> also, hello
03:09:05 <mah_b> > let fn ((x, y):xs) = x in fn [(1, 2), (2, 3)]
03:09:06 <lambdabot>   1
03:09:25 <mah_b> > let fn (x, y):xs = x in fn [(1, 2), (2, 3)]
03:09:26 <lambdabot>   <no location info>: Parse error in pattern
03:09:35 <skatez> ahhh
03:09:38 <skatez> many thanks
03:09:38 <mah_b> there have to be braces around the match.
03:10:01 <skatez> quite obviously, i am just learning right now
03:10:05 <skatez> i appreciate the help
03:10:21 <mah_b> you're welcome
03:18:11 <watermind> I just tried to use cabal and got this:
03:18:13 <watermind> cabal: error while loading shared libraries: libHSold-locale-1.0.0.2-ghc6.12.3.so: cannot open shared object file: No such file or directory
03:18:43 <watermind> anyone knows what is going on here? using openSUSE 12.1 RC1, haskell platform 2010.2
03:22:25 <tech2> watermind: how did you install cabal?
03:23:25 <hpaste> Magnus pasted “Parse Error” at http://hpaste.org/52962
03:24:34 <hpaste> dafis annotated “Parse Error” with “Parse Error (annotation)” at http://hpaste.org/52962#a52963
03:25:07 <dafis> tabs have bitten once again :)
03:26:49 <watermind> nevermind I managed to fix it
03:27:08 <watermind> tech2: it's a problem with teh openSUSE rpms
03:27:17 <tech2> :( fair enough
03:27:26 <watermind> tech2: it's already reported for 11.4 and apparently it's going to creep in 21.1
03:27:28 <watermind> opss
03:27:29 <watermind> 12.1
03:28:14 <watermind> tech2: there are a couple of .so files that are not in the appropriate directory, so ld does not find them
03:28:40 <tech2> Package maintainer not doing their job :( Seems a shame.
03:28:47 <watermind> tech2: I just sym linked them to /usr/lib64
03:29:19 <watermind> the fact that apparently openSUSE 12.1 is only going to get platform 2010.2 is not brilliant either :S
03:29:36 <tech2> agreed
03:32:05 <dafis> watermind: much as I like SuSE, I've long given up even trying to use the distro packages - except for the first ghc (+ necessary alex, happy) on a new installation, it's strictly BYO after that
03:33:39 <watermind> dafis: I was using 11.3 up until now, and had platform 2010.2 available for it, so it didn't look that bad, but now it looks a bit stuck
03:36:38 <dafis> watermind: problem is, I think, at least in part, too few people doing Haskell packaging on Suse, I looked into helping, but when it took more than an hour to just google together the requirements specs for packages, I said bugger it
03:40:47 <akosch> are there any tutorials on graphs in haskell? I want to create my own graph type to store a grid graph constructed from coordinates like (Int, Int)
03:41:21 <akosch> maybe an example with something similar?
03:43:18 <akosch> I was thinking of using Data.Graph, but it's a bit daunting at the first look
03:44:40 <watermind> dafis: yes I think it is a one man job as of now... kinda
03:45:21 <watermind> dafis: there are in fact two repositories, haskell and haskell:, the first is a bunch of individual packages and the second provides haskell platform
03:46:04 <watermind> dafis: the haskell rep only provides ghc 6.10, haskell: provides platform 2010.2 and therefore ghc 6.12
03:46:23 <watermind> and there is plenty of overlapping between both
03:46:28 <watermind> rather messy
03:47:58 <JuanDaugherty> and hp is dead or sumthin
03:48:33 <dafis> Yeah. If you feel like wrestling with the formalities, that would be great.
03:49:36 <gienah> the fedora packaging guidelines might help if opensuse is using rpms: http://fedoraproject.org/wiki/Packaging:Haskell
03:51:05 <gienah> when a haskell package is bumped, this often breaks other haskell packages that use it. So they have to be rebuilt as well.
03:51:29 <gienah> On Gentoo haskell-updater is run to find and rebuild the affected packages.
03:51:53 <gienah> For the binaries on Arch Linux a similar tool is used.
03:52:23 <watermind> cabal update keeps telling me there's a new cabal-install available, even after I 'cabal install cabal-install'
03:52:49 <watermind> but the upgrade seems to run fine...
03:52:53 <dafis> watermind, which cabal-install version have you?
03:53:18 * gienah does not use cabal-install, instead uses gentoo ebuilds
03:53:36 <dafis> watermind: if it does install the new, you probably have a path issue
03:53:50 <dafis> old cabal-install before new on it
03:54:04 <watermind> dafis: how can I check the version of cabal-install?
03:54:15 <dafis> $ cabal --version
03:54:27 <watermind> dafis: 0.8.2
03:54:54 <dafis> watermind: $HOME/.cabal/bin near the front of your $PATH?
03:55:48 <watermind> dafis: nowhere on my $PATH
03:56:08 <dafis> watermind: $ ~/.cabal/bin/cabal --version
03:56:47 <watermind> dafis: 0.10.2
03:56:58 <dafis> bingo
03:57:00 <watermind> so seems like you're right
03:57:51 <dafis> watermind: either cabal install --global cabal-install (requires sudo), or add ~/.cabal/bin to your path
03:58:22 <dafis> If you're sole user, I recommend the latter
03:58:59 <mah_b> akosch: what du you mean by "constructed by coordinates"?
03:59:26 <watermind> dafis: maybe I should actually do a global install
03:59:36 <akosch> mah_b: I mean I have a list of coordinates available and I want to create a graph from it
03:59:45 <watermind> dafis: I am the only user but I use multiple accounts
04:00:02 <dafis> watermind: okay, that's a good reason for a global install
04:00:03 <watermind> dafis: is it that unsafe to do a global install?
04:00:50 <dafis> watermind: not really, just it's less hassle to do user-installs (no sudo)
04:01:59 <dafis> (and if things get screwed up, you can't hose your system)
04:02:25 <akosch> mah_b: adjacent (x+-1 or y+-1) points should have an edge between them
04:04:13 <mah_b> akosch: so each vertex has up to 8 edges?
04:05:49 <akosch> mah_b: no, just 4 (it's either x+-1 or y+-1)
04:07:28 <mah_b> akosch: what operations do you want to perform on the graph?
04:08:16 <watermind> weird caball install --global did not work
04:08:36 <watermind>  /usr/bin/cabal is still the previous version
04:09:09 <watermind> where do globally installed programs/libraries go to?
04:09:17 <akosch> mah_b: I want to find routes: not every vertex has 4 edges; some are dead ends, etc.
04:09:41 <watermind> ah found it
04:09:45 <watermind> usr/local/bin
04:10:20 <watermind> ok so what is the "proper" way of setting this up?
04:12:01 <watermind> nevermind, done
04:19:36 <mah_b> akosch: what's wrong with Data.Graph?
04:20:20 <hpaste> mah_b pasted “grid graph” at http://hpaste.org/52964
04:21:09 <akosch> mah_b|afk: nothing, I just didn't know how to use it :)
04:21:15 <akosch> mah_b|afk: thanks for the example
04:41:55 * hackagebot ConfigFile 1.1.0 - Configuration file reading & writing  http://hackage.haskell.org/package/ConfigFile-1.1.0 (JohnGoerzen)
05:53:14 <rferranti> where i can find the old the monad.reader issues?
05:55:20 <basvandijk> You can look at the history of http://www.haskell.org/haskellwiki/The_Monad.Reader
05:55:50 <rferranti> thank you
06:02:56 <dcoutts> basvandijk: thanks for the various patches
06:03:03 <dcoutts> basvandijk: I don't understand the crypt one though
06:03:18 <dcoutts> -foreign import ccall unsafe "crypt" cCrypt :: CString-> CString -> CString
06:03:18 <dcoutts> +foreign import ccall        "crypt" cCrypt :: CString-> CString -> CString
06:03:30 <dcoutts> oh, I see, I think it's just a misunderstanding
06:03:34 <basvandijk> dcoutts: FFI are safe by default right
06:03:46 <dcoutts> basvandijk: the point c_wraith was making was that the C function crypt itself is not threadsafe
06:04:11 <dcoutts> nothing to do with whether we mark our call to it a 'safe' or not
06:04:22 <basvandijk> I thought the problem was that crypt could take a long time to execute
06:04:32 <basvandijk> thereby blocking other Haskell threads
06:04:43 <dcoutts> basvandijk: if you read the man page for crypt, you'll see that it says it's not safe to call from multiple threads at once
06:04:47 <basvandijk> if it's safe it's executed in its own OS thread
06:04:49 <dcoutts> because it uses some global mutable state
06:04:58 <basvandijk> ah right
06:05:10 <basvandijk> So the correct solution is to use an MVar
06:05:23 <dcoutts> and glibc provides an alternative crypt_r which takes the private state as a paramater
06:05:35 <dcoutts> making it a pure function (in the C sense)
06:05:55 <kk`> @hoogle toUpper
06:05:56 <lambdabot> Data.Char toUpper :: Char -> Char
06:06:01 <basvandijk> Mmm maybe we could use that
06:06:03 <dcoutts>        char *crypt_r(const char *key, const char *salt,
06:06:04 <dcoutts>                      struct crypt_data *data);
06:06:27 <dcoutts> basvandijk: to use that, the caller mallocs the struct crypt_data and passes it in
06:06:47 <dcoutts> basvandijk: the only problem is that crypt_r is only available on glibc, e.g. not OSX
06:06:59 <dcoutts> which is a pita
06:07:05 <basvandijk> BTW can't we use any of the crypt packages on hackage?
06:07:25 <dcoutts> basvandijk: there is a binding on hackage to crypt_r, but that has the same OSX issue
06:07:56 <dcoutts> we really do need to use this specific crypt algorithm, because we have an old apache htpasswd file that we have to be compatible with
06:08:26 <dcoutts> we don't use the crypt function for the new password store
06:08:35 <basvandijk> ok
06:08:44 <dcoutts> it's just to let us migrate old accounts over to the new server
06:08:51 <fryguybob> I think OpenSSL has a thread safe version of it.
06:09:13 <dcoutts> basvandijk: it's not a performance concern, so we could use an MVar lock
06:09:41 <dcoutts> it'll only be used when existing users are converting their accounts
06:09:47 <basvandijk> Yes that seems to be the only solution
06:10:28 <dcoutts> basvandijk: the crypt package on hackage would be nicer, but we'd have to get the author to accept a patch so it works on osx
06:10:48 <dcoutts> otherwise we use an mvar locally
06:11:57 <fryguybob> foreign import ccall unsafe "DES_fcrypt" c_fcrypt :: CString -> CString -> CString -> IO CString
06:12:50 * dcoutts admits to having an irrational prejudice against openssl
06:13:11 <fryguybob> :D, just mentioning that it is there in case you were already using it.
06:14:59 <dcoutts> currently we're not
06:15:05 <dcoutts> e.g. no support for https
06:17:38 <basvandijk> dcoutts: I have a patch ready, I will mail it to you
06:17:46 <dcoutts> ta
06:19:28 * byorgey brews a giant pot of lambda-tea for everyone
06:19:38 <dcoutts> byorgey: mmmm
06:19:55 <byorgey> =)
06:20:04 <dcoutts> basvandijk: re the rss patches, did you also send them to the author of the rss package?
06:20:19 <dcoutts> basvandijk: and perhaps we should go all the way and switch the deps from old-time to time
06:21:02 <basvandijk> dcoutts: yes, but he's not maintaining it anymore. He asked me to ask the community if there's already an new maintainer. (See my mail on cafe)
06:21:07 <dcoutts> basvandijk: oh and another Q, are you subscribed to cabal-devel?
06:21:10 <dcoutts> basvandijk: oh right
06:21:18 <basvandijk> If nobody responds I take over rss
06:21:26 <basvandijk> Yes I'm on cabal-devel
06:22:17 <byorgey> dcoutts: while you're here, I have a question: I'm calling 'configCompiler' to discover the compiler to use for getting the installed package DB. The fourth argument is a ProgramConfiguration -- where do I get one?
06:22:33 <dcoutts> basvandijk: yes, that sounds like a good plan.
06:22:37 <byorgey> dcoutts: I tried passing 'defaultProgramConfiguration' but that doesn't seem to work
06:22:56 * dcoutts takes a look
06:23:13 <byorgey> I get the error 'cabal: unknown compiler'
06:23:38 <basvandijk> regarding old-time and rss: rss makes use of the Day type (Monady | Tuesday | ...). I'm not sure what to do about that. I could add that type to rss directly but that seems wrong. The most important thing is that times are now UTCTime
06:23:46 <byorgey> dcoutts: I can make a little test program showing my difficulty if that would help
06:24:31 <dcoutts> byorgey: although it takes a Maybe CompilerFlavorm you actually have to pass Just :-)
06:24:51 <byorgey> oh! I see =)
06:25:15 <dcoutts> if you have access to a set of ConfigFlags, there's a convenience function configCompilerAux
06:25:21 * dcoutts wonders who named this stuff
06:25:29 <dcoutts> hope it wasn't me :-)
06:25:32 <Igloo> :-)
06:25:42 <byorgey> dcoutts: ah, yes, I see that function, but I'm not sure where I get my hands on some ConfigFlags
06:26:10 <dcoutts> byorgey: it may not make sense in your context
06:26:11 <joe9>  /ws 14
06:26:21 <dcoutts> e.g. when we're doing configure or install, then we have that
06:26:34 <byorgey> dcoutts: right, here we're just doing 'init'
06:26:39 <dcoutts> right
06:27:00 <byorgey> dcoutts: the point of all this is to get my hands on a way to invoke ghc-pkg or whatever the equivalent program is
06:27:11 <Igloo> I wonder if we should have a push to remove old-time dependencies
06:27:12 <byorgey> I was trying to be non-GHC-specific
06:27:59 <basvandijk> dcoutts: You've got mail
06:28:02 <dcoutts> byorgey: take a look at the list/info actions, they're in the same boat
06:28:10 <dcoutts> basvandijk: thanks
06:28:23 <basvandijk> dcoutts: I'm actually working on another patch for hackage-server: Package logo's
06:28:24 <byorgey> dcoutts: ah, an excellent idea!  why didn't I think of that =)
06:28:28 <dcoutts> byorgey: in cabal-install Main they're doing (comp, conf) <- configCompilerAux' configFlags
06:28:43 <dcoutts> byorgey: using configFlags obtained from the user's config file
06:28:58 <byorgey> ah, I see
06:29:06 <dcoutts> so that means you'll get the right compiler
06:29:15 <Feuerbach> basvandijk: "Monady" -- nice typo :)
06:29:15 <byorgey> great.
06:29:15 <dcoutts> e.g. if the user configured to use hugs or uhc or something
06:29:23 <kamaji> What would be a good way to convert a list of two items to a tuple?
06:29:32 <basvandijk> Feuerbach: hi hi
06:29:41 <dcoutts> byorgey: you can also see what list/info do for getInstalledPackages
06:29:43 <kamaji> I saw something once with `ap` and something like (,) but I didn't understand it
06:29:59 <byorgey> right, exactly.  OK, thanks dcoutts, I'll go read some code =)
06:30:37 <Philonous> When profiling with GHC, can I add a cost centre to an IO action so that the time of the action being performed rather than evaluated is measured?
06:30:58 <Feuerbach> kamaji: I'd use: case list of [x, y] -> (x,y)
06:31:47 <kamaji> oh ok
06:32:06 <kamaji> I guess I could do x1:x2:xs as well
06:33:03 <dcoutts> basvandijk: ok, applied. Re the rss, I might wait and apply those once you make the new release of the rss package. It just makes it a bit easier for people playing with the code.
06:33:22 * dcoutts looks at basvandijk's 3rd patch set
06:33:32 <basvandijk> dcoutts: I think I release rss today
06:33:38 <dcoutts> great
06:34:19 <basvandijk> dcoutts: the 3rd patch set, is that the json->aeson switch patch?
06:34:24 <dcoutts> yep
06:34:38 <dcoutts> I see, so I should hold off applying that one too, wait for releases there
06:35:41 <basvandijk> dcoutts: probably a good idea. Unfortunately Bryan is a bit slow to merge pull requests lately. Probably swamped.
06:35:59 <dcoutts> he's still quicker than me :-)
06:36:23 <basvandijk> dcoutts: not with my patches ;-)
06:38:53 <basvandijk> dcoutts: the package logo's patch is almost finished. I'm not sure if it's in line with the big design of hackage-server. So there's a chance that I have to do it over. Fortunately there's not much code
06:39:23 <dcoutts> hmm? logo?
06:39:38 <dcoutts> basvandijk: I'm not sure what you're talking about :-)
06:40:51 <basvandijk> dcoutts: You can put a logo.svg or logo.png file in your package root. Once you upload the package the logo is added the the blob store. When you browse to the package page you see the logo.
06:41:29 <basvandijk> These days, all app-stores have logo's. We should have one too :-)
06:41:32 <dcoutts> basvandijk: oh I see. Or we can serve it directly out of the package tarball.
06:41:39 <dcoutts> like we do for the changelog
06:42:17 <basvandijk> dcoutts: Mmm that's also possible. I thought that was not as performant but I could be wrong
06:42:58 <dcoutts> it should be ok, we store the package tarball uncompressed and we have an index of file names to offsets in the uncompressed tarball
06:43:35 <basvandijk> dcoutts: ok great, then I will modify my patch to do that.
06:44:22 <basvandijk> dcoutts: In general it would be great to have a package "file explorer"
06:44:30 <dcoutts> basvandijk: we do!
06:44:37 <dcoutts> take a look at how the changelog serving works, it's based on the generic code for serving the entire package contents
06:44:59 <dcoutts> but using a particular search algorithm to find the changelog, and serving it as a separate resource
06:45:12 <basvandijk> dcoutts: cool! I will look at it.
06:46:45 <byorgey> ooh, logos =)
06:49:44 <dcoutts> basvandijk: ok, ping me when the new rss is out and I'll have another look at the patch to switch hackage-server to the new rss and drop the dep on the old-time
06:50:46 <basvandijk> dcoutts: sure. You know what, I will release it now
06:51:19 <dcoutts> basvandijk: oh so you've dropped the dep on old-time completely? I thought it was only part-way done
06:51:45 <basvandijk> dcoutts: no it's not dropped completely
06:53:03 <dcoutts> basvandijk: is there an advantage to releasing now before the conversion is complete?
06:53:20 <dcoutts> e.g. the hackage-server would still need to depend on old-time wouldn't in?
06:53:22 <dcoutts> in/it
06:54:24 <basvandijk> dcoutts: not directly. I just removed the old-time dep in hackage-server and it build fine
06:55:10 <basvandijk> You do need it when you use specific constructors from rss like: SkipDays :: [Day] -> ChannelElem
06:55:23 <basvandijk> where Day comes from old-time
06:56:29 <dcoutts> basvandijk: is there any problem with switching that to the Day type from Data.Time ?
06:57:16 <dcoutts> oh, the old one means weekdays, like Monday..Sunday
06:57:25 <basvandijk> Indeed
06:58:22 <basvandijk> The best solution is to add a WeekDay type to time.
06:58:58 <dcoutts> the time lib has some stuff to do with weekdays
06:59:03 <dcoutts> what does SkipDays do?
06:59:18 * dcoutts unpacks rss
06:59:54 <basvandijk> To be honest, I have no idea. I have to dive into the rss spec to see what it does
07:00:09 <dcoutts> basvandijk: you could just define a local Enum it looks like
07:00:14 <dcoutts> there's no interesting calculation
07:00:29 <kamaji> Why is lines.getContents unbuffered in ghci but not when I use "runhaskell?
07:00:47 <basvandijk> dcoutts: Yes I thought about copying the Day type from old-time to rss. But that feels a bit wrong
07:01:03 <dcoutts> basvandijk: but it's not doing anything sophisticated
07:01:12 <dcoutts> there's no code to manipluate week days
07:01:22 <dcoutts> it's really just an enum with a Show instance
07:01:27 <dcoutts> that's how it's being used
07:02:09 <basvandijk> dcoutts: Ok I will copy the Day type to rss
07:02:19 <dcoutts> http://www.rssboard.org/skip-hours-days
07:02:21 <basvandijk> and completely drop the dep on old-time
07:02:56 <dcoutts> it also looks like it's a feature that's pretty rarely used
07:03:05 <basvandijk> yes indeed
07:03:12 <dcoutts> ok great
07:05:22 <glass> does anyone have any recommendations for haskell IDE's w/ good auto complete?  it's sort of an issue given my RSI issues...
07:05:38 <basvandijk> eclipse?
07:05:52 <donri> what sort of autocomplete?
07:06:03 <glass> that's the best I found, but it's so so in my opinion
07:06:20 <glass> symbol name completion mostly
07:06:49 <donri> based on?
07:07:19 <glass> the first few letters of the name + context of where you are typing it would be nice
07:07:52 <donri> from source?
07:07:57 <glass> think intelliJ/pycharm if you have used those tools
07:07:58 <donri> there are many kinds of autocomplete
07:08:37 <glass> or visual assist in VS
07:08:59 <donri> haskell might be difficult to complete intelligently since qualified imports aren't really the norm
07:09:31 <donri> i've read about haskell-specific ides that do it though
07:09:49 <donri> otherwise i'd consider learning vim or emacs and set up completion by ctags
07:10:18 <glass> so in the case of pycharm, it literally scans the entire python install for all libs and symbols.  memory is cheap these days :)
07:10:58 <donri> yea, python is even more difficult because it's runtime dynamic, but i have it working to some extent with vim's omnicompletion
07:11:09 <basvandijk> Should WeekDay be written in camel-case or not (Weekday) ?
07:11:55 <donri> I'd write it Weekday, excessive camel case only hurt readability IMO
07:12:15 <basvandijk> donri: thx
07:12:36 <glass> I actually know vim but haven't used it for dev in awhile... and only used ctags to jump to C++ function defs.  is the omnicompletion decent?
07:13:05 <donri> haven't looked into omni with haskell
07:23:00 * dfeuer is away: Taking the goddamn meds.
07:23:05 <basvandijk> dcoutts: A new rss-3000.2.0 is uploading...
07:23:56 * dfeuer is back (gone 00:00:56)
07:23:57 <dcoutts> nice
07:24:20 <donri> dfeuer: splendid! how useful!
07:24:40 <ion> Thank you for the information!
07:26:17 <basvandijk> dcoutts: would you now like to drop the dep on old-time in hackage-server. Or should I create a patch?
07:26:48 <dcoutts> basvandijk: I was planning to start with the patch you sent previously, will it need much else?
07:27:02 * hackagebot DSH 0.7.5 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.7.5 (GeorgeGiorgidze)
07:27:23 <basvandijk> You can just apply it and then drop the dep on old-time
07:27:34 <dcoutts> ok, will do that
07:27:37 <basvandijk> dcoutts: thx
07:27:44 * basvandijk is going to get a coffee
07:59:52 <xcvii> hey, is there an easy way within haskell to take a string containing a haskell expression, and compile it into ghc core?
08:00:48 <basvandijk> scsibug_: http://hackage.haskell.org/package/hint
08:01:55 <basvandijk> xcvii: I'm not sure if that compilies into ghc-core
08:02:11 <hpc> xcvii: not even remotely; there's mueval, which is hard to set up but fairly straightforward to use
08:02:21 <hpc> > text "it works like this"
08:02:22 <lambdabot>   it works like this
08:02:40 <hpc> (not with the text function; it's what lambdabot uses to run haskell code)
08:02:55 <xcvii> i have used hint, but i don't think it supports ghc core ):
08:03:16 <xcvii> hpc: cheers, i'll check it out
08:03:51 <hpc> if you are using GHC >= 7, i have no clue how well it will work, or if at all
08:05:05 <xcvii> in fact i'll be happy if i can get something like this running, no matter the ghc version (:
08:05:21 <hpc> @hackage lambdabot
08:05:21 <lambdabot> http://hackage.haskell.org/package/lambdabot
08:05:54 <hpc> ^ iirc it's Plugin/Eval.hs that has the code for calling out to mueval, when you want to use it in haskell code
08:06:12 <hpc> i don't recommend calling the mueval library directly, because it can crash
08:07:52 <dcoutts> basvandijk: how did you get it to build with 7.2.x at all? the xhtml package doesn't build for 7.2
08:08:47 <basvandijk> dcoutts: xhtml builds just fine here with ghc-7.2.1
08:09:01 <basvandijk> I have xhtml-3000.2.0.4 installed
08:09:15 <dcoutts> Implicit import declaration:
08:09:15 <dcoutts>     base:Prelude can't be safely imported! The package (base) the module resides in isn't trusted.
08:09:21 <dcoutts> is what I get for 3000.2.0.4
08:09:25 <basvandijk> ghc-pkg trust base
08:09:29 <basvandijk> and your fine
08:09:40 <basvandijk> that bug is fixed in ghc-7.4
08:10:12 <dcoutts> ok, I suspected it'd be worse
08:10:29 <dcoutts> having to trust everything recursively
08:11:30 <dcoutts> gah, and package trust settings are not per user
08:13:33 <kamaji> If I want to define a really simple Vector2D class, how should I go about giving it a + operator?
08:14:20 <ion> Make it an instance of Num
08:14:28 <xcvii> you could make it an instance of Num or perhaps Functor
08:16:06 <kamaji> so it's "type Vector a = (a,a)"
08:16:26 <kamaji> do I just add "instance Num Vector a where" ?
08:17:05 <xcvii> you'll be better off with an ADT: data Vector a = MkVector (a,a)
08:18:21 <kamaji> ADT?
08:18:31 <donri> for lambdabot, I get: Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short) -- ideas?
08:18:39 <sipa> instance Num a => Num (Vector a) where ...
08:19:07 <dcoutts> donri: is /usr/lib/libncurses.so a real .so file?
08:19:13 <dcoutts> what does ldd think about it?
08:19:21 <sipa> instance Num a => Num (Vector a) where { Vector (a,b) + Vector (c,d) = Vector (a+c, b+d) }
08:20:07 <kmc> it's probably a linker script
08:20:17 <kmc> you can rebuild readline to look for libncursesw instead
08:20:33 <donri> ldd: warning: you do not have execution permission for `/usr/lib/libncurses.so'; lddlibc4: cannot read header from `/usr/lib/libncurses.so'
08:20:35 <kamaji> sipa: ah ok
08:20:54 <donri> could this be a fedora bug?
08:21:15 <sipa> kamaji: since you're calling + itself yourself, but this time with arguments of type a, you need the Num a constraint
08:22:41 <akosch> could I somehow combine Data.Tree / drawForest with show to draw my forest with non-string nodes?
08:22:43 <basvandijk> dcoutts: I'm trying to understand resource strings. I would like my logo URL to be like /package/usb-1.1/logo.svg (or .png) so I added the resource: (resourceAt "/package/:package/logo.:format") {...}. However when I browse to the above URL I get a 404 error.
08:23:58 <kamaji> sipa: oh I get Illegal instance declaration
08:24:43 <basvandijk> dcoutts: Ah I discovered something: the {...} is actually: { resourceGet = [("image", runServerPartE . servePackageLogo store)] } Now when I browse to /package/usb-1.1/logo.image I get a response (and format = image)
08:24:44 <dcoutts> basvandijk: you need to provide a corresponding resource that provides that format
08:25:24 <dcoutts> basvandijk: do you really want to use a .svg or .png? we don't expect packages to provide both
08:25:32 <sipa> kamaji: paste your code somewhere
08:25:59 <basvandijk> My idea was that packages could use either svg or png.
08:26:10 <basvandijk> And svg is preferred over png
08:26:16 <dcoutts> basvandijk: right but we'll want to provide a single url
08:26:29 <dcoutts> providing resource specific ones is always ok too
08:26:33 <dcoutts> erm, format specific
08:26:37 <basvandijk> yes that's also possible
08:26:57 <basvandijk> so just /package/usb-1.1/logo ?
08:27:01 <dcoutts> basvandijk: right
08:27:30 <dcoutts> basvandijk: and that'll serve whichever is available (and if both then the format that's preferred)
08:27:33 <mah_b> akosch: what about drawForest $ fmap show myForestWithSomeOtherType?
08:28:13 <akosch> mah_b: I was trying that one just a second ago :)
08:28:32 <dcoutts> basvandijk: this idea with this :format thing is that we have a common url and that one does content negotiation, but we also provide format specific urls, and those get the one specific format
08:29:01 <akosch> mah_b: ah, forest is a list of trees so I need to map (fmap show)
08:29:09 <dcoutts> basvandijk: so this use case is actually a good example, since we'll want to have all links go to the generic one
08:29:13 <akosch> mah_b: thanks
08:29:58 <mah_b> akosch: you're welcome
08:30:13 <hpaste> Kamaji pasted “Vector type instance” at http://hpaste.org/52970
08:30:21 <kamaji> sipa: http://hpaste.org/52970
08:30:48 <kamaji> it doesn't really work as Num anyway, because * would have to return a vector
08:31:12 <kamaji> well, I guess that would bea  transpose actually
08:31:15 <kamaji> ignore that ^ :D
08:31:21 <ion> I don’t see a problem with (*) :: Num a => Vector a -> Vector a -> Vector a.
08:31:39 <kamaji> I was just being a dumbass
08:31:50 <ion> Might as well do numberwise multiplication and have another operator for a vector product.
08:31:57 <kamaji> yeah
08:32:04 <kamaji> so you think I should just define operators not in a class?
08:32:05 <ion> s/vector product/dot product/
08:32:14 <kamaji> because that conflicts with Prelude
08:32:49 <ion> If you don’t define operators that conflict with Prelude, they won’t conflict with Prelude.
08:33:20 <sipa> kamaji: (a,b) is not of type Vector a
08:33:25 <sipa> kamaji: Vector (a,b) is
08:33:59 <kamaji> sorry, i'm still a bit lost?
08:34:08 <sipa> you're trying to add tuples to eachother
08:34:18 <sipa> while you're defining an addition between vectors
08:34:28 <kamaji> how do I pattern match the vectors?
08:34:29 <xcvii> actually type defines a type synonym, so (foo,bar) is of type Vector a (for some a) as per this definition
08:34:40 <sipa> kamaji: what is the contructor for a fector?
08:34:45 <sipa> oh wait
08:34:51 <kamaji> well i'm totally confused.. :D
08:34:52 <sipa> you're using type, not data
08:34:55 <dcoutts> basvandijk: hmm, the deepseq vs containers thing is a bit annoying isn't it, for 7.2
08:35:00 <mah_b> kamaji: http://stackoverflow.com/questions/5683009/haskell-newtype-for-type-synonyms
08:35:19 <sipa> kamaji: are you using FlexibleInstances?
08:35:45 <xcvii> kamaji: data Vector a = Vector a
08:35:46 <basvandijk> dcoutts: Well if we just depend on the lastest containers and latest deepseq we're fine I guess.
08:36:07 <xcvii> this defines an algebraic data type
08:36:20 <TotoTitus> thought exposed loudly on general chat: i am confused
08:36:29 <TotoTitus> i'm almost finished with LYAH, and looking for other stuff, and there's so much going on
08:36:29 <dcoutts> basvandijk: I've added a trick in the .cabal file so we don't need people using current stable ghc to install a new containers or deepseq
08:36:30 <xcvii> with its own constructor, with this you can define Num operators in the way sipa wrote
08:36:44 <basvandijk> dcoutts: that's even better
08:36:45 <kamaji> xcvii: I don't understand how that's a vector
08:36:59 <TotoTitus> all sort of concepts, it's like the world of FP is enormously large
08:37:05 <xcvii> kamaji: ah sorry, data Vector a = Vector (a,a)
08:37:28 <kamaji> oh right
08:37:37 <kamaji> sorry, I just thought I was missing something, hehe
08:37:50 <TotoTitus> i'm only starting to feel a bit comfortable with monads, and bang! something called 'monad transformers' exist
08:38:34 <basvandijk> dcoutts: something else: I'm checking out the change log feature and I noticed it serves files which look like:  ["ChangeLog", "CHANGELOG", "CHANGE_LOG", "Changelog", "changelog"]. In my packages I always use a NEWS file. Isn't it an idea to also add ["News", "NEWS", "news"] to that list ?
08:38:38 <TotoTitus> it makes me think, how much more knowledge do i have to graps before i actually write a useful program
08:39:06 <dcoutts> basvandijk: depends if we think those are the same thing, I see packages with both
08:39:35 <dcoutts> basvandijk: also, we might try and do something like have the changelog be in a particular parsable format
08:39:37 <kmc> TotoTitus, you don't need to understand monad transformers or even monads to write a useful program
08:39:47 <kmc> but yeah, there is a lot to learn
08:39:52 <basvandijk> dcoutts: that would be nice
08:40:08 <kmc> the world of FP is enormously large
08:40:21 <dcoutts> basvandijk: it's perfectly plausible that we can serve all of: changelog, news, readme, license etc, we just need to decide which ones are logically different
08:40:33 <kamaji> xcvii: now it just says it can't match the Vector type against a tuple
08:40:41 <kmc> because functional languages are where interesting language design stuff is done
08:40:49 <kmc> and some of it gradually trickles into "mainstream" languages
08:41:00 <sipa> kamaji: now you are defining an addition between vectors, but your + operation takes tuples as arguments
08:41:08 <sipa> (x1,y1) is a tuple, not a Vector a
08:41:09 <kamaji> sipa: but I need to pattern match
08:41:14 <sipa> yes
08:41:18 <kamaji> so how do I get the values out of the tuple?
08:41:24 <sipa> how do you make a vector?
08:41:30 <kamaji> Vector (foo,bar)
08:41:33 <sipa> bingo
08:41:37 <kamaji> I tried that...
08:41:41 <sipa> show me
08:42:15 <kamaji> oh, I forgot to return a vector >_>
08:42:46 <kamaji> so many brackets :(
08:43:22 <sipa> you don't need many
08:43:43 <kamaji> oh, I don't need (Vector (x1,x2))
08:43:44 <jweofijm> @pl \ x y -> f (g x y)
08:43:45 <lambdabot> (f .) . g
08:43:46 <kamaji> 'kay
08:43:48 <sipa> 17:31:20 < sipa> instance Num a => Num (Vector a) where { Vector (a,b) + Vector (c,d) = Vector (a+c, b+d) }
08:46:20 <kamaji> oh, sorry
08:50:18 <deech> Hi all, does anyone use Scion for active development? I have found that it hangs when doing continous compilation and doesn't flag some errors.
09:02:09 <basvandijk> dcoutts: I see the PackageContents feature can already serve our logo by just getting: /package/:package/src/logo.svg. What do you think is nicer having a dedicated URL /package/:package/logo or just using the PackageContents feature?
09:04:08 * basvandijk is away for 5 min.
09:07:01 <akosch> I'm trying to build a shortest path tree, but have no idea how to implement Dijkstra's algorithm in a functional way. has someone done this before?
09:08:16 <fryguybob> I think Cale has an A-star implementation
09:08:23 <fryguybob> akosch: http://hackage.haskell.org/package/astar
09:08:41 <akosch> fryguybob: thanks, I'll check it out
09:09:48 <mah_b> akosch: http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/src/Data-Graph-Inductive-Query-SP.html#dijkstra
09:12:35 <akosch> mah_b: thanks, looks great!
09:16:16 <kamaji> How do I convert Int to Int64?
09:16:29 <basvandijk> kamaji: fromIntegral ?
09:20:01 <kamaji> basvandijk: oh, thanks
09:22:45 <rostayob> oh man, I just discovered that you can define undefined using fix
09:22:57 <rostayob> this is great
09:23:11 <sipa> you can define bottom using fix, but undefined is another bottom :)
09:23:14 <smop_> is there any way i can fix this http://hpaste.org/52971 i think i need to add a flag when i install it or something
09:23:25 <rostayob> sipa: well you can define something of type :: a
09:23:30 <sipa> yes
09:23:37 <rostayob> that diverges
09:24:06 <rostayob> pretty cool ehe
09:25:43 <parcs_> > fix undefined
09:25:44 <lambdabot>   *Exception: Prelude.undefined
09:25:51 <c_wraith> was undefined broken?
09:25:56 <rostayob> > let und = fix id
09:25:56 <lambdabot>   not an expression: `let und = fix id'
09:26:13 <sipa> > let und = fix id in und
09:26:17 <lambdabot>   mueval-core: Time limit exceeded
09:26:26 <rostayob> @t let und = fix id in und
09:26:26 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:26:36 <rostayob> :t let und = fix id in und
09:26:37 <lambdabot> forall a. a
09:28:09 <parcs_> i think being able to define a non-bottom expression using fix is even cooler
09:28:27 <rostayob> well that's less surprising
09:28:29 <rostayob> that's what fix is for
09:29:09 <parcs_> is it?
09:29:16 <rostayob> parcs_: to define recursive functions
09:29:47 <rostayob> fix is the only way to define recursive functions in lambda calculus
09:30:05 <basvandijk> For example
09:30:06 <basvandijk> > let fac = fix $ \f x -> if x == 0 then 1 else x * f (x-1)
09:30:07 <lambdabot>   not an expression: `let fac = fix $ \f x -> if x == 0 then 1 else x * f (x-...
09:30:15 <mercury^> Nah, there are other ways.
09:30:27 <rostayob> > let fac = fix $ \f x -> if x == 0 then 1 else x * f (x-1) in fac 5
09:30:28 <lambdabot>   120
09:30:33 <parcs_> fix isn't 'for' defining non-bottom expressions
09:30:46 <rostayob> mercury^: really? how?
09:30:52 <DanielDiaz> Hi all! Someone knows how to create popup menus with gtk? I've done a few attempts without success.
09:31:28 <DanielDiaz> I'm only creating empty menus. Menu items do not appear.
09:31:29 <rostayob> in simple lambda calculus you're going to use a combinator similar to fix to encode recursion
09:33:20 <mercury^> rostayob: right.
09:33:38 <mercury^> I had just typed one up, then you made it unnecessary to post it. :(
09:34:03 <cheater> parcs_: what is fix for then
09:37:14 <parcs> it's for finding the least fixed-point of a function. it may be bottom, or it may be not
09:37:53 <rostayob> parcs: well in lambda calculus, fix's main use is to encode recursion
09:40:13 <basvandijk> cheater: If you have a big recursive function that you need to write using a let (because it references lambda-bound variables for example) like: "let go = <big expression> in go" the final "in go" can sometimes be far away from where it is bound. If you use fix you don't need the "in go": fix \go -> <big expression>
09:40:16 <monochrom> the least fixed-point of a function = recursion
09:40:56 <cheater> basvandijk: interesting
09:41:17 <parcs> is there any recursion going on in fix return 5 ?
09:41:50 <MAUKE> > fix return
09:41:51 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
09:41:56 <MAUKE> yes
09:41:59 <monochrom> heh
09:42:19 <monochrom> perhaps you have fix (const True) in mind
09:42:57 <monochrom> but "is 'x=5' a recursive definition?" is the same question as "is a square a rectangle"
09:43:10 <basvandijk> cheater: For another example of fix look at the implementation of >>= for Iteratees:
09:43:16 <basvandijk> http://hackage.haskell.org/packages/archive/enumerator/0.4.14/doc/html/src/Data-Enumerator.html#Iteratee
09:43:25 <cheater> thx
09:43:34 <parcs> oops :P
09:43:40 <rostayob> I think that the best way to understand fix is this definition: fix f = f (fix f)
09:43:57 <rostayob> recursion is definitely in there ehe
09:44:03 <rostayob> and you can also see why it works
09:45:33 <gratemyl> any hledger users around? i'm having trouble getting it to install through cabal on debian squeeze.
09:45:58 <gratemyl> (sorry, hledger installs just fine, as do the other extensions, just hledger-web is an issue)
09:46:02 <monochrom> afterall, if I wrote 'x = const 5 x', the type-checker has to assume I am writing a recursive definition, it can't know better.
09:47:19 <hiptobecubic> monochrom, i don't understand what is happening there
09:47:29 <hiptobecubic> monochrom, 'x = const 5 x'.
09:48:09 <hiptobecubic> oh... wait. const throws out the second var?
09:48:20 <monochrom> you have not heard of const? :)
09:48:23 <Philonous> const a b = a
09:48:29 <hiptobecubic> yeah i just did :t const
09:48:34 <hiptobecubic> i guess i see what's happening
09:48:43 <cheater> @src const
09:48:43 <lambdabot> const x _ = x
09:48:56 <hiptobecubic> the laziness means that x is never evaluated in the definition?
09:48:57 <cheater> :t const
09:48:57 <lambdabot> forall a b. a -> b -> a
09:49:40 <monochrom> right. would blow up in SML.
09:49:52 <hiptobecubic> sml?
09:50:02 <monochrom> SML is an eager functional language
09:50:11 <hiptobecubic> ah
09:51:00 <kmc> that's a good little example
09:51:01 <kmc> i like it
09:51:35 <monochrom> thanks
09:57:31 <dmwit> gratemyl: You should consider just putting the error output up on hpaste.org.
09:57:46 <dmwit> Even somebody who doesn't use hledger might have a clue for you.
09:58:31 <gratemyl> okay will do
10:28:55 <mmos1127> question at http://hpaste.org/52973
10:32:57 <mmos1127> question at http://hpaste.org/52973
10:33:26 <ClaudiusMaximus> mmos1127: hFlush stdout works as expected for me
10:33:41 <ketil> what is polymorphism a la carte?
10:33:56 <ClaudiusMaximus> mmos1127: stops working if i do something like ./prompttest | tr
10:34:12 <ClaudiusMaximus> mmos1127: but that would be tr's fault
10:34:23 * ketil is watching Hickey's presentation, Simple made Easy.
10:36:14 <mmos1127> I'm on Windows, perhaps my IO needs different settings?
10:37:08 <dmwit> hFlush should Just Work
10:37:54 <Ikarus> hrm, interesting question (to me atleast) given [ (x, y-x) | y <- [0..], x <- [0..(div y 2)] ] is there any name for the pair list I am generating ?
10:37:57 <mmos1127> any ideas I just blindly try? changing IO settings?
10:38:04 <dmwit> mmos1127: If you change the "evaluate" line to just "return ()" and call it "main" instead of "lineFetch", do you still see bad behavior?
10:38:22 <dmwit> mmos1127: If such a minimal example is bad, you should probably report a bug, including OS version information and GHC version information.
10:39:39 <dmwit> > [(x, y-x) | y <- [0..], x <- [0..div y 2]]
10:39:39 <lambdabot>   [(0,0),(0,1),(0,2),(1,1),(0,3),(1,2),(0,4),(1,3),(2,2),(0,5),(1,4),(2,3),(0...
10:40:19 <Ikarus> it generates all natural pairs, but excludes the mirrored version of them
10:41:13 <Ikarus> (except those that are their own mirror)
10:41:58 <dmwit> It's the powerset of the naturals, filtered to only include sets of size two.
10:42:10 <dmwit> (Just another way to describe it; not a name, really.)
10:42:24 <Ikarus> dmwit: hehe yeah, I was just wondering if anyone did know a name for it
10:42:27 <Ikarus> but I guess not
10:42:32 <dmwit> { x | x \subset N, |x| = 2 }
10:42:39 <mmos1127> dmwit: I'm not sure if this is a mimmal example, my implementation of lineParse is complicated. But it is pure, so maybe doesn't matter how complicated. I do want it to be evaluate, since I want to catch exceptions. I'll try return
10:42:40 <Ikarus> (it's a useful set though)
10:42:44 <zzo38> I invented a typeclass for classical logic, by proving the law of excluded middle for each type that has that class.
10:44:26 <mmos1127> dmwit: changing to "return" fixes it!
10:44:42 <dmwit> mmos1127: huh
10:45:46 <dmwit> evaluate breaks the monad laws!!!
10:46:16 <zzo38> Describe how evaluate breaks the monad laws
10:46:22 <dmwit> From the documentation: "(return $! x) >>= return is a correct implementation, but (return $! x) is not"
10:46:35 <zzo38> O, that is how.
10:46:36 <dmwit> But monad law number one is "m >>= x === m".
10:46:53 <dmwit> err
10:46:59 <dmwit> "m >>= return === m"
10:47:00 <dmwit> sorry
10:47:46 <mmos1127> dmwit: not sure I follow... does that mean it's not a bug? i.e. the behavior is know or cannot be fixed in advance?
10:47:58 <mmos1127> ^ not known
10:48:06 <dmwit> mmos1127: It sounds like it is not a bug, and you just used evaluate wrong.
10:48:26 <dmwit> However, I would say the existence of "evaluate" is a bug, now that I have read its documentation.
10:48:29 <dmwit> =P
10:48:53 <mmos1127> dmwit: how would I be able to use it right?
10:49:14 <zzo38> How many ways are there of making classical logic in Haskell?
10:50:05 <ciaranm> zzo38: countably infinitely many
10:50:12 <ion> Exactly three.
10:50:16 <zzo38> I mean how many and which ways have been done.
10:50:39 <zzo38> ion: Why do you say exactly three? What are those three ways?
10:50:41 <dmwit> mmos1127: Dunno! Maybe it's as easy as doing "v <- evaluate blah; return v".
10:50:56 <ion> Just joking
10:51:33 <zzo38> ion: OK. But still, what are some ways?
10:51:56 <dmwit> zzo38: There are half a dozen axioms that are equivalent to the law of the excluded middle.
10:52:16 <dmwit> Any of those are perfectly good candidates for the type of the function in the class.
10:52:20 <zzo38> dmwit: Yes. One property of proper monads is that you can make it in terms of fmap/unit/join instead of return/bind, or Kleisli composition.
10:52:30 <dmwit> And there are probably billions of ways to encode Not.
10:53:20 <mmos1127> dmwit++++  That fixes it
10:53:28 <dmwit> To be honest, I'm not even sure what the question "How many ways are there to do X in Haskell?" even means.
10:53:40 <dmwit> mmos1127: yay! =)
10:54:15 <ion> @faq Can Haskell compute the number of ways there are to do things in Haskell?
10:54:15 <lambdabot> The answer is: Yes! Haskell can do that.
10:54:17 <zzo38> dmwit: Yes, I know of Peirce's law, and it is what Curry-Howard suggest, by using continuations. I did not need continuations, I used law of excluded middle as axiomatic, and then proven Peirce's law from double negation elimination.
10:55:56 <zzo38> Contradiction imply anything is provable from intuititionistic logic, but Haskell does not support empty case blocks.
10:56:16 <zzo38> So I had to put that in the class too.
10:56:40 <dmwit> ?djinn Void -> a
10:56:41 <lambdabot> f = void
10:56:48 <dmwit> ?djinn-env
10:56:48 <lambdabot> data () = ()
10:56:49 <lambdabot> data Either a b = Left a | Right b
10:56:49 <lambdabot> data Maybe a = Nothing | Just a
10:56:49 <lambdabot> data Bool = False | True
10:56:49 <lambdabot> data Void
10:56:50 <lambdabot> type Not x = x -> Void
10:56:52 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
10:56:54 <lambdabot> class Eq a where (==) :: a -> a -> Bool
10:57:05 <byorgey> void = undefined
10:57:09 <byorgey> sadly
10:57:12 <dmwit> cheaters
10:57:18 <zzo38> byorgey: See? That is what is wrong with it!
10:57:32 <byorgey> I thought I remembered seeing a proposal to add empty case statements to Haskell.  Dunno what happened to it.
10:57:58 <byorgey> I originally thought it was part of -XEmptyDataDecls but I guess not.
10:58:33 <PDani> hi
10:58:42 <byorgey> welcome, PDani
10:58:54 <Guest578> hallo
10:59:05 <byorgey> hi Guest578, welcome
10:59:38 <PDani> Graphics.GD can nicely load an image, draw into it, etc, but i can't see, how can it get color information of a pixel (http://hackage.haskell.org/packages/archive/gd/3000.4.0/doc/html/Graphics-GD.html). is this possible at all?
11:00:00 <zzo38> Yes I do think empty case statements in Haskell is good idea, one reason is for Curry-Howard, but another reason might be use with macros if there is such macros, or TH, or just in case you did not write that part of the program yet and want to program it in to test it in GHCi
11:00:06 <dmwit> getPixel :: (Int, Int) -> Image -> IO Color
11:00:07 <dmwit> PDani: ?
11:00:34 <PDani> oh my god :) i must be blind :)
11:00:37 <PDani> thx
11:00:40 <PDani> and sorry
11:02:39 <dmwit> mmos1127: By the way, I can't reproduce your problem here. I'd love to see a minimal example, so I could write it up as a warning for other Haskellers. =)
11:03:57 <zzo38> This is how I prove Peirce's law:   unswitcheroo . contrapositive .> mapR (contrapositive switcheroo') .> mapR (map1 undoubleNot . undeMorgan) .> mapL ((,) ()) .> either snd fst
11:04:22 <kmc> zzo38, what's the type of that expression?
11:04:31 <zzo38> (Classical p, Classical q) => ((p -> q) -> p) -> p
11:04:36 <mmos1127> dmwit: are you on windows XP? Also note I'm using haskell platform 2010.2.0.0 (not the latest GHC I think)
11:05:08 <dmwit> No, all the technology I have is different from yours.
11:10:07 <zzo38> I realized I had an unnecessary step in that proof, which I have now removed.
11:10:58 <hsalamin> #who
11:19:44 <Sgeo|web> Wait, why does that return an IO Color?
11:22:27 <shachaf> Presumably it does IO.
11:22:38 <shachaf> (FSHVO "IO")
11:23:12 <erus`> why would it
11:24:21 <shachaf> Maybe it's a binding to a very imperative mutable library?
11:26:28 <byorgey> PDani: by the way, you seemed to be looking at the documentation for an old version of gd, which did not have getPixel
11:26:37 <byorgey> PDani: perhaps that's why you could not find it.
11:27:45 <dmwit> erus`: Because it's doing pointer dereference, presumably, and Image is a wrapper around a mutable type.
11:27:58 <dmwit> (So it's not safe to hide the dereference behind an unsafePerformIO.)
11:28:17 <erus`> yuck
11:30:13 <kmc> shachaf, FSVO "does" too ;)
11:30:37 <shachaf> kmc: True.
11:31:17 <kmc> shachaf, what's your 'H' stand for?
11:31:23 <shachaf> Haskell.
11:31:41 <shachaf> I mean that it probably doesn't do either "input" or "output", just looks at mutable memory.
11:31:52 <shachaf> But Haskell calls everything IO.
11:34:25 <Ikarus> hrm, meh, is there a guide that teaches writing good, well formatted, readable, reusable Haskell
11:35:57 <BOTJE> LeNsTR: please turn that off
11:42:03 * hackagebot sednaDBXML 0.1.2.3 - Sedna C API XML Binding  http://hackage.haskell.org/package/sednaDBXML-0.1.2.3 (EricJones)
11:51:22 <napping> Is http://haskell.org/ghc/docs/latest/html/users_guide/bugs.html out of date?
11:51:33 <napping> I can't get data U = MkU (U -> Bool)
11:51:39 <napping> to make the inliner diverge
11:52:11 <kmc> works for me, are you using -O
11:52:23 <napping> ah
11:52:30 <napping> --make -O, but didn't clean
11:52:42 <kmc> *nod*
11:52:43 <napping> there it goes
11:52:47 <kmc> imo --make should save the compiler flags in the .hi files
11:52:52 <kmc> and rebuild if you change those
11:52:56 <monochrom> oh, you want the bug? :)
11:53:25 <kmc> i tend to use -fforce-recomp a lot while testing, which somewhat defeats the usefulness of --make
11:53:46 <jmcarthur> ... really? Data.Array.Repa.(//) uses lookup on a list? wtf
11:54:45 <monochrom> is that list long?
11:54:55 <jmcarthur> it's a parameter to an exposed function
11:55:10 <jmcarthur> (//) :: (Shape sh, Elt a) => Array sh a -> [(sh,a)] -> Array sh a
11:55:50 <jmcarthur> it performs the lookup for every element of the new array :(
11:55:55 <monochrom> that's sad
11:56:03 <kmc> they probably expect that the list is short
11:56:25 <jmcarthur> IMO, that defeats the purpose of the function
11:57:56 <jmcarthur> i guess the alternative would be to make a mutable array and then update it, like vector does, but that might mess with repa's fusion i guess
11:58:11 <jmcarthur> still, the existence of this function seems to imply that it's efficient
11:58:29 * jmcarthur rolls his own using a more efficient container for lookup
11:59:02 <jmcarthur> what would really suck is if i had wanted to use this for a very long, lazily generated list
11:59:29 <jmcarthur> potentially with duplicate keys (the intent being to use the latest one)
11:59:55 <monochrom> list is fine if you walk it once rather than search then search then search...
12:00:01 <jmcarthur> yeah
12:01:01 <monochrom> is there a reason (//) cannot walk the list just once?
12:02:11 <jmcarthur> if the array was manifest and didn't need to be shared it could be mutated, or if it wasn't important that the list be lazy it could be transformed into a map or something
12:02:32 <jmcarthur> vector doesn't something like the former, but it might be easier on vector since it's plain ol' stream fusion
12:02:42 <jmcarthur> instead of repa's explicit sharing thing
12:02:48 <jmcarthur> *vector does something
12:03:40 <jmcarthur> i'm actually not sure of the details behind vector's fusion and under-the-hood mutation
12:08:25 <Schalken> Am I supposed to use Data.HashTable or Data.HashMap?
12:08:45 <kmc> that depends on what you're using ;P
12:08:49 <kmc> what you're doing
12:08:54 <kmc> but I recommend http://hackage.haskell.org/package/unordered-containers for most purposes
12:09:13 <kmc> the Data.HashTable in 'base' is not an immutable functional structure
12:09:22 <kmc> it's mutated in place by IO actions
12:09:23 <byorgey> Schalken: HashTable is quite old and supposedly slow.  HashMap is a much more modern implementation, so I would use that
12:09:49 <kmc> which has various nasty consequences (both because it's a poor fit for Haskell, and because mutable data is worse in general even if we're in the minority for saying so)
12:09:59 <kmc> also it's just a bad implementation, iirc
12:10:27 <ddarius> @hackage hashtables
12:10:27 <lambdabot> http://hackage.haskell.org/package/hashtables
12:10:29 <kmc> i wouldn't be surprised if HashMap in an IORef is a better mutable hash table than HashTable
12:10:33 <kmc> especially in a concurrent context
12:10:34 <Schalken> Oh no, I was talking about this one: http://hackage.haskell.org/package/hashtables-1.0.0.0
12:10:39 <Schalken> Not the one in bash.
12:10:54 <Schalken> kmc: byorgey: ^
12:11:01 <Schalken> base*
12:11:02 <monochrom> in a concurrent context, a real hash table is a mess
12:11:06 <kmc> ah, that's still mutable, though
12:11:23 <monochrom> can't even get it correct easily, nevermind speed
12:11:38 <byorgey> Schalken: ah, I see!  Yes, that one looks nice too.  In that case I have no idea which one you should use.  Try both and pick whichever one you like better.
12:11:49 <monochrom> "if it doesn't have to be correct, I can make it even faster"
12:11:49 <ddarius> @google lock-free hash table
12:11:51 <lambdabot> http://www.azulsystems.com/events/javaone_2007/2007_LockFreeHash.pdf
12:11:51 <lambdabot> Title: A Lock-Free Hash Table
12:12:10 <kmc> Schalken, do you need a in-place mutable table for some specific reason?
12:13:07 <Schalken> kmc: Yes. I don't care about mutability. I'm going to have it in memory with about 700,000 Text -> Int entries, and it will be the bottleneck of my program. So all I care about is performance.
12:13:19 <kmc> that's not so many
12:13:35 <kmc> surely you care about something other than performance
12:13:51 <kmc> if you do not care about correctness then "main = return ()" is a fine solution
12:14:09 <roconnor> I don't understand dmwit's evaluate problem
12:14:10 <kmc> and if you do not care about the time it takes you to write the solution, then just wait 50 years and use a better language
12:14:13 <PDani> i got this from ghc: Expected type: a (Coord, Coord) Color      Actual type: IOToDiffArray array-0.3.0.2:Data.Array.IO.Internals.IOUArray (Coord, Coord) Color, but i bound a by (IArray a e) => .... what did i wrong?
12:14:17 <Schalken> kmc: Performance after correctness, of course.
12:14:49 <monochrom> give unordered-containers a try
12:15:29 <Schalken> monochrom: Is it as fast as the hash table in, python/PHP/JavaScript, say?
12:15:36 <roconnor> I don't see why do {v <- evalutate (lineParse li); return v} and do {evaluate (lineParse li)} would reorder IO behaviour.
12:15:39 <kmc> why don't you try it and find out
12:15:46 <roconnor> unless unsafePerformIO is being used
12:15:48 <monochrom> I havent' measured. but it's the fastest known
12:15:54 <kmc> there were some talks about unordered-containers, you can find benchmarks from those
12:16:04 <Schalken> monochrom: Thanks.
12:16:09 <kmc> "as fast as the hash table in Javascript" makes no sense
12:16:13 <Schalken> kmc: Oooh.
12:16:18 * Schalken googles
12:16:24 <kmc> there are many Javascript implementations with vastly different performance
12:16:41 <kk`> All Javascript objects can act like hashtables
12:16:49 <kmc> Schalken, if you really want to, throw together what you think is a representative test case, and benchmark unordered-containers versus hashtable
12:16:55 <kmc> use Criterion for  the benchmarking
12:17:01 <kk`> object.member and object["member"] are pretty much the same.
12:17:09 <Schalken> kmc: Alright.
12:17:18 <kmc> to me this sounds like more work than just using unordered-containers and seeing if it's fast enough
12:17:32 <monochrom> these days it is not even safe to ask "is python interpreted or compiled?"
12:17:41 <kmc> also even if it's not fast enough, there are various things you can do to improve performance without rewriting your code
12:17:52 <kmc> such as GC tuning
12:17:56 <kmc> or switching to the experimental 'hamt' branch of unordered-containers from github
12:18:20 <kmc> the benefit of the benchmark is that you'll save the work of writing your code in functional style and then rewriting it to use mutation
12:18:25 <kmc> if that really turns out to be necessary
12:20:04 <kmc> Schalken, saying you care about correctness and ease of implementation, but don't care about using a functional data structure, is inconsistent
12:20:57 <kk`> Is Purely Functional Data Structures by Chris Okasaki a good book? Has anyone here read it?
12:21:11 <cirno_the_greate> hello, fellas. Is there any function that return argument itself? (like x = x; need it for mapMaybe)
12:21:16 <kmc> > id 3
12:21:17 <lambdabot>   3
12:21:18 <kmc> @src id
12:21:18 <lambdabot> id x = x
12:21:22 <cirno_the_greate> thanks
12:21:25 <Schalken> kmc: Isn't functional purity a means rather than an end?
12:21:25 <kmc> kk`, I've read about half, and yes
12:21:29 <kmc> yes
12:21:33 <shachaf> @ty catMaybes
12:21:34 <lambdabot> forall a. [Maybe a] -> [a]
12:21:40 <kmc> it's a means to correctness and ease of implementation
12:21:45 <kk`> Ok, kmc, thanks.
12:21:46 <cirno_the_greate> shachaf: oh
12:21:49 <cirno_the_greate> shachaf: thanks :)
12:21:54 <shachaf> @src catMaybes
12:21:54 <lambdabot> catMaybes ls = [x | Just x <- ls]
12:22:19 <kk`> @src const
12:22:19 <lambdabot> const x _ = x
12:22:20 <monochrom> kk`: it is a good book.
12:22:39 <PDani> i woudl like to do something like this: getImage :: (IArray a e) => FilePath -> IO (a (Coord, Coord) e). but ghc complains. how can i keep the return value polymorphic?
12:22:59 <kmc> with difficulty
12:23:16 <kmc> data Foo = Foo (forall a e. a (Coord, Coord) e)
12:23:26 <Schalken> kmc: But if I can have something harder to implement but perform better, I still might be better off with the difficult implementation. It's cost-benefit.
12:23:26 <kmc> getImage :: FilePath -> IO Foo
12:23:35 <kmc> Schalken, yes, I agree
12:23:55 <kmc> of course the performance improvement might be useless, even if it's significant numerically
12:25:00 <kmc> "care about" does not mean "treat as the one overriding concern"
12:25:04 <Eduard_Munteanu> Wait, why does GHC complain about that?
12:26:11 <kmc> my point was that if you care about correctness and ease of implementation then you should care about the difference between immutable and mutable containers
12:26:15 <ddarius> kmc: That solution won't work3
12:26:31 <kmc> you might ultimately decide that you care about performance more than all of these things
12:29:30 <kamaji> Is there a mean function in some library/
12:29:33 <kamaji> operating on a list
12:30:29 <kk`> @hoogle mean
12:30:29 <lambdabot> No results found
12:30:41 <aristid> @hoogle average
12:30:41 <lambdabot> No results found
12:30:48 <Schalken> kmc: Well look at it this way. The situation is an intensive data processing project with free choice of programming language, and when my lecturer runs my code and it takes 20x longer than everyone else's to process the file because they all didn't use Haskell while I did, how do you think I'm going to look, regardless of what the "ease of implementation" was?
12:30:51 <kmc> http://book.realworldhaskell.org/read/profiling-and-optimization.html has a good example of writing a 'mean' function and performance tuning it
12:31:21 <aristid> @leat mean x = let xs = Data.Foldable.toList x in sum xs / length xs
12:31:22 <lambdabot>  <local>:3:44:
12:31:22 <lambdabot>      No instance for (Fractional Int)
12:31:23 <lambdabot>        arising from a us...
12:31:25 <aristid> @let mean x = let xs = Data.Foldable.toList x in sum xs / length xs
12:31:25 <lambdabot>  <local>:3:44:
12:31:26 <lambdabot>      No instance for (Fractional Int)
12:31:26 <lambdabot>        arising from a us...
12:31:28 <Eduard_Munteanu> Schalken: what sort of programs do you intend to write?
12:31:29 <napping> hmm, "statistics" has the fancy KDE stuff, and no mean?
12:31:41 <kmc> Schalken, unordered-containers is 20 times slower than PHP's hashtable? did you benchmark it?
12:31:47 <aristid> @let mean x = let xs = Data.Foldable.toList x in sum xs / fromIntegral (length xs)
12:31:48 <lambdabot>  Defined.
12:31:53 <aristid> :t mean
12:31:53 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t, Fractional a) => t a -> a
12:32:01 <Schalken> kmc: I'm being hypothetical.
12:32:03 <kamaji> kmc: Ah, cheers
12:32:18 <kmc> hypothetically your haskell code jumps out of the computer and stabs the lecturer in the eye
12:32:20 <kmc> now you look even worse
12:32:32 <kmc> also it is really stupid for your instructor to care about performance absent any context
12:32:35 <monochrom> hypothetical doesn't buy you productivity or credibility
12:32:36 <shachaf> kmc++
12:32:51 <kmc> like if they say "the point of this exercise is to write fast code, you will be graded on the number of seconds it takes", that is correct
12:33:24 <kmc> if they say "the point of this exercise is to produce correct results to this problem" then they should set a bar for performance and not care below that
12:33:27 <kmc> this is how the real world works
12:33:32 <byorgey> @oeis 1 8 31 78 120
12:33:33 <lambdabot>  Sequence not found.
12:33:38 <Eduard_Munteanu> "The point of this exercise is to choose the best tool for the job" :P
12:33:47 <kmc> in the real world you get 0 points for making your program run in 1 second instead of 10, if the only requirement is that it finish in a day
12:33:53 <napping> Schalken: I've had it go the other way - write Python, have some extra time to pick decent algorithms, beat the heck out of naive C
12:33:57 <PDani> kmc: thx
12:33:58 <monochrom> in retrospect, lecturers love to hide their marking schemes. mostly just because too lazy to even design the marking scheme early enough.
12:33:58 <companion_cube> :t uncurry div $ foldl (\(x,y) z-> (x+z,y+1)) (0,0)
12:33:59 <lambdabot>     Couldn't match expected type `(a, a)'
12:33:59 <lambdabot>            against inferred type `[b] -> (b, t)'
12:33:59 <lambdabot>     In the second argument of `($)', namely
12:34:10 <companion_cube> :t uncurry div . foldl (\(x,y) z-> (x+z,y+1)) (0,0)
12:34:11 <lambdabot> forall b. (Integral b) => [b] -> b
12:34:18 <kamaji> wait, so is there genuinely not a standard mean function?!
12:34:23 <companion_cube> > uncurry div . foldl (\(x,y) z-> (x+z,y+1)) (0,0) $ [1..10]
12:34:25 <lambdabot>   5
12:34:30 <kmc> kamaji, i'm sure e.g. the 'statistics' package has it
12:34:34 <Eduard_Munteanu> monochrom: is there a marking scheme at all, even?
12:34:46 <monochrom> there eventually is one
12:35:01 <kamaji> kmc: oh ok, cheers
12:35:27 <RarrRaptor> > let mean = f 0 0 where f n t [] = t/n; f n t (x:xs) = f (n + 1) (t + x) xs in mean [1, 4, 5]
12:35:27 <lambdabot>   3.3333333333333335
12:35:42 <RarrRaptor> Lazy and mean :(
12:35:50 <RarrRaptor> So to speak
12:35:51 <aristid> > mean [1,4,5]
12:35:52 <lambdabot>   3.3333333333333335
12:35:55 <monochrom> CS lectuerers are not evolved enough to the point of arts lecturers' full subjectiveness yet. mostly because CS is still a young field! XD
12:36:03 <RarrRaptor> @type mean
12:36:04 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t, Fractional a) => t a -> a
12:36:10 <RarrRaptor> Srsly?
12:36:20 <RarrRaptor> @hoogle mean
12:36:20 <lambdabot> No results found
12:36:34 <Eduard_Munteanu> Anyway, as far as some algos go, it might be a bit inconvenient to express them in Haskell, rather than C.
12:36:42 <kmc> Schalken, if you're pointing out that CS educators care too much about performance and not enough about correctness and programmer productivity... then you're unfortunately correct
12:36:54 <kmc> it's a consequence of Moore's Law
12:36:57 <Eduard_Munteanu> And in many cases you don't get to choose algorithms.
12:37:02 <napping> kamaji: it seems to be at Statistics.Sample.mean
12:37:07 <kmc> the educators learned to program many years ago, when machines were many times slower
12:37:17 <aristid> many many times slower
12:37:25 * monochrom would use Moore's law to justify biasing towards correctness
12:37:34 <kmc> (and had less memory, and language implementations were worse)
12:37:37 <napping> I like John Carmack's story about "infinitely fast computers"
12:37:52 <aristid> monochrom: but then you're an ivory tower functional programmer
12:37:54 <kmc> it's hard for someone even of my generation to appreciate how fast, say, V8's Javascript runs
12:38:04 <kmc> you can emulate a full x86 machine in Javascript in your browser
12:38:23 <rostayob> oh, bellard
12:38:31 <kmc> and yet instructors will tell you that anything other than C is unusably slow
12:38:33 <Eduard_Munteanu> Yeah, jslinux.
12:38:34 <monochrom> that's krad
12:38:36 <rostayob> that runs faster on firefox actually
12:38:41 <rostayob> last time i checked
12:39:05 <monochrom> which browsers use V8?
12:39:08 <Eduard_Munteanu> kmc: isn't Java popular in schools these days as well?
12:39:11 <aristid> monochrom: chrome.
12:39:22 <kamaji> napping: Ah ok, thanks, i'll check it out
12:39:23 <rostayob> monochrom: chrome
12:39:27 <kmc> Eduard_Munteanu, yes, you will still hear that it's unacceptable for performance though
12:39:29 <monochrom> nice
12:39:30 <rostayob> yes, boot time is half on firefox :P
12:39:37 <rostayob> kmc: not really
12:39:39 <kmc> or you'll hear that Java is fine but Javascript or Python is not
12:39:48 <Eduard_Munteanu> Heh.
12:39:57 <napping> ah, here we go: http://ve3d.ign.com/articles/news/45679/John-Carmack-Releases-Open-Source-Wolfenstein-iPhone-Port
12:39:58 <rostayob> in my experience this attitude is not there, or is not that bad anyway
12:40:09 <kmc> meanwhile nobody is even talking about difficulty of writing correct programs in one vs the other language
12:40:18 <napping> kamaji: do you need a good or fast one? sum and length is usually fine
12:40:30 <aristid> kmc: i sometimes get the impression that many haskell programmers care a lot about performance, too
12:40:59 <Eduard_Munteanu> Well, I understand the POV somewhat, because if you implement such algos in Haskell they will be almost inevitably slower than C or asm stuff.
12:41:24 <kamaji> napping: yeah that's what i'm doing for now
12:41:33 <kamaji> if it ends up being an issue then I will use Stats package
12:41:35 <kmc> aristid, the attitude I see in the Haskell community is that the core libraries should be heavily optimized, with all the GHC tricks etc
12:41:40 <monochrom> I don't understand porting the algorithms to Haskell (or Prolog for that matter).
12:41:43 <kmc> so that the "user-level" idiomatic code is fast
12:42:17 <Eduard_Munteanu> Because in CS you generally implement numerical algos or stuff like that, not full apps that can use fine-tuned libs under the hood (e.g. through the FFI)
12:42:32 <napping> Carmack was porting Wolfenstein to the iphone based on some open source code, which had somehow mutated to look up the texture for each wall by doing sprintf( name, "walls/%d.tga", wallNum ); and then a linear scan of strcmp over the texture table
12:43:00 <napping> Schalken: that's quite possibly the sort of C code an assignment will be up against, btw
12:43:15 <kmc> speaking of numerical algos... anyone have a suggestion for a library which computes 2D Voronoi tessellations?
12:43:30 <kmc> specifically one with a nice C API (or a Haskell API, but that's too much to ask)
12:43:36 <Schalken> I just think the frustrating part is that Haskell has 5 (Data.HashTable in base, Data.HashTable in hashtables, Data.Map, Data.HashMap in unordered-containers, Data.HashMap in hashmap) ways to create maps from arbitrary keys to values. This wouldn't be terrible if they were compatible - swap one out for another and see how it goes - but they're not.
12:43:55 <kmc> there's a lot more than those 5 :)
12:44:02 <Schalken> Some are mutable, some are not. If you pick the mutable one and find out an immutable one is faster, you have the ST monad lying around all over the place for no reason. If you pick the immutable one and find out the mutable one performs much better, you have to rewrite most of your code into the ST monad.
12:44:27 <kmc> that's a pretty fundamental problem though
12:44:34 <Schalken> Meanwhile every other mainstream language I know of has a generic hash table that everybody just uses without thinking and gives optimal performance in most cases. Why is mapping keys to values something such an advanced language like Haskell is still figuring out how to do?
12:44:43 <Eduard_Munteanu> napping: if you already have an algorithm you have to implement, I wouldn't be surprised dumb and dirty C code is still a lot faster than Haskell code you've spent days on.
12:44:55 <kmc> Schalken, because it's harder in a pure functional context
12:45:02 <rostayob> Schalken: because to map key to values in Haskell you probabaly want to use Map, which is pure and standard
12:45:06 <rostayob> well standard...
12:45:08 <kmc> Schalken, but also because Data.Map works fine for most things
12:45:39 <kmc> the existence of alternatives on Hackage doesn't imply that people think of it as an unsolved problem
12:45:53 <neitz> That isn't true, game companies ignore the STL completely in a lot of cases for example.  Options are good.
12:45:55 <aristid> c++ didn't come with a hash map until recently. it had a tree-based map
12:45:56 <kmc> by the way C and C++ do not have standard hash tables
12:46:01 <kmc> (C++11 might, I didn't look)
12:46:05 * ddarius also -highly- doubts the "optimality" of built-in/standard hash tables.
12:46:07 <rostayob> kmc: it does
12:46:24 <Eduard_Munteanu> In Soviet Russia, there's a single state-approved map :P
12:46:35 <aristid> Eduard_Munteanu: and it's stateful
12:46:42 <Eduard_Munteanu> Sure :)
12:46:51 <aristid> *giggle*
12:47:23 <monochrom> those generic hash tables are probably not optimal performance in most cases. see http://enfranchisedmind.com/blog/posts/problems-with-hash-tables/
12:47:43 <kmc> Java too has Hashtable, TreeMap, HashMap...
12:47:58 <rostayob> kmc: well but they're all in the standard library
12:48:01 <Associat0r> kmc: unordered_map
12:48:14 <rostayob> but anyway, haskell has containers, which is a good package for these kind of things
12:48:32 <rostayob> and has other have said most of the times hash maps are incovenient in haskell
12:48:43 <aristid> Data structures are hard, let's go shopping.
12:48:52 <kmc> Schalken, the difference between functional and imperative algorithms is fundamental; even if Haskell allowed unrestricted side effects you would still have to modify your code extensively to switch between styles
12:49:05 <kmc> Schalken, most languages "solve" this problem by making the functional style impractical
12:49:08 <monochrom> no, data structures are hard, let's go hashing  XD
12:49:30 <kmc> Haskell encourages and supports functional style, but also supports imperative style, which yes does introduce complexity
12:49:37 <napping> Schalken: the points about varying interfaces and ST vs pure is agreed to be annoying
12:49:39 <aristid> monochrom: the jokes practically write themselves :D
12:49:56 <napping> kmc: if you make single-threaded use of a hash table, it should be easier to switch
12:51:01 <companion_cube> just by curiosité, what woul you use to implement a union-find in haskell?
12:51:34 <napping> historically, IORef
12:51:40 <kmc> napping, in which direction?  imperative to pure, right?
12:51:55 <napping> kmc: well, with linear types hopefully either way
12:52:01 <kmc> there are many ways to use a functional map structure, which don't translate easily to mutation
12:52:03 <companion_cube> curiosity* oO
12:52:17 <Schalken> kmc: The fact that you point at functional programming generally as the source of trouble in providing efficient maps tells me that there should surely be a mutable implementation for Haskell on par with those of other languages, no? And if so then in the ST monad I will stay until.
12:52:33 <kmc> Schalken, you've still not performed any benchmarks, have you?
12:52:37 <napping> or - because I've only done that for unification - just picking new names and working with raw substitution
12:52:48 <napping> it's hard to backtrack an imperative union-find
12:52:50 <Schalken> kmc: Ranting is funner!
12:52:54 <kmc> indeed
12:53:26 <napping> Schalken: well, just be sure to bring your code here and rant about it being slow
12:53:39 <aristid> i.e. Schalken is a troll, by his own admission
12:54:17 <kmc> Schalken, I still don't understand where your performance requirements come from
12:54:25 <kmc> like, how fast is fast enough?
12:54:53 <shachaf> 0.4 seconds
12:55:34 <napping> aristid: ranting is hardly coextensive with trolling
12:55:47 <kamaji> can I fmap a tuple?
12:56:04 <rostayob> kamaji: yes
12:56:04 <napping> does anyone know if the thing with constructors and ghci's linker will be fixed in 7.4?
12:56:04 <aristid> napping: what does coextensive mean? :)
12:56:04 <geheimdienst> > fmap succ (7,9)
12:56:04 <lambdabot>   (7,10)
12:56:20 <rostayob> kamaji: but the Functor instance is quite recent I think
12:56:25 <rostayob> (in base)
12:56:39 <napping> aristid: it means the most annoying kinds of trolling don't look much like complaining
12:56:56 <Schalken> kmc: Frankly I don't like the idea of sitting for an hour or two waiting for this thing to process the file knowing that it would be faster if I had just chosen another language.
12:56:56 <kmc> it would be faster still if you fabricate a custom processor
12:56:57 <kmc> think about that
12:56:58 <napping> you have code that is taking an hour to process a file?
12:56:58 <kamaji> "No instance for (Functor ((,) t0))"
12:57:03 <rostayob> of FPGAs
12:57:03 <kamaji> rostayob: does that mean I have an old version?
12:57:06 <aristid> napping: ok
12:57:09 <rostayob> kamaji: it probably does
12:57:16 <napping> kamaji: fmap won't work elementwise, if that's what you're after
12:57:26 <kamaji> oh, it was
12:57:27 <kamaji> heh
12:57:27 <kamaji> do I need to pattern match?
12:57:29 <kmc> rostayob, if you use a FPGA you'll think about how much faster an ASIC would be
12:57:34 <Ikarus> :( it's a shame you can't sort infinite lists at times :P
12:57:41 <rostayob> kmc: true
12:57:44 * Ikarus needs to change the generation of it :)
12:57:49 <kamaji> kmc: not in terms of dev time :p
12:58:01 <aristid> kmc: fortunately ASIC designers are cheap
12:58:03 <rostayob> Schalken: in short, your program will always suck
12:58:04 <kmc> oh yeah?
12:58:22 <kmc> Schalken, if you want to make performance decisions based on superstition, and don't care about correctness or ease of implementation, there are languages I'd recommend over Haskell
12:59:11 <napping> I did some image processing on an ASCII PPM the other day
12:59:30 <kmc> some people are working on Bitcoin mining ASICs
12:59:33 <napping> String and all! surprised it worked, but it seemed to be plenty fast
13:00:35 <kmc> i wrote an algorithm to pick random points subject to a minimum distance criterion
13:00:43 <kmc> i did the stupid O(n^2) way and it's plenty fast
13:00:49 <kmc> with thousands of points or so
13:01:04 <sdf12> kmc: I expect they'll be unhappy with their roi now.
13:01:06 <rostayob> but you're tiring your cpu needlessly
13:01:10 <kmc> before that i was agonizing over k-d trees and such
13:01:22 <napping> rostayob: nah, the poor dear gets bored without something to do all day
13:01:26 <kamaji> kmc: how many dimensions? :D
13:01:31 <kmc> 2
13:01:39 <ddarius> Silly kmc with his silly superstitions and inability to do back-of-the-envelope calculations.
13:01:59 <kmc> what BotE calculation should i have done?
13:02:04 <RarrRaptor> Yo dawg, I heard you like superstitions
13:02:15 <napping> anyway, will blaze-textual and friends work in ghci in 7.4?
13:04:14 <ddarius> kmc: 10,000^2 is 100,000,000 so that gives you ~40 cycles on average per operation (though you probably have n^2/2) if you wanted it to complete in 1 second.
13:04:54 <kmc> yes, it was n^2/2
13:05:46 <kmc> i should have parallelized it ;)
13:06:57 <kmc> what's the best sequential data structure for supporting parallel folds?
13:07:07 <kmc> it's hard to subdivide a list into equal chunks
13:07:13 <kmc> I assume it's better for Data.Sequence
13:07:28 <ddarius> Is the alternate elements not usuable?
13:07:52 <ddarius> Data.Sequence should be able to split into roughly equal chunks fairly quickly.
13:08:22 <ddarius> It could probably be done even more quickly if there were a split that was non-deterministic in semantics.
13:08:42 <kmc> my worry is that the alternation takes too long compared to the small per-element operation
13:09:06 <kmc> yeah, that would be nice
13:12:15 <napping> Vector?
13:13:10 <kmc> Vector would subdivide nicely
13:13:20 <kmc> otoh you can't *build* them in parallel as well
13:13:36 <napping> can't you?
13:13:51 <kmc> well, they're flat arrays, so concatenation is expensive
13:14:21 <napping> I was assuming you knew the size - you were talking about splitting, after all
13:18:03 <napping> Schalken: do you have any slow code? It's like catnip, people here will tweak and tune
13:18:50 <Schalken> napping: :/
13:19:15 <shachaf> "I'd rather have my grievance!"
13:19:51 <napping> shush
13:27:37 <FUZxxl> @pointful
13:27:37 <lambdabot> ()
13:27:43 <FUZxxl> @pointful compress xs@(_:_:_) = (ifte <$> ((==) <$> head <*> head.tail) <$> ((compress.).(:) <$> head <*> tail.tail) <*> ((:) <$> head <*> compress.tail) ) xs
13:27:43 <lambdabot> compress xs@(_ : _ : _) = (((ifte <$> \ d -> (((==) <$> head) <*> head) (tail d)) <$> \ g -> ((\ j p -> compress ((((:)) <$> head) j p)) <*> tail) (tail g)) <*> \ m -> ((((:)) <$> head) <*> compress)
13:27:43 <lambdabot>  (tail m)) xs
13:28:00 <napping> what's that for?
13:28:14 <FUZxxl> napping: Do you talk about me?
13:28:27 <napping> if it's supposed to undo pl it doesn't do a very good job
13:28:31 <aristid> is there an agda channel?
13:28:43 <napping> FUZxxl: Yeah, I've never seen the @pointful command
13:28:43 <shachaf> aristid: There's an easy way to find out. :-)
13:28:54 <aristid> shachaf: i was in #agda and it was empty
13:28:59 <FUZxxl> napping: http://stackoverflow.com/questions/7862414/why-doesnt-this-typecheck
13:29:02 <aristid> but maybe it has a different name
13:29:05 <shachaf> aristid: Looks non-empty to me.
13:29:18 <aristid> shachaf: oO
13:29:24 <aristid> shachaf: i must have typo'd the first time
13:29:58 <FUZxxl> It is annoying if somebody just askes a question about a type error and throws a big pile of completely pointless code to the reader... I don't like to tye a know in my brain just to understand the question.
13:30:24 <napping> I'm first bothered by it all being on one line in a tiny scrolling box
13:30:49 <napping> once I've gotten over that, maybe I'll worry about points
13:31:34 <FUZxxl> napping: For me, having the need to write lines longer than 80 chars is nearly always a sign of opaque code.
13:31:53 <napping> I was just complaining about the stackoverflow rendering
13:32:03 <dafis> FUZxxl: does that include the indentation spaces?
13:32:07 <napping> Does it show up in a single-line text box that you have to scroll sideways?
13:32:10 <FUZxxl> dafis: Yes.
13:32:20 <FUZxxl> napping: The question? Yes
13:32:36 * dafis sometimes gets to 100 with spaces
13:32:47 <FUZxxl> dafis: If you need more than three indentation levels in Haskell, you usually do something wrong....
13:32:50 <napping> So, it @pointful supposed to make @pl code more readable
13:33:01 <FUZxxl> napping: But it kind of doesn't works.
13:33:08 <monochrom> 80 columns was adequate before the "meaningful name" movement
13:33:08 <napping> or make it even more unreadable by randomly adding lambdas and single-letter variables?
13:33:29 <kmc> FUZxxl, disagree
13:33:38 <FUZxxl> I guess the problem is, that the <*> combinator is too general; pointful  can't decipher whether it is S or something else.
13:33:42 <bfig> what is the best way to build a parser to count words? i was thinking about lifting the parsec thing to a state with a map String Int there. is there a better way?
13:33:46 <napping> monochrom: bonus points if you are using C and have conventions requiring huge prefixes on public symbols
13:33:57 <kmc> bfig, produce a list of words and then count them
13:34:01 <kmc> why entagle the two bits
13:34:09 <FUZxxl> dafis: kmc: I am talking about Haskell code.
13:34:23 <bfig> ok, sounds good :)
13:34:38 <kmc> i disagree that Haskell code rarely requires more than three indentation levels
13:35:05 <monochrom> yeah, 80 columns is barely fit 8 identifiers. so unless you write in the machine code "three address instruction" style...
13:35:42 <napping> FUZxxl: okay, now that I've copied it to a decent editor and reindented to a decent number of lines, I see what you are saying
13:36:09 <FUZxxl> monochrom: kmc: My style is to split every algorithm into small parts that are easy do comprehend. I rarely need more than three nesting then.
13:36:09 <companion_cube> i'd say that 100 columns is a good tradeoff nowadays
13:36:18 <FUZxxl> napping: What do you see?
13:36:36 <monochrom> yes, split every algorithm into "three-address instuctions"
13:36:54 <monochrom> completely defeat even the point of fortran
13:36:55 <napping> that it's a very confusing piece of code
13:37:13 <aristid> monochrom: that must make the code very clear and readable.
13:37:49 <monochrom> my more detailed sarcasm on it: http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
13:38:54 <kmc> FUZxxl, there are advantages to that style but also advantages to others
13:39:49 <FUZxxl> monochrom: Well, I don't exactly do "three-adress instruction" style.
13:39:51 <monochrom> at the end of the day, the choice is "I am an executor" vs "I am a reasoner"
13:40:20 <napping> monochrom: would you object likewise to the decomposition in "why functional programming matters"?
13:40:23 <kmc> im the supervisor
13:41:02 <FUZxxl> monochrom: I decompose as neccessary.
13:41:06 <monochrom> Hughes's decomposition is about separating concerns, so it's fine
13:41:14 <FUZxxl> (decompose / compose)
13:41:45 <napping> FUZxxl: do you know what applicative instance is even being used in that code?
13:41:48 <monochrom> indeed, Hughes's decomposition is friendly to the reasoner and hostile to the executor
13:42:34 <FUZxxl> napping: No. I didn't tried to deduce it on my own.
13:42:47 <napping> I don't know either
13:42:49 <FUZxxl> I am too tired for coding puzzles today.
13:43:25 <napping> The outer one just used to distribute xs?
13:43:51 <kk`> @hoogle ap
13:43:51 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
13:43:52 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
13:43:52 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
13:44:34 <FUZxxl> The code would be completely pointless, if he'd remove that pattern.
13:47:37 <FUZxxl> Wow! The question actually got an answer by sdcvvc
13:48:56 <napping> FUZxxl: looks like it's just a <$> instead of <*>
13:49:01 <napping> but ew
13:50:29 <napping> ew, both layers of applicative are just for distributing parameters
13:50:43 <FUZxxl> Yeah.... kind of pointless
13:56:19 <BOTJE> LeNsTR|off: you should *really* fix that.
14:06:39 <napping> where is the instance for (Functor ((->) a))?
14:07:54 <FUZxxl> napping: fmap :: a -> b -> (x -> a) -> (x -> b)
14:08:01 <FUZxxl> @djinn fmap :: a -> b -> (x -> a) -> (x -> b)
14:08:02 <lambdabot> Cannot parse command
14:08:07 <FUZxxl> @djinn a -> b -> (x -> a) -> (x -> b)
14:08:07 <lambdabot> f _ a _ _ = a
14:08:21 <FUZxxl> @djinn (a -> b) -> (x -> a) -> (x -> b)
14:08:21 <lambdabot> f a b c = a (b c)
14:08:31 <FUZxxl> So:
14:08:53 <FUZxxl> instance Functor ((->) a) where fmap = (.)
14:09:07 <FUZxxl> and additionally:
14:09:12 <napping> no, what do I import to get it?
14:09:30 * napping is having a dumb today
14:09:58 <FUZxxl> napping: Control.Applicative, perhaps?
14:10:23 <napping> I already have that imported - haddock shows an instance but doesn't link to it
14:10:32 <FUZxxl> Ah.
14:10:36 <FUZxxl> :i (->)
14:10:49 <FUZxxl> It's declared in Control.Monad.Instances
14:10:56 <FUZxxl> but Control.Applicative exports it.
14:11:08 <FUZxxl> The latter one does not clutters your imports that much.
14:12:31 <kmc> anyone know of Haskell bindings to CGAL?
14:12:43 <kmc> it's a huge templated C++ library, but I'd be happy to have even a small subset of functionality
14:12:44 <FUZxxl> kmc: What is CGAL?
14:12:49 <kmc> @google CGAL
14:12:50 <lambdabot> http://www.cgal.org/
14:12:51 <lambdabot> Title: CGAL - Computational Geometry Algorithms Library
14:13:14 <FUZxxl> I don't think so.
14:13:18 <FUZxxl> @hoogle cgal
14:13:18 <lambdabot> No results found
14:13:56 * kmc ponders implementing Fortune's algorithm, versus writing CGAL bindings
14:14:31 * FUZxxl thinks it's not worth the effort writing those bindings.
14:14:47 <napping> thanks, that's where it was - apparently not reexported from my version of Control.Applicative
14:14:52 * FUZxxl has problems with english grammar
14:15:06 <FUZxxl> napping: Which version of GHC do you have?
14:15:22 <napping> running 7.0.4
14:15:22 <kmc> FUZxxl, so how should I get Voronoi tessellations?
14:15:53 <FUZxxl> kmc: No plan. Implement them?
14:16:24 <FUZxxl> I am not experienced in writing FFI bindings, but I think it is quite complicated to make those bindings work with C++
14:16:35 <tsousa> what seems to be the problem here http://dpaste.com/639273/ ?
14:17:10 <kmc> FUZxxl, my approach would be to write a small layer which specializes all that template stuff to a few common cases, and exports a pure C API
14:17:12 <FUZxxl> tsousa: Function names must be lowercase
14:17:13 <napping> uppercase names are reserved for data constructors
14:17:20 <napping> should work if you call it "helper"
14:17:27 <kmc> FUZxxl, implementing Fortune's algorithm sounds fun and I'm sure it builds character
14:17:34 <kmc> but it's also fairly complex and will take me a while
14:17:48 <tsousa> oh thanks
14:17:51 <kmc> and I expect weird bugs from corner cases, numeric problems, etc
14:18:01 <FUZxxl> kmc: The question is, what takes more time and which is more educating / entertaining
14:18:13 <kmc> I'm told that real robust implementations like CGAL's use adaptive-precision arithmetic
14:18:34 <napping> Ratio Integer ftw!
14:19:17 <FUZxxl> One thing I always wondered about.
14:19:49 <napping> or for the slow, that too
14:19:51 <kmc> actually, looks like it uses interval arithmetic and escalates to multiple-precision when it detects trouble
14:20:27 <FUZxxl> In combinatory logic, one uses the S combinator, which is essentially <*> instanciated for ((->) a)
14:20:47 <FUZxxl> Why is there no instanciated version, like that for fmap (.)
14:20:50 <tsousa> what is the differences between the problem 11 and problem 13 http://www.haskell.org/haskellwiki/99_questions/11_to_20 ?
14:21:09 <FUZxxl> There is also a second combinator that is a special case.
14:21:13 <FUZxxl> It's basically flip.
14:21:19 <FUZxxl> Why is there no generalized flip?
14:21:32 <FUZxxl> flip :: (a -> b -> c) -> b -> a -> c
14:21:37 <Cale> FUZxxl: well, what do you mean?
14:21:55 <Cale> Composition is certainly definable in combinatory logic
14:21:55 <FUZxxl> flip' :: Functor f => f (b -> c) -> b -> f c
14:22:08 <byorgey> @type flip
14:22:09 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:22:13 <byorgey> ;)
14:22:30 <FUZxxl> byorgey: Only in lambabot.
14:22:34 <FUZxxl> @src flip
14:22:34 <lambdabot> flip f x y = f y x
14:22:37 <byorgey> I know.
14:22:40 <FUZxxl> wtf?!
14:22:53 <FUZxxl> :t \f x y -> f y x
14:22:54 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> t -> t1 -> t2
14:22:55 <Cale> @src is just reading out of a textfile :P
14:22:55 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:25:46 <kk`> @src pure
14:25:46 <lambdabot> Source not found. Take a stress pill and think things over.
14:26:58 <byorgey> @src Applicative
14:26:58 <lambdabot> class Functor f => Applicative f where
14:26:58 <lambdabot>     pure  :: a -> f a
14:26:58 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
14:27:04 * hackagebot cprng-aes 0.2.2 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.2.2 (VincentHanquez)
14:27:17 <byorgey> kk`: there is a different implementation of pure for every instance of Applicative
14:27:26 <kk`> byorgey, yeah, I just realised that by doing a :t in ghci :p
14:27:31 <byorgey> ok =)
14:27:33 <kk`> Random brainfart :)
14:29:33 <tsousa> why is that in this replicate needs to be surrended by () repli xs n = concatMap (replicate n) xs ?
14:30:09 <FUZxxl> tsousa: Because (replicat n) is an argument to concatMap.
14:30:40 <FUZxxl> If there were no braces, both replicate and n were applied to concatMap which is clearly wrong.
14:30:58 <napping> in other words, application has high precedence and associates left
14:31:05 <FUZxxl> GHC can't figure out which argument goes where, so you have to set braces on your own.
14:31:10 <FUZxxl> napping: Yes.
14:31:16 <napping> (It's not based on the number of arguments, that's fuzzy with curried types)
14:31:17 <tsousa> thanks
14:32:11 * napping is happy do see darcs gloss works from ghci
14:40:25 <morel> is `f = \x -> x^2' a closure?
14:40:43 <MAUKE> no
14:41:45 <napping> that one isn't, at least - it only refers to the argument x, so it doesn't have to "close over" anything
14:41:58 <parcs> it refers to ^ too
14:42:22 <MAUKE> but that's the global ^
14:42:25 <napping> well, yes, but that's (presmuably) a top level thing
14:42:28 <geheimdienst> > let y = 2 in (\x -> x^y) 4
14:42:29 <lambdabot>   16
14:42:48 <napping> > let (^) = (*) in (\x -> x^2) 4
14:42:48 <lambdabot>   8
14:42:51 <MAUKE> > let (^) = 2 in (\x -> x^y) 4
14:42:52 <lambdabot>   2
14:42:53 <geheimdienst> ^^ that's a closure, it refers to y, which is outside the lambda (outside the parens)
14:43:04 <MAUKE> trollface.jpg
14:43:18 <morel> thank you.
14:43:18 <napping> that's the most important part of that example, yes
14:43:52 <napping> It's is a lambda and a first class function, which is often what people mean by closure anyway
14:44:04 <MAUKE> and we ... kill those people
14:44:27 <napping> iow - it kind of sucks to use nested or first class functions if they can't be closures
14:44:39 <napping> MAUKE: the caps seem to have made you angry
14:46:01 <MAUKE> napping: http://www.youtube.com/watch?v=fZkhR8suCF4#t=20s
14:52:31 <FUZxxl> @src foldl
14:52:31 <lambdabot> foldl f z []     = z
14:52:31 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:52:35 <FUZxxl> @src foldr
14:52:35 <lambdabot> foldr f z []     = z
14:52:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:53:50 <Mauke> > foldl f z [a,b,c]
14:53:51 <lambdabot>   f (f (f z a) b) c
14:53:56 <Mauke> > foldr f z [a,b,c]
14:53:57 <lambdabot>   f a (f b (f c z))
14:54:13 <yrlnry> I haven't seen it do that before.
14:54:40 <Mauke> > deriv (sin + cos) x
14:54:41 <lambdabot>   1 * cos x + 1 * negate (sin x)
14:54:49 <byorgey> yrlnry: do what? output  f a (f b (f c z))  etc.?
14:54:56 <yrlnry> yes
14:54:57 <Mauke> triple hit lambdabot feature combo
14:55:09 <byorgey> yeah, it's fun =)
14:55:12 <byorgey> > x^7
14:55:13 <lambdabot>   x * x * (x * x) * (x * x * x)
14:55:19 <byorgey> @where expr
14:55:20 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
14:55:31 <byorgey> yrlnry: you can read about how it works there ^^^
14:55:33 <yrlnry> thanks.
14:55:38 <Mauke> there's no magic here
14:55:45 <Mauke> lambdabot simply predefines all single-letter variables
14:55:59 <byorgey> yrlnry: basically single-letter vars are defined as primitive values of type Expr, which has instances for Num and various other classes
14:56:14 <byorgey> and the instances just reify the expressions into an AST
14:56:18 <yrlnry> That's a pretty big value of zero in "no magic" :)
14:56:32 <Mauke> Expr is slightly magic
14:57:13 <kmc> hmm can cabal handle building c++ code, the way it builds c code?
14:57:36 <FUZxxl> @help where
14:57:36 <lambdabot> where <key>. Return element associated with key
15:02:50 * DanBurton wishes lambdabot weren't so hard to install
15:05:22 <luite> DanBurton: why is it hard?
15:18:18 <rimmjob> does linear algebra get used a lot in functional programming?
15:18:24 <rimmjob> outside of graphics
15:18:30 <snifi> 'cabal install lambdabot' fails for ghc 6.12 with ExitFailure 1, so I continued reading...
15:19:02 <snifi> continued reading... http://www.haskell.org/haskellwiki/Lambdabot/Building ...
15:19:52 <snifi> it suggests : 'darcs get http://code.haskell.org/HSP/haskell-src-exts' and results: darcs failed: Not a repository...
15:20:04 <luite> hmm, I'm pretty sure I got it installed with cabal insall without problems
15:20:12 <byorgey> on 6.12 ?
15:20:42 <luite> hmm, it's been a while since I've run lambdabot, might have been 6.10
15:21:21 <snifi> ghc 6.12 is from the packet repository for Ubuntu
15:21:23 <companion_cube> rimmjob: not s far as i know
15:22:08 <nh2> can I make ghci load the language extensions that are declared in the top of the file when we load it with ghci file?
15:22:41 <nh2> it's not nice to have to :set -X all of them every time
15:22:53 <luite> you can create a .ghci that loads them
15:25:36 <companion_cube> nh2: or just give -XFooBar to ghci
15:25:45 <companion_cube> you can make an alias
15:26:50 <nh2> luite, companion_cube: thanks, both work well, but I wonder if there is something like a --set-languages flag that loads all the language extensions in the {-# ... #-} of the file
15:28:28 <luite> nh2: I don't think there is, but you can make a .ghci in your project dir
15:29:07 <companion_cube> i have a ~/.ghci
15:29:25 <nh2> luite: yeah that works, but it imports them for all files in the project dir, not only the one where I need them
15:30:08 <luite> yeah that's true, it might not be ideal. are there extensions you don't want enabled for some files?
15:30:57 <jweofijm> @pl \x y -> f x (g y)
15:30:57 <lambdabot> (. g) . f
15:34:14 <rimmjob> what kinds of math are useful/related to functional programming then? besides category theory
15:35:06 <companion_cube> rimmjob: logic
15:37:32 <dtrebbien> @t liftIO
15:37:32 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:37:34 <ddarius> Abstract algebra is probably generally useful.
15:37:50 <dtrebbien> @type liftIO
15:37:50 <lambdabot>     Ambiguous occurrence `liftIO'
15:37:51 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
15:37:51 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
15:37:52 <ddarius> But programming (in general) is applied logic, so it is the most relevant.  Type systems are also logical systems.
15:38:33 <rimmjob> so math in FP really isnt that different from math in regular programming?
15:39:01 <EvanR> rimmjob: arithmetic?
15:39:07 <EvanR> 2+2 still equals 4 ;)
15:40:07 <ddarius> rimmjob: Why would math change?
15:40:49 <lamspam> hello
15:41:33 <lamspam> anyone here use UltraEdit to write Haskell?
15:41:42 <min> Why would "$cabal install happy; cabal install haskell-src-exts" fail on haskell-src-exts because happy could not be found?
15:42:30 <Saizan> min: do you have $HOME/.cabal/bin in your $PATH ?
15:42:51 <lamspam> anyone here use UltraEdit to write Haskell?  I have a syntax highlighting question concerning functions that end with a single quote
15:45:56 <kmc> rimmjob, you seem generally confused about the relationship between math and programming
15:46:52 <kmc> and i'm not sure where to draw the line between "functional programming" and other programming, or why it's particularly relevant
15:47:57 <kmc> for some bits of math (like the lambda calculus, or the math which gives you recursion schemes) it's relevant
15:48:11 <min> Saizan: good point.
15:48:16 <monochrom> I hope "regular programming" does not refer to designing Turing machines.
15:48:28 <kmc> but category theory, type theory, and logic would seem to relate more to types than to "FP"
15:51:03 <nh2> luite: yes, exactly. Of course starting it with -X every time works, but ghci just loading what is specified in the file would be nicer
15:51:27 <nh2> is there something that converts BSON (e.g. from mongo) to Aeson's json?
15:52:07 <kmc> not afaik, but there is a bson library
15:54:30 <dtrebbien> Is there a guide to the top level hierarchies of Haskell packages?
15:54:34 <nh2> kmc: yes, mongo uses that to give the result to haskell. We'd like to forward that as Json to the browser
15:54:51 <dtrebbien> Or a list
15:55:27 <dtrebbien> I've seen so many. I'm basically trying to get a high-level picture of module hierarchies.
15:56:16 <dtrebbien> Visiting package pages on Hackage, I see only the hierarchies of that package, but can't "explore" adjacent hierarchies, etc.
15:56:55 <lamspam> dtrebbien, is this not what you want? http://www.haskell.org/ghc/docs/7.0.3/html/libraries/
15:57:47 <dtrebbien> lamspam: That's useful. Thank you.
15:57:58 <byorgey> lamspam: those are only the libraries that come with GHC.
15:58:21 <kmc> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html has a bit more
15:58:28 <byorgey> dtrebbien: there's not a good way to explore the module hierarchy of, say, all modules on Hackage, although that would be really cool
15:58:37 <kmc> also cabal can build this for you on your local machine
15:58:38 <byorgey> hopefully Hackage v2 will include such a feature eventually.
15:58:56 <kmc> i have a bunch of docs in file:///usr/share/doc/ghc6-doc/html/libraries/index.html
15:59:40 <dtrebbien> byorgey: Especially for beginners such as myself, a "high level" overview or a way to dig through module hierarchies would be neat.
16:00:12 <lamspam> anyone here use UltraEdit to write Haskell?  I have a syntax highlighting question concerning functions that end with a single quote
16:00:20 <luite> hehe I think a full hackage module overview would be more "huge mess" than "high level", but it would be cool nonetheless :p
16:00:21 <byorgey> dtrebbien: well, a view of the module hierarchy for all of hackage would NOT be useful for beginners, I think, because there would be WAY too much to sort through =)
16:00:42 <HugoDaniel> i want to be a better haskell programmer
16:00:49 <dtrebbien> byorgey luite: You two are probably right.
16:01:00 <dtrebbien> Just looking through the GHC list is... mind blowing.
16:01:02 <byorgey> dtrebbien: what kmc linked to is probably a good place to start if you want to familiarize yourself with some of the standard libraries.
16:01:14 <dtrebbien> Okay
16:01:33 <hpaste> mrakan pasted “why does this fail? can I make this happen somehow?” at http://hpaste.org/52989
16:01:35 <byorgey> OK, well, if the GHC list is mind blowing, then start there! =)
16:01:51 <dtrebbien> Yes  :)
16:02:09 <mrakan> I've pasted the above. I'm not sure how to accomplish it. I'd like to use separate types, not constructors.
16:02:19 <luite> GHC has a rather flat module hiearchy, not really a good example :)
16:02:27 <dtrebbien> By "mind blowing" I mean overwhelming.
16:02:31 <dtrebbien> But yes.
16:02:45 <byorgey> mrakan: you probably want to combine Move and Flee into a single data type
16:03:14 <byorgey> mrakan: having a two-parameter type class for this seems like premature generalization.
16:03:19 <mrakan> byorgey: I'd also like to have functions that return something like (Maybe Flee).
16:03:58 <DanBurton> byorgey: is it true that it could work with existential types? Not that it should be done, but could it?
16:04:07 <hpc> having a typeclass at all seems like premature generalization imo
16:04:12 <byorgey> mrakan: based on what you have currently, Maybe Flee is the same as Bool.  I don't see why that would be useful.
16:04:13 <mrakan> byorgey: So, using multiple constructors (a single datatype) seems bad to me as it won't help me accomplish this. All my functions would have to return something like (Maybe AnAction).
16:04:54 <byorgey> mrakan: why not just have constructors  Flee  and  DontFlee  ?
16:05:14 * DanBurton thinks this is where subtyping might be useful
16:05:28 <byorgey> DanBurton: yes, it is true.  but I really don't think that's what mrakan wants.
16:05:33 <mrakan> byorgey: I understand your thoughts, but the Move and Flee datatypes aren't really anything I wanted to use. This is merely a test to see whether something like this can be done (I plan to use more complex types later on).
16:06:12 <mrakan> DanBurton: What do you mean by subtyping?
16:06:15 <byorgey> well, I have to go.  Hopefully someone else can explain to you the difference between having the *caller* of a function choose a type, and the function *implementation* choosing a type.
16:06:54 <mrakan> byorgey: Ack, I see what you mean.
16:07:30 <hpc> mrakan: it seems like you were moving towards the existential typeclass antipattern
16:08:06 <lamspam> anyone here use UltraEdit to write Haskell?  I have a syntax highlighting question concerning functions that end with a single quote
16:08:11 <hpc> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ -- instead of going with a type class, just have one data type
16:08:52 <hpc> so instead of having execute :: Thing a => a -> IO (), have data Thing = Thing {execute :: IO ()}
16:08:55 <ddarius> There is no module hierarchy.
16:09:04 <mrakan> hpc: Is there then a way I could have a function that is guaranteed to always return a Move value, where I have defined (data AnAction = Move Int Int | Flee)?
16:09:57 * BMeph thinks mrakan just hit the Motherload of premature generality!
16:10:24 <mrakan> BMeph: :D Don't worry, this program is just a test. I'm toying with Haskell.
16:10:31 <hpc> mrakan: not at the type level
16:11:07 <hpc> honestly, you aren't going to be doing anything that needs such guarantees at the type level until you know enough to do it without needing google or outside advice
16:12:06 <mrakan> hpc: Yes, I had hoped I could make that kind of guarantee at the type level. Thank you all for the help.
16:12:09 <hpc> there's a quote somewhere about how every haskell programmer has to make this mistake at least once to realize what sort of designs you don't want to attempt :P
16:13:44 <Saizan> it's pretty easy with GADTs
16:14:06 <ddarius> I haven't read all of this, but it seems pretty without GADTs.
16:15:13 <Saizan> well, sure, you can do data Move = Move Int Int; data Flee = Flee; type AnAction = Either Move Flee
16:15:27 <ddarius> Exactly.
16:17:16 * BMeph is now imagining the announcer's voice from _Torchlight_ saying, "Your pet has fled."...
16:17:42 <mrakan> BMeph: Oh, I'm still here. ;)
16:18:46 <BMeph> mrakan: ...okay. Good for you! (I wasn't trying to say you were my pet, just that your "test" reminds me of that game.)
16:19:26 <hpaste> DanBurton annotated “why does this fail? can I make this happen somehow?” with “Beware: "antipattern" follows” at http://hpaste.org/52989#a52990
16:19:54 <DanBurton> Use antipatterns at your own risk :P
16:20:28 <mrakan> Saizan: That seems nice, but in case of many types of actions I'd have some kind of huge EitherN type to potentially hold any one of them?
16:20:46 <ddarius> BMeph: Very sparkly.
16:20:52 <mrakan> DanBurton: This is the first time I've received this honour! :D
16:21:45 <Saizan> mrakan: yeah, or just define data AnAction = C1 T1 | C2 T2 | ... | CN TN
16:21:46 * DanBurton secretly likes ExistentialQuantification such as this, even if Luke Palmer thinks it is an antipattern. That probably means Luke is smarter than Dan.
16:21:46 <ddarius> mrakan: Either A (Either B C)
16:23:03 <ddarius> DanBurton: The pattern has uses, it has some of the core properties of OOP, hence many people lean toward it when starting Haskell.
16:23:26 <mrakan> Saizan: Thanks, that seems like a nice compromise that allows me to have action-specific functions.
16:23:50 <kmc> you can do OOP in Haskell in a much more direct style, though
16:23:51 <ddarius> @google data types a la carte
16:23:52 <lambdabot> http://lambda-the-ultimate.org/node/2700
16:23:52 <BMeph> DanBurton: You've also misused your type: "AnyWorldAction Flee" is a value of type AnyWorldAction, by your definition. :)
16:23:52 <lambdabot> Title: Data Types a la Carte | Lambda the Ultimate
16:24:04 <kmc> (which does sometimes involve existentials, but not so many types & classes)
16:24:33 <rangless> Is there a popular type class, parameterized by type t, that stipulates a function with signature (a -> b) -> t a -> b ?
16:24:47 <DanBurton> BMeph: erm...yes. It's a naming ambiguity but I don't see how it is "misused"
16:25:03 <ddarius> rangless: No.
16:25:28 <Peaker> rangless: what kind of generalization are you seeing here?
16:26:46 <kmc> rangless, you'd get that from a co-pointed functor, including a comonad
16:26:58 <ddarius> DanBurton: You missed the trick of making AnyWorldAction an instance of Action.  worldExecute is just execute.
16:27:01 <kmc> 'cause that gives you t a -> a
16:27:05 <kmc> and the rest is just fmap
16:27:23 <Peaker> Existential Quantification offers some neat ways to write more performant code. Other uses I think should usually be re-encoded differently, and the existentials are superfluous
16:27:40 * rangless doesn't know about comonads ...  will read up on them ...
16:28:05 <DanBurton> ddarius: ah good point
16:28:24 * ddarius has no idea why people think that universal quantification is something we should be using all the time, but existential quantification should never be used.
16:29:04 <mrakan> I'm not sure why the use of ExistentialQuantification (as the one on the hpaste) is an antipattern? It seems to fit the needs perfectly? Is there a good reason why I shouldn't use something like this?
16:29:18 <Peaker> ddarius: I think stuff in H2010/H98 should be preferred -- all else being equal
16:29:39 <Peaker> ddarius: Also, even with H98/H2010, support for existentials in ghc is somewhat brittle
16:29:53 <DanBurton> mrakan: did you read the blog post linked above? The basic argument is that it complicates things unnecessarily
16:29:55 <ddarius> Peaker: I agree, but not everything is equal and existentials quantification is a very well understood extension.
16:30:14 <mrakan> DanBurton: Or, right, I have them open in tabs but forgot about them. Thanks for the reminder.
16:30:23 <DanBurton> :)
16:30:40 <Peaker> ddarius: Do you have some good examples of usefulness of existential quantification that isn't encoded as nicely without them?
16:33:38 <monochrom> perhaps people are content with abstract types (write a module, restrict exports) as the most popular way to apply existential types
16:33:47 <Peaker> I have some useful uses in mind.. Most involve type trickery for extra type safety, and performance stuff. But most existentials I see "in the wild" (at least in #haskell pastes) involve stuff that are just as easily encoded with universal
16:33:54 <Saizan> mrakan: the point of the article seems to be that in cases where you never care about differentiating at the type level between different things you can use the methods with, then it doesn't make sense to do so
16:34:16 <Saizan> which is a bit tautological :)
16:40:09 <hpaste> DanBurton annotated “why does this fail? can I make this happen somehow?” with “The 'not antipattern' alternative” at http://hpaste.org/52989#a52991
16:40:51 <DanBurton> whoops forgot the ints in a few type signatures. whatever
16:42:34 <ddarius> Peaker: The cases where trying to represent existentials using other means starts to fall apart (though you can always use the "double negation" translation) is the translucent case, http://okmij.org/ftp/Computation/Existentials.html
16:45:33 <Peaker> ddarius: Yeah, I see.  I wonder about some real examples of that, though
16:45:47 <ddarius> In many cases it is arguably conceptually clearer to use an existential even when it could be eliminated fairly simply, e.g. for state machines like what is happening in Data.List.Stream.
16:46:23 <Peaker> ddarius: I think if you eliminate the existential in Data.List.Stream you end up back with [a] (i.e: it falls into the performance category I mentioned earlier)
16:46:35 <morel> i installed ghc, but there's no ghci. :/   why?
16:47:45 <ddarius> Peaker: I'm saying it's not just a "performance" issue, but there is a conceptual appeal to viewing streams as generated by a state machine.  This is what unfoldr does.
16:48:14 <Peaker> @type unfoldr
16:48:15 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:49:02 <Peaker> ddarius: I don't think you can encode Data.List.Stream using H98/H2010 and get the desired performance characteristics
16:49:33 <ddarius> Peaker: I'm not talking about performance.
16:49:34 * DanBurton isn't sure if ghci is packaged with ghc
16:49:46 <ddarius> ghci is ghc --interactive
16:50:09 <Peaker> ddarius: What's the conceptual appeal of the state machine in that case then? [a] is much simplre
16:50:37 <Peaker> (btw, I don't think I've ever used unfoldr :-)
16:50:40 <erus`> Peaker: tres simplre*
16:52:55 <Peaker> ddarius: I don't think there's much conceptual appeal in the implementation of various list manipulation functions in Data.List.Stream -- they're much less elegant and uglier than their Data.List counter-parts. The whole appeal in there is performance
16:58:49 <ddarius> Peaker: A trivial example would be streams of random numbers.  Here we want to maintain a state that is separate from our output.
16:59:08 <kmc> ddarius, I'm trying to implement this "natural split" for Sequence, but it's awkward due to the internal structure of the finger tree
16:59:11 <kmc> any advice?
17:00:05 <ddarius> The "natural split" should be informed by the internal structure of the finger tree.
17:00:30 <kmc> yeah, that's the idea
17:00:44 <kmc> the problem is that the tree has a different type at each level
17:01:20 <kmc> data FingerTree a = ... | Deep ... (FingerTree (Node a)) ...
17:01:41 <kmc> i thought, for best efficiency, that it should be a "one-level split"
17:02:01 <kmc> that is you get back some Seqs (and maybe some indivdual elements) and can choose whether to split those further or process sequentially
17:02:09 <kmc> but now it's looking like this will require rebuilding the whole tree structure anywya
17:02:15 <Polarina> Does anyone know of any tips on how I can improve this piece of code? http://codepad.org/onebEvej
17:02:22 <ddarius> kmc: Perhaps it shouldn't be a binary split.
17:02:31 <kmc> it's not
17:02:44 <kmc> Seq a -> ([a], [Seq a])
17:02:53 <kmc> (also not preserving order, just yet)
17:03:28 <ddarius> I'd expect just Seq a -> [Seq a] (maybe with some more information)
17:04:05 <Peaker> ddarius: streams are more simply represented by lists -- even if you choose to implement them using unfoldr/streams, you don't need an existential if you convert to list first
17:04:30 <kmc> I think that'll require non-trivial rebuilding of tree structures
17:04:36 <ddarius> kmc: Likely.
17:04:37 <Peaker> ddarius: Unless I'm missing something, the appeal of streams is their performance characteristics
17:04:59 <Peaker> (which is why I claim Existentials are often useful for more performant encodings)
17:05:44 <ddarius> Peaker: Your response seems like a completel non sequitur to the example I gave.
17:06:17 <Peaker> ddarius: why represent a "stream of random numbers" and not a simple infinite list of random numbers?
17:06:43 <ben> Where do I read about this whole stream/fusion thing?
17:06:53 <kmc> "Lists to Streams to Nothing at all"
17:06:53 <ben> http://www.cse.unsw.edu.au/~dons/streams.html 403s
17:07:05 <Peaker> ddarius: I agree that existentials are a natural/useful way of representing "streams" (list generation state-machines) -- I just don't see why streams rather than lists, are ever more than a performance enhancer
17:07:45 <DanBurton> @google don stewart streams
17:07:47 <lambdabot> http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/s/Stewart:Don.html
17:07:47 <lambdabot> Title: DBLP: Don Stewart
17:08:07 <Peaker> ben: "From Lists to Streams to Nothing At All" was a fun read, good paper
17:08:18 <ben> Looking for that now, cheers
17:09:09 <DanBurton> This it? http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.7401&rep=rep1&type=pdf
17:18:48 <Peaker> DanBurton: yeah
17:24:38 <dalaing_home> there are a lot of dead links on various wikis pointing to http://www.cse.unsw.edu.au/~dons/
17:25:37 <dalaing_home> I guess it's probably good that they 403 rather than 404, means there's hope that some of that info lives on
17:39:02 <sadgur> hi
17:39:23 <sadgur> can anyone help me with a quick question, I want to build an infinite list of True,False,True,False..
17:39:37 <ddarius> > cycle [True, False]
17:39:38 <lambdabot>   [True,False,True,False,True,False,True,False,True,False,True,False,True,Fal...
17:39:42 <sadgur> ah
17:39:47 <sadgur> thankyou
17:39:53 <sadgur> i was trying repeat and it exploded
17:39:55 <sadgur> ha
17:39:58 <Entroacceptor> > fix (True:False:) []
17:39:59 <lambdabot>   The operator `:' [infixr 5] of a section
17:39:59 <lambdabot>      must have lower precedence th...
17:40:09 <ddarius> > unfoldr (Just . (id&&&id) . not) True
17:40:11 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
17:40:25 <sadgur> thanks for your help
17:40:33 <monochrom> repeat is for an infinite list of the same item, e.g., repeat True
17:40:34 <kmc> > concat $ repeat [True, False]
17:40:35 <lambdabot>   [True,False,True,False,True,False,True,False,True,False,True,False,True,Fal...
17:40:41 <ddarius> > iterate not True
17:40:42 <lambdabot>   [True,False,True,False,True,False,True,False,True,False,True,False,True,Fal...
17:40:44 <Entroacceptor> > fix (True:False:)
17:40:45 <lambdabot>   The operator `:' [infixr 5] of a section
17:40:45 <lambdabot>      must have lower precedence th...
17:41:04 <Entroacceptor> > fix ((:) (True:False))
17:41:05 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
17:41:05 <lambdabot>         against inferred typ...
17:41:16 <sadgur> monochrom: thanks
17:41:17 <kmc> > fix ((True:) . (False:))
17:41:19 <lambdabot>   [True,False,True,False,True,False,True,False,True,False,True,False,True,Fal...
17:41:25 <sadgur> i was trying umm
17:41:32 <sadgur> repeat False ++ repeat True
17:41:47 <sadgur> but obviously the evaluation means it just repeats False infinitely
17:42:08 <kmc> > transpose [repeat False, repeat True]
17:42:09 <lambdabot>   [[False,True],[False,True],[False,True],[False,True],[False,True],[False,Tr...
17:42:14 <kmc> > concat $ transpose [repeat False, repeat True]
17:42:14 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
17:42:25 <sadgur> ha when anyone asks a question do you just come up with as many answers as possible :D
17:42:29 <kmc> yes
17:42:30 <sadgur> I like it
17:42:36 <sadgur> i must join in sometime
17:42:36 <byorgey> sadgur: yep.
17:42:48 <sadgur> i'm fairly new to haskell but doing a phd in computation logic
17:42:53 <byorgey> > map odd [0..]
17:42:53 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
17:43:02 <sadgur> ooo i like that one byorgey
17:43:07 <kmc> haha nice
17:43:10 <geheimdienst> > map even [0..]
17:43:11 <lambdabot>   [True,False,True,False,True,False,True,False,True,False,True,False,True,Fal...
17:43:22 <kmc> > iterate not False
17:43:23 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
17:43:45 * monochrom contemplates this scheme: map head . group . map (\x -> is x valid haskell and type-checks?) $ (enumerate all strings)
17:44:15 <EvanR> kmc: you just solved the barber of seville paradox
17:46:18 <dmwit> monochrom: You'd grow old and die before it even generated strings long enough to turn on a few extensions and import some libraries.
17:46:21 <dmwit> ;-)
17:47:22 <dmwit> monochrom: Also, I'm not sure what the "map head . group" is doing; presumably your enumeration is already making unique elements, so that's id.
17:47:33 <dmwit> ...oh
17:47:49 <dmwit> That's not a filter, that's a *map*, and I totally missed the joke.
17:47:52 <dmwit> dmwit--
17:47:54 <Phlogistique> Prelude> :t ((\ x -> x) . (\ x -> x))
17:47:54 <Phlogistique> ((\ x -> x) . (\ x -> x)) :: c -> c
17:47:54 <Phlogistique> Prelude> :t ((\ x -> x) $ (\ x -> x))
17:47:54 <Phlogistique> ((\ x -> x) $ (\ x -> x)) :: t -> t
17:48:13 <Phlogistique> Is there a difference between the "c" and the "t" as printed by GHCi here?
17:48:20 <dmwit> Phlogistique: Nope.
17:48:33 <Phlogistique> dmwit: thanks
17:48:37 <kmc> nah, it's just picking arbitrary variables based on what was used in type signatures
17:49:21 <Phlogistique> any idea why GHCi consistently picks c for this composition and t for this application?
17:49:51 <Gracenotes> :t (.)
17:49:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:49:54 <Gracenotes> :t ($)
17:49:55 <lambdabot> forall a b. (a -> b) -> a -> b
17:50:40 <Entroacceptor> what I was wanting to ask, has anyone written a zeroc ICE stack for haskell? Hackage doesn't have one, but there was a question on the mailing list... http://haskell.1045720.n5.nabble.com/Internet-Communications-Engine-and-Haskell-td3108272.html
17:50:45 <Gracenotes> oh. the type it gives to (\x -> x) is t -> t.
17:50:45 <Entroacceptor> maybe that rings a bell for someone?
17:50:54 <Gracenotes> that is from where it comes.
17:51:04 <dolio> @type (Prelude..)
17:51:04 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:51:11 <dolio> That's probably where the c comes from.
17:51:18 <sadgur> right got another question if you could help I want to build all permutations of a list of [True,False] length n
17:51:28 <sadgur> but my solution didn't get all values
17:51:35 <Phlogistique> Gracenotes, dolio: thanks!
17:51:37 <sadgur> missed True,True,True, False,False False
17:51:38 <kmc> > replicateM 5 [True, False]
17:51:39 <lambdabot>   [[True,True,True,True,True],[True,True,True,True,False],[True,True,True,Fal...
17:51:47 <sadgur> permutations $ take numAtoms $ cycle [True,False]
17:52:08 <sadgur> permutations $ take 3 $ cycle [True,False]
17:52:11 <sadgur> right let me see
17:52:43 <Gracenotes> in that formulation permutations would be suspect.
17:53:01 <sadgur> thanks kmc that did it
17:53:07 <sadgur> care to explain why?
17:53:22 <sadgur> :t replicateM
17:53:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:53:31 <sral> is there any programming language which can check Monad law by compiler?
17:53:34 <sadgur> oof not got to monads yet
17:53:57 <hpc> sral: agda
17:54:35 <sral> it does? cool. i want to have a look, is it in its std lib?
17:55:25 <hpc> sral: i forget what module it's in
17:55:31 <rwbarton> Except you won't be able to prove the laws for most interesting monads unless you introduce your own notion of equality, since the built-in reflexive equality of functions is not extensional
17:58:18 <Saizan> rwbarton: eta-conversion seems to be enough for State at least
18:00:21 <rwbarton> Yes, though I never like replacing the thing I am trying to prove with something equivalent since I can always replace it by "true" by hand anyways...
18:02:51 <napping> rwbarton: what are you up to?
18:03:17 <rwbarton> sral was asking about proving the monad laws in agda
18:03:24 <napping> you *ought* to prove that the one thing is equivalent to the other before replacing it.
18:03:57 <rwbarton> of course I know that, classicaly, I have (forall x. f x == g x) ==> f == g.
18:04:15 <napping> that sounds like a question of extensionality
18:04:29 <rwbarton> But I also know, classically, that the monad law I wanted to prove holds, so... it is just a matter of degree how much of my proof is in agda, and how much is outside
18:04:58 <napping> "subst" gives you (forall x y f . x == y -> f x == f y)
18:05:17 <zugz> is there a more idiomatic way, perhaps using callCC, to write: liftOut :: (r -> r) -> Cont r a -> Cont r a;  liftOut f m = Cont $ \c -> f $ runCont m c  ?
18:05:38 <napping> Coming up with a formal definition you are trying to prove is the place you can't be sure if substitutions are safe, unfortunately
18:07:40 <Saizan> rwbarton: i meant that agda's eualit
18:08:38 <Saizan> rwbarton: by eta-conversion i meant f == \x -> f x, and that's already built into agda's notion of equality
18:08:45 <rwbarton> It is
18:08:46 <rwbarton> ?
18:09:00 <Saizan> yep
18:09:23 <Saizan> that's weaker than (forall x. f x == g x) ==> f == g though
18:09:51 <rwbarton> I mean, it's not as bleak as I make it sound because you can introduce setoids everywhere with your favorite equality notion. It's just an extra layer of baggage to deal with the difference between agda's logic and something classical (and requiring extensionality of functions is not very classical)
18:09:56 <dolio> Confusingly, eta is sometimes called extensional equality.
18:09:56 <rwbarton> oh
18:10:08 <dolio> Because it's not a computational rule, typically.
18:12:08 <hpc> on the bright side, you can prove forall f g. (forall x. f x == g x) ==> f == g
18:12:27 <hpc> so if you can get a proof of the first part for specific f and g, you can get f == g
18:12:32 <rwbarton> in agda?
18:12:40 <rwbarton> or like, in math? :P
18:12:49 <hpc> heh
18:12:53 <hpc> i think you can do it in agda
18:13:14 <dolio> Nope.
18:13:18 <kmc> i'd be surprised
18:13:37 <kmc> if by (==) you mean reflexive equality
18:13:43 <rwbarton> this is what stopped me from constructing functor categories, since I couldn't prove that composition of natural transformations was associative
18:13:51 <hpc> interesting
18:14:26 <rwbarton> I think the reason is suppose the domain of f,g is infinite; then to prove that, you effectively need to match infinitely == constructors
18:14:46 <hpc> ah
18:14:51 <rwbarton> hmm, can you prove it when the domain is finite though?
18:14:57 <dolio> You can't even prove it when the domain is empty.
18:14:59 <napping> for that, setoids don't sound so unnatural anyway
18:15:22 <hpc> dolio: wait what?
18:15:32 <dolio> Go try.
18:15:38 <Eduard_Munteanu> hpc: in Agda you kinda have to assume it (as a postulate, or provide it some other way)
18:15:50 <napping> if you want to allow things like topological spaces
18:15:57 <Eduard_Munteanu> It's Relation.Binary.PropositionalEquality's Extensionality
18:17:15 <ybit> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50] seems redundant
18:17:44 <Eduard_Munteanu> dolio: I think the reason you can't prove it is it's a definitional thingy, no?
18:18:46 <dolio> The only means you have to prove equality in Agda are reflexivity and induction, yes.
18:18:46 <Eduard_Munteanu> e.g. "we also say two functions are equally if the values they take are the same, in addition to being intensionally equal"
18:18:49 <ybit> multiply the list x elems by the list y elems and check to to see if they are less than 50, than return those elems to the output function which then multiplies the elems together and outputs them
18:19:05 <Eduard_Munteanu> s/equally/equal/
18:19:20 <ybit> it seems like you should just be doing
18:19:36 <ybit> [ x | x <- [2,5,10], y <- [8,10,11], x*y > 50]
18:19:56 <ybit> [ z | x <- [2,5,10], y <- [8,10,11], x*y > 50] for readability
18:20:04 <dolio> And (forall x. f x = g x) does not allow you to prove that f and g are interconvertable by beta and eta rules.
18:20:24 <ybit> re: lyah example
18:20:38 <dolio> And you really have nothing to do induction on.
18:21:26 <ybit> z wouldn't be in scope, hrm.. okay, i'll work on this later
18:21:44 <ybit> btw, i think my haskell code is on average shorter than my python stuff
18:22:03 <hpc> ybit: filter (> 50) [x * y | x <- blah, y <- foo]
18:23:32 <dolio> Curiously, if anyone ever figures out all this homotopy type theory stuff, it implies extensionality of functions.
18:24:28 <Eduard_Munteanu> @. pl undo [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
18:24:28 <lambdabot> ([8, 10, 11] >>=) . flip flip [] . ap (ap . (if' .) . flip flip 50 . ((>) .) . (*)) (flip flip [] . ((:) .) . (*)) =<< [2, 5, 10]
18:24:42 <napping> dolio: OTT also aimed at it
18:24:42 <ybit> internet went down, nice hpc!
18:24:52 <dolio> Yeah. That's closer.
18:24:59 <ybit> much less redundant
18:25:00 <Eduard_Munteanu> Ouch.
18:25:13 <dolio> Well, not closer to being finished, maybe.
18:25:24 <dolio> Since they keep rewriting Epigram 2 every 6 months or so.
18:25:47 <dolio> But everything in OTT makes sense computationally, I think.
18:25:52 <Eduard_Munteanu> What, is there anything more experimental than Agda? :P
18:26:12 <dolio> I'm not sure there's any explanation of how Voevodsky's "univalence axiom" is supposed to compute.
18:26:48 <qop> I wonder is haskell is a good language to learn programming
18:26:59 <napping> I think part of the story was that "equality" would have to be witnessed by a pair of functions for the translation
18:27:02 <Peaker> @faq can Haskell be used to teach programming?
18:27:03 <lambdabot> The answer is: Yes! Haskell can do that.
18:27:13 <ybit> qop: no, it's a terrible language
18:27:13 <sadgur> ha
18:27:18 <Peaker> qop: there's the Haskell for Kids thing
18:27:30 <ybit> haskell, *his*
18:27:32 <sadgur> this channel is used to disuade people from learning it
18:27:33 <ybit> hiss*
18:27:43 <qop> Peaker: lol cool
18:27:44 <spock> Is it possible to partially apply a list of parameters to a function and return the result once the function has been fully evaluated? It seems that I run into type issues when I try to do this recursively. :(
18:28:09 <napping> a list?
18:28:28 <napping> you'd need to depend on the type of the function to have any idea how many it wants
18:28:29 <Peaker> spock: what is the type of this applier you want to write?
18:28:49 <spock> as general as possible
18:29:18 <spock> ive been using exisistential types to prevent having to specify the types of parameters
18:29:27 <Peaker> spock: Something like: data Func a b = Func (a -> Either (Func a b) b)  ?
18:29:29 <napping> then it won't be different from just applying the parameters you have, will it?
18:29:30 <Eduard_Munteanu> Peaker: Helium?
18:29:38 <monochrom> most likely not typable. but I don't understand the question anyway.
18:29:44 <Peaker> Eduard_Munteanu: the thing advertised on Reddit
18:29:51 <spock> except that its in list form
18:29:52 * Eduard_Munteanu looks
18:30:02 <Peaker> spock: [a] -> b? :-)
18:30:05 <Eduard_Munteanu> Ah.
18:30:56 <Peaker> spock: what are you trying to do/use it for?
18:31:15 <Eduard_Munteanu> If it's variadic functions, then have a look at printf.
18:31:21 <Eduard_Munteanu> @hoogle printf
18:31:22 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
18:31:22 <lambdabot> module Text.Printf
18:31:22 <lambdabot> Text.Printf class PrintfArg a
18:31:35 <Eduard_Munteanu> Typeclass magic.
18:31:39 <byorgey> s/have a look at printf/don't do that/.
18:31:55 <shachaf> byorgey++
18:32:08 <Peaker> augustuss has some nice type hacks
18:32:14 <Eduard_Munteanu> Yeah, you might not want to do that anyway.
18:32:21 <spock> to create a function that takes f:: (a->b->..->x) -> [param] -> x
18:32:21 <Peaker> why not look at it? printf may not be a good idea -- but the type trickery is nice to know
18:32:25 <Eduard_Munteanu> It depends on what your goal is.
18:32:46 <Peaker> spock: can you narrow a,b,etc down to be a uniform type as a start?
18:32:54 <spock> nope
18:33:05 <spock> its for a DSL...
18:33:07 <Peaker> spock: so basically you want this dynamically-typed, to fail at runtime?
18:33:23 <napping> then perhaps Dynamic?
18:33:45 <Eduard_Munteanu> If it's a DSL, then you can probably pass the list straight to it.
18:33:50 <Peaker> spock: You can use: f :: (Dynamic -> Dynamic) -> [param] -> Dynamic     (and just reapply it as long as its type matches a function of the given params
18:34:23 <Eduard_Munteanu> There are limits to how close you can get to an actual syntax when implementing an EDSL in Haskell.
18:34:39 <spock> hmm dynamic? ill read up about this thanks!
18:34:51 <byorgey> the solution with Dynamic completely wastes approximately half the benefit you would otherwise get from embedding a DSL in Haskell.
18:35:18 <byorgey> Don't use Dynamic.  Redesign your DSL so you don't need variadic application.
18:36:01 <dolio> Or does it half waste the complete benefit?
18:36:07 * Peaker has never used Dynamic
18:37:04 <byorgey> It half wastes approximately the complete benefit.
18:37:05 * hackagebot carettah 0.0.6 - A presentation tool writtten with Haskell.  http://hackage.haskell.org/package/carettah-0.0.6 (KiwamuOkabe)
18:38:58 <parcs> good to know a package on hackage is written in haskell :P
18:41:17 <edenc> guys, I'm on mac os x and I'm trying to figure out a way to prevent dynamic loading on my binaries, cos it's loading incompatible libs from macports instead of the stock xcode libs which the platform was built against
18:42:08 <edenc> anyone have any pointers about how to solve that?
18:44:31 <Eduard_Munteanu> Does LD_LIBRARY_PATH / LD_PRELOAD work on Mac?
18:46:53 <edenc> not sure
18:47:14 <edenc> I know there's a DYLD_LIBRARY_PATH
18:48:38 <Cale> edenc: -static ?
18:48:51 <Cale> edenc: (though, I thought that -static was the default...)
18:49:35 <Eduard_Munteanu> Oh.
18:49:48 <Eduard_Munteanu> I think it isn't for non-Haskell stuff.
18:50:05 <Cale> oh, right
18:50:17 <Eduard_Munteanu> As in GHC will link statically against Haskell libs, but not against e.g. libc.
18:51:35 <Eduard_Munteanu> Dunno, maybe -optl-static might work.
18:51:41 <edenc> yeah, it keeps loading libiconv from the macports install
18:51:54 <edenc> when it should be loading from /usr/lib/
18:51:55 <Eduard_Munteanu> Or just messing with (DY)LD_LIBRARY_PATH
18:52:16 <Cale> there's also -optl-static
18:52:26 <edenc> I can't do static cos' then I'd have to recompile libiconv
18:52:50 <Cale> ah, it was mentioned while I looked away :)
18:52:57 <edenc> well, I can, but, that's a *lot* of trouble
18:53:39 <Eduard_Munteanu> Try    LD_LIBRARY_PATH=/usr/lib/:$LD_LIBRARY_PATH ./foo
18:53:48 <Eduard_Munteanu> (replacing foo with your executable)
18:53:52 <edenc> yeah, just did, no good
18:54:04 <Eduard_Munteanu> Maybe the DY... variant?
18:54:12 <edenc> yeah, tried that too
18:54:24 <edenc> it's pissing me off, If I disable the port lib it loads fine
18:54:36 <edenc> osx is so silly
18:55:13 <mmos1127> are function guards guaranteed to be tested in the order written? I would imagine so
18:55:22 <edenc> there has got to be an easy switch somewhere
18:56:00 <edenc> I could recompile the platform against the port libs but hell, that's gonna take all night
18:56:32 <edenc> I could also rewrite all the ports so that they use the stock libiconv, but that's an all-nighter too
18:58:09 <napping> mmos1127: That's how it acts. If you mean actually evaluated, I don't think there are promises
18:58:47 <mmos1127> napping: just asking about how it acts. I would expect so because I can streamline how I write guard testing if I know all guards above have failed
19:00:02 <napping> yeah, it's the first = that matches
19:03:25 <napping> mmos1127: from here http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13
19:03:48 <mmos1127> thanks.
19:03:52 <mmos1127> napping: thanks
19:06:08 <kmc> is there a general name for type constructors which recurse at a type other than their parameter?
19:06:32 <kmc> such as perfect binary trees:  data Perfect a = Stop a | Grow (Perfect (a,a))
19:06:43 <kmc> and is there any particular way to think about such types?
19:06:54 <kmc> (i suspect not, because it's such a general class)
19:07:29 <byorgey> kmc: they are usually known as "nested", or sometimes "non-regular"
19:07:44 * byorgey prefers "nested" since "regular" already has other meanings
19:08:18 <mmos1127> I am having the hardest time-- I'm trying to write a function that takes the difference between two integers mod M, in which the answer is "the closest way 'round" -- that is in the range approx -M/2 to M/2 --- any succinct expressions of this?
19:09:05 <byorgey> kmc: see "Nested Datatypes" by Bird and Meertens: http://www.cs.ox.ac.uk/richard.bird/online/BirdMeertens98Nested.pdf
19:09:17 <kmc> thanks :)
19:09:57 <ddarius> @google "Manufacturing Data types"
19:09:58 <lambdabot> http://www.linkedin.com/in/justinneway
19:10:04 <ddarius> @google "Manufacturing Datatypes"
19:10:05 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.3529&rep=rep1&type=ps
19:10:46 <byorgey> mmos1127: decompose it into a composition of two functions: one to take the difference of two integers mod M, and one to take a value from 0..M-1 and if it is > M/2, subtract M
19:10:49 <nh2> would you recommend putting software under WTFPL?
19:10:54 <gwern> @quote overflow
19:10:55 <lambdabot> copumpkin says: <kmc> do you have a theory where the stack overflow is coming from? <copumpkin> joel spolsky
19:11:03 <Phlogistique> nh2: why not?
19:11:30 <mmos1127> byorgey: that's what I tried to do and it's not working.. I guess I'm on the right track but it's buggy
19:11:39 <gwern> Phlogistique: you gain nothing whatsoever and confuse people wondering wtf this license is and will they be sued into oblivion for using it and no toolchain or set up supports such a stupid idiosyncratic license?
19:11:47 <nh2> Phlogistique: in its OSI proposal, it was rejected because it was too close to public domain, which does not exist in some countries
19:12:18 <gwern> (oh lovely, so it's not even legally workable? what a pile of fail)
19:12:33 <Phlogistique> gwern: wait, how is any toolchain or set up even related to this?
19:12:37 <gwern> some people say, I have a problem deciding what to license my code as; I know, I'll write my own license! ...
19:13:36 <byorgey> mmos1127: ok, well if you paste what you have so far on hpaste.org (along with any errors) I can take a look
19:13:37 <gwern> Phlogistique: what does cabal do when it sees wtfpl in a .cabal? as I remember the ADTs, it punts to other, which means anyone interested in license dependency graphs, automated compliance checking etc now has this bizarre entry on hackage they need to hand-deal with
19:13:38 <mmos1127> byorgey: does the mod operator giving a negative answer to negative input? I think that's my problem.. but I thought it was giving a positive answer in one case of a negative input.. is there a guarantee?
19:13:46 <Phlogistique> http://www.gnu.org/licenses/license-list.html#WTFPL
19:13:50 <byorgey> > (-5) `mod` 2
19:13:51 <lambdabot>   1
19:14:05 <gwern> using thw wtfpl makes about as much sense as writing your comments in pig latin
19:14:27 <byorgey> @check \n (Positive m) -> n `mod` m >= 0
19:14:28 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
19:14:28 <lambdabot>                     (Test.QuickC...
19:14:34 <nh2> gwern: why?
19:14:35 <gwern> not as bad as writing your own language or OS, though, so I shouldn't harsh on it too much
19:14:51 <byorgey> @check \n (NonNegative m) -> n `mod` (m + 1) >= 0
19:14:51 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
19:14:52 <lambdabot>                     (Test.QuickC...
19:15:04 <byorgey> @check \n (NonNegative m) -> (n :: Int) `mod` (m + 1) >= 0
19:15:05 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
19:15:05 <lambdabot>                     (Test.QuickC...
19:15:13 <byorgey> grrr
19:15:15 <mmos1127> oh I know what my problem is! when I tested mod at the ghci prompt I wrote "-5 `mod` 12" which it read as "- (5 `mod` 12)"
19:15:25 <byorgey> mmos1127: ah, yes, that would do it =)
19:15:43 <Phlogistique> gwern: WTFPL opponents will answer that your critics are nonsensical, because you can relicense it under BSD for the purpose of Cabal if you like
19:15:50 <BMeph> " <gwern> some people say, I have a problem deciding what to license my code as; I know, I'll write my own license! ..." Now they have two problems? ;)
19:16:02 <Phlogistique> *proponents
19:16:11 <gwern> Phlogistique: 'using my stuff causes problems? no problem, simply don't use my stuff!' <-- I see...
19:16:55 <Phlogistique> gwern: this is terrible straw man
19:17:10 <nh2> +1
19:17:15 <gwern> Phlogistique: what advantage does it have over BSD? from your reply, it has none.
19:17:29 <Draconx> gwern, you don't have to reproduce a giant paragraph in all caps.
19:17:34 <gwern> if it has none, then it is pernicious license proliferation and fragmentation
19:17:41 <gwern> wow. what an advantage.
19:17:44 <Phlogistique> gwern: my point is that it's a non-issue. no point getting worked-up with it
19:18:16 <gwern> Phlogistique: then there's no point in recommending or discussing it
19:18:29 <mmos1127> byorgey: ok it does what I expected now. byorgey++++
19:18:42 <ddarius> byorgey++--
19:18:47 <Draconx> one annoying thing about BSD3 is that each package tends to have slightly different all-caps paragraphs.  So if you combine those packages, you now have two paragraphs in all caps that you need to reproduce.
19:18:57 <mmos1127> byorgey+++++
19:19:11 <Phlogistique> gwern: you seem to think that there is a point in discussing it, as that's what your doing currently
19:19:32 <Phlogistique> as for recommending it, it looks pretty clear to me that the point is that people think it's funny
19:20:11 <gwern> Phlogistique: it is worth discussing like false beliefs are worth discussing - worth discussing because it, unfortunately, exists and there are believers
19:20:20 <gwern> were it to not exist, one would not discuss it
19:20:33 <nh2> Phlogistique: we're looking for a license closest to the public domain, but still legal in all countries
19:21:17 <gwern> (also, what an extremely irritating rhetorical move. as if discussing something must mean that there's a point - yes, there is a point, the point is there is no point and one can stop discussing it.)
19:21:46 <byorgey> mmos1127: ddarius did that because lambdabot parses anything of the form "foo++" and keeps track of karma points.  so you gave a karma point to 'byorgey++'
19:21:54 <Phlogistique> gwern: 04:30:30 < gwern> Phlogistique: then there's no point in [...] discussing it
19:22:20 <gwern> meta. Phlogistique does not understand it.
19:22:26 <byorgey> mmos1127: glad it works now =)
19:22:28 <Phlogistique> gwern: oh well, excuse me for discussing that with you. I'm not following-up on this discussion.
19:22:55 <gwern> Phlogistique: I forgive you. it's easy to think fragmentation is harmless.
19:23:32 <ddarius> gwern: Not if you've written a memory allocator or database.
19:23:42 <byorgey> nh2: what about CC0 ?
19:23:49 <gwern> ddarius: can't say I was really thinking o that kind of fragmentation
19:23:55 <byorgey> nh2: http://creativecommons.org/publicdomain/
19:24:32 <mmos1127> byorgey++
19:24:48 <gwern> byorgey: as far as I can tell, cc0 is good. I use it for gwern.net
19:25:04 <mmos1127> Okay I thought you would enjoy the bonus of karma points, but I gave you nothing the first time. How sad.
19:25:15 <nh2> byorgey: wasn't there something that CC is only inteded for media, documentation or something like that? I've seen no software so far using CC
19:25:39 * kmc has a soft spot for the WTFPL, but no love for license arguments
19:25:47 <byorgey> mmos1127: heh, no worries, thanks =)
19:25:59 <kmc> i think the most important thing is to use a license which is clear and well-understood
19:25:59 <byorgey> nh2: I don't know.  Isn't software copyrightable?
19:26:06 <kmc> otherwise you cast FUD over your whole project
19:26:22 <Phlogistique> byorgey: it is
19:26:44 * ddarius is cooking some fud right now.
19:28:11 <byorgey> nh2: if CC is not appropriate for software it's news to me.  But I Am Not A Lawyer (tm).
19:28:30 <kmc> füd?
19:29:02 <nh2> byorgey: just found http://wiki.creativecommons.org/CC0_FAQ#May_I_apply_CC0_to_computer_software.3F_If_so.2C_is_there_a_recommended_implementation.3F - that looks very good. Thanks!
19:29:12 <byorgey> föøð
19:29:21 <byorgey> nh2: excellent.
19:30:02 <byorgey> oh, I see, normal CC licenses aren't for software but CC0 can be.
19:30:02 <gwern> nh2: interesting; I knew they didn't recommend the other CC licenses for software, but not that CC0
19:30:14 <Cale> http://www.youtube.com/watch?v=icTrzUuWlHI -- lol (offtopic)
19:32:39 <BMeph> Why do people insist on giving business to Springer-Verlag?
19:33:25 <monochrom> habit
19:41:56 * ddarius likes recursive helping.
19:44:45 <Cale> BMeph: Well, there are a lot of really good yellow books.
19:45:01 <Cale> BMeph: It's not so much that Springer is great, it's the books :)
19:46:13 <kmc> hmm, the first example in the nested datatypes paper is de bruijn lambda terms with indices proven valid in the type
19:46:23 <kmc> and it's Haskell 98
19:46:33 <kmc> (though I guess the functions you want for working with it require rank-N types)
19:46:34 <kmc> that's cool :)
19:47:03 <ddarius> kmc: See the Manufacturing Datatypes paper I referenced as well.  Admittedly, it is not as cool as the deBruijn lambda terms.
19:47:40 <kmc> thanks ddarius
19:47:51 <kmc> tharius
20:06:48 <kmc> by vectron's beard!
20:15:08 <dolio> Nested types are slightly iffy.
20:15:30 <dolio> If you're not a fan of impredicativity.
20:18:17 <Cale> What's iffy about them?
20:20:08 <dolio> Large indices are rather impredicative.
20:20:35 <dolio> The predicative justification for large parameters on a type is that you can abstract them from the data.
20:21:11 <dolio> That is, 'data T (A : Large) ...' is equivalent to 'module M (A : Large) where { data T ... }'.
20:21:40 <dolio> And it would be pretty anal to disallow defining datatypes with any scope parameterized by something large.
20:22:05 <dolio> However, that transformation is invalid for nested types, so they're not exactly just parameterized by the large type.
20:22:35 <dolio> For a while, Coq couldn't handle nested types at all, except using a type with large indices.
20:23:02 <dolio> And that typically kicks the type into a higher sort anyway, unless you use impredicativity of Set for instance.
20:27:50 <joshcough> hi. im getting a warning message that is rather confusing. im hoping some could possibly shed some light on it? it seems like the patterns dont really overlap...
20:27:52 <joshcough>     Warning: Pattern match(es) are overlapped
20:27:53 <joshcough>              In an equation for `parseList':
20:27:53 <joshcough>                  parseList ["eax", "<-", "allocate", t1, t2] = ...
20:27:53 <joshcough>                  parseList ["eax", "<-", "array-error", t1, t2] = ...
20:29:11 <Saizan> looks like the warning is just wrong
20:29:20 <joshcough> i agree.
20:29:39 <joshcough> i just wanted to make sure i wasnt misunderstanding something.
20:30:28 * ddarius suspects that it is incomplete...
20:32:58 <rwbarton> is that an array of Strings or are you using the overloaded strings extension?
20:33:08 <rwbarton> er, list
20:33:12 <joshcough> it is a list of strings.
20:49:15 <napping> has anyone here installed Mozart/Oz?
21:00:15 <T_X> hmm, sry, stupid beginner question: but why does this short program not compile? http://pastebin.com/LJR7tLkT
21:00:17 <Mauke> The paste LJR7tLkT has been copied to http://hpaste.org/53000
21:00:32 <T_X> if I remove the isInteger part, then it suddenly works
21:01:13 <ion> It seems the paste is missing the error message.
21:01:20 <T_X> and that's the error I'm getting: http://pastebin.com/tDvaijjp
21:01:23 <Mauke> The paste tDvaijjp has been copied to http://hpaste.org/53001
21:02:10 <ion> Try typeOf (5 :: Integer)
21:02:21 <ion> Also, “foo == True” is the same as “foo”
21:04:25 <T_X> ion: thanks that works!
21:04:26 <stepkut> T_X: 5 could be an Int, but it could be a Float, or a Double, or anything else with a Num instance.
21:05:06 <T_X> stepkut: mkay, but why is a simple 'typeOf 5' returning an unambigous 'Integer' then?
21:05:28 <T_X> *unambiguous
21:05:46 <ddarius> Yay generalized defaulting.
21:05:52 <stepkut> T_X: in what situation? When you type it at the ghci prompt?
21:06:04 <T_X> stepkut: yes
21:06:24 <ion> What’s the point of that code, btw? :-)
21:06:36 <T_X> Prelude> typeOf 5
21:06:38 <T_X> Integer
21:07:03 <stepkut> T_X: in ghci, the defaulting rules are applied, and it decides that 5 should be an Integer
21:07:06 * hackagebot binary-bits 0.1 - Bit parsing/writing on top of binary.  http://hackage.haskell.org/package/binary-bits-0.1 (LennartKolmodin)
21:07:12 <T_X> ion: there's not really a point in it, just wanted to write a stupid function which is type independent :)
21:08:03 <ion> $ ghc -Wall -e 'Data.Typeable.typeOf 5'
21:08:06 <ion>     Warning: Defaulting the following constraint(s) to type `Integer'
21:10:25 <T_X> just wanted to write down my first haskell program with both a type variable and guards :)
21:10:31 <stepkut> T_X: you could write it like this, http://hpaste.org/53002
21:10:36 * T_X is currently reading learnyourhaskell
21:10:57 * T_X is currently reading learnyouahaskell
21:11:27 <ion> echo… echo…
21:11:46 * DanBurton just finished installing Ubuntu 11.10, which came with GHC 7.0.3, yay!
21:11:53 <T_X> ion: nope, learnyourhaskell != learnyouahaskell ;)
21:12:51 <T_X> stepkut: thx! that looks way nicer. the specific type example in the code looked a little silly, yeah
21:15:09 <Cale> DanBurton: I think I've decided against installing that upgrade. I'm just going to find a way to switch back to Ubuntu :P
21:15:25 <Cale> DanBurton: Though how are you finding it?
21:15:32 <DanBurton> Cale: seems nice
21:15:58 <DanBurton> Just tried cabal install yesod, ran into issues with crypto-api T_T
21:16:36 <Cale> Are you using the new UI or traditional Gnome?
21:16:42 <DanBurton> the new one
21:16:51 <DanBurton> Unity; I was using it since 11.04
21:17:11 <Cale> I tried it for about 30 minutes, and decided it was too frustrating.
21:17:13 <eggsby> I just switched from debian to ubuntu 11.10, it's pretty nice
21:17:14 <stepkut> T_X: yeah. I think the use of undefined makes it clear that the actual value is not important, only the type
21:17:15 <DanBurton> at first it's like "hey where'd all my Gnomey options go", but I don't have tons of customizations so it's not a big deal
21:18:10 <eggsby> DanBurton: the shortcuts make up for it, stuff like [shift]+control+alt+arrow key
21:19:10 <Cale> I've also been uninstalling PulseAudio for the last several versions, and lately I've had to recompile packages just to turn on plain ALSA support again. PA has never worked with my sound setup. It always pins my headphone volume at 0 and gives me only a single master volume control which is supposed to be good enough for everything, I guess.
21:19:54 <ddarius> PulseAudio has tended to be a good thing for me.  NetworkManager on the other hand...
21:20:10 <luite> you can still get thegnome ui with 11.10 if you install the gnome-panel package
21:20:34 <Cale> luite: Yeah, I'm just not sure it's worth the trouble staying with Ubuntu.
21:20:56 <ddarius> Cale: Going to get a Mac?
21:21:04 <Cale> ddarius: no, Debian.
21:21:32 * ddarius only jokink anyvey.
21:22:35 <Cale> I used Debian unstable for 6 or 7 years before deciding to try Ubuntu on a fresh machine install at one point. I originally liked it because its default configuration didn't take much work to get into a shape that I liked it, but that's only become less and less true with each upgrade.
21:22:54 <ddarius> Gnome is sin.
21:23:20 <DanBurton> KDE?
21:23:31 <Cale> Before Gnome, I used Enlightenment :)
21:23:34 <ddarius> I highly suspect KDE is worse
21:23:55 <ddarius> Gnome is more than just the dm/wm.
21:24:40 <eggsby> Would you recommend lyah or real world haskell? Why one over the other?
21:24:49 <DanBurton> lyah first then rwh
21:24:53 <ddarius> eggsby: Read both or neither.
21:24:54 <DanBurton> lyah is easier to digest
21:25:04 <eggsby> okay, ya lyah def seems shorter too
21:25:04 <DanBurton> rwh is more in depth
21:25:06 * ddarius checks and finds that he is not eggsby.
21:25:25 <eggsby> ddarius: Not... yet!
21:26:18 <napping> Cale: first, why isn
21:26:28 <napping> isn't this conversation in the off-topic channel?
21:26:35 <ddarius> @vera isn
21:26:36 <lambdabot> *** "isn" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
21:26:36 <lambdabot> ISN
21:26:36 <lambdabot>      Information Systems Network
21:26:36 <lambdabot>  
21:26:36 <lambdabot> *** "isn" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
21:26:38 <lambdabot> [11 @more lines]
21:26:38 <Cale> napping: Which one? :)
21:26:56 <Cale> napping: Mostly because there's not much else going on here
21:27:06 * hackagebot rss 3000.2.0 - A library for generating RSS 2.0 feeds.  http://hackage.haskell.org/package/rss-3000.2.0 (BasVanDijk)
21:27:16 <napping> but I had a similar history - running debian unstable, switching to ubuntu, then realizing the only thing I actually wanted such a fresh version of was GHC and going back to debian stable
21:28:04 <ddarius> Do you actually need a "fresh" version of GHC?
21:28:08 <napping> well, the desktop is still on Ubuntu, but it's in the middle of upgrading. If Ubuntu manages to make the system unbootable for the third version upgrade in a row it's going back to debian
21:28:28 <Cale> ddarius: Kinda, if you want to install a lot of the stuff that's on hackage
21:28:38 <napping> to try new extensions and stuff - also, debian stable has a pretty old version
21:29:36 <ddarius> Do new Haskell programmers think, "how did they program stuff in Haskell back in the day?"
21:29:57 <Cale> ?
21:30:15 <hpaste> DanBurton pasted “Ugh...cabal install yesod” at http://hpaste.org/53003
21:30:42 * shachaf >>= NY
21:31:22 <Cale> DanBurton: I guess one thing to figure out is why it's selecting 0.6.4
21:31:27 <ion> What’s the monadic type for which NY is a data constructor?
21:31:49 <ddarius> Cale: To think, there is a time when we didn't have constraint kinds or type families or GADTs.
21:31:59 <DanBurton> Cale: it looks like Yesod wants crypto-api >= 0.8, but clientsession wants crypto-api < 0.7
21:32:29 <DanBurton> Cale: Can't they each just use their own preferred version of crypto-api? /confused
21:32:33 <kmc> GADTs whatever, but think there was a time with no Cabal or Hackage!
21:32:42 <ddarius> DanBurton: Not currently.
21:33:11 * ddarius remembers when Cabal was just a glimmer in Isaac's eye; back when he was merely Mr. Jones.
21:33:14 <Cale> ddarius: Features like that have been the main reason we keep updating our GHC version at iPwn. We're going to need 7.2.1 now because we need superclass equality constraints to keep things from getting messy with some changes to our arrow machinery.
21:34:26 <kmc> i'm starting to wonder whether superclass equality constraints for a custom arrow preprocessor are really the best way to write an iPhone game
21:34:44 <Cale> DanBurton: Well, if the packages have conflicting deps, then they're not going to be installable. Maybe the version of clientsession which the latest yesod relies on hasn't hit hackage yet?
21:34:53 <luite> DanBurton: hmm, you can try to install crypto-api 0.7 and cprng-aes-0.2.1 manually first
21:35:00 <luite> looks like there was a recent update to cprng-aes
21:35:25 <ddarius> kmc: Pssh.  Haskell wasn't practical before we had constraint kinds.  Just look at Java.
21:35:37 <luite> don't really know why there's that upper bound on crypto-api for clientsession
21:35:58 <Cale> kmc: :)
21:36:05 <DanBurton> luite: yeah I'll try that, thanks
21:36:19 <DanBurton> luite: I just wish cabal-install was smart enough to do stuff like this
21:36:25 <luite> DanBurton: otherwis, get the clientsession package from:  https://github.com/snoyberg/clientsession
21:36:41 <luite> it has been updated today, but apparently not yet released on ahckage
21:36:43 <Cale> kmc: Well, we might be able to get away with making more use of type families instead.
21:36:45 <Cale> :)
21:37:24 <Cale> kmc: Or just use different choices of module imports without making the interface explicit (just use monomorphic types everywhere)
21:42:02 <DanBurton> luite: nice; grabbing the latest clientsession looks like it fixed the problem. At least, now my computer has happily moved on to installing various other libraries that yesod requires :)
21:42:05 * hackagebot DSH 0.7.6 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.7.6 (GeorgeGiorgidze)
21:42:07 * hackagebot mime-mail-ses 0.0.0.3 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.0.0.3 (MichaelSnoyman)
21:42:36 <luite> ok, there's Michael uploading packages :)
21:55:26 * DanBurton wonders how it is that there are 767 people in the chat room, and yet it is silent
21:55:43 <newsham> shhh
21:55:45 <byorgey> it WAS silent
21:55:48 <byorgey> sheesh
21:55:58 <newsham> if everyone starts talking imagine what a flood of noise it would be :(
21:56:01 <newsham> we all need to do our part
21:56:12 <DanBurton> sorry, didn't mean to wake the endofunctors
21:57:06 <qop> heya, is there any good ide for Haskell? (Linux) I mean something really useful like gnat or qtdevelop not a lousy eclipse/netbeans plugin
21:59:10 <tensorpudding> http://leksah.org/
21:59:18 <tensorpudding> can't say it's good, just that it exists
22:00:07 <qop> lol
22:02:33 * kmc doesn't know enough about ides to know what makes gnat or qtdevelop better than eclipse or netbeans
22:02:49 * DanBurton has never heard of gnat or qtdevelop
22:03:10 <napping> isn't gnat an ada compiler?
22:03:26 <DanBurton> GPL 2.0 makes leksah sound old
22:03:33 <qop> those are for Ada and for C ++  respectively
22:03:35 <byorgey> qop: there is also an eclipse plugin, but I think it is not lousy
22:03:45 <byorgey> @where eclipsefp
22:03:45 <lambdabot> I know nothing about eclipsefp.
22:03:51 <byorgey> @go EclipseFP
22:03:51 <lambdabot> Maybe you meant: google googleit do
22:04:01 <qop> byorgey: I dont like eclipse a bit, too cluttered
22:04:05 <qop> but ty
22:04:09 <byorgey> ok.
22:04:34 <DanBurton> @google eclipseFP
22:04:35 <lambdabot> http://eclipsefp.github.com/
22:04:35 <lambdabot> Title: EclipseFP
22:05:03 <DanBurton> The last time I tried EclipseFP, it didn't work at all.
22:05:38 <qop> I believe that IDEs should support your development, and stay off the way, eclipse or VS tend to always be there saying "hey dont forget about me"
22:05:45 <DanBurton> I've been more and more pleased with emacs, though
22:06:24 <qop> one shouldn't even have to learn much about the ide, just shoot the program and start coding
22:06:27 <qop> imho
22:06:39 <ddarius> Why do you want an IDE?
22:07:07 <qop> macrom and less windows  :)
22:07:11 <qop> macros*
22:07:30 <ddarius> Why do either of those things require an IDE?
22:07:50 <qop> require? naw, none of them do :)
22:08:15 <DanBurton> emacs and vim can do those things easily
22:08:25 <qop> its just handy when it happens to integrate well
22:08:55 <qop> yes but again, you invest time in learning emacs and vim
22:09:10 <qop> (even though I do use emacs)
22:09:24 <DanBurton> sadly true
22:09:52 <kmc> you also invest time in learning an IDE
22:10:02 <DanBurton> I always sympathize with emacs, though. Emacs came before typical commands like CTRL-S, CTRL-C and CTRL-P were popularized
22:10:05 <qop> thats my oint! you shouldnt
22:10:08 <kmc> i mean Emacs *is* basically an IDE
22:10:18 <kmc> you shouldn't have to learn how to use tools?
22:10:35 <qop> kmc: you can remove the ", it IS
22:10:42 <kmc> then they must not be very powerful tools
22:10:44 * DanBurton wants an IDE with a direct interface to his brain
22:11:18 <qop> have you used c++ and qdevelop for example
22:11:50 <kmc> no
22:12:03 <qop> you can open it and start coding right oer even if you havent ever seen the app before, thats what I mean
22:12:11 <qop> over*
22:12:29 <qop> you spend time dealing the code, not the ide
22:12:36 <kmc> it's basically true of GUI emacs as well
22:12:46 <kmc> but whatever
22:12:49 <qop> too bad it only supports c++ now =\
22:12:58 <kmc> i don't have strong opinions about emacs; I don't use it much, and it's off topic
22:13:07 <qop> kmc: ya, once you''ve learn it..
22:13:22 <qop> all rite
22:13:44 <qop> so... I'll tr leksah, looks simple eough ty
22:13:51 <xrl> I'm getting this error: Couldn't match expected type `IO b0' with actual type `[a0]'. How do I perform the IO operation so I can get my string?
22:14:16 <kmc> xrl, http://www.haskell.org/haskellwiki/Introduction_to_IO
22:14:32 <kmc> you can use:   fmap :: (a -> b) -> (IO a -> IO b)
22:14:37 <kmc> or use (>>=) or "do" notation
22:14:54 <xrl> hmm, the code is inside of a do block
22:14:59 <xrl> which is why I'm confused
22:15:10 <tkahn> xrl go to hpaste.org
22:15:24 <kmc> xrl, maybe you should study the translation from "do" syntax into (>>=), and the type of (>>=)
22:15:42 <kmc> xrl, just being inside a "do" block doesn't change the meaning of Haskell expressions
22:15:48 <hpaste> xrl pasted “Working with binary data, parser” at http://hpaste.org/53004
22:15:49 <kmc> it just gives you a little syntactic sugar for (>>=)
22:15:54 <xrl> http://hpaste.org/53004
22:15:57 <xrl> oops
22:15:58 <xrl> haha
22:17:03 <hpaste> tkahn annotated “Working with binary data, parser” with “Working with binary data, parser (annotation)” at http://hpaste.org/53004#a53005
22:17:14 <kmc> xrl, «putStrLn foo ++ bar» is «(putStrLn foo) ++ bar»
22:17:24 <kmc> i think you want «putStrLn (foo ++ bar)»
22:17:36 <kmc> function application always binds tighter than infix operator application
22:17:43 <kmc> xrl, do you want other suggestions regarding your code?
22:17:56 <xrl> kmc: of course! it's my first try at a parser
22:17:59 <kmc> ok
22:18:10 <xrl> to say nothing of my total confusion on lazy or otherwise bytestrings ;)
22:18:17 <kmc> ByteString.Char8 is a loathsome hack; don't use it
22:18:29 <kmc> ByteStrings hold bytes, not chars
22:18:54 <xrl> how do I parse a binary protocol?
22:19:02 <xrl> a byte-oriented binary protocol, at that
22:19:08 <kmc> using ByteString
22:19:12 <xrl> I was going to to use the bit-get syntax
22:19:31 <kmc> or using a bytestring parser library like attoparsec
22:19:46 <kmc> but I don't see how Char8 would help you work with binary data
22:19:57 <kmc> compare the Data.ByteString and Data.ByteString.Char8 APIs
22:21:06 <kmc> Word8 is the type of a byte
22:21:15 <kmc> so [Word8] is a list of bytes and ByteString is a packed array of bytes
22:21:36 <xrl> hmm, I'm looking over attoparsec and it seems like it might have what I want
22:22:00 <kmc> Char is a Unicode character; [Char] = String is text stored as a list, and Data.Text is a packed text type
22:22:42 <xrl> a list is not guaranteed to be stored in continguous data whereas data.text is indeed?
22:22:50 <kmc> yes
22:23:02 <kmc> so many operations are more efficient on Data.Text or ByteString than on [Char] or [Word8]
22:23:03 <xrl> so data.text is a more suitable storage for my data, right?
22:23:09 <kmc> your data are bytes, yes?
22:23:13 <kmc> not Unicode characters?
22:23:14 <xrl> yup
22:23:20 <kmc> so ByteString is a more suitable storage
22:23:23 <xrl> yup, just dumb bytes when they come in
22:23:26 <xrl> oh, ok
22:23:36 <kmc> [Word8] = list bytes.  ByteString = packed bytes
22:23:41 <kmc> [Char] = list text.  Text = packed text
22:23:58 <kmc> it's all very simple provided you don't assume bytes and characters are the same thing
22:24:10 <kmc> which they haven't been for decades, but that assumption is still ruining computers for people all over the globe
22:24:14 <xrl> a byte is a width, a character is a representation... right?
22:24:17 * kmc rants
22:24:24 <xrl> ya, java chars
22:24:32 <kmc> a byte is a number between 0 and 255 inclusive
22:24:45 <kmc> a character is... well, Unicode is pretty complicated
22:24:47 <xrl> yes, 8 bit bytes, unless you go back in time
22:24:51 <kmc> there are characters and code points and scalar values
22:24:57 <kmc> but suffice to say there's many more of them than bytes
22:25:10 <kmc> there are many incompatible ways to represent characters as sequences of bytes
22:25:21 <xrl> yes, you have to know the context of their encoding
22:25:32 <xrl> I'm quite glad I just deal with bits
22:25:35 <kmc> *nod*
22:26:01 <tkahn> i think even calling a byte a number from 0 to 255 is assigning an interpretation
22:26:08 <tkahn> it's just a bit pattern
22:26:20 <kmc> in Haskell the former is a more natural than the latter
22:26:21 <xrl> tkahn: don't start with that ;)
22:26:27 <tkahn> lol
22:26:28 <kmc> because Num is in Prelude and Bits isn't
22:26:35 <kmc> not like it's a big deal
22:26:55 <xrl> tkahn: although you have a point. we should have number encodings. provide an offset before I'll consider adding them ;)
22:27:03 <ddarius> xrl: We do.
22:27:18 <xrl> I don't provide 0... it's implied, isn't it?
22:27:32 <kmc> xrl, anyway, ByteString.Char8 is a loathsome hack because it uses types which suggest it handles Unicode text, but it does incorrect things for almost all Unicode characters
22:27:40 <kmc> it perpetuates the confusion between bytes and characters
22:27:41 <ddarius> See floating point, 2's complement, biased encodings, fixed point.
22:27:51 <kmc> and the attitude of "my software is good enough if it only works for people who speak english"
22:28:38 <kmc> anyway
22:28:46 <kmc> you're working with bytes so the situation is nice and simple :)
22:28:48 <xrl> attoparsec it is!
22:29:04 <kmc> xrl, I recommend "import qualified Data.ByteString as B"
22:29:20 <kmc> then you can say "putStrLn" and not "Prelude.putStrLn"
22:29:31 <xrl> also, as you pointed out, I need to remember that ++ has a lower precedence than space ;)
22:29:47 <kmc> also you don't need to qualify ZMQHS.Frame.parse 'cause you imported that module not-qualified
22:30:18 <xrl> ah, good point
22:30:37 <kmc> if you really want to qualify Prelude names you can get a short prefix
22:30:39 <kmc> "import Prelude as P"
22:31:12 <kmc> "qualified" and "as" are orthogonal
22:31:33 <kmc> "as" says what the qualifier is
22:31:47 <kmc> "qualified" says that the qualifier is always necessary; without it's only necessary when ambiguous
22:32:06 <xrl> as give an alias... qualified means with/without certain functions... right?
22:32:22 <kmc> certain functions?
22:32:22 <DanBurton> if you do "import qualified Prelude as P", then can you still do Prelude.foo?
22:32:43 <kmc> xrl, with "qualified" you must use a qualified name for anything from that module
22:33:04 <kmc> xrl, without "qualified" you may use any name from the module unqualified, unless it collides with another module
22:33:15 <kmc> in those cases you can still use the qualifier even though you did not "import qualified"
22:33:41 <kmc> (it's not just functions, but anything which can be imported)
22:34:22 <napping> DanBurton: I think that's complicated by the implicit prelud
22:36:13 <hpaste> kmc annotated “Working with binary data, parser” with “Working with binary data, parser (annotation)” at http://hpaste.org/53004#a53006
22:36:15 <napping> the answer seems to be no
22:36:21 <kmc> xrl, this is how i'd write it
22:42:02 <DanBurton> interesting...looks like if you perform the qualified import in ghci, then the original name is available as well, while if you perform the import in the source file, the original name is not available.
22:42:29 <napping> ghci lets you refer to things by a fully qualified name without importing them at all
22:42:48 <DanBurton> ahh
22:42:52 <DanBurton> til
22:44:26 <DanBurton> OK...time for me to actually learn Haskell Mode in emacs. Is there a ready-made Haskell Mode binding for "load current buffer into GHCI"?
22:45:05 <napping> I doubt it
22:45:28 <napping> well, maybe the whole buffer
22:45:50 <DanBurton> I know I've heard of something like that
22:45:51 <napping> the very newest might actually let you add top level definitions
22:47:13 <DanBurton> ooh found it. C-c C-L
22:47:24 <xrl> kmc: thanks for all the help :)
22:49:40 <kmc> no problem :)
22:50:02 <napping> it's a shame you lose local definitions that way
22:55:39 <fazzone> Is   case (thingOne, thingTwo) of ...    preferable to nesting case statements?
22:57:43 * DanBurton is learning tons of cool ghci powers that are also present in emacs Haskell Mode
22:58:05 <DanBurton> fazzone: it just depends. It's a matter of taste
22:59:23 <DanBurton> fazzone: I can imagine situations where nesting would be preferable, and other situations where tupling would be best
22:59:39 <DanBurton> s/best/clearest
23:15:57 <DanBurton> one thing that is slightly weirding me out about the new ubuntu is that it seems the default font for the terminal has changed
23:27:13 <DanBurton> Is anyone running into this issue? "error while loading shared libraries: libffi.so.5: cannot open shared object file: No such file or directory
23:27:33 <DanBurton> Looks like the ubuntu upgrade might have screwed up the ffi or something
23:31:49 <DanBurton> ls
23:31:51 <DanBurton> doh
23:31:56 <DanBurton> wrong window
23:33:05 <ion> rm -fr ~
23:33:27 <ion> danburton: I don’t mind the new font.
