00:06:35 <gaze__> @pl \x y -> a (b x y)
00:06:35 <lambdabot> (a .) . b
00:06:55 <gaze__> @pl \x y z a b -> a (b x y z a b)
00:06:56 <lambdabot> ((ap (.) .) .) . flip flip id . ((flip . ((flip . (ap .) . flip) .) . flip) .) . flip . flip id
00:07:26 <gaze__> well, that was fun.
00:07:58 <gaze__> @pl \x y z a b -> p (q x y z a b)
00:07:59 <lambdabot> ((((p .) .) .) .) . q
00:08:42 <gaze__> that's actually what I meant... any idea how to get that point-free?
00:09:15 * hackagebot hastache 0.1.5 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.1.5 (SergeyLymar)
00:09:17 * hackagebot Stream 0.4.4 - A library for manipulating infinite lists.  http://hackage.haskell.org/package/Stream-0.4.4 (WouterSwierstra)
00:09:19 * hackagebot Stream 0.4.5 - A library for manipulating infinite lists.  http://hackage.haskell.org/package/Stream-0.4.5 (WouterSwierstra)
00:24:26 <Blkt> good morning everyone
00:29:16 * hackagebot unix-time 0.0.3 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.0.3 (KazuYamamoto)
00:30:01 <Quantumplation> So, every few months I fall in love with Haskell again and want to write something in it, but have no idea what.  I just got an idea, but It's a bit out of my scope as a haskell developer (not in other languages, i'm a fairly competent programmer there), so I was wondering if anyone wanted to help guide me along in the process
00:34:32 <Quantumplation> I'm working on a math problem called the Thrackle problem, which has to do with graph embeddings in the plane, and I thought it'd be really cool to have a library/DSL/visualization tool to create and manipulate various graphs (the vertex edge kind, not the bar or pie kind) and detect properties and highlight features of the graph
00:35:55 <Quantumplation> Seems like a nice meaty problem that would be ideal for haskell, and allow me to really enjoy the coding process for a substantial, "real" project (bigger than project euler and more applicable than contrived samples and such i've encountered)
00:38:49 <koala_man> I'm reading "why dependent types matter", which uses the notation "order x y <= rec x". what does that mean?
00:39:45 <Saizan> koala_man: iirc, that you are defining order x y by recursion over x
00:43:22 <koala_man> Saizan: so that it'll recurse based on the type, i.e. the equivalent of n-1 for for natural numbers and tail for lists?
00:51:37 <koala_man> Saizan: ah, it does explain it further on
00:51:39 <MatrixFrog> Quantumplation sounds good to me
00:51:54 * MatrixFrog runs off to google the Thrackle problem
00:52:34 <MatrixFrog> ugh i hate wikipedia math articles. literally in the first sentence there are two things i have to look up
00:52:47 <MatrixFrog> and the articles for each of those will probably have at least another two things
00:53:23 <MatrixFrog> i think understanding this article will be an O(e^n) operation
00:54:52 <Quantumplation> MatrixFrog: Basically, here's the quick version.  Let "Interaction" be defined as two edges sharing a common vertex, or intersecting.  A thrackle is a graph which every edge interacts with every other edge *exactly* once.
00:55:14 <Quantumplation> Conway said that there can never be more edges than vertices in a thrackle, but noone can prove/disprove this.
00:56:00 <MatrixFrog> ok so the example on the wikipedia page has 6 vertices and 6 edges
00:56:22 <MatrixFrog> so if you could somehow add a 7th edge, and make it still satisfy the property, you'd have disproved the conjecture
00:56:27 <Quantumplation> right
00:57:06 <Quantumplation> Mind if I PM you with a bit more detail?
00:57:21 <MatrixFrog> every thrackle is a pseudoforest, sounds very lewis carroll to me
00:57:35 <MatrixFrog> i mean, i don't expect that i'd be able to help much with the mathematical understanding
00:57:42 <MatrixFrog> and quite likely, not with the haskell either, tbh :P
00:58:37 <Quantumplation> hehe, Thrackles are actually very easy to understand.  People have just attached all these complicated terminology to them.  I've been working on the problem for about 6 months now, on and off, exploring their different properties and whatnot.
00:59:14 <MatrixFrog> when was this first conjectured?
00:59:21 <Quantumplation> 45 years ago or so
01:00:08 <MatrixFrog> for some reason, when a math problem goes unsolved for more than a few decades, it's so tempting to think "well, all those OTHER mathematicians were probably just not looking at it the right way. i bet if i stared at it for a little while i could come up with a really SIMPLE proof. now let's see..."
01:00:17 <MatrixFrog> *several hours later*
01:00:31 <MatrixFrog> "wait, but what if... no. hm, damn it. wait i got it! oh no that doesn't work either"
01:00:59 <Quantumplation> heh, yea.  Actually, I started a group called the Open Problem Society, first at MIT and now here at NYU Poly
01:01:15 <MatrixFrog> nice
01:01:25 <MatrixFrog> anyway i would check if there's anything that's already been done in haskell wrt graphs. just googling "graph haskell" turns up a few things...
01:01:29 <MatrixFrog> and maybe build off of one of those
01:01:50 <Quantumplation> where, the idea is to work on unsolved problems.  Not particularly to SOLVE them, but because doing so very directly takes the emphasis off the solution or even success, and places the emphasis on the *process*, and just "fucking around" with math.  "what happens if I do this? I wonder if this is always true", etc.
01:02:02 <Quantumplation> which is kind of an experimental run for how I think math education should *really* be.
01:02:51 <Quantumplation> MatrixFrog: Yea, I thought about that, but that takes all the fun out of it ;) I could code it in a couple of hours with some existing libraries in C#, but part of it is that this is just for fun anyway, so I want the experience of writing something *real* in haskell.
01:03:25 <MatrixFrog> true
01:03:43 <MatrixFrog> that's awesome
01:06:38 <erus`> "fucking around with math"
01:06:55 <erus`> A sentence i never thought i would hear
01:06:58 <Quantumplation> haha
01:08:21 <anandjeyahar> Qunatumplation: "fucking around with math" My favourite quote in a couple of years :-)
01:08:49 <MatrixFrog> @quote Qunatumplation "fucking around with math"
01:08:50 <lambdabot> No quotes for this person.
01:09:21 <Quantumplation> It's been wildly successful so far.  Back in march we solved this relatively obscure and irrelevant problem in architecture (more like, pointed out a flaw in this famous architects math, and then corrected it), wrote a paper on it, and it's now being used as required reading for an introduction to architecture course at Savannah College of Art and Design
01:09:30 <MatrixFrog> @remember Qunatumplation "fucking around with math"
01:09:30 <lambdabot> It is stored.
01:09:38 <MatrixFrog> @quote Qunatumplation
01:09:38 <lambdabot> Qunatumplation says: "fucking around with math"
01:09:42 <MatrixFrog> there we go
01:09:51 <anandjeyahar> Quantumplation: W.R.T Conway's conjecture: How's an edge intersecting another defined mathematically?
01:10:36 <erus`> Quantumplation: what is your IQ?
01:12:18 <sbrg> MatrixFrog: you wrote his name wrong
01:12:54 <quicksilver> lambdabot is never wrong
01:13:00 <quicksilver> it must be Quantumplation who is using the wrong nick.
01:13:07 <Quantumplation> Probably gunna screw up some of the terminology here, but an embedding of a graph defines a mapping of vertex v of the graph G to single points in the plane, and the edge e of graph G as jordan arcs (continuous, unbroken curves)...
01:13:12 <sbrg> lambdabot = chuck norris?
01:13:47 <Quantumplation>  in the plane such that if e and v are adjacent, they share exactly one point at the boundaries of the edge, and two edges are said to intersect if they share exactly one interior point and in the small neighborhood of the intersection one edge passes from one side of the other line to the other side of said line.
01:14:01 <Quantumplation> um, as to my IQ, no idea.
01:14:39 <Quantumplation> so no tricky business with tangential intersections, anandjeyahar ;)
01:15:51 <anandjeyahar> Quantumplation:Thanks. was running around wikipedia pages to get that
01:16:47 <Quantumplation> but like, I've discovered this nifty property of thrackles: Their linegraph and their intersection graphs are always complementary (when you look at it, that's almost the definition of a thrackle).  Likewise, it's known that a thrackle which violates conways conjecture would take one of three forms, called the bowtie, dumbbell, and theta graphs.
01:17:01 <Quantumplation> if you take the linegraphs of each of those three forms, i've identified a pattern that shows up in all three of them
01:17:03 <Quantumplation> which is kind of exciting
01:18:04 <Quantumplation> Much of my work is very unformal (mostly self taught), so I don't know how to formalize my arguments yet, and I'm probably retracing the steps of other people who have published thrackle papers, but it's still fun, so I don't care. =P
01:18:09 <Quantumplation> informal*
01:18:52 <anandjeyahar> Quantumplation: Ok the last part went out of my head. now i have to look up linegraph. :-) i guess intersection graph is one with all intersecting edges.
01:19:09 <Quantumplation> basically, think of it this way
01:19:11 <Quantumplation> draw a thrackle
01:19:24 <Quantumplation> now, make a new graph, and for each edge on the thrackle, there will be a point
01:19:27 <Quantumplation> (vertex)
01:19:39 <Quantumplation> now, connect the two vertices if the two edges share a common endpoint
01:19:51 <Quantumplation> that's the linegraph, and it's like the "adjacency" data for a graph
01:20:13 <Quantumplation> now, an intersection graph is essentially the opposite: only connect edges if they intersect
01:20:23 <anandjeyahar> Yeah..it's adjacency data ..visual rep..
01:20:52 <Quantumplation> i showed that they're perfectly complementary, meaning the proper union of each is a complete graph (every vertex connected to every other vertex)
01:21:17 <Quantumplation> which is kind of obvious, since the definition of a thrackle is that every edge just either share a common endpoint OR intersect with every other edge, but not both
01:21:20 <anandjeyahar> Yeah i got that part... just trying to imagine a violation of conway's conjecture
01:21:23 <anandjeyahar> and having trouble
01:21:23 <Quantumplation> but it's still cool to draw that parallel
01:21:58 <Quantumplation> #Thrackles
01:29:17 * hackagebot cabalvchk 0.2 - Verify installed package version against user-specified constraints.  http://hackage.haskell.org/package/cabalvchk-0.2 (KevinQuick)
01:50:12 <erus`> @hoogle [m a] -> m a
01:50:13 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
01:50:13 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
01:50:13 <lambdabot> Data.IntMap unions :: [IntMap a] -> IntMap a
01:50:36 <erus`> @hoogle [m a] -> m [a]
01:50:36 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
01:50:37 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
01:50:37 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
01:50:56 <erus`> > sequence [Just 1, Just 2]
01:50:57 <lambdabot>   Just [1,2]
01:51:01 <erus`> > sequence [Just 1, Just 2, Nothing]
01:51:02 <lambdabot>   Nothing
01:51:06 <cicatristeza> why is called pointfree if it does have points?
01:51:20 <quicksilver> cicatristeza: the 'points' are the named individuals
01:51:32 <quicksilver> map (\x -> x+1) [1,2,3] --- the point is 'x'
01:51:35 <erus`> "because fuck you"
01:51:44 <quicksilver> erus`: not appropriate
01:53:46 <JoeyA> Should be "because . ****"
01:53:51 <cicatristeza> is erus` a bot?
01:54:17 <erus`> how do you feel about is erus` a bot?
01:55:12 <erus`> (eliza... anyone?)
01:56:06 <quicksilver> cicatristeza: nope
02:02:11 <MHD> I find it moderately difficult to model a stack based language in the haskell LLVM api
02:02:52 <MHD> I typecheck it separately, so ideally I would like to keep a stack of Value types around for manipulation.
02:03:10 <MHD> Actually, it is more of a concatenative lanugage.
02:03:33 <shachaf> Is there a way to hide a Prelude symbol in ghci?
02:04:16 <MHD> There is technically no dynamic stack manipulation, it is purely an isomorphism for the LLVM register machine.
02:04:40 <MHD> shachaf: you know you can do import statements?
02:04:53 <shachaf> MHD: Right. Is there a way to make it work?
02:05:27 <MHD> shachaf: import Prelude hiding (iDontWantThisSymbol)
02:05:36 <shachaf> MHD: Does that actually work for you?
02:06:24 <MHD> shachaf: ... no. not it doesn't.
02:06:45 <MHD> s/not/no/
02:14:46 <yitz> shachaf: you can shadow it using let
02:15:05 <shachaf> yitz: That's true... But then :i won't tell me where it came from.
02:15:19 <shachaf> I just want to use Control.Exception.catch instead of Prelude.catch in my .ghci.
02:15:28 <erus`> import Prelude hiding (..) worked for me
02:15:47 <erus`> or maybe it was excluding or soething
02:15:53 <erus`> i did it a little while ago
02:16:33 <shachaf> erus`: Does that syntax even work in ghci?
02:16:55 <erus`> oh sorry that was in ghc
02:20:25 <yitz> shachaf: the syntax does work in ghci. but since there was already an implicit import Prelude without hiding, it doesn't help in this case.
02:20:55 <shachaf> yitz: Doesn't work for me.
02:21:01 <yitz> ?
02:21:08 <shachaf> The (..) bit.
02:21:16 <shachaf> I also tried -XNoImplicitPrelude and that didn't work.
02:21:19 <yitz> ah
02:26:29 <erus`> @hoogle (a -> Bool) -> [a] -> Int
02:26:29 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
02:26:29 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
02:26:30 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
02:30:38 <erus`> @hlint length $ takeWhile
02:30:39 <lambdabot> No module "length $ takeWhile" loaded
02:34:48 <absence> any news on platform 2011.4? the july date mentioned on the download page seems to have slipped :)
02:35:53 <shachaf> absence: No, It Will Be Released On That Date. Do Not Question The Download Page.
02:36:08 <WeiCheng> Hello.
02:36:30 <shachaf> WeiCheng: Greetings.
02:36:33 <WeiCheng> I have a question about GHC document.
02:36:54 <WeiCheng> In http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/Control-Concurrent.html
02:37:22 <absence> shachaf: right :D
02:37:24 <WeiCheng> It is still written: "whereas on Unix systems all the currently blocked I/O requests are managed by a single thread (the IO manager thread) using select."
02:37:50 <WeiCheng> Is it should be using "epoll" after 6.13?
02:38:27 <shachaf> Well, presumably it doesn't use epoll on all UNIX systems. :-)
02:38:40 <mux> epoll is not available everywhere; IIRC the new GHC I/O manager uses libevent2, which will appropriately use epoll/kqueue/whatever depending on the system
02:40:14 <absence> where can i find 2011.odd.0.x releases btw?
02:40:24 <WeiCheng> Ok. Then may the document needs to be updated to " using epoll/kequeue/select depends on the platforms".
02:40:28 <shachaf> absence: I don't think there are odd releases.
02:41:02 <shachaf> Maybe.
02:41:10 <WeiCheng> May I ask how to issue a ticket for the GHC  document?
02:41:23 <shachaf> @bug
02:41:23 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
02:41:38 <WeiCheng> @bug
02:41:39 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
02:43:22 <WeiCheng> Oops, I have no account and registering an account needs an accound first. :)
02:44:22 <absence> shachaf: they're supposed to be testing releases. do you mean they're not packaged into a release and have to be fished out of source control instead?
02:44:37 <shachaf> absence: Oh, I see. I don't know.
02:45:25 <erus`> coudl someone help me with monads please? :)
02:46:02 <int-e> WeiCheng: http://hackage.haskell.org/trac/ghc/wiki/ReportABug has a working account
02:46:31 <hpaste_> erus` pasted “error” at http://hpaste.org/52453
02:47:09 * int-e wonders why one needs an account to register though.
02:48:47 <erus`> ouch my brain
02:48:54 <int-e> WeiCheng: perhaps the 'register' link at the top is too easy to miss?
02:51:30 <erus`> how do i do a monad operation inside another monad?
02:51:42 <erus`> if it fails return Nothing
02:54:57 <erus`> how do you guys work with Maybe (m a) ?
02:55:34 <shachaf> The same way we work with Maybe b
02:56:01 <Botje> what's the difference between Nothing and Just (Left ...) ?
02:56:26 <int-e> erus`: unfoldr is really the wrong thing to use -- note that in its type, (b -> Maybe (a, b)) -> b -> [a], the result has no 'b' -- so you'll not be able to access the remaining string.
02:57:44 <int-e> erus`: then you use 'sequence' on [Either _ _] inside a Maybe computation ... and match the result (which would be a list) against a pair. But I think these are just follow-up mistakes of trying to make unfoldr work.
02:58:22 <erus`> bummer
02:58:47 <JoeyA> Neat, today's 20111011
02:58:57 <int-e> wait another month...
02:59:44 <JoeyA> Insensitive!  Some folks might not live that long.
03:04:02 <WeiCheng> Gave up issuing bug in GHC trac. It's too difficult. Logged in as 'guest' and found out 'guest' does not have privilege only after finish all the writing and press "create ticket".
03:04:08 <int-e> True. OTOH, I suppose we all missed the great 1111-11-11 day, and will miss the 2111-11-11 one.
03:04:35 <JoeyA> <God> Insensitive!
03:05:08 <JoeyA> WeiCheng: Go install the Lazarus plugin.  Now.
03:05:44 <JoeyA> http://superuser.com/questions/236390/how-do-i-recover-a-form-in-firefox-without-installing-a-plugin
03:06:41 <JoeyA> (if the process is still open, you could attempt to get a core dump and recover the text you wrote by searching the binary)
03:06:44 <JoeyA> ...
03:07:40 <sbrg> JoeyA: lol.
03:09:18 * hackagebot authenticate 0.10.2.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.10.2.2 (MichaelSnoyman)
03:09:20 * hackagebot http-enumerator 0.7.1.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.1.1 (MichaelSnoyman)
03:16:39 * int-e cannot reproduce WeiCheng's problem. ( http://hackage.haskell.org/trac/ghc/ticket/5547 )
03:17:33 <incluye> > 62 ^ 11
03:17:34 <lambdabot>   52036560683837093888
03:35:14 <JoeyA> Is there a library in hackage for simple wildcard matching?
03:35:20 <cao> quick question: does one of haskells' web frameworks (snap,yesod,happstack etc) support ssl client certificate authentication?  any1 a clue?
03:38:06 <yitz> JoeyA: what kind of wildcard matching?
03:38:33 <JoeyA> In a string: * means match zero or more of any character, ? means match one or more character.
03:38:45 <JoeyA> It's easy enough to implement; I'm just wondering if there's already a package for it.
03:38:52 <yitz> cao: if no one here can answer at the moment, the best place to ask is on the haskell web-devel mailing list
03:39:16 <JoeyA> (I might implement one as Data.ByteString.Wildcard)
03:39:33 <JoeyA> Or should it be Data.Wildcard.ByteString ?
03:39:44 <robert[]> I PROVED IT
03:39:45 <Jafet> Text.Glob
03:39:56 <yitz> JoeyA: well that only makes sense within some parsing framework
03:40:04 <JoeyA> robert[], Are they equal?
03:40:13 <robert[]> which
03:40:58 <yitz> JoeyA: if you're just parsing using raw Text/String/ByteString functions, then * is called "dropWhile"
03:41:00 <JoeyA> yitz: I'm thinking a simple match :: ByteString -> ByteString -> Bool function, where the wildcard is user-supplied.
03:41:16 <cwl> how to remove *un-needed* import
03:41:23 <cwl> just like eclipse do for java
03:41:28 <robert[]> I have new insights into de btuijn dincedx
03:41:29 <quicksilver> cwl: run ghc with -Wall
03:41:35 <robert[]> I will prepare a document for you
03:41:40 <quicksilver> although I'm not sure it works perfectly.
03:41:40 <cwl> quicksilver: thanks
03:41:56 <JoeyA> Showing results for de bruijn index.
03:41:59 <quicksilver> (or just -fwarn-unneeded-imports but I haven't checked the spelling of that option; it's in the manual)
03:42:03 <robert[]> yes
03:42:18 <yitz> JoeyA: if you are doing that old crusty form of parsing called "regular expressions", then yes, there are several libraries
03:43:07 <yitz> JoeyA: in many more modern parsing combinator libraries, the equivalent of "*" would be "many".
03:43:11 <quicksilver> http://hackage.haskell.org/package/Glob-0.5
03:43:37 <yitz> quicksilver: ah right - there's another kind of "*"
03:43:56 <quicksilver> yes, JoeyA is talking about simple globbing, not regexps
03:44:00 <yitz> oh ok
03:44:02 <JoeyA> right
03:44:07 <quicksilver> if you're using them for parsing, don't ;)
03:44:10 <JoeyA> and user-supplied globs
03:44:15 <quicksilver> if you're using them for user-supplied matching, sure.
03:44:30 <quicksilver> although regexps might be better(?)
03:46:46 <JoeyA> I think I'll just roll my own globber.  I'm not globbing file paths.
03:49:38 <nabster> hello people
03:52:10 <hirsch_> Is there an Repa expert here?
04:02:18 <kmc> hi nabster
04:02:28 <kmc> hirsch_, I'm not, but you should probably just ask your question
04:05:58 <hirsch_> kmc: I want to calculate an Integral Image where each Pixel is the sum of the Pixels of the rectangle from the origin to the pixel. How can I calculate something like that in a pure language efficiently without resumming the rectangle at every pixel?
04:06:45 <hirsch_> In other words: how can I access the previous results?
04:06:58 <kmc> *nod*
04:07:23 <kmc> that's not really a problem of purity, but of wanting parallel computation
04:08:07 <kmc> it's not hard to do sequentially as a pure function
04:08:24 <ClaudiusMaximus> does Repa not have an efficient parallel scan?
04:10:20 <hirsch_> I haven't found it, but I must confess I'm a haskell and Repa noob
04:11:28 <hpaste_> erus` pasted “How can i improve” at http://hpaste.org/52455
04:11:37 <erus`> am I missing a common pattern there?
04:12:04 <t3t> hi
04:12:31 <kmc> erus`, where do you think you might be
04:12:32 <kmc> hi t3t
04:12:46 <t3t> kmc
04:12:51 <erus`> i remember using an unfold last time
04:12:54 <kmc> erus`, i'm kind of suspicious of the type «([Line], [(Indent, [Token])])»
04:12:58 <t3t> u know how could i implement something like
04:13:07 <kmc> maybe you should define your own data type for that, or at least some synonyms
04:13:23 <t3t> for(int i = 1 ; i <= m ; i ++)  		f[1][i] = 1 ;
04:13:29 <t3t> in haskell
04:13:31 <t3t> using array
04:13:51 <Axman6> we don't use arrays vert often in haskell
04:14:00 <Axman6> so you probably don't want to do that
04:14:11 <Axman6> > replicate 10 1
04:14:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
04:14:12 <kmc> don't try to write C in Haskell
04:14:28 <kmc> (not by default anyway)
04:14:36 <t3t> mmm
04:14:45 <kmc> erus`, you have «(li, ts) = l»; I'd move that to where you match l
04:14:54 <kmc> you also use (snd l) which shouldn't be necessary then
04:15:03 <Axman6> t3t: when learning haskell, you'll have to forget a lot of what you already know about programming in imperative languages
04:15:37 <quicksilver> forM_ [1..m] $ writeArray f (1,i) 1
04:15:43 <t3t> the thing is that i need to create like a table to fill it with results from loops
04:15:55 <quicksilver> t3t: Axman6 and kmc are right, stylistically. I doubt arrays are the right way.
04:16:00 <kmc> t3t, you probably don't
04:16:14 <t3t> how about something like this:
04:16:14 <quicksilver> but if you just want to understand how C concepts relate, it's similar (but shorter) in haskell
04:16:15 <t3t> for(int i = 2 ; i <= n ;i ++ ) 	{ 		for(int j = 1 ; j <= m ; j ++) 		{ 			for(int k = 1 ; k <= j / 2 ; k ++) 				f[i][j] += f[i-1][k] ; 		} 	}
04:16:28 <kmc> t3t, is there some reason imperative programming and destructive update are the right tools for this problem?
04:16:31 <t3t> thats what im trying
04:16:34 <kmc> t3t, how are you learning Haskell?
04:16:40 <ClaudiusMaximus> hirsch_: i couldn't find it either (just looked briefly, there is fold but no scan...)
04:17:07 <t3t> vi learn http://learnyouahaskell.com/
04:17:13 <kmc> ok
04:17:15 <kmc> how far are you?
04:18:11 <t3t> not much,
04:18:20 <Jafet> hirsch, it's fairly easy to do that to a (pure!) Array: \a -> let a' = array [ if i == 0 then a ! 0 else a' ! (i-1) + a ! i | i <- [0..n] ]
04:18:37 <Jafet> That's in one dimension, but it illustrates laziness
04:18:56 <t3t> i see
04:19:06 <kmc> t3t, maybe you should keep reading then
04:19:06 <hirsch_> ClaudiusMaximus: Yes, perhaps it can be implemented with little effort, I'll look at it
04:19:18 <t3t> :(
04:19:47 <kmc> t3t, solving problems in Haskell requires a different way of thinking; you can't just write the code in C and then translate it
04:20:04 <kmc> that's why Haskell is hard to learn, and also why it's rewarding
04:20:41 <hirsch_> Jafet: ok, I'll try it out
04:20:51 <Jafet> kmc: you're trying too hard; just talk about spreadsheets
04:20:58 <kmc> haha
04:21:42 <erus`> once everyone starts using haskell i wont use it anymore, i'll move to some other lesser known language :)
04:21:52 <kmc> yeah
04:22:07 <Nimatek> erus`: Don't worry, that will never happen.
04:22:10 <kmc> Agda
04:22:19 <Axman6> erus`: quantum C?
04:22:31 <Jafet> C is already unpredictable.
04:22:47 <Axman6> Nimatek: maybe not haskell itself, but something similar
04:22:59 <Axman6> Jafet: but now it's a feature
04:23:09 <Jafet> It's already a feature!
04:23:09 <Axman6> it's like Java2000
04:23:18 <erus`> using pre-increment in C is like quantum computation
04:23:37 <Axman6> not post increment?
04:23:57 <erus`> i forget which one
04:24:00 <Axman6> i thought preincrement was easier to get right than post
04:26:37 <Guest29051> how to check if a charactor is printable or not ?
04:27:04 <Guest29051> isprint like in c
04:27:59 <yitz> Guest29051: characters in Haskel are Unicode characters
04:28:20 <erus`> tz s >>= return . (,) i     <- is that readable?
04:28:25 <yitz> Guest29051: look at the functions in Data.Char and see if any of them are helpful to you
04:28:36 <Axman6> erus`: barely
04:28:42 <Guest29051> yitz: thank you
04:28:53 <Axman6> @hoogle isPrint
04:28:54 <lambdabot> Data.Char isPrint :: Char -> Bool
04:29:01 <Axman6> > isPrint 'a'
04:29:02 <lambdabot>   True
04:29:07 <Axman6> > isPrint '\NUL'
04:29:08 <lambdabot>   False
04:29:13 * Axman6 wins
04:29:21 <yitz> Axman6++
04:29:38 <Axman6> we've just talked about this, ++Axman6 is usually better :P
04:29:55 <Axman6> > isPrint '\n'
04:29:55 <lambdabot>   False
04:30:00 <Axman6> hmm
04:30:15 <Twey> \n is kind of printable…
04:30:23 <Axman6> yeah, that's what i thought
04:30:28 <quicksilver> erus`: >>= return is fmap (or liftM)
04:30:43 <Axman6> though, i guess it's more of a character that causes an action than get printed
04:30:49 <yitz> Axman6: oh noes using lambdabot requires knowledge of C style best practices
04:30:55 <Twey> You mean, a control character?  :þ
04:30:56 <quicksilver> erus`: try "(,) i `liftM` tz s" or "(,) i <$> tz s"
04:30:59 <Twey> Yeah, I suppose so
04:31:16 <quicksilver> GHC lets you do "(i,) <$> tz s"
04:31:23 <Twey> … beat me to it
04:31:32 <yitz> > map isPrint ['\127'..'\160']
04:31:33 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
04:31:33 <erus`> ah cool
04:31:43 <yitz> @more
04:31:54 <Axman6> > filter isPrint [minBound..]
04:31:55 <lambdabot>   " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg...
04:32:01 <Twey> > any isPrint ['\127' .. '\160']
04:32:02 <lambdabot>   True
04:32:05 <Axman6> > filter (not.isPrint) [minBound..]
04:32:07 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
04:32:31 <yitz> > dropWhile (not . isPrint) ['\127'..'\160']
04:32:33 <lambdabot>   "\160"
04:32:33 <Axman6> > text $ filter (not.isPrint) [minBound..]
04:32:42 <Axman6> >_>
04:32:57 <yitz> @vixen oh oh - are you still there?
04:32:57 <lambdabot> Don't try to take on a new personality; it doesn't work.
04:33:01 <Axman6> hello?
04:33:02 <yitz> whew
04:33:05 <Axman6> :|
04:33:25 <Axman6> > text $ take 10 $ filter (not.isPrint) [minBound..]
04:33:47 <yitz> Axman6: try it without "not"
04:33:57 <Axman6> ah, i guess it probably does a filter isPrint, and doesn't show anything if the thing to print is empty
04:34:02 <Axman6> > text $ take 10 $ filter (isPrint) [minBound..]
04:34:03 <lambdabot>    !"#$%&'()
04:34:10 <Axman6> > text $ filter (isPrint) [minBound..]
04:34:11 <lambdabot>    !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghij...
04:34:18 <quicksilver> or is it just that NULs are not permissable in IRC?
04:34:26 <Axman6> i love that ^_` in there
04:34:38 <quicksilver> > text "A\NULB"
04:34:38 <lambdabot>   AB
04:34:41 <quicksilver> interesting.
04:34:53 <Axman6> > text $ take 10 $ filter (not . isPrint) [succ minBound..]
04:35:21 <Axman6> i always found it odd that ACK was an acssi character
04:35:29 <yitz> > text "\7"
04:36:30 <erus`> let a | True = 123 in a
04:36:32 <yitz> > length . filter (not . isPrint) $ [minBound..]
04:36:33 <erus`> > let a | True = 123 in a
04:36:34 <lambdabot>   1013605
04:36:34 <lambdabot>   123
04:36:51 <yitz> > length . filter isPrint $ [minBound..]
04:36:53 <lambdabot>   100507
04:37:01 <yitz> interesting, about half and half
04:37:03 <RichardBarrell> > toEnum 0 : "foo"
04:37:04 <lambdabot>   "\NULfoo"
04:37:13 <yitz> oh wait
04:37:32 <yitz> there are ten times as many non-printable as printable?
04:37:57 <Guest29051> i am trying to read pcap file but i am getting Readfile: network.pcap: hGetLine: invalid argument (invalid byte sequence)
04:37:58 <yitz> > maxBound :: Char
04:37:59 <lambdabot>   '\1114111'
04:38:33 <Axman6> > length . filter isPrint $ [minBound..]
04:38:35 <lambdabot>   100507
04:38:42 <Axman6> > length . filter (not . isPrint) $ [minBound..]
04:38:44 <lambdabot>   1013605
04:39:22 <yitz> > (/ log 2) . log . fromIntegral $ (maxBound :: Char)
04:39:23 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
04:39:23 <lambdabot>    arising from a use of...
04:39:24 <Axman6> Guest29051: hmm, i don't think a pcap library should be using text IO.
04:39:36 <yitz> > (/ log 2) . log . fromIntegral . fromEnum $ (maxBound :: Char)
04:39:37 <lambdabot>   20.087461546321563
04:39:49 <Guest29051> Axman6: so how can i read it ?
04:40:43 <Axman6> Guest29051: i'm not sure, that error seems like a pretty stupid bug in the pcap library. maybe you should email the author and ask why they're not using ByteStrings
04:40:43 <Guest29051> Axman6: i am just looking for Data in it . It working fine with wireshark but when i am trying with haskell no success
04:41:21 <Axman6> Guest29051: what exactly are you doing?
04:41:27 <Axman6> can you share the code?
04:41:52 <hpaste_> arvind pasted “reading pcap ” at http://hpaste.org/52456
04:42:06 <Axman6> thanks
04:42:10 <erus`> how do i check if read worked?
04:42:25 <Guest29051> Axman6: i am trying to read the data in the pcap file
04:42:28 <ClaudiusMaximus> erus`: use reads
04:42:43 <Axman6> Guest29051: you need to use binary IO, you can't use strings to do this.
04:42:54 <Axman6> it's not hard though
04:43:03 <Guest29051> Axman6: thank you
04:43:14 <Axman6> :t openFile
04:43:14 <lambdabot> Not in scope: `openFile'
04:43:19 <Axman6> bah
04:43:25 <Axman6> @hoogle openFile
04:43:25 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
04:44:46 <quicksilver> openBinaryFile
04:45:06 <quicksilver> you can keep using Chars if you want to, but it is probably more sensible to use bytestrings
04:45:08 <Guest29051> @hoogle openBinaryFile
04:45:08 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
04:45:15 <quicksilver> I don't know what the format for pcap files is
04:46:36 <yitz> > [length $ filter (not . isPrint) [toEnum x..toEnum y] | x <- [0,2^17..2^20], let y=x+2^17-1]
04:46:37 <lambdabot>   [74058,87819,131072,131072,131072,131072,131072,130832,*Exception: Prelude....
04:46:51 <Axman6> if you use bytestrings, then fun = BS.filter (isAscii . fromIntegral) i think
04:51:08 <tijn_> @t3t : I think you might want to use a map, as from Data.Map
04:51:08 <lambdabot> Maybe you meant: ft let thx
04:51:15 <tijn_> http://haskell.org/ghc/docs/latest/html/libraries/containers-0.4.1.0/Data-Map.html#g:4
04:51:48 <tijn_> book.realworldhaskell.org/read/data-structures.html
04:57:42 <t3t> \a ->
05:02:56 <kmc> erus`, http://haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
05:03:38 <erus`> yeah thats how i matched it :)
05:03:40 <erus`> good stuff
05:10:38 <erus`> i love the inference with reads
05:10:45 <erus`> very very useful
05:11:03 <mekeor> erus`: what's very very useful?
05:11:46 <erus`> I have a single 'Number' type (which is currently double), i have i have to change this to Integer or whatever at some point i will not have to re-write anything
05:12:30 <erus`> i have i = if i
05:12:58 <erus`> 'reads' the function btw
05:22:36 <hpaste_> obi pasted “rewrite bind to use where” at http://hpaste.org/52457
05:25:27 <bear_> hello everyone i was wondering if someone here knows how to make a prefix tree in haskell
05:26:07 <Axman6> is that another name for a ternary tree?
05:26:55 <shachaf> Axman6: Isn't a ternary tree just a tree where nodes have three children?
05:27:21 <shachaf> bear_: It's very likely that someone here does.
05:27:35 <bear_> its more like http://en.wikipedia.org/wiki/Trie
05:27:48 <shachaf> It's, in fact, exactly like http://en.wikipedia.org/wiki/Trie . :-)
05:27:51 <Axman6> well, i guess. when I first learnt to use them, they were referred as ternary trees, but i later learnt they're often referred to as tries
05:28:10 <Axman6> i have a package on hackage implementing them bear_ :P
05:28:37 <mux> well I'm not sure if ternary trees are indeed trees with 3 children, but I'm quite sure that description doesn't match either tries or prefix trees
05:28:38 <shachaf> They're a popular thing to implement.
05:29:00 <Axman6> according to one paper that used them as a comparison for benchmarking, they're pretty fast... at the operations i bothered to implement (no delete I think)
05:29:10 <bear_> well its for my school assignment  but  i have hard time grasping the code to make such tree
05:29:19 <mux> tries and prefix trees are the same thing
05:29:29 <mux> and you have a ByteString implementation on hackage, called bytestring-trie
05:29:47 <dmwit_> There are several implementations on Hackage.
05:29:47 <Axman6> bear_: do you have a data type defined yet?
05:29:54 <shachaf> bear_: Presumably that makes it a good exercise.
05:29:57 <Axman6> data PrefixTree a = ...?
05:30:29 <bear_> well keys are suppose t obe strings
05:30:42 <mux> nope, integral sequences
05:30:57 <mux> they're also used to store IP addresses for instance
05:31:29 <dmwit> Oh, hush. If he wants to specialize to String for his assignment, why not let him?
05:31:58 <mux> I understood what he said as "tries always have strings as keys" so that's why I made that comment
05:32:10 <mux> obviously I'm not suggesting him to go around his assignment
05:32:13 <bear_> the assignment says it has to be strings
05:32:13 <shachaf> According to mux, type PrefixTree = [∫]
05:32:28 <dmwit> haha
05:32:44 <mux> heh
05:33:05 <mux> integer sequences, sorry
05:34:35 <bear_> hmm ok
05:35:23 <Axman6> bear_: well, start with the obvious thing: a constructor that has three branches, data PrefixTree a = Branch ... (PrefixTree a) (PrefixTree a) (PrefixTree a)
05:35:55 <dmwit> Axman6: That doesn't seem obvious to me.
05:35:57 <shachaf> Axman6: What is it with you and ternary?
05:36:01 <Axman6> mux: why integer? anything that implements Ord can be used in a prefix tree if you have a list of them
05:36:04 <mux> Axman6: you're not describing tries
05:36:14 <mux> you're describing ternary search tries
05:36:31 <Axman6> :\
05:36:40 <Axman6> i guess i'll just shut up then
05:36:50 <dmwit> bear_: What have you got so far?
05:40:05 <bear_> the assignment says i have to create a prefix tree with 3 keys( they suppsoe to be strings) with values,  the 3 keys are (foo 42, bar 42, baz 43) the values can change ofc
05:40:16 <bear_> so far...nothing :(
05:40:33 <erus`> how do i catch an error in 'readFile'  ?
05:40:36 <dmwit> Well, do you know what a prefix tree is?
05:40:44 <dmwit> ?hoogle catch
05:40:44 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
05:40:44 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
05:40:44 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
05:41:06 <shachaf> Well, readFile does evilazy I/O, so it might be a bit trickier.
05:41:20 <dmwit> o right
05:41:37 <erus`> hmm
05:42:05 <erus`> this is confusing
05:42:05 <dmwit> shachaf: Actually, the example in the docs for Control.Exceptions *is* readFile.
05:42:11 <dmwit> So... perhaps it's not trickier. =)
05:43:03 <shachaf> dmwit: Hmm, how does that work?
05:43:17 <shachaf> What if the file opens without a problem but later you get an error on reading?
05:43:23 <dmwit> shachaf: I think readFile probably opens the file immediately, and only the actual reading is lazy.
05:43:25 <obiwahn> any suggestions for my paste?
05:43:28 <dmwit> How would you get an error on reading?
05:43:52 <shachaf> I/O error on device?
05:44:00 <dmwit> mmm
05:44:08 <dmwit> Yeah, you probably wouldn't catch that. =)
05:44:18 <Axman6> > head . read $ "[1,2,sdkjsdf]" :: Int
05:44:19 <lambdabot>   *Exception: Prelude.read: no parse
05:44:20 <shachaf> The documentation should probably note that. :-)
05:44:26 <shachaf> Or it should just use a non-evil function.
05:44:35 <dmwit> obiwahn: What's your question about your paste?
05:45:05 <dmwit> shachaf: I would test it, except I don't know how to trigger an IO device error in any way that I actually want to do. =P
05:45:18 <obiwahn> how to rewrite the bind that it uses where instead of let
05:45:26 <Axman6> heh, so, the wikipedia article on tries gives the first code example in haskell
05:45:46 <obiwahn> it works with let butut i can not rewirte it to use where
05:45:51 <shachaf> dmwit: Oh, maybe not.
05:46:10 <shachaf> Oh, no, it seems like it.
05:46:24 <shachaf> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-IO-Handle-Text.html#lazyReadBuffered
05:46:27 <dmwit> obiwahn: where can't go in expressions
05:46:44 <dmwit> obiwahn: You can do something like this... one second
05:47:50 <hpaste_> dmwit annotated “rewrite bind to use where” with “rewrite bind to use where (annotation)” at http://hpaste.org/52457#a52458
05:48:45 <obiwahn> thaks:)
05:49:59 <shachaf> The GHC IO code is such a maze to figure out.
05:51:22 <Jafet> Sounds amazing.
05:52:06 <obiwahn> writing monads is so strange it took me so long to wirte that bit of coe:(
05:59:33 <absence> is there a library that just opens a window and renders a bitmap in it? sort of like what gloss and hgl do for vector graphics
06:04:35 <benmachine> absence: SDL does that
06:04:39 <benmachine> er, ish
06:04:42 <benmachine> probably
06:04:45 * benmachine not an expert
06:05:26 <mux> I'm no SDL export either but I suppose SDL + SDL_image could do that indeed
06:05:30 <mux> expert*
06:11:56 <absence> indeed, sdl does that, but with quite a bit more code overhead than i was hoping for
06:11:57 <dmwit> absence: spawn "feh bitmap.png"
06:12:12 <dmwit> Why reinvent the world? =)
06:12:32 <absence> dmwit: i'd have to write the generated bitmap to disk first then ;)
06:12:52 <dmwit> writeFile bitmap "bitmap.png" >> spawn "feh bitmap.png" -- still not so bad
06:13:03 <dmwit> err... with the arguments to writeFile swapped, of course
06:13:31 <absence> ignoring the details of the png file format, it's not so bad
06:13:47 <dmwit> Whatever bitmap library you're using surely has a write-to-file operation.
06:14:01 <absence> i'm not using one. i'm asking for one :D
06:14:24 * hackagebot geniplate 0.5.0.0 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.5.0.0 (LennartAugustsson)
06:14:46 <absence> and was hoping for something as simple as this: main = displayInWindow "My Window" (200, 200) (10, 10) white (Circle 80)
06:14:56 <dmwit> absence: There's about 30 on Hackage.
06:15:20 <yitz> absence: ah you don't even have the bitmap, you want to draw it from primitives?
06:15:29 <yitz> how about Gloss then
06:16:08 <dmwit> Yeah, or diagrams.
06:16:15 <dmwit> defaultMain :: Diagram Cairo R2 -> IO ()
06:16:16 <dmwit> done
06:16:29 <absence> yitz: that was a gloss example :) gloss is for vector graphics though, i'd like pixels that i can map over
06:17:01 <dmwit> absence: gd
06:17:28 <dmwit> ?hackage gd
06:17:28 <lambdabot> http://hackage.haskell.org/package/gd
06:18:06 <dmwit> But if you're *actually* mapping, then vector graphics seem superior to raster graphics.
06:18:08 <BobFunk> ugh - cabal can be hell sometimes :( seem to keep running into the "cannot satisfy -package Cabal-1.10.1.0: ..." errors, even with cabal-dev :(
06:18:47 <absence> dmwit: by mapping i mean the map function. that is, process each pixel
06:18:55 <dmwit> absence: Yes, I know what you mean.
06:19:01 <dmwit> absence: And I stand by my claim.
06:19:38 <absence> dmwit: so how would you implement e.g. a ray tracer wusing vector graphics?
06:20:10 <dmwit> If it's *not* actually a map -- e.g., if the function you are applying to the pixel does *not* depend only on the contents on the pixel (but also, say, on the position of the pixel), then I agree that vector graphics may not be the best choice.
06:21:09 <dmwit> I wouldn't even know how to implement a ray tracer using raster graphics. So ask a more focused question. =P
06:21:10 <absence> hm, that's true, position is needed
06:21:38 <absence> i'm not asking how to implement a ray tracer :) i just want to get some pixels to the screen
06:21:47 <dmwit> Use gd.
06:21:54 <absence> and external viewer?
06:22:08 <dmwit> Seems simplest.
06:22:22 <quicksilver> the simplest way for me to get pixels to the screen would be to use opengl
06:22:34 <quicksilver> that may not be simplest if you've not used opengl before, though
06:22:38 <quicksilver> there is a bit of a learning curve.
06:23:03 <dmwit> quicksilver: He actually wants pixels. Does OpenGL do that? (My understanding was that it abstracted away from pixels significantly.)
06:23:05 <absence> quicksilver: i have used opengl, and i would call that stretching the definition of "simple" to its breaking point :)
06:23:26 <quicksilver> dmwit: certainly it does. OpenGL is as much as pixel pushing as it is about 3D.
06:23:31 <absence> dmwit: you can upload pixel data to the frame buffer
06:23:35 <quicksilver> they are complementary features.
06:23:48 <quicksilver> absence: *shrug* if you have used it before, it's simple.
06:24:06 <absence> quicksilver: sdl is also simple. i was looking for a one-liner :)
06:24:16 <dmwit> Well, if you've used it before, gtk2hs or sdl are also simple for this task. =)
06:24:35 <absence> gd seems like a nice hack for something quick and dirty
06:24:58 <absence> or maybe not
06:25:01 <FAA> I'm going through the parsec documentation, having read the "Real World Haskell" chapter on it. I still don't get what a "GenParser" is :S
06:25:23 <absence> * Missing C libraries: gd, png, z, jpeg, fontconfig, freetype, expat
06:25:28 <absence> sometimes being on windows isn't so fun
06:26:45 <tnks> in general, I want to have only one instance for a type class, but I'm having a hard time justifying that for Show.
06:27:13 <tnks> is there  recommended pattern for having multiple instances of Show without abandoning the type class completely?
06:27:22 <quicksilver> abandong the type class completely.
06:27:39 <quicksilver> the *only point* of that type class is that there is a unique instance.
06:27:49 <quicksilver> just work with functions (a -> String)
06:27:59 <quicksilver> typeclasses are over-rated and over-used.
06:28:39 <tnks> quicksilver: hmm, is this a debated issue?
06:28:40 <dmwit> I'm confused.
06:28:55 <quicksilver> tnks: well, yes, people debate these things.
06:28:56 <tnks> or is it something Haskellers are converging to a consensus on?
06:28:57 <dmwit> "In general, I want to have only one instance for a type class." -- then why have a type class?
06:29:21 <quicksilver> we seldom achieve consensus on anything tnks.
06:29:22 <dmwit> "Is there a recommended pattern for having multiple instances of Show?" -- there's about thirty instances of Show just in the Prelude
06:29:35 <quicksilver> dmwit: (he means "per type")
06:29:46 <tnks> dmwit: sorry, I didn't mean instances.
06:29:55 <dmwit> quicksilver: ...aha
06:30:00 <quicksilver> in general there are too many people who disagree with quicksilver to achieve consensus.
06:30:30 <dmwit> I agree with quicksilver. If your function of type (Foo -> String) doesn't produce valid Haskell code, it shouldn't be the implementation of your Show instance.
06:30:36 <quicksilver> but the honest (non-rhetorical) question is - what is you goal? How does having multiple Show instances advance that goal?
06:30:53 <quicksilver> is having multiple Show instances somehow more convenient than functions (a -> String)
06:31:51 <tnks> quicksilver: I'm guessing it's about reuse with any functions that accept the Show type class.
06:32:12 <dmwit> you're _guessing_?
06:32:23 <dmwit> You don't even have a solid use case and you're complaining? =P
06:32:24 <quicksilver> tnks: yes, that would be a good answer
06:32:30 <quicksilver> but that's OK because there aren't any.
06:32:39 <quicksilver> there are no functions that use the Show type class [*]
06:32:54 <quicksilver> ([*] warning, the previous sentence may contain hyperbole or exagerration)
06:33:05 <tnks> quicksilver: interesting.
06:33:28 <quicksilver> normally Show instances are used by other Show instances (with the standard derivation)
06:33:35 <quicksilver> there are a few - like 'print' and so on
06:33:49 <quicksilver> but there is generally a version which just takes a String instead (putStrLn in that case)
06:34:08 <quicksilver> (or is it putStr? not important)
06:34:28 <dmwit> (it's putStrLn)
06:36:33 <tnks> quicksilver: okay, I see your point with Show.
06:36:43 <benmachine> quicksilver: I think there are quite a few library functions that use Show
06:37:03 <benmachine> e.g. QuickCheck uses it for error messages
06:37:09 <tnks> so if I revisit this issue, it will have to be with another typeclass and another use case.
06:37:21 <tnks> thanks.
06:37:29 <benmachine> tnks: the usual way of dealing with multiple instances is newtypes
06:37:41 <benmachine> but it's not the most convenient thing in the world
06:37:51 <quicksilver> or just not using the typeclass
06:37:58 <benmachine> heh
06:38:00 <quicksilver> because the typeclass was a stupid idea in the first place.
06:38:14 <tnks> benmachine: for Show, I think a simple conversion to a String is more appropriate.
06:38:16 <benmachine> quicksilver: are *any* typeclasses not a stupid idea? :)
06:38:30 <tnks> the other approach introduces unnecessary complexity, I think.
06:38:37 <quicksilver> benmachine: they're fine for overloading, certainly.
06:38:58 <erus`> I wrote my first  haskell program that writes a haskell program LD
06:39:02 <BobFunk> how do I start making sense of this? https://gist.github.com/1278108
06:39:02 <benmachine> quicksilver: does, e.g. WrappedMonad with an Applicative instance upset you?
06:39:03 <quicksilver> benmachine: the idea of a hierarchy of typeclasses for numeric operations is good. (Without venturing an opinion on how the hierarchy should be structured)
06:39:33 <quicksilver> Functor and Monad and Applicative are good typeclasses.
06:39:43 <quicksilver> there aren't many examples where there is more than one sensible instance
06:39:43 <BobFunk> my ap compiles locally on os x, but when I try to compile it on my build box to deploy, I run into that
06:39:46 <quicksilver> (yes I know of a couple)
06:40:01 <Peaker> quicksilver: Typeclasses are awesome, not overrated, but I agree they are often used inappropriately :)
06:40:22 <Peaker> (though IMO very underused -- by a hugely monomorphic standard library)
06:40:33 <benmachine> Peaker: maybe you are one of the people who overrates them :P
06:40:39 <quicksilver> he is
06:40:44 <quicksilver> but that's OK :)
06:40:45 <Peaker> or vice versa :)
06:40:50 <tnks> quicksilver: just to advance my understanding, what's an example of something where there's two sensible instances?
06:40:58 <quicksilver> tnks: Monoid, I suppose
06:41:15 <absence> cabal: cannot configure repa-2.1.1.6. It requires base ==4.4.* For the dependency on base ==4.4.* there are these packages: base-4.4.0.0. However none of them are available. base-4.4.0.0 was excluded because of the top level dependency base -any
06:41:18 <quicksilver> although Monoid doesn't come all that often in programming contexts.
06:41:20 <absence> what :s
06:41:30 <quicksilver> BobFunk: the machine you're trying to compile on has an inconsistent set of packages.
06:41:53 <quicksilver> BobFunk: I don't think I'm skilled enough in cabal fu to explain exactly what but you have two versions of the Cabal library and that's part of the problem
06:42:05 <benmachine> absence: I think that's cabal's awkward way of saying, I want to upgrade base but I can't
06:42:06 <quicksilver> (two versions which are both 10.0.1.0 versions)
06:42:09 <BobFunk> quicksilver: any hints on how to solve it?
06:42:09 <tnks> actually, I was reading the post on the ML about Monad being overused for do-sugar, when a Monoid would have been more appropriate.
06:42:36 <quicksilver> I would probably agree with that post, tnks :) I've certainly made that rant here from time to time.
06:42:50 <absence> benmachine: oh. that sucks. anything i can do about that?
06:43:01 <quicksilver> BobFunk: one answer might be to remove any "local" packages on that machine
06:43:13 <quicksilver> it's probably a local Cabal-10.0.1.0 conflicting with the "global" one
06:43:15 <benmachine> absence: base versions are tied to ghc versions, if you really need the newer base you'll have to get ghc 7.2
06:43:19 <quicksilver> "local" == "user", I mean.
06:43:39 <Peaker> I attribute virtually all of my Haskell pains to bad stdlibs: A) Unnecessary partiality  B) unnecessary monomorphism (painful conversion of lazy/strict BS, bah)  C) Various bad consequences of B (performance problems with String vs. difficulty of using Text), difficulty in switching to different data structures, etc.
06:44:27 <absence> benmachine: i don't supposer there's an easy way to install it in haskell platform? :)
06:44:33 <Peaker> when typeclasses are overused, the result is clumsy and maybe a bit inflexible.. When they are underused, the result is much worse
06:44:44 <benmachine> absence: I've never tried, never needed to... don't know either way, sorry
06:45:01 <absence> ok, thanks though
06:45:06 <kmc> Peaker, I think writing a good set of type classes to encompass all those different data structures is a very very hard problem
06:45:06 <quicksilver> repa versions are, I think, quite closely coupled to GHC versions
06:45:17 <kmc> however I'd love to see you (or anyone else) do it
06:45:28 <quicksilver> you probably have to find out which is the right version for your ghc and install that one
06:45:51 <kmc> it's a library problem; anyone can attack it
06:46:03 <Peaker> kmc: It seems the counter opinion though is that type-classes aren't useful for that at all -- and I don't understand that argument (I'd love to)
06:46:14 <kmc> whose opinion?
06:46:19 <kmc> I think type classes are useful for that
06:46:29 <kmc> i mean, that's what they were designed for
06:46:35 <kmc> using (+) for Int and Double
06:46:45 <kmc> the typeclass overuse I'm always complaining about is something different
06:46:50 <BobFunk> already started by nuking all global packages - guess I'll have to nuke everything on the machine and start over. A real pain tht it seems to be necesarry every other day with cabal :(
06:47:05 <kmc> using type classes to awkwardly emulate a Java OOP class hierarchy or something
06:47:17 <kmc> anyway the code (and design) speaks louder than words here
06:47:18 <quicksilver> Peaker: it would be interesting to see a good proposal
06:47:23 <kmc> I know there's a few alternative preludes already on Hackage
06:47:29 <kmc> does anyone have a good comparison writeup?
06:47:35 <quicksilver> the thing that strikes me is those various different libraries use different natural APIs
06:47:35 <benmachine> BobFunk: it's not necessary as such, it's just that the rules to avoid it are a little hard to work out or get used to
06:47:45 <kmc> I don't think this should be attacked as a language extension proposal committee thing
06:47:49 <benmachine> BobFunk: http://www.vex.net/~trebla/haskell/sicp.xhtml this may be helpful
06:47:51 <quicksilver> e.g. List's natural API is about (:) and take and drop
06:47:52 <kmc> I think you just write a library and upload it
06:47:55 <kmc> and then get people to use it
06:48:03 <BobFunk> quicksilver: thanks, checking
06:48:12 <quicksilver> while sequence's natural API is ! and update
06:48:23 <quicksilver> etc.
06:48:23 <absence> quicksilver: great, the previous version did the trick, thanks
06:48:27 <quicksilver> absence: :)
06:48:34 <benmachine> kmc: I think a better module system might make the problem easier to solve
06:48:37 <quicksilver> I'm not sure that abstracting over those details is the right approach.
06:48:48 <kmc> there's http://hackage.haskell.org/package/ClassyPrelude for example
06:49:06 <quicksilver> Peaker: I think the *real* problem about Text/String/ByteString is not really that we didn't have the right typeclasses in place
06:49:17 <benmachine> c
06:49:21 <benmachine> er, oops
06:49:27 <quicksilver> Peaker: it is that String was the Wrong Thing for many cases; it was replaced by ByteString which was Still Wrong But Faster
06:49:27 * benmachine hits return instead of delete
06:49:32 <kmc> also http://hackage.haskell.org/package/prelude-plus  -- looks like this gives you the Foldable / Traversable equivalents to list functions
06:49:45 <quicksilver> and finally by Text, which is the Right Thing (for certain use cases, at least)
06:49:52 <kmc> *nod* ByteString is in no way a replacement for String
06:49:57 <quicksilver> and then we have a bunch of libraries using different things
06:50:02 <kmc> (except that people were already mis-using String)
06:50:06 <quicksilver> many of which (not all) would just use Text if they'd be used first.
06:50:09 <quicksilver> kmc: exactly.
06:50:17 <quicksilver> s/used first/written later/
06:50:29 <quicksilver> so it's more about history and using "the best thing that exists now"
06:50:36 <quicksilver> than it is about a failure to abstract / missing typeclasses.
06:50:52 <kmc> http://hackage.haskell.org/package/yap nice embedded picture in docs, didn't know you could do that
06:51:19 <quicksilver> the mathematician in me agrees that the numeric hierarchy is wrong
06:51:27 <quicksilver> the programmer in me finds it really, really hard to care :)
06:51:42 <kmc> it gets in my way, as a programmer
06:51:45 <quicksilver> I've never suffered a haskell problem which would have been solved if only my numeric types had been instances of AbelianGroups
06:51:45 <hpc> the programmer in me says the numeric heirarchy is confusing
06:51:51 <kmc> the mathematician's objections are probably *different*
06:52:05 <kmc> but, say, the Show and Eq requirement on Num is annoying in some practical circumstances
06:52:13 <quicksilver> Peaker: do you see my point about String/ByteString/Text ?
06:52:16 <benmachine> quicksilver: I have, I think
06:52:25 <quicksilver> benmachine: hurrah :) Have a cookie!
06:52:29 <benmachine> :P
06:53:00 <benmachine> well, it's only tenuously because of the numeric hierarchy, but the large number of methods in Num means people tend to leave some out
06:53:13 <benmachine> and I had a particularly nasty and hard to find bug once when I left out both (-) and negate
06:53:20 <benmachine> not even a compiler warning, of course
06:53:38 <benmachine> nor even a runtime error, just an infinite loop :)
06:54:17 <benmachine> (I claim that had AbelianGroup existed I'd've been forced to be more careful about what was and wasn't defined)
06:54:34 <Taejo> is there a way in Yesod to have "static generated" files -- if a file has already been generated for a given URL I want to use it; otherwise I want to create it
06:54:39 <quicksilver> benmachine: that's not quite what I meant, although interesting point
06:54:51 <quicksilver> benmachine: (I was thinkg about consumers of the hierarchy, not people writing new instances)
06:55:14 <quicksilver> as a person writing a new instance I actually did once have an issue that (^) isn't a method so you can't do interval arithmetic instance for it
06:55:55 <hpc> :t (^)
06:55:56 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
06:55:59 <hpaste_> desaiu pasted “ask for num, get it right, you win!” at http://hpaste.org/52460
06:56:17 <desaiu> test.hs:9:2: Not in scope: `askforNums'
06:56:26 <desaiu> Not sure what's going on there
06:56:35 <benmachine> quicksilver: the interval arithmetic instance is distinct from the multiplication definition?
06:56:57 <hpc> desaiu: capitalization
06:57:03 <desaiu> Also, I don't understand what "where" means in module Main\ where
06:57:29 <desaiu> hpc: drr!
06:57:30 <desaiu> Thanks
06:57:32 <quicksilver> benmachine: you don't want to do repeated squaring.
06:57:38 <hpc> desaiu: in that case, "where" is just syntax
06:57:54 <desaiu> test.hs:7:2: Not in scope: `hsetBuffering'
06:57:55 <hpc> so the compiler knows where export lists end and the module body begins
06:58:02 <quicksilver> benmachine: [a,b]^2 is interesting if a < 0 < b
06:58:09 <hpc> desaiu: capitalization again :P
06:58:14 <benmachine> quicksilver: aha
06:58:17 <quicksilver> benmachine: it becomes [0,max (a^2) (b^2)]
06:58:41 <desaiu> :P
06:58:41 <quicksilver> [a,b]^2 is *not* [a,b] * [a,b]
06:58:50 <quicksilver> because in the former you know it's the same number squared
06:58:55 <quicksilver> in the latter it's antyhing from the range
06:58:56 <benmachine> I see
06:59:06 <benmachine> interesting
06:59:17 <quicksilver> the fall back is OK it's just conservative
06:59:38 <quicksilver> [a^2,b^2] is correct but it might be larger than you can do
06:59:52 <quicksilver> and obviously you'd rather have the tightest bound
06:59:57 <benmachine> mm
07:00:20 <benmachine> wait, how could it be larger than you can do?
07:00:54 <benmachine> do you mean [a,b]*[a,b] is correct but larger?
07:01:40 <tijn_> say I have a list of lists, as in [l1, l2,l3,l4], and I have a function eating that, and I want to return the name of the list (i.e. l3) and not that list itself, it that possible?
07:02:27 <hpaste_> desaiu pasted “compilation error” at http://hpaste.org/52461
07:02:40 <quicksilver> tijn_: no. Names do not exist.
07:02:48 <tijn_> ok thnx
07:02:52 <benmachine> tijn_: not really, but you could return its index in the big list
07:02:56 <hpc> tijn_: you would have to make it a list of (name, list)s
07:03:00 <hpc> or something like that
07:03:04 <quicksilver> benmachine: [a,b]*[a,b] is a superset of the actual interval
07:03:11 <benmachine> quicksilver: right
07:03:13 <quicksilver> benmachine: so by using that, you'll just inflate all your intervals
07:03:17 <desaiu> Possible fix: add an instance declaration for (Num String)
07:03:21 <quicksilver> which won't cause you to make a mistake, per se
07:03:21 <tijn_> I was thinking about changing the datastructure yes, just wanted to check :-)
07:03:28 <quicksilver> but might make your algorithm have to work harder than it shuold
07:03:31 <benmachine> quicksilver: but [a^2,b^2] is the right answer, right?
07:03:34 <desaiu> Oh I know!
07:03:52 <hpc> tijn_: a lot of information is destroyed during compilation, so you can't ask for an expression's type at runtime either, for example
07:03:58 <quicksilver> benmachine: the right answer is "if a<0 then [0,max (a^2) (b^2)] else [a^2,b^2]"
07:03:59 <benmachine> ...assuming a^2 < b^2
07:04:13 <benmachine> quicksilver: ah, right, ok
07:04:25 <quicksilver> hmm actually there is another case for a and b both <0
07:04:42 <quicksilver> [b^2,a^2] if a<b<0
07:04:43 <benmachine> [b^2,a^2]?
07:04:46 <benmachine> right
07:05:21 <desaiu> Compiled and worked!
07:05:29 <desaiu> Now I go to school
07:05:46 <desaiu> Thank you hpc for pointing out what should have been obvious mistakes
07:06:24 <benmachine> quicksilver: hm, [a^2,b^2] is actually too small if a<0<b
07:06:38 <benmachine> so you could get an outright wrong answer
07:07:12 <quicksilver> benmachine: well that's not really what the multiplication rule is
07:07:32 <benmachine> quicksilver: oh, yes
07:07:37 <benmachine> but it's what you said a while ago :P
07:07:41 <quicksilver> yes, sorry
07:07:48 <quicksilver> I only had one case in my head
07:07:51 <quicksilver> it's a bit small
07:07:54 <benmachine> :P
07:08:52 <Taejo> I'm trying to use yesod devel (running "./cabal-dev/bin/yesod --dev devel") and it's not reloading (if I modify a file, it restarts the server, but the changes don't show up) until I do "cabal-dev install -fdevel" and restart the server. I'm using a cabal-dev installed yesod-0.9.3 on Ubuntu 10.10 (Maverick). Any ideas?
07:11:12 <kmc> any way to make runhaskell read the program from a pipe instead of an ordinary file?
07:11:18 <kmc> it fails on hFileSize
07:18:33 --- mode: gibson.freenode.net set +o Igloo
07:18:33 --- mode: gibson.freenode.net set +o ChanServ
07:19:25 * hackagebot uniplate 1.6.3 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.3 (NeilMitchell)
07:26:54 <erus`> whats a monad comprehension ?
07:27:25 <KitB> erus`: A generalised list comprehension
07:27:33 <kmc> list comprehension generalized to monads other than []
07:28:26 <kmc> list comprehension and "do" are two syntactic variations on the same basic idea
07:28:27 <KitB> What kmc said ^_^
07:28:31 <erus`> > [ x <- Just 123]
07:28:32 <lambdabot>   <no location info>: parse error on input `<-'
07:28:42 <erus`> > [ x | x <- Just 123]
07:28:44 <lambdabot>   Couldn't match expected type `[t]'
07:28:44 <lambdabot>         against inferred type `Data.Mayb...
07:28:44 <KitB> They were removed IIRC
07:28:48 <kmc> so it makes sense to allow an arbitrary monad for either
07:29:00 <kmc> this was the case in Haskell 1.4 and it's the case in new GHC via extension
07:29:02 <engla> it's like condensed syntax for do notation
07:29:22 <brisbin> kmc: try runghc <(someprocess)
07:30:05 <kmc> no good, it's still a pipe
07:30:17 <brisbin> dunno, works for vim, diff, etc
07:30:38 <brisbin> echo foo | runghc <(cat)
07:30:58 <quicksilver> yes, but that's not the point
07:31:15 <kmc> that doesn't work
07:31:18 <quicksilver> that just gives it a file name representing an FD
07:31:27 <kmc> yeah, the fd is still open to a pipe
07:31:29 <quicksilver> kmc's error message clearly showed it was trying to get the file size
07:31:33 <kmc> (an anonymous pipe in Linux's pipefs)
07:31:40 <kmc> on Linux with bash.
07:31:44 <quicksilver> and you can't do that on a pipe or socket or other special
07:31:53 <kmc> i'm sure some shells / OSes implement <(...) with temp files
07:31:54 <quicksilver> which is why my solution used a temp file
07:31:58 <dmwit> kmc: No, I don't think there's a way. Use a temp file.
07:32:17 <benmachine> I wonder what it needs hFileSize for
07:32:24 <benmachine> is it some exotic version or setup of ghc?
07:32:27 <kmc> i wish there were a cleaner way to ephemerally emulate a seekable regular file
07:32:34 <kmc> nope benmachine
07:32:44 <benmachine> are you sure the error isn't generated by the file you're running? :P
07:32:47 <kmc> yes
07:32:51 <kmc> you can try it yourself
07:32:52 <copumpkin> kmc: than what?
07:32:56 <benmachine> kmc: I did
07:32:58 <benmachine> it worked
07:32:59 <copumpkin> kmc: have you tried knob? :D
07:33:02 <kmc> oh really benmachine
07:33:08 <kmc> what did you do, exactly?
07:33:12 <benmachine> $ echo 'main = print "foo"' | runghc
07:33:13 <benmachine> "foo"
07:33:50 <glas> Hi guys, I have a question about replacing values in a list
07:33:52 <kmc> oh, that did work for me
07:33:56 <glas> I want to insert new values into my list. How do I make it so if the key already exists it will replace the old value in the key-value pair? Exemple:  This is the old list:[("Cat",10),("Horse",8),("Dog",12)] replaceValue ("Dog", 4) aList => [("Cat",10),("Horse",8),("Dog",4)]
07:33:58 <kmc> but runghc /dev/stdin did not
07:34:01 <kmc> thanks benmachine
07:34:04 <benmachine> :)
07:34:10 <kmc> i guess i should try the simple way first :)
07:34:14 <benmachine> :P
07:34:22 <kmc> glas, you should use Data.Map instead of a list
07:34:29 <kmc> lists are not good for this use case anyway
07:34:31 <AtnNn> Taejo: yesod devel uses the installed Application module
07:34:55 <glas> I just want to know how to replace the value if the keys are the same :P
07:35:08 <Taejo> AtnNn, I thought the purpose of yesod devel was to recompile whenever recompilation is needed?
07:35:31 <kmc> benmachine, now, is there a way to pass command line args?
07:35:41 <dmwit> glas: What have you tried?
07:35:51 <AtnNn> Taejo: yes. It might be a bug. my workaroudn is not to install with -fdevel. try asking in #yesod
07:35:56 <luite> AtnNn: it doesn't use the installed module, but the one from the package installed in-place
07:35:58 <glas> Well I found something called addToAL but didnt know how to use it
07:36:09 <dmwit> glas: Try writing it yourself. It's not hard.
07:36:23 <glas> I know how to add values into an empty list and I also know how to add values into the back of an existing list
07:36:24 <AtnNn> luite: that may be what I meant
07:36:26 <dmwit> Though addToAL does indeed sound promising. Where did you find that?
07:36:49 <glas> Googled it :P
07:36:53 <luite> AtnNn: err, I meant, it doesn't install the package, it uses the in-place library. older versions did install it
07:36:56 <benmachine> kmc: none of the magic I tried worked :( (I suppose withArgs is out of the question?)
07:37:11 <kmc> hmm runghc is a little haskell program that ships with ghc
07:37:16 <benmachine> maybe something really odd like ghc -e 'withArgs [blah] main'
07:37:23 <kmc> when reading from stdin it uses a tempfile
07:37:25 <kmc> ;P
07:37:28 <kmc> so i'll just stick with that
07:37:31 <benmachine> hah
07:37:36 <glas> I want to write it myself though :(
07:37:38 <benmachine> fair enough
07:37:42 <dmwit> glas: Yeah, write it yourself.
07:37:56 <glas> dmwit: Any tips?
07:38:07 <glas> Im totally new to haskell
07:38:09 <dmwit> glas: The general strategy is just to recurse over the list, replacing an element if you find one, and sticking the thing in (say, at the end) if you never do find one.
07:38:14 <benmachine> glas: break and span would be good places to start
07:38:19 <benmachine> well, break or span
07:38:22 <benmachine> probably break
07:38:34 <glas> Alright, I'll check those out
07:38:43 <benmachine> or actually, if you're totally new, dmwit's way is probably easier
07:38:48 <dmwit> glas: I actually recommend writing the recursion yourself first.
07:38:58 <dmwit> glas: Then, later, we can talk about a few other ways to write it that take advantage of library functions.
07:38:59 <kmc> hmm otherwise it does ghc -ignore-dot-ghci -x hs -e ':set prog "foo.hs"' -e ':main ["args", "go", "here"]' foo.hs
07:39:02 <kmc> i guess i can emulate that
07:39:11 <glas> I can show you my current code?
07:39:16 <dmwit> For sure!
07:39:18 <dmwit> ?hpaste
07:39:18 <lambdabot> Haskell pastebin: http://hpaste.org/
07:39:24 <luite> Taejo: hmm, ok, you shouldn't install with -fdevel, can you remove that package from your cabal-dev?
07:39:41 <AtnNn> luite: yesod's deve.hs does import "module" Application, which picks up the installed version instead of the recently built version
07:40:05 <Taejo> luite, ok I've done that -- should I install without it or leave uninstalled?
07:40:07 <luite> AtnNn: yeah the problem is probably that the application should never be instaled
07:40:31 <luite> the library is built only for the yesod devel server, for production you build an executable
07:41:14 <luite> Taejo: you can just run yesod --dev devel now, and then it should pick up the freshly built library (with the inplace package config)
07:42:35 <glas> dmwit, benmachine: http://i.imgur.com/1Idp3.png
07:42:44 <glas> Screenied it instead :P
07:42:54 <dmwit> Why??
07:43:04 <glas> Faster
07:43:08 <luite> Taejo: did it work?
07:43:15 <glas> First one adds the list to an empty list, second one adds it to the back
07:43:31 <dmwit> glas: Yep, looks reasonable, but doesn't check the list for duplicates.
07:43:34 <benmachine> glas: what happens when you add something to the back of an empty list? >_>
07:43:47 <dmwit> glas: (By the way, adding it to the back seems very strange: why not add it to the front?)
07:43:51 <benmachine> (also, is emptyList defined anywhere?)
07:44:05 <dmwit> glas: (Then you don't need two clauses. And you can just write insertList = (:), very clean. =)
07:44:46 <dmwit> glas: To check for duplicates, pattern match on the non-empty list clause to pull out the components of the tuple in the list and the tuple you're trying to insert.
07:44:53 <glas> dmwit: Yeah I know it doesnt look for duplicates nor replace them. Thats why I came here :P
07:45:24 <dmwit> Here's a start: insertList (k, v) ((k', v'):rest) = {- ... -}
07:45:38 <copumpkin> > let test :: (a ~ (b, c), a ~ (c, d)) => (b, c) -> (c, d); test = id in test (5, 6)
07:45:39 <lambdabot>   (5,6)
07:45:46 * copumpkin applauds GHC
07:46:21 <dmwit> Let's prove that a = b! Step 1. Assume a = b. Step 2. Done.
07:46:32 <Taejo> luite, yes. thank you!
07:46:48 <copumpkin> > let test :: (a ~ (b, c), a ~ (c, d)) => b -> c; test x = x in test 5
07:46:49 <lambdabot>   5
07:47:18 <luite> Taejo: ok
07:47:19 <mm_freak> does anyone know how well the OGL package is maintained compared to the OpenGL package?
07:47:38 <kmc> great a screenshot of some haskell code
07:47:41 <dmwit> copumpkin: Well, okay, that one was pretty darn impressive.
07:47:55 <copumpkin> yeah, <3 GHC
07:48:06 * copumpkin awaits one of the unicodeites to provide the appropriate symbol
07:48:17 <kmc> ♥
07:48:18 <dmwit> In fact, how does that even work?
07:48:19 <luite> Taejo: I've added a comment to the yesod devel improvement ticket: https://github.com/yesodweb/yesod/issues/125
07:48:28 <copumpkin> ♥ kmc
07:48:31 <kmc> yay
07:48:39 <kmc> <Multi_key> less 3
07:48:43 <copumpkin> dmwit: it has to assume injective type constructors
07:48:57 <luite> Taejo: I'll probably work on it some more in a few weeks
07:49:01 <dmwit> Can a proof of type (b, c) ~ (c, d) be deconstructed into two proofs b ~ c and c ~ d?
07:49:22 <luite> Taejo: you can add more comments if you want more features or find bugs :)
07:49:22 <dmwit> s/proof/cast/ if you prefer, I guess
07:49:30 <int-e> dmwit: since it's not a type family, yes.
07:49:32 <copumpkin> dmwit: only if (,) is injective
07:49:36 <int-e> "it" being (,)
07:49:46 <dmwit> magical
07:49:48 <kmc> there is a paper about this
07:49:50 <mm_freak> ok, question answered itself…  OGL's last upload was in 2009
07:49:51 <kmc> about System Fc
07:49:58 <dmwit> I know, I've read it.
07:50:01 <dmwit> Doesn't mean I understand it.
08:31:27 --- topic: '["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin/spam issues: #haskell-ops"]'
08:31:27 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Sep 03 10:10:12 2011]
08:32:01 <ski> > Data.Graph.Node {Data.Graph.rootLabel = (),Data.Graph.subForest = []}
08:32:02 <lambdabot>   `Data.Graph.rootLabel' is not a (visible) field of constructor `Data.Tree.N...
08:32:16 * ski phaws
08:32:24 <copumpkin> phaw away
08:33:28 <kniu_> is there a more comprehensive tutorial for using Haskell's LLVM bindings than what's on lennart augustsson's blog?
08:37:40 <dmwit> ski: ...did you mean Data.Tree?
08:38:14 <dmwit> > Data.Tree.Node { Data.Tree.rootLabel = (), Data.Tree.subForest = [] }
08:38:15 <lambdabot>   Node {rootLabel = (), subForest = []}
08:47:14 <antihoax> hi
08:47:15 <antihoax> is there a raid-z layer in linux ?
08:47:57 <kmc> why are you asking #haskell?
08:48:12 <kmc> i am pretty confident that there is not a raid-z layer in Linux implemented in Haskell
08:48:31 <kmc> furthermore if you showed us a raid-z layer in linux our response would be "it sucks because it's not written in Haskell"
08:48:46 <osfameron> a redundant stream of inexpensive monads
08:48:54 <kmc> cheap burritos
08:50:00 <antihoax> hehehe
08:50:18 <antihoax> but... i like redundant streams on my hddds
08:50:34 <antihoax> especially if they have error-correction
08:50:54 <osfameron> a haskell raid system would have no errors, as they would all be caught by the type system
08:59:25 <dang`r`us> ello. I keep trying to get more proficient in haskell and now I have decided to write a simple web application in haskell, which would have to read+write json and "database stuff" (not necessarily SQL, could be anything). What libraries should I use to accomplish that?
09:00:52 <dmwit> aeson for JSON
09:00:53 <msieradzki> I used HDBC
09:01:07 <dmwit> I don't know what the prevailing wisdom is for database stuff these days, but there's half a dozen packages on Hackage.
09:01:12 <dang`r`us> okay, and for the actual "webapp framework" part?
09:01:15 <msieradzki> I tried to use haskelldb, maybe something changed with it but it was quite clumsy compared to MS LINQ
09:01:28 <dmwit> yesod and snap seem popular
09:01:32 <msieradzki> there are no real frameworks they're closer to web server libraries
09:01:37 <dang`r`us> would one use "ORM"-like libraries in haskell?
09:01:49 <msieradzki> there's no framework that controls everything from start to end
09:01:49 <dang`r`us> msieradzki, okay, what are my options?
09:01:58 <dang`r`us> hm. Is that considered a good thing?
09:02:28 <dmwit> Webapp frameworks are maybe the number one most active development area in Haskell right now.
09:02:30 <dang`r`us> a quick google reveals http://www.haskell.org/haskellwiki/Web/Frameworks - so basically I should toss that list?
09:02:50 <dmwit> That list looks pretty good to me.
09:02:52 <rotflcopter> hi guys
09:03:00 <dang`r`us> I don't need anything fancy, the app will be used to manage todo lists
09:03:00 <msieradzki> dmwit, my point is that python people expect ORM, web server, html lib, json lib and 10 other things in one package and call it framework
09:03:04 <kmc> dang`r`us, happstack, snap, yesod are the main ones
09:03:23 <dang`r`us> ok thanks guys
09:03:26 <kmc> i wouldn't toss any list, I would just research these libraries and see if they do what you need
09:03:29 <dang`r`us> will have a look
09:03:32 <kmc> which might be less than what all of Rails does
09:03:50 <dang`r`us> no worries, I don't need a lot, probably not even html templates
09:03:54 <kmc> (actually, there's a trend towards minimalist web frameworks in other languages)
09:03:56 <Cale> dang`r`us: "Object Relational Mapping" seems a bit awkward of a name in a language which doesn't really try to be object oriented.
09:03:59 <dang`r`us> (for now)
09:04:13 <dang`r`us> Cale, hence the quotes; I don't know the equivalent term for haskell or if there even is such a thing
09:04:18 <benmachine> I think I used hsql once, it was okay
09:04:32 <frigga> dang`r`us: http://stackoverflow.com/questions/5645168/comparing-haskells-snap-and-yesod-web-frameworks
09:04:33 <ido> kmc: hi
09:04:35 <AtnNn> persistent does a nice job for mapping a database to haskell types
09:04:36 <kmc> i'd like to see a good comparative writeup about the various sql / mysql / sqlite libraries
09:04:38 <Cale> There's HaskellDB, which might be pretty scary for beginners, but seems quite nice.
09:04:39 <kmc> hey ido, how goes it?
09:05:03 <Saizan> "persistent" is probably less scary
09:05:08 <msieradzki> is haskelldb still alive?
09:05:10 <benmachine> I used HSQL and my impression was it wasn't as clever as it could have been, but did a decent job anyway
09:05:13 <dang`r`us> frigga, cool, thx
09:05:20 <dang`r`us> AtnNn, thx as well
09:05:29 <Cale> msieradzki: I'd hope so.
09:05:58 <msieradzki> simple scenario I wanted to have with haskelldb: have it some way work with stored procedures
09:06:25 <msieradzki> otherwise if library can't have some hack to use them you have to either use HDBC and haskelldb or forget about haskelldb totally
09:06:33 <matthiasgorgens> Where can I find a simple example (just reading and printing lines or so) for reactive?  The examples I found in the tutorials don't seem to work.  If there's no simple example, I'll just go and have a look at some reactive-glut or so.
09:06:57 <dang`r`us> ok, I think I've got a lot of reading material now
09:06:59 <dang`r`us> thanks again.
09:07:09 <quicksilver> matthiasgorgens: I made a post to the reactive list yonks ago with some simple read/print style examples
09:07:32 <quicksilver> matthiasgorgens: using my version of the library not conal's but the basic API is the same and it might be helpful
09:08:01 <matthiasgorgens> Thanks, I'll try that, quicksilver.
09:11:32 <Cale> matthiasgorgens: You could probably talk to Conal about what needs to be looked into exactly, but last I actually managed to get the packages installed, it had some pretty severe performance problems in cases where it wasn't supposed to (probably making it unsuitable for real projects yet.)
09:11:43 <Cale> (reactive did)
09:13:18 <quicksilver> Cale: my implementation appears to work. Although it is not entirely complete.
09:13:53 <quicksilver> matthiasgorgens: http://www.haskell.org/pipermail/reactive/2008-December/000139.html
09:13:59 <quicksilver> (wow, nearly 3 years ago)
09:14:11 <matthiasgorgens> quicksilver: Thanks.
09:14:15 <quicksilver> matthiasgorgens: that message doesn't appear to describe a simple example but one is, in fact, included in that upload, it's called "myreactive.hs"
09:14:15 <dmwit> This is the year of FRP.
09:14:38 <quicksilver> "martin" found it useful, he said ;) http://www.haskell.org/pipermail/reactive/2008-December/000151.html
09:14:41 <copumpkin> FRP on the linux desktop?
09:14:53 <Cale> Oh!
09:15:01 <dmwit> FRP on the Linux desktop, running in a BeOS VM.
09:15:03 <Cale> That's my coworker :)
09:15:25 <matthiasgorgens> dmwit: I'm actually working on VMs in Haskell.
09:16:04 <Cale> Martin Kudlvasr
09:16:07 <copumpkin> Cale: is that a worker in the opposite category?
09:17:17 <dmwit> Nah, it's a person who orks cows.
09:18:14 <matthiasgorgens> copumpkin: I bet he has all his morphisms backwards.
09:19:19 <quicksilver> Cale: I'm glad to hear that, nearly three years ago, I helped your coworker grok some part of reactive
09:19:25 <quicksilver> it really is a nice model if we can make it work.
09:19:55 <rotflcopter> do you like chips?
09:19:57 <quicksilver> although you can get a bit bored of (\a b c -> ... something quite involved) <$> behaviourA <*> behaviourB <*> behaviourC as a writing style.
09:20:09 <quicksilver> we need applicative shorthand :)
09:20:29 <Cale> Hey, that's still way way nicer than arrow notation.
09:21:02 <quicksilver> yes, it is. In my opinion.
09:21:07 <quicksilver> I've never really "got" arrow notation though.
09:21:18 <quicksilver> (it's always looked worse than longhand arrow combinators in the examples I've tried)
09:21:33 <quicksilver> s/longhand/appropriately chosen/
09:21:51 <quicksilver> of course you can write
09:22:17 <Cale> Well, not once you start writing larger things. One of the problems with arrows is that they don't really give you a great way to name the things that are often central to what you're trying to express. It's a bit like being forced to program in a points-free way.
09:22:24 <quicksilver> f <$> behaviourA <*> behaviourB <*> behaviourC where f a b c= ....
09:22:25 <Cale> The arrow notation gives you back your points, locally.
09:22:48 <quicksilver> I don't like that much mostly because of my irrational dislike of where
09:22:54 <quicksilver> but it's better
09:23:09 <Cale> You could also go with let :)
09:23:41 <Cale> Or if you're a crazy person, you can define those idiom bracket things :)
09:24:11 <quicksilver> yar.
09:24:24 <quicksilver> erm, idiom brackets don't solve the big ugly lambda?
09:24:39 <quicksilver> they just remove the <$> <*> noise, which doesn't bother me anyway
09:25:09 <Cale> oh, right
09:25:13 <kmc_> maybe it was a mistake for those operators to be 3 characters each
09:25:29 <Cale> Should they be 1?
09:25:35 <kmc_> though <*> <* *> <$> <$ are nicely systematic
09:25:41 <Cale> yeah
09:25:47 <kmc_> i don't think it's a big deal
09:26:38 <quicksilver> I don't think it's a big deal although I vaguely recall finding them ugly originally
09:26:41 <quicksilver> I'm used to them.
09:27:04 <Cale> The arrow notation also is good vs. the arrow combinators precisely because it's ambiguous with respect to how it decomposes in terms of them. There's a good bit of room for the compiler to do something smart there (though GHC certainly doesn't, and our preprocessor has a way to go still)
09:27:32 <ion> I for one never found them ugly.
09:29:15 <quicksilver> Cale: hmmm...
09:29:41 <Cale> I thought that Applicative was kind of arbitrary until I learned that the function instance was just the SK calculus, which is probably odd, because it seems more likely to happen the other way around.
09:29:49 <quicksilver> Cale: well you've used arrows much more than me. The only time I ever used arrows was for a kind of parsing/rewriting thing I wrote
09:30:03 <quicksilver> that was a transformer for C++ code, I think
09:30:17 <quicksilver> I should dig it out and ask you to explain to me how arrow notation might have helped.
09:31:35 <Cale> The Arrow paper also explicitly denies the "naturality" axiom that (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k), but I think it should be an axiom of Arrow, both for programmer sanity and to give the translation of arrow syntax a bit more room to adjust things.
09:31:47 <kmc> for me thinking of Applicative as the class of liftA(n) was key
09:36:54 <hpaste_> stepcut pasted “got in happstack” at http://hpaste.org/52466
09:38:25 <quicksilver> Cale: well it's abotu effect order isn't it?
09:38:56 <quicksilver> Cale: (putStrLn "a" >>> putStrLn "b") *** (putStrLn "c" >>> putStrLn "d")
09:39:12 <quicksilver> Cale: (abuse of notation, lift my putStrLn into Kleilsi IO in the obvious way)
09:41:11 <dmwit> One of the most interesting SO questions in a while: http://stackoverflow.com/questions/7720108/total-function-of-type-forall-n-maybe-f-n-maybe-forall-n-f-n
09:41:32 <hpaste_> stepcut annotated “got in happstack” with “got in happstack (annotation)” at http://hpaste.org/52466#a52467
09:43:24 <c_wraith> anyone know how the threaded runtime assigns green threads to capabilities?  And, in particular, if switching a green thread from one capability to another ever happens?
09:44:32 <kmc> i think it can, that's why you need bound threads for some FFI stuff
09:44:41 <kmc> you could ask #ghc too
09:45:36 <c_wraith> I've got a silly two-thread example where it appears the main thread is being starved by a green thread sitting in a tight (no-allocation) loop, despite running with +RTS -N2
09:48:14 <kmc> what's a good (fast, high-quality) PRNG supporting a "split" operation and a pure generator -> (value, generator) interface?
09:48:24 <kmc> mersenne-random-pure64 does not implement 'split'
09:48:42 <c_wraith> I'm not sure there is one.
09:49:39 <kmc> sad
09:50:05 <kmc> maybe i'll generate an infinite list with mwc-random and unsafeInterleaveIO
09:50:25 <kmc> er, I guess i could do that with the pure mersenne twister too
09:50:47 <kmc> but splitting the stream of random numbers could be slow
09:51:38 <dmwit> split (x:y:rest) = let ~(xs, ys) = split rest in (x:xs, y:ys)
09:51:46 <bleh> ./msg lambdabot
09:51:48 <kmc> right
09:52:03 <kmc> i expect that to get slow when used many levels deep
09:52:07 <dmwit> Oh, yes.
09:52:09 <dmwit> Yes indeed.
09:52:29 <dmwit> And it plays badly with garbage collection.
09:53:00 <dmwit> (e.g. if some consumers consume much more quickly than others)
09:55:31 <parcs> did conal elliott pioneer frp?
09:55:54 <Cale> FRP is still being pioneered, so yes :)
09:57:01 <parcs> but not reactive programming in general?
09:59:56 <Barbaren> Hey, quick question, is there a way in haskell to make a list of n length?
10:00:20 <sipa> what would you put in it?
10:00:25 <c_wraith> Barbaren: sure.  lots of them.
10:00:35 <c_wraith> > replicate 5 "hello"
10:00:36 <lambdabot>   ["hello","hello","hello","hello","hello"]
10:00:49 <Barbaren> oh
10:00:51 <Barbaren> sweet
10:00:52 <Barbaren> thanks
10:00:53 <c_wraith> > tails "hello"
10:00:53 <lambdabot>   ["hello","ello","llo","lo","o",""]
10:02:19 <yitz> > length $ tails "hello" -- umm, c_wraith?
10:02:19 <lambdabot>   6
10:02:27 <c_wraith> yitz: I miscounted. :)
10:02:39 <yitz> c_wraith: either you or lambdabot
10:02:50 <c_wraith> in particular, I forgot tails includes both the full original list *and* the empty list
10:17:06 <mroman> hi
10:17:18 <mroman> I've got a little problem (bug?)
10:17:23 <mroman> Prelude Text.Printf> let p c = printf "%d" c; p :: Int -> IO ()
10:17:23 <mroman> Prelude Text.Printf> mapM p [1..10]
10:17:23 <mroman> 12345678910[*** Exception: Prelude.undefined
10:17:28 <mroman> ^- how so?
10:19:35 <mroman> I can't think of any reason why that should yield undefined.
10:19:43 <mroman> unless there's a bug in printf.
10:20:52 <mroman> wait a moment.
10:20:57 <mroman> printf has NO return value?
10:21:14 <sipa> use mapM_
10:21:18 <sipa> :t mapM_
10:21:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:21:29 <sipa> that ignores the return values
10:21:41 <hpc> instance PrintfType (IO a)
10:21:59 <erus`> is mapM only useful for IO ?
10:22:06 <hpc> so you don't get a () after an IO printf, you get _|_
10:22:08 <erus`> what other monads have side effects?
10:22:18 <hpc> erus`: mapM works on any monad
10:22:20 <kmc> IO does not have side effects
10:22:20 <erus`> mapM*
10:22:21 <hpc> :t mapM
10:22:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:22:22 <erus`> mapM_*
10:22:24 <kmc> you're still confused
10:22:25 <parcs> mapM is useful for every monad
10:22:29 <parcs> even mapM_
10:22:34 <hpc> > mapM Just [1..5]
10:22:34 <kmc> mapM f = sequence . map f  -- erus`
10:22:35 <lambdabot>   Just [1,2,3,4,5]
10:22:43 <hpc> > mapM (const Nothing) [1..5]
10:22:44 <kmc> so the real question is "which monads have interesting 'sequence'"
10:22:44 <lambdabot>   Nothing
10:22:48 <kmc> and the answer is probably "most of them"
10:22:53 <erus`> i meant mapM_
10:23:15 <erus`> god damn 15 answers to my spelling error before i can fix it :P
10:23:15 <hpc> erus`: what "side effects" means is different for each monad
10:23:37 <mroman> hpc: Why is that @ bottom?
10:23:42 <hpc> erus`: so in the Maybe example i just ran, the side effects could be "you might not get an answer"
10:23:48 <mroman> Why does printf not return IO ()?
10:24:00 <kmc> another interesting effect is non-local control flow
10:24:00 <hpc> mroman: it's the only value that is of type (forall a. a)
10:24:02 <kmc> i.e. Cont or ContT
10:24:11 <sipa> mroman: printf uses some type-level tricks to take a variable number of arguments
10:24:15 <Veinor> i'm kind of surprised ifM doesn't exist
10:24:17 <kmc> mapM_ in Cont could jump to some totally different part of code
10:24:22 <sipa> mroman: to do so, it has a type class of things that printf can reutnr
10:24:30 <hpc> Veinor: you can use when and unless
10:24:32 <erus`> ah so its like checking lots of operations for error?
10:24:32 <sipa> mroman: and one of the instances is IO a
10:24:41 <sipa> mroman: which is maybe more useful than only IO ()
10:24:53 <sipa> mroman: but it implies there is no meaningful return value
10:24:55 <kmc> i bet it's to be compatible with the Haskell 98 restrictions on instances
10:24:57 <Veinor> hpc: my values aren't m () though
10:25:11 <kmc> for which «instance PrintfType (IO ())» is invalid
10:25:15 <kmc> that's also the reason for the horrid IsChar hack
10:25:47 <Veinor> yeah, that sounds right
10:26:54 <Dashkal> Can I get a sanity check?:  If every ADT came with a catamorphism, there would be no need for pattern matching.  This true?
10:33:23 <kmc> i think so Dashkal
10:33:59 <kmc> that's like the church encoding or the mogensen-scott encoding of a data value
10:34:12 <Saizan> the catamorphism wouldn't give you O(1) tail
10:34:53 <Saizan> para- would
10:35:09 <hpaste_> applicative pasted “clunky export browser (cp typeof)” at http://hpaste.org/52472
10:40:49 <Dashkal> Ok cool.  Then my pet language doesn't need case.  One less crash case :)
10:41:12 <Dashkal> I still have the ⊥ that is infinite recursion, but I guess I have to deal with that.
10:43:05 <c_wraith> You can just not allow non-terminating recursion
10:43:12 <c_wraith> coq and agda do that
10:43:29 <Dashkal> Proving that is beyond me at present, but that would be a goal
10:43:38 <Dashkal> I want to have a scripting language that can't crash.
10:48:16 <kmc> O(1) tail for what Saizan?
10:48:28 <Naresh> hi
10:49:31 <copumpkin> kmc: for a list, for example
10:49:43 <Saizan> kmc: let's say s/tail/access to substructures/
10:50:46 <Naresh> i don't get why foldr works on infinite lists (as claimed in the 'higher order functions' chapter in learnyouahaskell.com) can someone give me a hint or two?
10:50:48 <kmc> Haskell doesn't have O(1) tail for lists, either
10:50:53 <kmc> oh, err
10:50:57 <kmc> 'tail' not 'last'
10:50:59 <kmc> sorry
10:51:07 <kmc> yeah i see now
10:51:16 <kmc> @where folds
10:51:17 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
10:51:20 <harriotq> After installing Haskell Platform on os x 10.6, is there something I can put in ~/.cabal/config to specify a path for gcc?  It seems to default to /Developer/usr/bin/gcc
10:51:30 <kmc> @src foldr
10:51:31 <lambdabot> foldr f z []     = z
10:51:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:51:45 <kmc> Naresh, see the last line?  'f' might produce some data before fully evaluating its right-hand argument
10:52:02 <kmc> in particular, «foldr (:) []» is the identity function on lists
10:52:11 <kmc> «foldr f z» just replaces each (:) with f and [] with z
10:52:25 <monochrom> Naresh: my http://www.vex.net/~trebla/haskell/lazy.xhtml has a case study on foldr, it is enough hint to see why foldr is fine for infinite lists, even though I don't use an infinite list as an example
10:53:23 <yitz> harriotq: try with-gcc
10:53:55 <yitz> harriotq: try it first on the cabal command line --with-gcc=...
10:54:41 <Dashkal> hmm, cata can't give O(1) on tail?  I suspect I'm confusing cata with para now...
10:54:50 <Naresh> thanks!
10:55:44 <harriotq> yitz: thanks, but no.  tried --with-gcc and --with-cc and also export CC=... on shell
10:56:48 <yitz> harriotq: the expert to ask about cabal things is dcoutts but he doesn't seem to be around today (i actually needed him for something else)
10:57:13 <harriotq> also tried to symlink /Developer -> /Developer3xyz but that makes llvm-gcc itself crash for some unknown reason
10:58:32 <harriotq> yitz: ok I'll wait
11:00:10 <harriotq> (also tried to compile the whole thing but then I get hit by the conflicting mtl libraries, something about profiling)
11:04:50 * hackagebot ottparse-pretty 0.1 - Pretty-printer for Ott parse trees  http://hackage.haskell.org/package/ottparse-pretty-0.1 (BrentYorgey)
11:08:04 <exFalso> evening gentlemen
11:08:10 <sipa> main screen turn on
11:09:17 <exFalso> what should one do with a "Could not find module 'Network'" error?
11:09:42 <kmc> is there more to the message?
11:10:00 <exFalso> nope
11:10:12 <Twey> Install the Platform?
11:11:12 <exFalso> using ghc 6.12.3
11:12:01 <kmc> did you use ghc --make
11:12:16 <robert[]> hi haskell
11:12:44 <robert[]> only a computer programmer can appreciate the beauty of the diamond lemma
11:13:05 <tac-tics> What's a diamond lemma?
11:13:13 <robert[]> ill show you
11:13:20 <yitz> @vixen only a computer programmer can appreciate the beauty of the diamond lemma
11:13:20 <lambdabot> I am not a crook.
11:13:29 <robert[]> http://sbseminar.files.wordpress.com/2009/11/diamond-e1258746666568.jpg?w=246&h=300
11:13:45 <robert[]> This is fundamental to lambda calculas
11:13:46 <exFalso> @Twey thanks
11:13:46 <lambdabot> Unknown command, try @list
11:13:57 <robert[]> beta reduction
11:13:58 <Twey> Welcome?
11:14:13 <monochrom> Twey++
11:14:21 <tac-tics> robert[]: Ah, is that the church rosser theorem?
11:14:31 <Twey> Ah
11:15:00 <Twey> I completely forgot I'd answered that…
11:16:49 <kmc> a mathematician can't appreciate the beauty of abstract structures?
11:17:44 <rferranti> hello scary people!
11:18:13 <monochrom> several possible answers: a mathematician may be a computer programmer; the diamond lema is not abstract.
11:18:16 <kmc> hello friendly people
11:18:28 <kmc> it is known that some mathematicians are not computer programmers
11:19:01 <rferranti> not yet
11:19:51 * hackagebot ottparse-pretty 0.1.1 - Pretty-printer for Ott parse trees  http://hackage.haskell.org/package/ottparse-pretty-0.1.1 (BrentYorgey)
11:21:16 <robert[]> chirch rosser?
11:21:21 <robert[]> I suppose so
11:21:35 <robert[]> http://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem
11:21:37 <robert[]> nice
11:22:41 <edwardk> kmc: worse. i hear that some computer scientists are not mathematicians! the horror!
11:23:04 <yrlnry> I wasted a significant portion of my life about 15 years ago tracking down what the "J" in "J. Barkley Rosser" stood for.
11:23:07 <robert[]> what is the diffrence between computer scientist and mathematiticna
11:23:11 * alpounet chokes
11:23:25 <sipa> yrlnry: and the answer is?
11:23:31 <yrlnry> John.
11:23:31 <alpounet> i'm studying math in order to be computer scientist! have I been lied to?
11:23:40 <edwardk> i've been told that this small, finite-but-non-empty, proper subset of computer scientists don't tend to like my code
11:23:57 <edwardk> robert[]: the axiom of choice ;)
11:24:00 <robert[]> haha
11:24:30 <yrlnry> hey, look at that.  I started the Wikipedia article on the Church-Rosser theorem.
11:24:32 <yrlnry> Woo.
11:24:48 <robert[]> well done yrlnry
11:24:54 <yrlnry> \o/
11:24:56 <monochrom> I studied math in order to be a computer scientist. I have not been lied to. however, I was careful with what math I went into.
11:25:26 <edwardk> i wasn't careful what math i went into, and yet it all seems to have somehow been applicable ;)
11:26:19 <monochrom> Hausdorff spaces have resisted computer science application so far.
11:26:41 <edwardk> i mean come on: homotopy type theory? who went into homotopy thinking that it'd be a killer way to approach type systems
11:27:15 <robert[]> homotopy
11:27:20 <robert[]> type theory
11:27:28 <robert[]> what
11:27:42 <copumpkin> .
11:27:44 <edwardk> @google homotopy type theory
11:27:45 <copumpkin> http://homotopytypetheory.org/
11:27:45 <lambdabot> http://homotopytypetheory.org/
11:27:45 <lambdabot> Title: Homotopy Type Theory
11:27:45 <robert[]> how about the KNOT THEORY of TYPES
11:28:09 <edwardk> we could talk about that, but lets knot
11:28:15 <aristid> copumpkin: you are the faster lambdabot.
11:28:15 <robert[]> XD
11:28:29 <robert[]> can you do knot theory
11:28:34 <robert[]> in homotopy ttype thoeyo
11:30:12 <edwardk> robert[]: i'll be sure to ask dolio about knotted types when he talks about homotopy type theory ;)
11:30:15 <dolio> edwardk: Nobody did. They went to type theory thinking it'd be a killer way to approach homotopy.
11:30:16 <alpounet> monochrom, you studied math? what kind ?
11:30:42 <monochrom> undergrad kind
11:30:54 <robert[]> whats homotopy for
11:31:18 <robert[]> nevermind
11:32:08 <msieradzki> are there any things to watch out for when binding C++ library to Haskell and then using that Haskell binding from GHCi?
11:32:46 <morphles> > 1
11:32:46 <lambdabot>   1
11:32:53 <morphles> > :t 1 1
11:32:54 <lambdabot>   <no location info>: parse error on input `:'
11:33:00 <monochrom> yes. watch out for C++. :)  more seriously, much better to build a C interface, and bind haskell to that.
11:33:00 <morphles> >:t 1 1
11:33:25 <msieradzki> yes and I have huge C++ library bound by someone else automatically to C
11:33:28 <msieradzki> Bullet physics
11:33:41 <morphles> " :t 1 1" gives "1 1 :: (Num a, Num (a -> t)) => t" what deos that even mean?..
11:33:42 <dmwit> msieradzki: I guess the only thing I've heard of causing problems (with C interfaces, mind you -- I didn't even know Haskell could bind directly to C++) was that ghci plays fast and loose with threads.
11:33:44 <msieradzki> and I have all kinds of stuff like missing symbols when loaded into GHCi (for vtables and such)
11:34:05 <monochrom> then you need many -l's
11:34:05 <msieradzki> nah I solved the problem with threads it's enought o add runInBoundThread
11:34:08 <dmwit> So if all your FFI calls need to come from a single thread or some such thing, you need to enforce that yourself.
11:34:17 <morphles> how 1 1 is legal here, but of course cou cant execute that.
11:34:31 <dmwit> morphles: \bot has a function instance for Num
11:34:43 <monochrom> some evil people gave lambdabot a Num instance for stupid functions
11:34:58 <dmwit> morphles: And ghci observes that, although it doesn't know of a function instance, somebody might eventually make one.
11:34:59 <monochrom> or perhaps, some stupid people gave lambdabot a Num instance for evil functions
11:35:23 <dmwit> (...and somebody eventually did. =)
11:35:33 <dolio> I think it comes from some linear algebra modules or something.
11:35:39 <kmc> Haskell can bind directly to C++, if your platform's C++ ABI matches the C ABI and you mangle names yourself etc.
11:35:43 <kmc> it's not pretty or portable
11:35:46 <dolio> Maybe I'm just imagining that, though.
11:36:45 <robert[]> I need double induction
11:37:07 <monochrom> I sell double induction at $100 per piece
11:37:35 <tkahn> monochrom: i'll take it
11:37:51 <tac-tics> Why not just use structural induction on nat pairs?
11:38:01 * dmwit specializes his strong induction to mere double induction
11:38:06 * byorgey sells double induction i[Cfors $99.99 plus a FREE INSTRUCTIONAL DVD
11:38:11 <monochrom> tkahn: http://www.vex.net/~trebla/compsci/imperative-functional.html :)
11:38:17 <robert[]> rofl
11:38:29 <robert[]> I want that DVD
11:38:30 <phasip> I am trying to use fold on a Map to create a kind of min function for the values of the map, but I can't figure how to make a initial value, any suggestions?
11:38:53 <byorgey> robert[]: notice I did not specify what it instructs you in
11:39:22 <tkahn> monochrom: bookmarked
11:39:39 <donri> i bet "main is usually a function" is kmc's blog
11:39:39 <monochrom> great. next time you talk about "this program terminations", we won't know how much time either
11:40:11 <monochrom> what? I would think kmc would speak like "main is usually a burrito recipe"
11:40:18 <kmc> it is donri
11:40:23 <kmc> what do you win
11:40:32 <byorgey> phasip: make a newtype Min a = NegInf | Min a  deriving (Eq, Ord)
11:40:39 <monochrom> win a burrito recipe! :)
11:40:40 <byorgey> phasip: then use NegInf as the initial value
11:41:01 <donri> kmc, oh? i was joking :D
11:41:09 <kmc> what was the context for your joke?
11:41:30 <donri> that you have remarked more than once in my presence that main is *not* a function
11:41:37 <monochrom> in fact, which blog article?
11:41:38 <kmc> in Haskell it's not
11:41:40 <phasip> Hmm, that sounds good. Thanks byorgey, I'll try that!
11:41:55 <donri> but it usually is, ok :)
11:42:09 <dmwit> I wonder how many times byorgey's type appears on Hackage.
11:42:21 <kmc> donri, cd /tmp && echo 'int main=0;' > foo.c && gcc -Wall -c foo.c
11:42:21 <byorgey> heh, good question
11:42:47 <donri> hah
11:44:05 <robert[]> bythe way
11:44:11 <robert[]> I have a complete theory of de briiojn indices
11:44:27 <dmwit> ?keal
11:44:27 <lambdabot> nsa try kill me numerous times
11:44:30 <monochrom> then it is an inconsistent theory
11:44:31 <tac-tics> A complete theory? I thought debruijn took care of that...
11:44:42 <robert[]> well
11:44:49 <robert[]> so did I many ears later
11:45:19 <tac-tics> de bruijn is also a cooler name than robert[]. The brackets just kill off the potential for you to get credit for it now :(
11:45:47 <dmwit> ?keal[]
11:45:47 <lambdabot> proofs are no longer sound
11:45:58 <dmwit> o noes
11:46:10 <robert[]> proofs of what?
11:46:13 <tac-tics> dmwit: what does that command do?
11:46:16 <robert[]> no longer sound?
11:46:17 <dmwit> ?keal[] proofs of what?
11:46:17 <lambdabot> when i put what i dat recoved from that tile into a ti92. the damn thing blew up
11:46:54 <dmwit> tac-tics: It shows a random quote from a troll/nutjob from several years ago.
11:47:03 <monochrom> the command replays famous quotes from a character called keal. a bad character.
11:47:08 <tac-tics> dmwit: lol
11:47:15 * JoeyA has spent a lot of time programming a TI-89, and it has yet to combust.
11:47:25 <tac-tics> Did Keal believe that monads were like a taco?
11:47:44 <dmwit> ?state
11:47:44 <lambdabot> Unknown command, try @list
11:47:46 <dmwit> ?where state
11:47:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/
11:47:47 <monochrom> I think he was way before taco
11:47:58 <dmwit> 403'd
11:48:00 <JoeyA> Monads are more like turnovers.
11:48:09 <JoeyA> Do safe FFI calls "spawn a new thread" when -threaded is enabled?  Or do they reuse threads?
11:48:18 <kmc_> is de briiojn related to de btuijn or de brjuiojn or de bruijhn?
11:48:28 <dmwit> I don't think safe/unsafe has anything at all to do with threading.
11:48:33 <kmc_> JoeyA, they're allowed to reuse threads, and under GHC they usually do
11:48:36 <hydo> Apparently, all it takes is simply the mention of 'taco' to put "Puttin' on the Ritz" in my head.  ugh.
11:48:38 <JoeyA> Thanks.
11:48:42 <kmc_> (I assume you mean OS threads; the question does not make sense for Haskell threads)
11:48:48 <robert[]> anyway
11:48:54 <monochrom> they reuse threads. but some new thread may be spawned to do something else
11:49:02 <robert[]> peano arithmetic
11:49:14 <copumpkin> piano arithmetic
11:49:14 <dmwit> I'm wrong, as usual.
11:49:15 <robert[]> data PA = Z | S PA
11:49:19 * copumpkin loves piano arithmetic
11:49:24 <robert[]> therefore haskell is unsound
11:49:25 <tkahn> meta-h /window left
11:49:27 <tkahn> meta-h /window left
11:49:35 <robert[]> just kidding
11:49:37 <tac-tics> The two hardest things for computer science students to grok are pointers and recursion. It makes me want to present some freshman with the fixpoint combinator in de bruijn notation.
11:49:38 <JoeyA> I'm convinced that unsafe shouldn't be used without good reason.  Now I need to spread the gospel to a package maintainer I sent a patch to.
11:49:52 <kmc_> those are the hardest things?
11:49:59 <robert[]> tac-tics: hgreat! idea!!
11:50:10 <kmc_> JoeyA, yes, the difference is about 200 ns on my laptop
11:50:21 <kmc_> so only for the very fastest foreign functions does it matter
11:50:41 <JoeyA> Is it safe to use unsafe with malloc, as is done in Foreign.Marshal.Alloc?
11:50:50 <dmwit> kmc_: JoeyA is on the other side of the argument than you. =)
11:50:59 <Twey> tac-tics: I happen to be in a unique position to do just that…
11:51:01 <robert[]> who wrote a Go AI in haskell?
11:51:01 <dmwit> JoeyA: unsafe is always safe
11:51:02 <kmc_> dmwit, oh yeah?
11:51:14 <dmwit> JoeyA: It's "safe" that you should be careful of putting on calls.
11:51:16 <robert[]> igo
11:51:21 <dmwit> "safe" is the one that carries a proof burden
11:51:23 <Twey> Heh.
11:51:25 <kmc_> dmwit?
11:51:27 <dmwit> Or am I confused yet again.
11:51:33 <kmc_> we're talking about FFI
11:51:36 <c_wraith> dmwit: uh, no.  unsafe should basically never be used.
11:51:39 <kmc_> foreign import vs. foreign import unsafe
11:51:54 <robert[]> ??
11:51:59 <kmc_> !!
11:52:01 <robert[]> I cant get the japan letters here
11:52:05 <JoeyA> dmwit: Not when you have a function that might block indefinitely.
11:52:08 <robert[]> http://ja.wikipedia.org/wiki/%E5%9B%B2%E7%A2%81
11:52:20 <JoeyA> With unsafe, it can block the whole RTS.
11:52:22 <c_wraith> forget indefinitely.  If it may block for 100 ms, it's bad to call it without "safe"
11:52:24 <kmc_> seems like malloc could block for a while, if it has to request more memory from the OS
11:52:28 <dmwit> Yep, I'm confused yet again.
11:52:32 <kmc_> 100 ms?
11:52:34 <dmwit> Damn that naming is confusing.
11:52:34 <Twey> robert[]: If anybody knows, Cale will, I'd imagine
11:52:43 <robert[]> Cale knows everythin!
11:52:52 <Twey> dmwit: ‘unsafe’ is unsafe; this is confusing?  :þ
11:52:52 <kmc_> that's like 1000 times longer than the threshold of caring
11:53:06 <Cale> Twey: haha
11:53:14 <monochrom> a possible workflow: OS thread #1 is happily running several haskell threads. it hits haskell thread #A, and #A commits a crime^H^H^H^H^H safe FFI call. OS thread #1 now runs C code. OS thread #2 now runs all haskell threads except #A (until #A's FFI call returns). Now, where did #2 come from? Maybe in existence since the RTS began. May also be freshly created just when #A calls FFI.
11:53:20 <dmwit> Twey: 'unsafe' indicates functions that are safe to call with no extra work
11:53:24 <dmwit> Twey: That is confusing.
11:53:25 <Twey> Cale: Have you heard of a go AI in Haskell?
11:53:27 <kmc_> if your function takes 10 μs then the "safe" overhead is 2%
11:53:28 <c_wraith> kmc_: well, that too.  But people seem to think "use unsafe unless X".  That's exactly the opposite of how it should be treated
11:53:35 <kmc_> people think that?
11:53:36 <Cale> Oh, no I haven't.
11:53:36 <Twey> dmwit: Fair
11:53:44 <c_wraith> kmc_: yes.  just about everyone.
11:53:53 <c_wraith> (who has ever written an FFI binding)
11:53:59 <kmc_> not i
11:54:06 <robert[]> Why is Go AI so difficult
11:54:10 <robert[]> thats the question we shoudl be asking
11:54:10 <Twey> robert[]: Then there probably isn't one :þ
11:54:19 <kmc_> robert[], because the game has a very high branching factor
11:54:21 <c_wraith> robert[]: that's not a haskell question.  It's an AI question
11:54:27 <robert[]> computers can't see shapes
11:54:31 <JoeyA> Strong AI is slightly more difficult, so I've heard.
11:54:33 <kmc_> yeah they can
11:54:38 <Twey> Because it's a marvellously complex game with an awful lot of possible moves and exceedingly complex heuristics?
11:54:43 <Cale> robert[]: Mostly the difficulty of coming up with a good heuristic scoring algorithm for unfinished games.
11:54:58 <Cale> But also the extremely high branching factor.
11:54:59 <c_wraith> computers can see shapes just fine.  The problem is that the heuristics used by pro-level go players are very nuanced, and almost impossible to make explicit.
11:55:06 <robert[]> just cound who has most pieces
11:55:09 <robert[]> LOL
11:55:18 <Twey> That's not how go works :þ
11:55:22 <Cale> robert[]: That's a terrible heuristic. :P
11:55:22 <merijn> Go is positively easy compared to implementing an Awari AI
11:55:27 <robert[]> that was ajoke :)
11:55:27 <kmc_> robert[], it's funny because you said something stupid and then indicated to us a moment later that you were joking
11:55:30 <monochrom> This is a stupid pointless debate.
11:55:32 <Twey> Ah :þ
11:55:39 <monochrom> or stupid pointless conversation.
11:55:47 <robert[]> http://en.wikipedia.org/wiki/Oware
11:55:49 <robert[]> african bean game?
11:55:53 <Twey> monochrom: Which one?
11:56:00 <merijn> robert[]: That's one of the variations, yes
11:56:49 <robert[]> "In May 2002, two scientists from the Free University in Amsterdam, Netherlands reported that they had used computers to solve the game of "Awari" using a brute force approach. Over 889 billion positions were considered, with their solution demonstrating that perfect play leads to a draw."
11:56:59 <dmwit> merijn: https://panmind.com/projects/938/uploads/Awari_is_solved_(2002)/download.pdf claims otherwise
11:57:02 <monochrom> the AI one
11:57:28 <monochrom> an example of why it's stupid pointless is "computer cannot see shapes".
11:57:55 <merijn> robert[]: That seems unlikely since I've been going to the Free University since 2004 and during our AI class it was listed as an unsolved game harder than Go
11:58:00 <dmwit> monochrom is just sour because he can't see shapes either
11:58:07 <monochrom> or more to the point, "computer cannot[sic] see[sic] shapes[sic]"
11:58:22 <robert[]> merijn: it could be a mistake on the page
11:58:30 <robert[]> of wikipedia
11:59:10 <Cale> merijn: I think it was solved, if we're talking about the same game... It seems much simpler than go, because at least the branching factor is not nearly as large (even as Chess)
11:59:16 <merijn> robert[], dmwit: Ah, I see. They solved the game tree, by throwing exorbitant amounts of hardware at it. Building an actual awari playing AI is unsolved
11:59:26 <dmwit> ?
11:59:34 <Cale> Whaaat...
11:59:39 <dmwit> A solution includes an AI.
11:59:44 <byorgey> merijn: awari being harder than go seems extremely unlikely.
11:59:48 <robert[]> ther difference btween thinking and calcuating
11:59:51 * hackagebot set-extra 1.2 - Functions that could be added to Data.Set.  http://hackage.haskell.org/package/set-extra-1.2 (DavidFox)
11:59:54 <robert[]> that you mean merijn
11:59:57 <merijn> I mean one usable on an actual pc
12:00:01 <robert[]> Humans play awari
12:00:03 <Twey> merijn: Doesn't *seem* that hard… only six branches
12:00:10 <robert[]> but they dont compute 80 billion moves
12:00:25 <dmwit> > logBase 8 998000000000
12:00:26 <lambdabot>   13.28674961977451
12:00:30 <dmwit> err
12:00:35 <kmc> robert[], yes, they calculate a big pile of heuristics instead
12:00:37 <kmc> subconsciously
12:00:39 <dmwit> > logBase 2 998000000000 / 8
12:00:40 <lambdabot>   4.982531107415441
12:00:43 <robert[]> so there is a QUALITATIVE difference
12:00:50 <dmwit> wut
12:00:53 <kmc> and i don't know about awari, but chess grandmasters do explicitly calculate many moves ahead
12:01:00 <dmwit> I'm an idiot.
12:01:15 <Twey> dmwit: I'm not sure what you're trying to do…
12:01:17 <donri> kmc, http://www.reddit.com/r/haskell/comments/l86s6/shqq_embedding_shell_commands_in_haskell_code/c2qndvo
12:01:18 <kmc> robert[], there's a difference in the kind of algorithm used, sure
12:01:24 <kmc> it's still "calculation" in a fundamental sense
12:01:26 <dmwit> > 998000000000 * 50 / 1024 / 1024 / 1024
12:01:27 <lambdabot>   46472.99647331238
12:01:52 <merijn> Anyway, I might be wrong about there not being a good AI
12:01:54 <dmwit> Yeah, storing a lookup table probably isn't a good implementation strategy for an awari AI. =)
12:01:59 <kmc> donri, cool
12:02:30 <merijn> (Although the appendix lists different rules then the Awari we looked in AI class, so maybe we're just talking of different variations)
12:02:54 <Cale> merijn: There are at least decent AIs for similar mancala games, so I'm not sure why there shouldn't be...
12:06:45 <robert[]> what about an AI that progtrams haskell
12:06:48 <robert[]> ?
12:07:12 <sipa> you mean TH? ;)
12:07:15 <merijn> Classic AI is dead anyway
12:07:37 <merijn> Just write an evolutionary algorithm which uses number of GHC warnings/errors as fitness function
12:07:44 <merijn> Once it typechecks its bound to do SOMETHING
12:07:53 <robert[]> that sounds a bit ad hoc
12:08:02 <robert[]> lets do it more precice
12:08:20 <Cale> @keal
12:08:20 <lambdabot> T seems to be haskell, except with a decent interface at this point
12:09:25 <copumpkin> kmc: looks like your foldr is a fromListWith
12:09:54 <kmc> oh hoh hoh
12:10:06 <kmc> I didn't know about that one
12:10:07 <copumpkin> kmc: also, if you swap your tuples, you can even avoid all the swappage
12:10:17 <copumpkin>     let getSize f = ((,f) . fileSize) `fmap` getFileStatus f
12:10:39 <kmc> yeah, I had them that way before
12:10:45 <Masxmasx{AFK}> is there a way to have a type sort itself (provided the elements are all of the same type, which is in Ord), or would I need to write a sort function?
12:10:50 <kmc> but I thought (f,) was more natural in some vague sense
12:11:08 <kmc> and the code was no longer, because I was pattern-matching the tuple anyway
12:11:14 <kmc> Masxmasx{AFK}, sorting a list?
12:11:28 <Masxmasx{AFK}> well, a tuple
12:11:44 <kmc> sorting a tuple doesn't make much sense
12:11:48 <Masxmasx{AFK}> type foo = (foobar, foobar)
12:11:54 <kmc> unless it's a tuple of all the same type
12:11:55 <Masxmasx{AFK}> type Foo*
12:11:58 <Masxmasx{AFK}> yeah, they are
12:12:09 <Masxmasx{AFK}> I want to always have them sorted though, is that possible?
12:12:12 <copumpkin> you probably want a fixed-length vectro
12:12:19 <Masxmasx{AFK}> or would I need to write a function that I call every time I use it?
12:12:29 <copumpkin> oh, well you could wrap a list in a newtype
12:12:36 <copumpkin> and make sure that all functions that touch it maintain the sortedness
12:15:40 <kmc> copumpkin, I still have to singletonify the values, though
12:15:41 <kmc> right?
12:15:47 <copumpkin> probably
12:21:24 <Quantumplation> newtype doesn't work from ghci command line, i take it?
12:22:12 <alpounet> it has only been introduced in the last version of ghci iirc
12:22:52 <Quantumplation> I downloaded ghci early this morning, so unless the development cycle is that rapid... lol
12:23:01 <erus`> kmc do you think i have what it takes to be a professional programmer or should try a more hands on profession?
12:23:42 <copumpkin> Quantumplation: he means in the development tree
12:23:51 <copumpkin> Quantumplation: no released version has that yet, as far as I know
12:24:01 <Quantumplation> ah ok
12:24:11 <kmc> erus`, how the hell should i know?
12:24:15 <Quantumplation> LYAHFGG must just be being pre-emptive
12:24:44 <erus`> infer from what you have seen me code, how much help i need to *get* things
12:24:44 <kmc> no, it probably expects you to put that newtype in a file
12:25:09 <Quantumplation> Is tuple a data constructor type?  cause i'm looking at newtype Pair b a = { getPair :: (a, b) } and i'm having a hard time understanding what this is doing.
12:25:24 <Quantumplation> is it Pair of type b, where b is a type that has a single data constructor?
12:25:34 <Quantumplation> or is it Pair with two types b and a in it's constructor?
12:26:20 <kmc> Quantumplation, do you know how "data" works?
12:26:34 <Quantumplation> I thought I did, perhaps i need to review though
12:26:35 <kmc> and do you know about the record syntax?
12:26:48 <merijn> Quantumplation: Pair b a stores an a and b value as a tuple
12:26:49 <kmc> well "newtype" is very similar to "data"
12:26:55 <cicatristeza> why does this line hang on even values: testing x = elem x $ [x * x | x <- [1, 3 .. ]]
12:27:00 <merijn> oh, wait. That's newtype
12:27:09 <kmc> cicatristeza, because you search forever?
12:27:20 <kmc> > elem 0 [1..]
12:27:24 <lambdabot>   mueval-core: Time limit exceeded
12:27:39 <merijn> cicatristeza: Not all even values are in that list
12:27:44 <engla> cicatristeza: if you want lookup in an infinite list, use some variant of elem that uses the fact that the list is sorted..
12:28:01 <copumpkin> merijn: by "not all" you mean "no", right?
12:28:16 <cicatristeza> doesnt make sense. why would it search forever over a range while the range is clearly defined to be odd?
12:28:27 <rwbarton> clear to you, perhaps
12:28:31 <merijn> copumpkin: I'm technically still right!
12:28:33 <copumpkin> cicatristeza: it has no idea the number doesn't show up later
12:28:39 <kmc> cicatristeza, it's not solving equations or anything
12:28:47 <engla> cicatristeza: why not. this information is not available to `elem`
12:28:52 <kmc> it's just testing each element in order
12:29:00 <engla> @src elem
12:29:01 <kmc> [x * x | x <- [1, 3 .. ]]
12:29:01 <lambdabot> elem x    =  any (== x)
12:29:02 <kmc> > [x * x | x <- [1, 3 .. ]]
12:29:03 <lambdabot>   [1,9,25,49,81,121,169,225,289,361,441,529,625,729,841,961,1089,1225,1369,15...
12:29:06 <monochrom> haskell is just a programming language. not a mathematician.
12:29:18 <kmc> is 1 == 2? no.  is 9 == 2? no.  is 25 == 2? no. ...
12:29:23 <monochrom> even haskell curry himself was not so much a mathematician
12:29:39 <kmc> erus`, I don't know how many hours a day you're spending learning Haskell
12:30:06 <kmc> and there's a lot more to being a professional programmer than being able to learn an obscure language nobody uses anyway ;)
12:30:12 <kmc> but you seem to be learning it in reasonable time
12:30:12 <merijn> erus`: Also depends on whether you want to be a haskell programmer or just a programmer in general :p
12:30:38 <merijn> Understanding haskell to a reasonable level puts you on the right of the programmer skill bell curve
12:30:41 <cicatristeza> i mean it seemed intuitive that elem wouldnt search after a certain number of terms given that the range is linearly increasing
12:30:52 <kmc> cicatristeza, how does elem know that?
12:31:00 <monochrom> intuitive to you, I'm sure.
12:31:03 <kmc> and it's not linearly increasing, it's quadratically increasing ;P
12:31:10 <copumpkin> or monotonically
12:31:25 <engla> cicatristeza: look at the type of the elem function. It only uses (Eq a), so it can only do equality comparison, no orderings
12:31:30 <merijn> cicatristeza: Would you expect a C function to automatically determine that something is not in a list because it's constantly increasing?
12:31:36 <cicatristeza> yes, an error to assume this. how do i search over infinite lists then? or how do i tell elem that this list is ordered?
12:31:44 <merijn> (or python, or whatever language you're used to)
12:31:45 <monochrom> Coq probably does what you want.
12:31:46 <kmc> :t \x xs -> (== [x]) . take 1 $ dropWhile (< x) xs
12:31:47 <lambdabot> forall a. (Ord a) => a -> [a] -> Bool
12:31:51 <copumpkin> coq can prove what you want
12:31:55 <copumpkin> it won't do it automatically
12:32:02 <copumpkin> you can prove what you want, too
12:32:08 <cicatristeza> sorry, haskell's the first language i've programmed in
12:32:20 <kmc> merijn, a lot of people might understand Haskell but totally lack the practical skills necessary to a professional programmer
12:32:25 <engla> cicatristeza: that's cool
12:32:28 <merijn> kmc: I guess
12:32:42 <merijn> kmc: Like me, probably :D
12:32:48 <kmc> using version control, working with people, documentation, designing and understanding large systems
12:32:50 <merijn> That's why I plan to be an academic instead :)
12:32:54 <kmc> exactly
12:33:01 <kmc> a lot of academics would not make good professional programmers, and vice versa
12:33:09 <merijn> Actually, I got those 5 covered
12:33:27 <mdxbhmt> merijn: what you lack then ?
12:33:32 <merijn> Well, maybe not the working with people. When other people are involved work tends to start decreasing
12:33:40 <kmc> sure, that's inevitable
12:33:46 <kmc> you just have to mitigate the overhead
12:33:47 <merijn> mdxbhmt: The ability to say "fuck it, it kinda works, let's ship it!"
12:33:47 <kmc> and that's hard
12:33:59 <kmc> erus`, why do you ask this question, by the way?
12:34:00 <mdxbhmt> merijn: D: don't we all
12:34:27 <erus`> Im thinking of doing computer science. I cant get a decent job at the moment
12:34:42 <merijn> Computer science != professional programmer
12:34:48 <kmc> studying computer science won't teach you how to be a professional programmer, either
12:34:56 <kmc> but it will teach you some more interesting things which are still important
12:35:06 <mdxbhmt> computer science has nothing to do with computers, and neither science /first mit lesson
12:35:09 <gwern> > (((582771/202680742)*0.1)*10000)
12:35:09 <lambdabot>   2.875315110105528
12:35:54 <sipa> computer science education these days is largely software engineering, imho
12:36:32 <merijn> sipa: Depends where you go and what you make of it
12:36:52 <kmc> "informatics" is a much better name
12:44:01 <aristid> kmc: and shorter, and germans who try to speak english already use it by accident
12:44:20 <kmc> :)
12:44:40 <kmc> it's used in English sometimes too
12:44:42 <mauke> that's handy
12:46:50 <merijn> aristid: So do Dutch people
12:47:56 <rferranti> same for italians if you care
12:48:15 <rferranti> well, actually even if you don't care
12:48:36 <merijn> Damn, for a moment I thought I had influence over Italy :(
12:48:52 <rferranti> you sure do, somehow
12:49:27 <aristid> merijn: are you at a dutch university? if so, which?
12:50:00 <aristid> somehow i imagine that all haskell people are in utrecht ;)
12:50:08 <dcoutts> harriotq: you had a Cabal Q?
12:50:46 <merijn> aristid: Yes, but I'm at the Free University in Amsterdam (no, we don't do Haskell there)
12:50:50 <rotflcopter> ahah this is a fish http://www.newsrealblog.com/wp-content/uploads/2010/05/big_fish.jpg
12:51:07 <merijn> Don't Eindhoven and Twente also have a bunch of Haskell people?
12:51:43 <aristid> merijn: you're more likely to know that than i am :)
12:52:06 <variax> I have a terminology question with regard to writing documentation. What's the function passed to 'map' called? The "mapee", the "map function"? Is there some common term?
12:52:50 <byorgey> dcoutts: didn't I hear something about the Cabal and cabal-install repos being merged into one recently?
12:53:08 <JoeyA> I guess the "mapping function"
12:53:12 <JoeyA> I dunno
12:53:23 <kmc> the mapped function, maybe
12:53:29 <byorgey> dcoutts: my real question is: is http://www.haskell.org/cabal/code.html accurate?
12:53:30 <kmc> why do you need to name it?
12:53:30 <dcoutts> byorgey: that's right
12:53:50 <dcoutts> byorgey: um no :-)
12:53:51 <byorgey> dcoutts: was thinking of hacking a bit on cabal init
12:53:55 <JoeyA> Is there a variant of bracket that can do two different things, depending on whether the inner computation succeeded?
12:53:59 <variax> I've been flipping back and forth between "mapping function" and "mapped function". The fact that both seem acceptable would seem to mean that both are wrong.
12:54:18 <dcoutts> byorgey: it's accurate about cabal, the cabal-install bit is out of date
12:54:20 * dcoutts fixes...
12:54:22 <JoeyA> I would use mask, but that would require GHC 7 (the module I'm contributing to doesn't depend on GHC 7 yet, as far as I know)
12:54:30 <byorgey> dcoutts: ok, thanks
12:54:34 <dcoutts> byorgey: btw, I hope you like what I've done to cabal init... :-)
12:54:52 <kmc> JoeyA, you can use 'block' in earlier GHC, and #ifdef between the two
12:55:13 <kmc> variax, yeah, it suggests to me that you should reword your documentation to avoid needing this name
12:55:14 <byorgey> dcoutts: I'm sure I will!  what is it you've done?
12:55:14 <alpounet> byorgey, you have been the one initiating the cabal init part right ?
12:55:21 <JoeyA> What condition do I use for #ifdef ?  Should I test the base version somehow, or the GHC version?
12:55:32 <byorgey> alpounet: yes, Benedikt Huber and I wrote the initial version
12:55:38 <dcoutts> byorgey: I was writing a new quickstart section to the cabal user guide and realised I wanted to tweak cabal init
12:55:42 <kmc> #if MIN_VERSION_base(4,3,0)
12:55:49 <kmc> JoeyA, i do this here: http://hackage.haskell.org/packages/archive/spawn/0.3/doc/html/src/Control-Concurrent-Spawn.html
12:55:55 <dcoutts> byorgey: see the current state of my quickstart guide which gives an indication of the changes: http://code.haskell.org/~duncan/cabal/user-guide/developing-packages.html#quickstart
12:56:12 <byorgey> dcoutts: great, I'll take a look
12:56:25 <byorgey> I love how writing documentation spurs development of new features
12:56:41 <dcoutts> byorgey: right, trying to explain it makes you realise it's all wrong :-)
12:56:43 <byorgey> "gosh, I don't want to have to write X, I want to be able to say Y instead!"
12:56:49 <dcoutts> yeah, exactly
12:57:02 <dcoutts> byorgey: the main thing is to do with generating in comments the .cabal file.
12:57:09 <byorgey> oh, great
12:57:26 <byorgey> that annoys me too, I always forget to pass -m =)
12:57:33 <JoeyA> kmc: Thanks!
12:58:40 <dcoutts> byorgey: right, I dislike getting comments by default, and I don't want to encourage huge unreadable .cabal files on hackage etc etc, but obviously those comments are really useful for beginners, so how to resolve the ui...
12:58:41 <alpounet> dcoutts, "As this stage the proglet.cabal is not quite complete" => "AT this stage [...]"
12:58:52 <dcoutts> alpounet: ta
12:59:07 <dcoutts> byorgey: so I've made it an interactive question, defaulting to no
12:59:29 <byorgey> dcoutts: right, excellent
12:59:41 <dcoutts> byorgey: also, cabal init now has only a single interactive question without any default. So you can get away with hitting enter repeatedly.
12:59:58 <dcoutts> only required Q is lib vs exe
13:00:08 <JoeyA> kmc: In your cabal file, why do you say other-extensions instead of just extensions?
13:00:35 <byorgey> dcoutts: anyway, I was thinking of trying to add more auto-detection, like for (1) repo, (2) dependencies, (3) main-is file
13:00:55 <byorgey> all of those should be doable in some circumstances
13:01:56 <dcoutts> byorgey: and check the recursive dir traversal code, I think I've seen some failures there
13:02:08 <kmc> JoeyA, because I don't want to turn the extensions on, just document that they're required
13:02:11 <byorgey> dcoutts: ah, yeah
13:02:16 <kmc> they're turned on per-file with LANGUAGE pragmas
13:02:25 <kmc> (this is admittedly a bit silly for this one-module package)
13:02:25 <JoeyA> Ah, okay
13:02:26 <byorgey> dcoutts: I've got a few bugs filed away in my bug tracker, I'll dig them up
13:02:38 <kmc> anyway I believe that's the behavior I get with other-extensions but I could be wrong
13:03:03 <dcoutts> byorgey: how do you plan to get dependencies?
13:03:33 <Veinor> i have a controversial opinion
13:04:01 <byorgey> dcoutts: hmm, am I allowed to use the GHC API?
13:04:02 <Veinor> i think haskellers should start using type variables that aren't one letter long
13:04:12 <dcoutts> JoeyA: we split the 'extensions' field into two for Cabal-1.10: default-extensions and other-extensions. default are applied to all modules in the component when compiling, the latter is a declaration that they're used (like declaring dependencies)
13:04:23 <dcoutts> JoeyA: the previous 'extensions' was confused, it did both.
13:04:35 <byorgey> dcoutts: if so, I already have some code that uses the GHC API to look up what package(s) export a given module
13:04:38 <Eelis> Veinor: that's crazy. how will math people ever take us seriously if we do!
13:04:48 <JoeyA> http://hackage.haskell.org/packages/archive/spawn/0.3/spawn.cabal
13:04:56 <JoeyA> Hmm, this has cabal-version:       >=1.6
13:04:58 <dcoutts> byorgey: we know what packages export modules, we've got that in Cabal via the installed package db.
13:05:00 <JoeyA> Should it be >= 1.10 ?
13:05:02 <Veinor> i'm fine with like, (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
13:05:10 <byorgey> dcoutts: oh, right, of course =)
13:05:20 <JoeyA> Or do earlier Cabal version harmlessly ignore other-extensions.
13:05:22 <JoeyA> ?
13:05:26 <byorgey> dcoutts: well, shouldn't be hard them, just look through sthe source code for import statements
13:05:41 <Veinor> but Form m i e v a is just silly
13:05:43 <dcoutts> byorgey: and I don't think we should depend on the ghc api package
13:05:48 <byorgey> dcoutts: agreed
13:06:02 <dcoutts> byorgey: might be ok, it doesn't have to be 100% accurate
13:06:23 <kmc> JoeyA, why 1.10?
13:06:27 <kmc> JoeyA, I think they ignore it with a warning
13:06:35 <kmc> that's what I got when I tested this package on GHC 6.12
13:06:41 <Veinor> i'd prefer, say, Form m input error value view result
13:06:43 <dcoutts> JoeyA: yes, extra fields are ignored with a warning
13:06:52 <byorgey> dcoutts: right
13:06:55 <Veinor> er, remove one of 'value' and 'view
13:07:17 <dcoutts> JoeyA: it's rather the other way around, if you use cabal-version: >=1.10 then you have to use the new fields, rather than the old extensions field
13:07:57 <JoeyA> Thanks
13:09:39 <alpounet> byorgey, for ambiguous modules, you can make cabal tell the user that module M has been found in packages xxx and yyy, and that the user should handle this
13:10:26 <byorgey> alpounet: yes, good idea
13:14:19 <bos> edwardk: hey!
13:14:25 <edwardk> yo
13:14:41 <bos> edwardk: i'm teaching (part of) a class on data-lens tomorrow
13:14:52 <edwardk> =)
13:15:01 <bos> which meant i had to figure out how to use it yesterday. lovely piece of work, very elegant.
13:15:10 <edwardk> thanks =)
13:15:18 <edwardk> have you looked at data-lens-fd and data-lens-template?
13:15:21 <bos> it made me happy to be writing about it.
13:15:34 <bos> no, they're beyond the scope of what i'll have time for, but i know they exist.
13:15:39 <edwardk> fair nuff
13:15:56 <edwardk> data-lens-fd just makes it the state monad stuff work over any MonadState, and the template just auto-derives them for records
13:15:59 <bos> also, we haven't taught the students about fundeps yet, and we've been intentionally vague about monads so far.
13:16:03 <edwardk> *nods*
13:16:07 <alpounet> bos, good job on the course by the way
13:16:13 <bos> alpounet: thanks!
13:16:13 <alpounet> i've been reading the slides
13:16:24 <edwardk> what is the venue?
13:16:38 <alpounet> i like practical aspect of the course
13:16:46 <dcoutts> bos: got any good ideas for Haskell practical exercises I could steal? :-)  I'm teaching on Friday for a bunch of professional programmers, but FP newbies
13:16:50 <alpounet> +the
13:16:53 <bos> edwardk: oh, i'm teaching a couse at stanford
13:16:57 <edwardk> bos: ah
13:17:08 <DanBurton> @google 99 exercises haskell
13:17:10 <lambdabot> http://www.haskell.org/haskellwiki/99_Haskell_exercises
13:17:10 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
13:17:18 <bos> dcoutts: our first lab exercise, maybe? http://www.scs.stanford.edu/11au-cs240h/labs/lab1.html
13:17:39 <bos> dcoutts: it's too big to do within a class, but a pretty easy assignment nonetheless
13:17:41 <edwardk> that reminds me, i need to put together a presentation on trifecta for a couple of weeks from now
13:17:52 <kmc> i like the exercises here:
13:17:53 <kmc> @where cs11
13:17:53 <lambdabot> http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
13:18:03 <bos> edwardk: the world will thank you if you ever write some documentation for your libraries :-)
13:18:10 <DanBurton> dcoutts: or there's always Project Euler. Not Haskell-specific but still very mathy which makes Haskell well suited for the problems
13:18:12 <dcoutts> bos: I've got a 3 hour session, but first 90min will be slides, leaving remaining for exercises
13:18:20 <edwardk> @quote edwardk.*haddock
13:18:20 <lambdabot> No quotes match. Maybe you made a typo?
13:18:29 <bos> dcoutts: i think the 99 haskell problems are really good for getting people started
13:18:40 <edwardk> bos: =) i accept patches ;)
13:18:42 <dcoutts> bos: I had a similar idea about log file processing, extracting some stats, list pipelines etc
13:19:31 <bos> dcoutts: i think that lab1 is doable in 90 minutes, especially if you're there to help people along
13:19:40 <edwardk> @quote haddock problem
13:19:40 <lambdabot> No quotes for this person. My mind is going. I can feel it.
13:19:44 <edwardk> wow its gone
13:19:51 <dcoutts> bos: though ideally I'm trying to think of something that involves them defining their own algebraic (but not recursive) datatype
13:20:04 <bos> dcoutts: ah
13:20:05 <edwardk> @quote haddock
13:20:06 <lambdabot> edwardk says: i have a lot fewer [haddock problems] now since i stopped bothering trying to document ;)
13:20:08 <edwardk> found it =)
13:20:20 <dcoutts> bos: I was thinking of some simple discrete event simulation, like simulating requests of a webserver
13:21:14 <dcoutts> bos: it's tricky, only one session to give people a taster, so tempting to want to cover too much
13:21:35 <alpounet> edwardk, we should make a bet some time, if you loose you have to document all your packages
13:21:37 <bos> dcoutts: one thing i did for criterion used non-recursive ADTs and was pretty easy to do
13:22:07 <edwardk> alpounet: the question is what you could wager that would be worth that many weeks of my time? =)
13:22:09 <bos> dcoutts: basically, classifying the effect of variation in a sample to determine whether they inflate data much or note
13:22:19 <bos> or not, i mean
13:22:30 <dcoutts> mm
13:24:24 <alpounet> edwardk, hm
13:24:25 <alpounet> indeed
13:24:28 <alpounet> let me think about it
13:24:34 <Aaron> Greetings!
13:24:42 <Twey> Salutations!
13:25:02 <Twey> Your name was taken, I'm afraid.  Try a different one.
13:25:03 <Guest63818> quick question...
13:25:43 <Guest63818> Could I just type "add x y = x + y" in a text file called "test.hc"...
13:25:54 <dmwit> yes
13:26:00 <Guest63818> then just "ghc test.hc" ?
13:26:04 <dmwit> no
13:26:04 <Twey> No
13:26:11 <Guest63818> Sorry - this would be just as easy to do in a console
13:26:15 <dmwit> However, if you named it test.hs, then yes.
13:26:16 <dmwit> =)
13:26:20 <Twey> Still no, surely?
13:26:21 <Twey> No main
13:26:28 <Twey> You'd need the library flag
13:26:29 <dmwit> mm
13:26:41 <Guest63818> The library flag?
13:26:48 <byorgey> Guest63818: however, if you name it  test.hs  you CAN do  "ghci test.hs"
13:26:52 <Twey> To compile it into a library
13:26:58 <dmwit> Yeah, you need a main, or use "ghc -c test.hs".
13:26:58 <byorgey> Guest63818: then you can try out your add function interactively
13:27:02 <Twey> If it's to be an executable, it needs a main :: IO ()
13:27:04 <dmwit> To compile without linking.
13:27:09 <akosch> i'm trying to build a simple web-service with wai, but got stuck with using enumerators: I don't really get how I would do normal IO (database queries for example) with request parameters when they are stuck in the Iteratee type. Do I need to run the Iteratee to obtain the values?
13:27:22 <Twey> If you want it to be a compiled library, you need to pass the appropriate flags to ghc to tell it so
13:27:32 <byorgey> Guest63818: what exactly would you want to do with your file?
13:27:42 <Twey> If you just want to run it in the interpreter, you don't need to do anything special, but you do need to call ‘ghci’, not ‘ghc’.
13:27:55 <Guest63818> Just *very* new to haskell, so just wanted to play around
13:28:01 <Guest63818> Seeing it compile would be enough...
13:28:03 <Twey> ghci is probably the way to go, then
13:28:19 <Twey> You can add a ‘main = return ()’ to your file if you want to test out compilation
13:28:28 <Twey> That will be enough to make it compile
13:28:31 <Guest63818> it's just that ghci syntax differs slightly from what I'd type in my source files (apparently)
13:28:32 <kmc> LYAH and RWH both talk about how to compile stuff, I think
13:28:34 <Guest63818> Thanks very much!
13:28:37 <Twey> Yeah, a little
13:31:54 <Guest63818> ttfn - thanks again very much!
13:32:55 <Daegalus> Can anyone tell me why this:  isBetween x y z = (x > y && x < z) || (x < y && x > z) -- gives me a error "ERROR - Syntax error in input (unexpected `=')" in both Hugs and GHC
13:33:19 <Twey> Daegalus: You're not allowed to define things like that in GHCi
13:33:31 <Daegalus> What about hugs?
13:33:31 <Twey> It won't give you a syntax error in GHC, just GHCi
13:33:33 <kmc> you should use "let isBetween ..."
13:33:36 <Twey> You need to prefix it with a ‘let’
13:33:44 <kmc> GHCi is like an IO "do" block
13:33:47 <Daegalus> ah, makes sense
13:33:48 <byorgey> or put it in a .hs file and load that into ghci
13:34:45 <Daegalus> welll I want to test my functions in the repl first. Faster to test my functions there
13:34:48 <Daegalus> thank you for hte help
13:34:56 * hackagebot PropLogic 0.9 - A system for propositional logic with default and fast instances of propositional algebras.  http://hackage.haskell.org/package/PropLogic-0.9 (DavidFox)
13:36:08 <sm> isn't there a newer ghci that allows more haskell syntax ?
13:36:32 <monochrom> will be
13:37:10 <sm> ah, not yet
13:38:08 <JoeyA> GHC says: Couldn't match expected type `IO a -> IO a' with actual type `forall a1. IO a1 -> IO a1'
13:38:15 <JoeyA> Isn't the actual type more generic, though?
13:38:37 <JoeyA> Meaning the types should match, no?
13:38:42 <kmc> what's the context?
13:38:52 <JoeyA> I'm writing portableMask :: ((IO a -> IO a) -> IO b) -> IO b
13:39:05 <JoeyA> Note that I deliberately took out the Rank-3 polymorphism.
13:39:16 <kmc> that makes it significantly less useful :/
13:39:20 <JoeyA> I only need to call the inner callback once, in my case.
13:39:23 <kmc> *nod*
13:39:26 <kmc> makes sense
13:39:27 <JoeyA> I'm not exporting portableMask.
13:39:37 <Daegalus> Is there anything i need to know between Hugs and GHC for basic haskell? My professor uses WinHugs for all his stuff, and will probably be running our scripts with it.
13:39:51 <kmc> Daegalus, there are lots of differences
13:39:54 <kmc> best if you just test with Hugs
13:40:04 <Daegalus> ok
13:40:26 <kmc> i don't know of a way to put GHC into a very strict Haskell 98 only mode
13:40:45 <kmc> probably the more important difference is libraries, anyway
13:40:56 <JoeyA> I guess I could resort to ScopedTypeVariables and add the necessary type signature.
13:41:13 <JoeyA> (the module I'm adding to already uses that extension)
13:41:18 <kmc> JoeyA, which type is mismatching, exactly?
13:42:22 <kmc> you can't instantiate ((∀a. T a) → b) to (T a → b)
13:44:56 * hackagebot logic-classes 0.44 - Symbolic logic support - a class framework, example instances, polymorphic implementations  http://hackage.haskell.org/package/logic-classes-0.44 (DavidFox)
13:44:58 * hackagebot cabal-debian 1.3 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-1.3 (DavidFox)
13:45:00 <DanBurton> kmc: isn't Haskell 2010 the new Haskell 98?
13:45:08 <kmc> yes, but Hugs does not implement Haskell 2010
13:45:13 <kmc> Hugs hasn't seen a release since 2006...
13:46:47 <DanBurton> Is there any major Haskell implementation besides GHC that is current with Haskell 2010?
13:47:06 <kmc> "Is there any major Haskell implementation besides GHC"
13:47:09 <byorgey> DanBurton: no, although I think UHC is close
13:47:22 <kmc> i don't know what the point of "major" is in your question? ;)
13:47:29 <JoeyA> kmc: But can't you instantiate (∀a. T a -> T a) to (∃a. T a -> T a) ?
13:47:41 <DanBurton> kmc: I don't know either. Delete that word from my question :)
13:47:48 <colah> How can I start ghci without importing prelude?
13:47:58 <kmc> ghci -XNoImplicitPrelude
13:47:59 <byorgey> JoeyA: ho.  You can instantiate it to  (T x -> T x) for some particular x.
13:48:04 <byorgey> *no
13:48:21 <kmc> or load a file with "import Prelude()"
13:48:36 <kmc> JoeyA, you have to pick an 'a'
13:48:50 <DanBurton> kmc: but that includes the instances in Prelude, right? Or does it?
13:48:52 <byorgey> DanBurton: my answer to both questions is the same.
13:49:00 <kmc> DanBurton, good point
13:49:07 <monochrom> JoeyA: I think I have a simpler phenomenon of the same spirit. myfun :: (a -> Int) -> Int; myfun cb = cb ()
13:49:49 <colah> kmc: I still have prelude imported...
13:49:52 <kmc> there the caller of myfun picks 'a'
13:50:16 <DanBurton> colah: yeah I'm trying it out too. Seems to still have prelude stuff.
13:50:29 <JoeyA> D'oh, here's where the compiler complains: portableMask = E.mask (supporting the new function)
13:50:35 <monochrom> and I think I have a handwaving explanation of the phenomenon. "a" of myfun is in the covariant, positive position. it is analogous to myvalue :: a
13:50:51 <JoeyA> So I have to instantiate ((forall a1. IO a1 -> IO a1) -> IO b0) -> IO b0 as ((IO a -> IO a) -> IO b) -> IO b
13:50:56 <monochrom> So I cannot write myvalue = (). So I cannot write myfun cb = cb ()
13:51:14 <kmc> ok, so -XNoImplicitPrelude just means that [1..] desugars to (enumFrom (fromInteger 1)) and not (Prelude.enumFrom (Prelude.fromInteger 1))
13:51:22 <kmc> i thought it did that *and* changed the imports
13:51:57 <monochrom> myfun :: (a -> Int) -> Int  is a way to say "return type 'a', but do CPS". well I cannot return the value () for return type 'a'
13:52:13 <dolio> NoImplicitPrelude is supposed to prevent the automatic insertion of an 'import Prelude' line.
13:52:22 <JoeyA> I just had to <greek letters>-expand it: portableMask io = E.mask $ \restore -> io restore
13:52:39 <kmc> interesting
13:52:42 <DanBurton> and for my ghci, it still has the prompt "Prelude>" even when starting it with -XNoImplicitPrelude
13:52:56 <DanBurton> version 6.12.3
13:53:00 <dolio> I don't know that it has an effect in ghci.
13:53:15 <colah> DanBurton: Yeah, that's why I came and asked for help :)
13:53:33 <DanBurton> Unless someone else wants to, I'm gonna throw this ghci/Prelude question on StackOverflow
13:53:51 <colah> DanBurton: That would be awesome :)
13:55:24 <colah> Another question: I'm writing a CSG library. Refactoring it, actually. I'd like to use some ghc extentions to extend the type system and make things more convenient internally. None of the types that need it will be exposed. Will the end user need to use the extenions I used?
13:56:06 <colah> If so, I'll just grit my teeth and do it the silly way. I'd rather not complicate use :)
14:01:23 <quackquack> What is the standard library for regexes w/ haskell?
14:01:59 <kmc> a mess is what it is
14:02:24 <quackquack> well, thats annoying :P
14:02:35 <kmc> yeah
14:02:53 <edwardk> http://hackage.haskell.org/package/regex-base provides types that are used by a lot of different regex-foo
14:03:02 <kmc> there's some library which defines a (=~) operator which is all overloaded to hell
14:03:06 <edwardk> but the API is a bit too magic for normal use
14:03:21 <kmc> it seems the only design goal was "act like perl at all costs"
14:03:24 <edwardk> it was heavily inspired by perl's regex api
14:03:28 <kmc> never mind whether it fits sanely into Haskell's type system
14:03:31 <byorgey> quackquack: however, the consensus is that you don't need regexes as much in Haskell as you do in other languages
14:03:39 <kmc> they're still nice to have
14:03:50 <edwardk> and as a result you have a million overloads that mean you need to put random type annotations on well, everything, to do anything.
14:03:54 <byorgey> since it's really easy to write a quick parser
14:04:01 <kmc> is there a library which is just a sane standalone binding to pcre or something?
14:04:06 <kmc> given that RWH has a chapter on how to write that...
14:04:07 <sm> if you do need em, regexpr is the simplest portable option
14:04:14 <edwardk> there was a pcre-light which was done as part of RWH
14:04:17 <edwardk> or something like that
14:04:24 <kmc> thanks for the suggestion sm
14:04:30 <edwardk> http://hackage.haskell.org/package/pcre-light
14:04:46 <engla> there's a table at http://www.haskell.org/haskellwiki/Regular_expressions
14:05:05 <quackquack> ok, thanks everyone. i miss them from ruby & javascript where they are native >.<
14:05:47 <edwardk> quackquack: there is also a quasiquoter syntax for them http://hackage.haskell.org/packages/archive/regexqq/latest/doc/html/src/Text-Regex-PCRE-QQ.html
14:05:50 <donri> if i have a set of records of the same algebraic type but with different fields, what's a simple way to get that field or otherwise a default for records without that field?
14:06:06 <edwardk> which gives you stuff like [$re|^([+-])?([0-9]+)\.([0-9]+)|]
14:06:14 <edwardk> er $rx
14:06:22 <quackquack> edwardk: ty, i will take a look at it
14:06:39 <erus`> donri: only some fields set?
14:06:40 <sm> I kind of miss native regexps too
14:06:56 <edwardk> its matt morrow code, so it may have bitrotted in the couple of years since he vanished from the community
14:07:00 <donri> erus`, different constructors have different record fields
14:07:07 <donri> erus`, but they're all of the same data type
14:07:36 <donri> some have "experimental" others not, `experimental x` throws error if x doesn't have the field
14:08:03 <erus`> ok i do not follow :P ask someone else
14:08:55 <donri> data Post = Blog { published::Bool } | Page;  published Page --> error
14:09:14 <donri> it's perfectly reasonable, I'd just like a way to do "get published or False" easily
14:09:20 <sm> donri, you have to pattern match, with a function or case
14:09:25 <tac-tics> donri: getPublished (Blog x) = x; getPublished _ = defaultValue
14:09:52 <tac-tics> donri: Slot functions on variant types are necessarily partial.
14:09:55 <donri> that's the only way? i have multiple constructors with that same field, so using the function would be useful
14:10:13 <byorgey> donri: there's some stuff in fclabels that mihgt be useful
14:10:13 <tac-tics> donri: It's kind of a dumb design decision, but Haskell's record syntax is pretty bad overall.
14:10:17 <byorgey> donri: see http://hackage.haskell.org/packages/archive/fclabels/1.0.4/doc/html/Data-Label-Maybe.html
14:10:47 <byorgey> "Lens type for situations in which the accessor functions can fail. This is useful, for example, when accessing fields in datatypes with multiple constructors. "
14:10:50 <byorgey> sounds like exactly what you want.
14:11:13 <donri> i'll have a look; still, i'd like to know a "native" way for the sake of it
14:11:18 <byorgey> and fclabels has Template Haskell code for automatically generating the lenses, of course.
14:11:33 <byorgey> donri: the only "native" way is what tac-tics said.
14:12:04 <byorgey> and ultimately that's the same thing fclabels is doing, it just has some TH magic to automate it for you
14:12:11 <slack1256> i dont really understand what is the problems with records
14:12:21 <slack1256> why people say are weird?
14:12:28 <donri> because errors can only be catched during IO right?
14:12:34 <tac-tics> slack1256: They are messy and hard to work with. Most importantly, they pollute the global name space.
14:12:44 <byorgey> donri: huh?
14:13:12 <tac-tics> slack1256: If you have data Point2 = Point2 {x :: Int, y :: Int}, you can't also have Point3 = Point3 {x :: Int, y :: Int, z :: Int}, because x is already a function x :: Point2 -> Int
14:13:35 <dcoutts> tac-tics: had an interesting discussion at ICFP about some improvements
14:13:37 <slack1256> but i think thats a feature
14:14:10 <sm> I like how the fclabels hackage page shows the release notes.. I think I'll do that again
14:14:22 <tac-tics> slack1256: It's a feature in the same way cancer is a feature of certain people.
14:14:34 <dcoutts> sm: note that the new server can show a changelog file
14:14:40 <sm> oh even better, yay
14:14:42 * tac-tics hates Haskell record syntax *that* *much*
14:14:44 <DanBurton> colah: http://stackoverflow.com/questions/7732594/a-ghci-session-without-prelude
14:14:57 <donri> byorgey, i mean what i want is something like catch (published post) (const False) without IO
14:15:11 <dcoutts> sm: which I think will become the preferred method since that could show up in rss feeds etc, rather than abusing the description
14:15:22 <slack1256> tactics: i *got* cancer
14:15:34 * sm notes fclabels has nice docs too.. added to must-try list, thanks byorgey 
14:15:39 <byorgey> donri: well, you can't have that, so I suggest changing what you want ;)
14:16:00 <dcoutts> tac-tics: about making record selectors not first class functions, allowing overlapping names
14:16:28 <tac-tics> dcoutts: Yes. That would be nice.
14:16:31 <donri> byorgey, I know, I'll use unsafePerformIO!
14:16:33 <donri> yay!
14:16:39 <tac-tics> dcoutts: Disciple has something like that.
14:16:53 <byorgey> donri: now you have two problems! yay!
14:17:01 <tac-tics> donri: The record syntax is so bad..... you can't even fix it with unsafePerformIO.....
14:17:05 <tromp> why were fields not qualified with record type, like Point2.x ?
14:17:08 <donri> that's alright, i'll throw in some regexp to solve the problems
14:17:15 <byorgey> hehehe
14:17:17 <dcoutts> tac-tics: the idea we were looking at had a syntax like a.x for selection, and 'x' there is a field name not any function
14:17:33 <tac-tics> tromp: That's not exactly any better :P
14:18:03 <tac-tics> dcoutts: yeah. That would be ideal. And like I said, disciple already has almost exactly that.
14:18:22 <tac-tics> Even in those cases, though, field selectors will still be partial, as per donri's question.
14:19:09 <dcoutts> tac-tics: though you can still make a function like: (\a -> a.x) ::  e { x :: r } => e -> r
14:19:12 <donri> oh you mean partial functions; i keep thinking of partial application when people use that word
14:19:33 <acowley> anyone have any recently-informed opinions on a good lens package?
14:19:40 <tac-tics> donri: Ah. No, partial meaning it's not defined properly at all points.
14:19:48 <acowley> (I haven't looked at them in several months)
14:19:51 <dcoutts> acowley: heh, good timing
14:19:58 <tac-tics> donri: In haskell, no one talks about partial evaluation, since currying is the default :)
14:20:00 <donri> yes, i know what it means i just confuse the two uses :)
14:20:30 <acowley> dcoutts: it's always a good time to ask about lenses on #haskell
14:20:31 <dcoutts> tac-tics: heh, if only it were that simple
14:20:43 <donri> is there anything good about haskell allowing partial functions / exceptions?
14:21:04 <tac-tics> donri: Yep. It means you don't have to prove your functions are total :)
14:21:14 <monochrom> @type fix unsafePerformIO
14:21:14 <lambdabot> Not in scope: `unsafePerformIO'
14:21:30 <monochrom> @type fix fromJust
14:21:31 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
14:21:31 <lambdabot>       Expected type: Maybe a
14:21:32 <lambdabot>       Inferred type: a
14:21:50 <donri> but isn't it typically better to wrap partialness in Maybe/Either or somesuch?
14:22:10 <dcoutts> donri: you can't really exclude partial functions without making it a completely different language
14:22:26 <monochrom> @quote monochrom linear.type
14:22:26 <lambdabot> No quotes match. You type like i drive.
14:22:30 <tac-tics> donri: In some languages, it isn't enough to write a function definition recursively. You have to define it recursively AND show that each recursion operates on something smaller than what called it. It's called structural recursion.
14:22:31 <dolio> Partial evaluation isn't the same thing as partial application.
14:22:38 <keep_learning> Hello all
14:22:44 <monochrom> onoes
14:22:48 <byorgey> hi keep_learning
14:22:48 <acowley> donri: the problem with demonstrating to a checker that your function is total is that it typically restricts your ability to use recursion
14:23:15 <donri> huh, 'kay
14:23:39 <monochrom> I write a proof of "this quantity decreases" to prove totality of my recursive functions. (it's also what Coq accepts.)
14:23:43 <dcoutts> byorgey: fixed http://www.haskell.org/cabal/code.html
14:23:51 <dcoutts> thanks for pointing it out
14:23:56 <acowley> monochrom is ready for the new total world order
14:24:31 <keep_learning> byorgey, i have a haskell file C.hs and its inside directory A/B . I have to write unit test for different functions in C.hs
14:24:40 <tac-tics> Coq and Agda, etc are funny, because even functions like division can't be total
14:24:43 <byorgey> dcoutts: great, thanks
14:24:54 <byorgey> keep_learning: ok
14:24:56 <monochrom> generally, I accept well-founded recursion as total, well-defined, etc. and my philosophical stance is that I accept nothing else, but I don't have enough evidence to back it up.
14:24:59 <copumpkin> tac-tics: depends on your types!
14:25:01 <copumpkin> and your meanings!
14:25:10 <tac-tics> copumpkin: You punner you :D
14:25:26 <dcoutts> bah, inductive programming is passé, co-inductive ftw!
14:25:40 * tac-tics is stauntly against coinduction. 
14:25:43 <keep_learning> in C.hs ,  import A.B.C where  some function definition . Now my test.hs function should also be in B directory ?
14:25:55 <copumpkin> tac-tics: this is the wrong channel for you then!
14:25:55 <monochrom> Coq certainly lets you write "divide :: number -> nonzero number -> number"
14:26:01 <tac-tics> Coinduction flies in the face of my personal system of morphisms
14:26:10 <dcoutts> heh heh
14:26:29 <byorgey> keep_learning: you can either put it in B directory and say 'import C' or you can put it in the root directory and say 'import A.B.c'
14:26:34 <byorgey> *A.B.C
14:26:44 <dcoutts> coinduction is prefectly reasonable in a total programming language
14:26:47 <byorgey> keep_learning: wait, no, the first one won't work actually
14:26:47 <tac-tics> copumpkin: I can't help it. If Ocaml were as popular as Haskell, I'd probably be there instead.
14:26:54 <byorgey> keep_learning: you have to put it in the root directory
14:26:56 <Jeanne-Kamikaze> do we have joel burget in here ?
14:27:00 <monochrom> coinduction is for coworkers
14:27:24 <copumpkin> coinduction is for cotransformers
14:27:25 <tac-tics> dcoutts: It's more that I had to fight hard to build up an understanding of induction. I have no idea where I'd learn how co-induction fits in....
14:27:36 <keep_learning> byorgey, thank you
14:27:36 <desaiu> Someone mentioned that YAHT is outdated because of the do statements? I don't understand.
14:27:38 * tac-tics wants to write a dependent types blog
14:27:44 <acowley> coinduction flying into your face sounds like a Sisyphean punishment
14:27:45 <dcoutts> tac-tics: it's just unfoldings
14:27:47 * tac-tics wants to become a dependent type monk
14:28:11 <desaiu> What did the Haskell 2010 report do with do/if/then/else statements?
14:28:17 <acowley> so nobody wants to tell me to data-lens instead of fclabels?
14:28:22 <acowley> s/to/to use
14:28:25 <dcoutts> tac-tics: e.g. take a productive process and unfold its (possibly infinite) tree of actions
14:28:38 <sm> dcoutts: do you want --lazy instead of --partial on that page ? I think modern darcs doesn't support --partial, and hopefully --lazy does the right thing even if the repo is old format (which hopefully it isn't)
14:28:41 <monochrom> induction flies out of your face like in the movie Alien
14:28:46 <dcoutts> tac-tics: or infinite streams are coinductive
14:28:59 <byorgey> desaiu: it made the grammar slightly more permissive, so there are ways to indent if-then-else expressions in do-blocks which used to be an error and are now accepted
14:29:23 <dcoutts> sm: try refreshing your browser cache, I deleted the --partial entirely
14:29:25 <acowley> I'd rather be punished inductively
14:29:31 <sm> cool
14:29:32 <dcoutts> sm: I think --lazy is the default anyway
14:29:42 <desaiu> \t is for tab right?
14:29:54 <byorgey> desaiu: yes
14:29:55 <desaiu> typical ascii tab character
14:29:56 <desaiu> okay
14:29:58 <sm> hmm I don't think --lazy is default
14:30:11 <tac-tics> dcoutts: I'd need to see some code examples in a blog.
14:30:19 <trinithis> > turtles
14:30:20 <byorgey> desaiu: see http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
14:30:20 <lambdabot>   "It's turtles all the way down."
14:30:24 <tac-tics> But a blog without talking about f***ing categories
14:30:49 <desaiu> I usually space my if then else statements like this: if \n \t then \n else \n elseif
14:30:55 <desaiu> I forget if elseif is in the language
14:31:24 <tac-tics> > take 100 $ foldr (++) "" (repeat turtles)
14:31:26 <lambdabot>   "It's turtles all the way down.It's turtles all the way down.It's turtles a...
14:31:30 <trinithis> lol
14:31:36 <byorgey> desaiu: it is not.
14:31:42 <desaiu> else do is what I meant
14:31:50 <acowley> last lens question: has anyone written fclabels-style TH support for data-lens?
14:31:58 <desaiu> if \n \t then \n else do
14:31:59 <byorgey> desaiu: but yes, lining up then and else, with both indented more than the if, is good style for haskell
14:32:02 <dcoutts> tac-tics: see if you can find a copy online of "A note on categorical datatypes" by G. C. Wralth
14:32:05 <jeffcutsinger> tac-tics, http://www.jucs.org/jucs_10_7/total_functional_programming is a decently gentle introduction to the idea. PDF though.
14:32:26 <alpounet> acowley, like http://hackage.haskell.org/package/data-lens-template ?
14:32:27 <tac-tics> jeffcutsinger: They're all pdfs. Thanks though :D
14:32:33 <desaiu> Yeah, I guess my indentation is off now that I think of it
14:32:57 <jeffcutsinger> tac-tics, except when they're postscript :P
14:33:06 <desaiu> else one spaced tab to the right of if
14:33:13 * tac-tics shudders at postscript papers
14:33:30 <acowley> appamatto: that sounds right! Thanks. The build failure on 7.2 will be fun...
14:33:43 <dcoutts> tac-tics: ah, try this one http://www.cs.ox.ac.uk/jeremy.gibbons/publications/adt.pdf
14:33:50 <tac-tics> I will read this in detail once I don't feel like doing a good job at work
14:35:02 <acowley> Ah, I seem to have just cabal installed edwardk
14:35:09 <acowley> his web ensnared me
14:35:13 <monochrom> haha
14:35:14 <edwardk> muahahaha
14:35:49 <edwardk> tempted to make that an actual package ;)
14:36:08 <edwardk> trifecta?
14:37:45 <kmc> hahaha
14:37:55 <acowley> edwardk: I already have a bug report!
14:37:57 <kmc> yeah, there should be an edwardk metapackage
14:38:16 <edwardk> acowley: for which package on which version of ghc?
14:38:29 <alpounet> kmc, and cabal shouldn't even mention haddock trying to build any documentation for them
14:38:30 <acowley> edwardk: "...only generated for fields ending with an underscore" in an error message
14:38:43 <acowley> edwardk: data-lens-template
14:38:58 <acowley> edwardk: the underscore goes at the beginning of the name
14:39:00 <edwardk> acowley: ah, the snap guys missed that comment when patching it to flip it around =)
14:39:38 <Bummi> Helluu, I have a beginner's question if someone care to answer
14:39:50 <ciaranm> Bummi: cut the red wire first
14:39:59 <acowley> if that fails, try the blue one
14:40:25 <acowley> if *that* fails, just roll back the transaction
14:40:30 <edwardk> fixed
14:40:36 <acowley> edwardk: ty!
14:40:41 <kmc> cut all the wires
14:40:58 <kmc> Bummi, you should just ask your question :)
14:40:58 <Bummi> I know you can't modify variables and you should use recursion to do the business
14:41:06 <Bummi> but
14:41:15 <Bummi> 1sec need to write :p
14:42:02 <acowley> hmm, it will be some time before I have muscle memory for quickly typing ^%=
14:42:35 <Bummi> say if, I want to do a super simple game where two players have a pile of pebbles (21 or something), then they take turn in removing 1,2 or 3
14:42:46 <Bummi> how do i update the pebbles thingi
14:42:54 <Bummi> with recursion?
14:42:59 <Bummi> i feel brainfucked
14:43:21 <ciaranm> you don't update. you pass around a modified pebbles thing.
14:43:27 <tac-tics> Bummi: First, it's #haskell, so you don't update :)
14:43:29 <ciaranm> or you use state. but you don't want to do that.
14:43:31 <acowley> each step in the game takes one state of the game and produces a new one
14:44:02 <hvr> where can I find some introduction to "digestive functors"?
14:44:09 <Bummi> aaa... omg I feel messed up now
14:44:17 <alpounet> hvr, jasper had published a blog post or two about them, didn't he ?
14:44:49 <hvr> alpounet: have any url?
14:44:57 * hackagebot data-lens-template 2.1.2 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.1.2 (EdwardKmett)
14:45:03 <alpounet> hvr, http://jaspervdj.be/posts/2010-12-09-digestive-functors-0.0.2.html ?
14:45:07 <tac-tics> Bummi: takeTurn :: Int -> PebbleAmount -> PebbleAmount; takeTurn n amount = amount - n
14:45:19 <hvr> alpounet: thx, exactly what I was looking for :-)
14:45:33 <alpounet> hvr, just saw the "UPDATE" at the top of the blog post though
14:45:44 <DukeDave> Bummi: Just imagine you don't have an eraser (or you wrote in pen), you can't erase the previous value to 'update' it, so you just use another part of the paper..
14:45:53 <alpounet> hvr, https://github.com/jaspervdj/digestive-functors/blob/master/examples/Snap.lhs for the up-to-date version apparently
14:46:15 <edwardk> well i think the main thing to note about digestive functors is that they have nothing to do with digestion and few if any of them are functors ;)
14:46:22 <phasip> Hello, Is there a nice way to create all combinations of two elements from a list or set? eg [1,2,3] -> [[1,2],[2,3],[1,3]]
14:46:29 <Bummi> yeah i try to think like that but still
14:46:38 <DukeDave> If you're playing scrabble for example, you (or at least, I) don't erase my score each time, I just write the new one underneath each time
14:46:53 <kmc> > replicateM 2 [1,2,3]
14:46:54 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
14:47:05 <DukeDave> Unfortunately some has yet to invent self garbage collecting paper, but the principle is similar..
14:47:21 <Bummi> :)
14:47:21 <edwardk> hvr: http://jaspervdj.be/tmp/digestive-functors.pdf
14:47:48 <phasip> so I should use replicatem and then remove all "bad" permutations ?
14:47:50 <DukeDave> Bummi: Try not to think about "where" to put things, think about "how" you get from one state to the next
14:48:15 <DukeDave> (someone may scream at my use of the word 'state'..)
14:48:17 <hpaste_> “Mukesh Tiwari” pasted “hunit testing” at http://hpaste.org/52478
14:48:18 <Quantumplation> phasip: yea, i just read about this.  [1,2,3] <*> [1, 2, 3] works, and you can even change the second list
14:48:19 <acowley> yeah I never understood the genesis of the digestive functors name
14:48:21 <Bummi> I guess I have to re-structure my code. I think I'm stuck
14:48:26 <Daegalus> Can you do something like this? unweave x = [ y | y <- [1,3,5...(length x)]] -- i am most likely doing something dumb.
14:48:30 <Quantumplation> > [1,2,3] <*> [1,2,3]
14:48:31 <lambdabot>   [1,1,1,2,2,2,3,3,3]
14:48:31 <hvr> edwardk: what motivates 'digestive functors' being called that way?
14:48:34 <Quantumplation> er, nvm
14:48:41 <ion> Caleskell strikes again.
14:48:47 <ion> > 3 4
14:48:47 <lambdabot>   3
14:48:50 <edwardk> hvr: you'd have to ask jasper. the name gives me indigestion ;)
14:48:53 <keep_learning> Could some one please tell me why this Hunit testing is not working . http://hpaste.org/52478
14:48:54 <ion> > (3 + sin) 4
14:48:55 <lambdabot>   2.2431975046920716
14:49:20 <keep_learning> 3 + sin 4
14:49:28 <keep_learning> > 3 + sin 4
14:49:29 <lambdabot>   2.2431975046920716
14:49:44 <Quantumplation> > sequenceA [[1,2,3],[1,2,3]]
14:49:45 <lambdabot>   Not in scope: `sequenceA'
14:50:09 <ciaranm> > ((sin * sin) + (cos * cos)) 42
14:50:10 <lambdabot>   1.0
14:50:13 <Quantumplation> > sequence [[1,2,3],[1,2,3]]
14:50:14 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
14:50:17 <Quantumplation> there we go
14:50:45 <ion> > (sin^2 + cos^2) 42
14:50:46 <lambdabot>   1.0
14:51:04 <cgroza> > 2 +
14:51:04 <DukeDave> Bummi: It might help to imagine that you have all the inputs for the game already.. If it's a two player game where people each choose a number (1, 2 or 3) then that's just a list [1,3,2,1,3,1,2,2,...]. Get the game logic working with that first.
14:51:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:51:38 <ciaranm> just which crazy module is the bot getting that stuff from?
14:51:40 <engla> phasip: let t xs = [[x,y] | x <- xs, y <- xs, x < y]
14:52:02 <keep_learning> any one please .
14:52:35 <edwardk> ciaranm: thats a bunch of rnadom caleskel for dealing with instance Num a => Num (e -> a), etc that is baked into lambdabot
14:52:44 <Bummi> thanks for the help guys ( DukeDave, tac-tics, acowley) My brain is having a meltdown but I'll try to think about what you said
14:52:47 <phasip> Whow engla!
14:52:51 <phasip> Love it =)
14:53:01 <edwardk> ciaranm: various packages (like conal's vector-space) provide those definitions as well
14:53:20 <Bummi> DukeDave: But if I want to number of pebbles as output between each turn?
14:53:37 <Bummi> want the number of pebbles*
14:53:42 <ciaranm> edwardk: ah, thanks. i implemented something similar a few weeks back for the purposes of making some code much more confusing...
14:53:58 <tromp> @let bitstrings = flip replicateM "01"
14:53:59 <lambdabot>  Defined.
14:54:08 <edwardk> conal's beautiful differentiation posts make good use of it
14:54:24 <tromp> > bitstrings 3
14:54:25 <lambdabot>   ["000","001","010","011","100","101","110","111"]
14:54:31 <hpaste_> DukeDave pasted “Lenses, simply” at http://hpaste.org/52479
14:54:36 <edwardk> > bitstrings 200
14:54:37 <lambdabot>   ["0000000000000000000000000000000000000000000000000000000000000000000000000...
14:54:49 <DukeDave> While we're on lenses, what do people think about that^
14:54:57 <tromp> that;s a long list
14:55:33 <DukeDave> I'm refactoring something, and I have a pattern where lenses would be appropriate, but I don't know if they're just overkill..
14:55:56 <kmc> overkill how? what's the downside?
14:55:57 <edwardk> DukeDave: lenses are just a pair of functions like get :: a -> b and a set ::  b -> a -> a. the typeclass you gave is one way to make a 'lens-like thing' but you can't compose those instances very well
14:56:20 <edwardk> whereas if they are made out of data you can use a Category to compose them, etc.
14:56:23 <donri> is there some easy way to "inline" a generated data structure at compile time?
14:56:31 <edwardk> data Lens a b = Lens (a -> b) (b -> a -> a)
14:56:33 <kmc> donri, Template Haskell?
14:56:36 <kmc> what do you want exactly?
14:56:42 <edwardk> get (Lens g _) = g
14:56:47 <edwardk> set (Lens _ s) = s
14:57:13 <edwardk> then you can define combinators like (.) :: Lens b c -> Lens a b -> Lens a c
14:57:17 <donri> i'm reading an XML file into haskell data types, I'd like to do that at compile time and "bundle" the result in the binary
14:57:19 <DukeDave> Bummi: Well, how do I work out how many people are left after someone plays a move? Is it just subtracting the number they play?
14:57:37 <keep_learning> byorgey, hi , could you tell me why this hunit test is not working . http://hpaste.org/52478
14:58:04 <kmc> donri, okay, you can do that with TH
14:59:40 <DukeDave> kmc: Read overkill as overcomplicate
14:59:41 <Bummi> DukeDave: The game is like this: We start with 21 pebbles. Player 1 removes 1, 2 or 3 pebbles. Then Player 2 removes 1, 2 or 3. This process repeats until no pebbles are left, the loser is the one removing the last pebble. I want to show how many pebbles are left each turn
14:59:56 <kmc> DukeDave, complicated to use, or complicated in ways which are hidden?
15:00:02 <kmc> 'cause I don't think lenses are very complicated to use
15:00:10 <kmc> though it does raise the barrier for understanding your code
15:00:14 <DukeDave> kmc: To use, and for readability of others
15:00:14 <kmc> every external library dependency does
15:00:37 <kmc> in general I think 'overkill' objections are pretty silly
15:00:54 <kmc> the point of a powerful tool is that you don't need all its power in every circumstance
15:01:54 <DukeDave> kmc: I'm considering lenses because I have three data structures which need to be synchronised, and the synchronisation step is silly and bug prone. I'd rather have one underlying data structure and expose the necessary parts of it such that it 'appears' as three distinct structures.
15:01:58 <hpaste_> monochrom pasted “guessing game: introductory example” at http://hpaste.org/52480
15:03:16 <Bummi> DukeDave: Or nvm, I think I got it. Thanks for the help
15:03:36 <monochrom> Bummi: perhaps you will enjoy my paste, just posted above
15:03:41 <donri> kmc, any particular pointers?
15:04:05 <kmc> not really, just read about Template Haskell
15:04:08 <Bummi> monochrom sorry, i dont see any?
15:04:13 <kmc> the original TH paper is good (though GHC does not implement all of it)
15:04:17 <monochrom> http://hpaste.org/52480
15:04:24 <kmc> you can execute arbitrary code at compile time, including IO
15:04:36 <kmc> and produce a value of an algebraic data type representing Haskell code
15:04:47 <kmc> and said code gets spliced into the program being compiled
15:04:59 <Bummi> monochrom thanks! I'll check it out
15:05:04 <kmc> there's an overloaded function 'lift' which turns a (compile-time) Haskell value into Haskell syntax for a literal of that value
15:05:08 <kmc> that might be useful
15:05:22 <kmc> TH is fairly cumbersome but really powerful
15:05:48 <monochrom> I used to say "use TH to play a movie while waiting for compilation"
15:06:08 <donri> aye thanks
15:06:09 <monochrom> now I say "use TH to run a PHP script that outputs a haskell program" :)
15:08:05 <sm> donri: see the file-embed package or the embed in yesod-static
15:08:45 * monochrom is writing a haskell program that inputs and outputs xml; the input xml may include a #! script to be run for more xml to be included in the output
15:08:59 <sm> or the static in yesod-static, I guess
15:09:18 <sm> one of those
15:10:49 <jgeene> anyone have a recomendation for a library to do image resizing with transparency?
15:11:28 <donri> cool thanks
15:12:58 <Daegalus> How woudl I got about doing something like this: [50..70] !! [1,3..20] -- in sense , how do i pull out all the odd values from the first array.
15:13:07 <Daegalus> err odd indexes
15:13:12 <kmc> Daegalus, not an array, a list
15:13:18 <Daegalus> well list yes
15:13:25 <kmc> and doing it that way is going to be slow, quadratically slow
15:13:31 <kmc> which is probably enough that I should warn you up front :)
15:13:33 <Daegalus> well it doesnt work to begin with
15:13:42 <kmc> odds (x:_:xs) = x : odds xs; odds _ = []
15:13:51 <Veinor> what kmc said
15:14:01 <tromp> jgeene: http://linux.die.net/man/1/convert
15:14:21 <Daegalus> So use recursion?
15:14:23 <kmc> yeah, I would shell out to netpnm or imagemagick
15:14:31 <kmc> Daegalus, it's probably the simplest way
15:14:47 <Daegalus> kmc: ok thank you, sorry for the noob questions, just getting started with Haskell
15:14:52 <kmc> noob questions are great!
15:15:42 <tac-tics> @let filterOdds (x:y:xs) = x : filterOdds xs; filterOdds _ = []
15:15:43 <lambdabot>  Defined.
15:15:49 <tac-tics> > filterOdds [1..20]
15:15:51 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
15:16:12 <tac-tics> ah yeah, that's essentially what kmc put
15:17:58 <hvr> why not simply   "filter even [50..70]"? =)
15:18:22 <hvr> (or s/even/odd/ depending on which values are wanted)
15:18:42 <Daegalus> because its not the Even values of the list, but the even indexes
15:18:43 <kmc> > catMaybes $ zipWith ($) (cycle [Just, const Nothing]) [1..20]
15:18:54 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
15:18:56 <tac-tics> hvr: that filters on the value, not the index
15:18:56 <hvr> Daegalus: right
15:19:13 <copumpkin> I wish we could have overlapping type families
15:19:25 <kmc> > map snd . filter (even . fst) . zip [0..] $ [1..20]
15:19:26 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
15:19:43 <kmc> there are various cute ways to do it
15:19:50 <kmc> but I think the direct recursion is clearest
15:19:52 <copumpkin> or can we?
15:19:53 <hvr> Daegalus: map snd $ filter (odd . fst) $ zip [0..] [50..70]
15:20:11 <copumpkin> I want to write last on a type-level list represented as nested tuples terminated by ()
15:21:00 <copumpkin> @src last
15:21:00 <lambdabot> last [x]    = x
15:21:01 <lambdabot> last (_:xs) = last xs
15:21:01 <lambdabot> last []     = undefined
15:21:30 <hvr> Daegalus: or even [ v | (i,v) <- zip [0..] [50..70], odd i ]
15:21:36 <kmc> > [50,52..70]
15:21:37 <lambdabot>   [50,52,54,56,58,60,62,64,66,68,70]
15:21:48 <tac-tics> Fancy lambdabot, defining last [] as undefined....
15:22:00 <kmc> as opposed to?
15:22:10 <kmc> > last []
15:22:10 <lambdabot>   *Exception: Prelude.last: empty list
15:22:11 <tac-tics> leaving it implied like a lazy programmer
15:22:25 <kmc> heh
15:22:28 <hpaste_> Daegalus pasted “unweave” at http://hpaste.org/52481
15:22:31 <kmc> but then GHC will give a warning!
15:22:41 <Daegalus> kmc: would something like that work?
15:22:58 <kmc> Daegalus, did you try it?
15:23:21 <kmc> i'm not sure you should use 'tail' here, it is after all undefined on []
15:23:33 <Daegalus> no because I am having trouble in Hugs with every function I enter with  (unexpected end of input)
15:23:40 <kmc> unweave x@(_:xt) = (filterOther x, filterOther xt)
15:23:50 <kmc> there's also a way to build both those lists in one pass, so to speak
15:24:07 <tac-tics> Daegalus: close your damn parentheses please :)
15:24:16 <kmc> you don't need so many parens anyway
15:24:24 <akosch> can someone explain liftIO to me please?
15:24:29 <tac-tics> kmc: It looks like he needs one more than he has :)
15:24:32 <tac-tics> but yeah
15:24:34 <kmc> akosch, lets you run an IO action inside a monad which is a transformer over IO
15:24:38 <Daegalus> well this is technically homework, so i probably should stop asking specifics otherwise you wil pretty much be doing a bit of it
15:24:58 * hackagebot monadacme 0.0.1 - The Acme and AcmeT monads.  http://hackage.haskell.org/package/monadacme-0.0.1 (ThomasEding)
15:26:00 <kmc> > let alt (x:y:zs) = (let (xs,ys) = alt zs in (x:xs, y:ys)); alt _ = ([],[]) in alt "like so Daegalus"
15:26:01 <lambdabot>   ("lk oDeau","ies agls")
15:26:55 <akosch> kmc: I just used it for "Iteratee x IO y" and it worked. Does this mean that Iteratee embeds IO?
15:27:03 <kmc> > let alt (x:y:zs) = case alt zs of ~(xs,ys) -> (x:xs, y:ys); alt _ = ([],[]) in alt "like so Daegalus"
15:27:04 <lambdabot>   <no location info>: Parse error in pattern
15:27:12 <kmc> akosch, it means that Iteratee x IO does
15:27:19 <kmc> (Iteratee x) is a monad transformer
15:27:45 <imc> \o/ ! haskellmode.vim
15:28:17 <akosch> kmc: got it, thank you for your help
15:28:27 <kmc> :)
15:29:37 <kmc> maybe you want alt xs = (xs,[]) instead
15:29:45 <kmc> of alt _ = ([],[])
15:30:14 <Daegalus> Ok, i kinda get it
15:30:22 <Daegalus> now Im trying to adapt it to my unweave function
15:30:47 <platzhirsch> Do you use tabbing to indent your indentions, for instance where, deriving, etc? I am asking, because I would like to know how many characters you use for indention
15:30:59 <kmc> platzhirsch, i use 4 usually, 2 occasionally
15:31:06 <kmc> but you should never use actual tab characters
15:31:35 <kmc> because they will render differently in different editors, but only one of those is actually the way Haskell interprets them
15:32:06 <benmachine> I indent things strangely
15:32:16 <benmachine> I use two for most things but more or less when I think it looks prettier
15:32:17 <platzhirsch> I knew someone would hint me to this, hehe
15:32:54 <DukeDave> Mmm, http://en.wikipedia.org/wiki/Whitespace_(programming_language)
15:33:21 <Daegalus> kmc, do you know why any time i try to define a function in hugs, it keeps saying "unxpected end of input". Like "let filterOther (x:_:xs) = x : filterOther xs"
15:33:39 <kmc> no
15:33:51 <kmc> if it's in a file, you leave off the "let"
15:33:55 <mauke> I do
15:34:00 <mauke> you can't define stuff in hugs
15:34:01 <Daegalus> no im mean in the repl
15:34:14 <Daegalus> that makes sense
15:34:19 <Daegalus> worked in GHC
15:34:21 <kmc> you can in ghci
15:34:22 <kmc> yeah
15:35:50 <FUZxxl> @pf
15:35:50 <lambdabot> Maybe you meant: bf pl
15:35:58 <FUZxxl> @pointful
15:35:58 <lambdabot> ()
15:36:03 <FUZxxl> @pointful ap (const ap) const
15:36:03 <lambdabot> ((\ _ l m -> l >>= \ j -> m >>= \ i -> return (j i)) >>= \ d -> (\ b _ -> b) >>= \ c -> return (d c))
15:36:07 <FUZxxl> wtf
15:36:21 <kmc> @unpl ap (const ap) const
15:36:21 <FUZxxl> > :t ap (const ap) const
15:36:21 <lambdabot> ((\ _ l m -> l >>= \ j -> m >>= \ i -> return (j i)) >>= \ d -> (\ b _ -> b) >>= \ c -> return (d c))
15:36:22 <lambdabot>   <no location info>: parse error on input `:'
15:36:28 <FUZxxl> :t ap (const ap) const
15:36:29 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a) -> b1 -> b
15:36:38 <FUZxxl> ah
15:36:43 <benmachine> @. djinn type ap (const ap) const
15:36:44 <lambdabot> f a b c = a (b c)
15:36:45 <FUZxxl> so ap (const ap) const == id
15:36:57 <benmachine> ...no
15:37:02 <FUZxxl> so ap (const ap) const == (.)
15:37:05 <FUZxxl> sorry...
15:37:07 <benmachine> seems like it, yes
15:37:20 <benmachine> :t (.) `asTypeOf` ap (const ap) const
15:37:21 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a) -> b1 -> b
15:37:28 <kmc> S(KS)K
15:37:32 <FUZxxl> is there a package that can convert lambda expressions into combinatory logic?
15:37:51 <benmachine> pointfree can sorta do it
15:37:52 <FUZxxl> kmc: yeah
15:38:00 <benmachine> but it's not a library, just an executable
15:38:06 <benmachine> I'd make it a library only I don't understand the code :P
15:38:29 <FUZxxl> benmachine: But the problem is, that pointfree uses different combinators.
15:38:42 <DukeDave> So, here's a design question: I was 'bad' and wrote some code to who's types all have "Data.Map i v", but now I'd like to be 'good' and hide the map behind an interface. I'm going to write a class for this interface, and I have something like "class Data m i v", where 'm' is the model which contains the map (or perhaps not!) and 'i' and 'v' are the key/value types. Does this sound sensible?
15:38:51 <benmachine> FUZxxl: sure, but then you're just reducing to the problem of defining pointfree's combinators
15:39:02 <kmc> why a class?
15:39:04 <benmachine> which are a finite set, and not a large one :P
15:39:26 <FUZxxl> benmachine: K and S ought to be enough for anyone. (Or X) :D
15:39:34 <DukeDave> kmc: Well this is why I was asking about lenses earlier
15:39:37 <FUZxxl> K == const
15:39:39 <syntaxfree> There are two pointfree combinators, S and K.
15:39:46 <FUZxxl> S == ap for (a ->)
15:39:46 <kmc> DukeDave, why not just «newtype Thing i v = Thing (Map i v)»
15:40:05 <FUZxxl> S == ap                             (for (a ->))
15:40:23 <syntaxfree> lambdabot's pointfree styling exploits monadic functions too much methinks. But well, it's a fine piece of AI
15:40:25 <syntaxfree> :t ap
15:40:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:40:39 <benmachine> syntaxfree: in what sense are there two pointfree combinators?
15:41:08 <syntaxfree> benmachine: in the same sense there is one number and one operation.
15:41:09 <benmachine> syntaxfree: I mean, you *can* use two combinators
15:41:22 <syntaxfree> "One" and "next".
15:41:29 <kmc> there are lots of different complete bases for the lambda calculus
15:41:33 <kmc> {S, K} is one of them
15:41:34 <benmachine> syntaxfree: there is one pointfree combinator
15:41:45 <benmachine> X ≡ λx.((xS)K)
15:41:59 <benmachine> according to wikipedia you can recover both S and K from there
15:42:03 <kmc> how?
15:42:09 <benmachine>        X (X (X X)) =ηβ K and
15:42:10 <benmachine>        X (X (X (X X))) =ηβ S.
15:42:16 <kmc> haha
15:42:19 <kmc> baller
15:42:24 <DukeDave> kmc: Well here's the underlying problem: I have two modules, each which do 'stuff', presently each module has its own 'model', each comprising of a Map, then I have a 'synchronise' function (which is ugly) to ensure the two models are consistent.
15:42:32 <FUZxxl> Where '=ηβ' means equal under beta and eta reduction
15:42:45 <syntaxfree> I'm going to take that on faith. I'm learning how to do cute tricks with pointers in C. It's such a weird language, and I understand cat theoretical monads.
15:42:55 <DukeDave> I'd like to have one Map underlying both models, but I don't want to pollute each module with this underlying model
15:42:59 <kmc> is η-reduction the opposite of η-expansion?
15:43:14 <DukeDave> In some sense I'd like each module to have a 'lens' on the underlying model
15:43:17 <benmachine> :t let x x = x ap const in x (x (x x))
15:43:18 <lambdabot>     Occurs check: cannot construct the infinite type: a = b1 -> a -> b
15:43:18 <lambdabot>       Expected type: ((b1 -> a -> b) -> (b1 -> a) -> b1 -> b)
15:43:18 <lambdabot>                      -> ((b1 -> a -> b) -> b1 -> a)
15:43:22 <benmachine> oh :(
15:43:23 <FUZxxl> Is it possible that there are two functions in the lambda calculus that always return the same input but are not reducible to each other in terms of alpha, beta and eta-reduction?
15:44:12 <benmachine> FUZxxl: I think I would be surprised if the answer was no
15:44:18 <benmachine> although
15:44:26 <BMeph> FUZxxl: Use the Applicative instance for Reader, and you get: k = pure; S = (<*>). ;)
15:44:32 <benmachine> one could argue that proving they always return the same input is equivalent to
15:44:39 <benmachine> basically, I don't know >_>
15:44:52 <DukeDave> kmc: Context: It's a UI, and there's one module which lays things out, and one which handles user dragging things.
15:45:01 <syntaxfree> proving extensional equivalence rather than intensional equivalence?
15:45:02 <FUZxxl> benmachine: If the answer would be "no", the decision problem would be just NP-hard...
15:45:20 <syntaxfree> this is the first time I get to use "intensional" in a sentence. I hope I got it right.
15:45:28 <benmachine> FUZxxl: really?
15:45:46 <FUZxxl> benmachine: (You could just use a nondeterministic turing machine that, if there are multiple reductions possible, applies one of them in any branch.
15:46:11 <benmachine> FUZxxl: sure, but how would it prove that things were not reducible to each other?
15:46:23 <benmachine> it could only prove that they were
15:46:28 <medfly> hello, cabal update is complaining I need to cabal install cabal-install repeatedly. wat do? http://pastebin.com/MDXGaUQd
15:46:30 <mauke> The paste MDXGaUQd has been copied to http://hpaste.org/52482
15:46:37 <FUZxxl> benmachine: It won't halt.
15:46:56 <FUZxxl> Maybe my statement was not true.
15:47:05 <benmachine> FUZxxl: ...that takes longer than NP time :P
15:47:13 <syntaxfree> FUZxxl just stated the Fuzzy Liar Paradox.
15:47:26 <FUZxxl> syntaxfree: What is that?
15:47:28 <benmachine> medfly: try 'which cabal' and make sure it is running the one you just installed
15:47:30 <syntaxfree> Maybe I lie all the time. Maybe I like p% of the time. Maybe I don't.
15:47:40 <FUZxxl> :P
15:47:53 <FUZxxl> benmachine: Isn't that ... kind of "semi decidable"?
15:47:53 <syntaxfree> FUZxxl: just made it up. The "crisp" liar paradox you know, I assume.
15:47:56 <FUZxxl> Oh yes.
15:48:01 <FUZxxl> It would be.
15:48:11 <benmachine> FUZxxl: sure. I'm not sure if that leads to a contradiction
15:48:17 <syntaxfree> the fun thing about the Fuzzy Liar Paradox is that it's amenable to bayesian inference.
15:48:29 <FUZxxl> Since you can enumerate all lambda terms (I am sure you can), one can simply test each input.
15:49:04 <FUZxxl> In the case, that both terms are different, the machine will eventually halt.
15:49:15 <FUZxxl> (Povided that the evaluation terminates)
15:49:24 <FUZxxl> (Which requires solving the halting problem)
15:49:31 <FUZxxl> x_x
15:49:32 <benmachine> FUZxxl: you've lost me a bit, but I'm too tired to argue at this point :P
15:49:44 <akosch> do I have to unpack and pack to convert from ByteString to lazy ByteString?
15:50:00 * hackagebot monadacme 0.0.2 - The Acme and AcmeT monads.  http://hackage.haskell.org/package/monadacme-0.0.2 (ThomasEding)
15:50:05 <FUZxxl> akosch: There are conversion functions somewhere
15:50:17 <FUZxxl> @hoogle Data.ByteString -> Data.ByteString.Lazy
15:50:18 <lambdabot> Parse error:
15:50:18 <lambdabot>   --count=20 "Data.ByteString -> Data.ByteString.Lazy"
15:50:18 <lambdabot>                  ^
15:51:04 <FUZxxl> umpf...
15:51:05 <medfly> benmachine: well for some unclear reason it is putting the new executable on my home dir.
15:51:19 <FUZxxl> It seems that hoogle is incapable of referring to qualified names.
15:51:43 <benmachine> medfly: that seems sensible; cabal likes running without root
15:51:46 <DukeDave> Anyone else?  So, here's a design question: I was 'bad' and wrote some code to who's types all have "Data.Map i v", but now I'd like to be 'good' and hide the map behind an interface. I'm going to write a class for this interface, and I have something like "class Data m i v", where 'm' is the model which contains the map (or perhaps not!) and 'i' and 'v' are the key/value types. Does this sound sensible?
15:52:02 <benmachine> medfly: you can use cabal install --global but ime that makes things much harder to fix if they all go horribly wrong :)
15:52:05 <syntaxfree> I wonder if vulcans are going to visit us when we've figured out either the Church-Turing thesis or sufficiently good probabilistic analysis of halting problems.
15:52:10 <benmachine> medfly: or you could manually install the thing yourself
15:52:15 <FUZxxl> akosch: Okay. You can use fromChunks and toChunks combined with concat.
15:52:16 <benmachine> medfly: or you could just add the thing to your path
15:52:19 <akosch> FUZxxl: yeah, it says unexpected "." expecting "forall", "(", "[", "!" or end of input Bad symbol
15:52:31 <FUZxxl> akosch: I doubt that there is a faster way.
15:53:14 <akosch> FUZxxl: ok, thanks
15:53:31 <FUZxxl> So lazyBStoStrictBS = foldr1 empty . toChunks
15:53:37 <FUZxxl> and the other way round:
15:53:51 <FUZxxl> strictBStoLazyBS = fromChunks . return
15:54:02 <FUZxxl> no no
15:54:25 <FUZxxl> So lazyBStoStrictBS = foldr append empty . toChunks
15:54:37 <medfly> benmachine: even when I use sudo.
15:54:48 <benmachine> medfly: don't use 'sudo cabal whatever'
15:54:58 <benmachine> medfly: set root-cmd: sudo in your ~/.cabal/config
15:55:09 <benmachine> medfly: and then run as your user; cabal will elevate when it needs to
15:55:22 <benmachine> medfly: it's --user or --global that determine where stuff goes
15:55:35 <medfly> I know this sounds sensible when you say it, but I'm updating the dang program >.<
15:55:54 <benmachine> I do not understand your complaint :P
15:56:18 <mercury^> Why does it not default to sudo?
15:56:26 <benmachine> mercury^: why should it?
15:56:37 <benmachine> it's configurable, if that's what you want to do
15:56:47 <benmachine> but it's easier to avoid breaking things if you default to user installs
15:56:48 <mercury^> Because that will almost always be what people will enter.
15:56:50 <benmachine> plus it doesn't need root
15:57:02 <benmachine> mercury^: oh, you mean root-cmd?
15:57:04 <mercury^> Yes.
15:57:08 <benmachine> that I don't know; maybe it does
15:58:44 <akosch> FUZxxl: thanks!
15:59:19 <FUZxxl> akosch: I recall that there is also a package doing exactly this, but I forgot where...
16:03:50 <medfly> benmachine: I do sudo cabal install --global cabal-install, and then  Installing executable(s) in /usr/local/bin
16:03:54 <medfly> benmachine: SIGH
16:04:23 <benmachine> medfly: the sudo's still unnecessary
16:04:37 <medfly> benmachine: but I used global
16:04:41 <donri> runIO and dataToExpQ - it's working! except for the larger XML where ghc eats 2.4gb+
16:05:25 <benmachine> medfly: right, and it worked
16:05:27 <benmachine> no?
16:05:55 <medfly> benmachine: oops, confused. BUT NO, it did not.
16:06:04 <medfly> benmachine: I mean, not from what I copied.
16:06:06 <shachaf> medfly: Why are you installing globally?
16:06:08 <medfly> benmachine: it still wants more updating.
16:06:14 <medfly> shachaf: BECAUSE I'M UPDATING CABAL GODDAMNIT
16:06:17 <benmachine> medfly: oh. which cabal, again
16:06:17 <shachaf> medfly: So?
16:06:28 <benmachine> (I'm with shachaf, though)
16:06:28 <medfly> what's the point of having a global cabal if I do all the instalations locally?
16:06:30 <shachaf> medfly: You can "update" cabal and it'll install the new version in ~/.cabal/bin.
16:06:38 <shachaf> Then just use that.
16:06:39 <medfly> which is damn annoying
16:06:41 <benmachine> medfly: good question. what *is* the point of that? :P
16:06:44 <medfly> no. it's annoying.
16:06:45 <shachaf> No, it makes perfect sense.
16:06:51 <medfly> ANNOYING!!
16:07:02 <benmachine> medfly: it doesn't annoy *me*
16:07:07 <medfly> I don't make any other local installs of any other programs
16:07:08 <benmachine> also, indoor voice >_>
16:07:11 <medfly> I don't want to start now.
16:07:23 <medfly> benmachine: I shout indoors more than I do outside, so all caps?
16:07:33 <benmachine> medfly: if it would make you happy
16:07:45 <benmachine> medfly: anyway, what was wrong with what you copied?
16:07:50 <medfly> but it still wants me to update if I just use the /usr/local/bin/cabal
16:07:59 <medfly> even after global install
16:08:03 <benmachine> medfly: oh right.
16:08:04 <benmachine> hm
16:08:09 <benmachine> ok so let's do some diagnosis
16:08:24 <shachaf> medfly: Maybe you're accidentally running the local user version?
16:08:28 <benmachine> so you're saying /usr/local/bin/cabal update complains that there is a newer version available?
16:08:28 <shachaf> type -a cabal
16:08:56 <medfly> $ type -a cabal
16:08:57 <medfly> cabal is /usr/local/bin/cabal
16:08:57 <medfly> cabal is /usr/bin/cabal
16:09:02 <medfly> hurray?
16:09:10 <medfly> do I need to make it update the /usr/bin/cabal as well?
16:09:20 <medfly> benmachine: yes.
16:09:45 <benmachine> medfly: ok, so what does /usr/local/bin/cabal --version say?
16:09:50 <benmachine> what does cabal list cabal-install say?
16:10:29 <benmachine> (from the latter I just want the version line)
16:10:43 <medfly> benmachine: /usr/bin/cabal is older.
16:10:55 <benmachine> medfly: that doesn't answer either of my questions :P
16:11:00 <benmachine> hmm
16:11:09 <benmachine> I wonder if the out-of-date checker doesn't always check itself
16:11:30 <medfly> $ /usr/bin/cabal --version
16:11:30 <medfly> cabal-install version 0.8.0
16:11:30 <medfly> using version 1.8.0.2 of the Cabal library
16:11:41 <medfly> vs 0.10.2 for the other (usr/local/bin/cabal)
16:11:47 <benmachine> right
16:12:33 <benmachine> hmm, as far as I can see, it uses its own internal version
16:12:52 <benmachine> soo, I don't know?
16:13:05 <benmachine> hmm
16:14:49 <medfly> benmachine: it updates /usr/local/bin/cabal but not /usr/bin/cabal ~_~
16:14:58 <benmachine> medfly: that's sensible
16:15:07 <medfly> NO
16:15:07 <benmachine> /usr/bin is usually handled by your package manager
16:15:17 <medfly> and it's also WHAT I USE....
16:15:29 <benmachine> if you install a package yourself, in any of the various ways you might do it
16:15:31 <shachaf> medfly: Well, stop using it.
16:15:34 <benmachine> you *almost always* get it in /usr/local
16:15:39 <medfly> enoug hwith your madness!!
16:15:48 <benmachine> unless you specifically ask for something else
16:15:51 <medfly> I just want to update this thing, not spend 50 minutes thinking about what is sensible
16:16:00 <shachaf> You can't update it!
16:16:05 <shachaf> This is Haskell!
16:16:07 <shachaf> No updates.
16:16:32 <benmachine> medfly: you're not supposed to think about it, you're just supposed to add /home/you/.cabal/bin to your PATH
16:16:35 <benmachine> and then stop complaining :P
16:16:48 <medfly> I don't want to add it to my path
16:16:54 <benmachine> or, you can whine to your package manager about how it's behind the times
16:17:00 <benmachine> or you can just ignore the damn message :P
16:17:02 <medfly> I want to be able to update something with one command! >.<
16:17:18 <medfly> I don't want to manually add every program's path like that. that's stupid
16:17:23 <medfly> be in my fucking bin directory
16:17:44 <shachaf> Most programs don't install other programs.
16:17:49 <benmachine> ok well I've given you like four different options
16:17:54 <benmachine> take them or leave them :)
16:18:14 <akosch> could someone please point out the problem with getPostParams? (I only get back an empty list) http://hpaste.org/52484
16:18:21 <medfly> most programs don't bitch about not being up to date and then fail to update themselves normally
16:18:47 <benmachine> medfly: true. but this is a problem you can solve
16:18:50 <benmachine> it's also a problem you can ignore
16:19:06 <benmachine> because it's two lines of stdout every few days
16:19:20 <shachaf> akosch: What's the run_ for?
16:19:22 <medfly> yes, but I don't want to have to work to install things. that's the whole point of having something like cabal
16:19:58 <shachaf> akosch: Oh, wait.
16:20:03 <shachaf> akosch: Why are you doing this in IO?
16:20:08 <benmachine> medfly: in the words of the great philosopher M. Jagger, you can't always get what you want
16:20:45 <shachaf> akosch: I think handleRequest should be in Application (which I think is something like Request -> Iteratee IO Response).
16:20:49 <shachaf> Isn't that the point?
16:21:04 <medfly> welp, if I ever develop something, it won't be on cabal because it pisses me off.
16:21:25 <benmachine> medfly: it seems like a rather trivial issue to dismiss the whole thing on
16:21:34 <benmachine> medfly: almost everyone else who develops haskell uses cabal
16:21:41 <akosch> shachaf: Application is Request -> Iteratee ByteString IO Response
16:21:44 <benmachine> cabal has some user interface issues it's true
16:21:47 <shachaf> akosch: Oh, right.
16:21:57 <shachaf> akosch: Doesn't using run_ yourself defeat the purpose?
16:22:10 <shachaf> (Which is that you read the POST parameters from the existing input.)
16:22:14 <medfly> I don't care
16:22:42 <akosch> shachaf: hm, I just want to access the whole request at once
16:22:48 <akosch> shachaf: not iterate over it
16:22:54 <acowley> I actually quite like the way cabal-install deals with user directories
16:23:04 <shachaf> akosch: More than the POST params?
16:23:19 <benmachine> medfly: would it kill you to be a little accommodating? can I point out that it probably would take less time to fix it than to argue about not fixing it? :)
16:23:22 <acowley> it usually does what I want be default, and makes it easy to install data files alongside packages
16:23:27 <medfly> benmachine: yes, it would
16:23:40 <benmachine> medfly: well, as you like it.
16:23:52 <benmachine> acowley: I like it too, I kind of understand why people don't
16:23:57 <akosch> shachaf: no, just the POST params, files included (basically the parsed request body)
16:24:06 <benmachine> but I don't think the problems medfly is encountering are really cabal's fault
16:24:08 <shachaf> akosch: handleRequest :: Application; handleRequest req = do { (params,files) <- parseRequestBody lbsSing req; ... }
16:24:14 <shachaf> akosch: Anything wrong with doing it like that?
16:24:20 <benmachine> they're more problems associated with managing packages in two different ways
16:24:29 <benmachine> which is always going to be a little awkward
16:25:09 <akosch> shachaf: how do I do normal IO in there?
16:25:45 <shachaf> akosch: liftIO
16:26:31 <akosch> shachaf: thanks, I understand. I'll try it this way...
16:32:21 <donri> this is incredibly space inefficient; a 300K xml parsed and inlined with template haskell yields a 25M binary
16:32:47 <akosch> shachaf: thanks again, it's working :)
16:33:15 <acowley> donri: inlined in what sense?
16:33:40 <donri> acowley, dataToExpQ
16:35:57 <acowley> donri: what XML representation are you using?
16:36:36 <donri> acowley, oh, custom. gonna check how large the "show" is for comparison
16:37:40 <donri> the whole thing with show is 180K
16:39:19 <donri> oh, without inlining it's still 18M
16:39:34 <ddarius> Twitter is the worse thing that has ever happened in a long while.
16:39:34 <donri> guess it's static linking of lots of libs etc
16:41:32 <KirinDave> Dang, shqq is cool
16:41:53 <medfly> benmachine: anyways I added it to my path >.<
16:42:10 <medfly> benmachine: it would be convenient if it was done when I installed cabal and not via cabal
16:42:31 <Nafai> KirinDave: Oh man, this looks awesome
16:42:39 <KirinDave> http://mainisusuallyafunction.blogspot.com/2011/10/shqq-embedding-shell-commands-in.html
16:48:09 <dylukes> :D
16:48:30 <sm> medfly: cabal is totally open for contributors right now and I for one would welcome your fix
16:49:01 <dylukes> Who maintains the emacs mode?
16:49:28 <dylukes> It properly finds the root of the current cabal project and looks for files from there but it fails to check for other source directories (as specified in the .cabal file)
16:50:07 <alpounet> ddarius, why?
17:01:09 <ddarius> alpounet: Imagine if IRC logs were stored by person sorted by time and then by channel.
17:02:04 <alpounet> oh, from that point of view.
17:02:11 <RaptorRarr> ddarius: That's much better than sorting by character!
17:03:43 <xil> GHC is recommending I use a TChan instead of a Chan if I want the functionality of isEmptyChan. Does anyone know why? I don't really know what Transactional Memory is so I prefer not to use it
17:04:17 <c_wraith> isEmptyChan will deadlock if there is another thread in the middle of a readChan call on an empty Chan
17:04:39 <c_wraith> There's no sane way to fix that deadlock, when the structure is built on MVars, like Chan is
17:04:52 <c_wraith> TChan, on the other hand, is built on a system that can't deadlock.
17:05:06 <ddarius> xil: You should reevaluate your need for isEmptyChan.
17:07:20 <xil> that is incredibly fascinating. I wish I had the time to learn why it deadlocks right now. But if I know that no other thread reads the Chan then is it safe to do? I presume so? I only check to see if it's empty because I do something else if it is than if it's not, but the Chan is essentially one way from one thread to one other thread. Will a writeChan cause the deadlock like the readChan does?
17:08:34 <xil> ddarius: I want this thread to be doing something repeatedly until it get's a message, at which point it should stop repeating and do what the message wants
17:11:41 <monochrom> you should use TChan
17:12:21 <ddarius> If the timing doesn't matter, then that is probably reasonable enough.
17:13:46 <monochrom> 3 reasons to use TChan!
17:13:54 <monochrom> 1. isEmptyTChan actually works
17:14:12 <monochrom> 2. you can use orElse to obtain a select over several channels
17:14:37 <monochrom> 3. (I'll think up one in the future)
17:14:41 <xil> haha
17:15:11 <c_wraith> xil: stm is actually a very clever system, and you shouldn't be afraid of using it.  It gives a very nice API for managing concurrent things that need to access the same resources.
17:16:09 <xil> I feel uncomfortable using it before understanding Transactional Memory though, and I don't have the time right now to learn new things. If it's safe to just stick "atomically" on the front of all my TChan functions and then just use them like Chan functions then I could switch
17:16:45 <xil> I know I can also stick atomically on the front of a block of STM operations, like a do-block
17:17:00 <xil> or a bunch of operations strung together with >> and >>=
17:17:58 <ddarius> xil: The rule is simple, beyond following the types, just use atomically around any group of operations you want to be atomic.
17:18:40 <ddarius> You other than retry and orElse, if you need them, you don't really need to understand anything else or what "transactional memory" is.
17:18:55 <ddarius> Also, retry and orElse similarly have pretty simple semantics.
17:19:23 <xil> okay, I'll change it then, just in case
17:19:29 <xil> thanks for the help everyone =]
17:29:10 <trinithis> why is (+) infixl?
17:29:24 <trinithis> Wont that make lazy numbers not as lazy?
17:29:42 <trinithis> Say, I encode a number as a list for example
17:30:05 <trinithis> I cant take the infinite + of it and compare to a finite number
17:30:09 <trinithis> or am i wrong
17:30:12 <Axman6> i think it's infixl because that's generally how it's fixity is accepted to be in maths
17:30:54 <trinithis> alright. gtg
17:30:54 <dylukes> ^
17:31:04 <dylukes> :t (fix +0) 1
17:31:05 <lambdabot> forall a. (Num a) => a
17:31:19 <dylukes> @let infinity = (fix +0) 1
17:31:20 <lambdabot>  Defined.
17:31:23 <dylukes> take 20 infinity
17:31:27 <dylukes> > take 20 infinity
17:31:28 <lambdabot>   No instance for (GHC.Num.Num [a])
17:31:28 <lambdabot>    arising from a use of `e_120' at <inte...
17:31:36 <Axman6> ?
17:31:39 <dylukes> :<
17:31:50 <dylukes> @let infinity = (fix +1) 0
17:31:51 <lambdabot>  <local>:14:0:
17:31:51 <lambdabot>      Multiple declarations of `L.infinity'
17:31:51 <lambdabot>      Declared at: <...
17:31:55 <dylukes> @forget infinity
17:31:56 <lambdabot> Incorrect arguments to quote
17:32:04 <dylukes> oh well
17:32:41 <ddarius> @undefine
17:32:50 <ddarius> Stop trying to add to fix.
17:33:14 <ddarius> trinithis: What hard drive are you storing your infinitely long source file on?
17:34:22 <dylukes> :t fix
17:34:22 <lambdabot> forall a. (a -> a) -> a
17:34:23 <dylukes> :t (+)
17:34:24 <lambdabot> forall a. (Num a) => a -> a -> a
17:34:28 <dylukes> :t fix (+1)
17:34:28 <lambdabot> forall a. (Num a) => a
17:34:33 <dylukes> orite
17:34:43 <dylukes> > let inf = fix (+1) in take 20 inf
17:34:44 <lambdabot>   No instance for (GHC.Num.Num [a])
17:34:44 <lambdabot>    arising from a use of `e_1120' at <int...
17:35:31 <dylukes> > let inf = fix (:1) in (foldr1 (+) . take) 20 inf
17:35:32 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]Couldn't match exp...
17:35:34 <dylukes> ba
17:35:35 <dylukes> bah*
17:37:36 <Axman6> you can talk to lambdabot in pm
17:39:37 <dylukes> Quiet you bynbo
17:39:40 <dylukes> :p
17:47:00 <djanatyn> firstRule = "the first rule of recursion club is that " ++ firstRule
17:49:29 <FUZxxl> Is a@~(b:c) a valid pattern?
17:50:05 <FUZxxl> @let firstRule = "the first rule of recursion club is that " ++ firstRule
17:50:05 <lambdabot>  Defined.
17:50:11 <FUZxxl> > firstRule
17:50:12 <lambdabot>   "the first rule of recursion club is that the first rule of recursion club ...
17:50:39 <jmcarthur> is there a name for a mealy machine that might not have an output for every input?
17:51:20 <djanatyn> making the first rule of recursion club is a lot easier in haskell than in scheme :P
17:51:26 <djanatyn> (delay) is weird.
17:51:35 <ddarius> > let a@~(b:c) = undefined in True
17:51:36 <lambdabot>   True
17:51:48 <ddarius> It doesn't mean what you think it means though.
17:52:39 <Pseudonym> > let theFirstRuleOfQuineClub s = s ++ show s in "let theFirstRuleOfQuineClub s = s ++ show s in "
17:52:40 <lambdabot>   "let theFirstRuleOfQuineClub s = s ++ show s in "
17:53:14 <ddarius> Very impressive.
17:53:20 <Pseudonym> > let theFirstRuleOfQuineClub s = s ++ show s in theFirstRuleOfQuineClub "let theFirstRuleOfQuineClub s = s ++ show s in theFirstRuleOfQuineClib "
17:53:21 <lambdabot>   "let theFirstRuleOfQuineClub s = s ++ show s in theFirstRuleOfQuineClib \"l...
17:53:26 <Pseudonym> > let theFirstRuleOfQuineClub s = s ++ show s in theFirstRuleOfQuineClub "let theFirstRuleOfQuineClub s = s ++ show s in theFirstRuleOfQuineClub "
17:53:27 <Pseudonym> That's it.
17:53:27 <lambdabot>   "let theFirstRuleOfQuineClub s = s ++ show s in theFirstRuleOfQuineClub \"l...
17:54:10 <shachaf> > ap(++)show"ap(++)show"
17:54:12 <lambdabot>   "ap(++)show\"ap(++)show\""
17:54:18 <Pseudonym> Nice!
17:54:44 <shachaf> (Not original to me, though it's an obvious transformation of your function.)
17:54:52 <Pseudonym> (id&&&show)"(id&&&show)"
17:54:56 <Pseudonym> > (id&&&show)"(id&&&show)"
17:54:56 <lambdabot>   ("(id&&&show)","\"(id&&&show)\"")
17:55:01 <shachaf> @pl theFirstRuleOfQuineClub s = s ++ show s -- @pl-obvious
17:55:01 <lambdabot> theFirstRuleOfQuineClub = ap (++) show
17:55:02 <Pseudonym> Uhm...
17:57:12 <Pseudonym> > uncurry(++)(id&&&show)"uncurry(++)(id&&&show)"
17:57:13 <lambdabot>   Couldn't match expected type `(a, c)'
17:57:13 <lambdabot>         against inferred type `a1 -> ...
17:57:46 <Pseudonym> > uncurry(++).(id&&&show)$"uncurry(++).(id&&&show)$"
17:57:48 <lambdabot>   "uncurry(++).(id&&&show)$\"uncurry(++).(id&&&show)$\""
17:57:49 <Pseudonym> Right
17:58:06 <jmcarthur> it may be that i'm abusing the definition of mealy machine just in asking this question
17:58:27 <FUZxxl> Is there a function Bool -> a -> Maybe a?
17:58:37 <Pseudonym> @hoogle Bool -> a -> Maybe a
17:58:38 <jmcarthur> @djinn Bool -> a -> Maybe a
17:58:38 <lambdabot> Control.Exception assert :: Bool -> a -> a
17:58:38 <lambdabot> Control.OldException assert :: Bool -> a -> a
17:58:38 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
17:58:39 <lambdabot> f a b =
17:58:39 <lambdabot>     case a of
17:58:40 <lambdabot>     False -> Nothing
17:58:42 <lambdabot>     True -> Just b
17:58:44 <dylukes> @hoogle Bool -> a -> Maybe a
17:58:44 <lambdabot> Control.Exception assert :: Bool -> a -> a
17:58:46 <lambdabot> Control.OldException assert :: Bool -> a -> a
17:58:48 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
17:59:01 <jmcarthur> i have often wanted that function to be predefined
17:59:05 <Pseudonym> > guard False >> 42 :: Maybe Int
17:59:06 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
17:59:06 <lambdabot>    arising f...
17:59:13 <Pseudonym> > (guard False >> 42) :: Maybe Int
17:59:14 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
17:59:14 <lambdabot>    arising f...
17:59:17 <ddarius> Pseudonym is really off his game today.
17:59:21 * Pseudonym is
17:59:24 <dylukes> :t liftM assert
17:59:25 <lambdabot> lexical error at character '\FS'
17:59:27 <Pseudonym> Thinking too hard about RNA-seq.
17:59:29 <dylukes> :t liftM assert
17:59:30 <lambdabot> Not in scope: `assert'
17:59:34 <ddarius> > guard True >> return 32
17:59:35 <lambdabot>   No instance for (GHC.Show.Show (m t))
17:59:35 <lambdabot>    arising from a use of `M7460085575...
17:59:39 <dylukes> :t liftM Control.Exception.assert
17:59:40 <lambdabot> forall a (m :: * -> *). (Monad m) => m Bool -> m (a -> a)
17:59:44 <jmcarthur> > guard False >> return 42 :: Maybe Int
17:59:45 <lambdabot>   Nothing
17:59:51 <jmcarthur> > guard True >> return 42 :: Maybe Int
17:59:52 <lambdabot>   Just 42
17:59:54 <Pseudonym> That's it.
17:59:56 <dylukes> :D
18:00:06 <Pseudonym> @pl \b x -> guard b >> return x
18:00:07 <lambdabot> (. return) . (>>) . guard
18:00:07 <FUZxxl> dylukes: great!
18:00:14 <dylukes> no
18:00:16 <dylukes> not mine
18:00:22 <dylukes> jmcarthur's
18:00:46 <jmcarthur> :t guard
18:00:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:00:54 <jmcarthur> is there an Alternative version of guard?
18:01:05 <Pseudonym> > guard True >> Just 32
18:01:06 <jmcarthur> hmm guess it can't be
18:01:06 <lambdabot>   Just 32
18:01:09 <FUZxxl> How about a <$ guard x
18:01:11 <Pseudonym> > guard False >> Just 32
18:01:12 <lambdabot>   Nothing
18:01:21 <FUZxxl> > 42 <$ guard True
18:01:22 <lambdabot>   No instance for (GHC.Show.Show (f t))
18:01:22 <lambdabot>    arising from a use of `M4878801191...
18:01:26 <ddarius> jmcarthur: I don't think so, but then I'm hardly an expert on FSM terminology.  Such a machine could be modelled by a Mealy machine with a "silent" output.
18:01:33 <FUZxxl> > 42 <$ guard True :: Maybe Int
18:01:34 <lambdabot>   Just 42
18:01:40 <FUZxxl> > 42 <$ guard False :: Maybe Int
18:01:41 <lambdabot>   Nothing
18:01:45 <FUZxxl> yeah
18:01:50 <Pseudonym> BTW, this is one situation where monad comprehensions would be damn useful.
18:01:55 <Pseudonym> > [ 42 | True ]
18:01:56 <lambdabot>   [42]
18:01:58 <Pseudonym> > [ 42 | False ]
18:01:59 <lambdabot>   []
18:02:39 <FUZxxl> Pseudonym: Yes. You are so right.
18:02:48 <FUZxxl> What is the pragmas name?
18:03:44 <dylukes> Why don't we ever get back Monad comprehensions :<?
18:04:01 <ddarius> They are back.
18:04:15 <Quantumplation> how would I implement Eq typeclass for a cyclicly dependent type? (data Vertex = V [Edge] deriving (Eq) and data Edge = E Vertex Vertex deriving (Eq))
18:04:36 <ddarius> listToMaybe [42|True]
18:05:12 <FUZxxl> > 	listToMaybe [42|True]
18:05:12 <lambdabot>   Just 42
18:05:24 <ddarius> > let guard' b x = msum[x|b] in guard' True 42 :: Maybe Int
18:05:25 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
18:05:25 <lambdabot>    arising f...
18:05:33 <FUZxxl> :i msum
18:05:38 <ddarius> Almost.
18:05:43 <FUZxxl> @hoogle msum
18:05:43 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
18:05:44 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
18:05:48 <ddarius> > let guard' b x = msum[return x|b] in guard' True 42 :: Maybe Int
18:05:49 <lambdabot>   Just 42
18:06:21 <ddarius> I guess I could use asum alternatively.
18:06:34 <Quantumplation> nevermind, I was trying to do both deriving and instance clauses, i guess that's not allowed
18:09:50 <ddarius> jmcarthur: You should look at FSMs from the perspective of coalgebra, by the way.
18:09:55 <ddarius> If you aren't/haven't.
18:10:02 <Quantumplation> hrm.  How would I check if two lists contain the same elements, but not neccesarily in the same order?
18:10:16 <ddarius> sort xs == sort ys
18:10:34 <Quantumplation> \o/ thanks
18:10:47 <Pseudonym> @pl \xs ys -> sort xs == sort ys
18:10:47 <lambdabot> (. sort) . (==) . sort
18:11:02 <Pseudonym> pl doesn't know about `o`
18:11:14 <ddarius> You mean on?
18:11:18 <Pseudonym> on, yes.
18:11:22 <Pseudonym> Sorry, mistype.
18:11:55 <Quantumplation> what if the types in the list don't derive Ord?
18:12:20 <Pseudonym> Quantumplation: Then you can't use a fast algorithm.
18:12:50 <Quantumplation> that's fine
18:12:56 <Pseudonym> all (`elem` xs) ys && all (`elem` ys) xs
18:13:27 <Pseudonym> Probably the easiest.
18:13:54 <Quantumplation> ty
18:15:25 <FUZxxl> Ah.... I found a bug either in lambdabot or GHC
18:15:42 <Pseudonym> Note that this isn't an exact substitute for the sort one, because duplicates are treated differently.
18:15:47 <FUZxxl> The former accepts a@~(b:c) as a pattern while the latter spits out a parser error
18:16:16 <Pseudonym> Which version of GHC?
18:16:24 <Pseudonym> And which bit of lambdabot?
18:16:54 <jmcarthur> ddarius: thanks for the hint. i've seen it mentioned this way in literature before
18:34:52 <FUZxxl> Pseudonym: My GHC is 7.0.3
18:35:04 <FUZxxl> >  a@~(b:c) = [0,1]
18:35:05 <lambdabot>   <no location info>: parse error on input `='
18:35:09 <FUZxxl> @let  a@~(b:c) = [0,1]
18:35:10 <lambdabot>  Defined.
18:35:13 <FUZxxl> a
18:35:15 <FUZxxl> > a
18:35:16 <lambdabot>   a
18:35:21 <FUZxxl> > b
18:35:22 <lambdabot>   b
18:35:25 <FUZxxl> > c
18:35:26 <lambdabot>   c
18:35:38 <FUZxxl> @let  asd@~(eds:rff) = [0,1]
18:35:39 <lambdabot>  <local>:2:0:
18:35:39 <lambdabot>      Warning: Pattern match(es) are overlapped
18:35:40 <lambdabot>               In...
18:35:49 <FUZxxl> > asd
18:35:50 <lambdabot>   Not in scope: `asd'
18:35:54 <FUZxxl> ?!?!
18:35:56 <Pseudonym> > L.a
18:35:57 <lambdabot>   Not in scope: `L.a'
18:36:04 <mauke> @undefine
18:36:14 <FUZxxl> @let  a@~(b:c) = [0,1]
18:36:15 <lambdabot>  Defined.
18:36:17 <mauke> @undefine
18:36:18 <FUZxxl> > a
18:36:18 <lambdabot>   a
18:36:30 <FUZxxl> @help undefine
18:36:30 <lambdabot> undefine. Reset evaluator local bindings
18:36:36 <FUZxxl> @help let
18:36:36 <lambdabot> let <x> = <e>. Add a binding
18:36:48 <mauke> oh, you're defining @~ ?
18:36:51 <FUZxxl> @let  foo@~(bar:quu) = [0,1]
18:36:52 <lambdabot>  Defined.
18:36:58 <FUZxxl> mauke: no...
18:37:07 <mauke> > "foo" @~ "bar"
18:37:09 <lambdabot>   [0,1]
18:37:10 <Pseudonym> > let a @ ~ (b:c) = [0,1] in a
18:37:11 <lambdabot>   [0,1]
18:37:11 <mauke> yes
18:37:24 <FUZxxl> I try combining an irrefutable pattern with an alias pattern
18:37:26 <Pseudonym> > let a @ ~ (b:c) = [0,1] in (a,b,c)
18:37:27 <lambdabot>   ([0,1],0,[1])
18:37:30 <mauke> FUZxxl: irrelevant
18:37:36 <mauke> FUZxxl: you're defining @~
18:37:40 <Pseudonym> > let a @~ (b:c) = [0,1] in (a,b,c)
18:37:41 <lambdabot>   (a,b,c)
18:37:44 <FUZxxl> So I have to add a space?
18:37:44 <Pseudonym> Bingo.
18:37:48 <FUZxxl> :D
18:38:51 <monochrom> > let a @~ b = 5 in 0 @~ 0
18:38:52 <lambdabot>   5
18:38:57 <monochrom> so it does
18:39:21 <FUZxxl> uaahhh.... I didn't even know that @ is allowed in function names.
18:39:32 <monochrom> put a space between @ and ~. that should do
18:39:43 <monochrom> yeah it's new to me too
18:39:56 <mauke> @.@
18:39:56 <lambdabot> Maybe you meant: . @
18:39:57 <Pseudonym> :t (@@)
18:39:58 <lambdabot> Not in scope: `@@'
18:40:40 <monochrom> nice, I can use @.@ from now on!
18:40:58 <FUZxxl> mauke: :-ð
18:41:22 <mauke> that's not a valid operator
18:41:33 <mauke> it's not even a valid constructor since ð is a letter
18:41:37 <FUZxxl> @let a @.@ b = a . b
18:41:37 <lambdabot>  Defined.
18:41:53 <mauke> > ord@.@"@'"
18:41:55 <lambdabot>   [64,39]
18:42:02 <FUZxxl> mauke: That was meant as the islandic edition of :-p
18:42:09 <monochrom> \∩/
18:42:16 <mauke> :-þ
18:42:31 <FUZxxl> 囧
18:42:57 <mauke> ツ
18:43:19 <FUZxxl> (The above one is often used in chinese Forums in a similar fashion as o.O)
18:43:28 <FUZxxl> mauke: Why do you say shi?
18:44:17 <mauke> it's a smiley
18:44:22 <FUZxxl> ?!?
18:44:27 <FUZxxl> It's a Katakana
18:44:44 <FUZxxl> sh******
18:45:00 <mauke> ヾ
18:46:11 <Daegalus> Can anyone help me figure out the errors I am getting with a list unweave? I think i have some bad recursion or syntax going on, but not sure exactly how: http://hpaste.org/52488
18:46:35 <mauke> yeah, that's pretty obvious
18:46:41 <mauke> you're doing foo x : foo y
18:46:45 <mauke> that can't possibly work
18:47:02 <FUZxxl> You probably want ++
18:47:12 <mauke> and you should stop using 'if'
18:47:17 <monochrom> I am not sure what type filterOther has, and more pointedly, whether you want that type or not
18:47:18 <mauke> null x? wtf
18:47:52 <monochrom> I am especially suspicious of "null x || null xs"
18:48:24 <novodinia> Is template Haskell the recommended method for creating DSLs?
18:48:43 <Daegalus> i just did that for testing and such, Im still new to haskell. I usually put in unnecessary null checks for just extra testing, I will get rid of some of those that are unnecessary
18:48:56 <mauke> Daegalus: do you even know what 'null' does?
18:49:06 <monochrom> > null True
18:49:07 <lambdabot>   Couldn't match expected type `[a]'
18:49:07 <lambdabot>         against inferred type `GHC.Bool....
18:49:15 <monochrom> it's a type error
18:49:40 <monochrom> so your filterOther is immediately inapplicable to [True, False, True, True]
18:49:59 <monochrom> do you test your functions often?
18:50:03 <ddarius> [21:00] <ddarius> > let a@~(b:c) = undefined in True
18:50:03 <ddarius> [21:00] <lambdabot>   True
18:50:03 <ddarius> [21:00] <ddarius> It doesn't mean what you think it means though.
18:50:13 <Cale> novodinia: It's a lot nicer if you can embed the language in Haskell more directly.
18:50:30 <Daegalus> monochrom: im testing them now, but in order for me to get any output, i need to get them to stop erroring, im getting type errors still, or other errors of bad syntax or typos.
18:50:44 <blackdog> Daegalus: one of the lovely things about haskell is that null doesn't exist
18:51:02 <mauke> Daegalus: do you know what 'null' does?
18:51:06 <blackdog> if you try to bull through the way you would with PHP, you won't understand it and it won't work.
18:51:35 <Daegalus> mauke: from what i gathered I thoguht it was a check if it an whatever specified was null
18:51:37 <Cale> Well, 'null' does exist. It's a function for testing if a list is empty or not.
18:51:42 <Cale> > null []
18:51:43 <lambdabot>   True
18:51:46 <Cale> > null [1,2,3]
18:51:47 <lambdabot>   False
18:51:53 <Daegalus> thats exactly how im using it...
18:51:57 <mauke> Daegalus: no, it isn't
18:51:59 <monochrom> yes, you should mind the type errors first. you should look at the inferred type of filterOther and ask yourself: do you want that type?
18:52:30 <monochrom> @let filterOther (x:_:xs) = if(null x || null xs) then [] else x : filterOther xs
18:52:31 <ddarius> blackdog: Just like in PHP.
18:52:31 <lambdabot>  Defined.
18:52:36 <monochrom> @type filterOther
18:52:37 <lambdabot> forall a. [[a]] -> [[a]]
18:52:38 <Cale> mauke: well... it is, because that's what null does ;)
18:52:47 <Cale> He can't use it in any other way :)
18:52:48 <monochrom> is that type what you want? nested lists?
18:52:59 <monochrom> > filterOther [True, False, True]
18:53:00 <lambdabot>   Couldn't match expected type `[a]'
18:53:00 <lambdabot>         against inferred type `GHC.Bool....
18:53:12 <Daegalus> ummm, not nested lists, just lists
18:53:15 <monochrom> is that type error what you want? that I can't even use it for a list of Bools
18:53:18 <blackdog> ddarius: well, it'll kinda sorta work. enough to get something on the screen, even if it's just an error.
18:53:30 <Cale> Daegalus: you apply null to x which is the first element of the list being passed to filterOther
18:53:39 <monochrom> OK good, so nevermind unweave, fix your filterOther first
18:54:02 <Cale> Daegalus: which means that the list must be a list of lists, otherwise there would be no way for its first element to be an empty list
18:54:18 <mauke> Daegalus: for now I'd recommend not using 'if'
18:54:33 <mauke> use 'case' if you need to make two branches
18:54:34 * ddarius , in an effort to make Haskell more appealing to the dynamically typed masses, modifies GHC to always successfully compile but if there is a type error, to create an executable which does nothing but displays a type error and terminates.
18:54:39 <Cale> You probably just wanted to write  filterOther (x:_:xs) = x : filterOther xs
18:54:48 <Cale> and handle the case of 0 and 1 element lists separately
18:54:53 <Cale> filterOther [] = []
18:54:58 <Cale> filterOther [x] = [x]
18:55:00 <Cale> or something
18:55:04 <mauke> preflex: quote . sensible
18:55:05 <preflex>  <augustss> ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.
18:55:12 <Daegalus> Cale: i had that before, but it was erroring on me for some reason, i forget what error
18:55:34 <blackdog> ddarius: PHP: optimised for close-enough-for-government-work
18:55:54 <Cale> Daegalus: one problem is that unweave uses tail, which can fail at runtime if passed an empty list
18:55:57 * ddarius has never used or seen PHP used for government work.
18:55:58 <Cale> > tail []
18:55:59 <lambdabot>   *Exception: Prelude.tail: empty list
18:56:21 <Cale> ^^ this can be really annoying if it happens in a real program, so most people avoid using tail as much as possible
18:56:37 <Cale> (you can always pattern match instead, which is a good reminder to handle the other cases)
18:57:17 <Cale> of course, you're checking explicitly first if the list x is empty or not, so that tail isn't a problem on its own
18:57:19 <Daegalus> hmmm, well reason im using tail, is because of the way filterOther works. I filter out the Odd indexes, then get rid of hte first element and use the rest of the list for another iflter other to get even indexes
18:57:30 <Cale> How about drop 1 instead?
18:57:33 <Cale> > drop 1 []
18:57:34 <lambdabot>   []
18:57:47 <Cale> Or just pattern match:
18:57:54 <Cale> unweave [] = []
18:58:17 <Cale> er, well, I'm not sure what unweave is meant to do
18:58:28 <Cale> Perhaps you want...
18:58:29 <ddarius> Unweave, silly.
18:58:33 <mauke> Daegalus: what would unweave's type be?
18:58:38 <Cale> unweave [] = ([],[])
18:58:45 <Daegalus> what cale said
18:58:51 <Cale> unweave (x:xs) = (filterOther (x:xs), filterOther xs)
18:58:59 <Cale> something like that?
18:59:41 <mike-burns> It produces two lists, one with the even elements and the other with the odd?
18:59:43 <ddarius> module A where { cleave = splitAt }; module B where { cleave = (:) };
18:59:48 <Daegalus> but umm, its meant to take a list, and take all the odd indexes in one list, and all the even indexs into another list, and return it. So [111,42,64,74,23,6] -> ([111,64,23],[42,74,6])
19:00:00 <mauke> Daegalus: what would unweave's type be?
19:00:03 <incluye> > unweave []
19:00:04 <lambdabot>   Not in scope: `unweave'
19:00:42 <Daegalus> mauke: [a] -> [a] -> ([a],[a]), i think thats it
19:00:54 <Daegalus> wait
19:01:05 <Daegalus> just one [a]
19:01:28 <shachaf> [a] -> ([a] -> [a] -> r) -> r
19:01:42 * mauke thwaps shachaf 
19:02:05 <monochrom> @arr (a->r)->r
19:02:05 <lambdabot> Keelhaul the swabs!
19:02:58 <byorgey> hah, if no one has ever made a joke about pirates and continuations...
19:03:06 <monochrom> you write (expression0, expression1) to get a value of type (s,t)
19:03:18 <monochrom> i.e., you don't write expression0 : expression1
19:03:23 * byorgey makes a mental note
19:04:01 <shachaf> @quote monochrom CCCP
19:04:02 <lambdabot> monochrom says: in Soviet Russia, current continuation calls procedure (CCCP)
19:04:23 <shachaf> @quote monochrom СССР
19:04:23 <lambdabot> No quotes match. There are some things that I just don't know.
19:04:28 <monochrom> oleg organizes the continuation workshop to let researchers say "(a->r)->r matey!" to each other
19:07:34 <monochrom> and you don't write [] to get a value of type (s,t) at all. [] has a list type, not a tuple type.
19:08:21 <monochrom> this is not Scheme. you don't use the empty list as a stand-in for every "no answer" situation
19:08:43 <shachaf> > toDyn (toDyn 1,toDyn (toDyn 2,toDyn (toDyn 3, toDyn ())))
19:08:44 <lambdabot>   <<(Dynamic,Dynamic)>>
19:08:51 <mike-burns> Yeah, use `fail' for that instead!
19:09:36 <mauke> > toDyn [toDyn 1,toDyn [toDyn 2,toDyn [toDyn 3, toDyn []]]]
19:09:37 <lambdabot>   Ambiguous type variable `a' in the constraint:
19:09:37 <lambdabot>    `Data.Typeable.Typeable a...
19:09:52 <mauke> > toDyn [toDyn 1,toDyn [toDyn 2,toDyn [toDyn 3, toDyn ()]]]
19:09:53 <lambdabot>   <<[Dynamic]>>
19:10:03 * hackagebot zoom-cache 0.1.0.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.1.0.0 (ConradParker)
19:10:24 <parcs> monochrom: i thought common lisp does that
19:11:53 <mauke> (), '(), nil, 'nil, (quote ()), (quote nil)
19:12:36 <parcs> yeah scheme actually has a boolean data type
19:30:03 * hackagebot zoom-cache 0.1.0.1 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.1.0.1 (ConradParker)
19:35:47 <Quantumplation> can type declarations (type Blah = (Node, Node)) implement typeclasses?
19:36:16 <mauke> no
19:36:19 <dmwit> Yes, if the expansion of the type alias would be a valid instance declaration.
19:36:23 <dmwit> You need to enable some extensions.
19:36:28 <mauke> dmwit: what
19:36:28 <dmwit> Try it and GHC will tell you which ones.
19:36:40 <dmwit> mauke: true story
19:36:43 <mauke> no
19:37:17 <QinGW> join #emacs
19:37:44 <dmwit> mauke: I just tried it. I only needed -XTypeSynonymInstances.
19:37:48 <dmwit> So... yes.
19:38:02 <mauke> there is no way to create a class instance with 'type'
19:38:05 <mauke> you need 'instance'
19:38:10 <dmwit> Oh, yes.
19:38:22 <dmwit> I thought Quantumplation was asking whether type aliases could be used in instance declarations.
19:38:34 <dmwit> I still think that.
19:39:08 <dmwit> Reread his question, this time with a little less pedantry. =)
19:39:58 <mauke> dmwit: can data declarations (data Blah = Node) implement typeclasses?
19:40:03 * hackagebot zoom-cache 0.1.0.2 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.1.0.2 (ConradParker)
19:41:54 <dmwit> mauke: Yes.
19:42:33 <dmwit> mauke: I understand your point (the *declaration* isn't the thing that implements the type class), but I think your answer is nevertheless unhelpful.
19:43:27 <mauke> that'll learn you to ask the wrong questions
19:45:09 <dmwit> Yes. God forbid we should apply our huge brains to understanding the person who's asking for help.
19:45:28 <dmwit> This isn't ##c.
19:45:54 <mauke> Quantumplation: so ... are you still here?
19:51:59 <mauke> :-(
19:54:42 * copumpkin comforts mauke 
19:55:47 * ddarius renames copumpkin to corobert[]
19:56:36 <shachaf> * comauke mforts pumpkin
19:56:53 <mauke> preflex: quote . cowrote
19:56:59 <preflex>  <parcs> i cowrote that.  and by that i mean i read it
20:01:02 <blb> I'm unsure if haskell is installed on a system or not
20:01:07 <blb> what is it usually called
20:01:16 <blb> …the interpreter
20:01:28 <Guest74480> ghci
20:01:33 <mauke> you can't install "haskell", it's not a program
20:01:47 <mauke> if you want to run programs written in haskell, you don't need to install anything extra
20:02:22 <blb> Guest10185: thanks
20:02:27 <shachaf> Usually you need libc or something.
20:02:43 <mauke> show me a system without libc :-)
20:02:44 <Clint> you can learn you a haskell but you can't install you a haskell?
20:02:45 <blb> mauke: yea, i was just looking for the name of the interpreter
20:02:54 <mauke> blb: there are at least two, hugs and ghci
20:03:07 <mauke> and a compiler
20:07:07 <dmwit> I always use uhci, personally.
20:07:10 * dmwit chuckles into his hand
20:07:31 <Pseudonym> You should use DUH-ci.
20:09:56 <hpaste_> blb pasted “sums” at http://hpaste.org/52489
20:10:41 <blb> line 6 is populating the array by mapping sumOnesAt over that range right?
20:11:21 * blb has never read haskell before. but trying  to make sense of this file
20:12:41 <blb> in sumOnesAt', it checks to see if n is less than the table size, then fetches n from the table right?
20:13:19 <blb> otherwise it returns sumOnesAt(n) right
20:13:20 <blb> ?
20:14:06 <blb> i don't get how line 14 will ever pass on an empty array
20:14:17 <shachaf> blb: More or less, yes.
20:14:23 <shachaf> What do you mean, pass on an empty array?
20:14:33 <blb> sumOnesAtTable ! n
20:14:34 <shachaf> There is no empty array.
20:14:57 <blb> I'm assuming thats the python equip to sumOnesAtTable[n]
20:15:01 <blb> right?
20:15:20 <shachaf> More or less, yes.
20:15:27 <blb> ok
20:15:37 <blb> so how is the array initially populated?
20:15:56 <shachaf> In line 6, as you said.
20:15:58 <blb> seems like lines 4-6 handle that. but it depends on  sumOnesAt' n
20:16:05 <blb> which should always fail
20:16:12 <shachaf> Why?
20:16:31 <monochrom> eh? let's try my example
20:16:36 <blb> because line 6 is depending on it to populate the array
20:17:14 <shachaf> blb: Works for me.
20:17:20 <monochrom> > let myarray = listArray (0,1) ["hi", (myarray ! 0) ++ " there"] in myarray
20:17:21 <shachaf> blb: Haskell is lazily evaluated.
20:17:22 <lambdabot>   array (0,1) [(0,"hi"),(1,"hi there")]
20:17:26 <blb> how am i reading this wrong?
20:17:34 <mauke> blb: you're thinking it wrong
20:18:00 <blb> hrmm
20:18:04 <monochrom> see also my http://www.haskell.org/haskellwiki/Dynamic_programming_example
20:18:08 <mauke> use your spreadsheet brain
20:18:22 <blb> ha,
20:18:30 <monochrom> yeah spreadsheets do the same thing
20:19:18 <monochrom> of course if you try to define myarray!0 in terms of myarray!0, that won't work. but no one is doing that sort of thing here
20:20:18 <shachaf> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
20:20:18 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
20:20:55 <monochrom> I should remember to include an array example in my lazy evaluation article
20:21:08 <shachaf> @arr
20:21:09 <lambdabot> Ahoy mateys
20:21:11 <mauke> data Nat = Z | I | S Nat Nat
20:21:26 <monochrom> the notation is a bit tricky
20:21:27 <mauke> xs = Z : I : zipWith S xs (tail xs)
20:22:18 <blb> oh i see
20:22:26 <blb> my brain wasn't working at all
20:23:01 <monochrom> now you can't go back to other programming languages. you are spoiled.
20:23:22 <mauke> > ruined for marriage
20:23:27 <blb> i just learned scala and thought the same
20:23:34 <blb> where does the tunnel end???
20:23:44 <monochrom> does not end
20:23:54 <blb> just gets more functional?
20:24:30 <shachaf> The tunnel ends at the end of the list.
20:24:39 <shachaf> @let the_list = 1 : the_list
20:24:40 <monochrom> hahaha
20:24:40 <lambdabot>  Defined.
20:24:54 <mauke> agda
20:25:12 <monochrom> agda is not the end either. more beginnings. no ends.
20:26:37 <shachaf> It's the river than ends on the gada, not the tunnel.
20:29:57 <Daegalus> Can anyone help me figure out why Haskell believes that the OrderedTree data type is not in scope or undefined? http://hpaste.org/52491
20:30:21 <mauke> Daegalus: it's not complaining about a type
20:30:30 <mauke> the error message refers to a data constructor
20:30:53 <mauke> your OrderedTree type has two data constructors, Nil and String
20:31:10 <mauke> String [String [Nil], Nil]  -- valid
20:32:14 <hpaste_> monochrom annotated “OrderedTree” with “OrderedTree (annotation)” at http://hpaste.org/52491#a52492
20:32:29 <monochrom> Daegalus: see my paste
20:32:38 <mauke> so many redundant brackets
20:33:28 <Daegalus> monochrom: that would be great, but I can't modify the sampleTree. That is a test that needs to stay unedited that the professor is checking.
20:33:59 <mauke> Daegalus: so what can you change?
20:34:17 <monochrom> yeah, what can I change?
20:34:54 <Daegalus> only the new type... I am supposed to create the OrderedTree type that will match the test
20:35:07 <monochrom> OK will do, but I hate it pedagogically
20:35:20 <ddarius> hlint integrated into hpaste has automated me out of existence.
20:35:57 <hpaste_> monochrom annotated “OrderedTree” with “OrderedTree (annotation)” at http://hpaste.org/52491#a52493
20:36:07 <monochrom> there
20:36:46 <Daegalus> blah, wasnt too far off -_-
20:37:08 <monochrom> but the professor is doing you a disservice pedagogically by having type name and value name being the same. it is the cause of the original confusion.
20:37:30 <mauke> Word.
20:38:02 <monochrom> I would impeach such a professor and get his/her tenure revoked if possible.
20:38:06 <Daegalus> monochrom: the odd thing, his examples using a Binary Search Tree actually use Node.
20:38:12 <mauke> hahahaha
20:39:20 <Daegalus> Sorry for all the noobishness and crap, the professor is actually really bad, so I am kinda going at this with poor instruction. Im trying to amend things through questions and googling
20:40:09 <mauke> @where lyah
20:40:09 <lambdabot> http://www.learnyouahaskell.com/
20:40:38 <ddarius> Daegalus: Eliminate the professor.  Save tons of money.
20:40:42 <mauke> you're free to noob out ... if you can take THE HEAT!
20:41:06 <Daegalus> ya i am using that as a reference, he actually gave us that link. But he assigned this today out of the blue with minimal instruction, and expects it done by 11:59 tonight and turned in
20:41:09 <shachaf> > fmap text reverse "HAYL LYAH"
20:41:10 <lambdabot>   HAYL LYAH
20:41:39 <Daegalus> is there a 'children' function anywhere in teh default haskell libraries?
20:41:46 <monochrom> no
20:42:52 <mauke> @hoogle children
20:42:52 <lambdabot> No results found
20:43:03 <co_dh> @type text
20:43:04 <lambdabot> String -> Doc
20:43:16 <Daegalus> sigh "  putStrLn (show (head (children sampleTree)))" is one of the tests. he never instructs us to implement it, and unless you can do that through the data type doing something like OrderedTree { name::String, children::OrderedTree }, i dunno what he wants
20:43:16 <co_dh> @type reverse
20:43:17 <lambdabot> forall a. [a] -> [a]
20:44:01 <monochrom> I don't know what he wants either.
20:44:07 <co_dh> I believe children has type tree -> [ tree]
20:44:21 <Daegalus> there is no children
20:44:24 <mauke> Daegalus: he wants you to write 'children'
20:44:24 <monochrom> not the least because I haven't read the assignment verbatim
20:44:29 <co_dh> you implement it.
20:44:46 <mauke> Daegalus: how many tests involve 'children'?
20:44:51 <Daegalus> jsut that one
20:44:52 <wavewave> hi
20:44:59 <mauke> Daegalus: excellent; hardcode the result
20:45:04 * hackagebot git-annex 3.20111011 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20111011 (JoeyHess)
20:45:07 * monochrom saw it coming
20:45:12 <co_dh> :@type fmap
20:45:27 <co_dh> @type fmap
20:45:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:45:28 <Daegalus> mauke: monochrom: http://pastebin.com/rE3xqAix thats the part im implementing now
20:45:30 <mauke> The paste rE3xqAix has been copied to http://hpaste.org/52494
20:46:32 <co_dh> @type fmap text reverse
20:46:33 <lambdabot> [Char] -> Doc
20:46:38 <mauke> Daegalus: what's the representation in Assignment 2?
20:46:52 <monochrom> I don't see "children". and I haven't seen Assignment 2
20:47:04 <wavewave> .
20:47:12 <Daegalus> monochrom: mauke: sorry was working on it finding the file: http://pastebin.com/fZBg5XK6
20:47:15 <mauke> The paste fZBg5XK6 has been copied to http://hpaste.org/52495
20:47:43 <mauke> wait, "Define an data type"?
20:48:12 <Daegalus> i dont even want to know, maybe hw was thinking "Define an OrderedTree Data Type" or something
20:48:23 <monochrom> I don't know what to say about a prof who makes newbies translate java to haskell (or any language to any other language at all). this is beyond "revoke tenure". I'm thinking "revoke human rights"
20:48:50 <mauke> Daegalus: OrderedTree { name::String, children::[OrderedTree] } looks about right
20:48:59 <companion_cube> by "translate" i assume you mean "write a brand new program" in this case? :)
20:49:08 <Daegalus> mauke: ok, sounds good
20:49:12 <wavewave> or teach what the real mundane life look like
20:50:07 <wavewave> interprete your clients' or boss' ambiguous specification.
20:50:14 <companion_cube> monochrom: what would you say if the prof was making newbies translate haskell to java?
20:50:16 <monochrom> companion_cube: the assignment says "write a haskell type for such-and-such java class"
20:50:22 <companion_cube> lol
20:50:23 <monochrom> same thing
20:50:47 <companion_cube> java classes do not match haskell type that easily ôO
20:51:00 <mauke> THEY WILL BY THE TIME I'M DONE
20:51:15 <monochrom> the impedance mismatch due to "null pointer" is the least of the problems
20:51:48 <shachaf> monochrom: No, there exist problems lesser than that.
20:51:53 <Daegalus> Oh btw, this prof pretty much only codes in Java, and this class used to do Scheme I think, but they switched to Haskell per this professors choice
20:52:14 <ddarius> Apparently he doesn't only code in Java.
20:52:18 <monochrom> java-to-scheme is still much impedence mismatch
20:52:18 <companion_cube> i was thinking of subtyping
20:52:19 <Daegalus> well
20:52:23 <ddarius> But now you know not to trust Haskell-folk.
20:52:26 <wavewave> mm
20:52:56 <ddarius> "Translate this untyped lambda calculus interpreter to Agda."
20:53:08 * monochrom snickers
20:54:11 <companion_cube> ddarius: the opposite is hard too if you do not want to lose information :)
20:54:14 <Veinor> 'translate the particle in a box equation to agda'
20:54:45 <companion_cube> 'translate this five years old boy's gibberish into coq proofs'
20:54:48 <wavewave> Daegalus: as for your question, just follow what children mean and define it without thinking about java.
20:55:17 <Daegalus> wavewave: well I know, but I can't define it as a function, so I am just naming the OrderedTree members
20:55:30 <mauke> Daegalus: that just defines it as a function :-)
20:55:41 <Daegalus> oh
20:55:48 <wavewave> Daegalus: you can view it by pattern match.
20:55:56 <mauke> wavewave: ?
20:56:16 <Daegalus> well, now I need to write a Show override to get this to print output. hopefully i can get the recursion right
20:56:39 <mauke> not a Show override, just a Show instance
20:56:54 <mauke> (you can't really override instances)
20:57:05 <Daegalus> sorry, was using wrong terminology
20:57:18 <monochrom> considering that Assignment 2 had java code...
20:57:42 <ddarius> It could have been worse, "Translate this Java class to a Haskell class."
20:58:01 * Clint twitches.
20:58:14 <mauke> "translate this haskell type to a java class"
20:58:18 <Daegalus> its a Programming Paradigms class
20:58:26 <shachaf> Presumably the professor's goal is to translate a Scheme class to a Haskell class.
20:58:38 <Daegalus> we were writing a Lexer for some random stuff for Assignment 1+2
20:58:51 <Daegalus> in java
20:59:36 <wavewave> Daegalus, mauke : I mean that you don't need to name OrderedTree members (I assume you mean haskell record). You can define a function retreiving children node  using pattern match.
21:00:08 <mauke> yeah, but why?
21:01:49 <monochrom> it is subjectively nicer to use the record syntax and make it a field. more faithful to "use the same representation" (representation refers to the private fields in the java class)
21:02:11 <monochrom> but of course nothing whatsoever can be faithful about the "null" part
21:02:25 <wavewave> mauke: I just assume that he might think he always need to define "member"  to look inside data type.  not meaning one of which is superior.
21:03:30 <monochrom> then again the assignment will be graded by humans. you can do whatever you want and then go complain if marks are deducted
21:04:15 * ddarius recommends shitting on a piece of paper and turning it in.
21:04:38 <monochrom> haha
21:05:13 * mauke sets mode: +troll
21:06:03 <Daegalus> grr, how would i get something like this to work: "output i (x:xs) =  x++(replicate i ' ')++(output (i+1) xs)" im just really tired. the thing errors with "Couldn't match expected type `Char' with actual type `[a0]'"
21:06:43 <RayNbow> replace x with [x]?
21:06:51 <ion> You have three parts separated by ++s. Try them one by one.
21:06:56 <monochrom> what type is x?
21:07:04 <Daegalus> X should be a String
21:07:10 <shachaf> type X = String
21:07:13 <mauke> > let output i (x:xs) =  x++(replicate i ' ')++(output (i+1) xs) in  output 3 ["foo", "bar"]
21:07:14 <lambdabot>   "foo   bar    *Exception: <interactive>:3:4-61: Non-exhaustive patterns in ...
21:07:19 <mauke> Daegalus: works
21:07:30 <mauke> show the rest of the code
21:08:40 <hpaste_> Daegalus pasted “Recursive stuff” at http://hpaste.org/52496
21:08:55 <mauke> Daegalus: line 6 is wrong
21:09:02 <monochrom> " "
21:09:10 <monochrom> @type ' '
21:09:11 <lambdabot> Char
21:09:14 <monochrom> @type " "
21:09:15 <lambdabot> [Char]
21:09:17 <mauke> Daegalus: line 7 is also wrong
21:09:22 <monochrom> whole world of difference
21:09:29 <wavewave> last one '\n'
21:10:36 <monochrom> there are better ways to write a Show instance, but I'll save it for after you graduate
21:10:42 <Daegalus> well i get more errors now
21:10:59 <mauke> yay
21:11:14 <mauke> Daegalus: x is not a String
21:11:22 * BMeph also wonders, idly, if Daegalus thinks the second part of output's definition should have (i-1), vice (i+1)...
21:11:31 <monochrom> and "a" is not a list either
21:11:52 <Daegalus> BMeph: im incrementing to add spaces fo every level of depth
21:11:54 <monochrom> i is indentation level. increases for subtrees
21:12:27 <mauke> might be easier to just pass the indentation as a string
21:12:34 <mauke> maybe not
21:12:39 * BMeph understands, FSVO "understand".
21:13:48 <monochrom> the easiest is to quit this school and find a job and learn haskell during weekends
21:14:19 * ddarius endorses monochrom for President.
21:14:21 <Daegalus> Every other class on campus does Java, C, or C++ this is the only class with Functional programming
21:14:39 <Daegalus> plus I already have a fulltime job lined up starting Next July
21:15:04 <ddarius> It would be ironic if it involved translating Java into Haskell.
21:15:13 <monochrom> hahaha
21:16:09 <wavewave> Daegalus: did you figure out what to change now for fixing the type error?
21:16:26 <ddarius> Please wait for genetic algorithm to converge.
21:16:45 <mauke> please wait for geriatric algorithm
21:17:01 <Daegalus> not in the slightest wavewave. Not sure where I need to change things to get those to be lists, or to properly parse the ORderedTree. Hell he never showed us how to access records of a data type
21:17:25 <ddarius> Some... Most of the best algorithms are geriatric.
21:17:45 <mauke> Daegalus: you use accessor functions
21:18:02 <mauke> 'name a' and 'children a' in your case ... except not
21:18:09 <mauke> Daegalus: you need pattern matching
21:19:28 * wavewave feels that the teacher would make students get very negative impression on haskell..
21:19:36 <companion_cube> Daegalus: you have a class in which you use Haskell ? sweet
21:19:41 <mauke> hah
21:20:12 <Daegalus> companion_cube: yes, but at the moment its more like bashing my face into the keyboard using haskell because the teacher taught us nothing apparently
21:20:50 <Daegalus> I like haskell, i just dont know how to use it properly due to poor instruction. Otherwise i have enough programming experience outside of Haskell to enjoy haskell even when bashing my face into the keyboard
21:21:02 <monochrom> have you seen pattern matching?
21:21:31 <Daegalus> not really. he covered x:_ and _:x and just that _ is for unimportant stuff, other than that, NOPE
21:21:38 <monochrom> have you seen functions defined like myfun (OrderedTree x y) = "the name is " ++ x ?
21:21:58 <Daegalus> ummm, nope. all were myfunction x y
21:22:05 * mauke screams
21:22:07 <wavewave> Daegalus: I see that from what you said.
21:22:31 <mauke> Daegalus: ':' is a data constructor for []
21:22:50 <mauke> data List a = Nil | Cons a (List a)
21:22:56 <Daegalus> omfg, that makes sooo much sense now...... explains why ive been failing at using :
21:22:57 <monochrom> play with my myfun. test it with myfun sampleTree
21:23:01 <mauke> data [] a = [] | (:) a ([] a)
21:23:09 <mauke> ^ not valid syntax, but that's how it actually behaves
21:23:53 <Daegalus> ok, its amazing what a simple sentence can do to improve understanding. he NEVER mentioned it was a data constructor for [] he just randomly used it to concat lists. I thgouth it was jsut another concat symbol
21:24:04 <mauke> ++ is concat
21:24:12 <mauke> : is cons (this may make no sense if you don't know lisp)
21:24:18 <ddarius> concat is concat
21:24:47 <wavewave> Daegalus: Now did you get (:) as data constructor like Cons?
21:25:00 <monochrom> (lisp makes no sense in this channel anyway, i.e., the whole style of using null? car cdr)
21:25:12 <BMeph> ++ is cat? ;)
21:25:21 <Daegalus> wavewave: i think
21:25:52 <mauke> [1,2,3] == (:) 1 ((:) 2 ((:) 3 []))
21:25:58 <wavewave> Daegalus: as mauke said, list is defined as data List a = Nil | Cos a (List a)  isomorphic to data [] a = [] | (:) a ([] a)
21:26:45 <wavewave> haskell conveniently write (List a) type as [a], Nil as [], Cons as (:)  in infix notation.
21:26:45 <mauke> > case [1,2,3] of { (:) x xs -> "the head is " ++ show x ++ " and the tail is " ++ show xs; [] -> "it is empty" }
21:26:47 <lambdabot>   "the head is 1 and the tail is [2,3]"
21:26:50 <ddarius> The type of (:) explains why you were failing at using it.
21:26:51 <shachaf> data Tan a = Sin | Cos a (Tan a)
21:26:54 <mauke> > case [] of { (:) x xs -> "the head is " ++ show x ++ " and the tail is " ++ show xs; [] -> "it is empty" }
21:26:55 <lambdabot>   "it is empty"
21:27:00 <BMeph> Hey, you, speak Engrish!
21:27:10 <mauke> tanasinn!
21:27:47 <monochrom> was ist Engrish?
21:28:05 <shachaf> Types are oppressors. Rise above them and be free!
21:28:05 <Daegalus> though< I still am not sure hwo to modify the Show and Output function to get this to work. I jsut need to get the name records and recurse down.
21:28:17 <wavewave> Daegalus: Cons has two arguments : first is element, second is lists.     that means the same for (:)
21:28:36 <mauke> Daegalus: you need to write two equations for show
21:28:47 <mauke> Daegalus: one dealing with Nil, the other dealing with OrderedTree
21:29:18 <wavewave> Daegalus : then in (x:xs), x must be an element and xs must be list. for Char and String, x must be Char, xs must be [Char] = String
21:29:52 <mauke> > Node "test" []
21:29:53 <lambdabot>   Node {rootLabel = "test", subForest = []}
21:30:00 <wavewave> Daegalus: I think now you are able to see why type error happens in your code.
21:30:30 <mauke> @let name = rootLabel; children = subForest
21:30:31 <lambdabot>  Defined.
21:30:39 <mauke> > name (Node "test" [])
21:30:41 <lambdabot>   "test"
21:30:53 <ddarius> Mu (Either a . shachaf)
21:31:14 <Daegalus> ya, I can see that quite clearly. i guess Im just not thinking about this the right way to get this to work. how would i got from having char:string to string:OrderedTree for teh output?
21:31:21 <accel> is there a latex symbol for stating that a function is 1-to-1 ?
21:31:37 <mauke> injective?
21:31:55 <mauke> Daegalus: that question makes no sense
21:32:11 <mauke> Daegalus: your show needs to go OrderedTree -> String
21:32:27 <wavewave> Daegalus: are you sure that you need string:OrderedTree for the output?
21:32:44 <Daegalus> well I need to recurse down into sub OrderedTrees to get their names too
21:32:58 <mauke> what does the output format look like?
21:33:09 <wavewave> Daegalus: In haskell, it is very helpful to think about what is your final result type in your question. not intermediate step.
21:33:47 <wavewave> Daegalus: you are thinking about intermediate data type (string:OrderedTree) in imperative way.
21:33:49 <hpaste_> Daegalus pasted “Java Output” at http://hpaste.org/52498
21:34:08 <Daegalus> something like that
21:34:20 <mauke> I don't get it
21:34:34 <wavewave> Daegalus: that's exactly what you should unlearn now.
21:34:41 <mauke> Daegalus: what are those words?
21:35:16 <Daegalus> mauke: sorry like I said we were writing a parser for I think a dumbed down version of haskell, and thats the output of the orderedtree we create from teh expression given
21:35:17 <shachaf> ddarius: Is that a type-level (.)?
21:35:40 <wavewave> Daegalus: you think (string:OrderedTree) = (your current resultant string): (remaining tree)  in intermediate step.
21:35:40 <mauke> Daegalus: what does the tree look like?
21:36:21 <Daegalus> mauke: http://cs.sjsu.edu/faculty/smithj/classes/152/a2.html here is the assignment for the parser, has a tree, and a print out of the indented tree
21:36:31 <Daegalus> wavewave: i guess ya
21:36:42 <ddarius> accel: You could use ↣, but I doubt your target audience will understand it.
21:36:54 <mauke> Daegalus: yeah, that doesn't make sense
21:37:00 <wavewave> Daegalus: do not think about intermediate step. just focus on the nature of your problem.
21:37:20 <accel> ddarius: insulting my readers?
21:37:33 <accel> ddarius: I like you. I don't like my readers very much either.
21:37:44 <Daegalus> wavewave: well my problem is I need to go OrderedTree -> String
21:37:55 <wavewave> Daegalus: bingo!
21:38:29 <Daegalus> that i understand, i just am not sure how to get there. Im having a problem with syntax and overall how haskell works
21:38:31 <ddarius> accel: That's not insulting.  Your target audience probably won't understand Telegu either.
21:38:36 <mauke> Daegalus: you can pretty much copy the toString function from java
21:38:45 <wavewave> Daegalus: okay. now think one by one! let's think about easiest one..
21:39:07 <wavewave> Daegalus: your OrderedTree has two cases : one is Nil, the other is OrderedTree
21:39:21 <wavewave> Daegalus: where should Nil go?
21:39:45 <Daegalus> straight to an empty string
21:40:15 <wavewave> Daegalus: that's right; now you can define a function f .   f  Nil = ""
21:40:33 <wavewave> Daegalus : this is pattern-matching
21:40:44 <mauke> Daegalus: bonus question: why does Nil exist at all?
21:40:52 <Daegalus> so can i do something like this: "show nil = "" "
21:40:56 <mauke> Daegalus: is it used in your teacher's tests?
21:41:02 * ddarius introduces contradiction into accel's life by reading whatever it is he's planning on writing.
21:41:03 <mauke> Daegalus: no, show Nil = ""
21:41:07 <mauke> capitalization matters
21:41:12 <Daegalus> teacher hasnt given us a test on haskell
21:41:20 <ddarius> ...
21:41:21 <mauke> Daegalus: so ... do you really need Nil?
21:41:35 <mauke> because if not, you can simply remove it from your data definition
21:41:59 <Daegalus> mauke: yes because and OrderedTree can have an empty  or non-existant child orderedtree
21:42:25 <mauke> Daegalus: an empty list of children is simply []
21:42:47 <mauke> Daegalus: and your java code won't handle the case where one of the children is null anyway
21:43:03 <mauke> so ... get rid of Nil
21:43:05 <Daegalus> so I dont need hte Nil in the data tpe
21:43:21 <mauke> that should simplify things a bit, because now you don't need to know about pattern matching
21:43:26 <wavewave> Daegalus: in fact, yes in this case.
21:43:57 <ddarius> And we all know that pattern matching is the work of the devil.
21:44:00 <Daegalus> so, can I do something like this: "show (OrderedTree x y) = show (output 0 (OrderedTree x y))"
21:44:02 <wavewave> Daegalus: since [a] already has [] case.
21:44:20 <mauke> Daegalus: that looks slightly crazy
21:44:33 <mauke> Daegalus: and equivalent to show x = show (output 0 x)
21:44:50 <mauke> Daegalus: what does 'output' return?
21:45:01 <Daegalus> output should return a string
21:45:02 <wavewave> Daegalus : but you need  pattern match for your [OrderedTree] again.
21:45:09 <mauke> Daegalus: then you don't want to call show again
21:45:44 <mauke> Daegalus: seriously, I'd start by trying to translate the toString method
21:46:06 <Daegalus> output i (x:xs) =  x++(replicate i ' ')++(output (i+1) xs)++"\n" <--- so that is all bogus for the most part now.
21:47:39 <wavewave> Daegalus : anyway, you had better look into each case one by one now as a learning process.
21:47:43 <companion_cube> Daegalus: oh, too bad he's wasting the opportunity to teach haskell properly :/
21:49:08 <wavewave> Daegalus: Now I am moving to the next case: you already did Nil case. Now you have OrderedTree case. What possibilities do you have in OrderedTree case?
21:49:34 <Daegalus> OrderedTree String [OrderedTreee]
21:49:51 <wavewave> Daegalus: Yes, that is not one case indeed.
21:49:51 <mauke> yep, java translation works
21:49:59 <mauke> the only tricky bit is the iterator loop
21:50:29 <mauke> Daegalus: do you know any list utility functions like map/filter/concat/etc?
21:50:40 <Daegalus> yes
21:50:54 <wavewave> Daegalus: recall what [a] type is.
21:51:07 <Daegalus> anything?
21:51:29 <mauke> Daegalus: ok, then you don't need any pattern matching anywhere
21:51:30 <wavewave> Daegalus: as we discuss above.
21:52:07 <wavewave> data List a = Nil | Cons a (List a )
21:52:18 <mauke> one difference is that instead of resultSoFar.append(X); resultSoFar.append(Y); you simply write X ++ Y in Haskell
21:52:52 <mauke> you also have to recognize that lines 153,154 in the java code are redundant
21:52:55 <ddarius> Neither X nor Y are lists.
21:52:57 <wavewave> translate List a to [a], Nil to [],  Cons to (:)
21:53:14 <mauke> ddarius: they're metasyntactic variables
21:53:27 <ddarius> Metasyntactic variables are also not lists.
21:53:43 <mauke> they are now
21:53:44 <wavewave> Daegalus: then [a] type has two cases :  [] or (x : xs)
21:54:06 <wavewave> where x is in a type and xs is in [a] type again.
21:55:05 <wavewave> Daegalus: now once you identify your cases of your datatype, write down appropriate behavior for each type case by case.
21:55:34 <mauke> (or you could simply copy the java code)
21:55:38 <wavewave> Daegalus: if you cover all cases, that' it. that's how you define a function in haskell.
21:56:59 <wavewave> Daegalus : all haskell functions are basically defined by this pattern matching. this is the first thing you have to get before learning how to translate java to haskell.
21:58:51 <wavewave> Daegalus: and with the complete pattern matching of this recursive type, you will find you define an algorithm.
21:59:18 <wavewave> Daegalus: this is how to program declaratively.
22:01:04 <DanBurton> Hey guys, how is fmap defined on functions?
22:01:11 <wavewave> Daegalus: and that's why it is misleading to translate an imperative program directly into haskell.
22:01:18 <ddarius> fmap = (.)
22:01:41 <DanBurton> ddarius: thx :) that's what I thought
22:01:53 <ddarius> DanBurton: Next time prove.
22:02:29 <wavewave> Daegalus: I see you have some good experience in programming language, so you will get this easily. just keep in mind that some unlearning process is needed.
22:05:04 * hackagebot zoom-cache 0.2.0.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.2.0.0 (ConradParker)
22:09:45 <Daegalus> Ok, I think I got it, now I just need ot figure out how to handle empty children so head doesn't get all bitchy
22:09:46 <Daegalus> output i x = (node x) ++ "\n" ++ (replicate i ' ') ++ (output (i+1) (head (children x)))
22:10:17 <mauke> that looks wrong
22:10:28 <Daegalus> "usa\nw\n ca\n  *** Exception: Prelude.head: empty list
22:10:30 <Daegalus> gave me that
22:10:44 <wavewave> wow it's classic.
22:11:06 <ujihisa> http://www.slideshare.net/ujihisa/text-manipulation-withwithout-parsec
22:11:08 <mauke> Daegalus: according to the java code the output should start with indentation
22:11:26 <Daegalus> mauke: i know, the newlines arent being rendered properly.
22:11:36 <mauke> Daegalus: what
22:11:47 <DanBurton> Hey guys, what do you think about the "unfoldrM" I wrote here? http://stackoverflow.com/questions/7733482/how-do-i-handle-an-infinite-list-of-io-objects-in-haskell/7735551#7735551
22:12:04 <Daegalus> The indentation looks fine. if you notice the spaces. its jsut the newlines are just being printed
22:12:22 <mauke> Daegalus: the indentation doesn't look fine
22:12:51 <Daegalus> well, ill fix that up when I get the head problem worked out
22:13:16 <mauke> oh well, I tried
22:13:19 <Daegalus> I got less than 2 hours to get this, and im already tired as hell, so Im jsut making it work however i can
22:13:49 <mauke> so why are you ignoring my suggestion?
22:13:57 <mauke> wouldn't it be simpler?
22:14:03 <wavewave> Daegalus: first, you should not use head if argument can be []. head is not defined for [], so that it gave that exception.
22:14:55 <Daegalus> i know head doesnt handle [] but children x returns [OrderedTree] not OrderedTree
22:15:27 <wavewave> Daegalus: yes. so children can produce [] and head cannot treat it. so it gave the error.
22:15:46 <wavewave> Daegalus: you got this, right?
22:16:14 <Daegalus> i know, so i added a check that checks if the children is [] and returns node only
22:16:31 <wavewave> Daegulus: now you have to treat [] differently. That's again pattern matching.
22:16:39 <wavewave> Daegalus: do you know case of ?
22:16:42 <Daegalus> output i x =
22:16:43 <Daegalus>   if children x == [] then node x
22:16:43 <Daegalus>   else (node x) ++ "\n" ++ (replicate i ' ') ++ (output (i+1) (head (children x)))
22:16:50 <wavewave> case ... of  .... ->
22:17:03 <Daegalus> no, we havent covered case
22:17:07 <wavewave> Daegalus: no. in haskell == is not defined as a default
22:17:22 <mauke> wavewave: works here, though
22:17:35 <Daegalus> *Main> show sampleTree
22:17:35 <Daegalus> "usa\nw\n ca"
22:17:36 <ddarius> x == y = not (x /= y)
22:17:41 <mauke> Daegalus: try without 'show'
22:17:52 <mauke> Daegalus: that should also look better
22:17:57 <wavewave> Oh.. you defined it as Eq.
22:18:12 <wavewave> okay.. I didn't see that (hidden in my webbrowser. )
22:18:32 <ddarius> blah == [] is still evil
22:18:53 <mauke> ddarius: but vastly better than length blah == 0
22:19:06 <Daegalus> mauke: ok, its identing 1 after its supposed to. so "usa" and "w" are on the same line, even though "w" should have a space
22:19:47 <mauke> Daegalus: why do you keep ignoring everything I say about just translating the java code?
22:20:07 <ddarius> No one likes you mauke, apparently.
22:20:11 <mauke> :-(
22:20:19 <wavewave> Daegalus: using 'case .. of' is better, but okay, I do not want to go over your current curriculum... So in this case, use (==). and remember that's because (deriving (Eq)) in the definition of OrderedTree
22:20:33 <Daegalus> i dunno, seems 1000x harder than getting this to work. Only thing lef tis to iterate. since it olly does 1 tree line, not all of them
22:20:49 <mauke> Daegalus: why do you think it would be harder?
22:20:57 <mauke> it's only like 3 lines
22:21:50 <Daegalus> because aside from the iteration of all the children, i dont see much else i need to add
22:21:50 <DanBurton> @pl let myUnfoldrM f = unfoldrM (liftM (fmap tuplefy) . f) in myUnfoldrM
22:21:50 <lambdabot> unfoldrM . (fmap (fmap tuplefy) .)
22:22:23 <siracusa> :t tuplefy
22:22:24 <lambdabot> Not in scope: `tuplefy'
22:22:24 <Daegalus> im thinking of mapping output across all the children... that might work
22:22:44 <DanBurton> I made tuplefy up. tuplefy x = (x,x)
22:22:51 <RayNbow`TU> @hoogle dup
22:22:51 <lambdabot> Control.Concurrent.Chan dupChan :: Chan a -> IO (Chan a)
22:22:51 <wavewave> Daegalus: so you figured it out now?
22:22:51 <lambdabot> Control.Concurrent.STM.TChan dupTChan :: TChan a -> STM (TChan a)
22:22:51 <lambdabot> Language.Haskell.Syntax data HsFieldUpdate
22:22:56 <Jafet> join (,)
22:22:57 <RayNbow`TU> hmm
22:23:08 <DanBurton> @hoogle a -> (a,a)
22:23:09 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
22:23:09 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
22:23:09 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
22:23:30 <Daegalus> wavewave: maybe, trying to see if I can figure out if i need to do anything special to map a fucntion with 2 parameters
22:24:07 <DanBurton> Daegalus: zipWith, perhaps?
22:24:20 <mauke> DanBurton: what
22:24:45 <DanBurton> "map a function with two parameters" sounds like zipWith
22:24:53 <mauke> no, it doesn't
22:25:10 <DanBurton> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
22:25:11 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
22:25:11 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
22:25:11 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
22:25:21 <mauke> DanBurton: that's two lists
22:25:26 <DanBurton> that it is
22:25:37 <DanBurton> he never said map onto a single list
22:25:45 <mauke> you have no choice
22:25:51 <mauke> you always map into a single list
22:26:04 <DanBurton> but you can think of zipWith as a sort of "map" onto 2 lists
22:26:10 <mauke> no
22:26:20 <Daegalus> (map output (i+1) (head (children x))) im trying to do something like that, oviously thats wrong, but im working it out
22:26:21 <mauke> zipWith draws from two lists in parallel. you still end up with one output list
22:26:40 <mauke> Daegalus: map (output (i+1)) (children x)
22:27:15 <wavewave> Daegalus : haskell is hard, isn't it? :-)
22:27:24 <DanBurton> Daegalus: probably what mauke said. you need to parenthesize the partially-applied function so that map knows what to map over the list
22:27:29 <Daegalus> wavewave: just the thought process
22:27:42 <DanBurton> wavewave: s/hard/different
22:28:35 <wavewave> Daegalus: did you get what mauke's suggestion means now?
22:28:46 <Daegalus> yes, i was thinkng that, but i wasnt sure if you could do partial
22:28:53 <Daegalus> so i was not trying it
22:29:05 <wavewave> Daegalus: have you heard of currying?
22:29:16 <Daegalus> now i am getting a type mismatch between Char and String
22:29:19 <Daegalus> yes
22:29:28 <mauke> Daegalus: yeah, I wasn't sure if you knew about partial application
22:29:41 <mauke> so I used a helper function in my sample solution
22:29:50 <Daegalus> (node x) ++ "\n" ++ (replicate i ' ') ++ (map (output (i+1)) (children x)) --- is what i have
22:30:17 <Daegalus> but its not liking it
22:30:20 <wavewave> Daegalus: okay. just to make sure :  output (i+1) = \x -> output (i+1) x
22:31:26 <wavewave> Daegalus: :-) wow, you hit all classic problems today.
22:31:40 <Daegalus> Awesome :P
22:32:15 <Daegalus> I think for some reason the partial is expecting Char adn getting a String
22:32:37 <wavewave> Daegalus: just think about what type (map (output (i+1)) (children x)) is
22:33:24 <Daegalus> well, it should be an array of strings i think.
22:33:29 <Daegalus> err list of strings
22:34:02 <wavewave> Daegalus: then, isn't it strange?
22:34:47 <DanBurton> wavewave: looks like lisp with all those parens :)
22:35:00 <wavewave> Daegalus: look at the other terms
22:35:21 <wavewave> DanBurton : haskell with outermost ( ) is lisp. ;-)
22:35:38 <Daegalus> ya i see the problem, I need to go from a [Strings] to String
22:35:50 <wavewave> Daegalus: bingo.
22:35:57 <DanBurton> wavewave: and no infix allowed :P
22:36:08 <wavewave> Daegalus: let me tell you a tip.
22:36:10 <mauke> wavewave: (((1)))
22:36:10 <Daegalus> not exactly sure how though. take?
22:36:16 <mauke> Daegalus: concat
22:36:27 <wavewave> DanBurton, mauke: agree agree :-P
22:36:37 <wavewave> @google hoogle
22:36:38 <lambdabot> http://www.haskell.org/hoogle/
22:36:39 <lambdabot> Title: Hoogle
22:36:49 <wavewave> try hoogle
22:37:13 <DanBurton> don't just try it. LOVE it. Hoogle isn't just your friend. It's your BEST friend <3
22:37:39 <Daegalus> wavewave: so I am assumeing I concat the Map to the first part thats a string? or map a concat to the map that i already have
22:37:46 <wavewave> Daegalus: okay, in this case, this may cause some confusion to you..
22:38:02 <wavewave> Daegalus: anyway. concat is the answer as mauke said.
22:38:17 <mauke> Daegalus: you can connect the pieces just by looking at the types
22:38:23 <mauke> Daegalus: you have: [OrderedTree]
22:38:24 <wavewave> > concat ["ab" , "cd" ]
22:38:24 <lambdabot>   "abcd"
22:38:28 <mauke> Daegalus: you want: String
22:38:43 <mauke> Daegalus: output x :: OrderedTree -> String
22:38:57 <wavewave> Daegalus: Do you know function composition?
22:38:58 <mauke> Daegalus: map (output x) :: [OrderedTree] -> [String]
22:39:05 <mauke> Daegalus: concat :: [String] -> String
22:39:46 <Daegalus> > :t concat
22:39:47 <lambdabot>   <no location info>: parse error on input `:'
22:39:56 <wavewave> :t concat
22:39:56 <mauke> :t concat
22:39:57 <lambdabot> forall a. [[a]] -> [a]
22:39:57 <lambdabot> forall a. [[a]] -> [a]
22:40:04 <mauke> @src String
22:40:04 <lambdabot> type String = [Char]
22:40:08 * ddarius is really surprised just how many people write > :t foo
22:40:16 <DanBurton> :t concat
22:40:17 <lambdabot> forall a. [[a]] -> [a]
22:40:20 <DanBurton> just to join the fun
22:40:38 <DanBurton> @botsnack
22:40:38 <lambdabot> :)
22:40:45 <ddarius> :t join
22:40:46 <Daegalus> ok, PROGRESS, but the output isnt right
22:40:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:41:36 <wavewave> Daegalus: good! probably you are not far from the final goal if your program is compiled well.
22:41:56 <Daegalus> i need to add an additional "\n" during the concat between the concacted pieces.
22:42:08 <Daegalus> I feel like i need to through in a Zip in there, making it more complicated
22:42:20 <hpaste_> mauke pasted “complete solution” at http://hpaste.org/52502
22:43:01 <Daegalus> wow yours looks quite different from mine
22:43:42 <Daegalus>  (node x) ++ "\n" ++ (replicate i ' ') ++ (concat (map (output (i+1)) (children x))) ---- and all thats missing is the new lines between the concats
22:43:45 <wavewave> Daegalus: no need to use zip. just change your function behavior
22:44:30 <mauke> Daegalus: why quite different? it's almost the same
22:44:41 <wavewave> Daegalus: anyway, I think you have almost enough information to solve this by yourself from now on.
22:45:19 <mauke> Daegalus: the main differences are: 1) you use an integer instead of a string to represent the indentation level, and 2) you insert the indentation in the wrong place
22:45:21 <wavewave> Daegalus: another tip is define things using 'let' or 'where' is helpful.
22:45:52 <wavewave> Daegalus: refer to your reference books.
22:47:26 <wavewave> Daegalus: experiment your expression in various ways and try to understand why the result look like that.
22:48:17 <wavewave> Daegalus: I am stopping here ;-) hope that you enjoy haskell programming.
22:48:35 <Daegalus> wavewave: thank you very much for the help, very much appreciated
22:48:46 <Daegalus> mauke: you too, exteremely appreciative of your help
22:50:38 <ddarius> "I'm extremely appreciative to your help, mauke, but not quite appreciative enough to listen to it."
22:50:50 <mauke> heh
22:51:09 <mauke> you end up at the same solution anyway
22:57:46 <hpaste_> “not fun” pasted “blb” at http://hpaste.org/52503
22:57:55 <blb> aren't those lines equivalent?
22:58:04 <blb> …trying to translate some haskell to python
23:00:06 <ddarius> The first line is a syntax error.
23:00:29 <blb> how so
23:00:50 <porges> is anyone familiar with Alex? - more specifically, how to hack it to accept unicode inputs for the regex sections
23:02:34 <blb> ddarius: what do you mean?
23:03:15 <blb> other than it not being indented
23:10:44 <blb> mauke: still around?
23:11:42 <blb> Daegalus: ?
23:11:48 <Daegalus> ?
23:11:50 <quicksilver> blb: you're missing a guard |
23:11:58 <quicksilver> to introduc that condition
23:12:37 <quicksilver> sumOnesOfPositiveRange from to | from < 0 && to <= 0 = 32 * (to - from + 1) - sumOnesOfPositiveRange (negate (to + 1)) (negate (from + 1))
23:13:31 <blb> sorry about that
23:14:00 <blb> i just placed the function definition there so people would know its parameters
23:14:19 <blb> heh
23:14:34 <blb> thats not the full definition,
23:15:13 <blb> beyond the guard are they equivalent?
23:16:03 <hpaste_> blb pasted “blb” at http://hpaste.org/52504
23:16:30 <blb> quicksilver fwiw, thats the full definition of both
23:24:45 <Daegalus> is there a way to fold a list of booleans?
23:25:03 <gaze__> would it make sense to have a TVar of a list of TVars?
23:25:21 <c_wraith> Daegalus: many ways.  you have anything more specific to ask?
23:25:29 <gaze__> say you have a bunch of threads that have local storage that each one should be able to modify.
23:25:57 <c_wraith> gaze__: it would make sense in the case where it's common to update elements of the list, but not common to change what elements are in the list
23:26:38 <gaze__> what would make more sense in the latter case?
23:26:50 <Daegalus> c_wraith: well I have a function "member" that takes 2 argumetns, a String and an orderedTree. It tries to find if the value exists anywhere on the tree. I get a List of Booleans at the end, and what I need is to return True, if any in the list are true.
23:27:05 <c_wraith> :t and
23:27:06 <lambdabot> [Bool] -> Bool
23:27:24 <c_wraith> err, except that's the opposite of what you asked for
23:27:26 <c_wraith> :t or
23:27:27 <lambdabot> [Bool] -> Bool
23:27:57 <c_wraith> @src or
23:27:58 <lambdabot> or    =  foldr (||) False
23:28:31 <gaze__> also, why should it have that restriction?
23:29:23 <c_wraith> gaze__: well, for stm in particular, it's really important to know the intended access patterns.  stm works best when you have small, generally non-overlapping subsets of a large number of mutable cells that you want to update atomically
23:29:54 <Daegalus> c_wraith: thanks, that partially helped, but now everything is returning true. even though it should have a few false in there.
23:30:32 <c_wraith> Daegalus: I can't contribute anything more than "you must have a bug" with just that description. :)
23:31:30 <Daegalus> c_wraith: http://hpaste.org/52505 check the annotation
23:34:15 <c_wraith> > or []
23:34:15 <lambdabot>   False
23:35:04 <Daegalus> > or [[],True]
23:35:05 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
23:35:05 <lambdabot>         against inferred type ...
23:35:10 <c_wraith> well, not your problem, but line 4 is redundant
23:35:12 <ddarius> @src any
23:35:12 <lambdabot> any p =  or . map p
23:35:53 <c_wraith> I don't know.  That code looks right.  Are you sure none of those strings are in the tree?
23:36:15 <c_wraith> err, are you sure some of them are not in the tree
23:37:35 <c_wraith> where is sampleTree defined?
23:37:46 <hpaste_> Daegalus annotated “Member” with “Member (annotation) (annotation)” at http://hpaste.org/52505#a52507
23:37:55 <Daegalus> c_wraith: ^^^
23:38:28 <c_wraith> uh.  yes, everything test7a is looking for is in the tree.
23:38:30 <c_wraith> looks right to me
23:38:40 * ddarius would give up hope on humanity if he hadn't already given it up a long time ago.
23:40:03 <Daegalus> c_wraith: oh my bad, I was looking at the wrong test on a different part. Sorry, it works. thank you
