00:01:37 <Haskill> should i use regexp to do the substitution or is there something else?
00:01:39 <dmoctezuma> Haskill, I'd wish they teach it at my university :-)
00:02:11 <Haskill> @dmoctezuma: what do they teach at yours?
00:02:12 <lambdabot> Unknown command, try @list
00:02:58 <dmoctezuma> Haskill, Scheme, JAVA and C#
00:04:49 <Haskill> see, i can do all that
00:05:02 <erus`> Most universities set you up for the brain dead  java/c# roles (or so i hear)
00:05:05 <Haskill> haskell is just...a very different mindset that i have to get it
00:05:07 <Haskill> in*
00:05:38 <Haskill> what's brain dead java/c# roles?
00:05:51 <rostayob> well some universities teach haskell/ml whatever as first language
00:06:05 <dmoctezuma> Haskill, well, take it as a challenge and a opportunity to learn a new world. It has very cool features.
00:06:39 <Haskill> i dunno man, up until now, I haven't been convinced but today I'm starting to get a bit of it so maybe i'll use it in the future
00:06:48 <{][3473|^> most C#/Java roles are brain dead
00:06:56 <dmoctezuma> agree
00:07:01 <Haskill> what is "brain dead"?
00:07:03 <shachaf> JAVA is similar to PERL, right?
00:07:07 <shachaf> In that they both run on a MAC?
00:07:09 <{][3473|^> Haskill: uninteresting
00:07:22 <{][3473|^> shachaf: Java/J/Joomla
00:07:23 <dmoctezuma> shachaf, cross-platform yes
00:07:48 <rostayob> the fact that most java/c# are bran dead is not because java or c#
00:07:55 <rostayob> well maybe in part...
00:08:01 <rostayob> *because of
00:08:05 <{][3473|^> you have been sheltered
00:08:16 <Haskill> are you ppl talking about the repititive parts of java/c# etc?
00:08:22 <rostayob> them most interesting jobs are in java as well - most programming jobs are in java!
00:08:25 <Haskill> i haven't done enough haskell to know the difference
00:08:27 <shachaf> I wonder whether we could implement HASKELL so it could be used on a MAC.
00:08:44 <Haskill> and i code for Android...so...yeah I dunno what brain dead roles are
00:09:00 * shachaf sighs.
00:09:09 <Haskill> give me an example
00:10:43 <Haskill> subst [("x",5)] x     .... how would you go about substituting x by 5?
00:10:54 <erus`> lol
00:11:12 <Haskill> that's not even the end of this :(
00:11:26 <erus`> > (\x -> x) 5
00:11:27 <lambdabot>   5
00:12:03 <Haskill> lol...but say there was x and y values
00:12:07 <erus`> Haskill: do you have to substitute inside a string?
00:12:18 <dmoctezuma> shachaf, doesn't the haskell-platform run on Mac?
00:12:19 <Haskill> it's a custom data type
00:12:32 <Haskill> if it was a string, i'd just search up regexp and be done
00:12:50 <shachaf> I was talking about MAC, not Mac.
00:12:58 * shachaf never mind
00:13:01 <erus`> > (\x y -> [x, y]) 5 4
00:13:02 <lambdabot>   [5,4]
00:13:09 <dmoctezuma> oh
00:13:24 <Haskill> hmm..
00:13:43 <Haskill> i don't see what's happening... but i understand that it's getting substituted ...
00:14:04 <erus`> Haskill: do you know any other programming languages ?
00:14:06 <Haskill> how would i go about getting the actual variable name?
00:14:28 <Haskill> yes, java, little python, web lingos
00:14:34 <erus`> Haskill: you can't get the variable name from an expression without reflection
00:14:59 <erus`> maybe you could show me the problem you are trying to solve in java
00:15:03 <erus`> and i will give you a hint
00:15:03 <rostayob> > lookup "x" [("x", 5)]
00:15:04 <lambdabot>   Just 5
00:15:13 <rostayob> Haskill: that's what you meant i suppose
00:15:25 <Haskill> i think...yes
00:15:34 <Haskill> @erus: you mean I code this in java?
00:15:34 <lambdabot> Unknown command, try @list
00:15:38 <tigger_> actually that's interesting, if let hi = 5, how would you get the string that is the variable name in haskell? so myfunc (hi) == "hi", does such a function exist
00:15:55 <Axman6> you can't
00:15:55 <rostayob> tigger_: you can use template haskell to do that
00:15:56 <shachaf> tigger_: Nope, and it shouldn't exist.
00:16:01 <tigger_> haha cool
00:16:08 <rostayob> (more or less)
00:16:11 <tigger_> why shouldn't it exist
00:16:11 <tigger_> ?
00:16:12 <shachaf> rostayob: No, you can't use template Haskell to do *that*.
00:16:26 <shachaf> tigger_: Because it breaks a lot of the point of Haskell.
00:16:38 <Axman6> changing identifier names shouldn't change the semantics of a program (to quote shachaf i think)
00:16:38 <rostayob> shachaf: why not?
00:16:40 <shachaf> E.g. myfunc x = "x", but let y = x in myfunc y == "y"
00:16:51 <shachaf> Axman6: I don't think you're quoting me. :-)
00:16:53 <tigger_> gotcha, nice
00:16:54 <tdammers> variable names live in the realm of source code; they are lost in compilation
00:16:56 <shachaf> But that's indeed true.
00:17:00 <tdammers> just like in C/C++
00:17:02 <rostayob> you can create a function that generates a function definition with a certain name
00:17:03 <Axman6> it wasn't you? maybe kmc
00:17:07 <shachaf> rostayob: Because, well, how would you do it?
00:17:11 <erus`> tdammers: they live on in debug symbols
00:17:15 <rostayob> shachaf: ^^
00:17:27 <rostayob> like $(generateStupidFun "blah")
00:17:34 <tdammers> they do, but debug symbols aren't actually part of the binary, strictly speaking
00:17:35 <rostayob> you can't change the name of a function
00:17:36 <shachaf> rostayob: Right -- you can go from the string "hi" to the variable hi, at compile-time, but that's backwards from what tigger_ said.
00:17:40 <shachaf> And not *as* bad.
00:17:43 <Axman6> erus`: that's not exactly part of the program though
00:17:49 <rostayob> shachaf: oh, ok, then i misunderstood
00:17:50 <Axman6> it's instrumentation of the program
00:17:59 <tdammers> you can strip them out, and the program still functions the same
00:18:09 <rostayob> ah yes, i misunderstood
00:18:12 <erus`> tdammers: not if sed program read the debug symbols
00:18:27 <shachaf> erus`: That's not what "program" means in Haskell.
00:18:36 <tdammers> erus`: which is exactly why C++ doesn't have reflection built into the language
00:18:49 <tdammers> (and neither does haskell)
00:19:22 <Haskill> `erus: i'll show you in python if that's okay
00:19:29 <erus`> Haskill: ok
00:21:46 <tdammers> there's another reason why reflection is hard in haskell
00:22:08 <tdammers> functions are, conceptually speaking, kind of search-replace patterns
00:22:27 <dmoctezuma> now that some of you mention reflection-related things, I wonder if Haskell lets you modify code in real-time (via runghc perhaps?), or possibility of mutable code?
00:22:30 <shachaf> @google extensionality
00:22:31 <lambdabot> http://en.wikipedia.org/wiki/Extensionality
00:22:31 <lambdabot> Title: Extensionality - Wikipedia, the free encyclopedia
00:22:32 <tdammers> because they're pure, calling a function or inlining its definition are interchangeable
00:23:45 <tdammers> so there's no guarantee that the compiler will even generate anything for a particular function - it might end up being inlined everywhere
00:24:30 <tigger_> also, im trying to build a basic gui frontend, and am pretty familiar with qt in python. there is qtHaskell, but from what i've seen on some sites is that it has stop being developed. If I wanted to make my frontend in python with qt and core logic in haskell, are there any recommendations about message passing that's scalable? (is protobuffers overkill), should I use pipes (does that work on windows?), i need something simple and 
00:24:46 <tigger_> any thoughts would be great
00:26:40 <gienah> tigger_: maybe zeromq and protocol-buffers
00:27:33 <tigger_> I can prolly find this somewhere on the internet, but amqp is for lightweight stuff and protobuffers larger things, or are my first impressions wrong
00:27:47 <dmoctezuma> tigger_, have you tried Gtk2Hs?
00:27:57 <Haskill> gaah! i give up !
00:28:07 <gienah> tigger_: I think zeromq looks a lot simpler than amqp
00:28:37 <Haskill> all i want to do is substitute every instance of agiven variable in some data type :(
00:29:12 * hackagebot schonfinkeling 0.1.0.0 - Transformation of n-ary functions to unary functions  http://hackage.haskell.org/package/schonfinkeling-0.1.0.0 (DenisDefreyne)
00:29:29 <tigger_> @dmoctezuma no I haven't. but I heard it is terrible on macs (i read "deploying a GTK2HS application on a Mac is god-awful and it looks ugly to boot."), and I need cross platform, any thoughts?
00:29:30 <lambdabot> Unknown command, try @list
00:30:14 <gienah> tigger_: my thought is I like your idea of Qt and Python for the front end talking to a Haskell back end
00:31:07 <dmoctezuma> wxHaskell?
00:31:08 <tigger_> @gienah ohkay, yeah and I'd probably use epoll for event handling in haskell, to respond to messages from 0mq or whatever
00:31:08 <lambdabot> Unknown command, try @list
00:31:15 <tigger_> or is there something easier than that
00:32:16 <tigger_> @dmoctezuma yeah, I've looked at wxHaskell, and am still considering it, do you know if it has code generation like qtdesigner or something, off the top of your head?
00:32:16 <lambdabot> Unknown command, try @list
00:32:19 <gienah> tigger_: maybe: http://hackage.haskell.org/package/zeromq-haskell
00:32:31 <merijn> tigger_: Maybe I missed something important but why not just use threads and a socket?
00:35:06 <dmoctezuma> tigger_, I haven't used it, just trying to give ideas that might help. But you can take a look to wxGlade.
00:35:09 <tigger_> @merijn oh yeah I could just do that, I feel dumb saying this, but I don't know how to put a thread to sleep in haskell (I would just recurse infinitly checking the socket), and I was under the impression that might be less practical than an event callback method
00:35:10 <lambdabot> Unknown command, try @list
00:36:09 <merijn> tigger_: Just use blocking calls, the haskell runtime multiplexes lightweight threads onto OS threads using epoll/kqueue/select under the hood
00:37:16 <merijn> (assuming you're using GHC 7, I think GHC6 only uses select and with other compilers YMMV)
00:39:18 <tigger_> merijn: sorry this may be dumb also, so just client server tcp socket on the localhost, with calls to read (which block if no data is available), or were you referring to some other kind of socket (like a pipe)
00:39:33 <Haskill> OMG!!!
00:39:48 <Haskill> i already have this function called eval which evaluates after substituting!
00:40:05 <Haskill> ...i just have to make a function that doesn't evaluate .. but generates the expression
00:40:26 <merijn> tigger_: Well, TCP socket is portable to every platform anyone cares about, but if you're only developing for *nix platforms you could use unix sockets and avoid networking code...
00:41:04 <merijn> tigger_: Both would let you do blocking reads
00:41:27 <tigger_> merijn: okay cool, yeah I was mostly worried about the thread sleeping/blocking thing
00:41:48 <tigger_> merijn: thanks for the help!
00:41:56 <merijn> tigger_: np
00:42:06 <tigger_> gienah: thanks for teh suggestions!
00:42:20 <tigger_> dmoctezuma: thanks dude!
00:42:20 <gienah> tigger_: no worries
00:42:25 <dmoctezuma> np
00:42:46 <merijn> I always become helpful when I have more important things to do ;)
00:43:55 <Haskill> do we use pastebin here or something else?
00:44:11 <merijn> Haskill: hpaste.org
00:44:40 <hpaste_> haskill pasted “haskill” at http://hpaste.org/52066
00:45:09 <Haskill> could someone please tell me what little modification i would need to do to get the resulted expression instead of getting the evaluated result?
00:45:13 <Haskill> in that pasted code
00:45:40 <Axman6> what do you mean by 'resulted expression'?
00:45:50 <Haskill> as in, the not evaluated expression
00:46:00 <Haskill> just filled in with the found substitutions
00:46:23 <Axman6> can you give an example of the input and output you expect?
00:47:30 <Haskill> wait, lemme update the paste
00:48:50 <Haskill> http://hpaste.org/edit/52066
00:48:58 <Haskill> ah wait
00:49:27 <hpaste_> haskill annotated “haskill” with “haskill (annotation)” at http://hpaste.org/52066#a52067
00:49:36 <Haskill> done
00:51:33 <Axman6> so, if you run eval [("k",7),("m",2),("n",11)] (Add (Var "k") (Num 5)) you want to get back Add (Num 7) (Num 5)?
00:51:39 <Haskill> yeah
00:51:42 <Haskill> instead of 12
00:52:15 <Axman6> so the type you want is evalVars :: State -> Expr -> Expr?
00:52:17 <Haskill> so basically eval :: State -> Expr -> Expr
00:52:18 <Haskill> yes
00:52:18 <dmoctezuma> you need to change the type signature first
00:52:22 <Haskill> done that
00:52:46 <Axman6> well, you already know how to get the number a var represents
00:52:53 <Haskill> yes..
00:53:05 <Axman6> so, now you just need to use that to retuen something of type Expr. what do you have that is of type Expr?
00:53:21 <Haskill> e1 is type Expr
00:54:09 <hjulle> ghc --make fails with error "Could not find module `Graphics.Rendering.Chart.Gtk':
00:54:11 <Axman6> but how you you make a new Expr?
00:54:38 <hjulle> but running the program from ghci works.. :/
00:54:42 <dmoctezuma> data Expr = ... ?
00:55:06 <Axman6> hjulle: you've got constructors called Add and Var and Num right?
00:55:21 <Axman6> uh. Haskill
00:55:23 <Haskill> yes
00:55:45 <hjulle> Axman6: ?
00:55:51 <Axman6> well, Var by itself is actually a function: Var :: String -> Expr
00:55:52 <Haskill> basically even when i enter e1 in ghci, it returns (k+5) instead of that Add Var etc
00:55:55 <Axman6> hjulle: wrong person
00:56:02 <Haskill> hmm..
00:56:22 <Axman6> Add :: Expr -> Expr -> Expr
00:56:23 <Haskill> okay.
00:56:30 <Axman6> and Num :: Integer -> Expr
00:56:38 <Haskill> yes, that's all there
00:56:44 <Axman6> so, if you apply Num to an Integer, you get an Expr right?
00:56:50 <dmoctezuma> hjulle, ghc --make -package Chart YourFile.hs ?
00:57:04 <Haskill> yup
00:57:43 <Axman6> and you have an Integer don't you?
00:57:44 <Haskill> yes i do
00:57:46 <hjulle> dmoctezuma: Thanks.
00:57:48 <Haskill> ooo...oo...wait it's right on the tip on my brain
00:57:52 <Axman6> so...
00:57:54 <dmoctezuma> hjulle, did it worked?
00:58:14 <hjulle> dmoctezuma: Kinda. I got another error now... :/
00:58:26 <Axman6> Haskill: a hint, there's only three characters you need to type ;)
00:58:31 <dmoctezuma> hjulle, what kind of error?
00:58:34 <Haskill> Num n?
00:58:41 <Haskill> that's not 3 though
00:58:41 <Axman6> give it a go
00:58:42 <hjulle> dmoctezuma: nusable due to missing or recursive dependencies
00:58:49 <Axman6> ok, maybe 4
00:58:53 <Axman6> if you're including the space
00:58:59 <Haskill> why does it say Non-exhaustive patterns in function Main.eval
00:59:28 <dmoctezuma> put a _
00:59:28 <Haskill> o, what does the _ do?
00:59:29 <dmoctezuma> or otherwise
00:59:29 <Axman6> because you haven't matched the other Expr constructors: Add, Num etc
00:59:41 <Haskill> oh oh okay
00:59:42 <Axman6> dmoctezuma: eh?
00:59:52 <dmoctezuma> ah yeah
01:00:06 <dmoctezuma> never mind
01:00:09 <Axman6> Haskill: so, you need eval s (Add a b) = ..., eval s (Num n) = ...
01:00:09 <hjulle> dmoctezuma: Apparently I have two versions of the same package :/
01:00:52 <Haskill> done that
01:00:53 <Haskill> kinda
01:01:48 <hjulle> dmoctezuma: More precisely two copies of the same version of the  package installed
01:02:01 <dmoctezuma> :O
01:02:27 <Haskill> OH MY GOD!!!
01:02:33 <Haskill> even though i don't believe
01:02:34 <Haskill> wow
01:02:41 <Haskill> THANK ..YOU
01:03:55 <Haskill> it works! it works!
01:04:00 <danr> :)
01:04:07 <dmoctezuma> it's good to hear that
01:04:09 <Haskill> intense session of spoonfeeding :(
01:04:09 <Haskill> lol
01:05:30 <dmoctezuma> hjulle, haven't had that kind of situation, you could try to unregister one of the copies from your cabal list, perhaps?
01:08:46 <hpaste_> haskill annotated “haskill” with “haskill” at http://hpaste.org/52066#a52068
01:08:54 <Haskill> so it's become that now
01:09:14 <Haskill> but what if line 3 was type State = [(String, Expr)] ?
01:10:50 <Haskill> hmm i changed Just n -> Num n to Just n -> n
01:11:53 <Haskill> doesn't work...that's more to it
01:12:32 <TotoTitus> Uhh, given a function (r -> a -> b)
01:12:40 <TotoTitus> could you somehow take the ' a-> b ' part of it ?
01:12:58 <Haskill> can't you just do that by running a through the function directly?
01:13:07 <Haskill> partial functions?
01:13:26 <TotoTitus> wouldn't that pollute it with the input from r ?>
01:13:36 <TotoTitus> (i may be tripping right now)
01:13:58 <danr> TotoTitus: yeah probably, I guess what you (cannot) do is pass an undefined to the function to get a -> b
01:13:58 <Haskill> ...dunno about that, sorry i'm a newb
01:14:14 <danr> TotoTitus: but typically, you want something of type r
01:14:40 <TotoTitus> since last night, i've been thinking of the im[
01:14:46 <TotoTitus> implementation of applicative for functions
01:14:58 <TotoTitus> (r -> a -> b) -> (r -> a) -> (r -> b)
01:15:08 <danr> Yes
01:15:21 <danr> Remember that -> is right associative, so this is the same type:
01:15:25 <TotoTitus> f <*> g = \x -> f x (g x)
01:15:27 <danr> (r -> a -> b) -> (r -> a) -> r -> b
01:15:40 <danr> With your r as the third argument
01:15:49 <danr> TotoTitus: yeah, you got it already
01:15:58 <TotoTitus> But i am still figuring it out
01:15:59 <dmoctezuma> Haskill, having type State = [(String, Expr)] would mean having a list of pairs in the second part
01:16:04 <TotoTitus> Let's rewrite it in prefix:
01:16:12 <dmoctezuma> not sure if that's what you want
01:16:27 <TotoTitus> ((-> r) (a -> b)) -> (r -> a) -> (r -> b)
01:16:49 <TotoTitus> The applicative should take the 'a -> b' out of its ' ->r ' context, to apply it to r-> a
01:17:13 <TotoTitus> Similarly to how Just (*3) <*> Just 5
01:17:21 <TotoTitus> Takes the (*3) out of the Just
01:17:48 <danr> TotoTitus: well there's a difference between (-> r) and ((->) r). The "latter" means (r ->), and the first is not valid haskell. But it seems you're aware of this
01:17:58 <danr> uhm. latter "means"
01:18:15 <TotoTitus> ah, LYAH was using ((->) r)
01:18:20 <TotoTitus> but i am aware this is (r ->)
01:18:24 <danr> ok great
01:18:35 <danr> Yes, ((->) r) is how you have to write it in Haskell
01:19:04 <TotoTitus> What i am wondering is, does the current implementation do the equivalent of what i said before (the Just analogy) or could there be an alternate implementation ?
01:19:26 <TotoTitus> i am on the brink of fully understanding this so that's why i am coming up with weird reasonings
01:19:51 <danr> There is only one implementation (up to eta-beta-equivalence) due to parametricity
01:20:05 <danr> @djinn (r -> a -> b) -> (r -> a) -> (r -> b)
01:20:06 <lambdabot> f a b c = a c (b c)
01:20:07 <TotoTitus> eta-beta-equivalence ?
01:21:00 <TotoTitus> @parametricity
01:21:00 <lambdabot> Unknown command, try @list
01:21:04 <TotoTitus> @list
01:21:05 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:21:05 <danr> I mean, you could write something like \f g x -> f x (g ((\y -> y) x))
01:21:09 <danr> but that's just silly
01:21:39 <willem> I was searching for a ctags generator for haskell but there seem to be so many (hasktags, hothasktags, lushtags, haskdogs, GHC itself). Which one is used most/do you use?
01:21:48 <danr> I meant alpha-beta-equivalence (d'oh)
01:22:56 <danr> TotoTitus: an introduction to parametricity can be found in the Theorems For Free paper
01:23:50 <TotoTitus> is it math-related ?
01:24:04 <danr> TotoTitus: but I am not sure I follow your reasoning with the Just-analogy
01:24:04 <TotoTitus> i mean, how much math do i need for it?
01:24:18 <TotoTitus> why is that ?
01:24:19 <danr> You cannot really take it out of its r-context
01:24:43 <danr> You supply the r, the environment, in the "end".
01:24:44 <dabblego> I gave a short talk on parametricity to my colleagues in 45 minutes -- it's not hard
01:25:09 <TotoTitus> The way i've come to understand lent itself to such an analogy
01:25:48 <TotoTitus> i'm at work right now, and there's nothing to do, so i've got time to think of this :)
01:34:19 <hjulle> dmoctezuma: I believe the problem is that I did not install gtk2hs correctly
01:41:05 <burbul> If I have a parametric outer function, like
01:41:13 <burbul> mapForest :: Ord a => (Node a -> Maybe (Node a)) -> PackedForest a -> PackedForest a
01:41:28 <burbul> And then I want to declare inside it a nested function that uses the 'same' a
01:41:42 <burbul> How would I go about doing that, please?
01:42:19 <burbul> If I just use 'a', as in
01:42:20 <burbul>       recurse_node' :: Node a -> Maybe (Node a)
01:43:02 <burbul> Then I get an error message "Could not deduce (a ~ a1)"
01:43:13 <burbul> -- I.e. it thinks that the second 'a' is a fresh type variable.
01:43:32 <benmachine> burbul: either define a generic function, so the 'a' doesn't need to be the same, or pass the first argument to recurse_node even though you don't use it, or use ScopedTypeVariables
01:44:42 <burbul> tahnks!
01:46:14 <benmachine> the last solution is probably the nicest in this case
01:47:02 <benmachine> enable ScopedTypeVariables via a LANGUAGE pragma, then put forall a. at the beginning of mapForest's typesig
01:47:47 <Eduard_Munteanu> @hoogle asTypeOf
01:47:48 <lambdabot> Prelude asTypeOf :: a -> a -> a
01:48:10 <Eduard_Munteanu> In case the context allows for a nice solutions in terms of that.
01:48:29 <Eduard_Munteanu> s/ns/n/
01:50:00 <Eduard_Munteanu> > 1 `asTypeOf` 2.0
01:50:01 <lambdabot>   1.0
01:50:34 <burbul> ScopedTypeVariables + forall works nicely -- thank you, benmachine.
01:50:46 <burbul> I'll also keep the asTypeOf in mind.
01:51:32 <burbul> Incidentally, why was the explicit 'forall' necessary?
01:52:28 <benmachine> ScopedTypeVariables uses the forall to say "I want this type variable to be scoped"
01:52:40 <burbul> ah, I see -- thanks
01:52:45 <benmachine> I believe so anyway
01:53:39 <quicksilver> yes
01:53:45 <quicksilver> it's a way of being backwards compatible
01:54:11 <quicksilver> simply adding the extension doesn't damage any haskell2011 code
01:59:05 <BobFunk> would be happy if anybody feels like upvoting: http://news.ycombinator.com/item?id=3065672 :)
01:59:18 <Haskill> what's the difference if i write @lookup v s :: Maybe Integer
01:59:27 <Haskill> or if i write @lookup v s
02:07:11 <mm_freak> Haskill: i don't know what you're doing with the @, but in the former case you are specifying the type signature
02:07:29 <mm_freak> it's really the same question as what's the difference between 'main' with and without a type signature
02:08:23 <mm_freak> a type signature serves as a specification to a part of your program, which can just be explicit about its type or in many cases specialize or generalize a type
02:08:25 <hpaste_> haskill pasted “haskill2” at http://hpaste.org/52069
02:08:42 <Haskill> Any help on the above would be greatly, hugely appreciated
02:09:07 <Haskill> is lookup the way to go for this one too?
02:09:27 <mm_freak> yes
02:09:48 <Haskill> it is?! o.O i shall try further before more questions then :)
02:10:14 <Haskill> and yeah...I understood that but my lookup seemed to work either way (with or without a signature)
02:10:30 <mm_freak> yes, it does
02:10:36 <Twey> subst s v@(Var v') = v `fromMaybe` lookup v' s
02:10:41 <mm_freak> if you don't specify a type signature, the type is inferred
02:10:46 <Twey> Yes, because the signature is redundant there
02:10:52 <Haskill> ah i see
02:10:56 <Twey> You've provided all the information necessary to infer exactly that type elsewhere
02:11:27 <Haskill> and thanks for that Twey...that line looks a bit complicated for me to understand (sorry)
02:11:49 <mm_freak> Haskill: haskell is capable of inferring most types for you, but in any case it's good style to write type signatures at least for your top level definitions (e2, s2, subst)
02:11:52 <Twey> It's not that complicated — have a shot at it
02:12:01 <Haskill> wait, what exactly is that?
02:12:13 <Haskill> is it the match function?
02:12:31 <mm_freak> v `fromMaybe` lookup v' s = fromMaybe v (lookup v' s)
02:12:38 <mm_freak> it's just infix syntax for function application
02:12:44 <Twey> The compiler knows that s :: [(String, Expr)], and it knows that lookup :: Eq a => a -> [(a, b)] -> b
02:12:45 <Haskill> you're losing me...
02:12:47 <Twey> Er
02:12:51 <Twey> The compiler knows that s :: [(String, Expr)], and it knows that lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:13:00 <Haskill> right
02:13:05 <mm_freak> Haskill: given a function f, you can apply it using prefix: f x y
02:13:10 <mm_freak> or infix: x `f` y
02:13:22 <Haskill> oh and both are the same?
02:13:24 <Twey> The only way ‘lookup v s’ makes sense is if a = String, b = Expr
02:13:27 <mm_freak> given a function (+) you can apply it prefix:  (+) x y
02:13:30 <mm_freak> or infix:  x + y
02:13:41 <Twey> So that becomes lookup :: String -> [(String, Expr)] -> Maybe Expr
02:13:57 <mm_freak> yeah, they are the same…  just a syntactic convenience (though i prefer to write prefix syntax most of the time)
02:14:12 * hackagebot sox 0.2.1 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2.1 (HenningThielemann)
02:14:24 <Haskill> what is that what you gave me?
02:14:24 <Haskill> subst s v@(Var v') = v `fromMaybe` lookup v' s
02:14:25 <Haskill> ??
02:14:35 <mm_freak> fromMaybe is a function
02:14:36 <Haskill> is that a variation of subst?
02:14:37 <mm_freak> :t fromMaybe
02:14:38 <lambdabot> forall a. a -> Maybe a -> a
02:14:42 <Twey> subst s v@(Var v') = fromMaybe v $ lookup v' s
02:14:48 <mm_freak> > fromMaybe 3 (Just 4)
02:14:49 <lambdabot>   4
02:14:54 <mm_freak> > fromMaybe 3 Nothing
02:14:54 <lambdabot>   3
02:14:55 <Twey> Haskill: It's the definition of your ‘subst’ function
02:15:07 <Haskill> ohh i see
02:15:12 <Twey> Without the unnecessary case (that particular pattern is captured in the ‘fromMaybe’ function from Data.Maybe)
02:15:15 <mm_freak> you will have to import Data.Maybe for it
02:15:27 <Haskill> but Subst works already
02:15:36 <Haskill> http://hpaste.org/52069
02:15:47 <Haskill> i'm looking for an inverse of subst now...
02:15:55 <Haskill> thought you were talking about that
02:16:21 <mm_freak> Haskill: your code is fine for now…  you will learn how to use combinators like 'fromMaybe' later
02:16:31 <Haskill> i guess...lol
02:16:43 <Haskill> this is my first haskell program though...
02:16:49 <Haskill> so i'm not worried about that atm :p
02:16:54 <Haskill> module*
02:17:16 <mm_freak> i suppose you come from another language?
02:17:25 <Haskill> java and python mostly
02:18:09 <Haskill> it's hard to visualize what my code is doing in haskell right now
02:18:21 <mm_freak> well, just read it…  it's very straightforward
02:18:51 <mm_freak> your code doesn't do any magic…  it just follows the rules you have written down
02:19:02 <Haskill> the rules of the language.
02:19:11 <mm_freak> your substitution rules
02:19:15 <Haskill> i don't understand half of what i'm writing in this one
02:19:34 <Haskill> ...hmm, reminds me of the French class I took last year :d
02:19:34 <mm_freak> do you understand your algebraic type Expr?
02:19:37 <Haskill> yes
02:19:47 <mm_freak> do you understand your type signatures?
02:19:51 <Haskill> what is lookup doing?
02:19:58 <Haskill> yes i understand type signatures now
02:20:01 <mm_freak> :t lookup
02:20:01 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
02:20:17 <mm_freak> it takes a list of pairs, where the left value is a key and the right value is a value
02:20:33 <mm_freak> the rest should be fairly self-explanatory from the type signature of 'lookup'
02:20:36 <Haskill> oh
02:20:55 <mm_freak> > lookup 3 [(2, 'a'), (3, 'b'), (4, 'c')]
02:20:56 <lambdabot>   Just 'b'
02:20:57 <Haskill> :t case
02:20:58 <lambdabot> parse error (possibly incorrect indentation)
02:21:00 <Haskill> :(
02:21:02 <mm_freak> > lookup 5 [(2, 'a'), (3, 'b'), (4, 'c')]
02:21:03 <lambdabot>   Nothing
02:21:20 <Haskill> case/of is a way to go through the list i guess?
02:21:34 <mm_freak> no, it just performs pattern matching
02:22:05 <Haskill> case (lookup 3 [(2, 'a'), (3, 'b'), (4, 'c')]) of
02:22:08 <mm_freak> you give it a value and a list of patterns…  the result of the 'case' construct is the right side of whatever pattern matches
02:22:32 <mm_freak> > case Just 4 of Nothing -> "no"; Just x -> show x
02:22:33 <lambdabot>   "4"
02:22:38 <mm_freak> > case Nothing of Nothing -> "no"; Just x -> show x
02:22:39 <lambdabot>   "no"
02:22:51 <Haskill> oh so it's a way to perform stuff on the result?
02:22:52 <antihoax> hii :)
02:22:53 <mauke> case EXPR of { PATTERN1 -> EXPR1; PATTERN2 -> EXPR2; ... }
02:22:57 <Haskill> in each case?
02:23:01 <Eduard_Munteanu> antihoax: hi
02:23:03 <Haskill> ohhh
02:23:12 <Haskill> okay
02:23:32 <Haskill> so how would i use lookup for the match function now? :/
02:23:50 <Haskill> i'm supposed to "find" the key
02:24:14 * hackagebot hamlet 0.10.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.10.2 (MichaelSnoyman)
02:24:16 * hackagebot persistent-postgresql 0.6.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.6.1 (MichaelSnoyman)
02:24:34 <Haskill> here's the link to the problem: http://hpaste.org/52069
02:25:54 <Eduard_Munteanu> Haskill: what should it do?
02:26:12 <Haskill> it does the reverse of Subst.
02:26:44 <Haskill> it gives the Maybe Subst from two Exprs
02:27:13 <Haskill> like if subst s1 e1 = e2. then match e1 e2 = s1
02:32:27 <Haskill> Eduard_Munteanu: ?
02:33:09 <engla> > length ([1..] :: [Int])
02:33:13 <lambdabot>   mueval-core: Time limit exceeded
02:33:23 <engla> it should eventually terminate right, since Int is bounded
02:34:15 * hackagebot persistent-sqlite 0.6.2 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.6.2 (MichaelSnoyman)
02:34:17 * hackagebot persistent 0.6.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.6.3 (MichaelSnoyman)
02:34:19 * hackagebot persistent-template 0.6.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.6.3 (MichaelSnoyman)
02:34:21 * hackagebot shakespeare 0.10.1.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-0.10.1.1 (MichaelSnoyman)
02:34:23 * hackagebot shakespeare-css 0.10.2 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-0.10.2 (MichaelSnoyman)
02:35:33 <mm_freak> > length [False ..]
02:35:34 <lambdabot>   2
02:35:58 <hpaste_> haskill annotated “haskill2” with “haskill2 (annotation)” at http://hpaste.org/52069#a52073
02:36:18 <Haskill> can someone just guide me a bit on this? :(
02:39:25 * hackagebot shakespeare-js 0.10.2 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-0.10.2 (MichaelSnoyman)
02:39:27 * hackagebot shakespeare-text 0.10.2 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-0.10.2 (MichaelSnoyman)
02:39:29 * hackagebot wai-app-static 0.3.4 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.3.4 (MichaelSnoyman)
02:39:31 * hackagebot wai-extra 0.4.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.3 (MichaelSnoyman)
02:39:33 * hackagebot yesod-auth 0.7.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.3 (MichaelSnoyman)
02:40:37 <Botje> Haskill: walk the two Expr trees in parallel
02:41:04 <mah_b> Haskill: Looking for sthing like http://en.wikipedia.org/wiki/Unification_(computer_science)#A_Unification_Algorithm?
02:41:04 <Botje> whenever you see two Vars, create a substitution from one to the other
02:41:15 <Botje> at the end, check if your substitutions are consistent
02:41:48 <antihoax> cheater<< what are you writing?
02:41:49 <Haskill> hmm...
02:41:57 <Haskill> using lookup I am guessing?
02:42:51 <cheater> antihoax: nothing in specific
02:43:30 <Haskill> how do i check if my substitutions are consistent?
02:44:35 * hackagebot yesod-core 0.9.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.3 (MichaelSnoyman)
02:44:37 * hackagebot yesod-default 0.3.1 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-0.3.1 (MichaelSnoyman)
02:44:39 * hackagebot yesod-form 0.3.3 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.3.3 (MichaelSnoyman)
02:44:41 * hackagebot yesod-static 0.3.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.3.1 (MichaelSnoyman)
02:44:58 <Haskill> could you walk through the first iteration?
02:45:24 <cheater> you can use the "print" function for debugging
02:45:40 <Haskill> whoa..
02:45:52 <Eduard_Munteanu> No, not really.
02:46:07 <cheater> Eduard_Munteanu: you can't use print?
02:46:11 <Eduard_Munteanu> Also I'm not sure what you're supposed to lookup.
02:46:16 <Axman6> not everywhere...
02:46:20 <Eduard_Munteanu> cheater: not in non-IO functions
02:46:27 <cheater> right
02:46:31 <Eduard_Munteanu> @hoogle trace
02:46:31 <lambdabot> Debug.Trace trace :: String -> a -> a
02:46:31 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
02:46:31 <lambdabot> module Debug.Trace
02:46:49 <Haskill> then what do you think would be used here?
02:46:58 <Haskill> is there something like a reverse lookup?
02:47:14 <Botje> Haskill: you check that they're consistent by verifying that symbol A is always translated to B
02:47:43 <Botje> if there exists another mapping A -> C, you cannot generate a substitution.
02:47:51 <dankna> @hoogle foldM
02:47:52 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
02:47:52 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
02:47:52 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
02:48:04 <Haskill> so say theres
02:48:07 <Botje> so start by walking your trees in parallel and collecting all places where there are two different vars
02:48:13 <Haskill> @let e1 = x * y
02:48:14 <lambdabot>  Defined.
02:48:16 <Botje> if the trees differ structurally, bail out immediately
02:48:26 <Haskill> @let e2 = (y + z) * y
02:48:27 <lambdabot>  Defined.
02:48:48 <Haskill> how would you go through it in the first iteration?
02:49:04 <Haskill> would you assign x to e2?
02:51:33 <hpaste_> mah_b pasted “match” at http://hpaste.org/52074
02:52:04 <Haskill> wow..
02:52:14 <Haskill> thanks mah_b, looking through it
02:54:54 <Haskill> doesn't exactly work as it should but it's a very good starting point for me too get something from it
02:54:58 <Haskill> thank you very much mah_b
02:55:27 <Haskill> actually..
02:55:31 <Haskill> it works i think
02:56:35 <antihoax> will (var + 0.1) - 0.1 always be equal to var in haskell?
02:56:48 <antihoax> (as a floating point value)
02:57:15 <Axman6> @check \x -> (x + 0.1) - 0.1 == x
02:57:17 <lambdabot>   "Falsifiable, after 11 tests:\n4.0\n"
02:57:18 <Axman6> no
02:57:27 <osfameron> good ol' floating point
02:57:32 <Axman6> well, it depends on the type you use
02:57:38 <antihoax> ;<
02:57:40 <Axman6> @check \x -> (x + 0.1) - 0.1 == (x :: CReal)
02:57:40 <lambdabot>   Not in scope: type constructor or class `CReal'
02:57:45 <antihoax> so i must check range?
02:57:47 <Axman6> o.O
02:57:59 <Axman6> > 11 + 0.1
02:58:00 <lambdabot>   11.1
02:58:08 <Axman6> > (11 + 0.1) - 0.1
02:58:09 <lambdabot>   11.0
02:58:10 <antihoax> @check \x -> ((x + 0.1) - 0.1) == x
02:58:11 <lambdabot>   "Falsifiable, after 55 tests:\n0.25\n"
02:58:16 <Axman6> > (11 + 0.1) - 0.1 == 11
02:58:17 <lambdabot>   True
02:58:20 <Axman6> huh
02:58:43 <osfameron> > (0.25 + 0.1) - 0.1
02:58:44 <lambdabot>   0.24999999999999997
02:58:54 <Axman6> anyway, that expression defaults to Double, which is just the double type you should know from C etc
02:59:11 <Axman6> it's IEEE-754's double precision floating point repesentation
02:59:18 <antihoax> aham
03:00:13 <antihoax> so how do i round for examaple after 6 digits after . ?
03:00:44 <Axman6> Cale: where did CReal go in lambdabot?
03:02:03 <hpaste_> ha annotated “match” with “match (annotation)” at http://hpaste.org/52074#a52075
03:02:10 <Haskill> that's mine :/
03:02:27 <Haskill> check line 20.. would that be an acceptable thing ?
03:02:50 <Haskill> because x can't be both at the same time
03:04:38 <antihoax> > (round ((10+0.1)*1000000)))/1000000
03:04:39 <lambdabot>   <no location info>: parse error on input `)'
03:04:43 <mah_b> You have to detect when a variable is already bound. Then, you can match both terms again.
03:05:21 <mah_b> The result should m.E. be Just [("x", (y + 2)), ("z", y)]
03:05:47 <Haskill> oh
03:05:56 <Haskill> interesting, i'll try to do this
03:06:41 <mah_b> the trick is to replace (++) with a custom operator that will take care of properly matching substitutions.
03:06:53 <Haskill> i see
03:07:13 <Haskill> thanks man, you really saved the day today
03:07:28 <Haskill> along with Axman6 and others
03:07:41 <mah_b> you're welcome
03:07:43 <Axman6> no worries
03:08:16 <antihoax> > round ((10+0.1)*1000000))
03:08:17 <lambdabot>   <no location info>: parse error on input `)'
03:10:06 <antihoax> ahh
03:11:06 <antihoax> > (round ((10+0.1)*1000000))/1000000
03:11:07 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:11:07 <lambdabot>    `GHC.Real.Integral b'
03:11:07 <lambdabot>   ...
03:13:14 <Axman6> need to use div
03:13:49 <Axman6> > (round ((11 + 0.1) * 100000)) `div` 10000
03:13:50 <lambdabot>   111
03:14:10 <Axman6> lambdabot!
03:14:20 <antihoax> thats not what i wanted
03:14:23 * hackagebot libcspm 0.1 - A library providing a parser, type checker and evaluator for CSPM.  http://hackage.haskell.org/package/libcspm-0.1 (ThomasGibsonRobinson)
03:14:29 <Axman6> > (round ((11 + 0.1) * 100000)) `div` 100000
03:14:29 <Axman6> though... obviously that won't work
03:14:29 <lambdabot>   11
03:14:41 <antihoax> that returns integer
03:15:48 <antihoax> ((0.25 + 0.1) - 0.1)*1000000
03:15:53 <antihoax> > ((0.25 + 0.1) - 0.1)*1000000
03:15:54 <lambdabot>   249999.99999999997
03:16:01 <Haskill> -mah_b. I ran the resulting substitution you gave me through the subst function, it only returns in terms of y.
03:16:04 <antihoax> > round (((0.25 + 0.1) - 0.1)*1000000)
03:16:04 <lambdabot>   250000
03:16:08 <mauke> > ((0.25 + 0.1) - 0.1)*1000000 :: Rational
03:16:09 <lambdabot>   250000 % 1
03:16:26 <antihoax> > (round (((0.25 + 0.1) - 0.1)*1000000))/1000000
03:16:27 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:16:27 <lambdabot>    `GHC.Real.Integral b'
03:16:27 <lambdabot>   ...
03:16:45 <antihoax> i should have gotten 0.25 no?
03:16:56 <mauke> no
03:16:59 <mauke> it's a type error
03:17:17 <Axman6> :t round
03:17:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:19:16 <mah_b> Haskill: what have you tried? subst s q1 or q2?
03:20:22 <Haskill> for both q1 and q2
03:20:37 <Haskill> one gives in terms of y and the other in terms of z
03:21:22 <Haskill> actually ,sorry. both give in terms of y
03:22:43 <Haskill> i don't think my subst supports this kind of substitution though, how would it know when to not switch vars?
03:24:23 * hackagebot cspmchecker 0.1 - A command line type checker for CSPM files.  http://hackage.haskell.org/package/cspmchecker-0.1 (ThomasGibsonRobinson)
03:28:05 <mah_b> from the match, you can't fully get back. Consider a * b and c * c. You can only subst in one direction. from a * b -> c * c using either [("a", c), "b", c)] or [("a", b), ("b", c)].
03:29:06 <mah_b> and this is the key point. as soon as there are two subsitutions with the same *body*, substituting back is impossible.
03:29:40 <mah_b> this also includes transitivity.
03:30:03 <antihoax> cheater<< ahah http://www.heijnen1.demon.nl/
03:30:10 <rostayob> is calling C++ still this bad http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell ?
03:30:36 <cheater> antihoax: what is that?
03:31:58 <mah_b> Haskill, btw a invert :: Subst -> Subst so that subst s e1 = e2 => subst (invert s) e2 = e1 would also be interesting.
03:32:48 <antihoax> cheater<< itrs a cheating program, can find variables in games, freeze them, i have used a similar "gamewizard" on dos to play <;
03:34:02 <Axman6> rostayob: i can't seem to load the page :\
03:34:23 <Axman6> ah there we go
03:35:59 <Axman6> rostayob: the usual way to use C++ in haskell is to write simple wrappers in C
03:36:43 <rostayob> Axman6: how do you wrap class creation and stuff like that in C?
03:37:04 <rostayob> well
03:37:04 <Axman6> instantiation?
03:37:16 <rostayob> you do a C++ wrapper which you call from C
03:37:25 <rostayob> yeah instantiation
03:38:07 <cheater> antihoax: oh, ok.
03:38:20 <Axman6> foo * init_Foo(arg1, arg2...) { return Foo(arg1,arg2,...);}?
03:38:33 <rostayob> Axman6: yeah but that's not C code
03:38:44 <Axman6> it's a C function calling C++
03:38:58 <Axman6> which makes it easy to call from the FFI
03:39:19 <rostayob> right, so I have to create a C++ wrapper that sets up the classes i need, and then a C wrapper that calls those functions
03:39:51 <rostayob> probably the problem here is that i know less than anything about C++
03:39:58 <rostayob> are class constructor valid C functions?
03:43:09 <quicksilver> rostayob: nothing in C++ is a valid C function.
03:43:17 <quicksilver> you have to wrap them all in C functions as you suggested.
03:43:25 <quicksilver> C++ has an entirely different ABI
03:44:05 <dankna> and more importantly, C++'s ABI is not remotely standard
03:46:32 <rostayob> quicksilver: ok, it sounds kind of ugly
03:46:40 <rostayob> C++ always sounded kind of ugly :P
03:46:51 * rostayob goes to eat something
03:48:14 <quicksilver> there are tools for automatically wrapipng C++ apis but they bring in complexity, since it's a complex problem
03:48:21 <quicksilver> IIRC, the wxhaskell team have a custom tool
03:53:20 <rostayob> quicksilver: i was curious more than anything, i hope i never have to deal with something like that eheh
04:11:06 <RaptorRarr> How is a stream arrow more powerful than the list monad?
04:21:45 <ocharles> has something happened to hackage that makes it unable to render documentation?
04:21:48 <ocharles> (http://hackage.haskell.org/package/category-extras-0.53.5.1 for example)
04:22:06 <hpc> that version of the package failed to build
04:22:13 <hpc> http://hackage.haskell.org/package/category-extras-0.53.5
04:22:43 <ocharles> ah
04:22:55 <ocharles> yea, I know the last version works (I'm reading it now :)) I just wondered what had happened
04:23:01 <ocharles> cause it's not the first package I've seen today without docs
04:23:05 <hpc> dunno why it does that though
04:23:11 <hpc> it drives me up a wall sometimes
04:23:12 <Axman6> also, newly uploaded packages don't get their docs built immediately, i think it's done every 6 hours
04:23:45 <ocharles> ah, that's good to know
04:25:57 <ksf> dammit it's always the same: I end up not using, but circumventing the record system.
04:30:45 <rostayob> ksf: records are bitchy in haskell
04:30:57 <rostayob> *flame follows*
04:32:07 * JuanDaugherty has to restore an slew of changes to an XML file where all the line terminatio was lost from an earlier version. (change of subject to deflect flame) 
04:32:18 <JuanDaugherty> *a slew
04:38:36 <ruuby> can anyone explain to me why liftIO cannot be implemented using lift? (obviously because the types are different but I'm looking for a more intuitive explanation)
04:38:56 <dankna> ah
04:38:57 <dankna> well
04:39:01 <dankna> :t lift
04:39:02 <lambdabot>     Ambiguous occurrence `lift'
04:39:02 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
04:39:02 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
04:39:09 <dankna> :t Control.Monad.Logic.lift
04:39:10 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Logic.MonadTrans t, Monad m) => m a -> t m a
04:39:15 <dankna> :t liftIO
04:39:16 <lambdabot>     Ambiguous occurrence `liftIO'
04:39:16 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
04:39:16 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
04:39:22 <dankna> as you can't really see from that
04:39:23 * hackagebot clientsession 0.7.3.1 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.7.3.1 (MichaelSnoyman)
04:39:25 * hackagebot yesod-core 0.9.3.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.3.1 (MichaelSnoyman)
04:39:26 <RaptorRarr> lambdabot makes it sooo easy!
04:39:27 <dankna> lift does "one level" of lifting
04:39:40 <dankna> liftIO does however many levels are necessary to bring IO to the top of the stack
04:39:46 <dankna> through the magic of typeclasses
04:40:04 <dankna> "lift" is a method of MonadTrans and "liftIO" is a method of MonadIO
04:40:09 <dankna> you can define your own things like liftIO
04:40:15 <dankna> you would do it like this
04:41:07 <ruuby> so its always necessary to have IO at the top of the stack? IO (m1 (m... (m a))
04:41:24 <dankna> class Monad m => MonadMine m where { liftMine :: (Monad m) => m a -> MonadMine a }
04:41:35 <dankna> wait
04:41:43 <quicksilver> liftIO is lift . lift . lift . lift for n copies of lift
04:41:46 <dankna> that doesn't quite work, because I used MonadMine as both a class name and a type constructor
04:41:47 <quicksilver> but you don't know what n is
04:41:50 <dankna> yes, what quicksilver said
04:41:59 <quicksilver> I mean, it works for various n :)
04:42:04 <quicksilver> by type inference / typeclasses.
04:42:08 <dankna> ruuby: well, because IO is not a transformer, you can't put it anywhere but the top
04:42:10 <dankna> there is no IOT
04:42:13 <dankna> but there is a StateT
04:42:16 <dankna> so State always goes around IO
04:42:20 <dankna> not IO around State
04:42:32 <dankna> rather, you can't put IO anywhere but the /bottom/ I should really say
04:42:33 <quicksilver> IOT would require the ability to timetravel, in a sense
04:42:34 <dankna> the top is the exposed one
04:42:49 <dankna> yeah
04:43:04 <dankna> anyway for the custom-lift example, what you would need is
04:43:24 <dankna> instance MonadMine MyMonad where liftMine a = a
04:43:57 <dankna> instance (MonadTrans transformer, MonadMine underlying) => MonadMine (transformer underlying) where liftMine a = lift a
04:44:47 <int-e> Sounds dangerous.
04:44:53 <dankna> with those two instances, ghc is able to figure out that if you stack any number of knowns transformer (any instances of MonadTrans) on top of a MyMonad, you can lift the appropriate number of times
04:45:06 <dankna> int-e: hah, yes, the mine might explode :)
04:45:10 <dankna> unsafeLiftMine :D
04:45:58 <dankna> notice that I defined a monad MyMonad, and ALSO a typeclass MonadMine
04:46:10 <dankna> MyMonad being a member of MonadMine
04:46:12 <benmachine> I wouldn't do that latter instance, it would probably overlap quite a lot
04:46:15 <dankna> it does
04:46:19 <benmachine> I'd do it for each transformer individually
04:46:20 <dankna> it's a problem
04:46:24 <dankna> yeah, hm
04:46:26 <dankna> that would work
04:47:07 <benmachine> it's a bit of a nuisance but it's less liable to explode
04:47:24 <dankna> I forget now exactly what problem I ran into when trying to do this
04:47:28 <dankna> I had a ton of StateTs
04:47:32 <dankna> stacked on top of each other
04:47:44 <dankna> and typeclasses for lifting into each different one
04:47:49 <dankna> right, I remember now
04:47:55 <dankna> the base case was overlapping with the iterative case!
04:48:09 <dankna> so I wound up having to turn on OverlappingInstances, I think
04:48:23 <dankna> which worked only because I was able to control stuff precisely
04:48:28 <dankna> it sucked and was disappointing :(
04:50:10 <benmachine> yes, overlappinginstances causes pain
04:50:25 <dankna> yes, it did
04:50:32 <dankna> I eventually changed it to be a single StateT
04:50:38 <dankna> because of efficiency concerns
04:50:41 <dankna> although it didn't help
04:50:50 <dankna> and the program is still two orders of magnitude slower than it needs to be :(
04:51:07 <dankna> most of the time in the profile goes into >>=
04:51:09 <dankna> I'm mystified
04:54:09 <RaptorRarr> http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf says "The stream function example above illustrates an arrow which takes its input in a di?erent way, as a stream of values rather than a single value, so this is an example of a kind of computation which cannot be represented as a monad."
04:54:22 <RaptorRarr> I'm a bit confused because it seems like the list monad does that, too.
04:54:29 <RaptorRarr> What do they mean there?
04:54:32 <dankna> the list monad actually represents nondeterminism
04:54:38 <dankna> rather than a stream
04:55:07 <benmachine> dankna: considered trying the strict StateT instead of the lazy one?
04:55:19 <dankna> benmachine: already done.  as well as a custom reimplementation of StateT.
04:55:23 <benmachine> oh right :<
04:55:30 <dankna> oh, you were one of the people helping with it?
04:55:41 <benmachine> ...was I? >_>
04:55:46 <dankna> I didn't think so
04:55:47 <rrc7cz> I'm having trouble parsing a numeric month value with Data.Time.Format.parseTime which uses Unix format elements. The problem is only %m is supported, but it requires a leading zero. I can't find a way to do it without a leading zero. I tried %n, which some systems support, and %-m, neither of which work. Any ideas?
04:55:51 <dankna> but you said "oh right" as if you knew haha
04:55:55 <RaptorRarr> dankna: So, the difference is that each element of the stream is guaranteed to produce one output?
04:56:07 <benmachine> no, I meant "acknowledged" :P
04:56:07 <dankna> rrc7cz: does %0m work?
04:56:10 <dankna> benmachine: oh
04:56:21 <dankna> RaptorRarr, not certain.  have that paper open now and looking.
04:56:24 <rrc7cz> dankna: no
04:56:30 <RaptorRarr> dankna: Thanks :)
04:56:40 <rrc7cz> Here's the expr btw: parseTime defaultTimeLocale "%-m/%-d/%Y" "8/9/2011" :: Maybe Day
04:56:40 <dankna> rrc7cz: hmmm, track down the maintainer and talk to him I'd say.  it could use an overhaul.
04:57:02 <rrc7cz> okay
04:57:07 <dankna> what about
04:57:12 <dankna> %-2m
04:57:13 <rrc7cz> also that %-d should be a %e, I copied an old one by accident
04:57:37 <dankna> also check the source to the library if you feel brave
04:57:38 <rrc7cz> ok
04:59:00 <rahul_> Hi
05:01:13 <rahul_> I have noticed this general pattern while composing functions. `f x = a . b x` can be written as `f = (a .) . b`, and `f x = a x . b` can be written as `f = (. a) . b`
05:01:21 <dankna> yes, indeed
05:02:12 <rahul_> I however fail to see how to intuitively think of these compositions. I have almost had them memorized now, but I didn't came up with these on my own. They got etched on my memory after repeated experiments with lambdabot
05:02:33 <rahul_> Can someone please tell me how should I "read" these point free versions?
05:02:51 <rahul_> Sorry if my question is vague. Dunno how else to put it. :-(
05:03:14 <dankna> I don't know that they necessarily have an intuitive translation into English
05:03:18 <dankna> which I think is what you're asking for
05:03:37 <rahul_> dankna: Yes.
05:03:45 <dainanaki> Basically you read them by putting together the type signatures in your head.
05:03:47 <RaptorRarr> rahul_: You mean (a .) and (. a)?
05:03:50 <dankna> I guess I'd say f = (a .) . b
05:03:52 <dankna> as
05:03:56 <rahul_> RaptorRarr: Yes.
05:04:01 <Botje> rahul_: if you expand them once, you get f x = a . b x back
05:04:07 <dankna> "A slice-compose, composed with B"
05:04:08 <rahul_> dainanaki: Tried that. It blows my head. :(
05:04:16 <dainanaki> It takes time.
05:04:16 <dankna> and f = (. a) . b as
05:04:24 <dankna> "Slice-compose A, composed with B"
05:04:31 <dankna> but that convention is not very useful
05:04:35 <dainanaki> rahul_: my advice is trying them out on paper until you get used to it.
05:04:38 <dankna> in particular it doesn't generalize to things with more levels of parentheses
05:04:42 <RaptorRarr> rahul_: "Apply b, then (a .). (a .) takes the first argument as if it's a function."
05:04:46 <dankna> you really want to get to a point where "math is your first language"
05:04:48 <dankna> that is
05:05:03 <moriramar> @pl f x = g x (d c x)
05:05:03 <lambdabot> f = ap g (d c)
05:05:06 <RaptorRarr> @unpl (a .) . b
05:05:06 <lambdabot> (\ f i -> a (b f i))
05:05:08 <int-e> Heh. I just don't use sections of (.).
05:05:14 <dankna> it's a standard test of natural-language proficiency that you can do arithmetic, speaking the intermediate steps out loud, as quickly in the target language as you can in your first language
05:05:22 <dankna> but for me and probably many people here, I can't even do that in English!
05:05:30 <dankna> because it's faster to treat the math as "its own mental object"
05:05:35 <dankna> and not put it in words at all
05:05:42 <Botje> anyone know of good texts for learning to write typesystem papers?
05:05:57 <Botje> ie: is there a concrete list of DOs and DONTs ?
05:05:58 <rahul_> I understood arrows after I read Wikibook's arrows chapter that provides a metaphor of conveyor belt and robots. Something like that would help!
05:06:15 <Botje> rahul_: there is no metaphor. only zool^w the source
05:06:28 <dankna> sp. zuul
05:06:30 <rahul_> dankna, Botje : Sounds good. Maybe I should be patient, and wait for my moment of mathematical enlightenment. :-)
05:06:34 <dankna> rahul_: yeah :)
05:06:57 <rahul_> It's been just over a week. Maybe I am being too greedy!
05:07:02 <benmachine> I sort of imagine squashing arguments on the end with sufficient force that a dot pops out, then clamping it there with some parentheses
05:07:09 <dankna> benmachine: hahhahahaa!  wow
05:07:12 <benmachine> and then sorting out the sections
05:07:23 <dankna> that's quite a metaphor
05:07:30 <benmachine> :P
05:07:32 <rahul_> benmachine: LOL
05:07:56 <RaptorRarr> @unpl (a .)
05:07:57 <lambdabot> (\ b e -> a (b e))
05:08:03 <RaptorRarr> @unpl (. a)
05:08:04 <lambdabot> (\ b e -> b (a e))
05:08:45 <rahul_> :t fmap fmap fmap
05:08:46 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:09:13 <RaptorRarr> @unpl fmap fmap fmap
05:09:14 <lambdabot> fmap fmap fmap
05:09:26 <rahul_> @slap lambdabot
05:09:27 <lambdabot> Come on, let's all slap lambdabot
05:09:41 <RaptorRarr> :(
05:09:44 <sbrg_> @slap lambdabot
05:09:44 * lambdabot karate-chops lambdabot into two equally sized halves
05:09:52 <sbrg_> @slap lambdabot
05:09:53 * lambdabot pushes lambdabot from his chair
05:10:02 <dankna> didn't that used to not work
05:10:03 <sbrg_> @slap herself
05:10:04 * lambdabot smacks herself about with a large trout
05:10:13 <RaptorRarr> Bot abuse!
05:10:17 <sbrg_> what a crazy lambdabot
05:10:54 <cheater> is it possible to use an unqualified import only in a single function?
05:11:31 <cheater> say i want to use blaze html, but only in one function, i would like to have all the values from the relevant packages available in one function but not elsewhere
05:11:34 <int-e> cheater: heh, yes, by putting that function into its own module?
05:11:40 <cheater> or elsewhere too but only qualified
05:11:43 <cheater> int-e: hmmmmmmmmmm
05:11:44 <int-e> cheater: but as you mean it, no.
05:12:07 <cheater> int-e: putting a function in its own module is interesting, though.
05:12:21 <int-e> cheater: (of course you can use let to define an (unqualified) alias for a function)
05:12:48 <gienah> Botje: sure stephanie explains how to on slide 3 of:
05:12:55 <gienah> @google "Machine Assistance for Programming Language Research" Stephanie Weirich
05:12:55 <cheater> int-e: but can i create unqualified aliases for everything, in one go?
05:12:56 <lambdabot> http://www.seas.upenn.edu/~sweirich/talks/cuny09.pdf
05:12:56 <lambdabot> Title: Machine Assistance for Programming Language Research
05:13:03 <cheater> for everything in a module
05:13:36 <gienah> Botje: Proof sketch: By standard induction over the typing rules
05:13:46 <int-e> cheater: no. (excluding Template Haskell -- I'm not sure whether TH can query module interfaces.)
05:14:04 <cheater> int-e: why?
05:14:23 * hackagebot time-http 0.2 - Parse and format HTTP/1.1 Date and Time strings  http://hackage.haskell.org/package/time-http-0.2 (MasatakeDaimon)
05:14:58 <int-e> cheater: why? there's no syntax for that.
05:15:31 <cheater> why do we need syntax for that?
05:15:46 <cheater> can't you define something like let in haskell?
05:15:59 <int-e> no. let is built-in syntax.
05:16:08 <cheater> why?
05:16:17 <int-e> because that's how haskell is defined
05:17:05 <cheater> that doesn't exhaust the subject
05:17:17 <benmachine> cheater: how would you?
05:17:30 <RaptorRarr> Variable names aren't really mess-with-able by code.
05:17:43 <RaptorRarr> So, you can't make up new ones in code.
05:17:50 <cheater> hmm
05:17:52 <RaptorRarr> Except by using let or something.
05:17:53 <cheater> not good
05:18:23 <sbrg_> let is one of the few things in haskell that is actual 'magic'
05:18:27 <sbrg_> it's syntax etc
05:18:54 <cheater> cool
05:18:55 <cheater> ok
05:19:02 <sbrg_> You know, even integers aren't magic
05:19:06 <sbrg_> They are literally a data type
05:19:12 <cheater> aha
05:19:20 <cheater> btw, what's the best way to use something like postgresql in haskell?
05:19:20 <sbrg_> to this day, people are still working on updating it
05:19:25 <sbrg_> infinity is a hard thing to reach
05:19:49 <RaptorRarr> cheater: Are you trolling?
05:19:53 <herself> sbrg_: why smack me?!
05:19:54 <cheater> ?
05:19:55 <cheater> no
05:19:58 <cheater> are you?
05:19:59 <RaptorRarr> Oh, OK
05:20:03 <sbrg_> herself: sorry
05:20:04 <saml> you're welcome.
05:20:05 <RaptorRarr> Nope
05:20:10 <saml> what's wrong RaptorRarr ?
05:20:10 <benmachine> sbrg_: no it isn't :P
05:20:12 <herself> ;-D
05:20:16 <cheater> good to know.
05:20:20 <Jafet> sbrg: data Infinity = Succ Infinity
05:20:23 <sbrg_> benmachine: Don't you lie to the newbie
05:20:29 <cheater> so does haskell have any high level abstractions over database apis
05:20:35 <benmachine> sbrg_: wrt infinity being hard to reach
05:20:40 <cheater> or do i just find some postgresql specific interface
05:20:46 <saml> cheater, yes
05:20:47 <rahul_> Now I have this function: let range i j = sequence $ zipWith enumFromTo i j.
05:20:51 <sbrg_> You and I both know integer is just data Integer = 1 *verticallinecan'tmakeit*.. etc to infinity
05:20:53 <saml> oh..
05:20:55 <int-e> Looking at TH's Quasi monad I don't think you can query module interfaces from TH either. (There's no fundamental reason for that, I think)
05:20:56 <rahul_> I asked lambdabot for a pointfree version.
05:20:59 <cheater> that wasn't a yes/no question
05:21:01 <saml> cheater, you can easily create LINQ over haskell
05:21:03 <rahul_> @pl \i j -> sequence $ zipWith enumFromTo i j
05:21:04 <lambdabot> (sequence .) . zipWith enumFromTo
05:21:04 <sbrg_> benmachine: oh
05:21:11 <cheater> saml: what's linq?
05:21:18 <rahul_> but this code yielded by lambdabot doesnt seem to work.
05:21:18 <saml> DB Monad
05:21:24 <cheater> ok
05:21:26 <RaptorRarr> saml: Nothing, it just seemed like cheater was joking, but I wasn't confident in that assessment.
05:21:29 <sbrg_> benmachine: well, your joke went over my head
05:21:32 <dankna> int-e: you can neither query nor extend module interfaces from TH, correct
05:21:36 <sbrg_> but i'll pretend like i understand it and assume it is funny
05:21:37 <cheater> what does it mean to "create a linq over haskell"?
05:21:38 <benmachine> sbrg_: it wasn't a joke; Integer *could* be defined without magic, but it would just be much slower than the existing implmentation
05:21:43 <dankna> it would be useful to be able to add to the export list, but oh well!
05:21:49 <cheater> RaptorRarr: joking isn't trolling
05:22:03 <cheater> saml: what does it mean to "create a linq over haskell"?
05:22:17 <benmachine> oh, admittedly integer *literals* couldn't
05:22:19 <RaptorRarr> cheater: I meant more trolling in a humorous fashion.
05:22:19 <benmachine> but oh well
05:22:21 <saml> cheater, i mean.. you can easily create high level db abstraction monad in haskell
05:22:34 <saml> do it and post on hpaste.org. thanks.
05:22:44 <Jafet> sbrg: no, you silly child. data Integer = S# Int# | J# Int# ByteArray#
05:23:07 <gienah> saml cheater: linq was influenced by haskelldb
05:23:13 <int-e> dankna: Oh I wouldn't want to extend them. (Except the current module, and that can be done.)
05:23:23 <cheater> saml: i don't want to create one, i want to use one that exists.
05:23:24 <rahul_> :(
05:23:26 <benmachine> Jafet: that's already magic, MagicHash to be precise
05:23:50 <gienah> cheater: there's haskelldb, it uses its own extensible records
05:24:35 <gienah> cheater: there's groundhog, which is neat as it can use haskell records, but its only sqlite at the moment so guess you would need to write a postgresql driver for it
05:24:51 <rahul_> nvm. adding a type signature solved the issue.
05:25:09 <cheater> that is a sad state of things
05:25:21 <dankna> int-e: it can?  I was under the impression it couldn't, because the compiler needs to process module headers in an earlier pass, before processing contents.
05:25:23 <Jafet> benmachine: just connive to get the Shootout to disqualify integer-gmp and we'll have a fast integer-simple in no time
05:25:39 <benmachine> Jafet: heh
05:26:01 <cheater> there is apparently something called HDBC-Postgresql
05:26:09 <cheater> is HDBC something any of you has used?
05:26:26 <int-e> dankna: Oh, you mean the export list. I agree, you cannot change that from TH. (But if a module exports everything, it should still work? I never tried.)
05:26:31 <gienah> cheater: no as its kind of low level
05:26:38 <Jafet> Extensible records: http://hpaste.org/51082
05:26:57 <dankna> int-e: I never tried that either, but my guess would be that it doesn't work, actually!
05:27:11 <gienah> cheater: as in I'd prefer to use a more high level database library in application code
05:27:21 <cheater> gienah: what is low level about it?
05:27:37 <dankna> int-e: anyway it's a relatively minor bookkeeping overhead, really
05:28:20 <gienah> cheater: groundhog can map straight from haskell records to SQL rows, and haskelldb has a relational algebra like high level query language
05:28:33 <EvanR-work> cheater: i used HDBC
05:28:46 <gienah> cheater: haskelldb is a library that uses HDBC
05:28:58 <EvanR-work> haskelldb can use dhbc
05:29:00 <EvanR-work> hdbc
05:29:19 <Haskill> what does the $ sign mean?
05:29:26 <EvanR-work> cheater: i used it for mysql, but mysql-simple is better. there might be a just-as-awesome mysql lib
05:29:38 <cheater> Haskill: argument application
05:29:39 <EvanR-work> > even $ 9
05:29:40 <lambdabot>   False
05:29:58 <Haskill> cool, thanks
05:30:00 <mauke> Haskill: it's a library function
05:30:05 <cheater> func x y (func2 z) <=> func x y $ func z
05:30:10 <cheater> func x y (func2 z) <=> func x y $ func2 z
05:30:11 <cheater> sorry
05:30:55 <cheater> EvanR-work: but i want to use it for postgres
05:31:06 <EvanR-work> i meant to say
05:31:11 <EvanR-work> there might be just-as-awesome postgres lib
05:31:15 <cheater> oh ok :p
05:31:53 <saml> cheater, chances are you 'll have to create on your own
05:32:05 <cheater> why
05:32:05 <gienah> cheater EvanR-work: there is a postgresql library like mysql-simple in development on github (tries to remember where)
05:32:14 <saml> haskell provides different abstractions.. and one might not fit your taste, usecase
05:32:31 <cheater> i don't want to bother developing a library for a database
05:32:31 <EvanR-work> i just looked through hackage and i dont see anything good for postgress except maybe haskelldb
05:32:42 <gienah> cheater: https://github.com/chrisdone/pgsql-simple
05:32:42 <saml> why not? it's fun to reinvent over and over until you find agreed upon abstraction that is eloquenty
05:32:43 <cheater> if it's necessary i would just instead use a different database :p
05:32:55 <EvanR-work> cheater: you dont need a library, but you can just use postgres directly
05:33:13 <cheater> gienah: let's say i wanted to use haskelldb... would i use pgsql-simple?
05:33:19 <EvanR-work> no
05:33:25 <cheater> why not?
05:33:40 <gienah> cheater: no, as haskelldb can use hdbc-postgresql instead
05:33:41 <EvanR-work> you use haskelldb with the haskelldb-hdbc-postgres driver
05:33:44 <saml> cheater, why do you need abstraction?
05:34:07 <EvanR-work> which need hdbc and probably postgres
05:34:12 <saml> you can easily create SQL generation/parsing library.  but actual drives will be different per database
05:34:26 <saml> use haskellalchemy
05:34:31 <ski> cheater : s/<=>/=/
05:34:57 <saml> and why not use mongodb? postgresql is not web scale but mongodb is
05:35:04 <EvanR-work> i will kill you
05:35:11 <cheater> kill him
05:35:28 <sbrg_> kill me
05:35:31 <sbrg_> no, seriously
05:35:33 <cheater> ok so..
05:35:34 * ski . o O ( "Kill him, my robots!" )
05:35:35 * saml takes out mongodb card
05:35:44 <cheater> i either use pgsql-simple
05:35:49 <saml> we need mongodb based on CMS
05:35:52 <cheater> or i use haskelldb with hdbc-postgresql
05:35:53 <sbrg_> this class is draining sending my soul into an infintely deep and dark abyss, piece by piece
05:35:54 <cheater> right?
05:35:54 <EvanR-work> the amount of complexity involved here and the way i say you should use these shitty rdbmss indicates you should switch to mysql just so you can use mysql-simple
05:35:56 * RaptorRarr eats sbrg_.
05:36:01 <EvanR-work> cheater: ^
05:36:15 <EvanR-work> unless pgsql-simple is ready
05:36:26 <cheater> i don't want to use mysql
05:36:40 <cheater> some of my applications don't really support it
05:36:44 <EvanR-work> ok
05:36:48 <saml> mysql is sharding web scale
05:36:56 <saml> mongodb is nosql web scale
05:38:16 <dolio> sbrg_: Sounds great.
05:39:14 <EvanR-work> is mongodb webscale in the sense that node.js is webscale? that is to say, monumentally retarded?
05:39:17 <sbrg_> dolio: it really is
05:52:52 <Botje> gienah: a belated thank you. I got called away
05:53:56 <gienah> Botje: no worries, it appeals to my sense of humour :-)
05:54:19 <rostayob> Is it possible generate a FunPtr from an exported haskell function in Haskell code?
05:54:41 <rostayob> or even not exported
05:56:25 <quicksilver> rostayob: absolutely.
05:56:38 <quicksilver> rostayob: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-Ptr.html#2
05:57:47 <rostayob> wow how could i miss that
05:57:48 <rostayob> quicksilver: thanks
05:58:34 <rostayob> that is pretty cool, so i can freely pass haskell functions that do stuff to C code that will use them
06:00:10 <Saulzar> Repa's shape polymorphism is neat. The simplest multi dimensional array interface I've seen (admittedly out of not many)
06:00:57 <Saulzar> Curiously if I use 2 threads (on my dual core machine) time taken is halved, if I use four it goes up by a factor of 4... !
06:01:34 <EvanR-work> might as well set it to 256 threads then
06:01:58 <EvanR-work> or 16384
06:02:33 <Saulzar> Yes, that seems to be taking some time...
06:03:29 <Saulzar> 16 threads is already a slowdown of around 100x
06:03:55 <EvanR-work> the law is broken!
06:05:06 <erus`> http://mathias-biilmann.net/posts/2011/10/is-haskell-the-cure
06:05:18 <cheater> how do i find out all the values in a qualified module?
06:05:31 <Botje> :browse ?
06:06:04 <EvanR-work> what isnt the cure is that hip web design
06:06:07 <cheater> thanks
06:06:45 <erus`> i wish i could do sexy websites
06:07:00 <koala_man> do them all night long
06:07:04 <erus`> but making stuff work on all browsers just makes me too sad
06:07:26 <EvanR-work> even the idea of working on all browsers is flawed
06:07:52 <erus`> html is flawed
06:07:56 <erus`> css is flawed
06:08:00 <EvanR-work> www is flawed
06:08:09 <erus`> x86 has too many instructions
06:08:40 <EvanR-work> new platform plz
06:08:48 <roconnor> sgml is perfect
06:08:49 <EvanR-work> star trek computers
06:09:11 <koala_man> just use server side image maps. problem solved.
06:10:09 <erus`> koala_man: good idea
06:10:20 <erus`> maybe even send drawing commands to a full page canvas
06:10:24 <EvanR-work> yep, at least then it would have dignity
06:10:33 <erus`> animooted
06:10:45 <EvanR-work> rather than pretending to not be a freakin image
06:11:05 <EvanR-work> its become a game to see how to can draw a photoshop-like image with esoteric css
06:11:12 <EvanR-work> you can*
06:11:39 <Veinor> erus`: pointed out in the comments of that post:
06:11:45 <EvanR-work> if its fixed width etc and browsers now simply scale rather than 'zoom'
06:11:49 <Veinor> the http headers on that post include X-Trolled: Hard
06:11:56 <EvanR-work> might as well just be an image
06:12:35 <EvanR-work> on the subject of node, its awful
06:13:02 <erus`> agreed
06:13:08 <Jafet> Didn't some no-longer-extant company called Macromedia do that?
06:13:25 <EvanR-work> heh
06:14:02 <EvanR-work> "This benchmark is a perfect example of why improving your algorithms is a better idea that changing your language"
06:14:12 <EvanR-work> uhm, web programming is 100% moving data around
06:14:18 <EvanR-work> no 'real' computation
06:14:47 <erus`> EvanR-work: that depends on the website, surely
06:14:48 <EvanR-work> within the same language theres no way to make that faster in a dignified way, its inherent
06:15:34 <erus`> I'm going to make a snap website for snobby haskell users like myself :)
06:15:36 <roconnor> EvanR-work: http://ddmf.msr-inria.inria.fr/1.6.1/ddmf
06:16:10 <EvanR-work> giving me fringe counterexamples wont change the rounded value of 100%
06:16:17 <Silvah> EvanR-work: uhm, web programming is 100% making security holes, actually.
06:16:20 <roconnor> stupid rounding
06:16:46 <EvanR-work> Silvah: well thats an additional layer on top of the data moving
06:16:56 <EvanR-work> but yes, equally important
06:22:49 <int-e> EvanR-work: you could argue that they're one and the same
06:22:55 <tromp> > 210/8
06:22:56 <lambdabot>   26.25
06:23:22 <int-e> tromp: but what does it do?
06:27:35 <tromp> what does what do?
06:28:09 <tromp> oh, you asked what the 210 is about. yes, the blc interpreter
06:36:19 <Phazorx> trying to compile/emerge snap on gentoo and get: http://paste.pocoo.org/show/486533/
06:36:22 <Phazorx> any suggestions?
06:36:53 <mauke> base >=4 && <3
06:37:44 <EvanR-work> no solution
06:39:00 <erus`> whats wrong with this? interact (\x -> show $ 100 / (read x) * 33)
06:39:02 <ski> @check \n -> not (n >= 4 && n < 3)
06:39:03 <lambdabot>   "OK, passed 500 tests."
06:39:34 <ski> erus` : is there anything wrong with it ?
06:39:43 <erus`> ghci does like it
06:39:47 <ski> (you can s/(read x)/read x/, of course)
06:40:04 <erus`> doesnt*
06:40:08 <RaptorRarr> @type interact (\x -> show $ 100 / (read x) * 33)
06:40:09 <lambdabot> IO ()
06:40:11 <ski> @type interact (\x -> show $ 100 / (read x) * 33)
06:40:12 <lambdabot> IO ()
06:40:25 <ski> > read "12" :: Double
06:40:26 <lambdabot>   12.0
06:40:45 <saml> > read mind :: You
06:40:45 <lambdabot>   Not in scope: type constructor or class `You'Not in scope: `mind'
06:40:50 <RaptorRarr> > let f = (\x -> show $ 100 / (read x) * 33) in f "25"
06:40:51 <lambdabot>   "132.0"
06:40:55 <RaptorRarr> Looks good to me.
06:41:07 <erus`> maybe interact doesnt work with ghci
06:41:15 <saml> > read "0.000001" :: Double
06:41:15 <lambdabot>   1.0e-6
06:41:36 <saml> > 0.1 + 0.2
06:41:37 <lambdabot>   0.30000000000000004
06:41:45 <RaptorRarr> @pl (\x -> show $ 100 / (read x) * 33)
06:41:45 <lambdabot> show . (33 *) . (100 /) . read
06:42:04 <erus`> what does pl stand for?
06:42:17 <int-e> "pointless"
06:42:21 <saml> in lua,  0.1+0.2  is 0.3
06:42:23 <ski> erus` : mayhaps you wanted to use `lines' and `unlines' ?
06:42:25 <RaptorRarr> erus`: Pointless, which means get rid of arguments.
06:42:28 <erus`> ah i thought it was pointfree
06:42:33 <int-e> a pun on "pointfree" and the usefulness of the results
06:42:33 <ski> @help pl
06:42:34 <saml> in python, 0.1+0.2 is 0.30000000000000004
06:42:34 <lambdabot> pointless <expr>. Play with pointfree code.
06:42:54 <Veinor> saml: welcome to the world of IEEE854 floats!
06:43:03 <int-e> (that's my interpretation at least)
06:43:07 <saml> lua does correctly, right?
06:43:22 <Veinor> > (0.1 :: Double) + (0.2 :: Double)
06:43:23 <lambdabot>   0.30000000000000004
06:43:27 <int-e> define "correctly"
06:43:29 <Veinor> > (0.1 :: Float) + (0.2 :: Float)
06:43:30 <lambdabot>   0.3
06:43:30 <RaptorRarr> @type let interact' :: Read a, Show b => (a -> b) -> IO (); interact' f = show . f . read in interact'
06:43:31 <lambdabot> parse error on input `,'
06:43:41 <RaptorRarr> @type let interact' :: (Read a, Show b) => (a -> b) -> IO (); interact' f = show . f . read in interact'
06:43:42 <lambdabot>     Couldn't match expected type `()' against inferred type `String'
06:43:42 <lambdabot>     In the first argument of `(.)', namely `show'
06:43:42 <lambdabot>     In the expression: show . f . read
06:43:45 <RaptorRarr> Lies!
06:43:53 <int-e> > 0.1 + 0.2 :: Rational
06:43:54 <lambdabot>   3 % 10
06:44:03 <Veinor> > 0.1 + 0.2 == 0.3
06:44:04 <lambdabot>   False
06:44:04 <RaptorRarr> @type let interact' :: (Read a, Show b) => (a -> b) -> IO (); interact' f = interact (show . f . read) in interact'
06:44:05 <lambdabot> forall a b. (Show b, Read a) => (a -> b) -> IO ()
06:44:08 <RaptorRarr> There :)
06:44:39 <RaptorRarr> @type let interact' :: (Read a, Show b) => (a -> b) -> IO (); interact' f = interact (show . f . read) in interact' (\x -> 100/x * 33)
06:44:40 <lambdabot> IO ()
06:44:54 <int-e> Proof by floating point arithmetic. I need to add that to my repertoire.
06:45:05 <RaptorRarr> Much wonderfuller than interact.
06:45:18 <RaptorRarr> Many wonderfullers more than it.
06:45:41 <RaptorRarr> @hoogle (Read a, Show b) => (a -> b) -> IO ()
06:45:42 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
06:45:42 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
06:45:42 <lambdabot> Data.ByteString.Char8 interact :: (ByteString -> ByteString) -> IO ()
06:46:02 <erus`> i have a name for my blog 'function compost'. My first post is about monads
06:46:22 <dankna> :t Data.Map.insert
06:46:23 <erus`> monads are like ice cream
06:46:23 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
06:46:35 <roconnor> > 0.5 + 0.25 == 0.75
06:46:36 <lambdabot>   True
06:46:59 <int-e> erus`: monads are like mouldy leaves?
06:47:03 <RaptorRarr> > 0.1 + 0.1 == 0.2
06:47:05 <lambdabot>   True
06:47:12 <Saulzar> > 1.0 /= 1.0
06:47:13 <lambdabot>   False
06:47:19 <Veinor> monads are like a box of chocolates
06:47:22 <EvanR-work> lol
06:47:27 <Veinor> you never know what you're going to get
06:47:30 <dankna> monads are like monads
06:47:30 <Saulzar> They go well with ice cream?
06:47:35 <RaptorRarr> > 0.1 + 0.1 + 0.1 == 0.3
06:47:37 <lambdabot>   False
06:47:38 <int-e> Veinor: always mysteriously empty? *g*
06:47:42 <Veinor> haha
06:47:43 <cheater> burritos are like monads
06:47:46 <Eduard_Munteanu> No, monads monads are like monads :P
06:48:01 <Veinor> cheater: overrated?
06:48:02 <int-e> Eduard_Munteanu: but no monad is like a monad.
06:48:04 <dankna> Monads are like monads, because monads are like monads.
06:48:08 <ski> @where floating-point
06:48:09 <lambdabot> I know nothing about floating-point.
06:48:11 * mah_b believe forrest's me is right
06:48:16 <ski> @where+ floating-point "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
06:48:16 <mah_b> *ma
06:48:16 <lambdabot> It is stored.
06:48:21 <ski> saml : ^
06:48:33 <RaptorRarr> Monads are like monads by identity. QED.
06:48:45 <Eduard_Munteanu> refl, bro
06:48:51 <dankna> wouldn't it be funny if monads were actually not like monads
06:49:00 <EvanR-work> antireflexive
06:49:09 <erus`> monads are A monad is just a monoid in the category of endofunctors
06:49:19 <cheater> Veinor: yes
06:49:24 <Veinor> :D
06:49:24 <dankna> wtf endofunctor :)
06:49:43 <Veinor> gah that pings me
06:49:54 <Veinor> well not literally but it makes me think someone's talking to me
06:49:55 <dankna> mind you, I understand monads, functors, and monoids.  but not endofunctors.
06:49:59 <dankna> heh, I see
06:50:05 <dankna> so it pings you at the brain-level.
06:50:11 <Veinor> yeah
06:50:13 <dankna> hehe
06:50:32 <roconnor> dankna: 'Functor's are endofunctors
06:50:34 <ski> saml : Lua probably gets `0.30000000000000004' as well, only it rounds the result just before displaying it, so that you don't see the small error
06:50:51 <dankna> roconnor: hmmm okay
06:51:22 <roconnor> dankna: they are endo because they have kind * -> *
06:51:30 <roconnor> so the input kind is the same as the output kind
06:51:33 <dankna> so, what would an exofunctor be?
06:51:34 <ElKaku> the first rule of monads. There are no monads.
06:51:47 <dankna> the second rule of monads: there are no monads YET.
06:52:17 <roconnor> dankna: in my multiplate work I effectively have functors from functors to type (in haskell it gets the inexact kind (* -> *) -> *)
06:52:31 <ElKaku> the third of monads. MAYBE they exist, MAYBE they don't.
06:52:34 <roconnor> sorry, functors from 'Functor's to Types
06:52:37 <EvanR-work> missing a (
06:52:41 <EvanR-work> oh nm
06:52:49 <ski> dankna : a(n example of a) class for functors which wouldn't be endo could be `class FunctorFunctor t where tmap :: (Functor f,Functor g) => (forall a. f a -> g a) -> (t f -> t g)'
06:53:09 <Veinor> > x = 0.2 + 0.1
06:53:09 <lambdabot>   <no location info>: parse error on input `='
06:53:11 <Veinor> > print (x == 0.3)
06:53:12 <lambdabot>   <IO ()>
06:53:13 <Veinor> false
06:53:17 <Veinor> haha
06:53:19 <dankna> hmmmmmm
06:53:27 <dankna> wait a sec while I ponder that
06:53:39 <ski> dankna : those would be functors of kind `(* -> *) -> *' .. so like roconnor's ones, i suspect
06:53:41 <roconnor> dankna: ya, my multiplate stuff has a tmap like ski's
06:53:45 <saml> maybe lua uses something like  printf("%.<precision>f", x);    whre <precision> is calculated from x.
06:53:48 <dankna> ah yes, interesting
06:53:53 <Veinor> that's possible
06:53:55 <dankna> I believe I get it
06:54:00 <ski> roconnor : with or without the `(Functor f,Functor g) => ' part ?
06:54:32 <roconnor> dankna: I like to write (forall a. f a -> g a) as f ~> g ... but ~> gets used a lot for otherthings I guess
06:54:46 <dankna> yeah it does
06:54:50 <dankna> I don't like overloaded things
06:55:04 <roconnor> ski: I have the poorly named function: applyNaturalTransform :: forall p f g. Multiplate p => (forall a. f a -> g a) -> p f -> p g
06:55:16 <ski> dankna : an example of a type which could be an instance of this class would be `newtype List ref a = MkL (ref (ListCell ref a)); data ListCell ref a = Nil | Cons a (List ref a)'
06:55:34 <EvanR-work> saml: heres a rule you can use for this decorative discussion. the number which you display for a given fp number is the shortest in base ten necessary to reproduce the number by parsing
06:55:34 <roconnor> ski: f and g are intended to be Applicative; however they don't appear in the constraint
06:55:36 <dankna> hmmmmm
06:55:37 <dankna> so I see
06:55:43 <roconnor> ski: perhaps I should add them
06:55:48 <dankna> parametrized on both ref and a
06:55:49 <ski> roconnor : the class of which it is a member being `Multiplate' ?'
06:56:12 <EvanR-work> saml: if the next number is 3.0000000000039, then theres 'no difference' between 3.000000000004 and 3
06:56:21 <EvanR-work> next fp number*(
06:56:28 <roconnor> ski: I didn't understand your question; not sure what 'it' refers to.
06:56:34 <dankna> it should be noted that fp numbers can't be written exactly in decimal
06:56:41 <EvanR-work> eh?
06:56:44 <ski> roconnor : well, i'm not fully sure yet what the consequences of including resp. excluding them are -- i'm pretty sure the results will be different for sufficiently complicated examples, though
06:56:49 <dankna> because they are internally represented in binary
06:56:57 <dankna> that is, ones which are exact sums of powers of two can
06:56:58 <EvanR-work> they can be exactly represented in decimal
06:57:06 <roconnor> ski: what is 'them'?
06:57:09 <ski> roconnor : i meant, is `applyNaturalTransform' a member of the type class `Multiplate' ?
06:57:15 <dankna> oh wait
06:57:18 <dankna> sorry, I got that backwards
06:57:32 <dankna> you're right; all fp numbers have decimal representations, because when we write in decimal we don't put a limit on the length
06:57:37 <dankna> not all decimal representations have fp numbers
06:57:41 <ski> roconnor : sorry, i'm apparently very vague today -- "them" being the constraints `(Functor f,Functor g)'
06:57:42 <roconnor> ski: applyNaturalTransform is not a member of the class.  It is derived.
06:57:46 <ski> ah, ok
06:57:57 <ski> that would work as well, i suppose
06:57:57 <ski> (like `liftM' is derived)
06:58:36 <EvanR-work> dankna: well 0.1 is a tenth in decimal
06:58:43 <EvanR-work> but its infinite in binary
06:58:45 <ski> roconnor : btw, imo we really need some way of making a single `Functor' class which applies to all these cases
06:58:49 <dankna> EvanR: yes, I know
06:58:49 <Igloo> Type family question: Is there some way I can make this work? http://paste.debian.net/133851/
06:58:59 <EvanR-work> so you can put limit on base 10 and still get the binary problem
06:59:08 <Veinor> dankna: also iirc all fp numbers are of the form a*2^b where a and b are integral
06:59:14 <Veinor> so they have terminating decimal expansions
06:59:23 <roconnor> ski: tricky
06:59:30 <dankna> Veinor: yes, sorry.  that's what I was saying, just more concrete.
06:59:34 <ski> yes
06:59:38 <Veinor> ah, okay
07:00:04 <roconnor> ski: applyNaturalTransformation is roughly analogous to liftA which may help explain why it is derived and not a class member.
07:00:09 <ski> hm .. i suppose requiring an `f' of kind `* -> *' to be a functor is a bit similar to requiring an "operation" to be extensional (wrt an equality relation)
07:00:35 <ski> (only it's orderings, so monotonic instead of extensional)
07:00:36 <EvanR-work> Veinor: a*2^b wont be finite in base three though ;)
07:00:59 <EvanR-work> numbers are messed up
07:01:08 <ski> roconnor : yah, i mentioned similarity with `liftM' above :)
07:01:47 <roconnor> oops, I missed that
07:01:47 <dankna> oh I see
07:02:13 <dankna> the base in which you want it to have a finite representation has to be a multiple of the base in which it was originally written
07:02:17 <dankna> 10 divides 2 but 2 doesn't divide 10
07:02:30 <roconnor> 10 does not divide 2
07:02:32 <dankna> or backwards, whichever
07:02:33 <roconnor> 2 does divide 10
07:02:34 <EvanR-work> 2 divides 10
07:02:47 <roconnor> 10 is divisible by 2
07:02:47 <dankna> thank you, yes, that.  happily I am not a number theorist so I don't have to remember that :)
07:03:05 <EvanR-work> 'im not a climatologist so i can deny global warming' ;)
07:03:16 <dankna> EvanR: not the same thing!
07:03:39 <roconnor> EvanR-work: if you were a climatologist you sould call it climate change
07:03:45 <roconnor> *would
07:03:53 <EvanR-work> im not a climatologist
07:03:54 * roconnor is not a climatologist
07:04:10 <ski> IANAC
07:04:21 <roconnor> WWACD
07:05:44 <ski> dankna : a morphism from `A' to `A' is called an endomorphism (on `A') -- similarly a functor from a category `C' to the same category `C' is called an endofunctor (on `C')
07:06:32 <Eduard_Munteanu> dankna: presumably plain functors are "exo" by default
07:06:46 * ski has never heard the term "exofunctor" (before)
07:07:05 <Eduard_Munteanu> Endo means it stays in the same thing (category, group etc.)
07:07:32 <ski> also, an "automorphism" is an endomorphism which is also an isomorphism
07:07:43 * roconnor learns the ptx program
07:08:12 <ski> what's "ptx" ?
07:08:19 * Eduard_Munteanu thinks homo might not be politically correct :P
07:08:22 <roconnor> ptx - produce a permuted index of file contents
07:08:46 <polann> hello, I'm new to Haskell and I'm encountering some difficulties. I'm trying to use (map putStrLn) inside of a do block in order to print a list but I'm getting a type error.
07:08:50 <ski> Eduard_Munteanu : for what ? and why not ?
07:09:04 <Eduard_Munteanu> ski: eh, pun on homomorphisms
07:09:10 <ski> polann : what is the type error you get ?
07:09:11 <byorgey> polann: map putStrLn will produce a list of IO actions
07:09:23 <byorgey> polann: but you need a single IO action.
07:09:24 <ski> polann : you probably want `mapM_ putStrLn'
07:09:27 <Eduard_Munteanu> polann: you probably want mapM or mapM_
07:09:28 <byorgey> polann: instead of map, use mapM_
07:09:37 <polann> ok, I'll give it a try
07:09:52 <ski> polann : i.e. either `mapM_ putStrLn myList' or `sequence_ (map putStrLn myList)'
07:09:54 <polann> it worked :) thanks
07:10:04 <Eduard_Munteanu> Interestingly, I've never heard of "homofunctors", as terminology
07:10:30 <byorgey> polann: your homework now is to go stare at the types of map and mapM_ and the type error you got until you understand them
07:10:31 <ski> polann : `map putStrLn myList' will have type `[IO ()]', while you wanted `IO ()'
07:10:44 <polann> the type error was 'couldn't match IO a against inferred [IO ()]'
07:10:57 <Eduard_Munteanu> Though it's not like plain morphisms make sense either in, say, group theory.
07:11:01 <ski> polann : `sequence_' can be used to run each action in the list .. but you can also use `mapM_' instead of `sequence_' together with `map'
07:11:17 <ski>   sequence_ :: [IO a] -> IO ()
07:11:19 <polann> I don't understand sequence very well
07:11:36 <ski>   mapM_ :: (a -> IO b) -> ([a] -> IO ())
07:11:43 <ski>   sequence :: [IO a] -> IO [a]
07:11:44 <roconnor> sequences is probably the single most important function ever created by man.
07:11:48 <ski>   mapM :: (a -> IO b) -> ([a] -> IO [b])
07:11:50 <roconnor> *sequence
07:12:19 <ski> @src mapM_
07:12:20 <lambdabot> mapM_ f as = sequence_ (map f as)
07:12:23 <Eduard_Munteanu> @src sequence
07:12:23 <lambdabot> sequence []     = return []
07:12:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:12:24 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
07:12:31 <ski> @src sequence_
07:12:32 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:12:33 <byorgey> polann: sequence says 'run each action in this list and return a list of the results'
07:12:39 <ski> @src mapM
07:12:39 <lambdabot> mapM f as = sequence (map f as)
07:12:42 <byorgey> polann: sequence_ does the same thing but discards the results
07:13:43 <polann> could you give me a simpler example of using sequence?
07:13:53 <polann> I've seen it used to get cartesian products
07:15:12 <Eduard_Munteanu> polann: you can sequence_ [putStrLn "foo", putStrLn "bar"] for example
07:15:39 <ski> polann : `sequence_ [putStrLn "a", putStrLn "b", putStrLn "c"]' is the same as `do putStrLn "a"; putStrLn "b"; putStrLn "c"'
07:15:48 <Eduard_Munteanu> And that's like saying    putStrLn "foo" >> putStrLn "bar"
07:16:01 <ski> yeha, that's another way of saying the same thing
07:16:04 <polann> ah, that's neat
07:16:06 <Eduard_Munteanu> :)
07:16:46 <ski> polann : but whenever you have `sequence_ (map foo (...))', you can replace that with `mapM_ foo (...)' where `mapM_' exists because this is such a common case
07:17:36 <ski> also, instead of e.g.
07:18:10 <ski>   mapM_ (\number -> do putStr "Number : "; print number) numbers
07:18:13 <ski> you can write
07:18:22 <ski>   forM_ numbers $ \number -> do
07:18:27 <ski>     putStr "Number : "
07:18:30 <ski>     print number
07:18:31 <roconnor> you can also use sequence to find optimal game play, proof Tychonoff's Theorem, and implement the double-negation shift.
07:18:36 <cheater> i find >> much more verbose than do
07:18:46 <roconnor> *prove
07:18:48 <polann> I was looking for something like forM_, nice
07:18:57 <cheater> forM_ is cool
07:18:59 <ski> @src forM_
07:18:59 <lambdabot> forM_ = flip mapM_
07:19:03 <ski> @src forM
07:19:04 <lambdabot> forM = flip mapM
07:19:44 * Eduard_Munteanu wishes runState et al were flipped as well :/
07:19:48 <polann> I frequently write \x -> read x :: Int is there an easier way without a lambda?
07:19:57 <ski> roconnor : you might want to elaborate on those ? :)
07:20:22 <Eduard_Munteanu> @type read
07:20:22 <ski> polann : well, you *could* do `(read :: String -> Int)'
07:20:22 <lambdabot> forall a. (Read a) => String -> a
07:20:37 <Eduard_Munteanu> @type read :: String -> Int
07:20:38 <lambdabot> String -> Int
07:20:39 <ski> polann : can you give an example of a context where you'd use this ?
07:20:59 <Eduard_Munteanu> You may also fix the type somewhere else.
07:21:25 <roconnor> @go What do Sequential Games, the Tychonoff Theorem and the Double-Negation Shift have in Common?
07:21:25 <lambdabot> Maybe you meant: google googleit do
07:21:28 <polann> let [a,b] = map (\x -> read x :: Int) $ words line
07:21:29 <roconnor> @google What do Sequential Games, the Tychonoff Theorem and the Double-Negation Shift have in Common?
07:21:31 <lambdabot> http://lambda-the-ultimate.org/node/4037
07:21:31 <lambdabot> Title: What Sequential Games, the Tychonoff Theorem and the Double-Negation Shift have  ...
07:21:37 <ski> roconnor : ty
07:22:17 <polann> where line is something like "2 3"
07:22:26 <roconnor> (answer, they are all instances of sequence)
07:22:41 <Eduard_Munteanu> Hm, I might have some fun with Agda, regarding that.
07:22:50 <ski> polann : i might write `let [a,b] = map read (words line) :: [Int]'
07:22:53 <Eduard_Munteanu> Ah, they already provide Agda programs :)
07:23:24 <polann> that's much cleaner
07:24:27 <dmwit_> [read x :: Int | x <- words line] -- also a possibility, but less general
07:24:39 <Eduard_Munteanu> polann: if the function that does that isn't polymorphic you might only need the toplevel signature
07:24:51 * ski pondered suggesting that, but decided against it, on grounds of being too verbose in this cas
07:24:54 <ski> e
07:25:26 <polann> Eduard_Munteanu: I'm not sure what you mean, this is inside a do block
07:25:49 <ski> it being inside a `do'-block shouldn't matter here
07:26:09 <elliott> Whenever I run "cabal sdist", I get "cabal: dist/src/sdist.-[random]/[pkgname]-[pkgversion]: does not exist". I'm running cabal-install 0.10.2 on GHC 7.2.1. "runhaskell Setup.hs sdist" works fine. Is this a known issue and is there a workaround?
07:26:19 <Eduard_Munteanu> Yeah, it only matters if something somewhere asks for a specific type.
07:26:31 <polann> yup, works without it
07:27:07 <polann> why aren't 'lets' allowed to have an 'in' inside do blocks?
07:27:12 <dmwit> They are.
07:27:22 <c_wraith> they're just not required to
07:27:24 <dmwit> elliott: I've never heard of it.
07:27:24 <cheater> hey guys what does this mean? {-# INLINE simpleHttpServe #-}
07:27:47 <dmwit> cheater: When GHC encounters calls to simpleHttpServe, it will replace them with the definition of the function instead.
07:27:56 <ski> it's a pragma, a hint that you want `simpleHttpServe' to be inlined
07:27:57 <Twey> cheater: It means the function should be inlined: not treated as a separate function at all, but simply replaced with its contents wherever it appears
07:27:58 <elliott> dmwit: That's a shame. Giving -v doesn't seem to produce any useful info; it copies everything to dist/src/sdist.-[random] then gives that error.
07:27:59 <KirinDave> Hum, come to think of it...
07:28:00 <cheater> is this standard?
07:28:02 <elliott> (-v -v gives the same info.)
07:28:22 <dmwit> cheater: No, it's not in any Haskell standard.
07:28:24 <ski> cheater : no
07:28:32 <wolverian>  
07:28:35 <dmwit> (Though it's almost certainly documented in the GHC manual.)
07:28:37 <cheater> is this something ghc does without extensions?
07:28:54 <dmwit> Yes.
07:28:58 <cheater> thanks
07:29:01 <ski> this is a GHC extension (maybe some other compiler implements it as well, i dunno)
07:29:03 <cheater> why is inlining important?
07:29:07 <KirinDave> There are many cases I've come across where you have to specify the type you are expecting and a bunch of magic happens to give you that type.
07:29:07 <dmwit> GHC can often figure out when to do inlining even without such hints.
07:29:12 <dmwit> Inlining is an optimization.
07:29:16 <cheater> does it save a jmp/longjmp or something?
07:29:24 <dmwit> Something like that, yes.
07:29:33 <KirinDave> It can be more significant in haskell, right?
07:29:44 <elliott> Inlining lets you reduce the inlined expression further.
07:30:03 <KirinDave> Anyways, what does code that can respond to the expected type look like?
07:30:05 <elliott> Because the code doesn't have to have an "abstract" argument, it might have a defined or at least more defined value.
07:30:09 <elliott> A "case" could be eliminated, for instance.
07:30:14 <ski> cheater : inlining might make the compiler realize it can perform a whole bunch of other improvements, so it might cascade -- that would probably be the main point of doing that, rather than the small gain in just inlining `simpleHttpServe' itself
07:30:22 <elliott> Because "f (A ...)" becomes "case A ... of A ... -> etc; ..." becomes "etc".
07:30:26 <cheater> ski: aha
07:30:32 <elliott> That won't happen if "f" isn't inlined.
07:31:05 <cheater> ski: what prevents ghc from trying to inline everything everywhere?
07:31:10 <Eduard_Munteanu> cheater: it also saves argument passing / register saving, at least in other languages
07:31:14 <dmwit> KirinDave: It looks like some class-polymorphic function calls.
07:31:27 <ski> cheater : it would be inefficient, i.e. take too long time to compile
07:31:32 <KirinDave> dmwit: Ah… would that be a use for a type family?
07:31:37 <Eduard_Munteanu> You don't need to go through a call sequence.
07:31:41 <cheater> ski: oh
07:31:47 <elliott> ski: And produce huge executables.
07:31:47 <dmwit> KirinDave: I'm not sure the two things are related.
07:31:57 <ski> elliott : yeah, that too
07:32:04 <Eduard_Munteanu> And some functions *cannot* be inlined.
07:32:09 <elliott> But GHC does try to "inline everywhere".
07:32:11 <dmwit> KirinDave: Classes give you a way to write many pieces of code with the same name, but different types.
07:32:13 <elliott> I mean, the inliner is very aggressive.
07:32:19 <ski> elliott : itym s/cannot/shouldn't/
07:32:27 <cheater> ski: i realize the complexity given that a single level of inlining could give you a bigger executable, but two levels would simplify greatly
07:32:30 <elliott> ski: ITYM Eduard_Munteanu.
07:32:31 <dmwit> KirinDave: No need for anything fancier than that to get code that "responds to" its expected type.
07:32:34 <cheater> so i understand it's a bit of a problem
07:32:36 <KirinDave> dmwit: Right, but I am am offering back one of several types.
07:32:37 <elliott> ski: And I think you're wrong, you cannot inline a fully recursive function.
07:32:42 <elliott> That could fail to terminate.
07:32:55 <KirinDave> dmwit: I've got a redis client I am using where I can say :: String or :: Int and it actually does that for me on gets.
07:33:11 <KirinDave> dmwit: (although this is probably unwise, it is useful)
07:33:19 <dmwit> Sure.
07:33:33 <dmwit> No need for type families there.
07:33:35 <elliott> Doesn't sound unwise to me.
07:33:40 <Eduard_Munteanu> Yeah, I'm hinting at other languages there... of course if you do LTO or stuff like cross-module optimizations you might never need to go through standalone definitions.
07:33:48 <ski> elliott : you can always replace `f x = ..x..f..' with `f = let g x = ..x..g.. in f' just prior to inlining `f'
07:33:49 <elliott> I mean, unless you're going to go all the way and make a strongly-typed binding where you have to specify schemas at compile time.
07:33:58 <ski> s/in f/in g/
07:34:01 <elliott> ski: yeah, and then you have to inline g
07:34:07 <elliott> because you're inlining _everything_
07:34:51 <ski> elliott : ah, you meant in that way -- yes, then you're right that you can't fully inline recursive stuff getting statically unknown inputs
07:35:03 <dmwit> KirinDave: Here's a first approximation to the truth. H98 type classes are sets of types. GHC type classes are relations between types (sometimes one-place relations, i.e. sets). Type families are functions between types.
07:35:13 <elliott> dmwit: Aha, I know why that cabal-install error happens: "Setup.hs sdist" copies everything to dist/src/sdist.-[random]/[pkgname]-[pkgversion]/..., but "cabal sdist" just copies to dist/src/sdist.-[random], but still tries to use the subdirectory (presumably because it reuses code).
07:35:25 <Eduard_Munteanu> ski: I think you can simulate a stack some other way, no?
07:35:27 <elliott> Weird bug to introduce... I could see it happening first code time round
07:35:33 <Athas> How do I do conditional compilation based on GHC version within a Haskell file?
07:35:34 <Eduard_Munteanu> Not much of a difference, though.
07:35:42 <elliott> ski: Well, no, I'm assuming it's what cheater meant. I could be wrong.
07:35:42 <ski> elliott : "ITYM" - yeah, sorry
07:36:20 <ski> Eduard_Munteanu : "And some functions *cannot* be inlined." -- see what i mistakenly said to elliott above
07:36:41 <KirinDave> dmwit: Okay so you return a value who's type has an implementation for a typeclass.
07:36:48 <elliott> it'd be fun to make GHC inline absolutely everything non-recursive
07:36:48 <KirinDave> dmwit: a -> IO MyTypeClass
07:36:57 <elliott> small programs might get smaller but then try it on GHC itself :-)
07:37:10 <cheater> isn't it easy to inline a recursive function by just extending the type of the function calling that recursive funciton
07:37:21 <KirinDave> dmwit: What sort of function exists to take the incoming string and make it MyTypeClass based off of the preferred type?
07:37:28 <cheater> with an argument of type Maybe RecursiveFunctionType
07:37:39 <elliott> KirinDave: Is MyTypeClass a type class here?
07:37:43 <elliott> If so, that signature is invalid.
07:37:56 <dmwit> KirinDave: MyTypeClass a => IO a -- a much more likely signature
07:38:05 <KirinDave> dmwit: Okay...
07:38:09 <dmwit> :t readLn
07:38:10 <lambdabot> forall a. (Read a) => IO a
07:38:12 <dmwit> for example
07:38:25 <dmwit> That action has a different implementation for each type that you plug in for 'a'.
07:38:27 <elliott> KirinDave: Basically, either you put (String -> Maybe a) into the typeclass,
07:38:32 <elliott> KirinDave: Or you write it yourself using existing typeclass methods.
07:38:36 <KirinDave> Oohhh
07:38:44 <KirinDave> The function itself?
07:38:49 <elliott> readLn is just:
07:38:51 <elliott> ?src readLn
07:38:51 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
07:38:51 <KirinDave> The haskell compiler can supply that?
07:38:54 <KirinDave> that's slick.
07:38:56 <elliott> ?src readIO
07:38:56 <lambdabot> Source not found. Do you think like you type?
07:38:58 <elliott> Gah.
07:39:06 <elliott> readIO just calls reads which is part of the Read class.
07:39:07 <elliott> KirinDave: Huh?
07:39:09 <ski>   readLn = readIO =<< getLine
07:39:20 <dmwit> Yeah, I'm not sure I understand KirinDave's question(s) any more.
07:39:21 <elliott> KirinDave: I think you have misinterpreted me.
07:39:23 * hackagebot libcspm 0.1.1 - A library providing a parser, type checker and evaluator for CSPM.  http://hackage.haskell.org/package/libcspm-0.1.1 (ThomasGibsonRobinson)
07:39:24 <KirinDave> elliott: Maybe I misunderstood then?
07:39:32 <elliott> KirinDave: What did you think I meant?
07:39:43 <KirinDave> elliott: I guess nevermind that, it's obviously wrong
07:39:53 <ski> (*what* is obviously wrong ?)
07:40:07 <KirinDave> I'm just trying to understand the shape of the code that allows for things like Redis.get db "keyval" :: IO String
07:40:10 <elliott> KirinDave: I want to know what you think so I understand how you're not understanding me :)
07:40:32 <KirinDave> Vs Redis.get db "keybal2" :: IO Int
07:40:48 <ski> @src Read
07:40:48 <elliott> KirinDave: It might look something like this:
07:40:48 <lambdabot> class Read a where
07:40:49 <lambdabot>   readsPrec    :: Int -> ReadS a
07:40:49 <lambdabot>   readList     :: ReadS [a]
07:40:49 <lambdabot>   readPrec     :: ReadPrec a
07:40:49 <lambdabot>   readListPrec :: ReadPrec [a]
07:40:50 <elliott> class RedisType a where parse :: RedisResponse -> Maybe a
07:40:50 <elliott> get db kv = do { resp <- getResponse db kv; case parse resp of Just a -> return a; Nothing -> error "oh no" }
07:40:56 <elliott> With instances of RedisType for String, Int, etc.
07:41:12 <KirinDave> Ah...
07:41:21 <KirinDave> Interesting
07:41:22 * ski can't recall seeing `ReadPrec' before
07:41:25 <elliott> Then get :: (RedisType a) => DB -> String -> IO a
07:41:56 <ski> @src Show
07:41:57 <KirinDave> Scala has effed up my head in that I always sort of read things left-to-right, but I guess that is not a necessary thing in Haskell.
07:41:57 <lambdabot> class  Show a  where
07:41:57 <lambdabot>     showsPrec :: Int -> a -> ShowS
07:41:57 <lambdabot>     show      :: a   -> String
07:41:57 <lambdabot>     showList  :: [a] -> ShowS
07:42:10 <ski> apparently no corresponding `ShowPrec' :/
07:42:14 <ski> @index ReadPrec
07:42:15 <lambdabot> Text.ParserCombinators.ReadPrec, Text.Read
07:42:18 <ski> @index ShowPrec
07:42:18 <lambdabot> bzzt
07:42:48 <elliott> KirinDave: What's not left-to-right about that?
07:44:50 <KirinDave> elliott: Well in the final expression, you actually specify what type specifically you want.
07:45:07 <elliott> KirinDave: I'm pretty sure Scala has overloading.
07:45:12 <KirinDave> elliott: It does.
07:45:30 <elliott> Maybe not overloading of types that don't happen to occur in the argument types?
07:45:36 <KirinDave> Yeah
07:45:46 <KirinDave> I'm pretty sure you can't overload on return type in scala, or java.
07:45:53 <ski> Ada has overloading on result types, as well
07:46:04 <elliott> Well, I know you can't in Java. But Scala's type system is pretty flexible as I understand it.
07:46:44 <ski> (and if it's ambiguous in Ada, then the implementation is required to give an ambiguity error (as opposed to C++))
07:46:46 <EvanR-work> im pretty sure im pretty sure
07:47:01 <elliott> hello EvanR-work
07:47:10 <KirinDave> elliott: Before you say that, go look at scalaz. :)
07:47:17 <elliott> ski: wait, what does C++ do? just pick one?
07:47:33 * ski is pretty sure EvanR-work is not pretty sure EvanR-work is pretty sure EvanR-work is pretty sure
07:47:38 <ski> elliott : i think so, yes
07:47:45 <KirinDave> elliott: It's pretty entertaining, for example, to see the familair applicative functor chaining run in reverse to satisfy the type system.
07:47:48 <elliott> ski: at random? :)
07:47:57 <ski> iirc, yes :)
07:48:01 <elliott> KirinDave: lol
07:48:14 <elliott> ski: sweet, I'll make a g++ patch that literally uses random() to pick
07:48:18 <EvanR-work> c++0x formalized the requirement of the RNG which chooses in implementations
07:48:18 <KirinDave> It's one of the reasons I cannot cotton to scalaz.
07:48:21 <ski> ("it's your own fault if it matters which one the compiler chooses", or something ..)
07:48:40 <KirinDave> elliott: Examples: https://github.com/scalaz/scalaz/blob/master/example/src/main/scala/scalaz/example/ExampleApplicative.scala
07:48:43 <hpaste_> applicative pasted “#if __GLASGOW_HASKELL__ < 610” at http://hpaste.org/52085
07:48:56 <applicative> Athas, like this? ^^^
07:48:58 <EvanR-work> its your own fault is the warcry of the assembly language
07:49:09 <Athas> applicative: yes, exactly.
07:49:15 <Apocalisp> KirinDave: That's to cater to Scala's type inferencer.
07:49:23 * hackagebot cspmchecker 0.1.1 - A command line type checker for CSPM files.  http://hackage.haskell.org/package/cspmchecker-0.1.1 (ThomasGibsonRobinson)
07:49:23 <KirinDave> Apocalisp: I am aware.
07:49:27 <elliott> Apocalisp: That's what he was saying
07:49:43 <applicative> Athas, what's the difficulty? (Not that I'm likely to know how to resolve it?)
07:49:45 <elliott> applicative: weird conditional
07:49:56 <KirinDave> Apocalisp: I'd be more down with this sort of code if the scala compiler gets better about explaining what happens when it goes wrong.
07:50:10 <Apocalisp> Scala infers types generally from right to left. Inference in Scala is undecidable in general, but it could be much better.
07:50:22 <applicative> elliott: yes, thats the point, its just the use of the CPP for this
07:50:28 <elliott> applicative: ah :)
07:50:38 <KirinDave> Apocalisp: Every time I try to use scala, a mistake often results in very difficult error messages.
07:50:49 <KirinDave> Apocalisp: Err, scalaz
07:50:59 <elliott> wow, scala has worse error messages than ghc?
07:51:02 <elliott> Impressive
07:51:05 <Twey> Heh
07:51:16 <KirinDave> elliott: Coming to haskell from scala, I was shocked at how good the ghc messages are.
07:51:17 <Apocalisp> elliott: Sometimes yes, much worse. Sometimes no.
07:51:22 <Athas> applicative: I had not found it in the GHC docs at the time I asked.
07:51:22 <EvanR-work> c++ error messages are impressive
07:51:26 <Twey> GHC's are reasonably clear so long as you're not doing anything too complicated
07:51:32 <Athas> I still haven't, in a way, I just happened to follow some lucky hyperlinks.
07:51:33 <Twey> IMAO
07:51:41 <KirinDave> elliott: The only time I rage at ghc is when I am writing iteratees and there is an error in the inevitable where statement.
07:51:52 <Athas> GHC error messages are C++-ish when you use quasiquotation.
07:51:57 <KirinDave> Errors in big complicated where statements are nightmares on stilts.
07:51:59 <Twey> Yeah
07:52:00 <OLiverr> hello again, I ve again a rather technical problem: my haskell program uses a speciefic (haskell) library and when I call one function of this library he program just freezes on a Windows 7 (64 bit) whereas on a Windows XP 32 bit it just runs fine, so are there maybe some 32/64bit complications (im using ghc without any special compiling parameters)
07:52:06 <Athas> There's nothing quite like getting unsugared parse trees thrown at you.
07:52:17 <elliott> Twey: I would agree if not for the recent proliferation of ~s.
07:52:19 <KirinDave> Athas: yeah well, this is better than the lisp way. Get an error in a macro?
07:52:24 <EvanR-work> KirinDave: you can just add types to the definitions in the where
07:52:24 <KirinDave> Athas: COMPILER FAILS.
07:52:27 <elliott> Twey: But really, GHC's are overly long even when they're clear :)
07:52:29 <Apocalisp> Scala 2.10's typer is getting an interactive debugger, so that should be nice.
07:52:30 <Twey> True
07:52:52 <applicative> Athas, oh I see. I was just looking around for unanswered questions, when I got on.
07:52:52 <KirinDave> EvanR-work:  Sometimes this is awkward. I'd give an example but dog requires walk.
07:53:05 <applicative> Athas, I was too late!
07:53:22 <ski> (famous last words ..)
07:53:43 <Athas> KirinDave: I programmed Common Lisp for many years, and you can write macros that deal extremely well with errors.
07:53:55 <Athas> And even if you don't, you can just look at the expanded code...
07:54:10 <Athas> I've little experience with Template Haskell, but it's probably similar.
07:54:25 <EvanR-work> runtime errors suck
07:54:28 <EvanR-work> a lot
07:54:30 <ski> Athas : you mean the errors can often refer back to the unexpanded code instead of the expanded one ? that's cool :)
07:54:30 <c_wraith> you should never look at expanded template haskell, if you value sanity. :)
07:55:15 <elliott> c_wraith: Sometimes you just can't avoid -ddump-splices :P
07:55:28 <elliott> ski: that basically just involves using an AST representation that includes source location, doesn't it?
07:55:43 <elliott> and "inheriting" it as much as you can when generating a macro expansion
07:55:57 <elliott> I guess it couldn't be a list then though
07:56:03 <ski> elliott : well, that would take care of some cases, not all though, i think
07:56:43 <EvanR-work> templating is immoral
07:56:50 <c_wraith> You know what'd be *really* awesome for debugging type errors?  If GHC had a mode that would cause it to spit out type signatures for every expression (yes, this would be *huge* for a large source file), as they were inferred.  This would allow tools to be written that would display type errors and let you examine the types of expressions surrounding the type error.
07:57:02 <ski> (well, the AST's that staged programming (such as macros) access shouldn't be plain sexps in any case, imnsho)
07:57:11 <c_wraith> ...  now comes the point where someone tells me GHC already has that, and I feel dumb
07:57:41 <Twey> ski: Why?
07:57:48 <KirinDave> Athas: Check out how Clojure does it.
07:58:05 <KirinDave> Athas: Unless it changed in 1.3, it just says "Compiler exception. Bzzt"
07:58:10 <KirinDave> It's difficult to even get a stack trace
07:58:11 <ski> Twey : hygiene
07:58:11 <Twey> Haha
07:58:15 <elliott> EvanR-work: I wish I could eliminate TH from my current code, that's for sure :P
07:58:17 <Twey> ski: Oh, right
07:58:36 <ski> c_wraith : you know what you be really useful ? -- if GHC implemented type error slicing !
07:58:50 <EvanR-work> c_wraith: every expression and subexpression?
07:58:51 <elliott> ski: I like the idea of an fexpr model where you can't actually pick apart the individual arguments given to you
07:59:01 <c_wraith> EvanR-work: yes.  It'd be a *lot* of output.
07:59:03 <EvanR-work> 2 + 2
07:59:14 <EvanR-work> :t 2
07:59:14 <lambdabot> forall t. (Num t) => t
07:59:16 <EvanR-work> :t (+)
07:59:17 <lambdabot> forall a. (Num a) => a -> a -> a
07:59:18 <EvanR-work> heh
07:59:20 <ski> elliott : what has that got to do with FEXPRs ?
07:59:43 <elliott> ski: well, nothing directly, but in total that seems to be the cleanest macro model to me
08:00:06 <elliott> I think it'd allow fexprs to be optimised almost as much as macros are inherently (i.e. "run at compile time")
08:00:38 <elliott> it also makes them hygienic, like anything that looks like a lambda should be :p
08:00:45 <cheater> hey guys, what does OverloadedStrings do?
08:00:55 <ski> i think FEXPRs are a horrible mistake
08:01:04 <EvanR-work> cheater: makes string litearls polymorphic like numbers
08:01:06 <ski> @hoogle fromString
08:01:06 <lambdabot> Data.String fromString :: IsString a => String -> a
08:01:21 <cheater> evanR in what way?
08:01:22 <elliott> ski: they /were/ a horrible mistake, but their problems were caused mainly by dynamic scoping
08:01:22 <ski> cheater : replaces any string literal `"foo"' with `fromString "foo"'
08:01:28 <aristid> ski: what are FEXPRs?
08:01:29 <cheater> huh funny
08:01:30 <elliott> ski: have you seen the Kernel language?
08:01:31 <EvanR-work> cheater: so you can type ByteStrings and Textx
08:01:32 <cheater> why would you do that ski?
08:01:44 <cheater> ah
08:01:44 <applicative> cheater, you can use 'string literals' to denote Text or whatever, if you make an 'IsString' instance
08:01:44 <cheater> interesting
08:02:08 <cheater> do i have to make the instance or is that bundled with Text already?
08:02:56 <applicative> there's one in Text, for each type if I remember
08:03:29 <ski> elliott : i haven't seen the Kernel language -- but i think that if you remove the inspection part, it's not FEXPRs (at least in any traditional sense)
08:04:33 <applicative> cheater, yes, there's one in Data.Text for strict Text and another in Data.Text.Lazy
08:04:49 <elliott> ski: Kernel doesn't -- I strongly suggest looking at Kernel (http://lambda-the-ultimate.org/node/1680, http://lambda-the-ultimate.org/node/4093, http://web.cs.wpi.edu/~jshutt/kernel.html), I think it might make you think better of fexprs :)
08:05:10 <ski> aristid : FEXPRs means that if you call a function `foo' (which you might have got as an argument earlier, e.g.) like `(foo (lambda (x) ..x..))', then `foo' is allowed to inspect the *expression* `(lambda (x) ..x..)', interpreting it in any way it wants, and so you can't rely on `lambda' meaning that it means in the current scope
08:05:41 <elliott> ski: notably, kernel builds "lambda" on top of $vau (its fexpr primitive) and wrap (which can be implemented in terms of $vau and eval (which can be implemented in terms of $vau and wrap... etc. :)))...
08:05:50 <ski> aristid : note that `foo' here is not a macro, but can be a run-time value
08:05:57 <aristid> ski: which language is that? common lisp?
08:06:00 <elliott> (and it's very "clean" and Scheme-ish)
08:06:04 <elliott> aristid: pre-common lisp
08:06:12 <dmwit> c_wraith: Type inference doesn't work that way...
08:06:30 <cheater> applicative: i don't actually need to do anything to use it, right?
08:07:00 <ski> aristid : it's supposed to be Scheme (there are some Schemers who still think FEXPRs are a good idea), but the same thing would "work" in some CL variant as well, i think
08:07:01 <applicative> yes, you need the {-#LANGUAGE OverloadedStrings #-} pragma.
08:07:02 <aristid> ski: so it's bad and they killed it. sounds like a non-problem?
08:07:10 <elliott> all language extensions must be turned on
08:07:18 <aristid> ski: r5rs does not have fexprs IIRC
08:07:22 <ski> indeed
08:07:29 <elliott> aristid: my contention (and that of Kernel's author) is that it is not essentially bad
08:07:29 <cheater> @hoogle writeText
08:07:29 <lambdabot> No results found
08:07:31 <elliott> so there's your problem :)
08:07:40 <applicative> then if you import Data.Text.Lazy, "Hello World" will be of type IsString a => a, not of type String
08:08:00 <hpaste_> k annotated “A play in one act” with “A play in one act (annotation)” at http://hpaste.org/51474#a52086
08:08:04 <ski> some people have argued for inclusion in standard or at least not explicitly disallowing or making it hard to implement, though
08:08:04 <applicative> cheater, so it's like 1 2 3 4, as we usually have them, with the familiar possibilities of mishap
08:08:19 <elliott> ski: apart from all the benefits the Kernel author lists (and he states them better than I could), the fact that it eliminates the arbitrary compile/runtime distinction is a big plus for fexprs, imho... but this is off-topic :)
08:08:33 <aristid> ski: well, given how tedious r5rs macros are, i kinda can hear the siren song
08:08:47 <elliott> applicative: It'll be of type (IsString a) => a regardless of whether you import it or not.
08:08:51 <ski> elliott : ty for the links, will try to take a look at them later
08:08:56 <elliott> ski: :)
08:09:07 <Athas> KirinDave: Clojure isn't really what most people understand by Lisp, is it?
08:09:11 <Athas> If so, that's... sad.
08:09:33 <cheater> a
08:09:36 <aristid> Athas: you don't like clojure?
08:09:37 <applicative> elliot, if I have OverloadedStrings? or without it?
08:09:50 <applicative> elliott, rather
08:09:52 <cheater> applicative: what if i only want to use qualified imports or imports with the functions selected - what would i do then?
08:09:56 <elliott> applicative: with :)
08:10:10 <Athas> aristid: I have little experience with it, but it's a very young member of the Lisp family.
08:10:16 <elliott> cheater: class instances are imported regardless of what import style you use
08:10:23 <applicative> elliott: yeah, that's what I was thinking, I was just smashing points together
08:10:25 <elliott> (and there is no way to hide a class instance)
08:10:52 <ski> aristid : imo, the main argument against FEXPs (at least in the traditional form, i dunno what this Kernel does) is that they make it all but impossible to reason (for human and compiler alike) about code in a local, modular way
08:11:06 <elliott> ski: so do macros
08:11:07 <aristid> ski: sure, that is pretty obvious.
08:11:08 <ski> (also, in general it would be less efficient)
08:11:16 <elliott> that is not universally agreed on :)
08:11:20 <aristid> elliott: macros meanwhile are more obvious in some way
08:11:31 <ski> elliott : to a much lesser degree
08:12:19 <ski> if you know a macro allows some subform to be (any) expression, then you can insert an expression referring to any bindings you have in scope, and you know nothing strange will happen
08:12:46 <applicative> cheater, one confusing thing is that you also have to do :set -XOverloadedStrings inside ghci if you want to use it there
08:13:05 <ash__> On OS X, how would one use the llvm backend? Anytime I use -fllvm it gives me a Warning: -fllvm is incompatible with -fPIC and -dynamic on this platform
08:13:13 <yitz> OverloadedStrings is bad
08:13:21 <elliott> yitz: bad and useful
08:13:23 <cheater> applicative: interesting
08:13:27 <applicative> ash__ you can use it with the latest versions of ghc
08:13:29 <cheater> applicative: i've actually got a problem here
08:13:30 <ski> of course, for this to work, you have to have a kind of "type" of a macro in your head -- i.e. which kind of forms each subform must be (expression, pattern, definition, &c.), and also where variables are bound and which subforms they are in scope in
08:13:37 <yitz> elliott: yeah. but it could be changed to be good and useful
08:13:43 <elliott> yitz: what's wrong with it?
08:13:47 <yitz> if it ran at compile time instead of run time
08:13:47 <ash__> applicative: ghc 7.2? (I am using 7.0)
08:14:00 <elliott> yitz: well
08:14:04 <Athas> Um, my ghc -v says 'Glasgow Haskell Compiler, Version 7.2.1', but __GLASGOW_HASKELL is defined as 702 when compiling with -cpp.  What gives?
08:14:04 <elliott> yitz: I think Num should be fixed before IsString
08:14:05 <cheater> applicative: i'm trying to check out what functions there are in the Snap.Core module, but doing :l Snap.Core in ghci says it can't find the module.
08:14:12 <cheater> applicative: what am i doing wrong?
08:14:12 <Athas> Er, __GLASGOW_HASKELL__, of course.
08:14:17 <TotoTitus> can anyone tell me in what order are these evaluated ?
08:14:18 <TotoTitus>  (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
08:14:26 <applicative> ash__ I think that's right, I haven't been able to use it till recently.
08:14:28 <elliott> yitz: so it seems weird to specifically say "OverloadedStrings is bad" when fromInteger still exists :)
08:14:44 <elliott> :t (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
08:14:45 <lambdabot> forall a. (Fractional a) => [a]
08:14:56 <cheater> > (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
08:14:57 <lambdabot>   [8.0,10.0,2.5]
08:15:02 <Twey> yitz: Bad?  What *do* you mean?  It lets you do cool stuff like http://samuelhughes.com/isstring/rpn.html !
08:15:02 <yitz> elliott: there are IsString instances out there in the wild that can crash your program at run time depending on what characters you type in your string literals
08:15:05 <elliott> hmm, where did that $ come from
08:15:08 <cheater> TotoTitus: start adding parens until it makes sense.
08:15:15 <applicative> ash__ I installed a version of 7.2 a couple of months ago, but now there's a binary up if you don't mind installing the Platform libraries yourself
08:15:16 <cheater> :D
08:15:22 <byorgey> cheater: use +m +Snap.Core,  not :l
08:15:23 <elliott> Twey: oh no, you actually went out and did what i spent hours convincing somebody else not to do
08:15:29 <ski> TotoTitus : it is evaluated the same as `((\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2)) 5', if that's what you mean
08:15:30 <byorgey> cheater: I mean  :m +
08:15:32 <elliott> Twey: you have _hurt_ me
08:15:33 <TotoTitus> AFAIK, <$> and <*> are left- associative ?
08:15:34 <elliott> yitz: Num instances too
08:15:35 <Twey> elliott: Not mine
08:15:42 <cheater> byorgey: oh, uh, what's :l for then?
08:15:42 <Twey> But I think it's awesome, if horrific :þ
08:15:45 <elliott> Twey: I blame you for making me aware of it anyway
08:15:48 <Twey> Haha
08:15:51 <yitz> elliott: true but it's very rare for that to happen for Num instances
08:15:51 <ash__> applicative: I have been using brew install haskell-platform (cause I am lazy)
08:15:55 <cheater> last time someone told me to use :l and not :m !
08:15:56 <byorgey> cheater: loading modules from the current directory
08:15:59 <elliott> yitz: and IsString instances
08:16:03 <TotoTitus>  (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2)
08:16:05 <TotoTitus> only this
08:16:08 <yitz> elliott: but yes Num literals should also resolve at compile time
08:16:09 <ski> TotoTitus : and that in turn get's turned into `(\x y z -> [x,y,z]) ((+3) 5) ((*2) 4) ((/2) 5)' -- i think you can figure out the rest for yourself, yes ?
08:16:13 <cheater> byorgey: oh
08:16:13 <elliott> yitz: (-2 :: Nat) vs "\[some invalid unicode character]" :: String
08:16:23 <Twey> yitz: That's not really specific to OverloadedStrings… lots of things can crash your program at runtime depending on the contents of string literals
08:16:24 <TotoTitus> ski: no, the left part is what i can't figure out
08:16:28 <elliott> yitz: both are not likely scenarios, I would say the former is more likely
08:16:32 <Twey> > head "foo" -- fine
08:16:32 <byorgey> cheater: :l loads things from the current directory.  :m loads modules that have been installed via ghc-pkg
08:16:32 <lambdabot>   'f'
08:16:37 <Twey> > head "" -- oops
08:16:38 <lambdabot>   *Exception: Prelude.head: empty list
08:16:42 <ski> TotoTitus : yes, `<$>' and `<*>' are both left-associative
08:16:44 <yitz> Twey: no that's very different
08:16:50 <ski> TotoTitus : "the left part" being ?
08:16:50 <TotoTitus> ok, so this can be rewritten as :
08:16:51 <ash__> when is the next haskell-platform supposed to be released?
08:16:52 <applicative> ash__ that makes sense, the next platform version will be with -fllvm clearly. Now OSX has all the swanky features...
08:16:58 <elliott> Twey: well sure, but `main = return "abc"` being able to "crash" (I don't like the word crash here) is a bit counterintuitive
08:17:01 <yitz> Twey: it's not the string literal crashing, it's head.
08:17:03 <TotoTitus>  (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2)  <- this is the left part
08:17:06 <elliott> still, I think fromInteger failing is much more important + common than fromString
08:17:06 <cheater> :m + Snap.Core still does not find it
08:17:17 <cheater> even though!!!! i can compile programs that do import that
08:17:24 <ski> TotoTitus : ok, so what do you wonder about that part ?
08:17:27 <TotoTitus> ((((\x y z -> [x,y,z]) <$> (+3))  <*> (*2)) <*> (/2))  <- this is the left part
08:17:28 <Twey> yitz: True
08:17:34 <TotoTitus> are my parens corect ?
08:17:35 <yitz> elliott: yes i'm using crash as an alias for returns _|_ not necessarily an actual crash
08:17:52 <elliott> yitz: if it doesn't segfault... :p
08:17:53 <Twey> (though, as other people are saying, this applies to fromInteger too)
08:18:23 <TotoTitus> First, (+3) gets fmapped to x,y,z, then (*2) and (/2) get applicative'ed
08:18:30 <TotoTitus> to \x -> x,y,z
08:18:32 <yitz> elliott: i suppose it depends on the kinds of programs you usually see.
08:18:35 <applicative> ash__ I think there's no point asking for exact dates, but I notice the Platform libraries were all lined up when I installed the binary that's onthe ghc site, but they werent when i built it a couple months ago
08:18:37 <Twey> data MyType; instance Num MyType where fromInteger = error "Crash"
08:19:00 <applicative> ash__ so it looks like a lot of the work has been done.
08:19:08 <ski>      (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2)
08:19:12 <ski>   =  \n -> ((\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2)) n
08:19:14 <yitz> elliott: Nat is very theoretical to me, i've never used it or even seen it used in a production program
08:19:16 <ski>   =  \n -> ((\x y z -> [x,y,z]) <$> (+3) <*> (*2)) n ((/2) n)
08:19:19 <ski>   =  \n -> ((\x y z -> [x,y,z]) <$> (+3)) n ((*2) n) ((/2) n)
08:19:22 <ski>   =  \n -> (\x y z -> [x,y,z]) ((+3) n) ((*2) n) ((/2) n)
08:19:23 <ski>   =  \n -> (\x y z -> [x,y,z]) (n + 3) (n * 2) (n / 2)
08:19:29 <ski> TotoTitus : does that ^ help ?
08:19:31 <elliott> yitz: that's just a matter of culture.
08:19:35 <yitz> elliott: whereas i need to use IsString all the time in real life, and that really bothers me
08:19:39 <TotoTitus> processing
08:19:39 <elliott> yitz: you should love Nat, it avoids a whole variety of "crashes" :)
08:19:53 <elliott> (consider every function (e.g. list functions) which errors out on a negative input)
08:20:01 <yitz> elliott: i do use NonEmpty though :)
08:20:02 <ash__> applicative: just curious, not terribly concerned, I am still happy with the last version of haskell platform, just thought i'd ask incase someone in here is working on it currently
08:20:08 <ski> TotoTitus : "are my parens corect ?" -- yes
08:20:35 <elliott> yitz: can i interest you in agda? :p
08:20:40 <Twey> Hehe
08:20:53 <yitz> elliott: haha i'm just about ready
08:20:55 <ski>   =  \n -> [n + 3,n * 2,n / 2]    -- next step, i suppose
08:20:59 <TotoTitus> ski: thanks! i will take my tyme to fully understand this
08:21:19 <ski> TotoTitus : also take your type to understand it ;)
08:21:31 <elliott> tyme is a nice spelling
08:21:40 <TotoTitus> umm i was about to mispell 'time' into 'type'
08:21:46 <TotoTitus> you got me there
08:21:58 <ski> @all-dicts tyme
08:21:59 <lambdabot> No match for "tyme".
08:22:08 <yitz> elliott: seriously, no self-respecting language delays resolving its literals to run time. it's ridiculous for haskell to do that, while bragging about being so safe because of catching so much at compile time
08:22:20 <elliott> yitz: I'd never defend Num
08:22:35 <elliott> yitz: but it, eh, irks me to say things like "OverloadedStrings is bad" when Num is right there in the Prelude and used in every program :)
08:22:48 <ski> yitz : the resolving is done at compile-time .. the conversion might be done at run-time
08:23:50 <yitz> ski: i mean resolving to a concrete value that gets hard-compiled into your executable. that's what a literal is.
08:24:16 <yitz> ski: currently the only way to do that is with TH. (bringing us back to fexps...)
08:24:34 <elliott> I wouldn't suggest fexprs for a language like Haskell :p
08:24:48 <yitz> ski: or the ffi, where you put your literal into a .c file.
08:24:49 <ski> (TH does have nothing per se to do with FEXPRs, afacs)
08:25:12 <yitz> or macros or whatever
08:25:51 * ski . o O ( "FOCUS THEFT SHOULD BE A FELONY. !@*#^$@!*#^@%!*#@$^%!#*@!%" )
08:26:25 <elliott> yitz: I would prefer just some machinery for compile-time-evaluated functions than TH really
08:26:36 <elliott> Or, well
08:26:50 <elliott> I guess you need TH, since it involves allocating buffers and the like for ByteString and Text
08:26:57 <elliott> so you have to generate an expression tree
08:27:23 <elliott> ... you could just duplicate every fromString call at compile time and then `evaluate` it :P
08:28:43 <cheater> byorgey: any ideas now?
08:28:51 <cheater> the :m doesn't work either :(
08:30:03 <ski> maybe we ought to have a `class Lift a where liftE :: a -> Q Exp' ..
08:30:52 * ski . o O ( `$(liftE ("blah" :: Text))')
08:32:22 <byorgey> cheater: did you install snap-core via cabal?
08:32:29 <cheater> yes
08:32:51 <byorgey> cheater: and do you get an error when you type   :m +Snap.Core  ?
08:33:24 <c_wraith> byorgey: Snap.Core is the name of the module in 0.6.  Previously, it was Snap.Types (and that name is still in 0.6, just marked as deprecated)
08:33:36 <elliott> ski: I think we do have a lift class in TH
08:33:45 <elliott> ski: I think it's -> Q Lit not Exp though
08:33:50 <cheater> no just "not a module in the current program"
08:33:56 <cheater> c_wraith: AHHHHHhhh
08:34:00 <cheater> c_wraith: thanks a lot
08:34:05 <hpaste_> applicative pasted “OverloadedIO()” at http://hpaste.org/52089
08:34:47 <rostayob> well, type classes really are similar to prolog predicates
08:34:48 <elliott> applicative: that hurts
08:34:50 <c_wraith> applicative: why do you hate people? :)
08:34:50 <rostayob> kind of
08:35:07 <elliott> instance (Monad m, IsString a) => IsString (m a) where fromString = ...
08:35:19 * applicative pretends to be annoyed that he cant write:  main = "hello world"  with his brilliant instance IsString (IO()) instance ^^
08:35:46 <cheater> @hoogle toStrict
08:35:46 <lambdabot> Control.Monad.ST.Lazy lazyToStrictST :: ST s a -> ST s a
08:35:53 <cheater> nope
08:36:09 <cheater> why on earth is it so annoying to find functions in haskell
08:36:33 <applicative> elliott: I was just amused that I could get main = a ; a = "hello world" to compile but not main = "hello world"
08:36:45 <applicative> elliott: Its  a bug!
08:36:47 <elliott> applicative: huh, why didn't it work?
08:36:56 <ski> elliott : ok, nice
08:37:03 <elliott> applicative: I guess it's slightly ambiguous which instance is meant
08:37:07 <elliott> because main :: IO a for any a
08:37:14 <elliott> I bet it'd work if you added main :: IO ()
08:37:29 * ski kinda thinks `main' ought to be required to have type `IO ()'
08:38:15 <applicative> elliott, i'll be darned, your right.  I was thinking like ski, though I know it can be IO whatever
08:38:25 <EvanR-work> didnt know that
08:38:27 <elliott> ski: not "IO Void" or "forall a. IO a"? :p
08:38:28 <quicksilver> ski: I think it is, according to the standard.
08:38:37 <elliott> quicksilver: I don't think so.
08:38:38 <dmwit> IO Void would be damn annoying.
08:38:43 <quicksilver> ski: accepting IO a is a ghc silent extension.
08:38:47 <dmwit> So would forall a. IO a.
08:38:51 <c_wraith> all programs must end with "return undefined"
08:38:53 <elliott> dmwit: Well, "exitSuccess" isn't that bad.
08:38:57 <elliott> c_wraith: No.
08:39:03 <aristid> c_wraith: or exitCode 0
08:39:07 <elliott> quicksilver: A GHC silent /undocumented/ extension?
08:39:08 <applicative> quicksilver: my memory was it's IO x , for any old x
08:39:16 <elliott> aristid: Uglier than exitSuccess
08:39:29 <elliott> (I thought the intention was `return undefined` too but roconnor corrected me :P)
08:39:32 <aristid> elliott: it's the idea that counts!
08:39:40 <elliott> I think it would be OK as long as System.Exit was of course part of the Prelude
08:39:52 <elliott> but it does make programs less composable in a way
08:39:52 <applicative> quicksilver: Oh i see what you are saying, ignore my last remark
08:39:56 <aristid> i think IO () is still nicer
08:39:59 <elliott> like, you can't have forever :: ProgramType -> ProgramType
08:40:05 <elliott> because the "program" inside would have to exit
08:40:09 <tsousa> i am trying to solve problem3 on 99 haskell problems, but i am getting this error http://dpaste.com/626487/ (code and error in the paste)
08:40:16 <elliott> so IO actions that are "main" become essentially uncomposable in some way
08:40:34 <elliott> tsousa: you mean (x:_), not [x:_]
08:40:40 <ski> elliott : no, not `IO Void', or `forall a. IO a' or `IO (forall a. a)', that would generally require one to use a `killThread :: IO Void' operation (i did something like that in a monad which simulated cooperative multi-tasking, though)
08:40:44 <quicksilver> you're right, it's IO a.
08:40:50 <elliott> tsousa: but this function already exists
08:40:52 <quicksilver> well, IO tau.
08:40:57 <elliott> tsousa: (!!) although the first element is 0 not 1
08:41:02 <applicative> what about "main = putStrLn "hello" >> main" isn't that composition?
08:41:05 <ski> quicksilver : mhm
08:41:21 <elliott> applicative: sure, what's your point?
08:41:30 <elliott> I mean that you can't really use many combinators on actions that also work on main
08:41:37 <elliott> you can't transform "main = ..." into "main = forever ..."
08:41:46 <elliott> because the ... will exit
08:41:55 <elliott> I mean, you /can/ transform it into that but it won't do what you want
08:42:10 <quicksilver> in fact, it changed between haskell98 to haskell2010
08:42:14 <applicative> elliott, I grant that (>>) is not too thrilling a combinator
08:42:15 <tsousa> elliott, in the exercices it says to start on 1
08:42:16 <tsousa> thanks
08:42:17 <quicksilver> it used to be IO t and became IO tau
08:42:19 <quicksilver> ;)
08:42:22 <ski> elliott : that `forever :: ProgramType -> ProgramType' is a good point in favour of `IO ()' (or `IO a' for any specific `a') (as opposed to `IO Void')
08:42:26 <elliott> applicative: less composable, not completely uncomposable :P
08:42:30 <elliott> ski: Yes, that was what I was intending.
08:42:41 <elliott> ski: (I wish forever's first argument was of type IO (), too.)
08:43:06 <ski> elliott : with dialogue-based I/O, this exact problem existed
08:43:12 * applicative was in fact offended when he discovered that "main = putStrLn "hello" >> main" was valid. It's a menace
08:43:18 <elliott> applicative: why?
08:44:04 <ski> quicksilver : hm, what's the difference between `IO t' and `IO tau', there ?
08:44:12 <elliott> ski: "au"
08:44:20 <applicative> elliott, it's not important, it just offends against my theory that main = ... is really an imperative and thus uncomposable
08:45:13 <quicksilver> ski: it was a bad joke, sorry
08:45:15 <parcs> :t \[x:_] -> ()
08:45:15 <ski> elliott : agreed about `forever' as well as `sequence_' and `mapM_' .. a few `ignore :: IO a -> IO ()'s never hurt anybody :)
08:45:16 <lambdabot> forall t. [[t]] -> ()
08:45:32 * applicative thinks it should be forbidden, you should just mention a library, and name the item you want compiled on the command line....
08:45:46 <ski> quicksilver : heh (i still don't get it :)
08:45:57 <elliott> applicative: I don't get it
08:46:03 <elliott> foo = putStrLn "blah" >> foo works too
08:46:17 <elliott> here's how you name the library and item:
08:46:23 <elliott> module Main where { import Foo; main = foo }
08:46:25 <elliott> :-)
08:46:33 <ski> applicative : "imperative" doesn't have to be uncomposable (even though it often is not as much composable, yes)
08:46:38 <elliott> since you'll usually use the same item ghc works by abbreviating the selection into a single file :P
08:47:37 <TotoTitus> (\x y -> [x,y]) <*> (*3)  is this wrong ?
08:47:43 <applicative> imperatives are not composable any more than assertions are, this was proven by Frege in the 19th c.
08:47:47 <TotoTitus> i am trying to get the type of this, but my GHC is complaining
08:48:38 <applicative> is "Dont do A!" composed out of "Do A!" and something else?
08:49:37 <TotoTitus> (\x y -> [x,y]) <*> (*3) :: (Num t, Functor ((->) t)) => t -> [t]
08:49:42 <TotoTitus> i do not understand this typing
08:51:43 <dmwit> :t \x y -> map (3*) [x, y] -- you want this instead?
08:51:44 <lambdabot> forall t. (Num t) => t -> t -> [t]
08:51:53 <TotoTitus> no
08:52:30 <dmwit> Can you write the function you want in a more straightforward way?
08:52:39 <dmwit> Perhaps we can help you obfuscate it after that.
08:52:46 <TotoTitus> it is not something i want, i just want to understand whatever i wrote down there
08:52:56 <dmwit> ok
08:52:56 <elliott> applicative: imo the menace is to insist "main = ..." be an imperative and thus less composable
08:52:58 <dmwit> :t (<*>)
08:52:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:53:11 <elliott> applicative: it's like intentionally bringing haskell down to the level of languages without a first-class abstraction for imperative programs
08:53:32 <ski> @src (->) fmap
08:53:33 <lambdabot> fmap = (.)
08:53:52 <byorgey> so (*3) has type  Num a => a -> a
08:54:00 <ski> TotoTitus : you want to understand that ^ instance for `Functor (r ->)' (actually written `Functor ((->) r)')
08:54:02 <byorgey> so f must be  (->) a
08:54:17 <elliott> i think he obviously doesn't want this function guys
08:54:27 <elliott> <TotoTitus> ((((\x y z -> [x,y,z]) <$> (+3))  <*> (*2)) <*> (/2))  <- this is the left part
08:54:32 <elliott> that's the original example
08:54:32 <elliott> oh hmm
08:54:35 <ski> TotoTitus : if you know anything about monads and monad transformers yet, you might first want to look at `instance Functor (Reader r)'
08:54:39 <applicative> TotoTitus: If you import Control.Monad.Instances and Control.Applicative, then the signature is (\x y -> [x,y]) <*> (*3) :: Num t => t -> [t]
08:54:42 <elliott> that is the (->) applicative isn't it, i assumed list
08:54:44 <ski> @src Reader fmap
08:54:45 <lambdabot> Source not found. :(
08:54:46 <TotoTitus> No, i'm not getting into monads yet
08:55:05 <TotoTitus> until i understand this applicative soup thoroughly
08:55:16 <dmwit> TotoTitus: Okay. Here's one way to approach it.
08:55:19 <ski> TotoTitus : basically, `fmap foo f' is `\x -> foo (f x)'
08:55:33 <dmwit> TotoTitus: You can think of [a] as a container whose elements are 'a's, indexed by natural numbers. Yeah?
08:55:43 <TotoTitus> Yes
08:55:48 <dmwit> TotoTitus: Similarly for Array i a; it's a container whose elements are 'a's, indexed by 'i's.
08:55:56 <ski> TotoTitus : i.e. `foo <$> f' is `\x -> foo (f x)' .. also `f <*> g' is `\x -> (f x) (g x)'
08:56:04 <dmwit> TotoTitus: For (->) e a, it's a container whose elemenst are 'a's, indexed by 'e's.
08:56:13 <ski> (all this is for `Functor (r ->)' and `Applicative (r -)')
08:56:22 <dmwit> ...and (e -> a) is just another way to write ((->) e a).
08:56:28 <TotoTitus> Yeah, that's where i've been since last night
08:56:35 <TotoTitus> functions as applicative functors
08:56:41 <Athas> Um, my ghc -v says 'Glasgow Haskell Compiler, Version 7.2.1', but __GLASGOW_HASKELL__ is defined as 702 when compiling with -cpp.  What gives?  Is my GHC setup borked or is this somehow correct?
08:56:42 <dmwit> Now, take a look at the type of (<*>).
08:56:44 <TotoTitus> don't worry...i understood most of it
08:56:45 <dmwit> :t (<*>)
08:56:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:56:52 <TotoTitus> there are only some few loose ends left
08:56:56 <dmwit> Fill in the 'f' bits with 'e ->':
08:57:07 <applicative> TotoTitus, do you see how the fmap definition for e.g. String -> a would go?
08:57:08 <dmwit> (<*>) :: (e -> a -> b) -> (e -> a) -> (e -> b)
08:57:27 <dmwit> Just from the type, the implementation is pretty clear. But can we make sense of it at a higher level?
08:57:50 <TotoTitus> go on
08:57:52 <dmwit> (<*>) takes an e-indexed container with functions inside, and an e-indexed container with arguments for that function.
08:58:07 <int-e> Athas: 6.12.3 defined it as 612.
08:58:09 <dmwit> And then it just applies the functions to their arguments at each index.
08:58:20 <dmwit> To give back an e-indexed container with results.
08:58:21 <TotoTitus> dmwit: been there, done that
08:58:27 <dmwit> sure
08:58:29 <int-e> Athas: so it's meant to be that way
08:58:32 <TotoTitus> i also understand how it works for functions, i can provide an explanation
08:58:45 * applicative applauds excellent exposition
08:58:45 <dmwit> Okay, then going a bit further:
08:58:48 <TotoTitus> But there are some few loose ends
08:58:51 <dmwit> (\x y -> [x, y]) <*> (*3)
08:58:53 <TotoTitus> which translate to odd code samples
08:58:56 <TotoTitus> Yes, yes, there:
08:59:07 <EvanR-work> thats the container view of Functor
08:59:11 <EvanR-work> er Applicative
08:59:23 <Athas> int-e: oh.  Uh.  Alright then.
08:59:26 <dmwit> Now, (\x y -> [x, y]) is an a-indexed container whose elements are *functions* that put the index and the argument together in a list.
08:59:29 <TotoTitus> I think it would be best to explain what i expected that code to do
08:59:51 <dmwit> And (*3) is a number-indexed container whose elements are triple the index.
08:59:54 <TotoTitus> (sorry, i am not interrupting, i am merely helping you to help me)
08:59:56 <byorgey> \x y -> [x,y] :: a -> (a -> [a]
09:00:01 <elliott> Athas: two decimal digits are used for the minor, in other words
09:00:05 <elliott> big-endian
09:00:17 <TotoTitus> (\x y -> [x, y]) <*> (*3) $ 2
09:00:22 <TotoTitus> i expected this to return:
09:00:24 <dmwit> So, (\x y -> [x, y]) <*> (*3) should zip those together, making lists of indices together with triple their value.
09:00:27 <TotoTitus> [2, 6]
09:00:32 <dmwit> Oh, it doesn't?
09:00:37 <TotoTitus> no
09:00:37 <byorgey> TotoTitus: that IS what it returns.
09:00:40 <TotoTitus> LOL
09:00:44 <dmwit> > (\x y -> [x, y]) <*> (*3) $ 2
09:00:45 <lambdabot>   [2,6]
09:00:46 <byorgey> > (\x y -> [x, y]) <*> (*3) $ 2
09:00:47 <lambdabot>   [2,6]
09:00:48 <Athas> elliott: yeah, it makes sense, I was just momentarily confused.
09:00:53 <dmwit> TotoTitus: That *is* what it returns. =)
09:00:53 <elliott> > (\x y -> [x, y]) <*> (*3) $ 2
09:00:54 <lambdabot>   [2,6]
09:00:57 <elliott> evaluation party
09:01:00 <elliott> Athas: :)
09:01:02 <TotoTitus> BUT my local GHC is crying
09:01:02 <byorgey> \o/
09:01:04 <TotoTitus> endlessly
09:01:08 <dmwit> TotoTitus: oh!
09:01:13 <dmwit> TotoTitus: :m + Control.Monad.Instances
09:01:14 <byorgey> TotoTitus: perhaps you need to import Control.Monad.Instances
09:01:14 <dmwit> =)
09:01:32 <byorgey> which defines the Functor and Monad instances for ((->) e)
09:01:39 <applicative> > map  ((\x y -> [x, y]) <*> (*3) ) [1..10]
09:01:40 <lambdabot>   [[1,3],[2,6],[3,9],[4,12],[5,15],[6,18],[7,21],[8,24],[9,27],[10,30]]
09:01:41 <dmwit> TotoTitus: The (->) e Functor isn't built-in.
09:02:04 <byorgey> hmm, no, just importing Control.Applicative is enough, actually
09:02:08 <TotoTitus> i had imported C.Applicative
09:02:11 <byorgey> TotoTitus: what error do you get from ghc?
09:02:42 <TotoTitus> <interactive>:1:17:
09:02:45 <deserteagle> svalko
09:02:49 <TotoTitus>  No instance for (Functor ((->) t0))
09:03:06 <TotoTitus> i imported Control.Monad.etc, it works now
09:03:06 <TotoTitus> thanks
09:03:17 <byorgey> TotoTitus: interesting, what version of ghc?
09:03:19 <dmwit> Perhaps an older version of Control.Applicative didn't import that instance.
09:03:22 <deserteagle> quit
09:03:25 <deserteagle> exit
09:03:31 <byorgey> yes, that's what I'm wondering
09:03:32 <deserteagle> help
09:03:40 <byorgey> deserteagle: try /quit
09:03:48 <byorgey> heh
09:04:05 <applicative> byorgey, yeah it works in 7.2
09:04:14 <byorgey> it works in 7.0.3 as well
09:04:23 <dmwit> "Are you bipolar?" "I'm bi-winning." Did Charlie Sheen really say that?
09:04:25 <applicative> not in 7.0.3
09:04:29 <c_wraith> dmwit: yes
09:04:36 <EvanR-work> loool
09:04:40 <applicative> byorgey, i'm baffled
09:04:50 <byorgey> applicative: it does for me in 7.0.3.
09:04:57 * ski . o O (  "Are you a bifunctor?" )
09:05:13 <byorgey> base-4.3.1.0
09:05:15 <applicative> maybe I installed the Platform libraries a day earlier :)
09:05:25 <applicative> no this isn't a platform library
09:05:37 <byorgey> applicative: what isn't?
09:06:06 <TotoTitus> byorgey: i don't know, how do i check the ghc version?
09:06:18 <byorgey> TotoTitus: at the command line type  ghc --version
09:06:30 <TotoTitus> i'm using Windows
09:06:47 <TotoTitus> what do i type in the ghc itself, rather than the terminal ?
09:06:52 <applicative> byorgey: Control.Applicative -- I was baffled, since I couldn't get ghci-7.0.3 to recognize the instance just by importing Control.Applicative, whereas you could
09:07:12 <dmwit> ghci should say its version right at the top after you open it.
09:07:21 <hjulle> Can hoogle search for instances for a class?
09:07:30 <TotoTitus> GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
09:07:34 <byorgey> applicative: Control.Applicative most certainly is a platform library.
09:07:35 <TotoTitus> 7.0.3
09:08:02 <TotoTitus> i'm also running WinGHCI
09:08:45 <applicative> byorgey, Oh I was thinking of it as 'built in'
09:09:05 <elliott> applicative: it's in base
09:09:07 <TotoTitus> yes ! i think i understand the functions as applicatives
09:09:39 <elliott> Is it just me or is hackage.haskell.org slow today?
09:09:43 <applicative> elliott: right, I was excluding things in 'base' from things in 'Platform' but there's no reason to do that
09:09:49 <cheater> what is a platform library?
09:09:57 <byorgey> cheater: a library included in the Haskell Platform
09:10:22 <cheater> ok
09:10:36 <cheater> i thought it meant like a library for windows, dos, unix, ...
09:10:50 <cheater> i don't suppose i can compile haskell for dos real mode can i?
09:11:31 <RaptorRarr> I don't think there are any existing compilers that do that.
09:11:36 <elliott> maybe jhc?
09:11:40 <elliott> ISTR its C is quite portable
09:11:41 <ski> TotoTitus : if you have functions like `Bool -> a', then you can think of them as sequences of exactly two `a' elements (one for `False', and one for `True')
09:11:57 <elliott> ski: and one for _|_
09:12:47 <TotoTitus> ski: uh, more exactly ?
09:12:49 <RaptorRarr> elliott: Ahh, good idea :)
09:13:10 <ski> TotoTitus : so this is similar to `data Two a = MkTwo a a' with `instance Functor Two where fmap f (MkTwo a0 a1) = MkTwo (f a0) (f a1)' as well as `instance Applicative Two where pure a = MkTwo a; MkTwo f0 f1 <*> MkTwo a0 a1 = MkTwo (f0 a0) (f1 a1)'
09:13:18 <elliott> RaptorRarr: seems like you can disable its boehm gc
09:13:21 <ski> elliott : yeah, but i was glossing over that :)
09:13:24 <elliott> hmm, the reliance on pointer tagging might be a problem
09:13:29 <elliott> but it seems to have an option to disable that too
09:13:54 <ski> TotoTitus : so a value `MkTwo a0 a1' would correspond to the function `\b -> case b of False -> a0; True -> a1'
09:14:21 <ski> TotoTitus : in this way you can think of a function of type `r -> a' as a sequence of `a' elements, indexed by `r' indices
09:14:57 <ski> TotoTitus : so then `fmap' in `instance Functor (r ->)' just "maps over this sequence"
09:15:25 <dmwit> ski: I went through the whole spiel, just to find out TotoTitus already understood it all and just wasn't importing the right modules. =)
09:15:49 <ski> dmwit : yeah, nothing like duplicated explanaitons :)
09:15:53 <tac-tics> can someone give me the layman's explanation of what unsafeInterleaveIO does?
09:16:06 <elliott> tac-tics: return . unsafePerformIO :-P
09:16:16 <tac-tics> elliott: that's pretty darn lay
09:16:33 <TotoTitus> This Haskell is actually making me think
09:16:34 <dmwit> unsafeInterleaveIO defers the actual input and output actions until they actual become required to determine their result.
09:16:48 <ski> tac-tics : operationally, `unsafeInterleaveIO act' is an action that when run will finish immediately, and when the resulting value is forced will actually run `act', and yield its value
09:16:51 <elliott> dmwit: (But they're all executed at once.)
09:16:53 <applicative> dmwit, ski, it's like the creeds repeated week after week in churches, it doesn't matter that we all 'know' it already....
09:17:01 <elliott> (So (unsafeInterleaveIO m) doesn't magically make m use lazy IO everywhere :-))
09:17:29 <dmwit> Good clarification.
09:17:55 <elliott> That would be a pretty fun operation, unsafeUseLazyIOEverywhere.
09:17:57 <EvanR-work> thou shall not unsafePerformIO
09:18:02 <ski> tac-tics : so `unsafeInterleaveIO act' means that the effects done by `act' aren't explicitly sequenced wrt other effects, but will be interleaved in some arbitrary way (compare to how multiple threads executing will also be interleaved in some arbitrary way)
09:18:10 <elliott> EvanR-work: ...except when useful and safe
09:18:20 <EvanR-work> which is never!
09:18:22 <EvanR-work> god said so
09:18:26 <ski> tac-tics : great ! :D
09:18:52 <dcoutts> and comparing unsafeInterleaveIO with unsafePerformIO, unsafeInterleaveIO just adds a bit of non-determinism while unsafePerformIO actually adds malevolent evil to your program
09:18:53 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:19:03 <ski> applicative : "it's like the creeds .." -- what is ?
09:19:19 <jsternberg> I have a question, how does ghc --make work? I'm more talking implementation details
09:19:39 <applicative> ski, repeating excellent accounts of instance Functor (r ->) when no one actually needs them :)
09:19:50 <jsternberg> I get that ghc can determine which modules get imported easily, but how does it determine if it has to compile a module or link to an already created library?
09:20:12 <tac-tics> ski: So usiIO readFile "a.txt" >>= \x -> usilIO readFile "b.txt" >>= \y -> print $ x == y
09:20:17 <dcoutts> jsternberg: local modules are always used in preference to package modules
09:20:22 <tac-tics> Would read both files "at the same time"
09:20:31 <elliott> tac-tics: No.
09:20:40 <elliott> tac-tics: It would read the two files sequentially but in some unspecified order.
09:20:45 <elliott> tac-tics: Also, readFile is a bad function to use here.
09:20:52 <elliott> It's already lazy IO (uses unsafeInterleaveIO internally).
09:20:59 <tac-tics> ah
09:21:01 <tac-tics> ok
09:21:03 <applicative> jsternberg: it also doesnt recompile if it doesn't think it has to.
09:21:05 <elliott> say B.useFile (from Data.ByteString) :P
09:21:08 <elliott> (which /is/ strict)
09:21:10 <elliott> erm, readFile not useFile
09:21:11 <jsternberg> when using a package module, how does it determine which library to link for that package module?
09:21:13 <ski> tac-tics : btw, note that `unsafeInterleaveIO' isn't really unsafe in the sense of circumverting the type system (possibly making the program crash or subtly yield wrong results / corrupt data) or in the sense of circumventing referential transparency -- (`unsafePerformIO' does both of those things, otoh)
09:21:25 <elliott> tac-tics: (Specifically, whichever string (==) forces first would have its file read first)
09:21:27 <dcoutts> jsternberg: using the package database managed by ghc-pkg
09:21:31 <dmwit> tac-tics: A better example is that (usilIO getLine >> usilIO getLine >>= print) would only ask for one line of input.
09:21:38 <jsternberg> ah
09:21:40 <elliott> ski: unsafeInterleaveIO definitely violates referential transparency.
09:21:47 <jsternberg> I thought that the package database manager was cabal, and was optional
09:21:49 <elliott> Or, well.
09:21:51 <elliott> It violates purity, at least.
09:21:59 <elliott> jsternberg: cabal is distributed with GHC; cabal-install isn't
09:22:03 <elliott> (cabal-install is the command-line tool)
09:22:08 <ski> elliott : no, you can explain it away by the `IO' in the result type
09:22:29 <applicative> jsternberg: ghc-pkg is independent of cabal, it's a ghc thing
09:22:31 <elliott> ski: that doesn't mean you should be able to construct a String which changes semantics depending on how long you take to traverse it
09:22:43 <dcoutts> ski: note that the view that unsafeInterleaveIO violates anything is controversial, and not universally agreed. e.g I don't think it violates purity (but it does add non-determinism to IO programs).
09:22:46 <elliott> ski: or an () that deletes a file or not depending on how long you take to force it
09:23:02 <jsternberg> so does ghc check ghc-pkg or cabal when determining what to link?
09:23:03 <ski> elliott : the differing results can be explained by different system state, just like how the scheduling that yields some interleaving of threads can be explained
09:23:06 <applicative> jsternberg: (by lower case cabal I mean cabal install)
09:23:14 <dmwit> elliott: You don't create an () that deletes a file or not depending on how long you take to force it. You create an IO ().
09:23:33 <elliott> dmwit: Yes, but the action doesn't happen with the typical IO sequencing.
09:23:35 <ski> elliott : maybe i should say "explained", though, since it doesn't explain very much -- but it does avoid making the code side-effectful
09:23:39 <dmwit> elliott: So?
09:23:49 <hjulle> Does anyone know if hoogle can search for instances for a class?
09:24:09 <dmwit> hjulle: Yes, I know. It can't.
09:24:19 <applicative> jsternberg, you can delete your cabal install executable and ghc --make will be the same
09:24:34 <elliott> dmwit: Well, "so?" purity is violated, because we can cause IO outside of IO.
09:24:46 <dmwit> hjulle: However, if you import some modules in ghci, :i ClassName will show what instances are in scope.
09:24:52 <dmwit> elliott: No, you can't.
09:25:00 <dmwit> elliott: You can cause IO inside of IO.
09:25:02 <dmwit> That's it.
09:25:04 <dcoutts> jsternberg: the ghc package database is consulted by ghc. the cabal tool registeres installed packages in that database by calling ghc-pkg
09:25:21 <elliott> dmwit: Outside as in: inside pure code.
09:25:30 <hjulle> dmwit: ok. But that requires me to install them first?
09:25:33 <ski> elliott : "that doesn't mean ..","or an () that .." -- the same points apply to `forkIO :: IO () -> IO ThreadId', imo
09:25:35 <dmwit> elliott: You can not cause pure code to do IO with unsafeInterleaveIO.
09:25:35 <EvanR-work> not inside pure code
09:25:39 <dmwit> elliott: You are incorrect.
09:25:43 <jsternberg> the only package manager I'm really familiar with is dpkg and apt-get, is ghc-pkg comparable to dpkg and cabal comparable to apt-get?
09:25:50 <dmwit> hjulle: yes
09:25:58 <ski> dcoutts : yeah, i'm aware :)
09:26:05 <dcoutts> jsternberg: very roughly, yes. But don't take that analogy too far.
09:26:06 <elliott> dmwit: Then clearly we are using different definitions of either "pure" or "do"
09:26:34 <dmwit> elliott: Calling a pure function from inside an IO-action does not make the resulting action pure.
09:26:46 <ski> (dcoutts : and i'm arguing that `unsafeInterleaveIO' doesn't violate purity or referential transparency, if that wasn't clear)
09:27:15 <dcoutts> ski: sorry, I didn't see the conversation from the beginning
09:27:20 <hjulle> dmwit: Is there any reason why hoogle can't search for instances of a class?
09:27:20 <ski> np
09:27:33 <applicative> jsternberg,  ghc-pkg might also be compared to  pkg-config I suppose
09:27:33 <elliott> dmwit: So "return x :: IO ()" doing IO when executed is just fine in your opinion?
09:27:52 <dmwit> elliott: No. return x :: IO () never does IO when executed.
09:28:09 <elliott> dmwit: evaluate x :: IO (), then?
09:28:23 <dmwit> No, it's still not okay.
09:28:32 <ski> elliott : you can only cause the I/O done by an `IO'-action to be delayed to a later point, using `unsafeInterleaveIO' -- conceptually, it's still the `unsafeInterleaveIO act' action that does the I/O (cf. `forkIO')
09:28:35 <jsternberg> so right now, I just ran "ghc-pkg find-module Data.Char"
09:28:39 <elliott> do x <- unsafeInterleaveIO deleteFileMwahaha; evaluate x :: IO ()
09:28:41 <elliott> dmwit: No?
09:28:50 <dmwit> But unsafeInterleaveIO foo >>= \x -> evaluate x is a _bigger_ expression than just evaluate x.
09:28:57 <jsternberg> and I got two things, "base-3.0.3.2" and "base-4.2.0.2", how does ghc decide which one to use?
09:29:04 <elliott> ski: Sure, but it's still impure in a rather practical sense.
09:29:05 <dmwit> I'm perfectly happy with (>>=) doing IO.
09:29:28 <jsternberg> and is this the command that's run for ghc --make?
09:29:37 <elliott> dmwit: Well, you're happy with (>>=) exposing "implementation details" (evaluation order and the like) of the pure functions used within it.
09:29:37 <dcoutts> elliott: a useful analogy for unsafeInterleaveIO is forkIO, both cause non-determinism in IO actions, they just have different schedulers (and the unsafeInterleaveIO one is almost demonic)
09:29:42 <elliott> I'm not.
09:29:43 <ski> elliott : it's still hard to *predict*, in the same way scheduler interleaving of threads doing I/O is hard to predict, i grant that
09:29:47 <elliott> jsternberg: You got a problem.
09:30:16 <elliott> Or, hmm, was base-3 shipped with an older GHC version along with base-4?
09:30:27 <elliott> dcoutts: Sure, but you can't really get a value out of forkIO.
09:30:28 <dmwit> elliott: Yes, that's unavoidable.
09:30:48 <jsternberg> elliott: hm?
09:31:01 <saml> jsternberg, find-module returns two base?
09:31:06 <saml> that's weird
09:31:13 <elliott> jsternberg: Well, generally having two versions of a package installed is worrying, especially if it's a core package like base.
09:31:16 <hjulle> dmwit: Thanks anyway
09:31:17 <jsternberg> saml: on the current install I'm using
09:31:19 <saml> on my machine find-module Data.Char  returns only one
09:31:27 <saml> jsternberg, how did you install?
09:31:31 <elliott> Maybe your base-3 is a compatibility layer implemented on top of base-4; I think I remember GHC shipping that once
09:31:35 <elliott> but if not...
09:31:43 <dcoutts> elliott: yes, ghc-6.10 and 6.12 came with two versions of base
09:31:45 <jsternberg> it's ghc-6.12.3 if that helps
09:31:48 <elliott> dcoutts: ah, ok then
09:31:48 <dmwit> hjulle: Anyway, no, I don't think there's anything fundamentally impossible about instance search. Just nobody's written one.
09:31:51 <elliott> jsternberg: you should probably update :P
09:31:54 <dcoutts> as you say, 3 as a compat layer over base 4
09:31:59 <applicative> jsternberg: I think this just means you have an older ghc
09:32:04 <ski> elliott : the declarative meaning of `unsafeInterleaveIO act' is that it is allowed to interleave the I/O effects of `act' with any later effects after this action -- it just so happens that the implementation always does this when the resulting thunk is forced
09:32:09 <dmwit> hjulle: If anything, the thing to do would be to make a server that had as many packages installed as possible and just feed it :i commands. =)
09:32:10 <elliott> jsternberg: (your version is from June 2010)
09:32:12 <applicative> jsternberg: right, like dcoutts said, as usual
09:32:16 <saml> jsternberg, so, it's alright you're just using older version. older version is good.
09:32:28 <elliott> ski: I totally agree that you can give semantics to unsafeInterleaveIO, sure :P
09:32:48 <jsternberg> elliott: I would, but that was the easiest one for me as when I tried to install 7 from source, it required 6
09:32:51 <applicative> ghc 6.10 ghc 6.12 they were so advanced, so new...
09:32:58 <jsternberg> so after I got 6 working, I just didn't care
09:33:01 <hjulle> dmwit: ok
09:33:03 <elliott> jsternberg: The binary packages offered for GHC are very good.
09:33:16 <saml> jsternberg, what is your operating system?  BeOS?
09:33:26 <elliott> BeOS, the most common operating system.
09:33:27 <ski> elliott : note that i'm not disagreeing that this declarative semantics isn't that *useful* for predicting things (cf. threads, again) -- i'm just claiming that this isn't side-effectful
09:33:29 <jsternberg> the OS that I'm currently using is some really old red hat
09:33:46 <elliott> ski: sure... I still wouldn't strip the unsafe prefix from unsafePerformIO thoguh :P
09:33:52 * ski would
09:34:05 <jsternberg> and I don't have admin privelages on it, so I've just been compiling and installing locally
09:34:06 <dcoutts> elliott: so that's my standard line on the issue of unsafeInterleaveIO, that it does have a legit semantics, but non-determinism is tricky and so you should only use unsafeInterleaveIO when that non-determinism does not matter
09:34:10 <elliott> jsternberg: does it have glibc and gmp?
09:34:24 <rwbarton> ski: did you notice the bait and switch to unsafePerforIO?
09:34:30 <elliott> dcoutts: Fair enough. At least we agree (or at least that's how I interpret your non-determinism remark) that lazy IO is bad :P
09:34:35 <dcoutts> readFile is a case where often it does not matter
09:34:35 <jsternberg> not sure about gmp, glibc is should have
09:34:45 <dcoutts> but sometimes it does, and in those cases, don't do it
09:34:55 <elliott> jsternberg: you should probably just use the linux binary package; it's easy to check whether it works: http://haskell.org/ghc/download_ghc_7_2_1#binaries
09:35:00 <elliott> and uses autoconf so it can be installed locally
09:35:04 <elliott> er, hmm
09:35:18 <elliott> probably you want the haskell platform version
09:35:22 <applicative> jsternberg, dont listen to them. once you want something newer then get it. half the linux distributions have 6.10 or 6.12. even pacman gives you 6.12
09:35:22 <elliott> http://haskell.org/ghc/download_ghc_7_0_3#binaries :P
09:35:34 <elliott> applicative: yeah, that's why you don't use ghc from your distribution
09:35:35 <jsternberg> elliott: thanks, I'll try that out later. I'm not actually using it currently, but ghc --make is interesting
09:35:51 <mzero> haskell platform is at 7.0.2
09:35:55 <elliott> jsternberg: using ghc --make is the path of least resistance, what are you doing, makefiles? :P
09:36:01 <elliott> mzero: 7.0.3, I thought.
09:36:07 <jsternberg> the reason I ask is because I've been experimenting with the d programming language and it could really benefit from something like ghc --make
09:36:13 <ski> rwbarton : i can see no such one
09:36:17 <applicative> jsternberg, don't listen to the fanatics, listen to common sense.
09:36:26 <elliott> mzero: yeah you're wrong: http://hackage.haskell.org/platform/changelog.html
09:36:38 * applicative of course has various dangerous ghc's installed....
09:36:44 <dmwit> jsternberg: Go with your heart.
09:36:48 <rwbarton> you'd remove the unsafe prefix from unsafePerformIO?
09:36:53 <rwbarton> unsafeInterleaveIO I can understand
09:36:58 <mzero> hmmm... don't think it is 7.0.3 for mac
09:37:05 <ski> rwbarton : ah, now i see it :), ty
09:37:19 <mzero> but I'm at work - might be easily wrong then
09:37:26 <jsternberg> applicative: the reason why I didn't use ghc 6 to compile ghc 7 was because I didn't want the two to conflict with each other in weird ways and for me to have to debug why
09:37:37 <ski> elliott : sorry, i meant i wouldn't remove the `unsafe' prefix off `unsafeInterleaveIO' -- `unsafePerformIO' should of course keep the prefix ;)
09:37:40 <jsternberg> applicative: so I took the path of least resistance, which was "use what's currently compiling my code"
09:37:48 <RaptorRarr> lambdabot has ground to a halt.
09:37:55 <elliott> ski: err, that was a mistake on my part :P
09:38:15 <dmwit> jsternberg: ghc installs everything with version suffixes (e.g. ghc-6.10 and ghc-7.0), then symlinks the short one (e.g. ghc links to ghc-7.0).
09:38:22 <ski> s/i meant i wouldn't remove/i meant i *would* remove/ -- argh !
09:38:25 <dmwit> jsternberg: So you can have multiple installs at once fairly pain-free.
09:38:36 <ski> > ()
09:38:45 <rwbarton> elliott: why not unsafeForkIO then
09:38:46 <jsternberg> dmwit: I assumed it did that. Just call me paranoid ;)
09:38:55 <RaptorRarr> (12:42.50) * lambdabot (~lambdabot@li85-105.members.linode.com) Quit (Ping timeout: 245 seconds)
09:38:57 <jsternberg> or lazy
09:39:00 <elliott> rwbarton: Can you implement lazy IO with forkIO?
09:39:02 <dmwit> jsternberg: Totally understandable.
09:39:04 <applicative> jsternberg, like I said, your situation is sound, if ghc 6.10 is not sound, commercial prospects for Haskell are nil. But in fact it is sound.
09:39:15 <dmwit> jsternberg: Just telling you so that when you're ready, you can feel confident about the upgrade. =)
09:39:19 <elliott> applicative: What definition of sound are you using?
09:39:25 <rwbarton> not as far as I know, but I don't see the qualitative difference between the two
09:39:32 <elliott> And jsternberg isn't using 6.10.
09:39:58 <elliott> rwbarton: Well, unsafeInterleaveIO lets you get a value out. forkIO doesn't. I don't know how to make that more explicit, though, which is my fault.
09:40:25 <dmwit> forkIO + IORefs let you get a value out
09:40:30 <rwbarton> and of course many applications of lazy IO can be rewritten to a forkIO version (using an MVar say) which has the same operational properties
09:40:39 <ski> elliott : you could, if you also had an non-blocking `readIVar :: IVar a -> IO a' operation whose thunk blocked until the `IVar' was filled  (of course the normal way to implement this `readIVar' would be using `unsafeInterleaveIO')
09:40:42 <rwbarton> but is now magically safe!
09:40:58 <applicative> elliott, he's using 6.12.3
09:41:04 <elliott> ski: So unsafeInterleaveIO makes forkIO as unsafe as unsafeInterleaveIO? Wow :P
09:41:14 <elliott> dmwit: Not a value out in the sense I mean.
09:41:15 <rwbarton> well, perhaps not quite the same operational properties
09:41:26 <elliott> Which, like I said, is vague.
09:41:54 <c_wraith> You can't implement lazy IO with forkIO, though.
09:41:56 <dmwit> Pretty vague. =)
09:41:56 <ski> elliott : i'm not sure what you mean by that -- imo `unsafeInterleaveIO' already is comparable with `forkIO' (and neither is unsafe in the two meanings above mentioned for `unsafePerformIO')
09:42:05 <c_wraith> because the operational guarantees are very different.
09:42:15 <c_wraith> well, promises, not guarantees.
09:42:20 <tac-tics> maybe we should rename it unsafeForkIO
09:42:35 <elliott> ski: Well, yeah, I'm not entirely sure either. :p
09:42:40 <rwbarton> that's what I suggested originally, I don't see why one would consider one unsafe and the other not
09:42:43 <elliott> ski: The benchmark is something like "can you do lazy IO with it".
09:43:04 <c_wraith> in particular, forkIO can be true concurrency.  unsafeInterleaveIO will never execute concurrently on another core.
09:43:08 <ski> elliott : otoh, `unsafeInterleaveST' is quite unsafe (in the sense of nondeterminacy of pure code), in the general case
09:43:46 <c_wraith> rwbarton: unsafeInterleaveIO is unsafe in terms of "making what appears to be pure code cause IO."  forkIO can't do that.
09:43:49 <elliott> ski: indeed
09:43:50 <ski> c_wraith : with a speculative implementation, `unsafeInterleaveIO' might well do that
09:44:03 <c_wraith> ski: that'd ruin many uses of unsafeInterleaveIO
09:44:05 <rwbarton> but it doesn't "cause" IO, we already went over that
09:44:07 <elliott> Hey, someone fix lambdabot, I need ?pl :-P
09:44:13 <ski> (s/of pure code/of "pure" code/)
09:44:42 <ski> c_wraith : probably, yes -- just noting i don't see this as an incorrect implementation
09:45:16 <c_wraith> ski: if it defeats most of the operational properties that make unsafeInterleaveIO useful, I'd call it an incorrect implementation.
09:45:28 <rwbarton> c_wraith: what it causes is for the IO to happen at a particular time, as opposed to another time, yes?
09:45:39 <rwbarton> Or, perhaps, never
09:45:54 <c_wraith> ski: I'd say the most important part of unsafeInterleaveIO isn't that the call doesn't block - it's that the IO is *deferred*
09:46:28 <ski> c_wraith : agreed, like `forkIO'
09:46:58 <c_wraith> forkIO doesn't make that guarantee, though.  It says "this will be executed whenever the runtime wants", not "this will be executed when it is needed"
09:47:20 <rwbarton> what if I write do { x <- getCurrentTime ; print $ length $ fib 1000 ; y <- getCurrentTime ; ... }
09:47:22 <c_wraith> they're entirely different things
09:47:41 <elliott> c_wraith: and doesn't return the value.
09:47:44 <rwbarton> this exposes "details of the implementation of fib", does that mean I should write "unsafe" somewhere in my program, and if so, where?
09:48:05 <elliott> rwbarton: it only exposes it through an executed IO action
09:48:10 <tac-tics> Will a usilIO call never run the command if the value is never deconstructed?
09:48:18 <gwern> wow. thanks to pandoc/highlighting-kate/snap, I no longer have enough RAM to both compile my Hakyll script *and* run Firefox
09:48:18 <elliott> you will now respond that "main" is an executed IO action and therefore blah blah blah :P
09:48:24 <c_wraith> tac-tics: that's correct
09:48:27 <rwbarton> unsafeInterleaveIO doesn't help you escape IO
09:48:39 <gwern> I guess my next laptop will need more than 4 gigabytes of RAM...
09:48:40 <c_wraith> tac-tics: and something I rely on sometimes, like when creating infinite streams via IO
09:49:19 <c_wraith> gwern: try using gold to get back some ram during compiling?  usually it's the linker that explodes memory use
09:49:21 <tac-tics> c_wraith: So I can launchMissiles, but as long as I don't ask whether or not I hit my target, I don't have to worry about starting a nuclear war :)
09:49:29 <gwern> c_wraith: yes, it's ld that's being killed
09:49:53 <c_wraith> gwern: several people have had a lot of success using gold instead of ld
09:49:58 <gwern> c_wraith: how does one do that?
09:50:03 <c_wraith> gwern: but I'm not one who's tried, so I don't have instructions :)
09:50:43 <elliott> gwern: LD=gold? --something-ld=gold?
09:50:46 <elliott> at cabal configure time
09:50:57 <elliott> ah, something = with
09:51:00 <c_wraith> tac-tics: there's a reason it's marked "unsafe".  Like never being sure if you're accidentally starting armageddon.
09:51:04 <elliott> --with-ld=gold will do it, I believe
09:51:24 <rwbarton> or for another example, perhaps when I use a value assigned through unsafeInterleaveIO, the value I see happens to depend on the details of how I wrote some other pure function, but so what, when I read a file (even using strict IO) what I see will depend on how my program is scheduled relative to another one writing that file
09:51:45 <elliott> rwbarton: Yes, which is why reading a file is in IO.
09:51:58 <tac-tics> c_wraith: I guess if you forkIO, you're significantly more certain (yet still not entirely certain) that you started armageddon
09:51:59 <rwbarton> right, and why the return type of unsafeInterleaveIO is IO a
09:52:12 <c_wraith> tac-tics: yes. :)
09:52:25 <elliott> rwbarton: This conversation is going in circles. :p
09:52:42 <c_wraith> conversation = unsafeInterleaveIO conversation
09:52:49 <elliott> Heh.
09:52:56 * elliott wonders what that does.
09:53:01 <c_wraith> just an infinite loop
09:53:11 <elliott> Boring.
09:53:21 <elliott> (Well, only when forced.)
09:53:24 <dankna> surely it's an infinite loop that ? yeah
09:53:26 <c_wraith> however, it waits until you force the result of binding it before being an infinite loop!
09:53:31 <elliott> Beautiful.
09:53:35 * ski sometimes thinks `readFile' ought to use copy-on-write wrt the file-system, effectively taking a snapshot of the file at the time the action runs
09:53:41 <elliott> Other actions that meet this criteria: return _|_ :P
09:54:03 <c_wraith> unsafeInterleaveIO is approximately the same semantics as return . unsafePerformIO
09:54:06 <elliott> ski: I would be OK with that: lazy IO would merely be inefficient, not impure.
09:54:10 <elliott> c_wraith: that's what I opened the conversation with :P
09:54:46 <benmachine> I think the only thing that upsets me about lazy IO is that it's in the standard prelude, and there's no simple alternative to it
09:54:49 <ski> elliott : i still consider it pure, but not as determined as we'd like to
09:54:50 <rwbarton> anyways the point is that there are many sources of nondeterminism in IO, and so from one point of view it is strange to single out one and give it an "unsafe" prefix
09:55:12 <trinithis> How do I build a 64 bit haskell program with ghc?
09:55:19 <elliott> trinithis: ghc --make foo.hs
09:55:32 <c_wraith> rwbarton: I don't think it's that strange.  It's the one that hides the fact that it's concurrent.
09:55:35 <ski> benmachine : *nod*, i would have no problem with banishing it to another module
09:55:35 <elliott> (Requires an appropriate compiler, of course.)
09:55:54 <trinithis> Would running it under 32 bit cygwin compile it 32 even on a 64 bit os?
09:56:14 <c_wraith> trinithis: yes.  ghc doesn't do cross-compiling at the moment
09:56:21 <trinithis> ah, thanks
09:56:47 <ski> (c_wraith : i don't think it hides that it's concurrent ;)
09:57:03 <elliott> trinithis: Why Cygwin? I'm under the impression GHC has a native Windows version.
09:57:09 <ski> (i mean, you can hide `forkIO' and operations on `MVar's or `Chan's inside other functions and types, as well)
09:57:17 <trinithis> I hate cmd.exe
09:57:37 <elliott> trinithis: You can use Windows programs in the Cygwin terminal thing.
09:57:37 <jsternberg> http://sourceforge.net/projects/console/
09:57:38 <elliott> Try "dir".
09:57:48 <elliott> (The Cygwin terminal thing being rxvt.)
09:57:49 <jsternberg> place cygwin on your path, use console with cmd.exe backing it
09:57:50 <rwbarton> c_wraith: it's certainly more likely to violate one's expectations than a function with a name like getCurrentTime or getRandomR or forkIO, and perhaps that is reason enough to call it "unsafe"
09:58:03 <trinithis> I'll try it ouy
09:58:07 <jsternberg> so far the best "linux" shell I've had on windows
09:58:15 <elliott> jsternberg: You must not have used many "linux" shells. :p
09:58:30 <KirinDave> Whaaa?
09:58:37 <KirinDave> jsternberg: does zsh work on windows?
09:58:38 <jsternberg> I'm always looking for better linux shells on windows, as I'm forced to work on windows at work
09:58:39 <gwern> gaahh! hakyll broke table of contents on gwern.net >.<
09:59:00 <KirinDave> gwern: Howso?
09:59:06 <jsternberg> I was really surprised to find that I the following command works on my setup
09:59:11 <jsternberg> ls | wc -l
09:59:12 <c_wraith> ski: but that doesn't do what unsafeInterleaveIO does.  actions that don't use unsafePerformIO or unsafeInterleaveIO promise that all IO they perform is done by the time the bind operation finishes.  unsafeInterleaveIO violates that expectation
09:59:15 <gwern> KirinDave: the TOC div is no longer there
09:59:17 <tsousa> ['a'] ++ ['a','b','c']  ++ appends 'a' to the end of the second list right?
09:59:28 <Clint> KirinDave: there have been multiple windows ports
09:59:42 <elliott> jsternberg: Why?
09:59:43 <KirinDave> gwern:Weird.
09:59:49 <elliott> jsternberg: DOS and Windows have always supported pipes.
09:59:51 <KirinDave> gwern: I've finally started to tame hakyll for my site.
09:59:51 <gwern> KirinDave: I mean, I can see the generated pointers *to* the TOC div - eg. '<h1><a href="#TOC">Technical aspects</a></h1>' <-- but no actual "TOC" div!
09:59:55 <ski> c_wraith : no, if you use `forkIO', the the I/O done isn't promised to be done by the time `(>>=)' finishes
09:59:57 <trinithis> damn it, I rebuilt my haskell program in a 64 bit cmd.exe and am running it there. Still shows up as a 32 bit program
09:59:59 <elliott> Although by writing to a temporary file, so you can't do streaming.
10:00:00 <jsternberg> really? I thought they didn't
10:00:02 <elliott> Maybe Windows changed that.
10:00:17 <Nafai> tsousa: Try it out in ghci...
10:00:21 <jsternberg> elliott: I thought that was cygwin magic
10:00:21 <elliott> ski: But you can't get a value out of forkIO.
10:00:29 <ski> tsousa : no, it prepends  ['a']  to the start of the other list
10:00:35 <KirinDave> gwern: That suggests the cruddy templating failed or you didn't have a value in the environment for that template variable, right?
10:00:36 <elliott> jsternberg: "Cygwin magic" is not magic, it's just shipping a port of bash.
10:00:48 <elliott> jsternberg: cmd.exe isn't a shell either, it's a terminal that happens to have a built-in shell. (You can run bash in cmd.exe.)
10:00:49 <gwern> KirinDave: running one page in pandoc, I see the TOC div, so that's not it
10:00:55 <tsousa> ok thanks
10:01:11 <jsternberg> elliott: I tried the cygwin shell and I disliked it a lot
10:01:15 <ski> elliott : with something like the 'readIVar :: IVar a -> IO a' operation i suggested, you can (but maybe you consider that essentially `unsafeInterleaveIO', anyway ..)
10:01:16 <elliott> jsternberg: You mean bash?
10:01:23 <jsternberg> no, I love bash
10:01:24 <c_wraith> ski: ah.  yes.  I should have said "the result of the bind action doesn't doesn't have secret IO in it."  (it can, of course, have non-secret IO, like in the case of IO (IO a)
10:01:26 <elliott> jsternberg: Or rxvt, which is not a shell but a terminal?
10:01:35 <elliott> Cygwin ships both.
10:01:55 <jsternberg> elliott: I'm not sure honestly
10:01:58 <elliott> Basically I'm totally unclear on what you disliked because you say it was the shell, but the shell is bash.
10:02:10 <trinithis> Oh, I see. Is there an already built x64 Haskell platform
10:02:20 <trinithis> for windows
10:02:29 <elliott> Maybe what you truly hate is using bash in the cmd.exe terminal... but that's cmd.exe's fault, not Cygwin's. :p
10:02:31 <gwern> KirinDave: TOC wasn't a variable before, and the other bits of my templating like $modified$, $title$, $description$, or $body$
10:02:41 <gwern> work
10:02:43 <KirinDave> gwern: Weird.
10:02:56 <jsternberg> I should try using bash inside of console and see if it's nice
10:02:57 <KirinDave> gwern: Well the new hakyll is kinda tedious to work with, tbh. I mean, sometimes it feels great
10:03:06 <KirinDave> gwern: But then you're like, "Oaky, tuple this, chain to that."
10:03:11 <KirinDave> gwern: And it gets tedious.
10:03:48 <elliott> "tuple this, chain to that" <-- sounds like arrows
10:03:50 <gwern> KirinDave: going to take this to #hakyll
10:03:53 <gwern> elliott: yes, arrows
10:03:57 <elliott> oh look, it uses arrows
10:04:10 <ski> c_wraith : you could imagine `IO (IVar Foo)' (using `forkIO'), with a later `readIVar', and a still later forcing of the result, which would block until the other thread filled the `IVar'
10:04:32 <elliott> ski: You could not implement lazy IO with that.
10:04:41 <c_wraith> ski: yes, but in those cases, you're using another IO action to read the IVar.
10:04:47 <rwbarton> ski wants readIVar :: IVar a -> a, I think
10:04:50 <jsternberg> elliott: you may have improved my life slightly. The thing that annoyed me is I could never do alt+backspace in cygwin, but bash inside console I can use alt+backspace
10:04:56 <rwbarton> otherwise it's just an MVar
10:04:56 <elliott> rwbarton: there's the problem :P
10:05:07 <elliott> jsternberg: haha
10:05:08 <jsternberg> (someone recently taught me that ctrl+u was the equivalent, but old habits die hard)
10:05:12 <c_wraith> huh.  I guess that's what monad-par gives you, too.
10:05:28 <ski> elliott : that's right -- i'm just saying this would be similar to interleave I/O in that when the I/O is done isn't apparent for the current thread, from when it uses `IO' operations
10:05:28 <elliott> jsternberg: I'm sure you can get bash to bind that with its keybindings system from within rxvt or whatever
10:05:43 <elliott> c_wraith: I don't think so.
10:05:45 <c_wraith> however, monad-par is implemented with unsafePerformIO
10:05:50 <c_wraith> so it's still not a counterexample
10:05:50 <elliott> monad-par gives you readIVar :: IVar a -> whateveritsmonadiscalled a
10:05:52 <elliott> I believe
10:05:55 <c_wraith> oh.  right.
10:05:57 <c_wraith> Par a
10:05:59 <elliott> right
10:06:04 <ski> rwbarton : hm, actually `readIVar :: IVar a -> a' would also work here (possibly better) -- i had forgotten that
10:06:14 <elliott> c_wraith: and I think running the whole thing will end up forcing it
10:06:28 <rwbarton> oh I see
10:06:32 <c_wraith> ski: but how do you implement readIVar with that type signature without an unsafePerformIO?
10:06:40 <jsternberg> elliott: oh, and this is the thing I didn't like about cygwin. I call cygwin.bat to open up the shell and it took 10 seconds to finally get me into bash
10:07:01 <elliott> jsternberg: Well, I don't like Cygwin. But it certainly doesn't take ten seconds to start up for me.
10:07:26 <jsternberg> elliott: I do need to stop saying fud though. I just tried alt+backspace in the cygwin shell and it worked. Might be because my company just upgraded me to windows 7
10:08:13 <ski> c_wraith : as a primitive would be one way -- using `unsafeInterleaveIO' would be another :) (but note that this doesn't use the full force of the operational semantics given by `unsafeInterleaveIO')
10:08:27 <elliott> jsternberg: heh :P
10:08:30 <elliott> it's not FUD to be mistaken
10:08:58 <cheater> jsternberg: i seem to remember bash in windows xp cygwin was shit
10:09:02 <cheater> that was a few years ago
10:09:06 <tsousa> doing the 99 haskell problems is a good way to improve or no?
10:09:26 <cheater> jsternberg: also, alt-backspace is readline, not bash
10:09:31 <ski> well, with `IVar a -> a', one would do `unsafePerformIO', and claim that the nondeterminacy is due to the earlier `forkIO' -- so maybe having a monad (`IO' or `Par') here would be nicer in practice
10:09:37 <cheater> jsternberg: so maybe your version was compiled without readline support?
10:09:46 <jsternberg> possibly
10:10:06 <cheater> btw, if you like stuff like that you can check this out: http://cheater.posterous.com/readline
10:10:07 <c_wraith> ski: so...  with stuff that gives the same kind of operational semantics as unsafeInterleaveIO (even if the full operational semantics aren't required).  I think you're agreeing that unsafeInterleaveIO is fundamentally different from forkIO.  The latter has the timing of its effects bound more by the type system than the former.
10:10:12 <elliott> jsternberg: Does alt-backspace erase the whole line for you?
10:10:17 <elliott> Because that's what Ctrl+U does which you named as a replacement.
10:10:22 <jsternberg> elliott: it's delete word
10:10:26 <elliott> ah
10:10:28 <jsternberg> elliott: oh...
10:10:35 <jsternberg> that's not a replacement at all!
10:10:37 <elliott> Ctrl+W is the "replacement" then
10:10:44 <elliott> (in quotes because alt-backspace works for me)
10:10:57 <jsternberg> I like alt-backspace better personally
10:11:03 <ski> jsternberg : i typically run `cygwin.bat' only once per windows session, then running everything inside that (using GNU screen, and often opening more terminals using X)
10:12:12 <jsternberg> ski: I know how to use screen, but I don't know how to open more terminals using X. And there's nothing like the ctrl+shift+n that gnome-terminal has
10:12:38 <ski> c_wraith : i'm claiming that the declarative semantics is similar to `forkIO', but the operational semantics that we've come to expect out of GHC is different, yes (cf. with laziness and forcing of thunks not being required by the standard)
10:13:44 <ski> jsternberg : you need to start up `X', you can either start up a mother X-window, where every real X window with appear inside that, or you can run "rootless", where it reuses Windows windows for each X window
10:13:59 <ski> s/with appear/will appear/
10:15:04 <jsternberg> another question about ghc --make, is it ever used for compiling a library?
10:15:17 <dmwit> yes
10:15:18 * ski wrote a small script `startx_wmaker' to do this for him .. i dunno whether recent Cygwin's already comes pre-shipped with something like this
10:15:23 <jsternberg> or how are libraries generally created with ghc?
10:15:30 <dmwit> via cabal
10:15:57 <jsternberg> libraries don't generally have a root module though, do you just have to list all the source files (or use a glob)?
10:16:14 <elliott> yeah jsternberg you should definitely check out cabal
10:16:16 <dmwit> Yes, list all the exposed modules and all the auxiliary modules.
10:16:21 <elliott> it handles all the work of ghc --make and the like for you :)
10:17:16 <dmwit> jsternberg: Assuming you have cabal-install installed, try "cabal init" from within the directory where you're writing your library.
10:17:32 <dmwit> If you don't have it installed, install it. =)
10:17:44 <dmwit> ?hackage cabal-install has a bootstrap.sh in the .tar.gz
10:17:47 <jsternberg> okay, let's try this
10:18:06 <dmwit> Oh, no lambdabot.
10:18:08 <jsternberg> I'm going to try making a test library
10:18:14 <rostayob> Is it possible not to export something, while exposing it on haddock?
10:18:39 <dmwit> rostayob: I don't think so. But you can re-export it from another module to make it visible.
10:18:42 <elliott> dmwit: cabal init --no-comments, I'd prefer. :p
10:18:45 <elliott> (Why isn't that the default?)
10:18:59 <dcoutts> elliott: yeah I agree, I've changed it in the dev version
10:19:03 <dmwit> rostayob: (Haddock builds documentation for all modules, exposed or not, but only links to the exposed modules.)
10:19:17 <dcoutts> elliott: the trick was making it discoverable for new users without making it annoying for experienced users
10:19:44 <rostayob> dmwit: yeah the thing is that I have this "marker" type class used internally, and i don't want users to be able to use it
10:19:44 <dcoutts> elliott: so what I've done is made it an interactive Q in cabal init, with a default of 'n' for "no thanks I don't need the commentary"
10:19:58 <elliott> dcoutts: I dunno, even a beginning user probably wants to Ctrl+K a ton afterwards
10:20:01 <rostayob> dmwit: but at the same time, functions visible externally use it in their type signature
10:20:10 <elliott> I think the fields are pretty self-explanatory, but that might be bias because I'd consider myself experienced :P
10:20:15 <dcoutts> elliott: sure, they ctl-k after reading it
10:20:17 <dmwit> rostayob: Ah, yep. A common problem. The type should link to the internal module, though, doesn't it?
10:20:31 <dcoutts> elliott: anyway, now they get the option to have the comments or not
10:20:33 <elliott> dcoutts: I'd rather output foo.cabal.info then or something
10:20:44 <rostayob> dmwit: well it's in the same module
10:20:44 <jsternberg> so I ran cabal init
10:20:46 <rostayob> oh wait
10:20:47 <elliott> or just have it link to a commented example :P
10:20:50 <jsternberg> pretty amazing, now how do I build the library?
10:21:02 <dmwit> jsternberg: cabal configure && cabal build
10:21:04 <elliott> jsternberg: "cabal configure", "cabal build"; you might want to check out cabal-dev for more reusable/sandboxed builds
10:21:06 <dmwit> jsternberg: or just "cabal install
10:21:07 <dmwit> "
10:21:15 <elliott> http://hackage.haskell.org/package/cabal-dev, https://github.com/creswick/cabal-dev
10:21:19 <elliott> (install with "cabal install cabal-dev")
10:21:19 <dmwit> But then it gets installed, not just built. =)
10:21:22 <jsternberg> wait, cabal is also a build system?
10:21:30 <rostayob> dmwit: yeah it's in the same module of the functions exposed externally, but it doesn't show
10:21:45 <elliott> jsternberg: It just uses ghc --make.
10:21:52 <elliott> jsternberg: But it has to be able to build the packages you write...
10:22:15 <dcoutts> jsternberg: you might like to read my new quickstart guide to cabal http://code.haskell.org/~duncan/cabal/user-guide/developing-packages.html#quickstart
10:22:25 <dcoutts> (part of an attempt at rewriting the cabal user guide)
10:22:29 <dmwit> rostayob: The usual trick is to make a Foo.Internal that exposes everything (but is not in exposed-modules in your .cabal), and a Foo which exposes only some things, but imports Foo.Internal, so that the haddock gets links.
10:23:07 <rostayob> dmwit: why does that work and this doesn't?
10:23:38 <dmwit> rostayob: Because haddock ignores non-exposed functions/types but doesn't ignore non-exposed modules.
10:23:44 <rostayob> weird. thanks.
10:23:57 <dmwit> ("expose" has two different meanings in that sentence. It's context-polymorphic.)
10:24:21 <DevHC> i'm making a new monad, a restricted version of IO, for use in Safe code. i have functions of type (... -> RIO a). they can be divided into 2 groups: read operation and write operations. in certain parts of the program i want to allow the usage of only read operations (and in other parts both types of operations). what is a good way to enforce this at compile time?
10:24:49 <dmwit> DevHC: RIO rw a, RIO Read a, RIO Write a
10:24:55 <dmwit> + functions to combine them
10:25:10 <dmwit> You'll probably need RIO ReadWrite a, too
10:25:18 <EvanR-work> DevHC: what about RW operations
10:25:25 <elliott> dmwit: I don't think DevHC needs Write.
10:25:32 <elliott> EvanR-work: DevHC mentioned RW, and never mentioned write-only.
10:25:50 <KirinDave> Hey folks,
10:26:05 <elliott> You can simply have "RIO rw a", have read actions be "RIO rw a", and write actions "RIO RW a", then instantiate rw = anything that isn't RW for read execution.
10:26:09 <DevHC> i have functions like getFieldA, setFieldA, and doSomethingGeneral
10:26:09 <dmwit> If you only want to distinguish read-only and read-write, then you indeed need only RIO rw a and RIO R a.
10:26:16 <KirinDave> awhile ago there was a paper and some blog posts discussing how mutliple passes over a dataset could be transformed into one pass automatically via like a codensity monad and a free monad?
10:26:26 <KirinDave> Does anyone have links to that still?
10:28:10 <applicative> KirinDave: http://comonad.com/reader/2011/free-monads-for-less/ ?
10:28:26 <KirinDave> Yeah, I think taht's it.
10:28:36 <KirinDave> The paper was http://www.iai.uni-bonn.de/~jv/mpc08.pdf
10:29:58 <hpaste_> DanBurton pasted “Cont no return” at http://hpaste.org/52097
10:30:00 <hpaste_> dmwit pasted “read-write” at http://hpaste.org/52098
10:30:11 <dmwit> DevHC: How about some API like that?
10:30:24 <dmwit> DevHC: Note that the type annotations are *more restrictive* than the ones GHC would infer if you left them off.
10:30:49 <DanBurton> I've been reading http://okmij.org/ftp/continuations/index.html#tutorial - is there a better way to make it so "return" is unnecessary?
10:31:05 <DanBurton> Seems a little wonky to make (m a) an instance of Num
10:31:29 <elliott> DanBurton: You mean how ex1 looks?
10:31:30 <applicative> KirinDave, I take it you saw the use of codensity in http://personal.cis.strath.ac.uk/~conor/Kleisli.pdf
10:31:33 <elliott> That's just because of liftM2
10:31:38 <elliott> You can define a, like, liftSecondM2
10:31:45 <elliott> :: (a -> b -> m c) -> a -> m b -> m c
10:32:02 <elliott> But no, you can't eliminate the returns as much as you can eliminate them from any other monad
10:32:33 <KirinDave> applicative: I have not understood that paper yet, but I have seen it. It's on my list of bears to wrestle in the snow nearly naked to make myself stronger.
10:33:06 <DevHC> dmwit: i'll see how i can get that to work. at first it seems exactly what i'm looking for
10:33:34 <hpaste_> dmwit annotated “read-write” with “read-write (annotation)” at http://hpaste.org/52098#a52099
10:33:36 <applicative> KirinDave, I was trying to see if I could get edwardk's simplification to work in that context, but dropped it.
10:33:45 <DanBurton> elliott: yeah; Oleg's notes in the .hs file indicated that we could get t1 (or whatever it was labeled in his file) to not have any "return"
10:33:47 <dmwit> DevHC: I forgot an important part, see the annotation.
10:33:52 <elliott> dmwit: Why the typeclass?
10:33:56 <roconnor> :type fmap (=<<)
10:34:00 <dmwit> elliott: Which type class?
10:34:05 <roconnor> @type fmap (=<<)
10:34:06 <elliott> dmwit: Readable, Writable.
10:34:12 <elliott> Which you, I note, don't define.
10:34:28 <dmwit> elliott: I'm assuming DevHC will fill in the definitions of getField/setField himself.
10:34:37 <elliott> dmwit: Uh.
10:34:41 <elliott> Oh, I see.
10:34:46 <elliott> dmwit: bind' and the like seem unnecessary.
10:34:51 <elliott> You just need a run function.
10:34:56 <dmwit> bind' doesn't seem unnecessary to me.
10:35:02 <incluye> @pl \a -> [a + 1]
10:35:13 <dmwit> How are you going to sequence safe actions if you don't have bind'?
10:35:18 <hpaste_> elliott annotated “read-write” with “read-write (annotation) (annotation)” at http://hpaste.org/52098#a52100
10:35:22 <incluye> dude where's the bot
10:35:23 <elliott> dmwit: Like that?
10:35:44 <dmwit> elliott: When you implement (>>=) there, you will write something very like bind'. =)
10:35:56 <elliott> dmwit: Yes, you need a binding function.
10:35:57 <dmwit> elliott: Except its type will be too restrictive, because it can't mix ReadOnly and WriteOnly actions.
10:36:06 <elliott> dmwit: I am not under the impression that DevHC requires WriteOnly.
10:36:14 <dmwit> It's what he asks for.
10:36:18 <elliott> Indeed I very much doubt it.
10:36:22 <elliott> dmwit: Where?
10:36:35 <elliott> "in certain parts of the program i want to allow the usage of only read operations (and in other parts both types of operations)."
10:36:44 <elliott> dmwit: Sounds like ReadOnly vs. ReadWrite to me.
10:36:48 <dmwit> they can be divided into 2 groups: read  operation and write operations.
10:36:55 <elliott> dmwit: Yes, the operations can.
10:36:59 <elliott> Not the contexts in which they can be used.
10:37:08 * dmwit shrugs
10:37:13 <elliott> But really, we should just ask DevHC whether he wants write-only operations or not.
10:37:16 <elliott> :
10:37:16 <elliott> :p
10:37:20 <dmwit> The approach for read-only vs read-write is an obvious simplification of this one.
10:37:49 <elliott> BTW, you missed TypeFamilies in your extension list.
10:38:29 <dmwit> Indeed I did.
10:38:48 <dmwit> I'd be quite surprised if this compiled straight off, in fact, since I just typed it straight into hpaste.
10:39:00 <tsousa> in this code what is x in the forth line? http://dpaste.com/626549/ is (k,v) ?
10:39:48 <DevHC> did i not make it clear that i don't need write-only operations? now i'm making it clear: i don't need write-only operations
10:40:02 <dmwit> tsousa: an error
10:40:13 <elliott> DevHC: Then you can use my simpler version :P
10:40:19 <dmwit> DevHC: Then the approach can be significantly simpler.
10:40:23 <tsousa> dmwit, ?
10:40:23 <elliott> Although I'm not sure I like the "forget" name.
10:40:24 <dmwit> No need for type families and the like.
10:40:29 <elliott> It's more like... "makeMorePrivileged".
10:40:34 <dmwit> tsousa: x is an error in the fourth line. It's not in scope.
10:40:35 <elliott> raise?
10:40:43 <elliott> Is raise used for anything?
10:40:50 <dmwit> tsousa: Perhaps you'd better double-check that you copied and pasted correctly. =)
10:40:55 <elliott> dmwit: Oh, I don't think you got getField's type right
10:40:56 <tsousa> dmwit, that code is in lyah
10:40:59 <elliott> oh wait, only my approach breaks it :P
10:41:20 <hpaste_> elliott annotated “read-write” with “read-write (annotation) (annotation) (annotation)” at http://hpaste.org/52098#a52102
10:41:24 <elliott> DevHC: there
10:41:26 <elliott> the last one on that page
10:41:53 <tsousa> dmwit, i think that it is correct
10:42:20 <dmwit> tsousa: It should probably say "| key == k"
10:42:33 <elliott> It is definitely not correct as pasted.
10:42:59 <tsousa> probably that what is in the book is keu == x = Just v
10:43:11 <elliott> Eh?
10:43:23 <dmwit> tsousa: Bonus points if you tell the author to fix it. =)
10:43:37 <tsousa> ehehe
10:43:50 <tsousa> uh in the example that is below it is correct
10:43:58 <tsousa> i will send a email to him
10:44:56 <elliott> right
10:45:32 <applicative_> DanBurton, very styling Num instance there
10:47:08 <elliott> DanBurton: Oleg is probably referring to such a dirty hack as Num (m a), yes.
10:47:20 <elliott> That's just a day in the life of Oleg :P
10:47:27 <DanBurton> :)
10:49:37 <applicative_> I tried various expedients but wasn't as bold as that.  I dont see what can be done in cases like your t2
10:50:16 <applicative_> DanBurton: the 'she' preprocessor permits this for t1:  t1s' = (|  (reset  (| ~ 3  + (shift (\k -> (| ~ 5 * ~ 2 |))) |))  - ~ 1 |)
10:50:39 <applicative_> DanBurton, not so great, and doesn't work for t2
10:51:16 <shirt> let write x y = putStrLn ((format x) ++ y) in mapM_ (write "foo") [1..10]
10:51:17 <DanBurton> applicative_: so basically it lets you use "~" as a macro for "return" inside the bananas?
10:51:19 <dmwit> DanBurton: In case the questions in the comments are yours, Num requires an Eq instance because pattern matches on numeric constants are done with (==), and it requires a Show instance because it was expected that this would cut down on the size of typing contexts in many cases.
10:51:24 <elliott> ~ is not a nice name for pure.
10:51:32 <elliott> I would prefer some brackets like {}.
10:51:33 <shirt> how many times will 'format "foo"' be called? 10 times, or will it be optimized to one call at the beginning?
10:51:55 <elliott> shirt: "Depends".
10:52:03 <elliott> shirt: You can be relatively sure by doing:
10:52:15 <applicative_> DanBurton: Yes. Similarly @ at the close of the bananas turns into join (...) after processing
10:52:21 <elliott> shirt: write x = write' where x' = format x; write' y = putStrLn (x' + y)
10:52:26 <DanBurton> dmwit: yes all the comments were mine
10:53:14 <applicative_> DanBurton: the ~ and @ are kind of lame, but the use of | for Alternative is worth a macro, maybe...
10:53:27 <elliott> | for Alternative is nice.
10:54:26 <shirt> elliott: hm... unfortunately this requires restructuring the code and breaking encapsulation :/
10:54:34 <elliott> shirt: Howso?
10:54:37 <elliott> It is entirely local to write's definition.
10:55:04 <elliott> shirt: But I would wait to see if it's an actual performance problem before worrying.
10:55:12 <elliott> Write first, worry (and profile) later.
10:55:51 <dmwit> > let f :: CReal -> Integer; f 0.0000000000000000000000000000001 = 1 in f 0
10:56:05 <dmwit> argh, again no lambdabot
10:56:09 <RaptorRarr> http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf says "The stream function example above illustrates an arrow which takes its input in a di?erent way, as a stream of values rather than a single value, so this is an example of a kind of computation which cannot be represented as a monad."
10:56:13 * copumpkin screams for Cale 
10:56:21 <RaptorRarr> Can't you write a list monad that does streaming?
10:56:22 <EvanR-work> encapsulation is for c++
10:56:22 <roconnor> dmwit: 1
10:56:32 <roconnor> stupid CReal
10:56:33 <copumpkin> maybe there should be multiple lambdabot administrators, so that we aren't all waiting on Cale when it dies
10:56:34 <shirt> elliott: ok thanks
10:56:38 <dmwit> roconnor: thanks =)
10:57:01 <elliott> copumpkin: distributed lambdabot
10:57:04 <elliott> sorry, CLOUD lambdabot
10:57:08 <copumpkin> cloudbot
10:57:11 <roconnor> dmwit: Eq should not be a requirement for Num.
10:57:17 <copumpkin> webscale cloudbot
10:57:25 <dmwit> roconnor: agreed
10:57:33 <copumpkin> Num should not exist
10:57:34 <KirinDave> copumpkin: You forgot to mention it has positive ions.
10:57:41 <dmwit> RaptorRarr: I'm not sure I understand the question.
10:57:49 <elliott> Clambdabot.
10:58:01 <wunki> is it more correct to say that ``foo a b = c`` is a function which takes two arguments, or is it a function that takes one argument, returning a function taking one argument?
10:58:10 <RaptorRarr> dmwit: It says there's a stream arrow and it's an example of a kind of computation you can't represent as a monad.
10:58:12 <dmwit> wunki: Both are correct.
10:58:19 <jsternberg> on a debian system, should one use cabal or apt-get? what happens if you use both? are they compatible with each other? does apt-get use cabal when installing a haskell dependency?
10:58:26 <RaptorRarr> dmwit: I'm wondering what characteristics of it cannot be done with monads.
10:58:33 <elliott> wunki: Both are equally correct.
10:58:38 <roconnor> wunki: it is more correct to say it is a function taking one argument and returning a functiont taking one argument
10:58:53 <elliott> roconnor: If you take that view, then "taking one argument" is redundant.
10:58:58 <roconnor> yes
10:59:01 <elliott> wunki: "A function with (n+1) arguments" = "a function taking one argument and returning a function with n arguments".
10:59:01 <DevHC_> dmwit, elliott: epic.
10:59:08 <DevHC_> raise isn't even needed i gather
10:59:09 <applicative_> RaptorRarr: I think the merits of this example depends on the delay aspect, though I've never understood this.
10:59:12 <elliott> I don't think anyone else can disagree with that definition, so they are both equally correct :-)
10:59:15 <elliott> DevHC_: Yes it is.
10:59:20 <elliott> DevHC_: To use read-only actions from inside read-write ones.
10:59:28 <DevHC_> orly
10:59:29 <dmwit> wunki: Actually, in Haskell, "a function taking two arguments" is just a short-hand way of saying "a function taking an argument and returning a function".
10:59:36 <roconnor> elliott: ML people might disagree :)
10:59:44 <wunki> I'm confused why this ``foo (a, b) = c`` is uncurried, and this one is ``foo a b = c``. Since for me they both seem to take multiple arguments.
10:59:49 <elliott> DevHC_: I suppose if you already use a universally quantified "rw" for read-only things, then you don't need it.
10:59:51 <DevHC_> elliott: all the getField-like actions will have a type of RIO rw a
10:59:52 <elliott> Still, I would keep it.
10:59:58 <DevHC_> yees
10:59:59 <elliott> DevHC_: Yes, but the actions you build out of them might not be.
11:00:03 <roconnor> now wunki is getting into the thick of semantics
11:00:04 <rwbarton> plug in n=0 to that equation and a few people will flip out though :)
11:00:06 <dmwit> wunki: The first is a function taking one tuple argument.
11:00:14 <elliott> DevHC_: For instance you might expose a separate "runReadOnly :: RIO ReadOnly a -> IO a".
11:00:15 <RaptorRarr> applicative_: But you can, for instance, delay the list monad.
11:00:17 <DevHC_> elliott: where would i accidentally build a ReadOnly action?
11:00:22 <elliott> But sure, you don't even have to export ReadOnly.
11:00:23 <elliott> (I wouldn't.)
11:00:26 <elliott> BUT
11:00:29 <dcoutts> jsternberg: cabal knows about haskell packages installed by apt, but not the other way around
11:00:31 <roconnor> I think ML people would call f :: (a, b) -> c a function taking two parameters.
11:00:31 <elliott> That makes your runReadOnly type more compliacted.
11:00:42 <elliott> DevHC_: It must be: "runReadOnly :: (forall rw. RIO rw a) -> IO a".
11:00:45 <elliott> Which requires an extension.
11:01:00 <dcoutts> jsternberg: that is, you can install global haskell packages via apt and use cabal to build other things against those libs
11:01:00 <dmwit> DevHC_: Yes, you don't need raise.
11:01:08 <applicative_> RaptorRarr, just a sec. It is a favorite example of Conor McB too
11:01:08 <DevHC_> i think i have successfully compiled the code without extensions
11:01:15 <DevHC_> newtype RIO rw a = RIO { unRIO :: IO a }
11:01:20 <RaptorRarr> applicative_: Alright.
11:01:23 <ion> f :: Point3D -> a   -- f takes three arguments?
11:01:37 <ion> f :: [a] -> a; f [0..9]  -- f took 10 arguments?
11:01:39 <elliott> DevHC_: unRIO does not do what you think.
11:01:43 <dmwit> DevHC_: In fact, you don't even need ReadOnly; only ReadWrite.
11:01:47 <elliott> DevHC_: It can run read-write code as well as read-only.
11:01:56 <DevHC_> dmwit: right
11:02:05 <elliott> dmwit: Well.
11:02:12 <elliott> dmwit: How else do you _enforce_ the constraints?
11:02:20 <elliott> You either need rank-two types or ReadOnly.
11:02:23 <elliott> I'd pick ReadOnly.
11:02:38 <jsternberg> dcoutts: ah, so I'm guessing that the apt-get packages install the files cabal would normally retrieve in the same place cabal stores files
11:02:48 <DevHC_> elliott: so? i will only apply unRIO to values of type RIO ReadOnly a, whenever i want to execute read-only actions
11:02:59 <dmwit> elliott: Yep, there are (at least) two perfectly good ways.
11:03:01 <elliott> DevHC_: "You don't even need ReadOnly" --dmwit
11:03:04 <jsternberg> does cabal actually use a database? I see a bunch of ".conf" files, but I see no indication of a database
11:03:06 <elliott> DevHC_: "I'll just use ReadOnly" --DevHC
11:03:14 <applicative_> RaptorRarr, It is about 'applicative not monad' but here is a start :) http://www.mail-archive.com/haskell-cafe@haskell.org/msg66472.html
11:03:15 <elliott> DevHC_: These two statements contradict.
11:03:38 <wunki> dmwit: so, is it correct to say that in haskell the only taking two arguments, of these three https://gist.github.com/6540612b4feab776143f is foo3 ?
11:03:59 <elliott> DevHC_: BTW, you likely want "instance MonadIO (RIO ReadWrite)".
11:04:08 <dmwit> wunki: I'd say foo3 is the only one that *doesn't* take two arguments.
11:04:18 <elliott> DevHC_: Unless RIO ReadWrite should not be able to do arbitrary IO, in which case the "IO" part of its name seems weird.
11:04:21 <roconnor> wunki: there is no concencus on this issue
11:04:24 <elliott> I guess you could export your own set of IO operations.
11:04:33 <wunki> dmwit: ah, sorry, that's right...
11:04:40 <elliott> wunki: foo1 and foo2 are completely identical.
11:04:42 <RaptorRarr> applicative_: Thanks. I'll take a look.
11:04:47 <elliott> wunki: foo3 takes one argument.
11:05:00 <elliott> (That foo3 takes one argument is not a point of contention.)
11:05:08 <dmwit> elliott: Not true, the MR may apply to one of foo1 and foo2 but not the other. =P
11:05:15 <ion> wunki: Look at the types of the functions. Count the ->s.
11:05:19 <roconnor> elliott: elliott foo1 and foo2 are complete identical, except in haskell where they are totally different and foo1 and foo3 are identical. :(
11:05:42 <wunki> I'm not trying to flamebait here, but I had written a blog post which was critized (and rightfully so)
11:05:43 <elliott> roconnor: You think foo1 and foo3 are /identical/?
11:05:48 <wunki> so I'm really trying to understand it
11:05:51 <roconnor> dmwit: and seq will distinguish between foo1 and foo2
11:05:54 <roconnor> in some cases
11:05:56 <elliott> dmwit: The MR doesn't exist, and anyone who thinks it does is a horrible bad person.
11:06:07 <DevHC_> elliott: so i do need ReadOnly. and i'll gladly use it. no problems here
11:06:10 <Cale> @bot
11:06:12 <dmwit> roconnor: Wait, really?
11:06:14 <DevHC_> elliott: i have no idea what MonadIO is
11:06:17 <lambdabot> :)
11:06:19 <RaptorRarr> Oh, Haskell explainers. Why must you hurt my brain?
11:06:19 <roconnor> elliott: the Haskell 98 report says foo1 and foo3 are identical IIRC
11:06:25 <elliott> DevHC_: It provides liftIO.
11:06:28 <elliott> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-IO-Class.html
11:06:31 <elliott> Part of the standard library.
11:06:39 <dcoutts> jsternberg: it's not that they install the files in the same place, it's that they both register packages in the ghc package database.
11:06:39 <elliott> roconnor: Dude.
11:06:43 <elliott> roconnor: Are we talking about the same functions?
11:06:45 <roconnor> yep
11:06:45 <elliott> roconnor: https://gist.github.com/6540612b4feab776143f
11:06:51 <roconnor> let me get the report
11:06:54 <elliott> roconnor: What definition of identical are you using?
11:07:03 <elliott> roconnor: Are you telling me the report automatically eliminates tuples or something???
11:07:12 <jsternberg> dcoutts: got it, but since cabal doesn't register anything in the apt-get database, apt-get can't know that something is already installed
11:07:15 <roconnor> elliott: no, the report automatically adds tuples
11:07:20 <dcoutts> jsternberg: cabla just relies on the ghc-pkg database to know what is installed, it does not care if dependencies were installed manually, via apt or via cabal install.
11:07:22 <elliott> roconnor: You have to be kidding me.
11:07:24 <applicative_> RaptorRarr: here's what I was looking for http://www.e-pig.org/epilogue/?p=186
11:07:33 <dcoutts> jsternberg: yes, exactly
11:07:34 <elliott> Someone tell me roconnor is deluded :(
11:07:42 <dmwit> > let f x y = 3; g x = \y -> 3 in (f "hey" `seq` 5, g "hey" `seq` 5) -- roconnor, how to get seq to distinguish these?
11:07:47 <lambdabot>   (5,5)
11:07:58 <rwbarton> > let foo (a, b) = a + b in foo 1 2
11:08:03 <lambdabot>   2
11:08:09 <dcoutts> jsternberg: it's just like installing some other package in /usr/local not using apt
11:08:12 <dmwit> ...what
11:08:16 <byorgey> rwbarton: hahaha
11:08:16 <Cale> RaptorRarr: Did they manage to explain what the distinction was here?
11:08:17 <rwbarton> fff
11:08:20 <ion> :-D
11:08:23 <elliott> rwbarton: WHAT ARE YOU DOING???????
11:08:26 <rwbarton> well anyways it's not 3!
11:08:27 <DevHC_> elliott: i could use RS (``restricted script'') instead of RIO, and yes, the set of functions ever to be used in RS/RIO is a highly restricted subset of IO
11:08:31 <elliott> wait
11:08:31 <elliott> what
11:08:33 <dcoutts> jsternberg: people mostly use cabal for per-user packages, rather than system wide
11:08:41 <elliott> > 9 :: (Int,Int)
11:08:44 <rwbarton> probably an instance for Num (a,a) or some such atrocity
11:08:47 <byorgey> yes
11:08:49 <lambdabot>   (9,9)
11:08:53 <ion> > let foo = 1 in 0foo 1foo 2foo
11:08:59 <lambdabot>   0
11:09:02 <elliott> OK, lambdabot is awful; still waiting on roconnor to prove to me that Haskell is awful.
11:09:07 <jsternberg> dcoutts: yea, but that's usually not an issue with conflicting packages because they get  installed in separate directories. the issue comes when you do "cabal install <package>" and then install it using apt-get
11:09:19 <dcoutts> jsternberg: right exactly
11:09:20 <Cale> elliott: Wait, what?
11:09:29 <rwbarton> actually two Num instances in use there, heh
11:09:30 <ion> > (0,1) + (2,3)
11:09:33 <elliott> Cale: <rwbarton> > let foo (a, b) = a + b in foo 1 2
11:09:34 <elliott> <lambdabot>   2
11:09:37 <lambdabot>   (2,4)
11:09:41 <ion> > (0,1) / (2,3)
11:09:41 <byorgey> rwbarton: yes, one for pairs and one for functions =)
11:09:46 <elliott> Cale: <roconnor> elliott: the Haskell 98 report says foo1 and foo3 are identical IIRC [those two functions being from https://gist.github.com/6540612b4feab776143f -Ed.]
11:09:47 <lambdabot>   (0.0,0.3333333333333333)
11:09:53 <dcoutts> jsternberg: so people usually use their distro for core packages and cabal for random extra stuff from hackage
11:10:10 <Cale> > let foo (a, b) = a + b in foo 1 2
11:10:11 <lambdabot>   2
11:10:20 <Cale> haha
11:10:22 <aristid> Cale: wtf?
11:10:24 <rwbarton> I should have used a * b
11:10:25 <Cale> > let foo (a, b) = a + b in foo (1, 2)
11:10:26 <lambdabot>   3
11:10:29 <dmwit> > let foo (a, b) = a ++ b in foo "no" "never"
11:10:29 <lambdabot>   Couldn't match expected type `(t, t)'
11:10:29 <lambdabot>         against inferred type `[GHC.T...
11:10:30 <benmachine> foo 1 2 = foo (1,1) 2 = (1 + 1) 2 = 2 2 = 2
11:10:37 <Cale> cute
11:10:37 <dcoutts> jsternberg: and you get a similar problem if you upgrade a core package via apt and it breaks other stuff that depended on the old version.
11:10:49 <stepcut> how do I get chrome to open haskell files in the browser instead of downloading them ?
11:10:53 <aristid> Cale: i don't even... wtf... what is happening?
11:10:56 <dcoutts> jsternberg: it's not a major problem, and it is easily detected, just means more rebuilding
11:11:06 <Cale> aristid: Look at the type of the parameters being given to foo
11:11:08 <benmachine> aristid: numeric literal polymorphism gone crazy
11:11:20 <Cale> foo takes a pair
11:11:21 <byorgey> aristid: lambdabot has instances for  Num a => Num (a,a)  and also  Num a => Num (b -> a)
11:11:32 <Cale> so  foo 1 2  must be  foo (1,1) 2
11:11:39 <aristid> > (1,2)+(2,2)
11:11:39 <lambdabot>   (3,4)
11:11:39 <shirt> do you guys try to keep haskell code less than 80 columns wide? i find it nearly impossible
11:11:43 <elliott> Cale: L.hs must be the worst thing in the world.
11:11:44 <Cale> and foo (1,1) = 1 + 1
11:11:48 <EvanR-work> shirt: yep
11:11:51 <byorgey> shirt: I do, yes
11:11:52 <Cale> so that's (1 + 1) 2
11:11:56 <EvanR-work> shirt: use 2 spaces
11:11:57 <byorgey> shirt: it often requires some creative indentation
11:11:58 <Cale> elliott: It's not L.hs
11:11:58 <benmachine> shirt: I tend to manage it (when I can be bothered)
11:12:02 <aristid> Cale: ooh.
11:12:05 <elliott> Cale: It's something L.hs imports
11:12:10 <elliott> Worst by proxy
11:12:15 <jsternberg> dcoutts: got it. right now I'm just trying to figure out what languages that provide a package manager do when a system package manager exists
11:12:18 <Cale> elliott: Well, it's just that we're importing stuff from the vector-space package
11:12:22 <ion> shirt: Split the function into two.
11:12:28 <Cale> But this isn't bad
11:12:33 <Cale> It makes complete sense
11:12:36 <benmachine> shirt: occasionally putting things in where-clauses helps (with readability, as well)
11:12:54 <benmachine> Cale: it makes complete sense in much the same way a brainfuck program does >_>
11:12:58 <Cale> foo 1 2 = foo (1,1) 2 = (1 + 1) 2 = 2 2 = 2
11:13:03 <dmwit> jsternberg: Do other languages provide more integration with the system package manager?
11:13:09 <dmwit> That seems Hard.
11:13:12 <elliott> Cale: I don't think a numeric instance for any kind of (,) makes sense.
11:13:16 <Cale> elliott: Sure it does
11:13:19 <benmachine> > let foo (a,b) = a + b in foo x y
11:13:19 <lambdabot>   Couldn't match expected type `(t, t)'
11:13:19 <lambdabot>         against inferred type `Simple...
11:13:22 <shirt> EvanR: is 2 spaces the agreed upon gold standard?
11:13:23 <jsternberg> dmwit: nope! but some provide no package manager!
11:13:24 <benmachine> > let foo (a,b) = a + b in foo x y :: Expr
11:13:24 <Cale> If R and S are rings then so is R x S
11:13:25 <lambdabot>   Couldn't match expected type `(t, t)'
11:13:25 <lambdabot>         against inferred type `Simple...
11:13:29 <benmachine> gr
11:13:37 <dmwit> jsternberg: Oh, okay. =)
11:13:37 <EvanR-work> shirt: dunno. but spaces sure are. as opposed to tabs
11:13:38 <Cale> With componentwise addition and multiplication
11:13:46 <Cale> So it makes sense to define a Num instance.
11:13:52 <Leif_Bork> Hi!
11:13:58 <byorgey> hi Leif_Bork
11:14:00 <elliott> Cale: Well, sure, it makes sense in that it's not nonsense.
11:14:07 <elliott> Cale: But not in the sense that I want it anywhere near me or it won't cause a bajillion bugs.
11:14:09 <ion> > (1 :: Integer, 2 :: Double) + 3
11:14:10 <lambdabot>   (4,5.0)
11:14:12 <Leif_Bork> I am very sorry to inform you, that I had a very serious error
11:14:17 <Cale> All the methods satisfy all the laws you'd expect
11:14:21 <jsternberg> dmwit: the languages without a package manager have the disadvantage that they're incredibly hard to maintain dependencies without one, but they also don't have the problem of the two package manager competing with each other
11:14:40 <Cale> So, you can't really expect it to cause bugs
11:14:43 <jsternberg> although I'd prefer the later problem to the former
11:15:05 <DanBurton> > fromIntegral 3 :: (Int, Int)
11:15:05 <lambdabot>   (3,3)
11:15:07 <byorgey> elliott: the worst that can happen is that code which would otherwise have given you a bug will have unexpected (but sensible) semantics.
11:15:15 <byorgey> s/bug/type error/
11:15:16 <roconnor> elliott: see the bottom of 4.4.3.1 in the Haskell 98 report
11:15:20 <elliott> byorgey: Yes.
11:15:22 <DanBurton> > fromIntegral 3 :: (Int, Double)
11:15:22 <lambdabot>   (3,3.0)
11:15:32 <elliott> byorgey: And?
11:15:33 <benmachine> byorgey: that's pretty bad, imo
11:15:38 <elliott> byorgey: I use Haskell because I want strong type checking.
11:15:45 <roconnor> elliott: I'm pretty sure that I somehow got seq to do something screwy with multi parameter functions
11:15:48 <Leif_Bork> When I run a module with tests I get this error: Tests.hs: /home/oa/Public/SP/dist/lib/sp-0.0/ghc-7.0.3/HSsp-0.0.o: unknown symbol `__stginit_spzm0zi0_SPziCache_'
11:15:57 <byorgey> yes, I agree.  I just personally happen to like those Num instances. =)
11:16:00 <Cale> But if you think about it, almost anything you define will turn some compile-time failures into success.
11:16:08 <elliott> roconnor: I was talking about the tuple introduction thing.
11:16:17 <roconnor> elliott: oh wait, you need to pattern match for the tuples to be introduced
11:16:32 <dmwit> Leif_Bork: Are you compiling with --make?
11:16:35 <benmachine> Cale: sure, but the question is how common the error, how bad the failure, etc. and how often is that actually what you meant
11:16:37 <elliott> roconnor: I really gotta see an example of code using this.
11:16:42 <roconnor> elliott: so I was wrong; there are no pattern matches in that paste
11:16:45 <Cale> If you define a new instance of literally any class, you're turning some compile time failures into programs which will run and produce potentially unexpected results!
11:16:57 <benmachine> when does anyone *use* Num (a,b)
11:17:05 <applicative_> stepcut, good question ... I notice mine is kind with raw .hs files on github e.g. https://raw.github.com/jgoerzen/hdbc/master/testsrc/TestSqlValue.hs so it's not impossible..
11:17:13 <Leif_Bork> dmwit: I use runhaskell to run my tests
11:17:38 <dmwit> Leif_Bork: Odd; could you paste a minimal example that doesn't work to hpaste.org?
11:17:38 <Cale> benmachine: Well, you have to admit it's at least convenient in terms of addition and multiplication by scalars :)
11:18:06 <Cale> > sum [(1,2),(30,40),(500,600)]
11:18:07 <lambdabot>   (531,642)
11:18:09 <elliott> roconnor: yeah, but I want to see an example of it anyway
11:18:13 <elliott> roconnor: because I've never heard of this at all :P
11:18:21 <benmachine> Cale: sooorta. but perl is "convenient" :P
11:18:25 <Leif_Bork> dmwit: Yes, I'll try to cut it down and hpaste! Thanks!
11:18:29 <DanBurton> sum [(1,2), 3]
11:18:31 <elliott> applicative_: github probably sends those as text/plain
11:18:34 <DanBurton> > sum [(1,2), 3]
11:18:34 <lambdabot>   (4,5)
11:18:38 <DanBurton> o_O
11:18:41 <Cale> > 100 * (4,5)
11:18:42 <lambdabot>   (400,500)
11:18:43 <elliott> Content-Type: text/plain; charset=utf-8
11:18:44 <elliott> Yep.
11:19:06 <applicative_> elliot, I see.
11:19:31 <rwbarton> > (4,6) / 2
11:19:32 <lambdabot>   (2.0,3.0)
11:19:44 <EvanR-work> > 100 :: (Int,Int)
11:19:44 <lambdabot>   (100,100)
11:19:55 <Cale> The fact that numeric literals can be treated as constant functions might be seen as a bit more confusing than this, but it's also a natural extension of it.
11:19:57 <EvanR-work> > 100 :: Complex
11:19:58 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
11:20:03 <wunki> ion: thanks, I added the function types, and now I see why ``foo3`` is the only function with one paremeter: https://gist.github.com/6540612b4feab776143f
11:20:44 <stribor> i am trying to create type
11:20:45 <dmwit> > 100 :: Complex Double
11:20:46 <lambdabot>   100.0 :+ 0.0
11:20:47 <stribor> Slol
11:20:59 <DanBurton> > sum [((1,2),(3,4)), (3,2), 5]
11:21:00 <lambdabot>   ((9,10),(10,11))
11:21:06 <stribor> i am trying to create type MyType  = (Int,Int)
11:21:09 <roconnor> elliott: I haven't recreated the strangeness yet :(
11:21:28 <elliott> roconnor: I take it it's still there in 2011? And GHC doesn't implement it?
11:21:39 <roconnor> I presume so
11:21:42 <Cale> > sum [((1,2),(3,4)), (50,60), 700]
11:21:42 <lambdabot>   ((751,752),(763,764))
11:21:47 <stribor> I would liek to make this type instance of class Show.....can someone point me on how to do that
11:22:01 <scooty-puff> can anyone think of a better way to do this: http://pastebin.com/zhFHshEy
11:22:04 <mauke> The paste zhFHshEy has been copied to http://hpaste.org/52106
11:22:14 <dmwit> stribor: That is already an instance of Show.
11:22:17 <Cale> stribor: That type synonym is already an instance of Show
11:22:28 <dmwit> stribor: If you want to declare a new instance, you will need to create a new type (not just a type alias).
11:22:35 <roconnor> elliott: I wonder if I can grep my logs
11:22:40 <Cale> stribor: because there's an instance (Show a, Show b) => Show (a,b) and an instance Show Int
11:22:55 <dmwit> stribor: For example, newtype MyKindOfPair = MyKindOfPair (Int, Int); instance Show MyKindOfPair where ...
11:23:07 <stribor> dmwit: how is that above already instance of class Show
11:23:46 <dmwit> scooty-puff: You don't need a class to have a type family.
11:24:02 <Cale> stribor: Because you didn't really define a new type, you defined a new name for an existing type
11:24:18 <Cale> stribor: and (Int, Int) is already an instance of Show
11:24:21 <dmwit> scooty-puff: You can just write "type family Size a; type instance Size Narrow = Word8; type instance Size Wide = Word16"
11:24:31 <stribor> i would like to be able to print this using show
11:24:42 <applicative_> elliott, yes, code.haskell.org is calling .hs files text/x-haskell This upsets Chrome, but not the other browsers, it seems
11:24:45 <rwbarton> > show (3,5)
11:24:46 <lambdabot>   "(3,5)"
11:24:48 <dcoutts> jsternberg: note that it's also possible to translate cabal packages into native packages, so you don't have to use the cabal tool as a package manager
11:25:00 <dmwit> stribor: as rwbarton demonstrates =)
11:25:18 <stribor> ok tx
11:25:44 <dmwit> scooty-puff: Other than that, the code you pasted looks pretty reasonable to me.
11:25:56 <scooty-puff> does having a class allow me to restrict where the associated type can be defined - i.e. if i export the class, but not the type?
11:26:03 <stribor> yeah but what if MyType = (SomeOtherType,SomeAnotherType)
11:26:12 <stribor> that is surely now instance of Show
11:26:12 <dmwit> scooty-puff: Personally I'd write the inverse of that function.
11:26:32 <stribor> ii meant not instance of show
11:26:50 <rwbarton> make SomeOtherType and SomeAnotherType instances of Show, then MyType will be as well
11:26:51 <elliott> stribor: Iff one of SomeOtherType or SomeAnotherType isn't an instance of Show.
11:26:53 <scooty-puff> i don't follow, you mean a Size class and an Operand at?
11:27:04 <willem> I was looking for a ctags generator but there seem so many (hasktags, hothasktags, GHC itself, ...). Which one would you suggest?
11:27:21 <dmwit> scooty-puff: Since "ILOAD :: a -> Insn (Wideness a)" is much more usable than "ILOAD :: Size a -> Insn a" when "Size" is not (necessarily) injective.
11:27:23 <stribor> can you give me example how i would make those instance of shiw
11:27:45 <rwbarton> well, what is SomeOtherType
11:27:46 <roconnor> elliott: ah got it
11:27:50 <scooty-puff> rules out bad usage, right?
11:27:56 <roconnor> > let {f :: Bool -> Bool -> Bool ; f True True = True} in seq (f undefined) 7
11:27:56 <lambdabot>   7
11:27:58 <scooty-puff> doing it the way you describe
11:28:03 <roconnor> > let {f :: Bool -> Bool -> Bool ; f True = \True -> True} in seq (f undefined) 7
11:28:04 <lambdabot>   *Exception: Prelude.undefined
11:28:08 <roconnor> ta da
11:28:20 <elliott> roconnor: I wasn't the one who asked for that part :)
11:28:20 <dmwit> scooty-puff: No, it just means you have to do less type ascription.
11:28:22 <elliott> I forget who was though
11:28:27 <scooty-puff> ok
11:28:37 <roconnor> [15:24] <elliott> roconnor: yeah, but I want to see an example of it anyway
11:28:45 <elliott> roconnor: That was about the tuple introduction thing.
11:28:50 <rwbarton> is this some kind of optimization and arity analysis gone awry, or is this report-specified
11:28:53 <roconnor> elliott: that is the example of the tuple introduciton thing
11:28:53 <elliott> Someone else definitely did ask for an example of distinguishing functions with seq though.
11:28:58 <dmwit> scooty-puff: You can't tell whether "ILOAD (32 :: Word8)" has type Insn Narrow or Insn a for some other a for which (Size a) happens to be Word8.
11:29:03 <wunki> ok, I think I get it now, could someone validate this logic, please: https://gist.github.com/6540612b4feab776143f
11:29:06 <stribor> well SomeOtherType = (Int,Int)....SomeAnotherType = (Int,Int,String0
11:29:08 <elliott> roconnor: Uh?
11:29:15 <elliott> roconnor: We are most definitely using different definitions of identical thing.
11:29:24 <roconnor> elliott: I mean, the fact that the behaviour is different is due to the tuple use
11:29:24 <elliott> stribor: Those have Show instances.
11:29:25 <elliott> s/thing/then/
11:29:35 <elliott> roconnor: I don't see any tuples there...
11:29:35 <stribor> k
11:29:45 <roconnor> elliott: well the tupples are used internally
11:29:51 <RaptorRarr> applicative_: So, monads can do less than applicatives because join removes possibilities for what monads might model?
11:29:53 <roconnor> elliott: I cannot exhibit it directly
11:29:59 <scooty-puff> dmwit: makes sense, thank you!
11:29:59 <elliott> roconnor: Right, I can accept that, but two things with different types and therefore calling conventions are hardly identical :P
11:30:12 <roconnor> elliott: they have identical types
11:30:17 <elliott> RaptorRarr: yes, but they can also do more, because they can join :)
11:30:26 <elliott> roconnor: Not the two test functions we were talking about
11:30:34 <elliott> in https://gist.github.com/6540612b4feab776143f
11:30:38 <rwbarton> fewer things are monads, but you can do more with a thing if you know it's a monad than if you just know it's an applicative
11:30:39 <elliott> a -> b -> c =/= (a,b) -> c
11:30:45 <roconnor> oh right
11:30:53 <roconnor> I meant my two f's have identical types
11:31:12 <roconnor> elliott: Ya, I was miskated about foo1 == foo3
11:31:20 <roconnor> elliott: only because foo1 doesn't use patterns
11:31:28 <elliott> roconnor: so
11:31:36 <elliott> foo True False = blah; foo' (True, False) = blah'
11:31:40 <elliott> roconnor: you contend these have the same type?
11:31:55 <roconnor> ah I see your point
11:33:08 <elliott> roconnor: thought I was losing my mind there :D
11:33:11 <roconnor> elliott: right
11:33:26 <elliott> like the haskell report lets f (a,b) work as f a b if it wouldn't type otherwise
11:33:35 <roconnor> elliott: foo1 True a = blah and foo2 True = \a -> blah are not the same
11:33:46 <roconnor> I guess I went too far to claim foo1 and foo3 are the same.
11:33:50 <stribor> whats the difference when i create type by doing ....type = .........or newtype = ..............
11:33:59 <elliott> roconnor: right
11:34:33 <Botje> stribor: you cannot give type class instances for "type" types
11:34:38 <roconnor> stribor: type is just a synonym, while newtype is a whole new "branded" data type; which may have its own different class instances, etc.
11:35:07 <stribor> so if i want my type tp be isnatnce of class Show i would haver to use newtype right?
11:35:17 <elliott> All the types you have mentioned are Show instances.
11:35:22 <elliott> If you want a /different/ instance, yes, you must use a newtype.
11:35:35 <rwbarton> and you'll also have to convert from/to the newtype
11:35:44 <elliott> OTOH,
11:35:50 <elliott> stribor: If your type is a tuple, "data" is better than "newtype".
11:35:57 <elliott> (a,b,c) --> data Foo = Foo a b c
11:36:29 <stribor> ok
11:36:31 <stribor> thank you
11:37:24 <rwbarton> stribor: do you know C?
11:37:35 <stribor> rwbarton: yes
11:37:57 <rwbarton> "type" is like "typedef", and "newtype" is more or less like making a struct with a single field
11:38:15 <stribor> oh ok thats more clear
11:38:32 <stribor> rwbarton: thank you
11:38:45 <scooty-puff> dmwit: is there a way to define bijective class instances/associated types, i.e. with fundeps a -> b, b -> a?
11:39:27 <dmwit> scooty-puff: Good question.
11:39:33 <dmwit> scooty-puff: Fundeps could do.
11:39:40 <dmwit> scooty-puff: Alternately, you can write things like
11:39:52 <dmwit> a ~ F (G a) => some type involving a
11:40:35 <aristid> scooty-puff: but with type families instead of fundeps?
11:40:46 <scooty-puff> if possible, partly just wondering
11:41:05 <dmwit> So, yeah, if you want to use type families, the way to do it is to put type equality constraints in your context.
11:41:11 <scooty-puff> mostly to avoid having OperandType a b => ... in the data declaration
11:41:17 <scooty-puff> ok
11:41:22 <Cale> class (a ~ G (F a)) => C a where type F a; type G a
11:41:35 <dmwit> Ah, cool.
11:41:46 <Leif_Bork> dmwit: When I broke it down like you said, I solved it. The problem was solved when I exposed a module that was used by other exposed modules. Maybe this is a bug, I don't know! But thank you! I'll pray to Baby Jesus, that you'll have good looking kids, without teeth problems, and a spouse that will stay reasonable.
11:41:54 <dmwit> Cale: Then you can even write both constraints.
11:42:07 <dmwit> class (a ~ G (F a), a ~ F (G a)) => C a where ...
11:42:21 <dmwit> Leif_Bork: =)
11:42:38 <dmwit> Leif_Bork: Perhaps you should just list that module in other-modules (if you don't want to expose it).
11:42:40 <sm> is there any way for a cabal package to include some files that are to be available at compile time ?
11:43:00 <dmwit> sm: Yes! One second while I look it up.
11:43:03 <dcoutts> sm: what do you mean exactly?
11:43:07 <Cale> For some reason I want to write that second constraint as F (G a) ~ a instead ;)
11:43:32 <dmwit> dcoutts: Like C header files and such, I assume.
11:43:57 <dmwit> sm: Use extra-source-files
11:44:12 <Cale> http://upload.wikimedia.org/wikipedia/en/8/8d/AdjointFunctorSymmetry.png -- might have something to do with the directions of the arrows in this diagram ;)
11:44:35 <sm> I want to ship css/js/image files which can be seen at build time by yesod's $(static) or $(embed) TH directives. getDataFileName runs in IO.. I can do this in TH, but I need the files to actually be accessible at build time
11:44:48 <sm> just getting the path isn't enough
11:45:33 <dmwit> When you say "ship", you mean via "cabal sdist" or so?
11:45:43 <dmwit> If so, then extra-source-files sounds like just the thing.
11:46:14 <sm> dmwit: I mean when you cabal install hledger-web, that package should (a) include the static web files, and (b) should be able to access them as it builds (required by yesod)
11:47:16 <dmwit> Okay, but "cabal install" just takes the .tar.gz that's on Hackage.
11:47:22 <dmwit> So the question is how to build the .tar.gz.
11:47:30 <dmwit> One way to build it is via "cabal sdist".
11:47:42 <dmwit> If you're building it another way, you'll need to say what that other way is to get better advice.
11:48:02 <sm> dmwit: no, including the files is easy, the hard part is reading them at build time
11:48:15 <dmwit> Then I don't understand.
11:48:41 <dcoutts> sm: the package gets built with the current dir set as the package root, so files in the build tree are accessible from there
11:49:10 <sm> really ? great. I couldn't see them so figured they weren't there yet - I'll try harder
11:49:15 <Leif_Bork> dwmit: Aah, thanks!
11:50:29 <dcoutts> sm: as dmwit says, it's just a matter of including the files you want in the package tarball, and if you're using cabal sdist to make the tarball then extra-source-files is the way to get extra files included into the source tarball
11:50:53 <sm> not data-files ?
11:52:18 <sm> what is the difference, anyway ? I think they are the same except with data-files you can also look up the paths at runtime
11:52:25 <sm> and access them at runtime
11:52:30 <sm> of course
11:54:59 <sm> I think data-files aren't present in the build tree, only accessible later; and with extra-source-files it's vice-versa
11:58:45 <sm> dmwit, dcoutts: that helped, thanks!
12:00:22 <illissius> ...I was wondering: AFAIK, on AMD64, GHC uses the bottom 3 bits of a pointer for tagging... but on current AMD64, the full top 16 bits are unused. could those also be used for tags, is there a reason why they can't, or is this just a "no one's done the work yet" thing?
12:00:22 <lambdabot> illissius: You have 1 new message. '/msg lambdabot @messages' to read it.
12:00:45 <illissius> ooh. that's never happened before
12:01:19 <dmwit> Probably a "no one's done the work yet" thing.
12:01:37 <dcoutts> illissius: I know physical pointers on amd64 are only 40 bits or something, but arn't pointers in the virtual address space really 64bit ?
12:01:39 <dmwit> Got any ideas for how to use the extra bits?
12:03:47 <ash__> So.. I found an older library I am trying to compile and the .cabal file has some problems, How do you hide or specify where a module is from? I am getting a problem because its trying to import Numeric but it says that exists in both base and haskell98
12:03:59 <illissius> dcoutts: hmm. I wasn't paying attention to (and don't really know the details of, tbh) the physical vs. virtual address difference.
12:04:01 <illissius> http://en.wikipedia.org/wiki/AMD64#Virtual_address_space_details
12:07:23 <illissius> dmwit: currently it uses the bottom 2-3 to store the 'constructor id' of the object it's pointing to, assuming it's small enough to fit, otherwise it has to look at the info table (afaik not really a ghc hacker etc). but everything would be small enough to fit into 16.
12:07:46 * hackagebot Unixutils 1.44 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.44 (DavidFox)
12:08:50 <tsousa> isPalindrome x = if reverse x == x then True  I cannot say this?
12:09:24 <ash__> tsousa: you need an else
12:09:27 <hjulle> tsousa: Why the if?
12:09:57 <tsousa> hjulle, i need to check is x is a palindrome
12:10:06 <tsousa> so if x == reverse x then True
12:10:14 <ornicar_> if True then True.
12:10:31 <mzero> you'd say   either    isPalendrome x = if reverse x == x then True else False     --- note the else clause
12:10:31 <mzero> OR
12:10:40 <mzero> you'd just say    isPalendrome x = reverse x == x
12:10:49 <mzero> no reall ned for the if
12:10:54 <tsousa> parcial applyed functions right?
12:10:59 <mzero> no
12:11:06 <mzero> there is nothing partially applied there
12:11:18 <mzero> the result of    ==    is a Bool - either True or False already
12:11:31 <rvn_> @pl isPalendrome x = reverse x == x
12:11:31 <lambdabot> isPalendrome = (==) =<< reverse
12:11:33 <mzero> so no real need to apply if then else
12:11:49 <tsousa> mzero, your secound exemple doesnt not work
12:11:56 <aristid> hmm, i think (==) <*> reverse looks nicer.
12:12:13 <hpaste_> SomeAuthoir pasted “someTitle” at http://hpaste.org/52107
12:12:23 <mzero> > let isPal x = reverse x == x in (isPal "abcba", isPal "bobs")
12:12:23 <lambdabot>   (True,False)
12:12:28 <mzero> looks like it works
12:12:33 <stribor> guys why it is forcing me to have only one paramerthar when i have 2 paramethars
12:13:22 <brisingr> I'm trying to do a permutation function with extra conditions
12:13:26 <brisingr> namely,
12:13:44 <brisingr> determine all permutations of [1..n] where no two adjacent elements are consecutive
12:14:00 <brisingr> now I've managed to do that, but it's terribly inelegant
12:14:08 <brisingr> and this seems like prime suspect for monads
12:14:38 <RaptorRarr> You're generating the permutations?
12:14:45 <hjulle> [(==) <*> reverse] I'm always confused by the ((->) r) monad :/
12:14:57 <brisingr> yes
12:15:10 <tsousa> http://dpaste.com/626593/ what is the problem?
12:15:15 <ion> hjulle: http://heh.fi/haskell/functors/#function-instance may or may not be helpful.
12:15:28 <brisingr> for example, f [1,2,3,4] = [[2,4,1,3], and others]
12:15:37 <Cale> hjulle: (f <*> g) x = f x (g x)
12:15:43 <dmwit> tsousa: eliminate all the ['s and ]'s
12:15:55 <dmwit> tsousa: and the isPalindrome [] = False line
12:15:57 <Cale> So ((==) <*> reverse) x = (==) x (reverse x)
12:16:01 <dmwit> Because [] is clearly a palindrome.
12:16:04 <Cale> = x == reverse x
12:16:39 <ash__> tsousa: http://dpaste.com/626596/
12:16:44 <brisingr> on an unrelated note, how do I apply >>= n times?
12:16:48 <mzero> tsousa: [a] only matches lists with one elmeent
12:17:06 <dmwit> ash__: No, that's wrong.
12:17:16 <ash__> err ya Just noticed that too
12:17:19 <dmwit> isPalindrome x = reverse x == x -- not reverse [x] == [x]
12:17:41 <ion> brisingr: Do you mean something like foldr (>=>)?
12:17:42 <ash__> ya sorry
12:17:57 <tsousa> humm thanks
12:17:57 <brisingr> ion: possibly
12:17:59 <dmwit> :t foldM
12:18:00 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:18:05 <tsousa> next exercise
12:18:13 <brisingr> cool, dmwit
12:18:23 <brisingr> now I'm still having trouble with the permutation stuff
12:18:26 <dmwit> :t replicateM
12:18:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:18:52 <brisingr> the solution (code lost) I've found is terribly inelegant
12:19:19 <brisingr> so basically determine all permutations of a list that satisfy certain conditions
12:19:40 <rahul> :t (.).(.)
12:19:40 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:19:58 <mzero> general thought: If you are looking for Haskell help while doing problem sets or school work -- if you let us know most people here will give answers slanted to helping you understand what's going on --- otherwise we tend to give working terse code!  :-)
12:20:19 <brisingr> not actually school work
12:20:26 <brisingr> but yeah, I'm trying to understand
12:20:49 <dmwit> > let perms xs = do { x <- xs; permsAvoiding x (delete x xs) }; permsAvoiding x [] = [[x]]; permsAvoiding x xs = do { y <- xs; guard (y /= x); rest <- permsAvoiding y (delete y xs); return (y:rest) }; in perms [1,1,2,3]
12:20:50 <lambdabot>   [[2,1,3,3],[2,3,1,1],[3,1,2,2],[3,2,1,1],[2,1,3,3],[2,3,1,1],[3,1,2,2],[3,2...
12:21:02 <dmwit> Ah, nasty.
12:21:05 <dmwit> Doesn't check the final time.
12:21:41 <dmwit> oh, no, just a bug
12:23:11 <brisingr> hm
12:23:13 <dmwit> > let perms xs = do { x <- xs; permsAvoiding x (delete x xs) }; permsAvoiding x [] = [[x]]; permsAvoiding x xs = do { y <- xs; guard (y /= x); rest <- permsAvoiding y (delete y xs); return (x:rest) }; in perms [1,1,2,3]
12:23:13 <lambdabot>   [[1,2,1,3],[1,2,3,1],[1,3,1,2],[1,3,2,1],[1,2,1,3],[1,2,3,1],[1,3,1,2],[1,3...
12:24:01 <brisingr> > let perms [] = [[]]; perms xs = [x:yx | x <- xs, ys <- perms (delete x xs)]; in perms [1..3]
12:24:01 <lambdabot>   Not in scope: `yx'
12:24:05 <RaptorRarr> Is there a function that will produce tuples of each element in a list with the remaining list?
12:24:07 <brisingr> > let perms [] = [[]]; perms xs = [x:ys | x <- xs, ys <- perms (delete x xs)]; in perms [1..3]
12:24:07 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
12:24:11 <brisingr> okay
12:24:22 <brisingr> now
12:25:02 <brisingr> I'm trying to do the filtration "backtracking-style" i.e. immediately discard when an incorrect sequence is found
12:25:05 <brisingr> let's see
12:25:12 <RaptorRarr> @type deleteAt
12:25:13 <lambdabot> Not in scope: `deleteAt'
12:25:17 <brisingr> (actually it's so much easier to think if you present it_
12:25:28 <RaptorRarr> @hoogle Int -> [a] -> [a]
12:25:28 <lambdabot> Prelude drop :: Int -> [a] -> [a]
12:25:28 <lambdabot> Prelude take :: Int -> [a] -> [a]
12:25:28 <lambdabot> Data.List drop :: Int -> [a] -> [a]
12:28:34 <RaptorRarr> > let elementsRemoved = f [] where f ps [] = []; f ps (n:ns) = (n, reverse ps ++ ns):f (n:ps) ns in elementsRemoved [1..5]
12:28:36 <lambdabot>   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
12:34:42 <roconnor> maybe [] toList . fmap Data.List.poisitions . Data.List.PointedList.fromList
12:34:58 <roconnor> maybe [] toList . fmap Data.List.PointedList.positions . Data.List.PointedList.fromList
12:35:02 <Veinor> has anybody in here used groundhog?
12:35:07 <Veinor> it looks pretty neat
12:35:08 <roconnor> RaptorRarr: ^^
12:40:43 <MatrixFrog> veinor: what is it? do you have a link?
12:40:53 <Veinor> http://hackage.haskell.org/package/groundhog
12:40:59 <Veinor> database interface thingy
12:41:23 <Veinor> seems nicer than haskelldb
12:42:48 * hackagebot haddock 2.9.4 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.9.4 (DavidWaern)
12:45:22 <Veinor> actually, persistent looks neat too
12:49:02 <brisingr> okay, done
12:50:01 <RaptorRarr> roconnor: Thanks
12:50:08 <brisingr> okay, done
12:50:36 <brisingr> a piece of advice: don't forget that list comprehensions are monadic; it'll save you from reimplementing them
12:51:53 <aristid> Veinor: it looks like groundhog doesn't offer you a lot of power. if i see right, there are no joins, for example
12:53:59 <Veinor> ah, true
12:56:08 <Veinor> i like the strong typing of stuff like groundhog and haskelldb but i don't like the sheer amount of boilerplate-y code haskelldb requires
12:56:19 <MatrixFrog> quote of the day: Haskell allows a module to export other modules. Scala requires you to stick your finger in your left ear to do this
12:56:26 <MatrixFrog> (from http://programmers.stackexchange.com/questions/51245/what-kind-of-things-are-easy-in-haskell-and-hard-in-scala-and-vice-versa )
12:58:24 <aristid> MatrixFrog: dunno, what's so funny about it?
12:58:48 <MatrixFrog> i've never used scala but that just sounds unpleasant
13:01:38 <JoeyA> If I want to use a package with a C library dependency on Windows, how do I install the C library?
13:02:12 <jsternberg> wow, talk about clearing a room
13:02:31 <JoeyA> Is it because I said the "C" word?
13:02:32 <MatrixFrog> hehe. i don't think there is a general answer JoeyA. it depends on what lib it is
13:02:34 <aristid> MatrixFrog: i don't know, of all the things that haskell allows you to do, exporting modules seems like it's one of the less important
13:02:47 <Veinor> i might just stick with hdbc for now
13:02:55 <Veinor> which seems... bad
13:03:00 <MatrixFrog> aristid: yes, but it was the one that was phrased in the most amusing way, that's all
13:03:00 <JoeyA> Specifically, I'm planning to write a binding for libssh2.
13:03:19 <MatrixFrog> JoeyA: yes, if by "the C word" you mean "Windows" :P
13:03:22 <aristid> MatrixFrog: ok:)
13:03:40 <geheimdienst> JoeyA: i guess i'd find the website of libssh2 and check if they have any installation instructions for windows. failing that, you might google "installing libssh2 on windows"
13:04:02 <JoeyA> So for a new library, how does one declare a lib dependency in the .cabal file such that it will work on Windows?
13:08:08 <MatrixFrog> i guess i would say, look at some other projects for examples
13:31:15 <shirt> what's a good work for an operation that does nothing?
13:32:43 <Axman6> no-op?
13:32:58 <MatrixFrog> yeah, "no op" would be the standard answer
13:33:11 <MatrixFrog> unless you mean a function that returns its input unchanged, that would be "id"
13:33:59 <rahul> Where is lambdabot? :(
13:35:55 <DukeDave> Hey gang, is there an alternative way to express this: "mCreate >>= \x -> mModify x >> mUse x".
13:36:28 <DukeDave> I'm actually using this: dateTimeCreate >>= \d -> dateTimeNow d >> datePropertyCreate "Date label" "date" d
13:36:34 <shirt> no-op is good, but what are other options?
13:36:51 <geheimdienst> cale: ping? lambdabot is wasting her time on the PS3 again
13:36:53 <rahul> DukeDave: do { x <- mCreate; mModify x; mUse x }
13:37:01 <rahul> Is that what you're after?
13:37:10 <DukeDave> rahul: Ha, yeah I had it in do notation previously
13:37:21 <engla> DukeDave: \x -> mModify x  is just the same as mModify
13:37:21 <DukeDave> I just thought it might be known pattern
13:37:39 <rahul> engla: You need x later
13:37:44 <rahul> engla: in mUse
13:37:53 * DukeDave nods
13:37:54 <engla> oh, ok
13:38:52 <rahul> How to make this point-free?
13:39:01 <rahul> f x = g (h x)  (i x)
13:39:22 <erus`> Write a 100 line Haskell program to solve a non trivial problem - someone on IRC writes and tests a 1 line solution in 30 seconds
13:39:23 <geheimdienst> DukeDave: possibly you could do something with "liftM2 (&&&)" to apply both functions to x ... but i'm not sure if that makes anything clearer :)
13:39:49 <rahul> One way: f = uncurry g . (h &&& i)
13:39:50 <erus`> I'm going back to C++
13:39:52 <DukeDave> geheimdienst: That's exactly the kind of obfuscation I'm looking for :)
13:40:07 <geheimdienst> (reminder: "(succ &&& pred) 42" gives a tuple (43,41))
13:40:16 <RaptorRarr> @pl let f x= g (h x) (i x) in f
13:40:30 * RaptorRarr pines for lambdabot
13:40:32 <rahul> RaptorRarr: lambdabot is sleeping :)
13:40:44 <RaptorRarr> Let's see then.
13:40:56 <DukeDave> geheimdienst: Arrows are on my 'to assimilate' list..
13:41:07 <RaptorRarr> Oh, I see you got it.
13:41:10 <roconnor> erus`: won't that mean that you write a 1000 like C++ program to solve a non trivial problem and then have someone on IRC write and test a 1 line Haskell solution in 30 seconds?
13:41:30 <geheimdienst> DukeDave: arrows give me the willies. (&&&) is the only function in that whole module that i understand
13:41:33 <erus`> yeah but at least noone on #c++ will write a 1 line solution
13:41:47 <rahul> RaptorRarr: I think there's a better way.
13:41:48 <tac-tics> erus`: Don't let the Pro-golfers intimidate you.
13:42:07 <tac-tics> Golf is not an admirable trait in a good programming language
13:42:21 <DukeDave> erus`: I'm intrigued, can you post it?
13:42:26 <erus`> tac-tics: half the time their solution is more elegant too :P
13:42:37 <DukeDave> I'm forever getting led down the wrong path
13:42:54 <erus`> DukeDave: i made some 'snail problem' program a little while ago
13:42:55 * DukeDave is always a victim of the XY problem
13:43:15 <DukeDave> (and I'm a lot more weary since I discovered that it has a name)
13:43:30 <roconnor> I am reminded of the google treasure hunt to count the number of monotone paths from one corner of a grid to the opposite corner.
13:43:47 <roconnor> lots of people were writing complex dynamic programming solutions
13:43:59 <roconnor> I wrote (n + m) `choose` n
13:44:07 <roconnor> er
13:44:12 <roconnor> ya
13:44:34 <erus`> did you win the treasure?
13:45:01 <roconnor> the treasure was the ability to apply to google for a job. :^)
13:45:35 <erus`> wow the pirates had it easy
13:45:55 <RaptorRarr> Haha
13:46:10 <Veinor> roconnor: hahahah
13:46:45 <monochrom> nice, now I can suggest to beginners "are you solving the XY Problem?" :)
13:47:24 <aristid> :t choose
13:47:37 <roconnor> what is the XY problem?
13:48:01 <aristid> @hoogle choose
13:48:14 <aristid> NO LAMBDABOT?
13:48:17 <MatrixFrog> nope :(
13:48:21 <aristid> roconnor: what is the type of choose?
13:48:34 <homie> binomial
13:48:51 <aristid> oh
13:49:44 <tromp> of course, a common way to compute choose() is exactly by counting paths: pascal  = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
13:50:26 <Jafet> choose n r | 0 <= r && r <= n = product [r..n] `div` product [1..r]
13:50:28 <roconnor> @type \n m -> product [n-m+1 .. n]
13:50:34 <c_wraith> the XY problem is asking for help doing Y when you really want help doing X, because you think doing Y is the best way to do X.  Very common.
13:51:00 <roconnor> oh wait that isn't right
13:51:04 <roconnor> well, the type is right :P
13:51:14 <Jafet> Damn type system
13:53:16 <yitz> preflex seen Cale
13:53:16 <preflex>  Cale was last seen on #haskell 1 hour, 37 minutes and 15 seconds ago, saying: = x == reverse x
13:58:32 <DukeDave> Here's one for you: Can I use Typeable to 'read' a string and cast it to a type I only know at run time?
13:58:57 <turrosec> haskell sucks
13:59:08 <plathrop> lol
13:59:15 <yitz> coward
13:59:21 <plathrop> lazy troll - that's somewhat... appropriate.
13:59:24 <erus`> preflex: seen kmc
13:59:25 <preflex>  kmc was last seen on #haskell-blah 15 hours, 57 minutes and 15 seconds ago, saying: ok
13:59:30 <blackdog> well, if haskell can do anything...
13:59:39 <erus`> wow 15 hours logged out
13:59:41 <erus`> new record?
14:00:14 <RaptorRarr> preflex: seen lambdabot
14:00:14 <preflex>  lambdabot was last seen on #haskell 1 hour, 31 minutes and 39 seconds ago, saying:   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
14:00:37 <ion> preflex: seen preflex
14:00:38 <preflex>  what
14:00:43 <JoeyA> That sounds like something lambdabot would say.
14:01:08 <dibblego> yo dmwit
14:01:41 <yitz> interesting, lambdabot keeled over only a few minutes after Cale left
14:01:44 <Jafet> preflex, tell preflex you rock
14:01:45 <preflex>  what
14:02:46 <RaptorRarr> preflex, preflex preflex preflex
14:03:07 <yitz>  what
14:03:12 <RaptorRarr> That's actually a valid English sentence.
14:03:27 <RaptorRarr> yitz: Heheh
14:03:51 <Cale> huh...
14:03:56 <erus`> to anyone who reads reddit: Does node.js cure or cause cancer now?
14:04:01 <Cale> sshing into lambdabot's machine seems slow
14:04:13 <Cale> erus`: Probably causes it. I dunno.
14:04:14 <RaptorRarr> erus`: It was the original cause of cancer, but it's become a cure.
14:04:22 <drdo> erus`: pretty sure it's harmful
14:04:23 <hpc> erus`: neither, but it may increase your risk of heart attack or stroke
14:04:32 <Cale> ssh: connect to host lambdabot port 22: No route to host
14:04:34 <hpc> do not use while having sex while operating heavy machinery
14:04:40 <Jafet> Nope, it definitely decreases your strokes
14:05:01 <drdo> What kind of stroking are you talking about there?
14:05:06 <RaptorRarr> hpc: Haha
14:05:32 <Cale> ^^ lots of ping timeouts going on too
14:05:52 <yitz> Cale: traceroute?
14:06:08 <hpc> Cale: λbot is down, in case you haven't noticed :P
14:06:24 <Cale> I have noticed. I can't seem to ssh back in to bring it up again
14:06:36 <hpc> oh, that's a problem
14:06:36 <zmv> > 2 + 2
14:06:39 <zmv> ):
14:06:46 <ion> 4
14:06:50 <yitz> Cale: is it still on lispy's machine?
14:06:51 <aristid> Cale: it isn't your own machine, is it?
14:06:57 <zmv> ion: HOW DID YOU DO THAT? :P
14:07:07 <Cale> It's not my own machine. It's lispy's virtual hosting.
14:07:27 <drdo> zmv: by copy pasting into a local ghci of course
14:07:39 <hpc> one would expect a virtual host to have better uptime
14:07:39 <zmv> drdo: oh, ofc
14:07:50 <zmv> drdo: stupid question, indeed.
14:07:52 <Jafet> ghci doesn't cut it. You need to paste into a local lambdabot to do that.
14:08:06 <erus`> yeah ghci takes a good 3 mins to start
14:08:13 <Cale> hpc: The weird thing is that lambdabot often doesn't stop running, or indeed notice that it's been disconnected from the network at all.
14:08:25 <mm_freak> i'm teaching haskell to a total programming newbie, and i'd like to save her from the occasional total system crash by setting something like -M256m by default…  is there some way to do this via e.g. environment variables or a userwide configuration file without her noticing it?  i'd like not to confuse her with such details for now
14:08:25 <yitz> and ghci doesn't run caleskell out of the box
14:08:26 <hpc> Cale: my bot used to do that too
14:08:40 <hpc> Cale: the fix is, you can send PINGs to the irc server, and it will PONG back to you
14:08:47 <hpc> so i PING the server every time it PINGs me
14:08:54 <hpc> er, every minute, i mean
14:08:55 <RaptorRarr> lispy was one of the ping timeouts just a minute ago.
14:09:02 <Ke> or you can add timeout to your main loop
14:09:04 <Cale> I'm not even really sure why that should be necessary.
14:09:14 <Jafet> mm_freak: .ghci?
14:09:22 <yitz> preflex: seen lispy
14:09:23 <Cale> Aren't TCP connections supposed to handle noticing that sort of thing?
14:09:23 <preflex>  lispy was last seen on #haskell 4 days, 7 hours, 55 minutes and 27 seconds ago, saying: sweet, now my raytracer can dump to a .bmp file
14:09:24 <mm_freak> Jafet: for compiled programs
14:09:31 <Jafet> Or add a ulimit directive to bashrc
14:09:38 <ion> hpc: Virtual hosts have virtual uptime.
14:09:39 <hpc> Cale: it's easier to catch a broken handle that way than it is to keep track of the time :P
14:09:50 <DukeDave> Boo, why the hate: cast "123" :: Maybe Int     is    Nothing
14:10:02 <Cale> DukeDave: Obviously
14:10:04 <aristid> Cale: TCP can take a while to notice that kind of stuff
14:10:04 <hpc> :t cast
14:10:10 <hpc> D:
14:10:15 <Cale> DukeDave: cast will only succeed when its types are the same
14:10:15 <hpc> DukeDave: try it with unsafeCoerce ;)
14:10:20 <Jafet> Typeable a => a -> Maybe b
14:10:21 <zmv> no lambdabot, hpc
14:10:23 * Jafet guessed
14:10:33 <mm_freak> Jafet: you can specify default RTS options using a GHC flag, but i don't know how to set default GHC flags
14:10:40 <DukeDave> Cale: Oh, that's boring :(
14:10:43 <aristid> Cale: make lambdabot easier to set up and the channel will have 10 of them
14:10:48 <Cale> cast x gives Nothing unless a ~ b, in which case it gives Just x
14:10:57 <mm_freak> i'd like not to use ulimit, but only the RTS, if even only for the sake of a useful error message
14:11:04 <RaptorRarr> @botsnack
14:11:07 <c_wraith> Cale: or unless a Typeable instance lies
14:11:08 <Jafet> lambdabot isn't difficult to set up. The channel doesn't need 9.9 of them.
14:11:11 <ion> Make lambdabot distributed
14:11:27 <hpc> a distributed bot would be a nightmare
14:11:48 <Jafet> mm_freak: isn't ghc a shell script
14:11:49 <yitz> mm_freak: shell alias?
14:11:53 <DukeDave> Cale: So, I'm trying to find some way to read a string in to a type which I only know at run time
14:11:59 <Jafet> But an alias is better.
14:12:08 <mm_freak> yitz: wouldn't work from Makefiles
14:12:22 <ion> unsafeCoerce :-P
14:12:22 <mm_freak> indeed, i could just put a 'ghc' symlink
14:12:27 <hpc> oh god, what would it take to write a compiler with just bash and the GNU utils?
14:12:27 <Jafet> Or make your own shell script and add it to her PATH.
14:12:29 <Cale> No matter where I try to ssh in from, the traceroute to lambdabot's machine seems to stop very early on.
14:12:34 <hpc> how many lines?
14:12:36 <Cale> (in one or two hops)
14:12:40 <mm_freak> hpc: LSD
14:12:44 <RaptorRarr> hpc: Do the GNU utils include gcc?
14:12:51 <hpc> RaptorRarr: no :P
14:13:13 <erus`> Has anyone tried golang in here?
14:13:22 <RaptorRarr> hpc: You could probably make some simple lisp-like language with shell script.
14:13:29 <erus`> i see similarities between classes and interfaces
14:13:31 <Cale> erus`: I haven't exactly tried it, but I read about it and decided it was extremely boring
14:13:33 <hpc> RaptorRarr: ah, indeed
14:13:47 <mm_freak> everybody seems to talk about google go, but when i looked at it it really just looked like yet another java clone
14:13:53 <Jafet> RaptorRarr: it doesn't count unless it has continuations
14:13:56 <Cale> It's less than a Java clone
14:14:14 <hpc> RaptorRarr: i suppose the shortest would be "#!bash bash"
14:14:19 <erus`> Cale: it has first class functions and nice channels
14:14:21 <RaptorRarr> Jafet: Well, I mean just as a bootstrap to compile stuff. You could probably make an assembler off of that and so on.
14:14:25 <Cale> It's possibly a slightly better C than C.
14:14:38 <mm_freak> Jafet: that would be a requirement of scheme, but not of lisp in general…  and even with scheme you can just not provide a call/cc construct
14:14:40 <erasmas> DukeDave: do you know the types that the string might be converted to? I've created a Cell data type for csv parsing, in the form CellStr Text | CellInt Integer and so on.
14:14:43 <aristid> mm_freak: google go and node.js seem to be some of the favorite scapegoats of functional programmers
14:14:44 <Jafet> Eh, it's hard to be better at C than C.
14:14:54 <hpc> aristid: i thought java was...
14:15:08 <RaptorRarr> Java is the scapegoat of rubyists.
14:15:08 <mm_freak> Cale: then what's with all that hype around it?
14:15:13 <hpc> go and node.js try too hard to suck; java is a natural :P
14:15:16 <Cale> mm_freak: I have no idea.
14:15:27 <mm_freak> probably just because it's google
14:15:29 <geheimdienst> erus`: have a look at this article :) http://www.cowlark.com/2009-11-15-go/ be sure to read the last section "so what is brand x" for the punchline
14:16:22 <erus`> wow i have written a couple of libraries in go and i didnt know you could name return values
14:16:32 <erus`> i dont see why you would want to though...
14:16:52 <mm_freak> erus`: prolog allows and in fact requires you to name your result values since ages ;)
14:17:46 <mm_freak> erus`: you also frequently give results names in haskell:  myFunc = result where …
14:18:04 <mm_freak> (ok, i don't know whether you do it, but i do)
14:18:47 <erus`> this is true
14:18:53 <aristid> mm_freak: myFunc x y z = go where ... <- for nicer recursion?
14:19:13 <mm_freak> aristid: value recursion mostly
14:19:15 <monochrom> where go = myFunc x y z :)
14:19:38 <erus`> bottom = myFunc 1 2 3
14:19:56 <mm_freak> a common pattern using the 'vector' library:  myFunc size = vec where vec = V.generate size f; f ix = …
14:19:56 <aristid> monochrom: i think where go = go would be more efficient ;)
14:20:18 <mm_freak> that way 'f' can refer back to 'vec'
14:20:32 <aristid> mm_freak: why not just myFunc size = V.generate size f where f ix = ...?
14:20:35 <aristid> oh
14:20:39 <Cale> foldTree t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
14:21:10 <mm_freak> aristid: sharing…  it lets you build vectors both elegantly and efficiently
14:21:22 <mm_freak> you can view it as a form of memoization
14:28:57 <yitz> Cale: traceroute to linode.com shows that they are located at theplanet in dallas
14:30:00 <yitz> Cale: my isp uses level3.net to get there. level3.net is not even attempting to get to lambdabot - it doesn't respond to those requests. weird.
14:33:00 <yitz> Cale: yeah, tried from a vm i have in nj - also goes via level3.net. that seems to be where the problem lies.
14:34:34 <hpc> Cale: do you just need an ip address?
14:34:57 <hpc> i seem to be able to see linode
14:35:41 <yitz> hpc: me too, but not the specific machine lambdabot is on. packets to it get dropped by level3.net, before they even get near linode.
14:40:38 <Cale> hpc: See if you can find a path to 74.207.243.105
14:41:38 <conal> oh, urg. i just noticed that LYAH reinforces the common confusion between functions and definitions. :(
14:41:57 <hpc> Cale: tracing
14:42:28 <geheimdienst> cale: goes through something called telia.net for me, the step after that fails
14:42:57 <hpc> goes through 68.1.4.139 here, then everything starts not responding
14:44:02 <yitz> there's actually a linode vm belonging to a client i can log into. turns out to be in a different data center though. drat.
14:45:26 <yitz> geheimdienst: yeah telia.net is a major backbone in eu. after that you're probably hitting level3.net. try traceroute linode.com and you'll see.
14:45:49 <hpaste_> “/dev/humancontroller” pasted “restricted IO, enforcing read-only access, write-only access, or no access, at compile time; no code extensions used” at http://hpaste.org/52114
14:45:56 <DevHC> dmwit: http://hpaste.org/52114
14:46:03 <geheimdienst> yitz: i can load the linode.com webpage by the way. seems like only some of their datacenters are affected
14:46:39 <yitz> geheimdienst: looks like lambdabot's vm is in the same data center as linode.com
14:47:06 <Feuerbach> how to prevent GHC from eta-expanding a function? ie. make it treat (f x = \y -> ..) as a function of arity 1
14:47:48 <benmachine> Feuerbach: why do you want to?
14:47:50 <c_wraith> Feuerbach: it already doesn't do that, in the few cases where the difference is observable in any way
14:48:05 <benmachine> I think if you put a let in, GHC will be reluctant to swap the two
14:48:22 <Feuerbach> benmachine: I hope that it'll be faster. In my case, there's some work being done outside of the lambda
14:48:40 <benmachine> Feuerbach: ah, can you put that work in a let-statement?
14:49:04 <Cale> f x = let ... in \y -> ...
14:49:08 <benmachine> like doThing x y = let z = x + y in \a -> map (+ z) a
14:49:10 <benmachine> or whatever
14:49:19 <Feuerbach> I use a view pattern for that -- I hoped that it's equivalent to such a let-node, but probably it isn't
14:49:40 <c_wraith> no, view patterns are equivalent to monad comprehensions.  somehow. :)
14:50:36 <Feuerbach> so I have something like "f (foo -> bar) = \y -> ..", and GHC eta-expands it
14:50:42 <c_wraith> (not that surprising, really, both include notions of failure terminating the computation and going to the next)
14:51:09 <Feuerbach> I'll try using explicit lets for that
15:00:57 <ulidtko> no lambdabot?
15:01:38 <ulidtko> hmm...
15:01:50 <hpc> ulidtko: there's quite a discussion in -blah as to the nature of λbot's outage
15:02:16 <Cale> The virtual server that it normally runs on seems to be down.
15:03:10 <ulidtko> ok
15:03:19 <ulidtko> can anybody tell, which version of ghc has Applicative instance for StateT?
15:04:37 <monochrom> StateT doesn't come with GHC, so the question is ill-defined
15:04:52 <cwb> Does anyone have some method of avoiding repeating a programs version number twice (once for cabal and once for the program)?
15:05:41 <monochrom> I have mtl-2.0.1.0 and transfomers 0.2.2.0, I get instance (Functor m, Monad m) => Applicative (StateT s m)
15:06:25 <yitz> cwb: cabal has version numbers for packages, not programs. the version number of a package is defined only once in its cabal file.
15:07:36 <benmachine> cwb: you can get the version of a package from the Paths_pkg file; let me see if I can find the cabal docs
15:08:26 <benmachine> cwb: http://www.haskell.org/cabal/users-guide/#accessing-data-files-from-package-code it's from the same module as this
15:08:28 <yitz> Cale: the machine seems to be responding again now. see if you can get on.
15:11:31 <cwb> benmachine: thanks, looks promising, let me play with it and see what I can get.
15:15:45 <hjulle> If I want to profile my program, do I need to recompile all the libraries (that it depends on) with profiling enabled?
15:16:40 <shirt> hjulle: yes
15:16:43 <koninkje> @seen augur
15:16:43 <preflex>  augur was last seen on #haskell-blah 14 hours, 16 minutes and 1 second ago, saying: its pretty cool
15:16:51 <hjulle> :(
15:16:55 <koninkje> @tell augur sorry for the delay, I was away at ICFP and then playing catch-up last week
15:17:16 <koninkje> :tell augur sorry for the delay, I was away at ICFP and then playing catch-up last week
15:17:40 <koninkje> hrmm
15:18:01 <koninkje> is lambdabot dead?
15:18:14 <DukeDave> koninkje: Yeah, has been down for an hour or so
15:18:14 <ulidtko> yeah
15:18:24 <koninkje> ah, alas
15:19:35 <DukeDave> Is preflex real?
15:19:36 <DukeDave> preflex: seen lambdabot
15:19:36 <preflex>  lambdabot was last seen on #haskell 2 hours, 51 minutes and 6 seconds ago, saying:   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
15:19:47 <hjulle> shirt: I was afraid so. What is the easiest way to do that?
15:20:01 * DukeDave saw someone say "prefix: seen..." earlier
15:20:19 <Jafet> It is easiest to recompile all the libraries with profiling enabled.
15:20:53 <Clint> i just install the debian packages
15:21:00 <Cale> hjulle: Make sure that library-profiling: True  is in your ~/.cabal/config
15:21:07 <Jafet> That is deceptively easy.
15:21:13 <hjulle> Cale: ok
15:21:18 <Cale> hjulle: (and while you're at it,  documentation: True  is also a good idea)
15:21:36 <Cale> and then you'll have to  cabal install --reinstall  anything that wasn't built with profiling
15:22:12 <yitz> preflex: seen... -- what
15:22:20 <cwb> benmachine: Awesome, that's precisely what I was looking for. Any suggestions on making it play nicely with GHCi by any chance?
15:22:27 <Jafet> Unfortunately, documentation: True doesn't get you hyperlinked source
15:22:51 <hjulle> Cale: What is wrong with the online documentation?
15:23:18 <Cale> hjulle: Nothing, but it can be nice to have a local index of all your packages together.
15:23:24 <geheimdienst> Jafet: i think you need to separately enable hscolour, or possibly separately run it ...
15:23:43 <Jafet> http://hpaste.org/47364/kludge_what_kludge
15:23:56 <hjulle> Cale: aha :)
15:24:15 <geheimdienst> Jafet: thanks a lot, i think i can actually use that
15:25:44 <Jafet> It seems to get some links wrong though, like linking to "base/foo" instead of "base-1.2.3.4/foo"
15:26:01 <Jafet> Not sure if the default cabal haddock also does that
15:26:41 <Jafet> I'm guessing someone expected someone else to add some symlinks somewhere.
15:28:46 <geheimdienst> that reminds me. for every gorram package i install, haddock warns me it can't link into "rts" and "ffi". it used to say this also for base and 3-4 other packages, but it improved at some point, now it's only those 2
15:29:47 <Jafet> Someday, we'll have haddocks for rts.
15:31:27 <dmwit> DevHC: Great. =)
15:31:37 <geheimdienst> oh that's the problem? i thought the docs existed and it was only an issue of haddock not finding them (as with base)
15:31:50 <geheimdienst> ... okay the problem is not on my end then :)
15:32:26 <dmwit> DevHC: You're going to be sad if you don't include something like "forgetR :: RIO r w a -> RIO Does w a" and similarly forgetW/forgetRW.
15:32:42 <DevHC> orly
15:33:01 <dmwit> DevHC: Eventually, you'll want to combine a RIO DoesNot Does a with a RIO Does DoesNot a.
15:33:58 <Jafet> geheimdienst: your package index won't list any module in rts or ffi, whereas it will list several in base
15:34:07 <dmwit> You can either use type families (e.g. my LUB) or just plain polymorphism (e.g. forget*), but you'll surely want it eventually.
15:34:30 <DevHC> well, if u say so :P
15:34:42 <dmwit> Might as well wait until you need it, though, I guess. =)
15:34:44 <DevHC> wtf is LUB?
15:35:00 <companion_cube> leat upper bound?
15:35:02 <dmwit> LUB is a type-level function much like (&&).
15:35:03 <companion_cube> least*
15:35:07 <dmwit> Yes, least upper bound.
15:35:21 <dmwit> LUB Does _ = Does; LUB _ Does = Does; LUB DoesNot DoesNot = DoesNot
15:35:39 <geheimdienst> actually the opinion of "ghc-pkg list" is that /usr/lib/ghc-7.0.3/package.conf.d has rts and ffi. apparently only the docs are missing
15:36:12 <Jafet> I think the source is missing, too!
15:36:37 <dmwit> bind :: RIO r w a -> (a -> RIO r' w' b) -> RIO (LUB r r') (LUB w w') b
15:37:45 <geheimdienst> jafet: that too, probably :)
15:38:07 <shirt> how can i directly parse a (Parser a) in Data.Aeson? There seems to be a runParser function but it's not exported
15:40:18 <dmwit> > 1.0 0.10
15:40:34 <DevHC> dmwit: that bind has a weird type signature; is that valid for >>= ?
15:40:40 <dmwit> DevHC: No it's not.
15:40:43 <DevHC> meh
15:40:58 <dmwit> It's like (>>=), but a bit different.
15:41:03 <cwb> benmachine: Found a way to make it play nice with GHCi using CPP and doing conditional import/define of version.
15:41:14 <DevHC> what if i import Prelude hiding (>>=)?
15:41:29 <dmwit> Doesn't help.
15:41:40 <dmwit> The Monad typeclass is the one that sets the type for (>>=).
15:41:44 <DevHC> is there an amount of stuff i can hide t make that work?
15:41:49 <DevHC> to*
15:41:57 <dmwit> You could import Prelude hiding Monad(..) and turn on OverloadedSyntax or whatever.
15:42:02 <dmwit> And then you could make it work.
15:42:08 <DevHC> meh
15:42:10 <c_wraith> NoImplicitPrelude, you mean?
15:42:15 <dmwit> But you wouldn't be allowed to use any of the *current* instances of Monad, so it would be a bit annoying.
15:42:18 <c_wraith> or the ghc7 version of it
15:42:26 <DevHC> ok, no LUBe for me
15:42:33 <dmwit> If you import Prelude hiding Foo, it's not an implicit import.
15:42:45 <dmwit> So no, NoImplicitPrelude is probably unnecessary.
15:58:42 <rostayob> is it good practice to use a ForeignPtr for foreign data even if you need no finalizer?
16:00:54 <c_wraith> Nah, might as well just use a Ptr at that point
16:03:21 <rostayob> c_wraith: ok, thanks
16:03:36 <rostayob> because i've seen them used even if it's just newFinalizedPtr_
16:05:14 <maurer> Does anyone know of a way to use a C struct in haskell without having to write out all the fields manually?
16:05:39 <maurer> I currently have it imported and working fine, but was hoping to make it automatically import from the header file as the struct changes.
16:06:07 <dmwit> c2hs
16:06:09 <ddarius> Use something like c2hs.
16:06:09 <dmwit> or hsc2hs
16:06:58 <maurer> dmwit: hsc2hs explicitly doesn't do this--you have to list all the field names to use #peek and #Poke
16:07:01 <maurer> *#poke
16:07:15 * maurer looks into c2hs
16:16:50 <hpaste_> “L. Lang” pasted “Blah” at http://hpaste.org/52117
16:17:36 <Louis11> I'm trying to get something like this working http://hpaste.org/52117, however I get an error about the type not matching (it's looking for a Char and I'm giving it a String). Is there any similar method like elem that will work on a string?
16:18:38 <Jafet> A substring is never an element of a string
16:18:58 <Saizan> s `isInfixOf` "=<>+-*%/![]"
16:19:02 <Jafet> Wait, what are you trying to do?
16:19:30 <Jafet> I'm guessing he wants all (`elem` "=<>+-*%/![]") s
16:19:31 <byorgey> Louis11: is the input to isOp1 guaranteed to be one character long?
16:19:48 <geheimdienst> Louis11: the code looks good, it's only that you need to change the type to Char -> Bool
16:19:56 <Louis11> Jafet: Well I need to see if the character provided is one of several allowed characters. The type that's defined is String -> Bool (full disclosure: This is a homework assignment), though I'm not sure exactly why a String is used as it seems that the length is 1 character long
16:20:08 <geheimdienst> (String is the same as [Char], that means a list of Chars. a Char is a single character)
16:20:12 <dobblego> is there a tool to find the source of a call to undefined?
16:20:16 <Louis11> geheimdienst: Yea, I figured changing to Char would work, however the type was provided to me :/
16:20:17 <byorgey> also, the order of the arguments to elem is switched
16:20:30 <Jafet> dobblego: debugger?
16:20:34 <Jafet> I don't know if -xc does it
16:21:19 <Jafet> Louis11: in that case, pattern-match on [c] and use c.
16:21:22 <byorgey> Louis11: you could also do something like  isOp1 [c] = ... use elem with the Char c    isOp1 _ = error "O noes! The operator was not a single character!"
16:21:31 <maikaahl> Has haskell got anything like Neo4j? - which would be an ACID compliant graph data store.
16:21:45 <Jafet> error "Prof. Schmakerty is an idiot"
16:22:31 <Louis11> yea I think I need to clarify with my professor to see if we are only working with one character at a time. It seems to be the case based on the comment he provided. Didn't know if there was some fancy haskell stuff I was completely missing. As always, thanks everyone :)
16:22:51 <maurer> ddarius: It looks like c2hs does the same thing as hsc2hs, in that it does not generate haskell records corresponding to structs :(
16:23:45 <romanandreg> hey guys… have any of you tried to do a foldl' to Enumeratees?
16:23:56 <dmwit> dobblego: Change all (undefined) calls to (error "Source location: foo") instead. ;-)
16:24:10 <dobblego> dmwit: I fear it is in one of my dependencies
16:24:47 <romanandreg> I'm trying to do something like this => http://pastie.org/2635187
16:24:51 <dmwit> File a blocking bug against any library that calls undefined.
16:24:59 <romanandreg> but always getting a type error of infinite types
16:25:35 <Peaker> dobblego: Haskell debugging state is pretty sad -- which is made worse by the liberal use of "head", "undefined" and various other partial horrors in libraries...
16:26:00 <dobblego> Peaker: yes, I agree this could be improved a lot
16:26:01 <geheimdienst> Louis11: an alternative approach might be to have a list of Strings and check each of them if it equals s. prelude has a good function you can use for that (hint: its name has three letters)
16:26:03 <bfig> this is enough, i'm gonna understand the reader transformer now. i've been trying to understand the reader transformer in a separate state but i think i get it now
16:26:07 <rostayob> is cross platform gui programming still bad?
16:26:11 <Peaker> Language magic to add source location information to all errors/undefined would be helpful
16:26:19 <dobblego> bfig: reader transformer = Kleisli
16:26:21 <Jafet> Cross platform programming is still bad.
16:26:24 <dmwit> Peaker: There's Template Haskell magic for it.
16:26:30 <bfig> dobblego, let me put this in a category theory perspective
16:26:35 <dmwit> Peaker: But you have to have the foresight to use it (instead of error/undefined).
16:26:37 <Peaker> dmwit: yeah -- but I want to force it down everyone's throat :)
16:26:49 <Peaker> I want GHC to silently replace error with annotated error
16:26:58 <bfig> lift = natural transformation from monad object to  Tmonad object, right?
16:27:05 <bfig> lift means 'adding context'
16:27:19 <hpc> indeed
16:27:22 <bfig> how do you distinguish ReaderT m binds from m binds ?
16:27:24 <Jafet> Peaker: GHC already has magic... you even get it by writing less code!
16:27:29 <geheimdienst> Peaker: seems to work for asserts ... http://www.haskell.org/ghc/docs/latest/html/users_guide/assertions.html
16:27:32 <dobblego> I have a feeling this call to undefined was generated by TH actually
16:27:40 <bfig> ie, you have a >> which passes context around, and a >> that doesn't pass bindings around
16:27:53 <hpc> bfig: follow the types
16:27:54 <hpc> :t lift
16:28:01 <hpc> ...
16:28:24 <bfig> a monad transformer is a natural transformation on monads defined by the lift and the bind
16:28:32 <dobblego> I think I am going to blame the over-emphasis on the importance of turing-completeness
16:28:37 <hpc> bfig: lift :: m a -> monadT m a
16:28:44 <geheimdienst> ... good question actually: how does it work? the page says "ghc will rewrite", so is this an actual rewrite rule?
16:28:45 <romanandreg> can one do a fold of Enumeratees? even if it is foldr or foldl
16:28:51 <hpc> bfig: lift (a >> b) -- (>>) is acting on 'm a'
16:28:56 <romanandreg> it seems I can't, I thought this was going to be way more trivial
16:29:04 <Peaker> dobblego: with a type system as weak as Haskell's having forced totality could make things very hard
16:29:07 <hpc> bfig: (lift a) >> b -- (>>) is acting on monadT m a
16:29:09 <bfig> hpc, but lift a >> lift b is acting on ReaderT m a
16:29:21 <dobblego> oy, I didn't say I was going to be rational about it
16:29:29 <bfig> wait, shouldn't you lift both sides?
16:29:34 <hpc> bfig: yeah; ghc just follows the types, as with any class method resolution
16:29:36 <bfig> aren't you binding in monad transformers?
16:29:46 <hpc> bfig: lift a >> lift b == lift (a >> b)
16:29:55 <bfig> so how do you distinguish b from lift b?
16:30:02 <hpc> bfig: by the type
16:30:06 <bfig> ie, how do you chain any monad with a readerT? or does it
16:30:13 <bfig> does it put it automagically in there?
16:30:22 <Peaker> bfig: (>>) and (>>=) only work when you have the same "m" type on both sides
16:30:34 <gnuvince> I wrote a little makeChange function and wanted to quickcheck it, so I wrote this expression: quickCheck (\n -> n > 0 ==> sum (makeChange n) == n).  However, quickcheck reports that it bailed out without completing a full round of tests because of too many discards.  Can anyone explain how to avoid that?
16:30:35 <Peaker> bfig: you can only chain (ReaderT r m) with (ReaderT r m)
16:30:46 <bfig> pffffttt!!!! i got it now :DDD
16:30:51 <Peaker> bfig: "lift" is basically about coercing the types to bind well
16:30:55 <bfig> i finally got it :))))
16:30:59 <Peaker> bfig: :)
16:31:07 <Cale> gnuvince: quickCheck (\(Positive n) -> sum (makeChange n) == n)
16:31:14 <bfig> why don't you just say it is a natural transformation and lift is the morphism of objects!!
16:31:26 <Peaker> Cale: I didn't know about that QuickCheck trick :)
16:32:04 <Jafet> n > 0 produces too many discards?
16:32:10 <Peaker> bfig: because I don't like using a cobra helicopter to kill a mosquito :)
16:32:29 <Peaker> bfig: No need to go all the way to "abstract nonsense" to explain these down-to-earth things :)
16:32:32 <bfig> but it doesn't make sense otherwise since it is a categorical notion of transformation
16:32:41 <bfig> there is nothing 'down to earth' of this absurd morphisms :D
16:32:42 <maurer> Is there any way for me to do per-architecture conditional compilation in GHC?
16:32:46 <Peaker> bfig: It makes a lot of sense without thinking of any CT at all
16:33:13 <bfig> i can *only* make sense of it with a categorical notion. same with the functor objects with pure ~ lift
16:33:38 <maurer> I looked at machdeps, but it just seems to give me bittages, which doesn't give me all the information I need to case on
16:33:51 <gnuvince> Hmmm
16:33:59 <gnuvince> I must've done something really bad in my code...
16:34:06 <gnuvince> quickCheck triggers a stack overflow
16:34:09 <Peaker> bfig: I think of it all from a purely programming/expressiveness-utility standpoint and it works for me
16:34:34 <Peaker> bfig: I'm sure the underlying CT is a helpful perspective, but it's not a necessary one
16:34:37 <bfig> of course i'm speaking on my experience Peaker
16:34:55 <bfig> if i have mathematical transformations i need to make sense of it in a mathematical way
16:35:35 <bfig> it is a matter of where the morphisms occur in this categorical salsa, since if you transform monads you expect it to work in a monadish way
16:36:31 <bfig> but i never quite understood that i had to bind two equal monads which makes me feel like an idiot and makes things much clearer
16:38:14 <hpc> on a related note, i really wish mtl used "class Monad m => MonadTrans t m"
16:38:30 <hpc> so you could make a transformer that could only lift certain monads
16:38:44 <dmwit> nooooo
16:38:48 <Oxfaded> is there a magic way to convert a Data.Bytestring to a Data.Bytestring.Char8?
16:38:49 <hpc> no?
16:39:04 <Cale> Oxfaded: yeah, id ;)
16:39:07 <RaptorRarr> Oxfaded: It already is one, I think.
16:39:10 <Cale> Oxfaded: They're the same type
16:39:16 <dmwit> People would be constantly writing extra instances because some freaking library author didn't happen to write an instance for the combination *you* wanted.
16:39:39 <Cale> The Char8 module just has stuff for examining a ByteString as if it were composes of ASCII chars.
16:39:42 <Cale> composed*
16:39:49 <dmwit> *Latin1
16:39:56 <shachaf> Cale: What's with lambdabot?
16:40:01 <Cale> shachaf: server down
16:40:06 <shachaf> Oh.
16:40:09 <hpc> dmwit: i was more thinking of the case when someone writes a specific monad that isn't kinded enough for MonadTrans, and transforms over specific monads by hand
16:40:22 <RaptorRarr> Oxfaded: It's apparently part of the #haskell bylaws that if you're dealing with text, we inform you you should use Text instead of ByteStrings.
16:40:23 <hpc> my website rolls its own monad that lifts over Error, State, and IO
16:40:26 <dmwit> Then that's not a monad transformer.
16:40:49 <hpc> dmwit: ah, good point
16:40:54 <Jafet> Using Char8, with few exceptions, is an international felony.
16:41:52 <gnuvince> Anyone can see why this stack overflows? http://www.ideone.com/QfHcP
16:42:15 <dmwit> gnuvince: Make your second argument to loop strict.
16:42:33 <dmwit> gnuvince: You're generating deeply-nested (m+(m+(m+(m+c)))) thunks.
16:42:36 <Cale> actually, it's the third, isn't it?
16:42:38 <Cale> yes
16:42:41 <dmwit> Yes, third.
16:42:44 <maurer> Anyone know how I can detect architecture for conditional compilation in haskell? Ideally via CPP?
16:42:59 <maurer> (e.g. I want something like the __amd64__ macro from gcc)
16:43:07 <dmwit> maurer: You can do it in your cabal file with the os() test.
16:43:10 <gnuvince> dmwit: isn't that in a tail position?
16:43:14 <Cale> loop builds up large expressions in its third parameter which never get evaluated until the end
16:43:18 <dmwit> err... not os(), obviously
16:43:25 <dmwit> Not sure if they have arch() as well as os().
16:43:25 <Cale> gnuvince: tail position is pretty meaningless
16:43:31 <Oxfaded> RaptorRarr: haha thanks.
16:43:50 <Cale> gnuvince: The evaluator evaluates expressions in pretty much the reverse order that it would in, say, scheme
16:43:51 <ddarius> The Green-Tao theorem is kinda cool.
16:44:07 <Cale> gnuvince: Things are being evaluated outermost-first
16:44:09 <dmwit> gnuvince: Not sure what "tail position" means, but if you're asking whether this is tail-recursion, the answer is "yes, and tail recursion is bad in Haskell".
16:44:18 <Jafet> gnuvince: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
16:44:26 <gnuvince> hmmm
16:44:28 <gnuvince> interesting
16:44:33 <Cale> but actually, is that the problem?
16:44:36 <adit__> I thought ghc took care of tail recursion
16:44:41 <Cale> It seems like it will have to evaluate m
16:44:43 <ddarius> Tail recursion is not "bad" in Haskell.
16:45:14 <ddarius> Tail position is also a syntactical concept that admittedly varies with language, but is usually pretty straightforward.
16:45:21 <maurer> dmwit: Know where the relevent documentation is?
16:45:35 <maurer> dmwit: http://www.haskell.org/ghc/docs/latest/html/Cabal/index.html seems absent
16:45:42 <maurer> (which is where reading the normal cabal docs lead me)
16:46:00 <dmwit> maurer: http://www.haskell.org/cabal/users-guide/
16:47:15 <Cale> actually, I think the problem might be more subtle :)
16:47:29 <Cale> gnuvince: Do you still get stack overflow using Integer instead?
16:48:17 <bfig> so how do i write an instance of a reader monad transformer?
16:48:35 <dmwit> maurer: grep for the section headed "conditional blocks"
16:49:12 <gnuvince> Cale: I don't.
16:49:18 <bfig> i have r -> m a, a -> (r -> m b) -> (r -> m c) right?
16:49:31 <Cale> gnuvince: Yeah, I think the problem is that Int is badly behaved.
16:49:40 <Cale> gnuvince: and you're getting into an infinite loop somehow :)
16:49:56 <dmwit> bfig: I don't think so.
16:49:58 <gnuvince> Cale: really?
16:50:03 <gnuvince> Cale: like integer overflowing?
16:50:08 <Cale> maybe...
16:50:10 <gnuvince> (Int overflowing)
16:50:18 <dmwit> I would think you have (r -> m a) -> (a -> r -> m b) -> (r -> m b).
16:50:18 <bfig> (r -> m a) -> ( a -> (r -> m b ) -> (r -> m c)  dmwit ?
16:50:33 <bfig> eerr, (r -> m b) at the end
16:50:35 <Cale> Did it happen to say what the test input was when it stack overflowed?
16:50:46 <dmwit> bfig: EUNMATCHEDPARENTHESIS
16:50:52 <bfig> >_>
16:51:05 <bfig> ( a -> (r -> m b ) )
16:51:10 <dmwit> yes
16:51:13 <dmwit> That sounds right.
16:51:41 <bfig> in what does instancing the class consist of?
16:51:42 <gnuvince> Cale: when I Ctrl+C'ed, it gave me Positive 52218280
16:51:58 <Cale> gnuvince: If m+c ever becomes negative, then the test that says m+c <= n will always succeed
16:52:19 <Cale> Well, it'll succeed for a long time anyway
16:52:24 <scooty-puff> is it a code smell to use STArray?
16:52:27 <bfig> instance Monadtype m => readerT m a ?
16:52:42 <dmwit> scooty-puff: Absolutely not.
16:52:48 <Cale> gnuvince: Stuff like this is why I hate Int and think it shouldn't be in the Prelude.
16:52:58 <scooty-puff> k
16:53:01 <dmwit> bfig: instance Monad m => Monad (ReaderT r m) -- is this what you meant?
16:53:27 <bfig> possibly, but now it gets confusing
16:53:37 <Cale> gnuvince: Out of interest, what does maxBound :: Int report on your system?
16:54:13 <bfig> dmwit, do you define it for generic readers?
16:54:28 <bfig> generic monads m i mean
16:54:37 <dmwit> Sure, why not?
16:54:43 <geheimdienst> i've had another Dubious Idea™. would it be possible to use a rewrite rule to change all mentions of error into assert? that way you'd get the line number when the error is hit
16:55:27 <bgamari> Is it really true that HMatrix has no cross product implementation?
16:55:30 <dmwit> geheimdienst: This rule would surely not fire on any code you didn't already have control over. So why not apply the rule yourself?
16:55:47 <dmwit> geheimdienst: (That is to say: libraries you're linking against are already compiled and not subject to rewrite.)
16:55:56 <geheimdienst> dmwit: yeah i guess you'd have to recompile everything under consideration
16:56:50 <bgamari> Can anyone recommend a good linear algebra library for low-dimensional work (3 dimensions and lower)?
16:59:29 <ddarius> The cross product is sin.
17:00:17 <bfig> cross product : V->V->V* ?
17:05:03 <kfish> hi dcoutts!
17:13:32 <bfig> kaboom
17:15:58 <gnuvince> Cale: sorry about the delay (dinner).  maxBound::Int == 9223372036854775807
17:20:48 <roconnor> bfig: that is the outerproduct, yes.
17:21:19 <bfig> complaining about the types? :p
17:21:19 <roconnor> bfig: er wait
17:21:33 <roconnor> bfig: the output of the outerproduct is a bivector
17:21:55 <roconnor> not V*
17:21:56 <roconnor> my bad
17:22:09 <bfig> are you sure?
17:22:21 <bfig> outer product means v wedge w ?
17:22:42 <roconnor> bfig: yes
17:23:07 <bfig> ie, the prod_{k-1} V^k -> V^k* ?
17:23:48 <roconnor> That I didn't follow
17:24:41 <rwbarton> you get that once you pick a volume form on V
17:25:15 <bfig> the outer product on a k dimensional tensor space is  V^k x V^k x V^k x...  (k-1 times) -> V^k*
17:26:26 <bfig> v
17:26:27 <bfig> http://en.wikipedia.org/wiki/Exterior_algebra
17:26:28 <ddarius> Oh great googly-moogly.
17:26:59 <roconnor> biio: I'd have to think about that
17:27:01 <roconnor> er
17:27:06 <roconnor> bfig: I'd have to think about that
17:27:14 <roconnor> but it seems right
17:27:48 <bfig> the outer product is a sort of 'how do you fill up this' determinant, if that means something for you
17:27:51 <roconnor> oh wait
17:27:55 <roconnor> since V^k x ... x V^k (k times) should be a pseudo-scaler
17:28:13 <roconnor> that won't quite work
17:28:23 <roconnor> pseudo-scalers are not exactly scalers.
17:28:29 <incluye> hence "pseudo"
17:29:02 <Cale> "scalar"?
17:29:11 <roconnor> scaler
17:29:12 <roconnor> er
17:29:14 <roconnor> scalar
17:29:15 <roconnor> god
17:29:20 <roconnor> I can't even type it right when I try
17:29:41 <roconnor> bfig: wait a minute, what is V^k?
17:29:57 <bfig> a k dimensional vector space V^k
17:29:59 <bfig> like R^k
17:30:08 <roconnor> ah okay
17:30:17 <roconnor> thats what I read it as
17:30:57 <roconnor> bfig: pseudo-scalars are 1-dimensional spaces, but are not naturally isomorphic to scalars.
17:32:38 <bfig> mmm i can't remember much of this :(
17:34:18 <bfig> so how do i implement the ask and local functions of a monadreader instance? what am i supposed to do?
17:35:16 <roconnor> ask should be straightforward
17:35:23 <roconnor> I don't think local should be part of the class :/
17:35:26 <bfig> is this left to personal implementation just in case you want to apply other functions to local?
17:35:34 * roconnor slowly remembering again why he hates the mtl
17:35:50 <roconnor> edwardk!!
17:36:25 <roconnor> bfig: um, implementing the ask function is the whole point behind the MonadReader class.
17:36:39 <Veinor> sometimes i wonder how much more newbie-friendly haskell code would be if we used words instead of single letters in polymorphic types
17:37:23 <roconnor> Veinor: maybe for constrained types
17:38:42 <Veinor> ?
17:39:09 <bfig> so you extract the r from the environment, which is inside the readerT context in some way?
17:39:59 <roconnor> Veinor: if polymorphic types are unconstrained then you probably don't have any helpful names to give them.
17:40:13 <Veinor> 'source' and 'target'?
17:40:14 <geheimdienst> veinor: i wish we could travel to some strange land and discover a type variable that is actually documented. maybe we somehow could reverse-engineer how to do that. and over time learn to apply that to our own code
17:40:19 <Veinor> but i do see your point
17:40:25 <roconnor> Veinor: maybe
17:40:43 <Veinor> geheimdienst: i have no clue if i'm being trolled right now :V
17:40:46 <roconnor> bfig: Ya, but if you are using readerT, then you are already an instance of MonadReader.
17:41:07 <geheimdienst> i mean, type variables should be documented, and nobody right now seems to do it
17:41:29 <roconnor> geheimdienst: what's a better name for a in concat :: [[a]] -> [a] ?
17:41:50 <parcs> [[something]] -> [something]
17:41:51 <roconnor> concat :: [[elementValueType]] -> [elementValueType]
17:43:16 <roconnor> the thing is that it the List's that are important here not the types of the values.  In a really good langauge we'd be able to hide the a entirely and write a type for a natural transformation
17:43:24 <geheimdienst> roconnor: there probably isn't any. but i think that's irrelevant, he wasn't making the point the every single type variable needs to be renamed, only that it often would help
17:43:29 <roconnor> concat :: List `o` List ~> List
17:43:53 <roconnor> so, I guess I'd be in favour of getting rid of the type variables entirely. :)
17:44:28 <wagle> :t concat
17:44:39 <wagle> 8/
17:44:43 <roconnor> [[wagle]] -> [wagle]
17:45:53 <wagle> @t join
17:46:15 <wagle> well, so much for my spam
17:46:17 <roconnor> Monad wagle => wagle wagle a -> wagle a
17:46:34 <roconnor> oh
17:46:36 <dolio> Kind error.
17:46:40 <roconnor> bad bracketing
17:46:52 <roconnor> wagle: you will find the missing parens in #lisp
17:47:24 <geheimdienst> http://xmonad.org/xmonad-docs/xmonad/src/XMonad-StackSet.html#StackSet <- a good example. the type variables afaik are not documented, and there's 5 of them, and their names are confusing. i = tag, a = window id, sid = some stuff about screens, sd = some more stuff about screens
17:47:30 <ben> @pl [[a]] -> [a]
17:47:30 <wagle> concat is a specilization of join..  blah blah blah
17:47:33 <ben> :)
17:47:44 <monochrom> join :: (Monad wagle0) => wagle0 wagle0 wagle1 -> wagle0 wagle1
17:47:50 <geheimdienst> it wouldn't have killed them to say t for tag and w for window, or even "tag" and "win"
17:49:19 <roconnor> geheimdienst: aye
17:51:37 <wagle> join :: (Monad monad) => monad monad someType -> monad someType
17:52:07 <wagle> o.O
17:59:00 * hackagebot Unixutils 1.45 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.45 (DavidFox)
18:00:59 <parcs> at least w isn't for tag and t for window
18:03:11 <geheimdienst> parcs: right :)
18:06:06 <ryb> 'let' doesn't seem to work in recursive do… Maybe a dumb question: Is there a reason it doesn't work?
18:06:22 <parcs> :t concat :: (elementType ~ [a], resultType ~ elementType) => [elementType] -> resultType
18:07:00 <parcs> lambdabat where are youuu
18:07:14 <monochrom> let works in recursive do but faces a monomorphism restriction (more restriction than the usual one)
18:07:47 <ryb> ah, okay.
18:10:36 <ryb> phew. thanks.
18:24:01 <bfig> :t let
18:24:22 <bfig> > :t let
18:24:27 <bfig> > let
18:24:31 <bfig> > 1+!
18:24:41 * MatrixFrog cries out: lambdabot!!!
18:25:29 <monochrom> "let" is a reserved word. it has as much type as "module"
18:25:30 <RaptorRarr> ...and is suddenly silenced :(
18:26:05 <bfig> just wanted to see what the bot said
18:28:57 <MatrixFrog> yeah, lambdabot has been down :(
18:29:15 <QtPlatypus> Ask what is the type of "let" makes as much sence as asking what the quardatic equation smells like.
18:32:31 <bfig> i wanted to see if it detected a parsing error or something
18:32:51 <ion> They smell like vanilla.
18:33:03 <bfig> why don't we ask WA
18:33:38 <bfig> it smells 'doubly degenerate'
18:36:56 <JoeyA> What's a good library for HTTP serving?
18:37:41 <JoeyA> (I'm interested in hosting pages from memory, rather than from disk)
18:37:59 <parcs> wai
18:41:15 <JoeyA> Thanks; looking at it.
18:42:45 <gnuvince> Is there a good screencast out there of QuickCheck?
18:43:26 <parcs> why do you specifically want a screencast?
18:43:42 <gnuvince> parcs: I like the format
18:44:08 <gnuvince> parcs: although I guess an indepth written tutorial is fine as well
18:44:28 <parcs> why? (just curious; i like the format too but i'm not sure why)
18:44:50 <JoeyA>  /A Taste of Haskell/ talks about QuickCheck.
18:46:41 <gnuvince> parcs: there's something about watching someone work that brings a dimension that I can't quite describe.
18:47:07 <gnuvince> parcs: I remember an italian programmer made some screencasts on Emacs+SLIME and it was a lot more exciting than reading about SLIME
18:48:37 * shachaf finds screencasts annoying.
18:49:09 * Saizan likes talks though
18:49:25 <shachaf> That's rather different.
18:49:52 <ion> gnuvince: http://www.quviq.com/ are okay.
18:50:06 <ion> Yay, frames. http://www.quviq.com/demos.html that is.
18:51:41 <JoeyA> gnuvince: +1.  I've gotten to see that in person only once in my life.  I was shadowing a programmer who used xterm, vim, and bash jobs proficiently.
18:51:53 <gnuvince> ion: thanks
18:52:08 <gnuvince> Also, is it possible that the Quick Introduction to Quickcheck on the wiki is out of date?
18:52:40 <gnuvince> for instance, it seems that defaultConfig that's used in section 6 (coverage) does not exist anymore and has been replaced by stdArgs
18:56:50 <desaiu> I'm trying to follow along with tis site: http://neonstorm242.blogspot.com/2011/01/visualizing-gis-data-using-html5-canvas.html I don't understand the part where it says "And here is the suffix file"
18:57:42 <desaiu> He presents html but github says it's a haskell file?
18:58:12 <desaiu> I'm wanting to create some graphics, and I think the html canvas element is ideal
18:59:01 <desaiu> All I want to do tonight is to display *something*, *anything* on the canvas element with a combination of html and haskell
19:00:18 <Cale> desaiu: Oh, the suffix has a weird filename by the looks of it
19:00:20 <JoeyA> Sounds like an idea for a song.
19:00:29 <geheimdienst> desaiu: near the end of the blog post, there's haskell code which makes the entire thing fit together. basically the haskell program writes into an html file 3 things: the "prefix" file, then some javascript things to display stuff, then the suffix file
19:00:38 <Cale> desaiu: it looks like however he was creating the gists, they mostly got named "gistfile1.hs"
19:01:14 <Cale> But yeah, the prefix is apparently supposed to be called "canvasPrefix.html" and the suffix is supposed to be "canvasSuffix.html"
19:01:27 <Cale> (as you can see from the Haskell code)
19:01:47 <desaiu> That's what I'm thinking, even github's code highligting thinks that
19:02:41 <Cale> by the way, I think there are much more straightforward ways of getting drawings into a browser now...
19:02:50 <desaiu> Really?
19:02:53 <desaiu> How?
19:04:22 <Cale> Um, let me look it up. There's a web-based version of gloss which looks like it should be nice to use.
19:05:12 <desaiu> I was trying to follow along with the Haskell for Kids posts, but failed
19:05:39 <desaiu> @ import Graphics.Gloss
19:05:40 <ddarius> desaiu: Perhaps you should find some kids.
19:05:51 <desaiu> I installed gloss through cabal
19:06:22 <desaiu> Or so I thought, cabal says no
19:06:48 <Cale> I'm not sure how the web interface to gloss works. It's easy to get things up on the screen though.
19:07:03 <desaiu> That's a start
19:07:09 <Cale> It seems like it ought to be easy to transform gloss pictures into SVG
19:07:32 <desaiu> I'm new to programming, but I figure I need to do *something* everyday
19:08:40 <desaiu> Relatively new
19:09:32 * ddarius measures desaiu's newness in decibels.
19:10:12 <geheimdienst> desaiu: not a bad plan, for sure :)
19:11:18 <desaiu> Oh, I needed the libghc6-opengl-dev package
19:11:34 <Cale> actually, why the heck isn't gloss-web on hackage?
19:11:58 <desaiu> https://github.com/cdsmith/gloss-web.git
19:12:03 <Cale> yeah
19:12:10 <Cale> It's only on github :P
19:12:16 <desaiu> Which is odd
19:12:19 <JoeyA> 404
19:12:24 <Cale> I should cabal sdist it and put it on hackage for him
19:12:30 <desaiu> https://github.com/cdsmith/gloss-web
19:15:33 <Cale> https://github.com/cdsmith/gloss-web/blob/master/src/Serialize.hs -- aha
19:16:56 <Cale> Kind of amazing that cdsmith opted to do his own PNG construction, rather than use some image library, but that ought to work anyway :)
19:18:55 <gwern> 'In addition, there's currently no protection against:  * Eating up 100% of your CPU time. * Using bandwidth to transfer infinite-sized results. * Crashing the server by using unbounded amounts of memory.' <-- never say mueval isn't doing anything for ya
19:20:23 <Cale> Oh, bizarre.
19:20:47 <Cale> The "png" which is constructed is actually a bunch of drawing commands which get interpreted by some javascript canvas code :P
19:20:54 <bfig> i don't understand something, why would i need to implement the ask and local functions on the readerT ?
19:20:57 <Cale> wtf
19:21:20 <desaiu> In ghci, how do you see what's included in a module?
19:21:36 <desaiu> I'm looking at the :commands
19:21:44 <ski> :browse Foo
19:21:47 <bfig> ie, instance MonadReader r m => MonadReader r (MyTransT m) where ...
19:21:50 <Cale> :browse ModuleName
19:21:57 <desaiu> Thanks ski
19:22:21 <Cale> bfig: Because they're part of the MonadReader class?
19:22:31 <bfig> but what does the ask and local mean?
19:23:10 <bfig> what am i supposed to do with them? isn't that something that only matters for the things that live in the transformer monad?
19:23:14 <Cale> ask gets the value of the environment -- it's the main point of something being a Reader monad
19:23:31 <bfig> i see things like lift ask, but what does that mean?
19:23:54 <Cale> local takes a function on the environment, and a computation to be run, and it transforms the current environment locally, running the given computation in the transformed environment
19:24:40 <Cale> lift ask would be something you might do if you had yet another monad transformer applied to a reader monad, and you wanted to transform the ask computation from that reader monad to a computation in the transformed monad
19:25:31 <Cale> If M is any monad, and T is any monad transformer, then whenever x :: M a, then you have  lift x :: (T M) a
19:25:39 <desaiu> A little help? http://sprunge.us/aTJU
19:25:48 <bfig> ok, let's start with something very simple to understand that
19:26:04 <Cale> desaiu: in order to compile a program, you need to define a main IO action.
19:26:17 <Cale> desaiu: for now...
19:26:24 <desaiu> You mean, display picture somehow?
19:26:43 <Cale> main = displayInWindow "My Window" (200, 200) (10, 10) white picture
19:26:44 <bfig> if i have MonadReader Int (Maybe Int), i can for example build a simple monad as
19:27:03 <bfig> lift $ Maybe 5
19:27:06 <Cale> desaiu: and then when you run the thing, it should display your picture in a 200x200 window
19:27:18 <Cale> (with a white background)
19:28:20 <Cale> bfig: uh, I don't think Maybe is a suitable instance of MonadReader...
19:28:29 <bfig> that will give me a Reader Maybe 5 that will ignore the environment. then if i want to do something with the maybe 5 i can use pattern matching and i'll be able to access the content
19:28:37 <Cale> Maybe also isn't a data constructor
19:28:45 <bfig> err, Just
19:28:50 <bfig> lift $ Just 5
19:28:53 <bfig> isn't that correct?
19:29:06 <parcs> bfig: return 5 will do
19:29:25 <Cale> lift (Just 5) :: (MonadTrans t) => t Maybe Integer
19:29:41 <parcs> wait no, i am wrong
19:29:55 <Cale> yay, lambdabot's machine is back up
19:30:32 <Cale> and of course, lambdabot still thought it was connected to the IRC server and that everything was okay :P
19:30:42 <bfig> :t lift (Just 5)
19:30:48 <lambdabot>     Ambiguous occurrence `lift'
19:30:52 <Cale> heh, hmm
19:30:54 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
19:30:56 <bfig> lol :p
19:31:02 <bfig> not Reader :p
19:31:04 <Cale> :t Control.Monad.Trans.lift (Just 5)
19:31:12 <lambdabot> forall t (t1 :: (* -> *) -> * -> *). (Num t, Control.Monad.Error.MonadTrans t1) => t1 Maybe t
19:31:13 <desaiu> http://sprunge.us/PZeV
19:31:28 <Cale> desaiu: ghc --make test
19:31:48 <Cale> desaiu: or else you'd need to do something like ghc -package gloss test.hs
19:32:01 <Cale> desaiu: but --make will generally figure that stuff out for you
19:32:21 <bfig> Cale, how does this work then? what is the correct syntax to use a Maybe a inside a reader transformer?
19:32:30 <Cale> I kinda think that --make should be the default behaviour of ghc
19:32:32 <bfig> ie, why should any monad not be a valid instance?
19:32:50 <Cale> bfig: Well, okay, ReaderT Maybe is a reader monad
19:32:57 <Cale> (instance of MonadReader)
19:33:05 <Cale> ReaderT Integer Maybe, rather
19:33:34 <desaiu> http://sprunge.us/TdTb
19:34:21 <Cale> > runReader (do x <- ask; lift (lookup x (zip [0..] (words "here are a few words")))) 5
19:34:22 <lambdabot>   Ambiguous occurrence `lift'
19:34:23 <lambdabot>  It could refer to either `Control.Monad.Trans....
19:34:29 <bfig> lol
19:34:30 <Cale> ugh, let me fix that
19:34:38 <bfig> we need type signatures but why wouldn't it be correct>
19:34:55 <Cale> :re
19:34:59 <Cale> @undefine
19:35:05 <Cale> > runReader (do x <- ask; lift (lookup x (zip [0..] (words "here are a few words")))) 5
19:35:06 <lambdabot>   Ambiguous occurrence `lift'
19:35:06 <lambdabot>  It could refer to either `Control.Monad.Trans....
19:35:12 <Cale> OR WHAT
19:35:48 <ski> how can `Control.Monad.Trans.Class.lift' and `Control.Monad.Trans.lift' clash with each other ?
19:35:53 <desaiu> I tried the ghc -package gloss test.hs and I received the same error when running a.out
19:35:56 * ski thought those were the same ..
19:36:38 <desaiu> It's past my bedtime
19:37:18 <desaiu> New task before I sleep, what's the printf or print equivalent so I can print something on screen :)
19:37:24 <Cale> > runReaderT (do x <- ask; lift (lookup x (zip [0..] (words "here are a few words")))) 5
19:37:26 <lambdabot>   Nothing
19:37:26 <ddarius> printf
19:37:31 <ddarius> or print
19:37:32 <Cale> > runReaderT (do x <- ask; lift (lookup x (zip [0..] (words "here are a few more words")))) 5
19:37:33 <lambdabot>   Just "words"
19:37:55 <Cale> desaiu: Usually print or putStrLn
19:38:04 <Cale> There's a printf library, but it's crazy ;P
19:38:06 <ddarius> @src print
19:38:07 <lambdabot> print x = putStrLn (show x)
19:38:12 <desaiu> Oh wait, I need to learn monads I think before I can compile it and print something
19:38:30 <Cale> desaiu: Actually, you just need to learn about one particular thing which happens to be a monad
19:38:32 <Cale> (IO)
19:38:36 <ski> > printf "%s" (concat ["here are ",show 3," words"]) :: String  -- desaiu
19:38:38 <lambdabot>   "here are 3 words"
19:38:41 <Cale> You don't need to know about monads in general :)
19:38:56 <Cale> lol
19:38:58 <ski> you can replace `:: String' by `:: IO ()' to make it write to `stdout'
19:39:17 <Cale> > printf "Here are %i words" 3 :: String
19:39:18 <lambdabot>   "Here are 3 words"
19:39:50 <Cale> printf is kinda magically polymorphic in its use of typeclasses
19:39:56 * ddarius made sure to learn about algebraic topology before he learned to tie his shoes.
19:40:13 <Cale> algebraic topology goot skill
19:40:54 <desaiu> I'm getting invalid type signature
19:41:02 <desaiu> printf "Here are %i words" 3 :: IO ()
19:41:07 <desaiu> That's what's in the file
19:41:18 <desaiu> ghc test2.hs is what I'm running to get the error
19:41:31 <ski> (however, you need to know Yoneda's Lemma, to survive in today's increasingly enterprise solution environment)
19:41:32 <Cale> desaiu: you need to write   main = that
19:41:40 <Cale> main = printf "Here are %i words" 3
19:41:59 <Cale> and you'll have to import Data.Printf  if you really want to use printf
19:42:04 <Cale> errr
19:42:10 <Cale> Text.Printf
19:42:28 * shachaf wonders why Haskell distinguishes between Control. and Data.
19:42:40 <shachaf> Also, why is Functor in Data but Applicative in Control?
19:42:49 <shachaf> Ridiculous.
19:42:57 <Cale> Control.* and Data.* are stupid extra hierarchy which is no better than Miscellaneous.*
19:43:02 <Cale> except that it's shorter to type
19:43:23 <shachaf> Misc.
19:43:39 <Cale> What's wrong with naming modules Set and Map? Why does it have to be Data.Set?
19:44:29 <shachaf> Hierarchical module names are more modern!
19:44:31 <Cale> Probably because WHEEE HIERARCHICAL MODULES EXTENSION TO HASKELL 98
19:44:41 <desaiu> I will give up on getting any output tonight I suppose
19:44:47 <Cale> desaiu: What's wrong now?
19:44:47 <desaiu> I should be sleeping
19:44:54 <ski> well, maybe it should be `ZF.Set' ?
19:44:56 <Cale> desaiu: did that not work?
19:45:08 <Cale> ski: well, that would be a *very* different Set :)
19:46:15 <Cale> ZF sets are almost, but not quite, entirely unlike Data.Sets
19:46:44 <ski> yeah
19:46:46 <ski> :)
19:46:56 <desaiu> http://sprunge.us/YRdP
19:47:28 <Cale> desaiu: oh dear :)
19:47:44 <Cale> desaiu: replace the 3 with (3 :: Integer) and it should work
19:47:56 <Cale> honestly, that printf hack is not what you're meant to use
19:48:32 <Cale> main = putStrLn ("Here are " ++ show 3 ++ " words")  should work without complaint
19:48:52 * shachaf always implements his ZF sets in terms of balanced binary trees with an Ord constraint.
19:48:55 <desaiu> It worked!
19:48:56 <shachaf> I don't know about you.
19:49:06 <desaiu> That was quite the experience
19:49:30 <desaiu> import Text.Printf
19:49:30 <desaiu> main = printf "Here are %i words" (3 :: Integer)
19:49:35 <desaiu> That's the file
19:50:03 <shachaf> desaiu: printf is darkish magic, by the way; putStrLn/print are much simpler.
19:50:08 <desaiu> I'm going to Yet Another Haskell Tutorial and then dive into Real World Haskell
19:50:12 <donri> isn't it better to use some quasiquoter for printf-type of things?
19:50:18 <shachaf> desaiu: Why YAHT?
19:50:33 <desaiu> I ran into problems with Real World Haskell
19:50:36 <shachaf> desaiu: I found YAHT rather confusing when I read it, particularly on the topic of IO etc.
19:50:38 <parcs> donri: it's more type safe
19:50:43 <parcs> and faster
19:50:47 <shachaf> LYAH is often recommended around here.
19:50:49 <donri> "it"?
19:50:50 <shachaf> @where lyah
19:50:50 <lambdabot> http://www.learnyouahaskell.com/
19:51:02 <parcs> donri: quasiquoter-based printf
19:51:12 <shachaf> parcs: You probably misread donri's question.
19:51:13 <donri> and syntax-checked at compile-time
19:51:26 * shachaf doesn't like TH much when it can be avoided.
19:51:38 <donri> is quasi-quotation part of TH?
19:52:00 <parcs> well there's no way of creating a type-safe printf in haskell without TH
19:52:17 <tickle> is there a way to do "monadic pattern guards"? i.e., foo x = do { pat <- ... } and if matching pat fails, we move on to the next equation of foo?
19:52:29 <shachaf> parcs: Sure there is, for sufficiently broad enough definitions of printf.
19:53:00 <parcs> liar
19:53:07 <parcs> oleg said it isn't possible
19:53:11 <MatrixFrog> tickle, i'm like 68% sure that is not possible
19:53:16 <desaiu> "Good thing I read Hal's 'Yet Another Haskell Tutorial' before buying this book."
19:53:21 <MatrixFrog> at least not with do notation
19:53:44 <bfig> Cale, sorry i left, i saw your example and then had to leave
19:54:02 <desaiu> "Let us step through the evaluation of sumList [1,2]. The list notation [1,2] is shorthand for the..." That paragraph lost me, and that comment got me started reading YAHT
19:54:09 <desaiu> I have to leave now though, really, I need to sleep
19:54:14 <desaiu> Thank you all for you generous help
19:54:18 <shachaf> desaiu: LYAH might be better.
19:54:21 <bfig> so, a simple monad is just fine to lift, now, the problem arises when we have transformers inside, right?
19:54:53 <tickle> MatrixFrog: Hmmm. that's not very convincing :-)
19:55:04 <bfig> why should there be a problem when you have two stacked transformers?
19:55:14 * ski can't really recommend from experience any one of YAHT,RWH,LYAH other the others, having read none of them completely
19:55:20 <hpaste_> Louis11 pasted “Data” at http://hpaste.org/52120
19:55:27 <donri> tickle: are you looking for a solution or specifically a way to do it with guards?
19:55:32 <desaiu> I prefer getting to the nitty gritty, LYAH seems too stylistics for my dull self
19:55:42 <Louis11> Any reason why that code isn't working? It's giving me a: <interactive>:1:1: Not in scope: data constructor `Pos'
19:55:43 <shachaf> desaiu: _Programming in Haskell_ is good but not available online.
19:55:44 <MatrixFrog> tickle: i'm not very experienced with monads yet. sorry :)
19:55:46 <desaiu> s/stylistics/stylistic
19:55:58 <donri> LYAH is quite well thought-out in terms of things like the order it teaches things
19:55:59 <desaiu> Goodnight!
19:56:04 <tickle> donri: a solution, hopefully with decent syntax.
19:57:24 <donri> tickle: how about something like foo x = do pat <- case ... of ..., move the guarding to the inside
19:58:57 <tickle> donri: I suppose that works; I was hoping for a way to do it without nesting
19:59:24 <donri> well you can always refactor out the nested parts with where-clauses or so
19:59:53 <rwbarton> does the second case have a separate monadic action that you have to run after the first fails?
20:00:38 <donri> what?
20:00:46 <rwbarton> "we move on to the next equation of foo" is pretty vague
20:01:17 <tickle> the "next equation" would be a different monadic action, if that's what you're asking
20:01:41 <rwbarton> Perhaps you can just mplus or msum together a bunch of those do blocks, then
20:02:26 <donri> perhaps provide a concrete example and let people suggest how they would solve the problem
20:04:31 <Louis11> Is there any reason a custom data type would not be in scope?
20:04:45 <shachaf> Yes.
20:05:32 <Louis11> http://hpaste.org/52120 What about in this case?
20:05:45 <Louis11> It's in the same file, so I'm not sure why it's not in scope? Am I messing up syntax?
20:05:53 <tickle> hmm. mplus might work well. I'll try it out. thanks donri & rwbarton
20:07:20 <donri> Louis11: your constructor is "String"
20:07:36 <donri> you want data Pos = Pos String Int Int ...
20:08:12 <Louis11> What does the additional Pos do exactly?
20:08:22 <donri> The first is the name of the type, the second one of its constructors
20:08:47 <shachaf> data Maybe a = Just a | Nothing -- the second "Pos" is like "Just" or "Nothing".
20:09:00 <Louis11> ah, alright thanks :)
20:13:40 <bfig> question about monad transformers: is there an equivalent functor transformer?
20:15:13 <shachaf> Every monad transformer is a functor transformer. :-)
20:16:08 <bfig> only in the categorical sense, but what about the type sense? can i lift a functor?
20:16:37 <bfig> can i lift pure?
20:19:01 * hackagebot containers 0.4.2.0 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.4.2.0 (JohanTibell)
20:19:25 <shachaf> bfig: Do you want to?
20:21:17 <bfig> shachaf, just wondering :p
20:51:26 * shachaf vaguely wishes you could do Foo { Just field = ... }
21:00:32 * ddarius doesn't know what that would mean.
21:02:00 <shachaf> The same as Foo { field = fromJust ... }
21:02:06 <shachaf> I suppose that doesn't really generalize, though.
21:03:57 <Axman6> can't you do something like that with an extension? named record fields or something...
21:04:04 <Axman6> scoped record fields?
21:04:15 <geheimdienst> Foo { (field, otherfield) = something_that_gives_a_tuple }
21:06:01 <dobblego> can I cabal uninstall an executable?
21:06:15 <shachaf> dobblego: No, but you can rm it.
21:06:22 <dobblego> alrighty ta
21:06:31 <geheimdienst> for packages, use ghc-pkg unregister
21:43:06 <rj_> I seem to get "Terminated" on every line. Does anyone know what's going on?
21:43:40 <Cale> Every line of what?
21:45:03 <tsuraan_> I have a function that returns IO (Either String (Foo a)), and something that's trying to use the (Foo a) (Snap's setResponseBody; Foo is an Enumerator).  ghc says something about skolems escaping their scope?
21:46:11 <tsuraan_> what can I do about (rigid, skolem) type variables escaping their scopes?  what does that even mean?
21:49:01 * hackagebot hbro 0.6.8.1 - A minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-0.6.8.1 (koral)
21:49:53 <tsuraan_> heh, added ImpredicativeTypes and replaces (Foo a) with (forall a. Foo a) , and it's happy now
21:50:09 <tsuraan_> I guess that sort of makes sense, in a really fuzzy way...
21:57:17 <Cale> tsuraan_: hmmm
21:57:37 <Chetore> can someone help me out? I'm a complete noob
21:58:50 <Cale> Chetore: Feel free to ask any questions you might have :)
21:59:05 <Chetore> Thanks! I've been learning Haskell for exactly a week
21:59:27 <Chetore> and I can't figure out why this doesn't work:
21:59:36 <Chetore> intersects (Line a b) (LineSegment (Point x1 y1) (Point x2 y2))
21:59:36 <Chetore> 	| x1 <= x && x <= x2 = True
21:59:36 <Chetore> 	| x2 <= x && x <= x1 = True
21:59:36 <Chetore> 	| otherwise = False
21:59:36 <Chetore> 	where x = (y1 - (((y2 - y1) / (x2 - x1)) * x1) - b) / (a - ((y2 - y1) / (x2 - x1)))
22:00:11 <Chetore> to check if a line a b intersects a given line segment
22:00:29 <shachaf> Chetore: Doesn't work in the sense of not type-checking or not being correct?
22:00:30 <dalaing> Chetore: are you getting an error, or is it not behaving how you expect?
22:00:50 <Chetore> I'm not getting an error. It's just returning False for things that should be True.
22:01:12 <shachaf> That looks more like a mathematics problem than a Haskell problem, then. :-)
22:02:14 <Chetore> Do you think so? I mean it wouldn't surprise me, but I also don't have great access to people to tell me if my code is okay that I'd never know
22:02:21 <Chetore> *so I'd never know
22:02:30 <Cale> hmm, Line a b represents what line?
22:02:33 <shachaf> @paste your definitions and a test case and such, if you have them?
22:02:34 <lambdabot> Haskell pastebin: http://hpaste.org/
22:02:49 <shachaf> Yes, what Cale said.
22:02:52 <Cale> It seems that a and b are numbers
22:03:18 <Cale> So y = a*x + b?
22:03:37 <shachaf> Oh.
22:03:38 <donri> > length ([minBound .. maxBound] :: [Char]) -- what actually is this number? actually defined code points?
22:03:39 <lambdabot>   1114112
22:03:51 <Cale> Or a*x + b*y = 1 maybe?
22:03:51 <shachaf> donri: They're not all defined.
22:03:51 <hpaste_> Chetore pasted “intersects” at http://hpaste.org/52122
22:03:51 <dalaing> it might be easier to read with m = (y2 - y1) / (x2 - x1) in the where bit
22:04:05 <shachaf> Indeed.
22:04:38 <shachaf> (Also, you can simplify your logic a bit using || and such.)
22:04:40 <dalaing> you might also want x = if x1 == x2 then x1 else ... to avoid dividing by zero
22:05:03 <Cale> Chetore: Which line does Line a b represent?
22:05:21 <dalaing> I'm only a month or two into this Haskell thing, so take what I say with a bowl of salt
22:05:39 <Chetore> I'm not sure I know what you mean... the test is to check if a line a b intersects with a line segment
22:05:47 <Chetore> so the user defines Line a b
22:06:00 <Cale> Chetore: I mean, what are the two parameters a and b?
22:06:06 <shachaf> Chetore: Right, but what line does Line a b refer to?
22:06:06 <Cale> What is the equation of the line?
22:06:08 <Chetore> ooooh sorry
22:06:19 <Chetore> a is slope; b is y-intercept
22:06:31 <Cale> Okay, so y = a*x + b is the line we're talking about
22:06:37 <Chetore> indeed
22:09:12 <dalaing> Chetore: which inputs are causing it to behave incorrectly?
22:09:50 <Cale> So if vx = x2 - x1 and vy = y2 - y1, we want to solve (y1 + t * vy) = a * (x1 + t * vx) for t, and check to see that t lies between 0 and 1.
22:10:02 <Cale> er, + b
22:10:45 <Chetore> I was using "let l1 = Line .25 1" and "let ls = LineSegment (Point (-2) (-1)) (Point (-2) 2)
22:10:47 <Chetore> "
22:10:57 <Chetore> which should intersect
22:11:12 <Chetore> also, I meant 0.25
22:13:04 <shachaf> Chetore: x1=x2, so you're dividing by 0.
22:13:34 <Ptival> oh shi-
22:13:59 <Chetore> ergh.
22:15:02 <rj_> when I try to type "5 + 7" (without quotes) it says Terminated!
22:15:21 <rj_> this happens for any command that the tutorial walks me through
22:15:26 <shachaf> Cale: lambdabot and lispy just went offline and then lispy came back, so I assume lambdabot can be brought back too.
22:15:27 <Cale> rj_: What says terminated?
22:15:38 <shachaf> rj_: tryhaskell.org?
22:15:39 <Cale> lambdabot was online...
22:15:40 <rj_> the Try Haskell window
22:15:41 <shachaf> Looks like it's broken right now.
22:15:52 <rj_> ah, is tryhaskell broken? ok
22:15:55 <shachaf> Cale: Right, she just died a couple of minutes ago.
22:16:20 <rj_> ok, thanks
22:16:31 <Cale> rj_: that's too bad, hrm
22:16:34 <shachaf> Chetore: dalaing mentioned the problem and gave a solution above, by the way. :-)
22:16:46 <Cale> intersects (Line a b) (LineSegment (Point x1 y1) (Point x2 y2)) = 0 <= t && t <= 1
22:16:46 <Cale> 	where vx = x2 - x1
22:16:46 <Cale>               vy = y2 - y1
22:16:46 <Cale>               t = (a * x1 - y1 + b)/(vy - a * vx)
22:16:56 <Cale> er, whoa, tabs!
22:17:14 <Chetore> what does "else" do? I've not run into that before
22:17:26 * hackagebot googleplus 0.2.1 - Haskell implementation of the Google+ API  http://hackage.haskell.org/package/googleplus-0.2.1 (MichaelXavier)
22:17:30 <shachaf> rj_: Did you get here by clicking the Chat link in tryhaskell? This is a general-purpose channel, which is why we were confused. :-)
22:17:34 <shachaf> > if True then 'a' else 'b'
22:17:34 <Cale> Chetore: Configure your text editor not to produce tab characters
22:17:39 <Chetore> ha also I've never used an if then statement... the joys of being a noob
22:17:39 <shachaf> > if False then 'a' else 'b'
22:17:42 <lambdabot>   'a'
22:17:45 <Cale> Chetore: If you're using vim, set expandtab
22:17:48 <lambdabot>   'b'
22:17:51 <Chetore> gedit
22:18:32 <shachaf> Edit->Preferences->Editor->Insert spaces instead of tabs (and shift-width 4 or something like that)
22:18:52 <shachaf> Chetore: It's not a statement, it's an expression. (if blah then A else B) will be A if blah is True and B if blah is False.
22:18:53 <Cale> yeah
22:18:55 <donri> I think you can also set it in the statusbar
22:19:11 <shachaf> What introduction/book/etc. are you using?
22:19:15 <Chetore> er, I have it set to 4
22:19:22 <donri> though that is per-buffer with no persistence i think
22:19:24 <shachaf> donri: Oh, so you can.
22:19:39 <shachaf> OK, but you want to use spaces too. :-)
22:19:42 <shachaf> Tabs are evil.
22:20:01 <shachaf> 0.999... out of 1 Haskellers agree.
22:20:13 <donri> smart tabs?
22:20:33 <donri> i doubt gedit is smart enough though :)
22:24:31 <Aatch> Vim! With smarttabs, smartindent and softtabs on
22:25:26 <shachaf> Aatch: softtabs? :-(
22:25:46 <shachaf> A mix of tabs and spaces is worse than either.
22:26:16 <donri> http://www.emacswiki.org/pics/static/TabsSpacesBoth.png
22:26:51 <hpaste_> Cale annotated “intersects” with “intersects (annotation)” at http://hpaste.org/52122#a52123
22:26:56 <Cale> Chetore: ^^
22:27:08 <Aatch> softtabs is just tabs = spaces
22:27:25 <Aatch> its a vim option.
22:27:29 <Chetore> thanks! reading it
22:28:04 <Cale> NO! softtabs is that weird thing which mixes tabs and spaces
22:28:09 <Cale> You want expandtab
22:28:10 <shachaf> Chetore: Is this homework, by the way?
22:28:41 <shachaf> Cale++ # talkin' sense
22:28:45 <Chetore> it is. Is that illegal? I mean, I wrote it myself and everything
22:28:57 <Cale> Nah, that's fine
22:28:59 <Aatch> I just checked, Cale is correct
22:29:14 <Aatch> Sorry
22:29:52 <Aatch> I was thinking of softtabstop, which lets vim treat spaces as tabs.
22:29:55 <Cale> You could use softtabs with 8 and have everything work, but people will still hate you
22:30:08 <donri> softtabstop is also about mixing
22:30:40 <Cale> You don't want any tab characters at all in your Haskell source files
22:30:49 <shachaf> Chetore: It's fine (though it's in general a good idea to mention it).
22:30:52 <glguy> Chetore: I don't know if this was covered, but if you do have haskell files with tabs, set your tabstops to 8
22:31:06 <dobblego> ?? {-# LANGUAGE TabSafeHaskell #-}
22:31:06 <lambdabot>  {-# LANGUAGE TabSafeHaskell #-}
22:31:09 <Aatch> 8? Really?
22:31:11 <glguy> OH, I just now noticed cale say it
22:31:16 <Chetore> sorry, I didn't know that was a thing
22:31:30 <Chetore> noted
22:31:32 <Cale> Aatch: It's necessary for the compiler to interpret things correctly
22:31:55 <Cale> Aatch: The compiler treats a tab character as aligning to the next higher multiple of 8 columns
22:32:06 <Aatch> oh right, so if you are mixing...
22:32:16 <Cale> So if your editor doesn't display it like that, you can end up with nonsense :)
22:32:27 <Aatch> I compulsively change all tabs to spaces in a source file
22:32:30 <Cale> yeah
22:32:48 <Cale> I think that tab characters should outright be considered a lexical error
22:32:57 <Cale> Even in a comment, just to be safe
22:33:07 <shachaf> Aatch: :retab :-)
22:33:12 <glguy> compulsive changing is a good way to make a mess of revision control history
22:33:17 <donri> so, no love for smart tabs then?
22:33:23 <Aatch> shachaf: thats what I do :D
22:33:33 <Cale> Tab characters are awful.
22:33:33 <shachaf> donri: smarttabs = spaces with tabby behavior.
22:33:41 <shachaf> donri: No one's objected to those. They're good.
22:33:53 <donri> 'smart tabs' as in tabs for indent and spaces for alignment
22:34:02 <donri> i see the benefits but think it might be a bit too clever
22:34:12 <Cale> You can have your editor do whatever you want when you press the tab key, so long as it's not inserting a tab character ;)
22:34:18 <shachaf> donri: That's not what "smart tabs" means.
22:34:32 <Cale> donri: No, that's a terrible policy
22:34:32 <shachaf> Maybe eviltabs.
22:34:34 <donri> http://www.emacswiki.org/emacs/SmartTabs
22:34:38 <Aatch> There is a thing that does that though
22:34:52 <shachaf> Oh, maybe in Emacs that's what it means. Stands to reason Emacs would would say that. :-)
22:35:08 <donri> :)
22:35:29 <Aatch> glguy: To be honest, if I have to open a file, I usually have to change it, so my tab changes get bundled with a real change anyway...
22:35:40 <donri> personally i use vim and all spaces, but i do see the charm of tabs (everyone can have their preferred indentation width)
22:35:43 <Cale> donri: The thing is, all the whitespace at the start of every line in a Haskell source file is for alignment, not indentation.
22:35:48 <glguy> it screws up the line-by-line attribution
22:36:15 <donri> i suppose that's true, layout ≠ plain off-side
22:36:29 <Cale> and it's important for things to line up to an exact column, so tabs which can be reinterpreted by different people's editors as a different number of spaces are really bad
22:36:39 <glguy> I don't recommend tabs in haskell source files, to be clear
22:36:47 <shachaf> glguy: When you work on a project in a revision control system, you follow whatever guidelines the project uses, of course.
22:37:12 <donri> shachaf: what if those guidelines are "tabs every second line"?
22:37:21 <Cale> If you find a Haskell project with lots of tab characters in the source files, please push a patch replacing them all with spaces anyway ;)
22:37:26 <shachaf> donri: Either get them changed or work on another project.
22:37:27 <donri> (except on thursdays)
22:37:32 <pelotom> hi, is anyone familiar with this paper? http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.6483
22:37:47 <donri> .oO( if hogwarts was a programmer )
22:37:47 <Aatch> In my experience, VCS never gets used to its full capability as it is, so worrying about line-by-line attribution is a waste of time.
22:38:15 <Aatch> Half the people I know barely even look at the commit logs after a pull
22:39:08 <glguy> Aatch: we should probably just work on different projects :)
22:39:45 <Cale> Besides, shouldn't it be character-by-character attribution? ;)
22:40:13 <shachaf> You mean it shouldn't attribute changes to shady characters like Aatch?
22:40:14 <Aatch> glguy: probably
22:40:32 <Aatch> I'm not shady, the people I know are shady. I am a paragon <.< >.>
22:57:02 <cheater> when using blaze html i always have to do things like eg:
22:57:02 <cheater> html $ do
22:57:02 <cheater>   head $ do
22:57:03 <cheater>     title
22:57:05 <cheater>     style
22:57:24 <cheater> is there a possibility to get rid of the $ do's and just let indentation work instead?
22:58:12 <shachaf> No, "do" is necessary.
22:58:15 <donri> either do's or parens
22:58:58 <shachaf> donri: What do parentheses have to do with "do"?
22:59:00 <shachaf> Maybe you mean $.
22:59:28 <Cale> Yeah, you could replace the $ with parens, though that's probably worse. You can replace do-notation with >>
22:59:29 <donri> shachaf: i mean not with blaze, but something similar could be done without do's but with parenthesis
22:59:32 <kfish> #define <HEAD> head $ do
22:59:44 <Cale> kfish: lol!
22:59:48 <donri> hsp :)
23:00:10 <shachaf> donri: I'm not sure how, unless you mean printf-style overloading or something like that.
23:00:24 <shachaf> Or brackets and commas. Or something.
23:01:01 <donri> shachaf: ah yea it would require lists or something
23:01:32 <donri> html [head [title ["ohai"], style []]]
23:01:47 <donri> tldr don't
23:02:05 <shachaf> There's always quasiquoting.
23:02:33 <donri> yea, hamlet does that already, which is whitespace-sensitive
23:09:09 <cheater> is there really no way to define new syntax in haskell?
23:09:15 <cheater> wow that's a bit weak
23:10:50 <donri> ... quasiquoting.
23:16:26 <TNA-MichaelK> I have been trying to declare in ghci like this: http://learnyouahaskell.com/syntax-in-functions but get errors like "<interactive>:1:1: Not in scope: `head'' "... Thoughts?
23:16:44 <mah_b> prefix with "let"
23:17:18 <TNA-MichaelK> Ah, ok.  So, it'll work in a .hs file like that but in ghci you need "let" ?
23:17:29 <mah_b> exactly
23:17:37 <TNA-MichaelK> Thank you.
23:17:52 <mah_b> you can simplified thin of ghci as if you were inside of a IO monad.
23:20:48 <TNA-MichaelK> I'm unfamiliar with monad.  Also, "The type signature for `head'' lacks an accompanying binding" means I just need the appropriate catch statements, right?
23:21:33 <Aatch> The GHCi is a very basic interpreter, as such, it doesn't do stuff like support mutli-line statements, which means having to desugar `do' blocks and similar everywhere
23:22:19 <Aatch> TNA-MichaelK: Monads are, not complicated, but difficult to explain without examples
23:22:56 <dalaing> TNA-MichaelK: normally when I "The type signature for 'XYZ'' lacks an accompanying binding" it means I have a typo between my type signature and my function definition
23:23:09 <dalaing> could be other reasons though, that's just the one I tend to come across
23:23:31 <TNA-MichaelK> Atach: It sounds like I should drop the idea of always using the interpreter, but I kind of want to see how to do this in an interpreter since it didn't say to switch over in this book.  Also, know of any nice examples?
23:24:16 <TNA-MichaelK> dalaing: Ah, thanks, any idea how to do: http://learnyouahaskell.com/syntax-in-functions in ghci then?
23:24:18 <donri> Aatch: :{
23:24:33 <TNA-MichaelK> ah, thanks
23:24:47 <donri> (end with :})
23:24:58 <Aatch> What!
23:25:14 <TNA-MichaelK> I spelled your name wrong by accident, donri pointed it out
23:25:15 <Aatch> donri: That would have been so so very useful
23:25:50 <donri> would?
23:26:13 <Aatch> TNA-MichaelK: I wasn't "What!"ing about that, its the discovery of the :{ command in GHCi
23:26:31 <TNA-MichaelK> ah, haha
23:26:51 <Aatch> donri: Well will as well I guess, but I've had several "I wish I could do multi-line expressions in GHCi" moments over the past week
23:27:17 <shachaf> :{ is overrated.
23:27:30 <donri> I didn't know it was rated at all.
23:27:30 * shachaf , at least, can't figure out a way of using it that isn't more trouble than it's worth.
23:27:43 <shachaf> TNA-MichaelK: To do which part?
23:28:05 <shachaf> TNA-MichaelK: Oh, I see.
23:28:11 <TNA-MichaelK> Perhaps: " factorial :: (Integral a) => a -> a  factorial 0 = 1  factorial n = n * factorial (n - 1)  "
23:28:16 <shachaf> TNA-MichaelK: Put them all one one line, separated with semicolons, and use let.
23:28:36 <shachaf> let factorial :: (Integral a) => a -> a; factorial 0 = 1; factorial n = n * factorial (n - 1)
23:28:38 <donri> would be nicer if you could do it per-line at the end of the line, e.g. end with \ or something
23:28:52 <Aatch> shachaf: When I'm trying to test some small 3-line proof-of-concept, then it can be very useful
23:29:02 <donri> or if it could parse do { as such, etc
23:29:02 <shachaf> Aatch: More than semicolons?
23:29:30 <shachaf> donri: If you had to use explicit {, there wouldn't be much point to multiline syntax anyway.
23:29:39 <TNA-MichaelK> shachaf: Ah, thanks, that's exactly what I wanted to see.
23:29:59 <donri> well, easier to keep track of what you're typing
23:30:21 <shachaf> Not really. For instance, up-arrow doesn't give you the entire previous line (though I suppose it could).
23:30:30 <TNA-MichaelK> donri: The semicolon method is easy enough for something simple like that.
23:31:04 <TNA-MichaelK> shachaf: It doesn't?
23:31:14 <donri> but you still have to write it as one big-ass one-liner
23:31:16 <dalaing> TNA-MichaelK: it might save you some time if you type the code into a file i.e. test.hs, then run ghci from the same directory and type :l test.hs to load it
23:31:23 <shachaf> TNA-MichaelK: If you use multiline syntax it doesn't.
23:31:51 <shachaf> If only there was good editor support for doing that smoothly.
23:32:09 * shachaf cleverly rules out Emacs by combining the words "good" and "editor".
23:32:20 <donri> http://www.vim.org/scripts/script.php?script_id=2356
23:32:29 * shachaf is not serious about that, in case that wasn't clear.
23:32:32 <TNA-MichaelK> dalaing: I'm not coding anything cohesive yet, just playing around with syntax.  I don't want to have to reload the file every time I try something new.  Actually, would you have to reload it?
23:33:17 <Aatch> TNA-MichaelK: yes, fortunately, there is :reload
23:33:27 <Aatch> which reloads all currently loaded files
23:33:29 <TNA-MichaelK> shachaf: What's not good about emacs except that it's too complicated?
23:33:34 <TNA-MichaelK> speaking of emacs...
23:33:46 <TNA-MichaelK> http://xkcd.com/378/
23:33:52 <Aatch> NO
23:34:08 <dalaing> TNA-MichaelK: in the worst case it's probably as much work either way, and working in a file will probably pay off before too long for one reason or another
23:34:10 <TNA-MichaelK> Aatch: Ah, lifesaver! That reloads all?
23:34:15 <TNA-MichaelK> oops
23:34:17 <donri> emacs is great, it just needs a good editor
23:34:27 * shachaf is very sorry to have started this.
23:34:32 <donri> ;)
23:34:36 <Blkt> good morning everyone
23:34:54 * shachaf goodmorn Blkt
23:35:00 <Blkt> :)
23:36:04 <TNA-MichaelK> dalaing: good advice;  donri: Ah, haha, I understand that too well :}; shachaf: started what?
23:36:27 <dalaing> TNA-MichaelK:  unless I've got this horribly wrong, you can't define new data types in ghci (except for the new stuff in trunk, I think)
23:36:57 <Aatch> That said, I was impressed when I discoved that GHCi could parse pragmas
23:37:41 <shachaf> Aatch: It can?
23:38:32 <Aatch> yes, you can type {-# LANGAUGE Extension #-} and it seems to parse it ok
23:38:45 <shachaf> It parses as a comment.
23:38:49 <shachaf> It doesn't look like it does anything.
23:38:58 <Aatch> it seemed like I could use the extension
23:39:03 <Aatch> I could be wrong though
23:39:10 <TNA-MichaelK> dalaing: Ah? I'm not even sure why I'd want to yet. Right now, I'm just trying to get a feel for these functions and create a few variants.
23:39:19 <donri> could you not use it before?
23:39:38 <donri> falsifiability, man
23:40:47 <Aatch> I will admit that I can't even remember what I was doing at the time
23:47:07 <rostayob> How should I represent C types from stdint.h (uint32_t etc) in Haskell? Are Int32/Word32 etc going to be fine?
23:47:51 <Aatch> Shouldn't the Foreign.C.Types cover all of that?
23:48:02 <rostayob> Aatch: it doesn't
23:48:07 <rostayob> http://www.haskell.org/onlinereport/haskell2010/haskellch28.html#x36-27400028
23:48:40 <shachaf> rostayob: Why wouldn't Int32/Word32 work?
23:48:49 <Aatch> I sit corrected
23:49:00 <rostayob> shachaf: well then why do we have CInt at all?
23:49:01 <Aatch> Not that I was asserting fact to start with <.<
23:49:29 <rostayob> shachaf: These types are needed to accurately represent C function prototypes, in order to access C library interfaces in Haskell. The Haskell system is not required to represent those types exactly as C does, but the following guarantees are provided concerning a Haskell type CT representing a C type t:
23:50:41 <rostayob> shachaf: anyway, it's probably fine, i was just curious
23:52:24 <kmc> rostayob, you can use hsc2hs to be sure
23:52:32 <kmc> (#type uint32) or whatever
23:53:04 <rostayob> kmc: oh, that works? cool
23:53:26 * hackagebot websockets 0.3.1.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.3.1.0 (JasperVanDerJeugt)
23:53:36 <shachaf> rostayob: CInt presumably exists because C's int can be a different type from Haskell's Int.
23:54:23 <kmc> indeed quite often is
23:54:34 <rostayob> shachaf: yeah that's true. ghc is 64bit most of the times
23:54:46 <rostayob> and yes, hsc2hs returns Int32
23:54:50 <rostayob> so thanks to both
