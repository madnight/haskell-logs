00:02:04 <ddarius> c_wraith: Java -was- slow.
00:02:41 <c_wraith> but someone on the internet said java is slow last week!  was someone on the internet wrong?
00:05:01 <shachaf> c_wraith: I heard someone on the Internet say that someone on the Internet was wrong.
00:05:04 <ddarius> c_wraith: Last week was a long time ago.
00:05:13 <c_wraith> ddarius: good point.
00:05:37 <Rc43> clear
00:05:50 <Rc43> Hi.
00:06:03 <impl> (Java hasn't been slow since 1.4 [well, since HotSpot], but that doesn't have anything to do with much)
00:06:06 <Rc43> Anybody familiar with haskell plugins?
00:06:29 <Rc43> I want to get method to declare interfaces for plugins.
00:13:09 <c_wraith> Rc43: That could mean quite a few different things.  What do you actually want to do?
00:13:52 <Rc43> c_wraith, suppose I have an application with core and plugin
00:14:27 <Blkt> good morning everyone
00:14:32 <Rc43> c_wraith, I want to write other plugin with common iface to current
00:14:48 <adrake>     Couldn't match expected type `STRef s[a3UL]0 (PHBlock s[a3UL]0)'
00:14:48 <adrake>                 with actual type `S.Set a0'
00:14:53 <adrake> that is not much of a type name, right there
00:17:00 <c_wraith> Rc43: it's not something that's heavily standardized.  The options available in GHC are roughly equivalent to what you get from DLLs or shared objects on non-windows
00:17:06 <shachaf> Well, ST is a mystery.
00:17:22 <c_wraith> I find it strange that s was even instantiated to a type
00:17:57 <c_wraith> that should never actually happen in ST. :)
00:17:57 <shachaf> Should this happen in ST?
00:17:57 <shachaf> > id runST (return 5)
00:17:57 <lambdabot>   Couldn't match expected type `m t'
00:17:57 <lambdabot>         against inferred type `forall s....
00:17:57 <shachaf> > (id runST) (return 5)
00:17:57 <lambdabot>   5
00:18:02 <shachaf> (This is a completely different type of complain, of course.)
00:18:09 <c_wraith> with sufficient impredicativity, sure
00:18:28 <shachaf> c_wraith: I'd think that the two would be syntactically equivalent.
00:18:49 <zygoloid> rank-2 types, inference, blah :)
00:18:58 <c_wraith> well, yes, the fact that the two are treated differently is strange.  need more impredicativity
00:19:32 <Rc43> c_wraith, I think it isn't difficult to write by myself, but if it is implemented already it will be more convinient to use it.
00:20:45 <c_wraith> Rc43: are you using hs-plugins?
00:21:40 <Rc43> c_wraith, yes
00:22:38 <c_wraith> Rc43: I think there's no standardized approach.  My idea would be to package everything you need into a big record type and document it.   Then say that when you load a plugin module, it should have one of those records with a specific name.
00:22:54 <Rc43> c_wraith, I suppose such case: core has an declared interface and plugin has too, whe core tries to load plugin it will check that plugin supports core's interface
00:27:49 <Rc43> c_wraith, i didnt' read about it yet, but it seems haskell has ioc frameworks. May be it will be better to use it?
00:29:10 <c_wraith> that seems almost orthogonal.  That seems like it would be part of the types in the record you load, rather than part of how you'd load stuff
00:31:03 * hackagebot resource-pool-catchio 0.2.0.2 - Fork of resource-pool, with a MonadCatchIO constraint  http://hackage.haskell.org/package/resource-pool-catchio-0.2.0.2 (JurrienStutterheim)
00:31:05 * hackagebot certificate 0.9.5 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.9.5 (VincentHanquez)
01:39:30 <hpaste> “Ertugrul Söylemez” pasted “Concurrent echo server” at http://hpaste.org/52742
02:08:01 <Dybber> Does anyone have experience with running HPC on a code base which relies heavily on C2HS? I can't get it to give any reasonable output.
02:14:22 <zhourujin> halo
02:16:07 * hackagebot clash 0.1.3.9 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.3.9 (ChristiaanBaaij)
02:26:07 * hackagebot hakyll 3.2.0.10 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.0.10 (JasperVanDerJeugt)
02:26:13 <taruti> Has anyone used GHC on arm?
02:44:51 <DevHC^> oh look, there's yet another algorithm which is supposed to solve an NP-complete task in polynomial time
02:45:11 <DevHC^> the algorithm starts with: u := 2^(2^n) - 1
02:45:16 <DevHC^> where n is the length of the input
02:45:24 <DevHC^> does anyone see a problem here? :}
02:45:48 <DevHC^> (btw http://arxiv.org/abs/1110.1658)
02:47:09 <int-e> DevHC^: No. 2^(2^n) - 1 is a constant size string :)
02:47:26 <int-e> But I'm not going to look at the paper.
02:48:07 <DevHC^> sarcasm detected
02:48:43 <int-e> Me? Sarcasm? Never! .... Ok, maybe a little.
02:48:50 <DevHC^> lol
02:58:54 <DevHC^> does anyone know any public PvsNP discussion channel, where every now and then someone throws up a proof, but gets his virtual_ass handed to him/her by others? xD
03:01:10 * hackagebot complex-integrate 0.1 - A simple integration function to integrate a complex-valued complex functions  http://hackage.haskell.org/package/complex-integrate-0.1 (MarkSafronov)
03:01:38 <opqdonut> you had me at "complex-integrate 0.1 - A simple"
03:03:58 <frerich> DevHC^: I'm sorry for my ignorance, and I'm sure this idea is super old and has been discarded many times, but when hearing about such stuff (I'm not familiar with 'NP' vs 'P' or stuff like that) I wonder: why don't people start writing proofs in a way which can be verified mechanically for such things, is that impossible to do?
03:04:10 <frerich> I know that this is a really stupid question, but I'm curious. :-)
03:04:41 <geheimdienst> P=NP for N=1. QED.
03:04:59 <frerich> I wonder, maybe the "proof" for this problem always involves either a wrong precondition, or it contains a 'magic step' which cannot possibly be proved mechanically because no computer could ever comprehend the genius idea or so.
03:06:10 * hackagebot theta-functions 0.1 - Theta-functions implemented as trigonometric series  http://hackage.haskell.org/package/theta-functions-0.1 (MarkSafronov)
03:06:28 * frerich never really "proved" anything but had the impression that it's basically the process of showing that some statement to be proven can be derived from another statement (which is known to be true or just accepted in some sense) using a sequence of steps, and each step maintains the truth value. So to me, that sounds like something a computer could do?
03:07:03 <frerich> I'm unsure whether this room filled with math people is the worst possible place to ask such a question, or whether it's actually a really good place. :-)
03:07:09 <ziman> It's quite a lot of work, sometimes. And you need a sufficient body of formalized mathematics to build on.
03:13:42 <erus`> has addition been proved now?
03:13:54 <ziman> But there are (quite serious) proofs formalized already (e.g. goedel's first incompleteness theorem in roconnor's thesis: http://r6.ca/Thesis/).
03:19:07 <frerich> Just in case I wasn't clear: I'm merely wondering whether it would be possible for a computer to *verify* a proof, assuming that the proof has been formalized enough. It would be nice to have such a device for automatically checking submissions. :-)
03:25:36 <erus`> does neil mitchel come in here?
03:25:50 <gienah> frerich: some mathematical proofs can be formalized and verified with proof assistants like coq and isabelle
03:26:39 <DevHC^> frerich: however, formalization of proofs in such assistants takes a long time, like many years for a 100-page proof
03:27:09 <frerich> Wow
03:27:59 <dalaing_home> frerich: lots of paths down the road to automatic proofs end up with you needing to solve NP-complete problems
03:28:09 <redsteg> do they have to be verified all the way down, or can you start by assuming things people already believe to be true, and go from there?
03:28:12 <erus`> DevHC^: can't you just add more ram?
03:28:38 <DevHC^> erus`: 2^(2^n) - 1 requires EXPONENTIAL amount of RAM
03:29:21 <erus`> 8 gig should be enough
03:29:34 <DevHC^> erus`: WRONG
03:29:42 <frerich> hehe
03:29:50 <sipa> for n=3
03:29:53 <dalaing_home> frerich: also, if generating the proof is an NP-complete problem, verifying the proof is in P (by definition)
03:30:00 <sipa> for n=36
03:30:06 <gienah> redsteg: in coq you can use axioms for things you believe are true and do not wish to prove, however if the axiom is wrong then everything else is incorrect
03:31:53 <nonicknameavaila> newbie questions allowed?
03:31:57 <redsteg> gienah: sure, but I guess you have the same problem for maths papers that rely on the results of other papers
03:32:04 <DevHC^> frerich: basically, no mathematical reasoning has statements like "X is true". all statements are actually "if Y, Z, and etc. r true, then X is also true"
03:33:09 <nonicknameavaila> http://hpaste.org/52745 - what have i done wrong? (except for an ugly code)
03:33:48 <gienah> redsteg, frerich: a course on coq in case you are interested: http://vimeo.com/album/1497795/page:1 which starts with this video: http://vimeo.com/18138042
03:34:02 <frerich> DevHC^: So the 'meat' of the proof is that you have some insights and realize that you can chain implications like that together to go from some start point to some end point which wasn't reachable using implications before?
03:34:04 <erus`> do you juust define functions in coq?
03:34:19 <frerich> DevHC^: I apologize for the wording :-)
03:34:41 <redsteg> gienah: thanks
03:34:57 <jweofijm> @pl ispalindrome::Eq a => [a]->Bool; ispalindrome = (\x y -> x y y) ((==).reverse)
03:34:58 <lambdabot> (line 1, column 26):
03:34:58 <lambdabot> unexpected ">" or "-"
03:34:58 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
03:35:07 <DevHC^> nonicknameavaila: add parentheses around b++[(b!!(length b-1))+(b!!(length b-2))] ?
03:35:27 <nonicknameavaila> thanks
03:35:32 <nonicknameavaila> does work splendid
03:36:05 <jweofijm> @pl (\x y -> x y y) ((==).reverse)
03:36:05 <lambdabot> (==) =<< reverse
03:36:14 <DevHC^> frerich: yes, basically
03:38:25 <DevHC^> frerich: what we write as "P=NP" is actually "if we assume the existence of natural numbers, and assume that 1+1=2, also assume the existence of lists, functions, and what not, then P=NP"
03:39:56 <osfameron> assumptions make an ass of u and mption
03:40:31 <gienah> erus`: sometimes it is easier to prove things about propositions in coq rather than functions, then to prove the function is equivalent to the proposition, this is discussed here: http://www.cis.upenn.edu/~bcpierce/sf/Imp.html section "Equivalence of Relational and Step-Indexed Evaluation"
03:42:12 <Athas> Why are there so many 404 links on Hoogle?  Is it some known bug or is it just lagging behind Hackage?
03:45:19 <gienah> erus`: coq can only extract Haskell code from functions though (like fixpoints), hence its useful to write functions if you want to extract certified code. The extracted code though is likely to have Peano numbers, and may use unsafe coerce to do stuff in the extracted code. coq has dependent types so coq understands its safe to do stuff that Haskell's type system may not know about.
03:46:09 <erus`> ooo i didnt know you could do that
03:47:18 <hughfdjackson> hey guys
03:47:22 <hughfdjackson> newbie question..
03:47:50 <hughfdjackson> :P and i resolved it
03:47:56 * hughfdjackson should double check before asking
03:47:59 <Botje> another satisfied customer
03:48:03 <hughfdjackson> you guys
03:48:09 <hughfdjackson> just your presence is enough
03:48:34 <sipa> we're telepathocally awesome?
03:48:42 <sipa> telepathically
03:48:45 <gienah> erus`: some info on extracting Haskell from coq: http://www.reddit.com/r/haskell/comments/gf3sb/reimplementing_xmonads_core_in_coq_wouter/
03:50:00 <hughfdjackson> telepathy over irc is quite the revelation
03:51:10 * hackagebot netwire 1.2.7 - Arrowized FRP implementation  http://hackage.haskell.org/package/netwire-1.2.7 (ErtugrulSoeylemez)
04:06:02 <KitB> I know this is a little cheeky, but you guys might be able to help:
04:06:03 <KitB> http://stackoverflow.com/q/7792456/998879
04:07:42 <frerich> KitB: It's a pity that your question is "Could any of you suggest what I might be doing wrong in my GA implementation to make the graph look like this?" but none of your images, including the graph, is visible because you don't have enough reputation.
04:08:03 <KitB> frerich: I've linked a page at the top which has them all
04:09:25 <Xeli> Hi, I've implemented the show class like this: http://pastebin.com/cHLpdJNj but it displays card like this: "N""V" how can i make it show up like: "NV" or even just NV ?
04:09:26 <mauke> The paste cHLpdJNj has been copied to http://hpaste.org/52749
04:09:32 <erus`> cabal is dependency hell
04:09:44 <Xeli> what's the difference between the last two anyway?
04:10:59 <KitB> Xeli: Show us the "data" declaration too
04:12:49 <Xeli> KitB: here it is: http://pastebin.com/iiWWPkzF
04:12:51 <mauke> The paste iiWWPkzF has been copied to http://hpaste.org/52750
04:13:52 <KitB> Just noting: I would call CardColor Suit
04:15:20 <hpaste> KitB annotated “pastebin.com/iiWWPkzF” with “pastebin.com/iiWWPkzF (annotation)” at http://hpaste.org/52750#a52751
04:15:37 <KitB> Xeli: See above link.
04:16:01 <KitB> explicitly: http://hpaste.org/diff/52750/52751
04:16:03 <KitB> There's a diff
04:19:04 <Xeli> KitB: Im not yet sure why it works but atleast it does, thanks :)
04:19:24 <KitB> Xeli: When you write a show instance, you just need to return a String
04:19:37 <KitB> You were running show on those strings
04:19:45 <KitB> > "S"
04:19:46 <lambdabot>   "S"
04:19:50 <KitB> >show "S"
04:19:53 <KitB> > show "S"
04:19:54 <lambdabot>   "\"S\""
04:20:03 <KitB> You see?
04:20:03 <rtharper> so many double quotes
04:20:12 <Xeli> ahh
04:20:13 <rtharper> > show (show "S")
04:20:14 <lambdabot>   "\"\\\"S\\\"\""
04:20:16 <Xeli> :P
04:23:53 <eikke> is there any way to tell ghc my .foo file is actually a .lhs file?
04:24:39 <erus`> > (read . show)  "Hello"
04:24:41 <lambdabot>   *Exception: Prelude.read: no parse
04:24:47 <erus`> > (read . show)  "Hello" :: String
04:24:48 <lambdabot>   "Hello"
04:25:18 <erus`> > (read read read read . show show show show)  "Hello" :: String
04:25:19 <lambdabot>   Couldn't match expected type `GHC.Base.String'
04:25:19 <lambdabot>         against inferred typ...
04:25:40 <erus`> > (read . read . read . read . show . show . show . show)  "Hello" :: String
04:25:41 <lambdabot>   "Hello"
04:26:53 <ClaudiusMaximus> eikke: possibly -x lhs  - manual says "Override default behaviour for source files"
04:27:24 <KitB> > iterate show "Hello"
04:27:25 <lambdabot>   ["Hello","\"Hello\"","\"\\\"Hello\\\"\"","\"\\\"\\\\\\\"Hello\\\\\\\"\\\"\"...
04:27:32 <eikke> ClaudiusMaximus: thanks! must have overlooked that one... works!
04:40:52 <geheimdienst> when reading about the ST monad, the word thread has nothing to do with multithreading, right?
04:41:47 <Twey> geheimdienst: No, nothing at all
04:41:53 <Twey> Well
04:42:08 <Twey> Probably; I guess in theory you could parallelise a state thread into an OS thread
04:42:26 <Twey> But that's a transparent optimisation, which means that by definition you don't have to care about it ;)
04:42:49 <int-e> it's a thread in the sense that it executes a linear sequence of operations
04:44:14 <int-e> But there's no notion of concurrency built into ST, no communication at all.
04:44:16 <geheimdienst> all i can say is that when you think of multithreading and read this, you get confused ... http://www.haskell.org/haskellwiki/Monad/ST
04:44:21 <ClaudiusMaximus> as i understand it (not an expert), it's restricted to single-threading for sequencing actions explicitly, when unrestricted non-strict evaluation could use different evaluation orders; the restriction through the type system allows real mutation to be used under the hood
04:46:05 <ClaudiusMaximus> or maybe i'm getting two things confused
04:46:26 <int-e> Yeah, ST is concerned with a single thread isolated from everyhting else. So any thoughts of multi-threading will be misleading.
04:49:02 <ClaudiusMaximus> mm, more i think about it the more i think i was confused - the sequencing is normal data dependency stuff, and the type magic is to stop mutation leaking out of scope?
04:50:20 <int-e> essentially, yes.
04:50:46 <int-e> (the data dependency stuff is an implementation detail though)
04:51:42 <ClaudiusMaximus> sure, but no more an implementation detail than (>>=)'s implementation for State or whatever?
04:52:18 <ClaudiusMaximus> @src State (>>=)
04:52:18 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:52:40 <ClaudiusMaximus> @unmtl State
04:52:40 <lambdabot> err: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
04:52:45 <ClaudiusMaximus> @unmtl State s a
04:52:45 <lambdabot> s -> (a, s)
04:54:53 <ClaudiusMaximus> @type let bind = (>>=) ; c = runState (undefined `bind` undefined) undefined in bind
04:54:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:55:06 * ClaudiusMaximus gives up
04:56:16 <b_jonas> ST is magic
04:57:06 <KitB> ST is wonderful
05:01:11 * hackagebot xml2html 0.0.1 - blaze-html instances for xml-enumerator types  http://hackage.haskell.org/package/xml2html-0.0.1 (MichaelSnoyman)
05:06:19 <o-_-o> I need to do something like map read ["0", "10", "11"]
05:06:28 <o-_-o> How do I do this ?
05:06:59 <Starfire> > map read ["0", "10", "11"] :: [Int]
05:07:00 <lambdabot>   [0,10,11]
05:07:00 <erus`> map read ["0", "10", "11"] :: [Int]
05:07:05 <o-_-o> I mean I need to give read "10"::Int, how do I give ::Int to all the things in a list ?
05:07:06 <erus`> damn
05:07:07 <o-_-o> ah
05:09:03 <klapaucius> ST is way better than magic. ST just works
05:09:56 <o-_-o> what if t = ["0", "10", "11"]
05:10:04 <o-_-o> map read t::[Int] ?
05:11:03 <Starfire> o-_-o: Note that map read ["0", "10", "11"] :: [Int] is actually (map read ["0", "10", "11"]) :: [Int]
05:11:16 <o-_-o> ah...
05:12:10 <Starfire> > map (read :: String -> Int) ["0", "10", "11"] -- This will also work
05:12:10 <lambdabot>   [0,10,11]
05:12:24 <o-_-o> ah...let me try that
05:12:40 <mauke> > map read ["0", "10", "11"] `asTypeOf` [0]
05:12:41 <lambdabot>   [0,10,11]
05:13:02 <b_jonas> mauke: wouldn't you need to specify the type of the 0 then?
05:13:05 <o-_-o> woohoo that worked
05:13:08 <mauke> defaulting
05:13:11 <o-_-o> Starfire: thanks
05:13:24 <b_jonas> doesn't it default to Integer?
05:13:29 <hpc> b_jonas: yes
05:14:08 <hpc> if you use the result of that read somewhere it might infer that it's a list of Ints
05:14:09 <Starfire> o-_-o: And if you have the type there already due to context (e.g. you're passing the result to some function that expects [Int]), you don't need any annotation.
05:14:10 <mauke> > map read ["0", "10", "11"] `asTypeOf` fix (return . length)
05:14:11 <lambdabot>   [0,10,11]
05:14:21 <b_jonas> right
05:14:42 <b_jonas> lol
05:14:46 <b_jonas> fix (return . length)
05:14:50 <o-_-o> Starfire: no in this case I am doing something incredibly stupid
05:15:31 <hpc> return . length :: [a] -> [Int], which unifies with fix and becomes [Int] -> [Int]
05:15:42 <hpc> then the whole expression is of type [Int]
05:15:55 <mauke> return . length :: Monad m => [a] -> m Int
05:15:56 <b_jonas> exactly
05:16:43 <b_jonas> > map read ["0", "10", "11"] `asTypeOf` pure (1 :: Int)
05:16:44 <lambdabot>   [0,10,11]
05:17:51 <o-_-o> goo.gl/xTDmQ
05:18:03 <o-_-o> I am experimenting with HSH and haskell
05:18:34 <o-_-o> I think there should be a way to simplify this
05:18:44 <o-_-o> it takes the size field of ls -l and adds all of it up
05:19:13 <mauke> why not fetch the size yourself?
05:19:17 <mauke> easier than parsing ls output
05:19:39 <o-_-o> I know, I am just doing it for fun, and gaining familiarity with haskell
05:20:04 <b_jonas> at least call it as ls -b if you want to parse it
05:20:09 <o-_-o> now to simplify the above
05:20:14 <o-_-o> hmmm... ?
05:20:22 <b_jonas> I mean ls -lb
05:20:53 <o-_-o> What happens when you do ls -lb ?
05:21:06 <o-_-o> ah...ok got it
05:21:14 <benmachine> -b gets you octal escapes for magic characters apparently
05:21:28 <o-_-o> yeah...
05:21:53 <Twey> http://mywiki.wooledge.org/ParsingLs
05:22:25 <mysticc> can you name some universities where good research projects related to functional programming are active ..??
05:23:08 <o-_-o> Twey: this is not serious, I am learning things with this, I'll never use the above script for anything serious
05:23:17 <Twey> Okay
05:25:11 <mauke> ls -l | ghc -e 'interact ((++ "\n") . show . sum . map (read . (!! 4) . words) . drop 1 .lines)'
05:25:24 <mauke> what do I win?
05:25:59 <o-_-o> heh
05:26:00 <benmachine> a big cake
05:26:05 <meric> I'm studying the tutorial and saw it mention a class like (class C a where m :: Show b => a -> b). It didn't show an example of how to instantiate it so I tried it on my own, but I don't get it. http://hpaste.org/52752
05:26:46 <benmachine> meric: you can't do much with that type
05:26:47 <mauke> meric: that class has no useful instances
05:27:01 <mauke> meric: m is required to return any type that is an instance of Show
05:27:14 <mauke> meric: that is, m's *caller* gets to choose any type it wants and m has to comply somehow
05:27:17 <meric> I didnt get why they put it in the tutorial
05:27:25 <benmachine> which tutorial
05:27:28 <mauke> what do you mean by "the tutorial"?
05:27:33 <meric> so you can't instantiate it?
05:27:38 <meric> http://www.haskell.org/tutorial/classes.html
05:27:50 <mauke> heh, the "gentle" introduction
05:28:00 <meric> search for "Class methods may have additional class constraints"
05:28:30 <mauke> right
05:28:41 <mauke> it's just a random example with a class context on some type
05:28:44 <NaFiann> Hi, I'm trying to learn haskell, and am not sure how to do the following the easiest way: say I have an infinite list of nums, that I know will converge at some point. How do I traverse the list until it is converged and return the value at that point?
05:28:47 <mauke> completely useless otherwise
05:28:53 <meric> Okay
05:28:56 <meric> thanks
05:29:08 <benmachine> NaFiann: how do you know when it's converged
05:29:24 <mauke> meric: do you know about "learn you a haskell"?
05:29:25 <benmachine> is a list that goes 1,2,2,3 possible
05:29:52 <NaFiann> benmachine previous value will be same (or within a bound) from the current value.
05:29:55 <NaFiann> benmachine: no
05:29:58 <Botje> NaFiann: compare the list against a delayed copy of it
05:30:19 <mauke> it's ap zip tail time
05:30:20 <Botje> zip list (tail list) -- and then take an element where fst is close enough to snd
05:30:34 <Botje> mauke: :D
05:30:51 <mauke> :t fst . head . dropWhile (uncurry (/=)) . ap zip tail
05:30:52 <lambdabot> forall a. (Eq a) => [a] -> a
05:30:56 <meric> mauke: yeah I've been through all except the last three monads chapter
05:31:11 * hackagebot wai-app-file-cgi 0.3.5 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.3.5 (KazuYamamoto)
05:31:13 * hackagebot mighttpd2 2.3.4 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.3.4 (KazuYamamoto)
05:31:30 <NaFiann> Botje, mauke  thx :) will try that
05:31:33 <mauke> > fst . head . dropWhile (uncurry (/=)) . ap zip tail . iterate (0.5 *) $ 1
05:31:35 <lambdabot>   0.0
05:34:01 <drchill> aw
05:34:05 <drchill> woah
05:34:39 <mauke> knock knock, neo
05:35:42 <b_jonas> could you also use (fromJust . find p) instead of (head . dropWhile p) ?
05:35:46 <geheimdienst> in the example code inside the haddock, it says "instance Attributes where". that's a typo and should read "instance Attributes Flag where", right? http://hackage.haskell.org/packages/archive/cmdlib/0.3.4/doc/html/src/System-Console-CmdLib-ADTs.html#ADT
05:35:54 <geheimdienst> ... cause it could also be a bug in my understanding :)
05:54:04 <ClaudiusMaximus> > let sheetBlend samples zoom = let base = logBase 4 samples + zoom ; sheet = floor base ; delta = base - fromIntegral sheet ; blend = 1 - (1 - 4**delta) / (4**(delta + 1) - 4**delta) in (sheet, blend) ; diff s = let (sh,bl) = sheetBlend s in abs (s - (4^sh * bl + (1-bl) * 4^(sh + 1))) in map diff [0.1, 0.4 ..]
05:54:04 <lambdabot>   Couldn't match expected type `(t, t1)'
05:54:05 <lambdabot>         against inferred type `t2 ->...
05:55:37 <ClaudiusMaximus> > let sheetBlend samples zoom = let base = logBase 4 samples + zoom ; sheet = floor base ; delta = base - fromIntegral sheet ; blend = 1 - (1 - 4**delta) / (4**(delta + 1) - 4**delta) in (sheet, blend) ; diff s z = let (sh,bl) = sheetBlend s z in abs (s - (4^sh * bl + (1-bl) * 4^(sh + 1))) in liftM2 diff [0.1, 0.4 .. 5] [0.1, 0.3 .. 0.9]
05:55:38 <lambdabot>   [*Exception: Negative exponent
05:55:50 <ClaudiusMaximus> > let sheetBlend samples zoom = let base = logBase 4 samples + zoom ; sheet = floor base ; delta = base - fromIntegral sheet ; blend = 1 - (1 - 4**delta) / (4**(delta + 1) - 4**delta) in (sheet, blend) ; diff s z = let (sh,bl) = sheetBlend s z in abs (s - (4^^sh * bl + (1-bl) * 4^^(sh + 1))) in liftM2 diff [0.1, 0.4 .. 5] [0.1, 0.3 .. 0.9]
05:55:50 <lambdabot>   [6.599411862124518e-2,7.422836111771694e-2,8.046875000000002e-2,0.136830713...
05:56:31 <ClaudiusMaximus> > let sheetBlend samples zoom = let base = logBase 4 samples + zoom ; sheet = floor base ; delta = base - fromIntegral sheet ; blend = 1 - (1 - 4**delta) / (4**(delta + 1) - 4**delta) in (sheet, blend) ; diff s z = let (sh,bl) = sheetBlend s z in abs (s - (4^^sh * bl + (1-bl) * 4^^(sh + 1))) in filter (> 0.1) $ liftM2 diff [0.1, 0.4 .. 5] [0.1, 0.3 .. 0.9]
05:56:31 <lambdabot>   [0.1368307135172496,0.26397647448498057,0.29691344447086776,0.3218750000000...
05:57:30 <ClaudiusMaximus> something wrong somewhere, but i'll stop spamming and fire up local ghci
06:13:24 <ketil> darcs: ./_darcs/tentative_pristine-0: rename: resource busy (Device or resource busy)
06:13:36 * ketil wonders how far he should trust darcs when NFS is acting up.
06:18:19 <ClaudiusMaximus> got it working :)
06:18:21 <ClaudiusMaximus> > let sheetBlend samples zoom = let base = logBase 4 (4**zoom * samples) ; sheet = floor base ; delta = negate $ base - fromIntegral sheet ; blend = 1 - (1 - 4**delta) / (4**(delta+1) - 4**delta) in (sheet, blend) ; blend s z = let (sh, bl) = sheetBlend s z ; k = fromIntegral sh - z in (4**k * bl + (1 - bl) * 4**(k + 1)) ; diff s z = abs (s - blend s z) in filter (> 1e-6) $ liftM2 diff [0.1, 0.4 .. 16] [0.1, 0.3 .. 0.9]
06:18:22 <lambdabot>   []
06:21:04 <engla> I know a better computation that produces the same result
06:21:05 <engla> > []
06:21:06 <lambdabot>   []
06:27:16 <erus`> lambdabot: is multiplayer ghci
06:50:31 <fasta> What's the current best parsing library (correct, documentation, speed would be the order of requirements)?
06:51:38 <adrake> fasta: it's my understanding that it's parsec (although I hope speed really is your last priority), but I'm far from an expert
06:54:20 <shachaf> Trifecta looks nice. I'm not sure how complete/usable it is.
06:54:42 <adrake> trifecta does look nice
06:54:47 <fasta> dcoutts: Are you ever going to release us from the extremely time wasting "Perhaps you haven't installed the profiling libraries for package message"?
06:55:03 <adrake> I stopped just short of switching over my school project to it
06:56:12 * hackagebot cake 0.3.0 - A build-system library and driver  http://hackage.haskell.org/package/cake-0.3.0 (JeanPhilippeBernardy)
06:56:31 <fasta> trifecta is more of an exercise to show that GHC 6 and 7 are completely different.
06:58:12 <llano> Anyone knows how to install FranTk in windows?
06:58:37 <dcoutts> fasta: hope so yes, but it's not trivial
06:58:49 <dcoutts> relies on some other new infrastructure we're working on
06:59:12 <fasta> it was found in multiple packages: parsec3-1.0.0.4 parsec-3.1.0 <- how do I nuke the latter one?
06:59:30 <dcoutts> use ghc-pkg hide
06:59:47 <dcoutts> or nuke it with unregister
07:01:41 <fasta> ghci should ask: 'input a number to select the one you want to use'.
07:02:01 <fasta> Perhaps the unique naming policy in Java isn't a bad idea either...
07:02:41 <fasta> dcoutts: a shell script could even do it automatically by parsing the error messages. What problem are you talking about?
07:12:45 <dcoutts> fasta: to do it properly we need to track the profiling lib separately from the normal one
07:13:08 <dcoutts> and we need to be able to build the profiling lib matching any normal lib, ie reproducing the same configuration
07:13:36 <fasta> dcoutts: why don't you just give up on Hackage and use Nix?
07:14:00 <fasta> dcoutts: (unless you have some good reason why you think that cabal, etc. is better than Nix)
07:14:42 <dcoutts> fasta: I think we can take the nix ideas and apply them in cabal
07:15:03 <dcoutts> and thus get the benefit on all the platforms that we support with haskell/ghc/cabal
07:15:17 <dcoutts> fact is we're not going to get everyone to adopt nix
07:15:20 <fasta> dcoutts: are those more platforms than nix supports?
07:16:10 <dcoutts> fasta: you have to "buy in" to nix. If we can get cabal to "just work" then users don't have to even know, let alone buy into a whole new package system
07:16:44 <dcoutts> fasta: so we're not ignoring nix, on the contrary
07:16:49 <fasta> dcoutts: I think nix has a few small issues that could be solved for 20000 euros or so.
07:17:09 <dcoutts> nix is the inspiration, it shows how to do things right
07:17:15 <fasta> dcoutts: but those are issues I found out after extensive usage that don't even apply to Haskell.
07:17:22 <dcoutts> but note that we can do some bits differently, because we control the infrastructure
07:17:36 <dcoutts> where as nix has to deal with all the old C packages and horrible build systems
07:18:10 <fasta> dcoutts: any idea on when this will be done?
07:18:16 <fasta> dcoutts: months/years/never?
07:18:42 <fasta> dcoutts: I am glad you are taking the lessons from Nix, btw.
07:19:06 <dcoutts> fasta: first task is installing packages without breaking others, we'll think about profiling packages later
07:19:21 <dcoutts> so you should see progress on that in the order of months, not years.
07:24:37 <nohonor> will learning haskell make me a better engineer?
07:25:10 <dmwit> ?faq will learning haskell make me a better engineer?
07:25:10 <lambdabot> The answer is: Yes! Haskell can do that.
07:25:34 <dmwit> (More realistically: how can that question be objectively answered?)
07:25:46 <hatomic> is there an equivalent of isDirectory (System.Posix Files) for windows?
07:25:57 <dmwit> hatomic: Yes, one second.
07:26:03 <hatomic> @hoogle isDirectory
07:26:04 <lambdabot> No results found
07:26:34 <dmwit> doesDirectoryExist
07:26:47 <dmwit> System.Directory
07:27:02 <nohonor> i was hoping someone with such experience could give me advice
07:27:22 <nohonor> i mean, using haskell outside computer science
07:27:45 <zomg> Learning new languages usually improves your skills in my opinion
07:27:58 <dmwit> Learning new *good* languages.
07:28:08 <zomg> Yeah =)
07:28:09 <nohonor> what about construction engineering?
07:28:24 <fasta> nohonor: I did that.
07:28:25 <zomg> Especially if you haven't used said language's style before
07:28:34 <zomg> eg. if you have used only OO-languages and never functional
07:28:51 <dmwit> Learning Haskell is unlikely to improve your non-programming skills.
07:28:54 <nohonor> fasta, i'd love to hear more
07:29:15 <nohonor> dmwit, one might imagine that it will help develop analytical skills
07:29:40 <nohonor> the question is, will it find practical application
07:29:48 <hatomic> dmwit: Thanks. So, I have a list from getDirectoryContents and want to know the directories. I pass doesDirectoryExist on every item of the list and filter out the false ones. Just want to make sure there isnt something better already.
07:29:50 <fasta> nohonor: I implemented a complex visualization for a certain construction norm.
07:30:13 <fasta> nohonor: it worked and there exist some buildings which depend on the computation that the program performed.
07:30:19 <dmwit> hatomic: Sounds about right. You'll probably want to filter out special ones, too, like "." and "..".
07:30:38 <nohonor> fasta, that's impressive
07:30:40 <hatomic> will do ;)
07:31:25 <nohonor> so would you say it's likely to be a worthwhile investment for a professional in this line of work
07:31:27 <fasta> nohonor: there was one impressive part about it. To efficiently compute something you essentially needed a 90 line function using a customly designed data structure.
07:31:31 <nohonor> it's obviously fun as hell
07:32:07 <fasta> nohonor: to make a GUI you either have to be very experienced in software development or very persistent.
07:32:26 <fasta> nohonor: that has nothing to do with intelligence, but more with the sorry state of software development.
07:32:50 <fasta> I think development environments should be as interactive as http://www.lively-kernel.org/
07:33:02 <fasta> Likely this could be combined with Haskell.
07:33:25 <zomg> Lively Kernel? Are they still working on that stuff?
07:33:35 <zomg> I remember it like years back and it seemed extremely pointless..
07:33:36 <fasta> zomg: knowing Oracle, probably not :)
07:33:42 <zomg> Heh
07:33:48 <fasta> zomg: pointless? Why?
07:34:17 <fasta> I think the implementation is slow, but that's just because the implementer likely did somethign stupid.
07:35:14 <zomg> Yeah I recall that and some weird bugs was basically why I  thought it was not exactly great
07:36:24 <nohonor> so about my question ...
07:36:46 <fasta> nohonor: to which language are you comparing?
07:37:10 <zomg> If you're a software developer I'd say haskell is a worthwhile investment, no matter what kind of software you develop
07:37:23 <zomg> this is assuming you don't already know another functional language.. if you do, then perhaps not so much
07:37:54 <shachaf> "Haskell greatest programming language ever made", reports #haskell
07:37:54 <nohonor> i am not a software dev
07:38:10 <nohonor> although i am comfortable with  several languages
07:38:26 <nohonor> and studied haskell for several weeks last summer
07:38:28 <nohonor> out of curiosity
07:38:50 <zomg> Well unless you think you may at some point pursue a career more oriented in software development then I'm not sure if you would have a big benefit from it
07:39:20 <nohonor> that's what i asked
07:39:44 <zomg> Yeah
07:39:47 <fasta> nohonor: I think you are worth tons more per year if you can do software development too.
07:40:18 <zomg> I'd say having experience in programming is generally something that will benefit even in non-programming IT sort of jobs
07:40:21 <fasta> nohonor: if you stick to command line programs first, then you can see whether you are good at it.
07:40:40 <zomg> but they don't typically consider specific languages, besides perhaps the one they use in house
07:40:44 <fasta> nohonor: if you want a more simple language with less 'why doesn't this program work' kind of things, use Scheme or Common Lisp.
07:41:00 <nohonor> fasta, i wrote a 150,000 liner some years ago
07:41:01 <nohonor> in c#
07:41:09 <nohonor> so i guess we're past that level
07:41:13 <fasta> nohonor: that's quite a lot.
07:41:31 <fasta> nohonor: if that was not total crap, I'd say you are more than ready to switch to Haskell.
07:41:38 <nohonor> the question is, if haskell can be effectively used to solve complicated engineering problems
07:41:54 <nohonor> basically, i'm looking for an excuse to study it
07:42:02 <dmwit> Yes, I think it can.
07:42:12 <fasta> nohonor: yes, it can.
07:42:36 <fasta> nohonor: if you want the last bit of performance, it is usually easier to just use C++.
07:42:40 <dmwit> That's a much more objective question than the one you opened with. =)
07:42:44 <mike-burns> nohonor: What are the actual, objective criteria needed?
07:43:01 <fasta> nohonor: but... you will get bored waiting for your compiler to finish.
07:43:09 <fasta> nohonor: in Haskell you can use the interpreter.
07:43:18 <fasta> Without an interpreter I would have never wanted to use Haskell.
07:43:24 <fasta> No tools => broken language.
07:43:42 <nohonor> well, i'm still a student so i was hoping that someone else had hands-on experience
07:43:53 <mike-burns> Haskell is used in the real-world.
07:43:58 <mike-burns> If that's what you're asking.
07:44:08 <fasta> nohonor: My Haskell engineering program was only 2000 lines or so.
07:44:29 <nohonor> excellent
07:44:53 <nohonor> itd be nice to see some examples
07:45:01 <nohonor> fasta gave a good one
07:45:15 <matthiasgorgens> nohonor, at citrix we use haskell in XenClient.
07:45:15 <fasta> nohonor: someone wrote a Haskell visualisation kit too.
07:45:28 <fasta> nohonor: I think that's fairly 'impressive'.
07:45:52 <fasta> nohonor: so, bindings to opencv basically.
07:47:02 <nohonor> it does seem quite spectacular
07:47:20 <kmc> nohonor, http://www.haskell.org/haskellwiki/Haskell_in_industry
07:47:54 <kmc> hardware design, crypto consulting for the NSA, embedded machine control, financial modeling, biotech simulations,...
07:48:07 <kmc> it's pretty much *only* used for complicated engineering problems
07:49:05 <mike-burns> Well, publicly.
07:49:21 <mike-burns> It's also useful as a quick scripting language, but few companies brag about that.
07:49:27 <kmc> true
07:49:43 <kmc> but other things are very good at quick scripting too
07:49:52 <nohonor> kmc, thanks!
07:49:52 <kmc> i'm talking about the domains where learning Haskell is actually worth the effort
07:50:21 <kmc> and the domains where using Haskell at a company is worth the trouble of finding people who know it
07:50:41 <nohonor> that still leaves the question open about construction engineering though
07:51:00 <kmc> if you're just reimplementing some common webapp, or writing vanilla business software, the advantage is not so great
07:51:17 <tsousa> where is that the type classes are defined?
07:51:27 <kmc> which type classes?
07:51:37 <kmc> type classes can be defined in any module
07:51:55 <nohonor> i guess we shall have to see
07:52:12 <nohonor> thanks to eveyone for the help :-)
07:52:44 <kmc> good luck!
07:53:43 <kmc> there are social advantages to using Haskell for the hard problems, too
07:54:06 <kmc> it's a way to attract and filter programming talent
07:54:22 <cvic_> Like Python was in the past.
07:54:25 <navaati> hi
07:54:26 <kmc> *nod* Paul Graham wrote an essay about that
07:54:33 <cvic_> Bulb
07:54:51 <kmc> a different one http://www.paulgraham.com/pypar.html
07:55:18 <kmc> anyway this is an advantage if you're writing something tricky
07:55:18 <cvic_> Ah, here  http://bos.github.com/strange-loop-2011/talk/talk.html#%2815%29
07:55:21 <cvic_> Cool talk
07:55:23 <kmc> and you need a few clever people to think hard about it
07:55:43 <tsousa> nohonor, the default type classes like show
07:55:49 <cvic_> I noticed that Haskell is a very good tool in the hands of people that worked with mainstream languages for 5 - 10 years
07:56:03 <kmc> it's a disadvantage if you're solving a problem which many people have solved before, and simply need a lot of people working on it
07:56:03 <cvic_> The see why Haskell shines
07:56:25 <kmc> yeah, I've known some pure mathematicians to be quite unimpressed
07:56:32 <cvic_> Haha
07:56:34 <kmc> "what, you mean this isn't how every programming language works?"
07:56:50 <tsousa> Where is that the type class show is definied?
07:57:07 <kmc> tsousa, notionally, in Prelude, but in GHC it's imported from somewhere else
07:57:12 <kmc> you can do ":i Show" in GHCi to find out where
07:57:49 <tsousa> GHC.Show
08:00:05 <kmc> http://cdsmith.wordpress.com/2011/03/13/haskells-niche-hard-problems/
08:01:21 <cvic_> I'm surprised to see GHC 6.12 in Debian Squeeze. Nice, nice
08:01:48 * cvic_ got used to GHC 6.2 
08:02:16 <cvic_> nah, I'm lying. GHC 6.8
08:02:27 <kmc> 6.12 is still pretty old
08:02:35 <kmc> big performance improvements in 7.0
08:03:10 <cvic_> I have to test that too
08:03:34 <cvic_> Can I install them both?
08:03:39 <cvic_> Without breaking stuff?
08:04:35 <dmwit> yes
08:04:48 <dmwit> Install as many different versions of GHC as you like.
08:05:12 <cvic_> Ah, found something on the mailing list
08:05:22 <kmc> you can install each one to a different prefix
08:05:31 <tsousa> kmc, i only the the binarys
08:05:36 <tsousa> /usr/lib64/ghc-6.12.3/base-3.0.3.2/GHC/Show.hi
08:05:57 <kmc> tsousa, you're trying to get the source for GHC.Show?
08:06:13 <tsousa> kmc, i am trying to see the code yes
08:06:18 <cvic_> Hmm http://haskell.1045720.n5.nabble.com/Advice-on-Multiple-GHC-installations-td3188938.html    I'll try this
08:06:32 <kmc> tsousa, normally i'd look it up on http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html
08:06:34 <kmc> but it's not there
08:06:48 <kmc> or here http://hackage.haskell.org/package/base (404)
08:06:53 <kmc> but you can 'cabal unpack base'
08:06:57 <kmc> to download the source
08:17:52 <tsousa> kmc, i did not find the Show type class in the second link nor in the first one
08:18:06 <kmc> yeah i said "not there or here"
08:18:09 <kmc> i'ts where i usually look
08:18:16 <kmc> did you try 'cabal unpack base'?
08:18:22 <kmc> that should download the source to the 'base' package
08:18:40 <kmc> i usually have a GHC source checkout somewhere, so I just look there
08:18:46 <kmc> cabal unpack is useful
08:23:11 <Xeli> Am i correct when I say once I've generated a random number using getStdRandom from that point on all my types should include IO ?
08:23:36 <monochrom> @type getStdRandom
08:23:37 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
08:23:43 <kmc> sounds like an oversimplification
08:23:52 <kmc> you can call ordinary Haskell functions not involving IO from an IO action
08:24:11 <cheater_> yes
08:24:17 <matthiasgorgens> I have some piece of code that looks like f <$> g1 a <*> g2 a <*> g3 a <*> g4 (pretend it's in the Maybe applicative functor), and I want to employ the (a->) Functor to get rid of the repeated argument.  But I can't figure out how to compose those applicative functors.  Any hints?
08:24:26 <cheater_> i think he means "all types which call that function"
08:24:34 <cheater_> in which case it would be so
08:24:36 <tac-tics> Xeli: As long as you can supply an StdGen, you don't need be "to be in IO" to get random numbers
08:24:45 <Xeli> kmc: even using parameters which are dependent on an IO type?
08:25:03 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
08:25:22 <Xeli> I am reading that exact page right now actually :P
08:25:26 <kmc> don't think of IO as a "taint bit" on values derived from the real world
08:25:33 <kmc> or as a way of marking an impure function
08:25:38 <Xeli> mm
08:25:47 <kmc> cheater_, you can call a function returning an IO action from anywhere
08:25:56 <kmc> you just can't do very much with that IO action if the caller's type is Int -> Int
08:26:23 <monochrom> I wouldn't use getStdRandom to begin with
08:26:40 <kmc> > let fact 0 = 1; fact n = (let x = putStrLn "Hello, world!" in n * fact (n-1)) in fact 5
08:26:41 <lambdabot>   120
08:26:56 <kmc> > let fact 0 = 1; fact n = (let x = putStrLn "Hello, world!" in x `seq` (n * fact (n-1))) in fact 5
08:26:57 <lambdabot>   120
08:27:11 <kmc> neither of these will perform any IO
08:27:33 <kmc> you construct an IO action (and maybe evaluate it) but you never return that IO action to a point where it could be executed
08:27:37 <kmc> which is only main
08:29:17 <_Bummi_> if I want to use a library, say FunGEn, how do I install/use/import it? I don't get it
08:29:30 <kmc> where's the library from?
08:29:44 <kmc> you run "cabal install FunGEn" from the command line
08:29:53 <kmc> and then you can 'import' modules from the package http://hackage.haskell.org/package/FunGEn
08:30:00 <kmc> e.g. import Graphics.UI.Fungen
08:30:20 <kmc> Haskell has packages and modules; they occupy different namespaces
08:30:24 <kmc> packages are collections of modules
08:30:45 <_Bummi_> do i need to install cabal?
08:30:53 <hpaste> Xeli pasted “xeli question” at http://hpaste.org/52753
08:31:04 <kmc> _Bummi_, you should start with Haskell Platform which already has it
08:31:13 * hackagebot effects 0.1 - Computational Effects  http://hackage.haskell.org/package/effects-0.1 (SjoerdVisscher)
08:31:31 <kmc> Xeli, that should be fine
08:31:34 <Xeli> kmc, the reason I ask is because I am asking to implement those two functions. The second obviously being used after the first
08:31:35 <_Bummi_> aight thanks
08:31:46 <Xeli> how do i get from IO Deck to Deck though?
08:31:50 <kmc> you can't
08:31:54 <kmc> Introduction to IO explains it
08:31:58 <tac-tics> Xeli: You use >>=
08:32:17 <kmc> it's not a meaningful question.  there's no Deck hiding inside an IO Deck
08:32:27 <kmc> but you can take a (Deck -> Foo) and an IO Deck and get an IO Foo
08:32:30 <kmc> fmap will do that
08:32:43 <tac-tics> shuffle d >>= \dShuffled -> dealNCards 5 dShuffled :: IO ([Card], Deck)
08:33:12 <kmc> that won't work, dealNCards doesn't return an IO action
08:33:31 <tac-tics> oops
08:33:38 <kmc> fmap (dealNCards 3) shuffle :: IO ([Card], Deck)
08:33:43 <tac-tics> shuffle d >>= \dShuffled -> return (dealNCards 5 dShuffled) :: IO ([Card], Deck)
08:35:17 <ziman> @pl \t1 t2 -> \st c -> t1 st (\st2 -> t2 st2 c)
08:35:18 <lambdabot> (. flip) . flip . ((.) .)
08:39:23 <kmc> when haddock says my documentation coverage is 19/20...
08:39:29 <kmc> how do i find out which 1 thing was not documented? ;P
08:39:58 <tac-tics> kmc: Just take a look at your source code. I'm sure there's a line you missed somewhere :P
08:40:07 <kmc> ;P
08:40:22 * roconnor suspects haddock has hardcoded the 19/20 message
08:40:52 <b_jonas> heh
08:41:24 <_Bummi_> kmc: I have the Haskell Platform but it doesn't recognize the cabal command
08:43:16 <kmc> did it install a program named 'cabal'? is the location of that binary in your $PATH environment variable?
08:44:04 <kmc> ah, the module itself was missing a haddock comment :)
08:44:18 <_Bummi_> i have no idea, i'm a total beginner :S
08:44:29 <ManateeLazyCat> Hi, how to build cabal for ghc-7.2.1 ? I need darcs version?
08:44:35 <ManateeLazyCat> ghc-7.2.1 build well
08:44:36 <_Bummi_> maybe i should re-install it?
08:44:49 <kmc> ManateeLazyCat, that's in the topic
08:44:54 <tac-tics> _Bummi_: That might not be a bad idea.
08:44:56 <kmc> _Bummi_, ok, well that's not a Haskell question so much as an OS question
08:44:57 <tac-tics> _Bummi_: Although, first
08:45:00 <kmc> what OS are you using?
08:45:03 <ManateeLazyCat> kmc: Oh, thanks. :)
08:45:10 <tac-tics> _Bummi_: Check to make sure your PATH is set up correctly
08:45:54 <cvic_> Ok, so I'm trying to install https://github.com/facebook/futil    ran the install script and it gives me an error
08:46:13 <cvic_> says transformers failed to install. But that package is already installed.
08:46:37 <cheater_> edit the install script and comment that part out??
08:47:46 <tac-tics> cvic_: I tried playing with the other Haskell Facebook project on github, and I had issues with it too
08:47:56 <tac-tics> I think the projects are way out of date
08:48:18 <cvic_> Yep
08:48:35 <cvic_> Time to study the code more carefully
08:48:41 <cvic_> Wanted to play with that lex-pass
08:48:53 <Cale> cvic_: make sure that the version numbers match up...
08:49:07 <cvic_> Cale: yeah, checking that
08:49:37 <cvic_> Yeah, latest version of transformers installed
08:49:40 <cvic_> 0.2.2.0
08:50:06 <cvic_> the Setup.lhs behaves weird too
08:50:14 <cvic_> I installed the dependencied with cabal
08:50:21 <cvic_> and it still complains about them missing
08:50:30 <ManateeLazyCat> Cale: Hey, how are you? :)
08:50:40 <_Bummi_> tac-tics: isn't there a good tutorial somewhere? Everything feels so messy
08:50:49 <ManateeLazyCat> Cale: Long long time no see. :)
08:50:54 <Cale> I'm well :)
08:51:01 <_Bummi_> how do i check the PATH btw, how do i know it's correct
08:51:09 <tac-tics> _Bummi_: A tutorial for what exactly?
08:51:36 <tac-tics> _Bummi_: Setting your path: http://www.java.com/en/download/help/path.xml
08:52:36 <Cale> _Bummi_: What OS are you using?
08:52:41 <_Bummi_> win7
08:52:48 <Cale> Ah, okay
08:53:23 <_Bummi_> tac-tics: a tutorial for installing libraries but i'll check the path thing, thanks :)
08:53:36 <donri> wait, isn't that an "unoperating" system?
08:53:41 * donri </smugness>
08:53:52 <Cale> Well, I'm not sure how the Haskell platform stuff installs on windows 7, but you should be able to see your PATH by running cmd and then typing  echo $PATH  into it, I think.
08:54:08 <tac-tics> _Bummi_: You use cabal install, or you get play a game called "pray ./configure; make; make install" works
08:54:16 <ziman> maybe %PATH% ?
08:54:26 <donri> yea i think the syntax ins %PATH% in doslike
08:54:28 <Cale> yeah, possibly that :)
08:54:47 <cvic_> Yep,  %PATH%
08:54:58 <cvic_> Weird things in W7
08:55:44 <donri> there's always cygwin
08:55:47 <exeter> hello haskellers, I've made a really tiny parser ( < 20 lines) for a little test. I've pasted it here http://pastebin.com/r7sP1p9p with a description of the expected behaviour. The result is correct, but I fear that the code is a bit cumbersome. Do you tink there is a way to make the code prettier / more clear?
08:55:50 <mauke> The paste r7sP1p9p has been copied to http://hpaste.org/52754
08:55:53 <Cale> tac-tics: You can also just build Setup.hs and run that.
08:56:18 <tac-tics> Cale: Yes, but your need to pray too!
08:56:21 <Cale> tac-tics: which is how we did things between the inception of Cabal and cabal-install being written.
08:56:38 <Cale> Maybe. It should work about as well as cabal-install.
08:57:01 <Cale> Seeing as it's mainly what cabal-install is doing to install it :)
08:57:48 <tac-tics> The advantage of cabal-install is that you don't need to download-and-untar before you just give up and try something else
08:57:59 <tac-tics> :)
08:58:09 <kmc> _Bummi_, sounds like not a problem installing libraries but a one-time problem setting up cabal-install
08:58:13 <RichardBarrell> cabal-dev is becoming my favourite thing about cabal-install. Means that you have a sane rollback plan for when "runhaskell Setup.hs install" explodes. :)
08:58:15 <tac-tics> More importantly, it will knab the dependencies for you
08:58:27 <kmc> once you have cabal-install working, installing libraries is a one-step process
08:58:27 <ManateeLazyCat> kmc: Cabal looks install well with ghc-7.2.1, thanks! :)
08:58:28 <kmc> yay
08:59:01 <exeter> I ask because I'm pretty new to haskell and parsec
08:59:03 <cvic_> What's the latest version of cabal?
08:59:14 <ManateeLazyCat> 0.10.2
08:59:30 <Athas> Are finalizers ever run concurrently?
08:59:30 <Cale> exeter: Use do-notation?
08:59:36 <cvic_> Hm, 0.8.0 here
08:59:41 <cvic_> Good enough
08:59:53 <dcoutts> Athas: yes
09:00:04 * ManateeLazyCat pasted "./bootstrap.sh" at http://paste2.org/get/1723383
09:00:05 <ManateeLazyCat> After apply patch 'http://hackage.haskell.org/trac/hackage/raw-attachment/ticket/872/ghc7.diff' to cabal-install, replace ./bootstrap with above content will make cabal-install install well with ghc-7.2.1 .
09:00:28 <RichardBarrell> Athas: the GC itself is parallelised these days. :)
09:00:40 * ManateeLazyCat Start to research c2hs with GObject Inspection .... :)
09:00:45 <Athas> No problem, I'll just add basic synchronisation then.
09:00:48 <exeter> Cale: I am more comfortable without do, I feel. Would using do make my code shorter?
09:01:08 <kmc> finalizers don't run during GC, do they?
09:01:14 <exeter> (read: I've checked "do notation considered harmful")
09:01:19 <cheater_> exeter: there's noting wring with using do
09:01:21 <Athas> kmc: they run just after GC, IIRC.
09:01:24 <kmc> *nod*
09:01:30 <Athas> Then the memory will actually be reclaimed at the next run.
09:01:30 <cheater_> "considered harmful" considered harmful
09:01:32 <Cale> exeter: Well, not much shorter...
09:01:32 <cheater_> amirite kmc
09:01:34 <kmc> GC stops the Haskell world, and finalizers might need to do more allocation
09:01:34 <byorgey> exeter: it wouldn't really make it shorter, just more idiomatic
09:01:36 <kmc> yes cheater_
09:01:38 <kmc> you are rite
09:01:54 <cheater_> glad we have that cleared
09:02:09 <byorgey> exeter: but if you are more comfortable without it, then I don't think it's really a big deal
09:02:47 <Athas> I would argue that it's a big deal in a group project.  Do-notation is vastly more readable.
09:03:02 <cheater_> one thing is more comfortable, another thing is being a masochist because you think you are uncool if you use do
09:03:11 <exeter> byorgey, Cale, cheater_ : thanks, I will keep that in mind and modify the code appropriately. Anything about the actual parse part? Is the task / the execution clear enough? I'm getting my feet wet with Parsec and I hope not to make silly mistakes / things more complex than they are supposed to be.
09:03:43 <byorgey> exeter: no, the actual parsing looks good to me
09:03:53 <kmc> if you understand the "do" syntactic sugar, then the question of whether to use it is a syntactic question
09:04:30 <exeter> kmc: I was planning to use it only because of <- fail (because there's no way to easily replicate it without do, right?)
09:04:41 <kmc> *nod*
09:04:51 <kmc> except for list comprehensions, which are basically "do" in a slightly different form
09:05:00 <kmc> (and restricted to lists, but recent GHC has an extensions which drops that restriction)
09:05:18 <kmc> the main objection to "do" is that people who don't understand the sugar will cargo-cult it as "the thing that does IO"
09:05:23 <kmc> well, that doesn't apply if you know
09:05:25 <exeter> thanks byorgey , I was hoping to make something more elegant, but probalby when the job itself is dirty it's pointless to search for an elegant solution
09:05:55 <kmc> nah Haskell excels at elegant solutions to dirty problems
09:06:02 <exeter> kmc: and that objection holds (or better, held) for me! I am glad to have switched for a bit
09:06:20 <kmc> because all this functional higher order stuff integrates well with IO, concurrency, FFI, etc.
09:06:48 <cheater_> but it's not close to the hardware
09:06:57 <kmc> correct
09:07:05 <cheater_> so how can i use haskell on a computer
09:07:09 <kmc> assembly is not close to "the hardware" either
09:07:18 <cheater_> no but Checkout is
09:07:26 <exeter> kmc: don't know, I'm not proud of that if in the middle of the function. Also it seems a bit longish. I hoped I had been able to solve it with <|> and try () and not much else (or maybe a notFollowedBy)
09:07:35 <ManateeLazyCat> Looks install ghc-7.2.1 is not good idea, many package install failed.
09:07:50 <kmc> the "Do notation considered harmful" page also raises the objection that "do" notation lets you ignore results silently
09:07:53 <kmc> well, so does (>>)
09:08:03 <kmc> and GHC has a warning about ignoring results in "do" now
09:08:06 <kmc> so I think that objection is weak
09:08:07 <cheater_> oh no, you're *ignoring results*
09:08:12 <cheater_> definitely bad
09:08:32 <kmc> oh they actually suggest restriction
09:08:33 <kmc> (>>) :: m () -> m a -> m a
09:08:44 <exeter> no! It is useful to see >>, it's like someone slapping you in the face and shouting "it's not C, you f00!"
09:08:49 <exeter> (or at least it did for me)
09:08:52 <kmc> :)
09:09:06 <kmc> maybe it's like C and you just spell ; as >>
09:09:06 <kmc> ;)
09:09:09 <quicksilver> kmc: that's one of those "You could only think that's a good idea if you're a theorist who's never written an actual program" things, isn't it? :)
09:09:23 <kmc> maybe so
09:09:31 <luite> kmc: that warning is quite annoying imho
09:09:37 <kmc> i'm fine with it
09:09:38 <luite> one of the reasons not to use -Wall
09:09:38 <tac-tics> kmc: I can't imagine ignoring the results of a do could be a serious problem in any sense.
09:09:43 <quicksilver> we have so many IO actions which yield results you often don't need
09:09:44 <luite> for me at least :)
09:09:52 <quicksilver> it's annoying to have to explicitly ignore them all
09:10:02 <Cale> Actually, if you're a theorist, you should prefer the use of parametricity I think.
09:10:06 <luite> otherwise you have your code littered with _ <- ...
09:10:08 <kmc> "_ <-" is not that many characters
09:10:11 <kmc> or you can use 'void'
09:10:24 <kmc> i use -Wall for everything and it's fine
09:10:34 <quicksilver> mabe it's not as bad as I imagine.
09:10:44 <exeter> kmc: you're right. Still, being able to use funA >>= funB (without stating other stuff like a <- this ) it's rewarding!
09:10:53 <kmc> yes definitely :)
09:11:05 <tac-tics> -Wall just *lists* the warnings, right? Is there also a flag to promote warnings to errors?
09:11:21 <luite> -Werror
09:11:27 <luite> or something like that
09:11:41 <tac-tics> ah yeah
09:11:44 <Cale> Functions which ignore part of their input should have a type variable there. Functions which produce output and want to ignore part of the structure should use ().
09:12:03 <exeter> anyhoo thanks for the comments on the code
09:12:29 <monochrom> damn C for requiring declaration before use!
09:12:41 * monochrom is spoiled by haskell's allowing declaration after use
09:13:42 <ManateeLazyCat> Haha, good to see you guys, love #haskell
09:14:01 <monochrom> oh it's a manatee lazy cat!
09:14:21 <ManateeLazyCat> monochrom: Haha, long time no see. :)
09:14:46 <wavewave> hi!
09:14:55 <ManateeLazyCat> wavewave: Hi. :)
09:15:17 <wavewave> ManateeLazyCat: are you the author of manatee? I'm very impressed about it.
09:15:41 <ManateeLazyCat> wavewave: yes. :)
09:16:26 <wavewave> to be fair, I am impressed by all the haskell packages by people here every day ;-)
09:16:53 <tac-tics> wavewave: You'd think they'd never get any work done being on IRC
09:16:54 <tac-tics> ;)
09:16:55 <ManateeLazyCat> wavewave: Have many genius guy at here. :)
09:17:20 <ManateeLazyCat> wavewave: you can always learn something from they talk. :)
09:17:52 <kmc> there's too many packages :/
09:17:55 <kmc> it's hard to find anything
09:18:05 <kmc> i should stop bitching and work on Hackage 2.0
09:18:10 <quicksilver> kmc: use the -cafe crowdsource.
09:18:19 <wavewave> ManateeLazyCat: BTW, manatee is now installable on ghc 7? I found it had failure log on hackage.
09:18:22 <kmc> meh, I don't use -cafe
09:18:29 <quicksilver> kmc: post an email saying 'HASKELL SUCKS!!! There isn't even a good package to do X'
09:18:34 <kmc> haha yes
09:18:41 <quicksilver> then wait while engraged responses come in
09:18:43 <quicksilver> step 3. profit.
09:18:50 <kmc> you can't follow -cafe, reddit, irc, stack overflow, and everyone's blogs
09:18:57 <kmc> i have no job and I still don't have the time
09:18:59 <ManateeLazyCat> wavewave: I haven't test it
09:19:22 <kmc> i realize that the fact I don't post ANN: emails means that some people will never find out about my libraries
09:19:23 <kmc> oh well
09:19:45 <b_jonas> monochrom: when I was a little boy, I tried 10 PRINT X\n20 X=3*4 in a BASIC interpreter and didn't understand why it didn't work until they explained it to me. now we've got a language where it works.
09:20:13 <kmc> haha
09:20:21 <_Bummi_> tac-tics: My PATH seems correct (C:\Users\Louise\AppData\Roaming\cabal\bin), still Haskell Platform says cabal is not in scope
09:20:40 <ManateeLazyCat> wavewave: I haven't update Manatee long time since i'm busy on software center of linux deepin ( http://www.linuxde.net/wp-content/uploads/2011/07/software.jpg )
09:20:41 <kmc> yeah, when programmers say "imperative programming is more natural, it matches the way our minds / the world work"
09:20:43 <tac-tics> _Bummi_: oh, actually, have you tried closing your terminal and opening a new one?
09:20:48 <kmc> I am suspicious for this reason
09:21:04 <kmc> total beginners come up with all kinds of computational models
09:21:07 <tac-tics> _Bummi_: Windows loads your path when you open the terminal, and it doesn't change until it's closed again
09:21:28 <ManateeLazyCat> wavewave: But i try to back to Haskell world recently....
09:21:31 <monochrom> kmc: haskell-cafe has a lot less to follow.
09:22:01 <kmc> yeah maybe my mistake is picking IRC to follow, as it's the highest volume
09:22:05 <fasta> Haskell-cafe used to be a lot. One of the reasons for me to unsubscribe.
09:22:15 <kmc> but I really enjoy the interactivity
09:22:22 <quicksilver> IRC is different in timeliness
09:22:24 <fasta> Now I just occasionally read it via the web.
09:22:26 <_Bummi_> tac-tics: Tried that but :< still not in scope. I'm obviously retarded, cant get this shit to work
09:22:29 <quicksilver> the cafe you can read one a day if you choose to
09:22:30 <ManateeLazyCat> Hmm, c2hs looks install failed by package `language-c`
09:22:34 <quicksilver> IRC will suck you in constantly :)
09:22:35 <kmc> i'm sub'd to the hackage upload feed now
09:23:17 <monochrom> haskell-cafe sitll has much traffic. but does not conflict with little to follow.
09:23:31 <b_jonas> kmc: it was me who said that.
09:23:46 <b_jonas> and I still think imperative programming matches us more.
09:24:11 * ManateeLazyCat Oh, `happy` is not install
09:24:17 <tac-tics> _Bummi_: Have you tried typing the full path of the executable file?
09:24:54 <kmc> b_jonas, i've heard it many times
09:24:57 <tac-tics> C:\Users\Louise\AppData\Roaming\cabal\bin\cabal or whatever?
09:24:58 <kmc> not just from you
09:25:09 <kmc> and I'm not saying it's definitely false
09:25:25 <kmc> but I'm suspicious of any argument by experienced people over what's "natural"
09:25:29 <kmc> that experience changes the way you think
09:25:35 <_Bummi_> tac-tics: nope but since it says "'cabal' not in scope" i believe something's really wrong aomewhere
09:25:46 <kmc> i have the same problem here, I tell beginners that certain things are easy and maybe they really aren't
09:25:56 <Twey> b_jonas: So when you tell someone to do the washing-up, you say ‘for each plate in the stack, take the plate, wash it, and put it on the draining board’?  :þ
09:25:58 <_Bummi_> tac-tics or you mean whole path to cabal?
09:26:01 <_Bummi_> full*
09:26:02 <b_jonas> kmc: right, you (the channel) have at least convinced me to keep an open mind about it
09:26:18 <tac-tics> _Bummi_: The full path to cabal
09:26:36 <parcs_> it's not too hard to follow -cafe if you read it in digest mode
09:27:21 <dcoutts> _Bummi_, tac-tics: C:\Users\Louise\AppData\Roaming\cabal\bin is where cabal installs things, not where the cabal.exe that comes with the Haskell platform lives. But if you install cabal-install via cabal-install, then the new cabal.exe will end up there (just like anything else it installs)
09:27:37 <tac-tics> dcoutts: Thanks. I thought that looked strange
09:27:43 <ManateeLazyCat> wavewave: I'm installing ghc-7.2.1 for test. :)
09:28:01 <b_jonas> Twey: I don't know.
09:31:23 <wavewave> ManateeLazyCat: thanks! hope that you will get manatee installed without problem. ;-)
09:36:13 <Athas> Is it really this cumbersome to run a Haskell function as a finalizer on a ForeignPtr?  I think I have to create a FinalizerPtr (a kind of FunPtr) from my Haskell function.
09:37:44 <kmc> there are different modules providing finalizers
09:37:51 <Athas> Is there a way to use finalizers that does not depend on ForeignPtr?
09:37:55 <Athas> Which ones?
09:38:01 <kmc> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/Foreign-Concurrent.html
09:39:38 <ManateeLazyCat> dcoutts: Have any people work on gobject inspection recently?
09:40:27 <sm> morning
09:40:53 <Twey> Hello
09:42:00 <dcoutts> ManateeLazyCat: yes, Will Thompson, see https://gitorious.org/haskell-gi
09:42:36 <ManateeLazyCat> dcoutts: Thanks, i want to send all my time on gobject-inspection, thanks for link. :)
09:42:56 <dcoutts> ManateeLazyCat: yes, you should really talk to Will, I think he can help
09:43:09 <ManateeLazyCat> dcoutts: OK, thanks for help.
09:43:57 <ManateeLazyCat> dcoutts: I think gobject-inspection is better way to generate GTK+ code, and i plan to use newest c2hs instead c2hs fork in gtk2hs
09:44:15 <dcoutts> ManateeLazyCat: good, we should be using the upstream c2hs
09:44:35 <dcoutts> ManateeLazyCat: and yes, gobject-inspection is the right way to do it these days.
09:45:55 <navaati> it will need a generic OOP lib in haskell, is there one ?
09:46:09 <Cale> navaati: What will?
09:46:38 <navaati> gobject-introspection
09:46:58 <ManateeLazyCat> dcoutts: Ok, i need research c2hs first, maybe will ask some question about c2hs. :)
09:47:41 <Cale> navaati: There are some odd libraries, but I usually encode objects more directly.
09:48:08 <kmc> would anyone care to review the design / implementation / documentation of my latest library before I release it?
09:48:09 <kmc> http://ugcs.net/~keegan/safe-globals/
09:48:57 <dcoutts> navaati: I don't think so, we already model gobject/gtk objects in Haskell fine
09:49:05 <Cale> kmc: Isn't there a syntax like 'Char or something for [t| Char |] ?
09:49:27 <kmc> 'Char has type Name, not Q Type
09:49:34 <kmc> (actually it's ''Char)
09:49:38 <Cale> oh, right
09:49:43 <kmc> more importantly, it won't work to replace [t| Maybe Char |]
09:49:59 <nh2> somebody tell slemi to turn jabber on :D
09:50:31 <ManateeLazyCat> 1:00 in China, good night all! :)
09:50:44 <nh2> lambdabot: (:) <$> [1,2,3] <*> [[1,2,3]]
09:51:30 <sipa> > (:) <$> [1,2,3] <*> [[1,2,3]]
09:51:31 <lambdabot>   [[1,1,2,3],[2,1,2,3],[3,1,2,3]]
09:51:59 <nh2> sipa: thanks
09:54:35 * cvic_ likes ASTs, so he uses Haskell to manipulate his PHP codebase
09:59:19 <tsousa> kmc, i am sorry but i did not find the show type class on the downlaod link that you gave me
10:00:07 <kmc> download link?
10:00:24 <tsousa> kmc, the base something
10:01:03 <kmc> i said you should do "cabal unpack base"
10:01:22 <kmc> however my cabal downloads some ancient version by default
10:01:36 <kmc> so i had to do 'cabal unpack base-4.4.0.0'
10:02:08 <tsousa> kmc, cabal is a command?
10:02:12 <kmc> yes
10:02:12 <tsousa> i dont have it on my system
10:02:15 <_Bummi_> kmc: Okay, I have successfully installet FunGEn now using cabal but when I try to "import FunGEn" in my .hs-file it can't find it. Something obvious I've missed?
10:02:30 <kmc> the module is not named FunGEn _Bummi_
10:02:32 <kmc> look here http://hackage.haskell.org/package/FunGEn
10:02:40 <kmc> the modules are  named e.g. "Graphics.UI.Fungen"
10:02:53 <kmc> tsousa, did you install Haskell Platform?
10:03:04 <kmc> 'cabal' is the main command for downloading, building, and installing Haskell libraries
10:03:07 <_Bummi_> i tried that too  kmc
10:03:16 <kmc> if you're doing Haskell development then you almost certainly want it
10:03:25 <kmc> _Bummi_, can you put the code and error message on hpaste?
10:04:10 <_Bummi_> it's just a new Main.hs with only "module Main where <new line> import Graphics.UI.Fungen"
10:04:18 <kmc> _Bummi_, can you put the code and error message on hpaste?
10:06:47 <hpaste> “_Bummi_” pasted “import prob” at http://hpaste.org/52755
10:07:26 <_Bummi_> kmc: I have no code in that file, just wanted to try importing FunGEn
10:08:47 <kmc> ok well it works for me
10:08:57 <kmc> are you sure you did "cabal install FunGEn" and that it succeeded?
10:09:12 <kmc> what do you get from "ghc-pkg list FunGEn"
10:12:50 <_Bummi_> kmc: hmm should i write that in cmd or
10:13:02 <kmc> yeah, those are both command-line commands
10:13:31 <_Bummi_> well i did install it there ad it says it was registring FunGEn and compiling all the modules and such
10:14:04 <kmc> btw I think you will have an easier time if you develop on Linux
10:14:17 <kmc> not that Windows is unsupported, or that bugs with GHC on Windows are okay
10:14:17 <_Bummi_> but it says WARNING: cache is out of date when i type "ghc-pkg list FunGEn"
10:14:26 <kmc> in fact the key GHC people are employed by Microsoft
10:14:33 <kmc> but still, Windows is a second-class platform for software development in general
10:14:51 <_Bummi_> kmc: Maybe but I'm only doing a small assignment in haskell for now
10:15:06 <kmc> ok
10:15:18 <kmc> it sounds like cabal and ghc / ghc-pkg are looking at different package databases
10:15:24 <kmc> i don't know how to fix this problem
10:15:34 <kmc> maybe you have two installs of the Platform somehow
10:15:47 <dcoutts> cabal will use the ghc on the $PATH
10:16:14 <_Bummi_> FunGEn got installet under /cabal
10:16:19 <Cale> wait, cache is out of date for ghc-pkg and not cabal?
10:16:22 <_Bummi_> installed*
10:16:26 <Cale> weird
10:16:40 <dcoutts> cabal does not have a separate package db, it just uses ghc-pkg
10:16:58 <Cale> dcoutts: I mean, I've never seen ghc-pkg warn me that a cache is out of date
10:17:11 <hpaste> hatomic pasted “how to improve readability or make it simpler?” at http://hpaste.org/52756
10:17:13 <dcoutts> oh that can happen if you fiddle with the package db manually
10:17:40 <kmc> hatomic, other than by using "do" notation?
10:17:50 <dcoutts> if the file timestamp of the cache is not as old as the timestamp of any individual package file
10:18:20 <kmc> what's that «formatCalendarTime undefined» doing?
10:18:25 <dcoutts> Cale: or somehow otherwise mess up the timestamps, e.g. copying or unpacking from a tarball could do it if you didn't preserve times
10:18:46 <_Bummi_> dcoutts: So, you think I've messed something up? :S
10:19:04 <dcoutts> no idea, but it's easy to fix using ghc-pkg recache
10:19:09 <_Bummi_> I have't even done anything except installing Haskell Platform and then cabal install FunGEn
10:19:15 <_Bummi_> dcoutts: I tried that but
10:19:25 <dcoutts> and the cache warning doesn't mean you get wrong results, it's just slower
10:19:30 <hatomic> kmc: yes, I was trying to explore other ways instead of the sweet do notation
10:19:38 <_Bummi_> it says I dont have permission to modify that file
10:19:43 <dcoutts> then do it as root
10:19:52 <dcoutts> root/Administrator
10:20:09 <hatomic> kmc: and I don't know, formatCalendarTime has another property in the place of "undefined, but I dont need it.
10:21:01 <kmc> awkward
10:21:18 <kmc> i've never used formatCalendarTime, that sounds like a bad API design, but maybe there's a reason
10:21:28 <shachaf> It looks like it's a locale.
10:21:36 <shachaf> Maybe it's only used for language-formatting of dates or something?
10:21:51 <parcs_> why aren't shiftL and shiftR named .<<. and .>>. or something
10:22:07 <shachaf> formatCalendarTime :: (forall a. a) -> String -> CalendarTime -> String
10:23:28 <burp> @hoogle .>>.
10:23:28 <lambdabot> No results found
10:23:43 <Cale> The first parameter to formatCalendarTime is the locale
10:24:03 <Cale> you can use defaultTimeLocale for it
10:24:48 <Cale> (from System.Locale)
10:25:27 <hatomic> interesting
10:25:48 <hatomic> so I can make it spit out german? :D
10:27:49 <tsousa> there is not webpage that post the source code of the type classes?
10:28:16 <mike-burns> You mean the Haskell Prelude?
10:28:24 <mike-burns> http://www.haskell.org/onlinereport/standard-prelude.html ?
10:30:37 <kmc> dude, it's shachaf
10:30:38 <kmc> hi shachaf
10:30:44 <kmc> any thoughts on http://ugcs.net/~keegan/safe-globals/ ?
10:30:57 <shachaf> ?
10:30:58 <shachaf> What did I do?
10:31:08 * shachaf looks.
10:31:17 <kmc> nothing in particular
10:33:34 <shachaf> Oh, that's why you were talking about InlineSpecs.
10:33:35 <dcoutts> kmc: if you want my opinion it's perpetuating a bad design
10:33:51 <dcoutts> there's no such thing as a global var
10:33:56 <kmc> i do want your opinion :)
10:34:09 <dcoutts> and trying to use them anyway makes software not reusable
10:34:17 <kmc> i agree that global variables are usually a bad design
10:34:44 <aristid> sometimes it feels like people use monad transformers to replace global variables
10:34:51 <kmc> however people keep using them anyway, and I think we should try to make that safer
10:34:54 <kmc> as a form of harm reduction
10:35:10 <dcoutts> but also global is the wrong term
10:35:15 <dcoutts> it's per-process
10:35:21 <parcs_> aristid: is that a bad idea?
10:35:40 <dcoutts> process-scope or perhaps it's rts scope
10:35:57 <kmc> dcoutts, say you have a thread-unsafe C library, and you're writing FFI bindings and want them to be threadsafe
10:35:59 <dcoutts> kmc: I suspect it's because we don't have better modules
10:36:02 <aristid> parcs_: i don't know
10:36:08 <mike-burns> Why do people use globals?
10:36:12 <kmc> is there a nicer way than a hidden global MVar?
10:36:15 <dcoutts> kmc: sure so bad designs beget bad designs
10:36:21 <kmc> right
10:36:33 <dcoutts> ie using more global mutable state to make up for other people using global mutable state
10:37:09 <kmc> then I think we agree it's perpetuating a bad design
10:37:25 <kmc> but it will help people write useful, safe Haskell code more quickly
10:37:36 <Igloo> kmc: If you can do it witha "global" MVar you can do it by passing an MVar around in a Monad
10:37:50 <dcoutts> Igloo: not safely in the FFI example
10:37:58 <kmc> Igloo, except the external API to your library might be pure functions
10:38:20 <dcoutts> but for the FFI example we don't need to make it nice or usable except for FFI
10:38:23 <kmc> also even if your external API is IO, converting that to ReaderT Stuff IO, or even an abstract monad, has significant drawbacks
10:38:41 <kmc> I wrote this package as a counterpoint to http://hackage.haskell.org/package/global-variables
10:38:42 <dcoutts> e.g. you could add a mutex on the C side
10:38:50 <kmc> which does the same thing in a much worse way
10:39:11 * dcoutts disappears in a cloud of mutable state
10:39:19 <kmc> yeah, you could add a mutex on the C side
10:39:39 <kmc> but anything thread-related in C is cumbersome and dangerous, and will not cooperate with the GHC RTS as well
10:39:48 <mike-burns> Globals are useful because they help prevent your public function signatures from changing?
10:39:56 <kmc> though, the best solution may be to store your MVar in a C global variable via StablePtr
10:40:06 <kmc> i've not yet thought about that solution in depth
10:44:34 <kmc> anyway thank you for input dcoutts, Igloo, et al
10:45:15 <dcoutts> kmc: btw, I wouldn't mind something that's clearly only usable in an FFI context. But anything "better" I fear would encourage the use in more general software design contexts.
10:45:33 <kmc> *nod*
10:45:41 <kmc> how would you suggest making it only usable in an FFI context?
10:45:47 <dcoutts> not sure :-)
10:45:56 * dcoutts really does leave this time
10:46:08 <dcoutts> OxHug meeting...
10:46:16 * hackagebot digestive-functors-blaze 0.2.0.1 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.2.0.1 (JasperVanDerJeugt)
10:46:30 <kmc> btw I think there are other reasonable use cases besides FFI
10:49:50 <kmc> such as generating unique IDs to speed up operations which are extensionally pure
10:49:55 <kmc> like http://hackage.haskell.org/package/intern
10:51:19 <kmc> anyway I probably wouldn't release this except that someone already released the global-variables package and it got some buzz
10:51:21 <_Bummi_> kmc, dcoutts: Just wanted to say I reinstalled Haskell Platform and it all magically works now. Guess something went wrong somewhere but well, it's gone. Thanks for your help!
10:51:35 <kmc> cool, glad it's working _Bummi_
10:51:41 <_Bummi_> (y)
10:51:54 <_Bummi_> :]
10:54:38 <kmc> and the global-variables approach is really broken
11:06:16 * hackagebot hp2any-core 0.11.1 - Heap profiling helper library  http://hackage.haskell.org/package/hp2any-core-0.11.1 (GergelyPatai)
11:06:53 <Xeli> What would be the 'best' way of defining a 'hand' of 5 Cards? Cards being a datastructure
11:07:26 <Twey> data Hand = Hand Card Card Card Card Card
11:07:27 <Xeli> I could do type Hand = [Card] but it doesn't limit it to just 5
11:07:34 <benmachine> Xeli: it depends a little on what exactly you want to do
11:07:34 <mike-burns> Xeli: What are you doing with the data?
11:07:57 <benmachine> to me a hand is a multiset
11:08:07 <Twey> Not if it's exactly five
11:08:11 <Twey> You'd want to encode that somehow
11:08:17 <benmachine> well, you might do
11:08:17 <Twey> I guess you could use safe accessors, but still
11:08:18 <mike-burns> Do you?
11:08:23 <benmachine> you might find it more trouble than it's worth
11:08:29 <Twey> Mm, maybe
11:08:32 <Twey> & why a multiset?
11:08:34 <mike-burns> It's really up to how you use the data.
11:08:37 <Twey> Surely it would just be a set
11:08:40 <Twey> There's only one of each card
11:08:44 <benmachine> oh, true
11:08:52 <benmachine> a set, unless there's more than one of each card
11:08:59 <kmc> if you want to define poker hand ranking by pattern matching, it helps to access the cards according to the poker card ordering
11:09:53 <kmc> you can generically define fixed-length lists, but it involves some fairly fancy type system extensions
11:09:54 <Xeli> by sorting them into the datastructure?
11:10:07 <kmc> by maintaining the invariant that the datastructure is always sorted
11:10:21 * benmachine pines for dependent types :P
11:12:03 <Xeli> so a set and making sure it's always sorted, alright thanks :)
11:12:14 <kmc> Data.Set does the sorting for you
11:13:05 <benmachine> Xeli: Twey's idea isn't a bad one, and you can maintain the sorty invariant yourself
11:13:21 <benmachine> but I'd go with Data.Set and checking the size at runtime
11:13:28 <amindfv> kmc: do you know a good reference for the concepts that allow you to generically define fixed-length lists?
11:13:43 <benmachine> amindfv: GADTs are pretty key to the process
11:13:46 <kmc> amindfv, in Haskell, I would read about GADTs
11:14:37 <amindfv> ok, that was what I was guessing
11:14:38 <kmc> data Z; data S n;  data List n t where { Nil :: List Z t;  Cons :: t -> List n t -> List (S n) t }
11:14:38 <amindfv> thank you
11:15:03 <_Bummi_> btw, can anyone recommend a simple 2d graphics library?
11:15:15 <ziman> vector or bitmap?
11:15:22 <Twey> Hehe
11:15:24 <kmc> _Bummi_, http://hackage.haskell.org/package/diagrams or http://hackage.haskell.org/package/graphics-drawingcombinators
11:15:29 <Twey> ‘How would you like your graphics, ma'am?’
11:15:33 <SmartViking> Maybe there are SDL bindings for haskell?
11:15:41 <Twey> SmartViking: There are
11:15:56 <kmc> I would not call SDL a graphics library
11:16:11 <Twey> http://www.haskell.org/haskellwiki/SDL http://abstractabsurd.blogspot.com/2008/04/intro-to-sdl-with-haskell.html
11:16:15 <Twey> Oh, the two questions were related?
11:16:16 * hackagebot clocked 0.4.1 - timer functionality to clock IO commands  http://hackage.haskell.org/package/clocked-0.4.1 (SoenkeHahn)
11:16:26 <_Bummi_> i just want to make 3 rectangles working like buttons and display strings, so nothing fancy is needed
11:16:34 <kmc> oh, you want a GUI library?
11:17:08 <kmc> there are bindings for GTK, Qt, wxWidgets
11:17:14 <benmachine> SDL will do what you want if you get it to compile :P
11:17:26 <_Bummi_> i don't know what i want :D Just something super easy and simple if possible
11:17:40 <kmc> does SDL have drawing primitives?
11:17:47 <kmc> i thought it just gives you access to a raw pixel buffer
11:17:57 <benmachine> SDL lets you draw rectangles yes
11:18:07 <_Bummi_> hmmmm
11:18:30 <Twey> _Bummi_: ‘Super easy & simple’ is probably Gtk2Hs
11:18:32 <hpaste> hatomic annotated “how to improve readability or make it simpler?” with “make it simpler? do notation” at http://hpaste.org/52756#a52757
11:18:34 <kmc> _Bummi_, there's a big difference between a vector graphics library, a bitmap graphics library, raw pixel buffer access, and a UI library
11:19:02 <Twey> If you want to raw graphics you're going to have to handle boundaries &c. all by yourself
11:19:05 <Twey> to do**
11:19:16 <kmc> SDL is a fine way to get a window and input and an OpenGL context
11:19:27 <kmc> but drawing with SDL itself is pain
11:19:32 <kmc> or at least was the last time I tried, n years ago
11:19:34 <hatomic> I think formatCalendarTime can be used with Locale functions like dateFmt, but I dont know how
11:19:46 <_Bummi_> Twey: Hehe doesn't sound too simple then :)
11:19:47 <ben> yo what's that clever fibonacci term with fix again
11:19:59 <kmc> > fix ((0:) . scanl (+) 1)
11:20:00 <_Bummi_> kmc: Hum okay, maybe I'll check sdl out then
11:20:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:20:06 <Twey> _Bummi_: It's ‘simple’ in that there's not much of an API to learn
11:20:12 <ben> cheers
11:20:14 <Twey> But complex in that you have to do more yourself
11:20:18 <kmc> _Bummi_, what in what I said suggests that is a good idea?
11:20:19 <DukeDave> Oh look: "Ambiguous type variable `v3' in the constraint"
11:20:53 <kmc> do you know OpenGL?
11:20:57 <Twey> If you use Gtk2Hs it will take a little more learning (the bindings are a bit more complex, & you have to understand packing, signals, &c.) but in a few lines of code you'll get two native-looking buttons in a resizeable window & it'll handle events, keyboard input, &c. all for you
11:21:21 <Rafael> Hi
11:21:27 <Twey> (assuming you don't already know GTK; if you do, you're pretty much set)
11:21:30 <Twey> Rafael: Hi!
11:21:45 <_Bummi_> kmc: Well I know some about it but it would probably not be a good idea to use for me now
11:22:04 <kmc> i agree
11:22:09 <alkobottle> hi! I have a beginners question, is this the right place?
11:22:13 <kmc> alkobottle, yes
11:22:22 <alkobottle> sweet
11:22:27 <kmc> _Bummi_, I said that SDL is not a good way to draw stuff unless you're using OpenGL with it
11:22:51 <_Bummi_> kmc: I missed that part
11:22:57 <alkobottle> can anyone show me how I can check if a list of numbers exists in another list of numbers?
11:23:07 <kmc> contiguous alkobottle?
11:23:12 <kmc> > [3,4,5] `isInfixOf` [1..10]
11:23:13 <lambdabot>   True
11:23:15 <Twey> alkobottle: All of them or any of them?
11:23:17 <kmc> > [3,4,6] `isInfixOf` [1..10]
11:23:18 <lambdabot>   False
11:23:25 <Twey> In order or out?
11:23:32 <alkobottle> hm, in order
11:23:36 <Twey> Are there duplicates?
11:23:44 <Twey> Oh, isInfixOf it is then.
11:23:53 <alkobottle> yeah, there are duplicates
11:23:59 <kmc> you can do it more efficiently
11:24:03 <kmc> but isInfixOf is nice and simple
11:24:12 <Twey> Can you?
11:24:17 <alkobottle> the result should be a list of the containing numbers, in order :/
11:24:33 <Twey> I guess Boyer–Moore or similar
11:24:35 <kmc> Twey, isInfixOf in the standard Data.List implementation doesn't use any fancy string search algorithm
11:24:39 <kmc> @src isInfixOf
11:24:39 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
11:24:40 <kmc> right
11:24:43 <Twey> *nod*
11:24:52 <benmachine> alkobottle: I'm confused, can you write the type of the function you want, and provide an example?
11:24:52 <kmc> there are boyer-moore and knuth-morris-pratt implementations on hackage
11:25:07 <Twey> alkobottle: Define ‘containing numbers’
11:25:34 <alkobottle> benmachine,  it should look something like this: function [3,2,5] [3,2,5,3,(-5),4,3,2] -> [3,2,5,3,3,2
11:26:15 <benmachine> alkobottle: so you want the second list, but drop all the elements that don't appear anywhere in the first list?
11:26:29 <alkobottle> exactly :)
11:26:43 <alkobottle> kinda hard to explain
11:27:07 <benmachine> alkobottle: I suggest using 'filter' and 'elem'
11:27:28 <BMeph> foldr filter? :)
11:27:50 <alkobottle> alright then, will look into filter & elem :), thx!
11:28:16 <benmachine> alkobottle: if you need more hints come back, but try without first
11:28:21 <benmachine> (without more hints, I mean)
11:28:29 <benmachine> BMeph: huh, that's kinda neat
11:28:46 <alkobottle> will do, otherwise I wouldn't learn much ^^
11:28:57 <alkobottle> bye
11:30:49 <hatomic> compiling the example in haskell.org/ghc/docs/7.2.1/html/users_guide/ghc-as-a-library.html gives the error "Could not find module `DynFlags'". How can I fix that?
11:31:28 <c_wraith> hatomic: add "-package ghc" to the command line
11:31:44 <c_wraith> hatomic: the ghc package is hidden by default.  that will expose it
11:32:46 <erus`> what would the implications be if we found out pi was a rational number ?
11:33:01 <c_wraith> erus`: that we suck at math.
11:33:18 <erus`> we know that anyway
11:33:21 <c_wraith> erus`: because we've found many different ways to prove it's not rational
11:33:23 <benmachine> you can prove pi irrational with maths that isn't that advanced
11:33:31 <benmachine> so it would prove that some pretty basic mathematics was inconsistent
11:34:16 <kmc> maybe we could finally get rid of the real numbers then
11:35:02 <c_wraith> I'm quite happy to live without non-computable reals.
11:35:58 <c_wraith> Though things like Chaitin's constant annoy me.  They are uniquely described, so don't require infinite information.... but non-computable.
11:36:06 <c_wraith> I'm not sure what to do with them.
11:36:47 <benmachine> chaitin's constant doesn't annoy me
11:36:56 <benmachine> I think it stretches the concept of "uniquely described"
11:37:21 <benmachine> I mean, I suppose it is
11:37:53 <hatomic> c_wraith: thanks. hm. now I get something like ghc-7.2.1-(...) is unusable due to missing or recursive dependencies: template-haskell-2.6.0.(...)
11:38:26 <c_wraith> hatomic: that sounds broken.  How did you install ghc?
11:39:02 <hatomic> latest installer from haskell.org/ghc
11:39:13 <c_wraith> global or user install?
11:40:02 <benmachine> c_wraith: http://www.dpmms.cam.ac.uk/~wtg10/reals.html you reminded me of this
11:40:17 <hatomic> I installed on windows so I guess it was global. Cabal packages I use to install globally too
11:40:57 <c_wraith> hatomic: huh.  something's broken with your install, but I really don't know what.
11:41:56 <c_wraith> benmachine: I'm not sure how much I trust that dialog, since it starts by ignoring the existence of proper supersets of Q that are still much smaller than the reals.
11:42:52 <benmachine> c_wraith: well, it certainly doesn't continue by doing that
11:43:07 <benmachine> it spends a while talking about the algebraics and stuff and why they're not enough
11:44:35 <Vitka_banned> So uh...
11:44:43 <Vitka_banned> Is my IP 109.173.94.129 banned?
11:45:40 <benmachine> there are 133 bans in this channel :o
11:45:46 <benmachine> by various criteria, including IP
11:46:01 <Vitka_banned> Why? :(
11:46:03 <cvic_> That's a lot
11:46:13 <benmachine> it is kinda
11:46:15 <cvic_> Given the general newbie friendliness of #haskell
11:46:17 <kmc> because it's one of the largest channels on freenode
11:46:18 <cvic_> But, heh
11:46:18 <benmachine> maybe someone should do some GCing
11:46:25 <kmc> and one of the top google hits for "programming chat" or whatever
11:46:32 <cvic_> It's also a target for trolls
11:47:02 <kmc> so we get a lot of spam, trolls, obnoxious people, etc
11:47:03 <benmachine> I like how irssi expresses all times since bans in seconds
11:47:05 <cvic_> trolls that read research papers before joining
11:47:08 <benmachine> and by like I mean find completely unhelpful
11:47:18 <cvic_> irssi is very cool
11:47:18 <Vitka_banned> I din't troll... Haskell IRC anyway.
11:47:24 <byorgey> Vitka_banned: I'm sure someone can unban your IP
11:47:27 <erus`> cvic_: yeah, thinking man's troll
11:47:28 <byorgey> @where ops
11:47:28 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
11:47:52 <kmc> I've seen very few trolls who put any effort in
11:47:57 <benmachine> Vitka_banned: I'm not actually sure you're among the bans
11:48:03 <benmachine> there's too many to read :P
11:48:24 <Vitka_banned> 22:47 -!- Cannot join to channel #haskell (You are banned)
11:48:44 * monochrom observes that we are reading all this in #haskell
11:49:02 <Vitka_banned> I'm using web right now. :\
11:49:36 <benmachine> I see
11:51:17 <monochrom> not found in banlist
11:51:52 <Vitka_banned> But if it's somehow free node-wide ban, why I can connect to it?
11:51:54 <cvic_> Maybe a general ban? On freenode?
11:51:55 <cvic_> Hmm
11:52:09 * cvic_ shrugs 
11:53:32 <c_wraith> ah, there it is.  It's the monotone-sequences axiom I reject.  It *sounds* natural, but so does the axiom of choice.
11:54:26 <benmachine> c_wraith: that bounded monotonic sequences converge?
11:54:32 <c_wraith> yeah
11:54:38 <Vitka_banned> Well I'm able to join #haskell-blah...
11:57:33 <angstrom> I want to map over a [String] and find myself using `map . map'. is there some other way to do it? e.g., a shorthand, or so?
11:58:05 <byorgey> no
11:58:19 <angstrom> it seems pretty common, though
11:59:02 <byorgey> I mean, you could use the TypeCompose library to change  [[Char]] into  Compose [] [] Char, and then it's just a single 'fmap' instead of 'map . map'
11:59:16 <byorgey> but that would end up being longer, if length is what you're worried about.
11:59:52 <byorgey> angstrom: of course you're welcome to make your own function defined as  map . map  if you find yourself using it a lot.
12:00:29 <kmc> hmm, if you generalize both map and (.) to fmap, then map . map is also the common "composition with 2 arguments" function, right?
12:00:35 <kmc> that's nice
12:00:42 <byorgey> yes, I guess it is
12:00:53 <angstrom> byorgey: ty
12:01:02 <shachaf> @ty (.:) -- You mean this?
12:01:03 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
12:01:03 <Veinor> (.) `fmap` (.)
12:01:09 <byorgey> > (map . map . second) (+1) [[('c',2), ('d',3)], [('x',5)]]
12:01:11 <lambdabot>   [[('c',3),('d',4)],[('x',6)]]
12:01:17 <shachaf> However, I'm not sure whether (.) for fmap is valid.
12:01:26 <shachaf> Category might have precedence.
12:02:38 <dmwit> > (((+1) .) .) . [[('c', 2), ('d', 3), ('x', 5)]]
12:02:40 <lambdabot>   [[('c',3),('d',4),('x',6)]]
12:03:00 <benmachine> shachaf: in practice categories tend to be used far less than functors
12:03:13 <benmachine> I like the category notion better but I think . as fmap is more practical
12:03:47 <shachaf> benmachine: What about lenses?
12:03:51 <benmachine> > fmap fmap fmap (+2) [[1,2],[3,4]]
12:03:51 <lambdabot>   [[3,4],[5,6]]
12:04:09 <benmachine> shachaf: fair point, but I still think functors are more common
12:04:18 <benmachine> they're all over the proverbial shop
12:04:32 <kmc> > toUpper .: ["hello", "world"]
12:04:33 <lambdabot>   ["HELLO","WORLD"]
12:04:36 <kmc> pro
12:04:38 <shachaf> benmachine: I also think that maybe an overly- generalized (.) isn't a good thing.
12:04:48 <byorgey> functors are more common, but (.) as category composition is quite standard.  (.) as functor lifting is weird.
12:04:54 <Vitka_banned> msg chanserv unban #haskell
12:05:02 <benmachine> shachaf: I'm undecided personally. I don't like excessive generalisation, but fmap is hecka common
12:05:04 <Vitka_banned> You are not authorized to perform this operation.
12:05:06 <Vitka_banned> :P
12:05:15 <Veinor> i want ++ to be mappend, dammit
12:05:15 <shachaf> benmachine: Right, and you can use <$> or something for it.
12:05:17 * byorgey likes <$> for fmap
12:05:30 <copumpkin> Vitka_banned: join #haskell-ops or something
12:05:32 <benmachine> <$> is ok but I want to save those two keystrokes :P
12:05:36 <shachaf> It's annoying how @pl can convert things to use ap and (>>=) and so on, but @unpl can't safely convert back.
12:05:44 <angstrom> where is (.:) defined?
12:05:48 <shachaf> ＄
12:05:50 <benmachine> shachaf: @unpl could probably be a bit more clever
12:05:56 <shachaf> benmachine: No, it can't.
12:06:04 <shachaf> Because the monad functions are polymorphic.
12:06:14 <benmachine> shachaf: it *sometimes* can - sometimes they're used in a monomorphic way
12:06:20 <shachaf> benmachine: Well, OK.
12:06:24 <dmwit> It could be more clever if you were okay with assuming something about the types of things in the Prelude.
12:06:29 <shachaf> But it's a more general annoyance.
12:06:32 <dmwit> But ?pl doesn't do that, and neither does ?unpl.
12:06:42 <dmwit> ?pl \x -> map x y z
12:06:42 <lambdabot> flip (flip map y) z
12:06:46 <benmachine> dmwit: huh? @pl assumes all sorts of things
12:06:49 <shachaf> Neither of them even pays attention to types.
12:06:50 <benmachine> @pl 0 + x
12:06:51 <lambdabot> x
12:06:53 <benmachine> heehee
12:07:06 <shachaf> @pl 1 + 2
12:07:06 <lambdabot> 3
12:07:09 <shachaf> More like @calc.
12:07:14 --- mode: ChanServ set +o copumpkin
12:07:19 <shachaf> @pl 2^8
12:07:19 <lambdabot> 256
12:07:23 --- mode: copumpkin set -b *!*@*.nationalcablenetworks.ru
12:07:32 <shachaf> I wonder if you can get @pl to do arbitrary computations.
12:07:37 <shachaf> Probably.
12:07:38 --- mode: copumpkin set -o copumpkin
12:07:39 <Vitka_banned> o_O
12:07:40 <copumpkin> shachaf: you can get it in a loop
12:07:44 <shachaf> copumpkin: Right.
12:07:58 <copumpkin> I wonder why the entire ISP was banned
12:07:58 <shachaf> So presumably it has a sort of untyped lambda calculus evaluator in it, or something close.
12:08:19 <vitka> Much better. :)
12:08:20 <benmachine> @pl \g -> (\x -> g (x x)) (\x -> g (x x))
12:08:20 <lambdabot> ap (. join id) (. join id)
12:08:32 <Vitka_banned> Hello, myself.
12:10:18 <kmc> copumpkin, do you have an example of making @pl loop?
12:10:46 <copumpkin> kmc: in the past, it's killed lambdabot
12:11:03 <copumpkin> but yeah
12:11:25 <copumpkin> if you have a local @pl, or maybe if Cale has fixed lambdabot: @pl (\x -> x x) (\x -> x x)
12:11:51 <kmc> haha
12:11:56 <kmc> right, it doesn't typecheck
12:11:59 <benmachine> my local pl appears to be looping forever
12:11:59 <copumpkin> yeah
12:12:02 <kmc> fun
12:12:03 <copumpkin> @pl doesn't care though
12:12:04 <lambdabot> doesn't care though
12:12:07 <copumpkin> see?
12:12:09 <benmachine> I wanted to write a lightweight haskell typechecker once
12:12:12 <benmachine> it sounded hard
12:12:13 <kmc> are there any well-typed examples?
12:12:18 <dmwit> It's not easy to typecheck open terms. =)
12:12:19 <copumpkin> I don't think so
12:12:20 <kmc> benmachine, have you read Typing Haskell in Haskell?
12:12:27 <benmachine> kmc: yes, but I got told it was old
12:12:40 <kmc> old how?
12:12:42 <erus`> Someone should apply for a software patent for curried functions. I bet they would give it.
12:13:03 <benmachine> kmc: I forget the details; someone just told me to read some papers on System F instead
12:13:07 <benmachine> or Fc or something
12:13:09 <benmachine> I forget which exactly
12:13:20 <erus`> kmc casts are kinds now or something?
12:13:22 <kmc> you're not going to need Fc for typechecking Haskell
12:13:28 <kmc> only for weird GHC extensions
12:13:52 <kmc> THiH is still the best document I've seen on typechecking Haskell, though I haven't looked very hard
12:13:54 <benmachine> I did try to convert thih to typechecking HSE expressions
12:13:55 <erus`> or casts are type
12:14:01 <benmachine> but got bored, I think?
12:14:19 <benmachine> I'd need to use the annotated ast, because THIH's carries more information
12:19:43 <byorgey> you need Fc (or something like it) if you want to typecheck GADTs and type families
12:19:55 <byorgey> otherwise you can get away with a simplified form of F omega
12:20:03 <byorgey> simplified because there are no type-level lambdas.
12:20:39 <kmc> i think THiH is insufficient even for rank-2 types
12:20:59 <byorgey> probably
12:21:11 <byorgey> higher-rank types are difficult
12:21:24 <benmachine> there's a THIH that provides MPTCs
12:21:29 <benmachine> other than that shrug
12:21:39 <mah_b> is here anyone who knows about papers applying haskell to physics?
12:22:25 <cvic_> physics in general? Anything specific?
12:22:26 <copumpkin> mah_b: you might be interested in the quantum arrow by luqui
12:22:34 <copumpkin> not really applied physics though
12:23:03 <byorgey> benmachine: another nice tutorial (which covers how to handle higher-rank types) is "Practical type inference for arbitrary-rank types" by SPJ, Vytiniotis, Weirich, & Shields
12:23:58 <benmachine> byorgey: noted (not that I have time to deal with it atm anyway, though)
12:24:12 <byorgey> right, no worries
12:24:14 <benmachine> pesky university getting in the way of my fun :(
12:24:20 <byorgey> boo =(
12:24:39 <benmachine> (thanks though)
12:25:03 <mah_b> cvic_, any subject. (e.g. mechanic, electricity, waves, relativity)
12:25:30 <byorgey> benmachine: sure. what university?
12:26:20 <mah_b> copumpkin: this looks interesting, but I'm looking more for something "applied".
12:26:55 <cvic_> mah_b: don't know... except game physics
12:27:10 <cvic_> www.haskell.org/haskellwiki/Hpysics
12:27:25 <mah_b> Yes, I've seen this.
12:28:01 <vitka> Well, I once wrote tiny app to do simple Huckel calculation.
12:28:04 <cvic_> The most popular search result for "Haskell and physics"
12:28:32 <vitka> And then tried something more complex, and failed miserably.
12:28:47 <cvic_> Haskell -> Math Math -> Physics
12:29:51 <mah_b> ok, thank you (cvic_: *.*)
12:30:14 <cvic_> don't mention it. That's the connection
12:30:17 <kert> a3li is shit
12:30:23 <cvic_> go for the Math connection
12:31:03 <mah_b> maybe I should then ask the question in a different way: What area of physics do you think could be modeled nicely in haskell?
12:32:00 <byorgey> mah_b: what areas of physics can be modeled nicely by mathematics?
12:32:12 <byorgey> the answers to the two questions are likely to be very similar.
12:33:50 <dmwit> mah_b: You might want to ping wavewave, he's a hardcore physics guy who happens to use Haskell for his research.
12:34:03 <cvic_> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:physics
12:34:49 <cvic_> Not much...
12:36:55 <mike-burns> The bigger question is the quality of those packages.
12:37:01 <dmwit> trifecta is woefully underdocumented
12:38:15 <cvic_> That too
12:38:28 <stepkut> is there something like CoArrow, which has, coarr :: (c -> b) -> a b c
12:38:38 <benmachine> byorgey: wups sry, I went and did washing up mid-conversation :P
12:38:39 <cvic_> but that's why we need people from diverse areas
12:38:49 <benmachine> byorgey: university of cambridge!
12:39:22 <dmwit> stepkut: There are contravariant functors, for which cofmap :: (b -> a) -> (f a -> f b)
12:39:28 <byorgey> benmachine: oh, nice! did we meet when I was there last summer?
12:39:55 <benmachine> byorgey: no :(
12:39:59 <byorgey> sad =(
12:40:01 <benmachine> you were here last summer?
12:40:06 <cvic_> NRAO has used Haskell to implement the core science algorithms for the Robert C. Byrd Green Bank Telescope (GBT) Dynamic Scheduling System.  Nice! https://science.nrao.edu/facilities/gbt/schedules/dynamic
12:40:09 <benmachine> I met ezyang once when he was here
12:40:20 <benmachine> and I met some people at camhac
12:40:21 <dmwit> stepkut: CoArrow looks to me like a data type, not a class.
12:40:24 <byorgey> yes, I did an internship at MSR in the summer of 2010
12:40:54 <benmachine> oh, last as in 2010
12:40:56 <stepkut> dmwit: it's just, arr :: Arrow a => (b -> c) -> a b c, with the arrow reversed?
12:41:07 <byorgey> benmachine: yeah, I guess "last" is a bit ambiguous
12:41:10 <dmwit> stepkut: newtype Flip arr a b = Flip (arr b a)
12:41:43 <benmachine> byorgey: anyway, if you're ever back for some reason :P
12:41:47 <dmwit> stepkut: And then an instance of Category for Flip for whatever "arr" you think happens to be the dual of a category.
12:42:07 <stepkut> hmm
12:42:38 <dmwit> stepkut: What type were you wanting to plug in for "a" (or "arr" in my examples)?
12:42:46 <byorgey> benmachine: for sure!  I have no concrete plans to visit atm but it's a good possibility I might at some point
12:42:55 <stepkut> dmwit: I wrote a little parser like this:
12:42:59 <stepkut> dmwit: newtype Parser e tok a b = Parser { runParser :: tok -> Pos e -> [Either e ((a -> b, tok), Pos e)] }
12:43:08 <stepkut> which is an instance of Category and Arrow
12:44:03 <benmachine> byorgey: the awesome thing about going to world-famous universities is that cool people just turn up every now and then :>
12:44:11 <byorgey> benmachine: hehe, indeed =)
12:44:23 <rtharper> agreed
12:44:48 <stepkut> and then I can do, (const (,)) ^>> (lit "foo" . int . lit "-" . int), to parse "foo1-2".
12:45:03 <stepkut> dmwit: but that will return [Right (2,1)]
12:45:36 <dmwit> stepkut: (const (flip (,))) ^>> garbage?
12:45:53 <stepkut> dmwit: what if I have three ints?
12:46:08 <stepkut> dmwit: the order is all backwards
12:46:24 <dmwit> I'm not sure my mental type-inference engine is getting things straight.
12:46:30 <stepkut> dmwit: but if I change my parser to, newtype Parser e tok a b = Parser { runParser :: tok -> Pos e -> [Either e ((b -> a, tok), Pos e)] }
12:46:39 <dmwit> Can you help me with a few type annotations there?
12:46:41 <stepkut> so that I have, b -> a, instead of a -> b. Then it works out ok
12:46:55 <stepkut> but I can't make an Arrow instance then
12:47:12 <stepkut> for the first version of the parser:
12:47:13 <stepkut> lit :: Text -> Parser (ParserError MajorMinorPos) [Text] a a
12:47:19 <stepkut> int :: (Integral i) => Parser (ParserError MajorMinorPos) [Text] b (i -> b)
12:47:39 <stepkut> (lit "foo" . int . lit "-" . int) :: Parser (ParserError MajorMinorPos) [Text] a (Integer -> Integer -> a)
12:49:03 <dmwit> stepkut: reading...
12:49:11 <hatomic> I see haskell98 package defaults to exposed and haskell2010 is hidden. Does that mean default GHC installs use haskell 98?
12:49:26 <stepkut> in theory, I could use normal applicative parsers for this, (,) <$> (lit "foo" *> int <*> lit "-" *> int)
12:49:56 <stepkut> but having to explicitly mark with parts to ignore via *> and <* is a bit tedious
12:50:14 <stepkut> I like the cleanliness of (lit "foo" . int . lit "-" . int)
12:50:43 <stepkut> which, via OverloadedStrings, can be reduced even more to, ("foo" . int . "-"  .int)
12:51:09 <stepkut> so that is what I am really after
12:51:27 <nomeata> Hi. What does it mean if I find the names of type aliases in the profiling output (-hy) I thought they disappear?
12:52:26 <copumpkin> is there an algorithm for computing graphs that represent common polyhedra?
12:52:56 <erus`> rasterizing
12:52:59 <cheater_> i don't think there would be just one algorithm
12:53:11 <cheater_> you might be lucky with regular ones
12:53:36 <copumpkin> cheater_: regular shouldn't mean anything on graphs?
12:53:44 <cheater_> well it does
12:53:59 <copumpkin> I'm talking about the connectivity structure
12:53:59 <cheater_> regular means it looks different. therefore the graph is different?
12:54:13 <cheater_> or do you mean representation groups
12:54:13 <copumpkin> graph in the mathematical sense
12:54:13 <cheater_> ok
12:54:22 <cheater_> the other graph is in the mathematical sense too
12:54:22 <cheater_> but um
12:54:42 <cheater_> from what i remember very vaguely my topology teacher told me representations are mostly a manual job
12:55:14 <Athas> Is Clemens Fruhwirth on this channel?
12:55:29 <cheater_> of course, if your polyhedron's faces can be classified into groups that might help you copumpkin
12:55:41 <cheater_> btw copumpkin
12:55:44 <cheater_> i have questian
12:55:45 <copumpkin> http://en.wikipedia.org/wiki/Schl%C3%A4fli_symbol
12:55:57 <cheater_> yeah the schlaefli symbol is helpful there
12:56:01 <copumpkin> given one of those symbols, generate a graph
12:56:03 <copumpkin> that seems tractable
12:56:24 <copumpkin> cheater_: what questian? :)
12:56:44 <cheater_> copumpkin: is it difficult to write a realtime exchange?
12:57:15 <copumpkin> not sure :) I have several ideas on how to do it, but haven't gotten around to see if they work yet
12:57:34 <cheater_> let's say i wanted to sit down, and write an exchange
12:57:36 <cheater_> moderately big
12:57:51 <cheater_> let's say i want it to have just one thing traded for
12:58:10 <cheater_> and very basic features, maybe even no futures
12:58:20 <copumpkin> if you just want to support limit orders, I'd imagine it'd be pretty straightforward
12:58:20 <cheater_> would i make it in half a year?
12:58:28 <copumpkin> dealing with atomicity and persistence could  be hard
12:58:31 <cheater_> where does the complexity come from?
12:58:34 <copumpkin> yeah, definitely, unless you suck at programming
12:58:46 <copumpkin> cheater_: more advanced order types, reliability, performance
12:58:56 <cheater_> such as what order types?
12:59:03 <cheater_> ah ok
12:59:06 <cheater_> hm
12:59:09 <copumpkin> trailing limit orders, maybe
12:59:11 <copumpkin> stuff like that
12:59:17 <copumpkin> making sure you do the right thing in different situations
12:59:18 <cheater_> what are traling limit orders?
12:59:22 <copumpkin> trailing stop, I mean
12:59:31 <cheater_> what are traling stop orders?
12:59:37 <copumpkin> a stop order is something like "make this order a market order when the price goes above/below X"
12:59:54 <copumpkin> a trailing stop is same as above, except the X moves in the same direction as the market
13:00:01 <dmwit> stepkut: sorry, byorgey distracted me
13:00:06 <cheater_> A sell trailing stop order sets the stop price at a fixed amount below the market price with an attached "trailing" amount. As the market price rises, the stop price rises by the trail amount, but if the stock price falls, the stop loss price doesn't change, and a market order is submitted when the stop price is hit. This technique is designed to allow an investor to specify a limit on the maximum possible loss, without setting a limit 
13:00:14 <cheater_> interesting
13:00:16 <stepkut> dmwit: I am checking my work anyway :)
13:00:23 * byorgey isn't sorry
13:00:23 <cheater_> ok i think i have to go
13:00:33 <copumpkin> cheater_: it's interesting stuff, but tricky to implement :)
13:00:42 <cheater_> yes, definitely
13:01:04 <cvic_> can Haskell do it?
13:01:05 <cheater_> is it a requirement for any self-respecting exchange?
13:01:10 <cvic_> Sure it can.
13:01:18 <cheater_> @faq why is cvic asking?
13:01:18 <lambdabot> The answer is: Yes! Haskell can do that.
13:01:32 <cheater_> copumpkin: would you say it's "necessary"?
13:01:33 * cvic_ ;-) 
13:01:53 <copumpkin> cheater_: nah, most of the bitcoin exchanges are super simple, for example, and people still use them
13:02:00 <copumpkin> but they're nice features to have in an active market
13:02:01 <cheater_> aha
13:02:07 <cheater_> gotcha
13:02:14 <dmwit> stepkut: Okay, I think I understand the problem. And I think there isn't a well-known built-in class for it, but it shouldn't be hard to make one.
13:02:48 <stepkut> sadly if I do that, I don't get the arrow syntax :-/
13:02:54 <kmc> most of the bitcoin exchanges will leak your password and lose all your money
13:02:57 <kmc> and people still use them
13:03:33 <copumpkin> hell yeah
13:03:36 <dmwit> stepkut: yes =(
13:03:37 <copumpkin> and we're grateful
13:05:02 <cheater_> hahaha
13:05:04 <cheater_> nice
13:05:08 <cheater_> well ok, i'm off
13:05:33 <cvic_> people still using bitcoin?
13:06:12 <copumpkin> cvic_: price is way down, but still fairly active :)
13:06:22 <cvic_> heh
13:06:23 <kmc> copumpkin, are you still mining?
13:06:28 <cvic_> those crypto geeks
13:06:35 <copumpkin> kmc: nah, but only cause I got tired of fixing my ubuntu install
13:06:42 <copumpkin> kmc: way before it turned unprofitable :P
13:06:48 <kmc> hahaha
13:06:59 <copumpkin> now that machine is a lean mean skyrim-playing machine
13:07:01 <copumpkin> or will be
13:07:07 <cvic_> bitcoin bubble. Good times, eh?
13:07:22 <kmc> jesus, you need 4 top-of-the-line graphics cards to play some rpg? ;P
13:07:31 <kmc> also don't you have the cheapest CPU and RAM
13:07:42 <copumpkin> yeah, but I'll probably throw 16gigs of ram into it at some point
13:07:44 <copumpkin> since it's so cheap these days
13:07:50 <copumpkin> then I can run agda on it too
13:07:51 <stepkut> dmwit: maybe I just want to use >>> instead of . :-/
13:07:58 <cvic_> to crack hashes
13:08:00 <kmc> yeah, I'm glad that RAM is still getting cheaper
13:08:02 <mike-burns> Is :-/ also a function?
13:08:06 * Twey does that
13:08:08 <kmc> :t (:-/)
13:08:09 <lambdabot> Not in scope: data constructor `:-/'
13:08:09 <Twey> Haha
13:08:14 <Twey> It could be
13:08:22 <copumpkin> cvic_: yeah, those GPUs are also good at graphics, surprisingly enough!
13:08:26 <cvic_> <>< is a very cool operator
13:08:38 <cvic_> or was it ><>
13:08:40 <Twey> Ah, the fish operator
13:09:08 <cvic_> copumpkin: you can build a supercomputer with a few PS3s
13:09:12 <cvic_> that's cool
13:09:21 <b_jonas> is the rose operator valid perl syntax?
13:09:28 <b_jonas> -'-,-<@
13:09:34 <b_jonas> s/perl/haskell/
13:09:35 <cvic_> everything is valid Perl syntax
13:09:39 <b_jonas> sorry, I'm tired
13:09:43 <b_jonas> I should sleep
13:09:46 <cvic_> Ah, Haskell
13:09:51 <Twey> b_jonas: No, because of ,
13:10:02 <Twey> You can have a thornless rose
13:10:14 <hpc> cvic_: untrue; you might have a BEGIN section that crashes ;)
13:10:21 <Twey> Oh no
13:10:23 <Twey> ' is special too
13:10:24 <Twey> :<
13:10:28 <cvic_> Damn, true
13:10:30 <copumpkin> cvic_: PS3s are nothing compared to modern GPUs
13:10:35 <copumpkin> especially for bitcoin mining
13:10:35 <Twey> > let (--‘-<@) = (+) in 5 --‘-<@ 3
13:10:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:10:40 <Twey> Hmph
13:10:41 <b_jonas> right, but how about some variant, or possibly not as a single operator but inside some stuff
13:10:47 <Twey> What's wrong with *that*?
13:10:54 <b_jonas> yes, that one is right
13:11:08 <Twey> > let (---<@) = (+) in 5 ---<@ 3
13:11:09 <lambdabot>   8
13:11:14 <cvic_> Hahha
13:11:15 <ion> ><̢>̢
13:11:21 <Twey> > isSymbol '‘'
13:11:22 <lambdabot>   False
13:11:24 <Twey> Huh.
13:11:26 <Twey> Weird.
13:11:35 <Twey> > let ‘foo’ = 5 in ‘foo’
13:11:36 <lambdabot>   <no location info>: lexical error at character '\8216'
13:11:39 <b_jonas> > 2 --,-'-<@ 5
13:11:40 <lambdabot>   2
13:11:47 <Twey> ‘ isn't anything, apparently
13:11:53 <Twey> b_jonas: Oh, that is allowed?
13:11:58 <hpc> ?eval '''
13:12:07 <b_jonas> Twey: it's a trick: the --, starts a comment
13:12:10 <hpc> er
13:12:10 <Twey> Oh!
13:12:11 <Twey> Haha.
13:12:20 <hpc> ?run '''
13:12:21 <lambdabot>   <no location info>:
13:12:21 <lambdabot>      lexical error in string/character literal at chara...
13:12:34 <b_jonas> :t 2 -- hello
13:12:35 <lambdabot> forall t. (Num t) => t
13:12:42 <hpc> Twey: how the hell did that parse?
13:12:45 <b_jonas> ghci's answer for that is more confusing
13:12:46 <dmwit> Twey: @ is special, but ' isn't.
13:13:06 <hpc> oh nvm, backtick
13:13:20 * hpc is on phone with very small font
13:13:22 <b_jonas> hpc: it's not backtick, it's non-ascii open quote
13:13:29 <dmwit> > let f x@(y:ys) = (x,y,ys) in f [3,4]
13:13:29 <lambdabot>   ([3,4],3,[4])
13:13:32 <hpc> or that
13:13:42 <benmachine> Twey: it might be that ‘ is something but the lambdabot translation is screwing it up
13:13:51 <Twey> Possibly
13:13:56 <b_jonas> hpc: ` is backtick, ‘ “ „ ” ’ » « are non-ascii quotes
13:14:02 <benmachine> > let x $@ y = y in ()
13:14:02 <lambdabot>   ()
13:14:03 <Twey> Nope
13:14:12 <Twey> > isSymbol '»'
13:14:13 <lambdabot>   False
13:14:23 <Twey> Apparently punctuation ≠ symbol
13:14:24 <dmwit> > let x $@ y = 3 in x 5
13:14:25 <lambdabot>   Couldn't match expected type `t1 -> t'
13:14:25 <lambdabot>         against inferred type `Simpl...
13:14:29 <Twey> But . is a symbol, so I'm confused.
13:14:44 <dmwit> :t let x $@ y = 3 in ($@)
13:14:45 <lambdabot> forall t t1 t2. (Num t2) => t -> t1 -> t2
13:14:48 <dmwit> huh
13:14:52 <Twey> > let (y ?? n) p = if p then y else n
13:14:53 <lambdabot>   not an expression: `let (y ?? n) p = if p then y else n'
13:14:56 <Twey> @let (y ?? n) p = if p then y else n
13:14:56 <benmachine> > isSymbol '.'
13:14:57 <lambdabot>   False
13:14:57 <lambdabot>  Defined.
13:15:06 <benmachine> Twey: looks like isSymbol is the wrong test
13:15:07 <dmwit> > let x -'-<@ y = 3 in "hey" -'-<@ "there"
13:15:08 <lambdabot>   <no location info>:
13:15:08 <lambdabot>      lexical error in string/character literal at chara...
13:15:22 <hpc> ?run isSymbol '?'
13:15:23 <b_jonas> heh
13:15:23 <lambdabot>   False
13:15:27 <hpc> ?run isSymbol 'z'
13:15:28 <lambdabot>   False
13:15:35 <hpc> o.O
13:15:40 <Twey> > map (('Y' ?? 'N') . isSymbol) "'@‘’“”«»!?#,"
13:15:41 <lambdabot>   "NNNNNNNNNNNN"
13:15:53 <Twey> So what *is* a symbol?
13:15:53 <benmachine> > take 10 $ filter isSymbol [minBound ..]
13:15:54 <lambdabot>   "$+<=>^`|~\162"
13:16:01 <Twey> *headscratch*
13:16:05 <benmachine> :P
13:16:08 <hpc> wut
13:16:15 <Twey> > isSymbol '-'
13:16:16 <lambdabot>   False
13:16:21 <Twey> So + is a symbol, but - isn't.
13:16:23 <Twey> Riiiiight.
13:16:55 <Veinor> ugh why is ld pegging my CPU in IO
13:17:04 <benmachine> is - a hyphen or a minus, pedantically?
13:17:10 <Twey> Both
13:17:14 <Twey> It's a HYPHEN-MINUS
13:17:30 <dmwit> > isPunctuation '.'
13:17:30 <Veinor> i despise ld
13:17:31 <lambdabot>   True
13:17:31 <benmachine> > text . take 20 . filter isSymbol $ [minBound ..]
13:17:33 <lambdabot>   $+<=>^`|~
13:17:37 <benmachine> huh.
13:17:38 <Twey> There are dedicated Unicode equivalents for each; the HYPHEN-MINUS is retained for ASCII compatibility
13:17:43 <benmachine> > take 20 . filter isSymbol $ [minBound ..]
13:17:45 <lambdabot>   "$+<=>^`|~\162\163\164\165\166\167\168\169\172\174\175"
13:17:49 <benmachine> Twey: oh, neat
13:17:50 <benmachine> sorta
13:17:50 <Twey> > map (('Y' ?? 'N') . isPunctuation) "'@‘’“”«»!?#,"
13:17:51 <dmwit> > map isPunctuation "'@‘’“”«»!?#,"
13:17:51 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True]
13:17:52 <lambdabot>   "YYYYYYYYYYYY"
13:17:59 <Twey> … that leaves me no less in the dark
13:18:03 <Twey> OH!
13:18:06 <Twey> Hah!
13:18:11 <Twey> Wait… no.
13:18:14 <dmwit> Twey: From the Haskell report, symbol -> any unicode symbol or punctuation
13:18:27 <dmwit> Twey: But infix operators don't use symbol.
13:18:41 <dmwit> They use symbol - _:"'
13:18:49 <dmwit> any symbol except those
13:18:52 <dmwit> four
13:19:18 <benmachine> you can use : in infix operators
13:19:31 <benmachine> I thought you could anyway
13:19:36 <Twey> > let (--‘-<❧) = (+) in 5 --‘-<❧ 3
13:19:37 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:19:38 <benmachine> > let x -: y = () in ()
13:19:38 <lambdabot>   ()
13:19:40 <Twey> :<
13:19:41 <dmwit> Oh, any symbol except those four or "special" guys -- like (), {}, etc.
13:19:51 <Twey> dmwit: Ah, okay.
13:20:21 <dmwit> (),;[]`{} specifically
13:20:51 <dmwit> So, all together: any symbol or punctuation except _:"'(),;[]`{}
13:23:22 <benmachine> dmwit: and yet we continue to fail to put ‘ in anything
13:23:51 <cvic_> foo
13:24:56 <benmachine> hm
13:25:02 <roconnor_> @hoogle readMaybe
13:25:02 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe :: (i -> r -> a) -> Split t i r -> SplitM t j i -> SplitM t j a
13:25:03 <lambdabot> Data.Graph.Inductive.Internal.Thread threadMaybe' :: (r -> a) -> Split t i r -> Split t j (Maybe i) -> Split t j (Maybe a)
13:25:05 <benmachine> > let foo’ = 7 in ()
13:25:06 <lambdabot>   <no location info>: lexical error at character '\8217'
13:25:09 <benmachine> nope
13:25:16 <benmachine> > ‘x’
13:25:17 <lambdabot>   <no location info>: lexical error at character '\8216'
13:25:34 <ion> > let a = 1; a′ = a+1; a″ = a′+1; a‴ = a″+1; a⁗ = a‴+1 in a⁗
13:25:35 <lambdabot>   <no location info>: parse error on input `='
13:25:51 <roconnor_> @hoogle readEither
13:25:51 <lambdabot> No results found
13:26:09 <byorgey> roconnor_: maybe you want the 'safe' package?
13:26:10 <benmachine> > let a » b = () in ()
13:26:11 <lambdabot>   <no location info>: lexical error at character '\187'
13:26:14 <benmachine> :/
13:26:19 <izukerman> is there some way to use the cabal Version in haskell source?
13:26:43 <cvic_> 
13:26:51 <ion> > map generalCategory ['\'' {- not prime -}, '′' {- prime -}]
13:26:52 <lambdabot>   [OtherPunctuation,OtherPunctuation]
13:27:13 <benmachine> it seems like it wants specifically OtherPunctuation
13:27:18 <cvic_> > generalCategory
13:27:18 <lambdabot>   Overlapping instances for GHC.Show.Show
13:27:19 <lambdabot>                              (GHC.T...
13:27:20 <benmachine> » and ’ both fail for being FinalQuote
13:27:38 <nomeata> let x’=1
13:27:47 <nomeata> let x’=1 in x’
13:27:53 <byorgey> izukerman: yes, a special Foo_Paths module is generated which has the version and some installation paths
13:27:56 <cvic_> Nope
13:27:56 <nomeata> > let x’=1 in x’ -- :-)
13:27:57 <lambdabot>   <no location info>: lexical error at character '\8217'
13:28:02 <byorgey> izukerman: I am trying to find you a link to the documentation
13:28:03 <benmachine> nomeata: we already tried that
13:28:21 <nomeata> benmachine: hmm, right, should read the scrollback buffer more carefully. \8217 was easier to spot than ’
13:28:53 <cvic_> > putChar
13:28:53 <lambdabot>   Overlapping instances for GHC.Show.Show
13:28:54 <lambdabot>                              (GHC.T...
13:29:04 <cvic_> Hm
13:29:21 <byorgey> izukerman: http://www.haskell.org/cabal/users-guide/#accessing-data-files-from-package-code
13:29:34 <cvic_> How can I print a special character if I know the code?
13:29:36 <byorgey> izukerman: it doesn't say anything about version but I'm pretty sure that special module has version info too
13:29:39 <cvic_> Like
13:29:40 <cvic_> foo '\8217'
13:29:53 <benmachine> > let x ⇮ y = () in ()
13:29:53 <lambdabot>   ()
13:30:10 <benmachine> > let x ☺ y = () in ()
13:30:11 <lambdabot>   ()
13:30:33 <byorgey> izukerman: once you have built a project with cabal look in dist/build/autogen
13:31:52 <cvic_> > "\130\&11"
13:31:53 <lambdabot>   "\130\&11"
13:32:03 <donri> > let (☺) = (+) in 5 ☺ 3
13:32:04 <lambdabot>   8
13:32:25 <cvic_> > putString "test \130\&11
13:32:25 <lambdabot>   <no location info>:
13:32:26 <lambdabot>      lexical error in string/character literal at end o...
13:32:31 <cvic_>  "
13:32:40 <cvic_> > putString "test \130\&11 "
13:32:41 <lambdabot>   Not in scope: `putString'
13:32:54 <cvic_> Right.
13:33:01 * cvic_ googles 
13:33:41 <cvic_> > putStr "test \130\&11 "
13:33:43 <lambdabot>   <IO ()>
13:34:06 <cvic_> > putStr "what "
13:34:07 <lambdabot>   <IO ()>
13:34:22 <cvic_> So > is for type
13:34:38 <cvic_> !help
13:34:38 <andreas_b> I have a function in which I want to subtract a constant from every element in a list. I tried "map (-constant) list" but it gives me a type error doing "map (+constant) list" works however
13:34:58 <andreas_b> what am I doing wrong?
13:35:39 <monochrom> because -5 is already taken for "negative five"
13:35:39 <byorgey> andreas_b: you are doing nothing wrong, you have just run up against a quirk in the Haskell spec
13:35:55 <byorgey> andreas_b: instead of (-constant) you have to write (subtract constant)
13:35:55 <monochrom> > map (subtract 5) [1, 10, 20]
13:35:56 <lambdabot>   [-4,5,15]
13:36:02 <byorgey> the subtract function is provided for exactly this reason.
13:36:22 <byorgey> - is just special.
13:36:23 <cvic_> >map (`-` 5 ) [1..10]
13:36:55 <byorgey> andreas_b: I think it's silly, by the way, but there it is.
13:37:06 <andreas_b> oh ok, thank you very much :D I'll go with subtract then
13:37:28 <cvic_> does the `` thing work?
13:37:36 <nimish_> is there a mature graph library that can handle millions of edges and ~1 million nodes?
13:37:40 <cvic_> > map (`+` 4 ) [1,2,3]
13:37:41 <lambdabot>   <no location info>: parse error on input `+'
13:37:54 <cvic_> Seems not
13:37:58 <cvic_> Only for `name`
13:38:01 <andreas_b> I'll give it a try and see
13:39:12 <andreas_b> nope doesn't seem to
13:42:34 <kmc> nimish_, what do you need to do with it?
13:42:55 <kmc> cvic_, no, > evaluates and prints an expression.  lambdabot has some special typeclass instances so that it can print IO actions, but it just prints the type
13:43:02 <kmc> lambdabot will evaluate IO actions but will not execute them
13:43:12 <cvic_> I see
13:43:16 <kmc> (but there it is not even evaluating)
13:43:19 <kmc> > undefined :: IO ()
13:43:20 <lambdabot>   <IO ()>
13:43:26 <kmc> > (undefined :: IO ()) `seq` ()
13:43:26 <lambdabot>   *Exception: Prelude.undefined
13:43:33 <nimish_> kmc: do a lot of network analysis, so lots of statistics on nodes and edges. I'll need to do some community detection which includes some optimization
13:43:39 <kmc> > (putChar 'x' :: IO ()) `seq` ()
13:43:39 <lambdabot>   ()
13:45:45 <krawczyk> ["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Plat++
13:46:55 <stepkut> dmwit: i figured it out. :)
13:47:05 <stepkut> dmwit: i think
13:47:50 <stepkut> maybe not
13:48:14 <Ke> > return 1 :: IO Int
13:48:15 <lambdabot>   <IO Int>
13:49:36 <wavewave> hi
13:49:54 <krawczyk> wavewave: Hi!
13:53:00 <wavewave> just finished a talk and came back to irc.   :-P
13:58:21 <kmc> unsafePerformIO docs say "Use the compiler flag -fno-cse to prevent common sub-expression elimination being performed on the module, which might combine two side effects that were meant to be separate. A good example is using multiple global variables (like test in the example below)."
13:58:25 <kmc> is this still necessary?
13:59:03 <kmc> most of the code I've seen which uses this for global state does not appear to do it
14:00:07 <hpc> kmc: i like to think that modules don't use it for global state anymore ;)
14:00:22 <kmc> you can think whatever you like
14:00:46 <leod> @type Text
14:00:46 <lambdabot> Not in scope: data constructor `Text'
14:01:42 <donri> is there something more "aggressive" than hlint, that could make suggestions like http://chrisdone.com/posts/2011-10-17-boycott-head.html ?
14:02:07 <byorgey> donri: you can easily add your own custom rules to hlint
14:02:23 <byorgey> but otherwise, not that I know of
14:02:25 <donri> byorgey, isn't it limited to sticking within the existing types though?
14:03:14 <kmc> hpc, I have a few scenarios where global state is the best approach, imo
14:04:19 * BMeph wonders what the use is from a program that suggests you to fix your usage of types that don't exist... ;)
14:04:33 <kmc> hlint sometimes gives bad advice too
14:04:46 <kmc> just because you can get rid of some parentheses does not mean you should
14:05:24 <donri> kmc, if you have a function that uses head and therefore could end in an exception it could suggest a change to listToMaybe which would change the type of your function - but to Maybe, an existing type
14:05:31 <donri> uh, BMeph*
14:05:42 <kmc> just because you could import Control.Arrow and use some function with a scary type does not mean you should
14:06:04 <donri> kmc, it also likes to suggest getting rid of "redundant" do's, but they're sometimes useful for future refactorability
14:06:10 <shachaf> Control.Arrow doesn't have the real scary types.
14:06:12 <donri> for example blaze-html
14:06:29 <byorgey> donri: I don't know whether it cares about types
14:06:58 <donri> byorgey, i thought it only made suggestions that didn't change the behavior of the program?
14:06:59 <Saizan> i'm pretty sure it doesn't typecheck anything
14:07:33 <byorgey> donri: by default it doesn't.  But it can't possibly check whether custom rules you specify have that property.
14:07:50 <byorgey> donri: you could also just suggest   head xs ---> error "foo" `fromMaybe` listToMaybe xs   which does not change the semantics.
14:07:55 <byorgey> or the types.
14:08:24 <byorgey> but at least it would force you to give a good error message.  and if you thought it was appropriate you could go further and change to a Maybe return value, etc.
14:08:41 <donri> isn't that what chrisdone also suggests with the throw?
14:09:02 <donri> but, isn't the broader point to avoid partial functions
14:09:09 <donri> which may require a change in types
14:09:20 <byorgey> you can't ALWAYS avoid partial functions.
14:09:44 <byorgey> but at the very least you should not shoot yourself in the foot by using partial functions that generate a generic error message which is impossible to track down.
14:11:56 <donri> made worse by haskell's lack of proper tracebacks, though i read something about something to fix that situation ...
14:12:30 <mm_freak> as far as i understand, a function of type a -> (forall b. b) requires the caller to assume a universal result type, is that wrong?  because it doesn't really match with what i'm observing
14:12:34 <donri> the more common runtime errors are, the better the tools to debug them :)
14:12:36 <wavewave> donri: we will probably have stack trace soon, hopefully.
14:13:05 <benmachine> mm_freak: I think that foralls can be moved such that that is equivalent to forall a b. a -> b
14:13:23 <wavewave> with my wishful thinking.
14:13:28 <monochrom> a -> (forall b. b) requires the caller to pick b.
14:13:41 <mm_freak> benmachine: i'm not sure…  (forall a. a) -> b is definitely different from a -> b
14:13:44 <monochrom> which is more like a freedom than a require
14:13:50 <benmachine> mm_freak: right, they can't be moved in that way
14:13:59 <mm_freak> monochrom: why is it freedom in the result case and requirement in the argument case?
14:14:13 <mm_freak> (f :: (forall a. a) -> b) ()
14:14:15 <mm_freak> gives me a type error
14:14:24 <benmachine> I forget how it works
14:14:27 <monochrom> callee is the user of an argument. caller is the user of a result.
14:14:38 <shachaf> monochrom: What's the type of f?
14:14:43 <benmachine> forall things . a -> T can be turned into a -> forall things . T if a doesn't mention things
14:14:45 <shachaf> s/monochrom/mm_freak/
14:14:50 <Saizan> a -> forall b. b ~ forall b. a -> b just by a generalized flip
14:14:50 <benmachine> and vice versa
14:14:58 <benmachine> right
14:15:18 <mm_freak> shachaf: i gave a type signature…  just replace f by undefined
14:15:23 <mm_freak> f is not important here
14:15:25 <mm_freak> monochrom: i see
14:15:50 <shachaf> Oh, right.
14:15:55 <monochrom> so the unifying principle is that the user picks and the provider obliges. the question is who is the user: caller or callee?
14:16:10 <shachaf> mm_freak: When you say (f :: (forall a. a) -> b), that means f accepts a value which is able to assume any type at all.
14:16:49 <shachaf> For example, if you say (f :: (forall a. Num a => a) -> Bool), f accepts only a value that can be *any* Num.
14:16:56 <shachaf> @ty 5 -- Like 5
14:16:57 <lambdabot> forall t. (Num t) => t
14:17:00 <donri> wavewave, http://www.yesodweb.com/blog/2011/09/limitations-of-haskell has some mentions
14:17:18 <shachaf> @ty let f :: (forall a. Num a => a) -> Bool; f x = x == 0 in f
14:17:19 <lambdabot> (forall a. (Num a) => a) -> Bool
14:17:27 <wavewave> mm_freak,  f :: (forall a. a ) -> b can take only bottom as first input.
14:17:32 <shachaf> I guess you don't gain much with that particular example.
14:17:44 <mm_freak> wavewave: yes, i understand the argument case
14:17:50 <mm_freak> i just don't understand the result case
14:18:05 <shachaf> mm_freak: Well, f :: forall a. a is "the result case"
14:18:07 <benmachine> mm_freak: did you understand what Saizan said?
14:18:35 <mm_freak> benmachine: i'm still thinking
14:18:37 <benmachine> it helps if you think of forall like it is in agda, declaring a type function
14:19:17 <wavewave> donri: yes. I read that article, too.
14:19:24 <mm_freak> uhm…  could you expand on that?
14:20:18 <Twey> Heh, the Yesod site is still hideous
14:20:50 <mm_freak> @ benmachine
14:21:40 <wavewave> mm_freak: it's in fact a little confusing..
14:22:13 <wavewave> mm_freak: basically, you need to distinguish what is the scope of type variables.
14:22:14 <benmachine> mm_freak: you can look at 'forall a. a -> a' as 'give me a type, and I'll give you a function from that type to itself'
14:22:56 <wavewave> (forall a. a ) -> b   :   the only type variable in scope outermost  is b
14:23:14 <benmachine> mm_freak: when you look at it like that, you could see 'forall a. Char -> a' as 'give me a type and a Char, and I'll give you a thing of that type' and 'Char -> forall a. a' as 'give me a Char and a type, and I'll give you a thing of that type'
14:23:15 <benmachine> the latter two are fairly clearly equivalent
14:23:40 <benmachine> but '(forall a. a) -> Char' can be seen as 'give me a function that takes a type and gives a value of that type, and I'll give you a Char']
14:24:14 <wavewave> a -> (forall b. b)  = forall b. a -> b : a, b both are in outermost scope
14:24:29 <nimish_> hey, so is there a mature haskell graph library that can handle millions of nodes/edges?
14:24:39 <ion> benmachine: Wouldn’t that description match (forall a. a -> a) -> Char?
14:25:03 <shachaf> ion: No, the function benmachine talked about takes a type as an argument.
14:25:10 <benmachine> ion: no, not under my weird terminology
14:25:13 <ion> Err, sorry. I didn’t read accurately.
14:25:24 <shachaf> benmachine: Your terminology isn't that weird.
14:25:49 <benmachine> shachaf: if you're going to use "that's how agda does it" as an indication of "not weird" I'm not sure I buy it :P
14:26:24 <shachaf> benmachine: It's both how Agda does it and how I think of foralls when anything like this comes up.
14:26:52 <benmachine> shachaf: fair enough, but it could be weird to people who aren't familiar with it
14:27:34 <mm_freak> benmachine: ah, that makes sense a little
14:27:58 <shachaf> mm_freak: I think concrete examples that use nested foralls would help.
14:28:07 <shachaf> Have you seen any? :-)
14:28:29 <mm_freak> shachaf: the funny thing is that i use rank n types a lot
14:28:37 <shachaf> Oh.
14:28:59 <shachaf> What was the question, then?
14:29:21 <benmachine> you don't have to understand rank-n types to use them, technically :P
14:29:23 <mm_freak> i always understood it as:  (forall a. …) is a type that only unifies what types, which are at least as polymorphic
14:29:35 <mm_freak> unifies with*
14:29:50 <mm_freak> and so far it worked that way
14:30:09 <mm_freak> it also made sense of "inferred type is less polymorphic than …"
14:30:39 <mm_freak> so i thought i understood what's going on technically
14:31:14 <mm_freak> but today i tried to use a higher rank result type, which turned out not to be higher rank
14:31:15 <shachaf> mm_freak: Think of the function f x = (x 'a', x True)
14:31:54 <mm_freak> shachaf: my question was about the result case…  why that one is different…  it makes a little sense now, but only a little, and i don't feel like i've really understood it
14:32:13 <benmachine> mm_freak: I think if you thought about what you wanted your higher-rank result type to do, you'd realise you didn't need it
14:32:15 <shachaf> mm_freak: It isn't different, is it?
14:32:20 <benmachine> but that's just my suspicion
14:32:31 <shachaf> Well, I'm not sure what you mean by different.
14:32:42 <mm_freak> benmachine: it was just a test, not related to any actual application
14:33:00 <benmachine> mm_freak: yeah, sure, but if you thought about what you expected it to mean
14:33:16 <mm_freak> shachaf: (forall a. a) -> b is different from a -> b, but a -> (forall b. b) is the same as a -> b
14:33:40 <shachaf> Oh.
14:33:51 <mm_freak> benmachine: i expected it to mean that the result type of the function in question needs to be unifyable only with fully polymorphic types
14:33:52 <shachaf> Well, I guess you can see that as different.
14:34:09 <shachaf> Do you see why "forall a. Int -> a" is the same as "Int -> forall a. a"?
14:34:42 <benmachine> mm_freak: if you want 'a function that can only return bottom', then ending it in forall a. a will do that
14:34:50 <mm_freak> shachaf: i'm not sure…  i have a vague idea, but it didn't click yet
14:35:02 <benmachine> but it's not higher-rank, still: forall a. Int -> a can also only return bottom
14:35:36 <mm_freak> benmachine: i can totally see how both functions can only return bottom
14:35:37 <benmachine> if you want a function whose result can only be passed to functions that accept anything, then... that's weird. maybe you should return Void
14:35:51 <shachaf> mm_freak: Well, "forall a. Int -> a", for any type, takes an Int and gives you that type. "Int -> forall a. a" takes an Int and, for any type, gives you that type.
14:35:52 <Xeli> is there a functions which takes a list of functions (a->b) and b and gives back the results in a list? [a->b]->a->[b]
14:35:53 <wavewave> mm_freak: logically there is only one function f _ ( :: Int -> forall a. a) = undefined
14:35:58 <shachaf> Oh, is *that* was Saizan meant by flip?
14:36:09 <mm_freak> benmachine: the difference is that i can pattern-match the result with a concrete value without a type error, and that isn't what i expected
14:36:14 <quicksilver> Xeli: map ($b) list_of_functions
14:36:17 <wavewave> hmm f :: Int -> forall a. a,  f _ = undefined
14:36:33 <mm_freak> wavewave: yes, that's clear
14:37:06 <mm_freak> shachaf: i think the fog is starting to clear
14:37:58 <wavewave> f :: Int -> (forall b. b -> b) ,    f _ = id
14:38:21 <wavewave> id (3 :: Int) = 3 :: Int
14:38:23 <benmachine> mm_freak: return Void then, I guess
14:38:47 <shachaf> mm_freak: I's similar to the reason (->) is infixr. :-)
14:38:58 <wavewave> mm_freak: so (f _) must be as inferrable as id.
14:39:09 <mm_freak> benmachine: as said, it's not for a real application…  i just wanted to examine how 'forall' behaves in the result type…  i'm starting to see the light =)
14:39:29 <wavewave> mm_freak : f :: Int -> (forall a. a) , in this case, f _ must be as inferrable as undefined.
14:39:33 <benmachine> mm_freak: fair enough, but it's interesting to know you have that option anyway
14:39:35 <shachaf> Think of Int -> (A::Type) -> (a::A) -- Hmph, wrong channel
14:40:08 <mm_freak> benmachine: i wouldn't know where to use that option except for type arithmetic or reification
14:40:14 <mm_freak> thanks people
14:40:23 <Xeli> quicksilver: cool, thanks :)
14:40:49 <mm_freak> i'm still not sure i understand it fully, but it's starting to make sense now
14:40:51 <benmachine> mm_freak: the best application of the Void type I can think of is, say, forever :: Monad m => m a -> m Void
14:41:15 <benmachine> mm_freak: the type there says "you can't pattern-match on the result of this function"
14:41:21 <mm_freak> benmachine: that's actually a case, where i would rather say:  Monad m => m a -> m b
14:41:23 <shachaf> benmachine: Or callCC :: ((a -> Void) -> a) -> a
14:41:26 <wavewave> mm_freak: good. hope that I also contributed to your understanding. :-) (maybe negative contribution by making confusion)
14:41:39 <shachaf> mm_freak: You can go from Void to b trivially, of course.
14:41:40 <benmachine> mm_freak: ah, but that typesig is obnoxious, here's why:
14:41:43 <mm_freak> benmachine: but yes, Void is probably better
14:41:46 <benmachine> :t forever putStrLn "hello!"
14:41:47 <lambdabot> forall b. b
14:41:55 <mm_freak> benmachine: true
14:42:18 <mm_freak> wavewave: you did =)
14:42:20 <benmachine> mm_freak: not everyone agrees with me, but I think that type-checking is not worth the convenience of main = forever foo typechecking
14:42:21 <mm_freak> positively
14:43:04 <mm_freak> benmachine: well, you can have:  main :: IO Void
14:43:10 <mm_freak> that's allowed by the standard
14:43:27 <mm_freak> and it's reasonable, too
14:43:36 <shachaf> runMain :: forall a. IO a -> IO ()
14:43:41 <benmachine> mm_freak: yes, I realised that was a bad example, but you get what I mean, right?
14:43:55 <shachaf> As opposed to runMain :: (forall a. IO a) -> IO (), which only accepts _|_-yielding mains.
14:44:25 <mm_freak> benmachine: yes…  but i guess actions with 'forever' as their last subaction would ideally also be of type IO Void
14:44:40 <mm_freak> so there is probably nothing wrong with forever :: Monad m => m a -> m Void
14:44:51 <benmachine> mm_freak: right
14:45:14 <benmachine> what would be really cool is if we could make forever x >> y not typecheck
14:45:20 <benmachine> hmm, would that be valid
14:45:24 * benmachine shrug
14:45:27 <Twey> :t let forever a = a >> forever a in a
14:45:28 <lambdabot> Expr
14:45:30 <Twey> Er
14:45:33 <mm_freak> shachaf: i really have no problems with the argument case for 'forall'
14:45:34 <Twey> :t let forever a = a >> forever a in forever
14:45:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:45:56 <shachaf> mm_freak: Well, I was pointing out how the result case is the opposite.
14:45:59 <shachaf> Or I thought I was.
14:46:06 * shachaf might be running into a burrito-problem.
14:46:35 <KirinDave> shachaf: Subtle Idiocracy jokes are available.
14:46:43 <shachaf> ?
14:46:48 <kmc> you can do it with (>>) :: m () -> m a -> m a,  and forever :: m a -> m Void
14:46:54 <KirinDave> shachaf: Burrito covers and "shit is getting emotional"
14:46:57 <mm_freak> benmachine: i don't think that's possible, because it would require 'forever' to change the 'm'
14:47:18 <coppro>  /win 7
14:47:24 <shachaf> KirinDave: Oh, right, it's a movie. I haven't seen it.
14:47:34 <benmachine> mm_freak: right, or >> would have to be more exotic than it is at the moment
14:47:39 <benmachine> mm_freak: but a man can dream
14:47:46 <mm_freak> shachaf: i think it just needs some time…  you gave enough examples today, and more would be counterproductive
14:48:21 <shachaf> One man's argument is another man's result.
14:48:23 <mm_freak> benmachine: also i think it's not necessary…  i like how haskell has a powerful and safe type system and still keeps itself on the ground of reality
14:48:31 <kmc> omg me too!
14:48:44 <shachaf> kmc++
14:48:58 <mm_freak> ok, for today i'll go with forall being a burrito =)
14:49:06 <kmc> if we keep it up somebody might think that this egghead academic theoretical nonsense is actually good for making stuff!
14:49:06 <mm_freak> at least in the result case =)
14:49:32 <dmwit> :t forever
14:49:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:49:33 * benmachine hugs kmc 
14:49:42 <shachaf> mm_freak: I meant in the sense of "once you understand something, your explanations aren't going to be that helpful for someone who misunderstood it in a different way from you"
14:49:42 <kmc> aww thanx benmachine
14:49:45 * kmc hugs back
14:49:45 <dmwit> > forever [3] >> [4]
14:49:47 <lambdabot>   *Exception: stack overflow
14:49:47 * donri ghc kmc
14:49:51 <dmwit> hum =)
14:49:55 * kmc thc self
14:50:18 <mm_freak> well, if someone comes up with a useful, nondisturbing way to express that no action must follow 'forever', i'll be happy to use it =)
14:50:22 <shachaf> kmc: edwardk took that name, by the way.
14:50:29 <kmc> :(
14:50:31 <kmc> i saw
14:50:42 <kmc> is «(>>) :: m () -> m a -> m a» that disruptive?
14:50:52 <shachaf> I think so.
14:50:59 <kmc> if you like the "discarded result in 'do'" warning then you should like that function
14:51:03 <shachaf> kmc: I think it's about as disruptive as requiring _ <- do-notation.
14:51:04 <kmc> s/function/type for that function/
14:51:08 <elliott> If I use Data.ByteString.Char8.putStrLn, do I still need to put the handle into binary mode to print invalid UTF?
14:51:09 <kmc> i'm fine with that one
14:51:22 <kmc> Char8 :(
14:51:24 <shachaf> If you use Data.ByteString.Char8.putStrLn, you're racist.
14:51:29 <shachaf> It's the truth.
14:51:39 <kmc> i don't know why Char8 IO would do anything differently
14:51:45 <shachaf> kmc: Maybe it's the newline?
14:51:48 <kmc> but i try not to use Char8
14:51:59 <mm_freak> kmc: i use (>>) for a lot of non-() things, and it would be inconvenient to have to apply (() <$) to all of them
14:52:06 <shachaf> No, regular ByteString has putStrLn
14:52:08 <kmc> what if (() <$) is named 'void'
14:52:09 <shachaf> Weird.
14:52:12 <elliott> shachaf: It's deprecated.
14:52:17 <shachaf> kmc: It is!
14:52:20 <mm_freak> it's not that all meaningful results are also useful or relevant
14:52:23 <benmachine> :t void
14:52:24 <lambdabot> Not in scope: `void'
14:52:25 <kmc> the name "putStr" is already wrong, might as well make it wronger
14:52:30 <elliott> kmc: Well, I could just print the ten byte after it.
14:52:32 <dmwit> Half of the reason to use (>>) is that it discards the result for you.
14:52:36 <shachaf> kmc: What's wrong with it?
14:52:41 <elliott> kmc: But that seems worse than using the pre-existing thing.
14:52:42 <shachaf> It puts a (byte) string.
14:52:52 <kmc> meh
14:52:56 <elliott> kmc: But yeah, no, Data.ByteString.putStrLn tells you to use the Char8 version.
14:52:59 <elliott> kmc: Which does no Char8 magic.
14:53:05 <elliott> kmc: It's just because '\n' is charset-dependent.
14:53:05 <solidsnack> Strings were made of bytes long before they were made of characters :)
14:53:07 <elliott> I guess?
14:53:15 <shachaf> elliott: What if it ends with a half-UTF8-sequence?
14:53:17 <elliott> So it assumes ASCII.
14:53:27 <shachaf> Or, wait.
14:53:32 * shachaf never mind.
14:53:45 <elliott> You never mind?
14:53:58 <shachaf> I never mind.
14:53:59 <dmwit> I've never heard of anybody ever assuming ASCII. latin-1 at worst
14:54:06 <shachaf> Latin-1. :-(
14:54:11 <shachaf> ISO-8859-8 is the true way.
14:54:13 <elliott> dmwit: Well, yeah.
14:54:14 <shachaf> Or CP437
14:54:17 <dmwit> Some people don't even realize that ASCII characters always have a zero top bit.
14:54:22 <elliott> dmwit: But the value of '\n' isn't very bytestringy.
14:54:24 <shachaf> dmwit: They don't!
14:54:33 <elliott> dmwit: To print a plain ten byte as that is definitely Char8y.
14:54:36 <cvic_> Kiss my ascii
14:54:57 <solidsnack> elliott: You could just hPut.
14:55:02 <solidsnack> s/just/just use/
14:55:03 <cvic_> > hPut
14:55:04 <lambdabot>   Not in scope: `hPut'
14:55:13 <dmwit> shachaf: ?
14:55:21 <elliott> solidsnack: I need the ten byte.
14:55:22 <cvic_> I still don't know how to use lambdabot
14:55:34 <solidsnack> Oh, hmm.
14:55:36 <cvic_> Hoogle
14:55:37 <shachaf> dmwit: ASCII is a seven-bit encoding.
14:55:46 <cvic_> @hoogle: hPut
14:55:47 <lambdabot> Maybe you meant: hoogle hoogle+
14:55:52 <dmwit> shachaf: heh
14:55:53 <shachaf> s/encoding/character set/
14:55:54 <cvic_> Hoogle+
14:55:57 <cvic_> The social Hoogle
14:56:11 <cvic_> Google Wave was good
14:56:16 <solidsnack> I find this business of handles with text and binary mode to be a little puzzling, myself. I mean, that's Windows stuff, right?
14:56:19 <shachaf> dmwit: If you extend it to eight bits, you might as well extend Latin-1 to nine bits and say that it always has a top zero bit.
14:56:20 <dmwit> shachaf: I didn't even realize that ASCII was considered a character set, not an encoding.
14:56:32 <dmwit> shachaf: Does anybody do anything other than the embedding encoding?
14:56:43 <shachaf> Sure.
14:56:45 <shachaf> I guess.
14:56:52 * shachaf can't think of a case.
14:56:58 <dmwit> That's a confidence-inspiring answer.
14:57:03 <shachaf> Unless you count the ASCII subset of UTF-16 or something.
14:57:25 <elliott> solidsnack: It's about whether standard functions try to decode the data or not.
14:57:30 <elliott> solidsnack: GHC likes Unicode a lot.
14:58:07 <solidsnack> elliott: Yes, that's a new wrinkle. But there's also newline normalization, in classic Windows style.
14:58:27 <elliott> It's not much of a wrinkle.
14:58:35 <elliott> GHC is about text files by default; you have to tell it if you're not doing Unicode.
14:59:09 <solidsnack> There's probably a better way to describe it than "wrinkle".
14:59:34 <solidsnack> It is so sad about having to tell it you're not doing Unicode.
15:00:11 <solidsnack> Well, it is for me, since I almost never am doing Unicode...
15:00:18 <solidsnack> ...maybe for other it's helpful.
15:00:24 <solidsnack> s/other/others/
15:02:23 <elliott> My code:
15:02:24 <elliott>   forever $ readChan lineChan >>= B8.putStrLn
15:02:25 <elliott> :t forever
15:02:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:02:36 <elliott> What GHC thinks:
15:02:36 <elliott>     Warning: A do-notation statement discarded a result of type GHC.Prim.Any.
15:02:36 <elliott>              Suppress this warning by saying "_ <- ($)
15:02:36 <elliott>                                                      forever (>>=) readChan lineChan B8.putStrLn",
15:02:36 <elliott> My mind is boggled.
15:02:47 <benmachine> elliott: I reckon you could get that considered a bug
15:02:59 <elliott> I can't dec‪ide whether to (a) append ":: IO ()", (b) prepend "_ <-" or (c) ignore it.
15:03:02 <benmachine> in fact, I'm sure of it
15:03:16 <benmachine> (d) submit it to trac and get it fixed for the next verision :D
15:03:19 <benmachine> er, version
15:03:21 <elliott> benmachine: Hmm... Shouldn't that statement actually be ambiguous?
15:03:24 <ion> Also, void
15:03:29 <ion> @hoogle void
15:03:29 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
15:03:30 <elliott> I would expect to have to clarify which "b" I want.
15:03:35 <benmachine> elliott: ambiguous types are only a problem if they have class constraints
15:03:37 <elliott> In forever's return value.
15:03:41 <elliott> benmachine: Yeah, that's true.
15:03:44 <ion> Hmm. Wasn’t that in Control.Monad before? I’m probably wrong.
15:03:56 <benmachine> ion: it's now in somewhere sensible
15:04:10 <ion> @type Control.Monad.void
15:04:11 <lambdabot> Not in scope: `Control.Monad.void'
15:04:13 <benmachine> yeah, Control.Monad
15:04:16 <benmachine> but quite recently
15:04:56 <solidsnack> @type Control.Monad.Void
15:04:57 <lambdabot>     Not in scope: data constructor `Control.Monad.Void'
15:05:09 <elliott> ion: It is.
15:05:12 <elliott> lambdabot is just on GHC version Old.
15:05:29 <shachaf> GHC version Old is great.
15:05:40 <shachaf> It has lovely bugs like id runST (return 5)
15:06:01 <ion> forever_ :: IO a -> IO (), anyone? ;-)
15:06:18 <ion> The version of forever that discards the result value!
15:06:26 <shachaf> ion++
15:06:39 <elliott> ion: forever :: IO () -> IO ()
15:06:42 <elliott> It should never have been generalised in the first place.
15:07:04 <elliott> I _suppose_ you can make a case for -> IO a because it never returns, but I don't think anyone actually uses that in practice.
15:07:55 <monochrom> IO a -> IO () is easier to use
15:08:18 <elliott> Hmm, does stdout have a guaranteed default buffering mode?
15:08:25 <monochrom> IO a -> IO b may be the easiest to use
15:08:38 <shachaf> monochrom: forall a. a is even easier to use.
15:09:00 <monochrom> no, the context is what is the best type for forever
15:09:20 <shachaf> forever :: forall a. a is very easy to use.
15:09:26 <shachaf> Perhaps not completely correct.
15:09:32 <shachaf> It's a trade-off
15:09:48 <monochrom> under the constraint of completely correct
15:10:13 <monochrom> stdout is line-buffered if tty, block-buffered if not
15:10:22 <elliott> monochrom: ah, thanks
15:10:44 <elliott> line-buffering still works for binary files too, right?
15:11:01 <shachaf> elliott: Racist!
15:11:24 * hackagebot arithmoi 0.1.0.0 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.1.0.0 (DanielFischer)
15:11:34 <monochrom> yes
15:11:45 <elliott> right
15:12:11 <elliott> I like how openFile doesn't document the default buffering :/
15:12:16 <elliott> I suppose it's block-based
15:13:03 <hpc> elliott: i expect it would be block buffering
15:13:21 <hpc> and stdin/out default to line buffered
15:13:35 <hpc> same as C, afaik
15:14:39 <monochrom> in the section "buffering operations", there is a lot of "implementation-dependent" but at the end it admits "For most implementations, physical files will normally be block-buffered and terminals will normally be line-buffered."
15:16:06 <elliott> monochrom: heh
15:16:08 <monochrom> openFile is not always the physical file case because maybe you openFile "/dev/tty" and maybe it is smart enough to ask unix "istty?" and line-buffer it
15:17:23 * benmachine never liked the ability to ask if things were a tty
15:17:36 <benmachine> well, more specifically, I don't like how hard it is to override
15:18:06 <elliott> benmachine: | cat :P
15:18:16 <benmachine> elliott: sure, and the other way?
15:18:33 <Clint> ssh -t
15:18:42 <monochrom> not sure why anyone would override it, but you can always choose your own buffering
15:18:57 <benmachine> Clint: that's devious :P
15:19:01 <benmachine> but I like it
15:19:03 * benmachine makes notes
15:19:10 * benmachine doesn't actually have sshd running though
15:19:39 <elliott> benmachine: The other way? </dev/stdin
15:19:59 <benmachine> elliott: I mean, how can you trick a program to think it's reading from a tty when it isn't
15:20:06 <benmachine> *into thinking
15:20:12 <elliott> Ah.
15:20:15 <elliott> benmachine: ptys :P
15:20:30 <benmachine> oh
15:20:34 <elliott> It would be cool to have a fakepty '...' that forward stdin to the program named but through a pty
15:20:40 <elliott> But that's like a ten-liner I think
15:20:41 <benmachine> mm
15:20:45 <benmachine> fiiine
15:20:53 <elliott> benmachine: Hey, I hate it too
15:20:58 <benmachine> :)
15:21:07 <waveman> Anyone here using Haskell for a real-world useful project?
15:21:08 * benmachine feels validated
15:21:30 <elliott> waveman: Nobody, we're just a bunch of amateurs.
15:22:03 <Clint> elliott: there's a zsh module that'll let you do that
15:22:08 <Cale> waveman: We're using it for a game at iPwn studios :)
15:22:42 <cvic_> haha, nice. I saw your site earlier.
15:23:09 <cvic_> Also, http://joyridelabs.de/game/
15:23:16 <cvic_> Haskell + game dev
15:23:51 <waveman> Cale: are you using it for the AI, or something else?
15:23:51 <cvic_> A very awesome combo
15:24:05 <Cale> waveman: Pretty much everything, including the AI
15:24:17 <shachaf> Cale: I don't think Haskell has enough parentheses for AI.
15:24:53 <cvic_> Maybe they're using a Lisp interpreter made in Haskell
15:25:12 <Cale> waveman: There's some lower-level rendering stuff in C++ (because GC on older iPhones can take up to 300ms), but that may move to Haskell as well, depending on how things go.
15:25:38 <Cale> At least, parts of it.
15:25:51 <cvic_> What libraries are you mainly using?
15:26:31 <c_wraith> Ugh.  There's no Map function for modifying a value and returning the old one?
15:26:53 <Cale> We have our own in-house Arrow-based FRP system. There are a lot of libraries which are used in small ways. We get a bunch of use out of fclabels...
15:27:21 <cvic_> So mostly in-house stuff
15:27:32 <shachaf> Cale: *LookupWithKey?
15:27:40 <shachaf> s/Cale/c_wraith/
15:27:43 <elliott> c_wraith: Map's modification functions are a bit annoyingly simple :(
15:27:52 <elliott> c_wraith: There's not even anything to get a lens out.
15:28:10 <Cale> cvic_: Well... yeah, I guess. Though our dependency list is really long anyway :)
15:28:24 <ddarius> @hoogle alter
15:28:24 <lambdabot> Data.IntMap alter :: (Maybe a -> Maybe a) -> Int -> IntMap a -> IntMap a
15:28:25 <lambdabot> Data.Map alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
15:28:25 <lambdabot> Control.Applicative class Applicative f => Alternative f
15:28:26 <cvic_> Don't need to reinvent the wheel
15:28:28 <cvic_> Cool
15:28:35 <Cale> cvic_: The stuff which is directly relevant to game dev is mostly ours :)
15:29:01 <shachaf> @hoogle LookupWithKey
15:29:02 <lambdabot> Data.IntMap insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
15:29:02 <lambdabot> Data.Map insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
15:29:02 <lambdabot> Data.IntMap updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a, IntMap a)
15:29:12 <cvic_> this way you have an advantage your competitors don't understand
15:29:20 <c_wraith> I'm not cale. :P
15:29:28 <shachaf> c_wraith: Hence the substitution.
15:30:03 <c_wraith> shachaf: all return the *new* value
15:30:10 <shachaf> What?
15:30:53 <shachaf> Oh.
15:30:55 <shachaf> Weird.
15:30:57 <Cale> insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
15:30:57 <Cale> O(log n). Combines insert operation with old value retrieval. The expression (insertLookupWithKey f k x map) is a pair where the first element is equal to (lookup k map) and the second element equal to (insertWithKey f k x map).
15:31:07 * shachaf didn't even check.
15:31:29 <c_wraith> oh.  That does look potentially right.
15:31:30 <shachaf> Cale: That seems like it returns the old value.
15:31:36 <Cale> It does.
15:32:23 <c_wraith> yeah, that looks like it should do.  In this case.
15:32:34 <shachaf> "You win this time, Data.Map!"
15:32:59 <ddarius> :t (Data.Map.!)
15:33:00 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
15:33:24 <Twey> Yeah
15:33:40 <shachaf> let Just v = M.lookup k m
15:37:40 <hpaste> csoroz pasted “Happy Numbers” at http://hpaste.org/52764
15:48:28 <kmc> ok i've been bugging people all day but:  any last comments on http://ugcs.net/~keegan/safe-globals/ before i upload to hackage?
15:49:34 <elliott> kmc: aww, I was wondering how you managed that, but you cheated by using TH :P
15:49:59 <shachaf> elliott: Would cheating using CPP make you happier?
15:50:06 <elliott> shachaf: No :P
15:50:17 <blackdog> i'm kind of looking forward to the use of TH being considered utterly commonplace
15:50:29 <shachaf> kmc: You could make a quasiquoter that let you specify the actual type!
15:50:40 <ddarius> blackdog: That won't be for a while yet, and for good reason.
15:50:45 <elliott> shachaf: declare [d| foo :: TVar |]?
15:51:03 <shachaf> Right, something like that.
15:51:03 <elliott> declare [d| foo :: IORef <- initialValue |]? :-P
15:51:09 <shachaf> Do you even need the declare?
15:51:22 <shachaf> Well, OK, initial values exist, I guess.
15:51:44 <ddarius> kmc: Do you handle mutual recursion?
15:52:10 <blackdog> ddarius: it depends which subcommunity you're talking about
15:52:17 <blackdog> in yesod it's everywhere
15:53:06 <kmc> hmm that would be fancy
15:53:08 <kmc> ddarius, uh, I think so
15:53:18 <kmc> it's just a macro for the normal unsafePerformIO hack
15:53:23 <hpaste> csoroz pasted “Happy Numbers (memoized)” at http://hpaste.org/52765
15:54:00 <elliott> <shachaf> Do you even need the declare?
15:54:11 <elliott> shachaf: Oh, duh.
15:54:17 <elliott> [declare| foo :: IORef <- initialValue |]
15:54:18 <elliott> would work.
15:54:21 <elliott> Even if it is misleading.
15:54:27 <elliott> Perhaps (:=).
15:54:36 <kmc> that would be a quasiquoter and would need haskell-src-meta or such
15:55:04 <elliott> kmc: You could do it with [d||] if you're OK with overloading syntax.
15:57:48 <hpaste> csoroz annotated “Happy Numbers” with “Happy Numbers (annotation)” at http://hpaste.org/52764#a52766
15:58:19 <benmachine> kmc: I kind of dislike how you use CPP only to throw an #error
15:58:47 <kmc> me too
15:58:57 <benmachine> it causes faff when using your code with ghci, for example
15:58:58 <kmc> is there a better way to say "this library is GHC-only"?
15:59:00 <kmc> oh really
15:59:03 <benmachine> well
15:59:04 <kmc> i hadn't noticed that
15:59:07 <benmachine> I might be wrong
15:59:29 <benmachine> it might be just that the modules I try to use it with don't specify LANGUAGE properly
15:59:32 * benmachine investigates
16:00:36 <benmachine> kmc: hmm, I think I'm getting confused with using CPP with cabal macros
16:00:40 <kmc> ah yes
16:00:43 <kmc> that will break in ghci
16:00:45 <benmachine> my stuff that uses MIN_VERSION gets upset
16:00:51 <benmachine> but you're probably fine
16:00:54 <benmachine> it's still a bit icky :P
16:01:12 <benmachine> you could do like, if !impl(ghc) Buildable: False
16:01:17 <kmc> when i'm testing cabalized projects in ghci i do "cabal build; cd dist/; ghci -package-conf package.conf.inplace"
16:01:29 <kmc> it's important not to do it from the top directory, if your module Foo.Bar is in Foo/Bar.hs
16:01:39 <kmc> 'cause your imports will still use the interpreter
16:01:41 <benmachine> anyway, it's conceivable that a non-GHC compiler could work, isn't it?
16:01:52 <benmachine> or do you do it like it is because you can't rely on the behaviour of non-GHC
16:01:55 <kmc> it's conceivable, but I'm not willing to guarantee safety
16:02:02 <kmc> since as is we depend on details of the GHC inliner etc
16:02:17 <kmc> arguing that it's safe on GHC is dodgy enough
16:02:23 <kmc> my copout is like "everyone else does it"
16:02:30 <benmachine> heh
16:02:39 <benmachine> well, fair enough
16:02:44 <kmc> and if you use my library, you don't have to rewrite your code when GHC 9 requires a new hack
16:02:50 <benmachine> sure
16:03:03 <benmachine> oh
16:03:16 <benmachine> other problem with CPP is it doesn't mix with haskell-src-exts
16:03:17 <kmc> maybe I should even use #if __GLASGOW_HASKELL__ < 800
16:03:19 <rwbarton> what if you add a fake dependency on the ghc package
16:03:19 <kmc> mm
16:03:30 <benmachine> which prevents hlint and sourcegraph and similar being used on it
16:03:55 <elliott> rwbarton: That'll break Hackage docs
16:04:01 <benmachine> rwbarton's idea is reasonable too, although I'd use impl for that, if possible
16:04:06 <kmc> yeah
16:04:17 <kmc> i didn't find a nice way in cabal to do like "if ! impl(ghc) fail"
16:04:27 * kmc wonders if dcoutts knows
16:04:28 <benmachine> oh
16:04:28 <rwbarton> break how?
16:04:41 <benmachine> elliott: note that packages like http://hackage.haskell.org/package/vacuum depend on ghc-prim but still have docs
16:04:47 <elliott> benmachine: oh, huh, right
16:04:50 <kmc> before i had something like "if impl(ghc)  <entire library stanza>"
16:04:53 <elliott> because the building machine still has the ghc package
16:04:54 <kmc> but then Hackage shows no deps etc
16:05:06 <dcoutts> kmc: yeah, that'd be nice
16:05:12 <benmachine> kmc: if !impl(ghc) build-depends: sorryghconly == 0
16:05:17 <benmachine> that's not evil at all :P
16:05:39 <dcoutts> kmc: it'd have a reasonable meaning in the logic semantics for flags
16:05:55 <sm> how exactly can I pattern match on a UserInterrupt exception in a SomeException catch handler ?
16:06:10 <sm> (case (e::SomeException) of
16:06:19 <sm>   (SomeException UserInterrupt) -> ... no good
16:06:34 <dcoutts> sm: no, pattern match at the specific type of the exception
16:06:54 <benmachine> you could use fromException, couldn't you?
16:07:01 * benmachine doesn't claim whether it's the right thing, though
16:07:03 <dcoutts> but that'd be missing the whole point
16:07:07 <benmachine> heh
16:07:08 <benmachine> fair enough
16:07:08 <dcoutts> of the exception system
16:07:11 <sm> dcoutts: you mean use the pattern AsyncException -> ...
16:07:12 <sm> ?
16:07:24 <kmc> case (e :: SomeException) of _ | Just (ee :: UserException) <- fromException e -> ...;  | Just (ee :: OtherThing) <- fromException e  -> ...
16:07:28 <kmc> patten guards
16:07:32 <kmc> or something similar with ViewPatterns
16:07:37 <dcoutts> sm: well, AsyncException is the type, not the constructor, but yeah that's the idea
16:07:39 <kmc> or something uglier but similar with neither
16:07:39 <sm> aha...
16:07:52 <benmachine> kmc: and also scopedtypevariables, for those pattern signature
16:07:52 <benmachine> s
16:07:52 <kmc> yeah
16:07:52 <shachaf> ScopedTypeVariables?
16:07:52 <shachaf> Yes.
16:08:01 <shachaf> I think it's silly that that syntax requires ScopedTypeVariables.
16:08:04 <benmachine> yes
16:08:06 <benmachine> I too
16:08:08 <shachaf> The two are mostly disjoint.
16:08:17 <dcoutts> sm: e.g. `catch` \e -> case e of UserInterrupt -> ...; _ -> throw e;
16:08:40 <dcoutts> sm: you need to deal with the other AsyncExceptions, eg by rethrowing
16:08:44 <benmachine> it's even sillier because PatternSignatures *did* exist at one point
16:08:47 <benmachine> but is now deprecated
16:08:50 <Igloo> You generally shouldn't use "SomeException". The "catches" function takes a list of handlers of different types
16:09:02 <dcoutts> or by using catchJust to select out the one you want
16:09:33 <aavogt> @type fromException
16:09:34 <lambdabot> Not in scope: `fromException'
16:09:40 <aavogt> @type Control.Exception.fromException
16:09:41 <lambdabot> forall e. (GHC.Exception.Exception e) => GHC.Exception.SomeException -> Maybe e
16:09:42 <sm> exception handling is tricky
16:10:09 <sm> why not use SomeException, if I really do want to say "handle everything" ?
16:10:10 <aavogt> so kmc's case can be written as      case () of  ....
16:10:22 <Igloo> sm: You very rarely should "handle everything"
16:10:52 <Igloo> sm: e.g. do you really want to handle the user pressing ^C?
16:11:24 <dcoutts> well in this case he specifically does want to handle ^C apparently
16:11:43 <dcoutts> but almost certainly does not want to try and handle stack overflow or the other async exceptions...
16:11:53 <sm> I wanted to show a little different exit message for ^C, ie not ERROR
16:12:14 <Igloo> Oh, OK; I didn't read the context
16:12:23 <sm> and I do want to handle stack overflow and async exceptions :)
16:12:25 <dcoutts> ^C doesn't report an error I thought
16:12:51 <sm> more context: I'm in hackagebot, and wanting to handle any and all strange terminations of subthreads
16:12:54 <Igloo> But generally people "handle everything" when really they want to handle "any IO exception when reading a file" or something
16:12:56 <dcoutts> I mean when the UserInterrupt propagates to main, then no error message is printed
16:28:25 <hpaste> sm pasted “exception catching troubles” at http://hpaste.org/52767
16:30:55 <davv3> heya, can someone recommend any application/game written in haskell? im using xmonad and am thoroughly impressed with its stability and stuff.
16:32:05 <sm> davv3: nikki and the robots, see the games page on the wiki for more
16:32:44 <sm> so in my paste above, how come the try on line 5 doesn't catch a failure in connect ? it never reaches line 19
16:33:59 <davv3> sm: great. which wiki?
16:34:30 <sm> and I read about the difference between try and catch, so I tried to use catch instead. How come ghc is complaining about line 39 with "parse error (possibly incorrect indentation)" ?
16:34:46 <sm> davv3: http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
16:35:44 <monochrom> because the ) is aligned with the (
16:37:08 <sm> right you are, thanks monochrom. And when that's fixed, how come it complains about the closing parenthesis in (\e::SomeException) ?
16:37:22 <rwbarton> > maximum []
16:37:23 <lambdabot>   *Exception: Prelude.maximum: empty list
16:37:48 <monochrom> \ (e::SomeException) ->
16:38:24 <sm> oh I see.. yes, thanks again. Fatigue setting in
16:39:03 <monochrom> I wonder which "try" you're using
16:39:59 <sm> Control.Exception.try
16:41:05 <monochrom> I think I see. UserInterrupt forces the exception type to be AsyncException. this type does not include socket exceptions (or any IO exceptions)
16:41:07 <sm> I also wondered if having overlapping exception handlers like that is the problem. There's something similar in the haddock
16:41:52 <sm> interesting
16:41:55 <monochrom> it is an unfair comparison to the "catch" version because there you say "SomeException" to force the most general type
16:43:45 <sm> monochrom: excellent call
16:46:59 <hpaste> sm annotated “exception catching troubles” with “almost there” at http://hpaste.org/52767#a52768
16:47:30 * sm rereads the pattern matching advice
16:52:05 <incluye> is the emphasis on the second syllable in "haskell"
16:52:08 <monochrom> Left e -> case fromException e of { Just UserInterrupt -> (False, "user interrupt"); _ -> (True, show e) }
16:52:35 <monochrom> the use of "fromException" forces e :: SomeException
16:52:52 <incluye> "haskle"? o_o
16:53:01 <monochrom> the use of "Just Userinterrupt" forces fromException e :: Maybe AsynException
16:53:50 <monochrom> if you have pattern guards, there is a shorter way to write it, too :)
16:54:40 <sm> monochrom: if it's clearer/easier, I'd love to see it
16:55:31 <sm> Left (e::SomeException) -> case e ofLeft (e::SomeException) ->
16:55:49 <sm> this ^^ is not equivalent to what you just wrote ?
16:56:01 <monochrom> no
16:57:23 <monochrom> Left e | Just UserInterrupt <- fromException e -> (False, "user interrupt")
16:57:37 <monochrom> Left e -> (True, show e)
16:59:12 <sm> monochrom: ohh you're blowing my mind.. and it works
16:59:51 <monochrom> I want e :: SomeException so I don't miss any exception
17:00:28 <monochrom> but then I need fromException e to specialize it back to AsyncException (if applicable) so I can test against UserInterrupt
17:01:37 <sm> that is terrific. So the | is a guard.. you can stick one of those after any pattern in a case expression I guess
17:01:54 <monochrom> if the exception is an I/O exception for example, my "fromException e" there will be Nothing
17:02:39 <sm> but it really surprises me that you can write <- fromException e there. Is that more pattern matching syntax ?
17:02:50 <elliott> pattern guard
17:02:55 * sm manuals
17:02:55 <monochrom> of course, even if the exception is an AsyncException, it may still be a ThreadKilled rather than UserInterrupt, and you still want to go (True, show e)
17:04:17 <monochrom> damn, it is a standard now, in Haskell 2010, no wonder you don't need any {-# LANGUAGE blah #-}
17:04:27 <monochrom> well, all the better
17:04:43 * monochrom keeps forgetting what's new in Haskell 2010
17:06:08 <sm> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards . holy mackerel
17:06:30 <sm> I suppose this might not be 6.12 compatible
17:06:40 <monochrom> you have "pattern | guard", "pattern" expands to "Left e", "guard" expands to either boolean expression (like "x>0") or more pattern matching "pattern <- expression", which I expand to "Just UserInterrupt <- fromException e"
17:07:06 <monochrom> right, in 6.12 you need {-# LANGUAGE PatternGuards #-} or something
17:07:12 <sm> ah cool
17:07:30 <monochrom> or go back to nested cases :)
17:08:17 <sm> no way, going to use this as much as possible :)
17:08:39 <monochrom> we put pattern guards in guards so you can pattern-match while you pattern-match
17:08:47 <sm> monochrom, all: thanks again, and yay reliable connection handling
17:08:57 <monochrom> \∩/
17:08:58 <aavogt> it's supported in rather old ghcs, just you used to get a warning that it wasn't standard
17:08:59 <sbahra> dawg
17:09:23 <aavogt> going back to 6.6 at least
17:12:28 <amtal> I'm giving FRP another try. Is NetWire the current state-of-the-art library?
17:14:28 <elliott> amtal: I like reactive-banana, but it's designed to hook into event-based GUI/graphical frameworks so if what you want doesn't fit that then it's likely not applicable
17:14:36 <kmc> davv3, 'pandoc' is a wonderful piece of useful practical software written in Haskell
17:15:03 <anacrolix> hi
17:15:05 <kmc> it's also in the area of Haskell's greatest strengths -- converting between different structured data formats
17:15:17 <kmc> whereas xmonad is good for less obvious reasons, in a domain where Haskell is less obviously the right tool
17:15:26 <kmc> i use both on a daily basis
17:16:07 <davv3> kmc: looks nice! i do a bit of LaTeX so
17:16:15 <davv3> may find some use for it
17:16:18 <anacrolix> i've just written my first useful haskell program, it's a rewrite of an existing python program, but it performs very poorly. would anyone take a look and help me improve it (both the way i use the language, and performance)? http://pastebin.com/1SkFidWc
17:16:20 <mauke> The paste 1SkFidWc has been copied to http://hpaste.org/52769
17:17:05 <anacrolix> hm hpaste already has some tips
17:17:11 <elliott> anacrolix: those aren't performance tips
17:17:25 <kmc> i write slides and blog posts in Markdown
17:17:34 <kmc> which has a nice compact syntax
17:17:48 <kmc> pandoc helps me produce HTML with syntax highlighting, or nice PDF slides via LaTeX and Beamer
17:17:56 <anacrolix> yeah i know, but i'm also learning at the same time :)
17:18:20 <kmc> it's fun to write a blog post whose Markdown source is also a literate Haskell program
17:18:25 <anacrolix> is it idiomatic?
17:18:41 <kmc> http://hackage.haskell.org/package/BlogLiterately is another package for  this
17:21:20 <hpaste> tsuraan pasted “Fighting Lazy IORef” at http://hpaste.org/52770
17:21:48 <tsuraan> I'm wondering about how to make a modifyIORef be strict in the update function's result
17:23:18 <tsuraan> In the example above, my PC runs the "strict" version in 23ms, and the "lazy" version in 30ms
17:24:03 <tsuraan> I think this is due to lazyness, since that's the only different I see between the two functions
17:24:20 <kmc> i don't think you can do it with modifyIORef
17:24:25 <kmc> it's defined thus: modifyIORef ref f = readIORef ref >>= writeIORef ref . f
17:24:30 <kmc> so you can just redefine that with strictness
17:24:41 <kmc> atomicModifyIORef can't be strict either, and there's a better reason for that
17:24:54 <elliott> kmc: Really?
17:25:01 <kmc> really which?
17:25:04 <tsuraan> heh, I didn't even think to read the source
17:25:11 <elliott> kmc: Well, I don't understand why atomicModifyIORef couldn't be strict. It's done with CAS, right?
17:25:16 <tsuraan> so my "strict" update function really is basically what I need to do
17:25:20 <elliott> kmc: Hmm, right
17:25:27 <kmc> right, they want to implement it with a lockless atomic pointer swap
17:25:30 <elliott> kmc: I guess it has no way to jump into the runtime "during" that
17:25:39 <kmc> and you can swap the current contents for a pointer to a thunk
17:25:45 <elliott> kmc: I was thinking you could just read the variable first and apply f to it and seq it ... but then I realised that would just be unatomicModifyIORef :-0
17:25:47 <kmc> but you can't do arbitrary Haskell computation in the middle, atomically
17:25:47 <elliott> s/0/)/
17:25:53 <kmc> *nod*
17:26:05 <kmc> if you want computation inside the critical section, then use MVar or TVar or such
17:26:27 <tsuraan> that works
17:27:04 <kmc> anyway this means atomicModifyIORef can perform much better than MVar etc
17:27:07 <tsuraan> I was thinking that there was somehow a way to do (IORef !Int), but that's not valid.  I thought I was missing some cool trick, but I guess not
17:27:27 <anacrolix> can someone help me make this more idiomatic? http://hpaste.org/52769
17:27:38 <kmc> there was some Simon Marlow presentation (?) where they benchmark a bunch of fancy mutable containers and the best one was.... a functional container inside IORef with atomicModify
17:27:45 <kmc> i forgot the exact details but it was funny and surprising
17:28:14 <kmc> then you think about concurrency more and persistent data structures + atomic pointer swap starts to sound like a really really good idea
17:29:23 <kmc> these things get really subtle though
17:30:01 <kmc> you can make your algorithm lockless, and then you can make the lockless stuff wait-free too... and you'll still have synchronization overhead from the implicit bus locking of atomic operations
17:30:31 <kmc> and even if you get rid of atomic ops, you still have synchronization overhead from the cache coherence protocol
17:30:49 <c_wraith> if you use atomicModifyIORef, and want to prevent thunks from building up, you use sharing to force evaluation after the atomicModifyIORef completes
17:31:02 <kmc> ah yes, that's a good idea
17:31:04 <c_wraith> since atomicModifyIORef has two results, you can pass the value stored back in the IORef back as part of the other one, and then evaluate it
17:31:06 <kmc> (or even in a spark)
17:31:18 <elliott> c_wraith: oh, that's clever
17:31:44 <elliott> atomicallyModifyIORef r (\x -> let x' = f x; (x',x')) >>= evaluate
17:31:58 <kmc> >>= evaluate . flip par () -- !
17:33:34 <elliott> kmc: Surely strategies make that nicer.
17:34:06 <elliott> Hmm, I guess not.
17:36:05 <elliott> putStrLn and friends aren't thread-safe, right? I swear I've seen interleaving of lines printed simultaneously from multiple threads before.
17:36:51 <tsuraan> not sure if Snap uses putStrLn at all, but it certainly can interleave lines.  I guess they fixed that in 0.5.5 though
17:37:04 <kmc> they can definitely interleave
17:37:09 <kmc> sometimes buffering prevents it, sometimes not
17:37:20 <kmc> (that might still count as "thread-safe" depending on your application)
17:37:43 <elliott> Right.
17:37:52 <elliott> I'll stick to my Chan solution, then.
17:38:00 <kmc> logger = do chan <- newChan; forkIO (forever (readChan chan >>= putStrLn)); return (writeChan chan)
17:38:05 <kmc> yeah
17:38:34 <kmc> this is my go-to example for arguing that concurrency and higher-order programming are a nice match
17:38:47 <kmc> 'cause the user doesn't even see a Chan
17:40:09 <anacrolix> can someone tell me if this is idiomatic? http://hpaste.org/52769
17:40:30 <elliott> anacrolix: not really
17:40:45 <elliott> anacrolix: also, are you /sure/ you want to be doing equality on floating point numbers there?
17:41:06 <anacrolix> yeah i wasn't sure. the string comes in as "0" i need to ignore these ones
17:41:20 <anacrolix> surely you can compare a floating point to 0.0 tho
17:41:26 <elliott> probably you should do it based on the string instead, and yes you can but you probably don't want to
17:41:40 <anacrolix> how else can i improve it?
17:41:44 <anacrolix> okay i'll change that, thx
17:42:13 <elliott> anacrolix: do you really discard the first element of every row?
17:42:19 <elliott> as in, do you really want to?
17:42:21 <anacrolix> no, the first row of every file
17:42:25 <anacrolix> ah yes
17:42:26 <anacrolix> that too
17:42:29 <anacrolix> i do, yes
17:43:27 <hpaste> elliott annotated “first hs program” with “first hs program (annotation)” at http://hpaste.org/52769#a52771
17:43:38 <elliott> anacrolix: There's a slight cleanup; it won't be any faster and it's still not very good, but it's a bit better
17:43:44 <elliott> oh, wait, there's another obvious improvement
17:44:03 <rwbarton> how about rather than let t1:t2:[] = ... $ take 2 $ tail $ head rows, write let _:t1:t2:_ = ... $ head rows
17:44:05 <hpaste> elliott annotated “first hs program” with “first hs program (annotation) (annotation)” at http://hpaste.org/52769#a52772
17:44:25 <anacrolix> i didn't think to half of that stuff like that
17:44:30 <anacrolix> thx! learning heaps from this version
17:44:36 <elliott> anacrolix: that program looks fairly decent, though csVals is doing some redundant computation
17:45:08 <elliott> :t elemIndex
17:45:09 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
17:45:48 * elliott tries to fix csVals
17:46:37 <hpaste> elliott annotated “first hs program” with “first hs program (annotation) (annotation) (annotation)” at http://hpaste.org/52769#a52773
17:46:47 <elliott> anacrolix: there, that looks pretty good to me :-)
17:46:55 <elliott> oh, duh, of course you can use print too
17:47:08 <hpaste> elliott annotated “first hs program” with “first hs program (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/52769#a52774
17:47:12 <elliott> There, I think I'm done spamming :-)
17:47:34 <rwbarton> Wonder why hlint reported two copies of that Error about print.
17:47:50 <elliott> rwbarton: If you click, one is about replacing the function, and one is about replacing its application
17:48:00 <elliott> Kinda redundant :P
17:48:04 <rwbarton> ah
17:48:11 <anacrolix> so how do you decide when to use (.) and when to use ($)
17:48:23 <elliott> anacrolix: only use one $ in a chain, basically
17:48:27 <elliott> f $ g $ x should be f . g $ x
17:48:29 <anacrolix> and is there some advantage to the former? it seems to be preferred whenever possible
17:48:41 <elliott> anacrolix: a lot of people think ($) should have reversed fixity
17:48:47 <elliott> anyway, with the latter you can chop off the ($ x)
17:48:48 <aavogt> f $ g $ x is shortest as   f $ g x
17:48:50 <elliott> to refactor it into a function
17:48:54 <elliott> aavogt: for long x :P
17:49:12 <elliott> anacrolix: wait...
17:49:17 <elliott> anacrolix: why do you use break and then discard its second element?
17:49:20 <anacrolix> okay, but f . g requires that f takes a single argument right?
17:49:30 <hpaste> elliott annotated “first hs program” with “first hs program (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/52769#a52775
17:49:32 <elliott> there we go
17:49:33 <elliott> anacrolix: no
17:49:49 <elliott> anacrolix: (f . g $ x) is literally equivalent to (f $ g $ x), so you don't have to think of relative advantages/disadvantages :-)
17:50:33 <rwbarton> one advantage of (f $ g $ x) is as you write it you don't have to figure out when you get to "f $" whether the argument of f is going to have a $ in it. :P
17:50:44 <aavogt> > flip (flip map . tail) pred "anacrolix"
17:50:45 <lambdabot>   "m`bqnkhw"
17:50:49 * monochrom frowns. that's like saying advantages and disadvantages of (+) vs negate
17:51:14 <elliott> monochrom: well, anacrolix implied that the (.) method might only work in certain cases
17:51:17 <dmwit> The advantage of "f . g . h $ x" is that there are more pieces which can be abstracted out via copy and paste.
17:51:26 <elliott> dmwit: also, less visual noise
17:51:32 <elliott> also, doesn't break once Cale gets his way
17:51:35 <dmwit> You can take "f" or "f . g" or "f . g . h" and name them.
17:51:45 <dmwit> Whereas "f $ g" is not a sensible subexpression to name.
17:52:48 <dmwit> anacrolix: That's the argument for (.) over ($) in the current status quo. There's also an argument about tomorrow's status quo, but it's not tomorrow yet. =)
17:53:12 <anacrolix> hm
17:53:26 <anacrolix> i can do f . g x, and f $ g x
17:53:29 <anacrolix> they do the same thing
17:53:32 <rwbarton> no
17:53:35 <anacrolix> :t f . g x
17:53:36 <lambdabot> forall a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, SimpleReflect.FromExpr (f a), Functor f) => f b
17:53:52 <dmwit> :t \f g x -> f . g x
17:53:53 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (a -> b) -> (t -> f a) -> t -> f b
17:53:57 <dmwit> :t \f g x -> f $ g x
17:53:57 <lambdabot> forall t a b. (a -> b) -> (t -> a) -> t -> b
17:54:00 <dmwit> Not the same.
17:54:12 <dmwit> :t \f g x -> f Prelude.. g x
17:54:13 <lambdabot> forall t b c a. (b -> c) -> (t -> a -> b) -> t -> a -> c
17:56:52 <dmwit> "f . g x" is "\y -> f (g x y)"; "f $ g x" is "f (g x)"
17:57:18 <shachaf> elliott: Cale will never get his way.
17:57:20 <dmwit> ...which is "\y -> f (g x) y" in some cases.
17:57:26 <elliott> shachaf: You can never be sure.
17:57:30 * shachaf can be sure.
17:57:38 <anacrolix> i'm so confused
17:57:44 <anacrolix> let me try this stuff in ghci adn come back
17:58:01 <elliott> Hmm, I appear to have activated the secret feature of GHC where Chans don't work and reading from a Chan that's being written to just blocks forever.
17:58:09 <elliott> I don't like this feature much.
17:58:34 <dmwit> That sounds like a bad feature.
17:58:51 <dmwit> Did you compile with -threaded -rtsopts and run with +RTS -N2?
17:59:20 <elliott> dmwit: No. (Are programs meant to break if I don't run with -threaded?)
17:59:31 <elliott> I'll try it but if it works I'll be sad.
17:59:34 <dmwit> It is possible that the reading thread is entering a alloc-less loop and preventing the writing thread from running.
17:59:39 <mm_freak> elliott: except when using certain primitives, you shouldn't /need/ -threaded
17:59:50 <elliott> dmwit: It's a read-from-handle -> write-to-channel loop, so I hope not..
17:59:50 <mm_freak> elliott: just make sure that you have indeed concurrent threads
17:59:58 <elliott> dmwit: Oh, you mean an alloc-less loop in readChan?
18:00:00 <elliott> That would be weird.
18:00:08 <dmwit> No, I didn't mean that.
18:00:13 <dmwit> That would, indeed, be weird.
18:00:28 <elliott> Yeah, that doesn't help. I suppose I just have some subtle bug of my own.
18:00:55 * dmwit nods sadly
18:02:20 <shachaf> elliott: Subtle bug of your own > subtle bug in GHC, probably.
18:02:22 <mm_freak> applicative parsers are as powerful as monadic parsers, right?
18:02:35 <elliott> shachaf: I totally don't believe that.
18:02:51 <elliott> shachaf: I'm so good, how can the GHC devs be better?
18:03:16 <dmwit> mm_freak: Nope.
18:03:49 <mm_freak> dmwit: which grammer can be parser by a parser monad, which cannot be parsed by an applicative parser?
18:03:53 <mm_freak> grammar*
18:04:04 <dmwit> mm_freak: For example, in a monadic parser, you can track which identifiers have been declared and only allow terms with those identifiers in; applicative parsers can't do that.
18:04:20 <shachaf> elliott: ">" as in "is preferable to"
18:04:39 <elliott> shachaf: Me being fallible is way less preferable than some other people being fallible. I deal with other people's bad software all the time.
18:04:56 <shachaf> Oh, that's true.
18:05:25 <shachaf> It's a good thing to have your infallible self around to keep the rest of us in check.
18:06:15 <mm_freak> dmwit: but Applicative + Category can do that, as far as i see
18:07:04 <elliott> You mean Arrow? :-P
18:07:13 <elliott> (Yeahyeah, modulo etc.)
18:07:25 <mm_freak> elliott: Category (but i'm asking myself whether i would lose power by implementing an Arrow-based parser, yes)
18:08:31 <dmwit> :t (<*>)
18:08:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:08:45 <mm_freak> i'd like to create a parser arrow for bytestrings
18:09:02 <dmwit> mm_freak: ...are you sure Applicative can do that?
18:09:10 <kmc> i'm interested to see this Chan breakage exmaple
18:09:11 <mm_freak> dmwit: Applicative + Category
18:09:21 <dmwit> ?src Category
18:09:21 <lambdabot> Source not found. There are some things that I just don't know.
18:09:27 <mm_freak> dmwit: Control.Category
18:10:17 <mm_freak> attoparsec has some performance limitations, when it comes to keyword parsing
18:10:43 <dmwit> mm_freak: instances of Category and Applicative don't even have the same kind...
18:10:58 <elliott> dmwit: Did you not read that Control + Category = Applicative thing?
18:11:00 <elliott> Erm.
18:11:00 <elliott> = Arrow
18:11:02 <dmwit> Anyway, I guess it makes much more sense to ask about particular parser libraries.
18:11:03 <mm_freak> dmwit: instance Applicative (Parser a); instance Category Parser
18:11:14 <elliott> And s/Control/Applicative/.
18:11:20 <dmwit> Since Applicative and Category on their own don't allow you to write very many interesting parsers at all. =P
18:11:21 <mm_freak> elliott: yes
18:11:29 <elliott> mm_freak: You're dmwit? :-)
18:11:36 <mm_freak> oh, sorry =)
18:12:09 <mm_freak> attoparsec chokes on these kinds of parsers:  try (string str1 >> a) <|> try (string str2 >> b) <|> (string str3 c)
18:12:16 <mm_freak> parser arrows can solve that easily
18:12:30 <shachaf> Do Applicative and Category on their own allow you to write very many interesting papers?
18:12:33 <shachaf> That's what really matters.
18:12:34 <mm_freak> s/str3 c/str3 >> c/
18:12:40 <shachaf> (Also what I misread dmwit's message as.)
18:13:48 <dmwit> elliott: I believe the conclusion of that blog post was that Applicative + Category /= Arrow, no?
18:14:00 <dmwit> (Actually, it concluded in an inclusion, but I don't remember which way it was.)
18:14:01 <mm_freak> i just fear that i might lose some power, because for the parser type i have in mind it will be difficult to write a useful ArrowApply instance
18:14:04 <rata_> hi
18:14:19 <elliott> dmwit: No, it was "you can do it, but you need a few obvious laws that should be satisfied by any sane instance".
18:14:24 <elliott> dmwit: Admittedly we haven't been told quite what you need yet.
18:14:35 <dmwit> elliott: That sounds like a (/=) conclusion to me.
18:14:46 <elliott> dmwit: Well, it's an ~= conclusion. :p
18:14:52 <dmwit> ~= ?
18:14:56 <mm_freak> dmwit: not really, otherwise you could say the same about monads
18:14:56 <elliott> Totally.
18:15:03 <elliott> mm_freak: You'll probably lose a bit of power, but it might not matter; IIRC the whole niceness of applicative parsers is that they avoid inefficiencies of monadic parsing.
18:15:05 <hpaste> rata pasted “progress bar” at http://hpaste.org/52779
18:15:09 <dmwit> mm_freak: What could you say about monads?
18:15:14 <rata_> do you know what I'm doing wrong trying to implement a progress bar for my program? http://hpaste.org/52779
18:15:54 <mm_freak> dmwit: you could similarly conclude that the Monad class doesn't define monads, because you need to satisfy some laws
18:16:04 <dmwit> mm_freak: I conclude exactly that.
18:16:17 <dmwit> Don't you?
18:16:22 <mm_freak> no
18:16:27 <dmwit> Well, you're wrong.
18:16:30 <dmwit> =)
18:16:46 <dmwit> An instance of Monad is only a monad if it satisfies some laws.
18:17:05 <dmwit> Similarly, an instance of Applicative is only an instance if it satisfies some laws, and likewise for Functor, Category, and Arrow.
18:17:19 <mm_freak> yes, and an instance of both Applicative and Category is only an arrow, if it satisfies some laws
18:17:38 <dmwit> Right. Which means applicative + category /= arrow.
18:17:46 <dmwit> applicative + category + laws == arrow
18:18:03 <elliott> monad /= monad
18:18:06 <elliott> monad + laws = monad
18:18:08 <elliott> ergo laws = 0
18:18:09 <dmwit> I would be perfectly happy also saying Monad + laws == monad.
18:18:19 <dmwit> elliott: No, Monad /= monad
18:19:18 <mm_freak> nitpicking…  haskell's type system is not powerful enough to enforce the laws…  you would have to go as far as saying that Integer does not correspond to the set of integers
18:19:24 <mm_freak> because it has bottom
18:19:46 <dolio> Integer isn't the set of integers.
18:19:50 <dolio> It's the domain of integers.
18:20:19 <dmwit> undefined is sort of an orthogonal issue
18:20:52 <dmwit> If Integer didn't satisfy laws like 0 + x = x, 1 * x = x, x + (y + z) = (x + y) + z, etc. I'd hesitate to even call it Integer.
18:21:08 <dmwit> (And again, OOM errors and the like are a bit orthogonal.)
18:22:24 <mm_freak> these questions have been analyzed to death…  to me that Monad class corresponds to haskell monads, and for any instance i assume that either the laws hold or there is a bug
18:23:00 <dmwit> mm_freak: Then, what you are saying is that defining an instance of Arrow for anything that happens to be an Applicative and a Category would be a bug.
18:23:03 <dmwit> Is that fair?
18:23:25 <mm_freak> dmwit: no, that's not what i'm saying
18:23:27 <dmwit> (Because it's not necessarily true that the final laws are true just by assuming bug-free implementations of Applicative and Category.)
18:23:40 <mm_freak> but certain combinations of Applicative and Category make an Arrow, too
18:23:46 <dmwit> Absolutely!
18:23:52 <dmwit> I wouldn't argue there.
18:23:58 <dmwit> But that's an inclusion, not an equality.
18:24:08 <mm_freak> and i'm interested in this question for a real world application, so i don't really want to discuss this
18:24:20 <dmwit> Yes, we are getting a bit far from the original question.
18:24:23 <dmwit> Let's go back to it.
18:24:26 <mm_freak> please
18:24:39 <dmwit> Again, I say we should be talking about particular parser types, not about "applicative" versus "monadic" parsers.
18:24:56 <dmwit> So, I assume we can take something like Parsec for the "monadic" part -- what's the "applicative" part?
18:25:25 <mm_freak> i know that i'm going to lose the power to express Parser (Parser a), and that has been useful sometimes, but i'm sure it can be solved with specific combinators, too
18:26:07 <hpaste> “Ertugrul Söylemez” pasted “Parser arrow” at http://hpaste.org/52781
18:26:08 <dmwit> rata_: Give us a hint. Is there a compilation error? Does it run? What does it do? What do you expect it to do?
18:26:14 <mm_freak> see the paste
18:26:25 <mm_freak> the parser arrow i have in mind is based around that set of types
18:26:41 <dmwit> PConst consumes no input?
18:26:46 <mm_freak> it works and is fast, but before putting a lot of effort into it, i would like to know the limitations of the approach
18:26:51 <mm_freak> yes
18:27:06 <rata_> it runs perfectly, the only problem is that all the hashes are printed instantly
18:27:19 <rata_> instead of print each hash as it computes
18:27:22 <rata_> dmwit: ^
18:27:57 <mm_freak> the real magic is going to happen in the ArrowPlus instance, which is not written yet
18:28:00 <elliott> mm_freak: I hear only CPS parsers are fast. :p
18:28:00 <dmwit> mm_freak: ...and PGen consumes characters greedily, or...?
18:28:08 <rata_> *printing
18:28:12 <mm_freak> elliott: it is CPS
18:28:17 <elliott> Oh, so it is.
18:28:20 <bd_> > (length + length) "abc"
18:28:21 <lambdabot>   6
18:28:33 <bd_> > (length + length) == (length + length)
18:28:34 <lambdabot>   *Exception: (==): No overloading for function
18:28:48 <bd_> > show (length + length)
18:28:49 <lambdabot>   "*Exception: show: No overloading for function
18:28:51 <shachaf> elliott: CPS makes your program fast because events.
18:28:51 <mm_freak> dmwit: yes…  if it Results, it gives the result along with the rest of the current string chunk
18:28:52 <bd_> disappointing :)
18:28:58 <elliott> shachaf: Yes.
18:29:12 <dmwit> mm_freak: Sorry, I think I phrased my question badly. PGen consumes one character, or many?
18:29:27 <mm_freak> dmwit: as many as it needs
18:29:27 <elliott> bd_: Shh, we're busy trying to convince him to not do it.
18:29:44 <bd_> elliott: who is 'him' here? :)
18:29:54 <shachaf> Sgeo?
18:30:00 <shachaf> He's not even in here.
18:30:07 <elliott> shachaf: It's true for correct values of "we".,
18:30:14 <shachaf> Get your data type context declarations out, everyone!
18:30:25 <mm_freak> dmwit: the only rule is that PGen may only drop characters from the string chunk…  it may not change future characters or put characters back
18:30:35 <elliott> s/,//
18:30:46 <bd_> shachaf: ah. yeah, I was talking to him in another channel
18:30:59 <bd_> I suggested the use of GADTs and Rank2Types. This may have been unwise <.<
18:31:32 <shachaf> {-# LANGUAGE Zygomorphisms #-}
18:31:32 <dmwit> mm_freak: I want to parse the exact string "ab". So I write (PGen (=='a') f) for some f. I give it the string "aa". What is given to 'f' as its first argument?
18:31:58 <mm_freak> dmwit: (.) basically sequences parser automatons, where the next automaton is not invoked, until the current one has given a Result
18:32:07 <mm_freak> this should be pretty clear from the types
18:33:31 <hpaste> “Ertugrul Söylemez” annotated “Parser arrow” with “Example parsers” at http://hpaste.org/52781#a52782
18:33:37 <mm_freak> dmwit: the first argument to PGen is optional…  it gives a static input validator…  if you want to parse "ab", you would define anyChar…  see the paste
18:33:55 <mm_freak> based on anyChar you can define 'char'
18:34:00 <mm_freak> or you can define 'char' separately
18:34:46 <mm_freak> for the 'char' parser you would use MatchChar as the validator and just the same as anyChar for the parser
18:36:46 <mm_freak> i think i'll just go to sleep now and try to write a real library tomorrow
18:37:11 <dmwit> If the static information is optional as you say, you may be able to get away with a great deal.
18:37:29 <dmwit> But then it seems like you lose the benefit of the static analysis.
18:37:44 <mm_freak> the static information is optional and only for optimizing…  the parser may just fail in the traditional way through 'Error'
18:38:01 <mm_freak> for some parsers the latter makes sense
18:40:15 <mm_freak> but this is really just the basic idea…  i'll do some more research, because i would like to make iteratees obsolete through a smart parser arrow
18:40:36 <mm_freak> i think with some effort you can turn the parser into a generic stream processor
18:41:03 <dmwit> This may actually be a monad.
18:41:15 <mm_freak> no, it will be even further away from a monad
18:41:27 <mm_freak> add a third argument (Parser a b) to the Result constructor
18:41:41 <mm_freak> that effectively allows all parsers to become stream processors
18:41:57 <dmwit> I meant the type you pasted may give rise to a monad.
18:42:20 <mm_freak> you can define ArrowApply for it, and it would make a monad, but that monad wouldn't be very useful
18:43:04 <mm_freak> you're basically facing the problem of defining 'app' for the automaton arrow
18:43:40 <mm_freak> you can do it, but the instances you can define aren't going to be very useful
18:44:25 <mm_freak> in this parser arrow you could define ArrowApply to use the first valid result value as the input to the subcomputation, but that will break down with the stream processing idea
18:45:18 <mm_freak> i'll do some research tomorrow…  good night
18:45:39 <dmwit> rata_: return $! ms ++ drop 1 ms' only evaluates its argument far enough to know whether it is a [] or a (:); is that what you meant to do?
18:46:58 <rata_> dmwit: no, I wanted it to force the list
18:47:10 <Axman6> you need deepSeq then
18:47:24 <Axman6> rata_: but make sure that's actually what you want. that could lead to space leaks
18:47:39 <rata_> Axman6: why?
18:47:42 <Axman6> @hoogle ($!!)
18:47:42 <lambdabot> No results found
18:48:25 <Axman6> rata_: because forcing the evaluation of things that don't actually ever need to be evaluated can cause them to stay in memory for much longer and use a lot more space
18:50:17 <Axman6> if you do xs = take 1000000 [1..] and do deepSeq xs, and still keep a reference to xs, then all 1000000 ints would be kept in memory
18:50:29 * Axman6 -> tute
18:53:56 <rata_> Axman6: ok, but in this programs it seems that the whole story list is put in memory anyway, as my netbook is sluggish now (I'm running the program and it's taking 44% of my memory)
19:03:42 <sagelywizard> Why is Num a => a the type of 1? Why not just Int?
19:03:50 <kmc> > 1 :: Double
19:03:51 <lambdabot>   1.0
19:04:06 <kmc> :t 1 / 2
19:04:07 <lambdabot> forall t. (Fractional t) => t
19:04:54 <kmc> :t 1 / (2 :: Double)
19:04:55 <lambdabot> Double
19:05:00 <rata_> Axman6: by rapidly looking at my code, do you know how could I avoid storing the whole story list in memory at the same time?
19:05:00 <kmc> :t (1 :: Int) / (2 :: Double)
19:05:01 <lambdabot>     Couldn't match expected type `Int' against inferred type `Double'
19:05:01 <lambdabot>     In the second argument of `(/)', namely `(2 :: Double)'
19:05:02 <lambdabot>     In the expression: (1 :: Int) / (2 :: Double)
19:06:22 <sagelywizard> kmc: So, it just hasn't been assigned to a definite type yet? It just has a type class?
19:06:34 <kmc> correct
19:07:04 <kmc> numeric literals are polymorphic values
19:07:10 <kmc> they get instantiated to a concrete type through the process of type inference
19:07:39 <kmc> the way this works is that 1 is syntactic sugar for (fromInteger 1)
19:07:52 <kmc> (where the second 1 has type Integer)
19:07:59 <kmc> and fromInteger is defined in the Num type class
19:08:07 <kmc> :t fromInteger
19:08:08 <lambdabot> forall a. (Num a) => Integer -> a
19:08:17 <Peaker> > fix fromInteger
19:08:21 <lambdabot>   mueval-core: Time limit exceeded
19:08:26 <kmc> this is a function whose *result* type is overloaded, which is quite unusual in most languages
19:08:37 <kmc> but is pretty common in Haskell, and fits well with type inference etc
19:09:44 <kmc> similarly 1.5 is sugar for (fromRational (3 % 2))
19:09:54 <kmc> :t fromRational
19:09:55 <lambdabot> forall a. (Fractional a) => Rational -> a
19:11:19 <sagelywizard> kmc: Hmm, interesting. Thanks.
19:11:50 <kmc> :)
19:13:30 <anacrolix> elliott: something isn't write at the final part of the annotation you gave me
19:13:36 <anacrolix> networkPlusQueue . map csVals . tail $ lines contents
19:13:44 <elliott> hmm
19:13:45 <anacrolix> map csVals returns [[String]]
19:13:55 <elliott> networkPlusQueue takes [[String]]
19:13:57 <elliott> oh
19:13:57 <anacrolix> but networkPlusQueue takes [String]
19:13:57 <elliott> hmm
19:14:06 <elliott> anacrolix: concatMap? I didn't change that part of your code :P
19:14:07 <elliott> oh hmm
19:14:09 <anacrolix> i need to map them over it right?
19:14:18 <elliott> maybe networkPlusQueue actually takes a [String]
19:14:21 <elliott> I didn't look too closely
19:14:27 <anacrolix> how would i select the appropriate way to map across it?
19:14:27 <elliott> does it work if you remove networkPlusQueue's type signature?
19:14:37 <elliott> if not, you probably want concatMap
19:14:41 <anacrolix> mapM networkPlusQueue $ map csVals . tail $ lines contents
19:14:43 <anacrolix> ?
19:14:44 <anacrolix> okay
19:15:07 <elliott> that $ should be a . if that ends up being what you want :)
19:15:08 <ion> I actually needed factorial for the very first time when using Haskell. :-)
19:15:14 <elliott> first one
19:15:56 <elliott> anacrolix: anyway, I have to leave now; sorry I can't be more help, but I'm sure someone here can :-)
19:16:50 <anacrolix> thanks for the help it was considerable
19:16:59 <NemesisD> anyone subscribe to haskell beginners?
19:18:24 <pchiusano> what is the difference between EitherT and ErrorT?
19:20:17 <pchiusano> they look like they have identical signatures
19:23:14 <pchiusano> oh, is it just that the left type is an Error for ErrorT, whereas for EitherT the left can be any type?
19:27:21 <DanBurton> @pl let sinkM hof f = runIdentity . hof (return . f) in sinkM
19:27:22 <lambdabot> ((runIdentity .) .) . (. (return .))
19:29:00 <NemesisD> gratuitous
19:29:15 <DanBurton> pchiusano: yes, Either allows the left and right types to be anything you want
19:29:48 <DanBurton> I wish lambdabot had nicer combinators than ((foo .) .) . bar
19:30:04 <DanBurton> :@unpl ((foo .) .) . bar
19:30:09 <DanBurton> @unpl ((foo .) .) . bar
19:30:09 <lambdabot> (\ e h k -> foo (bar e h k))
19:30:34 <elliott> DanBurton: .:
19:30:36 <DanBurton> @unpl (. (foo .))
19:30:36 <lambdabot> (\ b e -> b (\ h -> foo (e h)))
19:30:40 <elliott> :t (.:)
19:30:40 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:30:59 <elliott> it's (.) . (.)
19:31:34 <DanBurton> elliott: yes I'm familiar with it. I called it .* in Data.Composition
19:31:48 <pchiusano> DanBurton: that makes sense - i was confused because I was just looking at the signature, not the instances
19:31:51 <elliott> ah
19:32:27 <pchiusano> and i guess you need two separate types for typeclass dispatch
19:32:35 <pchiusano> er, selection
19:33:16 <DanBurton> :t (.:.)
19:33:17 <lambdabot> Not in scope: `.:.'
19:33:23 <pchiusano> ErrorT could actually be just a newtype of EitherT
19:33:43 <DanBurton> Does lambdabot have something like .* for \a b c -> f (g a b c) ?
19:33:51 <DanBurton> Like .: I mean
19:34:43 <DanBurton> That would be a cool ghci feature: sort of a mini-hoogle; search all current bindings for a given type signature
19:37:50 <DanBurton> pchiusano: check it out: "newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }" http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/src/Control-Monad-Trans-Error.html#ErrorT
19:43:59 <keep_learning> how can i export my library from user space to root . I have installed Network in user but when i am trying to run ghci from root , it shows could not find module
19:44:31 <parcs_> :t (.::)
19:44:32 <lambdabot> forall a1 b a (f :: * -> *). (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
19:44:33 <DanBurton> I'm sure there's a way, way better answer, but how about just re-installing it as root?
19:45:06 <DanBurton> Meaning, as root, "cabal install network", or whatever package it is in
19:45:38 <monochrom> root installs Network in user (then only root can use it); or root installs Network in global (then everyone can use it)
19:45:38 <parcs_> why are you running ghci as root
19:46:10 <keep_learning> parcs_, i am writing network sniffer
19:46:27 <keep_learning> parcs_, in which i have to  be root
19:46:28 <monochrom> you can actually run an executable as root
19:47:28 <keep_learning> monochrom, yes but interactive ghci is more helpful sometime for function testing .
19:49:42 <parcs_> keep_learning: you can configure sudo to retain the $HOME variable of the calling environment
19:49:51 <parcs_> that way it will use your local packages
19:50:19 <monochrom> actually sudo does that normally
19:50:27 <parcs_> not on arch
19:51:43 <monochrom> let me check again
19:51:43 <penryu> it's distro-dependent, ime
19:51:43 <keep_learning> parcs_, great idea
19:51:43 <monochrom> alright
19:51:44 <parcs_> that is immensely useful btw
19:51:44 <penryu> well, the default behavior is distro-dependent. it can be changed, regardless.
19:54:08 <DanBurton> penryu: well, with open source software, *anything* can be changed :)
19:54:28 <DanBurton> Linux and its distros being prime examples of FOSS
19:54:35 <mike-burns> There's a config flag for it. It defaults to disabled.
19:54:47 <mike-burns> This is overly pedantic now, even for this channel.
19:55:46 <penryu> hasn't the OSI approved microsoft's Shared Source licenses in the past? *cough*cough*
19:56:32 * hackagebot zoom-cache 0.2.1.1 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.2.1.1 (ConradParker)
19:56:34 * DanBurton drops his FOSS pedantry and starts thinking about arrows
19:56:39 <penryu> hehe
19:57:20 <DanBurton> Speaking of, has anyone come across a really good read on Arrows? I've read typeclassopedia and the wikibook, but I still feel that my arrow-fu is weak.
19:57:40 <DanBurton> Arrow exercises would be good
19:59:22 <kmc> TH doesn't allow decl splices except at top level, correct?
19:59:42 <byorgey> DanBurton: read the tutorial papers linked from the typeclassopedia
19:59:50 <byorgey> there are a few good ones
20:00:06 <byorgey> I think one of them even has exercises, I forget which though
20:00:55 <DanBurton> byorgey: thanks, I'll take a look
20:02:28 <rata_> memory problems always hit me
20:05:43 <DanBurton> rata_: care to hpaste? maybe we can help?
20:09:51 <rata_> DanBurton: the whole program?
20:10:32 <DanBurton> rata_: well, ideally, paste an example that is as small as possible but still manifests the problem
20:10:49 <gks> anyone install haskell-platform via Brew on a mac? It appears to be stalling on me and I can't tell why, or what to do to fix it
20:13:02 <rata_> DanBurton: the problems seems to be related to IO and Rand monads + huge lists (but I don't need the entire list at the same moment)
20:16:56 <rata_> well, I'm too sleepy now, see you tomorrow
20:18:05 <DanBurton> mmkay then
20:18:06 <pikhq_> penryu: Certain of Microsoft's Shared Source licenses are OSI *and* FSF approved.
20:37:06 <Sgeo|web> The wiki says "Normally when creating a new type using type, newtype, data, etc., every type variable that appears on the right-hand side must also appear on the left-hand side. Existential types are a way of turning this off."
20:37:16 <Sgeo|web> elliott says that that's a bad explanation
20:37:20 <Sgeo|web> Can someone please explain?
20:38:01 <DanBurton> perhaps elliott could? :)
20:38:28 <DanBurton> Sgeo|web: which wiki page is that? Can you give us the link?
20:38:35 <Sgeo|web> http://haskell.org/haskellwiki/Existential_type
20:38:41 <elliott> it extends the type system, it doesn't just turn some arbitrary restriction off
20:38:55 <byorgey> @ask dcoutts what is the canonical way, using Cabal, to get one's hands on the list of packages currently installed?  I've spent a while trying to wade through the API but can't figure it out
20:38:56 <lambdabot> Consider it noted.
20:38:57 <DanBurton> Ooh I've been meaning to read up on existential types
20:39:10 <elliott> i figure the folks here can explain existential types to Sgeo|web better than i can
20:39:49 <Sgeo|web> I see a million examples of using it to turn a class into a type
20:39:52 <Sgeo|web> Any other uses?
20:40:49 <byorgey> sure, you can use them to build heterogeneous collections
20:40:53 <byorgey> or simulate dynamic types
20:40:58 <luite> byorgey: hmm, I've used this, it calls ghc-pkg, let me check
20:41:21 <elliott> byorgey: ...but you usually shouldn't :P
20:41:27 <Sgeo|web> The heterogeneous collection example seems to be based on turning a class into a type
20:41:59 <Sgeo|web> It seems to be possible to do similar without existential types, just annoyingly. Are there cases when that can't be done?
20:42:05 <byorgey> or you could use them for encapsulation purposes, having a "private implementation type" which is usable only with functions you provide but not with anything outside
20:42:53 <byorgey> how would you do something similar without existential types?
20:43:22 <Sgeo|web> byorgey: I wasn't referring to implementation hiding, just turning classes into types
20:43:34 <byorgey> "turning a class into a type" does not technically make sense
20:43:52 <Sgeo|web> By having a type that contains all the functions of the class, and a function that takes something of the class and turns it into that type
20:44:00 <byorgey> if you want an existentially quantified type to be usable outside its scope, the ONLY way to do it is by giving it a class constraint.
20:44:11 <DanBurton> type HList = Empty | IntCons Int HList | DoubleCons Double HList ...
20:44:20 <byorgey> Sgeo|web: ah, right, I see what you mean
20:44:40 <byorgey> Sgeo|web: basically reifying the class dictionary
20:46:01 <byorgey> if you have a type that does nothing other than existentially quantify over a type variable with a class constraint you could think of that as "turning the class into a type"
20:46:05 <byorgey> but it is really more general than that
20:46:47 <Veinor> i have u :: m (Maybe a), and f :: a -> m (Maybe b). how can i get an m (Maybe b) out of this?
20:46:52 <DanBurton> Is it fair to call Existential Types a way of using a type class as a "superclass" or "interface"?
20:46:54 <byorgey> elliott: I know of several excellent uses of heterogeneous collections/dynamic types.
20:47:09 <byorgey> DanBurton: no
20:47:16 <elliott> byorgey: yeah, but newbies tend to overuse them :)
20:47:18 <DanBurton> byorgey: explain?
20:47:23 <byorgey> types classes are already "interfaces"
20:47:27 <byorgey> elliott: agreed.
20:47:29 <elliott> and classes in general, really
20:47:39 <byorgey> DanBurton: existential types have nothing to do with type classes.
20:47:52 <byorgey> it's just that they often work well together.
20:48:01 <DanBurton> well sure
20:48:09 <elliott> Veinor: join (u >>= fmap f)?
20:48:16 <luite> byorgey: isn't it getInstalledPackages from Distribution.Simple.GHC? I've used that, but since it's compiler specific, I'm not sure if its the canonical way :)
20:48:33 <Veinor> :t \u f -> join (u >>= fmap f)
20:48:34 <lambdabot> forall (m :: * -> *) a a1. (Functor m, Monad m) => m (m a) -> (a -> m a1) -> m a1
20:48:56 <elliott> oh hmm
20:49:05 <Veinor> i feel like there is a short way to do this
20:49:17 <elliott> u >>= (>>= f)
20:49:20 <elliott> then join that
20:49:24 <elliott> i think
20:49:26 <Veinor> :t \u f -> u >>= (>>= f)
20:49:27 <byorgey> Veinor: runMaybeT (MaybeT u >>= (MaybeT . f))
20:49:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (m a) -> (a -> m b) -> m b
20:49:35 <elliott> aargh
20:49:39 <byorgey> @type \u f -> runMaybeT (MaybeT u >>= (MaybeT . f))
20:49:40 <lambdabot> Not in scope: `runMaybeT'
20:49:40 <lambdabot> Not in scope: data constructor `MaybeT'
20:49:40 <lambdabot> Not in scope: data constructor `MaybeT'
20:49:43 <Veinor> byorgey: yeah
20:50:02 <elliott> byorgey: there must be a simpler way...
20:50:03 <byorgey> luite: thanks, I can try that
20:50:12 <joevandyk> can someone explain a monad transfer to someone who is drunk?
20:50:27 <joevandyk> isn't a monad a burrito?
20:50:35 <byorgey> elliott: how is that not simple? perhaps you mean a more "primitive" way?
20:50:44 <elliott> byorgey: probably :P
20:50:49 <iFire>  I figured out a scheme to get Peter Novig to give me his signature!
20:50:50 <DanBurton> joevandyk: no, monads are transformers in disguise ;)
20:50:53 * iFire does shifty eyes
20:51:00 <joevandyk> DanBurton: wtf
20:51:05 <DanBurton> joevandyk: doh messed that up. other way around
20:51:05 <byorgey> elliott, Veinor: there is no way to do it that does not make use of the special properties of Maybe.
20:51:14 <elliott> yeah
20:51:16 <byorgey> i.e. it cannot be done just with monad combinators
20:51:26 <Veinor> ah, okay
20:51:45 <Veinor> so i think i might just rewrite my logic
20:52:19 <DanBurton> joevandyk: http://haskellers.spreadshirt.com/transformers-monads-in-disguise-for-men-A7042596
20:52:31 <byorgey> luite: problem is I am extending 'cabal init', so it needs to be as generic as possible
20:54:29 <joevandyk> DanBurton: i found http://en.wikibooks.org/wiki/Haskell/Monad_transformers which seems to say that a transformer is a mechanism for combining multiple monads into one
20:54:32 <joevandyk> about right?
20:55:24 <DanBurton> joevandyk: yeah, jokes aside, that's the idea.
20:55:48 <joevandyk> DanBurton seems to be a weird choice of words.  i'm assuming it's math related.
20:55:56 <joevandyk> transformer seems ...
20:55:59 <byorgey> joevandyk: yes, a monad transformer adds the capabilities/effects/features of one monad to an existing monad.
20:56:07 <DanBurton> joevandyk: So if you have a transformer "t" and a monad "m", then the type "t m" should be a monad too
20:56:10 <byorgey> joevandyk: what would you call it?
20:56:24 <joevandyk> byorgey: combiner?  mixer?
20:56:25 * DanBurton would call it monad legos
20:56:27 <EvanR> monad convertator
20:56:42 <kmc> easier to explain burrito to person who is drunk
20:56:43 <joevandyk> factory?
20:56:49 <EvanR> uhg factory
20:57:02 <EvanR> c++ talk
20:57:02 <joevandyk> :)
20:57:14 <EvanR> haskell constructor is bad enough
20:57:26 <joevandyk> transformer to me doesn't indicate that many inputs go into one output
20:57:30 <DanBurton> "cons" stands for "constructor", you know ;)
20:57:48 <EvanR> joevandyk: well one input
20:57:49 <DanBurton> because back in the day, the Lispers figured that a list was all you would ever need to construct. Or so I'm told.
20:58:06 <EvanR> lisp makes no sense
20:58:40 <DanBurton> lisp makes perfect sense to me :) it's like Haskell but all prefix and with parens
20:58:42 <luite> byorgey: oh I think it should be Distribution.Simple.Configure.getInstalledPackages then, the configure function in that module shows how to detect the compiler and call it
20:58:50 <EvanR> DanBurton: and no types
20:59:09 <DanBurton> EvanR: Yeah, no Hindley-Milner magic :(
20:59:14 <joevandyk> are there any other somewhat commonly used languages that uses the terms monads, functors, lifting, transformers, applicative functors, etc?
20:59:35 <joevandyk> half the battle of haskell for me is figuring out all these weird terms
20:59:35 <elliott> clean
20:59:35 <DanBurton> @google monad C sharp
20:59:35 <lambdabot> http://lostechies.com/derickbailey/2010/09/30/monads-in-c-which-part-is-the-monad/
20:59:35 <lambdabot> Title: Monads in C#: Which Part Is The Monad? | ThoughtStream.new :derick_bailey
20:59:36 <EvanR> clean doesnt have monads
20:59:40 <elliott> i think scala?
20:59:44 <MatrixFrog> "functor" is used in a lot of languages, but to mean totally different things than it means in haskell :(
20:59:52 <DanBurton> doh. anyways my friend was reading some book about FP in C# and it has a chapter on monads
20:59:59 <elliott> EvanR: really? i know it doesn't do monadic io\
20:59:59 <EvanR> ouch
21:00:05 <elliott> but no monad class?
21:00:09 <blackdog> EvanR: would be easy to write a monad in Clean, of course..
21:00:14 <DanBurton> although I read that chapter, and it basically says C# doesn't accommodate them very well..
21:00:15 <EvanR> or anything else blackdog
21:00:22 <EvanR> doesnt mean youd want to you ;)
21:00:33 <blackdog> i think it'd probably be useful in clean
21:00:42 <blackdog> i tried it in ruby once. it felt a little silly.
21:01:04 <DanBurton> scala does have monad-like stuff. but they use weird names like "flatmap"
21:01:04 <EvanR> elliott: i didnt think clean had type classes
21:01:06 <wavewave> does Clean have type classes?
21:01:06 <blackdog> it's really hard to build towers of abstraction without types. At least, that's my experience.
21:01:12 <elliott> EvanR: it does iirc
21:01:20 <elliott> one-defn typeclasses
21:01:27 <joevandyk> fwiw: 2 shots gin, .75 shots sweet vermouth, 1 shot pineapple juice, 0.25 shots triple sec makes for a hell of a monad applicative transformer
21:01:40 <joevandyk> oh, and top with club soda
21:01:42 <byorgey> luite++
21:01:49 <byorgey> luite: thanks =)
21:01:51 <EvanR> blackdog: well theres always types, if you dont know wtf is going on they may be very complex and funky, and of course they are rarely checked ;)
21:09:39 <wavewave> for me, using math terms for haskell concepts is better than using warm fuzzy terms at least since it straightforwardly points unambiguous concept.
21:11:24 <kmc> *nod*
21:11:33 <kmc> if you're starting out, you know that you don't know what a monad is
21:11:40 <kmc> while you don't know that you don't know what "return" or "class" mean
21:11:41 <wavewave> at least, functor should be used in the same way as mathematical meaning.
21:12:09 <wavewave> kmc: *nod*
21:12:19 <wavewave> I hate return
21:12:35 <kmc> what should it be named?
21:12:39 <kmc> "pure" is fairly misleading too
21:12:45 <wavewave> unit
21:12:49 <Sgeo|web> I'm tempted to ask if this tutorial page I'm looking at is getting to a point, but I should keep reading
21:12:56 <Sgeo|web> But it's not unit
21:13:05 <Sgeo|web> I think
21:13:14 <rwbarton> η
21:13:17 <kmc> 'point' is probably relatively confusion-free
21:13:36 <kmc> @let η = return
21:13:37 <lambdabot>  Defined.
21:13:52 <kmc> > map η "nice one" :: [[String]]
21:13:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
21:13:53 <lambdabot>         against inferred ty...
21:14:00 <kmc> > map η "nice one" :: [String]
21:14:02 <lambdabot>   ["n","i","c","e"," ","o","n","e"]
21:14:23 <kmc> @let μ = join
21:14:24 <lambdabot>  Defined.
21:14:50 <geheimdienst> > µ (+) 2
21:14:51 <lambdabot>   Not in scope: `
21:15:05 <byorgey> wrong mu
21:15:05 <geheimdienst> > μ (+) 2
21:15:07 <lambdabot>   4
21:15:17 <DanBurton> η is pronounced "eta", correct?
21:15:22 <byorgey> > yep
21:15:23 <lambdabot>   <no location info>: lexical error at character '\DEL'
21:15:30 <byorgey> heh, whoops
21:15:50 <djahandarie> > yep
21:15:51 <lambdabot>   "Yep!"
21:15:58 <byorgey> and μ is pronounced either "moo" or "myoo" depending who you ask
21:16:17 * byorgey prefers "moo"
21:16:26 <EvanR> objectivist weenies might ask a greek
21:16:37 <byorgey> they would have to ask an ancient greek though
21:16:44 <wavewave> i am not sure whether unit is appropriate.. but I am sure that 'return' is bad.
21:16:45 <DanBurton> I pronounce μ "mew", like the pokemon
21:16:53 <byorgey> I think in modern Greek it is pronounced "me"
21:16:56 <geheimdienst> i find it unfair that cows have their own letter and cats don't. there should be a letter pronounced "meow"
21:16:59 <byorgey> but I am not sure
21:17:05 <EvanR> byorgey: because in modern greek people are too busy protesting
21:17:21 <wavewave> because it hindered me from understanding monad correctly in the beginning.
21:17:22 <byorgey> not exactly what I meant, but I guess that's true too =)
21:17:26 <kmc> i recommend putting a classics student, a cab driver from Greece, and a mathematician / physicist / fratboy in the same room
21:17:31 <kmc> and asking them how to pronounce π
21:17:41 <byorgey> hahaha
21:17:41 <DanBurton> :t join (+)
21:17:42 <lambdabot> forall a. (Num a) => a -> a
21:17:43 <rwbarton> "table"
21:17:46 <DanBurton> :t join
21:17:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:17:54 <EvanR> phi phi pho phum
21:18:02 <kmc> > let 2 + 2 = 5 in join (+) 2
21:18:03 <lambdabot>   5
21:18:18 <DanBurton> o_O lol
21:18:26 <byorgey> kmc: that should be amusing even without asking them any specific questions
21:18:45 <kmc> > map pred "zpv!ibwf!opu!cffo!qbzjoh!buufoujpo"
21:18:46 <lambdabot>   "you have not been paying attention"
21:18:57 <kmc> byorgey, yes
21:19:04 <elliott> <kmc> 'point' is probably relatively confusion-free
21:19:05 <elliott> kmc: nuh uh
21:19:11 <elliott> foo = point . succ -- point-free
21:19:16 <kmc> ;P
21:20:27 <DanBurton> :)
21:20:40 <solidsnack> DanBurton: I was so amused that you said "like the Pokemon".
21:20:43 * byorgey recommends "flimp" for maximum confusion-free-ness 
21:21:15 <DanBurton> solidsnack: I learned Pokemon before I learned Haskell, or any greek letters for that matter, so yeah :)
21:21:29 <kmc> flimp is what you have once your blimp deflates
21:21:46 <elliott> byorgey: famp
21:21:50 <solidsnack> I wonder if there is a Pokemon named eta-something-something. Than both Monad operators would have Pokemons.
21:21:54 <byorgey> hehehe
21:22:00 <elliott> ap is fapm, join is fpam
21:22:03 <DanBurton> @google pokemon eta
21:22:04 <solidsnack> s/Than/Then/
21:22:04 <lambdabot> http://www.gamespot.com/ds/rpg/pokemonds3/show_msgs.php?pid=989552&topic_id=m-1-54726089
21:22:05 <lambdabot> Title: Can I get an ETA on the leak? - Pokemon Black Version - GameSpot Forums
21:22:10 <DanBurton> aw lol
21:22:12 <byorgey> elliott: oh, great idea
21:22:26 <byorgey> elliott: reminds me of cadr, cdaddr, etc.
21:22:35 * DanBurton shudders.
21:22:44 <DanBurton> I hate cdaddr and that stuff. o_O so weird
21:22:48 <elliott> >>+ is mafp I guess
21:22:53 <elliott> m `mafp` famp == m
21:22:55 <byorgey> 'fpam' sounds like something the Knights Who Formerly Said "Ni!" would say
21:23:00 <kmc> i should make a TH macro to define them
21:23:04 <elliott> fpam (fmap f m) = mafp m f
21:23:05 <solidsnack> fapm would be...unfortunate
21:23:28 <kmc> (but should they operate on lists or on nested tuples?)
21:23:51 <rwbarton> @hoogle cdr
21:23:51 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
21:24:19 <elliott> rwbarton: how did that give you a vaguely-related result
21:25:00 <DanBurton> How about naming η "wrap". Then monads could be even more like burritos!
21:25:03 <byorgey> generiCDRop
21:25:03 <rwbarton> Hmm, good question
21:25:21 <kmc> more false intuition :/
21:25:30 <rwbarton> yes but cdr is more or less genericDrop 1!
21:25:33 <elliott> DanBurton: wrap promotes monads-as-containers model
21:25:57 <DanBurton> elliott: but it still makes sense in monads-as-computation, doesn't it? wrap in a default computation?
21:25:57 <byorgey> @hoogle car
21:25:58 <lambdabot> Language.Haskell.ParseMonad discard :: Int -> Lex r ()
21:25:58 <lambdabot> Language.Haskell.Syntax HsPWildCard :: HsPat
21:25:58 <lambdabot> Language.Haskell.Syntax HsWildCard :: HsExp
21:26:07 <elliott> DanBurton: that's kind of strained :P
21:26:10 <elliott> I'm not sure what "wrap" means there.
21:26:16 <wavewave> elevate
21:26:22 <elliott> empower
21:26:36 <byorgey> monadicalize
21:26:37 <solidsnack> I am not sure what bind/join becomes in monads-as-burritos thinking.
21:26:41 <wavewave> monadify
21:27:14 <kmc> solidsnack, what, you've never made a burrito out of smaller burritos?
21:27:22 <shachaf> solidsnack: As discussed in #-blah recently, burritos are a lot more like comonads than like monads.
21:27:22 <kmc> rolled up in an additional tortilla?
21:27:26 <kmc> and then deep-fried for good measure?
21:27:30 <elliott> http://blog.plover.com/prog/burritos.html
21:27:31 <solidsnack> shachaf: Oh, neat.
21:27:37 <elliott> the definitive monad tutorial
21:27:47 <kmc> did anyone write a Tutorial monad yet
21:27:55 <shachaf> After all, turning a burrito of burritos of X into a burrito of X is a non-trivial operation.
21:28:05 <shachaf> But turning a burrito of X into a bunch of X pretty much happens on its own.
21:28:30 <wavewave> Tutorial is monad transformer of newbie monad to beginner monad
21:29:09 <solidsnack> elliott: People sometimes actually do that with burritos, now that I think about it.
21:29:12 <shachaf> LairotuT
21:29:52 <wavewave> LairotuT Tutorial = Identity?
21:30:15 <shachaf> I certainly hope not.
21:30:23 <solidsnack> I am trying to remember why it is actually done...I remember it from a late night restaurant, years ago.
21:30:56 <solidsnack> Like, you had a burrito that didn't go out or something, and the tortilla was cold but the filling could be reused.
21:31:20 <wavewave> monado, monadilla
21:31:33 <solidsnack> So you put the burrito on top of a tortilla and unwrap it, literally, inside the tortilla.
21:31:49 <solidsnack> So burritos are like monads.
21:32:22 * wavewave think monadify is best for replacement of return in his mind.
21:32:52 <solidsnack> In this case the bind/join analogue becomes, "reuseFilling".
21:33:00 <solidsnack> Not terribly compelling.
21:33:09 <solidsnack> Maybe "reWrap" is better.
21:37:41 * wavewave doesn't get why writing on why not using some language.
21:38:12 <DanBurton> wavewave: referring to the "Why not Haskell" post? I was just reading that
21:38:23 <wavewave> DanBurton: yes.
21:38:31 <EvanR> because its the devil
21:38:33 <kmc> it struck me as a very reasonable post
21:38:49 <DanBurton> wavewave: by "just reading", I mean, I'm 2/3 of the way through reading right now. Weird
21:39:19 <kmc> it describes the majority of people's experiences learning the language
21:39:21 <elliott> it was a reasonable post that contradicted my experience
21:39:38 <elliott> that's probably what most people here would say, I imagine :P
21:39:42 <DanBurton> I like how he says Go is "a shining example of worse is better" :)
21:39:50 <kmc> you have to put in a ton of effort before haskell is a practical tool for solving problems
21:39:54 <kmc> most people don't get to that point
21:40:00 <wavewave> I do think the writer is reasonable.. yeah,  it's controdictory to my experience, too.
21:40:02 <kmc> few projects would motivate that effort by themselves
21:40:20 <kmc> it doesn't contradict my experience
21:40:57 <kmc> my only complaints are a) the author seems to overstate their (apparent) skill level in the first paragraph, b) the diagram makes no sense
21:41:08 * elliott only took, like, a year to go from first learning Haskell to feeling fluent in it.
21:41:10 <wavewave> so things can differ in situation and that's common to any language..
21:41:49 <elliott> huh, looks like he's the original author of hexpat
21:41:49 <wavewave> kmc: *nod*  the most unreasonable part of the post was that figure
21:41:59 <kmc> sorry but knowing how to use monad transformers does not make you a 'ninja'
21:42:14 <EvanR> lol
21:42:31 <elliott> I want to go back in time and prevent ninjas from ever existing.
21:42:33 <elliott> Also rockstars.
21:42:35 <kmc> ==
21:42:40 <elliott> I mean, the real things.
21:42:42 <elliott> It'd be worth it.
21:42:53 <kmc> rock music is pretty cool tho
21:43:11 <elliott> kmc: It'll just have to be written and performed by completely anonymous, faceless beings.
21:43:12 <EvanR> what makes you think ninjas dont still exist?
21:43:19 <kmc> maybe you're saying that rock musicians should have languished in obscurity until long after their death, like Real Artists
21:43:32 <elliott> EvanR: They're boring nowadays; they just use jQuery and work at startups.
21:43:36 <EvanR> lool
21:43:38 <lucca> ninjas are mammals.
21:43:43 <wavewave> I was from basic. but I wouldn't write why not basic, I was from C, but I wouldn't write why not C, I was from C++, I wouldn't write why not C++.
21:43:55 <elliott> why not brainfuck
21:44:00 <kmc> man, I should write some blog posts for insecure wannabe painters about how what they do is cool because it's like computer programming
21:44:07 <elliott> :D
21:44:08 <EvanR> elliott: the idiot book "secrets of the javascript ninja" has a samurai on the cover :(
21:44:34 <elliott> kmc: tell them about "blub", which is when a painter can't imagine a palette with more realistic colours than the one they have
21:44:45 <kmc> i would write "why not C++" if there was enough ink in the world
21:45:02 <companion_cube> do you think that someone who programs in haskell without using monad transformers can be called "proficient" ?
21:45:03 * DanBurton laughs
21:45:05 <elliott> why not jumping off a tall building in lieu of writing your application
21:45:20 <elliott> companion_cube: yes, monad transformers aren't that essential
21:45:32 <DanBurton> companion_cube: "proficient" in what? Sure you can do tons of stuff without transformers
21:45:39 <wavewave> companion_cube: definitely..
21:45:43 <kmc> i dislike monad transformers and try to avoid them even though i know how they work
21:45:44 <companion_cube> ok, cool :)
21:45:46 <monochrom> "when they came after c++, I didn't speak up because I didn't miss c++ ..."
21:45:59 <kmc> elliott, http://en.wikipedia.org/wiki/Imaginary_color#Perception_of_imaginary_colors
21:46:19 <elliott> kmc: That's Lisp.
21:46:24 <wavewave> companion_cube: beautiful functional programming algorithm and monad transformer are indep.
21:46:28 <lucca> Where is this why not haskell article?
21:46:28 <kmc> that's right, this article gives directions for how to see a red that is redder than the reddest red
21:46:49 <elliott> kmc: Then you need to take ten years off saying you're going to develop the _perfect_ dialect of Lisp, usable for a hundred years at the least.
21:46:52 <kmc> that makes it the 6th trippiest article on the whole wikipedia
21:46:58 <elliott> kmc: You finally release a prototype; it's just the primary colours.
21:47:07 <elliott> Also the wood has a bunch of splinters in i.
21:47:10 <kmc> but you can make *anything* with them!
21:47:24 <elliott> kmc: Yes. You prove this by painting a house with some neon grass and a blue sky.
21:47:36 <wavewave> companion_cube: I like beautiful functional pearls without any advanced types.
21:47:43 <elliott> There's also a little stick figure standing in front of the house. (You have a patent on the stick figure.)
21:47:47 <elliott> lucca: http://neugierig.org/software/blog/2011/10/why-not-haskell.html
21:48:13 <DukeDave> Wow, this channel, every time...
21:48:21 <kmc> anyway it figures people here will be butt-hurt but I thought it was a pretty reasonable article
21:49:14 * DukeDave just read about the burrito tutorial :D
21:49:15 <wavewave> kmc: reasonable except that figure that makes me laugh.
21:50:20 <wavewave> kmc: even I notice there is a small portion of "code written in haskell" outside "code that works"
21:50:50 <kmc> there's more than a small portion of Hackage outside "code that works"
21:51:27 <elliott> I'm surprised he thinks Haskell code is that large a percentage of All Code(tm).
21:56:44 <kmc> elliott, can you define "proficient"?
21:57:06 <kmc> the first real projects I used Haskell for were compilers and interpreters and the like
21:57:10 <elliott> kmc: Hmm, where did I say that?
21:57:25 <kmc> oh sorry "fluent"
21:57:26 <kmc> * elliott only took, like, a year to go from first learning Haskell to feeling fluent in it.
21:57:44 <kmc> the first real projects I used Haskell for were compilers and interpreters and the like, and it was really nice even though i was quite nub
21:57:57 <kmc> because that's the domain where you get the most power relative to other languages
21:58:03 <kmc> and my stuff didn't need to be that fast or robust
21:58:22 <elliott> Well, I learnt Haskell like I did most languages: I read a few tutorials, kind of lost track, forgot about it for half a year, then started writing code and realised I somehow knew the language. Then it was basically gradual evolution and reading.
21:58:27 <kmc> it took much longer to get to the point where it's an attractive option for day to day data munging stuff
21:58:52 <elliott> So, "fluent" I guess is basically when I stopped feeling friction from the language, and my average solutions stopped feeling overcomplex and klunky like I was fighting the language.
21:58:54 <kmc> of course one lesson you learn is that a day-to-day data munger and a compiler aren't as different as you might think
22:01:34 <wavewave> my case is probably pretty different from others maybe. i started to learn haskell for doing numerical simulation for real work.
22:04:16 <wavewave> starting from rather strange reason. just happen to look at hmatrix tutorial.
22:04:43 <penryu> pikhq_: please. I'm trying to eat here.
22:06:37 <wavewave> and later got to know haskellForMaths...
22:10:08 <wavewave> at that time, I need some Grobner basis algorithm for my work.
22:15:52 <tgeeky> wavewave: possibly (probably) unrelated: http://hackage.haskell.org/package/Operads
22:16:28 <tgeeky> in the sense that it may not be useful to you
22:16:53 <wavewave> tgeeky: oh thanks, didn't know it.
22:17:07 <tgeeky> also, the standard mathematical starting point is NumericPrelude
22:17:50 <tgeeky> there is also a package that has several different monomial orderings
22:18:02 <tgeeky> i think it is HaskFoRmaths
22:18:33 <tgeeky> also, there's np-extras http://hackage.haskell.org/packages/archive/np-extras/0.2.0.2/doc/html/MathObj-Monomial.html
22:18:40 <tgeeky> for a simpler monomial representation
22:18:53 <tgeeky> geared toward cycle index series
22:19:08 <wavewave> tgeeky: HaskFoRMaths is different from HaskellForMaths?
22:19:15 <tgeeky> wavewave: no, I was just being lazy
22:20:55 <wavewave> tgeeky: thanks for introducing those packages.
22:22:06 <wavewave> I was talking about how I started haskell for rather practical reason.
22:22:15 <tgeeky> geometric algebra?
22:22:53 <wavewave> some physics measurement stuff.
22:23:03 <kmc> hey, you got geometric algebra in my algebraic geometry!  hey, you got algebraic geometry in my geometric algebra!
22:23:18 <tgeeky> my second guess was physics, but a QM phsycist, so I assumed otherwise
22:23:51 <tgeeky> wavewave: there's also this:
22:23:53 <tgeeky> http://www.normalesup.org/~oudomphe/programs/Polynom/Algebra-GroebnerBasis.html
22:24:29 <wavewave> I am a particle physicist.
22:24:36 <wavewave> tgeeky: oh good.. thank you very much.
22:24:47 <tgeeky> I am talking goose!
22:25:08 <wavewave> great. ^^
22:25:11 <tgeeky> what is that other one? I am a peanut butter and jelly sandwhich.
22:25:27 <tgeeky> sounds too long.
22:27:05 <wavewave> ^^
22:27:06 <tgeeky> i am a jelly doughnut! that's it.
22:27:35 <tgeeky> ok, actually, I'm a feeble human and hence need sleep. Good luck!
22:28:02 <wavewave> tgeeky: thanks again for those material.
22:28:29 <tgeeky> wavewave: yep. let me know what you're working on / if you have other questions.
22:30:19 <wavewave> tgeeky: if you are interested, this is the paper I used haskell for the first time: http://prl.aps.org/abstract/PRL/v104/i8/e081601
22:31:01 <wavewave> oops... it's password controlled.
22:31:20 <tgeeky> http://arxiv.org/abs/0910.1149
22:31:26 <wavewave> yes.
22:32:21 <elliott> bracket is no good if your action that actually uses the resource forks off a thread, right?
22:34:17 <tgeeky> wavewave: for what it's worth, someone is also porting ROOT, to HROOT
22:34:25 <tgeeky> http://hackage.haskell.org/package/HROOT-0.6.6
22:34:33 <wavewave> tgeeky: that's me ;-P
22:34:49 <tgeeky> wavewave: oh. well that's a hell of a task :)
22:35:04 <wavewave> thanks ;-)
22:37:40 <luite> whoah that looks very unhaskelly. are you going to build a higher level interface on this, or is it actually less bad than it looks?
22:37:58 <tgeeky> wavewave: is the idea in the above paper being run over CMS/ATLAS (or the little kids?) currently?
22:38:10 <tgeeky> luite: hroot?
22:38:17 <elliott> I wish finally's arguments were flipped.
22:38:28 <luite> tgeeky: yeah
22:38:32 <wavewave> tgeeky: I am collaborating with those guys now.
22:38:58 <tgeeky> luite: yeah, I got the same impression. ROOT is pretty non-haskelley, and is rather well-ingrained
22:39:43 <wavewave> luite: it's very unhaskelly, that's true. To reduce any creativity to port C++ library.. ;-P
22:40:02 <wavewave> luite: but how to use is not that bad.
22:40:11 <tgeeky> wavewave: ok. I'm significantly further toward the theoretical and away from the experimental, but I am sure we can talk in the future.
22:40:41 <shachaf> elliott: I think it's meant to be used infix or something.
22:40:41 <wavewave> tgeeky: definitely! good to know you!
22:41:05 <elliott> shachaf: Yeah, but, currying. :(
22:41:28 <elliott> shachaf: "finally blah . handle foo" reads nicely.
22:42:19 <shachaf> (`finally` blah)
22:42:57 <elliott> shachaf: Ugly.
22:46:53 <marvinalone> What does it mean when GHC says "Undefined symbols: "_Foo_bar_closure", referenced from: <bla bla bla>?
22:47:53 <kmc> most likely, that you're using GHC 6.x and did not pass the --make flag
22:48:05 <adrake> why does readSTRef eat so much time and memory? ideally, shouldn't it just copy one pointer?
22:48:29 <kmc> how did you determine that it's eating so much time and memory?
22:48:52 <elliott> huh, does ghc seven do --make by default?
22:48:59 <kmc> perhaps you are storing an unevaluated thunk inside the STRef, and then forcing it when you read
22:49:01 <kmc> elliott, yes
22:49:04 <elliott> neat
22:49:22 <kmc> yes
22:49:23 <kmc> <3
22:49:31 <kmc> GHC team cares about usability!
22:49:38 <wavewave> kmc. elliott : oh really? I didn't know it..
22:49:45 <kmc> 7 got support for "import" statements in GHCi, including "import qualified etc"
22:49:51 <kmc> 7.4 will have data declarations in ghci, iirc
22:49:52 <elliott> kmc: wow, that wasn't in six?
22:49:55 <kmc> nope
22:49:56 <elliott> I'm spoilt
22:50:02 <kmc> in GHC 6 you just have :m
22:50:04 <elliott> yeah
22:50:07 <coppro> now I can't wait for 7.4
22:50:07 <kmc> yeah, those were dark days
22:50:08 <marvinalone> heh, awesome. thanks!
22:50:34 * kmc started on GHC 6.4, he thinks
22:50:35 <adrake> kmc: the built-in profiler assigns it some large percentage of my program's allocations, with -auto-all and +RTS -Pa -RTS
22:50:39 <marvinalone> what does --make do for me?
22:50:40 <kmc> new features: STM, GADTs
22:50:52 <marvinalone> in other words, if i wanted to do it myself, what would i do?
22:51:00 <kmc> marvinalone, automatically finds the right packages to enable, and then passes the right flags to the linker
22:51:18 <kmc> marvinalone, in a direct sense, you'd say ghc -package mtl -package containers -package whatever-other-pkg-youre-using
22:51:27 <kmc> but in a practical sense, you'd build your project with Cabal
22:51:34 <kmc> which you should do anyway, because Cabal is great
22:51:40 <kmc> (it uses --make anyway, behind the scenes)
22:51:56 <adrake> kmc: would thunks get balled into that? GHC doesn't show any substantial cost centers below readSTRef
22:52:04 <kmc> I'm not sure
22:52:05 <wavewave> kmc : you are ghc6.4 generation.
22:52:28 <kmc> adrake, do you get different results if you change the write to «writeSTRef foo $! value»?
22:53:57 <adrake> kmc: not drastically
22:54:18 <adrake> within 0.1% everywhere
22:56:25 <kmc> hm
22:57:27 <wavewave> adrake: if you can show us snippet of your code, it will be helpful..
22:58:00 <adrake> wavewave: it is 2500 lines of haskell
22:59:19 <adrake> I don't think I can really produce a meaningful/runnable snippet of an elaborator for a C-like language :P
23:00:12 <wavewave> ?
23:00:39 <shachaf> kmc: Remember the GHC 6.6 release?
23:00:43 * shachaf vaguely remembers that.
23:00:59 <kmc> I think I was too noob to notice
23:01:06 <kmc> I remember being excited about 6.8, though
23:01:26 <shachaf> 6.6 introduced things like the threaded RTS.
23:01:29 <kmc> the big news in 6.6 was... -threaded o_O
23:01:38 <kmc> so 6.4 had STM with a single-threaded runtime?
23:01:40 <shachaf> "GHC now handles impredicative polymorphism"
23:01:47 <wavewave> oh.... threaded was from 6.6..
23:01:49 <shachaf> kmc: Best kind of STM.
23:01:56 <companion_cube> threaded RTS... neat
23:02:20 <kmc> also new in 6.6: the LANGUAGE pragma!
23:02:29 <kmc> but I used -fglasgow-exts because it's better clearly
23:02:37 <adrake> how do I read the heap profile cost center names?
23:02:54 <adrake> they are foo/bar/baz/...
23:03:10 <adrake> is that callee, caller, caller, caller, ... ?
23:03:49 <wavewave> adrake: hmm, I may give some general comments..     there are several runtime (RTS) options for heap profiling (-hc, hr, hy, hd.. )
23:04:14 <shachaf> -fglasgow-exts is great.
23:04:23 <shachaf> They stopped adding new extensions to it, though.
23:04:26 <wavewave> adrake: you can use SCC pragma for some specific pinpoint cost center.
23:04:28 <shachaf> I wish I could still use it in ghci.
23:05:51 <elliott> There should be a way to turn on literally every extension.
23:05:54 <elliott> Including the ones starting No.
23:07:22 <elliott> "New command-line option -fth to enable Template Haskell. Template Haskell is still enabled by -fgasgow-exts too."
23:07:28 <elliott> shachaf: -fgasgow-exts > -fglasgow-exts.
23:07:39 <ion> -fgascow-exts > -fgasgow-exts
23:07:49 <kmc> ghc $(ghc --supported-languages | sed 's/^/-X/')
23:07:54 <elliott> The following deprecated features have been removed: _ccall_, _casm_, ``...'' (literal-literals), the CCallable and CReturnable classes. These features have been obsoleted by the Foreign Function Interface for some time now.
23:07:57 <elliott> What the heck is a literal-literal?
23:08:04 <shachaf> elliott: -fgasglow-exts is even better.
23:08:11 <kmc> i'm guessing some TH nonsense
23:08:17 <kmc> but dunno
23:08:40 <shachaf> {-# LANGUAGE FigurativeLiterals #-}
23:08:48 <elliott> kmc: They say the FFI obsoleted them.
23:08:51 <elliott> 6.2 was a boring release.
23:09:06 <elliott> Ah, 6.0 introduced TH.
23:09:12 <shachaf> What was the last version that supported Haskell 1.good?
23:09:18 <elliott> And --make.
23:09:21 <elliott> Or, well.
23:09:25 <elliott> --make with hierarchical models.
23:10:00 <elliott> Modules.
23:10:11 <elliott> "Data.Bits: shiftL, shiftR, rotateL, and rotateR are now methods of the Bite class."
23:10:14 <elliott> instance Bite Integer where ...
23:11:17 <elliott> kmc: shachaf: No, you are totally wrong. 6.0 release notes mention threaded RTS.
23:11:22 <elliott> "Several bugs have been fixed in the threaded RTS, and it should now be rather more robust (it should still be considered experimental, however)."
23:11:53 <shachaf> elliott: Oh.
23:12:12 <shachaf> «GHC now supports SMP: when you compile with -threaded, you now get an RTS flag -N that allows you to specify the number of OS threads that GHC should use. Defaults to 1. See Section 4.12, “Using SMP parallelism” and Section 7.15, “Parallel Haskell”.»
23:12:53 <elliott> What release was that?
23:13:16 <shachaf> 6.6
23:13:52 <elliott> shachaf: I guess it supported OS threads but not SMP somehow?
23:14:04 <elliott> shachaf: Oh.
23:14:07 <elliott> shachaf: That's _parallelism_.
23:14:13 <elliott> GHC supported threaded concurrency, but not parallelism. I think.
23:14:25 <shachaf> Oh. par etc.?
23:14:49 <elliott> shachaf: Presumably, yes. This is just a guess, but the reference to "parallelism" makes me believe...
23:15:08 <shachaf> elliott: But +RTS -Nn affects your forkIO threads too...
23:15:18 <elliott> Baah, I don't know. Ask someone who knows.
23:15:30 <elliott> Anyone have GHC 5.0 release notes? :-
23:15:31 <elliott> :-p
23:16:05 <shachaf> http://www.haskell.org/ghc/docs/5.04/html/users_guide/release-5-04.html
23:16:26 <elliott> That's .04 more. :-(
23:16:40 <elliott> shachaf: Wow, they had RULE pragmas before TH?
23:16:56 <shachaf> Are those related?
23:16:56 <Quantumplation> Friend challenged me to find 10 people under 50 and above 20 that can use old style BBS systems (usenet etc)
23:17:08 <elliott> shachaf: It just, I don't know.
23:17:19 <elliott> "The -fall-strict flag never really worked, and has been removed." Wow, that sounds like a hoot.
23:17:25 <djahandarie> I'm only 19, I don't count?
23:17:44 <Quantumplation> He says you count as .5
23:18:04 <elliott> So when did 5.04 come out?
23:18:09 <shachaf> What does "can use old style BBS systems (usenet etc)" mean?
23:19:09 <elliott> Usenet is unrelated to BBS systems, isn't it?
23:19:10 <adrake> is  internal error: Invalid object in processHeapClosureForDead(): 58, when ctrl-cing a profiled program normal?
23:19:11 <Quantumplation> his words: "can actively access, read, and post"
23:20:10 <shachaf> Seems like a silly question.
23:20:25 * shachaf has posted to Usenet at least once and read from Usenet at least once.
23:20:32 <shachaf> Anyway ageism is bad.
23:20:47 <elliott> Almost as bad as BBSes.
23:20:56 <elliott> Brrrrrn.
23:20:58 <companion_cube> nntp is a pretty col protocole
23:21:06 <elliott> It's the collest protocole.
23:21:17 <companion_cube> cool* -_-
23:21:31 <shachaf> colleste protocole offe ole?
23:21:41 <companion_cube> aixe at lee
23:21:59 <shachaf> "In Haskell 98, it is illegal for class method types to mention constraints on the class type variable."
23:22:03 <shachaf> Is that true?
23:22:31 <companion_cube> it seems reasonable
23:22:47 <companion_cube> otherwise you would not be sure to be able to use the instance in all situations
23:22:48 <elliott> shachaf: That surprised me too.
23:25:02 <copumpkin> anyone have a mac OS build of HEAD with constraint kinds lying around?
23:25:54 <djahandarie> I keep one in my backpack
23:26:03 <djahandarie> You never know when you might need one
23:27:27 <Veinor> is there a way to say 'look at every file in this directory and tell me what ghc will warn on'?
23:29:18 <frerich> Veinor: There is a program called 'hlint' which may be able to do this, I don't know.
23:29:21 <Veinor> apparently ghc doesn't properly detect exhaustive patterns with view patterns
23:29:34 <Veinor> i have myFunc (f -> Nothing) = ...; myFunc (f -> Just x) = ...
23:29:58 <elliott> Doesn't that evaluate (f x) twice.
23:30:09 <shachaf> elliott: I think it's guaranteed not to.
23:30:27 <elliott> Huh.
23:31:12 <Veinor> it's telling me that the pattern is non-exhaustive
23:31:13 <Veinor> :|
23:31:50 <shachaf> Veinor: Odd.
23:32:01 <elliott> Veinor: ISTR a bug report about that.
23:32:32 <kmc> can't you run GHC in some "don't actually compile" mode?
23:32:33 <elliott> it was kind of ridiculous; the devs said that e.g. myFunc (unsolvedProblem -> True) = ... might be exhaustive but you can't know
23:32:40 <elliott> despite the fact that the same problem exists for regular exhaustive checks
23:32:54 <Veinor> elliott: oh, that's kind of silly
23:33:01 <shachaf> elliott: Right, but if you match all the patterns it shouldn't matter, should it?
23:33:10 <elliott> shachaf: that's what everyone else said
23:33:13 <elliott> IIRC, this means that every view pattern is considered inexhaustive :P
23:33:23 * elliott thinks someone was just trying to avoid having to fix a bug.
23:33:41 <shachaf> No, (f -> _) isn't, at least.
23:33:44 <Veinor> also, hlint doesn't warn on stuff like unused imports
23:33:49 <elliott> shachaf: The most useful pattern.
23:34:07 <Veinor> elliott: you can use it as a default
23:34:10 <elliott> Veinor: You could just run ghc and set all its dirs to somewhere in /tmp then rm -r it.
23:34:13 <shachaf> I wonder if (f -> _) even runs f
23:34:19 <elliott> Veinor: You can skip linking, so it should be pretty fast.
23:34:21 <Veinor> also i just used ghci -W
23:34:40 <elliott> I like how -W/-Wall are the other way around in GHC than gcc.
23:34:48 <Veinor> what, really?
23:34:52 <elliott> Yes.
23:34:58 <elliott> ghc: -W is just "some warnings", -Wall is nearly everything.
23:35:11 <elliott> gcc: -Wall is "some warnings", -W is deprecated for -Wextra which is "lots of things".
23:35:20 <elliott> (Not "nearly everything", because gcc has about ten billion warning types.)
23:35:23 <Veinor> haha
23:35:28 <kmc> buh
23:35:36 <kmc> -fheinous-gnu-extensions
23:35:48 <kmc> i look forward to thc -fheinous-glasgow-exts
23:35:51 <elliott> -Wcode-that-maybe-makes-you-think-what-the-author-was-thinking
23:36:12 <elliott> -Wactually-just-warn-for-every-line-of-code-I'm-not-sure-about-this-code-base-in-the-slightest
23:36:37 <kmc> -Weffc++
23:36:50 <elliott> -Wno-errors
23:36:52 <shachaf> preflex: karma -Weffc
23:36:53 <preflex>  -Weffc: 45
23:36:58 <elliott> What.
23:37:05 <elliott> Is that a real option?
23:37:09 <shachaf> Yep.
23:37:11 <elliott> Wow.
23:37:18 <elliott> I...
23:37:20 * shachaf decides not to ruin it for elliott.
23:37:28 <elliott> Aww, it's not that kind of eff.
23:37:35 <elliott> I almost liked gcc.
23:37:48 <Veinor> -Weffc++ warns if your code implements drm
23:37:56 <elliott> I was hoping it would, like, explicitly fail whenever anything written in C++ was encountered. extern "C"? BEEEEP.
23:38:13 <srh> Hey.  I'm curious about GHC and multithreading.  When forcing a thunk, are there atomic ops involved?
23:38:26 <elliott> preflex: karma C--
23:38:26 <preflex>  C--: 10
23:38:29 <elliott> preflex: karma C--++
23:38:29 <preflex>  C--++: -2
23:38:31 <elliott> preflex: karma C--++--
23:38:31 <preflex>  C--++--: 1
23:38:33 <elliott> preflex: karma C--++--++
23:38:33 <preflex>  C--++--++ has no karma
23:38:43 <elliott> preflex: karma C--++--++
23:38:43 <preflex>  C--++--++ has no karma
23:38:46 <elliott> preflex: karma C--++--
23:38:46 <preflex>  C--++--: 3
23:38:48 <elliott> Heh.
23:38:56 <Veinor> :|
23:41:37 <shachaf> srh: Are you trying to get actual Haskell discussion in here?
23:41:48 <shachaf> srh: (I don't know, but #ghc might.)
23:42:10 <srh> yes
23:42:27 <srh> that's for ghc development supposedly
23:43:43 <elliott> srh: GHC devs know a lot about gritty GHC internals.
23:45:56 <elliott> "show (reverse []) (which is what GHCi computes here) has type Show a => a"
23:45:59 <elliott> This manual makes some rather strong claims.
23:47:30 <srh> you misspelled "wrong"
23:47:52 <elliott> srh: Well, maybe Show had superclass (a ~ String) in those days.
23:47:56 <elliott> Even though ~ wasn't a thing yet.
