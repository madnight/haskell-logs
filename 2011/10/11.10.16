00:00:09 <edwardk> deck.js is pretty cute
00:00:10 <kmc> deck.js and slidy look nicer than that
00:00:39 <kmc> maybe i could have fixed my S5 with a little custom css
00:00:49 <kmc> but i'm pretty happy with my current setup
00:00:51 <eyu100> I can't seem to debug an infinite loop in my program; I don't know where to start
00:01:12 <kmc> eyu100, maybe use Debug.Trace to figure out the specific sequence of infinite function calls
00:01:19 <eyu100> k
00:02:43 <geheimdienst> kmc: re edwardk's problems, well yeah, whatever fancypants technology you use, it can't replace being a good teacher. keynote or deck.js or chalk-on-blackboard, you only get a good talk by thinking a lot about how to put it and what perspective makes best sense
00:03:00 <kmc> yeah
00:03:25 <kmc> i got a ton of useful feedback on my "why learn haskell" talk
00:03:42 <kmc> of course some of it was like "you should give this completely different talk instead"
00:04:03 <kmc> but some of it was specific and direct
00:04:28 <Axman6> "The talk was great, but you should start with how Haskell is exactly like Java, then people will feel more comfortable"
00:04:36 <tactics> kmc: What kind of audience was it?
00:04:53 <kmc> i gave it for the Boston Haskell group
00:04:58 <kmc> first
00:05:00 <manjunaths> mauke, can you tell which library I can include to fix this ?
00:05:10 <manjunaths> What do I do something like -lposix ?
00:05:18 <mauke> manjunaths: -package haskell98
00:05:28 <kmc> which served a dual purpose: a) we had a good discussion about how to teach haskell, b) bring your friends and convert them ;)
00:05:35 <kmc> then i gave the talk for another group at MIT
00:05:45 <kmc> about a month later, with several changes based on the first go round
00:08:46 <eyu100> damn
00:08:53 <eyu100> there's too many functions to trace them all
00:09:08 <eyu100> and the only one that would seem to cause any trouble wasn't causing the problem, because it never got called
00:10:05 <eyu100> in fact, the cpu was not being used at 100%
00:10:32 <eyu100> it wasn't being used at all...
00:10:42 <kmc> you could try the normal time profiling mechanism
00:10:50 <kmc> you still get output even if you hit ^C, right?
00:11:09 <eyu100> I type the thing I want to evaluate in and *nothing* happens
00:11:18 <eyu100> no output, not even any noticeable cpu activity
00:11:25 <kmc> in ghci?
00:11:27 <eyu100> and my function isn't IO-dependent
00:11:30 <eyu100> kmc: yes
00:11:52 <kmc> you probably have unintended recursion somewhere
00:12:00 <shachaf> eyu100: Is it small enough to @paste?
00:12:03 <kmc> like you wrote «let x = f x» when you meant «let x' = f x»
00:12:12 <kmc> anyway, compile your code and run it with profiling
00:12:37 <kmc> either it will loop and the profile tells you where
00:12:43 <kmc> or it aborts with "<<loop>>" and you can use +RTS -xc
00:12:45 <kmc> @where RTS-xc
00:12:46 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
00:13:03 <eyu100> k will try
00:13:19 <eyu100> damn I need to add a main func then...
00:13:31 <shachaf> I wonder if having -W in the style of -X would be good.
00:13:35 <kmc> it's not a function :)
00:13:41 <eyu100> lol
00:14:01 <shachaf> E.g. {-# WARN DodgyImports #-} and -W{No,}DodgyImports, instead of the assortment of -f flags we have now.
00:15:36 <eyu100> lol you know what happened?
00:15:39 <eyu100> my code was fine
00:15:45 <eyu100> but I created an infinite loop in ghci
00:16:03 <eyu100> offending line: let (h,t,trees) = update (h,t,trees) (MkA [One]) (MkO [One], MkR [One])
00:16:26 <eyu100> damn nvm
00:16:29 <eyu100> that didn't fix the problem
00:16:53 <eyu100> kmc: is there profiling in ghci?
00:17:06 <shachaf> Not really. You'll need to compile your code.
00:22:30 <eyu100> lol
00:22:34 <eyu100> it worked when I compiled it
00:22:37 <eyu100> but not in ghci
00:23:14 <eyu100> (well it works in ghci when I run the main function)
00:23:19 <eyu100> maybe I was just testing wrong
00:23:48 <jmcarthur> shachaf: {-# OPTIONS -fdodgy-imports #-}  ?
00:24:17 <shachaf> jmcarthur: Right, but you might as well have the same thing for LANGUAGE.
00:24:53 <shachaf> Maybe warnings are different enough across compilers that there's no sense in "standardizing" them, which might've been the main point of LANGUAGE.
00:25:04 <shachaf> Also, GHC will get angry if you use OPTIONS instead of OPTIONS_GHC
00:27:25 <ddarius> main should be a function...
00:27:53 <shachaf> Why?
00:28:20 <Veinor> ddarius: of what type?
00:28:29 <ddarius> shachaf: I would like to get rid of ambient authority.
00:29:49 <Veinor> ?
00:30:48 * ddarius has no idea why people need to differentiate between special cases of type class polymorphism and compare them to totally different mechanisms.
00:31:09 <kmc> example?
00:31:32 <ddarius> kmc: "return type polymorphism" "value polymorphism"
01:21:05 <manjunaths> When compiling this file http://hpaste.org/52683, I get this error, http://hpaste.org/52682. Please, can anyone tell me how to fix this ?
01:21:34 <shachaf> manjunaths: You need IORef.
01:21:36 <shachaf> @hoogle IORef
01:21:37 <lambdabot> module Data.IORef
01:21:37 <lambdabot> Data.IORef data IORef a
01:21:37 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
01:21:39 <shachaf> import that
01:23:04 <shachaf> manjunaths: Also, don't use -fglasgow-exts. It's evil.
01:23:09 <manjunaths> ah...cool. Thanks.
01:23:43 <manjunaths> shachaf, This is a package I downloaded (hsshellscript). This came in the stock makefile, I don't know enough to fix the makefile.
01:23:54 <manjunaths> shachaf, what is the replacement to -fglasgow-exts ?
01:24:27 <shachaf> manjunaths: Well, enabling whihever extensions you're actually using.
01:24:34 <shachaf> I don't know anything about hsshellscript, though.
01:24:36 <manjunaths> shachaf, ah...got it
01:24:49 <manjunaths> shachaf, Ok.
01:37:04 <tryhaskell> Hi!
01:37:39 <shachaf> tryhaskell: Hello!
01:56:14 <tactics> Anyone want to help me with dis-ambiguating a grammar I want to code in Parsec?
01:56:15 <tactics> http://hpaste.org/52686
01:56:46 <tactics> It's been forever since I've done anything with parsers
01:57:27 <ivanm> I'm trying to port vacuum to use my graphviz library rather than direct text mangling
01:57:44 <ivanm> yet I find it mentions an attribute that doesn't exist...
02:10:04 <mah_b> tactics: what have you tried so far?
02:12:11 <tactics> mah_b: Hacking it together :)
02:12:28 <tactics> mah_b: It froze once, which I thought was kinda fun
02:12:36 <tactics> Right now I'm looking into http://en.wikipedia.org/wiki/Left_recursion#Removing_left_recursion
02:12:40 <tactics> which is I think what I want
02:12:45 <Gracenotes> > ord '0' - ord '1'
02:12:46 <lambdabot>   -1
02:12:58 <mah_b> tactics: could you paste this, too?
02:13:56 <tactics> mah_b: It's kinda big and messy. I'm gonna work on it a while and see where I get
02:21:34 <heiz> Hi! I have let a = ... in let b = ... in ... Can I expect that a will be computed before b or not?
02:22:01 <shachaf> heiz: Nope.
02:22:03 <b_jonas> heiz: no, you can't, and in Haskell you can't observe what's computed first anyway
02:22:09 <shachaf> heiz: a might not be computed at all if you don't use it.
02:22:17 <shachaf> And you have no guarantees about order of evaluation.
02:22:27 <heiz> ok. thanks
02:25:01 <ivanm> where does one find the "Bag" module?
02:25:07 <ivanm> vacuum seems to use it :/
02:26:13 <b_jonas> ivanm: in the EdisonAPI package
02:26:23 <shachaf> There's one in the package "ghc".
02:26:29 <ivanm> well, vacuum has never depended upon it AFAIK :s
02:26:57 <b_jonas> oh, I thought you just wanted any bag-like structure
02:26:59 <b_jonas> sorry
02:27:13 <ivanm> shachaf: what's the difference between ghc and ghc-prim?
02:27:19 <ivanm> since vacuum already imports ghc-prim
02:27:45 <shachaf> I think ghc-prim just gives you, er, GHC.Prim, maybe?
02:27:59 <shachaf> Which is for public use. Or something.
02:28:26 <ivanm> OK
02:28:38 <b_jonas> ivanm: I think ghc gives interface the the compiler stuff itself, whcih most programs won't use in runtime, not even indirectly; whereas ghc-prim gives you low-level stuff you rarely use directly but almost always use indirectly
02:28:47 <edwardk> ivanm: ghc-prim is used to get GHC.Prim so you can play around with Int#, etc.
02:28:51 <ivanm> wait, kfish doesn't seem to have uploaded the latest version to his github...
02:29:00 <ivanm> which might explain why I can't build it :s
02:29:03 <shachaf> GHC.Prim has things like Int#
02:29:27 <shachaf> Or maybe just Word#
02:29:35 <edwardk> it has both of those
02:29:38 <ivanm> possibly also if he's built it against 7.2 when I'm still using 7.0
02:30:55 <tactics> @src char
02:30:55 <lambdabot> Source not found. It can only be attributed to human error.
02:31:18 <shachaf> @src Char
02:31:18 <lambdabot> data Char = C# Char#
02:31:52 <mah_b> @src Text.ParserCombinators.Parsec.char
02:31:53 <lambdabot> Source not found. stty: unknown mode: doofus
02:32:22 <tactics> What I was looking for, apparently, was TokenPrim
02:33:04 <b_jonas> that sounds scary
02:35:43 <tactics> b_jonas: tokenPrim or C# Char#?
02:36:37 <b_jonas> TokenPrim
02:39:20 <tactics> b_jonas: apparently, you need to define it so parsec can operate on streams other than Char's
02:46:32 * hackagebot snap-core 0.5.5 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.5 (GregoryCollins)
02:46:34 * hackagebot snap-server 0.5.5 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.5 (GregoryCollins)
02:51:32 * hackagebot snap 0.5.5 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.5 (GregoryCollins)
03:30:54 <k0ral> dcoutts: any comment regarding my last request on the mailing list ?
03:34:01 <hpaste> edwardk pasted “multi-core Barendregt convention” at http://hpaste.org/52687
03:42:44 <mm_freak> which package is generally recommended to generalize forkIO?
03:43:09 <edwardk> mm_freak: in the monad transformer sense?
03:43:18 <edwardk> mm_freak: i dunno if i ever release mine
03:43:24 <edwardk> er released
03:43:39 <mm_freak> edwardk: i'm finding the forkable-monad library
03:43:52 <mm_freak> it looks reasonable as it depends only on transformers
03:44:17 <edwardk> *nods*
03:46:04 <mm_freak> edwardk: does your library provide instances for other monads than StateT and ReaderT?
03:46:39 <edwardk> some yoneda-ish stuff at least =)
03:46:54 <edwardk> might have cont too
03:47:01 <edwardk> not remembering
03:47:26 <mm_freak> hmm
03:47:51 <tsousa> in this code http://dpaste.com/635254/ how Haskell know what is right or left?
03:48:01 <edwardk> or ErrorT
03:48:15 <mm_freak> i'm not sure whether i want to make my library depend on my own transformer library…  it has its own Forkable class with instances for MaybeT, ContT, EitherT, StateT and ChoiceT
03:48:45 <edwardk> tsousa: those are just names assigned by 'treeInsert x (Node a left right)'
03:48:50 <edwardk> that is a pattern
03:48:52 <mm_freak> would be convenient, but i think i'm the only user of contstuff
03:49:30 <edwardk> tsousa: you could just as easily have called them 'treeInsert x (Node a bob fred)' and you'd have to talk about the bob child and the free child of your Node.
03:49:45 <edwardk> er fred child
03:50:13 <tsousa> edwardk, but in which part of the code those the author assigned that names?
03:50:20 <shachaf> * edwardk writes post on free children of trees
03:50:37 <edwardk> foo x y = … is assigning the names x and y within ...
03:51:02 <edwardk> foo (Node a l r) = … is where be binds the names a l and r in ...
03:51:38 <edwardk> singleton x = Node x EmptyTree EmptyTree -- is him binding the name x to the argument to singleton and using it in the right hand side
03:51:49 <tsousa> ok thanks
03:52:00 <edwardk> in the case of treeInsert x (Node a l r) = … you are binding the names to the individual fields of Node in positional order
03:52:20 <mm_freak> edwardk: are you planning to release your library?
03:52:31 <tsousa> men Haskell is freacking hard
03:52:56 <edwardk> mm_freak: probably not since nobody has mentioned any need for it prior to now and i don't know how bitrotted its become
03:53:04 <edwardk> i think it was in the mtl 1.x era
03:53:17 <edwardk> so it'd be a bit of work
03:53:22 <mm_freak> uh
03:53:46 <mm_freak> ok, then i'll probably write my own library or ask the author of forkable-monad…  last release is from 2010
03:54:15 <mm_freak> tsousa: haskell is very logical…  it's hard for people coming from illogical languages (it was hard for me)
03:54:37 <mm_freak> tsousa: you really need to think very simple to understand haskell best
03:58:40 <Gracenotes> > ord '0' - ord '1'
03:58:41 <lambdabot>   -1
03:58:51 <Gracenotes> compulsive up arrowing
04:08:52 <tsousa> another question. http://dpaste.com/635254/ why it returns a new tree?
04:10:14 <sipa> how do you mean?
04:10:25 <sipa> why doesn't it modify the original one
04:10:26 <sipa> ?
04:10:37 <engla> tsousa: values are immutable in haskell
04:11:19 <tsousa> engla, why it cant just return the value that i am looking for?
04:11:37 * hackagebot derive-trie 0.2 - Automatic derivation of Trie implementations.  http://hackage.haskell.org/package/derive-trie-0.2 (AndreasBaldeau)
04:11:54 <shachaf> engla: http://hpaste.org/52266
04:11:56 <engla> tsousa: treeInsert is not about looking for values
04:13:15 <tsousa> men i am not understanding the guard. i am freacking out
04:13:53 <sipa> tsousa: what are you trying to do, and how do you expect it to be possible differently?
04:14:15 <mm_freak> tsousa: your code looks perfectly reasonable to me, except some style points
04:14:16 <tsousa> sipa, i am trying to understand how the function works
04:14:19 <engla> shachaf: thanks, I always wanted to do that.. (no)
04:14:33 <sipa> tsousa: first, do you know what it is supposed to do?
04:14:41 <tsousa> mm_freak, the code is not mean, i only trying to understand it
04:14:54 <mm_freak> "mean"?  "mine"?
04:15:00 <tsousa> sipa, insert a value in a list
04:15:05 <tsousa> mm_freak, yes sorry
04:15:12 <mm_freak> tsousa: it's not a list, it's a tree
04:15:12 <sipa> tsousa: a list?
04:15:22 <tsousa> sipa, in a tree sorry
04:15:25 <sipa> ok
04:15:28 <mm_freak> tsousa: you can read the code literally
04:15:45 <mm_freak> if the new element is larger than the root of the tree, then it tries to insert it into the right subtree
04:15:55 <mm_freak> if it's equal, it just returns the tree as it is
04:16:04 <mm_freak> if it's smaller, it inserts into the left subtree
04:16:14 <mm_freak> this is recursive…  the subtree becomes the root of the recursive call
04:16:23 <tsousa> humm
04:17:37 <mm_freak> example:  the new element is smaller than the current root node…  so it returns the same tree, except with the value inserted into the left subtree…  this insertion just assumes that the left subtree is the root…  it decends into the tree
04:18:17 <mm_freak> you never have a "top root"…  you always work with subtrees
04:19:02 <tsousa> mm_freak, ok i now understand
04:19:17 <shachaf> It smells like uproot in here.
04:20:25 * shachaf >>=
04:20:54 * mm_freak <+> zeroArrow = zeroArrow
04:20:58 <mm_freak> i'm a singularity
04:21:45 <mm_freak> or perhaps i'm just zeroArrow =)
04:22:12 <mm_freak> for arrow syntax there should be a way to abbreviate "-< ()"
04:22:29 <mm_freak> it could just follow from context…  that would be great
04:25:08 <mm_freak> is it hard to extend the syntactic extensions of GHC?
04:55:10 <Aymen> hello
04:59:03 <Aymen> i want install scion for eclipsefp plugin but i encounter some problems
05:04:02 <edwardk> is the old Splittable class still around?
05:11:00 <eleruin> Hi, I'm getting exactly the errors in http://hpaste.org/49135 when trying to cabal install nano-md5-0.1.2, does anyone know a solution?
05:16:38 * hackagebot mstate 0.2.4 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.2.4 (NilsSchweinsberg)
05:16:55 <Spockz> when you do a cabal update, which file is requested from the server?
05:19:13 <Saizan> 00-index.tar.gz
05:19:45 <Saizan> cabal update -v3 will show you the request
05:20:59 <eleruin> http://hpaste.org/49135
05:21:07 <eleruin> i'm sorry
05:21:12 <Spockz> Saizan: I'm interested in setting up a caching mirror for it
05:21:22 <eleruin> 00-index.tar.gz
05:22:46 <Spockz> the funny part is that downloading packages is fast enough, it's just that requesting the index is so slow
05:31:38 * hackagebot snap 0.5.5.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.5.1 (GregoryCollins)
05:44:08 <aristid> relevant: http://byorgey.files.wordpress.com/2011/05/monad_tutorial.jpg
05:45:43 <Axman6> anyone had any linker problems with 7.2.1 on OS X?
05:47:20 <tew88> Am working my way through Real World Haskell. I'm on chapter 5 and it's come to compiling code and creating an executable. I've copied the code *exactly* from the book, but get a compiler error informing me that "The main function `main' is not exported by module `Main'". Is this an error in the book, or has GHC changed its behaviour since the book's publication?
05:48:06 <tew88> (The issue is resolved when I omit the parantheses)
05:48:31 <tew88> parentheses*
05:49:12 <Saizan> have you shown the code?
05:49:33 <tijn> are you reading the book or the e-version on the net?
05:49:43 <mceier> tew88: does your code contain "module Main(main) where" ?
05:49:45 <tijn> because on the net there are comments with updates
05:50:00 <tew88> Ah, reading the book
05:50:11 <tew88> mceier: Guessed at that as the solution and it was fine
05:50:20 <tew88> It's just written in the book as: module Main () where
05:50:20 <tijn> I also had some problems with the code from the book
05:50:54 <tijn> it os good for reading but for programming I always check the version on the web
05:51:19 <tew88> tijn: Right. I'll make sure to refer to the web if I run into any such errors again. Cheers for the tip.
05:59:30 <dmwit> Guest81642: That code looks great. Bonus points if you draw up a patch to xmonad-contrib that adds it to IndependentScreens -- I'll happily apply it.
06:42:22 <mm_freak> haskell.org should have an openid service
07:10:18 <jweofijm> @pl \ x y -> x y y
07:10:18 <lambdabot> join
07:26:29 <alpounet> edwardk, ping
07:27:55 <Insolsence> Hey all
07:27:59 <Insolsence> I'm a noob to haskell
07:28:08 <Insolsence> coming from imperative languages
07:28:13 <kmc> that's cool
07:28:14 <Insolsence> I can't figure out how to get portion of a string in haskell
07:28:18 <kmc> Haskell is also an imperative language :)
07:28:24 <Insolsence> say I have a = "Hello!"
07:28:35 <Insolsence> How do I get just He
07:28:46 <Insolsence> in python, we could simply do a[0:2]
07:28:49 <kmc> > take 2 "Hello!"
07:28:50 <lambdabot>   "He"
07:28:53 <alpounet> take 2 a
07:28:55 <Insolsence> oh!
07:28:57 <kmc> > drop 2 "Hello!"
07:28:57 <lambdabot>   "llo!"
07:29:03 <kmc> > splitAt 2 "Hello!"
07:29:03 <lambdabot>   ("He","llo!")
07:29:27 <Insolsence> Ah!
07:29:29 <Insolsence> Thankyou!
07:50:07 <mm_freak> has anyone implemented a concurrent StateT monad transformer?
07:50:58 <mm_freak> something like:  newtype StateT s m a = StateT (TVar s -> m a)
07:51:21 <byorgey> @hackage mstate
07:51:21 <lambdabot> http://hackage.haskell.org/package/mstate
07:51:35 <byorgey> mm_freak: perhaps ^^^ ?
07:51:40 <byorgey> I haven't used it
07:52:16 <mm_freak> thanks
07:52:22 <mm_freak> yes, looks like what i need
07:53:02 <mm_freak> it uses monad-peel, though
07:53:06 <mm_freak> monad-control would have been better
08:05:18 <hjulle> What is the easiest way to perform a calculation while blocking on IO? Example: f x = getChar >> print (longCalculation x)
08:06:25 <hjulle> I want the longCalculation to be performed while the program is waiting for a keypress.
08:06:38 <kmc> you can do this with pure parallelism
08:06:40 <kmc> f x = x `par` (getChar >> print (longCalculation x))
08:06:55 <kmc> it might be less predictable than you want
08:07:08 <Axman6> or, let y = longComputation x in y `par` getChar >> print y
08:07:15 <kmc> er yes
08:07:17 <kmc> that's the correct one :)
08:07:20 <Axman6> ;)
08:07:46 <kmc> since you're integrating this with IO code, an alternative is to use actualthreads
08:08:14 <hjulle> Do I need to use DeepSeq to make it evaluate it compleatly?
08:08:16 <kmc> http://hackage.haskell.org/packages/archive/spawn/0.3/doc/html/Control-Concurrent-Spawn.html#g:1 is a little helper for performing asynchronous IO and later demanding the result
08:08:39 <kmc> however (spawn (return (longCalculation x))) isn't going to work
08:08:52 <kmc> the IO action returns immediately and produces a thunk
08:09:00 <kmc> but you could do something like
08:09:10 <hjulle> What is actualthreads?
08:09:13 <kmc> actual threads
08:09:18 <hjulle> aha :P
08:09:18 <kmc> like you get from forkIO
08:09:19 <Axman6> hjulle: probably. depents on the type of longComputation
08:09:40 <kmc> it depends on how much of longComputation you want to force
08:09:54 <kmc> i advise against throwing deepseq at everything
08:09:58 <Axman6> so, let y = deepSeq (longComputation x) in y `par getChar >> print y
08:10:10 <kmc> if you understand what's going on, it's usually possible to do it with primitive seqs only
08:10:25 <Axman6> uh, actually, that's wtong
08:10:28 <Axman6> wrong*
08:10:39 <kmc> f x = do t <- spawn (evaluate (longCalculation x)); getChar; t >>= print
08:10:46 <kmc> hjulle, that's my "actual threads" solution
08:10:46 <Axman6> let y = longComputation x in deepSeq y `par getChar >> print y
08:10:48 <hjulle> Well, to be honest what I actually want to do is @ plot myData >> plot (nextIteration myData)
08:10:56 <kmc> using 'evaluate' from Control.Exception
08:11:42 <Axman6> evaluate only evaluates to WHNF no?
08:12:10 <hjulle> What does evaluate do?
08:12:24 <Axman6> evaluates its argument to WHNF
08:12:35 <Axman6> before returning it
08:12:37 <kmc> yes
08:12:42 <hjulle> aha
08:12:43 <Axman6> evaluate :: a -> IO a
08:13:21 <kmc> you can do like:   evaluate (foo `using` rdeepseq)
08:13:29 <kmc> but again, deepseq is the brute force solution
08:14:22 <kmc> if you understand what's going on, it's usually possible to do it with primitive seqs only
08:14:23 <hjulle> When would I not want deepseq?
08:14:38 <Axman6> deepSeq [1..] is a bad idea
08:14:45 <kmc> when you don't want to waste time traversing the whole structure
08:14:53 <dylukes> > deepSeq [1..]
08:14:54 <lambdabot>   Not in scope: `deepSeq'
08:15:07 <hjulle> What I have is a matrix, which should be ploted
08:15:33 <hjulle> So I believe the whole structure is needed.
08:15:34 <dylukes> Right, but what if some of the thunks to calculate values in that matrix are non-terminating computations?
08:15:35 <kmc> deepseq is a code smell
08:15:49 <dylukes> Well... this is kind of a separate problem in of itself, but yeah.
08:15:50 <Axman6> i think deepSeq for list is: deepSeq [] = (); deepSeq (x:xs) = deepSeq x `seq` deepSeq xs
08:15:54 <kmc> better to use the proper combination of data with strict fields, whnf-strictness annotations on functions, etc.
08:16:10 <dylukes> If you're trying to get at the actual value hjulle, the thunk will have to be evaluated for it to be output.
08:16:29 <hjulle> dylukes: [non-evaluating]} Then the plotting will never terminate...
08:16:32 <kmc> if you have, say, a big binary tree of strings, then deep seq is going to traverse the *entire* tree and each Char of each string
08:16:41 <kmc> that's usually wasteful overkill
08:16:51 <kmc> that said... if it's fast enough, and gets the job done quicker, meh
08:17:25 <Axman6> well, if you know you need to evaluate the whole structure at some point, doing the evaluation in parallel might save some time
08:17:57 <kmc> i wonder if the GHC runtime could maintain a bit which records that a closure is in normal form
08:18:09 <hjulle> kmc: I probably should use more strict data-structures as you say.
08:18:32 <hjulle> kmc: Just not entirely sure how to do that.
08:19:40 <hjulle> [code-smell] I believe my code smells pretty much in other senses too...
08:20:57 <kmc> hjulle, the RWH chapter on optimization has some examples
08:21:07 <jweofijm> @pl \ d e -> a (b d) (c e)
08:21:08 <lambdabot> (. c) . a . b
08:21:46 <hjulle> kmc: ok, I'll check that out.
08:22:51 <Blkt> good evening everyone
08:23:13 <kmc> hi Blkt
08:28:11 <keep_learning> hello everyone
08:28:55 <kmc> hi keep_learning
08:29:02 <keep_learning> i created a file name Test.hs and import Test.Hunit but i am getting error
08:29:51 <hpaste> “Mukesh Tiwari” pasted “Module error” at http://hpaste.org/52690
08:31:06 <keep_learning> kmc, should i change the name of file Test.hs
08:31:24 <kmc> what's the error
08:31:35 <kmc> and did you try that
08:32:02 <hpaste> “Mukesh Tiwari” annotated “Module error” with “Module error (annotation)” at http://hpaste.org/52690#a52691
08:32:32 <kmc> the error message explains the problem
08:33:05 <keep_learning> kmc, i have intalled Hunit
08:33:44 <hpaste> “Mukesh Tiwari” annotated “Module error” with “Module error (annotation) (annotation)” at http://hpaste.org/52690#a52692
08:33:47 <kmc> the module is Test.HUnit not Test.Hunit
08:33:59 <keep_learning> kmc, ohh
08:34:05 <keep_learning> kmc, thank you
08:39:57 <hjulle> btw. why is sum in prelude defined with foldl (+) and not foldl' (+)
08:41:06 <Eduard_Munteanu> It works fine with optimizations turned on.
08:42:45 <hjulle> Eduard_Munteanu: Do you mean that they automatically adds strictness?
08:43:02 <Eduard_Munteanu> Yeah.
08:43:08 <Eduard_Munteanu> AFAIK.
08:44:36 <hjulle> Is there any case where sum would benifit from the lazyness?
08:45:12 <hjulle> (hmm... perhaps peano-numbers?)
08:46:48 <Eduard_Munteanu> In that case I suppose you'd want foldr.
08:47:15 <hjulle> Eduard_Munteanu: Yes, of course.
08:47:16 <Eduard_Munteanu> Since it'd result in a productive sum.
08:48:19 <hjulle> Well, any other case?
08:49:11 <Eduard_Munteanu> I guess plain foldl would be beneficial for non-strict, non-associative operations when you really need the leftwise association, but I'm unsure.
08:49:15 <Eiler> i want to implement a little pattern, can someone show me a small code example of this: i want call a function based on user input, i want to map strings to functions so if user types: "factorial 5" it should return 25, and "factorial 5 4" should return invalid number of arguments?
08:49:55 <Eiler> return 120 i mean, not 25
08:50:00 <XWisdom> Or if anyone could point me to any info about Trie, it'd be great
08:53:18 <Eduard_Munteanu> Eiler: you could start by splitting the input using 'words'. Are you having difficulties with anything in particular?
08:56:36 <Eiler> Eduard_Munteanu well, i dont know if my approach and design is the correct, should i just create a list of tuple<string, function>? not sure how to make so it works with different number of arguments either, factorial should take 1, while multiply should take 2, for example
08:59:03 <DukeDave> Eliel: You might want to look at how Text.Printf works:
08:59:04 <DukeDave> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
09:00:35 <DukeDave> Eiler: I don't know how it works 'under the hood' (which you would have to figure out), but I know that it accepts different numbers of arguments at run time and throws an exception if something doesn't make sense; which sounds similar to your problem.
09:01:15 <DukeDave> "SourceThe PrintfType class provides the variable argument magic for  printf.  Its implementation is intentionally not visible from  this module. If you attempt to pass an argument of a type which  is not an instance of this class to printf or hPrintf, then  the compiler will report it as a missing instance of PrintfArg".
09:03:04 <Eiler> DukeDave that looks advanced, can i someone get the number of arguments/parameters a function has?
09:06:00 <Eduard_Munteanu> Eiler: you could have a lookup table with rows consisting of the function name (as a string), the Haskell function and the number of arguments.
09:06:01 <DukeDave> Eiler: Erm, well you are wanting to something in the meta-programming domain, so I'm afraid it's going to be a little 'advanced'.
09:06:07 <KitB> Recommended Chart/plot libraries anyone?
09:07:19 <kmc> Text.Printf uses some awful type class hacks to do that
09:07:51 <Eduard_Munteanu> KitB: have you tried 'chart'?
09:08:16 <Eiler> DukeDave oh, i would need some sample code for that
09:08:31 <KitB> Eduard_Munteanu: That's the one I was looking at, just checking to see if there's any that people think is best
09:08:49 <engla> printf is a mystery when first seen, its polymorphic (either String or IO) return type
09:08:53 <DukeDave> Eiler: Well, there's some examples on here: http://www.haskell.org/haskellwiki/Template_Haskell
09:10:13 <Eduard_Munteanu> Nah, you don't really need that.
09:13:44 <DukeDave> Eiler: You might also have some luck with 'dynApply' from here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
09:16:02 <KitB> setup: The program gtk2hsC2hs version >=0.13.5 is required but the version
09:16:02 <KitB> found at /usr/bin/gtk2hsC2hs is version 0.13.4
09:16:08 <KitB> Anyone got a fix for this?
09:17:10 <Saizan> install the newer version? if you have already done that you could get rid of the old one so that it gets found
09:17:31 <Saizan> assuming you have $HOME/.cabal/bin in your $PATH
09:18:03 <Saizan> @hackage gtk2hs-buildtools
09:18:03 <lambdabot> http://hackage.haskell.org/package/gtk2hs-buildtools
09:18:06 <KitB> I think I need to update the one it's looking at
09:18:09 <KitB> Which I'm doing
09:18:13 <KitB> (I've been googling too)
09:18:50 <kmc> Eiler, are all your arguments integers?
09:19:03 <kmc> Eiler, you could just use Map String ([Integer] -> Integer)
09:19:42 <kmc> or you can push the parsing / printing into the functions and just do Map String (String -> String)
09:19:49 <kmc> and write some helpers to make that clean
09:20:41 <Eiler> all arguments wont be integers
09:20:51 <Eiler> kmc mind showing me an example?
09:24:28 <tactics> What's the difference between Text.Parsec and Text.ParserCombinators.Parsec?
09:25:35 <aristid> tactics: the latter is the old name
09:25:37 <kmc> tactics, the latter has a somewhat Parsec2-compatible interface
09:25:46 <kmc> for new code you should probably use Text.Parsec
09:26:08 <tactics> So, the code in Real World Haskell is using the older version (2.0)?
09:26:14 <kmc> yes
09:26:17 <tactics> What's the 3.0 equivalent of GenParser?
09:26:37 <tactics> (If it's still there, I can't seem to figure out which submodule it's in)
09:27:06 <benmachine> Text.ParserCombinators.Parsec still exists in 3.0
09:27:20 <benmachine> and still has a GenParser
09:27:28 <benmachine> it's defined in terms of the new Parsec type
09:27:45 <benmachine> (fsvo new)
09:27:54 <tactics> ah, I see
09:27:58 <tactics> It's in .Char
09:28:39 <benmachine> it's *also* in .Char
09:28:39 <tactics> or.... maybe not >__>
09:28:52 <benmachine> it's defined in Text.Parsec.String and then re-exported in a few places
09:29:13 <benmachine> assuming we're talking about the same version (I'm looking at the docs for 3.1.2)
09:29:35 <tactics> oh, I mean .String
09:30:06 <benmachine> oh, right
09:30:12 <tactics> benmachine: The GHC/hackage/cabal packaging system still confuses the hell out of me. But i'm fairly certain I have the latest release on hackage
09:30:27 <benmachine> simple way to check: ghc-pkg list parsec
09:31:02 <tactics> 3.1.1
09:31:32 <tactics> That makes things a little more definite. Thanks
09:32:22 <kmc> tactics, what's confusing?
09:33:12 <tactics> Keeping track of all the packages you have floating around your system, what versions they are, etc.
09:33:29 <tactics> Do I need to define a Stream instance if I plan to write a parser for a custom Token type?
09:36:12 <kmc> you mean as opposed to a parser on String or ByteString etc?
09:37:24 <tactics> I'm trying to parse a token list, rather than a string
09:37:45 <tactics> I need to write a definition for "tokenSatisfy :: (Token -> Bool) -> GenParser Token () Token"
09:37:48 <tactics> or something like that
09:37:59 <tactics> I figured tokenPrim looks like what I need
09:38:21 <benmachine> isn't there already a Stream instance for list-of-things?
09:38:57 <tactics> there is... I must have misspelled the type or something
09:39:04 <hpc> Monad m => Stream [tok] m tok
09:39:08 <hpc> is the instance
09:40:26 <benmachine> should obv be Applicative m =>
09:44:54 <tactics> ok, cool. I got it ;)
09:46:41 * hackagebot haskell-src-meta 0.5.0.2 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.5.0.2 (BenMillwood)
09:56:54 <b_jonas> how dangerous is the FlexibleContexts language extension?
09:58:37 <b_jonas> glasgow-exts contains it so it can't be that dangerous, right?
09:58:38 <aristid> b_jonas: don't fear it.
09:59:43 <b_jonas> but they say -fglasgow-exts is an old thing and they want us to decide on extensions individually instead
10:00:44 <b_jonas> can a raptor climb on balconies to the third floor? if no, I guess I could try it. ( http://xkcd.com/292/ )
10:02:53 <b_jonas> hmm, it doesn't help me, ghc tells what I want to do needs undecidableinstances
10:04:38 <kmc> both of them are fine, imo
10:05:11 <kmc> glasgow-exts contains all kinds of things, I wouldn't trust it or use it for anything
10:05:29 <kmc> b_jonas, they're just relaxing restrictions which were placed in Haskell for the benefit of implementors
10:05:29 <b_jonas> okay
10:06:05 <kmc> they're not going to add weird new semantics
10:06:28 <kmc> iow, they're allowing new things that are disallowed in Haskell but whose meaning would be clear anyway
10:06:33 <kmc> unlike OverlappingInstances and IncoherentInstances
10:06:43 <kmc> i do think that needing a pile of type class extensions is a bad sign
10:07:01 <kmc> people tend to go crazy with type classes when some plain old functional programming would do the job better
10:12:55 <danr> is sortBy in Data.List stable? I cannot find that documented
10:13:28 <monochrom> so far it's stable iirc
10:14:39 <monochrom> > sortBy (comparing fst) [(2, "d"), (1, "a"), (1, "b"), (2, "c")]
10:14:40 <lambdabot>   [(1,"a"),(1,"b"),(2,"d"),(2,"c")]
10:14:44 <monochrom> \∩/
10:15:19 <monochrom> oh oops, that's unstable, sorry!
10:15:38 <monochrom> err, oops the second time, that's stable :)
10:15:53 <engla> sort is documented as stable
10:16:34 <danr> engla: nice, do you have a reference?
10:17:15 <danr> engla: nvm, i found one. thanks anyway :)
10:17:41 <MatrixFrog> i always mix up repeat and replicate. any trick for remembering which is which? other than :t
10:17:52 <MatrixFrog> actually i guess :t might be all you need. but still
10:18:35 <mike-burns> The word "replicate" is longer, as is the type signature.
10:19:44 <engla> replicate sounds like a one-off action and repeat is continuous
10:19:50 <MatrixFrog> nice
10:20:01 <MatrixFrog> thank you
10:20:11 <kmc> @src replicate
10:20:11 <lambdabot> replicate n x = take n (repeat x)
10:20:27 <kmc> replicate is built from repeat and the name is longer
10:20:54 <benmachine> I think I don't remember 'replicate' as a name, I remember 'replicate n x' as an expression
10:20:55 <MatrixFrog> replIcate has an I in it
10:20:57 <MatrixFrog> so it takes an Int
10:21:07 <MatrixFrog> all good suggestions, thank you!
10:22:56 <edwardk> alpounet: just saw your ping
10:24:41 <absence> is there a "the" frp library, which is where most activity is going on, etc? from the outside it looks like a tangled mess of forked and abandoned libraries :) (i realise frp is an ongoing research topic)
10:25:05 <b_jonas> does this make sense? http://hpaste.org/52694
10:25:19 <b_jonas> if so, is it also a monad? here I define only an applicative instance.
10:26:27 <kmc> not a fan of layout?
10:26:38 <mike-burns> Is that Java?
10:27:27 <b_jonas> kmc: yep, I don't like layout
10:27:32 <b_jonas> mike-burns: huh?
10:28:51 <kmc> why not, out of curiosity?
10:30:10 <b_jonas> kmc: I find it too magical
10:30:37 <byorgey> b_jonas: that makes sense, and it is already defined in the TypeCompose package
10:30:49 <b_jonas> TypeCompose? I'll check, thanks
10:30:54 <kmc> b_jonas, the rules are pretty simple
10:30:57 <parcs_> layout rules are clearly defined
10:30:57 <byorgey> b_jonas: TwoLevel is not, in general, a monad, unless m distributes over n in a certain way
10:31:33 <byorgey> b_jonas: the problem is implementing join :: m (n (m (n a))) -> m (n a)
10:31:50 <byorgey> b_jonas: oh, and clearly I mean n distributes over m
10:32:08 <byorgey> because then you can do  fmap distribute :: m (n (m (n a))) -> m (m (n (n a)))
10:32:22 <byorgey> and from there  fmap join . join
10:32:31 <kmc> b_jonas, same column = implicit semicolon; further left = implicit close brace
10:32:36 <b_jonas> byorgey: okay
10:32:39 <b_jonas> thanks
10:34:09 <b_jonas> kmc: my problem is the implicit close brace added when you write "let x = y in z" all in one line
10:35:15 <kmc> why?
10:35:59 <b_jonas> that one is magical. the rule is that closing brace is inserted wherever the opening brace was implicit and there would be a syntax error otherwise
10:36:00 <mike-burns> That syntax is rather magical, in comparison.
10:36:13 <kmc> L (t : ts) (m : ms) = }  :  (L (t : ts) ms)  if m ≠ 0 and parse-error(t)
10:36:17 <kmc> right
10:36:17 <b_jonas> I don't understand the implications of that rule enouhg
10:36:24 <kmc> neither do i
10:36:35 <kmc> but I don't think it's a practical obstacle to using layout
10:36:48 <mike-burns> I tend to avoid `let'.
10:37:03 <kmc> really?
10:37:46 <b_jonas> maybe if someone gave a more understantable equivalent of that rule, possibly restricted for a usable subset of all syntax that I could restrict myself to, I might consider this
10:37:54 <mike-burns> I use it, but less so than if I understood the layout rules for it better.
10:38:13 <Philippa> b_jonas: "if there's the possibility it'd help and you get a parsing failure otherwise, try inserting a close brace"
10:39:22 <Philippa> in practical terms it tends to mean that you can write statements as one-liners and you surround them with parens and put the close paren on the same line
10:39:38 <b_jonas> byorgey: right, it seems TwoLevel is called (Control.Compose.:.)
10:40:06 <b_jonas> besides, I like one-liners, and I don't like significant whitespace
10:40:15 <b_jonas> I write out all the semicolons explicitly in ruby
10:40:38 <b_jonas> though ruby is a quite different matter
10:40:47 <b_jonas> its syntax has different problems than haskell's layout
10:40:58 <ghosting> :t Philippa
10:40:59 <lambdabot> Not in scope: data constructor `Philippa'
10:41:49 <Philippa> my type is generally people who wouldn't ask what my type is on #haskell
10:43:00 <ghosting> :D just wanted to hear something sly, I'm bored here
10:46:03 <b_jonas> byorgey: the fact that there's no monad instance for this, is it related to the fact that you can't just convert any monad to a monad transformer in a generic way?
10:47:28 <ddarius> If you could make a Monad instance for it, then there wouldn't be a need for monad transformers.
10:47:40 <mm_freak> are weak pointers only referring to the head constructor of their values?
10:47:57 <mm_freak> i have a large data structure and would like to clean things up, as soon as it is dead
10:48:15 <mm_freak> with a weak pointer to a single element of that structure it works
10:48:49 <mm_freak> but as soon as i use the data structure itself or a tuple containing all its fields, the finalizer is run immediately
10:51:04 <ddarius> mm_freak: If you don't have any other reference to the structure, then there is nothing linking it into the reachability graph.
10:51:33 <ddarius> Presumably in the former case, you have a reference to the whole structure, which of course also holds references to the components, and also a weak pointer.
10:52:08 <mm_freak> ddarius: the data structure is definitely used later in the code, but before it gets into use, it's already finalized
10:52:56 <hjulle> Does there exist any "official" coding standards document for haskell?
10:52:57 <mm_freak> the structure contains a few TVars and a thread id…  the purpose is to kill the thread, once the variables run out of reachability
10:53:02 <ddarius> mm_freak: I didn't say anything about being used later, you have to have another "strong" path to it.
10:54:23 <ddarius> mm_freak: At any rate, you may want to post some cut-down example that demonstrates the problem if possible, because I think we're having difficulty communicating well.
10:55:13 <mm_freak> ok, gimme a minute
10:56:33 <tactics> :hoogle (a -> a -> b) -> [a] -> b
10:56:57 <tactics> @hoogle (a -> a -> b) -> [a] -> b
10:56:58 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
10:56:58 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
10:56:58 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
10:57:35 <hpaste> “Ertugrul Söylemez” pasted “Weak pointers to finalize a record” at http://hpaste.org/52695
10:57:42 <mm_freak> ddarius: see the paste
10:58:30 <mm_freak> ddarius: when i have a weak pointer to the thrInputVar component or any other component i'm going to use later, it works the way it should
10:58:58 <mm_freak> however, referencing the whole data structure does not work
10:59:26 <mm_freak> technically the whole data structure is not needed anymore, only its components
11:00:27 <ddarius> So as it is currently written there, it doesn't work?  Also, what does a typical use look like?  If you do a record update, for example, you will indeed quite lose a reference to the original wt once all the thunks of the fields have been forced.
11:00:37 <mm_freak> the pasted code doesn't work
11:00:59 <b_jonas> is this loaded in lambdabot?
11:01:00 <mm_freak> no updates are made to that record…  the use case is an automaton-style arrow
11:01:12 <b_jonas> > fmap (*10) (O [[2]])
11:01:13 <lambdabot>   Not in scope: data constructor `O'
11:01:19 <b_jonas> > fmap (*10) (Control.Compose.O [[2]])
11:01:20 <lambdabot>   Not in scope: data constructor `Control.Compose.O'
11:01:27 <b_jonas> I think it's not
11:02:15 <mm_freak> ddarius: an AFRP arrow to be exact…  i would like to provide the ability to launch threads as part of the FRP session…  the threads should either die after the reference is lost (for example when switching away) or when the FRP session ends
11:02:51 <ddarius> mm_freak: Record update was just an example, as soon as no reference to wt exists it can be garbage collected.  That can indeed happen if you immediately case analyze it and just use the components or if you build other records from the components.
11:03:17 <ddarius> mm_freak: I don't need to know the overarching grand scheme, I need to know the details of how the code is actually using the record.
11:04:16 <hpaste> “Ertugrul Söylemez” annotated “Weak pointers to finalize a record” with “How it's used” at http://hpaste.org/52695#a52696
11:04:25 <mm_freak> ddarius: there is an example
11:04:35 <mm_freak> the computation you see there is called in an infinite loop
11:05:12 <ddarius> mm_freak: Though I guess it is possible that you don't want to use weak pointers for this.
11:05:22 <ddarius> mm_freak: I need an example of forkWT being (explicitly) used.
11:05:25 <mm_freak> the overaching grand scheme matters here (and somewhat justifies why i would like to use finalization instead of a with* style function)
11:06:34 <hpaste> “Ertugrul Söylemez” annotated “Weak pointers to finalize a record” with “Wire interface to 'forkWT'” at http://hpaste.org/52695#a52697
11:06:41 <mm_freak> ddarius: paste
11:07:08 <mm_freak> in the first instant this one calls forkWT as in the code
11:07:25 <mm_freak> in the following instants it just constantly returns that 'wt'
11:08:12 <mm_freak> the other wires 'listen' and 'feed' use that 'wt' to pass stuff through the TMVars
11:08:43 <b_jonas> hmm, the haskell wiki has some useful informations
11:08:47 <b_jonas> I should check it more
11:09:24 <osfameron> is anyone writing about doing #aiclass with haskell?
11:10:09 <b_jonas> anyway, I was thinking about what you mentioned yesterday, namely that you think beginner programming could be taught using declarative programming style at first
11:10:30 <mm_freak> i would be glad for an idea that's better than weak pointers, though…  i'm not entirely happy with them…  perhaps i should rethink my concept
11:10:49 <mm_freak> just no idea how to deal with it differently
11:12:26 <b_jonas> so when I taught introd to programming, one example I gave is this https://omnibus2.math.bme.hu:8000/home/pub/38/#cell_text_22
11:12:47 <b_jonas> where the story is the coupon collector problem:
11:13:04 <b_jonas> you generate random numbers in [0..9] and want to stop when you've got at least one of each of the ten numbers
11:13:19 <mm_freak> ddarius: do you think it could fail because of the mfix?
11:13:39 <b_jonas> so in my example code I generate the frequency table, modifying the mutable table in each step
11:14:30 <b_jonas> So if one was to teach introd programming in declarative style, how would you code this? Does that question even make sense?
11:15:01 <b_jonas> I mean, maybe in that case this wouldn't be the right problem to give (I had all kind of hidden motives when chosing problems).
11:15:35 <mm_freak> ddarius: no worries…  i think i solved it in the most straightforward way i could imagine…  just use addFinalizer on wt =)
11:15:40 <b_jonas> Would you use scan with amend on immutable lists? Transpose? Recompute the table in each step?
11:15:47 <b_jonas> Something else?
11:16:07 <b_jonas> The problem is not just the mutable array, but also the while loop.
11:16:37 <b_jonas> Also, did I make sense? Are you lost?
11:17:22 <monochrom> haskell is declarative for some common tasks and not declarative for some common others
11:17:40 <b_jonas> monochrom: I'm saying declarative style. I don't think it's the language that matters.
11:17:47 <monochrom> but usually brute-force search via list comprehension is pretty declarative.
11:17:58 <b_jonas> You can teach in a more declarative style in python. In fact, my collegues tried exactly that.
11:18:08 <b_jonas> Eg. I don't write map in my code at all. They did.
11:18:11 <ddarius> b_jonas: Why do you need a freqency table?
11:18:12 <monochrom> or with GHC 7.2, via monad comprehension and LogicT
11:18:32 <b_jonas> ddarius: it could be just a table of bools instead. Same thing.
11:18:34 <mm_freak> b_jonas: i would just write this with a recursive function using a Set under the hood
11:18:53 <mm_freak> initialize with all elements you want to see and remove as you encounter them…  stop when the Set is empty
11:18:58 <b_jonas> ddarius: but I used a freq table because I gave the twist that you also win if you have ten coupons of the same kind
11:19:11 <mm_freak> b_jonas: no mutation there
11:20:19 <ddarius> Or just insert into a bag to handle the more general case.
11:20:49 <ddarius> You could probably readily do this using something like unfoldr or scanl
11:20:59 <mm_freak> ddarius: one further question…  just when exactly is a value considered dead?  is there some documentation?  i just removed the 'listen' and 'feed' computations, such that there is only the 'subsession' computation, which just returns the 'wt' constantly…  it's not used
11:21:07 <mm_freak> the finalizer is still not called, no matter how long i let that run
11:22:45 <b_jonas> mm_freak: and how do you handle the unbounded outer loop? do you generate the random numbers in IO?
11:23:11 <b_jonas> or just skip the random part and use a list as input?
11:23:50 <ddarius> It's dead when it's no longer reachable (through any "strong" path.)  Optimizations may change the apparent reachability and thunks can lead to things being reachable longer than you'd like.
11:24:28 <ddarius> For using weak pointers, I would recommend having them be on the things that are actually important.
11:24:51 <monochrom> let rs be a given infinite stream of random coupons. to be a coupon collector taking from rs: head [ cs | cs <- inits rs, all (`elem` cs) [0..9] ].
11:25:07 <monochrom> it is slow but it is the most declarative so far.
11:25:09 <ddarius> b_jonas: You can generate an infinite list of random numbers and use that, or you can pass the random number generator along.
11:25:33 <mm_freak> b_jonas: for beginners i would just generate a lazy list of random numbers
11:25:46 <b_jonas> mm_freak: I see
11:25:49 <ddarius> @hoogle randoms
11:25:49 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
11:26:21 <mm_freak> ddarius: ok, thanks for your help
11:27:25 <b_jonas> well, I'm not sure all this would work
11:27:28 <b_jonas> maybe
11:28:22 <monochrom> let g be a given generator of random coupons. to be a coupon collector taking from g: head [ cs | i <- [0..], let cs = take i (randomRs (0,9) g), all (`elem` cs) [0..9] ]
11:29:44 <b_jonas> what I wanted to achieve with my course is to introduce only a very small set of language features and show how you can write any program (for some value of any) using only those
11:29:51 <b_jonas> basically all you need is in https://omnibus2.math.bme.hu:8000/home/pub/22/
11:30:13 <monochrom> I would certainly include list comprehension in the small language core
11:30:46 <monochrom> and therefore omit some other things if necessary
11:30:47 <ddarius> b_jonas: All you need is recursion and some data structure that can represent a bag.
11:31:35 <monochrom> list comprehension covers a large class of slow but close-to-specification (declarative) things
11:31:53 <ddarius> You can translate the Python code directly to Haskell albeit you'd probably want to switch data structures.
11:32:06 <ddarius> Also, it's not a good demonstration of a declarative approach.
11:32:29 <Twey> b_jonas: Unlambda?
11:32:38 <monochrom> unless the specification mentions bag, I wouldn't introduce a bag. not declarative. or at least, not close to specification
11:33:51 <b_jonas> ddarius: exactly, so there are two contradictory arguments here: I could say that I choose my examples in a specific way and this problem is not a good one to teach declarative programming; or I can say that my point is to show how you can write any program from a few primitives so if you can't write this program in the declarative way then that's the fault of that declarative way.
11:34:23 <b_jonas> Twey: isn't there an Unlambda with haskell-like IO somewhere?
11:34:44 <mm_freak> b_jonas: one great way to teach declarative programming is to teach how to construct values making use of lazy evaluation
11:34:44 <ddarius> b_jonas: Netiher are true depending on the primitives you allow.
11:34:46 <b_jonas> Twey: I've seen a lazy Unlambda somewhere, but it too has impure IO so it's not what I want
11:35:19 <ddarius> b_jonas: For example, monochrom's first example is pretty clear and simple.
11:35:45 <b_jonas> ddarius: yes, that's true
11:35:49 <mm_freak> b_jonas: in imperative programming you usually wrap a data structure around a data structure-generating algorithm…  in declarative programming you wrap a data structure around an element-generating algorithm, which may refer to other elements while doing so
11:35:56 <ddarius> b_jonas: I will say, though, that generating random numbers is something that isn't handled quite so "well" in pure languages.
11:36:32 <mm_freak> uhm…  in imperative programming you wrap a data structure-generating algorithm around a data structure
11:36:37 <b_jonas> yes, maybe the random numbers are a particularly evil but narrow example that shouldn't come up if I want to teach in a declarative way
11:37:12 <mm_freak> b_jonas: regarding unlambda…  lazy k is lazy and uses pure I/O
11:37:14 <ddarius> Of course, separating the algorithm into a list processing function and a random stream conveys quite a few benefits which aren't had from the typical imperative way of generating random numbers.
11:37:56 <ddarius> (They can be recovered in the imperative approach quite easily, though.)
11:38:24 <b_jonas> mm_freak: thanks for the pointer on Lazy k
11:40:21 <b_jonas> on another topic, one thing I should have done differently (among many) in this course is to take http://wiki.math.bme.hu/index.php/Informatika1-2010/Hazi4 in the course (as opposed to as a homework)
11:40:39 <b_jonas> because it's my best problem to explain how subroutines work
11:42:07 <b_jonas> problem is: given the timetable of trains from A to B and the timetable of trains from B to C and the time a meeting in C start, determine the latest time you can start from A to reach the meeting
11:42:32 <b_jonas> a timetable of trains from x to y is a list of pairs of times when a train departs from x and when it arrives in y
11:43:50 <hjulle> b_jonas: Is it sorted?
11:44:26 <b_jonas> hjulle: it's sorted by the departure time, but not by the arrival time
11:44:41 <hjulle> ok
11:46:30 <hjulle> I suspect it is possible for a train to start earlier and arrive later then another train.
11:47:12 <b_jonas> mm_freak: no, Lazy K is not what I want
11:47:34 <b_jonas> it promises pureness but it doesn't actually deliver it
11:47:40 <poincare101> Hello everyone. I wrote a simple One time password generator, that gives me OTPs in a list, I can use it in GHCi, but, how would I write a main function to print out the result of, say, (otp f 1729 20)? (Here's the code: http://paste.pocoo.org/show/493491/)
11:47:46 <b_jonas> hjulle: yes, that's possible
11:48:33 <rwbarton> main = print (otp f 1729 20)
11:49:34 <hjulle> Doesn't ghc allow you to even write main = otp f 1729 20?
11:49:35 <cgroza> where does ghc look for libraries by default? I need this because cabal says it puts them ~/.cabal/bin ...
11:49:53 <shachaf> cabal doesn't put libraries in ~/.cabal/bin
11:50:00 <shachaf> It puts executables there.
11:50:17 <cgroza> shachaf: ok. So it should put libs at the right place?
11:50:38 <shachaf> That depends on what you consider "the right place" to be.
11:50:50 <cgroza> shachaf: I want ghc or ghci to find them.
11:50:51 <shachaf> Do you have an actual problem with something not finding something?
11:50:54 <eichi> I have damn problems with "brackets" in haskell: I have this "helper  rest  filter (== keyword) . words $ text" and I want this: (helper  rest  (filter (== keyword) . words  text))
11:51:05 <cgroza> shachaf: no.
11:51:21 <shachaf> cgroza: Then what's the problem?
11:51:39 <eichi> helper get 2 parameters rest and a filtered wordlist from string text
11:51:39 <cgroza> shachaf: none for the moment. I was just asking...
11:51:48 <shachaf> eichi: If you want that, why don't you just use that?
11:52:11 <shachaf> cgroza: Oh, well, cabal should make it work out somehow.
11:52:11 <eichi> shachaf: das haskell understand this lisp style brackets? normal ones?
11:52:26 <cgroza> shachaf: ok. It seems like working.
11:52:26 <shachaf> Haskell understands Haskell-style brackets.
11:52:40 <b_jonas> eichi: sort of, yes
11:52:43 <eichi> yeah and I thours that is $ and .
11:52:53 <shachaf> $ and . aren't brackets
11:53:02 <shachaf> They're operators. Haskell understands them too.
11:53:09 <b_jonas> eichi: you need to write ((+) 3 4) for example, lisp-style (+ 3 4) doesn't work
11:53:17 <shachaf> If *you* don't understand them, or don't feel like using them, feel free to resort to ( and )
11:53:38 <b_jonas> also, you can't use square brackets like in some lisps
11:53:43 <cgroza> although you should try your best to understand them.
11:54:33 <eichi> I know that     command parameter does start command and use parameter if it needs while command $ parameter first get the parameter
11:54:40 <ddarius> I and B are pretty important combinators.
11:54:45 <eichi> but thats all I understand
11:54:46 <rwbarton> no
11:54:52 <shachaf> Haskell doesn't have commands.
11:55:02 <eichi> function
11:55:05 <shachaf> function $ argument is the same as function argument
11:55:11 <ddarius> Also they are part of the basis of (the proof terms) an (ordered) linear logic.
11:55:19 <shachaf> ddarius: Understanding parentheses is probably more important than understand those combinators.
11:55:22 <b_jonas> (at first approximation)
11:55:27 <eichi> okay but function argument+argument2 is not same as function $ argument + argument2
11:55:47 <shachaf> But it *is* the same as "function (argument1+argument2)"
11:55:50 <b_jonas> and I agree with shachaf
11:55:55 <ddarius> shachaf: Yes, if you can't parse Haskell, then the content doesn't really matter.
11:56:32 <ddarius> shachaf: That was poorly worded.
11:56:48 <ddarius> shachaf: function $ argument1 + argument2 is the same as function (argument1 + argument2)
11:56:51 <b_jonas> could someone who understands it add "exists" to http://haskell.org/haskellwiki/Keywords  please
11:57:08 <shachaf> ddarius: That's not what I said?
11:57:18 <shachaf> Oh, I had it backwards.
11:57:22 <shachaf> eichi: I meant what ddarius said.
11:57:23 <ddarius> function argument1 + argument2 is the same as (function argument1) + argument2.  Application binds tighter than (almost) anything.
11:57:41 <shachaf> There are only two things that bind tighter than application, I believe.
11:58:08 <dschoepe> shachaf: record updates and ..?
11:58:19 <shachaf> dschoepe: Record creation.
11:58:20 <b_jonas> it also misses some other punctuation, like lists and tuples stuff
11:58:32 <dschoepe> shachaf: ah, right
11:58:44 <ddarius> b_jonas: exists isn't a keyword in Haskell.
11:58:46 <b_jonas> and the part about {} should mention record creation
11:59:04 <b_jonas> ddarius: but this page documents many ghc extensions already
11:59:27 <ddarius> exists isn't a keyword in GHC unless it has been added very recently.
11:59:27 <eichi> filter (== keyword) . words $ text           but this should work? it takes list text, makes a wordstring list and filters out all things, that are not equal keyword
11:59:29 <b_jonas> hmm wait, it isn't a keyword even with LANGUAGE flags?
11:59:32 <b_jonas> oh, I see
11:59:39 <b_jonas> okay, thanks for clearing that up
11:59:41 <ddarius> b_jonas: It may be a keyword is some other implementations.
11:59:46 <brannmar_mac> any one acknowledge this paste? http://hpaste.org/52653
11:59:52 <b_jonas> I guess I'll go on adding some stuff about the parts I understand more, like lists and tuples
12:00:20 <shachaf> eichi: "filter (== keyword) . words $ text" is the same as "(filter (== keyword) . words) text", which is the same as "filter (== keyword) (words text)"
12:00:49 <shachaf> eichi: You should read a guide to Haskell syntax.
12:01:20 <ddarius> eichi: Don't bother with using ($) and (to a lesser extent) (.) until you can use parentheses to express your intent (or if (.) just is the appropriate function, use it certainly.)
12:01:21 <slack1256> eichi: there is a utility in hackage that tell you when parentesis are redundant. is called hlint
12:02:38 <Twey> You forgot: filter (== keyword) $ words text
12:03:10 <shachaf> Twey: filter (==keyword) isn't the "expansion" of any of those.
12:03:16 <shachaf> All I did was apply definitions.
12:03:33 <b_jonas> parenthesis in haskell work mostly like parenthesis in mathematics. only, in haskell, they also convert infix operators to ordinary values.
12:03:41 <shachaf> And make tuples.
12:04:00 <b_jonas> right, but I think they make tuples in mathematics too
12:04:04 <hpc> and make sections
12:04:14 <slack1256> they are called N-uplas right?
12:04:14 <b_jonas> hmm, yes, sections
12:04:27 <b_jonas> sections require parens in haskell, I keep forgetting that
12:04:47 * ddarius is not sure how you could forget that.
12:05:04 <mm_freak> b_jonas: and there is also ()
12:05:14 <ddarius> mm_freak: That's a tuple.
12:05:26 <mm_freak> i found that not explaining () specifically leads to a lot of confusion among beginners
12:05:26 <b_jonas> ddarius: think of tuples in python or comma-separated lists in perl or trains in J. these don't actually require parens, but some beginners think they do, because they have such a low precedence that they usually appear with parens.
12:05:26 <ddarius> Unless you mean the type level form.
12:05:28 <hpc> i thought it was the unit type
12:05:37 <shachaf> The fact that parentheses are used for tuples is just an abuse of syntax, in my opinion.
12:05:40 <slack1256> ddarius: unit type isn't a N-upla
12:05:53 <shachaf> slack1256: What's wrong with N=0?
12:05:59 <b_jonas> ddarius: similarly, it could make sense if sections didn't require parens in haskell so you could write let { f = + 2 } in f 3
12:06:00 <rwbarton> "N-upla" isn't a word.  You mean n-tuple.
12:06:04 <mm_freak> ddarius: i mean both…  surely you can interpret it as a tuple, but it's not apparent immediately to most people
12:06:07 <b_jonas> but no, it doesn't work that way
12:06:20 <rwbarton> > let { f = + 2 } in f 3
12:06:21 <lambdabot>   <no location info>: parse error on input `+'
12:06:21 <hpc> b_jonas: oh god, you don't need parens for a perl list?
12:06:34 <rwbarton> oh, no unary +, hmm
12:06:36 <slack1256> shachaf: unit isn't intent to express a number of result.
12:06:53 <shachaf> slack1256: 0 isn't a number?
12:06:54 <conal> b_jonas: the parens necessity for sections is a bummer, as it breaks the story that parens has a single, consistent purpose in expressions.
12:07:13 <ddarius> b_jonas: That's about the only case where it could be potentially unambiguous, and even then you could say the same about (+).
12:07:29 <b_jonas> why do we have infix operators at all? couldn't we just use prefix everywhere?
12:07:30 <slack1256> shachaf: didn't say that, the intention of unit type is different from a N-upla
12:07:41 <shachaf> Haskell /me isn't sure what "a N-upla" is.
12:07:45 <mm_freak> b_jonas: i'd really miss the infix variant of (.)
12:08:06 <ddarius> b_jonas: Yes, why would we want to just use prefix everywhere?
12:08:06 <conal> b_jonas: for looks. and yes.
12:08:06 <rwbarton> or for that matter (+)
12:08:08 <b_jonas> ddarius: but it would make conal happier, wouldn't it?
12:08:09 <mm_freak> b_jonas: and (>=>) and (>>=) and (>>>) and (<+>) and many more
12:08:15 <ddarius> b_jonas: I doubt it.
12:08:21 <rwbarton> it's nice to write associative operators infix
12:08:30 <ddarius> @where liskell
12:08:30 <lambdabot> http://clemens.endorphin.org/liskell
12:08:37 <ddarius> Have at it, if you want.
12:08:51 <conal> b_jonas: i loved lisp & scheme programming. and i like infix for mathy stuff.
12:09:01 <mm_freak> b_jonas: infix notation is strictly an option in haskell, and it's good that it's there
12:09:12 <mm_freak> you really wouldn't want to write f . g . h prefix
12:09:15 <slack1256> shachaf: N-upla == sequence, sorry i was using the name we most use in spanish
12:09:22 <b_jonas> it's not really the existance of infix operators that I don't like in haskell, but the way how it's very ugly when you want to use those operators as prefix
12:09:23 <shachaf> mm_freak: (. f g h)
12:09:32 <mm_freak> shachaf: no, . (. f g) h
12:09:44 <shachaf> Not in most LISPs.
12:09:48 <conal> b_jonas: ah. yeah :/
12:09:52 <b_jonas> it might not be so ugly if the libraries defined nice alphabetic aliases to all the infix operators
12:09:53 <mm_freak> shachaf: i'm talking about the statically typed haskell
12:10:10 <mm_freak> shachaf: variadic functions don't play well with static typing
12:10:18 <ddarius> b_jonas: I don't find it ugly at all, nor do I usually want to use them prefix, so even if it were very ugly, I would not care.
12:10:44 <mm_freak> b_jonas: what would be your proposal?  i don't find the prefix notation particularly ugly
12:11:01 <b_jonas> mm_freak: dunno, I don't really have a proposal
12:11:40 <mm_freak> b_jonas: the only way around this would be to allow operators to be prefix, when there is nothing on the left side
12:11:45 <monochrom> define an alphabetic name for prefix, a punctuation name for infix
12:12:00 <mm_freak> but then you would run into trouble with sections, because (+ x) is not (+) x, but flip (+) x
12:12:35 <mm_freak> in any case, i prefer the well defined syntax of haskell
12:12:47 <shachaf> GHC also supports postfix operators.
12:12:57 <ddarius> shachaf: Hackily.
12:13:00 <slack1256> really?
12:13:03 <b_jonas> wait, haskellwiki uses mediawiki? why did I register with a camelcase username then?
12:13:05 <shachaf> Of course.
12:13:46 <slack1256> i understan "(+) 2 2" and "2 + 2" but how postfix on ghci?
12:14:12 <slack1256> *understand
12:14:39 <Botje> 2 2 (+) means "apply the function '2' with arguments '2' and '(+)'"
12:14:42 <b_jonas> > let { (x %+?) = 10*x; } in (3%+?)
12:14:43 <lambdabot>   <no location info>: Parse error in pattern
12:14:46 <Botje> so I don't think you can do that.
12:14:52 <ddarius> The Report says that (1 +) expands to \x -> 1 + x.  GHC, with the PostfixOperators extension simply expands it into (+) 1
12:14:53 <b_jonas> > let { (%+?) x = 10*x; } in (3%+?)
12:14:54 <lambdabot>   30
12:15:05 <ddarius> I.e. it doesn't eta expand.
12:15:43 <monochrom> iirc GHC used to expand (1 +) to (+) 1
12:16:05 <shachaf> monochrom: Yes, at one point it was an implicit extension.
12:16:26 <mm_freak> > let (!) 0 = 1; (!) n = n * (!) (pred n) in 3!
12:16:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:16:29 <mm_freak> > let (!) 0 = 1; (!) n = n * (!) (pred n) in 3 !
12:16:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:16:36 <ddarius> mm_freak: You need parentheses.
12:16:42 <mm_freak> > let (!) 0 = 1; (!) n = n * (!) (pred n) in (3 !)
12:16:43 <lambdabot>   6
12:16:45 <mm_freak> i see
12:16:55 <ddarius> mm_freak: All GHC is doing is interpreting the section syntax is a (very slightly) more liberal way.
12:16:59 <shachaf> let (*) = zeroOrMore; (+) = oneOrMore
12:17:17 <mm_freak> ddarius: what's hacky about that?
12:17:18 <rwbarton> IIRC, even after PostfixOperators was added, it would expand (x +) to (+) x for the purposes of sharing.  PostfixOperators only changed the typing rules
12:17:30 <ddarius> mm_freak: Because they aren't actually postfix operators and it changes semantics.
12:18:02 <slack1256> yeah, iirc there was a problem between eta-reduction and sharing.
12:18:02 <rwbarton> er, it may also affect seq on function types, yes, if you believe in that sort of thing
12:18:23 <shachaf> rwbarton: seq on functions types is a lie.
12:18:42 <slack1256> a lie that works!
12:18:50 <ddarius> mm_freak: I think what GHC does is the right thing and I would prefer the Report to be more liberal on this.
12:19:07 <shachaf> > let (!) x = undefined in (5!) `seq` ()
12:19:07 <lambdabot>   *Exception: Prelude.undefined
12:19:15 <conal> shachaf: what's not true about seq & function types?
12:19:24 <shachaf> That works even with the extension disabled.
12:19:40 <ddarius> shachaf: Yes, but then it is a bug.
12:19:50 <shachaf> ddarius: Right.
12:20:10 <shachaf> conal: I often prefer to pretend it doesn't exist.
12:20:23 <ddarius> shachaf: I mentioned on some mailing list or something that the approach of simply relaxing the type is not adequate.
12:20:45 <ddarius> But it's not something I care about since I think this way is better.
12:21:06 <mm_freak> ddarius: i see
12:26:16 <ddarius> (or rather it's the tightening the type to fix the bug is not adequate)
12:27:04 <shachaf> Is there a reasonable way of fixing the bug without losing sharing?
12:27:44 <ddarius> shachaf: GHC can lambda drop.  Sharing is orthogonal to how that expands.
12:28:18 <mm_freak> i just got a "dmdFix loop" from GHC…  doesn't seem to be an error, because the compilation succeeded…  what is that?
12:29:15 <shachaf> Something like (foo !) ==> let x = (!) foo in (\y -> x y) ?
12:29:34 * shachaf reads about what lambda dropping actually is.
12:30:49 <ddarius> shachaf: Yes.  More or less that.
12:39:24 <jmcarthur> > let (!) x = undefined in (!) `seq` ()
12:39:25 <lambdabot>   ()
12:40:33 <sipa> :t seq
12:40:34 <lambdabot> forall a t. a -> t -> t
12:41:58 <b_jonas> can (x $ y) be of a more restricted type than (x y) even if higher-order types aren't involved?
12:42:01 <vic__> Is there any other way of calling external programs in Haskell except using System.Cmd?
12:42:09 <shachaf> Yes.
12:42:18 <kmc> System.Process is the replacement for System.Cmd
12:42:26 <vic__> Ah, so System.Cmd is deprecated?
12:42:49 <kmc> well, maybe "replacement" was incorrect
12:42:50 <kmc> but "This module provides a simple interface for executing external commands. For a more complex, but more powerful, interface, see the System.Process module."
12:42:55 <kmc> from the System.Cmd docs
12:43:01 <b_jonas> wait, that's not exactly the question I want to ask
12:43:12 <vic__> Cool, already loaded it and called :browse
12:43:15 <vic__> Hmm
12:43:28 <k0i> Hello, could anyone explain why 'printf "%.2f" pi' works in the interpreter, but not when I compile it?
12:43:31 <vic__> I'll try with this
12:43:39 <b_jonas> is it possible that a program breaks if you replace (x y) with (x $ y) somewhere, even if higher-order types aren't involved?
12:43:51 <shachaf> k0i: It would probably be easier for people to answer you if you said what the error was.
12:43:52 <hpc> k0i: what is the error?
12:43:57 <shachaf> As it is there are many possible reasons.
12:43:58 <kmc> shachaf++
12:44:19 <kmc> my guess is that the interpreter (ghci?) is defaulting polymorphic types more than the language spec says
12:44:30 <kmc> printf's return type can be String or it can be IO ()
12:44:33 <hpc> k0i: also, "can anyone answer" or "can i ask" questions are kinda useless :P
12:44:35 <kmc> (or actually, IO t)
12:44:39 <rwbarton> heh, my guess is that he was trying to compile the file 'printf "%.2f" pi'
12:44:41 <k0i> http://pastebin.com/X544qsUq
12:44:43 <mauke> The paste X544qsUq has been copied to http://hpaste.org/52702
12:45:02 <shachaf> hpc: "can anyone explain why X?" isn't necessarily unreasonable, if X is wellspecified.
12:45:04 <tactics> Hey. Is there any easy boilerplate code to make Control-C work for Haskell on Windows?
12:45:05 <sipa> kmc wins
12:45:17 <tactics> I keep having my command prompt freeze because of bad recursion
12:45:32 <tactics> I'd like to just Control C and kill the process/thread/whatever that's doing it
12:45:56 <shachaf> k0i: Just give it an explicit type signature or use it in an unambiguous context.
12:48:13 <ddarius> http://comjnl.oxfordjournals.org/content/35/5/514.full.pdf
12:49:38 <hpc> oh god the typesetting
12:50:49 <aristid> why can't pdfs have nicer filenames?
12:50:51 <k0i> Cheers
12:51:00 <aristid> thinking about new filenames is hard
12:51:39 <ddarius> aristid: Google Desktop.
12:51:51 <aristid> ddarius: Deprecated.
12:53:38 <luite> hpc: it looks sharper if you ocr it with acrobat
12:53:55 <vic__> Heh, ocr. Working with tesseract now
12:54:01 <vic__> Not too shabby
12:54:47 <luite> acrobat has this setting that makes outline fonts out of scanned bitmaps
12:56:11 <vic__> Any elegant way of merging an arbitrary number of text files into one in Haskell? I'm working on a script and I don't like it...
12:58:15 <eyu100> is there a good way to create a "fixed-length bit string" type or type class?
12:59:01 <ddarius> vic__: Source files?  Or just a cat program?
13:00:10 <vic__> Here's the whole story: I'm calling tesseract for a pdf with X pages. And it creates X text files. And I want to concatenate them into one text file.
13:00:26 <ddarius> vic__: Use cat.
13:00:33 <vic__> And I'm using Haskell to call ls...
13:00:37 <vic__> cat... ok
13:00:51 <vic__> Simple is better
13:01:18 <luite> use getDirectoryContents instead of calling ls
13:01:58 <vic__> Yes
13:02:33 <vic__> getDirectoryContents "/home/user/work/txt" >>= return . filter (`notElem` [".", ".."])
13:02:34 <vic__> is better
13:02:36 <vic__> hehe
13:04:06 <shachaf> fmap (\\ [".",".."]) (getDirectoryContents "/homeuser/work/txt")
13:04:44 <vic__> that looks better
13:04:49 <vic__> Thank you
13:04:53 <vic__> All I have to do now is cat them
13:04:55 <vic__> hmm
13:05:53 <hpc> :t intercalculate
13:05:54 <lambdabot> Not in scope: `intercalculate'
13:05:56 <hpc> er
13:05:58 <hpc> :t intercalate
13:05:59 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:06:31 <hpc> > intercalate ", " (words "these words all have commas between them") -- replace separator with whatever
13:06:32 <lambdabot>   "these, words, all, have, commas, between, them"
13:07:27 * ddarius is not really sure why vic__ is using Haskell at all for this.
13:07:45 * vic__ shrugs 
13:07:51 <vic__> Good question
13:07:55 <vic__> Because I can
13:11:21 <vic__> fmap (\\ [".",".."])  this doesn't work
13:12:24 <stribor> ok i was here yesterday talking to people about partial functions and currying...i went to read a bit about it and still loost.anyone care to work with me on this for few min
13:13:46 <mysticc> luite: Am i supposed to use static file url as for /js/script.js as #{js_script_js} in the hamlet ...
13:13:48 <stribor> for example....someFunction :: Int->Int->Int......says it is function that takes one integer and returns function that takes one in and returns int
13:14:15 <hpc> stribor: correct
13:14:31 <stribor> hpc: let say ......maximum 3 5
13:14:34 <mysticc> luite: Am i supposed to use static file url as for /js/script.js as @{js_script_js} in the hamlet ...
13:14:55 <stribor> so oit takes (maximum 3) and then what
13:15:07 <hpc> @src maximum
13:15:08 <lambdabot> maximum [] = undefined
13:15:08 <lambdabot> maximum xs = foldl1 max xs
13:15:12 <hpc> @src max
13:15:12 <lambdabot> max x y = if x <= y then y else x
13:15:28 <luite> mysticc: yeah, that should be the name generated for it
13:15:28 <mysticc> :t max
13:15:29 <lambdabot> forall a. (Ord a) => a -> a -> a
13:15:34 <hpc> so we start with "max 3 5"
13:15:39 <stribor> hpc:  ok
13:15:51 <hpc> with parens that's (max 3) 5
13:15:53 <mysticc> luite: but it is giving some weird type error
13:16:07 <hpc> so we fill out the definition of max, with 3 instead of x
13:16:10 <luite> mysticc: if you use $(staticFiles "static") it will actually be served from the static subdirectory, so your filename would be ./static/js/script.js, url /js/script.js
13:16:17 <hpc> max y = if 3 <= y then y else 3
13:16:28 <hpc> max 3 y = if 3 <= y then y else 3 -- rather
13:16:48 <luite> mysticc: can you hpaste that error?
13:16:51 <hpc> so if we do 'let f = max 3'
13:16:59 <hpc> f y = if 3 <= y then y else 3
13:17:27 <mysticc> luite: http://paste.pocoo.org/show/493552/
13:17:30 <hpc> when we do (max 3) 5, we just apply 5 to that intermediate function
13:17:43 <hpc> and get 'if 3 <= 5 then 5 else 3'
13:17:47 <hpc> which is 5
13:17:47 <stribor> hpc: yeah but what does (max 3) returns
13:18:02 <hpc> stribor: it returns \y -> if 3 <= y then y else 3
13:18:15 <penryu> f :: Int -> Int
13:18:34 <stribor> hpc: sorr i dont get it....
13:18:40 <stribor> hpc: thanks for trying
13:18:47 <sipa> stribor: it returns another function
13:18:58 <sipa> namely the function that takes one argument, y
13:19:06 <sipa> and returns max 3 y
13:19:15 <luite> mysticc: did you use #{...} instead of @ or something?
13:19:26 <stribor> sipa: you said it returns another function.....what is that "other function
13:19:39 <penryu> hpc: what is the name of this feature? partial application?
13:19:47 <sipa> stribor: i just said it
13:20:00 <mysticc> luite: nope I used @{..}
13:20:04 <hpc> penryu: currying
13:20:06 <stribor> penryu: yes it is particla application i think
13:20:12 <sipa> stribor: (max 3) gives you a function, namely the function that takes an argument y and returns (max 3 y)
13:20:27 <mysticc> luite: remember , I am not using any scaffolding ..
13:20:28 <penryu> yeah, I usually end up with those two terms.
13:20:28 <hpc> partial application is more general; currying is the special case where you are partially applying the left-most argument
13:20:34 <stribor> sipa: what is "y"
13:20:34 <hpc> (i think)
13:20:44 <sipa> stribor: a function argument
13:20:55 <stribor> sipa: which is 5?
13:20:59 <sipa> no
13:21:08 <sipa> it will be 5, if you do (max 3 5)
13:21:14 <stribor> orifinally function was max 3 5
13:21:18 <mysticc> luite: In ghci when I dont use @{..} .. It complies correctly and I can see a function of that name ..
13:21:23 <sipa> that means you're supplying 5 to the function (max 3)
13:21:44 <mysticc> but it gives this error when I use that
13:21:55 <stribor> sipa: ok hang on......before you supply 5 to (max 3) doesnt (max 3) needsw to return somethingf
13:22:08 <luite> mysticc: what does :t js_script_js (or whatever your static file is) say?
13:22:08 <sipa> stribor:
13:22:15 <sipa> max is a function that takes 2 arguments
13:22:20 <penryu> afaict, (max 3 5) is equivalent to (max3 5 where max3 = max 3)
13:22:21 <stribor> sipa: yes i agree
13:22:22 <luite> mysticc: perhaps we should continue this in #yesod, fewer distractions there
13:22:23 <SmartViking> Newb question: If I define a function inside a .hs file, haskell-compiler screams at me "blalba must import func", what is that all about?
13:22:25 <sipa> max 3 is a function that takes 1 argument
13:22:37 <sipa> max 3 5 does not take any arguments
13:23:06 <stribor> sipa:  isnt max 3 5 function that takes 2 args
13:23:19 <sipa> stribor: no, because you've already supplied them
13:23:34 <stribor> sipa: oh?
13:23:46 <sipa> max takes 2 arguments
13:23:48 <SmartViking> Do I really have to create another textfile just to have functions for my program in, or how do I do it?
13:23:51 <sipa> (max 3 5) is just 5
13:23:56 <sipa> 5 does not take any argument
13:23:58 <stribor> sipa: yes agreee
13:24:26 <stribor> sipa: let me ask you this then.....if function max can take only one argument....then what is outpout of max 3
13:24:53 <sipa> stribor: (max 3) gives you a function, namely the function that takes an argument y and returns (max 3 y)
13:25:35 <Kaidelong> @ty uncurry max
13:25:36 <lambdabot> forall a. (Ord a) => (a, a) -> a
13:25:36 <sipa> what (max 3) returns is (the function that takes one argument - let's call it y - and returns (max 3 y))
13:26:03 <Kaidelong> > (uncurry max)(3,65)
13:26:04 <lambdabot>   65
13:26:17 <Kaidelong> @ty max 5
13:26:18 <lambdabot> forall t. (Num t, Ord t) => t -> t
13:26:58 <stribor> sipa:what you said above i dont see from source code?
13:28:09 <Kaidelong> application is left associative. (max 3) 5 applies the function max 3 to one argument, 5
13:29:01 <Kaidelong> you can do multi-parameter functions by using tuples instead but converting between tuples and curried stuff is trivial
13:29:03 <mysticc> suppose I have a function abc and have a x = "abc" ... so how to call function abc via x ??
13:29:35 <stribor> ok so this is for  case myFunctoion:: Int->Int->Int
13:29:38 <Kaidelong> a multi-parameter version of max would be invoked max(3,5)
13:29:48 <stribor> what is myFunction::Int->Int->Int->Int
13:30:38 <Kaidelong> the -> type constructor is right associative. Int->Int->Int->Int is the same as Int->(Int->(Int->Int))
13:31:41 <stribor> Kaidelong: then what is return type if only 2 paramethars are supplkied
13:32:09 <ncs> hey
13:32:21 <Kaidelong> stribor: when you apply a function to its argument, the thing returned is the type to the right of the ->, in this case that type would be Int->(Int->Int)
13:32:42 <stribor> Kaidelong: ok
13:32:47 <ncs> i'm having some trouble using the data type Map
13:32:54 <Kaidelong> because application is left associative, you could leave out the parenthesis. So you can write f 1 2 instead of (f 1) 2
13:32:58 <ncs> actually I don't even understand what this data type does...
13:33:00 <ncs> can anyone help
13:33:01 <ncs> ?
13:33:18 <stribor> so if you give 2 parametahrs instead of 3 it returns Int-Int
13:33:35 <ddarius> ncs: Why are you trying to use it if you don't know what it does?
13:33:51 <mysticc> :t Map
13:33:52 <lambdabot> Not in scope: data constructor `Map'
13:34:04 <mysticc> :t Data.Map.Map
13:34:05 <lambdabot> Not in scope: data constructor `Data.Map.Map'
13:34:07 <ncs> because i have an assignment that says that i have to make a function using Map
13:34:12 <ncs> Map is a DATA TYPE
13:34:18 <ncs> so, :i Map
13:34:22 <Kaidelong> stribor: I suppose. Better to say that you apply 2 to (f 1) rather than to f, when using multiple parameters
13:34:22 <stribor> > @src max
13:34:23 <lambdabot>   <no location info>: parse error on input `@'
13:34:29 <mysticc> yup similar to dictionary in python ..
13:34:38 <Kaidelong> ncs: Map associates things of one type to keys of another
13:34:59 <Kaidelong> ncs: the basic important thing you can do is...
13:35:03 <stribor> Kaidelong: so regardless of # of poarametahrs how would you generally look into constructors
13:35:10 <Kaidelong> @hoogle Map k v -> k -> v
13:35:10 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
13:35:10 <lambdabot> Data.Map findWithDefault :: Ord k => a -> k -> Map k a -> a
13:35:10 <lambdabot> Data.Map lookup :: Ord k => k -> Map k a -> Maybe a
13:35:14 <stribor> you always look at the right of ->
13:35:22 <mysticc> ncs : think it as a list of (key,value) pairs with faster lookup function because it is stored as a tree
13:35:42 <Kaidelong> stribor: right, if you have anything in the form a -> b, when you give it an a, you get a b
13:35:54 <Kaidelong> even if the b itself is another thing like (a -> b)
13:36:15 <stribor> so if you have a->b->c->d and you give it a b you get out c->d
13:36:16 <stribor> ?
13:36:25 <Kaidelong> in which case you supply the result of the first application a parameter, to get another application...
13:36:37 <Kaidelong> yeah
13:36:45 <Kaidelong> and when you give it a and b
13:36:45 <stribor> Kaidelong: thank you so much
13:37:05 <Kaidelong> what happens is that you get a b -> (c -> d) back from giving the a, then a (c -> d) back from giving the b to the result you got
13:37:24 <stribor> Kaidelong: i am gonna work on that...give me sec
13:44:10 <davidL> g/w 20
13:45:27 <m3ga> my hoogle foo os failing me. is there a way to convert from non-lazy ByteString to lazy ByteString that doesn't involve going via String?
13:46:54 <ClaudiusMaximus> @hoogle fromChunks
13:46:54 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
13:46:55 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
13:47:10 <ClaudiusMaximus> not sure if that's the one
13:50:05 <m3ga> ClaudiusMaximus: thanks. will try
13:51:17 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#v:fromChunks documentation says it's the one
13:51:58 <hpaste> vic pasted “combine files” at http://hpaste.org/52705
13:52:25 <vic___> How to get rid of that "parse error on input <-"
13:52:41 <m3ga> ClaudiusMaximus: yep, just tested it. exactly what i wanted. thanks.
13:52:48 <ClaudiusMaximus> :)
13:53:50 <ClaudiusMaximus> vic___: get rid of the second `let' : <- is only valid syntax in do blocks (or list comprehensions, or arrow notation)
13:54:12 <kmc> m3ga, going via String would be wrong anyway
13:54:24 <kmc> ByteString is a string of bytes not a string of characters
13:54:25 <vic___> <ClaudiusMaximus>: thank you
13:54:28 <kmc> you'd go via [Word8]
13:55:34 <m3ga> kmc: agree completely, but it seemed like the obvious way at first. in hindsight fromChunks is so much better.
13:56:18 <kmc> m3ga, I think you missed the point of what I was saying
13:56:40 <monochrom> "show" is how I convert ByteString to String
13:56:42 <kmc> the naive solution -- unpacking and repacking -- would go via [Word8] not [Char]
13:56:56 <copumpkin> monochrom++
13:56:56 <m3ga> ah, right
13:59:34 <kmc> ByteString.Char8 is an ugly hack
14:03:36 <kmc> if using Char8 is your "obvious way" then that's really bad
14:03:46 <kmc> sorry to be such a hardass on this
14:04:03 <ddarius> kmc: The landscape of string / binary types is settling down into a reasonably good shape.
14:04:13 <kmc> i think so too
14:04:31 <kmc> we have ByteString and Text, and reasonable ways to go between them
14:04:39 <kmc> what else do you think constitutes that landscape?
14:05:50 <navaati> hi
14:06:00 <ddarius> kmc: Vector.
14:06:13 <navaati> are there GPipe users here ?
14:08:17 <kmc> ddarius, do you think Vector Word8 will replace ByteString?
14:08:21 <kmc> (Storable Vector, that is)
14:08:29 <ddarius> kmc: Not completely.
14:08:47 <ddarius> Though if that's possible, that would be nice.
14:10:17 <ddarius> kmc: I imagine you enjoyed your foray into demo coding.
14:10:31 <kmc> you do not need to imagine, I can confirm it :)
14:12:11 <KitB> Does anyone in here have a knowledge of genetic algorithms and some spare time?
14:12:22 <KitB> (I know it's an off chance, but I'm tearing my hair out here)
14:14:31 <vic___> Nice... there's a correspondence between Haskell's monadic I/O forms and UNIX shell operations
14:16:25 <vic___> So...
14:16:33 <vic___> cat f1.txt f2.txt is
14:16:51 <mm_freak> vic___: that's a useful intuition for some people
14:16:55 <dylukes> kmc: You should change up shqq to produce eta reduced IO actions as a I suggested.
14:17:06 <dylukes> So that correspondence can be exact :D.
14:17:08 <vic___> return f1.txt f2.txt...
14:17:09 <vic___> hm
14:18:26 <mm_freak> vic___: there is some similarity between haskell's (>>=) combinator and the shell's pipe |
14:18:37 <vic___> I just need the > operator
14:18:43 <mm_freak> there is also some similarity between haskell's (>>) and the shell's &&
14:18:54 <vic___> so, cat x is return x
14:19:01 <dylukes> I think the similarity is more noticeable with Applicative, not Monad.
14:19:03 <hpc> :t (=<<) . writeFile
14:19:04 <vic___> i want cat x y z > z
14:19:04 <lambdabot> FilePath -> IO String -> IO ()
14:19:12 <hpc> vic___: ^
14:19:18 <mm_freak> yes, 'cat' acts like 'return' in that intuition
14:19:20 <vic___> cat x y z > t sorry
14:19:22 <vic___> Ok
14:21:01 <ClaudiusMaximus> @package HSH
14:21:02 <lambdabot> http://hackage.haskell.org/package/HSH
14:21:27 <mm_freak> vic___: if that intuition helps you, go with it, but don't take it for granted…  it might hurt you, when IO behaves differently
14:21:31 <dylukes> @hackage shqq
14:21:32 <lambdabot> http://hackage.haskell.org/package/shqq
14:22:12 <vic___> mm_freak: I just want to cat files using the monadic I/O
14:22:39 <mm_freak> vic___: actual files?
14:22:49 <vic___> Yes. Text files
14:22:55 <navaati> i think return is more like '<' and cat is, well…
14:22:59 <mm_freak> then 'return' does something completely different
14:23:00 <navaati> :t fmap concatenate
14:23:01 <lambdabot> Not in scope: `concatenate'
14:23:11 <navaati> :t fmap concat
14:23:12 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
14:23:30 <navaati> assuming files are Strings
14:23:55 <mm_freak> the equivalent to 'cat' would be foldM (\xs -> fmap (xs ++) . readFile) ""
14:24:03 <mm_freak> :t foldM (\xs -> fmap (xs ++) . readFile) ""
14:24:04 <lambdabot> [FilePath] -> IO String
14:24:37 <navaati> :t foldM
14:24:38 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:24:41 <navaati> nice !
14:24:52 <shachaf> vic___: Oleg had a specific thing in mind when he said UNIX shell programming was like monadic I/O.
14:25:16 <vic___> I understand. Didn't know about foldM
14:25:20 <vic___> I'll try now with that
14:25:25 <shachaf> It only makes sense if you think of it in that specific sense.
14:25:30 <mm_freak> vic___: haskell's 'return' is more like 'echo' in that regard
14:25:35 <vic___> I see
14:25:41 <hpaste> SmartViking pasted “Extremely newbish and dumb?” at http://hpaste.org/52708
14:26:08 <mm_freak> vic___: don't take that literally…  really, it's nice as an intuition, but won't really help you write actual software
14:26:10 <navaati> in facts, IO values are more like file descriptors in unix
14:26:14 <shachaf> Haskell's return is more like wrapping a burrito.
14:26:15 <kmc> what
14:26:19 <mm_freak> navaati: huh?
14:26:24 <kmc> how are IO actions like file descriptors?
14:26:38 <kmc> @where burrito
14:26:38 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
14:26:51 <shachaf> People have made dozens of analogies in here already; you can probably argue, fainly, for all of them, but I doubt it'll help anyone much.
14:27:14 <navaati> using read on a files descriptors i can get bytes from a file, or a program, or more generally a "computation"
14:27:16 <kmc> if you'd like to advance an analogy please read this article first :)
14:27:41 <vic___> Googled for the wrong thing. Sort of
14:27:44 <shachaf> SmartViking: I recommend that you insult your code a little more; it makes us more likely to want to help you. :-)
14:27:47 <kmc> SmartViking, do you have a question?
14:27:51 <vic___> I just want to cat an arbitrary number of text files into one.
14:27:59 <vic___> Pretty simple. But I'm using monads, haha
14:28:00 <shachaf> SmartViking: What are you actually trying to do?
14:28:20 <SmartViking> I'm just learning haskell, this is the first program that I actually got to compile
14:28:32 <mm_freak> navaati: IO values are really just procedures
14:28:41 <SmartViking> I'm not sure about this line, is this correct for nested lists with integers?
14:28:44 <SmartViking> f :: [[Int]] -> Int
14:28:48 <mm_freak> an IO String is a procedure that yields a String, and that's about it
14:29:01 <shachaf> SmartViking: That line says that f is a function from lists of lists of Ints to Ints.
14:29:06 <SmartViking> What is that anyway, do I have to do it because haskell is statically typed?
14:29:10 <shachaf> SmartViking: What's "o" and "li"?
14:29:19 <shachaf> SmartViking: You don't have to do it. The program will work if you take it out.
14:29:27 <kmc> SmartViking, you usually do not have to write down types, but it's considered good style to write them on your top-level bindings
14:29:30 <shachaf> It's a good idea to do it, though, because it makes it easier to read.
14:29:41 <kmc> "statically typed" means that the types are known to the compiler, not that you wrote them explicitly
14:29:52 <kmc> main = do xs <- getArgs; mapM BS.readFile xs >>= (BS.putStr . BS.concat) -- vic___
14:30:01 <navaati> don't worry, i know what IO values and monads are ;)
14:30:01 <navaati> i thought we were just joking here, but i realize that vic___ is trying to implements this analogy, which is wrong…
14:30:10 <SmartViking> shachaf: Variables or whatever? Is there another way? I'm new to functional programming
14:30:19 <vic___> kmc: thank you
14:30:23 <monochrom> SmartViking: you are right about what [[Int]] means
14:30:28 <shachaf> SmartViking: Those names don't mean much to someone who's reading the program.
14:30:30 <kmc> SmartViking, did you at some point say what you were trying to do or why it doesn't work?
14:30:32 <SmartViking> kmc: ok, faster compile time and better readability?
14:30:37 <kmc> SmartViking?
14:30:43 <kmc> SmartViking, types help you catch errors early
14:30:53 <SmartViking> Aha
14:31:07 <kmc> most likely, Haskell's type system is vastly different from anything you've seen before
14:31:14 <navaati> is haskell98 entirely inferable ?
14:31:14 <kmc> so you'll have to take it on faith initially
14:31:19 <SmartViking> shachaf: Yeah, I'm not good with naming, if I ever get a child I'll name it "var1"
14:31:23 <ddarius> navaati: No.
14:31:26 <kmc> that this really is useful, and not cumbersome
14:31:41 <shachaf> Types make you an inferior programmer, crippled, reliant on machines instead of your own mental skills.
14:31:42 <monochrom> (show . read) is not entirely inferrable. but that's basically it.
14:31:46 <kmc> SmartViking, ah, but you were asking why to write the types, not why they exist?
14:31:52 <shachaf> (This last line isn't true.)
14:32:08 <kmc> SmartViking, the difference to compile time is negligible
14:32:11 <shachaf> SmartViking: You write the types because it's easier for other people to make sense of the program.
14:32:17 <ddarius> shachaf: Programmers are (in practice) already reliant on machines.
14:32:19 <kmc> SmartViking, you write down types because they are like comments which can be checked by the machine
14:32:23 <shachaf> I expect that writing the types will make your program take longer to compile.
14:32:28 <SmartViking> Ah, that makes sense
14:32:47 <SmartViking> Awesome, thanks for the help. :)
14:32:49 <kmc> :)
14:32:54 <shachaf> SmartViking: If there's no point to the name "o", you can just say "main = print (f li)"
14:32:54 <monochrom> when I did lisp homework, I wrote types in comments anyway. too confusing otherwise.
14:33:25 <mm_freak> SmartViking: put differently…  types are the specification of your program…  given type signatures the compiler can actually make sure that your code matches your specification
14:33:25 <vic___> kmc: BS.putStr > Data.ByteString?
14:33:28 <mendez> is there a way to make an infinite list of functions like [Integer -> Integer]?
14:33:29 <kmc> yes
14:33:32 <vic___> ok
14:33:33 <shachaf> mendez: Yes.
14:33:34 <kmc> import qualified Data.ByteString as BS
14:33:43 <vic___> Yeah, got it.
14:33:48 <shachaf> @type cycle [(+1)] -- An example of such a list.
14:33:48 <lambdabot> forall a. (Num a) => [a -> a]
14:33:49 <monochrom> @type repeat id
14:33:50 <lambdabot> forall a. [a -> a]
14:33:57 <mm_freak> SmartViking: http://www.haskell.org/haskellwiki/Why_Haskell_just_works
14:34:01 <monochrom> my infinite list of functions is even more general
14:34:05 <navaati> > cycle 2
14:34:06 <lambdabot>   No instance for (GHC.Num.Num [a])
14:34:06 <lambdabot>    arising from a use of `e_12' at <inter...
14:34:09 <SmartViking> shachaf: Ahm I was kind of confused about what and whatnot to put inside main
14:34:11 <shachaf> Haskell "just works"?
14:34:16 <mendez> shachaf: i've been trying to using list comprehensions and it gives me the same type exception
14:34:20 <ddarius> cycle [x] = repeat x
14:34:32 <kmc> monochrom, your infinite list of functions sucks, I can't use function 0 at one type and function 1 at another
14:34:35 <SmartViking> mm_freak: ty
14:34:42 <shachaf> ddarius: That definition of cycle is incomplete. :-)
14:34:53 <monochrom> cycle wants a list
14:35:02 <ddarius> shachaf: Good thing it is not a definition.
14:35:11 <ClaudiusMaximus> > cycle []
14:35:12 <mendez> ddarius: thanks repeat does exactly what i need!
14:35:12 <lambdabot>   *Exception: Prelude.cycle: empty list
14:35:14 <stribor> can someone give me e3xample of using $ operator please
14:35:20 <shachaf> That line, viewed as a definition of cycle, gives an incomplete definition of cycle.
14:35:23 <monochrom> > sin $ 0
14:35:24 <lambdabot>   0.0
14:35:28 <monochrom> example of using $
14:35:36 <shachaf> @google how to make $ fast
14:35:37 <lambdabot> http://www.wikihow.com/Make-Money-Fast
14:35:37 <lambdabot> Title: How to Make Money Fast - wikiHow
14:35:48 <stribor> what does it do $
14:35:54 <shachaf> Nothin'
14:35:55 <kmc> @src ($)
14:35:56 <lambdabot> f $ x = f x
14:35:57 <monochrom> doesn't do anything
14:36:12 <kmc> > length $ take 20 [1..]
14:36:13 <lambdabot>   20
14:36:16 <stribor> oh gosh...you gota love operator that do nothing :)
14:36:16 <ClaudiusMaximus> > map ($ 4) [(+1),(*2),(^3)]
14:36:16 <lambdabot>   [5,8,64]
14:36:18 <kmc> > length (take 20 [1..])
14:36:19 <lambdabot>   20
14:36:21 <monochrom> or rather, doesn't do anything you can do
14:36:40 <mm_freak> stribor: it does something…  it's function application
14:36:57 <mm_freak> > map ($ 3) [sin, cos, tan]
14:36:58 <lambdabot>   [0.1411200080598672,-0.9899924966004454,-0.1425465430742778]
14:37:11 <hpc> > flip 3 [sin, cos, tan]
14:37:12 <lambdabot>   No instance for (GHC.Show.Show (f b))
14:37:13 <lambdabot>    arising from a use of `M5823640298...
14:37:14 <ddarius> ($) ⊒ id
14:37:19 <hpc> :t flip
14:37:20 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:37:26 <hpc> > flip [sin, cos, tan] 3
14:37:26 <navaati> stribor: it's purpose is, most of the time, to replace parenthesis
14:37:27 <lambdabot>   [0.1411200080598672,-0.9899924966004454,-0.1425465430742778]
14:37:31 <alpounet> stribor, basically, it lets you write code with less parenthesis
14:37:34 <stribor> what would happen if you did map (3) [sin,cos,tan]
14:37:41 <mendez> never knew you could use ($) with a map like that, fucking awesome
14:37:46 <kmc> stribor, type error
14:37:49 <hpc> stribor: 3 isn't a function
14:37:49 <kmc> because 3 isn't a function
14:37:49 <ddarius> > map (3) [sin, cos, tan]
14:37:50 <hpc> :t 3
14:37:50 <lambdabot>   [3,3,3]
14:37:51 <lambdabot> forall t. (Num t) => t
14:37:53 <hpc> :t ($ 3)
14:37:54 <lambdabot> forall a b. (Num a) => (a -> b) -> b
14:38:07 <tkahn> i think lambda bot has something weird for Num
14:38:08 <kmc> it's complicated by the fact that numeric literals are polymorphic
14:38:10 <mm_freak> depends on whether you do it in lambdabot =)
14:38:10 <SmartViking> Does anyone know about any haskell video tutorials, or video lectures? I'm almost as lazy as haskell in that I love to just sit and watch other people write code :)
14:38:15 <mm_freak> > map 3 [sin, cos, tan]
14:38:16 <lambdabot>   [3,3,3]
14:38:18 <mm_freak> ;)
14:38:21 <kmc> so the actual error is "you didn't tell me how to make a function from an integer"
14:38:45 <shachaf> SmartViking: Haskell is not known to just sit and watch other people write code.
14:38:45 <tkahn> > 3 2
14:38:46 <lambdabot>   3
14:38:49 <tkahn> lol
14:39:02 <shachaf> tkahn is easily entertained.
14:39:08 <parcs_> SmartViking: watch yourself code
14:39:19 <hpc> instance Num a => b -> a where fromIntegral = const -- etc
14:39:26 <SmartViking> parcs_: aww but I do so many mistakes :)
14:39:32 <kmc> that's how you learn
14:39:39 <mm_freak> SmartViking: that won't really help you as a beginner…  as a more advanced haskell programmer video tutorials are actually nice to watch
14:39:54 <tkahn> > 3 $ 2 1
14:39:55 <lambdabot>   3
14:39:56 <mm_freak> so first work, then enjoy =)
14:39:59 <vic___> kmc: I ran ghc on that one liner and it gave me
14:40:01 <vic___> compilation IS NOT required
14:40:09 * shachaf learns by not making mistakes.
14:40:12 <vic___> So i just type runhaskell script.hs
14:40:14 <SmartViking> mm_freak: Why is it different?
14:40:16 <vic___> and the filenames...
14:40:17 <monochrom> there are haskell videos but I don't know of any
14:40:22 * Twey has never understood video coding tutorials
14:40:27 <kmc> SmartViking, there's http://channel9.msdn.com/Shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1
14:40:31 <Twey> It's just like reading code!  Except slower!
14:40:39 * Ferdirand has never understood video tutorials
14:40:39 <kmc> and http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-tutorial/index.htm and http://haskell.org/haskellwiki/Video_presentations
14:40:40 <mm_freak> SmartViking: because to learn haskell you need to write code
14:40:41 <mendez> imo the videos are for different types of learners
14:40:42 <mm_freak> you just need to
14:40:58 <mm_freak> otherwise the only thing you'll learn is to copy code from the tutorial
14:41:00 <mendez> i'm a visual learner so i prefer books but differet strokes for different folks
14:41:17 <navaati> SmartViking: if you wwant to read code, read the standard library
14:41:18 <kmc> http://en.wikipedia.org/wiki/Learning_styles#Criticism
14:41:24 <vic___> go for the hybrid approach: books, reading code on your own, podcasts, video tutorials
14:41:27 <vic___> and IRC ;-)
14:41:38 <vic___> #haskell is an awesome place to learn
14:41:39 <monochrom> direct wifi to your brain
14:41:46 <kmc> basically it's highly controversial whether "learning styles" are a thing at all
14:42:22 <shachaf> kmc: Every person must find their own burrito analogy.
14:42:26 <navaati> let's make a "Haskell for Dummies" \o/ (wait, no)
14:42:40 <Twey> That's basically Learn You A Haskell :þ
14:42:45 <SmartViking> I'm the type that actually remembers stuff I see in videos, and error caught in a video mean as much as an error I do myself, when I write code myself I just feel that I'm wasting time, and potentionally making bad coding a habit :)
14:43:06 <shachaf> SmartViking: An error caught in a video is very different from an error you make.
14:43:10 <SmartViking> kmc: ty
14:43:10 <shachaf> Unless you're in the video, that is.
14:43:14 <monochrom> I'm actually fine with existence of diverse learning styles, because its logical conclusion is: natural selection implies that most of them are doomed to fail.
14:43:17 <cvic_> The Khan Academy way
14:43:21 <mm_freak> SmartViking: try it out, if you find a tutorial
14:43:38 <mm_freak> but i'm sure it won't help you as much as a written tutorial/book
14:43:52 <b_jonas> I guess even if you're watching a video lecture you could then write code yourself. Video tutorial doesn't differ from a book in this respect.
14:44:04 <cvic_> You learn a lot by trial and error
14:44:05 <cvic_> Nuff said
14:44:09 <mm_freak> SmartViking: basically you are going to learn what haskell is /not/ ;)
14:44:25 <kmc> "learning styles" are popular in American grade school etc. because you're not allowed to say that kids aren't learning because they're dumb or they don't give a fuck or the teacher is bad
14:44:27 <cvic_> Do a lot of mistakes.
14:44:31 <hpaste> erus` pasted “can i use a foldl in f?” at http://hpaste.org/52710
14:44:42 <erus`> please help :)
14:44:47 <b_jonas> kmc: who is the "you" in that one?
14:45:03 <kmc> any of the relevant parties
14:45:15 <b_jonas> some people do seem to say that on blogs
14:45:16 <mm_freak> cvic_: not entirely true for haskell…  compared to other languages it's very logical…  if you don't understand it, then mostly you won't get past the compiler
14:45:38 <b_jonas> mm_freak: right, the shoot in the foot thing
14:45:41 <kmc> sure, but the teachers and school administrators and policymakers can't
14:45:42 <cvic_> Well, yeah. That's why you need to read a tutorial or a book
14:45:47 <mm_freak> you need to learn the basics…  it's not like a scripting language, where you can just write commands to perform
14:45:50 <cvic_> Then play with it
14:45:54 <b_jonas> kmc: even some teachers say that
14:46:19 <cvic_> mm_freak: well, you can use Haskell as a scripting language too. Sort of :-p
14:46:27 <cvic_> *for scripting
14:46:28 <kmc> "scripting language" is a meaningless term
14:46:34 <cvic_> Indeed
14:46:36 <kmc> it's worse than meaningless because it has a pejorative connotation
14:46:47 <b_jonas> which one is more meaningless, "functional language" or "scripting language"?
14:46:55 <cvic_> scripting language
14:47:03 <SmartViking> Btw, what is the link between microsoft and haskell?
14:47:09 <cvic_> functional language is ok
14:47:13 <monochrom> which one is more meaningless, "meaningful" or "meaningless"?
14:47:19 <stribor>  can amnyone show example oif map function using $
14:47:19 <kmc> SmartViking, several key GHC developers are employed by Microsoft Research to work on GHC
14:47:25 <kmc> > map ($ 3) [pred, succ]
14:47:26 <lambdabot>   [2,4]
14:47:28 <dylukes> kmc: Seems like a good deal for them :P.
14:47:28 <ion> cvic: <a href="http://www.haskell.org/">
14:47:40 <cvic_> ion: yes?
14:47:47 <SmartViking> kmc: An free software project?
14:47:50 <SmartViking> a*
14:47:56 <kmc> SmartViking, yes, it's the most popular Haskell compiler by far
14:48:00 <monochrom> yes, BSD-like licence
14:48:05 <kmc> and it's available under a permissive free software license
14:48:18 <SmartViking> Awesome to see microsoft do something good for a change
14:48:31 <cvic_> MS is not the evil empire. Heh
14:48:38 <b_jonas> come on, that's not the only good thing they're doing
14:48:39 <kmc> herp derp more like MICRO$HAFT
14:48:42 <navaati> SmartViking: two great haskell coders (i think they work on GHC) are paid by Microsoft Labs (which is very different of Microsoft, i guess)
14:48:43 <kmc> cause i'm from slashdot in 1996
14:48:46 <b_jonas> just because they're evil, they can do good things
14:48:48 <b_jonas> in fact, they must
14:48:53 <kmc> MICRO$UX WINBLOWZE
14:48:59 <b_jonas> you can sell lies only if most of what you're saying is true
14:49:05 <cvic_> Fast: name 3 EVIL EVIL CORPORATIONS
14:49:07 <kmc> take that bill gates or should i say BORG gates
14:49:13 <cvic_> Haha
14:49:18 <b_jonas> cvic_: oracle, microsoft, google, apple
14:49:19 <mm_freak> cvic_: as long as you don't get confusing type errors
14:49:22 <mm_freak> > sin "3"
14:49:27 <lambdabot>   No instance for (GHC.Float.Floating [GHC.Types.Char])
14:49:27 <lambdabot>    arising from a use...
14:49:29 <cvic_> Excellent
14:49:39 <monochrom> ABC, NBC, CNN
14:49:48 <cvic_> Coca Cola, MCD
14:49:51 <cvic_> McD
14:49:59 <b_jonas> or any political parties
14:49:59 <cvic_> Nvm, they're all evil.
14:50:02 <b_jonas> cvic_: coca cola? how are they evil?
14:50:13 <cvic_> They produce a dark beverage.
14:50:19 <kmc> http://en.wikipedia.org/wiki/Category:Tobacco_companies_of_the_United_States
14:50:28 <b_jonas> you don't like dark beer?
14:50:35 <jmcarthur> mm beer
14:50:40 <navaati> they are, because coca cola used to have a good taste, wich is no longer true…
14:50:43 <cvic_> Dark beer is produced by Belgian monks.
14:50:45 <cvic_> So, no
14:50:53 <cvic_> The good one
14:50:55 <b_jonas> navaati: when?
14:51:07 <monochrom> name 3 evil haskellers
14:51:08 <navaati> when i was a child ^^
14:51:38 <cvic_> Haskellers that create  ICBM software
14:51:41 <cvic_> Yeah
14:51:43 <jmcarthur> Rumpelstiltskin Rumpelstiltskin Rumpelstiltskin
14:51:49 <b_jonas> monochrom: me, and I don't know any others
14:51:51 <kmc> by the way, what the fuck is going on in this channel?
14:51:56 <cvic_> Ok, enough.
14:52:06 <cvic_> there is #haskell-offtopic
14:52:08 <erus`> http://stackoverflow.com/questions/7787641/how-can-i-make-this-code-neater earn some karma
14:52:10 <cvic_> #haskell-blah
14:52:12 <ciaranm> what is it with haskell and ICBMs? is that just simon peyton-jones' influence?
14:52:15 <b_jonas> navaati: doesn't help me. I don't know your age.
14:52:15 <kmc> you should all join #haskell-offtopic
14:52:22 <shachaf> Yes.
14:52:27 * cvic_ goes back to Haskell one-liners 
14:52:31 <navaati> is there a difference (any kind of difference : semantic, perfs…) between "f a = …" and "f = \a → …" ?
14:52:36 <shachaf> #haskell-offtopic is the official offtopic channel for Haskell.
14:52:36 <cvic_> Because Haskell is cool
14:52:58 <benmachine> navaati: if 'a' is a pattern then yes, otherwise no
14:53:11 <benmachine> by a pattern I mean, like, (x:xs) or (Just p) or something
14:53:56 <astory> is there a standard on where to place quickcheck test code?  (for example, in python, it's common to test foo.py in foo_test.py)
14:54:12 <navaati> you mean that there's a difference because i can't pattern-match on other cases in a lambda ?
14:54:21 <benmachine> navaati: yeah, basically
14:54:43 <benmachine> if the pattern match in a lambda fails, you just get an error
14:54:52 <b_jonas> the pattern in the lambda is matched lazily, the one in the function declaration is matched strictly, right?
14:54:54 <benmachine> if the pattern match in a function fails, you go to the next pattern
14:55:01 <MatrixFrog> astory: i think that question was asked on reddit once maybe...
14:55:08 <benmachine> > (\(Just x) -> ()) Nothing
14:55:08 <navaati> ok, so for a type with a unique constructor there is no difference…
14:55:09 <alpounet> astory, http://www.haskell.org/cabal/users-guide/#test-suites ?
14:55:09 <lambdabot>   *Exception: <interactive>:3:1-15: Non-exhaustive patterns in lambda
14:55:15 <b_jonas> navaati: yes there is
14:55:23 <astory> alpounet: looking, thanks.
14:55:23 <benmachine> b_jonas: doesn't seem so
14:55:35 <b_jonas> > let { f True = 42; } in f False
14:55:36 <lambdabot>   *Exception: <interactive>:3:6-16: Non-exhaustive patterns in function f
14:55:39 <alpounet> astory, i'm affraid that doesn't precisely answers your question though
14:55:41 <b_jonas> > let { f = \True -> 42; } in f False
14:55:42 <lambdabot>   *Exception: <interactive>:3:10-20: Non-exhaustive patterns in lambda
14:55:43 <MatrixFrog> astory: or stackoverflow, but i can't find it there. and reddit seems to be kinda down
14:55:45 <astory> yeah...
14:55:47 <b_jonas> hmm
14:56:02 <b_jonas> > let { f = \~True -> 42; } in f False
14:56:03 <lambdabot>   <no location info>: parse error on input `\~'
14:56:10 <b_jonas> > let { f = \ (~True) -> 42; } in f False
14:56:11 <lambdabot>   42
14:56:24 <navaati> oh, irrefutable patterns
14:56:47 <b_jonas> so that means there is no difference?
14:56:49 <astory> well, what I can find on reddit doesn't say much.  What do *you* do?
14:56:50 <benmachine> navaati: if that's the only equation to the function there's basically no difference
14:57:06 <benmachine> (that I can think of, anyway)
14:57:08 <alpounet> astory, generally in a 'tests/' directory
14:57:38 <navaati> ok, so for good style purpose i can use both…
14:57:41 <navaati> thanks
14:59:07 <kmc> there is another difference navaati
14:59:18 <kmc> f = \x → ... where ...
14:59:24 <kmc> the stuff in "where" does not have access to x
14:59:32 <MatrixFrog> astory: i've never really published a haskell module so i don't know. but iirc the discussion was kind of weighing the pros and cons -- you don't want to have your module depend on quickcheck directly. but on the other hand you do want the tests to be part of the package, not isolated elsewhere...
14:59:47 <MatrixFrog> i think someone came up with a good fix. just wait for reddit to come back up  :P
14:59:52 <kmc> here's an important consequence:
14:59:57 <kmc> f x = \y → ... where ...
14:59:59 <navaati> kmc: oh, smart, i didn't thought about this one !
15:00:02 <astory> I could access reddit fine, but it's hard to skim :D
15:00:15 <kmc> the "where" block can compute some data structure based on x
15:00:28 <MatrixFrog> oh it's back up yay
15:00:42 <kmc> and then other code can say «let g = f 3 in (g 4, g 5, g 6)»
15:00:46 <kmc> and that computation is done only once
15:00:57 <kmc> if you wrote «f x y = ...» you would not have this behavior
15:01:01 <mysticc> @hoogle (=<<)
15:01:02 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
15:01:02 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
15:01:10 <kmc> it is implementation-dependent though, and various optimizations can come into play
15:01:38 <b_jonas> kmc: I see
15:01:43 * hackagebot rdioh 0.1.0 - A Haskell wrapper for Rdio's API.  http://hackage.haskell.org/package/rdioh-0.1.0 (AdityaBhargava)
15:02:15 <monochrom> ***Exception: pattern-matching failure
15:02:27 <monochrom> err, wrong time :)
15:02:33 <MatrixFrog> astory: i guess http://www.reddit.com/r/haskell/comments/7uu1b/koweycode_practical_quickcheck_wanted/ and http://www.reddit.com/r/haskell/comments/fooeb/practical_quickcheck_revisited_separate_testing/ were the threads i was thinking of
15:03:03 <astory> thanks, I'll give those a read
15:03:22 <navaati> kmc: yeah, in fact this optimization is rather intuitive : f 3 computes a function, and computes it only one time. thank you, it was the kind of difference i was looking for
15:04:41 <ddarius> When did #haskell-offtopic get made ... ?
15:05:36 <b_jonas> ddarius: probably when the pointer to #haskell-blah got removed from the topic
15:06:09 <b_jonas> the channel name for #haskell-blah is almost as difficult to guess as #not-math or #perl-cafe, so it should be mentioned in the topic
15:06:17 <shachaf> ddarius: Just now, after you asked.
15:06:22 <b_jonas> (though #perl-cafe isn't really the off-topic channel of a channel)
15:06:48 <b_jonas> someone please add a mention to #haskell-blah in the topic
15:07:22 <shachaf> I don't think it should be in the topic.
15:07:30 <shachaf> #haskell-blah is where we make fun of people in #haskell
15:07:49 <Philippa> I thought that was -ops? :p
15:07:52 <ddarius> But don't worry, #haskell-blah is also where we make fun of people in #haskell-blah.
15:08:03 <shachaf> True.
15:08:14 <b_jonas> hmm, you can't add it because the topic is almost maximum length
15:08:22 <shachaf> To be fair, most people in #haskell-blah are also in #haskell
15:08:23 <b_jonas> remove something and add it then
15:08:37 <monochrom> #haskell-diagonal makes fun of those who don't make fun of themselves
15:08:38 * shachaf wonders whether ddarius is in #-blah under a pseudonym
15:09:27 <astory> monochrom: shouldn't it be where people who don't make fun of themselves make fun of themselves?
15:09:34 * monochrom votes for removing "Haskell News: http://reddit.com/r/haskell"
15:10:07 * shachaf votes for not adding -blah to the topic.
15:10:52 <b_jonas> shachaf: is the intent to hide -blah from newcomers so we can make fun of them there?
15:10:54 * monochrom votes for replacing by "Haskell News: #haskell-blah"!
15:11:22 <hpaste> vic pasted “ambiguous occurences” at http://hpaste.org/52713
15:11:32 <shachaf> b_jonas: Yes.
15:11:36 <cvic_> OK, I feel weird puttinf Prelude.filter
15:11:39 <cvic_> *putting
15:11:46 <monochrom> what is the ambiguous ocurrences?
15:11:48 <shachaf> b_jonas: Not that it'll stop us from making fun of them if they join the channel.
15:11:55 <cvic_> filter
15:11:57 <cvic_> and notElem
15:12:14 <monochrom> oh, they are in both Prelude and BS
15:12:18 <shachaf> cvic_: You usually import ByteString qualified.
15:12:18 <cvic_> Yep.
15:12:23 <shachaf> You should do that.
15:12:25 <cvic_> Ah..
15:12:39 <monochrom> import qualified Data.ByteString as BS
15:12:42 <shachaf> Also, use \\, not filter (`notElem` ...).
15:13:03 <kmc> nobody makes fun of newcomers for being bad at haskell
15:13:04 <shachaf> (And fmap/liftM or something.)
15:13:13 <kmc> that'd be mean
15:13:24 <shachaf> kmc: I don't think anybody does that.
15:13:51 <monochrom> I make fun of oldcomers being too good at haskell
15:13:52 <kmc> but #haskell gets actual trolls or just obnoxious people on a fairly regular basis
15:13:53 <cvic_> Great. not in scope BS.readFile
15:13:54 <shachaf> cvic_: Is there any reason you're writing everyone in one line in point-free style?
15:14:07 <kmc> one consequence of being one of the largest channels on Freenode
15:14:11 <cvic_> Um
15:14:12 * MatrixFrog thinks 'or' and 'and' should have been called 'any' and 'all'
15:14:18 <kmc> :t any
15:14:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:14:23 * cvic_ has no idea what he's doing 
15:14:29 <kmc> > any odd [1,3,6]
15:14:30 <lambdabot>   True
15:14:31 <MatrixFrog> ohhh i see
15:14:37 <monochrom> yeah, BS.readFile should work fine
15:14:37 <MatrixFrog> why did i not know that?
15:14:40 * MatrixFrog :(
15:14:47 <kmc> @src any
15:14:47 <lambdabot> any p =  or . map p
15:15:01 <cvic_> I think mapM BS.readFile files >>= (BS.putStr . BS.concat) is not right
15:15:38 <shachaf> cvic_: As in main = do { files <- fmap (...) getDirectoryContents; fileContents <- mapM BS.readFile files; BS.putStr (BS.concat files) }
15:15:41 <kmc> not right?
15:15:53 <kmc> can you explain what goes wrong?
15:16:06 <monochrom> is it because lines 5 and 6 are currently two lines but should be one?
15:16:14 <shachaf> Oh.
15:16:16 <cvic_> Nevermind. I'll try something else
15:16:17 <cvic_> Sorry
15:16:35 <monochrom> and even then something's wrong. what shachaf says
15:18:35 <johnfn> i want to make a 2d array a functor so that i can do like fmap (+1) [[1,2],[3,4] == [[2,3],[4,5]], but my approaches are proving unsuccessful. i did type Matrix a = [[a]] but when i do instance Functor [[a]] i get stuff about how the kind has to be * -> * but it's only *
15:19:07 <shachaf> johnfn: That's not a 2D array.
15:19:28 <shachaf> It's a list of lists.
15:19:45 <shachaf> There's already a Functor instance for lists of lists, namely, the Functor instance for lists.
15:19:47 <johnfn> yeah, i apologize for the incorrect terminology
15:19:56 <johnfn> right
15:19:59 <navaati> :t fmap fmap (+1) [[1,2],[3,4]
15:20:00 <lambdabot> parse error (possibly incorrect indentation)
15:20:05 <navaati> :t fmap fmap (+1) [[1,2],[3,4]]
15:20:05 <lambdabot>     Couldn't match expected type `[[t]]' against inferred type `a -> b'
15:20:06 <lambdabot>     In the expression: fmap fmap (+ 1) [[1, 2], [3, 4]]
15:20:17 <navaati> > fmap (fmap (+1)) [[1,2],[3,4]]
15:20:18 <lambdabot>   [[2,3],[4,5]]
15:20:19 <shachaf> > fmap fmap fmap (+1) [[1,2],[3,4]] -- Ignore this, johnfn
15:20:20 <lambdabot>   [[2,3],[4,5]]
15:20:25 <ClaudiusMaximus> > fmap (+1) . listArray ((1,1),(2,2)) . take 4 $ [1..]
15:20:27 <lambdabot>   array ((1,1),(2,2)) [((1,1),2),((1,2),3),((2,1),4),((2,2),5)]
15:20:43 <johnfn> ...wow, triple fmap
15:20:43 <shachaf> johnfn: If you want a to define a Functor instance that does what you want, you'll have to define your own type.
15:20:54 <johnfn> gotcha
15:21:04 <zygoloid> triple fmap... all the way!
15:21:17 <navaati> fmap fmap fmap, it uses the fact that a → r is a functor ?
15:21:21 <shachaf> Yes.
15:21:29 <hpc> it's the same as fmap . fmap
15:21:30 <shachaf> Well, that (a ->) is a Functor.
15:21:38 <b_jonas> johnfn: I just mentioned a solution for that today
15:21:40 <johnfn> i felt like that was a little clunky since i did data Matrix a = Items [[a]] and it was weird that Matrix would have only one type
15:22:01 <shachaf> johnfn: You often use "newtype" instead of "data" for that.
15:22:07 <shachaf> newtype is like "type", but with type safety.
15:22:43 <hpc> shachaf: that's like saying "it's like raisins, only it tastes good"
15:22:45 <johnfn> ooh perfect
15:22:46 <shachaf> Type safety is generally a good thing, not a bad thing; a Matrix is a different thing from a list of lists, and you don't want just any function that can operate on a list of lists to automatically operate on a Matrix.
15:22:50 <b_jonas> johnfn: turns out Control.Compose.O wraps a list of lists just the way you want
15:23:04 <b_jonas> thanks to byorgey who pointed out that package for me
15:23:18 <shachaf> johnfn: Anyway, if you define Matrix that way, you can say instance Functor Matrix where ...
15:23:27 <johnfn> wow, so many fun things
15:23:34 <johnfn> that's perfect, thanks
15:23:59 <shachaf> johnfn: You can't say "instance Functor (Matrix a) where ...", though.
15:24:08 <astory> hmm, so realworldhaskell uses Tst.QuickCheck.Batch, but I can't find it on hoogle; is that not a thing anymore?
15:24:14 <shachaf> Matrix is a Functor, not (Matrix a).
15:24:23 <astory> s/Tst/Test/
15:24:26 <shachaf> That's one reason your "instance Functor [[a]] where" didn't work.
15:25:19 <johnfn> hmmm
15:26:01 <monochrom> do "instance Functor Matrix", cf "instance Functor Maybe", "instance Functor IO"... (no "a")
15:27:33 <hpaste> vic pasted “not in scope” at http://hpaste.org/52714
15:27:34 <MatrixFrog> astory: some stuff in rwh is out of date, but people often say so in the comments
15:27:45 <hjulle> Is "59,614,953,644 bytes allocated in the heap" a sign of a memory leak?
15:27:45 <cvic_> Ok, so what's wrong there with fmap...
15:28:55 <hpc> hjulle: no; haskell programs easily go through gigs per second at times, just because each new value is an allocation instead of a mutation of an existing value
15:29:05 <monochrom> fmap (\\ [".", ".."]) (SD.getDirectoryContents "/home/user/text")
15:29:14 <b_jonas> monochrom: no I think
15:29:28 <b_jonas> monochrom: it's supposed to be fmap instance for (->)
15:29:31 <monochrom> the fmap there is liftM
15:29:34 <hpc> hjulle: it's not slow either; GHC does deep magic that i only tenuously understand myself
15:29:43 <ddarius> any/or and all/and are instances of Yoneda.
15:29:53 <b_jonas> oh, right
15:29:55 <b_jonas> I'm stupid
15:29:56 <b_jonas> sorry
15:30:10 <b_jonas> it's fmap for IO so you need the parenthesis
15:30:12 <b_jonas> right
15:30:14 <cvic_> Hmm, let's see
15:30:39 <geekosaur> it's more that, since haskell uses space to separate funciton arguments, if you're involimg something that itself takes an argument you need to wrap in parens
15:30:51 <geekosaur> getDirectoryContents being the thing in question
15:31:13 <Bo3Bo3>  http://weddingwarehouse.com/  Weddings and wedding planning at the Wedding Warehouse Bridal Resource Center. Find wedding dresses and gowns, bridal beauty, photographers, disc Come and See OffeR
15:31:56 <jchia> hi
15:32:03 <cvic_> And now... a parse error
15:32:03 --- mode: ChanServ set +o Saizan
15:32:10 <kmc> allocation in GHC is very fast; it's just incrementing a pointer
15:32:11 <cvic_> Here  fileContents <- mapM BS.readFile files; BS.putStr ( BS.concat files )
15:32:21 --- mode: Saizan set -o Saizan
15:32:23 <kmc> you pay for that allocation eventually, in garbage collection
15:32:38 <jchia> i have a basic question about some code from the LYAH book that my ghci doesn't like
15:32:55 <kmc> so making the garbage collector fast is one of the main areas of GHC development over its lifetime
15:33:04 <jchia> can someone help me understand the error message? 2 lines of code
15:33:14 <kmc> it drives a lot of other design decisions
15:33:20 <kmc> jchia, just ask; put the code and error on hpaste.org
15:33:55 <hpaste> monochrom annotated “not in scope” with “not in scope (annotation)” at http://hpaste.org/52714#a52715
15:34:09 <monochrom> cvic_: see my paste
15:34:16 <ddarius> kmc: Well you also have to initialize memory that is allocated modulo some arrays.
15:34:29 <cvic_> monochrom: thank you
15:34:29 <hpaste> “LYAH author” pasted “find-key.hs” at http://hpaste.org/52716
15:34:30 <kmc> *nod*
15:34:43 <kmc> i don't think that's traditionally accounted as part of the cost of allocation
15:35:13 <kmc> I mean to contrast "just increment a pointer" with "walk one or more free lists until you find a suitable block"
15:35:13 <hpaste> “Josh Chia” pasted “find-key error message from ghci” at http://hpaste.org/52717
15:35:22 <ddarius> kmc: Agreed.
15:35:39 <jchia> code in the first link, ghci error message in the second link
15:36:22 <ion> That should be “then Just v else acc” i think.
15:36:52 <jchia> of course! thanks
15:37:01 <jchia> typo
15:37:46 <jchia> what is haskell saying by "Could not deduce (k ~v)"?
15:37:55 <jchia> can't make k and v the same type?
15:38:02 <kmc> yeah
15:38:34 <jchia> thanks for your help, ion & kmc
15:40:21 <hpaste> vic annotated “not in scope” with “not in scope (annotation) (annotation)” at http://hpaste.org/52714#a52718
15:40:28 <cvic_> hmm
15:41:25 <monochrom> because current directory is not /home/user/text
15:41:50 <cvic_> Ah
15:41:51 <monochrom> inside files all you get is ["01.txt", "hello"] etc. not absolute paths
15:41:58 <cvic_> I see
15:42:33 <cvic_> Works now
15:42:41 <cvic_> I ran it in the txt folder
15:42:44 <monochrom> \∩/
15:42:48 <cvic_> Hehe
15:43:20 <cvic_> All I have to do now is to put all that output in a file.
15:43:22 <cvic_> Should be easy
15:43:35 <monochrom> probably BS.writeFile
15:43:43 <cvic_> Yep
15:44:13 <navaati> hum, i thought implicit parameters were *really* cool, but you need to provide a type-signature, so… not so usefull
15:44:25 <kmc> you do?
15:44:34 <kmc> :t let x = ?f ?g in x
15:44:34 <lambdabot> forall t t1. (?f::t -> t1, ?g::t) => t1
15:45:22 <navaati> yeah, i'm testing them, and… shit, doesn't work like this for me oO
15:47:44 <shachaf> navaati: You can't say f :: Int -> Int; f x = x + ?y
15:47:57 <shachaf> The implicit parameter is part of the type of the function.
15:48:28 <navaati> shachaf: i don't think i'm in such a case, my parameter is a Float…
15:48:38 <cvic_> writeFile "/tmp/foo.txt" aaa
15:48:40 <cvic_> Hm, not it
15:48:43 <cvic_> I need the reverse
15:49:12 <shachaf> navaati: I don't think whether it's a Float or an Int makes any difference...
15:49:29 <shachaf> But I don't know what your case actually is. You haven't said.
15:49:50 <cvic_> Ah, wait.... I'm tired
15:49:55 <cvic_> Should work now
15:50:54 <navaati> it's in the complex of shaders nesting in GPipe, actually i want to use implicits like a more convenient form of reader monad
15:51:15 <navaati> s/complex/context
15:52:10 <cvic_> And... of course it doesn't work
15:52:13 * cvic_ facepalm 
15:54:11 <hpaste> vic annotated “not in scope” with “not in scope (annotation) (annotation) (annotation)” at http://hpaste.org/52714#a52719
15:56:50 <cvic_> Maybe BS.appendFile
15:57:29 <cvic_> *Write
16:00:33 <astory> ghci
16:00:40 <astory> eek, wrong window >.<
16:05:15 <DukeDave> astory: Not exactly the worst thing you could have accidentally sent to #haskell ;)
16:06:46 <ddarius> php
16:07:07 <astory> DukeDave: yeah, it could have been "ledit ocaml"
16:07:26 <hpc> matlab
16:09:21 <cvic_> Ruby.
16:09:50 * DukeDave would like to see a directed, weighted graph of "respect" and "loathe" between users of different languages.. 
16:09:58 <astory> heh.
16:10:10 <astory> Is there a standard maxarg function lying around or should I roll my own?
16:10:51 <navaati> maxarg ? you mean
16:10:54 <navaati> :t maximum
16:10:54 <navaati> ?
16:10:54 <lambdabot> forall a. (Ord a) => [a] -> a
16:10:59 <cvic_> Nah
16:11:03 <astory> no, so here's what I've got:
16:11:34 <astory> I have [a], [BigDataStructure_t], and f :: BigDataStructure_t -> a -> Int
16:11:51 <companion_cube> DukeDave: you mean http://axgle.github.com/images/haskell.jpg ?
16:11:52 <cvic_> astory: use hpaste.org
16:11:53 <astory> For each a, I want to find the best of the BigDataStructure_t's
16:12:07 <byorgey> cvic_: for just a few type signatures it's OK
16:12:13 <astory> based on that function f
16:12:23 <byorgey> astory: use maximumBy
16:12:33 <DukeDave> companion_cube: Haha, wonderful!
16:12:46 <byorgey> maximumBy (comparing (f a)) or something like that
16:12:46 <astory> that's perfect, thanks byorgey
16:13:05 <byorgey> astory: maximumBy is from Data.List, comparing is from Data.Ord
16:13:08 <ddarius> Depending on how complicated f is, there is also another approach.
16:13:51 <astory> oh?  f is potentially expensive
16:14:46 <byorgey> ah, right, then you may want to first do  map (\dataStructure -> (f a dataStructure, dataStructure))
16:15:00 <byorgey> then do maximumBy (comparing fst)
16:15:10 <byorgey> then project out the winning data structure with snd
16:15:19 <byorgey> I assume that's what ddarius was referring to
16:15:34 <astory> how is that different from the previous approach
16:15:35 <astory> ?
16:15:49 <navaati> when i want to use implicit parameters withoud type signature, i got "Unbound implicit parameters (?size::Vec2 Int, ?angle::Float) arising from a use of `vertexShader'" and similar errors… are you sure lambdabot doesn't cheat ?
16:15:55 <byorgey> astory: with maximumBy (comparing (f a)), f may be run multiple times on a given data structure, since it will be computed every time two structures are compared
16:16:11 <byorgey> astory: with the second approach, you precompute f for each data structure, then find the maximum store
16:16:14 <byorgey> *score
16:16:22 <astory> logical.  Thanks!
16:16:34 <hjulle> kmc: Why is your analogy for monads not on the wiki?
16:16:37 <hjulle> kmc says: a monad is like an invisible train filled with jello  traveling backwards in time
16:17:28 <byorgey> that is the monad anology that finally made monads "click" for me
16:17:52 <astory> since I don't quite get monads yet... can't tell if trolling or serious /squintyfry
16:18:04 <Philippa> very long-running joke
16:18:23 <Philippa> everyone knows they're really like burritos. After they've been through someone's digestive tract.
16:18:26 <cvic_> Monads Inside
16:18:27 <byorgey> astory: not serious =)
16:19:31 <Philippa> cvic_: Monads In Middle. Except IO, which is on the outside
16:19:38 <cvic_> Haha
16:19:51 <hpaste> vic annotated “not in scope” with “not in scope (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/52714#a52721
16:19:53 <hjulle> Philippa: [burritos] Yeah, I've seen a blog post which explains that. It really makes sense.
16:19:58 <Philippa> actually, more like monads in ever-repeating pure/monad layer, if that's what you want
16:20:16 <jeffcutsinger> astory, the joke is poking fun at the hundreds of monad tutorials out there, each with its own analogy which often only makes sense to them.
16:20:37 <jeffcutsinger> s/them/the author/
16:20:54 <astory> jeffcutsinger: yes, I've encountered those...
16:21:16 <Philippa> the first few weren't too bad, because they were reasonably sensible. Containers, for example. Computations is, give or take some slightly bad phrasing, a direct take on one thing they /are/ in Haskell...
16:21:27 <Philippa> (that is: it's more projection than analogy)
16:28:56 <Philippa> hmm. Is that silence everyone agreeing with me, or me just having said something so controversial everyone's left dumbstruck?
16:29:08 <blackdog>   makes sense to me.
16:29:42 <monochrom> just afk in my case
16:29:42 <navaati> there is also the notion of "context"…
16:29:52 <blackdog> i wonder if people have the same trouble coming to terms with the Strategy pattern etc
16:30:34 <mike-burns> What finally made it click for me was the realization that there are a whole bunch of typeclasses and that I couldn't get anything done if I spent all my time obsessing over only one.
16:30:36 <Philippa> navaati: yup. Mine was back when the first couple of big tutorials existed but none tried to tell you what monads were about in and of themselves, they just showed you what was in mtl
16:30:36 <hpc> the parallel strategies?
16:30:50 <hpc> the type bamboozles me, even though it's basically a type alias
16:31:02 <Philippa> blackdog: some people do, yeah
16:31:07 * cvic_ is dumb 
16:31:27 <mike-burns> I'm going to write a tutorial on the Eq typeclass, with analogies.
16:32:13 <mike-burns> You know, Read is a lot like a bookshelf.
16:32:15 <mike-burns> Etc.
16:33:02 <ddarius> Strategy pattern = higher order functios
16:33:08 <ddarius> Factory pattern = higher order function
16:33:22 <mike-burns> Hah. I'm sure there's subtly to it.
16:33:32 <slack1256> mike-burns: after had explained using analogies a lot of concept of haskell i recommend you to not do that
16:33:35 <ion> Object pattern = higher order functions
16:33:38 <blackdog> ddarius: and we don't seem to have to come up with tortuous justifications and analogies for HOFs
16:33:47 <slack1256> analogies tend to fit the mind of the teller not of the listener
16:33:49 <cvic_> Who needs OOP when you have higher order functions
16:33:53 <cvic_> Heh
16:34:12 <mike-burns> slack1256: Indeed!
16:34:20 <ddarius> ion: If you include types, objects are not trivially higher order functions.
16:34:25 <slack1256> mike-burns: although i would like to be proved wrong :)
16:34:55 <mike-burns> slack1256: I was mostly poking fun at all the monad tutorials that make monads in Haskell out to be some exciting thing that is hard to learn.
16:35:15 <mike-burns> Which in turn causes people to hunker down and get confused.
16:35:37 <slack1256> oh. sorry i didn't get that!, xD
16:35:45 <Philippa> cvic_: open recursion is pretty damn useful too
16:35:59 <hpc> mike-burns: it is admittedly not as natural an abstraction as functor and applicative, when you look at it from the bind perspective
16:36:30 <ddarius> Open recursion = higher order function
16:36:35 <Philippa> mike-burns: I just put up a tutorial (not on monads, though it builds some - not Monads though) and /at the end/ mentions casually that it just used haskell as a metametametalanguage
16:36:40 <ddarius> Open recursion /= recursion
16:36:55 <Philippa> ddarius: it's encodable with some HOFs, yes
16:37:07 <mike-burns> hpc: Few of the tutorials I've seen help the reader understand what awesome abstractions he can build with a monad. Most of them talk about laws and that they can potentially be combined.
16:37:21 <mike-burns> I'd read a book titled The Monad Cookbook.
16:37:29 <slack1256> metametameatlangage, Douglas Hofstadter would be proud.
16:37:49 <Philippa> in practice most FPLs don't have type systems that play well with more creative uses of it though :-(
16:38:04 <cvic_> SAMS How to Write A Monad Tutorial in 24 Hours
16:38:17 <ion> Monad tutorials are like burrito restaurants.
16:38:31 <Philippa> slack1256: if it's any help, the object language at the bottom of the stack is just data
16:39:00 <slack1256> mmm
16:39:30 <hjulle> slack1256: metametameat instead of metametaburritos?
16:40:04 <slack1256> i prefer metametameat instead of metametaburritos. with burritos you aren't sure of what they have!
16:40:25 <Philippa> but unnamed meat is fine?...
16:40:32 <hpc> ddarius: why is it called open recursion? wikipedia just gave a very basic "this is what 'this' is" redirect
16:40:48 <slack1256> xD
16:41:15 <monochrom> open recursion example: fibmaker f = \n -> if n==0 || n==1 then 1 else f (n-1) + f (n-2). so you can obtain fib = fibmaker fib, but you can also obtain something more. consider: fibIO = fibmaker (\x -> print x >> fibIO x)
16:41:21 <cvic_> Everytime someone writes a monad tutorial a functor [insert action here]
16:42:15 <monochrom> err, that has a problem. nevermind.
16:42:55 <slack1256> yeah monochrom.
16:42:55 <Philippa> the normal example is that when you replace one of the values (be it a method or otherwise) in an object, you expect all the references the object had to itself to refer to the new value
16:42:56 <monochrom> ah, but you can sneak in memoization
16:43:08 <cvic_> monochrom: any hints on this http://hpaste.org/52714
16:43:21 <Philippa> (where the object is being treated as a record defined recursively in terms of itself)
16:44:00 <MatrixFrog> cvic_ which version should we be looking at?
16:44:04 <monochrom> BS.appendFile "/tmp/foo.txt" fileContents
16:44:05 <cvic_> Last one
16:44:09 <cvic_> Yeah, that's wrong.
16:44:15 <monochrom> @type appendFile
16:44:16 <lambdabot> FilePath -> String -> IO ()
16:44:31 <monochrom> BS's appenFile is analogous
16:44:46 <monochrom> oh, forgot BS.concat
16:44:53 <monochrom> BS.appendFile "/tmp/foo.txt" (BS.concat fileContents)
16:45:07 <cvic_> Oh
16:45:13 <cvic_> That would be it
16:46:33 <cvic_> Excellent
16:46:39 <cvic_> monochrom: thank you again
16:48:07 <cvic_> Hmm, it plays nice with UTF8 too
16:48:09 <cvic_> Cool
16:50:06 <monochrom> yeah, ByteString functions preserve the bits, if you give it GB18030 it gives you back the same GB18030, no error no change
16:50:39 <cvic_> Good, good
16:50:45 <navaati> :t mconcat
16:50:47 <lambdabot> forall a. (Monoid a) => [a] -> a
16:50:48 <cvic_> I am working with some German texts, so I need that
16:50:58 <navaati> :t mconcatMap
16:50:58 <lambdabot> Not in scope: `mconcatMap'
16:51:02 <cvic_> Now, I need to fix this working directory issue
16:51:28 <slack1256> everything that is ASCII or UTF-8 should be done with bytestring.
16:51:45 <slack1256> UTF-16 & UTF-32 with Data.Text right?
16:51:45 <ddarius> ByteString doesn't know anything about encodings.  It operates in terms of bytes.
16:52:07 * slack1256 realize about BYTEstrings
16:52:11 <ddarius> slack1256: No.  If you are working with text, you should use Data.Text.  If you are working with bytes, you should use ByteStrings.
16:52:36 * cvic_ is working with bytes, right 
16:52:53 <monochrom> SD.setCurrentDirectory "/home/user/text" or something
16:52:55 <slack1256> ddarius: you're right.
16:53:19 <navaati> haskell's Char are full unicode, i can put venusian characters of 32 bits in them ?
16:53:40 <monochrom> yes
16:54:44 <cvic_> monochrom: my Haskell program takes one argument, a pdf file
16:54:53 <cvic_> and it needs to get the directory where the pdf is
16:55:03 <cvic_> program file.pdf
16:55:07 <cvic_> and it outputs a text file
16:55:24 <cvic_> in the same place
16:56:14 <cvic_> Hm, I'll use pwd
16:56:24 <monochrom> module System.FilePath has various utilities for that, if you have it installed
16:57:08 <cvic_> Yeah, it's perfect
16:57:47 <cvic_> takeDirectory might be what I need
16:58:17 <monochrom> yeah
16:58:37 <cvic_> setCurrentDirectory (takeDirectory file.pdf )
16:58:40 <cvic_> something like that
16:59:28 <cvic_> Any way I can drop the rest of the args
16:59:36 <cvic_> I need just the first one
17:01:57 <cvic_> head getArgs hmm
17:02:44 <monochrom> args <- getArgs; case args of {[] -> ... ; x:_ -> ... }
17:03:17 <monochrom> or x:_ <- getArgs if you feel adventurous
17:03:31 <astory> you could also do take 1 args
17:03:37 <astory> and match on that
17:04:41 <tswett> @type forever
17:04:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:04:46 <tswett> > forever [1,2]
17:04:47 <lambdabot>   *Exception: stack overflow
17:05:08 <ddarius> astory: What would be the benefit of that?
17:05:49 <monochrom> to fill up a text file and reduce internal fragmentation of hard disk sectors
17:07:15 <MatrixFrog> what's wrong with just:
17:07:15 <MatrixFrog> (x:_) <- getArgs
17:07:25 <keep_learning> how can i print the bytestring in hex format ?
17:07:26 <MatrixFrog> you'll get an error if there are zero args, but that's probably more or less what you want anyway
17:08:18 <MatrixFrog> oh i see, monochrom said that and i missed it, sorry
17:08:19 <slack1256> keep_learning are you using byteString.Char8?
17:08:31 <ddarius> keep_learning: There's a concatMap.
17:08:38 <keep_learning> Data.ByteString.Lazy
17:08:41 <cvic_> MatrixFrog: yep, and that case is nice
17:09:38 <slack1256> use Data.ByteString.Lazy.Char8
17:10:34 <keep_learning> ddarius, i did not get you .
17:10:55 <keep_learning> ddarius, how does concatMap help
17:11:44 * hackagebot campfire 0.1.1 - Haskell implementation of the Campfire API  http://hackage.haskell.org/package/campfire-0.1.1 (MichaelXavier)
17:13:22 <slack1256> "B.map (intToDigit . read)" should do
17:13:26 <slack1256> no nevermind
17:14:16 <ddarius> :t BS.pack
17:14:17 <lambdabot> [Word8] -> BSC.ByteString
17:16:47 <keep_learning> ddarius, slack1256 thank you , pack and unpack helped
17:18:09 <slack1256> but. i didn't do anything. my solution was wrong xD
17:21:44 * hackagebot googleplus 0.3.1.1 - Haskell implementation of the Google+ API v1  http://hackage.haskell.org/package/googleplus-0.3.1.1 (MichaelXavier)
17:22:36 <joe9> is the author/maintainer of HUnit in here?
17:22:41 <ddarius> > let hexTable = listArray (0 :: Word8, 255) $ map (BSC.pack . flip showHex " ") [0..255] in BS.concatMap (hexTable!) (BSC.pack "fragglerock")
17:22:42 <lambdabot>   "66 72 61 67 67 6c 65 72 6f 63 6b "
17:22:45 <joe9> the Test::HUnit
17:25:25 <hpaste> vic pasted “Parse error ” at http://hpaste.org/52725
17:25:52 <cvic_> seems that args has a wrong type or something
17:26:14 <ion> x doesn’t have the same type as putStr "…"
17:26:49 <cvic_> x is IO...?
17:27:07 <cvic_> IO String
17:27:22 <ion> @type getArgs
17:27:23 <lambdabot> Not in scope: `getArgs'
17:27:26 <ion> @hoogle getArgs
17:27:27 <lambdabot> System.Environment getArgs :: IO [String]
17:27:32 <cvic_> Yeah
17:27:40 <ion> In args <- getArgs, what is the type of args?
17:27:56 <slack1256> string
17:28:07 <slack1256> [strings]
17:28:08 <slack1256> sorry
17:28:17 <ion> Let’s let cvic answer. :-)
17:28:26 <slack1256> derp sorry
17:28:42 <cvic_> getArgs returns IO [String]
17:28:44 <cvic_> Right
17:28:53 <cvic_> :t putStr
17:28:54 <lambdabot> String -> IO ()
17:29:07 <cvic_> So that's my first problem
17:29:18 <cvic_> :t print
17:29:19 <lambdabot> forall a. (Show a) => a -> IO ()
17:29:33 <ion> cvic: Again, what is the type of args?
17:30:42 <cvic_> args is IO [String]
17:31:54 <ion> @undo do args <- getArgs; something
17:31:54 <lambdabot> getArgs >>= \ args -> something
17:32:01 <ion> @type (>>=)
17:32:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:32:12 <cvic_> Ok.
17:32:53 <ion> The do notation is syntactic sugar for that. ‘m a’ stands for the type of getArgs (IO [String]) and ‘a’ stands for the type of args. What is it?
17:33:20 <cvic_> [String]
17:33:28 <ion> Indeed. You can think of <- “drawing” the result value from an IO action upon execution.
17:34:13 <ion> Now, to the next line. All the top-level expressions in the do block should be IO actions.
17:34:39 <ion> The case expression can return ‘putStr "…"’ which is an IO action. Everything’s fine so far.
17:34:50 <ion> But it can also return ‘x’ which is not an IO action, is it?
17:35:28 <ion> In fact, it can’t return either because the expression cannot be compiled.
17:35:46 <cvic_> Yeah, that case is wrong
17:35:46 <ion> due to the type mismatch
17:37:35 <cvic_> Could not match IO () ageinst String.
17:37:37 <cvic_> Indeed
17:37:41 <cvic_> *against
17:38:45 <DukeDave> Erm, I am allowed something like "instance (MyTypeClass a) (MyDataType a) where", right?
17:39:54 <DukeDave> No, that doesn't make sense..
17:39:59 <DukeDave> Why am I confused :|
17:40:17 <cvic_> Show us some code
17:41:48 <DukeDave> "class DPGraph i v where {..}" and then "instance (DPGraph i v) (Graph i v) where..."
17:41:59 <DukeDave> I've gotten myself muddled, that makes no sense :)
17:42:05 <ddarius> DukeDave: I agree.
17:42:11 <cvic_> Well..
17:42:17 <cvic_> Simplify it
17:42:46 <DukeDave> The type class only needs "DPGraph g" doesn't it..
17:43:20 <Stribor> funtion:a->b->c........if you give only 2 paramethars it will return c.........if you give one paramethar is will return b->c.........but where or what will b->c be applied to
17:43:39 <DukeDave> And then if the type which is an instance of the class happens to be higher order, then so be it..
17:44:43 <ddarius> DukeDave: In Haskell 2010, type classes can only be of the form class C a where {...}
17:45:03 <DukeDave> ddarius: Good
17:46:07 <ddarius> DukeDave: The kinds that the type class classifies can be anything, but must be consistent.  If Graph :: * -> * -> *, though, Graph i v :: *.
17:47:15 <ddarius> DukeDave: All this said, I recommend (re)reading a book section or tutorial on type classes.
17:48:12 <DukeDave> ddarius: Yeah, I was just being silly for a moment
17:49:08 <DukeDave> I was misled because some of the function type signatures which comprise my class have key and value types
17:49:28 <DukeDave> .. And I'm using type variables in those signatures
17:50:23 <ddarius> DukeDave: It's quite possible that you do want a multiparameter type class or an associated type.
17:50:47 <DukeDave> ddarius: Ah, so these things do exist?
17:50:52 <DukeDave> Just not in Haskell 2010?
17:51:34 <ddarius> DukeDave: What I just referred to are extensions, the former of which is widely supported.  They still don't look like what you originally tried to write though.
17:52:23 <DukeDave> ddarius: Yeah, I'm reading up on it now, and things make more sense, thanks for the help (http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes#Multi-parameter_type_classes)
17:56:53 <keep_learning> how can i change [0x00 , 0x00 , 0x01 , 0x01 ] to "00000101" . map show [0x00 , 0x00 , 0x01 , 0x01 ]  is just returning "0011"
17:58:04 <Stribor> can someone please help me with this example here ....http://learnyouahaskell.com/higher-order-functions#curried-functions
17:58:26 <Stribor> it starts here -> What really happens when we do multThree 3 5 9
17:58:33 <Cale> keep_learning: well, you'll want to use showHex probably, as well as do something to pad with 0's.
17:58:40 <shachaf> > foldr (printf "%02d%s") "" [0x00,0x00,0x01,0x01] :: String
17:58:40 <lambdabot>   "00000101"
17:58:47 <ezyang> Hey #haskell, I need some function types which Djinn can derive, which are harder than things like a -> a but easier than callCC
17:58:48 <MatrixFrog> Stribor i think i could possibly be of some help...
17:58:52 <Cale> keep_learning: because there's no way for show to know that you want 2 digits.
17:59:14 <Stribor> MatrixFrog: ok cool...first it starts here   First, 3 is applied to multThree, because they're separated by a space.
17:59:16 <ddarius> ezyang: Church encoded types.
17:59:19 <slack1256> keep_learning: are your sure you don't want the first form?. is more correct than the second.
17:59:31 <Stribor> MatrixFrog: That creates a function that takes one parameter and returns a function
17:59:49 <Stribor> MatrixFrog: so 3 is applied to multThree
17:59:50 <shachaf> slack1256: How can you say what's more correct?
18:00:00 <ezyang> Hmmkay.
18:00:11 <Stribor> MatrixFrog:  and when 3 is applied to multiThree what is actually returned?
18:00:17 <Cale> @djinn (e -> a) -> (a -> e -> b) -> (e -> b)
18:00:17 <lambdabot> f a b c = b (a c) c
18:00:41 <copumpkin> ezyang: why not take the three de morgan laws that work?
18:00:46 <MatrixFrog> multThree is of type Int -> Int -> Int -> Int (simplifying slightly)
18:00:55 <ezyang> OK, let's make this a little harder: no use of sum or product types.
18:00:59 <MatrixFrog> so when you apply it to an Int, you get back an (Int -> Int -> Int)
18:01:27 <Cale> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
18:01:27 <lambdabot> f a b c = a (\ d -> b d c)
18:01:27 <shachaf> ezyang: Church-encoded sum and product types. :-)
18:01:27 <slack1256> shachaf: the first one show the decimal value, the second one showed each one independtly.
18:01:27 <copumpkin> ezyang: the S combinator, or doing things behind double negation
18:01:29 <Cale> @djinn a -> ((a -> r) -> r)
18:01:29 <lambdabot> f a b = b a
18:01:34 <td123> > [3,2,1] > [2,10,100]
18:01:35 <MatrixFrog> Stribor: so (multThree 3) is a function that takes 2 Ints and returns an Int
18:01:35 <lambdabot>   True
18:01:35 <slack1256> shachaf: but you are right, I am noone to say what is correct :)
18:01:44 * ezyang gets copying down the suggestions. 
18:01:45 <td123> why does that expression return true
18:01:45 <djahandarie> mauke, is your website down? (mauke.ath.cx)
18:01:57 <td123> 3>2 True, but 2 is not > 10
18:02:09 <td123> but it still returns true
18:02:14 <mauke> djahandarie: http://mauke.dyndns.org/stuff/
18:02:15 <Cale> td123: The ordering on lists is lexicographic
18:02:20 <copumpkin> @djinn Not (Not (Not (Not a) -> a))
18:02:24 <lambdabot> f a = void (a (\ b -> void (b (\ c -> a (\ _ -> c)))))
18:02:24 <djahandarie> mauke, ah, nice, thanks.
18:02:34 <Cale> td123: It compares the first elements, and only if they match does it compare the tails.
18:02:36 <copumpkin> not that that's exactly double negation elimination, but it's close enough
18:02:48 <Cale> td123: Like how you'd compare words in a dictionary
18:02:50 <copumpkin> or just @djinn Not (Not (Not a)) -> Not a
18:02:55 <td123> wow
18:02:56 <copumpkin> @djinn Not (Not (Not a)) -> Not a
18:02:56 <lambdabot> f a b = void (a (\ c -> c b))
18:02:57 * ddarius was about to say.
18:03:01 <MatrixFrog> Stribor: these examples are all a little contrived to be honest. it might be easier to understand with some 'map' examples or something
18:03:07 <slack1256> mauke: http://mauke.dyndns.org/stuff/santorum.html WTF man
18:03:14 <td123> > [2] > [10]
18:03:14 <lambdabot>   False
18:03:19 <td123> wait what?
18:03:26 <shachaf> @djinn (Cont r (Cont r (Cont r (Cont r a)))) -> Cont r a
18:03:26 <keep_learning> slack1256, actually [0x00,0x00,0x01,0x01] is hex  4 byte hex value whose decimal value is 257  but when i am doing some thing like  concatMap show [0x00,0x00,0x01,0x01]
18:03:26 <lambdabot> f a b = a (\ c -> c (\ d -> d (\ e -> e b)))
18:03:26 <Stribor> MatrixFrog: i tried with others just have hard time understanding this
18:03:37 <Cale> td123: 2 > 10 is False
18:03:39 <mauke> slack1256: hmm?
18:03:41 <keep_learning> slack1256, i am getting 0011
18:03:42 <Stribor> MatrixFrog: lets try simple map example
18:03:54 <keep_learning> slack1256, whose hex value is 17
18:03:56 <MatrixFrog> so if you import Data.Char, you have a function "toUpper"
18:03:58 <copumpkin> rimmjob, eh
18:04:02 <MatrixFrog> > toUpper 'h'
18:04:03 <lambdabot>   'H'
18:04:11 <copumpkin> talk about the santorum and in comes rimmjob
18:04:15 <slack1256> keep_learning: you're right. forget what i said
18:04:17 <keep_learning> slack1256, so i need to convert [0x00,0x00,0x01,0x01] to 00000101
18:04:24 <Cale> > [1,2,3] < [1,2,3,4]
18:04:24 <MatrixFrog> Stribor: now a string like "haskell" is actually a list of chars
18:04:25 <lambdabot>   True
18:04:29 <Cale> > [1,2,3,5] < [1,2,3,4]
18:04:29 <lambdabot>   False
18:04:34 <keep_learning> slack1256, :)
18:04:34 <shachaf> keep_learning: You didn't like the printf solution? :-(
18:04:41 <Cale> > [1,2,2,5] < [1,2,3,4]
18:04:42 <lambdabot>   True
18:04:43 <MatrixFrog> Stribor: so if i want to apply the 'toUpper' function to all the chars in that string, i can use map
18:04:49 * shachaf suspects it's evil.
18:04:50 <MatrixFrog> > map toUpper "haskell"
18:04:50 <lambdabot>   "HASKELL"
18:04:54 <keep_learning> shachaf,  i like that
18:05:05 <Stribor> MatrixFrog: ok i undeerstand that perfectly.....
18:05:08 <rimmjob> copumpkin:  hi
18:05:10 <MatrixFrog> Stribor: of course, you can do that to *any* string
18:05:15 <MatrixFrog> > map toUpper "stribor"
18:05:16 <lambdabot>   "STRIBOR"
18:05:17 <keep_learning> shachaf, but i am looking with monads
18:05:23 <MatrixFrog> >map toUpper "wheee"
18:05:27 <shachaf> Now you're thinking with monads!
18:05:29 <td123> Cale: ohh
18:05:29 <MatrixFrog> > map toUpper "wheee"
18:05:29 <lambdabot>   "WHEEE"
18:05:30 <Stribor> you take each leter on "haskell" and apply function "toUpper"
18:05:30 <MatrixFrog> you get the idea
18:05:34 <slack1256> keep_learning: use the printf one. seems to fit perfect to the situation
18:05:35 <MatrixFrog> right
18:05:39 <td123> Cale: so the whole list is treated as a number
18:05:42 <Cale> td123: no
18:05:42 <shachaf> keep_learning: ...*Why* are you looking with monads?
18:05:44 <MatrixFrog> so the part that's the same each time is "map toUpper"
18:06:01 <MatrixFrog> so then you ask yourself "what is this 'map toUpper' thing?"
18:06:02 <td123> Cale: sorry, this is really new to me :(
18:06:07 <keep_learning> shachaf, oh sorry without moands
18:06:08 <Stribor> hang on
18:06:18 <ezyang> Oh, the reader monad suggestion was a good one.
18:06:20 <Stribor> lets get back to "map toUpper:"   why it is same each time
18:06:20 <shachaf> keep_learning: Why are you looking without monads?
18:06:31 <shachaf> ezyang: Reader monad suggestion?
18:06:32 <MatrixFrog> i'm just saying, you keep repeating "map toUpper" over and over again
18:06:39 <Stribor> you mean because map toUpper is applied to each char in the string
18:06:39 <MatrixFrog> so you might give it a name:
18:06:44 * hackagebot haskeline 0.6.4.4 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.4.4 (JudahJacobson)
18:06:46 <MatrixFrog> let capitalize = map toUpper
18:06:47 <shachaf> How is that different from functions?
18:06:48 <keep_learning> shachaf, if i am going to use monad solution then i have to change lot of code
18:06:50 <ezyang> @djinn (r -> a) -> (a -> r -> b) -> (r -> b)
18:06:50 <lambdabot> f a b c = b (a c) c
18:06:54 <MatrixFrog> > let capitalize = map toUpper
18:06:55 <lambdabot>   not an expression: `let capitalize = map toUpper'
18:07:03 <keep_learning> shachaf, so i am looking for pure function .
18:07:05 <shachaf> keep_learning: Where did the monads come in? What monads are you talking about?
18:07:06 <MatrixFrog> @let capitalize = map toUpper
18:07:09 <lambdabot>  Defined.
18:07:13 <ezyang> But... I've forgotten how to Church encode sum types >_<
18:07:14 <shachaf> keep_learning: That's a tautology. All functions are pure.
18:07:15 * MatrixFrog always messes up lambdabot commands. anyway...
18:07:22 <keep_learning> :t printf
18:07:23 <lambdabot> forall r. (PrintfType r) => String -> r
18:07:27 <Cale> td123: Consider how you'd decide whether apple or ape comes first in a dictionary.
18:07:38 <Stribor> its so hard to follow convo in this room...lol
18:07:42 <keep_learning> shachaf, a great thanks
18:07:45 <td123> Cale: ah, I just got it
18:07:48 <MatrixFrog> Stribor: so now we can ask how the hell this "capitalize" thing works
18:07:51 <td123> Cale: http://stackoverflow.com/questions/3651144/comparing-lists-in-haskell-or-more-specifically-what-is-lexicographical-order
18:08:03 <mauke> looks like we're pretty active right now
18:08:07 <MatrixFrog> Stribor: 'map' is a function that takes two things: first a function, then a list
18:08:21 <td123> > [3, 1] > [2, 10]
18:08:22 <lambdabot>   True
18:08:23 <shachaf> ezyang: Just like disjunction elimination. :-)
18:08:27 <Stribor> MatrixFrog: yes
18:08:45 <td123> > [3, 1] > [3, 10]
18:08:46 <lambdabot>   False
18:08:46 <MatrixFrog> Stribor: so how is it that we're allowed to only apply it to ONE thing?
18:08:50 <td123> yay, I got it
18:08:57 <Stribor> MatrixFrog: what do you mean?
18:08:58 <td123> Cale: thx for your helP :P
18:09:00 <ezyang> @djinn (a -> r) -> (b -> r) -> r
18:09:01 <lambdabot> -- f cannot be realized.
18:09:08 <td123> Cale: haskell is the first language I know of that does this :P
18:09:09 <ezyang> So... what do I pass as the first argument ;-)
18:09:11 <Stribor> oh instead of 2
18:09:12 <Stribor> got it
18:09:13 <Cale> td123: Really?
18:09:15 <keep_learning> shachaf, why printf is not some thing like a -> IO ()
18:09:20 <td123> Cale: afaik
18:09:33 <keep_learning> shachaf, is it not doing some thing like print or putStrLn ?
18:09:35 <shachaf> keep_learning: Because. Or, alternately, it is.
18:09:40 <td123> Cale: what other languages have this?
18:09:46 <Cale> td123: python, for one
18:09:48 <ddarius> @djinn ((a -> b) -> c -> b) -> c -> a
18:09:48 <lambdabot> -- f cannot be realized.
18:09:49 <mauke> keep_learning: because then (printf "%d" 42) would be invalid
18:10:00 <MatrixFrog> Stribor: the answer is that it becomes "partially applied" -- it's ready to accept two args, we've given it the first one, and what we get back -- the capitalize function -- is ready to accept another argument
18:10:06 <djahandarie> mauke, hmm, your unicode thing seems to not let me search with different types of spaces. :(
18:10:08 <ddarius> @djinn ((a -> b) -> c -> b) -> c -> b
18:10:08 <lambdabot> -- f cannot be realized.
18:10:10 <shachaf> @ty (\(f::Int -> String) (g::Bool -> String) -> g True)
18:10:10 <lambdabot> (Int -> String) -> (Bool -> String) -> String
18:10:12 <td123> Cale: oh.. then I've never encountered that in python.. /me is going to try it
18:10:14 <Cale> Ruby apparently doesn't define a < method for its arrays...
18:10:16 <Stribor> MatrixFrog: ok hang on
18:10:24 <Cale> (but I don't really know)
18:10:26 <ddarius> @djinn ((a -> b) -> a -> c) -> b -> c
18:10:26 <lambdabot> -- f cannot be realized.
18:10:31 <Cale> Probably O'Caml does the same
18:10:31 <mauke> djahandarie: http://mauke.dyndns.org/stuff/javascript/unicode.html?q=space
18:10:36 <ddarius> ENOTENOUGHPOLYMORPHISM
18:10:44 <Cale> It's really the only sensible general ordering on lists.
18:10:48 <ezyang> oh, d'oh, I need two constructors, don't I.
18:10:56 <djahandarie> mauke, I mean to actually search one of the space characters.
18:10:56 <Cale> You can do other things, but they're weird :)
18:11:00 <ezyang> @djinn a -> (a -> r) -> (b -> r) -> r
18:11:00 <lambdabot> f a b _ = b a
18:11:06 <djahandarie> mauke, it ends up splitting on it instead of literally searching it.
18:11:08 <td123> Cale: thanks, I've never known this
18:11:12 <mauke> djahandarie: yes
18:11:22 <td123> Cale: just tried it in python and it works
18:11:22 <MatrixFrog> Stribor: maybe using map examples wasn't the best idea. *shrug* whatever works
18:11:23 <Stribor> MatrixFrog: can we do example using capitalize function
18:11:30 <djahandarie> mauke, is there a quick fix for this?
18:11:31 <MatrixFrog> > capitalize "stribor"
18:11:33 <lambdabot>   "STRIBOR"
18:11:35 <shachaf> ezyang: There you go.
18:11:48 <mauke> djahandarie: why is that a problem?
18:11:55 <shachaf> @ty either
18:11:55 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:11:55 <Stribor> > capitalize
18:11:56 <lambdabot>   Overlapping instances for GHC.Show.Show
18:11:56 <lambdabot>                              ([GHC....
18:11:57 <djahandarie> I have a specific space and I'm not sure which one it is.
18:12:15 <MatrixFrog> Stribor: you can't print out the "capitalize" function itself but you can look at its type:
18:12:19 <MatrixFrog> @type map
18:12:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:12:19 <MatrixFrog> @type capitalize
18:12:20 <lambdabot> [Char] -> [Char]
18:12:31 <dylukes> Silly question time, is it possible to suppress missing-type-signature warnings on a per file basis?
18:12:46 <shachaf> dylukes: Yes.
18:12:52 <shachaf> ASCII silly question, get a silly ANSI.
18:13:02 <MatrixFrog> Stribor, the way we're using it here, you can think of the type of map as: map :: (Char -> Char) -> [Char] -> [Char]
18:13:06 <dylukes> Is there an OPTINS_GHC pragma I can use?
18:13:08 <shachaf> dylukes: Yes.
18:13:11 <dylukes> OPTIONS*
18:13:12 <dylukes> What is it?
18:13:13 <shachaf> Well, no.
18:13:25 <MatrixFrog> Stribor: and then toUpper is of type Char -> Char
18:13:45 <shachaf> dylukes: According to `man ghc`, it's -fno-warn-missing-signatures
18:13:52 <MatrixFrog> so the type of (map toUpper) is [Char] -> [Char]
18:13:52 <dylukes> okay
18:13:56 <dylukes> I hope ghc-mod understands that XD
18:14:00 <shachaf> But I didn't know that until looking it up.
18:14:02 <Stribor> but when you apply capitalize with only one argument....what is actualy given back
18:14:04 <dylukes> hurray it works!
18:14:08 <Stribor> like what value is given back
18:14:12 <dylukes> My new emacs set up highlights warnings and errors
18:14:15 <dylukes> which I love,
18:14:19 <shachaf> ,
18:14:22 <dylukes> but not in my parser combinators TT-TT
18:14:22 <dylukes> ,
18:14:24 <dylukes> ,
18:14:24 <dylukes> ,
18:14:35 <shachaf> That's the spirit.
18:14:39 <ezyang> OK, next question: I need function types that require a lambda to derive, but do NOT involve continuations (that disqualifies negation too, since a continuation is just a generalized negation.)
18:14:52 <ghosting> :t (map toUpper)
18:14:53 <lambdabot> [Char] -> [Char]
18:15:04 <shachaf> ezyang: S?
18:15:12 <shachaf> Oh, never mind.
18:15:29 <shachaf> ezyang: Why do you need that?
18:15:31 <mauke> djahandarie: ok, the input is trimmed first, so step 1 is to put other characters around the space
18:16:01 <dylukes> I've added some new features I know I'm later never going to live without...
18:16:12 <dylukes> such as showing the type-signature of arbitrary expressions automatically
18:16:12 <mauke> djahandarie: the next heuristic is whether it contains a not-printable-ascii character, so add one of those if necessary
18:16:25 <Cale> ezyang: hmm, is that theoretically possible? :)
18:16:28 <ezyang> shachaf: I've started working on the 'better' version of my game semantics blog post, and I need a simple example to motivate what happens when you make a lambda.
18:16:34 <ezyang> Cale: Good question!
18:16:38 <Stribor> MatrixFrog: what you did is just changed capitalize === map toUpper
18:17:14 <Stribor> so capitalize "Stribor" is same as map toUpper "stribor"
18:17:17 <shachaf> ezyang: Also, what's wrong with continuations?
18:17:19 <Cale> ezyang: To require a lambda in the derived code, you'll need a function parameter which requires a function argument of a type which isn't directly supplied.
18:17:28 <MatrixFrog> Stribor: right, i was just giving it a name
18:17:38 <Cale> hmm
18:17:40 <ezyang> Cale: Yes. "Do these all degenerate into continuations? I don't think so."
18:17:44 <ezyang> shachaf: Too long.
18:17:57 <BMeph> djahandarie: There's nothing there; it's all space. ;)
18:17:57 <Stribor> MatrixFrog: so that is partical?
18:18:03 <ezyang> well, maybe fmap will be Ok...
18:18:04 <Cale> @djinn ((a -> b) -> c) -> (a -> d) -> (d -> c) -> c
18:18:04 <lambdabot> -- f cannot be realized.
18:18:12 <Cale> @djinn ((a -> b) -> c) -> (a -> d) -> (d -> b) -> c
18:18:12 <lambdabot> f a b c = a (\ d -> c (b d))
18:18:18 <Cale> there you go?
18:18:20 <ezyang> @djinn (a -> r) -> (a -> b) -> b -> r
18:18:20 <lambdabot> -- f cannot be realized.
18:18:21 <djahandarie> mauke, aha. So it turns out the Linux clipboard turns most spaces into just normal spaces.
18:18:35 <Cale> @. pl djinn ((a -> b) -> c) -> (a -> d) -> (d -> b) -> c
18:18:36 <lambdabot> f = (. flip (.)) . (.)
18:18:40 <mauke> djahandarie: or it's your browser :-)
18:18:46 <shachaf> ezyang: What about something that returns a Church-encoded product type?
18:18:54 <mauke> djahandarie: I would have tried gvim first, btw
18:19:05 <Stribor> so you said you only giving one paramethar which is "stribor" but thats just tricking because other paramthar is inside capitalize
18:19:11 <MatrixFrog> Stribor: so yeah, you've "partially applied the map function"
18:19:13 <ezyang> shachaf: If you saturate the function you don't need lambdas, I think.
18:19:54 * shachaf must have not understood the question.
18:19:55 <Cale> But it's arguable that this type I provided "doesn't involve continuations".
18:19:58 <ezyang> Cale: Yeah, that's what I meant...
18:20:36 <MatrixFrog> Stribor: i think you're starting to get it
18:20:37 <Cale> I guess it's not directly a double negation with respect to some result
18:20:43 <djahandarie> mauke, I'm not a vim buff :(
18:20:44 <ezyang> You wrote fmap, IUIC
18:20:51 <ezyang> shachaf: It's this one, right?
18:21:03 <ezyang> @djinn a -> b -> (a -> b -> r) -> r
18:21:03 <lambdabot> f a b c = c a b
18:21:29 <shachaf> Oh. Hm.
18:21:30 <mauke> djahandarie: gvim has a paste button; the only command you need to know for this is 'ga'
18:21:31 <Cale> @djinn (a -> b -> r) -> (a -> r) -> (b -> r) -> r
18:21:32 <lambdabot> -- f cannot be realized.
18:21:34 <Stribor> MatrixFrog: but partially applying or not result is same ....
18:21:40 <mauke> djahandarie: ga displays information about the character under the cursor
18:21:42 <ezyang> fmap is probably basically reasonable.
18:21:49 <djahandarie> Ah, thanks.
18:21:59 <ezyang> It's too bad J a = a -> r isn't a monad >:-)
18:22:02 <MatrixFrog> Stribor: no, if i say "map toUpper" then i get a function, which takes a string and returns a string
18:22:08 <Cale> @djinn (c -> d -> r) -> (a -> c) -> (b -> d) -> (a -> b -> r)
18:22:09 <lambdabot> f a b c d e = a (b d) (c e)
18:22:23 <MatrixFrog> Stribor: but if i say 'map toUpper "stribor"' then i just get a string
18:22:27 <MatrixFrog> :t map toUpper
18:22:28 <lambdabot> [Char] -> [Char]
18:22:35 <MatrixFrog> :t map toUpper "stribor"
18:22:35 <lambdabot> [Char]
18:22:54 <shachaf> ezyang: Is J a standard name for that?
18:23:09 <ezyang> shachaf: I saw it in the double-negation shift/Tychonoff paper.
18:23:40 <Stribor> MatrixFrog: i get that...but i dont get this.......when you say "map toUpper" you said return is a "function".......but my question is what "ffunction" actually do???
18:24:10 * ddarius wonders if sheaves would bring any value to graphics.
18:24:16 <MatrixFrog> "map toUpper" is a function that takes a string, and returns a capitalized version of that string
18:24:22 <MatrixFrog> which is why i gave it the name "capitalize"
18:24:50 <wavewave> sheaf cohomology?
18:25:26 <MatrixFrog> Stribor: i think one reason lyah puts so much emphasis on this, is that these concepts are never really used in most imperative languages
18:25:27 <ddarius> wavewave: Yes.
18:25:38 <ddarius> Though not necessarily cohomology.
18:25:40 <shachaf> MatrixFrog: Which concepts?
18:25:44 <ezyang> :t (\a b -> a (\x -> x b))
18:25:44 <lambdabot> forall t t1 t2. (((t -> t1) -> t1) -> t2) -> t -> t2
18:25:47 <Stribor> MatrixFrog: luah?
18:26:09 <ezyang> @djinn (((t -> t1) -> t1) -> t2) -> t -> t2
18:26:10 <lambdabot> f a b = a (\ c -> c b)
18:26:10 <MatrixFrog> if you have a method in Java that takes two numbers and multiplies them, you can't just apply it to ONE number, and then get back a "partially applied function"
18:26:16 <ezyang> I wonder what that's called...
18:26:16 <MatrixFrog> lyah = learn you a haskell
18:26:48 <shachaf> @@ @pl @djinn (((a -> b) -> b) -> c) -> a -> c
18:26:48 <lambdabot>  f = (. flip id)
18:26:49 <ddarius> ezyang: It's essentially another case of triple negation "elimination"
18:26:50 <Stribor> MatrixFrog: oh ok..yes in java it would be compile error.
18:27:00 <ezyang> oh ho, that's right!
18:27:44 <Stribor> MatrixFrog: ill play wiht this on ghci for bit see if i can clear it up more..it helped a lot your explananation
18:29:13 <ezyang> Oh, quadruple negation elimination is join for cont. Yum.
18:32:53 <ezyang> :t (\a b -> a (\x -> x b) (\x -> x b))
18:32:54 <lambdabot> forall t t1 t2 t3. (((t -> t1) -> t1) -> ((t -> t2) -> t2) -> t3) -> t -> t3
18:33:08 * wavewave does't understand how to interprete function type as negation.. 
18:33:22 <ezyang> wavewave: Not a = a -> False
18:33:39 <ezyang> It's the sort of function that 'blows up' if you apply it, in that it produces a contradiction.
18:33:47 <shachaf> ezyang: Why not a = a -> False? That's a great way to interpret it. :-)
18:34:06 <wavewave> so what is False here?
18:34:07 * ezyang kaboom 
18:34:16 <shachaf> wavewave: data False, i.e., a type with no constructors
18:34:19 <ezyang> It's the 'uninhabited type', in terms of programs.
18:35:17 <wavewave> hmm.. then how can use say something on negation with ((a->b) -> b)->c ...? you just replace one of type parameter with False and interprete it?
18:35:26 <ezyang> Right, so I set b = False and c = False
18:35:30 <shachaf> ezyang: That defines type J r x = (x -> r) -> x
18:35:48 <dylukes> ddarius: sheaves?
18:35:49 <ezyang> so I have ((a -> F) -> F) -> F -> a -> F
18:35:50 <wavewave> I see.. now I got the context of this conversation. ;-)
18:35:54 <ezyang> I.e. NOT NOT NOT a -> NOT a
18:36:07 <ezyang> shachaf: Heh, I suck at this ^.^
18:37:16 <shachaf> ezyang: Are you going to BostonHaskell next week?
18:37:33 <ezyang> Oh, is it next week? I hope so.
18:38:03 <shachaf> If your week starts on Sunday (as it should).
18:38:28 <ezyang> "oh I see" That makes more sense.
18:38:33 <wavewave> http://en.wikipedia.org/wiki/Sheaf_(mathematics)
18:38:53 <dmwit> ezyang: missing some parentheses on that second-to-last type?
18:39:06 <ezyang> yeah...
18:39:18 <ezyang> Though the second-to-last type is inhabited :-)
18:39:58 <shachaf> Intuitionism is silly.
18:42:37 <amtal> What fraction of people here use Haskell at work?
18:42:47 <wavewave> I use.
18:42:50 <djahandarie> About a half of each person.
18:43:06 * MatrixFrog reads a little about haskell at work sometimes, to take a break from working :-/
18:43:16 <shachaf> amtal: Why do you care about fractions of people here?
18:43:20 <amtal> Question came up in #erlang.. Curious what the Haskell distribution is.
18:43:24 <amtal> Heh.
18:43:41 <shachaf> This is a big channel; most people here probably don't talk.
18:43:48 <MatrixFrog> perhaps the people using it for work are too busy *working* to be on IRC
18:43:56 <MatrixFrog> so it's not a particularly scientific poll
18:44:20 * shachaf has used Haskell at work.
18:44:22 <wavewave> I use haskell almost in all my projects since nobody can touch my code at all. ;-P
18:44:39 <djahandarie> I thought when you use Haskell, you're so efficient that you essentially spend 0 time working anyways?
18:45:01 <MatrixFrog> i think it's more like, you spend a long time thinking about your code, and very little time writing it
18:45:11 <pikhq_> djahandarie: Yes. Therefore, most Haskellians are out of work.
18:45:17 <shachaf> MatrixFrog: I take that to the logical conclusion:
18:45:26 <shachaf> I spend *all* my time thinking about code and *none* of my time writing any.
18:45:37 <pikhq_> For employment, use C. Guaranteed job security.
18:45:47 <amtal> Or your problem is simple enough to not require thought, and end up writing it so quickly you forgot how much you really wrote.
18:46:01 <wavewave> true... after haskell, my way of programming is changed. pondering more...
18:46:20 <mgsloan> yeah, Haskell's ruined me for industry :/
18:46:28 <mgsloan> but that's OK
18:46:35 <shachaf> mgsloan: I thought you liked C++?
18:46:40 <MatrixFrog> my way of writing Java has changed: "okay, so i just want to do fmap... oh right. damn it"
18:46:44 <djahandarie> sup mgsloan
18:46:50 <MatrixFrog> not always, but sometimes i think things like that
18:47:52 <dylukes> Yeah...
18:47:53 <dylukes> :<
18:47:54 <mgsloan> Hey djahandarie! 'lo shachaf!  I do like C++, but my C++ style is heavily haskell affected / boost using.  In my experience, companies don't like that
18:47:59 <amtal> It briefly turned my Python into gigantic pointfree one-liners.
18:48:03 <dylukes> boost using is bad :P
18:48:07 <amtal> I forced myself out of it... Barely.
18:48:18 <solidsnack> I am having a hard time determining how `hWaitForInput' handles data on binary handles.
18:48:20 <shachaf> Boost is great if... Er.
18:48:20 <dylukes> amtal: I just gave up and started using haskell for my python-esque tasks >_>
18:48:22 * wavewave  thinks he should be grateful surrounded by people who just saw my code and could say nothing at work 
18:48:27 <dylukes> shachaf: nope.
18:48:32 <solidsnack> Does it wait for valid ASCII and fail on higher bytes?
18:48:46 <amtal> dylukes: that's how I grew out of it. I realized I was writing typespecs in the comments, facepalmed, and swithced :p
18:48:48 <mgsloan> schachaf - if the template errors weren't /insane/ ? concept checking helps a bit..
18:49:11 <dylukes> amtal: Types on the brain :).
18:49:11 <MatrixFrog> amtal: switched to more pythonic python? or just back to haskell?
18:49:18 <amtal> Back to haskell ;)
18:49:50 <dylukes> amtal: You could use Boa. Augussts just had a post on it
18:49:51 <dylukes> http://augustss.blogspot.com/
18:49:54 <dylukes> :P
18:50:26 <mgsloan> Google's style guide affected my Haskell a lot, I've taken up tibbe's style for the most part - https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
18:50:36 <amtal> dylukes: that's not the same thing and you damn well know it :p
18:50:41 <mgsloan> (Google's C++ style)
18:50:45 <dylukes> amtal: hm?
18:51:19 <shachaf> augustss is slightly evil
18:51:58 <copumpkin> only slightly?
18:52:08 <dylukes> How so?
18:52:17 <wavewave> by introducing assignment?
18:52:29 <dylukes> wait
18:52:30 <dylukes> how the hell
18:52:31 <dylukes> lst.head
18:52:38 <dylukes> did he override . ?
18:52:46 <dylukes> or is there some even worse evil going on here
18:53:04 <dylukes> I suppose it could be some sort of weird lens type thing.
18:53:09 <shachaf> It's just ., presumably.
18:53:28 <shachaf> Can you actually define methods that way, though?
18:53:39 <dylukes> Yeah, but then the results of var must have some evil magic going on
18:53:51 <dylukes> yep
18:54:12 <dylukes> () have no meaning beyond guiding parsing.
18:54:13 <JoeyA> What's a good video talk about STM?
18:54:38 <wavewave> by SPJ? I guess.
18:54:52 <wavewave> JoeyA: wait a minute.
18:54:54 <companion_cube> +1
18:54:59 <JoeyA> http://channel9.msdn.com/Shows/Going+Deep/Programming-in-the-Age-of-Concurrency-Software-Transactional-Memory
18:55:02 <JoeyA> There's one
18:55:23 <JoeyA> linked from http://www.haskell.org/haskellwiki/Software_transactional_memory
18:56:50 <wavewave> probably that's the one I am now thinking of. it needs me to install silverlight right now.
18:57:02 <JoeyA> (looks like I can just download a wmv)
18:57:31 <Cale> http://a11.video2.blip.tv/9580000183425/OSCON-OSCON2007SimonPeytonJones914.mov?brs=424&bri=6.6
18:57:35 <JoeyA> oh, it's an mms://
18:57:40 <wavewave> bad connection.. unfortunately..
18:58:15 <ghosting> I can't even begin to digest hssyn
19:00:37 <wavewave> article by SPJ in beautiful code was also very nice.
19:00:52 <wavewave> I mean in the book "beautiful code"
19:01:16 <wavewave> I remember there is free pdf file for that.
19:01:43 <wavewave> @google beautiful concurrency
19:01:44 <lambdabot> http://research.microsoft.com/pubs/74063/beautiful.pdf
19:01:45 <lambdabot> Title: Beautiful concurrency
19:01:52 <JoeyA> I'm finding it difficult to compartmentalize threaded code.  To give an example: I wanted to implement a module that downloads from a URL every N seconds.  On success, it passes the result to a callback, and on failure, it waits a separate interval of time before trying again.
19:02:26 <JoeyA> So I wrote a function that takes configuration input, and spawns a thread that does this forever.
19:03:09 <JoeyA> It can be stopped by throwing an exception to a ThreadId behind an MVar.
19:03:51 <JoeyA> The reason for the MVar is so the downloader loop can opt-in for termination, rather than allowing asynchronous exceptions to interrupt user callbacks.
19:04:08 <wavewave> yeah, you probably have benefit from TVar in that case.
19:04:09 <JoeyA> However, it's hairy when I want to actually use it.
19:04:39 <keep_learning> @google programming with arrow
19:04:42 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.96.9534&rep=rep1&type=pdf
19:04:42 <lambdabot> Title: Programming with Arrows
19:04:42 <dmwit> ?unpl \old -> union old >>= intersection
19:04:43 <lambdabot> \ old -> (union old) >>= intersection
19:04:45 <dmwit> err
19:04:55 <dmwit> ?src (->) (>>=)
19:04:55 <lambdabot> f >>= k = \ r -> k (f r) r
19:05:03 <JoeyA> I have to devote a great amount of thought to what race conditions could arise, etc.
19:05:17 <keep_learning> @google SPJ
19:05:19 <lambdabot> http://www.spj.org/
19:05:19 <lambdabot> Title: Society of Professional Journalists
19:05:27 <wavewave> great.
19:05:33 <keep_learning> @google beautiful codes
19:05:34 <lambdabot> http://www.amazon.com/Beautiful-Code-Leading-Programmers-Practice/dp/0596510047
19:05:40 <wavewave> SPJ = Simon Peyton Jones
19:05:42 <JoeyA> Simon Peyton Jones
19:05:42 <shachaf> @google spjaper
19:05:43 <lambdabot> http://www.twitpic.com/5r5bqr
19:05:44 <lambdabot> Title: This is how I make people place #LaSpadas orders at #spjpaper... on Twitpic
19:06:13 <JoeyA> I link to it here: file:///home/joey/.cabal/share/doc/acme-missiles-0.1.0.0/html/Acme-Missiles.html
19:06:14 <JoeyA> err
19:06:28 <JoeyA> http://hackage.haskell.org/packages/archive/acme-missiles/0.1.1/doc/html/Acme-Missiles.html
19:06:42 <wavewave> hmm. should we hack your computer to launch missile?
19:06:42 <JoeyA> I need to get around to actually reading it.
19:07:32 <JoeyA> putStrLn "No silos found.  Abort, Retry, Ignore?"
19:08:00 <shachaf> JoeyA: Nuclear launch detected?
19:08:10 <shachaf> Surely you mean "Nuclear missile -- launched"
19:08:14 <ddarius> @vera spj
19:08:16 <lambdabot> No match for "spj".
19:08:51 <JoeyA> I'm referencing a 1998 real-time strategy game that made a small comeback in 2010.
19:09:28 <JoeyA> I also encounter a dilemma concerning whether I should return an infinite loop, or return a thread that does the infinite loop.
19:10:17 <JoeyA> There's also the issue of exceptions.  Overall, I have a very vague idea of what a "worker thread" should be.
19:11:23 <JoeyA> It seems to me I should strive to write actions, plain and simple.
19:12:11 <JoeyA> An "action" is expected to run in a finite time, and it produces its result solely with a return value.
19:12:34 <JoeyA> As opposed to, say, supplying a callback which is expected to ship off the result on a Chan.
19:12:48 <Cale> JoeyA: Are you referring to Starcraft Brood War or StarCraft in general? SC2 is doing quite well :)
19:13:19 <shachaf> JoeyA: I'm referring to a 2000 real-time strategy game.
19:13:24 <shachaf> I guess you win.
19:13:44 <JoeyA> SC2 probably doesn't run well on my machine, and Blizzard doesn't want to support LAN.  I'm quasi-boycotting SC2.
19:14:14 <dylukes> Wait.
19:14:17 <Cale> It runs okay under Linux on my machine.
19:14:22 <Cale> (Wine)
19:14:22 <dylukes> SC2 has no LAN play :-0?
19:14:25 <Cale> dylukes: right
19:14:31 <dylukes> That's terrible.
19:14:42 <Cale> It's not like you don't have an always-on internet connection
19:14:42 <dylukes> :<
19:14:46 <dylukes> ...true.
19:14:48 <dylukes> but I mean
19:14:49 <shachaf> Cale: I don't!
19:14:49 <Cale> But yes, LAN would be nice
19:14:51 <dylukes> that makes it harder to pirate.
19:14:55 * shachaf quasi-considers boycotting Diablo 3.
19:14:56 <dylukes> ¬_¬ *sarcasm*
19:14:59 <shachaf> Probably a good idea anyway.
19:15:46 <MatrixFrog> how's it going Stribor? have you learned you a haskell yet?
19:15:47 <JoeyA> Going back to my downloader example, I ended up just writing an action that performs a download, throwing an exception on error.  It also supports timeout and guards against an oversized result.
19:16:16 <Cale> dylukes: Yeah, at least there's no monthly fee. That would be a dealbreaker for me.
19:16:36 <shachaf> Cale: Blizzard would love to do that.
19:16:46 <JoeyA> However, it omits the repeat/retry loop.  When I try to express that, I some up with all sorts of zany approaches.
19:17:06 <JoeyA> If I return a continuation, I also have to make that continuation when the downloader throws an exception.
19:17:34 <JoeyA> So I could return three continuations: go ahead, on success, on failure.
19:17:44 <JoeyA> But that's really messy.
19:17:57 <ddarius> JoeyA: You seem to be overcomplicating this.
19:18:02 <wavewave> JoeyA: I am not sure that I understand your situation well, but MVar problem often happens when you create MVar and read it in another thread before it is really created.
19:18:14 <JoeyA> ddarius: Indeed, that's sort of what I'm saying.
19:18:53 <JoeyA> I haven't learned much about STM, but am looking into it.
19:18:55 <wavewave> very simple workaround is wait some time before read MVar value.
19:19:10 <wavewave> by just threadDelay or something.
19:19:19 * ddarius doesn't know wtf wavewave is talking about.
19:20:24 <Cale> http://www.twitch.tv/steven_bonnell_ii -- 26.5 million views for this guy's SC2 stream page, and he hasn't even won a major tournament (he is really entertaining though) :)
19:20:29 <JoeyA> After considering various ways of coding a threaded daemon a piece at a time, I've found that my approach falls apart when dealing with threads, mvars, and exceptions.
19:20:47 <wavewave> ddarius: I now share some of my experience if JoeyA encounters the same situation.
19:20:53 <dylukes> JoeyA: when in doubt ,shared nothing concurrency!
19:20:58 <dylukes> message passing ftw
19:21:09 <Cale> I hate the term "shared nothing". Message passing is sharing.
19:21:10 <JoeyA> So my best recourse is to just code a bunch of simple actions, and have my main module be a messy glue-it-together thing.
19:21:24 <dylukes> Cale: sharing-nothing-except-by-copying
19:21:24 <dylukes> happy/
19:21:25 <dylukes> ?
19:21:27 <Cale> :)
19:21:38 <ddarius> Cale: It is (in many cases) only sharing values, though references to other processes get murky.
19:21:44 <dylukes> message passing is not sharing though, since it's being copied.
19:21:48 <ddarius> I can easily set up a "reference cell" process.
19:21:54 <dylukes> ddarius: ^
19:21:59 <dylukes> You could, but its kind of silly :3
19:22:02 <JoeyA> And to code dumbed-down versions of my daemon and learn from the experience, rather than building the application piecemeal.
19:22:04 <dylukes> I mean, it's done all the time though.
19:22:28 <Cale> If the state of one thread depends on the state of another in some fashion, then each thread essentially becomes its own little memory cell with perhaps a somewhat different interface than get/set, but still a memory cell shared with everything that can communicate with it.
19:22:40 <Cale> Or, I should say, big memory cell
19:22:46 <dylukes> "can become" is not "is"
19:22:48 <JoeyA> It's like there's a purity to IO "functions" that parallels pure functions.
19:23:02 <ddarius> dylukes: No, it pretty much always is.
19:23:07 <dylukes> You can make apple pie from apples, but that doesn't mean apples are pies.
19:23:10 <Cale> Well, it is to the extent that it responds to other messages in the system
19:23:17 <Cale> which is pretty much the whole point, so it has to be
19:23:25 <dylukes> Cale: Right, but it doesn't directly depend on another process,
19:23:30 <dylukes> it depends on the messages it's received.
19:23:38 <dylukes> It's agnostic to the state of its neighbors.
19:23:41 <JoeyA> In my downloader example, I sacrificed being able to abstract away the loop to vastly simplify the interface and usage.
19:23:43 <Cale> Which are emitted by other processes
19:23:44 <dylukes> and that level of indirection is what matters.
19:23:48 <Cale> based on their states
19:23:52 <ddarius> Part of the point of many message passing approaches is to get the sequential execution for a single process while handling a message.
19:23:55 <dylukes> Right, but they could be emitted by *any* other processes.
19:24:01 <JoeyA> Likewise, one might sacrifice being able to access the database for the sake of keeping a function pure
19:24:15 <Cale> You still have all the problems with shared memory concurrency, you just have them one level up.
19:24:18 <dylukes> Each process is for most intensive purposes alone, except when it gets a foreign pid ref.
19:24:30 <dylukes> Cale: most of them can be dodged due to that level of indirection.
19:24:46 <dylukes> And you don't have any of the issues with shared memory, unless you reintroduce some form of shared memory.
19:25:03 <dylukes> (i.e, ETS, mnesia, global state processes)
19:25:17 <dylukes> And even then, it's a lot more restricted and easier to reason with.
19:26:14 <ddarius> Cale: You do, the benefit is that you usually have a much coarser grain and the "interleavings" are more semantically meaningful.
19:26:27 <dylukes> The point is that by abstracting all communication to message passes, theres not any DIRECTLY shared memory.
19:26:41 <dylukes> ddarius: What do you mean?
19:27:07 <Cale> I suppose. It kinda seems like a stop-gap measure to me, kind of like how OO helps problems with imperative languages, but at some level you end up with very similar problems.
19:27:11 <keep_learning> :t TOD
19:27:12 <lambdabot> Not in scope: data constructor `TOD'
19:27:23 <shachaf> Is there a whenM :: m Bool -> m () -> m ()?
19:27:23 <keep_learning> TOD 100 0
19:27:24 <Cale> keep_learning: Probably the Time Of Day constructor
19:27:35 <dylukes> Cale: I've found message-passing to generally work a lot better than OO in its respective field.
19:27:50 <ddarius> Cale: A "stop-gap measure" suggests that there is a "proper" solution.
19:27:56 <Cale> data ClockTime = TOD Integer Integer
19:28:08 <dylukes> Cale: also, its pretty formalized
19:28:09 <dylukes> http://en.wikipedia.org/wiki/%CE%A0-calculus
19:28:16 <Cale> Number of seconds since 1970 + additional picoseconds
19:28:21 <ddarius> Whereas I would say the shared memory abstraction is a stop-gap measure for the distributed nature of reality.
19:28:43 <dylukes> mm, shmem seems a lot more stopgap to me.
19:28:43 <keep_learning> Cale, is there any reverse function ?
19:28:45 <JoeyA> To me, a great STM talk would shed light on how STM tackles the difficulty in breaking down threaded programs, not just what STM is.  Still need to watch the channel9 one to see.
19:28:53 <Cale> keep_learning: reverse?
19:28:58 <ddarius> dylukes: The pi calculus is only one of -many- different message passing formalisms.
19:29:10 <dylukes> ddarius: Sure, it was just an example :)
19:29:11 <keep_learning> Cale, given date and time and return epoch time
19:29:12 <Cale> JoeyA: Have you read the paper?
19:29:20 <dylukes> keep_learning:
19:29:20 <Cale> JoeyA: (I'm new to this discussion)
19:29:22 <dylukes> :t reverse
19:29:23 <lambdabot> forall a. [a] -> [a]
19:29:26 <JoeyA> Again, not yet.
19:29:26 <dylukes> > reverse "foobar"
19:29:28 <lambdabot>   "raboof"
19:29:36 <Cale> dylukes: Oh, then start there.
19:29:45 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/#composable
19:29:49 <dylukes> ?
19:29:50 <dylukes> me?
19:29:57 <dylukes> JoeyA I think you mean.
19:30:02 <Cale> uh, yes
19:30:03 <dylukes> I read the STM paper.
19:30:06 <Cale> JoeyA: :)
19:30:06 <dylukes> It was interesting.
19:30:08 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf -- specifically
19:30:26 <Cale> You're both the same colour in my IRC client :)
19:30:27 <dylukes> is that the one with the santa claus example?
19:30:34 <dylukes> Yep, it is. :)
19:30:46 <keep_learning> Cale,  Like TOD 100 0 return Thu Jan  1 05:31:40 IST 1970 so is there is any function given Thu Jan  1 05:31:40 IST 1970 return 100 ?
19:30:49 <Cale> oh, maybe that's not what I meant to link actually
19:30:58 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf -- this one!
19:31:09 <Cale> but yeah, they're both good :)
19:31:40 <Cale> keep_learning: You're probably going to want the new time stuff in Data.Time.*
19:31:55 <wavewave> keep_learning: look at Data.Time.Clock.
19:32:10 <Cale> Data.Time.Format
19:32:10 <wavewave> ah.. one step late. ;-P
19:32:26 <Cale> defines parseTime
19:32:37 <Cale> which you can use to parse time/date strings in various formats
19:33:36 <dylukes> Hm... I feel like I should, at some point, make a paper-queue
19:33:42 <dylukes> and dedicate myself to getting through at least one a day
19:33:45 <dylukes> that would be great.
19:33:52 <dylukes> I don't have the time as it is sadly ;~;
19:38:33 <slack1256> dylukes: every haskeller promise to make a paper-queue someday...
19:43:16 <shachaf> Where was that function :: Either a a -> a?
19:43:22 <ddarius> If I read a paper a day from my backlog, it would take about three years.
19:43:31 <shachaf> (Other than "either id id")
19:43:55 <ddarius> id+++id ?
19:44:02 <ddarius> er ||| ?
19:44:04 <amtal> ddarius: it's not a backlog it's a stack
19:45:26 <shachaf> I saw a library that defined a named function for that recently.
19:45:42 <ddarius> It's a counit of an adjunction...
19:46:40 <ddarius> And thus a counit (extract) of a comonad.
19:47:15 <ddarius> (A fairly boring comonad, admittedly.)
19:47:35 <shachaf> A comonad isomorphic to (Bool,a)?
19:48:32 <ddarius> Yes.
19:59:13 <compugirl89421> hello
19:59:32 <compugirl89421> anyone familiar with brookshear/computer science?!?
19:59:56 <compugirl89421> if so can anyone help me with the question---> http://cxg.de/_9d1f6b.htm
20:02:52 <solidsnack> compugirl89421: Not really the right channel for your question...
20:03:40 <compugirl89421> which would be?
20:04:25 <solidsnack> Don't know the server that well; probably should check google to see if there is a "homework" channel on FreeNode.
20:05:32 <compugirl89421> good ide
20:05:35 <compugirl89421> a
20:20:21 <solidsnack> I am having trouble getting Cabal to handle a CPP MIN_VERSION_... clause.
20:20:48 <solidsnack> GHCi loads the same file okay.
20:21:33 <solidsnack> I see this message:      warning: extra tokens at end of #ifndef directive
20:30:26 <amtal> The best homework question policy, is to answer all questions truthfully... But in the language of your choice.
20:32:36 <ddarius> @google "defensive consistency"
20:32:37 <lambdabot> http://www.eros-os.org/pipermail/e-lang/2007-November/012349.html
20:32:37 <lambdabot> Title: [e-lang] What is defensive consistency?
20:34:51 <dmwit> solidsnack: Definitely don't paste any code. ;-)
20:36:48 * hackagebot yeganesh 2.3 - small dmenu wrapper  http://hackage.haskell.org/package/yeganesh-2.3 (DanielWagner)
20:36:50 * hackagebot suffixtree 0.2.2.1 - Efficient, lazy suffix tree implementation  http://hackage.haskell.org/package/suffixtree-0.2.2.1 (BryanOSullivan)
20:37:02 <solidsnack> dmwit: It's hard to reproduce...
20:37:07 <solidsnack> Putting together a small package now.
20:42:55 <hpaste> solidsnack pasted “Minimus.hs” at http://hpaste.org/52733
20:43:24 <hpaste> solidsnack pasted “Minimus.hs” at http://hpaste.org/52734
20:44:34 <hpaste> solidsnack pasted “minimus.cabal” at http://hpaste.org/52735
20:45:06 <solidsnack> GHC builds it, GHCi loads it but Cabal doesn't like it.
20:45:29 <solidsnack> dmwit: If you get a chance to take a look, let me know.
20:51:17 <amtal> Does anyone use the CoreErlang package on hackage?
20:52:16 <amtal> I've got a bugfix + small improvement to it at https://github.com/amtal/coreerlang, not sure how soon I should pester maintainers to pull it.
20:53:16 <dmwit> solidsnack: looking
20:55:10 <dmwit> solidsnack: weeeeird
20:55:23 <solidsnack> inorite?
20:58:00 <dmwit> solidsnack: #if, not #ifdef
20:58:17 <dmwit> and #if !, not #ifndef
20:59:22 <solidsnack> Oh, hmm.
20:59:24 <solidsnack> Okay, that works with Cabal.
20:59:49 <solidsnack> However, GHC dies with 'Minimus.hs:8:0:  error: missing binary operator before token "("'
21:00:11 <solidsnack> This is some kind of cpp/cpphs weirdness, I guess.
21:00:33 <solidsnack> Now I need to have macros in my macros to select the macros.
21:01:12 <dmwit> solidsnack: Oh, you just need to figure out the right command-line parameters to pass to define the operators.
21:01:24 <dmwit> I don't know the right answer to that, but you shouldn't need to change the source.
21:01:29 <dmwit> Maybe look in the cabal documentation?
21:01:34 <solidsnack> Command line parameters to define the operators?
21:01:43 <dmwit> yeah
21:01:43 <solidsnack> To define ifndef, you mean?
21:01:56 <dmwit> cabal sends some parameters that define MIN_VERSION_base and friends.
21:01:56 <solidsnack> I am not sure what operators are meant.
21:02:02 <dmwit> They're not #defines.
21:02:21 <solidsnack> Oh, hmm.
21:02:26 <dmwit> (That's why #ifdef and #ifndef are wrong.)
21:02:35 <solidsnack> So they are not even available when I load it from GHCi.
21:02:37 <solidsnack> Aha.
21:03:16 <solidsnack> So they are undef, ha.
21:03:29 <solidsnack> Which works find since I have an older base.
21:04:10 <dmwit> Okay, I have to go to bed. Good luck unraveling what you need.
21:04:24 <solidsnack> dmwit: Thanks.
21:28:39 <keep_learning> i have installed pcap  library in user but when i am running ghci from root and trying to import Network.Pcap it shows could not find the module
21:30:59 <hpaste> “Mukesh Tiwari” pasted “Running ghci from root” at http://hpaste.org/52736
21:37:48 <deech> Hi all, I've enabled building documentation by default in Cabal, but the Haddocks it generates don't have a "Source" link. I know the sources are sitting in tarballs in my .cabal directory, how do I get them to link?
21:44:04 <luite> deech: I think cabal install can't do that, only cabal haddock
21:44:51 <luite> deech: I overwrite all documentation with source-linked versions when I build the hoogle index of my locally installed packages
21:44:56 <luite> it works, but it
21:45:10 <luite> 's a bit annoying that the source links disappear when a package is reinstalled
22:17:40 <hpaste> fazzone pasted “Trie + Anagrams” at http://hpaste.org/52738
22:18:27 <fazzone> Is there a neater / more idiomatic way to write the "bwList" function?  I think the if-then-else bit is a little funny, in addition to all the 'let's
22:21:38 <Axman6> fazzone: well, you can replace the second and third lets with spaces =)
22:21:49 * hackagebot acme-missiles 0.2 - Cause serious international side effects.  http://hackage.haskell.org/package/acme-missiles-0.2 (JoeyAdams)
22:22:20 <fazzone> Axman6: I don't think it likes that inside the 'do'
22:22:47 <fazzone> *yes it does, indentation error
22:23:09 <Axman6> yeah, indentation is important
22:23:13 * Axman6 -> out
22:24:01 <fazzone> GHC just likes to bug me a little for using tabs :)
22:25:07 <luite> I've set up my editor to highlight tabs
22:27:40 <fazzone> I use tabs because spaces take forever to backspace.  I suppose if I were cool enough to use a real editor that would be a nonissue, but there I am
22:29:21 <shachaf> fazzone: What's your editor?
22:29:30 <fazzone> For Haskell, gedit
22:29:52 <joo> gedit can delete multiples of spaces, that I recall
22:29:56 <shachaf> Hmm, I thought gedit did that.
22:30:02 <shachaf> But I can't make it work...
22:30:19 <joo> there's a configuration setting somewhere
22:30:20 <shachaf> Oh, shift-tab will untab.
22:30:27 <joo> Yes.
22:30:44 <shachaf> (If you set it to use spaces.)
22:31:49 * hackagebot acme-missiles 0.2.1 - Cause serious international side effects.  http://hackage.haskell.org/package/acme-missiles-0.2.1 (JoeyAdams)
22:32:00 <fazzone> shachaf, joe: most excellent!
22:32:22 <shachaf> fazzone: Or you could use vim. :-)
22:33:28 <fazzone> shachaf: for serious editing, I generally prefer emacs.  Haven't gotten haskell-mode to work yet though, so I suppose I don't get to complain
22:33:45 <shachaf> vim isn't for serious editing.
22:33:57 <shachaf> So you're allowed to use it. No configuration needed.
22:42:21 <levi> I dunno about 'not for serious editing'.  I don't program with it, generally, but some version of vi saved my bacon many years ago when I needed to load a corrupted database dump that was larger than my PC's RAM+swap and excise the corrupted bits.
22:44:36 <companion_cube> vim is suitable for "serious editing"
22:49:04 <newsham> vi -R is good for goofin around
22:49:17 <shachaf> companion_cube: I didn't say it wasn't suitable.
22:52:23 <wli> Almost certainly not nvi; it's bad about processing large files.
22:55:40 <companion_cube> emacsis good on large files ?
22:58:49 <mysticc> hello .. I have http://paste.pocoo.org/show/493703/ .... writing (putStrLn $ showManyP "%d" 10 )  works when I load it into ghci but not when I write it main = (...) inside the program ??
22:59:30 <mysticc> any one ??
23:02:30 <quicksilver> mysticc: dreaded monomorphism restriction I expect.
23:03:15 <quicksilver> mysticc: as a hint for the future though, doesn't work doesn't help us. We need to see the error message you're getting.
23:03:23 <shachaf> mysticc: Saying "X doesn't work" rarely gives us enough information to be able to help.
23:03:57 <shachaf> You should probably call your class something that isn't Showable, by the way.
23:06:49 * hackagebot rdioh 0.1.1 - A Haskell wrapper for Rdio's API.  http://hackage.haskell.org/package/rdioh-0.1.1 (AdityaBhargava)
23:38:58 <osfameron> oh my god, they killed buffer!
23:40:14 <otulp> you bastards!
23:45:43 <rimmjob> are there any other fields, besides multicore/distributed computing, that FP makes much easier
23:46:15 <copumpkin> all of them, in my opinion
23:46:36 <copumpkin> well, most of them :)
23:49:13 <c_wraith> FP really doesn't solve most of the problems with multicore or distributed computing, either.  The fact is, those are just plain hard.
23:49:34 <Tordek> wait, what?
23:49:40 <Tordek> next you'll tell me FP
23:49:44 <Tordek> 's not a silver bullet
23:52:33 <rimmjob> i had a class called "concurrency in java"
23:53:07 <rimmjob> it was really terrible, but i tried some of the problems in clojure and they were 100x simpler
23:53:28 <companion_cube> sure, with STM it becomes tractable
23:53:34 <silver> but java is FAST!
23:55:29 <c_wraith> wait, I thought the internet said java was SLOW.
23:55:33 <c_wraith> I'm foncused
