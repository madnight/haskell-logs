00:35:10 <alem0lars> I need a type guru for a problem related to my xmonad configuration. I tried to make my configuration for different desktop environments.. This is the relevant part for the error: http://hpaste.org/53009
01:41:23 <techtangents> hello
01:42:16 <techtangents> Does anyone know this function? Monad m => (a -> m b) -> (b -> c) -> (a -> m c)
01:44:29 <Feuerbach> :t \f g -> liftM g . f
01:44:30 <lambdabot> forall a1 r (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f (m a1) -> (a1 -> r) -> f (m r)
01:45:10 <Feuerbach> :t \f g -> liftM g . f :: Monad m => (a -> m b) -> (b -> c) -> (a -> m c)
01:45:11 <lambdabot>     Inferred type is less polymorphic than expected
01:45:11 <lambdabot>       Quantified type variable `c' is mentioned in the environment:
01:45:11 <lambdabot>         g :: a1 -> a -> m c (bound at <interactive>:1:3)
01:45:58 <techtangents> Right. Cool.
01:46:32 <techtangents> :t (>>^)
01:46:33 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> (c -> d) -> a b d
01:46:58 <techtangents> Seems similar.
01:47:34 <Feuerbach> Indeed, using the Kleisly arrow
01:48:00 <Feuerbach> Kleisli
01:48:18 <techtangents> So I wonder if I can use that...
01:48:43 <byorgey> :t \f g -> f >=> return . g
01:48:44 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> m b) -> (b -> a1) -> a -> m a1
01:49:25 <techtangents> :t (>=>)
01:49:26 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:49:57 <techtangents> So, kleisli composition of a kleisli and a normal function lifted into a kleisli?
01:50:02 <Feuerbach> :t \f g -> runKleisli $ Kleisli f >>^ g
01:50:02 <lambdabot> forall (m :: * -> *) a b c. (Monad m) => (a -> m c) -> (c -> b) -> a -> m b
01:50:30 <techtangents> :t runKleisli
01:50:31 <lambdabot> forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
01:51:11 <Feuerbach> Kleisli is just a newtype wrapper for a -> m b
01:52:26 <techtangents> Hrmm... I think I wanted a function like >>^ - the types seemed to fit - but the 'f' needed to be an arrow (kleisli arrow in this case)
01:52:34 <techtangents> is that right?
01:53:20 <Feuerbach> a -> m b is already a Kleisli arrow -- it's just Haskell doesn't know that. So you need to give it a hint, by wrapping it into Kleisli newtype and then unwrapping back
01:54:11 <techtangents> I see!
01:54:16 <techtangents> No wonder I was confused!
01:54:58 <techtangents> thanks!
01:55:51 <Feuerbach> yw
02:42:59 <faceoftheplanet> how do you make Ptr value from a function so that you can give a Haskell callback to a C library to call?
02:43:16 <faceoftheplanet> is this possible?
02:43:59 <faceoftheplanet> or do i have to implement my own callback triggers and such ~_~
02:45:32 <rostayob> faceoftheplanet: you can use the "wrapper" thing
02:45:55 <rostayob> faceoftheplanet: http://www.haskell.org/onlinereport/haskell2010/haskellch35.html#x43-30800035.2
02:46:09 <rostayob> you can easily get function pointers of haskell functions that way
02:46:58 <DanBurton> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
02:51:12 <faceoftheplanet> oh, sweet. thanks guys
02:51:15 <jesnor> i have a few questions about ghc optimizations, anyone have time?
02:54:57 <jesnor> anyway, does ghc optimize small tuple/record types into value types to avoid allocation? when creating an array with small elements, are they stored as value types or always as references?
02:55:41 <DanBurton> um
02:55:48 <DanBurton> not sure
02:55:54 <DanBurton> by "array" do you mean list?
02:56:04 <jesnor> no i mean proper arrays
02:56:05 <opqdonut> unboxed tuples at least are treated efficiently
02:56:19 <DanBurton> Haskell has unboxed arrays too
02:56:32 <opqdonut> also small unboxed records
02:56:55 <opqdonut> see also -funbox-strict-fields
02:58:25 <jesnor> so, unboxed arrays will unbox any user defined type?
02:58:45 <opqdonut> no
02:59:10 <opqdonut> read the docs http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Unboxed.html
02:59:39 <opqdonut> also, you might find http://nix-tips.blogspot.com/2011/03/how-to-choose-haskell-array-library.html interesting
03:03:06 <jesnor> UArray only seem to work for primitive types, correct?
03:05:01 <ivanm> so it turns out that my grand plans for having some kind of simple, intermediary representation of graphs that can be consumed/created by different binary encoding methods might not work, or at least not efficiently
03:06:09 <ivanm> because they all typically require different types of pre-processing done that would be best done on the graph, and so it might just be easier to avoid the intermediary representation :s
03:06:30 <opqdonut> jesnor: well you can define your own UArray instances too. also, some unboxed array libraries know how to unbox e.g. Binary instances
03:07:35 <opqdonut> http://hackage.haskell.org/packages/archive/vector/0.9/doc/html/Data-Vector-Unboxed.html#t:Vector
03:09:15 <jesnor> opqdonut: ah, thats useful
03:10:08 <opqdonut> there are many different array libraries with slightly different designs wrt. unboxing, stream fusion, splicing
03:10:37 <opqdonut> you'll probably need to do some research to find the one that suits your use case
03:13:28 <jesnor> ok, thanks
03:13:39 <jesnor> whats the status of the LLVM backend?
03:32:57 <Peaker> techtangents: you can also use the Kleisli composition functions directly on (a -> m b) (e.g: >=>)
03:32:58 <Peaker> @type (>=>)
03:32:59 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
03:33:50 <evan__> Hi all, can somebody tell me why I cant use elem(e lst) when lst is a list of 2-tuples and e is a 2-tuple?
03:33:59 <evan__> i get a type error
03:35:14 <techtangents> Peaker: yeah, I'm aware of that one. See, there is >>> for Categories, and >=> specialised to kleislis, to avoid the "runKleisli $ Kleisli" boxing above. But, there isn't equivalents for >>^ et al.
03:35:41 <mah_b> > (1,2) `elem` [(2,1),(1,2),(3,4)]
03:35:42 <lambdabot>   True
03:35:45 <mah_b> > (1,2) `elem` [(2,1),(1,3),(3,4)]
03:35:46 <lambdabot>   False
03:36:12 <techtangents> So, I think I'll write it and get it up to hackage. Would be my first hackage package. Alternatively, it'd make a good contribution for the Control.Arrow module.
03:36:55 <mah_b> @type elem
03:36:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
03:37:48 <evan__> oh okay i wasn't aware of that syntax (i'm a beginner obvs) thanks alot
03:39:08 <evan__> a more general question: when should i use the a `func` b syntax as opposed to func(a b)?
03:40:00 <ivanm> evan__: whenever you think it makes it cleaner
03:40:10 <ivanm> consider this: a `func` g b
03:40:16 <ivanm> ^^ applying another function to one side
03:40:35 <ivanm> using prefixes, you'd have to do func a (g b) or func a $ g b
03:40:45 <ivanm> but it's normally a visual, personal preference thing
03:40:52 <evan__> oh okay, thanks!
05:13:56 <dixie> What is replacement for old-locale? It seems time depends on it when I want parse time
05:17:58 <geheimdienst> dixie: if i remember correctly, it got that name by mistake. "old-locale" is the one and only locale package. it's confusing, sorry
05:20:54 <dixie> oh. no problem :) but it is funny how some inocent mistake can cause unnecessary cognitive load
05:55:27 <mm_freak> when you have a Builder and are working with the enumerator library, what's better for sending?  iterSocket or toByteStringIO?
06:04:24 <hpaste> sal23 pasted ‚ÄúLazy sum using ST - how to make strict?‚Äù at http://hpaste.org/53014
06:06:22 <sal23> scratching my head about how to make sum strict in forM_ part of the code‚Ä¶is it possible to sneak in a seq or ! there without refactoring the code?
06:13:25 <ben> I'm not sure you can get around something like forM_ xs $ \x -> readSTRef n >>= (writeSTRef n $!) . (x+)
06:18:08 <sal23> ben, thanks. let me try that
06:18:47 <mm_freak> sal23: why ST anyway?
06:19:02 <sal23> mm_freak, just playing with it
06:19:09 <mm_freak> ah, alright
06:21:23 <mm_freak> :t \f var -> do x' <- readSTRef var; let x = f x'; x `seq` writeSTRef var x
06:21:24 <lambdabot> parse error (possibly incorrect indentation)
06:21:37 <mm_freak> :t \f var -> do { x' <- readSTRef var; let x = f x'; x `seq` writeSTRef var x }
06:21:38 <lambdabot> parse error on input `}'
06:22:08 <ben> :t let modifySTRef' r f = readSTRef r >>= (writeSTRef r $!) . f in modifySTRef'
06:22:13 <lambdabot> forall s a. STRef s a -> (a -> a) -> ST s ()
06:22:16 <mm_freak> :t let modifySTRef' f var = do { x' <- readSTRef var; let x = f x'; x `seq` writeSTRef var x } in modifySTRef'
06:22:17 <lambdabot> parse error on input `}'
06:22:44 <mm_freak> gah‚Ä¶  no layout sucks
06:23:01 <mm_freak> for some reason i don't like that ($!) function
06:24:13 <ben> Probably because it has seq inside it
06:25:26 <mm_freak> ben: no, i use seq explicitly
06:25:30 <mm_freak> @src ($!)
06:25:30 <lambdabot> f $! x = x `seq` f x
06:25:39 <mm_freak> hmm
06:30:31 <sal23> ben, modifySTRef' looks like a better solution. thanks
06:34:12 <sal23> with that solution, sum using STRef takes half the time of sum implemented using foldl', and 1/2 the memory
06:34:51 <sal23> was just playing around to see how they behave under different implementations‚Ä¶will be nice to have some kind of redex generator in ghc that could show the redexes
06:42:22 <Ptival> hey #haskell, what do you recommend to set up a static personal website using Haskell-world stuff?
06:45:11 <donri> hakyll
06:46:35 <Ptival> that's what I wat looking at :)
06:49:25 <Ptival> the tutorial is strange in that it doesn't tell you how to begin, but asks you to retrieve an existing project
06:52:38 <KitB> @src seq
06:52:38 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:55:14 <mm_freak> KitB: seq is magic
06:55:37 <mm_freak> Ptival: either hakyll or pandoc
06:55:44 <mm_freak> i'm using pandoc with a Makefile
06:55:51 <donri> hakyll uses pandoc methinks
06:55:57 <mm_freak> yes, it does
06:55:59 <ben> What is GHC.Exts.lazy used for?
06:56:55 <mm_freak> donri: it's a long time ago, but i remember fighting against the limitations of hakyll‚Ä¶  it may be different today
06:57:52 <donri> duno, haven't used it myself
06:59:08 <qwer123> What's the easiest way to use haskell as fastCGI under debian squeeze ?
07:02:08 <Kaidelong> is there a particular name for the relationship compare (g x) (g y) == compare (f x) (f y)? does monotonicity work just as well talking about one function being monotonic with respect to a non-id function?
07:02:10 <dafis> ben: tricking the compiler to believe that the function is not strict (it's magic, too)
07:03:02 <ben> is the effect that lazy (f $!) x is equivalent to f x?
07:03:17 <ben> What's it good for? <:)
07:05:27 <Kaidelong> > (\x -> if x then const 5 else tail) True $! undefined
07:05:28 <lambdabot>   No instance for (GHC.Num.Num [a])
07:05:28 <lambdabot>    arising from a use of `e_15' at <inter...
07:05:37 <Kaidelong> > (\x -> if x then const [] else tail) True $! undefined
07:05:38 <lambdabot>   *Exception: Prelude.undefined
07:05:47 <Kaidelong> > (\x -> if x then const [] else tail) True undefined
07:05:48 <lambdabot>   []
07:06:19 <dafis> ben: no, it just hides f from the strictness analyser
07:06:44 <ben> Oh. I didn't know anything about the strictness analyser. It's magic, too, isn't it?
07:07:33 <dafis> in a way, everything the compiler does is magic
07:07:54 <dafis> much of it is expressible in Haskell
07:08:24 <dafis> things like seq or lazy aren't
07:08:35 <ben> Can you show me an example where introducing lazy into a program causes observably different behavior?
07:08:55 <dafis> ben: not off the top of my head, sorry
07:08:59 <ben> all right
07:09:10 <ben> Then I don't feel bad for not getting what it's good for :)
07:10:28 <Kaidelong> I imagine you'd want to do it when A) the compiler determines that a particular function argument is strict and B) it still is better to evaluate it lazily, performance wise, in that particular situation
07:10:47 <Kaidelong> doubt that'd be neccessary very often though
07:11:01 <dafis> ben: -- Implementation note: its strictness and unfolding are over-ridden
07:11:01 <dafis> -- by the definition in MkId.lhs; in both cases to nothing at all.
07:11:01 <dafis> -- That way, 'lazy' does not get inlined, and the strictness analyser
07:11:01 <dafis> -- sees it as lazy.  Then the worker/wrapper phase inlines it.
07:11:01 <dafis> -- Result: happiness
07:13:42 <yitz> qwer123: can't you just compile to an executable and run it as usual?
07:14:47 <qwer123> yitz: and how this would be linked to the webserver?
07:14:57 <qwer123> as standard cgi you mean?
08:03:25 <s951> Hey, stupid question: how do I extract an element from a triple?
08:03:45 <shachaf> Pattern match.
08:04:08 <shachaf> Unless by "triple" you mean monad, in which case you can't in general. :-)
08:06:07 <yitz> > thrd (_,_,x) = x in thrd (1,2,3) -- s951
08:06:08 <lambdabot>   <no location info>: parse error on input `='
08:06:31 <yitz> > let thrd (_,_,x) = x in thrd (1,2,3) -- s951
08:06:32 <lambdabot>   3
08:08:46 <s951> can i do pattern matching on something that isn't a direct argument to the function?
08:08:55 <s951> i.e. if it's an arg to a function that my function calls.
08:09:10 <s951> ?
08:09:47 <Eduard_Munteanu> s951: any pseudo-Haskell example?
08:10:18 <Eduard_Munteanu> The answer is probably no.
08:10:34 <aavogt> > map (\x -> case x of 1 -> 'a'; _ -> char x) [1..]
08:10:35 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:10:35 <lambdabot>         against inferred type...
08:10:53 <aavogt> > map (\x -> case x of 1 -> 'a'; _ -> chr x) [1..]
08:10:54 <lambdabot>   "a\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ETB\...
08:11:11 <aavogt> s951: in that sense?
08:13:01 <s951> function1 takes an argument n. Function 2 takes an argument n, and returns a triple depending on the value of n. How do I extract the first, second or third element of the output of function2 using pattern matching in function1?
08:13:46 <shachaf> let (a,b,c) = f2 n in ... ?
08:16:13 <s951> ...
08:16:14 <s951> doh
08:16:16 <s951> thanks
08:24:33 <angstrom> is it considered bad practice to use guards, where an if/then/else would suffice?
08:26:21 <shachaf> angstrom: Probably not?
08:27:04 <s951> Back again: Could I make this any simpler than extractA = a, where (a,b,c)=returnTriple
08:27:13 <snifi> I would prefer guards, I feel them more readable.
08:27:16 <angstrom> e.g., `f xs | null xs = "bla" ; otherwise = "foo"' vs. `f xs = if null xs then "bla" else "foo"'
08:27:22 <angstrom> ok
08:27:39 <shachaf> angstrom: Just pattern match.
08:27:43 <shachaf> On xs.
08:28:30 <angstrom> well. that was just an example
08:29:25 <shachaf> Well, give an example where there isn't another solution and people can answer you better. :-)
08:30:45 <angstrom> e.g., `f xs | predicate xs = "bla" ; otherwise = "foo"' vs. `f xs = if predicate xs then "bla" else "foo"' ;->
08:31:05 <angstrom> also, s/;/|/, probably
08:31:20 <mike-burns> You want us to say "always do this" or "never do that"?
08:31:39 <mike-burns> Why would they put something in the language if you are never supposed to use it?
08:32:07 <angstrom> mike-burns: I'm referring to the case where you're having exactly one "regular" guard, and `otherwise'
08:32:39 <mike-burns> Sometimes it reads better, sometimes it doesn't.
08:32:44 <angstrom> fair enough
08:32:45 <shachaf> It's not such a big deal. Do whatever seems clearest.
08:51:15 <coppro> Is there any way to do something similar to lisp's (with-file) in Haskell or must you pass a handle around?
08:52:56 <mercury^> You mean withFile?
08:54:12 <mercury^> Probably not. :)
09:08:05 <yitz> coppro: something vaguely analogous might be to use a reader monad with the file handle as its value.
09:12:14 <qwer123> What's the easiest way to use haskell as fastCGI with httpd under debian squeeze ?
09:14:28 <coppro> hmm... I'll just refactor this code later and hack around it for now
09:15:17 <dschoepe> qwer123: Yes, that should help: http://hackage.haskell.org/package/fastcgi
09:15:50 <fasta> Which library can subtract two dates in the format <yyyy>-<mm>-<dd> <HH>:<MM>:<SS>?
09:16:39 <qwer123> dschoepe: and which httpd in combination with that ?
09:16:47 <qwer123> for easy handling
09:17:05 <dschoepe> qwer123: Most httpds support fcgi, I find lighttpd to be quite pleasant to use.
09:17:38 <byorgey> fasta: the time library can do that.  parse them to UTCTimes and then use 'diffUTCTime' (see Data.Time.Clock)
09:17:45 <dschoepe> qwer123: I think nginx is also a popular, lightweight choice.
09:18:02 <hpc> fasta: http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t:DiffTime -- diffUTCTime
09:18:26 <hpc> fasta: http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Format.html#v:readTime -- and this to get a time from a string
09:27:21 * hackagebot skein 0.1.0.2 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.2 (FelipeLessa)
09:35:28 <FUZxxl> Hello!
09:36:03 <FUZxxl> Recently, there was a series of blog post on planet.haskell.org about how arrows are in fact just plain old applicative functors.
09:36:14 <FUZxxl> Anybody knows where I can find that post?
09:39:09 <yitz> FUZxxl: http://cdsmith.wordpress.com/2011/08/13/arrow-category-applicative-part-iia/
09:39:41 <yitz> FUZxxl: that links back to part i
09:40:13 <yitz> FUZxxl: still waiting for the rest of the series, but currently cdsmith is busy teaching haskell to a class of 12-year-olds
10:03:56 <lispy> with ghc 7.0 (and older) I could put INLINE pragmas on functions in classes.  Now with 7.2, ghc is giving me an error saying the function lacks an acompanying binding :(
10:04:37 <lispy> What is the correct way to tell GHC that it should inline a function from a type class?
10:05:50 <dafis> lispy: put the pragma in the instance
10:06:41 <dafis> AFAIK, the inline pragma in the class had no effect anyway (without default method)
10:06:57 <lispy> http://hackage.haskell.org/trac/ghc/ticket/5084
10:07:07 <lispy> dafis: yeah, I guess the previous behavior was considered a bug
10:07:30 <dafis> yup
10:07:43 <szerf> hello , ihave a code that hang and i dont know what is the problem
10:08:15 <lispy> szerf: hmm...can you describe it more?
10:08:59 <szerf> i will past him in hpaste
10:09:05 <hpaste> szerf pasted ‚Äúhang‚Äù at http://hpaste.org/53025
10:09:29 <lispy> Now I get this error (can you tell I just upgraded to 7.2 on osx?) ld: unknown option: -no_pie
10:09:42 <lispy> My cabal file isn't requesting any special ld flags
10:10:03 <dafis> szerf: filter out "."
10:10:28 <dafis> szerf: you read the contents of . infinitely often
10:10:30 <szerf> "." is the current directory
10:10:51 <szerf> how ?
10:11:22 <dafis> szerf: lines 12 and 13
10:13:05 <szerf> ok what i want to do is create a function that take all files paths in a directory and his subdirectories
10:13:28 <dafis> szerf: also filter out ".."
10:13:28 <szerf> i mean return them as a string
10:14:12 <szerf> ok i understand now
10:15:10 <kmc> man i had the classic haskell experience
10:15:26 <kmc> had to think really hard, took hours to write 10 lines of code and make it typecheck
10:15:27 <dafis> szerf: for the recursion, you have to prepend the relative path to the names
10:15:32 <kmc> works the first time
10:15:42 <kmc> performs fine, but its performance relative to other things is totally inexplicable
10:16:10 <dafis> kmc: in which way is it inexplicable?
10:16:40 <kmc> well it's actually not even my code that's inexplicable
10:16:41 <szerf> how to do that
10:17:16 <kmc> the code I wrote was a routine to reshape a Data.Sequence into a rose tree in a natural way
10:17:30 <kmc> (using the internal tree structure)
10:17:39 <k0ral> dcoutts__: would you be available to help me implementing the notify signal ?
10:17:48 <kmc> the hope being that parallelizing an associative fold over a Seq would be faster if you use the natural tree structure
10:18:26 <kmc> rather than, say, splitAt, which has to rebuild parts of the tree structure for each half
10:18:26 <lispy> bah, so that -no_pie error is because I have xcode 3.2.something but I need a newer version like 3.2.3.
10:18:37 <dafis> szerf: in the recursive call, mapM (fdir . (dir </>)) -- needs System.FilePath
10:19:06 <kmc> anyway, the inexplicable part is that splitting the Seq with splitAt and summing chunks performs much better than linearly summing, even without parallelism
10:19:19 <kmc> never mind my tree
10:20:48 <dafis> kmc: I can imagine it would be because linearly summing requires descending to the head for each element (just guessing, though)
10:21:17 <dafis> (and I don't really know Data.Sequence)
10:21:29 <kmc> well i'm using Seq's own Foldable instance
10:22:28 <dafis> that's what you meant by linearly? Strange.
10:22:56 <kmc> well it also performs better than naively unconsing the first element and summing it
10:23:06 <dafis> the Foldable instance should be rather efficient, else bug
10:23:14 <kmc> yeah
10:23:24 <kmc> I assume this splitting is not the way to go in every circumstance
10:23:31 <kmc> (also, it's only valid for associative operators)
10:23:53 <dafis> kmc: quite, thus it can't be done in general
10:24:00 <dafis> still...
10:37:29 <mdxbhmt> @quote stm
10:37:30 <lambdabot> monochrom says: Monad is about postmodernism. There are laws but no one owns them. You can interpret them any way you want. You can write about your own understanding and the meaning of your writing
10:37:30 <lambdabot> is not fixed.
10:37:53 <monochrom> try again :)
10:37:56 <mdxbhmt> @quote stm
10:37:56 <lambdabot> dons says: so, anyone else plan on getting a phd in haskell studies, so they can get a job at a big investment bank? :)
10:38:06 <monochrom> hrm! :)
10:38:35 <byorgey> hehe
10:38:47 <byorgey> @quote STM
10:38:47 <lambdabot> quicksilver says: [about uninstalling packages installed with cabal-install] packages are for life, not just for christmas.
10:38:48 <dafis> @quote stm
10:38:48 <lambdabot> quicksilver says: [about uninstalling packages installed with cabal-install] packages are for life, not just for christmas.
10:39:04 <byorgey> all sorts of words contain 'stm', who knew!
10:39:21 <dafis> @quote "stm "
10:39:21 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
10:39:30 <dafis> @botslap
10:39:30 <lambdabot> Unknown command, try @list
10:39:38 <dafis> @slap lambdabot
10:39:38 <lambdabot> stop telling me what to do
10:39:57 <byorgey> perhaps there ought to be an @all-quotes command that returns *all* matches.  Or perhaps that would just be asking for flooding.
10:40:38 <mdxbhmt> LOL i was thinking lambdabot was making searching related queries, since STM is a monad, had a bank example and a christmas example
10:40:45 <mdxbhmt> way to overthink
10:41:03 <byorgey> inveSTMent, chriSTMas, poSTModernism... =)
10:42:29 <mdxbhmt> Yeah, i would never see it  D:
10:44:59 <FUZxxl> Recently, there was a series of blog post on planet.haskell.org about how arrows are in fact just plain old applicative functors.
10:44:59 <byorgey> @quote rst
10:44:59 <lambdabot> monochrom says: some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748)
10:44:59 <lambdabot> and find one single student who faithfully evaluate 389238493+97283748 first.
10:45:01 <FUZxxl> Anybody knows where I can find that post?
10:45:35 <monochrom> I'm sorry for all my quotes! :)
10:45:35 <FUZxxl> @quote foobar
10:45:35 <lambdabot> magthe says: foobar
10:45:56 <FUZxxl> @quote prepohistozygomorphisms
10:45:57 <lambdabot> No quotes match. It can only be attributed to human error.
10:45:58 <FUZxxl> @quote prepohistozygomorphism
10:45:58 <lambdabot> No quotes match. My pet ferret can type better than you!
10:46:01 <FUZxxl> wow...
10:46:03 <byorgey> FUZxxl: you already asked that, and yitz already answered you
10:46:14 <FUZxxl> byorgey: Well, I was offline by that time.
10:46:19 <mdxbhmt> lol
10:46:25 <byorgey> (12:51) <      yitz> FUZxxl: http://cdsmith.wordpress.com/2011/08/13/arrow-category-applicative-part-iia/
10:46:34 <FUZxxl> ByronJohnson: Is that channel logged?
10:46:39 <byorgey> @where logs
10:46:39 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
10:46:47 <dafis>  http://cdsmith.wordpress.com/2011/08/13/arrow-category-applicative-part-iia/
10:46:51 <byorgey> FUZxxl: logs of #haskell are kept there, for future reference
10:46:55 <dafis> FUZxxl: ^^
10:46:58 <FUZxxl> okay. thanks
10:47:03 <mdxbhmt> @where me
10:47:03 <lambdabot> I know nothing about me.
10:47:16 <mdxbhmt> aw, he's not an AI
10:47:22 * hackagebot swish 0.6.2.1 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.2.1 (DouglasBurke)
10:47:47 <FUZxxl> okay. The second logs-link is dead.
10:49:59 <FUZxxl> thank you!
10:52:54 <ybit> http://youtu.be/b9FagOVqxmI :: mzero's video on haskell
11:04:45 <engla> ybit: what does "amuse bouche" mean?
11:05:53 <steve954> http://entertaining-videos.blogspot.com/
11:07:28 <dafis> engla: "please mouth"  alittle something before the menu to please your palate
11:07:41 <byorgey> engla: it's French for "mouth amuser".  It's a single bite-size appetizer sort of thing sometimes served between courses of a meal.
11:08:04 <engla> oh ok I should learn french
11:08:05 <engla> thanks
11:08:23 <byorgey> you know, if you've ever been to a fancy restaurant and the waiter brings out some tiny thing on a tiny spoon on a tiny plate and says "compliments of the chef"
11:08:42 <byorgey> and that thing turns out to be delicious and you wish you had more than one bite of it.
11:10:18 <hpaste> kmc pasted ‚Äúweird performance summing over Data.Sequence‚Äù at http://hpaste.org/53027
11:11:07 <TomMD> Is all the hoogle documentation badly out of date?  It seems the flags have changed massively and no one updated the wiki. (ex: output --> outfile, --include isn't accepted, etc)
11:11:09 * kmc is perplexed
11:11:41 * pumpkin deperplexes kmc
11:12:11 * kmc derperplexes pumpkin
11:12:29 <pumpkin> :O
11:16:45 <dafis> kmc: another guess: perhaps the strictness analyser doesn't manage to make it strict, so the foldr builds thunks. With splitting, the thunks remain smaller and hence faster to evaluate.
11:17:29 <dafis> kmc: +RTS -hT could help finding out
11:19:09 <kmc> hmm ¬´F.foldl' (+) 0¬ª is a bit slower than ¬´F.foldr (+) 0¬ª
11:19:20 <FUZxxl> Is there a Haskell paper anywhere that comes with sources (*.tex)?
11:19:38 <FUZxxl> I want to see a practical example on how to use this lhs2tex stuff.
11:21:44 <fasta> Is there some library which works for basic financial calculations? (So, no Floats/Doubles.)
11:21:53 <hpc> fasta: CReal
11:22:03 <hpc> it's not even remotely fast, but it's exact
11:22:12 <mm_freak> what is the order of a non-higher-order function?  0 or 1?
11:22:16 <kmc> I would expect Rational to be much more appropriate than CReal
11:22:20 <FUZxxl> fasta: How abou using Rational?
11:22:25 <evan__> Hi all, i want to create a list of 2-tuples which should represent all the possible dominoes (each with 2 numbers from 0-6), what is the best way to do this in haskell? (I'm used to using for loops!)
11:22:27 <mm_freak> ‚Ä¶ conventionally
11:22:31 <kmc> aren't most financial calculations done to a fixed precision?
11:22:37 <kmc> dafis, what should I look for in -hT output
11:22:39 <fasta> kmc: yes.
11:22:53 <hpc> mm_freak: you mean like, rank 1 type, rank 2 type, rank n type?
11:23:00 <dafis> kmc: THUNK
11:23:03 * hpc would guess 1
11:23:05 <kmc> evan__, list comprehension might be the easiest to figure out
11:23:16 <kmc> > [ (a,b) | a <- [0..6], b <- [0..6] ]
11:23:16 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(1,0),(1,1),(1,2),(1,3),(1,4),(1...
11:23:18 <FUZxxl> evan_ How about [(x,y)|x<-[1..6],y<-[1..6]?
11:23:26 <FUZxxl> That's something called a list comprehension
11:23:27 <evan__> okay wow, thats exactly what i need, thank you!
11:23:31 <kmc> > liftM2 (,) [0..6] [0..6]
11:23:32 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(1,0),(1,1),(1,2),(1,3),(1,4),(1...
11:23:46 <kmc> dafis, only a little bit
11:23:50 <hpc> evan__: technically you will get some repeats; the (1,0) domino is the same as the (0,1) domino
11:23:56 <kmc> much more of TSO and ARR_WORDS
11:23:58 <fasta> So, a fixed point arithmetic library.
11:24:00 <hpc> but that's the general idea
11:24:10 <kmc> the latter might come from Criterion's vector-based statistics?
11:24:14 <kmc> i'm not sure otherwise
11:24:20 <FUZxxl> evan__: You could try [(x,y) | x <- [1..6] , y <- [x..6]
11:24:21 <kmc> also confused by TSO -- isn't that a thread state object?
11:24:29 <FUZxxl> that eliminates the double dominoes
11:24:33 <mm_freak> hpc: yes, like when you have a type with parentheses, which can't be simplified away, you have a "higher order function"
11:24:41 <FUZxxl> >  [(x,y) | x <- [1..6] , y <- [x..6]]
11:24:42 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,2),(2,3),(2,4),(2,5),(2,6),(3,3),(3...
11:24:54 <mm_freak> what exactly is the order of a function without parentheses in its type?  0?  1?  is there even a distinction?
11:24:56 <FUZxxl> > length [(x,y) | x <- [1..6] , y <- [x..6]]
11:24:57 <lambdabot>   21
11:25:01 <dafis> kmc: yes, 10000 is too short, I tried with 100000, but nothing much to see (meaning, no clear difference in space used by thunks)
11:25:07 <mm_freak> i would say that the parentheses nesting level is the order of the function
11:25:18 <mm_freak> but then you would have zero order functions
11:25:21 <hpc> mm_freak: i think it has to do with how the foralls are nested
11:25:22 <FUZxxl> foldr1 (+) [1..10] :: Expr
11:25:26 <FUZxxl> > foldr1 (+) [1..10] :: Expr
11:25:26 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + 10))))))))
11:25:30 <mm_freak> hpc: i'm talking about order, not rank
11:25:33 <hpc> oh
11:25:34 <FUZxxl> > foldl1 (+) [1..10] :: Expr
11:25:35 <lambdabot>   1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
11:26:59 <kmc> i've got to go now, but i'll be  back later
11:28:18 * hackagebot diagrams-core 0.4 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.4 (BrentYorgey)
11:28:20 * hackagebot diagrams-lib 0.4 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.4 (BrentYorgey)
11:28:22 * hackagebot diagrams-cairo 0.4 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.4 (BrentYorgey)
11:28:24 * hackagebot diagrams 0.4 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-0.4 (BrentYorgey)
11:28:34 <incluye> @pl \n -> [x | x <- [1..n]]
11:28:34 <lambdabot> return . ((x | x) <-) . enumFromTo 1
11:28:43 <incluye> > (return . ((x | x) <-) . enumFromTo 1) 3
11:28:44 <lambdabot>   <no location info>: parse error on input `|'
11:28:53 <incluye> :(
11:32:29 <hascoooo> How to run a *.hs within ghci ??
11:32:40 <hpc> ghci foo.hs
11:32:53 <hpc> or :l foo
11:33:05 <hpc> or :m+ iforgetthesyntax
11:33:14 <hascoooo> thanks. hpc, and any way to run functions out of foo.hs with arguments?
11:33:15 <hpc> type :? in ghci to learn more
11:33:18 <hascoooo> i need to include ?
11:33:33 <FUZxxl> hpc: for a file to load, you first need :l foo.hs
11:33:52 <hpc> ah, groovy
11:34:06 * hpc mostly just does 'ghci foo.hs', *edit code*, ':r'
11:34:13 <hascoooo> FUZxxl: and afte :l foo.hs I can run functions out of that file ?
11:34:35 <hascoooo> "after :l"
11:38:19 <dafis> hascoooo: yes
11:38:26 <hascoooo> thx
11:38:30 <dafis> if they're exported
11:48:42 <hascoooo> I'm new to hs ... Which module I have to load to solve this error when defining functions like f x = sin x / x??? error: ***parse error on input `='***
11:48:59 <aristid> hascoooo: are you trying to define them in ghci?
11:49:05 <hascoooo> yes
11:49:07 <hascoooo> not possible ?
11:49:11 <aristid> let f x = sin x / x
11:49:21 <aristid> ghci is not in a top-level context
11:49:36 <hascoooo> and f x = sin x / x would work in a foo.hs file ?
11:49:40 <aristid> yes.
11:49:49 <hascoooo> many thansk ;)
11:53:46 <evan__> I'm getting errors trying to define multiple variable declarations when using where, is this not allowed? (code looks like: func x = (a,b) where a=1 b=1) though with indentation and all that of course
11:54:24 <Botje> are you doing it on the ghci command line?
11:54:50 <dafis> evan__: check the indentation twice
11:54:56 <evan__> no i'm using hugs, that is not exactly the code i have written i just put it there as an example
11:55:14 <Botje> you should define functions in a file and then load that
11:55:32 <evan__> yes thats what i'm doing
11:55:41 <evan__> i'm getting the error: Syntax error in input (unexpected `=')
11:56:05 <Botje> put the exact file you're trying to load on hpaste.org
11:56:05 <monochrom> then check tabs. simplest to eliminate all tabs.
11:56:05 <evan__> and the declrations and indented so they are further right then the where
11:56:05 <evan__> okay 1 min
11:56:36 <monochrom> not to say that there isn't a non-obvious way to make tabs work
11:56:51 <hpc> it's just not obvious :P
11:56:57 <hpaste> er pasted ‚ÄúEvan's Dominos‚Äù at http://hpaste.org/53029
11:57:13 <evan__> thats it
11:57:18 <evan__> scroll down to the scoreN function
11:57:21 <hpc> egads
11:57:32 <evan__> the a=1 is arbitrary but its what causes the error
11:57:47 <hpc> evan__: take a look at that file in hpaste for a minute
11:57:52 <hpc> see if you can spot the problem :P
11:58:00 <evan__> any hints?
11:58:07 <monochrom> the (non-obvious) rule about using tab is: if on hpaste things look misaligned, then it's misaligned. screw your editor.
11:58:24 <dafis> evan__: the a needs to be aligned with the definition above
11:58:26 <hpc> evan__: hint: your indentation is HORRIBLE
11:58:39 <hpc> 													then Just ([domino]++board)
11:58:47 <monochrom> the (only) reason why getting tabs to work is non-obvious is that modern editors lie. damn lies.
11:59:09 <hpc> non-modern editors lie too, but only after being configured
11:59:12 <evan__> well i'm using gedit dunno if thats whats causing the problems though - that and i'm not 100% sure on the indentation rules - yes i realize i need to learn them!
11:59:25 <Botje> evan__: turn on tab expansion, be happy.
11:59:27 <monochrom> anyway, dominoes_not_played = ... and a = ... are misaligned.
11:59:48 <hpc> rule #1: never use tabs
11:59:53 <monochrom> so just keep mutating spacing until hpaste shows them aligned
11:59:53 <dafis> Wow. Indented top level definitions
11:59:56 <hpc> you also don't indent after 'module blah where'
11:59:59 <evan__> *turns off gedit tabs..
12:00:27 <hpc> also, stuff like if(fst(domino) == snd(last board))
12:00:40 <dafis> rule #2: if you ever think of breaking rule #1, don't
12:00:43 <hpc> better written as if fst domino == snd (last board)
12:01:18 <hpc> rule #3: spaces between ALL the identifiers
12:01:37 <hpc> except for (:) sometimes
12:02:07 <evan__> okay, thanks for the critique (this is the first program ever written in a functional language)
12:02:36 <hpc> it looks like it typechecks, so that's a strong start
12:02:36 <monochrom> [shameless plug again] so much for "plain text files because you can use any[sic] editor"
12:04:28 <c_wraith> monochrom: why can't I edit these files with photoshop?
12:05:48 <evan__> okay guys, i realize this i a n00b question but i'm still having problems with the indentation, how far right should a=1 be indented? i.e. should it be past the "dominoes_not_played = "?
12:05:55 <hpc> c_wraith: you need to change the color depth
12:06:02 <dafis> evan__: exactly as far
12:06:05 <hpc> or possibly increase your swap memory
12:06:11 <hpc> photoshop is fickle that way
12:06:22 <monochrom> they're under the same "where", make them equal
12:06:32 <hpc> evan__: it should be exactly as far indented as the other stuff it is grouped with
12:06:47 <hpc> where foo = bar
12:06:51 <hpc>       baz = quux
12:07:01 <hpc> (hope your irc client is monospace)
12:07:10 <evan__> okay, yes i can read that
12:07:24 <hpc> it starts at the start of the first declaration, so you can do
12:07:25 <hpc> where
12:07:29 <hpc>   foo = bar
12:07:32 <hpc> for example
12:07:39 <dafis> ah, *much* better
12:08:46 <evan__> hpc: this is what i have but still get the error:
12:08:49 <evan__> scoreN board n =  a
12:08:49 <evan__>   where dominoes_not_played = filter (\d -> (playedP board d) == False) [(a,b) | a <- [0..6], b <- [a..6]]
12:08:49 <evan__>                           a = 1
12:08:58 <evan__> the ='s are aligned
12:09:18 <hpc> it's not the '=' that needs to be aligned
12:09:18 <Botje> the a should start right under the d of dominoes_not_played
12:09:42 <hpc> where biglongthing = stuff
12:09:45 <hpc>       a = b
12:09:48 <evan__> ooh okay thanks that works!
12:10:02 <evan__> ...didn't realize the severity of these indentation rules... lol
12:15:55 <hpaste> er annotated ‚ÄúEvan's Dominos‚Äù with ‚ÄúEvan's Dominos (annotation)‚Äù at http://hpaste.org/53029#a53030
12:18:36 <dafis> in a heap profile (-hT), does STACK refer to anything besides the function call stack?
12:19:55 <elliott> Is the lack of "alter" in unordered-containers' HashMap intentional?
12:26:29 <FUZxxl> How do I notate the maximum of a function f(x)?
12:26:39 <FUZxxl> Is it just $\max f(x)$?
12:27:46 <engla> FUZxxl: something like \sup_{x in U} f(x)  ?
12:28:27 <dafis> FUZxxl: is the domain understood or does it need to be mentioned?
12:28:35 <FUZxxl> It is understood.
12:29:14 <dafis> then $\sup f(x)$ is fine, \max also, if the supremum is taken as a value
12:29:16 <FUZxxl> The function I have has one global maximum (it is monotone and converging). Both that and the domain are known by the context.
12:30:01 <dafis> FUZxxl: then just $\max f$ is plenty good
12:30:07 <FUZxxl> dafis: Actually, I have something like $\max E_n = E_\infty = ... \approx 3.5$
12:30:18 <FUZxxl> dafis: Great! thank you.
12:30:37 <dafis> 'spected values?
12:30:49 <FUZxxl> dafis: Yeah.
12:31:31 <FUZxxl> I have an event that yields true with a probabily of p_n and false otherwise.
12:31:37 <FUZxxl> I repeat it till true comes.
12:31:41 <dafis> FUZxxl: is $E_\infty$ defined by itself or only as the limit/maximum?
12:31:49 <FUZxxl> How often can I expect to do this event?
12:32:07 <dafis> 1/p, iirc
12:32:07 <FUZxxl> dafis: It's actually a limit. I declare that limit elsewhere.
12:32:19 <FUZxxl> dafis: Yeah. That's what I wrote too.
12:32:44 <FUZxxl> It's kind of an excercise. I have to give an upper bound on the expected number of tries.
12:32:47 <dafis> FUZxxl: okay, if it were defined there, it would be better to write $E_\infty := \max E_n = ...$
12:33:04 <FUZxxl> dafis: Why?
12:33:25 <dafis> to make it clear what is defined as what
12:33:26 <FUZxxl> I have a line before stating that p_\infty = lim ...
12:34:02 <FUZxxl> than I write$A_n = p_n^-1$ and finally $\max A_n = A_\infty = ... $
12:34:15 <FUZxxl> dafis: I am goint to consider it.
12:34:49 <dafis> FUZxxl: if it's defined elsewhere, the order doesn't matter, but where things are defined, best to have them leftmost, second best, have them rightmost (blah =: def'ed_thing)
12:37:54 <FUZxxl> dafis: Nah... It's just because those definitions are on the same page and that line was supposed to define $\max A_n$
12:55:54 <tsousa> how can i divide a list like [1,2,3,4,5,6] into [1,2,3] and [4,5,6] the length of the list is specified. new function on the standard librarys?
12:56:07 <Botje> Data.List.Split has chunk
12:56:33 <c_wraith> if you just want to split it into halves, and already know the length, you can use take and drop
12:58:07 <tsousa> c_wraith, take will only take a number. i need to split all of the list in the length that i want
12:59:41 <c_wraith> tsousa: I don't understand what you're saying.  What do you have?   What do you want?  What's the type of this function?  What behavior should it have?  A single example doesn't uniquely define it.
13:00:56 <tsousa> c_wraith, i have a list like [1,2,3,4,5,6,7,8,9,10] and i need to split that list into some number specified by the user like function 3 [1,2,3,4,5,6,7,8,9,10 ] will return [1,2,3],[4,5,6],[7,8,9],[10]
13:01:09 <Botje> Data.List.Split.chunk
13:02:21 * hackagebot cblrepo 0.2.3 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.2.3 (MagnusTherning)
13:05:28 <elliott> CABAL?
13:05:48 <elliott> Completely Automated Bdistribution Algorithms Lforhaskell?
13:05:52 * dcoutts has no idea where he got that capitalisation from
13:06:08 <tsousa> Botje, that library it's no in my system
13:06:29 <Botje> tsousa: then go to the website and steal its code
13:07:11 <dafis> tsousa: cabal install split
13:07:29 <Botje> oh, bleh
13:07:31 <Botje> yeah. that
13:07:33 <FUZxxl> elliott: There are many people outside that write JAVA, too. Java isn't an acronym!
13:07:48 <Botje> stealing code not an option :)
13:08:15 <rostayob> well, FORTH isn't an acronym
13:08:16 <FUZxxl> Botje: Well... It's open sourced. So if you give proper credit, it's not really stealing.
13:08:37 <rostayob> capitalizing is fun
13:08:39 <dafis> so, stealing is not an option
13:09:01 <rferranti> borrow then
13:09:26 <Botje> FUZxxl: no, i mean chunk is not a nice standalone definition. it uses other stuff from .split
13:10:21 <wavewave> hi..
13:11:07 <dafis> > let chunk k = unfoldr (\xs -> if null xs then Nothing else Just (splitAt k xs)) in chunk 3 [1 .. 20]
13:11:08 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
13:12:07 <ion> > unfoldr (\xs -> splitAt 3 xs <$ (guard . not . null) xs) [1..20]
13:12:08 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
13:12:36 <ion> > unfoldr (liftA2 (<$) (splitAt 3) (guard . not . null)) [1..20]
13:12:38 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
13:13:55 <ion> > unfoldr ((<$) <$> splitAt 3 <*> guard . not . null) [1..20]  -- Obfuscated enough? :-P (I‚Äôd use the \xs -> ‚Ä¶ <$ ‚Ä¶ form, though.)
13:13:57 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
13:14:37 <elliott> ion: glorious
13:14:59 <Younder> No where but Haskell would something obvious be percieved as 'beating' the language.
13:15:16 <Younder> sigh
13:15:44 <clsmith> i have a problem where i try to work out what classes everything is an instance of. so in conversations about the ogg format i have to suppress the urge to exclaim "ogg's a monad!"
13:16:07 <Phlogistique> Seems like nobody wrote a Haskell wrapper for Oniguruma
13:16:48 <elliott> Younder: ?
13:16:55 <Phlogistique> on the wiki, it is written that
13:16:57 <Botje> clsmith: it's definitely a Functor :)
13:16:59 <Phlogistique> "This wraps the pcre c-library from http://www.pcre.org and gives all the Perl regular expression syntax you might want. This is especially efficient with Data.ByteString."
13:17:09 <clsmith> Botje: it's both! :D
13:17:12 <Younder> elliott, <dafis> > let chunk k = unfoldr (\xs -> if null xs then Nothing else Just (splitAt k xs)) in chunk 3 [1 .. 20]
13:17:18 <elliott> Younder: What about it?
13:17:21 <elliott> Looks obvious to me.
13:17:21 <Phlogistique> about regex-pcre. What does "especially efficient" mean? Is there a problem using it with String?
13:17:30 <Botje> clsmith: you're aware that OGG is a container format, and vorbis/theora are the audio/video codecs? :P
13:17:38 <elliott> Phlogistique: probably it has to be encoded and packed and the like to use it on Strings
13:18:01 <clsmith> Botje: yep. which is why it's instance Monad (Ogg a)
13:18:04 <cin> with the FFI is possible to pass a uint32_t from haskell to c and what type should be used?
13:18:06 <Younder> elliott, <ion> > unfoldr ((<$) <$> splitAt 3 <*> guard . not . null) [1..20]  -- Obfuscated enough? :-P (Iíd use the \xs -> Ö <$ Ö form, though.)
13:18:17 <elliott> Younder: What about it?
13:18:22 <Botje> Phlogistique: Strings are linked lists of characters, whereas bytestrings are arrays of chars.
13:18:24 <elliott> It's harmless fun.
13:18:42 <clsmith> s/chars/bytes/ >.> otherwise it's very confusing
13:18:45 <cin> i tried Word32 first, then CUInt, but‚Ä¶ i are not succeed
13:18:52 <Phlogistique> Botje: oh, so there is an expensive conversion done by the wrapper? ok
13:18:55 <elliott> clsmith: s/bytes/octets/
13:19:04 <clsmith> elliott: haha, fair point
13:19:12 <elliott> :-)
13:19:14 <elliott> might be using a Cray
13:19:25 <Younder> elliott, sigh, It is hazardous obfuscating
13:19:39 <elliott> Younder: ion is clearly not suggesting anyone actually use that.
13:19:43 <elliott> It's harmless fun, like code golf.
13:19:47 <ion> Perhaps ByteString should use Word9 on certain hardware. ;-)
13:20:02 <elliott> The (\xs -> splitAt 3 xs <$ (guard . not . null) xs) form is pretty readable, anyway.
13:20:08 <clsmith> elliott: if you are, i suspect bytestrings elements would be non-octets too
13:20:13 <clsmith> (it's not an octetstring!)
13:20:16 <elliott> clsmith: heh
13:21:00 <Younder> elliott, You are right. I am just being cranky.
13:21:08 <elliott> :-)
13:25:09 <Phlogistique> http://www.tom.sfc.keio.ac.jp/~sakai/d/?date=20050209 wow, I'm not the only one who thought of Oniguruma for Haskell regexps
13:27:21 * hackagebot cryptohash 0.7.4 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.4 (VincentHanquez)
13:38:21 <thoughtpolice> preflex: seen edwardk
13:38:22 <preflex>  edwardk was last seen on #haskell 2 days, 14 hours, 58 minutes and 56 seconds ago, saying: ivanm: without it you can write all sorts of crazy cool things, with it, it takes a lot less code to write the smaller set of things we _can_ write (for the most part, there are notable exceptions)
13:38:29 <szerf> i want to ask for a function that read(write) file in a non lazy mode
13:38:41 <kmc> did anyone happen to figure out my weird performance puzzle while i was out?
13:38:54 <szerf> i have source exhausted message
13:43:08 <dafis> kmc: if you try the benchmark on a larger Seq, you'll see that foldr and split 1 get pretty large STACK allocations, so, I'd say those deep call trees they build just take so much longer to evaluate (the amount of STACK allocation neatly gets smaller when the split parameter increases)
13:43:43 <chrisdone> i have a vector of ints from C (of type uint16_t*), or Ptr Word16. probably i'll have to peekElemOff to extract the contents, but into what haskell data structure?
13:43:53 <chrisdone> vector, uvector both look ok
13:43:55 <dafis> kmc: say 100,000 or 200,000 to get a clear picture
13:44:14 <dafis> chrisdone: Word16?
13:44:24 <chrisdone> dafis: yup
13:44:40 <Feuerbach> szerf: writeFile is strict. For readFile, you can use this http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html or just force the string yourself
13:44:50 <chrisdone> dafis: why do you ask?
13:45:20 <dafis> chrisdone: sorry, misread your question
13:45:21 <kmc> ok
13:45:29 <luite> uvector is deprecated afaik
13:45:30 <kmc> dafis, you'd see this in -hT ?
13:45:44 <copumpkin> byorgey: will the autolifting of types to kinds also allow pattern matching on types (if you declare the need to do that), like SHE does? say I have a typelist and I want to case on whether the list is empty. I could write a typeclass to typecase, but SHE does that for me
13:45:51 <dafis> kmc: yes
13:45:51 <szerf> thanks but what do you mean by force the string ?
13:45:56 <kmc> chrisdone, you can convert it to a Vector.Storable without any copy
13:46:06 <dafis> kmc: at least, that's what I saw here
13:46:24 <kmc> ok, i'll take a look
13:46:24 <kmc> thanks
13:46:30 <chrisdone> kmc: awesome! i had that package open in a tab but didn't yet see how to convert
13:47:00 <Feuerbach> szerf: e.g. using http://hackage.haskell.org/packages/archive/deepseq/latest/doc/html/Control-DeepSeq.html#v:deepseq
13:47:01 <chrisdone> kmc: uh, do you know how off the top of your head?
13:47:07 <dafis> kmc: by the way, for the large Seqs, seqDirect is much faster than fold
13:47:12 <kmc> chrisdone, look at unsafeFromForeignPtr
13:48:08 <cheater> sometimes i think "unsafe" is a verb
13:48:19 <cheater> which means "remove from safe"
13:48:21 <szerf> thanks very much
13:48:27 <kmc> dafis, I don't see anything labeled STACK in -hT
13:48:49 <dafis> kmc: what Seq size, which ghc?
13:49:05 <kmc> 100,000 elements
13:49:11 <kmc> GHC 7.0.4
13:49:23 <chrisdone> kmc: cheers!
13:49:42 <dafis> kmc: Okay, I used 7.2.1, perhaps that's the difference, let me try out 7.0.4
13:50:04 <kmc> containers-0.4.0.0
13:53:20 <dafis> kmc: yeah, different picture. Not too different, though, if you hp2ps -c -d, the jagged TSO peaks between the ARR_WORDS blocks
13:53:48 <kmc> ah, TSO includes the stack?
13:54:40 <DanBurton> what is the "world" file inside of the ".cabal" directory?
13:54:56 <dafis> kmc: suppose so. each TSO used to carry a complete stack around with it, the organisation has been changed, apparently between 7.0.4 and 7.2
13:55:01 <dcoutts> DanBurton: it's to keep track of which packages you asked to install
13:55:10 <dcoutts> DanBurton: to support the "cabal install world" feature
13:56:03 <DanBurton> dcoutts: cool, thanks
13:56:34 <kmc> ok
13:56:36 <kmc> i see the spikes now
13:56:53 <kmc> and F.foldl' (+) 0 doesn't have one
13:57:05 <kmc> and it's significantly faster than foldr on the larger input
13:57:12 <kmc> but divide and conquer is faster still
14:00:25 <rferranti> straight from twitter: Richard Gabriel - "things like type systems are there to help losers lose less"
14:00:51 <kmc> you're trolling by proxy
14:00:53 <kmc> please don't
14:01:18 <rferranti> lol, i'm not of the same opinion
14:01:24 <blackdog> kmc: let's you and him fight.
14:01:27 <kmc> it doesn't matter
14:03:14 <elliott> kmc: it read as self-deprecating to me, not a bash on type systems
14:03:15 <blackdog> rferranti: what's his handle, OOC?
14:03:16 <elliott> but you never know with lispers :p
14:03:54 <companion_cube> does he mean that compilers are losers ?
14:05:54 <rferranti> blackdog, handle?
14:06:22 <ddarius> blackdog: You're too leet for him.
14:07:05 <blackdog> rferranti: richard gabriel on twitter? does he have an account?
14:07:14 <blackdog> or is he just getting quoted by admiring fanboys?
14:07:35 <kmc> it doesn't matter who said it or why or whether you agree
14:07:37 <rferranti> blackdog, i don't think so, it was ron jeffries quoting
14:07:47 <kmc> there is no reason to relay such a quote to #haskell except to get people riled up
14:07:53 <companion_cube> i hope he writes perl
14:08:06 <copumpkin> I'm with kmc
14:08:25 <chrisdone> kmc: woot, I am officially reading depth perception data from my new Kinect with Haskell xD
14:08:28 <osfameron> Richard Gabriel trolling? say it ain't so ;-)
14:08:29 <kmc> nice!!
14:08:34 <kmc> chrisdone, library forthcoming? ;)
14:08:37 <chrisdone> https://github.com/chrisdone/freenect
14:08:39 <osfameron> isn't he the king of devil's advocates?
14:08:39 <geheimdienst> chrisdone++
14:08:44 <chrisdone> in the works! :)
14:08:44 <hpc> awesome
14:08:47 <osfameron> i.e. arguing against his own Worse is Better and so on
14:10:18 <osfameron> oh, an entirely unrelated Richard (non-P) Gabriel, sorry
14:10:19 <hpaste> charly pasted ‚ÄúisPrime‚Äù at http://hpaste.org/53034
14:10:53 <charly__> hi anybody knows why my code is not working correctly? im new to haskell
14:11:00 <chrisdone> alright, bed time. thanks for the tip kmc, saved me some time
14:11:40 <dafis> charly__: in which way is it not working correctly?
14:12:03 <charly__> i always get n-1 as result
14:12:17 <Ptival> charly__: don't you want to return a Bool? :)
14:12:36 <dafis> charly__: oh, you need parens around the (n-1)
14:13:55 <dafis> charly__: but, just to remove the worst inefficiency, the largest divisor of n (> 1) - except itself - can be at most (n `div` 2)
14:14:11 <charly__> hey thanks it works.
14:14:16 <charly__> yes i modiefied the programm
14:14:20 <charly__> i know that ;)
14:14:45 <dafis> charly__: however, start at 2 and stop at the square root is still less inefficient
14:15:34 <charly__> dafis, yes. i already have written a root function :)
14:15:55 <dafis> charly__: good
14:16:26 <charly__> thanks for helping me!
14:16:32 <dafis> welcome
14:22:06 <kmc> okay i've posted my question to stack overflow as well :)
14:23:19 <copumpkin> what question was that?
14:23:46 <kmc> http://stackoverflow.com/questions/7869359/why-is-it-faster-to-sum-a-data-sequence-by-divide-and-conquer-even-with-no-para
14:24:29 <kmc> dafis said some things that made sense, but it's a big enough puzzle that I want to see what others say :)
14:25:06 <hpc> maybe CPU pipelining has something to do with it
14:26:47 <kmc> do you have a more specific explanation regarding pipelining?
14:27:33 <ddarius> kmc: What do you use seqFoldr rather than seqFoldl' in seqSplit?
14:27:34 <hpc> just that it can do a + b, and c + d at the same time
14:27:52 <ddarius> s/What/Why/
14:28:00 <kmc> ddarius, because seqFoldr was the fastest non-splitting one, on the smaller test cases I was using initially
14:28:00 <monochrom> hyperthreading cpu?
14:28:02 <kmc> (length 10,000)
14:28:30 <kmc> monochrom, no.  AMD Phenum II X6 1075T
14:28:39 <kmc> 6-core, but I'm not using the threaded RTS in this test
14:34:55 <hpaste> DanBurton pasted ‚Äúerror configuring ghc 7.2.1 generic linux tarball package‚Äù at http://hpaste.org/53035
14:35:02 <ddarius> kmc: Then it seems the question is why is seqFoldr fast on small lists.
14:36:23 <ddarius> Also there should be a n for which the performance starts getting worse again.
14:36:31 <kmc> but even on the large sequences, divide-and-conquer is faster than both foldr and foldl'
14:36:40 <ddarius> An n=10000 run would make sense.
14:40:40 <dmwit> kmc: I just saw that question. Very puzzling.
14:44:20 <DanBurton> any clues on how I could fix this error trying to install ghc? "wrong ELF class: ELFCLASS64"
14:44:56 <dmwit> Looks like you're trying to use some binary that was built for x86_64 on a non-x86_64 machine.
14:45:55 <DanBurton> Though the situation is actually the opposite; my machine is x86_64 but I have a 32-bit ubuntu installed
14:46:15 <DanBurton> and it's the i386 distribution of ghc
14:47:26 <rwbarton> maybe it's trying to load a 64-bit library?
14:48:01 <dafis> DanBurton: file libgmp.so.3 ?
14:48:36 <DanBurton> dafis: yeah, I have no idea what that is, but that's the error
14:49:00 <dafis> DanBurton: I meant, check with file, whether it agrees with ghc
14:49:14 <DanBurton> dafis: where might I find it?
14:49:35 <dafis> file or libgmp?
14:50:09 <DanBurton> oh I see what you meant
14:50:21 <dafis> normally, libgmp.so.* would live in /usr/lib
14:50:40 <DanBurton> libgmp.so.3: symbolic link to `libgmp.so.3.5.2'
14:51:00 <dafis> okay, and what thinks file of that?
14:51:03 <DanBurton> libgmp.so.3.5.2: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, stripped
14:51:11 <dafis> ah-hah
14:51:13 <DanBurton> odd
14:51:19 <dafis> very
14:51:30 <DanBurton> so how do I get the 32-bit version? o_O
14:51:50 <rwbarton> well the real question is how you got the 64-bit version
14:51:54 <DanBurton> aye..
14:51:55 <dafis> ubuntu uses apt, doesn't it?
14:52:00 <DanBurton> yeah
14:52:25 <rwbarton> what does 'uname -a' report?
14:52:41 <DanBurton> Linux dan-ubuntu-laptop 3.0.0-13-generic #21-Ubuntu SMP Mon Oct 17 20:18:51 UTC 2011 x86_64 x86_64 x86_64 GNU/Linux
14:52:48 <rwbarton> Well, there's your problem
14:52:58 <DanBurton> so...it is a 64-bit ubuntu?
14:53:01 <rwbarton> Yes
14:53:02 <dafis> yes
14:53:07 <DanBurton> sigh
14:53:10 <DanBurton> figures
14:53:35 <rwbarton> You can probably get the 32-bit version of libgmp, and convince the 32-bit version of ghc to use it
14:53:56 <rwbarton> Or just install the 64-bit ghc
14:53:57 <dafis> or he could just install the 64-bit version of ghc
14:55:06 <DanBurton> So I in fact downloaded that distribution earlier as well. When I run ./configure on *that* one, I get:
14:55:18 <DanBurton> ./configure: line 1847: ghc/stage2/build/tmp/ghc-stage2: No such file or directory
14:55:18 <DanBurton> Can't work out build platform
14:56:26 <kmc> apt-get install ia32-libs
14:56:26 <kmc> (may or may not have the right ones)
14:56:44 <rwbarton> surely this should not be necessary for getting the 64-bit ghc to work, though
14:56:45 <kmc> DanBurton, source or binary ghc distribution?
14:57:08 <DanBurton> kmc: binary
14:57:25 <rwbarton> did you run out of disk space while extracting it perhaps?
14:57:59 <DanBurton> I...don't think so
14:59:32 <kmc> DanBurton, what's the end goal? 32-bit or 64-bit GHC?
14:59:44 <DanBurton> kmc: 64-bit I guess
15:00:45 <sadgur> hi, wonder if you could help me out, I have a list of lists and trying to eliminate any list which is a subset of another, aslong as the length of the sublist is greater than 2
15:00:57 <kmc> :t isInfixOf
15:00:58 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
15:01:01 <sadgur> i have the means to do this just need to do it efficently as possible
15:02:09 <rostayob> kmc: isInfixOf doesn't do what he wants, I think
15:02:36 <rostayob> > isInfixOf [1,2,3] [4,3,2,1]
15:02:36 <lambdabot>   False
15:02:57 <kmc> ah
15:03:08 <rostayob> > any $ map (isInfixOf [1,2,3]) (perm [4,3,2,1])
15:03:09 <lambdabot>   Not in scope: `perm'
15:03:09 <kmc> sadgur, I'd suggest converting them all to Data.Set first
15:03:19 <kmc> "as efficiently as possible" is rarely the single overriding goal
15:03:22 <sadgur> right then i can test for subsets
15:03:24 <sadgur> this is fine
15:03:28 <kmc> otherwise we would fabricate custom silicon for every problem
15:03:32 <rostayob> > any $ map (isInfixOf [1,2,3]) (permutations [4,3,2,1])
15:03:33 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
15:03:33 <lambdabot>         against inferred ...
15:04:05 <kmc> usually there is a tradeoff between efficiency, ease of implementation, and correctness
15:04:13 <kmc> and it's important to be clear about where you are on that tradeoff
15:04:16 <sadgur> my sets are likely to contain many subsets of each other
15:04:22 <sadgur> right i understand this
15:04:24 <kmc> as Haskell provides many increasingly difficult ways to get extra performance
15:04:29 <kmc> how big are the sets, and how many?
15:04:55 <rostayob> > any (isInfixOf [1,2,3]) (permutations [4,3,2,1])
15:04:56 <lambdabot>   True
15:04:58 <sadgur> well really depends on the input but some sets are exponentially sized based on input
15:05:22 <rostayob> > let subset x1 x2 = any (isInfixOf x1) (permutations x2)
15:05:23 <lambdabot>   not an expression: `let subset x1 x2 = any (isInfixOf x1) (permutations x2)'
15:05:31 <kmc> sadgur, but how big actually?
15:05:32 <rostayob> > let subset x1 x2 = any (isInfixOf x1) (permutations x2) in subset [1,2,3] [5,4,3,2,1]
15:05:33 <lambdabot>   True
15:05:45 <sadgur> ok theoretically i am working with small values
15:05:46 <kmc> i mean, do you have an input size in mind? and how big would they be given that input
15:05:50 <rostayob> anwyay yeah you're better of converting all of them to Set
15:06:23 <sadgur> well I am working with propostional formulae which the set is infinite however a fairly efficent working implementation is fine
15:06:30 <sadgur> ofc this doesn't help you
15:06:44 <sadgur> fairly efficent is fine, most cases will be reasonbly small
15:06:47 <sadgur> the set of 200 or so
15:07:39 <sadgur> with this in mind the best solution would be conversion to a set ?
15:07:59 <kmc> yeah, I would start by converting them all to a Data.Set
15:08:02 <sadgur> a list of sets or a set of sets?
15:08:11 <sadgur> if this even possible
15:08:11 <kmc> probably a list
15:08:17 <sadgur> i alright
15:08:28 <kmc> you need to scan through *all* the sets when adding a new one
15:08:37 <sadgur> well they are all generated
15:08:38 <kmc> which means a list is basically what you want
15:08:45 <sadgur> i just want to remove the ones that are subsets of each other
15:08:58 <kmc> and that's quadratic time, but may be fast enough
15:08:59 <rwbarton> just sorting them all might be a little better
15:09:01 <sadgur> so filter or something of this nature
15:09:14 <sadgur> I think if i start with the biggest set
15:09:18 <sadgur> and remove all subsets of this
15:09:20 <rostayob> sadgur: you can sort all the lists and then use isInfixOf
15:09:29 <rwbarton> still not isInfixOf
15:09:37 <rwbarton> but some kind of merge-like function
15:09:41 <rostayob> why not?
15:09:42 <kmc> what's the actual combinatorial problem here, I wonder
15:09:51 <rwbarton> [1,2,4] is a subset of [1,2,3,4,5
15:09:52 <rwbarton> ]
15:09:56 <sadgur> would an example of my data help?
15:09:57 <rostayob> ah right
15:10:28 <rwbarton> Which is good, since you can do the merge algorithm in linear time
15:10:32 <rostayob> if it's just 200 elements you're probably ok with whatever solution
15:10:51 <kmc> also there is no unique answer, right?
15:10:53 <rostayob> which is not completely stupid :P
15:10:55 <sadgur> yes indeed but theoretically i'd like it to be efficent since the output can be exponential in relation to the input
15:11:10 <sadgur> but any decent solution is fine
15:11:16 <sadgur> it's just a prototype implementation
15:11:20 <kmc> don't chase after theoretical exponentials which are practically under 200
15:11:45 <sadgur> kmc: you have a fair point, ok a decent solution is fine
15:11:55 <rostayob> then convert them all to sets, and then start inserting the bigger one
15:12:08 <kmc> there's not a unique answer, is there?
15:12:10 <sadgur> assume i have a way of detecting subsets, which is the best way of removing all subsets, filter?
15:12:10 <rostayob> *biggest
15:12:19 <rwbarton> why isn't there a unique answer
15:12:24 <mmos1127> it looks to me like Control.Monad.State and some of the other monads were removed from the standard library. Is this true? and why?
15:12:36 <kmc> mmos1127, they're in the 'mtl' package, same as ever
15:12:48 <rostayob> mmos1127: State is not in the standard library
15:12:57 <rostayob> well is not in the reposrt
15:12:58 <rwbarton> It's going to be all the sets which are not a proper subset of one of the original lists
15:12:59 <rostayob> *report
15:13:03 <kmc> rwbarton, because the predicate "is a subset of any set I've picked so far" depends on which sets you've picked so far
15:13:15 <MatrixFrog> mmos1127: maybe you mean, it's not in the Prelude
15:13:24 <elliott> MatrixFrog: it never was
15:13:27 <rostayob> MatrixFrog: they've never been in the prelude
15:13:28 <kmc> hmm okay
15:13:30 <rwbarton> it doesn't actually though, since I throw out the smaller list
15:13:31 <mmos1127> hmm, what's confusing is that in earlier versions of the Haskell platform, Control.Monad.State is part of the docs that come with it---is that because mtl comes with the Haskell Platform?
15:13:43 <rostayob> mmos1127: yes
15:13:44 <kmc> mtl comes with Platform and always has, afaik
15:14:02 <mmos1127> okay ignore me-- I just am not paying enough attention
15:14:04 <MatrixFrog> mmos1127: it's safe to assume that any haskell distribution will have the Control.Monad.State package available, so you can use it. you just need to import it
15:14:04 <rostayob> mmos1127: http://www.haskell.org/ghc/docs/latest/html/libraries/
15:14:09 <kmc> the recent-ish change is that mtl version 2 shares more code with the 'transformers' package
15:14:16 <rostayob> those are the ghc libraries
15:15:01 <engla> what's the difference between mtl and transformers?
15:15:03 <rostayob> and this is the platform http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html
15:15:04 <sadgur> thanks for you help again i will have a whack at some implmentation
15:15:34 <rostayob> I think that mtl defines class with fundeps?
15:15:42 <kmc> yes
15:15:49 <mmos1127> I've been reading a bit about fundeps-- so mtl absolutely requires fundeps to get the job done?
15:15:56 <rostayob> while transformers doesn't, you have to lift manually
15:15:57 <kmc> and mtl has the duplication between State and StateT
15:16:08 <dafis_> no more
15:16:11 <kmc> whereas in 'transformers', State s is just a synonym for StateT s Identity
15:16:13 <kmc> right, it had
15:16:15 <rostayob> duplication? type State s a = StateT s Identity a
15:16:16 <kmc> in mtl-1
15:16:18 <rostayob> ah
15:16:19 <kmc> sorry
15:16:29 <Draconx> wasn't mtl-1 H98?
15:16:33 <kmc> no
15:16:34 <rostayob> Draconx: no
15:16:46 <kmc> the fundeps come into play when you want classes like MonadState which work for "all State monads"
15:16:56 <kmc> cause you need a type parameter to say what the state is, and another to say what the monad is
15:17:07 <kmc> you don't need them for the monads and transformers themselves
15:17:08 <mmos1127> what's going on with fundeps and the standard? have they been incorporated into the standard?
15:17:12 <kmc> nope
15:17:12 <rostayob> mmos1127: no
15:17:20 <kmc> don't expect it to happen any time soon either
15:17:34 <rostayob> no language extension is in the standard afaik
15:17:40 <rostayob> otherwise it wouldn't be an extension
15:17:41 <kmc> tautological O_O
15:17:42 * shachaf declares "the standard" to mean "GHC".
15:17:48 <dafis> Hierachical modules
15:17:48 <rostayob> here we go
15:17:50 <JoeyA> shachaf++
15:17:53 <rwbarton> some Haskell 98 extensions are in the 2010 Report though
15:17:56 <kmc> there are GHC extensions to H98 which were included in H10 by name
15:17:58 <kmc> right
15:18:13 <kmc> in recent GHC you can replace fundeps with associated types and superclass equality constraints
15:18:19 <monochrom> doifthenelse, pattern guards
15:18:25 <JoeyA> I wonder: if GCC would have been released under a liberal license, would it be the de facto standard for C like GHC is for Haskell?
15:18:26 <kmc> which puts into doubt the wisdom of standardizing fundeps
15:18:33 <monochrom> actually, FFI too
15:18:39 <kmc> they'd still be useful sugar for the other thing, though
15:19:00 <rostayob> wasn't FFI in haskell98 as well?
15:19:04 <blackdog> JoeyA: I think it's got a different goal to the other C compilers - it has to run on anything anywhere, where ICC etc just need to be crazy fast
15:19:22 <blackdog> optimised for running benchmarks:)
15:19:51 <fazzone> JoeyA: Are you saying there isn't a de-facto standard for C?  because I can't think what it would be besides gcc
15:20:00 <rostayob> fazzone: ICC, clang?
15:20:05 <Draconx> JoeyA, C has almost 40 years of history with competing implementations pretty practically since day 1.
15:20:05 <JoeyA> fazzone: Visual C++?
15:20:11 <monochrom> FFI had one foot in 98 and another outside. GHC 6.x made you add {-# LANGUAGE ForeignFunctionInterface #-} for it, otherwise it would say "wtf is foreign import?"
15:20:11 <kmc> FFI was a ratified addendum to the H98 standard
15:20:16 <Draconx> s/practically //
15:20:29 <kmc> there are *tons* of C compilers.  don't forget that most CPUs in the world are embedded things
15:20:32 <Draconx> er, and s/pretty/pretty much/ :(
15:20:56 <rostayob> let's not forget about this http://bellard.org/otcc/otcc.c
15:21:01 <JoeyA> If GCC were the de facto standard for C, then why do people rarely rely on GCC's nested function support [citation needed]?
15:21:11 <Phlogistique> kmc: a lot of them suck very, very hard though
15:21:15 <kmc> becuase it's not very useful JoeyA
15:21:19 <fazzone> rostayob, JoeyA: i'm not saying other C compiles don't exist, I'm just saying that if you were to relax the definition of 'de-facto standard' enough so that there was a de-facto standard C compiler, it'd probably be GCC
15:21:29 <kmc> everything uses gcc and x86, in the same way that all computers run windows
15:21:34 <Yarou> gcc isn't the de facto standard, iirc it's ANSI C99
15:21:36 <kmc> i.e. all the computers you see, which is almost none of them
15:21:42 <rostayob> on the other hand, apple relies on blocks ehe
15:21:56 <JoeyA> kmc: I suppose so.  One can't implement map in C because of the lack of type polymorphism, not just the lack of lambdas.
15:22:08 <kmc> "lambdas" are just syntax
15:22:08 <rostayob> JoeyA: you can implement map in C
15:22:25 <kmc> the problem is that there are no closures; you can't return a function from a function if it has free variables
15:22:36 <kmc> this wrecks a lot of FP
15:22:37 <JoeyA> True, but it's ugly, but it's not as applicable as Haskell's map.
15:22:45 <rostayob> JoeyA: well ok, but you totally can
15:22:48 * monochrom prefers implementing a Haskell RTS in C, then just use Haskell :)
15:23:09 <JoeyA> You can't write a void **map(void **objs, ... ugly function syntax ...); and expect people to use it in lieu of a for loop
15:23:14 <rostayob> i mean higher order functions in C are widely useful
15:23:23 <rostayob> *used
15:23:36 <kmc> ICC produces bad code for amd processors on purpose
15:23:38 <rostayob> JoeyA: well but you can expect people to use qsort
15:23:46 <JoeyA> Enough of this off-topic banter.  I came online to ask this: what's a good Halloween costume for a Haskell programmer?
15:23:51 <kmc> basically it assumes that every AMD processor is an original 386 even though they've all supported SSE2 etc. for ages
15:23:58 <blackdog> JoeyA: monad burrito
15:24:01 <JoeyA> lol
15:24:04 <KitB> JoeyA: Lambdaman
15:24:08 <rostayob> deforestation
15:24:13 <monochrom> SPJ mask
15:24:18 <blackdog> rostayob: wow, you're a downer.
15:24:21 <rostayob> ahah
15:24:30 <JoeyA> Does SPJ have Chuck Norris status in the Haskell world?
15:24:33 <mmos1127> if I want to make data useful with "show", what class does it need to be an instance of?
15:24:41 <KitB> (Phil Wadler has a lambdaman costume)
15:24:42 <kmc> Show
15:24:42 <rostayob> JoeyA: it's contended with oleg
15:24:43 <JoeyA> :t show
15:24:44 <lambdabot> forall a. (Show a) => a -> String
15:24:44 <monochrom> no, Oleg has Chuck Norris status
15:24:50 <monochrom> @quote oleg
15:24:51 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
15:24:58 <monochrom> @oleg
15:24:59 <rostayob> ahahah
15:24:59 <lambdabot>  Defined.
15:25:02 <mmos1127> got it that's easy to remender
15:25:09 <rostayob> @quote oleg
15:25:09 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
15:25:11 <monochrom> interesting, oleg -> let
15:25:20 <monochrom> @quote oleg.*type
15:25:20 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
15:25:39 <hascoooo> What does "(Ord t)" mean ??
15:25:42 <DanBurton> monochrom: I'm so using that from now on
15:25:46 <hascoooo> it's used in a definition of a function
15:25:52 <monochrom> well, there are a couple of "oleg can do ____ in the type system!"
15:25:55 <kmc> hascoooo, a constraint saying that the type t must be a member of the Ord type class
15:25:56 <hascoooo> foo :: (Ord t) => [t] -> [t]
15:25:59 <JoeyA> Just wondering, does SPJ come on IRC much?
15:26:02 <rostayob> hascoooo: on it's own, not much. Ord t => t. puts a constraint on t
15:26:04 <DanBurton> @oleg myFix f = let x = f x in x
15:26:05 <lambdabot>  Defined.
15:26:07 <rostayob> so t has to be an instance of Ord
15:26:11 <kmc> hascoooo, we're not going to be able to explain type classes in a few lines of text, so you should probably read a Haskell tutorial regarding them
15:26:28 <JoeyA> "<rostayob> JoeyA: well but you can expect people to use qsort" Ah, true.
15:26:37 <hascoooo> where to lookup the Ord class ?
15:26:38 <JoeyA> T'is a shame it doesn't take a context argument.
15:26:49 <rostayob> hascoooo: :info Ord on ghci
15:26:52 <JoeyA> Or http://haskell.org/hoogle/
15:27:04 <JoeyA> http://haskell.org/hoogle/?hoogle=Ord
15:27:14 * DanBurton crosses his fingers. just did sudo make install on ghc-7.2.1 64 bit and it looks like it is working :)
15:27:19 <rostayob> or hayoo. we like jokes in haskell land.
15:27:28 <hascoooo> aaaaah.... wow
15:27:30 <hascoooo> thanks !!!!!!
15:28:04 <monochrom> "how to make purely functional associative maps without Eq being Ord"
15:28:05 <kmc> no, you can't expect C programmers to use qsort and bsearch
15:28:14 <kmc> they will often reimplement these, with bugs
15:28:14 <rostayob> kmc: well, they do
15:28:24 <rostayob> you've met bad C programmers ehe
15:28:29 <kmc> the Linux kernel alone contains dozens of implementations of each
15:28:43 <kmc> it's not just bad programmers; that's the norm in C
15:28:50 <kmc> reimplement algorithms and datastructures yourself
15:29:05 <rostayob> well that's not *always* a bad idea
15:29:23 <kmc> this is one reason why C favors hash tables... easier to write an okay hash table than an okay tree associative structure
15:29:23 <ddarius> @quote olegfacts
15:29:24 <lambdabot> No quotes match. I've seen penguins that can type better than that.
15:29:33 <kmc> even if a *good* tree structure is what you really need
15:29:40 <rostayob> kmc: it's easier to write a broken hash table you mean
15:29:44 <kmc> that too
15:29:47 <monochrom> @olegfact
15:29:47 <lambdabot> Unknown command, try @list
15:29:51 <ddarius> Type classes = type level relations
15:30:00 <monochrom> @quote olegfact
15:30:01 <lambdabot> No quotes match. I am sorry.
15:30:02 <kmc> it's easy to write a hashtable which is mostly safe to use concurrently and only crashes once every few years, at the worst possible time
15:30:03 <tech2> kmc: easier to create a sensible datastore in C for a hashtable of fixed size too.
15:30:19 <ddarius> DanBurton: make install is usually just copying files.
15:30:35 <DanBurton> ddarius: yeah it finished rather quickly :)
15:31:29 <rostayob> kmc: i have the hobby of replacing all binary searches in C with the really short and cryptic version
15:31:38 <DanBurton> now how do I replace all the old programs like ghc-pkg and ghci with their newer counterparts?
15:31:40 <rostayob> the one from programming pearls
15:32:50 <silvio_> hello can some one explain to me why yi is the most recursive acrynom? in "Y I is the most recursive acronym. (Read it as combinators)."
15:32:58 <JoeyA> > fix id
15:33:01 <lambdabot>   mueval-core: Time limit exceeded
15:33:19 <JoeyA> > fix (\x -> id x)
15:33:19 <rostayob> Y = fixed point combinator, I = identity
15:33:23 <lambdabot>   mueval-core: Time limit exceeded
15:33:29 <rostayob> :t fix (\x -> x)
15:33:31 <lambdabot> forall a. a
15:33:34 <rostayob> yo
15:33:42 <silvio_> ok
15:33:45 <JoeyA> > let f x = x in x
15:33:46 <lambdabot>   x
15:33:53 <rostayob> > (fix (\x -> x)) :: Int
15:33:57 <lambdabot>   mueval-core: Time limit exceeded
15:33:59 <rostayob> ehe
15:34:03 <DanBurton> > let y = fix; i = id in y i
15:34:07 <lambdabot>   mueval-core: Time limit exceeded
15:34:08 <JoeyA> > let f x = x in f x
15:34:09 <lambdabot>   x
15:34:13 <kmc> y ‚â† fix
15:34:24 <monochrom> > y == fix
15:34:25 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
15:34:25 <lambdabot>         against inferred ...
15:34:25 <silvio_> is it a standard notation? from where?
15:34:25 <JoeyA> > let f x = f x in f x
15:34:29 <lambdabot>   mueval-core: Time limit exceeded
15:34:40 <kmc> Y and I are standard combinators in the combinatory logic
15:34:58 <kmc> Y is a specific lambda term, not just any fixed point combinator
15:35:04 <kmc> it does not type in Haskell
15:35:16 <byorgey> preflex: seen copumpkin
15:35:16 <preflex>  copumpkin was last seen on #haskell-blah 35 minutes and 47 seconds ago, saying: shachaf: you planning on staying over?
15:35:20 <copumpkin> hi
15:35:26 <rostayob> monochrom, kmc: ok ok
15:35:35 <byorgey> copumpkin: no, currently the lifting doesn't give you typecase
15:35:38 <JoeyA> > let y = \f -> (\x -> f (x x)) (\x -> f (x x)) in y ("Circular reasoning works because " ++)
15:35:39 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
15:35:45 <rostayob> JoeyA: that's an infinite type
15:35:47 <JoeyA> > let y = \f -> unsafeCoerce (\x -> f (x x)) (\x -> f (x x)) in y ("Circular reasoning works because " ++)
15:35:48 <byorgey> copumpkin: but that's on the list of things we're thinking about/want to add
15:35:48 <lambdabot>   Not in scope: `unsafeCoerce'
15:35:49 <rostayob> you can't type Y
15:35:52 <JoeyA> right
15:36:09 <JoeyA> (that'll work if you throw in enough unsafeCoerce)
15:36:13 <rostayob> you can write fix in haskell with pattern matching basically
15:36:34 <silvio_> ok thanks every one
15:36:47 <monochrom> you write fix in Haskell by using Haskell's recursion-enabled let
15:36:59 <JoeyA> > let fix f = f (fix f) in fix ("Circular reasoning works because " ++)
15:37:00 <lambdabot>   "Circular reasoning works because Circular reasoning works because Circular...
15:37:04 <rostayob> fix f = f (fix f), no let
15:37:12 <monochrom> or recursion-enabled "data", or recursion-enabled "newtype"
15:37:14 <rostayob> yeah
15:37:17 <rostayob> it's not just let
15:37:24 <JoeyA> :t fix
15:37:25 <lambdabot> forall a. (a -> a) -> a
15:37:31 <JoeyA> fix's type signature is interesting.
15:37:37 <rostayob> it is indeed ehehe
15:37:42 <JoeyA> The logical counterpart is: If A says that A is true, then A is true.
15:38:13 <monochrom> well, "fix f = f (fix f)" is inside an implicit "module X where" which is like "let" and which is also recursion-enabled.
15:38:27 <byorgey> I think "says that" is a bit misleading.  More like "if you can prove A, given A, then you can prove A".
15:38:48 <Phlogistique> hi
15:39:01 <Phlogistique> I can't seem to find the most up to date doc about regexes in Haskell
15:39:10 <Phlogistique> Real World Haskell is broken
15:39:26 <Phlogistique> http://hackage.haskell.org/packages/archive/regex-base/0.93.2/doc/html/Text-Regex-Base-Context.html this says XXX THIS HADDOCK DOCUMENTATION IS OUT OF DATE XXX
15:39:33 <rostayob> monochrom: yeah, but it's simply the fact that you have general recursion that enables you to write fix
15:40:06 <rostayob> when they first told me "you can write fix in haskell because of let" i didn't understand what they were talking about :P
15:40:09 <monochrom> now enter ocaml, in which "let" is not recursion-enabled
15:40:17 <rostayob> let rec
15:40:41 <monochrom> yes, you have to add "rec" for that
15:40:48 <rostayob> i always found that silly
15:41:20 <monochrom> not silly because ocaml's "let" is meant to be haskell's do-notation
15:41:48 <rostayob> monochrom: to be honest, i don't know much about OCaml. Can't you sequence in let rec/
15:41:50 <rostayob> ?
15:42:12 <monochrom> can. but then that's haskell's do-rec-notation (mfix)
15:42:51 <rostayob> oh, right. it makes sense i guess.
15:43:16 <monochrom> so the motivation is that people want to write "x <- f x" instead of "x' <- f x" because in general you lose track of how many primes you have to add, especially if you are to delete a few lines in-between later
15:43:20 <JoeyA> > fix fix error
15:43:21 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
15:43:25 <JoeyA> > fix (fix error)
15:43:26 <lambdabot>   Couldn't match expected type `a -> a'
15:43:26 <lambdabot>         against inferred type `[GHC.T...
15:45:16 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg92742.html :)
15:45:56 <rostayob> monochrom: wow, the sound of music + haskell.
15:46:21 <rostayob> what more could you possibly want?
15:46:58 <rostayob> yeah but what's "rec"?
15:47:12 <rostayob> oh. DoRec.
15:47:19 <monochrom> HEE HEE HEE
15:47:39 <rostayob> i want an achievement for each language extension that i discover.
15:51:37 <ddarius> "Achievement Unlocked: You opened a Haskell source file"
15:51:40 <shachaf> @ty let y f = (\x -> outR x x) (InR (\x -> f (outR x x))) in y
15:51:41 <lambdabot> forall a. (a -> a) -> a
15:51:44 <monochrom> hahaha
15:52:02 <rostayob> :k InR
15:52:02 <lambdabot> Not in scope: type constructor or class `InR'
15:52:08 <rostayob> :t InR
15:52:08 <lambdabot> forall a. (Rec a -> a) -> Rec a
15:52:11 <shachaf> @src Rec
15:52:12 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
15:52:29 <rostayob> wat...
15:52:42 <rostayob> so this is closer to Y i guess
15:52:51 <monochrom> Achievement Unlocked: You wrote Y with newtype.
15:52:53 <rostayob> apart from the lack of simmetry
15:53:24 <DanBurton> "Achievement unlocked: You used a Monad Transformer correctly!"
15:53:28 <coppro> haha
15:53:32 <rostayob> is Rec in caleskell?
15:53:38 <rostayob> hoogle doesn't help
15:53:48 <DanBurton> @where hayoo
15:53:48 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:53:56 <sadgur> i have write a function "subsets" which takes a set and a list of sets and returns a list of booleans if there contains a subset, what is the best way to check if any item of the list of sets is a subset of another and remove it
15:53:56 <elliott> <shachaf> @ty let y f = (\x -> outR x x) (InR (\x -> f (outR x x))) in y
15:53:57 <rostayob> hayoo doesn't help
15:54:00 <elliott> shachaf: Isn't that the one that kills GHC's inliner?
15:54:07 <shachaf> elliott: No?
15:54:11 <elliott> Hm.
15:54:13 <shachaf> Not as far as I know.
15:54:26 <shachaf> rostayob: Rec is in L.hs. I guess you could consider that Caleskell.
15:54:57 <DanBurton> any Data.Text maintainers here?
15:55:11 <elliott> shachaf: Here's where I read that: http://r6.ca/blog/20060919T084800Z.html but I guess it's fixed in recent ghc.
15:55:15 <rostayob> schlicht: and where can I find this L.hs?
15:55:47 <shachaf> elliott: Oh, maybe it happens with optimizations?
15:55:56 <rostayob> sorry, that was for shachaf
15:56:01 <monochrom> bos and dcoutts are maintainers of Data.Text
15:56:10 <DanBurton> I want L.hs for my Prelude instead of Prelude
15:56:20 <monochrom> rtharper too
15:56:23 <rostayob> anyway, it makes sense i guess, Rec a is your infinite type
15:56:55 <monochrom> fear leads to anger, anger leads to newtype, newtype leads to Y
15:57:22 <monochrom> Y fighters, too
15:57:40 <shachaf> elliott: Works for me.
15:57:51 <elliott> shachaf: Wasn't the inliner written for 7?
15:57:58 <shachaf> @version
15:57:58 <lambdabot> lambdabot 4.2.2.1
15:57:58 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:58:12 <shachaf> elliott: Well, the "other" inliner bug is still present, as far as I know.
15:58:32 <elliott> s/written/rewritten/
15:58:33 * shachaf doesn't know much about GHC's inliner.
16:00:43 <rostayob> monochrom: anyway what Rec shows is that recursion is broader than rec! eheh
16:00:46 <rostayob> *than let
16:01:24 <shachaf> You're still using a recursive let, it's just in the type system this time. :-)
16:01:42 <rostayob> but why should we call it let at that point :P
16:02:11 <shachaf> Is this just an argument about words?
16:02:43 <rostayob> shachaf: it's not really an argument, it's just that imo the usual answer "you can define fix because of let" is misleading
16:03:41 <shachaf> You can define fix because Haskell supports recursion anyway.
16:03:50 <rostayob> yes that's my point
16:09:48 <DanBurton> is there a command to uninstall a package that you installed via cabal install?
16:09:55 <rostayob> no!
16:10:15 <rostayob> why would you want that? it takes away all the fun
16:10:21 <dafis> sudo rm -rf /
16:10:22 <kmc> ghc-pkg unregister
16:10:23 <kmc> plus rm
16:10:28 <DanBurton> dafis T_T
16:10:37 <kmc> repa question: I have a function (Float -> Array DIM1 Word8) and I want to use it as (Array DIM2 Float -> Array DIM3 Word8)
16:11:07 <kmc> that is, apply the function at each array element, with the indices of the new DIM1 array becoming the last index of the DIM3 array
16:11:20 <kmc> anyone know the right function to use?
16:11:28 * kmc repa noob
16:11:29 <ehamberg> has anyone have problems using ‚Äúcabal sdist‚Äù on mac os x? this is what happens here: http://hpaste.org/53038
16:11:58 <rwbarton> kmc, you can do it with traverse at least
16:12:18 <kmc> looks like traverse can do anything :D
16:12:18 <rwbarton> er... hmm
16:12:22 <rwbarton> perhaps not
16:12:30 <copumpkin> kmc: traverse I think is your best bet
16:12:31 <copumpkin> yeah
16:12:38 <elliott> with repa I just use fromFunction all the time :P
16:12:39 <rwbarton> well, I think you can do it still
16:12:45 <DanBurton> :t traverse
16:12:45 <lambdabot> Not in scope: `traverse'
16:12:56 <DanBurton> boo
16:13:11 <copumpkin> in derpa, I have a more precise type for traverse
16:13:46 <rwbarton> can you describe that more precise type informally?
16:14:01 <rwbarton> I have a little trouble understanding when/why I should use traverse over something like fromFunction
16:14:24 <copumpkin> traverse is fromFunction wrapped up
16:14:34 <elliott> I wish GHC let you somehow construct functions that e.g. pattern match on unboxed integers at runtime... so that you could use (Coords -> Value) as an array type without lookup basically being linear in the number of element replacements done
16:14:38 <rwbarton> oh, ok
16:14:47 <elliott> (because everything looks like "if idx == idx' then v' else f idx")
16:15:00 <elliott> ...a bit of a silly wish admittedly
16:15:48 <copumpkin> traverse : ‚àÄ {n m} {sh : Shape n} {sh' : Shape m} {a b} {A : Set a} {B : Set b} ‚Üí Array sh A ‚Üí ((Index sh ‚Üí A) ‚Üí Index sh' ‚Üí B) ‚Üí Array sh' B
16:15:59 <rostayob> oh god agda
16:16:48 <elliott> copumpkin: I hope you encode size into the shape :-)
16:16:49 * DanBurton needs to learn agda someday
16:16:55 <copumpkin> elliott: of course
16:17:00 <copumpkin> that's kind of the whole point
16:17:06 <elliott> right
16:17:14 <hascoooo> When pattern matching definitions are overlapping, the first definition is taken by ghc ??
16:17:24 <elliott> copumpkin: Does it do the concurrency stuff? :p
16:17:43 <copumpkin> elliott: no, I haven't written the foreign backend for it yet, so it's just implemented inefficiently in agda
16:17:54 <elliott> copumpkin: You mean...
16:17:56 <elliott> copumpkin: Agda...
16:17:57 * ddarius wants to make a thing to make recursive helping simple.
16:17:58 <elliott> copumpkin: Isn't...
16:17:59 <copumpkin> but there are quite a few proofs of it
16:18:00 <elliott> copumpkin: Web scale????
16:18:06 <rostayob> hascoooo: yes
16:18:17 <DanBurton> hascoooo: yeah
16:18:23 <hascoooo> rostayob, DanBurton: And how about that when there are used very complex functions to define with pattern mathching? will ghc recognize this overlapping, too ?
16:18:31 <copumpkin> elliott: guess not
16:18:41 <rostayob> hascoooo: i'm not sure i get what you mean
16:18:42 <elliott> copumpkin: I'll stick to Coq
16:18:47 <rwbarton> hascoooo: there isn't anything to recognize... by the language definition, it just tries to match the patterns in order
16:20:52 <dcoutts> ehamberg: you've compiled cabal-install-0.10 against Cabal-1.12
16:20:53 <hascoooo> rostayob, rwbarton: what if I do this: fib 0 = 0, fib 1 = 1, fib n = fib(n-1) + fib (n-2),    if the 2000000th number of pi is a "2" do fib 2 = 1
16:20:54 <hascoooo> ????
16:21:05 <dylukes> If I have, in the middle of my parser code, a series of case maybeThing of ... (could also be (flip .maybe) maybeThing $ (\...)
16:21:06 <rwbarton> your question mark key seems broken by the way
16:21:11 <dcoutts> ehamberg: either use the older Cabal lib, or use a newer cabal-install
16:21:12 <dylukes> Is there a nice way to clean that up.
16:21:14 <rostayob> hascoooo: what?
16:21:14 <hascoooo> this would overlap if pi has a "2" at 20000th num
16:21:29 <hascoooo> ^^
16:21:29 <rostayob> "if the 200000th numer of pi whatever" is not a valid haskell expression
16:21:38 <hascoooo> yes ...
16:21:43 <ehamberg> dcoutts: oh. thanks!
16:21:45 <rwbarton> the third pattern will match, so the fourth will never be examined
16:21:50 <rwbarton> since 'n' matches everything
16:22:02 <hascoooo> rwbarton: ah... okay
16:22:10 <kmc> is there a shortcut for expressions like (Z :. x :. y)
16:22:16 <rostayob> yeah but you can't express what you want while pattern matching anyway
16:22:24 <ddarius> > last $ showCReal 2000000 pi
16:22:28 <lambdabot>   mueval-core: Time limit exceeded
16:22:37 <kmc> i'd kind of expect like dim2 :: Int -> Int -> DIM2
16:22:58 <rwbarton> kmc, that would be nice since typing Z :. (0 :: Int) :. (0 :: Int) is awful
16:23:11 <copumpkin> I don't think there is :/
16:23:13 <elliott> kmc: the worst part is pattern matching
16:23:19 <elliott> though I guess you could have (undim2 -> (x,y))
16:23:33 <copumpkin> yeah
16:23:35 <kmc> *nod*
16:23:49 <elliott> (undim -> (x,y)) ;; POWER OF TYPECLASSES
16:24:05 <copumpkin> :)
16:24:07 <kmc> bah we need those implicit view patterns
16:24:09 <kmc> (-> (x,y))
16:24:19 <elliott> class Implicit a where x :: a
16:24:56 <ehamberg> dcoutts: ‚Äúcabal list cabal-install‚Äù lists cabal-install 0.10.2, which is the one I have installed.
16:25:12 <ehamberg> ‚ÄúThere is no available version of cabal-install that satisfies >0.10.2‚Äù
16:25:16 <dcoutts> ehamberg: right, but you're using the library Cabal-1.12
16:25:29 <kmc> using 'traverse' for this seems kind of wrong... there's a lot of regular structure I'm hiding
16:25:31 <monochrom> "cabal -v" is more informative
16:25:36 <rostayob> ddarius: last $ showCReal 2000000 pi does take a long time.
16:25:37 <dcoutts> ehamberg: if you want a newer cabal-install you'll have to get the development version
16:25:42 <hascoooo> rwbarton, rostayob:         I can e.g. tell ghc to set fib n = fib (n-1) + fib(n-2) for all odd n, right? So would ghc check for all my further definitions of fib, if an odd number is definied??
16:26:00 * dcoutts has to go
16:26:28 <ddarius> "It's late.  I'm going to bed.  I'll kill you all in the morning."
16:27:12 <rwbarton> hascoooo: I still don't know why you are using so many question marks.
16:27:35 <monochrom> to avoid an odd number of question marks :)
16:27:35 <rwbarton> However, if you write "fib n | odd n = fib (n-1) + fib(n-2)", then in later patterns, you can be sure that if they are reached, that n is not odd
16:28:07 <hascoooo> there are only 3
16:29:04 <DanBurton> Haskell pattern matching is dead simple. It start from the top, and picks the first one it finds that matches.
16:30:26 <DanBurton> @hackage quickcheck
16:30:26 <lambdabot> http://hackage.haskell.org/package/quickcheck
16:30:37 <DanBurton> hm
16:31:04 <DanBurton> @hackaage QuickCheck
16:31:04 <lambdabot> http://hackage.haskell.org/package/QuickCheck
16:31:22 <DanBurton> there we go...stupid case sensitivity. Anyways...
16:31:35 <DanBurton> How does QuickCheck manage to have such extremely liberal dependencies?
16:31:46 <hascoooo> okay, thanks ....
16:32:00 <hascoooo> will come back ;) with lots of question marks
16:32:16 * DanBurton likes question marks
16:32:21 <hpc> DanBurton: presumably because it still builds :P
16:33:34 <DanBurton> hpc: I wish more package dependencies were so easily satisfied
16:33:50 <hpc> indeed
16:36:05 <kmc> and the import list specifier of the day award goes to.... (:.)(..)
16:36:34 <monochrom> hehehe
16:36:39 <dylukes> Is there not a MaybeT in the mtl package or elsewhere?
16:36:46 <dylukes> @hoogle MaybeT
16:36:46 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
16:36:49 <dylukes> :|
16:36:49 <monochrom> not in mtl
16:36:56 <dylukes> where would I find such a thing? :P
16:37:02 <monochrom> I don't know
16:38:09 <elliott> dylukes: its in transformers
16:38:24 <dylukes> @hackage transformers
16:38:24 <lambdabot> http://hackage.haskell.org/package/transformers
16:38:35 <elliott> dylukes: mtl is based on transformers
16:38:38 <elliott> as is monads-tf
16:38:38 <mm_freak> hmm‚Ä¶  i like mzero's google tech talk on haskell‚Ä¶  unfortunately he uses a very complicated function for run-length encoding
16:38:47 <mm_freak> :t map (head &&& length) . group
16:38:48 <lambdabot> forall a. (Eq a) => [a] -> [(a, Int)]
16:38:49 <dylukes> elliott: I was going to ask, is monads-tf preferred?
16:38:53 <dylukes> I recall fundeps being on the way out?
16:38:58 <mm_freak> that one would probably blow their heads off
16:39:49 <hpaste> DanBurton pasted ‚Äúparse error? Lambdas‚Äù at http://hpaste.org/53040
16:40:00 <dylukes> let rle = map (head &&& length) . group in "aaaaaabbbbccddeeee"
16:40:08 <dylukes> > let rle = map (head &&& length) . group in rle "aaaaaabbbbccddeeee"
16:40:09 <lambdabot>   [('a',6),('b',4),('c',2),('d',2),('e',4)]
16:40:11 <dylukes> neato :D
16:40:17 <dylukes> :t (&&&)
16:40:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:40:22 <dylukes> fgures.
16:40:32 <dylukes> but, not very hard to get here.
16:40:37 <DanBurton> :t (&&&) `asAppliedTo` head
16:40:38 <lambdabot> forall c c'. ([c] -> c) -> ([c] -> c') -> [c] -> (c, c')
16:40:45 <dylukes> Nah, I get &&& :\.
16:41:03 <dylukes> > let rle = map (head &&& length) >>> group in rle "aaaaaabbbbccddeeee"
16:41:04 <DanBurton> I just like playing with asAppliedTo
16:41:04 <lambdabot>   Couldn't match expected type `[a]'
16:41:04 <lambdabot>         against inferred type `GHC.Types...
16:41:10 <dylukes> er
16:41:21 <mm_freak> dylukes: <<<
16:41:26 <dylukes> > let rle = map (group >>> (head &&& length)) in rle "aaaaaabbbbccddeeee"
16:41:27 <lambdabot>   Couldn't match expected type `[a]'
16:41:27 <lambdabot>         against inferred type `GHC.Types...
16:41:39 <hpc> :t group
16:41:39 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
16:41:45 <hpc> :t (head &&& length)
16:41:46 <lambdabot> forall c. [c] -> (c, Int)
16:41:52 <mm_freak> > map (head &&& length) <<< group $ "aaaabbbccd"
16:41:53 <lambdabot>   [('a',4),('b',3),('c',2),('d',1)]
16:42:01 <dylukes> so why does group >>> not work here?
16:42:07 <mm_freak> (<<<) = (.)
16:42:07 <hpc> because you are mapping it
16:42:10 <hpc> group takes a list
16:42:13 <DanBurton> > map (head &&& length) . group $ "aaaabbbccccddddddd"
16:42:14 <lambdabot>   [('a',4),('b',3),('c',4),('d',7)]
16:42:16 <hpc> you are mapping it over [Char]
16:42:22 <DanBurton> <<< is the same as . right?
16:42:23 <hpc> so group is getting Chars
16:42:26 <dylukes> no I mean
16:42:38 <mm_freak> DanBurton: in Prelude no, in Control.Category yes
16:42:39 <dylukes> (a &&& b) <<< c /= c >>> (a &&& b) ?
16:42:47 <dylukes> :t (>>>)
16:42:47 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:42:48 <dylukes> :t (<<<)
16:42:49 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
16:42:53 <copumpkin> >_>
16:42:54 <copumpkin> <_<
16:42:58 <copumpkin> ^_^
16:42:59 <hpc> map (a &&& b) <<< c == (map (a &&& b)) <<< c
16:43:10 <hpc> == c >>> map (a &&& b)
16:43:14 <dylukes> ah, right >_<
16:43:25 <dylukes> > let rle = group >>> (map (head &&& length)) in rle "aaaaaabbbbccddeeee"
16:43:26 <lambdabot>   [('a',6),('b',4),('c',2),('d',2),('e',4)]
16:43:26 <mm_freak> or short:  (>>>) = flip (.)
16:43:40 * DanBurton suddenly wishes for a new feature: semi-qualified imports. Import as much as possible unqualified as long as it doesn't clash with what is already imported.
16:43:47 <copumpkin> rle is better when defined the other way
16:43:55 <dylukes> DanBurton: Better, we just need "renaming" like Agda.
16:44:01 <dylukes> Is there any plans to bring that to Haskell?
16:44:05 <copumpkin> @let rle = map (length &&& head) . group
16:44:06 <lambdabot>  Defined.
16:44:07 <DanBurton> "renaming"?
16:44:13 * DanBurton is not too familiar with Agda
16:44:18 <copumpkin> @let unrle = concatMap (uncurry replicate)
16:44:18 <hpc> import Foo renaming foo to bar
16:44:19 <lambdabot>  Defined.
16:44:22 <copumpkin> :t unrle
16:44:23 <lambdabot> forall b. [(Int, b)] -> [b]
16:44:23 <copumpkin> :t rle
16:44:23 <dylukes> import Foo.Bar renaming foo to bar
16:44:24 <lambdabot> forall a. (Eq a) => [a] -> [(Int, a)]
16:44:35 <DanBurton> ohh that would be nice
16:44:36 <dylukes> :t uncurry
16:44:37 <hpc> vaguely like that, only with more parsable syntax
16:44:37 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:44:43 <mm_freak> copumpkin: the type used in the talk is (a, Int)
16:44:49 <mm_freak> surely (Int, a) would be better
16:45:16 <dylukes> agda also has 'hiding'
16:45:18 <dylukes> which would be nice.
16:45:23 <dylukes> oh wait :P.
16:45:26 <DanBurton> :P
16:45:32 * dylukes swallows his foot.
16:45:37 <mm_freak> anyway, nice talk‚Ä¶  i'm feeling good recommending it
16:47:16 <kmc> DanBurton, interesting... would they apply in order?
16:47:44 <kmc> [mostly joking] you should be able to specify a numerical priority with each import, used to resolve ambiguity
16:47:56 <DanBurton> o_O
16:47:57 <kmc> or better an arbitrary partial order
16:48:05 <elliott> kmc: import fixity
16:48:09 <mm_freak> kmc: actually that wouldn't be bad
16:48:14 <elliott> you can't mix ambiguous name usages in the same expression, etc.
16:48:22 <elliott> I don't know where left/right come in
16:49:04 <DanBurton> or...we could just hope for TDNR
16:49:06 <kmc> i don't suppose affine transforms on Shapes are defined anywhere
16:49:41 <dylukes> elliott: kmc: okay stop you two. We don't need a turing complete import keyword...
16:49:51 <copumpkin> kmc: not that I know of :)
16:50:16 <dylukes> "In other news, Haskell's popularity as a language has declined considerably, having been replacing with the Structured Haskell Import Templating language.
16:50:35 <mm_freak> lol
16:50:59 <DanBurton> Let's throw some stuff into Haddoc to make it turing complete, too
16:51:40 <DanBurton> *Haddock
16:51:57 <dylukes> Everything is a turing complete quine language.
16:52:45 <prabhat> i know -> is used to for type signature of functions e.g. f::Int -> Int but i don't quite understand the type f = (->) e
16:53:01 <prabhat> any help?
16:53:28 <kmc> prabh4, the type constructor (->) is partially applied
16:53:52 <kmc> ¬´A -> B¬ª is sugar for ¬´(->) A B¬ª
16:54:01 <kmc> much like infix operators at value level
16:54:05 <prabh4> how do i interpret fmap :: (a -> b) -> (->) e a -> (->) e b
16:54:10 <ddarius> I believe earlier versions of Haskell's module system had something like renaming.
16:54:15 <kmc> (a -> b) -> (e -> a) -> (e -> b)
16:54:29 <prabh4> ok
16:54:32 <dylukes> the haskell module/package system could use some improvement :\
16:54:52 <ddarius> The package system is not part of Haskell.
16:54:52 <mm_freak> compared to other languages haskell's module system is a true virtue
16:54:54 <kmc> is there a std lib function to do mod/rem on floating point numbers
16:55:01 <hpc> :t divmod
16:55:02 <lambdabot> Not in scope: `divmod'
16:55:03 <ddarius> @hoogle fmod
16:55:04 <lambdabot> Network.HTTP.Headers HdrIfModifiedSince :: HeaderName
16:55:05 <hpc> :t divMod
16:55:06 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
16:55:06 <rwbarton> > 3.0 `mod'` 1.4
16:55:07 <lambdabot>   0.20000000000000018
16:55:14 <hpc> > 3.0 divMod 1.4
16:55:14 <dylukes> :t mod
16:55:15 <lambdabot>   3.0
16:55:15 <lambdabot> forall a. (Integral a) => a -> a -> a
16:55:16 <kmc> @src mod'
16:55:17 <lambdabot> Source not found. Take a stress pill and think things over.
16:55:23 <kmc> @hoogle mod'
16:55:23 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
16:55:23 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
16:55:26 <kmc> aha!
16:55:28 <kmc> thanks
16:55:34 * DanBurton is getting screwed over by unix-2.5, can't install darcs or even cabal-install which want unix < 2.5 T_T
16:55:38 <copumpkin> honestly, those should be moved elsewhere
16:55:43 <kmc> how did i not know about this module?
16:55:44 <kmc> looks useful
16:56:31 <copumpkin> it's nice
16:56:58 <mm_freak> huh?  when were mod' and divMod' added?
16:57:22 <copumpkin> they've been around for ages
16:57:27 <copumpkin> hidden away in Data.Fixed
16:58:02 <mm_freak> oh man, i'm always reinventing them
16:58:25 <mm_freak> can i assume them to be available in base >= 4?
16:59:09 <copumpkin> http://hackage.haskell.org/packages/archive/base/3.0.3.1/doc/html/Data-Fixed.html
16:59:13 <copumpkin> still there
16:59:19 <mm_freak> alright
16:59:37 <mm_freak> the names are unfortunate‚Ä¶  i always searched for fmod
16:59:44 <mm_freak> who would think that it's mod'
17:00:05 <hpc> i think it's misnamed
17:02:27 <dafis> DanBurton: which version of cabal-install are you trying to install?
17:02:55 <DanBurton> 0.10.2
17:03:13 <DanBurton> which is actually the one I have, so it's not extremely dire
17:03:27 <DanBurton> I just wanted to rebuild it with my newer ghc
17:04:09 <dafis> ah, don't bother then, darcs is hairier, possibly
17:04:22 <hpaste> DanBurton pasted ‚Äúcabal-install vs unix‚Äù at http://hpaste.org/53041
17:05:17 <dafis> though, unpacking and editing the .cabal file should work there too (unless too many dependencies depend on unix < 2.5)
17:05:41 <DanBurton> yeah
17:05:53 <DanBurton> I'm not that dedicated to the idea
17:06:07 <elliott> DanBurton: see topic
17:06:10 <dafis> DanBurton: you should not install any unix package beside the one that came with ghc
17:06:11 <elliott> for how to get cabal-install working on new ghc
17:06:16 <elliott> oh is this darcs?
17:06:18 <elliott> with darcs just fix the deps
17:06:19 <elliott> it works fine
17:06:36 <DanBurton> darcs or cabal-install
17:06:37 <elliott> i.e. what dafis said :P
17:06:42 <elliott> DanBurton: either or?
17:06:45 <DanBurton> both are having the same issue
17:06:51 <DanBurton> &&, not || sorry
17:06:56 <elliott> ah
17:07:00 <elliott> well see https://gist.github.com/1169332 for cabal-install
17:07:04 <elliott> and with darcs just edit the cabal file to fix the deps
17:09:49 <dylukes> @tell edwardk Why was your MonadParser codensity instance abandoned :<?
17:09:49 <lambdabot> Consider it noted.
17:09:53 <dylukes> @seen edwardk
17:09:53 <lambdabot> Unknown command, try @list
17:09:53 <preflex>  edwardk was last seen on #haskell 2 days, 18 hours, 30 minutes and 33 seconds ago, saying: ivanm: without it you can write all sorts of crazy cool things, with it, it takes a lot less code to write the smaller set of things we _can_ write (for the most part, there are notable exceptions)
17:10:31 <ghosting> @seen Cale
17:10:31 <preflex>  Cale was last seen on #haskell 19 hours, 33 minutes and 34 seconds ago, saying: kmc: Or just use different choices of module imports without making the interface explicit (just use monomorphic types everywhere)
17:10:31 <lambdabot> Unknown command, try @list
17:10:37 <Cale> hi
17:17:54 <Cale> ghosting: What's up?
17:23:32 <JuanDaugherty> prolly froze up when the actual Cale ponged
17:23:39 <kmc> man, GC tuning is tricky
17:24:25 <dafis> aye
17:24:28 <kmc> on this program, increasing the allocation area size massively improves productivity and decreases GC time, but increases total real time O_O
17:24:49 <copumpkin> kmc: did anyone respond to your stackoverflow question?
17:24:51 <JuanDaugherty> you meant run time didn't you
17:24:58 <dafis> kmc: try reducing alloc area, sometimes that speeds thing s up
17:25:07 <kmc> maybe because a compacted heap has better locality than the huge alloc area
17:25:16 <JuanDaugherty> because dilation of real time is a psychological topic
17:25:27 <kmc> copumpkin, nothing definitive yet
17:25:29 <kmc> JuanDaugherty?
17:25:33 <dafis> real time is imaginary
17:25:47 <kmc> maybe I just should not worry about optimizing the runtime of a program that takes 2s anyway
17:25:55 <kmc> maybe the runtime of longer-running programs is easier to understand?
17:26:16 <dafis> depends
17:27:22 <JuanDaugherty> (discounting relativity of course)
17:27:39 * copumpkin wonders about JuanDaugherty sometimes
17:28:09 * ddarius wonders about copumpkin sometimes
17:28:29 * copumpkin wonders about ddarius sometimes
17:28:52 <JuanDaugherty> well the locution "increasing real time" just caused a reflex action
17:30:55 <JuanDaugherty> i expect not to have to worry about gc in a lang with automatic gc if I'm not using a ffi
17:31:15 <JuanDaugherty> haskell a special case but still
17:31:23 <JuanDaugherty> *is a special
17:32:01 <shachaf> JuanDaugherty: Do you expect to worry about GC in a language that doesn't have GC?
17:32:19 <JuanDaugherty> absolutely
17:32:34 * shachaf wonders sometimes.
17:32:39 * kmc wonders whether mapM :: (a -> r -> b) -> [a] -> r -> [b]  is comprehensible
17:32:46 <shachaf> I'd think that languages with automatic GC are the ones you'd have to about GC most in.
17:33:01 <kmc> Java people worry about GC a *ton*
17:33:02 <JuanDaugherty> and in one that does maybe some general algorithm setting, parameter setting (at most)
17:33:07 <copumpkin> kmc: sure
17:33:56 <JuanDaugherty> kmc, apparently they do but SFAICT they only should be doing so in a system that isn't pure java
17:34:11 <kmc> uh if you say so
17:34:41 <kmc> people in high frequency finance who do crazy things to get acceptable performance from their pure Java FIX parser and financial modeling code
17:34:47 <kmc> s/who //
17:34:58 <kmc> anyway I don't really know what you're getting at here
17:35:05 <copumpkin> but they're immoral so they don't count
17:35:05 <shachaf> Does "isn't pure java" include running on a computer?
17:36:04 <JuanDaugherty> well in this case by not pure java I meant has some FFI interfaced code, because that as I understood it was the case were the finalX forms come into play
17:37:59 <JuanDaugherty> JNI interfaces and the like, ditto for haskell. If it's pure ghc approved haskell do still have other than standard mm concerns with haskell have to worry about gc?
17:38:33 <JuanDaugherty> i.e. ditto for haskell as far my expectations are concerned, asking the empirical question
17:41:23 <elliott> huh?
17:41:50 <dylukes> oh neat.
17:41:56 <dylukes> there's mark/release in Trifecta...
17:42:00 <dylukes> could be useful :)
17:44:24 <JuanDaugherty> If it's pure "ghc approved" haskell do you still, other than standard mm concerns for haskell have to worry about gc?
17:45:14 <elliott> Worry in what way?
17:45:32 <kmc> what
17:45:40 * elliott concurs.
17:47:36 <kmc> oh derp forgot ghc -O
17:47:48 <kmc> now my repa code's performance makes a little more sense
17:49:10 <copumpkin> JuanDaugherty: if your code spends a lot of time garbage collecting, you're making lots of garbage, and can probably do your algorithm better
17:49:17 <copumpkin> look ma, no FFI
17:49:30 <copumpkin> it won't affect the correctness of your program, but you do have to "worry"
17:50:07 <ddarius> copumpkin: Needs more mutation.
17:51:36 * JuanDaugherty resists the Alfred E. Neuman line.
18:21:32 <kmc> what is repa using for parallelism anyway? i see zero sparks but plenty of parallel CPU utilization
18:21:46 <kmc> is it using the same GHC internals as DPH?
18:23:08 <shachaf> kmc: It looks like it does unsafePerformIO of various forks.
18:23:31 <kmc> :(
18:23:43 <shachaf> Like monad-par.
18:27:13 <elliott> shachaf: :(
18:31:20 <kmc> haskell is like sausages
18:35:42 <ddarius> A restructuring of meat to get ideal properties?
18:44:21 <MatrixFrog> people like it even though they don't really know what's inside it?
18:45:29 * DanBurton missed the context of that question. McDonald's, perhaps?
19:18:35 <JuanDaugherty> people like it better if they don't see what goes into it
19:19:50 <JuanDaugherty> although I don't see how that really applies in a completely open source environment
19:30:03 <kmc> "I have come to the conclusion that the making of laws is like the making of sausages‚Äîthe less you know about the process the more you respect the result"
19:30:09 <kmc> many quotes like this attributed to many people
19:32:15 <kmc> anyway it's right and proper that core datastructure / algorithms libraries have messy optimized implementations
19:32:53 <kmc> when the alternative is to bake them into the language, write that mess in C and push it further down into GHC where fewer people will see it
19:37:15 <hpaste> sagelywizard pasted ‚ÄúSimpleHTTP‚Äù at http://hpaste.org/53043
19:38:02 <sagelywizard> Hmm. I've been learning Haskell lately and started writing a Haskell libcurl binding wrapper, for educational purposes. Any feedback would be really appreciated. http://hpaste.org/53043
19:39:52 <Guest78182> I try Haskell now.
19:40:10 <Axman6> ...
19:40:45 <copumpkin> Axman6: !!!
19:40:54 <djahandarie> (Warning: Haskell occasionally has fatal side effects.)
19:41:06 <djahandarie> unsafeInstantDeath
19:41:21 <Axman6> 'lo copumpkin
19:42:32 <MatrixFrog> is there a safe instant death?
19:42:33 <tgeeky> i thnk he was just vectorizing your points
19:42:33 <Cale> sagelywizard: foldl (++) will be slower than foldr (++)
19:43:06 <Cale> sagelywizard: (it's quadratic vs. linear time, since xs ++ ys takes O(length xs) time)
19:44:09 <sagelywizard> Cale: Ah, okay, cool.
19:44:31 <Cale> foldr (++) also produces the start of its result almost immediately, where foldl (++) will have to go through the whole list of lists first
19:44:49 <Cale> > foldr (++) [] [[k] | k <- [0..]]
19:44:51 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:44:54 <Cale> > foldl (++) [] [[k] | k <- [0..]]
19:45:07 <lambdabot>   mueval: ExitFailure 1
19:45:08 <lambdabot>  mueval-core: Time limit exceeded
19:50:09 <sagelywizard> Cale: Thanks. :)
20:08:19 * hackagebot gloss 1.4.0.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.4.0.1 (BenLippmeier)
20:08:21 * hackagebot gloss-examples 1.4.0.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.4.0.1 (BenLippmeier)
20:18:19 * hackagebot iproute 1.2.4 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.4 (KazuYamamoto)
20:20:17 <kmc> hmm repa-devil isn't threadsafe, is it :/
20:29:41 <elliott> kmc: huh, really?
20:29:53 <elliott> that sucks
20:30:08 <elliott> actually repa-devil is pretty disappointing in general, a bit overly-minimal interface... that might be DevIL's fault though
20:53:02 <kmc> i'm fine with the minimal interface
20:53:07 <kmc> so far
20:55:47 <T_X> another beginners question... is it possible to write something like: let isMod5 x = hasNoReminder (calcMod5 x)
20:55:52 <T_X> as a curried function?
20:56:35 <T_X> *remainder
20:56:36 <mzero> T_X: with only one argument, in what sense do you mean "curried"
20:57:04 <mzero> you could write
20:57:29 <T_X> mzero: if it's possible to write it without the 'x'
20:58:10 <mzero> > let isMod x y = (x `mod` y) == 0, isMod5 = flip isMod 5 in map isMod5 [4..7]
20:58:15 <lambdabot>   mueval-core: Time limit exceeded
20:58:35 <mzero> > let isMod x y = (x `mod` y) == 0; isMod5 = flip isMod 5 in map isMod5 [4..7]
20:58:39 <lambdabot>   mueval-core: Time limit exceeded
20:58:46 <mzero> fiddlesticks
20:59:05 <Saizan> isMod5 = (==0) . (`mod` 5)
20:59:08 <mzero> but, in any sense, T_X, writing without the explicit argument is called "point-free", not "curried"
20:59:13 <mzero> all functions in Haskell are curried
21:00:02 <mzero> @pl \x -> (x `mod` 5) == 0
21:00:02 <lambdabot> (0 ==) . (`mod` 5)
21:00:06 <mzero> hence
21:00:28 <mzero> > let isMod5 = (0 ==) . (`mod` 5) in map isMod5 [4..7]
21:00:43 <lambdabot>   mueval: ExitFailure 1
21:00:44 <lambdabot>  mueval-core: Time limit exceeded
21:00:51 <mzero> what is up with Lambdabot?
21:01:05 <mzero> > 3 + 4
21:01:06 <lambdabot>   7
21:01:26 <T_X> mzero: thx for the info. I'm just reading learnyouahaskell.com, so just read about the term "curried" (and might have misunderstood it, obviously :) )
21:01:35 <T_X> Saizan: thx, that works great!
21:02:03 <T_X> and I was especially looking for this to figure out whether it's possible to write the whole thing in one line:
21:02:24 <T_X> > filter ((==0) . (`mod` 5)) [1..100]
21:02:24 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100]
21:02:34 <mzero> curried just refers to the fact that when you define a function with two or more arguments, it is in fact a function that takes one (the first one) and returns a function that takes one less.
21:03:02 <T_X> and yes, that works like that (I guess I have to have a peak at what the '.' does, it didn't appear until my current chapter yet)
21:03:17 <mzero> so    funny x y z = 3*x*x + 2*y + z    can be applied to just one argument:   funny 5
21:03:37 <DanBurton> (.) is function composition: (f . g) x = f (g x)
21:03:47 <mzero> > filter (\x -> x `mod` 5 == 0) [1..100]
21:03:48 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100]
21:03:58 <mzero> might be clearer in this case
21:04:17 <mzero> in either case, the argument to filter in both yours and mine are actually the same thing --
21:04:26 <mzero> yours is expressed "point free"
21:04:36 <DanBurton> hey mzero liked your talk
21:04:42 <mzero> oh, thanks!
21:05:18 <DanBurton> :)
21:05:57 <mzero> T_X: here's a slide about (.)  : http://www.ozonehouse.com/mark/haskell-amuse-bouche/slides.html#(11)
21:06:40 <T_X> mzero: ok, thanks a lot!
21:15:43 <DanBurton> @where lambdabot
21:15:44 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
21:18:14 <DanBurton> So I'm about to try and install lambdabot from the darcs repo (with ghc 7.2.1) .. any tips? I hear lambdabot is notoriously difficult to install
21:19:04 <mzero> never tried it myself
21:19:24 <mzero> just /msg lambdabot so my use of it is private!!
21:20:16 <Saizan> DanBurton: be patient, and ask here if there's something that doesn't make sense
21:21:00 <DanBurton> Saizan: k. I'll give it a try. The darcs repo is taking a while to download :P
21:21:53 <byorgey> needs moar tubes
21:24:40 <ddarius> byorgey: More tubes would cause more of the internet to leak out.
21:26:32 <byorgey> you have to install the diodes the right way around.
21:27:47 <DanBurton> So the first issue I ran into was this: mueval-0.8.1 wants mtl < 1.2, but lambdabot 4.2.3.3 wants mtl >2
21:31:20 <DanBurton> Sigh. tried grabbing mueval from darcs, now it tries to install show-0.4.1.1 which wants base <4 T_T
21:32:16 * DanBurton , again, gives up on installing lambabot for now
21:37:07 <byorgey> DanBurton: lambdabot doesn't depend on mueval, does it?
21:37:36 <ddarius> It doesn't but obviously you want have the evaluation functionality without it.
21:37:52 <Cale> DanBurton: That's okay, because you build mueval and lambdabot separately
21:38:01 <byorgey> yes, but I don't see why they need the same version of mtl
21:38:03 <byorgey> right
21:38:12 <DanBurton> byorgey: when I try to install lambdabot from its darcs repo, it tries to install mueval
21:38:50 <byorgey> DanBurton: oh, I guess the dependencies in the darcs version are different than those in the version on Hackage
21:39:41 <byorgey> sure enough, it specifies mueval
21:39:58 <DanBurton> byorgey: OK, so trying to install lambdabot straight from Hackage has a similar problem to the mueval problem...it tries to install show-0.4.1.1 which wants base <4
21:39:59 <Saizan> try removing that dep
21:40:37 <byorgey> look at http://hackage.haskell.org/package/show
21:40:50 <byorgey> in particular the dependencies say "OR... base >= 4 ...
21:41:00 <byorgey> so I guess there is some flag you can pass...
21:41:21 <byorgey> DanBurton: yeah, try this first:  cabal install -fbase4 show
21:41:28 <DanBurton> mm but the other option is <4.4; however 4.4 is the version of base that I have
21:41:29 <byorgey> see http://hackage.haskell.org/packages/archive/show/0.4.1.1/show.cabal
21:41:49 <byorgey> ah, that should be updated
21:42:16 <byorgey> DanBurton: cabal unpack show; cd show; $EDITOR show.cabal; ... change 4.4 to 4.5 ...; cabal install
21:42:20 <byorgey> ought to do the trick
21:42:43 <DanBurton> I'll give it a whirl, thanks
21:42:47 <byorgey> and send an email to twanvl
21:46:16 <DanBurton> so...latest update. Installing the slightly tweaked "show" package now wants to install smallcheck-0.4, which has an error
21:46:17 <mzero> I see Data.Enumerator now says of Operators: "Most of these will be obsoleted by version 0.5."
21:46:26 <mzero> anyone know what is planned for 0.5 for Operators?
21:46:42 <mzero> (I find the current ones totally bizarre)
21:46:44 <napping> what am I doing wrong: base:Prelude can't be safely imported! The package (base) the module resides in isn't trusted.
21:46:51 <DanBurton> "Implicit import declaration: Ambiguous module name 'Prelude': it was found in multiple packages: base haskell98-2.0.0.0
21:47:04 <thoughtpolice> napping: ghc 7.2.1? it has a bug in the shipped version. you need to say 'ghc-pkg trust base'
21:47:08 <thoughtpolice> this is fixed in HEAD
21:47:15 <kmc> haha
21:47:36 * DanBurton trusts no one, not even base!!!?? :)
21:47:47 <elliott> ghc-pkg trust ghc
21:47:52 <napping> that was it, thanks
21:49:51 <byorgey> DanBurton: if you remove the 'base' dependency from smallcheck I think (?) it should work
21:50:07 <byorgey> DanBurton: the haskell98 package is a lot different in ghc 7.2 than it was previously
21:50:30 <byorgey> it might also work if you remove the haskell98 dependency
21:51:23 <DanBurton> byorgey: thanks, I'll give *that* a whirl.
21:51:36 <DanBurton> This is starting to feel like Inception: Must. Go. Deeper.
21:52:25 <Cale> mzero: They are a little bizarre, aren't they? (<==<) has the wrong type, it seems to me. Why isn't it (Step a' m b' -> Iteratee a'' m b'') -> (Step a m b -> Iteratee a' m b') -> (Step a m b -> Iteratee a'' m b'')? (Instead, it's a specialisation of that)
21:52:46 <Cale> It's supposed to be analogous to composition.
21:52:51 <DanBurton> ugh.
21:53:21 <DanBurton> if I remove base, then it can't find the "Foreign" module. If I remove haskell98, then it can't find the "IO" module
21:53:49 <mzero> and it feels odd that one needs three types of connectors
21:53:50 <Cale> System.IO
21:54:18 <DanBurton> System.IO is a base module, right?
21:54:26 <Cale> yeah
21:55:18 <byorgey> people used to use the old non-hierarchical module names (List, IO, etc.) to conform to the haskell 98 spec
21:55:41 <DanBurton> yeah, looks like there are a couple of these that I need to address. Next up: Monad -> Control.Monad
21:56:29 <byorgey> but to get those GHC made you use the haskell98 package
21:57:22 <DanBurton> YAY smallcheck installed now after a couple of those adjustments
21:57:32 <byorgey> \o/
21:57:44 <DanBurton> now...popping off the stack...
21:58:23 <byorgey> smallcheck is a nice package, someone ought to update it properly and send Colin Runciman a patch
22:04:37 <elliott> Cale: mzero: btw, the iterIO package has nicer composition... IMO
22:05:13 <elliott> there's just (.|) and (|.), and the latter has a trivial definition in terms of the former
22:08:05 <mzero> and I like that he's whittled the three types of things into just two
22:11:04 <Axman6> @hackage iterIO
22:11:04 <lambdabot> http://hackage.haskell.org/package/iterIO
22:12:03 <gienah> smallcheck patch removing haskell98: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/smallcheck/files/smallcheck-0.4-no-haskell98.patch
22:12:03 <mzero> but I wonder why Iter can't just be a specialization of Inum, in something analogous to how Onum is
22:12:23 <DanBurton> Well I've sent emails to Colin and Twan
22:14:53 <hpaste> DanBurton pasted ‚ÄúWhat now? Lambdabot..‚Äù at http://hpaste.org/53047
22:15:01 <elliott> mzero: I wanted that too, but I'm not sure it makes sense -- conceptually, Inum is an iterator transformer
22:15:15 <elliott> mzero: i.e. Inum in out m a = Iter out m a -> Iter in m a
22:15:36 <elliott> ...the type just looks a little different in reality since it's more convenient to use like that
22:15:55 <byorgey> DanBurton: hmmm, strange
22:16:01 <byorgey> you should not need to install it globally
22:16:06 <elliott> mzero: I mean, you can rewrite an Integer as a function () -> Integer; that makes sense too, but is more obviously the wrong thing to do :)
22:16:30 <byorgey> DanBurton: try cabal -v3 install lambdabot
22:16:32 <mzero> elliott - that is well put, I see it inow
22:17:09 <gienah> DanBurton byorgey: a patch: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/show/files/show-0.4.1.1-ghc-7.2.patch
22:17:22 * elliott has had good experiences with iterIO, only thing I'd like to see is a split into multiple packages, since it has some unfortunate dependencies -- HsOpenSSL and unix come to mind
22:17:42 <mzero> ouch
22:17:52 <elliott> yeah... it's not inherent though
22:17:57 <elliott> it's just a little too big for one package
22:17:59 <Saizan> DanBurton: you need to bump the show version when you install a modified version of it
22:18:02 <elliott> nothing baked-\in
22:18:13 <Saizan> DanBurton: otherwise cabal will think it's the same as the one on hackage
22:18:20 <DanBurton> Saizan: ah..ok
22:20:36 <DanBurton> Cool, that fixed it Saizan. Now, of course, IOSpec-0.2.2 requires base <4.4
22:22:11 * DanBurton continues the Quest for Lambdabot, manually unpacking any package that stands in his way..
22:23:24 <Saizan> remember to bump versions!
22:23:33 <DanBurton> indeed I did
22:24:59 * DanBurton watches as the various dependencies whiz by. Looks like a good sign.
22:26:19 <DanBurton> Next up: the oeis package has the "Ambiguous module" issue with Prelude
22:26:21 <elliott> lambdabot's code is pretty terrifying.
22:28:47 <DanBurton> byorgey: the oeis package is giving me trouble, but I don't understand why
22:29:31 <DanBurton> the build-depends only say it needs base, but I am getting the "Ambiguous module name 'Prelude'" error
22:29:31 <byorgey> hmm, what's the trouble?
22:29:43 <byorgey> weird
22:30:55 <byorgey> DanBurton: do you get an error if you just 'cabal install oeis'?
22:31:31 <DanBurton> byorgey: yep same error
22:31:58 <byorgey> hmm, just a second, let me try installing oeis with ghc 7.2
22:32:50 <DanBurton> hm, so I just did "ghc-pkg hide haskell98" and then "cabal install oeis". That seemed to work, although it is less than ideal to need to hide it.
22:33:55 <byorgey> agreed, you shouldn't "need" to do that.
22:34:53 <DanBurton> is this a GHC bug? Or perhaps a cabal bug? Because haskell98 clearly isn't in the dependency list
22:36:35 <byorgey> not sure
22:36:48 <byorgey> hmm, oeis installs fine for me with 7.2.1
22:37:11 <byorgey> oh! but the haskell98 package is hidden by default
22:37:23 <byorgey> maybe you want it hidden, in general.
22:38:06 <DanBurton> mmm that would make sense
22:38:37 <DanBurton> I did hide and then unhide it when I was messing with something earlier, maybe it was hidden all along and then unhiding it messed me up
22:38:38 <byorgey> I still don't understand why it would look at haskell98 at all, hidden or not, if oeis does not specify it as a dep. but oh well. onwards!
22:38:54 <DanBurton> yeah so last challenge: haskell-src
22:38:55 <Saizan> btw the problem comes up because it has to build the Setup.hs of oeis, since it has build-type: Custom
22:39:11 <byorgey> aha!
22:39:15 <byorgey> Saizan++
22:39:40 <byorgey> and just building a random module, it looks in all non-hidden packages to find its imports
22:40:01 <DanBurton> ahh
22:40:10 <byorgey> hence you want haskell98 hidden.
22:40:49 <DanBurton> So I started unpacking and bumping haskell-src, but this scares me a little
22:41:07 <DanBurton> -- the dependency on Haskell 98 is only becuase Happy generates a parser that imports Array
22:41:36 <DanBurton> is it going to blow up in my face if I remove the haskell98 dependency?
22:42:01 <Saizan> sounds likely
22:42:32 <DanBurton> boo. I didn't come this far just to get thwarted =/
22:42:44 <Saizan> you could edit the generated parser module to use Data.Array
22:42:48 <byorgey> ugh
22:42:56 <DanBurton> mmm
22:43:10 <byorgey> that was a generic 'ugh', not directed at Saizan's suggestion in particular
22:43:18 <DanBurton> lol
22:43:35 <elliott> agree w/ ugh
22:43:43 <elliott> DanBurton: it'd be quicker to rewrite lambdabot :P
22:43:51 <DanBurton> elliott: ikr
22:44:35 <kmc> can you use -XHaskell98
22:44:39 <byorgey> you could find the place in happy's code generation code where it spits out 'Array' and change it to 'Data.Array' =P
22:45:11 <DanBurton> well..I just removed the haskell98 dependency, and did a "cabal install". It didn't blow up yet
22:45:31 <DanBurton> in fact it looks like it worked
22:45:59 <Saizan> maybe happy got updated :)
22:46:19 <DanBurton> I do have the latest happy; installed it earlier today
22:46:31 <byorgey> nice =)
22:47:07 <DanBurton> if this works...I think I'll celebrate by sending a few more emails to maintainers.
22:47:17 <byorgey> "If I try this simple thing will it work?" "Probably not." (10 minutes of discussion ensue) "Oh, the simple thing worked."
22:47:28 <DanBurton> :)
22:47:40 <elliott> kmc: that's giving up
22:48:07 <Saizan> :P
22:48:12 <DanBurton> it looks like I've made it through all of the dependencies, and now there's just a small problem with the lambdabot code itself
22:48:28 <elliott> very small problem :P
22:48:43 <DanBurton> it's suggesting -XFlexibleInstances for Plugin/Activity.hs
22:48:43 <KernelTrap> typoseverywherewesrdfnhtjndstgaffxgt
22:48:48 <elliott> hi KernelTrap
22:48:59 <elliott> DanBurton: lambdabot requires like a billion extensions so just pile 'em on
22:49:09 <byorgey> DanBurton: ah, yes, there is a certain class of syntax which used to not require FlexibleInstances and now does
22:49:13 <kmc> lambdabot is from the era of -fglasgow-exts
22:49:18 <gienah> DanBurton: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/lambdabot
22:49:22 <byorgey> just add whatever flags it wants
22:49:52 <DanBurton> gienah: how exactly should I use that?
22:49:57 <elliott> We really need something more severe than {Undecidable,Incoherent}Instances so we can have some new popular "turn on fancy stuff" flag that enables it by default.
22:50:20 <elliott> InternallyInconsistentInstances.
22:50:28 <elliott> JustPlainWrongInstances
22:51:09 <byorgey> VolatileInstances -- may change its mind about which instance was chosen halfway through executing your program
22:51:17 <elliott> haha
22:51:19 <elliott> RandomInstances
22:51:25 <elliott> it solves overlap with dice
22:51:25 <gienah> DanBurton: since you are using cabal I thought it might help to crib some of the patches
22:51:33 <byorgey> elliott: hehe
22:51:47 <elliott> NoInstances -- you don't need to declare instances any more; every type is an instance of every class
22:51:48 <gienah> DanBurton: like this one: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/lambdabot/files/lambdabot-4.2.3.2-ghc-7.2.patch
22:52:20 <DanBurton> gienah: whoa...flexible instances :)
22:52:46 <elliott> ContortionistInstances
22:53:22 * gienah has to go some some stuff
22:53:47 <DanBurton> k thanks. gienah :)
22:54:12 <Sgeo|web> Is http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.2/doc/html/Data-MemoCombinators.html the standard library for memoization?
22:54:19 <Sgeo|web> And also, I don't see how to build my own memoizer
22:54:37 <byorgey> that's a commonly used memoization library, yes
22:54:41 <DanBurton> Sgeo|web: it's not "standard" per se, but it is a good one
22:55:19 <elliott> Sgeo|web: there's also memo-trie and uglymemo
22:55:23 <elliott> type Memo a = forall r. (a -> r) -> a -> r
22:55:25 <Sgeo|web> Does it try to stop it from running out of memory?
22:55:28 <elliott> you build memoisers by giving a value of that type
22:55:34 <Sgeo|web> e.g. can parts of the table be garbage collected?
22:55:45 <elliott> note that if your parameter is something like a number, uglymemo will probably be a lot faster
22:55:53 <elliott> might be different if it's some complex data structure
22:55:58 <elliott> Sgeo|web: nothing does that to my knowledge
22:57:15 <DanBurton> it would be cool if someone wrote a garbage-collectable memoizer. Say, a memoizer that remembers the last 10 entries. Sounds ugly and mutable, but w/e
22:57:55 <elliott> DanBurton: at that point I think you should write your own memoiser
22:57:58 <DanBurton> o....m......g.....lambdabot installed!!!! Success! :)
22:58:04 <elliott> cache invalidation is one of CS' two hard problems, after all
22:58:08 <byorgey> \o/
22:58:11 <elliott> the others are naming things and off-by-one errors
22:58:17 * byorgey high-fives DanBurton 
22:58:50 <DanBurton> I got it to install by adding -fglasgow-exts to the compiler flags in the cabal file >xD I didn't want to deal with all of the issues by hand.
22:59:12 <elliott> :-(
22:59:16 <Sgeo|web> Wait, I thought I understood memoization, but now I forgot
22:59:23 <Sgeo|web> memoize f, for example
22:59:26 <elliott> how do you forget what memoisation is?
22:59:29 <Sgeo|web> THen I use that separate on two things
22:59:43 <Sgeo|web> How does memoize f update its internal list after I used it the first time?
22:59:51 <DanBurton> perhaps you should memoize the meaning of memoization?
22:59:57 <DanBurton> ;)
23:00:01 <elliott> Sgeo|web: one of two ways
23:00:05 <elliott> Sgeo|web: (a) using sharing
23:00:09 <elliott> Sgeo|web: (b) using unsafePerformIO
23:00:18 <elliott> MemoCombinators/memo-trie is (a), uglymemo is (b)
23:00:22 <elliott> (b) tends to be faster in practice
23:00:23 <Sgeo|web> sharing?
23:00:26 <DanBurton> (a) also requires laziness. Fortunately, (a) is lazy
23:00:30 <elliott> Sgeo|web: yes
23:00:31 <DanBurton> *haskell
23:00:34 <elliott> Sgeo|web: e.g.
23:00:40 <elliott> let x = someReallyBigObject in ([x],[x])
23:00:45 <elliott> the pointer to "x" in both of those lists is the same
23:00:49 <elliott> this isn't guaranteed by Haskell's semantics
23:00:56 <elliott> but is provided by every sane implementation
23:01:03 <elliott> Sgeo|web: for instance consider
23:01:23 <elliott> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); fib = (fibs !!) in map fib [0..]
23:01:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:01:44 <elliott> that works because, when another element of fibs is computed, that's shared between all occurrences of "fibs"
23:01:48 <elliott> and the work is never performed again
23:01:59 <elliott> it'd still /work/ without sharing, it'd just be as slow as the naive fibonacci implementation
23:02:10 <elliott> Sgeo|web: MemoCombinators/memo-trie just generalise this to all types of data
23:02:26 <Sgeo|web> Yes, but how do I end up sharing the same way between two textual different uses of the function separated far away?
23:02:33 <elliott> because sharing is pure mutation
23:02:54 <elliott> when a thunk is evaluated, it gets replaced by its value
23:03:08 <elliott> that's pure, because the two are indistinguishable
23:03:22 <elliott> but it's mutation, and therefore has (performance) effects at a distance
23:03:57 <Sgeo|web> So a part of the mapping table is a thunk?
23:04:11 <elliott> everything is thunkss
23:04:20 <elliott> a thunk is just any value that hasn't been evaluated yet
23:04:43 <Sgeo|web> COuld we say that the table contains all possible keys? It's just only the keys have have been used are stored?
23:04:52 <elliott> yes
23:04:55 <elliott> that's exactly the idea
23:05:07 <elliott> you describe the infinite tree that represents all values of the function
23:05:13 <elliott> and traversing it causes it to be partially evaluated in just those spots
23:05:28 <elliott> which results in those parts being replaced by their values
23:05:33 <elliott> and therefore not evaluated again
23:06:03 <elliott> the disadvantage is, you have to traverse the tree... so for simple inputs like integers, an uglier unsafePerformIO table solution like uglymemo is a lot faster
23:07:43 <DanBurton> @where uglymemo
23:07:43 <lambdabot> I know nothing about uglymemo.
23:07:49 <DanBurton> @hackage uglymemo
23:07:49 <lambdabot> http://hackage.haskell.org/package/uglymemo
23:08:08 <DanBurton> @where+ uglymemo http://hackage.haskell.org/package/uglymemo
23:08:08 <lambdabot> It is forever etched in my memory.
23:08:25 <Sgeo|web> Hmm, could memoization be used to make the trivial quicksort that everyone loves to hate efficient?
23:08:33 <Sgeo|web> Or is that not the issue?
23:08:42 <DanBurton> Not the issue
23:09:13 <DanBurton> The typical Haskell quicksort isn't that bad in the first place, and it's only "bad" because it uses extra memory
23:09:53 <Sgeo|web> How much memory?
23:10:29 <DanBurton> let quicksort [] = []; quicksort [x] = [x]; quicksort (x:xs) = quicksort (filter (<x) xs) ++ [x] ++ (filter (>x) xs) in quicksort [5,2,7,2,4,8]
23:10:34 <DanBurton> doh
23:10:39 <DanBurton> > let quicksort [] = []; quicksort [x] = [x]; quicksort (x:xs) = quicksort (filter (<x) xs) ++ [x] ++ (filter (>x) xs) in quicksort [5,2,7,2,4,8]
23:10:41 <lambdabot>   [2,4,5,7,8]
23:11:06 <DanBurton> in the worst case, it takes up O(n^2) memory, where n is the size of the list
23:11:24 <DanBurton> iinm
23:11:32 <Sgeo|web> iinm?
23:11:38 <DanBurton> if i'm not mistaken
23:12:04 <Sgeo|web> AH
23:12:06 <Sgeo|web> *Ah
23:12:53 <byorgey> the traditional quicksort algorithm is designed to run "in place", by mutating an array
23:12:59 <DanBurton> memoization won't help here because quicksort does not make use of any given recursive call more than once.
23:13:27 <DanBurton> memoization helps the fibonacci example tremendously, because each fibonacci value depends on all of the previous ones
23:13:41 <pikhq_> It's really not that the typical Haskell quicksort is bad, but rather that sorting a linked list is not the same as sorting an array.
23:13:44 <pikhq_> :)
23:13:51 <DanBurton> aye
23:15:06 <DanBurton> I could never pound out the "real" quicksort from memory the way I just did the "fake" quicksort. It's so conceptually simple in Haskell, I barely had to think about it. I was actually surprised I didn't make any mistakes :)
23:15:39 <Sgeo|web> Besides failing to ask lambdabot
23:15:47 <byorgey> yeah, the "real" quicksort is fiddly
23:15:55 <DanBurton> well yes, I made that one mistake ;) omitting the >
23:16:09 <pikhq_> Well, yeah. It feels kinda like, in Haskell, you write out the concept of a function. Whereas generally you do the legwork, too.
23:16:46 <Sgeo|web> But it's a horrible mistake! You don't even get a type error
23:16:48 <byorgey> DanBurton: actually, you made a mistake =)
23:17:04 <byorgey> > let quicksort [] = []; quicksort [x] = [x]; quicksort (x:xs) = quicksort (filter (<x) xs) ++ [x] ++ (filter (>x) xs) in quicksort [5,2,5,5,5,5,5]
23:17:06 <lambdabot>   [2,5]
23:17:13 <pikhq_> Hahah.
23:17:56 <DanBurton> byorgey: d'oh :P wtb dependent types
23:18:04 <DanBurton> the type system didn't save me like it usually does
23:18:11 <byorgey> hehe
23:18:22 <Sgeo|web> Where's the bug?
23:18:33 <DanBurton> I forgot to include elements of the list equal to the pivot
23:18:45 <Sgeo|web> Oh
23:18:57 <DanBurton> I filtered based on (<x) and (>x) but neglected (==x)
23:19:14 <copumpkin> you should lifter instead of filtering
23:19:26 <Sgeo|web> Would you do (<=x)?
23:19:26 <copumpkin> needs moar cowbell
23:19:31 <copumpkin> I mean fourier transform
23:19:54 <DanBurton> Sgeo|web: yes, that would solve the problem
23:20:52 <DanBurton> So I've been wondering
23:21:03 <DanBurton> @hoogle split
23:21:03 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
23:21:03 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
23:21:04 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
23:21:11 <DanBurton> no that's not it..
23:21:21 <DanBurton> @hoogle [a] -> ([a],[a])
23:21:22 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
23:21:22 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
23:21:22 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
23:21:35 <DanBurton> we have that, but we don't have
23:21:50 <DanBurton> @hoogle Eq a => a -> [a] -> ([a],[a],[a])
23:21:50 <lambdabot> No results found
23:22:57 <ddarius> It's trivial to write that in terms of span.
23:28:04 <DanBurton> @let partition3 f = foldr (\x (lt,eq,gt) -> case f x of LT -> (x:lt,eq,gt); EQ -> (lt,x:eq,gt); GT -> (lt,eq,x:gt)) ([],[],[])
23:28:06 <lambdabot>  Defined.
23:28:37 <DanBurton> > partition3 (`compare` 7) [2,4,7,9,4,5,6,6]
23:28:39 <lambdabot>   ([2,4,4,5,6,6],[7],[9])
23:29:38 <DanBurton> Seems to me that partition3 should be in Data.List along with partition
23:30:14 <DanBurton> Ord being the data type of 3 parts, analogous to Bool the data type of 2 parts
23:30:56 <DanBurton> Ordering, I mean
23:31:43 <coppro> better would be genericPartition :: (Eq b, Ord b) => (a -> b) -> [a] -> [[a]]
23:32:34 <DanBurton> exercise: write genericPartition
23:33:22 <DanBurton> it would help if the domain of b were also given as input
23:33:56 <DanBurton> because for each possible b, there should be at minimum an empty list
23:34:14 <copumpkin> partitionBy :: (a -> b) -> [a] -> b -> [a] or (a -> b) -> [a] -> Map b [a]
23:34:27 <copumpkin> with suitable constraints
23:35:26 <DanBurton> if b were bounded and enumerable, then I suppose you could discover the domain with [minBound .. maxBound]
23:35:31 <copumpkin> :t \f -> M.fromListWith (++) . map (f &&& pure)
23:35:33 <lambdabot> forall k a (f :: * -> *). (Monoid (f a), Ord k, Applicative f) => (a -> k) -> [a] -> M.Map k (f a)
23:35:54 <copumpkin> @let partitionWith = \f -> M.fromListWith (++) . map (f &&& pure)
23:35:55 <lambdabot>  Defined.
23:36:06 <copumpkin> > partitionWith even [1..10]
23:36:07 <lambdabot>   No instance for (Data.Monoid.Monoid (f a))
23:36:07 <lambdabot>    arising from a use of `e_1110...
23:36:22 <copumpkin> @undef
23:36:29 <copumpkin> @let partitionWith = \f -> M.fromListWith (P.++) . map (f &&& pure) -- fuck you
23:36:30 <lambdabot>  <local>:1:37: Not in scope: `P.++'
23:36:42 <elliott> copumpkin: Prelude.++
23:36:47 <copumpkin> @let partitionWith = \f -> M.fromListWith (++) . map (f &&& (:[])) -- fuck you
23:36:47 <elliott> don't you just love caleskell????
23:36:48 <lambdabot>  Defined.
23:36:52 <copumpkin> :t partitionWith
23:36:53 <lambdabot> forall a k. (Ord k) => (a -> k) -> [a] -> M.Map k [a]
23:36:57 <copumpkin> > partitionWith even [1..10]
23:36:59 <lambdabot>   fromList [(False,[9,7,5,3,1]),(True,[10,8,6,4,2])]
23:37:06 <copumpkin> > partitionWith (compare 4) [1..10]
23:37:07 <lambdabot>   fromList [(LT,[10,9,8,7,6,5]),(EQ,[4]),(GT,[3,2,1])]
23:37:07 <DanBurton> lol
23:37:22 * DanBurton applauds
23:37:24 <copumpkin> > partitionWith (`mod` 7) [1..10]
23:37:25 <lambdabot>   fromList [(0,[7]),(1,[8,1]),(2,[9,2]),(3,[10,3]),(4,[4]),(5,[5]),(6,[6])]
23:37:31 <copumpkin> yay equivalence classes
23:37:51 <DanBurton> with one caveat, I think
23:38:00 <copumpkin> no, everything I do is perfect
23:38:02 <DanBurton> > partitionWith (const True) [1..10]
23:38:03 <lambdabot>   fromList [(True,[10,9,8,7,6,5,4,3,2,1])]
23:38:10 <DanBurton> no list entry for False
23:38:15 <copumpkin> why should there be one?
23:38:29 <DanBurton> I suppose you could simply use functions to look for it
23:39:17 <DanBurton> my preconception was that the "partition" function should have an entry for every element in the domain of b, where f :: a -> b is the partitionWith function argument
23:39:42 <copumpkin> the `mod` 7 thing makes that annoying
23:39:54 <copumpkin> you don't just want to enumerate the domain
23:40:03 <DanBurton> right
23:40:04 <copumpkin> or codomain, there
23:40:11 <DanBurton> ew, that could get nasty then
23:40:12 <copumpkin> there's no way it can know that you wanted False to be there
23:40:16 <copumpkin> but 9 not to be
23:40:19 <elliott> :t partitionWith compare
23:40:20 <lambdabot> forall a. (Ord a) => [a] -> M.Map (a -> Ordering) [a]
23:40:22 <copumpkin> unless you tell it what you want in there
23:40:27 <elliott> the most useful
23:40:31 <copumpkin> lol
23:40:40 <elliott> might even work if you only end up with a singleton
23:40:57 <byorgey> Cale: did you originally create http://www.haskell.org/haskellwiki/New_monads/MonadSupply ?  I'm thinking of packaging it up properly and uploading to Hackage, any objection?
23:41:01 <copumpkin> > partitionWith compare [1..5]
23:41:02 <lambdabot>   Overlapping instances for GHC.Show.Show
23:41:02 <lambdabot>                              (a -> ...
23:41:10 <Cale> byorgey: yeah, no objection
23:41:13 <elliott> L.hs is so messed up
23:41:17 <copumpkin> > M.elems $ partitionWith compare [1..5]
23:41:19 <lambdabot>   *Exception: (==): No overloading for function
23:41:20 <elliott> overlapping instances for showing functions
23:41:23 <copumpkin> :P
23:41:29 <elliott> copumpkin: that's my favoured way to write _|_
23:41:29 <DanBurton> > map ($3) . toList . partitionWith compare [1..5]
23:41:30 <lambdabot>   Not in scope: `toList'
23:41:49 <copumpkin> elliott: yay
23:42:07 <byorgey> Cale: ok, great.  I know it's just a thin wrapper around State but I end up wanting it every few months and am annoyed that I can't just cabal-install it
23:42:29 <elliott> byorgey: hmm, wouldn't "newtype SupplyT s m a = SupplyT (m s -> m a)" be nicer?
23:42:35 <elliott> oh hmm
23:42:41 <elliott> I guess that doesn't work because SupplyT Identity doesn't work
23:42:57 <elliott> feels like you could avoid State, though
23:43:57 <elliott> byorgey: Cale: wait, why the heck is Supply s = SupplyT s Maybe there?
23:44:01 <elliott> rather than Identity
23:44:20 <Cale> what?
23:44:30 <elliott> newtype Supply s a = Supply (SupplyT s Maybe a)
23:44:36 <Cale> Weird.
23:44:41 <DanBurton> @let partitionWithDomain ys f xs = let m = partitionWith f xs in map (flip lookup m) ys
23:44:42 <lambdabot>  <local>:2:77:
23:44:42 <lambdabot>      Couldn't match expected type `[(a, b)]'
23:44:42 <lambdabot>             again...
23:44:46 <Cale> I certainly didn't write it that way originally
23:44:57 <elliott> you didn't write that page, so :p
23:44:57 <Feuerbach> I guess so that pattern matching returns Nothing rather than throws an exception
23:44:59 <elliott> http://www.haskell.org/haskellwiki/index.php?title=New_monads/MonadSupply&action=history
23:45:13 <elliott> oh hmm
23:45:18 <copumpkin> ported from old wiki?
23:45:23 <elliott> i guess someone messed it up at some point
23:45:35 <byorgey> elliott: oh, weird
23:45:57 <byorgey> the version of the code I have on my laptop (which I actually use) has Identity
23:46:38 <Cale> fixed
23:46:49 <elliott> newtype SupplyT s m a = SupplyT (Get s m -> m a); newtype Get s m = forall r. Get ((s -> Get s m -> m r) -> m r) ... no, this isn't working :p
23:47:21 <byorgey> I think Feuerbach has the right idea
23:47:35 <byorgey> but I guess it's better as Identity, if someone wants Maybe they can use Maybe explicitly.
23:48:08 <elliott> weird that there doesn't seem to be any way to do it without state...
23:48:18 <elliott> State, that is
23:48:35 <Feuerbach> byorgey: yes, but it may be not obvious for them to do so :) So, I suggest having both of them for your package, under different names
23:48:57 <copumpkin> just run it over an infinite list/stream
23:49:00 <copumpkin> no worries
23:49:27 <Feuerbach> depends on your use case...
23:49:51 <byorgey> I'll think about it.  I don't want this to be TOO much work =)
23:53:25 <elliott> aha
23:53:32 <elliott> byorgey: http://sprunge.us/dGQP
23:53:36 <elliott> no StateT :p
23:53:53 <elliott> and it lets the "next supply value" computation be any computation in the transformed monad
23:54:15 <elliott> e.g. you could supply a (SupplyT Int IO) with values from the RNG
23:54:43 <elliott> I guess this is a slightly different monad at this point though
23:55:34 <byorgey> that's pretty neat
23:55:43 <byorgey> that should get packaged up too.
23:56:17 * elliott has wanted something like this a few times
23:56:37 <elliott> I suppose a lot of people might just unsafeInterleaveIO an infinite stream and use the regular supply monad :)
23:57:26 <byorgey> hehe
23:58:24 <byorgey> elliott: hmm, I guess given that you can do runSupplyT there it is strictly more general than the version with StateT
23:58:31 <elliott> yeah
23:58:33 <copumpkin> with autolifting, will I be able to use existing types at higher levels? In the paper it redefines data List a = Nil | Cons a (List a) and I was wondering whether there was some reason it didn't just use [a]
23:58:41 <elliott> byorgey: and it even looks like CPS, so it must be fast :-D
23:58:50 <byorgey> hehe, right!
23:59:17 <byorgey> copumpkin: yes, you will be able to use existing types
23:59:20 <copumpkin> cool
23:59:22 <copumpkin> so then I can do
23:59:47 <copumpkin> class WhichList (l :: List *) wher whichList :: some representation of typecase
23:59:52 <copumpkin> instance WhichList [] where whichList = ...
23:59:53 <copumpkin> ?
