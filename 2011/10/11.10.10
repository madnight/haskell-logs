00:00:01 <ddarius> kmc: No it doesn't.
00:00:24 <shamster> frerich2: I'm still coming to grips with tail recursion and trying lots of examples to see what goes... so now I'm thinking haskell isn't the place to try
00:00:37 <shamster> frerich2: at least if I'm going to measure performance
00:00:55 <kmc> ddarius, you can be a successful professional software engineer even if cargo cult is your primary tool for understanding code
00:01:05 <ddarius> If you care about "measuring performance" then why not do that?  Why do you care, one way or another, about tail recursion?
00:01:16 <frerich2> shamster: I'm still tinkering around. I often have a top-down approach to learning, so I start with a few programs, notice that some of them behave much better than others and then (if I have the time/motivation) dig down to figure out why things are like that.
00:02:43 <shamster> frerich2: I've been writing up the code in C and trying to come up with haskell equivalents to learn the language and to start understanding the recursion issues
00:02:59 <kmc> there are many popular, wrong theories about predicting performance in C, too
00:03:08 <frerich2> shamster: And to me, Haskell has been a pretty good place to try since the language is nice and the community is friendly (sans the group of [to me] die hard math people who explain stuff in terms of endofunctors and comonads and whatever :)
00:03:24 <kmc> those people are friendly too :)
00:03:26 <frerich2> shamster: I mean, they are friendly too - but not helpful to me :)
00:03:29 <kmc> hehe
00:03:31 <frerich2> kmc: Yeah ;-)
00:03:45 <kmc> it's often the same people, really
00:03:48 <shamster> So far I've had good luck on those ends
00:04:04 <pikhq_> shamster: Rule #1 of performance: it matters less than you think.
00:04:11 <pikhq_> Rule #2: no, really.
00:04:13 * frerich2 has the theory that people who really really understood something are able to explain it in very simple words
00:04:38 <shamster> pikhq_: haha, as long as I'm only tinkering in Haskell and I'm not writing any production code with it
00:04:39 <ddarius> frerich2: That's a poor approach without a good foundation.  1) You'll just end up with epicycles of epicycles, and 2) you are taking an empirical approach to figuring out something that is determined and documented.
00:05:05 <shamster> pikhq_: but for my C code #1 && #2 are reversed
00:05:21 <ddarius> frerich2: That idea is ridiculous, unless you mean to say there is no skill in teaching.
00:05:21 <pikhq_> shamster: Even in production code, 99% of your code's performance will be utterly irrelevant.
00:05:26 <kmc> frerich2, you can explain what a category and a functor and an endofunctor are in simple words
00:05:31 <shamster> pikhq_: agreed
00:05:43 <kmc> "endofunctor" may be a big scary word, but it's a totally arbitrary name attached to a formal definition
00:05:49 <pikhq_> And even then, generally the only performance that matters is big-O.
00:06:04 <kmc> pikhq_, I disagree, unless you're talking about O(# cache misses) or something
00:06:07 <kmc> which people usually aren't
00:06:15 * ddarius agrees with kmc.
00:06:30 <pikhq_> kmc: Okay, right, cache misses also matter hugely.
00:06:32 <frerich2> ddarius: Maybe it's not so ridiculous if you assert that people who teach better than others might also have a better understanding of what's being tought.
00:06:40 <kmc> counting computational steps is a big red herring for most tasks on most modern machines
00:06:42 * frerich2 goes out on alimb here
00:06:49 <QtPlatypus> kmc: Can you explain endofunctor in simple words?  Not a challange, its a genuime question as I'm a bit lost about them.
00:06:52 <pikhq_> "Hugely", heck, they're the primary performance factor.
00:06:55 <dolio> Cale: Apparently it only works for me if I put those lines above the colorscheme line.
00:07:00 <kmc> QtPlatypus, do you know what a category is?
00:07:16 <QtPlatypus> Yes
00:07:24 <kmc> do you know what a functor is?
00:07:38 <QtPlatypus> Sure.
00:07:47 <kmc> an endofunctor is a functor from a category to itself
00:07:48 <kmc> that is all
00:08:36 <ddarius> frerich2: That theory would mean there's no such thing as a good teacher, just one who knows more than others.  Not only is pedagogical skill not seem to be terribly well correlated with, at least, traditional signs of knowledgability, it also requires that everyone understand, teach, and learn things in the same way, which is also patently false.
00:08:52 <QtPlatypus> So the identity functor would be an endofunctor?
00:09:41 <QtPlatypus> ddarius: I think he is arguing that domain knowlige is neccery but not sufficant
00:09:42 <ddarius> All Haskell Functors are endofunctors (if they satify the laws, otherwise they aren't functors at all.)
00:09:46 <frerich2> ddarius: No, that's not what I meant. I said that "people who teach better than others might also have a better understanding". So this means that knowing more than others doesn't automatically make you a better teacher, but it is beneficial.
00:10:01 <ddarius> QtPlatypus: Obviously, it is.  No one expects one to teach something they don't know.
00:10:41 <QtPlatypus> ddarius: And it follows if one has a poor grasp of the subject mattor one would be a poor teacher.
00:11:11 <kmc> QtPlatypus, sure
00:11:19 <ddarius> QtPlatypus: That's fine.  His first statement though is logically equivalent to: if you can't teach something well, then you don't ("really really") understand it.
00:15:24 <frerich2> It's a bit exaggerated because there are surely other factors coming in but yes, that's the essence. If you notice that you cannot explain something nicely, then maybe you didn't tinker with it in your head long enough.
00:18:01 <kmc> there are plenty of world-class scientists who just suck at teaching
00:18:03 <ddarius> frerich2: Just because you can explain something nicely, doesn't mean you can teach someone easily.  If understand things differently from you, then my explanations are probably going to be difficult for you to understand.
00:21:23 <ddarius> Again, this theory implies that there is no reason to train educators as educators; that such training is a complete waste of time.
00:22:01 <frerich2> No, of course, the original theory was a bit of a provocation. There are a lot of other factors which decide whether youre good at teaching, or whether you suck at it. However, I did notice an effect that many 'pretty intelligent' people were only able to explain stuff using the ideas of the abstraction level below, whereas the people who really 'got it' realized that something is really very much the same as
00:22:01 <frerich2>  something else (something else being something many people are fmiliar with) and can then explain it in terms of that simpler idea.
00:22:45 <ddarius> frerich2: How do you know that such explanations were effectively and valuable?
00:23:19 <frerich2> ddarius: because I'm working as a software engineer nowadays :-)
00:24:13 <frerich2> (besides, any theory which implies that there is no reason to train educators must of course have been reduced to an absurd extreme)
00:26:48 <ddarius> Forgive me if I don't find your 0 sample size experiment compelling.
00:35:13 <ddarius> Another consequence of this theory is that you can always blame your failure to understand something on the person trying to explain it.  "Well, I guess they weren't as smart as I thought."  It also suggests that someone who's spent years trying to understand something, should be able to convey that understanding to anyone in a brief timespan, which would be wonderful and extremely valuable if it were true, but somehow
00:35:14 <ddarius>  doesn't seem to be the case.
00:41:36 <Cale> frerich2: If you want to understand endofunctors and comonads, it's really not all that bad :)
00:42:29 <frerich2> ddarius: I think you can only do as you describe if you neglect the fact that knowledge is only necessary (and my idea is that it's more necessary than people think) but not sufficient for teaching.
00:42:46 <Cale> frerich2: You can probably pick up most of what you need to know to understand 90% of the discussions about that stuff around here in a week or two.
00:43:19 <frerich2> Cale: Hah, probably, yes.
00:44:23 <kmc> i think frerich2 said something which was not literally true in order to make a more subtle point
00:44:25 <frerich2> Cale: That's actually why I greatly enjoy Haskell (because of the community) despite not having enjoyed a thorough mathematical (or even computer science...) education.
00:44:26 <Cale> (assuming you don't know what a category is yet, but are okay with technical definitions of things, I could probably get you as far as functors in about half an hour)
00:44:29 <ddarius> frerich2: Your original statement is basically that knowledge by far dominates what is sufficient to teach.
00:44:56 <Cale> (with a few good examples and such)
00:45:11 <cicatristeza> can anyone explain this snippet to me: sum [x | x <- takeWhile (<=4000000) fib, even x]
00:45:33 <cicatristeza> i dont understand the takeWhile (<=4000000) bit
00:45:42 <shachaf> > takeWhile (<5) [1,2,3,4,5,6,7]
00:45:43 <lambdabot>   [1,2,3,4]
00:45:55 <erus`> cicatristeza: get the Fibonacci sequence number less than or equal to 4000000 that are even
00:46:03 <cicatristeza> oh god it is simple less than or equal to isnt it
00:46:07 <Cale> yes
00:46:07 <cicatristeza> god i am sorry
00:46:18 <Cale> It looks a bit like an arrow :)
00:46:23 <kmc> cicatristeza, (< 5) is shorthand for the function (\x -> x < 5)
00:46:26 <kmc> works for any operator
00:46:34 <cicatristeza> yes! i thought i had missed some syntax
00:46:37 <ddarius> <- means less than or minus to
00:46:44 <cicatristeza> sorry
00:46:45 <Cale> :D
00:46:45 <shachaf> sum . filter even . takeWhile (<==4000000) $ fib
00:46:47 <kmc> no worries :)
00:46:52 <cicatristeza> ddarius: you are joking yes?
00:46:57 <kmc> => is a reserved word, after all
00:46:59 <Cale> cicatristeza: yes
00:47:28 * shachaf once embarrassed himself in front of a mathematician by writing <= instead of ≤ on a piece of paper.
00:47:43 <kmc> oh no
00:47:52 <kmc> this is why you should use Agda
00:48:01 <cicatristeza> whats agda
00:48:04 <ddarius> I don't know why you'd be embarrassed by that.
00:48:12 <kmc> cicatristeza, a programming language http://wiki.portal.chalmers.se/agda/pmwiki.php
00:48:19 <kmc> it's kind of like Super Haskell
00:48:28 <shachaf> Somehow it worked out that way in the context.
00:48:31 <ddarius> but more like Super Not Haskell.
00:48:49 <danr_> Well it let's you write ≤ instead of <=, so that's quite super :)
00:48:51 <roelvandijk> It is perfectly ok to use ≤ in Haskell. Just define (≤) = (<=) and specify the right fixity.
00:48:59 <kmc> yeah, there is a Hackage package to do that
00:49:01 <ddarius> You can write ≤ in Haskell.
00:49:12 <kmc> cicatristeza, it has dependent types, so you can specify and prove *any* property of your program in the type system
00:49:25 <roelvandijk> And use {-# LANGUAGE UnicodeSyntax #-} for extra goodness
00:49:40 <kmc> and it uses non-ASCII characters pervasively
00:49:54 <Blkt> good morning everyone
00:49:56 <danr_> It's not really praxis to use unicode in haskell, so I wouldn't. But in Agda it's standard
00:50:08 <roelvandijk> Blkt: Good morning to you too!
00:50:22 <ddarius> kmc: The users use ...
00:50:36 <ddarius> Conor seems not to care for the Unicode.
00:50:59 <roelvandijk> danr_: I use Unicode in all my Haskell stuff, but it is controversial
00:51:03 <kmc> cicatristeza, and it has user-defined mixfix operators, which are more general than infix.  so you can write  if_then_else_ : Bool → t → t → t
00:51:10 <kmc> and then use it like: if True then 3 else 4
00:51:16 <dolio> Conor prefers to draw terrible ascii art in his files.
00:51:27 <cicatristeza> kmc: thanks
00:51:42 <kmc> cicatristeza, but it's still in the very earliest stages of being a usable programming language, imo
00:51:46 <ddarius> It would only be more terrible if it were Unicode art.
00:51:56 * kmc complains about the use of "Unicode" to mean "non-ASCII"
00:52:03 <engla> roelvandijk: how do you insert the symbols? did you modify your keymap?
00:52:25 <kmc> not just semantic pedantry; there's a real conceptual point to be made there
00:52:25 <roelvandijk> engla: http://haskell.org/haskellwiki/Unicode-symbols#Input_methods
00:52:25 <ddarius> kmc: Does Agda allow non-Unicode?
00:52:41 <kmc> I don't know
00:52:44 <ddarius> Haskell defines the syntax to be in terms of Unicode, so it is certainly correct in Haskell's case.
00:52:46 <kmc> is there a formal Agda spec?
00:52:51 <roelvandijk> engla: In short: I wrote my own input method
00:52:57 <engla> roelvandijk: ok
00:53:08 <frerich2> engla: Shameless plug: I use https://github.com/frerich/unicode-haskell to get fancy Unicode in my (vim) editor but plain ASCII on disc. Sample screenshot: http://imageshack.us/photo/my-images/840/unicodehaskell.png/
00:53:22 <kmc> cool!
00:53:42 <cicatristeza> kmc: what do you use haskell for, i mean what have you made with it
00:54:02 <danr_> roelvandijk: looking at your haskell-unicode-input-metod.el, didn't know there was a 𝔹, black board bold B, thanks
00:54:21 <roelvandijk> danr_: There isn't. I didn't add it
00:54:41 <kmc> compilers, interpreters, bioinformatics tools, graphics programs, tools for analyzing binary executables, small sysadmin scripts, ...
00:54:43 <roelvandijk> danr_: But you can easily define it yourself.
00:55:15 <engla> frerich2: that's nice, looks great.
00:55:28 <cicatristeza> kmc: anything i can see?
00:55:29 <roelvandijk> danr_: To be precise, I didn't add it to base-unicode-symbols. You can ofcourse use the input method to type 𝔹, ℤ, ℚ and the like
00:56:01 <kmc> cicatristeza, most of that isn't online
00:56:05 <cicatristeza> ok
00:56:06 <kmc> but you can browse https://github.com/kmcallister
00:56:13 <roelvandijk> danr_: But when using all the nice symbols be carefull in what fonts they are supported.
00:56:35 <kmc> and my blog: http://mainisusuallyafunction.blogspot.com/
00:56:44 <kmc> you might like http://mainisusuallyafunction.blogspot.com/2010/10/tour-of-real-toy-haskell-program-part-1.html
00:57:42 <frerich2> kmc: Oooh,t hat looks nice, bookmarked it :-)
00:58:40 <cicatristeza> kmc: i do like it! thanks
00:59:20 <kmc> cicatristeza, Hackage packages I maintain: clogparse crc16-table crystalfontz debug-diff detrospector dewdrop gtfs hdis86 hexquote jspath patience posix-escape rowrecord spawn spool yices-easy
00:59:22 <danr_> kmc: Didn't know you write that blog. I really liked your slide First-Class Concurrency in Haskell with the Pi-calucus. Thanks
00:59:28 <kmc> thanks danr_ :)
00:59:46 <kmc> cicatristeza, they are mostly small things I've made for my own projects, not anything big or important
01:00:56 <cicatristeza> kmc: do you have a day job and how do you find the time to be so helpful in this channel?
01:01:13 <kmc> no day job at the moment
01:01:20 <erus`> what is the name of the system that converts a lexed file into a AST?
01:01:20 <kmc> i worked for Ksplice before they got bought by Oracle
01:01:20 <ddarius> Squirrels just climb up and put food in kmc's mouth.
01:01:25 <kmc> that's right
01:01:36 <kmc> erus`, a parser?
01:02:10 <erus`> AST to IR is a compiler or another parser?
01:02:21 <kmc> i would call that a compiler pass
01:02:24 <kmc> or stage
01:02:48 <kmc> most compilers have many IRs
01:09:39 <Gracenotes> what is tex for ++?
01:12:17 <augur> Gracenotes: what do you mean ++?
01:12:24 <augur> like, the special append ++?
01:12:36 <shachaf> The fancy connected ++, presumably.
01:12:44 <augur> +\!+
01:12:45 <Gracenotes> yeah
01:12:52 <augur> or +\!\!+
01:13:01 <augur> you'd be good to define a new command for that
01:13:38 <Gracenotes> hmm. looks a bit messy.
01:13:44 <kmc> heh
01:14:15 <Gracenotes> also, seems you need \, at the end, otherwise spacing is screwed
01:14:29 <kmc> what does lhs2TeX do?
01:15:08 <shachaf> http://people.cs.uu.nl/andres/lhs2tex/
01:18:16 <erus`> compiling is hard :( maybe its just too early in the morning
01:19:18 <ddarius> Depends on what you are compiling and to what.
01:19:26 <ddarius> Interpreting is, technically, harder.
01:19:34 <erus`> my IR interpretter is done
01:19:51 <erus`> i am now compiling lambdurp intermediate module representation to IR code
01:26:16 <erus`> I feel like I shouldn't enjoy writing this kind of thing.
01:26:56 <kmc> why
01:27:20 <ddarius> Perhaps enjoyment pains him?
01:28:10 <erus`> "I am writing a computer program that transforms a computer language I have invented into another computer language so that i can use the first language to program parts of a system in the second language" "Get away from me you nerd"
01:29:38 <ddarius> I designed and implemented a compiler (in x86 assembly) as part of an operating system kernel that I wrote to develop the operating system kernel.
01:29:49 <kmc> erus`, nerds are cool now, didn't you get the memo
01:32:05 <tpest> anyone has hear about the Lenny’s Lucky Lotto Lists
01:32:09 <tpest> ?
01:32:27 <ddarius> I'm going to guess that it is not related to Haskell or programming at all.
01:33:10 <tpest> its a problem i need to solve in haskell
01:33:22 <kmc> what's the problem?
01:33:28 <tpest> using dynamic programing
01:33:51 <tpest> Lenny likes to play the game of lotto. In the lotto game, he picks a list of N unique integers in the  range from 1 to M. If his list matches the list of N integers that are selected randomly, he wins.
01:34:03 <tpest> Lenny has a scheme that he thinks is likely to be lucky. He likes to choose his list so that each  integer in it is at least twice as large as the one before it. So, for example, if N = 4 and M = 10,  then the possible lucky lists Lenny could like are:
01:34:18 <tpest> 1 2 4 8  1 2 4 9  1 2 4 10  1 2 5 10
01:34:28 <tpest> Thus Lenny has four lists from which to choose.  Your job, given N and M, is to determine from how many lucky lists Lenny can choose.
01:34:40 <tpest> Input  There will be multiple cases to consider. The input for each is a pair of integers giving values for N and M, in that order. You are guaranteed that 1 <= N <= 10, 1 <= M <= 2000, and N <= M. The input for  the last case will be followed by a pair of zeroes.
01:34:49 <tpest> Output  For each case display a line containing the case number (starting with 1 and increasing sequentially),  the input values for N and M, and the number of lucky lists meeting Lenny’s requirements. The  desired format is illustrated in the sample shown below.
01:34:49 <kmc> don't paste your whole homework set here
01:34:52 <kmc> put it on hpaste.org or something
01:34:59 <shachaf> Or just link to it: http://poj.org/problem?id=2193
01:34:59 <tpest> ups
01:35:00 <frerich2> If this was Stackoverflow, my first question would be "Is this homework?".
01:35:01 <tpest> sorry
01:35:39 <companion_cube> frerich2: what does it change?
01:35:44 <erus`> how do i make either a monad again?
01:35:52 <kmc> import Control.Monad.Instances
01:36:15 <erus`> cheers
01:36:21 <kmc> tpest, you can view dynamic programming as a technique for speeding up a recursive computation
01:36:23 <frerich2> companion_cube: If it's homework, you shouldn't give the solution right away but just hints which get the guy asking the question on the right track
01:36:38 <kmc> by remembering the results of intermediate recursive calls
01:36:43 <companion_cube> uh, right
01:36:44 <tpest> ok
01:36:51 <kmc> in Haskell, I prefer to just write the recursion, and use http://hackage.haskell.org/package/data-memocombinators or http://hackage.haskell.org/package/MemoTrie
01:37:04 <cwl> is raise# a function?
01:37:12 <cwl> throw e = raise# (toException e)
01:37:15 <companion_cube> lookslike core
01:37:31 <Botje> # means "sharp corners: do not touch" :)
01:37:34 <kmc> looks like GHC internals
01:37:55 <kmc> raise# is a GHC-specific primitive function, I'll bet
01:38:10 <kmc> GHC allows the use of # in identifiers, as an extension
01:38:10 <cwl> kmc: so throw cannot be treeted as normal function?
01:38:24 <shachaf> throw can. You can just use it.
01:38:31 <shachaf> How it's implemented should be of no concern.
01:38:36 <kmc> you should read the documentation for throw, not its implementation
01:38:38 <cwl> shachaf: but it can change the control flow
01:38:50 <kmc> yes
01:38:52 <shachaf> Oh, in that sense.
01:39:00 <kmc> throwing exceptions from pure evaluation *is* a little weird
01:39:02 <kmc> but GHC allows it
01:39:15 <kmc> the semantics are those of "imprecise exceptions"
01:39:20 <cwl> Throw an exception.  Exceptions may be thrown from purely
01:39:24 <cwl> functional code, but may only be caught within the 'IO' monad.
01:39:44 <erus`> outrageous
01:39:50 <kmc> the denotation of (error "foo"  + error "bar") is a *set* of exceptions, because it's semantically undetermined which exception happens first
01:39:56 <shachaf> Exceptions are pretty much evil.
01:40:07 <tpest> thanks kmc
01:40:11 <erus`> shachaf: good for testing though
01:40:13 <tpest> i will read about that
01:40:17 <kmc> so catching is nondeterministic, which is fine, because it's an IO action
01:40:41 <kmc> shachaf, ;P
01:40:52 <shachaf> ?
01:40:54 <cwl> @type catch
01:40:56 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
01:40:56 <kmc> I think exceptions are a fine way to deal with errors from execution
01:41:09 <shachaf> Hmm.
01:41:18 <kmc> in that view GHC Haskell's exceptions are better than most languages'
01:41:45 <kmc> extending that with imprecise exceptions and asynchronous exceptions is more questionable
01:42:24 <hvr> kmc: what makes Haskell's exceptions better than other languages?
01:43:30 <kmc> IO actions are first-class so all the exception handling is done with ordinary functions
01:43:39 <kmc> and you can define your own exception-aware control flow operators
01:43:41 <kmc> in a simple clean way
01:43:57 <kmc> other languages tend to have special syntax for 'catch' and 'finally' and 'with' etc
01:44:01 <hvr> ic
01:44:34 * ddarius defined Try on an Either type in C#.
01:47:28 <Peaker> @hoogle try
01:47:28 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
01:47:29 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
01:47:29 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
01:47:32 <Peaker> ddarius: this one?
01:47:35 <erus`> :t (>>=)
01:47:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:47:51 <Peaker> or just a method taking various catchers?
01:48:08 <erus`> i allways forget that $ has lower prec than >>=
01:48:33 <shachaf> Simple rule: $ has lower precedence than everything.
01:48:34 <c_wraith> $ has the lowest possible precedence
01:48:47 <shachaf> Everything user-definable, that is.
01:49:35 <c_wraith> yes.  everything with lower precedence than $ is syntax
01:50:33 <tpest> how haskell implements sequencing ?
01:50:43 <kmc> what does that mean?
01:51:02 <tpest> like how it knows what value comes next
01:51:05 <kmc> what does that mean?
01:51:12 <ddarius> kmc: How does Haskell calculate your genome?
01:51:47 <kmc> tpest, are you asking about the evaluation of function calls and their results, or the execution of IO actions
01:52:04 <tpest> the evaluation of function calls and results
01:52:22 <kmc> ok
01:52:35 <kmc> the Haskell standard does not specify evaluation order
01:52:59 <kmc> most Haskell implementations use the lazy evaluation strategy
01:53:18 <Barbaren> I have a noob question: say I have a custom data type like so: "data Pie = Blueberry String | Raspberry String" and I want to write a function that matches but doesn't care whether it's a blueberry or raspberry pie... how do I write guards to match out the string and not care about the type?
01:53:29 <Barbaren> e.g. "is_tasty (_ string) = string
01:53:37 <kmc> data Flavor = Blueberry | Raspberry;  data Pie = Pie Flavor String
01:53:45 <tpest> oki thanks
01:53:46 <Barbaren> oh
01:53:50 <Barbaren> sweet
01:53:51 <Barbaren> thanks :D
01:54:38 <Peaker> Barbaren: kmc's way is better, but just of interest, there's also a possible (worse) way:  data Pie = Blueberry { name :: String } | Raspberry { name :: String }        Then you have:  name :: Pie -> String
01:54:39 <kmc> tpest, http://www.vex.net/~trebla/haskell/lazy.xhtml
01:55:07 <tpest> :) thx kmc
01:55:47 <kmc> tpest, in Haskell the evaluation order can't affect your program's correctness
01:55:52 <kmc> (until you care about performance)
01:55:54 <Peaker> (I think it would be nicer if Haskell made record fields fclabels rather than getters, and perhaps only allowed them without sums (so they're total) -- and also didn't have this feature that encourages duplicating same-name fields rather than factoring them out
01:55:58 <Barbaren> Peaker: ok, I'm not exactly sure if i understand that :p
01:56:18 <kmc> tpest, Haskell encourages you not to care about evaluation order, to think about what things mean but not how they happen
01:56:19 <kmc> (until you care about performance)
01:56:31 <tpest> i see
01:56:35 <Peaker> Barbaren: If you use record syntax and have the same field name in multiple constructors, you can use that field getter to extract the field from any of the constructors
01:59:46 * hackagebot geniplate 0.2.0.0 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.2.0.0 (LennartAugustsson)
02:02:38 <erus`> @hoogle (a -> m b) -> (c -> m d) -> a -> c -> m b d
02:02:38 <lambdabot> No results found
02:03:03 <erus`> i need a bind2 again
02:03:08 <erus`> how did i do this before...
02:03:10 <kmc> nothing could have that type;  you're using 'm' inconsistently
02:03:16 <kmc> does it have one type parameter or two?
02:04:14 <erus`> oh i used do last time :)
02:04:42 <erus`> is do cheating? do real haskell hackers use do?
02:04:48 <kmc> yes
02:05:06 <kmc> you should use 'do' when it produces nicer code than the alternatives
02:05:17 <kmc> i realize that is not very helpful advice :)
02:05:30 <kmc> if you show me what you're doing with 'do' i will make a recommendation
02:06:28 <hpaste_> erus` pasted “example” at http://hpaste.org/52399
02:07:08 <kmc> liftM2 IR.Function (compilePattern p) (compileExpression e)
02:07:17 <kmc> or liftA2
02:07:31 <kmc> or:  IR.Function <$> compilePattern p <*> compileExpression e
02:07:40 <kmc> using operators from Control.Applicative
02:08:05 <erus`> ah i remember those operators
02:08:27 <kmc> erus`, the sign is that you're binding variables in "do" but not using them until the last line, which is a "return"
02:08:39 <kmc> that's the pattern for liftA(n)
02:10:24 <kmc> the difference between Applicative and Monad is that Monad lets you use the results of an earlier action to decide which later action to perform
02:10:30 <kmc> that's what (>>=) does
02:11:00 <erus`> @hoogle liftA2
02:11:00 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
02:12:48 <erus`> @hoogle liftM2
02:12:49 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:23:29 <erus`> i think i rely on ghci too much
02:24:26 <shachaf> That's what it's for.
02:34:43 <rostayob> I have to build an applications to display large graphs, so you can zoom in and out, move and update the graph
02:34:46 * hackagebot geniplate 0.3.0.0 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.3.0.0 (LennartAugustsson)
02:35:19 <rostayob> I was thinking of using gtk2hs, is there any graph visualization library that would play nicely with that? so maybe something that works with cairo?
02:35:24 <rostayob> (i'm just guessing)
02:35:31 <dcoutts> rostayob: yep, Chart
02:36:04 <rostayob> dcoutts: well Chart seems to be to display charts and plots, not graphs
02:36:21 <dcoutts> oh you mean graphs as in nodes and edges?
02:36:23 <rostayob> I need to display large networks
02:36:25 <rostayob> dcoutts: yes
02:36:50 <rostayob> the only thing i know is graphviz but i'm not sure it's useful for an application like that
02:36:55 <dcoutts> use graphviz to generate .svg or .png and display those using gtk/cairo/cairosvg
02:37:28 <rostayob> dcoutts: well i imagine that wouldn't work well for a real time application like that
02:37:35 <quicksilver> graphviz is quite poorly suited to applications where you want to 'move' the graph
02:37:51 <quicksilver> at least it seems it's not designed for that case
02:37:55 <dcoutts> rostayob: right, if it needs to be interactive then that approach will not work
02:38:07 <quicksilver> interactive graph layout is Hard
02:38:10 <quicksilver> (or, at least, Fiddly)
02:38:12 <rostayob> quicksilver: that's the impression I had as well
02:38:15 <rostayob> quicksilver: mhm...
02:38:22 <dcoutts> and if you really mean real time, then yeah the graph layout is going to be a problem
02:38:47 <rostayob> dcoutts: well i mean "not too long delay"
02:39:18 <dcoutts> there's an app using wx that does some graph/network thing
02:39:48 <dcoutts> rostayob: http://wxhaskell.sourceforge.net/applications.html
02:40:25 <dcoutts> dunno if that lets you interact directly with the graph, or just scroll around / view it
02:40:50 <rostayob> dcoutts: that's interesting, thanks
02:41:09 <rostayob> I don't have to interact with the graph, i just want to visualize it nicely
02:41:53 <ClaudiusMaximus> "Blobs is a diagram editor for directed graphs. It is written in Haskell, using the platform-independent GUI toolkit wxHaskell. Blobs is a front-end for drawing and editing graph diagrams. " - but link on wiki is broken
02:43:45 <rostayob> I might just use graphviz, i think it can be good enough
02:44:36 <erus`> Protip: dont forget about scoping after writing 100 LOC of the compiler
02:44:45 <erus`> before*
02:46:28 * ddarius would recommend not forgetting about scoping ever.
02:48:04 <erus`> i should be writing code in java or c#
02:48:08 <erus`> so i can get a job
02:48:18 <ddarius> If you say so.
02:48:49 <dcoutts> rostayob: you might find that using .svg and rendering using the cairosvg package gives you faster scrolling than generating a big png
02:48:50 <erus`> on the jobs in kent website they all want .NET and java devs. there are a few php
02:48:57 * ddarius had never written any C# before he worked at a job that primarily used C#.
02:49:04 <dcoutts> rostayob: also, it's scalable of course, which might be handy for a viewer app
02:49:12 <rostayob> dcoutts: yep that's what i was thinking
02:49:28 <rostayob> is it possible to render just a region of a svg?
02:49:37 <rostayob> in cairo
02:50:01 <dcoutts> rostayob: well it clips automatically, and the stuff that's well outside the clipping region is I think a tad cheaper
02:50:23 <rostayob> dcoutts: cool, then yes i think that's the best solution
02:50:25 <dcoutts> rostayob: you're probably ok unless you've got massive networks
02:50:42 <rostayob> dcoutts: i might have really big networks, i am generating small world networks
02:50:54 <ddarius> erus`: If you want to get a "good" job, network.  If you just need -a- job, get a MSDN certification or some such.
02:51:30 <erus`> good idea
02:57:05 <dcoutts> rostayob: the rsvg lib can render specific svg elements by their xml id, but you'd need to know the relationship between location and id
02:58:57 <dcoutts> rostayob: or you could do the rendering yourself, based on position info returned by graphviz, see the graphviz package on hackage
02:59:28 <erus`> > ord 'a'
02:59:28 <lambdabot>   97
02:59:52 <erus`> > (ord 'a') :: Double
02:59:53 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
02:59:53 <lambdabot>         against inferred ty...
03:00:05 <rostayob> dcoutts: yeah i'll experiment with it, it seems pretty complete
03:00:06 <erus`> > (fromIntegral $ ord 'a') :: Double
03:00:07 <lambdabot>   97.0
03:06:23 <erus`> @hoogle a -> a -> [a]
03:06:23 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
03:06:24 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
03:06:24 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
03:06:38 <erus`> is there a (,) for lists?
03:09:25 <phasip> Hey, is there a function to call a function on all elements of two lists, eg func + [1,2,3] [1,2,3] should return [2,4,6]
03:09:43 <erus`> zipWith
03:09:44 <quicksilver> > zipWith (+) [1,2,3] [1,2,3]
03:09:45 <lambdabot>   [2,4,6]
03:09:50 <phasip> Thanks!
03:09:53 <idnar> erus`: what exactly do you want?
03:10:02 <idnar> erus`: the constructors for lists are [] and (:)
03:10:05 <quicksilver> I think erus wants (\a b->[a,b])
03:10:13 <idnar> ah
03:10:34 <idnar> @pl \a b -> [a,b]
03:10:35 <lambdabot> (. return) . (:)
03:10:37 <idnar> (but don't use that)
03:12:35 <erus`> @pl (\x y -> IR.Tuple [charToExp x, y])
03:12:35 <lambdabot> (IR.Tuple .) . (. return) . (:) . charToExp
03:13:19 <erus`> meh i think point free is worse here
03:15:38 <osfameron> just a bit ;-)
03:19:31 <erus`> writing a compiler isnt so hard :D
03:20:06 <erus`> pfff who needs university amirite
03:20:41 <ddarius> It isn't hard and you don't need university.
03:22:50 <erus`> one lambdurp is done i will probably get many offers to do a fully funded phd in compiler design
04:00:09 <kmc> erus`, writing a good compiler is hard, though
04:01:51 <aristid> kmc: like with most software
04:02:54 <kmc> yeah
04:03:04 <kmc> well "good" is a slippery open-ended thing that often has nothing to do with technical quality
04:03:16 <kmc> but probably less so for compilers
04:03:57 <erus`> whats the pattern for try this else try this else try this
04:04:14 <aristid> @hoogle orM
04:04:15 <lambdabot> Text.Parsec.Error addErrorMessage :: Message -> ParseError -> ParseError
04:04:15 <lambdabot> Text.ParserCombinators.Parsec.Error addErrorMessage :: Message -> ParseError -> ParseError
04:04:15 <lambdabot> Network.HTTP.Base defaultNormalizeRequestOptions :: NormalizeRequestOptions ty
04:04:30 <quicksilver> quite often that's mplus in a suitable monad, erus`
04:04:53 <kmc> or msum
04:04:55 <kmc> :t msum
04:04:56 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
04:05:01 <kmc> :t asum
04:05:02 <lambdabot> Not in scope: `asum'
04:05:14 <kmc> :t Control.Foldable.asum
04:05:15 <lambdabot> Couldn't find qualified module.
04:05:16 <erus`> msum gets the first?
04:05:23 <osfameron> I'd have thought *plus* would be more like 'and' behaviour, than 'or' ?
04:05:43 <kmc> it does whatever the MonadPlus instance for your monad says it does
04:06:23 <kmc> the laws are that mplus is associative and mzero is a left and right identity for it
04:06:39 <kmc> and (mzero >>= x) ≡ (x >> mzero) ≡ mzero
04:07:02 <erus`> i am doing a search over a few trees
04:07:28 <erus`> search a and if no result search b and if no result...
04:07:46 <erus`> so i can use maybe or something
04:07:56 <erus`> but at the same time it may throw an error :(
04:08:08 <erus`> so double monad house of pain
04:08:26 <kmc> the MonadPlus instance for Maybe is left-biased
04:08:40 <kmc> > Just 3 `mplus` Just 4
04:08:41 <lambdabot>   Just 3
04:08:45 <kmc> > Nothing `mplus` Just 4
04:08:46 <lambdabot>   Just 4
04:08:53 <erus`> ah perfect
04:09:20 <cwl> how to 'go to definition' for user defined function in leksah
04:11:05 <kmc> erus`, this is one of those nice situations where laziness makes your code more composable
04:11:27 <kmc> you can msum a list of map lookups and it will only perform lookups until it one succeeds
04:13:23 <aristid> :t Data.Foldable.asum
04:13:24 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Foldable.Foldable t, Alternative f) => t (f a) -> f a
04:23:08 <erus`> @hoogle find
04:23:08 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
04:23:09 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
04:23:09 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
04:23:19 <erus`> i wish hoogle was built into ghci
04:24:25 <aristid> erus`: you can in fact add hoogle to ghci
04:25:17 <aristid> erus`: install hoogle (cabal install hoogle), then add this to your .ghci file: :def hoogle \x -> return $ ":!hoogle \"" ++ x ++ "\""
04:26:29 <erus`> cool thanks :)
04:27:15 <erus`> is it a bug that haddock wont build (cabal install haddock) from the latest haskell platform?
04:28:38 <kmc> erus`, did you see http://hackage.haskell.org/package/goa
04:28:46 <erus`> hmm where is my .ghci ... i found ghci_history
04:28:56 <kmc> probably your home directory
04:28:58 <kmc> you might have to create it
04:31:12 <erus`> hoogle needs wget ...
04:32:01 <kmc> ?
04:32:13 <aristid> erus`: then you may need to install it
04:33:29 <erus`> windows needs a package manager
04:35:17 <aristid> hoogle could probably be patched not to rely on wget
04:35:20 <aristid> but...
04:35:37 <erus`> windows is so crap
04:36:29 <mm_freak> it's funny how all people seem to complain about windows, but yet they use it for no apparent reason
04:36:43 <erus`> work is a valid reason
04:36:53 <erus`> and perhaps games
04:36:55 <erus`> and drivers
04:37:14 <aristid> mm_freak: i'm trying to refrain from ranting about windows, because this channel is about haskell, not operating systems. but it is hard :D
04:38:29 <aristid> erus`: do you use haskell for work?
04:38:53 <erus`> no but i use haskell at work
04:39:15 <Axman6> what's the difference o.O
04:39:17 <erus`> Im an IT support monkey
04:39:29 <erus`> i work on my hobby projects when its quiet
04:39:33 <Twey> http://www.logilab.org/9861
04:39:49 <Axman6> ah, heh :)
04:40:03 <erus`> which is most of the day
04:40:32 <aristid> Twey: most of those are dead, it seems
04:40:38 <Twey> Yeah
04:41:49 <kmc> huh, i didn't know about this unsafeLocalState:  http://www.haskell.org/onlinereport/haskell2010/haskellch30.html#x38-28500030
04:42:58 <aristid> this seems to be a windows package manager: http://chocolatey.org/
04:43:08 <kmc> in current GHC it's an alias for unsafePerformIO, but maybe the intent is for it to have weaker guarantees
04:43:18 <kmc> does that mean unsafePerformIO isn't in Haskell 2010?  I didn't find it just now
04:45:06 <quicksilver> passed me by too kmc
04:47:22 <mm_freak> erus`: sure, if you're forced to use windows, there is little you can do
04:47:46 <quicksilver> kmc: see also this : http://www.haskell.org/pipermail/libraries/2011-July/016549.html
04:47:54 <mm_freak> but most people complaining about it don't actually use it at work
04:47:57 <kmc> mm_freak, two kinds of software, software people complain about and software nobody uses
04:48:17 <kmc> *nod*
04:48:23 <kmc> that's an interesting point
04:48:45 <kmc> i don't think the distinction between unsafePerformIO and unsafeDupablePerformIO is well-known
04:49:35 <aristid> kmc: i would have thought unsafePerformIO behaves like unsafeDupablePerformIO, naively
04:50:02 <kmc> people may use unsafeLocalState outside its preconditions
04:50:20 <kmc> and while they're wrong in doing so, introducing additional bugs in wrong code is still bad
04:50:30 <kmc> and might outweigh the performance justification
04:51:10 <kmc> it's a tricky decision, i think
04:51:59 <quicksilver> I side with Ross
04:52:09 <quicksilver> making broken code break is a feature not a bug
04:52:22 <quicksilver> but then I'm not the person who has to cope with the fallout :)
04:52:33 <phasip> Hey guys, another question. We have created a class named Tes (class Tes a where | func :: a -> Int ) if we copy paste this code int our module it works, but how should the file look and how do we use it if we want it in a separate file named Tes.hs ?
04:53:18 <kmc> quicksilver, I don't think it's a feature, not always
04:53:49 <kmc> I associate that attitude with the kind of egomaniacal assholes who poison open-source communities
04:54:24 <quicksilver> that sounds like a reasonable description of me, kmc
04:54:35 <kmc> in the real world, fixing broken code is not always an option
04:54:38 <quicksilver> except that I try not to contribute too much, so that the poison is not too widespread
04:54:52 * hackagebot parsec3 1.0.0.4 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.0.4 (ChristianMaeder)
04:55:01 <Botje> phasip: pretty much the same. except you stick something like "module Tes where" at the top of that file.
04:55:22 <kmc> there was a recent shitstorm where glibc introduced an implementation of memcpy() which copies data starting at the end
04:55:38 <kmc> which is allowed by the documentation of memcpy() -- if your regions overlap, you should use memmove() instead
04:55:56 <phasip> then we get the problem "func is not a visible class of
04:55:57 <kmc> but it broke a lot of Linux software people need, including closed-source things which can't easily be fixed
04:56:08 <quicksilver> and in GHC at least, you call the file 'Tes.hs' and put it in the same place as your other .hs file, and you put import Tes; in that file
04:56:14 <Botje> why would moving stuff from the end be better?
04:56:14 <erus`> is it faster to do it from the back?
04:56:24 <quicksilver> kmc: seriously it is, of course, a question of degree and circumstance.
04:56:39 <kmc> erus`, it was on certain particular CPUs
04:57:09 <quicksilver> kmc: breaking software gratuitously is extremely funny^W^Wobviously not reasonable; on the other hand, maintaining bug-compatibility for ever with every version you released is not necessarily the right use of (always limited) resources.
04:57:10 <kmc> it's not clear that ruining a bunch of people's day was worth winning at some dubious microbenchmark
04:57:15 <aristid> kmc: to make the decision, it has to be known how localised the fallout of changing unsafeLocalState would be
04:59:01 <kmc> *nod*
04:59:12 <kmc> it is a difficult tradeoff
04:59:36 <aristid> kmc: isn't unsafePeformIO the more well-known function?
05:00:04 <kmc> and there are certain... strong-spoken individuals... in open-source communities who ignore the pragmatic tradeoff and base all decisions on a formal pedantic reading of the rulebook
05:00:14 <kmc> and say that anyone who's negatively impacted is an idiot
05:00:27 <kmc> aristid, compared to?
05:00:36 <quicksilver> compared to unsafeLocalState
05:00:43 <aristid> kmc: as quicksilver said
05:00:45 <kmc> i think so
05:00:49 <phasip> now we have a file named Tes.hs with the content module Tes where | class Tes a where | func :: a->Int and the other file has import Tes, still getting the problem =/
05:01:03 <quicksilver> based on my survey of leading haskell commentators, unsafeLocalState was entirely unknown.
05:01:14 <aristid> phasip: do you import Tes?
05:01:14 <quicksilver> [*] survey consisted of two people in #haskell today.
05:01:33 <aristid> quicksilver: that's scientific enough for me!
05:01:43 <quicksilver> phasip: probably some simple mistake but much easier to help you if we get the exact error messgae.
05:01:43 <hpaste_> rata pasted “Ambiguous type variable” at http://hpaste.org/52403
05:01:50 <aristid> .oO(he used the word "survey", very scientific)
05:02:08 <phasip> Never mind, typo =/ , Sorry and thanks!
05:02:16 <quicksilver> :)
05:03:38 <rata_> do you know how I may solve the problem I'm having with two related type classes in http://hpaste.org/52403?
05:03:42 * frerich2 thinks the swear word 'shitstorm' is kinda funny; I'll put it onto my list of funny words, right next to 'fuckwit'. Thanks kmc!
05:04:00 <ion> It’s a swear word?
05:04:02 <rata_> I've tried many different things, but nothing has worked so far
05:04:07 <erus`> @google shitstorm
05:04:08 <lambdabot> http://www.urbandictionary.com/define.php?term=shitstorm
05:04:09 <lambdabot> Title: Urban Dictionary: shitstorm
05:04:50 <frerich2> Oh, I didn't know it's slang.
05:05:03 <frerich2> But the thesaurus for the word is hilarious.
05:05:12 <Axman6> frerich2: i've always quite liked cockspank, though it's not widely used. "you're such a cockspank"
05:05:23 <quicksilver> rata_: "transitions" has a surprising type. are you sure this is what you want?
05:05:24 <rata_> I've also tried functional deps, but didn't work either
05:06:04 <quicksilver> that's not really answering anything.
05:06:13 <quicksilver> there are all kinds of ways you could try functional deps ;)
05:06:18 <Axman6> that is indeed a very strange type.
05:06:21 <quicksilver> are you sure transitions has the type you want?
05:06:24 <rata_> quicksilver: well, I want to get a list of actions from "transitions state"
05:06:34 <quicksilver> rata_: but the caller gets to choose the tyep of action
05:06:51 <quicksilver> so every 'State' type you define has to be prepared to produce a list of actions for any possible Action type (chosen by the caller)
05:07:34 <rata_> I see your point, but I don't know how to say "deliver the corresponding action"
05:07:37 <quicksilver> it seems more likely you expect each State type to have a specific Action type
05:08:01 <quicksilver> rata_: have you written a program using typeclasses like this before? I only ask to try to judge your level of haskell experience.
05:08:18 <cicatristeza> i like the package HaskellForMaths, is the author here?
05:08:24 <quicksilver> I'm only trying to guess what your code does based on variable names etc, but it smells to me like you shouldn't be using typeclasses at all
05:08:46 <rata_> quicksilver: my level of haskell experience is very basic
05:09:14 <quicksilver> I would recommend trying to write this program with concrete types and not typeclasses at all
05:09:30 <quicksilver> add a typeclass once you're convinced some kind of overloading is appropriate
05:09:43 <quicksilver> (typeclasses are for overloading, they're not a general abstraction for interfaces)
05:09:49 <rata_> why shouldn't I? Metropolis is a generic algorithm that can be used with other kinds of states, transitions and energy functions
05:10:30 <rata_> you mean typeclasses are not a way to abstract behaviours?
05:10:33 <quicksilver> rata_: well I don't know what you're doing, so I can't give a satisfactory answer. I can only say that your code looks like it's written by someone who misunderstands type classes.
05:10:41 <quicksilver> correct. typeclasses are not a way to abstract behaviours.
05:10:47 <quicksilver> typeclasses are a way to overload function.
05:11:07 <rata_> weird, what do you use then to abstract behaviours?
05:11:19 <quicksilver> data types. Parametric polymorphism.
05:11:30 <quicksilver> parametric data types sometimes. (Which is the same, I suppose)
05:11:50 <quicksilver> "Metropolis is a generic algorithm that can be used with other kinds of states, transitions and energy functions"
05:12:01 <quicksilver> ^^ the simplest interpreation of this is that State is one type (not a class)
05:12:17 <quicksilver> and probably transition is a type, although maybe it's part of the definution of State.
05:12:22 <rata_> but a type is a concrete implementation
05:12:33 <kmc> not always
05:12:45 <kmc> http://haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
05:12:47 <rata_> you mean type variables?
05:12:52 <kmc> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
05:13:01 <kmc> "what do you use then to abstract behaviours?"   functions.
05:13:59 <kmc> Java says "new behavior implies new type".  not so in Haskell, where behaviors are first-class values
05:14:33 <erus`> > msum [Nothing, Just1]
05:14:34 <lambdabot>   Not in scope: data constructor `Just1'
05:14:37 <erus`> > msum [Nothing, Just 1]
05:14:38 <lambdabot>   Just 1
05:14:48 * frerich2 noticed that whenever he has the urge to whip up a type class, he is usually much better served by passing some function as an argument.
05:15:00 <kmc> *nod*
05:15:12 <kmc> type class overuse is a common problem
05:15:21 <kmc> especially among beginners, but i see it everywhere
05:15:25 <quicksilver> frerich2: the first rule of typeclasses : if you think you want to write a new typeclass, think again.
05:15:38 <kmc> sometimes a new class *is* the best solution, for some non-obvious reason
05:15:41 <kmc> so maybe i am too hasty to judge
05:15:56 <quicksilver> well I get biased by the code I see here
05:15:59 <kmc> i definitely wrote a lot more type classes when I was new to haskell
05:16:14 <quicksilver> most times I see people use typeclasses they've made the problem more fiddly/more complex by doing so.
05:16:16 <kamaji> is Data.HashTable the best implementation to use? Also, can it be used with Data.Containers?
05:16:21 <kmc> and I wasn't even particularly from a Java background
05:16:31 <kmc> Data.HashTable is seldom used
05:16:42 <kamaji> what should I use instead?
05:16:43 <Axman6> hashtables are pretty unhaskelly
05:16:48 <frerich2> quicksilver: Can that be extended to "If you think you need to write a new type class, think again - even when taking quicksilvers' rule into account"?
05:16:49 <kmc> kamaji, do you really want mutable hash tables in the IO monad?
05:16:54 <kmc> http://hackage.haskell.org/package/unordered-containers is nicer to use
05:17:06 <Axman6> kamaji: start with a Map
05:17:11 <erus`> @hoogle msum
05:17:11 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
05:17:11 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
05:17:30 <kamaji> Axman6: Map isn't O(1) lookup is it?
05:17:43 <Axman6> no
05:17:43 <kmc> ugh i'm sick of this "O(1)" myth
05:17:46 <kmc> about hash tables
05:17:56 <Axman6> but find out whether you need that before complaining ;)
05:17:58 <kmc> unordered-containers is "O(1)" as much as hash tables are
05:18:02 <kmc> kamaji, did you benchmark your code?
05:18:18 <fasta> Does anyone know what happened to 'Delta debugging'?
05:18:24 <kamaji> I'm just reading
05:18:26 <Axman6> hashtables are O(k) where k is the amount of time it takes to hash your keys
05:18:29 <fasta> I.e., http://www.st.cs.uni-saarland.de/dd/
05:18:30 <mm_freak> kamaji: it's O(log n), and yet your lookups may be faster with Map
05:18:43 <kmc> you can't index n bytes of memory in O(1) anything
05:18:58 <aristid> Axman6: well, don't forget collisions
05:19:06 <Axman6> kamaji: depends on how big your constants are :P
05:19:15 <kmc> kamaji, on modern systems the difference between some theoretical O(log n) and O(1) is going to be dwarfed by real-world considerations like the relative number of cache misses
05:19:28 <mm_freak> kamaji: hash tables are commonly asked for in haskell, but you really don't want them
05:19:43 <kmc> (and tree-based structures probably do worse there, but that's where you should be looking, not at an irrelevant theoretical result)
05:19:51 <mm_freak> they are slow for lookups (because of the hashing) and for modifications (because of possible growth)
05:19:56 <Axman6> aristid: can't you amortise (sp?) that with better collision handling... things... damn, it's too late to think of words >_<
05:20:10 <kmc> i'm excited for unordered-containers to get packed 16-ary nodes
05:20:14 <kmc> that should improve cache behavior significantly
05:20:38 <mm_freak> kamaji: in general if you want a fast container and don't know which one to use, use Data.Map
05:20:53 <aristid> Axman6: i think it's kind of the opposite of amortisation
05:20:53 <mm_freak> in fact i only use Data.Map and Data.Vector for most things
05:21:20 <aristid> Axman6: or do you mean that you could just increase the size of the table repeatedly?
05:21:24 <Axman6> aristid: also, doesn't growing the hashtable when it gets too full help too?
05:21:30 <Axman6> yeah
05:21:37 <aristid> Axman6: well i'm too stupid to calculate that :)
05:21:55 <hpaste_> erus` pasted “fromJust ” at http://hpaste.org/52404
05:21:55 <Axman6> me too, i was quite happy to accept it when taught it :P
05:22:22 <erus`> kmc: can i make that nicer?
05:22:26 <mm_freak> kamaji: note also that Data.Map plays very well with laziness…  you can use it in pure code without losing performance, whereas for hash tables you need IO or have to copy the whole structure over and over
05:22:45 <kmc> :t fromMaybe  -- erus`
05:22:46 <lambdabot> forall a. a -> Maybe a -> a
05:23:13 <mm_freak> ok, i noticed that i mixed two unrelated concepts in my last line, but anyway, it's still true =)
05:24:56 <engla> what about unordered-containers and HAMt?
05:25:18 <mm_freak> kmc: i prefer 'maybe def id' over fromMaybe
05:25:30 <mm_freak> less to type, defined in the prelude and only one combinator for one purpose
05:25:46 <kmc> *nod*
05:25:50 <kmc> engla, what about them?
05:25:55 <aristid> !cal length . ["maybe id", "fromMaybe"]
05:26:01 <aristid> > length . ["maybe id", "fromMaybe"]
05:26:03 <lambdabot>   [8,9]
05:26:10 <aristid> damn, too many mueval bots with different syntax :D
05:26:24 <engla> kmc: I should have asked mm_freak directly. as alternatives to Data.Map
05:26:27 <quicksilver> mm_freak: I think the idea of having a shortcut for "flip maybe id" is entirely reasonable, actually. It's a common pattern.
05:26:31 <kmc> ah, they were mentioned above
05:26:34 <aristid> mm_freak: so it's actually shorter in terms of characters, but fromMaybe feels shorter to me :)
05:26:36 <quicksilver> I'm not very fond of fromMaybe as a name, though
05:26:50 <quicksilver> I don't know why not. It's just unaesthetic to me.
05:27:04 <kmc> kamaji, mm_freak, yeah, these pure data structures which return a "new copy" on update are not actually copying very much
05:27:07 <quicksilver> it doesn't tell you anything about *how* it converts from a Maybe.
05:27:10 <aristid> quicksilver: which name would you prefer?
05:27:13 <kmc> that's a huge underappreciated area of data structures, imo
05:27:16 <mm_freak> quicksilver: should be named runMaybe or something+
05:27:19 <kmc> and they'd be useful in traditional imperative languages too
05:27:27 <engla> HAMT for haskell: http://blog.johantibell.com/2011/09/slides-from-my-haskell-implementors.html (slides)
05:27:31 <aristid> quicksilver: maybeDef?
05:27:38 <quicksilver> aristid: I don't know. the name 'fromMaybe' sounds like it could be fromJust
05:27:46 <aristid> quicksilver: hah
05:27:47 <quicksilver> I know it isn't. I'm just saying, the name is uninformative.
05:28:07 <quicksilver> maybeDef would be better but gratuitous abbreviation of words is never nice
05:28:24 <kamaji> I'm having trouble accepting that "You don't need a hashtable"
05:28:51 <kmc> why
05:28:54 <kamaji> there seem to be plenty of people who need one, and the Judy package seems to exist to cater exactly to that
05:29:06 <kamaji> as a general answer
05:29:16 <kmc> judy is not a hash table
05:29:36 <kmc> it's based on specialized fat trees
05:29:38 <quicksilver> nobody needs a hashtable; people need data structures which are "fast enough" for their purposes.
05:29:51 <kmc> there's a big doc amount how they work
05:29:58 <quicksilver> IntMap, Map, Sequence and HAMT are all fast.
05:30:06 <quicksilver> Data.Hashtable happens to be somewhat slow.
05:30:07 <kmc> there's no hashing at all -- they just take Int keys, much like IntMap
05:30:31 <quicksilver> which one is fast enough for you - well, that depends what you're doing. Only a benchmark can tell you for sure.
05:30:32 <kamaji> oh ok
05:30:36 <quicksilver> but don't be mislead by O(lies)
05:30:40 <kmc> unordered-containers *is* hashing-based, but is also a tree-shaped pure data structure with efficient functional updates
05:30:46 <quicksilver> no hashtable is O(1).
05:30:54 <mm_freak> kamaji: a hash table is fast in the specific corner case, where you can precalculate all hashes and do /only/ lookups and modifications, never insertions
05:31:07 <mm_freak> kamaji: and even then, a Map may still be faster
05:31:18 <mm_freak> i recommend you to benchmark instead of just rejecting our suggestions
05:31:22 <quicksilver> unless you have precalculated hashes, that's true.
05:31:29 <quicksilver> but precalculated hashes is pretty unusual.
05:31:41 <kamaji> Well actually I'm not writing much yet
05:31:44 <kmc> kamaji, I wouldn't say that nobody ever needs a flat, imperative hash table.  but from experience, the vast majority of people here who ask after a "hash table" are just looking for a fast-enough associative data structure
05:31:45 <kamaji> just looking about perfect hashing
05:31:55 <kamaji> wondering what it would be like to do in haskell
05:31:56 <kmc> and they leave quite happy with Map, IntMap, HashMap, etc.
05:32:03 <kmc> which are all much nicer to use than an imperative hash table
05:32:07 <kmc> nicer in Haskell, nicer in general
05:32:29 <mm_freak> kamaji: a fast hash table would require IO for modifications in any case, so it wouldn't be nice to work with
05:32:35 <mm_freak> that's why nobody uses hash tables in haskell
05:32:40 <kamaji> Why does it need IO?
05:32:48 <kamaji> The tree structures are copied, right?
05:32:49 <kmc> because it's updating memory in-place
05:32:53 <mm_freak> kamaji: because otherwise you will be copying around
05:32:54 <kamaji> "copied"
05:33:02 <kmc> kamaji, a flat table would need a full copy
05:33:12 <kmc> a tree-shaped structure (including a hash trie) would not
05:33:13 <kamaji> Why doesn't a tree?
05:33:14 <kmc> does not
05:33:19 <mm_freak> the tree structure in a Map is not copied…  only the part that has changed and the path to it is copied
05:33:26 <kmc> kamaji, because you can point into the nodes of the old tree
05:33:43 <kamaji> oh, because it's recursive?
05:33:47 <mm_freak> if the old map is forgotten after the update, then that's a very quick and memory-saving operation
05:33:57 <kmc> insert x (Node y a b) | x < y = Node y (insert x a) b
05:34:06 <kmc> note that 'b' is repeated on the right-hand side unmodified
05:34:08 <mm_freak> if the old map is not forgotten, then you have two paths, but not two whole maps
05:34:11 <kamaji> Possibly dumb question, is it not possible for the compiler to understand which parts have changed and update in place?
05:34:18 <kmc> that means (with typical implementations) that you reuse the same pointer into the old tree
05:34:28 <kamaji> or does that break other references to the table
05:34:40 <quicksilver> kamaji: theoretically possible, but nobody does that in practice, partly for the reason you just said.
05:35:10 <kmc> theoretically very hard
05:35:21 <quicksilver> optimising code which converts persistent structures to use mutation under the hood has been *written about* a lot, but I don't think anybody has found a practical way to do it.
05:35:34 <mm_freak> i think hash tables have become so popular, because of the imperative programming languages, which make it insanely difficult to implement efficient data structures like trees
05:35:59 <kmc> s/imperative/bad/
05:36:03 <kmc> Haskell is an imperative language
05:36:08 <mm_freak> true
05:36:10 <kmc> imperative languages don't need to be bad, they just tend to be
05:36:15 <mm_freak> s/bad/mainstream/
05:36:41 <kmc> also some languages are explicitly low-level by design
05:36:50 <kmc> in C you are expected to re-implement all data structures in every project
05:37:06 <mm_freak> yeah
05:37:13 <kmc> and it's easier to implement a flat hash table than a tree-based map that doesn't suck
05:37:14 <mm_freak> well, unless you work with unsafe pointers, of course
05:37:35 <kmc> no, even then
05:37:39 <kamaji> err, why are you expected to reimplement all the data structures?
05:37:44 <kamaji> I don't think that's true :P
05:37:45 <kmc> because that's just how it's done in C
05:37:52 <kamaji> they do have libraries
05:37:53 <fasta> I think we should get rid of every developer having to figure out which tiny constants are best for his/her system or platform.
05:37:57 <mm_freak> kmc: you can write a library
05:37:58 <kmc> what's the standard data structures library for C, kamaji?
05:38:04 <sipa> every language is imperative (use IO in Haskell), functional (implement function objects yourself in C++), objective (use eg. GTK's pointer casting to get OOP in C), logical (implement unification yourself, ...), ...
05:38:07 <mm_freak> but indeed, thinking of it, i always reimplemented all data structures in C
05:38:08 <kamaji> there isn't one, but there do exist many
05:38:11 <kmc> mm_freak, C programmers won't use it
05:38:13 <mm_freak> never used libraries for that
05:38:15 <sipa> the question is to what extend a language encourages a certain paradigm
05:38:24 <kmc> because re-implementing every data structure is how you prove you have a bigger penis than the other C programmers
05:38:36 <mm_freak> sipa: brainfuck is not functional
05:38:42 <mm_freak> and no, that's not a joke
05:38:46 <fasta> We should be able to just say 'platform: 400MB memory, speed 4000BogoMips' and get the data structures rolling out of them automatically.
05:39:20 <fasta> Or, platform: 'realtime'.
05:39:23 <mm_freak> fasta: huh?
05:39:35 <mm_freak> that information is totally unrelated to what data structures you use
05:39:41 <fasta> mm_freak: no, it is not.
05:39:44 <mm_freak> s/use/should use/
05:40:06 <fasta> mm_freak: data structures have time and space trade-offs associated with them.
05:40:14 <mm_freak> fasta: the specification should be:  "fast lookup, slow insertion"
05:40:20 <kamaji> fasta: it's a bit complicated though
05:40:30 <fasta> mm_freak: I was not saying it was a complete specification.
05:40:33 <cicatristeza> how do i use dropWhile to drop all zeroes from a list?
05:40:37 <kamaji> could always run a profiler to determine it :P
05:40:39 <fasta> mm_freak: also, I disagree with it being a compile time option.
05:40:41 <quicksilver> cicatristeza: you don't.
05:40:43 <cicatristeza> dropWhile (0) k?
05:40:43 <quicksilver> cicatristeza: you use filter.
05:40:48 <cicatristeza> aha
05:40:50 <fasta> mm_freak: it should run at run-time.
05:40:53 <mm_freak> fasta: that specification would always give you Vector as the most efficient data structure, which is wrong in most cases
05:40:56 <quicksilver> cicatristeza: dropWhile only drops things from the front
05:40:58 <cicatristeza> filter (0) list?
05:41:03 <kmc> filter (/= 0) list
05:41:06 <quicksilver> cicatristeza: no, the first argument to filter is a function.
05:41:06 <kmc> it takes a function
05:41:10 <mm_freak> you /need/ to specify characteristics of your data structure
05:41:11 <fasta> mm_freak: no, it wouldn't.
05:41:23 <mm_freak> fasta: when would it prefer Map over Vector?
05:41:32 <cicatristeza> kmc: wouldnt that leave behind everything that is NOT zero?
05:41:40 <fasta> mm_freak: if it determines that at run-time it is faster.
05:41:53 <mm_freak> fasta: how does it do that?  does it solve the halting problem?
05:41:55 <kmc> cicatristeza, use the one you want
05:42:01 <kmc> filter (/= 0) or filter (== 0)
05:42:08 <kamaji> mm_freak: estimates*
05:42:14 <yitz> > filter even [1..10]
05:42:15 <lambdabot>   [2,4,6,8,10]
05:42:21 <cicatristeza> sorry: will filet (==0) list give me the list with zeroes only, or without?
05:42:23 <fasta> mm_freak: it doesn't. It just runs the same application with multiple datastructures in parallel and takes whatever finished first.
05:42:27 <cicatristeza> *filter
05:42:34 <fasta> mm_freak: it could do this based on sampling or continuously.
05:42:41 <yitz> > filter (/=0) [-3..3]
05:42:42 <lambdabot>   [-3,-2,-1,1,2,3]
05:42:49 <yitz> > filter (==0) [-3..3]
05:42:49 <lambdabot>   [0]
05:42:56 <cicatristeza> i got it fromhoogle, thanks
05:43:01 <fasta> mm_freak: in the end, all programmers want is select certain elements from a set with certain properties as fast as possible.
05:43:02 <aristid> :t partition
05:43:03 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:43:10 <fasta> mm_freak: or update, etc.
05:43:12 <kmc> cicatristeza, you could test it in GHCi, or with lambdabot, or read the documentation
05:43:36 <mm_freak> fasta: so it's about speed, not memory?
05:43:43 <aristid> > partition (==0) [-3..3]
05:43:44 <lambdabot>   ([0],[-3,-2,-1,1,2,3])
05:43:47 <fasta> mm_freak: you can do the same for memory, obviously.
05:44:39 <mm_freak> fasta: faster data structures will need more memory usually…  i don't think it would work
05:44:52 <fasta> mm_freak: I think you are misunderstanding me on purpose.
05:45:05 <mm_freak> no, i'm not
05:45:08 <fasta> I doubt quicksilver doesn't understand what I mean for example.
05:45:19 <yitz> fasta: not fair quicksilver reads minds
05:45:26 <mm_freak> but i'm saying your specification is unrelated to the problem you want to solve
05:45:40 <mm_freak> fasta: i'd prefer to specify certain operation characteristics and have an answer right away
05:46:03 <fasta> mm_freak: that's a lower abstraction level.
05:46:17 <fasta> mm_freak: your model requires information about the future where mine doesn't.
05:46:19 <mm_freak> for example when i say that i need O(1) insertion, then i automatically rule out vectors and maps
05:46:31 <mm_freak> true, but yours needs computing power
05:46:43 <fasta> mm_freak: sure, but you could use mine for the 'testing environment'.
05:46:53 <fasta> mm_freak: then you could get the 'production version' compiled out of that.
05:47:23 <mm_freak> then you can't adapt at production time…  it may turn out that your test environment didn't really match production conditions
05:47:43 <fasta> mm_freak: if your production environment is really big, you don't need the compiled version.
05:47:54 <fasta> mm_freak: I was thinking of embedded platforms in the last case.
05:48:11 <fasta> If you want to cater to everyone, you need both.
05:48:47 <mm_freak> then again you're wasting production cycles, where using an intelligently chosen data structure could make better use of them
05:49:32 <fasta> I think the costs of using such automatic selection are far lower than the costs of manually having to run benchmarks and having to reinitialize the system manually.
05:49:59 <fasta> Manually as in having discussions whether or not to switch to a new structure X.
05:50:23 <fasta> These approaches would fit nicely within e.g. Google and if they are smart they are already doing similar things.
05:50:47 <mm_freak> i think, google rather goes the manual way =)
05:51:56 <mm_freak> i believe your approach won't work as good as you imagine
05:52:38 <mm_freak> you will need to make a different intelligent tradeoff here:  how much resources and what kind of resources to allocate to the benchmarker
05:52:58 <Axman6> anyone have any useful nemonics for remembering things like whether filter filters in or out based on the predicate, or the order of arguments to foldl?
05:53:21 <mm_freak> Axman6: intuition mostly
05:53:53 <mm_freak> Axman6: also i always have my local haddock docs open in a browser
05:55:35 <Jafet> Axman6: use them more
05:56:21 <mm_freak> Jafet: he should use foldl more?
05:56:23 <mm_freak> really?
05:57:17 <Jafet> Yeah, and call it foldl'
05:57:23 <Axman6> foldr is easy to remember, because of the list identity/how foldr f z [a,b,c] :: Expr looks, but i've never been able to remember the foldl order
05:57:50 <Jafet> foldl (flip f) z [a,b,c]
05:57:50 <Axman6> so, i can never remember if i should write foldl (\acc x ->...) or foldl (\x acc -> ...)
05:58:35 <quicksilver> I just check the type in ghci
05:58:40 <quicksilver> i don't use foldl very often though
05:58:42 <fasta> Axman6: that is why Smalltalk and Common Lisp uses :acc acc :element some_element.
05:58:43 <frerich2> A little offtopic: what does the Haskell logo (as shown on haskell.org) represent? A lambda character intermingled with the '>=' operator?
05:58:59 <quicksilver> frerich2: it's supposed to be lamdba intermingled with >>=
05:59:05 <frerich2> Aah.
05:59:07 <fasta> frerich2: the state of a disturbed mind.
05:59:14 <quicksilver> I think it's a bad deicision on multiple levels ,but that's voting for you.
06:00:30 <fasta> quicksilver: since when do we have that logo? I think the vote I followed on the mailing list years ago didn't vote for that one. Did we get a new one?
06:01:26 <quicksilver> the \= train operator logo was the one that won the 2009 contest, fasta
06:01:35 <mm_freak> i like the logo…  it looks modern and i associate it with speed
06:01:44 <hpaste_> erus` pasted “help” at http://hpaste.org/52405
06:01:56 <erus`> kmc how can i do this?
06:02:01 <mm_freak> because it kind of looks like moving fast to the right
06:02:40 <mm_freak> the old logo was much more horrible =)
06:02:40 <quicksilver> erus`: probably simplest to return Either CompilerError (Maybe IR.Expression)
06:02:51 <quicksilver> mm_freak: the old logo was worse, yes :)
06:02:52 <fasta> Lots of logos are really, really badly done. See http://www.haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
06:02:59 <kmc> erus`, do you mean (Just . Right) instead of Just ?
06:03:15 <fasta> I would say 80%+ shouldn't really even be there.
06:03:34 <quicksilver> fasta: Yes. well 99% didn't win the contest :)
06:03:41 <kmc> you mean functional programming skill does not equate to graphic design ability?
06:03:45 <erus`> no because if it fails it returns an Either rather than a maybe
06:03:48 <fasta> kmc: exactly.
06:03:56 <kmc> http://www.cs.earlham.edu/~jeremiah/linux-pix/linux-logo.html
06:04:05 <kmc> http://www.cs.earlham.edu/~jeremiah/linux-pix/linux20shark.jpg love this one
06:04:13 <quicksilver> fasta: personally I liked the ideas in Cale's lambda-mountain idea (search for his name) although for a winning entry I'd have wanted it simplified/stylised so it worked better as a logo.
06:04:45 <fasta> quicksilver: that one has some quality, but why mountains?
06:04:46 <kmc> obviously some of these are jokes as well
06:05:07 <kmc> the http://cufp.org/ logo is fantastic
06:05:14 <burp> http://www.haskell.org/wikiupload/f/f3/UnsafeHaskell.png
06:05:16 <burp> LOL
06:05:17 <kmc> so businessey
06:05:24 <fasta> He already mentions it, but well, I don't really buy into that.
06:05:27 <kmc> then oh shit hidden lambda!
06:05:38 <quicksilver> fasta: why not? it's a memorable simple image. mountains reflect size, strength, solidity, these are reasonable associations.
06:06:28 <mm_freak> quicksilver: also steady, slow moving
06:06:36 <kmc> these are decent too http://www.haskell.org/haskellwiki/Image:Sgf.png
06:06:47 <ion> Also something you don’t want to drop on you from the sky.
06:07:01 <mm_freak> really i think the current logo is great
06:07:05 <kmc> me too
06:07:11 <ion> yeah
06:07:15 <mm_freak> it's simple and has a speed to it
06:07:21 <kmc> it's regrettably similar to the old Amtrak logo
06:07:34 <fasta> In some sense the idea of the UnsafeHaskell one is good.
06:07:35 <kmc> http://upload.wikimedia.org/wikipedia/en/8/8b/AmtrakLogo.png
06:07:39 <erus`> oh god i am confuse
06:07:44 <kmc> "avoid success at all costs" right?
06:07:50 <fasta> So, you have purity, but you can escape it too.
06:07:52 <kmc> so we should have picked the ugliest logo
06:07:56 <mm_freak> kmc: i wouldn't confuse those two
06:08:00 <kmc> full of nerd in-jokes with no graphic design sense
06:08:00 <fasta> There are languages which don't even offer the escape.
06:08:02 <ion> Programmer art is strong in this one. http://www.cs.earlham.edu/~jeremiah/linux-pix/linux-logo.html
06:08:13 <mm_freak> particularly the amtrak logo doesn't look fast
06:08:19 <kmc> that's appropriate then
06:08:42 <frerich2> http://blog.webspecies.co.uk/media/haskell.jpg <-- that's the old logo, which everybody seems to frown upon?
06:08:49 <kmc> yeah
06:08:53 <kmc> that one's pretty bad
06:09:06 <quicksilver> kmc, ion, mm_freak: well I'm glad some people like it :)
06:09:21 <quicksilver> I'm not suggesting anyone would *confuse* it with the amtrak logo
06:09:27 <quicksilver> it's just that it evokes it, for me
06:09:31 <quicksilver> and the old british rail one, too
06:09:41 <burp> http://pixel2pixel.files.wordpress.com/2011/02/lambda.gif I vote for this ;-)
06:09:43 <quicksilver> http://www.crwflags.com/fotw/images/g/gb_brail.gif
06:09:53 <fasta> Imagine old Amtrak would use Haskell.
06:09:53 <kmc> the old Haskell logo is perfect for avoiding success at all costs
06:09:58 <kmc> ugly, complicated, full of scary maths
06:09:59 <mm_freak> lol burp
06:10:17 <fasta> Nah, that won't ever happen :)
06:10:29 <mm_freak> quicksilver: now that logo doesn't really look similar to haskell's
06:10:53 <mm_freak> kmc: and also contains a symbol from a haskell extension
06:11:06 <quicksilver> burp: in fact, it's a shame about half-life because I think we chose to reject a lot of "lamdba in a circle" ideas, and a simple lambda-in-a-circle could have been a good basis.
06:11:14 <kmc> well ⇒ and → are extensions too
06:11:19 <mm_freak> the forall symbol doesn't really belong there
06:11:22 <kmc> unless you mean to use them as ordinary infix operators, but that would be a Terrible Idea
06:11:32 <quicksilver> what is certainly true is that the logo which was chosen *does* satisfy the objective criteria
06:11:36 <erus`> @undo do { (Just firstSib) <- find ((id ==) . bindingId) sibs; Just (compileBinding m s firstSib >>= return . IR.Identifier) }
06:11:36 <lambdabot> find ((id ==) . bindingId) sibs >>= \ a -> case a of { (Just firstSib) -> Just (compileBinding m s firstSib >>= return . IR.Identifier); _ -> fail ""}
06:11:49 <quicksilver> it's bold, simple, recognisable, works in black and white and works at lots of different sizes
06:11:51 <kmc> the symbols in the old logo represent concepts, not syntax
06:11:53 <quicksilver> so that is all great.
06:12:00 <quicksilver> it's just subjective dislike :)
06:12:00 <mm_freak> kmc: i can accept graphical versions of the arrows in a logo (the current haskell logo uses a real lambda, too), but the forall symbol really shouldn't be there
06:12:03 <kmc> functions, types, polymorphism, monads, type classes
06:12:39 <ketil> Any reason to think 'advancePtr' is particularly expensive?
06:12:42 <kmc> it's a logo the way F_ω is a logo
06:12:59 <kmc> from what library ketil?
06:13:10 <ketil> Uh, FFI?
06:13:15 <kmc> i don't see one, do you mean plusPtr?
06:13:16 <mm_freak> ketil: you don't mean plusPtr?
06:13:24 <kmc> anyway no, it should be very fast
06:13:45 <kmc> just adding two (boxed) integers
06:13:51 <kmc> (on GHC)
06:14:00 <kmc> plusPtr (Ptr addr) (I# d) = Ptr (plusAddr# addr d)
06:14:16 <ketil> No, it does say advance.  Yes, I thought it'd just be an addition - but then I have a function that is slow (according to profiling), and I can't really see why.
06:14:32 <ClaudiusMaximus> @hoogle advancePtr
06:14:32 <lambdabot> Foreign.Marshal.Array advancePtr :: Storable a => Ptr a -> Int -> Ptr a
06:14:52 <ketil> Seems to be...ah, right, that one, yes.
06:14:55 <ion> @hoogle plusPtr
06:14:55 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
06:15:00 <kmc> aha
06:15:25 <ClaudiusMaximus> i imagine advancePtr uses sizeOf
06:15:40 <Axman6> ew
06:15:43 <mm_freak> i imagine advancePtr copies
06:16:01 <ketil> I imagine there's a way to check? :-)
06:16:08 <kmc> doAdvance dummy ptr i  = ptr `plusPtr` (i * sizeOf dummy)
06:16:09 <erus`> > mapM (\x -> Just 1) []
06:16:10 <lambdabot>   Just []
06:16:21 <mm_freak> ketil: safely checking means reading the code
06:16:27 <fasta> advancePtr 1 is just (&foo)++
06:16:32 <mm_freak> ketil: should be simple haskell code, because it really only uses Storable
06:17:23 <mm_freak> oh, forget it, it doesn't copy
06:17:46 <sipa> (&foo) is not an lvalue
06:19:25 <ketil> kmc: should I try replacing it and see what happens?
06:19:52 <kmc> with?
06:19:55 <fasta>  sipa: MyType * foo; foo++; //works in C++. Doesn't it in C?
06:20:28 <kmc> wouldn't it be «&foo + 1» not «(&foo)++» ?
06:21:14 <fasta> kmc: yes, but you often write the latter in C++.
06:21:21 <fasta> By often, I mean never.
06:21:23 <fasta> ;)
06:21:43 <sipa> fasta: yes, but then foo is variable and thus an lvalue
06:21:47 <fasta> Normally you would use iterators, this was just an example.
06:21:53 <sipa> but (&foo) is never an lvalue
06:22:38 <fasta> sipa: ok
06:23:01 <ketil> kmc: I replaced with what I think is the correct combination of plusPtr and sizeOf.  let's see what happens.
06:23:29 <ion> Why replace it if it works?
06:24:02 <kmc> because it might be faster (but probably isn't)
06:24:07 <kmc> are you benchmarking using Criterion?
06:24:48 <erus`> it compiles :O !
06:24:54 <erus`> the code seems a bit messy
06:24:58 <erus`> but its tiny
06:25:21 <mm_freak> ketil: out of curiosity, why don't you just use a vector/array?
06:25:38 <fasta> mm_freak: what is he currently using?
06:25:41 <mm_freak> those are often more efficient than naive Ptr code
06:25:57 <ion> How is your implementation of ptr `plusPtr` (i * sizeOf x) faster than advancePtr’s?
06:25:59 <ketil> It's not my library.  And it wraps a C lib, so I suppose ForeignPtr comes naturally.
06:26:20 <mm_freak> fasta: i assume that it's just an array, but as a Ptr
06:26:22 <ketil> ion: I imagine it's the same.  But I'm checking anyway. :-)  A few more minutes.
06:26:44 <mm_freak> ketil: and there is no higher level interface to that library?
06:26:49 <ion> Did profiling show advancePtr is the bottleneck in your code?
06:27:11 <ketil> mm_freak; yes, well, that's the interface I am using, but which, for some reason, is very slow at this particular operation.
06:27:39 <fasta> ketil: which library?
06:27:42 <ketil> ion: no, I don't get profiling for the FFI operations, so it's just a guess.
06:27:46 <ketil> samtools.
06:28:22 <mm_freak> ketil: what exactly in that library?
06:28:26 <fasta> ketil: write a few example programs in C to benchmark.
06:28:38 <fasta> C programs written by scientist usually suck.
06:28:46 <ketil> Hang on a sec, I can hpaste it.
06:28:49 <fasta> scientists*
06:28:49 <ketil> fasta :-)
06:28:55 <erus`> code review? https://github.com/tm1rbrt/lambdurp/blob/master/compiler.hs
06:28:56 <fasta> ketil: fact.
06:28:57 <mm_freak> i don't see that library returning any Ptrs anywhere
06:29:18 <fasta> ketil: the formats they come up with are even more funny.
06:29:35 <ketil> mm_freak: no it's in the targetSeqLen function.
06:29:49 <mm_freak> scientists write C code?  i thought they write only fortran
06:29:55 <mm_freak> or cobol
06:30:23 <fasta> erus`: compileExpression m s b p (Application x y) =
06:30:24 <erus`> ScyPy
06:30:27 <hpaste_> ketil pasted “targetSeqLen” at http://hpaste.org/52406
06:30:46 <fasta> erus`: the x and y could be given better names, although the type and constructor name already tell the whole story.
06:31:33 <fasta> erus`: the error handling likely is a bit too simplistic.
06:31:54 <mm_freak> ketil: that code looks a bit broken
06:31:54 <ketil> Updated with profiling info.
06:32:00 <lpsmith> ok,  i'm interfacing with a C library that can close a file descriptor behind my back
06:32:04 <ketil> mm_freak: please elaborate?
06:32:07 <fasta> erus`: and I wouldn't use 'type'. In all my programs, 'type' have turned into 'newtype' or 'data'.
06:32:17 <mm_freak> ketil: i think the author assumes that Int = CInt
06:32:25 <lpsmith> (libpq, specifically)
06:32:33 <ketil> OH, shit, that's my ugly hack.  Hang on!
06:32:46 <mm_freak> hehe ok
06:33:31 <mm_freak> fasta: what's wrong with 'type'?
06:33:45 <ketil> mm_freak, updated again.
06:34:32 <fasta> mm_freak: I already said that.
06:34:51 <fasta> has turned into*
06:35:11 <ketil> Anyway:  I'm not able to see any obvious culprit, profiling seems to clear any of the other operations.  It does see a lot of calls, though, so perhaps it's just withForeingPtr overhead?
06:35:46 <kmc> does withForeignPtr incur much overhead?
06:36:11 <ketil> I shouldn't think so, but I'd deeply appreciate any insights into the matter.
06:36:23 <fasta> ketil: perhaps inline targetSeqLen completely?
06:36:34 <tromp> :t all
06:36:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:36:37 <mm_freak> fasta: yes, but why do you avoid 'type' in general, disregarding this specific example?
06:36:43 <tromp> :t and
06:36:44 <lambdabot> [Bool] -> Bool
06:36:47 <erus`> fasta: i just used type so i dont have to document the arguements
06:37:14 <fasta> erus`: if you don't want arguments, use Factor ;)
06:37:16 <mm_freak> ketil: i don't see the updated version
06:37:30 <hpaste_> ketil annotated “targetSeqLen” with “targetSeqLen (annotation)” at http://hpaste.org/52406#a52407
06:37:42 <fasta> ketil: or just do bulk processing.
06:37:43 <kmc> ketil, I don't expect so, either
06:37:44 <erus`> i want arguments, i just want to know what they are
06:37:52 <ketil> Oh, I needed to add author again.
06:38:01 <kmc> ketil, you could store the ForeignPtr and Ptr together and use touchForeignPtr only at the last possible moment
06:38:07 <mm_freak> ketil: in any case, the pointer functions in haskell a very fast, approaching (but not quite reaching) C speed, the difference being a constant factor
06:38:13 <kmc> i don't recommend keeping your code this way unless it actually makes a big difference to speed
06:38:13 <fasta> ketil: calling index functions from the Haskell world into the C world is a bad idea.
06:38:16 <kmc> which I do not expect it does
06:38:24 <kmc> because it's unsafe code
06:38:30 <mm_freak> ketil: you can expect the pointer functions/actions to do what you would code in C anyway
06:38:51 <dino-> @seen Lemmih
06:38:51 <preflex>  Lemmih was last seen on #haskell 31 days, 2 hours, 14 minutes and 42 seconds ago, saying: Jafet: What does 'mapM_' have to do with it?
06:38:51 <lambdabot> Unknown command, try @list
06:40:41 <ketil> kmc, mm_freak: hm, could you restate that?  What is unsafe, and how would it be better structured?  (This isn't my code, btw, I'm just a user)
06:41:22 <mm_freak> ketil: indexing C arrays from haskell is generally a bit fragile, although with the foreign types it should be fine
06:41:23 <kmc> unsafeForeignPtrToPtr is unsafe
06:41:42 <kmc> i meant that my proposed refactoring would be unsafe
06:41:58 <ketil> Ah, okay.
06:42:15 <mm_freak> ketil: anyway, benchmark the C code
06:42:23 <mm_freak> perhaps the bottleneck isn't even on the haskell side
06:42:44 <kmc> Criterion works pretty well for benchmarking C code too :)
06:43:38 <josiah14> ?
06:43:50 <kmc> !
06:44:29 <tromp> :t foldr
06:44:31 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:44:31 <thoughtpolice> <3 criterion. i'm running a benchmark right now that's estimated to take 45 minutes :P
06:44:34 <mm_freak> (that reminds me…  it's interesting that the sole question mark is seldomly used as an operator)
06:44:36 <kmc> haha, wow
06:44:54 * hackagebot hex 0.1.2 - Convert strings into hexadecimal and back.  http://hackage.haskell.org/package/hex-0.1.2 (TaruKarttunen)
06:45:10 <thoughtpolice> it should be done soon. i think. if i didn't somehow mess it up. :)
06:45:24 <ion> foo ? bar ? baz : quux : narf
06:46:33 <mm_freak> ion: in haskell
06:46:46 <tromp> :t min
06:46:47 <lambdabot> forall a. (Ord a) => a -> a -> a
06:46:50 <tromp> :t minimum
06:46:51 <lambdabot> forall a. (Ord a) => [a] -> a
06:49:05 <tromp> :t minimumNy
06:49:06 <lambdabot> Not in scope: `minimumNy'
06:49:09 <tromp> :t minimumBy
06:49:10 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
06:49:43 <quicksilver> mm_freak: incompatible with the (nasty, nasty) implicit param stuff?
06:49:55 <quicksilver> I'm not actually sure what implicit parameters do to the lexer
06:49:58 <quicksilver> but that might be the reason.
06:50:22 <irene-knapp> heh
06:50:26 <dmwit> > let True ? (t:_) = t; False ? (_:f:_) = f in (3 == 5) ? "weird" : ["not weird"]
06:50:27 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:50:27 <lambdabot>         against inferred type...
06:50:29 <irene-knapp> just fired off an email about changing the real name on my Hackage account
06:50:33 <dmwit> > let True ? (t:_) = t; False ? (_:f:_) = f in (3 == 5) ? ("weird" : ["not weird"])
06:50:34 <lambdabot>   "not weird"
06:50:43 <erus`> i need some help with theory :) anyone (clever) free?
06:50:43 <irene-knapp> I bet this is the first time the people in charge of that ever thought about this case :)
06:50:47 <dmwit> I don't suppose \bot allows fixity declarations...?
06:51:15 <tromp> @hoogle (b->c)->(a->b) -> a->a->c
06:51:16 <lambdabot> No results found
06:51:22 <dmwit> :t on
06:51:23 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:51:53 <tromp> thx, dimwit. was it @djinn that i needed?
06:52:09 <ion> I still can’t help reading \bot as ⊥.
06:52:14 <dmwit> tromp: Your function would only be able to use one of the two a's it's supplied with.
06:52:19 <dmwit> tromp: So why bother supplying both a's?
06:52:25 <ClaudiusMaximus> > let foo a b c= a & b .|. c where (&) = (.&.) ; infixl 6 & in foo 1 2 3
06:52:26 <lambdabot>   Ambiguous type variable `a' in the constraint:
06:52:26 <lambdabot>    `Data.Bits.Bits a'
06:52:27 <lambdabot>      a...
06:52:31 <kmc> irene-knapp, cool :)
06:52:31 <ClaudiusMaximus> > let foo a b c= a & b .|. c where (&) = (.&.) ; infixl 6 & in foo 1 2 3 :: Int
06:52:32 <lambdabot>   3
06:52:36 <irene-knapp> kmc: thanks :)
06:52:47 <tromp> oh, right,  i needed extra b in first function
06:52:52 <ClaudiusMaximus> > let foo a b c= a & b .|. c where (&) = (.&.) ; infixl 6 & in foo 1 2 4 :: Int
06:52:53 <lambdabot>   4
06:53:00 <ClaudiusMaximus> > let foo a b c= a & b .|. c where (&) = (.&.) ; infixl 1 & in foo 1 2 4 :: Int
06:53:01 <lambdabot>   0
06:53:12 <obiwahn> @src getLine
06:53:12 <lambdabot> getLine = hGetLine stdin
06:53:20 <kmc> i bet it's not the first time, actually
06:53:21 <dmwit> tromp: Indeed. In that case, no, you didn't need ?djinn, you did exactly the right thing. =)
06:53:26 <obiwahn> @src readLn
06:53:26 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
06:53:38 <tromp> @hoogle on
06:53:38 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:53:38 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
06:53:38 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
06:53:52 <dmwit> ?hoogle (b -> b -> c) -> (a -> b) -> a -> a -> c
06:53:53 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:53:53 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
06:53:53 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
06:54:05 <irene-knapp> kmc: well, I wouldn't be amazed :)
06:54:11 <dmwit> ?src readIO
06:54:12 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:55:38 <obiwahn> what is the difference between getLine and readLn
06:55:46 <kmc> @src readLn
06:55:46 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
06:55:56 <kmc> @src readIO
06:55:56 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:56:08 <EvanR-work> :t readLn
06:56:09 <lambdabot> forall a. (Read a) => IO a
06:56:10 <kmc> readIO is like 'read' but it throws an IO exception on parse failure
06:56:11 <EvanR-work> the type
06:57:50 <mm_freak> quicksilver: on the value level?
06:58:34 <quicksilver> mm_freak: yes. let ?foo = 3 in ....
06:58:46 <quicksilver> but as I said, I don't know that lexed.
06:59:09 <obiwahn> how would i pass the type to readLn
06:59:15 <quicksilver> it isn't *technically* ambigous.
06:59:32 <quicksilver> obiwahn: you don't normally need to. It works it out from context.
06:59:48 <quicksilver> can you annotate it to be sure, though. (readLn :: IO Int)
07:00:12 <dmwit> kmc: I know that. I was just wonderding how it was implemented. (via reads?)
07:00:12 <obiwahn> i am playing with basic IO
07:00:15 <dmwit> ?src Read
07:00:16 <lambdabot> class Read a where
07:00:16 <lambdabot>   readsPrec    :: Int -> ReadS a
07:00:16 <lambdabot>   readList     :: ReadS [a]
07:00:16 <lambdabot>   readPrec     :: ReadPrec a
07:00:16 <lambdabot>   readListPrec :: ReadPrec [a]
07:00:18 <erus`> get yer free karma folks http://stackoverflow.com/questions/7713965/searchign-a-tree-while-storing-the-path
07:00:26 <obiwahn> > getLine >>= putStrLn
07:00:27 <lambdabot>   <IO ()>
07:00:34 <dmwit> via readsPrec, I guess
07:00:39 <robert[]> hi #haskell
07:01:21 <kmc> hi robert[]
07:01:56 <tromp> :t foldr
07:01:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:02:00 <dmwit> erus`: I'm not sure the problem is yet well-specified.
07:02:28 <dmwit> erus`: As stated, a very elegant solution is getArgIndex _ = InTuple 1 (ArgIndex 1)
07:02:44 <dmwit> whoops
07:02:53 <dmwit> getArgIndex _ _ = Just (InTuple 1 (ArgIndex 1))
07:06:03 <ketil> Sorry to go on about this, but one worrying thing here is:
07:06:08 <ketil>     targetSeqLen         Bio.SamTools.Internal                                492      582072  58.4    1.8    58.5    2.3
07:06:43 <erus`> dmwit: is that a joke
07:06:45 <ketil> The allocations column, although this function doesn't allocate much itself, something "below" it allocates most of the total allocations.
07:07:36 <dmwit> erus`: No. You don't really say what your function is supposed to do at all. What's the String argument represent? What's the meaning of the data types you've defined?
07:07:56 <fasta> ketil: targetSeqLen is called in an inner loop, right?
07:08:26 <hpaste_> “John Tromp” pasted “Oct11.hs” at http://hpaste.org/52408
07:08:26 <ketil> fasta: hm, not very inner, but, yes, a lot of times.
07:08:29 <fasta> ketil: so, you go from Haskell RTS to C RTS a gazillion times; don't do that.
07:08:40 <fasta> ketil: you should get a ton of data at a time.
07:08:43 <dmwit> Well... half of it's a joke, I guess. =) But "the problem is not yet well-specified" was not intended to be a joke.
07:08:51 <fasta> ketil: then do whatever you want and get another ton of data.
07:09:02 <fasta> ketil: or build a better compiler.
07:09:03 <tromp> can anyone see why my paste has a space leak?
07:09:04 <fasta> :)
07:09:10 <erus`> dmwit: ok i added another example
07:09:38 <ketil> fasta: 500K times?  So it's only about 1K times per second.  But yes, I could do with a single function to extract all of it, and just do the lookups in Haskell-land.
07:09:49 <tromp> n8 is of length 766080
07:10:07 <dmwit> erus`: I honestly still have no idea what your function is supposed to do. Can you describe it in English?
07:10:21 <ketil> ..but now I got a segmentation fault, which seems to indicate that this C lib is slightly less robust than it should be.  Sigh.
07:10:33 <fasta> tromp: did you profile it with the heap profiler?
07:10:35 <erus`> it searched the Pattern for a Named arguement
07:10:40 <erus`> and returns its index
07:10:47 <fasta> tromp: but the problem is going to be in the StateT, likely.
07:11:09 <tromp> each permute is only on a list of 8 elems
07:12:17 <juhp> anyone familiar with haxr?
07:12:24 <tromp> there is no space leak in permute
07:12:53 <fasta> tromp: the foldr contains a lazy addition.
07:13:23 <fasta> tromp: there is no need for foldr to actually reduce anything there.
07:13:34 <fasta> tromp: it just builds up a huge expression.
07:13:50 <tromp> each fold is only over 8 numbers
07:14:18 <fasta> tromp: ok, so we see that profiling is better ;)
07:15:16 <fasta> tromp: what makes you think you have a space leak, btw?
07:15:33 <fasta> tromp: if you use a ton of memory, that doesn't make it a space leak.
07:15:46 <tromp> Stack space overflow: current size 8388608 bytes.
07:16:28 <tromp> i don't see how it should use much memory at all
07:16:49 <dmwit> ?src maximumBy
07:16:49 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:16:54 <dmwit> ?src maximum
07:16:55 <lambdabot> maximum [] = undefined
07:16:55 <lambdabot> maximum xs = foldl1 max xs
07:17:02 <dmwit> tromp: Switch to foldl1', probably
07:17:37 <dmwit> tromp: Oh, by the way, on compare === comparing
07:17:43 <dmwit> Which reads better in some situations.
07:17:51 <tromp> ok, thx
07:18:05 <fasta> tromp: I don't get a stack space overflow when I compile it.
07:18:40 <tromp> @hoogle comparing
07:18:41 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
07:18:42 <dmwit> fasta: Stack overflows have more-or-less been eliminated in 7.x by making the stack dynamically sizable; are you running on a recent GHC?
07:19:00 <tromp> no, an older one
07:19:03 <fasta> dmwit: ah, they did. Finally! :)
07:19:20 <dmwit> tromp: I *know* you're running on an old one. =)
07:19:31 <tromp> 6.12.3
07:19:42 <fasta> It requires about 900MB of memory here.
07:19:45 <dmwit> You wouldn't get that message if you were running on a new one. =)
07:19:46 <fasta> In ghci.
07:19:53 <dmwit> But that doesn't mean there isn't a problem.
07:20:30 <tromp> so maximumBy doesn't consume n8
07:20:47 <tromp> we need maximumBy'
07:23:58 <BlankVerse> is there any easy to follow article/tutorial to decode a json string
07:28:14 <osfameron> BlankVerse: there is quite a detailed explanation about parsing JSON in Real World Haskell, iirc
07:28:32 <BlankVerse> osfameron: using Parsec?
07:29:48 <osfameron> BlankVerse: dunno, http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html
07:30:44 <osfameron> BlankVerse: and it looks like the Parsec chapter comes back to JSON data too: http://book.realworldhaskell.org/read/using-parsec.html
07:35:09 <incluye> > fix (\x -> 1:1:zipWith (+) x (tail x))
07:35:10 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
07:37:20 <Masxmasx{AFK}> is there a function to replace the n'th value of a list with another value?
07:37:41 <copumpkin> no
07:37:56 <Masxmasx{AFK}> okay, thanks
07:38:38 <copumpkin> you can do it without much difficulty, but probably shouldn't
07:38:56 <Masxmasx{AFK}> I have to for an assignment, so not much choice there :p
07:38:56 <kmc> yeah, lists are not random-access data structures
07:39:20 <kmc> if you want random access to indices, Data.Sequence or Data.IntMap are more appropriate
07:39:39 <Masxmasx{AFK}> I'm not allowed to, unfortunately
07:39:49 <incluye> or you could rewrite (!) using pattern matching to make it return the new value at the right index :o)
07:39:58 <copumpkin> tell the instructor that they're wrong!
07:40:10 <Masxmasx{AFK}> how are they wrong?
07:40:14 <incluye> or is it (!!)
07:40:17 <quicksilver> the instructor is probably testing your ability to write
07:40:19 <incluye> i'm a pro
07:40:30 <kmc> Masxmasx{AFK}, it wouldn't be as good of an assignment if the function were already in the std lib ;)
07:40:33 <kmc> we can help you write it though
07:40:43 <Masxmasx{AFK}> nah I can write it myself probably :)
07:40:45 <quicksilver> update n xs x = drop (n+1) xs ++ x ++ take (n+2) xs
07:40:56 <tromp> :t foldr'
07:40:57 <lambdabot> Not in scope: `foldr''
07:41:00 <quicksilver> ^^ code above contains deliberate bugs to make sure you are thinking.
07:41:08 <quicksilver> at least 3 :)
07:41:18 <Masxmasx{AFK}> I'll figure it out, thanks :)
07:42:21 <kmc> i'd like to hide all the things from Prelude and Data.List which have the same name as things in Data.Foldable or Data.Traversable
07:42:31 <kmc> is there a way to ask GHCi for all the ambiguous names in scope? or something like that?
07:42:42 <BlankVerse> how to use Text.JSON to decode a json string in one line?
07:47:09 <rostayob1> BlankVerse: jsonString s = case decode s of String js -> js?
07:47:21 <rostayob1> but it's partial for obvious reason
07:48:09 <BlankVerse> how to get the json string from a url?
07:48:19 <rostayob> BlankVerse: what do you mean?
07:48:30 <BlankVerse> curling a url gives the json string
07:48:43 <rostayob> curling a url gives an http response
07:48:47 <BlankVerse> instead of reading the json string from a file , i want to direct read it from the url
07:49:05 <tromp> what was the ghc option to use main from a non-Main module?
07:49:12 <dmwit> -main-is
07:49:21 <BlankVerse> rostayob: i meant the body contains the json string
07:49:34 <dmwit> It also doubles for using non-main from a Main module.
07:50:35 <dmwit> ...I'm pretty sure you never want foldr'.
07:55:46 <BrianHV> if I have "data Foo a", and a function "stringFoo :: (Num a) -> Foo a -> String", is there a way to allow the user to pass a numeric literal to stringFoo without having to manually wrap it in a Foo?
07:58:44 <kmc> BrianHV, write an instance Num a => Num (Foo a)
07:58:56 <kmc> is your Foo a newtype? then GHC can derive that instance for you
07:59:13 <BrianHV> it isn't, but maybe I can make it one. I'm still a little fuzzy on the difference.
08:00:24 <dmwit> newtypes can have exactly one constructor, and that constructor can take exactly one argument.
08:00:32 <dmwit> That's the exact difference.
08:00:56 <BrianHV> well, at the moment I meet those criteria
08:00:59 <dmwit> There are other semantic differences.
08:01:27 <dmwit> The primary one being that you get a ! on your argument's type, whether you want one or not.
08:01:32 <sipa> newtype Foo1 = Foo1 Int
08:01:36 <sipa> data Foo2 = Foo2 Int
08:01:37 <dmwit> ...sort of
08:01:43 <sipa> f1 = Foo1 undefined
08:01:46 <sipa> f2 = Foo2 undefined
08:02:03 <robert[]> anyone here an expert on de bruijn indices
08:02:06 <dmwit> Yeah, I retract the ! comment. That's not an accurate description.
08:02:11 <sipa> case f1 of (Foo1 _) ->    will fail, case f2 of (Foo2 _) will succeed
08:02:12 <robert[]> I have tricky questions about it
08:02:15 <dmwit> robert[]: Just ask your question.
08:02:20 <dmwit> (s)
08:02:29 <kmc> http://www.haskell.org/haskellwiki/Newtype
08:02:58 <dmwit> sipa: Here's a little puzzle for you: newtype Foo3 = Foo3 Foo3; case undefined of Foo3 _ -> "wow!"
08:03:00 <dmwit> sipa: What happens?
08:03:23 <hpaste_> Taejo pasted “cabal-dev woes” at http://hpaste.org/52410
08:03:28 <sipa> dmwit: nice one :)
08:03:57 <sipa> dmwit: my guess would be failure
08:04:12 <dmwit> Now test your guess. =)
08:04:20 <kmc> pattern-matching on a newtype constructor is always a no-op
08:04:23 <Taejo> I'm trying to get into cabal-dev and yesod -- I've installed yesod globally, but now doing cabal-dev install of my project fails (see above paste)
08:04:50 <Taejo> ghc-pkg check doesn't say anything
08:04:54 * hackagebot geniplate 0.4.0.0 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.4.0.0 (LennartAugustsson)
08:05:33 <sipa> dmwit: right :)
08:08:58 <tvynr> I'm having trouble finding a document to confirm or deny this.  In Template Haskell, if I am defining a type class, my splice has to insert the whole type class, right?  There's no way to write most of the type class in object program syntax and splice in a handful of declarations?
08:10:06 <kmc> tvynr, you can use declaration-splice syntax inside your decl quotation, can't you
08:10:13 <kmc> maybe that only works for top-level declarations
08:10:48 <tvynr> kmc: I think that there's a top-level restriction on that, but I'm not sure.  Every attempt I've made at building such a construction has failed to parse.
08:12:57 <Taejo> can one mix cabal-installed and cabal-dev-installed packages?
08:13:27 <kmc> tvynr, yeah, I can't make it work either
08:13:35 <tvynr> kmc: http://pastie.org/2671489  Doesn't parse.
08:13:39 <tvynr> kmc: Thanks for the sanity check.  :)
08:21:32 <BrianHV> is the implicit conversion to Num special, or is there a general rule there that will work for other type(classe)s?
08:21:50 <byorgey> BrianHV: it is special.
08:22:11 <BrianHV> all right. thanks.
08:22:41 <kmc> BrianHV, there is no implicit conversion in Haskell
08:22:41 * BrianHV may end up playing around with quasiquoting if this needs to be more concise
08:22:52 <kmc> are you talking about the fact that numeric literals are polymorphic?
08:23:04 <quicksilver> BrianHV: (it's not really conversion it's a special kind of overloaded literal) - GHC recently added an extension to do something similar with strings
08:23:16 <BrianHV> kmc: I suppose I am. fromInteger appears to be used implicitly
08:23:18 <quicksilver> you're right that quasiquoting is the only customisable way open to programmers though
08:23:41 <kmc> it's not that special.  'Nothing' is also a polymorphic literal
08:23:50 <kmc> it's not customizable, though -- parametric polymorphism, not ad-hoc
08:24:01 <merijn> As is []
08:24:06 <sipa> as is do
08:24:19 <merijn> do is not a literal
08:24:33 <merijn> It's syntactic sugar for a polymorphic function (also not a literal)
08:24:49 <sipa> true, but it is a syntax element whose semantics refer to a specific class/operator
08:25:17 <merijn> I'm of the strong opinion that polymorphic literals are a Good Thing(TM)
08:25:43 <kmc> "do" is no more an example of polymorphic literals than (succ x)
08:26:18 <merijn> Why would I need to specify something if the compiler can unambiguously figure it out from context?
08:26:34 * BrianHV is trying to articulate why numbers appear special to him
08:27:04 <merijn> BrianHV: Probably because there is quite a bit of complex typeclass machinery around numbers to make them "just work"(TM)
08:27:27 <kmc> they're special because "0" is syntactic sugar for "(fromIntegral 0)"
08:27:31 <kmc> er fromInteger
08:27:33 <BrianHV> ah!
08:27:34 <kmc> and that's a special built-in rule
08:28:10 <kmc> merijn, overloading comes at a price; if the compiler is inferring everything from context then it has less potential to catch your mistakes
08:28:45 <merijn> kmc: True, but how often have you mucked something up due to overloaded numbers/strings?
08:28:47 <mantovani> this channel is just for core developers or is for newbies too ?
08:28:57 <quicksilver> it's mostly for newbies, mantovani
08:29:07 <merijn> mantovani: This is the generic haskell channel, #ghc is for (GHC) devs
08:29:07 <mantovani> ok
08:29:08 <mantovani> :)
08:29:38 <mantovani> thank you
08:29:55 <merijn> Well, I wouldn't qualify it as "mostly for newbies" seeing some of the discussions. But you won't get yelled at for asking beginner questions ;)
08:30:49 <kmc> merijn, sure, that case is fine, I'm responding to the more general "Why would I need to specify something if the compiler can unambiguously figure it out from context?"
08:31:48 <mm_freak> in english what's the opposite of "to inhibit" in the sense of /not/ inhibiting?
08:31:55 <incluye> exhibit
08:32:01 <mm_freak> (not in the sense of exhibiting, but just not inhibiting)
08:32:03 <incluye> heh, seriously though
08:32:04 <kmc> to not inhibit
08:32:06 <merijn> mm_freak: Encourage? Stimulate?
08:32:14 <Taejo> allow
08:32:17 <Taejo> permit
08:32:21 <JuanDaugherty> promote
08:32:33 <mm_freak> thanks, some of those are useful
08:32:45 <merijn> kmc: In general I stand behind that statement, but until we finally have a practical, usable and working version of a language based on Epigram it might not always work out to well for us ;)
08:33:29 <Taejo> does cabal-dev work?
08:33:56 <merijn> The only reason it doesn't work that great in general now is because we're still employing the "search the space of ascii turds" approach to programming ;)
08:35:23 <quicksilver> if 1 million monkeys can produce 1000 ascii turds a day, how long until they write a referentially transparent reactive programming library?
08:35:55 <merijn> quicksilver: Depends? Do I assume uniform distribution of ascii turds?
08:39:56 <Taejo> I'm getting heaps of "Could not find module ... There are files missing the ... package" with cabal-dev
08:39:59 <Taejo> any ideas?
08:40:26 <JuanDaugherty> try the cabal specific channel(s)
08:41:05 <dcoutts> there aren't any cabal specific channels
08:41:07 <dcoutts> this is it! :-)
08:41:16 <JuanDaugherty> there used to be
08:41:18 <kmc> isn't #hackage sort of a cabal channel
08:41:30 <kmc> nobody talks there other than confused wannabe h4x0rz
08:42:01 <merijn> Why do those join a haskell channel? >.>
08:42:15 <quicksilver> because 'hackage' sounds like it's about h4x0ring
08:42:38 <JuanDaugherty> ##cabal, isn't haskell?
08:42:41 <merijn> Actually, I think I once convinced some dude in #python who want to learn how to hack to learn haskell
08:42:54 <copumpkin> I was thinking of registering hac.kg for short urls to hackage
08:43:02 <merijn> Figured he'd either learn and become a competent programmer or give up frustrated
08:43:12 <copumpkin> but Kyrgyzstan domains are expensive
08:43:19 <dcoutts> JuanDaugherty: heh, no
08:43:56 <hpc> copumpkin: hac.ag?
08:44:01 <dcoutts> kmc: actually #hackage seems to be mostly people interested in hackage server development
08:44:07 <hpc> or hac.ge
08:44:16 <dcoutts> kmc: plus the occasional confused haxor
08:44:17 <copumpkin> hck.ge
08:44:26 <copumpkin> oh goo
08:44:28 <copumpkin> boo
08:44:31 <copumpkin> .ge is restricted
08:44:47 <kmc> cool
08:44:54 <merijn> Speaking of urls, look what I snapped up a while ago but haven't done anything with yet (beyond set up a forward...)
08:45:06 <merijn> lambdacats.org :>
08:45:30 <JuanDaugherty> none of those quite click phonetically anyway
08:45:45 <merijn> I really should hack together a mirror that allows new contributions...
08:46:34 <merijn> Snap is pretty easy, right?
08:46:45 <quicksilver> you'll have it done in a snap.
08:47:03 <kmc> har
08:48:08 <parcs> is there any way to have ghci eagerly append to its history file?
08:48:19 <JuanDaugherty> unless it should be ur misHaps to get stacked up
08:48:36 <tgeeky> parcs: no, but I would love that
08:48:42 <tgeeky> parcs: i mean, I don't think it's out there
08:48:50 <JuanDaugherty> *mishapps
08:49:10 <exeter> I want to parse something that looks like markdown (but it is not markdown). What's the easiest way to do it?
08:49:16 <tgeeky> interrupting stream outputs results in exit to console in Windows
08:49:35 <kmc> exeter, maybe you can hack up pandoc's Markdown parser
08:49:36 <Taejo> exeter: depends how markdown-like it is, but modifying Pandoc is pretty easy
08:49:50 <kmc> (it already supports a number of extensions)
08:49:55 * hackagebot happstack-plugins 6.1.0 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-6.1.0 (JeremyShaw)
08:51:01 <exeter> thanks Taejo and kmc , but bear in mind I'm supernewbie. I will look into it nontheless, there's always something to learn!
08:51:39 <kmc> well this might be *easier* than starting from scratch
08:53:11 <Taejo> ok, seems I just needed to start from scratch
08:58:56 <exeter> kmc, Taejo , thanks for the tip, I'll dive into the code tonight. But generally speaking, would be a right approach to use something like regexp and going recurively through the text?
09:00:48 <kmc> exeter, probably not regexp, probably a real parsing library like Parsec
09:00:49 <jimmy_birer> hi
09:00:52 <kmc> hi jimmy_birer
09:01:00 <jimmy_birer> is learning haskell worth?
09:01:05 <jimmy_birer> i mean what can you do with it
09:01:06 <kmc> yes
09:01:17 <kmc> http://haskell.org/haskellwiki/FAQ#The_real_world
09:01:22 <exeter> jimmy_birer: I learned haskell and got laid.
09:01:26 <kmc> http://www.haskell.org/haskellwiki/Haskell_in_industry
09:01:30 <jimmy_birer> exeter:learning right now
09:01:38 <exeter> XD
09:02:13 <kmc> with GHC is there any way to include LANGUAGE pragmas from a #included file?
09:02:29 <kmc> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/release-7-0-1.html kind of suggests that it's possible ("Pragmas are now reread after preprocessing. In particular, this means that if a pragma is used to turn CPP on, then other pragmas can be put in CPP conditionals."
09:02:33 <kmc> ) but it's not working for me
09:03:34 <jimmy_birer> lets find a way
09:03:49 <jimmy_birer> this looks like an awesome problem to solve
09:04:05 <kmc> ok
09:04:15 <jimmy_birer> i dont really know haskell
09:04:20 <tgeeky> lol
09:04:21 <jimmy_birer> but can we expand another file
09:04:29 <jimmy_birer> without problems?
09:04:51 <shachaf> kmc: Works for me.
09:05:13 <kmc> shachaf, can you show me what you're doing?
09:05:44 <shachaf> kmc: Quite possibly misreading.
09:05:56 <kmc> oh, okay
09:06:00 <shachaf> I read the GHC documentation rather than what you were trying to do, and tried an ifdef.
09:06:10 <kmc> when i do this with ghci, it works for the file I'm #including into
09:06:19 <jimmy_birer> awesome
09:06:20 <kmc> but does not enable the extensions in ghci
09:06:37 <kmc> which is the usual behavior of {-# LANGUAGE #-}, but I thought for some reason it wasn't
09:06:45 <kmc> sorry for the confusion all
09:06:55 <shachaf> Nope, still works for me.
09:07:07 <shachaf> Unless I'm misunderstanding still?
09:07:23 <jimmy_birer> "7.13.3. INCLUDE pragma"
09:07:25 <shachaf> Oh, ghci.
09:07:40 <jimmy_birer> 'but it`s accepted,(and ignored) for compatibility"
09:07:45 <jimmy_birer> meaning you can do it
09:07:52 <jimmy_birer> but it doesn`t do crap
09:07:53 <jimmy_birer> :|
09:07:56 <kmc> anyway this is fine for what i actually wanted to do
09:08:17 <shachaf> kmc: What are you doing that involves #including LANGUAGE pragmas?
09:08:37 <kmc> i want to streamline the process of writing one-off Haskell programs
09:08:52 <shachaf> Aha.
09:09:06 <shachaf> My .ghci has ~40 imports in it. :-)
09:09:06 <jimmy_birer> you can also link
09:09:13 <kmc> by starting them with #include "all_my_imports_and_pragmas.hs"
09:09:14 <jimmy_birer> with ld
09:09:23 <shachaf> Unfortunately I've recently noticed that this makes ghci start up too slowly.
09:09:26 <kmc> ah, using .ghci is another good idea
09:09:43 <kmc> i want this to work for compiled code as well
09:10:08 <shachaf> Makes sense. I don't think .ghci actually affects files that you :load.
09:10:11 <kmc> what i want there is something like runhaskell but with transparently cached compilation
09:10:14 <kmc> maybe it can be built on top of dyre
09:11:45 <quicksilver> shachaf: surely you only have to start up ghci every few months when you log on to your session?
09:11:57 <shachaf> quicksilver: Huh? I start up ghci dozens of times a day.
09:12:06 <quicksilver> strange.
09:12:12 <quicksilver> why do you stop it?
09:12:22 <shachaf> Because I figured out what I wanted to figure out.
09:12:30 * quicksilver has a ghci permanently running
09:12:52 <shachaf> Maybe I just need to get a better window manager.
09:13:03 <shachaf> Or something.
09:13:06 <quicksilver> :)
09:13:30 <quicksilver> actually I do have to restart it sometimes, it does eventually take up a lot of memory
09:13:37 <quicksilver> but it takes weeks or more depending how much I use it
09:13:48 <osfameron> that's very disciplined of you
09:13:55 <osfameron> I tend to just open lots of new windows all the time
09:14:36 <parcs> kmc: there i
09:14:37 <parcs> is
09:14:41 <parcs> @hackage runghc
09:14:41 <lambdabot> http://hackage.haskell.org/package/runghc
09:14:46 <hpaste_> kmc pasted “import everything!” at http://hpaste.org/52412
09:14:59 <kmc> parcs, cool! thanks
09:15:13 <quicksilver> osfameron: <insert most recent version of heavily rehearsed quicksilver/osfameron emacs discussion>
09:15:30 <kmc> any notable omissions in my import list?
09:15:44 <kmc> this is geared toward one-off scripts, not big engineered systems
09:16:16 <rwbarton> Data.List.Split
09:16:20 <osfameron> quicksilver: yeah.  I guess it's the same thing with window manager.  I can't figure out how to *find* a given window under OSX (I used to keep configurations of term windows in different Virtual desktops under Linux, which worked reasonably nicely).
09:16:23 <kmc> woah, HLint tracks the use of language pragmas?
09:16:25 <kmc> nice
09:16:41 <kmc> rwbarton, ah, good one
09:17:52 <rwbarton> btw, you might like this little shell script if you don't have one like it already:   cat | ghc -e "interact ($*)" ~/bin/imports.hs
09:18:51 <kmc> nice
09:19:02 <kmc> why "cat |" ?  does ghc act differently when stdin isatty?
09:19:15 <rwbarton> I forget why the cat is there, but a comment on the previous line assures me it's necessary.
09:19:21 <rwbarton> Something like that, yeah
09:19:35 <jimmy_birer> wtf is haskell more complicated than C
09:19:35 <jimmy_birer> ?
09:20:03 <copumpkin> jimmy_birer: yes and no
09:20:19 <shachaf> kmc: That's everything?
09:20:38 <kmc> jimmy_birer, they're very different, hard to compare
09:21:21 <hpaste_> shachaf pasted “current .ghci” at http://hpaste.org/52414
09:21:27 <jimmy_birer> i just done a ghc -S learn.hs
09:21:38 <jimmy_birer> my file contained main = putStrLen "lolol"
09:21:41 <jimmy_birer> oh my god
09:21:51 <kmc> jimmy_birer, yes, Haskell is a high-level language
09:21:55 <jimmy_birer> i know
09:22:13 <kmc> thanks shachaf
09:22:13 <c_wraith> what's the -S flag?
09:22:17 <kmc> dump assembly
09:22:20 <c_wraith> ah
09:22:40 <shachaf> kmc: A good part of the purpose of this .ghci is that when I don't know where a function is from, I can :i it instead of using Hoogle.
09:22:40 <c_wraith> Does that include the RTS?  Probably not
09:22:51 <kmc> shachaf, nice
09:23:18 * shachaf adds some extensions.
09:23:45 <kmc> jimmy_birer, actually i only get about 200 lines of assembly from that
09:24:09 <kmc> no, it doesn't include the rts or other libraries
09:24:34 <jimmy_birer> yeah man
09:24:36 <jimmy_birer> only 200
09:24:40 <donri> haskell's runtime includes a garbage collector for one, yes?
09:24:42 <jimmy_birer> lets write a huge project
09:24:47 <jimmy_birer> then count
09:24:50 <kmc> GHC's runtime includes a garbage collector, yes
09:24:58 <jimmy_birer> holy shit thats awesome
09:25:03 <kmc> jimmy_birer, you can find many huge projects online, e.g. http://hackage.haskell.org/packages/archive/pkg-list.html
09:25:11 <jimmy_birer> i don`t even have to go to the kitchen
09:25:13 <jimmy_birer> take the trash bin
09:25:18 <jimmy_birer> and empty it
09:25:21 <c_wraith> Hmm.  Is most of the assembly for creating the string?
09:25:22 <jimmy_birer> haskell will do it for me
09:25:28 <kmc> jimmy_birer, are you drunk?
09:25:37 <jimmy_birer> why?
09:25:38 <kmc> donri, the Haskell language does not mandate a garbage collector
09:25:39 <donri> drunk with trolldom
09:25:43 <kmc> JHC tried to get by without one for a while
09:25:52 <kmc> by doing whole-program compilation with region analysis
09:25:54 <kmc> didn't really work
09:26:00 <donri> heh
09:27:33 <kmc> jimmy_birer, you IRC as root?
09:27:50 <binsh> Hey, can anyone help me implement this method? tokenize:: String -> [String]
09:28:01 <jimmy_birer> yes
09:28:05 <kmc> > words "maybe this one binsh?"
09:28:06 <lambdabot>   ["maybe","this","one","binsh?"]
09:28:12 <kmc> jimmy_birer, like a boss
09:28:15 <binsh> nope
09:28:19 <jimmy_birer> i know
09:28:21 <shirt> is there an #ifdef i can use to check if the code is being compiled with cabal?
09:28:22 <kmc> binsh, what should it do?
09:28:29 <binsh>  "String", ["S","t","r"... ]
09:28:31 <donri> @hoogle String -> [String]
09:28:32 <lambdabot> Prelude lines :: String -> [String]
09:28:32 <lambdabot> Prelude words :: String -> [String]
09:28:32 <lambdabot> Data.List lines :: String -> [String]
09:28:40 <kmc> > map return "String"
09:28:40 <donri> binsh, a string is already a [Char]
09:28:41 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
09:28:41 <lambdabot>    arising from a use of...
09:28:52 <kmc> > map return "String" :: [String]
09:28:53 <lambdabot>   ["S","t","r","i","n","g"]
09:29:04 <binsh> Yea, i know that :P
09:29:06 <copumpkin> > "String" >>= return
09:29:07 <lambdabot>   "String"
09:29:13 <binsh> but were supposed to make it a list of strings
09:29:15 <binsh> =\
09:29:37 <donri> single-character strings?
09:29:42 <binsh> YEAP
09:29:47 <donri> not sure that makes much sense at all :P
09:29:47 <kmc> that's silly
09:29:54 <binsh> hehe, yeah i kno
09:30:08 <kmc> > let tokenize :: String -> [String]; tokenize = map return in tokenize "like this binsh"
09:30:09 <lambdabot>   ["l","i","k","e"," ","t","h","i","s"," ","b","i","n","s","h"]
09:30:28 <kmc> > let tokenize :: String -> [String]; tokenize = map (\x -> [x]) in tokenize "like this binsh"
09:30:29 <lambdabot>   ["l","i","k","e"," ","t","h","i","s"," ","b","i","n","s","h"]
09:30:53 <kmc> > map (\x -> [x]) "like this binsh"
09:30:54 <lambdabot>   ["l","i","k","e"," ","t","h","i","s"," ","b","i","n","s","h"]
09:31:07 <binsh> nice!
09:31:10 <binsh> ty
09:31:11 <donri> > map (:[]) "how about this?"
09:31:12 <lambdabot>   ["h","o","w"," ","a","b","o","u","t"," ","t","h","i","s","?"]
09:31:12 <jimmy_birer> does anyone know a sudo rm -rf / equivalent in haskell
09:31:13 <jimmy_birer> ?
09:31:23 <kmc> jimmy_birer, stop trolling
09:31:28 <jimmy_birer> im not trolling
09:31:30 <jimmy_birer> i need it
09:31:34 <kmc> stop saying dumb things
09:31:37 <shachaf> > map pure"are we playing golf?"
09:31:38 <lambdabot>   No instance for (GHC.Show.Show (f GHC.Types.Char))
09:31:39 <lambdabot>    arising from a use of...
09:31:58 * shachaf sighs.
09:32:03 <jimmy_birer> map
09:32:13 <donri> meep
09:32:15 <kmc> import System.Process; system "sudo rm -rf /"  -- jimmy_birer
09:32:22 <jimmy_birer> thanks
09:32:24 <jimmy_birer> brb trying
09:32:26 <jimmy_birer> if it works
09:32:29 <kmc> hope it does
09:32:33 <donri> -.-
09:32:48 <shachaf> kmc: Always helpful, eh?
09:32:52 <kmc> (er, that should be «main = system ...»)
09:32:58 <yitz> > map pure "it realy should work, shachaf" :: [String]
09:32:59 <lambdabot>   ["i","t"," ","r","e","a","l","y"," ","s","h","o","u","l","d"," ","w","o","r...
09:33:09 <shachaf> yitz: Sure, but where's the golf in that?
09:33:36 <jimmy_birer>    Couldn't match expected type `Language.Haskell.TH.Syntax.Q
09:33:36 <jimmy_birer>                                     [Language.Haskell.TH.Syntax.Dec]'
09:33:36 <jimmy_birer>            against inferred type `IO GHC.IO.Exception.ExitCode'
09:33:37 <jimmy_birer>     In the expression: system "sudo rm -rf /"
09:33:41 * yitz quickly goes 9 strokes over par
09:33:48 <kmc> import System.Process; main = system "sudo rm -rf /"  -- jimmy_birer
09:33:55 <jimmy_birer> ahh thanks
09:33:57 <kmc> also don't paste big text in here
09:33:59 <kmc> try hpaste.org
09:34:14 <kmc> also why do you need sudo if you're root
09:34:16 <jimmy_birer> im affraid to run it
09:34:24 <kmc> yes, you probably should not
09:34:34 <jimmy_birer> fuck it
09:34:37 <jimmy_birer> i will be a man
09:34:42 <kmc> binsh, you don't use "in" with a function declared at top level
09:34:48 <mm_freak> what happens, when a pattern match fails in arrow do-notation?
09:34:53 <kmc> binsh, it's part of the syntax of "let"
09:34:55 <jimmy_birer> oh god what
09:34:57 <kmc> let … in …
09:35:00 <jimmy_birer> why my desktop disappeared
09:35:02 <binsh> ahh
09:35:06 <kmc> jimmy_birer, please leave
09:35:11 <jimmy_birer> i have an error which says [][][][][]
09:35:37 <jimmy_birer> FUCK YOU MOTHERFUCKING COCKSUCKERS
09:35:39 <jimmy_birer> I HAD MY FILES
09:35:42 <jimmy_birer> FORM WORK
09:35:44 * dolio summons monochrom
09:35:44 <shachaf> @where ops
09:35:44 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
09:35:50 <jimmy_birer> I LOST MY FILES
09:35:51 <jimmy_birer> :((((
09:35:54 <jimmy_birer> FFFFUUUCK
09:35:54 <jimmy_birer> FUCK
09:35:55 <jimmy_birer> FUCK
09:36:04 <jimmy_birer> I WILL SUE YOU
09:36:06 <jimmy_birer> DIPSHITS
09:36:14 <erus`> google dart has a recursion limit :(
09:36:21 <erus`> jimmy_birer: delete system32
09:36:23 <kmc> @where ops
09:36:24 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
09:36:26 --- mode: ChanServ set +o Igloo
09:36:27 <donri> not very skillful trolling to be this predictable
09:36:31 <shachaf> Igloo++
09:36:35 <kmc> thanks
09:36:45 --- mode: Igloo set +b *!*@86.120.244.99
09:36:59 * shachaf wonders what the point of doing this is.
09:37:10 <osfameron> I guess it's more fun than staring at the TV
09:37:11 <erus`> is trollan loloolll
09:37:15 <kmc> sometimes people are drunk and/or 14 years old
09:37:36 <erus`> any of you guys looked at dart yet?
09:37:40 <dolio> I didn't do that when I was 14.
09:37:49 <dolio> I guess I wasn't 14 at the time.
09:37:49 <shachaf> kmc: Being 14 years old is no excuse.
09:37:53 <kmc> indeed
09:37:56 <kmc> neither is being drunk an excuse
09:38:03 <shachaf> dolio wasn't 14 even when he was 14?
09:38:08 <kmc> > "explanation" == "excuse"
09:38:09 <lambdabot>   False
09:38:26 <shachaf> That's just ageism, man.
09:38:40 <dolio> Some people are just morons.
09:38:58 <shachaf> > ((==) `on` head) "explanation" "excuse"
09:38:59 <lambdabot>   True
09:39:06 <sacko> Hi, I am trying to make a Parser not too dissimilar to http://book.realworldhaskell.org/read/using-parsec.html.  Although rather than a [[String]] I'd like a [[Integer]].  Is that possible without going over the returned array and do it during the actual Parsing?
09:39:12 <kmc> i only wish i had given the right code the first time
09:39:30 <kmc> sacko, that's not an array, it's a list
09:39:33 <kmc> (a list of lists)
09:39:47 <shachaf> sacko: It's possible, but are you sure you want to do it?
09:40:01 <co_dh> Greeting and happy thanksgiving . In the Theorem for free, Walder said the abstraction theorem can be describe in Category theory, but I can't find any paper on this. Does anybody knows where I can find the Abstraction theorem in Category Theory?
09:40:45 <kmc> sacko, change the last line to "return (map (map read) result)"
09:41:25 <sacko> shachaf: sorry i'm still living in c land :).  the data is all numeric and it would be faster to change it there then go over it again.
09:41:46 <kmc> "change it there"?
09:42:15 <erus`> has anyone experimented with implementing an equation solver into haskell?
09:42:35 <dolio> co_dh: I have a paper called Categorical Models of Parametric Polymorphism.
09:42:46 <kmc> oh it's Canadian Thanksgiving
09:42:58 <dolio> Also, Types, Abstraction and Parametric Polymorphism, Part 2.
09:43:12 <dolio> Does logical relations over categories.
09:43:34 <co_dh> dolio: thanks, do you have the link?
09:43:49 <dolio> No. But I probably got them by googling.
09:44:06 <copumpkin> erus`: what sort?
09:44:13 <co_dh> I got it . thanks.
09:44:45 <erus`> copumpkin: like let a = 1 + 0.5 a in print a
09:45:06 <Younder> Finaly figured out the problem with my O(1) flatten
09:45:12 <dolio> co_dh: I don't know if either of those is really what you're looking for, but there's a chance.
09:45:13 <copumpkin> erus`: not a fan :P
09:46:03 <erus`> i dont know how you would differentiate between solved and unsolved values
09:47:26 <kmc> erus`, i saw a SMT solver DSL which used "let" (inside TH quotation)
09:49:28 <Kakadu> hi all!
09:49:38 <trinithis__> hi Kakadu!
09:49:42 <Kakadu> Is anybody good at qthaskell's internals?
09:49:56 <mm_freak> i don't understand how pattern match failures are handled by proc/do
09:49:57 <dolio> I don't think anyone is, no.
09:51:39 <mm_freak> are they handled at all or just translated into the corresponding arr lambdas?
09:52:19 <sipa> mm_freak: pattern match failures within do blocks call the monad's fail function, no?
09:52:22 <sipa> :t fail
09:52:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
09:52:27 <hpc> yes
09:52:31 <mm_freak> sipa: proc/do, i.e. arrow notation
09:52:57 <hpc> specifically, they desugar to a case statement which includes fail with some stock text describing the error
09:52:58 <mm_freak> proc _ -> 2 <- identity -< 1; identity -< ()
09:53:13 <mm_freak> yes, yes, yes, i'm NOT talking about monads
09:54:01 <mm_freak> the computation seems to just proceed, but when i ask for the output value it throws the pattern match failure
09:54:20 <mm_freak> it would be great, if this would be handled by ArrowZero instead
09:55:17 <obiwahn> how do i get the type of a function within the definition of an instance of a typeclass
09:55:20 <mm_freak> although i have no idea how that would work
09:55:33 <mm_freak> obiwahn: look at the class definition
09:55:47 <obiwahn> aaar
09:56:46 <akosch> could someone please help me with reading this type signature correctly? Data.Enumerator.Iteratee Data.ByteString.Internal.ByteString IO [Network.Wai.Parse.Param]
09:56:49 <mm_freak> obiwahn: or use GHCi's :t together with a type signature for one of your values
09:57:08 <akosch> I don't understand how I should get the list of params out of it
09:57:17 <mm_freak> akosch: simplified:  Iteratee ByteString IO [Param]
09:57:35 <mm_freak> akosch: you can get the params out of it either by running or by using monadic binding
09:57:53 <akosch> mm_freak: yeah, I thought I need to execute this
09:58:02 <akosch> mm_freak: thanks, I'll try...
09:58:05 <mm_freak> akosch: unlikely
09:58:16 <mm_freak> if you're using WAI, you need to bind instead
09:58:29 <mm_freak> use (>>=) or do-notation
09:58:55 <akosch> mm_freak: ok, I was thinking of bind too :)
09:58:56 <mm_freak> you are already in the iteratee's monad, so you really just need to bind to get the parameters
09:59:56 * hackagebot factory 0.2.0.0 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.2.0.0 (AlistairWard)
10:00:06 <tsousa> why is that in this type declaration i need to have [(String, String)] http://dpaste.com/631546/ ?
10:00:11 <trinithis> or use unsafePerformIO
10:00:25 <obiwahn> i wanted to write bind's signature to make things a bit clearer to myself now i know the def from Monads ...
10:00:48 <hpc> tsousa: as opposed to what?
10:01:46 <obiwahn> (MakeCounter [1] >>=)
10:02:13 <mm_freak> the classic counter example =P
10:02:20 <tsousa> hpc, that functions gets an filed in my dictionary
10:02:47 <mm_freak> tsousa: you don't /have to/ have [(String, String)], but it's a valid dictionary type
10:02:51 <mm_freak> it's a list of string pairs
10:03:01 <mm_freak> i.e. a dictionary
10:03:18 <tsousa> so String -> String -> Bool is not enough?
10:03:32 <merijn> tsousa: That depends on what you're doing?
10:03:34 <hpc> tsousa: what's the definition of the function?
10:04:04 <mm_freak> tsousa: what do you want to check?  because i think the one string argument is superfluous for your function
10:04:05 <hpc> :t \name number book -> (name, number) `elem` book
10:04:06 <lambdabot> forall t t1. (Eq t, Eq t1) => t -> t1 -> [(t, t1)] -> Bool
10:04:14 <mm_freak> and the [(String, String)] argument is mandatory
10:05:01 <hpc> :t \name book -> lookup name book
10:05:02 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:05:42 <ion> let a `asTypeIn` f = a where { _ = f a }; infixl 0 `asTypeIn`; f `asAppliedTo` x = f `asTypeIn` ($ x); infixl 0 `asAppliedTo`
10:05:55 <ion> λ> :t (>>=) `asAppliedTo` MakeCounter [1]
10:06:00 <mm_freak> :t \name -> maybe False (const True) . lookup name
10:06:01 <lambdabot> forall a a1. (Eq a1) => a1 -> [(a1, a)] -> Bool
10:06:31 <mm_freak> :t uncurry lookup
10:06:32 <lambdabot> forall a b. (Eq a) => (a, [(a, b)]) -> Maybe b
10:06:40 <mm_freak> uh
10:06:46 <ion> obiwahn: See above.
10:07:23 <mm_freak> :t maybe False (const True) . curry lookup
10:07:24 <lambdabot>     Couldn't match expected type `Maybe a'
10:07:25 <lambdabot>            against inferred type `b -> [((a1, b), b1)] -> Maybe b1'
10:07:25 <lambdabot>     Probable cause: `curry' is applied to too few arguments
10:07:35 <hpc> curry lookup doesn't typecheck
10:07:36 <cgroza> what was the function that makes another function take a monad?
10:07:44 <mm_freak> :t curry lookup
10:07:45 <lambdabot> forall a b b1. (Eq a, Eq b) => a -> b -> [((a, b), b1)] -> Maybe b1
10:07:48 <mm_freak> it does
10:07:53 <hpc> oh i suppose it does
10:07:56 <mm_freak> :t (maybe False (const True) .) . curry lookup
10:07:57 <lambdabot>     Couldn't match expected type `Maybe a'
10:07:57 <lambdabot>            against inferred type `[((a1, b1), b)] -> Maybe b'
10:07:58 <lambdabot>     In the first argument of `curry', namely `lookup'
10:08:03 <hpc> :t curry
10:08:04 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:08:06 <mm_freak> screw it
10:08:51 <ion> cgroza: Do you mean <$>?
10:08:52 <Younder> mm_freak, language
10:09:06 <ion> younder: English
10:09:13 <mm_freak> Younder: haskell
10:09:28 <cgroza> :t <$>
10:09:29 <lambdabot> parse error on input `<$>'
10:09:35 <Younder> mm_freak, I don't speak vulgar
10:09:59 <cgroza> ion: a minute.
10:10:08 <ion> :t (<$>)
10:10:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:10:37 <mm_freak> Younder: feel free to /ignore me
10:11:17 <obiwahn> yeahy - thank you
10:11:31 <Younder> mm_freak, no problem.. I've seen far worse
10:11:39 <cgroza> ion: I was talking about liftM
10:11:42 <cgroza> :t liftM
10:11:43 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:12:02 <merijn> Does "screw it" qualify as vulgar nowadays?
10:12:30 <mm_freak> i don't know…  beavis and butthead talk about screws all the time =)
10:12:42 <Younder> merijn, it always has. I use it all the time..
10:13:09 <ion> cgroza: liftM is a redundant way to say <$> due to the historical accident of Monad not depending on Functor. Sometimes it’s warranted when you don’t want an additional Functor constant, but i’d use <$> unless i have a specific reason to use liftA/liftM.
10:13:42 <ion> s/constant/constraint/
10:13:46 <mm_freak> ion: or fmap
10:13:54 <mm_freak> in some cases fmap is nicer
10:14:11 <ion> Yeah. It should be named just “map” though. ;-)
10:14:13 <ski> dolio : Lars Birkedal, resp. QingMing Ma,John C. Reynolds ?
10:14:23 <ski> erus` : maybe you'd like constraint logic programming ?
10:14:44 <erus`> does it have monads?
10:15:54 <ski> erus` : not per se, though an implementation of it in Haskell possibly would
10:16:35 <mm_freak> i wonder what a sensible implementation of monadic FRP looks like, i.e. one that doesn't suck
10:16:59 <ski> erus` : there are constraint logic systems implemented as libraries in various Prologs (and Mercury), also see Oz (and Alice ML, iirc)
10:17:06 <mm_freak> is it even possible without ugly impure stuff under the hood?
10:17:34 <erus`> i will have a butchers
10:17:42 <parcs> mm_freak: have you seem reactive-banana?
10:18:01 <ion> All Haskell code that runs on any of the processors we’re likely to have has ugly impure stuff under the hood. ;-)
10:18:11 <cgroza> ion: thanks
10:18:12 <ski> merijn : "ugly impure stuff" for efficiency, or for semantics ?
10:18:29 <ski> s/merijn/mm_freak/
10:19:47 <ski> cgroza : btw, in `liftM f ma', `ma' (of type `m a') isn't a monad, it's a *monadic action* (and `m'-action). the `m' (the type function) is the monad
10:19:56 * hackagebot geniplate 0.4.0.1 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.4.0.1 (LennartAugustsson)
10:20:14 <merijn> ion: The universe is ugly and impure, so I doubt there's much we can do to improve :p
10:20:18 <ski> cgroza : e.g. in `liftM reverse getLine', `getLine', having type `IO String', is an `IO'-action, and `IO' is the monad
10:20:39 <mm_freak> parcs: i didn't get that one, but i've seen scary unsafePerformIO stuff in the source code
10:21:17 <mm_freak> ion: problem with ugly impure stuff under the hood is that it's hard to write new FRP primitives sanely
10:21:39 <mm_freak> with my current arrow approach simple primitives can be written in one or two lines of code
10:21:39 <ski> mm_freak : see misdirected question above
10:22:01 <mm_freak> ski: the latter i guess
10:22:18 <mm_freak> i don't see any way to write a pure FRP implementation in the monadic framework
10:23:25 <kmc> the 'newtype' library docs say "For example, see ala Cont traverse, with the proper Newtype instance for Cont."
10:23:36 <kmc> why is that use case in particular interesting?
10:24:12 <kmc> it doesn't quite work as-is with mtl-2, but it's something like [(a -> r) -> r] -> ([a] -> r) -> r
10:24:24 <kmc> (where the list is potentially generalized to an arbitrary Traversable)
10:24:25 <ski> @type ala cont Data.Traversable.traverse
10:24:26 <lambdabot> forall a r (t :: * -> *) o'. (Data.Traversable.Traversable t, Newtype (Cont r a) ((a -> r) -> r), Newtype (ContT r Identity (t a)) o') => t ((a -> r) -> r) -> o'
10:24:48 <copumpkin> kmc: I like that function
10:25:00 <mm_freak> kmc: multiple continuations and a collector continuation
10:25:09 <kmc> can you use it in a sentence
10:25:13 <copumpkin> the example I've seen is withCString
10:26:11 <copumpkin> @hoogle withCString
10:26:12 <lambdabot> Foreign.C.String withCString :: String -> (CString -> IO a) -> IO a
10:26:12 <lambdabot> Foreign.C.String withCStringLen :: String -> (CStringLen -> IO a) -> IO a
10:26:35 <xil> hello. I'd like to draw to a Gtk DrawingArea and be able to force it to update without drawing the background color first. I was thinking about using a pixbuf to store my current visuals and then drawing it onto the DrawingArea, but I can't find a way to draw to the pixbuf
10:26:41 <copumpkin> kmc: you see how that'd be useful?
10:27:38 <kmc> copumpkin, to use a number of strings together?
10:27:49 <kmc> that's kinda neat
10:27:51 <copumpkin> yeah, it lets you work with the temporarily allocated memory all at once
10:27:57 <DevHC> is it true that operators must be enclosed in parenthes, except when the operator takes 2 arguments?
10:28:09 <copumpkin> use it for any of those "with" patterns that automatically frees something
10:28:13 <ski> @type \x -> ala cont Data.Traversable.traverse x . Foreign.C.String.withCString
10:28:14 <lambdabot> forall a r (t :: * -> *) b a1. (Data.Traversable.Traversable t, Newtype (Cont r a) ((a -> r) -> r), Newtype (ContT r Identity (t a)) (((Foreign.C.String.CString -> IO a1) -> IO a1) -> b)) => t ((a ->
10:28:14 <kmc> DevHC, operator names are enclosed in parentheses to use them as ordinary names
10:28:15 <lambdabot>  r) -> r) -> String -> b
10:28:24 <copumpkin> now just throw substructural typing into the mix and stop your bad stuff from leaking
10:28:40 <kmc> DevHC, I don't suggest thinking of (+) and (2 +) as similar
10:28:41 <copumpkin> ski: not quite that
10:28:44 <kmc> (+) is the name of that operator
10:28:51 <kmc> (2 +) is sugar for (\x -> 2 + x)
10:28:57 <copumpkin> @type ala cont Data.Traversable.traverse . map Foreign.C.String.withCString
10:28:58 <lambdabot> forall o' a. (Newtype (Cont (IO a) Foreign.C.String.CString) ((Foreign.C.String.CString -> IO a) -> IO a), Newtype (ContT (IO a) Identity [Foreign.C.String.CString]) o') => [String] -> o'
10:29:05 <copumpkin> aaaaah
10:29:18 * copumpkin gives up
10:30:00 <DevHC> kmc: let's say that we have { (♥) :: Integer -> Bool ; (♥) a = (<3) a }. why can't i  write (♥ 3) ?
10:31:17 <ski> DevHC : because your operator can't take a right (second) argument, since the type isn't `.. -> .. -> ..'
10:31:31 <xil> but it would still work, it just evaluates to True
10:31:46 <xil> I mean False
10:32:02 <ski> DevHC : you could apply you operator with an argument to the left, in CHC, though
10:32:21 <ski> > ("abc" `length`)
10:32:21 <DevHC> ski: can't
10:32:22 <lambdabot>   3
10:32:28 <ski> > (`length` "abc")
10:32:28 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
10:32:29 <lambdabot>         against inferr...
10:32:52 <DevHC> ski: in GHC that is :P
10:34:17 <copumpkin> how would you write
10:34:18 <copumpkin> transpose :: Map k (Map k' v) -> Map k' (Map k v)
10:35:00 <copumpkin> I guess they need to be non-empty
10:35:06 <copumpkin> or maybe not
10:35:18 <Landei> @djinn Semigroupoid s => s (a,b) c -> s a (s b c)
10:35:18 <lambdabot> Error: Class not found: Semigroupoid
10:35:26 <ski> > let (<<>>) :: Integer -> Bool; (<<>>) a = (<3) a in (3 <<>>)
10:35:27 <lambdabot>   False
10:35:29 <ski> DevHC ^
10:35:37 <Landei> @djinn Category s => s (a,b) c -> s a (s b c)
10:35:37 <lambdabot> Error: Class not found: Category
10:35:50 <copumpkin> Landei: it can't be written
10:36:26 <Landei> that's what I thought :-)
10:36:34 <copumpkin> you want an exponential class or something
10:37:36 <Landei> I just pondered whether I can get curry and uncurry expressed somewhere in the Arrow hierarchy
10:37:53 <DevHC> ski: in GHC: 2 ♥  ==>  parse error (possibly incorrect indentation)
10:39:06 <ski> DevHC : well, i suppose whatever unicode symbol you're using isn't considered an operator character
10:39:28 <robert[]> hi
10:39:31 <c_wraith> > let (♥) = (+) in 2 ♥ 3
10:39:32 <lambdabot>   5
10:39:33 <robert[]> lets talk about lambda calculus
10:39:34 <copumpkin> :t apply
10:39:35 <lambdabot> Not in scope: `apply'
10:39:38 <c_wraith> that's an operator character
10:39:43 <robert[]> if you want
10:40:08 <copumpkin> Landei: ArrowApply feels a bit exponential
10:40:54 <Landei> hmm, I was just curious
10:41:44 <Landei> @djinn Control.ArrowApply s => s (a,b) c -> s a (s b c)
10:41:44 <lambdabot> Error: Class not found: Control.ArrowApply
10:41:50 <Landei> :-P
10:43:49 <DevHC> ski: also fails with #
10:45:10 <DevHC> > let { (><>) :: Integer -> Bool ; (><>) a = a <3} in (><> 2)
10:45:10 <lambdabot>   Couldn't match expected type `t1 -> t'
10:45:11 <lambdabot>         against inferred type `GHC.B...
10:45:25 <DevHC> > let { (><>) :: Integer -> Bool ; (><>) a = a <3} in (2 ><>)
10:45:26 <lambdabot>   True
10:45:37 <KirinDave> is that the fish operator?
10:45:40 <DevHC> yes
10:46:08 <KirinDave> import Nightmare.Notations ((><>))
10:46:28 <DevHC> import Troll.Notations (.|.) -- penis operator
10:46:36 <shachaf> KirinDave: Needs more Unicode.
10:46:39 <robert[]> lol
10:47:03 <DevHC> > 1337 .|. 1234
10:47:03 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:47:04 <lambdabot>    `Data.Bits.Bits a'
10:47:04 <lambdabot>      a...
10:47:08 <DevHC> > 1337 .|. 1234 :: Integer
10:47:09 <lambdabot>   1531
10:47:28 <KirinDave> DevHC: import Boner.Town
10:47:37 <KirinDave> The dreaded 8==D operator.
10:47:55 <KirinDave> That's how java people make fun of the world of  & scala haskell operators, btw.
10:47:57 <rferranti> fixity matters
10:47:59 <DevHC> 8 can't be part of an operator name
10:48:07 <KirinDave> Evidently furiousdingdong inspired them
10:48:11 <rferranti> lol
10:49:19 <DevHC> uʍop-ǝpısdn
10:49:54 <nejucomo> Why does this naive timing function always return 0 for the time delta?  http://codepad.org/onX5ozc7
10:50:50 <kmc> because you're not forcing b
10:50:55 <binsh> tokenize (xs) =  b ++ tokenize(a)
10:50:55 <binsh> 		where
10:50:55 <binsh> 			b = [takeWhile isDigit xs]
10:50:55 <binsh> 			a = drop (length b) xs
10:50:55 <binsh> 			
10:50:56 <binsh> can anyone help me out on this one?
10:50:58 <binsh> i want to execute "b = [takeWhile isDigit xs]" before "a = drop (length b) xs" but i dont know how to do it :S
10:50:58 <kmc> sure, if you did force b, it would force v before computing (f v)
10:51:04 <kmc> binsh, don't paste here, use hpaste.org
10:51:12 <binsh> okay ;)
10:51:13 <kmc> nejucomo, you should use Control.Exception.evaluate
10:51:34 <kmc> also if you're doing benchmarks, just use Criterion, it's really really easy
10:51:41 <ski> @type \f -> app <<< first app <<< assocL <<< arr ((,) f)
10:51:42 <lambdabot> forall (cat :: * -> * -> *) b c b1. (ArrowApply cat) => cat b1 (cat b c) -> cat (b1, b) c
10:51:44 <ski> @type \f -> arr (\a -> f <<< arr ((,) a))
10:51:45 <lambdabot> forall b (cat :: * -> * -> *) c a (a1 :: * -> * -> *). (Arrow cat, Arrow a1) => cat (b, a) c -> a1 b (cat a c)
10:51:47 <shachaf> binsh: Why do you care about the order that things are executed?
10:51:48 <ski> @type \f g -> app <<< (f &&& g)
10:51:48 <lambdabot> forall (cat :: * -> * -> *) b c a. (ArrowApply cat) => cat a (cat b c) -> cat a b -> cat a c
10:52:00 <kmc> binsh, that's not execution, it's evaluation
10:52:13 <hpaste_> Binsh pasted “halp” at http://hpaste.org/52417
10:52:15 <nejucomo> kmc: I want to do two things:  a. Benchmark some code, and b. Understand evaluation order.
10:52:20 <kmc> ok
10:52:26 <nejucomo> Right now I'm working on b.  I'll use an already made tool for a.
10:52:35 <kmc> nejucomo, well, there's no way to absolutely force evaluation
10:52:36 <nejucomo> So is seq the only way to force a value?
10:52:45 <kmc> you can only add rules like "if you force a, force b also"
10:52:58 <kmc> if you force (f $! v), force v also
10:53:02 <Nimatek> Sometimes Haskell can seem like http://www.smbc-comics.com/index.php?db=comics&id=1169
10:53:04 <kmc> that's how ($!) works
10:53:19 <kmc> nejucomo, no, the basic way to force a value is to pattern-match it
10:53:21 <ski> Landei ^
10:53:26 <kmc> > case undefined of True -> 0; False -> 0
10:53:27 <lambdabot>   *Exception: Prelude.undefined
10:53:28 <nejucomo> kmc: thanks.
10:53:48 <binsh> shachaf, because i want the length of the list takeWhile "took"
10:53:52 <kmc> seq True x = x; seq False x = x
10:53:57 <Landei> yes, trying to comprehend...
10:54:02 <shachaf> binsh: That's not how Haskell works.
10:54:04 <kmc> the magic thing about 'seq' is that it's polymorphic over all data types, and that it works for function types too
10:54:08 <Younder> is parcaticcal hascell in a pdf?
10:54:28 <Younder> is practical hascell in a pdf?
10:54:34 <kmc> you can't distinguish ⊥ from (const ⊥) without seq (or one of the constructs which is essentially sugar for seq)
10:54:38 <binsh> shachaf: hmmkay, im new to this. It almost works the way i want to tho
10:54:39 <ski> > let ( # ) :: Integer -> Bool; ( # ) a = a < 3 in (2 # )  -- DevHC
10:54:40 <lambdabot>   True
10:54:49 <DevHC> binsh: u already have b evaluated first, mostly
10:55:14 <ski> Landei : i defined `assocL' in the obvious way
10:55:18 <ski> @type assocL
10:55:18 <hpc> :t let ( # ) :: Integer -> Bool; ( # ) a = a < 3 in flip (#)
10:55:18 <lambdabot> parse error on input `)'
10:55:19 <lambdabot> forall (ar :: * -> * -> *) a b c. (Arrow ar) => ar (a, (b, c)) ((a, b), c)
10:55:19 <ski> @type assocR
10:55:20 <lambdabot> forall (ar :: * -> * -> *) a b c. (Arrow ar) => ar ((a, b), c) (a, (b, c))
10:55:23 <kmc> nejucomo, Control.Exception.evaluate is what you want here, because it gives you an IO action to force a value
10:55:25 <ski> @type swap
10:55:26 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar (a, b) (b, a)
10:55:29 <ski> @type mirror
10:55:30 <lambdabot> forall (ar :: * -> * -> *) a b. (ArrowChoice ar) => ar (Either a b) (Either b a)
10:55:31 <shachaf> binsh: You don't change values by using drop or takeWhile or anything else. You don't change values ever, in fact.
10:55:34 <DevHC> ski: don't fool me with lambdabot extensions
10:55:39 <ion> The most elegant language ever created has a C-like for loop?
10:55:44 <ski> DevHC : hm ?
10:55:56 <nejucomo> ion: And boner arrays, apparently.
10:55:57 <DevHC> ski: did u try that in ur GHCi?
10:56:12 <kmc> nejucomo, meaning the point at which the evaluation occurs is ordered with respect to other IO
10:56:16 <mm_freak> ion: for loop?  where?
10:56:18 <binsh> shachaf: hmm, okay, its just strange that the name of the function is "takeWhile" when its not "taking" :P
10:56:24 <nejucomo> kmc: Ah, interesting.
10:56:32 <ion> “did uh try that in urrh GHCi durr”
10:56:42 <ion> mm_freak: < Nimatek> Sometimes Haskell can seem like http://www.smbc-comics.com/index.php?db=comics&id=1169
10:56:54 <nejucomo> Suppose the expression (f $! v) is forced.  Does that evaluate v only as much as needed to match the application to f?
10:56:56 <shachaf> binsh: It *is* taking -- it's returning a new list which contains the first n elements of its argument.
10:57:02 <kmc> @src ($!)
10:57:03 <lambdabot> f $! x = x `seq` f x
10:57:04 <yitz> google's new language. ho hum. http://googlecode.blogspot.com/2011/10/dart-language-for-structured-web.html
10:57:05 <shachaf> binsh: It's not modifying its argument, though.
10:57:08 <kmc> nejucomo, it forces x to weak head-normal form
10:57:19 <kmc> yitz, yeah, everyone is remarking about how unremarkable it is
10:57:29 <kmc> nejucomo, it might force x further if f does
10:57:29 <rferranti> fart
10:57:31 <Nimatek> ion: You can't take the comic literally.
10:57:35 <binsh> shachaf: okay. but if i want the rest of xs then, how do i get that? :S
10:57:36 <mm_freak> ion: ah, alright then =)
10:57:48 <Landei> ski: thanks, very interesting!
10:57:48 <shachaf> binsh: I'm not sure what you're trying to do.
10:58:07 <shachaf> binsh: Your code is also really unidiomatic, by the way -- e.g. you don't call functions with the syntax "f(x)".
10:58:07 <DevHC> binsh: what is the "rest of xs"?
10:58:33 <desaiu> Would anyone be willing to help me with a relatively simple function, something I'm sure any intermediate programmer knows how to do. The problem is...
10:58:35 <mm_freak> ski: where do those arrow functions come from?  assocL, etc.
10:58:36 <copumpkin> ski++
10:58:36 <binsh> shachaf, were making a "parser". i want to split "*+123 12" into ["*", "+", "123", "12"]
10:58:38 <nejucomo> Let's say I have a function which results in a large data structure.  How can I "force the data structure" to reside in memory without any unevaluated thunks?
10:59:00 <shachaf> binsh: Look at span and break.
10:59:03 <mm_freak> nejucomo: use Control.DeepSeq
10:59:13 <mm_freak> nejucomo: it's in the deepseq package
10:59:14 <binsh> DevHC, The rest is xs - what "takeWhile" took
10:59:21 <binsh> shachaf, okay
10:59:30 <nejucomo> If code recursively visits every node and matches it, is that sufficient?  If that code returns (), will an optimization prevent "forcing the whole data structure"?
10:59:47 <kmc> nejucomo, no, such an optimization would be semantically unsound
10:59:47 <nejucomo> mm_freak: My question is how to write DeepSeq.  I suppose I should go read the source.
10:59:47 <desaiu> You are given a list of values, [820, 1000, 2200, 3300, 4700, 5600], and you are asked to find a combination of those values which produce the values in this list [374, 417, 530, 825, 1068, 1320, 1440, 2555]
10:59:48 <ski> DevHC : as already mentioned, you need an extension (namely `PostfixOperators') for it to be allowed to use left sections of an operator which has type `A -> B' where `B' is not of form `.. -> ..'
11:00:04 <ski> copumpkin : hm ?
11:00:07 <co_dh> greeting, how do you solve the following problem? cabal: cannot configure containers-0.4.2.0. It requires deepseq ==1.2.*
11:00:10 <copumpkin> ski: your ArrowApply stuff
11:00:15 <shachaf> I recommend the word "quiet" to be used for "unsound" henceforth.
11:00:17 <nejucomo> kmc: So it is sufficient to recursively visit each node, match it, and use seq on the recursions?
11:00:18 <mm_freak> nejucomo: ah, for an own data structure…  well, there are two things to force here:  the elements and the data structure
11:00:21 <ski> mm_freak : i defined `assocL' (and the other whose type i showed)
11:00:21 <kmc> yes
11:00:33 <kmc> that polymorphic recursion is realized by the NFData type class
11:00:39 <mm_freak> nejucomo: a recursive walk through the structure together with forcing elements met along the way should do it, but it really depends on your data structure
11:00:43 <desaiu> I just finished http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics#Recursion so I'm aware of functions that can be applied to a list: map, head, tail, foldr, filter
11:00:52 <nejucomo> mm_freak, kmc: Thanks.
11:00:53 <joevandyk> When I create a haskell application, I can use cabal to indicate what packages the application depends on, right?
11:01:00 <dcoutts> co_dh: easy, don't upgrade your containers lib.
11:01:00 <shachaf> desaiu: That's often a bad way to operate on lists.
11:01:05 <desaiu> I think I can come up with the solution using what I know, these functions
11:01:12 <alpounet> joevandyk, yeah, you list them in your .cabal file
11:01:14 <shachaf> desaiu: People prefer to avoid head and tail, in particular, for pattern matching.
11:01:15 <mm_freak> nejucomo: more formally you need to force everything into WHNF, such that there is no uncertainty about constructors anymore
11:01:29 <desaiu> I could whip this out in python, but I want to learn haskell
11:01:39 <co_dh> dcoutts: can you be more specific?
11:01:48 <joevandyk> alpounet: when i install them, does cabal create a file that lists the versions of the dependencies (and the dependencies of the dependencies)?
11:01:49 <mm_freak> to force Just (Just (Just 3))) you first force the outermost Just, then the middle layer Just, then the innermost Just and finally the 3
11:02:02 <desaiu> Given what I know about Haskell, I should just not try this then?
11:02:04 <dcoutts> co_dh: you almost certainly do not need the later version of the containers package. Just use the one that you have installed already.
11:02:07 <c_wraith> co_dh: containers is one of the packages that ghc itself depends on.  It shouldn't be re-installed
11:02:20 <mm_freak> ski: it looked similar to Cale's ArrowPair class, that's why i asked
11:02:37 <alpounet> joevandyk, no, but you can specify constraints on the versions of the dependencies in the .cabal file of your project too
11:02:37 <shachaf> desaiu: If YAHT is recommending the use of head and tail, you should probably find some other guide instead. :-)
11:02:52 <alpounet> and you can find out what versions of the dependencies are installed on your system
11:02:55 <ski> copumpkin : it wasn't very hard ..
11:02:56 <joevandyk> alpounet: hm, but what if the dependencies of the dependencies change?
11:03:01 <alpounet> (ghc-pkg list name-of-the-package)
11:03:03 <copumpkin> ski++
11:03:04 <co_dh> I'm using Yesod, and I enter : cabal install in Yesod init created folder, so I don't know why it's try to config container-0.4.2.0
11:03:09 <joevandyk> alpounet: i have no way of locking down all the depdencies?
11:03:10 * ski groans
11:03:10 <desaiu> shachaf: It isn't based on yaht, it's some work in my class lab. The professor told me to just play around with some resistors
11:03:17 <desaiu> I'd prefer to let the computer tell me which ones I need
11:03:24 <alpounet> joevandyk, you can put very tight constraints, but generally people don't
11:03:27 <desaiu> But I also want to figure it out using haskell
11:03:33 <mm_freak> joevandyk: cabal manages dependencies completely…  you as a package developer don't have to deal with that
11:03:35 <alpounet> joevandyk, in particular, there's the package versionning policy
11:03:41 <joevandyk> with ruby's bundler, it creates a file that lists the exact version of everything my application uses
11:03:46 <gwern> if SF has taught me anything, it's that resistors are useless
11:03:49 <mm_freak> joevandyk: just focus on the dependencies of your own package
11:03:51 <alpounet> @where pvp
11:03:51 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
11:03:55 <desaiu> sf?
11:03:57 <alpounet> joevandyk, ^^^
11:03:58 <ski> mm_freak : i can't recall looking at that one, but yes, it would be much nicer to have a class such that these operations can be written without having to use `arr' at all
11:04:00 <joevandyk> so if another person installs the software two years from now, they get the exact same stuff that i was using
11:04:01 <shachaf> San Francisco, clearly.
11:04:02 <yitz> shachaf: that's not fair. there are some situations where it really does make sense t*Exception: Prelude.head: empty list
11:04:12 <nejucomo> desaiu: I recommend realworldhaskell.org.  I'm a pythonista and that was the first Haskell reference that I found to be not confusing.
11:04:16 <alpounet> joevandyk, so, with no performance improvements, for example? :)
11:04:17 <yitz> oops
11:04:23 <desaiu> San francisco has taught you that resistors are useless? o.O
11:04:26 <shachaf> yitz: NO CARRIER jokes of the 21st century, eh?
11:04:38 <kmc> wow the channel is really active right now
11:04:46 <yitz> shachaf: heh
11:04:55 <joevandyk> alpounet: yes, i'd rather have it be consistent.  if someone introduces a bug in a later version of a dependency of a dependency of a dependency, i don't want to deal with that
11:05:02 <copumpkin> ski: you have any ideas on how to define that map transpose function elegantly I asked about earlier?
11:05:07 <desaiu> Okay, I will just try to figure this out on my own :)
11:05:10 <mm_freak> ski: there is more…  apparently iPwn has written a preprocessor for arrow notation, which optimizes proc/do blocks based on ArrowPair
11:05:21 <mm_freak> i'd love to get my hands on that, because i work a lot with arrow notation
11:05:22 <desaiu> And ask when I have code to show
11:05:30 <ski> (Ceterum autem censeo, `arr'inem esse delendam)
11:05:38 <dcoutts> co_dh: hmm, perhaps it really does need it. Does "cabal info deepseq" tell you that 1.2 is available?
11:05:51 <alpounet> joevandyk, then specify very tight constraints on the dependencies version
11:05:52 <ski> mm_freak : any link ?
11:05:54 <joevandyk> mm_freak: what if a dependency depends on something else, and the newest version of the something else has a bug?
11:05:56 <nejucomo> desaiu: codepad.org is handy for sharing code examples, has haskell highlighting, and will compile/run examples if you wish.
11:06:01 <mm_freak> ski: it's not released, as far as i know
11:06:14 <alpounet> joevandyk, but keep in mind people maybe already have these dependencies installed, just another version, and that it may work
11:06:21 <co_dh> dcoutts: yes. Versions available: 1.0.0.0, 1.1.0.0, 1.1.0.1, 1.1.0.2, 1.2.0.0, 1.2.0.1
11:06:24 <joevandyk> alpounet: i have to specify the versions of the entire dependency chain by hand?
11:06:28 <mm_freak> joevandyk: contact the author of the package and have it be fixed ;)
11:06:37 <alpounet> you just have to figure out the bounds of your dependencies' versions that are consistent with your package
11:06:45 <mm_freak> joevandyk: you are always free to install certain versions manually
11:06:55 <ski> copumpkin : my first thought was trying to adapt the `foldr (zipWith (:)) (repeat [])' one, in some way -- i'm not sure whether that's sensible in this case, though
11:07:02 <joevandyk> mm_freak: seems that cabal should allow me to easily lock down an entire dependency chain
11:07:06 <joevandyk> like bundler
11:07:10 <mm_freak> joevandyk: cabal will only install dependencies, if it can't satisfy dependencies with the currently installed packages
11:07:23 <nejucomo> joevandyk: Your desire to have literal snapshots as dependencies is admirable: Publish the *actual* code you've tested against, don't break on dependency changes...
11:07:27 <ski> Landei : currently i'm wondering whether `(cat a b -> cat a c) -> cat a (cat b c)' or `(forall a. cat a b -> cat a c) -> cat a (cat b c)' can be written ..
11:07:44 <mm_freak> so if you have a package version 0.9 and 1.0 has a bug, but your package only requires >= 0.9, then cabal won't do anything
11:07:54 <nejucomo> -but there's a flipside:  Library a fixes critical bug (security, for example), and all code which depends on library a should benefit from the fix without delay.
11:07:57 <dcoutts> co_dh: try cabal install --conatraint='deepseq >= 1.2'. My guess is that there's some conflict somewhere in the versions that things are requesting.
11:08:12 <joevandyk> nejucomo: then i should specify the newer version in my cabal file?
11:08:17 <mm_freak> joevandyk: you can make your own package depend specifically on a certain version, even if that package is not a direct dependency of your package
11:08:45 <robert[]> de brjuin indices
11:09:06 <robert[]> data L = Var Nat | Lam L | Apo L L
11:09:09 <robert[]> data L = Var Nat | Lam L | App L L
11:09:12 <Landei> ski: I don't know, but wouldn't expect it
11:09:14 <robert[]> this is de brjuiojn notation
11:09:27 <mm_freak> ah, there we go again
11:09:47 <robert[]> b[0:=x][i:=n] = b[1+i:=n^][0:=x[i:=n]]
11:09:51 <robert[]> is this a theorem?
11:09:59 <robert[]> does anyone know about this theorem?
11:10:13 <robert[]> n^ means lifting all the free varaibles up by 1
11:10:31 <mm_freak> and again with a different set of misspellings for de bruijn
11:10:36 <robert[]> for example (App (Var 0) (Lam (Var 0)))^ = App (Var 1) (Lam (Var 0))
11:10:37 <copumpkin> robert[]: are you despondent types?
11:11:01 <mm_freak> i'm starting to believe that there are multiple of those de b* guys
11:11:16 <robert[]> hrs
11:11:22 <mm_freak> desparate types
11:11:36 <joevandyk> mm_freak: but i'd need to manually create the cabal file with the entire dependency chain and all the versions, right?
11:11:37 <robert[]> this is commuting substitions
11:11:46 <copumpkin> robert[]: just curious because ccasin was looking for despondent types on IRC :)
11:11:48 <joevandyk> With ruby's bundler, i can do this: https://raw.github.com/gist/1276068/0dab7fbdcbce2d404cb4fd2cbe185f773b2829e3/gistfile1.txt
11:12:13 <Landei> bye!
11:12:21 <mm_freak> joevandyk: that's not possible with cabal
11:12:31 <joevandyk> so i enter the dependencies in the Gemfile at the top.  then i run 'bundle install' and bundler generates the Gemfile.lock file for me with the exact versions of all the dependencies.
11:12:47 <dcoutts> or only indirectly possible, by specifying extra version constraints on the command line
11:12:48 <joevandyk> then when someone else runs 'bundle install', they get the exact same versions as me
11:12:58 <robert[]> it is very difficul to prove
11:13:05 <ccasin> robert[], copumpkin: :) solved this mystery already by looking at the coq channel
11:13:17 <mm_freak> joevandyk: but what you can do for development is to use cabal-dev
11:13:26 <Rmx> Hi, I want to execute a string like "runhaskell lalala.hs" from a haskell program.
11:13:40 <mm_freak> then you can have a project-specific cabal directory
11:13:42 <Rmx> how can I hook the windows or linux console
11:13:48 <alpounet> Rmx, System.Process ?
11:13:50 <alpounet> oh
11:13:57 <Rmx> :p
11:14:22 <copumpkin> ski: yeah, that might work
11:14:44 <copumpkin> ski: I was also thinking of trying the ZipList transpose
11:14:55 <copumpkin> ski: since Map is almost an Applicative with ZipList-like semantics
11:14:56 * hackagebot stm-stats 0.2.0.0 - retry statistics for STM transactions  http://hackage.haskell.org/package/stm-stats-0.2.0.0 (JoachimBreitner)
11:15:02 <robert[]> b[0:=x][i:=n] = b[1+i:=n^][0:=x[i:=n]]
11:15:03 <dcoutts> joevandyk: presumably with that gem example you're only pinning down some versions of deps, not all of them all the way down right? So people could use that same bundle on a slightly different ruby version for example?
11:15:22 <robert[]> proof by induction
11:15:24 <joevandyk> dcoutts: no, it specifies all the entire dependency chain
11:15:43 <dcoutts> joevandyk: oh so it's only good for the exact same ruby version
11:15:49 <joevandyk> dcoutts: ?
11:15:55 <joevandyk> dcoutts: it specifies gems, not ruby version
11:16:00 <robert[]> but to do induction you have to generaliszez
11:16:12 <dcoutts> joevandyk: ah so it covers all packages except the standard libs?
11:16:31 <joevandyk> dcoutts: yes
11:16:39 <robert[]> 0 does not occur in n^
11:16:57 <joevandyk> dcoutts: the neat thing about bundler is you can specify git repositories and filesystem locations to look for the packages
11:17:04 <dcoutts> joevandyk: I see, that'd be slightly more tricky for us, since we don't make a clear cut distinction between standard library and user installed library.
11:17:09 <copumpkin> ski: the problem is the base case
11:17:28 <joevandyk> i.e. gem 'something', :git => "http://something.com/blah.git", :ref => 'asdfasdf'
11:17:45 <joevandyk> then it checks out the git repository and builds the gem
11:17:52 <dcoutts> joevandyk: they're all registered in the same way. So if we pinned them all down exactly then it would only be usable on exactly the same configuration, same ghc version etc.
11:18:27 <ccasin> robert[]: check out the proof of open_open_swap in the files I sent you.  You're right: you must generalize the 0 to go under binders, and then you'll have to generalize your lift operation because not everything in n should be lifted.  I don't know a simpler way.
11:18:48 <joevandyk> dcoutts: my use case is mostly for web apps -- i develop locally, then want to deploy them.  ideally development environment matches production environment, and everyone's development environment is the same.
11:19:06 <robert[]> cool ccasin
11:19:08 <robert[]> thanks
11:19:42 <joevandyk> dcoutts: doesn't the standard library come with ghc?  do you need to use cabal for that?
11:20:00 <dcoutts> joevandyk: Oh it does, but it's registered just like any other library.
11:20:26 <dcoutts> joevandyk: so if you look at the dependencies of a package you install, it'll include base, rts, ghc-prim, etc
11:21:33 <alpounet> joevandyk, you can specify the exact version you want to install, when installing a package
11:21:45 <alpounet> i admit it'd be cumbersome to do that with a whole chain of dependency...
11:23:35 <co_dh> dcoutts: thanks,  deepseq >=1.2 failed because cabal: cannot configure aeson-native-0.3.3.1. It requires deepseq <1.2
11:24:06 <dcoutts> joevandyk: right, so the appropriate equivalent in the Cabal world would not be to pin down versions in the .cabal file, since that's supposed to be generic and flexible, but some extra local config file that lists exact version constraints
11:24:52 <dcoutts> joevandyk: the nearest thing you could do right now is to generate a script which calls cabal with flags like --constraint='foo==1.0'
11:24:57 <kamaji> Does anyone want to tell me that i'm stupid and why? :D
11:25:06 <dcoutts> and that'd give you reproducible configurations
11:25:20 <mm_freak> kamaji: you're stupid, but i don't know why =P
11:25:27 <kamaji> heheh
11:25:58 <mm_freak> kamaji: ok, you're stupid for insisting on hash tables ;)
11:26:03 <mm_freak> (i'm joking of course)
11:26:14 <hpaste_> kamaji pasted “State Monad Funtimes” at http://hpaste.org/52421
11:26:24 <kamaji> mm_freak: lol
11:26:38 <kamaji> mm_freak: well I tried really hard to think of a reason you were wrong but I couldn't without doing some actual benchmarking
11:26:45 <kamaji> so i'll just assume i'm wrong until otherwise proven~
11:27:05 <kamaji> so is there a way to do what I just did with the state monad with a fold?
11:27:11 <kamaji> or something like that
11:27:34 <kamaji> it basically takes n unique items from a list, and attaches the "unused" items back to the front of the list
11:27:45 <ski> copumpkin : yes, i think it's a bit similar to the problems with transposing a list of lists
11:27:57 <kamaji> and is supposed to be used with an infinite list because I didn't check for []
11:28:07 <mm_freak> kamaji: first question, any reason to use a state monad here?
11:28:15 <kamaji> mm_freak: I didn't know how to do it another way
11:28:22 <kamaji> also I wanted to learn how to use the state monad
11:28:36 <mm_freak> kamaji: my suggestion is to write a non-monadic interface first, and then wrap a monadic interface around it
11:28:57 <kamaji> mm_freak: don't quite follow
11:30:40 <mm_freak> kamaji: well, in this case you are mixing two unrelated concepts:  first of all, from what i've seen the numbers aren't going to be unique at all
11:30:58 <mm_freak> you are returning duplicates just as well, but you're recording them
11:31:14 <kamaji> mm_freak: oh right, yeah
11:31:28 <kamaji> mm_freak: well I wanted to return the uniques and a modified list of randoms
11:31:29 <shirt> why doesn't hlint like the use of "otherwise"?
11:31:49 <mm_freak> your function should have this signature:  nubPartition :: Eq a => [a] -> ([a], [a])
11:31:56 <mm_freak> no state monad at all
11:32:20 <mm_freak> it should partition the list into uniques and duplicates
11:32:39 <kamaji> it's not returning duplicates though
11:32:51 <kamaji> it's returning duplicates and the 'source' list
11:32:57 <kamaji> concatenated
11:32:58 <mm_freak> for a much faster implementation, here is a better type:  nubPartition :: Ord a => [a] -> (Set a, [a])
11:33:30 <mm_freak> huh?  i don't think so
11:33:44 <kamaji> uniques n xs = (uniques, dupes++xs')
11:33:45 <kamaji>  ?
11:33:48 <mm_freak> it's returning every element
11:33:48 <kamaji> oohhh shit
11:33:52 <kamaji> is that recursing
11:34:06 <kamaji> I renamed a variable
11:34:09 <ski> @type mapAccumL
11:34:10 <ski> @type mapAccumR
11:34:10 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:34:10 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:34:13 <kamaji> why does that even compile
11:34:28 <mm_freak> and sets the final state to contain the non-visited portion of the list, the uniques and the duplicates
11:34:33 <kamaji> oh, does the 'where' override the name of the function?
11:34:35 <tsousa> what does Map.map does in this ? http://dpaste.com/631577/
11:34:43 <kamaji> ski: is that for me?
11:34:54 <shachaf> tsousa: It's Map.Map, not Map.map.
11:34:57 <shachaf> tsousa: It's a type.
11:35:06 <mm_freak> kamaji: yes, it does
11:35:07 <tsousa> what does it do?
11:35:17 <shachaf> tsousa: It maps keys to values.
11:35:30 <kamaji> mm_freak: it's returning the uniques, and then the duplicates++restOfXs
11:35:43 <shachaf> tsousa: Like a dictionary/hash table/associative array/whatever you want to call it.
11:35:50 <tsousa> ok thanks
11:35:57 <tsousa> and Map.Map is a type?
11:36:05 <kamaji> xs is supposed to be an infinite list of randoms, so you don't 'waste' the randoms you generated but didn't want this time
11:36:07 <shachaf> Well, it's just called "Map".
11:36:12 <mm_freak> kamaji: the nextUnique computation returns the next number in the original list, no matter whether it's unique or not
11:36:21 <kamaji> mm_freak: oh yeah, i'm not using that though
11:36:21 <kamaji> heh
11:36:29 <kamaji> it's throwing away acc
11:36:31 <kamaji> I should make that _
11:36:34 <kamaji> or just replicateM_
11:36:35 <tsousa> shachaf, but a Type can do stuff? Int doesnt do anything
11:36:41 <mm_freak> kamaji: i think you're abusing a state monad here
11:36:50 <mm_freak> kamaji: you really should try without it
11:37:02 <ski> @type (state .) . mapAccumL . (runState .)
11:37:03 <lambdabot> forall a y. (a -> State y a) -> a -> State [y] a
11:37:04 <kamaji> mm_freak: with mapAccumL
11:37:05 <ski> @type (state .) . mapAccumR . (runState .)
11:37:05 <lambdabot> forall a y. (a -> State y a) -> a -> State [y] a
11:37:06 <shachaf> tsousa: Nor does Data.Map.
11:37:08 <kamaji> ski: thanks :P
11:37:13 <ski> kamaji : if you like it
11:37:14 <mm_freak> kamaji: yes, that's one option
11:37:16 <shachaf> tsousa: Oh, wait. What does that line even mean?
11:37:21 <kamaji> mm_freak: what would you suggest instead?
11:37:22 <shachaf> tsousa: Looks like invalid syntax to me.
11:37:35 <mm_freak> kamaji: a simple partitioning function
11:37:52 <tsousa> shachaf, before that line is type LockerMap
11:38:03 <tsousa> so it's a synonim
11:38:05 <kamaji> mm_freak: I convinced myself that wouldn't work, maybe I was wrong
11:38:14 <shachaf> tsousa: Well, there you go.
11:38:15 <mm_freak> nubPartition :: Ord a => [a] -> ([a], [a])
11:38:31 <mm_freak> you can also replace Ord by Eq, but then you can't use a Set under the hood anymore
11:38:32 <shachaf> tsousa: You should probably learn a bit more about Haskell syntax and types and then it'll be clearer. :-)
11:39:00 <tsousa> shachaf, i am reading Lyah but it's a bit confusing
11:39:17 <kamaji> mm_freak: but that won't return the modified source list
11:40:06 <ski> kamaji : though in your case it might be simpler with something like `compose . replicate n foo
11:40:09 <ski> '
11:40:15 <robert[]> there is something important in lambda calculus
11:40:23 <robert[]> something about generalized lifts
11:40:35 <robert[]> missing in the definition, but arising from proofs
11:41:01 <robert[]> congruence closure through lambda binders
11:41:03 <robert[]> it is this
11:41:23 <lysgaard> Anyone here managed Haskell to run in a web browser?
11:42:04 <kamaji> ski: i've not seen compose before, that's just doing >>= on [foo,foo,foo ... n ], right?
11:42:42 <kamaji> wait no... shit :|
11:43:17 <ski> robert[] : btw, have you tried stating and proving the corresponding substitution distribution, in plain lambda-calculus (not using de Bruijn indices) ?
11:43:54 <robert[]> ski,
11:44:12 <robert[]> I have only considered de briujn terms
11:44:14 <hpaste_> “Ertugrul Söylemez” pasted “Duplicate partitions” at http://hpaste.org/52422
11:44:21 <mm_freak> kamaji: see the paste
11:44:39 <ski> kamaji : one definition is `compose = foldr (.) id', another is `compose = flip (foldr ($))'
11:45:26 <mm_freak> kamaji: you can extract the duplicates by using 'lefts' and the uniques by using 'rights' from Data.Either
11:45:39 <mm_freak> and through this list you always know where in the original list you currently are
11:45:57 <mm_freak> because there is a direct correspondence between positions in the original list and the result list
11:46:19 <ski> robert[] : btw, one can also consider, given any term `M' with free variable set `X' (not containing `x'), a term `x^M' which is considered to have free variable set `X \union {x}', but which behaves like `M'
11:47:41 <ski> robert[] : i think this corresponds somwwhat to your `n^', except it generalizes from inserting `0' to inserting any variable (and, obviously using named rather than numbered variables)
11:48:20 <ski> > [id,id ..]
11:48:21 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
11:48:22 <lambdabot>    arising from a use of `e_1' at ...
11:49:11 <obiwahn> ion: you asAppliedTo is awesome - thank you:)
11:49:14 <mm_freak> kamaji: in general there are only few use cases for pure state monads (i.e. State)…  state monads are usually rather found in a transformer stack (i.e. StateT)
11:49:30 <mm_freak> kamaji: whenever you are tempted to use a pure state monad, try without it first
11:49:33 <ski> copumpkin : i suppose if we have a key which maps to an empty map, that info will be lost
11:49:36 <ski> however :
11:49:42 <mm_freak> the nonmonadic solution is usually nicer
11:49:43 <kamaji> mm_freak: sorry I'm trying to figure out that function still, hahah
11:49:49 <ski> > transpose [[0,1],[],[2]]
11:49:50 <lambdabot>   [[0,2],[1]]
11:49:58 <ski> > (transpose . transpose) [[0,1],[],[2]]
11:50:02 <lambdabot>   mueval-core: Time limit exceeded
11:50:07 <copumpkin> omnom
11:50:07 <kamaji> mm_freak: does it not require me to examine the return value to drop values from the source list?
11:50:15 <hpc> ski: wut
11:50:24 <ski> @slap lambdabot
11:50:24 * lambdabot hits lambdabot with an assortment of kitchen utensils
11:50:26 <ski> > (transpose . transpose) [[0,1],[],[2]]
11:50:28 <lambdabot>   [[0,1],[2]]
11:50:56 <mm_freak> kamaji: you drop as you examine…  one natural operation for the resulting list is folding, for example
11:51:03 <Twey> That seems like a very computationally expensive (filter (not . null))
11:51:10 <ski> copumpkin : i suppose we get a pseudo-inverse at least ..
11:51:14 <copumpkin> yeah
11:51:19 <ski> .. i wonder whether we get an adjunction
11:51:21 <copumpkin> adjunction!
11:51:21 <copumpkin> yes
11:51:22 <tsousa> Data.Map.Map creates a type because it's can only execute that type i am correct?
11:51:29 <ski> (which ordering is relevant ?)
11:51:31 <copumpkin> tsousa: wat
11:51:39 <mm_freak> tsousa: sorry, that didn't really make sense
11:52:06 <mm_freak> tsousa: Map is a type constructor…  with two type arguments it becomes a type
11:52:09 <tsousa> copumpkin,  Data.Map.Map creates a new time?
11:52:10 <mm_freak> like Map Int String
11:52:15 <tsousa> type
11:52:44 <tsousa> mm_freak, ok then it maps it all with the int as key and String as value right?
11:52:56 <ski> robert[] : anyway, Paul Taylor's "Practical Foundations of Mathematics" at <http://www.cs.man.ac.uk/~pt/Practical_Foundations/> mentions this `x^M' construction
11:53:07 <mm_freak> Map Int String is the type for maps from Int values to String values, if you mean that
11:53:13 <robert[]> ski thank you veruy much@
11:53:36 <ski> robert[] : also, `(x^)' has `exists x.' as left adjoint and `forall x.' as right adjoint
11:53:45 <tsousa> mm_freak, an Int becames a String ?
11:53:59 <robert[]>  ski WOW!!
11:54:08 <robert[]> so its the basis of logic
11:54:19 <ski> robert[] : maybe you'd be interested in Bart Jacobs "Categorical Type Theory", as well ..
11:54:28 <mm_freak> tsousa: no, but Map Int String is the type for dictionaries, where the terms are Int values and the definitions are String values
11:54:48 <mm_freak> tsousa: the actual "turning int into string" is done by Data.Map.lookup and other functions
11:54:49 <robert[]> where in Taylor is x^M mentioned
11:55:11 <tsousa> mm_freak, like (1,"Hey") that in a dictionary offcouse right?
11:55:16 <rferranti> you guys scare me a lot :|
11:55:18 <kamaji> mm_freak: but the calling function will have the original list no?
11:55:32 <mm_freak> tsousa: that is a dictionary, although it's of a different type:  [(Int, String)]
11:55:47 <tsousa> mm_freak, yes i understand
11:55:49 <mm_freak> kamaji: yes, but it doesn't need it
11:55:57 <tsousa> mm_freak, thank you
11:56:07 <mm_freak> kamaji: try to work out how to reconstruct the original list from the result of nubPartitions
11:56:37 <mm_freak> kamaji: the new list contains more information than the original, but no information is lost
11:57:21 <mm_freak> rferranti: what's wrong?
11:58:55 <mm_freak> kamaji: hint:  Either a a is isomorphic to (Bool, a) except with slightly different semantics
11:58:56 <rferranti> mm_freak, nothing really, i just feel a bit overwhelmed every time i join this channel
12:00:30 <shachaf> "isomorphic except with slightly different semantics"
12:01:23 <mm_freak> shachaf: ok, it's isomorphic to (Bool, a), where the Bool field is strict
12:01:26 <hpc> mm_freak: do bottoms really count as information?
12:01:39 <hpc> oh in this case they do
12:01:49 <hpc> you can still get an 'a' out of (undefined, foo)
12:01:50 <mm_freak> hpc: i would think so, since they make an extra element in every set
12:02:10 <ski> robert[] : and "Sets for Mathematics" by F. William Lawvere,Robert Rosebrugh at <http://www.mta.ca/~rrosebru/setsformath/>, also "Introduction to Higher Order Categorical Logic" (harder) by J. Lambek -- "Conceptual mathematics: a first introduction to categories" (for beginners in CT) by F. William Lawvere and Steven Schanuel is also nice
12:02:15 <kmc> rferranti, :)
12:02:20 <kmc> we're very friendly to beginners, i promise
12:02:21 <robert[]> ski youre a star
12:02:29 * ski is not a star
12:02:32 <robert[]> ok
12:02:33 <robert[]> :D
12:02:44 <kmc> rferranti, there's a big overlap between the Haskell people and the crazy maths people, but that doesn't mean you actually need to know crazy maths to use Haskell
12:03:27 <tac-tics> rferranti: What kmc said. Just because all Haskell blogs are also Category Theory blogs doesn't mean you need to know jack about CT to do Haskell :)
12:03:36 <tac-tics> (though a rudimentary understanding can help a bit)
12:03:41 <hpc> arguably, being a crazy math person harms your ability to be productive in haskell
12:03:49 <mm_freak> i have no idea about CT and yet use haskell productively
12:04:02 <xil> I have a program using Gtk2Hs. It works intermittently when I run it from the interpreter, but it doesn't seem to work I compile it
12:04:06 <hpc> guess how many people use category-extras who aren't edwardk? :P
12:04:43 <kmc> hey there's no category theory on my blog
12:04:50 <rferranti> tac-tics, that's not the problem per se, i bought 2 ct books before buying an haskell one, the real problem is whenever i join here i always wonder "what the hell was i doing in the last 10 years" ( btw i didn't want to divert the discussion, and thank you all :) )
12:04:55 <ski> robert[] : "where in Taylor is x^M mentioned" -- see end of 1.1, then remark 1.5.5, then final chapter (ix)
12:05:15 <hpc> xil: what's the error?
12:05:37 <mm_freak> i use edwardk's libraries…  you can learn them piece by piece =)
12:05:44 <kamaji> mm_freak: sorry phone call happened
12:05:51 <mm_freak> category-extras is one huge question mark to me
12:05:59 <hpc> mm_freak: i think you are a robot :P
12:06:24 <mm_freak> hpc: could you state that question again, please?
12:06:28 <xil> hpc: the only error I get is sometimes when running from the interpreter, and it's this "<interactive>: Fatal IO error 11 (Resource temporarily unavailable) on X server :0.0."
12:07:55 <xil> hpc: I have a DrawingArea that I copy a Pixmap to every 50ms
12:07:57 <rata_> hi again
12:08:34 <ski> copumpkin : hm .. i wonder whether anybody has attempted an `HList'-analogue for `Map's
12:08:44 <copumpkin> ski: what sort?
12:09:05 <ski> copumpkin : where the extant keys are statically known in the type
12:09:09 <copumpkin> I made some maps where both keys and values were indexed by the sam ething
12:09:10 <copumpkin> oh
12:09:10 <hpc> xil: google is giving me the impression that your X is misconfigured in some way, but isn't giving any details
12:09:14 * hpc is stumped
12:09:17 <copumpkin> ski: that'd be tricky :)
12:09:51 <xil> hpc: wouldn't surprise me if it is. My config is pretty shoddy and I don't get enough help from my OS channel
12:10:04 <ski> copumpkin : so that you could require in the type that every sub-map in the nested map has the same keys, so that transposition works flawlessly
12:10:34 * ski wonders about `Map (Map v0 k) v1'
12:11:35 <hpaste_> rata pasted “Functional dependencies” at http://hpaste.org/52423
12:11:43 <kamaji> mm_freak: I can't really see how I'd use that for my purposes though :\
12:12:04 <rata_> is there anything wrong with http://hpaste.org/52423 ?
12:12:34 <ski> rata_ : `energy :: Metropolis s a => s -> Double' is ambiguous
12:12:38 <rata_> I mean, am I using type classes in the "right" way?
12:12:52 <rata_> ski: why?
12:13:06 <ski> hm, no it isn't, ignore that
12:13:10 <rata_> ok
12:13:43 <mm_freak> kamaji: you can consume the result list element by element
12:13:54 <rata_> (note that there will be other instances of the Metropolis type class)
12:13:54 <mm_freak> kamaji: for that you can use a state monad or even an enumerator
12:14:38 <kamaji> mm_freak: but then aren't I using the State monad anyway?
12:14:56 <mm_freak> kamaji: i wouldn't =)
12:15:23 <joevandyk> stupid question: how do i add an int to a string?  i.e. "select * from images limit " ++ someInt
12:15:25 <mm_freak> i don't know your application, so i can only list the ways you can use this list
12:15:38 <mm_freak> joevandyk: show
12:15:44 <kamaji> I just wanted n uniques, but without throwing away the random numbers i'd generated that weren't unique
12:15:53 <kamaji> so I add them back onto the source list of randoms
12:15:56 <shachaf> joevandyk: show :: Int -> String
12:16:00 <joevandyk> mm_freak: ah, thanks
12:16:00 <kamaji> for the next call to use
12:16:00 <ion> obiwahn: Not mine. I think it was made by ski.
12:16:01 <shachaf> It's not really adding.
12:16:15 <shachaf> joevandyk: Also, constructing SQL queries that way is often a really bad idea. :-)
12:16:16 <mm_freak> joevandyk: have a look at HDBC, which lets you build SQL in a safer way
12:16:33 <joevandyk> yeah, i know.  i'm going through another haskell program and slowly cleaning it up.
12:16:42 <joevandyk> there's a function called getLastSixImages
12:16:43 <joevandyk> :(
12:16:52 <mm_freak> kamaji: oh, i see…  you shouldn't do that
12:17:02 <mm_freak> kamaji: your numbers become much less random that way
12:17:33 <mm_freak> it's fine to throw away random numbers with good generators
12:17:54 <kamaji> mm_freak: Why do they become less random?
12:18:31 <kamaji> I thought it wouldn't affect it
12:18:34 <parcs> mm_freak: are the source repositories to your packages hosted anywhere?
12:19:39 <kamaji> it was mainly to minimise the amount of generation I did, although I really should just throw them away since I don't _really_ know it's a problem
12:20:48 <mm_freak> kamaji: when you generated your random first number, that one is going to be taken as a unique number…  then someone who knows this number will know that the probability for the next number to be that number in the duplicates stream is higher than for all other numbers
12:21:02 <mm_freak> parcs: no, i'm sorry…  right now i have only local darcs repositories
12:21:37 <mm_freak> parcs: i think i will upload them this week to my server
12:21:50 <ski> obiwahn : i made `asTypeIn', someone else made the `asAppliedTo' variant of it (maybe Cale)
12:22:07 <parcs> mm_freak: you can also host them on darcsden/patch-tag :)
12:22:27 <mm_freak> parcs: do i have SSH access to those?
12:23:03 * ski wonders whether `flip asAppliedTo' would be useful, and in that case, what name it should have
12:23:41 <Masxmasx{AFK}> I am trying to use random variables/functions (getStdRandom) in an non-IO function. Is it possible to use Random and still output something non-IO?
12:23:48 <parcs> not sure, i haven't used them
12:24:20 <tac-tics> Masxmasx{AFK}: Yes. The trouble you'll run into is creating a random number generator purely
12:24:45 <Masxmasx> could you elaborate please, tac-tics?
12:25:13 <kmc> Masxmasx, you can generate an infinite list of random numbers and pass it into your function
12:25:28 <tac-tics> Using getStdGen, you'll be confined to IO
12:25:48 <Masxmasx> Maybe I'm misunderstanding my teacher's questions then =\
12:25:50 <Taejo> personally, my preferred method is to use MonadRandom
12:25:59 <shachaf> Can you generate an infinite list of actual random numbers without evil unsafeInterleaveIO-ish things?
12:26:04 <kamaji> shachaf: yeah
12:26:19 <kamaji> hang on
12:26:26 <Taejo> shachaf: a random-number generator is a pure thing, you just need IO to create one
12:26:27 <kamaji> randomRs
12:26:31 <Taejo> *pseudo-
12:26:32 <tac-tics> Masxmasx: I think if you want random numbers in a function, you should take a StdGen object as input
12:26:34 <Twey> Of course you can
12:26:35 <robert[]> actual random numbers??
12:26:36 <shachaf> Taejo: Pseudo-sure.
12:26:42 <Twey> Ah
12:26:43 <shachaf> s/-/-, /
12:26:44 <ion> let f = sequenceM 42 (rand (0,42)); rand = state . randomR in runState f =<< newStdGen
12:26:51 <tac-tics> Masxmasx and require the caller to provide the StdGen
12:27:05 <Masxmasx> tac-tics; they gave me a type description, and that one does not include another Int or IO Int
12:27:38 <kamaji> mm_freak: I'm not entirely convinced :D
12:27:44 <ion> err, s/sequenceM/replicateM/
12:28:10 <tac-tics> Masxmasx: ah. I see. Well, you can't get truly random numbers in a pure function. So either you have to take it as a parameter (StdGen), allow randomness to come from a sideeffect (IO), or it has to be pseudorandom (using a seed to create an StdGen
12:28:22 <kamaji> mm_freak: If I generate an infinite list of randoms, and keep taking n uniques out of it, why would that change probabilities?
12:28:32 <whald> technically, you don't need IO for creating an PRNG either, it just helps if you need a random seed
12:28:40 <Masxmasx> Okay thanks tac-tics
12:28:45 <ion> Err2, runstatef <$> newStdGen, not =<<
12:29:00 <kamaji> ion: what does it do?
12:29:01 <DevHC> does anyone have a preference to use "put" over "set" or "set" over "put", and why?
12:29:02 <Taejo> whald: indeed: mkStdGen :: Int -> StdGen
12:29:12 <tac-tics> Masxmasx: or... you can cheat an use an effect in pure code (unsafePerformIO)
12:29:13 <ion> It seems like typo day today.
12:29:16 <whald> during development i find it actually a good thing to have a constant seed, it helps to reproduce problems
12:29:28 <tac-tics> Masxmasx: But in every case, you must get randomness from somewhere else :)
12:29:39 <ion> > let go = sequenceM 42 (rand (0,42)); rand = state . randomR in evalState go (mkStdGen 0)
12:29:40 <lambdabot>   Not in scope: `sequenceM'
12:29:48 <Masxmasx> tac-tics: I am probably misunderstanding the question then, this seems more complicated than it should be :p
12:29:48 <ion> I’m too tired for this. :-D
12:29:54 <ion> > let go = replicateM 42 (rand (0,42)); rand = state . randomR in evalState go (mkStdGen 0)
12:29:55 <kamaji> let go = randomRs (0,42)
12:29:55 <Taejo> ion: replicateM?
12:29:56 <lambdabot>   [25,8,42,5,13,5,24,25,30,29,1,34,22,6,25,13,4,24,7,19,14,10,30,17,4,14,40,3...
12:30:11 <tac-tics> Masxmasx: Maybe post the full question on hpaste, and we can help you interpret it
12:30:15 <kamaji> oh forgot a generator
12:30:33 <kamaji> go $ mkStdGen 0
12:30:38 <kamaji> oh do I need a >
12:30:41 <kamaji> haha
12:30:42 <Masxmasx> tac-tics: I'll ask some classmates, but thanks :)
12:30:54 <tac-tics> np
12:31:10 <ion> > let go = (+) <$> rand (1,5) <*> rand (10,20); rand = state . randomR in evalState go (mkStdGen 0)
12:31:12 <lambdabot>   14
12:31:46 <ion> change evalState go (mkStdGen 0) to evalState go <$> newStdGen to start with a StdGen from IO but do the randomness computation in pure code after that.
12:34:05 <kmc> this randomness reminds me of a puzzle i thought of earlier
12:34:25 <copumpkin> dammit
12:34:30 <kmc> one can speak of choosing a random function of type (Integer -> Bool) uniformly
12:34:32 <copumpkin> why can't I find an elegant/efficient way to transpose these maps
12:34:44 <kmc> (they're bijection with infinite sequences of bits)
12:34:45 <shachaf> copumpkin: Which maps?
12:35:08 <copumpkin> transpose :: (Ord k, Ord k') => Map k (Map k' v) -> Map k' (Map k v)
12:35:31 <kmc> can you write a Haskell value of type «IO (Integer -> Bool)», which performs such a random sampling, without using unsafe operations?
12:36:17 <kmc> i'd think you'd want to make some kind of lazy trie
12:36:44 <kmc> i'm not sure if you need unsafeInterleaveIO for that
12:37:06 <Taejo> kmc: Integer -> Bool is computably isomorphic to [Bool]
12:37:29 <Taejo> does randoms :: IO [Bool] give the right distribution?
12:37:29 <kmc> i'd like the function to be reasonably efficient, too
12:37:30 <joevandyk> I have this code:
12:37:31 <joevandyk> << image ! [src (uploadDirCustom ++ "192x192!" ++ head images)]
12:37:32 <Taejo> I think so
12:38:09 <joevandyk> images is a list of strings.  instead of just using the first image in the list, i'd like to do that bit of code, one time for each image in the list
12:38:10 <Taejo> kmc: ah
12:38:13 <joevandyk> should i use a fold?
12:38:34 <ski> kmc : `newStdGen' and `split' ought to suffice, no ?
12:38:42 <Taejo> ski: I think so
12:39:56 <ion> I have no idea what the ! does in there, but since it takes an array, perhaps this works: image ! map (src . (uploadDirCustom ++ "192x192!" ++)) images
12:40:11 <ski> kmc : i suppose you could use a linear chain for the order of magnitude, and then do a binary tree for the remaining bits
12:40:11 <dolio> Using your pseudorandom generator with an infinite period?
12:40:33 <ion> image ! map (src . (uploadDirCustom ++) . ("192x192!" ++)) images
12:40:40 <kmc> ski, hmm, that's pretty good
12:40:56 <ski> (also handling negative numbers first, if you want that)
12:41:16 <kmc> but can't you build a trie with 'split'
12:41:30 <kmc> with a bool at each node (in case the Integer stops there)
12:41:46 <ski> kmc : i suppose a good question is what distribution you want ..
12:41:48 <dolio> Why not?
12:41:50 <kmc> uniform
12:42:00 <kmc> (within the limits of the PRNG, sure)
12:43:00 <rata_> kmc, quicksilver: what do you think about http://hpaste.org/52423? the same as before? (at least now it compiles and runs correctly)
12:43:06 <parcs> :t fst . random . mkStdGen . fromInteger :: Int -> Bool
12:43:07 <lambdabot>     Couldn't match expected type `Int' against inferred type `Integer'
12:43:08 <lambdabot>     In the second argument of `(.)', namely `fromInteger'
12:43:08 <lambdabot>     In the second argument of `(.)', namely `mkStdGen . fromInteger'
12:44:49 <kmc> that is, the distribution for f such that { f(k) | k ∈ Integer } are i.i.d. uniform Bools
12:48:45 <ski> kmc : it occurs to me i was confused about what you wanted, when i stated my suggestion (for some reason i was thinking atm you wanted to *generate* an `Integer') -- nonetheless, i think it might work :)
12:48:49 <ski> "i.i.d." ?
12:49:19 <rwbarton> independent and identically distributed
12:49:57 * hackagebot shqq 0.1 - Embed shell commands with interpolated Haskell variables, and capture output  http://hackage.haskell.org/package/shqq-0.1 (KeeganMcAllister)
12:50:20 * ski wonders whether this might be a good place to memoize in a tree
12:55:10 <ClaudiusMaximus> :t let transpose = M.fromListWith M.union . fmap (fmap (uncurry M.singleton) . fiddle) . concatMap splat . fmap (fmap M.toList) . M.toList where fiddle (a,(b,c)) = (b,(a,c)) ; splat (a,bs) = fmap ((,) a) bs in transpose -- i see what you mean about inelegant, copumpkin
12:55:11 <lambdabot> forall a k b. (Ord k, Ord a) => M.Map a (M.Map k b) -> M.Map k (M.Map a b)
12:55:28 <copumpkin> splat = strength!
12:55:40 <copumpkin> but yeah
12:55:46 <copumpkin> I had something close to that
12:55:50 <copumpkin> but it feels like there should be a nicer way
12:56:03 <robert[]> hello
12:56:10 <robert[]> anyone into de bruijn indices
12:59:00 <robert[]> multi index lifting
12:59:13 <joevandyk> what's wrong with this syntax?
12:59:14 <joevandyk> map something [1, 2, 3]
12:59:14 <joevandyk>   where something = id
12:59:36 <ion> Needs a ‘foo = …’
12:59:42 <ion> for ‘where’, that is.
12:59:42 <dolio> where is attached to definitions.
12:59:47 <dolio> Not expressions.
12:59:55 <joevandyk> ah, right
12:59:57 * hackagebot Stream 0.4.3 - A library for manipulating infinite lists.  http://hackage.haskell.org/package/Stream-0.4.3 (WouterSwierstra)
13:01:09 <joevandyk> what's the best way to write that code?  i want to name the anonymous function that's being used in map
13:01:18 <copumpkin> ClaudiusMaximus: how about the seemingly simpler :: (Ord k, Ord k') => Map k (Map k' v) -> Map k' [v]
13:01:26 <shachaf> joevandyk: let something = id in map something [1,2,3]
13:01:53 <shachaf> joevandyk: "where" can only be used in places where you bind names to things, e.g. "=" statements.
13:03:24 <joevandyk> shachaf: https://raw.github.com/gist/1276376/69571cd354b5aaa61d19dd545af05c36f3f54f43/gistfile1.txt -- is that a common thing to do?
13:03:26 <ClaudiusMaximus> :t M.unionsWith (++) . M.elems . M.map (M.map (:[]))
13:03:27 <lambdabot> forall k k1 a. (Ord k) => M.Map k1 (M.Map k a) -> M.Map k [a]
13:03:37 <joevandyk> shachaf: the first line is the original
13:04:50 <ClaudiusMaximus> @hoogle mapWithKey
13:04:50 <lambdabot> Data.IntMap mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
13:04:50 <lambdabot> Data.Map mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
13:06:02 <shachaf> joevandyk: Well, the second line looks like invalid syntax.
13:06:12 <shachaf> joevandyk: The general idea is pretty common, though.
13:06:13 <copumpkin> ClaudiusMaximus: oha
13:07:01 <ClaudiusMaximus> :t M.map M.fromList . M.unionsWith (++) . M.elems . M.mapWithKey (\k -> M.map (\v -> [(k,v)]))
13:07:02 <lambdabot> forall k k1 a. (Ord k1, Ord k) => M.Map k1 (M.Map k a) -> M.Map k (M.Map k1 a)
13:07:28 <copumpkin> @let strength = uncurry (fmap . (,))
13:07:28 <lambdabot>  <local>:5:0:
13:07:29 <lambdabot>      Multiple declarations of `L.strength'
13:07:29 <lambdabot>      Declared at: <l...
13:07:33 <copumpkin> :t strength
13:07:34 <joevandyk> shachaf: Prelude Main Text.XHtml> :t (<<)
13:07:34 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => a1 -> f a -> f (a1, a)
13:07:34 <joevandyk> (<<) :: HTML a => (Html -> b) -> a -> b
13:07:38 <copumpkin> @undef
13:07:40 <copumpkin> @let strength = uncurry (fmap . (,))
13:07:41 <lambdabot>  Defined.
13:07:58 <copumpkin> @undef
13:08:01 <copumpkin> @let strength = fmap . (,)
13:08:02 <lambdabot>  Defined.
13:08:14 <copumpkin> ClaudiusMaximus: that's quite nice
13:08:42 <copumpkin> :t fmap M.fromList . M.unionsWith (++) . M.elems . M.mapWithKey (\k -> fmap (\v -> [(k,v)]))
13:08:43 <lambdabot> forall k k1 a. (Ord k1, Ord k) => M.Map k1 (M.Map k a) -> M.Map k (M.Map k1 a)
13:09:01 <ClaudiusMaximus> copumpkin: shorter code, no idea about efficiency
13:10:33 <copumpkin> doesn't look much worse than I was expecting
13:17:30 <kamaji> is a monadic computation not "pure"?
13:17:36 <DukeDave> cabal kids: How to I link some object files, without re-compiling?
13:17:56 <DukeDave> I.e. Just like "c-sources", but without the recompile (I can tell you where the .o files are)
13:17:56 <DukeDave> http://www.haskell.org/cabal/users-guide/#build-information
13:19:09 <shachaf> kamaji: That depends on what you mean by "pure" and "computation".
13:19:22 <shachaf> kamaji: In general, no, it's pure.
13:20:44 <DukeDave> kamaji: How is your Haskell? It may be worth taking the time to digest: http://www.haskell.org/haskellwiki/Typeclassopedia
13:21:11 <erus`> if something returns an Either will it still be call by value?
13:21:39 <erus`> or is it just IO that is special?
13:21:49 <kamaji> DukeDave: not good :D
13:21:52 <kamaji> I struggle ^^
13:22:28 <shachaf> erus`: Huh?
13:22:38 <DukeDave> kamaji: I'd read the start of the Typeclassopedia (I'm going to start calling it T13a!)
13:22:41 <rferranti> DukeDave, nice thank you
13:22:41 <KirinDave> kamaji: Monadic computation can be pure or impure. It lets you sequence operations, but that doesn't inherently make it impure afaik.
13:22:45 <DukeDave> And see if it sounds like you
13:22:58 <DukeDave> kamaji: Np
13:22:59 <kmc> erus`, you seem confused, the ordering of IO actions has nothing to do with evaluation strategy
13:23:08 <erus`> an "IO int"  will be evaluated every time you use it?
13:23:10 <kmc> there are no special evaluation rules for IO
13:23:14 <kamaji> DukeDave: It does, thanks
13:23:20 <kmc> an IO Int is an inert description of how one might do IO to obtain an int
13:23:28 <kmc> you can evaluate that description whenever you like, no IO occurs
13:23:33 <erus`> ah ok
13:23:36 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:23:36 <kamaji> KirinDave: I think I will read this pdf before I continue blathering :)
13:23:48 <erus`> so an "Either blah bleh" will only be evaluated once?
13:23:53 <kamaji> wait, are KirinDave and DukeDave the same person or just named according to the same convention?
13:24:01 <KirinDave> kamaji: Different people
13:24:07 <benmachine> if you have x :: fmap read getLine, and x :: IO Int, then x >> x will evaluate x once, and execute it twice
13:24:08 <kamaji> ok :P
13:24:21 <KirinDave> Because I can't read Duke without thinking about the Dukes of Hazard and that' be a major impact to my productivity.
13:24:22 <ski> @type strength
13:24:23 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => a1 -> f a -> f (a1, a)
13:24:23 <ski> @type flip (flip . fmap (flip (,)))
13:24:24 <lambdabot> forall (f :: * -> *) a a1. (Functor f) => a -> f a1 -> f (a, a1)
13:24:38 <ski> copumpkin,ClaudiusMaximus ^
13:24:46 <DukeDave> Lmao
13:25:00 <copumpkin> lol
13:25:12 <ski> now write `flip' in turns of `strength'
13:25:24 <DukeDave> I'm afraid it's much worse, after having this handle for many years, someone in another IRC channel informed me of this:
13:25:25 <DukeDave> http://en.wikipedia.org/wiki/David_Duke
13:25:26 <ski> s/turns/terms/
13:25:58 <DukeDave> So I'd also like to dispel any fear that I am, or aspire to be, him :|
13:26:18 <ski> DukeDave : obviously he's aspiring to be you !
13:27:45 <ski> KirinDave : one of the main points of monadic computation is to avoid impure operations when doing effects
13:27:54 <ski> (KirinDave : e.g. `IO' is pure)
13:28:12 <kamaji> DukeDave: well, if you google "kamaji" I have a similar problem
13:28:37 * ski str that from "Spirited Away"
13:28:45 <kamaji> yeup
13:29:03 <kamaji> good film
13:29:23 <hpaste_> jaspervdj pasted “Type restrictions for the Haskell Websockets library” at http://hpaste.org/52424
13:29:28 <ski> erus` : "so an \"Either blah bleh\" will only be evaluated once?" -- huh ?
13:29:33 <DukeDave> kamaji: Heh, ages 7 to 15 your say ^_^
13:29:57 <kamaji> DukeDave: >>>>___>>>>>
13:30:16 <erus`> a = some computation that results in Either Int String
13:30:24 <erus`> a is only computed once?
13:31:20 <antihoax> lold
13:31:22 <antihoax> http://www.bbc.co.uk/news/technology-15200386
13:31:29 <antihoax> Real-life Jedi: Pushing the limits of mind control
13:31:29 <shachaf> erus`: Who knows? It's not defined by the standard.
13:31:46 <erus`> ghc developers will know
13:32:28 <antihoax> is the performance of ghc enough for it to be able to control a 3-5 axis cnc machine ?
13:32:50 <copumpkin> not sure, it might only be able to handle 2 axes
13:33:10 <erus`> i would use VB for a performance critical task
13:33:11 <antihoax> was thinking about realtime control
13:33:18 <tgeeky> copumpkin: you're thinking of a Viking. Haskell can handle several more axis.
13:33:25 <copumpkin> could be
13:33:30 <antihoax> step-dir controller
13:33:35 <ski> > (map fst . filter snd . (zipWith ((curry . graph . uncurry) (/=)) `ap` reverse)) ">>>>___>>>>>"
13:33:37 <lambdabot>   [('_','>'),('>','_')]
13:33:38 <tgeeky> copumpkin: those guys can duel weild like no other, though
13:33:45 <copumpkin> antihoax: yeah, just checked with mine. I could only get 2 axes out, and 2.5 if I compiled with -O2
13:33:56 <erus`> haha
13:33:57 <copumpkin> not fast enough to get more axes
13:34:14 <antihoax> seriously, im building a cnc machine
13:34:18 <erus`> in all seriousness though if it had to stop for .1 of a second todo GC it could be dangerous
13:34:33 <ski> erus` : assuming laziness, `a' is only computed once
13:35:29 <antihoax> i know realtime kernel allows less than 50us latency, to get more resolution i need rtai
13:35:47 <desaiu> if you create a list, called l, can you print the contents of l.3?
13:35:55 <desaiu> the fourth element in the list
13:36:02 <desaiu> In python, it's l.3
13:36:17 <shachaf> desaiu: No it's not?
13:36:35 <shachaf> desaiu: Anyway, yes, you can, with (l!!3), but list indexing is often a bad idea.
13:36:55 <desaiu> l[3] sorry
13:37:17 <kmc> lists are not a random-access data structure
13:37:22 <kmc> they are more like a control-flow structure
13:37:25 <desaiu> Thanks shachaf
13:37:27 <ski> erus` : but there may be different activisions(sp?) of `a' ..
13:38:03 <erus`> @google define:activisions
13:38:04 <lambdabot> http://www.activision.com/
13:38:05 <lambdabot> Title: Activision
13:38:14 <antihoax> erus`<< so ghc can make unwanted/random delays in functions?
13:38:32 <copumpkin> yes
13:38:37 <erus`> antihoax: yeah any GCd language can
13:38:41 <sm> jlouis: nice dart post
13:38:57 <antihoax> ok but i have realtime prrempt kernel
13:39:11 <copumpkin> antihoax: what kernel?
13:39:22 * ski wonders what it would take to automatically tuple together traversals of a list which occur in mostly lock-step
13:39:35 <antihoax> Linux 3.0.3-rt12 #14 SMP PREEMPT RT Sat Sep 24 03:40:24 CEST 2011 x86_64 GNU/Linux
13:40:00 <copumpkin> ah
13:40:06 <copumpkin> that won't change anything as far as haskell is concerned
13:40:39 <slack1256> generally is bad idea to use GC if you want realtime
13:40:44 <antihoax> so lets say i have a timer clock when the step signals must be output
13:40:58 <antihoax> all calculations must be done before that
13:41:13 <antihoax> i have 2.2GHz amd64
13:41:18 <rferranti> i fail to understand why Either is a functor and not a bifunctor
13:41:46 <ski> rferranti : `Either' is not a `Functor', `Either e' is (for any `e')
13:42:10 <ski> rferranti : but yes, `Either' ought to be a bifunctor
13:42:14 <antihoax> slack1256<< but it sounds so easy ;<
13:42:33 <antihoax> creating transfer functions for conversions
13:42:43 <Twey> Hmph
13:42:58 <Twey> What is the pivotal property that decides whether or not a given functor is also an applicative functor?
13:43:08 <slack1256> antihoax: what sound so easy? creating a realtime app?
13:43:18 <rferranti> ski, i'm missing something, thank you
13:43:22 <antihoax> no, the GHC transfer function part
13:43:30 <c_wraith> Twey: whether if makes sense to define <*>
13:43:33 <kmc> Twey, F (a -> b) -> F a -> F b
13:43:39 <acowley> and pure
13:43:40 <kmc> that might be a smartass non-answer, though
13:43:44 <c_wraith> err, Whether *it* makes sense
13:43:45 <Twey> Both are :þ
13:44:00 <Twey> You can ‘store’ a function inside any functor
13:44:02 <c_wraith> Oh, it's true.  Some things are functors but can't be applicative because they lack a pure
13:44:09 <ski> Twey : i bet `CoYoneda IORef' is not an applicative functor ..
13:44:13 <kmc> not many good examples of functors that aren't applicative functors
13:44:18 <acowley> The typeclass itself is the answer to the question
13:44:18 <kmc> this question came up on SO a while ago
13:44:21 <kmc> i don't remember the answers
13:44:26 <erus`> that feeling when your compiler is finished :D time to start on the parser then
13:44:28 <Twey> But you can also have a pure without Applicative
13:44:34 <Twey> kmc: Mm, 'kay
13:44:37 <c_wraith> ((,) a) is an example of a functor that isn't applicative because it lacks pure
13:44:43 <Twey> ski: Gesundheit :þ
13:44:47 <antihoax> actually it would be possible with a bash script, but at a very low control rate...
13:44:59 <kmc> *nod*
13:44:59 <Twey> c_wraith: Why does it lack pure?
13:45:03 <Twey> Oh, because the a isn't defined
13:45:06 <ski> Twey : prosit
13:45:06 <c_wraith> yeah
13:45:42 <ski> (btw, note that `CoYoneda IORef' *is* a `Functor')
13:45:47 <c_wraith> there's a reason the very-similar monad is actually (Monoid a => (,) a)
13:46:07 <c_wraith> Because that gives you enough context to define return
13:46:33 <Twey> ski: If I had any idea what ‘CoYoneda’ *is*, or could find out without reading through a mountain of prerequisite papers, I'd nod sagely here.
13:47:25 <ski> Twey : `newtype CoYoneda f b = forall a. FMapIncl (a -> b) (f a)'
13:47:55 <ski> actually, s/newtype/data/ (because of sillyness)
13:48:26 <ski> Twey : for *any* `f', `CoYoneda f' is a (covariant) functor
13:48:44 <Twey> Oh right
13:48:45 <acowley> I keep trying to go to a site "hayoogle" that I hope will search hayoo and hoogle
13:49:19 <ski> Twey : also, `data CoYonedaOp f b = forall a. CFMapIncl (b -> a) (f a)' makes `CoYonedaOp f' (e.g. `CoYonedaOp IORef') a contravariant functor
13:49:28 <slack1256> where did you guys study category theory or did your learn this on he fly?
13:49:29 <Twey> CoYoneda is a type plus transformation?
13:49:45 <Twey> slack1256: I'm all on the fly… but I'm not so good :þ
13:50:03 <ski> `CoYoneda IORef' is a "read-only view" of an `IORef', and `CoYonedaOp IORef' is a "write-only view" of an `IORef'
13:51:48 <antihoax> someone have loop benchmark programs in haskell?
13:54:18 <ion> antihoax: criterion
13:54:39 <ski> there's also a dual construction : `newtype Yoneda f a = FlipPamfJorp {projFlipFMap :: forall b. (a -> b) -> f b}'
13:54:59 <ski> where `Yoneda f' is also a (covariant) functor, regarless of `f'
13:54:59 * hackagebot ircbot 0.1.0 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.1.0 (JeremyShaw)
13:55:12 <ski> we can easily define
13:55:23 <ski>   incl :: f a -> CoYoneda f a
13:55:23 <ski> and
13:55:26 <Twey> ‘FlipPamfJorp’?  Really?
13:55:34 <ski>   proj :: Yoneda f a -> f a
13:55:41 <Twey> Ah
13:55:43 <Twey> ProjFmap
13:55:44 <Twey> Haha.
13:55:58 <ski> Twey : i'm sure edwardk called that constructor something more boring ..
13:56:26 <hpaste_> desaiu pasted “Resistors in a Parallel Circuit” at http://hpaste.org/52426
13:56:28 <antihoax> ion<< thx will see
13:56:48 <desaiu> That's the problem I'm working on right now.
13:56:56 <desaiu> I'm determined to get this today.
13:57:55 <ski> the idea behind the naming being that `projFlipFMap yfa ab = proj (flip fmap ab yfa)' and `FMapIncl ab fa = fmap ab (incl ab)'
13:58:37 <ski> er, `projFlipFMap yfa ab = proj (flip fmap yfaa ab)', i.e. `projFlipFMap = proj .: flip fmap'
13:59:22 <ski> and then since `FlipPamfJorp' is the inverse of that, it's (in a sense) some kind of composition of the inverse of `flip fmap' and the inverse of `proj'
13:59:37 * ski waves hands vigorously
13:59:59 * hackagebot ircbot 0.1.1 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.1.1 (JeremyShaw)
14:01:45 <ski> Twey : btw, you may note that `incl :: NatTransf f (CoYoneda f)' where `type NatTransf f g = forall a. f a -> g a', suggesting that `incl' is some kind of higher-level `return' operation for `CoYoneda', so one can ask whether one can code the corresponding `join' operation, i.e. `NatTransf (CoYoneda (CoYoneda f)) (CoYoneda f)'
14:02:00 <ski> which is `forall a. CoYoneda (CoYoneda f) a -> CoYoneda f a', then
14:02:30 <Twey> Haha
14:02:32 <Twey> *nod*
14:02:34 <ski> similarly, `proj :: NatTransf (Yoneda f) f' is some kind of higher-level `extract' (i.e. comonadic) analogue
14:02:49 <ski> and iirc, one can in fact define these operations
14:03:31 <ski> as well as a variant of bind with type `(forall x. f x -> CoYoneda g x) -> CoYoneda f a -> CoYoneda f g'
14:04:11 <ski> and for `preserve' we get `(forall x. Yoneda f x -> g x) -> Yoneda f a -> Yoneda g a'
14:04:21 <ski> s/bind/`extend'/
14:05:27 <ski> hm, you should also compare `Yoneda' with `CoDensity'
14:06:31 <ski>   newtype CoDensity f a = DnibJorp {projBind :: forall b. (a -> f b) -> f b}
14:06:35 <ski> with dual
14:08:00 <ski>   data Density f b = forall a. PreserveIncl (f a -> b) (f a)
14:08:22 <ski> `CoDensity f' is a monad, for any `f'
14:08:28 <ski> `Density f' is a comonad, for any `f'
14:09:26 <ski> `CoDensity m' improves any monad `m', using CPS, to get one which "right-associates" every `(>>=)' operation, automatically removing some inefficiencies
14:10:04 <KirinDave> ski: Why is the monad called codensity and the comonad called density?
14:10:15 <ski> KirinDave : hysterical raisins
14:10:38 <ski> apparently, the `Density f' case was already known in topology, and called "density" there
14:10:46 <ski> ask edwardk about details
14:11:07 * ski doesn't know the background
14:11:48 <ski>   fmap :: (a -> b) -> (f a -> f b)
14:12:00 <ski>   FMapIncl :: (a -> b) -> (f a -> CoYoneda f b)
14:12:17 <ski>   CFMapIncl :: (b -> a) -> (f a -> CoYonedaOp f b)
14:12:51 <ski>   flip projFlipFMap :: (a -> b) -> (Yoneda f a -> f b)
14:13:05 <ski>   projFlipFMap :: Yoneda f a -> (forall b. (a -> b) -> f b)
14:13:18 <ski>   FlipPamfJorp :: (forall b. (a -> b) -> f b) -> Yoneda f a
14:13:21 <kmc> I want a good intro example of using parser combinators which fits comfortably on one slide
14:13:41 <kmc> I have a Parsec parser for S-expressions
14:13:57 <ion> desaiu: You could start by getting a list of all the possible combinations of the resistors: replicateM 3 [820,1000,2200,3300,4700,5600]
14:14:03 <ski>   (=<<) :: (a -> m b) -> (m a -> m b)
14:14:37 <ski>   flip projBind :: (a -> m b) -> (CoDensity m a -> m b)
14:14:53 <ski>   projBind :: CoDensity m a -> (forall b. (a -> m b) -> m b)
14:14:57 <ion> desaiu: Since it looks like if you pick a 820, you don’t have another, you could make sure each combination lists a single resistor just once. This also makes the case of “one to three resistors” work. map (nub . sort) . replicateM 3 $ [820,1000,2200,3300,4700,5600]
14:15:09 <kmc> but it's the classic trap where functional languages are clearly best because they're best for implementing other functional languages
14:15:14 <ski>   (>>=) :: m a -> (forall a. (a -> m b) -> m b)
14:15:27 <ski>   DnibJorp :: (forall b. (a -> m b) -> m b) -> CoDensity m a
14:15:31 <ion> > {- desaiu: You could then remove the duplicate entries: -} nub . map (nub . sort) . replicateM 3 $ [820,1000,2200,3300,4700,5600]
14:15:33 <lambdabot>   [[820],[820,1000],[820,2200],[820,3300],[820,4700],[820,5600],[820,1000,220...
14:15:41 <ion> desaiu: Are you with me so far?
14:15:48 <ski>   preserve :: (w a -> b) -> (w a -> w b)
14:15:55 <kmc> so i'm looking for a example that's more applied? less navel-gazing?
14:16:07 <desaiu> I'm here, sorry, I've been talking to myself in the literate haskell file while you've been hilighting my nick
14:16:14 <ski>   PreserveIncl :: (w a -> b) -> (w a -> Density w b)
14:16:25 <Saizan> kmc: do json?:P
14:17:13 <ski> ^ those hopefully give a better intuition for why the types `CoYoneda',`CoYonedaOp',`Yoneda',`CoDensity',`Density' are what they are
14:17:44 <kmc> i think JSON is a bit too complicated for one slide
14:17:50 <kmc> even if I take a reasonable subset
14:18:57 <hpc> JSON is pretty simple, i thought
14:19:05 <hpc> just a deeply nested hash in javascript syntax
14:19:49 <kmc> well my S-expr parser is 4 lines, 40 columns
14:19:58 <kmc> without any terrible contortions
14:20:08 <kmc> i'd rather not make it much bigger than that
14:20:31 <kmc> you may all commence golfing a JSON parser
14:20:41 <desaiu> I don't know what nub is
14:20:48 <desaiu> ion
14:20:50 <kmc> (it's not real S-expressions, either, just lists and alphanumeric atoms)
14:21:03 <dolio> Functional languages are great because they can parse dead-fucking-simple languages.
14:21:16 <theDUBBER> www.thedubber.altervista.org
14:21:19 <monochrom> this subset of xml may be just a bit longer than s-expressions: no namespace, no attributes, no empty elements (<br/>)
14:21:25 <desaiu> ion: I also don't know what replicateM 3 [<list>] does
14:21:31 <ski> @let select :: MonadPlus m => [a] -> m (a,[a]); select [    ] = mzero; select (a:as) = return (a,as) `mplus` liftM (fmap (a :)) (select as)
14:21:32 <lambdabot>  Defined.
14:21:40 <ski> desaiu : i might try to use that ^
14:21:57 <kmc> monochrom, yeah, I'm trying to write a tiny parser for that now
14:21:59 <ion> desaiu: It’s an inefficient – but good enough for this thing – function to remove duplicate elements from a list: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:nub
14:22:15 <ski> > select "abc" `asTypeOf` []
14:22:17 <lambdabot>   [('a',"bc"),('b',"ac"),('c',"ab")]
14:22:46 <ion> > replicateM 3 [0,42]  -- desaiu
14:22:47 <lambdabot>   [[0,0,0],[0,0,42],[0,42,0],[0,42,42],[42,0,0],[42,0,42],[42,42,0],[42,42,42]]
14:22:51 <ion> > replicateM 2 [0,1,2]
14:22:52 <lambdabot>   [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]
14:24:45 <ion> ski: That would require us to explain MonadPlus, too. I figured i might start with trivial standard library functions. :-)
14:25:57 <ski> @let pick :: StateT [a] [] a; pick = StateT select
14:25:58 <ion> desaiu: With lists, replicateM generates all the possible lists of n elements consisting of elements of the input list.
14:25:58 <lambdabot>  Defined.
14:26:04 <ski> @let evalAffine :: StateT [t] [] a -> ([t] -> [a]); evalAffine = evalStateT
14:26:05 <lambdabot>  Defined.
14:26:12 <ski> @let evalLinear :: StateT [t] [] a -> ([t] -> [a]); evalLinear ma ts = do (a,[]) <- ma `runStateT` ts; return a
14:26:13 <lambdabot>  Defined.
14:26:14 <mm_freak> kamaji: i'm not sure…  i just wouldn't do it
14:26:17 <kmc> monochrom, that XML subset isn't (easily) applicative, is it?
14:26:33 <kmc> you have to read an opening tag before you know what parser to use for the closing tag
14:26:41 <mm_freak> kamaji: though it might be fine, if your application is not a crypto application
14:26:41 <ion> ski: Great, now we’ll need to explain monad transformers and the state monad as well, :-)
14:27:41 <ski> @let listToMP :: MonadPlus m => [a] -> m a; listToMP = msum . map return
14:27:42 <lambdabot>  Defined.
14:27:43 <dolio> Is XML not context free?
14:28:08 <dolio> That is, not even such a simplified version?
14:28:42 <kmc> it may be context free and yet not have a small, nice-to-look-at context free grammar
14:28:58 <ski> > evalAffine (do b <- listToMP [True,False]; if b then liftM2 (\a b -> [a,b]) pick pick else liftM3 (\a b c -> [a,b,c]) pick pick pick)
14:28:58 <desaiu> I'm going ignore monads for now. I'm too new to this
14:28:59 <lambdabot>   Overlapping instances for GHC.Show.Show ([a3] -> [[a3]])
14:28:59 <lambdabot>    arising from a ...
14:29:03 <kmc> matching closing tags is dumb anyway, maybe I won't bother
14:29:21 <desaiu> I unfortunately won't be getting there for a couple of months with my schedule
14:29:31 <ski> > (do b <- listToMP [True,False]; if b then liftM2 (\a b -> [a,b]) pick pick else liftM3 (\a b c -> [a,b,c]) pick pick pick) `evalAffine` "abcdefgh"
14:29:33 <lambdabot>   ["ab","ac","ad","ae","af","ag","ah","ba","bc","bd","be","bf","bg","bh","ca"...
14:29:36 <ski> > (do b <- listToMP [True,False]; if b then liftM2 (\a b -> [a,b]) pick pick else liftM3 (\a b c -> [a,b,c]) pick pick pick) `evalAffine` "abcd"
14:29:38 <lambdabot>   ["ab","ac","ad","ba","bc","bd","ca","cb","cd","da","db","dc","abc","abd","a...
14:29:44 <ion> desaiu: Yes, i’m not going to confuse you with monads.
14:30:00 * hackagebot nbt 0.2 - A parser/serializer for Minecraft's Named Binary Tag (NBT) data format.  http://hackage.haskell.org/package/nbt-0.2 (AdamFoltzer)
14:30:06 <ion> desaiu: Do you have further questions about what i explained so far?
14:30:19 <antihoax> can someone recommend a solution to run ghc? and possibly cabal if i used prefix= during install?
14:30:24 <ski> > (do (a,b) <- liftM2 (,) pick pick; b <- listToMP [True,False]; if b then return [a,b] else do c <- pick; return [a,b,c]) `evalAffine` "abcd"
14:30:25 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:30:26 <lambdabot>         against inferred type ...
14:30:29 <desaiu> I'm deciphering everything that just went on
14:30:34 <desaiu> I'll ask when I get to that point :)
14:30:38 <hpc> dolio: the way DTDs are laid out makes it look like XML is context-free
14:30:46 <ski> > (do (a,b) <- liftM2 (,) pick pick; bb <- listToMP [True,False]; if bb then return [a,b] else do c <- pick; return [a,b,c]) `evalAffine` "abcd"
14:30:48 <lambdabot>   ["ab","abc","abd","ac","acb","acd","ad","adb","adc","ba","bac","bad","bc","...
14:30:52 <JoeyA> antihoax: What OS?
14:30:56 <ski> > (do (a,b) <- liftM2 (,) pick pick; bb <- listToMP [True,False]; if bb then return [a,b] else do c <- pick; return [a,b,c]) `evalLinear` "ab"
14:30:57 <antihoax> bindmount? chroot? or setting path ?
14:30:58 <lambdabot>   ["ab","ba"]
14:30:59 <ski> > (do (a,b) <- liftM2 (,) pick pick; bb <- listToMP [True,False]; if bb then return [a,b] else do c <- pick; return [a,b,c]) `evalLinear` "abc"
14:31:01 <lambdabot>   ["abc","acb","bac","bca","cab","cba"]
14:31:04 <antihoax> Linux
14:31:05 <FUZxxl> Is it possible for a compiler to turn code like f x | p x = a | otherwise = x ?? f (x-1) into something tail-recursive?
14:31:16 <dolio> kmc: Well, it strikes me that s = <(.*)> s <\1> isn't context free unless you have a pre-known set of tag names.
14:31:23 <dolio> Or, is likely to not be.
14:31:42 <hpc> dolio: you do, in the DTD
14:31:43 <dolio> Finite set, even.
14:31:47 <ion> desaiu: Let me simplify the list a bit:
14:31:53 <dolio> Right, but then you have to parse the DTD.
14:31:57 <ion> > replicateM 3 $ [0,1,2]  -- all combinations
14:31:58 <lambdabot>   [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,1,2],[0,2,0],[0,2,1],[0,2,2],[1...
14:32:03 <ski> > replicateM 2 pick `evalAffine` "abcd"
14:32:04 <lambdabot>   ["ab","ac","ad","ba","bc","bd","ca","cb","cd","da","db","dc"]
14:32:07 <ski> > replicateM 2 pick `evalAffine` "abc"
14:32:09 <lambdabot>   ["ab","ac","ba","bc","ca","cb"]
14:32:16 <ski> > replicateM 3 pick `evalAffine` "abcd"
14:32:17 <JoeyA> antihoax: export PATH="$HOME/.cabal/bin:/usr/local/ghc7/bin:$PATH"
14:32:17 <dolio> And the DTD+XML isn't context free.
14:32:18 <lambdabot>   ["abc","abd","acb","acd","adb","adc","bac","bad","bca","bcd","bda","bdc","c...
14:32:19 <ski> desaiu ^
14:32:24 <ion> > map (nub . sort) . replicateM 3 $ [0,1,2]  -- for each sublist, sort and remove duplicates
14:32:26 <lambdabot>   [[0],[0,1],[0,2],[0,1],[0,1],[0,1,2],[0,2],[0,1,2],[0,2],[0,1],[0,1],[0,1,2...
14:32:31 <hpc> yeah
14:32:33 <ion> > nub . map (nub . sort) . replicateM 3 $ [0,1,2]  -- remove all duplicate sublists
14:32:34 <lambdabot>   [[0],[0,1],[0,2],[0,1,2],[1],[1,2],[2]]
14:32:36 <JoeyA> (replace /usr/local/ghc7 with the prefix you specified)
14:32:46 <ion> desaiu: See above.
14:32:56 <hpc> i was assuming parsing the DTD would yield a CFG for XML and that counted as "yes"
14:32:57 <ski> ion : great ! :D
14:32:58 <dolio> I guess the DTD is the context you need, more or less.
14:33:00 <hpc> the whole split file thing
14:33:14 <hpaste_> Husel pasted “Brackets” at http://hpaste.org/52428
14:33:26 <Husel> Why do I get an error at the first 'do'?
14:33:36 <Husel> it will be a really basic error :P
14:33:39 <JoeyA> antihoax: The .cabal/bin thing is needed if you install packages locally, which is the default.
14:34:01 <ski> desaiu : `replicateM 3 act' is equal to `do a <- act; b <- act; c <- act; return [a,b,c]'
14:34:02 <Husel> oops my formatting has become a bit weird there..
14:34:03 <antihoax> i have another problem then
14:34:04 <hpc> Husel: first, you need a "then"
14:34:10 <antihoax> i have installed cabal as root
14:34:15 <antihoax> ;/
14:34:23 <antihoax> and if i change the config file then it fails
14:34:49 <antihoax> so probably have to reinstall that as user
14:34:52 <hpc> are you using tabs for indentation?
14:35:00 <hpc> er, Husel ^
14:35:01 <Husel> hpc: now I have a parse error on input 'then'
14:35:11 <antihoax> hpc that cabal config file is a brainfuck
14:35:13 <Husel> no, spaces
14:35:24 <Husel> oh wait, it seems to be a mix :(
14:35:45 * ski gets visions of using `unsafeInterleaveIO' to set up a partial ordering for effects to happen in
14:35:53 <hpc> ghc tabs are 8 spaces wide, and i think they are fixed-width too
14:36:02 <hpc> which makes them 100% incompatable with just about any editor
14:36:03 <kmc> the other thing about the s-expr parser is that it does not need 'try' :)
14:36:05 <antihoax> but took a few minutes to sed out the variables and i pasted it here
14:36:25 <hpaste_> “Joey Adams” pasted “Crummy Haskell Platform installer script” at http://hpaste.org/52429
14:36:38 <antihoax> sed -nr 's;[ -]*'"$what"':[ ]*([^ ][^ ]*).*;\1;p' ./config
14:36:40 <JoeyA> antihoax: If it helps ^
14:36:44 <antihoax> sed -nr 's;^[ ]*([a-z,A-Z,0-9][a-z,A-Z,0-9,\-]*[ ]*):[ ]*([^ ][^ ]*).*;--\1="\2";p' ./config
14:36:49 <JoeyA> (you'd have to customize it by hand, and it's far from perfect)
14:36:50 <Husel> i'll try changing it
14:36:52 <kmc> maybe I should just change the parentheses to curly braces and then pretend it's a markup language
14:37:15 <syntaxfree> is there any project that takes a simple, incomplete c-like language and parses it via Parsec into compileable C++? Something with FP-type features?
14:37:23 <hpc> kmc: lol
14:38:01 <hpaste_> Luke pasted “Lazy ByteString” at http://hpaste.org/52430
14:38:53 <syntaxfree> I'm programming an Arduino. There's a cute IDE that transparently includes some libraries, but after that it's as much C++ as it fits inside the µC computronic chamber.
14:39:05 <ion> desaiu: Still there?
14:39:15 <JoeyA> I wish there was a compiler for a Haskell-like language that could generate code that plays well with C.
14:39:16 <kmc> "cute"
14:39:24 <syntaxfree> it's really cute.
14:39:31 <syntaxfree> like Processing.
14:39:33 <Luke> http://hpaste.org/52430 anyone know why I am getting type mismatches  "with actual type `Data.ByteString.Internal.ByteString'" with the given imports?
14:39:45 <kmc> maybe if you're trying to run it on HipsterOS
14:39:46 <syntaxfree> actually, reused the UI code from Processing mostly. But Processing is Java.
14:39:53 <JoeyA> e.g. ADTs should map to C structs in a predictable fashion.
14:40:13 <syntaxfree> JoeyA: that's what I'm trying to say, albeit less ambitious.
14:40:14 <JoeyA> And the language shouldn't assume garbage collection.
14:40:21 <kmc> it doesn't work well on my system (Linux, XMonad)
14:40:24 <syntaxfree> JoeyA: sure.
14:40:30 <acowley> The lack of documentation on hackage can be pretty demoralizing
14:40:44 <desaiu> I'm here, had to make a comment on r/Haskell
14:41:26 <syntaxfree> kmc: oh well, if you know which libraries to include you can download AVRstudio, which includes avrdude.
14:41:30 <ski> ion : using `nub' will not work if more than one resistor has the same resistance ..
14:41:32 <acowley> Luke: lazy vs strict probably
14:41:33 <ski> FUZxxl : it would presumably have to know that `(??)' is associative
14:41:34 <syntaxfree> which is what you really need.
14:41:40 <JoeyA> For example, the compiler could consider it an error if the code cannot be optimized to obviate GC.
14:41:43 <Luke> acowley: very likely - i'm trying to convert the code from strict to lazy
14:41:48 <kmc> yeah, I use avrdude along with some small build scripts I wrote
14:41:51 <Luke> acowley: as far as I can tell I converted everythign though
14:41:51 <kmc> I don't use the Arduino libraries
14:41:58 <JoeyA> Though that might make it hard to use...
14:42:03 <syntaxfree> JoeyA: ok, you're creepily five seconds ahead of my thinking.
14:42:06 <Luke> acowley: I'm not quite sure how to import things correctly to use lazy ByteStrings
14:42:07 <ion> ski: True, but i’ll start with the simplest case.
14:42:07 <JoeyA> lol
14:42:11 <Luke> just kinda need someone to take a look
14:42:36 <acowley> Luke: you'll need to paste the problematic code if anyone is going to debug it
14:42:44 <JoeyA> Haskell's ideally supposed to be this high-level declarative language that lets you explain "what" your program does rather than "how" it does it.
14:42:46 <desaiu> http://sprunge.us/aEKg
14:42:56 <syntaxfree> ADTs map to C structs in a straightforward fashion until you have recursive data types.
14:42:59 <desaiu> You have to admit, this problem just became tediously long :)
14:43:03 <desaiu> But I'm working through it!
14:43:11 <Husel> kmc: should it just be   do d x; then putStr "\n";     ?
14:43:19 <hpaste_> Luke annotated “Lazy ByteString” with “Lazy ByteString (annotation)” at http://hpaste.org/52430#a52431
14:43:25 <desaiu> ski: I ignored your monad stuff
14:43:26 <Luke> acowley: ^
14:43:29 <JoeyA> @tell syntaxfree What's wrong with pointers and forward-declared structs?
14:43:29 <lambdabot> Consider it noted.
14:43:40 <ski> (FUZxxl : of course, you can always make it tail-recursive by using a CPS-transformation, but that doesn't buy you very much, effectively it keeps the stack heap-allocated)
14:43:43 <acowley> I think the Arduino environment is a good example of a simple solution being most of what people want
14:43:53 <kmc> Husel, what are you talking about?
14:44:20 <Husel> kmc: oops, sorry, I meant hpc, your names are similar :)
14:44:26 <kmc> haha, that's okay
14:44:32 <ski> desaiu : you agree that  replicateM 2 pick `evalAffine` "abcd"  looks cool, though ?
14:44:34 <Husel> hpc: should it just be   do d x; then putStr "\n";     ?
14:44:53 <desaiu> ski: definitely! :P
14:45:24 <ski> desaiu : what `select' does is selecting out an element, also getting the rest of the list, doing this in every possible way
14:45:42 <ski> desaiu : so using `select' multiple times, we can ensure that we don't pick the same element in the list more than once
14:46:40 <Luke> anyone else able to help me get this code compiling? http://hpaste.org/52430
14:46:42 <ski> desaiu : you can code basically the same as above using just `select', instead of the `pick',`evalAffine' monad things -- though it won't look as pretty :)
14:46:55 <acowley> Luke: your snippet is missing a lot of imports and things
14:47:18 <Luke> acowley: like what?
14:47:26 <acowley> kmc: do you have a good setup for Arduino programming using something like Atom?
14:47:36 <ski> desaiu : btw, if you want to, you can simplify `select' to have type `[a] -> [] (a,[a])' (which is the same as `[a] -> [(a,[a])]') -- i just didn't want to needlessly restrict the operation above
14:47:42 <acowley> Luke: Control.Applicative, qualified Data.Map as M, and a definition of Params
14:47:46 <Luke> acowley: oh you're right - messed up the copy/paste =)
14:47:53 <desaiu> Prelude> replicateM 3 rAvailable
14:47:54 <desaiu> <interactive>:1:0: Not in scope: `replicateM'
14:48:01 <syntaxfree> acowley: the Atom is an Arduino-type kit?
14:48:01 <lambdabot> syntaxfree: You have 1 new message. '/msg lambdabot @messages' to read it.
14:48:09 <ski> @index replicateM
14:48:09 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:48:10 <syntaxfree> #arduino is useful if you ignore dongs.
14:48:19 <ski> desaiu : ^ `import Control.Monad'
14:48:24 <acowley> Atom can be used to generate code for an Arduino
14:48:41 <acowley> which is fantastically neat, but I don't use it
14:48:44 <Luke> acowley: check out the latest annotation
14:48:49 <syntaxfree> hmm.
14:48:53 <syntaxfree> @google atom arduino
14:48:54 <lambdabot> http://blog.sw17ch.com/wordpress/?p=84
14:48:55 <lambdabot> Title: Learning After School » Atom & Arduino :: Some Hacking (pt. 1)
14:49:03 <acowley> I got it working on enight, but it was a much clumsier dev. environment than the Arduino IDE
14:49:40 <desaiu> Is there such a thing as @index in ghci?
14:49:42 <syntaxfree> oh cool, people are already doing haskellduino things.
14:49:54 <acowley> Luke: now I'm just missing an import to bring fromEither into scope
14:50:26 <Luke> acowley: try one more time =)
14:51:08 <ski> desaiu : the `info' command, usually abbreviated as `i'
14:51:15 <ski> :i replicateM
14:51:27 <acowley> Luke: so the goal is for parse to work with lazy bytestrings?
14:52:01 <desaiu> Thanks ski!
14:52:47 <Luke> acowley: yeah
14:53:40 <ski> desaiu : but you need to already have a module which exports that in scope, for it to work .. shachaf's ".ghci" at <http://hpaste.org/52414> might help with that
14:53:56 <syntaxfree> whatever happened to darcs? hackage uses gits?
14:53:59 <acowley> ah
14:54:13 <acowley> Luke: Data.Attoparsec.Lazy is only a small shim over strict attoparsec
14:54:37 <acowley> so importing parseOnly from the .Lazy variant isn't doing anything useful wrt making things lazier
14:55:21 <acowley> Luke: it looks like the thing to do is define your parsers in terms of strict bytestrings, then use Data.Attoparsec.Lazy.parse to drive the whole thing
14:55:32 <jlouis> sm: thank you
14:55:42 <Luke> acowley: that's exactly what i'm trying to do
14:56:04 <acowley> Luke: but you're not using attoparsec's parse
14:56:15 <Luke> acowley: import Data.Attoparsec.Lazy (Parser, parseOnly)
14:56:20 <jlouis> sm: I just took the spec
14:56:39 <acowley> Luke: right, but both those identifiers are bound to definitions from Data.Attoparsec
14:56:46 <acowley> Attoparsec.Lazy just re-exports them
14:56:54 <jlouis> sm: and then wrote the post as I read it
14:57:05 <Luke> acowley: ... what's the point of the lazy module if it isn't lazy?
14:57:09 <jlouis> and finally, I just added some thoughts of my own
14:57:15 <Luke> acowley: how do I get at the lazy implementation of parse?
14:57:22 <acowley> Luke: supposedly it does something smart when given lazy bytestring input
14:57:38 <acowley> but your component parsers should still be on strict bytestrings
14:57:46 <acowley> the idea being that you lazilly chain together a bunch of strict parsers
14:57:46 <Luke> acowley: I don't follow
14:57:58 <acowley> a lazy bytestring is just a list of strict bytestrings
14:58:08 <desaiu> In map (nub . sort) . replicateM 3 $ [820,1000,2200,3300,4700,5600], why is (nub . sort) in parens?
14:58:14 <acowley> so you consume the lazy bytestring by eating pieces that are strict
14:58:20 <desaiu> Why is it not map nub . sort . replicateM 3...
14:58:36 <hpc> desaiu: to be annoying, probably
14:58:44 <hpc> (.) is associative, so there's really no point
14:58:44 <Luke> acowley: so what's the point of the lazy module in attoparsec?
14:58:58 <Luke> acowley: and how do I get at the lazy bytestring then if i'm not doing it now?
14:59:13 <Luke> acowley: I would expect Data.ByteString.Lazy (ByteString) would be a lazy bytestring
14:59:55 <desaiu> @index sort
14:59:55 <lambdabot> Data.List
15:00:10 <desaiu> > type sort
15:00:11 <lambdabot>   <no location info>: parse error on input `type'
15:00:19 <hpc> :t sort
15:00:20 <lambdabot> forall a. (Ord a) => [a] -> [a]
15:00:21 <hpaste_> acowley annotated “Lazy ByteString” with “Lazy ByteString (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/52430#a52436
15:00:34 <desaiu> :t Ord
15:00:35 <lambdabot> Not in scope: data constructor `Ord'
15:00:43 <hpc> @src Ord
15:00:43 <lambdabot> class  (Eq a) => Ord a  where
15:00:43 <lambdabot>     compare      :: a -> a -> Ordering
15:00:44 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
15:00:44 <lambdabot>     max, min         :: a -> a -> a
15:00:47 <hpaste_> Husel pasted “Brackets” at http://hpaste.org/52437
15:01:02 <Husel> Why am I getting the error there?
15:01:06 <desaiu> Aw man, haven't gotten to classes yet
15:01:09 <ski> dolio : hm, you didn't answer whether the papers "Categorical Models of Parametric Polymorphism" resp. "Types, Abstraction and Parametric Polymorphism, Part 2" you mentioned were the ones authored by Lars Birkedal resp. QingMing Ma,John C. Reynolds :(
15:01:13 <hpc> values have types and sometimes class constraints, types and classes have kinds
15:01:21 <mauke> Husel: because you have random ";" in your code
15:01:28 <hpc> :k Ord
15:01:29 <lambdabot>     Class `Ord' used as a type
15:01:30 <lambdabot>     In the type `Ord'
15:01:37 <hpc> oh, classes don't have kinds
15:01:38 <Husel> mauke: without it, the parsing doesn't get that far for some reason
15:01:46 <mauke> Husel: ok, and?
15:01:56 <Husel> mauke: i'm not sure why
15:02:03 <mauke> Husel: also, // doesn't start a comment
15:02:14 <ski> desaiu,hpc : `map (nub . sort)' is not the same as `map nub . sort'
15:02:18 <Husel> okay
15:02:25 <desaiu> Husel: -- starts a comment
15:02:27 <acowley> Luke: one thing I should point out about what you're trying to do is that lazilly building a Map might not work as lazilly as you'd like
15:02:32 <hpc> ski: oh, missed the "map" there
15:02:33 <desaiu> a one liner
15:02:39 * syntaxfree has such a hard-on for paper titles in FP.
15:02:46 <desaiu> {- use this for
15:02:46 <c_wraith> today's discovery: killThread can block!
15:02:53 <desaiu> multi-line comments -}
15:02:53 <acowley> syntaxfree: you should see a doctor
15:02:56 <Luke> acowley: what about keeping it as an AList?
15:03:02 <hpc> Husel: what are you learning haskell from?
15:03:06 <Husel> desaiu: thanks :)
15:03:09 <hpc> learnyouahaskell?
15:03:14 <syntaxfree> acowley: particularly because I'm a girl?
15:03:16 <ski> desaiu : `map (nub . sort)' will sort, then nub, each element list in the list of lists, while `map nub . sort' will first sort the list of lists (but not the individual lists), and then nub the result (which will probably contain more elements than with the former thing)
15:03:16 <acowley> Luke: that could work if you think you will be consuming parameters in the order they are specified
15:03:20 <syntaxfree> And a girl parrot at that?
15:03:26 <acowley> syntaxfree: at least consult a CS PhD
15:03:33 <Luke> acowley: I don't
15:03:44 <Husel> hpc: i've read some of Learn You A Haskell and Real World Haskell in the past, but at the moment I was just trying to have a quick go at doing something
15:03:51 <syntaxfree> academic types usually don't talk to parrots. There's a Hatebeak song about that.
15:03:57 <rwbarton> :k Ord Integer
15:03:57 <ski> > map (nub . sort) [[1,2,2],[0,3],[2,1,2]]
15:03:58 <lambdabot>     Class `Ord' used as a type
15:03:58 <lambdabot>     In the type `Ord Integer'
15:03:58 <acowley> Luke: then why are you trying to be lazier?
15:03:59 <lambdabot>   [[1,2],[0,3],[1,2]]
15:04:03 <rwbarton> hmm
15:04:08 <ski> > (map nub . sort) [[1,2,2],[0,3],[2,1,2]]
15:04:10 <lambdabot>   [[0,3],[1,2],[2,1]]
15:04:11 <shirt> any cabal devs or experts here?
15:04:24 <rwbarton> will that work in the future of constraint kinds?
15:04:30 <Luke> acowley: I don't want to read the whole file into mem at once
15:04:58 <Husel> Without the semi-colons, ghci says that putStr is being applied to 7 arguments...
15:05:18 <acowley> Luke: if you need random access to the data (e.g. the last parameter specified), and you don't want the data in memory, you need to get more intimiate with the file system
15:05:37 <mauke> Husel: because it is
15:05:47 <acowley> Luke: you could just linearly walk the file handle looking for a requested parameter
15:06:00 <Husel> mauke: what do I do to fix it?
15:06:08 <mauke> Husel: probably use >>
15:06:08 <acowley> Luke: or you could build some kind of search tree with file offsets to parameter names if the parameter values themselves are what you don't want in memory
15:06:09 <Luke> acowley: isn't that what I'm doing?
15:06:19 <acowley> Luke: No.
15:06:32 <syntaxfree> Luke: I haven't been following your question so maybe this is obvious to you, but generally it's a good idea to separate the functional and state-dependent parts of your code.
15:06:33 <acowley> Luke: laziness saves you memory when you incrementally consume a generated data structure
15:07:04 <Luke> acowley: really I'm just trying to read the file with readFile (which unless I'm doing Lazy IO, will read the file into mem all at once)
15:07:11 <desaiu> I have a feeling this endeavor is going to take much longer than expected.
15:07:21 <acowley> Luke: so if you were producing a list of parameters, and consuming them as they are parsed, then laziness could be great because you wouldn't need to every build the whole list in memory
15:07:32 <desaiu> The pain of doing things manually! Guess I will give in and do it manually
15:07:42 <Luke> acowley: yeah that's what i'm trying to do
15:07:48 <Luke> acowley: the whole list isn't big
15:07:52 <desaiu> I'll come back to this maybe over the weekend
15:07:55 <syntaxfree> I'm going to leave; I'm knee deep in folk truisms.
15:08:07 <desaiu> Because I know there are going to be several more combinatorial tasks in lab
15:08:32 <Husel> mauke: what exactly is >>? I don't think I've come across it anywhere yet
15:08:45 <Luke> acowley: I'm going to take off but be back on in an hour. Can you PM me if you have more to say?
15:08:48 <mauke> Husel: combines two IO actions into a single IO action
15:08:48 <acowley> Luke: and how are you using these parameters? Are they consumed once or do you want to refer to them possibly several times over the course of execution?
15:08:49 <Luke> acowley: thanks a lot for your help
15:08:49 <ski>   (>>) :: Monad m => m a -> m b -> m b
15:09:04 <hpc> (foo >> bar) = do foo, then bar
15:09:04 <ski> @undo do a; b
15:09:04 <lambdabot> a >> b
15:09:04 <acowley> Luke: I'll be gone soon, but I'm sure others will be able to help later!
15:09:12 <Luke> acowley: ok thanks
15:09:19 <RaptorRarr> Husel: It means to ignore the result of the monad on the left and then do the monad on the right.
15:09:25 <mauke> RaptorRarr: no
15:09:31 <mauke> also, fuck monads
15:09:34 <RaptorRarr> Rarr?
15:09:38 <ski> @do foo >> bar
15:09:38 <lambdabot> do { foo; bar}
15:09:44 <Luke> acowley: I'm not quite sure I understand your question about consuming them at once
15:09:47 <ski> Husel ^
15:09:50 <mauke> RaptorRarr: "do the monad" is nonsensical
15:09:53 <RaptorRarr> @src (>>)
15:09:54 <lambdabot> m >> k      = m >>= \_ -> k
15:10:25 <Husel> Thanks :) I'll try it but I haven't done monads yet
15:10:32 <ski> RaptorRarr : in `foo >> bar', neither `foo' nor `bar' is a monad -- they are monadic actions
15:10:43 <ski> RaptorRarr : if `foo :: m a', for some `m' and `a', then `m' is a monad, though
15:10:44 <desaiu> > map (nub . sort) . replicateM 3 $ [820,1000,2200,3300,4700,5600]
15:10:45 <lambdabot>   [[820],[820,1000],[820,2200],[820,3300],[820,4700],[820,5600],[820,1000],[8...
15:10:50 <mauke> Husel: you can ignore monads
15:10:53 <mauke> Husel: this is about IO
15:10:57 <RaptorRarr> Ahh, OK.
15:10:58 <RaptorRarr> Thanks
15:11:03 <ski> > nub . map (nub . sort) . replicateM 3 $ [820,1000,2200,3300,4700,5600]
15:11:04 <lambdabot>   [[820],[820,1000],[820,2200],[820,3300],[820,4700],[820,5600],[820,1000,220...
15:11:31 <ski> desaiu : btw, note that it's not good to use `nub' here if you might have two resistors with the same resistance
15:11:45 <ski> desaiu : which is why i suggested `select' in the first place
15:11:47 <desaiu> That's odd, I would have thought it would give me [[820,1000, 2200], [829, 2200, 3300], ...]
15:12:01 <desaiu> s/nub/select?
15:12:12 <ski> no, they don't have similar enough types
15:13:03 <ski> desaiu : the `[820]' was `[820,820,820]' before `nub' got its dirty paws on it
15:13:28 <desaiu> Oh
15:13:34 <desaiu> I have to run, I will be on later though
15:13:46 <desaiu> desai.shukla@gmail.com if you badly need me
15:14:19 <ski> desaiu : this is because `replicateM' in the `[]' (list) monad will happily select the same element more than once -- using my `pick' wrapping of `select', it removes the selected element so it won't choose it another time
15:14:28 <ski> @tell desaiu this is because `replicateM' in the `[]' (list) monad will happily select the same element more than once -- using my `pick' wrapping of `select', it removes the selected element so it won't choose it another time
15:14:28 <lambdabot> Consider it noted.
15:15:45 <ski> @tell desaiu (the "this" referring to "the `[820]' was `[820,820,820]' before `nub' got its dirty paws on it", apropos the unexpected initial `[820]' element in the `nub . map (nub . sort) . replicateM 3 $ [820,1000,2200,3300,4700,5600]' example)
15:15:45 <lambdabot> Consider it noted.
15:16:45 <hpaste_> ion pasted “resistor excercise” at http://hpaste.org/52438
15:17:26 <ion> @tell desaiu http://hpaste.org/52438
15:17:26 <lambdabot> Consider it noted.
15:18:16 * ski wonders why ion didn't annotate desaiu's original paste instead
15:20:31 <ion> ski: After that he switched to a sprunge.us paste.
15:21:01 <ski> oh, i missed that
15:23:10 <ddarius> nub . sort = evil
15:23:19 <ion> (Might as well have annotated the original paste anyway in hindsight.)
15:23:52 <hpc> ddarius: isn't that how you are supposed to use nub?
15:24:01 <ddarius> No.
15:24:04 <ion> ddarius: Yes. As soon as he understands this, it’s probably time to move to a better data structure.
15:24:12 <RichardBarrell> No, (nub) searches the entire list for every element.
15:24:13 <ion> ddarius: s/this/this code/
15:24:33 <FUZxxl> ski: Thanks!
15:25:00 <sm> mm_freak: are there cases where fastirc noticeably outperforms irc ?
15:25:01 <RichardBarrell> (map head . group . sort), not optimal but less evil.
15:25:24 <ddarius> If nothing else, do sort . nub.
15:25:24 <ion> Its meaning is actually (nub . map sort) . map nub. I should just have made it nub . map nub . sort, now that i think of it.
15:25:31 <shachaf> @let evil = nub . sort
15:25:32 <lambdabot>  Defined.
15:25:54 <ion> nub . map nub . … . sort
15:27:31 * ski . o O ( `coevil = cosort . conub' )
15:27:35 <mm_freak> sm: probably in all cases
15:28:25 <mm_freak> sm: fastirc uses a very fast attoparsec-based protocol parser
15:28:58 <ion> No, that’s not equal after all.
15:29:30 <ion> ski: :-D
15:30:17 <companion_cube> is it really likely that the bottleneck in an irc application would be the parser ?
15:30:31 <robert[]> no
15:31:19 <RichardBarrell> Seems more likely that the bottleneck in an IRC application is the ircd's flood control algorithm.
15:31:41 <RichardBarrell> Unless you're writing an ircd yourself in which case it *could* be, depending.
15:32:48 <ski> FUZxxl : btw, you could say that the point of CPS is to have every call be a tail-call
15:33:10 <FUZxxl> Thanks!
15:33:32 <sm> mm_freak: well, anyway I switched rss2irc to it because it looks better maintained, provides more type safety and doesn't require parsec==2. Thanks!
15:35:09 <FUZxxl> ski: I am not that familiar with tail calls.
15:35:14 <FUZxxl> I mean CPS
15:35:36 <FUZxxl> I just saw, that it seems that the LLVM backend can do that to some degree.
15:35:46 <FUZxxl> Just see http://llvm.org/demo
15:36:31 <desaiu> Times were mixed up, don't have to leave now.
15:36:31 <lambdabot> desaiu: You have 3 new messages. '/msg lambdabot @messages' to read them.
15:37:15 <mm_freak> sm: i wouldn't say it's better maintained…  i think i haven't uploaded a new version for almost 1.5 years
15:38:27 <sm> mm_freak: ok my bad.. uploaded more recently
15:40:31 <Husel> Thank you to everybody who has helped me :)
15:41:11 <ski> FUZxxl : i know that Mercury has optimizations like that, provided you have promised the corresponding associative law holds
15:41:27 <FUZxxl> ski That's good.
15:45:30 <efinn> Could someone help me with a question about multiparameter type classes?
15:46:21 <mauke> preflex: 8ball Could someone help efinn with a question about multiparameter type classes?
15:46:22 <preflex>  don't count on it
15:46:33 <efinn> uh-oh
15:46:44 <FUZxxl> efinn: Okay.
15:46:48 <efinn> I'm just trying to understand some of the stuff in the HList library
15:46:49 <FUZxxl> What's the issue.
15:46:50 <shachaf> Yes, it seems unlikely that anyone can help you if you don't ask the question.
15:47:04 <efinn> sorry, lemme make a paste
15:47:06 <FUZxxl> @hoogle Hlist
15:47:06 <lambdabot> No results found
15:47:14 <tac-tics> @faq Can haskell help you if you don't ask the question?
15:47:15 <lambdabot> The answer is: Yes! Haskell can do that.
15:47:15 <FUZxxl> @hackage hlist
15:47:15 <lambdabot> http://hackage.haskell.org/package/hlist
15:47:36 <FUZxxl> @hackage HList
15:47:36 <lambdabot> http://hackage.haskell.org/package/HList
15:47:37 <FUZxxl> okay.
15:47:46 <hpaste_> efinn pasted “MPTC's” at http://hpaste.org/52440
15:47:50 <FUZxxl> What part of that doc is difficult to understand?
15:48:04 <efinn> basically, i can't see how to generate instances of the HApply class
15:48:28 <efinn> even though i declare if for function types, it doesn't derive the instance for the simple example
15:48:32 <hpaste_> ion annotated “resistor excercise” with “resistor excercise (annotation)” at http://hpaste.org/52438#a52441
15:49:09 <ion> desaiu: See above. I didn’t think of Data.List.subsequences and i should have.
15:49:12 <desaiu> Woah ski!
15:49:16 <desaiu> That was really nice of you!
15:49:30 <desaiu> I mean ion
15:49:31 <desaiu> sorry
15:49:35 <sm> dangit stepcut, couldn't you have picked yesterday to release a new irc lib
15:49:45 <desaiu> Both of you :)
15:49:55 <desaiu> That's a whole lesson!
15:50:08 <desaiu> I wonder if I can digest this with a buddy over the weekend.
15:50:38 <desaiu> How did you leave messages like that, btw?
15:50:44 <desaiu> !ion test
15:50:53 <desaiu> I guess not that
15:50:55 <ion> Say “@tell nick blahblah” on the channel.
15:51:05 <desaiu> Got it.
15:51:19 <efinn> The more general problem, btw, is to understand how to fold over heterogenous lists
15:51:26 <desaiu> lambdabot: msg help
15:51:29 <efinn> I can't seem to wrap my head around it
15:51:30 <desaiu> lambdabot: help
15:51:50 <desaiu> > help
15:51:51 <lambdabot>   Not in scope: `help'
15:52:11 <ski> FUZxxl : see "Making Mercury programs tail recursive" by Peter Ross,David Overton,Zoltan Somogyi in 1999 at <http://www.mercury.csse.unimelb.edu.au/information/papers.html#tail_lopstr_lncs>, "State update transformation" by Peter Ross,Zoltan Somogyi at <http://www.mercury.csse.unimelb.edu.au/information/papers.html#update> -- Nancy Mazurs papers on structure reuse and compile-time GC are also interesting here
15:52:54 <ski> desaiu : like `@tell desaiu <message>', there's also `@ask desaiu <question>', which does the same thing
15:53:01 <ski> @help tell
15:53:01 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
15:53:02 <ski> @help ask
15:53:03 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
15:53:04 <ion> desaiu: In this case, think of (f &&& g) as (\a -> (f a, g a)). That might be a stumbling block since the documentation of (&&&) is perhaps too general.
15:53:07 <desaiu> @lambdabot help
15:53:07 <lambdabot> Unknown command, try @list
15:53:10 <desaiu> @list
15:53:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:53:19 <ski> @help
15:53:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:53:27 <ion> > (f &&& g) a :: (Expr, Expr)
15:53:28 <lambdabot>   (f a,g a)
15:54:07 <ion> > (length &&& ("foo":)) ["bar", "baz"]
15:54:08 <lambdabot>   (2,["foo","bar","baz"])
15:54:51 <hpaste_> DanBurton pasted “"true" qsort” at http://hpaste.org/52443
15:54:51 * ski idly wonders who ion is showing off `(&&&)' for ..
15:55:36 <ion> I used map (parRes &&& id) in the example for desaiu.
15:58:39 * ski . o O ( "Unclean! Unclean! or Purity issues in declarative constraint logic Programming" )
16:00:15 <ski> > map (id &&& (^ 2)) [0,1,2,3]
16:00:16 <lambdabot>   [(0,0),(1,1),(2,4),(3,9)]
16:00:20 <ski> > map (graph (^ 2)) [0,1,2,3]
16:00:21 <lambdabot>   [(0,0),(1,1),(2,4),(3,9)]
16:00:31 <ski> ion ^
16:01:11 <dschoepe> Is there some GHC extension that allows me to use monadic actions in guards (provided the result of the function is monadic)?
16:01:18 <ski> no
16:02:01 * ski isn't sure he'd even like that
16:02:06 <incluye> > arr (+1)
16:02:07 <lambdabot>   No instance for (GHC.Show.Show (a a1 a1))
16:02:07 <lambdabot>    arising from a use of `M805295...
16:02:15 <ion> ski: What defines graph?
16:02:20 <ski> i
16:02:22 <Peaker> dschoepe: why not just extract that func into:   realFunc | pureGuards = ...        and then: func = realFunc =<< action
16:02:38 <ski> <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f; cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| arr id
16:02:45 <ski> also, note
16:02:47 <ski> @type ap (,)
16:02:48 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
16:03:00 <ion> aye
16:03:17 <dschoepe> Peaker: that adds another layer of where declarations. In my case that would clutter things up too much.
16:03:34 <dschoepe> I'm currently using an ifM-function instead
16:04:03 <Peaker> dschoepe: or a separate function altogether
16:06:23 <ski> dschoepe : i'm not sure i'd like the order in which clauses/equations are written to get even more significant than it unfortunately already is
16:07:39 <dschoepe> ski: Well, ordering already important in monadic code, especially in IO, so I don't think it'd irritate me that much.
16:08:06 <DanBurton> anybody take a glance at my "true" quicksort paste? It seems rather cumbersome. Are there any imperative idioms that I'm not taking advantage of?
16:08:06 <ski> yes, but that's ordering of commands in `do', not ordering of clauses/equations
16:09:29 <dschoepe> It would definitely be ugly if it was used for more than things like doesFileExist anyway.
16:09:49 <dschoepe> If it would only be used like that, it would be no worse than pure guards, I think.
16:12:05 <stribor> i have problrm with isInfixOf function
16:12:20 * Clint nods.
16:12:32 <stribor> for example if you have let c = [1,2,3,4,5,6]   let d = [2,6]
16:12:50 <stribor> shouldnt this function return true since d is contained inside c
16:13:15 <hpc> stribor: no
16:13:28 <hpc> > "hewo" `isInfixOf` "hello world" -- what should this be?
16:13:29 <lambdabot>   False
16:14:00 <stribor> so what function should i use
16:14:09 <stribor> i want to find if d is inside c
16:14:29 <hpc> does it have to be in that order?
16:14:32 <stribor> no
16:14:34 <hpc> or could it be something like
16:14:48 <stribor> doesnt have to be in order
16:15:00 <hpc> > let c = [1, 6, 5, 4, 2]; d = [2, 6] in all (`elem` c) d
16:15:00 <RaptorRarr> > all (flip elem "hello world") "hewo"
16:15:01 <lambdabot>   mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
16:15:02 <lambdabot>   True
16:15:14 <hpc> > let c = [1, 6, 5, 4, 2]; d = [2, 6] in all (`elem` c) d
16:15:15 <lambdabot>   True
16:15:17 <RaptorRarr> > all (flip elem "hello world") "hewo"
16:15:19 <lambdabot>   True
16:15:21 <RaptorRarr> Darn
16:15:32 <RaptorRarr> Wait. L is sometimes unloaded?
16:15:35 <stribor> i thought it was already function for this
16:15:37 <hpc> someone must have been editing L.hs or something
16:16:15 <hpc> @hoogle isSubsetOf
16:16:15 <lambdabot> Data.IntSet isSubsetOf :: IntSet -> IntSet -> Bool
16:16:15 <lambdabot> Data.Set isSubsetOf :: Ord a => Set a -> Set a -> Bool
16:16:32 <hpc> might i ask why you don't use a Set?
16:16:37 <RaptorRarr> @pl \xs goods -> all (flip elem goods) xs
16:16:38 <lambdabot> flip (all . flip elem)
16:16:54 <RaptorRarr> > "hewo" `all . flip elem` "hello world~
16:16:55 <lambdabot>   <no location info>: parse error on input `.'
16:16:56 <RaptorRarr> > "hewo" `all . flip elem` "hello world"
16:16:57 <lambdabot>   <no location info>: parse error on input `.'
16:17:04 <hpc> backticks don't work that way
16:17:21 <RaptorRarr> :(
16:17:24 <stribor> hpc: because i didnt know about it
16:17:44 <stribor> to find this function i was doing search of hoogle [a]->[a]>->Bool
16:17:55 <stribor> and it returned isInfixOf
16:18:11 <hpc> yeah, makes sense
16:18:29 <hpc> you should take a look through the rest of the containers package when you get a chance (iirc that's where Set is?)
16:18:32 <stribor> hpc: what kind of type is IntSet
16:18:37 <hpc> there's other good structures in there
16:18:44 <copumpkin> stribor: *
16:18:47 <stribor> can i use this isSubste on the ist
16:18:53 <hpc> stribor: IntSet is (Set Int), only specialized
16:19:11 <hpc> it's a lot faster if you know that's the type you wat
16:19:34 <stribor> Well i want to apply it on the lists of pairs
16:21:23 <stribor> hpc: how would i use this in lists of integers
16:22:23 <hpc> stribor: uh, im a bit confused now
16:22:36 <hpc> the actual problem you want to solve isn't going to see data like the c and d you had above?
16:22:56 <hpc> it's going to see [(a,b), (c,d), ...]?
16:23:16 <stribor> no this is actual lists let a = [(1,1),(2,2),(3,3)] let b = [(1,1),(3,3)]
16:23:23 <stribor> is b inside a?
16:23:41 <hpc> ah, for that you should probably just use lists then
16:23:55 <hpc> it'll be less painful for now
16:23:56 <stribor> hpc: what you mean just lists?
16:24:14 <hpc> stribor: like you just pasted, let a = [...
16:24:35 <dalaing> stribor: lists rather than a Set of pairs of Ints
16:24:37 <hpc> and write isSubsetOf a b = ... and use that
16:24:43 <tkahn6> stribor you could use a hash set to get some speed
16:25:04 <ion> desaiu: To avoid confusion from (&&&) i replaced it by the equivalent lambda expression. https://gist.github.com/1276863
16:25:09 <stribor> hpc: but isSubste parametars are of type IntSet
16:25:50 <dalaing> stribor: you'd need to write your own version of isSubsetOf
16:25:51 <hpc> stribor: you can write your own function with that name, and just not import the other one
16:26:07 <hpc> (in fact, that's how that hoogle search found multiple results)
16:26:29 <stribor> oh ok...i thoiught there was already implemented function that i could use
16:26:38 <hpc> not that i know of
16:26:55 <stribor> hpc: ok thank you
16:31:57 <desaiu> Is that a .lhs file? You would need something like main = do...
16:32:10 <DevHC^> which is the first GHC version supporting FFI?
16:32:11 <desaiu> I don't know how to set that file up to be ran
16:32:11 <incluye> > fix ((1 :) . (1 :) . ap (zipWith (+)) tail)
16:32:12 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:32:31 <ion> > fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
16:32:33 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:33:23 <desaiu> I also feel like I'm in over my head in writing Haskell programs after reading that, and after considering my course load at school. The plan is to learn Haskell over the next three years while I'm not going to school for it
16:33:43 <desaiu> After three years, I should be taking some CS courses finally, and I might be able to apply what I've been learning.
16:33:59 <tac-tics> desaiu: Don't be intimidated by Haskell Golf
16:34:01 <ion> > fix((0:).scanl(+)1)
16:34:02 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:34:30 <tnks> I've been thinking about how abstract Haskell's data types are.
16:34:49 <tac-tics> desaiu: Most of what you see going into lambdabot is some Haskeller trying to be clever. And the easiest way to be clever is to do something old in a hard-to-understand way
16:34:54 <tnks> is it possible with the module system to expose the abstract type and operations that work on it, without exposing the type constructors?
16:35:05 <monochrom> haskell data types are normally concrete. you use selective export to make them abstract. that is all.
16:35:15 <monochrom> yes, that's how to do it
16:35:33 <tac-tics> tnks: Yes. You can mark at the top of your haskell file which constructors and functions to export. Everything else becomes private to the module.
16:35:35 <RichardBarrell> tnks: yes! You can expose just the functions that rip your data structure apart rather than the definition of your data structure itself.
16:35:55 <monochrom> module Whee(MyType, myop) where data MyType = X | Y; myop = X
16:36:04 <tnks> monochrom: tac-tics: RichardBarrell: awesome. . . that's what I was hoping.
16:36:22 * tac-tics finds it annoying you can't mark stuff as "private" at the location it's defined in Haskell
16:36:23 <desaiu> I'm terrible at programming, I've decided.
16:36:49 <desaiu> I couldn't hack a simple comination problem together
16:36:53 <RichardBarrell> tac-tics: you can tell a bored #haskell user because they're putting ever more and more complicated implementations of (id :: a -> a) for some restricted 'a' through lambdabot. :)
16:36:56 <monochrom> if you write module Whee(MyType(..)  you make the type concrete to users
16:37:07 <Axman6> tnks: module Foo (DataType,funcOnDT1,funcOfDT2) where
16:37:23 <tac-tics> desaiu: You're probably not terrible. You're just learning there are more ways to implement a single function that there are ways that people actually care about.
16:37:27 <Axman6> monochrom: can you only export certain constructors?
16:37:38 <monochrom> yes, module Whee(MyType(X)
16:37:42 <tac-tics> desaiu: The classic Haskell joke: http://www.willamette.edu/~fruehr/haskell/evolution.html
16:37:51 <Axman6> thought so. i've just never used that
16:37:59 <monochrom> note that module Whee(MyType, X  most likely doesn't work at all
16:37:59 <desaiu> I've read that several times before
16:38:06 <desaiu> Have it saved on my ebook device
16:38:32 <tac-tics> desaiu: Factorial is a stupid easy function, but Haskellers like to be "clever" and come up with many non-obvious ways to write it. But in reality, the only ones you should *EVER* see in a real, maintainable program are the first (freshman level) and the last (professor, teaching the freshman level)
16:38:38 <desaiu> I really am terrible though, I have nothing to show for the years that I've spent lazily learning programming as a hobby
16:39:03 <desaiu> Oh well, boohoo, I'm going to continue on with my plan as stated
16:39:24 <incluye> @pl \n -> product [1..n]
16:39:25 <lambdabot> product . enumFromTo 1
16:39:46 <tac-tics> lol, desaiu. I've been doing programming for 10 years, and I've never written anything I'm all that proud of.
16:40:18 <incluye> @pl \n -> foldr1 (*) [1..n]
16:40:18 <lambdabot> foldr1 (*) . enumFromTo 1
16:40:47 <desaiu> I will be back on later, thanks for the pick-me-up tac-tics
16:40:52 <desaiu> I have to meet someone now
16:43:19 <Hayshi> can someone give me an example of how fst works on a tuple?
16:43:29 <shachaf> > fst (1,2)
16:43:30 <lambdabot>   1
16:43:31 <monochrom> fst (x,y) gives you x
16:44:21 <hpc> fst (x, y) = x
16:45:09 <ion> > fst (x, y) :: Expr
16:45:09 <lambdabot>   x
16:45:44 <tac-tics> :t x
16:45:45 <lambdabot> Expr
16:45:51 <tac-tics> :t y
16:45:52 <lambdabot> Expr
16:46:04 <Axman6> > fst ("Hello", True)
16:46:04 <kmc> @src fst
16:46:05 <lambdabot> fst (x,_) =  x
16:46:05 <lambdabot>   "Hello"
16:46:08 <Axman6> > snd ("Hello", True)
16:46:09 <lambdabot>   True
16:47:14 <dalaing> Hayshi: it only works for pairs though
16:47:23 <donri> @check \x -> (fst x, snd x) == x
16:47:23 <lambdabot>   "OK, passed 500 tests."
16:47:36 <kmc> @check \x -> (snd x, fst x) == x
16:47:37 <lambdabot>   "OK, passed 500 tests."
16:47:53 <donri> wat
16:47:58 <kmc> it defaults to the type ()
16:48:06 <dalaing> hehe
16:48:07 <kmc> @check \x -> (snd x, fst x) == (x :: (Char, Char))
16:48:07 <copumpkin> @check \xs -> reverse xs == xs
16:48:08 <lambdabot>   "Falsifiable, after 0 tests:\n('\\73358','\\1027844')\n"
16:48:08 <lambdabot>   "OK, passed 500 tests."
16:48:37 <RaptorRarr> Ooooh! It didn't even take 1 test!
16:49:15 <kmc> wow, non-BMP characters :O
16:49:17 <ion> Huh. Why wasn’t that shrinked?
16:50:18 <ion> *** Failed! Falsifiable (after 1 test and 1 shrink):
16:50:18 <ion> ('a','b')
16:50:19 <ion> Works here.
16:50:36 <kmc> same
16:54:02 <quackquack> How can i convert a `IO UTCTime` to `UTCTime`
16:54:11 <copumpkin> @quote monochrom IO
16:54:11 <lambdabot> monochrom says: Do you know how godawful it is the 21st Century already and 2 out of 3 mainstream languages don't have nested functions, and the remaining 1 has it but only by way of an even more
16:54:11 <lambdabot> godawful construct?
16:54:14 <copumpkin> @quote monochrom IO
16:54:14 <lambdabot> monochrom says: linkalation
16:54:19 <copumpkin> @quote monochrom.IO
16:54:19 <lambdabot> No quotes match. You untyped fool!
16:54:23 <copumpkin> boo
16:54:28 <copumpkin> quackquack: you don't
16:54:52 <tac-tics> quackquack: Inside an IO "do" block, you can use myTime <- myIOTime or whatever
16:55:18 <tac-tics> generally, the <- in do notation turns an IO a into an a
16:55:25 <dalaing> quackquack: what are you trying to do?
16:55:30 <tac-tics> (but you, of course, have to end up with an IO value in the end)
16:55:38 <dalaing> (in the larger sense)
16:55:46 <quackquack> im trying to convert the current time (an IO UTCTime) to a regular UTC time
16:56:00 <copumpkin> an IO UTCTime doesn't contain a UTCTime
16:56:06 <quackquack> so that i can convert it to a Day
16:56:34 <dalaing> quackquack: and then what? are you going to print it to the screen, or write it to a file or something?
16:56:51 <DanBurton> (IO UTCTime) is an "IO action"
16:56:52 <quackquack> dalaing: yeah, ill be serializing it as JSON at some point
16:57:03 <DanBurton> generally the way to "run" an "IO action" is with <-
16:57:13 <RaptorRarr> quackquack: Make a function that takes a UTCTime and does whatever to it. fmap that onto the IO action.
16:57:21 <copumpkin> http://www.perlmonks.org/index.pl?node_id=542341
16:57:54 <FUZxxl> @src reverse
16:57:55 <lambdabot> reverse = foldl (flip (:)) []
16:58:04 <dalaing> quackquack: the bigger question is - do you want to get this done now and understand why it seems more complicated than you expected later, or do you want to take care of both at the same time :)
16:58:06 <RaptorRarr> quackquack: Your function will have the UTCTime, but outside the evil confines of IO.
16:58:41 <quackquack> dalaing: im looking to understand it, then making it work should be easy :)
16:58:45 <dalaing> indeed
16:59:01 <quackquack> RaptorRarr: so split up the part that actually does the IO from anything that uses the value
16:59:34 <RaptorRarr> quackquack: Yeah, that's one way to do it (plus, since it's pure, you might get more optimizations on the computational part).
16:59:51 <quackquack> RaptorRarr: ok, thanks :)
17:00:05 <RaptorRarr> quackquack: You're welcome.
17:03:00 <dalaing> quackquack: to idealize a little, you've got pure functions (no side effects) and non-pure functions (which can have side effects, such as IO actions) - and to make sure you know when you're dealing with non-pure code the type system makes sure that if something is marked with IO it stays marked with IO, so you can't get too sneaky
17:04:00 <quackquack> dalaing: and IO being anything w/ side effects?
17:04:08 <kmc> dalaing, you're describing Haskell?
17:04:39 <shachaf> kmc: dalaing doesn't seem to be describing Haskell to me. :-)
17:04:58 <dalaing> kmc: just trying to explain why trying to go from IO UTCTime to UTCTime doesn't fly, and then how to approach it from another angle
17:05:07 <kmc> quackquack, http://haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
17:05:17 <kmc> dalaing, ah, I think that's a confusing way to put it
17:05:17 <shachaf> dalaing: IO UTCTime isn't a non-pure function -- it's neither a function nor non-pure.
17:05:32 <kmc> IO isn't a prison for values tainted by the real world
17:05:45 <kmc> it's a type for describing IO actions which *have not occurred yet*
17:05:49 <kmc> there's no Int hiding inside the IO Int
17:05:52 <quackquack> so when the word "function" is used in haskell, it is in the mathematical sense?
17:05:53 <kmc> there's an imperative program hiding inside
17:05:56 <kmc> quackquack, yes
17:06:00 <quackquack> ahhh
17:06:06 <donri> IO in haskell is a form of a value that is executed only if it is the "main" function
17:06:12 <kmc> main is not a function
17:06:29 <RaptorRarr> main is a value?
17:06:30 <shachaf> x :: IO {-5-} Int
17:06:33 <donri> true
17:06:34 <kmc> functions are values, too
17:06:34 <dalaing> I was hand waving and rounding the edges a bit - should probably have taken my time a little more
17:06:38 <geheimdienst> (haskell is a DSL for making IO actions ...)
17:06:42 <shachaf> kmc: I hear it usually is.
17:06:48 <tac-tics> If we model IO a as RealWorld -> (RealWorld, a), then IO UTCTime is surely a function.
17:06:57 <kmc> i think Cale's "Introduction to IO" article does a good job explaining this in terms which are concrete yet correct
17:07:09 <kmc> tac-tics, no, it's analogous to a function
17:07:13 <kmc> just like it's analogous to a burrito
17:07:24 <kmc> except both analogies are bad
17:07:40 <RaptorRarr> kmc: This one? http://www.haskell.org/haskellwiki/Introduction_to_IO
17:07:41 <tac-tics> kmc: main is a function when you expand IO () with the internal definition in GHC.
17:07:45 <kmc> RaptorRarr, yes
17:07:48 <shachaf> tac-tics: World -> (World, a) isn't a helpful model.
17:07:55 <tac-tics> If we're going to be pedantic, we might as well be as unhelpful as possible ;)
17:07:56 <shachaf> tac-tics: The internal GHC implementation is something else.
17:08:04 <kmc> tac-tics, sure, that's an implementation detail of GHC, and a confusing and misleading one if you're trying to understand IO conceptually
17:08:25 <dalaing> seeing I fumbled IO so badly, does anyone else want to have a crack at explaining bind / do notation and how pure code gets stitched into code dealing with IO? :)
17:08:33 <kmc> yes, Cale would like to have a crack at that
17:08:38 <kmc> he already wrote it up on the wiki :)
17:08:59 * tac-tics found it most helpful to learn the basic rules of "do" notation, and then deal with the monad shit later.
17:09:03 <kmc> I think more of these stock explanations should be written up and polished
17:09:10 <shachaf> @ty let infiniteBurrito :: Monad m => Mu m; infiniteBurrito = undefined in infiniteBurrito
17:09:10 <kmc> rather than being passed on and mangled by the #haskell oral tradition
17:09:10 <lambdabot> forall (m :: * -> *). (Monad m) => Mu m
17:09:16 <donri> also, sequential IO ("imperative") works by >>= simply doing that for the monad instance of IO - it's not part of "Monad" itself but specifically the instance for IO (my rookie understanding)
17:09:24 <Tan_> hey guys
17:09:27 <Tan_> what is up?
17:09:34 <ion> burritos
17:09:38 <Tan_> lolol
17:09:44 <Tan_> u guys haskel pros?
17:09:51 <Tan_> *haskell
17:09:55 <Tan_> i just started
17:10:01 <Tan_> it seems fun to use
17:10:03 <Tan_> lolol
17:10:05 <tac-tics> The Burrito Analogy is bad only because it's hard to spell. I prefer the Taco analogy for Monads
17:10:07 <kmc> tac-tics, and the thing inside the IO newtype in GHC is not really a function: it's not pure, it breaks all the usual Haskell rules
17:10:20 <Tan_> ?
17:10:21 <kmc> tac-tics, its type is written using (->) but arguably that itself is a GHC extension
17:10:30 <Tan_> what are u guys talkin bout?
17:10:33 <kmc> haskell
17:10:36 <Tan_> oh
17:10:37 <tkahn6> Tan_ you might find #haskell-blah interesting
17:10:38 <Tan_> lol
17:10:39 <kmc> @where burrito
17:10:39 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
17:10:53 <RaptorRarr> tac-tics: I like that increase in usability.
17:11:54 <tac-tics> <- takes the meat out of the taco. ; joins two tacos together. And return wraps meat back into the taco.
17:12:06 <tac-tics> And you must always end up with a taco because the customer doesn't want to get meat on his hands
17:12:34 <tac-tics> Works as a perfect analogy as long as your monad is some kind of state monad (Maybe, ST, State, IO)
17:12:40 <donri> monad analogies only make sense when you already understand monads :P
17:12:53 <kmc> Maybe is a "state monad"?
17:12:55 <tac-tics> it breaks down with non-determinism, but at least then you have some sense of the typing rules involved
17:13:14 <kmc> it breaks down at the beginning
17:13:21 <tac-tics> kmc: er, Maybe is not a state monad, my bad
17:13:23 <dalaing> yeah, I was definitely burritoing earlier
17:13:43 <dalaing> in the pejorative sense
17:14:34 <kfish> i had a chimichanga yesterday, it tasted just like a deep-fried monad
17:15:19 <kmc> nom
17:16:31 <kfish> does anyone know of a version-control repo for vacuum?
17:16:46 <copumpkin> it went down with mmorrow's website
17:16:56 <kfish> yes, that's what i expected ...
17:17:13 <copumpkin> well, someone else might have a mirror somewhere
17:17:38 <kfish> i'll just reconstruct one from tarballs if there's no other ...
17:19:19 <ski> @wiki Introduction to IO
17:19:19 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
17:19:30 <ski> quackquack : you should read that ^ if you haven't already
17:19:32 <copumpkin> kfish: yeah, I can't find another one
17:19:47 <quackquack> ski: thank you, i will read that now :)
17:19:53 <ski> kmc : if you insert the appropriate uniqueness annotations, it becomes pure
17:20:02 <kmc> *nod*
17:20:08 <kmc> which GHC doesn't support :/
17:20:14 <ski> indeed
17:21:10 <ski> i'm just saying it's not a totally wrong intuition -- that doesn't mean it's so helpful with e.g. concurrency -- still, at least for me it served a purpose
17:21:19 <kmc> *nod*
17:21:27 <kmc> SPJ agrees with you :)
17:21:40 <kmc> perhaps i should not be so harsh on the (State RealWorld) analogy
17:21:49 <kmc> but i don't think any analogy is necessary
17:21:49 <ski> (in which paper ?)
17:21:54 <ski> (or video ?)
17:21:59 <kmc> (in the Taste of Haskell slides, for one)
17:22:07 <kmc> the truth about IO is simple enough, no analogy is necessary
17:22:24 <incluye> > fix (\n -> n + 1)
17:22:25 <ski> well, analogies might be useful as stepping stones ..
17:22:25 <shachaf> I like data IO = Exit | PutStrLn String IO | GetLine (String -> IO)
17:22:27 <lambdabot>   mueval-core: Time limit exceeded
17:22:40 <incluye> > fix (\n -> n:succ n
17:22:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:22:42 <incluye> > fix (\n -> n:succ n)
17:22:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:22:45 <kmc> IO actions are imperative programs which you manipulate as first-class values
17:22:49 <ski> shachaf : yeah, i like the ADT one as well
17:23:00 <shachaf> That one makes it obvious that you can write an interpreter yourself.
17:23:01 <kmc> I think that's an idea which needs not analogies but examples
17:23:06 <shachaf> The RTS just happens to provide one for you.
17:23:10 <kmc> *nod*
17:23:57 <ski> > fix (\n -> LT : map succ n)
17:23:58 <lambdabot>   [LT,EQ,GT,*Exception: Prelude.Enum.Ordering.succ: bad argument
17:27:55 <incluye> > sum $ fix (1:)
17:28:21 <lambdabot>   thread killed
17:28:30 <incluye> huh
17:28:34 <Luke> I'm trying to make an ascii text parser to parse a large file. Really I only want a small amount of data from the file and I don't want the whole file in mem at once. My first approach was to use lazy bytestrings (after I write the parser strictly) and put the fields I was looking for into a map. Apparently filling maps lazily isn't a good idea?
17:28:44 <djahandarie> > fix (1:)
17:28:53 <lambdabot>   mueval-core: Time limit exceeded
17:28:54 <Luke> would it be a good idea to parse a lazy bytestring into a strict data structure?
17:28:58 <djahandarie> > fix (1:)
17:29:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:29:07 <djahandarie> incluye, what's the sum of that? :P
17:29:13 <incluye> djahandarie: infinity!
17:29:17 <incluye> or maybe bottom
17:29:24 <djahandarie> You got bottom.
17:29:28 <Guest87507> what sum means?
17:29:32 <djahandarie> (Non-termination is considered bottom.)
17:29:34 <incluye> i got a dead thread
17:29:35 <Peaker> Luke: A Data.Map is not usefully lazy, I think
17:29:41 <incluye> well jeez bottom is all over the place isn't it
17:29:55 <Luke> Peaker: is there a place I could read more about this?
17:30:17 <kmc> with an inductive natural number type, sum (fix (1:)) is not ⊥
17:30:40 <Luke> I'm having trouble coming up with a good architecture for this parser
17:30:52 <djahandarie> kmc, with a lazy inductive natural number type.
17:31:03 <hpc> Peaker: Data.Map is spine-strict, and probably also strict in the key
17:31:14 <kmc> djahandarie, sure, as it would be by default in Haskell
17:31:19 <djahandarie> Indeed.
17:31:25 <hpc> it has all sorts of unpack and bang-pattern stuff in the definition, if you read through the source
17:31:41 <Peaker> Luke: what do you need from your Data.Map?
17:31:53 <Luke> Peaker: the map is just the results of the parse
17:31:55 <rwbarton> certainly it needs to evaluate keys enough to compare them
17:32:04 <Luke> I think I may want to parse strictly but read the file lazily?
17:32:15 <incluye> > [1,1..] == [1,1..]
17:32:16 <Luke> I'm eventually going to put the results into CSV
17:32:19 <lambdabot>   mueval-core: Time limit exceeded
17:32:28 <Luke> i'm using the map so I can reorder the results based on the column definition
17:33:02 <copumpkin> incluye: in agda I can prove that's true but can't decide whether it's true
17:33:13 <incluye> hmm
17:33:19 <Peaker> Luke: why not put it into CSV as part of the parsing pass?
17:33:52 <Luke> Peaker: not very separated concernes then... tying the output to the input
17:34:11 <Luke> Peaker: for example, I may want to go to a different output format in the future (db?)
17:34:15 <incluye> > let a = [1..] in a == a
17:34:43 <Peaker> Luke: I meant operationally, not in code
17:34:46 <lambdabot>   thread killed
17:34:56 <kfish> hmm, did -fglasgow-exts ever implicitly change how things are compiled? ie. change the optimization strategy or anything ...
17:34:59 <Luke> Peaker: oh - how do you mean?
17:35:09 <Peaker> Luke: either lazy I/O (yuck, I hate it :-)  or Iteratee chaining
17:35:56 <Luke> Peaker: is lazy IO something to avoid?
17:35:57 <Peaker> Luke: Lazy I/O is probably easier to start with -- basically you can write a big  input->csv processing pipeline, and as long as that pipeline doesn't demand too much input at once, or keep around old input, it can run in constant memory
17:36:08 <Peaker> Luke: IMO, yes, but it's controversial
17:36:15 <Peaker> For toy programs it's probably OK
17:36:38 <Luke> Peaker: I'm kinda trying to learn more about lazy IO with this project anyway
17:37:19 <hpc> Luke: ever used getContents or hGetContents?
17:37:43 <Luke> hpc: I'm using readFile now (which I think uses getContents)
17:38:00 <Peaker> Luke: Lazy I/O hides (supposedly benign) effects behind pure values... It also makes the order of effects not well specified w.r.t any other IO effects in your program.  It also moves the actual time consumption from IO actions to pure code (e.g: if you rely on async IO exceptions).  It also doesn't have a reasonable way to report I/O errors
17:38:08 <hpc> indeed it does
17:38:32 <hpc> Luke: if you understand how hGetContents decides when to continue reading more file input, you understand lazy IO
17:38:35 <hpc> congladurations! :P
17:39:10 <Luke> hpc: can you expand on that?
17:39:14 <shachaf> hpc: No one truly understands lazy IO.
17:39:21 <Luke> haha
17:40:02 <hpc> Luke: suppose instead of a file, you were reading in a network handle to an irc server
17:40:16 <Luke> The way I'm thinking about this parser is reading a stream of bytes, pulling out the ones I want and storing them in a map as I go... so the only space usage would need to be the map I'm keeping (and whatever's in the stream)
17:40:24 <hpc> you hGetContents on the handle and get a string that is "everything that will come through that handle"
17:40:41 <hpc> when you try to evaluate input that hasn't happened yet, it waits for it to happen
17:40:48 <hpc> so to speak
17:40:51 <Luke> sure
17:41:18 <hpc> and if you don't evaluate input that has happened, it stays buffered until you do
17:41:22 <Peaker> Luke: getContents :: IO String -- after the action is executed, you supposedly have a nice, pure, lazy string in your hands.  But what you actually have, is a magical list. This magical list, as consumed, actually performs the reads. It memoizes/caches the results so if you re-access old list entries it doesn't re-read.  If IO error is encountered, it just becomes an empty list...
17:41:36 <hpc> or more generally, IO doesn't happen until you evaluate data that the action would produce
17:41:50 <hpc> and that's lazy IO in a nutshell
17:42:01 <hpc> spooky action caused by evaluating a pure value
17:42:11 <hpc> only not spooky, and very specific
17:42:38 <Luke> so in general lazy IO is avoided? =)
17:42:52 <Luke> Peaker: hpc: that's actually really helpful
17:42:55 <Peaker> Luke: by non-toys, these days, yeah
17:42:59 <kmc> Luke, it's nice for small one-off scripts and the like
17:42:59 <hpc> in general, though there are safe uses
17:43:18 <Luke> I'm basically trying to write a one-off script
17:43:28 <hpc> for an IRC client, for example, you don't want the entire program blocking just because nobody has said anything
17:43:32 <Luke> I have it written... it reads every file into memory it seems =)
17:43:56 <Peaker> Luke: hpaste.org ?
17:44:02 <Luke> hpc: yeah gotcha... in this case I'm writing a log parser, to give some context
17:44:28 <Luke> http://hpaste.org/52430
17:45:06 <Luke> at this point, like Peaker suggested against, the parser happens fully before the use of the parsed data happens
17:45:20 <Luke> so I'm now trying to think of a way to consume the data as I parse it
17:45:23 <hpc> imo, operations on Handles are so easy and powerful that you have to be really lazy to use lazy IO to replace them (harr harr)
17:45:35 <Luke> haha
17:46:09 <hpc> Luke: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html -- everything you ever needed to know about files and network handles and all that crap
17:46:09 <Luke> I'm vaguely familiar with iteratees and don't really want to go down that route for this
17:46:48 <mm_freak> how expensive is realToFrac from a Double to a Double?
17:46:59 <mm_freak> > realToFrac (3.5 :: Double) :: Double
17:47:04 <lambdabot>   mueval-core: Time limit exceeded
17:47:09 <mm_freak> huh?!
17:47:12 <djahandarie> Apparently, very expensive.
17:47:12 <djahandarie> :P
17:47:16 <djahandarie> lambdabot is just lagging.
17:47:18 <mm_freak> seems to be very expensive =)
17:48:03 <Luke> Peaker: is it possible to to interleave state accumulation in parsec(atto)?
17:48:16 <kfish> copumpkin, https://github.com/kfish/vacuum
17:49:03 <copumpkin> neat :)
17:49:44 <copumpkin> oh sweet, a nice barrister from nigeria is offering me several million dollars. Now I can relax and start a haskell company
17:49:47 <copumpkin> y'all are all invited
17:50:02 * hackagebot vacuum 1.0.0.1 - Extract graph representations of ghc heap values.  http://hackage.haskell.org/package/vacuum-1.0.0.1 (ConradParker)
17:50:38 <mgsloan> I'm not sure why more rich people aren't patrons of the PL arts
17:50:53 <copumpkin> I'd love to be, if I were rich
17:51:04 <ion> copumpkin: I take it there’s a small processing fee we need to pay before getting the huge salaries from your company?
17:51:14 <kmc> mgsloan, it doesn't directly help the world and it's not interesting to most people
17:51:14 <copumpkin> ion: nah
17:51:25 <mgsloan> me too, I'd spend a few million dollars in /such/ good ways
17:51:36 <mgsloan> kmc - I think it can help the world a lot
17:51:39 <ion> HELLO SIR, I AM MR. JOHN HASKELL OF THE HASKELL COMPANY, INC. AND I HAVE A LUCRATIVE OFFER FOR YOU.
17:52:06 <kmc> mgsloan, only if you can solve the problem of convincing people to actually use your fancy whiz-bang languages
17:52:17 <mgsloan> working on it :)
17:53:02 <NemesisD> when declaring a type synonym with type, is there anyway to put a typeclass constraint in that?
17:53:10 <Peaker> Luke: Sure, I think they've got built-in user state, and you can of course StateT transform them
17:53:35 <mgsloan> only mostly kidding.. Anyway,  I think improving the way computation is represented, allowing for 'better' information transformation, can improve the world quite a lot
17:53:41 <mantovani> there a function to count the number of chars in a string ?
17:53:47 <mantovani> like a "words" ?
17:53:53 <kmc> > length "yes mantovani"
17:53:55 <lambdabot>   13
17:53:55 <tkahn6> length
17:54:00 <mantovani> thank you very much
17:54:08 <kmc> String = [Char] so you can use all list functions with String
17:54:25 * mantovani doing real world haskell exercices
17:54:43 <mantovani> exercises*
17:59:27 <cgroza> Why wxHaskell shows only the first letter in the Strings I give to the button and infoDialog??
17:59:34 <cgroza> I really don't get it.
18:00:19 <rwbarton> probably an encoding issue
18:00:38 <mm_freak> ok, i found my bottleneck
18:00:49 <rwbarton> I heard something changed about wxWidgets string encoding in a recent version
18:01:01 <mm_freak> realToFrac :: GLdouble -> GLdouble   -- has overhead and quite a bit of it
18:01:30 <cgroza> mm_freak: so what can I do?
18:01:55 <cgroza> mm_freak: bassically my prog is this:   bt <- button f [text := "Print", on command := (mapM_ (infoDialog f "Args") =<< getArgs) ]
18:02:02 <mm_freak> passing GLdoubles through realToFrac increases the computation time by a factor of 40
18:02:06 <mm_freak> that's quite huge
18:02:28 <mm_freak> cgroza: uhm…  i don't know, why are you asking me directly?
18:02:38 <Guest87507> cgroza:  i think you meant rwbarton
18:03:46 <cgroza> mm_freak: Guest38558: oops
18:04:04 <rwbarton> try using an older wxWidgets or fixing the bindings
18:04:42 <mantovani> or you can send an email to the binding dev :P
18:04:57 <cgroza> rwbarton: thanks, but I am just learning so does not worth it.
18:05:14 <rwbarton> someone here encountered a similar problem, but I forget who
18:05:15 <cgroza> mantovani: I will try to contact him.
18:05:20 <mdx1> In some POV, it may be a valid learning experience D:
18:05:29 <cgroza> Does anyone else use wxHaskell here?
18:05:42 <Axman6> people seem to prefer gtk
18:06:05 <slack1256> gtkHs uses gtk2 or gtk3?
18:07:19 <slack1256> it uses gtk2. sorry to ask.
18:08:56 <cgroza> slack1256: gtk2 probably...
18:09:11 <mm_freak> the OpenGL library should define GLdouble, GLfloat, etc. as type aliases, not newtypes
18:09:48 <mm_freak> i'm having some performance problems with GLdouble
18:10:00 <mm_freak> even though it's only a newtype for CDouble under the hood
18:10:17 <cgroza> Gtk2Hs is more uglier than wxHaskell. Moe code because of the packs...
18:10:31 <Axman6> use overloaded strings
18:11:14 <slack1256> cgroza: you seem to know both libraries. i haven't studied never any GUI library nor made one
18:11:31 <slack1256> cgroza: which is the most friction free way to do gui on haskell?
18:11:52 <cgroza> slack1256: on haskell? i just started gui on haskell...
18:12:12 <mm_freak> slack1256: the two main GUI packages are gtk2hs and wx
18:12:16 <cgroza> so I can't share my personal experience.
18:12:26 <mm_freak> wx has a nicer interface, but gtk2hs has more features
18:12:39 <mm_freak> also wx is on hackage, gtk2hs isn't
18:12:42 <slack1256> there is also the gloss package
18:12:54 <mm_freak> gloss is not for GUIs, but for graphics rendering
18:13:03 <slack1256> which is a nice opengl-glut framework
18:13:14 <mm_freak> yeah, it's nice for simple applications
18:13:29 <cgroza> mm_freak: well 90% of WX is ported... all this because it uses wxc...
18:13:58 * slack1256 if only Qt had a C interface
18:15:03 <cgroza> a frame with 2 buttons takes 13 lines in Gtk2Hs. I have made it in wxHaskell in 6 lines.
18:16:05 <slack1256> but by you, which of the 2 is most clear? (consider complete newbie here)
18:16:19 <mm_freak> well, UIs get really funny with FRP…  i was planning to make an FRP interface to wx using netwire, but i guess i will first explore FRP-based text UIs
18:16:36 <cgroza> What's a FRP?
18:16:44 <mm_freak> cgroza: functional reactive programming
18:16:47 <slack1256> reactive-banana has a wx backend
18:16:54 <slack1256> well is the only backend it has
18:17:07 <cgroza> mm_freak: nice.
18:17:49 <mm_freak> slack1256: yeah, i looked at that one, but somehow i dislike monadic FRP
18:18:10 <slack1256> there is another kind of FRP?
18:18:19 <mm_freak> sure, arrowized FRP
18:18:23 <mm_freak> yampa, animas, netwire
18:18:29 <slack1256> afterall FPR is all about incremental computations -> monads
18:18:41 <mdx1> FRP has any relationship with event driven model?
18:19:08 <mantovani> guys, if haskell is typed strong and static
18:19:08 <mm_freak> monadic FRP always seemed like a hack to me…  AFRP is clean and fast
18:19:20 <slack1256> which is the most popular of those 3 mm_freak?
18:19:24 <mm_freak> mdx1: events are used in FRP, but in a different way
18:19:48 <mm_freak> slack1256: yampa is the most popular, though nobody seems to use it
18:20:03 <mdx1> hmmm
18:20:03 <slack1256> oh the irony...
18:20:03 <mm_freak> animas is an attempt to get around the shortcomings of yampa…  it's a fork
18:20:08 <slack1256> xD
18:20:09 <mm_freak> and netwire is my own library =)
18:20:27 <slack1256> then tell us to use that one!
18:20:36 <slack1256> geez have some EGO
18:21:04 <mm_freak> if i were to judge, i'd say that netwire is the most useful, but also the most experimental library
18:21:11 <mm_freak> if you like experimental stuff, go with netwire
18:24:01 <mantovani> I can't do metaprogramming using haskell ?
18:24:29 <mm_freak> slack1256: if you want to try it out, have a look at the even more experimental web framework webwire:  http://www.mail-archive.com/haskell-cafe@haskell.org/msg93237.html
18:24:33 <ion> mantovani: http://mywiki.wooledge.org/XyProblem
18:24:47 <slack1256> mantovani: in plain haskell you don't, but if you use Template Haskell you can
18:24:48 <mauke> mantovani: what's a metaprogramming?
18:25:19 <shachaf> I never metaprogram I didn't like.
18:25:29 <slack1256> mm_freak: reading
18:25:42 <mm_freak> slack1256: i'm also developing an SDL/OpenGL framework (right now), which is not online, and as said, i want to explore AFRP-based UI programming, which is planned for the near future
18:25:48 <mantovani> http://en.wikipedia.org/wiki/Metaprogramming
18:25:52 <mantovani> slack1256: ^
18:26:02 <mantovani> ops
18:26:04 <mantovani> mauke: ^
18:26:15 <mantovani> thank you slack1256
18:26:18 <mauke> mantovani: that article is wrong
18:26:26 <mauke> Template Haskell isn't template metaprogramming
18:26:37 <mantovani> humm
18:27:49 * mantovani learning a lot of programming concepts with haskell
18:28:04 <slack1256> mm_freak: if you announce it on the #haskell-cafe i will check it out.
18:28:09 <mauke> eh, the article doesn't even define what it's talking about
18:28:32 <mauke> main = putStrLn "2 + 2"  -- metaprogramming!
18:28:45 <slack1256> mm_freak: first i have to learn a lot about FPR, and perfect myself on arrows. but i would like to help on it
18:29:19 <slack1256> > putStrLn "2 + 2"
18:29:20 <lambdabot>   <IO ()>
18:29:27 <slack1256> no metaprogramming in there
18:29:46 <Philippa> unless "2 + 2" happens to be a program
18:29:49 <mantovani> ion: it doen't mean xy problem
18:29:51 <mantovani> :P
18:29:51 <Philippa> which is does in many languages
18:29:52 <mauke> slack1256: why not?
18:30:13 <mm_freak> slack1256: what helped me to understand arrows very well was to implement the automaton arrow myself:  newtype Automaton a b = Automaton (a -> (b, Automaton a b))
18:30:14 <slack1256> mauke: because it prints the string "2 + 2"
18:30:24 <ion> main = do privmsg freenode "lambdabot" "> 2 + 2"; print =<< readIO =<< receivePrivmsg freenode "lambdabot"
18:30:26 <mauke> slack1256: ... yes?
18:30:40 <mm_freak> slack1256: an automaton is simply a self-mutating function
18:30:51 <Philippa> slack1256: you'll get the snark sooner or later, don't worry
18:30:54 <mm_freak> it returns an output value and a new version of itself
18:31:03 <slack1256> mantovani: "http://www.haskell.org/haskellwiki/Template_Haskell" check out the eval function
18:31:27 <mantovani> ion: I don't want x or y because I don't want solve anything
18:31:40 <mantovani> I just want to know if it is possible
18:31:42 <mm_freak> slack1256: and once you've understood the Automaton arrow you've really also understood AFRP =)
18:31:47 <mantovani> thank you very mych slack1256
18:32:01 <JoeyA> Can a .cabal file's Description field have a code sample in it?
18:32:02 <mauke> mantovani: main = putStrLn "main = putStrLn \"hello, world\""
18:32:05 <mauke> ^ metaprogramming
18:32:10 <Philippa> mantovani: most meaningful senses of metaprogramming can be done - but not all at runtime
18:32:29 <Philippa> mauke: be less of an arsehole now?
18:32:55 <Philippa> there *are* meaningful senses of the term that aren't covered by obvious stuff like the above, or even the embedding tricks we get up to all the time
18:33:09 <Philippa> staging ala TH would be one
18:33:29 <mauke> maybe, but that's not what wikipedia says
18:33:51 <Philippa> and wikipedia is, of course, the fount of all bullshit. Wait, I mean knowledge...
18:33:52 <geheimdienst> mantovani: i think it would help if you could tell us more about what you want to do with metaprogramming. what problem are you trying to solve, for which you think you need metaprogramming?
18:33:53 <slack1256> mm_freak: i don't complete get the automaton, but i think i understand it's intention
18:33:58 <mauke> and I don't see why static types would cause problems
18:34:02 <ski> Peaker : yes, I/O errors in `getContents'/`hGetContents' ought not to end the list with `[]', but with the error/exception it raised
18:34:15 <mantovani> geheimdienst: I don't want anything, I'm just studyng haskell
18:34:19 <mauke> Philippa: no, but when I asked what mantovani meant, they pointed me there
18:34:22 <JoeyA> Yes, .cabal files can have code in the description, using bird tracks ( > ).  I just needed an extra space-dot after preceding text.
18:34:22 <mantovani> I started today
18:34:31 <mantovani> :)
18:34:46 <Philippa> and in fact: the definition on wikipedia's fine
18:34:52 <mantovani> because I read right now haskell type are strong and static
18:35:04 <mm_freak> slack1256: here is a counter automaton:  countFrom :: Int -> Automaton a Int; countFrom x = Automaton $ \_ -> (x, countFrom (succ x))
18:35:06 <mantovani> so you can't do metaprogramming in compiling time
18:35:21 <mantovani> ops
18:35:21 <mauke> mantovani: how does that follow?
18:35:23 <mantovani> in runtime
18:35:30 <Peaker> ski: pure exceptions are also evil...
18:35:33 <mm_freak> slack1256: countFrom 10 will return 10 and a version of itself, which returns 11
18:35:34 <mantovani> you can't do metaprogramming in run time
18:35:39 <mauke> mantovani: why not?
18:35:45 <mm_freak> slack1256: that new version returns 11 and a version of itself, which returns 12
18:35:48 <mm_freak> etc.
18:35:49 <mantovani> because the compiler have to check the types in the compiler time
18:35:50 <Philippa> mantovani means something slightly more specific
18:35:51 <mantovani> ?
18:35:52 <mauke> mantovani: also, "strong typing" doesn't mean anything
18:36:09 <Philippa> mantovani: read up on "staging". "run time" isn't as strong a concept as you might think
18:36:24 <mantovani> mauke: if the compiler check the types at the compiler time
18:36:24 <slack1256> mm_freak: yes that function is clear. i understand what it does.
18:36:31 <mantovani> how can you generete code after it ?
18:36:33 <Philippa> (that said: you're right in the absence of whatever the current replacement for hs-plugins is, for lisp macro-style metaprogramming)
18:36:37 <mantovani> Philippa: humm
18:36:39 <mauke> mantovani: ... easily?
18:36:40 <slack1256> mm_freak: but don't understand how it returns a value
18:37:06 <mauke> Philippa: but lisp-style macros don't happen at runtime either, do they?
18:37:09 <Philippa> mauke: mantovani really means /reflective/ metaprogramming
18:37:18 <Philippa> mauke: depends on the lisp
18:37:21 <mantovani> Philippa: introspection and reflextion
18:37:22 <slack1256> mm_freak: neverming i get how it can return a value
18:37:24 <mauke> oh, fun
18:37:38 <Philippa> mantovani: introspection is a form of reflection, but yeah
18:37:49 <slack1256> mm_freak: that cool, this step can change the function of the next one
18:37:56 <mauke> Data.Data?
18:38:18 <mm_freak> slack1256: imagine a loop calling that function…  it always keeps the latest version of the function
18:38:18 <Philippa> for introspection you need to've provided yourself the means at compile-time. To build new code that can't be built from higher-order functions at runtime you're stuck, yes
18:38:30 <mm_freak> slack1256: now what arrows give you is composition of automatons
18:38:51 <Philippa> (at least, in the absence of having the ability to compile and link at runtime: I'm out of date on what current libs exist for that, but it certainly /has/ existed)
18:38:57 <slack1256> mm_freak: aaaa, now i get it
18:39:16 <slack1256> mm_freak: so your are telling me that arrow are just automatons + composition
18:39:33 <mm_freak> arrows are just composition
18:39:44 <mm_freak> in the case of the Automaton arrow it's automaton composition
18:39:46 <slack1256> mm_freak: and that automatons are the one like your example, functions that change the function of the next call
18:39:57 <mm_freak> exactly
18:39:58 <ski> Peaker : it's better than `[]', anyway
18:40:15 <mm_freak> now in AFRP you usually add a time delta:  newtype SF a b = SF { getSF :: Double -> a -> (b, SF a b) }
18:40:29 <mm_freak> the Double is just the time difference in seconds to the last instance
18:40:31 <slack1256> kind of makes sense.
18:40:42 <mm_freak> that's the basic idea of AFRP
18:41:33 <Philippa> mauke: most people who talk about metaprogramming mean reflection, FWIW - you can't /prevent/ metaprogramming modulo some thin encoding in a turing complete language anyway
18:41:43 <mm_freak> currentTimeFrom t' = SF $ \dt _ -> let t = t' + dt in (t, currentTimeFrom t)
18:41:45 <slack1256> yeah, i think i see the relationship between behavior (on Gui) and this composition of automators
18:41:49 <ski> mantovani : it's possible to type-check staged code so that at run-time only type-correct code can ever be generated. this is what MetaML/MetaOCaml does
18:41:53 <mauke> meh, I can generate machine code at runtime and call it from haskell
18:41:56 <mm_freak> that automaton returns the current time in seconds
18:41:57 <mauke> that's pretty meta
18:42:05 * slack1256 needs to copy paste this on a file
18:42:14 <Philippa> sure
18:42:45 <ski> Philippa : i've read some paper on RTCG (Run-Time Code Generation) ..
18:42:49 <Philippa> even so, most people /mean/ reflection in some sense (if not necessarily at runtime) most of the time
18:42:54 <Peaker> ski: I tried presenting how easy concurrency is in Haskell to people, and had a thread with getContents, and another thread async-killing it after threadDelay to implement timeout... it of course did not work, because the thread was done immediately (it did getContents)
18:42:55 <mantovani> ski: humm, thank you
18:42:56 <mm_freak> slack1256: try to write Category and Arrow instances for Automaton and/or SF…  it's really easy
18:43:22 <Peaker> ski: which kind of ruined the "it's so easy" presentation of mine :-P
18:44:17 <ski> Peaker : you did this before or during the presentation ?
18:44:33 <Peaker> ski: well, it was just a one-off thing during ordinary conversation, not something official
18:44:40 <Peaker> ski: I didn't prepare anything
18:44:51 <slack1256> mm_freak: seems to be a good exercise
18:44:51 <Peaker> I just noted yet another way to get bitten by god-damn-lazy-i/o :)
18:45:14 <slack1256> good bye fine gentlemans of #haskell, may the lambdas be with you.
18:45:18 <slack1256> good night
18:45:34 <slack1256> mm_freak: thanks, now i have some new goal.
18:45:38 <ski> Peaker :(
18:45:47 <mm_freak> slack1256: have fun =)
18:46:15 <Peaker> ski: I think Haskell the language has so much unrealized potential because of Haskell the libraries..
18:49:13 <Nafai> Peaker: That's the main reason I keep using Python
18:49:23 <Nafai> Oh, and I can find a job doing it.
18:52:26 <ski> Peaker : anyway, it seems to me what you really wanted there was something that spawned a thread reading the file eagerly
18:53:01 <ski> (i.e. using `getContents' in that situation was a mistake, you wanted something else)
18:53:15 <Peaker> ski: yeah that's what I ended up changing to -- but fighting such silliness is not a good thing to show people (or to fight in real code, either)
18:54:07 <ski> i don't see it as fighting
18:54:27 <ski> if you want lazy I/O, use `getContents', if you don't want it, don't use it (use something else)
18:55:19 <ski> but possibly there should also be easy ways to read off a file strictly, with comparable non-clutter
18:57:10 <ski> (hm .. maybe one could do something that starts reading eagerly, but blocks after `n' characters until someone starts forcing the list ?)
18:58:42 <monochrom> that's almost hGetContents in practice, when combined with buffering
18:59:13 <Peaker> ski: well, the problem is that the default/simple way to do stuff, or at least, the obvious names, were given to lazy I/O
18:59:19 <monochrom> if you force the 1st char of the string, the underneath reads n chars immediately
18:59:34 <Peaker> ski: so if I just want to demonstrate something and not worry about it -- I may end up using lazy I/O as a default
18:59:56 <monochrom> the next read happens when you force the n+1st char
19:00:54 <ski> Peaker : "don't do that then ?" ;) but, yeah, i feel your pain
19:01:58 * ski still thinks easy ways to do non-lazy I/O would alleviate most of the problem
19:22:53 <mantovani> how to convert Io::String to String ?
19:23:10 <mauke> what's Io::String?
19:23:19 <mauke> if you mean the perl module, it's IO::String
19:23:25 <mantovani> :info readFile
19:23:38 <mauke> mantovani: if you mean IO String, you can't
19:23:50 <mauke> mantovani: you can't convert IO String to IO either
19:23:51 <mantovani> humm
19:24:01 <shachaf> > show getContents -- WRONG
19:24:02 <lambdabot>   "<IO [Char]>"
19:24:07 <mantovani> lines (readFile "/home/mantovani/foo.txt")
19:24:09 <mantovani> :'(
19:24:28 <shachaf> do { file <- readFile "foo"; ... lines foo ... }
19:24:30 <mauke> mantovani: readFile "..." >>= \s -> ... (lines s)
19:24:43 <shachaf> do { x <- fmap lines (readFile "foo"); ... }
19:24:52 <mantovani> thank you guys
19:24:57 <mauke> liftM!
19:25:06 <shachaf> Sigh, OK.
19:25:15 <mantovani> mauke: are perl dev ?
19:25:16 <shachaf> do { x <- liftM (fmap lines) readFile "foo"; ... }
19:25:17 <shachaf> Happy?
19:25:22 <mantovani> are you perl dev*?
19:25:26 <mauke> mantovani: yes
19:25:32 <mantovani> I'm too
19:25:47 <mauke> mantovani: do you know javascript?
19:25:52 <mantovani> yes
19:25:57 <mauke> good
19:26:05 <mauke> shachaf: I see what you did there
19:26:10 <mantovani> mauke: why ?
19:26:14 <shachaf> Haskell is to burritos as JavaScript is to the cloud.
19:26:20 * Clint squints.
19:26:33 <mauke> mantovani: because I think Haskell's IO system is similar to XMLHttpRequest in javascript
19:26:38 <mauke> and setTimeout
19:27:02 <shachaf> In the sense that you use CPS for both, yes.
19:27:18 <mauke> it's all about the callbacks, baby
19:27:28 <mauke> shachaf: I raise you a filterM (return [True, False])
19:27:38 <mantovani> shachaf: burritos = donkey ?
19:27:41 * mantovani speak portuguese
19:27:46 <shachaf> Uh-oh.
19:27:48 <mantovani> :S
19:27:55 <shachaf> mantovani: It was a joke; never mind.
19:28:04 <RaptorRarr> > filterM (return [True, False]) "zomg"
19:28:04 <lambdabot>   ["zomg","zom","zog","zo","zmg","zm","zg","z","omg","om","og","o","mg","m","...
19:28:23 <mantovani> spanish and portuguese is very similar
19:30:06 <RaptorRarr> Isn't Portugal a province of Spain or something?
19:30:16 <mauke> haha, no
19:30:25 <mantovani> lol, no
19:30:26 <mauke> isn't the US a province of Canada or something?
19:30:33 <Pseudonym> I don't even know which street the US is on.
19:30:38 <RaptorRarr> No, Canada is a province of the US.
19:30:43 <mantovani> lol
19:30:49 <mauke> nah, Canada is much bigger
19:30:58 <RaptorRarr> Everyone in America has heard of Spain, not so many have heard of Portugal.
19:31:09 <shachaf> RaptorRarr: Huh? Who hasn't heard of Portugal?
19:31:13 <RaptorRarr> Same thing with America and Canada.
19:31:16 <ski> @wiki Introduction to IO
19:31:16 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
19:31:20 <ski> monochrom : read that ^
19:31:24 <mantovani> is because they don't go to the school RaptorRarr ?
19:31:24 <ski> argh
19:31:28 <mantovani> :S
19:31:29 <ski> mantovani : read that ^
19:31:36 <Pseudonym> RaptorRarr, these are the same people who think that everyone apart from Columbus thought the Earth was flat.
19:31:48 * ski thinks monochrom has read that a long time ago ..
19:31:58 <RaptorRarr> mantovani: No, it's, unfortunately, because they do go to school.
19:32:00 * mantovani reading
19:32:24 <RaptorRarr> mantovani: The literacy rate of people who go to school here is not too good.
19:32:50 <mantovani> RaptorRarr: they do about spain because they learn spanish
19:33:11 <mauke> you mean mexican?
19:33:31 <mantovani> I don't thintok they like mexicans :P
19:33:37 <mantovani> this is why they learn spain
19:33:38 <mantovani> hahaha
19:33:42 <mantovani> think*
19:33:58 <RaptorRarr> mantovani: Yeah.
19:34:00 <RaptorRarr> http://en.wikipedia.org/wiki/Functional_illiteracy
19:34:01 <Pseudonym> mauke: Apologies for an ignorant antipodean question, but is this meant in the same sense that the French don't believe that Canadians speak French?
19:34:06 <monochrom> ski: I read that a long time ago. but I want to convert IO String to IO. :)
19:34:30 <ski> monochrom : how would that work ?
19:34:53 <monochrom> I don't know. but it was a parody. :)
19:34:56 <mauke> Pseudonym: no, just that I'd imagine the main contact of an american with spanish would be mexicans
19:34:59 <RaptorRarr> "All over the U.S.A. 30 million (14% of adults) are unable to perform simple and everyday literacy activities."
19:35:11 <mantovani> perl has perldoc -f "function" to know about some function
19:35:16 <mantovani> I'm searching in the google
19:35:21 <nyingen> @arr
19:35:21 <lambdabot> Har de har har!
19:35:21 <mantovani> and I didn't find something like in haskell
19:35:26 <mauke> Pseudonym: and the funny internet quotes of people who don't realize that the language spoken in mexico is spanish
19:35:31 <mantovani> like haskdoc "function"
19:35:43 <mauke> mantovani: http://www.haskell.org/hoogle/
19:35:46 <Pseudonym> mauke: Or Puerto Ricans, or Dominicans, or Cubans...
19:35:50 <RaptorRarr> mantovani: You can try hoogle :)
19:36:00 <mantovani> I found it, but don't have nothing in the command line?
19:36:08 <nyingen> anyone know if/how I can define a C helper function inside a hsc2hs binding?
19:36:08 * monochrom speaks United Statianish
19:36:35 <nyingen> I tried #def but it causes linking problems
19:36:36 <shachaf> monochrom: I thought you spoke Canadianish/Chinaish/something.
19:36:40 <mauke> mantovani: "The Hoogle manual contains more details, including further details on search queries, how to install Hoogle as a command line application"
19:37:20 <RaptorRarr> Yeah, lambdabot has hoogle installed that way, I think.
19:37:29 <RaptorRarr> @hoogle Int -> [a] -> a
19:37:30 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:37:30 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:37:30 <lambdabot> Prelude drop :: Int -> [a] -> [a]
19:37:49 <mantovani> thank you
19:39:58 <mauke> preflex: remember <parcs> i cowrote that.  and by that i mean i read it
19:45:26 --- topic: '["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin/spam issues: #haskell-ops"]'
19:45:26 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Sep 03 10:10:12 2011]
19:47:00 <copumpkin> by the way, that transpose problem
19:47:02 <copumpkin> :t M.unionsWith M.union . M.elems . M.mapWithKey (fmap . M.singleton)
19:47:03 <lambdabot> forall k a k1. (Ord k, Ord k1) => M.Map k (M.Map k1 a) -> M.Map k1 (M.Map k a)
19:51:11 <ski> > (M.unionsWith M.union . M.elems . M.mapWithKey (fmap . M.singleton)) (M.fromList [((),M.fromList [])])
19:51:13 <lambdabot>   fromList []
19:53:25 <parcs> :t const M.empty :: (Ord k, Ord k1) => M.Map k (M.Map k1 a) -> M.Map k1 (M.Map k a)
19:53:25 <lambdabot> forall k k1 a. (Ord k1, Ord k) => M.Map k (M.Map k1 a) -> M.Map k1 (M.Map k a)
19:54:11 <copumpkin> why thank you
19:54:49 <parcs> any time :)
19:54:53 <ski> > (M.unionsWith M.union . M.elems . M.mapWithKey (fmap . M.singleton)) (M.fromList [((),M.fromList [((),())])])
19:54:54 <lambdabot>   fromList [((),fromList [((),())])]
19:55:02 * hackagebot simple-actors 0.1.0 - A library for more structured concurrent programming, based  on the Actor Model  http://hackage.haskell.org/package/simple-actors-0.1.0 (BrandonSimmons)
19:56:25 * ski imagines writing that map as `[map| \() -> [map| \() -> () |] |]'
19:58:33 <cwl> route :: MonadSnap m => [(ByteString, m a)] -> m a
19:58:47 <cwl> type ApiHandler a = ReaderT ChatRoom Snap a
19:59:22 <cwl> testApi :: Key -> ApiHandler ()
19:59:28 <copumpkin> ski: what do you think of that?
19:59:46 <cwl> let testKey key = route [("join", testApi key)]
19:59:57 <cwl> why is the last legal
20:00:22 <cwl> ApiHandler is MonadSnap
20:01:05 <parcs> why wouldn't it be legal
20:01:29 <cwl> parcs: ApiHandler is not MonadSnap
20:01:58 <parcs> are you sure?
20:02:03 <joevandyk> any ideas on why i get this error? https://gist.github.com/1277171
20:02:14 <cwl> parcs: yup
20:02:16 <parcs> maybe there's a MonadSnap instance for MonadSnap m => ReaderT r m
20:02:19 <joevandyk> my understanding is that args should be a String
20:02:24 <joevandyk> err, a [String]
20:02:40 <cwl> parcs: type ApiHandler a = ReaderT ChatRoom Snap a
20:02:46 <parcs> lol
20:02:53 <cwl> ?
20:03:06 <rwbarton> joevandyk: need parens around the argument to error
20:03:09 <rwbarton> or a $
20:03:17 <geheimdienst> joevandyk: try parens around the line with print
20:03:19 <parcs> cwl: http://hackage.haskell.org/packages/archive/snap-core/0.5.4/doc/html/Snap-Types.html#t:MonadSnap
20:03:27 <parcs> scroll down and look at the instancen
20:03:34 <joevandyk> ah.  what was it trying to do?
20:03:38 <parcs> "MonadSnap m => MonadSnap (ReaderT r m)"
20:03:52 <parcs> your ApiHandler conforms to this type, thus it si a MonadSnap
20:03:58 <geheimdienst> joevandyk: oh wait, sorry
20:04:00 <Veinor> it was trying to do maybe ((error "CAN'T FIND") ++ name ++ "IN ENV")
20:04:47 <joevandyk> thanks
20:04:52 <joevandyk> is there a better way to write that program?
20:05:07 <cwl> parcs: ah...
20:05:11 <joevandyk> https://gist.github.com/1277171 is what i have now
20:05:12 <cwl> parcs: get it
20:06:02 <elliott> joevandyk: s/error/fail/
20:06:03 <parcs> cwl: it looks like the sn@p guys were nice enough to provide some generic instances :)
20:06:26 <cwl> parcs: yes :-)
20:06:44 <joevandyk> elliott: "Fail is referring to the "fail" function, which is part of the Monad typeclass and is almost universally despised."
20:06:48 <geheimdienst> joevandyk: looks good to me. be aware that head is a little dirty, because it won't give you any good error message
20:07:02 <elliott> joevandyk: you use it every time you do <-
20:07:04 <joevandyk> geheimdienst: right
20:07:22 <elliott> joevandyk: it should be in its own typeclass yes
20:07:33 <elliott> joevandyk: but it is not itself evil
20:07:36 <joevandyk> geheimdienst: so if i'm expecting there to be at least one element in args, what should i do?
20:07:45 <elliott> and that use of error is imho a misuse
20:07:55 <elliott> joevandyk: x:_ <- getArgs
20:08:09 <elliott> (uses fail when getArgs returns [])
20:08:52 <geheimdienst> joevandyk: what elliott said will at least give you the line number where the problem occurred, so that's an improvement over head
20:08:52 <joevandyk> elliott: hm, i get this: read.hs: user error (Pattern match failure in do expression at /Users/joevandyk/tmp/read.hs:6:3-8)
20:08:56 <joevandyk> yeah
20:09:18 <elliott> use case + fail if you want a nice message
20:11:14 <joevandyk> why does ghci report [Char] instead of String?
20:11:53 <dmwit> ?src String
20:11:53 <lambdabot> type String = [Char]
20:12:04 <dmwit> They are the same.
20:12:12 <joevandyk> yes, so why not use String? :)
20:12:52 <dmwit> joevandyk: If I also write type Foo a = [a], and FooString = Foo Char, which of [Char], String, Foo Char, and FooString should it choose?
20:13:51 <rwbarton> "why does ghci report String instead of [Char]?"
20:13:54 <parcs> joevandyk: it sometimes does use the relevant type synonym
20:13:59 <rwbarton> this is the question we'd get if it used the other one
20:14:02 <dmwit> rwbarton: Exactly.
20:14:23 <dmwit> I was waiting for him to admit that none of the above choices was really canonical, then restrict it to only two choices. =P
20:14:26 <parcs> joevandyk: it largely depends on the context of the type error
20:17:04 <mantovani> good night
20:17:06 <mantovani> &
20:21:31 <ski> copumpkin : it looks nice
20:21:46 <ski> elliott : `<-' to an irrefutable pattern doesn't use `fail'
20:22:55 <ski> .. imo, it should only expand synonyms (at least for display purposes when it needs to
20:24:05 <ski> so `reverse "foo"' should get type `[Char]', but `reverse (words "foo bar")' should get type `[String]'
20:24:20 <ski> s/when/) when/
20:48:06 <bos> preflex: seen edwardk
20:48:07 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
20:48:07 <preflex>  edwardk was last seen on #haskell-blah 1 day, 19 hours, 1 minute and 41 seconds ago, saying: night all
20:50:14 * MatrixFrog is trying to use the "probability monad" from lyah to solve a project euler problem
20:50:31 <MatrixFrog> (http://projecteuler.net/problem=205)
20:52:06 <MatrixFrog> ok. if i have x=(1, a+b)
20:52:18 <MatrixFrog> the addition of a+b won't actually be performed unless i need the value right?
20:52:27 <MatrixFrog> like if i said snd x or show x
20:52:33 <mzero> only the later
20:52:41 <mauke> snd x doesn't need the value
20:52:43 <mzero> snd x still won't perform the addition
20:52:53 <MatrixFrog> (well, snd x, and then i actually did something with that value)
20:53:24 <mzero> depends on what you did with it!  :-)
20:53:38 <joevandyk> what's the best way to interface with postgresql?
20:53:40 <MatrixFrog> right. thanks
20:53:48 <mzero> so      y = if and x > 7 then "bob" else "amy"    would cause it to be evaluated
20:54:00 <mzero> er s/and/snd/
20:54:23 <mzero> but   y = (and x, "yada")   would not!
20:54:32 <mzero> er s/and/snd/   again
20:54:39 <MatrixFrog> right. i suspect my solution is technically correct but it's running out of memory
20:54:51 <MatrixFrog> and i think it's largely because i'm building up a big string of additions
20:54:56 <MatrixFrog> possibly
20:55:21 <MatrixFrog> i should just hpaste it but i want to try and get a little further on my own first...
20:55:27 <mzero> k
20:55:34 <mzero> we'll be here when you need us!  :-)
20:58:23 <MatrixFrog> if you think of Functor as being "something that can be mapped over", is there a typeclass that means "something that can be filtered" in some sense?
20:58:52 <mauke> Foldable is probably too general
21:00:02 <elliott> MatrixFrog: what fits that and not foldable?
21:00:51 <MatrixFrog> i haven't really used the Foldable class, i'll look at it
21:01:01 <MatrixFrog> but actually now that i think about it, Prob shouldn't be filterable anyway
21:18:26 <MatrixFrog> yay i solved it!
21:20:03 * hackagebot asn1-data 0.6.0 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.6.0 (VincentHanquez)
21:25:38 <hpaste_> MatrixFrog pasted “Project Euler 205” at http://hpaste.org/52449
21:26:04 <MatrixFrog> as soon as i pasted that, i realized the 'reduce' in the last line is redundant
21:26:26 <MatrixFrog> anyway if anyone is curious, that's how i solved it
21:29:11 <JoeyA> Whose fault is it that mathematicians chose to say f(x) instead of (x)f for function application?
21:29:43 <JoeyA> I have a time machine.  I need to know whether I should learn how to yell at people in German or English.
21:29:52 <mauke> aw, cute
21:30:03 * hackagebot certificate 0.9.2 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.9.2 (VincentHanquez)
21:30:06 <mauke> it's probably at least the greeks, if not earlier
21:30:24 <MatrixFrog> i assume you like (x)f better because then the type signature "a -> b" would look like you're putting an 'a' in on the left, and getting a 'b' out on the right?
21:30:52 <JoeyA> The annoying thing about f(x) is that function applications are written in reverse of their execution.
21:31:04 <MatrixFrog> maybe we should just start writing type signatures as "b <- a" instead. wait no, that won't make anything easier at all...
21:31:05 <JoeyA> (though that's not entirely true in Haskell, to be pedantic)
21:31:13 <mauke> JoeyA: or at all
21:31:30 <mauke> haskell does do f first
21:31:35 <JoeyA> right
21:31:54 <joevandyk> how do i connect to a postgresql database with haskelldb?
21:31:56 <joevandyk> do people use haskelldb?
21:32:07 <MatrixFrog> f(g(x)) would become ((x)f)g or something?
21:32:11 <MatrixFrog> no
21:32:17 <MatrixFrog> ((x)g)f
21:32:30 <MatrixFrog> take x, then apply g to it, then apply f to the result
21:32:33 <MatrixFrog> you're right, that's way better
21:32:35 <JoeyA> When you say blimp (\f x -> f x) $ groupBy ((==) `on` head) $ sort
21:32:47 <mauke> preflex: calc ((1)sin)cos
21:32:47 <preflex>  0.6663667453928805
21:33:08 <JoeyA> err, stick xs at the end
21:33:14 <MatrixFrog> is "blimp" a haskell thing?
21:33:19 <JoeyA> I have to read it right to left: "sort xs, then group it by heads, then blimp it.
21:33:27 <mauke> JoeyA: >>>
21:33:29 <JoeyA> I just made it up.
21:33:32 <JoeyA> I don't know what it would do.
21:33:34 <MatrixFrog> right, gotcha
21:33:50 <MatrixFrog> it would fill its argument with helium and watch it fly around slowly
21:33:54 <JoeyA> There would also be blimpWith, along with blimp1..blimp10
21:34:01 <JoeyA> Sort of like zip, but more confusing.
21:34:01 <MatrixFrog> blimpM
21:34:04 <MatrixFrog> blimpM_
21:34:06 <JoeyA> yup
21:34:19 <mauke> and blimp0 would be called florp for no reason
21:34:26 <MatrixFrog> not for "no reason"
21:34:30 <MatrixFrog> for "historical reasons"
21:34:39 <elliott> what's blimp her
21:34:39 <elliott> e
21:34:53 <MatrixFrog> it's just something JoeyA made up
21:35:03 * hackagebot certificate 0.9.3 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.9.3 (VincentHanquez)
21:35:05 * hackagebot tls 0.8.0 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.8.0 (VincentHanquez)
21:35:49 <JoeyA> Ooh, a major version!
21:36:14 <JoeyA> Does tls support generating certificates yet?
21:36:21 <JoeyA> Or should I wait a few more minutes?  :-)
21:36:38 <joevandyk> when people use haskell with postgresql, do they generally build up the sql strings themselves?
21:36:49 <JoeyA> (I'm planning to use the tls package, so the updates are appreciated)
21:41:27 <joevandyk> i've been searching for at least 20 minutes, can't find an example of connecting to postgresql with haskelldb :(
21:42:59 <MatrixFrog> joevandyk i think "persistent" is commonly used but i'm not sure
21:43:14 <joevandyk> i'm looking at this:
21:43:15 <joevandyk> http://hackage.haskell.org/packages/archive/haskelldb-hdbc-postgresql/2.1.0/doc/html/Database-HaskellDB-HDBC-PostgreSQL.html
21:43:40 <joevandyk> but still not sure how to use the postgresqlConnect function
21:44:17 <JoeyA> Note that, last time I checked, HDBC PostgreSQL doesn't have a provision for sending BYTEAs in binary mode.
21:44:42 <JoeyA> So to work with BYTEAs correctly, you would have to write an escaping function, I think.
21:45:02 <DanBurton> maybe try their mailing list? haskelldb-users[AT] lists [DOT] sourceforge [DOT] net
21:47:21 <elliott> JoeyA: i don't think haskelldb is tha tcommonly used any more but i could be wrong
21:48:21 <joevandyk> with ruby, i really like http://sequel.rubyforge.org/rdoc/files/doc/dataset_basics_rdoc.html -- it represents queries as objects.
21:48:40 <joevandyk> similar to arel: https://github.com/rails/arel
21:48:40 <elliott> I think persistent does stuff like that.
21:48:42 <elliott> that's what yesod uses
21:50:22 <joevandyk> elliott: i'll look at it.
21:51:12 <espringe> \x y -> x y
21:51:32 <espringe> > \x y -> x y
21:51:33 <lambdabot>   Overlapping instances for GHC.Show.Show ((t -> t1) -> t -> t1)
21:51:33 <lambdabot>    arising f...
21:51:44 <tab> JoeyA: yes, it can generate certificate
21:52:12 <espringe> > \x y -> x y
21:52:13 <lambdabot>   Overlapping instances for GHC.Show.Show ((t -> t1) -> t -> t1)
21:52:13 <lambdabot>    arising f...
21:52:28 <tab> JoeyA: although that's a very manual and hands-on process at the moment
21:53:05 <mzero> > let f = \x y -> x y in  f reverse "hello"
21:53:06 <lambdabot>   "olleh"
21:53:28 <mzero> @src ($)
21:53:29 <lambdabot> f $ x = f x
21:53:55 <mzero> > ($) reverse "hello"
21:53:56 <lambdabot>   "olleh"
21:54:08 <JoeyA> tab: Okay, thanks.
21:54:36 <mzero> olleh, espringe -- that sort of what you were looking for?
21:54:57 <elliott> aka id
21:55:09 <espringe> mzero, was trying to get that convert-to-point-free thing to work. But I realized i should just install the package and do it locally :D
21:55:31 <mzero> @pl \x y -> x y
21:55:31 <lambdabot> id
21:55:52 <mzero> espringe: or just /msg lambdabot privately
21:56:05 <espringe> mzero: oh cool, thanks
21:56:18 <shachaf> /msg lambdabot privately
22:03:54 <Veinor> sometimes I wish (++) was actually <>
22:04:25 <shachaf> @ty (<>)
22:04:26 <lambdabot> Doc -> Doc -> Doc
22:04:33 <Veinor> mappend
22:04:33 <shachaf> Veinor: That?
22:04:38 <shachaf> @ty (++) -- Tada!
22:04:39 <lambdabot> forall m. (Monoid m) => m -> m -> m
22:04:48 <shachaf> See also: Haskell 1.4
22:04:50 <Veinor> :P
22:05:03 * hackagebot tls-extra 0.4.0 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.4.0 (VincentHanquez)
22:05:16 <Veinor> i think (<>) = mappend is being re-added soon
22:05:28 <Axman6> > Just "hello" ++ Just "oooo"
22:05:30 <lambdabot>   Just "hellooooo"
22:05:36 <shachaf> What sort of weird syntax is <>?
22:08:32 --- mode: gibson.freenode.net set +o Igloo
22:08:32 --- mode: gibson.freenode.net set +o ChanServ
22:08:49 <mzero> > let  fibby = ap (flip if' 1 . (1 ==)) . ap (*) . (. subtract 1)  in fibby 7
22:08:49 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
22:08:49 <lambdabot>    arising from a use of `...
22:09:42 <mzero> > let  f = ap (flip if' 1 . (1 ==)) . ap (*) . (. subtract 1)  in f 7
22:09:45 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
22:09:45 <lambdabot>    arising from a use of `...
22:09:50 <shachaf> > fix (ap (flip if' 1 . (1 ==)) . ap (*) . (. subtract 1)) 5
22:09:52 <lambdabot>   120
22:10:01 <shachaf> espringe: This is a horrible abuse of @pl, though.
22:10:04 <mzero> ah  -- so @pl failed us?
22:10:13 <shachaf> mzero: No -- it did exactly what it was told.
22:10:32 <shachaf> espringe: Really, you're not qualified to abuse @pl that badly until you're capable of @pling that function by hand. :-)
22:10:39 <mzero> oh - ha ha ha
22:11:07 <espringe> Even if i do define if', I still can't get my ghci to accept it:
22:11:07 <espringe> Prelude> :t \ap (flip if' 1 . (1 ==)) . ap (*) . (. subtract 1)
22:11:07 <espringe> <interactive>:1:6: Parse error in pattern: flip
22:11:09 <mzero> missed that
22:11:18 <shachaf> espringe: That's because that's invalid syntax.
22:11:21 <shachaf> What's that \ doing there?
22:11:40 <shachaf> espringe: It's probably a good idea to spend a while getting used to Haskell syntax before embarking on wild @pl adventures. :-)
22:12:31 <mzero> what shachaf  said
22:13:19 <shachaf> What mzero said.
22:13:48 <espringe> (04:17:38 PM) shachaf: What's that \ doing there?
22:13:48 <espringe> What do you mean by that?
22:14:01 <espringe> It works fine with something simple
22:14:07 <shachaf> What business does that \ have at the beginning of that line?
22:14:10 <mzero> when you typed :t \ap .... you made ap be a parameter in a lambda
22:14:23 <mzero> but ap was a function @pl was applying
22:14:23 <shachaf> Not even that, since there was no arrow.
22:14:27 <shachaf> It's just invalid syntax.
22:14:35 <espringe> Ohh, i see
22:14:40 <espringe> I thought ap was actually a param
22:14:45 <espringe> Thanks, that makes sense
22:14:51 <elliott> shachaf: Well, not if you had your way.
22:14:56 <elliott> That thing would even type.
22:15:19 <mzero> espringe: @pl takes a lambda, with parameters, and returns you an expression, not a lambda, that is equivalent
22:15:37 <shachaf> elliott: So it would!
22:15:47 <shachaf> See? My way makes invalid programs typecheck!
22:15:51 <shachaf> That has to count for -- something, right?
22:16:10 * mzero resists urge to make Dart joke.... 
22:16:17 <mzero> d'oh!
22:16:44 <elliott> shachaf: No no no: you're _reducing errors_.
22:17:19 <shachaf> @ty foldr error -- Reducing errors?
22:17:20 <lambdabot> forall b. b -> [[Char]] -> b
22:17:34 <elliott> Wow, that's a useful function.
22:17:37 <elliott> @ty foldl error
22:17:38 <lambdabot> forall b. [Char] -> [b] -> [Char]
22:17:44 <elliott> Even usefuller.
22:17:58 <shachaf> @ty foldl1' error -- Usefullest.
22:17:59 <lambdabot> [[Char]] -> [Char]
22:18:19 <shachaf> @check \xs -> foldl1' error xs == concat xs
22:18:19 <lambdabot>   "*Exception: Prelude.foldl1': empty list
22:18:20 <shachaf> Curses.
22:18:28 <shachaf> So close.
22:20:07 <elliott> @ty mapAccumL error
22:20:08 <lambdabot> forall x y. [Char] -> [x] -> ([Char], [y])
22:20:11 <elliott> shachaf: I think I win.
22:20:53 <shachaf> @yhjulwwiefzojcbxybbruweejw
22:20:53 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
22:21:13 <elliott> I wonder if anyone has ever invoked that by accident.
22:21:19 <shachaf> I just did.
22:21:25 <shachaf> Random keypresses, that was.
22:21:40 <shachaf> > fix error
22:21:41 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
22:22:03 <elliott> shachaf: That fixed your error.
22:22:08 <shachaf> Yep.
22:22:35 <shachaf> > let endomorphism = show in fix endomorphism
22:22:36 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
22:24:10 <elliott> > let it = id; don't f _ = error (f "oops"); ain't = const True; broke = (); i = return; guess = () in if it ain't broke then don't fix it else do i guess
22:24:11 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
22:24:11 <lambdabot>         against inferred ty...
22:24:20 <elliott> :-(
22:24:29 <elliott> Literate Haskell: a failed attempt.
22:25:50 <Axman6> so close
22:26:05 <shachaf> elliott: You can't fix "oops".
22:26:14 <elliott> Aha.
22:26:20 <elliott> > let it = id; don't f _ = error (f ("oops " ++)); ain't = const True; broke = (); i = return; guess = () in if it ain't broke then don't fix it else do i guess
22:26:21 <lambdabot>   No instance for (GHC.Show.Show (m ()))
22:26:21 <lambdabot>    arising from a use of `M365434355...
22:26:25 <elliott> Oh please.
22:26:30 <elliott> > let it = id; don't f _ = error (f ("oops " ++)); ain't = const True; broke = (); i = Just; guess = () in if it ain't broke then don't fix it else do i guess
22:26:31 <lambdabot>   *Exception: oops oops oops oops oops oops oops oops oops oops oops oops oop...
22:26:35 <elliott> Yessssssss.
22:26:58 * shachaf imagines elliott, siting back, basking in the glory of his creation.
22:27:05 <elliott> Wouldn't you?
22:27:09 <shachaf> s/ti/tti/
22:27:12 <shachaf> Of course.
22:27:37 <JoeyA> Isn't there a way to do pattern matching in a list comprehension, such that if the pattern match fails, the item isn't included?
22:27:48 <JoeyA> > [x | m <- [Just 3, Just 5, Nothing, Just 7], let (Just x) = m]
22:27:49 <lambdabot>   [3,5,*Exception: <interactive>:3:49-60: Irrefutable pattern failed for patt...
22:27:50 <shachaf> JoeyA: The default way.
22:28:04 <elliott> JoeyA: > [x | Just x <- [Just 3, Just 5, Nothing, Just 7]]
22:28:05 <JoeyA> > [x | Just x <- [Just 3, Just 5, Nothing, Just 7]]
22:28:06 <lambdabot>   [3,5,7]
22:28:06 <shachaf> > [x | Just x <- [Just 3, Just 5, Nothing, Just 7]]
22:28:07 <lambdabot>   [3,5,7]
22:28:11 <elliott> Ha, I was first.
22:28:13 <JoeyA> ah, forgot about that.  Thanks
22:28:21 <shachaf> elliott: You didn't even talk to lambdabot.
22:28:29 <shachaf> It don't count if the bot don't hear it.
22:28:29 <elliott> shachaf: I deliver a more personal experience.
22:28:36 <elliott> The bot heard it.
22:28:38 <elliott> It just didn't react.
22:28:39 <JoeyA>   [3,5,7]
22:28:44 <JoeyA> Sorry, I'm slow.
22:28:50 <JoeyA> lambdabot: > 2+2
22:28:52 <elliott> Thanks JoeyA.
22:29:26 <Axman6> > catMaybes [Just 3, Just 5, Nothing, Just 7]
22:29:27 <lambdabot>   [3,5,7]
22:29:29 <Axman6> >_>
22:29:32 <shachaf> @src catMaybes
22:29:32 <lambdabot> catMaybes ls = [x | Just x <- ls]
22:29:33 <elliott> shachaf: Stop abusing your incredibly legitimate admin rights.
22:43:02 <JoeyA> If applying a difference list, is it good form to add a redundant application to make it explicit?
22:43:05 <JoeyA> e.g. foldl' f id list $ []
22:43:16 <JoeyA> rather than foldl' f id list []
22:45:09 <gaze__> hey, is there any way to make a list of things that have different types?
22:46:12 <gaze__> would generics be used here perhaps? I have control over the types.
22:46:30 <JoeyA> gaze__: The simplest thing would be to put the types in an algebraic type.
22:46:39 <JoeyA> e.g. data Value = VInt Int | VBool Bool | ...
22:46:42 <JoeyA> and have [Value]
22:46:54 <JoeyA> gaze__: But you can also use existential types.
22:47:25 <JoeyA> e.g. data Value = forall a. Show a => Value a (iirc)
22:47:49 <gaze__> yeah, say I don't want to enumerate out all the types somewhere.
22:48:05 <JoeyA> This means a Value contains a value of *some* type, as long as it has a Show instance.
22:49:34 <JoeyA> gaze__: It's similar to polymorphism in OO.
22:49:53 <Jafet> JoeyA: neither looks more explicit
22:50:05 <JoeyA> (namely, the idea of being able to store a list of items of different types in a list)
22:50:11 <gaze__> actually, that's exactly what I was looking for
22:50:13 <mzero> JoeyA: I wouldn't put in the $
22:50:25 <gaze__> I just want to make a list of stuff that supports show.
22:50:49 <mzero> gaze__: is that because you intend to show them? if so - apply show and make it a list of String
22:50:59 <mzero> remember - the show won't really happen until you use 'em
22:51:03 <JoeyA> gaze__: That's exactly what existential types can do.
22:51:08 <Jafet> gaze: heterogeneous lists are usually a worse alternative to something else
22:51:56 <gaze__> actually... nope... not what I want... I have to pass this thing later to something that will be typed to accept the "specific" type.
22:52:01 <mzero> There is no reason to have  [forall a. Show a => a]   if all you're going to do is later pick one or more and show 'em
22:52:09 <mzero> just apply show when you build the list ---
22:52:23 <mzero> costs you nothing (almost), and keeps everything simple
22:52:50 <gaze__> yeah... this isn't terribly simple... I knew that was too simple a solution
22:52:51 <mzero> gaze__: I don't understand what that means....
22:53:14 <mzero> perhaps you should hpastebin what you've got
22:53:58 <gaze__> okay... this is for a transaction system. I have a pile of "datas" (?) that are gonna get hacked up by a function, but they're all file backed, so a journal has to be updated along with them
22:54:33 <gaze__> and I'm serializing them with show
22:55:03 <bos> anyone used data-lens around here?
22:56:11 <mzero> gaze__: so each function on some data produces a tuple: (updated data, serailizable journal thingy)
22:56:41 <mzero> where later, something else is going to serialize the journal thingy by applying show to it?
22:57:21 <mzero> and you need to gather up all those serializeable journal thingies -- and later, perhaps, show 'em and stow 'em?
22:57:33 <mzero> is that about right?
22:57:33 <gaze__> something like that.
22:57:56 <mzero> then I'd say just apply show when you do your functions and return the tuple  (updated data, String)
22:58:11 <mzero> because that show isn't going to be applied until you actually, later decide to stow 'em
22:58:17 <mzero> (yay laziness!)
22:58:49 <bos> holy cow, data-lens is magic
22:58:51 <mzero> s/isn't going to be applied/isn't going to be computed/
22:59:09 <mzero> that's a strong endorsement coming from a wizard like box!
22:59:21 <quicksilver> bos: I haven't used it, but I've read the docs and recommended it to others, does that count? :)
22:59:27 <mzero> er, bos! (silly Mac OS X spelling corrector)
22:59:36 <shachaf> bos: Which part of it is magic?
22:59:37 <quicksilver> when I say "read the docs" I mean "browsed the types" of course
22:59:39 <bos> :-)
22:59:42 <quicksilver> edwardk doesn't do docs.
22:59:56 <bos> shachaf: it's very elegant and simple
23:00:12 <gaze__> this is gonna lead to some really funny syntax... All of the transactional stuff I want to happen in a DSL. Okay... let's forget all the transactional stuff... let's say I want to learn about generics
23:00:14 <shachaf> More than lenses in general?
23:00:33 <quicksilver> shachaf: just lenses done right, really
23:00:43 <quicksilver> some of the other attempts have been.... not so right.
23:01:00 <shachaf> Like data-accessors?
23:01:27 <shachaf> I read that you had to use undefined to get a getter, or something along those lines.
23:04:04 <tab> quicksilver: shouldn't you get all the doc you need from types anyway in a perfect world ? :)
23:05:10 <quicksilver> tab: with a library like data-lens, actually, you do get almost eveyrthing you want from the type
23:05:34 <quicksilver> but some comments on useful common approachs etc would be nice :)
23:06:04 <mzero> I wonder why Data.Lens bothers to be defined interns of Store -- seems overkill for what it is doing
23:06:21 <mzero> seems like one could implement that module more directly
23:06:24 <shachaf> mzero: Would you prefer a tuple?
23:06:53 <mzero> sure, that *is* what Store sort of is in the end, no?
23:07:03 <shachaf> Right, except with more specific types.
23:08:35 <mzero> and it doesn't seem to get any benefit of being a Semigroupoid (which seems to impart no particular utility functions) -- and the Category implementation would be straightforward enough
23:11:06 <quicksilver> mzero: can't the "why bother" argument be turned around the other way?
23:11:21 <quicksilver> "why bother" reimplementing it when it can just use Store.
23:11:38 <quicksilver> data-lens was broken out of category-extras for wider use.
23:11:40 <mzero> because for me to use Data.Lens I need to pull in about half a dozen packages I don't otherwise use
23:12:07 <quicksilver> that's not a problem unless something about those packages makes work for you
23:12:28 <mzero> adding them to my cabal file and getting all the version numbers right?  :-)
23:12:33 <mike-burns> Packages are great. I love pulling them in.
23:19:58 <MatrixFrog> i wonder if you guys saw this question: http://programmers.stackexchange.com/questions/113576/is-hungarian-notation-a-workaround-for-languages-with-insufficiently-expressive
23:21:23 <sbrg> MatrixFrog: well, IMO, yes.
23:21:32 <Nafai> MatrixFrog: I've thought the same thing, especially after reading an article linked in one of those answers: http://www.joelonsoftware.com/articles/Wrong.html
23:21:52 <Nafai> MatrixFrog: Why stop at making things *look* wrong when you can have a type system where *are* wrong.
23:21:57 <shachaf> Yep.
23:22:06 <shachaf> That Wrong.html article is aptly named.
23:22:50 <shachaf> «Somebody, somewhere, read Simonyi’s paper, where he used the word “type,” and thought he meant type, like class, like in a type system, like the type checking that the compiler does. He did not. He explained very carefully exactly what he meant by the word “type,” but it didn’t help. The damage was done.»
23:23:36 <sbrg> However you look at it, it is basically a fact that hungarian notation exists(existed) to make it easier for programmers to know the types of variables without having to scroll all the way up and find it in the beginning of some function(or beginning of the file if it was global) and so on
23:23:53 <sbrg> One can argue that in a way IDEs have removed the need for programmers to use it
23:24:03 <sbrg> But I for one have always found it ridiculously ugly
23:24:33 <MatrixFrog> but i think the point of that stackexchange question is that most programmers in most languages don't use the type system to indicate what a variable MEANS
23:24:40 <sbrg> and that using variable names that are named after what they're being used for instead of what they are makes more sense
23:24:47 <shachaf> Sometimes something vaugely similar to hungarian notation is used just to avoid naming conflicts.
23:27:59 <Nafai> I once interned at a company that primarily did Windows development, and try as they might, my mentors could never give me a justifiable reason Hungarian notation was useable
23:28:04 <Nafai> er, useful.
23:28:15 <Nafai> The only reason I used it was for code consistency.
23:28:33 <MatrixFrog> Nafai what language were you using mostly?
23:28:42 <davo> hi all. i'm using ghci, with a .hs file loaded. the .hs file contains a 'main' module which contains 'print' statements. is it possible to get the print statements to display in the ghc interactive ?
23:28:56 <MatrixFrog> davo: just type "main" at the ghci prompt
23:28:58 <shachaf> davo: :main (or just main)
23:30:10 <davo> ah great. that's it, it worked. thank you
23:30:37 <Nafai> MatrixFrog: C++
23:31:29 <MatrixFrog> oh the other thing i wanted to say wrt types and hungarian notation, was that i think it would be POSSIBLE to have 'x' and 'y' be different types, in Java or C++ or whatever
23:31:38 <MatrixFrog> it would just be wordy and ugly and not idiomatic
23:34:05 <MatrixFrog> a zillion tiny inner classes :(
