00:20:26 <Blkt> good morning everyone
00:21:35 <kmc> hi Blkt
00:35:06 <Blkt> hi kmc
00:35:47 <freeasjesus> RIP Jobs :(
00:36:56 <rostayob> yeah the internet is an obituary right now
00:37:11 <rostayob> too much
00:38:01 <freeasjesus> rostayob: well too be fair, he's the greatest guy in tech since bill gates
00:38:06 <freeasjesus> it directly relates to the internet
00:38:20 <rostayob> whatever, this is #haskell anyway
00:39:26 <freeasjesus> >:(
00:54:52 <rostayob> mhm... why is it that ForeignPtr can't be used in imported functions?
00:54:58 <rostayob> i mean FFI imports
00:56:17 <kmc> because it's not a raw pointer
00:56:32 <kmc> it's a pointer tracked by the garbage collector, with finalizers attached
00:57:16 <rostayob> yep but it's simply a matter of doing withFooreignPtr function
00:57:35 <rostayob> anyway, fair enough
00:57:36 <kmc> yeah, it might be a reasonable extension to allow them in argument position
00:57:43 <kmc> not in return position
00:58:09 <rostayob> yeah exactly
00:58:13 <rostayob> it's kind of annoying
00:58:23 <rostayob> if you have 70 functions
00:58:30 <kmc> yeah
00:58:32 <shachaf> Is the FFI import syntax just a bunch of magic ad hoc patterns that it recognizes to generate a Haskell function?
00:58:43 <kmc> the core FFI explicitly does not try to be clever
00:58:53 <kmc> and leaves higher-level marshalling up to libraries and extra tools
00:59:00 <kmc> shachaf, how do you mean
00:59:02 <rostayob> shachaf: no I meant the other way around, calling C from haskell
00:59:34 <rostayob> anyway there isn't much magic apart from setting up the runtime things
00:59:40 <shachaf> foreign import ... :: A -> B -> C
00:59:41 <rostayob> it just accepts basic C types
00:59:45 <rostayob> ah yes that
00:59:53 <shachaf> It takes boxed values, for instance, and "curries" the C function.
01:00:05 <kmc> yeah, it's somewhat ad-hoc
01:00:12 <rostayob> that's true
01:00:24 <shachaf> If I newtype Foo = Foo Int, will it recognize Foo?
01:00:25 <rostayob> i didn't think about the currying
01:00:25 <kmc> there's an explicit enumeration of Haskell types and their correspondence to C scalar types
01:00:30 <rostayob> shachaf: no
01:00:30 <shachaf> Ah.
01:00:37 <kmc> shachaf, no, but GHC allows newtypes of IO as a special extension
01:00:38 <kmc> iirc
01:01:02 <rostayob> an extension for ForeignPtrs would be really appreciated as well
01:01:12 <kmc> it might be clearer to take unboxed types but a) they're annoying, b) they're not in Haskell
01:03:34 <shachaf> I'd expect the basic FFI to be something lower-level.
01:03:53 <shachaf> But I guess this works well enough for most things you'd want to do, and I'll admit that it's much more convenient.
01:04:01 <rostayob> shachaf: wait what boxed types are we talking about?
01:04:11 <rostayob> aren't ints and chars already unboxed?
01:04:13 <kmc> currying vs not currying is kind of arbitrary
01:04:24 <kmc> no, an Int in GHC is a boxed heap-allocated value
01:04:33 <kmc> (you can't use Char directly with the FFI)
01:04:50 <rostayob> yeah, I meant CChar
01:05:09 <rostayob> data Int = I# Int#
01:05:20 <kmc> yeah
01:05:26 <rostayob> aren't primitive types unboxed?
01:05:30 <rostayob> ah but data Int
01:05:32 <rostayob> that's what boxes it
01:05:35 <kmc> right
01:05:37 <kmc> Int# is unboxed
01:05:40 <rostayob> yeah
01:05:43 <kmc> unboxed types are annoying to work with
01:05:47 <kmc> they aren't first-class
01:05:52 <kmc> you can't use them with polymorphic functions or data
01:06:04 <rostayob> yep yep i remember all that it makes sense now
01:06:14 <kmc> so the desire for (+) :: Int -> Int -> Int,  or xs :: [Int], guarantees that Int is (semantically) boxed
01:06:19 <kmc> of course it's nice when GHC can optimize that out
01:06:40 <kmc> also unboxed types aren't in Haskell, and the FFI is
01:07:09 <rostayob> also it really can't be too hard to just unbox those
01:07:22 <rostayob> shachaf: what advantage were you thinking about with having just unboxed types in the FFI?
01:07:28 <kmc> well what if you pass that xs to length :: [a] -> Int
01:07:43 <shachaf> rostayob: It would just seem to correspond more closely to C, that's all.
01:07:52 <kmc> by the way, GHC does allow you to use the unboxed types instead
01:07:56 <rostayob> kmc: no I mean in the case of FFI imported functions
01:07:56 <kmc> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html#ffi-ghcexts
01:08:10 <shachaf> Boxed values are difficult to understand, but the trick is to realize that they're a lot like monads.
01:08:17 <rostayob> shachaf: ahahahaha
01:08:19 <kmc> *thumbs down*
01:08:28 <rostayob> that's genius
01:08:36 <kmc> oh hmm "The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum)"
01:08:41 <kmc> so i was wrong before
01:08:46 <engla> shachaf: did you mean to say burritos?
01:08:54 <shachaf> engla: No.
01:09:00 <rostayob> kmc: oh, i had no idea as well
01:15:51 <simon> GHC doesn't detect that I installed Parsec through cabal. various other packages seem to work.
01:16:22 <simon> simon ~$ find .ghc -iname '*parsec*'
01:16:23 <simon> .ghc/i386-linux-7.0.3/package.conf.d/parsec-3.1.1-2c865593139c5f6458072364965b72ff.conf
01:16:50 <kmc> simon, ghc-pkg list parsec
01:17:14 <simon> /usr/lib/ghc-7.0.3/package.conf.d
01:17:14 <simon> /home/simon/.ghc/i386-linux-7.0.3/package.conf.d
01:17:14 <simon>    parsec-3.1.1
01:17:55 <simon> trying to compile my program:
01:17:55 <simon>     Could not find module `Parsec':
01:17:56 <simon>       Use -v to see a list of the files searched for.
01:19:02 <applicative> it should be Text.Parsec or something
01:19:26 <simon> ah!! I just mindlessly copy things from a tutorial.
01:20:01 <simon> thanks. :)
01:20:29 <kmc> yeah, there are some very old tutorials on parsec
01:20:32 <kmc> i bet a lot of things will not work :/
01:20:41 <kmc> i don't know the best up-to-date resource
01:20:46 <kmc> i think even RWH is on Parsec 2, not 3
01:20:52 <applicative> simon, there can be other trouble with some of the tutorials , from the Parsec 2 -> Parsec 3 switch.  Maybe you should use "Text.ParserCombinators.Parsec"
01:21:59 <applicative> which exports something closer to the old String based interface.
01:22:32 <kmc> oh, it does?
01:22:33 <kmc> cool
01:22:42 <kmc> i thought those were just aliases for the same modules
01:22:59 <applicative> they are, it's just the String instance of all of them so to say
01:23:33 <applicative> I was going to add that since the fundamental types are more abstract {-#LANGUAGE NoMonomorphismRestriction #-} is frequently useful with the old tutorials.
01:23:53 <kmc> aha
01:23:57 <kmc> frequently useful always!
01:24:35 <applicative> yeah, but my experience (and that of parsec tutorial readers who come on here) is that Parsec 3 really makes it necessary
01:31:32 <jpcooper> hello
01:31:40 <jpcooper> how can I see what a file with template haskell code expands to?
01:33:03 <phr> how much ram do i need to run ghc?
01:34:02 <applicative> you would want anything else using your ram would you?
01:34:24 <applicative> or rather , you wouldn't want anything else using it
01:34:30 <phr> not much
01:35:37 <phr> and, can i run the fedora package in centos 5?
01:36:25 <erus`> phr i needed 1 gig to build snap
01:36:30 <phr> zomg
01:36:35 <erus`> any less and it wouldnt go
01:36:46 <phr> ok, cross compiling it is :O
01:37:17 <phr> the fedora haskell-platform pkg only has a 64 bit binary, no 32 bit
01:38:13 <phr> how much ram do you need to run snap after it's built?
01:38:48 <shachaf> jpcooper: Probably -ddump-something, depending on what you want to see.
01:39:24 <shachaf> jpcooper: I don't know if you can get actual pretty-printed Haskell syntax; maybe, though.
01:40:29 <shachaf> jpcooper: Aha, -ddump-splices, maybe?
01:41:46 <applicative> "The flag -ddump-splices shows the expansion of all top-level splices as they happen."
01:42:28 <shachaf> kmc: Did you end up releasing your sh-style quasiquoter?
01:44:11 <shachaf> I wish Cabal could build profiling and non-profiling libraries in parallel.
01:45:59 <kmc> shachaf, no, it's stalled because I discovered that the 'process' library has broken Unicode handling which could have security consequences
01:46:17 <kmc> it seems that process-1.1 is okay, so I may just convince myself of that and then release with that depe
01:46:19 <kmc> dependency*
01:46:42 <shachaf> Wait, it uses the process library?
01:46:47 * shachaf must have forgotten what it does.
01:47:03 <kmc> it executes shell commands
01:47:08 <shachaf> Oh. Right.
01:47:13 <kmc> with interpolated haskell variables
01:47:20 <shachaf> I remembered the interpolated variables part.
01:47:23 <dcoutts> shachaf: I wish it built anything in parallel :-)
01:47:33 <kmc> shachaf, I think we've been over this about 3 times
01:47:54 <shachaf> dcoutts: Right, but some things are harder than others. Profiling and non-profiling libraries are completely independent, I'd think.
01:48:02 <shachaf> kmc: Yep.
01:48:10 <quicksilver> edwardk: data-lens could really do with a short tutorial-style intro
01:48:16 <quicksilver> edwardk: just an example of its use, really
01:48:27 <edwardk> quicksilver: sounds good. let me know when its written up ;)
01:48:28 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
01:48:37 <shachaf> Dim memories are returning to me. It does sh-style single-quote quoting because it passes strings to sh.
01:48:46 <applicative> @quote haddock
01:48:46 <lambdabot> edwardk says: i have a lot fewer [haddock problems] now since i stopped bothering trying to document ;)
01:48:48 <dcoutts> shachaf: except when one is using template Haskell, then you have to build the vanilla before building the profiling versions (since ghc can only load the non-profiling)
01:48:49 <shachaf> What's broken about process?
01:48:57 <edwardk> preflex: xseen dylukes
01:48:57 <preflex>  dylukes was last seen on freenode/#haskell-blah 8 hours, 52 minutes and 4 seconds ago, saying: djahandarie: I guess this was this years 'One More Thing'?
01:49:02 <shachaf> dcoutts: Oh. Bah.
01:49:09 <edwardk> applicative: =P
01:49:10 <kmc> awkward
01:50:00 <kmc> > text [chr (256 + ord '\'')]
01:50:01 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
01:50:19 <kmc> bah anyway it's ħ
01:50:27 <kmc> process-1.0 interprets characters mod 256
01:50:44 <kmc> so you can smuggle a character like ħ past the quoting
01:50:52 <shachaf> Ah.
01:51:05 <kmc> maybe i ought to email libraries@haskell.org about this problem
01:52:14 * hackagebot simpleprelude 1.0.0.3 - A simplified Haskell prelude for teaching  http://hackage.haskell.org/package/simpleprelude-1.0.0.3 (JeanMarieGaillourdet)
01:54:24 <applicative> wow, getting rid of all the number types except Integer is indeed a simplification
01:56:07 <kmc> ah http://hackage.haskell.org/trac/ghc/ticket/4006 and http://hackage.haskell.org/trac/ghc/ticket/1414
01:57:08 <kmc> shachaf, so I guess I will just release it with a process-1.1 dependency
01:57:40 <shachaf> OK.
01:57:51 * shachaf was only going to use it to test quasiquoting.
01:57:59 <kmc> test what?
01:58:26 <shachaf> jpcooper asked a question about -- oh, I guess there was no quasiquoting involved after all.
01:58:31 * shachaf got carried away.
01:58:44 <kmc> :/
02:00:08 <shachaf> kmc: You were hoping that your library would have an actual user? :-)
02:00:47 <kmc> in my wildest dreams ;)
02:02:14 <wavewave> sad to hear that steve passed away..
02:02:14 <lambdabot> wavewave: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:06:59 <wavewave> oh lambdabot can deliver messages.. I just knew it.
02:07:09 <hpaste_> kmc pasted “Depth monad” at http://hpaste.org/52230
02:07:19 <kmc> what do y'all think of my monad
02:08:53 <wavewave> kmc: what is it for? record how far I calculated it?
02:09:21 <kmc> yeah, counting function nesting
02:09:44 <rahul> I have a list of maybes, which I concat and then map with some function.
02:09:58 <rahul> Using catMaybes and then map.
02:10:04 <rahul> Is there a shorter way to do this?
02:10:20 <kmc> not that i know
02:10:21 <rahul> [Maybe a] -> (a -> b) -> [b]
02:10:21 <shachaf> rahul: What's wrong with catMaybes and then map? It seems to express what you want exactly.
02:10:34 <wavewave> mapMaybe?
02:11:08 <shachaf> mapMaybe goes in the other direction, I think.
02:11:20 <kmc> :t mapMaybe
02:11:21 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
02:11:33 <kmc> @src mapMaybe
02:11:34 <lambdabot> Source not found. I am sorry.
02:11:37 <wavewave> you can use some composite function inside argument.
02:11:42 <kmc> mapMaybe f = catMaybes . map f
02:11:56 <wavewave> f . (fmap id )
02:12:19 <wavewave> wait ...
02:12:20 <kmc> f . (fmap id) ≡ f . id ≡ f
02:12:36 <wavewave> starting from [Maybe a]
02:12:53 <wavewave> I misunderstood the problem
02:12:54 <rahul> map f $ catMaybes
02:13:08 <rahul> kmc: ^ this is what i am doing.
02:13:18 <wavewave> rahul: sounds compact and descriptive enough
02:13:22 <kmc> i think that'd be «map f . catMaybes»
02:13:34 <rahul> shachaf: nothing wrong, really. just wondering if there is a shorter way.
02:13:42 <rahul> kmc: oh yeah, sorry.
02:14:00 <shachaf> Composition isn't a bad thing, you know. :-)
02:14:15 <shachaf> Is that operation common enough to deserve its own name?
02:14:41 <wavewave> if you hit it several times, just make a function and use it.
02:15:08 <kmc> eh, even if you use it all over the place, it's not necessarily good to define f_of_g = f . g
02:15:10 <wavewave> anyway other functions like catMaybes are also such renamed function after all.
02:15:13 <kmc> (f . g) is a better name for that
02:15:13 <rahul> shachaf, wavewave: okay. :)
02:15:40 <shachaf> kmc: fogohoi might make sense to define.
02:15:47 <rahul> kmc: I was wondering if there was a general function which covered this use case.
02:15:56 <tdammers> if it's (f . g . h . i . j . k), then a shorter name may be better though...
02:16:25 <shachaf> rahul: [f x | Just x <- l]
02:16:34 <kmc> hm that's good
02:16:47 <rahul> shachaf: Hmm, that's nice.
02:17:22 <applicative> you still have to catMaybe it though?
02:17:43 <applicative> no, I see
02:18:06 <wavewave> I am a little confused.. how is Nothing treated there?
02:18:19 <tdammers> Just x does not match Nothing
02:18:51 <rahul> > [x * 2 | Just x <- [Just 2, Just 3, Nothing]]
02:18:52 <lambdabot>   [4,6]
02:19:02 <applicative> it's perfect
02:19:10 <wavewave> tdammers: why didn't it give an error? pattern not exhausted.
02:19:17 <kmc> pattern match failure in a list comprehension drops that element
02:19:17 <wavewave> hmm..
02:19:28 <tkahn6> that's kind of hacky
02:19:32 <tkahn6> imo...
02:19:34 <wavewave> Ah... I see.
02:19:36 <kmc> it's the same as the behavior of 'fail' for lists
02:19:40 <kmc> it's kind of hacky
02:19:46 <kmc> but it's probably the most useful aspect of list comprehensions
02:19:48 <wavewave> basically []
02:20:04 <tkahn6> interesting
02:20:13 <kmc> most list comprehensions that don't use that property are nicer to write without comprehension syntax
02:20:17 <wavewave> failure is []
02:20:42 <wavewave> and it always concats things so no problem. okay... I got it.
02:21:00 <shachaf> kmc: But.... "I think dropping filter() and map() is pretty uncontroversial; filter(P, S) is almost always written clearer as [x for x in S if P(x)]"!
02:21:10 <shachaf> s/\.//
02:21:36 <wavewave>  l >>= \(Just x) -> f x
02:21:44 <shachaf> wavewave: Not the same thing.
02:21:48 <wavewave> unfortunately this is impossible.
02:21:49 <shachaf> @undo [x | Just x <- y]
02:21:50 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) y
02:22:14 <wavewave> shachaf: I see.
02:22:33 <wavewave> pattern matching in <- has some default implicitly...
02:22:54 <wavewave> pattern matching in do notation/list comprehension
02:22:58 <shachaf> Yes.
02:23:29 <wavewave> shachaf: for generic monad, it's simply "fail"?
02:23:35 <shachaf> Yep.
02:24:59 <wavewave> Until now, I never used pattern matching in <-  .. Now I am happy that I learned it
02:25:52 <metatagg> Hi! :)
02:26:06 <shachaf> metatagg: Ahoy!
02:26:22 <wavewave> mathematically does Monad have to have "fail" by the way?
02:26:30 <Botje> no
02:27:07 <shachaf> Depends on what you mean by "mathematically". "monad" as used in mathematics doesn't. :-)
02:27:09 <Botje> you can translate pat <- action to foo <- action; case action of pat -> ...
02:27:23 <metatagg> i wonder about data types
02:27:30 <metatagg> im rather new to haskell
02:27:36 <metatagg> so...
02:27:42 <Botje> avoid the purple ones.
02:27:47 <wavewave> shachaf: I mean the standard textbook math..
02:28:26 <metatagg> if you make a 'data Person = Chef | Employee'
02:28:54 <metatagg> can you figure out which of either Chef or Employee has been used?
02:29:05 <metatagg> :S
02:29:07 <opqdonut> yes
02:29:10 <metatagg> how? :D
02:29:11 <wavewave> metatagg: case ?
02:29:17 <opqdonut> with pattern matching
02:29:21 <metatagg> oh
02:29:26 <opqdonut> e.g. case
02:29:27 <metatagg> i'll paste something
02:29:31 <wavewave> case x of Chef -> ... ; Employee -> ...
02:29:36 <metatagg> aha! :)
02:29:49 <metatagg> thanks a lot! :)
02:29:58 <applicative> salary Chef = 100; salary Employee = 300
02:30:35 <wavewave> metatagg: or as applicative said, you can use Pattern matching directly in function definition.
02:30:56 <wavewave> left-hand side of function definition is nothing but a pattern matching.
02:32:52 <metatagg> right!
02:32:58 <metatagg> i'm trying it out now.
02:33:24 <metatagg> having a bit of a hard time to get the grip of a 'value constructor' vs. a 'type constructor'
02:33:45 <kmc> data TypeConstructor = ValueConstructor Field
02:33:56 <kmc> Haskell makes a strong syntactic distinction between expressions and types
02:34:04 <kmc> value constructors appear in expressions; type constructors appear in types
02:34:24 <shachaf> Says kmc right after giving a "data" declaration...
02:34:36 <applicative> the type constructors are just the names of the types themselves.  they only appear in signatures.
02:34:36 <wavewave> Value constructor is Value : Type constructor is Type
02:34:50 <donri> isn't TypeConstructor there a concrete type
02:34:54 <metatagg> ah
02:35:00 <metatagg> so far i'm with you
02:35:11 <wavewave> Value constructor is a function (thoush special)
02:35:11 <donri> wouldn't you need paramters to make a constructor
02:35:21 <kmc> you could say that
02:35:26 <shachaf> donri: Is Nothing a data constructor?
02:35:29 <kmc> but it's awkward that there's no term for "type or type constructor"
02:35:35 <tkahn6> metatagg: check this out. Tree a = Tree a (Tree a) (Tree a) | Leaf
02:35:38 <applicative> the 'data constructors' are what are usually called constructors. It's a good name, it's how you build up the values
02:35:41 <wavewave> Type constructor is not a function.
02:35:45 <donri> same thing, Nothing is a concrete value
02:35:53 <donri> Just is a constructor for concrete values like Just "ohai"
02:35:53 <shachaf> In both GADTs and the FFI syntax, you provide a type from which the compiler derives a value.
02:35:56 <metatagg> tkahn6: ok :)
02:36:11 <shachaf> I guess they both seem to me implicit in a roughly similar way...
02:36:17 <tkahn6> metatagg: i forgot to put `data` in front of the first Tree
02:36:39 <metatagg> ah
02:36:53 <wavewave> metatagg: so you can rename  like f = ValueConstructor
02:37:04 <shachaf> data Tree = Tree [Tree]
02:37:08 <wavewave> metatagg: you cannot rename f= TypeConstructor
02:37:28 <wavewave> metatagg: They live in completely separate world.
02:37:33 <metatagg> right
02:37:39 <donri> type F = TypeConstructor -- ;)
02:37:54 <applicative> metatagg I hope we're not crushing you with explanations...
02:37:57 <metatagg> so.. if i have two value constructors of the same type
02:38:06 <metatagg> but with the same fields
02:38:21 <wavewave> donri: right.. so "type" is explicitly needed
02:38:22 <metatagg> i can compare them
02:38:46 <shachaf> metatagg: "compare" how?
02:38:52 <wavewave> metatagg: if your datatype is in Ord class.
02:38:53 <metatagg> no sorry
02:38:54 <applicative> data Person = Chef String | Employee String
02:38:58 <metatagg> exactly
02:39:03 <metatagg> was gonna write that
02:39:04 <metatagg> but
02:39:06 <metatagg> oh
02:39:09 <applicative> data Person = Chef String Int | Employee String Int
02:39:31 <metatagg> applicative: that's a great example
02:39:53 <wavewave> haskell has very strict separation between type / value
02:39:56 <donri> you can pattern match values against Chef or Employee and in both cases the type would be Person
02:39:59 <applicative> If the second field is "age" or "salary" in both cases you would probably want to refactor
02:39:59 <hpaste_> tkahn6 pasted “Binary Tree” at http://hpaste.org/52231
02:40:20 <metatagg> ah
02:40:38 <donri> salary :: Person -> Int; salary (Chef name age) = 100
02:40:42 <applicative> data Status = Chef | Employee ; data Person = Person String Int Status (say)
02:40:57 <metatagg> aha
02:41:07 <tkahn6> also data SortOrder = Ascending | Descending
02:41:29 <metatagg> so it's like idiomatic to add a 'status' field to the DT?
02:41:31 <applicative> data SortOrder = Ascending | Descending deriving Ord
02:41:40 <tkahn6> :)
02:42:37 <metatagg> because the way i've solved my 'problem' now is similar to adding a Bool called 'isEmployee'
02:42:50 <metatagg> as a field
02:42:58 <wavewave> metatagg: You can also think ValueConstructor as a function like if you have data Person = Employee String, then Employee :: String -> Person
02:43:29 <wavewave> metatagg : ValueConstructor is special in a sense that it's an end of evaluation.
02:43:32 <donri> adding a bool for a non-binary categorization doesn't seem very idiomatic at all
02:43:33 <tkahn6> wow what is the tool that hpaste uses to make suggestions for your code
02:43:39 <tkahn6> 6:7: Warning: Redundant bracket
02:43:39 <tkahn6> Found:
02:43:40 <tkahn6>   (show n) ++ " things"
02:43:40 <tkahn6> Why not:
02:43:40 <tkahn6>   show n ++ " things"
02:43:40 <kmc> HLint
02:43:43 <tkahn6> nice
02:44:07 <applicative> you can also use the less lovely record syntax in this sort of case data Person = Person { name :: String; salary :: Int ; isEmployee :: Bool}
02:44:13 <applicative> wait, commas there
02:44:36 <metatagg> applicative: that's a bit what it looks like atm
02:44:44 <metatagg> 11:46:52         kmc | HLint                                                                                  │ akosch
02:44:48 <metatagg> oh
02:44:51 <metatagg> sry
02:45:31 <metatagg> thanks a lot
02:45:34 <simon> how do I combine 'natural :: ParsecT s u m Integer' with some 'parseNumber :: Parser Integer'?
02:45:39 <metatagg> i think i get it now :)
02:45:44 <applicative> or using the Status type we had above data Person = Person { name :: String, salary :: Int , status :: Status}
02:45:48 <wavewave> in the record syntax, it defines    name :: Person -> String,  salary :: Person -> Int, isEmployee :: Person -> Bool   at once.
02:46:13 <wavewave> simon : use Identity monad.
02:46:26 <kmc> you don't have to use it explicitly
02:46:40 <wavewave> @src Parser
02:46:40 <lambdabot> Source not found. Maybe you made a typo?
02:46:47 <kmc> type Parser t = ParsecT [Char] () Identity t
02:47:09 <simon> ah, thanks!
02:47:10 <kmc> so 'natural's type generalizes the type of parseNumber
02:47:16 <simon> kmc, right.
02:47:22 <wavewave> kmc: ah,, yeah.. that's right..
02:47:41 <applicative> simon they should fit together, so that e.g. liftM2 (+) natural parseNumber returns the sum of the two parsers run in sequence, or am I confused
02:48:14 <wavewave> so you can use natural in Parser monad but you cannot use parseNumber in ParsecT s u m monad.
02:48:44 <applicative> simon, then the inferred type of liftM2 (+) natural parseNumber  will be the most constrained of the two, ie. Parser Integer
02:49:50 <kingping> Hello.
02:50:10 <shachaf> kingping: Ahoy!
02:50:14 <whald> kingping: hello
02:50:15 <kingping> :-D
02:50:19 <applicative> you can also narrow the type of natural to what youre really thinking about, by writing myNatural :: Parser Integer ; myNatural = natural
02:50:24 <kingping> How stepeval is evaluated in here?
02:50:25 <wavewave> kingping: hi.
02:50:53 <kingping> > :t optional
02:50:54 <lambdabot>   <no location info>: parse error on input `:'
02:51:09 <kingping> > @type fmap
02:51:10 <lambdabot>   <no location info>: parse error on input `@'
02:51:12 <shachaf> @type fmap
02:51:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:51:14 <wavewave> what's stepeval?
02:51:34 <kingping> wavewave: Allows you to see how Haskell evaluates expression step by step.
02:51:39 <kingping> @type optional
02:51:40 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
02:51:41 <applicative> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
02:51:46 <shachaf> kingping: I doubt that's implemented in lambdabot?
02:52:02 <kingping> applicative: Thank you.
02:52:20 <shachaf> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=%28%5Cx+-%3E+x+x%29+%28%5Cx+-%3E+x+x%29
02:52:46 <applicative> try e.g. foldr (+) 0 [1,2,3,4] vs foldl (+) 0 [1,2,3,4]
02:53:13 <wavewave> applicative: that's exactly what I did a second ago. ;-D
02:53:17 <shachaf> > foldr (+) z [a,b,c,d]
02:53:18 <lambdabot>   a + (b + (c + (d + z)))
02:53:20 <shachaf> > foldl (+) z [a,b,c,d]
02:53:21 <lambdabot>   z + a + b + c + d
02:53:44 <applicative> > scanr (+) a [b,c,d,e]
02:53:45 <lambdabot>   [b + (c + (d + (e + a))),c + (d + (e + a)),d + (e + a),e + a,a]
02:53:48 <wavewave> funny that we all think similarly.
02:54:05 <applicative> > scanl (+) a [b,c,d,e]
02:54:05 <lambdabot>   [a,a + b,a + b + c,a + b + c + d,a + b + c + d + e]
02:54:33 <kingping> > Just <$> putStrLn "hello" <|> pure Nothing
02:54:34 <lambdabot>   No instance for (Control.Applicative.Alternative GHC.Types.IO)
02:54:34 <lambdabot>    arising f...
02:54:56 <applicative> what? kingpin tried to make lambdabot do IO !
02:55:02 <donri> @type a
02:55:03 <lambdabot> Expr
02:55:06 <donri> ^_^
02:55:12 <kingping> > Just <$> IO "hello" <|> pure Nothing
02:55:12 <lambdabot>   Not in scope: data constructor `IO'
02:55:20 <kingping> > Just <$> Maybe "hello" <|> pure Nothing
02:55:21 <lambdabot>   Not in scope: data constructor `Maybe'
02:55:28 <kingping> > Just <$> Just "hello" <|> pure Nothing
02:55:29 <lambdabot>   Just (Just "hello")
02:55:29 <shachaf> kingping: You can experiment with lambdabot in /msg, by the way.
02:55:29 <kmc> lambdabot can evaluate IO actions just fine
02:55:51 <donri> > putStrLn "canhas?"
02:55:52 <lambdabot>   <IO ()>
02:55:54 <applicative> indeed, it was bad types
02:56:17 <shachaf> EvaluationisdistinctfromexecutionHaskellisthemostimperativelanguageeverbecauseimperativevaluesarefirstclass.
02:56:24 <applicative> > return () :: IO ()
02:56:25 <lambdabot>   <IO ()>
02:56:30 <kmc> shachaf, are you making fun of me again?
02:56:35 <shachaf> kmc: No!
02:56:41 <shachaf> You're not the only one who says that.
02:56:44 <simon> applicative, the last thing you suggested to me was what I seemed to try to accomplish. it doesn't seem to work. (I use the type Parser from, I think, Text.ParserCombinators.Parsec.)
02:57:09 <shachaf> Those are pretty standard #haskell answers, aren't they?
02:57:21 <simon> applicative, that is; myNat :: Parser Integer ; myNat = natural
02:57:47 <applicative> where is natural from, I'm looking
02:57:50 <wavewave> oh.. I can do a private conversation with lambdabot.. good.
02:58:28 <simon> applicative, http://hpaste.org/52232 -- natural is from Text.Parsec.Token
02:59:04 <simon> are there more 'natural's?
02:59:12 <wavewave> simon: are you using parsec 3 or 2?
02:59:39 <simon> wavewave, good question :-D I think all my tutorials use Parsec 2, and I want to use the token combinators which seem to be more general (so 3?)
03:00:02 <wavewave> simon: parsec 2 and 3 are quite different.
03:00:13 <wavewave> especially monad stack..
03:00:37 <simon> wavewave, oh. is there a Token library in Parsec 2?
03:00:58 <wavewave> changing parsec 2 to 3 is not so difficult though.
03:01:02 <applicative> right the token natural
03:01:11 <simon> ah... Parsec 2 is all in Text.ParserCombinators, right?
03:01:22 <wavewave> yes. I think so
03:01:34 <applicative> no, its not 2 vs 3, I was giving bad advice because I wasnt' thinking he was using the Token module
03:01:45 <wavewave> but your message shows Text.Parsec..... that's parsec 3
03:01:45 <simon> I didn't see that there is also a Text.ParserCombinators.Parsec.Token.
03:01:57 <simon> wavewave, I understand now.
03:02:14 <simon> so since both are present, are there any reasons to use Parsec 2 besides backwards-compatibility?
03:02:37 <applicative> better error statements
03:02:53 <wavewave> Hmm there is Text.ParserCombinators.Parsec.Token ?
03:03:06 <wavewave> simon: I see the documentation shows it.
03:03:33 <applicative> yes, its the same modules just restricted to stringland
03:03:56 <wavewave> Ah.. I see.. what's wrong.
03:04:35 <wavewave> Text.ParserCombinators.Parsec.Token uses ParsecT monad transformer which is parsec 3.
03:04:56 <applicative> but simon, does the tutorial you are reading use the Token and Expr and Language modules, they're a little more advanced
03:05:09 <rrc7cz> how can I include a function in an ADT?
03:05:18 <rrc7cz> in other words, treating the function as data
03:05:43 <wavewave> data MyData = MyData ( A -> B )
03:05:59 <simon> applicative, no, the tutorials don't use Token. I just want to do that because they seem neat.
03:06:10 <wavewave> f :: A -> B , then you can make MyData  f
03:06:30 <hpaste_> metatagg pasted “person” at http://hpaste.org/52233
03:06:34 <wavewave> rrc7cz: is that what you want?
03:06:40 <metatagg> i figured it out! :)
03:06:48 <metatagg> really, thanks a lot :D
03:07:14 <wavewave> metatagg: like your geek and nerd thing ;-)
03:07:22 <metatagg> hehe
03:08:06 <metatagg> i'll be back when i run in to more obstacles.. :)
03:08:41 <rrc7cz> wavewave: I think so. I'm looking at a Learn You prob trying to impl it myself. I want to take "10 3 4 + 2 -" etc and parse it into a list
03:09:06 <wavewave> simon: since  you understand parsec 2, move to parsec 3 is not very difficult.
03:09:13 <applicative> simon, the natural I was imagining when I was misunderstanding you above would be defined something like fmap read (many1 digit)
03:09:16 <rrc7cz> wavewave: in a weakly typed lang I could just have a list of both num and fn type, but since a list can only contain a single type, I'm trying to make an ADT that can contain nums and fns
03:09:41 <wavewave> rrc7cz: that's right approach.
03:10:23 <simon> applicative, right. the tutorial suggested something like that.
03:10:29 <kmc> data Thing = ThingInt Int | ThingFun (Char -> Bool)
03:10:34 * wavewave thinks we need parsec3 tutorial. 
03:10:37 <kmc> probably you can come up with better names ;)
03:10:37 <applicative> or (read :: String -> Integer) <$> (many1 digit)
03:11:07 <rrc7cz> wavewave, kmc: thanks!
03:11:52 <tkahn6> rrc7cz: data Exp a = Operand a | Operator (a -> a) ?
03:12:35 <applicative> simon, if I write let nat = (read :: String -> Integer) <$> (many1 digit)  in ghci,  I get a hideous Parsec3 signature (less hideous than it could be)
03:12:44 <tkahn6> hmm or better yet..
03:13:22 <applicative> simon, but if I then write mynat :: Parser Integer; mynat = nat, then we get the specification without trouble.
03:13:57 <simon> applicative, right!
03:14:41 <wavewave> tkahn6: I think exposing a in type signature willl cause problem at this level.
03:14:52 <tkahn6> i see
03:16:33 <rahul> I have a function: mo f g h i = f (g h i)
03:16:41 <wavewave> one of difficulty in haskell is that one can hit some deep problem quite early in the learning course.
03:16:51 <rahul> I am trying to rewrite it as follows:
03:17:03 <rahul> mo f g = f . uncurry g . (,)
03:17:08 <rahul> Why doesn't that work?
03:17:17 <rahul> > mo f g = f . uncurry g . (,)
03:17:18 <lambdabot>   <no location info>: parse error on input `='
03:17:26 <rahul> > let mo f g = f . uncurry g . (,)
03:17:27 <lambdabot>   not an expression: `let mo f g = f . uncurry g . (,)'
03:17:41 <rahul> > \f g -> f . uncurry g . (,)
03:17:42 <lambdabot>   Couldn't match expected type `(a, b)'
03:17:42 <lambdabot>         against inferred type `b1 -> ...
03:18:28 <applicative> simon, of course, if i had written let nat :: Parser Integer; let nat = (read :: String -> Integer) <$> (many1 digit)  I would get the cozy parsec2 type I wanted in one go
03:19:12 <applicative> simon, though the digit and many1 combinators are much more abstract in fact, I specialize the result to the simple sensible Parser-land
03:20:03 <applicative> type , Parser Int
03:20:08 <wavewave> :t (,)
03:20:09 <lambdabot> forall a b. a -> b -> (a, b)
03:20:10 <applicative> Parser Integer rather
03:20:24 <rahul> h :: a
03:20:27 <rahul> i :: b
03:20:33 <rahul> g :: a -> b -> c
03:20:44 <rahul> f :: c -> d
03:21:04 <rahul> Now, (,) :: a -> b -> (a, b)
03:21:05 <wavewave> :t uncurry
03:21:06 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
03:21:18 <rahul> uncurry g :: (a, b) -> c
03:21:22 <rahul> f :: c -> d.
03:21:27 <rahul> Ought to work, no?
03:22:06 <kmc> you gave the correct type for "uncurry g"
03:22:38 <kmc> the problem is that you're treating (,) as a two-argument function
03:22:44 <wavewave> yes
03:22:51 <kmc> you can't use (f . g) to mean \x y -> f (g x y)
03:23:14 <kmc> :t let (.) = (Prelude..) in (.) . (.)
03:23:15 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:23:53 <rahul> kmc: Hmm, got it.
03:24:16 <rahul> kmc: How else should I be writing it, assuming I want to use (,) and uncurry?
03:24:22 <wavewave> (.) . (. )
03:24:53 <shachaf> @pl mo f g h i = f (g h i)
03:24:53 <lambdabot> mo = (.) . (.)
03:25:04 <simon> wavewave, that reminds me of Total Recall.
03:25:05 <shachaf> rahul: Why do you want to use (,) and uncurry?
03:25:20 <wavewave> (.) (.) (.)
03:25:40 <rahul> shachaf: Just playing with the functions. :)
03:25:42 <applicative> rahul is studying haskell, why shouldn't he use all the combinators in all combinations?
03:26:13 <rahul> shachaf: I tried a similar one for this: \f g -> (g .) . f
03:26:28 <rahul> shachaf: uncurry f . (g &&& id) . (,)
03:26:35 <rahul> shachaf: That too doesnt work for same reasons.
03:26:38 <rahul> applicative: :(
03:27:31 <applicative> rahul, I thought I was defending your curry uncurry (,) ' ing, never mind it....
03:27:55 <wavewave> :t curry
03:27:56 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
03:28:09 <rahul> applicative: Oh, sorry. And thanks. I thought your remark was sarcastic.
03:28:24 <applicative> sorry, no not at all
03:28:31 <wavewave> @src curry
03:28:31 <lambdabot> curry f x y = f (x, y)
03:28:38 <rahul> shachaf: Yes, I am learning Haskell, and various ways to compose functions.
03:28:43 <wavewave> @pl curry
03:28:43 <rahul> shachaf: :)
03:28:43 <lambdabot> curry
03:29:04 <wavewave> @pl \f x y = f (x,y)
03:29:05 <lambdabot> (line 1, column 8):
03:29:05 <lambdabot> unexpected "="
03:29:05 <lambdabot> expecting pattern or "->"
03:29:14 <wavewave> @pl \f x y -> f (x,y)
03:29:14 <lambdabot> (. (,)) . (.)
03:29:34 <rahul> @unpl (,)
03:29:34 <lambdabot> (,)
03:29:39 <rahul> oops.
03:30:14 <wavewave> :t (. (,)) . (.) (uncurry g)
03:30:14 <lambdabot> forall a b a1 b1 c. (Show a1, Show b1, SimpleReflect.FromExpr c) => ((b -> (a, b)) -> (a1, b1)) -> a -> c
03:30:31 <wavewave> anyway..
03:31:09 <rahul> > mo f g = f . uncurry g . ( . (,)) . (.)
03:31:10 <lambdabot>   <no location info>: parse error on input `='
03:31:24 <rahul> > \ f g -> f . uncurry g . ( . (,)) . (.)
03:31:25 <lambdabot>   Couldn't match expected type `(a, a1)'
03:31:25 <lambdabot>         against inferred type `a2 ->...
03:35:20 <applicative> @type let mo f g = f . uncurry g   in mo
03:35:21 <lambdabot> forall a b a1 b1. (a -> b) -> (a1 -> b1 -> a) -> (a1, b1) -> b
03:39:07 <sanjoyd> Why is this slow: http://pastebin.com/5VFqj0gF ?
03:39:09 <mauke> The paste 5VFqj0gF has been copied to http://hpaste.org/52235
03:39:35 <mauke> because you're making 2^n function calls
03:39:53 <sanjoyd> mauke: but shouldn't the values be memoized or something?
03:39:58 <mauke> no, why?
03:40:02 <mauke> did you memoize them?
03:40:11 <sanjoyd> No.  But since f is a pure function ...
03:40:14 <applicative> fib (n-1) and fib (n-1) are calculated independently
03:40:21 <wavewave> sanjoyd: no. f cannot see previous result.
03:40:38 <mauke> sanjoyd: that's nothing special; every function is pure
03:40:44 <sanjoyd> mauke: exactly.
03:41:09 <wavewave> sanjoyd: to have shared value, you need to have the value in your function's scope.
03:41:13 <applicative> fib (n-1) and fib (n-2) are calculated independently, rather
03:41:35 <wavewave> when fib is calculated, it cannot see the previous result in its scope.
03:41:58 <sanjoyd> wavewave: how?  As in, how would I modify this example for that to happen?
03:42:07 <erus`> Could you all stop making Steve Jobs jokes please. It's not PC.
03:42:19 <shachaf> erus`: What?
03:42:22 <mauke> sanjoyd: by making fibSeries directly recursive
03:42:28 <wavewave> erus` : ?
03:42:40 <mauke> shachaf, wavewave: ...
03:42:46 <applicative> fibSeries = 0 : 1 : zipWith (+) fibSeries (tail fibSeries) to use olde faithfull
03:42:55 <sanjoyd> applicative: yes.
03:43:06 <sanjoyd> applicative: I'm just trying out various to generate the fib series.
03:43:07 * shachaf sighs.
03:43:10 <erus`> Not sure if wooosh or bad joke...
03:43:29 <mauke> erus`: a bit of column A, a bit of column B ...
03:44:41 <applicative> f x = fibSeries !! (x - 1) + fibSeries !! (x - 2)   will improve it, no?
03:45:04 * sanjoyd finds fix (\x->1:1:zipWith (+) (tail x) x) coolest.
03:45:09 <erus`> applicative: are you writing an evented webserver?
03:45:17 <mauke> needs more scanl
03:45:41 <applicative> erus` should I be??
03:45:55 <donri> how does tail work on infinite lists, is that some special casing of self-recursion?
03:46:02 <erus`> lots of people seem to be writing webservers for Fibonacci
03:46:08 <sanjoyd> donri: Laziness, I guess.
03:46:11 <shachaf> > let fibs@(_:x) = 1 : 1 : zipWith (+) fibs x in fibs
03:46:12 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
03:46:14 <kmc> tail (x:xs) = xs
03:46:16 <mauke> donri: no, it works normally
03:46:18 <kmc> doesn't matter what xs is
03:46:20 <ibid> donri: laziness, as with any other list function
03:46:23 <kmc> could be an infinite list or even ⊥
03:46:25 <applicative> > take 3 (tail [1..])
03:46:26 <lambdabot>   [2,3,4]
03:46:35 <mauke> sanjoyd, ibid: laziness doesn't come into it
03:46:43 <ibid> mauke: yes it does
03:46:46 <mauke> no
03:46:49 <shachaf> @let ⊥ = ⊥
03:46:50 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8869) is outside of bounds (0,255)
03:46:50 <donri> wait, what's tail do again
03:46:51 <mauke> I can do this in C
03:46:57 <donri> i think i'm confusing it for something else
03:47:01 <kmc> donri, tail (x:xs) = xs
03:47:02 <sanjoyd> Huh?  Won't strictly evaluating tail (1:undefined) be undefined then?
03:47:09 <donri> ah, then it makes sense
03:47:10 <ibid> mauke: if xs were eager, it wouldn't work
03:47:14 <shachaf> sanjoyd: Yes.
03:47:15 <kmc> sanjoyd, sure
03:47:20 <mauke> ibid: what does it mean for xs to be eager?
03:47:21 <wavewave> tail is lazy in its argument.
03:47:22 <kmc> > (tail (1 : undefined)) `seq` ()
03:47:23 <lambdabot>   *Exception: Prelude.undefined
03:47:31 <shachaf> sanjoyd: Does "strictly evaluating" x mean that you call id with x as an argument?
03:47:42 <donri> ah yea i was thinking of last
03:47:43 <ibid> mauke: that xs is evaluated before the function is entered
03:47:47 <wavewave> but the algorithm doesn't use laziness in effect.
03:47:52 <mauke> ibid: makes no difference
03:47:55 <shachaf> By the way, what does GHC.Exts.lazy actually do?
03:48:00 <ibid> mauke: yes it does
03:48:00 <mauke> > tail $! [0 ..]
03:48:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:48:03 <mauke> ibid: ^
03:48:23 <ibid> mauke: that evaluates to WHNF, which is laziness
03:48:37 <ibid> the rest of the list is still lazy
03:48:38 <sanjoyd> shachaf: what does id have anything to do with laziness?
03:48:39 <mauke> ibid: so what you're saying is that completely evaluating an infinite list takes forever?
03:48:41 <donri> > last [1..]
03:48:45 <lambdabot>   mueval-core: Time limit exceeded
03:48:45 <mauke> ibid: that has nothing to do with tail
03:48:45 <ibid> mauke: exactly
03:49:07 <ibid> mauke: it has to do with the fact that haskell is non-strict (often called lazy, but that's lazy talk)=
03:49:16 <mauke> ibid: no, I can do it in C
03:49:20 <wavewave> when we say 'lazy', we need to say lazy "where"
03:49:25 <sanjoyd> mauke: what can you do in C?
03:49:37 <mauke> struct node { int x; struct node *next; };  // I'm a list
03:49:48 <mauke> struct node *tail(struct node *p) { return p->next; }
03:50:03 <mauke> struct node list = { 1, &list };  // infinite list
03:50:04 <sanjoyd> mauke: but C does not have an "undefined", I think.
03:50:08 <mauke> tail(&list);
03:50:41 <mauke> sanjoyd: I don't need one, only an infinite list
03:51:05 <mauke> printf("%d\n", tail(&list)->x);
03:51:25 <wavewave> sanjoyd: in this example, we can think unvalid pointer value as an undefined value.
03:51:41 <wavewave> laziness is in fact very similar to pointer.
03:51:52 <koala_man> can anyone think of a simple, realistic example of Either that isn't error handling?
03:52:35 <ibid> mauke: point, i suppose.  the key is that tail doesn't care what's beyond the first element
03:52:37 <shachaf> koala_man: Having one of two values?
03:52:47 <tdammers> a function that takes either a filename or a file handle?
03:52:51 <ibid> mauke: in haskell's case that's because haskell is non-strict
03:52:54 <shachaf> ibid: Are you and mauke actually disagreeing on anything?
03:52:59 <shachaf> tdammers: That sounds evil.
03:53:09 <tdammers> well... maybe
03:53:20 <tdammers> but it doesn't have to be
03:53:27 <mauke> > head (tail (repeat 1))  -- haskell equivalent
03:53:28 <lambdabot>   1
03:53:38 <mauke> look ma, no bottoms
03:53:48 <koala_man> shachaf: yes. some function that realistically returns one of two types, for example
03:54:04 <ibid> mauke: in C's case it's because in C's semantic model there are only structs and pointers, there's no such thing as a list
03:54:06 <applicative> koala_man: well, that sum types are written into syntax with data MySum a = A
03:54:16 <applicative> koala_man: well, that sum types are written into syntax with data MySum a = A | B String | C a
03:54:24 <mauke> ibid: and in Haskell there are only algebraic types
03:54:44 <applicative> koala_man: makes Either a little less interesting than it might be, its just the abstract shape of all of those, so to speak
03:54:59 <ibid> mauke: not quite.  algebraic types don't have to be nonstrict
03:55:09 <wavewave> mauke , ibid : I do not understand what both of you disagree on.
03:55:29 <ibid> mauke: i should be more precise: in haskell's case it's because (:) is nonstrict in its second argument
03:55:42 <shachaf> (:) is nonstrict in all its arguments.
03:55:44 <koala_man> applicative: do you have a simple, realistic example of sum types off the top of your head? that isn't about errors I mean?
03:55:53 <mauke> data List a = Nil | Cons a !(List a)
03:55:54 <ClaudiusMaximus> > let { f x | x > 10 = Right x | otherwise = Left x ; g x = 2 * x ; h xs = let (todo, done) = partitionEithers (map g xs) in done ++ h todo } in h [1..5]
03:55:54 <wavewave> shachaf: exactly.
03:55:55 <lambdabot>   Occurs check: cannot construct the infinite type:
03:55:56 <lambdabot>    a = Data.Either.Either...
03:56:06 <mauke> ibid: I bet it would still work if you made (:) strict
03:56:06 <shachaf> wavewave: What?
03:56:10 <ClaudiusMaximus> > let { f x | x > 10 = Right x | otherwise = Left x ; g x = 2 * x ; h xs = let (todo, done) = partitionEithers (map (f . g) xs) in done ++ h todo } in h [1..5]
03:56:13 <ibid> shachaf: true.  what i said is a special case of it.  in tail's case, it doesn't matter whether (:) is strict in the first argument
03:56:14 <lambdabot>   mueval-core: Time limit exceeded
03:56:21 <ibid> mauke: feel free to try
03:56:22 <wavewave> shachaf: ahh.. I just agreed with you. ;-)
03:56:24 <shachaf> ibid: None of this has to do with strictness.
03:56:31 <applicative> koala_man: grep hackage for uses of data .* |
03:56:33 <ibid> wavewave: we're arguing about the number of angels on a pinhead
03:56:34 <wavewave> shachaf: about list.
03:56:39 <ibid> shachaf: yes it does
03:56:56 <shachaf> ibid: mauke gave you an example in C, which is a completely strict language.
03:56:56 <koala_man> never mind then, I'll just use an example about error handling.
03:57:11 <applicative> data Bool = True | False
03:57:40 <ClaudiusMaximus> > let { f x | x > 10 = Right x | otherwise = Left x ; g x = 2 * x ; h [] = [] ; h xs = let (todo, done) = partitionEithers (map (f . g) xs) in done ++ h todo } in h [1..5]
03:57:40 <ibid> shachaf: read my response above
03:57:42 <lambdabot>   [12,16,20,16,16]
03:57:43 <wavewave> I would say that C supports laziness using pointer.
03:58:00 <shachaf> ibid: What are youa ctually arguing about?
03:58:09 <wavewave> what makes haskell special is default-lazy .
03:58:12 <ibid> shachaf: 13:59  <ibid> wavewave: we're arguing about the number of angels on a pinhead
03:58:13 <wires> wavewave C is imperative.. different story
03:58:16 <koala_man> applicative: those are the same types
03:58:49 <koala_man> I mean, you don't need any form of Either or equivalent for that
03:58:51 <applicative> but we could have had type Bool = Either () ()
03:59:02 <shachaf> I would suggest that if you're arguing with mauke, you're likely wrong.
03:59:05 <wavewave> wires: yes. if we consider only functional analogous part of c...
03:59:22 <wavewave> wires: I mean in the context of this argument.
03:59:24 <donri> Argument to authority? :)
03:59:44 <ibid> shachaf: that's because you know mauke but not me.  i've been mostly silent here for years :)
03:59:53 <wires> wavewave, still.. you are getting into a mess.
04:00:30 <wires> with C i mean
04:00:49 <wavewave> wires: defining a lazy list using C's pointer and struct is well-matched.
04:00:52 <applicative> koala_man: I think I was agreeing that Either isn't used a lot for other things besides 'errors', one usually makes one's own type
04:01:31 <koala_man> applicative: I counted making one's own type as an equivalent
04:01:41 <applicative> koala_man but most cases of data Foo where ... will use | and thus are sum types.
04:01:44 <mauke> ibid: you're right
04:01:55 <mauke> I don't completely understand it yet but there's a level of indirection missing somewhere
04:02:00 <applicative> koala_man: if it's not a sum type you might as well use newtype Foo = Foo ....
04:02:03 <ibid> wavewave: mauke actually didn't define a lazy list in C.  the list was eager, with side-effects used to create a circular structure
04:02:15 <sanjoyd> Is it correct to say that without a type level fixed point combinator and a value level fixed point combinator Haskell would not be Turing complete?
04:02:16 <mauke> ibid: er, what side effects?
04:02:38 <ibid> mauke: ah, sorry. my bad
04:02:55 <applicative> koala_man: you use data Foo where ...  when you are going to distinguish cases.  But I must be missing something
04:02:59 <sipa> sanjoyd: i'm not sure whether recursive type definitions are equivalent to a type-level fixed point combinator
04:03:01 <wavewave> ibid: this is exactly what ghc graph reduction machine does..
04:03:03 <sipa> sanjoyd: though it suffices
04:03:07 <ibid> mauke: i was thinking of more complicated structures where you can't use that trick
04:03:41 <koala_man> applicative: anyways, I thought of some semi-plausible scenario. a binary search function on a list that returns either the element, or the index where the element would have been
04:03:41 <ibid> wavewave: true.  but that's an implementation issue, not a part of the language semantics
04:03:44 <wavewave> ibid: in that sense, there's nothing special in haskell.
04:04:01 <mauke> I think the problem is that you can't write a strict repeat
04:04:21 <shachaf> Why can't you write a strict repeat?
04:04:26 <mauke> ~ a repeat for a list strict in its tail
04:05:01 <wavewave> anyway.. I feel that this argument is on top of ill-definedness of laziness in C..
04:05:21 <mauke> wavewave: I don't think anyone's using laziness in C
04:05:43 <mauke> shachaf: the obvious definition is repeat' x = xs where xs = Cons x xs
04:05:52 * ibid was building a lazy C some years ago.  i got bored before it was finished :)
04:06:29 <ibid> C does support nonstrictness in certain special situations
04:06:33 <shachaf> mauke: Oh, I see.
04:06:45 <mauke> shachaf: now when you want to evaluate xs, the definition of Cons forces it to evaluate xs first
04:06:47 <mauke> bam! loop
04:06:58 <sanjoyd> ibid: side effects?
04:07:10 <mauke> ibid: &&, ||, ?: ?
04:07:16 <ibid> mauke: yes
04:07:57 <ibid> sanjoyd: nope :)
04:08:33 <ibid> mauke: but thanks for the debate.  i think i've got something new to ponder about the semantics of C pointers :)
04:09:00 <mauke> yah, I'll semant the shit outta you
04:09:14 * ibid tries to disappear again to do some (mostly unrelated) research
04:09:40 <applicative> > let koala_man  xs n = case length xs >= (n +1) of True -> Right (xs !! n) ; False -> Left n in map (koala_man "haha") [0..5]
04:09:41 <lambdabot>   [Right 'h',Right 'a',Right 'h',Right 'a',Left 4,Left 5]
04:10:17 <mauke> > let cons x xs = (:) x $! xs in cons 0 [1 ..]
04:10:18 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:10:37 <shachaf> mauke: Semanting is a hobby of yours, isn't it?
04:10:37 <mauke> > let cons x xs = (:) x $! xs; repeat' x = xs where xs = cons x xs in repeat 1
04:10:38 <wavewave> ibid, mauke: I do think that C pointer is a kind of laziness in practical sense. simulating laziness in C.
04:10:38 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:10:59 <shachaf> > let cons x xs = (:) x $! xs; repeat' x = xs where xs = cons x xs in repeat' 1
04:10:59 <mauke> > let cons x xs = (:) x $! xs; repeat' x = xs where xs = cons x xs in repeat' 1
04:11:01 <ibid> wavewave: nonstrictness, perhaps. definitely not laziness in the precise sense
04:11:03 <lambdabot>   mueval-core: Time limit exceeded
04:11:03 <lambdabot>   mueval-core: Time limit exceeded
04:11:21 <wavewave> ibid: I agree with you
04:11:48 <shachaf> I don't think pointers have much to do with nonstrictness as such.
04:12:46 <koala_man> applicative: fair example, just not realistic. it's for a presentation I'm doing on why java types are inadequat
04:13:02 <ibid> sanjoyd: well, unary & is actually nonstrict
04:13:15 <ibid> argh, shachaf ^^
04:13:22 <wavewave> if we have int *x,    x is boxed value. *x is unboxed value.
04:13:32 <ibid> sanjoyd: sorry :)
04:13:52 <ibid> not quite.  boxing is generally transparent
04:14:05 <applicative> koala_man, I was just thinking of it as a trivial version of your idea about search, you get the thing you were looking for but if you don't find it, you keep the index or place you were looking
04:14:16 <ibid> wavewave: C++ references are closer to boxing (but even there you have to explicitly indicate it)
04:15:25 <wavewave> ibid: I agree with you. definitely with mutability, there is no apple-to-apple comparison.
04:16:37 <wavewave> pointer / reference provide one level of indirection which can be embedded in the non-strict semantics.
04:18:30 <ibid> i've usually defined boxing as putting the representation behind a pointer in a way that the programmer doesn't need to care (beyond, perhaps, efficiency)
04:19:12 <ibid> from the programmer's POV, they're just using the value as if there was no pointer
04:19:17 <mauke> my definition of boxing doesn't include transparency
04:19:34 <ibid> (a good example is the classic implementation of the C++ string class)
04:19:47 <ibid> mauke: what's your definition?
04:20:31 <mauke> wrapping a value in a box
04:21:21 <ibid> what's a box?  what's wrapping?
04:21:31 <ibid> does newtype qualify?
04:22:25 <mauke> depends on your point of view
04:22:54 <ibid> i'm asking for yours :)
04:23:27 <mauke> I can see both
04:23:40 <mauke> at the syntax and type level, it's a box
04:23:57 <mauke> at the operational level, it's not
04:24:12 <ibid> syntax?  not semantic?
04:25:00 <mauke> depends on the kind of semantics!
04:25:16 <ibid> :)
04:25:43 <mauke> it affects e.g. instance selection but it's transparent with regard to strictness
04:25:46 <ibid> i just ask because to me, boxing is never a syntactic issue, it's an implementation technique (or if i allow for nontransparency, semantic)
04:26:05 <mauke> when I think boxing, I think of java
04:26:13 <mauke> Integer box = new Integer(i);
04:26:32 <ibid> ah.  but java isn't what defined that term
04:26:41 <ibid> the term is much older than that :)
04:26:59 <ibid> i think java calls autoboxing what i call boxing
04:27:06 <whald> what's the package of choice for reading image files like png or jpeg? a quick look at hackage did not reveal something mature, is there something I missed?
04:27:12 <mauke> Integer box = i;  // autoboxing
04:28:36 <ibid> mauke: well, in all honesty, Integer is a transparent box of an integer (the abstract value). it's only nontransparent if you think it's an int that's being boxed
04:29:14 <mauke> or when you need to do anything with it
04:29:18 <mauke> box + box  // invalid
04:29:37 <shachaf> Java has an Integer type that doesn't support +?
04:29:45 <shachaf> What's the point of it?
04:29:52 <sipa> storing it in collections
04:29:55 <mauke> shachaf: inheriting from Object, duh
04:29:56 <Nimatek> That's Java for you.
04:30:01 <mauke> that's what polymorphism means
04:30:08 <shachaf> mauke: Oh, right.
04:30:23 <sipa> if you type box + box, won't it do auto-unboxing?
04:30:29 <mauke> shachaf: supporting + would mean operator overloading and that's EVIL
04:30:39 <mauke> sipa: it probably does now
04:30:57 <ibid> mauke: is that a boxing issue or an operator design issue?  you can't use the operators with any non-builtin numeric type
04:30:58 <mauke> but that's just box.getValue() + box.getValue(), basically
04:31:12 <shachaf> new Integer(box.getValue() + box.getValue())?
04:31:26 <engla> and yet "result: " + 5  is a valid string concatenation
04:31:38 <mauke> engla: we don't talk about that :-|
04:31:44 <shachaf> What?
04:31:48 * shachaf sighs.
04:32:00 <shachaf> This language is too practical for me.
04:34:21 <ibid> my disappearance clearly was unsuccessful.  trying again :)
04:34:29 <donri> so autoboxing is less evil than operator overloading eh
04:36:29 <shachaf> I think C++ is a pretty cool guy. eh overloads operators and doesn't afraid of anything
04:37:56 <MjrTom> In soviet russia, operators overload YOU!
04:37:59 * shachaf ought to be ashamed.
04:38:19 <fabbomelker> hey
04:38:24 <ibid> MjrTom: you know, that's a scary thought :)
04:38:35 <MjrTom> aint it tho
04:39:38 <fabbomelker> I read the following somewhere; The GHC implementation for arrays proved to be less suited for scientific programming (compared with Clean and C).
04:40:21 <fabbomelker> So Haskell is not good for solving eg. linear systems Ax =b ? or i depends on the solver used?
04:41:09 <ohwow> well solving linear systems is easy enough, i think
04:41:19 <fabbomelker> the quote is from an article about conjugate gradient method implemented in Clean, C and Haskell
04:41:31 <ibid> fabbomelker: ref?
04:41:45 <ohwow> plus, there are different type of arrays in haskell
04:41:46 <ohwow> http://www.haskell.org/haskellwiki/Arrays
04:42:14 * gienah sort of thought fortran was good for solving linar algebra: http://hackage.haskell.org/package/hmatrix
04:42:19 <fabbomelker> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.3620&rep=rep1&type=pdf
04:42:31 <sanjoyd> I've always found arrays a little difficult in Haskell.
04:43:09 <sanjoyd> fabbomelker: if possible, you can wrap the array operations in the ST monad.  That way you get speed and the other advantages of Haskell at the same time.
04:43:13 <fabbomelker> ohwow: easy perhaps, but memory and time demanding for huge systems
04:43:50 <ohwow> What is ST monad btw?
04:44:01 <ibid> fabbomelker: that's an old paper.  things are likely to have changed
04:44:49 <ibid> (publisher copy at http://www.springerlink.com/content/p27m72283x577876/ )
04:44:51 <sanjoyd> ohwow: allows you to do (real) statelful computation at a local level, without polluting the rest of your code with side effects.
04:45:16 <sanjoyd> ohwow: a lot like IO, except that you create the RealWorld.
04:45:27 <ohwow> ah I see
04:45:31 <mauke> RealWorld--
04:45:34 <ohwow> I am a newbie in Haskell
04:45:35 <sanjoyd> ohwow: with some type system tricks, prevents the outside world from seeing that you did something naughty.
04:45:42 <mauke> ST gives you mutable variables
04:45:50 <fabbomelker> ohwow: Im a newbie too
04:45:55 <byorgey> fabbomelker: you may be interested in looking at the vector and repa packages
04:45:56 <ibid> sanjoyd: a bit like a bedroom door?
04:45:59 <mauke> and it's encapsulated so you can present a pure interface but use mutable stuff internally
04:46:02 <byorgey> @hackage vector
04:46:02 <lambdabot> http://hackage.haskell.org/package/vector
04:46:10 <byorgey> @hackage repa
04:46:10 <fabbomelker> thanks all
04:46:10 <lambdabot> http://hackage.haskell.org/package/repa
04:46:26 <sanjoyd> ibid: one with all the locks in the world on it.
04:46:36 <sanjoyd> So no matter which key you have, you can't unlock them all. :P
04:46:56 <sanjoyd> Okay, that was a really bad analogy for forall.
04:49:52 <erus`> can i model the Pinocchio paradox in haskell?
04:50:41 <sanjoyd> > fix (\x->not x)
04:50:45 <lambdabot>   mueval-core: Time limit exceeded
04:50:53 <sanjoyd> I think so. :P
04:51:14 <erus`> nose = bottom
04:51:42 <donri> > fix not
04:51:46 <lambdabot>   mueval-core: Time limit exceeded
04:51:48 <donri> or is it a keyword
04:51:57 <donri> @src not
04:51:57 <lambdabot> not True   =  False
04:51:57 <lambdabot> not False  =  True
04:52:05 <donri> guess... not
04:52:38 <sanjoyd> There aren't enough jokes about fixed point combinators.
04:53:25 <int-e> > fix error
04:53:26 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
04:53:29 <erus`> @src fix
04:53:29 <lambdabot> fix f = let x = f x in x
04:53:45 <int-e> sanjoyd: I think that one is a joke
04:53:46 <sanjoyd> int-e: nice one. :D
04:53:48 <sanjoyd> Yes.
04:54:31 <ibid> sanjoyd: nah, it's the forall that's the door, and the lock is only accessible from the inside :)
04:56:11 <fabbomelker> found this presentation about functional programming. I am a newbie to this area and it made some things clear to me. Id recommand it. it is really easy to following. http://www.math.ucla.edu/~siam/talks/functional%20programming%20for%20numerical%20analysis.pdf
04:58:07 <fabbomelker> is there a syntax for range in haskell? like range(5) = [1,2,3,4,5]
04:58:22 <ibid> > [1..5]
04:58:23 <lambdabot>   [1,2,3,4,5]
04:58:33 <sanjoyd> > fix id
04:58:37 <lambdabot>   mueval-core: Time limit exceeded
04:58:46 <sanjoyd> id is continuous, right?
04:58:48 <fabbomelker> ibid, neat thankz
04:59:04 <quicksilver> all functions expressible in haskell are continuous
04:59:11 <sanjoyd> What is a sufficient condition for f such that fix f converges?
04:59:27 <quicksilver> that f(_|_) is not _|_
04:59:34 <ibid> fabbomelker: i have a colleague who's using haskell to write all sorts of numerics-heavy research programs (genetic optimization, machine vision etc)
05:00:39 <sanjoyd> I wonder what this translates to, in Haskell, then: "Every order-preserving self-map f of a cpo (P, ⊥) has a least fixpoint.[5] If f is continuous then this fixpoint is equal to the supremum of the iterates (⊥, f(⊥), f(f(⊥)), … fn(⊥), …) of ⊥ (see also the Kleene fixpoint theorem)."
05:01:06 <fabbomelker> ah nice. I am graduating from technical mathematics in sweden, basically applied maths and numerical analysis, hence my interest. how does he like it?
05:01:31 <quicksilver> sanjoyd: it just says that fix exists; i.e. all functions in haskell have a fixed point.
05:01:42 <sanjoyd> Basically, is it okay to say the fixed pt. of id is _|_?
05:01:44 <ibid> fabbomelker: better than the alternatives, i understand.  of course, he uses quite a bit of FFI
05:01:45 <fabbomelker> is he connected to a University?
05:02:04 <quicksilver> sanjoyd: yes, that's correct. The fixed pt of id is _|_.
05:02:05 <sanjoyd> Rather, id's least fixed point?
05:02:10 <sanjoyd> Thanks.
05:02:13 * sanjoyd gets it now. :)
05:02:17 <quicksilver> the fixed point of all strict functions is id.
05:02:19 <ibid> fabbomelker: yes, he's a postdoctoral researcher in the next room from me :)
05:02:42 <quicksilver> sanjoyd: (yes, by 'the fixed point' I mean the least one)
05:02:48 <ibid> quicksilver: you mean bottom?
05:02:57 <quicksilver> ibid: sorry, I did.
05:03:00 <fabbomelker> FFI? Fatal familial insomnia is what i found..
05:03:10 <quicksilver> the fixed point of all strict functions is _|_, just like id.
05:03:11 <sanjoyd> Foreign function interface.
05:03:14 <quicksilver> is what I meant :)
05:03:15 <sanjoyd> fabbomelker: ^
05:03:50 <sanjoyd> quicksilver: because strictFunction(_|_) is _|_?
05:04:03 <fabbomelker> so he imports code from other languages?
05:04:07 <sanjoyd> And hence the least shall always remain _|_.
05:04:12 <quicksilver> sanjoyd: right.
05:04:24 <donri> fabbomelker: varför badar du alltid med kläderna på?
05:04:25 <fabbomelker> sry if I am a bit slow..
05:04:33 <ibid> fabbomelker: i can give you his info, but not right now.  he's super busy preparing for his next teaching session (on haskell, as it happens)
05:04:37 * sanjoyd loves how everything I discuss something here, I always take back something.
05:04:38 <int-e> quicksilver: the least fixed point. (id has very many fixed points)
05:04:58 <quicksilver> int-e: 13:05 < quicksilver> sanjoyd: (yes, by 'the fixed point' I mean the least one)
05:05:01 <fabbomelker> sure thanks m8
05:05:05 <erus`> Has anyone (high profile) ever complained that the type system in haskell isnt powerful enough?
05:05:15 <ibid> fabbomelker: ask me tomorrow or something
05:05:15 <quicksilver> frequently, yes, erus`
05:05:17 <sanjoyd> They went and wrote Agda.
05:05:24 <sanjoyd> (I think.)
05:05:39 * sanjoyd will learn Agda one day.
05:05:42 <ibid> they also went and improved the haskell type system :)
05:05:50 <fabbomelker> donri: för att jag blygs inför min enorma snopp
05:06:56 <donri> ^_^
05:06:57 <fabbomelker> ibid: are you working with something similar?
05:07:02 <fabbomelker> if I may ask
05:07:08 <engla> fabbomelker: are you at LTH?
05:07:30 <fabbomelker> engla: trying to track me down are you?
05:07:38 <fabbomelker> engla: just kidding, yes I am
05:07:41 <engla> just wondering if they bring up Haskell
05:07:47 <ibid> fabbomelker: i'm not currently actively doing FP.  i'm doing a systematic map on empirical programming language research
05:07:50 <donri> wait, engla is swedish too? that nick is, uh, yea
05:07:55 <ibid> fabbomelker: also, i've never been a numerics person :)
05:07:58 <engla> I still haven't been able to leave LTH
05:08:05 <ibid> fabbomelker: but i did teach him years ago :)
05:08:07 <fabbomelker> engla: and you? thought you were raped and killed..
05:08:14 <donri> ^_^
05:08:21 <engla> that's not me
05:08:42 <fabbomelker> engla: which department are u in?
05:08:51 <engla> engineering physics
05:09:20 <fabbomelker> engla: there is a course in haskell
05:09:26 <fabbomelker> engla: at LTH
05:09:33 <fabbomelker> engla: havent taken it though
05:09:55 <engla> that's good at least
05:10:16 <fabbomelker> engla: came through haskell by coincidence.
05:10:31 <fabbomelker> engla: which year?
05:10:54 <engla> http://cs.lth.se/edan40
05:10:59 <donri> are those sort of courses actually useful or are they anything like the "programming" courses i took in high school ("this is a comment")
05:11:03 <fabbomelker> inbid: which department are u in?
05:11:12 <ibid> donri: depends a lot on the course and its intended level
05:11:30 <fabbomelker> engla: that is the one
05:11:33 <ibid> donri: my colleague is teaching from RWH and LYAH
05:11:41 <engla> fabbomelker: F-too long ago
05:12:05 <fabbomelker> haha engela
05:12:08 <fabbomelker> engla
05:12:15 <fabbomelker> Im a bit lagging too
05:12:17 <ibid> donri: generally, you start with "this is a comment" if you're dealing with programming newbies.  if you assume programming experience you can skip most of that
05:12:23 <fabbomelker> 05
05:14:48 <erus`> @pl a ( b + c)
05:14:48 <lambdabot> a (b + c)
05:15:17 <erus`> @pl a . b ( c + d)
05:15:18 <lambdabot> a . b (c + d)
05:15:35 <ibid> @pl \ a b c -> a (b + c)
05:15:35 <lambdabot> (. (+)) . (.)
05:15:52 <fabbomelker> engla. are u taking any courses atm?
05:16:02 <engla> nope, exjobb
05:16:19 <fabbomelker> ah
05:16:22 <fabbomelker> topic?
05:16:31 <fabbomelker> same here
05:16:45 <engla> I'm at mathematical physics
05:16:50 <erus`> i Think today i will write an alligator eggs simulator
05:17:17 <fabbomelker> I got that. but which topic for your thesis?
05:18:39 <ibid> donri: one does need to explain comments to newbies.  when i was little, i once thought a program was very easy to understand and modify - i ignored all the weird stuff and read (and modified) all the stuff after REM
05:18:44 <ibid> (of course, it never worked)
05:19:11 <FUZxxl> fabbomelker: The presentation is great, but their Haskell examples have a strange syntax
05:19:52 <engla> well matphys is the actual department where it at, even though it's also related to high-energy. It's about selection rules for identifying particle tracks in a detector
05:20:48 <donri> ibid: :) well it was a java course of the *complete* basics
05:21:55 <donri> ibid: anyway it does sort of seem that you can't be taught programming - you have to teach yourself, even if you have help
05:22:41 <ibid> donri: it's a skill.  the same happens with playing violin, or driving a car.  the teacher is more like a coach than a lecturer
05:22:52 <ibid> (when it's well done, that is)
05:23:10 <fabbomelker> how do I write intermediate declarations inside a function?
05:23:23 <ibid> let or where
05:23:28 <donri> well, that's true to some extent. you can be taught the techniques of playing the violin, but it's only going to sound mechanical if you don't have the passion for music
05:23:56 <ibid> donri: you can't learn even the techniques without investing a lot of your own effort in it
05:24:22 <donri> depends what you mean by effort; some are very skilled in mimicry
05:24:24 <fabbomelker> I wanna write a function sample
05:24:27 <fabbomelker> sample a b n
05:24:31 <ibid> donri: but the teacher can guide you away from dead ends and tar pits
05:24:48 <ibid> donri: the mimicry argment applies to programming as well :)
05:24:58 <fabbomelker> should calcuate dx=(a-b)/n
05:25:17 <engla> fabbomelker: a let expression lets you declare intermediates inline. A 'where' can do it on the following lines
05:25:54 <ibid> > let x = 42 in x - 1
05:25:55 <lambdabot>   41
05:25:56 <hpc> let x = stuff in ...
05:26:12 <donri> ibid: programming is more similar to music composing. to *play* an instrument you can learn an existing composition and just repeat it. that's not very useful in programming - you have to understand how to combine smaller pieces of learned patterns
05:26:35 <fabbomelker> how do I declare the function to start with? for now i have only written really basic ones like: norm p x =  invraise p (summa (powwa p x))
05:26:58 <ibid> f y = let x = 42 in x - y
05:27:04 <quicksilver> haskell doesn't have declarations as distinct from defintions (order doesn't matter)
05:27:12 <quicksilver> you can put a type signature first if you want to, though
05:27:20 <hpc> @let f' y = let x = 42 in x - y
05:27:22 <lambdabot>  Defined.
05:27:23 <hpc> > f' 13
05:27:25 <lambdabot>   29
05:27:29 <hpc> @undefine
05:27:36 <hpc> (ignore the '@let' there)
05:28:22 <engla> fabbomelker: just  'norm p x = ...' like that is fine. in ghci you need to use only let bindings though
05:28:58 <ibid> donri: depends on the style of music.  some put a lot of emphasis on improvisation
05:29:03 <fabbomelker> ok
05:29:12 <_A{REEMA}_> help me
05:29:40 <donri> ibid: improv is a form of composition
05:29:52 <_A{REEMA}_> help
05:30:12 <ibid> donri: it's also an integral part of the skill of playing the instrument, in such styles
05:30:24 <hpc> _A{REEMA}_: Type `help name' to find out more about the function `name'.
05:30:25 <hpc> :P
05:30:28 <_A{REEMA}_> how i do register a nike?
05:30:38 <ibid> donri: in any case, the playing technique is not that much different from learning the basic patterns
05:33:01 <ibid> donri: a programmer out of the first course is rarely much more creative than what's required to mimicing the example programs given in the course
05:33:18 <ibid> donri: the creative skill comes later, as experience accumulates
05:33:21 <donri> i suspect you're missing my point; even with purely repetitive and improvisation-lacking performance, there's an element of musical expression that distinguishes the truely talented
05:34:29 <donri> and this is rather off-topic :)
05:34:29 <ibid> i get your point; i just disagree
05:34:53 <ibid> it's mostly a matter of definitions
05:36:53 <fabbomelker> sample a b 0 = 0
05:36:58 <fabbomelker> sample a b n = let dx = (a-b)/n in map (inc a dx) [0..n-1]
05:37:00 <fabbomelker> inc a dx i = a + dx*i
05:37:52 <fabbomelker> this doesnt seem to work.. any remedey? plus how can I add exceptions for e.g. a > b
05:39:22 <fabbomelker> anyone?
05:39:33 <mauke> fabbomelker: what's the type of sample?
05:39:38 <byorgey> fabbomelker: if you paste the code along with a copy of the error you are getting on hpaste.org, I can take a look
05:39:45 <fabbomelker> I havent declared that
05:39:54 <mauke> fabbomelker: yes, but what should it be?
05:39:57 <fabbomelker> but should return a float array
05:40:04 <mauke> fabbomelker: 0 isn't a float array
05:40:13 <fabbomelker> ah
05:40:16 <rrc7cz> in lisps you have an apply fn, which allows you to apply an arguments list to a fn like (apply sum [1 2 3 4]) where sum would normally be invoked like (sum 1 2 3 4), in other words taking var args, not a list itself. How do you do this in Haskell? It's a sort of unrolling a collection and splicing its elements in as args
05:40:23 <byorgey> fabbomelker: I highly recommend declaring the types of all your functions, especially when learning
05:40:26 <mauke> rrc7cz: you don't
05:40:42 <hpc> fabbomelker: haskell uses lists as the preferred "collection" type, rather than arrays
05:40:43 <byorgey> fabbomelker: that way the type checker will be able to give you much more specific and helpful errors
05:40:46 <fabbomelker> ok, how would I do that in this case
05:40:50 <hpc> (just fyi)
05:41:09 <mauke> sample :: Double -> Double -> Double -> [Double]
05:41:54 <rrc7cz> fmap (+) [1 2]
05:42:01 <simon> :t Text.Parsec.Token.decimal
05:42:02 <lambdabot> Couldn't find qualified module.
05:42:45 <fabbomelker> changing sample a b 0 = 0 into sample a b 0 = [0] did the trick
05:43:10 <fabbomelker> sample 1 2 10 [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7000000000000002,1.8,1.9]
05:43:25 <fabbomelker> why the 1.7000000000000002 ?
05:43:33 <mauke> welcome to floating point numbers
05:43:36 <fabbomelker> haha
05:43:53 <byorgey> rrc7cz: you cannot do that in Haskell.  In Haskell you just make the function 'sum' take a list as an argument in the firts place.
05:44:28 <mauke> fabbomelker: floating point numbers use a binary representation. you can't represent 0.1 exactly in base 2
05:44:46 <mauke> preflex: calc '2 1 / 10
05:44:46 <preflex>  0.00011001100110011001100110011001100110011001100110011
05:46:26 <fabbomelker> are there any defined basic functions in prelude? e.g. sin, cos, exp, etc. how do acess them? is there a list somwhere?
05:46:47 <mauke> fabbomelker: http://haskell.org/onlinereport/standard-prelude.html
05:47:31 <byorgey> fabbomelker: also, http://haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/Prelude.html
05:59:06 <simon> I wonder. in the Text.Parsec.Token documentation there is a 'decimal :: ParsecT s u m Integer', but when I :m +Text.Parsec.Token and :t decimal, I get 'decimal :: GenTokenParser s u m -> Text.Parsec.Prim.ParsecT s u m Integer'
05:59:24 <simon> ah! never mind. I am blind. I didn't see the Prim part.
05:59:47 <blaze-x> I'm new, but and for learning purposes I'm trying to write something which can reduce a list of strings into a regex that matches them all (obviously not .*)
06:00:04 <mauke> intercalate "|"
06:01:08 <donri> still need to escape special chars in the strings
06:01:20 <mauke> intercalate "|" . map quotemeta
06:01:42 <mauke> intercalate "|" . map quotemeta . sortBy (flip (comparing length) `mappend` compare)
06:03:25 <donri> @hoogle quotemeta
06:03:25 <lambdabot> No results found
06:04:59 <mauke> quotemeta = concatMap (\c -> (if isAlphaNum c || c == '_' then id else ('\\' :)) [c])
06:05:46 <freeasjesus> what's the haskell offtopic channel called again?
06:05:54 <erus`> -blah
06:06:08 <freeasjesus> cheers
06:07:13 <byorgey> freeasjesus: didn't you just ask that yesterday?  you should write it down on a sticky note and put it next to your computer ;)
06:07:39 <weltensegler> Hello, how can i flush a HandleStream that i get from openTCPConnection from the Module Network.TCP ?
06:07:40 <erus`> i want to design a game that is as simple as possible but with the complexity of chess
06:07:54 <freeasjesus> byorgey: yep, I keep forgetting... kinda used to type in [something]-chat :P will write it down ;)
06:12:32 <byorgey> erus`: try Go
06:12:37 <fabbomelker> hey u guys
06:12:38 <fabbomelker> in integrate f a b n = let feval = map f (sample a b n) in summa feval
06:13:05 <fabbomelker> i want to add en extra declaration, let dx = (b-a)/n
06:13:20 <fabbomelker> how do I squeeze that in?
06:13:40 <mauke> either you nest your let..in's or you do it directly
06:13:47 <mauke> let { a = 1; b = 2 } in ...
06:14:06 <fabbomelker> ty
06:17:09 <ketil> Eh, getElems takes a lot of time for TArray, is that correct?
06:17:30 <ketil> Perhaps I can use unsafeFreeze or something instead?
06:17:48 <ketil> (I just need to singlethreadedly extract the information)
06:23:58 <dylukes> @seen edwardk
06:23:58 <preflex>  edwardk was last seen on #haskell-blah 4 hours, 33 minutes and 7 seconds ago, saying: The 27th
06:23:59 <lambdabot> Unknown command, try @list
06:24:11 <cizra> How do I split a comma-separated two-colum string at the comma? span seems almost to work, but it retains the comma.
06:24:25 <hpc> :t splitAt
06:24:25 <cizra> I could use takewhile and dropWhile, but I'd prefer a nice split function.
06:24:26 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:24:33 <hpc> :t split
06:24:33 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
06:24:34 <dylukes> relevant maybe?
06:24:35 <dylukes> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
06:24:37 <hpc> hmm
06:24:42 <dylukes> the split package has more splitting
06:24:57 <cizra> splitOn!
06:25:11 <dylukes> split on dude.
06:25:25 <dylukes> split on you crazy list.
06:25:28 <donri> extercalate
06:28:57 <ClaudiusMaximus> cizra: use span with a little post processing i guess
06:29:02 <ClaudiusMaximus> > let f [] = [] ; f xs = let (a, b) = break (== ',') xs in a : f (drop 1 b) in f ",c,o,m,m,a,,s,"
06:29:03 <lambdabot>   ["","c","o","m","m","a","","s"]
06:30:44 <danr> cizra: maybe you want to look at unintercalate in Data.List.Split in the split package
06:30:51 <cizra> ClaudiusMaximus: I think that's what I'll do.
06:31:14 <danr> um, which happens to be a synonym for splitOn as you suggests
06:31:19 <benmachine> cizra: 'unfoldr' might help you
06:31:36 <ClaudiusMaximus> there's also some csv packages that do this kind of thing while also taking care of quoting (or something, not used them)
06:31:51 <benmachine> oh wait
06:32:03 <benmachine> if it's only two columns, can't you just do
06:32:15 <benmachine> import Control.Arrow (second)
06:32:27 <benmachine> :t second (drop 1) . break (== ',')
06:32:28 <lambdabot> [Char] -> ([Char], [Char])
06:33:28 <ClaudiusMaximus> @check \f ab -> fmap f ab == second f ab
06:33:29 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
06:33:29 <lambdabot>    arising from a use of `...
06:34:33 <benmachine> @check \f ab -> fmap f ab == second (f :: String -> String) ab
06:34:34 <lambdabot>   Overlapping instances for GHC.Show.Show
06:34:34 <lambdabot>                              (GHC.B...
06:34:46 <benmachine> hmph
06:35:07 <benmachine> I like how you got more error message printed because it didn't have so much pointless whitespace >_>
06:35:15 <byorgey> @type \f ab -> fmap f ab == second f ab
06:35:16 <lambdabot> forall a b d. (Eq d, Eq b) => (a -> b) -> (d, a) -> Bool
06:35:47 <benmachine> oh right, might be the d that's the problem
06:36:01 <ClaudiusMaximus> @check \f ab -> fmap f ab == second (f :: String -> String) (ab `asTypeOf` ("",""))
06:36:02 <benmachine> @check \f ab -> fmap f ab == second (f :: String -> String) (ab :: (String,String))
06:36:02 <lambdabot>   Overlapping instances for GHC.Show.Show
06:36:02 <lambdabot>                              (GHC.B...
06:36:03 <lambdabot>   Overlapping instances for GHC.Show.Show
06:36:03 <lambdabot>                              (GHC.B...
06:36:06 <benmachine> fff
06:36:07 <byorgey> no, the problem is that QC wants to be able to print counterexamples
06:36:14 <benmachine> oh, true
06:36:26 <byorgey> @check \(Blind f) ab -> fmap f ab == second f ab
06:36:26 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
06:36:27 <lambdabot>                     (Test.QuickC...
06:36:39 <benmachine> *one of the problems
06:36:53 <chrisdone> is there a tool to go through your codebase and tell you what files and what declarations aren't documented?
06:36:53 <lambdabot> chrisdone: You have 3 new messages. '/msg lambdabot @messages' to read them.
06:37:16 <byorgey> @check \(Blind (f :: String -> String)) (ab :: (Int, String)) -> fmap f ab == second f ab
06:37:16 <lambdabot>   Parse error in pattern at "(ab" (column 34)
06:37:50 <benmachine> chrisdone: I think haddock prints coverage information nowadays, so that'll tell you the files part
06:38:00 <byorgey> @check \(Blind f) ab -> fmap (f :: String -> String) (ab :: (Int,String)) == second f ab
06:38:01 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
06:38:01 <lambdabot>                     (Test.QuickC...
06:38:01 <chrisdone> i'll give that a go
06:38:03 <ClaudiusMaximus> chrisdone: not a complete answer, but haddock gives me coverage stats telling me 0/123 decls are documented or whatever, on a per-file basis
06:38:06 * byorgey gives up
06:38:19 <chrisdone> ClaudiusMaximus: nice, very nice. i'll try it
06:38:39 * ClaudiusMaximus slow and buggy today
06:38:50 <benmachine> you get something like haddock coverage for Primes.hs:     5/6  83%
06:39:24 <ClaudiusMaximus> but it only considers exported definititions
06:39:52 <fryguybob> @check \s ab -> let f = const s in fmap f ab == second f ab
06:39:53 <lambdabot>   "OK, passed 500 tests."
06:40:10 <chrisdone> ClaudiusMaximus: ah… i have some modules where i don't explicitly export things :/
06:40:40 <benmachine> chrisdone: you can tell haddock to ignore export lists
06:40:57 <ClaudiusMaximus> well, i think that means all are exported, and you'll get stats, but i'm not sure i tried that
06:41:12 <mm_freak> @src many
06:41:12 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:41:18 <mm_freak> @src Alternative many
06:41:18 <lambdabot> Source not found. :(
06:41:58 <benmachine> cabal haddock --haddock-option=--ignore-all-exports
06:41:59 <benmachine> perhaps
06:44:53 <Axman6> > maxBound :: Word16
06:44:54 <lambdabot>   65535
06:46:33 <absentia> maxBound :: Word64
06:46:46 <absentia> > maxBound :: Word64
06:46:47 <lambdabot>   18446744073709551615
06:47:10 <chrisdone> benmachine: ClaudiusMaximus: what option gives you coverage?
06:50:17 <chrisdone> maybe i need to upgrade
06:51:29 <dylukes> What package would people recommend for (de)serializing Data.Data instances?
06:52:06 <shachaf> dylukes: Is that what Data.Data.Data is for?
06:52:26 <mm_freak> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
06:52:26 <lambdabot> forall a b (f :: * -> *) a1 (f1 :: * -> *). (Functor f1, Functor f) => (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
06:52:36 <dylukes> dylukes: no, Data.Data.Data has the routines for unfolding and refolding and whatnot of data structures.
06:52:41 <mm_freak> huh?
06:52:44 <Axman6> would Data.Data.Data.Data be reexported as Data.MetaData?
06:52:44 <dylukes> I need something that defines how to take that and serialize.
06:52:54 <shachaf> mm_freak: fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap === fmap fmap fmap fmap fmap fmap -- :-(
06:53:09 <mm_freak> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
06:53:10 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f1, Functor f, Functor f2) => f1 (a -> b) -> f1 (f (f2 a) -> f (f2 b))
06:53:14 <dylukes> http://hackage.haskell.org/package/binary-generic
06:53:15 <shachaf> dylukes: Why do you need that?
06:53:16 <dylukes> this looks about right
06:53:19 <mm_freak> hmm
06:53:19 <shachaf> I don't think Data.Data is sufficient.
06:53:31 <mm_freak> GHCi gives me pages of a type there
06:53:33 <shachaf> Oh, well, maybe it is.
06:53:37 <mm_freak> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
06:53:38 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f1, Functor f, Functor f2) => f1 (a -> b) -> f1 (f (f2 a) -> f (f2 b))
06:53:47 <mm_freak> probably doesn't display the type in full
06:53:55 <dylukes> shachaf: because I have AST data types.
06:53:58 <mm_freak> or it's Caleskell
06:54:03 <mm_freak> :t fmap
06:54:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:54:04 <dylukes> And I'm waaaaay too lazy to define how I'm going to serialize my intermediate representation.
06:54:08 <mm_freak> no, it isn't
06:54:14 <dylukes> I need a binary format to just keep it in that isn't text.
06:54:25 <dylukes> might as well be haskelly and just derive everything :)
06:54:35 <shachaf> dylukes: Use the new Generics thing.
06:54:42 <dylukes> shachaf: Data.Data IS the new generics thing.
06:54:56 <shachaf> dylukes: Isn't it the old Generics thing?
06:55:00 <dylukes> :\
06:55:01 <shachaf> I'm talking about the (:+:) thing.
06:55:13 <dylukes> well, my goal is just to be able to auto derive Binary
06:55:23 <shachaf> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/generic-programming.html
06:55:23 <benmachine> chrisdone: yeah, I get it with no options but iirc it's a recent feature
06:55:29 <dylukes> http://darcs.haskell.org/binary/tools/derive/BinaryDerive.hs
06:55:31 <dylukes> FFFFFFF
06:55:35 <dylukes> :<
06:55:42 <shachaf> dylukes: Or use TH or something.
06:55:57 <chrisdone> there's a new new generic thing
06:56:01 <benmachine> mm_freak: it's because you haven't got the Functor ((->) r) instance in scope
06:56:07 <dylukes> I'll try the new generic stuff.
06:56:09 <benmachine> but lb has
06:56:53 <dreixel> dylukes: I suggest the new generic stuff. Let me know if you run into trouble.
06:57:12 <dylukes> mmk
06:57:16 <dylukes> I just want to see how I can derive Binary :<
06:57:31 <dreixel> by giving appropriate instances :)
06:57:36 <dylukes> ?
06:57:42 <mm_freak> benmachine: huh?
06:57:44 <dylukes> Generics have so much potential, if we had a mechanism to define how to derive our own type classes with them...
06:57:57 <dylukes> dreixel: I don't want to have to write instances for each thing :P
06:58:03 <benmachine> mm_freak: huh huh?
06:58:06 <dreixel> well, that's what this is about
06:58:10 <dylukes> just a "derive GenericBinaryThing" would be nice
06:58:14 <dreixel> you only have to give instances for the representation tyeps
06:58:17 <dreixel> the rest comes for free
06:58:38 <dreixel> not exactly like that, but more like "instance GenericBinary MyType" (no instance body)
06:59:03 <dreixel> dylukes: http://www.haskell.org/haskellwiki/Generics has an example of generic serialization
06:59:09 <dylukes> I was just reading
07:05:17 <cizra> I want to combine a [(key, value)] into a map. The problem is that different values repeat, so in the end I should have a Map key [value].
07:05:20 <cizra> So here's the question:
07:05:32 <cizra> how do I iterate over a list only for the side effect? With explicit recursion?
07:05:48 <shachaf> cizra: What side effect?
07:06:03 <cizra> shachaf: getting the elements appended to the map-value-lists.
07:06:09 <shachaf> You probably want a fold or something like that.
07:06:16 <shachaf> How are you expressing this side effect, exactly?
07:06:20 <shachaf> Functions don't have side effects.
07:06:34 <cizra> That's what I'm wondering (=
07:06:43 <shachaf> Are you using a monad like State or something? It's probably overkill for this, but if so you'd use mapM_.
07:06:50 <cizra> So I should be able to use a foldl'?
07:06:55 <cizra> No State here.
07:06:57 <shachaf> cizra: You'd do best to forget about side effects. :-)
07:07:04 <shachaf> cizra: foldl' would work.
07:07:15 <cizra> It should be a pure function from [(key, value)] into Map key [value].
07:07:34 <EEVIAC_> but what happens when two values repeat
07:07:37 * cizra goes back to think
07:07:48 <cizra> EEVIAC_: then they both get appended.
07:07:56 <EEVIAC_> ah
07:07:58 <Entroacceptor> :t foldl'
07:07:59 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:08:03 <shachaf> cizra: Does the order in the [value] list matter? Presumably not?
07:08:19 <cizra> no
07:08:22 <EEVIAC_> why not just do map snd?
07:08:38 <cizra> EEVIAC_: because keys matter
07:08:52 <EEVIAC_> oh wait i misread
07:08:52 <EEVIAC_> sorry
07:08:57 <shachaf> An easy but inefficient way is to do groupBy . sortBy.
07:09:07 <EEVIAC_> use fromListWith then
07:09:08 <cizra> Actually, now that I think of it, the value container should be a Set, not a list.
07:09:28 <shachaf> Oh, I didn't know about fromListWith.
07:09:59 <cizra> :t fromListWith
07:10:00 <lambdabot> Not in scope: `fromListWith'
07:10:08 <EEVIAC_> > Map.fromListWith (++) . map (\(x,y) -> (x,[y])) $ [(1,2),(1,3),(2,4)]
07:10:09 <lambdabot>   Not in scope: `Map.fromListWith'
07:10:13 <Peaker> shachaf: did you read conal's Type Class Morphisms paper?
07:10:31 <shachaf> Peaker: No. Context?
07:10:36 <EEVIAC_> > Data.Map.fromListWith
07:10:37 <lambdabot>   Not in scope: `Data.Map.fromListWith'
07:10:39 <EEVIAC_> hmmm
07:10:49 <shachaf> @ty M.fromListWith
07:10:50 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
07:11:22 <nooodl> hoogle says there's no unfoldl for anything but Data.Sequence. why's that?
07:11:25 <Peaker> shachaf: He defines TMap (total-map), which is much nicre than Data.Map
07:11:36 <nooodl> unfoldr is in Data.List, so i'd expect unfoldl to be there too
07:11:36 <Peaker> shachaf: and stuff like fromListWith are composed from nicer things
07:11:46 <shachaf> > M.fromListWith (++) . map (second (:[])) $ [(1,2),(1,3),(2,4)]
07:11:48 <lambdabot>   fromList [(1,[3,2]),(2,[4])]
07:11:58 <Peaker> I wish the standard library had TMap and people gradually moved from Data.Map to it
07:12:09 <Axman6> TMap?
07:12:21 <Axman6> @hoogle TMap
07:12:22 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
07:12:22 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
07:12:22 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
07:12:26 <Peaker> Axman6: http://conal.net/papers/type-class-morphisms/
07:12:28 <Axman6> -_-
07:12:46 <cizra> shachaf: second? What's second?
07:13:12 <Peaker> Axman6: the idea is that:  [[TMap k v]] = [[k]] -> [[v]]
07:13:17 <nooodl> @hoogle unfoldl
07:13:17 <lambdabot> No results found
07:13:23 <shachaf> second :: (a -> b) -> (x,a) -> (x,b)
07:13:24 <Peaker> ([[ x ]]  is notation for "the meaning of x")
07:13:34 <nooodl> weeeird
07:13:40 <shachaf> Peaker: Yes, I've seen a talk by conal before. :-)
07:13:46 <EEVIAC_> > second (+1) (5,6)
07:13:47 <Peaker> Axman6: And TMap is mostly defined by the Functor, Applicative, etc instances for (->)
07:13:47 <lambdabot>   (5,7)
07:13:51 <cizra> shachaf: Where does it come from? Which package?
07:13:59 <shachaf> cizra: It's in the module Control.Arrow.
07:14:20 <cizra> shachaf: Control.Arrow should be installed in base, right? My ghci doesn't have it )=
07:14:33 <Peaker> Axman6: so:  fmap on TMap changes the v, as in function types.       pure Nothing   gives a TMap that behaves like a Data.Map (background value of Nothing)
07:14:54 <shachaf> cizra: It's in my base. What version of GHC/base are you using?
07:14:55 <Peaker> I am not sure if conal's TMap could enumerate the keys though, like a Data.Map
07:15:02 <chrisdone> benmachine: seems like i'll have to upgrade to ghc7 to get the new haddock goodies ;_;
07:15:05 <cizra> The Glorious Glasgow Haskell Compilation System, version 7.0.3
07:15:07 <Axman6> i'd need to see its usage to see its use i think
07:15:16 * shachaf adds paper to list.
07:15:19 <cizra>     Installed versions: (4.3.1.0)
07:15:20 <nooodl> @src seq
07:15:21 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:15:23 <Peaker> Axman6: it's just a more-elegant-Data.Map
07:15:26 <benmachine> chrisdone: oh no how terrible?
07:15:28 <Peaker> Axman6: used for the same things
07:16:16 <benmachine> Peaker: how does it compare performancewise?
07:16:16 <Peaker> Axman6: with very very few primitives, and standard function type instances, you get all of the power of Data.Map, so instead of an API of many dozens of functions to learn, you learn just 2-3 functions, and reapply your existing knowledge of how function instances work
07:16:21 <Peaker> benmachine: I have no idea
07:16:27 <chrisdone> benmachine: yeah i've got 40~ dependencies on this project that need migrating to ghc7 too. that's a lot of fun that i totally have time and motivation for ;)
07:16:32 <cizra> shachaf: Sounds recent enough?
07:16:42 <shachaf> cizra: Are you sure you don't have it?
07:16:47 <Peaker> benmachine: the implementation of a TMap could use Data.Map under the hood :)
07:16:50 <benmachine> chrisdone: you could probably install ghc7 alongside ghc6?
07:16:58 <Peaker> benmachine: the point is more the interface/denotation than the implementation
07:17:01 <Axman6> Peaker: is it basically just maps constructed from functions instead of an actual data type?
07:17:08 <benmachine> chrisdone: then use new haddock on old code, perhaps
07:17:20 <benmachine> (perhaps. I don't know if haddock works like that)
07:17:20 <cizra> shachaf: Oooops, sorry )= I made a typo.
07:17:23 <chrisdone> benmachine: it is, yeah, i thought of trying to build haddock with it, but dunno if haddock will try to call ghc7 directly. we'll see
07:17:24 <Peaker> Axman6: the denotation/semantics are defined as functions.. The implementation might as well use a Data.Map in there
07:17:34 <Axman6> ah, i see
07:17:37 <chrisdone> benmachine: before that i can cheat and change haddock's .cabal file and see if it builds :D
07:17:47 <benmachine> hah
07:17:51 <benmachine> good luck with that
07:18:14 <Axman6> because it seemed to me that you're turning many operations that used to be O(log n) into O(n). but i guess if that's not the point, then ok then
07:18:41 <Peaker> Axman6: the point is the simpler semantics -- reapplying existing proofs and knowledge rather than inventing new ones
07:19:37 <Peaker> The semantics of Data.Map is basically a function + partiality + key-enumeration.  TMap puts partiality aside, and gains totality, which makes it a fit for function instances (gaining partiality back is trivial, using e.g: "pure Nothing") . Not sure what it does regarding enumeration of keys
07:19:45 <chrisdone> heh, no release notes on haddock's home page since 2.8.0
07:19:55 <chrisdone> f*ck it, we'll do it live!
07:22:51 <chrisdone> benmachine: nah, no chance i'm gonna get this to build on 6.12.3
07:23:17 <benmachine> mm
07:23:20 <hpaste_> nooodl pasted “unfoldl” at http://hpaste.org/52239
07:23:38 <nooodl> ^ why is this giving a parse error
07:23:44 <chrisdone> haskell makes it hard to maintain a large codebase over time
07:24:27 <benmachine> nooodl: the indentation on the case is wrong
07:24:53 <benmachine> nooodl: the way it works is the first thing after the 'where' keyword sets the indentation level for that where-block
07:24:57 <shachaf> nooodl: It's considered polite to paste the parse error as well as the code. :-)
07:25:09 <shachaf> nooodl: The third and fourth lines need to be indented past the =.
07:25:24 <benmachine> shachaf: they actually only need to be indented past the r
07:25:38 <shachaf> Oh, true.
07:25:38 <benmachine> (but the way I'd do it is put the r on a separate line, and have 'where' on its own)
07:25:46 <hpc> chrisdone: i've never had a problem with it
07:25:49 <benmachine> (then r can be more to the left, so you've got more space)
07:26:04 <nooodl> i really don't get haskell indentation rules
07:26:23 <nooodl> many programs i've seen tend to slant to the right a lot, which i really don't like
07:26:33 <chrisdone> hpc: good for you
07:27:11 <donri> chrisdone: because the fast-moving community and incompatibility between versions?
07:28:18 <chrisdone> donri: that's right
07:28:27 <yitz> nooodl: the first non-white-space after one of the magic words anchors the indentation at the column of the non-white-space
07:28:37 <yitz> nooodl: that's basically it.
07:28:37 <chrisdone> C# comparatively is easy
07:28:54 <shachaf> yitz: DoAndIfThenElse
07:28:55 <nooodl> yitz, magic words?
07:29:15 <nooodl> oh.
07:29:21 <matthiasgorgens> What's the recommended library to start with functional reactive programming?  I liked the paper about push-pull FRP, but the associated library (reactive) warns of bugs in itself.
07:29:24 <yitz> nooodl: let where of do
07:29:35 <shachaf> Actually, that doesn't affect it, does it?
07:29:49 <ski> chrisdone : hm, i can't recall whether i already mentioned this before, but <http://hpaste.org/10060/repaste_of_poormandebug> originally had <http://hpaste.org/10061/example_usage> as an annotation -- is that anything that would be quick to fix ?
07:30:03 <shachaf> I was thinking of something else.
07:30:49 <yitz> matthiasgorgens: if you want simple, use apfelmus' banana frp. if you want the way of the future, use reactive.
07:31:21 <chrisdone> ski: look again
07:31:40 <ski> ah, ty ! :)
07:31:45 <chrisdone> welcome :)
07:31:50 <matthiasgorgens> yitz, thanks.  We are thinking about replacing a messy subsystem in production code.  The warning about bugs had me frightened..
07:32:10 <yitz> matthiasgorgens: hmm, not sure about either library for production code...
07:32:15 <matthiasgorgens> ok.
07:32:35 <yitz> mathandemotion: ask apfelmus if banana is fitting for your purpose. it might be.
07:32:50 <matthiasgorgens> It's not too bad if it crashes.  The daemon is meant to be restartable.  It just shouldn't crash always, or give false answers.
07:33:37 <matthiasgorgens> yitz, I'll have a look, and then ask.
07:33:43 <chrisdone> i'm starting the moving to open source process now… (need to remove all those embarrassing working-against-deadline functions ;) so i will want to upgrade to ghc7 anyway, if i want anyone to be able to build it
07:33:56 <yitz> matthiasgorgens: sounds like a good plan
07:40:21 <mathandemotion> yitz: ?
07:40:56 <danr> Is it correct to say that iterate is not strict in any argument?
07:41:09 <benmachine> > iterate undefined undefined
07:41:10 <lambdabot>   [*Exception: Prelude.undefined
07:41:16 <saml> hey, wanna start  a haskell enterprise cms project?
07:41:21 <danr> benmachine: well it produces a cons
07:41:28 <benmachine> danr: then yes
07:41:29 <dmwit> ?src iterate
07:41:29 <lambdabot> iterate f x =  x : iterate f (f x)
07:41:38 <danr> > length (take 10 (iterate undefined undefined))
07:41:39 <lambdabot>   10
07:41:52 <dmwit> danr: Yes, it's correct.
07:42:02 <danr> benmachine: dmwit: Ok, thanks!
07:44:23 <dmwit> Does cabal have a way to say that a library requires a recent GHC?
07:44:33 <yitz> mathandemotion: yo
07:44:36 <hpaste_> Peaker pasted “TMap - can anyone add a denotational enum of keys, or beautify impl?” at http://hpaste.org/52240
07:44:37 <dcoutts> dmwit: requires in what sense?
07:44:46 <dmwit> Kind of like build-depends: ghc >= 7.2, except that I don't actually depend on the ghc *library*.
07:44:52 <hpc> dmwit: you could make it require a recent version of base
07:45:19 <dmwit> dcoutts: In the sense that it definitely won't build with any GHC before 7.4. =P
07:45:47 <dmwit> And so cabal shouldn't even bother trying.
07:46:26 <dcoutts> dmwit: right, but why? because of something in a core lib, because of some language extension?
07:46:30 <mathandemotion> yitz: ah, now I saw the context. looks like you highlighted me by accident. I just read banana and apfelmus and got confused
07:47:00 <dmwit> dcoutts: Because I use superclass equality constraints, which weren't supported in 7.2 (even though they're syntactically okay just by enabling the TypeFamilies extension).
07:47:32 <dcoutts> dmwit: ok, so due to a change in the meaning of a language extension
07:47:33 <dmwit> There's no extension that distinguishes between SEC-enabled GHC's and non-SEC-enabled GHC's, unfortunately.
07:47:37 <dmwit> right
07:47:41 <yitz> mathandemotion: oh, yeah, sorry. i typed ma<TAB> and irssi gave me some long nick. i didn't bother reading it.
07:47:46 <dcoutts> dmwit: yeah, that's unfortunate
07:47:53 <ski> "SEC-enabled" ?
07:47:58 <mathandemotion> yitz: no problem
07:48:02 <dmwit> ski: superclass equality constraint-enabled
07:48:10 <yitz> mathandemotion: matl;dr
07:48:18 <mathandemotion> :D
07:48:28 <ski> ty
07:49:15 <dmwit> hpc: Interesting idea.
07:49:37 <dmwit> Does anybody have a GHC 7.2 install lying around that wants to tell me which version of base it comes with?
07:49:43 <dcoutts> dmwit: see you don't really want to depend on ghc, since then if any other compiler even implements the same extension then it's overrestrictive
07:49:51 <yitz> dmwit: i thought what hpc said is the standard idiom
07:49:52 <dmwit> dcoutts: agreed
07:50:03 <dcoutts> dmwit: 4.4.0.0
07:50:03 <dmwit> dcoutts: Even if there were a way, I'd surely stick it in an if impl(ghc) block.
07:50:29 <dmwit> dcoutts: thanks
07:50:58 <dcoutts> dmwit: yeah, so base is probably the least bad proxy for what you want
07:51:17 <dmwit> Seems base hasn't (yet) switched to a higher version number in HEAD.
07:51:30 <dmwit> I guess I'll have to wait for a release to see if that will help. =P
07:51:47 <dmwit> Anyway, thanks for the advice, everyone.
07:52:57 * hackagebot HaTeX 3.0.0 - LaTeX code writer.  http://hackage.haskell.org/package/HaTeX-3.0.0 (DanielDiaz)
07:52:59 * hackagebot HaTeX-meta 1.0.0 - HaTeX monad modules builder.  http://hackage.haskell.org/package/HaTeX-meta-1.0.0 (DanielDiaz)
08:03:50 <Rmx> > 7 ++ 7
08:03:51 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:03:52 <lambdabot>    `Data.Monoid.Monoid a'
08:03:52 <lambdabot>  ...
08:04:50 <dmwit> > getSum (7 ++ 7)
08:04:51 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum a))
08:04:51 <lambdabot>    arising from a use of ...
08:05:00 <dmwit> WHY is there no Num instance?
08:05:10 <shachaf> dmwit: Would it be (+) or (*)?
08:05:19 <dmwit> Would *what* be (+) or (*)?
08:05:26 <dmwit> (+) wouldl be (+) and (*) would be (*)
08:05:27 <shachaf> Oh, wait.
08:05:27 <dolio> Oversight.
08:05:35 <shachaf> An instance Sum Num thing.
08:05:36 <copumpkin> shachaf: it could easily derive Num on the newtype
08:05:43 <shachaf> Never mind.
08:05:48 <copumpkin> instance Num Skull
08:05:55 <dolio> HNNNNG! Haskell 98 compatibility!
08:07:29 <tac-tics> SCS: Soup
08:07:32 <tac-tics> SCS: also http://c.learncodethehardway.org/book/
08:07:33 <tac-tics> :D
08:07:40 <tac-tics> damnit wrong channel
08:08:14 <tac-tics> Although, I think #haskell ought to level with people, and write a book of a similar title for Haskell
08:08:19 <erus`> > (+ . +) 1 2 3
08:08:20 <lambdabot>   <no location info>: parse error on input `.'
08:08:34 <erus`> > ((+) . (+)) 1 2 3
08:08:36 <lambdabot>   6
08:08:44 <erus`> > (+) . (+) 1 2 3
08:08:44 <lambdabot>   No instance for (GHC.Show.Show (f (a -> a)))
08:08:45 <lambdabot>    arising from a use of `M396...
08:09:00 <byorgey> tac-tics: hehe, I like that idea.  Chapter 1. Kan extensions.
08:11:44 <tac-tics> byorgey: I don't know what Kan extensions are, but seriously, we're gonna stick a chapter in there about that old monomorphism restriction shit
08:12:12 <tac-tics> I got stuck for about 30 minutes last night trying to hammer a single expression in GHCi because I had let two expressions to be integer literals
08:12:15 <shachaf> That's not hard, just annoying.
08:12:19 <tac-tics> and I KNEW it was a monomorphism restriction issue
08:12:27 <tac-tics> but I couldn't find the second instance
08:12:30 <shachaf> :set -XNoMonomorphismRestriction
08:12:44 <tac-tics> I still would have had to retype it all T___T
08:12:50 <shachaf> ?
08:12:59 <shachaf> You know about up-arrow in ghci, right?
08:13:06 <tac-tics> lesson learned: GNU readline is not a fair substitue for a file
08:13:13 <tac-tics> yeah
08:13:13 <erus`> @pl (\x y -> [1,(y+1)..(x-1)])
08:13:14 <lambdabot> flip (enumFromThenTo 1 . (1 +)) . subtract 1
08:13:41 <erus`> > let divide = flip (enumFromThenTo 1 . (1 +)) . subtract 1 in divide 10 3
08:13:43 <lambdabot>   [1,4,7]
08:13:55 <erus`> @pl (\x y -> length [1,(y+1)..(x-1)])
08:13:55 <lambdabot> (length .) . flip (enumFromThenTo 1 . (1 +)) . subtract 1
08:14:10 <erus`> > let divide = (length .) . flip (enumFromThenTo 1 . (1 +)) . subtract 1 in divide 10 3
08:14:12 <lambdabot>   3
08:14:14 <erus`> :D
08:14:14 <dmwit> :t unfoldr
08:14:15 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:14:32 <erus`> > let divide = (length .) . flip (enumFromThenTo 1 . (1 +)) . subtract 1 in divide 10 2
08:14:33 <lambdabot>   5
08:15:06 <erus`> do i win silliest function of the day?
08:15:19 <dmwit> :t \y x -> unfoldr (\z -> guard (z > 0) >> return (z-y, z-y)) x
08:15:20 <lambdabot> forall b. (Num b, Ord b) => b -> b -> [b]
08:15:24 <absentia> looks like bad forth.
08:15:30 <dmwit> ?unpl \y x -> unfoldr (\z -> guard (z > 0) >> return (z-y, z-y)) x
08:15:30 <lambdabot> \ y x -> unfoldr (\ z -> (guard (z > 0)) >> (return ((z - y), (z - y)))) x
08:15:36 <dmwit> err
08:15:38 <dmwit> ?pl \y x -> unfoldr (\z -> guard (z > 0) >> return (z-y, z-y)) x
08:15:38 <lambdabot> unfoldr . ap ((>>) . guard . (> 0)) . (return .) . ap (ap . ((,) .) . subtract) subtract
08:16:03 <absentia> when did haskell become funtional-forth?
08:16:46 <mauke> forth: functional orth
08:18:07 <tac-tics> @check \k -> k < 0 || k * k * k == sum $ take k $ drop (sum [1..k-1]) $ let odds = 1 : map (+2) odds in odds
08:18:08 <lambdabot>   Couldn't match expected type `a -> b'
08:18:13 <tac-tics> damnit lambdabot
08:18:38 <tac-tics> @check \k -> k < 0 || k * k * k == sum $ take k (drop (sum [1..k-1]) $ let odds = 1 : map (+2) odds in odds)
08:18:39 <lambdabot>   Couldn't match expected type `a -> b'
08:18:44 <tac-tics> sigh oh well
08:19:21 <byorgey> tac-tics: $ has lower precedence than ||
08:19:38 <byorgey> and ==
08:20:20 <tac-tics> @check \k -> k < 0 || k * k * k == sum (take k (drop (sum [1..k-1]) (let odds = 1 : map (+2) odds in odds)))
08:20:21 <lambdabot>   "OK, passed 500 tests."
08:20:23 <tac-tics> woot
08:21:21 <dmwit> @check \k -> k >= 0 ==>  k * k * k == sum (take k (drop (sum [1..k-1]) (let odds = 1 : map (+2) odds in odds)))
08:21:22 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:21:22 <lambdabot>                     (Test.QuickCh...
08:21:23 <erus`> @check \k -> True
08:21:24 <lambdabot>   "OK, passed 500 tests."
08:21:35 <quicksilver> I think ==> is the idiomatic way to do the short-circuiting || you have there
08:21:44 <quicksilver> oh, like dmwit did. Only it didn't work
08:21:45 <dmwit> @check \k -> (k >= 0) ==> (k * k * k == sum (take k (drop (sum [1..k-1]) (let odds = 1 : map (+2) odds in odds))))
08:21:46 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:21:46 <lambdabot>                     (Test.QuickCh...
08:21:49 <dmwit> huh
08:21:51 <dmwit> :t (==>)
08:21:52 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
08:23:02 <byorgey> weird, it Works For Me (tm)
08:23:23 <dmwit> ?check \x -> True ==> True
08:23:28 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:23:32 <lambdabot>                     (Test.QuickCh...
08:23:35 <byorgey> hah, what
08:23:40 <dmwit> Well, that can't be right.
08:23:53 <dmwit> ?undefine
08:23:54 <byorgey> Prelude Test.QuickCheck> quickCheck $ \x -> True ==> True
08:23:54 <byorgey> +++ OK, passed 100 tests.
08:24:10 <dmwit> ?check \x -> True ==> True
08:24:10 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:24:11 <lambdabot>                     (Test.QuickCh...
08:24:19 <int-e> @type (==>)
08:24:20 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
08:24:32 * dmwit throws his hands up
08:25:04 <byorgey> gross
08:25:35 <shachaf> It used to work in lambdabot.
08:25:38 <dmwit> You think that's gross, you didn't even have to taste them going down.
08:25:42 <int-e> anyway, there's a semantic difference in using ==>, too: If the first argument is false, the test is not counted as a test.
08:26:07 <shachaf> int-e: Right, which is often what you want for that sort of thing.
08:26:29 <int-e> sure.
08:26:59 <Saizan> @check \() -> True ==> True
08:26:59 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:27:00 <lambdabot>                     (Test.QuickCh...
08:27:25 <dmwit> ?check True ==> True
08:27:25 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:27:26 <lambdabot>                     Test.QuickChe...
08:27:26 <int-e> Test.QuickCheck> quickCheck $ \a b c -> (a >= 0 && b >= 0 && c >= 0) ==> a*b*c >= (0 :: Integer)
08:27:30 <int-e> *** Gave up! Passed only 61 tests.
08:28:02 <shachaf> @check undefined ==> undefined
08:28:02 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:28:03 <lambdabot>                     Test.QuickChe...
08:28:27 <dmwit> lambdabot--
08:28:34 <shachaf> @slap lambdabot
08:28:34 <lambdabot> I don't perform such side effects on command!
08:28:59 <warpy> how does the tell work here?
08:29:09 <dmwit> ?tell warpy to go away
08:29:10 <lambdabot> Consider it noted.
08:29:13 <dmwit> ;-)
08:29:20 <dmwit> (Not really, though.)
08:29:22 <shachaf> ?tell warpy to come back
08:29:22 <lambdabot> Consider it noted.
08:29:34 <shachaf> @ask warpy to stay
08:29:34 <lambdabot> Consider it noted.
08:29:37 <warpy> ?tell Cale the project i was doing https://github.com/abhin4v/russel-norvig-ai-problems
08:29:37 <lambdabot> Consider it noted.
08:29:49 <warpy> thanks shachaf
08:29:50 <lambdabot> warpy: You have 3 new messages. '/msg lambdabot @messages' to read them.
08:30:54 <warpy> what is this fascination with ? and @. generally irc bots use ! and :
08:31:11 <int-e> @why?
08:31:11 <lambdabot>  @where <key>, return element associated with key
08:31:52 <int-e> warpy: IIRC, one reason was to avoid clashes with other bots.
08:32:19 <warpy> i see
08:32:23 <shachaf> warpy: lambdabot is no ordinary bot.
08:32:38 <warpy> why is that?
08:32:38 <shachaf> Also, bots use many prefixes; why not this one?
08:32:50 <warpy> does it have super powers?
08:32:51 <int-e> @listchans
08:32:52 <lambdabot> ##freebsd ##logic ##proggit ##villagegreen #agda #arch-haskell #darcs #dtp2010 #esoteric #fedora-haskell #friendly-coders #functionaljava #gentoo-haskell #gentoo-uy #ghc #gp2010 #happs #haskell #
08:32:52 <lambdabot> haskell-blah #haskell-books #haskell-fr #haskell-freebsd #haskell-in-depth #haskell-overflow #haskell.au #haskell.cz #haskell.de #haskell.dut #haskell.hr #haskell.se #hscraft-srv #learnanycomputerlang
08:32:52 <lambdabot> uage #macosx #macosxdev #rosettacode #scala #scalaz #scannedinavian #teamunix #unicycling #uscs2010 #xmonad #yi weird#
08:32:52 <shachaf> I've never seen : but I've seen , and ` and . and such.
08:33:02 <int-e> warpy: it's on too many channels :)
08:33:13 <shachaf> lambdabot can join channels that *end* with # instead of starting with it.
08:33:16 <shachaf> Even you can't do that.
08:33:40 <warpy> ah. super powers indeed!
08:33:57 * warpy hatches plans to steal lambdabot's super powers
08:33:59 <shachaf> Also, lambdabot can be in many channels.
08:34:08 <shachaf> You need special Freenode permission to unlock that power.
08:34:31 <warpy> nice
08:34:42 * Saizan wonders if #dtp2010 is in another timeline
08:34:48 <warpy> i have written two irc bots in clojure
08:35:46 <warpy> shachaf: link me to lambdabot's source?
08:36:00 <int-e> @where lambdabot
08:36:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
08:36:14 <int-e> tsk.
08:36:31 <shachaf> @version
08:36:32 <lambdabot> lambdabot 4.2.2.1
08:36:32 <lambdabot> darcs get http://code.haskell.org/lambdabot
08:36:43 <shachaf> @google link me to lambdabot's source?
08:36:44 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
08:36:45 <lambdabot> Title: Lambdabot - HaskellWiki
08:36:52 <int-e> @where- lambdabot
08:36:52 <lambdabot> Maybe you meant: where where+
08:37:00 <int-e> @where+ lambdabot http://haskell.org/haskellwiki/Lambdabot
08:37:01 <lambdabot> Good to know.
08:37:12 <warpy> ah nice!
08:37:34 <shachaf> @where you
08:37:34 <lambdabot> I'm right here, silly.
08:37:50 <shachaf> ?where ?where
08:37:50 <lambdabot> ?where ?where
08:38:24 <warpy> this looks awesome!
08:40:16 <matthiasgorgens> Is there a combinator in the libraries that does: combinator a f = \b -> a >> f b
08:40:39 <matthiasgorgens> And if not, should it be called (=>>)?
08:40:49 <quicksilver> (a>>).f
08:41:08 <matthiasgorgens> could use that, true.
08:41:09 <matthiasgorgens> Thanks.
08:41:55 <mm_freak> matthiasgorgens: (=>>) is the extend operation for comonads, so it wouldn't be a very good name
08:42:00 <matthiasgorgens> ok.
08:42:18 <matthiasgorgens> >>. might do.
08:42:23 <matthiasgorgens> as a local name.
08:42:29 <byorgey> @type \a f b -> a >> f b
08:42:29 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => m a -> (t -> m b) -> t -> m b
08:42:36 <mm_freak> matthiasgorgens: why not just write it out?
08:42:37 <quicksilver> (a*>).f is even more general.
08:42:48 <matthiasgorgens> oh, yes.
08:42:53 <matthiasgorgens> mm_freak, yes, could do that too.
08:43:08 <mm_freak> matthiasgorgens: doesn't appear to me like a useful combinator TBH
08:43:11 <matthiasgorgens> but who likes unnecessary points?
08:43:38 <mm_freak> not sure whether they're unnecessary
08:44:17 <byorgey> but who doesn't like necessary ones? =)
08:44:33 <matthiasgorgens> no need to like necessary evils. ;o)
08:45:52 <mm_freak> @pl \n -> takeWhile (not . null) . map (take n) . iterate (drop n)
08:45:53 <lambdabot> (takeWhile (not . null) .) . ap ((.) . map . take) (iterate . drop)
08:46:03 <mm_freak> matthiasgorgens: which one do you find easier to read? ;)
08:46:11 <Khaled> hi everybody, I am learning haksell from 6 months now and I'm looking for a team to develop an open source software. Do you know where I can find this ?
08:46:32 <matthiasgorgens> khaled, you should probably start writing a prototype yourself, and then advertise what you already have.
08:46:41 <mm_freak> i agree
08:47:14 <simon> in Text.Parsec.Language, there is emptyDef. in my file, I try to express myDef = emptyDef { commentLine = ..., ... }, but I get the error: `commentLine' is not a (visible) constructor field name
08:47:18 <matthiasgorgens> mm_freak: if you use your variables more than once, points are often easier to read.
08:47:27 <matthiasgorgens> mm_freak: also when you use your variables deeply embedded.
08:47:45 <mm_freak> matthiasgorgens: i find pointfree style, when you express linear data flow
08:47:50 <mm_freak> for everything else i use points
08:47:52 <matthiasgorgens> mm_freak: but variables that are just used at the end of an expression usually don't give much.
08:47:53 <simon> I do import Text.Parsec.Language, but it seems that the constructor LanguageDef hasn't got its field constructors exported.
08:48:01 <matthiasgorgens> mm_freak: exactly.
08:48:15 <quicksilver> my rule of thumb is that, if a name is only used once, it may be worth trying to avoid naming it
08:48:18 <Khaled> ok I understand, have you got an idea ? I wrote a little app which use huffman compression, that's all
08:48:23 <quicksilver> if it's used twice it (more or less) never is.
08:48:24 <matthiasgorgens> and my example was quite linear.
08:48:30 <mm_freak> quicksilver: that would rule out many uses of liftA2
08:48:39 <mm_freak> > liftA2 (+) sin cos 3
08:48:40 <lambdabot>   -0.8488724885405782
08:49:14 <quicksilver> mm_freak: how so?
08:49:40 <matthiasgorgens> quicksilver: unless the double usage is very simple, then you might get a benefit out of the &&&.
08:49:50 <mm_freak> oh, ignore me =)
08:49:52 <quicksilver> oh you mean liftA2 in the (e->) applicative specifically
08:49:55 <quicksilver> not liftA2 in general.
08:49:58 <quicksilver> yes, ditto &&&
08:49:59 <mm_freak> yeah
08:50:19 <quicksilver> certainly if it's simple, yes. That's the (more or less) ;)
08:50:30 <matthiasgorgens> I'm tempted to use the S combinator here:
08:50:39 <matthiasgorgens> RpcAgent.onAgentStarted uuid (writeAgentAddonNodes uuid)
08:50:48 <mm_freak> matthiasgorgens: <*> is the S combinator
08:50:59 <matthiasgorgens> Yes.
08:52:29 <roconnor> dylukes: GHC only complains about recursive module dependencies, not recursive class or instance or anything else dependecies
08:52:55 <dylukes> but, because there's some general behavior that applies to all AST types (Statements, Expresisons, etc)
08:53:01 <dylukes> thats all
08:53:14 <dylukes> What it REALLY is is a constraint synonym
08:53:21 <dylukes> But I can't use constraints yet  :<
08:53:21 <shachaf> Are you sure using a type isn't sufficient?
08:53:27 <roconnor> dylukes: I don't understand the your problem.
08:53:33 <shachaf> Oh, it's just a synonym?
08:53:36 <nooodl> using the S combinator, or <*>, or anything like that, is going to cause a pretty big drop in readability
08:53:37 <dylukes> class (Eq a, Ord a, Show a, Generic a) => AbstractSyntax a
08:53:40 <shachaf> You don't need a where, then.
08:53:43 <dylukes> I know.
08:53:45 <dylukes> Anyways
08:53:47 * shachaf solves problem.
08:53:54 <dylukes> the problem is I have my AbstractSyntax module
08:54:02 <mm_freak> nooodl: how that?
08:54:05 <roconnor> dylukes: is this a module dependcy problem?
08:54:06 <dylukes> well, nevermind, I see a solution
08:54:08 <ddarius> shachaf problem solves.
08:54:11 <dylukes> It was, but I see a way around it.
08:54:30 <roconnor> dylukes: btw, GHC is violating the haskell standard.  Recursive modules should be allowed.
08:54:36 <nooodl> mm_freak, "<matthiasgorgens> I'm tempted to use the S combinator here:"
08:54:37 <dylukes> oh really?
08:54:42 <nooodl> oh. wait,
08:54:49 <roconnor> unless something changed in Haskell 2010
08:54:50 <dylukes> That should be trac'd repeatedly until its fixed :3
08:54:59 <shachaf> dylukes: Feel free to fix it.
08:55:13 <roconnor> dylukes: they won't fix it because they have wrongheaded ideas about separate compilation
08:55:19 <quicksilver> roconnor: GHC does allow recursive modules, surely?
08:55:21 <nooodl> well, basically it really forces you to think about what it says. using S is shorter, but doesn't make a lot of sense in its non-expanded form
08:55:27 <quicksilver> it just requires you to jump through annoying hoops.
08:55:30 <ddarius> roconnor: It allows them, it just requires extra effort.
08:55:32 <dylukes> When do we get constraint kinds?
08:55:34 <roconnor> quicksilver: ya with hoops
08:55:45 <matthiasgorgens> nooodl: only if you only use it once.  In the program the uuid parameter is passed to lots of stuff.
08:55:53 <mm_freak> nooodl: do you mean specifically the S combinator or the more general (<*>)?
08:56:02 <quicksilver> roconnor: so "GHC is violating the haskell standard" is untrue and rather flamebaity ;)
08:56:12 <ddarius> Arguably, the Report doesn't require enough information to be provided to support recursive modules reasonably.
08:56:14 <tac-tics> Haskell has a standard?
08:56:20 <tac-tics> I thought it just had a standards committee....
08:56:29 <quicksilver> tac-tics: it has two! :)
08:56:29 * tac-tics trolls
08:56:33 <tac-tics> lol
08:56:40 <ddarius> It no longer has a standards committee and it has several standards.
08:56:55 <tac-tics> Good thing GHC exists
08:56:57 <parcs> dylukes: with ghc 7.4 which should be released sometime before the end of the universe
08:56:58 <dylukes> er, how can I do an actual type class synonym again?
08:57:06 <tac-tics> GHC, standard by de facto implementation
08:57:11 <dylukes> I recall seeing it at one point.
08:57:17 <roconnor> quicksilver: Not all mutual recursion can be solved by adding *.hs-boot files.
08:57:25 <roconnor> according to the haskellwiki
08:57:45 <parcs> dylukes: class (Foo a, Bar a) => Baz a; instance (Foo a, Bar a) => Baz a
08:58:02 <dylukes> is that decidable?
08:58:04 * hackagebot Unixutils 1.46 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.46 (DavidFox)
08:58:11 <parcs> dylukes: 100% decidable
08:58:33 <dylukes> needs flexible instances though
08:58:37 <dylukes> what is actually meant by "flexible"?
08:58:46 <dylukes> nope
08:58:47 <ddarius> roconnor: If that's true, then the Report is probably requiring something that isn't implementable except by completely discarding separate compilation.
08:58:48 <dylukes> its undecidable.
08:58:49 <dylukes> :D
08:58:58 <ddarius> @wn flexible
08:58:59 <lambdabot> *** "flexible" wn "WordNet (r) 2.0"
08:59:00 <lambdabot> flexible
08:59:00 <lambdabot>      adj 1: extended meanings; capable of change; "a flexible
08:59:00 <lambdabot>             character"; "flexible schedules" [ant: {inflexible}]
08:59:00 <lambdabot>      2: able to flex; able to bend easily; "slim flexible birches"
08:59:01 <lambdabot> [9 @more lines]
08:59:09 <dylukes> parcs: "Constraint is no smaller than the instance head"
08:59:09 <shachaf> dylukes: The error message explains that as well as #haskell can.
08:59:16 <Saizan> dylukes: it requires UndecidableInstances but it's still decidable
08:59:31 <roconnor> ddarius: separate *module* compilation should be discarded.  My modules organize functionality and has nothing to do with units of compilation.
08:59:32 <dylukes> UndecidableInstances is the extension that most scares me.
08:59:41 <parcs> dylukes: that sucks
08:59:46 <dylukes> Like I'm not sure what terrifying things it might do.
08:59:53 <parcs> but undecidableinstances isn't that bad
09:00:16 <quicksilver> GHC has a simplistic decidability checker
09:00:17 <ddarius> roconnor: What is your unit of compilation?
09:00:24 <quicksilver> UndecidableInstances turns off that checker
09:00:30 <Saizan> dylukes: if you're not using fundeps the worst it can do is make the typechecker loop for a while until it gives up
09:00:32 <quicksilver> there are plenty of things obviously decidable that the checker rejects.
09:00:38 <dylukes> fundeps is weird too
09:00:43 <dylukes> type families seem nicer.
09:00:50 <shachaf> dylukes: There's always {-# LANGUAGE CPP #-}
09:00:58 <dylukes> *shudders*
09:01:03 <quicksilver> roconnor: "Your ideas are intriguing to me and I wish to subscribe to your newsletter"
09:01:24 <quicksilver> roconnor: (you should, seriously, write up a good proposal to unlink compilation unit and module)
09:01:26 <dylukes> Carnivorous Progenitor of Problems
09:03:14 <parcs> dylukes: btw flexible is this case means 'not in the form of T a1 a2 a3 ..'
09:03:52 <shachaf> parcs: Where a1, a2, a3 are distinct type *variables*.
09:07:27 <parcs> https://github.com/ghc/ghc/commit/90d70e44d58bc466a65259c6e371707dc86c3d06 -- who's actually going to use that
09:07:59 <shachaf> parcs: Oh, excellent!
09:07:59 <mm_freak> parcs: btw, thanks for updating the wiki page
09:08:11 <fasta> parcs: doesn't seem like the most useless feature ever.
09:08:22 <mm_freak> parcs: but for the sake of teaching i recommend putting in simplified type signatures
09:09:28 <mm_freak> parcs: especially in the withWire and stepWire functions
09:09:54 <parcs> mm_freak: they are simplified :P
09:10:00 <parcs> (no MonadCatchIO constraint)
09:10:11 <parcs> maybe i should just use IO
09:10:13 <parcs> ?
09:11:15 <saml> yes IO is good language
09:11:29 <mm_freak> parcs: probably…  with a note that the type signatures are simplified
09:13:56 <mm_freak> anyway, thanks a lot…  i really appreciate it…  wouldn't have time for that any time soon
09:15:11 <shachaf> When you say type A is smaller than type B, that means it has fewer inhabitants, right?
09:15:22 <shachaf> E.g. (a -> b -> a) is smaller than (a -> a -> a)?
09:15:51 <mm_freak> shachaf: is it?
09:16:04 <shachaf> Is it not?
09:16:11 <mm_freak> i'd say (a -> a -> a) is smaller in that sense
09:16:22 <mm_freak> ah, no
09:16:39 <mux> (a -> b -> a) is smaller; it's more constraining
09:16:42 <mux> is it not?
09:17:00 <mux> err not.
09:17:01 <mm_freak> @djinn a -> a -> a
09:17:02 <lambdabot> f _ a = a
09:17:06 <mux> scratch that :-)
09:17:14 <mm_freak> a -> b -> a = K
09:17:34 <mm_freak> ok, a -> b -> a is smaller
09:18:05 <mux> wait, yeah, I was right
09:18:20 * mux decides to just shut up
09:18:44 <shachaf> mux: Yes, stop being right in #haskell. It's impolite.
09:19:01 <trinithis> *VERY* impolite to be exact.
09:19:10 <quicksilver> well, if a and b are natural numbers, then |a x a -> a| is A^(AxA)
09:19:16 <quicksilver> (A = |a|)
09:19:27 <quicksilver> and the other one is A^(AxB)
09:19:34 <tac-tics> Here at #haskell, we don't need to be right on a regular basis. We have a type checker for that sh**
09:19:48 <mux> shachaf: really sorry about that; I'll make sure not to do that again. :-)
09:19:49 <quicksilver> so a -> b -> a is "smaller" if B is smaller.
09:19:57 <trinithis> That said, you can't be wrong because you get rejected if you are
09:20:50 <tac-tics> @faq Can lambdabot prevent me from committing any act of fallacy?
09:20:50 <lambdabot> The answer is: Yes! Haskell can do that.
09:21:42 <tgeeky> no problem there, cause lambdabot is talking about haskell :O
09:22:00 <matthiasgorgens> @fac Can foo?
09:22:01 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
09:22:33 <matthiasgorgens> Just wanted to check, if any sentence of the form "Can ..?" gets a "Haskell can do that." response.
09:23:14 <tac-tics> @faq
09:23:14 <lambdabot> The answer is: Yes! Haskell can do that.
09:23:25 <tac-tics> Vacuous Faq :)
09:23:26 <shachaf> Is there a nice phrase for "an implementation that doesn't involve _|_"?
09:23:39 <quicksilver> total?
09:23:46 <tac-tics> shachaf: Not an ass man?
09:23:46 <shachaf> I'd want to say "total" or something like that, but e.g. const (const undefined) is total in the sense that it returns non-_|_.
09:23:54 <mux> http://i.imgur.com/ZrOZd.png -- I seriously think I'm going to hell for laughing at that
09:24:07 <quicksilver> in what sense does const (const undefined) involve _|_ though?
09:24:44 <tac-tics> shachaf: strongly normalizing?
09:25:11 <tac-tics> shachaf: const x _|_ is only equal to x under lazy evaluation schemes, but applicatively normalizing schemes can't reduce it to normal form
09:25:22 <tac-tics> strongly normalizing languages always normalize under all strategies
09:26:32 <shachaf> quicksilver: I just want a way to say "the only reasonable implementaion of type T", where T is something like (a -> b) -> (b -> c) -> a -> c.
09:26:58 <shachaf> quicksilver: It involves _|_ in that if the language was total you couldn't write it. :-)
09:27:15 <matthiasgorgens> mux, steve jobs is dead?  I guess I should read more newspapers or so..
09:27:38 <rebuh> steve mobs
09:27:48 <eacameron> I'm new to regex in Haskell...what lib should I use to have Python-like regex?
09:27:52 <Peaker> quite a crook he was, at least when he was younger
09:27:55 <quicksilver> shachaf: "in the total fragment of the language"
09:28:27 <engla> Peaker: businessmen are mostly insubstantial talk
09:29:00 <quicksilver> #haskell-blah is thattaway
09:30:12 <shachaf> quicksilver: I think I'll just use "total".
09:30:22 * shachaf commits inaccuracy for the sake of brevity.
09:31:02 <rebuh> what's better, lisp (sbcl) or haskell?
09:31:30 <shachaf> rebuh: COBOL is best.
09:31:35 <parcs> rebuh: yes
09:31:38 <tac-tics> rebuh: For trolling? I'd say LISP is the best for that
09:31:49 <mux> INTERCAL
09:32:08 <mm_freak> what's better?  unlambda or brainfuck?
09:32:16 <Peaker> @protontorpedo
09:32:17 <lambdabot> how does haskell do with large systems?
09:32:21 <rebuh> mm_freak: whitespace
09:32:21 <elliott> There is no way to put stuff into a Handle's buffer other than hLookAhead, right?
09:32:22 <parcs> they are equally better
09:32:26 <mm_freak> ok, in that case i'd definitely answer unlambda
09:32:32 <shachaf> rebuh: Really, if you want the best language computing can offer, I'd recommend C++.
09:32:38 <elliott> mm_freak: Unlambda, it has nicer semantics, although Lazy K is nicer still
09:32:57 <elliott> (it's pure modulo lazy IO, for instance)
09:32:57 <mm_freak> elliott: true
09:33:24 <rebuh> shachaf: c++ is to complicated
09:33:44 <mux> I think my irony meter just exploded once again
09:33:49 <elliott> To C++ is to complicate.
09:33:57 <mm_freak> rebuh: to answer your question:  it really depends on whether you ask in #haskell or #lisp
09:34:09 <shachaf> elliott: Isn't Lazy IO an implementation detail?
09:34:11 <mm_freak> here haskell is better and over there CLisp is better
09:34:22 <rebuh> mm_freak: hehe i know. i just tried to start a flame war.
09:34:23 <parcs> rebuh: you need to ask a neutral channel
09:34:30 <parcs> like #php
09:34:32 <mux> so you admit to being a troll
09:34:36 <mux> I like your honesty
09:34:38 <mm_freak> lol parcs
09:34:43 <mm_freak> you can't ask in #php
09:35:00 <mux> I wasn't aware that there were programmers in #php
09:35:04 <shachaf> (I.e. isn't it just defined as ~ :: String -> String, which implementations happen to use stdin and stdout for?)
09:35:28 <elliott> shachaf: Well, yes, but considering the page details how to get IO to "work properly" with evaluation order tricks...
09:35:38 <elliott> I'd say it's pretty close to being part of the spec.
09:35:38 <rebuh> php isn't good for anything
09:35:56 <mux> php is very good at making people believe they can code while they obviously cannot
09:36:14 <mm_freak> PHP is very good at creeping the hell out of me
09:36:21 <mux> yeah, that too
09:36:30 <shachaf> elliott: Shh. My Lazy K is pure.
09:36:32 <rebuh> who likes perl?
09:36:37 <elliott> shachaf: Strict K.
09:36:41 <shachaf> @where ops
09:36:41 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
09:36:51 <mauke> yes?
09:37:01 <elliott> rebuh: Nobody likes Perl.
09:37:08 <rebuh> elliott: haha true
09:37:11 <mux> I kinda like perl in a masochistic way
09:37:23 <shachaf> mauke: See e.g. <rebuh> mm_freak: hehe i know. i just tried to start a flame war.
09:37:26 <mm_freak> lazy K without output…  the language that can compute anything in O(1)
09:37:30 <mauke> shachaf: and?
09:37:49 <mux> shachaf: he's not that annoying, is he?
09:38:18 <mm_freak> not at all…  it's quite difficult to start a successful flame war here
09:38:23 <shachaf> It seemed to me like deliberate trolling for the sake of disturbing the channel. Maybe not.
09:38:39 <elliott> mm_freak: Oh yeah? Well Haskell sucks.
09:38:40 <mux> yeah, but done in a rather classy way, I must say
09:38:55 <mm_freak> elliott: right, it hasn't got dependent types
09:39:01 <elliott> mm_freak: And it's pure, so it can't possibly do everything VB can.
09:39:12 <copumpkin> dependent types are the devil
09:39:29 <copumpkin> I want my category of types to be a monoid
09:39:42 <mm_freak> elliott: VB can make me cry, haskell can't, so you're right again =)
09:39:49 * shachaf is happy to help people asking actual questions in #haskell.
09:39:55 <elliott> You're all nerds. Nerds who can't tell me how to poke into the buffer of a Handle. :(
09:39:57 <shachaf> Regardless of whether I know the answer, I might add.
09:40:10 <elliott> Ooh, GHC.IO.Buffer.
09:40:11 <copumpkin> IRREGARDLESS
09:40:13 <elliott> This looks promising and portable.
09:40:19 <mux> lol
09:40:20 <shachaf> copumpkin: IRREGUARDLESS
09:40:55 <mm_freak> elliott: normally you wouldn't put back into a handle, because then it couldn't guarantee any buffer sizes anymore
09:41:05 <copumpkin> in other news, http://snapplr.com/h51q
09:41:07 <elliott> mm_freak: yeah
09:41:11 <mm_freak> elliott: what you can do is to use an I/O abstraction like iteratees
09:41:11 <elliott> mm_freak: I'll just keep a lazy bytestring as a buffer
09:41:20 <mm_freak> "putting back" is something an enumeratee could do
09:41:34 * shachaf sighs.
09:41:37 <elliott> mm_freak: hehe, I'm using iteratees, but unfortunately they'r enot ideal for my use-case so I'm migrating away
09:41:49 <mm_freak> what is your use case?
09:41:57 <shachaf> "not using iteratees"
09:42:01 <mm_freak> lol
09:42:06 * shachaf considers that legitimate all on its own.
09:42:28 <elliott> mm_freak: well, it's a network server; I have one loop chomping up all packets that come in, but what I /write/ to the packet comes from various sources in a bunch of threads via a Chan (maybe TChan)
09:42:38 <mm_freak> i really don't understand what everybody has against iteratees, when it comes to stream processing
09:42:44 <elliott> I'd basically need a "consumer" and a "producer" pipeline
09:42:56 <elliott> which is much less suited to iteratees than something like an HTTP server where there's a fairly direct map from input to output
09:43:10 <mm_freak> elliott: i use blaze-builder for the producer pipeline
09:43:47 <mm_freak> but it's not suitable for everything…  for more complicated use cases you can try using explicit coroutines (see monad-coroutine)
09:43:59 <elliott> mm_freak: I'm not sure I understand -- I do use cereal to go from network bytestrings to datatype and back, but I'm not sure how that'd solve this issue
09:44:15 <elliott> I definitely need a Chan of some sort to be the source of all the packets going to the socket.
09:44:35 <mm_freak> elliott: what iteratees are for input, builders are for output…  it gives you kind of safe "lazy O"
09:44:45 <mm_freak> safe and efficient that is
09:45:46 <mm_freak> when the output data comes from multiple threads, you can still have one thread assembling the output packets
09:45:46 <elliott> mm_freak: yeah... thankfully buffer IO is really easy for this server; the writer can literally just be a thread taking from the chan and writing to the socket, and the only nastiness with buffering is that I need to keep whatever cereal doesn't parse to feed back in
09:45:51 <elliott> s/buffer IO/handle IO/
09:46:31 <elliott> I might look into ripping out the cereal serialisation part and replacing it with blaze-builder, though
09:46:38 <elliott> thanks for the pointer
09:47:08 <mm_freak> builders don't serialize, they expect already serialized data
09:47:20 <mm_freak> thought here are some simple serializers in the blaze-builder library
09:47:30 <mm_freak> you'll likely still need cereal
09:47:32 <elliott> mm_freak: well, all my Serialize instances are hand-written
09:47:49 <elliott> as long as I can write integers and IEEE floats in big endian I'm fine
09:49:04 <mm_freak> anyway the multiplexing part calls for some Alternative functor
09:49:31 <mm_freak> do it like a parser monad
09:49:46 <mm_freak> perhaps even use a parser monad like attoparsec
09:50:11 <mm_freak> attoparsec can well parse binary data, and you can easily compose multiple parsers
09:50:17 <elliott> mm_freak: it's tempting, but there'd always still be residue left at the end: data read from the socket but not fed into the parser
09:50:32 <elliott> although I suppose if I only read as much as I need, GHC's buffering might make it efficient
09:50:41 <mm_freak> why?  consider this:  Parser (IO Result)
09:51:02 <mm_freak> a parser can determine what to do with the parsed data
09:51:05 <elliott> Done ByteString r	
09:51:05 <elliott> The parse succeeded. The ByteString is the input that had not yet been consumed (if any) when the parse succeeded.
09:51:11 <elliott> --attoparsec docs
09:51:46 <mm_freak> that ByteString will always be empty, if you have an endOfInput parser at the end
09:52:37 <elliott> I'm not really sure how you're proposing I do this; just feed attoparsec a ByteString of one character every time it asks for more input??
09:52:55 <elliott> Sure, that would work, but hardly sounds efficient, vs. reading a few kilobytes at a time, which will end up with residue input at the end.
09:53:30 <mm_freak> look at the attoparsec-enumerator package
09:53:45 <mm_freak> it transforms an attoparsec parser into an iteratee, which you can use in a larger iteratee
09:54:14 <dolio> ski: ping
09:54:36 <elliott> Well yes, I have a setup that works now with iteratees, but I was just talking about moving away from them, and it sounded to me like you were saying it could be handled without a manual buffer (which is no big deal for me) without iteratees
09:55:20 <mm_freak> you would need manual buffering, but really iteratees are much more convenient there
09:55:39 <mm_freak> your iteratee would be a simple loop calling the parser and performing an action repeatedly
09:55:48 <elliott> Yeah, but I can reimplement what iteratees give me on the input end in about thirty lines of code :P
09:55:54 <mm_freak> the unparsed portion is implicitly left in the enumeration
09:56:07 <elliott> Iteratees are certainly great for a lot of things, they're just overkill here, because they'd only be useful for input and my input handling is very simple.
09:56:38 <mm_freak> i'd think they are good for simple input handling and underkill for complicated stuff ;)
09:57:01 <mm_freak> anyway, repeatedly applying a parser to a stream is really one great use case of iteratees
09:57:13 <mm_freak> action <- iterParser myParser
09:57:16 <mm_freak> liftIO action
09:57:19 <mm_freak> doItAgain
09:57:31 <dankna> okay
09:57:36 <dankna> I require the services of a psychic
09:57:40 <dankna> I am using the Maybe monad, right
09:57:54 <dankna> it is exiting early
09:58:06 <dankna> somewhere between the opening "do" and the first statement inside it
09:58:09 * hackagebot debian 3.61 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.61 (DavidFox)
09:58:15 <elliott> mm_freak: type Buf = [ByteString]; blah buf h = do (r,extra) <- runParser buf h; return (r, buf ++ [extra]) :P
09:58:17 <dankna> how is this even possible?
09:58:22 <elliott> (except something better than [])
09:58:24 <mm_freak> dankna: it's not
09:58:28 <elliott> dankna: wat
09:58:40 <dankna> yeah, that's what I thought.  so I must have messed something up.  that's why I said I need a psychic :)
09:58:45 <donri> paste code
09:58:50 <dankna> one sec
09:59:12 <hpaste_> dankna pasted “I get HMMM but not ZZZQ” at http://hpaste.org/52242
09:59:23 <mm_freak> elliott: [] is fine for that
09:59:37 <dankna> the type of the method is BitSize -> Endianness -> ByteString -> Maybe (Section64, ByteString)
09:59:37 <elliott> mm_freak: well I guess it's pretty low overhead but repeated ++[x] irks me a bit
10:00:19 <ClaudiusMaximus> @src Maybe (>>=)
10:00:19 <lambdabot> (Just x) >>= k      = k x
10:00:19 <lambdabot> Nothing  >>= _      = Nothing
10:00:34 <elliott> dankna: it sounds like you're expecting the "do" to be strict imperative code, and getting surprised when the impurity of "trace" gives unexpected results :P
10:00:48 <elliott> I dunno about your problem though
10:00:51 <ClaudiusMaximus> @src Maybe (>>)
10:00:51 <lambdabot> (Just _) >>  k      = k
10:00:52 <lambdabot> Nothing  >>  _      = Nothing
10:00:53 <dankna> elliott: well, I suppose that's true
10:01:24 <shachaf> dankna: Is the whole thing actually being executed?
10:01:46 <dankna> shachaf: oh, that's an interesting thought.  you mean what if I'm returning it but not entering it.
10:02:18 <dankna> perhaps the caller is in the wrong monad, let me check that
10:02:18 <elliott> dankna: s/entering/forcing/
10:02:21 <elliott> s/returning//
10:02:22 <dankna> yeah, that
10:03:00 <dankna> the caller is definitely in Maybe as well, I checked by putting in "return () :: Maybe ()" as a statement right before the call
10:03:01 <mm_freak> elliott: with [] you would buffer in the other direction
10:03:10 <mm_freak> the head of the list would be the most recent packet
10:03:14 <dankna> which ought to produce a compile-time error if the monad were anything else
10:03:35 <elliott> mm_freak: yes, but if you have two elements in the buffer, then you want to feed the oldest first
10:03:35 <shachaf> dankna: I think your identifiers might be too short. Try ghc -fmagnifying-glass so it doesn't miss them.
10:03:43 <elliott> or that's like reversing the order the parser gets the input in :P
10:03:49 <dankna> shachaf: I'll keep that in mind!
10:03:50 <dankna> haha
10:03:57 <dankna> I like long identifiers.  we've discussed this before :)
10:04:07 <shachaf> With me?
10:04:13 <dankna> possibly, not sure
10:04:18 <shachaf> I don't know how you're actually using this deseria* function.
10:04:22 <dankna> it comes up virtually every time I hpaste code in here
10:04:23 <mm_freak> elliott: ok, if you want to process both ends, then you probably want Seq
10:04:32 <mm_freak> or even a fixed size ring buffer
10:04:37 <elliott> mm_freak: yeah
10:04:48 <shachaf> dankna: If you replace "return ()" with "undefined" does it crash?
10:04:55 <dankna> shachaf: fair question, lemme tru
10:04:57 <dankna> *try
10:04:59 <shachaf> (Well, I assume not, because that would be weird.)
10:05:14 <dankna> yes, it does
10:05:20 <shachaf> Oh.
10:05:29 <shachaf> Huh.
10:05:39 <dankna> well, not crash, but exit with the undefined exception
10:05:45 <shachaf> That's crashing. :-)
10:05:47 <dankna> yes
10:05:57 <shachaf> Assuming it's not some other undefined -- use error "foo" to check, I guess.
10:05:58 <dankna> except with fewer security implications :)
10:06:22 <dankna> yeah it prints foo
10:06:23 <shachaf> dankna: _|_ overrun exploits are a serious problem!
10:06:29 <dankna> haha
10:06:40 <shachaf> dankna: Does it *still* not print ZZZQ?
10:06:49 <elliott> dankna: Try:
10:07:01 <dankna> shachaf: yeah no ZZZQ at all
10:07:10 <shachaf> dankna: Well, do whatever elliott's about to suggest.
10:07:10 <elliott>     (sectionName, bytestring)
10:07:11 <elliott>       <- trace "ZAP" (deserializeFixedLengthText 16 bytestring)
10:07:15 <elliott> dankna: after the ZZZQ line.
10:07:20 <dankna> okay
10:07:38 <elliott> dankna: Oh, and trace the Section64 being returned wherever you use it.
10:07:42 <elliott> with traceShow
10:07:46 <elliott> That should make sure it's actually being forced.
10:07:52 <dankna> okay
10:08:07 <dankna> oh hm, I get ZAP but not ZZZQ
10:08:20 <dankna> I guess I was thinking Maybe was strict and being surprised when it didn't behave that way
10:08:30 <shachaf> Something is fishy here.
10:08:42 <elliott> dankna: I think being strict in that way actually technically violates the monad laws.
10:08:45 <elliott> shachaf: Not really?
10:08:54 <elliott> Hmm
10:08:56 <dankna> does it?  interesting
10:09:02 <elliott> Well I guess it has to force the Just around the () at least
10:09:05 <elliott> But maybe GHC turns it into
10:09:08 <elliott> return (trace "ZZZQ" ())
10:09:10 <elliott> or something.
10:09:13 <shachaf> elliott: If it forces the undefined but doesn't print the trace, that's not fishy?
10:09:26 <shachaf> In «trace "ZZZQ" $ undefined», I mean.
10:09:27 <elliott> dankna: Hey, try replacing the ZZZQ with
10:09:30 <elliott> trace "ZZZQ" un-
10:09:31 <elliott> Oh.
10:09:33 <elliott> You tried that?
10:09:40 <shachaf> dankna: Wait, didn't you try that?
10:09:44 <dankna> no, sorry, what I tried was something distinct from that
10:09:48 <elliott> Try that then.
10:09:49 <dankna> miscommunication
10:09:49 <shachaf> Oh. I thought that's what you tried.
10:09:53 <elliott> Or even trace "ZZZQ" Nothing.
10:10:00 <elliott> shachaf: Well, it sounds fishy, but trace is impure, so optimisations could mess it up.
10:10:07 <elliott> dankna: Try turning off all optimisations to boot.
10:10:22 <shachaf> elliott: True. But then there's still fishiness going on, just from a different source. :-)
10:10:56 <dankna> turning off optimizations, okay.  and with "trace "ZZZQ" Nothing" I get ZZZQ as output
10:11:02 <shachaf> Oh.
10:11:05 <shachaf> So it's not what I thought.
10:11:16 <dankna> although I should note that it actually invokes this routine twice,
10:11:29 <dankna> and it was always succeeding the first time, but obviously if I make it fail deliberately, it doesn't
10:11:37 <dankna> so it's not quite a perfect test
10:12:16 <dankna> anyway, hmm
10:12:20 <dankna> I think I have a handle on this now
10:12:27 <dankna> I just have to put my traces around things that actually are used :)
10:12:40 <shachaf> dankna: I can't reproduce this sort of behavior here.
10:12:58 <dankna> could be any number of factors different in our environments; I'm using a totally custom GHC :(
10:13:29 <dankna> I am now trying to narrow down the failure to a particular line based on tracing
10:13:51 <shachaf> dankna: Is there something runnable you could @paste?
10:14:10 <dankna> well, it's rather large, but I could.  but let me try this line of attack before I do that.
10:15:52 <dankna> okay yeah
10:15:57 <dankna> I believe I found it
10:16:05 <dankna> decode typeAndFlags
10:16:15 <dankna> returns a Maybe (SectionType, ByteString)
10:16:32 <dankna> but it's returning Nothing because it's seeing an undefined value for the enumeration
10:16:38 <dankna> I guess I should have suspected this problem from the outset
10:16:54 <dankna> well, now I just need to go into the data and figure out why it's an undefined value
10:16:56 <dankna> thanks :)
10:16:56 <elliott> Ah, because of Maybe's fail?
10:17:02 <dankna> yeah
10:17:03 <elliott> Or?
10:17:04 <elliott> Right.
10:17:19 <elliott> dankna: You should consider using Either :P
10:17:24 <dankna> of course in the long run I think I need a way to structure this code that -- yeah
10:17:46 <elliott> dankna: You shouldn't have to change anything but explicit Nothings, assuming all your code is done with do notation.
10:17:52 <dankna> it is
10:18:01 <elliott> Just change the types and use (Either String) then :-)
10:18:13 <shachaf> #define Maybe Either String
10:18:18 <dankna> well, obviously I'll want to also make the helper functions take an additional parameter to be the error in case of failure :)
10:18:36 * shachaf wonders whether Nothing should have a hidden String parameter.
10:18:44 <dankna> but yeah, think I'll do that.  as soon as I've got it running properly for this case.
10:18:50 <shachaf> This is the sort of thinking that gets fail into Monad...
10:18:54 <dankna> haha yeah
10:19:13 <shachaf> Someone once suggested data Maybe a = Nothing (forall b. b) | Just a
10:19:22 <elliott> And you just unsafeCoerce the value out?
10:19:23 * dankna blinks
10:19:29 <elliott> It'd have to be Any on GHC. :p
10:19:32 <shachaf> elliott: No, the value is always (error "foo")
10:19:40 <elliott> Otherwise you couldn't put functions in!
10:19:41 <elliott> Oh.
10:19:43 <elliott> Heh.
10:19:43 <shachaf> Operationally different but not denotationally.
10:19:49 <elliott> That's awful. I like it.
10:20:10 <elliott> Once we can define a constructor synonym of Nothing to NothingWith (error "Nothing"), let's do it.
10:20:43 <aristid> shachaf: what a lovely hack :D
10:20:48 <dankna> ahhhhh wtf, is anyone an expert on the Mach-O file format :(
10:20:56 <dankna> this value shouldn't be possible :(
10:21:11 <dankna> oh!  duh
10:21:13 <dankna> I see what happened
10:21:17 <benmachine> shachaf: I don't know if Nothing b >>= f = Nothing b would work
10:21:20 <benmachine> I suppose it would
10:21:22 <dankna> missed the alignment constraint so I was processing the wrong bytes
10:21:34 <elliott> dankna: Have you considered using a real serialisation library?
10:21:40 <dankna> elliott: no :D
10:21:46 <elliott> The code you pasted is kind of awful. :p
10:21:54 <dankna> well, I'm certainly interested in feedback
10:22:05 <shachaf> It could be drastically improved by using one-letter variable names everywhere.
10:22:07 <elliott> You'd completely eliminate the state threading if you used something proper... and it'd probably be quicker, if you're really unconsing the bytestring all the time.
10:22:16 <elliott> See the binary, cereal, attoparsec libraries.
10:22:21 <dankna> I don't really care about performance,
10:22:29 <shachaf> dankna: Also clearer.
10:22:36 <elliott> Well, yeah, but fast and pretty beats slow and ugly.
10:22:40 <dankna> isn't cereal its own format, not for parsing custom ones?
10:22:46 <elliott> Nah.
10:22:48 <dankna> yeah, certainly, the prettiness issue I take seriously
10:22:56 <shachaf> elliott: Go back to your ivory tower. We don't need purists like you in here.
10:22:57 <elliott> You just make a "Get MachO".
10:23:01 <dankna> the reason I am doing it this way is
10:23:10 <elliott> And use things like getWord32le.
10:23:15 <dankna> there are occasional fields which don't correspond 1:1 to things in the structure
10:23:20 <dankna> oh, but that's the beautiful part
10:23:31 <dankna> I have a single instance which handles all Int* and Word* types with both endiannesses
10:23:53 <elliott> dankna: Eh?
10:23:57 <dankna> yeah, lemme show it
10:24:08 <elliott> This sounds bad :(
10:24:14 <dankna> lol
10:24:35 <roconnor> quicksilver, ddarius: my unit of compilation would be something like a top level function or a mutually dependent group of top level functions.  I seem to recall hearing that IBM had a C++ compiler that did something along these lines.
10:24:39 <hpaste_> dankna pasted “ROYAL RAINBOW” at http://hpaste.org/52243
10:24:50 <elliott> dankna: That isn't "one instance".
10:24:58 <dankna> well, okay, it's four cases
10:24:59 <elliott> dankna: That's four separate functions, given two names for no reason. :p
10:25:07 <elliott> (As opposed to four names.)
10:25:17 <dankna> the reason is that this entire file format
10:25:23 <dankna> is actually parameterized on endianness
10:25:28 <elliott> Nice.
10:25:36 <shachaf> What format are you parsing?
10:25:37 <elliott> Well, you can certainly replicate that with cereal.
10:25:41 <elliott> shachaf: Mach-O.
10:25:46 <dankna> if I used four names I would have to write my own two-name wrapper for it
10:25:54 <elliott> dankna: How big inputs are you dealing with?
10:25:55 <dankna> it's the Mac and iPhone object-file format
10:26:03 <shachaf> Why?
10:26:03 <elliott> You might want binary; cereal only works with strict ByteStrings.
10:26:05 <elliott> Or attoparsec.
10:26:06 <dankna> mm, shouldn't be anything larger than about 32 megs at the outside
10:26:12 <elliott> Or, hmm.
10:26:33 <elliott> I think cereal will be fine. The APIs are practically identical anyway.
10:26:37 <dankna> hmm
10:26:39 <dankna> I'll give it a look
10:26:43 <dankna> @hackage cereal
10:26:43 <lambdabot> http://hackage.haskell.org/package/cereal
10:27:41 <shachaf> dankna: Anyway, there is no architecture but x86 and little is its endianness.
10:27:45 <dankna> this doesn't look substantially different from what I'm really doing
10:27:47 * shachaf conveniently ignores that you mentioedn iPhones.
10:28:00 <elliott> dankna: Good, so it's a good fit for your problem.
10:28:10 <dankna> except that I treat "serialize/deserialize" and "encode/decode" as two separate things
10:28:20 <dankna> I think I had a good reason for that, let me think
10:28:21 <dankna> oh right
10:28:23 <elliott> dankna: Here's one big difference: it doesn't involve threading state manually. :p
10:28:27 <dankna> lol
10:28:39 <dankna> well, I would rather rework mine to avoid that need
10:28:45 <dankna> the thing is that there are a couple cases where I need to
10:28:48 <shachaf> elliott: You're the maintainer of cereal, right?!
10:28:51 <dankna> because the state doesn't go linearly
10:28:53 <elliott> It'll still be slower.
10:28:54 <elliott> shachaf: I am?
10:29:07 <DevHC> RANDOM RANT: how about fractional operator binding strengths: infixr 2.75 ##
10:29:08 <elliott> dankna: Huh? The state in this case is the ByteString you're deserialising.
10:29:13 <dankna> yeah
10:29:17 <shachaf> It says "elliott". The wonderful thing about elliotts is that you're the only one.
10:29:18 <elliott> DevHC: We've already covered that.
10:29:19 <dankna> sometimes I need to take it out of order
10:29:24 <elliott> shachaf: No, he has one more t.
10:29:29 <DevHC> elliott: and the outcome is?
10:29:32 <elliott> dankna: Like how?
10:29:36 <dankna> because of <strikeout>dumb decisions in the file format</strikeout> length fields and things like that
10:29:43 <elliott> DevHC: Well, it was the most extensible fixity system ever.
10:29:46 <elliott> Also the worst.
10:29:50 <shachaf> elliott: And sometimes you have one more cable, but who's counting?
10:29:52 <elliott> dankna: Length fields are doable just fine...
10:30:01 <dankna> well, like
10:30:03 <dankna> the way I'm parsing
10:30:05 <elliott> dankna: n <- getLength...; b' <- getBytes n
10:30:09 <DevHC> elliott: why the worst? :P
10:30:16 <dankna> I can take that many bytes off the string and pass them to a sub-parser
10:30:23 <elliott> (Or getByteString, if you want to copy the bytes (i.e. are not about to immediately do something to b' then throw it away.)
10:30:29 <elliott> dankna: Yes, cereal has parser isolation.
10:30:31 <elliott> isolate :: Int -> Get a -> Get aSource
10:30:32 <elliott> Isolate an action to operating within a fixed block of bytes. The action is required to consume all the bytes that it is isolated to.
10:30:39 <dankna> okay, hmm, good
10:30:39 <shachaf> DevHC: How about arbitrary infixity DAGs instead?
10:30:56 <DevHC> shachaf: what's that?
10:31:01 <dankna> well, I think I'd rather rework my own thing than use cereal, honestly :) but these are good ideas for how to do that
10:31:25 <DevHC> shachaf: x has higher precedence than y if both x and y r used in an expression, etc.?
10:31:31 <dankna> when a library is so small, the overhead of learning it and determining its suitability is similar in time-consumed to just reimplementing
10:32:03 <elliott> dankna: Except that /it doesn't uncons all the time/.
10:32:10 <dankna> haha
10:32:18 <elliott> You might reimplement the same API, but it'll be a worse implementation.
10:32:20 <dankna> well, but if I eliminate the explicit state threading
10:32:28 <dankna> then I can just store pointers
10:32:54 <elliott> Shrug. I don't know why you'd make more work for yourself when somebody's already done it near-perfectly, but feel free :P
10:33:04 <dankna> must CODE ALL THE THINGS!
10:33:18 <dankna> if it wasn't invented here it doesn't exist!
10:33:21 <elliott> Hey, _I'm_ the king of NIH.
10:33:26 <elliott> My lawn: get off it.
10:33:29 <dankna> haha
10:33:37 <dankna> you can't be, I deny that you could have invented NIH
10:34:05 <dankna> anyway I definitely do thank you for helping me figure out my problem, heh
10:34:29 <elliott> mm_freak: btw, re: being able to turn a parser into an enumeratee, switching away from iteratees doesn't actually hurt me there, because I had to write the glue code myself :P
10:34:38 <shachaf> elliott: The real NIH experts haven't even heard of your competition.
10:34:38 <elliott> dankna: np
10:34:52 <elliott> shachaf: Who?
10:35:07 <shachaf> I don't know who they are. They don't use IRC.
10:35:24 <elliott> shachaf: They're not the NIH experts if they ever actually get around to reinventing things.
10:36:18 <shachaf> They've already written a full operating system superior to @ several times.
10:36:28 <elliott> Pah.
10:36:39 <mm_freak> elliott: into an iteratee
10:36:44 <shachaf> Wait, I forgot @ was the upper bound of operating systems.
10:36:47 <shachaf> Equal to @.
10:36:58 <elliott> mm_freak: Well, I use it as an enumeratee in my case.
10:37:02 <DevHC> elliott: TALK
10:37:04 <elliott> shachaf: @ is lame, everything else is just so much lamer.
10:37:08 <elliott> DevHC: No.
10:37:12 <DevHC> D:
10:37:22 <DevHC> shachaf: TALK
10:37:39 <shachaf> There is only silence and some second-hand clothes.
10:38:04 <elliott> We were both talking before you told us to talk.
10:38:10 <elliott> But now, oh no.
10:38:28 * shachaf has not slept in a while.
10:38:36 <DevHC> talk about fractional infix binding strengths i mean
10:39:45 <cacacatoc> which are the most famous haskell opensource projects?
10:40:06 <elliott> GHC. darcs. :p
10:40:09 <elliott> Pandoc, I guess?
10:40:10 <elliott> lambdabot.
10:40:19 <shachaf> lambdabot sure is famous.
10:40:24 <shachaf> @nixon You hear taht?
10:40:24 <elliott> Yes.
10:40:24 <lambdabot> Sure there are dishonest men in local government. But there are dishonest men in national government too.
10:40:25 <elliott> The most famous.
10:41:13 <yitz> xmonad
10:41:30 <mm_freak> yesod has become quite famous
10:41:33 <mekeor> cacacatoc: xmonad
10:41:42 <mekeor> yitz: oh, you were faster...
10:41:53 <shachaf> hpaste is so famous.
10:41:59 <mekeor> mm_freak: i dont know that
10:42:09 <shachaf> You don't even know what software is written in Haskell.
10:42:10 <mm_freak> mekeor: the web framework
10:42:13 <mekeor> is hoogle also written in haskell?
10:42:21 <shachaf> http://detexify.kirelabs.org/classify.html is, for instance.
10:42:29 <cacacatoc> Haskell code seems very untuitive
10:42:31 <mekeor> WOW!
10:42:32 <yitz> warp
10:42:40 <mekeor> shachaf: cool! i didnt know that! wow!
10:42:44 <elliott> cacacatoc: That's nobody's fault but your tuintition.
10:42:47 <luite> mekeor: yes you can download the code from hackage
10:42:53 <mekeor> awesome
10:43:02 <luite> mekeor: it uses the warp webserver
10:43:02 <elliott> cacacatoc: If you were fluent in mathematics rather than, I dunno, C or Java or Python, Haskell would seem much more natural than any of those.
10:43:12 <elliott> Although if you were fluent in Haskell it'd be even better.
10:43:24 <elliott> Knowing Haskell does wonders for how easy Haskell looks.
10:43:26 <yitz> elliott: you don't need to be fluent in mathematics to be fluent in Haskell
10:43:31 <elliott> yitz: Never said that :)
10:43:38 <mekeor> elliott: i think Haskell is much more similar to maths than the other language i know
10:43:39 <yitz> ok :)
10:43:40 <elliott> I'm just saying, it's all about your background/assumptions.
10:43:57 <erus`> I'm pretty crap at math but haskell seems natural to me. I also have a C background. You cant explain that
10:44:01 * shachaf is fluent in the green blotches that seem to be appearing on his fingers.
10:44:03 <mm_freak> elliott: i don't have the slightest clue about category theory and still write real world applications in haskell =)
10:44:14 <elliott> mm_freak: Me too. (Well, FSVO real world.)
10:44:16 <yitz> shachaf: you should get some sleep
10:44:18 <luite> mekeor: I find it useful to run my own hoogle that indexes all packages that I have installed on my own system
10:44:24 <shachaf> mm_freak: As long as they don't do IO.
10:44:33 <shachaf> You need a few PhDs in monadology before you can do any IO in Haskell.
10:44:40 <shachaf> This is a well-documented fact.
10:44:46 <mm_freak> lol
10:44:57 <mm_freak> or you can just read the type signatures ;)
10:45:17 <shachaf> PhD m => m (m a) -> m a
10:45:25 <yitz> > print "Hello World"
10:45:25 <lambdabot>   <IO ()>
10:45:26 <elliott> But what is Haskell? It's a difficult question because Haskell is impossible to describe. One might ask the same about monads. What are monads? We just don't know.
10:45:33 <shachaf> > putStrLn " <IO ()>"
10:45:34 <lambdabot>   <IO ()>
10:45:36 <yitz> see that - you can't do IO in Haskell
10:45:39 <elliott> -- Introduction to Monadology by Haskell Curry
10:45:44 <shachaf> yitz: Sure you can. See above.
10:45:45 * benmachine hugs elliott
10:45:57 <donri> i think the recent package updates list on the site is broken
10:45:59 <yitz> shachaf: haha
10:46:05 <elliott> donri: I noticed that
10:46:12 <shachaf> yitz: Should have gotten a few PhDs like me.
10:46:13 <elliott> but forgot to tell anyone so you win
10:46:20 <yitz> shachaf: indeed
10:46:23 <donri> the "latest" updates are from april
10:46:24 <shachaf> Basic Monadology for Computer Scientists
10:47:01 <elliott> A Gentle Introduction to Monads
10:47:11 <elliott> (assumes background in functorology)
10:47:30 <yitz> and applicatology
10:47:56 <shachaf> Does that come before or after categorology?
10:48:09 <elliott> Mathematology sure is complicated.
10:48:22 <tac-tics> How to Start a Nuclear War: A Treatise on Monads in Functional Programming
10:48:28 <shachaf> elliott: You need a meta-PhD before you can start on that one.
10:49:07 <yitz> (meanwhile, cacacatoc left)
10:50:36 <limetree> elliott: was that a reference to "look around you"? :)
10:50:41 <elliott> limetree: yep :P
10:51:25 <tac-tics> IO launches nuclear missles, State launches missiles, but they were imaginary missiles, List launches many missiles in all possible combinations, but they, again, where all imaginary, Maybe *might* launch an imaginary missile, Cont a launches an imaginary missile to the target of your choice, and STM launches missiles, but allows you think over your decision before it lands
10:53:37 <shachaf> elliott: I hadn't seen that before.
10:53:45 <shachaf> Chemical symbol H20...
10:54:44 <dylukes> :\
10:54:50 <dylukes> sometimes I really wish we could scope constructors
10:55:03 <dylukes> like, I hate typing "LetInExpression". "Expression.LetIn" would be nice.
10:55:46 <ddarius> You can.
10:56:25 <antihoax> hiii
10:59:30 <benmachine> dylukes: that's a vaguely interesting idea. one more vote for "better module system, please"
10:59:47 <dylukes> it would be very easy if we could have submodules within files like in Agda.
10:59:53 <dylukes> :\
11:01:03 <shirt> what do you guys think of the idea of changing cabal so that running "cabal" with no arguments means running "cabal build" ?
11:01:33 <dcoutts> shirt: I suggest you turn on the provided bash command line completion for cabal
11:02:08 <dcoutts> shirt: that'll cut it down to "cab<tab> b<tab>" 6 keystrokes
11:02:53 <mauke> shirt: :-/
11:03:01 <mauke> alias 'cabuild=cabal build'
11:03:21 <shachaf> Thanks, ants!
11:03:25 <shachaf> Thants
11:03:34 <hpc> or even alias cab
11:03:56 <shirt> i'm just thinking it would make it more like "make", where it implicitly builds "all" if you don't specify a target
11:04:01 <shachaf> By default if you press enter on an empty command prompt, it should run cabal build.
11:04:15 <shachaf> The thing about all is that it doesn't even make all.
11:04:20 <shachaf> For example, it doesn't run make clean.
11:04:24 <mauke> shirt: no, it doesn't
11:04:30 <mauke> and cabal isn't like make
11:05:00 <dcoutts> it's interesting to note that some other build tools have an interactive mode
11:05:15 <dcoutts> so you can drop the 'cabal ' prefix to all commands
11:05:21 <dcoutts> e.g. ruby's tool does this
11:05:36 <shachaf> dcoutts: Which tool?
11:06:09 <dylukes> mauke: I have `alias ls = cabal install; ls`
11:06:15 <dcoutts> shachaf: oh, misremembering, it's the scala one
11:06:20 <dylukes> because all of my directories have haskell in them and I want them always built.
11:06:22 <shachaf> Ah.
11:06:28 <dcoutts> dylukes: hah
11:07:01 <shachaf> Not that far from a Ruby thing: rvm aliases cd to an internal function that checks the new directory for relevant rvm files.
11:07:13 <shachaf> It's slightly ridiculous.
11:07:35 <dylukes> .___.
11:07:42 <dylukes> pff
11:07:53 <shachaf> cd () { builtin cd "$@"; local result=$?; __rvm_project_rvmrc; rvm_hook="after_cd"; source "$rvm_path/scripts/hook"; return $result }
11:07:59 <shachaf> I think that's missing a semicolon.
11:09:18 <hpaste_> Luke pasted “Attoparsec” at http://hpaste.org/52245
11:10:20 <Luke> can someone tell why http://hpaste.org/52245 is not of type Parser Param and is instead Parser String? type Param = (String, String)
11:10:59 <shachaf> Luke: Possibly an infixity thing? Try adding some parentheses and see if it still works out the same way.
11:11:18 <mauke> :t (,) <$> ?k <* ?q *> ?v
11:11:18 <lambdabot> forall a (f :: * -> *) b b1. (?k::f a, Applicative f, ?q::f b, ?v::f b1) => f b1
11:11:20 <hpc> Luke: you might also want to try using do notation and make sure it works that way
11:11:28 <shachaf> (Also, foo >>= (\x -> f x) === f <$> foo)
11:12:10 <hpc> shachaf: no, foo >>= \x -> return (f x) === that
11:12:23 <mauke> :t (,) <$> ?k <*> ?q *> ?v
11:12:24 <lambdabot> forall a a1 (f :: * -> *) b. (?k::f a, Applicative f, ?q::f a1, ?v::f b) => f b
11:12:25 <hpc> \x -> f x eta-reduces to f
11:12:28 <Luke> hpc: i'm trying to do it without do notation
11:12:33 <hpc> Luke: ah, k
11:12:51 <hpc> :t (,) <$> ?k <*> (?q *> ?v)
11:12:52 <lambdabot> forall a a1 (f :: * -> *) a2. (?k::f a, Applicative f, ?q::f a2, ?v::f a1) => f (a, a1)
11:12:53 <mauke> :t (,) <$> ?k <*> (?q *> ?v)
11:12:54 <lambdabot> forall a a1 (f :: * -> *) a2. (?k::f a, Applicative f, ?q::f a2, ?v::f a1) => f (a, a1)
11:12:58 <hpc> winner!
11:13:11 <Luke> so just wrap in parans?
11:13:15 <Luke> parens*
11:13:27 <hpc> yeah; looks like fixity was making things apply in the wrong order
11:14:24 <Luke> thanks guys
11:16:25 <Luke> hmm I added parens where you guys did and still no luck
11:16:44 <Luke> type comes out as: param :: Parser (b -> ([Char], b))
11:16:47 <mauke> :t (,) <$> ?k <* (?q *> ?v)
11:16:47 <lambdabot> forall a b (f :: * -> *) a1 b1. (?k::f a, Applicative f, ?q::f a1, ?v::f b1) => f (b -> (a, b))
11:16:56 <mauke> Luke: that's because you didn't use <*>
11:17:06 <Luke> do I need to?
11:17:14 <mauke> only if you want it to work
11:17:22 <Luke> haha why is that?
11:18:10 <shachaf> hpc: Yes, sorry, that's what I meant.
11:18:19 <mauke> Luke: what does <* do?
11:18:21 <shachaf> hpc: It's what was in his paste, anyway.
11:18:31 <Luke> ok it works - thanks
11:18:53 <Luke> mauke: i see... with the parens correct I can see it will just throw away the right side
11:18:57 <Luke> makes sense
11:19:22 <Luke> also, can someone think of a better way to do the lambda in the k and v functions?
11:19:53 <hpc> Luke:
11:19:55 <hpc> er
11:20:02 <shachaf> Luke: See what hpc and I said above.
11:20:13 <shachaf> foo >>= (\x -> return (f x)) === fmap f foo
11:20:35 <dankna> @src Either (>>=)
11:20:35 <lambdabot> Left  l >>= _ = Left l
11:20:35 <lambdabot> Right r >>= k = k r
11:20:40 <hpc> @pl takeWhile (/= '=') >>= (\x -> return $ B.unpack x)
11:20:40 <lambdabot> B.unpack `fmap` takeWhile ('=' /=)
11:21:22 <hpc> B.unpack <$> PC.takeWhile (/= '=')
11:22:19 <dankna> @src StateT (>>=)
11:22:19 <lambdabot> Source not found. Wrong!  You cheating scum!
11:22:23 <dankna> @src State (>>=)
11:22:24 <lambdabot> Source not found. Are you on drugs?
11:22:32 <dankna> @hackage mtl
11:22:33 <lambdabot> http://hackage.haskell.org/package/mtl
11:23:34 <dankna> @hackage transformers
11:23:34 <lambdabot> http://hackage.haskell.org/package/transformers
11:24:38 <parcs> does 'enumerator' have an Exception that i can throw in case of an unexpected EOF ?
11:28:18 <Luke> hpc: thanks
11:29:33 <rahul__> I have read it many times that arrows are generalization of monads. I never understood the explanations I was pointed to (mostly the Hughes paper). Can someone please explain it in easy to understand manner?
11:29:47 <Luke> thanks for all your help guys
11:29:55 <ski> dolio : syn ack
11:30:51 <ezyang> Hmm, gonna try to install threadscope again
11:30:55 <Luke> I'm rewriting a nonperformant python script to haskell using attoparsec. it's going really well actually
11:31:00 <hpc> rahul__: in this case, "generalization" means that we can get an arrow instance from a monad instance
11:31:24 <ski> for each monad `m', `Kleisli m' is an arrow
11:31:24 <hpc> rahul__: basically, the same way functor is a generalization of monad
11:32:00 * ski wonders how to define `EilenbergMoore m'
11:32:38 <hpc> Kleisli m ~~ /\ a b. (a -> m b)
11:33:10 <hpc> there's source code for the instances of Kleisli that will help a lot
11:34:12 <rahul__> hpc, ski: thanks.
11:35:05 <wyfrn> hey guys ... could anybody take a look on this code snippet http://hpaste.org/52246 and tell me, how to do it right?
11:35:32 <dolio> ski: Do you have that code for doing zipWith using folds? I was trying to remember how it went earlier and failing.
11:35:43 <dolio> ski: The one with the double negative type.
11:35:50 <shachaf> wyfrn: It depends on what you want to do.
11:36:00 <shachaf> wyfrn: By the monad laws >>= return doesn't do anythig.
11:37:02 <wyfrn> i know ... fc actually is nonsense ... i want fc to combine f1 and f2 ... but the 2 monads are confusing for a noob
11:37:11 <dolio> data EilenbergMoore m = forall a. EM (m a -> a)
11:38:12 <ski> "'10" by ski at <http://hpaste.org/47814>
11:38:30 <dolio> ski: Thanks.
11:38:42 <ski> er, that should have title  `zipWith' using `foldr'
11:38:53 <ski> (screen being slightly laggy)
11:39:28 <dolio> Oh, they're mutually recursive. That's what I was forgetting.
11:39:38 <ski> hm ?
11:39:44 <ski> no explicit recursion in there
11:39:45 <dolio> A and B.
11:39:50 <ski> ah, ok
11:40:06 <ski> you could unfold one into the other, of course
11:40:10 <dolio> Right.
11:40:25 <ski> (but it seemed more symmetric to do it this way)
11:40:36 <elliott> I wish there was a better way of writing case resultOfCerealParse of Fail e -> if "too few bytes" `isPrefixOf` e then ... else ...
11:40:54 <dankna> heh indeed
11:41:13 <ski> dolio : btw, any particular reason you wanted to see/think about this now ?
11:43:10 * hackagebot yesod-core 0.9.3.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.3.2 (MichaelSnoyman)
11:43:12 * hackagebot yesod-static 0.3.1.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.3.1.1 (MichaelSnoyman)
11:43:15 * hackagebot marxup 1.0.1 - Markup language preprocessor for Haskell  http://hackage.haskell.org/package/marxup-1.0.1 (JeanPhilippeBernardy)
11:43:21 <byorgey> wyfrn: one way to do it would be using the MaybeT monad transformer
11:43:27 <byorgey> wyfrn: I'll paste it, just a second
11:43:35 <dolio> ski: Yeah. Non-strictly positive types came up on the agda list, and this is the first example that popped into my head.
11:43:40 <dolio> Not that it's particularly compelling.
11:44:12 <ski> *nod*
11:44:28 <shirt> is there a way to abort an STM transaction? throw an exception?
11:44:48 <mm_freak> shirt: empty
11:45:01 <eacameron> I never got an answer about the regex question above. Can anyone recommend a regex lib that gives me Python-like regexs?
11:45:17 <elliott> mm_freak: shirt: Or throwSTM.
11:45:18 <ski> mm_freak : `mzero' ?
11:45:54 <hpaste_> byorgey annotated “Verschachtelte Monaden” with “Verschachtelte Monaden (annotation)” at http://hpaste.org/52246#a52247
11:47:56 <byorgey> wyfrn: there's one way to do it using the types you originally had, and another way to do it using MaybeT IO for everything
11:47:57 <Guest89445> did i?
11:47:59 <rvn_> eacameron, have you tried Text.Regex?
11:48:15 <hpaste_> byorgey annotated “Verschachtelte Monaden” with “Alternative formulation using MaybeT everywhere” at http://hpaste.org/52246#a52248
11:48:16 <ski> Guest89445 : did you what ?
11:49:08 <byorgey> wyfrn: the point is that MaybeT lets us "combine" the effects of IO and the effects of Maybe into a single monad
11:49:26 <byorgey> then those functions can just be composed with (>=>) as usual
11:49:32 <mm_freak> > fix ("not to be or to be and (" ++)
11:49:33 <lambdabot>   "not to be or to be and (not to be or to be and (not to be or to be and (no...
11:49:37 <ski> (or the effects of `Maybe' with plain any other monad)
11:50:22 <DanBurton> :t (>=>)
11:50:23 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:50:44 <ski> dolio : btw, `EilenbergMoore' ought to have kind `(* -> *) -> (* -> * -> *)' so that `EilenbergMoore m' could be an `Arrow' if `m' is a `Monad'
11:51:12 <dolio> Oh.
11:51:30 <wavewave> hi.
11:51:31 <dolio> In that case, I don't think you can define it in Haskell.
11:51:43 <Eduard_Munteanu> wavewave: hi
11:51:50 <dolio> The EilenbergMoore category doesn't have the same objects as the base category.
11:52:03 <dolio> Unless there's an alternate way to present it.
11:52:20 <ski> h, *nod*
11:52:25 <ski> s//m/
11:52:46 <dolio> I know there's an alternate way to present the Kleisili category that doesn't have the underlying objects, but I haven't seen the reverse for EM.
11:52:47 <byorgey> h, *nomd*?
11:53:06 <ski> yes
11:53:40 * ski nibbles away the bits in the words
11:56:14 <shirt> is there a way to run "atomically" that allows only reading and not writing of TVars?
11:56:33 <ski> hm, interesting question
11:56:35 * ski doesn't know
11:57:04 <elliott> shirt: you could build such a monad that _statically_ guarantees this easily
11:57:22 <wavewave> shirt: you just want to hide writing?
11:57:29 <Eduard_Munteanu> I think that's a problem with IO, generally
11:57:34 <wyfrn> byorgey: the functions i mentioned are just some examples to understand the way of combining ... i want to combine some functions of the Haskell TagLib binding so i can't change any signatures
11:57:35 <shirt> wavewave: i want what elliott just said
11:57:58 <elliott> shirt: newtype STMRO a = STMRO { unSTMRO :: STM a } deriving (Monad, ...); atomicallyRO = atomically . unSTMRO; readTVarRO :: TVar a -> STMRO a; readTVarRO = STMRO . readTVar
11:58:02 <elliott> shirt: and don't export the constructor
11:58:24 <elliott> shirt: of course, you need to write RO versions of all the functions on other STM structures, but it's as simple as "STMRO . readOnlySTMFunction" in most cases
11:58:37 <wavewave> sounds like building a Reader monad from from State monad.
11:58:55 <elliott> wavewave: except other threads can't touch the state in State ;-)
11:59:07 <byorgey> wyfrn: ok, well, you can use the first annotation I pasted.
11:59:23 <wavewave> elliott:  yes. STM state monad to STM reader monad. ;-)
11:59:33 <ski> elliott : well, it'd be nice if we could get different read-only parts to commute with each other
11:59:44 <elliott> ski: hm?
11:59:58 <elliott> ski: you mean to avoid overhead?
12:00:09 <byorgey> wyfrn: if you have trouble understanding it, let me know; I realize it's probably not obvious
12:00:21 <ski> elliott : yeah
12:00:27 <elliott> ski: it would be nice, sure
12:00:33 <wyfrn> byorgey: oh sry i missed your links ...
12:00:40 <elliott> ski: it'd be even cooler if "atomically" automatically did that if you didn't write
12:00:48 <ski> indeed
12:00:53 <elliott> ski: but, oh well
12:01:07 <ski> (though sometimes you'd like the extra guarantees of having it in the types)
12:01:11 <wavewave> where can I check how many packages depends on a certain package on hackage ?
12:01:12 * Eduard_Munteanu wonders about stacking capabilities as transformers
12:01:24 <wavewave> I remember there was a website for that, but forgot it.
12:01:38 <wavewave> global package dep tree
12:01:43 <ski> wavewave : see <http://hackage.haskell.org/trac/hackage/ticket/576>
12:02:03 <elliott> Eduard_Munteanu: I had an idea for something like that once, but I ended in typeclass hell trying to realise it.
12:02:11 <elliott> ski: there's a site with it, though
12:02:14 <wavewave> ski: thanks!
12:02:16 <elliott> I think roconnor linked me to it once :P
12:02:30 <elliott> at least I think it was roconnor
12:02:31 <Eduard_Munteanu> elliott: yeah, I guess so. I guess you need to avoid explicit lifting as much as you can.
12:02:34 <elliott> probably someone starting with an r
12:02:41 <ski> (that mentions <http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html>,<http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html> which are broken now)
12:02:45 <ski> elliott ^
12:02:53 <elliott> ski: nah, it was a different domain
12:02:57 <elliott> ski: and worked only like a month ago
12:03:05 <ski> ah, then i haven't heard of that
12:03:09 <elliott> Eduard_Munteanu: the nice thing was that the capabilities were always commutative... i.e. things like Cont aren't admissable, but it' sa lot nicer to use
12:03:23 <elliott> and you can "erase" parts of the stack without running the whole thing
12:03:51 <ski> elliott : can you find it in history or anything ?
12:04:12 <elliott> ski: dunno, I lost my logs recently
12:04:15 <wavewave> ski: so now no working website now?
12:04:20 <elliott> ski: I could download the clog ones, but eh
12:04:26 <elliott> wavewave: there is one.
12:04:40 <ski> wavewave : elliott claims there was one that worked at least a month ago, but he can't recall where it was atm
12:04:56 <elliott> let's just ping people at random until someone who's awake that knows about it responds
12:05:15 <ski> maybe ther should be a lambdabot plugin for that
12:06:09 <wavewave> elliott: I have seen a website not a long time ago. I am not sure whether it was the bifunctor... or not.
12:06:31 <elliott> ski: well, there's one for getting the ops
12:06:36 <elliott> and obviously they're the most knowledgable folk around here
12:06:39 <elliott> you do the honours :P
12:07:15 <ski> heh, i think i'll refrain from using that one unless there's a troll/abuse situation
12:08:01 <wavewave> ski: ?
12:08:06 <wyfrn> byorgey: isn't Control.Monad.Maybe part of the ghc package?
12:08:19 <ski> wavewave : sorry ?
12:08:27 <ski> @index MaybeT
12:08:27 <lambdabot> bzzt
12:08:45 <ClaudiusMaximus> wavewave: http://packdeps.haskellers.com/reverse/haskell2010
12:08:53 <elliott> ClaudiusMaximus: that's not the one I was thinking of
12:08:56 <elliott> the one I was thinking of looked just like hackage
12:08:59 <elliott> but with a revdeps field :)
12:08:59 <ClaudiusMaximus> oh
12:09:05 <elliott> that one is cool too though
12:09:10 <wavewave> ClaudiusMaximus: thanks.. I am trying.
12:09:40 <elliott> wavewave: use that one until whoever it was wakes up :P
12:10:00 <ClaudiusMaximus> http://81.26.216.99/~roel/cgi-bin/hackage-scripts/package/haskell2010
12:10:29 <elliott> yep
12:10:33 <elliott> I think it has a hostname though
12:10:37 <elliott> wavewave: ski: mystery solved :)
12:11:02 <wavewave> elliott, ClaudiusMaximus, ski: thanks, all ;-)
12:11:47 <byorgey> wyfrn: oh, sorry, use Control.Monad.Trans.Maybe  instead
12:11:53 <byorgey> wyfrn: which is in the 'transformers' package
12:12:04 <elliott> byorgey: wow, it is?
12:12:12 <lambdanaut> Anybody have any hints as to how to write a pathfinding algorithm? I'm about to resort to State s a
12:12:13 <elliott> when did that happen?
12:12:17 <byorgey> the version I used was from the 'MaybeT' package but that is deprecated now
12:12:22 <byorgey> elliott: I dunno, a while ago
12:12:40 <ski> elliott : ah
12:12:52 <lambdanaut> I'm trying A Star, but the lack of state in haskell is really getting to me!
12:13:31 <wavewave> byorgey: oh.. I didn't know there was Control.Monad.Trans.Maybe... good to know.. I was using maybet package, too.
12:13:41 <pedro3005> gah. I have a function zeroes :: Integer -> Integer and I am trying to do "map (\n -> (fromInteger $ zeroes n) - (n/4)) [1..100]" and keep getting errors
12:13:46 <sm> damn you, Haskell, with your total lack of state!
12:13:59 <byorgey> lambdanaut: there is a package for A* on Hackage
12:14:25 <byorgey> lambdanaut: unless you want to implement it yourself for learning purposes.
12:14:41 <byorgey> http://hackage.haskell.org/package/astar
12:15:20 <lambdanaut> Would that be suitable for a 2dimensional list?
12:15:22 <elliott> byorgey: that's some type signature
12:15:52 <byorgey> elliott: what is?
12:16:00 <pedro3005> anyone has a suggestion?
12:16:07 <wavewave> lambdanaut: if you want updatable state, use ST monad.
12:16:07 <byorgey> lambdanaut: it's suitable for anything you want to do A* search on.
12:16:09 <lambdanaut> I think he's referring to the astar sig
12:16:15 <rwbarton> pedro3005: that `n' needs to be an Integer to pass it to zeroes, but then you cannot write `n/4'
12:16:40 <byorgey> I dunno, doesn't look that bad to me
12:16:59 <elliott> byorgey: the astar
12:17:00 <wavewave> lambdanaut: you can do exactly the same thing as other imperative language with ST monad.
12:17:20 <wavewave> still pure ;-)
12:17:21 <pedro3005> rwbarton, oh, I fixed it. thanks
12:17:26 <elliott> if it doesn't look too bad to you I'm probably scared of your type signatures too :P
12:19:19 <byorgey> elliott: heh, probably =)
12:19:37 <ski> @where revdeps
12:19:37 <lambdabot> I know nothing about revdeps.
12:19:43 <ski> @where+ revdeps "Show reverse dependencies" at <http://hackage.haskell.org/trac/hackage/ticket/576>, "Hackage with Reverse Dependencies" by Roel van Dijk at <http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html>,"Reverse Dependencies" at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html>, : <http://packdeps.haskellers.com/reverse> -- `bifunctor.homelinux.net' appears broken, use `81.26.216.99' instea
12:19:44 <lambdabot> It is stored.
12:19:57 <elliott> inste
12:20:04 <ski> elliott,wavewave,ClaudiusMaximus ^
12:20:06 <elliott> you should probably just omit the broken link :P
12:20:09 <elliott> since it got cut off
12:20:11 <elliott> at "inste"
12:20:21 <ski> elliott : well, it might be a temporary problem
12:20:29 <elliott> ski: dunno, I've only heard the other version for months
12:20:40 <elliott> although I do recall a domain name rather than 81.26.216.99
12:20:50 <elliott> definitely never seen the bifunctor apart from in that ticket
12:20:54 <wyfrn> byorgey: could you please take a look at the original code? i tried to apply the monadtransformer thing but theres is still an error
12:21:02 <ski> @where+ revdeps "Show reverse dependencies" at <http://hackage.haskell.org/trac/hackage/ticket/576>, "Hackage with Reverse Dependencies" by Roel van Dijk at <http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html>,"Reverse Dependencies" at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html>, : <http://packdeps.haskellers.com/reverse> -- `bifunctor.homelinux.net' is broken, use `81.26.216.99' instead
12:21:02 <lambdabot> I will never forget.
12:21:12 <DukeDave> Quiz: If I specify "c-sources" in a .cabal file, and then do "cabal build" twice in succession, will all the "c-sources" be compiled twice?
12:21:32 <byorgey> wyfrn: sure
12:21:43 <wyfrn> byorgey: http://hpaste.org/raw/52249
12:22:28 <byorgey> wyfrn: what are the types of TL.tag  and TL.open path ?
12:23:21 <wyfrn> these are functions of the taglib binding ... open :: String -> IO (Maybe TagFile) and tag :: TagFile -> IO (Maybe Tag)
12:23:55 <byorgey> wyfrn: ok, since open :: String -> IO (Maybe TagFile), then  open path :: IO (Maybe TagFile)
12:24:20 <byorgey> wyfrn: so  MaybeT . TL.open path  does not make sense because it is trying to compose the function  MaybeT  with  TL.open path, which is not a function
12:24:29 <byorgey> wyfrn: instead, just write   MaybeT (TL.open path)
12:24:52 <byorgey> MaybeT :: m (Maybe a) -> MaybeT m a
12:25:13 <donri> the wiki could benefit from some styling of blockquotes; currently they look just like paragraphs, example http://haskell.org/haskellwiki/Introduction
12:26:54 <byorgey> wyfrn: then you also want to remove the . after runMaybeT
12:27:39 <byorgey> wyfrn: also, I recommend giving type signatures for all your functions... it's good that you gave one for toTag but you should write one for readTag too
12:27:55 <ski> @where hackage
12:27:55 <lambdabot> http://hackage.haskell.org/package/
12:28:11 <ski> @where+ hackage <http://hackage.haskell.org/package/>, also see `revdeps'
12:28:11 <lambdabot> Nice!
12:30:14 <DanBurton> @where hackage
12:30:14 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
12:30:38 <wyfrn> byorgey: i thought i can ommit signatures if there is haddock documentation ... but there is still an error i don't understand
12:31:04 <elliott> you can always omit signatures but you shouldn't
12:31:12 <elliott> not for top-level declarations
12:31:55 <elliott> donri: wow, that page still uses the "quick"sort example?
12:32:04 <donri> heh
12:32:16 <elliott> "In particular, strong typing means no core dumps! There is simply no possibility of treating an integer as a pointer, or following a null pointer." -- it's quite easy to follow a null pointer with Haskell's pointer support...
12:32:23 <elliott> although indeed the former is eliminated
12:34:22 <wyfrn> byorgey: i think i need some time to read and understand the docs ... thank you very much for your help
12:34:35 <shachaf> elliott: unsafeCoerce?
12:34:41 <shachaf> It's a useful function, unsafeCoerce.
12:34:45 <shachaf> @quote ddarius unsafeCoerce
12:34:45 <lambdabot> ddarius says: isJust . unsafeCoerce
12:34:54 <elliott> @quote ddarius unsafeCoerce
12:34:55 <lambdabot> ddarius says: isJust . unsafeCoerce
12:34:56 <shachaf> s/\./=/
12:34:58 <elliott> Where's the good one?
12:35:04 <elliott> It included a type signature too.
12:35:06 <elliott> @quote isJust
12:35:06 <lambdabot> ddarius says: isJust . unsafeCoerce
12:35:07 <DanBurton> keep trying? :)
12:35:09 <elliott> @quote isJust
12:35:09 <lambdabot> ddarius says: isJust . unsafeCoerce
12:35:10 <elliott> @quote isJust
12:35:11 <lambdabot> ddarius says: isJust . unsafeCoerce
12:35:15 <Eduard_Munteanu> Strong and safe typing, rather.
12:35:15 <elliott> Who removed it and added that nonsense? :/
12:35:20 <DanBurton> @quote unsafeCoerce
12:35:21 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
12:35:24 <shachaf> elliott: I recommend @forget and @remember at once.
12:35:35 <elliott> shachaf: yes, let me just grep down the original
12:35:48 <DanBurton> @quote unsafeCoerce
12:35:48 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
12:35:51 <elliott> @forget ddarius isJust . unsafeCoerce
12:35:52 <lambdabot> Done.
12:35:55 <elliott> @remember ddarius isJust :: Maybe a -> Bool; isJust = unsafeCoerce
12:35:56 <lambdabot> Okay.
12:36:17 <shachaf> elliott: You could always make it :: Maybe a -> b and live dangerously.
12:36:26 <elliott> shachaf: You could even make it (a -> b).
12:36:41 <DanBurton> so how exactly does the deep magic of `unsafeCoerce` work?
12:36:53 <elliott> DanBurton: by doing nothing
12:36:59 <dmwit> DanBurton: Types are erased at runtime.
12:37:00 <elliott> unsafeCoerce is just id that forgets to check its types :)
12:37:05 <dmwit> DanBurton: So there's nothing to do.
12:37:13 <DanBurton> that...is really nasty
12:37:15 <shachaf> @quote unsafeCoerce.*general
12:37:15 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
12:37:24 <elliott> DanBurton: It's like C++ reinterpret_cast.
12:37:26 <shachaf> DanBurton: Nastier than (foo)bar in C?
12:37:32 <elliott> DanBurton: (Not quite a C-style cast, because they do integral<->floating point conversion.)
12:37:51 <Eduard_Munteanu> More like casting pointers.
12:37:57 <elliott> Yeah.
12:38:04 <dmwit> C conflates casts and coercions.
12:38:18 <DanBurton> yeah, in C, (int)3.3 doesn't just interpret the double representation of 3.3 as an int
12:38:19 <elliott> C conflates lots of things.
12:38:23 <ski> (nice alliteration)
12:38:32 <wavewave> @google revdeps
12:38:34 <lambdabot> http://www.gentoo.org/doc/en/gentoolkit.xml
12:38:34 <lambdabot> Title: Gentoo Linux Documentation -- Gentoolkit
12:38:51 <wavewave> @where revdeps
12:38:51 <lambdabot> "Show reverse dependencies" at <http://hackage.haskell.org/trac/hackage/ticket/576>,"Hackage with Reverse Dependencies" by Roel van Dijk at <http://bifunctor.homelinux.net/~roel/hackage/packages/
12:38:52 <lambdabot> hackage.html>,"Reverse Dependencies" at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html>,<http://packdeps.haskellers.com/reverse> -- `bifunctor.homelinux.net' is
12:38:52 <lambdabot> broken, use `81.26.216.99' instead
12:39:09 <wavewave> ski: okay, I got it. thanks!
12:40:59 <geheimdienst> anyone know anything about the hal6 workshop tomorrow in leipzig? i was thinking of spontaneously showing up, but i haven't registered on the website. i'm not sure if people are supposed to gate-crash it ...
12:45:16 <amgarchIn9> hi, cabal install cmdlib produced this http://hpaste.org/52250 Any advices?
12:47:11 <dcoutts> amgarchIn9: looks like it was designed for mtl-1 not 2
12:48:22 <Saizan> that instance is not even in transformers but in base now
12:48:34 <geheimdienst> the clash concerns the transformers package. what i don't get is why it's even importing that. http://hackage.haskell.org/package/cmdlib-0.3.3 does not list transformers ...
12:48:37 <wavewave> amgarchIn9 : try cabal install cmdlib --constraint="mtl<2"
12:48:51 <byorgey> amgarchIn9, dcoutts: it also looks like the .cabal file naughtily does not specify version ranges for its dependencies
12:48:52 <elliott> geheimdienst: mtl depends on transformers.
12:49:06 <geheimdienst> elliott: oh i see, thanks
12:49:15 <elliott> geheimdienst: (as of version 2 :P)
12:49:34 <byorgey> mornfall ought to be ashamed
12:49:43 <mornfall> Oh?
12:49:46 <wavewave> amgarchIn9: but before doing that, I suggest you to do in cabal-dev
12:49:50 <mornfall> Oh!
12:49:54 <byorgey> mornfall: see above.
12:50:14 <mornfall> I am honoured that people install cmdlib. :D
12:50:39 <mornfall> What elliott says, though.
12:50:56 <wavewave> mornfall : if possible, please make the library compatible with mtl-2. ;-)
12:51:03 <mornfall> I am pretty sure I compile with mtl 2.
12:52:07 <mornfall> %snip% (PackageName "mtl") (IntersectVersionRanges AnyVersion (ThisVersion (Version {versionBranch = [2,0,1,0] %snip%
12:52:46 <mornfall> So something else must have dragged in mtl 1.
12:52:54 <olmo> i'm starting my happstack server using "runhaskell server.hs &", but how do i bring it down properly? I noticed that if i just kill $!, there is still another process left and it's hogging the port.
12:53:18 <wavewave> mornfall: yeah.. that's true.. I found that I also have installed your library.. I only had mtl-2.
12:53:43 <Saizan> mornfall: don't define your own instance of Monad (Either e)
12:53:53 <geheimdienst> mornfall: what version of the transformers package do you have? because the guy reported this failure: http://hpaste.org/52250
12:54:08 <mornfall> geheimdienst: Yes, I have seen that paste.
12:54:26 <Saizan> btw, i think the problem is that transformers had the Monad (Either e) instance only for a while, it got moved to base later
12:54:26 <mornfall> transformers-0.2.2.0
12:54:58 <geheimdienst> ... damn that's confusing ...
12:55:22 <mornfall> if !MIN_VERSION_base(4,3,0)
12:55:22 <mornfall> instance Monad (Either e) where
12:55:27 <mornfall> %snip%
12:56:06 <Saizan> solved :)
12:56:08 <mornfall> Is MAX_VERSION_transformers something that exists?
12:56:20 <wavewave> amgarchIn9 : what version of ghc are you using?
12:56:32 <Saizan> mornfall: can't you just import COntrol.Monad.Trans.Error?
12:57:01 <DukeDave> Would anyone like to comment on where the documentation alluded to here[1] has gone?
12:57:01 <DukeDave> [1] http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#More_complex_build_systems
12:57:11 <DukeDave> (http://www.haskell.org/ghc/docs/latest/html/Cabal/index.html)
12:57:17 <Saizan> i presume it'll reexport the instance from Control.Monad.Instances for later versions of base
12:57:48 <geheimdienst> DukeDave: have a look at this http://www.haskell.org/cabal/users-guide/
12:57:59 <mornfall> Saizan: I have no idea. I got that instance in a patch from someone who could not get cmdlib to build on their version of base.
12:59:00 * geheimdienst <- afk
12:59:08 <Saizan> mh, i guess you're already importing it somehow, or we wouldn't have the build failure
12:59:27 <amgarchIn9> wavewave: 6.12.1 Ubuntu LTS
12:59:31 <byorgey> DukeDave: http://www.haskell.org/cabal/users-guide/
13:00:04 <dcoutts> DukeDave: thanks for pointing out the broken link, fixed.
13:00:25 <mornfall> Well, I guess the only reliable fix involves killing the patient... (i.e. enforcing base > 4.3 or something to that effect).
13:00:36 <DukeDave> dcoutts: You confused me then, I went to edit it myself (after logging in to the wiki) and it had changed :D
13:00:44 <dcoutts> DukeDave: hah
13:01:25 <wavewave> amgarchIn9 : probably, you need to touch the source code of cmdlib right now for installation.
13:01:28 <mornfall> dcoutts: Are the MIN_VERSION_* things provided by Cabal?
13:01:53 <mornfall> Ah, found it.
13:01:56 <dcoutts> mornfall: yes, specifically by the simple build system (and its variants)
13:01:59 <dankna> :t fail
13:02:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
13:02:05 <mornfall> Unfortunately, there is no MAX_VERSION...
13:02:33 <dcoutts> mornfall: there is the actual version though
13:02:44 <wavewave> amgarchIn9: or wait for mornfall to succeed in embracing your case.. :)
13:03:04 <mornfall> dcoutts: Can't do much else than equality on strings with CPP though.
13:03:10 <elliott> mornfall: They're numbers, I think.
13:03:21 <elliott> Decimal fixed point :-)
13:03:24 <mornfall> elliott: Definitely strings in the header I am looking at.
13:03:30 <elliott> Aw.
13:03:32 <mornfall> #define VERSION_split "0.1.4.1"
13:04:03 <mornfall> You can't compare versions as decimal numbers anyway.
13:04:14 <mornfall> Since 0.10.1 > 0.1.1
13:04:29 <elliott> You could use Data.Version ... in the type system.
13:04:38 <mornfall> Forget it.
13:04:44 <elliott> mornfall: Just enumerate every version explicitly before the one you need :P
13:05:03 <dcoutts> mornfall: can you do anything with min_version_foo(,,) && !min_version_foo(,,) ?
13:05:58 <mornfall> Hm.
13:06:03 <mornfall> Maybe I really want MIN_VERSION.
13:06:49 <mornfall> Why, googling for tranformers fails to DWIM. :P
13:07:35 <elliott> That's why I use DWIMgle. Also because of the name.
13:07:42 <elliott> It sounds almost as silly as "Google".
13:07:56 <mornfall> Guess what.
13:08:18 <elliott> I can't guess.
13:08:26 <mornfall> transformers 0.2.2 ship the Monad (Either e) instance wrapped in #if !(MIN_VERSION_base(4,2,1))...
13:08:32 <amgarchIn9> cabal upgrade base says "cabal: fromFlag NoFlag. Use fromFlagOrDefault" How do I interprete that?
13:08:42 <elliott> mornfall: lol
13:08:52 <wavewave> amgarchIn9 : oh no..
13:08:55 <dcoutts> amgarchIn9: don't use cabal upgrade.
13:09:07 <wavewave> amgarchIn9 : that'll cause nightmare..
13:09:10 <dcoutts> amgarchIn9: in later versions of cabal it's been removed.
13:09:47 <dcoutts> amgarchIn9: you want cabal install, and you cannot install base. Its version is fixed with the version of ghc.
13:09:48 <wavewave> amgarchIn9 : base comes with your ghc. so it's not upgradable anyway
13:09:52 <mornfall> transformers-0.2 ships that instance unconditionally
13:10:15 <mornfall> So that means I want transformers >= 0.2.2 and kill my copy, right?
13:10:56 <mornfall> Seems so, no hideous build-depends in transformers.
13:11:22 <mornfall> But that means no mtl < 2 for me.
13:11:27 <mornfall> Booh.
13:11:51 <mornfall> Or maybe I can flag around that.
13:12:06 <wavewave> amgarchIn9 : erase instance Monad (Either e) ... part in Command.hs
13:12:24 <wavewave> amgarchIn9 : and compile cmdlib..
13:13:02 <mornfall> (You may need to cabal unpack cmdlib first.)
13:13:09 <wavewave> amgarchIn9 : you can find the source code in your ~/.cabal/packages/hackage.haskell.org/cmdlib/0.3.3/
13:13:44 <dcoutts> wavewave: cabal unpack means you should rarely have to go poking around in ~/.cabal/packages
13:13:55 <stepcut> let's say I have two bytestrings, such as 'foobar' and 'barbaz'. The suffix of the the first bytestring overlaps with the prefix of the second string. I want to remove the overlapping part from the second bytestring and return it. So in this case, I just want 'baz'.
13:14:17 <wavewave> dcoutts: I didn't know it until now... :-P
13:14:31 <wavewave> dcoutts, mornfall: thnx
13:14:34 <stepcut> for String and Text I can do, stripOverlap x y = fromJust $ msum $ [ stripPrefix p y | p <- tails x]. But that is not very efficient I think. And ByteString does not provide a stripPrefix
13:14:49 <stepcut> I wonder if there is a better approach
13:15:01 <wavewave> stepcut: no fromJust
13:15:09 <dcoutts> stepcut: stripPrefix is cheap once you have isPrefixOf
13:16:22 <stepcut> wavewave: ?
13:16:33 <eacameron> rvn_: Yes, but isn't that Posix based? I need a Python-like regex engine.
13:17:02 <wavewave> stepcut: ah.. I automatically respond to avoid  fromJust. this is out of context, though
13:17:13 <dankna> @hackage transformers
13:17:14 <lambdabot> http://hackage.haskell.org/package/transformers
13:17:43 <wavewave> stepcut: you can use catMaybes
13:17:58 <wavewave> or maybe
13:18:08 <stepcut> wavewave: fromJust is fine here. There is no set of inputs that will result in msum returning Nothing
13:19:50 <wavewave> stepcut: I guess so but  just good habit. anyway this is out of your interest.
13:20:21 <amgarchIn9> I only found the tarball in ~/.cabal/packages/hackage.haskell.org/cmdlib/0.3.3/ Where should it be untarred?
13:20:38 <mornfall> amgarchIn9: http://hackage.haskell.org/package/cmdlib-0.3.4 -- (since hackagebot is slacking)
13:20:49 <mornfall> amgarchIn9: I.e. cabal update && cabal install cmdlib
13:20:54 <mornfall> It *might* work now.
13:21:07 <stepcut> wavewave: I only used fromJust because it keeps the function total. Not sure why that would be a bad habit :)
13:21:50 <mornfall> stepcut: One problem with fromJust is that when it does fail, it's extremely uninformative.
13:22:09 <stepcut> mornfall: but it will never fail in that code
13:22:43 <mornfall> stepcut: Sure. But once you get a "fromJust: Nothing" as a result of your program, you can go and prove for each of them that it is safe.
13:23:13 * hackagebot cmdlib 0.3.4 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.3.4 (PetrRockai)
13:23:19 <stepcut> but I will never it get fromJust Nothing from that code
13:23:55 <wavewave> :t msum
13:23:56 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
13:23:57 <mornfall> stepcut: Right. But again, that's not the point. It's that when you do get a Nothing in a different fromJust, and you grep fromJust -r src and get two dozen hits, you need to decide for each one whether it could or could not fire.
13:24:02 <amgarchIn9> Ok, cmdlib 0.3.4 installs, thanks. But all in vain: "setup: The package darcs-fastconvert-0.2.1 requires the following languages which are not supported by ghc-6.12.1: Haskell2010"
13:24:19 <stepcut> mornfall: only if you are foolish enough to use fromJust calls that could fail
13:24:19 <wavewave> > (msum [] :: Maybe [Int])
13:24:20 <lambdabot>   Nothing
13:24:47 <mornfall> stepcut: I use a statically typed language because I am foolish enough to do just that. :-)
13:25:07 <mornfall> If I never made mistakes, the type system'd be superfluous.
13:25:14 <mornfall> More or less.
13:25:27 <wavewave> stepcut : are you sure that your tails
13:25:35 <wavewave> does not give empty list?
13:25:52 <mornfall> amgarchIn9: Is that for the darcs/git bridge?
13:26:01 <mornfall> amgarchIn9: Or just fastconvert from hackage?
13:26:11 <mornfall> Hm.
13:26:26 <mornfall> 0.2.1 sounds like the hackage version.
13:26:28 <amgarchIn9> yes. Older darcs-fastconvert did compile and worked.
13:26:38 <stepcut> wavewave: it does, but, stripPrefix [] [], is Just []
13:26:58 <mornfall> amgarchIn9: You need better GHC then, I guess.
13:27:14 <stepcut> perhaps I should rewrite this in Agda so I can prove that it will never fail?
13:27:45 <Twey> Heh
13:27:47 <wavewave> stepcut: your stripPrefix is in list comprehension. .so if tails x gives [] then the total list will be empty regardless of stripPrefix.
13:28:01 * Twey imagines a world where people code in Haskell & drop into Agda for potentially unsafe code.
13:28:11 <wavewave> > [undefined | x <- [] ]
13:28:12 <lambdabot>   []
13:28:22 <parcs> @hoogle liftIO
13:28:22 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
13:28:23 <stepcut> Twey: why? Writing haskell-like code in Agda is not that hard to start with..
13:28:41 <amgarchIn9> .cabal says "default-language: Haskell2010" What would be a more conservative name?
13:28:43 <wavewave> stepcut: so I think your fromJust seems a real bug.
13:29:41 <Twey> stepcut: Libraries?  :þ
13:30:10 <parcs> how does one resolve package ambiguities in when importing a module in ghci?
13:30:47 <sm> parcs: by reading that part of the ghci manual quite carefully.. otherwise it's really confusing
13:30:50 <luite> parcs: by using cabal-dev ghci :)
13:31:11 <stepcut> > (\x y -> fromJust $ msum $ [ stripPrefix p y | p <- tails x]) [] []
13:31:12 <lambdabot>   []
13:31:17 <stepcut> > (\x y -> fromJust $ msum $ [ stripPrefix p y | p <- tails x]) ['a'] []
13:31:17 <lambdabot>   ""
13:31:25 <stepcut> > (\x y -> fromJust $ msum $ [ stripPrefix p y | p <- tails x]) [] ['b']
13:31:26 <lambdabot>   "b"
13:31:32 <stepcut> > (\x y -> fromJust $ msum $ [ stripPrefix p y | p <- tails x]) ['a'] ['b']
13:31:32 <lambdabot>   "b"
13:31:37 <stepcut> > (\x y -> fromJust $ msum $ [ stripPrefix p y | p <- tails x]) ['a'] ['a']
13:31:37 <lambdabot>   ""
13:31:43 <stepcut> show me a case where it fails..
13:32:02 <wavewave> stepcut: okay, tails x does not give [] at all.
13:32:15 <wavewave> tails x does give [[]]
13:32:19 <stepcut> yup
13:32:49 <parcs> i wish PackageImports worked in ghci import statements
13:33:03 <parcs> sm: what part
13:33:46 <wavewave> stepcut: anyway, it is easy to miss where the real proof is going..  in this case tails, but you can think it is stripPrefix.. that's easy to miss. so avoiding fromJust is not a bad idea.
13:33:47 <stepcut> parcs: simon said somethig about the full language being available at the ghci prompt in an upcoming release. Perhaps that includes the package imports?
13:34:08 <stepcut> wavewave: you think I should write code that will proveably never be called?
13:34:39 <rwbarton> PackageImports statements already work in ghci 7.2.1
13:34:58 <stepcut> rwbarton: when you type that at the GHCi prompt?
13:35:07 <wavewave> stepcut: come on... I mean what is a good idea in general. I would not proceed this discussion more anyway since it's out of context.
13:35:22 <ski> @type \x y -> head [ s | p <- tails x,Just s <- [stripPrefix p y] ]
13:35:23 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:35:37 <rwbarton> http://hpaste.org/52252
13:35:53 <stepcut> rwbarton: epic!
13:36:13 <parcs> rwbarton: are you actually resolving an ambiguity?
13:36:27 <rwbarton> no
13:36:27 <parcs> i.e does import Control.Monad.Trans work
13:36:49 <ski> @type \x y -> case [s | p <- tails x,Just s <- [stripPrefix p y]] of s:_ -> s
13:36:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:36:56 <rwbarton> I don't have any ambiguous modules currently in my installation, I think
13:37:01 <parcs> well that works for me too, when the module name isn't ambiguous
13:37:16 <ski> stepcut : ^ you wouldn't have to write code that will probably never be called
13:37:36 <stepcut> ski: oh ?
13:37:52 <parcs> import "mtl" Control.Monad.Trans --> Ambiguous module name `Control.Monad.Trans': it was found in multiple packages: mtl-2.0.1.0 monads-tf-0.1.0.0
13:37:54 <rwbarton> parcs: you mean it allows the PackageImports syntax but doesn't actually use it to resolve the ambiguity?
13:37:59 <parcs> yeah
13:38:00 <rwbarton> weird
13:38:06 <ski> @type \x y -> case msum [ stripPrefix p y | p <- tails x] of Just s -> s  -- if you prefer this version
13:38:07 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:38:17 <rwbarton> sounds like a bug, doubt it will be caught by extended ghci input language
13:38:30 <stepcut> ski: but you are failing to handle the 'Nothing' case..
13:38:52 <ski> stepcut : you said it can't happen anyway -- what's the problem ?
13:39:30 <stepcut> ski: in my opinion .. there is no problem. But people who think that using fromJust there is a bad idea can't possibly think that not handling the Nothing case is any better since it is the same thing...
13:39:39 <stepcut> shapr: boing!
13:39:58 <ski> stepcut : the advantage would be (a) if something is wrong, and it does happen, you will get an error message pinpointing that place in the code; and (b) one less case to worry about if you get a mysterious `fromJust' error
13:40:28 <stepcut> ski: ah. A better error message that will never happen ;)
13:40:36 <ski> stepcut : yes :D
13:41:29 <ski> stepcut : the difference between `fromJust' erroring and the `case' matching failing is that in the latter case you get better diagnostics
13:41:50 <ski> so not using `fromJust' is usually preferable, imo
13:42:19 <shapr> stepcut: h0p!
13:42:31 <stepcut> shapr: when is your book coming out ?
13:43:25 <taotree> is there a way to do shared memory interprocess communication in haskell?
13:43:25 <ski> stepcut : for the (b) part, assume you're using some libraries, and you get a `fromJust' erroring -- even if you never make mistakes, possibly other library writers can, so by not using `fromJust' here, you help (a little bit) with hunting down which part of the program / library generated the error
13:44:47 * ski wonders how an implementation of correct blame assignments (even for HOFs) and contracts (like in PLT Scheme^W^WRacket) would look like in Haskell
13:45:16 <stepcut> maybe I'll just add a comment.
13:45:16 <tac-tics> what's a blame assignment?
13:45:28 <tac-tics> and contracts like in Eiffel?
13:45:36 <ski> tac-tics : assume you're written a function that only works on positive integers
13:46:07 <ski> tac-tics : and assuming the input is a positive integer, the result should always be a positive rational
13:46:29 <ski> tac-tics : so, these are two contracts, referring to the input respectively the output of the function
13:46:33 <tac-tics> yeah
13:46:42 <ski> we can *combine* these two contracts, to make a contract for the function itself
13:46:56 <ski> and we implement this by first checking the input contract for the input, when the function is called
13:47:03 <ski> if it fails, we blame the caller
13:47:12 <stepcut> ski: didn't somebody do that for haskell already?
13:47:14 <ski> otherwise we run the function, and then check the output contract
13:47:16 * stepcut tries to google it
13:47:27 <ski> if *that* fails, then we blame the callee itself, i.e. the function
13:47:37 <ski> now, just doing this isn't so tricky
13:47:55 <tac-tics> ski: Are we talking dynamic contracts or static?
13:47:56 <ski> the tricky part is getting this right while allowing contracts for higher-order functions
13:48:05 <ski> dynamic contracts, checked at runb-time
13:48:11 <tac-tics> ok
13:48:11 <ski> s/b-/-/
13:48:12 <tac-tics> I gotcha
13:49:03 <ski> so, if we have a HOF, that takes a function as argument, which is expected to conform to a given contract, then if the input contract for that function fails, we don't want to blame the caller of the HOF, but the HOF itself, since it called the argument function incorrectly
13:49:27 <stepcut> ski: http://gallium.inria.fr/~naxu/slides/escHaskell.pdf
13:50:57 <byorgey> ski: contracts for HOFs with proper blame assignment is well-understood, IIUC
13:51:29 <ski> yes -- but i couldn't recall seeing an implementation of it for Haskell
13:52:05 <byorgey> oh, yeah, I don't know of one
13:53:14 * hackagebot cereal-enumerator 0.1 - Deserialize things with cereal and enumerator  http://hackage.haskell.org/package/cereal-enumerator-0.1 (PatrickPalka)
13:54:09 <elliott> no deserialisation support? pshaw
13:54:25 <elliott> (why does my spellchecker know pshaw?)
13:54:38 <ddarius> Because it is a word.
13:54:55 <elliott> my spellchecker doesn't know about lots and lots of words
13:55:46 <ddarius> Maybe you shouldn't get your spellchecker from southern Alabama.
13:56:31 * ddarius just now realizes that it is fall again.
13:58:06 <cgroza> I love summer.
13:58:10 <ski> stepcut : i'm not quite sure, but that appears to be a static checking system
13:58:35 <stepcut> ski: you want runtime?
13:58:44 <ski> i was talking about a run-time system, yes
13:58:55 <stepcut> gross :)
13:59:05 <ski> well, ideally, we want both
13:59:26 <ski> (hopefully in a single system, or at least with two systems that get on well with each other)
13:59:53 <ski> what we can easily check statically, we of course check statically
14:00:19 <ski> what we can hardly check statically, we need dynamic checks
14:00:50 <stepcut> what is something you can not check statically?
14:00:56 <ski> (stepcut : btw, recall that QuickCheck is a run-time system :)
14:01:01 <gr0g> hi, where i can find an algorithm or some theory to delete a node from a binary tree?
14:01:31 <Botje> in an algorithms textbook, i guess.
14:01:36 <vicvicvic> is there an easy (and rather "generic") way of using parsec to verify that a string is formatted in some way and then just getting that string? e.g. i need to parse a string which must be formatted as '5a' (one digit followed by one letter) but am not really interested in structuring them (it's just that the identifier in question must follow this pattern)
14:01:52 <Botje> you basically replace the deleted node by the right-most leaf of its left subtree
14:01:55 <ski> stepcut : well, possibly stuff like checking that two integers computed by an algorithm are coprime
14:02:24 <vicvicvic> (:) <$> digit <*> letter works in this specific case, but yeah
14:02:38 <ziman> @pl (\x -> either (\b -> (fst x, b)) (\c -> (fst x, c)) (snd x))
14:02:39 <lambdabot> ap (ap (either . (,) . fst) ((,) . fst)) snd
14:03:14 <byorgey> vicvicvic: why don't you write a combinator  recognize :: [Parser String] -> Parser String
14:03:16 <wavewave> stepcut: ESC/haskell is being implemented as a GHC extension now?
14:03:44 <stepcut> wavewave: no idea. If I had to guess I would say.. no.
14:04:04 <vicvicvic> byorgey: well, because i dont know how :)
14:04:19 <wavewave> looks very cool!
14:04:31 <byorgey> vicvicvic: I bet you could figure it out =)
14:04:38 <wavewave> with SPJ as an advisor..
14:05:14 <byorgey> vicvicvic: try  recognize ps = concat `liftM` sequence ps
14:05:15 <stepcut> ski: of course, you can already write all the runtime checks you want..
14:05:31 <ski> vicvicvic : hm, good example .. there ought to be a `both :: Parser a -> Parser b -> Parser (a,b)' which parses the *same* input with both parsers
14:05:45 <ski> stepcut : yeah, but i want blame correctly assigned
14:05:46 <byorgey> vicvicvic: that runs each of the supplied parsers in sequence, collecting their results (sequence ps), then concatenates the results (liftM concat)
14:05:57 <vicvicvic> byorgey: i see, yeah, thanks
14:06:06 <gr0g> Botje: thanks
14:06:55 <Botje> (the left-most leaf of the right subtree is also an option, of course)
14:07:38 <ski> byorgey : hm, would you know whether there's a way to do that ^ (parsing the same (sub-)input with two parsers, preferably efficiently, if possible) ?
14:08:37 <byorgey> ski: not with parsec, that I know of
14:09:28 <byorgey> ski: but yes, that would work well, then you could just write  liftM snd (both (digit >> letter) (many anyChar))  or whatever
14:09:56 <byorgey> ski: this is one of the subjects covered in Tomas Petricek's recent Monad.Reader article (Issue 18)
14:10:13 <byorgey> I wonder whether edwardk's parsing library can do it
14:13:56 <ski> byorgey : ah, ty
14:14:19 * ski has pondered this problem in the context of DCG parsers in Prolog before
14:14:41 <ski> (also i've heard another person independently inventing this in Prolog as well)
14:15:06 <ski> this `both' feels a bit like the additive conjunction in linear logic, btw
14:19:54 <quickly> I'm reading the paper "Typed Logical Variables in Haskell" and having trouble translating the functions "true" and "false" into the backtracking monad transformer the authors create. Does anyone have any hints or tips?
14:20:39 <kamaji> Can anyone remember the extension that allows multiple instances per type using type synonyms?
14:22:27 <kamaji> I left it on my bloody work browser
14:23:15 <rwbarton> surely that doesn't exist?
14:23:28 <Saizan> quickly: i.e. always succeeding and never succeeding actions?
14:23:28 <kamaji> I swear I saw it
14:23:33 <Twey> TypeSynonymInstances
14:23:44 <kamaji> yay
14:23:46 <kamaji> Twey: I love you
14:23:54 <Twey> You're welcome :þ
14:24:01 <kamaji> :D
14:24:02 <rwbarton> that doesn't do what you said
14:24:04 <Saizan> quickly: in that case you could e.g. true = return 0; false = mzero, assuming a MonadPlus instance
14:24:13 <rwbarton> ... or does it?
14:24:14 <ddarius> ()
14:24:19 <ddarius> No, it doesn't.
14:24:29 <kamaji> ok maybe I misread it, but I think that's what I was looking at~
14:24:31 <Twey> Hm?
14:24:50 <Twey> It does allow it, doesn't it?
14:25:02 <Saizan> quickly: sorry, i meant true = return ()
14:25:03 <rwbarton> it doesn't allow "multiple instances per type"
14:25:11 <kamaji> right
14:25:13 <Twey> Oh, but you need UndecideableInstances or something, yeah
14:25:14 <kamaji> but you can add a synonym
14:25:18 <wavewave> kamaji: OverlappingInstances?
14:25:21 <rwbarton> it just lets you write a type synonym in place of its expansion
14:25:26 <rwbarton> in an instance declaration
14:25:26 <kamaji> yeah
14:25:30 <kamaji> and then it's treated differently
14:25:31 <ddarius> Twey: Nothing will let you do that.
14:25:33 <kamaji> when you refer to the synonym?
14:25:35 <Twey> Nothing?
14:25:35 <rwbarton> no
14:25:36 <quickly> Yeah: the non-transformer version uses e.fg (\s -> mzero) for false. I think the corresponding function for the transformer should be BackT (\s -> mzero), but GHC doesn't like this.
14:25:40 <kamaji> balls
14:25:41 <rwbarton> this would be a very very bad feature
14:25:47 <kamaji> why is that?
14:25:49 <elliott> kamaji probably means FlexibleInstances, dudes.
14:25:51 <elliott> Like [Bool] vs. [Char].
14:25:58 <elliott> That doesn't require anything bad at all.
14:25:58 <wavewave> I often have to use FlexibleInstances, FlexibleContexts,
14:26:03 <elliott> And is commonly seen with TypeSynonymInstances.
14:26:05 <elliott> (Because String = [Char])
14:26:13 <wavewave> TypeSynonymInstances, OverlappingInstances, IncoherentINstances
14:26:21 <elliott> wavewave: :(
14:26:22 <wavewave> etc..
14:26:24 <elliott> wavewave: You shouldn't do that.
14:26:33 <Twey> Yeah, no, that's bad.
14:26:39 <rwbarton> FlexibleInstances, FlexibleContexts, TypeSynonymInstances are ok, OverlappingInstances, IncoherentINstances are not ok
14:26:57 <elliott> SelfContradictoryInstances
14:27:05 <wavewave> Hmm. Not for haskell in fact.. for making C++ binding.
14:27:11 <elliott> InstancesThatDon'tEvenNameAClassWhyTheHellNot
14:27:14 <Twey> ExplodingInstances
14:27:16 <quickly> Hmm - nevermind, I figured it out. A stupid error on my part.
14:27:24 <elliott> InstancesWithSyntaxErrors
14:27:28 <acowley> I wrote some TH for generating instance and helper functions for the "overwritable Monoid" pattern things like snap-server use for configuration. Should I bother putting it on hackage, or instead just write a blog post with a github link?
14:27:41 <Twey> DeriveInstancesFromKeyboardMashing
14:27:53 <kamaji> WhatsWrongWithWantingMultipleInstances ?
14:28:03 <Twey> InstanceRoulette
14:28:03 <Twey> Hah
14:28:11 <Twey> I propose we rename IncoherentInstances to that one
14:28:13 <kamaji> AsLongAsYouSpecifyByASynonym ?
14:28:24 <kamaji> I don't know if Synonym means something specific here btw
14:28:39 <rwbarton> synonyms are just that, synonyms
14:28:39 <Twey> kamaji: It means type synonyms, of the form type X = Y
14:28:39 <kamaji> I just mean "call the class something else and treat it differently for those instances"
14:28:45 <elliott> Class?
14:28:45 <rwbarton> so they can't affect type class selection
14:28:48 <kamaji> oops
14:28:50 <wavewave> kamaji: probably, it's quite unpredictable
14:28:50 <kamaji> type
14:29:11 <elliott> kamaji: You almost certainly mean FlexibleInstances.
14:29:14 <wavewave> selecting most concrete type or someting like that.
14:29:19 <elliott> FlexibleInstances lets you have instances for [Bool] and [Char] that are separate.
14:29:23 <elliott> It does not allow instances for Int and Int.
14:29:31 <elliott> kamaji: You want a newtype if you want multiple instances for one type.
14:29:34 <elliott> newtype Foo = Foo Int
14:29:36 <elliott> instance Show Foo where ...
14:29:41 <rwbarton> I don't think that's what he means, but anyways yes a newtype is in order
14:29:45 <kamaji> elliott: that has proved problematic
14:29:59 <kamaji> I'm probably just doing it wrong
14:30:13 <kamaji> but I wanted to treat some inner types differently as well
14:30:32 <rwbarton> (Alternatively perhaps you don't want an instance at all but rather a record of functions)
14:30:50 <elliott> kamaji: Eh?
14:31:07 <kamaji> what's a codepad for haskell again?
14:31:09 <rwbarton> kamaji: here is an example of why it would be very bad
14:31:24 <rwbarton> kamaji: suppose I have a class MyClass a where myFunc :: a -> a
14:31:25 <kamaji> ok
14:31:33 <elliott> kamaji: hpaste.org
14:31:52 <rwbarton> also I have a type named Foo and I make Bar a type synonym, type Bar = Foo, and I have functions  f :: String -> Foo, g :: Bar -> Integer
14:32:08 <rwbarton> now I can write g (f "hello"), right? since Bar is a synonym for foo
14:32:10 <rwbarton> *Foo
14:33:02 <kamaji> sorry I kinda lost where the class came into it
14:33:04 <kamaji> let me write this down
14:33:07 <rwbarton> it hasn't, yet.
14:33:09 * ddarius doesn't understand why an explanation of why it would be a bad idea is necessary.  It just doesn't make any sense.
14:33:21 <kamaji> ddarius: well it's lke I want to treat the same data in different ways
14:33:23 <rwbarton> well, of course, but it seems to make sense to kamaji, so I am trying to dispel that impression
14:33:42 <kamaji> rwbarton: I appreciate you attempting to fix my noobitude :D
14:34:01 <rwbarton> all I am saying is, so far  g (f "hello")  is a well-typed expression, yes?
14:34:10 <rwbarton> since Foo and Bar are the same
14:34:17 <kamaji> let me think a sec
14:35:15 <kamaji> ok I suppose?
14:35:19 * wavewave is checking where he used OverlappingInstances and IncoherentInstances...
14:35:22 <rwbarton> Now suppose I tried to make two different instances  instance MyClass Foo  and  instance MyClass Bar
14:35:22 <kamaji> well
14:35:23 <kamaji> no
14:35:30 <kamaji> a Bar isn't a Foo
14:35:37 <kamaji> it is just an exact same representation of data
14:35:38 <rwbarton> ok here is the problem then!
14:35:42 <rwbarton> you're thinking of newtype
14:35:43 <elliott> kamaji: if you have two instances for the same type, then you would have to specify which instance you want to use every time you use it; but the whole point of typeclasses is that they're implicit, and it chooses which to use with the type. what you want is simple: a function.
14:35:44 <kamaji> or rather that's what I want
14:35:49 <elliott> kamaji: that's newtype
14:35:54 <kamaji> right, but it doesn't work for what I want to do
14:35:57 <elliott> yes it does
14:35:58 <kamaji> or at least, I think it doesn't
14:36:01 <rwbarton> "type Bar = Foo" literally means Bar is Foo
14:36:10 <elliott> if it doesn't work, you've done something wrong, but that something is not using newtypes :)
14:36:12 <kamaji> ok let me do the example :p
14:36:18 <kamaji> I'm aware i'm probably wrong~
14:36:54 <monochrom> use a newtype, or give up. give up means design some other way
14:37:18 <ddarius> give up means go back to Java
14:37:19 <monochrom> and bear in mind that the XY Problem cannot be overemphasized
14:37:30 <kamaji> the XY problem?
14:37:53 <monochrom> yeah, http://www.perlmonks.org/index.pl?node_id=542341
14:37:56 <ion> http://mywiki.wooledge.org/XyProblem
14:38:01 <ddarius> give up means forgetting this stupid programming crap and living a happy and full life as a plumber
14:38:13 <kamaji> plumbing is dull
14:38:19 <elliott> oblig.: so is programming
14:38:21 <ddarius> programming is dull
14:38:23 <kamaji> nahhhh :D
14:38:30 <wavewave> I cannot get rid of IncoherentInstances in my library. ;-(
14:38:35 <elliott> Most programming is dull, some is not.
14:38:40 <ddarius> Anyway, no one said that plumbing was exciting, just that you'd have a happy and full life.
14:38:49 <elliott> wavewave: Yes you can, IncoherentInstances doesn't increase the computational power of Haskell.
14:39:05 <elliott> wavewave: You might not be able to remove it without violating some static invariants or interface you want... but you probably can.
14:39:40 <kamaji> this example is taking a while to write
14:39:45 <kamaji> (sorry)
14:40:20 <wavewave> elliott: I am examining how I can eliminate it now..
14:41:42 <wavewave> now I get compilation error... hmm
14:43:12 <hpaste_> kamaji pasted “99 Problems and newtype is one” at http://hpaste.org/52253
14:43:23 <kamaji> well the problem is me
14:43:27 <kamaji> but that doesn't go as well
14:43:53 <kamaji> i'm guessing there's a much better way to do that
14:44:29 <elliott> "instance ShortColor Show\n" is an incoherent instance ;-)
14:44:39 <elliott> You mean "instance Show ShortColor where".
14:45:04 <kamaji> oh typos
14:45:06 <wavewave> Hmm I have a instance of ( Castable a a ) and (SomContext a) => (Castable a (Ptr RawTH1) )
14:45:07 <kamaji> also forgot where's yeah
14:45:10 <kamaji> wherers
14:45:15 <elliott> kamaji: instance Show ShortFoo where show (Foo c s) = show (ShortColor c) ++ show (ShortShape s).
14:45:16 <elliott> kamaji: HOWEVER
14:45:21 <elliott> kamaji: "Show" instances should produce valid Haskell code.
14:45:28 <elliott> kamaji: You don't want show; you want a function.
14:45:34 <kamaji> hold your horses
14:45:35 <kamaji> what now?
14:45:36 <elliott> shortColor :: Color -> String
14:45:40 <wavewave> it complains that  my type is matched for both cases..
14:45:45 <Cale> http://i.imgur.com/ALpLJ.jpg -- lol
14:45:46 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:45:49 <elliott> kamaji: Yes. You should be able to ctrl+c what show spits out and paste it into GHCi.
14:45:53 <elliott> kamaji: The resulting value should be == the argument to Show.
14:45:58 <kamaji> oh
14:46:01 <kamaji> shit
14:46:01 <kamaji> well
14:46:06 <wavewave> and ghc suggests IncoherentInstances.. ;-(
14:46:06 <kamaji> what am I implementing?
14:46:10 <elliott> kamaji: Functions.
14:46:11 <kamaji> lol
14:46:14 <elliott> Allow me to annotate.
14:46:33 <kamaji> ok let's say I want to print a human-readable string, with a PrettyPrint class
14:46:36 <kamaji> and I want two ways of printing it
14:46:41 <kamaji> pretend Show is that class
14:46:50 <kamaji> (I know...)
14:46:52 <hpaste_> elliott annotated “99 Problems and newtype is one” with “99 Problems but newtype ain't one (annotation)” at http://hpaste.org/52253#a52254
14:46:54 <mwc> So since the Haskell Platform missed the July release with no explanation, is it basically being aborted as a project?
14:46:58 <elliott> kamaji: Try that.
14:47:11 <elliott> kamaji: But if you do want it generic...
14:47:28 <elliott> kamaji: class Display a where display :: a -> String
14:47:28 <bfig> what is a parallel functor?
14:47:32 <elliott> Give instances as appropriate.
14:47:36 <acowley> I haven't been following closely, but it looks like kamaji just wants GeneralizedNewtypeDeriving?
14:48:00 <elliott> acowley: No.
14:48:10 <bfig> ie, F,G:C->D  parallel functors <= F has a morphism when G has one?
14:48:25 <kamaji> elliott: Do you mind if I slightly change the example?
14:48:30 <acowley> but that extension does just what his comment on SHortFoo asks for
14:48:34 <elliott> kamaji: Sure, go ahead, though I won't be available in a minute or so.
14:48:34 <kamaji> I'm a bit confused
14:48:38 <kamaji> oh ok
14:48:42 <kamaji> it's implementing Eq instead
14:48:50 <elliott> kamaji: Well, go ahead.
14:48:51 <kamaji> so for a Foo, I want to compare on both Color and Shape
14:48:54 <elliott> I'll be happy to tell you how exactly not to do that.
14:48:56 <kamaji> for OtherFoo I just want to compare on Color
14:48:57 <kamaji> haha
14:49:00 <elliott> kamaji: You don't want Eq.
14:49:04 <kamaji> oh
14:49:06 <kamaji> what do I want?
14:49:09 <kamaji> "a function"?
14:49:18 <elliott> kamaji: I dunno, sameColor :: Foo -> Foo -> Bool?
14:49:20 <elliott> Hey look, it's a function.
14:49:22 <elliott> :p
14:49:35 <kamaji> eh :\
14:49:42 <elliott> Values that are Eq should not be distinguishable (well, outside of the module implementing them, it's OK to have implementation details like Empty vs. Chunks []).
14:49:46 <elliott> Except in rare cases.
14:49:56 <elliott> As in, that (==) returns True for.
14:50:08 <quickly> Hmm - is there a MonadPlus instance of ST anywhere in the libraries? I can't find one.
14:50:18 <ski> bfig : i'm not sure what you're asking ..
14:50:19 <elliott> kamaji: You say eh, but trust me, you don't usually want typeclasses, and you don't ever want multiple instances for the same type.
14:50:23 <Cale> quickly: What would it do?
14:50:26 <elliott> kamaji: Functions are wonderful, learn to use them well :-)
14:50:33 <ski> quickly : i don't think so, how would it work ?
14:50:34 <Cale> quickly: (ST isn't naturally a MonadPlus)
14:50:43 <kamaji> hehe
14:50:55 <bfig> ski i'm trying to get into Ralf Heinze paper on Adjoint folds and unfolds
14:50:56 <ski> (/me isn't convinced `IO' is naturally a `MonadPlus' either)
14:51:18 <kamaji> I'm a bit confused how your Display example isn't exactly the same problem though
14:51:24 <Cale> ski: Well, it's a MonadElse, but we don't have a name for those :)
14:51:27 <brisbin> you can do multiple instances for the same type with newtypes
14:51:31 <kamaji> if I wanted two different Display behaviours for the same data "shape"
14:51:32 <ski> bfig : well, in haskell you can say e.g. `take,drop :: Int -> [a] -> [a]' meaning just `take :: Int -> [a] -> [a]' as well as `drop :: Int -> [a] -> [a]'
14:51:58 <ski> bfig : similarly, `F,G : C -> D' means just `F : C -> D' as well as `G : C -> D' -- nothing more
14:52:04 <quickly> I don't know. I think I'm going to have to have to look at monad transformers a little more and then come back to the paper's code. So I'll probably do that.
14:52:12 <bfig> ok, it makes sense
14:52:18 <ski> Cale : *nod* that might work
14:52:30 <elliott> kamaji: You don't.
14:52:47 <brisbin> data Foo = Foo, newtype AFoo = A Foo, newtype BFoo = B Foo, instance Show AFoo where..., intance Show BFoo where...
14:52:55 <conal> > [1,3 .. 10] :: [Float]
14:52:56 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
14:53:02 <elliott> kamaji: If you want two instances for one type, you either want a newtype, another class, or function.
14:53:03 <conal> does anyone know what's up with that? ^
14:53:09 <brisbin> that just lets you use show twice instead of showA and showB functions
14:53:14 <elliott> kamaji: You should consider these in order of function, newtype, another class.
14:53:19 <ddarius> conal: That's what the Report says to do.
14:53:27 <elliott> conal: It doesn't stop until the value is > 10.
14:53:34 <elliott> conal: That's because of floating point.
14:53:40 <kamaji> but what about the nested type thing :\
14:53:47 <elliott> conal: If the value isn't precisely representable, it picks the next available value
14:54:02 <elliott> So that a range never stops before its end
14:54:03 <conal> ddarius: do you have a handy pointer to the section in the Report?
14:54:04 <ddarius> elliott: All of those are exactly representable.
14:54:06 <elliott> It's kind of silly.
14:54:11 <elliott> ddarius: Yes, I'm just explaining the justification.
14:54:14 <ski> > 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1
14:54:15 <lambdabot>   0.9999999999999999
14:54:16 <elliott> kamaji: Functions. Functions functions functions functions.
14:54:23 <ski> > [0,0.1 .. 1]
14:54:24 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
14:54:29 <ski> > last [0,0.1 .. 1]
14:54:30 <lambdabot>   1.0
14:54:34 <ski> conal : ^
14:55:47 <elliott> oh right, >=
14:56:16 <conal> i wonder about rationale(s) for taking such care to capture the final value while being willing to capture more.
14:56:42 <brisbin> mutually exclusive?
14:56:43 <Cale> conal: I consider it a bug, myself.
14:56:59 <ddarius> conal: Look for numericEnumFromThenTo in http://haskell.org/onlinereport/standard-prelude.html
14:57:17 <conal> I imagine it was given careful thought, and I'm hoping to find what that thought was.
14:57:20 <conal> ddarius: thx!
14:58:09 <ddarius> conal: No explanation is given.
14:58:11 <Cale> conal: I think the idea is that they wanted to ensure that if the endpoint was within half an interval of getting in, then it would.
14:58:21 <Cale> To make up for potential rounding error
14:58:30 <conal> hm.
14:58:58 <Cale> But personally, I think [a,b..c] should never contain a value larger than c
14:59:14 <ddarius> > [1,10..11]
14:59:15 <lambdabot>   [1,10]
14:59:21 <ddarius> > [1,10..11] :: Double
14:59:22 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
14:59:22 <lambdabot>         against inferred ty...
14:59:25 <ddarius> > [1,10..11] :: [Double]
14:59:26 <lambdabot>   [1.0,10.0]
15:00:30 <conal> i'm helping a group of imperative programmers learn haskell, and right away someone stumbled across this behavior. They tried [1,3..10] vs [ x/10 | x <- [1,3,..10] ].
15:00:44 <conal> > [1,3..10]
15:00:45 <lambdabot>   [1,3,5,7,9]
15:00:52 <conal> > [ x/10 | x <- [1,3,..10] ]
15:00:53 <lambdabot>   <no location info>: parse error on input `..'
15:01:04 <conal> oops.
15:01:08 <ddarius> I also think it is the wrong behavior.  Though arguably Float/Double just shouldn't be in Enum.
15:01:13 <conal> > [ x/10 | x <- [1,3 .. 10] ]
15:01:13 <lambdabot>   [0.1,0.3,0.5,0.7,0.9,1.1]
15:01:29 <conal> ddarius: yeah. that part is sketchy.
15:01:49 <conal> there are a few subtle things going on with that last comprehension.
15:02:01 <conal> type defaulting as well as Float/Enum
15:03:27 <Cale> [0,10..14]
15:03:30 <Cale> > [0,10..14]
15:03:31 <lambdabot>   [0,10]
15:03:39 <Cale> > [0,10..16]
15:03:40 <lambdabot>   [0,10]
15:03:47 <Cale> > [0,10..18]
15:03:48 <lambdabot>   [0,10]
15:03:52 <Cale> > [0,10..18] :: [Double]
15:03:53 <lambdabot>   [0.0,10.0,20.0]
15:03:54 <Cale> duh
15:03:57 <Cale> > [0,10..15] :: [Double]
15:03:58 <lambdabot>   [0.0,10.0,20.0]
15:04:01 <Cale> > [0,10..14] :: [Double]
15:04:02 <lambdabot>   [0.0,10.0]
15:04:37 <Cale> The next element gets in if it's within half the step size from the endpoint
15:05:00 <ski> Cale : yeah, as the link to the prelude spec says :)
15:08:10 <conal> > let xs = [1,3..10]
15:08:11 <lambdabot>   not an expression: `let xs = [1,3..10]'
15:08:20 <conal> @let xs = [1,3..10]
15:08:20 <lambdabot>  <local>:2:0:
15:08:20 <lambdabot>      Multiple declarations of `L.xs'
15:08:21 <lambdabot>      Declared at: <local>:...
15:08:36 <conal> @let qs = [1,3..10]
15:08:37 <lambdabot>  Defined.
15:08:52 <conal> > (length qs, length (map (/10) qs))
15:08:53 <lambdabot>   (5,6)
15:09:09 <elliott> wow
15:09:13 <conal> yeah.
15:09:17 <elliott> that hurts
15:09:30 <conal> thanks in part to dropping the monomorphism restriction
15:09:34 <conal> @type qs
15:09:35 <lambdabot> forall t. (Num t, Enum t) => [t]
15:09:40 <conal> hrmf.
15:11:02 <conal> i think i'll allow this mystery to unfold in pieces, over time.
15:11:23 <conal> and meanwhile suggest that they not use .. for floats.
15:11:32 <elliott> haha
15:11:53 <conal> this mystery can be an ongoing challenge.
15:12:29 <conal> they'd probably hate the explanation now but enjoy it later.
15:12:52 <conal> i mean *the accurate* explanation.
15:14:29 <ddarius> The only accurate explanation you are likely to get is if you collar someone who worked on the Report, unless you meant the "because the Prelude says so" explanation.
15:27:35 <magicman> > xs
15:27:37 <lambdabot>   [1,3,5,7,9]
15:29:07 <dankna> @hoogle read
15:29:07 <lambdabot> Prelude read :: Read a => String -> a
15:29:08 <lambdabot> Text.Read read :: Read a => String -> a
15:29:08 <lambdabot> module Text.Read
15:31:30 <shirt> this is bad: http://blog.joda.org/2011/10/today-time-zone-database-was-closed.html
15:33:36 <elliott> -- It is expected that compilers will recognize this and insert error
15:33:36 <elliott> -- messages that are more appropriate to the context in which undefined
15:33:36 <elliott> -- appears.
15:33:36 <elliott> undefined        :: a
15:33:36 <elliott> undefined        =  error "Prelude.undefined"
15:33:40 <elliott> Does anything actually do that?
15:36:09 <trinithis> is `mapM return xs` equivalent to `return xs` when xs is finite?
15:37:25 <sshc> Are two lazy bytestrings equal if their contents are equal ((==) `on` (show . unpack)) but their chunking is different? ((==) `on` show)
15:38:11 <Twey> trinithis: Yyyyes, but the former requires that the two monads be the same where the latter doesn't
15:38:26 <elliott> sshc: I think so.
15:38:27 <Twey> Well
15:38:30 <Twey> Equivalent in type
15:38:46 <trinithis> two monads?
15:38:48 <schell> hi guys, i've got a newb question...
15:38:49 <Twey> Of course the elements of the list may have side effects, which wouldn't be accounted for
15:38:50 <elliott> :t mapM return
15:38:51 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> m [a]
15:38:54 <schell> is this the place?
15:39:00 <Twey> Oh
15:39:05 <sshc> elliott: I think so too.
15:39:08 <elliott> sshc: Yes, they are equivalent.
15:39:16 <sshc> elliott: Excellent.
15:39:19 <Twey> No, never mind.
15:39:20 <elliott> erm
15:39:21 <elliott> oops
15:39:24 <elliott> That was at trinithis
15:39:26 <elliott> Sorry sshc :-)
15:39:30 <elliott> Try it yourself I guess :P
15:39:36 <Twey> Yeah.  Equivalent.
15:39:36 <elliott> It irks me a bit because toChunks exists, but the alternative is probably worse
15:39:36 <Eduard_Munteanu> schell: hi, sure
15:39:41 <schell> okay
15:39:52 <Eduard_Munteanu> In fact, don't ask to ask :)
15:40:01 <sshc> (As a side note, I really think that there should at least be a version of bytestrings whose internal chunking *cannot* be exposed withshow and toChunks)
15:40:13 <schell> I'm running through learnyouahaskell.com and have run into a funky error during the 'guards' section...I can load this function http://pastebin.com/qWu9MH4p but I can't load this function http://pastebin.com/bT7Y0Yz4 (the difference being in the where)
15:40:17 <mauke> The pastes qWu9MH4p bT7Y0Yz4 have been copied to http://hpaste.org/52256 http://hpaste.org/52257
15:40:24 <sshc> Somebody should get around to doing that.
15:40:27 <mm_freak> sshc: why?
15:40:49 <elliott> schell: Indentation matters.
15:40:50 <schell> i get a > baby.hs:16:41:
15:40:50 <schell>     parse error on input `='
15:40:55 <elliott> schell: Align your ( with the "b" in "bmi".
15:41:05 <schell> should i be using tabs or spaces?
15:41:10 <mike-burns> Spaces.
15:41:13 <schell> i fudged around with it a little
15:41:30 <elliott> Spaces, most assuredly.
15:41:49 <elliott> Since Haskell does not exactly have a constant width of indentation in all cases.
15:41:57 <elliott> It is based on alignment (off-side rule).
15:43:00 <shapr> stepcut: Um, my memoirs are not yet sufficiently organized.
15:43:03 <sshc> toThunks :: [a] -> [a]; toThunks (x:xs) | isEvaluated x = toThunks xs | otherwise = x:toThunks xs; with perhaps foldifying
15:43:06 <schell> huh - maybe i need to turn on soft tabs a realign all of it
15:43:25 <schell> that was it
15:43:36 <schell> awesome - thanks guys
15:43:56 <elliott> sshc: wat
15:44:03 <elliott> sshc: a parody of lazy bytestrings? :P
15:44:26 <sshc> elliott: go'i
15:44:44 <elliott> Lojban is totally ungooglable.
15:48:19 <dylukes> So, question.
15:48:27 <dylukes> Why can't GHC figure out if a class is derivable?
15:48:40 <dylukes> I mean, if every method in it has a default, or a `default' (generics)
15:48:47 <dylukes> shouldn't it be able to figure out how to derive it?
15:48:59 <elliott> Can't it?
15:49:03 <elliott> But that isn't what deriving does, anyway.
15:49:09 <dylukes> Well yes, but it would be nice if say,
15:49:17 <dylukes> I define some class Generic a => MyClass a
15:49:24 <elliott> It would be nice. The fact that it doesn't work does not mean GHC could not do it.
15:49:28 <dylukes> and now I can do deriving Myclass a instead of instance Myclass a
15:49:44 <dylukes> No, I'm not saying it can't, I mean, why can't it YET :P
15:49:48 <elliott> You mean deriving (Myclass).
15:49:52 <dylukes> yeah
15:49:53 <elliott> And because you haven't written the patch for it yet.
15:49:55 <elliott> And/or opened the ticket.
15:49:57 <dylukes> pj/marlow put in a patch.
15:49:59 <dylukes> er, ticket
15:50:02 <dylukes> i forget which
15:50:13 <elliott> I guess you have to do the patch then :P
15:50:28 <dylukes> I wouldn't trust myself around the GHC codebase.
15:50:31 <dylukes> I don't know one inch of it.
15:50:45 <elliott> That's why you have to submit a patch instead of pushing directl :P
15:50:46 <elliott> y
15:50:56 <dylukes> well, for now I'm fine.
15:50:58 <rwbarton> it's not that much easier to write "deriving Myclass" than "instance Myclass Whatever"
15:51:02 <elliott> Also why the commentary exists.
15:51:07 <dylukes> rwbarton: true, but its more consistent I think :\
15:51:18 <dylukes> and cleaner.
15:57:09 <hpaste_> dankna pasted “deserializer thingy” at http://hpaste.org/52258
15:57:13 <dankna> okay so
15:57:20 <dankna> I'm trying to write this monad instance, right
15:57:39 <dankna> the reason I'm doing it as that algebraic datatype is that there are two "run" functions
15:57:43 <elliott> dankna: I thought you said the result of your NIHing would be simpler than cereal.
15:57:49 <dankna> one that runs it purely on a ByteString
15:57:55 <dankna> and one that runs it in IO on a FilePath
15:58:09 <dankna> I don't recall citing "simpler" as one of the virtues I felt my NIHing would result in :)
15:58:19 <elliott> data Result r = Fail String
15:58:19 <elliott>               | Partial (B.ByteString -> Result r)
15:58:19 <elliott>               | Done r B.ByteString
15:58:22 <elliott> You could just copy cereal directly.
15:58:28 <dankna> hmm
15:58:36 <elliott> (The monad itself uses CPS in cereal for moar speed.)
15:58:36 <dankna> that doesn't appear to allow for seek and tell
15:58:46 <elliott> No, it doesn't. Why do you need seek and tell?
15:58:57 <dankna> because of nonlinearities in the file format
15:59:08 <elliott> Sucks to be you :P
15:59:12 <dankna> yes, indeed
15:59:18 <schell> can someone explain why this causes a runtime error?
15:59:18 <elliott> I'd read the whole file in, and then use knot-tying.
15:59:20 <schell> initials :: String -> String -> String
15:59:20 <schell> initials first@(f:irst) last@(l:ast) = [f, ' ', l]
15:59:25 <dankna> hm, that's a thought
15:59:31 <elliott> dankna: i.e. you have parsers only for contiguous bits of the file, and they take the information they need from elsewhere.
15:59:33 <schell> initials "My Name"
15:59:36 <elliott> then you can just use mutual recursion to get it all going
15:59:51 <elliott> dankna: That requires you to have all the file in memory at once, but that probably isn't a huge deal.
15:59:59 <schell> results in a
16:00:00 <schell> No instance for (Show (String -> String))
16:00:00 <schell>       arising from a use of `print'
16:00:03 <dankna> well, as a design goal I'm trying not to load the entire file, actually
16:00:12 <elliott> schell: because initials takes two strings
16:00:16 <elliott> you only gave it one
16:00:23 <schell> jeeeesuuuus
16:00:40 <ddarius> and there is no instance for Show (String -> String)
16:00:41 <schell> due - should not have had that beer at lunch :\
16:00:57 <elliott> Don't worry, there's no problem that asking about in #haskell will not make you regret doing so :P
16:01:17 <dylukes> elliott: How does confluence work?
16:01:28 <dankna> even if you come up with some joke meta-problem that is designed to make regret impossible due to its structure, somebody will just point out a detail you got wrong
16:01:42 <wavewave> hmmm, I cannot find a solution without IncoherentInstances..
16:01:54 <elliott> dylukes: Confluently.
16:01:55 <elliott> HTH
16:02:08 <schell> :)
16:02:51 <dylukes> So if Haskell had an animal mascot what would it be :0?
16:02:55 <dankna> elliott: more disturbing though about reading it as two pieces, though, is that it seems to require me to have an "incomplete" version of my datatype
16:02:58 <dylukes> I vote for slime molds.
16:03:04 <dylukes> composable.
16:03:09 <dylukes> and flexible and shit.
16:03:10 <elliott> dankna: No, it just requires you to split your data types into two more modular components.
16:03:14 <dankna> hm
16:03:15 <elliott> s/types/type/
16:03:19 <Dybber> Hi #haskell. I have lot of functions of the form "checked_function x1 x2 x3 x4 x5 = doErrorChecking <$> some_function x1 x2 x3 x4 x5", can this in some way be written in point-free style?
16:03:27 <elliott> (Those components may end up referencing each other.)
16:03:30 <elliott> (But that's okay.)
16:03:31 <ddarius> dylukes: I think you should see a doctor if your feces are slime molds.
16:03:33 <elliott> (i.e. circularity)
16:03:45 <dylukes> Dybber: Can you elaborate?
16:03:52 <dankna> well, anyway, I am now enamored of this challenge and want to solve it at least as much as I want to write a MachO linker, haha
16:03:53 <dylukes> what is "doErrorChecking"
16:03:59 <elliott> Dybber: You should make your functions all check errors, and then write unsafe versions of the same. But no, there is no general way of doing that point-free.
16:04:10 <elliott> s/unsafe versions of the same/unsafe versions of the same that discard the error/
16:04:16 <elliott> (By "error"ing it, for instance.)
16:04:25 <elliott> (I guess that's a misuse of the word "discard"...)
16:04:30 <Pseudonym> :t (<$>)
16:04:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:04:40 <dylukes> <$> is fmap.
16:04:44 <dylukes> :t fmap
16:04:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:04:48 <Pseudonym> Sure.
16:04:57 <dylukes> it binds less tightly though
16:05:12 <dankna> anyway, I guess I'll go chew on the cereal source and see if its strategy is applicable
16:05:15 <dankna> @hackage cereal
16:05:16 <lambdabot> http://hackage.haskell.org/package/cereal
16:05:20 <dylukes> lul
16:05:26 <dylukes> whenever anyone does that all I can picture
16:05:26 <dylukes> i
16:05:38 <elliott> dankna: That would make you a cereal killer.
16:05:49 <dylukes> is them hitting some button on their wrist, a portal showing up, then they scream AWAY and shoot a grappling hook through it, then whoosh off.
16:05:51 <dankna> no, I didn't kill it, I just poured it out of the box
16:05:55 <dankna> I'm just a cereal consumer
16:05:56 <elliott> Ooh, now I know what to call my perfect serialisation library.
16:06:07 <dylukes> elliott: make the tagline: "cereal, outside of the box"
16:06:07 <dankna> do tell!
16:06:17 <dankna> oh, haha
16:06:18 <dylukes> elliott: ffs please make me a serialization library that works with Generic :3?
16:06:22 <Dybber> elliott: Okay, thanks.
16:06:30 <elliott> dylukes: That doesn't need to be built in.
16:06:38 <Pseudonym> Dybber: Look up applicative functors.
16:06:52 <dylukes> elliott: :<
16:06:53 <elliott> Pseudonym: <$> is in Control.Applicative.
16:06:58 <dylukes> but it clutters up my code and its irrelevant to have
16:07:00 <Pseudonym> Yeah.
16:07:02 <elliott> dylukes: What does?
16:07:05 <dylukes> its better to have it in the serialization library
16:07:07 <dylukes> the class
16:07:12 <elliott> instance Serialize where get = genericGet; put = genericPut
16:07:31 <dylukes> elliott: No I mean with the new Generic stuff :P
16:07:38 <elliott> dylukes: So did I.
16:07:49 <dylukes> are genericGet/genericPut defined anywhere though :P
16:07:50 <dylukes> ?
16:07:56 <dylukes> the point is I don't want to clutter my code with those.
16:07:59 <elliott> dylukes: Nope: You get to write a library.
16:08:08 <elliott> It turns out you can build libraries on top of other libraries.
16:08:11 <elliott> Like legos, or turtles.
16:08:13 <elliott> Lurtles.
16:08:14 <dylukes> :P
16:08:25 <dylukes> well sure, but I'm not writing a serialization library :P
16:08:41 <elliott> No, you're writing a library to create generic serialisers.
16:08:54 <dylukes> No, I'm not... :<
16:09:02 <dylukes> I'm writing a STG compiler.
16:09:09 <Pseudonym> @pf (\a b c -> fmap f (g a b c))
16:09:09 <lambdabot> Maybe you meant: bf pl
16:09:16 <Pseudonym> @pl (\a b c -> fmap f (g a b c))
16:09:16 <lambdabot> ((fmap f .) .) . g
16:09:28 <elliott> dylukes: Then what do you need serialisation for?
16:09:32 <Pseudonym> @pl (\a b c d -> fmap f (g a b c d))
16:09:32 <lambdabot> (((fmap f .) .) .) . g
16:09:42 <dylukes> elliott: partially for fun
16:09:42 <dylukes> :P
16:09:43 <Pseudonym> Ugly yet cute at the same time.
16:09:51 <dylukes> I'm just trying to learn Generics.
16:10:47 <ski> @pl \f g a b c d -> fmap f (g a b c d)
16:10:47 <lambdabot> (.) . (.) . (.) . (.) . fmap
16:10:51 <Dybber> Just to elaborate, what I essentially have is a lot of functions like this: http://hpaste.org/52259 (it is for an OpenCL-library). So my question is how and if that can be simplified.
16:11:24 <ski>   fmap f .::: g
16:11:59 <Dybber> I do this to avoid having to do error checking at each clGetDeviceIDs_ call site
16:12:26 <elliott> Oh, you're working on a low-level OpenCL binding? Excellent, now I don't have to.
16:12:46 * ski wonders what "OpenCL" might be
16:12:56 <ski> (i assume it's not "Open Common Lisp")
16:12:56 <elliott> http://en.wikipedia.org/wiki/OpenCL
16:13:22 <elliott> It's a (device-agnostic, but most useful for GPUs) computation library.
16:13:25 <elliott> Thing.
16:13:27 <elliott> Standard. Language.
16:13:30 <Pseudonym> @let liftB f = (f .)
16:13:31 <lambdabot>  Defined.
16:13:42 <Pseudonym> :t liftB . liftB . liftB
16:13:43 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
16:13:59 <dylukes> ski: It's like a generalized CUDS.
16:14:00 <elliott> Dybber: Anyway, what you can do is define versions for each arity.
16:14:01 <dylukes> CUDA*
16:14:02 <ski> @let (.:::) = (.) . (.) . (.) . (.)
16:14:03 <lambdabot>  Defined.
16:14:10 <elliott> Dybber: e.g. checkClError10 "foo" for a ten-argument function.
16:14:13 <ski> @type (.:::)
16:14:14 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
16:14:17 <elliott> Dybber: That's a pain, but it's a one-off cost.
16:14:22 <Pseudonym> :t liftB . liftB . liftB $ isJust
16:14:23 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a. (Functor f, Functor f1, Functor f2) => f (f1 (f2 (Maybe a))) -> f (f1 (f2 Bool))
16:14:46 <dylukes> :t (liftB)
16:14:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:14:47 * ski isn't sure what "CUDA" is either :)
16:14:57 <elliott> http://en.wikipedia.org/wiki/CUDA :P
16:14:59 <Pseudonym> Huh.
16:15:09 <dylukes> ski: It's for writing code that runs on GPU's. It's generally stream processing oriented.
16:15:14 <dylukes> OpenCL looks a lot like C.
16:15:18 <ski> @type ((.))
16:15:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:15:27 <Dybber> elliott: Yes, I thought about that. Would just make sure it couldn't be done with some magic type family stuff or the like.
16:15:27 <dylukes> @src (.)
16:15:27 <lambdabot> (f . g) x = f (g x)
16:15:27 <lambdabot> NB: In lambdabot,  (.) = fmap
16:15:30 <dylukes> :)
16:15:31 <zmv> OpenCL is like OpenGL?
16:15:45 <dylukes> OpenCL and OpenGL are standardized by the same group. Different purposes though.
16:16:05 <ski> dylukes : hm, it is dataflow, like Lucid and Synchone ?
16:16:22 <elliott> <dylukes> OpenCL looks a lot like C.
16:16:25 <elliott> Looks but not really behaves.
16:16:28 <Pseudonym> :t (fmap . fmap . fmap) fromJust (\a b c -> Just (a+b+c))
16:16:29 <elliott> GPUs are really weird.
16:16:29 <lambdabot> forall a. (Num a) => a -> a -> a -> a
16:16:29 <dylukes> Yeah.
16:16:33 <Pseudonym> Damn.
16:16:39 <elliott> ski: No, it's much lower-level.
16:16:52 <dylukes> http://en.wikipedia.org/wiki/OpenCL#Example
16:16:53 <ski> aww ..
16:17:03 <dylukes> see the section titled "The actual calculation:"
16:17:09 <elliott> ski: But you could build such a thing on top of it, certainly.
16:17:21 <elliott> Rather than messing about with undocumented platform-specific GPU assembly :-P
16:17:36 <ski> it's synchonous, i assume ?
16:17:52 <Pseudonym> ski: It's SIMD.
16:18:12 <elliott> ski: Well, GPUs do all sorts of things like running each branch of a conditional simultaneously...
16:18:25 <dylukes> non determinism, woo
16:18:42 <ski> elliott : well, i was thinking about not keeping around lots of history of data streams
16:19:12 * ddarius <3 predicated instructions.
16:19:12 <Pseudonym> If anyone is curious: http://dl.acm.org/citation.cfm?id=808581
16:19:12 <vicvicvic> is there an obvious way of running a parsec parser and getting both the parsed results and the consumed string?
16:19:12 <elliott> ski: Well, OpenCL maps fairly directly to a GPU; it won't make much impossible that doesn't already have a mismatch with what GPUs do.
16:19:17 <Pseudonym> How to write a compiler for GPUs.
16:19:25 <Pseudonym> circa 1984
16:19:28 <elliott> ski: Though it's certainly not a direct map to what GPUs do in many ways... (http://esolangs.org/wiki/Checkout)
16:20:42 <Pseudonym> If you were a compiler writer in late 2001 who had read this paper, you too could be working at NVIDIA today.
16:21:00 <ski> elliott : interesting ..
16:22:34 <dankna> okay, so I think I get the trick of how cereal works now
16:22:39 <dankna> trying to fit it in my impl
16:26:13 <wavewave>  will  type context inequality be implemented ? instance ( a /~ b) => C a b
16:26:59 <wavewave> without this, I think IncoherentInstances are unavoidable.
16:27:30 <elliott> wavewave: why on earth do you need that?
16:27:48 <elliott> take a look at http://stackoverflow.com/questions/6939043/is-it-possible-to-place-inequality-constraints-on-haskell-type-variables, but still, I can't think of any real usecase
16:27:57 <wavewave> I have some Castable class between two types.
16:28:08 <wavewave> Castable a a is obvious.
16:28:24 <elliott> you probably don't want that :P
16:28:38 <wavewave> but because of this, any general instance of Castable a A will cause a problem.
16:29:00 <elliott> yeah, Castable is not a good idea.
16:29:18 <wavewave> elliott: if you consider multiparam typeclass as a relation of types,
16:29:43 <wavewave> elliott: then you probably want to have some pattern-matching at type level.
16:30:22 <elliott> wavewave: Type families let you do that. They don't work here, though. Castable really isn't a good idea, though.
16:30:22 <wavewave> problem is not like value-level pattern-matching, there is no defined order in pattern-level instance matching.
16:30:49 <Jafet> @hoogle cast
16:30:50 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
16:30:50 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
16:30:50 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
16:30:55 <wavewave> elliott: not that simple.. because Type families only defines uniqueness.. in this case not unique.
16:31:04 <ski> wavewave : maybe you really want `data Equal :: * -> * -> * where Refl :: Equal a a' ?
16:31:18 <wavewave> ski: yeah.. probably.. I need it.
16:31:19 <elliott> wavewave: "They don't work here, though."
16:31:25 <elliott> ski: I doubt it, it's for a C++ binding
16:31:33 <elliott> So he's trying to do a single class for all kinds of class hierarchies
16:31:39 <elliott> Which just isn't going to work.
16:31:50 <ski> elliott : hm, i don't even understand what that means ..
16:32:04 <elliott> ski: instance Castable Superclass Subclass, presumably.
16:32:05 <wavewave> elliott: I define phantom type for this.. it's now inside haskell.
16:32:17 <elliott> wavewave: What?
16:32:19 <wavewave> elliott: not exactly.
16:32:25 * ski wonders whether that is nicer written as `data Equal a :: * -> * where Refl :: Equal a a'
16:32:30 <wavewave> instance Int CInt like this.
16:32:42 <elliott> wavewave: Oh. Don't do that.
16:32:42 <ski> elliott : oh, so it's not to be symmetric !?
16:32:54 <elliott> wavewave: For one, Int and CInt cannot necessarily hold the same values.
16:32:57 <elliott> /Either/ way.
16:33:03 <elliott> CInt might not fit into Int, Int might not fit into CInt.
16:33:08 <elliott> Use explicit conversions, seriously.
16:33:42 <wavewave> elliott: hmm. okay I probably accept your suggestion.. but anyway, I don't think my question is so specific on such cast cases.
16:34:08 * BMeph thinks, as elliott seems to be implying, that avoiding implicit conversions is SRS BSNS. ;)
16:34:30 <elliott> I'd throw away Castable and then add explicit conversions to the rest of the code until it works :P
16:34:37 <wavewave> generally if I want multiparam type classes which is not functional-dep or type families, this type-pattern matching problem can occur.
16:34:39 <Jafet> Liskov me harder.
16:35:04 <wavewave> elliott: In fact, that's too much boilerplate..
16:35:09 * BMeph lights another votive to Santa Barbara... ;)
16:35:13 <elliott> wavewave: Maybe Haskell just isn't the language for you?
16:35:23 <elliott> It's not boilerplate to have to put in a conversion when a conversion exists.
16:35:41 <elliott> Omitting that is like omitting an addition of one in an arithmetic expression just because they're common.
16:35:45 <elliott> It doesn't make any sense.
16:35:46 <wavewave> elliott : hmm I am a little bit offended now.
16:36:06 <elliott> Well, sorry, I'm not intending offence, it's just that implicit conversions kinda go against the principles of Haskell a fair bit :P
16:36:34 <wavewave> Please take that as an example. I probably accept your suggestion as I said.
16:36:34 <Jafet> You can't have implicit conversion in Haskell, so the issue is moot
16:36:44 <elliott> Well, OK.
16:37:13 <elliott> I mean, IncoherentInstances is going to seriously bite you at some point anyway, so in the long-run nobody has much choice of using it, they'll have to remove it to avoid breakage at some point in the future :-)
16:37:28 <wavewave> I am just asking about general questions on instance F a a and instance (C a) => F a A can coexist.
16:37:31 <BMeph> Haskell Celebrates Diversity! ;þ
16:37:35 <Jafet> He wants the inequality constraint so that he can avoid IncoherentInstances.
16:37:48 <ski> elliott : well, it is boilerplate to add it when there is a unique standard one (assuming all such cohere, of course)
16:38:02 <wavewave> so probably Refl is a solution.. I haven't thought about that yet.
16:38:14 <foxontherocks> hey everyone! I'm new to the haskell scene, so I thought I'd drop in and see what's up.
16:38:21 <elliott> ski: Still, only nop should look like the empty string.
16:38:46 <ski> elliott : yeah, i was mostly thinking about subsumption, here, so operationally nop yes
16:39:05 <Jafet> You can't use empty string, you need at least genericCast
16:39:21 <elliott> Call it some Unicode character that just looks like a tiny smudge.
16:39:24 <elliott> Then it's practically empty.
16:39:32 <BMeph> foxontherocks: Welcome! Enjoy yourself, and don't be afraid to grab a bucket is you feel your head exploding... ;)
16:40:48 <ski> wavewave : i was thinking you wanted to convert between `a' and `b', where those two types were equal, but not statically known to be equal
16:41:13 * ddarius doesn't see what holding a bucket accomplishes in that case.
16:41:14 <ski> wavewave : using `Equal' you can define `coerce :: Equal a b -> a -> b; coerce Refl ab = ab'
16:41:28 <ski> wavewave : but now it seems to me you wanted something else than i initially thought
16:41:38 <ddarius> "In case of nuclear attack, lift leek."
16:41:48 <hpaste_> haskell pasted “list comprehension” at http://hpaste.org/52260
16:42:04 <Jafet> I suspect wavewave wants some sort of oohaskell
16:42:04 <stribor> can anyone help me with this list comprehension
16:42:12 <ski> foxontherocks : well, welcome. if you have any questions, just ask. have you found a book or tutorial to read, yet ?
16:42:24 <ski> Jafet : or Timber
16:43:06 <foxontherocks> ski: yeah, thanks - I've read through Learn You a Haskell &c.
16:43:28 <Cale> stribor: sure
16:43:50 <stribor> id like to make result be first element from each pair of each list
16:43:52 <Cale> stribor: If you write fst x like that in the list comprehension, it means that fst x has to evaluate to True in order for the item to be included
16:44:28 <stribor> ok where do i extract each first element then?
16:45:21 <geheimdienst> > let xs = [1..5] in [x | x <- xs, x `mod` 2 == 0]
16:45:21 <lambdabot>   [2,4]
16:46:17 <geheimdienst> stribor: here's an example that takes only those elements that are divisible by two. you can see that in that place, you need something of type Bool. you wrote "fst x", which is of type Int, so that doesn't work
16:46:30 <ion> > filter ((== 0) . (`mod` 2)) [1..5]
16:46:31 <lambdabot>   [2,4]
16:46:40 <wavewave> elliott, ski, Jafet : thanks for suggestions..  i think what ski says is closed to what I am doing indeed.
16:46:43 <ion> > filter (\x -> x `mod` 2 == 0) [1..5]
16:46:44 <lambdabot>   [2,4]
16:47:04 <geheimdienst> ion: ur lyst comprension iz nott a list comprehsion!1!
16:47:05 <geheimdienst> ;)
16:47:10 <elliott> wavewave: OK, but it won't let you convert between Int and CInt.
16:47:15 <wavewave> Ptr RawObject <-> Object    conversion in haskell
16:47:20 <elliott> Refl equality only works for honest-to-god identical types.
16:47:25 <wavewave> Int CInt is really bad example.
16:47:31 <elliott> wavewave: is type Object = Ptr RawObject?
16:47:39 <elliott> that is the only way ski's solution will work
16:47:46 <stribor> geheimdienst: thanks
16:47:50 <Jafet> @undo [x | x <- xs, x `mod` 2 == 0]
16:47:51 <lambdabot> concatMap (\ x -> if x `mod` 2 == 0 then [x] else []) xs
16:47:54 <wavewave> Object is a phantom type.
16:48:06 <elliott> um, a phantom type has no values but _|_
16:48:12 <elliott> so I doubt you can convert one to a Ptr RawObject
16:48:26 <wavewave> Empty type..
16:48:41 <wavewave> maybe I am using wrong words?  data Object
16:48:43 <wavewave> like this..
16:48:46 <elliott> how do you implement Object -> Ptr RawObject, then?
16:48:48 <stribor> why cant my comprehension be t-bhis [(fst x,fst y)|x<-a,y<-b]
16:49:13 <elliott> wavewave: are you sure you don't want newtype Object = Object (Ptr RawObject) and not exporting the constructor?
16:49:18 <wavewave> oh I am sorry..
16:49:34 <wavewave> elliott : What you were saying is what I did.
16:49:39 <elliott> heh :)
16:49:44 <wavewave> RawObject is phantom
16:49:46 <ion> > [ (fst x, fst y) | x <- [(0,'a'), (1,'a'))], y <- [("foo", Just 42), ("bar", Nothing)] ]
16:49:47 <lambdabot>   <no location info>: parse error on input `)'
16:49:52 <elliott> wavewave: right, then ski's solution won't help you (there is no value of type Equal Object (Ptr RawObject))
16:49:54 <ion> > [ (fst x, fst y) | x <- [(0,'a'), (1,'a')], y <- [("foo", Just 42), ("bar", Nothing)] ]
16:49:55 <lambdabot>   [(0,"foo"),(0,"bar"),(1,"foo"),(1,"bar")]
16:50:11 <geheimdienst> stribor: it can, it works for me. what trouble are you having with it?
16:50:20 <ski> wavewave : you might be interested in O'Haskell <http://web.archive.org/web/20090517021445/http://www.cs.chalmers.se/~nordland/ohaskell/> and Timber <http://timber-lang.org/>
16:50:36 <elliott> stribor: [(x,y) | (x,_) <- a, (y,_) <- b] is nicer
16:51:00 <stribor> geheimdienst: in my example here http://hpaste.org/52260(ignore my comprehension) is result i would like
16:51:33 <wavewave> ski: That's language extension. isn't it?
16:51:34 <stribor> geheimdienst: i have two lists...i want to take each first element in each pair and make new list
16:51:46 <Dybber> elliott: If you are interested, you can look at my OpenCL library here: https://github.com/HIPERFIT/hopencl - it is in a usable form, but some sections of the OpenCL spec. is not implemented (look at the TODO file).
16:51:56 <wavewave> anyway, my library is already on hackage.
16:51:59 <wavewave> HROOT .
16:52:13 <ddarius> wavewave: They are totally different languages.
16:52:20 <wavewave> so if you want to see what I am doing really, you can check it.
16:52:25 <stribor> geheimdienst: oops i am way of there
16:52:29 <elliott> Dybber: Well, I've only used OpenCL to toy around with.
16:52:31 <stribor> i am creating list of pairs again
16:52:31 <geheimdienst> > let xs = [1..5] ; ys = [7..11] in [x | x <- xs ++ ys]
16:52:32 <lambdabot>   [1,2,3,4,5,7,8,9,10,11]
16:52:36 <stribor> i actually want list of ints
16:52:41 <wavewave> Until now, with IncoherentInstances, I managed to make it work reasonably.
16:52:42 <PhilRod> wavewave: the idea of connecting ROOT and Haskell slightly messes with my head
16:53:00 <stribor> geheimdienst: thanks
16:53:06 <geheimdienst> you're welcome
16:53:07 <wavewave> PhilRod: in fact, it's true... I struggled quite much.
16:53:20 <PhilRod> wavewave: yes, I'm impressed that anyone managed it
16:53:20 <stribor> i was creating list of pairs
16:53:34 <wavewave> PhilRod: anyway, it seems working quite  reasonably...please try it :-)
16:53:39 <ddarius> map id (xs ++ ys)
16:54:12 <wavewave> Today, I got several people's opinion against IncoherentInstances, so I am trying to get rid of it.. It's not simple at all.
16:54:21 <Dybber> elliott: Okay, it sounded like you were interested in such a library. It is usable for toying around at least :)
16:54:23 <ski> @where+ O'Haskell extension to Haskell adding subtyping and records, plus non-blocking reactive communication, by Johan Nordlander, Magnus Carlsson, and Bjrn von Sydow, at <http://web.archive.org/web/20090517021445/http://www.cs.chalmers.se/~nordland/ohaskell/>, also see `Timber'
16:54:24 <lambdabot> Done.
16:54:29 <ski> wavewave : yes
16:54:36 <elliott> Dybber: I am interested, I just haven't got much experience :-)
16:54:53 <wavewave> PhilRod: BTW, I am very glad to see somebody interested in ROOT ;-D
16:55:42 <wavewave> my code became messier and messier simulating all OOP with type hackery.. :-P
16:56:17 <Dybber> Okay, well I hope to make a more formal release to hackage soon. I just have to write some more test-code.
16:56:18 <wavewave> anyway.. except IncoherentInstances, the resultant usage code is not very ugly.. simply like using IORef.
16:57:19 <ddarius> http://esolangs.org/wiki/Burn
16:59:26 <PhilRod> wavewave: I'm only interested in ROOT because my experiment's data is in ROOT files... I would gladly never have to use or even think about it again in my life otherwise
17:00:01 <PhilRod> wavewave: but don't let me stop you making HROOT :-)
17:00:22 <elliott> Hey, I see an esolangs.org link.
17:00:49 <ski> @where+ Timber concurrent, reactive, event-driven language that was inspired by O'Haskell, <http://timber-lang.org/home.html>. also see `O'Haskell'
17:00:49 <lambdabot> I will never forget.
17:02:03 <wavewave> PhilRod: That sounds good to me. Current implementation can treat root file and draw histograms and such.
17:02:31 <wavewave> PhilRod: I cannot avoid it at all since all people surrounding me use that..
17:03:14 <elliott> ddarius is an enigma wrapped in a riddle wrapped in something confusing.
17:03:52 * wavewave sighes about when physicists are free from fortran77.
17:04:37 <Pseudonym> Mad, bad, and dangerous to good coding practices.
17:04:49 <tkahn6> what are some good html scraping libraries? I've used tagsoup but idk if it's the best interface for traversing the DOM
17:06:08 <khaled> hello
17:06:54 <khaled> I want to ask what is the implementation language of haskell
17:06:56 <khaled> ?
17:07:06 <Pseudonym> Haskell, C, and evil.
17:07:28 <khaled> what is evil?
17:07:34 <shirt> perl
17:07:37 <tkahn6> khaled: GHC uses gcc as backend
17:07:38 <elliott> khaled: Haskell is a language.
17:07:39 <Pseudonym> Oh, the evil mangler has been removedf.
17:07:45 <elliott> tkahn6: -fvia-C is not the default.
17:07:48 <elliott> and is deprecated.
17:07:52 <Pseudonym> So there's no more evil.
17:07:58 <elliott> khaled: Do you mean GHC/
17:08:10 <elliott> khaled: If so, the answer is mainly Haskell, with RTS bits in C and Cmm.
17:08:18 <elliott> It compiles via either native code or LLVM.
17:08:26 <tkahn6> elliot: was just about to ask you!
17:08:42 <khaled> So Haskell internally is implemented in C
17:08:45 <Pseudonym> Yeah, the right answer is "whatever you want it to be, if you're the one writing it".
17:09:00 <Pseudonym> khaled: It depends on the implementation.
17:09:19 <Pseudonym> GHC is written in Haskell. Hugs is written in C.
17:09:29 <khaled> Is there an GUI IDE for haskell
17:09:32 <khaled> ?
17:09:35 <shachaf> Is GHC written in Hugs-compilable Haskell?
17:09:51 <Cale> khaled: Yeah, there's EclipseFP and some other IDE tools, but I haven't known many people who use them
17:09:56 <elliott> shachaf: Hell naw.
17:10:00 <Pseudonym> shachaf: It was at one point. GHC was bootstrapped with Gofer, IIRC.
17:10:09 <tkahn6> khaled: http://leksah.org/
17:10:11 <elliott> tkahn6: hehe
17:10:13 <Pseudonym> I think you'd need much RAM to do it these days.
17:10:15 <elliott> khaled: Haskell is not internally in C.
17:10:19 <Cale> khaled: For the most part, a text editor which can convert tabs to spaces and do a little syntax highlighting is enough.
17:10:23 <elliott> khaled: GHC is some hundred thousand lines of Haskell, and much less C.
17:10:52 <Pseudonym> khaled: YOu have to understand that a language implementation is compiler plus run-time libraries.
17:10:57 <shachaf> Saying that GHC is written in Haskell is slightly disingenuous if GHC is the only program that can compile GHC. :-)
17:11:01 <Cale> khaled: Mostly you can leave GHCi running alongside whatever text editor you use, and tap :r in GHCi whenever you save your file.
17:11:05 <Pseudonym> Plus tools.
17:11:09 <elliott> GHC is written in GHCskell :P
17:11:21 <Pseudonym> The compiler and the tools are written in Haskell, pretty much.
17:11:33 <Jafet> I call it Glasgow Haskell, because it's the language accepted by the Glasgow Haskell Compiler
17:11:35 <Pseudonym> Some of the libraries are written in C.
17:11:43 <Pseudonym> Just like some of the C standard library is written in assembler.
17:11:48 <tkahn6> see: PCap library
17:12:27 <khaled> How GHC (Haskell Compiler) is written in Haskell?
17:12:35 <Cale> khaled: It compiles itself.
17:12:43 <Jafet> The GNU C compiler is also written in GNU C.
17:12:45 <elliott> khaled: How is gcc (a C compiler) written in C?
17:12:51 <elliott> gcc doesn't compile with other compilers, either.
17:12:56 <Cale> khaled: The previous version of GHC is used to compile the next version, and then that version is used to compile itself.
17:12:57 <elliott> The answer is bootstrapping.
17:13:05 <Jafet> The answer is masochism.
17:13:27 <elliott> Maybe for gcc, I think it would be masochistic to implement GHC in anything other than Haskell.
17:13:42 <Cale> indeed
17:13:43 <Pseudonym> Actually, implementing GHC in O'Caml would be an interesting exercise.
17:13:46 <Jafet> Well, it is sadistic to implement it in Glasgow Haskell, but that's how it is.
17:13:46 <Cale> heh
17:13:49 <ddarius> GHC may have been bootstrappable with Gofer at one point, but it was originally bootstrapped with hbc.
17:13:55 <elliott> Pseudonym: The original GHC was written in SML.
17:13:57 <Pseudonym> Ah, there you go.
17:13:57 <td123> hi, I'm interested in haskell's fixed point operator.. has there been any real world use case were it actually made sense to use it?
17:14:06 <Cale> I wish that GHC's internal design were a little more Haskellish in places.
17:14:08 <elliott> ddarius: I guess they ditched the SML version then
17:14:21 <elliott> It was a backend to "Chalmers LML" whatever that was, I'm betting "Lazy ML"
17:14:28 <elliott> Erm
17:14:30 <elliott> s/backend/frontend/
17:14:34 <Cale> The bits that I've looked at have involved a fair number of awkwardly partial functions.
17:14:35 <tkahn6> is there anyway to integrate hlint into ghc? like -Wall or something?
17:14:35 <elliott> Or compiler to, I guess
17:14:37 <stribor> > [ x | x <- [2,5,10], y <- [8,10,11]]
17:14:38 <lambdabot>   [2,2,2,5,5,5,10,10,10]
17:14:44 <Pseudonym> khaled: When you're writing a new language where the compiler is to be written in that language, you have a few options, but the usual approach is to implement a subset of the language in some other language.
17:14:51 <ddarius> HBC was bootstrapped with LML which was a lazy ML made by Lennart.
17:14:53 <stribor> why am i getting this result.....shouldnt it be just [2,5,10]
17:14:59 <Jafet> tkahn6: make a shell script called ghc that runs hlint?
17:15:11 <Pseudonym> You don't need to compile to your target language, either.
17:15:13 <Cale> stribor: because for each choice of y it will give another x
17:15:24 <tkahn6> > [ (x,y) | x <- [2,5,10], y <- [8,10,11]]
17:15:25 <lambdabot>   [(2,8),(2,10),(2,11),(5,8),(5,10),(5,11),(10,8),(10,10),(10,11)]
17:15:32 <khaled> Can Haskell do stuff like opengl games?
17:15:36 <Cale> khaled: Sure
17:15:36 <Pseudonym> You could, for example, compile a subset of Haskell _into_ an ML-like language.
17:15:41 <ski> Mercury was bootstrapped in the intersection of Mercury, Nu-Prolog, and another Prolog i can't recall atm
17:15:48 <elliott> ddarius: Hmm. The history I read said that GHC was a compiler written in some form of ML compiling to LML initially.
17:15:50 <Jafet> td123: but some people generate Fibonacci numbers in the real world, what will you tell them?
17:15:50 <stribor> Cale:  i dont get it
17:15:54 <tkahn6> jafet: yeah maybe
17:15:54 <Pseudonym> ski: Since I was there, I can answer that question.
17:15:56 <elliott> ddarius: And that hbc was the first Haskell compiler that actually worked :P
17:16:04 <Cale> khaled: I'm working for a company called iPwn Studios, and we're writing a game for iPhones and other mobile devices using OpenGL in Haskell.
17:16:21 <Pseudonym> The first cut of the Mercury compiler was written in the intersection of Mercury, NU-Prolog and SICStus Prolog.
17:16:27 <Pseudonym> And it compiled to Goedel.
17:16:33 <ski> ah, ok. SICStus
17:16:33 <tkahn6> Cale: how are you doing that? does the iPhone run native code?
17:16:36 <ddarius> Wunderbar.
17:16:38 <Pseudonym> The idea being that you could use Goedel's type checker.
17:16:45 * ski had no idea which of Mercury and Goedel was the older
17:16:57 <elliott> Pseudonym: /Intersection/?
17:17:00 <elliott> Pseudonym: That's hardcore.
17:17:04 <khaled> Cale can you send me a link for OpenGl in Haskell tutorial or reference
17:17:06 <tkahn6> Cale: and isn't that against apple TOS or something?
17:17:13 <td123> Jafet: i'm asking because i camehis article http://playingwithpointers.com/archives/590 across t
17:17:21 <Cale> tkahn6: Yes. It's an ARM processor, and GHC has native code support for ARM, together with some iPhone specific stuff written by Stephen Blackheath
17:17:22 <Pseudonym> Well, Mercury's syntax is essentially the same as Prolog's.
17:17:26 <stribor> Cale: oops i see it now
17:17:32 <tkahn6> Cale: that's pretty awesome
17:17:36 <Cale> We're also probably going to be moving to using the LLVM backend
17:17:43 <Pseudonym> In that if you strip the declarations off Mercury, you get valid Prolog.
17:17:54 <Cale> khaled: Well, you should know about this first: http://hackage.haskell.org/packages/archive/pkg-list.html
17:18:05 <Cale> http://hackage.haskell.org/package/OpenGL
17:18:08 <Cale> is the OpenGL binding
17:18:20 <Pseudonym> It compiled to Goedel only to let Goedel type check it. The Goedel programs were never actually run.
17:18:20 <tkahn6> Cale: does haskell give you any business advantage or do y'all just like haskell?
17:18:30 <Cale> tkahn6: I think it does.
17:18:31 <ddarius> Holy Christ.
17:18:32 <Pseudonym> Did I mention that Fergus is smart?
17:18:32 <elliott> the business advantage is avoiding Objective-C :P
17:18:35 <Jafet> I think liking Haskell is a business advantage for using Haskell.
17:18:38 <Cale> tkahn6: But we've yet to really prove it, I guess :)
17:18:47 <elliott> Pseudonym: That's amazing.
17:18:48 <tkahn6> that's still really cool
17:19:07 <Cale> tkahn6: The advantages are basically the usual advantages of using Haskell.
17:19:27 <Cale> Things are really nicely refactorable, usually work reasonably well when they compile, and so on.
17:19:37 <Jafet> td123: fix is just anonymous recursive let. There's no magic that means you can't write a program without it.
17:19:42 <Pseudonym> FJH and SPJ are the two smartest people I know who don't have PhDs.
17:19:46 <Jafet> @src fix
17:19:46 <lambdabot> fix f = let x = f x in x
17:19:47 <elliott> TChan is "faster" (I know, I know...) than Chan in most cases, right?
17:19:52 <tkahn6> Cale: that's really cool. are there any memory/performance concerns?
17:19:59 <elliott> Pseudonym: SPJ doesn't have a PhD? I guess I always just assumed
17:20:05 <Pseudonym> Yeah, you'd think.
17:20:06 <khaled> Thanks Cale
17:20:10 <ddarius> Pseudonym: Who are the smartest people you know that do have PhDs?
17:20:19 <Kreole> can someone point me towards the documentation for Integer (as opposed to Int)?
17:20:26 <Cale> tkahn6: Well, there are, but we have an FRP system for incremental computation that we've come up with.
17:20:29 <ddarius> @where report
17:20:29 <lambdabot> http://www.haskell.org/onlinereport/
17:20:31 <ddarius> There you go.
17:20:41 <Pseudonym> ddarius: Stan Skafidas is on the list.
17:20:41 <elliott> Kreole: I can quote it in its entirety for you: "Arbitrary-precision integers.
17:20:41 <elliott> "
17:20:48 <tkahn6> that's awesome
17:20:53 <geheimdienst> > maxBound :: Int
17:20:54 <lambdabot>   9223372036854775807
17:20:57 <geheimdienst> > maxBound :: Integer
17:20:58 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
17:20:58 <lambdabot>    arising from...
17:21:08 <elliott> geheimdienst: good documentation
17:21:18 <geheimdienst> Kreole: that's the important thing. Integer has no upper bound, Int has
17:21:29 <Kreole> oh thanks
17:21:35 <ski> Pseudonym : hm, i wonder where Fergus is now ..
17:21:36 <Cale> SPJ doesn't have a PhD? It seems like they should just give him one for all the various things he's published.
17:21:41 <geheimdienst> elliott: abserlutely great innit? i made it up on the spot :)
17:21:42 <ddarius> > complement 0
17:21:42 <elliott> geheimdienst: Kreole: Also no lower bound.
17:21:43 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:21:43 <lambdabot>    `Data.Bits.Bits a'
17:21:43 <lambdabot>      a...
17:21:47 <ddarius> > complement 0 :: Integer
17:21:48 <lambdabot>   -1
17:21:53 <elliott> Cale: well, "He is an honorary Professor of Computer Science at the University of Glasgow"
17:21:56 <Jafet> Robert Floyd didn't get a PhD
17:22:10 <Jafet> He was given a few later on, though
17:22:20 <Cale> OutsideIn(X) is Ph.D. worthy, I think.
17:22:22 <Pseudonym> Fergus is working at Google now.
17:22:39 <Cale> Or at least a Master's degree :P
17:22:44 <Pseudonym> http://sites.google.com/site/fergushenderson/
17:22:51 <geheimdienst> yeah of course. name compiler "glorious glasgow thingy", receive honorary thing from glasgow. figures.
17:22:59 <geheimdienst> ;)
17:23:03 <ddarius> Cale: You can't get a PhD for work you've pawned off to grad students.
17:23:09 <Cale> hehe
17:23:12 <Cale> I suppose
17:23:22 <Jafet> Why does it matter though. spj doesn't come here often so it doesn't affect the channel PhD ratio.
17:23:30 <shirt> what do you guys think about using one of the magical string interpolation libraries on hackage? or should i just stick to plain old ("hello " ++ name)
17:23:55 <Cale> I'm not really sure how much he's been involved in the various things with his name on them, but I suspect much of it is a nontrivial amount of work.
17:23:57 <ddarius> Jafet: Well when people say you need a PhD to program Haskell, you can point out that SPJ doesn't have a PhD.
17:24:05 <ddarius> Cale: I'm sure.
17:24:14 <elliott> "So technically, you only need 90 percent of a Ph.D."
17:24:14 <Cale> shirt: I usually go with the latter, or use concat
17:24:29 <ski> @remember ddarius Well when people say you need a PhD to program Haskell, you can point out that SPJ doesn't have a PhD.
17:24:29 <lambdabot> It is forever etched in my memory.
17:24:57 <shirt> Cale: what's the disadvantage of string interpolation? there seem to be a bunch of different packages for it
17:25:01 <khaled> How long does it take for completing a Master Degree?
17:25:16 <td123> khaled: typically 1 to 2 years
17:25:28 <shirt> Cale: i'm doing lots of this in my code, so making it just a little bit clearer would be a big win
17:25:36 <shachaf> Jafet: Has he ever been here?
17:25:55 <Cale> shirt: Well, not too much, but I usually haven't found much need for it myself. Your situation might differ :)
17:25:56 <khaled> td123 do you have a master degree?
17:25:56 * shachaf wonders if SPJ lurks #haskell as one of the many pseudonymous nicks we have here.
17:26:05 <shachaf> Probably not -- he's to productive to be using IRC.
17:26:09 <shachaf> s/to/too/
17:26:17 * shachaf grrs at his keyboard. *Keyboard*
17:26:22 <shirt> Cale: ok... i guess my next question would be which package is best? :)
17:26:32 * zmv grrs at shachaf's keyboard.
17:27:08 <khaled> What skills are mandatory to complete a Master Degree?
17:27:18 <Cale> shirt: What are you doing string interpolation for?
17:27:58 <shirt> Cale: text messages for the user
17:28:10 <Pseudonym> khaled: A postgraduate student is an apprentice researcher. You learn your skills on the job.
17:28:15 <ddarius> preflex: seen simonpj
17:28:15 <preflex>  simonpj was last seen on #ghc 3 years, 26 days, 9 hours, 24 minutes and 27 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
17:28:54 <shirt> guess he's away for another "moment"
17:28:58 <elliott> Then he went away for a very long mom- damn you shirt.
17:29:00 <ddarius> In my experience, Masters theses are almost always crap.
17:29:21 <Pseudonym> ddarius: Honours thesis == 1 paper, masters thesis == 2 papers, PhD thesis == 3 papers
17:29:24 <companion_cube> why?
17:29:24 <Pseudonym> Good rule of thumb.
17:29:44 <Pseudonym> But you're right. If you're any damn good at doing your masters, you convert to a PhD.
17:29:51 <companion_cube> ddarius: because they are not technical enough?
17:29:51 <Pseudonym> At least that's true in computer science.
17:29:56 <Cale> shirt: It's just that I've never found things like  concat ["There were ",show n," quarbleflummoxes while processing ",show m, " maljoves."] too unwieldy.
17:30:27 <ddarius> companion_cube: I don't know why.  My experience is that they tend to be uninteresting and uncompelling.
17:30:57 <Pseudonym> I've seen one or two. In such cases, I suspect they didn't convert to PhDs for economic or personal reasons.
17:31:04 <Cale> shirt: for multiline things, I'll generally use unlines
17:31:07 <khaled> When should you start writing your master thesis, at end or from beginning?
17:31:17 <Cale> shirt: and sometimes it's nicer to use unwords than concat
17:31:25 <shirt> Cale: maybe.... just having syntax highlight for the whole quoted string would be nice though
17:31:29 <shachaf> ddarius: Does that not apply to PhD theses?
17:31:33 <Pseudonym> khaled: It depends on the thesis.
17:31:53 <Pseudonym> If you're lucky, you can write papers as you go, then at the end, write an introduction and a conclusion and call that a thesis.
17:31:53 <khaled> for a computer science thesis?
17:31:57 * shachaf would vaguely expect Sturgeon's Law to apply.
17:32:02 <Cale> shirt: Well, I don't know how well the quasiquoter things on hackage will interact with syntax highlighting
17:32:08 <ddarius> Pseudonym: Yeah, I've read a couple of decent Master's theses.  Dawson Engler's is okay but not as good as his PhD.  Andrzej Filinski's Master's thesis is reasonably interesting.
17:32:09 <Cale> shirt: but this works fine :)
17:32:38 <companion_cube> ddarius: ok, i hope i will be in the minority that are interesting then :)
17:32:49 <ddarius> shachaf: We are talking about theses I've read, not all theses.
17:32:53 <Pseudonym> shachaf: Completed master's theses are a biassed sample, so Sturgeon's Relevation isn't numerically accurate.
17:32:55 <shirt> Cale: hm... unwords is a good tip
17:32:56 <JoeyA> When defining the package hierarchy of a new module, is it better to err on the side of a long path or a short path?
17:33:08 <JoeyA> e.g. Acme.Missiles versus Acme.Missiles.Launch
17:33:40 <khaled> Is Master thesis should come with something new (new contribution)?
17:33:45 <Cale> http://hackage.haskell.org/packages/archive/interpolatedstring-perl6/0.8.1/doc/html/Text-InterpolatedString-Perl6.html -- there's this
17:33:57 <Cale> but I personally find things like that to be scary
17:34:19 <companion_cube> khaled: i think so, if possible
17:34:55 <shirt> Cale: that one doesn't seem to work with Data.Text also
17:35:06 <Pseudonym> khaled: Yes. It may be a small contribution, but it must be a contribution to science to be a science faculty thesis.
17:36:06 <khaled> quit
17:36:07 <Pseudonym> Having said that, there are also master's-by-coursework.
17:36:21 <Pseudonym> Which are useless if you want to learn how to be a researcher.
17:37:03 <companion_cube> so a master is not too bad a diploma, in the end? :)
17:37:07 <khaled> I think the point form Masters and PHDs are to be a researcher
17:37:47 <ddarius> There are a lot of people with Master's degrees and no PhDs who aren't and do not wish to be researchers.
17:37:49 <dankna> sweet, I think my monad instance might be correct
17:37:55 <dankna> and my run* function
17:38:09 <Saizan> i thought you had to have a Master's already to qualify for PhD
17:38:12 <dankna> of course I can't test them yet ><
17:38:17 * hackagebot x11-xim 0.0.6 - A binding to the xim of X11 graphics library  http://hackage.haskell.org/package/x11-xim-0.0.6 (YoshikuniJujo)
17:42:20 <wavewave> elliott, ski, Jafet : temporarily eliminated IncoherentInstances now. this will not have problem. Thanks for your help and suggestion.
17:42:28 <elliott> yay
17:43:04 <wavewave> elliott: by the way, my Int <-> CInt conversion is just using fromIntegral, so it would not be a problem I guess.
17:43:17 * hackagebot HROOT 0.6.6 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.6 (IanWooKim)
17:43:21 <elliott> yeah
17:46:36 <tkahn6> uh oh… GHCi runtime linker: fatal error: I found a duplicate definition for symbol
17:46:36 <tkahn6>    _hsnet_freeaddrinfo
17:48:52 <brownie4590> hey what are some reworld applications of Haskell, this is the first time I have heard of this lanuage.
17:49:48 <hpc> brownie4590: people have written websites, GUI programs; one person wrote a whole application suite called manatee
17:49:52 <hpc> high frequency trading
17:49:55 <hpc> uh
17:50:04 <hpc> facebook uses it to refactor their shitty-ass php code
17:50:39 <brownie4590> manatee what is that?
17:50:41 <elliott> brownie4590: http://www.haskell.org/haskellwiki/Applications_and_libraries, http://www.haskell.org/haskellwiki/Haskell_in_industry
17:50:59 <elliott> brownie4590: a rather big haskell program is the Glasgow Haskell Compiler :-)
17:51:27 <elliott> you might have heard of the darcs revision control system... Haskell doesn't really have all that much exposure in the way of user-facing applications
17:51:33 <elliott> but it's used a lot "internally"
17:51:48 <shachaf> hpc: Do people actually use Haskell for high-frequency trading?
17:51:48 <hpaste_> wavewave pasted “implement C++ FFI ” at http://hpaste.org/52261
17:51:50 <elliott> there's xmonad :P
17:52:26 <shirt> anyone have download statistics of xmonad versus darcs?
17:52:44 <brownie4590> hmm cool col
17:52:45 <wavewave> elliott, ski : just in case you are interested in what I tried to talk to you, I just pasted a snippet of essential part of code.
17:53:00 <elliott> shirt: darcs is like a billion years older, so I suspect it has more downloads... but xmonad sure is popular
17:53:02 <brownie4590> well if you were to compare it to another programming lanuage, what would you compare it too?
17:53:07 <geheimdienst> i believe that thing's server side is written in haskell: http://detexify.kirelabs.org/classify.html might be a nice example, if you know tex at all
17:53:18 <elliott> wavewave: hmm, I see
17:53:45 <elliott> wavewave: have you looked into higher-level binding generators like c2hs
17:54:12 <elliott> geheimdienst: looks like the http server is ruby but the actual recognition server is haskell
17:54:22 <wavewave> elliott: I looked into it, but it's only for C, as I understand..
17:54:37 <elliott> wavewave: well... TObject_GetName doesn't look like a C++ function to me
17:54:42 <wavewave> in fact, I researched on this subject quite a bit.
17:54:43 <elliott> is that using some C interface to HROOT?
17:55:04 <wavewave> elliott : eventually in FFI since haskell has only C FFI.
17:55:08 <geheimdienst> elliott: of course, that's possible. i just heard haskell was being used on the back end
17:55:13 <elliott> right
17:55:17 <tkahn6> how does one uninstall a package using cabal?
17:55:22 <elliott> geheimdienst: yeah, I just poked at the source code now (it's linked from there)
17:55:25 <elliott> tkahn6: you don't
17:55:33 <tkahn6> lol srsly
17:55:34 <stribor> can someone help me with this com[prehension
17:55:38 <stribor> [(x,y) | x<-max [2,5,10], y<-[8,10,11]]
17:55:40 <wavewave> elliott: so using typeclass, I wrapped it as it look like an OOP.
17:55:43 <tkahn6> ok well i have symbol issues with a libary
17:55:44 <elliott> tkahn6: you can ghc-pkg unregister it and then try and obliterate it from the filesystem, but this is why you should use cabal-dev
17:55:49 <stribor> id like resuklt to be [(10,11)]
17:55:54 <tkahn6> elliott: i see
17:56:04 <stribor> [(x,y) | x<-max [2,5,10], y<-max[8,10,11]]
17:56:08 <wavewave> I studied others like gtk2hs, qtHaskell and wxHaskell etc.
17:56:11 <tkahn6> GHCi runtime linker: fatal error: I found a duplicate definition for symbol
17:56:12 <tkahn6>    _hsnet_freeaddrinfo
17:56:12 <tkahn6> whilst processing object file
17:56:12 <tkahn6>    /Users/tkahn/.cabal/lib/network-2.3.0.6/ghc-7.0.4/HSnetwork-2.3.0.6.o
17:56:39 <wavewave> unfortunately, many other methods used for those library assumes single inheritance.
17:57:01 <wavewave> while ROOT heavily uses multiple inheritance.. ( I hate that very much. )
17:59:42 <stribor> .
18:00:05 <DukeDave> wavewave: Ooh, what are you working on?
18:00:10 * DukeDave looked at your hpaste
18:01:22 <DukeDave> If you're doing things with FFI and casting, here's a challenge for you:
18:01:22 <DukeDave> http://haskell.org/haskellwiki/WxHaskell/Development/classes/wxAny
18:01:32 <DukeDave> Wrap that :)
18:02:27 <wavewave> DukeDave: interesting. wait a minute.
18:03:00 <elliott> DukeDave: Doesn't sound /that/ hard, apart from the template stuff...
18:03:08 <elliott> Which I would have take a (Proxy a).
18:04:20 <Kreole> sorry if this is a dumb question but what's the equivalent of Data.Int for Integer? It doesn't seem to be Data.Integer
18:05:30 <hpaste_> wavewave pasted “cpp code for C++-haskell FFI” at http://hpaste.org/52263
18:05:46 <elliott> Kreole: What do you need?
18:06:03 <wavewave> DukeDave: this is my cpp stub code part.
18:06:48 <wavewave> DukeDave: I made a code generator for both C++ and haskell codes
18:07:29 <dankna> @hackage cereal
18:07:29 <lambdabot> http://hackage.haskell.org/package/cereal
18:07:46 <wavewave> DukeDave: code generator is https://github.com/wavewave/HROOT-generate
18:08:16 <wavewave> DukeDave: HROOT is on https://github.com/wavewave/HROOT
18:08:34 <ski> > [let x = max [2,5,10]; y = [8,10,11] in (x,y)]
18:08:35 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
18:08:35 <lambdabot>    arising from a use ...
18:08:44 <wavewave> but HROOT is basically almost empty.. HROOT-generate fill the codes.
18:08:46 <ski> > [let x = max [2,5,10]; y = max [8,10,11] in (x,y)]
18:08:47 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
18:08:47 <lambdabot>    arising from a use ...
18:09:00 * ski dohs
18:09:07 <ski> > [let x = maximum [2,5,10]; y = maximum [8,10,11] in (x,y)]
18:09:08 <lambdabot>   [(10,11)]
18:09:30 <ski> > [(x,y | x <- [maximum [2,5,10]],y <- [maximum [8,10,11]]]
18:09:31 <lambdabot>   <no location info>: parse error on input `|'
18:09:37 <JoeyA> In Haddock, is it possible to have a newline within a bulleted item?
18:09:37 <ski> > [(x,y) | x <- [maximum [2,5,10]],y <- [maximum [8,10,11]]]
18:09:38 <lambdabot>   [(10,11)]
18:09:55 * ski only now notices stribor already left :/
18:12:09 <DukeDave> elliott: Yeah, I didn't think it would be /that/ hard either, but I was stumped by this: http://hpaste.org/51854
18:12:47 <DukeDave> wavewave: Ah, I'll have to take a look at it
18:13:34 <wavewave> my OOP simulation is quite different from wxHaskell way though.
18:13:53 <elliott> DukeDave: Yeah, dunno... but I don't really understand how C++ templates would interact with the FFI and all, seeing as they're compile time only.
18:14:05 <elliott> DukeDave: So I don't know how wxAny works in the first place, really :P
18:14:52 <wavewave> DukeDave: what is the mechanism of CheckType?
18:16:08 <wavewave> probably haskell FFI coerce the pointer to (void *) type all the time.
18:16:50 <wavewave> if CheckType uses some C type info, then probably they look the same..
18:17:58 <wavewave> data Ptr a = Ptr Addr# deriving (Eq,Ord)
18:18:00 <elliott> C type info doesn't exist, but C++ RTTI stuff might matter
18:19:00 <wavewave> elliott: yeah. we need to see the source code of CheckType<type>
18:19:19 <wavewave> and EWXWEXPORT
18:22:37 <lambdanaut> main = do     monkey <- getMonkeys       doStuffWith monkey         monkey <- getMonkeys        doMoreStuffWith monkey
18:22:53 <lambdanaut> second monkey != first monkey
18:22:54 <lambdanaut> right?
18:22:59 <byorgey> lambdanaut: right
18:23:02 <ddarius> It may.
18:23:21 <lambdanaut> er, I mean, second monkey ovewrites first monkey
18:23:22 <lambdanaut> ?
18:23:27 <ddarius> It shadows it.
18:23:27 <lambdanaut> overwrites*
18:23:37 <ddarius> It's just like writing let x = 3 in let x = 4 in ...
18:23:49 <lambdanaut> ah I see
18:23:50 <Veinor> @undo do {x <- a; x <- b; f x}
18:23:51 <lambdabot> a >>= \ x -> b >>= \ x -> f x
18:24:08 <wavewave> @undo do { monkey <- getMonkeys ; doStuffWith monkey ; monkey <- getMonkeys ; doMoreStuffWith monkey }
18:24:09 <lambdabot> getMonkeys >>= \ monkey -> doStuffWith monkey >> getMonkeys >>= \ monkey -> doMoreStuffWith monkey
18:25:44 <byorgey> just be sure not to use unsafePerformLikeAMonkey
18:26:04 <hpc> unsafePerformSwanLake
18:26:21 <hpc> warning: may have an identity crisis and commit suicide
18:27:37 <elliott> DukeDave: btw putStrLn . show === print
18:28:00 <lucca> that really should be... @de-do or something.  @undo sounds like some kind of un-evaluation-system that reverses the computation.
18:28:17 <lucca> (which, admittedly, would be a good trick)
18:28:18 * hackagebot acme-missiles 0.1.0.0 - Cause serious international side effects.  http://hackage.haskell.org/package/acme-missiles-0.1.0.0 (JoeyAdams)
18:28:35 <byorgey> hahahaha
18:28:41 <JoeyA> :-)
18:29:10 <elliott> lol
18:29:22 * byorgey cabal installs acme-missiles
18:29:27 <elliott> JoeyA: you forgot to rm -rf ~
18:29:30 <shachaf> > id runST (return 5)
18:29:31 <lambdabot>   Couldn't match expected type `m t'
18:29:31 <lambdabot>         against inferred type `forall s....
18:29:32 <elliott> in launchMissiles
18:29:34 <shachaf> > (id runST) (return 5)
18:29:35 <lambdabot>   5
18:29:42 <shachaf> Why should only people in That Other Channel suffer?
18:30:03 <wavewave> ?
18:30:20 <byorgey> shachaf: ah yes, you find runST's dirty little secret special case in the type checker
18:30:33 <shachaf> byorgey: This is a syntax thing, though, isn't it?
18:30:41 <shachaf> Why is f x y =/= (f x) y?
18:31:00 <DanBurton> runST has a dirty little secret special case? o_O
18:31:12 <byorgey> shachaf: it should be.  But there's some sort of special case for runST so that  runST $ foo  works
18:31:18 <wavewave> JoeyA: sounds like star-craft.
18:31:29 <JoeyA> elliott: Then we'll get a torrent of people from 4chan after a couple months.
18:31:35 <shachaf> byorgey: No $ involved here.
18:31:40 <Nisstyre> /prog
18:31:41 <shachaf> Well, I guess id is $.
18:31:45 <Nisstyre> rather /prog/
18:31:46 <byorgey> and the reason it wouldn't normally work has something to do with higher-rank polymorphism
18:32:07 <elliott> byorgey: wow, are you serious?
18:32:13 <byorgey> elliott: I am serious.
18:32:14 <Nisstyre> 4chan's prog has a weird obsession with SICP
18:32:23 <elliott> byorgey: but yeah, I want to know why the parens are actually maintained in the syntax tree
18:33:40 <byorgey> elliott: I don't actually know how it works.  it seems mysterious to me too.
18:34:06 <elliott> I wish rank-N types were nice.
18:35:04 <JoeyA> @info mask
18:35:04 <lambdabot> mask
18:35:07 <JoeyA> ?
18:35:13 <JoeyA> :t mask
18:35:14 <lambdabot> Not in scope: `mask'
18:35:19 <elliott> ?hoogle mask
18:35:20 <JoeyA> @hoogle mask
18:35:20 <lambdabot> No results found
18:35:20 <lambdabot> No results found
18:35:23 <elliott> huh
18:35:25 <elliott> it's in control.exception
18:35:31 <JoeyA> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#v:mask
18:35:53 <JoeyA> mask is a rank-3 polymorphic function
18:35:59 <monochrom> mask is in fairly recent GHC Control.Exception (e.g., since version 7)
18:36:08 <JoeyA> indeed
18:36:29 <monochrom> lambdabot is still 6.12, wouldn't know mask even if it tried
18:36:43 <JoeyA> @hoogle block
18:36:43 <lambdabot> Control.Exception block :: IO a -> IO a
18:36:44 <lambdabot> Control.OldException block :: IO a -> IO a
18:36:44 <lambdabot> Control.Exception.Base block :: IO a -> IO a
18:37:04 <elliott> monochrom: huh, is mask that recent?
18:37:11 <monochrom> yes.
18:37:14 <elliott> JoeyA: I don't think mask is rank-3.
18:37:19 <elliott> I only see two levels of forall.
18:37:41 <JoeyA> ((forall a. IO a -> IO a) -> IO b) is rank-2
18:37:48 <JoeyA> So ((forall a. IO a -> IO a) -> IO b) -> IO b is rank-3
18:37:52 <monochrom> yeah
18:37:59 <byorgey> elliott: see http://article.gmane.org/gmane.comp.lang.haskell.cafe/18078/
18:38:03 <elliott> Maybe I don't know how ranks are counted.
18:38:05 <JoeyA> If you don't believe me, try compiling that type signature with Rank2Types
18:38:13 <elliott> (a -> b) is rank-one, so (a -> b) -> c is rank-two
18:38:13 <elliott> :-P
18:38:17 <monochrom> there is a wikipedia definition of rank that says its rank 3 :)
18:38:22 <JoeyA> (you need a forall in there)
18:38:27 <elliott> JoeyA: It was a joke
18:38:30 <JoeyA> heh
18:39:08 <JoeyA> Where's the wikipedia definition?
18:39:10 <monochrom> similarly, the higher-rank callCC of Cont/ContT is rank 3
18:39:27 <byorgey> elliott: and also http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/19152
18:39:57 <elliott> byorgey: Is there a way to learn less of this horror, rather than more of it?
18:40:12 <JoeyA> Yes: write in C.
18:40:27 <JoeyA> You can learn different horror
18:40:34 <byorgey> elliott: sure: cabal install acme-missiles; ghci; :m +Acme.Missiles; launchMissiles
18:40:38 <JoeyA> Or you can learn weird, machine-checked horror.
18:40:46 <elliott> byorgey: Ah, thanks.
18:41:04 <elliott> byorgey: (Are missiles meant to blow _you_ up?)
18:41:34 <JoeyA> launchMissiles is effectful.  That's all you really need to know about it.
18:41:37 <byorgey> they are not that discriminating.
18:42:25 <byorgey> future versions of Acme.Missiles may include  launchMissilesAt :: Target -> IO ()
18:42:27 <JoeyA> Do we need a launchMissilesDiscriminately?
18:42:35 <JoeyA> byorgey: +1
18:43:04 <JoeyA> Though launchMissilesAt should be deprecated, because it also affects other targets.
18:43:21 <JoeyA> So it's still difficult to reason about.
18:43:40 <monochrom> darn, I can't find the wikipedia definition anymore, sorry, except for "rank-k polymorphism is a system in which a quantifier may not appear to the left of k or more arrows (when the type is drawn as a tree)" http://en.wikipedia.org/wiki/Parametric_polymorphism#Higher-ranked_polymorphism
18:44:06 <monochrom> I seem to recall another wikipedia page with an elaboration and examples, but can't find it now
18:44:11 <JoeyA> http://www.haskell.org/haskellwiki/Rank-N_types ?
18:44:45 <monochrom> oh, that's probably the one I remembered, and misremembered as wikipedia
18:45:46 <monochrom> otoh wikipedia says there is also an explanation in TaPL
18:46:52 <antihoax> heres a bash script for you
18:46:54 <antihoax> clear;e=eval\ ;p=printf\ ;x="$e$p\$";u=USER;n=NAME;r=$(stty -g);stty raw -echo;read -sn1 -p \[$($x$u)@$(${x}HOST$n):~\]$\ ;while read -n1 a;do $p \\$($p '%03o' $(($($p'%d' "'"$($p'%c' "$a")"")-1)));sleep .$(($RANDOM*2));done< <($p\%q 'Uif!Nbusjy!ibt!zpv!'"$($p'%s' "$(grep $($x$u$n) /etc/passwd |awk -F: '{print $5}')" | while read -n1 y;do $p'%c' "$($p\\$($p'%03o' $(($($p'%d' "'$($p'%c' "$y")")+1))))";done;)"'///');stty "$r";$p\\n
18:47:19 <ion> :(){:|:;};:
18:47:19 <elliott> There's no way to block until a TChan is empty other than a busy-loop on isEmptyTChan, right?
18:47:46 <elliott> Hmm, I could wrap the values inside the Chan inside Maybe and then terminate it with Nothing, I suppose.
18:48:29 <monochrom> combination of isEmptyTChan and retry is not exactly busy
18:48:44 <hpaste_> scooty-puff pasted “Functional version of this imperative description?” at http://hpaste.org/52264
18:48:51 <scooty-puff> can anyone think of an functional way to describe or right this?
18:48:56 <scooty-puff> *a functional
18:49:15 <scooty-puff> my current solutions have been with heavy use of ST, State, or FFI (and write it in c)
18:50:30 <scooty-puff> and the monadic solutions had a big whileM_ or variant of unfoldM_
18:50:54 <monochrom> atomically (isEmptyChan c >>= \b -> if b then return () else retry)  in GHC's implementation, this only wakes up to re-test if some change to c happens
18:51:02 <shachaf> It looks pretty stateful. Is a stateful solution necessarily a bad thing?
18:51:16 <scooty-puff> no, though it looks awfully ugly in haskell
18:51:49 <scooty-puff> just thinking maybe i'm constraining myself by to the description, when a stateless version exists
18:53:01 <monochrom> don't even need State. just a function: one_step :: MachineState -> MachineState. write a record for MachineState or something
18:53:37 <monochrom> the thing is if you use State you get MachineState -> (MachineState, a) but you won't use the "a" there anyway
18:54:08 <scooty-puff> yeah, my a was really just a particular part of MachineState
18:54:16 <scooty-puff> thanks for the help!
18:54:21 <monochrom> inside the MachineState record, you can have fields for the stack, the program counter, whatever you like
18:54:47 <elliott> monochrom: heh
18:54:55 <elliott> monochrom: that might work
18:55:24 <elliott> in this case I have a channel of things to write to a socket... a single thread formats it into a bytestring and pushes it down the wire
18:55:32 <monochrom> if, later, you find that immutable arrays are too slow, then you can consider ST for mutable arrays. that is the only possible imperativeness you ever need.
18:55:33 <elliott> but I want to kill the thread when the connection ends, but only after all the data has been written
18:55:48 <elliott> so I need to block until the Chan is emptied after the connection ends, and then kill the thread
18:58:03 <elliott> s/Chan/TChan/
18:58:10 <elliott> I guess monochrom's transaction solution is probably the best idea
18:58:36 <monochrom> yeah, you have the choice of: (isEmpty and retry) or (channel content is a sum type, one variant tells consumer thread to quit)
18:59:10 <elliott> the latter is kind of gross since there will never be any values after a Nothing, so there's some semantic junk... I think I'll go with the former
18:59:20 <elliott> actually I'm using Chans right now but I'll convert to TChans for this
18:59:21 <monochrom> oh actually I know a 3rd solution.
18:59:34 <elliott> hope it won't affect my performance much, I only have one reader so I hope it's not too bad
19:02:05 <ambidextrousTx> Anybody in here?
19:02:06 <monochrom> the 3rd solution is a bit complicated
19:02:25 <byorgey> ambidextrousTx: nope ;)
19:02:31 <ski> elliott : monochrom's <http://www.vex.net/~trebla/haskell/cont-monad.xhtml> shows rank-3 `callCC'
19:02:33 <ambidextrousTx> lol
19:02:42 <elliott> ski: hm
19:02:45 <elliott> alright then
19:02:55 <shachaf> monochrom++
19:02:58 <elliott> monochrom: what's the third solution, btw?
19:03:00 <ski> ambidextrousTx : we're all bots here, pretending to be humans that actually use Haskell
19:03:16 <ski> (and obviously you are a bot as well)
19:03:21 <ambidextrousTx> darn, I thought I'd be the only bot in here :/
19:03:37 <shachaf> ski: I don't pretend to be human.
19:03:38 <ambidextrousTx> but hey, bots that use Haskell FTW!
19:04:00 <shachaf> Psst: ski is written in PHP
19:04:12 <ski> shachaf : yeah, there's some exceptions, due to features/bugs in the implementation
19:04:12 <byorgey> @botsnack
19:04:12 <lambdabot> :)
19:05:54 <elliott> shachaf: PHP doesn't use `' quotes.
19:05:55 <DukeDave> elliott, wavewave: Sorry for disappearing earlier (while discussing FFI with wxAny), I do value your input!
19:05:55 <DukeDave> Unfortunately I have to go afk now, but hopefully I can catch you in the future to discuss? :)
19:06:00 <elliott> ski must be written in m4.
19:06:05 <elliott> DukeDave: sure :P
19:06:23 * ski insists on camlp4
19:06:57 <ski> (wavewave : btw, forgot to mention <http://homepages.cwi.nl/~ralf/OOHaskell/>, but i assume you already know about it .. and also another page on OO in Haskell on the wiki, which i can't find atm)
19:07:51 <elliott> I guess monochrom's third solution is just too beautiful to reveal to the mortals :-)
19:08:05 <monochrom> no, it's long, typing up in hpaste
19:08:25 <monochrom> "too long for mortals" may be more like it :)
19:08:57 <elliott> monochrom: I'm scared
19:12:50 <hpaste_> monochrom pasted “STM "orElse" shines” at http://hpaste.org/52265
19:13:22 <elliott> monochrom: wow
19:13:32 <ski> STM orElse !!
19:13:44 <elliott> monochrom: that's pretty terrifying :P
19:13:53 <monochrom> elliott: that one. I'm proud of this trick actually. (well, to begin with, everyone should be proud of orElse; but on top of that, I'm proud of return and join)  you may like this trick for some other tasks, if not your current task
19:14:00 <elliott> I wonder if there's a performance hit, vs. doing the isEmptyTChan thing right at the end
19:14:16 <elliott> it's pretty nice, really, just takes a moment to understand
19:14:20 <monochrom> I don't know. I think eventually they're of similar cost.
19:14:51 <elliott> yeah
19:15:17 <monochrom> err there is some mistake in version 1. but I think you get the idea.
19:15:58 <monochrom> s/return continue/\x -> return (continue x)/  i.e. s/return continue/(return . continue)/
19:16:48 <ski> monochrom : haha, that reminds me of <http://martin.jambon.free.fr/extend-ocaml-syntax.html#lettry>
19:16:51 <shachaf> monochrom: I.e. fmap continue (readTChan c)?
19:16:59 <monochrom> hrm, which is also what shachaf says!
19:17:19 <monochrom> gosh, we've successfully golfed a monster into a devil
19:17:33 <ski> (for details about that syntax see "Exceptional Syntax" by Nick Benton, Andrew Kennedy in 2001 at <http://research.microsoft.com/~akenn/sml/ExceptionalSyntax.pdf>)
19:18:09 <monochrom> I think I've forgotten enough of ocaml to understand that one, ski :)
19:18:53 <monochrom> (I mean, to understand what's the issue and why it's significant)
19:19:00 <listofoptions> anyone care to explane as to how a dependant PI binding works? and how i would type something similar in haskell? (working on something that uses pure type systems)
19:19:01 <wavewave> ski: thanks for the info!
19:19:54 <elliott> monochrom:
19:19:55 <elliott> consumer = join . atomically $
19:19:55 <elliott>   (continue  <$> readTChan c) `orElse`
19:19:55 <elliott>   (finish_up <* takeTMVar q)
19:20:02 <monochrom> you see, I'm spoiled by haskell, at least ghc haskell. if I want to screw with exception handling, I just do it, there is no syntax limitation that stops me, unlike most other languages
19:20:08 <elliott> erm, needs an extra space before takeMVar to line up
19:20:11 <ddarius> monochrom: You have a type error, unless you intend to use the (r->) monad.
19:20:19 <elliott> listofoptions: you can't, haskell is not dependently typed
19:20:36 <listofoptions> elliott, i know that but i can embed
19:20:37 <monochrom> yes ddarius we noticed that
19:20:41 <elliott> right
19:20:54 <elliott> monochrom: I think with my presentation it might even be non-devillish :P
19:20:58 <listofoptions> ie henk2000
19:21:14 <monochrom> I only gripe about the precedence of `orElse` being unoptimal for this
19:22:12 <ski> monochrom : the basic point of the example is that there ought to be a `bindCatch :: Exception e => IO a -> (a -> IO b) -> (e -> IO b) -> IO b' operation
19:22:42 <ski> monochrom : the workarounds shown at that page are quite similar to your paste
19:23:18 <monochrom> ah, return a procedure to the caller, let caller execute the procedure?
19:23:41 <ski> yes .. also the "explicitly tag, then immediately do a `case' outside"
19:24:02 <elliott> monochrom: action, not procedure, no?
19:24:07 <ski> either of these approaches are unsatisfactory
19:24:09 <elliott> I guess actions are pretty close to procedures
19:24:16 <monochrom> well, if done in ocaml, you say "procedure" :)
19:24:38 <monochrom> if done in C, you say "function"! -_-
19:24:40 <ski> monochrom : i dunno, there's `fun' and `function' keywords in O'Caml :)
19:25:08 <ski> however in Scheme, you say "procedure" (there's a standard `procedure?' predicate)
19:26:01 <elliott> <monochrom> atomically (isEmptyChan c >>= \b -> if b then return () else retry)  in GHC's implementation, this only wakes up to re-test if some change to c happens
19:26:05 <elliott> monochrom: isn't that actually >>= guard?
19:26:10 <elliott> maybe I misunderstand how STM handles failures
19:26:27 <monochrom> not guard, but when
19:26:43 <elliott> I meant
19:26:47 <elliott> atomically (isEmptyChan c >>= guard)
19:26:49 <monochrom> on second thought, perhaps guard provides the retry part
19:27:05 <elliott> hmm
19:27:09 <shachaf> Yep.
19:27:19 <elliott> neat
19:27:28 <elliott> so retry == mzero I guess
19:27:57 <shachaf> Is fail also retry?
19:27:58 <monochrom> damn you Haskell for enabling golfing ad infinitum absurdum until kingdom venum
19:28:33 <shachaf> monochrom: If you keep going it's a proven result that you can reduce any Haskell program to a single character.
19:31:37 <monochrom> source code says mzero = retry, mplus = orElse, fail = default
19:31:52 <shachaf> :-(
19:31:53 <shachaf> fail--
19:31:56 <shachaf> @karma fail
19:31:56 <lambdabot> fail has a karma of -1
19:31:58 <shachaf> fail--
19:32:56 <monochrom> well, fail is a nutcase because it serves two different purposes: what to do if pattern matching fails, what to do if you want mzero
19:33:50 <shachaf> monochrom: It used to be mzero for pattern match fails.
19:33:50 <monochrom> then again actually I think STM fail should be mzero too, even for pattern matching failures
19:33:52 <shachaf> Is that bad?
19:34:33 <deech`> Is there a scripting language that has good integration with Haskell? The best I could find so far was HsLua.
19:35:18 <ddarius> Haskell has good integration with Haskell.
19:35:46 <ski> monochrom : the versions on that page, in order, roughly correspond to
19:35:52 <ski>   cat = catchJust (guard . isEOFError . ioeGetErrorType) (do c <- hGetChar stdin; hPutChar stdout c; cat) (\() -> return ())
19:35:54 <monochrom> atomically (do { Just x <- readTVar v; return x })  -- perhaps I intend this to keep retrying while v has Nothing.
19:36:01 <elliott> monochrom: I agree
19:36:04 <ski>   cat = catchJust (guard . isEOFError . ioeGetErrorType) (liftM Just (hGetChar stdin)) (\() -> return Nothing) >>= \m -> case m of Just c -> do {hPutChar stdout c; cat}; Nothing -> return ()
19:36:12 <ski>   cat = join $ catchJust (guard . isEOFError . ioeGetErrorType) (do c <- hGetChar stdin; return $ do hPutChar stdout c; cat) (\() -> return $ return ())
19:36:15 <ski>   cat = catchBindJust (guard . isEOFError . ioeGetErrorType) (hGetChar stdin) (\c -> do hPutChar stdout c; cat) (\() -> return ())
19:36:50 <elliott> monochrom: I kind of view atomically as a magic function; I give it some code with all sorts of assumptions (nothing else is writing to my mutable variables, this condition is true, this value matches this pattern...), and it makes them come true :P
19:36:51 <wavewave> deech` : do we need to have a separate script language?
19:37:07 <ski> monochrom : the first one is bad, the next two are similar to your `Job' and `join' versions, while the last uses the imagined `catchBind'/`catchBindJust'
19:37:32 <ski> monochrom : the syntax suggested on that page is basically a sugar over an `catchBindJust'-type operation
19:38:17 <wavewave> deech` : haskell is quite good in scripting.  I am using haskell for scripting purpose much.
19:38:57 <Jafet> Is there a library I can use to print floating-point values? I want to limit the number of figures printed, or the number of characters... and to control rounding
19:39:15 <ddarius> Numeric
19:39:25 <wavewave> Text.Printf?
19:39:33 <Jafet> Hm, I'll look in Numeric again
19:39:46 <mightybyte_> What's going on with code like "myFunc Foo{..} = …"?
19:40:00 <elliott> mightybyte_: all the record fields are being bound to the same names as the field
19:40:01 <mightybyte_> What does the {..} do?
19:40:03 <elliott> kinda nasty :P
19:40:05 <elliott> so e.g.
19:40:12 <elliott> data Foo = Foo { fieldA :: Int, fieldB :: Int }
19:40:12 <mightybyte_> Oh
19:40:13 <monochrom> ski: thanks, now I see
19:40:17 <mightybyte_> Wow
19:40:17 <elliott> toTuple Foo{..} = (fieldA, fieldB)
19:40:30 <mightybyte_> I had no idea that was possible.
19:41:07 <mightybyte_> Is that a new language feature?
19:41:18 <Jafet> ddarius: I could write them myself, but I'd rather use a library
19:41:19 <Veinor> ... wow, that's kind of
19:41:20 <Veinor> interesting
19:41:22 <ski> monochrom : .. and the issue to avoid is to keep accumulating exception handlers over the supposedly tail-recursive loop (even in fact not to attempt catching excpetions from the `hPutChar stdout c' part at all)
19:41:34 <geheimdienst> mightybyte_: i don't think so, but you need a language extension ("RecordPuns" or some such)
19:41:43 <geheimdienst> no, something with "wildcards"
19:42:00 <mightybyte_> Ahh, RecordWildCards
19:42:05 <Jafet> Eg. Numeric doesn't let me choose rounding mode
19:42:18 <deech`> wavewave: Yeah, I'm just wondering if I can give non-Haskellers a scripting layer in some easier/more-familiar language.
19:42:38 <deech`> elliott: Does that technique have a use-case?
19:42:44 <elliott> What technique?
19:42:53 <deech`> elliott: toTuple ...
19:42:59 <mightybyte_> I guess if I read bos's code more often, I would have known about this already.
19:42:59 <elliott> Veinor: "Interesting" is my favourite synonym for "horrifying".
19:43:29 * ski wonders whether there's a useful `IO'-`STM' primitive lurking under monochrom's two versions
19:43:34 <Jafet> @ty floatToDigits
19:43:35 <lambdabot> forall a. (RealFloat a) => Integer -> a -> ([Int], Int)
19:43:56 <elliott> ski: I have always thought that maybe every STM action should come with a list of IO actions to execute after successful completion
19:44:17 <elliott> possibly that only works if you use some other name like atomicallyIO
19:45:03 <ski> monochrom : did you type up the "3rd solution" you had in mind ?
19:45:13 <scooty-puff> if ghc can determine that a reference to a record is the only reference, and it is updated and the previous reference never used again, will it perform it in place?
19:45:19 <scooty-puff> (statically)
19:45:25 <scooty-puff> (determine statically)
19:45:29 <ski> elliott : well, in what order ?
19:45:49 <elliott> good point :P
19:46:12 <ddarius> scooty-puff: GHC doesn't do such analyses.
19:46:30 <wavewave> deech` : I am not sure in fact...  Haskell is best in making EDSL. but I am not sure whether nonhaskeller welcomes EDSL if they don't have haskell experience at all.
19:46:36 <monochrom> ski: I gather that whoever wrote the haddock for Control.Exception favours the sum type dispatch approach. "you should use 'try' or 'tryJust' mostly", just for the sake of getting out of the masked state actually. cat = do { lr <- tryJust (guard . ...) getChar; case lr of { Left e -> handler; Right c -> putChar c >> cat} }  if you absolutely want to let putChar's exceptions pass through
19:46:42 <elliott> ski: hmm, does it work if you do "actions <- newTVarIO []; atomically (do { modifyIOVar actions (x:); modifyIOVar actions (y:) }); join (readTVarIO actions)" where modifyTVar v f = readTVar  >>= writeTVar . f?
19:46:48 <ski> istr E has something where you can attach actions to be done whenever another asynchronous action terminates -- but i don't recall details :/
19:47:03 <monochrom> ski: my join thing is already my 3rd solution
19:47:43 <wavewave> deech` : to design a good DSL is very difficult even for very experienced people.
19:48:00 <ski> monochrom : ah .. then i'm not sure what your first solution is
19:49:17 <monochrom> 1st solution is have a 2nd thread atomically (isEmptyTChan c >>= guard) >> killThread the_1st_thread
19:49:55 <ski> monochrom : yeah, but it seems somehow ugly to have to create a transient `Either' here -- btw, in more complicated examples, `putChar' might instead attempt reading or writing files which it has no permission to (or something) and we don't want to catch that here
19:49:58 <monochrom> of course, the 2nd thread is not spawned until the program decides that it's time to finish up and quit
19:50:03 <wavewave> deech` : You need to  estimate your non-haskeller client's demand and level quite carefully.
19:51:42 <ski> maybe if we had unboxed variants, it wouldn't feel as bad ..
19:52:00 <monochrom> I agree that a sum type feels uncomfortable. the sum type has two or more cases, but like 99.9% of the time it's the 1st case or some such, seems wasteful
19:52:54 <monochrom> all this is great material for a book called "from Control to Data and Back Again"
19:53:14 <elliott> monochrom: Doesn't Maybe work instead of your sum type?
19:53:19 <monochrom> (along with how we use lazy lists as though they're for-loops :) )
19:53:27 <monochrom> Maybe is yet another sum type
19:53:28 <ski> (by "unboxed variants" i mean implementing something like Olin Shivers' "Multi-return Function Call", so that a function returning `Either# a b' is actually always getting two continuations (the branches) and just selects which of them to yield to)
19:53:51 <elliott> Every time I think that lists should maybe have slightly more strictness I remember that their primary use is looping :P
19:54:28 <monochrom> then again GHC pulls tricks to make sum type dispatch very low-overhead, it's pretty competitive
19:56:24 * ski still would like to get guarantees, e.g. by using "unboxed variants", or by using ordinary variant/sum types in a well-defined, and easy (with practice) to adhere to, style, akin to making sure a call is a tail-call
19:56:26 <monochrom> I heard that if your sum type has enough variants (like 8 variants), GHC start pulling continuation tricks
19:57:52 <ski> (i.e. so that if you adhere to that style, you are guaranteed that you can have an unbounded amount of active semi-tail-calls (see the paper))
19:58:05 <thoughtpolice> lambdabot: @seen tibbe
19:58:05 <lambdabot> Unknown command, try @list
19:58:07 <monochrom> for low number of variants, it pulls a different trick, exploiting that normal pointers are 32-bit aligned or 64-bit aligned, so GHC deliberately misaligns certain pointers to carry the secret message "I am supposed to point to 'Just blah' if you align me"
19:58:12 <ski> preflex: xseen tibbe
19:58:13 <preflex>  tibbe was last seen on freenode/#darcs 1 day, 21 hours, 41 minutes and 22 seconds ago, saying: Heffalump: ok, thanks for letting me know
19:58:32 <thoughtpolice> ski: ta :)
19:59:22 <elliott> what does the x part of xseen even do
19:59:24 <elliott> preflex: seen tibbe
19:59:25 <preflex>  tibbe was last seen on #darcs 1 day, 21 hours, 42 minutes and 34 seconds ago, saying: Heffalump: ok, thanks for letting me know
19:59:32 <ski> monochrom : *nod* having two or three tag bits in the least significant end of an address
19:59:44 <monochrom> so you just look at the lower bits of a misaligned pointer and you can already branch, you don't have to read too much memory for it
19:59:44 * ski has read about that idea in Mercury
19:59:44 <elliott> someone made seen better and then gave it another name for no reason? :P
20:00:00 <ski> elliott : `xseen' looks on all networks it's connected to
20:00:08 <elliott> ski: that's a ubiquitously common Lisp implementation strategy, no?
20:00:13 <elliott> LSBits pointer tagging
20:00:22 <ski> probably is
20:00:34 * ski hasn't studied any lisp implementation closely
20:01:00 <ski> elliott : iirc, preflex is mauke's, you could ask him
20:02:04 <monochrom> LSB pointer tagger wasn't quite feasible when I was still using 6502 and everyone wanted byte-align and no more! :)
20:02:40 <mauke> monochrom: that's when you start using decimal places
20:02:47 <mauke> bit alignment, yo
20:03:36 <monochrom> in those bad old days, they did MSB tagging for some other purpose, and MSB was their only choice, and this is why when you read SML's definition or Haskell Report etc, "Int is only guaranteed to be at least 31 bit" or even "30 bit", they have to steal some of the MSBs
20:04:05 <monochrom> IIRC some language even went as far as "29 bit"
20:04:18 <shachaf> Haskell only guarantees 29 bits, doesn't it?
20:04:48 * shachaf finds it kind of ridiculous that Haskell guarantees anything about bits at all.
20:04:51 <kmc> 30 bits signed integer
20:05:10 <kmc> so the range is [2^-29 .. 2^29 - 1]
20:05:23 <kmc> it's not really a guarantee about bits; it's a guarantee of the minimum range of Int
20:05:29 <mauke> by bits are all personally signed by SPJ
20:05:44 <monochrom> haha
20:05:47 <shachaf> Integer ought to be the default type.
20:05:58 <kmc> it is
20:05:58 <shachaf> Just ask conal.
20:06:01 <shachaf> @ty length
20:06:02 <lambdabot> forall a. [a] -> Int
20:07:08 <shachaf> Haskell is above such mundane real-world constraints as hardware base-2 representation of numbers!
20:07:56 <ski> "SML's definition or Haskell Report" -- huh ?
20:08:02 <mauke> tell that to Data.Bits
20:08:16 <ski> (.. oh, misread "or" for "on", nvm)
20:08:38 <ski> we need `Data.Trites'
20:08:51 <shachaf> Really the type Int shouldn't even be a type.
20:08:59 <shachaf> Int :: IO *
20:09:21 <elliott> monochrom: Are you sure the Haskell report's limitation is because of the MSB?
20:09:27 <elliott> I'm pretty sure it's about LSB tagging for GC.
20:09:35 <elliott> But I could be wrong.
20:09:39 <elliott> shachaf++
20:10:01 <monochrom> well, I guess an interpreter is free to choose which bits to steal. maybe steal bit #14 :)
20:10:17 <elliott> shachaf: I like how that lets me state "Haskell needs dependent types to be web scale." and have it actually contain a kernel of truth.
20:10:56 <elliott> (web scale -> cloud -> distributed computing -> heterogeneous network so Int's meaning changes mid-computation; "Int :: IO *" makes sense primarily in a dependently-typed system)
20:11:44 * monochrom checks what Appel does in "modern compiler implementation in ____"!
20:12:34 * ski . o O ( "ML" ! )
20:13:06 * ski is too lazy to go check, relies on monochrom reporting back
20:14:26 <elliott> ski: {Java,ML,C}
20:14:32 <elliott> apparently
20:15:15 <ddarius> elliott: Many dynamically typed languages do use tag bits, but those tag "types" whereas GHC's tag constructors since GHC already knows the types.
20:15:33 <kmels_> why should be Int considered important for the GC?
20:15:46 <elliott> kmels_: because everything else might be a pointer
20:15:48 <elliott> other than Int and Word
20:15:58 <elliott> and you don't want to dereference an integer :P
20:16:04 <elliott> ddarius: Right.
20:16:04 <ski> elliott : i know, i'm just claiming (purely unscientifically) that the "ML" version is the best one
20:16:10 <kmels_> i see!
20:16:22 <elliott> ddarius: But tagging just the integer and putting things like the relevant constructor behind a pointer is an obvious strategy.
20:16:26 <elliott> s/the integer/integers/
20:16:33 <elliott> (As in, machine-sized integers.)
20:16:36 <elliott> ski: right
20:20:26 <kmc> well, Int is also a pointer
20:20:27 <kmc> in GHC
20:20:36 <kmc> but it's a pointer to a box containing an Int#, which is not a pointer
20:21:31 <kmc> someone convince me that monad-par is a good thing
20:21:51 <elliott> isn't monad-par basically making parallelism as fiddly as concurrency
20:21:56 <elliott> that's the impression I got looking at it :P
20:22:08 <Jafet> Concurrent parallelism!
20:22:46 <ski> someone ought to make a package for declarative concurrency
20:22:59 <ski> (in the sense of CTM)
20:24:08 <ddarius> ski: It doesn't really fit Haskell syntax nicely.  If you use a monad, which then will fit nicely, you lose a lot of the appeal.
20:25:44 <ski> hm .. how far would you get with an applicative functor ?
20:26:12 <ddarius> ski: The problem is binding the variables.
20:27:05 <ddarius> Also allocating them.
20:27:09 <ski> yeah, i suppose the nonseparation of binding and instantiation is the issue
20:28:16 <ski> (like how the nonseparation of binding&instantiation and evaluation of variables in strict languages makes it hard to emulate the non-strict style nonclumsily)
20:29:12 <ski> (some SML's have  'a susp  and Ocaml has  'a lazy  but it's not quite the same thing  -- otoh Alice ML has real non-strict values)
20:29:12 <ddarius> The problem is that the separation of binding and instantiation leads to an imperative-looking syntax.
20:29:30 <ski> *nod*
20:30:39 <ski> creation of a new uninstantiated dataflow/logic variable should be affine and central, so we'd like a nicer syntax for it
20:30:59 <ski> (especially if we also disallow comparision of them for identity)
20:31:53 <ski> hm, i wonder whether that would work out ..
20:31:54 <shirt> how do i not get a compiler warning for defined but not used record fields?
20:31:58 <ddarius> Which we probably would.
20:33:10 <ski> i.e. something like `withEmptyDVar :: (DVar a -> b) -> b'
20:33:12 <monochrom> So, Appel offers two choices: one is boxing, so you don't lose a bit (you lose a whole word :) ); the other is tagging, and it's LSB, so you can exploit alignment conventions
20:34:36 <ddarius> ski: I suspect, with a bit of evil, there's a way to get a nice syntax.
20:34:49 <monochrom> and it does say if you choose tagging for Int, it's still tagging by the LSB
20:35:30 <kmc> doesn't that screw up arithmetic operations, though?
20:35:40 * monochrom now seriously hunt down where did I got the idea that old implementations tagged the MSB!
20:35:44 <ddarius> Yes.
20:35:59 <monochrom> yeah you usually have to shift, add, shift
20:36:07 <ddarius> monochrom: Tagging the MSB lets you test by sign.
20:36:19 <monochrom> yeah MSB has its advantages too
20:36:29 <elliott> <ski> i.e. something like `withEmptyDVar :: (DVar a -> b) -> b'
20:36:34 <ski> hm, Appel also talks about coercion to/from a uniform representation, as well as type-passing
20:36:35 <elliott> ski: isn't that literally isomorphic to DVar a?
20:36:40 <elliott> oh wait no there's one more _|_
20:36:46 <elliott> _|_ vs ($ _|_)
20:36:48 <desaiu> I'm following along with YAHT, and in it, there is a statement, "the primary limitation of tuples is that they hold only a fixed number of elements, pairs hold two, triples hold three, and so on."
20:37:05 <desaiu> Is the author trying to get across that simply can't add to a tuple whereas in a list, you can add elements later?
20:37:17 <ski> elliott : well, to idea was that `withEmptyDVar $ \d -> ..d..' would simulate `let d in ..d..'
20:37:26 <elliott> desaiu: Well, something of type (Int,Int) has two and only two elements.
20:37:30 <elliott> Something of type [Int] could have any number of elements.
20:37:37 <elliott> (Even infinite.)
20:37:41 <elliott> ski: ah
20:38:22 <desaiu> Oh, that's right, I remember from some chapter in Real World Haskell that tuples are of type (<whatever is in here>)
20:38:26 <kmc> the write-once property of IVar is enforced only at runtime, yes?
20:38:28 <ski> ddarius : if it's only evil in the implementation, that's fine -- the interface (i.e observable behaviour) is another thing
20:38:35 <ski> (as i'm sure you already know)
20:38:58 <ddarius> kmc: Usually, yes.
20:39:36 <desaiu> if you let a = [], and you then ask for :type a, it gives back a :: [a]
20:40:06 <desaiu> It seems that lists are of type [<whatever is in here>] as well.
20:40:22 <shachaf> desaiu: Right. That a means "anything".
20:40:27 <monochrom> (Int, Char) is a fine tuple type, too
20:40:32 <ski> ddarius : yes, except all the elements has to be the same type
20:40:33 <shachaf> So it's also a list of Ints and a list of Strings.
20:40:39 <ski> @type [False,True]
20:40:40 <lambdabot> [Bool]
20:40:43 <Jafet> @ty []
20:40:44 <lambdabot> forall a. [a]
20:40:54 <desaiu> The only difference between lists and tuples it seems is that lists insists on all of its elements being the same type
20:41:05 <desaiu> But this is not what the author states in YAHT
20:41:16 <monochrom> or, (1, 'x') is a fine tuple value. but [1, 'x'] is not a good list value.
20:41:32 <shachaf> Is "let a = []" not restricted my the monomorphism restriction?
20:41:44 <shachaf> desaiu: Lists and tuples are very different types.
20:42:10 <ski> desaiu : if you get something of type `(Int,String,Int)', you know you get two `Int's and one `String', but if you get an `[Int]', you have no idea how many `Int's that actually contains
20:42:19 <dalaing> desaiu: a list containing 3 ints has the same type as a list containing 5 ints, a tuple of 2 ints and a tuple of 5 ints are distinct types
20:42:37 <shachaf> desaiu: Tuples are just a few values put together in the same place -- the length and types of the values in the tuple are part of the type.
20:42:42 <monochrom> in another language with a more relaxed type system, you are allowed [1, 'x'], so it just need a list type, it doesn't need a separate tuple concept.
20:42:57 <desaiu> That clears it up.
20:43:17 <ski> monochrom : well, Erlang has both lists and tuples anyway :)
20:43:31 <monochrom> fun
20:43:38 <dolio> So does Python.
20:43:55 <shachaf> desaiu: By the way, when I read YAHT I seem to remember finding it rather confusing -- there are other guides that are more generally recommended nowadays, I think.
20:44:25 <monochrom> well, in some cases, they really want to say "this is a linked list underneath" vs "this is an array underneath"
20:44:43 <elliott> desaiu: Oh, I read YAHT as LYAH.
20:44:45 <elliott> desaiu: Read LYAH instead.
20:44:47 <DanBurton> @where lyah
20:44:47 <lambdabot> http://www.learnyouahaskell.com/
20:44:48 <dolio> I doubt python lists are linked lists.
20:44:49 <desaiu> shachaf: I mentioned this the other day, I was reading Real World Haskell and some part confused me, some guy mentioned that he was lucky to have read YAHT before reading that paragraph, so it wasn't as confusing to him
20:44:52 <elliott> dolio: They're not.
20:44:53 <monochrom> in some other cases it's just evolution vs Intelligent Design
20:45:03 <desaiu> So the plan is to go through YAHT and return to RWH afterward
20:45:07 <shachaf> desaiu: Oh, right, I remember that.
20:45:18 <elliott> desaiu: LYAH before RWH is a much better approach.
20:45:18 <shachaf> desaiu: YAHT had several rather misleading sections in it, I think.
20:45:19 <ddarius> The difference being that Python is retarded.
20:45:26 <elliott> (And a commonly-practiced one.)
20:45:35 <elliott> desaiu: YAHT is really quite obsolete at this point...
20:45:47 <shachaf> In Python tuples are immutable and lists aren't, I think.
20:46:01 <elliott> shachaf: You can mutate Python tuples. It requires the FFI though.
20:46:09 <desaiu> Well, I've gotten this far, I suppose I can read LYAH
20:46:25 <desaiu> Rather, I haven't gotten very far, I supp...
20:46:26 <shachaf> desaiu: You can just skip over bits you already understand. :-)
20:46:31 <dalaing> I did LYAH then RWH pretty recently, two thumbs up from me
20:46:32 <Jafet> In Python, lists are arrays. But slavery is just slavery.
20:47:05 <kmc> elliott, by that definition you can mutate Haskell values too ;P
20:47:34 <elliott> kmc: Ooh, I should try that sometime.
20:49:24 <kmc> "what could go wrong"
20:50:35 <shachaf> That's what they did in the implementation of Arc something, I think.
20:50:48 <shachaf> Racket made their conses immutable, so they just used some low-level thing to mutate them anyway.
20:51:13 <ddarius> Arc was perfect.  Just what was needed.
20:52:20 <shachaf> The hundred-year language.
20:52:46 <ddarius> Yes.  It may have shut Paul Graham up for a hundred years.
20:53:47 <alpounet> haha
20:56:46 <ski> elliott : hm, why is LYAH better than YAHT ?
20:57:14 <elliott> ski: I read YAHT once. It lost me at some point along the way and I didn't come out of it very confident in my knowledge in Haskell.
20:57:31 <elliott> ski: Later on I read LYAH, and I liked it, and it pushed me to start actually using Haskell in practice, which I did, and here I am.
20:57:39 <elliott> That experience seems to be shared by others, so...
20:57:54 <elliott> At least the Haskell conversion rate has gone up massively since LYAH came out :-P
20:57:56 <ski> that might be because you needed more time to digest the ideas, no ?
20:59:08 <elliott> ski: I certainly didn't get that impression, especially since YAHT got to the point where I basically gave up somewhere slightly after half way through and stopped reading. That doesn't explain the fact that there are a lot more people coming into Haskell now using LYAH than there ever where with YAHT. I suppose you could attribute it directly to more exposure, but I think that exposure is due in large
20:59:08 <elliott> part to LYAH/RWH anyway.
20:59:23 <shachaf> I never read either.
20:59:42 <elliott> Which, LYAH/YAHT or LYAH/RWH?
20:59:42 <ski> shachaf : yeah, it's beyond me why they didn't instead use mutable conses (which Racket also has)
20:59:42 <shachaf> None three.
20:59:54 <shachaf> But I read the beginning of YAHT and it seemed just confusing (and, I now think, somewhat misleading).
21:00:03 <elliott> ski: Racket didn't have mutable conses when Arc was written.
21:00:11 <elliott> ski: They released it like a few weeks before conses became immutable by default.
21:00:30 <hpaste_> kmc pasted “mutation!” at http://hpaste.org/52266
21:00:38 <ski> elliott : Racket originally was PLT Scheme, which i know had mutable conses from the start
21:00:44 <dalaing> the functor / applicative part of LYAH was the clincher for me - then I tracked down typeclassopedia - after that I was pretty much sold
21:00:44 <elliott> kmc: You ruined my fun. :(
21:00:45 <kmc> elliott, ^^^ :)
21:00:46 <shachaf> elliott: Right, but when they updated it, they did a hacky thing where they mutated immutable conses.
21:00:49 <elliott> ski: Well yes, but it called them conses :)
21:01:03 <elliott> shachaf: Probably they relied on conses from "elsewhere".
21:01:03 <shachaf> I skimmed through a bit of LYAH and RWH and they both seem fine, though I haven't looked through them in much depth.
21:01:13 <kmc> it's fun that you can do these things entirely in "Haskell"
21:01:15 <shachaf> Hutton's _Programming in Haskell_ is good but not available online.
21:01:19 <kmc> without writing any C
21:01:24 <elliott> shachaf: So what did you read, or are you one of those hardcore folk who just, like, started reading GHC one day.
21:01:27 <shachaf> @slap kmc
21:01:27 * lambdabot moulds kmc into a delicous cookie, and places it in her oven
21:01:33 <elliott> kmc: I think it speaks to Haskell's strengths... somehow...
21:01:40 <elliott> kmc: I like how you used printf for additional gross.
21:01:53 <DanBurton> What about the Haskell wikibook?
21:02:18 <shachaf> The wikibook was full of space suits and astronauts.
21:02:21 <shachaf> Or was it nuclear waste?
21:02:30 <shachaf> I'm not joking. It was one of those two.
21:02:54 <DanBurton> lol
21:03:10 <shachaf> Maybe parts of the wikibook are good and parts aren't.
21:03:15 * ski read "Haskell: The Craft of Functional Programming"
21:03:24 <elliott> shachaf: The clue's in half of the name of the site.
21:03:43 <DanBurton> I've followed a few links to parts of the wikibook, I can confirm some seem rather good, though incomplete
21:04:04 <DanBurton> But I was converted by LYAH then RWH
21:04:10 <shachaf> elliott: "book", eh?
21:04:13 <elliott> shachaf: PRECISELY.
21:04:42 <DanBurton> @where wikibook
21:04:43 <lambdabot> http://en.wikibooks.org/wiki/Haskell
21:05:53 <scooty-puff> is say 30000 elements still small enough to consider Data.Map's operations to still be decent compared to Data.Array?
21:06:18 <Jafet> Don't you mean IntMap?
21:06:19 <scooty-puff> that question may be a bit.. bad
21:06:28 <kmc> unless your mapping is nearly read-only, I would not consider Array to be a viable alternative
21:06:29 <scooty-puff> ah, where its bounded?
21:06:37 <desaiu> I'm going to continue on with YAHT, it just feels more efficient
21:06:40 <shachaf> <elliott> shachaf: Also, what's a map structure with fast minKey (O(log n) at least) that isn't Map or IntMap?
21:06:42 <kmc> the new hotness in this space is http://hackage.haskell.org/package/unordered-containers
21:06:48 <elliott> shachaf: Hey, I said I didn't want minKey.
21:06:56 <elliott> That's gross misrepresentation.
21:07:00 <elliott> I'm suing.
21:07:20 <DanBurton> @where yaht
21:07:21 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III, <http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://darcs.haskell.org/yaht/yaht.pdf>
21:07:54 <dalaing> wow - I nearly forgot - Bird and Walders "Introduction to Functional Programming" was also excellent - I did half of LYAH, wasn't applying it anywhere, found Bird and Walder, completed it, _then_ I did LYAH and RWH
21:07:55 <desaiu> $ darcs get http://darcs.haskell.org/yaht/yaht.pdf
21:07:55 <desaiu> darcs failed:  Not a repository: http://darcs.haskell.org/yaht/yaht.pdf (Failed to download URL http://darcs.haskell.org/yaht/yaht.pdf/_darcs/inventory: HTTP response code said error)
21:08:23 <elliott> desaiu: Why would you expect a random PDF to be a darcs repo?
21:08:29 <elliott> Oh, the domain.
21:08:31 <scooty-puff> is there a way with IntMap or HashMap to lookup the next greater value?
21:08:42 <scooty-puff> with Map it was via findIndex and elemAt
21:08:58 <dalaing> I should probably check out Introduction to Functional Programming with Haskell and see what the difference is between the versions, but I'd guess it's still really good (and it has good exercises)
21:09:15 <desaiu> I guess it doesn't exist
21:09:25 <desaiu> I tried to get it via darcs previously and it failed then too
21:09:38 <Jafet> Have you used wget
21:09:42 <elliott> It's four-oh-foured.
21:09:49 <elliott> But I don't know whether desaiu is joking or not.
21:09:55 <desaiu> Jafet: It just grabs an index.html
21:09:55 <kmc> scooty-puff, i don't think there's an efficient way
21:10:04 <DanBurton> looks like the repo is gone
21:10:07 <desaiu> I'm not joking, I'll throw in a silly emoticon if I am
21:10:21 <kmc> scooty-puff, with IntMap there might be; with HashMap you'd only get the next greater hash key, which should mean nothing
21:10:54 <DanBurton> @where+ yaht "Yet Another Haskell Tutorial", Hal Daume III, <http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>
21:10:54 <lambdabot> Good to know.
21:11:00 <scooty-puff> kmc, with IntMap looks like with split and findMin
21:11:29 <scooty-puff> how lazy is the data structure, will split really be log n?
21:12:52 <desaiu> http://darcs.haskell.org/yaht/yaht.pdf is 404 as well
21:13:31 <desaiu> Ignore, I just copied/pasted the link presented on cs.utah.edu/~hal/htut/
21:13:52 <shachaf> desaiu: Weren't you just saying how you'll try something that isn't YAHT? :-)
21:13:55 <desaiu> http://hal3.name/docs/daume02yaht.ps is the only working link
21:14:07 <desaiu> Nope! Going to finish this first
21:14:13 <desaiu> yaht seems efficient
21:14:19 <DanBurton> yaht is looking rather deprecated though :P
21:14:32 <desaiu> The only thing I would consider is going back to RWH
21:14:39 <desaiu> Really?
21:14:42 <desaiu> What is it missing?
21:14:59 <shachaf> desaiu: Did you read the thing where it talks about do-notation yet?
21:15:49 <desaiu> I'm on the section Language Basics
21:15:50 <thoughtpolice> kmc: the paper intro kinda goes into the motivation for monad-par, and it's basically summed up as "par and pseq are difficult to use for many people, and even with strategies achieving good performance can be tough." so monad-par basically tries to alleviate that. i don't know if that's enough to convince you it's a "good thing"
21:16:13 <scooty-puff> so i either get two log n operations, or i get .. two log n operations
21:16:38 <thoughtpolice> also, I seem to have forgot how glamorous of work it is to write FFI bindings
21:16:57 <elliott> desaiu: If you're on language basics, get out before it's too late. :p
21:18:50 <desaiu> I'm reading "DOOM!" from some of you guys, and I'm just going to assume you know what you are talking about
21:19:02 <desaiu> I'm going back to RWH and I'll just ask in here for clarification when I trip up
21:19:37 <kmc> thoughtpolice, yeah, I've definitely had trouble achieving good performance with strategies
21:19:53 <elliott> desaiu: LYAH is good, seriously.
21:20:05 <shachaf> The real way to learn Haskell is to write a Haskell compiler in Haskell.
21:20:11 <shachaf> We need more JHCs in the world.
21:20:27 <elliott> desaiu: It will leave you with a very good comprehension of the language and a good idea of how to go about implementing abstractions and solving problems with it.
21:20:33 <elliott> RWH works to fill in the rest, i.e. building practical systems.
21:20:49 <thoughtpolice> kmc: par and pseq are no better, because you basically need to know operational semantics about them and related things like GC if you want to get good performance. monad-par is deterministic and at least has explicit granularity, so the IVar thing is disconcerning, but hopefully no crazy heisenbugs you'd normally get
21:20:59 <elliott> shachaf: I've always been a bit sceptical of jhc. It seems far too well-written for someone who doesn't know Haskell.
21:21:38 <kmc> thoughtpolice, yeah, I mean if you're doing pure computation, it's clearly better to use monad-par than to use Control.Concurrent, but either seems kind of like giving up
21:21:48 <kmc> i guess i should just trust that the Powers that Be have the same attitude
21:21:53 <kmc> and will not stop trying to improve strategies etc
21:22:32 <elliott> It seems a bit backwards to go from a functional evaluation order and parallelism mechanism to an imperative one.
21:23:15 <thoughtpolice> elliott: keep in mind JHC was under development for a long time, even before john released it. i think he said he officially started working on it in about 2001, and didn't make any public release until like 2005
21:24:08 <kmc> i think parallelism and concurrency are one major area where Haskell can impress "mainstream programmers", but I worry that the field is getting too cluttered with different approaches, and they're moving too fast
21:28:29 <ddarius> kmc: The approaches aren't in competition.
21:29:04 <kmc> agreed
21:29:13 <kmc> but there's a lot to learn in order to pick the right one
21:29:31 <ddarius> That's just the reality of the problem.
21:29:54 <ddarius> kmc: We could make it simpler by just not allowing you to use the right tool when appropriate.
21:30:02 <DanBurton> I'm looking a little bit into F#...is there a way to program in and compile/run F# programs without using Visual Studio?
21:30:21 <Cale> DanBurton: Maybe Mono stuff?
21:30:40 <ddarius> Also you don't need to use Visual Studio to use the Microsoft compilers.
21:32:23 * hackagebot hogg 0.4.1.1 - Library and tools to manipulate the Ogg container format  http://hackage.haskell.org/package/hogg-0.4.1.1 (ConradParker)
21:33:08 <Philippa> ddarius: you just reminded me I should read up on the parallelism monad stuff soon
21:34:20 <dalaing> I had a brief google around regarding F# and Mono a while ago (12+ months), seemed that some people thought there were some underlying problems in the Mono stack which might mean it's a bit of a non-starter
21:34:45 <dalaing> I don't know enough about F# or Mono to be able to say whether that's accurate or not, and it could have all been fixed since then
21:34:56 <DanBurton> there's always been some hesitancy to embrace Mono
21:35:13 <thoughtpolice> F# 2.0 works on mono and IIRC the latest version of mono (2.10?) includes it by default
21:37:52 * monochrom has tried out Spec# at the command line, without Visual Studio
21:37:57 <dalaing> thoughtpolice: nice, very good to know
21:40:19 <DanBurton> isn't Ubuntu due for a new release soon? Or did they switch to yearly releases?
21:40:30 <luite> yeah next week
21:40:45 <ddarius> The sad thing, though, is that C# is a better language than F# in many ways.
21:40:57 <hpaste_> “Joey Adams” pasted “Trying to understand why an Enumerator is a generator and not also a consumer” at http://hpaste.org/52267
21:40:58 <DanBurton> ddarius: how so?
21:41:30 <JoeyA> I'm trying to understand how Enumerator does what it does, and why it's not an Enumeratee.
21:41:35 <thoughtpolice> luite: really?
21:41:45 <thoughtpolice> oneric? damn, i didn't know they move that fast
21:41:47 <JoeyA> What happens if an Enumerator tries to consume input?
21:42:01 <JoeyA> (since it's in the Iteratee monad)
21:42:23 <luite> thoughtpolice: release is planned to be the 13th
21:42:40 <thoughtpolice> luite: hmm wow. well at least i won't have to use my own special linux 3.0 kernel anymore hopefully :)
21:42:53 <thoughtpolice> although i'm sure upgrading will break a trillion things somehow
21:43:25 <luite> yeah it's often good to wait a few more weeks :)
21:46:35 <newsham> > 1
21:46:36 <lambdabot>   1
21:48:42 <elliott__> newsham: stunning
21:49:37 <kmc> glad that's settled
21:50:16 <kmc> yep, ubuntu releases every 6 months, in April and October
21:50:27 <kmc> that's why the version numbers are always x.04 or x.10
21:50:43 <shachaf> April and October. Aprober.
21:52:32 <elliott__> shachaf: Totally my gimmick, dude.
21:52:42 <elliott__> kmc: Not always! There are two exceptions.
21:52:56 <elliott__> Or, hmm.
21:52:58 <elliott__> No, only one exception.
22:08:06 <wavewave> is it okay that I repost a post in haskell-cafe to reddit?
22:08:37 <kmc> if you think it's a particularly notable post, sure
22:08:43 <elliott> if you do, please use the google groups interface, the other mail archives are unbearable
22:08:51 <kmc> i read /r/haskell but not haskell-cafe, so people like me will see it
22:09:09 <elliott> (https://groups.google.com/group/haskell-cafe/topics?hl=en)
22:09:23 <wavewave> kmc, elliott : thanks.. let me look up google group for the same post.
22:10:10 <djahandarie> I can barely handle the load of the Agda mailing list... haskell-cafe would be a disaster for me :P
22:10:34 <parcs> two words: digest mode
22:15:47 <monochrom> wait, use google groups to... post to reddit?! :)
22:18:19 <wavewave> in fact, this was not haskell-cafe post, but  haskell-prime post.
22:18:35 <wavewave> I couldn't find google-group for haskell-prime.
22:19:47 <monochrom> oh! I now see why google groups is involved. you're posting a url to reddit, and you're saying that url had better point to google groups rather than say gmane
22:20:45 <wavewave> elliott: cannot find google-group. I will post haskell.org/pipermail .
22:20:49 <elliott> ok
22:22:24 <appamatto> How is ghc able to generate C code for Haskell and still support lazy evaluation?
22:23:14 <ddarius> How is it able to produce assembly and LLVM and still support lazy evaluation?
22:23:16 <Cale> appamatto: Generating C code isn't the main way that ghc compiles anymore...
22:23:42 <monochrom> you can mimick lazy evaluation in C by hand, too. it's just tedious.
22:23:50 <Cale> appamatto: Of course it can generate any kind of program that it wants to
22:23:52 <wavewave> sent it.. it was a post by SPJ. did anyone here take part in the discussion there?
22:23:52 <monochrom> it's also unreadable C at the end
22:24:33 <monochrom> this is why you use a computer rather than a group of grad students for a compiler
22:24:40 <appamatto> ddarius, also valid questions :)
22:25:26 <Saizan> wavewave: i did, why?
22:25:39 <appamatto> Hmm, does ghc generate "native" code that does little more than work cooperatively with the vm, or does it actually generate C code similar to that another language would?
22:26:54 <elliott> it generates native-native code
22:26:57 <elliott> sometimes native-llvm code :P
22:27:08 <elliott> it's a "real" compiler, yes
22:28:06 <wavewave> Saizan : ahh. just asked without any specific thought : )  Today, I was involved in incoherent instances, overlapping instances stuff and found this very recent discussion..
22:28:58 * Saizan would like to have instance chains to play with
22:29:36 <Saizan> and true fundeps
22:29:40 <wavewave> it seems that it was not introduced to reddit forum.
22:29:40 <kmc> appamatto, the C code that comes out of GHC is very strange C code
22:29:51 <appamatto> okay, thought so
22:29:55 <kmc> (and using C at all is deprecated)
22:30:39 <monochrom> some cooperation with the "vm" (actually a runtime, a collection of C functions), e.g., once in a while it calls a memory-allocation function, which may decide to GC.
22:31:02 <appamatto> I'll have to do some more research--I'm writing a language that is somewhat similar to haskell and I was thinking about writing the vm in the language as well
22:31:09 <kmc> appamatto, did you read the paper "Implementing lazy functional languages on stock hardware: the Spineless Tagless G-Machine"?
22:31:12 <monochrom> actually it's a bit less overhead than what I said
22:31:14 <kmc> appamatto, by VM you mean "virtual machine"?
22:31:38 <wavewave> Saizan: by the way, haskell-prime mailing list has only pipermail web view? it's quite messy in reading.
22:31:43 <kmc> GHC doesn't really use a virtual machine -- I mean, any language is a virtual machine and any program implements a virtual machine if you squint just right
22:31:45 <appamatto> I mean, the part of the language that usually gets written in C (garbage collection, g-machine-like evaluation engine)
22:31:51 <monochrom> but most of the time the generated code simply does a lot of tests and branches and push stack and pop stack
22:31:52 <kmc> ah
22:32:09 <monochrom> (plus whatever arithmetic you have decreed)
22:32:32 <kmc> some parts of the evaluation engine in GHC are written ahead of time in C or Cmm
22:32:33 <Saizan> wavewave: that's the one i know about, i've not looked for more though
22:32:36 <kmc> but much of it is generated by the compiler
22:32:49 <appamatto> I read the STG paper a long time ago, but forgot most of it
22:33:01 <monochrom> it actually rarely calls the g-machine functions if you turn on optimizations. it usually calls the g-machine functions if you turn off optimizations, otoh.
22:33:25 <wavewave> found osdir ..
22:33:27 <kmc> appamatto, every heap object has a pointer to some code which is executed when that heap object is entered
22:33:34 <monochrom> read the generated code yourself some day :)
22:33:41 <kmc> often custom code generated for a particular lambda in the source code
22:34:14 <kmc> appamatto, ah, I recommend re-reading the STG paper (it took me about three readthroughs to understand it)
22:34:23 <appamatto> Will do
22:34:24 <kmc> it also addresses some of the issues when compiling via C specifically
22:34:41 <kmc> the old C backend to GHC had two flavors, "registerized" and "unregisterized"
22:35:15 <kmc> reg'd was the default, and had acceptable performance, but used a bunch of GCC extensions, and would post-process the assembly output of GCC with a Perl script called the Evil Mangler
22:35:20 <wavewave> osdir, nabble, gmane ... which one do you prefer?
22:35:21 <kmc> so it's not really "compiling via C"
22:35:27 <appamatto> My language isn't specifically a lazy language, the evaluation order is unspecified but should be done lazily as much as possible
22:35:40 <appamatto> So it's also possible to compile it to an imperative language
22:35:42 <kmc> appamatto, the evaluation order in Haskell is unspecified, too
22:35:44 <appamatto> (should be possible)
22:35:52 <kmc> but the semantics are non-strict
22:36:19 <kmc> your language should probably specify whether (\_ -> 3) (error "foo") evaluates to 3 or raises an exception
22:36:50 <appamatto> Well, I don't think it should, but the type system should note that such an expression is ambiguous
22:37:01 <elliott> eh?
22:37:07 <elliott> that's well-typed
22:37:19 <kmc> appamatto, well, strict and non-strict semantics coincide on the terms where strict semantics produce a value
22:37:23 <appamatto> I don't think it should be
22:37:34 <appamatto> (well-typed)
22:37:46 <kmc> so if you reject "ambiguous" cases you are just rejecting non-strict semantics
22:37:54 <kmc> and you might as well say your language has strict semantics
22:37:56 <monochrom> I want your type system!
22:38:04 <appamatto> hehe
22:38:09 <appamatto> monochrom, working on it :)
22:38:15 <elliott> appamatto: how is it not well-typed
22:38:26 <monochrom> (subtext: I think it solves the halting problem!)
22:38:28 <kmc> deciding whether a particular term is ⊥ requires solving the halting problem
22:38:35 <monochrom> darn you
22:38:47 <appamatto> monochrom, the type system doesn't always halt :p
22:38:57 <monochrom> and darn you too
22:39:08 <kmc> unless you reject general recursion, of course
22:39:11 <elliott> "Nice"
22:39:14 <elliott> re appamatto
22:39:32 <appamatto> I'm interested in supporting arbitrary type systems, so that the language doesn't need to get rewritten anytime someone wants to experiment
22:40:03 <appamatto> A pluralistic approach :)
22:40:15 <appamatto> Anyway, I've got to hit the sack--thank you for the info about ghc!
22:41:56 <wavewave> I commented the reddit post with the original thread starter (nabble interface). the thread looks quite rich.
22:50:48 <Saizan> btw we shouldn't be twisting the semantics of instance Foo a => Bar a to accomodate instance resolution limitations, we should just go straight to the fact that it's an inference system crippled by design, though that might take more lines on irc
22:51:23 <tyrion_lanister> @pl \x -> map (x:)
22:51:23 <lambdabot> map . (:)
22:54:14 <tyrion_lanister> @pl \acc x -> if x `elem` ys then acc else x:acc
22:54:14 <lambdabot> ap (ap . flip (if' . (`elem` ys))) (flip (:))
22:58:08 <Cale> Saizan: ?
22:58:21 <Cale> Saizan: What do you mean by that?
22:59:40 <wavewave> Saizan: ?
22:59:51 <Saizan> Cale: that often when someone is puzzled by how such an instance overlaps with Bar X that gets explained by making it seem like instance Foo a => Bar a provides an instance Bar a for all a's
23:00:42 <Cale> Well, the choice of instance is independent of Foo a
23:02:27 <Saizan> if you have only instance Foo a => Bar a; instance Foo X; you don't have an instance for Bar Y
23:05:09 <hpaste_> kmc annotated “mutation!” with “mutation! (now dodges pointer tagging)” at http://hpaste.org/52266#a52268
23:05:23 <kmc> elliott, ^^^ :D
23:05:27 <kmc> now it actually gives the "right answer"
23:05:45 <ohwow> Hello guys, anyone here using haskell-mode for emacs? I did (setq haskell-font-lock-symbols t) but I still don't see pretty greek symbols :(
23:05:47 <elliott> kmc: noooooooooooooo
23:05:50 <elliott> :'(
23:05:53 <shachaf> kmc: I don't think you exactly *get* bonus points for making it work better.
23:06:07 <kmc> bah
23:06:26 <elliott> does it work in ghci
23:06:30 <kmc> no
23:06:54 <kmc> actually, this version does
23:06:59 <elliott> :D
23:07:31 <ohwow> o nvm, i had to restart emacs
23:08:16 <solrize> so does anyone use IterIO?  It seems much more comprehensible than the other iteratee implementations
23:08:30 <elliott> i did
23:08:37 <elliott> it's great
23:08:51 <elliott> moved away for reasons unrelated to goodness
23:09:11 <thoughtpolice> it has good documentation and i like the naming better, personally. the current implementation is kind of kitchen-sink though
23:09:18 <ohwow> What font is the best to use with haskell-font-lock?
23:09:24 <thoughtpolice> overall i too think it's a bit more comprehensible :)
23:09:27 <kmc> COMIC SANS MS
23:09:54 <thoughtpolice> splitting off the attoparsec/zlib/ssl dependencies would make it a lot slimmer.
23:10:10 <ohwow> Seriously tho
23:10:22 <ohwow> I am using DejaVu Sans Mono and every greek symbol looks like crap
23:11:01 <kmc> SPJ uses Comic Sans in many of his PowerPoint presentations
23:25:56 <ohwow> What is the simplest way to generate plots in Haskell?
23:26:08 <ohwow> What is the best library with minimum dependencies, I guess
23:26:44 <wavewave> there is gnuplot library
23:27:09 <wavewave> if you don't mind using external tool.
23:27:25 <ohwow> So I just have to download GNUPlot itself in order to use it?
23:27:59 <wavewave> yes. which os are you using?
23:28:26 <solrize> what are you trying to plot?
23:28:37 <kmc> you don't need any Haskell library if you just write out gnuplot data files
23:28:37 <solrize> timeplot and splot are great if a bit special-purpose
23:28:38 <wavewave> Chart library is also cool
23:29:11 <solrize> what's that thing that ganglia uses?
23:29:34 <solrize> rrdtool
23:29:43 <ohwow> I just need to plot polynomials in 2D.
23:29:43 <solrize> ftp://munnari.oz.au/pub/oldtz/tzcode2011g.tar.gz
23:29:47 <ohwow> That's all
23:29:48 <ohwow> :S
23:29:49 <solrize> oops wrong url
23:29:53 <solrize> http://oss.oetiker.ch/rrdtool/
23:30:00 <solrize> ohwow, use gnuplot for that
23:30:48 <ohwow> Ok, will do, thakns
23:31:26 <ohwow> Btw, what does `Num t' mean?
23:31:57 <kmc> it's a type constraint
23:32:03 <ohwow> I am trying to write a function which is polymorphic on all numbers
23:32:07 <kmc> says that the type variable 't' can only be instantiated to numeric types
23:32:29 <kmc> an explanation of the 'Num t' syntax out of context is probably not that useful
23:32:37 <kmc> consult your favorite Haskell tutorial's section on type classes
23:32:47 <ohwow> Ah, I see, thanks
23:32:53 <ohwow> I haven't got that far yet
23:35:18 <solrize> Westboro Baptist Church uses iPhone to announce protest at Steve Jobs’s funeral
23:35:21 <solrize> sheesh
23:35:44 <meric> protest of what?
23:35:52 <kmc> old + off topic
23:36:06 <solrize> that's the outfit that pickets funerals of people they consider sinners
23:37:27 <thoughtpolice> argh, too much FFI! kmc, write something that will make good bindings automatically :)
23:37:45 <kmc> oh this is my job now?
23:37:57 <kmc> you make one lousy talk...
23:38:27 <meric> c2hs?
23:39:11 <thoughtpolice> my binding isn't even particularly high level. i'm just really getting tired of writing 'foreign import' and various Data.ByteString.Unsafe strings, followed by C glue code, over and over. :P should just take a break.
23:39:25 <shachaf> thoughtpolice: Just use C.
23:39:28 * shachaf solves problem.
23:39:29 <thoughtpolice> s/using various Data.ByteString.Unsafe functions/
23:39:45 <thoughtpolice> bleh, screw my horrid typing
23:39:59 <meric> cabal info c2hs "C->Haskell FFI tool that gives some cross-language type safety"
23:40:14 <meric> thoughtpolice: will that help?
23:40:14 <thoughtpolice> shachaf: that is indeed a solution in some sense :P
23:40:30 <kmc> i recommend writing as much of your glue code in Haskell as is possible
23:40:36 <kmc> because then you can abstract over it more easily
23:41:26 <thoughtpolice> meric: i've looked at c2hs and it might help. in this case it's not that it's so hard to write direct bindings, it's just repetetive having to bind lots of small functions. i imagine it will be similar even with a tool :P
23:41:53 <meric> ok
23:42:25 <kmc> you can write a program to write that boilerplate for you
23:42:30 <thoughtpolice> kmc: it's kind of stupid because most of these glue wrappers are just 1 to 2 line C functions, but the reason I'm doing this is because the library I'm binding hides the actual implementation of a function behind a #define, and GHC doesn't care about macros when doing FFI, so you have to give the full function you want to link to
23:43:06 <ohwow> What is the numeric type for a numbers which form a field, which can be divided?
23:43:23 <thoughtpolice> so something like 'crypto_box_keypair' is actually a #define for crypto_box_keypair_crazy_impl_name_goes_here - and the impl is based on potential CPU-specific optimizations. :/
23:43:41 <shachaf> ohwow: The numeric types in Haskell don't really correspond to algebraic or to mathematics in general all that well.
23:43:51 <shachaf> There's Fractional:
23:43:52 <thoughtpolice> really i could probably just do some CPP macro hackery to make a lot of this go away i bet
23:43:53 <shachaf> @src Fractional
23:43:53 <lambdabot> class  (Num a) => Fractional a  where
23:43:54 <lambdabot>     (/)             :: a -> a -> a
23:43:54 <lambdabot>     recip           :: a -> a
23:43:54 <lambdabot>     fromRational    :: Rational -> a
23:44:13 <thoughtpolice> (or at least make the stupid glue.c bindings smaller/easier to add to)
23:44:29 <shachaf> This one is great:
23:44:31 <shachaf> @src Real
23:44:32 <lambdabot> class  (Num a, Ord a) => Real a  where
23:44:32 <lambdabot>     toRational      ::  a -> Rational
23:44:44 <ohwow> Hm
23:44:44 <ohwow> so
23:44:55 <ohwow> what's the difference between Fractional and Real?
23:45:05 <ohwow> Fractional also represents Complex numbers?
23:45:22 <kmc> thoughtpolice, you can just #include those defines in your Haskell file, yeah?
23:45:30 <kmc> hsc2hs can do that anyway
23:46:01 <shachaf> kmc: Presumably if you have #define MACRO(x,y) do { ...(x,y); } while(0) then you'll still need to make a wrapper?
23:46:15 <shachaf> ohwow: They do exactly what their type classes say they do. :-)
23:46:31 <Axman6> @src Fractional
23:46:31 <lambdabot> class  (Num a) => Fractional a  where
23:46:32 <lambdabot>     (/)             :: a -> a -> a
23:46:32 <lambdabot>     recip           :: a -> a
23:46:32 <lambdabot>     fromRational    :: Rational -> a
23:46:35 <Axman6> @src Real
23:46:35 <lambdabot> class  (Num a, Ord a) => Real a  where
23:46:36 <lambdabot>     toRational      ::  a -> Rational
23:47:07 <kmc> @src RealFrac
23:47:07 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
23:47:08 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
23:47:08 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
23:47:33 <ohwow> I don't understand, sorry :(
23:47:38 <thoughtpolice> kmc: what about when I say 'foreign import ccall unsafe "..."' <- with the real impl hidden in a #define, what do I put in for the ... ? i assume hsc2hs runs the regular C preprocessor, so I guess I could just quote the macro argument with # then
23:47:40 <ohwow> I think I should read more about typeclasses, etc
23:47:41 <kmc> it's all a bit of a mess
23:47:51 <kmc> *nod*
23:47:53 <thoughtpolice> hm, maybe that will work
23:47:56 <kmc> maybe
23:47:59 <kmc> or it might fail within quotes :/
23:48:12 <kmc> imo the hard part of writing FFI bindings is providing an idiomatic Haskell interface
23:48:43 <kmc> which involves writing new types, converting magic sentinel values to Nothing, deploying finalizers and unsafePerformIO where appropriate, etc
23:48:52 <ohwow> Can you guys check my code please? It's working, but it looks like crap, I need to improve my style: http://paste.lisp.org/display/125152
23:48:57 <kmc> and this is not something a tool can help very much with :/
23:49:05 <thoughtpolice> luckily these bindings are, for the most part, extremely simple and straightforward. the APIs are all very simple with very few 'gotchas'
23:49:20 <shachaf> I think this is the part where you traditionally hire a poor student to do it for you.
23:49:32 <thoughtpolice> i'm thinking about if it might just be easier to include all the reference NaCl implementations in the package, if I could make that work...
23:49:55 <thoughtpolice> (djb writes weird build systems/project layouts, who knew?)
23:50:00 <Axman6> ohwow: heh, yes it does :P firstly, get rid of the lambda at the beginning, and just make x a parameter of lagrange
23:50:08 <shachaf> thoughtpolice: Oh, you're writing NaCl bindings?
23:50:21 * shachaf was considering doing that before.
23:50:24 <thoughtpolice> yep
23:50:32 <shachaf> I'm glad I won't need to. :-)
23:50:48 <Axman6> also, what the bloody hell is wrong with gth2hs
23:51:02 <Axman6> setup: The program gtk2hsC2hs version >=0.13.5 is required but the version
23:51:02 <Axman6> found at /Volumes/Monad/Users/Axman/Library/Haskell/bin/gtk2hsC2hs is version
23:51:03 <Axman6> 0.13.4
23:51:17 <Axman6> but i just installed the new version of gtk2hs-buildtools >____________<
23:51:26 <thoughtpolice> :P it's a really nice library honestly. very straight forward, no super weird edge-cases in the API, all the primitives have good defaults (although I plan to allow you to use other primitives if you want)
23:51:33 <solrize> http://paste.lisp.org/display/125152#1   golfed it slightly
23:51:40 <solrize> indentation is messed up, don't follow that example ;)
23:51:44 <thoughtpolice> although I can very easily tell you why most people have never heard of it, and that's because this doesn't work: aptitude install libnacl-dev
23:51:49 <thoughtpolice> :P
23:52:48 <solrize> oops should say ps x   rather than  ps z
23:53:01 <thoughtpolice> you also make a tradeoff between something like openssl in that nacl implements somewhat different primitives for most of the operations, but djb is pretty good.
23:54:05 <ohwow> solrize: ohh nice, thanks
23:54:10 <ohwow> but how do I fix identation?
23:54:22 <ohwow> I come from a lisp background, so it is kinda messy
23:54:38 <Axman6> dcoutts: are you around?
23:56:20 <Axman6> @ask dcoutts is there a reason why gtk requires gtk2hsC2hs version >=0.13.5 but 0.13.4 is the latest one available?
23:56:21 <lambdabot> Consider it noted.
