00:00:13 <napping> that wouldn't work anyway, constructors have to live in the heap or stuff gets strange
00:01:36 <handonson> how about other structures like... Map? how would they be saved in the executable?
00:01:51 <ddarius> They aren't.
00:02:09 <bartavelle> hello, I'm writing some sort of interpreter for a language that has an "include" command. I would like to do something like mapping all file contents of files in a specific directory in a (Map String String), but have the IO happen in a lazy fashion
00:02:13 <bartavelle> I suppose this is not possible
00:02:20 <bartavelle> as the map would be a "pure" structure
00:02:23 <Cale> handonson: right, lists in general, even if they aren't eliminated by fusion, often only have one live cell in memory, and the garbage collector is really good at picking up short-lived values
00:02:26 <bartavelle> is there a magic way to do this ?
00:02:39 <bartavelle> (because I really need the file content in pure code)
00:02:42 <handonson> ddarius: so the code to produce Map is saved instead?
00:03:35 <Cale> handonson: yeah, and for everything apart from constant strings maybe, I'm not sure how often that optimisation to pack the string into an array is applied
00:03:36 <handonson> you know, something has to be saved in the data segment and something in the code segment
00:04:04 <Cale> but, but code is data ;)
00:04:23 <handonson> I mean in terms of assembly language.
00:04:46 <Cale> bartavelle: there is -- but you may hit OS limitations on open files
00:05:02 <Quantumplation> I want to watch video talks on haskell, either introductory or advanced features.  I just enjoy this kind of thing.  Seen the google tech talks, seen the Simon Peyton Jones talk on concurrency and such.  Anything else to watch?
00:05:07 <bartavelle> Cale : this is OK to me
00:05:09 <napping> most of it goes in the code segment
00:05:10 <Cale> handonson: I know
00:05:17 <napping> "tables next to code"?
00:05:25 <Cale> bartavelle: you can just readFile them all and put the results in a Map
00:05:36 <Cale> bartavelle: readFile in the Prelude is lazy
00:05:38 <handonson> Cale: Yes, I thought. No way you don't know it
00:05:41 <bartavelle> awesome
00:05:43 <bartavelle> thanks
00:06:01 <Cale> bartavelle: But as for what actually ends up in the data segment, I'm not sure.
00:06:08 <Cale> er, sorry, that was to handonson
00:06:18 <napping> handonson: if you are not planning to mutate the data, it can go in the code segment
00:06:27 <ddarius> handonson: There are no Map literals.  What you write in the source file is code to build a Map.
00:06:56 <napping> In particular, integer literals probably end up as immediates
00:07:17 <handonson> ddarius: You're right, but the compiler will do the "constant folding" and as a result things that are literal and things that are constructed with literals aren't really that different for a compiler, are they?
00:08:24 <Cale> The compiler doesn't know how long it'll take to evaluate them
00:08:43 <mroman> the readFile String is still lazy when I unwrap it from IO?
00:09:05 <Cale> mroman: Yeah, it's magic
00:09:16 <Cale> mroman: The file is read as you look at the string elements
00:09:36 <ddarius> handonson: If you write C code that builds a binary tree, the C compiler won't reduce that into static data.
00:09:39 <Cale> (a lot of people think this is too much magic to be in the Prelude, but it's handy for small shell-scripty things)
00:10:00 <mroman> Cale: With unsafePerformIO too?
00:10:14 <ddarius> I lot of people think its too much magic to be in Haskell.
00:10:15 <Cale> unsafeInterleaveIO is behind the scenes
00:10:17 <napping> unsafeInterleaveIO actually, but pretty close
00:10:22 <Cale> (which is a little less magic)
00:10:50 <Cale> unsafeInterleaveIO :: IO a -> IO a
00:10:52 <napping> it's not much different from return . unsafePerformIO, is it?
00:10:52 <handonson> ddarius: true, but that's because C has no type inference mechanism and it doesn't know if the result will end up... hold on...?
00:11:06 <Cale> transforms an IO action into one which, when its result is evaluated, performs the IO
00:11:15 <Cale> napping: Yeah, I can't think of any difference
00:11:18 <handonson> ddarius: so GHC has no ability to tell if a data structure is infinite or not? so it doesn't bother to constant-fold everything?
00:11:50 <Cale> handonson: Right, because that's the halting problem
00:11:53 <mroman> Cale: Isn't that default anyway?
00:12:00 <Cale> and it doesn't really even partially attempt to solve the halting problem
00:12:22 <napping> the inliner might do a bit
00:12:27 <mroman> IO actions are only evaluated when their results are evaluated?
00:12:33 <handonson> Cale: but what about types that are known to be finite?
00:12:50 <napping> mroman: no, they almost always happen in order. readFile is just special like that
00:13:08 <mroman> Order does not guarantee evaluation?
00:13:19 <mroman> head[print 5,print 6]
00:13:20 <napping> well, order in a do block
00:13:31 <napping> order like that or in a let doesn't control evaluation, those are lazy
00:13:51 <Cale> mroman: No. IO actions are evaluated at some point before they are executed, they all execute in a well-defined order - as specified by your program, and their results may be partially evaluated at the time of execution, or might only be evaluated at some later point.
00:14:09 <Cale> Usually evaluation of any sort can't cause I/O effects
00:14:09 <mroman> Okay
00:14:14 <Cale> But readFile is magic
00:14:17 <napping> yeah, that's more correct
00:14:25 <mroman> You might need to explain me the difference between evaluation and execution.
00:14:34 <napping> an IO thing is usually run in order with the do block, but can return a partially evaluated thing
00:14:40 <Cale> Okay, so evaluation means turning expressions into values
00:14:49 <mroman> Yes.
00:15:00 <mroman> But do to that, I need to execute the IO stuff?
00:15:04 <Cale> At runtime, there are (representations of) expressions floating around in memory, and evaluation turns these expressions into data constructors
00:15:11 <napping> and execution means taking a value of type IO a, and actually doing the stuff it says to do
00:15:22 <Cale> IO actions are datastructures that represent actions to be performed
00:15:47 <mroman> Ic.
00:15:48 <Cale> Evaluating those datastructures doesn't cause the actions to be carried out, any more than opening a program in a text editor causes it to run.
00:15:59 <napping> anyone know much typography
00:15:59 <mroman> Makes sense.
00:16:12 * napping is dubious that a j at the start of a line should extend left of the margin
00:16:36 <tehgeekmeister> huh.  there doesn't appear to be a rest package for haskell.
00:16:47 <Cale> There's a process of execution which causes the IO actions to happen, and that's "entirely separate" at least conceptually, from evaluating them. (In practice, GHC does some ugly hacks and leverages parts of its evaluator to do it, but you don't need to be aware of that)
00:17:00 <handonson> napping: depends on the occasion, I guess?
00:17:22 <ddarius> handonson: C doesn't need type inference all types are statically declared.
00:17:24 <Cale> napping: Is it in italics?
00:17:33 <napping> no, just plain text
00:17:39 <Cale> hmmm...
00:18:09 <napping> I'm reviving some old hacks with pango trying to do lhs2TeX style rendering of layout+proportional fons
00:18:12 <Cale> I think the dot ought to be in the same place as if an i were there.
00:18:26 <napping> okay, that's how it is
00:18:30 <Cale> But, it's probably typeface dependent to some extent.
00:19:15 <napping> mroman: readFile is something like having crazy emacs file-vars in your program that kicks off a test server as soon as you open it
00:19:35 <Cale> kekeke
00:19:43 <handonson> ddarius: No, that's not what I meant... like, in C, even if there's a int i, you don't know it's value until you compile an run... but in Haskell, if there's a top-level myInt :: Int, and the code typechecks, then you are guaranteed to know its value before actually running the problem (excluding the possibility of unsafePerformIO)
00:19:55 <handonson> it's value -> its value
00:19:56 <handonson> damn
00:20:01 <Cale> readFile is mildly evil, but if you *know* the file won't change while your program is running, it's fine
00:20:10 <handonson> an run -> and run ... okay forget it
00:20:14 * tehgeekmeister thinks he'll be writing a basic rest wrapper soon.  but for now, bed.
00:20:16 <napping> handonson: Turing has a thing or two to say about that
00:20:36 <handonson> napping: You're right. I'm totally wrong.
00:20:40 <Cale> handonson: Well, the trouble with that is that you can't tell if the Int is nonterminating or not :)
00:20:46 <napping> If you were talking Agda or something, maybe
00:21:00 <handonson> Like, it could be myInt = length [0 ..]
00:21:01 <Cale> Yeah, it's kinda weird to think about because in strict languages, values are always already evaluated.
00:21:23 <Cale> While in Haskell, any value can be an unevaluated expression
00:21:29 <napping> well, then it might get smart and replace it with error "<<Loop>>" or something
00:21:50 <mroman> If by top-level you mean constant... then ok.
00:21:50 <Cale> heh
00:22:21 <mroman> i = 5 :: Int vs. int i = 5;
00:22:25 <napping> what it could do but doesn't is do more agressive CSE on Int expressions
00:22:26 <ddarius> Knowing the type (usually) has nothing to do with knowing the value.
00:22:40 <handonson> so in case of ADTs like Map or Zipper, there's no optimization at all?
00:22:52 <handonson> everything's saved in the code segment?
00:22:52 <mroman> i in C is not guaranteed to be always 5.
00:23:03 <Cale> handonson: Just the usual sorts of optimisations on code
00:23:10 <napping> well, constants can be saved in the code segment
00:23:13 <Cale> Inlining, and such.
00:23:28 <napping> and it might inline and optimize things down to code that allocates some constructors rather then function calls
00:23:39 <mroman> Yeah, but I somehow might have guessed the pointer to i and changed the value.
00:23:44 <Cale> I'm not sure it'll get that far with Map
00:23:59 <Cale> Pretty sure the simplifier won't reduce comparisons
00:24:00 <mroman> (Would that be possible in Haskell too?)
00:24:05 <napping> but in general if something is a literal, it's small enough not to worry to hard about
00:24:09 <Cale> (though I could be wrong)
00:24:18 <mroman> With IO functions?
00:24:28 <napping> except perhaps to keep the size of the binary down, like with strings packed as arrays
00:24:55 <Cale> mroman: It's theoretically possible to change the value of a constant Haskell value from an IO action, but it's not practically feasible, and anything you did wouldn't be portable.
00:25:27 <Cale> mroman: However, there are IORefs which are like mutable cells
00:25:45 <Cale> mroman: and mutable array types and all sorts of other mutable datastructures accessible from IO and ST and STM
00:26:01 <handonson> in fact, there are portable ways to do that, i guess...?
00:26:17 <Cale> To do what?
00:26:32 <handonson> to change something that's supposed to be a constant?
00:26:34 <handonson> with unsafeCoerce or unsafePerformIO or ...
00:26:47 <Cale> Even those wouldn't let you do it
00:26:54 <napping> Ptr
00:27:06 <Cale> You'd have to hack away at the heap.
00:27:14 <Cale> To find the things that you wanted to change
00:27:44 <handonson> I mean, I can make myInt :: Int to be in fact a Ptr a
00:28:02 <Cale> unsafePerformIO will let you perform an IO action when something is evaluated, but once it evaluates, it tends to stay evaluated forever
00:28:11 <handonson> Or maybe not Ptr a but just a, pointed by the Ptr
00:28:18 <napping> hmm, ext-core?
00:28:27 <Cale> (so the IO action will *probably* run only once, though this isn't guaranteed either)
00:28:38 <napping> if you could flag it non-updating
00:29:14 <Cale> So you can have, for example, something which looks like a constant, but the first time it's evaluated, it evaluates to the current time, but thereafter, it doesn't change.
00:29:21 <Cale> Using unsafePerformIO
00:29:45 <Cale> at least, you can't guarantee that you'll ever see a different value (though you might, sporadically, depending on what the optimiser did)
00:30:04 <handonson> Well, it does change, if it's referenced multiple times, and it's inlined
00:30:08 <Cale> yeah
00:30:19 <ddarius> handonson: The heap has no specified format and changes regularly.  There is no portable way to change it.
00:31:20 <Cale> Yeah, if you start from something like x = 5, and then want an IO action to adjust the value of x at some point, there's no portable way to do it.
00:31:20 <handonson> ddarius: probably I can't portably "control" it
00:31:27 <Cale> (Nor should there be)
00:31:43 <ddarius> handonson: It may never be on the heap.
00:32:47 <Cale> If you want to use hackery to introduce top-level mutable state, it is possible to do that with unsafePerformIO. (Though it still usually makes me kinda sad)
00:33:43 <handonson> Cale: there's absolutely no way to x =5 then change it thereafter even unportably, because even if the compiler is the same, the compiler may randomly inline it or not
00:34:00 <handonson> so even if you do know its memory address, you won't be able to make changes in the way you want
00:34:27 <Cale> Basically, you should regard unsafePerformIO as serving two purposes: one is to let you purify bindings to external libraries where you know the actions being performed are actually pure, and the second is to let you add new primitives to the evaluator that would not otherwise be possible without modifying the compiler.
00:34:29 <handonson> well maybe you can analyze the compiler inside out and make your code track all the possible inlined locations and... no, let's say impossible
00:34:41 <Cale> handonson: Right, that too :)
00:35:04 <ddarius> handonson: You could always just write your own compiler.
00:35:10 <Cale> Even if you managed to find the thing on the heap and change it, you have no guarantee that you've changed them all
00:35:22 <ddarius> Of course, calling something that only works on your custom compiler "portable" is a bit silly.
00:35:45 <ddarius> It may not be on the heap at all.  There may be no 5 at all.
00:36:01 <handonson> ddarius: yeah, by "unportable" I meant writing code for each compiler
00:37:35 <Cale> That said, people have managed to do some crazy unportable things with the GHC heap :)
00:37:43 <napping> crude hack: http://imageshack.us/photo/my-images/849/screenshotpangotesting.png/
00:39:58 <handonson> Cale: most of the time by directly telling GHC to do this and that, right?
00:40:02 <Cale> Like that IOHCC entry by dons which defined a ByteString containing a GHC closure and then entered it
00:40:12 <handonson> with so many flags and pragmas
00:40:38 <Cale> I wonder if I can dig that up. I think it was called crawl.hs
00:40:56 <napping> which version did it work with?
00:41:11 <Cale> It only worked in a development version of GHC
00:41:24 <Cale> and didn't work in the release
00:41:42 <Cale> http://www.cse.unsw.edu.au/~dons/ :(
00:41:48 <napping> I had some unsafeCoerce# tricks once, but they don't work anymore (maybe pointer tagging?)
00:42:27 <napping> scrolling the text view should be a lot easier than trying to write an editor
00:43:11 <Cale> > case [1,2,3] of (:){} -> "hello"
00:43:11 <lambdabot>   "hello"
00:43:16 <napping> or maybe I should just bug a gtk list about some kind of crazy tabstop support
00:43:50 <napping> no comments on the screenshot?
00:44:07 <Cale> oh, missed it
00:44:09 <Cale> cool!
00:44:31 <handonson> napping: awesome, but what is crude?
00:45:07 <Cale> Probably the binding to pango? That's what you're working on, yeah?
00:45:11 <napping> well, it only does one block now
00:45:20 <napping> nah, pango bindings have been in gtk for a while
00:45:39 <Cale> Oh, you're doing general Haskell prettyprinting with Pango?
00:45:50 <napping> using the bindings to lay out the text myself, so layout is exact
00:46:05 <Cale> nice
00:47:28 <starngestLoop> hello
00:47:35 <Cale> hello
00:47:59 <starngestLoop> I have a question about cabal config files
00:48:09 <Cale> ask away :)
00:48:21 <starngestLoop> trying to use the hdbc module with snap
00:48:58 <SoleSoul> Hi. Is there a way to distribute haskell application as portable? I tried to install Leksah and Yi but it was very complicated. What prevents them from supplying a download and run executables?
00:49:13 <starngestLoop> I added these two build-depends "hdbc, hdbc-mysql"
00:49:48 <handonson> SoleSoul: probably because they use some GHC features to manage the source code?
00:49:52 <handonson> (I don't know for sure)
00:49:55 <starngestLoop> but Im getting an error the import of "Database.HDBC.MySQL" being a member of a hidden package
00:49:55 <Cale> SoleSoul: I believe Yi is of the form that its configuration is the main program itself like xmonad is, so you recompile it to configure it
00:50:23 <handonson> SoleSoul: if that's the case, they'd have to include the entire GHC to make it a single executable distribution
00:50:28 <starngestLoop> does anyone have any experience using mysql and snap?
00:50:42 <handonson> which will be an outrageous file size
00:50:51 <Cale> starngestLoop: hmm, that's interesting.
00:50:51 <handonson> oh, by the source code I meant the user code
00:50:59 <handonson> the code you type in Leksah and Yi
00:51:22 <Cale> starngestLoop: just out of curiosity, try HDBC-mysql? I didn't think it was case sensitive...
00:51:39 <SoleSoul> Cale handonson : so these are special cases? Can I assume that if I create for example a download manager in haskell it would be possible to compile it so it would run from a usb-disk on any windows machine without dependencies?
00:52:04 <Cale> SoleSoul: I think so. I'm not so familiar with Windows.
00:52:10 <Cale> SoleSoul: but yeah, it should be possible
00:52:32 <SoleSoul> Cale: Static linking in linux is also an option if it is possible.
00:52:38 <Cale> Even if there are deps, you can stick the .dlls you need in the same directory
00:52:41 <Cale> iirc
00:52:47 <starngestLoop> tried using "HDBC", now I got this error: Undefined symbols:
00:53:09 <kofman> I have a slightly off topic question for the community. I've been thinking of changing careers from Game Development into HFT. Does anyone in the room have experience with HFT? Can advise on any certifications, or other points of entry
00:53:09 <Cale> starngestLoop: which symbols?
00:53:23 <starngestLoop> a sample: "_mysql_real_connect", referenced from:
00:53:36 <kofman> The reason I ask is because so far I found some comminality among the haskell community
00:53:40 <handonson> SoleSoul: GHC for windows is ridiculously good at making portable windows executables. Except when your source code uses some foreign library binding. In which case you have to envelope the DLL as well.
00:53:52 <Cale> starngestLoop: ah, okay, so that's the C mysqlclient library which is missing, that HDBC-mysql is a binding to
00:54:18 <SoleSoul> Cale: The motivation for the question is I think that the user doesn't even have to know which language it was written in since it compiles to native.
00:54:37 <SoleSoul> handonson: That's good to know. thanks
00:54:52 <Cale> starngestLoop: If you're on linux, look in your package manager for something like libmysqlclient-dev
00:55:03 <handonson> SoleSoul: this is one Haskell feature that kicks ass, especially compared to other high-level languages such as python
00:55:40 <SoleSoul> handonson: true. compilation to native is a huge advantage in my eyes
00:55:43 <starngestLoop> on a mac, but checking now
00:55:52 <Cale> SoleSoul: yeah, though there are dynamically linked dependencies that GHC-compiled executables have
00:56:24 <SoleSoul> Cale: *any* compiled executables?
00:56:40 <Cale> such as libgmp, which is LGPLed
00:56:52 <Cale> which is needed to support Integer
00:57:13 <SoleSoul> Cale: oh, license problems?
00:57:14 <Cale> (well, there are replacement libraries written in Haskell, but I'm not sure they're ready to be swapped in yet :)
00:57:20 <Cale> yeah, in that case
00:57:24 <SoleSoul> :/
00:57:31 <SoleSoul> :)
00:57:38 <SoleSoul> weird
00:58:10 <starngestLoop> got this: ld: warning: in /usr/local/mysql/lib/libmysqlclient.dylib, file was built for unsupported file format which is not the architecture being linked (i386)
00:58:40 <Cale> starngestLoop: You're on a mac?
00:58:42 <starngestLoop> sorry if these are noob questions, still wrapping my head around cabal
00:58:43 <starngestLoop> yeah
00:59:07 <SoleSoul> thanks guys
00:59:42 <starngestLoop> Im about 10 seconds from saying bollocks to this mysql nightmare, and just writing this thing in Erlang
00:59:45 <Cale> starngestLoop: That basically says that the machine code in that library file isn't the right kind for your machine.
00:59:48 <starngestLoop> hmmm
01:00:10 <starngestLoop> but I have successfully using my current mysql installation
01:00:21 <Cale> hmm
01:00:49 <Cale> (well, I guess it doesn't *quite* say that...)
01:01:13 <Cale> But that'd be my first guess as to what it means
01:01:34 <Cale> SOMEONE WITH A MAC HALP ;)
01:02:04 <Cale> I've only used Mac OS X a little bit
01:02:59 <starngestLoop> haha, Ive always had problems with Cabal on OSX
01:03:03 <starngestLoop> I guess this is to be expected
01:03:22 <starngestLoop> I guess I'll go crying back to Erlang
01:03:30 <Cale> Are you on x86_64?
01:03:33 <yitz> Cale: the gmp replacements can already be swapped in if your code doesn't do anything serious with Integer. They do basically work, and it allows you to compile a ghc that creates static binaries without worries about lpgl compliance for gmp.
01:03:34 <starngestLoop> yeah
01:03:42 <mroman> Cale: Yes @not practically feasible
01:03:56 <yitz> Cale: however, the preferred approach is now dynamic binaries.
01:03:57 <mroman> but still, that means that you have no guarantee over pure functions.
01:04:05 <Cale> starngestLoop: Yeah, it's OSX's linker being annoying
01:04:22 <mroman> Because their code is in Memory and you can modify them at runtime.
01:04:28 <mroman> Which kills referntial transparency.
01:04:32 <mroman> -typo
01:04:37 <Cale> hmmmm...
01:05:18 <yitz> starngestLoop: i've been ignoring those warnings for months now and not had any particular problems. which ghc do you have?
01:06:02 <starngestLoop> 7.0.4
01:06:12 <Cale> oh, did it actually build?
01:06:23 <Cale> Is it an error or a warning now? :)
01:06:32 <starngestLoop> it failed to build
01:06:41 <yitz> starngestLoop: i'm still using 7.0.2 from the platform
01:07:39 <yitz> starngestLoop: there are some serious changes going on in XCode that are giving both the GHC team and the platform team a lot of work to do.
01:07:42 <mroman> Pure functionaly languages are practically not possible (or can not have IO)
01:07:51 <starngestLoop> Im gonna try install x86_64 mysql
01:07:55 <mroman> haskell wiki afaik states something about that.
01:07:57 <starngestLoop> ah, I see
01:08:07 <mroman> You need flexible moral :)
01:08:18 <yitz> starngestLoop: looks like they're deprecating GCC altogether in XCode. Not sure which way we're going to go on that one.
01:08:26 <starngestLoop> wow
01:09:54 <starngestLoop> well, thanks for the help guys!
01:09:55 <yitz> either install gcc anyway and use it somehow, or get ghc to work with the native compiler.
01:10:11 <starngestLoop> I'll play with it a bit more
01:10:28 <starngestLoop> If I find a solution
01:10:29 <Cale> yitz: It just needs the system linker, doesn't it?
01:10:34 <starngestLoop> is there somewhere I can post it
01:10:39 <starngestLoop> to help others in the future?
01:10:48 <yitz> Cale: no i think it's deeper than that. e.g. ffi
01:10:56 <Cale> hmmm...
01:11:07 <Cale> It doesn't just get away with system object conventions there?
01:11:27 <yitz> apparently not, i'm not familiar with the details
01:11:29 <Cale> Oh, I suppose it inspects the .h files somehow :)
01:11:52 <Cale> starngestLoop: maybe on the HaskellWiki
01:12:28 <starngestLoop> cool
01:12:53 <Cale> starngestLoop: But it sounds like something temporary (at least I really hope so!)
01:13:08 <yitz> on windows we've managed to stick with gcc because anyway we need a whole posix-like environment, and that gives us gcc.
01:13:38 <yitz> other languages, like python etc., tend to go the route of supporting the native compiler.
01:13:42 <Cale> At iPwn, we're kinda going to need GHC to work well on Mac OS soonish. Currently we've moved all our development to Linux because it's more convenient.
01:14:32 <Cale> But at least compiling for the iPhone will be quite important to us.
01:15:27 <yitz> right so once cross-compiling works well that's at least one way out for mac os x :). not really what we're aiming for though.
01:17:51 <cwl> emptyTemplateState :: Control.Monad.IO.Class.MonadIO m => FilePath -> TemplateState m
01:18:15 <cwl> why it is different from http://hackage.haskell.org/packages/archive/heist/0.2.1/doc/html/Text-Templating-Heist.html
01:18:27 <cwl> emptyTemplateState
01:18:42 <Cale> which version of heist is installed?
01:18:46 <Cale> ghc-pkg list heist
01:19:32 <cwl> Cale: 0.5.3
01:19:46 <Cale> That's the documentation for 0.2.1
01:20:26 <Cale> http://hackage.haskell.org/packages/archive/heist/0.5.3/doc/html/Text-Templating-Heist.html#v:emptyTemplateState
01:20:40 <cwl> Cale: thanks
01:41:09 <hpaste> monads pasted “parser” at http://hpaste.org/53157
01:41:29 <momoneymonads> can anyone help me with my parser
01:41:40 <momoneymonads> i keep getting stuck in an infinite loop
01:42:18 <momoneymonads> ii know it's because sequence is calling statementP recursively
01:43:07 <quicksilver> it's called left-recursion
01:43:20 <quicksilver> the standard trick is to split statementP into two types
01:43:33 <quicksilver> "Statement" and "AtomicStatement"
01:43:48 <quicksilver> where Statement = Sequence | AtomicStatement
01:43:58 <quicksilver> AtomicStatement = Assign | Skip
01:44:11 <quicksilver> and, critically, sequences only contain AtomicStatements, not Statements.
01:45:02 <momoneymonads> i see...i thought sep by was giving me back a list of atomic statements
01:45:23 <quicksilver> you don't have a notion of atomic statement.
01:45:35 <quicksilver> I'm saying the parameter you give to 'sepBy' must not permit the sequence case
01:45:47 <quicksilver> so you have to split statement into two - one class which permits sequence and one which doesn't
01:45:56 <momoneymonads> aah, i see
01:47:14 <quicksilver> that breaks the recursion
01:47:41 <quicksilver> as a point of style, having to wrap everything in 'wsP' is annoying and that's why I normally do lexing in a separate step :)
01:47:51 <quicksilver> but perhaps you're following an exercise and that's how they do it.
01:48:05 <momoneymonads> yah actually the next step is do the lexing
01:49:17 <momoneymonads> so I need to separate sequence from StatementP
01:49:58 <quicksilver> yes, the normal terminology is StatementP and AtomicStatementP
01:50:02 <quicksilver> you don't have to do it that way though
01:51:28 <momoneymonads> atomicStatement P :: Parser Char Statement
01:51:50 <momoneymonads> atomicStatement P = choice [ assign,  skip ] where ....(what i had before)
01:53:54 <quicksilver> momoneymonads: yes
01:54:55 <hpaste> monads annotated “parser” with “parser (annotation)” at http://hpaste.org/53157#a53158
02:04:36 * hackagebot gloss 1.5.0.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.5.0.1 (BenLippmeier)
02:04:38 * hackagebot gloss-examples 1.5.0.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.5.0.1 (BenLippmeier)
02:04:40 * hackagebot gloss 1.5.0.2 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.5.0.2 (BenLippmeier)
02:10:57 <Phyx-> Hm, when using the Inline pragma, does that force GHC to always inline a function or just raise the possibility of that function being inlined. And does it make sense to inline somewhat large functions which are called once? I split them up just for readability
02:22:46 <Blkt> good morning everyone
02:23:13 <Phyx-> hello
02:23:19 <Peaker> howdy ho
02:23:47 <Blkt> :D
02:28:08 <Phyx-> Peaker: Hi Ranger Jo
02:29:37 * hackagebot zoom-cache 0.3.0.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.3.0.0 (ConradParker)
03:04:42 <pt114> what is the spine of a list in haskell?
03:06:12 <sipa> its contructors
03:06:24 <sipa> without the list value
03:06:56 <pt114> could you give an example to explain?
03:09:16 <pt114> if this is a list 1:2:3:[] = [1,2,3], what would be its spine?
03:09:24 <pt114> just the structure?
03:11:19 <Phyx-> pt114: yes
03:11:40 <pt114> and how would that structure look like?
03:11:56 <pt114> if i have xs = [1..10]
03:12:00 <Phyx-> like the constructors with no values..
03:12:04 <pt114> then i do length xs
03:12:08 <Phyx-> _:_:_:[]
03:12:16 <pt114> will that just evaluate the spine?
03:12:17 <pt114> right
03:12:49 <pt114> Ok now i see.
03:13:06 <sadgur> hi im trying to sort a list of lists by length in reverse can anyone help me, normal sort . reverse doesn't do this
03:13:14 <sadgur> length of sublist that is
03:13:20 <Phyx-> yes, length does not do anything with the elements of the list, so they are not evaluated, only the spine is forced during traversal
03:13:39 <sadgur> which approach is best to achieve what I require?
03:13:50 <pt114> Phyx- thanks
03:14:18 <pt114> Phyx- I have another question about strategies
03:15:34 <pt114> i have this program which i'm trying to parallelise using strategies. in the profiling i can see the sparks being creating but not sure what `dud` and `frizzle` mean
03:15:35 <Phyx-> sadgur: calculate the length of the lists, group them wth the lists themselves, sort by the length component, and then drop the length component should be an easy way to
03:15:55 <sadgur> alright i'll give it a go
03:16:37 <Phyx-> pt114: i've never used that
03:16:53 <Phyx-> sadgur: actually, would be simpler to use sortBy and passing a compare function that looks at the lenght
03:16:57 <Phyx-> :t sortBy
03:16:58 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:17:08 <Phyx-> :t on
03:17:10 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
03:17:20 <Phyx-> :t compare `on` length
03:17:21 <lambdabot> forall a. [a] -> [a] -> Ordering
03:17:30 <Phyx-> :t sortBy (compare `on` length)
03:17:31 <lambdabot> forall a. [[a]] -> [[a]]
03:17:40 <sadgur> sortBy (comparing length)
03:17:42 <sadgur> did it
03:17:44 <sadgur> thanks :)
03:24:56 * hackagebot http-enumerator 0.7.1.3 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.1.3 (MichaelSnoyman)
03:30:16 <Kaide> for any two stable sorts, is it true that sort1 . sort2 . sort1 == sort1 . sort2?
03:33:34 <koala_man> yes
03:34:13 <koala_man> a stable sort won't change a sorted list
03:44:56 * hackagebot remote 0.1 - Cloud Haskell  http://hackage.haskell.org/package/remote-0.1 (JeffEpstein)
03:45:13 <ion> Woot!
03:46:29 <gienah> that's neat, remote on hackage
03:50:56 <geheimdienst> we should do something about hackagebot ... it should only annouce things once the haddock is in place
03:58:33 <Phyx-> geheimdienst: but that would fail epicly if haddock fails. like it often does on new ghc versions
03:59:29 <geheimdienst> well, when the ghc run (haddock run) comes back negative, it could still make the announcement as it is now
04:02:55 <geheimdienst> so, where is the hackagebot source? can't seem to find it on hackage or by googling
04:07:01 <Saizan> @hackage rss2irc
04:07:02 <lambdabot> http://hackage.haskell.org/package/rss2irc
04:07:55 <geheimdienst> Saizan: thanks man, checking it out
04:10:07 <byorgey> oh, so you'd need to change the Hackage RSS feed if you wanted to change the timing
04:11:45 <Phyx-> heh, compiling with -Wall gave me a list so long my console's buffer couldn't keep it
04:13:40 <mux> building the Linux kernel? *grins*
04:14:06 <Phyx-> no, the module that does typechecking and discovery
04:14:07 <Phyx-> lol
04:18:23 <Phyx-> bleh, how can a 800 lines haskell file generate this many warnings
04:21:30 <Phyx-> lol, can't even tell if the list is getting smaller
04:22:26 <BleuM937> G'day :)
04:22:40 <Phyx-> hello
04:24:21 <BleuM937> I'm new here, so sorry if I'm doing it wrong; are there people here who have experience with Yesod?
04:28:49 <Kaide> BleuM937: There is a Yesod channel I think
04:28:56 <Kaide> not that you shouldn't ask here
04:29:02 <gienah> BleuM937: yes: #yesod
04:29:04 <Kaide> but that might be a better place to get a response
04:29:17 <BleuM937> @Kaide, @gienah, thanks, I just found it
04:29:17 <lambdabot> Unknown command, try @list
04:29:41 <Kaidelong> silly lambdabot
04:31:53 <geheimdienst> any information on the service that builds hackage packages and makes the build logs? can't find any clues in hackage-scripts, much less rss2irc
04:41:31 * dafis just tried to tab-complete the login password
04:41:53 <hpc> next time just copy-paste it from the username :P
04:42:06 * Phyx- has his password tied to his fingerprint scanner
04:42:31 <Phyx-> although getting a finger i assume is less work then beating the password out of someone
04:42:55 <dafis> hpc: login to my xsession, no copy-paste available yet
04:43:41 * Phyx- thinks HP does some funky things with the BIOS
04:44:17 <Phyx-> first time i'v seen a bio with user management
04:44:30 <Phyx-> that grabs the users and pass from your windows login
04:49:34 <geheimdienst> is this the mechanism that hackage uses today, or some other newer thing? http://community.haskell.org/~sboehme/
04:49:55 <geheimdienst> ("this mechanism" = a gsoc 07 project)
04:50:42 <hpc> geheimdienst: looks like the old hackage
04:51:16 <geheimdienst> hpc: hmm ... we're all using the "old hackage", right? hackage 2.0 is not ready yet
04:51:23 <geheimdienst> (right?)
04:55:26 * geheimdienst brb ...
05:10:15 <Phyx-> can you surpress a "Defined but not used" warning for a specific function?
05:12:32 <dafis> local or top-level?
05:13:19 <dafis> anyway, try calling it _function
05:14:52 <ibid> export it?
05:15:42 <Phyx-> dafis: top level
05:16:27 <Phyx-> dafis: yeah _ would work, but I just want to have it stay the way it is, not export it, but also not warn. It's just a useful function that I'll probably use in the future
05:16:30 <Phyx-> but not atm
05:16:45 <ibid> comment it out?
05:17:01 <dafis> Phyx-: comment out until needed?
05:17:20 <Phyx-> dafis: ah, why didn't I think of that
05:17:21 <Phyx-> -.-
05:17:24 <ibid> :)
05:17:39 <Phyx-> lol, thanks ibid, dafis
05:17:39 <dafis> Phyx-: ibid thought of that fastest
05:17:55 <ibid> dafis: no, i was just a faster typer :)
05:17:56 <Phyx-> yeah, i responded to you because of the hilight, afterwards I saw his
05:18:22 <ibid> (seems pointless to keep dead code active, which is what the warning is about)
05:19:03 <dafis> ibid: in this case, not yet completely born, rather than dead
05:19:19 <ibid> :)
05:19:42 <Phyx-> hehehe
05:19:57 <ibid> i assume you know that it's a technical phrase :)
05:22:22 <d-snp> hey, what does parseEnum do in this line:
05:22:22 <d-snp>     opcode <- BG.getAsWord8 4 >>= parseEnum
05:22:41 <d-snp> I wonder why it's not just: opcode <- BG.getAsWord8
05:23:14 <d-snp> I'm trying to understand this: http://www.haskell.org/haskellwiki/DealingWithBinaryData#The_BitGet_monad
05:27:58 <ibid> wwhich parseEnum is that?
05:28:47 <Botje> d-snp: at a guess i'd say parseEnum takes those bits and returns an Enum instance
05:28:54 <Botje> which you can then pattern match on later?
05:28:59 <d-snp> hmm
05:29:59 <d-snp> hmm I guess it will just parse any enum
05:30:05 <ibid> that doesn't make much sense to me
05:30:20 <ibid> and i can't find a parseEnum in the libraries that matches that usage
05:30:33 <d-snp> well, an enum is just a bunch of names for int values
05:31:13 <d-snp> hmm
05:31:30 <Botje> *which* specific Enum instance is probably defined my future uses of opcode
05:31:56 <d-snp> right
05:32:00 <dafis> d-snp: a Haskell Enum is quite different from a C enum
05:32:09 <d-snp> weird that they don't give an implementation of parseEnum though
05:32:36 <ibid> d-snp: as dafis says, that's not what Enum is in haskell
05:32:49 <d-snp> also, do you guys know why they have this r value, which is of Either?
05:32:55 <ibid> Enum is anything that you can convert from/to integers
05:33:16 <d-snp> well that's what enum is in C too right?
05:33:53 <ibid> no, in C an enum type is an integral type
05:34:01 <ibid> there's no conversion involved
05:34:15 <ibid> the enum constants are compile-time integral constants
05:34:17 <dafis> > fromEnum 'a'
05:34:18 <lambdabot>   97
05:34:33 <ibid> yeah, parseEnum sounds a lot like toEnum
05:34:41 <ibid> > toEnum 97 :: Char
05:34:42 <lambdabot>   'a'
05:35:08 <Botje> d-snp: parsing can fail. in which case you want to tell your caller /why/ you failed.
05:35:10 <ibid> perhaps it's not tested code and someone just misremembered the function name
05:36:13 <d-snp> hm ok, I finished implementing it, lets see if it works :P
05:42:32 <ben> > let x = read "[]" in (read x :: [Bool], read x :: [Int])
05:42:32 <lambdabot>   (*Exception: Prelude.read: no parse
05:44:15 <ben> :(
05:44:30 <ben> i'm dumb
05:44:48 <ben> > let x = "[]" in (read x :: [Bool], read x :: [Int])
05:44:49 <lambdabot>   ([],[])
05:45:05 <ben> > let x = read "[]" in (x :: [Bool], x :: [Int])
05:45:06 <lambdabot>   ([],[])
05:45:54 <schwadri> hi there. i have a problem. I'm trying to follow the "Real World Haskell" chapter on "Concurrent and Multicore Programming". There is an example to figure out the number of cores, which import's GHC.conc. When i try this ghc fails telling me: "parse error on input `Base.GHC.conc'". any ideas whats wrong?
05:46:06 <trez> oh, the last one does work for me, old version maybe
05:46:43 <schwadri> doh, must have been the lowercase :-(. sorry
05:47:28 <Ferdirand> ben: what ? how does that last one work ?
05:49:29 <ben> Well, [] is a list of anything, isn't it
05:51:16 <quicksilver> Ferdirand: x is bound polymorphically by "let"
05:51:29 <quicksilver> x gets the type x :: Read a => a
05:52:03 <quicksilver> > let x = read "[]" in (x :: [Bool], x :: [Int], x :: String, x :: Char)
05:52:05 <lambdabot>   ([],[],"",*Exception: Prelude.read: no parse
05:53:14 <ben> Why doesn't case bind polymorphically again?
05:55:13 <quicksilver> ben: because if it did, the universe would end
05:55:58 <quicksilver> ben: I think it's because of they way type inference works, but I'm not sure.
05:55:58 <d-snp> awesome it works! :D
05:56:25 <ben> I always thought let x = y in z was fairly similar to case y in ~x -> z but apparently not quite
05:56:30 <ibid> > case read "[]" of x -> (x :: [Bool], x [Int])
05:56:31 <lambdabot>   Not in scope: data constructor `Int'
05:56:37 <ibid> > case read "[]" of x -> (x :: [Bool], x :: [Int])
05:56:38 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:56:39 <lambdabot>         against inferred type ...
05:56:43 <ibid> yeah
05:57:04 <ibid> ben: fairly and not quite aren't contradictory :)
05:57:33 <ben> not quite as much as I thought, then :)
05:58:28 <quicksilver> ben: well in this *particular* case, haskell98/haskell2010 wouldn't bind the let polymorphically
05:58:33 <quicksilver> due to the DMR
05:58:38 <quicksilver> but you could give it a type sig.
05:58:42 <quicksilver> \bot has the DMR off.
06:00:33 <ben> I keep forgetting let x :: X ; x = ... isn't the same as let x = (... :: X)
06:01:33 <quicksilver> well, only because of the DMR which is widely depreciated
06:01:37 <Ferdirand> I didn't know let bindings could be polymorphic
06:01:49 <Ferdirand> what's its behavior with respect to sharing ?
06:02:01 <quicksilver> parametrically polymorphic things share fine
06:02:10 <ben> I didn't realise polymorphicness was a property of the binding rather than the bound value
06:02:11 <quicksilver> typeclass polymorphism does not share (in GHC at least)
06:02:22 <quicksilver> and that is preicsely the justification for the DMR
06:02:25 <quicksilver> (expectations of sharing)
06:03:07 <ibid> ben: in classic HM typing, generalization happens in a let binding and only there
06:03:19 <quicksilver> let x = [] in (x :: [Char], x :: [Bool]) is fine from the perspective of sharing, and the DMR doesn't apply to this case.
06:03:28 <quicksilver> although this is, of course, an implementation detail.
06:03:39 <Ferdirand> quite interesting. thanks quicksilver!
06:03:43 <quicksilver> in fact in GHC there may well only be one global [] used for all lists of all types.
06:03:48 <quicksilver> so all your lists are joined at the tail ;)
06:03:53 <Phyx-> what's DMR?
06:04:21 <Phyx-> for the life of me I can't think of what that acronym is
06:04:29 <ben> Dreaded...
06:04:29 <Ferdirand> dreadful monomorphism restriction ?
06:04:36 <Phyx-> ah
06:04:37 <Phyx-> lol
06:04:38 <ibid> damned?
06:04:42 <ben> Cripes, why doesn't it apply there? I thought the rule had to do with looking like functions or something.
06:04:46 <ibid> difficult?
06:04:53 <ibid> domineering?
06:04:53 <Ferdirand> dubious?
06:04:56 <ibid> :-)
06:05:09 <Phyx-> rofl.. so for the few weeks i've been away MR has gotten more infamous huh
06:05:32 <ibid> it was infamous even when i learned haskell
06:05:36 <ibid> a long time ago
06:05:46 <ben> I actually thought it had been dropped in Haskell 2010
06:07:57 <ibid> ben: getting back to your question about the difference between case and let, it's because of the way Hindley-Milner typing works: single-binding let is dynamically just a case, but statically it's the only place where a value is generalized (turned from monomorphic to polymorphic).  iirc in strict languages like ML this causes other problems :)
06:08:52 <ibid> well, actually, single-binding let is dynamically just a beta redex.  case ... of x -> ... is syntactic sugar in itself
06:09:15 <ben> ibid: That's fairly arbitrary, or maybe historical, in haskell, isn't it?
06:09:27 <ibid> ben: historical more like
06:10:04 <ibid> ben: in classic HM, it's done that way to keep type inference decidable
06:10:37 <ibid> ben: and originally haskell was just HM plus very simple type classes (iirc)
06:10:52 <ibid> (they didn't even have enough oomph to express Monad:)
06:10:53 <ben> That seems fairly long ago :)
06:11:07 <ibid> well, HM dates back to the 1970s
06:11:09 <geheimdienst> i hated the DMR before it was cool
06:12:03 <ibid> ben: i suppose you could make variable bindings in case be generalization points as syntactic sugar
06:13:00 <hpaste> petekaz pasted “Laziness question and IO” at http://hpaste.org/53160
06:14:35 <petekaz> newbie question: can I count on laziness for this piece of code to work? I have a test for file existence and then I follow that (without checking the result of the existence) with a stat on the file. Then I have an if where I check "exists && age < 10", if exists is false, age should not be evaluated right?
06:14:50 <mauke> petekaz: correct but irrelevant
06:15:03 <mauke> you won't even get to the check if fileAge blows up
06:15:11 <petekaz> right.
06:15:13 <petekaz> but why?
06:15:29 <mauke> because that's how >>= works in IO
06:15:31 <ibid> petekaz: IO is not lazy unless explicitly asked
06:15:36 <petekaz> is fileAge just a promise to do something?
06:15:41 <petekaz> okay.
06:15:58 <petekaz> So no laziness in IO monad except for those lazy IO operations.
06:16:07 <mauke> fileAge is a function that takes a filename and returns an action, it seems
06:16:30 <mauke> and when that action is executed, it gets the age of that file
06:16:30 <petekaz> oh, sorry, yes.  String -> IO Integer
06:16:36 <mauke> right
06:16:56 <quicksilver> deferred execution of IO actions is not something which should be called 'laziness' IMO
06:17:05 <quicksilver> all the ideas have a similarly they have important differences
06:17:18 <mauke> parse error
06:17:24 <quicksilver> the point about laziness is that with pure evaluation it doesn't matter when things get evaluated.
06:17:30 <quicksilver> s/all/although/;
06:17:37 <quicksilver> what a mess
06:17:39 * quicksilver rewrites.
06:17:43 <mauke> s/similarly/similarity, /
06:17:53 <quicksilver> althought the ideas have a similar feel, they have important differences.
06:18:05 <quicksilver> ok, typos remain but that's better :)
06:18:10 <ben> the point here seems to be that IO operations are ordered and executed by the invisible semicolons here more so than when the thunks pointing at their results get evaluated?
06:19:42 <ibid> ben: true
06:20:02 * hackagebot numeric-tools 0.2.0.0 - Collection of numerical tools for integration, differentiation etc.  http://hackage.haskell.org/package/numeric-tools-0.2.0.0 (AlexeyKhudyakov)
06:20:04 <ibid> there's an unsafe way to defer an IO action until the thunk is forced
06:20:18 <ibid> but i probably should not have mentioned even that much :-P
06:20:39 <ibid> (it's what getContents and friends use)
06:20:57 <petekaz> Even if 'age <- fileAge cache' was just a promise (and I know it isn't now thanks to you guys), I guess even after the test, once you hit the next IO action, it would have to evaluate that promise due to the ordering of IO actions otherwise it would just be a giant mess.
06:21:03 * quicksilver has no objection to it being mentioned, just thinks that "laziness" is potentially a confusing word for deferred execution.
06:21:17 <quicksilver> I tend to call it 'interleaved IO'.
06:21:52 <ibid> petekaz: fileAge cache by itself is a promise (usually called an action in haskell).  but when you use it in do, it's forced
06:22:32 <petekaz> ibid: but is that the case for all monads? or just IO?
06:22:38 <yitz> quicksilver: that's very true. i think using "laziness" for that comes from the fact that one use case is to control IO using laziness of a pure function
06:23:16 <ibid> petekaz: it's true for IO and some other monads.  in some other monads it's close to meaningless
06:23:44 <mauke> petekaz: what does that question even mean for e.g. []?
06:24:19 <ibid> exactly
06:24:34 <ibid> i was thinking of Id myself, but any monad with no carried state would do
06:24:40 <quicksilver> well if you want to stretch words, then ["foo","bar","baz"] is a "promise" to give you at a later date one of foo, bar or baz, without specifying which.
06:24:52 <quicksilver> but that analogy only stretches a little.
06:25:15 <ibid> point
06:25:48 <yitz> petekaz: pure monads have the same kinds of laziness or strictness properties of >>= and return as any other functions. nothing special. IO is weird though.
06:26:18 <mauke> not that weird
06:27:07 <yitz> mauke: weirdness is measured on differing scales in different contexts
06:27:41 <ibid> it's also subjective
06:27:45 <mauke> http://i.imgur.com/7a2Ax.jpg #nsfw
06:27:49 * ibid must now run, bbl
06:29:37 <yitz> mauke: in IO, the question of when side effects happens is separate from the question of the strictness of >>= and return
06:29:57 <mauke> yes
06:31:08 <hpaste> petekaz annotated “Laziness question and IO” with “Laziness question and IO (annotation)” at http://hpaste.org/53160#a53161
06:31:35 <petekaz> is there a way to make the revised version nicer looking? more haskelly?
06:31:54 <mauke> why check existence at all?
06:32:35 <petekaz> Because fileAge does a getModificationTime and it fails if the file does not exist.
06:32:48 <mauke> this is like: if k `M.member` m then foo (m M.! k) ...
06:33:03 <mauke> petekaz: so it already checks for you
06:34:11 <petekaz> I'm not up to the chapter or how to test if the IO action fails :-)
06:34:28 <petekaz> is this where bracketOnError comes in?
06:34:44 <mauke> no, much simpler
06:35:02 <mauke> in fact, you could make fileAge return IO (Maybe Integer)
06:36:12 <petekaz> Right, that would seem more appropriate.
06:36:12 <mauke> petekaz: how do you compute the Integer?
06:36:20 <petekaz> Let me paste it ...
06:36:50 <hpaste> petekaz annotated “Laziness question and IO” with “Laziness question and IO (annotation) (annotation)” at http://hpaste.org/53160#a53162
06:37:46 <petekaz> It's the getModificationTime part that fails when the file doesn't exist.
06:39:06 <petekaz> I'm sure I'm getting ahead of myself. Just reading the learn you a haskell and playing around with a small script for practice.
06:40:19 <hpaste> mauke annotated “Laziness question and IO” with “Laziness question and IO (annotation) (annotation) (annotation)” at http://hpaste.org/53160#a53164
06:41:58 <petekaz> Great! Thanks. So catch is the secret sauce that I hadn't read about yet.
06:42:02 <bfig> what is a common recursive three-constructor datatype?
06:42:24 <quicksilver> i don't think there are many really common ones
06:42:27 <yitz> bfig: Node
06:42:30 <quicksilver> Stream has three types I think
06:42:38 <quicksilver> s/types/constructors
06:42:51 <bfig> yitz, what is a Node?
06:43:01 <yitz> ah two constructors
06:43:13 <yitz> @hoogle Node
06:43:14 <lambdabot> Data.Tree Node :: a -> Forest a -> Tree a
06:43:15 <lambdabot> Test.HUnit.Base data Node
06:43:15 <lambdabot> Data.Graph.Inductive.Graph type Node = Int
06:43:31 <bfig> Forest a == [Tree a] ?
06:43:37 <yitz> yes
06:44:22 <Phyx-> @src Tree
06:44:23 <lambdabot> Source not found. :(
06:44:39 <Phyx-> :t
06:44:41 <yitz> Result
06:44:49 <yitz> @hoogle Result
06:44:50 <lambdabot> Network.Stream type Result a = Either ConnError a
06:44:50 <lambdabot> Test.QuickCheck data Result
06:44:50 <lambdabot> Test.QuickCheck Result :: Maybe Bool -> [String] -> [String] -> Result
06:44:57 <yitz> oh no
06:45:05 <yitz> i'm thinking of attoparsec's Result
06:45:17 <yitz> it can be Done, Fail, or Continue
06:46:10 <Melvar`> > let o = 1 in ο
06:46:10 <lambdabot>   Not in scope: `
06:46:13 <yitz> same for a number of types in various other continuation-based libraries
06:46:38 <yitz> like iteratee libraries
06:47:13 <Phyx-> :t (o.O)
06:47:15 <lambdabot> Not in scope: data constructor `O'
06:47:16 <yitz> > let ο = 1 in ο
06:47:17 <lambdabot>   1
06:48:17 <mauke> > let ο = 1 in ο
06:48:18 <lambdabot>   1
06:48:25 <mauke> > let ο = 1; o = 2 in ο + o
06:48:26 <lambdabot>   3
06:48:32 <Phyx`> > let o = l in o
06:48:33 <lambdabot>   l
06:48:39 <yitz> > ο
06:48:40 <lambdabot>   Not in scope: `
06:48:45 <mauke> > let ο = l; o = 2 in ο + o
06:48:45 <lambdabot>   l + 2
06:49:14 <yitz> > l
06:49:16 <lambdabot>   l
06:49:25 <yitz> > l == 1
06:49:27 <lambdabot>   False
06:49:48 <Melvar`> @type l
06:49:49 <lambdabot> Expr
06:50:36 <khs> hi, what does [(x , y)] match? what is in x and y?
06:50:55 <mauke> khs: a list with a single element that is a pair whose first component is x
06:51:09 <yitz> khs: it is a list of tuples where the elements are any types
06:51:26 <byorgey> um.
06:51:31 <yitz> khs: all first elements are the same type, and all second elements are the same type
06:51:37 <byorgey> khs: is [(x,y)] a pattern or a type?
06:51:43 <khs> a pattern
06:51:49 <Melvar`> let o = 1; ο = 2; о = 4 in o .|. ο .|. о
06:51:51 <yitz> ohhh
06:51:52 <byorgey> then pay attention to mauke and ignore yitz.
06:51:53 <Melvar`> > let o = 1; ο = 2; о = 4 in o .|. ο .|. о
06:51:54 <lambdabot>   Ambiguous type variable `a' in the constraint:
06:51:55 <lambdabot>    `Data.Bits.Bits a'
06:51:55 <lambdabot>      a...
06:51:58 <yitz> haha
06:52:14 <Melvar`> > let o = 1; ο = 2; о = 4 in o .|. ο .|. о :: Int
06:52:15 <lambdabot>   7
06:52:46 <yitz> khs: mauke is also right if its an expression
06:53:11 <Phyx-> 16:05:51 < byorgey> then pay attention to mauke and ignore yitz. <- hahaha
06:53:12 <khs> just to be sure... this is the code: vdefgJS (Hs.Rec [(name, expr)]) =
06:53:43 <mauke> > let o = 1; ο = length [o,о]; о = 4 in o .|. ο .|. о
06:53:44 <lambdabot>   7
06:55:49 <Phyx-> holy.... using hlint on my file just flooded me with suggestions
06:55:49 <Phyx-> lol
06:56:02 <byorgey> khs: yes, that matches a value with a Hs.Rec constructor, which contains a single-element list
06:56:14 <byorgey> and the single element in that list is a pair
06:56:33 <dafis> Phyx-: you can configure it so it doesn't
06:56:41 <mauke> Rec ((:) ((,) name expr) [])
06:56:50 <dafis> otoh, then why use it at all?
06:57:17 <cwl> getTemplateFilePath
06:57:31 <cwl> heist
06:57:53 <cwl> what is it in 0.5.3?
06:58:53 <Phyx-> dafis: i'm just taking a look it's suggestions
06:58:56 <Phyx-> some are good
06:59:01 <Phyx-> others, meh
06:59:24 <Melvar`> > let ʻ ’ ʼ = [ʻ,ʼ] in 'ʻ'’'ʼ'
06:59:25 <lambdabot>   <no location info>: lexical error at character '\699'
06:59:38 <mightybyte> cwl: It didn't exist in 0.5.3
07:00:20 <Melvar`> Wait, what?
07:00:47 <Melvar`> > let (’) = (+) in 1 ’ 1
07:00:48 <lambdabot>   <no location info>: lexical error at character '\8217'
07:01:08 <Melvar`> > ‘a’
07:01:09 <lambdabot>   <no location info>: lexical error at character '\8216'
07:01:16 <khs> anyone has an example for a recursive value definition in haskell code?
07:01:26 <mux> > let ones = 1 : ones in ones
07:01:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:01:46 <mux> how's that?
07:01:54 <khs> great
07:02:47 <byorgey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs  -- khs, another fun one
07:02:48 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:03:54 <Melvar`> Why does ’ cause a lexical error?
07:04:04 <mauke> Melvar`: what else would it do?
07:04:57 <cwl> mightybyte: what is the equivalent in 0.5.3
07:05:05 <byorgey> Melvar`: there is a small finite list of characters which may be used in operator names
07:05:52 <yitz> > let (’) = mod in 42 ’ 13
07:05:53 <lambdabot>   <no location info>: lexical error at character '\8217'
07:06:09 <mauke> yitz: <Melvar`> > let (’) = (+) in 1 ’ 1
07:06:25 <Melvar`> > let (☺) = (*) in 2 ☺ 2
07:06:26 <lambdabot>   4
07:06:36 <mightybyte> cwl: There was none
07:06:59 <cwl> mightybyte: http://www.nadineloveshenry.com/haskell/heistTutorial.html
07:07:14 <khs> so matching [(x, y)] is the same as matching (x, y):[] ?
07:07:25 <dafis> khs: precisely
07:07:28 <mauke> [x] is the same as x : []
07:07:39 <cwl> compile error for getTemplateFilePath not found
07:07:54 <mauke> > 1 : (2 : (3 : []))
07:07:55 <lambdabot>   [1,2,3]
07:07:57 <mightybyte> cwl: Yeah, apparently he was using the github version of Heist.
07:08:12 <cwl> mightybyte: how do you know?
07:08:22 <mightybyte> Because that's the only explanation.
07:08:28 <bartavelle> noobish question : what does the ':' operator ?
07:08:41 <mightybyte> cwl: https://github.com/snapframework/heist/commit/8b8083a6be1882650161dd54ef916e67d7ac190e#L2R336
07:08:51 <cwl> (+CLcnpt)]
07:08:51 <cwl> [#haskell]
07:08:51 <byorgey> Melvar`: actually, I am wrong: operators can contain any unicode symbol or punctuation
07:08:52 <Melvar`> > let (¡) = (+) in 1 ¡ 1
07:08:52 <lambdabot>   2
07:09:08 <byorgey> so I don't know why ’ does not work
07:09:26 <Melvar`> > let (‘) = (+) in 1 ’ 1
07:09:27 <lambdabot>   <no location info>: lexical error at character '\8216'
07:09:29 <dafis> byorgey: Prelude Data.Char> generalCategory ''
07:09:29 <dafis> FinalQuote
07:09:37 <mauke> > generalCategory '’'
07:09:38 <lambdabot>   FinalQuote
07:09:44 <byorgey> aha
07:09:49 <yitz> Melvar`: you're right, according the Report that's a bug in ghc
07:09:50 <mauke> bartavelle: it's a constructor, part of the definition of []
07:10:04 <byorgey> bartavelle: it constructs a list out of an element and another list
07:10:06 <bartavelle> ok
07:10:13 <Melvar`> Have they reserved quotes of all kinds for literals?
07:10:13 <byorgey> > 3 : []
07:10:14 <lambdabot>   [3]
07:10:18 <byorgey> > 4 : [3]
07:10:18 <lambdabot>   [4,3]
07:10:20 <bartavelle> that explains the (x:xs) match
07:10:34 <yitz> because ’ is a unicode symbol, and not one of the finite list of special ascii symbols excluded in the Report
07:10:48 <byorgey> bartavelle: right, matching a list with (x:xs) means x will be the first element of the list and xs will be the rest
07:11:04 <Melvar`> > let (‘) = (+) in 1 ‘ 1
07:11:05 <lambdabot>   <no location info>: lexical error at character '\8216'
07:11:31 <Melvar`> > let (‚) = (+) in 1 ‚ 1
07:11:32 <lambdabot>   <no location info>: lexical error at character '\8218'
07:11:42 <byorgey> what is the definition of a "Unicode symbol"?
07:12:07 <Melvar`> > generalCategory '☺'
07:12:08 <lambdabot>   OtherSymbol
07:12:18 <yitz> byorgey: uniSymbol→ any Unicode symbol or punctuation
07:12:20 <mauke> Melvar`: (,) is a reserved operator
07:12:29 <khs> How about this: " data Bind b = NonRec b (Expr b) | Rec [(b, Expr b)] " the Rec data constructor can have a list with more than one tuple?
07:12:30 <yitz> byorgey: (quoted from the 2010 report)
07:12:45 <Melvar`> > ord '‚'
07:12:45 <lambdabot>   8218
07:12:48 <byorgey> yitz: yes, I see that production, I was wondering what the technical meaning of "Unicode symbol" on the RHS is
07:12:51 <Melvar`> > ord ','
07:12:52 <lambdabot>   44
07:13:16 <byorgey> > generalCategory '¡'
07:13:17 <lambdabot>   OtherPunctuation
07:13:17 <mauke> byorgey: unicode has character categories such as letter, number, mark, punctuation, symbol, ...
07:13:36 <byorgey> > generalCategory '☺'
07:13:37 <lambdabot>   OtherSymbol
07:13:53 <byorgey> right, so ’ is not a Unicode symbol
07:14:05 <byorgey> so this is not a bug in GHC.
07:14:08 <mauke> right, it's unicode punctuation
07:14:42 <mauke> khs: in types, [x] means "list of x"
07:15:14 <khs> mauke: ok, thanks
07:15:42 <mauke> 1 : (2 : []) :: [Int]
07:15:42 <byorgey> khs: a bit confusing at first, that [foo] means something different when it's a type vs. when it's an expression or pattern
07:16:14 <Melvar`> > let ʻ ′ ʼ = [ʻ,ʼ] in 'ʻ'′'ʼ'
07:16:15 <lambdabot>   <no location info>: lexical error at character '\699'
07:17:11 <Melvar`> > chr 699
07:17:12 <lambdabot>   '\699'
07:17:22 <Melvar`> How unuseful.
07:17:54 <Melvar`> > putStrLn (chr 699 : [])
07:17:55 <mauke> > generalCategory '\699'
07:17:55 <lambdabot>   <IO ()>
07:17:56 <lambdabot>   ModifierLetter
07:18:10 <mauke> Melvar`: that's a funny way to write "\699"
07:18:42 <dafis> > filter isPunctuation [minBound .. maxBound]
07:18:44 <lambdabot>   "!\"#%&'()*,-./:;?@[\\]_{}\161\171\183\187\191\894\903\1370\1371\1372\1373\...
07:19:06 <mauke> > text $ filter isPunctuation [minBound .. maxBound]
07:19:07 <lambdabot>   !"#%&'()*,-./:;?@[\]_{}
07:19:10 <yitz> no the report says symbol or punctuation so this is a bug
07:19:16 <dafis> > text $ filter isPunctuation ['\8200' .. maxBound]
07:19:18 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:19:50 <dafis> > length $ filter isPunctuation [minBound .. maxBound]
07:19:51 <lambdabot>   510
07:19:54 <yitz> byorgey: no the report says symbol or punctuation so this is a bug
07:20:31 <dafis> yitz: it doesn't consider '\8216' etc. punctuation
07:20:35 <yitz> > generalCategory '\8216'
07:20:36 <lambdabot>   InitialQuote
07:21:56 <byorgey> > isPunctuation '\8216'
07:21:57 <lambdabot>   True
07:22:08 <Melvar`> The category is actually “Punctuation, Opening Quote” or something like that so it is Punctuation.
07:22:14 <byorgey> yitz seems to be correct.
07:23:06 <JoeyA> If I want to lex ByteString input and feed the resulting tokens into a Parsec parser, what's a good lexer to use?
07:23:09 <yitz> byorgey: see table 4-9 on p. 127 of Unicode V6.
07:23:40 <bartavelle> JoeyA, you can use parsec too
07:23:52 <bartavelle> that's what I do, but I'm not sure I am a reference
07:24:03 <yitz> byorgey: however, the report should be changed to exclude all characters with property "Punctuation, initial quote" and "Punctuation, final quote".
07:24:49 <clsmith> imo any element in "Punctuation, Open" should be able to be paired with "Punctuation, Close" to form a new type or kind. so we could have a type {:} for hash tables, etc :p
07:24:56 <clsmith> {a:b} even
07:25:33 <Melvar`> > generalCategory '“'
07:25:34 <lambdabot>   InitialQuote
07:25:40 <Melvar`> > generalCategory '„'
07:25:41 <lambdabot>   OpenPunctuation
07:25:51 <Melvar`> Wat.
07:25:55 <geheimdienst> > generalCategoryTheory "lolcats"
07:25:56 <lambdabot>   Not in scope: `generalCategoryTheory'
07:25:59 <geheimdienst> bummer
07:26:20 <yitz> > fromEnum '„'
07:26:21 <lambdabot>   8222
07:26:28 <mauke> > '„'
07:26:29 <lambdabot>   '\8222'
07:26:35 <yitz> > text "\8223"
07:26:36 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:26:50 <yitz> > text "\8222"
07:26:52 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:27:16 <byorgey> geheimdienst: lolcats are an object in CAT, the category of all cats.
07:27:16 <yitz> > text ['\8222']
07:27:18 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:27:30 <mauke> yitz: you can stop now, thanks
07:27:31 <yitz> > text [toEnum 8222]
07:27:32 <geheimdienst> > init $ drop 2 $ show '„'
07:27:33 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:27:33 <lambdabot>   "8222"
07:27:44 <yitz> > text [toEnum 8222 :: Char]
07:27:46 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:27:48 <yitz> hmm
07:27:49 --- mode: ChanServ set +o mauke
07:27:49 --- mode: mauke set +q $a:yitz
07:28:00 <geheimdienst> yitz, please use a private lambdabot window
07:28:09 <Melvar`> > ο
07:28:10 <lambdabot>   Not in scope: `
07:28:19 <mauke> Melvar`: you too
07:28:26 <geheimdienst> mauke, i think that was a little much. i think he got the message
07:28:35 <saati> what is +q $a: ?
07:28:39 <Melvar`> It seems lambdabot fails to print non-latin1 characters.
07:28:40 --- mode: mauke set -o mauke
07:30:46 --- mode: ChanServ set +o mauke
07:30:46 --- mode: mauke set -q $a:yitz
07:31:36 --- mode: mauke set -o mauke
07:36:52 <saati> :t text
07:36:54 <lambdabot> String -> Doc
07:37:29 <yitz> Melvar`: can you please type the oposite character to „ and check its generalCategory?
07:37:44 <saati> which text is this? pretty Text.PrettyPrint.HughesPJ this one?
07:37:46 <mauke> > generalCategory '“'
07:37:47 <lambdabot>   InitialQuote
07:37:58 <yitz> the bottom onw
07:37:59 <yitz> one
07:38:04 <mauke> yitz: huh?
07:38:16 <yitz> oh it was geheimdienst
07:39:27 <yitz> no Melvar`, who left. a bottom thing „ looks like a close quote had type  OpenPunctuation.
07:40:10 <yitz> does its oposite say ClosePunctuation?
07:40:29 <yitz> guessing its either \8223 or \8221
07:41:01 <mauke> Melvar` used „. its opposite has type InitialQuote, as demonstrated
07:42:06 <yitz> mauke: the one you did? it looks the same as „
07:43:00 <yitz> anyway. it seems that this should be reported to the haskell prime committee, not the ghc team.
07:43:36 <mauke> how does „ look the same as “?
07:44:13 <yitz> mauke: oh. but that one's on top.
07:44:28 <mauke> ... yes?
07:44:47 <yitz> isn't there a character facing the other way on the bottom?
07:45:07 <mauke> dunno
07:46:55 <mauke> if it exists, it isn't used anywhere
07:55:08 <bfig_> i'm still having trouble understanding what In is supposed to mean... you have a list L, what does 'In L' do?
07:55:27 <Abraxas> is foldl to foldr conversion one of the easier things in haskell to understand?
07:55:55 <mauke> Abraxas: no
07:56:15 <Abraxas> so if i fail to understand not all hope is lost?
07:56:37 <mauke> just ignore it
07:56:43 <mauke> bfig_: what is In?
07:56:59 <Philonous> Is it expected for an xml file of 400kb to blow up to 40mb after parsing? (That's a whopping 100-fold increase)
07:57:28 <bfig_> mauke,  In : F (muF) -> muF a sort of constructor/transformer
07:57:41 <mauke> bfig_: what's that?
07:57:47 <Abraxas> even with that - i suppose - great explanation on stackoverflow i don't get it
07:57:57 <mauke> Philonous: no, parsing isn't supposed to modify files
07:58:00 <Abraxas> ignore it?
07:58:33 <Abraxas> i mean this one: http://stackoverflow.com/questions/6172004/writing-foldl-using-foldr
07:58:55 <Philonous> mauke:  Ah, no, I meant the parsed representation (in memory) being 100 times as large as the original data
08:00:42 <Abraxas> already don't understand this part: "foldr (\b g x"
08:00:44 <bfig_> mauke, you have endofunctor F: muF -> muF, initial algebra (muF, in)...
08:00:51 <Abraxas> why three arguments
08:01:20 <mauke> Abraxas: because they're folding into functions
08:01:35 <mauke> Abraxas: do you know that \x y z -> ... is the same as \x -> \y -> \z -> ...?
08:01:47 <Abraxas> yes
08:02:29 <Abraxas> but foldr takes a (a->b->b) function
08:02:38 <mauke> Abraxas: every function takes exactly one argument
08:02:53 <Abraxas> yeah
08:02:54 <dafis> Abraxas: try replacing the (\b g x -> ...) with (\b g -> (\x -> ...))
08:02:55 <mauke> foldr takes (a -> (b -> b))
08:03:04 <mauke> set b = c -> d
08:03:18 <mauke> now it's (a -> (c -> d) -> c -> d)
08:03:46 <ski> > seq ((\False _ -> ()) True) ()
08:03:47 <ski> > seq ((\False -> \_ -> ()) True) ()
08:03:47 <lambdabot>   ()
08:03:49 <lambdabot>   *Exception: <interactive>:3:6-23: Non-exhaustive patterns in lambda
08:04:10 <yrlnry> mauke:  http://blog.plover.com/prog/springschool95-2.html is an article I wrote a while back about   In : F (muF) -> muF a sort o
08:05:16 <Philonous> What is the expected memory overhead of Strings compared to (strict) ByteStrings?
08:05:50 <copumpkin> Philonous: huge
08:06:01 <copumpkin> Philonous: they're also doing different things, so I wouldn't compare them directly
08:06:11 <copumpkin> as in, one stores unicode code points, the other stores bytes
08:06:24 <copumpkin> a string on a 64-bit machine will probably eat 24 bytes per character
08:06:29 <copumpkin> or something around there
08:08:35 <Philonous> copumpkin:  Oh dear. That is much worse than I expected. And it basically means Strings are out of the question for even mediocre amounts of data. Too bad the xml library uses Strings as an internal representation.
08:08:52 <yitz> > let a’ = 5 in a’
08:08:53 <lambdabot>   <no location info>: lexical error at character '\8217'
08:09:07 <copumpkin> on the other hand, they can be streamed and garbage collected as you go along
08:09:14 <copumpkin> but yeah
08:09:18 <copumpkin> they aren't designed for data
08:09:32 <copumpkin> they're designed for simplicity or smallish human text :P
08:09:40 <stepkut> copumpkin: they are designed for unlimited RAM!
08:09:41 <copumpkin> if you want largeish human text, go with the text library
08:09:50 <copumpkin> if you want largeish binary data, go with the bytestring library
08:10:01 <Philonous> stepkut:  And unlimited throughput / processing power
08:10:05 <mkscrg> haddock question: is there a way to link to another module's documentation? so, rather than 'Data.ByteString.ByteString' (the datatype), just 'Data.ByteString' (the module)?
08:10:07 <stepkut> Philonous: yeah
08:10:25 <mkscrg> when i try that, i just get unformatted monospace text
08:10:34 <mkscrg> *unlinked
08:10:59 <Abraxas> this i would get: (a -> b -> (b -> b))...but with (a->b->b), looking at \b g x -> the function consumed b and g and is waiting for x, although that should be type b and not a function...what am i missing?
08:11:11 <dafis> mkscrg: "Data.ByteString"
08:11:22 <mauke> Abraxas: the type b is a function
08:12:15 <mkscrg> dafis: thanks. not sure how i missed that in the docs
08:12:44 <dmwit> (a type variable can be replaced with any type -- including a function type!)
08:13:20 <mauke> Abraxas: want to hurt your brain on something simple first?
08:13:28 <mauke> Abraxas: what's the type of 'flip id' and why?
08:16:09 <Abraxas> ok, so that is simple :D
08:16:22 <Abraxas> that's bad news for me
08:16:39 <bfig_> yrlnry, hey, i just read your blog, can i ask you a question?
08:16:50 <mauke> Abraxas: it's "simple" in that the code is just two identifiers
08:17:00 <mauke> well, two standard functions
08:17:10 <mauke> each of which looks simple in isolation
08:17:22 <yrlnry> bfig_:  please
08:17:23 <mauke> I did say it may hurt your brain :-)
08:17:35 <Abraxas> and i never worked with flip
08:17:38 <Abraxas> ;)
08:17:43 <bfig_> yrlnry, so what does the In constructor do?
08:18:14 <mauke> @src flip
08:18:14 <lambdabot> flip f x y = f y x
08:18:21 <yrlnry> What do you mean, what does it "do"?  It's just a constructor.
08:18:25 <Athas> Most wrappers around C libraries require you to do your own manual allocation, but using weak pointers and some other tricks, you can make it automatic.  Why do so few Haskell libraries do this?
08:18:28 <bfig_> i've read too many papers without understanding what this means, i just look at it and i can't make any sense out of it's existence. i know it performs a sort of unwrapping step
08:18:32 <Athas> More to the point, why are so many FFI wraps so thin?
08:18:38 <shachaf> bfig_: It doesn't do anything at all.
08:18:46 <bfig_> fuuuu....
08:18:50 <darrint> At the risk of being a jerk, I'm looking for an elaboration or second opinion on this answer I got on haskell-beginners: http://www.haskell.org/pipermail/beginners/2011-October/008832.html
08:18:50 <shachaf> bfig_: It's just a cosntructor. What does "Just" do? What does "Identity" do?
08:18:53 <mauke> bfig_: it's a constructor
08:18:55 <yrlnry> Yeah, it really doesn't do anything.
08:19:20 <dmwit> bfig_: The "In" constructor marks the places where we're converting between the unwrapped type "f (Mu f)" and the wrapped type "Mu f".
08:19:21 <Philonous> Is there a clever way to find out which part of a leaking program is holding on to data that should actually be disposed of?
08:20:00 <shachaf> bfig_: Look at value-level "fix" and then notice that it's exactly the same thing, except that since it's a newtype, you need a constructor.
08:20:01 <yrlnry> bfig_:  consider this:   data MyInt = My Int.   Then you can write   My 3 and get a MyInt.  What's 'My' doing?
08:20:02 <dmwit> bfig_: The two types are "equal" in a sense -- that is, "Mu f" is conceptually the infinite unwrapping "f (f (f ...))". But making them actually equal is Bad For Decidability. So instead we make the isomorphic.
08:20:29 <dmwit> bfig_: The "Mu" constructor (and the projection function "unMu" or whatever it's called in yrlnry's blog post) witness the isomorphism.
08:21:02 <bfig_> so the categorical In is a sort of 'inverse functor' ?
08:21:08 <Abraxas> the foldl to foldr is a task, i could just c/p it, but i wanted to understand it, hence not "ignoring" it ;)
08:21:25 <Abraxas> i guess the flip thing will help with that?
08:21:29 <ClaudiusMaximus> Philonous: heap profiling   +RTS -hT  doesn't need recompilation (apart from maybe adding -rtsopts) and shows which datatypes are consuming most memory; other -h options are available when compiled with -prof, see +RTS -? for details
08:22:13 <bfig_> i don't understand, F A ~ A, through In but when you use it you're not.. fuck, now it makes sense (at least a little more sense)
08:23:11 <dmwit> bfig_: Oh, sorry, I used "Mu" a few times when I meant "In" in my explanation.
08:23:27 <yrlnry> It took me a long time to understand it, as that blog article attests.
08:23:39 <dmwit> (I'm used to newtype Mu f = Mu (f (Mu f)), where both the constructor and the type are named "Mu".)
08:23:46 <shachaf> bfig_: Do you understand "newtype Blah = MkBlah (Maybe Blah)"?
08:24:52 <geheimdienst> "The Control.Monad.Error module in the mtl package makes 'Either String' into a monad as well" sez rwh. why String and not a? maybe i'd like to indicate an error using a c-style errno, or something
08:25:14 <shachaf> geheimdienst: I think it has to do with "fail".
08:25:21 * hackagebot HasGP 0.1 - A Haskell library for inference using Gaussian processes  http://hackage.haskell.org/package/HasGP-0.1 (SeanHolden)
08:25:30 <bfig_> shachaf, is that the isomorphic to the integers?
08:25:35 <shachaf> geheimdienst: There's an instance Monad (Either e) in Control.Monad.Instances.
08:25:38 <shachaf> bfig_: Naturals.
08:25:42 <bfig_> err naturals :)
08:26:02 <shachaf> geheimdienst: (Which can also be used for regular "early exit" and what not.)
08:26:26 <dmwit> geheimdienst: Actually, the instance is for Error e => Either e
08:26:34 <Philonous> ClaudiusMaximus: Thanks, but that only shows me what the data that's leaking looks like, but not what's keeping it alive (-hT doesn't seem to be documented)
08:26:39 <dmwit> geheimdienst: Along with an instance Error String.
08:27:21 <geheimdienst> dmwit: the one in C.M.Instances? i have the code here, it doesn't seem to have Error. it is "instance Monad (Either e) where ..."
08:27:25 <bfig_> ok now i understand why In appears. there is still something that i don't quite get: the universal property relating In and the fix point
08:27:34 <shachaf> geheimdienst: The Control.Monad.Error one/
08:27:45 <bfig_> but now i think you can tell me just the property and i'll find it meaningful
08:27:48 --- mode: ChanServ set +o mauke
08:27:48 --- mode: mauke set -q $a:yitz
08:27:55 <shachaf> I don't get the C.M.Error one.
08:28:05 <geheimdienst> me neither :) that's why i'm asking
08:28:11 <yitz> mauke?
08:28:23 <dmwit> The C.M.Error one implements fail.
08:28:24 <shachaf> bfig_: What universal property?
08:28:24 <geheimdienst> so this Error instance that everyone is bitching about is the very same, no?
08:28:39 --- mode: mauke set -o mauke
08:29:12 <geheimdienst> yitz: the muting lasts 1 hour by default. he lifted it early
08:29:30 <bfig_> shachaf, fold f = unique arrow that makes following true: F (fold f) . f = in . fold f
08:29:34 <dmwit> Or rather, the C.M.Error one has a total implementation of fail.
08:30:21 * hackagebot bindings-libzip 0.1.0.3 - Low level bindings to libzip.  http://hackage.haskell.org/package/bindings-libzip-0.1.0.3 (SergeyAstanin)
08:30:24 * hackagebot LibZip 0.2.0.3 - Bindings to libzip, a library for manipulating zip archives.  http://hackage.haskell.org/package/LibZip-0.2.0.3 (SergeyAstanin)
08:30:53 <geheimdienst> dmwit: how do you mean "total implementation"?
08:31:11 <dmwit> geheimdienst: No calls to error, undefined, unsafePerformIO (exitWith exitSuccess), etc.
08:31:28 <dmwit> No incomplete pattern matches.
08:31:52 <Abraxas> mauke: oh yeah, it hurts
08:32:25 <dafis> geheimdienst: note that the Monad instance for Either x has been changed recently, rwh talks about the state as it was in mtl-1.*
08:32:48 <geheimdienst> o_O
08:32:55 <geheimdienst> what's the change?
08:33:04 <dmwit> bfig_: Are you sure you got that universal property right?
08:33:45 <dafis> geheimdienst: there's now instance Monad (Either e) where ... in C.M.instances, and its `fail' is error (per default)
08:34:02 <chrissbx> How can I restrict a search on Hoogle for a concrete type? Like, I want Ord -> Ord -> Ord and not a -> a -> a etc.
08:34:17 <bfig_> dmwit, not sure :|
08:34:40 <dafis> previously, it was instance Error e => Monad (Either e) where ... fail msg = Left (strMsg msg) -- iirc
08:34:43 <bfig_> i don't really understand that formulation, that's what i've been trying to wrap my head about last (several) hours
08:35:35 <dafis> geheimdienst: and that was defined in C.M.Error in mtl
08:36:22 <geheimdienst> i see, so the Error constraint is gone. however, i don't see a definition for fail in C.M.Instances (from base)
08:36:32 <geheimdienst> this is all a bit confusing :)
08:36:47 <bfig_> the other formulation of the universal property lacks any 'reason to be', ie, fold [e,h] is the unique function that fold e f Nil = e, fold e f (cons a l) = f a (fold e f l)
08:37:31 <chrissbx> Hm, seems it fell back because Ord doesn't exist; I wanted Ordering; actually I'm looking for a combinator that takes two comparators and returns one that first compares by the first, then the second; (a -> a -> Ordering) -> (a -> a -> Ordering) -> (a -> a -> Ordering)
08:40:08 <dmwit> bfig_: I think you just got the composition backwards.
08:40:43 <bfig_> starting with the formulation: we have a fixed endofunctor F, a fixed category C, an F-algebra is a pair (A,f) with A an object, f: F A -> A an arrow (nothing imposed on this)
08:40:45 <dmwit> bfig_: Either it's the unique arrow for which "F (fold f); f = In; fold f" or it's the unique arrow for which "f . F (fold f) = fold f . In"
08:41:41 <dmwit> bfig_: So there's two ways to go from F (Mu F) to A: either, you first fmap the fold and then run f, or you first witness the isomorphism between F (Mu F) and Mu F and then fold.
08:42:19 <dafis> geheimdienst: since no fail implementation is given in the instance declaration, the default method from the definition of the class is used, and that's fail msg = error msg
08:42:43 <geheimdienst> oh right :) thanks
08:43:06 <Abraxas> mauke: i am actually still trying :D
08:43:50 <bfig_> dmwit, can we do a simple example and type the stuff to see how the intermediate values are typed?
08:43:59 <dmwit> one second
08:45:38 <dmwit> bfig_: http://draw.to/D3pXZxq <- the typing
08:46:49 <dmwit> bfig_: In fact, since in Hask we observe that In and out (defined by out (In x) = x) witness an isomorphism between types, we can reverse the In arrow to get a definition of fold f.
08:46:53 <dmwit> I'll draw that, too.
08:47:26 <dmwit> http://draw.to/D2vKlJT
08:47:44 <dmwit> So: fold f = f . F (fold f) . out
08:48:19 <dmwit> (in Haskell, we write "F (fold f)" as "fmap (fold f)" instead)
08:49:18 <bfig_> how do you fmap a fold? :|
08:49:40 <dmwit> A fold is just a function like any other function.
08:49:40 <bfig_> ahh you 'lift it' so that it types
08:49:55 <bfig_> i keep forgetting that the list inside the list is not a list :p
08:50:02 <dmwit> indeed =)
08:50:24 <bfig_> it is a F list, so you need to F fold f
08:50:58 <bfig_> the other thing which is weird is what 'f' means, since depending on the underlying functor it could be something weird
08:51:03 <dmwit> [a] is Mu (ListF a), where data ListF a b = Nil | Cons a b
08:51:32 <dmwit> Yes, "f" is allowed to observe the shape of the underlying functor.
08:51:48 <dmwit> For example, with ListF that I just defined, "f" could do a pattern match on Nil or Cons.
08:52:19 <dmwit> bfig_: In fact, taking this example just a bit farther might be a good idea.
08:52:33 <bfig_> i've found a generic way to build a fold by reading a bunch of papers
08:52:37 <Eduard_Munteanu> That's why Functor is a typeclass.
08:52:38 <dmwit> A typical implementation of a function f :: ListF e a -> a will look like this:
08:52:49 <dmwit> f Nil = {- some value of type a -}
08:53:07 <dmwit> f (Cons e a) = {- some way to combine a single list element and a value of type a to get a new a -}
08:53:11 <bfig_> one function for every constructor and the fold is the pattern matcher on every constructor
08:53:19 <dmwit> That is, "f" gives an a and a combining function.
08:53:23 <dmwit> Now look at the type of foldr:
08:53:25 <dmwit> :t foldr
08:53:26 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:53:30 <dmwit> equivalently:
08:53:38 <dmwit> foldr :: (e -> a -> a) -> a -> [e] -> a
08:53:55 <dmwit> So, foldr takes in a function that tells how to combine a single list element and a value, and an initial value.
08:54:06 <dmwit> That's exactly the data that "f" would have provided!
08:54:08 <dmwit> Magical!
08:54:14 <ski> then `let f Nil = a0; f (Cons e a) = g e a in fold f' corresponds to `foldr g a0'
08:54:38 <bfig_> so what does the universal property say from the categorical point of view?
08:54:53 <bfig_> (every time i ask that question i get closer to the truth! :p)
08:55:28 * hackagebot Hipmunk 5.2.0.5 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.5 (FelipeLessa)
08:55:30 <dmwit> It says that folding really makes sense: there's no other pseudo-fold with the same properties but a different behavior.
08:55:38 <Eduard_Munteanu> @free foldr  -- this?
08:55:39 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
08:55:41 <ski> the universal property for `Mu' in general ? or for the specific example of lists ?
08:56:03 <dmwit> bfig_: It's more a comment about the _category_ than it is about the operation of folding.
08:56:20 <bfig_> what do you mean by that?
08:57:20 <bfig_> sorry if it looks like i'm trolling but i really find this hard >_>
08:57:32 * dmwit too, sometimes =)
08:58:05 <dmwit> I'm not sure what I mean by that, so I retract it for now.
08:58:06 <ski> for the universal property of `Either', it says that to define a function `f :: Either A B -> C', it suffices to define what happens in the two cases `f . Left',`f . Right' : there is always an `f' satisfying `f . Left = g0' and `f . Right = g1', and furthermore, there can't be more than one such, it's uniquely determined by those two properties
08:58:41 <dmwit> bfig_: (Be careful: ski is no longer talking about a Mu type. "universal properties" apply to many, many constructs.)
08:58:53 <ski> so, in a sense, it says that `Left' and `Right' together are invertible : you can recover the values passed to `Left' and `Right'
08:59:03 <bfig_> ski, so when you say 'given a homomorphism from an universal algebra...' you mean 'for those that exists, you get x and y and z' ?
08:59:25 <bfig_> ie, the homomorphisms from the universal algebra are those representable by the folds over the functor?
08:59:32 <bfig_> err, initial algebra
09:00:07 <bfig_> (in both sentences)
09:02:27 <ski> yes, the morphism (unique, given that you've fixed the codomain) from the initial algebra is determined by the specification of the algebra that is the codomain
09:03:27 <bgamari> Anyone seen this before?
09:03:32 <bgamari> GHCi runtime linker: fatal error: I found a duplicate definition for symbol memset_off
09:04:26 <ski> consider for example the universal algebra signature specified by : carrier `X', operations `zero : 1 >-> X',`succ : X >-> X', and zero laws
09:04:45 <bgamari> Stackoverflow seems to think the problem is http://stackoverflow.com/questions/7772824/could-someone-offer-troubleshooting-steps-for-resolving-a-possible-package-confl
09:05:23 <ski> an example of such an algebra is when we take `X' to be `Bool', and define `zero () = True' and `succ = not'
09:06:02 <ski> now, the *initial* such algebra is of course (in Haskell terms) `data Nat = Zero () | Succ Nat' (ignoring bottoms)
09:06:42 <ski> and that `Nat' together with `Zero' and `Succ' is an initial algebra means exactly that there's a unique homomorphism from it to any other algebra
09:06:58 <ski> e.g. the algebra given by `Bool', `zero', `succ' above
09:07:01 <bfig_> the initial algebra is the set {Zero, Succ Zero, Succ Succ Zero...} right?
09:07:08 <bfig_> the set component
09:07:32 <ski> that's the carrier of the initial algebra, yes (just as the carrier of the other algebra above is `Bool')
09:07:59 <ski> so, there is a morphism `f : <Nat,Zero,Succ> >-> <Bool,zero,succ>'
09:08:32 <ski> the function part of it satisfies `f . Zero = zero' together with `f . Succ = succ . f'
09:08:51 <ski> i.e. `f (Zero ()) = zero' and `f (Succ n) = succ (f n)'
09:09:29 <ski> so `f' is the function that maps a natural number to a boolean determining whether the natural was even
09:10:02 <ski> btw, that `<Nat,Zero,Succ>' is the initial algebra (for this signature) just means that it is the initial object in the category of these algebras
09:10:42 <bfig_> i'm dizzy now
09:11:27 <ski> in the case of list folding (over lists with elements from `A'), the codomain of the initial morphism is determined by fixing a carrier `X', and two operations of type `1 >-> X' and `A * X >-> X'
09:12:08 <bfig> what do you mean by fixing a carrier?
09:12:20 <ski> picking some set/type
09:12:22 <bfig> the equivalent of picking the base type? ie, List Int ?
09:12:24 <bfig> ok
09:12:40 <bfig> (actually just Int)
09:13:22 <ski> in this case with lists of elements of type `A', an algebra is specified by picking a carrier `X', and picking two operations `nil : 1 >-> X' and `cons : A * X >-> X' (which are required to satisfy zero laws)
09:14:13 <ski> (btw, algebra( signature)s which have zero laws are sometimes called anarchic algebras .. ones which are lawful being then called archic algebras)
09:14:20 <bfig> to be consistent with notation: f: 1+ A x X -> X right?
09:14:47 <ski> what is that `f' supposed to be ?
09:14:53 <ski> the folding function ?
09:14:58 <bfig> a function over the whole 'level' of the datatype
09:15:03 <ski> the algebra operation in the codomain ?
09:15:07 <ski> ok
09:15:23 <bfig> it's how it's written in the papers i've been trying to read
09:15:54 <bfig> so your function is f:F X -> X
09:15:59 <ski> in universal algebra, we specify a record of operations `op_i : G_i X >-> X', for `i' in some index set `I'
09:17:06 <bfig> give me one second, i'll be right back, gotta do something real quick
09:17:14 <bfig> thanks for helping me understand this :)
09:17:15 <ski> in the categorical `F'-algebra view, all these can be joined together into `op : (Sum_{i : I} G_i X) >-> X', where we can abbreviate `Sum_{i : I} G_i X' as `F X' (for all `X')
09:17:33 <ski> so we get `op : F X >-> X' then, yes
09:17:59 <ski> in the example above, then `forall X. F X = 1 + A * X', indeed
09:18:27 <tromp> :t atan
09:18:28 <lambdabot> forall a. (Floating a) => a -> a
09:18:35 <tromp> :t atan2
09:18:36 <lambdabot> forall a. (RealFloat a) => a -> a -> a
09:18:59 <tromp> > 1280 :% 720
09:19:00 <lambdabot>   Not in scope: data constructor `:%'
09:19:10 * bfig will be back in 5 mins
09:19:29 <tromp> > 1280 % 720
09:19:30 <lambdabot>   16 % 9
09:20:12 <tromp> > sin(atan2 16 9)
09:20:12 <lambdabot>   0.8715755371245493
09:21:05 <tromp> > 720/(4.65*sin(atan2 16 9))
09:21:06 <lambdabot>   177.65380403889503
09:21:47 <tromp> > cos(atan2 16 9)
09:21:48 <lambdabot>   0.490261239632559
09:21:57 <tromp> > 720/(4.65*cos(atan2 16 9))
09:21:58 <lambdabot>   315.8289849580355
09:25:12 <bfig> back
09:25:13 <ski> bfig : time's up !
09:25:15 <ski> ;)
09:25:29 <ski> <bfig> the equivalent of picking the base type? ie, List Int ?
09:25:32 <ski> <bfig> (actually just Int)
09:25:38 <ski> not quite
09:25:44 <applicative> bgamari did you figure out the error?  are you using blaze-textual or one of those packages?
09:26:07 <ski> in the case of lists over `A', we get a different category for each choice of `A'
09:26:14 <__yhvh__> [[a,b] | let x = [1..2],a<-x,b<-x] -- can I define this for [a,b,c], [a,b,c,etc.]
09:26:46 <bfig> yes, each is a new type F A of kind 'one less *'
09:26:56 <ski> so, given an `A', we get a category where each object is specified by picking an `X', and picking two operations `nil : 1 >-> X' and `cons : A * X >-> X'
09:27:15 <ski> so, by "fixing a carrier", i meant picking the `X'
09:27:24 <ski> `A' was already assumed fixed earlier
09:27:53 <bfig> A the codomain of our arrow?
09:28:14 <ski> no, `A' being the type of elements of our `A'-list algebras
09:28:45 <ski> in the case of `Nat', we get (roughly speaking) `Nat'-algebras
09:29:04 <ski> but the list type is parameterized, so for each `A', we get `[A]'-algebras
09:29:11 <Abraxas> mauke: i got sidetracked (and disconnected)...if you are still there and would like to pick up on the flip id problem
09:29:34 <Abraxas> or someone else got a mind to jump in
09:30:28 <ski> so `<Bool,const True,not>' is a `Nat'-algebra (really, `Nat' here stands not for the type, but for the signature of having a carrier `X' with two operations of types `1 >-> X' and `X >-> X')
09:30:41 <mauke> Abraxas: I don't have much time, but what are you stuck on?
09:30:45 <ski> bfig : am i confusing you now ?
09:31:00 <bfig> ski, give me a minute to process all this
09:31:04 <Abraxas> flip takes (a->b->c) first and id is a->a...so for flip id the id has to be type (b->c)->(b->c) at least, right?
09:31:05 <ski> sure
09:31:16 <ski> Abraxas : yes
09:31:27 <bfig> it'd be unfair to say you're confusing me when i can't understand it without looking at it a couple times
09:32:03 <Abraxas> then there are no more arguments, would it help to construct a case where they are any, or should i be able to abstract it as it is
09:32:08 <applicative> Abraxas, yes.  It's forced to specialize 'id' to (b->c)->(b->c)
09:32:40 <ski> Abraxas : what you do is you pick fresh variables, `flip :: (a0 -> b0 -> c0) -> (b0 -> a0 -> c0)', and `id :: a1 -> a1', and then you unify the type of the operator/function domain/argument, i.e. `a0 -> b0 -> c0', with the type of the operand/argument, i.e. `a1 -> a1'
09:32:41 <Abraxas> because basically that was what i had after 1 minute and didn't get any further :D
09:32:53 <mauke> Abraxas: maybe it would help if you evaluate 'flip id x y' without looking at the types at all
09:33:00 <mauke> just the definitions of flip and id
09:33:22 <ski> Abraxas : so unifying means we want to solve the equation `a0 -> b0 -> c0 = a1 -> a1', which really means `a0 -> (b0 -> c0) = a1 -> a1'
09:34:16 <ski> Abraxas : and from this follows that the domain/argument types must be equal, and that the codomain/result types must be equal, i.e. `a0 = a1' and `b0 -> c0 = a1'
09:35:37 <ski> Abraxas : now, we look at the result/codomain type of the function/operand which is `b0 -> a0 -> c0', but since we know `a0 = a1' and `b0 -> c0 = a1', we expand that type to `b0 -> (b0 -> c0) -> c0'
09:35:49 <Abraxas> i guess i am stuck on flip needing two more arguments and id stood in for the function and now there is nothing left
09:36:27 <ski> Abraxas : there are no further restrictions on what `b0' and `c0' might be, so we can generalize on them, getting `flip id :: forall b c. b -> (b -> c) -> c'
09:36:55 <bgamari> applicative: I am
09:36:56 <ski> that above is the type view of it
09:37:20 <Abraxas> oh i see
09:37:21 <ski> Abraxas : looking at how the values would evaluateas mauke suggests is also good
09:37:22 <bgamari> applicative: Rather, no, I am not (at least not knowingly)
09:37:22 <bgamari> applicative: I'm using random-fu
09:37:45 <bgamari> applicative: Which at one point appeared to have issues
09:37:59 <bgamari> applicative: Statistics and random-fu seemed to be fighting over what version of random-source was needed
09:38:17 <bgamari> applicative: I rebuilt them all and now there are no broken packages
09:38:24 <bgamari> but unfortunately the crash persists
09:39:06 <Abraxas> never tried to unify the part that was left...haha
09:39:20 <Abraxas> thinking too much from left to right
09:39:23 <ski> Abraxas : you do know the typing rule for application, yes ?
09:39:56 <Abraxas> i guess not
09:40:05 <bgamari> applicative: Any ideas?
09:40:08 <Abraxas> maybe but i don't recognise it
09:40:54 <ski>   e :: tau_0 -> tau_1   e_0 :: tau_0
09:40:56 <ski>   ----------------------------------
09:41:01 <ski>   e e_0 :: tau_1
09:41:09 <applicative> bgamari, I thought I might, but random-fu random-source et al. are baffling me.  statistics does depend on the aeson/ blaze-textual nightmare
09:41:50 <ski> `e',`e_0' stand for arbitrary expressions -- in this case they would be the function/operator expression, and the argument/operand expression
09:41:56 <bgamari> applicative: Is there any way to tell what is calling for the earlier version of primitive?
09:42:28 <ski> `tau_0',`tau_1' stand for arbitrary type (expressions) -- in this case `tau_0' is the argument/domain type, and `tau_1' is the result/codomain type
09:42:32 <Abraxas> definitely no
09:42:56 <bgamari> applicative: It's clear that the crash occurs when the compiler attempts to load primitive-0.4.0.1
09:43:19 <bgamari> applicative: Judging by lines like "hiding package primitive-0.3.1 to avoid conflict with later version primitive-0.4.0.1
09:43:28 <bgamari> earlier in the output, it seems that the problem is a version conflict
09:43:30 <ski> e.g. if we look at the application `map fromEnum (reverse s)', this is really `(map fromEnum) (reverse s)', so `e' is then the expression `map fromEnum' and `e_0' is the expression `reverse s'
09:43:34 <bfig> ski, i'm looking at a commutative diagram with this: f o F (fold f) = fold f o in
09:43:42 <bgamari> applicative: But I really don't know why it would load 0.3.1
09:43:54 <applicative> bgamari: it's vector that wants that -- Build-Depends: base >= 4 && < 5, primitive >= 0.3.1 && < 0.4
09:43:58 <ski> Abraxas : the horizontal line means : given that all the things above the line hold, the thing below the line holds as well
09:44:12 <bfig> i guess my main problem with this diagram is that i didn't understand where the context of the *current level* is passed around, but the fact is that neither passes them around: the context are the objects themselves, right?
09:44:22 <ski> Abraxas : so it's just a fancy way of writing : if `e :: tau_0 -> tau_1' and `e_0 :: tau_0', then `e e_0 :: tau_1'
09:45:17 <dmwit> bfig: Okay, here's one possible interpretation of what the universal property means.
09:45:51 <ski> Abraxas : so the rule say that, in a function application, the type of the argument expression (actual parameter) has to match (be the same as) the argument/domain type of the function (which is the type of the formal parameter in the definition of the function)
09:45:51 <dmwit> bfig: It means, if we take the corresponding equation fold f = f o F (fold f) o out as a *definition* of fold, then it's a *good* definition.
09:45:58 <bgamari> applicative: Arg
09:46:11 <ski> Abraxas : and then the type of the whole application expression is the result type of the function
09:46:16 <bgamari> applicative: Well I depend upon vector pretty much everywhere
09:46:17 <dmwit> bfig: It's "good" in the sense that if we made any other definition of fold, and it turned out to make the diagram commute, then it would coincide with this definition.
09:46:46 <Abraxas> i had more of a practical approach to haskell so far, no calculus or any of that
09:46:51 <dmwit> (Because there's a unique fold arrow making the diagram commute!)
09:46:59 <Abraxas> but i see
09:47:08 <Abraxas> that's nice, thanks!
09:47:09 <bgamari> applicative: Any solution here?
09:47:11 <applicative> bgamari, I take that back, the new vector uses the new primitive, but I have the old vector for another reason, I'm not sure what's forcing ye olde primitive on you.
09:47:37 <sm> morning all
09:48:09 <sm> [cmd|.. |] is a quasiquoter expression.. but what's [| ... |] ?
09:48:28 <gwern> @quote
09:48:28 <lambdabot> luqui says: *sigh*: mathematicians. can't live with 'em, can't prove 'em wrong.
09:48:32 <bgamari> applicative: Perhaps I too have old vector
09:49:03 <ski> Abraxas : anyway, it's not really necessary to know the notation i mentioned above (though it helps, if you read papers), but the ideas are important : you should be able to infer the types in an application like `flip id', either in your head (e.g. in an implicit intuitive way), or if that fails, by writing down the equation `a0 -> (b0 -> c0) = a1 -> a1' down, solving it (easy), and plugging in values in the result type `b0 -> a0 -> c0'
09:49:45 <Abraxas> yeah, looks easy now
09:50:17 <ski> sm : iirc, it's an abbreviation for `[e| ... |]'
09:50:21 <applicative> bgamari: I don't know what to advise, I had originally hoped it was the familiar ghci+aeson/statistics/etc problem
09:50:26 <Abraxas> i wonder if it's trivial and i failed to derive it
09:50:34 <bgamari> applicative: Hmm, for some reason it's loading vector-0.7.1 despite having vector-0.9
09:50:34 * hackagebot gruff 0.2.1 - fractal explorer GUI using the ruff library  http://hackage.haskell.org/package/gruff-0.2.1 (ClaudeHeilandAllen)
09:50:44 <bgamari> applicative: hiding package vector-0.7.1 to avoid conflict with later version vector-0.9
09:51:24 <sm> ski: what's e ?
09:51:36 <applicative> what does ghc-pkg unregister vector-0.7.1 or ghc-pkg unregister primitive-whatever-it-was -- what does it tell you will break?
09:52:17 <ski> Abraxas : btw, one thing to take away from this, is that if you have something of type `forall a. A -> B -> C -> a', then this takes (curriedly) at *least* three arguments, but if you set `a' to a function type (e.g. `D -> E'), it will take four arguments
09:52:55 <ski> sm : a quasiquoter for expressions .. maybe it's spelled `exp' or `expr' or something, i don't recall (i'm not that familiar with TH)
09:52:56 <bgamari> applicative: ghc-pkg: unregistering vector-0.7.1 would break the following packages: criterion-0.5.1.0 statistics-0.9.0.0 hakyll-3.2.0.10 snap-server-0.5.5 vector-algorithms-0.5.3 snap-core-0.5.5 aeson-0.3.2.12 blaze-textual-0.2.0.4 random-fu-0.2.1.0 rvar-0.2 random-source-0.3 mwc-random-0.10.0.1 gamma-0.7.0.1 (use --force to override)
09:53:30 <sm> ski: ah, will check, thanks
09:53:34 <bgamari> applicative: primitive gives roughly the same list
09:53:40 <applicative> well, that would be a pain to reinstall....
09:53:56 <ski> sm : anyway, the above is that i *seem* to recall -- you should probably check it to make sure
09:55:01 <ski> bfig : i'm not sure what you mean by "where the context of the *current level* is passed around" -- also what's "contexts" here ?
09:55:28 <ski> bfig : if you want, i could continue my explanation of the list algebras
09:55:46 <bgamari> applicative: I don't mind waiting, at this point I just want working packages
09:55:50 <bfig> ski, so, in practical terms, the commutative diagram transcribes the idea that a fold will be defined by it's structural properties in a single level, applied recursively in the successive levels, right?
09:55:53 <bgamari> I've already reinstalled most of those once already
09:56:55 <bgamari> Which I why I suspect that just reinstalling again won't help
09:57:20 <bgamari> applicative: What is the proper solution here?
09:57:22 <bfig> ski, f is a function that takes a whole 'level' (ie f:1+Int x X -> X), and the fold is then the way to chain the structural recursion such that you can always reason in terms of levels
09:57:28 <bgamari> applicative: forcefully uninstalling all of the above and reinstalling?
09:58:07 <applicative> bgamari, of course, as what monochrom calls a ' promiscuous upgrade whore' I would unregister vector-0.7.1 and the old primitive and everything they depend on in one big script, then let cabal install 'unify' the reinstall all at once, but 1) i'm not sure this will solve your problem, 2) there is still the aeson/blazetextual/ghci problem, 3) I'm what monochom called by that unfortunate name....
09:58:12 * ski first mistook bgamari for bfig, and wondered what the talk about reinstalling (repeating the explanation of `F'-algebras ?) meant
09:58:23 <rotflcopter> hii
09:58:28 <sm> ski: good pointer, I found more at http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
09:58:59 * sm guesses [$|...|] is the ghc 6.12 compatible syntax then
09:59:03 <Abraxas> it's just weird that not knowing all this, i could be assumed to convert foldl to foldr
09:59:35 <bgamari_> applicative: If you said something in the last minute I missed it
10:00:04 <bfig> i think i have enough understanding to keep up with what i was trying
10:00:09 <bfig> ...to do
10:01:02 <sm> I can't seem to find api docs for those e, t, d, p functions though
10:02:00 <Abraxas> it's an advanced FP course and i skipped the basics because they included logical programming basics i already had done at the advanced stage...slides don't show anything that could help with this...probably figured we get it from the web :D
10:02:09 <dmwit> bfig: Yes, that's what the commutative diagrams mean.
10:02:32 <applicative> bgamari, the last thing I said was that I myself would unregister all that, then reinstall all at once, but I expressed doubts about the rationality of this... :)
10:02:49 <ski> in the general case, given an `F'-algebra specified by a carrier `X' and an operation `op : F X >-> X', the fold / initial morphism `fold op : <Mu F,In> >-> <X,op>' should satisfy `fold op . In = op . map_F (fold op)', as i think dmwit said
10:03:09 <bfig> ski, dmwit, shachaf, yrlnry and everyone else who pitched in, thanks for the help
10:03:29 <ski> bfig : istr "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs in 1997 at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf> was good, you might try to take a look at that
10:03:32 <ski> also
10:03:37 <ski> @where ErikPoll
10:03:37 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
10:03:37 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
10:03:37 <lambdabot> pdf>
10:03:48 <ski> might be interesting
10:03:59 <bgamari_> applicative: Could you re-express these doubts?
10:04:24 <applicative> oh I said the following longwindedly: bgamari, of course, as what monochrom calls a ' promiscuous upgrade whore' I would unregister vector-0.7.1 and the old primitive and everything they depend on in one big script, then let cabal install 'unify' the reinstall all at once, but 1) i'm not sure this will solve your problem, 2) there is still the aeson/blazetextual/ghci problem, 3) I'm what monochom called by that unfortunate name.
10:04:47 <ski> Abraxas : "logical programming" meaning logic programming like Prolog e.g. ?
10:06:18 <Abraxas> uh yeah, logic
10:06:20 <bgamari_> Whether it makes me an upgrade whore or not, I don't really see any other solution
10:06:27 * applicative is trying to affirm his inner promiscuous upgrade whore
10:07:42 <bgamari_> monochrom: Is there any other solution?
10:07:43 <applicative> bgamari_: me neither, my only real doubt is that is that it won't solve your original problem, but at least it would clarify the structure of dependencies
10:08:32 <bgamari_> applicative: Yep
10:09:34 <applicative> bgamari_: the only subtlety about simply reinstalling everything when you unregister everything is the blaze-textual/aeson/statistics issue, if you are going to end up using something from them in ghci
10:10:34 * hackagebot type-unary 0.1.2 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.2 (ConalElliott)
10:10:35 <ski> sm : presumably those are (at least in theory) values of type `QuasiQuoter' .. but i don't see them exported in `Language.Haskell.TH' nor in `Language.Haskell.TH.Quote', so mayhaps they're always in scope in the quoter part of a quasi-quotation
10:10:46 <applicative> bgamari_ but maybe if you install the random stuff you were working with first, you can see if that works, than deal with the aeson empire after that.
10:10:58 <bgamari_> applicative: I can uninstall double-conversion as well
10:11:02 <bgamari_> and recompile with -fnative
10:11:04 <Abraxas> but "flip id x y" written that way is not possible, is it
10:11:10 <applicative> bgmari_ right
10:11:22 <bgamari_> applicative: What exactly is so wrong with aeson anyways? Just this one issue?
10:12:00 <ski> Abraxas : well, since `flip id :: b -> (b -> c) -> c', i think we can imagine `x :: b' and `y :: b -> c' so that `flip id x y :: c', no ?
10:12:27 <augur> conal: !
10:12:27 <applicative> bgamari_: yes it's just that issue, I think the real way forward there is to use cabal-devel and have one instance for fiddling with ghci and another for testing, profiliing etc.  But my imagination is limited
10:12:34 <augur> you wrote a paper on higher order abstract syntax!
10:12:49 * ski . o O ( HOAS ! )
10:13:00 <applicative> excellent idea!
10:14:44 <Abraxas> see what i learned? :D
10:15:20 <applicative> bgamari_: sorry, I wish I could be of more use.
10:15:24 <Abraxas> yeah got it
10:16:06 <RevolverBaer> @pl (\ x -> do y <- f x; z <- g x; return (y, z))
10:16:06 <lambdabot> (line 1, column 20):
10:16:07 <lambdabot> unexpected ";"
10:16:07 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
10:16:08 <Abraxas> id with the (a->a) in the middle threw me off
10:16:22 <RevolverBaer> @pl (\ x -> do { y <- f x; z <- g x; return (y, z) })
10:16:23 <lambdabot> (line 1, column 12):
10:16:23 <lambdabot> unexpected "{"
10:16:23 <lambdabot> expecting variable, "(", operator or ")"
10:17:55 <Guest25030> hi, people kisses from france and poland
10:17:57 <bgamari_> applicative: It's alright
10:18:12 <Abraxas> keep forgetting a can be a function
10:18:18 <bgamari_> I just wish cabal wasn't so fragile
10:20:34 * hackagebot hledger-web 0.16.5 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.16.5 (SimonMichael)
10:20:49 <sm> hmm, didn't the tested-with field used to show on hackage ?
10:21:19 <RevolverBaer> @pl (\ (x, y) -> (,) <$> f x <*> g y)
10:21:20 <lambdabot> uncurry ((((,) <$>) .) . (. g) . (<*>) . f)
10:21:44 <sm> current it shows just Built on, and not for all packages
10:22:13 <applicative> bgamari_ cabal install is pretty infallible if it can do its inferences all at once, it's when you install a bit now and a bit later that things go crazy, or that's my experience.
10:22:32 <sm> oh I see, Built on or Build failure appears once it has attempted that
10:23:06 <ion> @type ((\f g (x,y) -> (,) <$> f x <*> g y), (\f g -> f *** g))
10:23:07 <lambdabot> forall t t1 a a1 (f :: * -> *) (a2 :: * -> * -> *) b c b' c'. (Applicative f, Arrow a2) => ((t -> f a) -> (t1 -> f a1) -> (t, t1) -> f (a, a1), a2 b c -> a2 b' c' -> a2 (b, b') (c, c'))
10:23:17 <ion> @type [(\f g (x,y) -> (,) <$> f x <*> g y), (\f g -> f *** g)]
10:23:18 <lambdabot>     Occurs check: cannot construct the infinite type: f = (,) (f a)
10:23:18 <lambdabot>       Expected type: f (a, a1)
10:23:18 <lambdabot>       Inferred type: (f a, f a1)
10:23:46 <applicative> bgamari_ have you looked into cabal-devel, it's pretty awesome (in my limited experience so far); also see the helpful monochrom, which I hadn't seen til it showed up on the agda list: http://www.vex.net/~trebla/haskell/sicp.xhtml
10:24:19 <sm> and I guess it doesn't attempt a build at all if there's no exposed library modules
10:26:21 <RevolverBaer> @pl (\ x -> f x <|> g x)
10:26:22 <lambdabot> liftM2 (<|>) f g
10:26:52 <ski> @type \f g ~(x,y) -> (,) `fmap` f x <*> g x
10:26:53 <lambdabot> forall t t1 a a1 (f :: * -> *). (Applicative f) => (t -> f a) -> (t -> f a1) -> (t, t1) -> f (a, a1)
10:31:51 <bgamari_> Is there any way to stop the profiler from truncating CC names into oblivion?
10:33:11 <dafis> bgamari_: you can set the length to which SCCs are displayed, iirc
10:33:27 * dafis goes searching the docs
10:33:30 <bgamari_> dafis: even in the .hp file they are truncated with ellipsis
10:33:46 <bgamari_> A bit of googling has turned up http://www.haskell.org/pipermail/glasgow-haskell-users/2005-November/009285.html
10:33:52 <bgamari_> which suggests you can't
10:34:11 <bgamari_> which I really have a hard time believing
10:34:23 <shachaf> bos: Ping?
10:34:25 <bgamari_> the profiler output really is next to useless is this case
10:36:25 <bos> shachaf: yup?
10:37:21 <shachaf> bos: I think pure is flipped in <http://www.scs.stanford.edu/11au-cs240h/notes/monads-slides.html#(18)>. Also return on slide 26.
10:40:41 <monochrom> strange! agda list...
10:41:26 <shachaf> agda-cafe@agda.org?
10:41:34 <dafis> bgamari_: try the -L option, according to section 5.4.1 of the ug, that "Sets the maximum length of a cost-centre stack name in a heap profile. Defaults to 25."
10:48:35 <parcs_> anyone know of an arrow-based parsing library?
10:49:06 <shapr> there was one...
10:49:17 <shapr> Written by Einar Karttunen I think?
10:50:03 <shapr> parcs_: But the short cut advantages of arrows have been overtaken by a new fad, the transparent parallelism of monoids as evidenced by edwardk's trifecta libs
10:50:32 <edwardk> and all the arrow based parsing tricks work with applicatives
10:50:39 <edwardk> there isn't really any use of the arrowness
10:50:43 <edwardk> just applicativeness
10:50:50 <edwardk> but they came along before applicatives existed as a concept
10:50:51 <shapr> Even the shortcut stuff works with applicatives?
10:51:16 <edwardk> what did the arrow use the input side of the arrow for?
10:51:33 <edwardk> i can implement sweirstra-and-duponcheel with an applicative parser very easily
10:51:53 <edwardk> moreover, i can make it compatible with a monad that just loses the static lookahead benefits when used as such
10:52:59 <shapr> ok, I'm interested.
10:53:02 <edwardk> basically all they do is compute the FIRST_1 sets of the grammar. its a (reasonably poor) approximation of LL(1) dispatch, given that it can't compute follow sets for anything
10:53:21 <shapr> parcs_: Does that answer your question?
10:53:39 <edwardk> so it is still less efficient than a classic LL(1) parser when skipping past parsers with epsilon transitions
10:54:05 <shapr> I totally don't get those last two sentences, but I'll go back and work on my C network message parser instead.
10:54:42 <edwardk> parcs: in the meantime http://www.fh-wedel.de/~si/HXmlToolbox/ uses an arrow based parser
10:55:23 <ski> parcs_ : i think the original motivation for arrows was Swierstra's and Duponcheel's "Deterministic, Error-Correcting Combinator Parsers" in 1996 at <http://www.staff.science.uu.nl/~swier101/Papers/1996/LL1.pdf>
10:55:32 <geheimdienst> what service is responsible for building packages that were uploaded to hackage? how are the build logs (linked on package pages) generated? i can't seem to find it in hackage-scripts
10:55:41 <edwardk> shapr: basically what a swierstra and duponcheel style parser does is track two parts, a set of terminals that it will recognize and a flag that indicates whether or not it accepts the empty string
10:56:18 <shapr> right
10:56:27 <shapr> Man, I miss having lunch with you most days :-/
10:56:35 <edwardk> if you go to compose foo <*> bar -- if foo doesn't accept the empty string then the set of terminals it recognize are just those that could be recognized by foo
10:56:46 <shapr> right
10:56:51 <edwardk> if it does then you have to merge the two sets and the result recognizes the empty string only if both do
10:56:56 <monochrom> wait, no, HXT uses parsec and/or tagsoup for parsing.
10:57:20 <edwardk> whereas with a monad, if you have foo >>= f  -- then you can only give a first set when foo doesn't recognize the empty string
10:57:39 <edwardk> otherwise you have no idea what f will receive as its input and therefore no idea what to union into your set
10:57:55 <edwardk> so you have to accept the universe of tokens and filter it dynamically if foo accepts the empty string
10:58:35 <edwardk> whereas with a traditional LL(1) parser, what you'd do is look through the entire grammar for occurrences of a non-terminal, and then compute the first set of whatever appears on their right hand side
10:59:03 <edwardk> that would tell you what tokens could come after it, and are important to preserving the asymptotic performance of LL(1)/LL(k)-style parsing
11:00:20 <shapr> oh, that's straightforward.
11:00:30 <edwardk> yeah
11:00:41 <edwardk> hence why i took the time to explain it fully ;)
11:01:15 <shapr> So traditional LL(1) parsers calculate a rough idea of what their first step could do, and tell you about it?
11:01:29 <shapr> Much like the Swierstra-Duponcheel parsers?
11:01:31 <edwardk> well in a real LL(1) parser it is an exact idea
11:01:40 <edwardk> in a swierstra/duponcheel parser we get a rough guess
11:01:56 <shapr> nifty
11:02:03 <edwardk> the 'static' part is the approximation of the FIRST set of an LL(1) parser
11:02:29 <edwardk> the dynamic part and the fact that we don't know follow sets are a sop to the fact that we build it using combinators, and that we can bolt a monad in
11:03:14 <edwardk> the GLL parser combinators djspiewak has in scala also has the same problem
11:03:20 <edwardk> er have
11:03:56 <Abraxas> oh a parser specialist
11:04:07 <Abraxas> what does this want me to do: string :: String -> Parser ()
11:04:15 <edwardk> ?
11:04:33 <Abraxas> (), that's a unit, right
11:04:34 <edwardk> probably build a parser using whatever kind of parsing combinator Parser is that only accepts a given string
11:04:36 <edwardk> yes
11:04:51 <edwardk> what does 'Parser' look like internally?
11:04:57 <Abraxas> sorry
11:05:15 <Abraxas> String -> (a,String)
11:05:23 <Abraxas> String -> [(a,String)]
11:05:34 <edwardk> ah, a list of successes parser
11:05:37 <shapr> :t Parser
11:05:40 <lambdabot> Not in scope: data constructor `Parser'
11:06:22 <c_wraith> replacing failure with a list of successes.  A reasonable strategy.
11:06:30 <Abraxas> i am stupid
11:06:32 <Abraxas> String -> Maybe (a, String)
11:06:43 <Abraxas> got confused by a different parser
11:06:50 <c_wraith> Oh.  Well, not a list after all.
11:06:52 <edwardk> string (x:xs) (y:ys) | x == y = string xs ys -- then you need cases for when the strings don't match and when you run out of characters in one before the other
11:06:57 <Abraxas> nope, sorry
11:07:34 <edwardk> c_wraith: http://www.springerlink.com/content/y7450255v2670167/
11:07:58 <edwardk> that joke is older than many people on this channel ;)
11:08:06 <c_wraith> edwardk: I've read the paper. :)
11:08:24 <edwardk> Abraxas: but thats the gist
11:08:27 <c_wraith> also, '85 isn't older than me...  But matches the first time I programmed *anything* pretty well
11:08:54 <edwardk> *nods* my first serious program came in just a couple of years before that as well
11:09:29 <geheimdienst> did they even have computers in 85 ...?
11:09:57 * ski . o O ( "Dr. Seuss on Parser Monads" <http://www.willamette.edu/~fruehr/haskell/seuss.html> )
11:10:08 <homie> they had them at WWI even.... or ?
11:10:25 <Abraxas> hold on, you joked?
11:10:39 <monochrom> they had computers in the 19th century. Hollerinth's weaving machines
11:11:00 <Abraxas> or just the link
11:11:15 <homie> the oldest is called abacus tho! ?
11:11:17 <homie> lol
11:11:22 <parcs_> thanks for the explanations
11:11:48 <homie> no wait, erm stones!, plain stones!
11:12:10 <monochrom> the oldest computer was a human
11:12:22 <homie> that's right, and her name was eve!
11:12:26 <edwardk> Abraxas: anyways your best bet would be to read through http://eprints.nottingham.ac.uk/223/1/pearl.pdf and mentally swap out [] for Maybe
11:12:28 <monochrom> or maybe a bee, I wouldn't know
11:12:44 <homie> but for some reason she was always offby1 somehow!
11:12:46 <homie> lol
11:13:05 <ski> (hm .. offby1 lives in #scheme)
11:13:15 <edwardk> homie: probably the extra rib
11:13:51 <homie> k
11:17:05 * monochrom played with Apple II and Atari 800 in 1985
11:21:03 <Abraxas> edwardk: sorry, was distracted
11:21:16 <Abraxas> we swapped it for lists by now
11:22:15 <Abraxas> ah, functional perls, that's coming up
11:22:18 <Abraxas> thx
11:24:55 <mizu_no_oto> I'm having some trouble getting a simple thing with Data.Enumerator working
11:24:58 <mizu_no_oto> http://hpaste.org/53145
11:25:47 <mizu_no_oto> an Iteratee a m b is just a newtyped m (step a m b)
11:26:06 <mizu_no_oto> I'd like to do something like mapM_ printData xs >> (E.Iteratee $ E.Continue f)
11:26:30 <mizu_no_oto> which would work if Iteratee were just a type synonym
11:27:42 <mizu_no_oto> any help?
11:31:18 <leino> what is the easiest way to do direct, per pixel rendering from haskell? I want to do some software rendering
11:33:56 <DukeDave> leino: Well, you can go down the OpenGL route: http://www.haskell.org/haskellwiki/Opengl
11:34:24 <leino> DukeDave: what about sdl?
11:34:38 <leino> I want to draw the triangles myself
11:34:58 <DukeDave> leino: Can't say I've used the SDL bindings in Haskell myself
11:35:25 <Peaker> the cinvoke bindings seem great.. anyone used them?
11:35:26 <DukeDave> It looks like there may be some examples to play with though: http://www.haskell.org/haskellwiki/SDL#Applications_using_SDL
11:35:35 <DukeDave> leino: Personally I use wxHaskell
11:36:07 <DukeDave> leino: http://wxhaskell.sourceforge.net/applications.html
11:36:16 <DukeDave> ^ Is that more what you are looking for?
11:36:19 <leino> DukeDave: wxHaskell doesnt seem to give you "framebuffer access"
11:36:48 <leino> I think I could get what I want here: http://hackage.haskell.org/packages/archive/SDL/0.6.2/doc/html/Graphics-UI-SDL-Types.html#t:Surface
11:37:06 <EvanR-work> good luck with writing pixels to buffers with haskell
11:37:09 <EvanR-work> aint pretty
11:37:12 <leino> but I havent used the FFI before
11:37:26 <EvanR-work> are you sure you dont want a higher level graphics lib
11:37:39 <DukeDave> Erk, that's a little lower level than I have ever needed
11:37:39 <EvanR-work> at least cairo
11:38:00 <leino> EvanR: yeah I'm sure
11:38:35 <kmc> oh cool, didn't know Haskell had cinvoke bindings
11:38:36 <leino> the source for these examples doesn't look *too* bad: http://hackage.haskell.org/packages/archive/SDL-gfx/0.6.0/doc/html/Graphics-UI-SDL-Primitives.html
11:38:42 <leino> (just found those)
11:38:45 <EvanR-work> the only sane way to do pixels in buffers is by assigning to derefenced pointers
11:39:07 <copumpkin> pokety poke
11:39:10 <EvanR-work> good way to drive yourself insane
11:40:09 <EvanR-work> what sucks is that framebuffers are not favored anymore by hardware and driver designers, so they are low performance even on high end computers
11:40:55 <leino> EvanR-work: that's news to me
11:41:23 <EvanR-work> try your sdl code at full rez full refresh rate on X
11:41:25 <leino> basically I just want to wrire a "reference rasterizer"
11:42:02 <leino> *write
11:42:14 <clsmith> hey. is there a function (:: Int -> [a] -> [[a]]) which splits a list into n equal length (except possibly the last one) lists? couldn't find on hoogle
11:42:20 <sm> EvanR-work: why is there no easy framebuffer api in haskell ?
11:42:30 <leino> EvanR-work: don't care all that much about performance, but decent would be nice
11:42:33 <kmc> clsmith, i think the split package has that
11:43:01 <EvanR-work> sm: its backend specific, just like theres no easy GUI api in haskell
11:43:34 <sm> but isn't there even one ? like the SDL one ?
11:43:41 <EvanR-work> clsmith: look up 'chunk'
11:43:59 <EvanR-work> sm: i wouldnt call it easy, not even in C
11:44:37 <EvanR-work> framebuffers are not in style(tm)
11:45:00 <leino> EvanR: define 'framebuffer'
11:45:17 <ski> @wn framebuffer
11:45:18 <lambdabot> No match for "framebuffer".
11:45:23 <leino> in ram?
11:45:34 <clsmith> chunk seems to be different. chunk 2 [1..5] = [[1,2],[3,4],[5]]. i want foo 2 [1..5] = [[1,2,3],[4,5]].
11:45:34 <leino> (i.e. not video card memory)
11:46:17 <ski> > transpose [[1,2],[3,4],[5]]
11:46:18 <lambdabot>   [[1,3,5],[2,4]]
11:46:20 <ski> hmm
11:47:01 <sm> leino: how about a gloss Picture, which can be "A bitmap image with a width, height and a ByteString holding the 32 bit RGBA bitmap data."
11:47:09 <EvanR-work> leino: its an api which presents you with an array of pixels which can be written to
11:47:20 <EvanR-work> implemention is another story
11:47:33 <EvanR-work> currently implementations will be low performance due to hardware and driver environment
11:47:46 <leino> EvanR-work: ok that makes sense then. of course they are out of date
11:47:53 <EvanR-work> lol, out of date
11:47:59 <EvanR-work> the concept expired
11:48:13 <leino> huh?
11:48:29 <EvanR-work> simple apis are good, not bad
11:48:54 <EvanR-work> youre the one who wants to manually draw triangles out of pixels
11:49:18 <sm> leino: or other stuff on hackage, like http://hackage.haskell.org/package/AC-EasyRaster-GTK
11:49:37 <EvanR-work> sm: also look at xlib ;)
11:49:55 <leino> sm:  hey that sounds nice
11:52:20 <leino> I have this loose plan to write a domain-specific language for defining triangle rasterizers
11:52:59 <leino> basically I'm aiming for something like d3d or opengl in flexibility
11:53:15 <EvanR-work> triangle rasterizers because current hardware is optimized for it?
11:53:43 <leino> EvanR-work: all current hardware?
11:53:49 <EvanR-work> no
11:54:04 <EvanR-work> how is that an answer
11:54:22 <leino> it wasn't
11:54:53 <Danl2620> leino: a shader language?
11:55:13 <leino> Danl2620: yes
11:55:19 <ski> @type let blocks :: Integral i => i -> [a] -> [[a]]; blocks n = Data.Foldable.toList . loop where loop [    ] = Data.Sequence.fromList (genericReplicate n []); loop (a:as) = (a:last_block) Data.Sequence.<| init_blocks where init_blocks Data.Sequence.:> last_block = Data.Sequence.viewr (loop as) in blocks
11:55:20 <lambdabot> forall i a. (Integral i) => i -> [a] -> [[a]]
11:55:25 <ski> clsmith : that ^ might work
11:55:26 <sm> leino: also check out bitmap, bitmap-opengl, bitmaps
11:55:52 <sm> man there's a lot of overlapping junior graphics libs now
11:55:58 <leino> sm: yeah, I'm starting to realize that I should go a less "direct" route
11:56:10 <leino> i.e. no framebuffers
11:56:38 <EvanR-work> all the high performance PC hardware systems dont have a framebuffer interface
11:56:46 <EvanR-work> unfortunately
11:57:20 <ski> (clsmith : any data structure supporting queue operations would work)
11:58:37 <ski> oh, `Data.Sequence' is also `Seq' in lambdabot
11:58:39 <mizu_no_oto> Can anyone help me with some fairly simple Enumerator code?  Essentially, I want to print out the values from the Enumerator as the Iteratee gets them
11:58:40 <mizu_no_oto> something like http://hpaste.org/53145
11:59:11 <mizu_no_oto> But this line here doesn't typecheck  f (E.Chunks xs) = mapM_ printData xs >> (E.Iteratee $ E.Continue f)
11:59:12 <leino> EvanR-work, sm: thanks for the input
11:59:32 <ski> > blocks 2 [1..5]
11:59:34 <lambdabot>   [[1,3,5],[2,4]]
11:59:54 <ski> oh, heh
12:00:16 * copumpkin slaps ski
12:00:25 <mizu_no_oto> Iteratee is a newtyped Step wrapped in a monad, so how do I compose an action in the monad with the Iteratee?
12:00:36 <mizu_no_oto> Any help?
12:00:38 <ski> clsmith : sorry, i got confused, and apparently implemented `transpose .: chunks'
12:01:15 <ski> copumpkin : ? :)
12:01:24 <clsmith> okay, thanks for trying ^^;
12:02:46 <mizu_no_oto> Does anyone know how to get that Iteratee working?
12:02:48 <ski> i suppose one could fill in that shape with the original list, basically un`concat'enating it -- there're probably better ways, though
12:03:24 <Danl2620> leino: on the PS3 you can use an SPU processor to pixel shade frame buffer memory by DMAing it to and from the main frame buffer
12:03:49 <Danl2620> leino: you only have 256kb for your code and data, so the memory model is key
12:04:21 <ski> clsmith : ok, so i don't see a better way than to compute the length and divide
12:04:41 <ski> @quote Cale length
12:04:41 <lambdabot> Cale says: Computing lengths is admitting defeat
12:04:46 <leino> Danl2620: no haskell then? ;)
12:05:01 <Danl2620> mizu_no_oto: have some patience... it takes awhile for the knowledgeable to notice
12:05:36 <Danl2620> leino: nope... although if your DSL is compiled the compiler can be haskell
12:05:46 <Cale> ski: What are you looking for?
12:06:05 <leino> Danl2620: yeah that is the eventyal plan. dsl -> c
12:06:19 <leino> or even dsl -> asm
12:06:34 <Cale> ah, split into n equal chunks?
12:06:43 <desaiu> Looking at Haskell programs to be compiled, I frequently see module Main\n where
12:06:48 <desaiu> What is the "where" for?
12:06:49 <Danl2620> or dsl -> shader language
12:07:05 <Cale> desaiu: everything at the top level inside the module is part of that where clause
12:07:19 <Cale> desaiu: A compiler could potentially allow more than one module per file
12:07:27 <augur> anyone familiar with linear logic?
12:07:32 <TomMD> And many do.
12:07:32 <Cale> desaiu: and if it did, then that's how they'd be syntactically separated
12:07:39 * shapr hugs Cale
12:08:06 <Cale> :)
12:08:13 <Cale> TomMD: which ones?
12:08:39 <desaiu> Cale: Where can I find more information on this?
12:08:56 <TomMD> Cale: I wasn't referring to Haskell compilers (some ML, Coq)
12:09:04 <Cale> ah
12:09:13 <Cale> desaiu: I guess the Haskell Report
12:09:33 <Cale> http://www.haskell.org/onlinereport/modules.html
12:09:42 <desaiu> Thank you.
12:09:55 <Cale> But it doesn't say much about the rationale for the keyword 'where' there
12:10:10 <Cale> Syntactically, it could have been left out without affecting things too much
12:10:51 <Danl2620> language designers are loath to admit that files define units of program organization
12:10:51 <Cale> But it sort of agrees with other uses of 'where' in the language (apart from the fact that you're allowed some declarations at the top level which you aren't allowed to make locally)
12:11:15 <Cale> Well, the Report doesn't say anything about files
12:11:23 <Danl2620> ah... exactly!
12:11:24 <Cale> (apart from the bits on I/O)
12:12:15 <Danl2620> our language is so cool that your source code doesn't reside in mere "files"
12:12:17 <RevolverBaer> @pl (\ x -> f x x)
12:12:17 <lambdabot> join f
12:12:19 <Cale> heh
12:13:10 <Cale> not only that, but they didn't define Haskell as lazily evaluated, but as having non-strict semantics, so the Report doesn't tell you anything about the order in which expressions are evaluated :)
12:13:56 <Cale> (which is actually practical for the compiler implementors, but kinda funny in a similar way)
12:14:05 <Danl2620> leaves at least a little language design work for the implementors
12:14:44 <Danl2620> yeah haskell as a language definition is merely interesting.  its ghc that makes it useful and cool.
12:14:54 <ski> augur : a bit
12:14:55 <Cale> Yeah, technically, if it was defined as being lazily evaluated, then you wouldn't be able to do strictness analysis.
12:15:46 <Cale> Well, the original standard is pretty cool (even with all of Haskell 98's warts, it's still a pretty cool language :)
12:16:10 <Cale> But I agree, GHC is even cooler :)
12:17:12 <DanBurton> Even despite -XCrazyWhackInstances?
12:17:49 <Cale> Sure
12:17:58 <Danl2620> or -XTurboBoost
12:18:14 <c_wraith> well.  FlexibleInstances and FlexibleContexts would have been nice as part of H98
12:18:36 <c_wraith> Since it seems it wasn't very hard to implement them, and they were only left out to make H98 easier to implement
12:18:50 <Cale> Yeah, for years, I think FlexibleInstances and FlexibleContexts were turned on by default even if you didn't -fglasgow-exts
12:19:11 <Cale> (this was even before the extensions had formalised names)
12:20:28 <salisbury> Is it wise to nest maps in Haskell?
12:20:39 <yottabit> shapr!
12:20:50 <shapr> ?
12:20:50 <yottabit> the vps is currently down
12:21:00 <yottabit> which is why i'm using this alt nick
12:21:05 <shapr> Which vps?
12:21:10 <yottabit> gnusha.org
12:21:13 <shapr> oh
12:21:14 <yottabit> anywho
12:21:40 <yottabit> shapr: i was going to let you know that lyah says...
12:22:07 <Calvin> Hi, I'm new to Haskell and I have a quick question. With the type : data Tree a = Node (Tree a) (Tree a) | Leaf a, can I declare a function which has a return type of ONLY (Leaf a) ?
12:22:12 <yottabit> "A lot of people coming from OOP get confused by typeclasses because they think they are like classes in object oritented languages. Well, they're not. You can think of them kind of as Java interfaces, only better.
12:22:16 <yottabit> "
12:22:19 <yottabit> awww
12:22:40 <yottabit> maybe shapr will come this way
12:23:54 <TomMD> Calvin: "Leaf a" is not a type, it is a type constructor for "Tree a", which is a type.
12:24:11 <TomMD> Calvin: If you only have a "Leaf a" to return then perhaps your return type should really be just "a"?
12:24:29 <Cale> salisbury: It's not unwise
12:24:37 <Calvin> TomMD Thank you
12:24:41 <Cale> salisbury: There's list fusion rules which will combine them together for you
12:24:53 <Cale> salisbury: So long as -O or -O2 is turned on
12:24:59 <ski> Calvin : no, Haskell has no sub-/super-typing
12:25:12 <ski> (nor refinement typing)
12:25:18 <Calvin> So I have a design problem
12:25:19 <TomMD> An no ponies!
12:25:28 <Calvin> I want to design a little game
12:25:29 <Mathnerd314> is anyone working on a Haskell variant with no typeclasses but sub/super-typing?
12:25:40 <salisbury> Cale: aha, perhaps that flag is what I need
12:25:40 <Cale> salisbury: But of course, map f . map g = map (f . g), so you may just want to rewrite it yourself if it makes your program simpler
12:25:57 <Calvin> So I wrote data Stat = Health Int | Attack Damage
12:26:05 <Calvin> *Attack Int
12:26:06 <ski> @where O'Haskell
12:26:07 <lambdabot> extension to Haskell adding subtyping and records, plus non-blocking reactive communication, by Johan Nordlander, Magnus Carlsson, and Bjrn von Sydow, at <http://web.archive.org/web/20090517021445/
12:26:07 <ski> @where Timber
12:26:07 <lambdabot> http://www.cs.chalmers.se/~nordland/ohaskell/>, also see `Timber'
12:26:08 <lambdabot> concurrent, reactive, event-driven language that was inspired by O'Haskell, <http://timber-lang.org/home.html>. also see `O'Haskell'
12:26:13 <ski> Mathnerd314 ^
12:26:20 <Cale> Mathnerd314: Maybe Timber (which grew out of O'Haskell) is still like that?
12:26:27 <Cale> ah
12:26:27 <Cale> heh
12:26:42 <salisbury> Cale: oh, sorry I should have been more clear. I mean Data.Map
12:26:44 <TomMD> Calvin: That strikes me as an odd type.  In what situation would I expect a Health value _or_ an Attack damage?
12:26:53 <Cale> salisbury: oh, then, it's fine
12:26:57 <salisbury> Cale: Something like Map String (Map String Int)
12:27:07 <Cale> salisbury: Yeah, that's just fine.
12:27:23 <Cale> salisbury: I mean, there's nothing special about the fact that you've nested them
12:27:42 <salisbury> Cale: Thanks, I suppose there must be a bug in my program then.. Look up times are way too large.
12:27:43 <Cale> It doesn't make the lookups any more or less expensive
12:27:44 <ski> @where ErikPoll
12:27:44 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
12:27:45 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
12:27:45 <lambdabot> pdf>
12:27:53 <TomMD> It's so sad.  No one asks for a language with more dependence on type classes.
12:28:01 <ski> Mathnerd314 : ^ might also be interesting, even though it's just theory, no implementation
12:28:03 <Cale> salisbury: It could be just because you're using Strings as keys.
12:28:36 <ski> Mathnerd314 : you might also want to check out "refinement typing"
12:29:17 <acowley> Does anyone know if there is a standard operator that is (<*>), but with right associativity?
12:29:19 <augur> ski: do you know of any rules that look like   G :- D, f : S -> T   G' :- D', x : S   =>   G, G' :- D, D', f x : T, x : S   ?
12:29:47 <conal> augur: hi. just saw your HOAS remark (2.25 hours ago).
12:30:13 <augur> conal: hey :)
12:30:18 <Calvin> TomMD you are right, I do not found any situation, for now.
12:30:22 <Calvin> *find
12:30:24 <salisbury> Cale: Perhaps one of the data structures with Hashable k would be a better alternative then. Its unfortunately necessary to use string keys..
12:30:24 <Abraxas> what is the equivalent (if any) to :t for a defined type, like when i have "type Parser a = String -> Maybe (a, String)" and i want the interpreter to show me Parser Char
12:30:59 <Cale> salisbury: (ByteString or Text are often faster than String)
12:31:05 <ski> augur : `:-' being "entails" ?
12:31:07 <Abraxas> *show me the type of
12:31:13 <Cale> Strings are lazy linked lists of lazy 32 bit Char values
12:31:23 <augur> ski: yeah
12:31:49 <Mathnerd314> augur: where do G and D come from? couldn't you just omit them and have f : S ->T, x : S => f x : T
12:31:58 <Cale> They're really big and spread out in memory, and so when you start getting really picky about efficiency, they're not so great.
12:32:09 <Cale> (but they are damn convenient up to that point)
12:32:14 <ski> Mathnerd314 : they're contexts
12:32:17 <augur> Mathnerd314: theyre typing contexts
12:32:43 <Calvin> Should I use type Health = Int ? Or data Health = Health Int ?
12:32:55 <ski> augur : is the `,' at the right of `:-' meant to be a structural conjunction, or a structural disjunction ?
12:33:09 <Mathnerd314> augur: yeah, but why do you have to give them names? ;-) (I'm really more concerned about D than G)
12:33:13 <augur> ski: lets say disjunction
12:33:16 <c_wraith> newtype Health = Health Int deriving (Ord, Eq, Show, Num)
12:33:17 <TomMD> Calvin: I'd go with the second for now (to get type safety) and add a deriving (Num) clause.
12:33:18 <augur> Mathnerd314: beccause you have to...
12:33:23 <DanBurton> Abraxas: not sure what you're asking for. :i will tell you the definition of a synonym
12:33:41 <c_wraith> TomMD: you can only derive Num with newtype
12:33:41 <TomMD> Right, my bad.
12:33:42 <salisbury> Cale: Aha, thats a good tip, thanks.
12:33:45 <ski> Calvin : the first will just give a synonym, but won't catch any errors using an `Int' meant for another purpose as a `Health'
12:33:54 <Mathnerd314> augur: just assume them... that's what the PL book I'm reading does :p
12:33:58 <Calvin> Yes i tried deriving Num, it returned an error :)
12:34:04 <Abraxas> dan: nm, it was pretty much nonsense
12:34:05 <augur> Mathnerd314: cant
12:34:08 <c_wraith> Calvin: using newtype and the GeneralizedNewTypeDeriving extension, you can derive Num
12:34:20 <c_wraith> or maybe it's GeneralizedNewtypeDeriving
12:34:26 <ski> Calvin : the latter will catch such errors, but require you to explicitly wrap with or match on the data constructor `Health :: Int -> Health', to pass between `Health' and `Int'
12:34:27 <c_wraith> in any case, it needs the extension
12:34:30 <DanBurton> @google generalized newtype deriving haskell
12:34:33 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving
12:34:33 <lambdabot> Title: NewtypeDeriving – Haskell Prime
12:34:41 <TomMD> GeneralizedNewtypeDeriving
12:35:20 <c_wraith> The nice thing about getting a Num instance is that you basically never will have to use the constructor.  You can just use fromIntegral and literals to do all your conversions
12:35:28 <Calvin> Ok, I'm looking for type safety, I will go for data Health
12:35:36 <augur> ski: is that familiar at all?
12:35:37 <c_wraith> Calvin: use a newtype, not data
12:35:41 * hackagebot gps 0.8.2 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.8.2 (ThomasDuBuisson)
12:35:52 <ClockFrog> I'm thinking about learning Haskell, i was wondering does it run on a VM, interpreted or compiled to opcode?
12:35:53 <augur> its like function application but with argument retention
12:35:59 <Abraxas> the :t only gives me type variables, that's no different
12:36:26 <byorgey> ClockFrog: GHC can compile Haskell to native code.
12:36:39 <Abraxas> i expected it to tell me String -> Maybe (a, String) for Parser Char, but why should it
12:36:39 <dafis> ClockFrog: it can run interpreted or compiled to native code
12:36:46 <Abraxas> argh
12:36:53 <ski> augur : i'm checking whether the structural things work out properly atm -- yes, you seem to want contraction on the argument, so possibly that should be in a non-linear context
12:36:54 <byorgey> ClockFrog: but I am not sure why this would make a difference to whether you want to learn it.
12:36:58 <Abraxas> String -> Maybe (Char, String)
12:37:10 <augur> ski: ok
12:37:21 <ClockFrog> i was just wondering
12:37:28 <salisbury> ClockFrog: I would highly recommend Haskell. I've just picked it up myself, and I'm so impressed
12:37:33 <augur> ski: im just wondering if it looks familiar; its slightly non-linear obviously
12:37:45 <DanBurton> surprise! person on #haskell highly recommends Haskell :)
12:37:48 <salisbury> ClockFrog: Its going to become my mainstay language.
12:37:52 <ClockFrog> lol
12:38:07 <mirari> ClockFrog: What other languages are you familiar with? and what kind of programming do you do?
12:38:10 <mkscrg> is there something tricky about cabal sdist? i've got an otherwise working package (developed using cabal-dev), but cabal-dev sdist (or cabal sdist) fail with "cabal: dist/src/sdist.-41346/my-package-0.0.0: does not exist"
12:38:23 <salisbury> hehe
12:38:30 <DanBurton> I highly recommend Java. /sarcasm
12:38:34 <brisingr> Is there an efficient way to get all possible splits of a list, the first list containing n elements?
12:38:48 <Mathnerd314> augur: http://books.google.com/books?id=zas498825CkC&lpg=PP1&dq=call%20by%20push%20value&pg=PR33#v=onepage&q=notation&f=false
12:38:49 <brisingr> short and elegant is what I'm looking for
12:39:13 <DanBurton> brisingr: what do you mean by "splits"?
12:39:20 <augur> Mathnerd314: what am i looking at
12:39:24 <ClockFrog> Object Pascal, Factor, C++, Python a bit of ASM. I program for fun not career
12:39:29 <ClockFrog> so i do many things
12:39:32 <brisingr> so [1,2,3] with n = 2
12:39:33 <brisingr> is
12:39:53 <Mathnerd314> augur: the notation at the end of I.4.2
12:40:05 <brisingr> [([1,2],[3]),([1,3],[2]),([2,3],1)]
12:40:19 <EvanR-work> ClockFrog: ah, a refugee
12:40:22 <brisingr> err, ([2,3],[1])
12:40:23 <dcoutts> mkscrg: you built your cabal-install-0.10 using Cabal library 1.12 (which incidentally required someone to patch the constraints in cabal-install.cabal). That combo results in the bug you describe. Either build the released cabal-install using a version of the Cabal lib it is compatible with, or use the development version of cabal-install
12:40:37 <augur> Mathnerd314: what about it
12:40:40 <ski> augur : so i think if you define `S -> T' as `?S -o T' (for every `S' and `T'), it will work out
12:41:01 <DanBurton> brisingr: challenge accepted. doesn't look like it's in the base libraries
12:41:25 <brisingr> I did manage to do it with explicit recursion
12:41:25 <mkscrg> dcoutts: thanks. i'll give the dev version a try
12:41:39 <brisingr> but it didn't look right, the function
12:41:44 <ski> augur : to derive the rule, you need to be able to pass from  G' :- D', x : S  to  G' :- D', x : S , x : S  so we need to require `S' to be a "why-not"able formula
12:41:51 <salisbury> ClockFrog: If you do get into Haskell, I would recommend getting the IDE Leksah
12:42:04 <EvanR-work> IDEs? :(
12:42:05 <Mathnerd314> augur: he doesn't have any contexts
12:42:07 <augur> ski: do you mean ?S -o T, or do you mean to have ?S in place of all ?S,
12:42:11 <augur> Mathnerd314: uh.. yes it does
12:42:29 <augur> Mathnerd314: oh i see
12:42:53 <augur> Mathnerd314: well whatever
12:43:05 <augur> Mathnerd314: its irrelevant for my issue
12:43:06 <ClockFrog> The reason i am looking into Haskell is to maybe replace Factor as my goto language, kinda feel like Haskell has a better community which i can learn from.
12:43:07 <ski> augur : oh, right, define `S -> T' as `?S -o T', *and* put `x : S' in a non-linear context
12:43:29 <ClockFrog> I normally use Vim insteado an IDE, does Leksah have something special?
12:43:41 <augur> ski: would i need ?S -o T tho? wouldnt ?S decay to S anyway?
12:43:41 <salisbury> EvanR-work: IDEs really help with learning a language.
12:43:53 <EvanR-work> salisbury: i cant say i agree
12:44:00 <EvanR-work> ClockFrog: vim is awesome
12:44:07 <Abraxas> and leksah sucks
12:44:41 <EvanR-work> ClockFrog: but i think the most popular is haskell mode for emacs
12:44:52 <andras> hello folks, I'm trying to install wx with cabal, which fails because old-time-1.0.0.7 fails to build: "System/Time.hsc:253:67: Not in scope: type constructor or class `CSUSeconds'".  I'm using ghc 7.0.4 (Debian testing), is there anything I can do about this?
12:45:01 <ski> augur : so, from `G0 |- D0 , f : S -> T | X0' and `G1 |- D1 | X1 , x : S', derive `G0 , G1 |- D0 , D1 , f x : T | X0 , X1 , x : S'
12:45:32 <dcoutts> andras: yes, use old-time-1.0.0.6 which you'll find is installed already.
12:45:33 <salisbury> EvanR-work: Why not? I find it really helpful. The auto-completion allows my to easily discover new functions. The auto-compiling lets me catch bugs as soon as I make them. That, in particular speeds up my learning.
12:45:34 <ski> augur : where the intension is that `G |- D | X' is interpreted as `G |- D , ?X'
12:46:01 <EvanR-work> salisbury: memorizing names of functions isnt 'learning a language'
12:46:23 <augur> ski: aha, so you're segmenting the right side into functions and non-functions, essentially
12:46:44 <ski> augur : this is similar to the well-known `G | X |- D' judgement being interpreted as `G , !X |- D', only dual
12:46:49 <salisbury> EvanR-work: certainly not, but learning which functions exist so you can go look the up is quite helpful.
12:46:56 <EvanR-work> salisbury: in anycase most normal editors let you autocomplete names of identifiers
12:46:58 <copumpkin> > let (a, b, c) = (5 + c, 3 * a, 3) in (a, b, c) -- autocomplete this
12:46:58 <lambdabot>   (8,24,3)
12:47:00 <augur> ski: link to anything like that?
12:47:06 <EvanR-work> salisbury: thats why we have module documentation
12:47:13 <ski> well, into copy&discardable results, and ones which aren't (necessarily) that
12:47:32 <augur> ski: i mean papers that discuss using something like G | D :- E
12:47:59 <salisbury> EvanR-work: I'm not saying its impossible to do anything without an IDE, just that it is helpful when learning a language.
12:48:23 <EvanR-work> salisbury: you still havent explained how it helps to learn the language
12:48:30 <ClockFrog> I got a question, my only experience of functional programming is Factor which uses a stack, how does things like + and / work if they are written like 5 + 7, how does the + function see both 5 and 7?
12:48:39 <EvanR-work> you only said it autocompletes names
12:49:04 <ski> augur : try the papers on lolli at <http://www.lix.polytechnique.fr/~dale/lolli/>
12:49:05 <salisbury> EvanR-work: No, I also said the auto-compiling is very helpful.
12:49:20 <Cale> ClockFrog: It is passed those things as arguments. The compiler turns all your expressions into trees by parsing.
12:49:38 <EvanR-work> salisbury: up arrow in the xterm works ;)
12:49:44 <EvanR-work> not to mention vim / emacs
12:50:35 <Cale> ClockFrog: and there's a node with + having 5 and 7 as subnodes
12:50:37 <Abraxas> string :: String -> Parser () with type Parser a = String -> Maybe (a, String)...that's string :: String -> String -> Maybe ((), String)?
12:50:41 <andras> dcoutts: I tried the cabal install without --upgrade-dependencies, which indeed uses old-time-1.0.0.6, but I get a new set of errors:
12:50:48 <Abraxas> what good is that
12:51:06 <salisbury> EvanR-work: I just find it easier. I start out using an IDE for every language, then eventually switch to an editor.
12:51:23 <EvanR-work> how about the time it takes to learn the IDE
12:51:30 <Cale> Abraxas: I think the point of your string parser is to succeed when the input matches the given string, and to fail if it doesn't.
12:51:32 <EvanR-work> seems dumb when youre going to quit using it later
12:52:16 <andras> dcoutts: Resolving dependencies... <command line>: cannot satisfy -package Cabal-1.10.2.0: Cabal-1.10.2.0-672d55bacb8b0905cbd8b35608c61a0f is unusable due to missing or recursive dependencies: directory-1.1.0.0-2841e9487a6005027e4296ebdc166af9 old-time-1.0.0.6-c99aff00768a1a5d56a60f5e0feff96f process-1.0.1.5-a942c1d177099fd041f95dc8c0ffef99 (use -v for more information) cabal: Error: some packages failed to install: time-1.2.0.3 failed 
12:52:44 <Abraxas> and success is ()?
12:53:06 <Cale> Abraxas: Success is  Just ((), rest of input), and failure is Nothing
12:53:18 <dcoutts> andras: if you've been using --upgrade-dependencies you'll likely have lots of duplicate packages between your global and per-user package dbs. Those confuse cabal. Elimate the duplicates and don't use --upgrade-dependencies.
12:53:37 <augur> ski: ill give it a look
12:53:41 <brisingr> maybe I should ask Cale, he's god
12:53:47 <brisingr> any chance I could make split monadic
12:53:48 <salisbury> EvanR-work: Its a small effort for Leksah. When I started in C/C++ I used eclipse, which I was already familiar with from before I kicked the java habit, so it wasn't so bad
12:53:53 <Abraxas> ok makes sense, what evan already said ages ago :D
12:53:56 <brisingr> like return all possible combinations of splits?
12:54:03 <Abraxas> no not evan
12:54:14 <Abraxas> edwardk
12:54:20 <EvanR-work> autocomplete ftw
12:54:26 <ski> augur : hm, btw, consider a rule saying that from `Gamma |- A_0',`Gamma , A_0 |- A_1',`Gamma , A_0 , A_1 |- A_2',...,`Gamma , A_0 , A_1 , ... , A_n |- A_{n+1}', derive `Gamma |- A_{n+1}'  (basically : anything already derived may be used in later derivations)
12:54:44 <EvanR-work> salisbury: c/c++ is a non entity
12:54:51 <Cale> brisingr: What do you mean by split?
12:55:01 <ski> (incidentally, that's related to complete/strong/transfinite induction)
12:55:03 <brisingr> like superSplit 2 [1..3]
12:55:04 <Cale> brisingr: It sounds like a good fit for the list monad...
12:55:05 <ski> augur : we can consider a dual rule (generalizing slightly) that from `Gamma , A_0 |-',`Gamma , A_1 |- A_0',`Gamma , A_2 |- A_0 , A_1',...,`Gamma , A_{n+1} |- A_0 , A_1 , ... , A_n' one derives `Gamma , A_{n+1} |-'
12:55:10 <brisingr> = [([1,2],[3]),([1,3],[2]),([2,3],[1])]
12:55:13 <salisbury> EvanR-work: Pardon?
12:55:20 <Cale> oh, sure
12:55:21 <hpaste> DanBurton pasted “brisingr splits” at http://hpaste.org/53171
12:55:30 <Cale> brisingr: I recommend starting from:
12:55:41 <brisingr> managed to do a brute recursion method
12:55:42 <salisbury> EvanR-work: by C/C++ I mean C and C++
12:55:47 <brisingr> but It's ugly
12:55:56 <EvanR-work> salisbury: thats like saying i use to use ada/malbolge
12:56:00 <Cale> select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
12:56:15 <andras> dcoutts: there are no global packages on either installation I'm trying to install wx into
12:56:19 <ski> augur : so, for each `n', we prove that from `A_n' some of the `A_i' for `i < n' must hold, reducing the possible conclusions/results down to zero alternatives, at which point we've refuted `A_{n+1}'
12:56:40 <ski> augur : your rule seemed to me somewhat similar to this latter rule
12:57:02 <augur> ski: hmm
12:57:10 <brisingr> Cale: thanks, I'll get started
12:57:37 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
12:57:38 <lambdabot>  Defined.
12:57:40 <andras> dcoutts: I started using --upgrade-dependencies because the plain install of wx failed (also a build failure of a depended-upon package, can't remember the exact cause)
12:57:42 <Cale> > runStateT (replicateM 2 (StateT select)) [1,2,3]
12:57:44 <lambdabot>   [([1,2],[3]),([1,3],[2]),([2,1],[3]),([2,3],[1]),([3,1],[2]),([3,2],[1])]
12:57:57 <Cale> oh, wrong type of selection :)
12:58:05 <dcoutts> andras: when you run ghc-pkg list it shows the contents of first the global package db and then the user package db
12:58:08 <brisingr> but that's still so cool
12:58:13 <ski> augur : i'm not sure there's a connection, i was just associating
12:58:23 <salisbury> EvanR-work: I learnt them at the same time
12:58:41 <ski> augur : may i ask why you're considering your rule ?
12:58:44 <salisbury> EvanR-work: became acquainted with, rather.
12:59:11 <dcoutts> andras: it's better to selectively use --constraint='blah >= x.y' rather than trying to upgrade absolutely everything.
12:59:26 <dcoutts> andras: upgrading core packages is almost never a good idea
12:59:54 <augur> ski: syntax of movement
13:00:28 <acowley> Is there no standard function with type (a -> Maybe b) -> [a] -> Maybe b that is like Data.List.find, but returns the result of the predicate?
13:00:39 <brisingr> Cale: that's magic
13:00:48 <ski> augur : so, you're trying to in some sense retain `x : S', while forming `f x : T' ?
13:00:50 <andras> dcoutts: sure... will play with ghc-pkg a bit, thanks for the info
13:01:13 <brisingr> we should move every line of code Cale writes to wiki/blow_your_mind
13:01:33 <brisingr> Man I wish I were like you without all the effort involved
13:01:56 <ski> brisingr : that `select' example is easy
13:02:11 <brisingr> the state one
13:02:11 <ski> it just selects an element twice from the list
13:02:12 <brisingr> I still can't fully grasp state
13:02:25 <brisingr> the select one is easy, but the state one
13:02:31 <brisingr> s/one/part/
13:02:48 <DanBurton> :t StateT
13:02:49 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
13:03:02 <augur> ski: yeah, basically the idea is that "full phrases" (ie not function-typed things) can be reused
13:03:18 <ski> > [([x0,x1],xs1) | (x0,xs0) <- select [1,2,3] , (x1,xs1) <- select xs0]
13:03:20 <lambdabot>   [([1,2],[3]),([1,3],[2]),([2,1],[3]),([2,3],[1]),([3,1],[2]),([3,2],[1])]
13:03:26 <augur> ski: so you want to keep them around somewhere
13:03:43 <ski> brisingr : ^ that's what the `replicateM' amounts to
13:04:07 <brisingr> actually I needed replicateM couple of days ago
13:04:13 <brisingr> where's replicateM when you need it?
13:04:22 <ski> augur : yeah, but i suspect you really want `x : S' with `f x : T', *conjunctively*, not disjunctively
13:04:53 <augur> ski: probably. im not fixed to the LL interpretation of what im writing :)
13:05:36 <ski> brisingr : in `select :: [a] -> [] (a,[a])', `[a]' is the state type, and the other `a' is the monadic result, the `[]' accounts for the nondeterminism of selecting an element
13:06:17 <ski> augur : possibly you're really interesting in an ordered logic of some kind, yes ?
13:06:38 <ski> s/interesting/interested/
13:06:52 <ski> @type StateT select
13:06:53 <lambdabot> forall a. StateT [a] [] a
13:07:05 <ski> @type replicateM 2 (StateT select)
13:07:06 <lambdabot> forall a. StateT [a] [] [a]
13:07:51 <brisingr> and runStateT runs StateT, right?
13:07:59 <ski> aye
13:08:14 <ski> @type (runState . replicateM 2 . StateT) select
13:08:16 <lambdabot>     Couldn't match expected type `Identity (a, [t])'
13:08:16 <lambdabot>            against inferred type `[(t, [t])]'
13:08:16 <lambdabot>     In the first argument of `(runState
13:08:24 <brisingr> so State is not really a "state" it's a "state runner"
13:08:27 <ski> @type (runStateT . replicateM 2 . StateT) select
13:08:28 <lambdabot> forall a. [a] -> [([a], [a])]
13:08:34 <ski> @type runStateT . replicateM 2 . StateT
13:08:35 <lambdabot> forall s (m :: * -> *) a. (Monad m) => (s -> m (a, s)) -> s -> m ([a], s)
13:08:44 <ski> brisingr : yes, it's a state (threading) monad
13:09:12 <ski> brisingr : in `StateT s m a', `s' is the state type, and `m' is the underlying monad type (and `a' is the monadic result type)
13:09:25 <ski> @unmtl StateT s m a
13:09:26 <lambdabot> s -> m (a, s)
13:09:30 <Cale> StateT and ContT can be really effective in oneliners like that
13:09:38 <Cale> er, and Cont rather
13:09:44 <augur> ski: actually no, linear order doesnt matter to me
13:09:48 <Cale> I don't think I've actually used ContT like that before :)
13:09:54 <brisingr> (just thinking out loud here) so when I try to understand State or StateT I should look towards ((->) r)
13:10:09 <Cale> brisingr: If you want, I can explain how State works
13:10:20 <brisingr> sure, if it isn't any trouble
13:10:38 <Cale> It takes a little while, so perhaps come to #haskell-overflow so that it's easier to follow everything :)
13:10:40 <ski> Cale : istr a `Cont' or `ContT' example, but i can't recall the details atm
13:10:45 <brisingr> sure
13:11:01 <Cale> ski: For combining a bunch of withFoo-style functions
13:11:02 <andras> dcoutts: still stuck -- wxcore-0.12.1.7 fails with "ignore: parse error : //WXCOLORREF wxColour_GetPixel( TSelf(wxColour) _obj );", apparently while "parsing: src/include/stc_gen.h"
13:11:16 <Cale> ski: or nesting one of them a bunch of times
13:11:37 <dcoutts> andras: that's a bug in the package itself then, not a dependency problem as such. You'll have to get help from the wx developers.
13:11:47 <ski> Cale : istr the example involved `mapM'ing or `mapM_' over a list, in `Cont' or `ContM'
13:12:06 <ski> yea
13:12:57 <ski> (brisingr : btw, note that `ST' is "State Threads" (not "Transformer"))
13:13:20 <mkscrg> dcoutts: you mentoined i could give the dev build of cabal-install a try. can you recommend a commit where it builds/runs? (current HEAD doesn't build)
13:13:31 <augur> ski: linear order for me can be taken to be irrelevant
13:13:40 <augur> so basically abstract syntax not concrete syntax
13:13:48 <dcoutts> mkscrg: current head of cabal should build, what's the problem?
13:13:58 <ski> augur : ok
13:14:17 <ski> is this maybe related to gaps in relative clauses ?
13:14:24 <augur> ski: no :)
13:14:30 <augur> its related to more fundamental issues
13:14:44 <mkscrg> [43 of 44] Compiling Distribution.Client.Install ( Distribution/Client/Install.hs, dist/build/cabal/cabal-tmp/Distribution/Client/Install.o )
13:14:44 <mkscrg> Distribution/Client/Install.hs:103:12:
13:14:44 <mkscrg>     Module
13:14:44 <mkscrg>     `Distribution.PackageDescription'
13:14:45 <mkscrg>     does not export
13:14:45 <mkscrg>     `Benchmark(..)'
13:14:58 <mkscrg> ah multiline spam, sorry folks
13:15:25 <dcoutts> mkscrg: is that the current head?
13:15:43 <leino> andras: I had similar erros a few days ago, then I followed the instructions at: http://www.haskell.org/haskellwiki/WxHaskell/Install and it worked out all right. (I had some debian packages missing)
13:16:27 <dcoutts> mkscrg: I think I fixed that three days ago
13:16:30 <ski> augur : hm, would it help if i read your paper (i seem to have misplaced the link) ?
13:16:54 <mkscrg> dcoutts: i pulled a snapshot from the commit marked master on the git mirror
13:17:27 <augur> ski: no no its not relevant to that
13:17:33 <augur> this is entirely unrelated
13:17:48 <mkscrg> dcoutts: ah, it looks like those are not listed chronologically. O_o
13:18:09 <dcoutts> mkscrg: sorry I've no idea about the git mirror
13:18:46 <mkscrg> dcoutts: i'll get it from darcs instead. seems more reliable
13:21:29 <basvandijk> mkscrg: Are you using ghc-7.2.1 to build cabal-install ?
13:21:30 <ben> Help, I rewrote my concise, clean and high-level code to be ugly, boilerplatey and confusing, and it didn't get any faster. What am I doing wrong?
13:21:45 <mkscrg> basvandijk: yes
13:22:14 <basvandijk> mkscrg: then you get the error because cabal uses the Cabal library that comes with ghc-7.2.1
13:22:28 <basvandijk> Cabal-1.12.0
13:23:08 <basvandijk> to install cabal-install use cabal install --preference=Cabal==1.11.3
13:23:10 <andras> dcoutts: ok, thanks a lot
13:23:40 <leino> andras: do you have g++ installed?
13:24:06 <dcoutts> basvandijk: the reason I pointed mkscrg to the latest version is that the latest cabal-install has a dependency on Cabal>=1.11.3, so no --preference etc is needed
13:25:35 <andras> leino: yes, I have.  sorry I missed your previous post, will look it up now
13:26:17 <ClockFrog> what does | and <- mean in haskell?
13:26:20 <leino> andras: missing debian packages was the problem for me. I had those parse errors in cabal also
13:26:47 <basvandijk> dcoutts: but the Cabal that comes with ghc-7.2.1 is version 1.12.0 which is higher than the version of HEAD. So if he cabal installs cabal-install cabal will pick 1.12.0 which does not include the Benchmarks stuff
13:27:02 <dcoutts> basvandijk: oh yes you're right. Hmm.
13:27:09 <ski> ClockFrog : show the code you wonder about
13:27:10 <basvandijk> I got this error myself today
13:27:11 <dcoutts> basvandijk: I should bump it to 1.13.x
13:27:23 <basvandijk> dcoutts: that would be nice!
13:27:24 <ski> ClockFrog : you are probably either looking at a list comprehension, or at a pattern guard
13:27:40 <ClockFrog> [x*2 | x <- [1..10], x*2 >= 12]
13:27:48 <ski> that is a list comprehension
13:28:04 <DanBurton> > [x*2 | x <- [1..10], x*2 >= 12]
13:28:06 <lambdabot>   [12,14,16,18,20]
13:28:15 <ski> it means : the list of all `x*2's, where `x' is taken from the list `[1..10]' and `x*2 >= 12' is `True'
13:28:40 <ski> it's one way to loop over a list, filtering out some of the elements, collecting the rest of the results in a new list
13:29:03 <DanBurton> it's meant to reflect set notation
13:29:29 * DanBurton wonders if lambdabot has monad comprehensions
13:29:41 <DanBurton> > [x | x <- Just 3, x < 2]
13:29:42 <lambdabot>   Couldn't match expected type `[t]'
13:29:42 <lambdabot>         against inferred type `Data.Mayb...
13:29:46 <DanBurton> nope
13:29:46 <ski> > [(x,y) | x <- [0,1,2] , y <- [0,1,2] , x /= y]  -- you can also do "nested loops" with it
13:29:46 <ClockFrog> oh i get it now
13:29:47 <lambdabot>   [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]
13:30:03 <ClockFrog> cheers
13:30:04 <ski> > [(x,y) | x <- [0,1,2] , y <- [3,4]]
13:30:05 <lambdabot>   [(0,3),(0,4),(1,3),(1,4),(2,3),(2,4)]
13:30:17 <ski> @undo [x*2 | x <- [1..10], x*2 >= 12]
13:30:18 <lambdabot> concatMap (\ x -> if x * 2 >= 12 then [x * 2] else []) [1 .. 10]
13:30:19 <dcoutts> basvandijk: done
13:30:26 <basvandijk> dcoutts: thanks!
13:30:26 <ski> @undo [(x,y) | x <- [0,1,2] , y <- [3,4]]
13:30:27 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [3, 4]) [0, 1, 2]
13:30:44 <augur> ski: im just trying to come up with a formalization of typical minimalist syntactic theories
13:30:59 <augur> where you have two primary operations, merge and move
13:31:14 <augur> where move is just merge that reuses its argument from something thats already been used
13:31:24 <ski> "merge" being a kind of composition/application of two phrases ?
13:31:45 <augur> ski: basically function application
13:31:57 <ski> both forwards and backwards, i assume
13:32:10 <basvandijk> dcoutts: What do you think about adding a logo field to cabal? (instead of the name convention logo.svg/logo.png that I'm currently using)
13:32:18 <augur> yeah. we usually treat it as being non-directional
13:32:25 <augur> and leave linearization issues to some other process
13:32:28 <ski> (including lifting to handle quantifiers ? or using composable continuations ?)
13:32:39 <dcoutts> basvandijk: I think by convention is fine really, it's certainly easier to start there
13:32:54 <augur> ski: well this is purely syntactic, not semantic, so semantic things like that are also left to another process
13:32:56 <dcoutts> basvandijk: should I read the thread about this, is there a controversy?
13:33:11 <ski> augur : ok
13:33:20 <basvandijk> dcoutts: Not really controversy.
13:34:46 <ski> augur : anyway, i think you want structural conjunction
13:34:53 <augur> ski: probably
13:35:03 <augur> i really didnt want to specify either way :)
13:35:44 <dcoutts> basvandijk: Changelog and README would be similar "by convention" things
13:36:01 <basvandijk> dcoutts: indeed
13:36:03 <dcoutts> basvandijk: there's also in principle no problem in having both
13:36:28 <dcoutts> basvandijk: e.g. if someone wants to not use the convention and put the files elsewhere or customise it in some other way
13:37:11 <dcoutts> basvandijk: re size, I suggest we limit the size
13:37:39 <dcoutts> basvandijk: which might be tricky
13:37:54 <basvandijk> dcoutts: I already added .logo {height:200px;} to the css
13:38:13 <dcoutts> basvandijk: mm, the visual problem there will be logos that are less than that size and have to be stretched
13:38:59 <roconnor> ski: I have some follow-up on our discussion on our Oct 7th discussion on probability if you want to join me in #haskell-blah
13:39:32 <basvandijk> dcoutts: there's also the max-height property. However I couldn't quickly get nice results with that.
13:39:56 <basvandijk> http://www.w3schools.com/cssref/default.asp#dimension
13:40:44 <ben> Also I didn't know you could have pattern guards with the patterns in case expressions
13:40:49 <ben> they're really the best kind of expression
13:40:53 <dcoutts> basvandijk: or we could get the size using pngload package (not entirely a serious suggestion)
13:41:55 <basvandijk> dcoutts: Mmm that could be a nice option
13:42:45 <basvandijk> dcoutts: An additional advantage to using pngload is that we can actually check the logo.png is a png file
13:42:57 <dcoutts> basvandijk: right
13:43:26 <dcoutts> basvandijk: it's not clear really how much we should be checking the content of packages we serve
13:44:00 <dcoutts> or if we should just trust package uploaders
13:44:21 <dcoutts> the opportunities for xss are pretty big
13:44:23 <basvandijk> dcoutts: The most important thing to watch out for is for XSS
13:44:27 <basvandijk> dcoutts: right
13:44:28 <dcoutts> heh
13:44:45 <dcoutts> basvandijk: if we're serving the content of tarballs then we're wide open to that
13:45:00 <dcoutts> if we allow maintainers to upload their own docs, same issue
13:45:10 <dcoutts> but these are enormously useful things to be able to do
13:45:23 <dcoutts> and we do mostly trust package authors to be sensible
13:45:27 <basvandijk> dcoutts: not as long as we escape all the responses
13:45:46 <augur> ski: im mostly not worried what the operator on the right is because you dont ever use the majority of the LL inference rules anyway
13:45:50 <dcoutts> basvandijk: haddock docs contain javascript
13:46:04 <basvandijk> dcoutts: ok
13:49:33 <augur> what do you call the text to which a footnote is a footnote
13:50:04 <dcoutts> footnotee? :-)
13:50:09 <augur> :P
13:50:54 <mkscrg> dcoutts: catching up on your convo with basvandijk: since ghc7.2 includes Cabal 1.12 and the cabal-install HEAD now requires 1.13, how do i go about building ghc7.2 and bootstrapping cabal-install?
13:51:25 <dcoutts> mkscrg: install dev versions of Cabal and cabal-install
13:51:34 <dcoutts> they're in the same darcs repo
13:52:13 <cfricke> Hey there, I have a question regarding syntactic correctness of placing definitions underneath a where clause. In Simon Thompson's latest revision he suggests a layout in which the statements line up with the where's 'w'. However, throughout the book this is inconsistent. Most of the time the statements are indented with 2 spaces, creating a new column. I know it narrows down to preference, but what would be the most preferable choice?
13:53:42 <shachaf> cfricke: I like to indent definitions past the w.
13:54:01 <shachaf> What I actually tend to do is indent most things with four spaces, but "where" with only two.
13:54:04 <mkscrg> dcoutts: will the cabal version regex in bootstrap.sh be a problem?
13:54:05 <shachaf> Which is kind of weird.
13:54:08 <ion> I figured the State monad can be implemented rather succinctly in terms of fmap and join: fmap f st = State (first f . runState st); join st = State (uncurry runState . runState st)
13:54:25 <cfricke> shachaf: I read somewhere that this is actually quite common.
13:54:26 <dcoutts> mkscrg: oh you might need to adjust those. I'll happily accept a patch
13:54:27 <cgroza> When should one use a let or a when?
13:54:41 <DanBurton> shachaf: I used to do that, too. I'm trying to conform more closely with emacs default indentation habbits for haskell mode
13:54:47 <mkscrg> dcoutts: will do
13:55:03 <dafis> shachaf: it may be weird, but I do it too
13:55:38 <DanBurton> ion: And return?
13:55:54 <shachaf> DanBurton: Conformist.
13:56:14 <DanBurton> :)
13:57:24 <ion> danburton: pure a = State ((,) a)
13:57:37 <cfricke> DanBurton: And how does that default indentation look like?
13:58:03 <DanBurton> cfricke: whenever you need to indent, only use 2 more spaces
13:58:41 <DanBurton> cfricke: and the where clause is indented only 2 spaces deeper than the function name it pertains to
13:59:19 <cfricke> DanBurton: Ah, sweet. That's how I do it, anyway. But I am still confused as to why the where clause actually works, when not indented at all.
13:59:47 <DanBurton> cfricke: Syntactic magic? :)
13:59:51 <DanBurton> @where haskell2010
13:59:53 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/
14:00:03 <cfricke> DanBurton: Heh. Already looking.
14:00:39 <basvandijk> dcoutts: sigh... I just read SVG is also vurnerable to XSS since you can embed javascript in it. I see two solutions: The easy way: drop support for SVG logos. The hard way: Filter the SVG.
14:01:03 <dcoutts> basvandijk: or decide we trust package authors
14:01:32 <dcoutts> basvandijk: or provide a method to serve all user content from another server
14:01:52 <dcoutts> from another domain
14:02:13 <basvandijk> dcoutts: interesting
14:03:06 <dcoutts> basvandijk: I'm not entierly sure on the rules browsers apply there
14:05:58 <dcoutts> basvandijk: oh, that may only work for iframes
14:06:05 <dcoutts> ie no good for svg logo
14:06:18 <dcoutts> basvandijk: see http://bottiger.org/wrote/21-mozillas-content-security-policy
14:06:28 <dcoutts> and http://bottiger.org/wrote/22-Mitigating-Cross-Site-Scripting
14:06:46 <basvandijk> dcoutts: will read
14:10:40 <c_wraith> holy crap, that author list is long on the "Giving Haskell a Promotion" paper
14:11:06 <c_wraith> also, Stephanie Weirich sounds really familiar...  Why?
14:12:43 <basvandijk> dcoutts: It is possible to embed the SVG logo in an iframe: <iframe src="http://hackageusercontent.org/package/logo.svg"></iframe> However you do get ugly borders around the frame.
14:12:49 <c_wraith> Oh, she's been a part of a lot of the other haskell type system research I've read about
14:12:59 <bfig> how do you fold Data Nat = Zero | Succ Nat to factorial?
14:13:06 <dafis> c_wraith: 'cause she's published a couple of things together with SPJ?
14:13:23 <Quantumplation> Is there a way to rearrange the parameters of a function for the purpose of currying that looks a bit nicer than using a Lambda or where?
14:13:47 <c_wraith> Quantumplation: there's flip and such
14:13:48 <dafis> Quantumplation: in easy cases, flip?
14:13:48 <bfig> you need to get a sort of accumulating parameter from the inside and then destroy it at the last step right?
14:13:51 <shachaf> Quantumplation: You can use flip (I don't recommend it) or backticks.
14:13:59 <c_wraith> @pl \x -> f x y
14:13:59 <lambdabot> flip f y
14:14:05 <shachaf> Quantumplation: But, really, just use a lambda or something. Pointy style isn't evil.
14:14:08 <Quantumplation> lol ok
14:14:12 <c_wraith> @pl \x y -> f x y z
14:14:13 <lambdabot> flip flip z . f
14:14:18 <c_wraith> @pl \x y -> f x y z q
14:14:18 <lambdabot> flip flip q . flip flip z . f
14:14:24 <c_wraith> and now you see why flip is bad
14:14:25 <c_wraith> :)
14:14:35 <basvandijk> bfig: just give Nat a Num instance and use your regular definition for factorial
14:14:41 <Quantumplation> haha
14:15:09 <shachaf> @ty flip flip
14:15:10 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
14:15:12 <shachaf> Ugh, Cale.
14:15:13 <bfig> basvandijk, not the point really...
14:15:24 <c_wraith> :t Prelude.flip Prelude.flip
14:15:25 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
14:15:48 <monochrom> basvandijk, dcoutts: use CSS rules to get rid of the iframe border. iframe { border: none }
14:16:14 <basvandijk> monochrom: nice
14:16:23 <bfig> fact Zero = 1; fact ( Succ t ) == ? you can't, right?
14:16:52 <c_wraith> bfig: sure you can.  it's just going to get ugly.
14:16:55 <bfig> you need to know your predecessors to do it so you need to add some structure
14:16:58 <Cale> shachaf: To be honest, when things get crazy like that, the functor definitions of things actually help me keep track of what's happening in my head
14:17:13 <shachaf> Cale: Really?
14:17:19 <Cale> yeah, particularly with (.)
14:17:22 <c_wraith> bfig: yes, it's not going to be a single recursion.
14:17:25 <bfig> c_wraith, you can't fold a function f:Nat -> Int with that property
14:17:26 * shachaf expects that there's intuition to be gained from understanding what Cale is referring to.
14:17:34 <monochrom> actually iframe also has attribute frameborder="0"
14:17:47 <Cale> flip isn't quite as intuitive...
14:17:49 <c_wraith> bfig: ah, you mean it can't be implemented as a single fold.  No, it's larger than that recursion structure
14:18:04 <c_wraith> bfig: well, it can't be implemented as a single foldl.  It should be possible as a foldr
14:18:09 <Cale> but fmap can be much more intuitive than partial applications and sections of (.)
14:18:22 <shachaf> Cale: By the way, I think I buy Control.Category.. a little more than fmap.
14:18:44 <shachaf> Well, Semigroupoid, but that doesn't exist. :-)
14:18:54 <bfig> c_wraith, what do you mean by larger than that recursion structure?
14:19:44 <Cale> shachaf: While I don't really have anything against Control.Category, my main problem with having it steal (.) is that it's not really anywhere close to as common as Functor
14:20:07 <Cale> I'd be perfectly happy with <<< for Control.Category
14:21:04 <shachaf> Cale: Right, but take e.g. Data.Lens.
14:21:20 <shachaf> Cale: At least with Control.Category, (.) is always composition.
14:22:10 <Cale> I compose lenses together infrequently enough that I'm happy typing 3 characters for it :)
14:22:22 <Cale> But I use fmap a lot more than that
14:22:36 <shachaf> More than three characters' worth?
14:22:38 <Cale> Maybe it's just the nature of the sort of programs I write...
14:23:15 <Cale> But it seems to me that fmap is central enough to deserve some really good names :)
14:23:26 <Cale> (I suggest both (.) and map)
14:23:39 <shachaf> I certainly don't disagree on map.
14:23:49 <shachaf> Cale: I also find the ambiguity a bit confusing.
14:23:49 <ski> augur : i don't have a problem if you use structural conjunction on the right instead (that could e.g. be useful for pattern-matching). but you have to be careful that you don't inadvertently use invalid rules as a result. it's probably best to restrict the system to not use/include any features you don't want/need
14:23:56 <Cale> Right, that's less controversial in my head too :)
14:24:02 <Cale> Which ambiguity? :)
14:24:08 <ski> @tell augur i don't have a problem if you use structural conjunction on the right instead (that could e.g. be useful for pattern-matching). but you have to be careful that you don't inadvertently use invalid rules as a result. it's probably best to restrict the system to not use/include any features you don't want/need
14:24:09 <lambdabot> Consider it noted.
14:24:11 <shachaf> When I see (.) in Caleskell, I'm not quite sure what it'll do.
14:24:31 <Cale> ski: haha, at first I thought that was someone @remembering your statement
14:24:39 * ski grins
14:24:46 <shachaf> I guess it's because I think of composition on its own rather than as a special case of fmapping.
14:25:07 <bfig> c_wraith, so it is not clear now: is there an f such that fold f :: Nat -> Int ?
14:25:12 <Cale> I suppose...
14:25:26 <shachaf> "f . g . [1,2,3]" looks weird to me.
14:25:27 <bfig> (and fold f n = n! ) ?
14:25:34 <Cale> But you do at least get that  f . (g . x) = (f . g) . x
14:25:41 <shachaf> Cale: When it type-checks. :-)
14:25:45 <Cale> yeah
14:25:46 <basvandijk> dcoutts: The pages you referred to also give a nice way of combatting XSS: http://bottiger.org/wrote/21-mozillas-content-security-policy
14:25:46 <shachaf> I guess you want infixr .
14:26:04 <shachaf> I also think it might cause confusing type errors.
14:26:06 <c_wraith> bfig: as I understand it, foldr corresponds to primitive recursion, which is capable of expressing the factorial operation
14:26:06 <Cale> which will be exactly when f and g are functions that line up, and x is any functorial value
14:26:15 <dcoutts> basvandijk: but it'd need to be done in combination with serving user content from a different domain
14:26:17 <Cale> (which lines up with g's type)
14:26:56 <Cale> I worried about this too at first, but the fact that the functor law turns into associativity kinda convinced me that it's not bad :)
14:27:59 <Cale> You can think of lists as being encoded by functions on a finite domain too :)
14:28:19 <Cale> and then the (.) makes sense as composition :)
14:28:46 <d-snp> hey, I encountered this in a haskell file: {-# INLINE  tcp_init_host     #-}
14:28:55 <d-snp> what does that mean, is that like C's inline?
14:28:57 <Cale> (i.e. functions from indices to elements)
14:29:23 <c_wraith> d-snp: {-# ... #-} is the pragma syntax.  The inline pragma tells the compiler it should try to inline that function, if it can.
14:29:30 <Cale> Or rather than finite domain, an initial prefix of the naturals :)
14:29:31 <d-snp> alright
14:29:37 <c_wraith> d-snp: well, inline the definition, it's not necessarily a function
14:29:48 <d-snp> pretty weird pragma syntax :P
14:30:01 <Cale> d-snp: well, it has the advantage that it's a comment
14:30:19 <Cale> d-snp: and so compilers which don't understand the pragma syntax will ignore it
14:30:28 <d-snp> ohh I see
14:30:29 <d-snp> nice
14:30:41 <d-snp> everything starting with {- is a comment then?
14:30:53 <d-snp> because I've seen {--
14:30:57 <thoughtpolice> byorgey: great job on the promotion work. i just skimmed the paper and it seems very nice (it totally skipped my mind you could define HList with a promoted [] constructor!)
14:31:00 <Cale> Yeah, there are two comment styles {- like this -}  and -- to the end of line
14:31:10 <thoughtpolice> d-snp: {- is a comment, the {-- is a particular idiom to make it easier to snip pieces of code in/out
14:31:19 <d-snp> ok
14:31:19 <Cale> Note that -- can't be immediately followed by a symbol character, or it becomes an infix operator
14:31:25 <thoughtpolice> people usually do something like {-- ... code i may play with ... --}
14:31:28 <Cale> --> is a valid infix operator name ;)
14:31:37 <thoughtpolice> then if you just want to enable it, you can change that first version to be {--}
14:31:42 <thoughtpolice> kinda like #if 0 in C :P
14:32:12 <d-snp> ah
14:32:21 <Cale> thoughtpolice: actually, I'd never seen that before, that's really cute
14:33:21 <thoughtpolice> Cale: yeah! i use it all the time now
14:34:25 <thoughtpolice> (i think i picked it up from /r/haskell fwiw)
14:34:31 <Cale> d-snp: another thing about {- -} is that they nest
14:34:53 <Cale> So you can {- have a comment {- with another comment inside -} -}
14:35:07 <Cale> unlike /* */ in C
14:35:11 <ion> FWIW, so do --. ;-)
14:35:16 <ion> foo -- comment -- another comment
14:35:22 <tromp> but nesting is messed  up by {--} .. code i may play with ... --}
14:35:32 <Cale> Well, sure, but that's less surprising, because there's no terminator
14:35:48 <Cale> tromp: er, is it?
14:35:51 <ion> I’m just joking.
14:36:29 <Cale> tromp: if there are {- -} comments inside the code to play with, it seems like it should work sensibly
14:36:45 <Cale> (which is good)
14:36:49 <tromp> Cale: imagine {-  -} AROUND that whole stuff
14:36:49 <d-snp> that is pretty surprising indeed
14:37:16 <Cale> tromp: ah, okay, that way around, yeah
14:37:28 <Eduard_Munteanu> Double commenting elimination? :)
14:37:32 <Cale> well...
14:37:54 <tromp> so to uncomment you should {--} ... code i may play with ... {--}
14:38:00 <Cale> as long as the lines are separated...
14:38:07 <Cale> heh
14:38:23 <mdempsky> What's the best way to use the type system to express a fixed-size ByteString?  E.g., I want a function that only accepts bytestrings of length 32.
14:38:34 <Cale> mdempsky: That's not easy
14:38:40 <shachaf> That's not really ByteStrings.
14:39:03 <monochrom> the best way to win is not to play
14:39:08 <mdempsky> fixed-size sequence of byte values
14:39:13 <d-snp> so I just read this: http://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration, which explains the strictness declarations
14:39:34 <d-snp> but it doesn't really explain why you would define something with an exclamation mark
14:39:43 <Cale> mdempsky: It may become easier when we have type level naturals. Currently you have to encode the naturals at the type level somehow, and operations on them, and then define a bunch of operations on ByteStrings which keep track of lengths at the type level and so on.
14:39:59 <Cale> mdempsky: It's probably not worth doing in most cases, and will certainly be inconvenient
14:40:23 <mdempsky> Cale: Hm. Okay.
14:40:40 <d-snp> is it a performance thing? so thunk's are not kept in memory for too long?
14:40:41 * hackagebot hyperpublic 0.0.0 - A thin wrapper for the Hyperpublic API  http://hackage.haskell.org/package/hyperpublic-0.0.0 (MichaelCraig)
14:40:52 <monochrom> yes, it is a performance thing
14:41:11 <monochrom> see the source code of Data.Map for example
14:41:12 <Eduard_Munteanu> It borders on correctness at times.
14:41:43 <Cale> Yeah, where performance and correctness interact with each other because machines are limited :)
14:41:48 <shachaf> Cale: We don't have type-level naturals?
14:41:58 <Cale> shachaf: Well, there are libraries for them...
14:42:12 <Eduard_Munteanu> Those are fake type-level nats anyway.
14:42:13 <shachaf> Cale: What do you mean by "have them"?
14:42:16 <Cale> shachaf: Mostly in unary... I've seen a crazy one with funky decimal ones
14:42:34 <Cale> shachaf: I mean where you can just write numeric literals in types and operations on them :)
14:42:38 <shachaf> Oh.
14:42:40 <Cale> shachaf: That's coming
14:42:40 <shachaf> We'll have that?
14:42:42 <Cale> yes
14:42:55 <shachaf> Coming to a Haskell compiler near you.
14:43:03 * shachaf is only near JHC.
14:43:23 <thoughtpolice> shachaf: yeah, iavor diatchki has had his branches with type-nats around for a while, but it's not integrated yet.
14:43:32 <Cale> Haskell is very gradually becoming dependently typed
14:43:36 <shachaf> thoughtpolice: We're doing type-level integration too?!
14:43:42 <Cale> lol
14:43:43 <thoughtpolice> Cale: have you seen the new promotion stuff?
14:43:52 <Cale> thoughtpolice: a little bit of it
14:43:54 <Eduard_Munteanu> You wouldn't need typelevel nats if you could write   foo : (a : Bytestring) -> BS.length a == 32 -> ...   :P
14:44:07 <Cale> I think I saw a wiki page about it, but I don't know how things are coming along :)
14:44:09 <shachaf> C++ has had type-level integers for ages. Clearly we're catching up.
14:44:11 <thoughtpolice> Cale: there's a link to spj et al's new paper on /r/haskell, it's really cool.
14:44:12 <copumpkin> Eduard_Munteanu: then how would you prove BS.length a == 32?
14:44:16 <copumpkin> shachaf: they're quite different
14:44:36 <Eduard_Munteanu> Nah, I'm kidding.
14:44:49 <c_wraith> I'm reading it now.  I'm still on the first page, and impressed. :)
14:44:51 <Cale> Awesome! I've been wanting a new SPJ paper to read :)
14:44:52 <shachaf> Don't argue semantics, copumpkin.
14:44:57 <copumpkin> lol
14:44:57 <thoughtpolice> Cale: for example, HList can be defined easily with [] promoted to a kind, so data HList :: [*] -> * where ...
14:44:58 <d-snp> meh, the only pure haskell tcp implementation I can find has 0 comments :(
14:45:13 <Cale> (OutsideIn(X) being a bit too dry for me)
14:45:35 <Cale> thoughtpolice: indeed, that's really awesome
14:45:42 <thoughtpolice> i actually thought the new typekind stuff included iavor's typenat work
14:45:50 <thoughtpolice> but in the last section of the paper they say they haven't done this yet
14:46:03 <thoughtpolice> (since it requires not only promoting e.g. Int and Char, but also all functions over them, etc)
14:46:41 <thoughtpolice> but, hopefully it paves the way. i'd like to see typenats (I have a crypto lib right now where it'd be awesome to statically track size of various nonces, and typenats would rule for this)
14:46:49 <c_wraith> d-snp: ultimately, haskell can't natively implement the hardware control portion of a full TCP stack.  Given this, I doubt anyone has put serious time into implementing TCP in terms of some lower-level primitives.
14:47:11 <thoughtpolice> right now I just use a phantom type to distinguish different nonces, but 'Nonce 64' is much more descriptive than 'Nonce PublicKeyNonce' etc
14:47:25 <d-snp> hmm, does a tcp stack require hardware control?
14:47:39 <d-snp> maybe I haven't thought this through..
14:47:52 <c_wraith> no, you can implement it entirely in terms of the IP layer.  But then you need a library for doing raw IP.
14:47:59 <Eduard_Munteanu> Not exactly, but you do need a way to get raw packets from the kernel somehow.
14:48:08 <d-snp> alright
14:48:13 <mdempsky> thoughtpolice: That's my use case as well; in fact, I found your package while playing around with doing the same thing (FFI wrapper for NaCl).
14:48:47 <Eduard_Munteanu> Which is possible, but then again it won't perform well or be tightly integrated with a common OS like Linux.
14:48:53 <thoughtpolice> mdempsky: patches welcome :D
14:49:13 <d-snp> Eduard_Munteanu: good enough for me :P
14:49:29 <thoughtpolice> mdempsky: i'm not quite ready to release it yet, but it's getting there. haven't done much over the past week. the biggest goal right now is to try and extract all the NaCl reference code
14:49:32 <d-snp> anyway, I don't really need this to actual work, it's just for a paper
14:49:35 <thoughtpolice> so i don't need that stupid bootstrap script
14:49:48 <mdempsky> thoughtpolice: Yeah, it's a pain.
14:49:51 <thoughtpolice> that's also the only way I'd be able to get shared libraries to work :/ the optimized nacl implementations totally aren't relocatable
14:49:57 <Eduard_Munteanu> d-snp: what is the purpose of your paper?
14:50:27 <d-snp> well don't laugh, but I'm researching how stateful network protocols can be expressed in functional languages
14:50:29 <thoughtpolice> mdempsky: my plans are to try and extract all the reference code, and let it keep the same API as the regular implementation. then i can distribute that as a 'purenacl' project, and other people could use it to bind in their own languages, etc
14:50:42 <d-snp> sort of comparing and finding out different styles, and looking for things that might be improved
14:51:05 <c_wraith> Yeah, if you just implement it in terms of data types that contain the information you need, it's enough for proof-of-concept.
14:51:07 <d-snp> I'm not sure yet if I'm going to pick tcp as an example, just was a nice stateful protocol that came to mind
14:51:12 <mdempsky> thoughtpolice: The unoptimized, reference versions are quite slow though.
14:52:17 <jcf> Hi, I have a really basic and boring question. I wrote a list comprehension for my maths homework and it works fine. I just can't get that list to sort.
14:52:29 <jcf> How do I do this?
14:52:37 <c_wraith> oh, nice, the stuff in the new paper is already implemented, and scheduled to be in an upcoming ghc version
14:52:40 <Eduard_Munteanu> @type sort
14:52:41 <lambdabot> forall a. (Ord a) => [a] -> [a]
14:52:48 <sadger> Data.List sort
14:52:51 <sadger> i think
14:52:57 <thoughtpolice> mdempsky: i haven't benchmarked them a ton yet. lots of the actual various crypto functions are actually reference impls with no optimized version (the stream ciphers and curve25519 are the notable exceptions.) but with an identical API I'm hoping to allow you to opt-in to the optimized versions.
14:53:00 <sadger> you might need to import Data.List at the top
14:53:03 <sadger> then
14:53:08 <sadger> sort listName
14:53:09 <Eduard_Munteanu> 'sort' is in prelude, I think sortBy isn't
14:53:16 <sadger> hmm
14:53:18 <jcf> I put sort infront of the comprehension but I get an error. I'll try that now.
14:53:19 <Eduard_Munteanu> @index sort
14:53:19 <lambdabot> Data.List
14:53:20 <sadger> sure?
14:53:22 <d-snp> anyway, I can always implement TCP over UDP if I really need it to work :P
14:53:25 <Eduard_Munteanu> Hm.
14:53:28 <thoughtpolice> mdempsky: another stupid problem is that the build system uses CPP EVERYWHERE to define the actual function names, so I need stupid glue code to bind them, because GHC expects you to give it the name of the symbol at *link time*, which you can't really know. :/
14:53:41 <sadger> thought as much
14:53:41 <Eduard_Munteanu> Ah, it's not, sorry.
14:53:41 <sadger> only because i had to import it this morning
14:53:54 <sadger> jcf: import Data.List
14:54:02 <sadger> jcf: sort listName
14:54:15 <Eduard_Munteanu> Other *By's are separate I think.
14:54:17 <mdempsky> thoughtpolice: Yep.
14:54:23 <jcf> sadger: Thank you very much. That's perfect.
14:54:33 <sadger> jcf: to do it the opposite was
14:54:45 <sadger> jcf: reverse . sort listName
14:55:33 <jcf> sadger: Thanks.
14:55:41 <sadger> jcf: No problem
14:55:46 <jcf> Haskell seems incredibly useful for number theory type stuff.
14:55:48 <thoughtpolice> mdempsky: i've thought of being super evil however and hacking Setup.hs to determine link-time names (by running gcc -E for example) and spit them into a file :P
14:55:51 <jcf> I'll be using it more.
14:55:55 <thoughtpolice> i'm not sure if i want to do that yet tho
14:56:08 <Eduard_Munteanu> thoughtpolice: there's ghc -E too
14:56:22 <Eduard_Munteanu> In case you need to do it for Haskell code.
14:56:47 <byorgey> jcf: if you're doing number theory stuff be sure to check out the 'arithmoi' package
14:56:51 <byorgey> @hackage arithmoi
14:56:51 <lambdabot> http://hackage.haskell.org/package/arithmoi
14:59:11 <thoughtpolice> mdempsky: but yes, if you have any ideas/patches i'd love to see them :D preferrably i want to keep dependencies low but i'm more than OK with extensions for the most part. michael stone has also expressed interest in helping out; he's actually using my bindings already for a private project of his it seems
14:59:40 <thoughtpolice> (which i don't know if he can quite release details about :P)
14:59:55 <mdempsky> thoughtpolice: Nah, nothing at the moment; I just started playing with Haskell last week, so I was just using NaCl to learn the FFI.
15:00:35 <mdempsky> (I wrote some of NaCl's reference implementation code, and also used it for implementing DNSCurve in djbdns; I was going to play with implementing CurveCP to learn Haskell's networking stuff.)
15:00:42 <byorgey> thoughtpolice: the typenats stuff is mostly orthogonal
15:01:30 <byorgey> thoughtpolice: promoting functions wouldn't be enough; most of the point of the typenats work is that there's a bunch of domain-specific constraint solving code for arithmetic
15:02:00 <copumpkin> byorgey: do you guys have a plan/syntax for supporting pattern matching on the promoted constructors at some point? :)
15:02:07 <copumpkin> I asked you before but slightly differently
15:02:16 <byorgey> copumpkin: nothing concrete yet.
15:02:24 <thoughtpolice> mdempsky: ah very cool. keep in mind my bindings are very simple too if you'd like to help in any way ;)
15:02:44 <thoughtpolice> (i plan on adding a more high-level API as part of separate package eventually, I think)
15:02:51 <mdempsky> thoughtpolice: Yeah.
15:03:11 <thoughtpolice> byorgey: ta for the clarification
15:04:26 <thoughtpolice> mdempsky: and my plans are to include a curvecp implementation too fwiw, heh. that's quite a ways off atm
15:04:48 <thoughtpolice> (i think it would actually be surprisingly easy with something like attoparsec though, it's amazing for network protocols)
15:04:55 <mdempsky> thoughtpolice: Yeah, I saw your docs about that.
15:06:43 <aspiers> hi all, any idea why cabal install template-haskell-2.6.0.0 fails with 7.0.2 on Fedora 15? "Language/Haskell/TH/PprLib.hs:55:10: Illegal instance declaration for `Show Doc'"
15:07:05 <ski> c_wraith : (re Stephanie Weirich) .. i dunno, but have the same feeling
15:07:34 <c_wraith> ski: turns out she's byorgey's phd advisor, among other things.  I'm sure I've just seen her name on a bunch of other papers.
15:08:09 <ski> yeah, but i can't recall which papers
15:08:24 <ski> (and a quick look at the publications list didn't ring a bell)
15:10:52 <byorgey> ski, c_wraith: yes, you're likely to have seen Stephanie's name on a bunch of other Haskell-type-system-related papers
15:11:37 <Cale> I find all this kind system stuff to be quite satisfying because years ago I had an intuition that the problem with making Set into a monad might be solved by having an ability to express the kind of types constrained by Ord explicitly. I was a bit off, but it's nice to see such a good solution involving kinds.
15:12:11 <ski> "Giving Haskell a Promotion" talks about this ?
15:12:37 <MHD0> Man, object oriented design is so easy to get wrong
15:12:44 <elliott> Cale: hmm... Something :: Constraint -> * sounds compelling
15:12:55 <Cale> Not specifically, but it does discuss Constraint kinds
15:13:00 <Cale> which are part of that solution :)
15:13:12 <bfig> MHD0, it is a horrible way to build generality
15:13:44 <MHD0> bfig: not necessarily. dynamic prototype based OO is cool
15:13:44 * d34df00d plays again with parallellizing stuff.
15:14:05 <d34df00d> Finally got my hands to that my code with expression trees and various genetic stuff.
15:14:16 <MHD0> bfig: but <insert {} based imperative OO language> is
15:14:22 <thoughtpolice> ski: constraint kinds are discussed for the most part here - http://hackage.haskell.org/trac/ghc/wiki/KindFact the idea of allowing you abstract the constraint language isn't new, but most of the old proposals involved new syntax. making constraints of a specific kind eliminates that need however
15:14:31 <MHD0> bfig: ... generally very bad
15:14:48 <bfig> sorry i don't know what a dynamic prototype is
15:15:08 <d34df00d> Particularly, reimplemented the Levenberg-Marquardt algorithm as well as some matrices ops so that the app wouldn't call to GSL and other C code now. Now I see that the app really runs in parallel, with ~4 cores load. Nice.
15:15:09 <MHD0> bfig: when you need a new class, you clone Object and change the clone
15:15:31 <MHD0> bfig: when you need a new object you clone the "class" and use that
15:15:45 <d34df00d> Is that a good result? → http://paste.pocoo.org/show/498759/
15:16:01 <bfig> you have a default object? are you talking about a parameterless constructor?
15:16:18 <d34df00d> I'm kind of confused with GC time, though it makes sense — the more stuff is parallelized, the less application runs in total time.
15:16:19 <bfig> or are you talking about modifying the classes?
15:16:23 <bfig> like 'class constructors' ?
15:16:28 <MHD0> bfig: The "class" is the default object. Self does this.
15:16:42 <bfig> how do you clone a non-object into an object?
15:16:51 <MHD0> bfig: everything is an object
15:16:55 <ddarius> d34df00d: Spending half your time GCing is bad.
15:16:58 <MHD0> bfig: nothing is a non-object
15:17:03 <d34df00d> ddarius: that's with -N8.
15:17:09 <d34df00d> ddarius: with -N1 it's 11% or such.
15:17:12 <Cale> MHD0: Yeah, most typed OOP languages are doing OO wrong.
15:17:48 <Cale> MHD0: By tying method implementations to the types of objects, they're missing a lot of the point.
15:17:49 <MHD0> Cale: And they encourage class inheritance over encapsulation/delegation
15:18:06 <ski> thoughtpolice : i've pondered making a constraint kind before (writing stuff like `Eq :: * -> instance' and `Ord :: (a : *) -> Eq a => instance' in documenting comments)
15:18:16 <Cale> To do typed OO correctly, you need first-class procedures so that you can fill in method implementations on a per-object basis.
15:18:22 <ddarius> In my opinion what OOP should have been is what you get when you program with message passing concurrency.
15:18:44 <MHD0> Self is the most OO language I have ever seen.
15:19:09 <Cale> Yeah, Self/Smalltalk/etc. are the sort of thing I think of when I think of OO
15:19:22 <ddarius> Self and Smalltalk are rather different.
15:19:27 <MHD0> Java is just imperative with data compartmentalization
15:19:41 <MHD0> that is a long word. "Compartmentalization"
15:19:51 <shachaf> > (compare `on` head) "Self" "Smalltalk"
15:19:52 <lambdabot>   EQ
15:20:16 <pr> aahhaa
15:20:20 <ddarius> In many ways I'd say Smalltalk is closer to Java than it is to Self.
15:20:32 <MHD0> yes
15:20:46 <thoughtpolice> ski: one nice thing about the design - one which i think most people will appreciate if nothing else - is that now you can use type synonyms to abstract constraints too! so you can say type X a = (Eq a, Show a) for example - no undecidable instances needed now to get the same effect (class (Eq a, Show a) => (X a) where ...)
15:20:48 <ddarius> MHD0: Have you ever looked at E?
15:20:56 <bfig> well i stand corrected, i was mostly refering to the java/c sharp OO practice
15:21:06 <MHD0> ddarius: No, sadly.
15:21:10 <MHD0> will do
15:21:36 <MHD0> There's also a guy making an operating system that is a giant virtual machine for a Self-inspired language
15:21:37 <ski> Cale : yes .. O'Camls OO system allows that too
15:21:47 <Cale> yeah
15:22:00 <ski> ddarius : actors ?
15:22:10 <ddarius> MHD0: That's what early Smalltalk basically was.
15:22:17 <ddarius> Obviously not Self inspired.
15:22:54 <Cale> The key point of OO to me is the way in which objects are values determined by their responses to a particular set of messages or methods.
15:22:56 <ddarius> ski: Not exactly.
15:23:16 <ddarius> Cale: That would be abstract data types in general.
15:23:24 <ski> MHD0 : i'm skeptical of the usefulness of "everything is an object" -- i don't see why records should be priviledged over variants (or indeed vice versa)
15:23:33 <ddarius> Also, objects are not determined by their responses to a particular set of messages.
15:23:49 <thoughtpolice> d34df00d: the best way to calculate parallel speedup in general, according to simon marlow, is basically to take the single-threaded version (NOT the -threaded version on 1 core) and get the elapsed time, and divide that by the elapsed time of the parallel version. so for your -N8 case the the elapsed time is about 103s. what's the elapsed time for a sequential version?
15:23:57 <MHD0> ski: What I meant was that classes themselves were actually prototype objects
15:24:06 <ddarius> ski: An object isn't a record anyway.
15:24:14 <thoughtpolice> (i.e. the equation is speedup = (elapsed time for 1 proc) / (elapsed time for N procs) )
15:24:15 <Cale> ddarius: well, yeah pretty close :)  I think of OO as being a style of programming that is particularly focused on that kind of abstraction.
15:24:19 <MHD0> ski: there is also the fact that Self is dynamically typed
15:24:51 <thoughtpolice> d34df00d: granted i don't know what your code looks like. a good percentage of the sparks you spawn are also abandoned, so you can probably reduce a bit of GC if you tune when you create a spark (with par or whatever you're using)
15:25:18 <Cale> In that light, it's possible to do OO quite nicely in Haskell, even without IO :)
15:25:37 <ski> thoughtpolice : yes, that's great .. also we should hopefully be able pass predicates as arguments to types without doing tricks like `data EqDict :: * -> * where EqDict :: Eq a => EqDict a'
15:25:43 * hackagebot data-util 0.1.1 - utilities for handle data  http://hackage.haskell.org/package/data-util-0.1.1 (KatsutoshiItoh)
15:26:19 <Cale> (you get a kind of functionally pure model of object oriented programming by having records of method implementations -- often which recursively produce other records of the same type, instead of mutating state)
15:26:40 <thoughtpolice> ski: yep :) check out this blog post by max - http://blog.omega-prime.co.uk/?p=127 - it discusses these exact things!
15:26:42 <d34df00d> thoughtpolice: the problem is that my code is quite stochastic — basically, I randomily generate some mathematical expressions and then try to find one best describing some given data points via genetic programming.
15:26:47 <ski> ddarius : ok, what are the most important differences, in your mind ?
15:27:17 <ski> (btw, i didn't mean to say that an object *was* a record -- the record presents a particular interface to it)
15:27:34 <ski> (though i'm not sure how great the difference would be)
15:27:50 <d34df00d> thoughtpolice: since it's not that deterministic, I guess there is little sense to do that comparison. At least, dumb comparison — of course, I could replace getStdGen with creating a random gen from a given and fixed random seed.
15:28:09 <d34df00d> thoughtpolice: and regarding tuning the amount of sparks — I'd use chunked versions of parMap and such, right?
15:28:19 <thoughtpolice> d34df00d: ah yes, that makes sense.
15:28:44 <thoughtpolice> d34df00d: for parallel strategies yes. parMap's chunk size can't be tuned at runtime or anything, so you may just want to play around with the chunk size
15:29:02 <ski> MHD0 : yeah. i'm not so happy with classes being objects either. it appears ad-hoc to me, somehow. maybe if i looked closer at such a system, it could seem more sensible
15:29:12 <d34df00d> thoughtpolice: moreover, the numbers I've given are not after the program finished, but rather me hitting ^C :)
15:29:22 <ski> thoughtpolice : ty
15:29:25 <MHD0> ski: It does, if you come from haskell
15:29:29 <MHD0> hehehe
15:29:45 <MHD0> I basically have no preconnotations anymore
15:29:47 <d34df00d> I thought they provide quite a good overall view if one won't take into account the overall run time.
15:29:56 <thoughtpolice> d34df00d: ah ok
15:30:07 <ski> thoughtpolice : max ?
15:30:50 <thoughtpolice> ski: max bolingbroke. he's been pretty awesome with his contributions to GHC lately. :) associated type defaults, constraint kinds, a supercompiler for GHC, optimizing the LLVM backend via alias analysis. he's been very prolific recently :D
15:31:05 <ski> thoughtpolice : IRC presence ?
15:31:29 <thoughtpolice> ski: mbolingbroke, but he joins rarely and mostly sticks around in #ghc i think. you can catch him sometimes (depending on the time zone)
15:31:43 <mauke> preflex: seen mbolingbroke
15:31:43 <preflex>  mbolingbroke was last seen on #ghc 4 days, 1 hour, 45 minutes and 21 seconds ago, saying: fine :)
15:31:48 <d34df00d> And I guess I'd just set the chunk size so that it would spawn just that much chunks as I have cores.
15:32:56 <thoughtpolice> d34df00d: right, you can try that. there's actually a value at runtime you can use to determine that. it's in GHC.Conc.Sync - it's called 'numCapabilities' and represents the 'x' in +RTS -N<x>
15:33:24 <thoughtpolice> (when i said you can't adjust chunk size at runtime i should have been more explicit: parMap won't -dynamically- adjust chunk size for you, so you have to do the tuning is what I meant)
15:33:28 <ben> Cripes, where do I get floating point modulus from again
15:33:38 <d34df00d> thoughtpolice: oh, great, thanks for hinting that!
15:35:48 <dino-> cabal sdist is noting that my project is missing a Setup.hs or Setup.lhs and saying that hackage will reject the package. Is that true, even if I don't need a Setup.hs at all?
15:37:35 <hpaste> charly pasted “How to pass only one parameter (i.e. only the items to sort)” at http://hpaste.org/53178
15:38:59 <charly__> hey can anybody help me. i want to make a insertionSortHelp [] [x:xs] function which is called by insertionSort [x:xs] but it seems not to work
15:39:01 <dino-> I guess it's mandatory even if it does nothing at all.
15:39:43 <mauke> charly__: [x:xs] is wrong
15:40:35 <TomMD> > [ 1 : [2] ] -- Wrong for a given context.  It is a valid expression
15:40:35 <lambdabot>   [[1,2]]
15:40:46 <ski> > ( 1 : [2] )
15:40:47 <lambdabot>   [1,2]
15:41:16 <ski> charly__ : `x:xs' is the list which starts with the element `x', and continues with the elements of the list `xs'
15:41:24 <monochrom> don't you want to just: insertionSort (x:xs) = insert x (insertionSort xs) ?
15:41:36 <ski> charly__ : `[x:xs]' is a list containing a single element, that element being the above list
15:41:57 <ddarius> ski: An object is an abstract data type.
15:42:16 <ddarius> @hoogle mod'
15:42:23 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
15:42:23 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
15:42:34 <ski> ddarius : with an arbitary set of operations ?
15:42:52 <dino-> > [1, 2, 3] == (1 : 2 : 3 : [])
15:42:53 <lambdabot>   True
15:43:12 <ski> > Data.Fixed.mod' 5 0
15:43:13 <lambdabot>   *Exception: Ratio.%: zero denominator
15:43:23 <ski> bah, they botched it, too :(
15:44:23 <ddarius> ski: The (primitive) operations provided are part of the data given when defining an abstract data type.  An abstract data type is not much more than a collection of operations.
15:45:03 <ski> yeah. i'm trying to determine whether you mean anything more by "object" than by "abstract data type"
15:45:54 <ddarius> ski: Even if I didn't, wouldn't that already make it more than a record?
15:46:24 <ski> sure
15:50:18 <ben> > let a :: Num t => t; a = 5 in (a^2, a**2)
15:50:19 <lambdabot>   (25,25.0)
15:51:06 <ddarius> > let a :: Num t => t; a = 2 in (a^a, a**a)
15:51:07 <lambdabot>   (4,4.0)
15:51:19 <Danl2620> > 1
15:51:20 <lambdabot>   1
15:51:32 <ben> > let r :: Num t => (t, t); r@(a, b) = (5, 6) in (a^2, a**2)
15:51:33 <lambdabot>   Couldn't match expected type `forall t. (GHC.Num.Num t) => (t, t)'
15:51:33 <lambdabot>         ...
15:51:45 <charly__> monochrom, that line of code isn't working for me
15:52:08 <charly__> i tried to change the code, but it's not working: http://hpaste.org/53179
15:52:16 <charly__> but on my own
15:53:30 <charly__> ski, i only mistyped
15:54:29 <ben> > let a, b :: Num t => t; (a, b) = (5, 6) in (a^2, a**2)
15:54:30 <lambdabot>   Cannot match a monotype with `forall t. (GHC.Num.Num t) => t'
15:54:34 <ben> cripes
15:54:52 <ben> I just want a polymorphic number :(
15:55:42 <mm_freak> which version of a package does hackage prefer when you open the package page for no specific version?  the highest version number or the latest upload?
15:56:01 <thoughtpolice> mm_freak: highest version number, i believe
15:56:20 <mm_freak> hmm, ok
15:56:29 <mm_freak> thanks
15:57:09 <thoughtpolice> np
15:57:12 <ben> :t 5
15:57:12 <lambdabot> forall t. (Num t) => t
15:57:25 <A1kmm> I'm trying to create Haskell bindings for appindicator, and running into trouble with a function that returns a GtkMenu - is there are way to wrap types from other gtk2hs packages?
15:57:32 <A1kmm> Graphics.UI.Gtk.Types is hidden in the gtk package.
15:59:12 <ben> > let a, b :: Num t => t; (a, b) = (5, 6) in (a**2, a^2)
15:59:13 <lambdabot>   Cannot match a monotype with `forall t. (GHC.Num.Num t) => t'
15:59:16 <ben> ^ how'd I get this to work?
15:59:22 <ben> It seems fairly well-typed.
15:59:33 <A1kmm> :t (**)
15:59:34 <lambdabot> forall a. (Floating a) => a -> a -> a
15:59:36 <hpc> you defined a and b to be the same t
15:59:39 <A1kmm> :t (^)
15:59:40 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:59:53 <hpc> so (a, b) :: Num t => (t, t)
15:59:56 <ben> I don't even use b, though
16:00:05 <hpc> oh, hmm
16:00:17 <ben> I mean, I'll end up using b the same way as a
16:00:28 <hpc> > let a, b :: Num t => t; (a, b) = (5, 6) in (a**2, a^2) :: (Double, Double)
16:00:29 <lambdabot>   Cannot match a monotype with `forall t. (GHC.Num.Num t) => t'
16:00:32 <ben> but the gimmick is that I want to use them both as ints and doubles
16:00:32 <A1kmm> let a, b :: Num t => t; (a, b) = (5, 6) in (a**2, (fromIntegral a)^2)
16:00:37 <hpc> > let a, b :: Num t => t; (a, b) = (5, 6) in (a**2, a^2) :: (Double, Double) :: (Double, Double)
16:00:38 <lambdabot>   Cannot match a monotype with `forall t. (GHC.Num.Num t) => t'
16:00:51 <ben> Clearly that ought to work since Num t => t is polyorphic...?
16:00:53 <ben> +m
16:00:56 <hpc> > let a, b :: Num t => t; (a, b) = (5, 6) :: (Double, Double) in (a**2, a^2) :: (Double, Double)
16:00:57 <lambdabot>   Couldn't match expected type `forall t. (GHC.Num.Num t) => t'
16:00:57 <lambdabot>         again...
16:01:09 <hpc> > let (a, b) = (5, 6) in (a**2, a^2)
16:01:09 <lambdabot>   (25.0,25.0)
16:01:37 <mm_freak> is there an ArrowIO class similar to MonadIO?
16:01:59 <hpc> mm_freak: you could probably make one
16:02:11 <mm_freak> hpc: i don't like inventing classes =/
16:02:13 <hpc> though i think an ArrowIO would automatically be a MonadIO
16:02:16 <mm_freak> thought there is something readymade
16:02:24 <ben> Cripes, I thought ^ was integral-specific
16:02:34 <ben> > let (a, b) = (5, 6) in (2**a, 2^a)
16:02:35 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:02:35 <lambdabot>    `GHC.Real.Integral t'
16:02:35 <lambdabot>   ...
16:02:45 <mm_freak> hpc: no, but one reasonable instance would be:  MonadIO m => ArrowIO (Kleisli m)
16:02:46 <ben> It's not ambiguous, it's generic >:[
16:03:05 <mm_freak> arrIO :: ArrowIO (>~) => IO a >~ a
16:03:07 <A1kmm> hxt has one: http://hackage.haskell.org/packages/archive/hxt/9.1.4/doc/html/Control-Arrow-ArrowIO.html
16:03:32 <mm_freak> A1kmm: ok, sounds like i'm ending up (re-) inventing it
16:03:55 <elliott> just depend on hxt to get the class :P
16:04:13 <mm_freak> well, their class isn't really what i'm looking for
16:04:28 <mm_freak> my 'arrIO' looks different
16:04:38 <hpc> i don't really like that ArrowIO; it seems to do the same as what's wrong with arr
16:04:53 <hpc> (letting you lift arbitrary stuff into the arrow)
16:06:00 <mm_freak> i think 'arr' is not bad per se
16:06:07 <mm_freak> 'arr' is only bad in the context of arrow notation
16:07:01 <hpc> i still don't get arrow notation
16:07:36 <mm_freak> what exactly?
16:08:20 <mm_freak> you are just naming the 'signals' you pass through arrow computations…  in the context of the function arrow you are just giving names to arguments
16:09:55 <augur> so ski, which bits of lolli did you say i should look at?
16:09:56 <lambdabot> augur: You have 1 new message. '/msg lambdabot @messages' to read it.
16:15:21 <Cale> I just noticed something a bit funny in the syntax of the typing rules in Giving Haskell a Promotion -- there's a construction "nth" which is then superscripted with an index i to say which n it is :)
16:16:27 <ben> Does gloss come with a button to render an animation as a gif, by chanc?
16:16:57 <shachaf> Cale: Sounds like computer scientists rather than mathematicians. :-)
16:18:04 <Cale> ben: I don't know. That would be nice. I think the way the current web-gloss stuff works is by constructing a funny "PNG" file which isn't really a valid PNG, but which can then be inspected by a bit of javascript code to carry out drawing commands on the client side... which seems a bit circuitous to me, but that's what they did.
16:18:08 <stribor> guys can anyone recomend tutorial for parsec please
16:18:18 <Cale> (or maybe it's a valid png, I'm not sure)
16:18:31 <Cale> It's certainly not a png of what is being drawn
16:18:50 <elliott> Cale: I would expect it's a valid png
16:18:57 <elliott> or at least valid enough to use canvas stuff
16:19:01 <Cale> stribor: I recommend the original doc... http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
16:19:15 <ben> I suppose I might steal the haskell-for-kids web thing to inflict horrible blinking patterns on my friends just as well
16:19:44 <Cale> stribor: which is slightly out of date with regard to module names, and some things have been generalised since, but is a pretty decent tutorial of how to use it anyway
16:20:03 <Cale> (someone should probably update it)
16:20:12 <stribor> Cale: i need something to get me started
16:20:31 <Danl2620> Cale: isn't the 'do' notation in the parsec doc deprecated or obsolete?
16:20:41 <Cale> http://hackage.haskell.org/package/parsec-3.1.2  is also important
16:20:44 <Cale> Danl2620: no
16:20:54 <Cale> Danl2620: You'll still use do notation with parsec
16:21:02 <donri> are you supposed to import text.parsec or text.parsercombinators.parsec?
16:21:11 <Cale> Text.Parsec
16:21:28 <donri> the other one is a historical artifact?
16:21:36 <Cale> The other one is still around for backward compatibility. People got really tired of typing ParserCombinators
16:21:45 <donri> ugly too :P
16:21:54 <ddarius> Danl2620: What gave you that idea?
16:22:03 <Cale> There aren't many other Text-oriented libraries named Parsec and which aren't parser combinator libraries
16:22:17 <Cale> So it was a bit too much hierarchy :P
16:22:19 <ben> So parsec hasn't been dethroned by any of the "like parsec, but ____" projects yet?
16:22:21 <elliott> Cale: Until I create one!
16:22:43 <donri> Text.Parsec.NotReallyTheParsecParsec
16:22:48 <Cale> ben: Well... ReadP can be pretty nice for simple things too
16:22:57 <Cale> (and it still comes with GHC, I think)
16:23:04 <ddarius> Data.Graph and Data.Graph.Inductive are completely unrelated.
16:24:24 <Danl2620> ddarius:
16:24:41 <Danl2620> ddarius: do { char '('; char '); }
16:24:57 <ski> ben : it's a pattern-binding, hence monomorphic
16:25:03 <ski> augur : at <http://www.lix.polytechnique.fr/~dale/lolli/>, at least "Logic Programming in a Fragment of Intuitionistic Linear Logic" talks some on an inference system with separated intuitionistic and linear context (see page 6 and 7)
16:25:22 <ben> ski: Is that required to keep the type system safe at room temperatures or something?
16:25:48 <Cale> ben: It's a completely stupid restriction which was introduced by Haskell 98 and which can be turned off
16:25:48 * hackagebot vacuum 1.0.0.2 - Extract graph representations of ghc heap values.  http://hackage.haskell.org/package/vacuum-1.0.0.2 (ConradParker)
16:26:04 <Cale> ben: {-# LANGUAGE NoMonomorphismRestriction #-} will disable it
16:26:23 <ben> Both my code and lambdabot run with that flag already though
16:26:35 <ben> We've played around with uh
16:26:58 <ben> > let a = read "[]" in (a :: [Int], a :: [Bool])
16:26:59 <lambdabot>   ([],[])
16:27:00 <ddarius> Cale: No it isn't and no it won't.
16:27:00 <Cale> (I wish that could be shortened to {-# LANGUAGE NoMR #-}, and I wish even more that the MR was just done away with altogether or turned into a warning.)
16:27:08 <Cale> Wait, what?
16:27:22 <Cale> ddarius: I assumed we were talking about the monomorphism restriction on pattern bindings
16:27:25 <augur> ski: will that talk about the stuff we were discussing with reuse of args not functions?
16:27:43 <ski> augur : if you've not seen it, chapter 6 of "Logic Programming in Intuitionistic Linear Logic: Theory, Design, and Implementation" (page 69) talks a bit about gaps and island constraints
16:28:13 <hpaste> stribor pasted “parsec” at http://hpaste.org/53181
16:28:40 <stribor> i got error saying could not find module "parsec"
16:28:47 <ski> augur : it talks about judgements `Gamma; Delta ---> B', corresponding to a linear logic judgement `!Gamma , Delta |- B'
16:28:50 <stribor> i did install it with cabal
16:29:03 <augur> aha ok
16:29:14 <Cale> stribor: import Text.Parsec -- it's moved slightly
16:29:15 <augur> ski: which where tho
16:29:30 <ben> Cale: Apparently we're talking about how names bound by patterns that aren't only the name can't be polymorphic?
16:29:33 <ben> I'm not sure
16:29:44 <ben> > let a :: Read r => r; [(a, _)] = reads "[]" in length a
16:29:45 <lambdabot>   No instance for (GHC.Read.Read (forall r. (GHC.Read.Read r) => r))
16:29:45 <lambdabot>    arisi...
16:30:50 <stribor> Cale: i am trying to do first example from page you gave me
16:30:52 <Cale> > let a :: Read r => r; [(a, _)] = reads "[]" in length (a :: [Integer])
16:30:53 <lambdabot>   No instance for (GHC.Read.Read (forall r. (GHC.Read.Read r) => r))
16:30:53 <lambdabot>    arisi...
16:30:57 <Cale> mhm
16:31:01 <Cale> stribor: okay
16:31:19 <stribor> Cale: still givinfg me error
16:31:26 <Cale> stribor: what are you getting now?
16:31:41 <stribor> ot in scope: type constructor or class `Parser'
16:31:47 <Cale> oh, ummm...
16:32:11 <Cale> import Text.Parsec.String
16:32:16 <Cale> see if that helps :)
16:32:51 <Cale> Parsec can parse other types of strings now, like strict and lazy ByteStrings, so some stuff is in separate modules
16:33:07 <dino-> So much has changed with cabal in the past year, it's fantastic.
16:33:14 <stribor> http://hpaste.org/53182\
16:33:29 <ski> augur : "which where tho" ?
16:33:42 <ski> augur : the papers i mentioned are linked from <http://www.lix.polytechnique.fr/~dale/lolli/>
16:34:01 <augur> which paper is the section reference to
16:34:03 <Cale> stribor: yeah, importing Text.Parsec.String fixes it for me
16:34:24 <stribor> Cale: doesnt for me ):
16:34:24 <TomMD> What are peoples preferred libraries for drawing an a PNG?
16:34:37 <Cale> stribor: still getting that Parser isn't in scope?
16:34:40 <stribor> Not in scope: `letter'
16:34:43 <stribor> thats what i get now
16:34:52 <TomMD> I see GD and Cairo, for example, but both are limited in their own way.  For example, both require me to write the file to disk to obtain the resulting PNG.
16:34:56 <hpaste> Cale annotated “stribor” with “stribor (annotation)” at http://hpaste.org/53182#a53183
16:35:25 <Cale> ^^ try that :)
16:36:22 <Cale> Text.Parsec.String basically just contains a definition for the Parser type synonym and a String version of parseFromFile
16:36:27 <stribor> testing.hs:5:10: Not in scope: type constructor or class `Parser' Failed, modules loaded: none.
16:36:34 <Cale> okay
16:36:39 <ski> (augur : i'm sure you'll tell me why the handling of gaps and island constraints in that article is nave/inadequate, but i was thinking you maybe would find it a bit interesting anyway)
16:36:41 <Cale> ghc-pkg list parsec
16:37:02 <ski> augur : the "Logic Programming in Intuitionistic Linear Logic: Theory, Design, and Implementation" one has that chapter 6
16:37:03 <Cale> I currently have 3.1.1 installed, and the code I pasted works for me
16:37:32 <augur> ski: LPILL has gaps and islands?
16:37:42 <dino-> TomMD: What about Graphics.GD.savePngByteString, that goes to disk?
16:38:11 <hpaste> stribor pasted “my output” at http://hpaste.org/53184
16:38:12 <dino-> TomMD: It's :: Image -> IO ByteString
16:38:26 <stribor> thats what i get when i list it
16:38:32 <TomMD> dino-: Right, I just saw that.  GD is OK - but still lacking (another example if you want: no line width control).  So I'm just looking for what other people like to use.
16:38:39 <Cale> stribor: hrm, I wonder if it's using that globally installed version by accident.
16:39:11 <stribor> Cale: so what do i do
16:39:30 <Cale> well, wait, it can't be, because 2.1.0.1 doesn't have Text.Parsec
16:39:41 <Cale> Let me update to 3.1.2 and see what happens
16:39:48 <stribor> Cale: thanks
16:40:04 <ski> augur : that chapter talks about the application of encoding a parser, exploiting the linearness of assumptions to good use
16:40:21 <dino-> TomMD: Ok. Not sure then. Haven't actually used these.
16:40:30 <ski> (and i'm not sure exactly which system you mean by `LPILL')
16:40:43 <augur> ski: ya i see
16:40:58 <Cale> stribor: In any case, importing Text.Parsec.Char should fix the problem with 'letter' being missing
16:41:06 <augur> which has the arg-multiple times, fun-once stuff?
16:41:18 <ski> i don't recall that, no
16:41:22 <Cale> stribor: but the stuff in Text.Parsec.Char is supposed to be re-exported by Text.Parsec, so that's confusing
16:41:33 <ski> i just mentioned that chapter since you're a linguist person
16:42:22 <stribor> Cale: same error "Not in scope: type constructor or class `Parser'
16:42:23 <augur> ski: ok
16:42:36 <Cale> stribor: You're importing all three now?
16:42:37 <ski> augur : in any case, you asked for some kind of reference for non-linear contexts, and at least some of the papers there talk about that
16:43:01 <stribor> no i just changed to Text.Parsec.Char
16:43:07 <Cale> stribor: You need both Text.Parsec and Text.Parsec.String
16:43:47 <stribor> Cale: yeah that worked
16:43:48 <stribor> lol
16:43:55 <Cale> Text.Parsec should get you most of the stuff available in Parsec, and Text.Parsec.String gets you a String-specific definition of Parser, and a String specialised version of parseFromFile
16:44:03 <ddarius> Cale: Trust no one.
16:44:15 <Cale> stribor: Then you didn't copy/paste my code earlier :)
16:44:21 <stribor> :)
16:44:24 <augur> ski: ok
16:44:26 <ski> (augur : that chapter talks about GPSG as well. i assume you know better than me what that is exactly)
16:44:35 <augur> yeah im familiar with gpsg
16:44:47 <ski> (i.e. "Generalized Phrase Structure Grammar")
16:44:48 <augur> gpsg is basically just CFGs where your rewrite rules can have equations
16:45:02 <augur> and accessor functions
16:45:07 <augur> so you can state things like
16:45:22 <ski> hm, is it related to attribute grammars, in some way ?
16:45:32 <augur> S -> NP VP | person(NP) = person(VP)
16:45:59 <augur> yeah its sort of AG-ish but not completely
16:46:18 <augur> that reminds me, i need to read that knot-tying thing again
16:46:18 <ski> ok
16:46:30 <ski> which one ?
16:48:13 <augur> ski: i dont understand this chapter enough -- its too built around lolli for me to jump right in
16:48:25 <augur> ski: http://www.haskell.org/haskellwiki/Tying_the_Knot
16:49:11 <ski> well, the initial examples at least are just DCGs in Prolog and later in lambdaProlog
16:49:38 <augur> yeah no i know
16:50:13 <ddarius> "yeah no I know yeah"
16:50:48 <augur> ddarius: :)
16:52:26 <shachaf> ya know, i, no yeah
16:55:01 <Axman6> y u no yeah?
16:57:01 <cjay> wat
16:57:08 <ski> "Attribute Grammars as a Functional Programming Paradigm" by Thomas Johnsson in 1987 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.8549>
16:57:11 <ski> "Attribute Grammars in the Functional Style" by S. Doaitse Swierstra,Pablo R. Azero in 1998 at <http://people.cs.uu.nl/doaitse/Papers/1998/SI2000.pdf>
17:04:29 <Cale> 99.94% of the mass is concentrated in 10^(-14)% of the volume. OCCUPY ATOM.
17:05:13 <TomMD> In real world, atom occupies you!
17:05:14 <c_wraith> shouldn't that be Occupy Nucleas?
17:05:22 <c_wraith> except, you know, Nucleus.
17:05:27 <c_wraith> Because spelling is good
17:05:33 <shachaf> 99% of netbooks use 1% of the CPU architectures. OCCUPY ATOM.
17:05:51 * shachaf #haskell-blah
17:06:02 <hpc> 99.7% of the integral is within 3σ of μ; occupy standard normal!
17:07:37 <Cale> oh, I suppose it ought to be OCCUPY NUCLEUS, yeah
17:08:32 <monochrom> http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml  \∩/
17:09:16 <ddarius> Cale: Then even more mass would be in the nucleus.
17:11:07 <Cale> But once we're in there, we're totally not going to be like those jerk protons and neutrons. We're gonna spread that mass around. .oO(Muahaha... Hope nobody observes us!)
17:11:55 <ddarius> Cale: That's what you say just before you collapse into a blackhole and concentrate even more mass in an even smaller area.
17:12:04 <monochrom> inside the nucleus, it's the same story again: monopoly by tiny quarks. so, occupy the quarks...
17:12:08 <ddarius> Luckily, you all will then quickly pop out of existence.
17:12:15 <stribor> Cale: insteaqd of simple :: Parser Char why doesnt it say simple :: Parser->Char
17:12:25 <shachaf> I'm quite annoyed by how unlines . lines =/= id.
17:12:27 <monochrom> "it's 99% all the way down"
17:12:40 <Cale> stribor: where does it say that?
17:12:53 <stribor> link you gave me
17:12:59 <Cale> uhh... I don't see it
17:13:05 <Cale> I see  simple :: Parser Char
17:13:17 <stribor> The type of simple shows that simple is a parser that will return a Char
17:13:24 <stribor> so if it returns Char
17:13:29 <stribor> then why not ->Char
17:13:35 <Cale> oh
17:13:50 <Cale> Because it's not a function.
17:14:02 <stribor> Cale: oh...what is it then?
17:14:02 <Cale> It's a parser, whose result type is Char
17:14:09 <Cale> It doesn't *take* a parser as a parameter
17:14:25 <stribor> difference between parser and function?>
17:14:49 <kmc> they are totally different things
17:14:50 <Cale> A function of type A -> B is a thing which associates to each value of type A, some value of type B
17:15:42 <ski> shachaf : indeed
17:15:54 <Cale> Parser -> Char would be the type of a function which took a value of type Parser as its parameter, and produced a Char as its result, based entirely on the value of type Parser it was given.
17:16:01 <monochrom> "Parser->Char" is like "US->Money". no, you got it backwards.
17:16:17 <Cale> But Parser here isn't a type on its own
17:16:34 <Cale> Parser is a type constructor, which takes a parameter saying what type of value it parses
17:16:50 <Cale> (it implicitly consumes a String to produce this value)
17:17:23 <Cale> If you want, you could model values of type Parser a as functions String -> [(String,a)]
17:17:27 <ski> > (unlines . lines) " "
17:17:29 <lambdabot>   " \n"
17:17:30 <stribor> can you give me example how would you evaluate this simple::Parser Char
17:17:37 <stribor> i d like to try it on ghci
17:17:52 <Cale> where you get a list of possible parses, each of which consists of the remainder of the string (after the part which was eaten), and a value which was parsed
17:18:40 <monochrom> presumably you also received some function called runParser or something...
17:18:41 <Cale> parseTest simple "hello"
17:18:57 <Cale> (you could also use the 'run' function which is defined in the tutorial there)
17:19:05 <stribor> whats parseTest?
17:19:35 <Cale> parseTest is apparently newer than the tutorial, it does the same thing as run
17:20:06 <hpc> parseTest returns what might have been parsed, without consuming input?
17:20:06 <Cale> It takes a parser, and a string, and runs the parser on the string, either showing the result of the parsing, or showing the parse error if there was one
17:20:12 <stribor>  oh thats alreadt defined function
17:20:14 <hpc> oh
17:20:16 <stribor> why do i have to use that
17:20:22 <Cale> Its result has type IO ()
17:20:33 <Cale> Uh, you don't have to use that, you could use parse
17:20:51 <c_wraith> How do you specify an inline pragma for an instance definition?
17:20:53 <Cale> ghci> parse letter "" "hello"
17:20:54 <Cale> Right 'h'
17:21:05 <Cale> ghci> parse letter "" "123"
17:21:06 <Cale> Left (line 1, column 1):
17:21:06 <Cale> unexpected "1"
17:21:06 <Cale> expecting letter
17:21:37 <Cale> The empty string I'm passing there is a filename parameter which you can fill in for it to use in error messages
17:22:09 <stribor> Cale: why does in tutorial explains run function when that function is already defined
17:22:19 <Cale> c_wraith: hmmm... can those be inlined? I guess if it's already specialising the class...
17:22:38 <Cale> stribor: just because the tutorial is from the first version of Parsec
17:23:03 <Cale> and nobody's bothered to update it, as far as I'm aware...
17:23:32 <stribor> Cale: is there any more updated version
17:23:48 <Cale> If I knew of one, I would have pointed you at it ;)
17:24:03 <Cale> I should probably go through and modernise that one a bit
17:24:25 <Cale> It's not so far off, the code will still work, it's just the imports are wrong, and it defines 'run' when it doesn't have to.
17:24:54 <stribor> Cale: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Char.html    its nice i just wish i has examples for each function like other modules
17:25:27 <stribor> Cale: some funciton have example some dont
17:26:17 <ski> > (unpages . pages) "a\vb\nc\v\nd"
17:26:19 <lambdabot>   "a\vb\nc\v\nd"
17:26:38 <Cale> lol \v
17:26:50 <stribor> ?
17:27:04 <ski> um, no, that's wrong
17:27:09 <Cale> \v is vertical tab
17:27:28 <ski> > (unpages . pages) "a\fb\nc\f\nd"
17:27:31 <lambdabot>   "a\fb\nc\f\nd"
17:27:34 <ski> yeah, i just recalled that
17:28:23 * ski sees it as `^L' in his files, and couldn't recall the correct escape for it
17:29:16 <sm> cabal configure --help
17:29:20 <sm> oops, sorry
17:30:01 <sm> cabal flags must be boolean, I assume
17:33:19 <T_X> how can I write a function 'f x y = g (h x y)' in a point free way? I tried 'f = g . h' which did not work
17:33:45 <hpc> > let .: = (.) . (.) in f (g x y)
17:33:46 <lambdabot>   <no location info>: parse error on input `.:'
17:34:01 <hpc> > let (.:) = (.) . (.) in (f .: g) x y
17:34:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:34:02 <lambdabot>    `GHC.Show.Show a'
17:34:02 <lambdabot>      a...
17:34:04 <kmc> @pl f x y = g (h x y)
17:34:04 <lambdabot> f = (g .) . h
17:34:07 <hpc> > let (.:) = (.) . (.) in (f .: g) x y :: Expr
17:34:08 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:34:08 <lambdabot>    `SimpleReflect.FromExpr ...
17:35:00 <T_X> kmc: thx, awesome!
17:37:35 <ddarius> :t fmap fmap fmap g h
17:37:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1, Show a, SimpleReflect.FromExpr b, SimpleReflect.FromExpr (f (f1 a))) => f (f1 b)
17:37:41 <ski> > let (.:) = (.) . (.) in (f .: (g :: Expr -> Expr -> Expr)) x y :: Expr
17:37:43 <lambdabot>   f (g x y)
17:37:54 <hpc> oh, there we go
17:38:11 <hpc> anyhoo, you want (.:) = fmap fmap fmap
17:38:28 <hpc> way more useful than (g .) . h, and easier to read
17:46:11 <mm_freak> after years of haskell, this is the first time i see value in Kleisli
17:46:25 <kfish> Kliesli is a star
17:47:27 <ddarius> @hoogle liftM2
17:47:27 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:48:28 <kmc> which value mm_freak?
17:48:50 <mm_freak> kmc: as the base arrow for arrow transformers
17:49:03 <kmc> ah, interesting
17:52:16 <monochrom> that will fulfill the prophecy: "inside every arrow stack is a monad trying to get out" :)
17:52:59 <shachaf> Whoa, man. A monad trapped inside something else? That's, like, so meta.
17:55:26 <monochrom> hahaha
18:00:41 <monochrom> some say "it's about time the monad is the one being trapped"
18:08:19 <stribor> let a = parse simple "" "imac"......returns Right 'i' which is of type a :: Either ParseError Char........how do i get the character out of this
18:09:10 <kmc> pattern matching
18:09:36 <stribor> kmc: can you give me example in case above
18:09:41 <stribor> kmc: please
18:09:50 <monochrom> case a of Right c -> c
18:10:01 <kmc> are you following some Haskell tutorial stribor?
18:11:51 <stribor> kmc: yes...i know how to pattern match other types..
18:12:04 <kmc> ok
18:12:07 <kmc> @src Either
18:12:08 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:12:11 <kmc> blah
18:12:15 <kmc> data Either a b = Left a | Right b
18:15:12 <stribor> kmc: tx
18:23:33 <monochrom> w00t, HWN
18:29:04 * kfish has LWN but no HWN yet :(
18:38:07 <Eduard_Munteanu> Hm, right, time for LWN.
18:42:04 <dino-> Having a problem with sdist where it's not drilling down into subdirs in my src dir, but this works as expected with, say, darcs dist
18:42:37 <dino-> If there's some additional cabal conf I need, not seeing it in docs yet. This sound familiar to anyone?
18:42:52 <Saizan> dino-: sdist doesn't drill at all, it picks only the modules listed in the .cabal file
18:43:13 <Saizan> dino-: so i guess you've to fill other-modules:
18:43:23 <dino-> Saizan: I can use exposed-modules with executable stanzas? I guess I *must*
18:43:41 <Saizan> dino-: other-modules :)
18:43:54 <dino-> Saizan: ok
18:44:34 <dino-> Does this kind of seem weird to you? I mean, the executable won't build without everything under src, and that other-modules isn't required to build.
18:44:50 <dino-> And now I have to maintain this list explicitly.
18:44:59 <Saizan> that other-modules isn't required to build is kind of an accident
18:45:26 <Saizan> and they aren't inferrable in general because of CPP
18:45:34 <dino-> This is the first time I'm using cabal sdist instead of darcs dist
18:47:00 <dino-> I bet this is going to bite me though in the future. Makes me think I need to unpack and test build before uploading to Hackage. Make sure nothing was accidentally left out of other-modules. :/
18:47:26 <dino-> Becuase the only way you would know otherwise is when it doesn't build up there.
18:47:59 * byorgey always unpacks and test builds after cabal sdist
18:49:18 <dino-> Maybe I'll write a script to do that
18:49:38 <Saizan> it's the same problem as darcs put really, if you didn't darcs add a file it won't appear in the resulting repo
18:49:53 <Saizan> maybe you can make a script that uses darcs to fill other-modules
18:50:01 <dino-> And also it's more like library stanzas where you have to list every module, really.
18:50:12 <Saizan> yep
18:50:17 <dino-> Ok then, thank you.
18:55:48 <kmc> ugh, i'm getting concurrency-related crashes with repa-devil
18:55:58 <kmc> even with a global lock (declared with unsafePerformIO and NOINLINE)
18:57:02 <kmc> it seems two threads can get the lock at the same time
18:57:34 <kmc> and i'm wondering if I screwed up, or if this global locking thing doesn't actually work, or if DevIL is breaking ghc somehow
19:00:57 <bfig> what is the datatype being folded over in ackermann's list version? it seems i should be able to deconstruct the value in a not so regular way
19:00:59 <thoughtpolice> kmc: what do you need a lock for?
19:01:25 <kmc> the DevIL C library is not thread-safe
19:01:28 <thoughtpolice> kmc: also, unsafePerformIO + NOINLINE? y u no use your own packages :(
19:01:35 <kmc> i was using my own package
19:01:41 <thoughtpolice> oh :P
19:01:42 <kmc> that's what it does ;P
19:01:50 <kmc> i ripped it out to make sure it wasn't my package's fault
19:03:22 <copumpkin> bfig?
19:05:03 <thoughtpolice> kmc: i wonder how much/if it would be easier to figure such a problem out with GDB these days, considering it now has reversable debugging and much better multithreaded debugging support
19:05:23 <bfig_> i have two naturals, and i want to fold over them. how do i define the datatype? (if i have the datatype i'm convinced i can find the fold but i can't see the proper way to write the datatype)
19:05:24 <thoughtpolice> i've been thinking about whipping together a bunch of python scripts using the GDB python interface to help do GHC debugging.
19:05:40 <kmc> that would be fun
19:05:41 <shachaf> I wonder whether it's easy to tell gdb about your own lightweight threading library.
19:05:44 <shachaf> Probably not.
19:05:58 <shachaf> (I mean one in C++, not in Haskell.)
19:06:15 <thoughtpolice> right now there are various gdbinit scripts that just have macros for things like finding the right pointers or looking at stg registers etc.
19:06:17 <bfig> say, you have a fold over datatype D, and a fold over datatype F, how do you define a fold over the product datatype D*F ?
19:06:56 <mauke> bfig: http://okmij.org/ftp/Algorithms.html#zip-folds ?
19:14:18 <Saizan> bfig: check the bottom of this paragraph if you're doing ackermann with folds http://en.wikipedia.org/wiki/Ackermann_function#Definition_and_properties
19:15:27 <thoughtpolice> byorgey: lol, what's up with the editorial for TMR 19? :)
19:22:06 <DukeDave> Slightly contrived: Is there anyway to 'inject' in to Either, like this:
19:22:06 <DukeDave> injectEither :: Either a a -> b -> Either b b
19:22:41 <kmc> @djinn Either a a -> b -> Either b b
19:22:42 <lambdabot> f _ a = Left a
19:23:16 <mauke> did you mean: Either a a' -> b -> Either b b
19:23:28 <DukeDave> mauke: Sure! Why not :)
19:23:48 <DukeDave> You can use either and const
19:23:54 <DukeDave> I just wondered if there was a shorter way
19:24:24 <mauke> :t \lr -> case lr of Left{} -> Left; Right{} -> Right
19:24:25 <lambdabot> forall t t1 a. Either t t1 -> a -> Either a a
19:25:04 <ddarius> :t either Left Right
19:25:04 <lambdabot> forall a b. Either a b -> Either a b
19:25:15 <kmc> somehow my call to unsafePerformIO has become unsafeDupablePerformIO in the core :/
19:25:15 <ddarius> :t either (const Left) (const Right)
19:25:16 <lambdabot> forall a a1 b. Either a b -> a1 -> Either a1 a1
19:26:09 <Axman6> :t join either . const
19:26:10 <lambdabot> forall a c. c -> Either a a -> c
19:26:23 <Axman6> hmm, or not
19:26:35 <DukeDave> Axman6: Interesting idea :)
19:26:41 <DukeDave> :t join
19:26:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:26:43 <shachaf> kmc: The safety analyzer analyzed it and decided it was safe, clearly.
19:26:44 <mauke> :t on either const Left Right
19:26:45 <lambdabot> forall a b. Either a a -> b -> Either b b
19:27:04 <Axman6> that's better
19:27:07 <DukeDave> You guys
19:27:39 <DukeDave> :t on
19:27:40 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:28:07 <kmc> hmm, the noDuplicate# is hiding elsewhere
19:28:44 <mauke> :t liftA2 either ($ Left) ($ Right) const
19:28:45 <lambdabot> forall a a1. Either a a -> a1 -> Either a1 a1
19:30:15 <augur> ski: i had this idea to make a fold widget that will have the appearance of an attribute grammar but will use folds directly to give you knot tying
19:30:20 <augur> safe knot tying
19:31:06 <ddarius> @hackage UUAG
19:31:06 <lambdabot> http://hackage.haskell.org/package/UUAG
19:37:34 <ddarius> Haskellers think too much of dependently typed programming.
19:38:20 <augur> ddarius: oh?
19:42:02 <kmc> yeah my supposedly not-dupable IO is getting duped
19:42:16 <shachaf> kmc: Sounds to me like you're the one getting duped.
19:42:23 <kmc> quite
19:42:37 <ddarius> kmc: Is it changing semantics?
19:42:42 <DukeDave> So, further to my previous statement, I like this:
19:42:42 <DukeDave> :let either_ l r = either (const l) (const r)
19:42:55 <kmc> yeah
19:43:25 <shachaf> DukeDave: Why "either_"?
19:44:08 <DukeDave> shachaf: It, throws away the result, in some sense
19:44:27 <DukeDave> Can you think of a better name?
19:45:33 <copumpkin> why are you using Either a a anyway?
19:45:40 <copumpkin> and using the other Either as a Bool
19:45:50 <copumpkin> Either a a ~ (Bool, a)
19:45:55 <shachaf> copumpkin: Early exit?
19:46:15 <DukeDave> copumpkin: I don't care what's in the Either, I just want to know if it's left or right..
19:46:30 <copumpkin> yeah, so maybe you just need a Bool?
19:46:33 <DukeDave> We probably should be using Either, because the semantics are wrong.
19:46:47 <shachaf> I always like to use things that have the wrong semantics.
19:47:01 <DukeDave> copumpkin: Yes, my other thought was having an "isLeft" function
19:47:05 <bfig> Saizan, thanks!, great! :)
19:47:12 <shachaf> DukeDave: There exists one.
19:47:20 <shachaf> Wait, maybe not.
19:47:21 <ddarius> @hoogle isLeft
19:47:22 <lambdabot> No results found
19:47:26 <shachaf> Odd.
19:47:29 <DukeDave> Yeah
19:47:43 <thoughtpolice> kmc: what version of GHC are you using? if you want to see if it comes down to a GHC bug i have 7.0.4 (OS X 64bit) and 7.2.1 sitting around
19:47:56 <DukeDave> But its non-existence kind-of makes sense
19:48:14 <kmc> i've observed this behavior on 7.0 and 7.2
19:48:21 <kmc> trying to get a nice test case atm
19:48:38 <DukeDave> Insomuch as usually you have Either a b where a /= b, and so knowing isLeft wouldn't be that useful..
19:48:53 <shachaf> Either (forall a. a) (forall a. a)
19:50:55 <thoughtpolice> hey kmc, looks like ben lippmeier took your quasicrystal doo-dad and made it work with the new repa3 and gloss 1.5.0, and got it running in realtime
19:50:59 <thoughtpolice> http://www.youtube.com/watch?v=v_0Yyl19fiI
19:51:01 <thoughtpolice> pretty awesome :)
19:51:34 <shachaf> Hmm, neat.
19:51:35 <bfig> so what i need to do is set up two folds: Ack :: Nat -> Nat -> Nat becomes Ack :: Nat -> ( Nat -> Nat ) and write the fold for the first, then write the fold for the second
19:51:46 <shachaf> kmc: (So's your thing, if I neglected to mention that before.)
19:51:57 <dino-> If anybody finds it helpful, script to test build a package after sdist: http://ui3.info/darcs/scripts/hs-test-build
19:51:58 <thoughtpolice> makes me want to find a use case for repa now :)
19:52:05 <thoughtpolice> i wonder what the changes for repa3 are...
19:56:33 <kmc> yeah i saw that on reddit :)
19:56:46 * kmc pushes gloss onto the stack of things to learn
19:57:42 <hpaste> kmc pasted “duplicated unsafePerformIO” at http://hpaste.org/53188
19:57:53 <kmc> thoughtpolice, here's my small reproducer
19:59:53 <kmc> anyone else is also encouraged to give it a try :)
20:00:34 <cepete02> Hello, I'm trying to get a space separated string from the console (getLine) convert it into a string array (splitWs) convert it into an Int array, and assign each element of the array into a variable.  Can anyone help me out with this.  I have been struggling with it for a while now (newbie)
20:01:06 <kmc> :t fmap (map read . word) getLine
20:01:07 <lambdabot> Not in scope: `word'
20:01:10 <kmc> :t fmap (map read . words) getLine
20:01:11 <lambdabot> forall a. (Read a) => IO [a]
20:01:59 <thoughtpolice> yeah gloss is quite fun, i played with it a little.
20:03:43 <shachaf> kmc: Yep, unsafePerformIO gets compiled to unsafeDupablePerformIO.
20:04:44 <thoughtpolice> yep, same here
20:05:02 <shachaf> kmc: Hmm, the behavior still happens even when adding noDuplicate to the unsafePerformIO block manually.
20:05:09 <shachaf> I must misunderstand noDuplicate. :-)
20:05:33 <shachaf> Oh, wait, the noDuplicate is inserted anyway.
20:05:47 <ddarius> byorgey: Category is a good example of a polymorphically kinded type class and it will also benefit greatly from kind level products as well.
20:05:58 <kmc> unsafePerformIO x = unsafeDupablePerformIO (noDuplicate >> x)
20:06:06 <shachaf> Right.
20:07:37 <shachaf> So what's noDuplicate actually supposed to do?
20:08:30 * shachaf is foiled by ack-grep not searching files again. :-(
20:09:13 <kmc> shachaf, locks against a global MVar, I think
20:09:15 <kmc> ironic, eh
20:09:26 <kmc> that's not quite right though
20:09:29 <kmc> there's a noDuplicate# primop
20:09:36 <shachaf> Ah, there's documentation.
20:13:44 <andy_> can anyone give me a good definition of type-schemes vs. types?
20:14:18 <Guest51379> can anyone give me a good definition of type-schemes vs. types? (not sure if went through - changed my nicname..)
20:14:19 <shachaf> Guest51379: That depends on what a type-scheme is.
20:14:29 <shachaf> Also, andy_ was better than Guest51379. :-)
20:14:29 * Eduard_Munteanu wonders that too
20:14:45 <shachaf> Guest51379: Is there a place where that terminology is used?
20:15:05 <Guest51379> well, it appears to be defined as a type where some of the type variables are universally quantified (not sure if that last term is correct)
20:15:19 <Guest51379> reading a paper on hindley-milner type inference via constraints
20:17:12 <Guest51379> it defines it as omega := forall alpha vector. tau
20:17:22 <Guest51379> where tau is a type
20:17:31 <ddarius> newtype Nat hom f g = Nat (forall a. hom (f a) (g a)); instance Category (hom :: k1 -> k1 -> *) => Category (Nat hom :: (k2 -> k1) -> (k2 -> k1) -> *) where id = Nat id; Nat f . Nat g = Nat (f . g)
20:18:09 <ddarius> Guest48922: In that context, types are monomorphic types and type-schemes are rank-1 polymorphic types.
20:20:10 <Guest51379> hmm
20:24:56 <ddarius> newtype Prod c d x y = Prod (c x x) (d y y); instance (Category c, Category d) => Category (Prod c d) where id = Prod id id; Prod f g . Prod h k = Prod (f . h) (g . k)
20:25:14 <ddarius> s/newtype/data/
20:26:53 <ddarius> data Iso c x y = Iso (c x y) (c y x); type Adjunction f g = Iso (Nat (->)) f g
20:27:06 * ddarius wants to build a darcs GHC now.
20:29:04 <ddarius> instance Category hom => Category (Iso hom) where id = Iso id id; Iso f f' . Iso g g' = Iso (f . g) (g' . f')
20:29:12 <ddarius> Now we have a category of adjunctions.
20:30:57 * hackagebot happindicator 0.0.1 - Binding to the appindicator library.  http://hackage.haskell.org/package/happindicator-0.0.1 (AndrewMiller)
20:32:17 <ddarius> Oops, I'm an idiot.
20:34:21 <thoughtpolice> ddarius: i find that hard to believe
20:34:31 <Guest51379> can a type variable be a monomorphic type?
20:34:42 <Guest51379> need a good definition for "monomorphic"
20:34:57 <byorgey> Guest51379: monomorphic = not polymorphic, i.e. containing no type variables.
20:35:01 <ddarius> My Adjunction type is just the type of natural isomorphisms (assuming the obvious laws for Iso are defined.)  An adjunction is a natural isomorphism, but it is a particular natural isomorphism.
20:35:09 <copumpkin> a type variable will typically only get instantiated to monomorphic types
20:35:22 <ddarius> Impredicativity ho!
20:35:30 <copumpkin> you callin me a ho, ho?
20:35:55 <ddarius> That would be "Impredicativity, ho!", ho!
20:36:15 <ddarius> s/defined/satisfied/
20:40:26 <ddarius> type Adjunction c d f g = Iso (Nat (->)) (forall (a,b). c (f a) b) (forall (a,b). d a (g b))
20:41:32 * ddarius somehow expects that type can't be handled in this form even by the latest GHC, but he is pretty sure it could be made to work with some suitable intermediate types or type families.
20:46:24 <Saizan> you want lambdas not foralls there
20:46:46 <ddarius> Saizan: Yes.
20:47:27 <ddarius> I suspect I'd need to introduce actual types to capture those two type expressions.
20:53:59 <byorgey> ddarius: yeah, and they'd have to be newtypes because type families and type synonyms can't be partially applied.
20:54:44 <byorgey> but another thing I am investigating is a way to allow such partial applications
20:54:58 <stepcut> byorgey: that would be swell
21:10:57 * hackagebot type-unary 0.1.3 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.3 (ConalElliott)
21:49:52 <vharishankar> > exp (log 10)
21:49:53 <lambdabot>   10.000000000000002
21:49:58 <vharishankar> log (exp 10)
21:51:50 <vharishankar> Hmm why exp (log x) and log (exp x) do not give the same answer? There floating point imprecision
21:53:10 <Axman6> > exp (log 10) :: CReal
21:53:11 <lambdabot>   10.0
21:53:19 <Axman6> > log (exp 10) :: CReal
21:53:20 <lambdabot>   10.0
21:53:40 <vharishankar> OK thanks
21:54:03 <vharishankar> Is there any specific reason it has to work that way?
21:56:44 <kmc> a specific reason why floating point arithmetic is imprecise/
21:56:44 <kmc> ?
21:57:14 <vharishankar> OK, but I thought since haskell was math oriented, they would fix that by default
21:57:32 <vharishankar> I was just surprised a bit that's all
21:57:37 <ulfdoz> It is not broken, it is a result of limited length floating point numbers.
21:57:52 <kmc> Haskell is not "math oriented"
21:57:59 <kmc> and math is not arithmetic
21:58:43 <Cale> hmm, there's something weird about the repa "quasicrystal" demo that benl put on YouTube
21:59:25 <Cale> Each frame seems to be doubly periodic
21:59:47 <vharishankar> Where is CReal imported from?
22:00:12 <Cale> http://hackage.haskell.org/package/numbers
22:00:17 <Cale> Data.Number.CReal
22:00:26 <kmc> you probably do not want to use CReal for most tasks
22:00:42 <vharishankar> Thanks . found that out
22:00:47 <kmc> performance will be terrible, and you can't even compare them for equality
22:00:56 <kmc> (because equality of computable real numbers is undecidable)
22:00:57 <vharishankar> OK
22:01:18 <kmc> for simple exact arithmetic, use Rational
22:01:32 <vharishankar> Thanks
22:01:39 <kmc> (of course you will have to explicitly approximate things like log and exp and pi)
22:01:56 <kmc> there is also http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/Data-Fixed.html
22:02:50 <vharishankar> There certainly seems to be a lot of options.
22:03:10 <kmc> *nod*
22:03:17 <kmc> representing real numbers in a computer is a hard problem
22:03:23 <vharishankar> I wanted to ask something : is f (g x) a higher order function?
22:03:29 <kmc> well, it's an impossible problem, but even approximating it in a way that makes people happy is a hard problem
22:03:29 <coppro> it's an unsolvable one
22:03:31 * BMeph prefers tau. It's like two pi, Dude. ;)
22:03:35 <kmc> vharishankar, not necessarily
22:03:43 <coppro> vharishankar: what kmc said
22:03:50 <kmc> a higher-order function is a function which takes a function as an argument, or returns a function as its result
22:04:10 <kmc> so every "two-argument function" in Haskell is technically a HOF
22:04:19 <kmc> but what you've written there might or might not be an application of HOFs
22:04:25 <Cale> (though mostly we don't consider the latter to be higher order in Haskell)
22:04:26 <shachaf> I like that word there, "technically".
22:04:31 <vharishankar> Should it return a function to make it higher order?
22:04:32 <shachaf> We don't?
22:04:50 <kmc> vharishankar, (g x) might be a function, in which case f is a HOF
22:04:51 <Cale> Yeah, because functions which return other functions as their result are just multiparameter functions ;)
22:05:03 <shachaf> Cale: Right; what's not higher-order about that?
22:05:11 <kmc> there are cases where it's nicer to think of them otherwise
22:05:16 <vharishankar> Cale: thanks
22:05:17 <kmc> like map :: (a -> b) -> ([a] -> [b])
22:05:54 <Cale> I would say that the order of a non-function type is 0, and the order of s -> t is max(s+1,t)
22:06:05 <kmc> :)
22:06:07 <vharishankar> Assuming g x = x^2 and f g x = f (g x) then it is higher order, right? Or am I confusng myself?
22:06:08 <kmc> that's like rank
22:06:09 <Cale> Or, rather max(order(s)+1, order(t))
22:06:27 <kmc> vharishankar, in that example, f is a higher-order function, because it takes a function g as an argument
22:06:33 <kmc> but it's also a recursive definition which probably doesn't type check
22:06:34 <Cale> and then 'higher order function' means order degree 2 or more
22:06:56 <kmc> a higher-order function is a function which takes a function as an argument, or returns a function as its result
22:07:03 <vharishankar> OK. So higher order need not be recursive?
22:07:06 <kmc> correct
22:07:17 <kmc> > let double f x = f (f x) in double (+1) 3
22:07:19 <lambdabot>   5
22:07:29 <BMeph> vharishankar: Also, see map, above. :)
22:07:29 <kmc> double is a HOF, because it takes a function f as an argument
22:07:33 <kmc> but it is not recursive
22:07:33 <vharishankar> so g x = x^2 and f g x = log (g x) is a higher order
22:07:53 <coppro> kmc: This is a bit of a fuzzy deifnition when currying exists.
22:08:00 <Cale> So, the order of Int -> Bool is then max(0+1,0) = 1, and then the order of Int -> (Int -> Bool) is max(0+1, 1) = 1 as well
22:08:10 <Cale> so Int -> (Int -> Bool) isn't higher order, by my definition
22:08:14 <kmc> vharishankar, in that example, f is a HOF, g is not.  you also may be getting confused because f's argument has the same name as the outer g you defined
22:08:20 <shachaf> > let double x = x + x in double (double 5)
22:08:21 <lambdabot>   20
22:08:24 <kmc> also, don't get too hung up on terminology
22:08:32 <Cale> But (Int -> Bool) -> Bool, say, has order max(1+1,0) = 2
22:08:36 <Cale> and is higher order
22:08:40 <shachaf> kmc++
22:08:40 <shachaf> Terminology is stupid.
22:08:47 <kmc> it's not stupid
22:08:54 <shachaf> I mentally pronounce most operators in Haskell as different kinds of grunts.
22:08:58 <kmc> it's necessary for communication
22:09:10 <kmc> but if you're communicating effectively in code, don't get too hung up on which words describe your code
22:09:23 <kmc> sometimes it is better to learn how to use the code first, and learn what other people call it later
22:09:35 <vharishankar> OK thanks
22:09:44 <vharishankar> I keep confusing the name of argument
22:09:55 <BMeph> kmc: E.g., "monads" <insert gratuitous eye roll here> ;)
22:10:04 <vharishankar> It could be anything
22:10:20 <Cale> vharishankar: Does my definition of the order of a function type make some kind of sense? It's not terribly important, but I think it captures how most people think about what's higher order in Haskell.
22:11:34 <Cale> That is, order(T) = 0 when T is not a function type, and order(S -> T) = max(order(S) + 1, order(T))
22:11:51 <Cale> (for any types S and T)
22:12:12 <vharishankar> OK, I will try to figure that one out
22:12:17 <Cale> Things of order 0 are not functions
22:12:24 <Cale> Things of order 1 are ordinary functions
22:12:34 <Cale> Things of order 2 and more are called higher order functions
22:12:49 <vharishankar> Thanks
22:13:14 <vharishankar> I understand. A function is a 3rd order function when the order of one of its arguments or return is 2nd order
22:13:30 <vharishankar> I mean return as in result
22:13:35 <Cale> When either its argument is 2rd order, or its result is 3rd order
22:14:01 <vharishankar> Or both?
22:14:07 <Cale> Or both, sure :)
22:14:22 <kmc> speaking of terminology, can anyone give a precise definition of a CAF?  a top-level binding is a CAF if it's an application, and isn't a CAF if it's a lambda
22:14:27 <kmc> but what about other forms like "let"
22:14:36 <vharishankar> So it can result in an absolute value or can result in another function
22:14:45 <kmc> functions are values
22:14:49 <kmc> "absolute value" is not a thing
22:14:57 <kmc> the sooner you stop mentally special-casing functions, the better
22:15:10 <kmc> this is a reason not to worry about "higher order functions"
22:15:13 <kmc> they are, after all, functions
22:15:21 <vharishankar> OK
22:15:25 <Cale> well, replace "absolute" with non-function, and nobody will complain ;)
22:15:40 <kmc> i'll complain that it's a distraction
22:15:43 <kmc> the sooner you stop mentally special-casing functions, the better
22:16:00 <Cale> Heh, a function which results in another plain function isn't higher order, by my definition
22:16:08 <vharishankar> Non-functions, ok
22:16:16 <kmc> i will define floobity-floo functions as those functions which either return a Char or take as an argument a function which takes an Int
22:16:20 <Cale> You don't want to call those higher order because they're just multi-parameter functions
22:16:39 <vharishankar> Maybe that's why I got confused by reading tutorials. :-)
22:16:42 <Cale> A -> (B -> C) is the same thing pretty much as (A,B) -> C
22:16:58 <Cale> (they're isomorphic, by currying and uncurrying)
22:17:28 <Cale> So we usually mentally identify the two, to some extent
22:18:03 <kmc> i don't
22:18:23 <vharishankar> Is it better then to forget the concept behind it and simply use it as a tool when needed?
22:18:39 <kmc> i don't really know what that means, but I'm going to go with "yes"
22:18:54 <Cale> vharishankar: To be honest, it has never really mattered to me exactly what order my functions are.
22:19:13 <Cale> vharishankar: you should just be aware that functions can take other functions as parameters and make use of that :)
22:19:19 <vharishankar> I mean, that as in forget how it's supposed to work, just see if it works.
22:19:32 <vharishankar> Cale: thanks.
22:19:42 <kmc> you should be aware that functions are values like any other
22:19:48 <Cale> If you have a bunch of functions which are the same except for one little piece, you usually want to make that piece into a parameter
22:19:57 <kmc> which means it's not so remarkable that functions can take functions as arguments or return them
22:20:08 <Cale> Sometimes the piece is a function, and if you couldn't make it a parameter, that would prevent you from factoring the code properly
22:20:19 <Cale> So, we let it be a function :)
22:20:22 <vharishankar> Right.
22:20:38 <vharishankar> It's not so different from how we use functions in imperative programming then
22:21:02 <vharishankar> Except of course, we USE other functions, rather say methods.
22:21:07 <Cale> Sure, except that in most(?) imperative languages, there's no support for doing this.
22:21:31 <Cale> Or weak, broken support, when there is.
22:21:33 <vharishankar> I mean as call other methods within methods??? Is that a good mental approximation.
22:21:53 <Cale> vharishankar: Call methods within methods which you received as a parameter?
22:21:55 <kmc> no most "imperative languages" support first-class functions too
22:22:00 <kmc> it's just that Java doesn't
22:22:08 <Cale> Well, all the old ones don't :)
22:22:10 <kmc> (and C and C++)
22:22:11 <kmc> except people hack it in anyway
22:22:22 <kmc> Lisp is a very old imperative language which supports first-class functions
22:22:25 <kmc> (though it didn't initially)
22:22:29 <Cale> Almost all the imperative languages when I stopped programming in imperative languages, which was like 10 years ago
22:22:40 <kmc> Cale, you don't program in Haskell?
22:22:49 <companion_cube> kmc: really ? it did not ? I thought it was designed after lambda calculus...
22:22:56 <kmc> so was Java
22:22:58 <vharishankar> Cale: No, not as parameters
22:23:02 <Cale> "imperative language" = "language which forces you to program imperatively"
22:23:11 <kmc> that's not a reasonable definition
22:23:29 <Cale> kmc: It works for me :)
22:23:29 <kmc> if you want a term that means "not a functional language" then i suggest "not a functional language"
22:23:33 <kmc> or "dysfunctional language" for short
22:23:41 <companion_cube> by "after" i meant "based on", not a temporal relation
22:24:06 <Cale> Otherwise, most things become imperative languages, because it's really easy to simulate imperative programming with most other kinds of abstractions.
22:24:07 <vharishankar> I am a total newbie to functional programming, but there are some problem domains where the problem is inherently stateful and dependent on the "outside" world
22:24:35 <kmc> anyway, I don't think arguing about what "imperative language" means or what "higher-order function" means is interesting
22:24:36 <Cale> vharishankar: Are you familiar with OO?
22:24:37 <vharishankar> So dysfunctional is a bit unfair. :)
22:24:53 <kmc> vharishankar, you misunderstand.  languages which exclude FP are dysfunctional
22:24:57 <Cale> vharishankar: And in particular, are you familiar with Model/View/Controller?
22:25:02 <kmc> vharishankar, languages which allow you to use FP or IP as the task requires are not
22:25:14 <kmc> in fact functional imperative programming is quite powerful
22:25:19 <vharishankar> Python I am familiar with
22:25:36 <kmc> vharishankar, the "paradigms" are bullshit anyway, just learn a good language and learn its tools and how to use them together
22:25:47 <vharishankar> I learn C and C++ in school. I have used PHP also to design my website.
22:25:56 <vharishankar> that should be learnt
22:25:58 <Cale> If so, then you can think of the separation between model and view/controller as *roughly* being how to separate your program into pure and I/O components.
22:26:11 <vharishankar> I am not 100% comfortable with OO either.
22:26:17 <kmc> the only reason to define arbitrary categories like "imperative language" or "higher-order function" is to facilitate communication between humans
22:26:26 <kmc> which they empirically do not do in #haskell
22:26:30 <Cale> Often lots of pure stuff can be pushed into the view and controller as well, but the view and controller will be doing input and output
22:26:32 <mzero> no no -- PHP should *never* be learnt!
22:26:41 <adnam> Cale: that's a pretty good analogy
22:26:41 <Cale> and the model will be entirely pure
22:26:45 <vharishankar> I couldn't get Java because it's full of nested abstracted classes.
22:26:55 <vharishankar> And interfaces
22:27:12 <Cale> (The model is a declarative specification of what the program does, as a function from inputs to outputs)
22:27:21 <vharishankar> kmc: yes. I agree with you.
22:29:05 <vharishankar> mzero: PHP was inevitable as it is supported by 90% of the web hosting companies. :-)
22:30:04 <mzero> well, just don't learn it -- put yourself in a trance when you have to write it so that none of it will rub off on your other coding.
22:31:01 <vharishankar> Well, I use it just for my website. I created my blog in PHP. BUt I agree, as a general purpose language PHP is retarded.
22:31:12 <mzero> which reminds me... who wants to start a Haskell based web hosting company.....   (ducks)
22:32:33 <vharishankar> Nearlyfreespeech.net supports Haskell CGI
22:32:39 <mzero> yikes - my Haskell video has almost hit 6k views!
22:33:13 * Axman6 was one of them
22:33:13 <shachaf> mzero: Is Bay Hac happening roughly the same time in 2012 as 2011?
22:33:34 <mzero> uhm... er... ahhh.... well....
22:33:46 <mzero> I suppose I'm sorta on the hook to run that again, eh?
22:34:11 <mzero> haven't picked a weekend yet
22:34:12 <cwl> where can I find the source after cabal install some package
22:34:15 <mzero> but, yeah
22:34:36 <mzero> just "cabal unpack" it anywhere you like
22:34:43 <mzero> you don't even need to have installed it when you do!
22:35:31 <mzero> c'mon, Axman6 - pretty sure you knew everything in that talk!  :-)
22:35:39 <augur> ski
22:36:13 <augur> you still havent told me which of those papers "talks about judgements `Gamma; Delta ---> B', corresponding to a linear logic judgement `!Gamma , Delta |- B'"
22:36:14 <vharishankar> Thanks, all. for the very informative discussion. :-)
22:38:29 <Axman6> mzero: sure, but it was still a good talk =)
22:38:40 <mzero> thanks!
22:38:51 <augur> ski: nor which talk about the copy and discardable results
22:39:22 <Axman6> mzero: it's now one of my resources i gave to people who want to learn haskell
22:39:32 <mzero> yay
22:44:19 <kirindave> Axman6, what is?
22:45:41 <Axman6> kirindave: mzero's google tech talk on haskell
22:45:50 <mzero> http://www.youtube.com/watch?v=b9FagOVqxmI&feature=feedu
22:46:04 <mzero> Slides: http://www.ozonehouse.com/mark/haskell-amuse-bouche/slides.html
22:46:09 <mzero> Code: https://github.com/mtnviewmark/haskell-amuse-bouche
22:46:12 <kirindave> Oh, that's you up there, mzero?
22:46:14 <mzero> :-)
22:46:19 <kirindave> Nice talk. Watched it the other day.
22:46:20 <mzero> yes, that's me!
22:46:44 <mzero> c'est moi: mzero@google.com
22:46:52 <kirindave> Although everyone I've shown it to deadpans to me, "How much haskell do they really use at google?" :)
22:47:12 <mzero> I'm tryin' to change that!
22:47:24 <mzero> Well over 120+ people showed up for that talk
22:47:32 <Axman6> nice
22:47:39 <shachaf> mzero: How did you get a five-character gma... Oh.
22:47:39 <byorgey> mzero++
22:47:52 <mzero> 80 in the live audience, and the balance video-conferenced in from ~10 locations world-wide
22:48:33 <mzero> byorgey: I thought we didn't do state modification in this channel...
22:48:35 <shachaf> mzero: Did you use to work at Google a while ago?
22:48:42 <mzero> I still work at Google
22:49:07 <mzero> or, if you're asking, I've worked there since Aug. 2010
22:49:11 <byorgey> mzero: we don't. I just made a new copy of you with one more karma point.  The old you will be garbage collected any minute now.
22:49:25 <shachaf> Oh, so you didn't during e.g. BayHac.
22:49:28 <shachaf> OK.
22:49:35 <shachaf> Wait, no, you did.
22:49:40 <mzero> I did
22:49:41 * shachaf gets years wrong.
22:49:43 <shachaf> Never mind.
22:50:19 <augur> byorgey: stop writing papers :|
22:54:24 <thoughtpolice> mzero: plenty of people in other channels on freenode have told me they watched your talk and said they really liked it. i told them you are awesome and this wasn't your first attempt teaching haskell to lots of people :)
22:54:41 <mzero> oh! that's nice to hear
22:55:17 <thoughtpolice> several people particularly mentioned that your talk helped them "get it" a lot more than other talks. feels good, man :)
22:55:22 * mzero thinks of ways to schedule more mass-teach-ins
22:55:35 <BlankVerse> any database library in haskell which doesn use c function calls?
22:55:54 <shachaf> mzero: You could probably get other people involved in running it if you needed.
22:56:40 <mzero> well it validates my belief that Haskell needn't be thought of as some acid-trip for deep-math-geeks!  I think Every-Programmer could "get it"
22:59:30 <ddarius> There are probably one or two that can talk a network format and probably plenty more that can send commands over a pipe.
23:00:20 <frerich> mzero: I wasn't aware of your google tech talk until it was mentioned here on IRC. It seems really nice - I'll forward this to our internal dev@ mailing list. Maybe it teases a few colleagues into trying Haskell :-)
23:01:31 * ddarius didn't like that Mark described (.) as built-in but did like the energy.
23:01:34 <mzero> I gave the original talk at Twilio at the request of a friend there -- it was a smaller crowd (~25) and they had a blast -- I answered questions for over an hour afterward!
23:01:47 <shachaf> What's the talk?
23:01:59 <mzero> ah - to that crowd I ment "built-in to the standard libraries"
23:02:17 <mzero> true - I should have made it clear
23:02:29 <mzero> http://www.youtube.com/watch?v=b9FagOVqxmI&feature=feedu
23:02:42 <mzero> (code and slides available too...)
23:02:56 * shachaf adds to heap.
23:03:14 <ddarius> @google torsor heap
23:03:15 <lambdabot> http://www.facebook.com/pages/Groud/133009616735255
23:03:15 <lambdabot> Title: Incompatible Browser | Facebook
23:03:20 <ddarius> Wtf?
23:03:39 <ddarius> I guess Groud is another name.
23:05:07 <mroman> I like the BOOM ;)
23:05:32 * ddarius eagerly awaits System Fc pro pro.
23:06:57 <mzero> "big ba-da-BOOM"
23:07:59 * ddarius could watch the Fifth Element yet again.
23:08:56 <frerich> mzero: One thing came to my mind while watching you talk: you mentioned type inference and then you showed that 'byLines indent' wouldn't typecheck. I think that would have been a good moment to show the type signatures of the functions which were previously given to 'byLines' (sort, reverse, take 2). That would have shown that they are all functions [String] -> [String], but the 'indent' function is String -> String.
23:09:23 <frerich> mzero: That not only explains the compile error, it also shows that it can be beneficial to explicitely add type signatures to verify that what the compiler is doing is indeed what you intend.
23:09:46 <ddarius> In that vein, it may have been more dramatic to demonstrate the generalization example by simply removing the type signature.
23:10:00 <frerich> mzero: And after that, the 'map' function could be explained afterwards to show how to fix things.
23:10:24 <frerich> (which you do, of course)
23:10:29 <ddarius> Train your audience in TDP.
23:10:30 <mzero> frerich - I like the idea of showing those type signatures there, at the point of the error --- I didn't want them in the earlier slides
23:10:52 <shachaf> TDP?
23:11:01 <mzero> because it broke that sort of initial feverish flow at the start there
23:11:05 <frerich> mzero: Yes I think it makes perfect sense to not show them earlier.
23:11:09 <mzero> but at the BOOM it would work
23:11:12 <mzero> good idea
23:11:38 <frerich> mzero: Yes. In fact, I think it's actually useful in "real life", too. When I get compiler errors, and I don't have a signature yet, I add one and that actually catches the problem earlier.
23:11:46 <ddarius> shachaf: Type-driven programming.
23:12:13 <mzero> true - I do too - especially for functions in where bindings where I typically leave them off
23:15:51 <ddarius> byorgey: I think some of my later kind polymorphic examples go beyond what you support even if I did add some more data declarations.
23:16:15 <ddarius> Though I'm pretty sure much of it could still be done with less genericity.
23:16:56 <mroman> I agree. The first thing I do when ghc tells me there is a type error is to write the type signature explicit and feed it to ghc again.
23:17:09 <mroman> Because then the type errors are more understandable.
23:17:16 <ddarius> byorgey: In fact, I think I run into all three of the bulleted items in section 3.3.
23:17:20 <mroman> ghc sometimes infers the heck out of functions :)
23:18:05 <elliott> (Technical term.)
23:18:13 * ddarius should play with Ωmega some time.
23:19:03 * QtPlatypus doesn't like writing type signatures "If the type inferer is there, then I should be able to use it"
23:19:29 <elliott> QtPlatypus: Work with the type system; tell it what you mean and it'll tell you when you make a mistake.
23:19:37 <elliott> Rather than showing up an error at the use site, which is very unhelpful.
23:19:47 <QtPlatypus> And it normally makes better signatures then I do.
23:19:56 <elliott> That won't change without practice.
23:20:27 <c_wraith> It's important to know when to write as general a signature as possible, vs when to restrict it.
23:20:51 <c_wraith> I mean, a function like asTypeOf intentionally doesn't have the most general possible signature, and it's more useful because of that.
23:21:04 <ddarius> People rarely use asTypeOf.
23:21:16 <ddarius> People use it's more general counterpart much more often.
23:21:18 <c_wraith> well, without ScopedTypeVariables, there are problems you need it to solve.
23:21:28 <c_wraith> and const cannot solve those problems.
23:22:00 <ddarius> You don't really need asTypeOf to solve those, though it is occasionally useful for that.
23:22:14 <ddarius> Also, in my opinion, lexically scoped type variables should have always existed.
23:22:39 <c_wraith> I agree with that.
23:24:06 <QtPlatypus> The only time I tend to write explict types is when I'm writing an interface or dealing with recursive types.
23:26:08 <BlankVerse> and haskell database library which doesnt use C bindings aka pure haskell code?
23:27:02 <mzero> BlankVerse: you mean one which talks to the DB via networking, and all done from Haskell? hard to do since the network protocol of most DBs isn't well specified
23:27:32 <mzero> Most DBs only define their interface in terms of a C library (or ODBC, which is, the same)
23:27:51 <BlankVerse> mzero: how about the one which happstack uses .. acid-state
23:27:56 <salisbury> I spend *alot* less time debugging when I use signatures
23:28:08 <mzero> don't know that one
23:28:18 <elliott> If I'm writing a binding to an MIT-licensed C library with the intention of putting it on Hackage, should I license my binding as MIT or the more-common-for-Hackage BSD3? They're practically equivalent, but I'm not sure which it would be better to stay consistent with. :)
23:28:30 <shachaf> elliott: MIT
23:28:34 <shachaf> It's better than BSD3 anyway.
23:28:42 <mzero> ah - that is a whole database implementation
23:29:06 * shachaf kind of wants to release something under "MIT, but with the NO WARRANTY OR ANY PARTICULAR PURPOSE etc. text normalcased".
23:29:07 <elliott> shachaf: Well, I agree that it's nicer (though ISC is nicer still), but it's more about the consistency than the merits in this case. :p
23:29:11 <shachaf> I wonder if it's even legal to do that.
23:29:30 <slack1256> elliot go with MIT as shachaf said also the library you are biding is also MIT *consistency*
23:29:36 <elliott> shachaf: I think that stuff would be ineffective if not uppercased or, like, bolded.
23:29:50 <elliott> slack1256: Most of Hackage is BSD3 -- consistency! But yeah, I'll go with MIT.
23:29:51 <BlankVerse> is there any way to safely use forkIO on functions which use unsafe C-binding databases then?
23:29:53 <shachaf> elliott: Or in 72-point font?
23:30:12 <elliott> shachaf: Presumably! I think it's some precedent as to what constitutes "easily visible"; uppercase does so nobody bothers trying anything else.
23:30:17 <shachaf> I think you're just supposed to make that part stand out, so people don't write it in tiny fine print.
23:30:18 <elliott> Because legalese is write-only code.
23:30:22 <slack1256> elliott: is *consistency* xD
23:30:29 <shachaf> But in a 2-paragraph license, it's probably OK to have it as one of the paragraphs.
23:30:37 <elliott> Probably! Want to risk it?
23:30:40 <BlankVerse>  SqlError {seState = "", seNativeError = 21, seErrorMsg = "prepare 32: INSERT INTO images VALUES (?,?): library routine called out of sequence"}
23:30:48 <BlankVerse> on using forkIO
23:30:50 <shachaf> Also, I'd want to take some redundancies out.
23:30:53 <shachaf> "to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software"
23:31:10 <mzero> night all
23:31:17 * elliott waits for shachaf to totally unravel the MIT license, and then discover that everything he removed is really important, legally.
23:31:17 <shachaf> All those examples are unnecessary when it first defines an entire class and then gives specific instances.
23:31:48 <shachaf> elliott: I considered doing that for the last thing I released under the MIT license, but then I decided I didn't want to accidentally end up providing a warranty for it.
23:32:18 <shachaf> If I was releasing something on Hackage, I'd probably want to use MIT just because it's a member of the ADT.
23:32:33 <slack1256> what is ADT?
23:45:58 <Varakh> > let x = 5; x
23:45:59 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:46:02 <Varakh> > let x = 5
23:46:03 <lambdabot>   not an expression: `let x = 5'
23:46:06 <Varakh> -.-
23:46:37 <Varakh> > let x = 5 in x+x
23:46:38 <lambdabot>   10
23:46:44 <Varakh> > let x = 5 in x+x*5
23:46:45 <lambdabot>   30
