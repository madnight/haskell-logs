00:25:02 <cwl> unable to cabal install leksah
00:25:38 <cwl> setup: The pkg-config package gtksourceview-2.0 version >=2.0.2 is required
00:25:44 <cwl> but it could not be found
00:28:37 <cwl> fixed, need to install gtksourceview first
01:12:27 <newsham> http://www.anchormodeling.com/modeler/latest/
02:05:22 * hackagebot quicklz 1.5.0.8 - binding to QuickLZ compression library  http://hackage.haskell.org/package/quicklz-1.5.0.8 (AustinSeipp)
02:11:28 <lightstep> if i already have ghc installed, how do i upgrade to the new version? i noticed the configure script tests for an old ghc installation
02:11:53 <lightstep> so should i just build normally?
02:26:37 <shachaf> lightstep: There's no real "upgrading" of GHC.
02:26:42 <shachaf> You just install a new version.
02:28:32 <lightstep> i dont want it to get confused: old package files, maybe it'll see old libraries and think they're its own, etc
02:28:46 <kmc> it is pretty clever about that
02:28:56 <shachaf> No, that doesn't generally happen.
02:29:07 <shachaf> Different versions of GHC can more or less coëxist without an issue.
02:29:19 <shachaf> You'll need to reinstall all your Cabal packages, though.
02:30:19 <alpounet> lightstep, when you install a package, it gets handled by the ghc-pkg associated to your ghc version, and thus installed in a place specific to that version. so you can install a new ghc version, it won't know about these libraries. and you can specify which ghc and ghc-pkg you want cabal to use when installing a package through cabal
02:30:25 <lightstep> is there a command for cabal to do that?
02:30:42 <lightstep> "upgrade" was deprecated last time i checked
02:32:13 <alpounet> lightstep, there isn't any
02:32:16 <alpounet> good luck heh
02:32:38 <azorius> greetings haskell pros :)
02:32:48 <lightstep> oh, alpounet, didn't see your first message. thanks
02:32:50 <kmc> hi azorius :)
02:32:53 <azorius> hi :)
02:32:58 <azorius> I am very new to haskell
02:33:19 <azorius> I started larning it this weekend ;)
02:33:22 <azorius> and so fare I like it
02:33:38 <azorius> I come from a python background
02:33:39 <shachaf> Wow, how did that 'e' move a line down to almost the same place?
02:33:42 <shachaf> Impressive. :-)
02:33:53 <alpounet> lightstep, you may want to look at your ~/.cabal/ and your ~/.ghc/ to get an idea of how things are organized
02:34:05 <shachaf> azorius: Feel free to ask any questions here if they come up! What guide/tutorial/book are you using?
02:34:29 <azorius> I use Learn yourself a haskell for greet good
02:35:28 <azorius> I am currently undertaking a PhD in Computational Biology but I am acualy educated in Biochemestry and therefore have no formal traning in programming
02:35:41 <azorius> I am trying to follow the "teach yourselth programming in 10 years" guide :)
02:36:00 <azorius> and I figured that haskell is the functional language I would like to pick up ::))
02:36:06 <ohwow> cool
02:36:24 <ohwow> i'd recommend SICP it takes some time to read it through
02:36:32 <azorius> anyway, I am also learning perl because that's used a lot at work and so is R (both language are new to me)
02:37:03 <ohwow> Perl is easy, unless you use some dirty hacks
02:37:15 <azorius> I am also surprised how easy perl is
02:37:21 <c_wraith> perl has parts that aren't dirty hacks?
02:37:33 <ohwow> c_wraith: :p
02:37:36 <azorius> I have written two functional parsers in perl and 2 weeks ago I couldn't do Hello world ;)
02:37:48 <c_wraith> (I once built a huffman decoder in perl.  as a regex)
02:37:49 <azorius> anyway... we have super computers to do stuff for us
02:38:02 <azorius> so speed is rarely an issue
02:38:07 <azorius> so python is "fast enugh"
02:38:11 <shachaf> c_wraith: We need an OlegFacts equivalent for regexps.
02:38:52 <azorius> my question is generaly... how easily does haskell and python interface and how well does haskell interface to C/C++ compared to python?
02:39:33 <alpounet> haskell interfaces very well to C (but with C++ things are WAY more complicated)
02:39:33 <c_wraith> GHC's only foreign interface is to C.  You need to bridge through that.  However, that might already be done somewhere. :)
02:39:34 <azorius> can you link me to SICP?
02:39:37 <alpounet> i don't know about python though
02:39:41 <shachaf> azorius: Haskell interfaces with C quite easily.
02:39:47 <c_wraith> python's only foreign interface is to C also. :)
02:39:58 <shachaf> azorius: It doesn't generally interface with C++, but few things actually do.
02:40:24 <azorius> ok
02:40:32 <azorius> I guess that SWIG is also C... :)
02:41:08 <azorius> my C/C++ programming level is ridiculous low
02:41:28 <azorius> is it possible to compile something in haskell and then import it in python?
02:41:33 <c_wraith> I've written small bindings to C libraries in both haskell and python.  Both were clean operations.  But I don't know about making them talk to each other.
02:42:32 <azorius> sorry my kids are sick, so if I take a few minuts to reply, you know the reason
02:42:54 <kmc> azorius, yes, it's possible
02:42:55 <kmc> via C
02:43:09 <kmc> here's a good introduction to the C interface:  http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
02:44:57 <azorius> but just so I understand, if I use python (mainly) and haskell to make algorithms, then importing the algorithms in python will have to go tru C?
02:45:06 <azorius> I am sorry I ask so useless questions :)
02:45:33 <azorius> the good thing is what we mostly do is scripting, so I can just make the most intensive scripts in haskell ;)
02:47:07 <yitz> azorius: there are two python/haskell bridges on hackage, look for them. that is a different approach; not necessarily better than via c
02:48:23 <yitz> azorius: they start a python intererpreter and let you access the python objects and their methods in haskell
02:48:42 <azorius> yes... just read... seems sweet
02:49:13 <azorius> because my current python level is way higher than my haskell level I would prefere it the other way around ;)... but it definalty seems sweet
02:49:38 <yitz> azorius: interfacing haskell with c is much easier than interfacing python with c
02:49:41 <azorius> but firstly I should learn the language... I mostly came here just to get a feel for what the language can :)
02:50:19 <azorius> that's good to know yitz... because I do not think it's easy in python... my lab has has some strange SWIG warnings :)
02:50:21 <yitz> azorius: yep you've come to the right place :)
02:51:58 <azorius> I will look forward to playing with berp
02:52:31 <yitz> azorius: ah right then there's berp, that's yet another approach
02:52:46 <azorius> ok... I taught berp was the one you pointed me at :S
02:53:23 <yitz> azorius: no that's a python compiler written in haskell.
02:53:58 <yitz> azorius: the old bridge is called MissingPy, then someone wrote a new one. maybe hpython?
02:54:49 <yitz> i've got to run now. search for "py" on the hackage page, you should find it.
02:55:29 <azorius> I will thanks a lot!
02:55:43 <yitz> azorius: see you later. good luck, have fun!
02:56:03 <shachaf> MississiPy
02:56:45 <azorius> I was a afraid that there would be a lot of RTFM in here because functional programming (especialy lisp it seems) have a awe of beeing for only the few enlightend uber smart people :D
02:59:04 <aristid> azorius: lisp is not really functional programming! :P
03:00:25 <azorius> as I said, I started haskell this very weekend, and I therefore am not qualified to make that distinction
03:00:51 <azorius> I hope that in 10-15 years I will know lisp sheme, and haskell and maby ML or Ocam
03:01:26 <azorius> but for now I am planing on perfecting the following languages: python, haskell, perl, R, C, C++
03:02:18 <azorius> I just found MissingPy as well... but as I reed it it interfaces "the wrong way", it calls python code fron haskell and not vice versa
03:02:49 <azorius> my idear was that functions are more pure and faster if written in haskell, so I could write all the heavy algorithms in haskell and the simple stuff in python
03:05:14 <aristid> azorius: you will never be able to perfect C++. that takes too much time :)
03:05:33 <azorius> I know
03:05:42 <azorius> especialy because I am not realy a "true" programmer
03:06:01 <azorius> so I have to use a lot of my time to understand scientific problems so I can solve them computational
03:06:44 <azorius> but I am not talking about perfecting these languages, I am talking about getting up to speed with them
03:06:45 <aristid> azorius: well i don't think it's because you are a true or false (lol) programmer, it's just that C++ is so full of details that you have to remember all the time if you actually want to use all of the language. most people have given up and simply use a small part of it :)
03:07:27 <shachaf> http://daskin.com/
03:07:29 <aristid> azorius: you're trying to learn these programming languages to help you with scientific research? cool
03:07:56 <azorius> the professor who hired me is a huge fan of c++ and he used like 3 hrs of his friday trying to explain virtuals, pure virtual and such goodies :)
03:08:20 <shachaf> Er, wrong window.
03:08:36 <aristid> shachaf: i was disappointed when i saw that this is not a programmer's keyboard :D
03:09:39 <mike-burns> azorius: When improving the speed of your program, be sure to use a profiler instead of just guessing on what the slow bits are.
03:13:29 <azorius> generaly our code is quite simple
03:13:38 <azorius> and it's very rare that we need to speed anything up
03:13:55 <azorius> because hashes/dictionaries are so fast and we have infinite ram
03:14:28 <azorius> it's often stuff like there are thise 20.000 proteins that give rise to thise 3.000.000 peptides that we should match against some data...
03:14:35 <shachaf> azorius: Infinite RAM? Can I have half?
03:15:07 <azorius> we have 2 super computers 1 with 4G pr core and one with 16G pr core (but less cores)
03:15:40 <aristid> what is a "4g pr core"?
03:15:48 <azorius> 4 giga byte ram pr core
03:16:36 <azorius> so if your program uses 20 threads you just have to use less than 320 Gigs of ram
03:17:59 <azorius> and often you use like A LOT LESS :D
03:18:59 <azorius> do you guys use haskell for more or less everything you do, or do you use a lot of different languages+
03:19:01 <aristid> azorius: i guess some of those problems you could as well run on your own computer
03:19:54 <aristid> i guess a lot of people here use haskell for everything they do privately, but not for the things they are paid for
03:20:15 <shachaf> I like to use PHP for personal project, but at work I'm forced to use Haskell.
03:20:30 <shachaf> I grit my teeth and do it.
03:21:01 <azorius> that the beauty of my situation, the official work polisy is pretty much this: if it can be installed as non root you can in stall it, if you work with other people, find a language everyone know or is willing to learn
03:21:24 <azorius> really fun shachaf
03:21:42 <shachaf> For really ambitious personal projects I like to use COBOL.
03:21:50 <shachaf> I find that it's a good fit for hard problems.
03:22:05 <azorius> why not FORTAN?
03:23:00 <shachaf> Because I'm not taking tangents?
03:23:19 <shachaf> Obvious FORTAN is the optimal language for taking tangents if I was doing that.
03:23:30 <azorius> how well doe haskell scale... this may be a dumb question, but I always assumed that was the strength of OOP, that you can chop stuff into smaller objects and solve the problems, but I can also see on a small scale how this is possible in functional languages (but I cannot make the "scaling" because I have no experience in haskell)
03:23:50 <azorius> huh? shachaf... you lost me
03:23:58 <azorius> I am not at all a programming wiz
03:24:12 * shachaf recommends not taking his last N lines seriously.
03:25:25 <aristid> azorius: the idea is that chopping problems into functions works better than chopping them into objects
03:25:40 <azorius> also if you are many people working on a project?
03:26:25 <azorius> if you answer yes I will belive you, because a lot of the stuff that you can do with duck typing in python also seems possible in haskell because of the typeclasses
03:26:48 <azorius> but again, I have like 4 hrs of theoretical knowlenge and 0 sekond of practical experience with haskell :D
03:26:56 <shachaf> azorius: Type classes are in one sense formalized duck-typing.
03:27:05 <shachaf> They're not always the solution that you want for that sort of thing though.
03:27:16 <azorius> that was what I kinda gathered as well
03:27:35 <shachaf> It's probably a good idea to learn more about the language and see. :-)
03:27:43 <azorius> agreed
03:27:51 <shachaf> There isn't a direct correspondence between many Haskell concepts and, say, OOP concepts.
03:28:24 <azorius> I guess there isn't... but that just makes it so much harder for me to try to forsee how valuable learning haskell will be for me
03:29:00 <azorius> but luckely I am a nerd, and I like lerning a language that is radicaly different from all others I have learned
03:29:06 <shachaf> That's true.
03:29:17 <shachaf> azorius: http://haskell.org/haskellwiki/FAQ might have some helpful answers to some of your questions.
03:29:32 <ClaudiusMaximus> > let n = 4 in [ scanl (+) 3 (replicate m 1 ++ replicate (n - m) 2) | m <- [0..n] ] -- some code i wrote tonight was similar to this
03:29:34 <lambdabot>   [[3,5,7,9,11],[3,4,6,8,10],[3,4,5,7,9],[3,4,5,6,8],[3,4,5,6,7]]
03:30:43 <azorius> I love the list compressions
03:30:57 <mike-burns> azorius: In asense, Haskell is more valuable to learn because it's so different from what you already know.
03:30:57 <azorius> I never compleatly understood them in python
03:31:24 <mike-burns> It gives some perspective on alternative solutions to problems.
03:31:47 <azorius> I totaly agreen mike-burns I have read a lot of "testemonies" about people who learned functional programming and became better OOP programmers
03:31:54 <mike-burns> I'm one of those!
03:32:14 <azorius> so haskell is not your primary spare time language?
03:32:16 <mike-burns> There's also a decent amount of overlap between OO and functional concepts, but they have vastly different names and you kinda have to squint.
03:32:23 <mike-burns> I do Ruby and Scala professionally.
03:32:34 <azorius> cool
03:32:55 <azorius> scala is a java implementation of what?
03:33:01 <azorius> I know closure is lisp
03:33:22 <mike-burns> That's way too much of a simplification for me to be comfortable answering.
03:33:30 <azorius> ok sorry
03:33:36 <azorius> I'll google it :D
03:33:47 <azorius> I wasn't trying to start a flame war
03:34:27 <mike-burns> I like to think of Scala as what Java should have been.
03:35:15 <azorius> ok :)
03:36:02 <azorius> why do you guys belive that functional programming has become such a small nitch?
03:36:26 <azorius> when all the most skilled software gurues talking so much in favor of it?
03:36:28 <mike-burns> Not sure if all of us believe that ...
03:37:01 <platzhirsch> azorius: has become? I thought it always was
03:37:07 <azorius> I mean it has a smaller nitch than what I presume you would like it to have ;)
03:37:50 <srh> for 99.99% of circumstances, functional programming is much much less useful than other improvements that could be made
03:37:52 <azorius> you may be very correct platzhirsch... I am into deem water here :D
03:38:01 <srh> yet companies don't make those improvements
03:38:32 <azorius> I don't get it srh
03:38:34 <mike-burns> It's taught in a very theorectical way, in a "you will think better if you know Haskell" way, instead of a practical, "this will get you a raise/laid" way like Java/Ruby.
03:39:15 <srh> employers do all sorts of stupid stuff.  for example, my previous employer had some QA people on project X and needed to move some of those resources to project Y.  So they had a couple QA people spend half their time on project X and half their time on project Y.
03:39:28 <platzhirsch> With more useful applications using functional languages eventually it will become bigger, but until then
03:39:31 <azorius> hehe I have the dream job, wife and kids, so can easily stick to the theoretical approach :D
03:39:34 <srh> this is because they retarded and don't know htf to do software development
03:41:37 <azorius> so the point is the stuff you can gain by using a functional language is overshadowed by the huge losses that can much easier be avoided if QA and bosses wern't reatarded
03:42:06 <mike-burns> At this point in my career, the actual programming language isn't my biggest concern.
03:42:19 <platzhirsch> mike-burns: what is?
03:42:20 <srh> not bosses in particular
03:43:20 <mike-burns> platzhirsch: Community, coworkers, end product, process.
03:43:35 <srh> for example, deciding whether to use an ORM or to write raw SQL is a bigger, easier win than the use of functional programming
03:43:53 <aristid> srh: which of those two do you consider better?
03:44:04 <srh> aristid: who cares
03:44:17 <aristid> srh: then it obviously does not matter.
03:44:24 <srh> to this discussion
03:44:41 <platzhirsch> The best promotion of function language I heard at university from a developer at CouchDB. He said, use functional languages, because they make you write less lines of code. Less lines of code will result in less errors
03:45:12 <aristid> srh: yes it does, if you want people to believe your statement
03:45:24 <srh> aristid: i don't care about you or what you believe
03:45:39 <aristid> srh: then why do you even make these statements?
03:46:04 <mike-burns> When comparing Haskell to Java, it's a no-brainer, for exactly the reason platzhirsch pointed out. When comparing again e.g. Python, some things are easier in Python, some in Haskell.
03:46:55 <mike-burns> It's seldom that I agree with someone in here as much as I've agreed with srh for the past 10 minutes.
03:47:45 <aristid> mike-burns: so your agreement on the sql-vs-orm statement must be based on your assumption that he means the one of them that you also prefer?
03:47:49 <srh> aristid: statements about ORMs and SQL?  we can talk about it in #sql.  see you there (not)
03:48:18 <aristid> srh: you are not in #sql.
03:48:28 <mike-burns> aristid: Preferring things in a vaccuum makes no sense.
03:48:46 <aristid> mike-burns: how can you agree that it matters then?
03:49:12 <aristid> i don't say it doesn't, there's just not enough information to say, and srh refuses to give it.
03:49:25 <kmc> is #haskell having another stimulating debate about whether Haskell is the best programming language?
03:49:54 <aristid> kmc: no, about whether and which other factors matter more.
03:50:02 <srh> aristid: the point was that you can come up with all sorts of examples of decisions that overshadow the decision to use some functional language.  if you think that using ORMs is about equivalent to not using them, consider it an exercise for the reader to come up with a different example, or just sit there unconvinced.
03:50:10 <azorius> I belive that what mike-burns and srh means it that in some projects raw SQL is better suited and in some ORM are prefred... but there is no generaly rule, like with python vs haskell, they both have their strength...
03:50:53 <aristid> srh: ok, i do accept that there are other more important decisions. i do not think that ORMs are equivalent or better or worse than SQL.
03:51:31 <aristid> azorius: but then, in some it obviously matters less than whether you use haskell or java
03:52:57 <shachaf> srh: That's what you get for trying to give a concrete example in this channel. We don't take kindly to that around here.
03:54:47 <mike-burns> There exist two comparable properties, A and B, such that the choice of A versus B has a larger impact than the choice of any two programming paradigms.
03:56:35 <msieradzki_> mike-burns, long term maintenance and inertion vs useful paradigms/technologies ;P
03:57:12 <lightstep> is it just me, or is there a bug in the new version of xhtml that does not allow compiling it?
03:57:39 <azorius> I see your point astrid... and I am not trying to defend or attack any paradime, especialy because I have no sql or functional programming experience :D
03:57:44 <lightstep> Text.XHtml.BlockTable should be a safe module but doesn't import SafePrelude
03:57:59 <azorius> anyway I am glad for the disgussion that resulted from my question, it was quite interesting
03:58:09 <azorius> hoever I have to feed my children and get them to take a nap
03:58:22 <azorius> so I will have to be inactive for atleast the next hour
03:58:31 <azorius> thanks for all the aswesome response
03:58:39 <azorius> this seems like a very good community ;(
03:58:40 <azorius> :)*
03:59:46 <shachaf> #haskell reports: "#haskell is the best community on Freenode"
03:59:56 <kmc> ++
04:02:06 <platzhirsch> #haskell is insanely large
04:04:42 <kmc> yeah
04:11:38 <zenzike> hello all. I'm trying to organise the hosting of HDBCs code. Currently the source is held in jgoerzen's github account, but now that I'm the maintainer, I'd like to move the source to somewhere more maintainer agnostic. I've thought about creating a repo in code.haskell.org, but I'd like issue tracking to be done via github. Any suggestions about how that might best be done?
04:13:35 <aristid> zenzike: create an organisation
04:13:44 <aristid> zenzike: that's free for open source stuff
04:13:53 <zenzike> aristid: I thought you had to pay for those?
04:14:02 <aristid> no
04:15:51 <zenzike> aristid: is there a canonical naming scheme for organisations? would you recommend I call it just hdbc, or something haskell specific, like haskell-hdbc
04:16:42 <aristid> zenzike: hdbc should be fine
04:16:45 <shachaf> haskell-hdbc-database-connectivity
04:16:50 <aristid> zenzike: h already stands for haskell i think :)
04:17:44 <zenzike> aristid: well that's true. maybe I'm being a little fussy :-)
04:17:59 <zenzike> github/haskell-database-hdbc :-)
04:18:02 <aristid> hdbc also stands for harley-davidson biker club, apparently
04:18:25 <aristid> i don't think it's likely that people will get confused over that, though
04:19:10 <shachaf> zenzike: Make sure you add -github-organization to the name.
04:19:17 <shachaf> So people know it's a github organization.
04:19:38 <zenzike> shachaf: ok, so github/haskell-database-hdbc-github-organization-source-code?
04:19:52 <shachaf> I'd add -connectivity in there somewhere.
04:19:53 <aristid> zenzike: damn, you stole my idea for adding that it is source code :D
04:20:04 <zenzike> :-)
04:20:09 <shachaf> But you might add -repository
04:20:15 <aristid> zenzike: it's also in git and in repositories
04:20:41 <zenzike> oh that's a good point too. might be careful we don't overspecify this though, the underlying repo might one day change
04:21:39 <shachaf> zenzike: You might want to inline the entire source code into the organization name.
04:21:45 <shachaf> That way it'll be truly self-documenting.
04:24:45 <lightstep> http://xkcd.com/910/
04:25:07 <Jafet> Just inline the module signature
04:25:23 <lightstep> the bot really should automatically link to the appropriate xkcd strip
04:25:47 <shachaf> It really shouldn't.
04:25:54 <shachaf> People overdo that as it is.
04:26:45 <Jafet> You want lambdabot to take what little fun there is in this activity out of it from you?
04:28:14 <lightstep> it used to be fun, but now it became a habit
04:38:13 <erus`> the hipsters dont like xkcd anymore, its too mainstream
04:41:36 <azorius> hipsters?
04:42:24 <mm_freak> what's wrong with lambdabot fun?
04:42:32 <mm_freak> > splitAt 7 . drop 27 . map head $ cake
04:42:34 <lambdabot>   ("TOOTOOT","ASCIICAT")
04:43:51 <zenzike> > cake
04:43:52 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
04:55:15 <mm_freak> > let chunksOf [] = pure; chunksOf (n:ns) = liftA2 (:) (take n) (chunksOf ns . drop n) in tail . chunksOf [27,7,5] . map head $ cake
04:55:16 <lambdabot>   ["TOOTOOT","ASCII","CAT"]
04:56:50 <aristid> lightstep: lol i never noticed the tooltip text in that particular strip before
05:00:43 <alpounet> what's the simplest way of drawing 2D points? has anyone got any magic library for this ?
05:02:03 <c_wraith> I use a marker on my screen.
05:02:22 <alpounet> c_wraith, heh
05:02:27 <mekeor> alpounet: Graphics.SOE
05:02:30 <alpounet> not great for automating, but still pretty efficient
05:02:36 <mekeor> alpounet: or Graphics.HGL
05:02:54 <aristid> c_wraith: that's not a point, which would have to have zero extent
05:03:08 <c_wraith> aristid: I use fine-point markers :)
05:03:40 <mekeor> alpounet: but what do you actually mean by "point"?
05:03:54 <mekeor> anyway, i've got a question, too: i'm looking for a function (say `foobar') such that e.g. `foobar (+) [1..5] == [1+2,2+3,3+4,4+5] == [3,5,7,9]'. is there such a function in the Prelude or so?
05:04:34 <Twey> > zipWith (+) `ap` tail $ [1 .. 5]
05:04:34 <lambdabot>   [3,5,7,9]
05:04:43 <alpounet> mekeor, i have a set of 2D points (i.e vector, x,y coordinates)
05:05:02 <alpounet> and would like to display them
05:05:09 <alpounet> (possibly with different colors)
05:05:36 <mekeor> alpounet: maybe you could use the gnuplot-API (i've never tested it…)
05:05:40 <mekeor> ?
05:05:43 <kmc> erus`, you really ought to join #haskell-blah :)
05:05:47 <alpounet> hm...
05:06:01 <shachaf> kmc: Context?
05:06:12 <shachaf> Oh, I see.
05:06:25 <shachaf> @let foobar f = zipWith f <*> tail
05:06:26 <lambdabot>  Defined.
05:06:27 <mekeor> Twey: that's not very elegant, bah :/ … so, there's no standard-function for THAT simple issue?
05:06:50 <dschoepe> mekeor: Why is it not elegant?
05:06:50 <shachaf> > let fibs=1:1:foobar(+)fibs in fibs
05:06:52 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
05:06:52 <Twey> It's perfectly elegant
05:07:01 <Twey> What's inelegant about it?
05:07:07 <kmc> foobar xs = zipWith (+)  xs (tail xs)
05:07:09 <shachaf> mekeor: zipWith (+) x (tail x)
05:07:12 <kmc> the use of 'ap' is kinda weird
05:07:23 <Twey> A.K.A. zipWith (+) `ap` tail
05:07:38 <Twey> It's kind of an idiom, I thought
05:07:43 <shachaf> kmc: It makes some sense, as I was forcefully informed by #haskell a while ago.
05:07:49 <Twey> I've seen lots of it.
05:07:57 <Phyx-> forcefully?
05:08:03 <Twey> With a baseball bat
05:08:10 <alpounet> mekeor, looking through the "Simple" module of the gnuplot API right now
05:08:16 <alpounet> let's see where it gets me
05:08:21 <shachaf> #haskell doesn't joke around.
05:08:40 <alpounet> wow, plotDots
05:09:00 <Phyx-> shachaf: depends on the joke.. they seem to quite like cat. theory jokes
05:09:26 <mekeor> Twey, shachaf, kmc: thanks
05:09:29 <kmc> mekeor, why should this particular function be in the standard library?
05:09:41 <Twey> It seems a rather specific case :þ
05:09:42 <shachaf> Because it's useful.
05:09:49 <kmc> imo it's better to have a small set of flexible building blocks, rather than anticipating each application
05:09:50 <mekeor> kmc: i think it's a frequently used function, isnt it?
05:09:51 <shachaf> It's not *that* specific.
05:10:02 <shachaf> It's also useful with e.g. max
05:10:11 <kmc> in the latter case someone has to name each function and then you have to learn a big list of names
05:10:21 <kmc> obviously this is a difficult tradeoff, though
05:10:40 <Twey> Not *that* frequently-used.  ‘zipWith f `ap` tail’ is sufficiently short name for the amount it appears, I think.
05:10:55 <Twey> s/suff/a suff/
05:11:28 <mekeor> kmc: btw, i got my sierpinski-program working yesterday noon =)
05:11:34 <Twey> > length "zipWith f `ap` tail"
05:11:35 <lambdabot>   19
05:11:48 <kmc> cool :)
05:11:55 <Twey> That's shorter than a single name in some Java programs ;)
05:12:00 <shachaf> > length "zipWith f <*> tail"
05:12:01 <lambdabot>   18
05:12:02 <kmc> :D
05:12:12 <kmc> mekeor, what are you drawing it with?
05:12:16 <Twey> I've always seen it with `ap`
05:12:18 <Twey> Not sure why
05:12:23 <shachaf> `ap`--
05:12:23 <mekeor> kmc: Graphics.SOE
05:12:34 <kmc> cool
05:12:47 <Twey> (I don't really know what ‘cargo-culting’ means, but…)
05:12:52 <shachaf> On the other hand "zipWith f <*> tail" takes me a bit to read.
05:13:14 <Twey> shachaf: It's just an idiom to get used to
05:13:22 <cheater> hi does anyone know what the following file does? /usr/local/lib/ghc-7.0.3/package.conf.d/package.cache
05:13:30 <mekeor> kmc: https://github.com/MekeorMelire/Sierpi-ski-Triangle/blob/43a077e1244443453a240c2a2df4c2e105091bea/Sierpinski.hs
05:13:31 <Twey> ‘for’ loops are devillishly tricky to follow when one first encounters them
05:13:33 <shachaf> I'm going to guess that it caches packages.
05:13:40 <cheater> i'm trying to install ghc7 and hp using checkinstall but they are conflicting (both try to write to this file)
05:13:41 <Twey> Heheh.
05:14:00 <mekeor> kmc: i'm currently working on the dragonCurve…
05:14:02 <shachaf> checkinstall probably has trouble with Haskell packages.
05:14:20 <shachaf> Since you need to update a file, not write it, when you install a GHC package.
05:15:22 <cheater> yes
05:15:29 <cheater> so what does that file do?
05:16:07 <shachaf> Probably keeps a cache about packages.
05:16:35 <shachaf> @google what does package.cache do in ghc
05:16:36 <lambdabot> http://www.haskell.org/ghc/docs/6.12.3/html/users_guide/packages.html
05:16:36 <lambdabot> Title: 4.8.� Packages
05:18:18 <cheater> can it safely be removed?
05:18:39 <mekeor> cheater: you could make a backup… (?)
05:18:44 <kmc> i think you can regenerate it with ghc-pkg
05:18:55 <shachaf> Yes, that page says as much.
05:19:03 <shachaf> Maybe you could tell checkinstall to ignore it.
05:19:15 <cheater> yes, i was thinking of making checkinstall ignore that file
05:20:40 <azorius> I have a quick question, I am reading "Learn yourself a Haskell for great good", many people in here have suggested Real World haskell, I have no functional programing experience... should I read real world haskell instead, or read it after the one I am reading now?
05:21:04 <kmc> azorius, I would take a look at both (they're both free online) and pick the one you like best
05:21:14 <shachaf> azorius: It's generally accepted in here, I think, that LYAH is a good start before RWH.
05:21:15 <kmc> RWH after LYAH is a popular choice
05:21:18 <kmc> but some people start with RWH
05:21:19 <cheater> continue reading LYAH and read RWH if you get stuck, then continue reading RWH.
05:21:38 <kmc> also learning Haskell and learning functional programming are pretty different goals
05:21:49 <cheater> yes
05:22:06 <kmc> FP experience does help with learning Haskell, certainly
05:22:08 * mekeor is learning haskell without a book oO
05:22:14 <kmc> but there's also a lot of unique things
05:22:22 <kmc> mekeor, how are you doing it, then?
05:23:04 <mekeor> well, i read a little bit of a haskell book, and then i just started to read the hackage-descriptions of the things. also the wiki is very helpful.
05:23:44 <mekeor> kmc: do you recommend reading a book?
05:23:51 <mekeor> (instead of what i'm doing)
05:24:30 <kmc> i did something more like what you're doing
05:24:36 <kmc> but it was 5 years ago, neither LYAH nor RWH existed
05:24:42 <mekeor> i see.
05:24:47 <kmc> i read some of the Gentle Introduction
05:24:50 <kmc> and i did these exercises:
05:24:52 <kmc> @where cs11
05:24:52 <lambdabot> http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
05:25:18 <mekeor> bookmarked.
05:25:26 <mekeor> thanks =)
05:25:38 <shachaf> http://www.cs.nott.ac.uk/~gmh/book.html is good.
05:25:45 <shachaf> Would be nice if it was available online.
05:25:55 <kmc> they are pretty intro-level exercises... it's a 10-week university course at 1/3 the normal number of credits
05:26:10 <kmc> then i did a bunch of small languages projects
05:26:25 <kmc> toy implementations of lisp-like language, stack language, predicate calculus, etc.
05:26:56 <mekeor> yea, i'm implementing a lisp-like calculator :)
05:26:57 <shachaf> Look at all those great reviews.
05:27:02 <shachaf> «“The writing style is clear and to the point” ― Mark Twain»
05:28:11 <kmc> pfft, that's not even his real name
05:28:14 <mekeor> kmc: here's my non-lisp-like calculator =) : https://github.com/MekeorMelire/hascal/blob/74640627603c52dcd09d651827f1bc8faf6e7ebe/Hascal.hs
05:28:33 <mekeor> i'm proud of its simplicity :)
05:28:55 <kmc> nice :)
05:29:05 <azorius> sorry I tapped away
05:29:33 <kmc> yeah, Hutton's book has good reviews... unfortunately it's not free online
05:29:36 <azorius> I have read in the FAQ that sheme is the "better language" if your goal is to learn FP... but I have seached the interwebs and come to the conclusion that haskell seems more interesting
05:29:59 <kmc> i agree that Haskell is more interesting
05:30:11 <azorius> I'll keep reading LYAH and read RWH when stuck, or when I start coding because LYAH seems good at teaching concept but the coce
05:30:17 <azorius> code examples are none existant
05:32:09 <shachaf> http://cs240h.stanford.edu/notes look like they're going to be good slides.
05:32:22 <shachaf> Maybe a bit terse on their own, though.
05:32:30 <azorius> do you think it's viable to just lead the books and then start working on "real" problems, or is the language so "hard" that you have to force yourselth tru random exercises?
05:32:56 <azorius> lead = read... I am having a bad keyboard day
05:33:00 <cheater> nah
05:33:19 <cheater> i wrote some tutorials on haskell that should be good for any newcomer and solve practical problems
05:33:32 <cheater> search here http://cheater.posterous.com
05:33:43 <shachaf> azorius: Solving "real" problems might involve having to learn more than in some other languages.
05:33:53 <kmc> azorius, it depends on what your real problems are
05:34:15 <azorius> they are luckely not that complicated I should think :)
05:34:34 <azorius> manipulating some data :)
05:34:39 <cheater> very easy
05:34:39 <kmc> imo a lot of the stuff to learn about Haskell is not "how to do it" but "how to do it faster, safer, cleverer, with less code"
05:34:45 <azorius> so very ad-hoc scripting like :D
05:34:56 <cheater> http://cheater.posterous.com/first-haskell-script
05:34:59 <kmc> azorius, that should be fine as long as you actually want to use Haskell for that
05:35:05 <kmc> it will feel pointlessly hard at first
05:35:14 <kmc> and you probably know tools which would be better in the short term
05:35:37 <azorius> I am luckely stubbern :)
05:35:51 <shachaf> I think writing functions and fiddling with ghci is probably more helpful than writing full programs.
05:35:58 <shachaf> At least at the beginning.
05:36:34 <mm_freak> shachaf: i disagree
05:36:37 <kmc> at the beginning, yes
05:37:00 <kmc> early haskell exercises are usually Project Euler type numeric stuff in ghci
05:37:14 <kmc> but that only covers a small subset of the things one wants to learn
05:37:15 <mm_freak> GHCi is good for the first few hours, but the real essence in writing haskell is in writing actual source files
05:37:26 <mm_freak> that gives you the real idea about types and how they interact
05:37:40 <kmc> yes (though in GHC 7.4 you can define data types in GHCi)
05:38:03 <mm_freak> especially PE problems should be solved using real source files…  they don't have to be programs with a main action, but they should be source files
05:38:22 <mm_freak> so you can experiment with let/where, indentation and type signatures more conveniently
05:38:50 <shachaf> mm_freak: Sure, writing actual source files and then trying them out with ghci.
05:39:11 <shachaf> mm_freak: Rather than source files that do IO and argument parsing and whatever "real programs" usually do.
05:39:43 <azorius> ok...
05:39:46 <cheater> hmm
05:39:49 <kmc> with PE your 'main' is just 'print (f 9000)', though
05:39:56 <cheater> is it a good idea to let checkinstall strip bins and so's?
05:40:02 <cheater> or should i make it not strip them?
05:40:15 <kmc> so it's feasible for beginners to build executables (and you get a big speed boost by doing so)
05:40:17 <shachaf> kmc: I don't think Project Euler is very interesting for learning Haskell.
05:40:23 <shachaf> At least not beyond the first few problems.
05:40:27 <mm_freak> shachaf: after a brief introduction into types and the general syntax IO was the first thing i taught to my friend, because it makes programming more fun, when you can turn everything into an own application right away
05:40:35 <mm_freak> it worked very well
05:40:36 <kmc> shachaf, I agree
05:40:38 <shachaf> The more interesting the problem is, the less relevant the implementation language is, for the most part.
05:40:43 <mekeor> shachaf: i dont agree.
05:40:48 <azorius> while we are on the topic... is there any place I can learn the propper syntax... because I cannot figure out when to put stuff on the next line
05:40:52 <cgroza> shachaf: I have learned quite alot using it.
05:41:26 <cgroza> shachaf: I was writing my own solution and then compared them with the HaskellWiki one.
05:41:28 <mm_freak> azorius: the indentation rules are quite intuitive…  the general rule is:  increased indentation continues a block
05:41:40 <kmc> @where layout
05:41:41 <lambdabot> http://haskell.org/onlinereport/lexemes.html#sect2.7
05:41:46 <kmc> azorius, ^^^^
05:42:05 <kmc> that may be more detail than you want, but I think it's reasonably clear
05:42:40 <kmc> the general idea is that same indentation = implied semicolon; less indentation = implied close brace
05:43:05 <cheater> i find it's a better idea to have a style guide which just shows one possible way of interpreting the layout and which is easy to remember
05:43:15 <cheater> unfortunately i do not have such a style guide
05:43:40 <kmc> blog that shit cheater
05:43:57 <cheater> maybe 1 day
05:44:14 <mekeor> cheater: you've got a blog? domain, pls
05:44:31 <cheater> i just posted it like twice
05:44:35 <cheater> http://cheater.posterous.com/first-haskell-script
05:44:37 <cheater> here you go
05:44:42 <mekeor> ty
05:44:47 <cheater> np
05:44:51 <cheater> yw
05:44:54 <shachaf> You should post pictures of your children on it.
05:45:03 <shachaf> And then submit it to planet.haskell.org
05:45:20 <mm_freak> lol
05:46:15 <mekeor> cheater: where are you from?
05:46:32 <azorius> thanks
05:46:48 <azorius> me?
05:46:50 <azorius> Denmark
05:47:08 <azorius> I no cheater, who he asked :D... sorry
05:47:20 <mekeor> :) np hehe :)
05:48:15 <cheater> mekeor: i travel a lot, i'm not from any specific place.
05:48:24 <shachaf> Except Poland.
05:48:35 <cheater> yeah, i never travel there
05:48:44 <cheater> pretty boring place
05:49:43 <mekeor> cheater: ^^ … and where were you born then?
05:50:06 <mekeor> cheater: and which's your mother tongue?
05:50:07 <cheater> in a hospital
05:50:21 <mekeor> … :)
05:50:28 <mekeor> okay. doesn't matter…
05:50:35 <cheater> inceed
05:50:36 <cheater> indeed
05:50:44 * hackagebot geniplate 0.1.0.0 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.1.0.0 (LennartAugustsson)
05:53:41 <mekeor> @let dragon 1 = 'R'; dragon n = let d = dragon (n-1); a = div (length d) 2; in d ++ 'R' ++ take a d ++ 'L' ++ drop (a+1) d
05:53:42 <lambdabot>  <local>:10:65:
05:53:42 <lambdabot>      Couldn't match expected type `[a]' against inferred type...
05:54:05 <mekeor> @let dragon 1 = 'R'; dragon n = let d = dragon (n-1); a = div (length d) 2; in d ++ "R" ++ take a d ++ "L" ++ drop (a+1) d
05:54:06 <lambdabot>  <local>:10:65:
05:54:06 <lambdabot>      Couldn't match expected type `[a]' against inferred type...
05:54:19 <mekeor> @let dragon 1 = "R"; dragon n = let d = dragon (n-1); a = div (length d) 2; in d ++ "R" ++ take a d ++ "L" ++ drop (a+1) d
05:54:20 <lambdabot>  Defined.
05:54:24 <Mkman> why this type declaration has a . http://dpaste.com/630909/ is there any meaning in it?
05:54:43 <shachaf> Mkman: Maybe it was part of a sentence which ended with a period?
05:54:49 <mekeor> > map dragon [1..7]
05:54:51 <lambdabot>   ["R","RRL","RRLRRLL","RRLRRLLRRRLLRLL","RRLRRLLRRRLLRLLRRRLRRLLLRRLLRLL","R...
05:55:39 <Mkman> shachaf: it is in a code block
05:55:45 <shachaf> > map ((++) "TRU" . dragon) [1..]
05:55:47 <lambdabot>   ["TRUR","TRURRL","TRURRLRRLL","TRURRLRRLLRRRLLRLL","TRURRLRRLLRRRLLRLLRRRLR...
05:57:13 <kmc> nice
05:58:31 <mekeor> kmc: my only problem is how to draw this…
05:59:59 <kmc> did you see http://hackage.haskell.org/package/diagrams and http://hackage.haskell.org/package/graphics-drawingcombinators
06:00:10 <mekeor> nope
06:02:24 <mekeor> kmc: actually, i want(ed) to draw it with Graphics.SOE/Graphics.HGL, too, but i couldnt create an appropriate function/concept yet…
06:02:38 <kmc> ah
06:03:07 <mekeor> im still a noob ;)
06:14:06 <azorius> see ya all, thanks for the friendly spirit
06:20:09 <shum> hi all. I have a q re ffi. How one can import c function that accepts structure by value?
06:21:14 <kmc> interesting question
06:21:35 <kmc> i think the easiest way might be to write a wrapper in C which accepts a struct by pointer
06:21:59 <kmc> (or just accepts the struct fields as individual arguments, if that's what you want)
06:22:19 <shum> the problem is that I need to import objective-c function objc_msgSend
06:22:44 <shum> so actually I don't know exactly what selector (method in objc) will be used
06:22:55 <shum> it is too hard to make wrapper every time
06:23:48 <shum> and target platform is iphone, so I can't use libffi :}
06:24:10 <kmc> aha! are you working with the iPwn Studios people?
06:24:31 <shum> no, I don't know who they are :}
06:24:48 <shum> just internal project
06:26:21 <shum> aha, they are authors of ghc-iphone. Yes, I use it
06:26:40 <shum> but it lacks bindings to iphone api
06:29:24 <d34df00d> Hi guys!
06:29:32 <d34df00d> Is there anything like lift but for types?
06:29:39 <kmc> elaborate?
06:30:01 <d34df00d> I'm writing some Matrix operations, and internally my "Matrix e" is just "Data.Array (Int, Int) e".
06:30:20 <d34df00d> And I've noticed I'm writing too much code like "fmap f m = Matrix (f <$> Matrix.elems m)"
06:30:43 <d34df00d> So, having fmap for Data.Array (Int, Int), I'd like to "lift" it into my matrices.
06:31:16 <kmc> wouldn't it just be «fmap f (Matrix m) = Matrix (fmap f m)» ?
06:31:29 <kmc> presuming you have «newtype Matrix e = Matrix (Data.Array (Int, Int) e)»
06:32:05 <d34df00d> kmc: hm, I actually have data Matrix e = Matrix { elems :: Array (Int, Int) e }
06:32:15 <kmc> that's fine, it will still work
06:32:18 <d34df00d> That's in case I'd want to keep something along with my matrix.
06:32:21 <kmc> you're not obliged to use record syntax
06:32:22 <kmc> *nod*
06:32:31 <kmc> then your fmap code would break
06:32:46 <d34df00d> That's implementation detail not exposed to other modules.
06:32:57 <d34df00d> In case I'd need to add something — just let it break and rewrite with what I have now then :)
06:33:02 <kmc> anyway you said you were writing too much code like this
06:33:05 <d34df00d> Yep.
06:33:06 <kmc> where does it come up, besides fmap?
06:34:07 <d34df00d> Hm. I've actually eliminated most of it after writing noticing that Matrix is a Functor and writing the fmap thing, but the question already came up but that moment.
06:34:17 <d34df00d> And it's rather theoretical now, kind of "What if I'd want to...?"
06:34:27 <d34df00d> s/writing noticing/noticing/
06:34:35 <kmc> i think the 'lifting' function you want is fmap itself
06:34:46 <kmc> GHC can derive Functor instances
06:35:00 <kmc> it can also derive any instance for a newtype
06:35:30 <kmc> http://hackage.haskell.org/package/newtype this library can also be useful for working with newtypes
06:36:35 <d34df00d> Hm, seems like yes, fmap is what I want.
06:49:21 <houeland> Urgh, parsec suddenly depends on text which depends on integer-gmp?
06:49:55 <kmc> :/
06:50:00 <kmc> are you using integer-simple for some reason?
06:50:44 * hackagebot spawn 0.3 - Tiny library for concurrent computations  http://hackage.haskell.org/package/spawn-0.3 (KeeganMcAllister)
06:51:17 <dcoutts> houeland: I don't see text depending on integer-gmp
06:51:23 <houeland> Yeah, looks like things will work by just specifying parsec-3.1.1, but this sounds terrible
06:52:17 <houeland> That's because it conditionally depends on either some version or another version depending on ghc implementation
07:10:46 <funktronic> can anyone recommend a nice tutorial/intro for someone using F# ?
07:11:17 <shachaf> funktronic: To Haskell, you mean?
07:11:21 <funktronic> yes
07:11:33 <funktronic> from ocaml would kinda i guess
07:11:37 <shachaf> funktronic: The Gentle Introduction might be good if you're generally familiar with many of the concepts.
07:11:42 <shachaf> @where tutorial
07:11:43 <lambdabot> http://www.haskell.org/tutorial/
07:11:55 <shachaf> Or there are the usual suspects, LYAH, RWH, etc.
07:12:22 <dcoutts> funktronic: or in book form, "Programming in Haskell" is good
07:12:27 <funktronic> hm that one looks pretty good
07:14:01 <shachaf> dcoutts: Hah, your review is on the front page of the website.
07:14:15 * dcoutts stands by his review
07:14:16 <shachaf> dcoutts: I keep recommending that book in here but feeling slightly guilty because you can't get it online.
07:14:53 <dcoutts> shachaf: sure, that's a tradeoff, you can of course also recommend an online one too. Some people prefer online, some books.
07:14:54 <rtharper> Yeah but it's really awesome
07:14:59 <rtharper> I recommend it to people all the time
07:15:18 <Skola> what tools are there for analysing haskell code other than scan and pl?
07:15:32 * rtharper wishes we taught from it instead of Introduction to Functional Programming using Haskell
07:15:37 <dcoutts> rtharper: Graham mentioned he might do a second edition
07:15:43 <rtharper> w00t
07:16:05 <zenzike> is there much that's outdated?
07:16:07 <dcoutts> rtharper: ah but Bird's book is really the Oxford style, you can't not do that at Oxford :-)
07:16:07 <rtharper> Has he considered extending it at all? The only complaint I hear from folk is that they wished it went further
07:16:29 <rtharper> dcoutts: It just doesn't make Haskell look very sexy
07:16:40 <rtharper> It certainly reflects how we teach FP to students, though
07:16:48 <dcoutts> rtharper: you just need to make cool practicals!
07:17:06 <rtharper> dcoutts: I agree, I'm not allowed near FP pracs, though, more senior people always want that job
07:17:13 <shachaf> Yes, _Programming in Haskell_ seemed a bit like half a book.
07:17:18 <dcoutts> rtharper: ah, pitty
07:17:22 <shachaf> Half a good book, but shorter than you'd expect.
07:17:26 <funktronic> what's a better book than programming in haskell then ?
07:17:31 <rtharper> shachaf: yeah exactly
07:17:40 <Skola> Programming in Haskell is pretty sweet, but indeed too short!
07:17:41 <rtharper> funktronic: depends on what you want, I would say
07:17:47 <rtharper> Programming in Haskell is good for the intro
07:18:01 <shachaf> We should get him to release it online RWH-style!
07:18:02 <funktronic> assuming that i am already comfortable with writing F#
07:18:08 <alpounet> RWH might be good for you
07:18:10 <shachaf> I wonder if the online release made financial sense for RWH.
07:18:22 <dcoutts> rtharper: I don't think so, he was going to fix the errors, perhaps switch to using typewriter font for the code, move the monad chapters around
07:18:24 <byorgey> Skola: analyze how?
07:18:44 <rtharper> dcoutts: Ah, those are all good fixes though
07:18:53 <rtharper> My main complaint about the code is thaty ou can't type it in as is
07:18:59 <shachaf> Good fixes meriting a second edition?
07:19:00 <rtharper> which is fine for papers, but hard on the n00bs
07:19:08 <dcoutts> rtharper: aye
07:19:13 <shachaf> rtharper: There's a translation table in the back.
07:19:25 <Skola> byorgey: to see if there's better ways to do things
07:19:35 <rtharper> shachaf: not exactly what I want to deal with when I'm learning a language with unfamiliar syntax ;)
07:19:37 <byorgey> Skola: ah, you want hlint
07:19:43 <byorgey> @hackage hlint
07:19:43 <lambdabot> http://hackage.haskell.org/package/hlint
07:20:03 <Skola> that's exactly what I want
07:20:03 <shachaf> rtharper: Was any of it such a huge deal?
07:20:05 <Skola> thanks a lot
07:20:15 <shachaf> I remember >>= as one character instead of three, and things like that.
07:20:16 <dcoutts> shachaf: it's a pretty popular book, so that makes it more worth making little tweaks
07:20:28 <rtharper> shachaf: for me, neve,r I was a haskell programmer before the book came out.  I have a ton of students for which the syntax of Haskell is their most frustrating hurdle
07:20:35 <shachaf> Nothing that wasn't pretty clearly translatable to ASCII.
07:21:22 <dcoutts> rtharper: what are your intro practicals these days then?
07:21:32 <rtharper> dcoutts: for FP? You don't want to know...
07:21:39 <rtharper> dcoutts: prime factorisation and BFS of a maze
07:21:58 <houeland> I wish I could write my code in a pretty way using unicode
07:22:03 <rtharper> houeland: you can, now
07:22:08 <rtharper> with -XUnicodeSyntax
07:22:24 <dcoutts> and you can use unicode identifiers even without that
07:22:29 <dcoutts> and unicode operators too
07:22:46 <rtharper> Ah, I didn't know Haskell was all unicode all the time for indents
07:22:49 <rtharper> *idents*
07:22:51 <houeland> Nah, that doesn't even use the right symbols. I made a custom preprocessor at one point to make it so I almost-could, but scrapped it since it got a bit too non-standard for me
07:22:54 <dcoutts> the UnicodeSyntax extension is just for things like -> and other bits of builtin lexical syntax
07:23:16 <dcoutts> ie you can use a unicode arrow instead of '-' '>'
07:23:27 <rtharper> there is also...cute haskell?
07:23:29 <rtharper> for vim and emas
07:23:36 <rtharper> which lets you use ASCII but renders things as unicode
07:24:07 <rtharper> Does anyone else find, btw, that the syntax highlighting in vim is a bit...lightweight... compared to emacs?
07:24:26 <shachaf> rtharper: Who needs syntax highlighting?
07:24:30 <shachaf> I mean, what is there to highlight?
07:24:36 <zenzike> rtharper: yes, absolutely
07:24:38 <houeland> Oh, that sounds pretty nice, wonder if that exists for my random-editor-of-choice
07:24:40 * rtharper needs syntax highlighting.
07:24:55 <zenzike> rtharper: I've actually hacked a better vim file
07:25:04 <rtharper> zenzike: would you mind sharing it?
07:25:08 <zenzike> rtharper: should probably dig it up and publish it :-)
07:25:15 <rtharper> yes please
07:25:23 <shachaf> rtharper: I just ran emacs. I don't see any notable differences.
07:25:33 <kmc> yeah, the Haskell Report specifies that Haskell source is UTF-8-encoded Unicode text, and describes e.g. valid identifiers in terms of Unicode character classes
07:25:33 <shachaf> I guess it highlights function names?
07:25:40 <rtharper> schroedinbug: yes, for one
07:25:41 <zenzike> things like "Nothing" not being highlighted, as well as function names
07:25:46 <kmc> this is why you can't use λ for \, even with -XUnicodeSyntax
07:25:49 <rtharper> yes, it doens't highlight constructors
07:25:52 <kmc> it's an identifier
07:26:03 <kmc> amounts to a one-letter reserved word, which is impolite
07:26:04 <zenzike> *I mean things like Just
07:26:22 <shachaf> I like how Unicode has exactly one character with "LAMBDA" in its name.
07:26:28 <shachaf> The others are all spelled "LAMDA".
07:26:38 * rtharper shudders.
07:27:05 <shachaf> Ah, well. Referers everywhere.
07:27:14 <houeland> What I really want is for \ ... -> to look like ⟼, not λ ... → (though that's still a lot prettier)
07:27:22 <mauke> heh, my unicode search is too smart for me
07:27:43 <shachaf> mauke: It corrects LAMBDA?
07:27:59 <mauke> well, it finds three characters for "lambda"
07:28:13 <mauke> probably not through autocorrection
07:28:27 <shachaf> Mine finds 14 for LAMDA and 1 for LAMBDA.
07:28:52 <shachaf> Hmm, my script was apparently written by Larry Wall.
07:29:07 <mauke> 14 for lamda here as well
07:29:37 <byorgey> to be fair, in modern greek it is pronounced (and spelled) 'lamda'
07:29:55 <dcoutts> it's rediculous, unicode has a number of mathematical lambdas, but they're all either bold, italic or both, there is no "ordinary" mathematical lambda
07:30:09 <dcoutts> and we should not steal the greek lambda, because that's an ordinary letter
07:30:33 <mauke> I think lambda is ugly and \ is a much superior choice
07:30:37 <shachaf> Clearly Unicode needs a "mathematical" combining character.
07:30:49 <shachaf> I think the ugly part of the Haskell lambda syntax is the arrow.
07:31:11 <kmc> houeland, i like the idea of using ⟼
07:31:14 <dcoutts> perhaps 𝜆 U+1D706 "mathematical small lamda" is the nearest
07:31:42 <dcoutts> 𝜆 vs λ
07:31:46 <shachaf> dcoutts: My font don't even render that.
07:32:01 <rtharper> dcoutts: Ah, I like that
07:32:06 <rtharper> I'd be fine with that
07:32:07 <kmc> my font seems confused about the width of the left character
07:32:15 <kmc> which is a kind of curly lambda at a weird angle
07:32:17 <shachaf> dcoutts: No, wait, it does. Something is breaking along the line somewhere.
07:32:20 <mauke> lern2astralplane
07:32:30 <shachaf> ssh/screen/irssi/I don't know.
07:32:40 <shachaf> mauke: techme2astralplane
07:32:42 <mauke> my font simply doesn't have it
07:32:47 <rtharper> omg it's the 21st century, what systems are unicode failing?
07:32:48 <dcoutts> rtharper: send in a patch for ghc's lexer, shouldn't be hard.
07:32:51 <mauke> no issues otherwise
07:33:16 <mauke> running irssi < tmux < urxvt
07:33:28 * shachaf is just racist.
07:33:32 <shachaf> Everything should be ASCII.
07:33:40 <mauke> don't be naïve
07:33:58 <rtharper> ASCII is an arbitrary restriction
07:34:03 <rtharper> imo
07:34:12 <dcoutts> rtharper: your choices are bold 𝛌, italic 𝜆, bold-italic 𝝀 :-)
07:34:20 <mauke> shachaf: I could write you an irssi script that turns everything into plain ASCII :-)
07:34:30 <shachaf> mauke: I don't do scripts.
07:34:40 <mauke> you don't have to, irssi will
07:34:54 <dcoutts> rtharper: oh and sans-serif bold 𝝺, and sans-serif bold italic 𝞴
07:34:57 <shachaf> If it was good enough for the irssi people to hard-code into the client, it's good enough for me!
07:35:31 <mauke> shachaf: the "irssi people" didn't even bother writing the second half of the manual :-)
07:35:47 <shachaf> /nctcp
07:35:48 <hpc> they wrote half the manual?
07:35:52 <hpc> an entire half?!
07:35:53 <aristid> mauke: therefore, having half a manual is good enough for shachaf
07:36:25 <shachaf> Wow, they're like Graham Hutton.
07:48:53 <hgyi> hi
07:49:06 <byorgey> hi hgyi
07:49:48 <hgyi> hi byorgey
07:50:33 <cicatristeza> can anyone tell me what is wrong with the following guard code: http://pastebin.com/Peh4fgew
07:50:33 <lambdabot> cicatristeza: You have 1 new message. '/msg lambdabot @messages' to read it.
07:50:36 <mauke> The paste Peh4fgew has been copied to http://hpaste.org/52371
07:50:46 * hackagebot posix-escape 0.1 - Quote arguments to be passed through the Unix shell  http://hackage.haskell.org/package/posix-escape-0.1 (KeeganMcAllister)
07:50:59 <kmc> cicatristeza, can you tell us what is wrong with it?
07:51:04 <kmc> compiler error? wrong behavior?
07:51:25 <byorgey> hgyi: how's it going? are you learning Haskell?
07:51:41 <kmc> cicatristeza, looks like those are infinite lists... so if you use 'elem' to search for an element which does not appear, it will search forever
07:51:53 <cicatristeza> kmc: aha, i see
07:52:06 <mauke> and you misspelled triangular
07:52:13 <byorgey> cicatristeza: also, you have '2A' in the definition of triangular which is not valid syntax
07:52:30 <mauke> > 2A
07:52:30 <lambdabot>   Not in scope: data constructor `A'
07:52:33 <mauke> ^ valid syntax
07:52:35 <cicatristeza> byorgey: yeah but thats kul cos its just dumb string
07:52:51 <cicatristeza> sorry i meant that for mauke
07:53:06 <hpc> > 2Nothing
07:53:07 <lambdabot>   2
07:53:12 <byorgey> mauke: sorry, you're right.
07:53:30 <aristid> @let km = undefined
07:53:31 <lambdabot>  Defined.
07:53:31 <byorgey> > (2True, 2True)
07:53:32 <lambdabot>   (2,2)
07:53:34 <aristid> > 2 km
07:53:36 <lambdabot>   2
07:53:40 <mauke> cicatristeza: you don't want /
07:53:41 <aristid> :D
07:53:44 <hgyi> yes, but stopped for hadoop.
07:53:54 <mauke> > 2m
07:53:55 <lambdabot>   2
07:54:12 <cicatristeza> god where he hell are these spelling errors popping up
07:54:13 <sal23> is there any paper or blog post which explains why monad-par version in Marlow's parfib.hs takes 240GB space?
07:54:24 <sal23> fib(40) 4 threads:    20.6s 78.6s 240GB allocated
07:54:44 <cicatristeza> ok, now, for thos folks who have seen my paste, some numbers can be traingular AND centered pentagonal, how do i test for them?
07:54:56 <cicatristeza> i mean with a guard, once it catches traingular, its all over right?
07:55:23 <cicatristeza> so it doesnt even look at the pentagonal or centeredpentagonal code
07:55:25 <hpc> :t (&&) -- cicatristeza
07:55:26 <lambdabot> Bool -> Bool -> Bool
07:55:30 <hpc> :P
07:56:01 <alpounet> sal23, have you tried doing some space profiling ?
07:56:14 <hgyi> do you know haskell can fit for mapred patten?
07:56:23 <cicatristeza> hpc: aha, instead of }| i use && and thats it? nice
07:58:02 <sal23> alpounet: no, I don't want to crash my machine….plus I am new to space profiling. so, I prefer to understand the issue first, and then explore in the profiler
07:58:05 <cicatristeza> hpc: no this is not what i mean
07:58:46 <cicatristeza> i mean, it should first test for triangular. if yes, output "triangular". then test for pentagonal, and then centeredpentagonal etc
07:58:59 <cicatristeza> i mean  anumber can be all three cases, how do i catch them all?
07:59:33 <hgyi> i'd like to use it in hadoop eco
07:59:52 <hpc> cicatristeza: http://hpaste.org/52371
07:59:56 <alpounet> sal23, problem is, it's hard to know what the issue precisely is without profiling
08:00:23 <hpc> er, cicatristeza: http://hpaste.org/52372
08:01:04 <cicatristeza> hpc: no this is so inelegant
08:02:05 <cicatristeza> is there any other construct? to test against different conditions and return all positives?
08:02:46 <kmc> map ($ k) [isCenteredPentagonal, isTriangular, isPentagonal]
08:03:24 <cicatristeza> why the $ kmc?
08:03:34 <byorgey> cicatristeza: you don't need any special construct.  for each type of number just make a function  isFoo :: Double -> Maybe String
08:03:44 <kmc> @src ($)
08:03:44 <lambdabot> f $ x = f x
08:03:47 <shachaf> cicatristeza: ($ k) means the same as (\f -> f $ k), which means the same as (\f -> f k)
08:03:51 <sal23> alpounet: yes, if I go that route, it will take me a couple of days. I would rather use that time exploring other parts of haskell :) Guess I have to go that route anyway if parfib example space issue is not documented
08:03:57 <kamaji> Should I be using ReadS for reading input (not code) to make objects or something else?
08:04:16 <cicatristeza> can i not do simply map k?
08:04:17 <kamaji> someone told me Show/Read was for showing/reading valid haskell
08:04:27 <byorgey> cicatristeza: also, you really don't want to be using Double
08:04:34 <kmc> cicatristeza, «map k [x,y] ≡ [k x, k y]»
08:04:52 <kmc> map ($ k) [x, y] ≡ [x $ k, y $ k] ≡ [x k, y k]
08:05:08 <kmc> > map f [x, y]
08:05:09 <lambdabot>   Ambiguous type variable `b' in the constraints:
08:05:09 <lambdabot>    `GHC.Show.Show b'
08:05:09 <lambdabot>      a...
08:05:17 <kmc> > map f [x, y] :: [Expr]
08:05:18 <lambdabot>   [f x,f y]
08:05:28 <kmc> > map ($ x) [f, g] :: [Expr]
08:05:29 <lambdabot>   [f x,g x]
08:05:33 <alpounet> sal23, you could also ask Simon Marlow
08:05:56 <alpounet> or ask people in here (but giving a link to the source code)
08:06:16 <kmc> cicatristeza, makes sense?
08:06:18 <sal23> alpounet: best way to ask this? haskell forum,?
08:06:20 <cicatristeza> kmc: ghci told me the type of the function catchall was Double, so i wrote it. what do you recommend?
08:06:36 <kmc> i'm confused
08:07:11 <alpounet> sal23, either here or on stackoverflow
08:07:16 <alpounet> here is fine don't worry
08:07:24 <alpounet> just put the code on hpaste.org or somesuch
08:07:44 <sal23> yep, let me do that
08:07:47 <alpounet> also it's weird that simon marlow hasn't commented this in the corresponding paper/tutorial/whatever
08:08:35 <sal23> exactly…I didn't find any references, and then when I read the comments in parfib.hs, I thought memory stats was a typo
08:08:51 <cicatristeza> perhaps restating my problem will help
08:09:23 <cicatristeza> the user inputs a number, and the program tests against the formulae for triangular, pentagonal and centeredPentagonal numbers
08:09:35 <cicatristeza> and returns a list of all positives
08:09:41 <cicatristeza> kmc: does that make sense?
08:09:51 <kmc> yeah
08:09:59 <cicatristeza> so how would you write it?
08:10:11 <kmc> cicatristeza, i was asking you whether my explanation of «map k» versus «map ($ k)» made sense
08:10:22 <cicatristeza> it does!
08:10:27 <kmc> cool
08:10:34 <cicatristeza> could you help me write it?
08:10:44 <kmc> maybe someone else can
08:10:54 <cicatristeza> a guard the wrong way to go isnt it?
08:14:16 <alpounet> sal23, isn't there a paper attached to this code ?
08:14:32 <alpounet> iirc simon has published a few papers about the recent parallel stuffs
08:15:34 <sal23> alpounet, this code was attached to a presentation to cufp…I have the recent papers on parallel stuff but haven't seen any space analysis
08:15:41 <cgroza> is there a function that allows me to see if the sum of any 2 numbers in a list is equal to a number?
08:16:07 <sal23> alpounet, am posting my query on stackoverflow anyway…this kind of query is best answered over a forum IMO
08:16:19 <alpounet> sal23, ok, that's really, really weird... you're right to ask that there
08:16:30 <alpounet> (i'll follow up the thread to see the reason)
08:16:39 <kmc> cgroza, nothing pre-made that i know of
08:16:55 <cgroza> kmc: ok. I guess I will write it myself.
08:17:18 <byorgey> cgroza: there is not a specific function for that, no.  but you can easily form all the pairwise sums from a list with  liftA2 (+)
08:17:27 <byorgey> > liftA2 (+) [1,4,5]
08:17:27 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
08:17:28 <lambdabot>    arising from a use ...
08:17:31 <byorgey> > liftA2 (+) [1,4,5] [1,4,5]
08:17:31 <lambdabot>   [2,5,6,5,8,9,6,9,10]
08:17:46 <byorgey> of course, that gives you every sum twice since (+) is commutative
08:18:49 <kmc> :t \xs target -> let s = S.fromList xs in any ((`S.member` s) . subtract x) xs
08:18:50 <lambdabot> forall t. [Expr] -> t -> Bool
08:18:55 <kmc> :t \xs target -> let s = S.fromList xs in any ((`S.member` s) . subtract target) xs
08:18:56 <lambdabot> forall a. (Ord a, Num a) => [a] -> a -> Bool
08:19:21 <kmc> that's not quite right
08:19:46 <kmc> but it's the approach i'd use
08:19:48 <kmc> it's potentially faster than the pairwise sums thing
08:22:46 <cgroza> byorgey: ntask-. I will take a look at that
08:24:30 <hiptobecubic> has anyone tried to make a CAS out of haskell?
08:25:38 <hiptobecubic> Oh i see, maxima is in lisp, close enough i guess
08:26:24 <kmc> not very close at all
08:27:50 <kmc> the whole "which programming languages are similar" thing is a bit like http://strangemaps.files.wordpress.com/2007/02/steinberg-newyorker.jpg
08:29:06 <kmc> Haskell and Lisp are those indistinct blobs on the horizon, like China and Japan
08:29:10 <kmc> pretty much the same country right
08:30:49 <kmc> (The Economist's version was good too:  http://strangemaps.files.wordpress.com/2009/03/how_china_sees_the_world.jpg?w=600&h=789 )
08:31:11 <sal23> alpounet: here is the thread I created in case you want to follow up: http://stackoverflow.com/questions/7704580/space-analysis-for-parfib-in-monad-par-example
08:31:26 <alpounet> thanks
08:32:14 <sal23> kmc, that was very informative article in Economist…they also had an excellent one about private enterprise in China
08:32:58 <dschoepe> Is there a fool-proof way to strictly read an entire file's content into memory and close the file immediately afterwards? I tried readFile from here, but it doesn't help: http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html
08:33:27 <kmc> dschoepe, the usual hack is «xs <- readFile "foo";  evaluate (length xs)»
08:33:31 <kmc> evaluate from Control.Exception
08:33:42 <dschoepe> kmc: Thanks, I'll give it a try.
08:34:01 <mauke> dschoepe: how does it not help?
08:34:31 <dschoepe> mauke: The file is still open after some other operations on the data that has been read. (According to lsof, for example)
08:34:47 <mauke> do you have a small testcase?
08:35:39 <dschoepe> I tried to build one, but there forcing the contents with `seq` fixed it. I'll try to extend it to the point where it doesn't anymore.
08:36:42 <dschoepe> (I also place the data structure read from the file in an IORef, maybe that's causing more problems)
08:37:08 <mauke> what's the type of your IORef?
08:37:24 <kmc> if you want to force evaluation as an IO action, 'evaluate' is the right thing to use, not 'seq'
08:37:34 <kmc> also 'seq' on a list does not do much
08:37:52 <shachaf> kmc: IO.Strict does >>= length xs `seq` return xs
08:37:56 <dschoepe> mauke: something like IORef (M.Map FilePath MyDataStructure)
08:38:02 <kmc> shachaf, :(
08:38:15 <mauke> hmm, ok
08:38:19 <kamaji> Does anyone know of a good tutorial for the Supply monad?
08:38:22 <dschoepe> where MyDataStructure is the thing read from the file. (roughly read <$> readFile ...)
08:38:50 <byorgey> kamaji: which Supply monad do you mean?
08:39:53 <kamaji> I thought there was just one :\
08:40:03 <mauke> kamaji: where?
08:40:20 <kamaji> I think I imagined seeing the wiki page >_>
08:40:26 <kamaji> I have UniqSupply open
08:40:44 <kamaji> I just want to take a sequence of n unique integers from a list
08:41:17 <kamaji> I'll just write a function :P
08:41:34 <tools> Hey has anyone succeed in running a HASKELL program on a Mac OS X Lion ?
08:42:43 <byorgey> kamaji: there is one on the wiki but it is not on Hackage
08:42:51 <byorgey> UniqSupply is a bit different
08:43:06 <kamaji> Yeah that looked like something to do with the language parser
08:43:07 <kamaji> wasn't sure
08:43:13 <byorgey> I keep meaning to package up the Supply monad on the wiki and put it on hackage, I do use it occasionally
08:43:56 <kamaji> Is it yours?
08:44:18 <Taejo> I'm looking at starting a webapp in Haskell, and it seems there are a bunch of options. Is there any reason to choose one framework over another besides taste? (e.g., snap is better than happstack for a specific thing, yesod is no longer maintained...)
08:44:59 <kamaji> Taejo: I think Snap were planning to do a release soon which breaks backwards compatibility
08:45:04 <kamaji> 0.6
08:45:17 <kamaji> not sure how soon that will be out
08:46:20 <kamaji> altho it is on github
08:47:11 <tools> Are there really no mac users in here with Lion ?
08:47:47 * Taejo settles down to read some documentation
08:48:19 <kamaji> tools: not I, sorry
08:48:24 <kmc> tools, give it some time
08:48:29 <tools> kk
08:48:38 <kmc> you're also asking before noon (US) on a weekend
08:48:41 <osfameron> tools: probably, but it's sunday afternoon ;-)
08:49:12 <tools> osfameron I do not know the word weekends for the time :D
08:49:26 <osfameron> tools: if you mention what problem you're having, sommeone might have a clue
08:50:24 <tools> okay I try following ghc -o test hello.hs I get: Command ghc is unknown - But it work under Snow Leopard
08:50:41 <kmc> did you install ghc
08:50:47 <tools> yes
08:51:04 <kmc> is it in your $PATH ?
08:51:08 <Taejo> if there's anybody working on Yesod in here, it would be nice if there were links to the next page of the book at the bottom of each page, so one doesn't have to scroll up to keep reading
08:51:11 <osfameron> from haskell platform?
08:51:32 <tools> Well yes I haven't change any thing since my Lion update
08:52:09 <osfameron> so maybe lion update stole $PATH?
08:52:12 <kamaji> tools: echo $path ?
08:52:21 <kamaji> in caps even
08:52:22 <kamaji> $PATH
08:52:57 <osfameron> alternatiuely, maybe worth reinstalling platform
08:53:11 <osfameron> (but check path first)
08:53:20 <tools> wtf it returns nothing :\
08:53:42 <osfameron> in caps?
08:53:47 <tools> yes
08:53:50 <kamaji> wat
08:53:58 <kamaji> but echo worked?
08:54:03 <tools> yes
08:54:03 <kamaji> oh could be builtin
08:54:24 <tools> Aiih got a result: /opt/local/bin:/opt/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin Apparently I should run it with sudo
08:54:41 <kmc> hmmmmmmmmmmmmmmm
08:59:18 <jmcarthur> is it really necessary for ArrowMonad to fix the type of the input to the arrow to ()?
09:01:28 <cicatristeza> hello, i rewrote my code with a case expression, and yest ghci gives me a parse error: http://pastebin.com/P720r2Fy
09:01:31 <mauke> The paste P720r2Fy has been copied to http://hpaste.org/52373
09:01:47 <mauke> cicatristeza: that's not how case works
09:02:00 <mauke> cicatristeza: and you still can't use elem with infinite lists
09:02:15 <cicatristeza> but they arent infinite
09:02:37 <byorgey> jmcarthur: yes, it is
09:02:40 <cicatristeza> doesnt case work that way? why not
09:03:02 <byorgey> jmcarthur: because the implementation of >>= has to create a value of type () to feed into such an arrow
09:03:24 <mauke> cicatristeza: oh, right. case works with patterns, not expressions
09:03:30 <byorgey> jmcarthur: if the type was unconstrained there would be no way to provide an input of the proper type to the second argument of >>=
09:03:47 <cicatristeza> so why am i getting a parse error?
09:04:05 <mauke> cicatristeza: because you're giving it expressions, not patterns
09:04:12 <hpaste_> jmcarthur pasted “arrow monad?” at http://hpaste.org/52374
09:04:24 <jmcarthur> byorgey: is that wrong somehow? ^^
09:04:29 <cicatristeza> i see
09:05:06 <cicatristeza> so how do i express "if k is present in the list triangular" as a pattern?
09:05:17 <mauke> cicatristeza: you don't
09:05:45 <byorgey> jmcarthur: oh, I see, you just duplicate the input x
09:05:55 <jmcarthur> right, like Reader or something
09:06:03 <byorgey> jmcarthur: hmm, I am not sure then
09:06:36 <cicatristeza> mauke: hmm, so how do i solve this simple problem then?
09:07:01 <jmcarthur> this kind of instance could somewhat unify classic and arrowized frp, i think
09:07:42 <jmcarthur> assuming it's efficient enough to to be useful
09:08:03 <Y0Gi> hi. I'm looking for a console UI toolkit (like curses, urwid) that I can use from Haskell. what can you recommend for a very basic use case (list w/ checkboxes)?
09:11:42 <rwbarton> Y0Gi: how about the 'dialog' command-line program
09:13:17 <dtrebbien> @type mapM_
09:13:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:13:31 <parcs> Y0Gi: vty-ui is nice
09:14:08 <Y0Gi> rwbarton: nice, will check it out. I just hadn't found a console equivalent to zenity yet.
09:14:37 <Y0Gi> parcs: thanks, it's said to be easy, so I'll try it, too :)
09:16:56 <kmc> isn't 'dialog' the console equivalent to 'zenity'?
09:17:39 <kmc> dialog begat Xdialog begat gdialog begat zenity
09:18:33 <shachaf> kmc: Something along those lines.
09:22:12 <Y0Gi> kmc: yes, I guess so
09:28:04 <Y0Gi> seems hackageDB packages don't go well with URLs: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vty (see the github hrefs)
09:35:21 <kmc> Y0Gi, that's because Haddock uses slashes as markup for /italics/
09:35:39 <kmc> they should write <https://github.com/coreyoconnor/vty>
09:35:47 <kmc> in the .cabal file
09:36:07 <kmc> also Cabal now supports metadata specifying a git repo
09:37:11 <rahul_> Hello.
09:37:59 <Eduard_Munteanu> rahul_: hi
09:38:16 <rahul_> I want to have a `Map` data type which has a `map` operation, which behaves as follows:
09:38:42 <rahul_> When mapped with a function that returns a pair, it returns a Map.
09:39:01 <rahul_> When mapped with a function that returns single value, it returns a list.
09:39:05 <rahul_> Is this possible?
09:39:50 <kmc> probably with some nasty type class
09:39:52 <parcs> yes
09:39:55 <kmc> the thing is, a pair is a single value
09:40:01 <parcs> but why not just make two separate functions
09:40:01 <kmc> why do you want this
09:40:13 <rahul_> Just curious.
09:40:31 <Eduard_Munteanu> Or functions that return a special datatype
09:40:46 * hackagebot stm-stats 0.1.0.0 - retry statistics for STM transactions  http://hackage.haskell.org/package/stm-stats-0.1.0.0 (JoachimBreitner)
09:41:20 <kmc> i agree, they should be separate functions
09:41:31 <parcs> it's possible with some ghc extensions, not but with haskell2010
09:41:41 <kmc> with type classes they're pretty much separate functions too, but have the same name
09:41:44 <rahul_> I am a Scala programmer, and am learning Haskell atm. Just want to know if it is possible to implement this functionality in Haskell type system.
09:41:44 <kmc> which is confusing
09:42:38 <cicatristeza> is there a tutorial on drawing svgs with haskell anywhere?
09:42:51 <Jimmy__> ???
09:42:57 <tgeeky> ciaranm: diagrams is the package
09:43:02 <tgeeky> ciaranm: there is a manual-in-writing
09:43:24 <kmc> you could do it with 'cairo' as well
09:43:25 <donri> did you perhaps mean to speak to cicatristeza
09:43:30 <Eduard_Munteanu> s/ciaranm/cicatristeza/
09:43:43 <tgeeky> yes
09:44:18 <Y0Gi> kmc: ah ok
09:44:34 <Y0Gi> didn't know there was an escape
09:44:54 <rahul_> Basically I need something like this
09:44:56 <rahul_> http://paste.pocoo.org/show/489939/
09:45:51 <cicatristeza> tgeeky: where is the manual in writing/
09:46:07 <parcs> rahul_: yep that's possible
09:46:17 <parcs> (with ghc extensions)
09:46:32 <kmc> but possible ≠ a good idea
09:46:40 <rahul_> parcs: Awesome! Which extensions specifically do I need?
09:46:43 <kmc> if it's just an exercise then whatever
09:46:51 <kmc> if you're trying to solve some larger problem, there might be a better way
09:46:58 <tgeeky> CindyLinz: http://www.cis.upenn.edu/~byorgey/diagrams-manual/diagrams-manual.html
09:47:09 <rahul_> kmc: Just an exercise to learn Haskell type system and extensions better. :)
09:47:34 <kmc> beginners tend to over-use type classes
09:47:37 <rahul_> rahul_: The pattern is found all over Scala stdlib, and I have found it to be very useful in practice.
09:48:09 <ion> y0gi: Also, IIRC the format for links with non-URL text is something like [text](http://…).
09:48:22 <CindyLinz> tgeeky: ??
09:48:42 <cicatristeza> tgeeky: why do you keep talking to other people :-)
09:49:03 <parcs> rahul_: MultiParamTypeClasses, FunctionalDependencies, OverlappingInstances and FlexibleInstances i think
09:49:31 <CindyLinz> haha
09:49:43 <rahul_> parcs: Are there any web resources I can refer to?
09:50:00 <kmc> the GHC manual is pretty good
09:50:07 <kmc> and the Haskell wiki might describe some of them
09:52:14 <rostayob> How can I configure cabal to install the documentation with links to the source?
09:52:22 <rostayob> every time that some package is installed?
09:52:46 <dcoutts> that's not currently possible
09:53:02 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/517
09:53:48 <rostayob> dcoutts: ok, right now I can't use a browser but I believe you
09:54:37 <tgeeky> cicatristeza: because my eyes are misbehaving, and I can't spell (evidently)
09:54:48 <KirinDave> Man, I am so glad Bos spends his time in the haskell camp. Reading his pronk-like-you-mean-it slides makes me glad he's not wasting his time in enterprise javaland.
09:54:54 <rahul_> kmc, parcs: Okay thanks.
09:55:43 <KirinDave> dmwit: Hey, I had a random question or two for you.
09:56:14 <tgeeky> does anyone have some references with interesting recursive usage of fixpoint?
09:56:33 <tgeeky> (of the `fix` function, at least)
09:56:46 <kmc> any recursion can be written using 'fix'
09:57:00 <kmc> one pattern i like is using it for monadic loops
09:57:07 <KirinDave> Also
09:57:14 <kmc> fix $ \again -> do .... when (whatever condition) again
09:57:15 <KirinDave> Fix was used for monad zippers
09:57:30 <kmc> i learned that from reading xmonad source
09:57:37 <glguy> ?src fix
09:57:37 <lambdabot> fix f = let x = f x in x
09:58:06 <KirinDave> I need to just dive into trying to do some haskell open source work.
09:58:06 <glguy> it just lets you write recursive definitions without naming them in a let (because it does that for you)
09:58:30 <KirinDave> I really want to dive in to trying to get monatron to play nicely with all aspects of mtl and iteratees.
09:58:32 <kamaji> How do I map a function over a monad again?
09:58:41 <ion> jlouis: Process, Process.Timer and Supervisor look like the modules to split into another package. Am i missing anything?
09:58:42 <kmc> kamaji, fmap or liftM or (<$>)
09:58:44 <kmc> is that what you mean?
09:58:44 <mauke> you can't; monads are a type-level thing
09:58:45 <parcs> rahul_: here's my implementation of this map function if you're curious: http://paste.pocoo.org/show/489949/
09:58:50 <mauke> functions are a value-level thing
09:58:52 <kamaji> kmc: oh yeah, fmap >_>
09:58:59 <KirinDave> Because mzippers are _perfect_ for iteratees. Iteratees _beg_ for monad zippers. :)
09:58:59 <kamaji> I probably asked the wrong question
09:59:02 <kmc> i'd say "map over a monadic value" not "map over a monad"
09:59:06 <kmc> because the monad is the type constructor itself
09:59:15 <kamaji> oh ok
09:59:19 <kmc> tgeeky, if you're interested in the *type-level* fixpoint, I wrote a little article here:  http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
09:59:22 <kamaji> isn't <$> applicative functors?
09:59:25 <kamaji> or is that <*>
09:59:38 <kmc> (<$>) is defined in Control.Applicative but it works for all Functors
09:59:46 <kmc> every instance of Monad should be an instance of Functor
09:59:53 <kamaji> oh right, but they added it after so it's not
09:59:54 <kmc> (this is not enforced, for historical reasons)
09:59:55 <glguy> parcs: what is [myMap] for?
10:00:04 <kamaji> ok thanks
10:00:08 <kmc> fmap is also defined on Functor
10:00:16 <kamaji> (also I just realised I can do this with pattern matching instead of fmap~)
10:00:24 <kmc> liftM is defined for Monad
10:00:26 <kamaji> (as,bs) <- get
10:00:27 <kmc> @src liftM
10:00:27 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:00:54 <kamaji> what's m1? the monadic value?
10:01:02 <kmc> yeah
10:01:07 <kamaji> so it's type is m m1?
10:01:10 <kamaji> its*
10:01:13 <kmc> m1 isn't a type
10:01:15 <parcs> glguy: myMap is supposed to work like scala's map function over Maps: http://paste.pocoo.org/show/489939/
10:01:18 <kmc> it's the name of a function parameter
10:01:25 <kmc> there's no types in that @src output
10:01:49 <kmc> liftM f x = x >>= (return . f)
10:02:02 <parcs> that is, if the mapping function returns a tuple (k, v) then the result is a Map k v and if it returns anything else then the result is a [a]
10:02:36 <kamaji> kmc: oh I think that makes more sense
10:02:38 <kamaji> thanks
10:02:41 <glguy> parcs: that seems like a mess… It looks like you wouldn't be able to use map to go from a Map to a list of tuples due to magic overlapping
10:02:43 <ion> What’s the word for a “functoric” value? :-P
10:02:52 <parcs> glguy: yep
10:02:54 <kamaji> functic? :D
10:03:04 <Taejo> funcy
10:03:17 <parcs> i don't condone this kind of hackery, but rahul_ was curious if it were possible
10:03:32 <kamaji> kamaji likes this 👍
10:04:37 <KirinDave> parcs: What is the code in haskell to make that happen?
10:04:47 <KirinDave> I missed the earlier paste?
10:04:47 <parcs> http://paste.pocoo.org/show/489949/
10:05:05 <KirinDave> Ha, right before I clicked I was like, "Brace yourself. Fundeps incoming."
10:05:15 <parcs> it's funny how type equality constraints can make overlapping functional dependencies magically not overlap
10:05:33 <KirinDave> I really need to sit down and read up on what code like this means. :\
10:05:42 <glguy> parcs: Why so many equality constraints? instance (Ord k, x ~ (k, v), y ~ Map k v) => Foo x y
10:05:43 <KirinDave> It's one of the big blind spots I frequently bang my head on when reading haskell
10:06:24 <parcs> glguy: ghc would complain about overlapping functional dependencies otherwise
10:07:03 <parcs> i'm not sure why/how it works, but it does :P
10:07:48 <rostayob> KirinDave: why? functional dependencies are not confusing, maybe it's hard to see what they're for in some code
10:08:03 <hatomic> is there a simple way to take a number and print it with a dot at each centesimal place? i.e. 65725094381 becomes 65.725.094.381
10:08:03 <KirinDave> rostayob: I couldn't tell you if I find them confusing or not.
10:08:19 <KirinDave> rostayob: I simply haven't devoted much in the way of time to understanding them at all.
10:08:43 <parcs> actually that first instance could be simplified to instance (Ord k, y ~ Map k v) => Foo (k, v) y where
10:08:59 <Boxo> @kind ->
10:09:00 <lambdabot> parse error on input `->'
10:09:00 <Twey> reverse . intercalate "." . chunk 3 . reverse
10:09:04 <Twey> Maybe?
10:09:05 <Boxo> @kind (->)
10:09:06 <lambdabot> ?? -> ? -> *
10:09:16 <Boxo> What's "?"?
10:09:18 <Twey> (split:Data.List.Split.chunk)
10:09:30 <parcs> wait nevermind
10:09:40 <parcs> you need both type equality constraints
10:09:59 <kmc> * is the kind of ordinary boxed values.  # is the kind of unboxed values.  (#) is the kind of unboxed tuples (which are not values).  ?? means "* or #" and ? means "* or # or (#)"
10:10:05 <kmc> (that's all GHC
10:10:08 <kmc> -specific notation)
10:10:34 <Boxo> ah, thanks
10:10:36 <hatomic> so I can feed it any number and it works, even if it doesnt end with a chunk of 3?
10:11:10 <diracdelta> Hi, what is the name of the format of the assembly language file output by ghc with the -S command (it's the same as gcc I believe, but I'm not sure what that's called)
10:11:35 <kmc> GNU assembler (gas) ?
10:11:59 <diracdelta> yeah, that would be it, thanks :)
10:14:38 <tgeeky> kmc: pm? or other than #haskell?
10:16:39 <kmc> ?
10:18:31 <tgeeky> kmc: nevermind, question is answered in 'odds and ends'
10:18:55 <kmc> oh
10:18:58 <kmc> what was it, out of curiosity?
10:19:15 <tgeeky> kmc: how you got the Show for Fix
10:20:48 <Y0Gi> ion: ah, then that's both Markdown syntax
10:22:21 <ion> y0gi: Looks like something very close, although i haven’t actually encountered a reference to Markdown.
10:22:42 <kmc> haddock syntax is not that close to markdown
10:22:51 <kmc> the syntax used in .cabal files is closer to haddock syntax, i think
10:23:23 <dcoutts> the markup in the package description in .cabal files is haddock syntax
10:23:33 <dcoutts> (taken from a slightly older version of haddock)
10:27:13 <nomeata> ibid: Hi. You are an admin of planet haskell, right? Would you mind changing the factis research feed as given in Stefan Wehr’s mail? I have a blog post ready that would not appear otherwise.
10:37:01 <cicatristeza> how is NAND in haskell?
10:37:48 <metatagg> not && ?
10:38:25 <kmc> :t (not .) . (&&)
10:38:26 <lambdabot> Bool -> Bool -> Bool
10:39:28 <mm_freak> :t \x y -> not (x && y)
10:39:29 <lambdabot> Bool -> Bool -> Bool
10:45:04 <kamaji> Does partition work on infinite lists?
10:45:21 <ion> > partition even [0..]
10:45:22 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
10:45:40 <kamaji> well, I mean is there something like partitionUntil
10:45:48 <kamaji> well
10:45:49 <kamaji> do I?
10:46:06 <kamaji> ok no because both items int he tuple are lazy
10:46:07 <kamaji> so it's ok
10:46:17 <rwbarton> > snd $ partition even [0..]
10:46:18 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
10:46:36 <kamaji> coo
10:46:47 <kamaji> this language is shiny
10:46:51 <ion> > ((take 3 *** take 4) . partition even) [0..]
10:46:52 <lambdabot>   ([0,2,4],[1,3,5,7])
10:47:02 <kamaji> ***?
10:47:18 <ion> Ignore that, just demonstrating that both lists in the tuple are lazy.
10:47:25 <kmc> @src partition
10:47:26 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
10:47:26 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
10:47:26 <lambdabot>                               | otherwise = (ts, x:fs)
10:47:28 <ion> :t (***) `asAppliedTo` (undefined :: a -> b)
10:47:28 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
10:47:47 <aristid> :t asAppliedTo
10:47:47 <lambdabot> forall t b. (t -> b) -> t -> t -> b
10:47:51 <erus`> :t (***)
10:47:52 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:48:41 <kamaji> ok most of that has gone over my head
10:48:59 <kamaji> what's the tilde operator?
10:49:06 <Tomsik> > join (***) (take 4) . partition even $ [0..]
10:49:07 <lambdabot>   ([0,2,4,6],[1,3,5,7])
10:49:14 <ion> Not an operator, it makes the pattern match strict.
10:49:20 <kmc> kamaji, irrefutable pattern match
10:49:25 <kmc> not strict, the other one ;)
10:49:28 <ion> Eh, sorry. I’m talking out of my ass.
10:49:52 <kmc> kamaji, matching against ~p always succeeds, and does not force any evaluation
10:50:08 <kamaji> oh ok
10:50:14 <aristid> kamaji: now you probably want to know what a pattern match is?
10:50:16 <kmc> if one of the variables bound by p is forced, only then does evaluation occur
10:50:29 <kmc> (and if you matched the wrong constructor before, it's a run-time error)
10:50:35 <kamaji> aristid: nope I know those :p
10:50:44 <kmc> > case Just 3 of ~Nothing -> 'n'; Just _ -> 'j'
10:50:45 <lambdabot>   'n'
10:50:49 <kamaji> i'm saving this conversation
10:51:04 <kmc> > case Nothing of ~(Just x) -> x; Nothing -> 0
10:51:04 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed for patt...
10:51:18 <kmc> it's commonly used with (,), where there's only one constructor anyway
10:51:51 <kmc> > fix (\~(evens, odds) -> (0 : map succ odds, map succ evens))
10:51:52 <lambdabot>   <no location info>: parse error on input `->'
10:51:59 <kmc> > fix (\(~(evens, odds)) -> (0 : map succ odds, map succ evens))
10:52:00 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
10:52:04 <kmc> > fix (\(evens, odds) -> (0 : map succ odds, map succ evens))
10:52:08 <lambdabot>   mueval-core: Time limit exceeded
10:52:34 <kmc> here the irrefutable pattern is key
10:52:43 <kmc> otherwise you match the (,) constructor too early and the function diverges
10:52:58 <kmc> ⊥ is a fixed point of (\(x,y) -> whatever)
10:53:47 <Tomsik> > (\[] -> 3) []
10:53:48 <lambdabot>   3
10:53:50 <Tomsik> > (\[] -> 3) [1]
10:53:51 <lambdabot>   *Exception: <interactive>:3:1-8: Non-exhaustive patterns in lambda
10:53:55 <Tomsik> > (\~[] -> 3) [1]
10:53:55 <lambdabot>   <no location info>: parse error on input `->'
10:54:24 <Tomsik> > let f ~[] = 3 in f [1]
10:54:25 <lambdabot>   3
10:54:31 <Tomsik> heh
10:54:47 <Tomsik> > let f ~[x] = x in f []
10:54:48 <lambdabot>   *Exception: <interactive>:3:4-13: Irrefutable pattern failed for pattern [x]
11:00:38 <prime_> Hi there. Can anyone explain to me what a Monad is?
11:00:48 <monochrom> I can't
11:01:11 <prime_> I've tried looking online, but can't find any simple explanation...I keep getting confused.
11:01:28 <monochrom> ~pattern does not postpone anything if you use its components right away
11:01:52 <mauke> prime_: what do you already know?
11:01:54 <monochrom> ah, but you are testing that. cool. nevermind.
11:02:07 <cicatristeza> suppose i have a list with a single number lets say [234567]. how do i split it into a list of numbers that make up this number? i.e, how do i make it [2,3,4,5,6,7 ]
11:02:09 <cicatristeza> ?
11:02:14 <kmc> prime_, are you learning Haskell?
11:02:26 <mauke> cicatristeza: map digitToInt . show
11:02:37 <ion> kamaji: If you expand the definition of partition mechanically for partition even [0..] you’ll end up with an infinitely growing pattern like this:
11:02:40 <ion> > let select p x ~(ts,fs) = if p x then (x:ts,fs) else (ts,x:fs) in (\ ~(ts,fs) -> (0:ts,fs)) . (\ ~(ts,fs) -> (ts,1:fs)) . (\ ~(ts,fs) -> (2:ts,fs)) . (\ ~(ts,fs) -> (ts,3:fs)) $ foldr (select even) ([],[]) [4..]
11:02:42 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,...
11:03:43 <ion> prime: First learn what functors are. Then learn what applicative functors are. At that point it’s not that big a leap to understand monads.
11:03:43 <prime_> Yes I am learning Haskell. I'm familiar with writing functions and things at the moment, but these monads seem strange.
11:03:58 <cicatristeza> mauke: thanks, you are so fast sometimes i think you are a bot
11:04:03 <mauke> prime_: do you understand typeclasses?
11:04:06 <prime_> yes
11:04:11 <kmc> prime_, a good Haskell tutorial will introduce monads at the appropriate time, and not too soon
11:04:13 <mauke> prime_: do you understand Functor?
11:04:15 <kmc> LYAH has a chapter about them, for example
11:04:25 <prime_> What is a functor?
11:04:28 <kmc> prime_, monads are simple but there are many prerequisite ideas
11:04:29 <mauke> @src Functor
11:04:30 <lambdabot> class  Functor f  where
11:04:30 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
11:04:32 <kmc> you should probably learn other things first
11:04:32 <prime_> Oh cool, thanks kmc
11:04:34 <mauke> ^ that
11:04:56 <prime_> sure
11:05:45 <prime_> I think I should come up with a more specific question in future, so I'll come back in a bit. Thank you guys for the help.
11:05:50 <mauke> Monad is a typeclass like Functor. it has two additional methods
11:05:53 <kmc> sounds good :)
11:05:56 <Eduard_Munteanu> prime_: it might help to take a few examples... e.g. lists as Functors, which gives fmap = map
11:06:30 <kmc> LYAH goes through the whole progression from Functor to Applicative to Monad
11:06:36 <kmc> by the time you actually get to monads, they aren't such a big deal
11:06:39 <kmc> in the proper context
11:06:45 <prime_> Gotcha. I'll take a look again at LYAH
11:06:52 <prime_> Cheers
11:07:10 <Eduard_Munteanu> :t map
11:07:11 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:10:47 * hackagebot kmeans-vector 0.1 - An implementation of the kmeans clustering algorithm based on the vector package  http://hackage.haskell.org/package/kmeans-vector-0.1 (AlpMestanogullari)
11:11:51 <aristid> :t fmap
11:11:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:12:31 <aristid> :t (map,fmap)
11:12:32 <lambdabot> forall a b a1 b1 (f :: * -> *). (Functor f) => ((a -> b) -> [a] -> [b], (a1 -> b1) -> f a1 -> f b1)
11:19:52 <hpaste_> Reisen pasted “First attempt to program in Haskell” at http://hpaste.org/52378
11:20:05 <Reisen> I've been reading a lot of haskell, today I tried to actually write something
11:20:18 <Reisen> The above is what I've done so far, would anyone be willing to point out if I'm doing anything wrong so far
11:20:32 <Reisen> It 'works', but I doubt It's well written
11:20:36 <mauke> not using readFile
11:20:44 <mauke> and the hpaste comments
11:21:03 <mauke> why does getKey not return [String]?
11:21:06 <Peaker> Reisen: why is your getKey in Maybe if it always returns a Just?
11:21:36 <Reisen> Peaker, on line 16, I wanted value to return a list no matter what, Map.lookup returned Nothing
11:21:45 <Reisen> mauke, didn't know about hpaste comments, that's pretty useful
11:22:14 <mauke> Reisen: your answer makes no sense
11:22:30 <Reisen> mauke, I've probably done somethign really stupid, this is my first attempt
11:22:31 <Peaker> Reisen: if you wanted it to return a list no matter what, why are you returning a Maybe list?
11:22:32 <mauke> getKey :: Table -> State -> [String]
11:22:53 <Reisen> Oh right, yeah sorry I see what you're saying
11:22:55 <mauke> getKey table state = fromMaybe [] (M.lookup state table)
11:22:56 <Peaker> Reisen: also, in the lookup-returned-Just case -- why do you discard what it returned to re-look it up unsafely with ! ?
11:23:31 <Reisen> Peaker, if lookup found it, surely ! isn't unsafe?
11:23:42 <mauke> Reisen: if lookup found it, why search again?
11:24:03 <ddarius> Reisen: You can use ($) with forM_ and withFile to produce something that is clearer, but you can actually simplify/eliminate both of those.
11:24:09 <Peaker> Reisen: It's unsafe in the sense that we have to trust the programmer knows what he's doing -- the compiler says "you're on your own now"... once someone shuffles/refactors the code -- the current assumption may no longer hold
11:24:10 <Reisen> mauke, my thinking at the time was if lookup didn't find it, I wanted []
11:24:14 <Reisen> Clearly I've done this really badly
11:24:19 <mauke> Reisen: irrelevant
11:24:21 <mekeor> @quote
11:24:21 <lambdabot> inimino says: actually, Chuck Norris is the Oleg of everything else
11:24:26 <ddarius> Reisen: \p -> putStrLn $ show p) = putStrLn . show = print
11:24:26 <mauke> Reisen: we're talking about the case were lookup succeeded
11:24:48 <ddarius> so the forM_ can be replaced with mapM_ print (M.toList $ table markov)
11:25:04 <Reisen> There's a lot for me to read here, let me just do one thing at a time before my head explodes
11:25:08 <Reisen> mauke, what should I do instead?
11:25:35 <mauke> Reisen: well, you could use the code I wrote
11:25:43 <Reisen> Oh, I missed it
11:26:01 <mauke> Reisen: if you want to keep your structure, case ... of Nothing -> []; Just x -> x
11:28:05 <Twey> Ugh.  I hate programming.  Why is building a GUI app with an embedded browser so damn difficult?
11:28:44 <Twey> I'm desperately trying to avoid falling back to C… I thought I could do Java with Clojure, surely they've got some stable, well-supported solution for browser-embedding, but apparently not
11:28:49 <Twey> *grumble* *grumble*
11:29:29 <luite> doesn't the webkit gtk2hs thing work?
11:30:28 <Twey> luite: ‘Sort of.’
11:30:31 <novice_> Hi, is there a Haskell plugin for eclipse you would recommend?
11:30:54 <aristid> Twey: just build a web app :P
11:31:01 <Twey> It does, but it lacks bindings to JavaScriptCore, & provides no real methods to manipulate the content
11:31:03 <luite> Twey: oh ok, then please improve it before I need it ;p
11:31:18 <Twey> & some of the signals work weirdly
11:31:29 <Twey> aristid: Mmm, it's a thought
11:31:43 <Twey> But I wanted to use Haskell :<
11:31:53 <aristid> Twey: you can definitely use haskell for webapps.
11:32:38 <Twey> But I wouldn't — I'd end up just writing Javascript.  Or CoffeeScript if I'm lucky.
11:33:15 <aristid> Twey: well, it'd be at least about 50% or so haskell
11:33:29 <Twey> aristid: It'd be all client-side
11:33:35 <aristid> Twey: why?
11:34:02 <Reisen> ddarius, mauke, Peaker, I made all those changes, thank you, I hopefully won't make those mistakes again
11:34:10 <Reisen> seems I need to spend more time looking at libraries
11:34:11 <Twey> Because it's an application, not a webapp :þ  About the only thing that I'd want to do anywhere near the server might be file-saving, & I'd avoid that if possible because otherwise I can practically zero server load.
11:34:41 <Twey> (also, I'd rather not require a working Internet connection)
11:34:45 <aristid> Twey: uh, what do you want to write?
11:35:03 <Twey> The project is an HTML editor, of sorts
11:35:06 <cheater> he meant run the web app on the client side.
11:35:25 <cheater> and have the browser connect to it.
11:35:31 <cheater> no internet connection necessary.
11:35:33 <Reisen> ddarius, any chance you can expand a little on the ($) and forM_? This is the first anything I've written, so I'm not sure what you mean
11:35:45 <xil> hello. How do I force a DrawingArea in Gtk2Hs to update the entire area? In OpenGL there is "swapbuffers" for double buffering, but I'm not seeing anything quite like that for Gtk2Hs =/
11:35:47 <Twey> There's no CRUD or anything like that — it consists entirely of parsing & rich editing
11:36:31 <aristid> Twey: too bad it's not reasonable (even if to some degree possible) to target haskell at the client side
11:36:42 <ClaudiusMaximus> xil: widgetQueueRedraw or similar, i can check...
11:36:44 <Twey> cheater: Doesn't really matter — it would still mostly be running on the browser
11:36:47 <Twey> aristid: Right
11:37:12 <Twey> But there's no reason to make it a web app, other than that browser embedding support apparently sucks in *everything*.
11:37:32 <aristid> Twey: well, it's also much easier to show to friends if you just need to send them a link
11:37:42 <ddarius> Reisen: Instead of withFile "foo" ReadMode (\p -> do ...) you can write withFile "foo" ReadMode $ \p -> do ...
11:37:55 <ClaudiusMaximus> xil: it's widgetQueueDraw - i used it in my glut-like wrapper for gtk+opengl
11:37:55 <ddarius> That will avoid needing a distant closing parenthesis.
11:37:56 <xil> ClaudiusMaximus: ah thank you, I found widgetQueueDraw, which does that
11:38:14 <Twey> aristid: Not a primary concern (also, GTK HTML5 backend)
11:38:24 <Reisen> ddarius, ah, well for what It's worth I replaced it with readFile anyway, so I guess that's not a problem anymore
11:38:28 <xil> ClaudiusMaximus: haha, found it before me. Thanks!
11:38:36 <ddarius> Reisen: Hence the latter part of my original statement.
11:38:55 <Reisen> ddarius, ok, I'm with you then, thanks
11:38:56 <Twey> I mean, yes, that's nice, but not so nice that it would make fighting Web technologies worthwhile
11:38:58 <aristid> Twey: well, then just fix the webkit embedding for gtk2hs, and go on
11:40:02 <Twey> aristid: Yeah, that's an option.  I'm just frustrated that I have to basically write my own bindings.  I'd expect this to be something that's been well-supported in everything for ages.
11:40:03 <ddarius> I believe there was a browser plugin for Haskell a long, long time ago.
11:40:37 <xil> ClaudiusMaximus: hmmm...when I used that it doesn't keep things that were drawn with drawLine between calls to it
11:42:15 <ClaudiusMaximus> xil: i guess it clears automatically, maybe use a buffer surface behind the scenes and draw lines into that, then copy to the display on expose
11:42:28 <Peaker> Reisen: if you do use a multi-line lambda, the convention is to use:  foo $ \x -> do ..              and not   foo (\x -> ... many lines here ...)
11:43:02 <Peaker> though I never understood why an indented "do" block needed delimitation to help the compiler figure out where the argument ends
11:43:04 <Reisen> Peaker, I will remember it, ddarius mentioned as well
11:43:39 <Peaker> anyone knows why Haskell couldn't just parse:  foo do .. indented lines here ...     as foo (do ... )     based on the indentation?
11:44:24 <Peaker> it's kind of weird, because infix does parse that way:  foo $ do ...   or foo . do { ... }      it's as if prefix precedence is stronger than "do"s syntax :)
11:44:24 <ClaudiusMaximus> > (+1) `fmap` do return 3
11:44:25 <lambdabot>   No instance for (GHC.Show.Show (f a))
11:44:25 <lambdabot>    arising from a use of `M6462014054...
11:44:51 <Peaker> > (+1) `fmap` do [3]
11:44:52 <lambdabot>   [4]
11:45:00 <Peaker> > fmap (+1) do [3]
11:45:00 <lambdabot>   <no location info>: parse error on input `do'
11:47:21 <aristid> Peaker: seems like the grammar has a "hole" there
11:47:58 <ddarius> It could do that, it just doesn't.
11:48:13 <Peaker> a lot less $'s would be wasted there :)
11:49:07 <ddarius> Indentation is irrelevant.
11:49:40 <Peaker> yeah, weird infix application vs. prefix application issue
11:55:08 <Peaker> would people generally like to be able to throw \x -> .. or "do"  in prefix application?
11:55:32 <Peaker> a harmless GHC extension can probably allow that?
11:58:22 <DanBurton> for ecample?
11:58:22 <DanBurton> *example
12:02:30 <Twey> I remembered why I hate using Java — you have to use Wikipedia because all the official ‘documentation’ is mostly marketing crud.
12:03:30 <kamaji> Twey: javadoc?
12:03:41 <Twey> kamaji: At a more basic level than that
12:03:45 <kamaji> Ah I see
12:03:54 <Twey> Something recommended ‘JavaFX’
12:04:12 <kamaji> it's Rich Internet Applications Development
12:04:15 <kamaji> what more could you want to know
12:04:18 <kamaji> I bet it has loads of XML
12:04:26 <kamaji> XML is great.
12:04:42 <Twey> So I went to the JavaFX site and found that ‘JavaFX is the next step in the evolution of Java as a rich client platform’
12:04:48 <Twey> Very useful
12:04:50 <kamaji> hahahah
12:04:56 <kmc> but is it a second-generation, outside-in, pull-based, multiple-stakeholder, multiple-scale, high-automation, agile methodology???
12:05:11 <c_wraith> kmc: you forgot about dependency injection
12:05:24 <kmc> Twey, what, they figured out how to compile Java to ActionScript? ;P
12:05:28 <kamaji> but it's designed to provide a lightweight hardware accelerated Java UI platform for enterprise business applications!
12:05:38 <kamaji> what's not to like
12:05:44 <Twey> kmc: From the Wikipedia page, I don't think it even uses Java
12:05:51 <kmc> romulans on the bridge!
12:06:23 <kamaji> those klingon bastards killed my son!
12:06:36 <c_wraith> you don't have a son
12:06:42 <kamaji> not anymore
12:06:42 <kmc> The Enterprise
12:06:46 <kamaji> those klingon bastards killed him
12:08:53 <kmc> saying that romulans and klingons are the same is racist isn't it
12:09:26 <kamaji> I just have a psychological trigger to say that any time I see anything related to star trek
12:09:30 <kamaji> it's a crippling mental problem
12:09:35 <kamaji> among many others
12:09:42 <kmc> it would be in some circles
12:09:52 <kamaji> hahah
12:10:03 <c_wraith> here, it's probably fine
12:10:31 <bgamari> I am dealing with floating point-defined geometric objects; can anyone think of a good reason not to define the Eq instance as approximate equals with a tolerance on the order of machine precision?
12:10:39 <bgamari> Am I going to seriously break anything?
12:11:13 <monochrom> maybe it's fine if you use (==) carefully
12:11:17 <kamaji> bgamari: define ApproximatelyEq with a (~=) ?
12:11:33 <bgamari> Currently I find myself in a situation where just creating a new object with the same Double gives me machine precision issues
12:11:35 <kamaji> oh I guess then you can't use things that need Eq
12:11:38 <bgamari> Not entirely sure how
12:11:47 <bgamari> kamaji: Right, that's the issue
12:12:15 <kamaji> this is why it would be nice to overload class instances~
12:12:16 <bgamari> kamaji: Most Prelude functions will accept an alternative comparison function
12:12:44 <bgamari> But it seems cleaner to override Eq if it won't break the world
12:13:16 <kamaji> only trouble is if you ever want to compare with a non-approximate (==)
12:13:22 <erus`> a game costs $1 plus half its price. Thats a joke right?
12:13:58 <erus`> cost and price are the same thing?
12:14:13 <bgamari> kamaji: Right, at the moment I'm failing to come up with any such scenario
12:14:16 <cheater> i solved this problem while still in primary school
12:14:44 <cheater> before i got introduced to variables
12:15:33 <kamaji> bgamari: I'm guessing it's like a Vec3D or something?
12:15:41 <erus`> >let price = 1 + price / 2 in price
12:15:52 <erus`> > let price = 1 + price / 2 in price
12:15:56 <lambdabot>   mueval-core: Time limit exceeded
12:17:34 <erus`> 1 + .5p = p so 1 = .5p so p = 2
12:18:01 <erus`> @faq can ghc solve equations ?
12:18:01 <lambdabot> The answer is: Yes! Haskell can do that.
12:18:37 <bgamari> kamaji: Yes
12:18:55 <bgamari> kamaji: And geometric objects such as LineSeg, Line, Plane, etc.
12:19:08 <kamaji> right
12:19:26 <kamaji> i'm guessing you're looking at zeroing the error when doing operations as well?
12:19:40 <kamaji> oh I guess that doesn't matter
12:44:33 <DanBurton> I'm about to write this in a StackOverflow answer, so let me run it by you guys first: agree or disagree with the following?
12:44:42 <DanBurton> "The Haskell Committee, as many on the #haskell irc channel will quickly tell you, has made some rather wonky decisions regarding language design in order to cater to newbies."
12:44:58 <HalfWayMan> "wonky" :)
12:45:56 <shirt> how can i read the last byte of a file?
12:46:28 <shirt> i need lastByte :: FilePath -> IO (Maybe Word8)
12:46:47 <shirt> Nothing if the file is empty
12:47:30 <glguy> shirt: It should involve hSeek
12:47:44 <glguy> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v:hSeek
12:48:05 <glguy> open the file, seek to the end, attempt to read one byte
12:48:45 <DanBurton> see also hFileSize
12:48:54 <kmc> DanBurton, I agree with that
12:48:58 <ddarius> DanBurton: That sentence doesn't seem like it is likely to be to germane to whatever you are answering.
12:48:59 <kmc> there's only a few examples i can think of
12:49:01 <glguy> You won't need hFileSize as you can hSeek relative to the end of the file
12:49:03 <kmc> they're kind of incongruous
12:49:08 <kmc> is this about the monomorphism restriction?
12:49:19 <shirt> glguy: thanks
12:51:40 <DanBurton> kmc: regarding exceptions
12:51:49 <kmc> oh
12:51:53 <kmc> how does your statement relate?
12:51:57 <DanBurton> you'll see
12:51:59 <DanBurton> :)
12:52:25 <mekeor> i'm looking for a function foobar, such that `foobar f (x,y) = (x,f y)'.
12:52:35 <ddarius> I recommend just omitting the sentence since it is likely just a waste of time.
12:52:38 <DanBurton> It is somewhat subjective, and probably somewhat false. But whatever. http://stackoverflow.com/questions/7704999/meaning-of-haskell-exceptions/7706155#7706155
12:52:38 <mekeor> i forgot its name...
12:52:41 <ddarius> fmap
12:52:54 <mekeor> ddarius: thats for me?
12:53:13 <ddarius> > fmap f (x,y) :: (Expr, Expr)
12:53:14 <lambdabot>   (x,f y)
12:53:28 <mekeor> wow
12:53:39 <mekeor> what the hell is "Expr" ?! cool!
12:53:50 <DanBurton> lambdabot magic
12:54:02 <ion> > [first f (x,y), second f (x,y), fmap f (x,y)] :: [(Expr, Expr)]
12:54:02 <lambdabot>   [(f x,y),(x,f y),(x,f y)]
12:54:04 <kmc> http://hackage.haskell.org/package/simple-reflect
12:54:09 <mekeor> so, it's not in GHCi?, DanBurton
12:54:23 <kmc> mekeor, see that package
12:54:30 <DanBurton> ^
12:54:31 <mekeor> ion: so, second == fmap ?
12:54:41 <mekeor> kmc: cool! oO
12:54:55 <ion> Whether to use second or fmap depends on whether you want or need the code to be tuple-specific or generalized to functors.
12:54:55 <c_wraith> > second `asTypeOf` fmap
12:54:56 <lambdabot>   Overlapping instances for GHC.Show.Show
12:54:56 <lambdabot>                              ((b ->...
12:55:00 <c_wraith> :t second `asTypeOf` fmap
12:55:01 <lambdabot> forall b c d. (b -> c) -> (d, b) -> (d, c)
12:55:02 <mekeor> @hoogle second
12:55:02 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
12:55:03 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
12:55:03 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
12:55:29 <ion> (Well, to be more accurate, first and second are generalized to arrows.)
12:56:06 <DanBurton> leapSecondTable o_O oh boy :)
12:56:06 <ion> But you’ll probably find yourself using first and second with functions and fmap with more generalized stuff.
12:56:14 <ddarius> ion: That is not the criteria, at all, that I would used to decide between fmap and second.
12:56:49 <kmc> how does the leap second table get updated :O
12:58:24 <shirt> glguy: it's ok to use hGetChar to read a single byte from a binary file?
12:58:39 <kmc> Char != byte
12:58:45 <kmc> if you want bytes you should use ByteString IO
12:59:25 <shirt> but i only need a single byte, do i really need the overhed of bytestring?
12:59:32 <glguy> overhead?
12:59:34 <kmc> tell me more about the overhead of bytestring
12:59:46 <glguy> You're writing Haskell code :)
13:00:04 <shirt> i mean the extra code for unpacking bytestring and everything
13:00:09 <kmc> unpacking?
13:00:33 <c_wraith> bytestring has 3 words of overhead above what a sufficiently primitive wrapper would use
13:00:33 <glguy> shirt: Just give us more information about what you're trying to do
13:00:41 <kmc> ah, you mean code size, not speed
13:00:49 <kmc> that's a fair point, but I don't think it will be much code
13:00:56 <shirt> glguy: it's easy: read the last byte of a file into a Word8
13:01:00 <kmc> and I don't know of IO routines that operate on [Word8] directly
13:01:32 <shirt> according to the docs, if i use openBinaryFile then hGetChar should return the single byte that i want
13:01:36 <glguy> shirt: so either go low-level and use hGetBuf or use the pretty ByteString wrapper
13:01:42 <DanBurton> I can't imagine that converting one byte from one format to another would produce any kind of significant overhead
13:01:44 <glguy> You won't see any overhead difference
13:01:51 <cicatristeza> i am trying to solve problem 45 of project euler, and the following code just hangs, can anyone tell me why? http://pastebin.com/b3uwdrZn
13:01:53 <kmc> shirt, that's a hack though, the type of hGetChar is wrong then
13:01:53 <mauke> The paste b3uwdrZn has been copied to http://hpaste.org/52380
13:02:32 <kmc> cicatristeza, for each of 100000 numbers, you're linearly searching three lists of 100000 numbers
13:02:37 <kmc> that's going to be slow
13:02:59 <kmc> membership testing on a Data.Set is much faster than membership testing on a list
13:03:20 <dmwit> cicatristeza: Because that's a really inefficient way to solve the problem.
13:03:20 <shirt> hm.... now that i think about it this file isn't actually binary
13:03:27 <kmc> als, higher-numbered PE problems usually expect you to do something clever involving maths
13:03:32 <kmc> not just brute-force programming
13:04:00 <emre> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 -emre(~jovr@97-83-39-82.dhcp.trcy.mi.charter.com)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 * emre I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 <beytullah> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 -beytullah(~onsg@97-83-39-82.dhcp.trcy.mi.charter.com)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 * beytullah I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 <Guest121534> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 -Guest121534(~woup@97-83-39-82.dhcp.trcy.mi.charter.com)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 * Guest121534 I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 <mehtap> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 <avvci> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 -avvci(~dlxw@75.118.231.215)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 * avvci I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 <hearos> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 -hearos(~hnvx@68.224.186.12)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 <eIif> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 -eIif(~omwh@ool-4352d2de.dyn.optonline.net)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 * eIif I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:00 <dumdale> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 * hearos I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 <kiziI> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 -kiziI(~jovr@jmst-ftth-cn-21-23.daktel.net)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 * kiziI I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 <kiziIok> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 -kiziIok(~nqzx@jmst-ftth-cn-21-23.daktel.net)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 * kiziIok I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 <sonyoIcu> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 -sonyoIcu(~dluz@jmst-ftth-cn-21-23.daktel.net)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 * sonyoIcu I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 -dumdale(~qwxa@ool-18bce939.dyn.optonline.net)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 * dumdale I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 <esin> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 -esin(~jovr@ool-18bce939.dyn.optonline.net)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 <dustyy> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 -dustyy(~ywxv@184.77.187.127)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 * dustyy I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 <burcin> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 -burcin(~mfru@CPE-65-31-152-99.wi.res.rr.com)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 * burcin I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 * esin I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:01 <gaffar> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:04 <bunani> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:04 -bunani(~vydc@65.36.9.120)- I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:04 * bunani I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:08 <cicatristeza> kmc, the problem states that 40755 is one of the possible solutions. even when i narrow the range down to 40000..45000, it doesnt show up with a positive
13:04:12 <resat> I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome in the me server irc.eu.bgit.net channel #Bulgaria I`m The Best HackeR in The World ! Wellcome
13:04:14 --- mode: kloeri set +r
13:04:34 <pigoz> lulz holy shit
13:05:13 <dmwit> What is +r?
13:05:36 <dmwit> Oh, only allow registered names to speak.
13:05:43 <kmc> @vixen I`m The Best HackeR in The World
13:05:43 <lambdabot> Government enterprise is the most inefficient and costly way of producing jobs.
13:05:58 <dmwit> ?vixen Are you totally ?nixon now.
13:05:59 <lambdabot> Voters quickly forget what a man says.
13:06:28 <dmwit> fickle voters
13:06:35 <kloeri> dmwit: s/speak/join/
13:06:53 <dmwit> ah, okay
13:07:15 <dmwit> kloeri: Anyway, thank you. =)
13:07:33 <kloeri> np
13:08:23 <c_wraith> wow.  @vixen *is* @nixon now.  People were that offended by vixen?
13:08:42 <jmcarthur> wow
13:08:53 <kmc> what's funny is that they're not offended by nixon
13:08:59 <kmc> @. elite nixon
13:09:00 <lambdabot> yOu \/\/ON't H4Ve nIxon 7O KI(K 4R0Und 4ny/\/\OR3, becAuse, gEN+|e/\/\En, +HIs iz /\/\Y 1aS+ PR3SS conphErEnCE.
13:09:03 <kmc> @. elite nixon
13:09:04 <lambdabot> 4 man iz n0T FIniS|-|Ed wh3N h3 iS DephEA+Ed. He Iz phiniSh3D \/\/Hen |-|3 qUiT5.
13:09:14 <c_wraith> nixon is historical-offensive.  that's a different alignment
13:09:31 <kmc> @nixon has some unkind things to say about certain minority groups
13:09:31 <lambdabot> The presidency has many problems, but boredom is the least of them.
13:10:05 --- mode: kloeri set -r
13:11:17 <jlouis> ion: I don't think so. They are what I would start with.
13:12:54 <jlouis> ion: yeah, that is about it I think
13:13:13 <jlouis> ion: looking at the other modules, there are not relly anything from there you will need
13:13:44 <kamaji> Where's a state monad tutorial :(
13:13:51 <kamaji> the learn-you-a-haskell one is broken
13:14:11 <DanBurton> @google haskell state monad tutorial
13:14:13 <lambdabot> http://coder.bsimmons.name/blog/2009/10/the-state-monad-a-tutorial-for-the-confused/
13:14:13 <lambdabot> Title: A State Monad Tutorial | LAMBDAPHONE
13:14:24 <kamaji> Ok where's one I can follow?
13:14:31 <DanBurton> Never seen that one before
13:14:43 <jlouis> ion: the only thing you need to be aware of is a bug I ran into: forever foo is not equal to foo' = foo >> foo'
13:14:54 <kamaji> i'll read it again
13:15:02 <cheater> @type (>>=)
13:15:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:15:04 <jlouis> ion: or it wasn't in 6.x
13:15:17 <cheater> how do i find the source for List's >>=?
13:15:22 <cheater> i just want to find out what it does
13:15:27 <DanBurton> kamaji: you could try the wiki one
13:15:31 <DanBurton> @wiki State Monad
13:15:31 <lambdabot> http://www.haskell.org/haskellwiki/State_Monad
13:15:40 <jlouis> ion: it might look like they are equal, but they had different memory usage. The forever variant leaks with the processM monad :/
13:16:56 <DanBurton> kamaji: or perhaps this http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
13:17:14 <kamaji> well the first one is also out of date
13:17:22 <ion> jlouis: Oh, ok.
13:17:25 <kamaji> it's because it switched to StateT or something
13:17:57 <jlouis> ion: I asked and looked at Core output, but I couldn't figure out why :P
13:18:06 <jlouis> it may be fixed now
13:19:11 <erus`> Growing a Language, by Guy Steele is a very good presentation
13:19:27 <BobFunk> kinda annoying that the mongoDB driver uses CompactString, when it seems to have been deprecated in favor of Text :(
13:19:35 <BobFunk> any good way to convert between the two?
13:19:57 <cheater> why not update the mongodb driver
13:20:57 * BMeph thinks that sounds like cheating... ;þ
13:21:21 <HalfWayMan> That's actually a good idea...
13:21:52 <BobFunk> might do it at some point - right now I'm just hacking on a little webapp, and starting to rework the database drivers doesn't seem like the most productive way forward...
13:22:02 <DanBurton> @hackage mongodb
13:22:02 <lambdabot> http://hackage.haskell.org/package/mongodb
13:22:07 <DanBurton> boo
13:22:10 <cheater> true
13:22:29 * DanBurton wants a hayoo extension for lambdabot
13:22:44 <HalfWayMan> Is there any particular reason why CompactString was chosen?
13:23:10 <BobFunk> no idea - it's actually the BSON library using it
13:23:18 <BobFunk> http://hackage.haskell.org/package/bson
13:23:34 <BobFunk> UString is just an alias for CompactString
13:24:16 <HalfWayMan> BobFunk: Indeed. I'll ask Tony.
13:28:16 <DevHC> haha, GHC is an utter failure:
13:28:17 <DevHC> [1 of 1] Compiling Main             ( delme.hs, delme.o )
13:28:17 <DevHC> delme.hs:2:1: parse error on input `<stderr>: hPutChar: invalid argument (invalid character)
13:28:33 <DevHC> whose bright idea was this "invalid character" crap?
13:29:17 <kmc> wow
13:29:20 <kmc> someone's pissy
13:29:35 <DevHC> the source file contains one ♥ btw
13:29:38 <kmc> GHC SUX FIX MY BUG OR I WILL HATE U FOREVER
13:29:49 <kmc> DevHC, what character encoding does your source file use
13:29:59 <DevHC> lemme see
13:30:51 <DevHC> using ``less'': <E2><99><A5>
13:31:02 <mauke> DevHC: echo $LANG
13:31:03 <DevHC> does that mean UTF-8?
13:31:13 <cicatristeza> in a list comprehension with two variables, how do i soecify two different ranges for the variables?
13:31:15 <kmc> that gives me a ♥ in UTF-8, yes
13:31:16 <DevHC> LANG: Undefined variable.
13:31:22 <kmc> cicatristeza, x <- xs, y <- ys
13:31:24 <cicatristeza> *specify
13:31:26 <mauke> DevHC: export LANG=en_US.UTF-8
13:31:29 <kmc> they're not just ranges, they are arbitrary lists
13:31:38 <joevandyk> i'm still trying to internalize left folds vs right folds.  I don't understand why they are called 'left' and 'right'.  They both take values from the left side of the list.
13:31:53 <kmc> @where folds
13:31:53 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
13:31:55 <cicatristeza> how simple, thanks kmc
13:31:58 <mauke> joevandyk: (A + B) + C -- left associative
13:32:00 <joevandyk> yes, i've seen that tons of times
13:32:03 <mauke> joevandyk: A + (B + C) -- right associative
13:32:23 <DevHC> mauke: ok, why should this be required?
13:32:28 <mauke> > foldr (+) z [a,b,c]
13:32:29 <lambdabot>   a + (b + (c + z))
13:32:33 <mauke> > foldl (+) z [a,b,c]
13:32:33 <lambdabot>   z + a + b + c
13:32:43 <joevandyk> hm
13:32:45 <cicatristeza> kmc, you meant the fold diagrams for me?
13:32:57 <mauke> DevHC: so programs know what encoding you prefer
13:33:04 <kmc> no for joevandyk
13:34:11 <kmc> does the Report specify a Unicode encoding for source files?
13:34:17 <kmc> i thought it spec'd UTF-8 but now i'm not finding it
13:34:22 <kmc> so maybe it is by locale
13:34:24 <Draconx> kmc, it does not.
13:34:36 <kmc> ok, i was wrong before then
13:34:36 <DanBurton> joevandyk: right fold is called right fold, because in theory, you start at the right, gathering the elements into an accumulator. It doesn't matter that it is actually implemented moving from left to right.
13:34:59 <DevHC> mauke: i mean why does GHC freak out when printing a non-ASCII character to a file opened in text mode while LANG is not set?
13:35:09 <joevandyk> DanBurton: so what confused me is that i read foldr can be used on infinite lists.  which have no end.
13:35:16 <mauke> DevHC: because there is nothing it can do with it
13:35:23 <Twey> devious: Because it was opened in text mode
13:35:25 <joevandyk> so when "it starts on the right", that seemed to make no sense.
13:35:27 <Twey> Er, DevHC
13:35:31 <kmc> DevHC, how should you print a character if you do not know what character to use?
13:35:31 <mauke> Twey: what
13:35:36 <kmc> what character encoding*
13:35:39 <Twey> Amongst other things
13:35:51 <DevHC> mauke: assume something other than ASCII if LANG is not set to ASCII-only?
13:35:58 <Twey> That means it should translate it to the appropriate encoding, no?
13:36:11 <slack1256> joevandyk: best advice i can give you about folds, try each one by hand, specially this setting "foldr/foldl (&&) False [False,False,True,False]"
13:36:12 <Twey> & it can't.
13:36:13 <mauke> DevHC: which encoding should it assume?
13:36:22 <DevHC> maybe UTF-8?
13:36:26 <joevandyk> > foldr (:) [] "Hello"
13:36:26 <lambdabot>   "Hello"
13:36:30 <DanBurton> joevandyk: yep. this is because when folding a given value from the list into the accumulator, you assume that the list from that point on all the way to the right has been folded in to the accumulator.
13:36:35 <mauke> DevHC: no, if you wanted UTF-8, you'd have said so in LANG
13:36:39 <joevandyk> > foldl (:) [] "Hello"
13:36:40 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
13:36:53 <slack1256> joevandyk: remember haskell evaluates from outside to inside , if you can do that you'd hav eearned your black bell
13:36:59 <ddarius> kmc: The Report says nothing at all about source files.
13:37:06 <mauke> DevHC: the issue here is legacy 1-byte encodings that were used everywhere before UTF-8 was invented
13:37:06 <Twey> DevHC: It's better to die & let the user know that something is wrong than to compile fine & print garbage (potentially into somewhere the developer won't find until past production)
13:37:09 <DevHC> mauke: what does GHC default to when LANG is not set, and why?
13:37:27 <mauke> DevHC: I don't know, probably US-ASCII
13:37:41 <mauke> and the reason is that unix is older than utf-8
13:38:12 <DevHC> unix specifies that text mode should be the same as binary mode
13:38:28 <mauke> not in haskell
13:38:45 <mauke> and, well, that's a stupid requirement
13:38:52 <slack1256> unix does that?
13:38:55 <DevHC> it's stupid that text mode even exists
13:38:57 <kmc> DevHC, you mean, like, fopen?
13:38:59 <mauke> it works if your language doesn't support unicode anyway
13:39:03 <Twey> I don't think UNIX has a text mode, does it?
13:39:04 <DevHC> kmc: yes
13:39:09 <kmc> that's not Unicode-compatible anyway
13:39:10 <mauke> Twey: C does
13:39:16 <kmc> you can't call it "text mode" in a modern sense
13:39:20 <mauke> but in C char == byte
13:39:26 <kmc> it fails to support the characters used by the majority of people on earth
13:39:31 <Twey> There's no text mode in my fopen() manpage
13:39:39 <mauke> Twey: look for the "b" flag
13:39:51 <mauke> default is text mode, with "b" binary mode
13:40:08 <kmc> on Windows you actually get a different *byte* stream for text vs. binary mode
13:40:18 <Twey> mauke: I have r r+ w w+ a a+
13:40:30 <kmc> the C spec allows it; POSIX systems will ignore it
13:40:33 <mauke> Twey: The mode string can also include the letter 'b' either as a last character or as a character between the characters in any of the  two-character  strings  described
13:40:34 <DevHC> kmc: Windows is WRONG(TM)
13:40:38 <Twey>        The mode string can also include the letter 'b' either as a last character or as a character between the characters in any of the two-character strings described above.   This  is
13:40:42 <Twey>        strictly  for  compatibility with C89 and has no effect; the 'b' is ignored on all POSIX conforming systems, including Linux.  (Other systems may treat text files and binary files
13:40:46 <Twey>        differently, and adding the 'b' may be a good idea if you do I/O to a binary file and expect that your program may be ported to non-UNIX environments.)
13:40:49 <Twey> Oops, that didn't wrap nicely
13:40:59 <DevHC> well technically text mode should have nothing to do with GHC chosing some encoding
13:41:14 <mauke> the reason C has a "b" flag is OSes with record-based file access
13:41:17 <DevHC> i gather there is a GHC option to chose some encoding for streams?
13:41:47 <mauke> it also does something on DOS based OSes (newline translation)
13:42:13 <mauke> DevHC: why not? what else does "text mode" mean?
13:42:20 <Twey> DevHC: GHC uses whatever encoding you specify; if you don't specify anything it uses the closest thing we have to a lowest common denominator (ASCII).  This seems like reasonable behaviour to me.
13:42:23 <mauke> again, Haskell is not C
13:42:43 <mauke> in particular, Haskell's String type isn't bytes
13:42:44 <monochrom> I'm thinking whether the CRLF convention began with CP/M
13:42:48 <DevHC> mauke: why not what? text mode is what it is: text mode, see hSetBinaryMode
13:42:55 <mauke> monochrom: probably older
13:43:09 <mauke> DevHC: <DevHC> well technically text mode should have nothing to do with GHC chosing some encoding
13:43:12 <mauke> DevHC: that's ALL it does
13:43:39 <monochrom> at any rate, hSetBinaryMode is useful for turning off utf-8 decoding so you can accept arbitrary bytes, too
13:43:41 <mauke> monochrom: typewriters have carriage return/line feed
13:43:52 <monochrom> ah, way back to teletype
13:43:56 <DevHC> Twey, mauke: if i set hSetBinaryMode True on stdout, then GHC does NOT freak out when outputting non-ASCII chars
13:44:13 <mauke> DevHC: it probably just mangles them
13:44:40 <mauke> that is, I'd expect it to turn Char -> Word8 by (`mod` 256)
13:44:53 <monochrom> if you want to use arbitrary bytes, you should go ByteString to begin with
13:45:22 <kmc> do typewriters execute \r and \n motions in parallel?
13:45:35 <mauke> lesson 1: "plain text" isn't
13:45:44 <monochrom> not usually
13:45:53 <c_wraith> line printers often do, though
13:45:57 <mauke> kmc: you have to move that thing all the way to the side
13:46:07 <c_wraith> anyone remember line printers? :)
13:46:31 * Twey does
13:46:53 <monochrom> could be parallel, could be sequential, same result, so it's just whatever the mechanical engineer chooses
13:46:53 <HalfWayMan> I miss those.
13:47:28 <joevandyk> > foldr (+) z [a,b,c]
13:47:29 <lambdabot>   a + (b + (c + z))
13:47:36 <joevandyk> > foldr (:) z [a,b,c]
13:47:37 <lambdabot>   Couldn't match expected type `[a]'
13:47:37 <lambdabot>         against inferred type `SimpleRef...
13:47:50 <DanBurton> :t (:)
13:47:51 <lambdabot> forall a. a -> [a] -> [a]
13:48:13 <monochrom> for example if it's a manual typewriter and I'm the one executing them, I could manually hit "linefeed" and manually push that side-handle for "carriage return" in parallel. but I wouldn't.
13:48:13 <joevandyk> > foldr (:) [z] [a, b, c]
13:48:14 <lambdabot>   [a,b,c,z]
13:48:30 <slack1256> > foldr (:) [] [a,b,c]
13:48:31 <lambdabot>   [a,b,c]
13:48:43 <joevandyk> > foldl (:) z [a, b, c]
13:48:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
13:48:47 <DanBurton> > (a:b:c:z)
13:48:48 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
13:48:48 <lambdabot>         against inferre...
13:48:54 <joevandyk> foldl (:) [z] [a, b, c]
13:49:13 <joevandyk> > foldl (:) [z] [a, b, c]
13:49:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
13:49:16 <slack1256> joevandyk : that doesn't make sense you see
13:49:21 <joevandyk> i hate computers
13:49:28 <HalfWayMan> :)
13:49:34 <DanBurton> > foldl (flip (:)) [z] [a,b,c]
13:49:36 <lambdabot>   [c,b,a,z]
13:49:54 * DanBurton has a love/hate relationship with computers
13:50:10 <slack1256> joevandyk: foldl (:) [z] [a,b,c] -> ((([z]:a):b):c)
13:50:54 <joevandyk> maybe i need to stop drinking
13:51:18 <slack1256> but drinking give you superPowers
13:51:25 <slack1256> code that works and you don't know why!
13:51:32 <joevandyk> @type superPowers
13:51:33 <lambdabot> Not in scope: `superPowers'
13:52:11 <dainanaki> is there a way to use template haskell to evaluate an expression fully at compile time?
13:52:44 <kmc> a quoted expression, sure
13:52:55 <rtharper> dainanaki: you want the concrete representation of an expression replaced with it's eval'd result
13:53:07 <DevHC> its*
13:53:43 <dainanaki> rtharper: yes. the idea would be that I could use TH to compute a lookup table at compile time.
13:53:55 <kmc> yeah you can do that
13:54:04 <kmc> there's code on hackage somewhere which generates unrolled FFT code at compile time
13:54:11 <rtharper> Thanks DevHC, I often hope that other people will serve as my typecheckers, it really adds something to the channel =p
13:54:58 <DevHC> xD
13:55:17 <slack1256> somebody here knows about the develoment of enumerators?
13:55:31 <slack1256> enumerators are ADT at its finest, and very clever too
13:55:43 <slack1256> but seems to complicated for simple setups
13:55:54 * earthy nods
13:56:17 <slack1256> anybody knows if  it going to simplify in the future (as in monad class which is super simple?)
13:56:34 <earthy> doubt it
13:56:40 <earthy> it's slightly tricky in edge cases
13:58:02 * slack1256 is losing hope
13:59:05 <mm_freak> slack1256: iteratees are actually very simple and very well suitable for simple applications…  but you need to understand the concept first
13:59:34 <mm_freak> slack1256: here is a good introduction: http://www.yesodweb.com/book/enumerator
13:59:37 <cicatristeza> can anyone please explain the last example here to me: http://zvon.org/other/haskell/Outputprelude/foldl_f.html ?
13:59:40 <slack1256> mm_freak: i think i understand the concept, maybe i should look more code
14:00:09 <mauke> > foldl (\x y -> 2*x + y) 4 [1,2,3]
14:00:10 <lambdabot>   43
14:00:13 <mauke> > foldl (\x y -> 2*x + y) 4 [1,2,3] :: Expr
14:00:14 <lambdabot>   2 * (2 * (2 * 4 + 1) + 2) + 3
14:00:28 <mm_freak> slack1256: your iteratee is just a consumer, which is always in one of three states:  wants more input, has already yielded a result, or has died with an error
14:00:40 <slack1256> mm_freak: yesod is the one *big* project that features enumerator right? any where else were to look
14:00:41 <mauke> > foldl (\x y -> 2*x + y) 4 [a,b,c] :: Expr
14:00:42 <lambdabot>   2 * (2 * (2 * 4 + a) + b) + c
14:00:54 <slack1256> mm_freak: yeah that is the definition of Step on enumerator
14:00:59 <mauke> cicatristeza: what part do you not understand?
14:01:08 <slack1256> mm_freak: iterators is just step wrapped on a newtype
14:01:23 <mm_freak> slack1256: yesod is a web framework, which uses enumerators under the hood…  however, the tutorial i linked is unrelated to yesod
14:01:25 <cicatristeza> mauke: y -> 2*x +y
14:01:30 <cicatristeza> mauke: how is this applied to the list?
14:01:34 <mm_freak> slack1256: iteratees, yes
14:01:37 <cicatristeza> and where does 4 come in?
14:01:38 <mauke> cicatristeza: oh, you don't know about functions?
14:01:43 <mm_freak> slack1256: there are no iterators in the iteratee concept
14:01:58 <cicatristeza> mauke: apparently not
14:02:05 <mauke> cicatristeza: \X -> Y is a function. X is the parameter, Y is the function body
14:02:25 <slack1256> mm_freak: cool I though it would be a news pages telling that yesod now uses enumerators.
14:02:25 <mauke> cicatristeza: \x y z -> ... is syntactic sugar for \x -> (\y -> (\z -> ...))
14:02:52 <mm_freak> slack1256: then i wouldn't call it an "introduction", would i?
14:03:01 <cicatristeza> so \x y -> is basically a function of 2 variables, yes>
14:03:16 <mauke> cicatristeza: right
14:03:34 <slack1256> mm_freak: yeah xD
14:03:37 <cicatristeza> and how is the 4 applied to the list?
14:03:48 <mauke> cicatristeza: foldl repeatedly applies that function
14:04:09 <mauke> cicatristeza: the first argument is an accumulator, the second argument is the current list element
14:04:16 <cicatristeza> yes, in the fist step, what is the x-value? is it 4? and is y 1?
14:04:30 <mauke> cicatristeza: the result of that function will be used as the accumulator for the next element
14:04:41 <mauke> cicatristeza: 4 is the initial value of the accumulator
14:04:55 <cicatristeza> ok
14:05:01 <mauke> yes, in the first call, y is 1
14:05:16 <mauke> @src foldl
14:05:16 <lambdabot> foldl f z []     = z
14:05:16 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:05:18 <cicatristeza> so how do you compute it: 2*4 + 1, correct?
14:05:27 <cicatristeza> and this is now the new accumulator right?
14:05:30 <mauke> right
14:05:36 <cicatristeza> i see
14:05:39 <cicatristeza> thanks mauke
14:06:00 <cicatristeza> when is foldl typically used
14:06:04 <cicatristeza> or foldr
14:06:09 <mauke> foldl? never
14:06:19 <mauke> normally you want either foldr or foldl'
14:06:32 <cicatristeza> why is that
14:06:40 <DevHC> mauke: this is just fucking WRONG(TM)
14:06:42 <mauke> excessive laziness
14:06:52 <rtharper> cicatristeza: usually you want the accumulator in foldl to be strict
14:07:00 <DevHC> i've created a file named ``''
14:07:05 <cicatristeza> and by strict you mean?
14:07:10 <rtharper> cicatristeza: not lozy
14:07:17 <cicatristeza> aha
14:07:20 <rtharper> lazy*
14:07:33 <DevHC> then i did: ls | (program to do getContents >>= readFile >>= putStr)
14:07:48 <DevHC> with LANG not set, GHC freaks out when reading the standard input
14:07:50 <cicatristeza> in this case, wasnt the initial accumulator strict?
14:07:57 <DevHC> with LANG set, GHC does not find the file
14:08:01 <mm_freak> cicatristeza: notice from the definition that foldl can't yield a result, until it has reached the base case, where the list is []
14:08:27 <cicatristeza> mm_freak: so?
14:08:41 <mauke> DevHC: does it work for a file named x?
14:09:09 <mm_freak> cicatristeza: while it cannot yield, it still doesn't know how you will use the result, so it doesn't compute anything
14:09:11 <joevandyk> Is there a function in the Prelude that takes two arguments and returns the second one?
14:09:32 <mm_freak> foldl (+) 0 [1,1,1,1,1] does not build a sum right away, but a chain of additions
14:09:38 <mm_freak> 0 + 1 + 1 + 1 + 1 + 1
14:09:39 <mauke> joevandyk: not directly but there's flip const and const id
14:09:50 <mm_freak> it keeps that chain in memory, until you ask for the sum, at which point it executes it
14:09:54 <mm_freak> foldl' doesn't do that
14:10:09 <glguy> It isn't in the prelude, but there is always just   \ _ a -> a
14:10:14 <joevandyk> mauke: hm, so i figure last can be written as
14:10:19 <DevHC> with the use of hSetBinaryMode true, GHC finds the file
14:10:19 <joevandyk> > foldl1 (\acc x -> x) xs
14:10:20 <lambdabot>   Not in scope: `xs'
14:11:13 <DevHC> mauke: yes, opening a file ``x'' works
14:11:22 <mm_freak> > foldl (const Just) Nothing [1..10]
14:11:23 <lambdabot>   Just 10
14:11:29 <mauke> DevHC: ok, then your code isn't quite what you showed me
14:11:29 <mm_freak> > foldl (const Just) Nothing []
14:11:30 <lambdabot>   Nothing
14:11:41 <DevHC> mauke, well, it's actually:
14:11:53 <mm_freak> > foldl (const id) (error "Last element of empty list") []
14:11:54 <lambdabot>   *Exception: Last element of empty list
14:11:55 <DevHC> getContents >>= readFile . head . lines >>= putStr
14:12:00 <mm_freak> > foldl (const id) (error "Last element of empty list") [1..10]
14:12:01 <lambdabot>   10
14:12:16 <mm_freak> i think this is one use case for foldl
14:13:33 <slack1256> as a rule of a thumb of folds: use foldr if your function is lazy in it's second arg, use foldl' if you are sure you will process the whole list
14:13:35 <joevandyk> mauke: i don't understand how 'const id' works.  id returns itself, right?
14:13:41 <mauke> joevandyk: no
14:13:45 <slack1256> almost never use foldl
14:13:51 <joevandyk> mauke: err, the argument
14:13:57 <joevandyk> mauke: id returns the first argument
14:14:02 <mauke> yes
14:14:08 <slack1256> > const True False
14:14:09 <lambdabot>   True
14:14:14 <slack1256> > const True 5
14:14:15 <lambdabot>   True
14:14:21 <cgroza> what foldl does? It travels at the end of the list at each iteration?
14:14:26 <mauke> cgroza: no
14:14:38 <DevHC> i think ppl need to understand that filenames on filesystems (like UFS) can have any ord in 0..255 with the exception of '/' and '\0'
14:14:49 <joevandyk> mauke: why does 'const id 3 4' return 4?
14:14:56 <jmcarthur> > foldl f z [a,b,c,d,e]
14:14:57 <lambdabot>   f (f (f (f (f z a) b) c) d) e
14:15:00 <jmcarthur> > foldr f z [a,b,c,d,e]
14:15:01 <lambdabot>   f a (f b (f c (f d (f e z))))
14:15:01 <mauke> joevandyk: evaluate it step by step
14:15:09 <jmcarthur> cgroza: ^^
14:15:17 <DevHC> which can have any form of encoding, be it UTF-8 or any other extended ASCII
14:15:27 <slack1256> joevandyk because ((const id 3)4) -> (id) 4 -> 4
14:15:50 <mauke> DevHC: funny thing, openFile is broken
14:16:03 <joevandyk> slack1256: i was reading that as const has 3 arguments
14:16:06 <mm_freak> joevandyk: const id 3 = id
14:16:09 <joevandyk> but it only takes two?
14:16:18 <mauke> joevandyk: every function has exactly one argument
14:16:18 <slack1256> yeah
14:16:21 <slack1256> @type const
14:16:22 <lambdabot> forall a b. a -> b -> a
14:16:30 <DevHC> mauke: what does that supposed to mean?
14:16:35 <mm_freak> > id id id id id 5
14:16:36 <lambdabot>   5
14:16:42 <joevandyk> yeah, but isn't 'const id 3 4' the same as 'const(id 3 4)' ?
14:16:42 <jmcarthur> > 3 5
14:16:43 <lambdabot>   3
14:16:50 <mauke> joevandyk: no
14:16:54 <slack1256> joevandyk: const take 2 and return id
14:16:57 <joevandyk> son of a bitch
14:16:58 <mauke> joevandyk: it's the same as ((const id) 3) 4
14:17:02 <mm_freak> joevandyk: a function can result in a function, and this is exactly what happens with 'const id 3'
14:17:15 <joevandyk> let me think
14:17:15 <jmcarthur> const id 3 4  ==  (const id 3) 4  ==  ((const id) 3) 4
14:17:20 <mm_freak> because the 'a' in the type a -> b -> a can itself be a function type
14:17:23 <mm_freak> a = x -> y
14:17:34 <mm_freak> (x -> y) -> b -> (x -> y)
14:17:44 <mauke> DevHC: sorry, I've suddenly lost my motivation
14:17:48 <mm_freak> since (->) is right-associative that's equivalent to:  (x -> y) -> b -> x -> y
14:18:01 <DevHC> mauke: map (>.<)
14:18:11 <mm_freak> and function application is left-associative, so (const id 3) 4 = const id 3 4
14:18:13 <cicatristeza> so then this snippet is a flub isnt it: http://stackoverflow.com/questions/185781/finding-the-lcm-of-a-range-of-numbers/196463#196463
14:18:47 <joevandyk> oh, i see
14:19:14 <joevandyk> that's crazy
14:19:20 <joevandyk> so different
14:19:25 <slack1256> but a clever crazy right?
14:19:26 <mauke> DevHC: btw, it works if you set stdin to binary
14:19:51 <ion> I like how even the early http://www.ml-class.org/ course videos have to deal with the subtle bugs you can get from using destructive assignment in the slightly incorrect order.
14:19:59 <mauke> > foldl lcm 1 [24, 12, 6]
14:20:00 <lambdabot>   24
14:20:03 <joevandyk> i've been programming full-time for 10+ years and haskell makes me feel like i know nothing.  :)
14:20:05 <mm_freak> joevandyk: haskell uses currying, so every function has exactly one argument
14:20:06 <mauke> > foldl lcm 1 [24, 12, 6, 5]
14:20:07 <lambdabot>   120
14:20:14 <joevandyk> mm_freak: yes
14:20:28 <mm_freak> joevandyk: just remember that (->) is right-associative and function application is left-associative…  that helps a lot
14:20:29 <dainanaki> Embedding a large precomputed table explicitly seems kind of impossible. Has anyone had any luck doing it before?
14:20:33 <ion> joevandyk: You know CLispScript very well, i’m sure. :-) http://www.jerf.org/iri/post/2908
14:20:35 <mm_freak> a -> b -> c = a -> (b -> c)
14:20:47 <mm_freak> so a "function of two arguments" is actually a function, which returns a function
14:20:57 <DevHC> mauke: that's what i've said
14:21:09 <mm_freak> the type doesn't tell you what 'c' is, so if c = x -> y, then suddenly you can pass three arguments
14:21:10 <joevandyk> ion: yes :(
14:21:20 <slack1256> joevandyk: as a mental model: if you have used a stack based prog lang, function application is similar
14:21:29 <mauke> DevHC: oops, missed that
14:21:33 <cicatristeza> mauke: aha, lcm is a function?
14:21:43 <ddarius> Currying is what curry does.
14:21:44 <cgroza> cicatristeza: yes.
14:21:54 <mm_freak> dainanaki: is that table expensive to compute?
14:21:59 <cicatristeza> ok
14:21:59 <cgroza> >@type lcm
14:21:59 <hydo> Is there a way to constrain a block of code or a whole program to x amount of memory?  Working on interview questions in preparation for a job and I don't want to leave anything to chance.
14:22:05 <mauke> :t lcm
14:22:06 <lambdabot> forall a. (Integral a) => a -> a -> a
14:22:19 <mm_freak> hydo: for whole programs, if you use GHC, compile with -rtsopts
14:22:20 <mauke> hydo: yes, ulimit
14:22:28 <mm_freak> then add:  +RTS -M128m
14:22:30 <mm_freak> to the command line
14:22:52 <joevandyk> slack1256: no, just c, c++, ruby, some scheme and some js
14:22:54 <mm_freak> ulimit is also a solution, if you have it
14:23:04 <ddarius> dainanaki: GHC does not handle large source files well, and likely will continue to fail to do so for the foreseeable future.
14:23:18 <hydo> mauke: duh.. of course.  Thanks.  also, mm_freak: hrm.. maybe I'll do both! hehe
14:23:25 <mm_freak> joevandyk: imagine in JS that you write all your functions with at most one argument
14:23:26 <mauke> joevandyk: funnily enough, javascript may be your best friend here
14:23:34 <slack1256> joevandyk: the forget it, after i told you, I realized it would only complicate things
14:23:38 <slack1256> *then
14:23:43 <ddarius> mauke: Not Scheme?
14:23:44 * hydo looks at joevandyk... hey, I know you.
14:23:55 <mm_freak> joevandyk: function add(x) { return function (y) { return x + y; }; }
14:24:02 <mauke> ddarius: javascript's IO system is the closest to Haskell's
14:24:04 <joevandyk> hydo: lies
14:24:05 <mm_freak> add(3)(5);
14:24:11 <hydo> joevandyk: haw haw!
14:24:35 <ddarius> mauke: ...
14:24:47 <mm_freak> mauke: how?
14:24:49 <mauke> ddarius: hmm?
14:24:55 <mauke> mm_freak: it's all callback based
14:24:57 <mauke> just like >>=
14:25:20 <mm_freak> mauke: what kind of output?  in the mainstream browsers you would use console.log for debugging
14:25:24 <cicatristeza> mauke: why does foldl lcm 1 [20..1] evaluate to 1?
14:25:41 <mauke> mm_freak: I mean XMLHttpRequest and friends
14:25:42 <slack1256> @type lcm
14:25:43 <lambdabot> forall a. (Integral a) => a -> a -> a
14:25:48 <mm_freak> cicatristeza: because [20..1] is an empty list
14:25:53 <cicatristeza> shouldnt the accumulator after step 1 be 20?
14:25:56 <donri> > [5..1]
14:25:57 <mauke> > [20 .. 1]
14:25:57 <lambdabot>   []
14:25:58 <lambdabot>   []
14:26:04 <donri> > [5,4..1]
14:26:05 <lambdabot>   [5,4,3,2,1]
14:26:13 <mm_freak> cicatristeza: if you want to count backwards, you have to give a step value:  [20, 19 .. 1]
14:26:14 <cicatristeza> mm_freak: how come? isnt it 20, 19, 18 ... 1?
14:26:26 <cicatristeza> aha ok
14:26:40 <mm_freak> cicatristeza: the step is +1 by default
14:26:56 <cicatristeza> i see
14:26:59 <cicatristeza> thank you
14:27:05 <ion> joevandyk: I can assure learning something outside the scope of CLispScript will be rewarding and it’ll also make you a better programmer in CLispScript. Although there’s the side effect of finding more annoyances and inelegance in it. :-)
14:27:11 <DanBurton> @src fromEnumTo
14:27:11 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:27:15 <mauke> > foldl lcm 1 [1 .. 20] :: Expr
14:27:16 <lambdabot>   abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (abs (...
14:27:22 <mauke> > foldl lcm 1 [1 .. 5] :: Expr
14:27:22 <cicatristeza> these higher order functions make everything so ridiculously succinct
14:27:23 <lambdabot>   abs (abs (abs (abs (abs (1 `quot` abs 1 * 1) `quot` (abs (abs (1 `quot` abs...
14:27:33 <mauke> zomg
14:27:39 <c_wraith> DanBurton: it's part of the Enum typeclass, so what it does depends on the type
14:27:46 <DanBurton> ah yes
14:27:49 <mauke> > foldl lcm 1 [2 .. 4] :: Expr
14:27:50 <lambdabot>   abs (abs (abs (1 `quot` (abs 1 `rem` abs 2) * 2) `quot` (abs 3 `rem` (abs (...
14:27:59 <mm_freak> mauke: well, that's not javascript, that's really just the browser's library
14:28:07 <ddarius> > lcm 2 3 :: Expr
14:28:08 <lambdabot>   abs (2 `quot` (abs 3 `rem` (abs 2 `rem` abs 3)) * 3)
14:28:26 <mauke> mm_freak: close enough
14:28:40 <mm_freak> mauke: also the callback is usually called asynchronously, so it's really much more of a model for haskell threads, not haskell I/O in general
14:28:48 <mauke> mm_freak: close enough :-)
14:28:49 <mm_freak> javascript has no idea of I/O
14:28:58 <mm_freak> ok =)
14:29:00 <cicatristeza> thank you all, what a helpful channel this is
14:29:06 <mauke> mm_freak: the reason you can't turn IO String into String is analogous to the reason you can't write sleep() in javascript
14:29:20 <mm_freak> mauke: you can't?
14:29:25 <slack1256> cicatristeza: hablas español verdad?
14:29:37 <mauke> mm_freak: no, all you get is setTimeout(kont, n);
14:29:59 <mm_freak> mauke: again, that's just the browser's library
14:30:04 <mauke> "just"
14:30:09 <cicatristeza> slack1256: claro que si, y vos?
14:30:13 <mauke> and in Haskell it's just System.IO
14:30:54 <mm_freak> mauke: javascript or more generally ECMA is just an imperative language with closures…  you can have a library, which gives you the usual imperative output functions
14:31:37 <mm_freak> mauke: the interpreter libraries usually have a function 'print' predefined, which writes to stdout
14:31:51 <mauke> mm_freak: yeah, but newbies usually complain about input
14:31:58 <DanBurton> mauke: well...there's The Function That Shall Not Be Named that can turn IO String into String
14:31:58 <mauke> i.e. the IO String "problem"
14:32:35 <mauke> DanBurton: and javascript allows synchronous http requests :-)
14:32:41 * slack1256 don't know about what function DanBurton is talking about
14:33:03 * DanBurton thinks its better that way :)
14:33:14 <mm_freak> mauke:
14:33:17 <mm_freak> % js -e "print(readline());"
14:33:17 <mm_freak> abc
14:33:17 <mm_freak> abc
14:33:33 <ion> @type (>>=) `asAppliedTo` (undefined :: IO String)
14:33:34 <lambdabot> forall b. IO String -> (String -> IO b) -> IO b
14:33:35 * slack1256 ignorance is a bliss
14:33:46 <ion> That’s what you should use to draw a String out of IO String.
14:33:48 <mauke> mm_freak: yes, and you can add readline and print to your Haskell as well
14:33:53 <mauke> mm_freak: just as library functions
14:34:20 <mm_freak> mauke: sure you can…  the difference is that in javascript there is nothing wrong with that =)
14:34:27 <mm_freak> in haskell you lose referential transparency
14:34:41 <ion> @type (<$>) `asTypeIn` \(<$>) -> undefined <$> (undefined :: IO String)
14:34:41 <aristid> and you need to enforce evaluation to see output
14:34:42 <lambdabot> forall b. (String -> b) -> IO String -> IO b
14:35:11 <mauke> I'm not defining an isomorphism
14:35:24 <mm_freak> aristid: that's an implementation detail and probably not true anyway, since the output forces the input
14:35:31 <mauke> it's just a useful way to think about stuff when you're already used to web programming with javascript
14:35:38 <cicatristeza> buenos noches
14:35:58 <mm_freak> mauke: don't you think that that makes do-notation even weirder?
14:36:04 <mauke> yes
14:36:12 <mauke> that's why I never start with do-notation
14:36:17 <gwern> @hoogle even
14:36:17 <lambdabot> Prelude even :: Integral a => a -> Bool
14:36:17 <lambdabot> Network.Browser data BrowserEvent ty
14:36:17 <lambdabot> Network.Browser BrowserEvent :: ClockTime -> RequestID -> String -> BrowserEventType ty -> BrowserEvent ty
14:36:50 <aristid> mm_freak: you need to force the output though.
14:37:07 <mm_freak> mauke: i start with IO using do-notation, then move on to monads without IO and finally explain IO as a monad and bring up do-notation again
14:37:11 <mm_freak> that works very well
14:37:22 <mauke> mm_freak: that didn't work at all with me
14:37:56 <mm_freak> aristid: of course something has to force the output, but once it's forced (which i'm assuming) the input is forced, too
14:38:29 <slack1256> mm_freak: i'd copy your way of teaching IO, beginners usually want a floor where to build
14:38:33 <aristid> mm_freak: yeah.
14:38:33 <joevandyk> why does this not compile?
14:38:36 <joevandyk> > take 10 (foldl1 (const id) [1..])
14:38:37 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
14:38:37 <lambdabot>    arising from a use...
14:38:42 <slack1256> maybe that's the biggest pitfall of monads tutorials
14:38:59 <joevandyk> if anything, it should never return, right?
14:39:07 <mm_freak> mauke: i tried teaching with the combinators in the beginning, but that didn't really work…  with do-notation and the explicit distinction between '<-' and 'let' it seems to work very well
14:39:19 <mm_freak> slack1256: exactly
14:39:20 <ion> joevandyk: take 10 wants an array. foldl1 … [x] returns something with the type of x.
14:39:28 <joevandyk> doh
14:39:32 <joevandyk> right
14:39:34 <mm_freak> i
14:39:36 <ion> Err, sorry. Not with the type of x.
14:39:41 <mauke> slack1256: that's exactly what I didn't like about do-notation
14:39:48 <ion> @type foldl1
14:39:49 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:40:02 <ion> Actually, yes, something with the type of x indeed in the case of fold*1. :-)
14:40:25 <slack1256> mauke: what don't you like?
14:40:48 <mauke> slack1256: that I can't build on it
14:41:06 <mauke> slack1256: it's some kind of magic where sometimes you have to use <- and sometimes it fails with mysterious type errors
14:41:21 <mauke> slack1256: and why is getchar not a function?!
14:42:12 <slack1256> mauke: hehehe, some procedures aren't definable on pure haskell (the ones who dealt with the real world for example)
14:42:15 <mm_freak> mauke: that really depends on how you present it…  my "student" could write useful programs in a day without understanding too much, what is going on under the hood…  she learns fast, because it's fun
14:42:26 <DanBurton> :t getChar
14:42:27 <lambdabot> IO Char
14:42:41 <mm_freak> mauke: you have to give a brief introduction to types and why you can pass getLine to putStrLn
14:42:54 <mauke> mm_freak: that doesn't explain anything
14:43:27 <slack1256> mauke: after all haskell is simple typed lambda calculus, which doesn't dealt with procedures(getChar), just functions
14:43:40 <mauke> slack1256: yes, so how does IO actually work?
14:43:44 <mm_freak> mauke: i can understand the perfectionism of haskellers, i myself am a perfectionist
14:44:02 <mauke> mm_freak: when I started with Haskell, I already knew Perl and OCaml
14:44:06 <slack1256> mauke: i can explain it to you simple
14:44:31 <mm_freak> mauke: and really there is nothing wrong with: "IO String is not a string, it's a procedure, which produces a string"
14:44:31 <slack1256> mauke: remember the monads laws? well IO being a monad also have those laws
14:44:37 <mauke> slack1256: wtf is a monad?!
14:44:49 <mm_freak> never mentioning monads at all
14:44:49 <mauke> mm_freak: so it's like () -> String?
14:44:54 <mauke> mm_freak: why can't I just call it then?
14:44:56 <DanBurton> well you see monads are burritos
14:45:26 <mm_freak> mauke: that question didn't pop up, because haskell is the first language of my hobby-student =)
14:45:32 <slack1256> @where monads for functional programming
14:45:32 <lambdabot> http://www.haskell.org/all_about_monads/html/
14:45:49 <mm_freak> and she understands the difference between IO procedures and functions
14:46:10 <mauke> again, OCaml: read_line : unit -> string
14:46:14 <slack1256> mauke: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
14:46:34 <slack1256> mauke: that explain "why" you would want a monad
14:46:38 <mauke> slack1256: that's crazy. you want me to read a 31 page research paper just to write hello world?
14:46:49 <mauke> this language sucks
14:46:56 <slack1256> no just the first 2 to understand why you would want a  monad
14:46:56 <mm_freak> i explained: "one key characteristic of functions is that they have a right arrow in the type…  they are values, which depend on other values, and function application is feeding those values"
14:46:57 <joevandyk> why is 'const' named the way it is?  i don't get why it's called 'constant'
14:47:04 <mauke> slack1256: I don't want a monad!
14:47:16 <mauke> joevandyk: because it produces constant functions
14:47:39 <joevandyk> mauke: uh
14:47:41 <mauke> joevandyk: a constant function is one that always returns the same value, regardless of input
14:47:48 <mauke> like f(x) = 2
14:47:49 <mm_freak> joevandyk: 'const x' is a constant function, which produces x regardless of its argument
14:47:54 <mm_freak> > const 3 5
14:47:55 <lambdabot>   3
14:47:56 <mm_freak> > const 3 7
14:47:57 <lambdabot>   3
14:48:21 <mm_freak> joevandyk: like a horizontal straight line…  think of function plots of constant functions
14:48:46 <slack1256> mauke: think this way, when you have a function "f ::  a -> a" and you want to add error posibility to it you end up having and "f :: a -> (a,error)"
14:48:59 <mm_freak> slack1256: too complicated for beginners
14:49:04 <mauke> slack1256: no, I don't
14:49:05 <DanBurton> main = putStrLn "Hello, world" -- no 31 page research papers required
14:49:16 <mauke> DanBurton: yes, but I don't understand how that works
14:49:20 <hpc> slack1256: f :: a -> Either error a
14:49:28 <mm_freak> slack1256: for efficient teaching don't talk about monads until late in your course
14:49:29 <slack1256> mauke:"if you want to have a state passed you end up witha function "f :: a -> (a,state)"
14:49:31 <hpc> slack1256: your f returns both a value and an error value
14:49:36 <mauke> slack1256: no, I don't
14:49:37 <DanBurton> mauke: you don't need to understand how the python "print()" function works in order to use it
14:49:46 <slack1256> a monad just generalizate that notion of adding a extra parameter
14:49:50 <mauke> DanBurton: yes, but I do need to understand IO to use print in Haskell
14:50:01 <mauke> slack1256: that's not an extra parameter
14:50:05 <mauke> slack1256: that's an extra return value
14:50:12 <mauke> slack1256: and wtf does that have to do with IO?
14:50:20 <mm_freak> slack1256: a state function looks different:  s -> a -> (a, s)
14:50:25 <DanBurton> mauke: In that case I would teach you magical do notation, but others here seem rather opposed to that style of teaching
14:50:38 <mm_freak> slack1256: if you want to add state to a -> a that is
14:50:39 <mauke> DanBurton: this all started because I complained about magical do notation
14:50:48 <mauke> DanBurton: because it doesn't really explain anything
14:50:55 <hpc> mm_freak: a -> s -> (a, s) -- so stateful functions curry nicely
14:50:56 <mauke> DanBurton: and I end up with mysteriously broken code
14:51:06 <mm_freak> mauke: my point is:  it doesn't have to explain anything yet
14:51:12 * slack1256 realizes sucks at teaching xD
14:51:13 <joevandyk> thanks all!  i made some progress today.
14:51:18 <joevandyk> back to drinking.
14:51:21 <hpc> lol
14:51:25 <slack1256> xD
14:51:28 <mauke> mm_freak: so I just get to stare at my broken code?
14:51:40 <slack1256> joevandyk: drink one for me
14:51:44 <joevandyk> will do
14:51:54 <mauke> btw, a major error I had back then was function parameters of type IO something
14:51:59 <DanBurton> with regards to IO, all you need to know as a beginner about magical do notation is that <- is how you "run" an IO action and bind its result
14:52:07 <mm_freak> mauke: when done properly the error messages will help your student
14:52:24 <slack1256> mauke: are you a student like me?
14:52:29 <mauke> DanBurton: but haskell is pure! it can't really run anything
14:52:34 <mm_freak> unless you get some of the "add instance for" GHC messages, which can really be confusing
14:52:41 <mm_freak> but that's not related to do-notation at all =)
14:52:55 <mauke> DanBurton: if I don't use the result, will it still run it with <-?
14:52:57 <DanBurton> mauke: well, given the fact that you can, in fact, do things with Haskell, it isn't entirely pure
14:53:01 <mauke> slack1256: no
14:53:03 <DanBurton> mauke: yes
14:53:20 <mauke> DanBurton: no, it won't
14:53:22 <DanBurton> mauke: well, assuming the do block encompassing it is run.
14:53:33 <mauke> DanBurton: const () (putStrLn "hello")
14:53:50 <mauke> now consider length [do { x <- getLine; print x }]
14:53:57 <DanBurton> main = do x <- getLine; putStrLn "Hello" -- in this case getLine *is* run
14:53:59 <mm_freak> mauke: when you teach C you don't explain pointers and low level function calling conventions to explain why a printf-based hello world works
14:53:59 <mauke> you said the <- will execute the action
14:54:06 <mauke> but *when* does that action happen?
14:54:07 <mm_freak> in haskell with do-notation it's the same
14:54:20 <mauke> DanBurton: so wtf is the difference?!
14:54:26 <DanBurton> mauke: see what I said after that. *if* the encompassing do block is run, then the <- inside will run
14:54:29 <mauke> DanBurton: and how does that interact with overall laziness?
14:54:52 <DanBurton> mauke: are you familiar with JavaScript or Python?
14:54:53 <mauke> mm_freak: wrong analogy; C doesn't have calling conventions
14:54:57 <mauke> DanBurton: no
14:55:07 <slack1256> mauke: IO makes promises it will run it before that print
14:55:11 <DanBurton> mauke: what languages can I use as an analogy?
14:55:18 <mauke> DanBurton: Perl, OCaml
14:55:18 <mm_freak> mauke: it has calling conventions, and it has to be a specific one for printf to work
14:55:21 <mauke> DanBurton: C
14:55:26 <mauke> mm_freak: no
14:55:33 <mauke> don't tell me how C works; I am a C
14:55:54 <mm_freak> mauke: then you'll know that printf can't work with stdcall calling convention
14:56:01 <mauke> C has no "stdcall"
14:56:05 <mauke> I don't even know wtf that is
14:56:18 <DanBurton> drat; not familiar with Perl or OCaml. And C isn't exactly apt for explaining such things ;)
14:56:21 <mm_freak> mauke: it's a calling convention, where the callee cleans the stack
14:56:27 <mauke> mm_freak: C has no stack
14:56:45 <DanBurton> it's the difference between defining a list with an action, and running the action found inside the list
14:56:46 <mauke> mm_freak: (this is like trying to explain Haskell in terms of STG or C--)
14:57:21 <mm_freak> mauke: well, obviously one has to know that it's not a /string/, which is passed to printf
14:57:33 <mm_freak> at least in C
14:57:35 <mauke> mm_freak: huh?
14:57:49 <mm_freak> it's a pointer to an character array
14:57:59 <mauke> no, a pointer to the first element of a character array
14:58:00 <mm_freak> s/ an / a /
14:58:12 <Nioate> what is the most advisable way to convert a lazy ByteStrings into a lazy list of strict ByteStrings, each of a size I can specify?
14:58:26 <mauke> but when starting out you can treat printf as a special form and always call it with a string literal
14:58:27 <mm_freak> whatever, i think you understand
14:58:30 <mm_freak> yeah, that's my point
14:58:44 <mauke> Nioate: you can't get the chunks but you don't get to choose the size
14:58:47 <mm_freak> when starting you can treat do-notation as a special form
14:58:49 <mauke> Nioate: er, you can*
14:59:12 <monochrom> @hoogle ByteString -> [ByteString]
14:59:12 <lambdabot> Data.ByteString group :: ByteString -> [ByteString]
14:59:12 <mauke> mm_freak: but Haskell wasn't my first language and that didn't work
14:59:12 <lambdabot> Data.ByteString inits :: ByteString -> [ByteString]
14:59:12 <lambdabot> Data.ByteString tails :: ByteString -> [ByteString]
14:59:28 <monochrom> I'll look harder
14:59:34 <Nioate> mauke: that part's kind of important in this case. the only thing I can thing of is unpacking to [Word8], splitting it, and then repacking
14:59:35 <mm_freak> mauke: it worked for me as someone coming from the C/C++ world
14:59:46 <Nioate> but I have no idea what that would do to performance
14:59:51 <mauke> mm_freak: C/C++ is boring
15:00:00 <mauke> mm_freak: you can't do much functional abstraction there
15:00:04 <mm_freak> Nioate: split the lazy bytestrings
15:00:04 <monochrom> Data.ByteString.Lazy.toChunks
15:00:24 <mm_freak> Nioate: the lazy bytestring, and then convert the individual lazy bytestrings into strict ones
15:00:34 <mauke> it's an entirely different learning curve in my case
15:00:40 <mauke> my first lisp program was "hello world"
15:00:46 <Nioate> mm_freak: is there a lazy -> strict function?
15:00:50 <mm_freak> mauke: i wasn't a functional programmer before haskell
15:00:53 <mauke> my second lisp program was a macro to transform infix expressions into prefix form
15:01:06 <mauke> including a recursive-descent parser and local submacros
15:01:07 <mm_freak> Nioate: no, but there is toChunks and B.concat
15:02:00 <mm_freak> mauke: before haskell i was a very imperative programmer using C++ style OOP
15:02:08 <mauke> IIRC when I started learning Haskell I'd already written a sort-of cooperative threading library in OCaml
15:02:21 <mauke> based on callbacks and select()
15:02:37 <mm_freak> doesn't ocaml have lightweight threads?
15:02:47 <mauke> and I knew how lambda calculus translates directly into perl
15:02:56 <Nioate> mauke, mm_freak: thanks for the help
15:03:10 <mauke> mm_freak: dunno, I just wanted to try it
15:03:22 <mm_freak> i see
15:04:03 <slack1256> anyone here with luck about haskell on ARM?
15:04:05 <mm_freak> anyway, i tried both approaches to teaching IO, and starting with do-notation worked better for me
15:04:07 <ddarius> There are reasons why you may want to make your own (cooperative) threading library even when (lightweight) threads are provided.
15:04:16 <mm_freak> slack1256: wanna write android apps, huh? ;)
15:04:37 <slack1256> mm_freak: nooooo! i wanna a raspberry pi !
15:04:40 <mm_freak> ddarius: because cooperative is faster?
15:04:54 <mauke> mm_freak: no, because cooperative threads can't fuck you over
15:05:08 <mauke> mm_freak: there's a single program counter
15:05:09 <ddarius> mm_freak: No.
15:05:25 <mm_freak> ok, but then you're really just writing coroutines, if you use the cooperativity for control
15:05:28 <slack1256> mm_freak: there are people writing haskell apps for android? :O
15:05:56 <mm_freak> slack1256: unlikely, because we don't have a compiler, but if you're interested in that, you should talk to Cale
15:06:05 <ddarius> You can easily write a cooperative threading library with coroutines.  You just systematically coroutine to a scheduler.
15:06:44 <mm_freak> mauke: it happened to me a lot in C that threads made me cry
15:06:48 <mm_freak> in haskell it never happened to me
15:06:59 <mm_freak> even with the preemptive scheduling
15:07:04 <ddarius> Admittedly, there are a variety of things that are called "coroutines" with varying amounts of power.
15:07:04 <mauke> for me it's the other way around
15:07:12 <mauke> but only because I never used threads in C
15:07:20 <mm_freak> hehe
15:07:43 <mm_freak> ddarius: isn't there only one kind of general coroutines?  routines, which can yield to other routines?
15:07:55 <def-lkb> slack1256: I once found this article about GHC on ARM mobile platforms http://www.alpheccar.org/content/94.html
15:07:58 <mm_freak> everything else is just a special case of that
15:08:28 <ddarius> mm_freak: "routines, which can yield to other routines" is hardly a clear and unambiguous definition.
15:08:44 <mm_freak> ddarius: true
15:08:54 <mauke> functions, which can return to other functions
15:09:03 <mauke> basically: functions
15:09:07 <mm_freak> but it really just sounds like CPS
15:09:13 <slack1256> def-lkb cool, thanks i'll read.
15:15:49 * hackagebot mysnapsession 0.4.1 - Sessions and continuations for Snap web apps  http://hackage.haskell.org/package/mysnapsession-0.4.1 (ChrisSmith)
15:16:02 <mm_freak> UH!
15:16:27 <mm_freak> seems like snap has just got the feature, which i was missing in yesod so much!
15:16:34 <hpaste_> angstrom pasted “looking for some critique” at http://hpaste.org/52383
15:17:34 <KirinDave> mm_freak: Which one is that?
15:17:42 <mm_freak> KirinDave: continuations
15:18:30 <KirinDave> mm_freak: Like, arc style?
15:18:44 <mm_freak> KirinDave: like in racket's web framework or ur/web
15:18:44 <KirinDave> mm_freak: Or whatever that smalltalk continuation-based webserver.
15:18:55 <mm_freak> no, not smalltalk
15:20:19 <KirinDave> I really can't believe how much play Ur/web has here. It's kind of stunning
15:20:35 <KirinDave> mm_freak: Seaside
15:21:22 <mm_freak> ur/web seems to be a great language, but for my taste it's too much tied to web development…  also i haven't found any useful emacs modes for it
15:21:49 <mm_freak> also it's slightly confusing with its inline XML syntax
15:21:58 <KirinDave> mm_freak: Well and also its security claims are generally considered spurious by the security community that has examined it.
15:22:12 <mm_freak> no idea there
15:22:21 <mm_freak> just had a brief look into it
15:25:58 <alpounet> has the security community examined yesod/snap ?
15:26:11 <KirinDave> alpounet: To an extent
15:26:23 <c_wraith> really?
15:26:24 <KirinDave> alpounet: Yesod and Snap don't make quite so many claims
15:26:37 <alpounet> how are they, security-wise ?
15:26:41 * KirinDave shrugs
15:26:47 <c_wraith> I mean.  yeah.  They have no real security claims, aside from "don't have internal buffer overflows"
15:26:48 <KirinDave> Most people don't understand what web security means these days
15:26:57 <KirinDave> c_wraith: Right. That's not so hard.
15:27:19 <KirinDave> Ur/web does more and claims more, so it got more scrutiny.
15:27:19 <mm_freak> c_wraith: i can only speak for yesod, and its security properties look very good
15:27:39 <mm_freak> KirinDave: it does more in what sense?
15:28:00 <MdxBhmt> while we are at yesod, can i step in and do a question? ;p
15:28:15 <mm_freak> MdxBhmt: you can perform it ;)
15:28:49 <MdxBhmt> mm_freak: i'm trying the 5 minutes tutorial on windows, with no sucess...
15:29:02 <mm_freak> MdxBhmt: what's wrong?
15:29:08 <alpounet> MdxBhmt, you can even step in when people aren't talking about it! :P
15:29:43 <MdxBhmt> mm_freak:  well, I followed the steps, it compiles and run, but, can't acess it
15:29:45 <KirinDave> mm_freak: Ur/web tries to do more, security wise.
15:30:01 <mm_freak> MdxBhmt: what happens when you try?
15:30:09 <MdxBhmt> alpounet: D:
15:30:23 <MdxBhmt> Devel application launched, listening on port 3000 , the page 404
15:30:41 <mm_freak> KirinDave: i don't know how far ur/web goes
15:30:43 <MdxBhmt> i guess if i do netstat, i should see some app using it, no?
15:30:50 <mm_freak> KirinDave: care to give some examples?
15:31:18 <mm_freak> MdxBhmt: if you get a 404 then at least the framework works, but your application is probably broken =)
15:31:41 <mm_freak> MdxBhmt: check your routes
15:31:41 <MdxBhmt> wait, lol
15:31:43 <MdxBhmt> not a 404
15:31:54 <MdxBhmt> 'cannot display a website'
15:32:06 <mm_freak> try to get a more useful error message
15:32:18 <c_wraith> what the heck does that error mean?  probably a browser error saying it couldn't make a tcp connection?
15:32:28 <mm_freak> and netstat-check that the webserver is indeed running
15:32:51 <MdxBhmt> c_wraith:  probably
15:33:25 <mm_freak> note that compiled yesod applications block the terminal, so once your program is started you shouldn't get a prompt back right away
15:33:30 <MdxBhmt> and yeah, nothing with 3k on netstat
15:34:05 <MdxBhmt> mm_freak:  yes, yesod is still running
15:34:17 <mm_freak> and it's not listening on any ports?
15:34:32 <MdxBhmt> not on 3k, at least
15:34:42 <mm_freak> write a small dummy application in GHCi, which sets up a listening socket
15:34:47 <mm_freak> on port 3000
15:35:01 <MdxBhmt> using network.sockets?
15:35:22 <mm_freak> no
15:35:25 <mm_freak> :m Network
15:35:33 <mm_freak> listenOn (PortNumber 3000)
15:35:35 <mm_freak> that's it
15:35:41 <MdxBhmt> ah, ok D:
15:35:43 <mm_freak> that should make it listen on port 3000
15:36:27 <MdxBhmt> should i get the ghci prompt imediatly?
15:36:33 <mm_freak> yes
15:36:41 <mm_freak> without errors, of course
15:36:49 <mm_freak> then without quitting the prompt look into your netstat
15:36:56 <mm_freak> GHC should be listening on port 3000
15:39:00 <antihoax> ahah
15:39:05 <MdxBhmt> ok, there is a problem here
15:39:05 <antihoax> webbrowser in ghc ?
15:39:27 <mm_freak> antihoax: test server in GHCi
15:39:32 <antihoax> :)
15:39:36 <antihoax> what does it serve?
15:39:51 <mm_freak> nothing…  it doesn't accept connections…  it just listens to show up in netstat =)
15:40:01 <antihoax> hm
15:40:01 <MdxBhmt> ah, LOL
15:40:08 <MdxBhmt> netstat -a gave me a solution
15:40:10 <MdxBhmt> o.O
15:40:18 <mm_freak> MdxBhmt: it's listening on port 4000?
15:40:21 <mm_freak> ;)
15:40:23 <MdxBhmt> no
15:40:44 <mm_freak> what was the problem?
15:40:46 <MdxBhmt> TCP    [::]:3000              Bhmt:0                 LISTENING
15:40:46 <MdxBhmt> TCP    [::]:3000              Bhmt:0                 LISTENING
15:40:46 <MdxBhmt> TCP    [::]:3000              Bhmt:0                 LISTENING
15:40:50 * hackagebot kmeans-vector 0.1.1 - An implementation of the kmeans clustering algorithm based on the vector package  http://hackage.haskell.org/package/kmeans-vector-0.1.1 (AlpMestanogullari)
15:40:51 <MdxBhmt> port 0 o.O
15:41:07 <mm_freak> MdxBhmt: yes, it's listening on port 3000
15:41:12 <mm_freak> at address ::
15:41:18 <mm_freak> which is just IPv6 for localhost
15:41:22 <MdxBhmt> hmmmm
15:41:22 <mm_freak> no
15:41:26 <mm_freak> it's IPv6 for everything
15:41:32 <mm_freak> it listens on every address
15:41:40 <mm_freak> ::1 would be localhost
15:41:47 <monochrom> but does it listen to IPv4 too?
15:41:56 <mm_freak> monochrom: it should
15:42:45 <fabbomelker_> hey I have  a question
15:42:46 <MdxBhmt> ok, so 127.0.0.1 (or localhost) is ipv4, and for some reason the local adress is on ipv6?
15:43:03 <mm_freak> MdxBhmt: no, it listens on all addresses
15:43:11 <mm_freak> try to connect to ::1 explicitly in your browser
15:43:12 <antihoax> you can also do lsof -i and lsof -itcp
15:43:22 <fabbomelker_> how can create an object of a data type?
15:43:31 <monochrom> depends on the data type
15:43:35 <mm_freak> antihoax: he can't, it's windows
15:43:46 <mm_freak> windows has no useful command line tools =)
15:44:07 <mm_freak> fabbomelker_: "object"?
15:44:08 <MdxBhmt> too bad ;(
15:44:20 <monochrom> just pretend s/object/value/
15:44:27 <MdxBhmt> ::1 directly in browser is a no-no
15:44:37 <fabbomelker_> yeah, perhaps bad choice of word
15:44:58 <hpc> firefox thinks i am trying to use port 1
15:45:06 <fabbomelker_> data Tree a = Leaf a | Branch (Tree a) (Tree a)
15:45:06 <MdxBhmt> yes
15:45:17 <c_wraith> huh.  did ghc 7.0.4 fix anything IO manager related?
15:45:29 <mm_freak> MdxBhmt: try connecting to http://[::1]:3000/
15:45:34 <c_wraith> 'cause I just found a trivial crash for the IO manager in 7.0.3
15:45:40 <monochrom> then try these: Leaf "hello", Branch (Leaf "right") (Leaf "left")
15:45:46 <MdxBhmt> yes, that works
15:45:46 <c_wraith> (It's dumb code, but it still shouldn't crash the IO manager)
15:45:50 <MdxBhmt> ;D
15:46:08 <mm_freak> MdxBhmt: ok, then windows does not automatically map IPv4 requests to IPv6
15:46:11 <mm_freak> windows is stupid
15:46:23 <MdxBhmt> lol
15:46:28 * monochrom guessed right :)
15:46:47 <monochrom> otoh I don't know what to do
15:48:19 <monochrom> oh, it may be a known bug in the network package and it may have been fixed in HEAD already. I'll find you the thread
15:48:31 <MdxBhmt> the funny thing is that doing bhmt:0 was diferent than  http://[::1]:3000/, they maped diferent runing pages
15:49:48 <fabbomelker_> but I wanna use a function defined on the the data Tree a
15:49:58 <c_wraith> still crashes on 7.2.1
15:51:15 <MdxBhmt> mm_freak:  Thank you, now i have some means to see the page, ;D
15:51:44 <mm_freak> have fun =)
15:51:52 <MdxBhmt> I guess I should do aticket about it
15:52:15 <fabbomelker_> monochrom, how can I use the data from your defintion?
15:52:39 <monochrom> MdxBhmt, mm_freak: http://www.mail-archive.com/haskell-cafe@haskell.org/msg93359.html
15:54:24 <mm_freak> monochrom: thanks
15:54:36 <mm_freak> MdxBhmt: you can use warp's runSettings instead of run
15:54:50 <mm_freak> you can specify a different host to listen on that way
15:55:16 <c_wraith> huh.  I can't reproduce this with simpler code...
15:55:47 <monochrom> fabbomelker_: http://www.vex.net/~trebla/haskell/testbed.cgi
15:55:53 <mm_freak> MdxBhmt: runSettings (defaultSettings { settingsHost = "127.0.0.1" }) app
15:56:07 <mm_freak> that makes it listen on host 127.0.0.1 explicitly, forcing it to use IPv4
15:56:16 <MdxBhmt> I see, solves it all
15:58:02 <mm_freak> you'll have to use toWaiApp with runSettings instead of just 'warp'
16:06:39 <kamaji> How do I do iterations of >>?
16:06:47 <kamaji> like I want (foo >> foo >> foo) n times
16:06:58 <JoeyA> repeat
16:07:09 <JoeyA> err
16:07:12 <JoeyA> replicateM
16:07:18 <JoeyA> (replicateM_, for this case)
16:07:50 <JoeyA> > kamaji: e.g. replicateM_ 5 (putStrLn "Hello world")
16:07:52 <lambdabot>   Not in scope: `kamaji'
16:08:03 <fabbomelker_> thanks for the link. But from a data type like Tree, I can I use that to build a tree?
16:08:09 <kamaji> oh ok
16:08:10 <kamaji> thanks!
16:08:47 <JoeyA> replicateM (without the underscore) returns a list of the result of each action.
16:08:53 <kamaji> oh, the one with _ gives no result?
16:08:57 <JoeyA> right
16:08:57 <Cale> yeah
16:08:59 <kamaji> damn, you win :p
16:09:44 <Cale> kamaji: It's rather nice how these things can be defined in a library rather than needing to be built-in language features  :)
16:10:29 <Cale> We also have mapM and forM (which just has the arguments flipped), which act like a for-each loop over a list.
16:10:39 <JoeyA> e.g. for i from 1 until equal to 10 do begin
16:10:52 <Cale> forM [1..10] $ \i -> do ...
16:10:57 <JoeyA> (making fun of overly verbose 'for' syntax in many languages)
16:11:37 <MdxBhmt> mm_freak:  It didn't worked, still only via [::1]
16:11:43 <Cale> for i from 1 by 1 until equal to 10 do begin
16:11:49 <Cale> ;)
16:12:06 <JoeyA> for i from 1 by 1 until equal to 10 step 1 do begin
16:12:15 <JoeyA> (that way, you have to ask what that "by 1" is for)
16:12:26 <Cale> Wait, we need both? :)
16:12:35 <Cale> haha
16:12:51 <kamaji> wait, is that supposed to compile?
16:12:54 <JoeyA> Any time anyone tries to ask what "by 1" does, don't give them a straight answer.
16:13:03 <kamaji> in haskell I mean
16:13:07 <Cale> kamaji: Is what supposed to compile?
16:13:12 <kamaji> the joke for
16:13:13 <JoeyA> @hoogle for
16:13:13 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
16:13:13 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
16:13:13 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
16:13:27 <Cale> kamaji: We've been joking about some imperative languages' syntax for loops
16:13:38 <JoeyA> Define enough functions and enable enough extensions, and maybe it will.
16:13:42 <kamaji> lol
16:13:47 <Cale> kamaji: But the  forM [1..10] $ \i -> do ...  thing is valid
16:14:13 <JoeyA> > forM [1..10] $ \i -> [i, i*i]
16:14:14 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,100],[1,2,3,4,5,6,7,8,81,10],[1,...
16:14:24 <rwbarton> I don't know, this "240 FOR X := 1 TO 5
16:14:29 <rwbarton> " seems to compile in Haskell just fine.
16:14:33 <Cale> lol
16:14:38 <Cale> yeah
16:15:03 <Cale> http://hackage.haskell.org/packages/archive/BASIC/0.1.5.0/doc/html/Language-BASIC.html
16:16:17 <JoeyA> I prefer to use languages that let me either 1) Shoot myself in the foot, or 2) Launch missiles
16:16:22 <JoeyA> Preferably not both
16:16:50 <JoeyA> (that's what C++11 tries to do)
16:16:55 <kamaji> Launch missiles into your foot?
16:17:28 <JoeyA> http://hackage.haskell.org/package/acme-missiles
16:18:50 <kamaji> installed
16:19:06 <JoeyA> lol
16:19:51 <mm_freak> MdxBhmt: note you have to specify the port number, too
16:19:53 <mm_freak> using settingsPort
16:26:19 <MdxBhmt> mm_freak: ouch, now i know i'm doing something wrong ,but for now i'm going to have dinner then dig in
16:26:58 <c_wraith> huh.
16:27:14 <c_wraith> This crash I have found is triggered by passing a large enough number to threadDelay
16:27:15 <c_wraith> nice
16:27:28 <c_wraith> (on 64-bit os x)
16:32:10 <jnhnum1> is there any way of passing a do expression as an argument to a function, as I'm trying to do in this sample code: http://hpaste.org/52385
16:32:28 <Axman6> jnhnum1: foo $ do ...
16:32:47 <jnhnum1> oh do you need the $ sign?
16:32:55 <Axman6> so, in that case, replicateM_ 4 $ do ...
16:32:56 <Axman6> yeah
16:33:07 <jnhnum1> right...ok thanks
16:33:14 <c_wraith> $ is just an infix operator, nothing special
16:33:16 <Axman6> not quite sure why you need to do that, but that does fix it =)
16:33:30 <MdxBhmt> it's like a ( ) around
16:33:34 <c_wraith> do blocks are allowed at certain points in the syntax.  after an infix operator is one of them
16:33:50 <c_wraith> in the middle of a chain of function applications is not one
16:34:30 <jnhnum1> ah ok
16:37:28 <monochrom> > id (do { x <- [1,2,3]; return (x-1) })
16:37:28 <lambdabot>   [0,1,2]
16:37:55 <monochrom> hmm, after an infix operator? :)
16:38:06 <monochrom> > [3,1,4] ++ do { x <- [1,2,3]; return (x-1) }
16:38:08 <lambdabot>   [3,1,4,0,1,2]
16:38:12 <monochrom> \∩/
16:38:51 <angstrom> http://hpaste.org/52383 anyone? :-) what that does is, determining the type of an integer constant, whereby the parsed representation (dec vs oct or hex (for which I use `Which')) dictates the conversion rule. problem is, it seems a little convoluted to me, with the multiple lookups and Maybes..
16:39:07 <Jafet> But $ is more magic
16:40:27 <Twey> angstrom: maybe Nothing (convert n) (lookup t ranges) = lookup t ranges >>= convert n
16:40:45 <Twey> Try to avoid fromJust
16:40:50 * hackagebot HandlerSocketClient 0.0.4 - Haskell implementation of a HandlerSocket client (API).  http://hackage.haskell.org/package/HandlerSocketClient-0.0.4 (XingboWu)
16:42:39 <angstrom> Twey: well. the line with fromJust is the one that particularly bugs me
16:42:41 <Jafet> data What = Int Int | Word Word | Integer Integer
16:44:05 <Jafet> If fromJust bugs you, don't use it
16:44:09 <c_wraith> does 100000001000083 mean anything to anyone?
16:44:25 <c_wraith> it's the highest number I can pass to threadDelay on OS X without it crashing...
16:45:01 <Jafet> > showHex 100000001000083 []
16:45:02 <lambdabot>   "5af310898293"
16:45:19 <geheimdienst> > maxBound :: Int
16:45:20 <lambdabot>   9223372036854775807
16:45:24 <geheimdienst> :t threadDelay
16:45:25 <Jafet> It's the last 5af3 number, probably
16:45:25 <lambdabot> Not in scope: `threadDelay'
16:45:36 <angstrom> Jafet: I "know", that the lookup in line 47 will always yield a Just. so maybe I should replace the lookup
16:45:45 <c_wraith> ooh, it's non-deterministic
16:45:48 <geheimdienst> afaik threadDelay takes an Int (not Integer or anything) ...
16:45:57 <c_wraith> sometimes it crashes with 100000001000084, sometimes it doesn't
16:46:05 <c_wraith> geheimdienst: 64-bit platform
16:46:51 <incluye> > (undefined,1) == (undefined,2)
16:46:52 <lambdabot>   *Exception: Prelude.undefined
16:46:57 <Twey> angstrom: Looks like you can do: flip find ts $ \t -> fromMaybe False $ lookup t ranges >>= Just . (n <)
16:47:21 <c_wraith> Twey: (>>= return) usually always means "I forgot about fmap"
16:47:21 <tristes_tigres> Any idea when the Haskell Platform is due? The one which had been announced to have been realeased in June?
16:47:29 <Twey> c_wraith: Point
16:47:39 <incluye> > fromJust $ Just 3
16:47:40 <lambdabot>   3
16:47:43 <Twey> angstrom: Looks like you can do: flip find ts $ \t -> fromMaybe False . fmap (n <) $ lookup t ranges
16:47:46 <incluye> WHOA
16:48:25 <c_wraith> > fromJust Nothing
16:48:26 <lambdabot>   *Exception: Maybe.fromJust: Nothing
16:48:31 <Twey> angstrom: Looks like you can do: flip find ts $ fromMaybe False . fmap (n <) . flip lookup ranges
16:48:37 <incluye> > fromMaybe 1 Nothing
16:48:37 <lambdabot>   1
16:48:43 <angstrom> Twey: >:D
16:49:07 <Twey> Add or remove flips according to taste
16:49:12 <incluye> til you can "get" monadic values "out" of the monad
16:49:15 <c_wraith> > fromMaybe 1 (Just 4)
16:49:16 <lambdabot>   4
16:49:28 <Twey> incluye: Being a monad is irrelevant here
16:49:44 <incluye> and there's another thing I've learned
16:50:16 <Jafet> @hoogle out.of
16:50:17 <lambdabot> No results found
16:50:20 <Jafet> @quote out.of
16:50:21 <lambdabot> monochrom says: yeah, get out of Turing tarpit, provable termination, only to get into Gödel tarpit
16:50:33 <monochrom> hehe
16:50:42 <monochrom> @quote monochrom IO
16:50:42 <lambdabot> monochrom says: How do I extract the IO out of IO String?
16:50:45 <geheimdienst> > maxBound ::Double
16:50:46 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
16:50:46 <lambdabot>    arising from a use o...
16:50:47 <monochrom> that one :)
16:50:47 <MdxBhmt> @quote lambdabot
16:50:48 <lambdabot> lambdabot says: I know nothing about comprehending.
16:50:48 <incluye> heh
16:51:02 <geheimdienst> > 100000001000084 :: Double
16:51:03 <lambdabot>   1.00000001000084e14
16:51:09 <geheimdienst> > 100000001000099 :: Double
16:51:10 <lambdabot>   1.00000001000099e14
16:52:19 <Jafet> > log 53 / log 2 / log 10
16:52:20 <lambdabot>   2.4876042461975634
16:52:37 <Jafet> > 53 / (log 10 / log 2)
16:52:38 <lambdabot>   15.954589770191003
16:52:46 <c_wraith> Now, to remember my ghc trac credentials..
16:53:07 <geheimdienst> > 100000001000084 / 1000000.0
16:53:08 <lambdabot>   1.00000001000084e8
16:54:11 <c_wraith> yay, I remembered
16:54:40 <incluye> mappend = "an associative operation"
16:54:42 <incluye> nice
16:54:56 <geheimdienst> c_wraith: i have no idea really :) as far as i can tell, threadDelay uses registerTimeout in GHC.Event.Manager, which uses a PSQ (some priority queue thing). the time in microseconds is divided by 1000000.0 and used as the Prio in the PSQ, which is a synonym for Double
16:55:02 <ion> mappend = (const . const) "an associative operation"
16:55:25 <ddarius> :t const . const
16:55:26 <lambdabot> forall b a b1. a -> b -> b1 -> a
16:57:01 <incluye> :t const . const . const
16:57:02 <lambdabot> forall b b1 a b2. a -> b -> b1 -> b2 -> a
16:57:03 <geheimdienst> incluye: yes, the haddocks are often in a pretty sad state :( your best bet is to google around. wikibooks, the haskell wiki, and RWH are often helpful
16:57:09 <Twey> :t const const const
16:57:10 <lambdabot> forall a b. a -> b -> a
16:57:16 <monochrom> :t asTypeOf
16:57:17 <lambdabot> forall a. a -> a -> a
16:57:21 <Twey> const const const is less fun than fmap fmap fmap
16:57:26 <c_wraith> I dunno.
16:57:41 <incluye> :t fmap fmap fmap
16:57:42 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:57:50 <c_wraith> I think the fact that const is an eigenfunction of "self-application twice" is kinda handy :)
16:57:58 <dylukes> what?
16:57:58 <c_wraith> well.  not handy.  but maybe neat.
16:58:01 <dylukes> I still don't quite get fmap fmap fmap
16:58:03 <dylukes> :t fmap fmap
16:58:03 <incluye> > asTypeOf 1 1.0
16:58:04 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
16:58:04 <lambdabot>   1.0
16:58:07 <monochrom> instance Monoid a where mappend = asTypeOf
16:58:42 <dylukes> :t (:.)
16:58:43 <lambdabot> Not in scope: data constructor `:.'
16:58:52 <hpc> :t (.:)
16:58:53 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:59:49 <incluye> @bf ++++
16:59:49 <lambdabot>  Done.
16:59:51 <incluye> Huh
17:02:28 <heatsink> Do you mind if I ask a question about novice programmers?
17:02:46 <heatsink> It's not haskell-related...
17:02:50 <monochrom> I don't mind
17:05:01 <incluye> so I'm trying to build lambdabot and it can't find "happy", so I did cabal install happy-1.18.6, but lambdabot still won't install because it apparently can't find happy
17:05:11 <incluye> "cabal info happy" says that the version I have installed is "unknown"
17:05:20 <heatsink> I've noticed a recurring programming mistake.  They encode some piece of data using a data structure.  In the data structure, they include fields that don't correspond to the meaning of the data.
17:05:21 <monochrom> ~/.cabin/bin
17:05:31 <heatsink> For example, they want a linked list of X
17:05:38 <heatsink> so they add a "next" field to X
17:05:48 <monochrom> sorry, ~/.cabal/bin
17:06:07 <incluye> yep, it's in there
17:06:15 <monochrom> add to PATH
17:06:34 <hpc> heatsink: are you noticing this in C?
17:06:46 <heatsink> In c++, hpc
17:06:49 <hpc> ah
17:06:58 <monochrom> when I was a kid, I did that too.
17:07:06 <MdxBhmt> that's in C too, in this case
17:07:14 <hpc> maybe this person doesn't want to have to deal with templates?
17:07:20 <companion_cube> heatsink: so what ?
17:07:22 <heatsink> Actually, I've seen it in both C and C++
17:07:52 <companion_cube> if your data is going to be in only one list, and you don't want to deal with deallocation of list nodes...
17:08:02 <hpc> C isn't good at the kind of polymorphism that lets you deal with linked lists easily, and C++'s abstraction is so nasty you might as well not bother
17:08:35 <incluye> monochrom: thanks
17:08:52 <heatsink> One problem is that it's harder to reason about the code.  For example, you can't just decide whether your struct Person is valid.  You have to decide whether it's valid with respect to the context where it's being used.  Sometimes it belongs in a list, sometimes it doesn't.
17:09:00 <monochrom> later, I was taught lisp, and also how it represented lists. then I knew I had two options, not just one.
17:09:04 <heatsink> Makes debugging harder.
17:09:43 <heatsink> Another problem is that sometimes it leads to more complicated algorithms, because having only one list pointer means you have to take your object out of the input list before putting it into hte output list
17:10:05 <Twey> heatsink: They do it because it's less work in the short term
17:10:19 <Twey> You don't have to refactor your algorithms to deal with the extra layer
17:10:26 <lucca> it's still very common practice for a number of languages
17:10:33 <lucca> especially in C
17:10:36 <Twey> Yeah
17:10:43 <heatsink> I suspect there's more to it than that.
17:11:01 <lucca> the BSD queue header is not universally well liked; next pointers in struct really are shorter and simpler for a wide array of cases
17:11:05 <geheimdienst> a case expression like "something >>= case of ..." as sugar for ">>= (\x -> case x of ...)" -- is that available in ghc yet? some extension maybe?
17:11:25 <monochrom> to some extent, separation of concerns is taught not born. only thing you can do: teach them the other way
17:11:51 <companion_cube> alo, next ppointers in the structure is faster
17:11:57 <Twey> geheimdienst: Not yet
17:12:01 <hpc> geheimdienst: just proposed
17:12:04 <Twey> We only thought it up a few months ago :þ
17:12:05 <companion_cube> also*
17:12:09 <pikhq> companion_cube: Also premature optimization.
17:12:40 <monochrom> but this case is miniscule when compared to: in C++, in a class for complex numbers, in the default constructor, ask the user for input.
17:12:41 <heatsink> I _think_ they're not conceptualizing the idea of a one-to-one correspondence between mathematical objects and states of memory.
17:12:46 <companion_cube> imho the very good point in this case is that it siplifis allcation
17:12:58 <companion_cube> simplifies allocation
17:13:07 <geheimdienst> okay, thanks guys :) i just thought maybe it's already in. it was discussed on -cafe about 2 years ago. http://haskell.org/pipermail/haskell-cafe/2009-November/068695.html
17:13:13 <lucca> come to think of it, queue.h actually ends up putting the pointers in-struct as well
17:13:23 <Twey> geheimdienst: Wow, really?
17:13:25 <c_wraith> ticket submitted.  Not my problem anymore! http://hackage.haskell.org/trac/ghc/ticket/5544
17:13:25 <incluye> What do you folks make of this error? https://gist.github.com/1274408
17:13:29 <Twey> Okay, I sit corrected
17:13:38 <heatsink> companion_cube: It's a valid optimization, but you should be aware that it's an optimization.
17:13:54 <companion_cube> true
17:14:05 <geheimdienst> Twey: *shrug* apparently. maybe it's a recurring thing :)
17:14:23 <c_wraith> incluye: that's crazy.  What version of ghc, and how did you install it?
17:14:27 <heatsink> companion_cube: In particular, you should be able to reason about the injection from the objects you want to describe to the data you use to describe it.
17:14:28 <monochrom> in fact, many teachers and books teach linked list as exactly "struct PersonList { name; phone; next }"
17:14:28 <Saizan> i've seen case of proposals since ghc 6.4.2
17:14:30 <companion_cube> but it's not necessarily premzature optimization
17:14:42 <companion_cube> -z
17:14:48 <heatsink> companion_cube: I think they're not even aware they should be doing that.
17:14:49 <Saizan> (which is when i started using haskell)
17:15:38 <geheimdienst> "ok guys, it's time for our yearly discussion why there is no split function in base. remember to bring megaphones"
17:15:47 <heatsink> True, monochrom
17:15:51 * monochrom brings popcorns
17:16:09 <quackquack> Is their a type signature that can match any function
17:16:14 <heatsink> a
17:16:15 <companion_cube> anyway C should not be usd to write regular programs, only high performance stuff
17:16:17 <heatsink> :t undefined
17:16:18 <lambdabot> forall a. a
17:16:20 <Jafet> geheimdienst: it's like the Matrix
17:16:42 <tristes_tigres> forall a.a == a ?
17:16:49 <Jafet> forall a b. a -> b
17:17:11 <incluye> @hoogle <*>
17:17:11 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
17:17:19 <monochrom> forall a. a  matches all functions. it matches more, but all the better
17:17:20 <heatsink> tristes_tigres, it's common to omit the "forall ..." part
17:17:29 <tristes_tigres> monochrom: and what is the better way to define the linked list ?
17:17:40 <incluye> @hoogle <$>
17:17:40 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
17:17:57 <heatsink> tristes_tigres, struct PersonList {Person *person; PersonList *next;}
17:19:00 <monochrom> struct LinkedList { ListNode *first; ListNode *last; }; struct ListNode a { a *datum; ListNode *next; }
17:19:07 <Jafet> struct List { void *car, *cdr; };
17:19:49 <tristes_tigres> heatsink: that way seems more harmonious with recursive way of thinking. Is it alsways better?
17:19:54 <monochrom> "better" as in separate concerns are separated
17:20:11 <heatsink> The "bad" design adds the requirement that all lists must be disjoint, globally.  Global properties are bad for modular design.
17:20:16 <Jafet> "better" as in you can upgrade the shared library
17:20:33 <heatsink> It might be a valid optimization if you know what your ENTIRE program will do.
17:21:03 <Jafet> Are there haskell programs for which there is no one that knows what the entire program does?
17:21:22 <tristes_tigres> Jafet: all of them ? :)
17:21:47 <Jafet> I like to think that I know what my programs do
17:22:01 <companion_cube> heatsink: or if the list is just a part of another structure
17:22:02 <tristes_tigres> Jafet: so do we all, so do we all
17:22:20 <Jafet> @quote what.it.means
17:22:21 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
17:22:21 <lambdabot> just don't know what it means.
17:23:44 <companion_cube> :D
17:23:46 <mm_freak> i don't know all of what my programs do…  couldn't even tell in which language the RTS was written
17:23:49 <MdxBhmt> autrijus should just blame aliens
17:23:56 <tristes_tigres> heatsink: Ah, so you're saying that the recursive definition of list allows two different lists to share a sublist?
17:24:18 <heatsink> Both definitions are recursive
17:24:25 <companion_cube> the problem with C is that you have to kkeep track of memory
17:24:32 <companion_cube> -k
17:24:34 <heatsink> The definition that separates the list type form its contents type allows an object to be in two different lists
17:24:38 <mm_freak> Jafet: could you tell me with certainty when your program is going to release its allocated memory?
17:24:45 <companion_cube> so, shared, immutable lists are painful
17:24:54 <heatsink> > let {x = 1; y = 2; z = 3; list1 = [y, x]; list2 = [y, z]} -- y is in 2 lists
17:24:54 <lambdabot>   not an expression: `let {x = 1; y = 2; z = 3; list1 = [y, x]; list2 = [y, z...
17:24:59 <mm_freak> companion_cube: it's not the problem, which is the problem…  it's the solution, which is the problem
17:25:02 <mm_freak> ;)
17:25:04 <Jafet> mm_freak: memory? What's that?
17:25:20 <mm_freak> Jafet: that stuff that even haskell programs have to use =)
17:25:38 <Jafet> No, it's the haskell program interpreter that uses memory!
17:25:58 <monochrom> define "know what the entire program does". I'm serious. suppose I write a program to find a non-trival zero of the Riemann zeta function with real part not 1/2. and we prove it correct, if there is such a zero, it terminates; if there is no such zero, it goes on forever. do you now "know what this program does"? you could say yes, you know this program is about Riemann blah blah blah. but you could say no, you don't even kno
17:25:58 <monochrom> w whether this program terminates or not. so, what counts as "know what the program does"?
17:25:59 <MdxBhmt> electricity?
17:26:06 <mm_freak> Jafet: i'll take that as a "no" ;)
17:26:36 <Jafet> mm_freak: ok fine, go ask the same question of dons
17:27:03 <tristes_tigres> monochrom: you know what it does by intention, but ot bey extension?
17:27:34 <mm_freak> Jafet: when i was a beginner i didn't even know the program actually processes the command line arguments without me using getArgs
17:27:50 <MdxBhmt> what it apears to do is not entirely what the program does
17:27:54 <mm_freak> in haskell there is more to knowing what's going on that to know what the code does
17:28:02 <Jafet> monochrom: don't be silly, we all know it's equivalent to ⟂
17:28:27 <Jafet> mm_freak: oh, I didn't notice you were talking about glasgow haskell
17:28:40 <mm_freak> who isn't? ;)
17:28:56 <Jafet> People who want to forget about memory
17:29:12 <mm_freak> what do they compile/interpret with?
17:29:19 <mm_freak> god?
17:30:31 <mm_freak> haskell needs at least GC…  for many useful programs you'll likely also want an RTS
17:31:01 <monochrom> god or richard bird :)
17:31:13 <Jafet> Extensionally equivalent
17:31:16 <monochrom> or all those denotational people, in fact :)
17:31:22 <mm_freak> ok, yeah, you could write out a lambda expression and reduce it by hand =)
17:32:01 <monochrom> all those people who think that "semantics" refers exclusively to denotational semantics. (so operational semantics is not a semantics?)
17:32:43 <mm_freak> works as long as you don't use I/O =)
17:34:31 <monochrom> I/O can be done by hand too
17:34:44 <Jafet> That ain't webscale
17:35:04 <monochrom> right, not webscale unless you hire many, many hands
17:35:24 <monochrom> IBM used to do that. hiring many, many hands. their job title:
17:35:27 <monochrom> "computer"
17:35:41 <mm_freak> monochrom: you can do (i.e. perform) connectTo by hand?
17:35:51 <Pseudonym> Printer, computer, bus driver... all used to be jobs people did.
17:36:04 <Jafet> mm_freak: uhh, it's called a "handshake"
17:36:07 <monochrom> we know how to do connectTo by pigeons, in fact.
17:36:17 <hpc> mm_freak: given a printout of the current RealWorld#, sure
17:36:49 <mm_freak> Jafet: Network.connectTo
17:38:56 <monochrom> yes, we know it's Network.connectTo
17:39:20 <tnks> is there any way to get Haskell to give a warning about infinite recurses like "neverHalt = neverHalt"?
17:39:34 <tnks> or rather evaluations of neverhalt?
17:39:43 <mm_freak> tnks: as long as it recognizes them, it prints <<loop>>
17:39:50 <Jafet> Haskell doesn't give warnings; GHC might
17:39:52 <monochrom> but that's during run time
17:39:52 <mm_freak> tnks: but of course it can't recognize all of them
17:40:20 <mm_freak> tnks: haskell can't recognize infinite computations statically though
17:40:25 <monochrom> I know of no compile-time warning for that
17:40:43 <tnks> mm_freak: I didn't see the <<loop>> warning when compiling:  noHalt = noHalt; main = putStr noHalt
17:40:46 <Jafet> tnks: I suggest not writing neverHalt if you don't want its evaluation to never halt
17:40:59 <Jafet> That concludes my wise suggestion of the day
17:41:09 <tnks> Jafet: yeah, a group of us are just exploring corner cases.
17:41:41 <tnks> I don't think we're expecting GHC to disprove the halting problem.
17:41:43 <mm_freak> tnks: if you need a language specifically with the ability to find infinite loops statically, consider using agda
17:41:45 <monochrom> but you can omit all your type signatures, ask for inferred types, and look at those inferred types. do they look too good to be true? if yes, you have an infinite loop.
17:41:56 <Jafet> What's the power of agda again?
17:41:56 <tnks> we were just curious if there was some detection of the simple stuff.
17:42:13 <mm_freak> Jafet: agda is not turing-complete
17:42:38 <Jafet> Of course not (barring false)
17:42:49 <tnks> yeah, I'd like to better understand Haskell first, then maybe stretch out to Coq or Agda.
17:42:54 <monochrom> example: you were trying to define an Int -> Int function. even with type inference, it should be at best (Num a) => a->a, or maybe a->a sometimes. but ...
17:43:04 <monochrom> :type let f a = f a in f
17:43:10 <monochrom> @type let f a = f a in f
17:43:11 <lambdabot> forall t t1. t -> t1
17:43:30 <monochrom> you get a->b. that is the doing of an infinite loop
17:43:41 <mm_freak> tnks: your question is related to the curry-howard isomorphism
17:44:14 <monochrom> there is a glorious example of a buggy sorting function that goes [a]->[b] by Markus Dominus
17:44:26 <mm_freak> tnks: but i'm pretty sure that GHC with suitable options recognizes many simple infinite loops
17:45:58 <monochrom> http://perl.plover.com/classes/OOPSLA/samples/slide001.html
17:46:06 <mm_freak> tnks: although it might not recognize the simplest f = f case intentionally
17:46:24 <mm_freak> but i don't know
17:46:37 <td123> how does the fix operator work? is it just a bruteforce or something?
17:46:49 <Jafet> @src fix
17:46:50 <lambdabot> fix f = let x = f x in x
17:46:52 <monochrom> it works by being a shortcut of recursion
17:47:05 <monochrom> see my http://www.vex.net/~trebla/haskell/fix.xhtml
17:47:33 <td123> monochrom: awesome, the first sentence makes me think this is a good article for me :)
17:47:50 <mm_freak> tnks: GHC recognizes this:  let x = x in print (x :: Int)
17:47:57 <monochrom> if you understand "let xs = 0 : xs in xs", you understand "fix (0 : )"
17:48:44 <mm_freak> it also recognizes:  print (fix (1 +))
17:50:37 <hpc> monochrom: cool slides on that plover link
17:50:56 <monochrom> yeah, Mark Dominus is cool
17:51:21 <mm_freak> wow, i'm impressed
17:51:50 <hpaste_> “Ertugrul Söylemez” pasted “GHC infinite loop recognition” at http://hpaste.org/52389
17:51:57 <mm_freak> http://hpaste.org/52389 ⇐ GHC even recognizes this
17:52:11 <monochrom> the simple kind of infinite loop "blah blah = blah blah" reliably gives you an inferred type too-good-to-be-true
17:52:30 <mm_freak> even with very large numbers instead of 100
17:52:47 <mm_freak> GHC seems to be very good at this
17:53:53 <mm_freak> it doesn't recognize this though:      print (elem 0 (repeat 1))
17:54:33 * ddarius doesn't know what mm_freak is talking about.
17:54:49 <monochrom> the run time recognizes knot-tying infinite loops, just because of technical details of lazy evaluation and sometimes concurrent lazy evaluation
17:55:19 <mm_freak> ddarius: GHC's infinite loop recognition
17:55:23 <td123> can I compile programs using ghc on windows?
17:55:30 <td123> or does it have to interpret?
17:55:33 <mm_freak> td123: sure
17:55:53 <td123> ok, I'll look into that then
17:56:02 <monochrom> can compile. fire up command prompt, ensure %path% is right, ghc --make myfile.hs
17:56:04 <td123> I was just asking because I didn't explicitly install gcc
17:56:27 <mm_freak> td123: GHC doesn't need GCC
17:56:34 <td123> hmm
17:56:40 <mm_freak> it uses one internally, though, as far as i've seen
17:56:46 <ddarius> mm_freak: What "infinite loop recognition"?
17:56:48 <td123> I think when I saw ghc --make -O2 I thought it used gcc as a backend
17:57:00 <monochrom> ddarius: blackholes and whiteholes
17:57:01 <td123> thanks for that clarification
17:57:03 <nyingen> anyone done any work writing bindings with hsc2hs?
17:57:17 <Jafet> Yes, GHC uses mingw on windows.
17:57:18 <mm_freak> ddarius: when it finds that an evaluation will never yield a value, it sometimes prints <<loop>> and kills the thread or program
17:57:38 <monochrom> "ghc -O2" needed gcc in very old versions, yes.
17:58:16 <monochrom> now it doesn't unless you ask for -fvia-C
17:58:16 <mm_freak> td123: anyway, if you installed the haskell platform, then you have everything to go ahead and write and compile programs
17:58:30 <robert[]> hello
17:58:36 <monochrom> oh noes
17:58:49 <Jafet> mm_freak: <<loop>> is a shown NonTerminationException, which is thrown by the RTS if an evaluation blocks on itself
17:59:01 <Jafet> The whnf of (elem 0 (repeat 1)) does not block on itself
17:59:16 <mm_freak> i see
17:59:23 <ddarius> mm_freak: Yes, that only covers a rather specific case, and, as monochrom said, this is more a side-effect of implementing lazy evaluation than GHC going out of its way to "find infinite loops."
17:59:52 <mm_freak> ddarius: for it being a side effect it is quite reliable sometimes
17:59:58 <robert[]> ddarius
18:00:12 <Jafet> And <<loop>> is really a side-effect of GHC looking for concurrency deadlocks
18:00:32 <ddarius> Jafet: No.
18:00:48 <Jafet> Er, I was thinking of MVar
18:01:06 <mm_freak> i've seen <<loop>> in concurrent contexts
18:01:33 <ddarius> mm_freak: It will only happen in cases like let x = ...  It will not ever happen for cases like let f x = ...
18:01:40 <ddarius> mm_freak: So?
18:01:48 <mm_freak> ddarius: i see
18:02:03 <Saizan> i thought you wouldn't get <<loop>> with the threaded runtime
18:02:21 <ddarius> Saizan: I'm pretty sure you don't.  You don't need the threaded runtime to use concurrent Haskell.
18:02:43 <mm_freak> ah no, that was a different exception
18:02:52 <mm_freak> test2: thread blocked indefinitely in an MVar operation
18:02:53 <ddarius> Yes, there's a ThreadBlockedOnMVarIndefinitely
18:03:36 <ddarius> That happens when the garbage collector traverses the heap and notices that a thread is blocked on an MVar that is not referenced anywhere else.
18:03:47 <mm_freak> ddarius: wait a minute…  look at my paste
18:03:53 <mm_freak> http://hpaste.org/52389
18:04:24 <mm_freak> that one throws <<loop>> (with -O2 and the threaded runtime)
18:04:44 <robert[]> does anyone know about lambda calculus
18:04:57 <mauke> haha
18:05:01 <monochrom> I think we all flunked lambda calculus.
18:05:14 <djahandarie> What's a lambda calculus
18:05:26 <djahandarie> Are those edible?
18:05:32 <dalaing> any thoughts on the books pearls of functional algorithm design / purely functional data structures / types and programming languages? - amazon is calling me...
18:05:34 <lambdabot> Do you know about proteins?
18:05:37 * gwern maked you a lambda, but he eated it
18:05:42 <mm_freak> lambda calculus?  isn't that obsolete now that we have google go?
18:05:49 <ddarius> mm_freak: Not here, it doesn't.
18:06:05 <robert[]> help
18:06:14 <mm_freak> ddarius: i've got GHC 7.0.3
18:06:23 <ddarius> I have 7.0.1
18:06:41 <c_wraith> dalaing: I have the first.  It's very much about the process of designing good algorithms - starting with something very simple, and refining it as it gets more and more efficient.
18:06:46 <monochrom> dalaing: I think all of them are must-reads. but I don't know how to prioritize them
18:07:02 <robert[]> who wants to help me with lambda calculus
18:07:16 <Jafet> Go, a game of intellectual suffocation.
18:07:23 <Pseudonym> robert: Everyone, as soon as they've stopped joking about it.
18:07:28 <mm_freak> robert[]: just ask your question
18:07:34 <dalaing> go is an awesome game :)
18:07:46 <robert[]> go is just knots and crosses
18:07:53 <robert[]> except on a bigger board
18:08:04 <lambdabot> People are just amino acids, just bigger.
18:08:18 <mm_freak> lol
18:08:29 <monochrom> Go, a game, a brainy game. Re, a city in Norway...
18:08:45 <mm_freak> Go.  Where the machine fails.
18:10:05 <mm_freak> i've seen a presentation of google go…  didn't like it…  it's like C with much more special cases and syntactic peculiarities
18:10:12 <robert[]> I need the theory of de bruijn indices
18:10:14 <dalaing> c_wraith: monochrom: thanks - they all look like they'd be nice and brain stretchy
18:10:46 * Pseudonym went to a Rob Pike talk on it
18:10:56 <Pseudonym> With a bunch of Haskell and Prolog people./
18:11:06 <Pseudonym> They were all polite.
18:11:07 <mauke> robert[]: that reminds me, you completely ignored me last time you did this
18:11:10 <robert[]> where can I learn about the theory of e briojn indices
18:11:24 <robert[]> the theorems
18:11:26 <ddarius> mm_freak: I highly suspect you have something else in whatever file you are testing, or you are failing to clean properly.  What mechanism do you propose to detect that loop?
18:11:28 <mauke> robert[]: are you going to acknowledge me now?
18:11:28 <mm_freak> Pseudonym: how was the general reception?  at least among the haskell people i'd say not so good
18:11:51 <Pseudonym> A surprising number of them did their homework first, looking at the implementation.
18:12:09 <Pseudonym> The assertion that Go doesn't need downcasts is, it turns out, false.
18:12:11 <mm_freak> ddarius: i have no idea how it works, but it does it
18:12:15 <Pseudonym> At least, the current implementation does use them.
18:12:43 <Pseudonym> This may explain one reason why the compiler is so fast.
18:13:24 <mm_freak> Pseudonym: the very complicated syntax already scared me off, but being fair i watched the presentation to the end…  it didn't convince me really
18:13:42 <mm_freak> it's too high a price to pay for chans and concurrency i think
18:14:01 <Pseudonym> The general feeling is that Go is a useful data point, but it's not a sweet spot.
18:14:09 <robert[]> data L = Var Nat | App L L | Lam L
18:14:16 <Pseudonym> Go = Squeak + duck typing
18:14:37 <mm_freak> yeah…  go is the first approach to solve decades old C problems for systems programming, but it seems far from mature
18:14:38 <ddarius> Pseudonym: NewSqueak?
18:14:42 <c_wraith> I thought smalltalk was already essentially duck typed...
18:14:58 <robert[]> anyone
18:15:05 --- mode: ChanServ set +o mauke
18:15:05 --- kick: robert[] was kicked by mauke (hi)
18:15:28 <ddarius> mauke has always been the diplomatic one.
18:15:39 <mm_freak> mauke: uhm…  this time i didn't really see the trolling
18:15:49 <ddarius> mm_freak: He didn't ban him.
18:15:54 <mauke> what do you mean, "this time"?
18:15:55 --- mode: mauke set -o mauke
18:15:58 <mauke> I'm still waiting for an answer
18:16:19 <mm_freak> nevermind
18:16:36 <mauke> it's been like two days and he seems to ignore everything said to him
18:16:58 <mm_freak> i see…  alright then
18:18:59 <mm_freak> ddarius: turns out you need -O2 for the <<loop>> exception
18:19:12 <mm_freak> it probably optimizes most of the counting away
18:19:24 <ddarius> You need just -O.  It's likely doing a fully laziness type of optimization.
18:20:09 <robert[]> what IRC channel can Ig et help
18:20:16 <mauke> robert[]: hi
18:21:01 <mauke> sigh
18:21:18 <robert[]> Mauke
18:21:24 <mauke> yes?
18:21:24 <monochrom> finally
18:21:29 <mm_freak> robert[]: try #math
18:21:30 <robert[]> reply to me
18:21:35 <mauke> I just did
18:21:36 <cgroza> >print "Hello"
18:21:49 <mm_freak> cgroza: space after '>'
18:21:53 <cgroza> > print "Hello"
18:21:54 <lambdabot>   <IO ()>
18:22:05 <mm_freak> cgroza: and of course lambdabot won't perform IO for you ;)
18:22:07 <cgroza> mm_freak: thanks. cool bot you have here.
18:22:15 <cgroza> :D
18:22:16 <mm_freak> cgroza: it's not my bot
18:22:24 <cgroza> mm_freak: I mean the channel
18:22:26 <monochrom> > putStrLn "<IO ()>"
18:22:27 <lambdabot>   <IO ()>
18:22:42 <mm_freak> ah…  the english "you" is confusing =)
18:22:46 <robert[]> does anyon want to talk about it
18:22:49 <mauke> "y'all"
18:23:01 <mm_freak> robert[]: as said, try the #math channel
18:23:10 <mm_freak> those people are very kind and helpful
18:23:14 <mm_freak> they are lovely
18:23:30 <monochrom> I agree
18:23:37 <robert[]> data L = Var Nat | App L L | Lam L
18:23:52 <robert[]> this is my data type
18:24:03 <lucca> there are many like it, but that one is yours?
18:24:41 <robert[]> does anyone know about it
18:24:50 <mauke> know what?
18:25:31 <mm_freak> robert[]: your question is a math question
18:25:37 <mm_freak> we don't have much experience with math
18:25:38 <robert[]> mauke:
18:25:42 <robert[]> lets PM
18:25:47 <mm_freak> /join #math
18:25:47 <mauke> robert[]: how about no
18:25:58 <mauke> mm_freak: oh? do you know what his question is?
18:26:04 <robert[]> am puting you back on ignore
18:26:19 <mauke> robert[]: are you crazy or something?
18:26:34 <mm_freak> mauke: i haven't really tried working it out
18:26:56 <mauke> it seems to be at least somewhat on-topic if it's haskell code
18:26:57 <robert[]> I've been workin gon lambda calculsu for 5 days
18:27:11 <mm_freak> my cryptography knowledge is kinda…  uhm…  eingerostet
18:27:21 <mauke> mm_freak: cryptography?
18:27:29 <zygoloid> robert[]: http://catb.org/~esr/faqs/smart-questions.html
18:27:30 <mm_freak> yeah
18:27:31 <mauke> oh, deciphering
18:27:33 <robert[]> I cant get it myself
18:27:40 <robert[]> so I haoped someone could help
18:27:44 <mauke> robert[]: can you see this?
18:27:57 <robert[]> stop harassing me
18:28:01 <mm_freak> lol
18:28:12 <mauke> wtf
18:28:39 <robert[]> I get it, you've got authority over me
18:28:42 <mm_freak> robert[]: you should first learn the basics
18:28:45 <robert[]> can we move on from this?
18:28:48 <mauke> if you have a question, ask it; if you have a point, make it
18:28:49 <mm_freak> like…  well…  using IRC
18:28:54 <mauke> move on from what?
18:29:05 <mauke> all you've done so far is pasted one data definition
18:29:09 <robert[]> you proving that you have higher authority
18:29:10 <Jafet> Yes mauke, can we move on from this
18:29:25 <mauke> robert[]: what does authority have to do with it?
18:29:33 <robert[]> that's why you kick me out
18:29:35 <robert[]> refuse to PM
18:29:41 <robert[]> and force me to reply to you
18:29:53 <mm_freak> robert[]: i've told you two times, you are in the wrong channel
18:29:56 <robert[]> I get it
18:29:56 <mauke> robert[]: no, I kicked you out because you ignored me for two days
18:29:57 <mm_freak> ask in #math
18:29:58 <robert[]> lets move on
18:30:22 <mauke> robert[]: please note: I was actually trying to help you
18:30:34 <zygoloid> robert[]: if you're having problems specifically with writing haskell code for something, you'll need to say so
18:31:07 <robert[]> zygoloid: I want to code beta substitution
18:31:26 <mm_freak> and what's the problem?
18:34:01 <robert[]> I am not lazy
18:34:05 <robert[]> I worked very hard on it
18:34:24 <mauke> and what's the problem?
18:34:45 <robert[]> I don't know how to write it correctly
18:35:06 <zygoloid> please be more specific
18:35:15 <mauke> what do you want me to do?
18:35:35 <robert[]> there is a gap bewteen the idea "lambda calculus beta substitution on de bruijn terms" and the program
18:35:57 <robert[]> how do I know the program really is ?
18:36:13 <robert[]> how do yu close the gap
18:36:42 <Jafet> You know, we could just continue to ignore him until his deadline passes
18:37:13 <mauke> when is that?
18:37:41 <Jafet> I'll go with indefinitely
18:38:17 <robert[]> did I explain it clearly?
18:38:40 <robert[]> ill show you my code
18:38:47 <MrZepeda> @robert is that for fun or for a homework?
18:38:47 <lambdabot> Unknown command, try @list
18:38:50 <zygoloid> please use a pastebin
18:38:54 <robert[]> MrZepeda: fun
18:39:20 <MrZepeda> @list
18:39:21 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:39:30 <MdxBhmt> @quote
18:39:30 <lambdabot> stepcut says: how can you possibly implement business logic without knowing about Schonfinkel!?
18:39:36 <robert[]> zygoloid: youre angry at me
18:39:47 <MdxBhmt> @quote robert
18:39:47 <lambdabot> No quotes match. Wrong!  You cheating scum!
18:40:12 <MdxBhmt> @quote
18:40:12 <lambdabot> c_wraith says: oh.  well, then.  some actually *do* simply unsafePerformIO into Mordor.
18:40:33 <MdxBhmt> oh lawlz
18:40:47 <robert[]> i dont know if my problem is too easy or too advanced
18:40:52 <robert[]> by everyone just makes jokes about it
18:41:19 <mauke> robert[]: you haven't asked an answerable question yet
18:42:40 <Clint> so many problems
18:42:48 <mauke> robert[]: also you're behaving very weirdly
18:43:02 <MdxBhmt> hey, very important question that i should had asked earlier, what's easier to learn and use for a total newb, yesod or snap?
18:43:07 <MrZepeda> robert: everyone feels like you want them to solve your problem for you, because you are not asking a specific question. It is your job to fill that gab and come down to the specifics that somebody can answer. For broad questions it is better to read a book or make an appointment with a Professor.
18:43:16 <MrZepeda> *gap
18:43:18 <zygoloid> robert[]: showing us your code and explaining your problem would be an excellent start. use http://hpaste.org to share your code with us
18:43:35 <HugoDaniel> :)
18:43:39 <robert[]> I feel like an out cast from here
18:43:54 <mauke> cool story, bro
18:44:06 <dalaing> robert[]: people are telling you what you need to do in order to get help or answers
18:45:34 <tkahn6> afaik robert[] wants to model lambda calculus
18:45:47 <tkahn6> in haskell
18:46:02 <robert[]> tkahn6: yes
18:46:10 <Saizan> that part was already clear
18:46:19 <robert[]> I have the model actually
18:46:41 <tkahn6> so what is the problem you have?
18:46:56 <robert[]> the fundamenal operation is beta substituoin
18:47:25 <robert[]> I need to write this function correctly
18:47:41 <robert[]> it is not enough that I simply type out source code
18:48:03 <robert[]> there is a lot of mistakes possible
18:48:14 <Saizan> can you show your attempt and why do you think it's not correct? or is your problem that you can't tell?
18:48:24 <robert[]> so a better method is needed where the code is arising necessarily
18:48:29 <robert[]> both Saizan
18:48:48 <MrZepeda> http://en.wikipedia.org/wiki/Lambda_calculus#Beta_reduction
18:48:49 <mauke> robert[]: ok, so prove it correct
18:48:49 <tkahn6> ok so you're having trouble modeling beta substitution?
18:48:51 <robert[]> I have come up against real bugs and I am never sure if the code is right
18:49:01 <robert[]> tkahn6: yes
18:49:02 <MdxBhmt> if i got it right, he wants to write a beta redux?
18:49:19 <Saizan> robert[]: well, the version i've given you that uses Fin for variables already goes a long way at guaranteeing correctness
18:49:19 <zygoloid> robert[]: so you have some code, and you'd like to prove that it's correct?
18:50:07 <robert[]> thank you everyone
18:50:08 <MrZepeda> So the code works, but you are not sure if it is doing the right thing?
18:50:18 <robert[]> MrZepeda: yes
18:51:09 <tkahn6> robert[] can you sketch out what beta substitution would look like?
18:51:14 <robert[]> okay
18:51:54 <MrZepeda> well with haskell you can take two approaches: 1) Run test cases 2) Use a formal verification system like cok, or fin.
18:53:03 <MrZepeda> if you understand the concept well you can come up with very good test cases, usually borders, and extremes work well.
18:55:30 <robert[]> http://pastebin.com/tiNyrrKh
18:55:33 <mauke> The paste tiNyrrKh has been copied to http://hpaste.org/52390
18:57:06 <robert[]> the purpose of this is to insert a term 'x' into the places with index 'j' of a term
18:57:17 <robert[]> but you cant simply put x into the places like a search and replace
18:57:43 <robert[]> the variable numbers have to be increassed to reach outside of the lambda binders
18:59:56 <zygoloid> robert[]: what is 'lift' for?
19:00:44 <robert[]> ill explain it by using an example
19:01:03 <robert[]> let x = Lam (App (Var 0) (Var 1))
19:01:25 <robert[]> this is x = " \u -> u v" roughly
19:01:58 <robert[]> now consider  (\x -> x (\y -> x)) x
19:02:12 <robert[]> in de brjuin indices this will be computed by my funcion as:
19:02:30 <robert[]> substitute (App (Var 0) (Lam (Var 1))) 0 x
19:03:06 <robert[]> in this "Lam"" 'v' must be reached out frther
19:03:21 <robert[]> therefore ew have  App (Lam (App (Var 0) (Var 1))) (Lam (App (Var 0) (Var 2)))
19:03:31 <robert[]> this '2' is computed by lift
19:06:10 <Cale> robert[]: Sorry, did you have a question? :)
19:06:20 <Cale> robert[]: (I could go looking through the scrollback for it...)
19:06:25 <robert[]> this is tryng to explain m answCale,
19:06:29 <robert[]> zy
19:06:40 <Cale> ah, okay :)
19:06:56 <robert[]> (I have a question
19:07:00 <mauke> <robert[]> I have come up against real bugs and I am never sure if the code is right
19:07:05 <robert[]> about beta substituoin on de bruijn indices
19:07:52 <ddarius> To answers Cale's question more definitively: no.
19:07:54 <Cale> Ah, maybe quickcheck testing could help... apart from that, equational reasoning and actually proving the correctness of the code is the main other option.
19:08:02 <Cale> okay
19:08:03 <robert[]> it's best to ignore my actually
19:08:05 <robert[]> my code
19:08:05 <Cale> What's the question?
19:08:30 <robert[]> The reason is, if I have a bug in my cde. Just looking at it could influence you tor e produce  it
19:08:53 <Cale> Um, I guess so. :)
19:08:57 <robert[]> its possible the entire approach is wrong
19:09:03 <zygoloid> robert[]: do you have some external definition of what it would mean for your code to be correct?
19:09:17 <robert[]> zygoloid: this is what I am battling with
19:09:50 <robert[]> it may not be possible to state "this code is correct" in mathematical language
19:09:54 <Cale> robert[]: Aha, okay, so you need some definitions of lambda term equivalence, so that you can ensure your evaluator produces equivalent terms to its input.
19:10:01 <zygoloid> robert[]: how about you define a transformation to and from lambda calculus and prove equationally that your code behaves the same as lambda calculus substition
19:10:06 <zygoloid> *substitution
19:11:05 <monochrom> if you define beta reduction formally, it will look not too different from haskell code.
19:11:17 <robert[]> Cale, I ca define equivalence but it is in terms of beta substitution
19:11:21 <Cale> Each of the things which your evaluator does with a term will usually be explained via alpha or beta equivalence. In some cases, you might also do eta reduction, but start with those two.
19:11:35 <robert[]> so I have a circular approach, and logically it is unsound
19:11:41 <Cale> ?
19:12:12 <robert[]> lambda calculus eqiovalance =reflexive symmetric transitive congruenceclosure of beta redex reduction
19:12:33 <Cale> Most evaluators will iteratively apply beta reduction to a term (to some redex inside it)
19:12:52 <robert[]> oh
19:12:58 <robert[]> I'm not making an evaluator yet
19:13:07 <Cale> oh, what are you doing then?
19:13:12 <robert[]> first of all I just want a single beta redex reduction
19:13:16 <Cale> ah, okay
19:13:23 <Cale> Well, that's a good piece to do :)
19:13:57 <robert[]> I don't know whether to beleive if a n external correctness such as zygoloid suggests is possible
19:14:18 <robert[]> if such a thing were available I think it would be completely solving my problems
19:14:22 <monochrom> "specify substitution. implement the specification. prove the implementation correct w.r.t. the specification. and oh, the two should look very different; artificially different if necessary"
19:14:45 <monochrom> it is the last part that I refuse to do
19:15:37 <monochrom> Church's original definition of substitution may be in English (or Italian, I forgot), but even that was already pretty close to code.
19:15:41 <robert[]> i take a carefuly considering of each singeline of code.. and also considering every possible interactionss
19:16:00 <robert[]> sometimes I feel like its all there and other times everyting is tumbling down and away
19:16:06 <ddarius> monochrom: Alonzo Church was born in DC.
19:16:20 <monochrom> ok then it's English
19:16:27 <robert[]> is there something solid for it to rest on
19:17:48 <Cale> robert[]: Sure, there's a mathematical specification of term equivalence.
19:18:33 <Cale> Every replacement which your evaluator does should eventually respect that equivalence.
19:18:42 <Cale> (once you get to that point)
19:19:15 <Cale> There are standard solutions to the various problems which can come up in substitution and so on.
19:20:14 <Cale> The first thing you'll want to implement is a function which substitutes all the *free* occurrences of some variable in a term with some other term.
19:22:01 <elliott> 	|	qcon { fbind1 , … , fbindn }	    (labeled construction, n ≥ 0)
19:22:01 <elliott> |	aexp⟨qcon⟩ { fbind1 , … , fbindn }	    (labeled update, n  ≥  1)
19:22:02 <elliott> Is the Haskell Report telling me that a negative number of binds is OK in a record construction, but unacceptable in an update?
19:22:06 <elliott> What strange reality have I landed in?
19:22:42 <rwbarton> are you having soe weird font issue?
19:23:00 <rwbarton> or do you mean "zero" rather than "negative"
19:23:26 <rwbarton> > IdentityT "hello"
19:23:27 <lambdabot>   Not in scope: data constructor `IdentityT'
19:23:31 <Cale> elliott: both of those clearly say that n is non-negative. The first is that n is greater or equal to 0, the second is that n is greater than or equal to 1.
19:23:45 <rwbarton> hmm, what's a convenient type declared with field names
19:23:49 <elliott> Cale: Oh, hmm, it's saying that an empty update for the second one is impossible
19:23:52 <Cale> yeah
19:23:55 <elliott> Why is an empty update impossible, I wonder
19:24:03 <Cale> Probably no good reason
19:24:03 <monochrom> n>=0 is a way to say "none". thus, qcon{} is a case of qcon { fbind1 , … , fbindn } with n=0
19:24:08 <elliott> Cale: I was more amazed by the previous line, really, which contains an inviolable variant? :-)
19:24:10 <elliott> s/?//
19:24:12 <Cale> Other than that it's probably a bug to have one.
19:24:33 <Cale> If you were going to write  foo {}  you could just write  foo  instead
19:25:02 <Cale> So if the braces are there, but without an update inside them, then it looks like you forgot to do something
19:25:11 <robert[]> what is the equational theory of lambda calculus, if not the computational theory of reduction
19:25:17 <elliott> Cale: Yeah... but it's so conceptually impure :-P
19:26:02 <Cale> robert[]: There's an equational theory which specifies which terms are *equivalent* to which other terms, without saying anything about what direction reduction proceeds in.
19:26:24 <Cale> elliott: Well, it's just concrete syntax :P
19:26:47 <Cale> concrete syntax is allowed to be conceptually impure for any number of reasons
19:27:12 <monochrom> such as 0 reasons :)
19:27:22 <Cale> lol
19:27:28 <Cale> yes, including 0
19:27:33 <monochrom> (remember? n≥0 :) )
19:27:38 <robert[]> i dont knwo what to do about this
19:28:07 <Cale> robert[]: actually, before you write capture-avoiding substitution, write something which finds the set of free variables in a term
19:28:25 <Cale> robert[]: This is fairly easy to do recursively, and you'll need it in order to define substitution.
19:28:31 <robert[]> i was using de bruijn indices
19:28:35 <ddarius> robert[]: There are dozens of books that formally prove correctness of implementations of beta reduction.  Feel free to read any of them.
19:28:51 <robert[]> ddarius: I can learn this online?
19:29:24 <robert[]> this proof is very important to me
19:30:25 <Cale> robert[]: I highly recommend picking up a copy of "Types and Programming Languages" by Pierce.
19:32:27 <robert[]> what is "correctness" of beta reuction
19:33:13 <Cale> Well, a function which beta-reduces a term ought to produce a term which is beta-equivalent to its input.
19:33:26 <robert[]> this is circular logic though
19:33:33 <Cale> No it isn't
19:33:41 <robert[]> my defnition of beta equivalent
19:33:42 <Cale> Beta equivalence isn't defined in terms of beta-reduction.
19:33:49 <robert[]> oh
19:33:58 <robert[]> I did define it that way
19:34:06 <robert[]> but how else can it be done
19:34:15 <Cale> ?
19:34:22 <Cale> oh
19:34:34 <Cale> How can we define beta equivalence without saying anything about reduction?
19:38:17 <Cale> Basically by saying that (\x. e1) e2 is beta equivalent to [e2/x] e1, and taking the least equivalence relation on terms which is closed under that.
19:38:26 <robert[]> okay
19:38:46 <Cale> (where [e2/x] is capture-avoiding substitution)
19:38:50 <robert[]> what is th theory of [e2/x] e1
19:38:53 <robert[]> I suppose
19:39:07 <robert[]> can it be uniquely specified
19:39:14 <Cale> yeah
19:39:22 <robert[]> by intuitively correct sentences
19:39:34 <Cale> Well, we're going to *define* it
19:39:45 <Cale> So our sentences that define it will be correct by fiat.
19:40:28 <Cale> (though I suppose we could technically write down something which doesn't define a function on terms or something...)
19:40:34 <Cale> But we will :)
19:40:36 <Cale> So...
19:40:47 <robert[]> what if I write
19:40:55 <Cale> We can define it recursively on the structure of a term.
19:41:02 <robert[]> [e2/x] e1 = \u -> u u
19:41:07 <robert[]> this is correct?
19:41:18 <Cale> no
19:41:26 <Cale> well... it's not always correct.
19:41:40 <Cale> Unless e1 and e2 are just the right things :P
19:41:52 <robert[]> http://pastebin.com/tiNyrrKh
19:41:53 <mauke> The paste tiNyrrKh has been copied to http://hpaste.org/52390
19:41:55 <robert[]> what if I write this
19:42:38 <Cale> Have you written a lambda calculus evaluator without using De Bruijn indices already?
19:42:54 <Cale> I recommend doing that first, because De Bruijn indices make more sense once you have.
19:42:58 <robert[]> no I dont have anything but de bruihn
19:44:39 <monochrom> I haven't written an evaluator without de Bruijn. in fact, I will never. all the variable-capture etc are a pain.
19:44:45 <Cale> With De Bruijn indices, you're essentially naming your variables using natural numbers, and doing various alpha-equivalent shiftings of variables to ensure that the outermost lambda in a complete term binds the variable 0
19:45:03 <robert[]> I don't quite agree with that
19:45:09 <mauke> it's also important that you never spell it right
19:45:18 <robert[]> my view is a slightly different
19:45:45 <Cale> er, sorry, I was wrong there
19:45:52 <Cale> The innermost lambdas bind 0 :)
19:46:28 <robert[]> when it gets down to it, we are literally floating through space on nothing
19:46:28 <ddarius> You can do it either way.
19:46:34 <Cale> right
19:46:37 <robert[]> I think lambda calculus is very much te same
19:46:40 <Cale> robert[]: What do you mean?
19:47:04 <robert[]> it is not just a universal notation for algorithms
19:47:06 <Cale> robert[]: There are some definitions, and we come to conclusions based on those definitions.
19:47:11 <robert[]> you can use for logic and mathematics too
19:47:16 <shachaf> Now that I think of it, the lambda calculus *is* a lot like floating through space on nothing.
19:47:33 <elliott> Also known as just floating.
19:47:37 <robert[]> in fact it is the basis of all thought and reality itself is very liekly to be a lambda calculus
19:47:37 <monochrom> Church certainly floated it on space.
19:47:39 <Cale> shachaf: and a monad is like a spacesuit which lets you survive?
19:47:41 <Cale> OMG
19:47:44 <shachaf> Cale: Exactly!
19:47:51 <Cale> ROFL
19:47:52 <ddarius> Cale: You don't survive
19:47:56 <elliott> shachaf: Cale: You just wrote my Haskell tutorial for me.
19:48:25 <Cale> robert[]: Don't get all metaphysical on us. I hate metaphysics.
19:48:29 <robert[]> sorry
19:48:38 * Cale is a formalist at heart.
19:48:39 <ddarius> Cale: That's pretty much all he's been going on about the whole time.
19:48:56 <shachaf> I expect "meta" is a monad, so you can join metametaphysics to get back to metaphysics, but can't get from metaphysics back to physics.
19:48:57 <Cale> THERE ARE SYMBOLS AND WE PUSH THEM AROUND AND THAT IS ALL THAT THERE IS
19:49:10 <Cale> heh
19:49:14 <monochrom> eventually, took Dana Scott et al. much work to ground it on partial orders on set theory. but then, set theory floats on space, too.
19:49:22 <Cale> Well, I'm not quite that hardcore about it, but you get the idea.
19:49:31 <shachaf> Cale: "A formalist is one who cannot understand a theory unless it is meaningless."
19:49:58 <Cale> Everything else is intuition. Intuition is necessary for navigating around these spaces of symbols, but it's not necessary for saying what we're talking about.
19:50:16 <monochrom> and a platonist doesn't understand a theory unless it is platonic
19:50:42 <elliott> Cale: But whence the symbols????
19:50:59 <elliott> Q.E.D.
19:50:59 <shachaf> elliott: It's symbols all the way down.
19:51:04 <Cale> elliott: I MAK MARK WITH CHALKS. IS GOOT.
19:51:11 * ddarius is not a formalist, but he's much more violently not a Platonist.
19:51:11 <elliott> shachaf: I heard Type : Type is, like, unsound.
19:51:13 <elliott> Q.E.D. redux.
19:51:25 <robert[]> I reject platonism
19:51:38 <Cale> I think we can all agree that Platonism is dumb.
19:51:45 <monochrom> "Type : Type" is Coq's syntax sugar for "Type 3 : Type 2" hehehe
19:52:16 <Cale> That the universe has some sort of opinion about whether we call certain strings of symbols true or false is pretty religious-sounding.
19:52:41 <robert[]> platonism is a vestige of spiritualism
19:53:41 <robert[]> this reminds me of the Godel paradox
19:53:50 <amtal> Are there any examples out there on using Test.QuickCheck.Monadic?
19:54:05 <Cale> robert[]: So in order to define the lambda calculus, we say which strings of symbols we're talking about (define lambda terms), and then we say which strings of symbols are equivalent to which other strings of symbols according to a few rules.
19:54:39 <robert[]> Cale: I guess the question is not "is this code correct" but "are we having fun"
19:55:09 <shachaf> Cale: So it's kind of like http://images.static.steveweissmusic.com/products/images/uploads/1126255_13233_popup.jpg ?
19:55:12 <Cale> Well, if that's the goal, then you don't need to stress out so much about it :)
19:55:34 <ddarius> robert[]: No, the question is "is this string of symbols (the code) meet the specification given by this other string of symbols."
19:55:45 <Cale> shachaf: perfect
19:56:35 <Saizan> monochrom: Type 2 : Type 3
19:56:42 <ddarius> Cymbals are expensive.
19:56:46 <monochrom> yeah I was being naughty
19:57:15 <Cale> Yeah, we can say which datastructures in our program correspond to which strings of symbols on paper, and then ask questions about the program like whether a certain function on our datastructures has a result whose interpretation is lambda-equivalent to the interpretation of its input.
19:57:49 <robert[]> this is very abstract
19:57:56 <Cale> Doing that is often quite dry and boring though, at least in my experience. If your goal is to have fun, then just implement the damn thing and see if it works :P
19:58:16 <Cale> (when it doesn't work, then returning to the dry and boring ardour is a decent option)
19:58:24 <monochrom> richard bird shows how fun the proofs are
19:58:48 <Saizan> btw, if i was formalizing lambda calculus in a type theory i'd define an interpretation function [[_]] : L -> D where D is some domain and then check that [[ (\x. M) N ]] = [[ M[x := N] ]]
19:59:00 <robert[]> domain?
19:59:05 <Saizan> [[_]] won't use substitution
19:59:23 <monochrom> but today my point is that there is nothing wrong with the specification and the implementation being identical.
19:59:40 <Cale> monochrom: I guess that's a good option as well.
20:00:03 <Cale> monochrom: It's a feature, not a bug.
20:00:36 <monochrom> if the implementation language is high-level enough (like haskell), you can't avoid it
20:00:37 <Saizan> robert[]: by domain here i mean some type that can be used as a model of lambda calculus rather than as a syntax for it
20:01:35 <monochrom> if you program a FPGA to do substitution, then there is maybe something slightly meaningful to prove.
20:01:52 <monochrom> but writing haskell code to do substitution? I'm sorry there is little to prove.
20:02:07 <Saizan> "Normalization By Evaluation" goes a step further by doing the whole normalization by converting to a domain and then back to the syntax
20:02:09 <Cale> robert[]: So the domain will be a set of some mathematical widgets defined somehow such that there's a unique thing in the domain so that any two equivalent lambda terms get mapped to that same thing by this [[ ]] function.
20:02:45 <Cale> and distinct terms typically also have to map to distinct things in the domain (that is, [[ ]] should be injective)
20:03:49 <Saizan> no [[ ]] shouldn't be injective, many terms have the same interpretation
20:05:19 <Saizan> monochrom: i guess the problem here is that substitution is already complex enough that you wouldn't like it in your specification
20:05:31 <monochrom> it may be nice to have [[ ]] surjective, but not required
20:06:19 <monochrom> I don't find it all that complex, if variable capture etc don't happen (e.g., de Bruijn)
20:06:51 <Cale> Saizan: oh, sorry, yes, injective on equivalence classes
20:07:07 <monochrom> I note again that Church wrote a recursive definition, and it was already almost code.
20:07:17 <Cale> So two things in the same equivalence class go to the same thing, and two things in different equivalence classes go to different things.
20:07:33 <Saizan> ah, ok then
20:07:54 <Cale> Thanks for pointing that out :)
20:08:09 <shachaf> Cale: Can't you make anything injective on equivalence classes?
20:08:40 <Cale> shachaf: Not when you don't have control over the equivalence relation
20:08:53 <Cale> shachaf: The equivalence relation is the equivalence on terms which is already specified
20:08:56 <shachaf> Oh, you already defined the equivalent relation.
20:10:12 <Cale> Yeah, the other option I suppose is to determine the equivalence on terms by this interpretation function which is just arbitrary then.
20:11:18 <Cale> It's mildly upsetting to me that in [[ ]]: L -> D, the D is referred to as the domain :)
20:11:56 <Cale> Anyway, the fibre over each element in D would then be an equivalence class of terms
20:13:17 <ddarius> D is -a- domain.
20:19:21 <robert[]> yoy know what i think my code is wrong
20:19:37 <robert[]> I tried running it and it gave wwrong answers
20:20:06 <ddarius> Then your code is wrong.  What thinking is required?
20:22:05 <hydo> Is there a way to override an instance for a type in a function or otherwise?  I have a type that's composed of a few strings,ints, etc. and it has an Ord instance comparing one field, but I'd like to be able generalize that further so I can search a bst for any of the types fields.
20:22:15 <hydo> maybe this is better asked in paste/gist form.
20:22:22 <mauke> no
20:24:25 <Cale> hydo: You can write a complete Ord instance, but short of that, it's not possible to just override part of the derived definition.
20:24:49 <rwbarton> make your search function take a parameter which plays the role of <
20:25:09 <Cale> oh, yeah
20:25:22 <hydo> rwbarton: yea, that's what I started to do.
20:25:48 <Cale> Obviously the BST will need to be more than just a BST if you want to have multiple indices.
20:26:02 <Cale> But if you want to construct different indices, that's the likely solution.
20:26:04 <hydo> Cale: mecha-bst!
20:26:32 <rwbarton> oh
20:26:52 <Cale> Another would be to define newtypes of your type for which the Ord instance compares on different fields.
20:27:02 <Cale> (you still need to use separate trees for each)
20:27:14 <hydo> thanks, mauke, Cale, and rwbarton.
20:28:04 <shachaf> Is there a reason there isn't an equivalent of Data.Set that takes a function rather than an Ord instance?
20:28:14 <hydo> Cale: hrm... that's mildly tempting, though I don't really want to maintain separate trees.
20:28:33 <ddarius> shachaf: union (fromList (<) [1,2]) (fromList (>) [2,3])
20:28:52 <Cale> hydo: You kinda have to do the equivalent of maintaining separate trees in any case, unless you know about some relationships between the fields.
20:29:20 <rwbarton> if your BST is based on the ordering of some particular field, you can't search it efficiently by an unrelated field.
20:29:54 * Saizan wants DeriveFunctor for (* -> *) -> (* -> *) functors
20:30:14 <hydo> Cale: my knee-jerk reaction was to write a function that replicated my generalized search that use (a -> Ordering) to walk the tree, and (a -> a) to modify it on EQ.
20:30:25 <hydo> s/use/uses/
20:30:34 <Cale> Though it seems like there should be some (2^n)-tree thing which could automatically take advantage of correlation between the fields in a dataset.
20:31:14 <shachaf> ddarius: What if you only allowed some operations, e.g. insert/remove/elem, and had the comparison function be part of the Set?
20:31:31 <Cale> (hmm... is that what that IxSet thing was...)
20:31:51 <ddarius> shachaf: Yes, you could do something like that.
20:32:57 <elliott> stenobot >:(
20:33:10 --- mode: ChanServ set +o Cale
20:33:26 --- mode: ChanServ set +o mauke
20:33:26 --- mode: mauke set +b stenobot2011!*@*
20:33:35 <Cale> beat me to it :)
20:33:36 <elliott> poor Cale
20:33:41 --- mode: Cale set -o Cale
20:33:53 <Cale> I always have to remember the syntax for /mode
20:33:55 <Cale> :P
20:34:07 <mauke> I don't (/ban)
20:34:10 <elliott> /ban
20:34:16 --- mode: mauke set -o mauke
20:34:17 <Cale> ah
20:34:30 <mauke> well, /tmpban in this case
20:35:15 <monochrom> mauke has a personal digital assistant :)
20:36:27 <MdxBhmt> hey, very important question that i should had asked earlier, what's easier to learn and use for a total newb, yesod or snap?
20:37:10 <Nisstyre> MdxBhmt: snap is still in its early stages
20:37:12 <hydo> MdxBhmt: learning you some haskell first would be my suggestion.
20:37:14 <Nisstyre> so it takes some hacking to use
20:38:08 <MdxBhmt> hydo: i'm reading about haskell has been some months, and was thinking of using web development as an excuse to use haskell in someway D:
20:38:34 <Cale> Neither of those are really set up to be particularly easy to beginners. If you're gung-ho about doing a bit of web programming to start off, I would perhaps recommend something really basic like Network.CGI, unless you're thinking that you need lots of performance right away.
20:39:26 <MdxBhmt> It's not that i need performance, i'm more interested in ease of development
20:41:10 <Cale> Yesod is slightly weird in that it's not just Haskell, but actually a bunch of custom languages implemented so as to embed into Haskell, using quasi-quoter syntax. It looks like it's rather convenient once you understand what's going on, but I found it kinda confusing from what little I've seen.
20:42:23 <Cale> (The quasiquoters automatically define a bunch of stuff to be made available from the Haskell code, often without explicitly mentioning their names anywhere -- you just kinda have to know that it does that.
20:42:25 <Cale> )
20:43:23 <Cale> Snap is, from what I understand, completely in plain Haskell, but does make use of some libraries (Iteratee/Enumerator) which are pretty beginner unfriendly.
20:43:38 <MdxBhmt> hmmm
20:43:55 <hydo> Though you don't have to know them to be productive in Snap.
20:44:02 <Cale> But to be honest, I don't know how much it exposes them to the user, yeah.
20:44:23 <c_wraith> You can mostly ignore them
20:44:44 <c_wraith> except for some operational concerns if you start caring about the details of where the responses are actually being rendered
20:45:16 <Cale> okay, that's probably good enough then :)
20:45:26 <MdxBhmt> having a *good* dsl seems to be a good way of solving the problemn, at least for me
20:45:50 <Saizan> a good edsl is better
20:46:32 <shachaf> Just make sure to avoid ADSL.
20:46:48 <MdxBhmt> lol
20:47:00 <hydo> MdxBhmt: here's a link to the handlers for a project I mess around with off and on.  Line 293 is especially basic.  http://snurl.com/ozmbw
20:47:12 <Cale> Yeah, my main concern with Yesod's things is that they seem to break one principle of good quasiquoters from my perspective, which is that they define things which are not named in the quasiquoted syntax.
20:47:37 <hydo> I'm not that huge of a fan of Yesod, but I LOVE Persistent.
20:50:12 <hydo> Oh, I would also like to go on record as a professed lover of digestive functors for snap as well.  Ok, I'm done.
20:50:39 <MdxBhmt> hydo, thx for the project D:
20:51:54 <MdxBhmt> if  my head isn't messed up, this looks straightforward ;p
20:53:10 <robert[]> sohere is a qestion
20:53:41 <hydo> MdxBhmt: sure thing.  If you decide to run it, let me know.  It erm.. hehe.. uses a stylesheet and a font string for the google font api that is saved in the db.  so it'll look like hell when you open it.
20:54:34 <MdxBhmt> o.O
20:54:38 <robert[]> lam(b[j+1\n^1])x[j\n] = b[0\x][j\n]
20:55:52 <MdxBhmt> hydo:  i'm going to download it just for the lulz
20:56:22 <hydo> I can't think of a better reason.
21:18:18 <DanBurton> Hey guys; any /r/haskell -ers should upvote this one as fast as possible http://www.reddit.com/r/haskell/comments/l6knx/virtuahac_the_completely_online_hackathon/
21:18:43 <DanBurton> :) just popped in here to spam yall with that
21:25:30 <MdxBhmt> nice idea
21:33:25 --- mode: ChanServ set +o mauke
21:33:25 --- mode: mauke set -b stenobot2011!*@*
21:34:15 --- mode: mauke set -o mauke
21:36:38 <davo> hi all. I'm trying to use the code on triple :: Int -> [(Int,Int,Int)]
21:36:42 <davo> oops
21:36:53 <davo> code from http://en.wikipedia.org/wiki/Talk%3APythagorean_triple#Definition_in_Haskell
21:37:17 <davo> why does triple :: Int -> [(Int,Int,Int)]
21:37:28 <davo> give Couldn't match expected type `(a -> IO ()) -> a1 -> t' ...etc
21:39:40 <shachaf> davo: Presumably because those aren't the same type.
21:39:56 <rwbarton> can you paste the actual code and actual error message?
21:40:16 <rwbarton> those two lines don't produce any errors, by themselves.
21:40:17 <davo> ok
21:40:36 <shachaf> davo: That page doesn't mention IO anywhere so presumably it's something that you introduced, like a print statement.
21:41:08 <davo> shachaf: ah yes, i did. I was trying to run the script from a file
21:42:10 <davo> however, the first line given at an interactive prompt gives
21:42:13 <davo> <interactive>:1:0: Not in scope: `triple'
21:43:24 <shachaf> davo: That's once again an error message without context. :-)
21:43:38 <bd_> davo: the code given is for use in a non-interactive source file
21:43:44 <bd_> ie, you enter it into triple.hs and :load triple.hs
21:43:51 <bd_> or you can do let triple n = ...
21:44:08 <bd_> the 'let' here is a special interactive command to do an ad-hoc toplevel variable definition
21:46:04 <davo> ah yes that is working better :)
21:46:26 <davo> thank you
21:55:54 * hackagebot words 0.1 - Cross-platform access to a list of words  http://hackage.haskell.org/package/words-0.1 (ChrisSmith)
21:58:19 <robert[]> ets theorem
22:00:56 * hackagebot words 0.1.1 - Cross-platform access to a list of words  http://hackage.haskell.org/package/words-0.1.1 (ChrisSmith)
22:00:58 * hackagebot words 0.1.2 - Cross-platform access to a list of words  http://hackage.haskell.org/package/words-0.1.2 (ChrisSmith)
23:01:44 <thoughtpolice> ugh, i hate how haddock inexplicably breaks sometimes
23:11:50 <Cale> I hate how haddock *and* GHC both elide required parens around (otherwise) infix type variables when prettyprinting types.
23:12:55 <shachaf> Cale: GHC does that?
23:13:17 <copumpkin> bug reportz
23:13:58 <shachaf> copumpkin: But then there'd be nothing to hate.
23:14:17 <copumpkin> true
23:14:20 <shachaf> The GHC developers need to introduce annoyin-but-meaningless little bugs to keep The People in check.
23:14:32 <shachaf> Who knows what Cale might do if all the trivial annoyances were fixed?
23:14:36 <copumpkin> We Are The 99% of Haskell Programmers
23:14:43 <copumpkin> REBEL AGAINST THE MAN
23:15:02 <Cale> I think it only happens in error messages, not in the output of :t
23:15:02 <copumpkin> THE TWO SIMONS WIELD TOO MUCH POWER
23:15:35 <djahandarie> We need to turn GHC development into a democracy!
23:15:36 <RomyCtrlZ> copumpkin: cooooool cool name…  i realize i haven't had pumpkin in over a year
23:15:38 <djahandarie> POWER TO THE PEOPLE!
23:15:39 <shachaf> Come to think of it, has anybody ever seen the two Simons together in the same room?
23:15:41 <Cale> (if there are explicit type synonyms in the prettyprinted source...)
23:15:49 <Cale> I'll have to try to get a testcase for that
23:15:55 <Cale> Haddock does it all the time though
23:15:57 <djahandarie> shachaf, conspiracy theory?
23:16:12 <Cale> er, explicit type signatures*
23:16:44 <shachaf> djahandarie: I'm just saying. Has JaffaCake ever publicly claimed not to be the same person as SPJ?
23:17:05 <Cale> oh, got one :)
23:17:06 <copumpkin> I hear JaffaCake1 once wrote a line of suboptimal code
23:17:12 <copumpkin> why is he not denying this?!
23:17:15 <copumpkin> does he have something to hide!?!
23:17:52 <hpaste_> Cale pasted “Example of syntax error in error output” at http://hpaste.org/52392
23:18:12 <elliott> Is JaffaCake1 actually one Jaffa cake, or does he have something up his sleeve?
23:18:17 <elliott> Perhaps... a second Jaffa cake?
23:18:43 <shachaf> Cale: Oh, when you said "types" you meant "types".
23:20:20 <Cale> It prints "Event (~>) a" as "Event ~> a" there
23:20:30 * elliott has noticed that before
23:20:50 <Cale> It doesn't do it in the output of :t thankfully
23:20:59 <Cale> ghci> :t gate
23:20:59 <Cale> gate :: ArrowEvent (~>) => (~>) (Event (~>) a, Bool) (Event (~>) a)
23:21:19 <Cale> That's at least correct.
23:21:51 <shachaf> Is "~>0" actually a valid name?
23:22:25 <djahandarie> Cale, oh wow, that's annoying
23:23:10 <hpaste_> Cale pasted “smaller testcase” at http://hpaste.org/52393
23:23:30 <djahandarie> lol
23:23:42 * elliott would have a stab at fixing that, but /last/ time he tried to fix error-message pretty printing he checked out all of git just to find it was already fixed.
23:24:47 <copumpkin> shachaf: yes
23:24:51 <copumpkin> no
23:26:09 <Cale> Interestingly, it will give a kind error for True :: Either (->) (->), but doesn't mess up the syntax. Probably just because (->) receives special treatment.
23:27:19 <djahandarie> When I first saw the error I thought it was due to the constructor being both applied and passed as a parameter. But it's apparently just completely broken (except for (->)). :P
23:33:32 <davo> why do i get Week3.hs:8:0: parse error (possibly incorrect indentation) on this module http://paste.pocoo.org/show/490245/
23:33:57 <shachaf> davo: You're mixing tabs and spaces.
23:34:01 <shachaf> davo: Indent with spaces only.
23:34:16 <davo> shachaf: yuk, really no tabs? :(
23:34:32 <shachaf> You *can* use tabs but most people here will tell you that it's not a good idea.
23:35:05 <davo> true, its worked on some cases, but perhaps that's what's jamming this time
23:35:15 <shachaf> If you do, just indent the -- wait, that syntax isn't even valid.
23:35:15 <davo> thanks, i'll investigate and try with only spaces
23:35:30 <shachaf> Those semicolons are invalid -- they should be commas -- and you're not closing your '['.
23:35:31 <Cale> davo: Just configure your texteditor to convert tabs to spaces automatically
23:35:39 <Cale> All good text editors have this feature :)
23:35:45 <Peaker> I don't understand how otherwise reasonable people fail to comprehend that putting a character in files that is interpreted differently by almost every single editor in existence, is a bad idea
23:35:50 <Cale> (practically everything other than notepad)
23:36:17 <davo> shachaf: ah that closing ] is definitely embarassing :)
23:36:25 <Peaker> Not to mention -- the only way to get the acclaimed benefits of tabs -- is to use tabs for indent, spaces for align -- and virtually no editors support this, and those that do need to be specially configured to do so (and virtually noone does that)
23:36:30 <davo> Cale: good idea, i'll look into that with my editor
23:36:53 <Cale> davo: If you're using vim, you'll want to add  set expandtab  to your .vimrc
23:37:04 <Peaker> I also don't understand why most code editors come preconfigured for putting these horrible characters into files.. I suffer from spurious conflicts so much because of that stupidity
23:37:10 <Cale> For emacs, (setq-default indent-tabs-mode nil)
23:37:16 <shachaf> smarttab is also good.
23:37:24 <Cale> yeah, smarttab is also good :)
23:37:55 <hpaste_> Cale pasted “My .vimrc” at http://hpaste.org/52394
23:38:54 <Cale> I also have some autocmd's there which highlight bad whitespace
23:39:04 <Cale> (tabs and end of line whitespace)
23:40:02 <shachaf> Cale: You don't need autocmds for that.
23:40:20 * shachaf has set listchars=tab:>-,trail:☢ " U+2622
23:40:27 <shachaf> (And set list)
23:40:49 <shachaf> Well, I guess that's not highlighting.
23:43:54 <hpaste_> cwl pasted “STM pure?” at http://hpaste.org/52395
23:44:01 <cwl> http://hpaste.org/52395
23:44:22 <cwl> is basicTransfer pure?
23:44:42 <cwl> It looks like alice and bob are modified by basicTransfer
23:44:43 <copumpkin> pure?
23:44:49 <copumpkin> it's an STM action
23:45:08 <cwl> copumpkin: how to understand it?
23:45:19 <cwl> @type STM
23:45:20 <lambdabot> Not in scope: data constructor `STM'
23:46:20 <copumpkin> cwl: they're "modified"
23:46:45 <copumpkin> but that's tracked by the STM type
23:47:10 <cwl> copumpkin: ah??!!
23:47:36 <copumpkin> I'd look at the same thing in IO
23:47:39 <copumpkin> and see if you understand that
23:48:49 <shamster> hey folks, I'm quite unpracticed in making things tail recursive, and I'm wondering how one would go about making this function tail-recursive: http://pastebin.com/SDXPjSQg
23:48:51 <mauke> The paste SDXPjSQg has been copied to http://hpaste.org/52396
23:49:11 <mauke> shamster: why would you want to?
23:49:24 <shamster> mauke: To learn how to make things tail recursive
23:49:26 <mauke> that function is pretty much optimal
23:50:03 <shamster> mauke: Is it not necessary in haskell to make it tail recursive in order to save on memory?
23:50:10 <mauke> uh, no?
23:50:24 <ddarius> In some cases it is, and in some cases that is a pessimatization.
23:50:27 <shamster> Will it blow up if I feed it a list with several million elements?
23:50:31 <ddarius> No.
23:50:37 <mauke> your function will work on infinite lists
23:50:46 <mauke> (a tail recursive version wouldn't)
23:51:38 <shamster> mauke: okay, I may need a different example, then
23:51:47 <kmc> cwl, the key is that evaluation is different from execution
23:51:52 <frerich2> shamster: I think that's a really good question, because I just noticed that I always thought the same as you (but it seems it's wrong) :-)
23:51:55 <kmc> evaluating an STM action (or an IO action) has no side effects
23:52:08 <copumpkin> (only intended effects!)
23:52:21 <copumpkin> (executing them)
23:52:44 <ddarius> (())
23:52:51 <copumpkin> ((()))
23:52:57 * copumpkin goes to sleep
23:53:07 <cwl> kmc: is STM like IO
23:53:07 <ddarius> Mission accomplished.
23:53:24 <kmc> cwl, they are similar in many way
23:53:25 <cwl> kmc: or STM is wrapped in IO
23:53:46 <kmc> STM is more restricted than IO
23:53:51 <kmc> you can read and write transactional variables
23:53:53 <shamster> frerich2: I guess because it's consing a list together there's no burden on extra stack space
23:53:56 <kmc> but you can't write files, send network packets, etc.
23:54:20 <kmc> cwl, but you can run any STM action in IO, atomically
23:54:21 <shamster> frerich2: if it were building up deep recursion calls, then we'd have a lot of extra overhead... I think
23:54:28 <kmc> which you can't do for IO in general
23:54:42 <ddarius> shamster: Don't just guess random theories.
23:55:40 <shamster> ddarius: why's that?
23:56:02 <kmc> I guess that "atomically" provides both atomicity and isolation, if you want to talk about http://en.wikipedia.org/wiki/ACID
23:56:04 <dolio> Cale: Your highlighting doesn't seem to work here....
23:56:45 <Cale> dolio: huh
23:57:19 <ddarius> shamster: You are unlikely to guess a correct model which means you will actively be constructing broken programs and will be completely confused about why they don't work.  It's also unnecessary.  This is logic.  You can calculate.
23:57:50 <frerich2> shamster: The one thing I notice is that due to the lazyness of Haskell, I find reasoning about the performance of programs to be pretty tricky. In this case, I suspect that even though swapList is not tail recursive, the runtime system can garbage collect thunks which are not used or the like.
23:58:07 <frerich2> shamster: It's most likely wrong, but just something which came to my mind.
23:58:13 <kmc> the old FP advice of "tail recursive = efficient" is not really true in Haskell
23:58:24 <kmc> often the non-tail-recursive function will have much nicer performance characteristics
23:59:11 <ddarius> I don't understand this desire to not understand what's going on and to make up random theories, then complaining about how complicated lazy evaluation is even though no effort was ever spent on attempting to understand it.
23:59:11 <kmc> (with common implementations, anyway)
23:59:37 <kmc> ddarius, it works in other contexts
23:59:54 <kmc> fsvo "works"
