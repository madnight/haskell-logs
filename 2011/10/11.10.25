00:23:27 <mmaruseacph2> !help lambdabot
00:25:45 <akosch> I'm having trouble debugging my pure code... got a bit used to inserting print statements all over the code in other languages, but in a lazy language this doesn't seem to be a good idea (also I obviously can't do it for pure code)
00:26:54 <bartavelle> I, I would like to write a library that would emulate the most used functionalities of the "erb" ruby template format
00:26:59 <bartavelle> hum
00:27:01 <bartavelle> s/^I/hi/
00:27:26 <bartavelle> is there any library I should look at ?
00:27:37 <bartavelle> either for inspiration, or usage
00:29:23 <ddarius> @quote refreshing.desert
00:29:24 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
00:32:29 <akosch> ddarius: oh, wow. thanks! I'm off to litter my code with this ;)
00:32:31 <zzo38> Is it possible to represent isomorphism directly by the type system?
00:33:17 <zzo38> if GHC extensions are used?
00:36:59 <ddarius> Not in Haskell's type system and not sanely.  You can easily represent a type that contains all (computable) isomorphisms, and you can represent type equality.
00:38:50 <ivanm> zzo38: isomorphism of what? (just out of curiousity)
00:38:51 <zzo38> If it cannot be done sanely, can it be done insanely?
00:39:23 <zzo38> ivanm: Isomorphism of two types, meaning there exists an isomorphism (as in category theory) between them, making them isomorphic.
00:40:10 <ivanm> right, wasn't sure if you were talking about any particular type of value (graphs, etc.)
00:40:33 <ivanm> I don't think you can really express that thing in the type-system per se, or at least not easily (since the type-system is technically turing complete)
00:40:49 <erus`> Does anyone know of a library to handle storing retrieving data by date?
00:40:50 <ivanm> might be able to do something like that in agda though; don't have any experience with agda myself to be able to tell
00:41:23 <zzo38> I know of many type system extensions in GHC; can any of those help at all?
00:42:53 <erus`> like i want to be able to retrieve all events in a specific month
00:44:20 <ddarius> It would be trivial in Agda.
00:44:23 <ivanm> zzo38: well, you need them to make the type system turing complete
00:44:48 <ddarius> erus`: Retrieving it from what?
00:44:57 <ivanm> but whilst you can state something like "these two types are the same", there's no real way of testing for isomorphism in the type system AFAIK
00:45:08 <ivanm> ddarius: I think he wants some kind of fuzzy time-based lookup
00:45:24 <ddarius> That's not relevant to my question.
00:45:28 <erus`> ddarius: a value or database or anything
00:46:41 <frerich> erus`: Do you just need a function to tell whether a given date matches some given filter (like, "Is in the second week of march 2001")?
00:47:12 <zzo38> Would having the feature to make types that represent isomorphism, be useful in the study of reversible computing?
00:47:14 <erus`> frerich: im just thinking of a good way to store and retrieve appointments
00:47:26 * ddarius really likes kmc's quasicrystal animation.
00:47:36 <Blkt> good morning everyone
00:48:29 <yitz> erus`: look at time-recurrence and relative-date packages
00:49:02 <ddarius> erus`: Also look at Microsoft Outlook.
00:49:12 <yitz> erus`: also, Ranged-sets package might be helpful
00:49:34 <yitz> ddarius: eww, ms outlook
00:50:06 <yitz> ddarius: perhaps you meant Google Calendar or Apple iCal, which actually work
00:50:33 <yitz> ddarius: i've heard that even Mozilla Thunderbird has a pretty good calendar component
00:50:47 <ddarius> Too bad Thunderbird sucks otherwise.
00:50:58 <yitz> ddarius: yeah too bad
00:52:00 <harblcat> why does the example in the docs for Network.Browser throw an error?
00:52:28 <yitz> erus`: it would be cool to have an app like hledger for calendars - library written in Haskell, actually works well, standards compliant, with various kinds of UI front ends
00:52:46 <erus`> im writing a room/hardware booking system for work
00:52:51 <erus`> with snap hopefully :)
00:53:39 <ddarius> Surely, there's some off-the-shelf software that can be used for that for probably a lot less than the development costs.
00:53:47 <yitz> erus`: another feature could be integration with exchange servers and outlook, but that somewhat conflicts with the standards compliance part
00:54:10 <erus`> yitz yeah that would be nice
00:54:21 <akosch> what array package would I use in the following scenario: I need small updates to be efficient (e.g don't copy the whole thing) and I don't need to access the old version after an update.
00:54:26 <erus`> i doubt there is a snap-exchange package though
00:54:41 <yitz> erus`: don't hardwire snap deeply inside. make it a library, it should be easy then to give it a command-line front-end and a snap front-end, to start with.
00:54:56 <erus`> yitz yeah thats the plan
00:54:57 <ddarius> akosch: DiffArray may work, or an IntMap or a mutable array.
00:55:21 <luite> hledger has the yesod web interface as a separate package I think
00:56:16 <akosch> ddarius: the wiki says: Since GHC-6.12, DiffArray has been splitted off into separated package due to its "unusably slow".
00:56:17 <yitz> erus`: this sounds like a great project. please keep us up-to-date about it. and publish the result on hackage!
00:56:17 <akosch> ddarius: should I still try using it?
00:56:58 <ddarius> akosch: I would probably just use an IntMap.
00:57:38 <yitz> erus`: you can talk to an exchange server using webdav, i think.
00:57:40 <zzo38> That would be an idea, then; make another kind of function type that is only allowed to contain isomorphisms; and allowing the inverse to be automatically derived in such case. It might help with study of reversible computing.
00:57:48 <akosch> ddarius: I have tuples of Integers as keys
00:58:08 <akosch> ddarius: sorry, I didn't mention that :)
00:58:29 <yitz> erus`: so getting something that basically works probably isn't too hard. the real challenge then is how many weird quirks you're able to handle.
00:58:47 <erus`> well, one step at a time
00:58:52 <yitz> right :)
01:00:03 <akosch> ddarius: maybe Data.Map would be a good choice?
01:00:25 <ddarius> :t index
01:00:26 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
01:01:20 <yitz> luite: right. i think that design is nice.
01:01:39 <yitz> hi Blkt
01:04:04 * ddarius thinks we should drop the C off of CPU.
01:05:55 <yitz> akosch: start out with a Map, IntMap, or Sequence, they're the simplest, and quite efficient. updates only replace a single node, plus a few pointers (O(log n)).
01:06:44 <hpaste> harblcat pasted “Network.Browser doc error?” at http://hpaste.org/53103
01:07:09 <yitz> akosch: arrays can sometimes be a bit faster, but i think they are premature optimization unless you know you need them.
01:07:40 <yitz> s/arrays/mutable arrays/
01:08:02 * ddarius waits for a Haskeller to implement an APL interpreter using Maps.
01:08:37 <Younder> I would think with ever more cores one would strive for better paralellization , not ways of breaking functional independence
01:08:41 <yitz> ddarius: why wait? get to work.
01:08:56 <ddarius> yitz: I've considered it several times, minus the Maps.
01:09:00 <yitz> heh
01:09:43 <ddarius> Maybe I should do it in Beluga though.
01:10:12 <yitz> ddarius: you can do it in the Canary Islands, too.
01:10:25 <Younder> lol
01:11:25 <Younder> complogic.cs.mcgill.ca/beluga/
01:11:48 <mm_freak> is there a way to specify the fixity for operator variables?
01:11:49 * ddarius considers making programming languages named after major cities.
01:11:55 <ddarius> "I'm programming in Seattle."
01:12:08 <akosch> yitz: hm, I've used Sequence before for a heap and it was quite nice. My current code uses Data.Array so it's not really a case of premature optimization, but I also think Data.Map will do nicely.
01:12:14 <ddarius> @google Seattle programming language
01:12:16 <lambdabot> http://www.meetup.com/Seattle-useR/
01:12:16 <lambdabot> Title: Seattle useR Group (R Programming Language) (Seattle, WA) - Meetup
01:12:40 <akosch> yitz: thanks for the advice
01:12:52 <yitz> akosch: if you need mutability, the question is whether your current code is already in the ST monad.
01:13:24 <akosch> yitz: it isn't
01:13:25 <Younder> R is statistics, thought with the GREAT support for statistics in Mathematica I use that these days.
01:14:00 <yitz> i was kind of hoping that search would come up with J, not R.
01:14:40 <Younder> well to my knowlege there is no J.. next project ;)
01:15:24 <yitz> akosch: in that case, it's not clear whether it would be easier to refactor into the ST monad than to refactor to use a Map.
01:16:27 <yitz> mm_freak: why not?
01:18:54 <akosch> yitz: what would be the advantages of each? I'd rather not use the ST monad if I don't need to...
01:21:27 <yitz> akosch: arrays make it easier for real down-and-dirty optimization, because you are explicitly manipulating actual memory. especially if you can arrange to use one of the types which allow unboxed arrays.
01:21:47 <yitz> akosch: but if you need mutability, it forces all your code into the ST monad
01:21:57 <erus`> @hoogle [IO String] -> IO [String]
01:21:58 <lambdabot> No results found
01:22:12 <erus`> @hoogle [m ] -> m [a]
01:22:12 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
01:22:12 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
01:22:12 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
01:22:15 <erus`> @hoogle [m a] -> m [a]
01:22:15 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
01:22:15 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
01:22:15 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
01:22:37 <donri> ok so apparently i still don't get arrows. how come @arr (+1)@ can be passed an argument despite not having any -> in its type?
01:22:38 <yitz> akosch: the tree-based containers still allow pretty fast mutability while maintaining nice purely functional style code
01:23:13 <mm_freak> yitz: add :: (Arrow (>~), Num a) => a >~ a >~ a
01:23:15 <mm_freak> won't work
01:23:19 <ddarius> donri: I can verify that you really aren't getting arrows.  You are also not getting Haskell's type system.
01:23:27 <mm_freak> i'd like to specify that (>~) is right-associative
01:23:35 <mm_freak> but it's a variable
01:23:42 <donri> ddarius: quite :)
01:24:05 <yitz> mm_freak: ah i see, that's your problem. right.
01:24:45 <yitz> mm_freak: you meant operator *type* variables
01:24:53 <mm_freak> yitz: variables in general
01:25:45 <yitz> mm_freak: so for regular variables, you mean, let's say, variables introduced in a pattern?
01:25:56 <akosch> yitz: I think I'll go with Data.Map, it's a big improvement over copying around arrays I hope :)
01:26:06 <mm_freak> yitz: yes
01:26:16 <mm_freak> yitz: but really type operator variables would be more important
01:27:19 <donri> my guess would be that (->) isn't all that special and that "arguments" are merely "filling in" values for type variables?
01:28:14 <ddarius> donri: Why guess?  You can just read about how the type system works.
01:29:23 <yitz> mm_freak: from the Report: "Also like a type signature, a fixity declaration can only occur in the same sequence of declarations as the declaration of the operator itself..."
01:29:43 <mm_freak> yitz: unfortunately there is no declaration in this case
01:29:45 <yitz> mm_freak: which implies that they can only be used for symbols that are declared, i think.
01:29:50 <yitz> yeah
01:30:03 <mm_freak> ok, then it seems to be impossible =/
01:30:03 <yitz> mm_freak: sounds like that would be a simple and useful extension
01:30:10 <mm_freak> totally
01:30:14 <ddarius> mm_freak: Time to implement first-class modules.
01:30:25 <mm_freak> ddarius: how would they help here?
01:30:28 <ddarius> yitz: Doesn't seem useful to me.
01:31:24 <yitz> ddarius: mm_freak needs them, that convinces me.
01:31:42 <ddarius> mm_freak: Presumably fixity declarations would be exported by a module along with the names.  It still wouldn't allow you to do exactly what you want, but you could get the effect by declaring and opening a module locally.
01:32:06 <mm_freak> ddarius: i see
01:32:15 <erus`> whats the short name for \a b -> take a $ repeat b
01:32:25 <ddarius> replicate
01:32:50 <erus`> thanks
01:33:00 <yitz> > replicate 5 'a'
01:33:01 <lambdabot>   "aaaaa"
01:33:11 <ddarius> @. @hoogle @type \a b -> take a $ repeat b
01:33:12 <lambdabot> Plugin `compose' failed with: Unknown command: "@hoogle"
01:33:18 <ddarius> @. hoogle type \a b -> take a $ repeat b
01:33:19 <lambdabot> Parse error:
01:33:19 <lambdabot>   --count=20 "forall a. Int -> a -> [a]
01:33:19 <lambdabot> "
01:33:26 <ddarius> Stupid forall.
01:33:51 <ddarius> Or rather stupid Haskell 1.0 for not requiring explicit foralls from the get-go.
01:33:51 <yitz> ddarius: use @@ and delete it
01:34:05 <ddarius> yitz: Too much work.
01:36:42 <yitz> @@ @hoogle . text . drop 1 . dropWhile (/= '.') . show . @type $ @read "\a b -> take a $ repeat b"
01:36:42 <lambdabot>  Parse error:
01:36:43 <lambdabot>   --count=20 ". text . drop 1 . dropWhile (/= '.') . show . parse error on input `$'
01:36:43 <lambdabot> "
01:37:19 <yitz> @@ @. hoogle @@ text . drop 1 . dropWhile (/= '.') . show . @type $ @read "\a b -> take a $ repeat b"
01:37:20 <lambdabot> Plugin `compose' failed with: Unknown command: ""
01:37:34 <yitz> don't know how to use @@
01:38:26 <yitz> @. hoogle @@ text . drop 1 . dropWhile (/= '.') . show . @type $ @read "\a b -> take a $ repeat b"
01:38:26 <lambdabot> Plugin `compose' failed with: Unknown command: "@@"
01:38:39 <yitz> @. hoogle @ text . drop 1 . dropWhile (/= '.') . show . @type $ @read "\a b -> take a $ repeat b"
01:38:40 <lambdabot> Parse error:
01:38:40 <lambdabot>   --count=20 " text . drop 1 . dropWhile (/= '.') . show . parse error on input `$'
01:38:40 <lambdabot>  
01:43:45 <yitz> @help @
01:43:45 <lambdabot>  @ [args].
01:43:45 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
01:43:45 <lambdabot>  The commands are right associative.
01:43:45 <lambdabot>  For example:    @ @pl @undo code
01:43:45 <lambdabot>  is the same as: @ (@pl (@undo code))
01:44:53 <yitz> @help run
01:44:54 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
01:46:00 <Younder> GHC -i
01:47:17 <Younder> Interactive is the way to go
01:50:27 <yitz> @help show
01:50:27 <lambdabot> show <foo>. Print "<foo>"
01:50:33 <yitz> @help read
01:50:33 <lambdabot> read "<foo>". Print <foo>
01:51:24 <Younder> @help @help
01:51:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:51:24 <Younder> lol
01:52:40 <Younder> A private session is probably better for that sort of thing instead of having your fuckups on record to the end of time
01:52:54 <Younder> Just a thought
02:13:18 <yitz> @@ @hoogle @read (@run drop 1 $ dropWhile (/= '.') (@@ @show @type \a b -> take a $ repeat b))
02:13:19 <lambdabot>  Prelude replicate :: Int -> a -> [a]
02:13:20 <lambdabot> Data.List replicate :: Int -> a -> [a]
02:13:20 <lambdabot> Prelude drop :: Int -> [a] -> [a]
02:13:42 <yitz> ddarius, Younder: got it, yay!
02:16:18 <yitz> hey it even works without the parens:
02:16:20 <yitz> @@ @hoogle @read @run drop 1 $ dropWhile (/= '.') @@ @show @type \a b -> take a $ repeat b
02:16:22 <lambdabot>  Prelude replicate :: Int -> a -> [a]
02:16:22 <lambdabot> Data.List replicate :: Int -> a -> [a]
02:16:22 <lambdabot> Prelude drop :: Int -> [a] -> [a]
02:28:06 <yitz> so i think the general syntax is: "@@ op1 op2 ... opLast" where each opN is either "@<plug-in>" or "@read @run <expr> @@ @show" where expr is a Haskell expression of type String -> String, and opLast is "@<plug-in> args".
02:31:43 <yitz> more specifically, expr is a Haskell fragment which forms an expression of type String when you append a string literal. so in particular, it can be any expression of type String -> String enclosed in parentheses.
02:33:19 <yitz> sigh. i wish i knew that while @vixen was still alive.
02:39:06 <erus`> What do i call the location of something in a tree
02:39:31 <erus`> A -> C -> D -> E
02:40:29 <erus`> ah a path, right?
02:42:10 <mah_b> erus`: yes, if A,C,D,E are nodes
02:50:03 <ivanm> if I want to take advantage of build/foldr fusion, is that automatic or do I need to provide my own RULEs for it?
02:50:36 <quicksilver> it's automatic if you express your function using 'build' which is, sometimes, a slightly unnatural feeling way to do it
02:50:45 <quicksilver> the prelude stuff has RULES to rewrite stuff into build form
02:51:48 <ivanm> is build defined somewhere?
02:51:57 <ivanm> or is it a matter of defining a build-like function?
02:53:54 <Saizan> GHC.Exts.build
02:54:51 <dibblego> @hoogle lookupBy
02:54:52 <lambdabot> No results found
02:54:57 <dibblego> :(
02:55:14 <ivanm> huh, hayoo didn't seem to find that...
02:55:26 <dibblego> don't think it exists
03:00:10 <ivanm> hmmm, looks like unfoldr isn't written in terms of build though.... and unfoldr matches what I want to do rather well... :s
03:02:15 <quicksilver> ivanm: unfoldr is rewritten to build by a rule.
03:02:21 <quicksilver> or at least, I imagine it is.
03:02:26 <ivanm> it is? didn't see it in the source...
03:02:47 <erus`> Constructors as types would be useful ...
03:02:54 <yitz> what is the type of build?
03:03:08 <quicksilver> or....
03:03:16 <quicksilver> there are rules for unfoldr at least
03:03:22 <quicksilver> I would use unfoldr and see if it works
03:03:28 <ivanm> quicksilver: I can't find them in Data.List
03:03:40 <ivanm> yitz: build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
03:03:44 <ivanm> erus`: hmmm?
03:04:24 <erus`> like data A = B | C   i only want a function to deal with C's
03:04:48 <ivanm> erus`: you could use Maybe for that...
03:04:56 <ivanm> or just define a new data type just for C
03:05:06 <ivanm> or rather than Maybe, make an unsafe function (e.g. head)
03:05:10 <quicksilver> ivanm: maybe I'm wrong.
03:05:16 <quicksilver> is there a plan to move GHC to stream fusion?
03:05:48 <quicksilver> erus`: yes, sometimes it's annoying.
03:06:03 <quicksilver> in fact, in the general case you will sometimes want a data type which represents some subset of the constructors
03:06:18 <quicksilver> data A = B x | C y | D z | E w
03:06:30 <quicksilver> and you want a data type for "C or E but not the two other cases"
03:06:55 <quicksilver> there is no simple perfect solution. Write the ones which have the right power/weight ratio.
03:07:04 <quicksilver> See "Data types a la carte" for a unified approach
03:08:26 <yitz> so what does it mean to "rewrite unfoldr to build"? it has a different type.
03:09:06 <ivanm> quicksilver: I just happened to come across the GHC bug about that :p  turns out no-one has any idea how to define concat/concatMap using streams, so they're not going to switch until they do
03:09:36 <ivanm> yitz: more about defining unfoldr by using build, so that foldr f . unfoldr g could have the intermediary list fused away
03:10:26 <yitz> so you want to express it as build . something ?
03:10:47 <yitz> @type unfoldr
03:10:48 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
03:11:50 <quicksilver> not build . something, no.
03:11:52 <quicksilver> build something
03:11:53 <yitz> hmm, so you want unfoldr f = build . something f ?
03:12:17 <yitz> build something has the wrong type
03:12:34 <ivanm> well, not that I necessarily want it, but it'd be nice
03:12:40 <quicksilver> unfoldr f x = build something
03:12:47 <ivanm> since I'm generating a list only as an intermediary stream-like data structure
03:12:50 <rtharper_> that is doable
03:12:54 <yitz> ok, i.e. what i wrote
03:13:45 <rtharper_> you can write unfoldr in terms of build
03:14:28 <Younder> RIP John McCarthy
03:14:51 <ivanm> rtharper_: how?
03:15:09 <ivanm> if you can do so, you should probably send a patch in with said implementation
03:15:10 <yitz> and Dennis Ritchie
03:15:51 <ivanm> well, someone tried to imply "and Donald Knuth", but wasn't too convincing: http://www.reddit.com/r/programming/comments/lnz50/donald_knuth_one_of_the_pioneers_of_computer/
03:16:41 <Younder> I have the triology and 4A
03:17:28 <Younder> Don't think it will ever be finished though
03:18:30 <yitz> @quote ritchie
03:18:30 <lambdabot> No quotes match. Take a stress pill and think things over.
03:18:52 <yitz> @remember ritchie C has the power of assembly language and the convenience of ... assembly language.
03:18:52 <lambdabot> Nice!
03:21:45 <hpaste> sioraocht pasted “unfoldr using build” at http://hpaste.org/53106
03:21:52 <rtharper_> ivanm: ^
03:22:15 <rtharper_> oops, rtharper*
03:22:17 <rtharper_> heh
03:22:39 <ivanm> *tsk, tsk* :p
03:23:18 <rtharper_> ivanm: nevertheless, there you are =p
03:23:24 <ivanm> ta
03:23:57 <rtharper_> ivanm: you can compare that also with "repeat" from the original foldr/build paper
03:24:12 <ivanm> *nod*
03:24:16 <rtharper_> which is repeat x = build (\ c n > let r = c x r in r)
03:24:22 <ivanm> I did read that a while back...
03:24:49 <ivanm> maybe they don't use such a definition of unfoldr because - according to the wikipage - there's a destroy/unfoldr rule...
03:25:03 <rtharper_> ivanm: only foldr/build is implemented in GHC at the moment
03:25:08 <ivanm> *nod*
03:25:21 <rtharper_> destroy/unfoldr (and its extension, stream fusion) does not handle concatMap efficiently
03:25:29 <rtharper_> or concat
03:26:18 <ivanm> *nod*
03:31:21 <rtharper_> note to self
03:31:28 <rtharper_> get out of the computer business before old age sets in
03:31:48 <rtharper_> rawr I left my IRC on at home
03:50:13 <erus`> whats a good collective name for (A group of things, a thing)
03:50:45 <erus`> no i mean like a branch
03:52:04 <DanielDiaz> I hate when typing "cabal install something" ends in "Error: The package has a './configure' script." ò_ó
03:52:52 <dcoutts> DanielDiaz: one day we'll integrate that into the dependency planner
03:56:19 <DanielDiaz> dcoutts: Yes, that will be good. (: I'm avoiding (as I can) this error for years.
04:02:51 <ketil> Anybody understand nVidia, CUDA, and related Haskell libraries/frameworks?  We might be getting a new number-crunching box, and I wonder if there's any point to selecting one or another graphics card.
04:03:24 <ketil> E.g. do I need a Tesla card to use Accelerate?  Will a Quadro do?  Or can I just use any plain old nVidia card?
04:04:12 <khs> http://developer.nvidia.com/cuda-gpus
04:06:42 <ketil> khs: from this, I conclude that any nVidia card supports CUDA, and it's just a matter of number of CUDA processors and memory.  The distinguishing factor for Tesla is ECC RAM?
04:07:51 <sohum> so how large are typical haskell programs?
04:08:49 <sohum> as in: I have an eight-hundred line program, and I want to know if it's small, medium, or large
04:08:50 <khs> ketil: I don't know, I would check to see if I could find it in the list
04:09:16 <ketil> Most answers here: http://developer.nvidia.com/cuda-faq
04:26:57 <erus`> > msum [ Nothing, Just 123]
04:26:58 <lambdabot>   Just 123
04:27:05 <erus`> > msum [ Nothing, Just 123, Nothing, Just 1234]
04:27:06 <lambdabot>   Just 123
04:30:15 <erus`> is their a synonym for msum . map ?
04:31:08 <mike-burns> :t msum . map
04:31:09 <lambdabot>     Couldn't match expected type `[m a]'
04:31:09 <lambdabot>            against inferred type `[a1] -> [b]'
04:31:09 <lambdabot>     Probable cause: `map' is applied to too few arguments
04:32:12 <chra> :t (msum .) . map
04:32:13 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
04:32:57 <erus`> like first-return
04:33:05 <erus`> first-non-fail
04:47:06 <yitz> @type choice
04:47:07 <lambdabot> Not in scope: `choice'
04:47:18 <yitz> @type Control.Applicative.choice
04:47:19 <lambdabot> Not in scope: `Control.Applicative.choice'
04:47:26 <yitz> @hoogle Control.Applicative.choice
04:47:26 <lambdabot> No results found
05:07:21 <BlankVerse> i want to parallelize the call to "write imgPath a conn" in https://github.com/satvikc/reddit-image-downloads/blob/master/reddit.hs
05:08:25 <BlankVerse> 86:sequence $ map (saveFile conn imgPath) zipped
05:08:42 <BlankVerse> i guess if i make this parallel , it might work?
05:09:28 <BlankVerse> or is there any flag in ghc , which will "intelligently guess" and make this parallel?
05:10:43 <Axman6> no
05:11:49 <Axman6> firstly, sequence (map f ...) === mapM f ..., and you can use mapM_ (forkIO . f) to create a thread for each element in the list
05:20:12 <BlankVerse> reddit: SqlError {seState = "", seNativeError = 21, seErrorMsg = "prepare 32: INSERT INTO images VALUES (?,?): library routine called out of sequence"}
05:20:32 <BlankVerse> i dont see any major improvement , are all the threads waiting on the database?
05:23:09 <BlankVerse> Axman6: how do i profile in part the threads are spending most time
05:28:03 <erus`> how do i represent a day in history with haskell?
05:28:19 <erus`> like a ClockTime but all day
05:28:55 <RarrRaptor> You could probably use midnight ClockTimes. Perhaps define your own type.
05:29:43 <erus`> is there no librarys to represent timespan
05:29:57 <erus`> and perform boolean operations and stuff on them?
05:35:46 <Philonous> Is there a a way to force a garbage collection run from inside a program?
05:35:56 <ClaudiusMaximus> @hoogle performGC
05:35:57 <lambdabot> System.Mem performGC :: IO ()
05:36:38 <Philonous> thx
05:36:59 <BlankVerse> is there any fmapM_?
05:37:23 <RarrRaptor> What would fmapM_ do?
05:38:46 <RarrRaptor> WWFD?
05:38:52 <Philonous> BlankVerse: Data.Traversable.mapM is a more general mapM
05:39:18 <chra> BlankVerse: And Data.Foldable.mapM_
05:40:11 <BlankVerse> thanks, is there any way to profile and get stats , as which parts of my code are my threads spending most time on
05:40:26 <BlankVerse> i doubt all my forkIO threads are waiting on the database
05:42:11 <hpc> :t mapM
05:42:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:42:18 <hpc> @src mapM
05:42:18 <lambdabot> mapM f as = sequence (map f as)
05:42:28 <hpc> @src sequence
05:42:28 <lambdabot> sequence []     = return []
05:42:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:42:28 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
05:43:05 <hpc> sorta looks like a job for Traversable, not Functor
05:46:36 <tsousa> is there any function to return the all list except from the last element?
05:47:11 <Philonous> > init [1,2,3,4,5]
05:47:12 <lambdabot>   [1,2,3,4]
05:47:29 <dylukes> So, which Iteratee library do you folks like?
05:48:43 <dylukes> I've only really used enumerator myself.
05:49:06 <tsousa> Philonous, thanks
05:50:00 <ion> That’s like asking “do you like taking the medicine intravenously or rectally?”
05:50:45 <dylukes> ion: >_>
05:51:38 <ion> Anyhoo, i haven’t studied anything else than enumerator either.
06:09:07 <frerich> http://crashlanden.files.wordpress.com/2009/11/fantastic-mr-fox5.jpg <-- this happens if you use too many point-free expressions in your Haskell program.
06:09:44 <RarrRaptor> Awesome!
06:11:17 <vimix> is it possible to declare a type like this type P = [ 1 + 4*x | x <- [1..]]? or give such a set an name so, that i can write elem n P?
06:12:20 <sipa> :t elem
06:12:21 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:12:42 <sipa> :t [ 1 + 4*x | x <- [1..]]
06:12:43 <lambdabot> forall t. (Num t, Enum t) => [t]
06:14:19 <angstrom> vimix: what happens if n isn't in P?
06:20:56 <yitz> vimix: not directly. one thing you could do is newtype Int and hide the constructor. export a function to construct it that guarantees it will be in that set.
06:22:56 <vimix> yitz: hmm... ok
06:25:41 <RarrRaptor> @type let inSet x = mod x 4 == 1 && x > 4 in inSet
06:25:42 <lambdabot> forall a. (Integral a) => a -> Bool
06:33:20 * hackagebot carettah 0.0.7 - A presentation tool writtten with Haskell.  http://hackage.haskell.org/package/carettah-0.0.7 (KiwamuOkabe)
06:52:52 <ColonelJ> ehehehe http://img706.imageshack.us/img706/1547/languagewar.png
06:59:49 <rostayob> is there a Set implementation with a custom equality function?
06:59:57 <rostayob> well, a custom Ord function
07:00:03 <rostayob> what I want to do is represent equivalence classes
07:00:42 <opqdonut> represent them with a newtype with the relevant Eq instance
07:00:49 <hpc> ...ninja'd
07:01:01 <rostayob> opqdonut: the problem is that Data.Set doesn't have a function like 'a -> Set a -> a'
07:01:08 <rostayob> where it returns the element found
07:01:17 <opqdonut> ah, right
07:01:23 <rostayob> which might be equivalent but different than the one used for the lookup
07:01:27 <opqdonut> yeah
07:01:33 <rostayob> that would be useful
07:04:05 <rostayob> kmc: you're on top of hacker news!
07:04:08 <rostayob> well almost on top.
07:06:05 <mah_b> rostayob: you could use S.filter
07:06:27 <mah_b> rostayob: you could modify it to return just the first found.
07:08:20 * hackagebot tuple-th 0.2.1 - Generate (non-recursive) utility functions for tuples of statically known size  http://hackage.haskell.org/package/tuple-th-0.2.1 (DanielSchuessler)
07:10:48 <tsousa> i am trying to solve problem 16 on the 99 haskell problems
07:10:58 <tsousa> i already have this code http://dpaste.com/640845/
07:11:16 <tsousa> but i am doing some kind of error of logical error on the last line
07:11:26 <tsousa> can someone please help me?
07:12:30 <ColonelJ> what are the rules for these 99 problems
07:12:32 <dolio> tsousa: take(n-1) is a function
07:12:37 <ClaudiusMaximus> tsousa: dunno about that, but line 3 doesn't typecheck
07:13:02 <dolio> Doesn't agree with your output type.
07:13:22 <rostayob> mah_b: I'm rolling out my own, not going to take much
07:14:07 <dolio> And yes, line 3 is also wrong.
07:14:13 <tsousa> dolio, my ideia is to take n elements and return all elements except the element in the end of the list that will be the value that needs to go
07:14:21 <tsousa> i use init to it
07:14:27 <dolio> Take n elements of what?
07:14:29 <tsousa> and : to add all list together
07:14:33 <ColonelJ> [15:26] <ColonelJ> what are the rules for these 99 problems << anyone??
07:14:39 <tsousa> dolio, of some lists
07:14:54 <tsousa> ColonelJ, no rules i just need to solve the problems
07:15:11 <ColonelJ> well like there are library functions that are answers to some of these =.
07:15:30 <mah_b> ColonelJ: http://www.haskell.org/haskellwiki/99_questions
07:15:38 <BMeph> Hmm, "TOSKS" - Tuples of Statically Known Size. Sounds like something from Princess Bride 2. ;)
07:15:41 <tsousa> ColonelJ, yes but the point of making exercises is to improve
07:15:54 <ColonelJ> mah_b, where are the rules??
07:16:14 <tsousa> there is no rules
07:16:22 <tsousa> it is not a contest
07:16:40 <ColonelJ> I guess there's an implicit rule to only use Prelude
07:16:43 <tsousa> dolio, did you understand my doubts?
07:16:53 <mah_b> ColonelJ: there are none. it's to explore solutions using various methods.
07:17:22 <ColonelJ> meh well I'll have a fire through them
07:17:25 <byorgey> BMeph: "TOUS", like 17-tuples
07:17:25 <BMeph> ColonelJ: The only rule is: WIN! ;)
07:17:35 <ColonelJ> how come some are unsolved
07:17:57 <byorgey> haha, I am going to start making Fire Swamp references every time I see a 4-tuple or bigger from now on =)D
07:18:14 <BMeph> ColonelJ: Because you keep asking "Why" instead of Solving Them! Hurry up, already! ;)
07:18:21 <ColonelJ> ok
07:18:49 <BMeph> byorgey: Whatever you say, Wesley. ;)
07:20:37 <BMeph> Err, I mean DPB - "Dread Pirate BYorgey". :D
07:20:45 <saati> hi, what is USE_REPORT_PRELUDE?
07:21:24 <byorgey> haha, I like it =)
07:21:27 <tsousa> http://dpaste.com/640848/ like in here why it is not working?
07:22:02 <quicksilver> tsousa: dropEvery needs two parameters?
07:22:05 <byorgey> saati: a CPP flag specifying whether to use the version of the Prelude as preciesly defined in the Haskell Report, as opposed to a more efficient version used in practice
07:22:14 <tsousa> quicksilver, yes a list and a number
07:22:27 <quicksilver> tsousa: right, but you only give it one :P
07:22:28 <saati> byorgey: when is it defined?
07:22:52 <tsousa> [a] -> [Int] -> [a]
07:23:00 <tsousa> quicksilver,  ^ two
07:23:03 <quicksilver> tsousa: you are calling dropEvery with only one parameter
07:23:07 <quicksilver> tsousa: that is the bug in your paste.
07:23:11 <byorgey> saati: presumably if you wanted the Report version of the Prelude you would pass an argument to define it on the command line when compiling base, but I'm not sure
07:23:44 <saati> so generally's not defined
07:23:51 <saati> it's
07:23:57 <saati> thanks
07:24:28 <tsousa> quicksilver, http://dpaste.com/640850/
07:24:31 <byorgey> saati: right, I think so
07:24:47 <quicksilver> tsousa: I have told you several times
07:24:52 <quicksilver> tsousa: you are calling dropEvery with only one parameter.
07:24:57 <quicksilver> tsousa: it takes two. This is your mistake.
07:25:00 <tsousa> quicksilver, oh sorry wrong past
07:25:16 <tsousa> the i already put an other parameter on the code
07:25:54 <tsousa> quicksilver, http://dpaste.com/640851/
07:26:14 <quicksilver> tsousa: what do you think "map init" will do?
07:26:25 <quicksilver> init is a function on lists
07:26:30 <quicksilver> so "map init" needs a list of lists.
07:26:49 <tsousa> and i need a list of list
07:26:56 <tsousa> i will explain what i want to do
07:27:13 <quicksilver> tsousa: ok well "take n xs " isn't a list of lists
07:27:33 <tsousa> quicksilver, how can i make it create one for each call?
07:27:34 <quicksilver> tsousa: did you maybe mean "map init (take n xs : dropEvery xs n)
07:29:06 <quicksilver> @type let dropEvery xs n = map init (take n xs : dropEvery xs n) in dropEvery
07:29:07 <lambdabot> forall a. [a] -> Int -> [[a]]
07:29:16 <quicksilver> tsousa: this type-checks at least but I dno't think it makes sense.
07:29:24 <quicksilver> it's unusual to call yourself recursively with the same parameters.
07:29:49 <hpc> :t (&&&)
07:29:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:29:56 <hpc> :t (***)
07:29:57 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:30:20 <fasta> Which difference does Set.difference compute?
07:30:28 <fasta> Data.Set.difference*\
07:31:25 <tsousa> quicksilver, let's say that i input this dropEvery 3 [1,2,3,4,5,6] first step is to have this [[1,2,3],[4,5,6]] then cut off the tail then i have [[1,2],[4,5] then concat it and return [1,2,4,5]
07:31:27 <byorgey> fasta: just normal set difference
07:31:31 <byorgey> fasta: not symmetric difference
07:31:45 <fasta> byorgey: is symmetric difference also somewhere?
07:31:52 <byorgey> fasta: not that I know of
07:32:06 <quicksilver> tsousa: so, what about [1,2,3,4,5,6,7,8,9] ?
07:32:43 <quicksilver> tsousa: would your "first step" be [[1,2,3],[4,5,6],[7,8,9]] ?
07:34:04 <tsousa> yes if i do dropEvery 3 but if i do dropEvery 4 it will be [[1,2,3,4],[5,6,7,8],[9]]
07:34:30 <quicksilver> tsousa: OK, well you need to write the "first step" first I think
07:34:52 <quicksilver> tsousa: once you've done that, cutting of the tail and concatting will indeed be easy
07:34:57 <quicksilver> so concentrate on the first step
07:35:20 <tsousa> quicksilver, will be better if i do separated functions ?
07:35:44 <quicksilver> yes.
07:36:04 <ColonelJ> how do you load a file into the ghci
07:36:20 <tsousa> :l
07:36:50 <ColonelJ> tried that one and it said compiling Main and then invalid type signature :S
07:37:14 <byorgey> ColonelJ: well, perhaps you have an invalid type signature.
07:37:28 <ColonelJ> there isn't a Main function
07:37:28 <byorgey> ColonelJ: if you paste your file along with the error message on hpaste.org we can take a look.
07:37:45 <byorgey> ColonelJ: if you do not specify a module name, by default it is given the name Main
07:38:10 <ColonelJ> it's not a module I just wanted to load a function from the file
07:38:21 <byorgey> every .hs file is a module.
07:39:12 <byorgey> ColonelJ: you seem quite determined to prove that ghci is trying to screw you over, but I assure you it is just doing its job =)
07:39:46 <byorgey> ColonelJ: if you paste the file on hpaste.org we can help.
07:40:13 <ColonelJ> fine...
07:40:31 <ColonelJ> http://hpaste.org/new
07:40:38 <ColonelJ> oops
07:40:59 <hpaste> ColonelJ pasted “what's missing” at http://hpaste.org/53110
07:41:25 <byorgey> ColonelJ: Haskell identifiers cannot contain hyphens
07:41:38 <byorgey> you could call it element_at or elementAt
07:42:09 <kmc> or element'at but people will look at you funny
07:42:16 <byorgey> true =)
07:42:52 <ColonelJ> ok that works
07:43:22 <byorgey> great =)
07:43:26 <ColonelJ> I just blindly copied the hyphened version from the description of problem 3 though
07:44:18 <quicksilver> that was the lisp description, ColonelJ
07:44:26 <quicksilver> hyphens are valid in lisp idenfitiers.
07:44:37 <ColonelJ> I imagine so
07:44:44 <quicksilver> the page I'm looking at has (element-at in the LISP and elementAt in the Haskell
07:44:48 <quicksilver> http://www.haskell.org/haskellwiki/99_questions/1_to_10
07:45:12 <ColonelJ> yes, but that didn't stop me blindly using the lisp version by accident
07:45:56 <quicksilver> :)
07:46:07 <quicksilver> fortunately #haskell was here to help you.
07:48:02 <saati> (\(a,b) ~(as,bs) -> (a:as,b:bs)) what does this mean? especially the ~ part
07:48:14 <BlankVerse> how do i force the runhaskell to use the local cabal-dev directory instead of ~/.cabal
07:48:20 * hackagebot splot 0.2.5 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.2.5 (EugeneKirpichov)
07:48:20 <dmwit> ?remember byorgey you seem quite determined to prove that ghci is trying to screw you over, but I assure you it is just doing its job
07:48:21 <lambdabot> Good to know.
07:48:43 <ColonelJ> myLength = sum . map (\x -> 1)
07:48:48 <ColonelJ> killer solution
07:49:57 <dmwit> saati: It's an irrefutable pattern. It asks the compiler to delay evaluating the second argument (even to check that it is actually a tuple constructor at its top level) until absolutely necessary.
07:50:04 <dmwit> saati: Compare:
07:50:28 <dmwit> > let fIrrefutable ~(a,b) = 3; fRefutable (a,b) = 3 in (fIrrefutable undefined, fRefutable undefined)
07:50:28 <lambdabot>   (3,*Exception: Prelude.undefined
07:50:46 <BlankVerse> how do i force ghc to use local sandboxed cabal-dev?
07:51:40 <saati> thanks dmwit
07:51:52 <dmwit> saati: It's most often used on tuples, just the way you show; in those cases, you can translate it to something more understandable by using fst and snd.
07:52:05 <ceii_> BlankVerse, I don't think you can do it easily.
07:52:06 <dmwit> (\(a, b) arg2 -> (a:fst arg2,b:snd arg2))
07:52:37 <ceii_> do you really need tu use runhaskell? Compiling the program with cabal-dev build would solve the problem
07:53:07 <yitz> > let cons2 (a, b) ~(as, bs) = (a:as, b:bs) in take 1 . fst $ cons2 (2,4) undefined
07:53:09 <lambdabot>   [2]
07:53:32 <BlankVerse> ceii_: how do i compile the program with cabal-dev build?
07:54:02 <BlankVerse> i have yesod in my cabal-dev , but on ghc --make , i get the error cant find yesod
07:54:15 <BlankVerse> so ghc is unable to use my cabal-dev build?
07:55:09 <BlankVerse> and my .cabal is broken with dependency conflicts which doesnt allow me to install yesod in .cabal
07:55:22 <dmwit> BlankVerse: Yes, you shouldn't mix manual invocations of ghc with cabal-dev.
07:56:09 <BlankVerse> dmwit: am i confusing the use of cabal-dev .... isnt it supposed to be used by ghc in the local directory?
07:56:09 <dmwit> No.
07:56:22 <BlankVerse> like preferring the cabal-dev directory and then the global cabal package
07:56:29 <dmwit> No.
07:56:59 <dmwit> Things built with cabal-dev will never use the global cabal package database.
07:56:59 <dmwit> s/cabal package database/package database/
07:57:08 <dmwit> (That's the point of sandboxing, really.)
07:57:30 <dcoutts> BlankVerse: also, note that ghc knows nothing about cabal-dev or local dirs, not unless you tell it, and that's exactly what cabal-dev does
07:57:33 <BlankVerse> i have a source code which requires yesod and other packages , so shouldn;t i use cabal-dev to install these specific packages in local cabal-dev/
07:57:43 <rekahsoft> hi all..why was it decided to take n+k patterns out of standard haskell? they seem pretty handy imho?
07:58:20 * hackagebot imgurder 1.1 - Uploader for Imgur  http://hackage.haskell.org/package/imgurder-1.1 (DanColish)
07:58:22 <BlankVerse> dcoutts: so how do i compile the soruce code using the local cabal-dev
07:58:22 * hackagebot storable-endian 0.2.5 - Storable instances with endianness  http://hackage.haskell.org/package/storable-endian-0.2.5 (EugeneKirpichov)
07:58:33 <dcoutts> BlankVerse: use cabal-dev to do it
07:58:44 <dmwit> BlankVerse: "cabal-dev install"
07:59:09 <BlankVerse> but the source code is not a cabal module..
07:59:23 <BlankVerse> do i need to convert it into a cabal-package first?
07:59:27 <dmwit> Yes.
07:59:47 <dcoutts> the alternative is to use lots of ghc flags that you will not understand
07:59:54 <dcoutts> like -package-db=.cabal/blah/blah
08:00:19 <BlankVerse> but what if my source code is not really a cabal module , its just a haskell application...
08:00:29 <BlankVerse> should every haskell app be make a cabal package?
08:00:51 <kmc> yes
08:00:55 <ColonelJ> what's wrong with this
08:00:56 <ColonelJ> compress' e (e:xs) = compress' e xs
08:01:08 <kmc> you're binding e twice
08:01:13 <kmc> you can't do that
08:01:18 <dmwit> You can do it by hand if you want. But cabal was made to spare you from all the hassle of looking up the appropriate ghc flags, finding the appropriate package databases, adding the right package versions...
08:01:24 <tsousa> quicksilver, http://dpaste.com/640863/ what about this?
08:01:30 <ColonelJ> it's meant to match the es
08:01:41 <dmwit> ColonelJ: Match by hand.
08:01:57 <dmwit> compress' e (e':xs) | e == e' = ...
08:01:57 <ColonelJ> lame but fine
08:02:15 <kmc> i wouldn't call it e'
08:02:20 <kmc> i find the primes hard to read
08:02:20 <ColonelJ> I called it x
08:02:21 <kmc> but whatever
08:02:32 <dafis> tsousa: use (:) instead of (++)
08:02:47 <dmwit> > map head . group $ [1,2,3,3,3,2,5]
08:02:48 <lambdabot>   [1,2,3,2,5]
08:03:07 <dmwit> > nub $ [1,2,3,3,3,2,5]
08:03:07 <lambdabot>   [1,2,3,5]
08:03:33 <tsousa> dafis, the problems is still there
08:03:36 <Brax> re parsing identifiers: how do i reject escape codes?
08:03:47 <ColonelJ> is guards any better than simple if..else here?
08:03:58 <dmwit> rekahsoft: I write "a + b + c = 3". What do?
08:04:28 <dmwit> ColonelJ: Guards vs if/then/else is often an aesthetic choice.
08:04:35 <dmwit> Not always, but almost always.
08:04:47 <yrlnry> dmwit:  I don't think n+k patterns ever applied to variable k.
08:04:48 <ColonelJ> do you have to write otherwise
08:04:57 <kmc> ColonelJ, if you used if..else you'd have to write the "else" part on the same pattern-match
08:05:01 <yrlnry> They only applied when k was a compile-time constant.
08:05:03 <dmwit> yrlnry: Okay, I write "1 + 2 + 3 = 6". What do?
08:05:03 <kmc> with guards you can fall through
08:05:15 <ColonelJ> [16:18] <ColonelJ> do you have to write otherwise
08:05:16 <kmc> "otherwise" is just a variable with value True
08:05:18 <kmc> > otherwise
08:05:19 <lambdabot>   True
08:05:32 <ColonelJ> true makes even less sense :P
08:05:37 <yrlnry> dmwit:  I don't understand what that has to do with n+k patterns.
08:05:43 <kmc> how's that ColonelJ?
08:05:47 <kmc> guards are boolean expressions
08:05:51 <kmc> True is a boolean expression
08:06:04 <kmc> so "otherwise" is used to write a guard which is always true
08:06:19 <kmc> so no, you don't have to use it... you only use it when that's what you want
08:06:35 <ColonelJ> what I meant was that otherwise looks better there than True
08:06:46 <kmc> right, that's why it exists
08:08:12 <rekahsoft> dmwit: hmm..i actually just looked at n+k patterns the other day (i learned originally they had been taken out of the language so i didn't use them..)..in this case k is to be constant no? so in your example of "a+b+c=3" couldn't you just let b+c=d (aka some constant?
08:08:42 <rekahsoft> that or i don't understand..
08:08:59 <dmwit> rekahsoft: (See also my reply to yrlnry's almost identical complaint. =)
08:09:17 <yrlnry> rekahsoft:  dmwit is confused about n+k patterns, or else i being too subtle for me to understand.
08:09:18 <dmwit> But yeah, that's probably not why they were taken out.
08:09:36 <dmwit> I think they were just taken out because they're a bit too ad-hoc and weird compared to the rest of the language.
08:09:40 <yrlnry> dmwit:  you have not yet given an example of an n+k pattern.
08:09:41 <dmwit> Plus view-patterns pretty much subsume them.
08:09:57 <kmc> pattern-matching on numeric literals is already ad-hoc and weird
08:09:58 * dmwit nods in agreement at yrlnry
08:10:13 <kmc> but the usefulness to weirdness ratio is higher
08:10:28 <dafis> tsousa: oh, and [xs] instead of [[xs]] in the 0-case
08:10:29 <yrlnry> http://blog.plover.com/prog/perl/undefined.html#5 ← I had a little discussion of n+k patterns on my blog a few years ago.  I should revisit the topic in light of new developments.
08:11:16 <yrlnry> rekahsoft:  I suspect that they were removed because they were an annoying language wart that introduced parsing complications out of proportion to their utility.
08:11:48 <yrlnry> rekahsoft:  As I said in the blog article: "Putting the feature in  bloats the spec—see the Perlesque yikkity-yak on pages 57–58 about how x + 1 = ... binds a meaning to +, but (x + 1) = ... binds a meaning to x."
08:11:50 <kmc> i'm not sure what the parsing complications are
08:11:54 <yrlnry> kmc^^
08:12:06 <kmc> hmm true
08:12:45 <tsousa> dafis, if i do that more erros appear
08:13:36 <dafis> tsousa: and (n-1) needs parentheses
08:14:12 <Brax> is there some is* function to catche escape codes?
08:14:23 <dmwit> Brax: What do you mean?
08:14:27 <dafis> tsousa: besides, you never remove the elements from the front of xs for the recursive call
08:14:32 <Brax> like isAlpha
08:14:44 <dmwit> Brax: Right, but what do you mean by "escape codes"?
08:14:53 <Brax> \xxx
08:15:18 <dmwit> Brax: I'm still not sure I understand. Could you give a few sample inputs and outputs to this function?
08:15:21 <quicksilver> Brax: not . isPrint
08:15:32 <bfig_> how do you build the fold operator for a generic datatype? ie, say i have the fixpoint  D = FIX (1+(1*X)+*(1*X*X)), how do i define the fold over D?
08:15:33 <tsousa> dafis, divlist (x:xs) n  then
08:15:40 <Brax> escape -> \ ( charesc | ascii | decimal | o octal | x hexadecimal )
08:15:44 <quicksilver> > filter (not . isPrint) [chr 0 .. ]
08:15:46 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
08:16:05 <rekahsoft> thanks yrlnry :) that was a good explanation :D..also there is a languages extension that gives n+k patterns no?
08:16:17 <kmc> bfig_, http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
08:16:28 <bfig_> kmc, thanks!
08:16:41 <dafis> tsousa: what is it supposed to do, actually?
08:16:42 <koeien> my program runs about 50% *faster* if I enable profiling in the ghc invocation. what could be the cause of this?
08:16:42 <rekahsoft> how are language extension like that made?
08:16:50 <quicksilver> ViewPatterns subsumes N+K patterns
08:16:57 <quicksilver> although you don't the exact same syntax
08:16:58 <rekahsoft> also found this on the web to clear things up about n+k patterns: http://hackage.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
08:17:05 <Brax> i am new here...was lambdabot in response to my input?
08:17:21 <tsousa> dafis, if i do like divlist 3 [1,2,3,4,5,6] it will return [[1,2,3],[4,5,6]]
08:17:22 <dafis> Brax: no, quicksilver's
08:17:24 <Brax> no, quicksilvers
08:17:27 <Brax> yes =)
08:17:46 <Brax> because that would be ascii
08:18:14 <dmwit> > not . isPrintable $ '\96'
08:18:15 <lambdabot>   Not in scope: `isPrintable'
08:18:21 <dmwit> > not . isPrint $ '\96'
08:18:21 <lambdabot>   False
08:19:22 <yrlnry> > isPrint ' '
08:19:23 <lambdabot>   True
08:19:32 <yrlnry> Huh.  I thought that was supposed to be false.
08:19:41 <kmc> rekahsoft, language extensions are made by modifying GHC (or some other implementation) and then maybe documenting what you did
08:21:00 <dmwit> > '\\' `elem` filter isPrint [minBound ..]
08:21:01 <lambdabot>   True
08:21:11 <dmwit> oh, right
08:21:18 <dmwit> > '\\' `elem` delete '\\' (filter isPrint [minBound ..])
08:21:19 <lambdabot>   False
08:21:36 <yrlnry> Isn't  x `elem` delete x ls   always false?
08:21:40 <dmwit> No.
08:21:48 <yrlnry> Oh, it only deletes the first x?
08:21:49 <dmwit> > '\\' `elem` delete '\\' "\\\\"
08:21:50 <lambdabot>   True
08:21:52 <dmwit> right
08:22:03 <dmwit> Anyway, this one would probably have been safer:
08:22:13 <dmwit> > '\\' `elem` filter isPrint (delete '\\' [minBound ..])
08:22:15 <lambdabot>   False
08:22:47 <dmwit> hurr durr durr
08:22:54 <dmwit> > '\\' `elem` show (filter isPrint (delete '\\' [minBound ..]))
08:22:54 <lambdabot>   True
08:22:58 <dmwit> aha!
08:23:14 <dmwit> > isPrint '"'
08:23:15 <lambdabot>   True
08:23:26 <dmwit> > "\""
08:23:27 <lambdabot>   "\""
08:23:34 <dmwit> alright...
08:23:36 <dmwit> :t intersect
08:23:36 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
08:24:37 <dmwit> > '\\' `elem` show (filter isPrint ([minBound ..] \\ "\\\""))
08:24:38 <lambdabot>   True
08:24:56 <Brax> i suppose there is nothing which combines isAlpha and isPrint?
08:25:12 <dmwit> :t liftM2 (&&) isAlpha isPrint
08:25:13 <lambdabot> Char -> Bool
08:25:19 <dmwit> :t (\x -> isAlpha x && isPrint x)
08:25:20 <lambdabot> Char -> Bool
08:26:38 <Brax> haha, yeah, that would do
08:26:41 <Brax> thanks!
08:26:44 <dmwit> > let context xs | '\\' `elem` (take 5 xs) = take 5 xs ++ context (drop 5 xs); context (x:xs) = context xs; context [] = [] in context . show . filter isPrint $ [minBound ..] \\ "\\\""
08:26:45 <lambdabot>   "{|}~\\160\\161\\162\\163\\164\\165\\166\\167\\168\\169\\170\\171\\172\\174...
08:27:29 <dmwit> isPrint doesn't seem quite right. =)
08:27:54 <dmwit> > filter (\x -> isAlpha x && not (isPrint x)) [minBound..]
08:27:55 <lambdabot>   ""
08:28:08 <dmwit> Brax: isAlpha already implies isPrint, though
08:28:43 <koeien> my program runs faster without -O, how can I figure out which switch is responsible?
08:29:02 <koeien> also -O2 slows down my program dramatically. (GHC 7.0.2)
08:30:53 <dafis> koeien: what sort of code? Often -fno-full-laziness or -fno-state-hack or -fno-cse help
08:32:00 <koeien> dafis: I'll try. quite numeric code. i'm using arrays a lot.
08:32:21 <dafis> koeien: nice
08:32:39 <dafis> koeien: which variant of arrays?
08:32:53 <koeien> dafis: Data.Array
08:33:05 <quicksilver> koeien: if you can't find the cause (or, actually, even if you do) I would probably file a bug on GHC; this sounds like the kind of behaviour they like to know about
08:33:24 <dafis> koeien: can you use unboxed arrays?
08:34:27 <koeien> dafis: my array is Array Int V3, where data V3 = V3 !Double !Double !Double
08:34:38 <koeien> i'm using -funbox-strict-fields
08:35:11 <dafis> koeien: okay, not ideal for unboxed
08:35:39 <koeien> dafis: yeah, I could rewrite it of course
08:36:17 <koeien> quicksilver: I'll try to get a smaller example.
08:36:25 <rekahsoft> kmc: i have read you did work on running haskell code on android? have you made this work public?
08:36:48 <dafis> koeien: to use UArray Int Double with custom lookup and write, or write an instance IArray UArray i V3
08:37:14 <koeien> dafis: yes, that's possible. although the speed without optimizations is acceptable for me.
08:37:47 <koeien> I ran the profiler and it was suddenly faster, so I was curious.
08:37:54 <dafis> that's fine then, so it's only necessary to find out what interferes with -O
08:39:38 <Brax> oh right...the problem was i may not use isAlpha...i have a sat function and can use this: letter = sat isAlpha...but there is no equivalent for isPrint
08:39:53 <Brax> is it even possible, then?
08:40:08 <quicksilver> what's wrong with "sat isPrint" or "sat (not . isPrint)" ?
08:40:49 <Brax> those are not given and i can't import char
08:41:12 <Brax> (i forgot what the problem was, sorry)
08:44:53 <Brax> i also have digit, lower, upper and alphanum...all of type Parser Char...defined via sat is*
08:45:33 <Brax> it's for parsing identifiers
08:46:07 <Brax> i guess it's not possible with only those...
08:46:48 <BlankVerse> i am unable to install yesod : http://dpaste.com/640879/
08:46:57 <BlankVerse> my .cabal is brand new
08:50:50 <koeien> BlankVerse: you might try #yesod
08:51:04 <geheimdienst> BlankVerse: there's a newer version of tls-extra which apparently can live with the tls-0.8.1 that http-enumerator wants. http://hackage.haskell.org/package/tls-extra-0.4.0
08:51:25 <geheimdienst> question is, why did cabal get it in its head to install the old tls-extra-0.3.1 in the first place
08:51:59 <koeien> try cabal update
08:52:56 <BlankVerse> koeien: i have done cabal update
08:53:40 <koeien> --constraints 'tls-extra==0.4.0'
09:18:43 <Ololo> @type flip ($)
09:18:44 <lambdabot> forall a b. a -> (a -> b) -> b
09:28:21 * hackagebot boomerang 1.2.0 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.2.0 (JeremyShaw)
09:29:49 <parcs_> what are the arrow laws?
09:36:42 <Saulzar> parcs_, I guess you're best off reading a paper on arrows, not sure offhand which would be best
09:36:45 <stepkut> parcs_: section 8, http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf
09:41:51 <tsousa> haskell is giving me an empty list in this code http://dpaste.com/640904/ but there is no empty list
09:44:41 <copumpkin> like there is no spoon?
09:45:27 <geheimdienst> > init []
09:45:28 <lambdabot>   *Exception: Prelude.init: empty list
09:46:16 <geheimdienst> tsousa: it appears that you give an empty list to init
09:46:42 <tsousa> geheimdienst, yes but there is not empty list. the input that goes into the map init is [[1,2,3],[4,5,6],[7,8,9],[10]]
09:47:39 <copumpkin> well, surely there is an empty list
09:47:41 <copumpkin> or it wouldn't say so
09:48:01 <mah_b> tsousa: are you sure that the `map init' is in the right place? imho it should be divLst num lst = map init $ aux lst ...
09:48:47 <dmwit> tsousa: Perhaps you only wanted to apply init to the first argument to the :, rather than mapping it.
09:48:48 <tsousa> mah_b, i think so. i need to apply init when the recursing call is complete
09:49:02 <dmwit> tsousa: Otherwise you're applying init more and more times the deeper you go in the list.
09:49:14 <dmwit> (One for each recursive call that's "above" it in the call stack.)
09:49:44 <mah_b> tsousa: yes, but not in each recursive call on all results, but only at the top.
09:49:59 <dmwit> init (take num lst') : aux (drop num lst') -- seems much more likely to be the code you meant to write.
09:50:05 <tsousa> mah_b, so where do i put the expression?
09:50:51 <hpaste> mah_b pasted “tsousa: divLst” at http://hpaste.org/53113
09:54:58 <tsousa> mah_b, one number is missing
09:55:11 <tsousa> 10 should be on the list and it is not
09:58:07 <mah_b> tsousa: yes, thats a principial flaw with your partition and init approach when dealing with the last part of the list.
09:58:31 <mah_b> tsousa: you should not use init, but (\lst -> if length lst == num then init lst else lst).
09:59:27 <Dodek> hey, is there a function like mapWithN :: (Int -> a -> b) -> [a] -> [b], which gives an index to a mapping function?
09:59:49 <rwbarton> zipWith f [0..] xs
10:00:06 <Dodek> rwbarton: thanks
10:00:34 <tsousa> mah_b|afk, thank you
10:00:42 <tsousa> it works now
10:02:01 <rwbarton> what is divLst supposed to do?
10:02:10 <rwbarton> for example divLst 3 [1,2,3,4,5,6,7,8,9,10] = ?
10:03:27 <rwbarton> oh, I see, I guess
10:03:43 <Dodek> rwbarton: but this is not exactly what i want
10:04:22 <rwbarton> at least instead of (\lst -> if length lst == num then init lst else lst), write (take (num-1))
10:04:37 <Dodek> rwbarton: is there a function curriedToPair :: (a -> b -> c) -> ((a, b) -> c) ?
10:04:45 <rwbarton> Yes
10:04:51 <rwbarton> :t uncurry
10:04:52 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:05:02 <Dodek> rwbarton: thanks
10:05:05 <rwbarton> (or:)
10:05:11 <rwbarton> @hoogle (a -> b -> c) -> ((a, b) -> c)
10:05:13 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
10:05:13 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
10:05:13 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
10:15:08 <penryu> how can I define a cron-style DayOfWeek datatype with values 0 to 6 :: Int?
10:15:50 <Botje> you could make an Enum instance.
10:15:57 <adrake> stepkut++ # link to arrows paper
10:20:00 <penryu> Botje: thanks. how would that look?  I was thinking of trying to implement a Bounded Int, but I can't seem to figure out how to declare minBound/maxBound
10:20:01 <Dodek> is it a good practice to use IORefs from multiple thread, using some MVar as a lock on them?
10:20:50 <penryu> s/declare/define/
10:21:15 <Botje> penryu: data DayOfWeek = Mon | Tue | ... | Sun deriving Enum
10:21:28 <Botje> although I think enum starts counting from one
10:21:41 <ben> Surely you mean = Sun | Mon | Tue | ... | Fri
10:21:55 <yrlnry> Only if you're Jewish.
10:21:56 <Botje> .. no?
10:22:15 <Botje> it's called a weekEND for a reason :)
10:22:17 <yrlnry> Because then the week starts on Sunday and you're now allowed to do any computation on Saturday.
10:23:04 <penryu> if Enum counds from 1, cron understands 7 as Sunday as well, so that works out
10:23:09 <kmc> Dodek, seems a little weird, and easy to screw up
10:23:11 <yrlnry> The Unix localtime() call makes Sunday = 0, Saturday = 6, because Ken Thompson was a crypto-Jew.
10:23:19 <kmc> Dodek, why that design?
10:24:06 <Dodek> kmc: mainly because i know next to nothing about concurrency in haskell
10:24:52 <hpc> Dodek: try using STM and TVars; you won't have to deal with explicit locking, though you might see some slowdown if your threads are fighting for the same resource
10:25:34 <dmwit> crypto-Jew?
10:25:35 <Dodek> hpc: could you recommend any introduction to STM in haskell?
10:25:46 <penryu> Note: Botje's type definition yields: fromEnum Mon => 0
10:26:19 <hpc> Dodek: i don't know of one, and haven't really used STM, but it shouldn't be very different from using IORefs in IO
10:26:33 <hpc> only it's going to be TVars in the STM monad
10:27:39 <Dodek> what i'm trying to do is to write a server for a multi user game, so that i need a few variables to track state
10:27:57 <dmwit> Dodek: Rather than locking an IORef with an MVar, the usual approach is to just put whatever data you were locking in that IORef directly into the MVar.
10:28:08 <hpc> or that
10:28:16 <Dodek> to keep things simple, i wanted to use a single lock on all of them
10:28:40 <dmwit> Dodek: Then just put the state into the single MVar you have.
10:28:45 <Dodek> because sometimes i need to change the state of one of them basing on the state of another
10:28:47 <dmwit> No need to make it more complicated than that.
10:28:50 <Dodek> dmwit: hmm.
10:28:56 <Dodek> this makes sense.
10:29:32 <hpc> you might also try getting your concurrency from par and pseq
10:29:54 <hpc> which is for parallel computation of pure values
10:30:15 <Dodek> i only use threads for multiplexed io
10:30:21 <dmwit> If it's a multiplayer game, he'll probably need to do IO in several threads. So par and pseq won't work there.
10:30:26 <Dodek> so par/pseq are not of much use
10:30:35 <hpc> ah k
10:31:54 <dmwit> Dodek: Do you expect to have a lot of contention?
10:33:13 <Dodek> i only expect a handful of clients and 2-3 messages per second from each of them
10:33:15 <dmwit> If you expect low contention, but frequent lock/unlocks, then it might be worth taking a look at STM. Otherwise, sticking to a simple solution that you understand well is probably best.
10:33:30 <kmc> Dodek, right, as others said, I'd use either STM, or a single MVar which holds all the shared data
10:33:32 <dmwit> Okay. Learning a brand new concurrency paradigm probably isn't worth it, then. =)
10:33:50 <kmc> meh STM is pretty simple as far as "paradigms" go
10:33:57 <kmc> because the atomicity Just Works
10:34:01 <dmwit> Yes.
10:34:17 <kmc> i will nitpick hpc and point out that par and pseq don't give concurrency at all, only parallelism
10:34:26 <kmc> (well pseq gives neither)
10:34:51 <hpc> pseq just gives order of evaluation
10:34:55 <Dodek> dmwit: to be honest, i'd like to learn it, but what i want more is to have it done fast, so that i get the grade and have more time to play with things :)
10:34:55 <kmc> Dodek, RWH has chapters on concurrency; the STM chapter is particularly good
10:35:21 <kmc> learning STM from scratch is easier than figuring out one moderately tricky locking puzzle
10:35:34 <kmc> and as an extra bonus you'll be confident your code actually works
10:35:46 <dmwit> One global lock rarely leads to any tricky locking puzzles.
10:36:07 <hpc> one global lock rarely leads to benefits from concurrency either
10:36:27 <dmwit> That's not at all true.
10:36:45 <kmc> concurrency has benefits even without parallelism
10:36:58 <Dodek> hpc: concurrency is not the same as parallelism
10:37:26 <Dodek> i don't really care about parallelism in my program.
10:39:18 <monochrom> one global lock is correct if you remember to follow the locking convention at all
10:39:38 <Dodek> if i were coding in another language i wouldn't even use concurrency for this, but since this is way to go in haskell...
10:41:14 <monochrom> I found System.Event last night. in base. available in GHC
10:44:53 <monochrom> my only gripe is that it is in a position to work at the Handle level, but it still chooses the Fd level
10:45:44 <Dodek> hmm. suppose i have a lazy list of packets received from client, and i want to take mvar as soon as i receive a packet
10:46:44 <Dodek> i'm afraid that if i  if i do let (p:ps) = packets in withMVar $ do ..., it'll block reading a packet inside withMVar
10:46:48 <Dodek> am i right?
10:47:15 <monochrom> yes
10:47:33 <Dodek> so what should i do instead?
10:47:42 <monochrom> loop (p:ps) = do ... takeMVar ...  loop ps
10:47:54 <hpc> and putMVar
10:48:09 <monochrom> loop (p:ps) = do ... withMVar ...  loop ps  if you like
10:48:31 <Dodek> monochrom: you left too much as an exercise for reader :)
10:48:45 <Dodek> monochrom: more specifically, i don't know what first ... is supposed to mean
10:49:33 <monochrom> every ... means I don't have your actual code so I play safe
10:50:03 <monochrom> case packet of p:ps -> withMVar ...  ?
10:50:03 <Dodek> monochrom: but i don't see what's the difference between my and your code
10:53:24 * hackagebot type-unary 0.0.0 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.0.0 (ConalElliott)
11:07:19 <scooty-puff> is there a good reference for extending the hindley/milner type system to include data types and type classes - my current background is only from "Generalizing Hindley-Milner Type Inference Algorithms"
11:08:15 <kmc> it's not exactly what you're looking for, but "Typing Haskell in Haskell" presents a type inferer / checker for Haskell 98
11:08:24 <scooty-puff> i am planning on writing a constraint based method to infer types in a structurally typed language
11:08:53 <Botje> scooty-puff: you /might/ want to look at gradual typing, then
11:08:58 <Botje> I'm doing something similar
11:09:45 <scooty-puff> Botje: ok, i'll try googling, etc.
11:11:15 <Botje> "Gradual typing with unification-based inference" by Siek and Vachharajani
11:11:20 <Botje> and "Gradual typing for objects"
11:13:32 <Botje> scooty-puff: if you find other interesting stuff, always interested :)
11:13:45 <yrlnry> That is tautologous.
11:15:28 <Botje> *interesting for you
11:18:27 * hackagebot email 0.1.1.2 - Sending eMail in Haskell made easy  http://hackage.haskell.org/package/email-0.1.1.2 (JohannesWeiss)
11:18:29 * hackagebot type-unary 0.1.0 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.0 (ConalElliott)
11:23:36 <ezyang> Who is current 'base' libraries maintainer?
11:23:51 <monochrom> I suspect GHC people
11:24:08 <monochrom> or the "libraries" mailing list
11:24:12 <ezyang> Yeah, I'm wondering specifically who. It doesn't seem to be the usual repo.
11:24:35 <ezyang> Already had a big discussion. I need to poke someone to actually push the patch.
11:24:50 <monochrom> darn
11:26:05 <mkscrg> cabal question: how does one resolve errors like "ambiguous module name foo: it was found in multiple packages"?
11:26:22 <shachaf> mkscrg: Hide n-1 of the packages.
11:26:45 <mkscrg> shachaf: how do you hide packages?
11:26:51 <Varakh> hi. is it possible to express the filter function with the help of takeWhile and dropwhile?
11:27:03 <parcs_> is there a flag to dump the desugared version of do/arrow notation?
11:27:08 <shachaf> Varakh: Not with only one application of each.
11:27:28 <shachaf> You could do it recursively, but there's no point to it, really.
11:27:42 <kmc> mkscrg, edit the cabal file for the project you're building
11:27:48 <kmc> to depend on only one of those packages
11:28:08 <DanBurton> Varakh: it would be rather roundabout to use those to define filter
11:28:12 <Varakh> shachaf: i dont get the sense of this exercise either :/ but i've to and i dont know how
11:28:12 <shachaf> mkscrg: Either compile with ghc -hide-package NAME or use `ghc-pkg hide NAME` to hide it "globally". But, really, you probably should use cabal, like kmc says.
11:28:25 <shachaf> Varakh: Ah, this is homework?
11:28:55 <monochrom> iterate between takeWhile and dropWhile
11:28:56 <Varakh> it is ;)
11:29:12 <monochrom> it is a painful exercise. I would skip it.
11:29:42 <Varakh> but i dont have any idea how to do it. i do know what take and dropwhile does but i dont know how to apply them recursivly :/
11:30:13 <shachaf> Varakh: You probably want to define your own function that uses them and then calls itself recursively.
11:30:16 <DanBurton> Varakh: how comfortable are you with takeWhile and dropWhile?
11:30:27 <monochrom> no no, your function is recursive, your function sometimes calls takeWhile, sometimes calls dropWhile, and calls them many times
11:30:27 <shachaf> 15 years takeWhile experience.
11:30:55 * DanBurton applauds shachaf's amazing takeWhile skills
11:31:38 <Varakh> DanBurton: i know that take stops when it finds a number for which prediction doesnt hold true and returns list of numbers which hold true. and drop stops there too but returns rest of list
11:31:38 <DanBurton> > (takeWhile (<3) [1,4,2,6], dropWhile (<3) [1,4,2,6])
11:31:40 <lambdabot>   ([1],[4,2,6])
11:32:14 <Varakh> ye
11:32:18 <Varakh> i know that :D
11:32:20 <DanBurton> You can use takeWhile and dropWhile to basically split the list into two parts
11:32:22 <kmc> (<3): the love predicate
11:32:28 <Varakh> =P
11:33:14 <Botje> you can probably use U+2665 as an operator.
11:33:21 <DanBurton> so suppose I want to write filter, using the example filter (<3) [1,4,2,6]
11:33:31 * hackagebot lsystem 1.2 - Paint an L-System Grammar  http://hackage.haskell.org/package/lsystem-1.2 (CarlosGomez)
11:33:37 <hpc> kmc: technically, ((<3):) is the love concatenation :P
11:33:55 <kmc> @let (♥) = (<3)
11:33:56 <lambdabot>  Defined.
11:34:07 <Varakh> lol
11:34:09 <DanBurton> the first step would be to use takeWhile and dropWhile to split it into ([1],[4,2,6])
11:34:15 <kmc> > 2 ♥
11:34:16 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:34:33 <kmc> > (♥) 2
11:34:35 <lambdabot>   True
11:34:48 <RaptorRarr> > 2 ♥
11:34:48 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:34:54 <copumpkin> the love is true
11:34:55 <RaptorRarr> > 2 ♥ Nothing
11:34:56 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a -> t'
11:34:56 <lambdabot>         against infe...
11:35:18 <Varakh> okay, then i concat lists which hold true
11:35:42 <DanBurton> Varakh: right, your filter function should keep the [1], but it needs to somehow deal with the rest, 4,2,6
11:35:49 <Varakh> ye
11:35:50 <Varakh> i got that
11:36:01 <Varakh> but i dont know how to do it in code
11:36:31 <DanBurton> well, what do you think is a good way to deal with [4,2,6] in order to extract just the [2] out of it?
11:36:33 <Varakh> (just 2h of haskell now in my lecture)
11:36:34 <yitz> kmc: please redefine to something that can be an operator
11:36:59 <Varakh> and professor is hell :X
11:37:23 <shachaf> DanBurton: const [2]
11:37:42 <Varakh> DanBurton: good question
11:37:44 <DanBurton> shachaf: -____-
11:37:54 <dino-> Does cabal-install run a project's Setup.hs if present?
11:38:05 <shachaf> yitz: It's a PostfixOperator!
11:38:06 <Varakh> take will return nothing but [] and drop the whole list i guess
11:38:17 <shachaf> > (1 ♥)
11:38:18 <lambdabot>   True
11:38:31 * hackagebot ConfigFile 1.1.1 - Configuration file reading & writing  http://hackage.haskell.org/package/ConfigFile-1.1.1 (JohnGoerzen)
11:39:03 <DanBurton> Varakh: I assume you are allowed to use the "not" operator
11:39:14 <monochrom> Setup.hs ignored if *.cabal file says "build-type: Simple"
11:39:16 <Varakh> i dont even know the not operator
11:39:21 <DanBurton> > not True
11:39:22 <Varakh> cuz lecture sucks as i said
11:39:22 <lambdabot>   False
11:39:26 <DanBurton> > not False
11:39:26 <lambdabot>   True
11:39:31 <DanBurton> that's all it is
11:39:34 <Varakh> k
11:40:27 <RaptorRarr> @hoogle Bool -> Bool
11:40:27 <lambdabot> Prelude not :: Bool -> Bool
11:40:28 <lambdabot> Data.Bool not :: Bool -> Bool
11:40:28 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
11:40:40 <RaptorRarr> not!
11:40:46 <RaptorRarr> @hoogle Bool -> Bool -> Bool
11:40:47 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
11:40:47 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
11:40:48 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
11:40:53 <DanBurton> > (takeWhile (>3) [1,4,2,6], takeWhile (\x -> not (x > 3)) [1,4,2,6])
11:40:54 <lambdabot>   ([],[1])
11:41:26 <DanBurton> > (dropWhile (>3) [1,4,2,6], dropWhile (\x -> not (x > 3)) [1,4,2,6])
11:41:27 <lambdabot>   ([1,4,2,6],[4,2,6])
11:42:27 <DanBurton> if takeWhile, dropWhile, and not are all you have to work with, then you can combine them, too
11:42:39 <yitz> > (ap ((.) . (=<<) . takeWhile) ((takeWhile (not . null) .) . iterate . (drop 1 .) . dropWhile)) ((==0).(`mod`3)) [0..15]
11:42:40 <lambdabot>   [0,3,6,9,12,15]
11:42:57 <yitz> dum de dum dum... just playing with some function... never mind me
11:43:06 <RaptorRarr> > [0,3..15]
11:43:07 <lambdabot>   [0,3,6,9,12,15]
11:43:28 <DanBurton> yitz: ap is cheating
11:43:38 <yitz> DanBurton: tell that to @pl
11:44:07 <RaptorRarr> @pl, ap is cheating.
11:44:07 <lambdabot> (line 1, column 16):
11:44:07 <lambdabot> unexpected end of input
11:44:07 <lambdabot> expecting white space or simple term
11:44:29 <yitz> RaptorRarr: @vixen is dead :(
11:44:37 <Varakh> DanBurton: ok, and now? :X
11:45:07 <RaptorRarr> yitz: I know :(
11:46:31 <applicative> kmc, nice quasicrystals; but now I want to know how to make the animated version...
11:46:44 <ColonelJ> what's wrong with this
11:46:46 <ColonelJ> :t (0 == . `mod` 2)
11:46:47 <lambdabot> parse error on input `.'
11:47:13 <applicative> :t ((0==).(`mod` 2)
11:47:14 <lambdabot> parse error (possibly incorrect indentation)
11:47:17 <applicative> :t ((0==).(`mod` 2))
11:47:18 <lambdabot> forall a. (Integral a) => a -> Bool
11:47:27 <kmc> applicative, you just make it cos(x cos(θ) + y sin(θ) + t)
11:47:32 <applicative> ColonelJ: not enough parentheses..
11:47:38 <DanBurton> Varakh: 1 minute; phone call
11:47:41 <kmc> t varying from 0 to 2π
11:47:43 <ColonelJ> you didn't really answer the question but that works I guess
11:47:55 <frcat> a self test.
11:48:12 <applicative> ah, kmc thanks.
11:48:16 <yitz> ColonelJ: a section of an operator always needs to be in parantheses. Using == that way is called a "section".
11:48:31 <applicative> actually my devil seems only to make jpg files; will have to study further
11:48:32 <kmc> applicative, glad you liked the post :)
11:48:32 * hackagebot cursedcsv 0.1 - Terminal tool for viewing tabular data  http://hackage.haskell.org/package/cursedcsv-0.1 (GershomBazerman)
11:48:51 <kmc> i'm thinking of making a library around this, which might turn out to be a Repa-backed revival of Pan, or something
11:48:52 <ColonelJ> also why does (1 +) (1 -) (+ 1) work but (- 1) doesn't :P
11:48:58 <kmc> ColonelJ, syntactic special case
11:49:08 <kmc> ColonelJ, because people expect prefix unary negation to work
11:49:13 <kmc> it's dumb ;P
11:49:19 <yitz> ColonelJ: ditto `mod` - putting it in backticks makes it an operator, then a partial application of that operator is section.
11:49:41 <tromp> > 1 `(+)` 1
11:49:41 <ColonelJ> well the arguments are in the wrong order the normal way
11:49:41 <lambdabot>   <no location info>: parse error on input `('
11:49:44 <kmc> Haskell panders to the expectations of the beginner in like three random places, and everywhere else completely defies them
11:49:55 <yitz> ColonelJ: use "subtract" instead
11:50:10 <yitz> > subtract 5 37
11:50:11 <lambdabot>   32
11:50:16 * applicative writes 0 - 12 all the time, so he knows what he's doing
11:50:31 <RaptorRarr> > (subtract 11) (1.0/0.0)
11:50:32 <lambdabot>   Infinity
11:51:02 <yitz> RaptorRarr: was that supposed to be an enlightening example?
11:51:15 <Varakh> DanBurton: ok
11:51:17 <RaptorRarr> yitz: Haha
11:51:32 * applicative is enlightened whenever the Infinite is brought to his attention
11:51:34 <mizu_no_oto> What's the best way to work with a pcap file in haskell?
11:51:37 <RaptorRarr> yitz: It better showcases the use of subtract as a section thingy.
11:51:59 <yitz> RaptorRarr: true.
11:52:13 <RaptorRarr> > map (subtract 11) [1..20]
11:52:15 <lambdabot>   [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9]
11:52:21 <mizu_no_oto> I know that there's Network.Pcap, but most of the functions in there work via callbacks
11:52:43 <ColonelJ> > fix (\r p xs -> if xs == [] then [] else (takeWhile p xs ++ (r p (dropWhile (not . p) . dropWhile p $ xs)))) ((0 ==) . (`mod` 2)) [1,2,3,4,5,6,7,8,9,10]
11:52:45 <lambdabot>   [2,4,6,8,10]
11:52:45 <yitz> applicative: so if the Infinite is brought to your attention you'll stop writing 0 - 12?
11:53:41 <DanBurton> > let f = (>3); xs = [1,4,2,6] in takeWhile f (dropWhile (\x -> not (f x)) xs)
11:53:41 <mizu_no_oto> There is one function, though, nextBS :: PcapHandle -> IO (PktHdr, ByteString)
11:53:42 <lambdabot>   [4]
11:54:06 <DanBurton> so that way of combining them wasn't too useful
11:54:08 <yitz> DanBurton: ahem
11:54:09 <ColonelJ> > fix (\r p xs -> if xs == [] then [] else (takeWhile p xs ++ (r p (dropWhile (not . p) . dropWhile p $ xs)))) (>3) [1,4,2,6]
11:54:10 <lambdabot>   [4,6]
11:54:11 <DanBurton> but the other way might be
11:54:30 <applicative> why would I stop writing 0 - 12 ?  dangling -'s make me think of the section, the one that doesn't exist
11:54:47 <DanBurton> > let f = (>3); xs = [1,4,2,6] in dropWhile f (takeWhile (\x -> not (f x)) xs)
11:54:48 <lambdabot>   [1]
11:54:48 <Varakh> DanBurton: drop phone :D
11:55:04 <kmc> mizu_no_oto, what about pcap-enumerator
11:55:08 <applicative> amphitheater?
11:55:16 <DanBurton> nope, not very helpful either
11:55:33 <DanBurton> > let f = (>3); xs = [1,4,2,6] in takeWhile f (takeWhile (\x -> not (f x)) xs)
11:55:33 <lambdabot>   []
11:55:37 <copumpkin> applicative: sometimes you just gotta do what you gotta do
11:55:46 <kmc> mizu_no_oto, also, what's wrong with callbacks?
11:55:50 <mizu_no_oto> kmc: Thanls a lot!
11:56:00 <DanBurton> @check \f xs -> takeWhile f (takeWhile (not . f) xs)) == []
11:56:00 <lambdabot>  Unbalanced parentheses
11:56:00 <applicative> it was okay
11:56:21 <DanBurton> @check \f xs -> takeWhile f (takeWhile (not . f) xs) == []
11:56:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
11:56:22 <lambdabot>    arising fro...
11:56:28 <RaptorRarr> Can QuickCheck construct arbitrary functions?
11:56:31 <DanBurton> doh
11:56:32 <DanBurton> dunno
11:56:34 <copumpkin> RaptorRarr: yeah
11:56:36 <mizu_no_oto> kmc: nextBS :: PcapHandle -> IO (PktHdr, ByteString)
11:56:39 <kmc> mizu_no_oto, all I did was search for 'pcap' on http://hackage.haskell.org/packages/archive/pkg-list.html
11:56:40 <RaptorRarr> Srsly?!
11:56:40 <mizu_no_oto> gah
11:56:41 <copumpkin> I want a DSL that compiles to super-efficient bpf code
11:56:46 <Varakh> DanBurton: so no idea either? :
11:56:47 <Varakh> :X
11:56:55 <RaptorRarr> @check \f -> f 1 == f 2
11:56:56 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
11:56:56 <lambdabot>    arising from a use of `...
11:57:02 <shachaf> Varakh: No idea about what?
11:57:14 <DanBurton> Varakh: i'm just trying out all of the combinations of using 2  functions in a row between takeWhile and dropWhile
11:57:25 <DanBurton> Varakh: and intentionally leaving the most useful for last..
11:57:27 <mizu_no_oto> kmc: type Callback = PktHdr -> Ptr Word8 -> IO ()
11:57:44 <DanBurton> > let f = (>3); xs = [1,4,2,6] in dropWhile f (dropWhile (\x -> not (f x)) xs)
11:57:44 <lambdabot>   [2,6]
11:57:45 <Varakh> about creating the filter function with the help of take an drop @ shachaf
11:57:50 <ColonelJ> > fix (\r p xs -> if xs == [] then [] else (takeWhile p xs ++ (r p (dropWhile (not . p) . dropWhile p $ xs)))) ((== 5) . length) ["One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten"]
11:57:51 <lambdabot>   ["Three","Seven","Eight"]
11:57:59 <Varakh> it worked! :D
11:57:59 <RaptorRarr> @check \f -> f 1 == f 1
11:58:00 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
11:58:00 <lambdabot>    arising from a use of `...
11:58:03 <shachaf> Varakh: take and drop are very different from takeWhile and dropWhile.
11:58:10 <Varakh> ye
11:58:16 <copumpkin> RaptorRarr: you need to fix the types
11:58:19 <Varakh> sry about that
11:58:22 <shachaf> Varakh: Anyway, usually we try to give some hints for homework questions, but not provide the whole answer. You should try to get something working and then ask for advice about specific things that don't. :-)
11:58:39 <mizu_no_oto> kmc: It's nice if each packet can be handled separately, but if you want to do something to them like sort them, that doesn't exactly work nicely with that
11:58:39 <thoughtpolice> copumpkin: bpf optimizer would be sweet, but i suppose that begs the question is 'how inefficient are the packet filters already' ?
11:58:51 <kmc> mizu_no_oto, you could send them into a Chan or something
11:58:52 <copumpkin> @check \p xs -> length (filter p xs) <= (xs :: [Int])
11:58:52 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:58:58 <thoughtpolice> isn't bpf jit compiled on some platforms, anyway? i think the linux pf project now has a jitter too
11:58:59 <kmc> it's not great but I think you can make it work
11:59:00 <Varakh> i would show u what we've done and what they expect us to do ...
11:59:01 <thoughtpolice> (for x86 ofc)
11:59:06 <copumpkin> thoughtpolice: I think so, yeah
11:59:36 <kmc> personally I'm happy to give the answer for homework
11:59:47 <kmc> (unless it's too hard or i'm lazy or the person asking is particularly annoying)
11:59:53 <thoughtpolice> copumpkin: let's write a functional language for systems programming. then rewrite bpf + jit. then rewrite all the things!
11:59:59 <kmc> it's not my job to tell other people how to learn
12:00:09 <ColonelJ> I'm designing a functional language for systems programming
12:00:15 <kmc> the people who are like "JUST GIMME DA ANSWER" usually fall into "too annoying" eventually
12:00:20 <copumpkin> thoughtpolice: yes!
12:00:25 <copumpkin> all of the above
12:00:31 <copumpkin> then we can rewrite rewriting itself
12:01:01 <mizu_no_oto> kmc:  This isn't for homework
12:01:17 <thoughtpolice> we should also make sure it'll rewrite bad wikipedia articles, and remove grammatical mistakes from all things
12:01:33 <thoughtpolice> (it can have iRevolutionary "close word" detection and merely replace everywithing without asking you!)
12:01:34 <kmc> i know
12:01:44 <kmc> shachaf and Varakh were talking about homework
12:01:50 <Varakh> DanBurton: there's no takeWhile in that ^
12:01:51 <thoughtpolice> also, everywithing is a new word
12:01:51 <Varakh> ^^
12:01:51 <mizu_no_oto> kmc: Oh, I see the thread that was about now >_<
12:02:24 <ColonelJ> Varakh: did you notice that 2 is not >3
12:03:03 <Varakh> -,-
12:03:41 <ColonelJ> didn't think so
12:03:44 <Varakh> now i did.
12:03:45 <Varakh> :P
12:03:45 <DanBurton> Varakh: well no. But can you see how using dropWhile twice, in conjunction with not, was able to burn through more of the list?
12:04:58 <Varakh> we dont have this x in ..... in our lecture, so dunno what they're expecting -.-
12:05:06 <DanBurton> It's too bad caleskell has overlapping Show instances for functions T_T
12:05:51 <kmc> is there a modern successor to Pan?  a library for manipulating images as functions from R2 to color?
12:06:12 <DanBurton> I have no idea what voodoo magic quickCheck uses to make up functions, but using instance Show (a -> b) where show _ = "<<some function>>" works just fine for ghci
12:06:22 * ski suspects conal might know
12:06:28 <kmc> DanBurton, it uses the Coarbitrary class
12:06:47 <shachaf> kmc: I asked conal about that a while ago and I don't think he really knew of one.
12:06:48 * DanBurton 's suspicions were confirmed. Coarbitrary voodo magic.
12:06:52 <kmc> coarbitrary :: a -> Gen c -> Gen c  "Used to generate a function of type a -> c. The implementation should use the first argument to perturb the random generator given as the second argument. the returned generator is then used to generate the function result"
12:07:03 <kmc> it's not "voodoo magic" it's just a type class anyone can implement
12:07:06 <applicative> kmc, oh yes, I forgot to praise your plan of more repa - image investigation.
12:07:34 <ColonelJ> kmc: given how easy it is to spit out a bitmap format image file I don't see why you need a library
12:07:44 <Varakh> DanBurton: do u know the solution to the problem i have? :D
12:07:58 <DanBurton> kmc: shhh. Typeclasses are magic.
12:08:18 <kmc> DanBurton, assume you know how to generate random b's.  then you generate random (a -> b)'s by perturbing your b generator with an a
12:08:22 <DanBurton> Varakh: yes :) I'm just trying to be sufficiently vague so you figure it out on your own
12:08:53 <Varakh> ok
12:08:57 <Varakh> its not working, i think :P
12:09:08 <kmc> ColonelJ, bitmap format image file ≠ image as function over the real plane
12:09:16 <kmc> I'm not saying it will be a huge library or difficult to write
12:09:18 <DanBurton> If you have some code, you can put it on hpaste.org so we can critique it or help you find errors
12:09:44 <ColonelJ> oh, so what exactly is it you want
12:09:54 <ColonelJ> the 2D function is the image no?
12:09:59 <copumpkin> gershom has a sense of humor: http://hackage.haskell.org/package/cursedcsv
12:10:02 * applicative had forgotten the retro webpage styling of conal.net/Pan and the like
12:10:05 <kmc> an image is a function from R2 to colors
12:10:10 <Varakh> anyway, we didnt have the let x in y phrase. dunno if i can use it
12:10:22 <DanBurton> actually, though, I have to go. Thanks for the quickCheck insight, kmc
12:10:26 <kmc> i will write some helper functions for manipulating such images
12:10:31 <kmc> and for converting between them and actual image files
12:10:40 <copumpkin> kmc: that was a neat animation by the way
12:10:44 <kmc> thanks
12:11:01 <copumpkin> kmc: an animated gif should be a 4-dimensional array!
12:11:15 <kmc> :O
12:11:39 <copumpkin> but I guess animated gifs can express more information more efficiently than that
12:11:43 <applicative> I don't think i'll find composing 4D images very inituite and Pan-like
12:11:58 <applicative> intuitive rather
12:12:01 <ColonelJ> I wrote a win32 program in x86 that showed you min(A mod B,(B - A) mod B) and the scrollbars made it feel like the image was infinite size
12:12:03 <RaptorRarr> Animated images should be 7D.
12:12:09 <kmc> an animation is a function R -> R2 -> Color
12:12:15 <RaptorRarr> 8D for translucency.
12:12:38 <copumpkin> well, 4-dimensional assuming you separate channels like devil does
12:12:42 <Varakh> any additional help ? :/
12:13:24 <ColonelJ> > takeWhile (>0) [1,2,3,4,-1,-2,-3,5,6,7,-8,-9,-10]
12:13:24 <lambdabot>   [1,2,3,4]
12:13:48 <yitz> Varakh: what are you stuck on?
12:14:05 <ColonelJ> > dropWhile (not . (>0)) . dropWhile (>0) [1,2,3,4,-1,-2,-3,5,6,7,-8,-9,-10]
12:14:06 <lambdabot>   No instance for (GHC.Num.Num [a])
12:14:06 <lambdabot>    arising from a use of `e_1001234123567...
12:14:24 <ColonelJ> wth...
12:14:29 <ColonelJ> > dropWhile (not . (>0)) . dropWhile (>0) $ [1,2,3,4,-1,-2,-3,5,6,7,-8,-9,-10]
12:14:30 <Varakh> on expressing filter function with takeWhile and dropWhile Dan helped me, but i didnt understand it yet ;>
12:14:31 <lambdabot>   [5,6,7,-8,-9,-10]
12:14:59 <ColonelJ> > takeWhile (>0) [5,6,7,-8,-9,-10]
12:14:59 <lambdabot>   [5,6,7]
12:15:09 <ColonelJ> > dropWhile (not . (>0)) . dropWhile (>0) $ [5,6,7,-8,-9,-10]
12:15:10 <lambdabot>   []
12:17:34 <RaptorRarr> > let filt f = concatMap (takeWhile f) . takeWhile (not . null) . iterate (dropWhile (not . f) . dropWhile f) in filt even [1..10]
12:17:36 <lambdabot>   [2,4,6,8,10]
12:18:20 <ColonelJ> > let myFilter _ [] = [] ; myFilter p xs = takeWhile p xs ++ (dropWhile (not . p) . dropWhile p $ xs) in myFilter even [1..10]
12:18:20 <shachaf> bos31337: I think pure in http://www.scs.stanford.edu/11au-cs240h/notes/monads-slides.html#(18) is flipped.
12:18:21 <lambdabot>   [2,3,4,5,6,7,8,9,10]
12:18:29 <ColonelJ> oopsy
12:18:45 <ColonelJ> > let myFilter _ [] = [] ; myFilter p xs = takeWhile p xs ++ myFilter (dropWhile (not . p) . dropWhile p $ xs) in myFilter even [1..10]
12:18:46 <lambdabot>   Couldn't match expected type `[a]'
12:18:46 <lambdabot>         against inferred type `a -> GHC....
12:18:56 <ColonelJ> > let myFilter _ [] = [] ; myFilter p xs = takeWhile p xs ++ (myFilter (dropWhile (not . p) . dropWhile p $ xs)) in myFilter even [1..10]
12:18:58 <lambdabot>   Couldn't match expected type `[a]'
12:18:58 <lambdabot>         against inferred type `a -> GHC....
12:19:07 <ColonelJ> > let myFilter _ [] = [] ; myFilter p xs = takeWhile p xs ++ (myFilter p (dropWhile (not . p) . dropWhile p $ xs)) in myFilter even [1..10]
12:19:09 <lambdabot>   [2,4,6,8,10]
12:19:13 <ColonelJ> sorry
12:20:50 <yitz> preflex: seen bos31337
12:20:50 <preflex>  bos31337 was last seen on #haskell 6 days, 1 hour, 20 minutes and 54 seconds ago, saying: preflex: seen rl
12:21:01 <yitz> preflex: seen bos
12:21:01 <preflex>  bos was last seen on #haskell 6 days, 47 minutes and 6 seconds ago, saying: shachaf: thanks! i can't tell you how much fun it is teaching the class. funnest thing since ... something else that was very fun!
12:21:11 <Varakh> ColonelJ: ?? :X
12:22:20 * yitz likes RaptorRarr's better
12:22:49 * ColonelJ likes RaptorRarr's better but thinks his is easier to understand because he wrote it
12:23:33 <Varakh> but wheres f :X
12:23:57 <ColonelJ> filt f =
12:26:21 <yitz> > let takeWhile' = concatMap; takeWhile'' = iterate; dropWhile' = not; dropWhile'' = null; filt f = takeWhile' (takeWhile f) . takeWhile (dropWhile' . dropWhile'') . takeWhile'' (dropWhile (dropWhile' . f) . dropWhile f) in filt even [1..10]
12:26:22 <lambdabot>   [2,4,6,8,10]
12:26:39 <Varakh> Oo
12:26:53 <Varakh> wheres the function f like filter f [a]
12:27:09 <yitz> Varakh: he used p instead of f
12:27:23 <ColonelJ> p for predicate
12:27:42 <Varakh> and u dont expect me to understand this with my base of knowlegde
12:27:45 <ColonelJ> who uses f for predicates lol
12:27:59 <Varakh> i just got 2 lecture (2hours) and it was total crap ;>
12:28:06 <yitz> s/he/ColonelJ/ -- i don't really know if ColonolJ is he or she
12:28:27 <shachaf> yitz: "it" is always safe.
12:28:41 <yitz> shachaf: yes, that insults everyone equally
12:28:43 <ColonelJ> yitz: "he" is always safe in here afaik
12:28:51 <shachaf> ColonelJ: Hardly.
12:29:04 <Shammah> Hey, Im trying to zipWith (*) a b where a :: [Int] and b :: [Double]
12:29:11 <Shammah> Apparantly, this doesnt work
12:29:13 <copumpkin> just use spivak pronouns, duh
12:29:26 <Shammah> Is there a way to convert the [Int] -> [Double]
12:29:31 <Obfuscate> yitz: With a name like Colon el J, you need not worry (or perhaps you should, for different reasons).
12:29:36 <copumpkin> map fromIntegral
12:29:37 <ski> Shammah : `zipWith (*) (map fromIntegral a) b'
12:29:41 <applicative> @type fromIntegral
12:29:42 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:30:08 <ski> Shammah : .. alternatively make sure that `a' and `b' already has the same type, if appropriate
12:30:10 <ColonelJ> sigh
12:30:27 <applicative> Shammah or change the function from x * y to (fromIntegral x) * y
12:31:25 <ski> > zipWith (\x y -> fromIntegral x * y) [1,2,3] [pi/2,pi/4,pi/8]
12:31:26 <lambdabot>   [1.5707963267948966,1.5707963267948966,1.1780972450961724]
12:31:26 <BMeph> :t zipWith ((*) . fromIntegral)
12:31:27 <lambdabot> forall a a1. (Num a, Integral a1) => [a1] -> [a] -> [a]
12:31:34 <yitz> Shammah: or perhaps you want zipWith (*) a (map round b)
12:31:40 <ski> @pl zipWith (\x y -> fromIntegral x * y)
12:31:41 <lambdabot> zipWith ((*) . fromIntegral)
12:31:51 * BMeph WINS!
12:32:00 <Shammah> Ah, thanks ski, that worked
12:32:15 <Shammah> a :: [Int] is btw just a [0..n] list
12:32:55 <yitz> BMeph didn't win yet, but is several strokes under par
12:33:07 <KernelJ> how does BMeph's even work
12:33:14 <ski> (BMeph : hehee, i thought of that before, but thought i'd give the simpler answer ;)
12:33:31 <applicative> > let  x ***** y = x * fromIntegral y in zipWith (*****) [1.1, 2.2 :: Double] [1..10::Int]
12:33:32 <lambdabot>   [1.1,4.4]
12:33:50 <ski> (.. needs more `*'s)
12:34:01 <Varakh> parse error on input `in' filt p xs = takeWhile p xs ++ (filt p (dropWhile (not . p) . dropWhile p $ xs)) in filt even [1..10]  ???
12:34:34 <ski> Varakh : are you typing this into the interactor ?
12:34:42 <Varakh> no
12:34:52 <Varakh> trying to compile
12:34:59 <applicative> in a file you skip the in part of course
12:35:06 <ski> what do you want to do with `filt even [1..10]' ?
12:35:14 <applicative> then on another line you write "test = filt even [1..10]
12:35:53 <Varakh> ok. didnt know that
12:35:58 <ski> `let ... in ...' is an expression, in a file you write declarations
12:36:14 <applicative> Varakh: the bit where it says "in filt even [1..10]" isn't part of the definition of filt, it is a use of the definition, and thus belongs elsewhere
12:36:17 <KernelJ> test = do ... whatever you want that worked before
12:36:30 <ski> `test = filt even [1..10]' is a declaration binding the name `test' to that expression, so that you can type `test' in the interactor to evaluate (and print) it
12:37:17 <applicative> Varak, there are the special expressions let x = foo in bar (foo) as well.
12:37:30 <applicative> in bar (x) rather
12:37:53 <KernelJ> right I've had enough of this Haskell for one day
12:39:03 <Cale> You can never have too much Haskell for one day ;)
12:39:49 <yitz> that's probably why Cale never sleeps
12:40:40 <RaptorRarr> Haha
12:41:38 <gwern> > 10/23 * 23
12:41:38 <lambdabot>   10.0
12:41:40 <Phyx-> yitz: I thought it was because he's lambdabot in disguise
12:41:41 <gwern> > 10/23 * 1
12:41:42 <lambdabot>   0.43478260869565216
12:45:07 <dgpratt> it all makes sense now
12:45:41 <dgpratt> lamdabot achieved sentience and...uh...terminated the real Cale and assumed his identity
12:46:35 <dgpratt> er.../lamdabot/lambdabot
12:48:19 <erus`> Today i spend hours going over and over how to represent my data in haskell. I never got round to writing any functions just data structures... Should have stuck with python or something :P
12:48:37 <bfig> erus`, NEVER!
12:48:44 <DasIch> are there any projects using cabal and quickcheck I could take a look at for best practices?
12:49:57 <mizu_no_oto> What are some good tutorials on Enumerators?
12:50:55 <gtirloni> DasIch: you can check the packages in hackage.haskell.org (there is a cabal source package).. as for quickcheck.. i wouldn't know.
12:51:36 <gtirloni> mizu_no_oto: http://www.haskell.org/haskellwiki/Enumerator_and_iteratee (has more resources at the end)
12:51:38 <lambadot> DasIch, for practices so good they border on madness, see the new https://github.com/basvandijk/vector-bytestring
12:52:06 <byorgey> DasIch: xmonad is a nice example of a project with quite a lot of quickcheck properties.
12:52:20 <byorgey> DasIch: my 'split' package also has a bunch.
12:52:46 <Phyx-> does /= short circuit when comparing lists?
12:53:00 <byorgey> DasIch: as for cabal, if you type 'cabal init' it will ask you a bunch of questions and generate an initial .cabal file
12:53:16 <scooty-puff> in f :: (C a) => a, is "(C a) => a" a type, or only "a"?
12:53:16 <ski> Phyx- : yes
12:53:17 <byorgey> > [2,3,4] == [2,5,undefined]
12:53:17 <lambdabot>   False
12:53:26 <byorgey> > [1..] == [0..]
12:53:27 <lambdabot>   False
12:53:45 <byorgey> scooty-puff: the entire thing is a type
12:53:52 <scooty-puff> ok, thank you
12:54:06 <gtirloni> scooty-puff: "(C a) =>" is indicating the typeclass
12:54:11 <lambadot> > [1..] =/ [1,2]
12:54:11 <lambdabot>   Not in scope: `=/'
12:54:16 <lambadot> > [1..] /= [1,2]
12:54:17 <lambdabot>   True
12:54:20 <Phyx-> ski: thanks
12:54:42 <ski> scooty-puff : sometimes we say the `C a => a' (or the full `forall a. C a => a') is a poly-type, or type scheme, while the `a' at the end is a mono-type
12:55:01 <lambadot> @type mempty
12:55:02 <lambdabot> forall a. (Monoid a) => a
12:55:21 <DanBurton> > mempty :: [a]
12:55:21 <lambdabot>   []
12:55:26 <ski> lambadot: @dotsnack
12:55:47 <lambadot> > (mempty :: [Int], mempty :: Maybe Char)
12:55:47 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
12:55:48 <lambdabot>    arising from a use o...
12:56:12 <DanBurton> > mempty :: Char
12:56:13 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
12:56:13 <lambdabot>    arising from a use o...
12:56:21 <DanBurton> > mempty :: Maybe [a]
12:56:21 <ski> > (mempty :: [Int], mempty :: Maybe Ordering)
12:56:21 <lambdabot>   Nothing
12:56:22 <lambdabot>   ([],Nothing)
12:56:56 <Varakh> why does elemIndex not work? do i have to import something?
12:57:03 <ski> @index elemIndex
12:57:03 <lambdabot> Data.List
12:57:06 <ion> > mempty :: ([Int], Maybe Ordering)
12:57:07 <lambdabot>   ([],Nothing)
12:57:16 <DanBurton> Varakh: yep, import Data.List
12:57:39 <Varakh> ah :D hi
12:57:39 <Varakh> ok
12:59:59 <Daegalus> Hmm, does anyone know how to check if a variable is a string?
13:00:22 <RaptorRarr> @type variable
13:00:24 <lambdabot> Not in scope: `variable'
13:00:28 <shachaf> Daegalus: At runtime?
13:00:29 <RaptorRarr> @type pi
13:00:30 <lambdabot> forall a. (Floating a) => a
13:00:43 <RaptorRarr> @type let zomg = "zomg" in zomg
13:00:44 <lambdabot> [Char]
13:01:06 <RaptorRarr> In ghci, :t var
13:01:08 <Daegalus> yes, im writing a function that takes any input and if its a String, return something, if its something else, return something else
13:01:15 <shachaf> @type let zomg = zomg in zоmg
13:01:16 <lambdabot> Expr
13:01:19 <Peaker> Daegalus: why are you doing this?
13:01:22 <RaptorRarr> zomg!
13:01:26 <shachaf> Daegalus: That's probably something that you don't want to write.
13:01:31 <RaptorRarr> @type let zomg = zomg in zomg + 5
13:01:32 <lambdabot> forall a. (Num a) => a
13:01:35 <Daegalus> Peaker: part of a homework assignement, i have to.
13:01:36 <shachaf> Daegalus: Is this for Ruby-style to_s?
13:01:42 <shachaf> Daegalus: Are you using Typeable or something?
13:01:49 <applicative> Daegalus: the simple minded approach to doing exactly what you're saying, is Either
13:01:49 <shachaf> Daegalus: That's a pretty un-Haskell thing to do.
13:02:11 <bfig> use a typing parser with phantom types!
13:02:13 <Daegalus> im not using anything. I was trying use "IsString" based on google searches, but it didnt work for me.
13:02:13 <applicative> Daegalus: then you pattern-match
13:02:21 <dgpratt> Daegalus: how are you getting the input?
13:02:49 <Daegalus> dgpratt: its a list of Strings or a custom type. if its a string, outputX, if its my custom type, output it instead
13:03:00 <shachaf> Daegalus: What's the actual assignment?
13:03:22 <Daegalus> Its a colelction of mini problems setting up functions that we will later use to write a parser for some made up language for the professor.
13:03:24 * byorgey wants to see the actual text of the assignment as well
13:03:30 <Daegalus> one sec
13:03:32 <Daegalus> ill link you
13:03:46 <Billiard> Is this code overly obfuscated to show off haskell or something, or is it really the most sane way to do it in haskell? :|  http://en.wikipedia.org/wiki/Trabb_Pardo-Knuth_algorithm#Haskell
13:03:48 <ski> Daegalus : typically, types are erased at run-time in implementations, so there's probably no information left to tell whether it is a string or not -- the function is expected to know what things it operates on, by static typing
13:04:26 <applicative> > let daegalus (Left str) = "hi, " ++ str; daegalus (Right int) = show int in [daegalus (Right 17) , daegalus (Left "daegalus")]
13:04:27 <lambdabot>   ["17","hi, daegalus"]
13:04:30 <Daegalus> then i might be doing something wrong, or misunderstanding. http://cs.sjsu.edu/faculty/smithj/classes/152/a4.html Im doing #3 atm
13:04:44 <Daegalus> oh hmm, left right, might be what he wants
13:05:12 <ski> @index mfilter
13:05:12 <lambdabot> bzzt
13:05:17 <ski> @hoogle mfilter
13:05:17 <lambdabot> No results found
13:05:30 <DasIch> Billiard: not particularly
13:05:45 <byorgey> Billiard: that code isn't actually all that obfuscated, once you get used to idiomatic Haskell, except for the mfilter, which is not common
13:06:25 <DasIch> Billiard: it's fairly simple to understand if you are familiar with the syntax
13:06:30 <byorgey> Daegalus: it says that it takes a value of type  Maybe String  as input.
13:06:37 <Daegalus> yes
13:06:55 <shachaf> SJSU uses Haskell?
13:07:07 <applicative> Daegalus, so it looks like the first case is "examine Nothing [] = Right []"
13:07:10 <Daegalus> only our Programming Paradigms class for part of the semester
13:07:12 <byorgey> Daegalus: so I think "if it is a String" means "if it is an application of the Just constructor to a String"
13:07:18 <Billiard> Compare it to the ruby example, it reads left to right in order of operations, haskell jumps all around. :|
13:07:26 <byorgey> Daegalus: otherwise it will be Nothing
13:08:06 <byorgey> Billiard: no it doesn't, it reads right to left.
13:08:17 <Daegalus> btw, the professor misses a lot in his lectures and jumps around. I was here for my last assignment too. I learned more from the people in this channel than from him.
13:08:22 * monochrom reads top to bottom
13:08:36 * hackagebot type-unary 0.1.1 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.1 (ConalElliott)
13:08:43 * ski reads out to in
13:08:51 <RaptorRarr> Unary is not an -ary!
13:08:52 <Daegalus> So would this be a correct statement: "examine :: [Maybe String] -> [[Token]] -> [Either String [Token]]"
13:08:53 * RaptorRarr rants.
13:09:34 <shachaf> RaptorRarr: Sure it is.
13:09:42 <byorgey> Daegalus: you have an extra list wrapped around everything
13:09:47 <shachaf> RaptorRarr: It' un-ary.
13:09:51 <RaptorRarr> Haha
13:09:56 <RaptorRarr> Well, yes, it's very un-ary.
13:10:03 <byorgey> Daegalus: #3 says  examine :: Maybe String -> [Token] -> Either String [Token]
13:10:07 <RaptorRarr> nonary.
13:10:09 <Daegalus> byorgey: because the test classes he provides us are all lists.
13:10:12 * applicative_ thought it was examine :: Maybe String -> [Token] -> Either String [Token]
13:10:13 <RaptorRarr> Antiary.
13:10:21 <ski> Daegalus : `[Maybe String]' would be the type of *lists* of maybe strings
13:10:27 <applicative_> like byorgey says
13:11:12 <byorgey> Daegalus: well, you may have to use things like 'map' or 'fold' to use examine when working with a list of inputs, I'm not exactly sure
13:11:33 <Daegalus> http://cs.sjsu.edu/faculty/smithj/classes/152/a4/a4.hs those are the test cases if it helps any
13:11:34 <byorgey> Daegalus: but #3 clearly states what type examine is supposed to have.
13:11:44 <applicative_> Daegalus, once you have examine ::  Maybe String -> [Token] -> Either String [Token] , then zipWith examine will have the signature you mention
13:12:04 <Daegalus> hmmm, ok, thanks for the info.
13:12:56 <byorgey> Daegalus: those tests have list types because they involve a list of calls to examine or similar functions.
13:13:08 <applicative_> Daegalus: look inside test3, you see 'examine' used with a Maybe String and [Token] as arguments
13:13:12 <byorgey> Daegalus: for example, if I have  f :: Int -> Bool, then  [ f 3, f 4, f 5 ] :: [Bool]
13:13:38 <ski> > map f [3,4,5] :: [Expr]
13:13:39 <lambdabot>   [f 3,f 4,f 5]
13:13:40 <Daegalus> hmmm, ok i see where i misunderstood. Thanks. Ill try to fix this up and see if I can get it working without bugging you guys too much
13:14:04 <RaptorRarr> > let zomg = zomg in map zomg [3, 4, 5] :: [Expr]
13:14:07 <lambdabot>   mueval-core: Time limit exceeded
13:15:03 <gaspa> !list
13:16:55 <monochrom> heh
13:22:14 <d-snp> hey, if I would want to make a struct in haskell that is 32 bits wide, and has subbyte fields, how would I do that?
13:22:30 <d-snp> it's part of a network protocol :)
13:23:01 <mauke> 1) you define your type however you want
13:23:02 <Botje> implement Binary instances for your type, and use a regular datatype with Ints
13:23:06 <FUZxxl> d-snp: Hm... can you be a little bit more detailed.
13:23:10 <mauke> 2) you define a Storable instance that does the serialization
13:23:18 <RaptorRarr> d-snp: Word32 might work.
13:23:23 <FUZxxl> Botje's way is probably the best one.
13:23:36 * hackagebot gf 3.3 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.3 (ThomasHallgren)
13:23:51 <ski> (yay!, GF)
13:24:08 <d-snp> ok, I'll read up on this :)
13:24:18 <monochrom> what mauke says
13:24:23 <Phyx-> ski: and it's the 3.3 version
13:25:02 <ski> Phyx- : mhm ?
13:25:26 <Phyx-> ski: gf :)
13:25:54 <ski> do you know about any particularly exciting feature in this version ?
13:25:58 <Phyx-> hrm.. Is there a list of ExtensionFlags that effect the tokenizer somewhere?
13:26:50 <Phyx-> ski: no, I was just being semi facetious
13:26:59 <ski> .. oh
13:27:11 * ski didn't get that it could be interpreted in another way
13:27:28 <d-snp> so, beginner's question: if I would want to know how I use the function recvFrom, what would I google?
13:27:30 <hpaste> xrl pasted “Parsing variable length field” at http://hpaste.org/53120
13:27:39 <d-snp> if I google 'haskell recvFrom' I get a bugreport
13:27:42 <ski> @hoogle recvFrom
13:27:42 <lambdabot> Network recvFrom :: HostName -> PortID -> IO String
13:27:42 <lambdabot> Network.Socket recvFrom :: Socket -> Int -> IO (String, Int, SockAddr)
13:27:52 <ski> @where hoogle
13:27:52 <lambdabot> http://haskell.org/hoogle
13:28:26 <xrl> anyone want to help me with this attoparsec parser? There's a length field which is either an octet, or 1 sentinel octet and 8 value octets
13:28:32 <geheimdienst> d-snp: if you have issues with hoogle not finding things, try hayoo. it searches more packages
13:28:35 <geheimdienst> @where hayoo
13:28:35 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
13:28:43 <d-snp> alright, thanks :)
13:28:53 <geheimdienst> note these can also search for types, which is sometimes handy :)
13:29:05 <xrl> I don't know how to do either a AP.getWord8 or AP.take 8
13:29:06 <ski> d-snp : btw, note that hoogle is distinct from google
13:29:10 <d-snp> ;)
13:32:10 <DanBurton> @where google
13:32:10 <lambdabot> I know nothing about google.
13:32:13 <DanBurton> lol
13:32:26 <Daegalus> Doesnt String == [Char] ?
13:32:41 <Phyx-> yes
13:32:55 <Daegalus> ok, then can someone point out why I get this error: http://hpaste.org/53121 ?
13:33:13 <DanBurton> @where+ google Mountain View, California
13:33:13 <lambdabot> I will never forget.
13:33:54 <d-snp> that's weird, my example code has (msg, _, addr) <- recvFrom sock 1024
13:34:01 <Phyx-> DanBurton: the type of ttype isn't String, it's Token -> String
13:34:08 <d-snp> but in the hackage it says it should just return (bytes, address)
13:34:32 <RaptorRarr> @type ExitFailure
13:34:32 <lambdabot> Not in scope: data constructor `ExitFailure'
13:34:38 <RaptorRarr> @hoogle ExitFailure
13:34:39 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
13:34:39 <lambdabot> System.Exit exitFailure :: IO a
13:34:47 <RaptorRarr> codepad uses Haskell
13:35:02 <Daegalus> Phyx-: so how would I get it to be of just a String type?
13:35:06 <Phyx-> DanBurton: and the type of spelling is Token -> String
13:35:07 <DanBurton> @where codepad
13:35:07 <lambdabot> codepad.org
13:35:15 <Phyx-> oops
13:35:17 <Phyx-> wrong person
13:35:19 <RaptorRarr> DanBurton: http://codepad.org/n55SuzEz
13:35:22 <DanBurton> yeah I was wondering :)
13:35:55 <d-snp> oh nvm, other library
13:36:04 <DanBurton> @where+ codepad http://codepad.org
13:36:04 <lambdabot> Okay.
13:36:09 <d-snp> I'm getting the hang of it, but haskell has some weird namespacing..
13:36:19 <Phyx-> Daegalus: http://hpaste.org/53121
13:36:29 <Phyx-> Daegalus: if has to be passed the token to unwrap
13:36:56 <monochrom> still wrong type. [Token] ≠ Token
13:37:01 <Daegalus> oh, ok, thank you for your help Phyx-
13:37:06 <Daegalus> monochrom: ya imma fix that in a sec
13:37:15 <Phyx-> monochrom: oops, right, forgot about that
13:37:27 <Phyx-> phyx fail!
13:37:51 <xrl> Attoparsec.take operates in the "Monad Parser"... how move the lazy "take" in to Data.Binary.Get.getWord64be?
13:37:51 <Daegalus> ya, i noticed it already, but was more curious on the actual typing errors. Thank you for the help
13:38:01 <Peaker> Binary/Storable/etc probably should have been records and not type-classes
13:38:06 <DanBurton> RaptorRarr: http://codepad.org/about states that "The supervisor is written in Haskell" :)
13:38:20 <xrl> I need to move a bytestring in to a Word64... any ideas?
13:38:39 <Phyx-> Peaker: why?
13:39:15 <ski> (Peaker : like `Gen' i assume you mean ?)
13:39:57 * Phyx- is genuinely curious why you would prefer the one over the other and not trolling
13:40:56 <RaptorRarr> DanBurton: Ahh, cool :)
13:41:02 <monochrom> Binary type class means if you want n ways to Binaryize Int (for example) you need n-1 newtypes.
13:41:53 <Varakh> DanBurton:
13:42:13 <DanBurton> Varakh: ? Hello again :)
13:42:53 <Varakh> DanBurton: filt p list = (takeWhile p list) ++ (filt p (drop 1(dropWhile p list)))
13:43:01 <Phyx-> monochrom: Ah, ok, I get the usefulness now
13:43:07 <monochrom> The phenomenon is most prominent with the Monoid type class. There are about 4 common monoids over Int, and a million uncommon ones.
13:43:20 <monochrom> make it 6 common monoids
13:43:38 <monochrom> plus, times, min, max, lcm, gcd
13:44:33 * Phyx- throws out a year worth of code
13:44:39 <Phyx-> time to do it properly
13:44:43 <DanBurton> > let  filt p [] = []; filt p list = (takeWhile p list) ++ (filt p (drop 1(dropWhile p list))); in filt (>3) $ [2,4,8,2,1,4,6,8,-1,4]
13:44:44 <lambdabot>   [4,8,4,6,8,4]
13:44:58 <DanBurton> Varakh: looks good :)
13:45:25 * DanBurton is avoiding the "love predicate" (<3) now..
13:45:47 <RaptorRarr> </3
13:46:02 <Phyx-> hmm.. seems that Opt_ParallelListComp doesn't effect the lexer but the parser
13:46:06 <Phyx-> *removes*
13:46:07 <acowley> :t (<3)
13:46:08 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
13:46:20 <RaptorRarr> Let (</) = (>=) in (</3) 5
13:46:26 <RaptorRarr> > let (</) = (>=) in (</3) 5
13:46:27 <lambdabot>   True
13:47:14 <RaptorRarr> > let (</) = (>=) in filter (</3) [1..10]
13:47:15 <lambdabot>   [3,4,5,6,7,8,9,10]
13:47:44 <DanBurton> RaptorRarr: the heartbreak predicate?
13:47:59 <RaptorRarr> Yes :(
13:48:00 <Cale> I think a million is a severe underestimate of the number of monoids on Int
13:48:30 <DanBurton> > mzero :: Int
13:48:31 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:48:31 <lambdabot>         against inferred type ...
13:48:38 <DanBurton> doh
13:48:41 <DanBurton> > mempty :: Int
13:48:42 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
13:48:42 <lambdabot>    arising from a use of...
13:48:46 <acowley> Perhaps the issue is that we should be using the newtypes directly more often
13:48:51 <DanBurton> I always confuse mzero and mempty
13:50:22 <copumpki_> monochrom: don't forget all the bitwise ones
13:50:33 <monochrom> darn
13:50:39 <Cale> an overestimate would be provided by (2^n)^(2^(2n)) (the number of binary operations on Int), where n = 32 or 64
13:53:02 <acowley> deriving instance (Eq a, Show a, Num a) => Num (Sum a)
13:53:06 <Cale> The number of monoids on 9 elements has been computed at 1,844,075,697
13:53:10 <acowley> that makes things somewhat more useful
13:53:45 <yrlnry> Wow, that's a lot of monoids.
13:54:09 <acowley> Although using the newtypes directly presumes that the monoid interface is commonly desired
13:54:12 <yrlnry> Oh, it's like state machines with 9 states and 8 arrows coming out of each state.
13:54:23 <yrlnry> No wonder.
13:54:30 <Cale> that's actually up to isomorphism
13:54:39 <yrlnry> Sure.
13:55:08 <edwardk> acowley: so what are you doing at the end of January?
13:55:11 <Peaker> Phyx-: Selecting serializers is sometimes a dynamic thing -- there's no "one true way" to serialize a data-type
13:55:48 <edwardk> cale: clearly each needs a newtype
13:56:19 <Peaker> Phyx-: if they were records, then you would have first-class serializer values
13:56:41 <acowley> edwardk: I don't know! ccshan mentioned that there's a workshop at POPL on underrepresented PL problems which I should at least propose a talk for
13:56:46 <Phyx-> Peaker: yeah, monochrom explained it. Never thought of using records like that. clever
13:56:59 <edwardk> acowley: bah. you know you want to show up http://www.haskell.org/haskellwiki/Hac_Boston
13:57:00 <edwardk> =)
13:57:23 <Daegalus> Can anyone tell me what this error is actually trying to tell me? I am not sure what I am missing from my function: http://hpaste.org/53123
13:57:32 <Peaker> acowley: isn't it organized by Jonathan Edwards?
13:57:47 <edwardk> posting the announcement now
13:58:07 <monochrom> "illegal-token: "+a ??
13:58:16 <byorgey> Daegalus: + is for adding numbers, I think you want ++ which concatenates strings
13:58:20 <acowley> edwardk: I will try to make it!
13:58:21 <Phyx-> yeah, you probably meant ++
13:58:23 <monochrom> "illegal-token: " ++ [a]
13:58:25 <blackh> Daegalus: Sniff. They all beat me to it.
13:58:27 * DanBurton would do a Haskell meet up in Utah, except he is apparently the only Utahn listed on http://haskellers.com
13:58:31 <acowley> edwardk: I'll figure out what else is going on then, but put it on my calendar now
13:58:38 <Nafai> DanBurton: I am also in Utah
13:58:39 <monochrom> sorry, "illegal-token: " ++ a
13:58:58 <Nafai> I apparently haven't filled out enough on haskellers.com to have my profile public
13:59:03 <Nafai> DanBurton: Where are you located?
13:59:06 <acowley> Peaker: http://www.cs.princeton.edu/~dpw/obt/
13:59:13 <DanBurton> Nafai: Provo (BYU)
13:59:17 <Daegalus> sigh, such dumb mistakes. thanks monochrom, Phyx-, byorgey
13:59:42 <Nafai> DanBurton: Cool, I'm in Lehi
14:00:00 <byorgey> edwardk: nice, I just put it on my calendar
14:00:18 <byorgey> edwardk: no promises but I'll see if I can come for at least part of it
14:00:19 <edwardk> byorgey: i shamelessly stole your wiki page ;)
14:00:32 <DanBurton> Nafai: nice. You should fill in more stuff so I'm not the lone marker on the haskellers map of Utah :)
14:00:45 <acowley> edwardk: you should identify a language with a single character with the phonetics of "Bos" or "Boston," it's what all the cool hackathons are doing.
14:00:47 <byorgey> edwardk: just as I shamelessly stole the wiki page of the hackathons before me, and so on in a great chain of tradition etc. yada yada =)
14:00:56 <edwardk> hah
14:01:01 <acowley> I'll use the wiki page as my christmas card this year
14:01:13 <edwardk> acowley: there was some talk of HacBeans, but then those who aren't familiar with the Beantown thing wouldn't get it
14:01:22 * byorgey doesn't get it
14:01:28 <acowley> edwardk: I like that!
14:01:37 <edwardk> that and i'd have to move all the pages
14:01:57 <ddarius> Kalimbas are awesome.
14:02:06 <Peaker> yitz: btw, I got it wrong, it's in the maths building of TAU, not in the tel-aviv-Yaffo academy
14:02:13 <Cale> kmc: Your quasicrystal animation is great :)
14:02:13 * ski wonders what newfangled thing <http://haskellers.com> is, and why <http://www.haskell.org/hawiki/HaskellUserLocations> is apparently not considered good anymore
14:02:30 <DanBurton> TIL codepad runs Haskell code with Hugs (Sept 2006) with the -98 flag. o_O
14:02:33 <ski> Cale : but can it be proved to be a quasi-crystal ?
14:02:41 <ddarius> kmc: You need to make a background size one.
14:03:08 <yitz> edwardk: "Cambridge is a very walkable city." not always at that time of year.
14:03:14 <Cale> ski: Well, it has 7-fold symmetry about the origin...
14:03:31 <edwardk> yitz: hahaha
14:03:33 <copumpkin> yitz: http://www.youtube.com/watch?v=unkIVvjZc9Y
14:03:37 <yitz> Peaker: ah ok thanks for the heads-up. now i know exactly how to get there, too. :)
14:03:45 <Cale> So it can't be periodic
14:04:03 <Peaker> yitz: and I don't :) But will learn
14:04:19 <yitz> Peaker: right next to beit hatfutzot
14:04:50 <ddarius> "MIT" describes a reasonably large area.
14:04:50 <yitz> Peaker: 2 minute walk from the train station
14:05:43 <abcdehhh> > 2 + 3
14:05:44 <lambdabot>   5
14:05:57 <abcdehhh> > foldr f 0 [1..5]
14:05:58 <lambdabot>   Ambiguous type variable `b' in the constraints:
14:05:58 <lambdabot>    `GHC.Num.Num b'
14:05:58 <lambdabot>      ari...
14:06:06 <abcdehhh> > foldr f z [1..5]
14:06:06 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
14:06:40 <Jafet> > foldr1 f [z,1,2,3,4,5]
14:06:41 <lambdabot>   f z (f 1 (f 2 (f 3 (f 4 5))))
14:07:13 <kmc> thanks Cale :)
14:07:20 <sully> the symbolic execution is pretty pro.
14:07:51 <Phyx-> :t f
14:07:51 <ski> > foldr1 f [0 ..] :: Expr
14:07:51 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
14:07:52 <lambdabot>   f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f...
14:08:04 <byorgey> sully: the neat thing is it's just a Haskell library.
14:08:27 <byorgey> i.e. it requires no special support from lambdabot.
14:08:29 <Jafet> Eh, most languages can do it.
14:09:59 <Jafet> (make fun of Java here)
14:10:01 <ddarius> :t f
14:10:02 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
14:10:17 <yitz> copumpkin: two years ago i visited my brother there for a weekend. spent almost the entire weekend shoveling snow. h.t.f.u. :)
14:10:51 <ddarius> yitz: Should've come last year.
14:10:54 <ski> @type f `asAppliedTo` z
14:10:55 <lambdabot> forall b. (SimpleReflect.FromExpr b) => Expr -> b
14:10:58 <yitz> ddarius: indeed.
14:11:17 <yitz> ddarius: well, i guess global warming will solve that problem soon enough.
14:11:19 <lep-delete> is  there a command-line version of @pl?
14:11:41 <Jafet> @hackage pointfree
14:11:41 <lambdabot> http://hackage.haskell.org/package/pointfree
14:11:50 <copumpkin> yitz: I walk to work in boston every day, even through the winter
14:12:00 <copumpkin> yitz: rain, wind, snow
14:12:03 <copumpkin> NOTHING CAN STOP ME
14:12:05 <ddarius> Walking is easier than driving.
14:12:06 <yitz> copumpkin: ice?
14:12:13 <copumpkin> yitz: I eat ice for breakfast
14:12:17 <copumpkin> so yes
14:12:20 <byorgey> VERTICAL SHEETS OF ICE
14:12:20 <lep-delete> hmm, my google foo is bad today
14:12:32 <copumpkin> byorgey: I carry a pick with me and have cleats
14:12:37 <byorgey> awesome
14:12:38 <yitz> ddarius: T is easier than walking
14:12:42 <byorgey> carry on then
14:12:52 * ski . o O ( <http://web.archive.org/web/20020305173247/http://glacierglen.dhs.org/Wallpaper/Fonndalsbreen1024x768.jpg> )
14:13:01 <ddarius> Speaking of which, copumpkin ...
14:13:09 * copumpkin coughs
14:13:12 <copumpkin> I've been very busy :P
14:13:32 <copumpkin> I wasn't even here this past weekend
14:13:41 <copumpkin> or the one before, or the one before that!
14:14:45 <Nafai> DanBurton: I have no idea why I'm not showing up on the map, because my profile seems public: http://www.haskellers.com/user/travisbhartwell
14:14:46 <yitz> Peaker: time 7:30
14:14:48 <yitz> ?
14:16:15 <hpaste> DanBurton pasted “No available version of ghc that satisfies -any” at http://hpaste.org/53124
14:16:31 <sully> ah!
14:16:52 <haskellnew> hello, everyone!
14:16:52 <sully> it works by just defining all of the single letters as Expr
14:17:02 <sully> that's amusing.
14:17:06 <ddarius> http://www.youtube.com/watch?v=Lo9kGHYn_bI -- off-topic
14:17:07 <ski> hello, haskellnew
14:17:09 <blackh> haskellnew: Hello!
14:17:17 <ski> sully : well, not `f',`g',`h', iirc
14:17:28 <ski> @type a
14:17:28 <lambdabot> Expr
14:17:30 <DanBurton> Nafai: odd
14:17:32 <ski> @type h
14:17:33 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
14:17:49 <sully> oh, the functions are different
14:17:55 <DanBurton> guys any clues on that cabal error I pasted?
14:18:01 <ski> > 0 * a == 0
14:18:03 <lambdabot>   False
14:18:15 <sully> > 0 * a
14:18:16 <lambdabot>   0 * a
14:18:31 <ski> @type f `asTypeIn` \f -> f a b :: Expr
14:18:32 <lambdabot> Expr -> Expr -> Expr
14:18:38 <ddarius> sully: Expr isn't a function type so it can't be applied to something.
14:18:41 <byorgey> DanBurton: it is looking for the ghc package, not the compiler
14:19:15 <ski> @type f `asTypeIn` \f -> f a b
14:19:16 <lambdabot> forall b. (SimpleReflect.FromExpr b) => Expr -> Expr -> b
14:19:26 <sully> :t asTypeIn
14:19:27 <lambdabot> forall a b. a -> (a -> b) -> a
14:19:46 <Peaker> yitz: Was wrong about that too :)
14:19:52 <ski> @src asTypeIn
14:19:52 <lambdabot> a `asTypeIn` f = a where _ = f a
14:19:53 <lambdabot> infixl 0 `asTypeIn`
14:19:53 <Peaker> yitz: it's 18:00-20:00
14:20:10 <byorgey> DanBurton: however I'm not sure why it wouldn't find the ghc package.
14:20:12 <Peaker> yitz: sorry, I was working with preliminary details yesterday
14:20:23 <ski> sully : it's just a handy trick to ask about the type of something as it is used in an expression
14:20:55 <sully> oh, that's cute.
14:21:07 <byorgey> DanBurton: but also, QuickCheck doesn't require the ghc package.  I am very confused.
14:21:19 <ski> @type map `asTypeIn` \map -> concat (map toLower "Foo")
14:21:20 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Char'
14:21:20 <lambdabot>       Expected type: [[a]]
14:21:20 <lambdabot>       Inferred type: [Char]
14:21:34 <ski> hm
14:21:34 <ski> @type map `asTypeIn` \map f -> "a" ++ concat (map f "Foo")
14:21:35 <lambdabot> (Char -> [Char]) -> [Char] -> [[Char]]
14:21:52 <DanBurton> byorgey: i know, right. o_O
14:22:10 <yitz> Peaker: that's a better time for me, more of a chance i can do it
14:22:24 <Peaker> yitz: great :)
14:22:32 <yitz> Peaker: this monday, right?
14:22:37 <maurer> Is there anything that will generate a graph representation of a haskell program, when given the source code?
14:22:39 <Peaker> yitz: yeah, Oct31
14:22:49 <s951> Is there a rounding function which returns a Float?
14:22:51 <maurer> Ideally one which can print the source back out?
14:22:56 <yitz> Peaker: any idea yet which room?
14:23:18 <Peaker> yitz: I asked Shmuel Tyszberowicz for the exact location
14:23:28 <Peaker> (in case you know the guy)
14:23:33 <yitz> no
14:24:13 <ski> > (fromIntegral . round) pi :: Float  -- s951
14:24:14 <lambdabot>   3.0
14:24:49 <byorgey> maurer: there is SourceGraph, but that produces a call graph, which sounds like it's more abstract than you want
14:25:42 <maurer> byorgey: Depends on how detailed it is, I'll look at it, thanks.
14:26:16 <byorgey> maurer: if you want more detail, then I suggest using haskell-src-exts to parse to an AST, then if you want to turn that into a graph you can
14:26:31 <byorgey> but you have to do the scope analysis yourself
14:27:27 <maurer> byorgey: Yeah, I may have to do that.
14:28:03 <wavewave> hi.
14:28:49 <acowley> It's fun when someone invents an XML data exchange format to wrap another XML data exchange format and then invents a macro language to generate that top layer of XML
14:28:51 <wavewave> does anyone know about 'undefined dynamic_lookup' for shared library and ghc?
14:29:28 <yitz> acowley: and then generates it all with xslt
14:29:45 <s951> ski: thanks
14:29:53 <acowley> yitz: I haven't hit that layer yet, but I am braced for it
14:30:36 <yitz> acowley: what you described, and a lot of xslt on type, is a lot of what we do at work.
14:31:08 <acowley> yitz: please maintain a place in your heart for the poor schlub who just wants that inner core of gooey data
14:31:33 <yitz> acowley: until now - we (well, snoyberg mostly) are working on gradually replacing replacing all the xslt and java with haskell
14:31:41 <byorgey> that's the problem with data, too gooey
14:33:31 <acowley> yitz: as long as the Haskell isn't just another layer said poor schlub has to now contend with
14:34:29 <acowley> to be fair, I'm reinventing every wheel I encounter here
14:34:50 <acowley> I'm sure if I was content to use the existing software, my life would be simpler. Shallower and less satisfying, but simpler.
14:35:07 <yitz> acowley: i'm working on xml documents that are over 100 Mb, so automation is actually somewhat welcome.
14:35:55 <acowley> yitz: A lot of XML organically grows to such sizes, but I suppose my request is for well factored automation so end users can slot in their own components
14:37:01 <acowley> edwardk: aren't the dates for Hac Boston 20-22 rather than 21-23?
14:37:11 <edwardk> oh shit
14:37:37 <edwardk> yes
14:37:52 <acowley> I should've said something earlier as it looked funny when I added it to my calendar, but I figured it was intentional. The cafe announcement made it clear something had gone awry.
14:38:56 <byorgey> hah, I wondered about that too =)
14:39:03 <wavewave> how does ghc decide some external library loaded while compiling?
14:39:40 <edwardk> i didn't have the calendar in front of me
14:40:11 <bgamari> wavewave: Would you care to reword your question?
14:41:07 <edwardk> posted the correction
14:41:20 <wavewave> bgamari: when compiling, ghc often loads packages  like   Loading package base ... linking ... done
14:41:51 <wavewave> bgamari: I wonder on what occasion this happen.
14:42:06 <bgamari> wavewave: It's the ghci linker that does this I believe
14:42:45 <wavewave> bgamari: yes, it seemed so to me. So why is ghci called if I am compiling?
14:43:52 <acowley> wavewave: what command are you issueing from where to generate the "Loading..." output?
14:43:55 <wavewave> bgamari: I have a situation that a FFI library can be compiled if it didn't load during compilation, but cannot be compiled if ghci linking is involved.
14:44:03 <wavewave> acowley: just cabal install
14:44:42 <wavewave> I just want to understand things behind the scene.
14:45:26 <wavewave> Is it related to Template Haskell?
14:45:47 <bgamari> wavewave: I'm not entirely sure but it seems that some features (e.g. TemplateHaskell)
14:45:50 <bgamari> require this
14:45:50 <bgamari> yes
14:45:54 <wavewave> If template haskell is used, probably ghci linker is called during the compiling.
14:46:09 <wavewave> bgamari: thanks.
14:46:55 <bgamari> wavewave: http://hackage.haskell.org/trac/ghc/ticket/4268
14:47:15 <yitz> Nafai: perhaps you switched your latitude and longitude?
14:47:35 <bgamari> wavewave: there's my evidence that it's TH related
14:47:36 <yitz> Nafai: a lot of people do that.
14:48:07 <wavewave> bgamari: Okay, it also seems consistent to me.
14:48:41 <yitz> Nafai: for people east of the mississippi, they end up in or near antarctica. (they are known as "penguin haskellers"). but you would just be off the map entirely.
14:49:08 <wavewave> bgamari: next question is when this happens, I got an error when loading a foreign library, which has some 'undefined but dynamically looked up' symbols
14:50:24 <wavewave> when I type nm -m xxx.dylib, it shows  (undefined) external  _somesymbol__ (dynamically looked up)
14:50:57 <wavewave> and ghc hit error by complaining __somesymbol__ is not defined.
14:51:13 <bgamari> wavewave: hmm, that's a bummer
14:51:22 <bgamari> wavewave: Who produced the so?
14:51:46 <wavewave> bgamari: some external big C++ library.
14:52:08 <wavewave> bgamari: it seems to be related to some stub code generation using templates in C++.
14:52:38 <wavewave> bgamari: if statically linked, I do not have a problem at all.
14:53:08 <wavewave> bgamari: probably, ghc cannot deal with (undefined dynamically looked up) symbol yet well?
14:53:21 <d-snp> hm
14:53:47 <wavewave> bgamari: for your reference, it is c++ library ROOT
14:54:04 <wavewave> bgamari: and I am making haskell FFI binding of ROOT called HROOT
14:54:29 <bgamari> wavewave: ouch, I'm sorry to hear you must use ROOT ;)
14:54:34 <wavewave> bgamari: it compiles and works well if I do not hit that problem.
14:54:56 <bgamari> wavewave: If it's undefined, then I would imagine that it'll cause issues
14:55:07 <bgamari> wavewave: Is the symbol defined in the static object?
14:55:23 <wavewave> let me see..
14:56:25 <wavewave> bgamari: hmm.it doesn't have .a file at all. everything is dynamical.
14:56:59 <wavewave> so if ghci is not invoked, it works okay.
14:58:51 <wavewave> bgamari: ah.. it's very annoying if I can't use template haskell and ghci at all when using this code.
14:59:50 <wavewave> but generally (undefined dynamic lookup) is anyway allowed solution for c library makers, so ghci need to support it.
15:00:14 <d-snp> is there standard stuff to convert Word16 -> [Word8] in haskell?
15:02:34 <yitz> d-snp: the binary parsing libraries have functions for that.
15:03:38 <Saizan> or Data.Bits
15:05:18 <ddarius> :t const [] :: Word16 -> [Word8]
15:05:19 <lambdabot> Word16 -> [Word8]
15:05:47 <hpc> :t fix id :: Word16 -> [Word8]
15:05:48 <lambdabot> Word16 -> [Word8]
15:07:38 <yitz> @tell Nafai check your coordinates, you may have switched latitude and longitude.
15:07:39 <lambdabot> Consider it noted.
15:14:00 * hackagebot text 0.11.1.6 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.6 (BryanOSullivan)
15:14:58 <Tekmo> Hi, this is my first time on #haskell
15:15:28 <Tekmo> I was wondering if anybody could answer a question I have about fast array performance in haskell
15:15:29 <shachaf> Tekmo: Welcome!
15:15:31 <Eduard_Munteanu> Hi.
15:15:52 <shachaf> Tekmo: Someone is more likely to be able to if you ask it. :-)
15:16:11 <Tekmo> IT's two parts.  First, I'm trying to compute a distance matrix and store the results in an array
15:16:13 <bgamari> wavewave: How is the linker supposed to handle an undefined symbol?
15:16:28 <Tekmo> Second, I'm trying to read and write such distance matrices very rapidly
15:16:42 <Draconx> bgamari, lazy binding.
15:16:51 <wavewave> bgamari: I don't know.. I am looking for information.
15:17:12 <Cale> How big is the matrix?
15:17:19 <Tekmo> I've tried various Data.Array.Unboxed/IOUArray/STArray tricks and they all do well for computing the array
15:17:26 <Tekmo> But when it comes to I/O then they are very slow
15:17:30 <Tekmo> compared to the equivalent code in C
15:17:40 <blackh> Cale: It is all around us... oh, sorry.
15:17:42 <acowley> Tekmo: What kind of IO?
15:17:49 <Cale> blackh: haha
15:17:50 <Tekmo> The matrix sizes are maybe 500x500 for now
15:17:51 <acowley> blackh :P
15:17:58 <Cale> hmm, then maybe the problem isn't with the array computation, but what you're doing to print the results?
15:18:04 <Tekmo> Well, I'm not printing them
15:18:08 <Axman6> Tekmo: are you using Doubles?
15:18:09 <Tekmo> I'm just trying to serialize them
15:18:13 <acowley> Tekmo: Vector or Array should handle that without trouble!
15:18:14 <Tekmo> Yes, Double
15:18:35 <Tekmo> I've been using Data.Binary to serialize them
15:18:36 <wavewave> bgamari : http://stackoverflow.com/questions/6009321/weak=symbol-link-on-mac-os-x
15:18:40 <Tekmo> I don't know if there is a better way than that
15:18:51 <wavewave> bgamari: maybe this is relevant.
15:18:53 <Axman6> Tekmo: so you've been doing the serialisation by hand?
15:18:57 <acowley> I'd do my own serialization
15:19:49 <bgamari> wavewave: I see
15:19:55 <acowley> In fact, I'd probably do something nasty like mapM_ (putWord64host . unsafeCoerce)
15:20:22 <Tekmo> I'm not familiar with unsafeCoerce
15:20:25 <Axman6> Tekmo: if you use vector, you can use the vector-binary package. it's likely to be pretty fast (it's written by don stewart)
15:20:42 <Tekmo> Let me check it out vector-binary
15:20:46 <Cale> Oh, right, Binary's instance for Double uses decodeFloat and encodeFloat to switch to an Integer representation
15:20:57 <Cale> > decodeFloat pi
15:20:57 <lambdabot>   (7074237752028440,-51)
15:21:02 <Cale> ^^ like this
15:21:12 <acowley> right
15:21:15 <acowley> we don't want that
15:21:38 <acowley> s/we/I usually
15:21:51 <Cale> Tekmo: unsafeCoerce is a low-level hook for breaking the type system
15:22:03 <Eduard_Munteanu> :t unsafeCoerce
15:22:04 <lambdabot> Not in scope: `unsafeCoerce'
15:22:08 <Eduard_Munteanu> @hoogle unsafeCoerce
15:22:08 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:22:21 <Varakh> hi. i try to write function listSum which sums up sum: input [1,2,3] output [6,3,1] im getting: 3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 (no ending) and have this function:
15:22:21 <Cale> There's probably something a bit less ugly which one could do...
15:22:28 <Tekmo> So would the unsafeCoerce trick you mentioned work for serializing any type?
15:22:35 <Eduard_Munteanu> A bit like casting C pointers even to incompatible types.
15:22:36 <Cale> Tekmo: no
15:22:37 <acowley> Tekmo: it will just write 8 bytes
15:22:52 <Varakh> http://pastebin.com/Kjd8JfR3
15:22:54 <mauke> The paste Kjd8JfR3 has been copied to http://hpaste.org/53125
15:22:54 <Axman6> hmm, binary-vector does just use the standard instances for the elements -_-
15:23:00 <Cale> Tekmo: and in fact, with many types, will cause a segfault
15:23:12 <acowley> Cale: In this case, it will work
15:23:13 <Cale> (it's called unsafe for a reason!)
15:23:25 <Cale> Yeah, at least with GHC's current implementation of everything ;)
15:23:32 <acowley> I live for today
15:23:58 <BMeph> Varakh: What should your function do with an input of []? :)
15:24:01 <acowley> Tekmo: the snippet I wrote assumes that Double is internally represented as 8 bytes
15:24:21 <yitz> > reverse . scanl1 $ [1,2,3]
15:24:22 <lambdabot>   Couldn't match expected type `[a]'
15:24:22 <lambdabot>         against inferred type `[a1] -> [...
15:24:32 <yitz> > reverse . scanl1 (+) $ [1,2,3]
15:24:34 <lambdabot>   [6,3,1]
15:24:41 <acowley> Tekmo: so, in order to use a function from Data.Binary.Put that works with 8 byte values, I do the unsafeCoerce business and hope no one's looking
15:24:52 * BMeph chants: Please don't say "crash", please don't say "crash", please don't say "crash".
15:25:00 <Cale> (and that it's the same shape of Haskell type around an unboxed type)
15:25:10 <Tekmo> So one thing I'm curious about is why array or vector types just use a contiguous block of memory to store the array?
15:25:15 <Tekmo> *which
15:25:22 <Varakh> yitz: without reverse and without scan :P
15:25:27 <acowley> Tekmo: The unboxed ones
15:25:29 <Axman6> acowley: would using Storable be a slightly safer way to do the same thing?
15:25:33 <yitz> Varakh: i thought so
15:25:38 <Varakh> :D
15:25:40 <Axman6> poke the Double, read as 8 Word8's?
15:25:44 <acowley> Axman6: possibly!
15:26:01 <Axman6> endianness will be a little odd
15:26:15 <Varakh> yitz: any idea? :D
15:26:20 <acowley> Axman6: the unsafe binary hackery has treated me well over the years
15:26:26 <Axman6> heh
15:26:30 <Varakh> why does it create and endless stream of 1,1,1,1,1 ?
15:26:42 <Tekmo> What about the vector type?  Does it also use a contiguous block?
15:27:00 <Axman6> Tekmo: unboxed vectors will
15:27:03 <acowley> Tekmo: The Unboxed and Storable vectors will
15:27:34 <acowley> Tekmo: Storable is particularly inviting if you're thinking about interop
15:27:45 <Tekmo> Right now I'm not looking for interoperability just yet
15:27:53 <Tekmo> I'm actually just experimenting with porting c code to haskell
15:27:57 <acowley> Tekmo: It's a layer of Haskell icing on a humble array
15:28:04 <Axman6> in fact, you'd probably do well to use the Storable vectors, which should allow for easy writing to disk
15:28:08 <Varakh> BMeph: like yitz said without reverse and scanl1 :P
15:28:39 <Tekmo> Do you mean to say that storable will do I/O faster?
15:28:50 <Eduard_Munteanu> Varakh: you probably want drop instead of take
15:29:11 <Axman6> possibly. i've never done IO with storable, but i'm hoping there's a way of taking a Ptr and storing n bytes starting from that point
15:29:17 <BMeph> Varakh: What should your function do with an input of []? :)
15:29:25 <d-snp>     Could not find module `Data.Binary.Put':
15:29:36 <d-snp> is this something I should install somehow?
15:29:42 <Varakh> BMeph: nothing
15:29:45 <Varakh> :D
15:30:05 <bgamari> Axman6: Looks like there's unsafeToForeignPtr
15:30:23 <yitz> Varakh: your list will only stop if you get to the empty list. but your second equation always takes one element.
15:30:38 <Tekmo> The reason I'm asking all of this is because the Data.Binary instance of the Unboxed Arrays converts them to a list and then writes the list.  I was looking for something that would be smart and just copy a block of memory to disk.
15:30:39 <Eduard_Munteanu> d-snp: check out the 'binary' package
15:30:50 <yitz> Varakh: i mean always calls the function recursively with one element
15:31:18 <Axman6> Tekmo: Binary is designed for "obvious" serialisation, not the most efficient
15:31:33 <d-snp> hmm so I install cabal and then run: cabal install binary?
15:32:16 <d-snp> weird, I should have cabal installed since it's bundled with ghc, but I don't have it it seems
15:32:36 <bgamari> Axman6: although it might just be better to use the Storable instance itself
15:32:40 <Varakh> yitz: i dont see any mistake there
15:32:55 <Eduard_Munteanu> (Ah, nvm, you don't want 'drop')
15:33:07 <Axman6> bgamari: you need a way to writing the pointer 'contents' to disk, that's the main issue.
15:33:21 <Axman6> i guess using one of the unsafe bytestring functions would work out nicely
15:33:50 <bgamari> Axman6: I suppose sucessive peekBytes wouldn't perform particularly well
15:34:08 <d-snp> awesome, got it to work
15:34:10 <Axman6> no, that's not what i'm advocating
15:34:15 <Eduard_Munteanu> > map sum . inits $ [1,2,3]
15:34:17 <lambdabot>   [0,1,3,6]
15:34:29 <Varakh> if i change to listSum [a] = [a] the second addition is left out yitz
15:34:30 <bgamari> Axman6: that's what I had advocated
15:34:33 <Varakh> Eduard_Munteanu: no sum ;>
15:34:49 <Eduard_Munteanu> > map (foldl (+) 0) . inits $ [1,2,3]    -- :)
15:34:51 <lambdabot>   [0,1,3,6]
15:35:03 <Eduard_Munteanu> @src sum
15:35:04 <lambdabot> sum = foldl (+) 0
15:35:05 <Tekmo> Oh, on a tangent, for the list summing problem
15:35:12 <Tekmo> I just did that yesterday for something else
15:35:15 <bgamari> Axman6: I don't see anything in Data.ByteString.Unsafe along these lines
15:35:25 <Tekmo> I ended up just hand coding a tally function
15:35:37 <Tekmo> that would tail-recurse over the list
15:35:50 <Eduard_Munteanu> Tekmo: sum should work fine if you enable optimizations
15:36:09 <Tekmo> Not sum
15:36:24 <Tekmo> Oh wait
15:36:28 <Tekmo> Yeah, I see how that one works
15:36:32 <Varakh> Eduard_Munteanu: and now it has to be reversed without using reverse :D
15:36:33 <Tekmo> I like that way better
15:36:47 <Varakh> yitz: ? :D
15:36:55 <hpaste> BMeph annotated “pastebin.com/Kjd8JfR3” with “pastebin.com/Kjd8JfR3 (annotation)” at http://hpaste.org/53125#a53126
15:36:58 <Eduard_Munteanu> Varakh: well, try writing reverse yourself
15:37:00 <bgamari> acowley: Have you considered using vector-mmap
15:37:27 <Tekmo> I ended up doing: tally n xs = case xs of [] -> []; (y:ys) -> (y+n):tally (y + n) ys
15:37:39 <Tekmo> and then just calling tally 0 xs
15:37:41 <acowley> bgamari: I haven't tried it
15:38:20 <bfig> question about generic folds: if i have D = t1 + t2 + t3 + ... + tn then the fold will have n components right?
15:38:20 <Varakh> Eduard_Munteanu: i died that
15:38:21 <Varakh> ;>
15:38:38 <bgamari> acowley: Might save you some effort in serialization/deserialization
15:38:56 <hpaste> BMeph annotated “pastebin.com/Kjd8JfR3” with “No reverse, (technically) no sum” at http://hpaste.org/53125#a53127
15:39:14 <Varakh> is it not possible to do it like i proposed?
15:39:51 <acowley> bgamari: I usually find myself having to work with vector data found somewhere in the middle of a file
15:40:05 <acowley> bgamari: but for stashing temporary values, vector-mmap looks very useful
15:40:09 <Cale> bfig: Yeah, it'll take n replacements for the constructors
15:40:18 <Cale> (one for each constructor in your type)
15:40:28 <d-snp> http://pastie.org/2759033 <-- why does the parser fail on line 5, column 3? is there something wrong with how I define my type?
15:40:46 <Eduard_Munteanu> Tekmo: well that's more or less what Varakh is asking about
15:42:12 <Eduard_Munteanu> d-snp: 'type' is a reserved keyword
15:42:14 <Tekmo> So you're saying the sum and inits trick you gave will also compile to the smart loop?
15:42:15 <bfig> Cale, ok, and the functions in each component will have one argument for each product term right?
15:42:16 <d-snp> ohhh
15:42:17 <Varakh> listSum list = [(foldl(+) 0 list)] ++ listSum (init list)
15:42:25 <Varakh> there it is :D
15:42:27 <d-snp> hmm
15:42:28 <Cale> bfig: yes
15:42:32 <bfig> cool :D
15:42:50 <hpc> why not listsSum = map sum . inits?
15:43:04 <hpc> or is this a homework thing?
15:43:04 <Cale> bfig: You should just think of them as substitutions for each of the constructors of the datatype -- so in the recursive case, you're going through a tree and replacing each of the nodes with a function.
15:43:16 <Eduard_Munteanu> hpc: looks like it
15:43:17 <bfig> i haven't understood so far what the In/Out stuff does
15:43:19 <Cale> (the branch nodes)
15:43:27 <Cale> and the leaves with possibly a non-function value
15:43:28 <Varakh> ye some practice for lecture
15:44:01 <Cale> bfig: Oh, that's a way to make the fixed point at the type level explicit, so that a generic kind of fold can be written once-and-for-all
15:44:22 <Cale> (for types written in terms of that explicit fixed point)
15:44:35 <Tekmo> So if I'm reading Data.Vector.Unboxed correctly, it only supports Int indices and not polymorphic indices like Data.Array.Storable, so I should probably use Storable
15:44:56 <Cale> It's not terribly practical, unfortunately, because of the syntactic noise, but conceptually, it's nice that it's possible
15:45:22 <bfig> mmm :|
15:45:22 <Cale> Tekmo: Yeah, I'm not really sure why that is.
15:45:25 <Axman6> Tekmo: why do you need polymorphic indices? they add quite a bit of overhead
15:45:36 <Tekmo> I want to work with matrices
15:45:44 <Axman6> so?
15:45:45 <Cale> It's not *that* much overhead. You just use the Ix methods :P
15:45:54 <Axman6> oh right, Vector is 1D
15:46:03 <Axman6> Cale: performance overhead
15:46:05 <Eduard_Munteanu> Tekmo: have you looked at hmatrix?
15:46:08 <Tekmo> Yeah, I have
15:46:19 <Axman6> Tekmo: Repa might also be worth checking out
15:46:21 <Cale> index is a pretty cheap function in most cases :)
15:46:33 <Eduard_Munteanu> It might come in handy if you're doing linear algebra stuff.
15:46:33 <Axman6> not sure about its serialisation
15:46:39 <Tekmo> Well, in this case it's not linear algebra
15:46:48 <Tekmo> But I have used it before for BLAS/LAPACK methods
15:46:55 <Tekmo> I just want a matrix just to organize the data
15:47:01 <Eduard_Munteanu> Ah.
15:47:28 <Cale> > index ((0,0),(100,100)) (20,50)
15:47:28 <lambdabot>   2070
15:47:46 <hpc> :t index
15:47:47 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
15:47:50 <bfig> why is haskell so awesome? :). seriously, it is an awesome language
15:48:01 <Cale> ^^ you can use that explicitly to compute which index is appropriate
15:48:01 <Tekmo> So even if I use Data.Vector, I'd still be using an index function that I hand-wrote
15:48:03 <Cale> also:
15:48:07 <Tekmo> Or use that one
15:48:07 <hpc> that's like asking why pizza is awesome :P
15:48:11 <Cale> > rangeSize ((0,0),(100,100))
15:48:12 <lambdabot>   10201
15:48:20 <Tekmo> But in which case I might as well use Data.Storable
15:48:27 <Cale> Pretty much :)
15:48:33 <Tekmo> The index function is not costing me muhc
15:48:37 <Cale> Though Data.Vector does more fusion, iirc.
15:48:38 <Tekmo> The matrix computation is fast enough for me
15:48:43 <Varakh> is it possible to get the length of the beginning list within the last step of recursion?
15:48:56 <acowley> Tekmo: I just write my own indexing function in these cases
15:49:05 <Tekmo> Yeah, I know how to do it
15:49:15 <Cale> I honestly really like the way that the Array library uses Ix.
15:49:15 <Tekmo> My native language is C after all
15:49:30 <Tekmo> I'm more concerned with the I/O at the moment
15:49:37 <Eduard_Munteanu> IDK, do you need indexing to serialize
15:49:38 <Eduard_Munteanu> ?
15:49:43 <Varakh> Tekmo: i hope its english xD
15:49:54 <Tekmo> No, it's not;
15:49:59 <Cale> It was a detail that I found pretty impressive when I first discovered Haskell's Array library :)
15:50:09 <Varakh> :p
15:50:11 <Cale> (and made me wonder why other languages weren't doing that)
15:50:27 <Axman6> Tekmo: i'd consider using Repa, it will do lovely things like automatic parallelisation, and has the ability to be written to a bytestring for writing to a file
15:50:41 <Tekmo> I'll check out Repa
15:50:45 <kmc> ♥ Repa
15:50:51 <acowley> shoot, I have some neat vector indexing code somewhere, but now can't find it
15:51:00 <Varakh> any idea about my queston above? :D
15:51:23 <Eduard_Munteanu> derpa
15:51:26 <Axman6> hmm, seems you can only convert Word8 Repa arrays to bytestrings -_-
15:51:42 * Eduard_Munteanu doesn't think that's such a bad name
15:51:59 <JoeyA> Varakh: I'm not sure what you mean.
15:52:10 <hpc> Eduard_Munteanu: herpa - it has to start with an 'h' to be a haskell lib!
15:52:12 <kmc> Axman6, you can get at the underlying Vector, and use http://hackage.haskell.org/package/spool
15:52:16 <acowley> derpa is an awesome name
15:52:16 <kmc> or is it not Vector.Storable?
15:52:39 <Cale> Varakh: If I understand your question correctly, the answer is no.
15:52:44 <Eduard_Munteanu> hpc: have you seen pumpkin's derpa? (Agda stuff)
15:52:55 <hpc> i have not
15:52:58 <Tekmo> I'm reading the Repa page and it says it uses Vector.Unboxed for the underlying type
15:53:05 <Cale> Varakh: Your function can only depend on the parameters it has been given.
15:53:09 <Axman6> kmc: heh, i was going to write that function if it didn't already exist
15:53:44 <acowley> Tekmo: Repa adds flexible indexing to the mix
15:53:44 <Varakh> JoeyA: input of function: [1,2,3] output: [3,3,3,2,2,1] so replicate content of list with number of index+1 and reverse order :p
15:53:51 <Cale> Varakh: If it's recursive, and applies itself to the tail of a list, the result of that recursive application of the function will only depend on the tail in isolation, and not on where the tail came from
15:53:53 <Tekmo> Yeah, I got that
15:54:00 <Eduard_Munteanu> https://github.com/copumpkin/derpa
15:54:24 <Cale> Varakh: what will the function do to [4,5,6]?
15:54:39 <Varakh> [6,6,6,5,5,4]
15:54:42 <Cale> okay
15:54:49 <JoeyA> > (map (\x -> replicate x x) . reverse) [1,2,3]
15:54:50 <lambdabot>   [[3,3,3],[2,2],[1]]
15:54:55 <Varakh> no reverse
15:54:58 <Cale> So you may want to start by pairing each element with its index
15:54:58 <Varakh> :>
15:55:07 <JoeyA> > (concatMap (\x -> replicate x x) . reverse) [1,2,3]
15:55:08 <lambdabot>   [3,3,3,2,2,1]
15:55:16 <Cale> > zip [1..] [4,5,6]
15:55:17 <lambdabot>   [(1,4),(2,5),(3,6)]
15:55:25 <JoeyA> @src reverse
15:55:26 <lambdabot> reverse = foldl (flip (:)) []
15:55:40 <hpc> Eduard_Munteanu: the names of identifiers are extremely confusing
15:56:00 <Varakh> JoeyA: no concatmap ^^
15:56:05 <Cale> But if you're taking a lower-level approach by recursion, I guess there's an easy way
15:56:08 <Varakh> we didnt have that :D
15:56:19 <hpaste> Danl2620 pasted “parsec issue” at http://hpaste.org/53128
15:56:43 <Varakh> multReverse (x:rest) = multReverse rest ++ replicate (length rest+1) x
15:57:04 <Varakh> this will repeat it on the other way around :D
15:57:04 <Danl2620> Do the parsec examples in RWH work in 6.12?
15:57:17 <Varakh> so last once, last but one 2 times etc
15:57:50 <Axman6> Tekmo: ok, so putting the pieces together, it seems that you should use Repa for your computation, then use toVector to create a vector, and use the spool package to create a bytestring, and write out the the shape of the array followed by the data from the bytestring
15:58:43 <Varakh> JoeyA: any idea how i get this with my recursion?
15:59:00 <Tekmo> I was checking out repa and there is a package called repa-io designed to work with repa
15:59:11 <BMeph> Varakh: If you can't use regular functions, then you might as well just write C in Haskell. :/
15:59:34 <Varakh> BMeph: its just practice
15:59:41 <Tekmo> http://hackage.haskell.org/package/repa-io-2.2.0.1
16:00:12 <Varakh> my worksheet states "no reverse and no thing we havent done already" :D
16:00:16 <Axman6> Tekmo: it seems to like writing things using ASCII...
16:00:27 <Tekmo> Check out the Binary one
16:00:32 <Tekmo> http://hackage.haskell.org/packages/archive/repa-io/2.2.0.1/doc/html/Data-Array-Repa-IO-Binary.html
16:00:42 <JoeyA> Varakh: Can you emulate concatMap (\x -> replicate x x) with simple recursion?  That is, everything but the reversing part.
16:00:44 <Axman6> ah yes, looks good =)
16:00:50 <JoeyA> > concatMap (join replicate) [1,2,3]
16:00:51 <lambdabot>   [1,2,2,3,3,3]
16:01:04 <Tekmo> So that's a good solution
16:01:12 <Tekmo> I'm still curious about how you would write a storable to disk, though
16:01:16 <Axman6> Tekmo: finding it took far too long -_-
16:01:16 <BMeph> multReturn list = go 1 list where {go _ [] = []; go n (x:xs) = go (n+1) xs ++ replicate n x}
16:01:22 <JoeyA> "join f" is just a fancy way of saying "\x -> f x x", but join can be used for other types, too.
16:01:36 <Tekmo> Because in the future I may want to interface haskell and C code
16:01:41 <Tekmo> so that's something I'd like to learn to do
16:01:46 <Axman6> Tekmo: Storable is basically just working with raw pointers, so you can have a C array of Double
16:02:01 <JoeyA> Varakh: But I digress.  See if you can write a function that turns [1,2,3] into [1,2,2,3,3,3].
16:02:12 <Tekmo> I get how you access the Ptr, but I don't know what to do with it after that point
16:02:38 <BMeph> Varakh: Your earlier version works.
16:02:47 <JoeyA> On the other hand, building the list in reverse might be easier.
16:03:27 <JoeyA> You can use an inner helper function whose recursive loop piles up the items.
16:03:28 <Axman6> Tekmo: time to start reading up on the FFI then i guess
16:04:05 <acowley> Tekmo: You'd allocate some bytes, poke your values into the bytes, then write the bytes to a handle
16:04:20 <Varakh> BMeph: no? :D
16:04:21 <Tekmo> I get that
16:04:26 <JoeyA> pile :: Int -> a -> [a] -> [a] -- prepend n copies of an item to the list.
16:04:31 <Tekmo> I mean, I'm looking at how to write a Ptr to a memory block to disk
16:04:32 <JoeyA> Varakh: Can you implement that?
16:04:39 <Varakh> JoeyA: no help functions :X
16:04:47 <JoeyA> Varakh: Not even your own?
16:04:52 <Varakh> no
16:04:53 <Varakh> -.-
16:04:55 <BMeph> Varakh: Your instructor seems to have an odd habit of wanting reversed input, but denying you the use of "reverse". Maybe you should just write your own reverse, and do it the "natural" way, lol. ;)
16:04:57 <Varakh> strict orders, sry
16:05:05 <acowley> Tekmo: hPutBuf
16:05:15 <Varakh> ^^
16:05:16 <acowley> Tekmo: That's the third part of what I said
16:05:19 <Varakh> he has, yep
16:05:27 <Tekmo> Thanks.  hPutBuf was what I was looking for
16:05:35 <acowley> :t hPutBuf
16:05:36 <lambdabot> Not in scope: `hPutBuf'
16:05:42 <Varakh> JoeyA: any other idea? :D
16:05:45 <acowley> @hoogle hPutBuf
16:05:45 <lambdabot> System.IO hPutBuf :: Handle -> Ptr a -> Int -> IO ()
16:05:45 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
16:06:30 <JoeyA> Varakh: So what are you allowed to use?
16:06:36 <Tekmo> Ok, I have two good solutions now to do this.  Thanks everybody for all your help.
16:07:01 <Varakh> map, filter, take, drop, dropwhile, takewhile, init, head, tail
16:07:18 <acowley> Tekmo: The great part is that there are a ton of ways to do this efficiently in Haskell. The frustrating part is that there are a ton of ways to do this efficiently in Haskell.
16:07:55 <JoeyA> Varakh: And you're not even allowed to say foo f = loop ... where loop ... =   ?
16:07:59 <hpc> Varakh: are all those the functions you can use?
16:08:09 <bgamari> Does anyone know where I could find a snippet of code to read a files in chunks (say, of 8 bytes) until EOF with enumerator?
16:08:42 <JoeyA> http://hackage.haskell.org/packages/archive/enumerator/0.4.15/doc/html/Data-Enumerator-Binary.html
16:08:42 <Varakh> JoeyA: no
16:08:45 <Varakh> :>
16:08:51 * BMeph can't imagine learning C++ where the teacher tells you "Make a system that does 'x', but don't use templates, or classes with more than two members."
16:08:51 <Varakh> hpc: yes
16:09:02 <JoeyA> bgamari: enumHandle?
16:09:13 <yitz> > let addSum xs@(x:_) y = (x+y):xs; addSum _ y = [y] in foldl addSum [] [1,2,3]
16:09:14 <lambdabot>   [6,3,1]
16:09:17 <dino-> I ran into the deprecated runTests cabal thing with one of my old project. So, working on bringing that into the test-suite .cabal thing...
16:09:30 <DanBurton> > foldr (:) [4,5,6] [1,2,3]
16:09:31 <lambdabot>   [1,2,3,4,5,6]
16:09:40 <dino-> I can only then run unit tests with cabal test, not runhaskell Setup.hs test
16:09:50 <hpc> BMeph: my AI prof tried to make us learn functional style with "you must write (fib n), without any helper functions, lets, or setfs"
16:09:57 <dcoutts> dino-: it's not going to disappear anytime soon, but the new stuff does offer more features
16:10:00 <dino-> But what happens if I have some things (like post install code) in a Setup.hs that can't go into .cabal?
16:10:07 <BMeph> yitz: I'm sure there's a "no as-patterns" rule, too. :P
16:10:25 <acowley> Is anyone teaching a 100% pointfree Haskell class?
16:10:37 <yitz> BMeph: most probably. that's why i wrote it that way. :)
16:10:37 <Tekmo> acowley: I agree.  Haskell is incredibly flexible and it's just a matter of finding the right library
16:10:39 <hpc> acowley: im sure someone is teaching a pointless one
16:10:39 <bgamari> JoeyA: It's the "until EOF" that I'm really having trouble understanding
16:10:41 <hpc> ;)
16:10:55 * acowley shakes his fist at hpc
16:11:24 <dcoutts> dino-: did you remove the test hook in your Setup.hs? otherwise that's going to interfere when doing runhaskell Setup.hs test
16:11:36 <bgamari> JoeyA: enumHandle takes chunks of a given size; What happens if the file size isn't divisible by this size?
16:12:09 <dino-> dcoutts: Ah, no. So running through Setup.hs will use the .cabal defs.
16:12:10 <dcoutts> dino-: re post install code, so long as you're specifing build-type: Custom rather than Simple, then cabal-install will run it
16:12:15 <JoeyA> bgamari: The last chunk will be smaller than the chunk size.  I haven't tried it, but common sense tells me so.
16:12:16 <Varakh> got it
16:12:16 <Varakh> :D
16:12:23 <Varakh> wanna see?
16:12:30 <JoeyA> Varakh: Sure
16:12:39 <Varakh> multReverse (x:rest) = (replicate (length (x:rest)) (last (x:rest))) ++ multReverse (init (x:rest))
16:12:42 <dino-> dcoutts: Aha, that's something I didn't know. Ignorance of build-type is jamming me.
16:12:48 <dino-> <- needs to read docs more
16:12:49 <JoeyA> You're allowed to use replicate?
16:13:01 <Varakh> yes
16:13:02 <Varakh> ^^
16:13:09 <Varakh> sry
16:13:14 <JoeyA> > let multReverse (x:rest) = (replicate (length (x:rest)) (last (x:rest))) ++ multReverse (init (x:rest)) in multReverse [1,2,3]
16:13:16 <lambdabot>   [3,3,3,2,2,1*Exception: <interactive>:3:4-102: Non-exhaustive patterns in f...
16:13:23 <JoeyA> You need an empty list case in there.
16:13:27 <Varakh> ye
16:13:32 <Varakh> i have it in my .lhs file
16:13:33 <Varakh> ^^
16:13:34 <JoeyA> > let multReverse [] = []; multReverse (x:rest) = (replicate (length (x:rest)) (last (x:rest))) ++ multReverse (init (x:rest)) in multReverse [1,2,3]
16:13:35 <dino-> dcoutts: ok ok, will go read more and tune my projects up with new knowledge.
16:13:35 <lambdabot>   [3,3,3,2,2,1]
16:13:40 <dino-> dcoutts: Thank you
16:13:48 <dcoutts> dino-: saying "build-type: Simple" declares that you're not using a custom Setup.hs (so cabal can do some things a bit quicker, and it will even cope without a Setup.hs)
16:14:06 * JoeyA isn't a fan of forall a. ProgrammingLanguage a => Literate a
16:14:38 <JoeyA> To me, it just scrambles the source code.
16:14:50 * ski ponders illiterate programming
16:15:04 <hpc> JoeyA: literate code is not meant to be read in the same editor you would code in
16:15:06 <ski> maybe that's the same as visual programming ?
16:15:07 <dcoutts> ski: perhaps lolcode?
16:15:10 * BMeph ponders transclusion
16:15:19 <hpc> it's perfect for posting on websites though
16:15:34 <dino-> Thanks again and apologies for silly questions whose answers lie in docs.
16:15:39 <ski> (i.e. <http://en.wikipedia.org/wiki/Visual_programming_language>)
16:16:36 <Danl2620> I have a question about the parsec examples in the RWH book.  Is this the right place?
16:16:40 * mgsloan1 has been using pure data a bit recently
16:16:48 <Axman6> yes
16:17:07 <ski> @wn transclusion
16:17:08 <lambdabot> No match for "transclusion".
16:17:43 <acowley> Danl2620: Yes!
16:17:47 <kmc> hpc, you refer to the fact that literate programs can be rendered to nicely typeset documents?
16:17:54 <Danl2620> just typing in a ghci example from the book, I get http://hpaste.org/53128
16:18:11 <yitz> @google transclusion
16:18:11 <lambdabot> http://en.wikipedia.org/wiki/Transclusion
16:18:11 <lambdabot> Title: Transclusion - Wikipedia, the free encyclopedia
16:18:13 <d-snp> is this the correct way of nesting do statements? http://pastie.org/2759185
16:18:18 <Danl2620> (trying putting together simple parsers in ghci)
16:18:25 * ski . o O ( <http://en.wiktionary.org/wiki/transclusion> )
16:18:30 <d-snp> I've been doing this on intuition, I should probably read something
16:19:10 * ski . o O ( <http://en.wikipedia.org/wiki/Intuition_%28Amiga%29> )
16:19:21 <JoeyA> I'm starting to think Parsec isn't a good thing to throw at people who are new to Haskell.  It's a parsing monad *and* a state monad transformer.
16:19:40 <JoeyA> It's somewhat impenetrable to people still trying to grasp what a monad is.
16:19:47 * ski wonders what a state monad transformer is
16:19:50 <Danl2620> it's so simple when it works... ;)
16:20:30 <bgamari> JoeyA: So I guess if I read a chunk of n encoded records, I should emit a list of n decoded records?
16:20:32 <JoeyA> I think Attoparsec is a better place to start.
16:20:38 <hpc> kmc: yes
16:20:39 <JoeyA> (as opposed to Parsec)
16:20:49 <ski> (.. something that transforms state monads to state monads ?)
16:20:50 <acowley> Danl: You just need a type annotation
16:21:12 <acowley> appending ":: Parser String" to the end of your snippet does the trick
16:21:27 <JoeyA> bgamari: In what context?
16:21:37 <JoeyA> Are you writing an Enumeratee?
16:21:43 <JoeyA> (that decodes records)
16:21:51 <bgamari> JoeyA: Yes
16:22:11 <yitz> ski: a monad transformer provided by the government
16:22:27 <d-snp> could anyone look at my pastie? I'm a bit puzzled
16:22:46 <yitz> d-snp: looked ok to me at first glance
16:23:19 <JoeyA> bgamari: I think I understand Enumeratee now, after trying to understand it a couple days ago.
16:23:20 <d-snp> hmm, then maybe I'm not using something right
16:23:26 <ski> yitz : or maybe it transforms government-endorsed monads into government-endorsed monads ?
16:23:35 <JoeyA> type Enumeratee ao ai m b = Step ai m b -> Iteratee ao m (Step ai m b)
16:23:47 <kmc> mm, I really like literate programming for blog posts and the like
16:23:59 <bgamari> JoeyA: I've been struggling with this as well
16:24:16 <kmc> it's a nice style if you *want* to write a detailed document about how your code works
16:24:23 <d-snp> http://pastie.org/2759211 <-- this is the error
16:24:30 <JoeyA> When you run Iteratee ao m (Step ai m b) with runIteratee, the result is:
16:24:31 <kmc> I don't think I want that for most of the software I write, though
16:24:40 <d-snp> hmm maybe I'm missing some parameter
16:24:48 <JoeyA> m (Step ao m (Step ai m b))
16:24:49 <JoeyA> I think
16:25:26 <JoeyA> bgamari: The key thing to notice is that an Enumeratee can return two steps.  This distinguishes it from an Enumerator that consumes input.
16:25:45 <d-snp> putNBits :: (Integral a, Bits a) => Int -> a -> BitPut <-- what does the => sign mean here?
16:25:53 <dafis> d-snp: guess: putNBits 5 (reserved h)
16:25:54 <yitz> d-snp: it's telling you that putNBits needs 2 parameters but you only gave it one
16:26:03 <d-snp> hmm
16:26:23 <dafis> d-snp: it means I guessed right
16:26:27 <JoeyA> Thus, you can read some data and have leftovers, and whoever's reading your data can have leftovers, too.
16:26:56 <QtPlatypus> d-snp: The => sign is telling yu that a must be a member of the typeclasses Integral and Bits.
16:27:09 <JoeyA> bgamari: For example, suppose you have an input source that produces data in chunks of 64 bytes.
16:27:25 <d-snp> alright got a much bigger error message now, decoding time :P
16:27:26 <Danl2620> acowley: cool, that works. thanks!
16:27:35 <JoeyA> bgamari: And you want to write an Enumeratee that takes those chunks and returns lines.
16:27:41 <bgamari> JoeyA: Sure
16:28:00 <JoeyA> This allows an Iteratee ByteString m a to read lines.
16:28:02 <bgamari> I think I've seen a similar example
16:28:53 <JoeyA> Consider the input source, an Enumerator ByteString m b that grabs chunks of 64 bytes.
16:29:03 <d-snp> thanks QtPlatypus, I got that now :)
16:29:17 <JoeyA> Without the type alias: Step ByteString m b -> Iteratee ByteString m b
16:29:56 <JoeyA> If the enumerator only produces a single line, then binding it to an iteratee that reads lines will produce an iteratee that needs the remaining lines.
16:30:19 <bgamari> ahh
16:30:40 <JoeyA> So if foo :: Iteratee ByteString IO Blah needs to read 5 lines
16:30:58 <monochrom> Evariste Galois's birthday. does galois.com hold a party? :)
16:31:02 <JoeyA> and readLine :: Enumerator ByteString IO a reads a single line
16:31:22 <JoeyA> Then readLine >>== foo is an iteratee that needs to read 4 lintes.
16:31:41 <JoeyA> err, foo >>== readLine
16:31:48 <bgamari> ahh, yes
16:31:54 <JoeyA> foo is plugging its Step into the enumerator
16:32:11 <JoeyA> The enumerator feeds the Continue function with a line, yielding an Iteratee that needs the rest.
16:32:27 <d-snp> omg it ran without error
16:32:39 <JoeyA> http://stackoverflow.com/questions/7683408/what-happens-if-an-enumerator-tries-to-consume-input/7857851#7857851
16:33:00 <JoeyA> I wrote about how an Enumerator works here.  However, I didn't talk about Enumeratee, as I didn't understand it then.
16:34:06 <JoeyA> A less confusing way to look at Enumerator is to think of it as: Iteratee a m b -> Iteratee a m b
16:34:07 <JoeyA> It modifies an iteratee by feeding it some input.
16:34:17 <JoeyA> It could possibly feed it an unlimited supply of input, or input terminated with EOF.
16:35:02 <bgamari> sure
16:35:17 <JoeyA> However, Step a m b -> Iteratee a m b means the enumerator doesn't have to run the input iteratee to get its step.
16:35:34 <JoeyA> (it does have to run it to get additional steps, though)
16:36:35 <JoeyA> I may go ahead and write an example of an enumeratee that takes chunks of input and turns them into lines.
16:38:24 <bgamari> JoeyA: That would probably be of use to me at least
16:38:52 <ben> @hackage netlines
16:38:52 <lambdabot> http://hackage.haskell.org/package/netlines
16:39:33 <bgamari> JoeyA: If I have 6 byte records, however, I probably want to output a list of them for efficiency's sake, right?
16:39:51 <bgamari> One per chunk would likely be horribly inefficient
16:39:59 <ben> Is attoparsec basically a funny way to say Iteratee ByteString IO or something?
16:40:19 <JoeyA> Iteratee ByteString IO is a funny way of saying... something :P
16:40:29 <bgamari> ben: Thanks
16:41:31 <ben> JoeyA: Well, iteratee feeding on bytestrings in the io monad computing... something, I suppose
16:42:02 <ben> I'm not good with enumerator but it looks like the attoparsec Result type is fairly close to a Step value?
16:42:30 <ben> Except you put in the IO on another side
16:44:36 <d-snp> http://pastie.org/2759293 <-- this code works, so ya'll know :D
16:44:51 <d-snp> feeling pretty good about myself now ;)
16:45:25 <bgamari> Are streams with lots of small chunks inherently inefficient?
16:45:42 <d-snp> small chunks implies header overhead
16:45:45 <d-snp> so yeah
16:45:46 <bgamari> Or will the compiler do some magic to reduce the overheat
16:45:49 <bgamari> overhead*
16:45:52 <Axman6> no
16:46:15 <Axman6> the compiler isn't all knowing and doesn't implement such specific optimisations
16:46:36 <bgamari> fair enough
16:47:27 <RaptorRarr> Is it possible for the library authors to specify those optimizations?
16:55:36 <hpaste> “Ben Gamari” pasted “Enumerator confusion” at http://hpaste.org/53131
16:55:47 <bgamari> Can someone help me fix the above?
16:56:16 <bgamari> It's an enumeratee to split up chunks into 6 byte words
16:56:29 <bgamari> Currently, however, produces chunks with only one word
16:56:51 * eyu100 can't believe haskell collections don't have arg max functions
16:56:54 <bgamari> I must admit it's not obvious to me how to do this such that I get larger chunks
16:57:28 * ski wonders what "arg max functions" might be
16:57:46 <eyu100> http://en.wikipedia.org/wiki/Arg_max
16:57:54 <bgamari> ski: I would assume a function which would return the index of the maximum in a list
16:57:59 <Daegalus> Can anyone help me figure this out. I know i am probably completely off, but I am going in circles with Type errors and I am not sure where I am going wrong or if the way I am doing it will even work: http://hpaste.org/53132
16:58:10 <eyu100> or for something like a map, returning the key of the largest value
16:58:10 <eyu100> etc.
16:59:56 <JoeyA> The EB.require 6 is redundant, I think
17:00:00 <JoeyA> (since you have EB.take 6)
17:00:32 <JoeyA> bgamari: Just make it E.Enumeratee BS.ByteString Word48 m b
17:00:43 <bgamari> JoeyA: Yeah, the code is supposed to get the idea across
17:00:54 <bgamari> JoeyA: But this will be inefficient, no?
17:01:07 <JoeyA> No, not any more inefficient.
17:01:11 <JoeyA> The Stream type already has a list in it.
17:01:19 <bgamari> Ahh, alright
17:01:26 <bgamari> that was easy
17:01:57 <JoeyA> If you wanted it to be efficient, I think you would have to read bytestring chunks and split them manually, rather than taking 6 at a time.
17:02:12 <ski> @type fmap fst . listToMaybe . foldr (insertBy (flip (comparing snd))) [] . zip [0 ..]
17:02:13 <lambdabot> forall a b. (Ord b, Num a, Enum a) => [b] -> Maybe a
17:02:25 <ski> > (fmap fst . listToMaybe . foldr (insertBy (flip (comparing snd))) [] . zip [0 ..]) "abraxas"
17:02:27 <lambdabot>   Just 4
17:02:34 <bgamari> JoeyA: I could definitely do that
17:03:05 <bgamari> JoeyA: I'm just worried that enumHandle will give me chunks that aren't sized as a multiple of my word size
17:03:10 <JoeyA> However, beware of the edge cases: 1) You get to the end of a ByteString, and it has less than 6 bytes.  You have to hang onto them for the next chunk.
17:03:25 <bgamari> JoeyA: It's fine if it does that at the end of the file (hopefully this will never happen)
17:03:33 <JoeyA> 2) You don't have enough input available.  You could use require in that case.
17:03:45 <JoeyA> (err, you don't have enough input available *at the moment*)
17:03:47 <bgamari> #2 was what I was worried about
17:03:51 <bgamari> right
17:04:01 <JoeyA> bgamari: #1 can happen for every chunk of input.
17:04:08 <bgamari> Ahh, right
17:04:17 <bgamari> I guess both are troublesome
17:04:19 <ski> eyu100 : ^ would work for lists, at least
17:04:28 <JoeyA> If your input source is reading in chunks of 64, you'll end up with leftovers per chunk.
17:04:38 <bgamari> yep
17:04:46 <bgamari> so that gets messy
17:04:46 <ski> @type findIndex
17:04:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
17:04:48 <ski> @type findIndices
17:04:49 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
17:05:13 <JoeyA> You may want to consider unboxed Vectors instead of lists, for values that small.
17:05:22 <bgamari> would I really be able to handle it more efficiently than Enumerator.Binary?
17:05:33 <JoeyA> Maybe
17:05:45 <JoeyA> bgamari: For one thing, Enumerator.Binary uses Integer for take and require :(
17:06:00 * ski wonders whether one can generalize the "find inputs/indices/keys with minimal/maximal outputs/elements/values" case in some nice way
17:06:01 <bgamari> JoeyA: Ahh, yeah. that's potentially an issue
17:06:28 <salisbury> I am searching for an example implementation of a the seesaw coroutine pattern. Anyone know of any code I can take a peek at?
17:06:42 <bgamari> JoeyA: Will unboxing help speed or just memory consumption?
17:07:00 <JoeyA> Both, I would think (if you're careful).
17:07:08 <JoeyA> What are these Word48s for, anyway?
17:07:09 <companion_cube> both, since speed is bound to memory
17:07:23 <bgamari> JoeyA: Strictly speaking right after this enumeratee is another enumeratee which decodes the word into a record
17:07:33 <ski> (JoeyA : i would prefer it using `Integral', with specialized versions for `Int' and `Integer', at least)
17:07:41 <bgamari> companion_cube: Not if things stay in cache, no?
17:07:43 <JoeyA> One word per record, then?
17:07:53 <JoeyA> bgamari: In that case, unboxing probably won't help much.
17:07:56 <bgamari> JoeyA: yep
17:08:51 <JoeyA> bgamari: I'm wondering if you would be better off implementing an Instance Storable for your records.
17:09:37 <bgamari> JoeyA: Further down the line someone will take the record and perhaps just drop it or maybe take one of its fields and build a vector out of these values
17:09:49 <bgamari> JoeyA: Could be
17:10:16 <bgamari> JoeyA: Then I could just use a storable vector
17:10:22 <bgamari> and do away with enumerator entirely
17:10:42 <bgamari> ultimately the data is coming from a file
17:10:47 <bgamari> albeit a very large file
17:11:03 <JoeyA> Yeah, I'm thinking enumerator wouldn't be a good idea.
17:11:04 <bgamari> so i don't necessarily need enumerator if I can mmap it
17:11:16 <JoeyA> Just read the file in large-ish chunks divisible by 6.
17:11:25 <JoeyA> And have a Storable instance for decoding the records.
17:12:47 <bgamari> JoeyA: Alright. Thanks for your help!
17:13:03 <bgamari> Data.Vector.Storable is unboxed, right?
17:13:53 <JoeyA> .Unboxed.
17:14:35 <bgamari> There is no Data.Vector.Storable.Unboxed
17:14:36 <JoeyA> The Storable class indicates how to read/write a given type of value from/to memory.
17:14:46 <JoeyA> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Storable.html
17:14:47 <bgamari> right, I guess that means yes
17:14:56 <bgamari> it doesn't construct the record until you ask it to
17:15:01 <JoeyA> I think you need a Storable instance to use it with Data.Vector.Unboxed.
17:15:35 <JoeyA> You also need to deal with the Unbox class.  I'm not sure how it's done, though.
17:16:32 <JoeyA> Anyway, implementing unboxed vectors for new types can be "very easy": http://hackage.haskell.org/packages/archive/vector/0.9/doc/html/Data-Vector-Unboxed.html
17:16:51 <bgamari> JoeyA: The vector-mmap code only produces Data.Vector.Storable vectors anyways
17:16:54 <JoeyA> (that's followed by code that doesn't look entirely easy to me)
17:17:08 <bgamari> JoeyA: Yeah, I think I've looked into Unbox in the past
17:17:19 <bgamari> It looks like storable shouldn't be bad, however
17:17:21 <JoeyA> Ah, didn't know about vector-mmap
17:17:57 <ben> I'm tring to understand part of the implementation of attoparsec. I can't seem to figure out what the Added type/values that get threaded around along with the input. What is it for?
17:18:13 <ben> ...+is for.
17:24:53 <Daegalus> If anyone can help me with the annotation of this: http://hpaste.org/53132 , I would greatly appreciate it
17:26:14 <mm_freak> i experimented with SPECIALIZE to improve the performance of my code…  while playing with it i noticed that a certain specialization caused my performance to drop by a factor of 1/8 (from 400k FPS down to 50k FPS)…  what are possible reasons for that?  i can paste the test code, if necessary
17:26:38 <RaptorRarr> mm_freak: Have you looked at the Core generated for both?
17:26:58 <RaptorRarr> Daegalus: You need (Left x) and (Right x) as arguments rather than just x.
17:27:27 <Daegalus> Hmmm, ok, I think i tried that and i got some weird type errors, but let me try again
17:27:28 <mm_freak> RaptorRarr: core output is totally unintelligible to me
17:28:00 <mm_freak> wait, i'll paste the code
17:28:09 <mm_freak> perhaps it's something obvious
17:28:11 <RaptorRarr> I once found a lovely performance bug caused by the code generator by examining the Core.
17:28:37 <RaptorRarr> mm_freak: OK.
17:29:06 <hpaste> “Ertugrul Söylemez” pasted “Generalized automata” at http://hpaste.org/53134
17:29:25 <mm_freak> see the paste…  the code may be ugly, because it's just an experiment
17:29:48 <mm_freak> it runs without problems, but in line 52 i have the 'e' type variable
17:30:01 <RaptorRarr> Where's the specialize?
17:30:08 <mm_freak> when i replace it by (), the performance drops from 400k FPS to 50k FPS
17:30:16 <RaptorRarr> Oh.
17:30:36 <mm_freak> when i replace it by (a -> a), it stays at 400k FPS
17:30:42 <mm_freak> i'm really puzzled
17:30:57 <mm_freak> no value of that type is ever generated in the code
17:31:48 <RaptorRarr> What happens if you just remove that part of the type?
17:32:17 <mm_freak> then i have to specialize it in the Auto type…  it's used for Left values (which don't come up in the experiment)
17:32:27 <mm_freak> the idea is that e would generally be SomeException
17:32:42 <mm_freak> but when i specialize e to SomeException, the performance drops
17:32:48 <RaptorRarr> Ahh, OK.
17:33:04 <mm_freak> same happens, when i eliminate the type variable and just specialize it in the Auto type
17:33:10 <RaptorRarr> You write a SPECIALIZE comment?
17:33:26 <mm_freak> i started with SPECIALIZE, until i realized that it's not specific to it
17:33:43 <Saizan> mm_freak: do you get more memory use in the slow case?
17:33:47 <RaptorRarr> Or you use an instance where the object has a type with e filled in with SomeException?
17:34:32 <Daegalus> RaptorRarr: I get a new error about the type "Either [Char] a" not matching "[Char]" : http://hpaste.org/53132 the last annotation
17:35:37 <cgroza> Daegalus: which line?
17:36:01 <bgamari> Frequently i want to foldl over a list-like structure, building a list as I go
17:36:04 <mm_freak> Saizan: same memory behaviour on the surface (top)…  also -s reports the same total memory in use
17:36:06 <RaptorRarr> Daegalus: Left ("blah" ++ x) or whatever
17:36:18 <RaptorRarr> Daegalus: You want Left to cover the result of the concatenation.
17:36:24 <mm_freak> RaptorRarr: nothing specializes 'e' except the main loop
17:36:27 <bgamari> however the obvious way to do this results in a list in reversed relative to the order of the original list
17:36:28 <Daegalus> I thoguht I did that...
17:36:32 <Daegalus> OHHH i did it on the wrong line
17:36:33 <Daegalus> blah
17:36:36 <bgamari> How does one go about avoiding this?
17:36:43 <mm_freak> RaptorRarr: and it can specialize it to whatever it wants, since it's never using it
17:36:56 <mm_freak> the code is perfectly fine with a fully polymorphic 'e' everywhere
17:37:10 <bgamari> It's difficult since appending to a list is expensive
17:38:20 <RaptorRarr> mm_freak: I'm not sure. Maybe there's optimizations for Either with the usual error types or something.
17:38:28 <RaptorRarr> mm_freak: So, () would be unusual and not optimized.
17:38:35 <RaptorRarr> mm_freak: That's a total guess, though.
17:38:36 <BMeph> bgamari: Nay, appending oto a list is cheap! Especially if you don't prematurely evaluate... ;)
17:38:43 <ben> I'm going to conquer the world and throw everybody into a dungeon who writes "it is well known that" without further references in documentation or teaching materials
17:39:06 <RaptorRarr> ben: It is well known that ben will conquer the world and throw everybody into...oh crap.
17:39:28 <mm_freak> RaptorRarr: that would mean that there is no such optimization for Either SomeException, but there is one for Either (a -> b), which would certainly be very odd
17:39:42 <Saizan> bgamari: you could just reverse at the end
17:40:02 <bgamari> Saizan: Sure, but it just seems there must be a better way
17:40:05 <RaptorRarr> bgamari: Can you give an example fold?
17:40:22 <bgamari> sure, one moment
17:40:50 <mm_freak> i'm not sure, but perhaps it's indeed because of optimization…  like making the () arguments strict
17:41:00 <mm_freak> that would certainly influence the performance of my code
17:41:02 <BMeph> bgamari: Reverse at the end, use the String function transform pattern, or reverse the folds, it's all good. :)
17:41:21 <Saizan> bgamari: well, it depends on context, but you can use DList, or just functions ([a] -> [a])
17:41:49 <mm_freak> yes, without -O both variants have the same performance
17:42:11 <hpaste> “Ben Gamari” pasted “Foldl to build a list” at http://hpaste.org/53136
17:42:28 <mm_freak> can i use -O, but turn off strictness analysis?
17:42:37 <Saizan> bgamari: in which case snoc :: ([a] -> [a]) -> a -> [a] -> [a]; snoc f x = f . (x:)
17:42:49 <bgamari> RaptorRarr: there you are, I apologize for the code
17:42:57 <bgamari> this was the example I was working on
17:43:56 <bgamari> For that matter, if anyone sees a better way to do what I'm doing, feel free to suggest
17:45:07 <Daegalus> Sorry for bugging you guys with dumb stuff, but my professor has been horrible and im still getting lost in typing: http://hpaste.org/53132 last annotation. Not sure how to concat that.
17:46:17 <RaptorRarr> BRB
17:48:33 <Phyx-> Does anyone know of a faster and more stable way to determing the "root" module than top-sorting the dependency graph and looking at the root?
17:52:22 <hpaste> themirror pasted “expression parser” at http://hpaste.org/53138
17:55:09 <Phyx-> DanBurton: x is of the type Either String [String] and not [String]
17:55:15 <Phyx-> which is why you get the type error
17:55:18 <Phyx-> @src Either
17:55:18 <lambdabot> Source not found. My mind is going. I can feel it.
17:55:31 <Phyx-> @src Maybe
17:55:32 <lambdabot> data Maybe a = Nothing | Just a
17:55:42 <RaptorRarr> Sorry, was sitting in a place where the music kept cutting out.
17:55:45 <Phyx-> damn autocmplete
17:55:50 <Phyx-> Daegalus i mean
17:56:15 <Daegalus> Phyx-: for the last annotation?
17:56:28 <Phyx-> Daegalus: so you have to pattern match, you probably meant processMiddle (Right x) = ...
17:56:40 <Daegalus> last annoation Phyx-, already fixed that
17:56:46 <Phyx-> oh sorry
17:57:26 <Phyx-> the call to foldl is missing an argument
17:57:29 <Phyx-> :t foldl
17:57:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:57:41 <Phyx-> should have 3, you have it 2
17:58:07 <Daegalus> @hoogle foldl
17:58:07 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
17:58:07 <lambdabot> Data.ByteString foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
17:58:07 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
17:58:23 <Phyx-> @src concat
17:58:23 <lambdabot> concat = foldr (++) []
17:58:54 <RaptorRarr> @type foldl'
17:58:55 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:59:29 <Daegalus> Phyx-: concat did the trick, but alas, more type errors.
17:59:34 <Phyx-> Daegalus: in both cases you're missing the initial value for foldl
17:59:43 <Daegalus> got it
17:59:57 <jeremy_> hello friends
17:59:58 <Daegalus> i personally thinkg hte whole thing is a mess, im just too noob to make it any better
18:00:31 <Phyx-> @type foldl (:)
18:00:32 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
18:00:32 <lambdabot>       Expected type: a
18:00:32 <lambdabot>       Inferred type: [a]
18:00:51 <Guest94370> been a while since i used this type of chat... how might i change my nickname?
18:00:59 <Guest94370> --nick makemachine
18:01:02 <Guest94370> not like that
18:01:03 <Phyx-> thought that.. so why are you getting another error than an infinite type
18:01:08 <Saizan> Guest94370: /nick
18:01:12 <Phyx-> Guest94370: /nick
18:01:36 <Guest94370> thanks!
18:01:47 <makemachine> hola
18:01:49 <Daegalus> Phyx-: no clue, i changed it to "concat (filter ..." and it worked, but Im having a "Either String Bool" not matching "Bool" in the primary function
18:01:50 <sadger> @src map
18:01:50 <lambdabot> map _ []     = []
18:01:50 <lambdabot> map f (x:xs) = f x : map f xs
18:02:03 <makemachine> on the tryhaskell.org site
18:02:08 <makemachine> pretty nice
18:02:43 <Phyx-> Daegalus: in processMiddle?
18:02:52 <Daegalus> actually no, processLast
18:03:24 <Daegalus> im thinking that I am not using Right/Lefts properly in the CheckAddress function
18:03:40 <Phyx-> Daegalus: you're missing parenthesis
18:03:49 <Phyx-> Left ("..." ++ x)
18:04:00 <Phyx-> not Left "..." ++ x
18:04:01 <luite> @hoogle (a -> m b) -> a -> a -> m (b,b)
18:04:02 <lambdabot> No results found
18:04:23 <Daegalus> Phyx-: i think thats also een fixed, at least on my current copy. Here let me make a brand new paste
18:05:07 <makemachine> i am currently looking for a language to use for a live coding platform that will involve visualizations, sound processing and some networking capabilities, anyone have thoughts as to whether or not haskell would be a good choice?
18:05:14 <hpaste> Daegalus pasted “ChekAddress” at http://hpaste.org/53140
18:05:32 <Daegalus> Phyx-: ^^^ new past
18:06:22 <Phyx-> Daegalus: right, processLast and processMiddle return an Either String Bool
18:06:40 <Phyx-> you're using them as arguments to (&&) which expects Bool
18:07:19 <Daegalus> so do I wrap all the process commands in Rights ?
18:07:35 <Daegalus> but then i would lose all the lefts?
18:07:59 <Phyx-> no, you have to test the results of the calls by pattern matching
18:08:17 <Phyx-> if they're both a Right, then you use the bool argument
18:08:29 <Phyx-> if not, then do something else
18:08:58 <RaptorRarr> bgamari: My brain is too tired to handle that code :)
18:09:11 <Phyx-> case processLast (tail x) of
18:09:15 <Phyx->  Left y -> ...
18:09:35 <DanBurton> :t let bind2 f x y = x' <- f x; y' <- f y; return (x', y') in bind2
18:09:35 <Phyx-> Right y -> case processMiddle x of
18:09:35 <lambdabot> parse error on input `<-'
18:09:36 <Phyx-> ..
18:09:40 <Phyx-> you get the idea
18:09:44 <DanBurton> :t let bind2 f x y = do x' <- f x; y' <- f y; return (x', y') in bind2
18:09:45 <lambdabot> forall t (m :: * -> *) t1. (Monad m) => (t -> m t1) -> t -> t -> m (t1, t1)
18:09:59 <Daegalus> I hope i do, he spend maybe 5 mins on cases, and never really covered them.
18:10:07 <Daegalus> thx for hte help. Ill try to figure it out
18:10:20 <Phyx-> np, it's 3.30am, going to bed :)
18:10:31 <Daegalus> night
18:12:48 <Phyx-> Daegalus: this chapter might be useful to you http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.case
18:12:54 <Phyx-> gn
18:13:05 <Daegalus> Phyx-: awesome, thank you
18:20:20 <xrl> can someone help me with my attoparsec parser? I'm trying to do a condition take and one of the takes will become a word64. http://hpaste.org/53120
18:20:44 <Daegalus> > head ["test","test2","test3"]
18:20:45 <lambdabot>   "test"
18:23:04 <xrl> am I going to "lift" the value from the attoparsec monad in to the Binary.Get monad? is that the right way of saying it?
18:23:33 <Daegalus> > init ( tail ["test","test2","test3","test4"] )
18:23:34 <lambdabot>   ["test2","test3"]
18:23:43 <xrl> and I'm pretty sure that this is ok since Binary.Get and attoparsec are lazy
18:25:06 <RaptorRarr> xrl: I think lifting is taking a function and lifting it to work in a whatsit: like (a -> b) -> m a -> m b
18:25:39 <RaptorRarr> @type (liftM, liftA)
18:25:40 <lambdabot> forall a1 r (m :: * -> *) a b (f :: * -> *). (Monad m, Applicative f) => ((a1 -> r) -> m a1 -> m r, (a -> b) -> f a -> f b)
18:25:58 <xrl> RaptorRarr: oh... so how do I take the work from one monad, namely a bytestring output, and put it into another mechanism?
18:26:24 <RaptorRarr> xrl: I'm not sure what that would be called exactly. Rewrapping?
18:26:36 <xrl> I thought >>= was used for that... but does it have to be the same monad? or just something which implements the monad interface?
18:27:06 <coppro> :t (>>=)
18:27:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:27:18 <RaptorRarr> Yes, (>>=) applies an action within the same monad.
18:27:28 <xrl> does that mean they're the same monad? so what happens when it's across monads?
18:27:41 <xrl> or rather: what should I do when the data goes across monads?
18:27:42 <dgpratt> can someone explain what's going on here (or give me a reference)? http://stackoverflow.com/questions/7897559/test-if-haskell-variable-matches-user-defined-data-type-option/7897658#7897658
18:27:54 <themirror> can someone explain how chainl works? I've written a piece of code to parse expressions (http://hpaste.org/53138) for an assignment but it goes into an infinite loop. I'm not sure how to utilize chainl to fix that
18:27:57 <coppro> xrl: are you trying to embed one monad in another, or are you trying to get data out of one monad and into another?
18:28:08 <coppro> if the latter, you will need some sort of function which lets you get data out of a monad
18:28:09 <RaptorRarr> I'm not sure what you mean. Like you get the value from type m a to type a, and then you put it to type m' a?
18:28:42 <xrl> coppro: could I embed the Binary.Get monad inside of attoparsec? I just want to take a known-length bytestrings and turn it in to a word64
18:29:04 * hackagebot data-util 0.1 - utilities for handle data  http://hackage.haskell.org/package/data-util-0.1 (KatsutoshiItoh)
18:29:06 <xrl> here's the code I'm trying to get working: http://hpaste.org/53120
18:29:14 <xrl> namely: get_flen
18:29:46 <xrl> either I want a Small Word8 or I wanted a Jumbo Word64. If it's a word64 it'll be from a (attoparsec.take 8)
18:30:48 <Daegalus> Hmmm, anyone know why I am getting this error? I am so failing at Eithers : http://hpaste.org/53142
18:31:36 <RaptorRarr> Daegalus: Wrap it in Right or something.
18:31:46 <coppro> xrl: take a look at http://en.wikibooks.org/wiki/Haskell/Monad_transformers perhaps?
18:32:05 <RaptorRarr> Daegalus: That'll take it from [String] to Either e [String]
18:32:30 <coppro> Daegalus: or better yet, use >>=
18:32:33 <Daegalus> RaptorRarr: nope, it didn't, gave me the same error.
18:32:41 <Daegalus> >>= ?
18:33:00 <coppro> Daegalus: on lines 12, 14, and 16, you are providing a value of type String; that's not what your declared type is
18:33:26 <coppro> oh, line 17 as well
18:33:34 <coppro> Daegalus: however, look up the semantics of >>= in the Either monad
18:33:37 <coppro> they are exactly what you want
18:34:22 <jwpowell> can anyone help with what's probably a simple xmonad problem?
18:34:44 <jwpowell> i can't seem to open even a single terminal
18:34:59 <jwpowell> i've made the standard switch to the super key from the mod key
18:35:21 <jwpowell> but nothing seems to work
18:35:38 <Daegalus> coppro: ummm, where can i look up more on >>= ? googling it doesnt work.
18:36:06 <coppro> http://hackage.haskell.org/packages/archive/category-extras/0.44.4/doc/html/src/Control-Monad-Either.html
18:38:17 <Daegalus> coppro: so in my case I can do processFirst (head x) >>= processMiddle (init (tail x)) >>= processLast (last x) ?
18:38:35 <coppro> Daegalus: something like that, yes
18:38:53 <coppro> you can also use do notation
18:39:40 <Daegalus> coppro: ok i switched to that syntax, all is good, BUT i get the exact same error about "init (tail x)"
18:40:07 <coppro> Daegalus: can you pastebin again?
18:41:18 <hpaste> mizu_no_oto pasted “Enumerator” at http://hpaste.org/53145
18:41:20 <Daegalus> coppro: http://hpaste.org/53144 , what is funny is when all this stops erroring, it wont even work properly
18:41:37 <napping> does anyone have gloss working in ghci? Under Ubuntu 11.10?
18:42:20 <coppro> Daegalus: processLast (head x) is of type Either String Bool, not of type a -> m b (with a = Bool in this case)
18:42:26 <mizu_no_oto> I'm trying to get a simple example working for Enumerators, and I'm having trouble.  Code is at http://hpaste.org/53145
18:42:40 <coppro> (and probably m = Either String and b = Bool as well)
18:42:51 <slack1256> napping: how did you install it? from some repo in ubuntu o directly from cabal?
18:43:30 <napping> darcs gloss-head, built with cabal
18:43:32 <Daegalus> coppro: then why arent the other 2 erroring. processFirst and processLast are pretty much the same.
18:44:00 <coppro> processFirst is fine since you aren't applying >>= to it
18:44:17 <mizu_no_oto> Essentially, how do you compose an IO action into the Iteratee?  I'd like to be able to do something like f (E.Chunks xs) = mapM_ printData xs >> (E.Iteratee $ E.Continue f) but the types don't match.  How should I be doing that?
18:44:19 <coppro> (as the second argument)
18:44:26 <coppro> :t (>>=)
18:44:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:44:29 <coppro> ^
18:44:43 <Daegalus> ok, then what about processLast not erroring?
18:44:43 <slack1256> napping: use a official release (not some get from cabal) because it can be using newer versions of your libraries
18:45:07 <coppro> Daegalus: probably it quits after the first deduction failure
18:45:36 <Daegalus> coppro: processLast comes before processMiddle
18:45:44 <Daegalus> processFirst (head x) >>= processLast (last x) >>= processMiddle (init (tail x))
18:45:53 <coppro> Daegalus: same reason then
18:46:01 <napping> slack1256: only head has GLFW, it doesn't seem GLUT can work interactively at all
18:46:03 <coppro> Daegalus: try (>>) also
18:46:12 <coppro> that might be more what you want here
18:46:15 <coppro> I haven't been paying enough attention
18:46:52 <Daegalus> coppro: same error. And I am not sure what I want, the assignement feels rushed on us. He hasn't covered half of this stuff properly or at all.
18:47:35 <coppro> Daegalus: then bother to understand it and further your education
18:47:43 <coppro> and don't go blindly subbing in code that I say
18:49:45 <Daegalus> Well I do look it up, and I try to understand it, this is my first functional programming, and the typing is really messing me up atm. and personally I dont get why a type of "[[Char]]" doesnt satisfy "Either String [Stirng]"
18:50:25 <dmwit> Daegalus: ...because a list is not an Either?
18:50:27 <mauke> what do you mean by "satisfy"?
18:50:32 <slack1256> napping: mmm so tell me, what kind error do you get? unefined behavior, not succesful compilation?
18:50:33 <mauke> they're both types, and they're different
18:50:44 <Cale> Daegalus: Either is a datatype, it has a different structure from a list
18:50:55 <mizu_no_oto> [[a]] means a list of lists - something like [[1,2,3,4],[1,2,3,4,5]]
18:50:57 <mauke> this isn't about functional programming
18:51:24 <Daegalus> i think the fact that it says Either.  I keep thinking that its Either the first argument or the second argument
18:51:29 <napping> slack1256: a message No GLXFBConfigs returned when calling Prelude - other GL stuff works fine, including compile Gloss
18:51:31 <Daegalus> mizu_no_oto: i know what that means.
18:51:33 <Cale> However, if x :: [[Char]], then Right x :: Either String [String]
18:51:36 <mauke> Daegalus: no, it's just a name
18:52:33 <Cale> More generally, if x :: a and y :: b, then Left x and Right y have type Either a b
18:53:18 <dmwit> It *is* either the first argument or the second argument -- but it's *also* a tag telling which one of the two it is.
18:53:34 <dmwit> ?src Either
18:53:34 <lambdabot> Source not found. Maybe you made a typo?
18:53:41 <slack1256> napping: FB could be for framebuffer?
18:53:43 <dmwit> data Either a b = Left a | Right b
18:53:48 <mizu_no_oto> You have Either [Char] [[Char]]
18:54:12 <vharishankar> Hello all.
18:54:16 <mizu_no_oto> You need to pattern match on the Right constructor to have something of type [[Char]]
18:54:21 <dmwit> Hello, vharishankar.
18:54:54 <napping> slack1256: I'm asking if it works for others, I'm fine for now trying to debug my own copy
18:55:01 <Cale> Without those tags, you couldn't decide which of the two types any given piece of data was, and would be resigned to only apply functions polymorphic enough to both types. It would also make type inference much more difficult and type checking more expensive.
18:55:06 <vharishankar> I am hoping to learn a lot about haskell and functional programming.
18:55:29 <mizu_no_oto> How much do you know now?
18:55:55 <Cale> vharishankar: Welcome! Feel free to ask any questions you might have :)
18:56:06 <Daegalus> Ok, i think it kinda makes sense now. Then from that understanding, I whoudl wrap (init (tail x)) in a Right so it becomes Either String [String], so processMiddle (Right (init (tail x))
18:56:10 <vharishankar> let fizzbuzz x = if x `mod` 15 == 0 then "fizzbuzz" else if x `mod` 5 == 0 then "buzz" else if x `mod` 3 == 0 then "fizz" else show x
18:56:18 <vharishankar> Is there any easier way to write this?
18:56:48 <slack1256> vharishankar: guards?
18:56:57 <dmwit> I think we have a wiki page collecting dozens of solutions to this problem.
18:57:17 <dmwit> http://www.haskell.org/haskellwiki/Fizzbuzz
18:57:29 <dmwit> I thought there were dozens of solutions, but maybe I'm just remembering IRC chat.
18:57:32 <dmwit> =P
18:57:36 <vharishankar> OK thanks.
18:58:00 <vharishankar> I am just beginning to understand what it's all about though...
18:58:12 <mizu_no_oto> check out http://learnyouahaskell.com/chapters
18:58:24 <mizu_no_oto> It's a good introduction
18:58:52 <Daegalus> Ok, now I am getting an error Ive never seen before "Instant of Monad (Either String) requird for Definition of checkAddress"
18:59:07 <dmwit> Daegalus: Perhaps you'd like to import Control.Monad.Error
18:59:21 <vharishankar> Yes, went through a bit of that tutorial
18:59:25 <coppro> dmwit: what?
18:59:36 <jeff2> I'm using Data.Traversable.find on a Data.Tree, but it only returns the rootLabel of the node found. How can I get the whole subtree?
19:00:00 <coppro> dmwit: Monad (Either e) should be in Prelude
19:00:06 <Daegalus> dmwit: Haskell 98 does not support dependent parameters
19:00:17 <coppro> Daegalus: can you please hpaste again?
19:00:32 <Cale> > let fizzbuzz x = fromJust $ (guard (x `mod` 3 == 0) >> return "fizz") `mappend` (guard (x `mod` 5 == 0) >> return "buzz") `mplus` return (show x) in map fizzbuzz [1..20]
19:00:33 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
19:00:33 <vharishankar> Is it better to use ghci environment or the compiler for learning?
19:01:04 <slack1256> jeff: i guess you should check for the Data.Tree functions. because returning a subtree isn't part of what Data.Traversable should do
19:01:08 <Cale> ^^ a monadic monoidal solution ;)
19:01:12 <kmc> vharishankar, best to write out functions etc. in a file, and load it in ghci and try them out
19:01:18 <hpaste> Daegalus pasted “Check 2345” at http://hpaste.org/53146
19:01:22 <vharishankar> kmc, thanks
19:01:28 <vharishankar> @kmc thanks.
19:01:28 <lambdabot> Maybe you meant: ghc rc src
19:01:36 <kmc> you can also compile that file before you load it in ghci, which will make stuff go faster
19:01:39 <Daegalus> coppro: hpaste above
19:01:42 <kmc> but it's often not worth the effort
19:02:26 <vharishankar> Thank you. I am getting stuck on higher order functions and types. But I am more confident now.
19:03:14 <Cale> oh, could also do this:
19:03:27 <mizu_no_oto> What sorts of things do you not understand with higher order functions?
19:03:33 <coppro> Daegalus: I get a type error on >>= from that hpaste
19:03:37 <Cale> > let fizzbuzz x = fromMaybe (show x) (guard (x `mod` 3 == 0) >> return "fizz") `mappend` (guard (x `mod` 5 == 0) >> return "buzz") in map fizzbuzz [1..20]
19:03:38 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
19:03:38 <lambdabot>         against inferred type...
19:03:41 <Cale> errr
19:03:59 <vharishankar> Jmizu no oto: ust the concept of functions returning functions. I am sure I will get there in the end.
19:04:12 <Daegalus> coppro: well I am using WinHugs because the professor grades using Hugs instead of GHC and thats teh error its spewing
19:04:43 <coppro> Daegalus: from exactly the hpaste? What changed from your previous error?
19:04:43 <Cale> oh, parens got messed up
19:04:44 <jeff2> slack1256: are all of the functions I should look at documented at http://www.haskell.org/ghc/docs/6.6/html/libraries/base/Data-Tree.html?
19:04:59 <Cale> > let fizzbuzz x = fromMaybe (show x) $ (guard (x `mod` 3 == 0) >> return "fizz") `mappend` (guard (x `mod` 5 == 0) >> return "buzz") in map fizzbuzz [1..20]
19:05:00 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
19:05:12 <Cale> > let fizzbuzz x = fromMaybe (show x) $ (guard (x `mod` 3 == 0) >> return "fizz") `mappend` (guard (x `mod` 5 == 0) >> return "buzz") in map fizzbuzz [10..30]
19:05:13 <lambdabot>   ["buzz","11","fizz","13","14","fizzbuzz","16","17","fizz","19","buzz","fizz...
19:05:42 <Daegalus> coppro: what changes was i wrapped the (init (tail x)) of processMiddle with a Right so processMiddle (init (tail x)) became processMiddle (Right (init (tail x)))
19:06:06 <coppro> Daegalus: ... no
19:06:11 <Cale> with a little Applicative stuff, we could clean it up even more
19:06:13 <vharishankar> Cale: thank you for the code. How is the if then else different from guards?
19:06:34 <coppro> Daegalus: look carefully at the type signatures of (>>=), (>>), and processMiddle (init (tail x))
19:06:45 <Cale> vharishankar: Only syntactically. Guards are a little nicer in that you can stack them without having to nest things.
19:06:54 <Daegalus> :t (>>=)
19:06:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:07:02 <Daegalus> :t (>>)
19:07:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:07:14 <vharishankar> Cale: Oh, ok. That makes sense
19:07:37 <Cale> > let fizzbuzz x = fromMaybe (show x) $ ("fizz" <$ guard (x `mod` 3 == 0)) `mappend` ("buzz" <$ guard (x `mod` 5 == 0)) in map fizzbuzz [10..30]
19:07:37 <lambdabot>   ["buzz","11","fizz","13","14","fizzbuzz","16","17","fizz","19","buzz","fizz...
19:07:56 <Cale> oh, if you're talking about my use of the *function* guard, that's fairly different
19:07:57 <coppro> @hoogle guard
19:07:58 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
19:07:58 <lambdabot> Language.Haskell.TH data Guard
19:07:58 <lambdabot> Language.Haskell.TH.Syntax data Guard
19:08:22 <Cale> guard is a function which is really polymorphic, but specialised to the Maybe type that I'm using it on
19:08:27 <vharishankar> Cale: I've not yet got to Maybe. Maybe (no pun intended) next time I will be ready for it.
19:08:30 <Cale> okay
19:08:54 <Cale> Well, guard False = Nothing, and guard True = Just ()
19:09:24 <Cale> and  Nothing >> x = Nothing, while  Just _ >> x = x
19:09:57 <Cale> So guard p >> Just x  will be Just x when p is True, and Nothing otherwise
19:10:11 <Cale> Same goes for x <$ guard p
19:10:29 <coppro> Daegalus: Feel free to talk about train of thought or something; I'm just not going to tell you the answer because a) that would be cheating and b) then you wouldn't learn what you're doing properly
19:10:31 <Cale> (which is equivalent, using a nice operator from Control.Applicative)
19:10:39 <vharishankar> Cale: thanks a lot. I am off to learn more about guards from the learnyouahaskell tutorial.
19:10:51 <Cale> vharishankar: There's also a syntactic thing that we call guards
19:11:00 <Cale> which is only vaguely related
19:11:04 <vharishankar> Cale: ok
19:11:18 <Cale> f x | condition1 = result1
19:11:23 <Cale>     | condition2 = result2
19:11:27 <Cale>     | condition3 = result3
19:11:29 <Cale> etc.
19:11:37 <Daegalus> well I changed the 2nd >> to a >>= to see the difference more pronouned, and got Either String Bool doesnt match a -> b c, which make sense, but when I get rid of the Right, it goes back to saying [[Char]] doesnt match Either String [String] so I have yet to really figure out what it wants.
19:11:40 <vharishankar> Yes, that was what I understood
19:11:45 <ski> @src take
19:11:45 <lambdabot> take n _      | n <= 0 =  []
19:11:45 <lambdabot> take _ []              =  []
19:11:45 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
19:11:59 <Daegalus> coppro: yes I undesrtand, and i dont expect the answer, Im just having a hard time understanding what is actually happening
19:12:18 <coppro> just try it with two process functions first
19:12:19 <Cale> vharishankar: Anyhow, the really clever bit of my thing is in the `mappend`
19:12:36 <coppro> Daegalus: have you used (>>=) and (>>) (or the equivalent do-notation) at all?
19:13:12 <Cale> vharishankar: mappend is a generic sort of appending or concatenation defined on lots of different types (the instances of a class called Monoid)
19:13:14 <vharishankar> Cale: I get not in scope: mappend
19:13:20 <Cale> import Data.Monoid
19:13:34 <Daegalus> coppro: not really, and his examples he uses pre-loaded functions he wrote that he doesnt show us, so he is doing a bunch of work without showing us what is happening. We covered a bit of Either/Left/Right but not much else. Maybe Just also.
19:13:47 <Cale> also you'll want Data.Maybe and Control.Applicative for the later ones
19:13:48 <vharishankar> Cale: thanks.
19:13:53 <coppro> Daegalus: Maybe and Either are both instances of the typeclass Monad
19:13:53 <ski> Daegalus : it doesn't make sense (except to fix type mistakes) to change `.. >> ..' into `.. >>= ..', without also modifying the right `..' accordingly (e.g. by adding `\_ -> ' in front of it)
19:14:14 <coppro> Daegalus: (>>) and (>>=) are functions defined on Monad; I linked you to the definition for Either e
19:14:16 <Cale> vharishankar: On lists (and strings), mappend is just concatenation
19:14:27 <Cale> > "fizz" `mappend` "buzz"
19:14:27 <lambdabot>   "fizzbuzz"
19:14:28 <coppro> (well, strictly speaking, Either is not; Either e is for any type e)
19:14:36 <Cale> > mappend "fizz" "buzz"
19:14:37 <lambdabot>   "fizzbuzz"
19:15:04 <vharishankar> Cale: how do you get the result to show on this chat?
19:15:16 <Cale> By prepending "> " (note the space)
19:15:22 <vharishankar> let me try
19:15:55 <vharishankar> > f x = x^2 + 2*x + 3
19:15:56 <lambdabot>   <no location info>: parse error on input `='
19:16:06 <Cale> ah, it wants expressions rather than declarations
19:16:07 <RaptorRarr> > let f x = x^2 + 2*x + 3 in map f [1..10]
19:16:08 <lambdabot>   [6,11,18,27,38,51,66,83,102,123]
19:16:15 <vharishankar> > let f x = x^2 + 2*x + 3
19:16:16 <lambdabot>   not an expression: `let f x = x^2 + 2*x + 3'
19:16:38 <Cale> You can use @let to define things for a while (until someone does @undefine which clears everything)
19:16:51 <vharishankar> Cale: thanks.
19:16:52 <Cale> but f is taken by all the things which are imported ;)
19:17:18 <Cale> (the bot's evaluator imports a lot of stuff)
19:17:33 <vharishankar> OK
19:17:44 <Cale> You can also just use let/in like RaptorRarr showed
19:18:09 <Cale> Which is usually convenient enough as long as the lines don't get too long :)
19:18:21 <vharishankar> > let myfunc x = x * 2 in map [1..10]
19:18:25 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
19:18:35 <vharishankar> > let myfunc x = x * 2 in map  myfunc [1..10]
19:18:36 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
19:18:47 <Cale> So anyway, if t is any type where mempty and mappend are defined (that is, any type which is an instance of Monoid)
19:19:16 <Cale> then Maybe t is also an instance of Monoid, with mempty = Nothing, and mappend defined like:
19:19:21 <Cale> mappend Nothing x = x
19:19:27 <Cale> mappend x Nothing = x
19:19:39 <Cale> mappend (Just x) (Just y) = Just (mappend x y)
19:19:57 <Cale> and so we get:
19:20:12 <Cale> > mappend (Just "fizz") Nothing
19:20:13 <lambdabot>   Just "fizz"
19:20:19 <Daegalus> coppro: ya, i just sat here thinking this over, and A) I Have no clue what a monad really is, B) He never covered >> or >>= and looking at that Monad typing just further solidified that i am lost on what is going on with my code atm. Maybe I am too used to Imperitive programming but all this typing si confusing the hell out of me.
19:20:22 <Cale> > mappend Nothing (Just "buzz")
19:20:23 <lambdabot>   Just "buzz"
19:20:35 <Cale> > mappend (Just "fizz") (Just "buzz")
19:20:35 <lambdabot>   Just "fizzbuzz"
19:20:44 <Cale> > mappend Nothing Nothing
19:20:48 <lambdabot>   Nothing
19:20:49 <coppro> Daegalus: haha
19:20:59 <coppro> Daegalus: let's start with (>>), since it's easier
19:21:00 <vharishankar> Cale: quite confusing for me. lol sorry
19:21:24 <Cale> vharishankar: that's okay, it's a solution which is maybe a bit too clever for its own good anyway :)
19:21:25 <coppro> Daegalus: You don't need to understand monads entirely, as long as you understand them as the apply here
19:21:29 <coppro> :t (>>)
19:21:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:21:46 <vharishankar> Let me try and work my way through the learn you haskell tutorial
19:21:55 <Cale> vharishankar: yeah, that's a good plan
19:22:04 <coppro> So when we instantiate this for Either String, we get (Either String a -> Either String b -> Either String b)
19:22:27 <coppro> Daegalus: One thing about Haskell is that you can often (though not always) determine a lot about a function from its type
19:22:31 <vharishankar> Not yet got to monad. but hopefully I will in a few days
19:22:50 <coppro> There aren't that many ways to get b from a and b without something (a -> b), are there?
19:22:55 <vharishankar> > print "bye"
19:22:56 <lambdabot>   <IO ()>
19:23:03 <vharishankar> hmm...
19:23:11 <Daegalus> coppro: nope
19:24:00 <coppro> now look at (>>=)
19:24:09 <coppro> :t (>>=)
19:24:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:24:27 <coppro> In Either String, this is Either String a -> (a -> Either String b) -> Either String b
19:24:41 <coppro> you understand the signature, right?
19:24:50 <Daegalus> Umm, I think so yes.
19:24:52 <vharishankar> Hey, thanks so much for the help so far. I will visit here often to find out more...
19:25:10 <vharishankar> Bye for now.
19:25:26 <coppro> Daegalus: How do you think it might go about constructing its value if it is given Left "foo"?
19:26:55 <Daegalus> Either String a -> a sooo, Left "foo" -> " foo" ?
19:27:18 <coppro> Daegalus: err, sorry, slightly bad question
19:27:32 <coppro> Daegalus: suppose I have a function f :: (a -> Either String b)
19:27:42 <Cale> > let fizz = cycle [Nothing, Nothing, Just "fizz"]; buzz = cycle [Nothing, Nothing, Nothing, Nothing, Just "buzz"] in [x | Just x <- zipWith mplus (zipWith mappend fizz buzz) (map (Just . show) [1..])]
19:27:44 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
19:27:44 <coppro> now think of what Left "foo" >>= f would be
19:27:56 <coppro> remember, it's of type Either String b
19:28:05 <Cale> ^^ there's a solution which doesn't explicitly do division ;)
19:29:12 <Cale> > let fizz = cycle [Nothing, Nothing, Just "fizz"]; buzz = cycle [Nothing, Nothing, Nothing, Nothing, Just "buzz"] in zipWith mappend fizz buzz
19:29:13 <lambdabot>   [Nothing,Nothing,Just "fizz",Nothing,Just "buzz",Just "fizz",Nothing,Nothin...
19:29:22 <RaptorRarr> @type cycle
19:29:22 <lambdabot> forall a. [a] -> [a]
19:29:27 <Cale> > cycle [1,2,3]
19:29:28 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
19:29:33 <coppro> Daegalus: thing about the ways that you could get either String or b from f and Left "foo"
19:29:35 <Daegalus> Left "foo" -> ("foo" -> Either String f)
19:29:47 <coppro> Daegalus: wha?
19:30:00 <coppro> I don't think you want arrows there
19:30:05 <coppro> those are reserved for type signatures
19:30:32 <Cale> (and lambda and case)
19:30:35 <Daegalus> oh i didnt see you f::(a-> Either String B)
19:30:38 <coppro> ah ok
19:31:39 <Daegalus> Left "foo" -> ("foo" -> either Stirng B) sec, i know thats wrong just thinking
19:31:45 <coppro> ok
19:31:53 <coppro> tip: "foo" is not an a here
19:31:56 <coppro> it's a String
19:32:05 <jeff2> is there a better way to search a Data.Tree? I wrote this function: http://pastebin.com/D5rCQPj3
19:32:07 <mauke> The paste D5rCQPj3 has been copied to http://hpaste.org/53147
19:32:08 <Daegalus> ohhh
19:32:28 <Daegalus> Left "foo" f -> ( a -> Either Stirng B) ?
19:32:38 <coppro> a is just a type variable, it might be Integer or Bool or Maybe (a -> b -> Either (a -> b) Bool)
19:32:53 <coppro> (tip: never write anything with that last type)
19:33:06 <RaptorRarr> > let f x False False = show x; f _ x y = if x then "fizz" else "" ++ if y then "buzz" else "" in zipWith3 f [1..] (cycle [False, False, True]) (cycle [False, False, False, False, True])
19:33:08 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
19:33:12 <coppro> Daegalus: err... not really
19:33:25 <coppro> Daegalus: want to move to PM>
19:33:26 <coppro> ?
19:33:30 <Daegalus> coppro: sure
19:33:31 <RaptorRarr> Not quite.
19:34:09 <RaptorRarr> > let f x False False = show x; f _ x y = (if x then "fizz" else "") ++ (if y then "buzz" else "") in zipWith3 f [1..] (cycle [False, False, True]) (cycle [False, False, False, False, True])
19:34:10 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
19:34:17 <RaptorRarr> Quite.
19:35:15 <RaptorRarr> Or: > let f x False False = Nothing; f _ x y = Just $ if x then "fizz" else "" ++ if y then "buzz" else "" in take 30 $ zipWith3 f [1..] (cycle [False, False, True]) (cycle [False, False, False, False, True])
19:35:35 <RaptorRarr> Take that list and just replace Nothings with numbers.
19:36:21 <ski> jeff2 : .. bah, disconnected
19:37:50 <RaptorRarr> > zipWith (\n fb -> fromMaybe (show n) fb) [1..] . cycle $ [Nothing,Nothing,Just "fizz",Nothing,Just "buzz",Just "fizz",Nothing,Nothing,Just "fizz",Just "buzz",Nothing,Just "fizz",Nothing,Nothing,Just "fizzbuzz"]
19:37:52 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
19:40:52 <makemachine> ping
19:42:29 <ski> hello, makemachine
19:42:35 <makemachine> hola
19:43:06 * RaptorRarr turns off all noise sources and dives deeper to avoid detection.
19:43:32 <makemachine> * currently @ step16
19:43:57 <RaptorRarr> What's step16?
19:45:36 <makemachine> i am on the tryhaskell website
19:45:42 <RaptorRarr> Oh.
19:46:03 <makemachine> currently looking for a language that might work well in a live coding environment
19:46:14 <byorgey> makemachine: nice. any questions so far?
19:46:22 <makemachine> have spent the day playing with clojure and haskell
19:46:40 <makemachine> so far the syntax is nice
19:46:48 <byorgey> makemachine: haskell definitely works well.  Do you know Alex McLean?
19:47:20 <byorgey> http://yaxu.org/
19:48:03 <makemachine> i don't believe so
19:48:55 <byorgey> makemachine: he has several libraries for doing livecoding (primarily for sound, I think) in Haskell
19:48:56 <makemachine> has he done something similar?
19:49:06 <byorgey> pretty cool stuff.
19:49:27 <makemachine> oh excellent, yes... I'm hoping to create a little toolkit for doing sound and data visualizations
19:49:30 <makemachine> on the fly
19:49:45 <byorgey> Haskell is great for making embedded domain specific languages.
19:50:22 <byorgey> So you make a little embedded language -- really just a Haskell library -- that lets you express stuff in whatever domain you are working with
19:50:22 <RaptorTryingHask> I've made it to step 16!
19:50:26 <byorgey> then you livecode using that embedded language, but of course you have the entire power of Haskell at your disposal too
19:50:32 <makemachine> quite fun right!
19:50:36 <byorgey> indeed =)
19:50:47 <makemachine> sounds very neat
19:51:05 <makemachine> any links on how one might go about creating an embedded language?
19:51:12 <RaptorTryingHask> Yes :)
19:51:24 <makemachine> Is this similar to how Lua can be embedded in C++?
19:52:00 <byorgey> makemachine: uh, I don't think so, although I'm not familiar with that
19:52:21 <RaptorTryingHask> This game is too easy. I just click the bottom line of source code and hit enter.
19:52:30 <RaptorTryingHask> Oh, wait. Exercise time.
19:52:55 <makemachine> well, i feel like i am on the right track
19:53:01 <byorgey> makemachine: nothing special really, you just create some data types to represent your domain and various functions for working with them
19:53:04 <makemachine> anyone know where haskell originated?
19:53:40 <RaptorTryingHask> Bah, step 22 doesn't take head . snd $ (10, "abc")
19:53:52 <RaptorTryingHask> Oh, pattern matching.
19:54:25 <byorgey> makemachine: yes, it was designed by committee in the late 1980s =)
19:54:31 <makemachine> i read somewhere that the effort to formalize functional programming happened at a meeting in portland oregon
19:54:48 <makemachine> in the late 80s
19:55:02 <napping> http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm
19:55:25 <DanBurton> @where historyofhaskell
19:55:25 <lambdabot> I know nothing about historyofhaskell.
19:55:32 <byorgey> makemachine: yes, that's right.  specifically lazy functional programming.
19:55:41 <DanBurton> @where+ historyofhaskell http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm
19:55:41 <lambdabot> I will never forget.
19:55:51 <napping> consolidate, rather than formalize
19:55:58 <makemachine> it is always nice to hear about something so profound originating from your home town :)
19:56:01 <byorgey> makemachine: in the early-mid 80s people designed a lot of them, and a bunch of researchers got together and decided to create the One True Lazy Functional Language so they could all work on it together
19:56:04 <napping> everybody had a little lazy language, and they wanted one to work on together
19:56:08 <ski> @quote what.actually
19:56:09 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
19:56:09 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
19:56:09 <lambdabot> problems and as a reward the Tangled Gnomes gave them the Se
19:56:11 <byorgey> makemachine: the initial meeting was in Portland.
19:56:12 <ski> ecret of Haskell
19:56:37 <makemachine> thanks for the link, watching now
19:56:38 <DanBurton> @quote secret.of.haskell
19:56:38 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell [snip] In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their problems and as a reward
19:56:38 <lambdabot> the Tangled Gnomes gave them the Secret of Haskell
19:56:48 <ski> ah
19:57:00 <makemachine> well, that explains it
19:57:24 * ski probably made lambdabot remember that, and then forgot about it
19:57:50 <RaptorRarr> What is tangling?
19:58:19 * DanBurton is clueless
19:58:24 <DanBurton> @google wadler tangling
19:58:25 <lambdabot> http://contemplatecode.blogspot.com/2011/10/haskell-weekly-news-issue-202.html
19:58:25 <lambdabot> Title: Contemplating code: Haskell Weekly News: Issue 202
19:58:32 <DanBurton> -_-
19:58:40 <DanBurton> is that honestly the first hit?
19:59:05 <RaptorRarr> It's the second when I search directly.
19:59:39 <DanBurton> I wonder what customizations google has tailored for lambdabot's search results.
20:00:10 <RaptorRarr> Ahh, so something with literate programming.
20:00:52 * ski smiles at the "Cale: Computing lengths is admitting defeat" one
20:01:53 <RaptorRarr> http://www.haskell.org/wikiupload/4/4a/Hwn-cover.png
20:02:05 <DanBurton> odd that the HWN didn't bother to retrieve the full syntaxfree quote, they left the [snip] in there
20:02:09 <RaptorRarr> "Typechecker saves 100s of lives"!!
20:03:09 <makemachine> Java is to Clojure as __________ is to Haskell ?
20:03:32 <DanBurton> Miranda?
20:03:34 <shachaf> Java is to Clojure as Java is to Haskell. I.e., different.
20:03:35 <Cale> C++?
20:03:55 <Cale> Depends on what analogy you want to make
20:03:56 <DanBurton> The problem with Clojure is it is clearly heavily influenced by Lisp/Scheme
20:04:04 <DanBurton> so comparing it to Java makes it complicated
20:04:13 <Cale> Comparing Clojure and Haskell is also hard
20:04:18 <kmc> makemachine, nothing
20:04:31 <shachaf> These analogies are silly.
20:04:36 <DanBurton> comparing Haskell and anything is hard, unless it's Clean, Disciple, or Miranda
20:04:39 <Cale> They're both functional languages... they both have lots of concurrency stuff...
20:04:43 <kmc> if what you're getting at is "new fancy FP language built on older, boring VM"
20:04:47 <Cale> similarities beyond that are few :)
20:04:55 <kmc> Haskell is not usually run on top of any standard VM
20:04:55 <makemachine> Ok... sorry let me rephrase
20:05:09 <RaptorRarr> Analogy puzzles are to intelligence as __________ is to elephants
20:05:13 <ski> Java is to Clojure as (Java/Clojure)*Haskell is to Haskell
20:05:15 <kmc> it's usually compiled to native machine code, or sometimes interpreted by custom interpreters
20:05:16 <makemachine> The JVM is for Clojure as ________ is for Haskell
20:05:20 <kmc> makemachine, nothing
20:05:29 <shachaf> makemachine is obviously asking what spot in the periodic table of programming languages Haskell occupies.
20:05:30 <kmc> GHC compiles Haskell to native machine code
20:05:31 <Cale> @remember RaptorRarr Analogy puzzles are to intelligence as __________ is to elephants
20:05:32 <lambdabot> It is forever etched in my memory.
20:05:33 <DanBurton> the GHC runtime?
20:05:38 <kmc> yes, languages other than C can be compiled to native machine code!
20:05:45 <makemachine> Ah ok
20:05:51 <kmc> you could go through a whole CS program and nobody would tell you about this fact
20:05:57 <makemachine> So, Haskell is compiled to machine code
20:05:58 <Cale> makemachine: GHC produces native code
20:06:02 <Cale> yeah
20:06:06 <DanBurton> kmc: C++ too!!!!
20:06:06 <makemachine> Excellent
20:06:09 <kmc> makemachine, Haskell is a standard language; it does not mandate a particular implementation
20:06:15 <Cale> but it can also produce bytecode and interpret that
20:06:20 <kmc> but GHC, the implementation ~everyone uses, compiles to native machine code (directly or via LLVM)
20:06:23 <Cale> (which is what ghci does by default)
20:06:39 <kmc> there have been GHC-on-JVM and GHC-on-.NET projects; none is totally working or actively maintained
20:06:46 <kmc> there's also a GHC-to-Javascript project, which is active (?)
20:06:51 <Cale> Yeah, there are also other interpreters and stuff :)
20:06:59 <DanBurton> @google ghc javascript
20:07:01 <lambdabot> https://github.com/sviperll/ghcjs
20:07:21 <Cale> also yhc had a working javascript backend at one point, iirc.
20:07:26 <ski> shachaf : <http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.jpg> ?
20:07:36 <kmc> i thought uhc had one too
20:08:10 <DanBurton> I'm waiting for the day when ghci is compiled to client-side javascript
20:08:46 <DanBurton> tryhaskell is nice, but it would be nicer to interpret the code on your own machine
20:08:52 <Cale> It bothers me that diagram has nothing in between "data structures only" and "Turing equivalent"
20:09:45 <Cale> Makes it seem like there are no classes of computation in between the two :)
20:09:53 <DanBurton> Descriptive declarative programming: XML. Ew. Thank goodness XML is not turing complete.
20:10:50 <Cale> also +closure is an awkward (if brief) way to talk about a language feature
20:11:05 <DanBurton> And "stateful functional programming: Java?" erm..
20:11:42 <Cale> (I really hate it when people talk about "closures" as a language feature)
20:12:13 <DanBurton> Cale: what about that bothers you?
20:12:18 <Cale> Closures are an implementation mechanism for a bunch of related language features
20:12:25 <kmc> XML is not turing complete in the same way s-expressions aren't
20:12:36 <kmc> people can (and do) build turing-complete languages whose syntax is s-expressions, or XML
20:12:43 <Cale> It's kinda like saying that C++ has vtables
20:12:48 <hpaste> holla pasted “statement parser” at http://hpaste.org/53148
20:13:13 <holla> can anyone help me with my parser
20:13:21 <kmc> of course if you use XML then your turing tarpit is Enterprise Webscale, if you use s-expressions then it's useless academic wankery
20:13:23 <kmc> that's the main difference
20:13:30 <holla> i keep getting stuck in an infinite loop
20:13:36 <kmc> it's really all about the closing tags, those make it webscale
20:13:49 <Cale> It's an awkward and ambiguous way to talk about the actual language feature which is being supported (like first class procedures or functions)
20:13:54 <holla> i think i need to use sepBy for sequence but not sure how to do it
20:17:24 <DanBurton> holla: yes, I imagine the infinite loop is because "statementP" can be a "sequence", which starts with a "statementP", which can be a "sequence", which starts with a "statementP"...etc and it never consumes input or determines that it is or is not a sequence
20:18:17 <DanBurton> though I don't have a lot of experience with parsers
20:18:52 <holla> is there a way i can make it fail if it is not sequence
20:18:58 <byorgey> holla: sepBy takes two parsers as arguments; the first parses the items and the second parses the separator
20:19:08 <byorgey> and it returns a list of the parsed items
20:19:23 <byorgey> holla: what do you mean, fail if it is not a sequence?
20:19:28 <DanBurton> :t sepBy
20:19:29 <lambdabot> Not in scope: `sepBy'
20:19:36 <DanBurton> @hoogle sepBy
20:19:36 <lambdabot> Text.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
20:19:36 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
20:19:36 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
20:19:55 <DanBurton> that second one, I believe
20:20:23 <byorgey> holla: are you using Parsec, or ReadP, or ... ?
20:20:51 <holla> I'm using a parser that I created
20:21:36 <byorgey> holla: oh, I see. and do you have a sepBy combinator?
20:22:16 <holla> yes...the type def is sepBy :: Parser a b -> Parser a c -> Parser a [b]
20:23:00 <byorgey> holla: yes, good.  So you want something like  sepBy (wsP statementP) (wsP $ char ';')
20:23:39 <holla> ok, so that returns a list of parsed items?
20:23:43 <byorgey> the only problem is that returns a *list* of Statements.  so you will then need to fold that list with the Sequence constructor to produce a single Statement.
20:24:22 <byorgey> wait, what am I saying.  That will have the same infinite loop problem.
20:24:29 <DukeDave> What are NamedFieldPuns ?
20:24:39 <DukeDave> Google isn't giving much up ;|
20:24:45 <byorgey> holla: you need to create a separate parser which will parse any statement *except* a sequence.
20:25:07 <byorgey> then you can safely call that one from within the sequence parser.
20:25:09 <DukeDave> Oh, I got it: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html
20:25:53 <holla> ok let me give that a try...
20:26:14 <holla> with sepBy...what would be first element in the parsed list?
20:26:25 <RaptorRarr> @src sepBy
20:26:25 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:26:31 <RaptorRarr> @hoogle sepBy
20:26:31 <lambdabot> Text.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
20:26:32 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
20:26:32 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepBy :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
20:26:43 <holla> could i pattern match on it ?  (x:xs) <- sepBy (wsP statementP) (wsP $ char ';')
20:27:24 <byorgey> holla: you could
20:27:34 <byorgey> holla: but I don't understand what you are trying to accomplish
20:28:00 <byorgey> oh, to get the first element in the parsed list? yes, that would be x
20:28:23 <byorgey> assuming the list is not empty
20:28:45 <holla> ok let me give it a shot
20:32:10 <themirror> holla: we are in the same class haha. i can't figure out how she fixes the recursion problem with chainl for the life of me
20:34:26 <DanBurton> using NoImplicitPrelude, is it possible to override list syntax?
20:35:13 <DanBurton> for example, if I want to use (:) for something else
20:38:25 <RaptorRarr> (:) is a buttoned vest.
20:38:49 <RaptorRarr> DanBurton: It's worth a try.
20:39:17 <byorgey> themirror, holla: what class are you in?
20:40:21 <byorgey> DanBurton: if you mean you want [x,y,z] to be interpreted using your own implementation of (:), NoImplicitPrelude certainly will not work
20:40:30 <byorgey> DanBurton: however it's worth trying RebindableSyntax
20:40:47 <holla> @themirror what do you mean by the recursion problem?
20:40:47 <lambdabot> Unknown command, try @list
20:41:37 <holla> themirror: like making it generic?
20:41:56 <themirror> holla: the sequence parse fails because s1 <- wsP statementP is recursive without consuming input
20:42:22 <holla> themirror: how do I consume it?
20:42:25 <themirror> something has to be done to avoid this problem, which is solved with chainl in some fashion that i cant comprehend because of the mutual dependence in the example in class
20:42:33 <themirror> holla: we'
20:42:43 <themirror> holla: we're in the same boat, im stuck
20:43:47 <holla> themirror: ok let me look into chainl...i was trying to use sepBy
20:44:02 <byorgey> oh, are you guys taking CIS 552 @ UPenn?
20:48:50 <themirror> byorgey: aye. the instructor encourages us to use this resource for help. how'd you know?
20:49:42 <DanBurton> what's the extension for when you have a class method default signature that is more specific than the regular signature?
20:50:29 <byorgey> themirror: I noticed your IP address. Stephanie is my advisor =)
20:51:45 <byorgey> DanBurton: there is no such extension.
20:52:08 <copumpkin> DanBurton: how would that work?
20:52:56 <DanBurton> byorgey: DefaultSignatures, I found it
20:53:09 <DanBurton> see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html
20:54:14 <copumpkin> oh, I see
20:54:26 <DanBurton> but it looks too new for the GHC I'm using right now :O
20:54:34 <copumpkin> get a newer GHC
20:54:56 <DanBurton> I'm too lazy to do that for windows right now. I'll just switch over to Ubuntu later
20:57:44 <DanBurton> I'm starting to like view patterns a lot
21:09:09 <kmc> <3 ViewPatterns
21:09:32 <kmc> PatternGuards are nice too (and they're in standard Haskell now!)
21:10:15 <tehgeekmeister> is there an analog to randoms in some package on hackage that provides an infinite list of random numbers within a range?
21:11:04 <DanBurton> @hoogle (a,a) -> [a]
21:11:04 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
21:11:05 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
21:11:05 <lambdabot> Prelude snd :: (a, b) -> b
21:11:11 <vharishankar> Hello again, all
21:11:38 <ski> @type randomRs
21:11:39 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
21:11:42 <DanBurton> I think randomRs
21:11:52 <ski> *nod*
21:12:03 <DanBurton> "Plural variant of randomR, producing an infinite list of random values instead of returning a new generator."
21:12:08 <tehgeekmeister> i did not notice that when i looked!
21:12:11 <ski> @src Random
21:12:11 <lambdabot> class Random a where
21:12:12 <lambdabot>   random    :: RandomGen g => g -> (a, g)
21:12:12 <tehgeekmeister> thank you.
21:12:13 <lambdabot>   randoms   :: RandomGen g => g -> [a]
21:12:15 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
21:12:17 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
21:12:19 <lambdabot>   randomRIO :: (a,a) -> IO a
21:12:21 <lambdabot>   randomIO  :: IO a
21:12:24 <vharishankar> I have a question regarding putStr and putStrLn
21:12:32 <ski> ask
21:12:58 <DanBurton> > getStdGen >>= mapM_ print . take 10 . randomRs (1,10)
21:12:58 <vharishankar> Whenever I use putStrLn it outputs the line as I expect it to
21:12:59 <ski> @src putStrLn
21:12:59 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
21:13:00 <lambdabot>   <IO ()>
21:13:14 <ski> vharishankar : you probably want `hFlush stdout'
21:13:24 <vharishankar> Thanks
21:13:25 <DanBurton> does lambdabot perform IO actions?
21:13:39 <byorgey> DanBurton: lots.
21:13:41 <vharishankar> I wasn't sure if it was due to the functional aspect of haskell or buffering
21:13:56 <ski> (that, or `hSetBuffering stdout NoBuffering')
21:14:09 <vharishankar> ski: thanks
21:14:18 <byorgey> DanBurton: but not ones you ask it to evaluate.
21:14:29 <DanBurton> byorgey: -__________________-
21:15:38 * ski imagines an exercise : prove `forall s. putStrLn s = putStr (s ++ "\n")'
21:16:14 * DanBurton is amused
21:16:19 <vharishankar> Is there any way to share an entire source here?
21:16:31 <byorgey> @where hpaste
21:16:31 <lambdabot> http://hpaste.org/
21:16:32 <companion_cube> @where hpaste
21:16:32 <lambdabot> http://hpaste.org/
21:16:37 <ski> > (take 10 . randomRs (1,10)) (mkStdGen 8128)  -- DanBurton
21:16:39 <lambdabot>   [6,2,8,8,4,7,5,5,10,8]
21:17:01 <DanBurton> ski: mkStdGen; good thinking :)
21:17:15 <companion_cube> ski: would such a proof be based on rewriting? or induction?
21:17:32 <ski> companion_cube : both, of course :)
21:17:33 <hpaste> Harishankar pasted “"caesar" encryption” at http://hpaste.org/53149
21:18:01 <vharishankar> What is wrong with the code?
21:18:15 <byorgey> companion_cube: you would also need to first postulate some laws about the behavior of putStr and putChar.
21:18:23 <tehgeekmeister> man.  and here i always dreaded the idea of working with random numbers in haskell.  is easy!
21:19:07 <DanBurton> tangentially related, I keep finding myself wanting ifF :: (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b
21:19:19 <DanBurton> @hoogle (a -> Bool) -> (a -> b) -> (a -> b) -> a -> b
21:19:20 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
21:19:20 <lambdabot> Control.Parallel.Strategies (-||) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
21:19:20 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
21:19:55 <DanBurton> @let ifF pred t f x = if pred x then t x else f x
21:19:56 <lambdabot>  Defined.
21:20:10 <ski> DanBurton : i've seen that called `cond'
21:20:11 <DanBurton> > ifF isAlpha succ id $ 'a'
21:20:13 <lambdabot>   'b'
21:20:16 <ski> vharishankar : i'm not sure what's wrong, but you could use `unless', instead of the conditional
21:20:45 <vharishankar> ski, it works all right, but I wanted to know why do is required after the if statement
21:20:56 <Cale> vharishankar: Well, first of all, you'll want to configure your text editor to not put tabs in your source files
21:21:08 <Cale> If you're using vim, it's :set expandtab
21:21:13 <ski>   unless (null st) $ do
21:21:17 <ski>     putStrLn ("The encrypted string is: " ++ map caesarenc s)
21:21:18 <ski>     main
21:21:24 <Cale> (setq-default indent-tabs-mode nil) for emacs
21:21:29 <vharishankar> Cale: I couldn't get the indentation right. I'm suing kate
21:21:42 <vharishankar> I'm using kate (lol at my mistake)
21:22:35 <vharishankar> I am confused about indentation. When I use the spaces, the compiler says error in indentation
21:22:45 <Cale> Configure -> Kate -> Editor -> Indentation -> Use spaces instead of tabs
21:23:06 <Cale> and then if/then/else should be indented like:
21:23:08 <Cale> if foo
21:23:10 <Cale>   then bar
21:23:12 <Cale>   else quux
21:23:25 <ski> vharishankar : well, since you wanted to combine two commands in the `then' part, you needed a `do' there to combine them into a single expression
21:23:36 <vharishankar> Cale, thanks.
21:23:38 <companion_cube> byorgey: i assumed the proof was based on the source code of putStr[Ln]
21:23:42 <companion_cube> or a specification
21:23:45 <vharishankar> ski, ah that explains it
21:24:00 <ski> vharishankar : note that the `..'s in `if .. then .. else ..' are all expressions, even if the whole conditional appears as a command in `do'
21:25:01 <Cale> wait, doesn't he have a do?
21:25:15 <Cale> Maybe I'm looking at the wrong paste :)
21:25:21 <shachaf> Cale: ski didn't say otherwise.
21:25:30 <ski> (there's no special `do { if exp then {cmds0; ...} else {cmds1; ...} ; cmds; ...}' construction, unlike `do {let {decls; ...}; cmds; ...}')
21:25:33 <Cale> oh, I see
21:25:37 <Cale> I missed that question :)
21:26:00 <Cale> Yeah, do is for gluing multiple actions together into more complicated ones
21:26:04 <shachaf> I find the nested indentation that you get in do notation to be kind of annoying.
21:26:10 <vharishankar> Thanks
21:26:19 <shachaf> I guess using EitherT or ContT or something would resolve that, kind of?
21:26:27 <vharishankar> Yes, I was confused about indentation. Editor automatically indents.
21:26:28 <hpaste> Cale annotated “"caesar" encryption” with “how I might indent it” at http://hpaste.org/53149#a53150
21:26:39 <ski> `ContT' for the win !
21:26:44 <shachaf> "resolve" by making things more complicated.
21:27:10 <ski> (even better : a composable continuations transformer with separate "inner" and "outer" result types)
21:27:11 <hpaste> DanBurton annotated “"caesar" encryption” with “How *I* might indent it :)” at http://hpaste.org/53149#a53151
21:27:14 <shachaf> In C you can write things like { if (foo == 0) { return false; } ... }, without indenting everything else.
21:27:51 <Cale> Well, that's more than just an indentation change, but sure :)
21:27:56 <DanBurton> well yes
21:27:59 <ski> DanBurton :)
21:28:04 <napping> you can write things like that in Haskell without indenting as well
21:28:05 <DanBurton> I was about to paste, and saw you pasted first Cale :)
21:28:28 <vharishankar> Haskell really makes me excited about doing programming. It's like being back in school learning C coming from BASIC. :-)
21:28:31 <Cale> vharishankar: People won't generally care how much things are indented by, so long as they line up
21:28:35 <DanBurton> I personally prefer using emacs's automagical indentation for Haskell
21:28:44 <shachaf> Cale: Right, it's a bigger issue than indentation.
21:28:48 <hpaste> aavogt annotated “"caesar" encryption” with “How *I* might indent it :) (annotation)” at http://hpaste.org/53149#a53152
21:28:50 <napping> shachaf: you can use explicit layout
21:28:59 <shachaf> napping: My issue is nesting, not indentation.
21:29:02 <vharishankar> Cale, thanks. It was the compiler which complained about wrong indentation first so I figured it is a bit like Python
21:29:02 <napping> (and ContT, for that matter)
21:29:03 <DanBurton> vharishankar: that's good! :)
21:29:25 <Cale> aavogt: haha
21:29:33 <shachaf> Cale: But when you have x <- y; case x of Nothing -> ...; Just a -> do { ... }, nested a couple of times, it gets really annoying.
21:29:37 <ski> aavogt : non-structuralist there :)
21:29:55 <shachaf> Also using a monad transformer is rather heavyweight, conceptually; you have to lift everything and so on.
21:29:58 <Cale> shachaf: Time to invent a combinator!
21:30:11 <shachaf> Cale: A combinator for Maybe?
21:30:18 <byorgey> companion_cube: their source code is low-level and magical.  and there is no specification of IO.
21:30:18 <Cale> hehe
21:30:26 <shachaf> My issue is with the general pattern; inventing a combinator for each instance isn't reasonable.
21:30:27 <Cale> shachaf: Or figure out which of the existing ones apply ;)
21:31:01 <Cale> You can almost always get away with some combination of the monadic things, mplus, and mappend
21:31:27 <shachaf> Not in my experience.
21:31:28 <Cale> (but it sometimes requires more thinking to write than just using case)
21:31:32 <DanBurton> monadic magic
21:31:39 <shachaf> I can't think of a concrete case to show here, though.
21:32:09 <companion_cube> byorgey: but you could give a spec like "putStrLn x = putStr x >> putStr "\n""; of course it makes the problem simpler :)
21:32:19 <shachaf> Cale: I don't object to extra thinking in general, but sometimes it just seems gratuitous.
21:32:33 <vharishankar> Thanks for the annotations, all. I am just starting to understand how control flow is achieved in Haskell... Not sure if I should confuse myself with IO before I learn more about functional programming though.
21:33:11 <companion_cube> but in fact i think that if s fills more than half the memory, putStrLn s will succeed and putStr (s ++ "\n") will not
21:33:19 * ski . o O ( `putStr = mapM_ putChar' )
21:33:40 <DanBurton> vharishankar: for beginners, it is common to simply fire up ghci and play with functions and stuff
21:33:48 <vharishankar> On the other hand, writing SOMETHING on my own which I can understand makes me feel more comfortable than blindly copy/pasting my way through a tutorial.
21:33:53 <napping> shachaf: is there a general solution, or not?
21:33:54 <vharishankar> Thanks DanBurton
21:34:18 <shachaf> napping: To what?
21:34:30 <napping> to your problems with things becoming nested
21:34:31 <DanBurton> vharishankar: or you can always play with lambdabot :)
21:34:34 <vharishankar> Yes, ghci is really cool. But not exactly like the python interpreter though.
21:34:38 <shachaf> ContT is a general solution to everything.
21:34:41 <napping> a C-style non-local return, maybe
21:34:51 <shachaf> napping: I don't know if there's a general solution that's satisfactory in Haskell.
21:35:01 <napping> how about working in ContT then?
21:35:17 * DanBurton loves ghci to death. :t is quite possibly the best feature ever
21:35:21 <napping> if you don't actually need to think about each new case
21:35:40 <napping> vharishankar: the next ghc release is supposed to support all top level definitions in ghci
21:35:41 <shachaf> But I do know that there's code that becomes annoyingly nested in Haskell and not in some other languages, which requires annoying extra thinking about that doesn't seem to yield much benefit.
21:35:46 <shachaf> napping: Or EitherT, for that matter.
21:35:56 <vharishankar> napping: thanks.
21:36:09 <shachaf> But one-off monad transformer use is pretty annoying.
21:36:19 <tigger> this seems like it should be easy but I can't come up with a really quick way to do it: how can you have a function that either takes a string or no arguments and does IO? so like function "hello" would print "hello" and function would do something else
21:36:25 <shachaf> Even in cases where what I'm doing is *exactly* MaybeT, it's often clearer to do it by hand than to use MaybeT.
21:36:37 <shachaf> tigger: If it takes no arguments, it's not a function.
21:36:45 * ski made a potentially infinitely nested/repeated `ContT', to be able to backtrack backtracking (and backtrack that, ad infinitum)
21:36:52 <shachaf> tigger: You can do it with type classes but it's probably not a good idea to.
21:36:58 <DanBurton> shachaf: other languages hide the complexity of mutation, which often makes things much simpler. Haskell's explicit take on mutation is a double-edged sword
21:37:22 <shachaf> DanBurton: No mutation involved.
21:37:33 <Jafet> DanBurton: right-leaning code has nothing to do with mutation
21:37:36 <DanBurton> shachaf: "effects", then
21:37:37 <shachaf> And, anyway, that sounds like a cop-out.
21:37:45 <Jafet> No effects, either
21:37:45 <shachaf> What happened to Haskell being the world's best imperative language?!
21:37:50 <Jafet> Consider nested cases
21:38:02 <napping> you don't want to use the appropriate monad?
21:38:09 <shachaf> Effects might have something to do with it, partly, but the issue is more fundamental, I think.
21:38:11 <DanBurton> Jafet: then what does right-leaning code have to do with?
21:38:51 <Jafet> The fact that most of the choice syntax constructs involve indentation.
21:38:56 <shachaf> napping: If you use ContT/EitherT, you have to lift everything else, and you get bigger if you had things that took actions as argument, and so on.
21:39:20 <Jafet> Oh, perhaps shachaf was talking about some other kind of nesting.
21:39:25 <Jafet> @quote 007
21:39:26 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
21:39:26 <lambdabot> UTF8&s=books <lambdabot> http://tinyurl.com/root7
21:39:39 <Jafet> @quote monochrom 007
21:39:39 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
21:39:39 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
21:39:41 * ski . o O ( "leaned so far right he came back left again!" )
21:40:29 <companion_cube> excellent
23:41:16 --- topic: '["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin/spam issues: #haskell-ops"]'
23:41:16 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Sep 03 10:10:12 2011]
23:41:16 --- names: list (clog rekahsoft WanderingGlitch gwicke mah_b Yarou qnikst nexx BizarreCake edwardk sopvop Itkovian pikhq_ xcvii mgsloan Apocalisp adam3 wtw ManateeLazyCat hrolf adlan handonson zhulikas Sup3rkiddo minsa1 neilk_ DevHC jan247 aidenhong MUILTFN fusion5 c0rn bru` copumpkin shintah mikeplus64 telexicon scm Palmik grumpytoad absentia setmeaway moriramar Jafet a11235 skaar mdempsky Harwin Anxuiz BlankVerse Smokey` jb55 And[y] Runar overrosy davesq Saulzar The_third_man)
23:41:16 --- names: list (scsibug_ mxweas napping tvynr doritos tehgeekmeister rsampaio alc herself EyesIsServer wespee empity``` hiredman ps-auxw MoALTz__ otto_s_ drdo rxc kirindave vili wli siracusa milkpost_ gtirloni wtetzner bfig DasIch helgikrs Carter Samy [[zz]] GreaseMonkey salisbury DanBurton endojelly bens OnionKnight pettter Nanakhiel irene-knapp realitygrill juhp replore_ theorbtwo Igloo meanburrito920 drhodes trin_cz bradleyayerswork zeiris mroman koala_man kfish cubi)
23:41:16 --- names: list (danharaj_ gienah eskimod rferranti kvey wto SyntaxNinja maurer pizzaplane albel727 }ElectrowolF{ aditya` skatez|peecee fryguybob kmels blackh dmos krishna augur c_wraith Cerise kolmodin1 Peaker milkpost Phyx- tomku robryk polux_ proq incluye Varakh dino- sagelywizard ruud shoerain Gilly ksf EmanuelZ Dodek ben Twey kamaji ToRA perlite brisbin koeien mlh petermw Younder noam preflex mauke Kaidelong kalven SmartViking zaero master_of_master schroedinbug rmunoz)
23:41:16 --- names: list (danols_work Philippa copton drbean Vorpal joelb guampa dnjaramba karlito oww levitation[A] vold ddarius pigoz nighty__ Tordek Cale Nanar milli iana iFire insomniaSalt Martty orbitz klapaucius Reisen puddy HalfWayMan ace2001ac ArchGT stepkut stepcut parcs_ ngochai jonke_ bogner xenocryst djanatyn ryant5000 tnks inetic ville KaneTW bbee mrapple oldwzd Nisstyre Kelet JaffaCake peterhil Saizan totte cacodaemon ortmage u_quark _chops obcode quackv2 Cope flippo Fuco)
23:41:16 --- names: list (neurogeek hackagebot Jaxan nwf zax_ wolong sbahra jamiely_desktop yrlnry Yacoby welterde Veinor ClaudiusMaximus clsmith julmuri QtPlatypus gentz smly- Ke rgrinberg jyyou A1kmm Modius __class__ drmegahertz jd10 rwbarton aliak ibid joevandyk mrdomino SonicvanaJr eZet alip purpleposeidon T_X blast_hardcheese arpunk em nkpart danr dju Draconx robinbb jrk_ jonafan ian_mi dcoutts mortberg amiri_ derrida profmakx i__ puzza007 uu1101 waern dqd tafryn araujo orangejuice)
23:41:16 --- names: list (almostsix cheater leod Berengal IvdSangen TomMD dfeuer levi KitB Polarina arcatan pi8027 ormaaj mercury^ harski MjrTom mike-burns dmwit sanjoyd k0ral dRbiG flux companion_cube chitragupt dixie c2thunes newsham nyingen davidL EvanR srid sdf12 hyko petekaz gredman warpy ttblrs shachaf jbalint Innominate djahandarie mattam sgronblo ChongLi sohum brixen Mitar mapour `0660 zygoloid Sunhay mokus mdwright Starfire DrSyzygy olsner bartavelle Laney ehamberg magicman)
23:41:16 --- names: list (cods alek_b wunki_off eyck int-e maloi DustyDingo framling ahihi2_ yell0 arkx iulian c1de0x dannynn kofman Ferdirand otulp SimonRC alexbobp idoru ethercrow armence mattp_ lucca Boney j-f lyn lpsmith lusory si14 ciaranm mike1703 Nimatek qz snarkyboojum redsteg rotflcopter waern__ plat0 integral lomeo dogmaT ski sully srh isenmann tswett zenzike nlogax flamingspinach snappy stepnem sm inr pantski pcapriotti Taggnostr2 doelie twn xrl justicefries kosmikus wjlroe)
23:41:16 --- names: list (haukeh Naresh akahn dkannan|away liesen dabradley micrypt tomh Baughn the-kenny arnihermann bradwright whoops etabot zomg_ faern rby gerard0 jbauman Counter-Strike earthy Masxmasx{AFK} frerich Gunni saiam Blub\0 audunska lokydor obiwahn fasta wyfrn caligula_ kephas ybit atsampson gf3 byorgey lambdabot norm2782 KernelTrap frio dilinger sunnavy quicksilver raek Guest48922 srcerer freiksenet d34df00d jakeskik naneau jrd0 helmut niko ion Ikarus dreixel TML Aisling)
23:41:16 --- names: list (adnam andersk kmc tgeeky traviscline d-snp Nshag Vulpyne zmoazeni sipa sunfun thetallguy1 ScooterAmerica bezik Megant [mth] Derander trez R496 bmiddleton _1amzave sshc eno Bwild protozoa saurik Nafai rfgpfeiffer CosmicRay etpace progrock poucet ttvd zomg koninkje_away quaestor_ jcapper luite marienz andrewsw tomaw xplat yam ido tromp pr mejalx Harbinger erg alpounet gemelen ernst ptrf Will| untwisted klugez periodic aszlig ztatlock suiside noplamodo cjackson)
23:41:16 --- names: list (loupgaroublond carlocci yahooooo emias thoughtpolice appamatto burp eigenweave tomlok bd_ thirsteh cao jabirali pesco anachron nazgjunk dabailey tlockney cynick houeland _jesse_ metatagg mkirillov ByronJohnson cizra args[0] BMeph bqf akosch snorble Jaak astory MasseR hpc wormphle1m thetallguy bvck PreciousMetals inittab davv3 Deewiant tsuraan penryu mm_freak jrockway sShintah MK_FG monochrom Botje __main__ s_chng kloeri mantovani bremner` mendez idnar wavewave)
23:41:16 --- names: list (Daegalus jayne bddn lebastr shutdown_-h_now ziman Maxdamantus franny Intensity linduxed geekounet Khisanth ousado Draggor Guest81642 birkenfeld Enigmagic kate__r dcoutts__ frigga1 ricky coppro sp3ctum majoh Internet13 dom96 mietek hpaste dsantiago LeNsTR|off solarus blackdog aristid joni6128 limetree_ shawn_ theclaw jix_ deavid edwtjo kolmodin lispy koeskoes EvanR-work geekosaur comak saati Corey robbert ixzkn Entroacceptor nimred jlewis zakwilson tessier)
23:41:16 --- names: list (spiff_ ahf jtg janne anders^^ froztbyte Ptival Eelis awg mrshoe Nereid shepheb taruti tew88 jmcarthur thorkilnaur angstrom FireFly jrslepak bisli tridactyla kpal reacocard Boxo ReinH BrianHV ahkurtz inimino smop_ cjay gdsx davean_ mux electrogeek tauntaun confound wires masterzora dorkitude noj hvr Vq opqdonut jlouis petanqk tg szbalint ray alexsdutton EEVIAC_ jml ve dropdrive peddie Eliel abbe biio johs Yahovah brett dcolish _habnabit ocharles gseitz McManiaC)
23:41:16 --- names: list (Belgarion0 mornfall sordina2 freeformz_ jql seats Liskni_si liyang kshannon Dashkal nniro osfameron ccasin Obfuscate aninhumer edenc othiym23 noddy ivan` PHO_ Gracenotes kaol ssalbiz Hunner Ornedan CindyLinz tamiko chra elliottt chee1 evhan duairc karld mrd nominolo epdtry yottis stroan willb impl absence skrblr devn dumael Clint _erik_ @ChanServ)
23:41:17 <rekahsoft> hi all :)..anyone use emacs for haskell devel? i am having some issues with emacs-haskell-mode..specfically C-c C-= and other keybindings do not work and do not show up when i do C-h b
23:41:27 <thoughtpolice> scratch that again
23:41:34 <thoughtpolice> gtk+hs was around *at least* in 2002 :)
23:41:49 <handonson> (I was trying to implement a simple chatting frontend as an assignment to the school's network course, and I had to use String for updating the log window all the time)
23:41:50 <thoughtpolice> (and the 2002 release was the 0.14 release!)
23:41:53 <Cale> rekahsoft: heh, I have used it before in the past, but I never used keybindings as much as that :P
23:42:23 <handonson> (I could clearly observe everything getting slower and slower as the chatting progressed)
23:42:43 <Cale> handonson: Yeah, stuff like that definitely deserves a ByteString or Text interface
23:43:10 <Cale> Anywhere that you might have to deal with more than a handful of lines, you certainly want the option.
23:43:11 <handonson> Cale: I'd say it requires rather than deserves :)
23:43:29 <thoughtpolice> Text would definitely be the way to go for that, IMO
23:44:43 <thoughtpolice> wow, just looking at this old web page seems crazy. "this release requires GHC 4.08"
23:45:21 <Cale> thoughtpolice: Yeah, I seemed to recall that the GTK binding was around at least nearly since I started writing Haskell, and ByteString is practically new technology ;)
23:45:23 <handonson> I always thought 7 was too high a number for a compiler version... and it was 4 in 2002? still high! :)
23:46:07 <Cale> handonson: you can still download 0.29 on the ghc website
23:46:10 <thoughtpolice> clearly GHC should go for the chrome versioning number
23:46:16 <thoughtpolice> *versioning scheme
23:46:26 <thoughtpolice> Cale: hah, i think i've actually looked at the source of that once long ago :)
23:46:40 <Cale> yeah, release GHC 8, 9, and 11 within weeks of each other.
23:46:42 <handonson> Cale: and Text is newer. Phew! For how long did Haskellers abuse String for everything?
23:47:18 <Cale> handonson: ages. Most Haskellers didn't really care so much about performance as semantics for a long time.
23:48:06 <thoughtpolice> we'll be on GHC 24.03092.342893 by next year, i estimate
23:48:09 <ddarius> There were buffers and ByteString grew out of GHC's semi-internal FastPackedString.
23:48:18 <Cale> If there's a complaint to level about String in that regard, it's that capitalisation can't work on an individual character level, in all languages.
23:48:19 <handonson> Cale: and now there are performance junkies everywhere writing bytestring, text, attoparsec, snap, warp, ...
23:48:32 <Cale> (and things like collation order...)
23:48:58 <ddarius> The Report's commitment to Unicode is very superficial.
23:49:25 <Cale> ddarius: Superficial but at least it was there!
23:51:13 <Cale> Fuck byte arrays, I have a Pentium II, lazy linked lists of 32 bit Char all the way!
23:51:30 <napping> lazy boxed 32 bit Char
23:51:31 <rekahsoft> Cale: awe :(..it just aligns equal signs when doing pattern matching and such :P
23:51:37 <rekahsoft> usefull i think..
23:51:52 <Cale> rekahsoft: ah
23:52:28 <napping> I wonder if Agda will ever stop using unary
23:52:31 <Cale> rekahsoft: Maybe there's some option in the haskell-mode setup? I don't really recall very clearly how it all worked :)
23:53:39 <napping> Edwin Brady's optimizations might just make that efficient enough
23:54:58 <handonson> I guess the historic Haskell gurus didn't really focus on the potential of Haskell becoming one of the languages with highest performance
23:55:31 <napping> if it's faster than SK combinator graph reduction, you're doing pretty good :)
23:55:56 <napping> maybe throw in B and C if you want to get fancy ;)
23:56:45 <handonson> How does GHC compile String internally?
23:57:21 <napping> [Char], how else?
23:57:28 <handonson> I mean
23:57:37 <napping> constants turn into something reading from an array in the binary, though
23:57:53 <ddarius> handonson: You could always do high performance IO in GHC.  As I just mentioned there have always been primitives for it.  What do you think ByteString uses?
23:58:18 <ddarius> napping: They turn into what was once FastPackedString.
23:58:21 <handonson> yeah, so it becomes something like C's char[] and a generator attached to it, right?
23:58:57 <ddarius> The only thing that has changed recently is that we now have a -pleasant- interface for it.
23:59:28 <napping> yes, a list thunk is allowed to come up with the new constructor however it likes
23:59:43 <handonson> it's not like all the pointers that is used to represent a String in memory are saved, is it?
