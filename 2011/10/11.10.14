00:00:05 <kmc> "A variable of type IORef Int and one of type MVar Int can both exist with the same name."  this is also a terrible design decision
00:01:07 <kmc> the package calls them "Namespaced, global, and top-level mutable variables"
00:01:11 <kmc> in what way are they namespaced?
00:01:24 <copumpkin> I'd avoid calling him out specifically
00:02:03 <kmc> i'm sure the author has good intentions
00:02:25 <kmc> but this package is worse than nothing, imo
00:03:11 <kmc> maybe it will evolve into something better than nothing
00:03:49 <kmc> like there was mention of generating unique names via TH
00:04:19 <kmc> but the current docs consider the impossibility of hiding global variables from other packages to be a feature
00:04:50 <dolio> I think ACIO is significantly better.
00:04:54 <dolio> And I'm not wild about it.
00:05:02 <kmc> ACIO is much better
00:05:11 <dolio> Of course, you can't do that as a package.
00:05:35 <kmc> you might could do it with a TH decl splice and an unsafe implementation
00:06:52 <dolio> Possibly.
00:07:14 <kmc> you could hide this same Map behind a TH decl splice, lift the decl'd Name to runtime, and use that as the map key instead
00:07:38 <kmc> and the splice could enforce monomorphism too
00:07:52 <dolio> I'm going to sit here and wait for first-class modules that can be wrapped in monads.
00:41:18 <MaskRay> hi all. i'm working on printing an ADT which represents a propositional logic expression { Not x, And x y, Or x y, Imply x y, Bicondition x y }
00:41:45 <MaskRay> can anyone suggest a printing way to generate less parens?
00:42:20 <MaskRay> remove redundant parens according to operator precedence
00:44:16 <kmc> :t showsPrec
00:44:17 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
00:45:22 <MaskRay> by in-stack/income precedence
00:47:35 <MaskRay> maybe i need a function of  `Tree -> Int' to compute in-stack or incoming precedence
00:48:21 <c_wraith> MaskRay: kmc's line was relevant
00:50:23 <MaskRay> c_wraith: kmc: thanks
01:02:47 <Blkt> good morning everyone
01:08:45 <Sawyer> Hi guys, does haskell file name have to be the same as the module name?
01:09:07 <shachaf> Sawyer: For the most part.
01:09:09 <shachaf> Not with Main.
01:09:27 <shachaf> ...
01:09:29 <shachaf> Er.
01:11:07 <Sawyer> I remember I read somewhere that it doesn't have to necessary, but I just read from wiki book, which says: "The name of the file must be that of the module but with a .hs file extension."
01:11:32 <kmc> it's implementation-defined i believe
01:11:39 <kmc> with GHC, yes, the name should match unless it's the Main module
01:11:49 <sipa> for all modules depended on
01:13:13 <Sawyer> so in GHC, it's just like java public classes right? the public class name should be the file name?
01:14:15 <sipa> yes
01:14:32 <sipa> except for main
01:15:36 <Sawyer> sipa, do you mean the module contains the main function or the module named as Main ?
01:16:27 <kmc> i think the Java analogy is gratuitous
01:16:47 <kmc> is there anything insane about declaring an instance of TH's Lift class for TH's Name type?
01:18:39 <wavewave> Sawyer; for Main module, haskell source file need not to be Main.hs. but Main module must contain a function named main :: IO ()
01:19:40 <ion> -main-is Set main module and function
01:19:47 <Axman6> hmm, i wonder if it would be useful for all modules to have their own main, but it's not exported, so that each module could say have a main that runs tests for the module if you compile it is a program
01:20:02 <wavewave> Sawyer: you can omit 'module Main where'  though
01:20:07 <kmc> wavewave, that 'main' is not a function
01:20:30 <wavewave> kmc: *nod*.. main monadic action.
01:20:33 <ion> ghc’s man page makes the same error.
01:20:44 <kmc> or just IO action, no need to invoke the scary m-word ;)
01:26:56 <shachaf> main usually is a function.
01:27:00 <shachaf> Just not in Haskell.
01:27:19 <Sawyer> one more dumb question, how does GHC recognize Main module if you don't name it's Main.hs? By inspecting which souce contains a main function? what happens there have more than one main function defined more multiple source files?
01:27:20 <otulp> But function usually isn't, right.
01:28:05 <Axman6> Sawyer: that's not legal i think. you can't have main defined in module Foo.Bar
01:28:19 <otulp> Why not, if you don't export it?
01:29:28 <otulp> Or, even if you do export it. As long as it isn't in Main, it shouldn't be mistaken for Main.main, should it?
01:30:05 <sipa> the source file defines which module it is
01:30:35 <sipa> as long as you make sure the source for the main module is included
01:30:46 <sipa> you have a main function
01:31:25 <Sawyer> sipa, can I define multiple modules in one file?
01:31:39 <sipa> no
01:31:47 <shachaf> Not in GHC.
01:32:00 <Sawyer> ok, I see
01:49:08 <kmc> data InlineSpec = InlineSpec Bool Bool (Maybe (Bool, Int))
01:49:10 <kmc> no haddock
01:49:15 <kmc> thanks, Template Haskell!
01:51:30 <shachaf> kmc: There are non-Haddock comments.
01:52:19 <ion> hah
01:52:25 <shachaf> «False: no inline; True: inline» «False: fun-like; True: constructor-like» «False: before phase; True: from phase»
01:52:33 <kmc> yeah, i found those
01:52:35 <shachaf> Admittedly the last one doesn't make much sense.
01:53:45 <ion> A good example of abusing booleans, too.
02:21:13 <rostayob> Is there a way to include a gloss Picture in some GUI?
02:23:01 <quicksilver> Axman6: you can put 'main' in any module; that's probably a GHC extension I guess.
02:23:56 <Axman6> hmm, and that will just work? that's useful to know.
02:24:17 <quicksilver> I don't remember to be honest.
02:24:27 <quicksilver> I think ghc --make Foo.hs will "find" the main function in Foo.hs
02:24:36 <quicksilver> but for more flexibility you use -main-is
02:24:40 <quicksilver> (or is it --main-is?)
02:24:42 <Axman6> It seems to me that it would be a good habit for more package developers to get into to write (probably quickcheck) tests for their modules. and I think having the testing code in each module would be useful
02:24:55 <quicksilver> yes, definitely
02:25:10 <quicksilver> although I think I'd favour a convention for that where the tests are called 'run_tests' or something
02:25:20 <quicksilver> and GHC has a special mode to compile and execute the 'run_tests' action.
02:25:28 <c_wraith> Axman6: there's a *huge* problem with that, though.
02:25:29 <quicksilver> (rather than main)
02:25:40 <c_wraith> Axman6: it makes your package depend on quickcheck
02:25:48 <Axman6> indeed :\
02:26:07 <c_wraith> Axman6: and quickcheck 1 and 2 are different enough that they're source-incompatible
02:26:20 <c_wraith> Axman6: meaning it can make packages fail to work together that otherwise would
02:27:02 <Axman6> that's more a problem with the module system/cabal though
02:27:53 <quicksilver> you just wouldn't state the dependency, c_wraith
02:28:03 <quicksilver> the dependencies would be things you need to build
02:28:14 <quicksilver> if you want to run the tests, you recognise the error and install the missing package
02:28:23 <c_wraith> that's...  not an option, the way things currently stand
02:28:25 <quicksilver> (although of course having a separate tests-depends: field might be handy)
02:28:49 <quicksilver> hmm yes it would be ugly you'd have to #ifdef the imports out
02:28:50 <c_wraith> if your tests are in the same modules as the code, you can't compile the code without the tests
02:29:03 <quicksilver> maybe you put them in separate physical files
02:29:13 <quicksilver> which get "catted" onto the end of the modules to compile
02:29:14 <c_wraith> In fact, that's what I've done
02:29:20 <c_wraith> well, not that part
02:29:29 <sipa> there is little "physical" about files, imho :)
02:29:42 <c_wraith> I just put the quickcheck tests in a different file, and put them in the extra-source-files section
02:29:52 <c_wraith> and didn't include anything about building them with cabal
02:30:28 <quicksilver> sipa: sorry, it was a stupid choice of adjective
02:30:53 <quicksilver> sipa: my point was that they wouldn't be proper independent modules; they'd be part of the same module, just in different files in the filesystem
02:31:03 <quicksilver> for a crude simple form of conditional compilation
02:31:11 <quicksilver> (splicing the imports to the top would be quite easy although annoying)
02:31:22 <quicksilver> bit like tangle/weave
03:44:12 <Axman6> @remember Porges State is stored in spacesuits. [via: reddit]
03:44:12 <lambdabot> I will remember.
03:44:48 <erus`> a monad is like a taco
03:45:31 <MarkusRamikin> Hi all, I'm new to Haskell. Any editor recommendations? I'm about to try out Notepad++, is that any good?
03:45:38 <geheimdienst> state is stored in troopers?
03:47:42 <erus`> MarkusRamikin: i use gedit on windows
03:47:44 * hackagebot logic-TPTP 0.3.0.0 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.3.0.0 (DanielSchuessler)
03:50:11 <erus`> where do i report the fact that haddock doesnt build?
03:52:46 <geheimdienst> erus`: http://hackage.haskell.org/package/haddock has a link to their bug tracker. also see the "build failure" field
03:55:20 <MarkusRamikin> erus`: thanks
04:05:53 <ytop> hola
04:07:35 <ytop> hello?
04:12:18 <erus`> hello
04:14:46 <erus`> i don't know why you say goodbye, i say hello.
04:15:40 <Axman6> hello hello
04:23:40 <ibid> oh no
04:25:50 <absence> http://pastebin.com/BPBbXFrz <- how can this repa fromFunction test be made more concise/elegant?
04:25:52 <mauke> The paste BPBbXFrz has been copied to http://hpaste.org/52609
04:26:59 <Axman6> absence: can you use a case statement?
04:27:29 <geoffgeoff> haskell is OK
04:27:39 <khs> anyone know how to make a codeStyle for pprCode? I would like to dump Core to JSON (or some similar format). Any ideas?
04:27:45 <Axman6> oh good, i thought it was going to die
04:28:32 <absence> Axman6: i guess?
04:29:04 <Axman6> absence: well, you have a lot of unnecessarilly repeated code. and that's usually a sign you can improve.
04:29:34 <Axman6> maybe something like component (Z .: x .: y .: z) = pixel x y !! z
04:30:54 <absence> ah, i like that :) thanks
04:32:35 <absence> Axman6: will laziness prevent !! from iterating the pixel list four times per pixe?
04:32:44 <absence> +l
04:34:40 <Axman6> no. but if you want that, there's a better way to do what you've done: component (Z .: x .: y .: z) = case z of 0 -> r; 1 -> g; 2 -> b; 3 -> a; where [r,g,b,a] = [fromIntegral...]
04:38:52 <absence> Axman6: not so pretty, but it works :) thanks again
04:47:30 <Bummi> hellooo, is there any super easy way to make a return value from a function negative? e.g. max 4 -(func a b)
04:47:46 <Axman6> :t negate
04:47:47 <lambdabot> forall a. (Num a) => a -> a
04:48:19 <sipa> max 4 $ negate $ func a b
04:48:31 <Bummi> aight, thanks!
04:50:49 <absence> it's also possible to do "component (Z :. y :. x :. c) = Repa.fromList (Z :. 4) (pixel x y) Repa.! (Z :. c)", but i'm not sure if it's a good idea ;)
04:51:20 <bartavelle> I would like an advice, I am writing a parser with Parsec, and my main loop is like that : result <- many stmtparser
04:51:49 <bartavelle> stmtparser returns Expressions, but it would be really useful if I could return [Expressions] sometimes and just concat them to the list
04:52:34 <bartavelle> is there something better than doing : result <- (many smtparser_list <|> (many stamparser))
04:53:02 <bartavelle> and writing two distinct 'stmtparser', one for single objects, and one for lists
04:53:36 <Axman6> can't you just check if the list has a single object or not?
04:53:56 <bartavelle> you mean always outputing a list ?
04:54:04 <Axman6> yeah
04:54:05 <bartavelle> that would be a much better idea indeed
04:54:07 <bartavelle> :/
04:54:11 <bartavelle> thanks
04:54:13 <Axman6> heh :)
05:02:10 <bartavelle> ok i have another question, I have something like that : stmtparser = parser1 <|> parser2 <|> parser3 ...
05:02:29 <bartavelle> hum
05:02:30 <bartavelle> no
05:02:32 <bartavelle> sorry ;)
05:02:39 <Philonous> Is there a "blessed" library for monadic control structures? (e.g. monad-loops)
05:03:08 <Axman6> not that i know of. monad-loops should be fine
05:03:33 <Philonous> Ok, thanks
05:07:45 * hackagebot avahi 0.1 - Minimal DBus bindings for Avahi daemon (http://avahi.org)  http://hackage.haskell.org/package/avahi-0.1 (IlyaPortnov)
05:07:47 * hackagebot generic-server 0.1 - Simple generic TCP/IP server  http://hackage.haskell.org/package/generic-server-0.1 (IlyaPortnov)
05:13:55 <axeljohnsson> hi
05:17:01 <Axman6> hi axeljohnsson, nice to meet you, how may we help you?
05:17:02 <Axman6> -_-
05:17:21 <geheimdienst> Axman6: he's gone ...
05:17:30 <Axman6> i know, that was the point
05:29:43 <Twey> Hey, don't we have a ‘mod’ defined on reals somewhere?
05:31:03 <Ke> you mean x - ceil(x/y)
05:31:19 <Ke> you mean x - ceil(x/y)*Y
05:31:54 <int-e> > properFraction pi
05:31:55 <lambdabot>   (3,0.14159265358979312)
05:32:54 <Ke> hmm actually would be floor
05:32:56 <Twey> Yeah, that one — such that f 3.5 2 = 1.5
05:33:53 <int-e> > floor 3.5 / 2 -- *ducks*
05:33:55 <lambdabot>   Ambiguous type variable `b' in the constraints:
05:33:55 <lambdabot>    `GHC.Real.Integral b'
05:33:55 <lambdabot>   ...
05:34:19 <int-e> true. but you get the idea :)
05:36:06 <Ke> such operation could give results which are all error and no precision
05:36:53 <Axman6> > let fmod x y = f (abs x) (abs y) where f x y = if x > y then f (x-y) y else x in fmod 3.5 2
05:36:53 <lambdabot>   1.5
05:37:02 <Axman6> i'm sure that's completely wrong though
05:37:03 <int-e> Ke: true, but that already holds for + and -.
05:37:08 <Axman6> > let fmod x y = f (abs x) (abs y) where f x y = if x > y then f (x-y) y else x in fmod pi e
05:37:12 <lambdabot>   mueval-core: Time limit exceeded
05:37:21 <Axman6> > let fmod x y = f (abs x) (abs y) where f x y = if x > y then f (x-y) y else x in fmod pi 3
05:37:22 <lambdabot>   0.14159265358979312
05:37:37 <Axman6> hm.... that e was supposed to be 3
05:37:46 * hackagebot lhs2TeX-hl 0.1.4.1 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.4.1 (AlessandroVermeulen)
05:37:55 <Twey> > e
05:37:56 <lambdabot>   e
05:38:09 <Twey> > e > 3
05:38:10 <lambdabot>   True
05:38:12 <Twey> > e < 3
05:38:13 <lambdabot>   False
05:38:18 <Twey> Oh, it actually is e
05:38:24 <Twey> Wait
05:38:28 <Twey> No, that's backwards
05:38:29 <Entroacceptor> > e + 1
05:38:30 <lambdabot>   e + 1
05:38:31 <Twey> What the heck?
05:38:32 <engla> > e**2
05:38:34 <lambdabot>   e**2
05:38:36 <Twey> Why is it > 3?  xD
05:38:39 <engla> it's an expr
05:38:43 <Axman6> :t e
05:38:44 <lambdabot> Expr
05:38:47 <Twey> I get that
05:38:51 <Twey> > e > 3
05:38:52 <lambdabot>   True
05:38:57 <Twey> ↑ I don't get that
05:39:00 <int-e> @type e
05:39:01 <lambdabot> Expr
05:39:11 <int-e> Expr has a weird order.
05:39:12 <Twey> > (e - 5000000) > 3
05:39:13 <lambdabot>   True
05:39:16 <engla> > toRational e
05:39:16 <lambdabot>   *Exception: not a number
05:39:22 <int-e> > exp 1
05:39:22 <lambdabot>   2.718281828459045
05:39:23 <Twey> I guess > is always true, < is always false?
05:39:26 <int-e> > exp 1 < 3
05:39:27 <lambdabot>   True
05:39:58 <int-e> > (a < b, b < a)
05:39:59 <lambdabot>   (True,False)
05:40:14 <engla> > [a..e]
05:40:15 <lambdabot>   *Exception: not a number
05:40:52 <int-e> consequently: e < f and also e < x -- it's just comparing the names
05:40:54 <portnov> hi all.
05:40:58 <Philonous> > exp e
05:40:59 <lambdabot>   exp e
05:41:06 <Twey> Makes sense within exprs
05:41:15 <Twey> Not so much the interpretation of 3
05:41:16 <Axman6> 'lo portnov
05:41:17 <Twey> > 3 :: Expr
05:41:18 <lambdabot>   3
05:41:25 <portnov> any thoughts about using Network.Socket.connect with IPv6 sockets?
05:41:31 <int-e> > e^4 == e*e*e*e
05:41:32 <lambdabot>   False
05:41:36 <portnov> currently it's saying «invalid argument» :/
05:41:38 <int-e> Twey: sort of :)
05:41:46 <int-e> > e^4
05:41:47 <lambdabot>   e * e * (e * e)
05:41:59 <Twey> > e ^ 4 == e * e * (e * e)
05:42:00 <lambdabot>   True
05:42:05 <Twey> … right then
05:42:22 <Philonous> > (1 :: Expr) + 1
05:42:23 <lambdabot>   1 + 1
05:43:10 <int-e> > (e > 0, -e > 0) -- and so on.
05:43:11 <lambdabot>   (True,True)
05:43:44 <Axman6> > a == b
05:43:45 <lambdabot>   False
05:43:54 <Axman6> > e == f
05:43:56 <lambdabot>   False
05:43:59 <Axman6> > e == e
05:44:00 <lambdabot>   True
05:44:01 <Philonous> >compare e (-e)
05:44:08 <Philonous> > compare e (-e)
05:44:09 <lambdabot>   LT
05:44:17 <Twey> x.x
05:45:04 <Philonous> > negate (-e)
05:45:05 <lambdabot>   negate (negate e)
05:45:26 <Philonous> > compare e (negate (-e))
05:45:27 <lambdabot>   LT
05:45:41 <erus`> > e
05:45:42 <lambdabot>   e
05:45:50 <erus`> wdf
05:45:55 <erus`> term re-writing?
05:46:04 <erus`> :t e
05:46:05 <lambdabot> Expr
05:46:15 <Axman6> it's just SimplReflect magic
05:46:22 <Axman6> or whatever it's called
05:46:35 <Axman6> > read e
05:46:36 <lambdabot>   Couldn't match expected type `GHC.Base.String'
05:46:36 <lambdabot>         against inferred typ...
05:46:40 <Axman6> bleh
05:46:56 <Axman6> > "test" == e
05:46:57 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:46:58 <lambdabot>         against inferred ty...
05:47:03 <Axman6> >_<
05:47:46 * hackagebot lhs2TeX-hl 0.1.4.2 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.4.2 (AlessandroVermeulen)
05:47:55 <Axman6> > e ^ e
05:47:59 <lambdabot>   mueval-core: Time limit exceeded
05:48:18 <int-e> http://hackage.haskell.org/packages/archive/simple-reflect/0.2/doc/html/src/Debug-SimpleReflect-Expr.html ... fun code.
05:49:02 <erus`> > e / 2 == e * 0.5
05:49:04 <lambdabot>   False
05:57:47 * hackagebot lhs2TeX-hl 0.1.4.3 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.4.3 (AlessandroVermeulen)
05:57:49 * hackagebot avahi 0.1.1 - Minimal DBus bindings for Avahi daemon (http://avahi.org)  http://hackage.haskell.org/package/avahi-0.1.1 (IlyaPortnov)
05:57:51 * hackagebot BiobaseXNA 0.5.5.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.5.5.0 (ChristianHoener)
06:07:49 * hackagebot lhs2TeX-hl 0.1.4.4 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.4.4 (AlessandroVermeulen)
06:11:15 <strake> @pl CallbackMT $ λ g →  (liftM · liftM) f $ runCallbackMT ma g
06:11:15 <lambdabot> (line 1, column 15):
06:11:15 <lambdabot> unexpected "\187"
06:11:16 <lambdabot> expecting letter or digit, variable, "(", operator, "$", "$!", "`seq`" or end of input
06:11:37 <strake> @pl CallbackMT $ \ g -> (liftM . liftM) f $ runCallbackMT ma g
06:11:37 <lambdabot> CallbackMT (fmap (fmap f) . runCallbackMT ma)
06:11:54 <strake> @pl \ f ma -> CallbackMT $ \ g -> (liftM . liftM) f $ runCallbackMT ma g
06:11:55 <lambdabot> (CallbackMT .) . (. runCallbackMT) . (.) . fmap . fmap
06:12:43 <strake> @pl \ ma f -> CallbackMT $ λ g →  liftM (>>= f) $ runCallbackMT ma g
06:12:43 <lambdabot> (line 1, column 25):
06:12:43 <lambdabot> unexpected "\187"
06:12:44 <lambdabot> expecting letter or digit, variable, "(", operator, "$", "$!", "`seq`" or end of input
06:12:52 <strake> @pl \ ma f -> CallbackMT $ \ g -> liftM (>>= f) $ runCallbackMT ma g
06:12:52 <lambdabot> (CallbackMT .) . flip ((.) . fmap . (=<<)) . runCallbackMT
06:12:54 <ion> (CallbackMT .) . (. runCallbackMT) . (.) . (.) . (.)
06:14:59 <strake> @pl \ ma = CallbackMT $ λ _ →  return ma
06:14:59 <lambdabot> (line 1, column 6):
06:15:00 <lambdabot> unexpected "="
06:15:00 <lambdabot> expecting operator, pattern or "->"
06:15:05 <strake> @pl \ ma = CallbackMT $ \ _ -> return ma
06:15:05 <lambdabot> (line 1, column 6):
06:15:05 <lambdabot> unexpected "="
06:15:05 <lambdabot> expecting operator, pattern or "->"
06:15:11 <strake> @pl \ ma -> CallbackMT $ \ _ -> return ma
06:15:11 <lambdabot> CallbackMT . const . return
06:15:43 <ion> It works in private, too.
06:15:49 <strake> oh
06:15:59 <strake> I thought the '@' did that
06:16:07 <strake> sorry
06:16:29 <strake> thanks
06:37:49 * hackagebot pointless-rewrite 0.0.2 - Pointless Rewrite library  http://hackage.haskell.org/package/pointless-rewrite-0.0.2 (HugoPacheco)
06:45:07 <koeien> I'd like to use a Float -> Double. is the best way via Rational ?
06:45:20 <ion> @type realToFrac
06:45:21 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
06:45:56 <koeien> ty. that works.
06:49:54 <quicksilver> @quote realToFrac
06:49:54 <lambdabot> No quotes match. :(
06:50:08 <quicksilver> lambdabot: it's really shame no one ever thought to backup your database, you know
06:50:18 <Axman6> @check \x -> realToFrac (realToFrac x :: Double) == (x :: Float)
06:50:19 <lambdabot>   "OK, passed 500 tests."
06:50:31 <Axman6> @check \x -> realToFrac (realToFrac x :: Double) == (x :: Double)
06:50:32 <lambdabot>   "OK, passed 500 tests."
06:50:39 <Axman6> @check \x -> realToFrac (realToFrac x :: Float) == (x :: Double)
06:50:40 <lambdabot>   "Falsifiable, after 3 tests:\n-1.4\n"
06:50:56 <koeien> yeah obviously that's not injective
06:51:12 <Axman6> indeed
06:51:37 <koeien> I'd use Double everywhere, but my input format has 32-bit floating point numbers
07:00:43 <whald> hmm, i've got a syntax question regarding let bindings in "do" pasted here: http://hpaste.org/52613 -- can anyone tell me how to get the second variant working?
07:01:59 <erus`> whald: remove the first do
07:02:17 <erus`> i didnt think you could let _ in _ inside a do anyway...?
07:02:24 <quicksilver> whald: your "let in" doesn't really belong inside a do
07:02:33 <quicksilver> and you've confused it with the indentation
07:02:35 <whald> erus`: i can't, because "stuff" is actually usedf
07:03:05 <quicksilver> whald: indent the 'in' by one more space will fix it
07:03:13 <erus`> let a = 54 <newline> return bar
07:03:13 <quicksilver> whald: however we don't normally use 'in' in a do
07:03:17 <ClaudiusMaximus> > pi `mod'` exp 1
07:03:18 <lambdabot>   0.423310825130748
07:03:40 <whald> quicksilver: I see that the style could use some polishing, but i can write it down with "dead" if, so shouldn't it be possible without the if as well?
07:03:53 <quicksilver> whald: inside the else you are in expression context so that's fine
07:04:01 <quicksilver> whald: inside the do you're in do-statement context
07:04:03 <quicksilver> so that parses as
07:04:13 <quicksilver> do {let a=54; in do return bar }
07:04:23 <quicksilver> which is a syntax error, "in" cannot start a statement
07:04:51 <quicksilver> (the strange error message you get is because the syntax error invokes a fallback in the grammer to insert a closing } and try again)
07:05:08 <erus`> @undo { let a = 123; return a }
07:05:08 <lambdabot>  Parse error at "{" (column 1)
07:05:15 <erus`> @undo do { let a = 123; return a }
07:05:15 <lambdabot>  Parse error at "}" (column 28)
07:05:20 <quicksilver> in fact it gets reparsed as:
07:05:24 <erus`> @undo do { let a = 123; return a; }
07:05:24 <lambdabot>  Parse error at ";" (column 27)
07:05:27 <ion> @undo do { let { a = 123 }; return a }
07:05:27 <lambdabot> let { a = 123} in return a
07:05:32 <quicksilver> do {let a=54;} in do return bar
07:05:41 <whald> quicksilver: indenting the "in" really helps, thanks a lot! I'll split the "let" part into a separate function if it actually produces the expected result now :-)
07:05:44 <quicksilver> and *that* is an error because you can't have a 'let' as the last thing in the do.
07:05:57 <quicksilver> whald: the best thing is to learn that the do-form of let
07:06:06 <quicksilver> whald: in a do block you don't bother with the 'in'
07:06:11 <quicksilver> whald: (this is what erus` is trying to show you)
07:06:33 <erus`> @undo do { let {a = 123}; something a; let {b = 321}; return $ somethingelse a b  }
07:06:33 <lambdabot> let { a = 123} in something a >> let { b = 321} in return $ somethingelse a b
07:06:39 <quicksilver> I explained why you get the error you get in case you were curious :)
07:06:42 <frerich> quicksilver: Do you work on ghc, or how comes you are so familiar with things like fallbacks in the grammar of the compiler? I think it's an interesting explanation (it didn't occur to me that there are such two different grammar contexts) but I wonder where you learned this stuff from :-)
07:06:55 <quicksilver> frerich: I haven't ever worked on ghc, no.
07:06:56 <frerich> Seems very subtle to me.
07:07:09 <quicksilver> but I've followed various debates on how haskell is parsed over the years
07:07:26 <whald> quicksilver: but I would have to write lots of "lets" then (which is likely because of bad style on my side, I still struggle at the border between monadic and pure code)
07:07:26 <frerich> But your own Haskell comp... ah, ok, I see.
07:07:59 <quicksilver> "A close brace is also inserted whenever the syntactic category containing the layout list ends; that is, if an illegal lexeme is encountered at a point where a close brace would be legal, a close brace is inserted"
07:08:12 <quicksilver> frerich: (from http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7)
07:08:15 <quicksilver> whald: no, you wouldn't.
07:08:21 <quicksilver> whald: you'd have to write exactly as many as you do now
07:08:29 <quicksilver> whald: but you'd write many fewer 'in's :)
07:08:36 <quicksilver> the only difference is you omit the in.
07:08:41 <quicksilver> and continue the indentation
07:08:45 <quicksilver> (so you get less indentation creep)
07:09:34 <whald> quicksilver: uhm, the I'v got the let-in-do syntax completely screwed in my mind
07:10:23 <erus`> haha yes you have
07:10:47 <whald> :-)
07:15:24 <sm> morning all. I want to parse multiple successive xml documents (rss/atom feeds) streaming in on stdin, any tips ?
07:16:17 <sm> currently using xml and feed libs and wondering if I can adapt them to streaming in a robust way
07:17:33 <whald> quicksilver: ehm, "the only difference is you omit the in. and continue the indentation (quicksilver)" was just printed out and pinned to the wall.
07:18:14 <sm> I guess I can read input up to </feed> or </rss> and parse that as a string
07:19:18 <whald> sm: I find Parsec very convient to use, but I guess there's something specialized on XML on hackage as well
07:19:46 <quicksilver> I think sm's question is about separating the parts of the stream
07:20:09 <quicksilver> sm: haxml has a stream parser
07:20:28 <quicksilver> sm: and there is also http://hackage.haskell.org/package/xml-enumerator which I have never tried.
07:33:09 <sm> whald, quicksilver: thanks. The feed package is specialised to xml-light which restricts me a bit, I'll check that out
07:48:31 <td123> any ops in here?
07:48:41 <quicksilver> td123: what's up?
07:48:57 <td123> "(9:55:31 AM) qawdgj:  ::::::::::::::::> WWW.MEGA-HD.ORG <:::::::::::::::: {{{{{{{{{{ The best High Definition movies, videos, programs }}}}}}}}}} "
07:49:15 <td123> he's probably a spam bot
07:49:41 <quicksilver> thanks.
07:49:45 --- mode: ChanServ set +o quicksilver
07:49:52 --- mode: quicksilver set +b *!*qawdgj@*.bbccable.net
07:49:52 --- kick: qawdgj was kicked by quicksilver (qawdgj)
07:50:46 <td123> thanks
07:52:50 * hackagebot cpphs 1.13.2 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.13.2 (MalcolmWallace)
07:57:06 <thoughtpolice> copumpkin: re ghc bug 5556, that's a good ticket. i was going to bring it up yesterday when you mentioned the pinning thing for my nacl bindings. choosing to pin or unpin would be very useful indeed
07:58:10 <thoughtpolice> (the GC fragmentation issue is the first thing that came to my mind, and i don't want to assume people either will/will not potentially be dealing with many secret keys in practice
08:06:30 <erus`> in chatzilla that links to this https://bugzilla.mozilla.org/show_bug.cgi?id=5556
08:06:36 <erus`> a 12 year old bug
08:08:36 <shirt> erus`: http://hackage.haskell.org/trac/ghc/ticket/5556
08:12:35 <ketil> Ah, found what I think is my performance bug.
08:12:35 <lambdabot> ketil: You have 1 new message. '/msg lambdabot @messages' to read it.
08:12:51 <ketil> great to end the working week with something that shows me how incredibly dumb I am.
08:13:33 <ketil> dmwit, and thanks, I realized that (/=) == xor for Bool after a bit of thought.
08:13:53 * ketil may be dumb, but not /that/ dumb.
08:13:54 <ketil> :-)
08:14:14 <ion> Also, + and - are xor if you use booleans as a mod-2 algebra. :-)
08:15:05 <ion> (ab)use
08:15:58 <Twey> ketil: I know, right?  That shocked me when I first considered it :þ
08:17:12 <ketil> ion: No instance Num, I think.
08:17:16 <ketil> > True + False
08:17:17 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
08:17:18 <lambdabot>    arising from a use of `GHC.N...
08:17:20 <ion> Easy enough to implement. :-P
08:17:58 <dmwit> ?src liftM
08:17:58 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:18:20 <ketil> Just goes to show how limiting a classical education can be.
08:18:30 <byorgey> @undo do { x1 <- m1; return (f x1) }
08:18:30 <lambdabot> m1 >>= \ x1 -> return (f x1)
08:18:39 <ketil> 2011-10-14 15:20:15.286186 UTC  done!   0.880475s
08:18:47 <byorgey> @. pl undo do { x1 <- m1; return (f x1) }
08:18:47 <lambdabot> f `fmap` m1
08:18:49 <copumpkin> thoughtpolice: yeah, but for that it seems like you'd want to say something stronger like "all memory allocated after this point should be pinned, in this mlocked part of memory" and then exit that critical part
08:18:53 <ketil> Hah.  Down from ...oh, I don't know, hundreds or thousands of seconds.
08:19:07 <byorgey> ketil: nice =)
08:19:08 <simpler> hello
08:19:09 <copumpkin> thoughtpolice: maybe we should have a feature request ticket for that too :)
08:19:17 <byorgey> welcome simpler
08:19:33 <byorgey> simpler: trying some Haskell?
08:19:33 <simpler> can you tell me what you will use Haskell for?
08:19:41 <ketil> byorgey, Heh, I'm afraid it was the previous version that was rather non-nice.  But at least it's an improvement.
08:19:49 <simpler> yeah im trying to figure out what it's for
08:19:56 <byorgey> simpler: everything and anything.  It is a general purpose language.
08:20:01 <ion> (\x -> return (f x)) =<< m = join (return . f <$> m) = f <$> m
08:20:07 <thoughtpolice> copumpkin: yeah. although actually thinking about it, that's probably more necessary than the pin/unpin primitive - i'll *always* want them pinned so there's no point in a dynamic choice. make secret key -> pinned BA# -> mlock.
08:20:11 <dmwit> ?src ($)
08:20:11 <lambdabot> f $ x = f x
08:20:12 <simpler> oh
08:20:45 <tac-tics> simpler: Haskell is especially useful for learning new functional techniques in programming
08:20:51 <ketil> Well, it's /for/ programming anything, but I guess it is more /suitable/ to certain things than others.
08:20:53 <tac-tics> simpler: And new ways to think of old things.
08:21:04 <simpler> it seems pretty cool
08:21:16 <thoughtpolice> copumpkin: yeah, i may have to hack something with the FFI, I'm not sure. it would be pretty badass to have a 'createPinnedLockedByteArray' - dunno if windows has any sort of equivalent
08:21:17 <tac-tics> simpler: Functional programming languages, in particular, are unbeatable when it comes to programming compilers
08:21:20 <ketil> Good for mind-expansion, and humiliation.
08:21:36 <copumpkin> thoughtpolice: well, I meant for a more global thing because you want to ensure that none of your dependent calls secretly stash away stuff in unlocked memory, either
08:21:40 <tac-tics> simpler: Haskell is also very well suited for concurrency
08:21:42 <byorgey> simpler: it is used for everything from writing compilers to controlling large trucks to handling financial data to generating graphics.
08:21:42 <copumpkin> thoughtpolice: say you read the key from an encrypted file
08:22:01 <copumpkin> thoughtpolice: you don't want that read call to secretly stash stuff behind your back
08:22:21 <copumpkin> I guess it'd be nice to have designated allocation regions (that can be locked) that you could blast in a single go
08:22:30 <thoughtpolice> copumpkin: that's what i was thinking
08:22:42 <byorgey> simpler: it is very cool.  =)  Feel free to ask questions in here as you are learning it.  We are generally a helpful bunch.
08:22:43 <copumpkin> but it's completely impure
08:22:48 <copumpkin> so you'd need to do that on a per-thread basis
08:23:23 <simpler> thanks a lot :)
08:23:34 <byorgey> ketil: the improvement is objectively nice, regardless of the status of the previous and current versions. =)
08:27:14 <dmwit> byorgey: By the way, next time you see me you are welcome to an "I told you so" moment. =)
08:27:28 <dmwit> (For laughing at you when you said superclass equality constraints were useful.)
08:27:30 <hirsch_> Is there something like erlang's OTP behaviours in haskell? A design pattern for common tasks.
08:27:41 <byorgey> dmwit: re: superclass equality constraints?
08:27:44 <byorgey> ok =)
08:28:06 <hpc> hirsch_: OTP?
08:28:07 * byorgey promises not to rub it in TOO much
08:28:11 <dmwit> I've used them in every single piece of Haskell I've written since I learned about them.
08:28:14 <dmwit> =D
08:28:15 <byorgey> hahaha
08:28:56 <dolio> They're awesome.
08:28:56 <hirsch_> hcp: http://www.erlang.org/doc/design_principles/des_princ.html
08:29:04 <hpc> superclass equality constraints?
08:29:05 <quicksilver> is "instance (a~b) => Monoid (a->b)" legal now we have explicit equality constraints?
08:29:22 <dmwit> quicksilver: In GHC 7.3, yes; 7.2, no.
08:29:35 <quicksilver> interesting.
08:29:43 <byorgey> "now that I know about it, I can't live without it!" -- pretty much applies to every GHC extension, except IncoherentInstances and ImplicitParameters
08:29:50 <dolio> That's an instance constraint. That should have been working.
08:30:00 <dmwit> hpc: See quicksilver's instance there.
08:30:05 <hpc> ah
08:30:12 <dmwit> hpc: It's a superclass constraint which is an equality.
08:30:12 <hpc> oh
08:30:17 <hpc> i want it
08:30:21 <dolio> Superclass equality constraints are where you put that on a 'class' definition.
08:30:25 <dmwit> ah
08:30:28 <quicksilver> byorgey: I hope it doesn't apply to OverlappingInstances
08:30:30 <byorgey> dolio is right, I think
08:30:31 <dmwit> Okay, I could be using the term incorrectly, then.
08:30:47 <quicksilver> byorgey: or RecordPuns....
08:30:55 * hpc is still using 6.12
08:31:04 <dolio> Are they not working in 7.2?
08:31:04 <dolio> I thought they were.
08:31:09 <byorgey> quicksilver: naturally, I was indulging in a bit of hyperbole =)
08:31:10 <dmwit> could be
08:31:18 <dolio> Or is 7.4 now the target?
08:31:30 <dolio> I can't keep track; they keep delaying it.
08:31:50 <benmachine> byorgey: a bit? you were indulging in more hyperbole than everyone else in the world put together
08:31:53 <byorgey> I doubt they are in 7.2, the implementation depends on the new ConstraintKind stuff which is not in 7.2
08:32:00 <dmwit> Well, I had code that gave the "I don't know how to do superclass equality constraints" error in 7.2, but that code works in 7.3.
08:32:03 <dolio> Oh really?
08:32:29 <copumpkin> why would it depend on the constraintkind stuff?
08:32:36 <dolio> So they were just fooling themselves that they could actually implement it before the constraint kind stuff?
08:32:37 <byorgey> rather, the addition of ConstraintKinds suddenly made superclass equality constraints trivial
08:32:42 <copumpkin> oh
08:32:43 <dolio> Oh.
08:32:49 <benmachine> I never really understood instance heads with duplicated type variables in them, they seem complicated
08:32:50 * hackagebot digestive-functors-blaze 0.2.0.0 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.2.0.0 (JasperVanDerJeugt)
08:32:52 * hackagebot simpleprelude 1.0.1.0 - A simplified Haskell prelude for teaching  http://hackage.haskell.org/package/simpleprelude-1.0.1.0 (JeanMarieGaillourdet)
08:32:53 <byorgey> it would have been messier before.
08:32:59 <benmachine> (a ~ b) => (a -> b) seems like a more natural formulation
08:33:24 <thoughtpolice> copumpkin: hm, yeah, there are several concerns to be had. pretty much everything allocated in some scope would need to be locked to ensure no leaking of secret info. i could just hack ghc to say mlockall :P
08:33:29 <Saizan> benmachine: try prolog for a while :)
08:33:33 <byorgey> benmachine: it's just unification
08:33:42 <copumpkin> thoughtpolice: sounds awesome :P
08:33:52 <quicksilver> it certainly seemed a surprising contrast to function definitions where you aren't allowed to repeat variables... but that's not that surprising, because function definitions are really quite different from instance heads.
08:33:53 <thoughtpolice> copumpkin: that would also have the benefit i don't have to mass FFI everything. :P
08:34:07 <dmwit> quicksilver: By the way, your ops are showing if you care.
08:34:15 <copumpkin> Igloo too
08:34:24 <copumpkin> was there a mass trolling session going on in here?
08:34:38 <dmwit> Your ops are showing if you don't care, too, I suppose.
08:34:39 <dolio> Miranda allowed repeated variables on function definitions. :)
08:35:34 <gwern> hm... my language is failing me. what does a garbage collector reclaim? it's not 'cells', because that's biological; 'memory' is a bit vague; 'nodes' doesn't seem right either
08:35:54 <tac-tics> mallocs? objects? garbage?
08:35:56 <gwern> 'elements' makes it sound like chemistry
08:36:01 <gwern> tac-tics: ah, objects, that should work
08:36:06 <dmwit> blocks?
08:36:07 <hpc> gwern: it reclaims areas of memory
08:37:29 <copumpkin> regions, in some cases
08:38:01 <byorgey> dolio: really?  it had built-in magic polymorphic equality, eh?
08:39:09 <dolio> byorgey: I don't think so. I don't know how it handled equality, though. It didn't have type classes, right?
08:39:21 <byorgey> right, it didn't
08:39:42 <byorgey> I'm just wondering what happened if you defined  f x x = x  and called  f 3 4 ?
08:40:01 * byorgey doesn't know very much about Miranda
08:40:03 <dolio> Inexhaustive match error.
08:40:39 <byorgey> right, I'm just wondering how it could tell.  Presumably f would be polymorphic and could be called on, say, functions.
08:41:17 <hpc> what if you called f x x with f (Just 3) (Just 2)?
08:41:32 <hpc> how does it decide equality?
08:45:59 <dolio> I'm having trouble finding anything that clears this up.
08:46:22 <dolio> Apparently they have = as syntax for the equality decision procedure, though.
08:46:44 <quicksilver> gwern: in GHC in particular they are normally called 'heap objects'
08:47:04 <quicksilver> dmwit: I've never really understood this convention of not showing ops, but since I'm in Rome
08:47:05 <gwern> quicksilver: I don't need to be technically precise, I just needed something whih sounded right and had two syllables
08:47:06 * byorgey can't find anything either, just lots of claims that Miranda supported nonlinear patterns, but no explanation of how it worked
08:47:07 --- mode: quicksilver set -o quicksilver
08:47:18 <quicksilver> gwern++ # poet
08:47:28 <gwern> quicksilver: I am actually
08:47:34 <quicksilver> byorgey: miranda was proprietary so it was illegal to discuss how it worked.
08:47:43 <quicksilver> it was permitted to give thanks.
08:47:47 * gwern would call himself an amateur poet, but no poet can live off his poetry these days so it's not like there's any more distinction
08:47:47 <byorgey> good point.
08:47:57 <dolio> byorgey: I'm pretty sure it would just desugar to guards with = like we'd do in Haskell, but I don't know how = works.
08:48:21 <byorgey> dolio: right, that's what I'm curious about.
08:48:22 <dolio> Maybe type-directed overloading?
08:48:35 <mrakan> Is there a way documentation can be associated with a function and then accessed within ghci?
08:48:38 <quicksilver> gwern: you can I think make a case for rappers (assuming they don't get someone else to write the stuff) being professional poets, but it would be off-topic to make that case.
08:48:41 <dolio> With forced monomorphization.
08:48:57 <tsousa>  http://dpaste.com/634432/ is this code How does the type List know before it's declared the type list ?
08:48:59 <quicksilver> mrakan: no, although it is a good idea which is suggested from time to time.
08:49:08 <gwern> quicksilver: musicians and singers have always had lyrics in most every culture, and musicians and singers are still a different word from poet
08:49:22 <gwern> quicksilver: not that music is a really lucrative field these days either
08:49:38 <dolio> byorgey: Oh, found it.
08:49:43 <dolio> They are polymorphic.
08:50:14 <byorgey> mrakan: you can associate documentation with a function using Haddock.  I don't know of a way to access it from within ghci, sadly.
08:50:18 <byorgey> @where haddock
08:50:18 <lambdabot> http://www.haskell.org/haddock/
08:50:26 <byorgey> dolio: link?
08:51:06 <dolio> http://www.cs.kent.ac.uk/people/staff/dat/miranda/nancypaper.pdf
08:51:14 <dolio> Page 8.
08:51:40 <tsousa> can someone please help me?
08:52:20 <Saizan> tsousa: i didn't understand your question, can you rephrase?
08:52:34 <quicksilver> tsousa: because the code is understood as a whole.
08:52:44 <dolio> Miranda apparently has some sort of quotient type, too.
08:52:47 <quicksilver> tsousa: haskell supports type and value recursion fundamentally.
08:52:54 <mrakan> I've been told a function to detect whether a string is a palindrome (equal to its reversed self) can be written as (join ((==).reverse)), but am having trouble understanding it or even running it. Is it valid?
08:53:13 <quicksilver> > join ((==).reverse) "madam"
08:53:15 <lambdabot>   True
08:53:29 <mrakan> My goodness. :))
08:53:59 <tsousa> quicksilver, i am not understanding why we need a recursion type on that one
08:54:09 <mrakan> What do I need to import in order for it to run within ghci? It complains that a (Monad ((->) String)) instance is not available.
08:54:40 <Saizan> Control.Monad.Instances
08:54:45 <quicksilver> mrakan: 'join' is a polymorphic function. In the specific case of the monad there, join is a higher order function which takes a 2-arg function and runs it with a single argument, by using it twice.
08:54:52 <quicksilver> > join (*) 3
08:54:52 <lambdabot>   9
08:55:05 <applicative> tsousa, data BrokenList a = Nil | Cons a a wouldn't be much fun
08:55:09 <quicksilver> tsousa: because the definition of List is recursive.
08:55:11 <ion> @type join
08:55:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:55:20 <mrakan> Saizan and quicksilver: Ah, I see now. Thanks!
08:55:28 <ion> mrakan: Imagine the m as ‘z →’.
08:55:51 <tsousa> quicksilver, what does Cons do?
08:55:52 <ion> (z → (z → a)) → z → a
08:56:04 <ion> @type join `asAppliedTo` (undefined :: a -> b)
08:56:05 <quicksilver> tsousa: it is the name of a constructor.
08:56:05 <Nimatek> Which join is that? Surely not the Control.Monad one?
08:56:05 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
08:56:13 <quicksilver> it is being defined in that line
08:56:16 <ion> @djinn (z -> z -> a) -> z -> a
08:56:17 <lambdabot> f a b = a b b
08:56:20 <mrakan> ion: Ah, that's a very good way of seeing it. Thanks!
08:56:21 <byorgey> Nimatek: the same.
08:56:35 <quicksilver> tsousa: that line of code defines one type 'List', and two constructors 'Empty' and 'Cons'.
08:56:36 <Nimatek> Hm.
08:56:39 <ion> mrakan: http://heh.fi/haskell/functors/#function-instance
08:56:44 <Nimatek> GHCi disagrees with that use of join.
08:56:53 <byorgey> Nimatek: disagrees how?
08:57:00 <quicksilver> tsousa: if you are unfamiliar with how type definitions work, you might want to tackle a non-recursive one before worrying about recursive ones.
08:57:00 <applicative> tsousa, if you just think of the type definition as introducing a bunch of expressions, Nil, Cons True Nil, Cons False Nil, Cons True (Cons True Nil) etc. then is there a problem?
08:57:04 <byorgey> Nimatek: note you must import Control.Monad.Instances
08:57:04 <tsousa> quicksilver, the type declarations means or the list or Empty or it has a value that Cons put into it right?
08:57:39 <hpaste> N pasted “join ghci” at http://hpaste.org/52614
08:57:47 <Nimatek> ↑
08:58:08 <byorgey> Nimatek: yes, you must first  :m +Control.Monad.Instances
08:58:17 <Nimatek> Ah.
08:58:23 <byorgey> Nimatek: that module constains precisely the Monad instance it is complaining about
08:58:39 <Nimatek> Thanks, byorgey.
08:59:00 <dmwit> tsousa: Yes. But the Cons has not just a value, but also the rest of the list.
08:59:15 <tsousa> yes
08:59:25 <dmwit> And "the rest of the list" is the recursive part.
09:00:37 <ion> (Control.Applicative imports Control.Monad.Instances as well.)
09:00:53 <tsousa> dmwit, ok i think i am getting it
09:00:55 <byorgey> ion: ah, does it? that's nice.
09:08:50 <mrakan> Does anyone know where I can see the source of the Monad ((->) r) instance definition?
09:09:02 <copumpkin> Control.Monad.Instances probably
09:09:09 <copumpkin> not sure where it actually lives
09:09:16 <copumpkin> it'd be nice if haddock gave us locations of instances
09:09:18 <mrakan> Or, right, found it. Thanks.
09:09:39 <applicative> http://www.haskell.org/ghc/docs/7.0.3/html/libraries/base-4.3.1.0/src/Control-Monad-Instances.html
09:09:52 <ion> And Control.Applicative has the Applicative instance.
09:10:22 <ion> The instance definitions are the only ones that make sense given the types.
09:11:45 <applicative> still, the Applicative instance is sublime, pure = const; (<*>) f g x = f x (g x)
09:12:34 <ion> @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
09:12:35 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
09:12:47 <ion> @djinn (<*>) :: (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
09:12:48 <lambdabot> Cannot parse command
09:12:49 <hpc> mrakan: one definition of the monad would be to take the applicative instance, fmap = (.), and join f x = f x x
09:12:53 <ion> @djinn (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
09:12:53 <lambdabot> f a b c = a c (b c)
09:13:20 <hpc> (the fmap-join-return definition of a monad)
09:15:24 <companion_cube> it's the "S" combinator, right?
09:15:35 <ion> yep
09:15:59 <applicative> join op x = x `op` x is much sublimer than (f >>= k) r =  k (f r) r
09:16:02 <cicatristeza> kmc: you're quite popular on pinboard, ya know?
09:20:51 <kate__r> is (P --> Q) & (R --> S) equivalent to (P & R --> Q & S)?
09:21:12 <opqdonut> no
09:21:14 <copumpkin> you can derive one from the other, but not vice versa
09:21:21 <opqdonut> right
09:22:17 <opqdonut> think P=S, Q=R=True
09:22:23 <copumpkin> @djinn (p -> q, r -> s) -> (p, r) -> (q, s)
09:22:23 <lambdabot> f (a, b) (c, d) = (a c, b d)
09:22:34 <copumpkin> @djinn ((p, r) -> (q, s)) -> (p -> q, r -> s)
09:22:35 <lambdabot> -- f cannot be realized.
09:24:56 <hpc> @djinn ((p, r) -> (q, s)) -> ((p, r) -> q, (p, r) -> s)
09:24:57 <lambdabot> f a =
09:24:57 <lambdabot>     (\ (b, c) ->
09:24:57 <lambdabot>      case a (b, c) of
09:24:57 <lambdabot>      (d, _) -> d,
09:24:57 <lambdabot>      \ (e, f) ->
09:24:58 <lambdabot>      case a (e, f) of
09:25:00 <lambdabot>      (_, g) -> g)
09:25:03 <hpc> oh balls
09:26:17 <applicative> kate__r: if S is trivial, 1 = 1, then the question reduces to whether you can get (P->Q)  and  R from (P&R) -> Q , no?  But you can't get R, clearly.
10:02:26 <keep_learning> what is the difference between Data.ByteString.Lazy and Data.ByteString.Lazy.Char8 ?
10:04:22 <copumpkin> the .Char8 versions allow you to plug your ears and pretend that encodings don't exist
10:04:28 <hpaste> “Mukesh Tiwari” pasted “Data.ByteString.Lazy” at http://hpaste.org/52615
10:04:35 <copumpkin> and be western imperialist scum
10:04:41 <keep_learning> i have imported Data.ByteString.Lazy and when i am trying to print some content then its showing me http://hpaste.org/52615
10:04:52 <copumpkin> keep_learning: are you western imperialist scum?
10:06:09 <monochrom> eh? what?
10:06:33 <monochrom> I see, hahaha
10:06:33 <copumpkin> sorry, just being stupid :P
10:06:38 <keep_learning> copumpkin, such a hard word . no i don't think so
10:06:39 <copumpkin> I'm not as opinionated as I sound
10:07:16 <monochrom> context > content
10:08:21 <keep_learning> copumpkin, .Char8 is only for ASCII characters
10:09:01 <monochrom> yes, that's what copumpkin tries to say
10:09:29 <keep_learning> monochrom, thank you but it was very hard to interpret the answer :)
10:10:05 <co_dh> @free (f :: [a] -> b)
10:10:05 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:10:16 <co_dh> @free map
10:10:17 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:10:22 <co_dh> @type map
10:10:23 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:10:26 <monochrom> oh, the interpretation is this: only western imperialist scums think that all bytes must stand for ascii
10:11:08 <co_dh> @free (forall a b. [a] -> b)
10:11:08 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:13:42 <co_dh> @help free
10:13:42 <lambdabot> free <ident>. Generate theorems for free
10:14:26 <byorgey> co_dh: if you want to generate free theorems for a given type, see http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi
10:15:46 <Rc43> Hi, guys.
10:15:56 <Rc43> Tell me what is package.conf, please.
10:15:58 <byorgey> free theorem for f :: [a] -> b  is that   h . f == f . map g
10:16:17 <Rc43> And how it is used by ghc.
10:16:41 <shapr> Rc43: Have you read http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html ?
10:16:53 <co_dh> byorgey: Thanks!
10:17:31 <byorgey> wait, that doesn't make sense
10:17:43 <Rc43> shapr, have seen it while googling, will look on it
10:18:03 <co_dh> @free [a]->[a]
10:18:03 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:19:01 <ClaudiusMaximus> woe, i discover the foolishness of ByteString for text - time to s/ByteString/Text/ in my code base
10:19:12 <byorgey> oh, yes it does.  The only possible implementations of [a] -> b are  undefined  and  const undefined.
10:19:56 <Rc43> shapr, is package.conf is used while compiligng to create object (.o) files?
10:20:41 <Rc43> shapr, i am trying launch `load' from System.Plugins.Load and it has an argument for package.conf files list.
10:21:17 <Rc43> And with [] passed to it I can't execute any function from plugin exceptionally `main'.
10:22:36 <ClaudiusMaximus> https://gitorious.org/hp2pretty/hp2pretty/blobs/master/tests/unicode.hs is my failing test case which makes rsvg abort later; hp2ps also fails (wrong character displayed when viewing output .ps)
10:23:46 <ClaudiusMaximus> though, this could be nightmarish - 'file' says the .hp is ISO-8859
10:27:37 <tom_> Hi, given the following signature: mostCommonSymbol :: String -> Char I want to implement a programm, that gives me the char with the most occurances e.g. mostCommonSymbol "Banana" shell return 'a'. If the word would be "Banan" it would simple print out an error. Can someone help me?
10:29:04 <roconnor> > group . sort $ "Banana"
10:29:06 <lambdabot>   ["B","aaa","nn"]
10:29:22 <roconnor> > sorBy length . group . sort $ "Banana"
10:29:27 <lambdabot>   Not in scope: `sorBy'
10:29:32 <roconnor> > sortBy (comparing length) . group . sort $ "Banana"
10:29:34 <lambdabot>   ["B","nn","aaa"]
10:29:39 <roconnor> pfft
10:31:02 <roconnor> > groupBy (comparing length) . sortBy (flip . comparing $ length) . group . sort $ "Banana"
10:31:03 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
10:31:03 <lambdabot>         against inferred type ...
10:31:14 <roconnor> > groupBy (equating length) . sortBy (flip . comparing $ length) . group . sort $ "Banana"
10:31:15 <lambdabot>   Not in scope: `equating'
10:33:27 <angstrom> > sortBy (flip $ comparing length) . groupBy (==) . sort $ "Banana"
10:33:28 <lambdabot>   ["aaa","nn","B"]
10:33:47 <roconnor> :)
10:33:56 <roconnor> but we need to group by length
10:34:03 <angstrom> I have to do the same assignment, right now >:D
10:34:11 <roconnor> :O
10:34:36 <applicative> I don't think the teacher's going to go for all this point free composition
10:34:59 <tom_> lol nice :d
10:35:04 <angstrom> afaik, the solutions don't get verified manually
10:35:12 <Botje> tell your teacher #haskell says hi ;)
10:35:41 <tom_> angstrom, @vienna?^
10:35:50 <angstrom> tom_: ja
10:35:57 <tom_> :D
10:36:00 <applicative> myfunction xs =  trace "#haskell says hi " $ sortBy (flip $ comparing length) . groupBy (==) . sort $ xs
10:36:11 <Botje> applicative:  :)
10:36:12 <roconnor> :D
10:37:51 <frerich_> Out of curiosity, what is the task? Sort the letters in a string by which one appears most often?
10:38:23 <tom_> Not to sort, just to return the character which appears most often...
10:39:01 <frerich_> Hm, how about 'head . maximumBy (comparing length) . group . sort'?
10:39:12 <frerich_> I like that one for having the 'maximumBy' part, which is kinda suggestive.
10:39:21 <angstrom> ah. didn't know about that :-)
10:41:56 <frerich_> I think maximumBy is in effect 'sortBy . flip' but it never occurred to me.
10:42:09 <frerich_> I only now realized that 'flip . comparing' is a neat trick to reverse the sort order.
10:42:24 <frerich_> roconnor: So thanks for that :)
10:46:17 <roconnor> unfortunately maximumBy wont "return an error" when there is no unique answer
10:53:46 <portnov> anyone worked with DBus from haskell?
10:54:06 <portnov> i can't export some types of methods :/
10:58:08 <cheater_> hi
10:58:37 <hpaste> cheater pasted “can't install haskell-platform” at http://hpaste.org/52616
10:58:59 <cheater_> i am having problems with installing hp, apparently the ghc i just installed can't even compile "hello world"
10:59:36 <cheater_> ah, running ghci shows an error too:
10:59:37 <cheater_> Loading package integer-gmp ... <command line>: can't load .so/.DLL for: gmp (libgmp.so: cannot open shared object file: No such file or directory)
10:59:55 <rwbarton> that error is in the middle of your paste too, "/usr/bin/ld: cannot find -lgmp"
11:00:04 <cheater_> mhm
11:00:36 <rwbarton> apt-get install libgmp3-dev
11:03:41 <cheater_> rwbarton: worked perfectly! thanks!
11:07:35 <monochrom> cheater_: some other C libraries that the Haskell Platform assumes are at my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
11:08:42 <hpaste> “Mukesh Tiwari” pasted “Compiler error” at http://hpaste.org/52617
11:08:54 <cheater_> thanks monochrom!
11:09:28 <keep_learning> Could some one please tell me why i am getting compiler error for this code . http://hpaste.org/52617
11:10:32 <keep_learning> I am trying taking first four bytes and trying to check if its 0xa1 0xb2 0xc3 0xd4 or 0xd4 0xc3 0xb2 0xa1
11:13:16 <monochrom> "Chunk" is probably not exported. you can't use it
11:14:53 <applicative> keep_learning: you can't pattern match on bytestrings .
11:15:13 <monochrom> I would case unpack a of [212, 195, 178, 161] -> print "reverse order of pcap d4c3b2a1"
11:15:47 <rwbarton> (or [0xd4, 0xc3, 0xb2, 0xa1])
11:16:13 <keep_learning> applicative, monochrom rwbarton thank you all
11:19:42 <dolio> I like this guy on the Haskell reddit who 'uses Haskell at work' but doesn't know basic stuff about how evaluation and data structures work in Haskell.
11:20:12 <tac-tics> dolio: Maybe he means he uses "#haskell" at work
11:20:14 <tac-tics> (like me)
11:20:45 <dolio> Like a lot of people here.
11:22:09 <erasmas> if anyone asks, I'm not at work.
11:22:22 <monochrom> evaluation is hard. but data structures?
11:22:23 <dolio> Okay. I'll let your boss know.
11:22:48 <keep_learning> rwbarton, are you Reid Barton from topcoder ?
11:22:59 <dolio> monochrom: I mean stuff like: if you update a tree, you only need to copy the path to where you insert.
11:26:20 <monochrom> to be fair, using python/php/java at work is just as highly correlated as not knowing basic stuff about them
11:26:33 <EvanR-work> js
11:26:39 <monochrom> s/correlated as/correlated with/
11:27:11 <EvanR-work> many people dont know js object fields have no particular ordering
11:28:01 <mauke> many people don't know x.y is equivalent to x['y']
11:31:51 <erasmas> do you think people don't know those things because they learn from tutorials/blogs/random google searches?
11:32:54 <EvanR-work> yes
11:33:02 <joo> And w3schools
11:33:55 <monochrom> even w3schools has some good advice on basic stuff
11:35:13 <monochrom> it is really the worker taking a path of least resistance.
11:35:52 <erasmas> I try to learn by reading books from start to finish, although that can lead people astray too. especially books on javascript
11:35:55 <mauke> in the case of javascript also because there literally is no reference describing how it works
11:36:03 <erus`> guys, i am in a pickle :(
11:36:37 <tac-tics> w3schools on Haskell would be humorous
11:36:45 <monochrom> well, javascript has the ECMA 262 reference, but it is also pretty hard to read. (pretty easy to read for compiler/interpreter implementers, sure)
11:36:56 <mauke> ecmascript != javascript
11:37:16 <EvanR-work> tac-tics: lool
11:37:30 <monochrom> http://dmitrysoshnikov.com/ is a good reference for javascript programmers on how it really works
11:37:57 <Twey> ECMA 262 is pretty friendly, I think
11:38:18 <Twey> If you know some EBNF, it's okay to read
11:38:24 <tac-tics> Except for the fact Javascript is quirky as hell, it's not that bad.
11:38:51 <monochrom> I don't mean the syntax. I mean the dynamic semantics.
11:55:06 <acowley> wasn't there someone working on updating the OpenGL bindings?
12:03:14 <KitB> SpecConstr?
12:03:21 <KitB> Anyone care to explain this strange warning?
12:04:08 <FUZxxl> KitB: Ignore it.
12:04:34 <KitB> FUZxxl: Oh I am, but I'd love to understand what on earth it's actually on about
12:04:36 <FUZxxl> It's caused by some optimizations and is no harm.
12:04:42 <c_wraith> KitB: it's saying it's not applying an optimization that it *could*, if you passed in some different flags.  Why that's a warning at all is baffling
12:04:54 <KitB> It's not actually saying "warning"
12:05:00 <KitB> It's just printing shit out
12:05:07 <c_wraith> well.  why it feels the need to tell you that at all
12:05:10 <c_wraith> is still baffling
12:05:16 <KitB> Indeed
12:05:30 <KitB> I often have this appear hundreds of times when installing stuff from cabal
12:05:33 <FUZxxl> IIRC some optimizations can specialise functions for certain inputs (type constructors).
12:05:49 <Saizan> it's debug information that they forgot to silence for the release :)
12:06:22 <FUZxxl> And if the compiler detects, that the input is always of a specific constructor, it can remove dead code.
12:06:44 <Saizan> (data constructors?)
12:06:55 <KitB> Saizan: It's been persistent across a few releases now D:
12:06:57 <FUZxxl> Eg. If you have the function checkV :: Bool -> a -> Maybe a; checkA p v | p = Just v | otherwise = Nothing
12:07:15 <FUZxxl> If GHC finds out that p == True, always
12:07:28 <FUZxxl> and you have the code fromJust . checkV p xyz
12:07:53 <FUZxxl> It can completely remove this code.
12:08:01 <FUZxxl> I am not completely sure though
12:08:50 <absentia> ruby finds if (0) true ...
12:09:21 <shapr> absentia: Are you writing a Ruby interpreter in Haskell?
12:09:32 <absentia> no, not me.
12:10:09 <FUZxxl> shapr: There is a Perl interpreter written in Haskell (pugs)
12:10:39 <absentia> I thought the firsta and only parrot (? perl6? ...) interpreter was written in haskell (way back when?) ...
12:11:15 <Jeanne-Kamikaze> looks like someone ran into the same problem recently: http://pastebin.com/FfKqgFie
12:11:17 <mauke> The paste FfKqgFie has been copied to http://hpaste.org/52620
12:11:37 <shapr> FUZxxl: Have you tried it?
12:11:48 <Jeanne-Kamikaze> any idea what that error is about :/ ?
12:12:35 <FUZxxl> shapr: No.
12:13:00 <FUZxxl> It was used for the development of Perl 6
12:13:38 <Nafai> shapr: Hey!  ltns!
12:14:00 <shapr> howdy Nafai!
12:15:02 <shapr> FUZxxl: My name is in the credits of Pugs!
12:20:57 <OLiverr> grr hier geht ja gar nix mehr, wer hat denn die vs-datei zerstört -.-
12:21:54 <copumpkin> wat
12:22:43 <OLiverr> ups tut mir leid, falscher channel ;)
12:23:16 <mauke> das war komisch
12:24:12 <parcs> acowley: i think that someone disappeared
12:24:36 <parcs> (in the middle of his GSoC term)
12:24:40 <FUZxxl> mauke: Wo der wohl hin wollte...
12:25:20 <mauke> vs-datei? visual studio vielleicht?
12:30:44 <acowley> parcs: Thanks. Well that's a shame... it doesn't seem like anybody is really picking up where he left off.
12:34:21 <parcs> i don't think he even did anything
12:36:50 <hpaste> int80_h pasted “Could someone walk me through the troubleshooting steps for this problem?” at http://hpaste.org/52622
12:37:39 <acowley> parcs: I thought I'd seen someone talking about it either here or on cafe or reddit
12:37:55 <acowley> parcs: I got the impression things where moving, but it was probably just around GSoC application time :/
12:41:35 <mauke> int80_h: my steps were: 1) google the error message. 2) give up
12:42:48 <hpaste> int80_h annotated “Could someone walk me through the troubleshooting steps for this problem?” with “Could someone walk me through the troubleshooting steps for this problem? (annotation)” at http://hpaste.org/52622#a52623
12:43:30 <acowley> I didn't even get as far as mauke
12:43:44 <int80_h> mauke: mauke: my initial paste left out import information. The package that crapped out. I fixed that. ghci lists the things that could be wrong, I just don't know what's the priority or how to go about following up on it's advice.
12:44:20 <int80_h> *important
12:44:23 <acowley> int80_h: what are you doing to produce this error?
12:45:07 <int80_h> inside ghci I :load program.hs. I do it inside ghci because I have to explictly hide another package that is causing a seperate problem.
12:46:45 <monochrom> I bet you have two "primitive" packages. (use "ghc-pkg list -v" to verify.) it is unsafe to have two instances or even just two versions of the same package.
12:47:12 <monochrom> (my "unsafe" means the same as in "unsafePerformIO". sure there are exceptions where it's fine. only exceptions.)
12:47:39 <monochrom> indeed one unsafe aspect is that if the package comes with its own C code, you're screwed
12:48:37 <acowley> I was just checking that and I have two versions of primitive
12:49:26 <int80_h> monochrom: that is the case. May have a firther complication, I'm investigating.
12:49:39 <Veinor> https://github.com/ghc/ghc/commit/3db757241ce7fb99c096c30481aefa86bb9855a1 oh dang
12:49:44 <acowley> I will continue being an exception until the inevitable "Nuke GHC and cabal, and start all over..."
12:50:19 <monochrom> there are 3 harmful advices given by most haskellers to most beginners based on myths and unverified presumptions
12:50:29 <int80_h> acowley: you tink that's where this is leading? I will if I have to.
12:50:48 <monochrom> the most popular and most harmful is "interleave apt-get install and cabal install liberally"
12:51:20 <keep_learning> how to convert 0xff into Word8 . I am trying to use Data.ByteString.Lazy.split :: Word8 -> ByteString -> [ByteString] but i am not sure how to convert hex value oxff  into Word8 .
12:51:21 <monochrom> the 2nd most is "having multiple package versions is fine"
12:51:27 <acowley> int80_h: I'm not shy of doing it, to be honest. I would try to fix the problem, but once packages you're not sure about start having version issues, you're usually hosed.
12:51:37 <monochrom> the 3rd most is "install more packages to solve package breakage"
12:51:37 <mauke> keep_learning: 0xff is already a Word8
12:51:38 <acowley> monochrom: I have multiple versions of dozens of packages
12:51:44 <int80_h> monochrom: I need both versions. They are dependecies for other needed packages.
12:52:11 <monochrom> like I said, that's as unsafe or safe as unsafePerformIO
12:52:15 <keep_learning> mauke, ohhh , i was using '0xff' .
12:52:23 <keep_learning> mauke, thank you
12:52:31 <monochrom> I know a couple of safe uses of unsafePerformIO, sure.
12:52:57 <monochrom> in fact, a dozen safe uses, too
12:52:59 <mauke> monochrom: how harmful is mixing apt-get with cabal if you only do cabal installs as a normal user?
12:53:07 <acowley> I think the connection your drawing is tenuous at best
12:53:13 <int80_h> monochrom: So I have verfied I have two packages of differing versions. The code uses packages that need these sperate versions. Is this resolvable?
12:53:19 <acowley> s/your/you're
12:53:28 <monochrom> mauke: see my http://www.vex.net/~trebla/haskell/sicp.xhtml
12:53:52 <monochrom> and acowley too.
12:55:45 <mauke> tl;dr
12:56:13 <monochrom> fast-forward to unsafeInterleaveInstall. you probably know all the background knowledge anyway
12:56:26 <monochrom> then again, if you have to ask, you probably don't know
12:56:32 <acowley> I don't think there's an argument that multiple versions in cabal can cause problems, I just don't see how it's helpful to compare it to some other potentially harmful activity one can undertake
12:57:20 <Veinor> which is preferrable, cabal-dev or capri?
12:57:54 * hackagebot logic-classes 0.45 - Support for propositional and first order logic, normal forms, and a resolution theorem prover.  http://hackage.haskell.org/package/logic-classes-0.45 (DavidFox)
12:57:54 <Veinor> cabal-dev seems to be actually maintained, so i assume that
12:58:14 <acowley> cabal-dev
12:58:38 <monochrom> int80_h: unresolvable. the best you can do is: one executable uses one version, another executable uses another version
12:59:45 <monochrom> the very fact that there are two libs, both exporting the same C symbol "memset_off", implies that you just can't link against both
13:00:18 <mauke> monochrom: wouldn't unregistering binary as a user fix the agda problem?
13:01:13 <monochrom> that requires re-building maccatcher
13:01:57 <roconnor> monochrom: why does installing moneyholder-1.1-newhash eliminate moneyholder-1.1-oldhash?
13:01:59 <monochrom> (unless you decide to kiss goodbye to maccatcher anyway)
13:02:03 <mauke> yes
13:02:14 <monochrom> because same version 1.1
13:02:28 <monochrom> or rather because that's what ghc-pkg register does.
13:02:32 <roconnor> ... as a nix user, this behaviour seems wrong
13:02:39 <dgpratt> very confused right now...someone with the last name of Harrop is speaking positively about Haskell (http://skillsmatter.com/podcast/scala/qcon-future-functional)
13:02:48 <mauke> but it's 1) only a problem for that one user and 2) it's fixable by rebuilding the packages depending on binary
13:02:49 <monochrom> I didn't author ghc-pkg, I don't know what the author was thinking
13:02:53 <roconnor> monochrom: can ghc-pkg only handle one version of a package at a time?
13:02:54 * hackagebot maccatcher 2.1.4 - Obtain the host MAC address on *NIX and Windows.  http://hackage.haskell.org/package/maccatcher-2.1.4 (JasonDusek)
13:02:59 <mdmkolbe> Are "drift" and "derive" the primary competitors in their areas or are there other alternatives?
13:03:22 <monochrom> yes, unless you say "blah-1.1 in global, blah-1.1 in user"
13:03:31 <roconnor> ah
13:03:37 <roconnor> so that is the source of the problem
13:04:25 <monochrom> but "blah-1.1 in global, blah-1.1 in user" doesn't really mean anything because when you run ghc, ghc picks one of them and neglects the other
13:04:26 <Veinor> cabal-dev: /home/phurst/code/others/snap-core/dist/snap-core-0.6.0.tar.gz: rename: unsupported operation (Invalid cross-device link)
13:04:52 <Veinor> wow this whoops
13:04:55 <Veinor> ...
13:05:00 <Veinor> wow i'm really bad at typing
13:05:15 <monochrom> and yes this whole system is nothing close to nix.
13:05:49 <monochrom> however, if you go the nix way, there is still going to be another, harder problem.
13:05:51 <roconnor> monochrom: which is too bad, because superfically it looks like nix
13:08:31 <roconnor> monochrom: and that harder problem is?  Solving version constraints?
13:08:39 <mdmkolbe> monochrom: "this whole system" = ?
13:09:32 <monochrom> suppose I write an executable to use both HXT and HaXml. my HXT build is linked against parsec-3.0.1, my HaXml build is linked against parsec-3.0.2
13:11:31 <monochrom> here is a condition such that they live together happily: HXT does not re-export parsec stuff (or it does but I don't import it), similarly HaXml. it is as though the two respective parsec's are just internal code of HXT and HaXml respectively
13:12:37 <monochrom> here is a condition such that chaos ensue: HXT re-exports parsec stuff, and I use it; HaXml re-exports parsec stuff, and I use it. I take a value from HXT's parsec-3.0.1, pass it to HaXml's parsec-3.0.2
13:13:08 <monochrom> the 3.0.1 value and the 3.0.2 function I call may be incompatible
13:13:30 <roconnor> does HaXml build with parsec-3.0.1 and HaXml build with parsec-3.0.2 have the same ABI? (in nix they would get different hashes since nix doesn't hash the ABI, but the source code)
13:13:59 <monochrom> likely still different ABI
13:14:27 <roconnor> nix has a partial solution to this problem called propogated build inputs.  If a library exports a dependency it should be put into the propogated build inputs; The problem is that there is no enforcement of this :(
13:14:29 <monochrom> nix doesn't solve this problem. nix doesn't need to solve this problem, since this is a rare problem in the C lib community
13:14:46 <roconnor> monochrom: I don't seen why it is rare in the C lib community
13:16:14 <monochrom> C ABI tends to be much more stable. various reasons. one is authors work extra hard to keep data structures compatible. another one is compilers work extra hard to preserve struct-to-memory layout
13:16:49 <monochrom> another important one is compilers work very hard to not inline across module boundaries
13:17:15 <roconnor> Are you suggesting that if C libraries are built against slightly different versions of another library they would likely be compatible?
13:17:18 <monochrom> GHC basically destroys that 3rd reason
13:17:27 <monochrom> yes
13:17:32 <roconnor> interesting
13:17:47 <roconnor> I find it difficult to believe, but I know very little about this ABI nonsense :)
13:18:04 <monochrom> and GHC sometimes destroys the 2nd reason if you change -O levels
13:18:24 <monochrom> well think memory layout and what bytes a C function receives and returns
13:19:00 <roconnor> I figure that it wasn't a big problem in nix because the way that nixpkgs is currently designed it is rare to have more than one version of a library avaiable (in a given version of nixpkgs).
13:19:04 <lama_> +i
13:19:27 <monochrom> C compilers try very hard to preserve what the programmer dictates. GHC tries very hard to butcher it.
13:19:30 <roconnor> that plus the fact that updates are never in-place
13:20:07 <monochrom> (what the programmer dictates about data exchange)
13:20:45 <FUZxxl> Hello!
13:21:08 <FUZxxl> Can someone help me finding an appropriate recursion scheme?
13:21:39 <monochrom> Yes. "fix" is always a good initial attempt.
13:21:54 <FUZxxl> I basically want foldr, but well not foldr
13:21:56 <monochrom> Given the given information, anyway.
13:22:41 <FUZxxl> Let's say: The accumulator of the foldr is a Alternatice a => SomeType.
13:22:49 <FUZxxl> Let's say: The accumulator of the foldr is a Alternatice a => a SomeType.
13:23:30 <FUZxxl> Let's say: The accumulator of the foldr is a Alternative a => SomeType.
13:23:49 <FUZxxl> The code usually produces one new accumulator for each old accumulator.
13:24:30 <FUZxxl> There are some cases in which the combination of input and accumulator leads to more than one possible next accumulators.
13:24:48 <monochrom> I don't understand your question. but maybe you like to consider mapAccumL and mapAccumR. find them in Data.List
13:25:00 <FUZxxl> The foldr should capture all cases using an arbitrary instance of Alternatice.
13:25:04 <FUZxxl> The foldr should capture all cases using an arbitrary instance of Alternative.
13:25:16 <FUZxxl> monochrom: Yeah... Maybe I should explain it different
13:25:27 <FUZxxl> I have equation systems.
13:25:37 <kmc> FUZxxl, when you don't know the correct recursion scheme, I'd advise writing the explicit recursion first
13:26:10 <FUZxxl> The equation system is represented as a matrix, which is represented as a list of matrix rows.
13:26:44 <FUZxxl> My function gets a Mmatrix in row echelon form and should output a vector of solutions.
13:27:07 <FUZxxl> I am operating over the field F_2 where it is quite common to have a determinant of 0.
13:27:26 <FUZxxl> This results in having some empty rows in the matrix.
13:27:48 <FUZxxl> Well, in that case you can choose the undefined variable arbitrarily
13:28:01 <FUZxxl> I want to output all possible solution.
13:28:35 <FUZxxl> My code folds the matrix from right to left and accumulates the solution vector.
13:29:07 <FUZxxl> I guess I need a monad, because I need join.
13:29:15 <FUZxxl> I need a recursion scheme like
13:29:40 <FUZxxl> Monad m => (a -> b -> m b) ->  b -> [a] -> m b
13:30:23 <FUZxxl> @hoogle Monad m => (a -> b -> m b) -> b -> [a] -> m b
13:30:23 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
13:30:24 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
13:30:24 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:30:44 <FUZxxl> nice...
13:34:47 <erus`> why do programmers love pointing out mistakes?
13:35:14 <acowley> erus`: they're trained to
13:35:41 <tac-tics> acowley: I think nerds do it so they can feel clever, and thus, good about themselves
13:35:48 <FUZxxl> erus`:  And many programmers - like me - are perfectionists who simply can't stand a flawed system
13:35:53 <erus`> i was hoping for a witty response
13:36:03 <acowley> I was being charitable
13:36:06 <FUZxxl> erus`: What kind of mistakes do you mean
13:36:10 <monochrom> what mistakes?
13:36:18 <acowley> you've made a huge mistake
13:36:48 <erus`> i said to someone "i have eaten 3000 cals today" and they said "Cals*"... made me lol
13:37:12 <monochrom> I certainly don't correct other people's typos like that
13:37:27 <angstrom> cats*
13:37:29 <parcs> that's not a typo
13:37:39 <engla> erus`: I suppose it was 3000 kcal :-)
13:38:07 <acowley> erus`: the mistake was eating too much
13:38:07 <monochrom> and I agree about cats* :)
13:39:03 <erus`> acowley: your mistake was assuming I don't want to gain weight
13:40:31 <acowley> I'm just trying to make more mistakes than you to draw your critic's ire
13:47:53 <Twey> erus`: You don't get to be a very good programmer unless you're the sort of person who automatically notices errors.
13:48:10 <Twey> & of course once you notice an error, there's a strong urge to correct it…
13:48:22 <erus`> Twey: i do but i have learned when it is socially acceptable
13:49:58 <tac-tics> Twey: Well actually, it's not an urge to correct errors...
13:50:01 <tac-tics> XD
13:50:22 <tac-tics> Programmers are the kind of people who like to start sentences with "Well, actually..."
13:51:34 <Nimatek> For some reason I am reminded of 'Storm' by Tim Minchin.
13:51:58 <Nimatek> If someone doesn't know: http://www.youtube.com/watch?v=KtYkyB35zkk
13:52:03 <kmc> programmers are the kind of people who spend time programming computers
13:52:28 <kmc> they're not all smart, they're not all "nerds", they don't all read hacker news and xkcd and play D&D
13:52:34 <MarkDBlackwell> KirinDave, if you're there, when I said or implied that I understood monads, I misspoke. I was thinking of Monoids. I have a long way to go to understand Monads!
13:52:45 <tac-tics> kmc: Don't forget wow. They don't all play wow
13:52:57 <dgpratt> Well, actually M. Icaza wrote a blog post on that subject: http://tirania.org/blog/archive/2011/Feb-17.html
13:53:29 <KirinDave> MarkDBlackwell: I don't think you told me this. :)
13:53:39 * kmc vomits upon reading this post
13:54:29 <MarkDBlackwell> Kirindave, sorry, maybe it was someone else I said it to!
13:54:35 <KirinDave> np man
13:55:03 <MarkDBlackwell> KirinDave, I didn't really think I did, yesterday, either.
13:55:11 <kmc> there's not much to understand about monads
13:55:19 <KirinDave> kmc: That is the problem
13:55:22 <kmc> exactly
13:55:27 <KirinDave> kmc: They're like pointers.
13:55:33 <KirinDave> it's kind of a non-thing, a very elementary concept
13:55:44 <KirinDave> But actually understanding the implications of said concept can be tricky.
13:56:03 <copumpkin> kmc: well, actually
13:56:30 <kmc> ugh i hate this kind of blog post so much
13:56:36 <copumpkin> lol
13:56:43 <tac-tics> kmc: all too familiar? :P
13:56:50 <erus`> kmc it hit home for me too :(
13:56:53 <copumpkin> kmc: I don't disagree with it, except for the generalizations about programmers etc.
13:57:02 <copumpkin> all the generalizations are annoying
13:57:07 <dolio> kmc: You're not getting laid because you're a big stereotype I believe in.
13:57:25 * ClaudiusMaximus profiling - first run took 10mins, ended up with one big blob called 'main'....  bit tedious adding cost centres and re-running if it takes that long each time :/
13:57:28 <MarkDBlackwell> KirinDave, kmc, after doing some reading, today, I think I agree: easy and deep of implications. Applicative Functors in LYAH kind of washed over me: difficult.
13:58:04 <dgpratt> I'm not getting laid because I'm at work and it wouldn't be appropriate
13:58:23 <MarkDBlackwell> KirinDave, anyway, I keep reading, because intuition tells me Haskell is upcoming.
13:58:25 <kmc> yeah programmers don't get laid, programmers are all autistic
13:58:35 <monochrom> someone should say "I'm not getting laid because I'm on vacation"
13:58:37 <kmc> if you program computers for a living then you must also define every aspect of your personality around this fact
13:58:41 <kmc> or else you're shit at it
13:58:54 <kmc> and you must train to be a ninja like the Karate Kid
13:58:58 <copumpkin> lol
13:59:05 <dolio> Dude, Google programmers get laid at work all the time.
13:59:14 <erus`> laid off?
13:59:14 <copumpkin> also, ruby programmers
13:59:17 <copumpkin> they're all rockstars
13:59:18 <dolio> In the ball pits.
13:59:21 <monochrom> but please don't be pissed by the stereotypical stereotyping blog
13:59:21 <kmc> they just watch hardcore porn at cons
13:59:53 <kmc> honestly, I am personally pretty close to the singleminded "programming is life" stereotype... but I have enough fucking perspective to know that not every competent software engineer is
13:59:53 <MarkDBlackwell> KirinDave, I should say also, I like Haskell.
14:00:12 <KirinDave> We agree it is great.
14:00:23 <tac-tics> Can we bring the Paul Graham mentality into this conversation?
14:00:34 <MarkDBlackwell> KirinDave, it draws me. Yes, we agree. :)
14:00:36 <tac-tics> We're nerds, that makes us inherently superior to everyone else!
14:00:51 <kmc> Lisp is better than other languages because it doesn't impose limits on how you think
14:00:55 <kmc> by the way, type systems are useless
14:01:01 <kmc> tac-tics, did that help?
14:01:07 <KirinDave> tac-tics: Did you hear?
14:01:09 <acowley> (haskell (is okay))
14:01:18 <KirinDave> tac-tics: He sent out an email today saying that HackerNews is full of morons now.
14:01:20 <kmc> acowley, well, actually, (is okay haskell)
14:01:24 <kmc> haha
14:01:27 <KirinDave> tac-tics: It's amazing.
14:01:33 <dolio> kmc: Are you sure he didn't mean the, "programmers are like struggling bohemian artists," angle?
14:01:39 <kmc> that too
14:01:46 <acowley> it's probabaly (isp *OKAY* haskell)
14:01:56 <kmc> another PG angle is "if you've not founded a startup by the age of 9, you are a failure and must kill yourself"
14:02:03 <kmc> that one is more blatantly self-serving
14:02:56 <c_wraith> Does founding a lemonade stand count?
14:03:07 <kmc> only if you get $10 million in seed funding
14:03:08 <tac-tics> Don't forget, "because I was successful with Lisp in my bubble-startup, Lisp is the best language, with a handful of flaws. I'm going to work in secret, then release the world's GREATEST language."
14:03:11 <MarkDBlackwell> KirinDave, for instance, I like (and Rubyists notice) that handling a chain of functions (composition) that may be fed a null (or nil, in Ruby) with a Maybe type is elegant.
14:03:28 <KirinDave> MarkDBlackwell: DId you see my blog post on this?
14:03:42 <tac-tics> ".... without any real understanding of software architecture (because I never made it past the start-up phase of coding) nor compiler or programming language theory"
14:04:07 <mdempsky> Quick terminology question: Which of these are proper to refer to as 'a monad': [] (the type constructor), [Integer], [42]?
14:04:11 <acowley> I once patronized a lemonade stand
14:04:17 <kmc> mdempsky, the type constructor only
14:04:21 <tac-tics> mdempsky: [] is the monad
14:04:28 <kmc> sometimes people say "monadic type" and "monadic value" for the other two
14:04:40 <kmc> I'm not convinced this is a good thing to do
14:04:45 <MarkDBlackwell> KirinDave, I may have! What is the title, or a link?
14:04:58 <mdempsky> kmc: Cool, thanks.
14:05:01 <KirinDave> MarkDBlackwell: http://dave.fayr.am/posts/2011-10-4-rubyists-already-use-monadic-patterns.html
14:05:03 <copumpkin> [] isn't the monad, either! [] plus operations that satisfy laws is the monad :P
14:05:15 <KirinDave> It was received with… mixed reception here.
14:05:29 <monochrom> other examples of what you can call a Monad: Maybe, IO, Writer Int
14:05:33 <tac-tics> copumpkin: You are the more technically correct of all of us :)
14:05:37 <dmwit> copumpkin++
14:05:40 <copumpkin> well, actually
14:05:44 <tac-tics> hehe
14:06:02 <MarkDBlackwell> KirinDave, not until now, but I'm happily reading it
14:06:17 <monochrom> generally look at "instance Monad ___ where" and think what is legit to fill in there
14:06:22 <kmc> there's a lot of discussions here which look like idle pedantry but serve to draw out real conceptual misunderstandings
14:06:48 <acowley> like erus` issue with not using proper units of energy
14:06:50 <kmc> like all the talk of "impure functions", "main function", etc
14:06:59 <dmwit> There's plenty of idle pedantry, too, kmc.
14:07:01 <monochrom> as for the values such as "return True" I have decided to call them actions
14:07:10 <dolio> kmc: It's probably not a good thing to do.
14:07:24 <kmc> i'm unforgiving about the terminology for these things because there really is a conceptual difference
14:07:26 <dolio> People will be all confused when they hear 'monadic' with other meanings in category theory then. :)
14:07:27 <mdempsky> monochrom: Right, I understand the difference between [], [Integer], and [42]; just people are very inconsistent in their terminology.
14:07:35 <kmc> dolio, and in APL!
14:07:37 <acowley> dmwit: I prefer to call that, "idyllic pedantry." #haskell is a happy place.
14:07:42 <dolio> Yeah, totally.
14:07:43 <monochrom> yes, I hate those people.
14:07:50 <Twey> mdempsky: [] is a monad; [Integer] is just a type; [42] we sometimes call a ‘mote’ or ‘monadic value’ or similar
14:08:09 <dolio> I call [42] a list.
14:08:15 <acowley> me, too
14:08:21 <kmc> if you understand that putChar is a pure function and getChar is an IO action then it's not hard to use the correct terminology
14:08:29 <monochrom> otoh the articles they wrote were written very long ago, at a time when even the bigshots used wrong terms.
14:08:40 <kmc> dmwit, yes
14:10:02 <kmc> there's also a difference between "correcting someone's mistake" and "being a dick about it"
14:10:19 <kmc> which is a constant struggle for me
14:12:05 <roconnor> what would you call the scale for degrees of authentication?
14:12:06 <arcatan> yeah. "you're wrong, you fucking idiot" is an incredibly bad argumentation strategy regardless if you're right or wrong
14:12:12 <arcatan> it's popularity is unfortunate :|
14:12:32 <roconnor> I performed a highly _____ authentication.
14:13:22 <irene-knapp> "secure" is a little generic but reasonable
14:13:22 <monochrom> authentic? authoritative? I don't really know
14:13:23 <arcatan> secure?
14:13:24 <kmc> suspect
14:13:31 <irene-knapp> "trustworthy"
14:13:33 <roconnor> kmc: :D
14:13:37 <arcatan> ha
14:13:49 <roconnor> trustworthy is good
14:13:54 * irene-knapp nods
14:14:08 <roconnor> irene-knapp++
14:14:45 <irene-knapp> hehe yay, karma catching up to what it was on the old nick~
14:15:04 <dmwit> ?karma dankna
14:15:04 <lambdabot> dankna has a karma of 4
14:15:25 <dmwit> dankna-- irene-knapp++ dankna-- irene-knapp++ dankna-- irene-knap++ dankna-- irene-knap++
14:15:30 <irene-knapp> lol :D
14:15:50 <irene-knapp> mind the spelling, two Ps
14:16:06 <hpc> irene-knapp++ irene-knapp++
14:16:11 <hpc> fix'd
14:16:25 <dmwit> irene-knap-- irene-knap--
14:16:28 <irene-knapp> sweeto
14:16:32 <dmwit> dmwit-- for being a lousy speller
14:17:18 <roconnor> dmwit: can you lower your own karma?
14:17:24 <dmwit> Probably not.
14:17:31 <dmwit> Well... yes, actually!
14:17:39 <roconnor> ok
14:17:39 <totally-not-dmwi> dmwit--
14:17:49 <roconnor> pfft
14:17:53 <dmwit> =)
14:22:19 <erus`> do I start on 1?
14:22:34 <erasmas> I'm about to hpaste an exercise I'm working on for fun, so if anyone has time I'm interested in other approaches/ideas/corrections
14:22:53 <hpaste> erasmas pasted “josephus” at http://hpaste.org/52625
14:23:44 <erasmas> (sorry about the long lines in the comments)
14:26:09 <erus`> next could be inside the where for initCircle ?
14:26:38 <erus`> i like to hide bindings for functions i only use inside a single function... if that makes sense
14:27:57 <erus`> but where do you draw the line? you can't have everything inside a where for main
14:28:16 <erasmas> erus`: that makes sense. I could actually move both next and kill into the maybeChange where clause
14:30:23 <Veinor> i've always wondered why haskell programs seem to have massive amounts of imports
14:30:47 <Veinor> erus`: the problem with that is it makes it harder to debug
14:31:24 <monochrom> http://hackage.haskell.org/package/prelude-plus may reduce your imports :)
14:31:50 <dolio> kmc should make an ACME.Everything module while he's bumming around.
14:31:54 <Veinor> i've considered it!
14:32:02 <dolio> Depends on every package on Hackage, and imports them all.
14:32:20 <monochrom> that may crash hackage
14:32:21 <kmc> it'll be hard to keep that up to date
14:32:46 <Veinor> but like
14:32:50 <mauke> Haskell should have something like AUTOLOAD
14:33:04 <Veinor> the default snap Site.hs has about 12 lines of imprts
14:33:07 <Veinor> imports
14:33:08 <monochrom> I know: write a bot to watch hackagebot and update ACME.Everything
14:33:26 <mauke> https://metacpan.org/module/Acme::Everything
14:35:04 <dolio> monochrom: That's too obsolete. It should watch the hackagebot twitter feed.
14:35:14 <monochrom> ok
14:35:26 <Veinor> also i need to patch haskell-mode to do aligned imports
14:36:21 <Veinor> ... wait, you can import multiple modules as the same qualified name?
14:36:28 <dolio> Yes.
14:36:37 <monochrom> yes! I was terrified too.
14:36:41 <dolio> You can import the same module qualified as different names.
14:36:45 <dolio> Multiple times.
14:36:50 <Twey> That one I know
14:36:51 <Veinor> dolio: that makes more sense
14:36:56 <Twey> Multiple modules as one name is scary, though.
14:36:59 <dolio> It does?
14:37:00 <Veinor> it's pointless but it makes sense
14:37:15 <dolio> I think multiple modules as the same qualified space makes sense.
14:37:27 <Veinor> how so?
14:37:40 <monochrom> makes sense when the modules are related
14:37:45 <dolio> Right.
14:37:50 <Veinor> i mean, when i say 'makes sense' i don't mean 'this is a feature i'm glad exists'
14:37:55 <Twey> One module as multiple names is simple — at least you know that a particular prefix always refers to the same module; there's no contextual ambiguity to be resolve
14:37:58 <Twey> d
14:38:05 <Veinor> i mean 'there's not really any reason to break it'
14:38:05 <dolio> Import 5 different parsec modules as qualified P.
14:38:23 <Veinor> so what happens if they define the same function, it bails?
14:38:47 <acowley`> everyone gets cake
14:38:54 <dolio> It's no different than multiple unqualified imports defining the same function.
14:39:49 <MarkDBlackwell> KirinDave, that is a very nice post for Rubyists overall! Also, I learned something about how to use (several), 'c &&= <expression>'. And if I may let you know of something that threw me, it was, 'Instead of get_host_by_name_or_nil, we could now use', whereas I wouldn't have been thrown by, 'Instead of get_host_by_name_or_nil, we generally use'. Great, overall!
14:40:18 <monochrom> but I combine this feature with explicit imports. import M0(f, g) as M; import M1(h) as M
14:40:32 <monochrom> (add "qualified" "as")
14:40:43 <monochrom> s/"as"//
14:41:18 <MarkDBlackwell> KirinDave: 'we generally use get_hosts_by_name, which returns a list, which could be empty, ...'
14:41:40 <acowley`> monochrom: I thought you'd take a stance advocating globally unique function names ;)
14:42:11 <monochrom> hmm, how come?
14:43:14 <monochrom> perhaps because I say "don't install several parsecs"? but that's only because ghc doesn't work well with it
14:48:06 <roconnor> preflex: seen ski
14:48:07 <preflex>  ski was last seen on #haskell 3 days, 6 hours, 17 minutes and 36 seconds ago, saying: * ski phaws
14:59:51 <MarkDBlackwell> KirinDave, The nice Object#try method in Rails is also nice: ( http://api.rubyonrails.org/classes/NilClass.html#method-i-try ). With it, as you may know, to avoid nil-crashing in `@person.children.first.name', we replace, `@person && !@person.children.blank? && @person.children.first.name' with the succinct, `@person.try(:children).try(:first).try(:name)', right? Not as nice as Haskell, I know.:)
15:00:06 <MarkDBlackwell> nice
15:00:18 <Twey> It's just a monad
15:00:37 <MarkDBlackwell> Twey, yes, I suppose.
15:00:55 <ciaranm> it's not a monad
15:01:08 <Twey> But without the typeclass they're restricted to giving it one specific instance only
15:01:11 <Twey> ciaranm: No?
15:01:34 <Twey> It's pretty much precisely the Maybe monad instance, isn't it?
15:01:48 <ciaranm> Twey: where's the functor on types?
15:01:50 <MarkDBlackwell> ciaranm, it only invokes the :children function if @person is not nil, for instance.
15:01:52 <Twey> Where Nothing is nil and Just x is just the object x
15:02:03 <ciaranm> "does what Maybe does" is not "is a monad"
15:02:07 <Twey> ciaranm: Touché
15:02:38 <MarkDBlackwell> Twey, yes, Maybe; I just read KirinDave's post (above) on the Maybe monad and Ruby.
15:02:54 <ciaranm> i mean, java 7 or 8 or something has a crappy operator called something like ?. that does that with nil
15:02:58 <ciaranm> not a monad either
15:03:04 <Twey> Yeah
15:03:23 <copumpkin> objective c does that for free!
15:03:28 <copumpkin> maybe monads everywhere!
15:03:29 <copumpkin> whee
15:03:46 <ciaranm> maybe is everywhere, but it's not a monad in most places!
15:04:11 <mokus> > map Just "copumpkin!"
15:04:12 <lambdabot>   [Just 'c',Just 'o',Just 'p',Just 'u',Just 'm',Just 'p',Just 'k',Just 'i',Ju...
15:04:24 <copumpkin> I am indeed very just
15:04:52 <MarkDBlackwell> Twey, ciaranm, right, those languages don't have monads, and it's good to bring people in by speaking to them about ways they already use the concepts, a little, it seems.
15:05:14 <Twey> Yeah
15:05:18 <ciaranm> you could do monads in ruby
15:05:24 <ciaranm> it's just no-one does
15:05:36 <Twey> http://moonbase.rydia.net/mental/writings/programming/monads-in-ruby/00introduction.html
15:05:50 <kmc> people use the Monad Design Pattern in most languages
15:05:56 <kmc> but they don't abstract it into a library
15:06:15 <ciaranm> monad's not a frickin' design pattern
15:06:21 <kmc> a language which "has monads" is just a language in which someone's written and popularized this library
15:06:25 <MarkDBlackwell> Twey, I read that one, today, and it's good.
15:06:27 <kmc> monads are not a language feature
15:06:37 <kmc> Haskell has some language features which make it a better host for this library than most
15:06:37 <ciaranm> Twey: those aren't monads
15:07:32 <Twey> ciaranm: No?
15:07:33 <ciaranm> "does the same kind of stuff as what a monad does in haskell" does not make something a monad
15:07:41 <Twey> It has return and bind
15:07:54 <MarkDBlackwell> ciaranm, can one do particular instances of monads (even fairly well) in Ruby, or, further, could one write the Monad typeclass (have I got that right) in Ruby, for general monads?
15:08:24 <ciaranm> Twey: that's not enough to be a monad
15:08:35 <ciaranm> MarkDBlackwell: ruby's duck typed, so you don't need a type class
15:08:52 <Twey> ciaranm: Isn't that precisely what's needed to be a monad?  What other criteria are there?
15:09:04 <ciaranm> MarkDBlackwell: what you can do is have functions that turn one type into another type, and that turn one function into another function
15:09:29 <hpc> Twey: it needs a proof that it follows the laws
15:09:41 <Twey> hpc: So Haskell's monads aren't monads, either? :þ
15:09:58 <ciaranm> haskell's monads are monads unless you get really pedantic
15:10:21 <hpc> @quote monad.*2.*category
15:10:22 <lambdabot> Cale says: A small category is a monad in the 2-category of spans of sets.
15:10:31 <hpc> @quote monad.*2.*category
15:10:32 <lambdabot> Cale says: A small category is a monad in the 2-category of spans of sets.
15:10:39 <ciaranm> Twey: first you have to establish that Ruby forms a category. you can't have monads until you show that.
15:10:39 <hpc> bah
15:10:46 <kmc> what.
15:11:31 <MarkDBlackwell> ciaranm, I have seen andand, and some others. I wonder about some verbose way to make general bind and zero (identity) methods.
15:11:37 <kmc> i'm gonna say Hask is not a category because (f . (g . h)) can be distinguished from ((f . g) . h) through some tricks
15:11:47 <ciaranm> kmc: that's the pedantic part
15:11:53 <kmc> oh i see
15:11:59 <kmc> the things i object to are pedantic
15:12:04 <kmc> but the things you object to are important
15:12:36 <copumpkin> @quote lax
15:12:36 <lambdabot> dons says: The alien rulers of the galaxy must surely use a statically typed language with type inference
15:12:38 <copumpkin> @quote lax
15:12:38 <lambdabot> wli says: Monads are like constipation. Comonads are like Ex-Lax.
15:12:39 <kmc> (also f . id from f)
15:12:43 <ciaranm> no no, i'm fully in favour of fixing haskell to make it behave itself
15:13:19 <ciaranm> but Hask is at least more or less a category until you look closely, whereas Ruby isn't since its morphisms are too weird
15:13:27 <kmc> functions?
15:13:27 <dolio> kmc: I don't think (f . (g . h)) is distinguishable from ((f . g) . h). Just (f . id) from f.
15:13:54 <kmc> yeah
15:14:01 <kmc> i was thinking in terms of implementation details, but I guess that's not really fair
15:14:07 <kmc> how do you distinguish (f . id) from f otherwise
15:14:13 <mokus> seq
15:14:29 <hpaste> “Ben Gamari” pasted “Possible disambiguation?” at http://hpaste.org/52627
15:14:35 <kmc> > (undefined . id) `seq` ()
15:14:36 <lambdabot>   ()
15:14:39 <kmc> *nod*
15:14:43 <kmc> i see
15:15:03 <shachaf> seq for functions. :-(
15:15:10 <shachaf> unsafeEvilSeq
15:15:41 <bgamari> Is there any way to make this code work?
15:15:44 <bgamari> http://hpaste.org/52627
15:15:46 <kmc> "Haskell has property X if you ignore the features which make it a practical programming language.  while Ruby lacks property X because of the features which make it a practical programming language"
15:16:13 <bgamari> I would like for the compiler to infer getAll's type from its use
15:16:16 <kmc> it's a popular line of argument
15:16:21 <bgamari> I guess not, now that I think of it
15:16:50 <kmc> how doesn't it work bgamari?
15:17:04 <bgamari> The compiler thinks there's an ambigous type variable
15:17:05 <copumpkin> bgamari: I think you've got it a little messed up
15:17:14 <ciaranm> an easier argument against ruby is that it doesn't have identity functions
15:17:21 <mike-burns> Object#try is a hack; use the wrapped gem instead.
15:17:26 <bgamari> copumpkin: Oh?
15:17:51 <dolio> I suspect Haskell is way closer to having proper category structure than Ruby.
15:17:52 <ciaranm> and for that matter that ruby functions don't have a domain or codomain
15:18:16 <bgamari> Well, either way I've managed to thoroughly confuse myself
15:18:31 <ciaranm> so i don't think you can claim that ruby only fails to be a category because of the useful bits. it's more that it isn't even remotely categoryish anywhere.
15:18:34 <bgamari> copumpkin: Something like this code could work?
15:18:54 <hpc> kmc: seq is required to do practical haskell programming?
15:19:26 <kmc> it's pretty damn useful
15:19:31 <bgamari> Alternatively, if you can see some way to build this list (or a similar data structure) without building in reverse and then reversing, that would be great
15:19:38 <kmc> seq on functions not as much
15:19:57 <shachaf> seq on functions is still sometimes useful.
15:19:59 <monochrom> either seq or compiler's perfect strictness optimization is required
15:20:01 <dolio> For Haskell it's, "get rid of seq (as currently implemented)." For Ruby it's, "throw out all sorts of mutation and reflections and whatnot."
15:20:22 <ciaranm> it's not just throwing stuff out. it's adding in notions like domain and codomain.
15:20:28 <copumpkin> bgamari: why not just use Get a -> Get [a]?
15:20:29 <kmc> I agree that Haskell is much closer to having category structure but I still think it's a useless, pedantic argument
15:20:48 <ciaranm> i mean, short of saying that the Ruby category has a single object in it...
15:20:50 <copumpkin> bgamari: call it many :)
15:20:51 <bgamari> copumpkin: unfortunately that instance first reads a length, then reads that many as
15:21:04 <copumpkin> bgamari?
15:21:05 <aristid> let's all use agda, and stop using haskell
15:21:12 <dolio> ciaranm: That works.
15:21:38 <mokus> you could also say that ruby merely 'contains' a category of functions following convention X - there's no reason every term has to be a part of the category
15:21:57 <ciaranm> dolio: i'm not sure even then... because the functions are weird in how arguments work
15:22:00 <bgamari>     get    = do n <- get :: Get Int
15:22:01 <bgamari>                 replicateM n get
15:22:13 <bgamari> copumpkin: That's why
15:22:14 <copumpkin> bgamari: I'm saying, why not write many :: Get a -> Get [a] ?
15:22:27 <dolio> Well, forget about Ruby per se and take, say, the untyped lambda calculus.
15:22:37 <ciaranm> do i have to?
15:22:37 <bgamari> copumpkin: Ahh. And what do I pass it?
15:22:49 <copumpkin> get
15:23:12 <bgamari> copumpkin: Ahh, alright
15:23:16 <bgamari> yes, of course
15:23:18 <monochrom> oh, get is polymorphic, now I get it
15:23:21 <dolio> You have categorical models for that that contain one object that is isomorphic to its own exponential with itself and so on.
15:23:31 <bgamari> copumpkin: Thanks!
15:23:35 <dolio> Or, identical, I guess.
15:23:57 <copumpkin> bgamari: :)
15:24:16 <ciaranm> dolio: i still have a sneaking suspicion you couldn't get an identity arrow under ruby
15:24:47 <ciaranm> dolio: because iirc the identity would drop the "block provided?" thingie
15:28:33 <ash_> so… this is completely off topic but I just was gonna throw it out there and see if anyone knows any good number sequence identifier tools or techniques
15:29:07 <Twey> OEIS
15:29:08 <ciaranm> ash_: you mean the "what comes next after 1 2 3 4" kind of thing?
15:29:15 <monochrom> google for OEIS
15:29:16 <ash_> ya
15:29:31 <ash_> OEIS already failed me actually
15:29:32 <ciaranm> ash_: try linderholme's "mathematics made difficult" for the universal solution to those
15:29:56 <shachaf> ciaranm: That was a great solution. :-)
15:30:05 <ciaranm> it's universal!
15:30:12 <aristid> @oeis 1 2 3 4
15:30:24 <monochrom> @bots
15:30:26 <lambdabot>  The natural numbers. Also called the whole numbers, the counting numbers or ...
15:30:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:30:26 <lambdabot> :)
15:30:37 <aristid> just a bit of delay:D
15:31:22 <ash_> hmm… well, what I am doing is trying to analyze shuffling sequence, it has a weird order, but I have been able to partially identify the pattern, its just more complicated than I have been able to recognize
15:36:08 <keep_learning> why don't we have isInfixOf function in Data.ByteString.Lazy  while it has isPrefixOf  and isSuffixOf ?
15:38:35 <aavogt> you could use =~ with an instance from http://hackage.haskell.org/package/regex-posix
15:38:52 <aavogt> Text.Regex.Posix.ByteString.Lazy
15:40:05 <monochrom> yikes :)
15:41:25 <aristid> http://hackage.haskell.org/package/stringsearch-0.3.6.2
16:03:20 <keep_learning> will the isInfixOf function in Data.ByteString.Lazy will destroy laziness .
16:03:53 <hpc> keep_learning: if it doesn't find the search term, the entire string will be evaluated
16:04:02 <hpc> so yeah, kind of, i suppose
16:04:16 <shachaf> Well, but if it does find the search term, it won't.
16:04:22 <shachaf> So no, kind of, I suppose.
16:04:27 <hpc> :P
16:04:44 <hpc> either way, it won't magically become a Data.ByteString.Strict value
16:06:18 <ranveer5289> can someone explain me lazy evaluation in relation to following pseudo code  http://pastebin.com/W5cwgNC8
16:06:20 <mauke> The paste W5cwgNC8 has been copied to http://hpaste.org/52628
16:07:01 <ranveer5289> i need to know what echo y is going to print in the last line
16:08:48 <shachaf> ranveer5289: What sort of pseudocode is that?
16:09:09 <hpaste> hpc annotated “lazy evaluation” with “lazy evaluation (annotation)” at http://hpaste.org/52628#a52629
16:09:50 <ranveer5289> it a normal I/O pseudo code
16:10:07 <ranveer5289> i copied from http://book.realworldhaskell.org
16:12:24 <ranveer5289> shachaf: i just need to know why in second case echo y will print 5 (i mean what role is lazy evaluation playing there)
16:12:30 <hpaste> hpc annotated “lazy evaluation” with “lazy evaluation (annotation) (annotation)” at http://hpaste.org/52628#a52630
16:13:49 <hpc> ranveer5289: http://hpaste.org/52630 -- it won't print 5 in haskell because the second keyboard input isn't changing the value of x, it is creating a new value and stealing the name of the other value
16:13:59 <shachaf> ranveer5289: I don't really understand that code or your question. I'm not sure you do either.
16:14:02 <hpc> y will still be 8 because it was defined up there
16:14:37 <hpc> RWH is probably using different semantics in their pseudocode and just not explaining it properly
16:14:52 * hpc hasn't read the earlier chapters and doesn't know exactly what the book says
16:15:08 <ranveer5289> kk
16:15:10 <shachaf> At any rate this seems to have little to do with lazy evaluation as it exists in Haskell.
16:15:18 <shachaf> ranveer5289: Where is that code actually coming from?
16:15:47 <ranveer5289> it was used in a comment at RWH
16:16:22 <ranveer5289> hpc: can u give me a basic example of lazy evaluation in haskell
16:16:38 <ion> > echo off
16:16:42 <ranveer5289> so that it helps me in understanding the real meaning of lazy evaluation
16:17:21 <ion> > echo on
16:17:22 <lambdabot>   Ambiguous occurrence `on'
16:17:22 <lambdabot>  It could refer to either `L.on', defined at <loc...
16:17:26 <ion> Whoops :-D
16:17:29 <hpc> ranveer5289: sure, gimme a sec to think of one that isn't actually a demo of 'fix' :P
16:17:51 <ranveer5289> hpc: ya sure
16:18:16 <hpc> actually, i can probably build up to that and not be confusing, maybe
16:18:24 <hpc> ranveer5289: okay, so suppose we did
16:18:27 <hpc> > undefined
16:18:28 <lambdabot>   *Exception: Prelude.undefined
16:18:35 <hpc> whoops, we crashed
16:18:38 <hpc> so now we do
16:18:49 <hpc> > let runme = undefined in 5
16:18:49 <lambdabot>   5
16:19:00 <hpc> we never evaluated runme because we didn't need to
16:19:04 <hpc> so we didn't crash
16:19:10 <ranveer5289> kk
16:19:12 <hpc> > let runme = undefined in runme + 5
16:19:12 <lambdabot>   *Exception: Prelude.undefined
16:19:47 <hpc> we had to evaluate it there though, because we wanted to evaluate it plus 5
16:20:11 <hpc> it more or less comes down to "pattern matching evaluates expressions, but only as far as the constructor"
16:20:36 <ion> > 5undefined
16:20:37 <lambdabot>   5
16:20:44 <ranveer5289> getting something
16:20:49 <hpc> > let rume = undefined; test = runme + 5; test2 = Just test in case test2 of Just x -> 15
16:20:50 <lambdabot>   Not in scope: `runme'
16:20:57 <hpc> > let runme = undefined; test = runme + 5; test2 = Just test in case test2 of Just x -> 15
16:20:58 <lambdabot>   15
16:21:47 <hpc> so starting from the top, test2 = THUNK -- a thunk is an unevaluated expression
16:22:03 <hpc> then we enter the case and see if it matches (Just x)
16:22:08 <hpc> so now test2 = Just THUNK
16:22:18 <hpc> then the whole case evaluates to 15 and we are done
16:22:56 <hpc> one of the cooler things you can do with this is manipulate infinite structures
16:23:13 <hpc> > let ones = [1] ++ ones in ones -- a whole bunch of 1s
16:23:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:23:46 <hpc> > let ones = 1:ones in head ones -- let's evaluate this by hand now
16:23:47 <lambdabot>   1
16:23:57 <hpc> so ones = THUNK
16:24:29 <hpc> then we start evaluating 'head ones' and match ones against the only pattern it has
16:24:41 <hpc> -- head (x:xs) = x
16:24:53 <hpc> so now we have ones = 1 : THUNK
16:25:08 <hpc> then head returns 1, and that's what the whole thing evaluates to
16:25:42 <hpc> if we tried to get the length of 'ones', we would keep pattern-matching forever before we are able to produce a value
16:25:55 <hpc> and that's pretty much lazy evaluation in a nutshell
16:26:29 <aristid> hpc: ranveer5289_ may not have been able to read everything
16:28:37 <alex____> sup guys?
16:30:41 <dmwit> Hiya, alex____.
16:31:21 <alex____> are you involved with this site?
16:31:36 <Axman6> site?
16:31:36 <c_wraith> site?
16:31:58 <Axman6> we're all users of the Haskell programming language
16:32:04 <alex____> ah yeah
16:32:21 <alex____> ok I thought this was a node for tryhaskell.org
16:32:26 <alex____> but it's a general one
16:32:28 <alex____> my mistake
16:32:39 <Twey> Yep, this is the #haskell IRC channel
16:32:54 <donri> chrisdone is the creator of tryhaskell, he hangs around here
16:32:58 <alex____> how long has haskell been around?
16:33:07 <joo> Since a few minutes ago.
16:33:08 <donri> 91 i think?
16:33:08 <Axman6> over 20 years
16:33:21 <joo> You created it by discovering it.
16:33:22 <alex____> right
16:33:39 <donri> joo, you solipsist!
16:33:43 <Twey> Twenty-one years
16:33:47 <Axman6> alex____: it's a bit over 20 years old -_-
16:33:48 <Twey> donri: Lazy evaluation of reality
16:33:51 <donri> alex____, wikipedia says '90
16:34:01 <donri> Twey, ah
16:34:02 <joo> Hehe.
16:34:03 <alex____> that's a lot of answers!
16:34:11 <donri> you shoot yourself in the foot, but it's ok as long as you don't look at it
16:34:18 <alex____> yeah, joo has Berkeleyan leanings
16:35:00 <donri> alex____, welcome to #haskell, where one silly question will typically result in three hours of deeply abstract discussion
16:35:09 <alex____> perfect!
16:35:30 <Axman6> alex____: so what brings you to tryhaskell.org?
16:35:38 <alex____> hmmm
16:35:46 <alex____> sk89q
16:35:51 <donri> perhaps a desire to.. try haskell (sunglasses, "yeaaa")
16:35:57 <alex____> a developer I follow tweeted about it
16:36:05 <alex____> nice, donri
16:36:21 <alex____> and hats off to chrisdone
16:36:30 <alex____> it's nicely made, and funny!
16:36:59 <donri> hpaste.org is also his work
16:37:05 <Axman6> you should look at LYAH:
16:37:10 <Axman6> @where lyah
16:37:10 <lambdabot> http://www.learnyouahaskell.com/
16:37:25 <alex____> lol
16:37:32 <donri> hey are you chatting by typing "chat" in tryhaskell?
16:37:42 <alex____> bingo
16:37:48 <donri> that explains your confusion :)
16:37:56 <alex____> yeah
16:38:03 <alex____> I was being stupid though
16:38:09 <donri> and perhaps your many underscores
16:38:24 <donri> try /nick somethinglessobnoxious ;P
16:38:35 <alex____> more underscores is a mark of honour
16:38:44 <donri> underscore of honour, ah
16:38:55 <shachaf_> WHOA, DUDE
16:39:07 <shachaf_> It's like an IRC client inside a web browser.
16:39:15 <Twey_________> Cool, isn't it?
16:39:22 <alex____> you here from tryhaskell.org too?
16:39:25 * donri is now known as donri¯¯¯¯
16:39:35 <donri> am i doing this right
16:39:46 <alex____> huh
16:39:46 <Twey_________> xD
16:39:51 <Twey_________> Overscores FTW.
16:39:58 <alex____> is that an invisible character?
16:40:07 <alex____> ¯¯¯¯¯¯
16:40:11 <alex____> no.
16:40:19 * shachaf_ is now known as shachaf—————
16:40:20 <Dashkal>  /nick "Dashkal" ++ repeat('_')
16:40:36 <donri> alex____, /me bla bla
16:40:41 <shachaf_> /nick
16:40:52 <alex____> clever
16:41:03 <alex____> IRC wizardry
16:41:15 <donri> debatable :P
16:41:25 * alex____ doesn't know much about IRC
16:41:26 <ash_> someone has my most common alias used already so i just let it add a few __
16:41:34 <Axman6> or, the second thing everyone learns when they're new to irc :P
16:41:40 * donri is now also known as Twey, but only on odd minutes
16:41:52 <donri> (yes, irc has a command for that)
16:42:02 <Twey> Heh
16:43:00 * Axman6 suggests maybe we might get back on topic
16:43:17 <alex____> so does anything serious ever get written in haskell?
16:43:21 <alex____> apart from xmonad of course
16:43:25 <donri> nope, never
16:43:42 <roconnor> was pugs serious?
16:43:59 <Axman6> alex____: the GHC compiler is almost completely haskell
16:44:18 <Axman6> alex____: http://ugcs.net/~keegan/talks/why-learn-haskell/talk.pdf
16:45:18 <Axman6> it's been used for lots of real world stuff. i was an intern at a company in Tokyo doing high frequency trading using haskell for all their systems
16:45:30 <alex____> thanks, I'll read that
16:46:21 <donri> http://haskell.org/haskellwiki/Haskell_in_practice
16:47:33 <alex____> OK, so I thought it might be one of these exotic languages like SCHEME which are elegant but compile to slow binaries
16:47:34 <Axman6> the company Galois does a lot of crypto stuff with haskell, as well as some high integrity stuff (for small organisations like the NSA and NASA)
16:48:04 <Axman6> it's certainly possible to write very fast haskell
16:48:11 <alex____> ok
16:48:23 <Axman6> if you know what you're doing, you can get quite close to c speeds
16:48:26 <alex____> I'm convinced
16:48:33 <Axman6> and if you're doing concurrency or parallelism, it's very easy to beat C
16:48:46 <alex____> I kinda feel like we should all be using C for the next couple of days, though...
16:49:12 <donri> heh
16:49:26 <Twey> It's okay
16:49:31 <Twey> GHC uses some C internally
16:49:35 <hpaste> int80_h pasted “Problem with http-enumerator” at http://hpaste.org/52633
16:49:55 <donri> the ghc runtime is C
16:50:02 <donri> and i'd guess ghc was bootstrapped with C?
16:50:03 <Twey> int80_h: Failed defaulting; add more typesigs (or compile with GHC)
16:50:41 <int80_h> Twey: What would the type sig look like. I experimented and got it wrong.
16:51:05 <Twey> Hold on
16:51:14 * Twey looks up the http-enumerator docs
16:51:15 <theorbtwo> donri: Actually, perl.
16:51:25 <donri> really?
16:51:36 <int80_h> mind=blowen
16:51:43 <int80_h> er, I mean blown
16:51:44 <aristid> int80_h: you could try disabling the monomorphism restriction *blind shot*
16:51:58 <int80_h> aristid: how?
16:52:30 <Nimatek> Obviously PHP is at the core of GHC.
16:52:39 <Twey> int80_h: I think m should be MonadIO
16:52:43 <copumpkin> roconnor: I see you wrote a proof of the infinitude of primes in coq
16:52:45 <int80_h> isn't php responsible for unix in general?
16:52:53 <aristid> int80_h: {-# LANGUAGE NoMonomorphismRestriction #-}
16:52:57 <Twey> So, :: test <- parseUrl "..." :: IO (Request IO)
16:52:59 <donri> wikipedia says "GHC complies with the language standard, called Haskell 98"; isn't this outdated now?
16:53:00 <alex____> I heard GHC was largely written in BASIC
16:53:02 <copumpkin> roconnor: I wrote one in agda, but I was looking for a more constructive statement/proof of it. Have you thought about that?
16:53:24 <int80_h> Twey: I got that far. I don't know how to express that in code. This is a new boundary for me
16:53:54 <Axman6> alex____: there's a packacge for writing BASIC in haskell, and having it compiled using LLVM to very fast code =)
16:53:58 <Twey> int80_h: That is code — just annotate your ‘test <- …’ line with the appropriate typesig (IO (Request IO))
16:53:58 <int80_h> Twey oooh! I was close. I tried IO Request
16:54:02 <Twey> Yeah
16:54:02 <Axman6> @hackage basic
16:54:02 <lambdabot> http://hackage.haskell.org/package/basic
16:54:15 <Twey> Request is parameterised over a monad type
16:54:20 <int80_h> but I couldn't tell from the resulting error that I was close
16:54:31 <Twey> You can tell from the docs
16:54:53 <Twey> http://hackage.haskell.org/packages/archive/http-enumerator/0.7.1.2/doc/html/Network-HTTP-Enumerator.html#g:1
16:54:58 <Axman6> bah, that's not what it's called >_<
16:54:59 <Twey> See how they all expect MonadIO m?
16:55:00 <aristid> oh right
16:55:05 <alex____> Axman6: but why??
16:55:07 <aristid> always use Request IO
16:55:10 <Twey> You can't see it on the type, but you can see it on the functions on that type
16:55:18 <Twey> Yeah, IO is the simplest MonadIO
16:55:34 <Axman6> alex____: why not? it was to experiment with the LLVM package
16:55:35 <int80_h> twey: yeah, my attempt at doing IO Request I thought would meet that requirement. When it didn't I got stuck.
16:55:55 <donri> anyone know of a not-too-complicated library for implementing search engines in haskell? can't really find one on hackage
16:55:57 <alex____> fair enough
16:55:59 <Twey> int80_h: The first IO is not a parameter to Request but a requirement of parseUrl
16:56:15 <donri> there's the one hayoo is built on but it's not on hackage and doesn't seem very well documented
16:56:17 <int80_h> Twey: ah!
16:56:24 <Twey> http://hackage.haskell.org/packages/archive/http-enumerator/0.7.1.2/doc/html/Network-HTTP-Enumerator.html#v:parseUrl
16:57:28 <Twey> You need an exception monad in which to execute the parseUrl in case it fails, and then a monad over which to parameterise the resulting Request (in which it will actually be performed)
16:57:29 <int80_h> Twey: You did it!
16:57:36 <int80_h> test
16:57:48 <Twey> They might be very different: parseUrl is a pure operation, so you might quite reasonably use Maybe or something for the outer monad
16:58:20 <Twey> (in fact, having figured that out, I'd recommend it)
16:58:27 <donri> or Either if you want more rich error reporting
16:58:45 <Twey> donri: There's no Either instance
16:58:52 <Dashkal> Is there a generic term for this operation: (Set a, Set a) -> (Set a, Set a, Set a) where the output is only left, both, only right?
16:59:01 <donri> oh you're talking about monads
16:59:11 <Twey> donri: The MPTC is over an exception type anyway
16:59:11 <Twey> Yeah
16:59:12 <int80_h> Trey: You did it!
16:59:17 <int80_h> Twey, I mean
16:59:34 <Twey> int80_h: You're welcome
17:02:30 <Cale> Dashkal: The first and last parts are the set differences, and the middle part is the intersection.
17:02:46 <Dashkal> Cale: I'm looking for a name for a function that takes that form.
17:02:57 <Dashkal> difInterDif sounds funny
17:03:27 <Veinor> man i really want a way to say 'tell me the type of this variable'
17:03:45 <copumpkin> Veinor: at runtime?
17:03:50 <copumpkin> Typeable does that
17:03:57 <Veinor> no, at compile time
17:04:00 <Cale> Dashkal: Well, there's a unix program called "comm" which does it, but I don't think that's much better.
17:04:06 <Veinor> i have some variable with an annoying type that i don't remember
17:04:07 <copumpkin> Veinor: I use implicit parameters that way
17:04:42 <copumpkin> Veinor: {-# LANGUAGE ImplicitParams #-} at the top, then type ?f myAnnoyinglyTypedVariable in some expression and typecheck
17:04:52 <Dashkal> mmm, c'est la vie.  The generic "setPartition" will have to do.
17:04:53 <Veinor> ha
17:05:18 <copumpkin> anyone have any ideas on constructively and totally (and easily) generating a larger prime given an existing prime?
17:05:21 <Veinor> the problem is that the variable is bound in some monad
17:05:25 <Veinor> er, do-block
17:05:38 <copumpkin> Veinor: that should still be fine
17:05:42 <Cale> Dashkal: You could name it "venn", after the diagrams :)
17:05:52 <Dashkal> I like it
17:05:53 <copumpkin> in fact, you can even just stick ?f myVaraible in your do block
17:06:04 <copumpkin> it'll be yourtype -> yourmonad a
17:06:07 <mdxbhmt> copumpkin: wouldn't that make primes an 'easy problem'?
17:06:18 <Veinor> mdxbhmt: PRIMES is in P
17:06:26 <Veinor> :D
17:06:37 <mdxbhmt> ah /facepalm
17:06:50 <mdxbhmt> wait
17:06:50 <copumpkin> mdxbhmt: there are definitely algorithms for it, but I want something that'd be not too painful in a proof assistant
17:06:53 <mdxbhmt> P as in NP?
17:07:00 <mdxbhmt> In not*
17:07:23 <Cale> Determining if a number is prime is doable in polynomial time on a Turing machine.
17:07:33 <Cale> Polynomial time in the number of bits in the number
17:07:57 <copumpkin> assuming I'm building from the very basics :P
17:08:01 <copumpkin> i.e. peano naturals
17:08:06 <Cale> http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf
17:08:14 <c_wraith> type-level primality testing?
17:08:18 <copumpkin> I have a simple (inefficient) primality decision procedure
17:08:55 <mdxbhmt> Cale: thanks for the pdf, i'll have a nice read D:
17:09:36 <Dashkal> I love it when a page of code suddenly collapses into one line
17:10:02 <copumpkin> Dashkal: you mean when you click the button on the left of the code in your editor?
17:10:28 <Dashkal> Or when I realize I horribly overcomplicated a solution and it collapses down into two differences and an intersect
17:10:33 <shachaf> So I added library-profiling: True to my .cabal/config, and now I keep having to chase dependencies and cabal install --reinstall manually whenever only the non-profiling version of a library is installed.
17:10:41 <shachaf> Is there anything that can be done about that?
17:10:50 <copumpkin> no
17:12:03 <monochrom> erase everything and install afresh :)
17:12:07 <hpc> shachaf: be more careful next time you reinstall your OS
17:12:34 <shachaf> Hmph.
17:12:43 * hpc got bit by that a couple of weeks ago
17:12:47 <shachaf> I also have a bunch of broken packages, apparently.
17:13:09 <Cale> See also http://www.math.dartmouth.edu/~carlp/aks041411.pdf, which cuts the time bound down from O~(log^12(n)) to O~(log^6(n))
17:13:57 * monochrom has heard of AKS and it seemed superior to the "master method"
17:23:49 <JuanDaugherty> did anything replace haskell platform?
17:24:40 <copumpkin> no
17:25:02 <JuanDaugherty> k, thx
17:40:54 <quackquack> I am trying to consume Twitter's firehose API, which is an HTTP stream. How can I do this in haskell? Can http-enumerator do the job?
17:41:29 <ddarius> There'd be something wrong with it if it couldn't.
17:41:38 <ash_> Make a system call to curl?
17:41:54 * ash_ sarcasm 
17:43:25 <quackquack> ddarius: but how? because normally I get the return value when the request ends, but with the stream it just keeps .... streaming
17:46:29 <JuanDaugherty> ole man river, that ole man river, he don't say nuthin ...
17:47:15 <kmc> how does that work? does it use HTTP chunked encoding?
17:47:35 <copumpkin> quackquack: you don't use the simple interface
17:47:42 <copumpkin> you want to write your own consumer
17:47:48 <copumpkin> there's some way to do that but I can't remember how
17:48:13 <kmc> they just had to use HTTP because otherwise it would not be webscale
17:49:15 <copumpkin> I used to consume the garden hose
17:49:40 <quackquack> copumpkin: hm, ok ty
17:51:28 <Lemonator> There is no #llvm
17:51:50 <copumpkin> go to irc.oftc.net
17:51:53 <copumpkin> #llvm there
17:51:55 <Lemonator> oh
17:57:22 <ddarius> Why did you stop consuming the garden hose?
17:57:37 <joo> My garden hose is more likely to consume me.
17:57:48 <wavewave> ?
17:57:58 <ClaudiusMaximus> hmm, 85% of my program runtime is taken up by   showF :: Double -> ByteString ; showF x = pack $ showFFloat Nothing x ""
17:58:28 <c_wraith> computing text representations of floating-point numbers is expensive
17:59:04 <ClaudiusMaximus> seems so - i wrote this before floatshow package was release, i'll see how it compares
18:00:51 <wavewave> ClaudiusMaximus: yeah, you are converting double to String to ByteString.. seems inefficient.
18:03:29 <wavewave> ClaudiusMaximus: BTW, text package has it's own RealFloat builder. probably you want to try it.
18:04:04 <ClaudiusMaximus> wavewave: yes, i originally started tonight's hacking many hours ago with the aim of switching from ByteString to Text
18:04:39 <augur_> does ghc currently depend on the background os?
18:04:40 <wavewave> ClaudiusMaximus: floatshow seems to use String again as an internal rep.
18:04:45 <int80_h> :q
18:04:49 <ClaudiusMaximus> wavewave: but instead i switched from home-rolled code for parsing .hp files to use hp2any-core, then found it slow and improved it and sent patches to its maintainer
18:04:52 <int80_h> \q
18:04:56 <int80_h> :q
18:05:40 <ClaudiusMaximus> wavewave: yes it does.  anyway, benchmarking now :)
18:06:01 <wavewave> ClaudiusMaximus: good to hear. I would like to know the result.
18:06:11 <mdxbhmt> @quote ByteString
18:06:12 <lambdabot> pozic says: I think if you want to contact dons, you have to say that you found a bug in ByteString.
18:07:13 <ClaudiusMaximus> wavewave: down from 240secs with showFFloat from Numeric, to 43secs with fshow :: Double7 -> String - now the bulk of the time is in parsing rather than printing
18:07:33 <ClaudiusMaximus> wavewave: showF now uses 15% of runtime instead of 85%
18:07:55 <wavewave> ClaudiusMaximus: great!
18:08:00 <ClaudiusMaximus> yep!
18:08:19 <ClaudiusMaximus> this is with a huge input too (36MB of heap profile)
18:08:33 <byorgey> augur_: I don't understand your question.
18:08:56 <augur_> byorgey: well, a friend claims that compiled haskell makes OS calls
18:09:03 <augur_> so it cant run directly on hardware
18:09:10 <augur_> by friend i mean EmanuelZ there
18:09:16 <augur_> and i wasnt aware that this occurred
18:09:43 <byorgey> oh. I don't know.
18:09:44 <wavewave> ClaudiusMaximus: Did you look up the module Data.Text.Lazy.Builder.RealFloat in text package?
18:09:46 <mdxbhmt> augur_: afaik, all software do OS calls, in some level
18:09:49 <ClaudiusMaximus> wavewave: not yet
18:10:17 <byorgey> augur: I mean, compiled Haskell can run on any platform to which a Haskell compiler has been ported.
18:10:40 <ddarius> augur: GHC compiled code makes RTS calls which then may make OS calls.
18:10:45 <byorgey> augur: obviously you can't take code compiled to run on Linux and expect it to run on your custom robot without recompiling.
18:11:00 <wavewave> ClausdiusMaximus: if your benchmark is not very complicated, try that one. It would not be very difficult
18:11:13 <ddarius> augur: There is an OS based on the GHC runtime so that you can compile code that will run on a computer with no operating system.
18:11:15 <augur> byorgey: well, EmanuelZ's intention is to play around with making his own OS so if haskell makes OS calls it can't be used to implement an OS (or you have to do some knot tying to do so)
18:11:23 <ddarius> (Essentially, the modified GHC RTS is the OS.)
18:11:40 <ClaudiusMaximus> wavewave: i do want to rip out the ByteString and replace with Text, but not tonight - it's late...
18:11:43 <augur> ddarius: hmm!
18:11:47 <monochrom> dangerous to say "haskell" rather than "ghc" (or pick your compiler)
18:11:48 <augur> EmanuelZ: well there you go.
18:12:22 <EmanuelZ> thank you.
18:12:32 <shachaf> byorgey: What if my custom robot runs Linux?
18:13:36 <byorgey> shachaf: I was talking about augur's custom robot.  Obviously it would run just fine on YOUR custom robot.
18:13:43 <shachaf> Oh.
18:13:52 <augur> byorgey: all of my robots run Mac OS
18:13:58 <augur> and are glossy white
18:14:01 <byorgey> exactly
18:14:42 <monochrom> build a robot that takes javascript. there is a haskell compiler that generates javascript. now haskell runs on the robot without OS-dependence. does that count?
18:14:54 * byorgey 's custom robots are made of carefully woven dried pasta
18:15:00 <ddarius> Unfortunately, augur can't run Haskell code on them for legal reasons.
18:15:16 <monochrom> (to highlight how "does haskell depend on OS" is ambiguous)
18:15:20 * mdxbhmt is amazed at monochrom idea
18:15:21 <augur> ddarius: fortunately i dont follow laws
18:16:35 <shachaf> Does your robot follow The Three Laws of Monadics?
18:16:50 <mdxbhmt> What about making an OS that is based on Http conections?
18:17:42 <ddarius> Already done.
18:17:50 <monochrom> @quote law.*monadic
18:17:51 <lambdabot> No quotes match. The more you drive -- the dumber you get.
18:18:43 <monochrom> http://www.last.fm/robots.txt
18:19:52 <ddarius> 404
18:19:58 <wavewave> .
18:20:09 * wavewave is thinking about internet os.
18:21:27 <monochrom> these days you can't even safely ask "is python written in C".
18:21:54 <wavewave> making haskell datatype serializable like json... interprotocol communication using http.
18:22:07 <mdxbhmt> @quote python
18:22:07 <lambdabot> python says: is a mediocre language invented by a mediocre person
18:22:21 <shachaf> monochrom: Sure python is written in C.
18:22:27 <shachaf> Just like perl is written in C.
18:22:31 <wavewave> hmm. that's too harsh. ;-P
18:22:35 <monochrom> no, see http://en.wikipedia.org/wiki/Python_%28programming_language%29#Implementations
18:22:42 <mdxbhmt> @quote C
18:22:43 <lambdabot> dobblego says: many of my colleagues used to be [fond of ruby] as well until I was let loose on them
18:22:45 <shachaf> monochrom: I'm referring to python, i.e., /usr/bin/python
18:22:46 <monochrom> there is pypy written in python
18:23:04 <monochrom> except there is no /usr/bin/haskell
18:23:16 <shachaf> "Only perl can parse Perl"
18:23:35 <mdxbhmt> then who parsed first?
18:24:02 <wavewave> it's lazy. tying the knot.
18:24:07 <dmwit> ?forget python is a mediocre language invented by a mediocre person
18:24:07 <lambdabot> Done.
18:24:16 <desaiu> Cale: you wanted to explain map? :)
18:24:18 <dmwit> ?remember anonymous python is a mediocre language invented by a mediocre person
18:24:19 <lambdabot> Done.
18:24:39 <shachaf> Is that quote even worth being in the quote database?
18:24:45 <shachaf> It seems completely pointless.
18:24:50 <dmwit> Yeah, I don't really like it.
18:24:54 <mdxbhmt> @quote pointless
18:24:54 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
18:24:58 <wavewave> I agree.
18:25:00 <dmwit> But it definitely shouldn't be attributed to a guy named python.
18:25:05 <monochrom> I second removing it
18:25:10 <mdxbhmt> i seems agressive
18:25:12 <mdxbhmt> it*
18:25:14 <dmwit> ?forget anonymous python is a mediocre language invented by a mediocre person
18:25:14 <lambdabot> Done.
18:25:31 <wavewave> @quote ruby
18:25:31 <lambdabot> Cale says: Ruby is kind of a nice language, for an imperative object oriented language that isn't smalltalk.
18:26:06 <mdxbhmt> someone can give me a non imperative OO lang?
18:26:27 <wavewave> OOhaskell?
18:26:31 <dmwit> smalltalk?
18:26:42 <monochrom> CSP, CCS
18:26:42 <Cale> O'Caml?
18:26:44 <wavewave> is smalltalk not imperative?
18:26:46 <companion_cube> scala is not very imperative too
18:26:59 <mdxbhmt> hmmm
18:27:03 <monochrom> pi calculus too
18:27:13 <ddarius> Smalltalk is definitely imperative.
18:27:17 <wavewave> btw, what's definition of OO?
18:27:26 <monochrom> message-passing
18:27:34 <ddarius> The pure σ-calculus is not imperative in certain forms.
18:30:05 <JuanDaugherty> st is imperative
18:30:15 <wavewave> is Builder in text package implemented as difference list?
18:30:27 <JuanDaugherty> classically OO is encapsulation, polymorphism, and inheritance
18:31:02 <hpaste> Stribor pasted “Types” at http://hpaste.org/52635
18:31:28 <stribor> i have problem with "function" it gives me type error and i dont get why....anyone willing to help me out
18:31:38 <mdxbhmt> JuanDaugherty: that's too general to define OO, IMO
18:31:56 <ClaudiusMaximus> hm, interesting - switching from a bytestring Trie Int to a simple Map ByteString Int gave quite a big speed up
18:32:07 <wavewave> stribor : someFunction Back Type1 is Type1
18:32:17 <wavewave> stribor: someFunction Back is Type1 -> Type1
18:32:20 <mdxbhmt> :t Trie
18:32:21 <lambdabot> Not in scope: data constructor `Trie'
18:32:29 <Cale> stribor: myData can't be named starting with a lowercase letter
18:32:43 <stribor> Cale: yeah that waass just typo
18:32:49 <wavewave> stribor, Cale : oh yes, that's another error.
18:32:56 <ClaudiusMaximus> @hoogle Trie
18:32:56 <lambdabot> Test.HUnit.Base tried :: Counts -> Int
18:32:56 <lambdabot> Network.BSD getHostEntries :: Bool -> IO [HostEntry]
18:32:57 <lambdabot> Network.Browser getMaxErrorRetries :: BrowserAction t (Maybe Int)
18:33:02 <stribor> wavewave: i dont get type error
18:33:04 <ClaudiusMaximus> none of the above...
18:33:15 <stribor> wavewave: i mean i dont understand what are you saying
18:33:27 <JuanDaugherty> mdxbhmt, I did say classically. My first use of st was c. '85. People started to ask the trick question to which that was the answer in the 90s
18:33:28 <wavewave> stribor: would you show how Type1 is defined?
18:33:34 <stribor> give me sec
18:33:49 <stribor> wavewave: what you mean how it is defined?
18:33:59 <wavewave> stribor: yes.
18:34:05 <ClaudiusMaximus> http://hackage.haskell.org/package/bytestring-trie this one
18:34:12 <Cale> stribor: you claim that function :: [Type1 -> Type1], but someFunction :: MyData -> Type1 -> Type1, and so someFunction Back :: Type1 -> Type1, and so someFunction Back Type1 :: Type1
18:34:22 <Cale> So [someFunction Back Type1] :: [Type1]
18:34:31 <Cale> assuming that Type1 :: Type1
18:34:34 <wavewave> stribor: you are probably mixing Type Constructor and Value Constructor.
18:34:50 * monochrom snickers. Coq has Type :: Type too!
18:35:05 <monochrom> stribor: function = [someFunction Back]
18:35:15 <wavewave> monochrom: yeah, yeah..
18:35:19 <stribor> monochrom: yes that is not giving me error but why
18:35:47 <monochrom> oh, because I sitll haven't finished writing my type inference tutorial. it's pretty difficult to write.
18:35:53 <Cale> stribor: Because someFunction :: Back -> Type1 -> Type1, and so to get something of type Type1 -> Type1 from it, you only need to supply one parameter
18:36:09 <stribor> Cale: oh interesting...
18:36:37 <stribor> Cale: but i just try to type someFunction Back and it gave me error
18:36:38 <Cale> If you supply two parameters, you'll have something of type Type1
18:36:57 <Cale> Well... could you show us your actual code? It might help :)
18:37:03 <mdxbhmt> ClaudiusMaximus: so you are saying that map is faster than the custom made "efficient map" of bytestring?
18:37:06 <wavewave> stribor: strange.
18:37:26 <JuanDaugherty> http://meansofproduction.biz/pub/codeSamples/xsqlbrws.cls shows some st I did about 20 years ago. As you can see it's quite imperative.
18:37:27 <monochrom> what is meant by "but i just try to type someFunction Back and it gave me error"
18:37:49 <stribor> it doesnt give me error when i type into file....save it..and then reload it......but if after i save it try to type it into interpreter then it gives me error
18:37:50 <monochrom> the least ambiguity is: type into where
18:38:13 <ClaudiusMaximus> mdxbhmt: right - i only tested briefly with one test case within a larger program, but it reduced from 43 seconds to 34 seconds runtime by s/Trie Int/Map ByteString Int/g
18:39:06 <wavewave> stribor: I got type error with your code.
18:39:42 <monochrom> if you enter stuff into the interpreter, the interpreter tries to evaluate and then print answers. but it can't print answers for mere functions. that's an error.
18:39:56 <ClaudiusMaximus> mdxbhmt: so i'm sure in other usage patterns the trie might be better
18:40:04 <stribor> monochrom:  yes it is printing error...tells me to create instance of Show
18:40:20 <monochrom> so ignore it. who wants to print functions anyway.
18:40:29 <mdxbhmt> ClaudiusMaximus: I can only imagine that, otherwhise it has a serious problem
18:40:38 <stribor> monochrom: thank you
18:41:02 <wavewave> stribor: anyway, your code is incomplete. in  the definition of Type1 and someFunction. Would you show your full code snippet?
18:41:26 <stribor> wavewave: give me sec.....i just want to see whats happening in my code and then ill paste it
18:41:52 <wavewave> stribor: good. take your time ;-)
18:42:09 <stribor> wavewave: thanks
18:42:37 <monochrom> I have a feeling that productivity and speed of progress can be doubled by deleting ghci
18:42:52 <mdxbhmt> JuanDaugherty: interesting, funny that 20 years later new languages can have worse syntax
18:44:24 <wavewave> monochrom: somewhat agree. I didn't use ghci from the beginning because I realized the grammar is different.
18:44:55 <wavewave> later, I understood ghci is immersed in IO monad.
18:45:15 <wavewave> with implicit print support.
18:45:36 <wavewave> for the beginner, it's quite misleading.
18:45:48 <stribor> Cale:  how does "someFunction Back" gives Type1->Type1
18:46:15 <wavewave> stribor: you're now touching the concept of 'currying'
18:46:34 <Axman6> a -> b -> c === a -> (b -> c)
18:47:01 <wavewave> stribor: a function that has two arguments has a type a -> b -> c   ( c as a result type)
18:47:08 <joo> As well you should be, for Curry is Haskell's surname.
18:47:50 <monochrom> someFunction :: MyData -> (Type1 -> Type1)
18:47:55 <monochrom> Back :: MyData
18:47:55 <wavewave> stribor: if you apply only one argument (of type a) to f, then remaining result type of (f a ) is b -> c
18:48:12 <monochrom> therefore, someFunction Back :: Type1 -> Type1
18:48:29 <wavewave> stribor: one good example is (+)
18:48:38 <mdxbhmt> :t (+)
18:48:39 <lambdabot> forall a. (Num a) => a -> a -> a
18:48:43 <monochrom> the general rule: f :: X -> Blah, v :: X, therefore, f v :: Blah
18:48:53 <wavewave> :t (+3)
18:48:54 <lambdabot> forall a. (Num a) => a -> a
18:49:40 <mdxbhmt> this sort of magic, I like it
18:49:54 <wavewave> stribor: now (+) 3 already took 3 as one parameter, but still it need another parameter to calculate a number.
18:49:57 <stribor> ok i have to figure this out
18:50:03 <monochrom> magic? sufficiently basic logic looks like magic?
18:50:33 <wavewave> stribor: so (+) 3  is a function that takes  a parameter and calculate to a number. \x -> (x+3)
18:50:42 <monochrom> no wonder humans tend to think that the human mind is a miracle
18:50:51 <mdxbhmt> monochrom: It simple, but I'm amazed to it anyway
18:51:19 <augur> so guys
18:51:26 <mdxbhmt> monochrom: probably because I spend too much time with C like
18:51:30 <augur> how complicated would it be to implement a variety of haskell?
18:51:42 <monochrom> depends on the variety
18:51:53 <wavewave> augur : a variety of haskell means different compiler?
18:51:58 <augur> not with all the fancy bells and whistles of a very good interpreter or compiler
18:52:00 <wavewave> augur : or some language extension?
18:52:02 <monochrom> probably not very complicated
18:52:06 <augur> just _an_ interpreter or compiler
18:52:19 <monochrom> after all, hugs is not very complicated
18:52:24 <augur> the way i figure it, it would be like implementing scheme, plus types, plus type classes
18:52:25 <wavewave> augur: haskell in its core is simple lambda calculus.
18:52:37 <wavewave> augur: exactly.
18:53:00 <wavewave> augur : haskell is more like a set of syntatic sugar at high level.
18:53:15 <wavewave> augur: but its evaluation model is different from scheme's
18:53:23 <augur> yeah, because its lazy
18:53:51 <monochrom> the layout rules are annoying to implement. but then, the haskell report almost spells out one implementation
18:54:30 <wavewave> augur: yes, so difficult part is implementing the evaluator.. GHC has so-called Spineless Tagless G-machine as the evaluator (graph reduction machine.)
18:54:45 <monochrom> lazy evaluation is or is not hard, depending on whether you know the trick
18:54:46 <stribor> ok i have question....it was said in earlier conversation this someFunction :: MyData -> (Type1 -> Type1)
18:55:03 <augur> wavewave: whats a graph reduction machine exactly
18:55:06 <augur> monochrom: whats the trick!
18:55:12 <stribor> what would happen if someFunction :: someFunction :: MyData -> Type1 -> Type1->Type1
18:55:17 <stribor> then what
18:55:25 <stribor> where would we put brackets??
18:55:54 <wavewave> augur: in its implementation, lambda calculus is regarded as some graph..
18:55:55 <augur> wavewave: is it?
18:55:55 <wavewave> augur: sorry, I mean lambda expression
18:55:55 <augur> hows that work
18:56:16 <stribor>  someFunction :: MyData -> Type1 -> (Type1->Type1)  or  someFunction :: MyData -> (Type1 -> Type1->Type1)
18:56:17 <wavewave> augur: I will recommend a book by Simon Peyton Jones.
18:56:35 <stribor> how dpo we know where to put brackets
18:56:39 <monochrom> a mutable cell for an algebraic type "data Stuff a = Evaluated a | NotYetEvaluated (Expression a)"
18:57:19 <wavewave> augur: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987
18:57:36 <wavewave> augur: you can get the free e-book there.
18:57:41 <augur> cool
18:58:08 <wavewave> guys, how can I remember this to lambdabot?
18:58:17 <monochrom> I am not sure whether my http://www.vex.net/~trebla/haskell/lazy.xhtml helps
18:58:58 <stribor> is a->b->c->d === a->b->(c->d)
18:59:16 <mdxbhmt> in this case, yes
18:59:17 <wavewave> monochrom: yes, this is good simple explanation.
18:59:34 <monochrom> and yes, the slpj-book-1987 is worth a read
18:59:39 <stribor> or is it is a->b->c->d === a->(b->c->d)
18:59:41 <deech> Hi all, cabal question. How do I install haddock documentation with a Hackage package? I set "documentation : true" in "~./cabal/config" and did a "cabal install --reinstall <some-package>" and it installs the package but not the documentation.
19:00:10 <wavewave> I personally think slpj-book-1987 is a kind of must-read since lazy evaluation causes so-many confusion.
19:00:33 <monochrom> my lazy.xhtml certain helps haskell users, but not quite low-level enough for a haskell implementer
19:00:46 <mdxbhmt> stribor, implement some functions without types and use :t on ghci to check them
19:00:50 <mdxbhmt> may help
19:01:03 <augur> stribor: it's both!
19:01:07 <monochrom> but slpj-book-1987 is too long and too low-level for haskell users. miss forest for trees
19:01:35 <wavewave> monochrom: I agree it. so it's like a must-read after real-world haskell?
19:02:04 <monochrom> it's a must-read after complex-world haskell
19:02:22 <wavewave> must-read after once bitten by laziness seriously.
19:02:44 <wavewave> asking what the hell this compiler does.
19:03:08 <monochrom> when my lazy.xhtml is complete, it will suffice to explain all your bitten by laziness, so you still won't need slpj-book-1987
19:03:45 <deech> Has anyone successfully installed Haddock on 7.2.1? I'm getting an error with "xhtml" saying "base:Prelude cannot be safely imported"
19:03:55 <augur> does anyone know if its possible to get haskell to call out to obj-c if the haskell instance is embedded in an obj-c program?
19:04:05 <wavewave> monochrom: your website is a really good addition. I think real world haskell / LYAH or any popular book must have somewhat serious section on laziness in detail.
19:04:48 <monochrom> yes, every book so far just handwave it "evaluate when needed". trouble is that "needed" is subjective
19:05:22 <monochrom> completely explains why some people come here to complain "why is the computer so dumb? why is 'if undefined then () else ()' undefined?"
19:06:01 <wavewave> *nod*
19:06:27 <shachaf> *gdi*
19:07:11 <wavewave> BTW, 'if undefined then () else ()' can be well-defined in SK evaluation scheme, I guess.
19:07:18 <monochrom> I fell into the trap of saying "need" in an earlier draft. now you see I have exorcised all or almost all of it. I now say "short-circuit", so that you know it means nothing until I spell out what to short-circuit and what not too.
19:08:01 <stribor> guys is there any online tutorial which would give me some insights into this problem
19:08:08 <stribor> that we discussedd earlier
19:08:30 <wavewave> so 'need' is defined by evaluation strategy.
19:08:51 <deech> nm, fixed it with "ghc-pkg trust base".
19:08:52 <wavewave> stribor: do you know 'Learn You A Haskell'? free online book?
19:09:27 <monochrom> we are under the constraint that the Haskell Report requires (after following a handful of its rules) if ⊥ then ... else ... = ⊥ . even if you know how to do better.
19:10:08 <monochrom> but yes, I actually know a way to implement if x then () else () = () if we switch to another language.
19:10:26 <wavewave> monochrom: oh. I didn't know about the constraint.
19:10:35 <stribor> wavewave: i can find it.....what part is it?
19:10:53 <wavewave> stribor: currying must be explained well there.
19:10:59 <wavewave> stribor: let me check.
19:11:05 <stribor> wavewave: thank you
19:11:21 <wavewave> ah.. I have a hard copy of it. .right.
19:11:29 <Axman6> > unzip . map (pred &&& succ) $ "test"
19:11:31 <lambdabot>   ("sdrs","uftu")
19:11:38 <Axman6> excellent
19:11:51 <Axman6> and it's pretty hilarious to read out loud too =)
19:12:33 <wavewave> section 5 is about higher-order functions
19:12:42 <wavewave> Axman6 : :-D
19:13:29 <wavewave> stribor: it starts with curried function.. it might help you well.
19:13:54 <wavewave> s/section/chapter
19:14:24 <stribor> wavewave: thank you
19:15:32 <stribor> wavewave: s/section/chapter?
19:15:49 <stribor> wavewave: 1-28 chapters
19:16:17 <wavewave> ah.. I mean section 5 -> chapter 5
19:16:48 <wavewave> s/section/chapter   is some common idiom we use in IRC.
19:17:05 <wavewave> from vi command.
19:17:50 <monochrom> suppose I write helo stribor good day
19:18:03 <monochrom> then I may write s/helo/hello/ to correct my typo
19:18:32 <monochrom> and this notation is much better than some other people's hello*
19:18:53 <stribor> wavewave: i didnt know that....
19:18:55 <stribor> ):
19:19:20 <wavewave> in fact, I am also a newbie in IRC world.. ;-P
19:19:53 <monochrom> I used to tease them: suppose your typo is that you have a spurrious word, rather than a misspelt word. how do you use your notation to correct it? do you just write "*"?
19:19:55 <shachaf> monochrom: Why is it better?
19:20:09 <shachaf> It's more redundant and there's almost never ambiguity.
19:20:10 <monochrom> it tells you where to carry out the replacement
19:20:33 <monochrom> no, I have seen far more genuine ambiguities than "almost never"
19:21:12 <monochrom> but yes, now I have ceased to tease them, because they are stubborn, insisting "almost never" like you do.
19:21:23 <mike-burns> It's more traditional, if only because lots of IRC users also had to know ed back in the day.
19:21:26 <monochrom> they are wrong and I'm done arguing against them
19:21:31 <shachaf> monochrom: I don't actually use that notation, mind you. I dislike it.
19:21:54 <shachaf> But I think that argument against itis silly.
19:22:14 <shachaf> s/ti/t i/
19:22:32 <monochrom> you know, you could have written "* " there
19:22:52 <shachaf> monochrom: I think the rule with that notation is that if there's ambiguity, you just include more of the surrounding text.
19:23:19 <monochrom> I have seen no one following that rule
19:23:44 <shachaf> Well, that's a different matter.
19:24:02 <monochrom> the true and deep rule is: every author thinks his writing is unambiguous and the most readable ever.
19:24:16 <shachaf> Right, but only I'm correct in thinking that.
19:24:27 <lntz> monochrom: what is this in regards to?
19:24:36 <lntz> monochrom: what document is in question?
19:24:46 <monochrom> s/x/y/ vs *y
19:24:50 <monochrom> in IRC
19:25:33 <shachaf> lntz: Are you rntz's evil twin?
19:26:02 <lntz> shachaf: :P nope
19:26:11 <lntz> shachaf: or am I? >:D
19:34:09 <ClaudiusMaximus> hooray, replacing read . unpack :: ByteString -> Double with  parseOnly double :: ByteString -> Double  (from attoparsec)  halved the runtime
19:35:41 <ClaudiusMaximus> well, slgitht errzro so pretend i unwrapped the Either result and handled the error case sanely
20:02:07 <mdxbhmt> ClaudiusMaximus: so you are from 250 secs to 25? congratz
20:02:08 <wavewave> ClaudiusMaximus: yeah. double in attoparsec is really fast. I also experienced it before.
20:03:39 <dmwit> > read "  ((0x30e-9) ) " :: Double
20:03:39 <lambdabot>   *Exception: Prelude.read: no parse
20:04:46 <dmwit> > read "  (-(30.5e-9) ) " :: Double
20:04:47 <lambdabot>   -3.05e-8
20:08:09 <akosch> what can I use to generate fancy, colored and formatted output from lhs files? (I've been using TOhtml in vim until now)
20:08:29 <wavewave> hscolour?
20:09:12 <wavewave> I haven't use it for lhs file though.
20:10:09 <akosch> wavewave: hm, can it do tex output?
20:10:38 <wavewave> you mean generating tex file?
20:11:05 <akosch> wavewave: yes
20:11:20 <wavewave> hscolour is specialized in coloring only as far as i know.
20:11:38 <wavewave> probably, pandoc helps you.
20:11:46 <wavewave> I am not sure.. though.
20:12:13 <napping> lhs2TeX is very fancy, but I don't think it does color
20:13:06 <bobzhang> a stupid question, I managed to compile ghc-7.4, but didn't find ghc, anyone knows the bin path??
20:13:45 <napping> Well, it does let you customize formatting, maybe you could throw in some tex coloring commands. Anyway, the output is beautiful enough you should try it anyway.
20:14:01 <kosmikus> napping: there's lhs2TeX-hl
20:14:07 <wavewave> bobzhang. did you do make-install ?
20:14:12 <akosch> napping: color is not strictly necessary, I would just like some nice output
20:14:14 <bobzhang> wavewave: no
20:14:19 <bobzhang> wavewave: i don't want to install
20:14:34 <bobzhang> wavewave: I just want to experiment some new features in ghc-7.4
20:14:59 <bobzhang> or the best practice of keeping 2 ghcs?
20:16:11 <ClaudiusMaximus> mdxbhmt: started tonight at 1m50s, went up to 2m50s when i switched to hp2any-core, after hacking on that a fair bit, the same test input now takes 10s
20:16:40 <ClaudiusMaximus> mdxbhmt: in comparison, hp2ps take 32s
20:16:48 <wavewave> bobzhang : I usually configure --prefix=desireddirectory
20:16:59 <wavewave> bobzhang: and make and make install
20:17:22 <bobzhang> wavewave: oh, thank you, but it's too late, it takes me 2 hours to compile...
20:17:59 <mdxbhmt> ClaudiusMaximus: this makes me think that you should be able to comment about the performance of hackage modules
20:21:27 <ClaudiusMaximus> mdxbhmt: i'll send the patches to the maintainer
20:31:05 <napping> bobzhang: have you tried "find"?
20:39:48 <tkahn> hi all. what's the best way to install profiling libraries for the packages you already cabal installed?
20:40:18 <wavewave> tkahn: that's messy. you need to cabal install --reinstall
20:40:23 <tkahn> oh god
20:40:25 <tkahn> for every one?
20:40:30 <shachaf> Yes.
20:40:37 <wavewave> afaik
20:40:52 <wavewave> that's one of top-requested feature for cabal
20:40:57 <tkahn> i see
20:41:02 <tkahn> okay.jpg off i go
20:41:09 <napping> might take a while, but with ghc-pkg list you should be able to automate
20:42:10 <tkahn> i'll see if i can do it with a bash script
20:43:14 <shachaf> Or ~/.cabal/world
20:43:36 <shachaf> Of course, that won't handle dependencies.
20:43:41 <shachaf> If you can get cabal to give you the dependency information, you might be able to tsort it. :-)
20:44:28 <napping> Can't you just list everything on one big cabal command line?
20:44:42 <wavewave> in fact, I made that script.
20:45:11 <shachaf> napping: Oh, maybe you can.
20:45:56 <wavewave> if you want, check my code : http://www.github.com/wavewave/devadmin
20:47:26 <wavewave> it has some code which get get dependency information and top sort from cabal files.
20:49:48 <Saizan> it's not like this does much more than rm -fr ~/.ghc/ and reinstalling the packages you actually need with -p (which will also recompile their deps automatically)
20:50:07 <Saizan> since it will also rebuild the vanilla binaries as well
20:54:59 <tkahn> Saizan: good point
20:58:08 * hackagebot hp2pretty 0.5 - generate pretty graphs from heap profiles  http://hackage.haskell.org/package/hp2pretty-0.5 (ClaudeHeilandAllen)
21:18:31 <NemesisD> hi all. i'm trying to write a function and i'm starting to get the impression that what i'm doing is impossible, i wanted to make sure
21:19:21 <shachaf> NemesisD: It's impossible.
21:19:24 <NemesisD> given a list of string keys, it would recurse into some nested Maps (with string keys) and retreive the value or Nothing
21:19:50 <shachaf> NemesisD: Can you give the type of the function and some examples?
21:20:00 <NemesisD> i.e. deepValue ["first key", "nested key", "nesteder key"] someMap
21:20:16 <NemesisD> the type elludes me
21:20:29 <NemesisD> eludes*
21:21:24 <NemesisD> aeson has a type: data Value = Object Object | ...., type Object = Map Text Value
21:22:06 <Axman6> NemesisD: you might want something like: data NestMap a = Map String (Either (NestMap a) a), deepValue :: [String] -> NestMap a -> Maybe a
21:22:17 <Axman6> I think that would work
21:22:28 <Axman6> hmm, maybe not
21:22:51 <Axman6> well, it depends if you want ["foo","bar"] and ["foo","bar","baz"] to both be able to return values
21:23:31 <NemesisD> hmm, im thinking it would be able to take a list of strings of any length
21:23:37 <Axman6> if you do, then you might like: (i should have used type before I think) type NestMap a = Map String (NestMap a, Maybe a)
21:23:41 <NemesisD> and actually this might not be so hard now that i look at how Value/Object are defined
21:24:04 <Axman6> well, the recursive nature of that type means you can go to any arbitrary depth
21:24:20 <NemesisD> im thinking foldM might be involved to take advantage of Maybe's Monad instance
21:25:35 <napping> If it's Object at every level it should be possible. It would be hard if the maps could have different types
21:28:42 <NemesisD> hmm i think i might have it
21:31:08 <NemesisD> ill paste my code as soon as i verify it actually works :P
21:37:12 <tkahn> just finished installing profiling libraries
21:37:15 <tkahn> whew
21:41:22 <NemesisD> woo!
21:42:35 <hpaste> NemesisD pasted “deepValue” at http://hpaste.org/52638
21:43:07 <NemesisD> might be a more elegant way to define it though
21:48:02 <ClaudiusMaximus> wrote a blog post about tonight's profiling+optimisation adventures http://claudiusmaximus.goto10.org/cm/2011-10-15_hp2pretty-0.5_released.html
21:50:31 <tkahn> CladiusMaximus: i'll check that out
21:50:50 <tkahn> happens to be the case that i'm doing that right now
21:52:17 <BMeph> Is there a place that goes more in-depth into the whole strict/non-strict/lazy eval argument, than augustss' blog?
21:52:51 <ClaudiusMaximus> it probably lacks crucial detail on how to actually profile - for heap profiles its +RTS -hT  (if not compiled for profiling) or +RTS -h (if compiled with profiling); for time/allocation it's +RTS -p
21:52:57 <NemesisD> naming infix operators is hard
21:53:32 <BMeph> I liked the conversation as it started, I just wish there had been twenty-odd more responses to it.
21:54:12 <tkahn> ClaudiusMaximus: the info on haskell.org is actually very easy to follow, probably just a link to that would suffice
21:54:38 <ClaudiusMaximus> tkahn: cool, any specific page in mind?
21:55:07 <tkahn> well i've been focusing on memory so this one has been helpful: http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
21:55:47 <tkahn> it gives links to the relevant pages for accomplishing this task
21:55:47 <ClaudiusMaximus> ok, i'll add it
21:55:58 <tkahn> the _only_ thing that's not really explained is how to recompile all your packages with profiling libraries turned on
21:56:08 <Maxdamantus> I saw an O(n) infix operator-naming algorithm once.
21:56:57 <tkahn> i basically wrote  bash script to recompile all packages listed by ghc-pkg with profiling libraries
21:57:06 <tkahn> that took about a half hour
22:00:21 <Axman6> ClaudiusMaximus: that was a pretty cool blog post.
22:03:03 <ClaudiusMaximus> Axman6: thanks :)
22:03:10 <Axman6> ClaudiusMaximus: reddited!
22:04:14 <fazzone> :t \a b c -> a >>> (b &&& c)
22:04:15 <lambdabot> forall (cat :: * -> * -> *) a b c c'. (Arrow cat) => cat a b -> cat b c -> cat b c' -> cat a (c, c')
22:07:58 <napping> BMeph: what was interesting?
22:09:10 <napping> One thing is that Harper only talks about the semantics of the domains of values, apparently not caring at all about what equations hold of expressions
22:10:40 <napping> Also, claiming lazy evaluation "doesn't have coproducts" is justifiable because the relevant diagrams have solutions, just not unique ones
22:11:04 <napping> strict evaluation "doesn
22:11:06 <napping> doesn
22:11:30 <napping> doesn't have products because you just can't define fst so that fst (e1,e2) is always equivalent to e1
22:12:59 <napping> well, the thing about domains of values was his complaint about natural numbers
22:18:36 <anacrolix> y u no, y?
22:20:52 <Axman6> y u y u no, y?
22:24:36 <fazzone> How is    a >>> b >>> (x &&& y)    different from    a >>> ((b >>> x) &&& (b >>> y))    ?
22:26:02 <Axman6> it probably isn't
22:26:14 <Axman6> :t \a b c -> a >>> b >>> (x &&& y)
22:26:15 <lambdabot>     Couldn't match expected type `cat b c' against inferred type `Expr'
22:26:16 <lambdabot>     In the first argument of `(&&&)', namely `x'
22:26:16 <lambdabot>     In the second argument of `(>>>)', namely `(x &&& y)'
22:26:28 <Axman6> except that it makes no sense =)
22:26:36 <Axman6> :t (>>>)
22:26:37 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
22:26:39 <Quantumplation> hrm.  I'm really confused as to what fmap (fst &&& (:[])) list is doing, where list is of the form [(Integer, Integer)]
22:26:43 <napping> the first expects b to process a pair of things
22:28:06 <fazzone> :t map (fst &&& (:[]))
22:28:07 <lambdabot> forall a b. [(a, b)] -> [(a, [(a, b)])]
22:28:41 <Quantumplation> well, i mean I can see how it's transforming the data, but i'm trying to understand what it means
22:29:54 <fazzone> napping: how is that?  my ghci gives me the same type signature for both of them
22:30:02 <Quantumplation> hoogling &&& doesn't help, it just describes it as "fanout"
22:30:15 <Quantumplation> oh wait...
22:30:17 <Quantumplation> it just clicked
22:30:25 <fazzone> (f &&& g) x = (f x, g x)
22:30:40 <Quantumplation> yup, that's awesome
22:31:33 <Quantumplation> wow, that's really freaking clever to use with Map.fromListWith
22:32:23 <Balahla> Need help: I need to work with UTF-8. How do I do that?
22:34:32 <mauke> define "work with"
22:35:13 <mauke> :t \a b x y -> a >>> b >>> (x &&& y)
22:35:13 <lambdabot> forall (cat :: * -> * -> *) a b b1 c c'. (Arrow cat) => cat a b -> cat b b1 -> cat b1 c -> cat b1 c' -> cat a (c, c')
22:35:25 <mauke> :t \a b x y -> a >>> ((b >>> x) &&& (b >>> y))
22:35:26 <lambdabot> forall (cat :: * -> * -> *) a b b1 c c'. (Arrow cat) => cat a b -> cat b b1 -> cat b1 c -> cat b1 c' -> cat a (c, c')
22:35:58 <Balahla> Store and read text in UTF-8, like: ã ç é, etc.
22:36:15 <Axman6> > "like: ã ç é, etc."
22:36:15 <mauke> via Handles?
22:36:15 <lambdabot>   "like: \227 \231 \233, etc."
22:36:25 <Axman6> > text "like: ã ç é, etc."
22:36:26 <lambdabot>   like:
22:36:32 <Axman6> hmm
22:38:56 <Axman6> Balahla: UTF-8 should work without problem as far as i know. Haskell strings have always been more than a stream of 8 bit chars
22:39:25 <Balahla> Gona try. Thanks.
22:43:40 <Maxdamantus> It needs to know somehow that whatever your source is, is UTF-8.
22:48:32 <Veinor> is there a more idiomatic way to write case xs of [] -> foo; _ -> bar; ?
22:49:40 <Veinor> other than if null xs then foo else bar
22:49:46 <Cale> Veinor: apart from leaving out the last semicolon, not really
22:49:59 <mauke> write a function for it
22:50:18 <Cale> (semicolon is a separator, not a terminator)
22:50:54 <shachaf> foldr (\_ _ -> foo) bar
22:50:56 <geheimdienst> Veinor: do foo and bar use xs?
22:51:44 <Veinor> nope
22:56:38 <Quantumplation> hrm.  Map.fromListWith (++) [(0,[(0,1)]),(0,[(0,2)]),(0,[(0,3)])] results in [(0, [(0,3),(0,2),(0,1)])].  In other words, it switches the order.  This isn't a big deal, i'm just trying to understand why that happens
23:15:27 <geheimdienst> Quantumplation: i don't know specifically about haskell's Map, but normally map datastructures don't guarantee you an order. their point is that given a key they can retrieve a value. the keys however don't need to be ordered or anything like that
23:17:09 <Veinor> https://github.com/veinor/snap-login-example
23:18:40 <Quantumplation> well, it's not the keys that it's reversing.  In my example, essentially (k, value), where value is of type [(int,int)].  fromListWith takes the keys, and joins all the values together based on some function, so in this case, it takes every instance of the key 0, takes the value [(0,1)] and [(0,2)] and [(0,3)], and merges them together with ++
23:18:50 <Quantumplation> but, for some reason it's reversing the order of the values
23:19:23 <Quantumplation> so instead of doing [(0,1)] ++ [(0,2)] ++ [(0,3)] it's doing [(0,3)] ++ [(0,2)] ++ [(0,1)] which seems odd to me
23:21:40 <Veinor> Quantumplation: it's because of the way insertWithKey works
23:21:47 <Veinor> it combines the keys with f new old, not f old new
23:22:02 <Cale> which is probably the wrong thing to do
23:22:06 <shachaf> geheimdienst: Haskell's Data.Map has a notion of an "index", but it's not clear what guarantees it gives for indices.
23:22:20 <Cale> (but it doesn't really matter all that much)
23:22:22 <Veinor> Cale: possibly? it makes using cons as the combiner simple
23:22:36 <Cale> Oh, I suppose it does.
23:22:51 <Cale> Er, does the type allow for that?
23:23:02 <Axman6> Quantumplation: insertListWith (flip (++))
23:23:18 <Veinor> oh, you're right, the type doesn't work that way
23:23:24 <Veinor> i dunno then!
23:23:49 <Axman6> :t M.insertListWith
23:23:49 <lambdabot> Couldn't find qualified module.
23:23:55 <Axman6> :t insertListWith
23:23:56 <lambdabot> Not in scope: `insertListWith'
23:24:04 <Axman6> :t Map.insertListWith
23:24:05 <lambdabot> Couldn't find qualified module.
23:24:11 <Axman6> -_-
23:24:17 <Axman6> :t Data.Map.insertListWith
23:24:18 <lambdabot> Not in scope: `Data.Map.insertListWith'
23:24:40 <Axman6> suck a pointer lambdabot
23:24:58 <Quantumplation> Axman6: Yea, that's what I ended up doing, I was just trying to understand why it did it in the first place, so it didn't come back to bite me in the ass :)
23:30:13 <Quantumplation> =D yay, i think this code works.  can someone look it over for me?  I'm trying to tie the knot, and i'm not exactly sure how to verify that it's not just creating a new copy of the edge/node each time I traverse the graph... http://hpaste.org/52642
23:32:08 <Veinor> Quantumplation: i can't take a look, but you can use Debug.Trace.trace to check whether you're actually tying the knot
23:32:40 <Quantumplation> how do I use that? i've never used the debugger in haskell heh
23:32:41 <Veinor> http://www.haskell.org/haskellwiki/Tying_the_Knot#Introduction something like this
23:33:11 <Veinor> trace :: String -> a -> a
23:33:20 <Veinor> trace outputs the string and evaluates to the second argument
23:33:40 <Veinor> (it's unsafe, which is why it's a debug function ;) )
23:36:17 <tkahn> I have a design question
23:36:22 <Veinor> shoot
23:36:28 <tkahn> thanks
23:38:09 <tkahn> ok let's say I have function that takes an Index, does some IO based on that Index, and returns some data and an Index which we can plug into the next call to the function
23:38:34 <tkahn> to get more data from IO and another Index
23:38:38 <Axman6> sounds like a state monad
23:38:42 <tkahn> i know right
23:39:00 <tkahn> but i'm struggling to see how i can actually do that
23:39:12 <tkahn> i'm doing it via tail recursion right now
23:39:44 <Veinor> so you have an Index -> IO (Output, Index)?
23:39:57 <tkahn> Request -> Maybe FeedbackIndex -> IO [Data] -> IO [Data]
23:40:01 <tkahn> that's what i have right now
23:40:03 <tkahn> as a helper function
23:40:15 <shachaf> @unmtl StateT Index IO Output
23:40:16 <lambdabot> Index -> IO (Output, Index)
23:40:40 <tkahn> i was looking at the StateT
23:40:52 <tkahn> so using a regular State monad wouldn't work?
23:41:13 <shachaf> Well, if you're doing IO on each step, no.
23:41:18 <tkahn> perfect
23:41:19 <shachaf> It depends on what you mean by "doing IO", though.
23:41:27 <tkahn> i mean talking to the internet
23:41:32 <shachaf> If you're only doing output, for example -- oh.
23:42:01 <tkahn> and btw this computation continues until Index is Nothing
23:42:26 <tkahn> @unmtl StateT (Maybe Index) IO Output
23:42:27 <lambdabot> Maybe Index -> IO (Output, Maybe Index)
23:43:05 <shachaf> That sounds a bit like an unfold or something.
23:43:06 <tkahn> ok i'll see if i can figure this out
23:43:08 <Veinor> this sounds like an unfold
23:43:11 <tkahn> ohh
23:43:16 <tkahn> idk what that is
23:43:21 <Veinor> :t unfold
23:43:22 <lambdabot> Not in scope: `unfold'
23:44:02 <Veinor> unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
23:44:05 <tkahn> oh yeah that does sound like that
23:44:14 <Axman6> :t unfoldM
23:44:15 <lambdabot> Not in scope: `unfoldM'
23:44:22 <Axman6> :t unfoldrM
23:44:23 <lambdabot> Not in scope: `unfoldrM'
23:44:30 <Axman6> @hoogle unfold
23:44:31 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
23:44:31 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
23:44:31 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
23:44:35 <Axman6> @more
23:44:40 <Axman6> :(
23:44:43 <Veinor> http://hackage.haskell.org/packages/archive/monad-loops/0.3.0.2/doc/html/Control-Monad-Loops.html maybe something from this?
23:44:46 <tkahn> there's one in Control.Monad.Loops
23:45:17 <tkahn> nice
23:47:07 <tkahn> thanks for your help guys. i'll see if i can work this out
