00:01:01 <kirindave> Is there an existing implementation of a parallel list monad?
00:09:15 <sdcvv> kirindave: LogicT? or something different?
00:09:48 <kmc> parallel in what sense?
00:10:37 <kmc> in the sense of "visits all possibilities even on infinite lists" there's http://hackage.haskell.org/package/control-monad-omega
00:10:45 <kmc> in the sense of "parallel evaluation" there's http://hackage.haskell.org/package/parallel-tree-search
00:32:29 <vharishankar> I am a bit confused about what the . operation is for. for example
00:32:39 <vharishankar> > not . all (>0) [1, 2, 3]
00:32:39 <lambdabot>   Couldn't match expected type `f GHC.Bool.Bool'
00:32:40 <lambdabot>         against inferred typ...
00:32:45 <vharishankar> Doesn't work while
00:32:53 <vharishankar> not (all (>0) [1,2,3])
00:33:01 <vharishankar> > not (all (>0) [1,2,3])
00:33:02 <lambdabot>   False
00:33:06 <vharishankar> works
00:33:16 <byorgey> vharishankar: not . all (>0) [1,2,3]   is parsed as   not . (all (>0) [1,2,3])
00:33:23 <kmc> @src (.)
00:33:24 <lambdabot> (f . g) x = f (g x)
00:33:24 <lambdabot> NB: In lambdabot,  (.) = fmap
00:33:26 <byorgey> you need parentheses around (not . all)
00:33:43 <kmc> (f . g)  evaluates to the function  (\x -> f (g x))
00:33:44 <byorgey> oh, wait, that won't work either
00:33:47 <vharishankar> byorgey: thanks.
00:34:11 <byorgey> let's try:
00:34:18 <byorgey> (not . all) (>0) [1,2,3]
00:34:42 <vharishankar> > (not . all) (>0) [1, 2, 3]
00:34:43 <lambdabot>   Couldn't match expected type `t1 -> t'
00:34:43 <lambdabot>         against inferred type `GHC.B...
00:34:50 <byorgey> == ((not . all) (>0)) [1,2,3]  -- function application associates to the left
00:34:55 <kmc> > (not . all (>0)) [1,2,3]
00:34:57 <lambdabot>   False
00:35:14 <byorgey> == (not (all (>0)) [1,2,3]
00:35:43 <kmc> > any (not . (>0)) [1,2,3]
00:35:44 <lambdabot>   False
00:36:18 <vharishankar> kmc: got a bit confused about the associativity.
00:37:01 <vharishankar> I am having more trouble trying to understand foldl and foldr hm.
00:38:12 <vharishankar> filter (/= []) ["harishankar", "", "is", "", "a", "nice", "", "person"]
00:38:20 <vharishankar> > filter (/= []) ["harishankar", "", "is", "", "a", "nice", "", "person"]
00:38:21 <lambdabot>   ["harishankar","is","a","nice","person"]
00:38:46 <vharishankar> I understand filters and map, but folding is confusing me...
00:39:51 <kmc> > foldr f z [a,b,c]
00:39:51 <lambdabot>   f a (f b (f c z))
00:39:55 <kmc> @where folds
00:39:55 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
00:42:36 <vharishankar> kmc, I am confused as to how to use foldl or foldr when not in the function definition. e.g. when I simply want to apply it to the list.
00:42:57 <kmc> > foldr (+) 0 [1,2,3]
00:42:57 <lambdabot>   6
00:43:13 <vharishankar> Oh, thanks. that was where I got confused
00:43:43 <vharishankar> foldr1 (++) ["harishankar", "is", "good"]
00:43:48 <vharishankar> > foldr1 (++) ["harishankar", "is", "good"]
00:43:49 <lambdabot>   "harishankarisgood"
00:44:05 <vharishankar> > foldr1 (++" ") ["harishankar", "is", "good"]
00:44:06 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> [GHC.Types.Char]'
00:44:06 <lambdabot>        ...
00:44:37 <vharishankar> > foldr1 (++[" "]) ["harishankar", "is", "good"]
00:44:38 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]
00:44:38 <lambdabot>                           ...
00:44:43 <kmc> :t (++" ")
00:44:44 <lambdabot> [Char] -> [Char]
00:44:44 <kmc> :t foldr1
00:44:45 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
00:45:02 <kmc> > foldr1 ((++) . (++" ")) ["harishankar", "is", "good"]
00:45:03 <lambdabot>   "harishankar is good"
00:45:18 <kmc> > foldr1 ((++) . (' ':)) ["harishankar", "is", "good"]
00:45:19 <lambdabot>   " harishankar isgood"
00:46:12 <vharishankar> kmc: thanks for the illustrations. Still confess I am not quite sure what you did there.
00:46:52 <kmc> > let f x y = (x ++ " ") ++ y in f "foo" "bar"
00:46:54 <lambdabot>   "foo bar"
00:46:56 <kmc> makes sense?
00:47:11 <kmc> > let f x y = (x ++ " ") ++ y in foldr1 f ["foo", "bar", "baz"]
00:47:13 <lambdabot>   "foo bar baz"
00:47:25 <ddarius> > unwords ["foo", "bar", "baz"]
00:47:26 <lambdabot>   "foo bar baz"
00:47:34 <kmc> > let f x = ((x ++ " ") ++) in foldr1 f ["foo", "bar", "baz"]
00:47:35 <lambdabot>   "foo bar baz"
00:47:39 <vharishankar> kmc: trying to figure it out...
00:47:48 <kmc> > let f = (++) . (++" ") in foldr1 f ["foo", "bar", "baz"]
00:47:49 <lambdabot>   "foo bar baz"
00:48:47 <kmc> the four examples do the same thing; the first is easiest to understand, the last is closest to what i wrote
00:49:06 <kmc> well three examples
00:49:27 <vharishankar> The one with specific variables makes sense
00:49:55 <kmc> (a ++) is sugar for (\y -> a ++ y)
00:50:24 <kmc> so «f x = ((x ++ " ") ++)»  ⇒  «f x = \y -> (x ++ " ") ++ y»   ⇒  «f x y = (x ++ " ") ++ y»
00:50:35 <vharishankar> kmc: OK... so instead of lambda function you just use the operations.
00:50:43 <kmc> not sure what you mean
00:51:03 <kmc> the syntax (e +) and (+ e), for expression e and operator (+), is called a "section"
00:51:09 <kmc> it's syntactic sugar provided by Haskell
00:51:17 <kmc> not something you could figure out from the other rules of the language
00:51:41 <vharishankar> kmc: ok, thanks. I meant as a shortcut. like we use a++ instead of a  = a + 1 in imperative languages
00:52:51 <kmc> they're both shortcuts
00:52:53 <kmc> not very similar ones
00:54:27 <vharishankar> I will try to construct some folds myself to try to wrap my head around this.. it seems simple, but somewhere I am confused by the syntax.
00:55:47 <vharishankar> Of course, the LYAH book makes everything seem easy. :-(
00:58:27 <vharishankar> If I might be bold enough to make a slight criticism of LYAH, I think there are not enough varied examples for the same concept.
00:59:13 <kmc> i think the author is glad to receive feedback
00:59:25 <kmc> goes by the nick BONUS, here occasionally
01:00:52 <vharishankar> kmc: thanks. While I think I can understand a concept, I feel that illustrating something in two wholly different applications will solidify it a bit more. Maybe that was why I couldn't get folds, in spite of understanding what it is about. ??
01:01:21 <vharishankar> I hope that was coherent.
01:01:57 <kmc> makes sense to me
01:02:24 <vharishankar> kmc: thanks. I put is as best as I could. :-)
01:02:51 <vharishankar> kmc: This is what I find a bit frustrating in general. Understanding the theory and then knowing how to put it to use.
01:03:01 <vharishankar> Not the same thing.
01:04:03 <vharishankar> Part of the time, it's about not understanding the syntax. The other part, I believe, is because I still am not confident about HOW currying works. The type system also occasionally trips me up.
01:04:42 <kmc> i think in the case of folds, you can find many examples online outside of LYAH
01:04:50 <kmc> vharishankar, I can explain how currying works.  it is very straightforward
01:05:06 <vharishankar> kmc: will definitely look at those examples. :-)
01:05:11 <kmc> «\x y -> ...» means the same thing as «\x -> \y -> ...»
01:05:17 <kmc> the former is just shorthand for the latter
01:05:26 <kmc> likewise (f x y) is shorthand for ((f x) y)
01:05:34 <kmc> that's all there is to currying, fundamentally
01:05:41 <kmc> you do have to get used to it
01:06:18 <vharishankar> kmc: thanks... I read about how functions have only a single parameter... is that something to do with currying?
01:06:54 <kmc> yes
01:07:18 <kmc> notice that «\x y -> ...» looks like it has two parameters but «\x -> ...» and «\y -> ...» have only one
01:07:48 <kmc> it's not quite correct to think of currying as a language feature
01:07:54 <kmc> it's more a style which Haskell syntax pushes you towards
01:08:20 <kmc> there's an alternative way,  \(x,y) -> ...
01:08:29 <kmc> this is also a one-argument function; that argument is a pair
01:08:41 <kmc> this is the "uncurried" style
01:08:41 <kmc> but the syntax encourages you to do it the other way
01:08:47 <vharishankar> kmc: ok. That is a tuple ?
01:08:49 <kmc> yeah
01:08:54 <kmc> "pair" means "2-tuple"
01:08:58 <kmc> "tuple with 2 elements"
01:09:24 <vharishankar> got it. so you can pass tuples instead of currying
01:09:32 <vharishankar> but it's not encouraged.
01:09:34 <kmc> right
01:09:38 <kmc> it makes sense in some contexts
01:09:55 <kmc> if you define «f x y = ...» then you can do things like «map (f 2) ...»
01:10:13 <kmc> it's sometimes called "partial application" but it's really just ordinary function application
01:10:16 <vharishankar> kmc: are partial functions totally unrelated? Not yet sure of what it means...
01:10:27 <kmc> "partial application" and "partial function" mean unrelated things
01:10:42 <kmc> "partial function" is a function which might not return a value
01:10:48 <kmc> (because it throws an exception or loops forever)
01:10:51 <vharishankar> kmc: OK.
01:11:09 <kmc> anyway if you say «f (x,y) = ...» then you cannot do «map (f 2) ...»
01:11:22 <vharishankar> kmc: OK.
01:11:24 <kmc> so that's one way the curried style is encouraged
01:11:40 * shachaf considers playing the "curry" pedant.
01:11:45 <kmc> you'd have to do «map (\y -> f (2,y)) ...»
01:11:56 <kmc> except, there are already functions in the stdlib for going between the two styles
01:11:59 <kmc> (at least in the 2-argument case)
01:12:01 <kmc> :t curry
01:12:01 * shachaf decides against it.
01:12:01 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
01:12:03 <kmc> :t uncurry
01:12:04 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
01:12:29 <kmc> so if you had «f (x,y) = ...» you could do «map (curry f 2) ...»
01:12:43 <kmc> (curry f 2) being ((curry f) 2), which is itself an example of the curried convention :)
01:13:38 <vharishankar> kmc: my head is spinning slightly, but I am sure I will get it eventually. :-)
01:14:48 <vharishankar> kmc: another unrelated thing. The $ operator is used to force evaluate the Right hand expression correct?
01:15:14 <vharishankar> Sorry, above question is addressed at everybody in general. :-)
01:15:29 <shachaf> vharishankar: The $ operators purpose is only syntactic.
01:15:36 <shachaf> s/ors/or's/
01:15:53 <vharishankar> :t $
01:15:53 <lambdabot> parse error on input `$'
01:15:56 <shachaf> "a b $ c d" === "(a b) (c d)"
01:16:02 <shachaf> :t ($)
01:16:02 <lambdabot> forall a b. (a -> b) -> a -> b
01:16:06 <kmc> no it's not about forcing evaluation
01:16:09 <shachaf> @src ($)
01:16:09 <lambdabot> f $ x = f x
01:16:10 <vharishankar> shachaf: OK.
01:16:20 <kmc> it's just a low-precedence infix operator
01:16:24 <kmc> with the definition lambdabot just gave
01:16:30 <vharishankar> kmc: right.
01:16:31 <kmc> you can use it to remove parentheses
01:16:35 <kmc> but you can also use it as a section
01:16:38 <kmc> > map ($ 3) [succ, pred]
01:16:39 <lambdabot>   [4,2]
01:16:54 <kmc> you may be thinking of ($!)
01:16:57 <kmc> @src ($!)
01:16:57 <lambdabot> f $! x = x `seq` f x
01:17:05 <vharishankar> kmc: OK right.
01:17:11 <kmc> this does force extra evaluation in a particular way
01:17:20 <kmc> forcing (f $! x) will force x even if f itself would not
01:17:31 <kmc> > (const ()) $ undefined
01:17:32 <lambdabot>   ()
01:17:34 <kmc> > (const ()) $! undefined
01:17:34 <lambdabot>   *Exception: Prelude.undefined
01:17:55 <kmc> note that all forcing rules are relative.  "forcing foo will also force bar"
01:17:57 <vharishankar> >> product $ [1, 2, 3, 4]
01:18:04 <kmc> there's no way to force something absolutely
01:18:10 <vharishankar> product $ [1, 2, 3, 4]
01:18:21 <kmc> that is, there's no expression e you can put in «let x = e in ()» such that e will be evaluated
01:18:40 <kmc> the prime mover in Haskell is that the runtime system will force 'main' in order to figure out which IO to perform
01:18:56 <vharishankar> kmc: OK.
01:20:04 <vharishankar> Is it a common thing to feel a bit confused AFTER spending some time learning Haskell?
01:20:23 <kmc> oh yes
01:20:43 <kmc> i gave you a lot of info just now and it wasn't all relevant
01:20:51 <kmc> i mean you asked about ($) and I went off on a tangent about ($!)
01:20:54 <vharishankar> kmc: That is reassuring.
01:21:35 <vharishankar> I am not sure whether I am confused or not about lazy evaluation, but I think eventually I will. :-)
01:21:39 <kmc> i hope you are at least finding the confusion rewarding :)
01:21:59 <vharishankar> kmc: Of course. Being confused actually means I am beginning to understand.
01:22:12 <vharishankar> If I am not confused, it means I don't know the concept enough to feel confused. :-)
01:23:45 <ming_> Hey, does anyone know how I can check if a is an element in a list?
01:23:50 <kmc> :t elem
01:23:51 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
01:23:57 <kmc> vharishankar, quite true
01:24:43 <vharishankar> kmc: And I've not even started on monads yet! :-)
01:25:01 <vharishankar> Functors, monoids, etc.
01:26:21 <kmc> *nod*
01:26:34 <kmc> each of those concepts is pretty simple
01:26:47 <kmc> but abstract, so it's hard to form valid intuitions
01:26:58 <augur> aristid: you're german right?
01:27:02 <kmc> and there are a lot of prerequisite concepts
01:27:05 <vharishankar> kmc: thanks.
01:27:32 <vharishankar> I guess I should become more comfortable before I approach them, correct?
01:27:37 <kmc> i see a lot of people who try to understand monads without knowing how type classes or higher-order functions work... that's not going to fly
01:27:38 <kmc> yeah exactly
01:27:46 <kmc> you're taking the long route, which is good :)
01:28:22 <vharishankar> kmc: yes. I also try to write a simple Haskell program whenever I learn something new, and which uses that concept.
01:28:31 <vharishankar> on my own, without reading tutorials.
01:28:49 <kmc> that's very good
01:29:44 <ming_> thank you kmc
01:29:55 <vharishankar> kmc: glad to know that. It is a slow method, but because I learn for fun, I find it rewarding.
01:30:01 <kmc> i think most programmers never have to understand a concept as simple-yet-abstract as monads
01:30:49 <kmc> but it's no worse than the first day of abstract algebra
01:30:57 <vharishankar> kmc: most programmers would say "asbtract" and "simple" are oxymorons.
01:31:09 <kmc> which is something loads of college sophomores get through every year
01:31:16 <kmc> vharishankar, that's a shame if true
01:31:27 <kmc> because the whole point of abstraction in programming is to provide a simple interface to complicated internals
01:31:40 <kmc> and it's one of the most important ideas
01:31:42 <vharishankar> kmc: I mean, most programmers are taught to use abstractions, but not necessary know how they work.
01:31:56 <kmc> surely they're expected to implement abstractions from time to time
01:32:08 <kmc> even the most banal Java business code has to implement abstractions
01:32:16 <kmc> otherwise these Design Patterns would not be such a big deal
01:32:48 <vharishankar> Of course, but it is easy to write working code without all that. And that's what a lot of people end up doing, I guess. I should not be judgemental though.
01:32:56 <kmc> maybe it's true that they are told what abstractions to implement by an architect with a fancy degree
01:32:57 <kmc> yeah
01:33:05 <kmc> ball of mud design :)
01:33:17 <kmc> i would say it is easy to write mostly-working code that way
01:33:27 <kmc> but very hard to write working code, or to modify what you have produced
01:34:11 <vharishankar> kmc: agreed. But the software industry works on the principle of "patching" up problems. :-)
01:37:22 <vharishankar> Anyway, nice chatting with you. :-) I must leave now.
01:37:50 <kmc> farewell vharishankar
01:38:13 <vharishankar> kmc: see you later :-)
01:53:16 <scshunt> the thing that I find most interesting about Haskell's IO exceptions is that, in theory, they do not require special flow control depending on how the IO monad is constructed
02:00:55 <kmc> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html nice
02:11:10 * hackagebot hastache 0.1.6 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.1.6 (SergeyLymar)
02:15:56 <kmc> Eq, Show no longer superclasses of Num in GHC 7.4!
02:16:02 <danr> horray!
02:16:37 <kmc> seems to be the case even with -XHaskell98
02:16:41 <kmc> isn't that wrong?
02:16:57 <danr> that sounds a bit suspicious indeed
02:17:24 <danr> in the 98 report:
02:17:25 <danr> class  (Eq a, Show a) => Num a  where
02:17:31 <danr> http://www.haskell.org/onlinereport/standard-prelude.html
02:17:47 <kmc> *nod* and it can break code, which gives a type signature (Num a) => ..., and uses Eq methods
02:18:00 <kmc> anyway I'm trying to install cabal-install for GHC HEAD
02:18:09 <kmc> latest puzzle: Unacceptable argument type in foreign declaration: CInt
02:19:50 <sefb1704> Hello
02:20:10 <kmc> hi sefb1704
02:20:13 <sefb1704> :)
02:20:49 <sefb1704> one question, i want to set a variable but it wont work :/ i defined it at the beginning of the program but i cant change it later without getting problems
02:21:53 <kmc> that's not how haskell works
02:22:18 <hpaste> sefb1704 pasted “Variable Setting” at http://hpaste.org/53355
02:22:39 <kmc> yikes
02:22:54 <sefb1704> at line 35 i want to change the variable
02:22:58 <kmc> sefb1704, what Haskell tutorial are you following?
02:23:01 <sefb1704> but i cant make this work
02:23:12 <sefb1704> i followed "learn you a haskell" :D
02:23:20 <Jafet> The world's best confusing language.
02:24:11 <sefb1704> basically the code i uploaded is only about line 2, 3 and 35
02:24:35 <sefb1704> set and change variables..
02:25:32 <kmc> you can't use <- at top level like that
02:25:39 <kmc> you can't change the value of an existing variable
02:25:46 <sefb1704> :(
02:25:57 <kmc> how far are you in LYAH?
02:26:14 <Jafet> Will there also be a shorter way to write (Num (Foo (Bar a)), Eq (Foo (Bar a)), Show (Foo (Bar a)))?
02:26:25 <kmc> Jafet, yeah, ConstraintKinds takes care of that
02:26:28 <sefb1704> well i read the part about the variables and stuff and also pretty far in from the beginning on ..
02:26:41 <kmc> sefb1704, you should probably read the whole thing, carefully, in order
02:27:03 <sefb1704> okey. can you also give me a quick solution about my problem?
02:27:06 <kmc> i'm sorry to be blunt but you seem to be confused in ways we cannot clear up in a few words
02:27:13 <kmc> there is no solution to your problem
02:27:16 <sefb1704> aww
02:27:29 <kmc> the solution is to learn how to think in Haskell
02:27:47 <sefb1704> i thought the solution was only a short piece of code
02:28:11 <kmc> i'm sorry
02:28:20 <kmc> Haskell is a very different language
02:28:35 <sefb1704> so you say if i fully read the "LYAH" i will be able to fix this?
02:28:39 <kmc> yes
02:28:41 <Jafet> You can pass “knife” and “wood” as parameters to your functions, or make them IORefs (variables in IO)
02:28:42 <sefb1704> oh great
02:28:51 <kmc> you should probably represent the state with parameters to a recursive function call
02:28:56 <kmc> rather than explicitly setting variables
02:29:15 <sefb1704> ok so i will simply read this thing..
02:29:21 <kmc> cool :)
02:29:29 <Jafet> Okay, they're not functions, but you'd make them functions.
02:29:47 <sefb1704> thanks for your help guys, have a nice day :*
02:29:52 <kmc> you too :)
02:29:58 <Jafet> By the way, “do clearance” is redundant; “clearance” is already an IO action and you're already running it in IO
02:30:05 <Jafet> So you should read about how IO works
02:30:25 <Jafet> @undo do x;
02:30:25 <lambdabot> x
02:30:37 <kmc> Jafet, type Stuff a = (Num (Foo (Bar a)), Eq (Foo (Bar a)), Show (Foo (Bar a)))
02:30:48 <Jafet> kmc: cool
02:30:49 <kmc> f :: (Stuff a) => ...
02:30:54 <kmc> yeah it's slick
02:31:19 <kmc> 7.4 has loads of goodies
02:31:29 <Jafet> Hmm, I don't understand why they re-use the “type” keyword though
02:31:33 <bartavelle> is there a prelude fonction for  [a] -> [(a,a)], such as [1,2,3,4] -> [(1,2),(2,3),(3,4)] (pairs of adjacent members)
02:31:56 <kmc> > let f xs = zip xs (tail xs) in f [1,2,3,4]
02:31:57 <lambdabot>   [(1,2),(2,3),(3,4)]
02:32:03 <bartavelle> ah smart
02:32:08 <kmc> Jafet, yeah, it is kind of weird
02:32:16 <kmc> constraints are now "types" of kind Constraint
02:32:24 <kmc> as are tuples of constraints
02:32:47 <kmc> which is insanely powerful, because they work as type class parameters and with families and GADTs and everything
02:35:02 <kmc> http://hackage.haskell.org/trac/ghc/wiki/Status/Oct11
02:35:17 <Jafet> I guess I still don't understand why, but at least I understand that it can be understood
02:35:46 <kmc> there is already a ton of machinery for working with types
02:36:09 <kmc> reusing it for constraints gives a lot of power for free, with few new things to learn
02:36:13 <kmc> thought it also makes me uneasy
02:36:47 <kalven> like a monday morning?
02:38:37 <kmc> Jafet, for example it lets you make Data.Set a Monad, even though (>>=) requires (Ord a)
02:38:55 <kmc> by adding to the Monad class an associated type of kind Constraint
02:39:08 <kmc> which would be instantiated to () for all existing Monads
02:39:22 <kmc> and (Ord a) for Set
02:39:30 <o-_-o1> if I have a list [4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,0], what is fastest way to take the alternate elements ?
02:39:31 <kmc> and then you add that constraint to (>>=)
02:39:52 <o-_-o1> that is I want a list of [4,6,8,..]
02:40:06 <kmc> fastest for you to write? or fastest for it to run?
02:40:08 <o-_-o1> Whatever I am currently using is too slow
02:40:13 <o-_-o1> fastest for it to run
02:40:28 <o-_-o1> I am using Data.Vector if that is of any help
02:40:57 <kmc> the fastest possible way would involve fabricating a custom processor in silicon at 22 nanometer process
02:40:59 <kmc> what are you using now?
02:41:28 <o-_-o1> (Data.Vector.map Data.Vector.head (splitEvery 2 xs))
02:42:10 <kmc> did you try converting it to a list and back?
02:42:17 <kmc> it might actually be faster, and anyway it will not be hard to try
02:42:33 <kmc> you're building with ghc -O2?
02:42:39 <o-_-o1> umm...no
02:43:15 <o-_-o1> well I did now and that didn't help it much anyway
02:45:05 <kmc> "did now" = compile with -O2?
02:45:21 <Peaker> o-_-o1: ghc might be smart enough to allow writing nicer code than this, but a straightforward loop should probably be fast on lists:  everyOther xs = go0 xs ; where go0 [] = [] ; go0 (x:xs) = x : go1 xs ; go1 [] = [] ; go1 (_:xs) = go0 xs
02:45:33 <Rajko_Grkinic> Hello
02:46:57 <o-_-o1> kmc: yes
02:47:05 <o-_-o1> Peaker: ah
02:55:20 <kmc> o-_-o1, are you sure it recompiled? did you pass -fforce-recomp
02:55:48 <o-_-o1> kmc: I delete all the intermediate and final files and then run the compile command
02:55:54 <o-_-o1> But that is not the problem
02:55:59 <o-_-o1> I think my code is slow
02:56:18 <kmc> it's easier to pass -fforce-recomp but ok
02:56:20 <o-_-o1> but I don't know what part is slow, I have tried profiling it and I can't find anything
03:09:55 <Eduard_Munteanu> It's easier to 'touch' the .hs, if you want to avoid -fforce-recomp :P
03:09:57 <Eduard_Munteanu> (no reason)
03:11:17 <Eduard_Munteanu> o-_-o1: maybe you can paste the profile?
03:12:52 <bartavelle> I would like to parse a language with $hash['access'][$like]["this"], but I'm not sure if I should parse the [ ] operator at the terminal level, or add an operator in the buildExpressionParser table
03:12:58 <bartavelle> actually I'd like to put it in the table
03:13:01 <bartavelle> but I have no clue how
03:13:20 <bartavelle> perhaps as some kind of postfix operator ?
03:13:33 <bartavelle> if anybody has a clue / link to code that does this
03:21:13 * hackagebot hack2-handler-mongrel2-http 2011.10.31 - Hack2 Mongrel2 HTTP handler  http://hackage.haskell.org/package/hack2-handler-mongrel2-http-2011.10.31 (JinjingWang)
03:21:28 <erus`> when is the new platform out?
03:36:41 <gienah> erus`: maybe after thanksgiving (suggestion on mailing list)
03:37:37 <kmc> with GHC 7.2?
03:37:43 <erus`> what date is that?
03:38:01 <kmc> US thanksgiving is 24 November 2011
03:38:21 <erus`> What do americans give thanks for anyway? Stealing land from the natives?
03:38:28 <kmc> yeah pretty much
03:38:30 <gienah> kmc: I don't know, I wonder when ghc 7.4 will be released
03:39:19 <erus`> You have turkey on thanks giving right? We have turkey at christmas
03:39:32 <kmc> yeah
03:39:35 <kmc> turkey on xmas is pretty common in the US too
03:39:41 <kmc> so is chinese food on xmas
03:40:00 <kmc> last year I had A Very Mary Chung Christmas
03:40:34 <kmc> GHC 7.4 may be out soon, but I think the Platform is supposed to lag GHC releases by some months
03:40:42 <kmc> to give library maintainers time to fix their shit
03:41:05 <kmc> 7.2 was supposed to be a "technology preview" before 7.4 but 7.4 adds even more crazy features than 7.2 did
03:41:25 <gienah> ghc 7.4 sounds exciting
03:41:43 <kmc> yeah I just ran GHCi from HEAD and defined a data type at the prompt :D
03:42:03 <gienah> sounds really neat
03:43:04 <joe9> 5
04:11:05 <adimit> the Functor instance for ((->) e) is fmap g a = g.a, and for ((,) e) it's fmap g (e,a) = (e,g a), no? I couldn't find it in Data.Functor's sources…
04:12:00 <mercury^> adimit: those are right.
04:12:03 <ClaudiusMaximus> Control.Monad.Instances (probably)
04:12:25 <adimit> thanks, mercury^, ClaudiusMaximus
04:12:45 <kmc> @djinn (a -> b) -> (e -> a) -> (e -> b)
04:12:45 <lambdabot> f a b c = a (b c)
04:13:04 <kmc> @djinn (a -> b) -> (e,a) -> (e,b)
04:13:04 <lambdabot> f a (b, c) = (b, a c)
04:13:07 <kmc> wooooo
04:14:13 <ddarius> Who needs programmers?
04:15:35 <kmc> @djinn the next facebook
04:15:36 <lambdabot> -- f cannot be realized.
04:15:39 <kmc> :(
04:16:04 <ddarius> Djinn has more sense than most programmers I see.
04:16:29 <kmc> @nixon the next facebook
04:16:29 <lambdabot> A man who has never lost himself in a cause bigger than himself has missed one of life's mountaintop experiences. Only in losing himself does he find himself. Only then does he discover all the
04:16:29 <lambdabot> latent strengths he never knew he had and which otherwise would have remained dormant.
04:16:50 <ddarius> See.
04:17:31 <adimit> @djinn (a -> b) -> Either e a -> Either e b
04:17:31 <lambdabot> f a b =
04:17:31 <lambdabot>     case b of
04:17:31 <lambdabot>     Left c -> Left c
04:17:31 <lambdabot>     Right d -> Right (a d)
04:17:41 <adimit> o_O
04:17:45 <adimit> djinn +1
04:17:46 <ClockFrog> is it usual to create an infinite recursion in a function and reply on the use of the function be coupled with 'take'?
04:18:04 <adimit> ClockFrog: it happens.
04:18:16 <adimit> > take 10 [1..]
04:18:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
04:18:27 <ddarius> ClockFrog's statement just seems like a word jumble to me.
04:18:46 <kmc> @quote ubuntu.freebsd
04:18:46 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
04:19:04 <kmc> i think s/reply/rely/ ?
04:19:11 <ClockFrog> rely not reply*, and yeah should of used grammer =P
04:19:12 <kmc> in that case, yes, it makes sense
04:19:18 <kmc> doesn't even need to be a function
04:19:34 <kmc> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
04:19:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
04:19:54 <adimit> now that's just evil.
04:20:05 <kmc> ClockFrog, when done well it's a nice design; laziness allows you to separate the question of what to produce from the question of how much the consumer wants
04:20:21 <kmc> you get simpler code with fewer parameters
04:20:24 <kmc> adimit, ?
04:20:43 <adimit> kmc: i just really liked the fibs implementation :-)
04:20:54 <kmc> ah that one's boring
04:21:04 <kmc> > fix((0:).scanl(+)1)
04:21:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:21:44 <adimit> … I'm in awe
04:22:32 <kmc> > nubBy(((>1).).gcd)[2..]
04:22:34 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
04:22:58 <kmc> the last one is pretty evil
04:23:18 <adimit> … prime numbers?
04:23:25 <adimit> wow
04:23:40 <kmc> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
04:23:40 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
04:23:54 <opqdonut> :)
04:24:20 <ClockFrog> it just feels weird having a possible infinite recursion if not handled right
04:24:45 <kmc> yeah it feels weird if you're not used to laziness
04:24:50 <kmc> but it's very common in Haskell
04:25:04 <adimit> kmc: tell me you copypasta'd that out of some "how-to-scare-noobs" site and didn't just make it up.
04:25:11 <kmc> the last one is from Uncyclopedia
04:25:11 <ddarius> ClockFrog: We should remove while loops from C.
04:25:21 <adimit> good.
04:25:24 <kmc> the primes one i remembered the general idea but I had to google it
04:25:32 <kmc> the fibs one I remembered and can even explain
04:25:57 <ddarius> The primes one is actually rather intuitive.
04:26:07 <opqdonut> yeah
04:26:15 <kmc> it relies on unspecified behavior of nubBy, doesn't it?
04:26:33 <opqdonut> that too :)
04:26:36 <yitz> @src nubBy
04:26:36 <lambdabot> nubBy eq []             =  []
04:26:36 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:27:13 <kmc> (((>1).).gcd) :: Integral b => b -> b -> Bool  --- this is "is coprime to", right?
04:27:23 <kmc> er, not that
04:27:39 <kmc> not coprime to
04:28:20 <opqdonut> yeah
04:28:54 <kmc> and nubBy wants an equivalence relation, but "is not coprime to" is not one; it's not transitive
04:29:28 <kmc> but the Prelude source for nubBy kind of accidentally has the form of a prime number sieve
04:30:38 <opqdonut> > let divides x y = mod x y == 0 in take 100 $ nubBy divides [2..]
04:30:39 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
04:30:39 <yitz> kmc: i think the report may specify that behavior, though, in which case it's not *that* evil
04:30:51 <opqdonut> that's slightly more well-behaved
04:31:21 <opqdonut> but not an equivalence
04:32:17 <yitz> kmc: at some point there was continue :: [Integer] -> [Integer] in lambdabot that called out to @oeis in the background. now *that* was evil.
04:32:33 <kmc> haha
04:32:41 <kmc> bet that impressed some people
04:32:45 <yitz> sure did!
04:34:55 <opqdonut> :D
04:35:48 <yitz> > nubBy(((==0).).mod)[2..] -- all right then, opqdonut
04:35:51 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
04:36:04 <opqdonut> yeah, sure it can be golfed
04:36:07 <ddarius> <1
04:36:34 <opqdonut> I just wanted to open it up a bit
04:36:47 <kmc> :t (.:)
04:36:48 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
04:37:24 <kmc> > nubBy((<1).:mod)[2..]
04:37:25 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
04:37:44 <kmc> > p
04:37:44 <lambdabot>   Ambiguous occurrence `p'
04:37:45 <lambdabot>  It could refer to either `L.p', defined at <local...
04:37:49 <kmc> bah
04:38:00 <kmc> still, where did the lighter fluid come from
05:01:16 * hackagebot hstzaar 0.8.2 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.8.2 (PedroVasconcelos)
05:01:32 <wwewe> What exactly is HASKELL
05:01:52 <ddarius> @google HASKELL
05:01:54 <lambdabot> http://haskell.org/
05:01:57 <cheater> @faq what is HASKELL?
05:01:57 <lambdabot> The answer is: Yes! Haskell can do that.
05:20:59 <adimit> installing category-extras fails on my machine…
05:21:28 <hpaste> adimit pasted “category-extras” at http://hpaste.org/53357
05:21:35 <kmc> category-extras is deprecated, isn't it
05:21:42 <kmc> i think 'categories' is the new hotness
05:21:46 <kmc> plus various other packages
05:21:54 <adimit> ah, the typeclssopedia references category-extras
05:22:17 <kmc> yeah, it's a fairly old document
05:22:18 <gienah> kmc: yes category-extras is deprecated, and someone other than the author uploaded a bumped one with trivial change
05:22:32 <kmc> you can ask edwardk about the details of the package split
05:22:34 <kmc> he's here regularly
05:22:47 <adimit> but categories doesn't have Pointed. there's the package pointed, though.
05:22:50 <gienah> kmc: thanks
05:23:03 <kmc> that's the likely successor
05:23:50 <adimit> though there the class' function is point, not pure. *mumble*
05:24:21 <kmc> 'pure' is part of Applicative usually
05:28:57 <adimit> anyway, pure = const for Pointed ((->) e), isn't it? (sorry, I don't trust myself.)
05:29:14 <kmc> yeah
05:29:24 <adimit> kmc:  thanks a bunch :-)
05:29:40 <kmc> there's only one function of type «a -> (e -> a)» if you're excluding ⊥'s
05:30:56 <ddarius> Not too many even if you include bottoms and seq.
05:31:09 <kmc> and it satisfies the law for Pointed, which I think is a free theorem anyway
05:31:22 <adimit> it is.
05:33:31 <kmc> ddarius, hmm... ⊥,  const ⊥,  const (const ⊥),  flip seq
05:33:34 <kmc> are there any others?
05:33:52 <adimit> but you do need it. because a → e → a ≡ a → (e → a), and you can have many such functions (w/o satisfying pointed.)
05:34:24 <kmc> adimit, what do you mean?
05:37:06 <adimit> well, a function a → e → a can be, say (+) (with e = a) but that wouldn't satisfy the law of Pointed…
05:38:09 <kmc> that function isn't polymorphic enough, so you don't have to consider it
05:38:33 <adimit> so I could say pure a = \e -> e + a, no?
05:39:09 <ddarius> No, you can't.
05:39:17 <ddarius> Try it.
05:39:21 <kmc> you couldn't say that in an «instance Pointed ((->) e)» declaration
05:39:28 <mysticc> suppose I have similar case statements for 3 variables ... case a of ...... case b of ...... case c of ... all the statements in the case statements are same .... what is the best way to avoid repeating it 3 times
05:39:31 <adimit> yeah…
05:39:46 <kmc> its type does not match the very polymorphic signature given in the definition of the «Pointed» class
05:39:55 <kmc> mysticc, write a function that does that
05:39:57 <kmc> call it 3 times
05:40:19 <mysticc> kmc: :p
05:40:39 <kmc> why :p
05:41:38 <mysticc> nothing ...
05:41:47 * kmc confused
05:41:58 <ClaudiusMaximus> > let handler :: Show a => a -> String ; handler = show in case Just (Left 42) of a@Nothing -> handler (0 :: Word) ; Just (Left b) -> handler (b :: Double) ; Just (Right c) -> handler (c :: Int)
05:41:59 <lambdabot>   "42.0"
05:44:00 <alfred__> ehem
05:44:19 <kmc> hi alfred__
05:44:25 <alfred__> hi
05:44:29 <alfred__> im a newcomer to haskell
05:44:40 <kmc> welcome :)
05:44:41 <alfred__> im doing the turorial
05:44:49 <kmc> which one?
05:44:58 <alfred__> http://tryhaskell.org/#5
05:45:03 <kmc> cool
06:07:57 <flatwhatson> maybe my hoogle-fu fails... does such a thing exist: justIf b x = if b then Just x else Nothing
06:08:09 <kmc> guard b >> Just x
06:08:35 <kmc> but not a single function, afaik
06:09:07 <kmc> @pl justIf b x = guard b >> Just x
06:09:07 <lambdabot> justIf = (. Just) . (>>) . guard
06:09:56 <chra> Data.Maybe.HT.toMaybe :: Bool -> a -> Maybe a
06:10:09 <kmc> what package is that from?
06:10:19 <ion> > 42 <$ guard True :: Maybe Integer
06:10:20 <chra> utilities, I think.
06:10:20 <lambdabot>   Just 42
06:10:22 <ion> > 42 <$ guard False :: Maybe Integer
06:10:23 <lambdabot>   Nothing
06:11:03 <kmc> with -XMonadComprehensions you can write [ x | b ]
06:11:37 <ion> I take it 7.2 supports MonadComprehensions? I still have 7.0.
06:11:58 <chra> kmc: http://hackage.haskell.org/packages/archive/utility-ht/0.0.7/doc/html/Data-Maybe-HT.html
06:12:00 <kmc> it does
06:12:13 <kmc> cool
06:14:30 <kmc> very old Haskell compilers also support monad comprehensions
06:21:45 <flatwhatson> nice, thanks for all the options!
06:26:16 * hackagebot persistent-hssqlppp 0.1 - Declare Persistent entities using SQL SELECT query syntax  http://hackage.haskell.org/package/persistent-hssqlppp-0.1 (IlyaPortnov)
06:26:17 <cheater> i have a list of (n, t) numbers which are the time of execution of an algorithm versus input size n. how do i best catalogize this function automatically as eg being O(log(n)), O(e^n), O(n^k)?
06:26:23 <o-_-o1> I want access to getTimeOfDay, I installed hsdns using cabal but when I say import System.Posix.GetTimeOfDay it says it cannot find the module. http://hackage.haskell.org/packages/archive/hsdns/1.1/doc/html/System-Posix-GetTimeOfDay.html
06:28:48 <o-_-o1> Oh well it has been removed in the latest version.
06:28:52 <o-_-o1> nebermind
06:29:40 <dylex> cheater: That's kind of complicated.  If you have a finite list of options you could e.g., fit it to each and do least squares model comparison.  However, that doesn't actually establish big-O (nor can it).
06:30:06 <cheater> i know i can do that
06:30:12 <cheater> i was looking for something a bit smarter though
06:30:13 <dylex> cheater: Actually complexities are generally determined by analyzing the code itself.  I'm not sure if there's something like that.
06:30:31 <cheater> and yes, i realize it doesn't establish the actual performance of the algorithm
06:31:39 <quicksilver> least squares log log
06:31:44 <quicksilver> works reasonably well
06:31:49 <cheater> quicksilver: ?
06:32:01 <quicksilver> it's almost impossible to empirically distinguish between O(n) and O(n log n) though
06:32:09 <quicksilver> we did this for a 2nd year complexity course once
06:32:25 <cheater> i don't need distinctions this fine
06:32:51 <luite> empirically anything in combination with big-O is meaningless anyway
06:33:04 <cheater> yeah i'm just trying to do some sort of curve fitting
06:33:09 <cheater> it's just a debugging tool anyways
06:34:22 <quicksilver> luite: meaningless is a strong word
06:34:37 <luite> quicksilver: it's the only correct one ;p
06:34:58 <quicksilver> you can empirically measure the quadratic behaviour of quadratic algorithms
06:35:08 <quicksilver> and that is both a meaningful distinction for practical work
06:35:18 <quicksilver> and one which mirrors a theoretical difference
06:35:21 <kmc> o-_-o1, it should be in the 'unix' package, no?
06:35:27 <opqdonut> people usually mean something stronger than O(n^2) when they say O(n^2)
06:35:35 <o-_-o1> kmc: System.Unix ?
06:35:38 <opqdonut> and that stronger thing can be supported empirically
06:35:43 <kmc> http://hackage.haskell.org/package/unix
06:35:56 <kmc> packages and modules are unrelated namespaces
06:36:33 <kmc> quicksilver, funny how it's impossible to tell the difference and yet people will flip out if you tell them an algorithm is O(log n) instead of O(1)
06:36:41 <quicksilver> kmc: well yes ;)
06:36:44 <o-_-o1> kmc: I don't see it in there
06:37:25 <kmc> so I think the empirical testing is a great idea for an algorithms class, for this reason :)
06:37:48 <luite> quicksilver: quicksort is O(n^2), right? :p
06:38:47 <kmc> the actual time complexity is determined by analyzing the code according to a model which ignores all interesting properties of modern computers
06:38:53 <dylex> really you should say big-Theta(n^2) if that's what you mean.
06:39:08 <luite> with quicksort you have the advantage that you can do a more complibated average case complexity analysis, so you know why you're nto measuring quadratic behaviour in real life
06:39:37 <kmc> you mean your measurement program didn't do adversarial pivot selection? ;)
06:40:39 <dylex> Nils Anders Danielsson has some interesting papers on complexity analysis of functional code.
06:42:24 <luite> kmc: hmm, interesting idea though, I wonder how difficult it is to automatically search for worst case behaviour... probably not possible in practice (or theory)
06:42:59 <kmc> maybe with symbolic execution
06:43:11 <kmc> using SMT solvers etc
06:44:55 <kmc> i'm more interested in analyzing algorithm runtime with a more realistic model
06:45:29 <kmc> i'm afraid that will be very hard for functional programs
06:46:00 <kmc> because functional data structures usually do not have explicit memory locality
06:46:25 <kmc> your performance will depend on what the garbage collector does and when
06:47:29 <kmc> I suspect this may have been responsible for something I saw the other day: a program where increasing the allocation area size would massively decrease the percent time spent in GC, but increase the overall run time
06:47:34 <kmc> but I really don't know
06:49:14 <luite> a more realistic model would mean you compltely ditch asymptotic complexity right?
06:49:32 <lpsmith> kmc:  did you ever consider using a more ambitious syntax for your safe-globals package?,   maybe something like  [global| var :: IORef Int |]
06:49:37 <luite> most improvements in the computer model would just result in the same asymptotics, maybe with some log factor differences
06:49:40 <c_wraith> Hmm.  I'm suffering in a struggle between readable documentation and code that performs well.
06:49:41 <o-_-o1> Does anyone have this saved up somewhere ? -> http://nix.cs.uu.nl/dist/courses/sgc-report-unstable-latest/manual/chunk-chapter/templatehaskell.html
06:49:50 <kmc> lpsmith, only a little bit
06:49:51 <o-_-o1> I am trying to grok template haskell
06:50:08 <c_wraith> Everything I do to make the type signatures sane in haddock results in a 50% performance loss.
06:50:36 <hpaste> flatwhatson pasted “Pointers/Advice/Suggestions? (n00b)” at http://hpaste.org/53358
06:50:43 <kmc> #ifdef HADDOCK
06:50:47 <luite> c_wraith: hmm, you can use CPP to insert haddock specific stuff
06:51:15 <kmc> luite, you could talk about the asymptotic number of cache misses or something
06:51:18 <Cale> o-_-o1: probably the place to begin is the paper which introduced it... I believe it's undergone a few somewhat-significant changes since then, but the paper should still be mostly accurate. After that, everything else is a detail which can be cleared up through haddock.
06:51:20 <kmc> that's still asymptotic complexity
06:51:20 <flatwhatson> specifically, i'm not sure how to approach using a State to remove all the passing around of string
06:51:46 <kmc> Template Haskell has undergone some significant changes from the paper, in that GHC fails to implement large parts of it
06:51:47 <o-_-o1> haddock ?
06:51:59 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH.html
06:52:03 <o-_-o1> Ah
06:52:12 <c_wraith> o-_-o1: haddock is the documentation-generation tool used by hackage and others
06:52:16 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH-Syntax.html -- probably this module will be the one most referred to
06:52:58 <o-_-o1> ah...thanks
06:53:02 <luite> kmc: hmm, I think that usually wouldn't make much difference, maybe I'm not thinking hard enough to come up with an example where it does
06:53:33 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html -- this section of the GHC user's guide is short and gives a decent quick overview
06:56:30 <kmc> luite, yeah, I don't have an example either... just speculating
06:59:36 <o-_-o1> Cale: Thank you.
07:01:00 <Cale> No problem
07:05:36 <o-_-o1> So I found a circle of haskellers on Google+ from Don and added it to my profile, now I have only haskell news on my feed -_-
07:06:01 <o-_-o1> I don't even know anyone...
07:06:05 <flatwhatson> any advice on how to better pass my string around in parseRule? ghc complains about shadowing... i'm quite new to haskell # http://hpaste.org/53358
07:06:12 <o-_-o1> A couple of people graciously added me back
07:08:05 <quicksilver> flatwhatson: that's what the state monad is for, although that is only a warning about shadowing isn't it?
07:10:00 <flatwhatson> yeah it's a warning, but i'm taking it as a hint to dive a bit deeper :) i'd need MaybeT State wouldn't i?
07:11:52 <dainanaki> Shadowing only refers to having overlapping names. That's not really relevant to the types and monad stack design you use.
07:14:09 <Cale> flatwhatson: Well, have you looked at any of the parser combinator libraries like Parsec?
07:14:45 <flatwhatson> Cale: yes, i've done this in Parsec already, but it didn't teach me much about haskell in general, so felt like a bit of a copout
07:15:11 <flatwhatson> plus this implementation is already much faster than the parsec equivalent, if slightly more verbose
07:15:19 <Cale> Okay, so let's take a look at how one would naively implement a library like that (Parsec does some more clever things which I'll ignore, because they're not terribly enlightening)
07:15:41 <Cale> Well, even a deterministic parser, like what you're doing
07:16:02 <Cale> You currently seem to be working with lots of functions of type String -> Maybe (a, String) for various a
07:16:15 <Cale> Let's capture that and make it into a new datatype:
07:16:32 <Cale> newtype Parser a = P (String -> Maybe (a, String))
07:16:57 <Cale> and of course, we'll define a way to "run" such a parser, just by extracting and applying the function:
07:17:03 <Cale> runParser (P f) s = f s
07:17:22 <Cale> runParser :: Parser a -> String -> Maybe (a, String)
07:20:35 <Cale> flatwhatson: Make sense so far?
07:21:09 <rkrzr> Hi all, I have a question about parsec: I was looking for a parser that always fails but couldn't find one, is there one?
07:21:17 <flatwhatson> Cale: ok, that makes sense, runParser returns the result of the parse function applied to a string input
07:21:23 <Cale> flatwhatson: yeah
07:21:27 <kmc> rkrzr, mzero
07:21:28 <Cale> rkrzr: yes, there is...
07:21:29 <kmc> :t mzero
07:21:30 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
07:21:49 <rkrzr> kmc, great thanks
07:22:08 <koala_man> "The parser (fail msg) always fails with message-error msg without consuming any input. "
07:22:11 <Cale> mzero as well as  unexpected str  for any string str (which will show up in the error message)
07:22:24 <Cale> flatwhatson: okay
07:22:39 <flatwhatson> Cale: the trick is the string part of things, i guess that's next :)
07:22:41 <Cale> flatwhatson: so what we'll do is define some ways to combine parsers together and build up more complicated ones from simple ones
07:22:54 <Cale> Well, also, some primitive parsers which will do very simple things
07:23:18 <Cale> Let's start with that actually...
07:23:38 <Cale> satisfy :: (Char -> Bool) -> Parser Char
07:23:46 <tswett> Haskell's semantics are the same as those of lambda calculus, lazily evaluated, right?
07:24:08 <sipa> approximately
07:24:19 <opqdonut> lambda calculus isn't a single thing
07:24:20 <Cale> will test if the next character satisfies the predicate given, and if it does, succeed, producing the character as its result
07:24:26 <Cale> and if not, it will fail
07:24:33 <Cale> (which we'll represent with Nothing)
07:24:45 <opqdonut> you need to specify the evaluation system you're using
07:24:47 <tswett> I guess that seq throws a wrench into the monkey works.
07:25:02 <Saizan> tswett: the standard doesn't guarantee lazy evaluation, just non-strict semantics
07:25:03 <Cale> satisfy p = ...
07:25:10 <Cale> well, the thing we're writing is a parser, so might as well use P
07:25:13 <Cale> satisfy p = P ...
07:25:22 <tswett> opqdonut: I guess saying "lazy evaluation" doesn't actually pin it down?
07:25:25 <Cale> and P takes a function String -> (a, String), so it might as well be a lambda
07:25:31 <Cale> satisfy p = P (\s -> ...)
07:25:53 <opqdonut> tswett: lazy evaluation is actually an implementation strategy for normal-order evaluation (except not quite)
07:26:12 <Cale> now we take the string apart by pattern matching, and see if it's 1) nonempty, and 2) its first character is of the sort we're expecting
07:26:44 <tswett> I'd like to ignore the issue of how long something takes to run, by the way; I'm only interested in inputs and outputs.
07:26:44 <Cale> satisfy p = P (\s -> case s of [] -> Nothing; (x:xs) | p x -> Just (x,xs) | otherwise -> Nothing)
07:26:59 <Cale> (I apologise for squishing that all on to one line)
07:27:24 <opqdonut> tswett: as long as the the term you are looking at isn't of a function type, lazy evaluation will do what normal-order evaluation does
07:27:54 <tswett> opqdonut: ah.  Where do they differ?
07:28:01 <Cale> flatwhatson: That might be a little more sophisticated than a lot of other possible primitives (match one Char exactly, match a String at the beginning etc.), but with it, we'll be able to write lots of other useful things, including those two
07:28:27 <Cale> For example, we can write straight away:
07:28:32 <Cale> char :: Char -> Parser Char
07:28:39 <opqdonut> tswett: lazy evaluation does evaluation only on the very top level of the expression. normal-order does it in the outernmost possible level
07:28:43 <Cale> char c = satisfy (== c)
07:28:56 <sm> I'm so confused about profiling options. ghc 7.0.4
07:29:10 <Cale> letter c = satisfy isAlpha
07:29:16 <opqdonut> tswett: so "\x -> (\y -> y) x" is in normal form for lazy evaluation, but not for normal-order evaluation
07:29:18 <Cale> digit c = satisfy isDigit
07:29:19 <kmc> sm, what about them
07:29:28 <sm> 's RTS --help lists -hT, which works. http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/prof-heap.html lists only -hc, -hm etc.
07:29:31 <opqdonut> tswett: normal-order evaluation would evaluate that into "\x -> x"
07:29:33 <tswett> opqdonut: ah.  So with lazy evaluation, const (fix id) halts, but with normal-order, it doesn't, for example?
07:30:05 <Cale> flatwhatson: Does that make some amount of sense? Perhaps we should move to #haskell-overflow where it's a bit quieter
07:30:14 <opqdonut> tswett: hmm, yeah
07:30:51 <flatwhatson> Cale: yep it does make sense, wrapping a function inside a datatype is a new concept for me :)
07:31:55 <tswett> I guess in Haskell, you can't actually *execute* const (fix id).  All you can do is seq it, and I'm pretty sure that seq returns.
07:32:24 <opqdonut> tswett: hmm, sorry, I was wrong. normal order also only does outernmost reductions
07:33:03 <tswett> Oh.
07:33:07 <opqdonut> hehe, it seems it depends on the source
07:33:51 <tswett> Quickly, name the versions after geographic regions.  }:)
07:34:18 <opqdonut> e.g. http://en.wikipedia.org/wiki/Beta_normal_form says only head position
07:34:31 <opqdonut> but http://en.wikipedia.org/wiki/Evaluation_strategy says outernmost
07:34:56 <opqdonut> (and now I myself used "outernmost" in two different meanings. should've stuck with head position)
07:36:32 <petekaz`> newbie question: can someone help explain to me in words what the difference between: mapM (\x -> [x,x+1]) [1,2,3] is versus [1,2,3] >>= \x -> [x,x+1] ?  I know how the results are calculated and understand that, but I'm confused as to when I would want to use each (in terms of the list monad). I think it's the sequencing of the list results that's throwing me in the mapM.
07:36:42 <cwl> where can I find API-doc of snaplet
07:37:41 <tswett> > mapM (\x -> [x,x+1]) [1,2,3]
07:37:42 <lambdabot>   [[1,2,3],[1,2,4],[1,3,3],[1,3,4],[2,2,3],[2,2,4],[2,3,3],[2,3,4]]
07:37:59 <mightybyte> cwl: http://hackage.haskell.org/packages/archive/snap/0.6.0.2/doc/html/Snap-Snaplet.html
07:38:05 <opqdonut> petekaz`: for the list monad, >>= is concatMap
07:38:26 <opqdonut> > [1,2,3] >>= \x -> [x,x+1]
07:38:27 <lambdabot>   [1,2,2,3,3,4]
07:38:40 <petekaz`> I should clarify, I understand why the results are what they are, because I can manually go about following the computation, but my little brain is trying to understand when I would want to use each.
07:39:03 <tswett> Well, you're not going to like this answer, but you should use mapM when you want what mapM returns, and >>= when you want what >>= returns.
07:39:20 <opqdonut> petekaz`: in the mapM variant the [1,2,3] list is a "normal" list, just representing a sequence of values
07:39:55 <opqdonut> petekaz`: in the >>= version the [1,2,3] is a value in the list monad, representing a value that is 1, 2 and 3 simultaneously (or one of them, nondeterministically)
07:40:27 <opqdonut> does this clarify the difference?
07:40:30 <tswett> I can't think of a use for mapM in the list monad off-hand.
07:40:43 <opqdonut> yeah, it's not that natural
07:41:00 <petekaz`> okay, I'm with you. I think my main source of confusion is the mapM variant and why one would use that in the list monad.
07:41:16 <opqdonut> though it's useful for generating all combinations of something
07:41:22 <Tinned_Tuna> > do { x <- [1,2,3]; print x }
07:41:23 <lambdabot>   Couldn't match expected type `[b]'
07:41:24 <lambdabot>         against inferred type `GHC.Types...
07:41:27 <dmwit> :t mapM
07:41:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:41:29 <petekaz`> And really, it's not the result of the first part of the mapM, it's when it sequences it together.
07:41:29 <Tinned_Tuna> > do { x <- [1,2,3]; show x }
07:41:30 <lambdabot>   "123"
07:41:32 <kmc> mapM in the list monad... you want to execute a "nondeterministic computation" on each element of a list
07:41:38 <quicksilver> > mapM (\x -> [x+0.5,x-0.5]) [4,6,8]
07:41:39 <lambdabot>   [[4.5,6.5,8.5],[4.5,6.5,7.5],[4.5,5.5,8.5],[4.5,5.5,7.5],[3.5,6.5,8.5],[3.5...
07:42:01 <quicksilver> hmmm
07:42:05 <dmwit> > mapM (\x -> [sqrt x, -sqrt x]) [5, 37]
07:42:06 <lambdabot>   [[2.23606797749979,6.082762530298219],[2.23606797749979,-6.082762530298219]...
07:42:11 <opqdonut> > mapM (\x -> [Just x, Nothing]) [1,2,3]
07:42:12 <kmc> hmm ignore me
07:42:13 <lambdabot>   [[Just 1,Just 2,Just 3],[Just 1,Just 2,Nothing],[Just 1,Nothing,Just 3],[Ju...
07:42:17 <opqdonut> that demonstrates the combinations thing
07:42:26 <quicksilver> yes.
07:42:39 <opqdonut> now you'll probably understand this:
07:42:50 <opqdonut> > filterM (const [True,False]) [1,2,3]
07:42:50 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
07:42:52 <opqdonut> :)
07:43:08 <tswett> petekaz`: well, when it comes to the list monad, 'sequence' is... simple once you get used to it.  It returns a Cartesian product of the list elements.
07:43:30 <tswett> petekaz`: so, suppose you want a list of all the points on the plane whose x-coordinate is 1, 2, or 3, and whose y-coordinate is 5, 6, or 7.  You can do this:
07:43:32 <kmc> i remember a game of golf on haskell-cafe
07:43:35 <tswett> > sequence [[1,2,3],[5,6,7]]
07:43:36 <lambdabot>   [[1,5],[1,6],[1,7],[2,5],[2,6],[2,7],[3,5],[3,6],[3,7]]
07:43:45 <kmc> to define a function to take the cartesian product of lists
07:44:03 <petekaz`> tswett: right. I get that too. I guess I was looking for the layman's words to why one would use mapM in the list monad.
07:44:19 <petekaz`> or maybe a typical example if it's used?
07:44:36 <tswett> kmc: were you allowed to use sequence in the definition?  :)
07:44:38 <kmc> i like opqdonut's example with Just
07:44:42 <dmwit> I wonder whether the assumption "one would use mapM in the list monad" ought not to be challenged.
07:45:05 <kmc> tswett, the first person to mention 'sequence' did win the game of golf pretty solidly
07:45:05 <tswett> Yeah, maybe mapM just *isn't* used very often in the list monad.
07:45:10 <kmc> hole in one you might say
07:45:33 <dmwit> Probably not all combinations of "choice of monad" and "choice of function that is polymorphic over all monads" has seen use in production code.
07:45:36 <kmc> > mapM (\x -> [x,'?']) "hello"
07:45:36 <lambdabot>   ["hello","hell?","hel?o","hel??","he?lo","he?l?","he??o","he???","h?llo","h...
07:45:38 <tswett> Of course, sequence takes and returns lists, not tuples.  I wonder if this is a strength or a weakness.
07:46:12 <haskellelephant> @botsnack
07:46:12 <lambdabot> :)
07:46:30 <kmc> > mapM repeat "abc"
07:46:30 <lambdabot>   ["abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","a...
07:46:39 <opqdonut> ...
07:46:41 <kmc> buh
07:46:42 <tswett> > repeat "abc"
07:46:43 <EvanR-work> mapM in Monad [], *brain explode*
07:46:44 <lambdabot>   ["abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","a...
07:46:54 <tswett> lambdabot: I think you forgot the mapM.  }:)
07:46:55 <haskellelephant> defaults to list, how intriguing...
07:47:03 <petekaz`> EvanR-work: yes, my thoughts exactly.
07:47:05 <kmc> it doesn't default
07:47:08 <dmwit> haskellelephant: no defaulting here
07:47:13 <kmc> the type of 'repeat' forces it to be the list monad
07:47:23 <haskellelephant> Ahhh
07:47:27 <haskellelephant> ofcourse
07:47:32 <ion> > mapM (\x -> ['0','1']) "000"
07:47:33 <lambdabot>   ["000","001","010","011","100","101","110","111"]
07:47:58 <dmwit> > replicateM 3 "01"
07:47:59 <lambdabot>   ["000","001","010","011","100","101","110","111"]
07:48:05 <opqdonut> > replicateM 3 "01"
07:48:06 <lambdabot>   ["000","001","010","011","100","101","110","111"]
07:48:07 <sm> answering myself: +RTS --help lists -h[^T] for an executable built with -prof
07:48:23 <kmc> > mapM (flip iterate . (:)) "abc"
07:48:23 <opqdonut> @botsnack
07:48:24 <lambdabot>   Overlapping instances for GHC.Show.Show
07:48:24 <lambdabot>                              ((([GH...
07:48:24 <lambdabot> :)
07:48:28 <kmc> > mapM (flip iterate [] . (:)) "abc"
07:48:30 <lambdabot>   [["","",""],["","","c"],["","","cc"],["","","ccc"],["","","cccc"],["","","c...
07:48:32 <dmwit> mapM (const e) es = replicateM (length es) e
07:48:44 * kmc isn't really sure what he's trying to do here
07:48:47 <haskellelephant> reapeat ":)"
07:48:48 <EvanR-work> lol
07:48:57 <haskellelephant> > repeat ":)"
07:48:58 <lambdabot>   [":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)",":)"...
07:49:10 <tromp> > cycle ":)"
07:49:11 <lambdabot>   ":):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):):)...
07:49:13 <haskellelephant> nice
07:49:32 <haskellelephant> @botsnack
07:49:32 <lambdabot> :)
07:50:21 <dmwit> > mapM (\x -> case x of 'a' -> repeat x; _ -> enumFrom x) "abc" -- trying to prove to myself that I understand the earlier example; this should *also* be repeat "abc" if I'm right
07:50:22 <lambdabot>   ["abc","abd","abe","abf","abg","abh","abi","abj","abk","abl","abm","abn","a...
07:50:32 <dmwit> I'm not right. =)
07:51:29 <dmwit> > mapM (\x -> case x of 'c' -> repeat x; _ -> enumFrom x) "abc"
07:51:31 <lambdabot>   ["abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","abc","a...
07:51:36 <dmwit> oh, okay
07:53:34 <dmwit> > mapM (`replicateM` ['a'..'z']) [1..]
07:53:39 <lambdabot>   mueval-core: Time limit exceeded
07:55:00 <dmwit> oh
07:55:10 <dmwit> > [1..] >>= (`replicateM` ['a'..'z']
07:55:13 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:55:17 <dmwit> > [1..] >>= (`replicateM` ['a'..'z'])
07:55:18 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
07:55:31 <EvanR-work> > [0,1] >>= id
07:55:33 <lambdabot>   No instance for (GHC.Num.Num [b])
07:55:33 <lambdabot>    arising from a use of `e_101' at <inte...
07:55:46 <dmwit> > ["ab", "cd"] >>= id
07:55:48 <lambdabot>   "abcd"
07:56:30 <EvanR-work> > [0,1] >>= (id . singleton)
07:56:32 <lambdabot>   Not in scope: `singleton'
07:56:54 <EvanR-work> > [0,1] >>= \x -> [x]
07:56:56 <lambdabot>   [0,1]
07:56:59 <dmwit> x >>= (id . return) = x >>= return = x
07:57:20 <EvanR-work> > [0,1] >>= \x -> [x,x]
07:57:22 <lambdabot>   [0,0,1,1]
07:57:24 <hpaste> vimix pasted “error” at http://hpaste.org/53359
07:58:12 <EvanR-work> > [0,1] >>= \x -> [x+1]
07:58:13 <lambdabot>   [1,2]
07:58:25 <EvanR-work> so basically for >>= to be interesting you want a list of lists
07:58:53 <adimit> > "foo" >>= (:['x'])
07:58:54 <lambdabot>   "fxoxox"
07:59:17 <vimix> i do not understand the hugs error msg of my code snippet
07:59:50 <dmwit> vimix: The minimal code change to fix it is to write "fill n ((z:zs) ++ [0])".
08:00:07 <dmwit> vimix: But there are some very serious code style and efficiency issues with what you've written. Would you like advice?
08:00:34 <vimix> advices are very welcome
08:00:47 <vimix> i am just learning haskell
08:00:53 <dmwit> When writing functions that work on lists, you are not *required* to do pattern matching.
08:01:15 <dmwit> For example, you write "maxLength (y:ys) = foldr blah blah blah (y:ys)".
08:01:26 <dmwit> You could use instead just "maxLength ys = foldr blah blah blah ys".
08:01:38 <dmwit> Similarly for anp1 and fill.
08:01:51 <dmwit> Additionally, appending to the end of a list is slow; prepending is preferred.
08:01:55 <vimix> oh, there was an anpl instead of anp1... thats a  shame...
08:02:26 <dmwit> So in fill, it would be better to write "0 : fill n (z:zs)" or just "0 : fill n zs" if you implement the above style suggestion.
08:02:39 <dmwit> In fact, recomputing the length each time you recurse is also quite wasteful.
08:02:53 <dmwit> I suggest using "replicate" to simply prepend or append the right number of zeros.
08:03:28 <dmwit> So, for example, "fill n zs = zs ++ replicate (length zs - n) 0" will be much faster than what you wrote, and is quite readable in comparison as well, I think.
08:04:20 <vimix> ok
08:04:24 <dmwit> ?src map
08:04:25 <lambdabot> map _ []     = []
08:04:25 <lambdabot> map f (x:xs) = f x : map f xs
08:04:51 <vimix> i had this before... is using (z:zs) instead of (zs) a real efficiency problem?
08:05:02 <dmwit> No, it's a totality problem.
08:05:18 <dmwit> If you write "f (z:zs) = ..." instead of "f zs = ...", then "f" may not work on empty lists.
08:05:33 <vimix> ah... of course
08:05:33 <dmwit> This is silly, especially when using functions like foldr and map that are perfectly well-defined on empty lists.
08:05:36 <vimix> thank you
08:05:53 <dmwit> vimix: One last suggestion:
08:05:55 <dmwit> :t maximum
08:05:58 <lambdabot> forall a. (Ord a) => [a] -> a
08:06:15 <EvanR-work> > maximum []
08:06:17 <lambdabot>   *Exception: Prelude.maximum: empty list
08:06:19 * hackagebot fraction 0.1.0.0 - Fractions  http://hackage.haskell.org/package/fraction-0.1.0.0 (WolfgangJeltsch)
08:06:19 <dmwit> Yep, a bit partial.
08:06:34 <dmwit> Since he's happy getting back 0 for empty lists, he can use "maximum . (0:)".
08:06:42 <dmwit> > (maximum . (0:)) []
08:06:47 <lambdabot>   mueval-core: Time limit exceeded
08:06:55 <dmwit> heh
08:07:11 <EvanR-work> lol
08:07:14 <dmwit> :t tfoldr
08:07:15 <lambdabot> Not in scope: `tfoldr'
08:07:16 <dmwit> :t foldr
08:07:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:07:25 <tswett> ...what?
08:07:28 <tswett> > maximum [0]
08:07:29 <lambdabot>   0
08:07:37 <vharishankar> Hey, after a week with Haskell I've documented some of my "newbie" thoughts on FP in general and Haskell in particular.
08:07:41 <dmwit> > (maximum . (0:)) [] -- just a glitch
08:07:44 <lambdabot>   0
08:07:59 <vharishankar> http://harishankar.org/blog/entry.php/why-learning-functional-programming-and-haskell-in-particular-can-be-hard
08:08:14 <dmwit> :t \f -> foldr (\a -> (f a:)) []
08:08:15 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
08:08:21 <vharishankar> Your feedback would be much appreciated. :-)
08:08:45 <EvanR-work> answer because we are taught by the totality of popular IT media that its proper to write programs a tape of symbols in a turing machine
08:09:20 <EvanR-work> OOP draws boxes around sections of tape
08:09:26 <EvanR-work> revolutionary
08:09:26 <dmwit> :t foldr (max . length) 0
08:09:28 <lambdabot> forall a. [[a]] -> Int
08:09:31 <Lemon> so uh
08:09:40 <Lemon> Monads "work" in strict languages too, right?
08:09:52 <EvanR-work> up to bottoms
08:09:54 <dmwit> Lemon: Yes, but not as well.
08:10:07 <Lemon> what are some of the cases in which behavior is not ideal?
08:10:16 <dmwit> Lemon: For example, (>>=) is short-circuiting in the Maybe and State monads in Haskell, but wouldn't be in strict languages.
08:10:22 <Lemon> ah
08:10:30 <dmwit> > Nothing >>= undefined
08:10:31 <lambdabot>   Nothing
08:10:52 <dmwit> > let a = Nothing; b = undefined in a `seq` b `seq` (a >>= b)
08:10:54 <lambdabot>   *Exception: Prelude.undefined
08:11:15 <Lemon> okay, slightly unrelated related question
08:11:17 <EvanR-work> >>=(Nothing, throw new Exception('undefined'))
08:11:25 <tswett> OOP does add *something* interesting to the mix.  With the procedural code doSomething(object), what happens is determined by doSomething; with the object-oriented code object.doSomething(), it's determined by the object.
08:11:39 <Lemon> what would be your "ideal" syntax for explicit laziness in a strict language?
08:11:50 <scshunt> tswett: not really
08:12:01 <scshunt> tswett: it's determined by the function doSomething(object)
08:12:07 <scshunt> it's just syntactic sugar
08:12:40 <tswett> scshunt: well, what that function is depends entirely on what the object is.
08:13:13 <haskellelephant> dmwit: I guess that would be of practical importance if you are guarding against something bad happening, Like unless (isNothing a) (putStrLn ("Everything when fine your answer was:  " ++ show (fromJust a))
08:13:18 <scshunt> tswett: sure. In a static language, it's just different name lookup
08:13:26 <Lemon> tswett, how is that any different than having doSomething inspect object?
08:13:36 <tswett> Lemon: it's exactly the same.
08:13:40 <scshunt> in a dynamic one, it's memberLookup(object, "doSomething")(object)
08:13:42 <dmwit> vharishankar: Your pebble-counting analogy doesn't really do anything for me. I don't see much of a difference between changing where a finger is pointing and changing where a palm separates a line of pebbles.
08:13:46 <Lemon> so... it's syntactic sugar.
08:13:54 <EvanR-work> tswett: doSomething['objtype'](...) or in js doSomething is just stored in a structure
08:13:57 <tswett> Every language is composed entirely of syntactic sugar.  }:)
08:14:04 <kmc> objects are the poor man's closures, and closures are the poor man's objects
08:14:30 <EvanR-work> tswett: thats what im saying, either its syntactic sugar on top of a turing machine, or its haskell ;)
08:14:30 <tswett> But yeah.  I don't think anything has been said that I disagree with.
08:14:31 <dmwit> vharishankar: I find the advice to persevere despite the new jargon quite good, though.
08:14:31 <vharishankar> dmwit: thanks. I realize it's a bit odd, but I wanted to illustrate the concept of "folding"
08:15:34 <vharishankar> dmwit: thanks. I had thought the analogy was a bit too primitive, but it maps well mentally: counters vs accumulators.
08:15:35 <kmc> oh man an article that starts off with "I'm not bashing functional programming, but..."
08:15:52 <vharishankar> kmc: sure, it doesn't.
08:16:04 <yitz> vharishankar: http://www.reddit.com/r/haskell/comments/lv84d/why_learning_functional_programming_and_haskell/
08:16:06 <frerich2> In virtually every project I notice that I keep accumulating a set of generic "utility functions" (usually at the bottom of my source files), like "rotateL :: [a] -> [a]" (which 'rotates' a list to the left) or 'allUnique :: [a] -> Bool' (which tells whether each element in the list appears exactly once) or the like. How do you handle such things - do you move them into a 'Utils.hs' file or something?
08:16:11 <kirindave> Sounds like I woke up to a rad article
08:16:12 <dmwit> vharishankar: Sorry, what's the difference between counters and accumulators?
08:16:19 * hackagebot kinds 0.0.1.4 - Emulation of subkinds and subkind polymorphism  http://hackage.haskell.org/package/kinds-0.0.1.4 (WolfgangJeltsch)
08:16:25 <frerich2> I think 80% of my program is specific to the problem at hand, and 20% is generic functions like that.
08:16:27 <kirindave> Link please?
08:16:36 <vharishankar> dmwit: counters are mutable. Accumulators are not?
08:16:48 <kmc> vharishankar, I agree with you that Haskellers spend too much time emphasizing FP ideology, and too little time talking about how Haskell is a good imperative language too
08:16:50 <EvanR-work> frerich2: make a module
08:17:04 <tswett> frerich2: I think I would keep the generic functions right next to where they're used, assuming they're used only once.
08:17:15 <dmwit> vharishankar: But your example doesn't illustrate that at all. Both of your examples use mutability (or neither do, depending on how you look at it).
08:17:20 <kirindave> vharishankar, perhaps you mean "monotonic", not "mutable"?
08:17:22 <kmc> vharishankar, it's common for beginners to protest that not all problems are naturally functional, and they're commonly under the mistaken belief that this means Haskell can't be used for those problems
08:17:59 <vharishankar> dmwit: Thanks. It is probably an analogy I could modify
08:18:02 <dmwit> vharishankar: In one you're changing where your finger points; in the other, you're changing where your palm separates the "seen" from the "unseen" pebbles.
08:18:03 <kmc> (or shouldn't)
08:18:16 <yitz> dmwit: he has glue on his hand
08:18:23 <EvanR-work> lol
08:18:34 <tswett> frerich2: if they're used many times, I guess I'd figure out why this is, and name the module accordingly.  If rotateL is useful because your lists act like cycles, put them in a file called Cycle.hs.  Maybe.
08:18:44 <mm_freak> one could totally live with arrows on their hand
08:18:51 <vharishankar> dmwit: right. Probably it's a bit too stretched...
08:19:23 <kmc> vharishankar, I'm not really sure "intro to recursion" is a "how to learn FP" problem.  don't all programmers learn recursion?  isn't it the basic way for traversing any tree-shaped structure, like a filesystem, in any language?
08:19:41 <dmwit> psh
08:19:44 <kmc> maybe this is wishful thinking on my part
08:19:52 <dmwit> reify your call stack as an actual stack and do it with a loop instead
08:19:56 <dmwit> be a real man
08:19:59 <vharishankar> kmc: I understand, but I feel recursion was never popular with imperative programmer anyway.
08:19:59 <EvanR-work> kmc: seems that they are told about recursion as an after thought, if its a course on C, they are told 'ok thats how it works, now dont use it' ;)
08:20:08 <kmc> also German is pretty similar to English
08:20:14 <vharishankar> EvanR-work: exactly!
08:20:19 <mm_freak> proper functional programming doesn't involve using explicit recursion…  in fact, you try to prevent it
08:20:30 <kmc> mm_freak, eh, I don't try that hard
08:20:34 <kirindave> kmc: I know that my college education didn't include the consequences of recursion in functional programming.
08:20:35 <EvanR-work> unless it scheme
08:20:37 <kmc> as we were discussing here earlier
08:20:48 <kirindave> kmc: "open recursion" for example, was a term never uttered in any class I had as a student.
08:20:53 <yitz> i think i understand what vharishankar is trying to get at with that analogy though. an action of counting, as opposed to a value you just have "in your hand".
08:20:58 <yitz> i guess
08:21:08 <kmc> if your recursion scheme can only be described by a zygohistomorphic prepromorphism, which one person has ever used before...
08:21:11 <kmc> you're better off writing it explicitly
08:21:19 <vharishankar> yitz: yes, that was about it.
08:21:20 <mm_freak> kmc: you don't try hard, you just do it…  you are using a lot of recursion under the hood…  compared to that the explicit recursions you use are comparably few
08:21:21 <kmc> if it's a straightforward 'map' or 'fold' then sure
08:21:40 <tswett> Have ZHMPPMs been used seriously, ever, or were they mostly implemented as a joke?
08:21:49 <EvanR-work> manually writing a function to sum stuff has got to be the absolute least important task when doing programming in general, functional or otherwise?
08:22:00 <vharishankar> That article was written partly to clarify my own thoughts and try to understand where I have imperfectly understood.
08:22:08 <mm_freak> well, in past times i used to use ContT with forever
08:22:14 <kirindave> vharishankar, you really never heard the phrase "syntactic sugar" until you came across Haskell?
08:22:24 <mm_freak> nowaway i really just write a recursive function/action and even call it "loop" =)
08:22:34 <yitz> vharishankar: recursion never became popular because most imperative language have neither laziness nor tail call optimization, so using recursion can randomly blow the stack and crash your program.
08:22:39 <vharishankar> kirindave: yes. I might have read it somewhere, but never read it so often as to make an impression.
08:22:43 <mm_freak> nowadays*
08:22:44 <kirindave> Huh
08:23:03 <vharishankar> yitz: true. Iteration is promoted as leaner and meaner in procedural programming.
08:23:11 <kirindave> vharishankar, because that term has been in use in the perl, ruby, python, and C++ communities for at least a decade.
08:23:12 <kmc> yeah it is not necessarily a common term
08:23:27 <byorgey> tswett: they were mostly implemented as a joke, but I don't know whether they have been used seriously
08:23:37 <EvanR-work> vharishankar: i avoid both iteration and recursion unless i explicitly need that effect, which is almost never
08:23:44 <vharishankar> kirindave: I am not sure why. But I must admit to ignorance.
08:23:48 <sm> when profiling with just SCC annotations (no -auto), how can I hide all the extra CAFs from the profile ? I just want to see what I annotated
08:23:55 <kmc> Java's not on that list
08:24:01 <kirindave> kmc: True story
08:24:01 <recube> ocaml
08:24:07 <mm_freak> EvanR-work: "effect"?
08:24:18 <vharishankar> EvanR-work: good idea. But most FP tutorials emphasize on these concepts, so I thought it would be worthwhile talking about it.
08:24:23 <EvanR-work> map and sum and friends dont require any reference to iteration or recursion
08:24:32 <kmc> i think there was a stackoverflow question about practical use for ZHPPMs
08:24:49 <mm_freak> EvanR-work: i totally think of 'map' as both recursion and iteration
08:24:53 <EvanR-work> and higher level transformations dont require reference to map or sum
08:25:00 <kmc> i've also found people on Reddit who use it to argue that Haskell is too complicated / academic, and don't realize it's a joke
08:25:00 <EvanR-work> mm_freak: i think of it as map
08:25:06 <kmc> makes me wonder about some of the Java shit we make fun of
08:25:07 <yitz> EvanR-work: the corresponding concept is to use for or foreach instead of while
08:25:16 <mm_freak> "iteration" doesn't necessarily involve thinking about imperative steps, but you do map elements one by one
08:25:17 <kmc> http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html
08:25:32 <vharishankar> mm_freak: yes, iteration is more a mental model.
08:25:40 <mm_freak> right
08:25:40 <EvanR-work> mm_freak: no you dont
08:26:09 <EvanR-work> the map doesnt require any particular order, or doing one after the other, conceptually
08:26:20 * hackagebot type-functions 0.2.0.2 - Emulation of type-level functions  http://hackage.haskell.org/package/type-functions-0.2.0.2 (WolfgangJeltsch)
08:26:22 <vharishankar> I'm lol at AbstractSingletonProxyFactoryBean (only Java can have such names)
08:26:29 <mm_freak> EvanR-work: you may want to look at the definition on its lowest level (i.e. after applying all combinators):  map f [] = []; map f (x:xs) = f x : map f xs
08:26:35 <mm_freak> that's totally an iteration
08:26:38 <EvanR-work> mm_freak: implementation detail
08:26:50 <EvanR-work> its irrelevant to the usage and understanding of the effect
08:27:08 <mm_freak> iteration is not an effect, that's my point
08:27:10 <mm_freak> it's a concept
08:27:21 <EvanR-work> i didnt say iteration was an effect, im not even talking about iteration
08:27:29 <EvanR-work> map is not 'iteration' its map
08:28:04 <kmc> dude, what does, like, anything even *mean*, man
08:28:15 <kmc> map is not iteration it just... is
08:28:15 <kirindave> This IO article up on haskell.reddit has me worried.
08:28:16 <kmc> dude
08:28:25 <EvanR-work> mapM is iteration
08:28:29 <kirindave> I guess I never use unsafePerformIo
08:28:29 <mm_freak> kirindave: about broken monad laws?
08:28:31 <kmc> which one kirindave
08:28:35 <kirindave> mm_freak, no, eff that.
08:28:37 <kmc> fuck the monad laws
08:28:42 <kmc> monad laws just protect the 1%
08:28:48 <kirindave> kmc: The one about unsafePerformIO
08:28:54 <kmc> kirindave, the super long one i wrote?
08:28:57 <kirindave> kmc: Yes.
08:29:01 <mm_freak> don't know that one…  i never use unsafePerformIO anyway
08:29:06 <mm_freak> or any other unsafe* function for that matter
08:29:08 <kirindave> It just worries me.
08:29:16 <kmc> i don't always unsafePerformIO, but when I do, I inline it
08:29:20 <kirindave> Ha
08:29:24 <kmc> (ByteString motto)
08:29:34 <kmc> kirindave, it worries me too... I hope there are no more bugs of this form
08:29:37 <dmwit> Off-topic a bit... is there a way to do something like what shift+pageup does in normal terms, but in screen?
08:29:44 <dmwit> (e.g. scroll back up a bit)
08:29:49 <kirindave> kmc: Indeed. Because I am about to really open the throttle on trying to push for haskell in infdev
08:29:51 <kmc> dmwit, ^A [
08:29:54 <yitz> kmc: but be careful, if you protest the monad laws, it may snow on you
08:29:56 <dmwit> kmc: thanks
08:30:07 <kmc> you may, uh, have to read about how screen copy-paste works
08:30:14 <kirindave> kmc: And if I do and then discover the impl is riddled with bugs... I will be sad and look ridiculous. :)
08:30:15 <kmc> (cause that's the underlying feature)
08:30:20 <kmc> what's an infdev?
08:30:36 <kirindave> kmc: Infrastructure development. For people like me who write components of big distributed systems
08:30:39 <dmwit> huh, nothing happens
08:30:48 <kirindave> kmc, we need some word to distinguish ourselves from devops.
08:30:55 <tswett> I wonder.  Is it possible to define an algebra for the IO monad in Haskell?
08:31:00 <kirindave> Because if I write many more chef recipes or puppet scripts I am going to die.
08:31:09 <dmwit> "must be on a window layer"?
08:31:16 <kmc> kirindave, I don't think GHC is riddled with bugs, more so than any other operating system
08:31:19 <monochrom> dmwit: ^A [ , that enters a mode, then you pgup and pgdn. when you are done, esc (or most other keys, with exceptions)
08:31:39 <kirindave> kmc: Concurrency mixed with parallelism is a delicate thing. :)
08:32:09 <dmwit> aaah
08:32:21 <tswett> It would be a type Program, along with a function alg :: IO Program -> Program, such that alg (return x) = x and alg (join x) = alg (alg x).  I... think.  I'm probably mixing something up.
08:32:21 <dmwit> perfect, thanks
08:32:24 <kmc> this particular bug only hits people who are doing pretty dodgy things
08:32:33 <kmc> in my defense, I think I have a pretty good reason to want to do that thing
08:32:38 <dmwit> I escaped the dungeon. =)
08:32:40 <kmc> and also it is a pretty common thing
08:32:42 <kmc> which worries me
08:33:24 <tswett> It seems like Haskell has no way of defining a global variable that is guaranteed to actually work.
08:33:45 <tswett> I mean, global variables are usually (always?) a bad idea in Haskell.  But sometimes, people want them.
08:33:46 <kmc> except a C global variable :)
08:33:51 <Cale> grrrr, if you accidentally install text before deepseq, you end up with a text package that has no instance of NFData, because they do CPP shenanigans to avoid depending on the deepseq package
08:33:51 <kmc> which is where I'm going next
08:34:11 <Cale> and then you have to rebuild all your packages which depend on text of course because reinstalling it will break everything
08:34:14 <tswett> Yeah, you can just link a C program that does nothing but define a global variable, can't you.
08:34:29 <kmc> tswett, I don't expect Haskell to have a way to define a global variable.  I'm disappointed that GHC Haskell doesn't have it, either
08:34:36 <dmwit> Yeah, cabal dependencies don't really have a good "flag" story yet.
08:34:49 <Cale> Why not just depend on deepseq here?
08:34:57 <kmc> actually trying to standardize such a thing would be an awful mess of bikeshedding and ridiculous "it's bad so it should also be dangerous" arguments
08:35:08 <Cale> Or just orphan the instance and put it in a text-deepseq package?
08:35:12 <dmwit> Cale: Thank goodness for the new hash checking, or else things would just be silently broken instead of noisily broken. =P
08:35:14 <Cale> Either of those would be preferable
08:35:32 <kmc> fuck, software is hard
08:36:01 <kmc> tswett, I don't think they're always a bad idea
08:36:02 <kirindave> "the new hash checking?"
08:36:09 <kmc> I had two use cases in my safe-globals post
08:36:12 <Cale> And for some reason, whenever I install some things which depend on the text package, cabal wants to reinstall text along with them, which is bizarre.
08:36:18 <kmc> and you can come up with more
08:36:20 <Cale> (and will of course break things)
08:36:20 * hackagebot records 0.1.1.5 - A flexible record system  http://hackage.haskell.org/package/records-0.1.1.5 (WolfgangJeltsch)
08:36:30 <dmwit> kirindave: Packages now store a hash of... something... which is very likely to change if you build it with different flags.
08:36:33 <tswett> Is it possible, by the way, to make an IORef out of a Ptr?
08:36:42 <kirindave> I see.
08:36:47 <Cale> tswett: Not as far as I know.
08:36:49 <kirindave> dmwit, ty
08:37:44 <kirindave> Hmm
08:37:47 <kirindave> "Functional Aesthetics"
08:37:51 <kirindave> click-to-buy
08:37:52 <mysticc> @hoogle handleForm
08:37:53 <lambdabot> No results found
08:38:26 <kmc> tswett, doubtful (for example IORefs can be moved around by the garbage collector)
08:38:41 <kmc> but there are packages like http://hackage.haskell.org/package/StateVar which let you manipulate both in similar ways
08:38:54 <kmc> this is kind of a "mutable lens" library
08:39:00 <kmc> one of the actual lens libraries might have a better story
08:40:16 <tswett> Aww, STRef is just a wrapper around MutVar#.
08:41:23 <bgamari> Cale: I found the same issue with random-source recently; cabal would randomly decide it didn't like the existing installation
08:41:50 <kmc> tswett, I imagine IORef is the same?
08:42:01 <tswett> IORef is a wrapper around STRef.
08:44:30 <quicksilver> tswett: for a slightly unusual notion of 'just a wrapper', though
08:44:36 <hpaste> ib pasted “unembedding” at http://hpaste.org/53360
08:44:58 <tswett> Isn't it... less than a wrapper?  It's, like, data IORef a = IORef (STRef RealWorld a).
08:45:21 <eyebloom> hi I'm trying to find some help reading some code from "Unembedding Domain Specific Languages"
08:45:37 <eyebloom> http://hpaste.org/53360
08:46:09 <quicksilver> tswett: I meant the other one; STRef being "just a wrapper" around MutVar#
08:46:16 <eyebloom> Just trying to understand how the Size constructor is being used in on lines 10 and 11
08:46:32 <sm> -ignore-scc doesn't seem to ignore {-# SCC "annotations" #-}. Does it do something else ?
08:46:55 <kmc> eyebloom, it's just a wrapper type for the Integer result of 1 + size x + size y
08:47:01 <tswett> quicksilver: Oh.  That one's pretty much data STRef s a = STRef (MutVar# s a), isn't it?
08:48:58 <quicksilver> tswett: except that data STRef is a data type of the haskell language
08:49:10 <Cale> Yeah, IORef is a wrapper around STRef, which is a wrapper around MutVar#
08:49:11 <quicksilver> tswett: and MutVar# is a data type of the (unnamed) GHC implementation language
08:49:28 <quicksilver> and the GHC implementation language is impure and strict-in-places
08:49:39 <quicksilver> quite a different semantics to haskell.
08:49:54 <quicksilver> MutVar# couldn't exist in haskell.
08:50:18 <quicksilver> so "STRef is just a wrapper around (something which couldn't exist in haskell)" is a more subtle claim than first appears
08:51:23 <eyebloom> kmc: How does line 11 read in english?
08:51:58 <kmc> I don't make a habit of reading code in English, in general
08:52:41 <kmc> you're saying the size of the term (x `app` y) is 1 plus the size of x plus the size of y
08:52:43 <eyebloom> kmc: ok what is the type of Size?
08:52:53 <kmc> Size is the data constructor for the type Size
08:52:59 <kmc> Size :: Integer -> Size
08:53:22 <kmc> you're just wrapping those Integers in a newtype so you can define a special type class instance
08:53:23 <eyebloom> ok, thanks.
08:53:37 <kmc> like, you might want to do another Integer-valued traversal
08:53:38 <kmc> say, depth
08:53:47 <kmc> you can't use "instance UntypedLambda Integer" for both
08:53:53 <kmc> so you make a wrapper type for each traversal
08:54:02 <eyebloom> aha
08:54:06 <kmc> eyebloom, have you read "Finally tagless, partially evaluated"?
08:54:31 <eyebloom> No
08:54:43 <eyebloom> I'll check it out.
08:54:48 <kmc> ah, it might clarify what's going on here
08:55:13 <kmc> that paper introduces this trick of defining a type class for the syntax of your language, and then instances for each operation you want to perform
08:56:02 <eyebloom> I see.
08:57:19 <edwardk> kmc: btw- your top level ioref hack can be done a bit more elegantly. declareIORef "ref" ''Int 3 -- could be used if you use the Data to TH stuff that is lying around
08:57:38 <eyebloom_> Thanks.
08:57:47 <kmc> ''Int doesn't work
08:57:50 <kmc> how do i do Maybe Int?
08:58:07 <kmc> and I don't want to require that initializers are evaluated at compile time
08:58:11 <edwardk> *nods*
08:58:12 <kmc> but maybe I should
08:58:15 <rostayob> is there a split  :: (a -> Bool) -> [a] -> [[a]]? seems strange that it doesn't exist
08:58:22 <rostayob> in the stdlib
08:58:26 <kmc> 'split' package might have it
08:58:35 <kmc> lots of things are missing from the stdlib, split-wise
08:58:38 <edwardk> for the more complicated types you'd have to actually throw more messy TH stuff in there
08:58:49 <edwardk> just thought i'd mention the data to TH bit
08:58:50 <kmc> there's 'words' but nothing for other delimiters, for example
08:58:57 <rostayob> kmc: yeah
08:59:03 <kmc> hmm, what's the data to TH thing you refer to edwardk?
08:59:20 <edwardk> one sec. i've used it but don't remember where its from. looking
09:00:58 <edwardk> dataToExpQ
09:01:11 <edwardk> http://haskell.org/ghc/docs/7.0.4/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH-Quote.html
09:01:21 * hackagebot type-equality-check 0.0.0.2 - Type equality check  http://hackage.haskell.org/package/type-equality-check-0.0.0.2 (WolfgangJeltsch)
09:01:38 <edwardk> see http://hackage.haskell.org/packages/archive/jmacro/0.5.2/doc/html/src/Language-Javascript-JMacro-QQ.html for an example
09:03:20 <kmc> ah right
09:03:29 <kmc> thanks
09:09:46 <sm> my new rss2irc is leaking memory at about 500M/min
09:09:54 <sm> is there an obvious leak in this loop ? http://joyful.com/darcsden/simon/rss2irc/browse/Feed.hs#L-102
09:10:37 <sm> types: http://joyful.com/darcsden/simon/rss2irc/browse/Base.hs#L-113
09:11:39 <adimit> @djinn (e -> a) -> (a -> (e -> b)) -> (e -> b)
09:11:39 <lambdabot> f a b c = b (a c) c
09:11:56 <tswett> quicksilver: ah, so http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-STRef.html isn't actually Haskell code; it's another language that looks almost identical to Haskell?
09:12:03 <adimit> @botsnack
09:12:03 <lambdabot> :)
09:12:18 <kmc> yeah, I call that language GHC Haskell
09:13:38 <tswett> Is the language GHC.STRef written in some special fancy internal GHC thing, or is it just a flavor of Haskell that people write applications in?
09:13:57 <Cale> tswett: The former, for the most part :)
09:14:08 <Cale> tswett: You can use GHC internals to write stuff
09:14:22 <adimit> a bit of both, but mostly the former, if you're not directly writing something very GHC-y.
09:14:47 <adimit> few people do, and that's good :-)
09:14:54 <tswett> Is this "GHC Haskell" distinct from Haskell-with-all-the-extensions-GHC-wants-to-provide?
09:15:15 <Philonous> sm:  I've been hacking on a feed reader and the feed package seems to introduce inexplicable leaks for me as well at about the same rate. (I think it's the fault of the underlying xml package, though). I had trouble debugging it because retainer profiling keeps crashing
09:15:18 <adimit> but you'll see GHC internal stuff occasionally in high-performance libs.
09:16:11 <sm> Philonous: interesting to hear, thanks
09:16:20 <Cale> Personally, I use the term "GHC Haskell" to mean Haskell with some or all of the fancy GHC type system extensions. But there's also lots of low-level GHC internal stuff with less potential for portability.
09:17:02 <sm> last time I tried this signs pointed there as well. I wondered about redoing feed on a more modern xml lib
09:17:23 * tswett grabs the STM source code to see if it actually *has* an implementation, or is simply made of magic.
09:17:50 <Cale> The high level extensions are all at least portable in theory, even if there doesn't presently exist another implementation of them. The low-level stuff is more dubious, because you'd end up with an implementation which looks enough like GHC that one would have to wonder why you weren't just contributing code to GHC rather than working on a new compiler.
09:18:52 <tswett> I suddenly marvel at the fact that mathematics manages to come up with essentially one definition, or maybe two, for each concept.
09:19:11 <tswett> "Real number" always means the same thing.  "Ring" always means one of two things.  But "Haskell" can mean any of dozens of things.
09:19:18 <Cale> heh
09:19:36 <adimit> tswett: "Haskell" is *immensly* more complex than "Ring" or "Real number"
09:19:42 <quicksilver> tswett: if it was *merely* the addition of a bunch of interesting primitives, I'd have no fear calling it a dialect of haskell
09:19:44 <sipa> i know at least two separate definitions for real number :)
09:19:48 <tswett> Indeed.
09:19:50 <Cale> Well, it's not one language really, it's a community of people working on a bunch of languages which are in the same vein.
09:19:59 <tswett> sipa: yes, but aren't they equivalent?  }:)
09:20:09 <quicksilver> tswett: but the fact that it is actually impure and, in some specific places, strict, makes it a different langauge in character.
09:20:13 <adimit> tswett: also, I know of no language of any significance that doesn't have *at least* one dialect *per existing compiler*
09:20:16 <quicksilver> (although similar in appearance!)
09:20:21 <tswett> Maybe we should just use the simplest practical language.  }:P
09:20:57 <Cale> I know a bunch of definitions of real number which are all equivalent to one another up to appropriately strong isomorphisms, and then I know of a weirdo definition which isn't equivalent at all and probably shouldn't be called "real number".
09:21:29 <geheimdienst> the so-called o rly numbers
09:21:36 <yitz> sipa: a real number is an element of a totally ordered dedekind complete field, which is unique up to isomorphism.
09:21:42 <monochrom> "natural number" means merely 2 things. "exponentiation" merely 3. juxtaposition merely 4.
09:21:59 <tswett> We could write programs in the essence of Turing-completeness itself.  But then we're starting to get silly.  }:P
09:22:03 <tswett> Cale: oh?  What's the weirdo definition?
09:22:18 <yitz> sipa: there are various constructions to show that there is one of those and not zero. but basically they're unique.
09:22:23 <sipa> yitz: yes, the other definition involved cauchy series
09:22:31 <sipa> but that's isomorphic indeed
09:22:40 <yitz> sipa: the best definition is that they are inifinite decimals.
09:23:02 <Cale> tswett: The constructivists' one, which looks really similar to a standard way of defining reals, but since it occurs inside a different logical system, entirely different conclusions get made about them.
09:23:03 <yitz> sipa: it's the most intuitive, concrete, and it's how we really think of them.
09:23:16 <Cale> yitz: ;___;
09:23:24 <Cale> That isn't how I think of real numbers at all
09:23:27 <sipa> yitz: you would need an equivalence relation that makes 1.0000... and 0.999... equal though :)
09:23:28 <tswett> yitz: well, the real numbers *aren't* infinite decimals; they're equivalence classes of infinite decimals.
09:23:37 <yitz> Cale: most people. :)
09:23:46 <tswett> It's just that most of the classes only contain one elements, and the rest only contain two.
09:23:50 <Cale> Decimal expansions are a horrible way to provide intuition about the reals, and lead to all sorts of awful confusion.
09:23:57 <yitz> tswett: no, disallow infinite repeating 9.
09:24:17 <Cale> They're very unnatural compared with an axiomatic approach, even.
09:24:24 <yitz> Cale: i disagree. it's simple straightforward and accurate
09:24:25 * sipa wonders how to adapt this definition to base-phi numbers
09:24:35 <tswett> I think I usually think of real numbers as points on the number line, or occasionally actions upon the number line.
09:24:49 <tswett> sipa: infinite decimals where there are never two 1s in a row.
09:24:49 <Cale> yitz: Prove that decimal expansions satisfy the least upper bound property.
09:25:02 <yitz> Cale: why unnatural? much more natural than, say, dedekind cuts, which are synthetic and artificial
09:25:02 <rkrzr> I have another parsec question: I would like to parse a lowercase identifier UNLESS it is a keyword, like e.g. "in", can I do that with lookAhead somehow?
09:25:07 <sipa> tswett: right, if you go exclude things, indeed
09:25:20 * monochrom hugs his dedekind cuts
09:25:23 <Cale> yitz: Have you tried proving anything about decimal expansions? :)
09:25:31 <tswett> yitz: I'd argue that Dedekind cuts are much more natural than, say, decimal expansions, which are synthetic and artificial.  }:)
09:25:42 <yitz> Cale: yep, at least as easy as dedekind cuts for everything
09:25:50 * monochrom feels sad today and makes more dedekind cuts on his arm!
09:26:11 <tswett> Anyway, I think I prefer to define the real numbers as the completion of the field of fractions of the initial ring.  Granted, it would take me a long time to prove that this definition is even valid...
09:26:23 <Cale> Showing that Dedekind cuts (at least the one-sided kind) have the least upper bound property is trivial. Doing the same for decimal expansions is a bitch.
09:26:24 <sipa> after dozens of attempts to find out why ubuntu gtk usb disk creator silently fails after a while, i finally found out it just doens't work under xmonad
09:26:58 <monochrom> decimal expansion is not more natural than dedekind cuts. decimal expansion is taught first. that is all. how to distinguish education from brainwashing?
09:27:07 <Cale> You can just take the union of a nonempty set of Dedekind cuts to find its least upper bound.
09:27:22 <yitz> Cale: let A be the subring of Z[[X]] of series whose sequencs of coefficients are absolutely polynomial bounded. Fix b >= 2. Define R = A / (1-bX). Done, basically.
09:28:05 <Cale> But for decimal expansions, you have to worry about coefficients/digits, and not producing an infinite sequence of 9's, if you're disallowing those.
09:28:06 <yitz> Cale: there is something to prove, but the proof is elementary and simple (though there's a trick to it, it's fun, try it).
09:28:18 <roconnor> of course that is like saying it is trivial to find out if a Turing machine halts or not.
09:28:20 <Cale> and lots of other crap which doesn't really matter
09:29:36 <yitz> Cale: we shall say that a series sum [a i | i <- [0..]] is "radix b" if a 0 >= 0, a i `elem` [0..b-1] for i > 0, and for all N there is i > N such that a i /= b-1.
09:29:38 <roconnor> oh wait, nevermind.  It is indeed trivial to *show* that a Turing machine halts or not.
09:29:47 <monochrom> hahahaha
09:30:12 <tswett> I dunno.  In intuitionistic logic, can you prove that for every Turing machine, either that Turing machine halts, or for all natural numbers n, it's still running after n steps?
09:30:41 <roconnor> tswett: nope
09:30:42 <yitz> Cale: Prop.: if x is a real number, there is a unique radix b series that represents one of x or -x. If x has an all-non-negative representation, then it has a radix b representation.
09:30:54 <roconnor> Twey: oh wait
09:30:57 <roconnor> oops
09:31:24 <yitz> roconnor: were you the one who wrote the nice blog post about *-algebras?
09:31:28 <tswett> My mental model of intuitionistic logic pretty much says "it's the logic of computability stuff".  If the halting problem is unsolvable, there's probably a corresponding excluded middle that's unprovable.
09:31:33 <tromp> tswett: only for some TMs, since it has to decide halting
09:31:55 <roconnor> tswett: it is provable that for every turning machine and for every n, either it halts after n steps or it is still running after n steps
09:32:12 <roconnor> tswett: which isn't quite what you said, but probably what you meant
09:32:28 <roconnor> yitz: yes
09:33:13 <yitz> Cale: it then follows that R is a field by long division, and that it is complete by the first chapter of any freshman calculus text.
09:33:31 <yitz> roconnor: could you please convince Google to index it?
09:33:58 <Cale> yitz: I'm not saying that it can't be done, I'm just complaining that doing it is more awkward than either the presentation by Cauchy sequences of rationals or by Dedekind cuts.
09:34:02 <roconnor> to tie this in with LUB principle, consider the set {A_n | n \in N} where A_n is 1 if the machine A has halted after n step and 0 otherwise.
09:34:04 <yitz> roconnor: what do i search for? none of the obvious terms seems to hit it even after several pages.
09:35:05 <yitz> Cale: i just did all the work - even the tedious parts - in a few irc posts. you can't do that with dedekind cuts, certainly not with cauchy sequences or integer slope functions.
09:35:18 <Cale> You didn't though.
09:35:23 <yitz> Cale: i think it's far less awkward than the others.
09:35:29 <Cale> You alluded to the work which needed to be done without carrying it out
09:35:32 <roconnor> yitz: look for words found in http://r6.ca/blog/20110808T035622Z.html
09:36:22 <Cale> In the case of Cauchy sequences, all the algebraic operations are easier to define than either the case of Dedekind cuts or decimal expansions, and Dedekind cuts have the advantage of the least upper bound property being particularly easy to handle, and the algebraic operations are still easier to define than those for decimal expansions.
09:36:22 <yitz> Cale: pretty close. anyway, i've written all three out in all detail. infinite decimal is clearly the most elegant and intuitive in my opinion.
09:38:28 <roconnor> Even constructively there is a unique upto isomorphism structure that is a complete ordered archimedean field which we can call the real numbers.
09:38:39 <yitz> Cale: historically the reals were first defined by Weirstrass as infinite decimals. however, his paper is a mess and unaccessable. that led to these other clever but less straightforward constructions becoming popular, and a popular misconception that the straightforward construction is tedious and messy. but in modern notation, it turns out to be really nice.
09:38:45 <tswett> There's probably not much use arguing over which of two things is nicer.
09:39:12 <Philonous> I wonder whether the decimal expansion definition isn't subsumed by the cauchy series one
09:39:31 <tswett> It's hard to tell whether we're talking about actual, existing things, or simply our own feelings.
09:39:31 <fedvasu> hi folks , noob here
09:39:33 <fedvasu> where is the FM for quickcheck
09:39:38 <tswett> Hi, fedvasu.
09:39:43 <fedvasu> hi
09:39:48 <Cale> fedvasu: FM?
09:39:51 <yitz> Cale: no. defining the algebraic operations and proving all of their properties is tedious. for decimal notation, you're starting with a well-know ring so it's automatic, and every elementary school child even knows how to compute with them fluently.
09:39:58 <fedvasu> manual
09:40:10 <fedvasu> the haskell wiki is outdated
09:40:16 <fedvasu> i'm using 7.0.4
09:40:17 <co_dh> greeting. I'd like to use Haskell to parse a html file, and out put all the tr  inside, any suggestion?
09:40:20 <fedvasu> in fedora
09:40:31 <roconnor> yitz: um, isn't multiplying infinite strings of decimals really tricky?
09:40:33 <Cale> http://hackage.haskell.org/package/QuickCheck
09:40:34 <tswett> Isn't defining the algebraic operations on Cauchy sequences trivial?  Addition is elementwise addition.  Multiplication is elementwise multiplication.  That's it.
09:40:38 <co_dh> I've tried haxml, but don't know how to output just a <tr>
09:40:39 <Cale> fedvasu: ^^ it's there
09:40:49 <yitz> roconnor: ok, thanks. (sigh) do you have a robots.txt that's stopping it or something?
09:40:55 <Cale> fedvasu: click on the module names to see the documentation for each
09:40:56 <c_wraith> tswett: equality is infinite-time, though
09:41:03 <Cale> yitz: "well known ring"?
09:41:05 <fedvasu> cale: thanks for the hackage pointer
09:41:07 <Cale> yitz: which one?
09:41:11 <roconnor> yitz: not that I'm aware of.
09:41:36 <Cale> yitz: Of course, if you assume that strings of digits form a ring, you've skipped much of the work that I said was tedious.
09:41:38 <yitz> roconnor: no. multiplication in Z[[X]] is defined exactly as in polynomial rings.
09:41:58 <roconnor> yitz: seriously I don't think I even know how to multiply decimal expansions
09:42:23 <yitz> Cale: the formal power series ring, which is conceptually just like a polynomial ring.
09:42:54 <yitz> Cale: i defined it that way, so yes, they form a ring
09:42:54 <fedvasu> sorry to interrupt again
09:43:09 <fedvasu> i can't find any module Test.quiccheck
09:43:11 <Cale> yitz: Okay, so you're quotienting out that ring by an appropriate ideal
09:43:14 <fedvasu> in ghci
09:43:24 <roconnor> yitz: it is #3 hit on a google search for StarSemiring
09:43:39 <fedvasu> i installed it from package manager ,the package ghc-quickcheck
09:44:26 <bgamari> Is there any library support for looking up a time zone from string (e.g. America/New_York)?
09:44:28 <geheimdienst> fedvasu: you're not interrupting anything :) that's what the channel is here for. have you double-checked the name? it should be "import Test.QuickCheck", as stated in the docs. uppercase matters
09:44:28 <yitz> Cale: right, and then the usual "string of digits thing" uniquely represents the cosets. you can just do the operations as usual, and it is guaranteed that carrying will terminate in a small number of steps on each digit.
09:44:29 <Cale> yitz: and, for some reason, you wanted the coefficients to be absolutely polynomial bounded, which sounds like more work :)
09:44:46 <Cale> (so you have to show that's actually a subring)
09:44:53 <Cale> (not so bad, I'll admit)
09:44:58 <fedvasu> yeah  i tried :m + Test.Quickcheck
09:45:19 <geheimdienst> no, the C in the middle of QuickCheck needs to be uppercase too
09:45:20 <Cale> and then you have to prove the result about cosets admitting that representation.
09:45:33 <yitz> Cale: no polynomial boundedness is actually one of the essential ingredients.
09:45:34 <bgamari> It seems like time zone support in the time package is only mildly less broken than that of most other languages'
09:45:45 <monochrom> fedvasu: Test.QuickCheck ?
09:45:47 <bgamari> admittedly, it's a hard problem
09:45:51 <geheimdienst> (use the name exactly as given on http://hackage.haskell.org/packages/archive/QuickCheck/2.4.1.1/doc/html/Test-QuickCheck.html ). in ghci you can also use tab-completion: import Te<tab>
09:46:03 <yitz> Cale: note that the multiplication formula for polynomials is itself a polynomial.
09:46:20 <fedvasu> when i hit <tab> after T it will go to Text. something
09:46:31 <roconnor> yitz: presumally you mean "not-quite uniquely represents the cosets"?
09:46:33 <yitz> bgamari: see the timezone-series and timezone-olson packages to complement it
09:46:39 <fedvasu> no Text. (module/typeclass at all!!!!)
09:46:57 <fedvasu> oops .. "Test."
09:47:02 <yitz> roconnor: i defined "radix b" series to be those that don't end in repeating b-1.
09:47:22 <yitz> roconnor: they uniquely represent the non-negative reals.
09:47:26 <bgamari> yitz: I see that, unfortunately there's no support in timezone-olson for searching for a timezone in a set of zone files (not to mention you need to know where the zone files are located, which is system-specific)
09:47:27 <geheimdienst> fedvasu: hit tab again ...
09:47:34 <Cale> yitz: But it's looking a lot worse already than even the definition of multiplication for Dedekind cuts, which I'll admit is not pretty.
09:47:40 <fedvasu> you don't understand
09:48:02 <fedvasu> there is no Test super module at all
09:48:20 <Cale> yitz: It's not just formal power series, it's a quotient of a specific subring of them which has to be proven a subring, and then that the cosets of the quotient admit particular representatives
09:48:21 <monochrom> that is right. so?
09:48:35 <fedvasu> here i spam the output
09:48:36 <fedvasu> :m + Test.QuickCheck  <no location info>:     Could not find module `Test.QuickCheck':       it is not a module in the current program, or in any known package.
09:48:55 <yitz> bgamari: yeah it's system specific. it's not hard to search the zone identifiers in an olson file once you've parsed it, but yeah, it would be nice to have some better search facilities.
09:49:06 <roconnor> yitz: this all sounds pretty convoluted to me: taking quotients, selecting not-quite unique representitives, using an uncomputable hack to get unique representatives.
09:49:07 <Cale> and all that is a lot more tedious a setup than, say, http://planetmath.org/encyclopedia/DedekindCuts.html
09:49:08 <monochrom> what does "which ghc" say?
09:49:18 <fedvasu> 7.0.4
09:49:20 <sm> Philonous: I got farther thanks to your hint, and haven't run into any retainer profiling crashes yet. http://joyful.com/darcsden/simon/rss2irc/raw/rss2ircp.ps shows some retainers in the xml lib FYI
09:49:27 <Cale> yitz: define x < y with your definition of real numbers ;)
09:49:35 <monochrom> no, "which ghc" should give a pathname not a version number.
09:49:44 <Cale> yitz: and compare that with the corresponding definition for Dedekind cuts
09:49:57 <Cale> (okay, that's pretty unfair, but still... :)
09:49:58 <yitz> bgamari: the biggest missing pieces at the moment are windows registry support (the format is slightly different than binary olson), and POSIX rules, which just started appearing in olson files in the wild a few months ago.
09:50:17 <fedvasu> yeah /usr/bin/ghc
09:50:36 <fedvasu> monochrom: there is your answer
09:50:41 <bgamari> yitz: Alright, well thanks. I guess I'll just code the search myself for the time being!
09:51:01 <Cale> yitz: Don't forget to show that your definition of < gives a total ordering ;)
09:51:14 <yitz> roconnor: the cauchy sequence constuction is also a quotient of a ring by an ideal. the integer slope function construction is worse, it can only be done by explicit equivalence classes.
09:51:16 <bgamari> yitz: Even if the library had a Maybe FilePath for the root of the zonefile repository that would be an improvement
09:51:45 <roconnor> what is the integer slope function construction?
09:51:56 <sm> Philonous: rss2ircp.prof is at the same path
09:52:28 <tswett> roconnor: I imagine a real number a is defined as the integer function f(n) = floor(a*n) or something like that.
09:52:29 <roconnor> yitz: Yes, it is a quotient construction, but the construction stops there.  There is no point in wasting energy fining uncomputable unique representitives.
09:52:36 <yitz> roconnor: they're unique. the problem with infinit repeating b-1 is taught in grade school. it's not an uncomputable hack, the computation is straightforward and every child is fluent with it.
09:53:03 <tswett> roconnor: then the real number is the slope of that integer function.
09:53:10 <geheimdienst> bgamari: when you have a solution, consider putting it on hackage, we could really use it :)
09:53:21 <byorgey> vharishankar: nice blog post
09:53:29 <yitz> bgamari: if you want to write it in a way that it can be released on hackage - or added to one of the libraries if you think that makes sense - it would be great!
09:53:40 <roconnor> yitz: it is most definitely uncomputable.  Tell me does this number end in repeating 9 or not 0.19283419024398123472394812904198234192042937419234...
09:54:18 <bgamari> geheimdienst, yitz: I'll see what I can do
09:54:21 <aristid> roconnor: maybe you should specify the number more precisely first :)
09:54:23 <monochrom> fedvasu: apparently the rpm ghc-QuickCheck is not enough. and I don't know fedora and I don't know which rpm you need
09:54:25 <byorgey> vharishankar: when you've been doing this stuff for a while it's easy to forget how hard it can be at first, so I appreciate you making a record of your impressions
09:54:28 <roconnor> tswett: interesting
09:54:29 <geheimdienst> bgamari: great, thanks
09:54:47 <kirindave> byorgey, +1
09:54:55 <vharishankar> byorgey: thanks. :-)
09:54:59 <fedvasu> monochrom: i have installed with package manager
09:54:59 <roconnor> aristid, yitz: fair. Ask me for any decimal place and I will tell you the digit.
09:55:01 <kirindave> byorgey, or perhaps "nevar froget newbism"
09:55:05 <fedvasu> it did dep resolution
09:55:08 <aristid> roconnor: 1328
09:55:16 <roconnor> aristid, yitz: I'm your oracle for that number
09:55:30 <aristid> a slow oracle if i may say so
09:55:44 <yitz> Cale: yep that's easy. we define a that a real number is positive if it has a radix b representation. all the axioms of total ordering follow directly. for computation, it is trivial to show that for positive real numbers this ordering is the same as the dictionary ordering on their radix b representations.
09:55:53 <monochrom> sure, I looked at its deps too, not enough.
09:56:11 <yitz> roconnor: sure i'll tell you. just give me the rest of the digits please...
09:56:13 <fedvasu> what? a bug?
09:56:41 <monochrom> simply not the right package at all
09:56:51 <roconnor> yitz: I'll give you any the value for any decimal position you like.
09:57:20 <fedvasu> monochrom:i'm using fedora 16 beta  and ghc-7.0.4, it installed many packages as dep,ghc-array,ghc-time and many more
09:57:23 <sipa> if you're going to ask him for an infinite amount of information, i doubt what you're doing is computable  :)
09:57:32 <monochrom> and I don't know the name of the right package, and I don't want to know. fedora is annoying in this aspect. splitting software to the point it confuses
09:57:52 <fedvasu> when i installed ghc-quickcheck
09:58:00 <kirindave> monochrom, this is why people who say that cabal-install should not be a package manager frustrate me so.
09:58:03 <monochrom> I am sorry to say that no amount of explaining to me will change the fact.
09:58:31 <fedvasu> so i should file a bug?
09:58:36 <kirindave> monochrom, There simply isn't a better option than for languages to manage their own libraries at this point in time. Inevitably debian-ification or fedora-ification hurts to work with.
09:58:37 <yitz> roconnor: be careful not to confuse limitations on practical calculation with the existence construction. remember, with the other constructions, you can't calculate at all. here, you automatically get that the usual methods of calculation, with their usual limitations, are concretely reflected in the construction. i think that's nice!
09:59:27 <roconnor> yitz: " you can't calculate at all. here, you automatically get that the usual methods of calculation,"  This seems like a contradiction to me.
09:59:37 <vharishankar> kirindave: I find Haskell's approach to package management different in the sense that it doesn't interfere with the system files.
09:59:49 <fedvasu> monochrom: though i'm suffereing now
09:59:59 <kirindave> vharishankar, same as cpan, ruby, python, plt scheme, and others
09:59:59 <roconnor> yitz: this isn't a limit on practical computation;  This is a limit on theortical computation
10:00:08 <yitz> roconnor: kids learn how to calculate with decimal representation in school. they don't learn how to calculate with cauchy sequences.
10:00:11 <fedvasu> splitting software makes sesnse
10:00:23 <roconnor> yitz: it is impossible, even in theory, to decide if a stream of digits ends in repeating 9s
10:00:24 <sm> +1 vharishankar, nice post
10:00:29 <fedvasu> like example installing ipython in Debian would automatically
10:00:29 <vharishankar> kirindave: true, though I prefer to work within the distribution's own package management if possible, for consistency.
10:00:43 <vharishankar> sm: thank you.
10:00:44 <roconnor> yitz: No one in school learns how to multiply infinite strings of decimals
10:00:48 <fedvasu> install ipython and ipythonx , which in turn depends on wcWidgets
10:00:54 <hpaste> Prabhat pasted “Strategies/Par monad parMap” at http://hpaste.org/53361
10:01:07 <yitz> roconnor: ok. and if the reals are constructed as, say, dedekind cuts, and i have a decimal representation of them, are you any better off?
10:01:10 <tswett> Are you guys telling me that you didn't learn about metric spaces, rings, fields, and categories in grade school?
10:01:19 <kirindave> vharishankar, I just think that most package systems are not helpful when it comes to what developers need when distributing software.
10:01:36 <kirindave> vharishankar, this is why gradually everyone is going back to things like static binaries, fat jars, and rubygem-builder
10:01:40 <fedvasu> grade school? ??
10:01:49 <kirindave> Deploying software? It is not the time for dynamic deps
10:01:51 <vharishankar> kirindave: yes, it's oriented towards end users. But the solution is not easy.
10:02:00 <gentleben> kirindave: so true
10:02:33 <yitz> tswett: hey we are haskell nerds, we were different
10:02:40 <roconnor> yitz: probably a little better off; though clearly I wouldn't be a fan of dedekind cuts.
10:02:46 <pt114> can any tell me what is wrong with this code http://hpaste.org/53361
10:02:58 <tswett> In my country, every student is required to be proficient with metric spaces, rings, fields, and categories by age 10.  }:)
10:03:02 <kirindave> vharishankar, how is it oriented towards end users? :\
10:03:10 <pt114> i'm basically comparing the parMap in Strategies and that in Par monad
10:03:21 <kirindave> I submit it is unhelpful as all hell to ship software fragmented into tiny barely-interlocking pieces.
10:03:29 <aristid> tswett: as it should be
10:03:31 <copumpkin> tswett: mine too!
10:03:33 <vharishankar> kirindave: everybody wants a point and click interface.
10:03:40 <kirindave> pt114, my conclusion there was that Strategies is so much more awkward to use for most things that I avoid it.
10:03:50 <kirindave> pt114, Par, on the other hand, can be really helpful.
10:03:51 <vharishankar> Deploying software for developers is different problem than deploying for end users.
10:04:05 <kirindave> vharishankar, what is easier than static binaries? :)
10:04:09 <kirindave> They show up, they work. End of line!
10:04:25 <vharishankar> kirindave: static binaries are good in the days of DOS. :-)
10:04:43 <pt114> kirindave: but why does my code doesn't work
10:04:43 <kirindave> vharishankar, why are they bad now?
10:04:58 <pt114> it works fine with haskell map and parMap found in Strategies
10:05:00 <kirindave> pt114, that I cannot tell you :)
10:05:08 <tswett> Now, I wonder if it would ever be useful to have an I monad.  I is the type of things that have no visible side effects, but nevertheless may return different values in different circumstances.
10:05:09 <kirindave> Because I got specs to write. Sorry dude.
10:05:10 <vharishankar> kirindave: because static binaries is just an ugly solution. Just throwing the kitchen sink at the problem. :-)
10:05:14 <roconnor> yitz: I don't mean this to be contary; As someone whose PhD thesis was implementing constructions of the real numbers, I have a strong interest in finding the "easiest" method of constructing the real numbers.
10:05:17 <kirindave> vharishankar, why do users care?
10:05:40 <kirindave> vharishankar, they don't care about how bloated a binary is so long as it performs well and runs every time.
10:05:48 <vharishankar> kirindave: I am not sure whether they do or not, so long as it is click-and-work.
10:05:53 <kirindave> So
10:05:57 <kirindave> Similarly
10:05:58 <gentleben> vharishankar: haskell currently doesn't uniquely identify a build for linking against
10:06:02 <kirindave> When you are building distributed systems
10:06:07 <monochrom> not quite, kirindave, the debian packages are not hair-splitted like fedora ones. if you search for debian packages of quickcheck, you get these 6: for QC1, -dev, -prof, -doc; for QC2, -dev, -prof, -doc. you immediately know you want QC2's -dev and that will suffice for a while. on fedora, do you know what they do? they have one package for the *.so file that nobody uses, another package for the *.hi *.o *.a that ghc actually
10:06:07 <gentleben> at least to my knowledge
10:06:07 <pt114> HELP using parMap from monad-par, anyone?
10:06:07 <monochrom>  uses. you do a search, you think the first one is enough, in fact you're probably only told about the first one because you need one more unknown keyword for the second one (rpmfind.net's search box is not very smart)
10:06:51 <gentleben> we use a build server with blessed packages versions to cut all builds
10:06:54 <kirindave> vharishankar, it doesn't help that most of the unix world refuses to adopt a superior library organization scheme like Apple's .framework and .app stuff
10:07:13 <geheimdienst> is there a function vaguely like sequence that transforms (a, IO b) into IO (a, b) ? hoogle didn't help
10:07:15 <vharishankar> kirindave: I wouldn't know about Apple though.
10:07:29 <geheimdienst> kirindave: what's superior about that?
10:07:29 <roconnor> kirindave: how does .framework .app work?
10:07:29 <gentleben> all the dependent binaries are snapshotted and archived with the appropriate links to source control
10:07:54 <kirindave> roconnor, .framework files contain both build and compiled artifacts, sorted by version
10:08:02 <gentleben> eventually we will move all dependencies into a source tree and remove all of cabal from our process
10:08:10 <yitz> Cale: the fact that it is a subring is obvious. the unique radix b representation of cosets needs proof, and it is the essential step. (and it's actually interesting) everything else falls out almost automatically from that, it's pretty amazing actually.
10:08:14 <roconnor> geheimdienst: you can write it yourself as \(a, mb) -> fmap (a,) mb
10:08:19 <kirindave> When you "Install" a library you actually install it, its headers, and whatnot into a well-known tree structure in the library's .framework
10:08:28 <vharishankar> Anyhow, it's getting late here. Thanks for the article feedback everybody. :-)
10:08:32 <kirindave> As for .apps, they are like that but contain frameworks
10:08:48 <kirindave> So for example, you don't have to care about clashing includes or binaries
10:08:51 <roconnor> geheimdienst: this function is commonly called "strength" I believe.
10:09:11 <geheimdienst> "strength"!?
10:09:22 <roconnor> geheimdienst: it is a term from category theory
10:09:38 <roconnor> geheimdienst: but someone knowing CT may know better than me
10:09:49 <yitz> geheimdienst: do you mean (IO a, IO b) -> IO (a, b) ?
10:10:28 <geheimdienst> oh right, CT, our prime source of ridiculous jargon wrapping around not much substantial ...
10:10:32 <c_wraith> :t liftM2 (,)
10:10:33 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
10:10:35 <dolio> A functor F is strong if there's a mapping A x F B -> F (A x B) natural in A and B, I believe.
10:10:43 <c_wraith> :t uncurry $ liftM2 (,)
10:10:44 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
10:10:58 <roconnor> dolio: and what is the name of the map?
10:11:04 <yitz> roconnor: thanks for the relink. my problem is that i'll never remember "star semiring".
10:11:10 <Philonous> sm:  Btw. even without a potential leak, the xml library seems to introduce huge overheads. A 400k xml file blew up to 80MB of memory usage. I'd guess it has something to do with the fact that it uses Strings as an internal representation (profiler says lot's of (:) )
10:11:12 <geheimdienst> yitz: could be. you could just do "return" to the fst of the tuple
10:11:17 <dolio> Strength is a fine name.
10:11:29 <yitz> roconnor: maybe add some meta keywords like star algebra, kleene algebra, regular expression, haskell.
10:11:55 <roconnor> yitz: it is the #1 hit when searching for: that blog post on really general semiring thing
10:12:17 <yitz> dolio: i think it's only a good name if the types have a Num instance. there's strength in numbers.
10:12:40 <dolio> Wow.
10:12:47 * yitz repeats over and over: semiring, semiring, ...
10:12:58 <sm> Philonous: nod.
10:13:06 <roconnor> yitz: oh I didn't realize semiring was the hard bit for you to remember.
10:13:43 <geheimdienst> anyway, thanks for the help, guys, i appreciate it
10:14:34 <bgamari> geheimdienst, yitz: Would autoconf be the best way to find the zonefile root?
10:14:38 * edwardk joins the herd of eager fanboys chanting "kind polymorphism", and trying to cheer Brent and everyone on in their efforts to slip it in under the wire ;)
10:14:38 <yitz> roconnor: implementing constructions of the reals - meaning machine implementation?
10:14:47 <roconnor> yitz: in Coq
10:14:49 <dolio> roconnor: I don't know what it's called in category theory. Probably alpha or something meaningless like that.
10:15:11 <roconnor> dolio: oh, that is likely
10:15:11 <yitz> roconnor: interesting. nice to hear that.
10:15:34 <yitz> roconnor: i never claimed that this construction is the nicest for implementation in Coq.
10:15:38 <roconnor> yitz: you can find my thesis at http://r6.ca/thesis.pdf  Part II is on real numbers
10:15:51 <fedvasu> monochrom and other folks , I have filed a bug
10:15:54 <yitz> roconnor: cool. thanks!
10:16:01 <fedvasu> let us see whats the reply.
10:16:10 <fedvasu> thanks for help..
10:16:12 <roconnor> yitz: I understand.  I put "easiest" in quotes because what construction is easiest depends on the context.
10:16:15 <fedvasu> see you around
10:16:44 <yitz> edwardk: i'm a fanboi of that too. hope it gets in.
10:16:59 <edwardk> i just want to finally be able to write product categories
10:17:07 <shapr> GOOD MORNING #HASKELL!
10:17:14 <shapr> How's code treating everybody?
10:17:18 <edwardk> its a shapr, RUN!
10:17:22 <roconnor> yitz: actually, I implemented fast converging cauchy sequences because I was trying to balance easy to reason with and fast to compute with.
10:17:37 * geheimdienst checks his watch and blood pressure, and both indicate it's not morning by any stretch
10:17:39 * shapr does a timing attack on edwardk's birthday present
10:17:49 <gentleben> does anyone know of a library that does distributed leader election?
10:18:07 <roconnor> yitz: The previous implementation was standard Cauchy sequences which I think is the easiest construction to reason with.
10:18:08 <fedvasu> geheimdienst: see my output :m + Test.QuickCheck  <no location info>:     Could not find module `Test.QuickCheck':       it is not a module in the current program, or in any known package.
10:18:26 <roconnor> yitz: well, easiest to reason with while still being constructive.
10:18:42 <yitz> roconnor: did you consider slope functions?
10:19:00 <yitz> roconnor: that's the latest buzz in real number construction
10:19:04 <roconnor> yitz: I didn't give any thought to Dedekind cuts which isn't constructive ... (modulo whatever they do in Abstract Stone Duality).
10:19:05 <shapr> edwardk: I'm still happy I pulled off that race condition and actually surprised you with a present :-)
10:19:13 <edwardk> =)
10:19:24 <roconnor> yitz: I hadn't heard of slopw functions until today; and I still don't quite understand it.
10:19:24 <edwardk> shapr: so you going to make it to hac boston?
10:19:28 <roconnor> *slope
10:19:45 <yitz> roconnor: not sure it would have helped you, but it's clever
10:19:51 <shapr> edwardk: Let me check the dates...
10:19:58 <fedvasu> that's it , ...
10:20:28 <byorgey> edwardk: do you have any registrations yet?
10:21:10 <roconnor> yitz: I want to read Norbert's "A natural construction for the real numbers"?
10:21:10 <edwardk> we're at around 21 registrations out of 30 slots. i've already put in for more space
10:21:11 <gtirloni> while reading RWH (chap 15 - parsec) there is a function like this "line :: GenParser Char st [String]" ... it's supposed to return [String] but so far I've been told that functions have "a -> b".. what allows this declaration to be that one (i.e. not look like a "normal" function) ? http://book.realworldhaskell.org/read/using-parsec.html
10:21:29 <edwardk> since i haven't heard from any of the usual new york crowd
10:21:41 <geheimdienst> fedvasu: yeah, thanks for filing a bug. it must be an installation issue. in the meantime, consider using cabal to install quickcheck
10:21:43 <edwardk> or even about half the folks who usually show up to normal boston haskell events
10:22:19 <shapr> edwardk: Bah humbug... classes here start on January 11th.
10:22:31 <edwardk> gtirloni: line isn't a function it yields a data type, that data type happens to _contain_ a function somewhere
10:23:38 <edwardk> shapr: skip ;)
10:24:00 <shapr> edwardk: Um, I like getting good grades.
10:24:13 <gtirloni> edwardk: i'm not familiar with that in haskell yet.. am i looking at monadic code? trying to understand what i should read next
10:24:21 <edwardk> gtirloni: yes, it is a monad
10:24:26 <gtirloni> edwardk: ah ok, thx!
10:24:43 <byorgey> edwardk: not 100% sure yet whether I can come but I guess I will register preemptively =)
10:24:45 <c_wraith> gtirloni: the fact that's a monadic value isn't really important, though.
10:24:53 <edwardk> byorgey: good idea =)
10:28:30 <kirindave> Does HSH work under ghc 7.2.1 yet?
10:28:35 <kirindave> It had a runtime error last time I tried
10:28:49 <dmwit> byorgey: Want to share a hotel?
10:30:35 <d34df00d> Hi!
10:30:47 <shapr> hi d34df00d, are you learning Haskell?
10:30:55 <d34df00d> shapr: kinda.
10:31:18 <d34df00d> I need to generate a biiiig string from a list of words and a list of random values which define which words to use.
10:31:49 <shapr> d34df00d: How are you doing it now?
10:31:53 <d34df00d> I use Box-Muller transform to get normal distribution from standard random's result.
10:31:57 <d34df00d> shapr: yep.
10:32:06 <d34df00d> Actually, I've written the code, and it works, but it's a bit slow.
10:32:17 <d34df00d> Profiling shows I spend 98% of my time in this function:
10:32:22 <dmwit> ?hpaste
10:32:23 <lambdabot> Haskell pastebin: http://hpaste.org/
10:32:32 <dmwit> (Please don't paste long code snippets in-channel.)
10:32:41 <shapr> d34df00d: Please paste to hpaste.org
10:32:47 <d34df00d> http://paste.pocoo.org/show/500933/
10:32:50 <d34df00d> Oh, sorry.
10:32:50 <dmwit> great =)
10:32:55 <dmwit> No, that's fine.
10:33:00 <d34df00d> I always paste to paste.pocoo.org.
10:33:03 <d34df00d> Hope that's ok :)
10:33:09 <d34df00d> So, any advice about optimizing it?
10:33:45 <d34df00d> Well, 'ws' is list of words from some language dictionary and 'rs' is (infinite) list of random values.
10:34:36 <dmwit> Yes, use a Map or IntMap instead of a list and (!!).
10:35:02 <d34df00d> I guess IntMap is just what I need.
10:35:32 <dmwit> Better yet, use an Array.
10:35:32 <d34df00d> Since I once parse the dictionary and then generate hundreds or thousands of files, with tens-hundreds thousands of words.
10:35:51 <dmwit> It looks like the list never changes, so the "immutable Arrays have really slow update" thing won't bite you.
10:36:01 <d34df00d> Yep, surely.
10:36:02 <d34df00d> It never changes.
10:36:09 <d34df00d> Thanks :)
10:36:33 <d34df00d> dmwit: BTW how could I know that list and !! are the things that slow stuff down?
10:36:41 <dmwit> experience
10:36:50 <d34df00d> I mean, how Haskell-gurus profile their code once they narrow down the hot spots to function level?
10:36:53 <dmwit> And I could easily be wrong.
10:36:55 <etpace> Can anyone recommend a library for the "input/output" of a repl (ie remembering history etc)
10:37:11 <dmwit> d34df00d: Oh, you can add explicit cost centers.
10:37:28 <byorgey> etpace: haskeline
10:37:32 <etpace> thanks
10:37:44 <dmwit> d34df00d: The GHC manual has a good section on how to do this.
10:37:53 <d34df00d> dmwit: oh, thanks, I'd read that.
10:37:55 <jweofijm> @pl f >>= \first -> g >>= \rest -> do ((return.(if' <$> (":t"==) <*> (const (Left True) ) <*> ( if' <$> (":f"==) <*> (const (Left False) ) <*> (Right) ))) (first:rest))
10:37:56 <lambdabot> (g >>=) . ((do . return . (if' <$> (":t" ==) <*> const (Left True) <*> (if' <$> (":f" ==) <*> const (Left False) <*> Right))) .) . (:) =<< f
10:37:58 <d34df00d> But try Arrays first :)
10:38:37 <dmwit> d34df00d: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html for when you're ready
10:45:40 <shapr> d34df00d: Also, GHC 7.4 upcoming features include improved profiling.
10:45:52 <shapr> Incrementally improved, but more consistent, etc
10:46:04 <d34df00d> Oh, great! GHC is getting tastier and tastier.
10:46:13 <d34df00d> Though I'm still on 7.0.
10:46:48 <d34df00d> dmwit: awesome! Run time decreased from 50 to 7 seconds on a test sample.
10:46:51 <shapr> I'm still on 7.0 myself, but I've been reading byorgey and copumpkin talk about the not-yet-release improvements.
10:46:51 <d34df00d> Thanks a lot!
10:47:28 <sm> Philonous: interesting in porting feed to xml-enumerator ?
10:48:23 <d34df00d> Oh, it slows down when trying to use more cores.
10:48:52 <dmwit> d34df00d: Great! Bummer about multiple cores, though; have you annotated it for parallelism?
10:50:15 <d34df00d> dmwit: yep. I've replaced map with parListChunk ... rdeepseq `withStrategy` map.
10:50:30 <d34df00d> And that's quite high in call hierarchy, so I hope each chunk gets enough work.
10:51:02 <d34df00d> After all, running with -s shows that no sparks are pruned at least, though crazy amounts of time are spent in GC, like 70-80%.
10:54:14 <dmwit> Odd. Have you tried using a tool like threadscope or so?
10:54:30 <d34df00d> Not yet.
10:54:31 <ClaudiusMaximus> d34df00d: heap profile to see what's using too much memory; also try tuning the RTS flags for memory/GC (allocation area or something, forgot the terminology..); maybe unboxed arrays would be faster (assuming your algorithm allows it)
10:54:58 <d34df00d> Well, actually tried with other project, but couldn't make any use of it — yeah, nice graphs and such, but how one should interpret them?
10:55:30 <d34df00d> ClaudiusMaximus: UArray wouldn't work with Strings (and need to keep strings) as far as I could understood, unfortunately. Though heap profiling is kind of next step, yes.
10:55:40 <ClaudiusMaximus> basically if you get something growing when you think it should be flat, that's the cost centre/type to target
10:57:05 <d34df00d> Actually, it's my second code that is perfect for parallelism and the second one that only suffers from it.
10:57:36 <ClaudiusMaximus> unfortunately heap profiling and parallelism didn't play too nice together last time i tried (ghc-7.0.4)
10:59:21 <ClaudiusMaximus> threadscope is great, haven't tried it recently, it's probably really great by now :)
11:00:23 <sm> ClaudiusMaximus: does threadscope supersede hp2any do you think ?
11:00:34 <d34df00d> Yeah, No instance for (IArray UArray String)
11:01:28 <ClaudiusMaximus> different purposes - threadscope lets you see what threads are getting up to in detail, didn't see any heap statistics last time i tried it (maybe 9 months ago?)
11:01:47 <sm> oh hmm. Thanks
11:01:48 <ClaudiusMaximus> maybe it will eventually
11:02:13 <c_wraith> threadscope still doesn't cover heap profiling
11:02:15 <sm> one of these days all these diagnostic tools will get rolled together into something awesome
11:02:18 <d34df00d> Well, a couple of weeks ago I haven't seen anything heapprof-related either.
11:03:05 <ClaudiusMaximus> sm: let's hope :)
11:04:13 <Cale> ThreadScope seems like it has enough data that it *could* provide you with lots of statistics
11:04:28 <Cale> I'm not sure if it actually computes those statistics, I haven't really tried it
11:06:13 <d34df00d> Well, I guess I have memory issues because of the way I work with strings when building them.
11:06:17 <c_wraith> well.  threadscope works with a different profile file than the heap profiler reports.  Its profile info only contains events related to thread switching and such
11:06:30 <d34df00d> Creating a list of strings and then intercalate'ing them into one.
11:06:34 <c_wraith> d34df00d: in general, String is a poor type to use for any real work.
11:06:35 <d34df00d> Is there something more optimal?
11:06:41 <yitz> roconnor_: sorry i was away for a while. yes, i think norbert is one of the papers on that.
11:07:00 <d34df00d> I'd repaste the function since it hasn't changed too much: http://paste.pocoo.org/show/500933/
11:07:16 <jweofijm> @pl \ h -> f.(g h)
11:07:17 <lambdabot> (f .) . g
11:07:20 <d34df00d> Running with -hy shows that most of allocations is done for []
11:07:48 <c_wraith> d34df00d: sure, but how much of it is resident at any time?
11:07:57 <d34df00d> c_wraith: hm, what do you mean?
11:08:10 <c_wraith> d34df00d: is it being allocated long before it's freed, or is it pretty tight?
11:08:44 <d34df00d> Well, pretty tight, I guess.
11:09:09 <c_wraith> d34df00d: then...  is GC time a significant amount of your runtime?
11:09:09 <d34df00d> I build a list of strings until the sum length of them isn't greater than, say, 100.000 symbols. Then I concatenate them.
11:09:16 <d34df00d> c_wraith: yep, exactly.
11:09:39 <c_wraith> d34df00d: ah.  Well, have you considered using Text?
11:09:43 <d34df00d> c_wraith: and seems like it holds the program from being run in parallel with all the profits of parallel map and such.
11:10:01 <d34df00d> c_wraith: not yet, I haven't heard yet. Thanks for the hint, I'd try :)
11:10:03 <c_wraith> d34df00d: ah, yes.  GC really kill parallelism
11:10:30 <c_wraith> *kills
11:10:47 <d34df00d> GC is 30-40% with -N1.
11:10:56 <d34df00d> With -N8 it's up to 80%.
11:11:03 <dainanaki> In template haskell, how can I get the name of a local variable?
11:11:24 <kirindave> Huh
11:11:30 <kirindave> I need to do more file I/O code
11:11:38 <kirindave> So i can learn about how to bitch about Haskell better.
11:11:52 <kirindave> I had never realized ~ isn't expanded in openFile's argument. Boo.
11:11:57 <kirindave> Now I can bitch like a pro about it.
11:12:34 <monochrom> yeah why doesn't openFile "$HOME/.bashrc" do what I want
11:12:53 <geheimdienst> kirindave: the shell is responsible for that kind of expansion, and openFile doesn't use a shell
11:13:01 <ClaudiusMaximus> d34df00d: do you need to return 'rs' from that function? maybe the tuple is blocking some potential laziness?
11:13:03 <kirindave> geheimdienst, may I repeat "boo"
11:13:07 <kirindave> I may? Excellent.
11:13:09 <kirindave> Boooooo.
11:13:09 <c_wraith> d34df00d: yeah, calling for GC causes all running threads to stop once they reach the next allocation point, and wait until all capabilities have stopped before proceeding.  That can *really* kill performance
11:13:17 <monochrom> in fact also openFile "ls | grep f"
11:13:43 <kirindave> monochrom, hence I've been asking if HSH works again
11:13:48 <kirindave> Neat trick, compiling but not running in Haskell.
11:13:55 <kirindave> That takes a bit of flair to accomplish.
11:14:07 <geheimdienst> openFile "$HOME/${f#x#u_mpfth%%R_$§#{}}"
11:16:09 <ClaudiusMaximus> @hoogle appuser
11:16:10 <lambdabot> System.Directory getAppUserDataDirectory :: String -> IO FilePath
11:17:11 <ClaudiusMaximus> Prelude System.Directory> getAppUserDataDirectory "foo"
11:17:12 <ClaudiusMaximus> "/home/claude/.foo"
11:17:58 <markstos> Howdy, I'm trying "cabal install" darcs on FreeBSD, but I don't know how to get past this error. Any idea?  "At least the following dependencies are missing: base >= 3.0.0 && < 4.3" .. where do I find "base" ?
11:18:35 <rwbarton> you can't not have base.  Most likely you have a too-recent version of GHC I guess?
11:19:34 <markstos> If I cannot have base, who does my  base belong to?
11:19:56 <rwbarton> try "cabal update" before "cabal install darcs" and failing that, paste the entire cabal output
11:19:58 <geheimdienst> markstos: base is already installed (unless something is terribly hosed). your base package must be outside those version bounds. use "ghc-pkg list" to check
11:20:10 <rwbarton> you cannot *not* have base; your base is belong to you
11:20:15 <markstos> rwbarton, geheimdienst, thanks. I'll see what I can find.
11:20:43 <geheimdienst> you're welcome
11:21:13 <blehteststudent> hey
11:21:16 <rwbarton> The most recent darcs on hackage requires "base (≥3 & <5)"
11:21:31 <blehteststudent> whats the current topic
11:22:07 <markstos> rwbarton: I see the pickle I'm in now. I'm trying to *downgrade* darcs to workaround a bug. By my ghc is apparently too new to compile it. :(
11:22:44 <monochrom> the current topic is http://www.amazon.com/Java-In-21-Minutes/dp/1593272839/
11:22:46 <markstos> rwbarton: but at least I understand the issue and a path forward: downgrade GHC or find a new way to solve the underlying problem.
11:22:59 <rwbarton> in practice you can relax the upper bound on the version of base in the .cabal file for the old darcs, that will almost never actually cause problems
11:23:14 <markstos> rwbarton: oh joy.
11:23:21 <markstos> I'll see how easy that might be.
11:24:21 <markstos> Thanks for the prompt and friendly help #haskell
11:25:15 <dmwit> d34df00d: Oh!
11:25:21 <dmwit> d34df00d: Is there any reason you don't do something like
11:25:40 <dmwit>     | otherwise = word ++ " " ++ makeDoc' (lstr + length word + 1, lws) ...
11:25:58 <dmwit> d34df00d: That is, instead of using an accumulator and making it tail-recursive, just return the bits you know and then keep computing.
11:26:19 <dmwit> d34df00d: As a rule of thumb, that's a better approach in Haskell (where laziness makes tail recursion a bit questionable).
11:27:32 <dmwit> I suppose for you it would be something like
11:28:03 <dmwit>     | otherwise = let ~(rest, randoms) = makeDoc' ... in (word ++ " " ++ rest, randoms)
11:28:13 <dmwit> hm, that ~ may be redundant
11:28:19 <dmwit> > let (a, b) = undefined in "test"
11:28:21 <lambdabot>   "test"
11:28:24 <dmwit> yeah
11:29:34 <dmwit> As a side note, what are you doing with the random numbers that you return?
11:30:55 <dmwit> (Are you sure you're not creating spurious serialization?)
11:31:47 <sm> dmwit: what's ~ there
11:32:12 <d34df00d> ClaudiusMaximus: I can rewrite so that there is no need to do it. I guess I'd do that.
11:32:41 <geheimdienst> anyone know of a html version of the typeclassopedia? the pdf i know about. there's a page on the wiki but it's minimal
11:32:45 <d34df00d> c_wraith: yeah, and what's meant by multithreaded GC?
11:32:56 <dmwit> sm: It's a lazy binding.
11:33:02 <d34df00d> dmwit: hm, what's ~?
11:33:07 <d34df00d> Ah, sm already asked.
11:33:41 <Cale> geheimdienst: There's http://snak.tdiary.net/20091020.html ;)
11:33:44 <c_wraith> d34df00d: GHC has a parallel GC that allows the GC process to be done with multiple threads at once.  But it's still stop-the-world GC.  also, in my experience, the parallel GC tends to lock up sometimes.
11:33:49 <dmwit> > let f ~(a,b) = "test"; g (a,b) = "test" in (f undefined, g undefined) -- sm, d34df00d
11:33:51 <lambdabot>   ("test","*Exception: Prelude.undefined
11:33:57 <Cale> *trollface*
11:34:56 <geheimdienst> that shows a ton of rectangles. am i supposed to put checkmarks in all of them?
11:35:07 <monochrom> japanese
11:35:08 <Cale> geheimdienst: aww, that spoils the effect
11:35:10 <shachaf> geheimdienst: https://docs.google.com/viewer?url=http://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf
11:35:18 <Cale> Install moar fonts :P
11:36:05 <dmwit> "Don't like the new look? Use the classic one by clicking the Help menu!"
11:36:09 <sm> dmwit: thanks for the example.. it uh.. makes the tuple constructor lazy ?
11:36:11 <dmwit> ...why would that be in the Help menu?
11:36:18 * Cale even has fonts to get Unicode coverage of Linear B, despite the fact that he'll never ever need them.
11:36:25 <dmwit> sm: Actually, it makes the pattern lazy.
11:36:28 * hackagebot tpdb 0.0 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-0.0 (JohannesWaldmann)
11:36:32 <sm> aha
11:36:47 <dmwit> sm: It doesn't evaluate the argument (even to whnf) until one of the variables that the pattern binds is demanded.
11:37:23 <dmwit> sm: It is also irrefutable; for example:
11:37:38 <dmwit> > let f ~(Left x) = "hi"; f (Right x) = "not hi" in f (Right 32)
11:37:39 <lambdabot>   "hi"
11:37:51 <sm> nice
11:38:24 <sm> I haven't seen that in the wild, would you use it for optimizing memory use ?
11:38:52 <dmwit> I only know of one real use for it, and that's for calling a function recursively that returns a tuple.
11:39:38 <d34df00d> dmwit: and, actually your advice regarding | otherwise = ... didn't change things much.
11:39:47 <d34df00d> I think I'd try Text now, as c_wraith suggested.
11:40:10 <hpaste> snappy pasted “mucking around” at http://hpaste.org/53363
11:40:17 <dmwit> d34df00d: Okay, good luck. =)
11:40:45 <snappy> Could someone please take a look at the paste above, I'm trying to implement sum over a list using only recursion; for some reason the then part of the conditional always executes
11:41:09 <dmwit> snappy: Try executing "sum 1" by hand yourself.
11:41:20 <d34df00d> dmwit: it reduced run time by about ⅓ though :)
11:41:24 <dmwit> You'll see very quickly why it always throws an exception. =)
11:41:42 <snappy> yep, got it ;)
11:41:55 <shachaf> snappy: That's not a pattern match failure. :-(
11:43:02 <EvanR-work> > sum []
11:43:03 <lambdabot>   0
11:43:07 <snappy> yep, i know; i should change it to guru meditation
11:43:25 <salisbury> any ideas on the most up to date html parser in haskell?
11:43:38 <shachaf> snappy: There are also no lists involved in what you @pasted.
11:43:45 <dmwit> > let sumOfFirst n = n * (n+1) `div` 2 in sumOfFirst (-32)
11:43:46 <lambdabot>   496
11:44:05 <ion> I’ve been using tagsoup with HXT. It works, but seems to use insane amounts of memory on big pages.
11:44:22 <edwardk> looks like we have extra space for hac boston, so registrations can continue unabated ;)
11:44:33 <silver> awww
11:44:33 <dmwit> yay!
11:44:58 <dmwit> Tell all those registered people to /join #haskell-hacboston.
11:45:00 <dmwit> ;-)
11:45:37 <edwardk> added it to my autologin list
11:46:00 <salisbury> ion: Isn't that for xml though? How does it handle malformed stuff?
11:48:27 <snappy> hm thanks, fixed it, got to have all those base cases
11:48:45 <ion> salisbury: It at least handles the invalid HTML at archive.org, but they probably don’t have the worst HTML out there. YMMV.
11:49:23 <dmwit> Haskell' proposal: change "let ... in ..." to "set ... in ..."
11:49:25 <dmwit> </trollface>
11:49:33 <EvanR-work> lol
11:49:34 <gentleben> salisbury: if you want to handle malformed XML with scalability I recommend using libxml2
11:49:43 <gentleben> tag soup doesn't scale
11:50:03 <EvanR-work> webscale
11:50:14 <dmwit> I thought tagsoup was designed specifically for malformed XML
11:50:21 <cheater> CLOUDscale
11:50:25 <TomMD> What is your opinion on xml-enumerator?
11:50:31 <gentleben> we originally used it but abandoned tag soup for libxml2, using the libxml-enumerator
11:50:37 <gentleben> xml-enumerator is good
11:50:58 <salisbury> gentleben: and libxml2 will catch all malformed, or must I run it though a cleaner like C++'s Tidy
11:51:28 <gentleben> salisbury: we use it for DOM cleaning ahead of webpage segmentation
11:51:48 <cheater> Haskell' proposal: translate all syntax to german.
11:52:00 <dmwit> {-# LANGUAGE German #-}
11:52:07 <cheater> nono
11:52:30 <cheater> {-# SPRACHE Reich #-}
11:52:34 <dmwit> =D
11:52:50 <gentleben> it has worked well at scale processing millions of pages in parallel
11:53:05 <cheater> yes
11:53:10 <blehteststudent> why is the interactive shell so slow... is it because I have the IRC widget open?
11:53:27 <cheater> the irc widget?
11:53:31 <shachaf> blehteststudent: What interactive shell?
11:53:33 <dmwit> blehteststudent: ECANNOTREPRODUCE
11:53:34 <cheater> what the hell?
11:53:42 <blehteststudent> to the left
11:53:44 <shachaf> If you're using tryhaskell.org, you should mention that. :-) This is a general-purpose IRC channel.
11:53:46 <salisbury> Ok, I'm doing some research on web links between web pages. All I'll need are <a>...</a> , lots of parallel and for it not to crash on malformed. Sounds like it'll do the trick.
11:54:01 <gentleben> the abandoned our first RSS parser stuff using the existing feed package + tag soup because when we would process many feeds in parallel memory usage exploaded
11:54:09 <cheater> salisbury: haskell is ultraparallel
11:55:04 <salisbury> cheater: but unfortunately you can only make so many http requests without hitting a bottleneck
11:55:38 <gentleben> salisbury: just write a simple wrapper around libxml path to grab all the links
11:55:42 <gentleben> *XPath
11:56:11 <gentleben> salisbury: i can do a few thousand requests per second per box
11:56:59 <blehteststudent> Bleh, i feel left out...there is so much for me to learn lol
11:57:05 <gentleben> the downloading piece isn't as performant as the one i built in .net but it simpler
11:57:25 <d34df00d> Hm, with Text everything got even slower.
11:57:39 <c_wraith> d34df00d: not really surprising, if allocation was the issue
11:57:47 <d34df00d> c_wraith: hm, why?
11:57:55 <c_wraith> d34df00d: since Text is a strict structure
11:58:12 <c_wraith> d34df00d: meaning it can't stream as well
11:58:12 <dmwit> d34df00d: You'll probably have to post a bit more of your code if you want better advice.
11:58:15 <d34df00d> Shouldn't I use Text.Lazy?
11:58:48 <salisbury> gentleben: interesting idea with xpath. I hadn't thought of that. Also nice to hear how many requests you get out. I'll have to take it up a notch and see what happens
11:58:55 <blehteststudent> Does anyone know a way to use python to get a URL from a certain web element and then mutate the URL string?
11:58:56 <d34df00d> http://paste.pocoo.org/show/500970/ ← here's the whole app.
11:59:15 <dmwit> blehteststudent: #python probably does
11:59:36 <gentleben> salisbury: it depends on your parallel strategy.
12:00:28 <blehteststudent> i know how to get source of a whole from using python but I only wanna find certian specifc urls, for instants, all URLs that end with a.jpg or .swf
12:00:44 <blehteststudent> from a whole webpage*
12:00:56 <monochrom> wow, too busy asking to read answers
12:01:23 <blehteststudent> after I find the desired URL I want the program to be able to change the string of the URL  and open it up in the default browser as a new tab/window
12:01:38 <blehteststudent> sorry sorry lol
12:01:41 <Cale> blehteststudent: This is #haskell
12:01:59 <Cale> blehteststudent: There's another channel for questions about python which would be a better place to ask
12:02:36 <blehteststudent> ok im guessing its #python ?
12:02:40 <Cale> yeah
12:02:49 <blehteststudent> ah ok, thanks alot, sorry for the disturbance
12:02:52 <monochrom> just 3 minutes ago <dmwit> blehteststudent: #python probably does
12:02:58 <dmwit> Honestly, this sounds like a use case for wget, though, not Python.
12:03:18 <salisbury> gentleben: I suppose so, thanks for your help! This sounds promising
12:03:21 <shapr> @quote
12:03:21 <lambdabot> kaol says: it's not perl. I can't just pipe urandom to the parser.
12:03:23 <blehteststudent> wget is a linux command to download from the terminal right?
12:03:42 <Cale> blehteststudent: Yeah, there are versions for other OSes too though.
12:04:35 <Cale> blehteststudent: It has lots of options for scraping through websites and following links to grab things recursively.
12:06:26 <sm> gentleben: I and others are looking for a more scalable feed parser, might you have any code you can share ?
12:06:47 <markstos> When I try "cabal install" for darcs 2.4.4, I get an error that "cannot satisfy -package Cabal" due a missing dependency "process". I'm not sure what to make of it-- help would be appreciated! The full diagnostic message is here: http://hpaste.org/53365
12:07:39 <sm> markstos: does ghc-pkg check reports broken packages ?
12:07:49 <gentleben> sm: PM me, ours uses lots of our internal libraries
12:07:50 <dmwit> d34df00d: Uh, this is going to sound a bit odd, maybe, but... have you tried a *smaller* chunk size?
12:08:02 <_Vi> [noob] I'm looking at some example source code (Counter.hs in reacrive-banana) and see various "<$>", "`union`", "<$" operators. How to look them up in docs? Google is not a friend there. May be there is IDE where I can hover on thing and see docs about it?
12:08:04 <dmwit> d34df00d: Like, a constant size. Maybe 10 or something like that.
12:08:15 <shachaf> _Vi: Hoogle and/or Hayoo.
12:08:16 <markstos> sm: thanks for the reply. No, it does not.
12:08:16 <c_wraith> _Vi: use hoogle
12:08:20 <shachaf> @hoogle <$
12:08:21 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
12:08:21 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
12:08:21 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
12:09:22 <markstos> sm: I was looking for the equivalent of "make clean",  but "cabal clean" gives the same kind of diagnostic output.
12:09:39 <d34df00d> dmwit: hm, I'd try.
12:09:51 <sm> markstos: for your whole installation, see https://gist.github.com/1185421 ghc-pkg-clean, ghc-pkg-reset
12:10:47 <markstos> sm: Thanks for the tip!
12:11:14 <d34df00d> dmwit: 73% GC time, much slower, though all the sparks converted.
12:11:15 <geheimdienst> ?hoogle
12:11:15 <lambdabot> No query entered
12:11:15 <lambdabot> Try --help for command line options
12:12:15 <geheimdienst> _Vi: hoogle's web interface gives you links to the function's types and documentation (fwiw), where you can click through to their source code. ditto hayoo
12:12:59 <_Vi> geheimdienst, shachaf, c_wraith, Thanks, wasn't aware of Hoogle before.
12:13:30 <d34df00d> And, well, 11x times more memory used — ~2500 MB vs 219 for -N1.
12:14:53 <dmwit> hmph
12:16:43 <dmwit> I wonder whether the (,) allocation is a problem here.
12:17:03 <d34df00d> I have never seen it in any heap profiles reports I've tried.
12:17:04 <d34df00d> Only :
12:17:14 <dmwit> It's mostly a stab in the dark.
12:17:26 <sm> markstos: any luck ?
12:17:32 <dmwit> But you would be allocating and de-allocating a (,) for each recursive call to makeDoc'.
12:17:52 <dmwit> Still, with optimizations on, GHC would probably notice that anyway.
12:18:10 <d34df00d> Yeah, I compile that with -O2.
12:18:23 <markstos> sm: Before I got your suggestion, I tried "cabal install cabal-install". That changed my problem. Now I get this: "Could not find module `System':
12:18:23 <markstos> " .. Still no broken packages reported.
12:18:28 <cheater> what is (,) allocation, dmwit?
12:18:30 <dmwit> Easy to try though.
12:18:36 <cheater> (in fact, what is (,)?)
12:18:41 <dmwit> cheater: tuples
12:18:41 <markstos> sm: Any idea about the "System" message?
12:18:45 <dmwit> cheater: e.g. (3, 4)
12:18:49 <cheater> ok
12:18:58 <dmwit> cheater: There's three things allocated there: 3, 4, and a (,) constructor pointing to them.
12:19:05 <sm> markstos: when installing which package ?
12:19:12 <cheater> dmwit: oh
12:19:30 <markstos> sm: from within a darcs 2.4.4 directory.
12:19:55 <dmwit> I'm speculating that writing a function f a b = blah blah blah (f a' b') would be more efficient than f (a, b) = blah blah blah (f (a', b')) for this reason: it wouldn't need to allocate and garbage collect the (,) constructor on every call.
12:20:06 <dmwit> d34df00d: Anyway, it's an easy thing to try...
12:20:17 <sm> markstos: shall we jump to #darcs for a minute ?
12:20:26 <markstos> sure.
12:20:33 <dmwit> d34df00d: And I can't see anything else egregious about your code. =)
12:21:06 <cheater> dmwit: that's very well explained, thanks
12:21:37 <monochrom> markstos, sm: probably add "haskell-98" to build-depends
12:21:48 <d34df00d> dmwit: hm, thanks, I'd try it.
12:22:03 <monochrom> err, sorry, "haskell98", it's a package name
12:22:13 <d34df00d> Never would've thought of the nice little (,) as the source of trouble by myself :)
12:22:51 <d34df00d> Though, I've generated now 2000 files of 60kbytes each in 45 seconds with it now, so I hardly need to optimize it further :)
12:23:17 <dmwit> =)
12:23:50 <ClaudiusMaximus> :t zipWith
12:23:51 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:24:16 <ClaudiusMaximus> :t \f xs ys -> map (uncurry f) (zip xs ys)
12:24:18 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:24:19 <dmwit> yep, zipWith would make much of his code nicer
12:24:28 <dmwit> But it won't make it faster or more parallel. =)
12:24:40 <dmwit> A real datatype for the parameters would help, too.
12:25:34 <shapr> d34df00d: But you've gotten the optimizers started now.
12:26:32 <d34df00d> shapr: moreover, I'd really like to know the reason of performance issues as well :)
12:26:49 <shapr> Yes, that's the best long term solution.
12:26:59 <d34df00d> And, well, removing (,) didn't help anyway.
12:27:06 <sm> monochrom: thanks for the hint
12:28:03 <d34df00d> shapr: yep, surely.
12:28:49 <d34df00d> And I guess I'd come in a few days with a bigger application, not a one-time script like this one, and I guess I could carry more experience from that one.
12:29:15 <geheimdienst> it compiled successfully, then i wanted to recompile with -Wall, and ghc did nothing. i needed to make a spurious change in the source file to get her to recompile. would you guys agree that this behavior is DO NOT WANT?
12:29:30 <d34df00d> geheimdienst: -fforce-recomp
12:30:18 <dmwit> geheimdienst: Yeah, that's bitten me a few times. But it's almost always what you want.
12:31:08 <dmwit> Possibly GHC should store relevant compilation flags next to wherever it stores the information about when it last recompiled.
12:31:12 <geheimdienst> i dunno, different flags often make a different binary, right? so i don't really think it's what you want
12:31:19 <dmwit> agreed
12:31:31 <dmwit> File a feature request -- or even better, implement it and send them a patch. =)
12:32:14 <geheimdienst> now that you mention it, i think i've seen something on the trac about that ...
12:36:23 <ybit> shapr: right!
12:38:48 <levkin> hi
12:39:42 <levkin> don't  get intermediate results of calculation using Debug.Trace.trace
12:39:53 <ybit> "After a long absence, monad comprehensions are back,"
12:39:59 <ybit> What happened to them, where'd they go the first time?
12:40:09 <dmwit> levkin: Sounds like you're not using the intermediate results of the calculation, then.
12:40:14 <ybit> And why did they go bb?
12:40:26 <dmwit> ybit: They went to simplify error messages for newbies.
12:40:30 <levkin> Maybe , but why
12:40:43 <dmwit> levkin: Insufficient data for meaningful answer.
12:40:52 <levkin> My code is at http://pastebin.com/5RvQ42z2
12:40:55 <ybit> dmwit: why are they back now?
12:40:57 <mauke> The paste 5RvQ42z2 has been copied to http://hpaste.org/53366
12:41:16 <dmwit> ybit: I think people are slowly starting to realize that Haskell shouldn't be optimized for undergraduate students.
12:41:18 <ybit> have the error messages been simplified?
12:41:31 <ybit> i'll take that as a no
12:44:42 <ClaudiusMaximus> d34df00d: try +RTS -A500M  (at least here, it boosts productivity from 31.9% to 88.1%)
12:45:10 <ClaudiusMaximus> (with -N4 on a 4-core machine)
12:45:23 <dmwit> levkin: When I run test1 and test2 I get loads of output.
12:46:42 <d34df00d> ClaudiusMaximus: and how that affects memory consumption?
12:46:55 <d34df00d> Cause I'm, well, already somewhere near the amount of RAM in my machine.
12:47:20 <levkin> I don't see values of intermediate results after constant prefix , such as 'Initial res_lst <here comes list print>'
12:48:01 <dmwit> I do.
12:48:17 <levkin> Strange
12:48:26 <ClaudiusMaximus> it possibly increases it, but i haven't checked by how much
12:48:49 <dmwit> Have you definitely saved your file to disk, recompiled, etc. since you added that?
12:49:19 <levkin> I constantly reloaded it
12:51:31 <ClaudiusMaximus> d34df00d: on my machine, it goes from 1.1GB to 2.6GB - quite a bit...
12:52:01 <levkin> Here again
12:52:12 <d34df00d> ClaudiusMaximus: then I guess I'd hit my limits. I've noticed that increasing number of cores to use increases the usage by itself considerably (for me, at least).
12:52:22 <levkin> I get : Init st vals = <empty line>
12:52:46 <d34df00d> And it already uses around 5G at peaks, and I have only 16 :)
12:52:48 <ClaudiusMaximus> yes same here, i guess because rdeepseq forces the whole document before writing, when it could be streamed to disk
12:52:49 <levkin> <empty line> is not a quoute from log
12:53:10 <dmwit> levkin: Yes, your code says: initSTvals = trace "Init st vals = " v
12:53:37 <dmwit> levkin: Perhaps you wanted: initSTvals = trace ("Init st vals = " ++ show v) v
12:53:38 <dmwit> ?
12:54:03 <levkin> I guess
12:54:05 <d34df00d> ClaudiusMaximus: so I guess it's either "be multithreaded" or "be memory-efficient" kind of dilemma?
12:54:25 <ClaudiusMaximus> so maybe this parallelism isn't the best way, and a concurrent forkIO some workers approach might scale better? which would kind of suck a bit
12:54:32 <levkin> I'll try it . So it's incorrect usage of 'trace' after all
12:54:49 <levkin> Thanks
12:55:24 <d34df00d> Hm.
12:55:32 <d34df00d> For some reason I haven't thought of forkIO.
12:56:02 <d34df00d> And I think I could just rewrite my main to spawn several `main'`s with lower number of documents to write, and add an additional parameter so that documents wouldn't overwrite each other.
12:56:08 <ClaudiusMaximus> (not least because the program ends when the main thread exits, so you need some waiting mechanism - luckily there's 'spawn' on hackage with a thread pool thing
12:56:59 <dmwit> Spawn a thread for each file. =)
12:57:24 <ClaudiusMaximus> @hoogle splitEvery
12:57:26 <lambdabot> No results found
12:57:34 <d34df00d> Oh, that's for tomorrow :)
12:58:02 <d34df00d> Sorry, definitely gotta sleep a bit now. 4 hours per day for a few days in a row is definitely not the best thing for the brain.
12:58:07 <dmwit> But it's really sad if this can't be done with parallelism, since this is basically the exact use case for parallelism annotations.
12:58:20 <d34df00d> Hope see you tomorrow :) You're awesome community.
12:58:24 <dmwit> g'luck
12:59:42 <ClaudiusMaximus> sleep++
13:07:56 <hirschen> Hi, is it possible to manipulate the cmdline args returned by getArgs?
13:08:58 <sm> hirschen: there's a withArgs that lets you change them
13:10:32 <hirschen> sm: ah great, I was looking in old documentation where this was not available, thank you
13:10:49 <shlevy> :t withArgs
13:10:50 <lambdabot> Not in scope: `withArgs'
13:11:10 <shlevy> :t System.withArgs
13:11:11 <lambdabot> Not in scope: `System.withArgs'
13:11:18 <shlevy> @hoogle withArgs
13:11:18 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
13:11:20 <hirschen> System.Environment
13:11:53 <shlevy> Ah so it's  a complete overwrite
13:20:37 <michaelh> Where is a large collection of open-source Haskell programs I can browse to read good code? (hoping something more edited than "search Github.")
13:21:18 <kirindave> michaelf: Have you tried searching Github? ;)
13:21:23 <kirindave> Doh
13:21:31 <kirindave> Joke ruined by bad autocomplete
13:22:10 <michaelh> :) I realize I can do that, but I want to read *really good* Haskell.
13:24:16 <sm> michaelh: this was answered on stackoverflow.com
13:24:22 <haskellSucks> hey
13:26:04 <byorgey> hi haskellSucks
13:26:07 <michaelh> sm: Thanks, I am looking at xmonad now.
13:26:21 <byorgey> that's a provocative nick you've got there ;)
13:27:12 <Clint> xmonad =<< haskellSucks (withProvocativeNick ProvocativeNick)
13:27:34 <dgpratt> maybe it's short for haskellSucksTheJoyOutOfUsingOtherProgrammingLanguages
13:27:46 <haskellSucks> i dont see why this language is any good
13:27:54 <kirindave> haskellSucks, it is awful. Don't use it.
13:27:55 <haskellSucks> there is no way that it is powerful enough
13:28:02 <kirindave> Not at all. Don't use it.
13:28:22 <haskellSucks> im in a class right now and a person is explaining that haskell should be used to introduce CS majors into coding
13:28:32 <haskellSucks> I feel that it has its merits but not as a full fledged language
13:28:43 <DasIch> haskellSucks: haskell is an elaborate joke to troll CS but don't tell anyone it's a secret
13:28:43 <byorgey> Haskell is one of the weakest languages ever invented.
13:28:45 <kirindave> haskellSucks, your intuition is perfect. Don't use it.
13:28:51 <byorgey> it is only good for implementing other programming languages.
13:28:55 <kirindave> byorgey, hardly any bicep mass at all.
13:28:58 <mdempsky> haskellSucks: Sounds like your conclusion is based on well-established facts too.
13:29:25 <haskellSucks> thank you!
13:29:53 <gentleben> i would say that it is difficult to build real world apps with it, but the language itself has many good ideas
13:29:59 <haskellSucks> i will agree with that
13:30:09 <haskellSucks> can you have lists of different types
13:30:14 <haskellSucks> i am trying that now
13:30:17 <c_wraith> I don't even think it's hard to build apps with.
13:30:22 <gentleben> if you are taking a class you are not building real world apps
13:30:24 <haskellSucks> like {43,"jim"}
13:30:42 <c_wraith> there are libraries for that, but they're complicated.  Because the type of such a list is necessarily complicated
13:30:47 <c_wraith> HList is one such library
13:30:47 <gentleben> sure [Either Int String]
13:30:53 <haskellSucks> thanks
13:30:56 <kirindave> haskellSucks, you can't. So you shouldn't use haskell.
13:31:29 <gentleben> haskell is very hard to wrap your head around sometimes, and the category theory people don't help
13:31:44 <magicman> I thought step one would be to first build the obligatory buggy Lisp-implementation, and use that to define them in. I've been doing it wrong all these years!
13:31:48 <gentleben> it lacks good profiling, and debugging tools
13:31:50 <c_wraith> gentleben: my day job is writing software in haskell, for my startup.  It isn't *any* harder to use than any other language.  The main problems are the same:  "I designed that badly, and it's getting in the way".
13:31:56 <gentleben> but things like IO are awesome
13:32:01 <gentleben> so is mine
13:32:06 <gentleben> runtime problems suck
13:32:09 <kirindave> gentleben, well let's be fair. Criterion is basically awesome.
13:32:24 <gentleben> we have built our own RTS extensions to solve problems
13:32:27 <burp> haskellSucks: sorry, if you join with a nick like that, and your first sentences are like "i dont see why this language is any good" we can't take you serious
13:32:29 <c_wraith> criterion isn't profiling though, it's benchmarking.  those are hugely different
13:32:34 <burp> expect to be handled like a troll
13:32:38 <kirindave> c_wraith, this is true, but
13:33:03 <kirindave> c_wraith, I find myself using criterion a lot where normally I'd use top level profiling.
13:33:14 <kirindave> This may be necessity-driven
13:33:15 <c_wraith> burp: but the way we handle trolls in this channel is being so helpful that they're confused. :)
13:33:35 <burp> hehe :D
13:33:59 <gentleben> but haskell does have advantages around type safety and compiler development that other languages don't
13:34:00 <haskellSucks> wasn't really planning on being taken seriously here
13:34:15 <haskellSucks> just thought I would check the language out
13:34:16 <kirindave> haskellSucks, you might be better off doing your homework.
13:34:24 <haskellSucks> and was hoping people would prove me wrong
13:34:25 <kirindave> than bothering people on irc.
13:34:34 <gentleben> haskellSucks: it took me a year to think haskell was good
13:34:41 <burp> haskellSucks: tryhaskell.org
13:34:46 <gentleben> no my complaints are mostly about libraries
13:34:47 <haskellSucks> im on that site now
13:34:50 <kirindave> haskellSucks, you're not really in the mindset where "proving you wrong" is possible, sir.
13:34:50 <haskellSucks> that is how i connected to this
13:35:08 <haskellSucks> cya brah
13:35:13 <deech> I don't know if this is the place to ask about Emacs' haskell-mode, but I was wondering why I can't tab-complete at the REPL.
13:36:20 <kirindave> c_wraith, so why aren't people busily creating profilers for haskell?
13:36:26 <kirindave> c_wraith, is it truly that difficult to do?
13:36:39 <dolio> Because there already is one?
13:36:43 <c_wraith> kirindave: what's wrong with the one that exists already?  It's solved all of my problems.
13:36:54 <kirindave> c_wraith, wasn't it you who said there wasn't one?
13:36:58 <c_wraith> ...  all of my profile-related ones.
13:37:00 <kirindave> Or did I get the attribution crossed?
13:37:02 <c_wraith> you did
13:37:06 <kirindave> Ahh, my bad.
13:38:37 <sm> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
13:38:45 <JoeyA> Is it possible to pattern match a data constructor without knowing in advance how many parameters it has?
13:39:08 <ClaudiusMaximus> > case Just 42 of Just{} -> "seven"
13:39:09 <lambdabot>   "seven"
13:39:20 <JoeyA> Ah, thanks.  I'd seen that before.
13:41:35 <gentleben> c_wraith: we have code that the profiler can't attribute costs to correctly, so the all come out 0
13:41:48 <gentleben> when it works it is nice though
13:41:55 <c_wraith> ah.  I haven't run into that.
13:42:18 <c_wraith> Every time I've run into things like that, it's along the lines of "didn't have -auto-all on for a package"
13:43:39 <gentleben> nah, i have seen it happen with iteratee's
13:43:52 <gentleben> even with SCC annotations
13:44:14 <sm> iteratees! ward evil!
13:44:42 <gentleben> so some higher level function says its descendants are using lots of CPU and then all its descendants report 0
13:45:07 <gentleben> yeah, in retrospect iterates weren't the best idea
13:45:17 <gentleben> all I really want is PLINQ from .net
13:45:20 <sm> I depend on them, but they're dark magic
13:45:42 <gentleben> one of our guys can do crazy things with them and understands them real deeply
13:46:01 <gentleben> but building custom enumeratees is overly complicated
13:47:01 <sm> it seems like a simple idea, but so complicated in practice (at least with enumerators lib)
13:50:14 <gentleben> yeah
13:50:18 <gentleben> tarts the one we use
13:50:31 <gentleben> its ok for what it does
13:51:09 <gentleben> but really we need something that incorporates par enumerator
13:51:42 <gentleben> that kind of thing is very hard to build tho, so i am not holding my breath
14:02:34 <adrake> I'm trying to do something like: data Foo s = Base | Rec s, type NormalFoo = Foo NormalFoo, type TupleFoo = Foo (TupleFoo, TupleFoo)
14:02:58 <adrake> obviously this doesn't work, but the best alternative I can come up with is to make NormalFoo and TupleFoo be full-on data types (or newtypes)
14:03:15 <adrake> which requires me to explicitly construct them everywhere, which is really obnoxious
14:03:37 <adrake> is there a good way to accomplish what I want?
14:05:51 <shachaf> adrake: Not really, as far as I know.
14:06:12 <shachaf> type NormalFoo = Mu Foo -- :-)
14:06:28 <shachaf> But you still have to construct explicitly that way, of course.
14:06:30 <adrake> shachaf: yeah, seriously :P
14:06:47 <JoeyA> What exactly does the where keyword get stopped by, syntactically speaking?
14:07:20 <JoeyA> For example, I've made the mistake of writing a statement in a do with where instead of let, to find out that the where bound higher than I expected it to.
14:07:23 <Cale> JoeyA: the first non-whitespace character after where sets the indentation level for the block
14:07:53 <deech> Google "Hayoo" , click the "Images" and check out the second image.
14:07:54 <Cale> JoeyA: The where clause stops as soon as a line starts with a character with less indentation than that
14:08:06 <JoeyA> I mean like: do  a <- blah; loop where loop = doSomethingWith a
14:08:32 <JoeyA> Here, loop can't see a because the where binds higher up.
14:08:33 <shachaf> JoeyA: That's invalid (unless that "a" shadows a different "a")
14:08:37 <JoeyA> Right
14:08:45 <shachaf> Right, where binds to "=" or "->".
14:08:54 <JoeyA> Thanks.  That's what I thought.
14:10:42 <shachaf> adrake: What is that Foo type for?
14:11:39 <koral> let f :: ReaderT Env IO (), and g :: IO () -> IO () ; say I want to use g inside f ; I feed g with h :: IO () ; what if I want to use my Reader monad with h, such that h :: ReaderT Env IO () ? How should I write it ?
14:12:00 <byorgey> adrake: there's no way around it since Haskell has iso-recursive types (where recursion must be explicitly given by an isomorphism), not equi-recursive types.
14:12:06 <byorgey> adrake: what we need are better tools for working with newtypes.
14:12:13 <shachaf> byorgey++
14:12:27 * shachaf gets faint sense of déjà vu
14:12:47 <adrake> shachaf: trying to non-invasively augment an AST with type information (i.e. without duplicating the AST data type or populating the thing the parser emits with type information)
14:12:48 <byorgey> =)
14:13:15 <adrake> literally, I just want this recursive tree of nodes to turn into a recursive tree of node * type :P
14:13:34 <adrake> (polymorphic on the recursive thing)
14:14:05 <magicman> @googel datatypes a la carte
14:14:07 <lambdabot> http://lambda-the-ultimate.org/node/2700
14:14:07 <lambdabot> Title: Data Types a la Carte | Lambda the Ultimate
14:14:54 <magicman> adrake: That's... somewhat related to what you're doing.
14:15:09 <magicman> adrake: But it's still newtypes everywhere.
14:17:07 <deech> I was reading some blog articles on the new C++ standard and apparently they have lambdas now. Do closures make any sense on a language without GC?
14:17:16 <kirindave> Yes
14:17:28 <adrake> magicman: yeah. the goal was to avoid polluting the parser with these constructors :(
14:17:29 <kirindave> Of course they do. Why wouldn't they?
14:17:39 <adrake> magicman: that is a pretty cute trick though
14:18:14 <adrake> deech: C as implemented by GCC has stack closures, even...
14:19:05 <deech> kirindave: It seems like it would make their utility for programmers would be lessened against having to track when certain parts of the environment aren't being referenced any more.
14:19:12 <companion_cube> you can refcount closures
14:19:24 <companion_cube> because they should not make cycles
14:19:27 <dylex> adrake: That's what gcc calls trampolines, right?
14:19:46 <deech> kirindave: Bad phrasing, basically knowing when a part of the environment is no longer referenced will be tricky.
14:19:52 <kirindave> deech, what companion_cube said.
14:20:05 <adrake> dylex: I have heard them referred to as such, IIRC they even end up putting code on the stack
14:20:25 <adrake> (so that you can embed a pointer to the environment)
14:20:54 <dylex> adrake: Right.  I think maybe the trampoline refers to what's put on the stack, to implement the stack closure.
14:21:22 <blackdog> kirindave: so it's basically downward funargs, rather than true closures? am i missing something?
14:22:06 <adrake> dylex: I could believe that :P
14:23:21 <romanandreg> has anyone here had interacted with the State Monad on large iterations?
14:23:47 <romanandreg> s/interacted/used/
14:24:21 <romanandreg> I'm having a really nasty issue with Lazy Evaluation and the modify function on the State Monad
14:24:45 <c_wraith> romanandreg: try the strict state monad instead?
14:26:31 <romanandreg> c_wraith: Control.Monad.State.Strict
14:26:32 <romanandreg> ?
14:26:42 <c_wraith> yes
14:27:02 <romanandreg> c_wraith: ok, will try and let you know
14:27:04 <c_wraith> romanandreg: it at least assures you that the internals aren't building up a chain of thunks
14:27:35 <c_wraith> romanandreg: however, if the operations you are performing on the state build up a chain of thunks, that will still happen
14:35:08 <romanandreg> c_wraith: still having the memory issue, I'm using Data.Lens.Common.modL as well, I think the issue is now there :-/
14:35:47 <c_wraith> I mean, if the only call you are ever using is modify, you will always leak space
14:36:02 <c_wraith> because nothing will ever force evaluation of the state
14:36:27 <c_wraith> You need to read it and do something that forces it occasionally.
14:36:41 <romanandreg> c_wraith: uhmm so the leak is not being caused by what the function is returning but on the modify function impl?
14:36:57 <c_wraith> :t modify
14:36:57 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
14:37:12 <c_wraith> romanandreg: you see how the result doesn't involve s at all?
14:37:42 <romanandreg> yes
14:37:55 <romanandreg> c_wraith: but I would have guessed they use an seq somewhere in there
14:38:00 <c_wraith> romanandreg: nope.
14:38:01 <romanandreg> specially on the strict version :-/
14:38:19 <c_wraith> nah, the strict version is just strict in its own tuple, not the contents of the state
14:38:29 <romanandreg> I think I will have to do my own modify fn then
14:39:23 <romanandreg> c_wraith: thanks for the feedback, I've been struggling with an awful memory footprint on a crawler I'm implementing
14:39:40 <romanandreg> c_wraith: at least I know now is the State monad, hopefully all the issues are going to go away just with that
14:41:31 * hackagebot crypto-pubkey-types 0.1.0 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.1.0 (VincentHanquez)
14:46:31 * hackagebot hatt 1.3.1 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.3.1 (BenedictEastaugh)
14:47:16 <romanandreg> c_wraith: shouldn't there be a strictModify in the Control.Monad.State.Strict? :-) (asking for your opinion)
14:47:16 <Abraxas> let's say you have the task to write several functions in foldr, for intermediate level...do you think it will be expected that you can write dropWhile in foldr?
14:47:45 <Abraxas> because from what i gather, it's not straightforward
14:51:19 <Abraxas> monad reader issue 6 and such...no clue
14:51:33 * hackagebot hatt 1.4.0 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.4.0 (BenedictEastaugh)
14:51:35 * hackagebot hatt 1.4.0.1 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.4.0.1 (BenedictEastaugh)
14:52:43 <c_wraith> dropWhile doesn't seem that bad.
14:52:54 <c_wraith> you can take advantage of laziness nicely
14:56:31 * hackagebot cryptocipher 0.3.0 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.3.0 (VincentHanquez)
14:57:31 <KSkrzet> I have a question
14:57:53 <KSkrzet> I have a datatype that has members without Show instance
14:58:05 <KSkrzet> so when I ask for "deriving Show", compiler refuses
14:58:17 <KSkrzet> yet, If i declare my own instance as:
14:58:24 <KSkrzet> instance Show Foo where
14:58:27 <KSkrzet> (that's all)\
14:58:33 <KSkrzet> it accepts it
14:58:36 <c_wraith> well.
14:58:40 <c_wraith> the compiler accepts it
14:58:43 <c_wraith> but it will fail at runtime
14:58:44 <KSkrzet> and in runtime it loops
14:58:53 <c_wraith> @src Show
14:58:53 <lambdabot> class  Show a  where
14:58:53 <lambdabot>     showsPrec :: Int -> a -> ShowS
14:58:53 <lambdabot>     show      :: a   -> String
14:58:53 <lambdabot>     showList  :: [a] -> ShowS
14:59:00 <Abraxas> but zip is not possible, because it's two lists, right?
14:59:03 <c_wraith> Those three functions each have default implementations in terms of the others
14:59:06 <KSkrzet> stackoverflow (interpreted) / forever loops (compiled)
14:59:16 <KSkrzet> same for Eq
14:59:26 <c_wraith> so if you don't provide a new implementation for any of them, it will mutually recurse forever
14:59:33 <c_wraith> Eq is the same
14:59:37 <c_wraith> @src Eq
14:59:37 <lambdabot> class  Eq a  where
14:59:37 <lambdabot>     (==), (/=)   :: a -> a -> Bool
14:59:52 <KSkrzet> H
14:59:53 <KSkrzet> AH
14:59:55 <c_wraith> Abraxas: I'm less sure of that
14:59:55 <KSkrzet> ah*
15:00:13 <KSkrzet> so 'minimal implementation' (as documented) is simply not checked, right?
15:00:15 <wavewave> hi
15:00:45 <c_wraith> KSkrzet: correct
15:01:01 <ddarius> KSkrzet: There is no way to even tell the implementation what the "minimal implementation" is.
15:01:14 <c_wraith> KSkrzet: in fact, there are some types where the minimal implementation is nothing, like Exception from Control.Exception
15:01:37 <KSkrzet> yes I know
15:01:47 <KSkrzet> some sort of extension would be needed here
15:03:19 <wavewave> romanandreg: if you really want to have a very strict operation, consider deepSeq solution.
15:04:26 <ddarius> deepSeq is evil.
15:04:47 <wavewave> ddarius: why?
15:05:36 <wavewave> ddarius: would you share your opinion about deepseq more with me? ;-)
15:06:31 * hackagebot certificate 1.0.0 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.0.0 (VincentHanquez)
15:08:28 <wavewave> I just listened to bos's recent talk.
15:08:41 <wavewave> he's a good speaker.
15:09:19 <Abraxas> writing this with only map, filter and concat: [(x,y) | x <- [1..100], y <- [1..x], x `mod` y > 0]
15:09:31 <Abraxas> i only have this, with zip and replicate: filter (\(x,y) -> x `mod` y > 0) . concat . map (\x -> zip (replicate x x) [1..x]) $ [1..100]
15:10:12 <monochrom> in fact, "x <- [1..100], y <- [1..x]" does not exhibit zip-like behaviour. far from it.
15:10:25 <co_dh> greeting, I have a question about HaXml. How can I select a tr that contains a <td>keyword</td> ?
15:10:50 <wavewave> Abraxas: write the expression in do notation and replace >>= with concatMap
15:11:31 * hackagebot tls 0.8.2 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.8.2 (VincentHanquez)
15:11:33 <Abraxas> i guess nothing but map, filter and concat is allowed
15:11:45 <wavewave> concatMap = concat . map
15:12:41 <Abraxas> yeah, but no do
15:13:10 <wavewave> yeah.. in the end, you will not have 'do' at all.
15:14:00 <monochrom> concat (map (\x -> filter (\(x,y)-> x `mod` y > 0) (map (\y -> (x,y)) [1..x])) [1..100])
15:14:01 <wavewave> Abraxas: change binding to lambda expression and semicolon to >>=, then you will not have do
15:15:50 <wavewave> Abraxas: did you get my point?
15:17:27 <zuchel> where can i find step by step leksah tutorial ??
15:19:20 <Abraxas> no, didn't :D
15:19:35 <wavewave> Abraxas: wait a minute.. I am writing a tutorial for you.
15:20:52 <zuchel> THX ... LOL ... i really new ... so don't be irritated ... ;p
15:21:15 <Philonous> Could someone recommend an (imperative) introduction text on algorithms and data structures?
15:22:15 <ddarius> @undo  [(x,y) | x <- [1..100], y <- [1..x], x `mod` y > 0]
15:22:15 <lambdabot> concatMap (\ x -> concatMap (\ y -> if x `mod` y > 0 then [(x, y)] else []) [1 .. x]) [1 .. 100]
15:22:58 <hpaste> wavewave pasted “list monad” at http://hpaste.org/53372
15:23:06 <zuchel> Philonous: I think try "The Spirit of Computing" by David Harel
15:23:16 <Philonous> thanksa
15:23:18 <Philonous> -a
15:23:19 <monochrom> @undo [x+x | 5<-[1..10]]
15:23:20 <lambdabot> concatMap (\ a -> case a of { 5 -> [x + x]; _ -> []}) [1 .. 10]
15:23:24 <monochrom> \∩/
15:23:29 <wavewave> Abraxas : see the hpaste.. lst == lst2 == lst3
15:26:32 * hackagebot cprng-aes 0.2.3 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.2.3 (VincentHanquez)
15:26:34 * hackagebot tls-extra 0.4.1 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.4.1 (VincentHanquez)
15:26:36 * hackagebot implicit 0.0.0 - Math-inspired programmatic 2&3D CAD: CSG, bevels, and shells; gcode export..  http://hackage.haskell.org/package/implicit-0.0.0 (ChristopherOlah)
15:26:51 <Abraxas> ah sorry, thank you...but that import is already not allowed =)
15:27:06 <Abraxas> sorry for your trouble
15:27:16 <wavewave> Arbaxas : no... import is not needed in the final answer..
15:27:29 <wavewave> Abraxas: I just show the logic behind it.
15:27:43 <wavewave> Abraxas: wait... I am appending more to it.
15:27:53 <Abraxas> neither is the flip
15:28:03 <wavewave> Abraxas: I know ;-)
15:29:51 <Abraxas> it's just that i didn't see how to get tuples without zip, if i can't use list comprehension
15:30:48 <wavewave> Abraxas: I know your intent of the question and all the constraints.. I simply explain the idea behind it.
15:31:52 <Abraxas> if that's no trouble for you, ok, thanks =)
15:32:44 <hpaste> wavewave annotated “list monad” with “list monad (annotation)” at http://hpaste.org/53372#a53373
15:33:09 <FUZxxl> > foldr (||) True $ repeat False :: Expr
15:33:10 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
15:33:10 <lambdabot>         against inferred ...
15:33:31 <wavewave> fconcatMap is nothing but \x f -> concat (map f x)
15:33:50 <wavewave> so now final answer is...
15:38:00 <hpaste> wavewave annotated “list monad” with “list monad (annotation) (annotation)” at http://hpaste.org/53372#a53374
15:38:11 <wavewave> lst7
15:38:19 <wavewave> quite a bit of typing.
15:38:40 <wavewave> Abraxas: would you follow it?
15:39:01 <wavewave> probably I need to add lst0 for original expression.
15:39:03 <c_wraith> Ugh.  I really need some way to document this library that doesn't result in haddock spitting out contexts that are wide enough to wreck the formatting.
15:39:20 <c_wraith> I think the ConstraintKinds extension would work.  If it was supported. :(
15:40:09 <hpaste> wavewave annotated “list monad” with “list monad (annotation) (annotation) (annotation)” at http://hpaste.org/53372#a53375
15:40:58 <ion> @type \x f -> concat (map f x)
15:40:58 <lambdabot> forall a a1. [a] -> (a -> [a1]) -> [a1]
15:41:09 <ion> @type (>>=) `asAppliedTo` (undefined :: [a])
15:41:09 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
15:41:30 <wavewave> Abraxas: list comprehension is just do notation.
15:42:20 <wavewave> Abraxas: in list monad, (>>=) = flip concatMap ,  and return x = [x]
15:42:51 <wavewave> flip concatMap can be written in map and concat only of course
15:43:19 <wavewave> guard is a little bit tricky, but you can pull it out as a filter outside.
15:43:22 <Abraxas> thanks!
15:43:48 <wavewave> Abraxas: so the intent of the question is basically to get a feeling of list monad inside.
15:43:55 <Abraxas> guard was the easiest part to understand, i thought
15:44:01 <mdempsky> wavewave: How is guard tricky?  Isn't it just 'guard x = if x then [()] else []'?
15:44:35 <osfameron> it's quite hard to understand how the void () works with that
15:44:38 <osfameron> well, I found it so
15:44:40 <Abraxas> hm, i doubt it was, because there were no monads up to that point ;)
15:44:43 <wavewave> mdempsky: I mean that according to original question, you should change guard to filter... that's not automatic rule.. that's why I am saying tricky..
15:44:57 <mdempsky> wavewave: Ah.
15:45:01 <wavewave> mdempsky : nothing tricky indeed.
15:45:19 <wavewave> the question was to write lst0 in terms of filter, concat and map.
15:45:40 <mdempsky> I see.  My bad for not following the channel then.
15:46:08 <wavewave> Abraxas: yeah. just knowing what the problem would indicate is good. ;-)
15:47:25 <wavewave> Abraxas: important lesson is in haskell, nothing is magical.. list comprehension is just mechanical rule which finally go down to lambda calculus.
15:47:35 <ski> @undo [x | x <- xs , p x]
15:47:36 <lambdabot> concatMap (\ x -> if p x then [x] else []) xs
15:47:43 <Abraxas> defintely is
15:47:46 <monochrom> if you know list comprehension, you almost know monad.
15:48:22 <monochrom> that is why monad is so hard to "understand". you don't know that you know.
15:48:34 <Abraxas> yeah, i have to look into monads soon, only did very little with it
15:48:53 <ion> You might want to learn functors and applicative functors first.
15:49:01 <wavewave> *nod*  seeing list as a monad is really an eye-opening awakening moment.
15:49:19 <monochrom> "understand" is largely a subjective feeling of satisfaction and hardly relates to objectively testable states of your knowledge and/or experience
15:51:20 <ivanm> dmwit: regarding your Church class on reddit, wouldn't it be better for the Bool instance to be "church b f t", keeping the base/nil case as the first argument?
15:51:20 <Nimatek> Monads seem to be like a rite of passage that seems scary to the young initiate but turns out to be an excuse for getting drunk.
15:52:08 <Abraxas> it's funny how this wasn't about monads, though :p
15:52:55 <Nimatek> But everything is about monads.
15:53:03 <Abraxas> exactly
15:53:21 <wavewave> Abraxas: I think the questioner definitely think list monad in mind.. maybe later he will probably mention about that example
15:54:14 <monochrom> it is a good preparation for monad
15:54:20 <bfig> fcr, hey!, are you around?
15:54:31 <wavewave> @seen fcr
15:54:31 <lambdabot> Unknown command, try @list
15:54:31 <preflex>  fcr was last seen on #haskell 181 days, 15 hours, 9 minutes and 55 seconds ago, saying: it stores 3 decimal digits on 10 bits
15:54:58 <monochrom> calculus homework asks you to work with (f(x+h)-f(x))/h on the eve before differentiation.
15:55:09 <Abraxas> it was one of a bunch of tasks a certain amount had to be solved, but don't worry, i already finished what had to be done, just want to get through them all ;)
15:55:11 <bfig> what... he's standing right there... in the channel
15:55:21 <wavewave> :-)
15:55:51 <Abraxas> thank you again for the tutorial =)
15:56:07 <wavewave> probably preflex remembers last time he talked on the channel, I guess.
15:56:18 <monochrom> how do you stand in a channel?
15:56:18 <wavewave> Abraxas: welcome ;-)
15:56:37 <Abraxas> have to leave now, bye!
15:56:38 <bfig> you just /stand
15:56:44 <wavewave> bye
15:56:46 <bfig>  /stand_still
15:56:50 <ddarius> monochrom: Then you just have to assert that h^2 = 0.
15:57:08 <monochrom> haha
15:58:00 <bblum> hey folks, anybody have experience with Language.C? I'm wondering if there's an easy way to do a state-tracking pass over basic blocks, or if I would have to write that myself?
15:58:24 <bfig> bblum, what?
15:58:36 <bblum> Language.C.Parse I guess I should say
15:58:39 <wavewave> what's state-tracking pass?
15:59:05 <bblum> I want to parse the code up into an AST, and then run a pass over the code in which I keep track of accumulated state.
15:59:39 <wavewave> sounds like you want a Parser monad transformer over state monad.
16:00:01 <rferranti> i'd buy two
16:00:24 <wavewave> bblum: unfortunately Language.C.Parser is not designed as monad transformer.
16:00:27 <bblum> Well I'm wondering if there's already some framework that will implement most of the pass logic for me
16:00:41 <wavewave> bblum: but you can use monad-control in this case maybe.
16:00:59 <bblum> sure sure... but that's if i have to implement it myself
16:01:09 * ski still isn't sure what this "pass logic" is supposed to do ..
16:01:13 <wavewave> bblum: no... you don't have to implement it.
16:01:43 <wavewave> bblum: in monad-control, you can run your upper monad's function in base monad.
16:01:45 <rferranti> ski, i suppose i just want to visit the ast and accumulate some value
16:02:01 <rferranti> i should stop impersonating third parties
16:02:06 <bblum> rferranti: basically
16:02:14 <bblum> ski: imagine something where you say "Here is my analysis code that I want to be run on every logical line of code in succession, please call it in order on every line of the code"
16:02:17 <wavewave> bblum: so build StateT over Language.C.Parser monad..
16:02:21 * rferranti wears his tin foil hat
16:02:58 <bblum> Instead of e.g. writing code that operates on the AST and figures out an ordering for the statements, and where the basic block boundaries are, etc etc
16:03:05 <ski> bblum : .. and how will you combine the results of running this analysis on every logical line of code ?
16:03:05 <wavewave> bblum : and use monad-control, and insert state accumulating routine during your suspended phase.
16:04:06 <wavewave> monad-control is in a sense to invert upper monad and lower monad in monad stack.
16:04:09 <bblum> ski: by holding on to some sort of state...? i thought that part was obvious; i mean, that is something that the pass framework would have to implement
16:04:19 <bblum> wavewave: interesting
16:04:51 <wavewave> bblum: basically it's coroutine. in more general term, it's continuation
16:05:08 <ski> bblum : no, it's not obvious. if it's state you want, then you want a state monad (obviously) -- but for some purposes an output/writer might suffice
16:05:22 <bblum> well, it's state
16:05:44 <ski> bblum : and i can imagine more complex scenarios where you want to pass state back again, as well
16:06:33 * hackagebot ListZipper 1.2.0.2 - Simple zipper for lists  http://hackage.haskell.org/package/ListZipper-1.2.0.2 (RyanIngram)
16:07:24 <ski> bblum : i'm not sure what kind of answer you're looking for, though
16:07:26 <wavewave> bblum: it can be generic fold operation, which you do not need state thing in fact. so it's worth scrutinizing the problem.
16:07:48 <ski> maybe you're not so familiar with monads (e.g. state monads), and want some help with that
16:07:52 <wavewave> bblum: anyway, if you really need state, then my answer will be relevant.
16:08:01 <bblum> it isn't about monad specifics ski
16:08:02 <ski> maybe you're familiar with that and want help with some specifics in your problem
16:08:23 <ski> is it about how to traverse the AST ?
16:08:37 <bblum> yes, more or less how to traverse the ast
16:08:56 <bblum> the question is just "Does a framework exist (within Language.C most likely) for doing a pass over the AST in some sort of basic-block-aware manner, or do I have to implement one myself?"
16:09:16 <ski> ok, i would just check the API, then
16:09:36 <bblum> (LLVM has such a framework, for contrast, that operates on its SSA IR)
16:10:32 * wavewave wonders about what basic-block-aware manner means. 
16:10:37 <ski> for some kind of operation like `Monad m => (Node -> m ()) -> (AST -> m ())' (cf. `mapM_')
16:11:16 <bblum> wavewave: consider "foo; if (x) bar; else baz; quux;" -- when passing over bar and baz, the state for those two have to be different, but the state has to get merged somehow before going to quux.
16:11:21 * ski haven't used `Language.C' at all, btw
16:11:52 <bblum> yeah, i mean, i figure i could slog through the datatypes and work together an implementation of some sort
16:12:11 <wavewave> bblum: I see.. basically it's about how many times nested block are we in now..
16:12:56 <bblum> It *may* just be that I should really be working in LLVM... D:
16:13:08 <bblum> (LLVM's C++ infrastructure is not pleasant.)
16:13:56 <bblum> (But at least it has this stuff implemented already)
16:14:01 <wavewave> bblum: I guess you can have annotated tree with nested block index or something like that for this problem.
16:14:25 <ski> <http://hackage.haskell.org/packages/archive/language-c/0.4.2/doc/html/Language-C-Analysis-TravMonad.html> looks like it might be relevant
16:14:31 <wavewave> bblum: anyway, it seems that you need to write down something
16:14:35 <wavewave> hmm.
16:14:45 <bblum> ski: ooh, thanks
16:15:06 <wavewave> yeah, this looks promising.
16:15:35 <bblum> It does.
16:18:42 <wavewave> anyway, annotation is not a bad idea. it's functional and Language.C looks like havinig generic interface for associating one's own AST with predefind AST .
16:20:28 * wavewave thinks functional programming always starts from defining data types for a specific purpose.
16:20:40 <bblum> yeah
16:20:51 <[ira]> Hi all! readFile believes that any file whose path has an accented 'e' does not exist. Easy way to convince?
16:20:57 <bblum> wavewave: I observed this while implementing a toy compiler for a class last fall
16:21:11 <bblum> if my datatypes were good, I was happy; if not, I had to wrestle with the code
16:21:40 <c_wraith> [ira]: sounds like an encoding issue.  do your locale environment variables match the file name's encoding?
16:22:27 <c_wraith> [ira]: also, what version of ghc?  the way this works changed in ghc 6.12
16:23:49 <wavewave> bblum: for example, I can approach to your problem like defining AnnotatedAST
16:24:13 <wavewave> bblum: so all Nodes can be lifted by a functor.
16:24:37 <wavewave> bblum: I can use DeriveFunctor extension so that I can automate the boilerplate.
16:24:48 <bblum> mmm, automating boilerplate. :P
16:25:12 <wavewave> DeriveFunctor is ghc extension. you don't need to boilerplate
16:25:37 <bblum> i haven't looked into it but i have heard of 'scrap your boilerplate' a bunch of times
16:25:37 <wavewave> and annotated node has its own level of nesting.
16:25:54 <bblum> yeah, i mean, the nesting level isn't the only problem athand though
16:25:59 <wavewave> bblum: that's different.
16:26:21 <wavewave> bblum: I understand that your problem may be complex.
16:26:33 <bblum> yeah, i appreciate that you are talking about a more general approach too :P
16:26:59 <wavewave> bblum: just in case you didn't think about the alternatives. ;-)
16:28:12 <wavewave> since AST is especially where functional approach does play much better than imperative approach.
16:28:52 <bblum> yes, functional languages are much better for compilers-type stuff
16:29:15 <bblum> i took undergrad compilers in the fall, which we did in haskell (how i learned haskell, in fact), and then took grad compilers in the spring, which was in LLVM/C++....
16:29:16 <wavewave> anyway.. I am sure that you already know all these ;-)
16:29:33 <bblum> yes i am sure i understand perfectly ;)
16:29:48 <bblum> (i have been vaguely following)
16:32:24 <wavewave> hope that you have a success with language-c library which looks awesome (I didn't pay attention to it before) I have to go home now, so see you guys :-D
16:32:39 <bblum> yeah, i hope it will work out
16:32:42 <bblum> thanks a bunch for the help!
16:32:53 <bblum> ski: thanks to you too, of course
16:39:10 <ClaudiusMaximus> would some fusion of   take n . catMaybes . parMap rseq   be able to optimize the amount of speculative computation at all?
16:39:51 <[ira]> c_wraith: thanks, don't know about the encoding, I'll find out -- ghc is 7.0.2
16:41:10 <ClaudiusMaximus> for example, n = 20, the 17th result is taking aaaages to compute, meanwhile all the other cores are racing down the list computing things that won't ever be needed no matter the result of the 17th...
16:42:22 <ClaudiusMaximus> actually, maybe i don't actually want to wait for the 17th result, as order is irrelevant here...
16:42:50 <ClaudiusMaximus> ..and it doesn't matter if i miss any (they're all pseudorandom anyway), i just want "20 results"
16:44:00 <Axman6> sounds better suited to using forkIO and a chan then
16:44:05 <Axman6> or maybe an MVar
16:44:43 <ClaudiusMaximus> yeah that would work, but the code is so elegant at the moment...
16:45:44 <ClaudiusMaximus> (apart from using Debug.Trace for logging, but hey...)
16:46:14 <ClaudiusMaximus> > read "Just {- test -} 42" :: Maybe Int
16:46:16 <lambdabot>   *Exception: Prelude.read: no parse
16:46:47 <ClaudiusMaximus> > read "Just\n42" :: Maybe Int
16:46:49 <lambdabot>   Just 42
16:57:23 <dmwit> ClaudiusMaximus: Construct all sublists of length 20 and race them.
17:12:45 <ClaudiusMaximus> Axman6: thanks for the idea, implemented it and seems to be working well
17:26:11 <fragamus> hey guys I have been reading Programming in Haskell and I love it.  I want to use a monadic parser module that does not require the typical code generation pass; just straight haskell code to do the parsing.  What is the best  package for that kind of thing?
17:27:16 <fpgc> parsec, attoparsec, trifecta
17:27:22 <JoeyA> fragamus: Parsec is the obvious, full-featured answer.  However, if you're starting out, I'd recommend Attoparsec or such instead.
17:28:21 <fragamus> I am a permanent newb when it comes to haskell, but I am skilled in writing parsers
17:28:24 <JoeyA> Parsec is a state and parser monad transformer that is generic in the stream (a lot of concepts to try to learn at once).  Attoparsec is just a parser monad.
17:28:26 <edwardk> attoparsec is better for streaming content like network sockets or huge log files, trifecta gives you better error reporting
17:29:20 <JoeyA> At a glance, Attoparsec looks like it's easier to understand than trifecta.
17:29:24 <edwardk> it is
17:29:26 <aristid> trifecta also seems to be completely undocumented
17:29:26 <Luke> how do you pass a flag to cabal. everything I try seems to fail (specifically trying -D..)
17:29:36 <edwardk> but attoparsec gives you no information about where the error occurred or why
17:30:00 <JoeyA> I'm approaching this from an ease of understanding perspective.
17:30:04 <edwardk> you are free to use trifecta just like parsec
17:30:35 <edwardk> *shrug*
17:30:35 <dcoutts> Luke: you mean pass a flag to ghc, but specify the flag in a .cabal file or via the cabal program?
17:30:45 <fpgc> cabal install --flags=blah ?
17:30:48 <Mathnerd314> edwardk: so much Haskell library fragmentation!
17:31:08 <edwardk> Mathnerd314: trifecta exists because parsec can't support any kind of decent user error messages
17:31:08 <Luke> fpgc: yeah that's it - thanks a lot
17:31:17 <JoeyA> When I was learning about monadic parsing, I did not care about fancy error reporting.  I just wanted to try to write a simple parser.
17:31:20 <edwardk> Mathnerd314: i started out making a concerted effort to just build on top
17:31:31 <edwardk> JoeyA: then you are exactly the opposite of my market
17:31:34 <dcoutts> Luke: that doesn't make any sense for your -D case
17:31:48 <Luke> dcoutts: it seems to be working
17:32:02 <Luke> "cabal install --flags=-DDEVELOPMENT"
17:32:14 <dcoutts> that does not do what you think it does
17:32:22 <edwardk> JoeyA: in my experience once you have a parser there are a bunch of tools you build on top. someone wants a syntax highlighter, maybe you want haskell style layout, or ctags, or it'd be nice to have better error reporting from an integrated c preprocessor so you know what macros were being expanded, etc.
17:32:39 <edwardk> trifecta is designed to be able to meet those needs
17:32:48 <Mathnerd314> edwardk: the logical thing to do is to make a typeclass and combine the parsing libs together
17:33:04 <dcoutts> Luke: -f / --flags is to specify values for configuration flags defined in the .cabal file.
17:33:11 <edwardk> with parsec i couldn't even ADD better error reporting because i couldn't supply any other error type
17:33:14 <Axman6> edwardk: is there a reason for not documenting trifecta?
17:33:16 <dcoutts> Luke: nothing to do with passing options to ghc
17:33:21 <edwardk> Mathnerd314: it doesn't fit together with what i'm doing well
17:33:26 <edwardk> Axman6: time
17:33:34 <Axman6> fair enough =)
17:33:35 <edwardk> Axman6: i accept patches
17:33:40 <Axman6> heh
17:33:54 <JoeyA> edwardk: "then you are exactly the opposite of my market" And I'm fine with that :-)  I may need a decent parser some day.  However, for teaching simple monadic parsing, I would recommend Attoparsec or similar instead.
17:34:01 <edwardk> Axman6: i do intend to spend more time documenting. and there is a fair bit of documentation in the parsec-ish parts
17:34:06 <dcoutts> Luke: if you want to specify cpp options in a .cabal file use the cpp-options field, if you want to specify it on the cabal command line, use --ghc-options=
17:34:11 <Teffen> I'm having some difficulties creating my own mod function
17:34:12 <Teffen> http://pastebin.com/GFUQ2FPQ
17:34:14 <mauke> The paste GFUQ2FPQ has been copied to http://hpaste.org/53377
17:34:26 <Teffen> The issue is regarding the type put in
17:34:31 <Luke> dcoutts: thanks
17:34:36 <Teffen> what should my type declaration be?
17:34:48 <edwardk> JoeyA: thats fine. my goal is to get trifecta to where the basic usage is as easy or simpler than parsec. it actually already is. for instance the token parsers are a LOT easier to use in trifecta
17:34:55 <Axman6> Teffen: well, you can't use (/) and div on the same types
17:35:04 <edwardk> dylukes even wrote up a quick tutorial the other day on trifecta iirc
17:35:06 <JoeyA> edwardk: Cool :-)
17:35:17 <Teffen> Axman6: what do you think I should do? I've been at this for awhile so I'm at wit's end.
17:35:21 <JoeyA> Is there an "easy" Parsec-style parser on Hackage, easier than Hackage?
17:35:26 <JoeyA> err, easier than Attoparsec?
17:35:34 <edwardk> but it supports a lot of things that parsec doesn't. e.g. being used with monad transformers
17:35:35 <JoeyA> e.g. like Attoparsec, but uses String instead.
17:35:37 <dylukes> JoeyA: Trifecta is pretty easy.
17:35:44 <dylukes> Trifecta uses arbitrary string inputs.
17:35:46 <dylukes> or files.
17:35:48 <dylukes> or bytestrings.
17:35:48 <dylukes> etc
17:35:51 <dylukes> edwardk: not really on trifecta, but on appicative usage :\
17:35:55 <JoeyA> Not meant for "real world" applications, but for ease of understanding.
17:36:02 <edwardk> parsec itself _is_ a monad transformer, but that is less useful than being able to be transformed in many ways
17:36:05 * fpgc wonders what answer to give Teffen, the direct answer or the helpful answer :)
17:36:10 <dylukes> JoeyA: ^ http://dylukes.blogspot.com/
17:36:11 <Axman6> Teffen: what exactly do you want to do? you seem to want to take the modulus of real numbers?
17:36:23 <Teffen> Axman6: essentially recreating mod
17:36:32 <edwardk> JoeyA: well attoparsec is 'easy' but then yiu build a grammar that you will always get shit error messages out of
17:36:34 <dylukes> I wrote a blog post on the very basics of this... but I haven't written the chapter with the "practical" bits yet.
17:36:38 <Teffen> it's a test problem I've been at for a few hours
17:36:42 <Teffen> Ceiling takes in fractions correct?
17:36:50 <Teffen> and I'm sending it integers
17:37:00 <Axman6> Teffen: well, you first need to decide what types you want to work on. mod in haskell is implemented for for integral types only
17:37:03 <edwardk> parsec gives slightly better error messages as long as you don't rely on it actually reporting the right location
17:37:21 <fpgc> ceiling taks in fractions and gives out integers. there lies your problem.
17:37:43 <edwardk> i like attoparsec for parsing protocols, etc. where errors are big bad catastrophic things
17:37:59 <edwardk> i think using attoparsec for parsing a programming language where you need to interact with a user is, however, a terrible mistake
17:38:06 <Axman6> > let mod a b | a < b = a | otherwise = mod (a - b) b in mod 22 7
17:38:06 <lambdabot>   1
17:38:49 <edwardk> and i don't see how the core combinator set which is basically identical between attoparsec, parsec and trifecta makes any difference
17:39:27 <edwardk> in trifecta i just make as many as can work with arbitrary Applicatives, rather than be hardwired in terms of parsec
17:39:30 <Axman6> (not that that implementation is wrong when using negative numbers))
17:39:33 <Teffen> Axman6: how would I do about converting a Int into a fraction then performing the calculations?
17:39:42 <Teffen> I've been playing with realToFractional
17:39:49 <fpgc> fromIntegral
17:39:50 <Axman6> Teffen: why do you feel you need to?
17:39:54 * JoeyA plans to write a simple parser combinator library aimed at beginners of Haskell that demonstrates the core concepts, at the expense of usability or quality of error messages.
17:39:55 <fpgc> @quote monochrom fromIntegral
17:39:56 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
17:39:58 <kwos> Hi guys quick question: I'm writing a tab-delim file parser using Oleg's IterateeM... I have two enumeratees: enum_lines :: Monad m => Enumeratee Char Line m a, and enum_fields :: Monad m => Enumeratee Char Field m a... the former splits on '\n' the latter on '\t'... How on earth do I combine these two to get [[Field]]?
17:40:08 <JoeyA> It could be called "inch" :-)
17:40:17 <Teffen> Axman6: my logic is that I convert the int into a fractional so ceiling will take the number
17:40:25 <edwardk> JoeyA: there are at least 3. there is lennart's paper on the topic written without even using a Monad. There is the Meijer paper on monadic parser combinators
17:40:33 <edwardk> there is the list of successes parser and there is polyparse
17:40:33 <JoeyA> Are any on Hackage?
17:40:45 <edwardk> the newbie friendly market is well served
17:40:58 <edwardk> polyparse includes many many parsers including the list of successes parser
17:41:14 <edwardk> i disagree with it in that it thinks commit semantics are better than try semantics, but *shrug*
17:41:27 <Teffen> So over my goal is using myMod 41 7 and outputting 6
17:41:35 <edwardk> and it like attoparsec gives crappy error messages ;)
17:41:48 <applicative> Teffen, i think you shouldn't be having anything to do with fractional numbers themselves, thus nothing to do with / . There are lots of pleasant ways of writing mod while staying with Integer
17:41:57 <JoeyA> Hmm, what are commit semantics?  Just curious.
17:42:15 <Axman6> Teffen: why do you need division at all? and you definitely don't need to use fractional numbers
17:42:27 <edwardk> in parsec everything that consumes input basically commits you to the current branch of <|> you are on
17:42:35 <Teffen> How else would I get the remainder without turning to mod or rem?
17:42:49 <edwardk> and try can be used to let a consuming parser act like it didn't consume on failure
17:42:50 <Axman6> > let mod a b = a - div a b * b in mod 41 6
17:42:51 <lambdabot>   5
17:42:56 <Axman6> > let mod a b = a - div a b * b in mod 41 7
17:42:57 <lambdabot>   6
17:43:20 <applicative> Axman6:  using div violates the idea of the problem, surely
17:43:38 <Teffen> I'm allowed to use div.
17:43:38 <Axman6> applicative: sure, seem my previous definition =)
17:43:47 <Teffen> though the question asks for recursion
17:43:48 <edwardk> in polyparse <|> (well, you can't use <|> but the same concept) backtracks by default, but commit foo can be used to make it so that foo on failure won't back track if it fails
17:43:53 <Teffen> which I'm not sure how it ties in
17:43:55 <centrinia> > let mod a b = if a < b then a else mod (a-b) b in mod 41 6
17:43:56 <lambdabot>   5
17:43:59 <centrinia> > let mod a b = if a < b then a else mod (a-b) b in mod 41 7
17:43:59 <lambdabot>   6
17:44:19 <applicative> Axman6: sorry, spoke too soon
17:44:35 <Cale> Someone help kwos to save me the trouble of learning how Oleg's enumeratee stuff works?
17:44:37 <Teffen> 7) Declare the type and define a function that takes two integers as input (say a b), and divides
17:44:37 <Teffen> a by b and returns the remainder. For instance, if the inputs were
17:44:37 <Teffen> 41 and 7
17:44:37 <Teffen> would
17:44:37 <Teffen> return 6. Do NOT use “rem” or “mod” or any other library function for getting the
17:44:38 <Teffen> remainder. Use only recursion.
17:44:44 <Teffen> sorry about the paste
17:44:52 <applicative> Teffen, define all the multiples of the modulus
17:45:00 <Teffen> Where would recursion fit into all of this?
17:45:15 <edwardk> i have been debating about adding a polyparse compatibility layer to trifecta
17:45:18 <Axman6> Teffen: we've shown you three times now :\
17:45:30 <applicative> > multiples n = map (n*) [1..]
17:45:31 <lambdabot>   <no location info>: parse error on input `='
17:45:34 <applicative> > multiples n = map (n*) [1..] in multiples 3
17:45:35 <lambdabot>   <no location info>: parse error on input `='
17:45:44 <applicative> grrrr lambdaspam
17:45:54 <applicative> > let multiples n = map (n*) [1..] in multiples 3
17:45:55 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
17:46:05 <centrinia> Zero is a multiple of 3.
17:46:18 <Cale> kwos: Does it really have to use iteratee? :)
17:46:24 <Teffen> Axman6: I'm sorry for my repetition, I might just be having difficulties grasping the concept
17:46:24 <applicative> centrina, good point, I don't like that definition of multiples either
17:46:24 <edwardk> JoeyA: anyways to use trifecta you only need to input Text.Trifecta just like you inport Text.Parsec and the combinators do basically the same things, except they don't run into the MPTC Stream typeclass problems
17:46:25 <fpgc> Teffen: 8 minutes ago <Axman6> > let mod a b | a < b = a | otherwise = mod (a - b) b in mod 22 7
17:46:30 <kwos> Cale: why not?
17:46:45 <Axman6> Teffen: do you understand what mod actually does?
17:47:01 <Teffen> Axman6: the remainder of division
17:47:12 <Axman6> and what is division?
17:47:15 <Cale> kwos: Because iteratees are kind of crazy and there are much easier to use libraries like Parsec available for parsing.
17:47:22 <Teffen> how many times one number can go into another
17:47:57 <Cale> I view iteratee as something which you might resort to if you're desperate for performance.
17:48:02 <fpgc> applicative: for the pupose of finding remainder, 0 being a multiple of 3 is necessary, in case the user tries "mod 2 3"
17:48:09 <kwos> Cale: I am
17:48:17 <Axman6> so, to figure out how many times b goes into a, you could the number of times you can take b away from a right?
17:48:26 <kwos> Cale: I have TBs of data to play with
17:48:36 <Cale> okay
17:48:48 <Axman6> you could count the number*
17:49:09 <kwos> in a very inefficient form... I need to read it, transform it, write it in efficient binary format, then read it again and play with it :)
17:49:14 <mm_freak> Cale: iteratees are better than parsers for stream transformations…  it's a good combination to use an enumeratee for splitting the stream (e.g. lines) and then a parser to interpret the individual packets
17:49:21 <mm_freak> parsers are not good at transformations
17:49:29 <Teffen> so in our case, 41 / 7, we can subtract 7 and get 34
17:49:32 <JoeyA> I'm still gonna write an easy-to-understand parser combinator (if I have time) whether y'all like it or not.  Now, should I call it inch, furlong, or sheppey?  :-)
17:49:40 <Teffen> then 27
17:49:46 <Teffen> then 20
17:49:49 <Teffen> then 13
17:49:54 <edwardk> JoeyA: you're welcome to do so. i'll just be sad ;)
17:49:58 <Axman6> and then...
17:50:01 <JoeyA> heh
17:50:02 <Axman6> bam! remainder!
17:50:08 <Teffen> then 6
17:50:12 <Teffen> right
17:50:12 <kwos> so, how do I go from having these two enumeratees to something like enumeratee Char [[Field]] m a?
17:50:32 <Teffen> jeeze
17:50:39 <Teffen> this recursion kills me sometimes
17:50:50 <Teffen> but thanks for sticking with me through the problem
17:50:59 <mm_freak> kwos: embed a parser into your iteratee
17:51:09 <mm_freak> kwos: see for example the attoparsec-enumerator package
17:51:12 <kwos> mm_freak: can you elaborate?
17:51:21 <kwos> mm_freak: OK, I will have a look
17:51:33 <Cale> Teffen: The trick to understanding recursion is not to try to trace the recursive calls out, but to assume that they will produce the solution to the problem they claim to solve.
17:51:50 <mm_freak> kwos: an attoparsec parser has the same structure as an iteratee, and the package i mentioned transforms a parser into an iteratee
17:52:08 <Axman6> Teffen: no worries. it's something that many programmers struggle with if they're used to crap like for loops. but once it starts to make sense, you'll start seeing how to implementing pretty much everything using recursion
17:52:31 <edwardk> that reminds me i need to go back and add the streaming mode to trifecta
17:52:37 <edwardk> so i can stop recommending attoparsec ;)
17:52:42 <Axman6> heh
17:52:43 <Cale> Of course, you don't really want to program anything recursively as long as you can avoid it. Higher order functions are the way to go :)
17:52:44 <Teffen> now when I do :t on our function I receive: myMod :: Integral a => a -> a -> a
17:52:49 <mm_freak> kwos: btw, if you really want maximum performance, you probably don't want Char as your input type
17:52:59 <Axman6> :t mod
17:53:00 <lambdabot> forall a. (Integral a) => a -> a -> a
17:53:00 <Teffen> when I think it should be myMod Int -> Int -> Int
17:53:03 <kwos> mm_freak: cool, that seems to be what I'm looking for, but in general, I still wonder... when I'm writing something to split a line into fields, which are '\t' separated
17:53:09 <edwardk> i already did all the hard work of factoring out the mark/release functionality from the rest of the parser code
17:53:10 <Cale> But it's important to know how, because it's not always clear whether there's a set of higher order functions which fit some pattern of computation.
17:53:21 <Axman6> Teffen: Integral a => a -> a -> a is even better than Int -> Int -> Int
17:53:33 <Axman6> > mod 41 7 :: Int
17:53:34 <lambdabot>   6
17:53:38 <Axman6> > mod 41 7 :: Integer
17:53:39 <lambdabot>   6
17:53:42 <Axman6> > mod 41 7 :: Word
17:53:43 <lambdabot>   6
17:53:48 <Axman6> > mod 41 7 :: Word8
17:53:49 <lambdabot>   6
17:53:50 <kwos> mm_freak: sure, I'm just trying to get the general structure now, I'll swap the impl detail later
17:53:55 <mm_freak> kwos: is this the only parsing you want to do?
17:54:01 <Teffen> what does the "=>" signify?
17:54:02 <Axman6> works for ALL the integrals! \o|
17:54:05 <mm_freak> just split by '\t'?
17:54:06 <applicative> Teffen for a problem like this you should be using Integer
17:54:06 <Teffen> I'm from rubyland
17:54:08 <edwardk> @tell thoughtpolice that bug isn't as bad as you made it sound. ;)
17:54:08 <lambdabot> Consider it noted.
17:54:15 <kwos> mm_freak: pretty much
17:54:25 <Axman6> Teffen: i'll see if a few examples make it clearer:
17:54:28 <Axman6> :t show
17:54:29 <lambdabot> forall a. (Show a) => a -> String
17:54:31 <Cale> Teffen: => separates typeclass constraints from the rest of the type signature
17:54:37 <mm_freak> kwos: do you have line length limits to worry about, for example like in a network protocol to prevent DoS?
17:54:52 <Cale> Teffen: Do you already know about type variables?
17:54:52 <Axman6> show can turn anything that is in the Show class into a String
17:54:55 <Axman6> :t (+)
17:54:56 <lambdabot> forall a. (Num a) => a -> a -> a
17:54:57 <kwos> mm_freak: I just wonder, as a general principle, how to combine these enumeratees
17:54:57 <thoughtpolice> edwardk: i'm trying to figure out the other RAM gobbling one
17:54:57 <lambdabot> thoughtpolice: You have 1 new message. '/msg lambdabot @messages' to read it.
17:55:07 <kwos> mm_freak: not really, I can assume that the data is well-formed
17:55:07 <Axman6> (+) can add anything that's in the Num type class
17:55:10 <applicative> > maxBound :: (Int, Word, Word8)
17:55:12 <lambdabot>   (9223372036854775807,18446744073709551615,255)
17:55:20 <edwardk> thoughtpolice: does it do so on a smallish input?
17:56:02 <thoughtpolice> yeah, but the parser/input was rather in flux and i was messing stuff around so i can't quite figure it out (wasn't under version control just yet)
17:56:02 <mm_freak> kwos: apply them one after another…  if you are using the iteratee package, i think, there is also a combinator for composing enumeratees…  the enumerator library has no such combinator, but you can always turn a set of enumeratees into an Iteratee aIn m b -> Iteratee aOut m b
17:56:05 <Cale> Teffen: Typeclasses are used to constrain which types a type variable is allowed to be.
17:56:09 <applicative> Teffen: number types with a maxBound are not in the spirit of "define mod"
17:56:34 <mm_freak> kwos: in that case, you don't really need iteratees
17:56:49 <mm_freak> splitting is better done by a parser or even simply a lazy bytestring function
17:56:55 <Teffen> so would myMod :: Integral a => a -> a -> a read as "myMod takes in 2 integrals and returns 1 integral"?
17:56:56 <kwos> mm_freak: won't that be inefficent though? applying them one after the other?
17:57:07 <mm_freak> kwos: no, that's the way you do it
17:57:11 <edwardk> thoughtpolice: anyways fixing the first bug you mentioned should happen around the time i or someone gets around to rewriting the renderer code so it can support putting in colored multicharacter proxies like <EOF> \g \r <0xff> for unrenderable text
17:57:17 <kwos> mm_freak: for now I have just one data source, but there will be others
17:57:22 <edwardk> the reason is that will make me revisit the way i store a line
17:57:47 <mm_freak> kwos: nothing to worry about, as long as you keep the I/O part of your program separate
17:57:48 <Axman6> Teffen: more like "myMod takes two numbers of a type that is in the Integral class, and returns something of the same type"
17:57:55 <kwos> mm_freak: I want to build the pipeline, and then swap the front-end when necessary
17:58:20 <kwos> mm_freak: OK, I'll check attoparsec-enumerator and see where it gets me
17:58:26 <kwos> mm_freak: thanks!
17:58:27 <mm_freak> kwos: iteratees are really useful, if you're doing some kind of complicated stream processing or when concatenating or cascading formats
17:58:32 <Teffen> Axman6: of what signifigance are the 'a's? what is different if the type declaration said myMod :: Integral a => a -> b -> c ?
17:58:32 <Axman6> so, that a's there could be replaced by Int, Integer, Word, as long as they are instances of the integral class
17:58:35 <mm_freak> otherwise go for a simpler approach
17:58:36 <edwardk> right now i don't store edits out of range so its hard for me to update the fixits that go 'out of frame'. i pick the focus before hand
17:58:49 <thoughtpolice> edwardk: ok, it's not a big rush, just something i was playing with on top of llvm
17:58:53 <edwardk> *nods*
17:59:39 <Axman6> Teffen: the a's all have to be the same. the type Integral a => a -> b -> c says the function takes something in the integral class, and _anything at all_ and returns something else of _any type_
17:59:53 <edwardk> one reason it hasn't seen much love lately is that i've been working on a typechecker/typeinference algorithm for doing type error slicing, since I want to see if I can extend those nice diagnostics right through the rest of compilation
17:59:57 <applicative> Teffen:  myMod: Integral a => a -> a -> a covers the specializations myMod :: Integer -> Integer -> Integer , myMod :: Int -> Int -> Int etc.
18:00:22 <edwardk> and that means that I need to be able to provide highlighting for arbitrary error slices, which has meant revisiting how i store errors, etc.
18:00:26 <applicative> @instances Integral
18:00:27 <lambdabot> Int, Integer
18:00:31 <edwardk> since my current renderer only knows how to draw a single line
18:00:45 <edwardk> and i want to be able to render whole swathes of colored code
18:00:57 <Teffen> hmm
18:01:10 <Teffen> well it seems I have more to learn but this has been helpful
18:01:26 <Axman6> Teffen: stick around and ask more questions. we're here to help
18:01:37 <applicative> Teffen,so the 'constraint'  Integral a => ... means  ... works for any type that kind of like integers
18:01:45 <Teffen> lol you will probably see more of me
18:02:02 <Teffen> and one last question to go
18:02:10 <Teffen> difference between Int and Integer?
18:02:37 <Axman6> Int is like an int in C. it's either 32 or 64 bits according to your system
18:02:41 <applicative> Teffen Integers go on till your machine breaks
18:02:43 <fpgc> > 99999999999999999 :: Int
18:02:44 <lambdabot>   99999999999999999
18:02:52 <Axman6> (according to the haskell standard, it's "at least 30 bits")
18:02:52 <fpgc> hmm, it's that big
18:03:00 <applicative> > maxBound :: Int
18:03:01 <lambdabot>   9223372036854775807
18:03:02 <fpgc> > 2^100 :: Int
18:03:03 <thoughtpolice> edwardk: i was going to ask you at one point about that - how can i use trifecta niceness post-parsing for things like type errors? :) my naive intuition is just to keep around all the spans etc for particular parts of the AST but that would be unwieldly right now
18:03:03 <lambdabot>   0
18:03:07 <fpgc> > 2^100 :: Integer
18:03:08 <lambdabot>   1267650600228229401496703205376
18:03:15 <Axman6> Integers have no size limit, except when they get too big to fit into memory
18:03:16 <applicative> >  9223372036854775807 + 3 :: Int
18:03:17 <lambdabot>   -9223372036854775806
18:03:19 <Axman6> > 2^27848
18:03:20 <lambdabot>   121148837328733986117716291416640364204670267340155268947565294832557103009...
18:03:23 <Axman6> > 2^27848 :: Int
18:03:24 <Teffen> so I see
18:03:24 <lambdabot>   0
18:03:49 <applicative> Teffen, Integers will be slower for some purposes, but they are right for your purpose.
18:04:09 <Teffen> I come from Ruby where everything is like a story.
18:04:17 <Teffen> Haskell is like a machine to me
18:04:20 <Axman6> a really slow story >_>
18:04:27 <Teffen> Axman6: I know I know.
18:04:39 <applicative> Teffen, Haskell isn't like a story]
18:04:42 <applicative> it's like a dream
18:04:47 <Teffen> Axman6 it's getting better!
18:05:05 <thoughtpolice> i like the way applicative puts it :)
18:05:06 <Axman6> Teffen: the learning curve for haskell is fairly steep, but god damn it's rewarding once you 'get it'
18:05:11 <aavogt> fortunately, you'll find your fill of analogies in either
18:05:28 <Teffen> Axman6: where does haskell fit into programming
18:05:33 <Teffen> such as day to day work?
18:05:36 <Axman6> Teffen: it's never going to be fats enough for me, the nature of the language doesn't allow it to be that fast
18:05:44 <edwardk> thoughtpolice: well, my initial stab at it was to put a Rendering or a Span at each AST node, but that really just meant i could blame one location when an error happened
18:05:46 <Teffen> I'm a junior web dev atm so I don't really see it
18:06:06 <edwardk> thoughtpolice: so i turned to 'type error slices' which doesn't associate them with generated code, only with parsed code
18:06:17 <Axman6> Teffen: lots of large financial institutions are using it. there's some sompanies using it for websites. and lots and lots of other stuff
18:06:32 <Axman6> Teffen: this might be useful for you: http://www.infoq.com/presentations/Running-a-Startup-on-Haskell
18:06:35 <fpgc> you can easily use haskell wherever other web programmers use ruby
18:06:43 <Teffen> Axman6: we're reaching a zenith in single thread processing, the language needs more optimization in that regard
18:06:53 <thoughtpolice> edwardk: ah yeah, that's also a problem not being able to keep multiple locations
18:06:54 <luite> Axman6: why not? a good jit compiler could squeeze a good amount of performance out of it
18:07:02 <edwardk> yep
18:07:14 <edwardk> have you seen the TES stuff out there?
18:07:24 <thoughtpolice> edwardk: sure haven't, links?
18:07:29 <thoughtpolice> (or just google-able names)
18:07:33 <Axman6> luite: possibly, but the synamic nature of it will limit that quite a lot no?
18:07:35 <edwardk> http://www.macs.hw.ac.uk:8080/techreps/docs/files/HW-MACS-TR-0079.pdf
18:07:38 <Axman6> dynamic*
18:07:40 <edwardk> take a look at figure 2 in particular
18:08:25 <edwardk> to mock this up i've been building a type checker (well, right now it only deals with polymorphic kinds, constraint kinds, and i haven't actually gotten to that pesky TYPE level) for ghc types/kinds
18:08:32 <thoughtpolice> Axman6: tracing JITs like luajit or pypy work quite well. i don't see why there couldn't be an effective ruby equivalent, although language design does have an impact
18:08:33 <luite> Axman6: in practice, many performance critical loops are often fairly "static" (in a runtime sense), good jit compilers can generate specialized code for that
18:09:10 <thoughtpolice> there is rubinius, but i don't see llvm ever being a good choice for dynamic languages. any static compilation technology is bad - there are too many branches and you pessimize all of them eventually
18:09:20 <thoughtpolice> custom JITs seem to be the way to go
18:09:45 <edwardk> well, even with a custom jit you can emit the jitted code through LLVM in a pinch
18:10:19 <thoughtpolice> edwardk: whoa, that's interesting (type error slices)
18:10:23 <edwardk> it isn't ideal, things like luajit are tuned to do their register allocation in reverse and emit code from the last instruction to the first, so they can get huge constant gains
18:10:24 <ghosting> > length $ nub $ permutations "wowwhoaboom"
18:10:28 <lambdabot>   mueval-core: Time limit exceeded
18:10:35 <edwardk> thoughtpolice: exactly
18:11:34 * hackagebot http-types 0.6.6 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.6 (AristidBreitkreuz)
18:11:45 <thoughtpolice> edwardk: so this is your next goal for trifecta? :D
18:11:45 <edwardk> thoughtpolice: i already have an interval map from the parsing phase, so using intervals/interval sets for the labels becomes trivial
18:11:51 <JoeyA> The STM type has an Alternative instance (it didn't in earlier versions).  Is (<|>) = orElse ?
18:12:15 <edwardk> thoughtpolice: right now its in my half-joking thc folder. since i wanted a "turbo haskell compiler" ;)
18:12:28 <luite> hehe
18:12:29 <thoughtpolice> lol
18:12:35 <JoeyA> lol
18:13:01 <Teffen> well I think I'm set for now. this has been a lot of fun and my headache has subsided
18:13:02 <JoeyA> Can you get it to run on my 90 MHz Pentium 1 running Windows 95?
18:13:15 <thoughtpolice> edwardk: overall i've been very pleased with the structure of trifecta. i'm still figuring out the layout bits, but i'm quite happy with the language components in particular
18:13:17 <Teffen> I'm going for dinner, thank you all and we'll probably meet again
18:13:45 <applicative> Teffen good luck with mod !
18:13:50 <fpgc> turbo haskell may be as successful as turbo prolog
18:15:32 <thoughtpolice> edwardk: in particular i think hooking it up to unbound would be a fun exercise :)
18:15:59 <JoeyA> Can someone articulate why Parsec-like parsers don't try alternatives if a parser consumed input (without a try) ?
18:16:30 <JoeyA> I understand there's a tradeoff, but I'm trying to understand what exactly that tradeoff is.
18:18:01 <JoeyA> Is it solely for performance, or is it better for reasoning about the parser as well?
18:19:02 <dmwit> Yes, it's for efficiency only.
18:19:48 <dmwit> Yes, (<|>) is orElse.
18:19:54 <JoeyA> thanks
18:20:29 <JoeyA> One thing that confuses me a bit about STM is that there are two types of "failure": retry, and exception.
18:20:55 <dmwit> Exceptions won't be retried.
18:21:02 <JoeyA> Does fail :: String -> STM a throw an exception or retry?
18:21:10 <edwardk> JoeyA: because a.) it makes error reporting a lot harder. lots of GLR style parsers give really really bad error reports
18:21:39 <dmwit> JoeyA: Try it. Open up ghci and do "atomically (fail [])".
18:21:44 <edwardk> and b.) it raises pretty bad efficiency and memory footprint issues
18:21:56 <edwardk> you can't throw away any of the alternative parses, since you never commit
18:21:56 <JoeyA> dmwit: Indeed, I get an exception.
18:22:10 <dmwit> ?hoogle retry
18:22:11 <lambdabot> Network.HTTP.Base Retry :: ResponseNextStep
18:22:11 <lambdabot> Network.HTTP.Headers HdrRetryAfter :: HeaderName
18:22:11 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
18:22:18 <dmwit> ?hoogle orElse
18:22:18 <edwardk> so you never get rid of any of the input and have to maintain the entire tree of decisions you took to get there
18:22:19 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
18:22:40 <JoeyA> edwardk: Ah, makes sense.
18:22:41 <edwardk> with parsec the branches that aren't guarded by try can be culled once you commit to some of the input
18:22:59 <JoeyA> So if you're 75% of the way through the document, and parsing fails, the parser might try twiddling something 25% of the way through the document?
18:23:05 <edwardk> yep
18:23:14 <JoeyA> Thanks, makes sense.
18:23:27 <edwardk> it'll try all the subsequent alternatives on _all_ of the <|>'s all the way back to the beginning
18:23:57 <edwardk> NB: attoparsec backtracks a bit too much
18:24:06 <edwardk> NB: so you need to be careful with it in that regard
18:24:39 <edwardk> attempting to fix it cost it performance, so bos left it with the backtrack-happy behavior
18:25:08 <dmwit> Backtracking less hurt performance?
18:25:09 <dmwit> weird
18:25:24 <edwardk> dmwit: yeah because it had to have code to make the decision
18:25:45 <JoeyA> I have observed that you can't rely on Attoparsec to fail after consuming input when you didn't explicitly try.
18:25:57 <Axman6> would it be possible to make a packrat parser generator?
18:26:08 <ddarius> That's what Pappy is.
18:26:12 <Axman6> they were mentioned a while ago in a lecture of mine, and seemed like an interesting idea
18:26:17 <edwardk> dmwit: in parsec and trifecta we carry around 4 continuations and heap-allocate them, which lets you throw away the branches from the uncommitted paths once you commit
18:26:21 <Axman6> ah cool. is that on hackage?
18:26:32 <edwardk> Axman6: pappy, frisby, even the little 'womp rat' parser from my blog
18:26:50 <Axman6> @hoogle pappy
18:26:50 <lambdabot> No results found
18:26:53 <ddarius> @hackage pappy
18:26:53 <lambdabot> http://hackage.haskell.org/package/pappy
18:26:55 <dmwit> edwardk: Huh, interesting.
18:26:57 <edwardk> Axman6: i wrote a post where i showed you can make a Stream type for parsec that gives you packrat
18:26:58 <Axman6> yeah, that one...
18:27:14 <edwardk> Axman6: so you don't even need to give up parsec if you don't want to
18:27:42 <edwardk> http://comonad.com/reader/2011/a-parsec-full-of-rats/ and http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/
18:28:08 <edwardk> for any particular parser that should be more than sufficient to derive the practical benefits of packrat
18:28:10 <Axman6> thanks. i saw the links when those first came out, but having no idea what packrat parsing was, i ignored them =)
18:28:26 <edwardk> basically you memoize parse results directly in the input stream
18:29:32 <edwardk> if you do it for every parser you get ford-style packrat, but subsequent research has shown that while it gives you the O(n) parse time guarantee, it comes at a pretty high constant cost, so in practice you are better off doing a little bit of left factoring to reduce redundancy and appealing to amdahl's law to figure out which parsers are worth tabulating
18:33:39 <ddarius> Amdahl was a jerk.
18:34:21 <edwardk> spoilsport
18:36:15 <Axman6> which law was Amdahl's?
18:40:35 <DevHC> ZOMFGBBQH$X http://hackage.haskell.org/platform/
18:40:41 <DevHC> it's all PINK !
18:41:08 <DevHC> well, fortunately it has a trolly "Problems?" link
18:41:10 <ddarius> April is in Spring.
18:43:18 <kmc> it's been that way for a while...
18:43:28 <ddarius> April was a while ago.
18:43:28 <nominolo> @tell chrisdone #:foo in common lisp are uninterned symbols, I think
18:43:29 <lambdabot> Consider it noted.
18:43:39 <edwardk>  http://en.wikipedia.org/wiki/Amdahl's_law
18:43:40 <kmc> maybe since april?
18:43:49 <Axman6> it's spring now
18:43:59 <Axman6> you're just all on the wrong side of the planet
18:44:05 <ddarius> Axman6: Right you are.
18:44:49 <kmc> DevHC, so what's wrong with pink?
18:44:50 <aristid> > (11 + 6) `mod` 12
18:44:51 <lambdabot>   5
18:45:00 <aristid> > (11 + 6 - 1) `mod` 12 + 1
18:45:01 <lambdabot>   5
18:45:17 <ddarius> kmc: Perhaps it is difficult to see for color-blind people.
18:45:19 <edwardk> basically the simplified form of it is that you can only optimize away the time you spend on something even if you optimize it perfectly. so if you spend 5% of your time on something, and you optimized it away you'd still only get 5% faster
18:45:53 <aristid> ddarius: is May in Spring, too?
18:46:06 <ddarius> aristid: Yes.
18:46:41 <fragamus> I found a bitchen expression evaluator which uses parsec. It is IMO a canonical example for parsing because it performs actions while it parses.
18:46:44 <fragamus> http://stackoverflow.com/questions/4559399/can-parser-combinators-be-made-efficient
18:46:59 <DevHC> kmc: it's WRONG(TM), that's what
18:47:12 <kmc> http://vischeck.homeip.net/uploads/132011228615856/
18:47:31 <edwardk> it invites you to choose your battles, and arises in parallelism, because if the part of your program that can be made parallel is p, then the maximum speedup looks like 1/(1 - p + p/n) for n processors
18:47:47 <aristid> kmc: why do the images have black background?
18:47:58 <kmc> DevHC ragequit over the color scheme
18:48:25 <kmc> aristid, colorblind people see alpha channel as black
18:48:27 <kmc> duh
18:48:37 <kmc> http://colorfilter.wickline.org/?a=1;r=;l=0;j=1;u=hackage.haskell.org/platform;t=p
18:48:50 <Axman6> edwardk: there's another law i like better, whose name i can't remember... gustafson's law? anyway, it's basically that the bigger your problem gets, the more efficiently it's likely to parallelise
18:49:09 <aristid> kmc: oh of course, they don't have receptor cells for alpha, like normal people do
18:49:42 <Axman6> http://en.wikipedia.org/wiki/Gustafson%27s_Law
18:49:46 <edwardk> *nods*
18:50:07 <edwardk> but sometimes you have the problem you have regardless of the resources at your disposal ;)
18:50:31 <edwardk> its just a matter of what you hold fixed
18:50:47 * Axman6 had better get ready for his assingment defence
18:51:56 <gentleben> purely form a cost standpoint once you have multiple cores your have to have a parallelization strategy
18:52:03 <gentleben> otherwise you are wasting money
18:53:44 * ddarius doesn't know who gentleben is talking to.
18:56:27 <fpgc> me
19:09:07 <JoeyA> In Parsec (and parser combinator libraries like it), if we have the parser (try (try pa *> try pb)), and pa succeeds but pb fails, will pa's alternatives be tried to get pb to succeed?
19:10:08 <JoeyA> Or will a failure in pb cause the entire expression to fail, leading to an alternative somewhere above it being tried?
19:13:09 <JoeyA> That is, is *> like a statement delimiter and a parser failure like an "exception" ?
19:28:22 <byorgey> fryguybob: I just sent you a patch for diagrams-postscript
19:28:34 <fryguybob> byorgey: ok
19:28:40 <byorgey> oops, wrong channel, but I guess it still works =)
19:29:43 <dradtke> can anyone help me out with compiling the haskell platform from source?
19:31:33 <kfish> dradtke, what platform/distro?
19:32:03 <dradtke> kfish: platform 2011.2.0.1, compiling  on 64-bit linux
19:32:17 <dradtke> kfish: I compiled ghc 7.0.3, but I keep getting an error trying to build the platform
19:32:36 <dradtke> kfish: "Implicit import declaration:
19:32:38 <dradtke>     Could not find module `Prelude':
19:32:40 <dradtke>       Perhaps you haven't installed the profiling libraries for package `base'?"
19:33:07 <dradtke> kfish: my main question is, is there a specific compilation option I need to give ghc in order to build the profiling libraries?
19:34:33 <kfish> dradtke, what ./configure args did you use when building ghc?
19:34:43 <dradtke> kfish: nothing special
19:35:15 <kfish> which bootstrapping ghc did you use?
19:35:33 <dradtke> kfish: 6.12.3, the version packaged for openSUSE
19:36:35 <fpgc> please don't build ghc yourself
19:36:58 <kfish> dradtke: ah, i just checked my logs and we were talking about this on oct 28 too :)
19:37:15 <dradtke> fpgc: I wouldn't have to if the openSUSE maintainers actually maintained the package
19:37:36 <fpgc> but I forgot whether, if you insist on building ghc yourself, whether it builds the profiling stuff, so I don't know
19:37:38 <dradtke> kfish: yep, first time I've picked this up since  then. Haven't really gotten anywhere with it
19:37:51 <kfish> ok
19:38:13 <fpgc> no, if you bother to build ghc yourself, you are stepping outside openSUSE's ready-made packages, no?
19:38:37 <fpgc> and if you are stepping outside anyway, why not use one of the ready-made binaries on ghc's website?
19:38:52 <fpgc> (do you even know that they exist?)
19:39:13 <dradtke> fpgc: yes, I know they exist, but I had issues with it not installing correctly
19:39:39 <fpgc> alright, then perhaps it's a good way to spend halloween
19:40:31 <dradtke> fpgc: ghc built pretty easily, it's the rest of the platform that doesn't work
19:43:14 <dradtke> looks like I can get the platform to build using --disable-profiling
19:43:36 <fpgc> then definitely building ghc yourself omits profiling as default
19:44:08 <dradtke> fpgc: I have no problem with that, but it would be nice if configure --help listed options for enabling  it
19:44:38 <fpgc> iirc it is not in configure, it's in some file
19:45:45 <fpgc> before you impeach that, consider the common expectation that 99% of ghc builders are ghc hackers, not ghc end-users
19:46:16 <fpgc> and 0.9999% are linux distro people
19:46:35 <dradtke> fpgc: I'm mostly interested in trying to get openSUSE to update their packages
19:46:54 <dradtke> fpgc: if I can get it to build, then I'll try uploading the package to my home repo
19:48:20 <kfish> fpgc: building ghc from source has profiling enabled by default
19:48:29 <fpgc> then strange
19:48:49 <kfish> yes, something unusual is going on with dradtke's build
19:49:07 <dradtke> I had the "BuildFlavor" set to quick, which says it's a fast build with optimized libraries
19:49:32 <kfish> oh so you did make a non-standard configuration :)
19:49:37 <dradtke> profiling might need the slower, performance-heavy build
19:49:38 <gienah> dradtke: maybe looking at other distros might give some inspiration, gentoo: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-lang
19:50:05 <kfish> dradtke, i suggest doing a default clean build overnight or during lunch :)
19:50:10 <fpgc> this is just another long chain of XY problems
19:50:15 <gienah> dradtke: fedora: http://fedoraproject.org/wiki/Packaging:Haskell
19:50:30 <dradtke> kfish: I might try that later, but it's working fine now with profiling disabled. I just want to make sure I can get it to work
19:50:52 <dradtke> gienah: thanks, that looks useful
19:51:07 <kfish> dradtke, sure, but you worked already worked out that it builds with profiling disabled 4 days ago :-P
19:51:19 <gienah> dradtke: debian: http://wiki.debian.org/Haskell
19:51:58 <dradtke> gienah: rpm will be more useful than deb, imo, but thanks
19:52:10 <dradtke> kfish: I don't remember anything from the first time I tried this other than it didn't work
19:52:17 <MostAwesomeDude> Hi, I'm kinda new to Haskell packages. What's the standard spot to stick QuickCheck tests in a package?
19:57:09 <gienah> MostAwesomeDude: its a new standard in cabal 1.8, like in for example this cabal file: http://hackage.haskell.org/packages/archive/network/2.3.0.7/network.cabal
19:57:52 <gienah> MostAwesomeDude: that example does not use quickcheck though
19:58:32 <JoeyA> In Haddock documentation, can a bullet have multiple paragraphs?  I tried indenting the next paragraph, but the text still appears outside of the bullet.
19:58:46 <gienah> MostAwesomeDude: text uses quickcheck: http://hackage.haskell.org/packages/archive/text/0.11.1.7/text.cabal
19:58:51 <MostAwesomeDude> gienah: What would be the best thing for me to do? I'm coming from Python, where it's common to have a folder full of unit tests which can be run with a top-level command.
19:59:31 <gienah> MostAwesomeDude: to use test-framework-quickcheck2 to organise the tests like text does
19:59:31 <DevHC> ddarius: so? what does spring have to do with pink?
20:00:39 <MostAwesomeDude> gienah: I see. Thanks!
20:01:06 <gienah> MostAwesomeDude: the tests in text only work in latin1 locales
20:01:13 <zeiris> I'm not too familiar with cabal files: why is 'pretty' include on line 31, but not line 33? https://github.com/amtal/CoreErlang/blob/master/CoreErlang.cabal
20:07:09 <int80_h> given a Day, is there a library to calculate the weekday that maps to that Day?
20:08:35 <Cale> toWeekDate :: Day -> (Integer, Int, Int)
20:08:49 <Cale> ?
20:09:35 <Cale> That gives year, week, day of week, (1 for Monday to 7 for Sunday)
20:09:59 <Cale> er, hmm
20:11:15 <int80_h> Cale: that's it, I couldn't find it
20:11:33 <int80_h> Cale: oh wait no that's not it
20:12:04 <Cale> Yeah, that's kind of a weird week format :P
20:12:08 <int80_h> Cale: more like toWeekDay :: Day -> DayofWeek
20:12:19 <int80_h> where DayofWeek is an enumerated type
20:12:31 <int80_h> Monday | Tuesday and so on
20:13:12 <int80_h> Cale: I figure it must be common enough that it's already in alibrary
20:13:47 <Cale> oh, no that works
20:13:49 <int80_h> Cale: I want to know before I write it myself. I'd hate to re-invent the wheel here.
20:14:01 <Cale> x <- getCurrentTime
20:14:07 <Cale> tz <- getCurrentTimeZone
20:14:15 <int80_h> got that part so far
20:14:24 <int80_h> even further
20:14:30 <Cale> toWeekDate . localDay $ utcToLocalTime tz x
20:14:40 <Cale> and then take the third part of that triple
20:14:42 <int80_h> toWeekDate already is written?
20:14:45 <Cale> yes
20:14:56 <Cale> It's in Data.Time.Calendar.WeekDate
20:15:01 <int80_h> oh!
20:15:51 <snappy> Trying to figure out why this doesn't work, any ideas?
20:15:53 <snappy> > filter (<0) map (+1) [1,2,3,4,-1]
20:15:54 <lambdabot>   Couldn't match expected type `[a]'
20:15:54 <lambdabot>         against inferred type `(a1 -> b)...
20:16:15 <Cale> The main awkward thing about the time library is that there may not be quite enough IO helpers, but once you have the current time and time zone, there *are* pure functions for getting everything you might want from that.
20:16:15 <adrake> > filter (<0) $ map (+1) [1,2,3,4,-1]
20:16:16 <lambdabot>   []
20:16:23 <adrake> snappy: ^
20:16:34 <Cale> or even:
20:16:44 <Cale> > filter (<0) . map (+1) $ [1,2,3,4,-1]
20:16:46 <lambdabot>   []
20:16:48 <snappy> hm the '$' is new to me, hm.
20:16:55 <Cale> Or:
20:16:56 <adrake> snappy: mine is equivalent to:
20:16:59 <Cale> > (filter (<0) . map (+1)) [1,2,3,4,-1]
20:17:00 <adrake> > filter (<0) (map (+1) [1,2,3,4,-1])
20:17:01 <lambdabot>   []
20:17:01 <lambdabot>   []
20:17:19 <snappy> ah, i see.
20:17:27 <adrake> snappy: $ is just function application with a different precedence
20:17:32 <Cale> snappy: the way you wrote it was like passing everything else to filter
20:17:43 <int80_h> Cale: I'm thinking I need a vector of WeekDays, where the index corresponds with the number assocaiated with the day. Is there a better way?
20:18:24 <Cale> int80_h: Well, once you have one of them, it's basically mod 7 arithmetic from there :)
20:18:57 <Cale> It's a bit of a shame that they decided to use 1 through 7 for numbering the days though
20:19:12 <int80_h> well that makes it convinient of a Vector
20:19:17 <int80_h> for a Vecotr I mean
20:19:44 <Cale> 0 through 6 would be easier to work with, but I guess that starting with 1 is the same awkward way that all the other date components work.
20:19:54 <Cale> (the month especially ;)
20:20:16 <MostAwesomeDude> Dates are unpleasant in any language. It's some kind of perverse constant.
20:21:12 <Cale> int80_h: If you have your own WeekDay type, you can make it an instance of Enum, and use fromEnum/toEnum to change back and forth from Int
20:21:17 <snappy> Hm, I seem to have this backwards anyway; I'm actually trying to build a partial function that filters negative numbers and adds 1 to all non-negative numbers. So I guess: plus1nonneg = map (+1) (filter (<0)); but I can see the issue since the application is on the map and not filter
20:21:43 <adrake> > map (+1) $ filter (<0) [1,2,3,4,-1]
20:21:44 <lambdabot>   [0]
20:21:47 <Cale> snappy: map (+1) . filter (<0) and you have a valid piece of code there
20:21:55 <snappy> yep, just did that, looks good.
20:21:56 <Cale> (or add a list parameter and use it)
20:22:16 <snappy> yeah that was my next option, trying to use higher order functions where possible
20:22:47 <MostAwesomeDude> Clearly I've been in Python too long; I was gonna suggest an LC.
20:23:01 <mdxbhmt> LC?
20:23:08 <Cale> list comprehension, I think
20:23:24 <fpgc> suggest MC instead :)
20:23:29 <byorgey> MostAwesomeDude: it's just because human measurement of time is a very complex subject.
20:23:37 <MostAwesomeDude> > [ x + 1 | x <- [1,2,3,4,-1], x < 0]
20:23:38 <lambdabot>   [0]
20:23:59 <MostAwesomeDude> Yeah, list comprehension. We don't map/filter/reduce in Python-land. :3
20:24:05 <int80_h> Cale: thanks, I didn't know about toEnum/fromEnum
20:24:08 <Cale> It might be, given the name that you gave the function, that you still have the inequality the wrong way :)
20:24:14 <MostAwesomeDude> byorgey: Indeed. :3
20:24:40 <mdxbhmt> byorgey: dealing with realtime system seems a pain
20:25:41 <Cale> It makes the imperial system of measurements that the US uses almost look sane.
20:26:19 <ian_mi> MostAwesomeDude: didn't expect to see you here!
20:26:42 <MostAwesomeDude> I see a couple people using unit2otherUnit to convert between types; is that a widely-used convention?
20:27:07 <MostAwesomeDude> ian_mi: I got bored so I'm seeing how hard it is to port one of my more serious libraries to Haskell. It's adventures!
20:27:21 <MostAwesomeDude> Also, my presence pervades all of Freenode. Is bkero in here too?
20:27:46 <fpgc> you can say it's halloween and you're here to scare us :)
20:27:54 <ian_mi> don't think so
20:27:57 <MostAwesomeDude> I'm not very scary. :c
20:28:18 <MostAwesomeDude> Hm, interesting, apparently the list monad's preferred to LCs? Or is it a matter of taste?
20:28:37 <fpgc> taste
20:28:52 <ian_mi> I never use LCs anymore but I don't think one's preferred
20:28:56 <fpgc> my opinion anyway
20:29:16 <Cale> Hmm, how shall we measure time, should we pick a single amount of time as measured by some cyclic process and measure all other times using a fixed radix representation from there? Nah, let's try to measure it with different incommensurate cycles, and have to insert extra occurrences of shorter cycles every now and again into the longer ones to make up the difference.
20:29:23 <ian_mi> once you go Applicative you never go back
20:29:56 <kfish> JoeyA, I don't think you can have multiple paragraphs in haddock bullet points (just tried various combinations of punctuation)
20:30:34 <JoeyA> kfish: Thanks.  I'll try to achieve a similar effect using bullets in my module header.
20:30:54 <ian_mi> I rarely actually use the list monad. It's too bad they switched the default applicative instance for lists to match the monad.
20:31:15 <Cale> I use the list monad frequently
20:31:34 <MostAwesomeDude> Lists as monads seem a little bit gratuitous to me, but maybe I just haven't been enlightened.
20:31:42 <byorgey> ian_mi: they *switched* it?  was it ever otherwise?
20:31:48 <Cale> Do you like list comprehensions?
20:31:59 <Cale> If you like list comprehensions, you'll love the list monad.
20:32:25 <MostAwesomeDude> Yeah, the monad syntax for lists just seems a bit...extra, I guess? Compared to the LC syntax.
20:32:39 <Cale> It is like list comprehensions, except that you get a library full of combinators which work with any monad.
20:32:48 <Cale> and which do lots of useful stuff
20:32:52 <byorgey> MostAwesomeDude: sure. which is why list comprehension have now been generalized to *monad* comprehensions! =D
20:32:55 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
20:32:56 <ian_mi> byorgey: didn't they used to be zip lists?
20:32:56 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
20:32:58 <MostAwesomeDude> byorgey: Wait, what.
20:33:09 <Cale> ian_mi: only in a paper
20:33:28 <Cale> > filterM (const [False,True]) [1,2,3]
20:33:29 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
20:34:03 <MostAwesomeDude> How does one have monad comprehensions? Is this like Python's set and dict comprehensions?
20:34:23 <adrake> Cale: that is pretty good
20:34:33 <Cale> MostAwesomeDude: It's basically the same thing as do-notation, using the function 'guard' whenever there's a boolean expression
20:34:35 <byorgey> MostAwesomeDude: http://db.inf.uni-tuebingen.de/files/giorgidze/haskell2011.pdf  if you are actually interested.
20:34:59 <MostAwesomeDude> byorgey: I am, but I think I'll hold off. I ate the kind inference paper yesterday and I'm still full.
20:35:02 <byorgey> MostAwesomeDude: basically, it turns out that the idea of list comprehensions generalizes to any monad, not just lists
20:35:11 <byorgey> MostAwesomeDude: fair enough =)
20:35:33 <applicative> > [(a , b) | a <- "hello"| b <- "hello"]  -- ian_mi 'parallel' monad comprensions use zip lists so to say
20:35:34 <lambdabot>   [('h','h'),('e','e'),('l','l'),('l','l'),('o','o')]
20:35:57 <Cale> [f x y z | x <- l1, p x, y <- l2, q x y, z <- g x y] translates to  do x <- l1; guard (p x); y <- l2; guard (q x y); z <- g x y; return (f x y z)
20:36:27 <Cale> Wait, parallel monad comprehensions now? :)
20:36:35 <Cale> That'll require an analogue to zip
20:36:47 <applicative> yeah, it generalizes
20:36:57 <Cale> Does the implementation in GHC do that?
20:37:02 <applicative> import Control.Monad.Zip define mzip
20:37:04 <fpgc> monad comprehension is in http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#monads  just 19 years ago
20:37:10 <ian_mi> MostAwesomeDude: basically [e x y | xs <- x, ys <- y] is the same as xs >>= (\x -> ys >>= (\y -> e x y))
20:37:14 <applicative> something like that
20:37:24 <Cale> applicative: Is that in 7.3.x?
20:37:29 <ian_mi> etc...
20:37:39 <fpgc> monad comprehension is probably older than some of you
20:37:40 <Cale> oh, it's even in 7.2 :)
20:37:46 <Cale> heh
20:38:15 <Cale> So that's pretty nice
20:38:59 <Cale> A little weird that they opted to put mzip and munzip in the same class.
20:39:01 <Jafet> Now someone just needs to make an SQL monad
20:39:26 <fpgc> the ideal is one class per method
20:39:35 <ian_mi> so the default applicative instance for lists was never zip lists?
20:39:39 <Cale> I'm not sure about that either :)
20:39:54 <Cale> mzip and mzipWith are obviously pretty much equivalent
20:40:07 <applicative> ian_mi: I think that's right, Control.Applicative defines the ZipList wrapper.
20:40:30 <blackdog> Cale: doesn't it then make sense to have one typeclass function, and to define the other in terms of the first?
20:40:34 <Cale> and in general, there are cases where super-fine class hierarchies are still just obnoxious (though this might not be true forever)
20:40:44 <fpgc> SQL monad: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions
20:40:57 <MostAwesomeDude> ian_mi: Okay, that's pretty cool.
20:40:58 <Cale> blackdog: Well, it makes sense to have defaults and let people define which one of the two they find it easiest to define
20:41:28 <fpgc> example: [ x | x <- [1,1,2,2,3], then group by x using GHC.Exts.groupWith ]
20:41:37 <Cale> blackdog: You define default implementations by mutual recursion, and have the people who write the instances define one of them to break the cycle
20:42:15 <applicative> ian_mi 'parallel list comprehensions' are nice because you get either interpretation without a wrapper, using
20:42:34 <Cale> Oh nice, there's Control.Monad.Group as well
20:42:35 <applicative> | for ziplists, ',' for the usual
20:42:56 <Cale> that's cute
20:44:03 <tgeeky> wow. I think this might be the most complicated expression I've ever seen for a (sin/cos) function:
20:44:06 <tgeeky> http://www.wolframalpha.com/input/?i=%28x-11i%29^10%28x-13i%29^14%28x-17i%29^18%28x-19i%29^20%28x-23i%29^24%28x-29i%29^30%28x-31i%29%28x-41i%29%28x-47i%29%28x-59i%29%28x-71i%29
20:44:09 <tgeeky> sigh.
20:44:20 <tgeeky> http://tinyurl.com/64c8knm
20:44:22 <tgeeky> ^^ that
20:44:33 <MostAwesomeDude> Hey, is there a way to get help or a docstring for some random function? Like Python's help().
20:44:52 <blackdog> MostAwesomeDude: hoogle is useful
20:45:01 <Cale> Though to be honest, I never really bought into the whole grouping thing as a good idea for list/monad comprehensions
20:45:23 <MostAwesomeDude> Heh, Hoogle? What a name.
20:45:35 <blackdog> or :info in the REPL, although that just gives you the type
20:45:41 <ian_mi> MostAwesomeDude: If I just want type information I use :t or :i in ghci
20:45:46 <blackdog> i think there's a hayoo too:)
20:46:24 <Jafet> > let a × b = ((.transpose b) . (sum.) . zipWith (*)) . a in [[1,2],[3,4]] × [[5,6,7],[8,9,10]]
20:46:26 <lambdabot>   [[21,24,27],[47,54,61]]
20:46:29 <ian_mi> MostAwesomeDude: Otherwise hoogle is great and there's also the same documentation available in /usr/share/doc/ghc-*
20:46:47 <applicative> @hoogle [a] -> [[a]]
20:46:48 <lambdabot> Data.List inits :: [a] -> [[a]]
20:46:48 <lambdabot> Data.List permutations :: [a] -> [[a]]
20:46:49 <lambdabot> Data.List subsequences :: [a] -> [[a]]
20:46:55 <MostAwesomeDude> Well, specifically I wanted to know about Data.Ord.comparing and why hlint recommended it. :t was sufficient. In general, though, I guess Haskell functions don't carry docs with them like Python objects? So I could understand the problem.
20:47:00 <MostAwesomeDude> What.
20:47:10 <MostAwesomeDude> @hoogle Data.Ord.comparing
20:47:10 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:47:21 <MostAwesomeDude> You guys have the best bot.
20:47:43 <Cale> tgeeky: Well... that is clearly a polynomial? So I guess it comes from factoring a truncated series representation of the thing over the complex numbers, though the roots are so simple (they're all purely imaginary), that perhaps this was the original form.
20:47:51 <blackdog> MostAwesomeDude: notice that you only have to give it the type for it to give you a few options, too. can't do that in python:)
20:48:38 <MostAwesomeDude> blackdog: Let us not get into the language wars. :3
20:49:06 <blackdog> MostAwesomeDude: no war intended, i do a lot of work in ruby.
20:49:35 <Jafet> To RTFM or not to RTFM
20:49:50 <Cale> MostAwesomeDude: It would be nice to have a way to get a link to local haddock documentation from within ghci. There almost is, in that there's a currently-experimental haddock API now with which you can query the system documentation.
20:50:04 <MostAwesomeDude> Cale: Ooh, nifty.
20:50:15 <ian_mi> @hoogle (a -> m (b, c)) -> [a] -> m ([b], [c])
20:50:15 <lambdabot> Control.Monad mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
20:50:53 <ian_mi> I wonder how often people use hoogle like that
20:50:58 <Cale> But it's not exactly so easy to use that you can use it as an alternative to help(). It's more like if you were interested in implementing this feature for ghci, you could maybe make good use of it.
20:51:18 <luite> tgeeky: what's that from? why are all the roots primes?
20:52:09 <Cale> Though it may be possible to write some simple wrappers around it which make IO actions to query the documentation in a user-friendly way
20:52:30 <tgeeky> luite: factors of the (factors of the order of) the monster group
20:52:47 <Cale> I noticed the primeness too...
20:53:03 <Cale> hmm
20:53:11 <tgeeky> it was hand picked, I'm goofing around
20:54:08 <MostAwesomeDude> So if I wanted to find a max3...
20:54:27 <MostAwesomeDude> @hoogle Ord a => a -> a -> a -> a
20:54:28 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
20:54:28 <lambdabot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
20:54:28 <lambdabot> Language.Haskell.TH.Syntax CondE :: Exp -> Exp -> Exp -> Exp
20:54:40 <MostAwesomeDude> Looks like I'll roll my own, then.
20:55:03 <Cale> MostAwesomeDude: yeah, or just use maximum [x,y,z]
20:55:23 <MostAwesomeDude> Aha.
20:56:48 <MostAwesomeDude> IIUC, Haskell doesn't have the Integer/int problem that Java has, right? It just has Ints and Floats and Chars as full types?
20:57:01 <Cale> Yeah...
20:57:16 <tgeeky> Haskell's numeric problems are much more interesting than Java's :)
20:58:46 <fpgc> IIUC, yes
20:59:03 <Cale> Well
20:59:03 <Cale> GHC gives some lowlevel support for unboxed types
20:59:05 <Cale> whoa lag
20:59:35 <Cale> grr
20:59:41 <Cale> MostAwesomeDude: did you get my response? I'm guessing no?
21:00:03 <fpgc> we got "GHC gives some lowlevel support for unboxed types" and "whoa lag"
21:00:04 <MostAwesomeDude> Cale: I got it.
21:00:09 <Cale> okay
21:00:23 <Cale> So it eventually delivered them :P
21:00:37 <MostAwesomeDude> I don't really care where the boxes are, I just want to make sure that if I do something like "data Coord = Coord Int Int Int" I'm not committing some sin.
21:00:39 <fpgc> irc is not lazy I/O :)
21:00:44 <Cale> MostAwesomeDude: So if you see types with # after them, that's what those are
21:01:00 <Cale> But you won't see that unless you dig into GHC's implementation of types like Int and Integer
21:01:31 <Cale> Int corresponds to machine integers, while Integer is unbounded (up to the size of memory)
21:01:35 <MostAwesomeDude> Aha.
21:01:46 <fpgc> our favourite game:
21:01:52 <fpgc> > 2^1000 :: Int
21:01:53 <lambdabot>   0
21:01:56 <fpgc> \∩/
21:02:04 <Cale> > 2^1000 :: Integer
21:02:05 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
21:02:10 <Jafet> @quote and.beyond
21:02:10 <lambdabot> identity says: "To " ++ (show $ log (2^1024)) ++ " and beyond!"
21:02:52 <ian_mi> MostAwesomeDude: basically, there's no problem
21:05:20 <MostAwesomeDude> ian_mi: Yeah, I'm pretty okay with this.
21:05:58 <scooty-puff> is it possible to use "happy" with a monad transformer with unknown underlying Monad m?
21:06:05 <scooty-puff> i have been having trouble doing so..
21:06:30 <Cale> I just got a fairly amusing spam, from someone claiming to be an attorney from Johannesburg, South Africa, spewing all kinds of nutcase religious garbage.
21:07:19 <ian_mi> Ints are great. I especially love how fast IntSet is.
21:07:33 <Cale> Ints have their place, but they don't belong in the Prelude
21:07:56 <Cale> and should not be the default for anything
21:09:46 <ian_mi> I'm not sure where else they'd go
21:09:55 <Cale> Data.Int
21:10:07 <Cale> I don't care that the results of certain things (like getting the size of a datastructure) technically can't be larger than an Int, calculations done on those results can easily be, and when it happens it destroys correctness in subtle ways which can be annoying to track down.
21:10:21 <adrake> Cale: you are advocating for use of Integer everywhere?
21:10:30 <DevHC> Cale: yes it certainly can be larger than 2^32 or even 2^64
21:10:38 <Cale> adrake: everywhere that it's not absolutely required for performance reasons to use Int
21:11:09 <scooty-puff> maybe have Num a with good use of specialise and inline?
21:11:32 <Cale> scooty-puff: That's also a good option, considering that numeric defaulting will tend to pick Integer
21:11:45 <ian_mi> you could have perfectly good finite lists with length which overflows an Int
21:11:57 <ian_mi> although in the 64bit case that would be pretty ridiculous
21:12:31 <DevHC> maybe use Integer everywhere and give the compiler hints on when to automatically transform Integer to Int, where equivalence can be deduced
21:17:03 <mithos28> if I have having trouble installing a hackage package, can people here help or should I try the maintainer?
21:17:15 <dmwit> Start here.
21:17:17 <dmwit> ?hpaste the error
21:17:18 <lambdabot> Haskell pastebin: http://hpaste.org/
21:18:16 <hpaste> mithos28 pasted “installation error of vec” at http://hpaste.org/53382
21:18:49 <DevHC> or even have code for both Int and Integer variants of every Integer function, and have runtime Integer-Int conversions of thunks
21:19:28 <DevHC> Int arithmetic is to be performed with overflow checks, and should transform thunks to Integer variants in case of detected overflows
21:19:37 <mithos28> The hackage page does not say that it supports 7.2.1(my version) but only 6.10, and 7.0. But I would think it shouldd be forward compatible.
21:21:00 <adrake> DevHC: that sounds like an implementation detail of Integer
21:23:42 <DevHC[1]> adrake: exactly
21:24:08 <DevHC[1]> haskell's job is to have a faster Integer, not fast hacks like Int
21:24:15 <DevHC[1]> well, Int as an alternative
21:24:28 <dmwit> mithos28: Those errors are pretty easy to fix: move the INLINE pragmas out of the class declaration block.
21:24:36 <dmwit> mithos28: Send the author a patch, while you're at it.
21:25:14 <mithos28> dmwit: where is the code kept on my local machine so that this works seamlessly with cabal?
21:25:19 <dmwit> mithos28: (See http://hackage.haskell.org/trac/ghc/ticket/5084 for more.)
21:25:35 <dmwit> mithos28: You can "cabal unpack vec" to get a copy of the code.
21:25:45 <dmwit> Or whatever the package is called.
21:25:57 <dmwit> mithos28: But you should check hackage to see if there's a code repository somewhere and use that instead.
21:26:33 <dmwit> Or perhaps a better way to answer your question: the location of the code on your machine is orthogonal to making it work seamlessly with cabal.
21:26:46 <dmwit> So put it where you like.
21:27:19 <mithos28> and cabal install from that location will work right?
21:27:24 <dmwit> Right.
21:27:31 <mithos28> awesome, thanks for the help
21:27:41 <dmwit> mithos28: If you change the .cabal file, be SURE to bump the version number.
21:28:13 <dmwit> If the version number in the .cabal file matches a version that cabal knows about via Hackage, but the rest of the file doesn't match the file that cabal knows about from Hackage, very annoying things can happen.
21:29:19 <mithos28> can I maintain my own repository of packages that cabal treats as more authoritative than hackage?
21:29:27 <dmwit> Yes.
21:29:43 <mithos28> and then that wouldn't be a problem, right?
21:30:17 <dmwit> I suppose not.
21:30:30 <dmwit> But that seems like much more work than just bumping a version number.
21:31:22 <BMeph> Does anyone here follow Norman Ramsey's papers?
21:35:06 <tgeeky> no but his picture makes me think *he* thinks interesting things
22:06:58 <kmc> DevHC[1], GHC already implements small Integers the same way as Ints
22:07:12 <kmc> it's still much slower because you usually can't infer statically that an integer is small
22:07:38 <kmc> btw you could make an IntegerSet which is about as fast as IntSet
22:10:27 <kmc> I agree with Cale that Int should not be in the Prelude
22:11:54 <kmc> Prelude should contain conceptually simple things
22:12:05 <byorgey> hmmmm. if V is a vector space then so is the set of total functions from T to V.  However, I really want to use the set of *partial* functions from T to V but it seems those *don't* form a vector space. =(
22:12:24 <kmc> you can import other modules if you want conceptually nasty things like integers mod some implementation-defined number
22:13:35 <kmc> ian_mi, a finite list which overflows the guarantees on Int (2^29 - 1) is not at all ridiculous
22:13:52 <kmc> if you're relying on 64-bit or even 32-bit integers, your code is not portable
22:14:31 <dmwit> byorgey: I don't suppose you have any more structure on T than just "a set"?
22:14:50 <byorgey> dmwit: for concreteness let's say T = the reals.
22:15:07 <ddarius> dmwit: Does it matter?
22:15:18 <dmwit> I don't know!
22:16:16 <byorgey> the context is adding support for animations to diagrams, where I want to be able to place animations next to each other temporally, so I need to know where they start and stop, i.e. for what times they are defined
22:17:37 <byorgey> anyway, it's not a question so much as a general lament in the hopes that someone might shed some brilliant insight on the subject
22:18:44 <dmwit> I wouldn't be surprised if intervals together with a function from that interval to V is a vector space.
22:18:44 <ddarius> Maybe use modules?
22:19:03 <dmwit> For addition, take the intersection of the intervals.
22:19:09 * dmwit looks up vector spaces
22:19:35 <byorgey> dmwit: yes, but then the problem is additive inverses
22:19:38 * djahandarie knows he is in trouble when he parses perfectly valid English as invalid English with Haskell expressions in it.
22:19:50 <dmwit> No additive inverse.
22:19:50 <byorgey> dmwit: if adding destroys information you can't get it back
22:19:56 <dmwit> Very bad.
22:20:41 <MostAwesomeDude> What do I use if I'm parsing binary data and I want to do it in a relatively pretty or declarative way?
22:20:56 <byorgey> ddarius: hmm, I'll think about that
22:21:15 <blackdog> MostAwesomeDude: cereal?
22:22:19 <MostAwesomeDude> blackdog: Hm. Would that be suitable for networking stuff?
22:22:40 <dmwit> I suppose you could make the interval also an input.
22:22:49 <dmwit> This would be a bit annoying for animation writers, I suppose.
22:23:01 <MostAwesomeDude> I have a protocol which is binary, and comes in raw over TCP, so something that could handle IO directly would be helpful.
22:23:17 <dmwit> Yeah, that doesn't really work.
22:23:25 <byorgey> dmwit: can you elaborate? what do you mean "make the interval" ... ok, never mind =)
22:24:04 <dmwit> I mean, I was thinking of functions with a dependent type like I : Interval -> a : I -> V
22:24:35 <dmwit> And then animations would have to do something dumb for intervals larger than the one they knew how to animate.
22:24:36 * djahandarie can't parse that signature
22:24:45 <djahandarie> Oh, I see it now.
22:24:54 * djahandarie is just having a hard day with parsing apparently
22:25:36 <byorgey> dmwit: oh, hah
22:25:43 <byorgey> dmwit: like render a picture of a monkey
22:25:48 <dmwit> =D
22:26:32 <blackdog> MostAwesomeDude: http://stackoverflow.com/questions/2423894/using-haskells-parsec-to-parse-binary-files
22:26:50 <dmwit> (Intervals are just standing in as an easily-representable alternative to giving any old subset of the reals, of course.)
22:27:14 <ddarius> djahandarie: It's not clear.
22:28:57 <byorgey> dmwit: right, I was thinking along those lines as well.
22:29:42 <byorgey> dmwit: I am perfectly happy not being able to represent animations like "at rational times, show this circle; at irrational times, show a monkey"
22:29:57 <dmwit> =)
22:30:18 <dmwit> On the other hand, if you can write an animation with that dependent type, why are we bothering with the partiality discussion at all?
22:30:50 <dmwit> Just use R -> V. For people who can write the more specific type, I'll hand them the interval that covers all of R.
22:30:51 * byorgey goes off to port diagrams to Agda
22:31:02 <fpgc> make a circle-like monkey
22:33:26 <ddarius> We all knew that Haskell was just a flash in the pan.  Now Agda, that's where the real staying power is at.
22:33:55 <Axman6> MostAwesomeDude: attoparsec is a great choice for parsing things coming in over a network, it allows for parsing things in chunks that may not contain the whole input yet
22:34:38 <ian_mi> Binary's get monad also can process lazy bytestrings I think but cereal is strict.
22:34:59 <ian_mi> MostAwesomeDude: iteratees also look interesting but I have no experience with them.
22:35:05 <Axman6> attoparsec is a much better design for network parsing
22:35:20 * adrake +1 attoparsec
22:35:28 <ddarius> If the format is reasonably complicated, use attoparsec, if it is rather simple use binary or cereal.
22:35:37 <Axman6> attoparsec is basically an iteratee (and all the iteratee frameworks will take an attorparsec parser and turn it into an iteratee)
22:36:12 <MostAwesomeDude> Axman6, ian_mi : I found attoparsec and am reading the docs right now.
22:36:19 <ian_mi> great
22:36:48 <MostAwesomeDude> This format is Minecraft's wire protocol. It's *incredibly* bonghits, so I'll keep reading attoparsec. :3
22:36:52 * ddarius endorses the recent Monad Reader article's perspective on "iteratees."
22:38:41 <adrake> MostAwesomeDude: if/when you get it working, be sure to put it on hackage :P
22:39:06 <Axman6> i think there's already someone who's parsing ther minecraft wire protocol with haskell...
22:39:36 <ian_mi> ddarius: "people frequently cannot understand what it is, how it works, what it offers, or anything else."
22:39:36 <Axman6> http://blog.acfoltzer.net/2010/12/minecraft-data-api-for-haskell-haskellnbt/
22:39:40 <MostAwesomeDude> adrake: Spoiler alert: I'm translating Bravo, the best of the custom servers, to Haskell. It's an exercise in masochism and learning new languages.
22:39:50 <MostAwesomeDude> NBT's the disk protocol; I'm doing wire protocol first.
22:40:26 <Axman6> hmm, there is someone doing the wire protocol too i'm sure. pretty sure someone's already written a minecraft server in haskell
22:40:46 <Axman6> https://github.com/glguy/minecraft-proxy
22:40:54 <ian_mi> I'm pretty sure everyone's already done everything.
22:41:01 <adrake> MostAwesomeDude: oof, have fun!
22:41:16 <MostAwesomeDude> wiki.vg/Server_List says that nobody's gotten anywhere serious in Haskell.
22:43:15 <ddarius> @quote ddarius iteratees
22:43:15 <lambdabot> ddarius says: The history of iteratees is making a simple idea complex.
22:43:30 <byorgey> dmwit: so if you think of a partial function as a total function (R -> V) paired with a "mask" function (R -> Bool) telling you where the partial function is defined, I think you can make a vector space if you combine the mask functions with XOR
22:43:41 <byorgey> dmwit: I just have no idea what such an operation would mean =P
22:46:00 <tomprince> that would just the free Z/2Z-module on the set of reals.
22:49:05 <ddarius> byorgey: It would mean show the animation frames only where only one of the addends is defined.
22:49:26 <tomprince> Which would make it not a vector space, since x+x=0. At least, it would have an everywhere zero mask. But then 2x = 2y, where y is x with 0 mask.
22:50:12 <tomprince> byorgey: Why do you need a vector space?
22:50:30 <ddarius> Indeed, I would start from the compositing operators and work "backwards."
22:50:56 <byorgey> tomprince: I already have a large existing framework that works with vector spaces.  I initially thought it would be easy to extend to animations.
22:51:20 <byorgey> but yes, at this point I guess I need to switch to a different appoach.
22:51:26 <byorgey> *approach
22:53:06 <tomprince> Well, if you don't care about your addative inverse being a true inverse, you probably could. i.e. extend functions with zero and take the union.
22:53:35 <tomprince> Or, 0
22:53:38 <tomprince> .
22:53:43 <ddarius> byorgey: I assume this framework is for images.  What do you do for cropping images?
22:54:48 <tomprince> Or, just take the dependent product {S: P(R) & S -> V}
22:55:07 <copumpkin> mzero: hey, you do the mac installers, right?
22:55:11 <byorgey> tomprince: yes, something like that could work I suppose.  I'd have to think about how much weirdness users would have to swallow if additive inverses aren't really
22:56:35 <mzero> copumpkin: I do indeed
22:56:45 <copumpkin> mzero: do you have any thoughts on http://hackage.haskell.org/trac/ghc/ticket/5580#comment:1 ?
22:56:53 <byorgey> ddarius: it's a bit complicated to explain but I see what you are getting at.
22:57:03 <tomprince> Wait, that dependent product isn't what I want.
22:57:26 <copumpkin> dependent products is always the answer
22:57:29 <copumpkin> are?
22:57:45 <ddarius> Are.
22:58:12 <ddarius> copumpkin just likes Π.
22:58:23 <tomprince> I just mean, treat the vector spaces for each I->V as independent, and take the sum.
22:58:38 <copumpkin> copumpkin Σ
22:58:39 <djahandarie> PumpkinΠ
22:58:42 <djahandarie> Damn it
22:58:45 <copumpkin> pumpkinΠ
22:58:48 <copumpkin> that's fine
22:59:19 <tomprince> That way you get real addative inverses.
22:59:35 <ddarius> Meth: Sedative inverse
23:00:50 <byorgey> tomprince: I'm not sure I follow.
23:01:27 <mzero> normally, on mac I'd expect to see  files in /usr/bin like ghc7.0 ghc7.2 ghc7.4
23:01:30 <tomprince> Just treat the sum of two partial functions defined on different sets as a formal sum.
23:01:33 <tomprince> byorgey: It really depends on what you want things in this hypothetical space to mean.
23:01:50 <mzero> these would symlink to the bin in /Library/Framework/GHC.frameworkVersions/x.y.zzzzzz/usr/bin
23:02:04 <mzero> then there would be a ghc in /usr/bin that symlink'd to one of those
23:02:05 <copumpkin> mzero: I just meant even for ghc itself
23:02:06 <copumpkin> airpumpkin2:~ pumpkin$ ls -ld `which ghc`
23:02:06 <copumpkin> lrwxr-xr-x  1 root  wheel  74 Oct 18 11:48 /usr/bin/ghc -> /Library/Frameworks/GHC.framework/Versions/7.3.20111017-x86_64/usr/bin/ghc
23:02:13 <copumpkin> that could easily point to the same thing but in Versions/Current
23:02:14 <mzero> or indirected via some config file in /etc
23:02:26 <mzero> copumpkin: yes - as do i
23:02:38 <byorgey> tomprince: oh, I see what you mean.  Yeah, that wouldn't really work for my purposes.
23:02:46 <tomprince> { S : P R & S } -> R
23:02:48 <byorgey> anyway, back to the drawing board.
23:02:57 <mzero> I don't think that you should indirect ghc though /Versions/Current
23:02:59 <copumpkin> mzero: ah
23:03:03 <tomprince> byorgey: So what does this vs mean?
23:03:21 <mzero> that isn't really what it is there for --- Current is sort of a hint to development env.
23:03:43 <mzero> so /usr/bin/ghc should symlink to /usr/bin/ghcX.Y
23:04:30 <copumpkin> hmm, I guess, but I don't see the problem with symlinking to current
23:04:48 <copumpkin> within each installation
23:04:53 <copumpkin> there's a ghc that points to a numbered ghc
23:05:19 <copumpkin> so lrwxr-xr-x  1 pumpkin  staff  16 Oct 18 11:48 /Library/Frameworks/GHC.framework/Versions/7.3.20111017-x86_64/usr/bin/ghc -> ghc-7.3.20111017
23:05:20 <tomprince> Like, what effect would a given partial function have on your drawing, and what would adding two such functions do?
23:05:53 <mzero> copumpkin: mostly because things in the system don't expect Current to be pushed around to older versions --- so it isn't the recommended way of running or defaulting to older versions of a tool
23:06:04 <copumpkin> ah, fair enough
23:06:38 <mzero> I doubt anything in Mac OS X would really care --- but the next installation by the user might get weirded out... not sure
23:07:03 <mzero> (and sure as heck don't want to make another test set up to add to my too many Mac OS X partitions for testing HP)
23:07:09 <adrake> apropos of nothing: I want to hug the authors of data-accessor
23:07:21 <copumpkin> as far as I could tell, it just sticks the version into Versions and overwrites the current Current symlink
23:07:21 <adrake> so much boilerplate and useless code saved
23:07:26 <copumpkin> but possibly not
23:07:41 <copumpkin> since I've installed older versions over newer versions
23:07:47 <copumpkin> and they change Current too
23:07:51 <tomprince> byorgey: I am guessing you are overloading the VS to both be a position (affine), and transformations (vector).
23:09:02 <mzero> copumpkin: so I want to include an optional "uninstall older versions" script with the next HP release for Mac
23:09:12 <copumpkin> ah, cool
23:09:43 <mzero> I'm going to need to understand what people have on their system and I'm thinking of writing a little script that probes what is on people's setups and asking folks to run it and e-mail me the results
23:09:47 <tomprince> Then you could just have R->V for your vector space (treating undefined as 0), and { S: P R & S -> V } as your affine space
23:10:11 <mzero> this is so that I can see where old cruft has ended up - and if / how they alter their cabal config
23:10:34 <mzero> I wonder if people would be more comfortable with a shell script or  a Haskell program?
23:10:38 <copumpkin> mzero: sure
23:10:46 <copumpkin> I'm fine with both, if you want to poke me when it's done
23:11:34 <tomprince> Then your vectors would act on the affine space. Although, the action wouldn't be free, and not every two points would f
23:12:11 <tomprince> .. would have a difference, although you could still take an approximate difference on their intersection.
23:21:55 <byorgey> tomprince: no, I'm not overloading the vector space like that
23:22:02 <byorgey> there is a separate type for positions
23:25:37 <tomprince> Well, then why do you need partial functions?
23:30:52 <Danl2620> ...
23:31:12 <Danl2620> @help
23:31:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:31:19 <Danl2620> @list
23:31:20 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:31:54 <Danl2620> @help seen
23:31:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:32:19 <Danl2620> @help @seen
23:32:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:32:50 <Danl2620> @seen dylukes
23:32:50 <preflex>  dylukes was last seen on #haskell 5 hours, 56 minutes and 24 seconds ago, saying: I wrote a blog post on the very basics of this... but I haven't written the chapter with the "practical" bits yet.
23:32:50 <lambdabot> Unknown command, try @list
23:56:19 <Axman6> edwardk: did you do a talk on trifecta? i've found slides, but they seem like they're missing a lot of info the accompanying talk would fill in
23:57:04 <dmwit> tomprince: Presumably to allow animations to only be defined for some times.
23:57:17 <edwardk> Axman6: i gave a short talk on it, but it was right after the gsoc summit, and i had been sick, so all i really did was sit down and talk through where it was and where it was going
23:57:30 <dmwit> tomprince: (Since in the R -> V vector space it's hard to ask for the "time normal", so to speak, to give a bounding box on an animation.)
23:57:37 <edwardk> so no real slide deck, etc.
23:57:55 <Axman6> edwardk: heh, fair enough. i'll read through the slides and ask questiong if i have any
23:58:11 <edwardk> what slides did you find? the old trifecta ones?
23:58:19 <Axman6> http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf
23:58:25 <dmwit> byorgey: Can you just use R^4...?
23:58:26 <edwardk> those really have little to nothing to do with the trifecta library that is there today =)
23:58:27 <Axman6> probably the old ones i'd guess from the url
23:58:41 <edwardk> they predate the current project. more or less i just stole my old name
23:58:42 <Axman6> heh, is there something better i should be looking at?
23:58:51 <edwardk> =/ not really
23:59:02 <Axman6> :(
23:59:02 <edwardk> they at least motivate the iteratee based parser stuff
23:59:13 <wavewave> hi.
23:59:15 <edwardk> but the monoidal dyck language layer isn't in there
23:59:37 <wavewave> I am making iteratee based GUI. :-)
23:59:50 <Axman6> o.O
23:59:58 <Axman6> how's that work?
