00:00:04 <bartavelle> not sure how to answer that, you say "include apache::proxy", and it should find the "class apache::proxy($parameter,$list) {}" block and add it to the list of stuff to configure
00:00:21 <bartavelle> the problem is that there is an explicit autoloading feature
00:00:34 <bartavelle> meaning it should be in /etc/puppet/modules/apache/manifests/proxy.pp
00:00:39 <bartavelle> so you should load a file
00:00:41 <ibid> to configure?  what do you mean by that?
00:00:58 <bartavelle> puppet is a language that embodies "configuration as code"
00:01:06 <ibid> ah
00:01:23 <bartavelle> it's like file { '/etc/apache2/sites-enabled': content => template('apache/my_default_site.erb') }
00:01:31 <ibid> can include occur anywhere, or only at top level?
00:01:42 <bartavelle> in any node or class block
00:01:48 <bartavelle> in conditionals even
00:02:01 <ibid> that's weird
00:02:04 <bartavelle> yes
00:02:09 <bartavelle> but incredibly useful :)
00:02:13 <ibid> if it's supposed to affect top level at any nesting level
00:02:40 <bartavelle> actually it is not really "top" level, the scoping only affects variable name resolution
00:02:44 <ibid> is your problem related to the actual loading of the file, or in getting the nesting level right?
00:02:54 <bartavelle> both, because you can have this
00:03:01 <bartavelle> include $variable
00:03:03 <bartavelle> well not like that
00:03:07 <bartavelle> but this can happen
00:03:18 <ibid> i mean, you can treat them as separate problems
00:03:18 <bartavelle> and I decided to parse, then interpret (and resolve variable) in pure code
00:03:22 <bartavelle> ok
00:03:31 <bartavelle> then it is more like the loading problem
00:03:48 <bartavelle> I do not really want to add variable resolution in the Parsec part
00:04:43 <ibid> if you can import the file text and have it included in your AST (or whatever) at the spot where the include command occurs, you can tag it and then do a post-parse rewrite of the AST to bring it to top level
00:05:15 <bartavelle> then a multi pass process
00:05:26 <ibid> now, the usual way to handle reading incldes is for the parser, once it recognises an include directive, to signal the lexer to switch to reading the included file
00:05:41 <ibid> well, haskell is lazy so it may end up being interleaved
00:05:51 <Cale> Yeah, you can include as part of the output of your parser a list of things which need to be included, and then back in I/O land, read those things, and recursively parse them, and splice them in appropriately
00:05:53 <bartavelle> I'm not sure how I could achieve that
00:06:04 <Cale> I don't think it would be particularly lazy.
00:06:06 <bartavelle> ah
00:06:20 <ibid> Cale's idea is a good one, actually
00:06:37 <bartavelle> then I'm have to change my "map" parsing process to a "foldl" one
00:06:51 <bartavelle> to pass some structure around
00:07:10 <ibid> not necessarilty, if you follow Cale's suggestion
00:07:36 <ibid> you parse your top file, then get the AST and see if the AST includes any include directives and if so, call the parser again for the included stuff
00:07:46 <ibid> parser's the same, doesn't need state
00:07:58 <Cale> However, if the parsing of the remainder of the file depends in an essential way on the text that's meant to be included, this isn't quite going to cut it.
00:08:01 <ibid> but there's a driver that handles the includes
00:08:30 <ibid> Cale: true, but then bartavelle would be passing state even without includes, i think
00:08:38 <bartavelle> I'm not sure if it should depend on it, surely my manifests don't, but the language definition is not really formal to say the least
00:08:49 <bartavelle> another question
00:08:54 <ibid> bartavelle: sorry, my original idea was poorly explained and was cut short.  cale's is better anyway :)
00:09:28 <bartavelle> Once parsed, I interpret with a foldl that keeps a context structure around, with things such as variable values
00:09:39 <bartavelle> how can I stop on error the foldl processing ?
00:09:41 <Cale> otoh, Parsec is a monad transformer now, so you could theoretically ParsecT over IO, and just load the file in-place.
00:09:48 <bartavelle> right now i do | otherwise = head []
00:09:51 <bartavelle> and i have an exception
00:09:53 <Cale> I'm not sure if that's better or worse :)
00:09:57 <bartavelle> but that's not a helpful error message
00:10:29 <Cale> Use Either somehow perhaps?
00:10:31 <ibid> bartavelle: have the fold return type include a Wrong value, and return that
00:10:41 <ibid> or Either, like Cale says
00:10:50 <Cale> same thing :)
00:10:57 <ibid> sure, but i personally like using tailored types :-)
00:11:23 <bartavelle> ah right
00:11:52 <bartavelle> everything seems obvious in retrospect
00:12:01 <ibid> they often do :-)
00:12:04 <bartavelle> except that IO problem, which I'll have to explore further
00:12:30 <ibid> but it would be a mistake to think that obvious in retrospect means should-have-been-obvious-in-the-first-place :-)
00:12:40 <DanBurton> regarding Maybes: Nothing seems obvious in retrospect ;)
00:12:43 <ibid> (i've committed that fallacy myself numerous times)
00:12:50 <bartavelle> I suppose once you have written a few interpreters this should be piece of cake
00:13:05 <bartavelle> DanBurton :)
00:13:23 <ibid> well yeah, you learn a couple of patterns the first time you do it :)
00:17:19 <Blkt> good morning everyone
00:27:19 <hinkes> Hey Haskellers:  quick question.  Any recommendations for resources on software desing in haskell?
00:28:36 <hinkes> Small toy applications with no state seem straight forward.  But ask me how to design something bigger (like a web-server), and I'm a bit lost.
00:28:50 <hinkes> I wonder if anyone else has similar experiences.
00:30:32 <flux> I have no idea, but I'm a big believer in 'learning by doing'
00:30:43 <flux> ie try to accomplish the task until you've done it, then do it again but better ;)
00:30:46 <luite> there are a few example webservers, and a few web frameworks. the yesod blog regularly has posts explaining which choices were made and why
00:31:40 <luite> a few common things you find between snap and yesod are iteratees and monad transformers
00:32:29 <luite> if you want to write a high performance webserver/framework, you'll likely use both of those
00:33:25 <hinkes> I'll take a look.  I bet the APIs will help me.  Thanks
00:33:59 <ddarius> Web servers are easy.
00:34:55 <luite> hinkes: they're quite different in how they approach things
00:37:20 <ibid> i'd probably start by thinking about the overall architecture.  trying to figure out the kinds of data that flows inside the program, and the components that read and write, and perhaps transport, those data. i'd try to figure out where i need state and try to isolate such parts from most of the program
00:37:52 <ibid> i wouldn't start with thinking about iteratees and monad transformers, except if my goal was to learn about them :)
00:38:24 <ibid> (though learning the available tools before committing to a design is a good idea)
00:38:29 <luite> it's probably a good subgoal if you want to write larger haskell programs :)
00:43:18 <wavewave> i think that in FP,  good design often comes from bottom-up.
00:43:32 <wavewave> also focus on data type.
00:43:49 <luite> hmm, I've upgraded the ram in my laptop from 4 to 8 gb, and after that my yesod web app started crashing when started with yesod devel (which compiles the program to a library, and then loads it with a small main .hs file and runghc)
00:43:52 <hinkes> If I went about designing a web-server framework, I'd end up exposing IO to the user and make liberal use of IORef
00:44:10 <wavewave> and very aggressive refactoring.
00:44:13 <luite> it could just be a coincidence, but is it possible that the larger amount of physical memory somehow affects runghc?
00:44:15 <Sgeo|web> >succ `id` 5
00:44:25 <Sgeo|web> > succ `id` 5
00:44:26 <lambdabot>   6
00:44:32 <Sgeo|web> I am pretty much freaking out
00:44:42 <Sgeo|web> How, exactly, does the `` stuff work?
00:44:56 <ibid> > id succ 5
00:44:57 <lambdabot>   6
00:44:58 <Sgeo|web> Apply the `` to the item on the left than apply to the right?
00:45:15 <c_wraith> Sgeo|web: it just lets you treat a function as an infix operator
00:45:26 <c_wraith> > 10 `subtract` 3
00:45:27 <lambdabot>   -7
00:45:29 <hinkes> `+` 1 2
00:45:35 <ibid> a `foo` b is the same thing as foo a b (with parentheses added if necessary)
00:45:45 <Sgeo|web> c_wraith: that's... not so intuitive, I guess, when currying's involved
00:45:50 <ibid> hinkes: (+) 1 2
00:45:53 <hinkes> > `+` 1 2
00:45:54 <lambdabot>   <no location info>: parse error on input ``'
00:46:01 <c_wraith> Sgeo|web: it's the opposite of putting an infix operator in parens
00:46:17 <Sgeo|web> c_wraith: but a->a worked as infix
00:46:17 <ibid> hinkes: '...' works only for function names.  + is an operator name
00:46:19 <c_wraith> Sgeo|web: it just makes some expressions easier to read
00:46:31 <Sgeo|web> So it's just a bit unintuitive for me I guess
00:46:33 <c_wraith> > 5 `elem` [1..10]
00:46:34 <lambdabot>   True
00:46:57 <ibid> Sgeo|web: what do you mean when you say that a->a worked as infix?
00:47:08 <ibid> Sgeo|web: a unary function cannot be infix
00:47:08 <c_wraith> Sgeo|web: I have no clue what you mean by that.  function application is the thing that's different from infix operator application
00:47:08 <Sgeo|web> > succ `id` 5
00:47:09 <lambdabot>   6
00:47:11 <hinkes> I thought + was just a function
00:47:22 <ibid> hinkes: (+) is a function.  + is an operator
00:47:31 <c_wraith> hinkes: functions and operators are the same thing internally, but they have different syntax rules
00:47:48 <hinkes> Right, thanks
00:47:54 <Sgeo|web> id is a unary function, usually, except, when used as such, it kind of becomes an operator ($)
00:48:06 <c_wraith> > id `asTypeOf` ($)
00:48:07 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> a -> b)
00:48:08 <lambdabot>    arising fro...
00:48:09 <c_wraith> err
00:48:12 <c_wraith> :t id `asTypeOf` ($)
00:48:13 <lambdabot> forall a b. (a -> b) -> a -> b
00:48:36 <c_wraith> Sgeo|web: it's just standard unification of types
00:49:00 <Sgeo|web> c_wraith: I worked out that id and $ are the same thing except $ has a resticted type, I was just a little surprised that GHC is... ok with doing what I did, I guess
00:49:08 <ibid> Sgeo|web: good point about id, but the reason it works is that id succ 5 is valid
00:49:21 <c_wraith> Sgeo|web: it shouldn't be that mysterious
00:49:25 <c_wraith> :t id
00:49:26 <lambdabot> forall a. a -> a
00:49:28 <ibid> Sgeo|web: a `foo` b is syntactic sugar for foo (a) (b)
00:49:30 <ddarius> id very slightly semantically distinct from ($)
00:49:39 <Sgeo|web> c_wraith: it makes a little more sense when I thing about it, I guess
00:49:39 <c_wraith> :t (succ `id)
00:49:40 <lambdabot> parse error on input `)'
00:49:41 <c_wraith> :t (succ `id`)
00:49:42 <lambdabot> forall a. (Enum a) => a -> a
00:50:02 <c_wraith> :t (5 `id`)
00:50:03 <lambdabot> forall t. (Num t) => t
00:50:10 <c_wraith> hehe.  Ok, that example is a bit dirty
00:50:15 <c_wraith> > (5 `id`)
00:50:16 <lambdabot>   5
00:50:33 <ibid> whoa
00:50:33 <c_wraith> technically, I believe that's against the haskell98 spec, but GHC has allowed it for a while now
00:50:39 <Sgeo|web> 5 `id` 3
00:50:46 <Sgeo|web> > 5 `id` 3
00:50:46 <lambdabot>   5
00:50:53 <Sgeo|web> ...wait what
00:50:55 <ibid> that's weird
00:50:56 <c_wraith> Sgeo|web: that, on the other hand, is different
00:50:56 <Sgeo|web> > 5 3
00:50:57 <lambdabot>   5
00:51:07 <Sgeo|web> ...is this a lambdabot quirk?
00:51:08 <c_wraith> that's because lambdabot has an instance of Num for functions
00:51:10 <ibid> > id 5 3
00:51:11 <lambdabot>   5
00:51:21 <ibid> what?
00:51:24 <Sgeo|web> > 'h' `id` 'j'
00:51:25 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> t'
00:51:25 <lambdabot>         against inferred...
00:51:27 <ibid> > id + succ
00:51:28 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
00:51:28 <lambdabot>    arising from a use of `...
00:51:34 <mauke> > (id + succ) 2
00:51:35 <lambdabot>   5
00:51:36 <ibid> weird
00:51:52 <ibid> what's the semantics of adding functions?
00:51:59 <Sgeo|web> ibid: functions are numbers in lambdabot, and normal numbers can be converted to functions
00:51:59 <ibid> pointwise addition?
00:52:00 <Sgeo|web> Yay!
00:52:05 <ibid> Sgeo|web: yes, i get that
00:52:08 <c_wraith> > let (!) x = product [1..x] in (4!)
00:52:08 <lambdabot>   24
00:52:28 <mauke> > (sin + cos) pi
00:52:28 <c_wraith> That example is the main reason GHC allows you to do that.  Fake postfix notation
00:52:29 <lambdabot>   -0.9999999999999999
00:52:35 <c_wraith> rounding error!
00:52:53 <mauke> > (2 * cos) pi
00:52:54 <lambdabot>   -2.0
00:52:57 <Sgeo|web> > (sin * sin + cos * cos) x
00:52:58 <lambdabot>   sin x * sin x + cos x * cos x
00:53:03 <Sgeo|web> > (sin * sin + cos * cos) 10
00:53:04 <lambdabot>   1.0
00:53:05 <tensorpudding> blame IEEE754
00:53:05 <ibid> aah
00:53:10 <c_wraith> > (sin ^ 2 + cos ^ 2) 32 :: CReal
00:53:11 <ibid> that makes sense!
00:53:11 <lambdabot>   1.0
00:53:16 <mauke> > deriv (sin * sin + cos * cos) x
00:53:17 <lambdabot>   1 * cos x * sin x + sin x * (1 * cos x) + (1 * negate (sin x) * cos x + cos...
00:53:29 <Sgeo|web> :t deriv
00:53:30 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
00:53:34 <ibid> > (id + succ) x
00:53:35 <lambdabot>   x + succ x
00:53:43 <ibid> pointwise addition, okay
00:54:06 <ibid> > deriv (x^2)
00:54:07 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
00:54:07 <lambdabot>                        ...
00:54:12 <ibid> > deriv (x^2) x
00:54:13 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
00:54:13 <lambdabot>                        ...
00:54:18 <mauke> ibid: x^2 isn't a function
00:54:20 <Sgeo|web> > deriv (x ** 2)
00:54:20 <wavewave> deriv (^2)
00:54:21 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
00:54:21 <lambdabot>                        ...
00:54:22 <ibid> > deriv (\x -> x^2) x
00:54:23 <lambdabot>   1 * x + x * 1
00:54:35 <wavewave> > deriv (^2) x
00:54:35 <lambdabot>   1 * x + x * 1
00:54:36 <Sgeo|web> Is it ** or ^?
00:54:39 <mauke> Sgeo|web: yes
00:54:43 <ibid> Sgeo|web: depends on what you mean
00:54:48 <c_wraith> :t (**)
00:54:48 <wavewave> :t **
00:54:49 <lambdabot> forall a. (Floating a) => a -> a -> a
00:54:49 <Sgeo|web> :t (**)
00:54:49 <lambdabot> parse error on input `**'
00:54:50 <lambdabot> forall a. (Floating a) => a -> a -> a
00:54:53 <c_wraith> :t (^)
00:54:54 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
00:55:09 <Sgeo|web> > deriv (**2) x
00:55:10 <lambdabot>   1 * recip x * 2 * exp (log x * 2)
00:55:19 <Sgeo|web> ...o...kay...
00:55:31 <ibid> mauke: shame.  it *could* abstract the only letter you know :)
00:55:50 <mauke> ibid: you can use 'id' instead :-)
00:55:54 <c_wraith> ibid: deriv is unrelated to the Expr stuff, which is what defines x
00:56:12 <mauke> > deriv (id^2) x
00:56:13 <lambdabot>   1 * x + x * 1
00:56:23 <Sgeo|web> > deriv id x
00:56:24 <lambdabot>   1
00:56:34 <mauke> > deriv (2*ask+1) x
00:56:35 <lambdabot>   2 * 1
00:56:39 <Sgeo|web> ask?
00:56:39 <ibid> c_wraith: shame, as i said :)
00:56:45 <wavewave> :t ask
00:56:46 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
00:56:47 <Sgeo|web> Is this thing suddenly running in Reader?
00:56:57 <mauke> Sgeo|web: everything is
00:57:02 <wavewave> r ->
00:57:04 <mauke> ask = id
00:57:22 <wavewave> instance Reader (r->)
00:57:25 <mauke> > ask "answer"
00:57:26 <lambdabot>   "answer"
00:57:37 <ibid> > ask "for a raise"
00:57:37 <lambdabot>   "for a raise"
00:57:40 <ibid> boo :)
00:57:49 <mauke> > fix error
00:57:50 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
00:58:00 <ibid> :-P
00:58:04 * Sgeo|web doesn't quite grok fix
00:58:10 <Sgeo|web> > fix (+0)
00:58:15 <lambdabot>   mueval-core: Time limit exceeded
00:58:22 <Sgeo|web> > fix (+2)
00:58:26 <lambdabot>   mueval-core: Time limit exceeded
00:58:27 <c_wraith> don't worry about fix just yet. :)
00:58:29 <mauke> Sgeo|web: all of those will be bottom
00:58:42 <wavewave> fix (1:)
00:58:44 <ibid> don't fix what's not broken :-)
00:58:48 <wavewave> > fix (1:)
00:58:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:58:55 <mauke> Sgeo|web: you can think of a function as a box with an input and an output
00:59:04 <Sgeo|web> Please don't assume I'm a complete abject beginner?
00:59:11 <c_wraith> fix f = f (fix f)
00:59:22 <mauke> Sgeo|web: a value comes in, is transformed by the function, and sent on to the output
00:59:24 <wavewave> Sgeo|web : the result  depends on strictness of your function.
00:59:34 <mauke> Sgeo|web: fix takes such a box and extracts a value from it
00:59:50 <ibid> > let f _ 0 = 1 ; f me n = n * me (n-1) in fix f 5
00:59:50 <mauke> Sgeo|web: it does this by sending the result back in time and using it as the input
00:59:50 <lambdabot>   120
00:59:51 <c_wraith> anyway, fix is mostly only of interest because it's an abstraction of named recursion
00:59:57 <wavewave> Sgeo|web: difference btwn fix (+0) and fix (1:)
01:00:06 <mauke> it's a stable time loop
01:00:10 <DanBurton> >fix unsafePerformIO
01:00:15 <DanBurton> doh
01:00:17 <Sgeo|web> DanBurton: wrong types
01:00:21 <Sgeo|web> :t fix
01:00:22 <lambdabot> forall a. (a -> a) -> a
01:00:26 <DanBurton> but i want to fix it
01:00:31 <DanBurton> it's broken >.>
01:00:33 <Sgeo|web> :t unsafePerformIO
01:00:34 <lambdabot> Not in scope: `unsafePerformIO'
01:00:35 <Sgeo|web> Oh, pun
01:00:40 <ibid> > fix unsafePerformIO
01:00:40 <Sgeo|web> I should be used to puns
01:00:41 <lambdabot>   Not in scope: `unsafePerformIO'
01:00:41 <DanBurton> ;)
01:01:00 * frerich skims the Haskell base library documentation, finds 'Control.Category' and reads "A class for categories. id and (.) must form a monoid." *gulp*
01:01:03 <ibid> > fix me
01:01:04 <lambdabot>   Not in scope: `me'
01:01:16 <Sgeo|web> I know barely enough Haskell to make a bad pun that I've since repeated endlessly
01:01:22 <DanBurton> > let unsafePerformIO :: IO a -> a; unsafePerformIO = undefined in fix (unsafePerformIO . return)
01:01:23 <lambdabot>   *Exception: Prelude.undefined
01:01:28 <Sgeo|web> It's on the wiki
01:01:35 <mauke> frerich: oh, good, that's easy. monoids are like the simplest thing ever
01:01:55 <Sgeo|web> Isn't that just stuff with mplus and mzero?
01:02:01 <mauke> Sgeo|web: no, mempty/mappend
01:02:16 <ibid> almost everything is a monoid
01:02:18 <DanBurton> mplus/mzero is for MonadPlus I believe
01:02:21 <mauke> or "an associative binary operation with a neutral element"
01:02:24 <Sgeo|web> ....what's mplus and mzero... I was thinking distinctly of mempty and mappent when I thought those
01:02:24 <ibid> many things are many monoids
01:02:29 <Sgeo|web> mappend
01:02:33 <DanBurton> :t mplus
01:02:34 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
01:02:38 <DanBurton> :t mzero
01:02:39 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
01:02:45 <DanBurton> there you have it, MonadPlus
01:02:48 <Sgeo|web> :t guard
01:02:49 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
01:02:56 <mauke> @src guard
01:02:56 <lambdabot> guard True  =  return ()
01:02:56 <lambdabot> guard False =  mzero
01:03:02 <ibid> monoids are also what one learns almost first thing in a university-level algebra course
01:03:17 <mauke> I think we did groups first, actually
01:03:25 <ibid> weird
01:03:30 <DanBurton> *sigh*, do I have to go to bed?
01:03:49 <DanBurton> I always hate that part of the night
01:03:56 <Sgeo|web> I have to be up to go to school in 3 hours
01:03:57 <Sgeo|web> :/
01:04:01 <ibid> DanBurton: it's sunrise somewhere :)
01:04:17 <wavewave> me too....
01:04:31 * ibid should be doing work right now, instead of having fun here
01:04:35 <wavewave> have to take airplane int he morning.
01:04:45 <Sgeo|web> Got into an argument (after class) with my professor on Monday
01:04:59 <DanBurton> about what?
01:05:15 <Sgeo|web> I was saying that for computers with finite memory, you can in fact determine whether or not a program will ever halt
01:05:28 <Sgeo|web> He was assuming that halting problem could also apply with finite memory
01:05:40 <ibid> some professor
01:05:41 <int-e> Sgeo|web: theoretically or practically?
01:06:09 <Sgeo|web> int-e: I assumed we were talking theoretically
01:06:10 <mauke> practically all programs halt
01:06:10 <flux> practically. say, you have a machine with one bit of memory :P
01:06:21 <int-e> (although on practical implementations one could argue that all programs halt anyway.)
01:06:23 <c_wraith> with finite memory, it's a finite state machine.  with a *huge* amount of time, you can run it until it halts or cycles.
01:06:33 <Sgeo|web> c_wraith: I know this
01:06:39 <mauke> no program will run more than 10^1000 years
01:06:42 <c_wraith> it's not a very interesting result. :)
01:07:01 <wavewave> mauke: who knows ;-P
01:07:08 <flux> "mauke's theorem"
01:07:10 <DanBurton> all programs that are not transferred mid-execution from one machine to another are guaranteed to halt
01:07:21 <mauke> preflex: quote mauke halting
01:07:22 <preflex>  <mauke> I've solved the halting problem WITH A SHOTGUN
01:07:34 <Sgeo|web> preflex: quote sgeo
01:07:34 <preflex>  no quotes found for sgeo
01:07:39 <Sgeo|web> preflex: quote goldilocks
01:07:39 <ddarius> What kind of shotgun?
01:07:39 <preflex>  no quotes found for goldilocks
01:07:40 <wavewave> oh.. you guys don't know that we are in matrix yet?
01:07:56 <Sgeo|web> There goes my ego
01:08:06 <ibid> no, we aren't yet in matrix.  that i know :)
01:08:06 <dalaing_home> that'll stop all of those unsafePerformIO jokes with lambdabot
01:08:16 <DanBurton> preflex: quote HaskellCurry
01:08:16 <preflex>  no quotes found for HaskellCurry
01:08:19 <mauke> preflex: quote
01:08:20 <DanBurton> aw
01:08:27 <preflex>  <cos> why would [software] be doing it in such a complicated way if it were [simple]?
01:08:36 <mauke> preflex: that quote sucked
01:08:48 <mauke> preflex: quote
01:08:50 <preflex>  <twey> You use emacs too much when: you try to launch gimp -nw
01:08:57 <DanBurton> lol
01:09:09 <ddarius> preflex quote that sucked
01:09:10 <preflex>  no quotes found for that
01:09:29 <DanBurton> @quote Church
01:09:30 <lambdabot> lennart says: alonzo is our church
01:09:38 <Sgeo|web> Do pastes on hpaste expire?
01:09:41 <DanBurton> yawn
01:09:47 <DanBurton> I think  so
01:09:49 <Sgeo|web> @quote Goldilocks
01:09:50 <lambdabot> No quotes match. You speak an infinite deal of nothing
01:09:54 <Sgeo|web> @quote Sgeo
01:09:54 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
01:10:05 <ibid> lambdabot is its charming self
01:10:05 <DanBurton> @botsmack
01:10:06 <lambdabot> :)
01:10:08 <mauke> preflex: quote
01:10:10 <preflex>  <vixey> debugging code is admitting defeat
01:10:49 <DanBurton> it's quote wars. lambdabot vs preflex
01:11:35 <DanBurton> @quote burrito
01:11:35 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
01:11:42 <ibid> are the quote databases online somewhere?
01:11:57 <DanBurton> no clue
01:12:15 <DanBurton> I know you can tell lambdabot to remember quotes, not sure how preflex works.
01:12:29 <mauke> preflex: help remember
01:12:30 <preflex>  remember NAME QUOTE - associate QUOTE with NAME
01:12:45 <DanBurton> what exactly is preflex, anyways?
01:12:48 <Sgeo|web> I think I saw links on the HUmor page
01:12:57 <Sgeo|web> Which I was looking at because I'm vain
01:13:22 <DanBurton> preflex: help
01:13:22 <preflex>  try 'help help' or see 'list' for available commands
01:13:29 <DanBurton> preflex: list
01:13:29 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
01:13:30 <preflex>  ZCode: [zdec, zenc]
01:14:38 <wavewave> anyone knows about codo notation?
01:15:10 <DanBurton> @google codo notation
01:15:11 <lambdabot> https://github.com/dorchard/codo-notation
01:15:13 <int-e> c_wraith: damn. now I wonder whether I can prove that one needs twice as much memory (plus some extra registers that can hold an address and a couple of extra bits) to decide whether we run into a cycle or not. (using twice as much memory, you can just run a computer with n bits of state for 2^n steps - if it hasn't halted by then, it never will)
01:16:05 * Sgeo|web might show this log to his professor >.>
01:17:06 <wavewave> use quantum computer
01:20:11 <Sgeo|web> I think I like Haskell's type system more than I like duck typing, where it seems like there needs to be an assumption that a method, say ".show" will have similar semantics on objects written by different authors
01:20:31 <wavewave> duck typing sucks
01:21:42 <int-e> Sgeo|web: Haskell has a bit of the same problem, of course. For example there's some disagreement on whether 'show' should produce output that Haskell can parse or not.
01:21:46 <mux> duck typing should be named optimistic typing
01:22:50 <int-e> (ultimately types say very little about semantics, toy examples and @djinn notwithstanding.)
01:24:59 <wavewave> In my opinion, I don't think show should produce only output that Haskell can parse
01:25:50 <wavewave> such implicit rule will always be broken.
01:28:39 <absence> is there a more elegant way to express this with repa, or is that the right/prefered way (given getZ)? fromFunction (Z :. 512 :. 512 :. 512) \(Z :. y :. x :. z) -> fromList (Z :. 512) (getZ x y) ! (Z :. z)
01:39:28 <Sgeo|web> What's the point of a monad transformer like MaybeT if I can just write Maybe (IO ())?
01:39:34 <Sgeo|web> Or whatever?
01:39:50 <ibid> they do different things
01:40:19 <mauke> did you mean: IO (Maybe ())
01:40:27 <quicksilver> well, MaybeT is actually IO(Maybe())
01:40:36 <quicksilver> but the answer to your question is - they make >> do something cleverer
01:40:50 <quicksilver> if you use IO(Maybe()) by hand, you have to handle the Just/Nothing logic by hand
01:41:01 <quicksilver> if you use MaybeT you get the right Just/Nothing logic automatically.
01:41:15 <Sgeo|web> I should probably get some sleep then look at ... something
01:41:42 <mauke> who wants to see me give a rock to a fish?
02:02:35 <o-_-o1> http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial in this section 2.3.2.1
02:03:17 <o-_-o1> Does the program really give 500000500000 as the answer for someone else on here ?
02:03:57 <o-_-o1> I get this as the answer 1784293664
02:04:21 <quicksilver> > 500000500000 > 2^32
02:04:22 <lambdabot>   True
02:04:29 <quicksilver> o-_-o1: I expect you're on a 32 bit machine
02:04:35 <quicksilver> > 500000500000 `mod` 2^32
02:04:36 <lambdabot>   1784293664
02:04:47 <o-_-o1> Ah...yes
02:04:49 <quicksilver> (or, at least, a 32 bit compilation of ghc)
02:04:59 <o-_-o1> Good catch :-)
02:05:19 <o-_-o1> Thanks.
02:06:28 <Sgeo|web> @src fix
02:06:28 <lambdabot> fix f = let x = f x in x
02:07:35 <Sgeo|web> fix (1:) = let x = 1:x in x
02:07:45 <Sgeo|web> That... makes a little more sense now. Kind of
02:08:01 <o-_-o1> I am having trouble understanding that program.
02:08:26 <o-_-o1> step returns Maybe (a,b)
02:08:56 <o-_-o1> unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
02:11:20 <o-_-o1> unfoldr takes step as an argument and parse passes IO ByteString to step. But where is the recursive call to step ?
02:11:48 <o-_-o1> How does step go to the next element in the ByteString ?
02:12:03 <o-_-o1> Shouldn't parse be recursive ?
02:13:21 <quicksilver> unfoldr calls its first argument many times
02:13:22 <o-_-o1> Ah...so does sum call parse recursively until it gets a Nothing ?
02:13:50 <quicksilver> so the recursion is inside the definition of unfoldr
02:13:56 <o-_-o1> ah...ok
02:14:09 <o-_-o1> Got it. That was what I was missing.
02:14:44 <quicksilver> > unfoldr (\x -> Just (1,x)) ()
02:14:44 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:14:57 <quicksilver> o-_-o1: ^^ really simple use of unfoldr which always produces 1s.
02:15:12 <quicksilver> of course, the Vector unfoldr is a special optimised version
02:15:19 <quicksilver> but *semantically* it's the same (as far as I know)
02:15:26 <o-_-o1> Ok.
02:15:57 <o-_-o1> unfoldr keeps calling it's argument function until it gets a Nothing ?
02:16:02 <quicksilver> the idea is the step "knows when to stop" (by returning nothing) and "knows how to produce more stuff" (on the left of the pair) and "keeps an internal state" (in the right of the pair)
02:16:06 <quicksilver> yes.
02:16:26 <quicksilver> > unfoldr (\x -> Just (x,(x*2))) 1
02:16:27 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
02:16:33 <quicksilver> ^^ using unfoldr to make a doubling
02:16:44 <quicksilver> > unfoldr (\x -> Just (show x,(x*2))) 1
02:16:45 <lambdabot>   ["1","2","4","8","16","32","64","128","256","512","1024","2048","4096","819...
02:17:29 <ion> > unfoldr (Just . (show &&& (*2)) 1
02:17:29 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
02:17:36 <ion> > unfoldr (Just . (show &&& (*2))) 1
02:17:37 <lambdabot>   ["1","2","4","8","16","32","64","128","256","512","1024","2048","4096","819...
02:17:56 <o-_-o1> Ah...
02:18:33 <quicksilver> o-_-o1: so, the first doubling example keeps an integer "internal state" and produces exactly that each step
02:18:45 <quicksilver> the second example still kept an int as an internal state but chose to produce a string version each step
02:18:59 <quicksilver> none of my examples ever produce Nothing so they never stop
02:19:14 <o-_-o1> quicksilver: yes...
02:19:15 <quicksilver> > unfoldr (\x -> if x > 1000 then Nothing else Just (show x,(x*2))) 1
02:19:16 <lambdabot>   ["1","2","4","8","16","32","64","128","256","512"]
02:19:19 <quicksilver> ^^ that one stops.
02:19:44 <quicksilver> > unfoldr (\x -> guard(x < 1000) >> return (show x,(x*2))) 1
02:19:45 <lambdabot>   ["1","2","4","8","16","32","64","128","256","512"]
02:19:46 <ion> > unfoldr (\x -> (show x, x*2) <$ guard (x <= 1000)) 1
02:19:47 <lambdabot>   ["1","2","4","8","16","32","64","128","256","512"]
02:19:59 <quicksilver> ^^ funky way of writing it using the MonadPlus instance for Maybe
02:20:15 <quicksilver> ion-- # trying to hijack my pedagogy and being too slow :P
02:21:24 <o-_-o1> Heh
02:22:25 <Ikarus> did something change in the definition of rem between haskell versions ?
02:22:53 <o-_-o1> ah...this is great
02:23:06 <o-_-o1> Thank you quicksolver.
02:23:14 <o-_-o1> quicksilver*
02:23:40 <osfameron> "quicksolver"++
02:24:53 <o-_-o1> I can use a take <num> and get a finite list too
02:26:37 <Sgeo|web> > fix $ \f x -> if x == 0 then 1 else f (x - 1)
02:26:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> t)
02:26:39 <lambdabot>    arising from a use of `...
02:26:44 <Sgeo|web> > fix $ \f x -> if x == 0 then 1 else f (x - 1) $ 3
02:26:45 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
02:26:50 <Sgeo|web> oops
02:26:56 <Sgeo|web> > fix $ (\f x -> if x == 0 then 1 else f (x - 1)) $ 3
02:27:00 <lambdabot>   mueval-core: Time limit exceeded
02:27:20 <Sgeo|web> > fix (\f x -> if x == 0 then 1 else f (x - 1)) $ 3
02:27:20 <lambdabot>   1
02:27:44 <Sgeo|web> > fix (\f x -> if x == 0 then 1 else x * f (x - 1)) $ 3
02:27:45 <lambdabot>   6
02:28:03 <Sgeo|web> I... actually kind of understand that
02:28:06 <Sgeo|web> Well, the usage of fix
02:28:06 <Ikarus> one version of haskell appaerently accepts rem with integers as arguments just fine, while another (7.0.4) complains with "No instance for (Integral [Integer]) arising from a use of `rem'"
02:28:09 <Sgeo|web> Not why it works there
02:29:05 <mauke> Ikarus: there are only two "versions" of haskell, 98 and 2010
02:29:14 <ion> > let f x = if x == 0 then 1 else x * f (x - 1) in f 3  -- the same thing
02:29:15 <lambdabot>   6
02:29:20 <mauke> Ikarus: and you're trying to use rem with lists
02:30:01 <ion> @src fix
02:30:02 <lambdabot> fix f = let x = f x in x
02:30:30 <Ikarus> mauke: well, the real wtf is that this same code ran fine on another version of ghc
02:30:38 <ion> > let foo = (\f x -> if x == 0 then 1 else x * f (x - 1)) foo in foo 3
02:30:38 <Ikarus> I guess I'll have to go figure out wtf
02:30:39 <lambdabot>   6
03:26:10 * hackagebot cabal-file-th 0.1 - Template Haskell expressions for reading fields from a project's cabal file.  http://hackage.haskell.org/package/cabal-file-th-0.1 (NickPartridge)
04:21:10 * hackagebot yap 0.1 - yet another prelude - a simplistic refactoring with algebraic  classes  http://hackage.haskell.org/package/yap-0.1 (RossPaterson)
04:23:37 <Alex_Haskell> hello
04:24:21 <Eduard_Munteanu> Alex_Haskell: hi
04:24:47 <Alex_Haskell> roman?
04:24:50 <Alex_Haskell> da
04:25:29 <Eduard_Munteanu> Alex_Haskell: oh, yeah.
04:26:00 <Alex_Haskell> de unde ... cum ... ai auzit de haskell?
04:26:13 <Eduard_Munteanu> Mm, let's talk English in here.
04:26:46 <Eduard_Munteanu> Well, I read about Haskell on somebody's blog, then I looked it up.
04:27:05 <Alex_Haskell> what's wrong with our language ... :))
04:27:30 <Eduard_Munteanu> Oh, nothing, but other people can't understand it :)
04:28:10 <Alex_Haskell> have you worked at some projects with this language?
04:29:30 <Eduard_Munteanu> A bit... school stuff (even though we don't learn Haskell in our faculty's dept.), various small things etc.
04:30:00 <Eduard_Munteanu> I don't have any useful, public Haskell project if that's what you're asking.
04:30:20 <Alex_Haskell> i am a student too
04:30:28 <Alex_Haskell> and i'll make my license in haskell
04:30:32 <Eduard_Munteanu> Do you learn Haskell at school?
04:30:33 <Eduard_Munteanu> Oh.
04:30:37 <Eduard_Munteanu> Where is that?
04:30:46 <Alex_Haskell> University
04:30:51 <Alex_Haskell> not school
04:30:54 <Alex_Haskell> :))
04:31:07 <Eduard_Munteanu> Sure.
04:31:17 <Eduard_Munteanu> I meant which university.
04:31:21 <Alex_Haskell> bacau
04:31:28 <Eduard_Munteanu> Ah, makes sense.
04:31:33 <Alex_Haskell> my teacher is Dan Popa
04:31:58 <Eduard_Munteanu> I wanted to do something like that but couldn't find an advisor.
04:32:26 <Rille> ooh hi there
04:32:30 <Alex_Haskell> well parsers monads
04:32:54 <Eduard_Munteanu> And anyway, I was at Automatica, UPB.
04:34:29 <Eduard_Munteanu> Rille: hi
04:36:03 <Eduard_Munteanu> Alex_Haskell: interesting. There are a few people in here working on Haskell parsers.
04:36:33 <Eduard_Munteanu> So you can ask for help in case you need it.
04:36:36 <cvic_> da, mai sunt romania amaotri de Haskell. Hehe
04:36:44 <Eduard_Munteanu> :)
04:36:50 <cvic_> *romani **amatori
04:36:51 <cvic_> Ok, back to English
04:37:15 <cvic_> Dan Popa... I have both of his books on my desk.
04:37:29 <cvic_> "Practica Interpretarii Monadice" is awesome
04:37:31 <Eduard_Munteanu> I haven't seen many around here.
04:37:49 <cvic_> We keep a low-profile
04:40:34 <cvic_> Noticed that most of them are at/finished UPB
04:40:54 <cvic_> I'm an exception
04:40:59 <Eduard_Munteanu> Hm, I only know one other from UPB.
04:41:10 <cvic_> mmaruseac
04:41:14 <Eduard_Munteanu> Yeah.
04:41:27 <cvic_> Yep, I know him know. Read his blog
04:42:49 <cvic_> And talked by email with Dan Popa awhile ago
04:52:19 <adimit> Question: I want a fixed-sized data map from bytestring (or text) to int. I *only* care about lookup performance. What should I use?
04:52:48 <Botje> hash table with perfect hashing.
04:53:29 <adimit> Botje: thanks :-) â€” what module would you recommend? (there's like 20 different ones on hackage)
04:53:42 <Botje> that I don't know :(
04:54:08 <kalven> cull the ones that are at version 0.0.1
04:54:19 <adimit> ah, damn. That was actually what I wanted to know :-P maybe unordered-containers again. tibbe makes good stuff.
04:55:28 <adimit> damn, no, unordered-containers is a patricia-tree. i'm sure a hashtable would get better lookup performance.
05:07:15 <HaudRex> Does this structure exist in the libraries: data Foo a = a | Foo a
05:07:42 <dafis> HaudRex: Can't, needs a constructor in the first
05:07:50 <HaudRex> yeah, sorry
05:08:08 <HaudRex> Does this structure exist in the libraries: data Foo a = Return a | Foo a
05:08:39 <HaudRex> data Foo a = Return a | More (Foo a)
05:08:42 <HaudRex> whew
05:08:49 <HaudRex> there. That.
05:09:00 <Axman6> what is the point of it?
05:09:17 <Axman6> it doesn't seem like it's very useful
05:09:43 <HaudRex> it's not very useful on its own
05:10:22 <dafis> HaudRex: what is it you want to achieve with it?
05:10:26 <Axman6> it seems to be basically equivalent to Peano numbers
05:11:12 <HaudRex> I want to add structure to state, as in: StateT Foo s a
05:12:17 <sipa> HaudRex: it's called []
05:12:18 <Axman6> how is it useful? i'm really struggling to see it having any use that isn't equivalent to (Integer, a)
05:12:23 <sipa> you just described a list
05:12:36 <Axman6> sipa: not really, it only contains one element
05:12:46 <sipa> oh, right, indeed
05:12:59 <Axman6> and it's just nested to some depth
05:13:00 <HaudRex> right, it's one element at some depth in *another* monad
05:13:26 <HaudRex> I only want it in order to transform it
05:13:28 <Axman6> well, you haven't stated that
05:13:49 <Axman6> do you maybe mean data Foo m a = Return a | More (m (Foo a))?
05:14:03 <Axman6>  data Foo m a = Return a | More (m (Foo m a)) even
05:16:11 * hackagebot carettah 0.0.3 - A presentation tool writtten with Haskell.  http://hackage.haskell.org/package/carettah-0.0.3 (KiwamuOkabe)
05:21:11 * hackagebot carettah 0.0.4 - A presentation tool writtten with Haskell.  http://hackage.haskell.org/package/carettah-0.0.4 (KiwamuOkabe)
05:23:47 <Botje> rapid software development at work.
05:29:59 <khs> What packages do people use to work with JSON? Are any better than others?
05:31:00 <Axman6> aeson is pretty common for parsing
05:32:10 <khs> I only need to pretty print a structure
05:33:09 <khs> to JSON...
05:33:31 <Axman6> well, see what it uses for its representation
05:34:59 <zomg> khs: Text.JSON is okay
05:35:16 <zomg> Look up "haskell json" or something in google and you'll even find a few articles describing how to use it
05:44:42 <mike-burns> There are quite a few JSON packages, all of which are less convenient than doing it in Ruby/Python/Perl/JavaScript.
05:46:43 <Cale> oh?
05:46:51 <Cale> Some of them seem pretty reasonable
05:46:58 <helmut> hi. i got an exercise to write reverse with foldr. while i do see how to write it with foldl and how to write it directly without ++, i fail to see a way with foldr. can you give me a hint without disclosing the full solution?
05:47:26 <Cale> helmut: You can actually write foldl using foldr too
05:47:47 <Cale> (but not the reverse)
05:47:57 <Cale> Er, dang words ;)
05:48:06 <Cale> I mean, you can't really write foldr using foldl
05:48:07 <helmut> Cale: uhh. right. i should have tried that earlier. :-(
05:48:25 <Cale> and thus write reverse in terms of that
05:54:12 <Baughn> > 1 : 1
05:54:13 <lambdabot>   No instance for (GHC.Num.Num [t])
05:54:16 <lambdabot>    arising from a use of `e_111' at <inte...
05:54:17 * Baughn pokes lambdabot with a stick
05:56:41 <Cale> Baughn: ???
05:57:05 <Baughn> Trying to check if lambdabot was still working.
05:57:10 <Cale> Baughn: ah
05:57:18 <Baughn> Which.. well, roughly two minutes delay
05:57:18 <Cale> helmut: another way to think about it...
05:57:37 * Baughn keeps confusing Cale with Colm
05:58:58 <Cale> helmut: You can replace lists of type [a] throughout a program with functions [a] -> [a] which add elements to the beginning of a list. The empty list becomes id, the one element list [x] becomes (x:), and concatenation becomes composition (.)
05:59:43 <Cale> helmut: This trick gives the advantage of having really efficient concatenation because (++) is linear time in the length of its first parameter, while composition is constant time.
06:00:02 <b_jonas> Cale: that's what everyone says, but I don't believe it's so simple
06:00:08 <Cale> helmut: You then apply the resulting function to the empty list to get back something which gives you a normal list
06:00:10 <Cale> b_jonas: oh?
06:00:14 <b_jonas> if you concat the empty list many times, it can build up
06:00:22 <b_jonas> even though it's still empy
06:00:26 <Cale> ?
06:00:57 <Cale> xs ++ ys takes O(length xs) steps to reduce
06:00:59 <b_jonas> you'll have a function that represents the empty list but actually takes a lot of time to execute
06:01:24 <Cale> Nobody said that arbitrarily many compositions take constant time to evaluate
06:01:34 <Cale> You take a constant cost for each one
06:01:36 <b_jonas> sure
06:02:43 <Cale> So, it'll be linear in the number of compositions you do, instead of having a quadratic worst case, which is a pretty decent improvement :)
06:03:04 <b_jonas> it won't be linear
06:03:14 <Cale> sure it will
06:03:16 <b_jonas> I mean, if you first compute a = id . id . id . ... . id
06:03:25 <b_jonas> then you apply this to lots of different stuff
06:03:37 <Cale> a will be evaluated at most once
06:03:43 <Cale> and it will evaluate to id
06:04:05 <Cale> = linear cost in number of compositions, once
06:04:43 <Cale> and thereafter, it will be free
06:05:12 <b_jonas> but then you consider you make b1 = a . [1]; b2 = a . [2]; ...
06:05:30 <dmwit> Cale: That's pretty magical, if true.
06:05:39 <b_jonas> and finally attempt to print each bn for which you have to apply them to [] to get a list
06:06:02 <b_jonas> that needs to take a lot of computation even though you actually have short lists only
06:06:05 <dmwit> Testing in ghci seems to indicate it's true, too, which blows me away.
06:06:16 <Saizan> the magic of CAFs :)
06:06:18 <b_jonas> you'd have been better using ordinary lists in this case
06:06:25 <Cale> b_jonas: why?
06:06:32 <dmwit> Or... not quite true.
06:06:39 <dmwit> The second invocation of a is faster, but not instant.
06:07:02 <Saizan> b_jonas: if you need to look at all the intermediates it might not be an improvement to use this, but that's not the common case
06:08:04 <int-e> Cale: it doesn't work that way -- foldl' (+) 0 $ map (iterate (id .) id !! 1000) [1..10000]  has a runtime very sensitive on the first !!.
06:08:28 <dmwit> Yeah. a doesn't get evaluated only once.
06:08:31 <dmwit> This was a faulty claim.
06:09:00 <int-e> Well in a sense it probably does. But the result is still a chain of partial applications.
06:09:24 <dmwit> Well, the real claim was that it evaluated to id.
06:09:28 <dmwit> Which is not true.
06:09:35 <RaptorRarr> @type iterate (id .) id !! 1000
06:09:36 <lambdabot> forall a. a -> a
06:09:39 <Cale> Oh, yeah, I guess it gets evaluated only once, but evaluates to something which is performance-wise not identical to id :)
06:09:51 <RaptorRarr> @type (iterate (id .) id !! 1000) "zomg"
06:09:52 <lambdabot> [Char]
06:09:58 <Cale> But it will be a lambda term
06:10:00 <int-e> True. Semantically it's id, of course.
06:10:25 <Saizan> i guess it depends on how you define (.)
06:10:45 <b_jonas> On the other hand, if you treat the empty list specially, then I think using this kind of append functions (or binary trees you flatten to a list, whichever you prefer) is okay
06:10:55 <RaptorRarr> @type (id .)
06:10:56 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
06:11:09 <Cale> *anyway* this is all beside the point of what I was trying to explain
06:11:31 <int-e> Saizan: true, if you can somehow teach the compiler that (id .) is id, then you win.
06:11:38 <Cale> which is that this way of thinking about functions on lists as a representation for lists is a good way of thinking about how to write reverse using foldr
06:11:56 <b_jonas> int-e: no, not yet, you also have to teach that (. id) is id, and also that ([] ++) is id
06:12:12 * dmwit notes that at -O2, the second invocation of foldr (.) id (replicate 10000000000 id) is as near instant as doesn't matter.
06:12:17 <int-e> b_jonas: Sorry, talking about my own example.
06:12:28 <b_jonas> and all this recursively, and not only to the compiler but to the runtime
06:12:54 <b_jonas> Cale: I see
06:12:59 <Cale> helmut: The function which we pass to foldr should take a list element, and the function representation for the reverse of xs, and turn it into a function representation for the reverse of x:xs
06:13:12 <dmwit> Yeah, to really take advantage of (id .) = id, you'd need to be able to do function equality to notice that some dlist you handed it was actually (id .). =)
06:13:26 <Cale> which can be obtained by composing that function with (x:)
06:13:40 <Cale> > foldr (\x xs -> xs . (x:)) id [1,2,3,4,5] []
06:13:42 <lambdabot>   [5,4,3,2,1]
06:13:50 <helmut> Cale: wait a bit. i'm not that fast. ;-)
06:14:20 <Cale> Well, there's an intermediate step or two we can throw in...
06:14:25 <Cale> First, the naive reverse:
06:14:29 <Cale> reverse [] = []
06:14:37 <Cale> reverse (x:xs) = reverse xs ++ [x]
06:15:23 <quicksilver> dmwit: actually I've spent quite a while idly pondering about the cost of 'functional programming' in the specific sense of building up complex functions which you apply later
06:15:36 <quicksilver> dmwit: I think it's not very obvious or transparent, if you want precise answers
06:15:37 <Cale> We can translate this into something which produces a function which will add elements to the beginning of a list instead, (incidentally speeding it up)
06:15:43 <Cale> reverse [] = id
06:15:49 <int-e> dmwit: funny. I would expect that to run out of memory.
06:15:52 <Cale> reverse (x:xs) = reverse xs . (x:)
06:16:09 <Cale> from which we can recover the real reverse function by applying the result to an empty list at the end
06:16:10 <int-e> dmwit: the foldr (.) id  (replicate 10000000000 id)  that is.
06:16:15 <Cale> yeah?
06:16:31 <Cale> But this thing is now naturally also in the shape to write it with foldr
06:16:32 <int-e> (unless used only once)
06:16:35 <b_jonas> quicksilver: instead of all these building up functions, you can use a binary tree data type with the list elements in the leaves to represent a list. It's equivalent but might be clearer.
06:17:05 <dmwit> int-e: Well, I think the list gets garbage collected. It's not needed after it's converted into a functional "spine", so to speak.
06:17:54 <dmwit> quicksilver: Does "thinking" mean like you're doing research in the area?
06:18:09 <dmwit> quicksilver: I've also thought about it (though probably more idly than you), and mostly just confused myself. =P
06:18:35 <dmwit> Oh, yes, "idly pondering". So probably not research.
06:18:47 <dmwit> But yeah, it's hard for me to understand exactly what is possible and what isn't.
06:20:08 <quicksilver> b_jonas: yes, and if you have a data realisztion of it then the runtime can cache evaluated portions as thunks
06:20:11 <int-e> dmwit: but the spine itself should consume memory. there's something going on that I don't understand.
06:20:24 <quicksilver> b_jonas: which can be shared between different expressions with common bits
06:20:45 <quicksilver> dmwit: just thinking. It doesn't get mentioned in the haskell folklore much, is my observation
06:20:51 <dmwit> yeah
06:21:13 <quicksilver> dmwit: it's related to stream fusion breaking abstraction
06:21:26 <b_jonas> quicksilver: what about sharing?
06:21:38 <quicksilver> stream fusion is an optimisation which applies syntactically to certain expressions which occur in the (inlined) unfolding of your source code
06:21:42 <dmwit> int-e: The list is getting garbage-collected as it's traversed; the functional spine is also getting compressed as it's evaluated.
06:21:55 <quicksilver> it doesn't apply dynamically to expressions which might get created at runtime
06:22:17 <quicksilver> which means if you "abstract" a program which relies on fusion you can push yourself out a big-O
06:22:19 <Saizan> you could do it dynamically, but you'd lose sharing
06:22:21 <quicksilver> which is a shade.
06:22:25 <dmwit> wow
06:22:29 <quicksilver> shame.
06:22:58 <helmut> Cale: thanks for all your pointers. even though i ignored most of them. foldl f z l = foldr (\x y -> y . flip f x) id l z
06:23:15 <Saizan> you have to unstream to get something that can be shared, in fact the fusion applies only to chains where you don't reuse the intermediates elsewhere afaiu
06:23:22 <Cale> helmut: no problem :)
06:23:39 <Cale> helmut: (it sort of turned into a discussion with some of these other guys too in the middle)
06:23:51 <Saizan> but that's the same for foldr/build fusion, i think
06:24:12 <quicksilver> Saizan: well my comments apply to all static optimisations after all
06:24:28 <quicksilver> Saizan: my point is that static optimisations are syntax-directed, and syntax is not abstract.
06:24:32 <dumael> anyone got any advice for tracking down the cuas
06:24:36 <Cale> helmut: But yeah, I really recommend having a good look at and understanding that translation of a function operating on [a] to a function operating on [a] -> [a], because it's a really useful trick for speeding things up quite often.
06:24:36 <quicksilver> Which is, well, Duh. But it's a shortcoming.
06:24:49 <dumael> ^cause of "Prelude.chr: bad argument:" errors?
06:25:13 <benmachine> > chr (ord maxBound + 1)
06:25:14 <lambdabot>   *Exception: Prelude.chr: bad argument: 1114112
06:25:27 <int-e> dmwit: so it's fusion -- the function becomes an actual loop. with iterate (id .) id !! 10000000  I see the memory increase that I expected.
06:25:38 <ion> > succ maxBound :: Char
06:25:39 <lambdabot>   *Exception: Prelude.Enum.Char.succ: bad argument
06:25:51 <Cale> I used that trick in a real setting to turn a program which took a few hours to run (operating on ByteStrings, incidentally, rather than lists), into a program which ran in a handful of minutes :)
06:25:54 <helmut> Cale: it'll probably take some time to see its application in the wild...
06:25:54 <benmachine> > chr (-1)
06:25:55 <lambdabot>   *Exception: Prelude.chr: bad argument: (-1)
06:26:10 <benmachine> dumael: it's not terribly easy to do so, I'm afraid
06:26:10 <Cale> helmut: I've used it in the wild ;)
06:26:38 <dmwit> int-e: pretty cool =)
06:26:39 <Cale> (In our game's terrain generator)
06:26:49 <dmwit> int-e: (but a bit sad, because then it's not testing what I wanted it to test)
06:27:34 <dumael> benmachine: crud. ghc-events-show is spitting it at me. Events file is probably malformed.
06:27:40 <helmut> Cale: talking about hours of runtime... maybe i should reimplement my long substring finder in haskell and try to employ this. ;-)
06:27:47 <Cale> We were considering a bunch of other possible optimisations, but I blindly applied this one, and it sped things up enough that we could get back to working on other things :)
06:27:57 <benmachine> dumael: what number does it spit at you?
06:28:16 <int-e> dmwit: also sad because now that it's come all this way it really should realize that the function implements id ... (but of course, that's tricky to get right, and probably not of much use in non-toy code)
06:28:26 <dumael> benmachine: 4191215
06:28:31 <frerich> Cale: Out of curiousity, did you use some sort of refactoring tool to do this patch on your code base, or did you just go through the sources by hand and fix up all the type errors which the compiler complained about?
06:28:38 <Cale> (It was just the program for generating the terrain files that the game will use from the output of the terrain editor)
06:28:44 <benmachine> dumael: ah, so way too big, interesting
06:28:55 <Cale> frerich: Just did it by hand, the code in question wasn't so big
06:29:29 <dmwit> int-e: I couldn't get the second invocation of the function to take any amount of time with -O2, so maybe it really did observe that it actually was id.
06:29:41 <dmwit> (Without -O2, even a few less zeros was noticeably not id.)
06:29:53 <helmut> Cale: the task (that takes a stupid python program) hours is to find a strings that simultaneously are long and are substrigs in many of the given input strings. (e.g. for each length find strings that are contained in as many inputs as possible)
06:30:04 <benmachine> dumael: I can't really help with this now, there's other things I should be doing; if someone else is going to help you they might want to know what ghc-events-show is
06:30:53 <b_jonas> helmut: hmm, fun, does that require those tricky kinds of trees I never really understood?
06:31:15 <dumael> benmachine: it's the commandline variant of threadscope. dumps eventlog to text rather than displaying it graphically a la threadscope.
06:31:17 <Cale> helmut: Sounds like a job for a trie.
06:31:31 <helmut> b_jonas: probably. but for now i simply threw big amounts of cpu and memory on it. ;-)
06:31:32 <Cale> Though... there might be some structure even better than that.
06:31:58 <benmachine> dumael: oh, it's included in this http://hackage.haskell.org/package/ghc-events
06:33:32 <Cale> My first crude implementation would just be a Map.fromListWith (+) over a list containing all (contiguous?) substrings of each string.
06:33:46 <Cale> (with 1 attached to each)
06:34:38 <Cale> But yeah, that's expensive ;)
06:35:23 <Cale> Just because that list will be very long
06:37:31 <helmut> Cale: yes, contigous
06:38:07 <helmut> Cale: we are talking about about 1k strings of length varying from 0.2k to 200k
06:38:45 <Cale> Ah, yeah, this algorithm is particularly terrible if many of the strings are long like that :)
06:39:07 <helmut> Cale: in any case trying this is hopefully a good exercise.
06:39:13 <Cale> yeah
06:39:27 <helmut> i can report back if i get any success if you like
06:39:33 <Cale> sure :)
06:51:21 <kamaji> How do mutable arrays work?
06:51:27 <kamaji> I thought we weren't allowed mutable things
06:51:29 <kamaji> or do they use IO
06:51:34 <sipa> they use ST
06:51:36 <benmachine> IO or ST
06:52:10 <kamaji> question 2: regular arrays when modified are only partially copied, right?
06:52:49 <kamaji> or is that not true
06:53:13 <Axman6> the array is copied, the elements pointed to by the array are not
06:54:11 <Axman6> arrays aren't a particularly common thing to use in haskell btw
06:54:24 <kamaji> how do constant lookup?
06:54:54 <Axman6> there's no such thing, in any language
06:55:06 <kamaji> always that answer :P
06:55:07 <benmachine> Data.Map is sufficiently close to constant that the difference should be measured in profiling rather than theoretically
06:55:11 <benmachine> that's what I've heard
06:55:29 <Axman6> IntMap is even better
06:55:42 <quicksilver> kamaji: use Data.Map or Data.IntMap or Data.Sequence or Data.Array whichever has the most convenient API
06:55:45 <quicksilver> benchmark it.
06:55:56 <quicksilver> change if you need to. constant time access is a lie.
06:55:56 <Axman6> (and given it has bounded depth, it also has O(1) lookup >_>)
06:56:20 <kamaji> well it was going to be for a 233MB lookup table
06:56:41 <Axman6> what types are the keys and values?
06:56:47 <kamaji> ints and more ints
06:56:52 <quicksilver> then your main concern is probably to store it in memory as efficiently as possible
06:57:17 <kamaji> It would be interesting to see if the caching thing makes the map faster
06:57:18 <danmaftei> I have a type 'data NT = S | NP | VP' which derives Read. If I do 'read "XP" :: NT', an exception is thrown. I would like to catch this exception and print something more useful. Tips?
06:57:19 <Axman6> IntMap is probably the best place to start
06:57:33 <dafis> kamaji: consider using unboxed arrays, they are much more compact
06:57:43 <kamaji> What's underneath IntMap?
06:57:44 <Axman6> dafis: use reads
06:57:51 <kamaji> dafis: oh ok
06:57:52 <Axman6> :t reads
06:57:53 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:58:01 <dafis> Axman6: ??
06:58:05 <benmachine> I think IntMap is a trie?
06:58:13 <dafis> oh, completion fail
06:58:15 <Axman6> uh, danmaftei, not dafis
06:59:32 <dafis> kamaji: unboxed arrays are fine if you build it once and then perform a lot of lookups, insertion/deletion in those is however more costly than in an IntMap
06:59:52 <dafis> benmachine: Patricia tree
07:00:12 <kamaji> dafis: yeah, so unboxed for a lookup table seems logical
07:00:33 <kamaji> oh I was reading about those
07:02:13 <danmaftei> thanks for the reads tip, works great
07:03:37 <Bummi> hellu, i'm experimenting with some graphics for a super simple game I've done. I'm using a recursive function "gameLoop" though, how can I make the loop spit out labels of info in my GUI-window while looping recursively? How should I think?
07:08:40 <Cale> Bummi: It's a little hard to say without seeing exactly what you already have... How are you doing the rest of your GUI stuff already?
07:08:56 <geheimdienst> cale, the dude is gone
07:09:01 <Cale> oh
07:17:14 <SharkMonkey> I upgraded my OS and libffi5 became libffi6. Now my cabal update and xmonad don't work anymore with an error loading shared library libffi.so. How should I proceed from here?
07:17:56 <geheimdienst> SharkMonkey: as a first step, try "ghc-pkg check" and see if it reports broken packages
07:18:07 <benmachine> no I've seen this kidn of thing before
07:18:10 <kmc> kamaji, for a lookup table you might consider http://hackage.haskell.org/package/MemoTrie or http://hackage.haskell.org/package/data-memocombinators
07:18:13 <geheimdienst> (i guess it won't but can't hurt)
07:18:16 <adimit> Since it's quiet, I'll dare repeat an earlier question (maybe someone knows *now*:) I want an immutable string to int map with *good* lookup time (I only care about lookup.) I've heard bad things about Data.Hashtable, but I don't know if they're still valid. Is there anything of that sort on hackage?
07:18:22 <benmachine> I think you just have to reinstall your haskell-built executables
07:18:41 <kmc> adimit, http://hackage.haskell.org/package/unordered-containers
07:19:10 <adimit> kmc: isn't that a patricia tree (and thus it doesn't provide O(1) lookup?)
07:19:12 <SharkMonkey> geheimdienst, No output from that command.
07:19:18 <kmc> oh not this again
07:19:33 <ClaudiusMaximus> adimit: Data.Map is a good default choice, bytestring-trie might have better memory usage than Map but i found it to be slower in one test (which was mainly insertion/lookup)
07:20:00 <kmc> adimit, the height of the tree is bounded by the number of bits in a pointer, so it's just as "O(1)" as a flat hash table
07:20:07 <kmc> which is to say they're both lies
07:20:08 <SharkMonkey> benmachine, It looks like I can invoke the OS installed cabal.
07:20:15 <SharkMonkey> Should I just delete my .cabal directory?
07:20:16 <geheimdienst> i'd have to get out the checklist, but i believe we had the O(gunk) discussion this week already? please refrain from it until next monday
07:20:23 <SharkMonkey> Since everything has to be rebuilt
07:20:27 <adimit> ClaudiusMaximus: bytestring trie didn't have better performance than unordered-containers last time I tried though :-|
07:20:30 <benmachine> SharkMonkey: no, only executables need rebuilding
07:20:37 <kmc> it is physically impossible to access n bytes of memory with O(1) resources
07:20:41 <benmachine> *probably* you can delete .cabal/bin, but shrug
07:20:52 <adimit> kmc, sorry, I'm not super-knowledgeable on the exact mechanics of the different data structures.
07:21:23 <kmc> so that's the first point, it is O(1)
07:21:24 <adimit> sorry, didn't want to step on anybody's toes, I hadn't seen that discussion.
07:21:37 <kmc> the more important point is that O(1) versus O(log n) just doesn't matter
07:21:45 <kmc> that is, the theoretical result is irrelevant to real performance
07:21:48 <int-e> adimit: the problem in the case of the hashtable is that you have to compute a hash from the string.
07:22:07 <kmc> sometimes one or the other will be much faster
07:22:19 <quicksilver> and hash algorithms are at best O(length string) and length string is at a minimum O(log n).
07:22:36 <quicksilver> unless you can precompute hashes.
07:22:43 <kmc> adimit, the usual asymptotic analysis is based on a model of computers that hasn't been accurate for 40 years at least
07:22:57 <kamaji> disagreee
07:23:00 <geheimdienst> adimit: i'm just joking. the gist is, don't overrate what the O(something) says. O is a measure of academic interest that does not correspond to runtime reality very closely
07:23:10 <kamaji> I use an embedded chip that has no cache
07:23:11 <kmc> if you're worrying about the difference between 1 and log n < 100, then flaws in that model become highly relevant
07:23:16 <kamaji> just an SRAM
07:23:21 <kamaji> single cycle mem access
07:23:22 <adimit> kmc: thanks for the update then. It's what I got told in class, so I guess mea culpa for not checking back.
07:23:29 <kmc> if you're worrying about the difference between n and n^100, it's different
07:23:41 <kmc> adimit, yeah, this is a rant directed at the sorry state of CS education
07:23:42 <adimit> kmc: I'm worrying for n ~ 20000
07:23:50 <kmc> > log 20000
07:23:51 <lambdabot>   9.903487552536127
07:24:01 <Axman6> kmc: then your n will never be big enough for you to have to worry any way
07:24:07 <Axman6> uh, kamaji
07:24:24 <kamaji> was mostly kidding :P
07:24:39 <kmc> yeah i quite like microcontroller programming
07:25:05 <kamaji> kmc: http://www.xmos.com
07:25:07 <adimit> kmc: yeah, our datastructures class was pretty miserable, but i've rarely been in a situation where that matters (until now.)
07:25:12 <benmachine> geheimdienst: I think it depends. if your algorithm is exponential rather than polynomial, that's worth worrying about
07:25:15 <kamaji> kmc: it is soooo much fun
07:25:33 <kamaji> I'd quite like to see what haskell would be like on it
07:25:33 <kmc> adimit, also, the kinds of data structures you want to use in Haskell usually just aren't covered
07:25:43 <benmachine> geheimdienst: I like the rule where O(stuff) is useful until you're sub-linear, in which case it tends to be a secondary concern
07:25:50 <benmachine> I might have made that up though
07:25:51 <kamaji> but I think there wouldn't be a way to do it
07:26:18 <ClaudiusMaximus> one algorithm i wrote was something like O(a^(b^n))   never figured out the exact values of a>1 and b>1, but it was problematic for n > 50 or so.. managed to speed up some parts of it but it's still impractical for n > 200
07:26:31 <adimit> kmc: that's why I thought I'd ask #haskell, since I'm not very aware of the "state of the art" of hash map-like functional data structures
07:27:07 <benmachine> ClaudiusMaximus: that's still not as bad as factorial time, is it?
07:27:19 <Axman6> kamaji: there's some packages for producing realtime code for such devices (most notably the atom package)
07:27:24 * benmachine wrote a fully general matrix determinant algorithm once that was fully stupid
07:27:47 <kmc> it's a shame too because immutable data structures are way nicer for concurrent programming even in traditional imperative languages
07:27:49 <kamaji> Axman6: that looks awesome
07:28:23 <kmc> but your stdlib will usually provide containers which are only safe to use persistently with a full copy
07:29:30 <adimit> kmc: or in the case of Java, provide containers some of which are threadsafe, some of which aren't, and some of which claim to be, but really are not. I'm very frustrated with Java's threading model (one thing I found so awesome about Haskell.)
07:29:53 <kmc> *nod*
07:30:03 <kmc> in most languages concurrent programming is much harder than it needs to be
07:30:22 <geheimdienst> benmachine: yeah, O is not completely irrelevant, but i think it is overrated and encourages ridiculous superstitions. my former boss started this big discussion about how best to insert an element into an array of length 30-something. he told me i cannot arrogantly wave that off and just use the framework's method without careful analysis and whatnot. i told him that maybe he should first make the server guy do something about the server taking 40
07:30:36 <kmc> kamaji, ah, I've heard of this chip... do you have one?
07:30:39 <b_jonas> I need to learn some more of concurrent programming.
07:30:45 <benmachine> geheimdienst: your message got cut off after 40
07:30:49 <Axman6> kmc: but it's not concurrent programming if you don't need locks and mutexes!
07:30:54 <adimit> b_jonas: start with RWH's two chapters on that. they're great.
07:30:55 <geheimdienst> "40 seconds to resond"
07:30:59 <kamaji> kmc: I have two :D
07:30:59 <benmachine> oic
07:31:03 <kamaji> kmc: and my friend works there...
07:31:14 <kamaji> kmc: also two of my lecturers
07:31:18 <kmc> just like it's not sorting algorithms unless you implement them in MIX assembly
07:31:24 <kamaji> so I am massively biased
07:31:27 <kmc> kamaji, cool, what have you used them for?
07:31:37 <kamaji> DS controlled Roomb
07:31:39 <kamaji> roomba*
07:31:48 <kamaji> over wifi
07:31:52 <kmc> haha sweet
07:31:55 <kamaji> and ... flashing LEDs :P
07:32:10 <kmc> b_jonas, adimit, seconding the recommendation of RWH's chapters
07:32:35 <kmc> b_jonas, maybe you'd also like http://ugcs.net/~keegan/talks/first-class-concurrency/talk.pdf
07:32:38 <kmc> (self promotion!)
07:32:40 <kamaji> yeah it is a nice little chip, and I realllly like their concurrency model- it's all channel based
07:33:19 <b_jonas> kmc, adimit: thanks for the references
07:37:53 <adimit> the chapter on STM was a particular eye-opener. When I compared that to Javaâ€¦ I was always scared of threading, no I'm like "let's make it in a thread."
07:38:41 <adimit> *now.
07:38:57 <SharkMonkey> So is ghc defaulting to dynamically linking these days?
07:39:23 <SharkMonkey> Explaining whey I keep getting shared library errors
07:41:09 <kmc> SharkMonkey, i believe that dynamic linking to system C libs, static linking of Haskell code is still the default
07:41:18 <kmc> adimit, yeah
07:41:51 <kmc> part of the whole "unlearning old habits to learn Haskell" thing is unlearning the rule that one should avoid threads at all cost, no matter how ugly your code becomes
07:42:03 <kmc> in GHC Haskell they are actually a reasonable way to solve problems, even small problems
07:42:34 <kmc> this is why new mainstream languages like Go call their shit "goroutines" or "fibers" or whatever
07:42:53 <syntaxfree> part of the whole unlearning thing is that there's no time to think while you're typing all the boilerplate code.
07:42:59 <mike-burns> Nice use of "mainstream" there.
07:43:36 <adimit> fibers sounds like pretty bad marketingspeak.
07:43:41 <cvic_> Also, the reaction to "monads". Sounds like some scary abstract math thing. But most programmers use monads in their favourite programming language
07:43:57 <cvic_> All about naming things
07:44:25 <osfameron> not really.  except inasmuch as sequential statements, or blocks of nested if's are monadic.
07:44:39 <adimit> i found monads intimidating mostly because everybody said they're scary. But using them in practice is actually not hard.
07:44:41 <kmc> but in most languages you can't easily capture "monad" as a library, and abstract over it, and write monad-generic code
07:45:03 <kmc> in most languages it's a latent "design pattern" which you can write about in books but not capture in the language itself
07:45:14 <osfameron> you can write monads in any language that has 1st class functions and reasonable scoping...
07:45:19 <osfameron> ... but the syntax will make your eyes bleed.
07:45:28 <adimit> cvic_: I think part of using monads is using the tons of combinators hackage provides for them â€” which is a haskell thing, you can't do that (easily) in C or Java.
07:45:46 <kmc> osfameron, most languages provide no mechanism for ad-hoc polymorphism over type constructors
07:46:27 <osfameron> kmc: meh, you can do it with duck-typing ;-)
07:46:30 <Cale> adimit: Certainly. There's basically no point in talking about monads if you can't write code which works with any monad, and most languages don't have good enough polymorphism to allow for that.
07:46:33 <cvic_> but _mainstream_ functional languages have monads, right?
07:46:45 <Cale> (at least, not well enough to make it worthwhile doing)
07:46:47 <cvic_> I hate this word... mainstream.
07:47:05 <Cale> kmc: I'd be careful with the word ad-hoc there.
07:47:12 <silver> I think in F# (dunno if it counts) monads are called something different
07:47:15 <tromp> use "succesful" instead
07:47:22 <adimit> I don't know. lispers don't usually use stuff like that. Then again, I haven't used lisp since I ditched emacs years ago.
07:47:23 <Cale> Typeclass polymorphism is quite different from what I'd call ad-hoc polymorphism
07:47:29 <osfameron> they're "computations" or something in F# aren't tehy?
07:47:34 <cvic_> Yep. MS marketing division took care of that
07:47:43 <cvic_> computations... of asynchronous flows
07:47:48 <cvic_> something buzzword-ish
07:48:06 <Cale> "workflows" wasn't it?
07:48:06 <cvic_> Ah, no
07:48:12 <cvic_> Computation expressions
07:48:21 <cvic_> http://en.wikibooks.org/wiki/F_Sharp_Programming/Computation_Expressions#Defining_Computation_Expressions
07:48:22 <cvic_> Heh
07:48:48 <cvic_> There are some hardcore Haskell fans working on the .NET
07:48:59 <Cale> It's funny to see people writing F# or Scala and thinking in Haskell while doing it.
07:49:04 <cvic_> Like Erik Meijer
07:49:11 <cvic_> Cool guy
07:49:11 <adimit> microsoft does a ton of research on haskell itself even.
07:49:16 <cvic_> Yes
07:49:30 <cvic_> SP Jones, right
07:52:16 <Nimatek> Soon to be released: Î»# for the .NET platform.
07:57:10 <adimit> it would be kinda cool to compile haskell to .NET bytecode :-P
07:57:22 <quicksilver> been done
07:57:24 <quicksilver> nobody used it
07:57:26 <quicksilver> project died
07:57:38 <quicksilver> like the twelve different projects to compile haskell to the JVM
07:58:01 <adimit> yeah, it's a lot of effort for just "kinda cool"
07:58:07 <kmc> keeping up with GHC backend changes is a big task
07:58:25 <kmc> or you can use some other compiler and nobody can use your shit
07:58:29 <quicksilver> the javascript backend seems the most likely to keep up
07:58:40 <quicksilver> but who knows
07:58:46 <quicksilver> stuff that doesn't get used, dies
07:58:49 <kmc> perhaps a separate pass from GHC external Core is a more stable approach
07:59:03 <kmc> but there are also projects to compile LLVM to Javascript, etc
07:59:14 <kmc> so maybe one can use those with less effort on the GHC side
07:59:18 <quicksilver> there have been eighteen different projects for "mobile code" (distributed haskell) which have also all bitrotted
07:59:27 <quicksilver> even though that seems even cooler (to me, at least)
07:59:30 <hpc> i imagine LLVM is easier to translate to js than core
07:59:46 <kmc> i also saw a project which compiled C, C++, etc. to the JVM via MIPS assembly
08:00:07 <quicksilver> hpc: but using JS as a register machine may not be an efficient compilation path. (I don't know that for sure)
08:00:49 <mike-burns> GHC is intimidating to hack on, and the fast pace of it doesn't help.
08:01:00 <mike-burns> All I feel like I can do is complain.
08:01:01 <quicksilver> true
08:01:09 <quicksilver> that's what IRC is for, mike-burns ;)
08:01:24 <kmc> it's also crusty 20-year-old pre-modern Haskell code
08:02:04 <quicksilver> kmc: some parts of it have been a little modernised
08:02:14 <quicksilver> kmc: it even uses monads in a couple of places now, did you know? :)
08:02:16 <mike-burns> Hah.
08:02:23 <kmc> ;)
08:02:31 <quicksilver> kmc: actually it was something far worse than 20-year-old haskell
08:02:42 <SharkMonkey> Hah, "The Glorious Glasgow Haskell Compilation System"?
08:02:47 <quicksilver> kmc: it was horrendous 20-year-old unsafePerformIO GHC-specific hacks
08:03:00 <quicksilver> kmc: using mutation to built up state during type checking etc
08:03:01 <kmc> it's still pretty far from the ideal of "beautiful functional program as compiler for beautiful functional language"
08:03:01 <kmc> yeah
08:03:26 <hpc> quicksilver: so GHC was bootstrapped on its own bugs? lol
08:03:26 <sully> SharkMonkey: ITYM "The Glonous Glasgow Haskell Compilation System"
08:03:26 <quicksilver> hpc: heh :)
08:03:38 <quicksilver> hpc: the version that was boostrapped must presumably have been cleaner
08:03:41 <quicksilver> boostrapped off hbc, was it?
08:14:16 <quicksilver> (yes it was HBC - http://marc.info/?l=haskell&m=66622004521334&w=2 )
08:14:48 <ion> â€œprobably with 16+MB memoryâ€, aww
08:16:16 <Axman6> how cute
08:17:29 <dafis> what? 16MB was huge a few years ago
08:18:08 <quicksilver> in 92, sun4s were seriously exotic kit
08:18:10 <Cale> s/a few years/a couple decades/
08:18:19 * dafis is old
08:18:21 <quicksilver> very few people had access to them
08:18:39 <quicksilver> well I suppose sun4s went from exotic to obscure without ever passing through common ;)
08:18:50 <quicksilver> but they were much more affordable in 96 than 92.
08:23:21 <kmc> wow, so the first arch supported by GHC was SPARC?
08:23:34 <kmc> i guess in 1992, PCs didn't have enough memory to run Haskell code
08:24:34 * dcoutts notes that GHC still supports sparc
08:24:48 <dcoutts> anyone want access to a 64core spark box? haskell.org has one
08:24:53 <dcoutts> core/thread
08:25:00 <kmc> well they say it should work on any Unix box
08:25:11 <kmc> so i guess it's producing ~portable C at this point
08:25:20 <dcoutts> no, we have a native code gen for sparc
08:25:36 <dcoutts> but the portable C backend should work too
08:25:42 <kmc> sorry i meant GHC 0.10
08:25:49 <kmc> somebody linked http://marc.info/?l=haskell&m=66622004521334&w=2 above
08:25:49 <dcoutts> ohh :-)
08:25:55 <quicksilver> kmc: in 92, PCs were 2/386s and unix for PCs was unusual
08:26:02 <dcoutts> kmc: right, probably semi-portable C
08:26:15 <dcoutts> kmc: it wouldn't at all surprise me if it were gnu C only though
08:26:23 <luite> hmm, 16+MB of memory, that must've been expensive :p
08:27:12 <kmc> quicksilver, yeah, around that time I heard about a student in Finland writing a free UNIX kernel for PCs
08:27:17 <kmc> what ever happened to that project?
08:27:19 <kmc> ;)
08:28:10 <mux> it lead nowhere; the guy should have known about 386BSD, but unfortunately didn't ;-)
08:41:37 <adimit> why on earth does Data.SmallString not export fromBs and toBS? â€¦ weird stuff.
08:42:27 <kmc> maybe they reserve the right to change the internal encoding
08:43:01 <adimit> nah, they'd be abstracting over it w/o a problem even with these exported.
08:43:20 <kmc> what BS does "toBS" return?
08:43:23 <adimit> at least the way I see it.
08:44:04 <adimit> strict.
08:44:04 * ClaudiusMaximus sees Data.SmallString and imagines data SmallString = Empty | String1 !Char | String2 !Char !Char | ... | NotSmallEnough String
08:44:19 <kmc> adimit, no, I mean, what are the bytes?
08:44:39 <kmc> there are many different ways to represent Unicode text as bytes
08:45:16 <RaptorRarr> Is there some easy way to make minor changes to the alternatives in a data declaration between, say, stages of a compiler?
08:45:24 <ClaudiusMaximus> or maybe | NotSmall [SmallString]
08:45:45 <adimit> SmallString is basically just a SmallArray around Word8, so it just copies its representations to a BS. Unicode assumptions aren't checked.
08:45:53 <byorgey> RaptorRarr: there is no easy way. There are some clever ways.
08:46:09 <RaptorRarr> What are some clever ways?
08:46:10 <kmc> adimit, what? are you talking about http://hackage.haskell.org/packages/archive/smallstring/0.3.1/doc/html/Data-SmallString.html or another module of that name?
08:46:29 <adimit> http://bit.ly/mSACnG yeah, talking about the same thing, methinks.
08:46:39 <byorgey> RaptorRarr: http://hackage.haskell.org/package/syntactic
08:47:02 <byorgey> RaptorRarr: see Wouter Swierstra's paper "Data Types a la Carte", it is really a fun read
08:47:05 <kmc> adimit, right so, if it exported toBS, it would expose the internal Unicode encoding
08:47:12 <RaptorRarr> Are there any Haskelly languages that make those things easy?
08:47:32 <RaptorRarr> byorgey: Ahh, thanks. I'm looking at those.
08:47:38 <kmc> adimit, and worse, fromBS would allow you to inject byte arrays which don't correspond to valid Unicode text
08:47:58 <kmc> adimit, not saying these would be inappropriate for a "Data.SmallString.Internal" module, but it would break the current abstraction
08:48:17 <adimit> kmc: hm. true. but this way I do a decodeUtf8, only to have fromText do an encodeUtf8 immidiately afterwardâ€¦
08:48:39 <kmc> why are you going through SmallString then?
08:48:51 <RaptorRarr> http://web.archive.org/web/20100330233650/http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
08:48:55 <kmc> it might make sense for SmallString to have a family of functions like http://hackage.haskell.org/packages/archive/text/0.11.1.5/doc/html/Data-Text-Encoding.html
08:49:16 <kmc> adimit, I'm fine with your "toBS" if it's named "encodeUtf8"
08:49:32 <kmc> and fromBS named "decodeUtf8", but it should do some additional checks
08:49:39 <adimit> kmc, because I want to use it as the key type in very large hashmap.
08:49:46 <adimit> I agree.
08:49:47 <kmc> okay
08:49:50 <kmc> have you seen http://hackage.haskell.org/package/intern by the way?
08:50:15 <adimit> kmc: nope. looking at it right now, thanks.
08:50:39 <adimit> the documentation is awful though. ^^
08:53:39 <jrgarcia> What is the meaning of the "{-# LANGUAGE xxx #-}" I see at the top of some modules?
08:53:39 <kmc> jrgarcia, enable language extensions
08:53:58 <jrgarcia> Where can I find information about language extensions?
08:54:03 <kmc> jrgarcia, GHC manual
08:54:15 <jrgarcia> Thanks, kmc!
08:54:15 <kmc> chapter 7
08:54:16 <kmc> :)
08:54:34 <Cale> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/ghc-language-features.html
08:54:35 <kmc> adimit, yeah, it's an edwardk production, so the rate of development far outpaces the rate of documentation... but he's on IRC a lot so you can bug him
08:54:41 <ClaudiusMaximus> ghc --supported-languages will dump a few pages :)
08:55:29 <adimit> kmc: yeah. At this point, I'm not sure I know what to do with it.
08:55:42 <quicksilver> kmc: edwardk's documentation is outsourced to #haskell
08:55:48 <quicksilver> so it's actually our fault it's not been written.
08:55:52 <kmc> adimit, you call intern :: Text -> InternedText
08:55:54 <quicksilver> we should never have signed that contract.
08:56:01 <byorgey> the Haskell community needs to all chip in money to hire a full-time documentation-writing assistant for edwardk
08:56:05 <kmc> and later you can call unintern :: InternedText -> Text
08:56:35 <kmc> and if you do this on two identical strings, they magically become the same heap object in the middle
08:56:37 <kmc> that's my fuzzy understanding anyway
08:56:47 <Cale> "Uninternable" is a funny class name :)
08:57:27 <adimit> kmc: aaah. Kinda like Java's string interning? now I get it.
08:57:29 * byorgey always expects the "intern" package to be a set of tools for use by people working at MSR over the summer, or something like that
08:57:31 <ClaudiusMaximus> byorgey: i hear interns can be lured to work for free
08:57:36 <kmc> haha
08:57:39 <kmc> not in software ;)
08:57:52 <kmc> http://blogs.oracle.com/ksplice/entry/how_to_quadruple_your_productivity
08:58:52 <kmc> "Interned.Internal" is funny too
08:59:00 <monochrom> as usual, the hard part is decomposing the project
08:59:37 <d34df00d> Hi!
08:59:44 <monochrom> err, decomposing the project properly to suit that scheme
08:59:57 <Cale> d34df00d: hello!
09:00:05 <dolio> I'm disappointed that InternedByteString is no longer an acronym.
09:00:09 <d34df00d> Why does join (***) work as it works? I've stared at their signatures but couldn't get it yet :(
09:00:09 <kmc> adimit, you also get a more efficient Eq and Ord on Text, although I think the Ord is arbitrary and not lexicographic
09:00:31 * monochrom feels that most of project problems are caused by wrong decompositions
09:00:41 <kmc> specialize join :: (a -> (a -> b)) -> (a -> b)
09:00:46 <kmc> (the ((->) a) monad)
09:01:02 <d34df00d> Hm.
09:01:16 <d34df00d> So that stems from a clever definition of arrow as a monad?
09:01:25 <kmc> specialize (***) :: (b -> c) -> (b' -> c') -> ((b, b') -> (c, c'))
09:01:28 <kmc> (the (->) arrow)
09:01:35 <monochrom> yes
09:01:38 <adimit> kmc: that's pretty neat. But I don't know if I need interning. I just need tons of small strings (I know they're all unique.)
09:01:47 <kmc> ah ok adimit
09:02:06 <kmc> d34df00d, a clever definition of a Monad instance for the  type ((->) a)  (for any a)
09:02:21 <jrgarcia> Ah, so {-# is a pragma... got it
09:02:21 <kmc> you can pronounce the type constructor (->) as "arrow", but don't confuse it with the Arrow type class or other instances of that class
09:02:24 <kmc> jrgarcia, yes
09:02:47 <kmc> GHC has other pragmas, like INLINE and SPECIALIZE
09:02:48 <kmc> and RULES
09:02:48 <hpc> or "function from blah to"
09:03:08 <adimit> the fact that (-> a) is a Monad and a Functor makes for some pretty exotic combinator shenanigans...
09:03:39 <Cale> (->) a or (a ->) -- the latter of which isn't really valid syntax, but morally ought to be :)
09:03:40 <copumpkin> ((->) a)
09:03:55 <copumpkin> (-> a) is a contravariant functor but you can't write it directly in haskell
09:04:06 <d34df00d> Oh.
09:04:12 <kmc> byorgey, so I'm interested in writing a 'diagrams' backend for G-code like http://linuxcnc.org/docs/html/gcode.html
09:04:13 * d34df00d fails at category theory.
09:04:31 <d34df00d> Thanks, I'd think a bit more of that.
09:04:59 <kmc> i think it would be cool to use 'diagrams' to control CNC mills, plasma cutters, etc
09:05:28 <Cale> d34df00d: So, in general fmap :: (a -> b) -> f a -> f b, so for f = (e ->), we get fmap :: (a -> b) -> (e -> a) -> (e -> b), which is exactly the type of composition
09:05:46 <Cale> and for join :: f (f a) -> f a, we get (e -> (e -> a)) -> (e -> a)
09:06:03 <Cale> which pretty much tells you what it does right from the type
09:06:16 <Cale> join f x = f x x
09:06:39 <Cale> and so in particular, join (***) x = x *** x
09:07:02 <d34df00d> Ah, it starts to clarify.
09:07:19 <kmc> byorgey, so I was wondering if there's code already in 'diagrams' to approximate ellipses and cubic splines as piecewise linear
09:07:24 <Cale> and the Arrow instance for (->) says that (f *** g) (x,y) = (f x, g y)
09:07:25 <d34df00d> Awesome!
09:07:26 <d34df00d> I got it!
09:07:33 <d34df00d> Thank you guys! Haskell is awesome!
09:08:21 <kmc> this G-code has primitives for lines and circular arcs, but not ellipses or cubic splines
09:08:27 <byorgey> kmc: no, there's no code to do piecewise linear approximation
09:08:44 <kmc> (it also has quadratic splines and NURBs but I don't know if they work well)
09:09:14 <byorgey> kmc: you should talk to fryguybob though, he used to do that sort of thing for a living
09:09:29 <kmc> byorgey, ok, if I write it do you think it would go in diagrams-lib?
09:09:45 <kmc> or some new contrib package, or should I just upload it myself
09:09:46 <byorgey> yeah, sure
09:09:51 <kmc> cool, how do I contact him
09:11:57 <byorgey> kmc: hold on, screaming baby
09:12:07 <kmc> haha, ok
09:12:08 <kmc> take your time :)
09:14:26 <danmaftei> I am unclear why you can pattern match the cons function but not the append one. (disregard view patterns for now) Further, are there other functions which can be pattern matched, or is it just cons b/c lists are so colloquial?
09:14:41 <kmc> you can pattern-match on any data constructor
09:14:57 <kmc> if you write Â«data List a = Nil | Cons a (List a)Â»
09:15:01 <kmc> then you can pattern-match on Nil and Cons
09:15:10 <danmaftei> oooh, so Cons is a data constructor, but (++) is not
09:15:11 <kmc> [] and (:) are just special built-in syntax for that
09:15:14 <kmc> right
09:15:19 <danmaftei> gotcha
09:15:59 <engla> danmaftei: and you can define infix data constructors, but they have to start with : just like : itself. You can use :-: etc.
09:16:27 <kmc> data List a = Nil | a :+ List a
09:16:32 <quicksilver> data Happy = Whos :-> SmilingNow
09:16:34 <byorgey> kmc: he hangs out in here sometimes, he also uses the same username @ gmail
09:16:38 <kmc> cool
09:16:43 <RaptorRarr> :>
09:16:48 <kmc> but you can't define syntax like [] or [1,2,3] yourself
09:16:58 <d34df00d> And, well, the more I think about arrows as functors and monads, the more it makes sense.
09:17:02 <kmc> that's baked in
09:17:03 <d34df00d> But where can I  read more about this?
09:17:16 <d34df00d> Interrelations between them and such.
09:18:02 <dingfeng> i like haskell, but i don't like its (lack of a proper) module system and its default non-strict evaluation. how can i change this so i can use haskell in the real world?
09:18:15 <RaptorRarr> Haha
09:18:24 <kmc> what do you want from the module system?
09:18:52 <Cale> dingfeng: rofl
09:19:03 <kmc> many people do use Haskell in the real world, despite those (valid) objections
09:19:34 <Cale> I contest the point about nonstrict semantics being impractical. It's quite useful in practice.
09:19:37 <kmc> it's kind of a weird way to ask "how can I improve the module system / strictness control"
09:19:43 <danmaftei> dingfeng: i ran into the strictness problem doing n-gram models (huge data structures). here's a site that was helpful: http://users.aber.ac.uk/afc/stricthaskell.html
09:19:48 <Cale> The module system is a valid point
09:19:49 <dingfeng> i want something like units/signature
09:19:52 <dingfeng> o
09:19:59 <osfameron> the question seems to imply "I'd rather use Ocaml" doesn't it?
09:20:06 <kmc> dingfeng, what "real world" language has those?
09:20:23 <Cale> I've discovered recently that type families can relieve a lot of the need for a better module system though
09:20:27 <kmc> that is, what language more popular than Haskell has them?
09:20:47 <kmc> (i don't know what you mean by "units"... signature like a ML module signature?)
09:20:55 <Cale> If your code starts to get littered with type parameters, you can collapse them into one configuration parameter, and a bunch of type families.
09:21:13 <kmc> that's helpful
09:21:22 <kmc> records + existentials can also act like first-class modules in some cases
09:21:35 <kmc> GHC's RecordWildCards extension even gives you a local "open" ability :)
09:22:00 <ezyang> Is GHC Haskell's type system (add lots of extensions!) extensional or intensional?
09:22:14 <ezyang> Is this an ill-formed question?
09:22:33 <adimit> d) !
09:23:00 <dolio> Ill-formed.
09:23:00 <Philonous_> Cale: I guess constraint kinds will make that idea even more powerful
09:23:06 <Cale> Philonous_: indeed
09:23:22 <dingfeng> i'm not sure. it's hard to apply all elements of a record to something.
09:23:29 <ezyang> dolio: How is it ill-formed?
09:23:35 <Cale> dingfeng: ?
09:23:42 <dylukes> How would you write something lke
09:23:47 <dingfeng> i always end up with "f i x" instead of "f x", and then "f i j x" instead of "f x", and it accumulates
09:24:04 <ezyang> dolio: And I don't think question is /entirely/ without merit, so how do I formulate it properly?
09:24:07 <dylukes> @pl (\y -> do x <- a; b x y)
09:24:08 <lambdabot> (line 1, column 17):
09:24:08 <lambdabot> unexpected ";"
09:24:08 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
09:24:09 <Cale> dingfeng: bundle extra parameters together into a new datatype
09:24:18 <dylukes> @pl (\y -> do {x <- a; b x y})
09:24:18 <lambdabot> (line 1, column 11):
09:24:19 <lambdabot> unexpected "{"
09:24:19 <lambdabot> expecting variable, "(", operator or ")"
09:24:30 <dylukes> @undo @pl (\y -> do {x <- a; b x y})
09:24:30 <lambdabot>  Parse error at "@pl" (column 1)
09:24:34 <ezyang> (for example: mumble undecidable instances mumble extensional)
09:24:35 <dylukes> @undo (\y -> do {x <- a; b x y})
09:24:35 <lambdabot> (\ y -> a >>= \ x -> b x y)
09:24:49 <dylukes> Is there any way to write that nicely in applicative?
09:25:01 <dylukes> Linter doesn't like lambdas >:<
09:25:07 <Cale> dingfeng: I end up with that too, but refactoring it to be nicer usually isn't so bad.
09:25:14 <RaptorRarr> @. pl undo (\y -> do {x <- a; b x y})
09:25:14 <lambdabot> (a >>=) . flip b
09:25:25 <dylukes> expr0 >>= flip expr2 p0
09:25:28 <dylukes> er
09:25:36 <dylukes> a >>= flip b y
09:26:07 <dylukes> trying to clean up
09:26:08 <dylukes> expressionParser table p0 expr0 = expr0 >>= flip expr2 p0
09:26:12 <dylukes> this is clear as is I think
09:26:27 <Cale> It's just a matter of working out a nice way to express the things that your function depends on, so that you don't have lots of separate ones coming from different places.
09:26:32 <dolio> ezyang: I guess maybe the question makes sense, but not at the level typically considered.
09:26:33 <dingfeng> it's not the same. abstraction is lost. like when i had a set of functions that operates on a graph, and the entire set of function should take the same first argument, it's hard to curry the entire set of functions
09:26:39 <dolio> Because there are no identity types for terms.
09:27:06 * ezyang doesn't actually know what an identity type is. 
09:27:23 <Cale> dingfeng: Not sure that I understand
09:27:32 <dolio> It is a type that witnesses equality between two terms.
09:27:52 <dolio> But GHC's type system doesn't involve equality of terms at all, only of types and above.
09:27:56 <Philonous> d34df00d:  If you want to understand the relationship between monads, arrows and idioms (applicative functors) there is this beautiful paper by Wadler et.al.: http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
09:28:04 <ezyang> ah, OK.
09:28:19 <ManateeLazyCat> Hi all. :)
09:29:19 <quicksilver> dingfeng: fmap ($i) x applies every function in the container 'x' to the first parameter 'i'
09:29:29 <quicksilver> so you certainly can partially apply functions en-masse
09:29:34 <quicksilver> not sure if I followed your point, though.
09:30:04 <dolio> If you're talking about equality of types instead, then it's kind of like extensional type theory, because if pf : T ~ U, then T and U are considered the same type automatically by the system.
09:30:21 <Cale> Or if the functions have different types, maybe the set of functions is meant to be bundled into a record which is constructed as a function of that parameter? I don't have a clear picture in my head of the problem.
09:30:24 <d34df00d> Philonous: oh, thanks a lot.
09:30:25 <dolio> But that doesn't have the same consequences as it does in normal extensional type theory.
09:32:01 <dingfeng> quicksilver: only if you define a container holding 20 functions and make it an instance of a functor
09:32:19 <Cale> If you have a bunch of functions, g -> t1, g -> t2, ..., g -> tn, you can always turn them into a function g -> (t1,...,tn), and of course, using a tuple for that is ugly, so define a record type to extract the components.
09:32:45 <DukeDave> Can someone link me to the wiki page for '~' in a type signature?
09:33:09 <Cale> DukeDave: http://www.haskell.org/haskellwiki/GHC/Type_families
09:33:20 <Cale> http://www.haskell.org/haskellwiki/GHC/Type_families#Equality_constraints
09:33:46 <dingfeng> when n = 20?
09:33:58 <Cale> dingfeng: That's fine :)
09:34:03 <DukeDave> Cale: Thank you :)
09:34:03 <mm_freak> does anyone know how to insert variables into markdown files, when using the pandoc command line utility?
09:34:44 <dolio> ezyang: Also, it's questionable whether a ~ b is the right analogue to a type identity type, because it's not exactly first-class.
09:34:51 <Cale> dingfeng: You end up with some big product types, but they are more or less the same thing as your first-class modules. You can use record wildcard syntax to even unpack them locally.
09:34:55 <monochrom> I have used records with more than 20 fields. it's fine.
09:35:16 <Cale> There's something kinda object oriented about doing this generally.
09:35:30 <dolio> data TEq t u where Refl :: TEq t t is closer, but that behaves like intensional type theory.
09:35:35 <monochrom> of course a real module system is much welcome, too
09:35:51 <dolio> In that a TEq T U being in scope doesn't cause T and U to be usable interchangeably automatically.
09:36:47 <Cale> Yeah, there have been a number of cases in our codebase at iPwn where it would be welcome, but it's really not so painful not to have it either, especially with the type family trick I mentioned :)
09:37:32 <ezyang> Damn. I thought I understood intensional vs. extensional. ^_^
09:37:37 <Saizan> which trick?
09:37:50 <Sgeo|TryHaskell> I only learned of TryHaskell's webchat thing by reading the code
09:37:50 <Sgeo|TryHaskell> :/
09:38:27 <Cale> Saizan: if you have a bunch of type parameters which seem to be common to a lot of the types in your code, you can bundle them together into a single phantom type parameter, along with a bunch of type families which "project out the components" of the abstract configuration-specifying type.
09:38:45 <dolio> ezyang: There's also intensional vs. extensional type theory, and intensional vs. extensional equality (of a type).
09:38:57 <kmc> Cale, that's a cool trick
09:39:05 <kmc> you should blog post it :)
09:39:07 <dolio> The former is about how identity types behave in the theory.
09:39:28 <dolio> The latter is about whether you can, for instance, prove that f = g given forall x. f x = g x.
09:39:35 <Cale> Saizan: this more or less makes up for not being able to stick datatypes into records (which is the main difference between records with higher rank types and first class modules)
09:40:05 <ezyang> Right. I'm thinking about the former in this case.
09:40:16 <ezyang> But the latter is certainly where I first heard about the distinction.
09:41:07 <Sgeo|TryHaskell> oh, it comes up during the tutorial
09:41:42 <kmc> yeah at one point tryhaskell.org made it to the Reddit front page
09:41:47 <kmc> there were a lot of confused people here
09:42:03 <Cale> Sgeo|TryHaskell: You should also be aware (if it's not made clear by the tutorial) that this chat is actually on a proper IRC server which you can connect to separately.
09:42:17 * Sgeo|TryHaskell is aware
09:42:45 <Cale> kmc: haha, I missed that
09:42:47 <Sgeo|TryHaskell> I'm at school right now, and didn't quite intend to go on IRC, just play with TryHaskell
09:43:00 <mike-burns> On October 19th, 2011, Sgeo|TryHaskell became self-aware.
09:43:09 <mike-burns> Terminator Five: #haskell
09:43:10 * RaptorRarr runs.
09:43:43 <erus`> by Novermber 2nd the virus had crossed the species barrier. Cats were posting lolhuman pictures all over the internet
09:43:51 * Cale envisions a Terminator/Jurassic Park crossover
09:44:55 <JoeyA> What's a good way to manage a set of items that supports efficient insertion and removal of items, where order does not matter?  In C, one might do this with a doubly linked list.
09:45:06 <kmc> Data.Set ?
09:45:16 <JoeyA> That involves ordered items.
09:45:16 <Cale> Yes, Data.Set.
09:45:29 <JoeyA> The items I'm talking about can't be compared.
09:45:30 <Cale> Data.Set doesn't preserve ordering
09:45:32 <companion_cube> JoeyA: a doubly linked list is not so efficient for removal
09:45:32 <Cale> oh
09:45:35 <kmc> doubly linked list does not support efficient insertion and removal, if by "efficient" you mean "faster than O(n)"
09:45:46 <kmc> well i guess just removal
09:45:54 <kmc> or do you mean removal given an iterator, rather than the element itself?
09:46:00 <Sgeo|TryHaskell> Would it be nice for there to be a class similar to Ord, except that the results of the comparisons are meaningless except for things like Set?
09:46:01 <JoeyA> correct
09:46:03 <Cale> JoeyA: Data.Sequence then?
09:46:15 <companion_cube> Sgeo|TryHaskell: it would still be an Ord
09:46:18 <Cale> JoeyA: You have a different concept of "order does not matter" than I do :)
09:46:51 <Cale> Data.Sequence encodes the order that you put items in it
09:46:52 <dingfeng> well, i'm not sure if using records and type families to simulate something so commonly used (at least in some areas) can be considered practical, given that it's so easily done in a more popular language like Java.
09:47:13 <kmc> also the doubly-linked list solution is not usable persistently
09:47:16 <Cale> It has logarithmic splitting and concatenation, and constant time access to both ends
09:47:19 <kmc> you have to mutate the list in place or else copy the whole thing
09:47:23 <JoeyA> The principle operations (in a purely functional API) would be: empty :: USet a; insert :: a -> USet a -> (Anchor, USet a); delete :: Anchor -> USet a -> USet a
09:47:35 <Sgeo|TryHaskell> But doesn't Ord imply being able to meaningfully compare, etc? I mean, it might be unpleasant to make Ord Complex because it's meaningless, but they can be ordered for the purposes of Sets I _think_
09:47:38 <kmc> which imposes constraints on the algorithms you can implement etc
09:47:49 <kmc> Sgeo|TryHaskell, yeah, I've heard this suggestion before
09:47:51 <kmc> it seems like a good idea
09:48:23 <kmc> JoeyA, what does 'delete' do if the Anchor came from a different set?
09:48:25 <kmc> undefined?
09:48:32 <JoeyA> Here's my use case: I have a thread that listens for notifications from the database.  Other threads can listen for select notifications.
09:48:37 <Cale> JoeyA: Yeah, look at Data.Sequence, I think it's what you're looking for.
09:48:43 <JoeyA> kmc: Correct
09:48:58 <kmc> that seems less than useful
09:49:01 <Cale> (where Anchor is just an integer index)
09:49:08 <kmc> you can't insert x, insert y, delete x
09:49:22 <kmc> the USet you get after inserting y is a different USet than the one you got the anchor from
09:49:29 <dolio> ezyang: Of course, even the TEq type I mentioned earlier doesn't exactly fit with intensional type theory. Because it allows you to create a local scope where T is considered identical to U, rather than just cast a P T to a P U or vice versa.
09:49:29 <kmc> (also before inserting y)
09:50:29 <JoeyA> I am thinking of implementing a doubly linked list in STM.
09:50:35 <dolio> So it's more like the second-class extensional behavior wrapped in a first-class box.
09:51:12 <ezyang> dolio: heh
09:51:32 <JoeyA> (so it'd be a stateful API, sort of like TArray)
09:51:37 <ezyang> "All I wanted to do was understand why I need to write such complex return types to make Coq's type checker happy"
09:51:58 <kmc> JoeyA, sounds legit, if you never need to interact with older copies
09:52:04 <JoeyA> Right
09:52:37 <dolio> Yeah, I guess the reason for that is that GHC is closer to extensional type theory, while Coq is definitely intensional.
09:53:07 <JoeyA> Does having a lot of TVars result in some surprising performance hit?
09:53:12 <dolio> And GHC can get away without some of the undecidability problems because not enough things are first-class.
09:53:21 <JoeyA> (as in my case: having two per linked list node)
09:53:24 <dolio> Or appear in types.
09:53:32 <hpc> JoeyA: depends on how they are written and read from; you could end up with lots of recomputation or none at all
09:53:59 <hpc> more TVars makes it harder to minimize computation, but not impossible
09:54:03 <JoeyA> I'm doing single node insertions and removals atomically.
09:54:10 <Saizan> dolio: also just reporting and error if it can't find how to use the coercions
09:54:17 <Saizan> s/and/an/
09:54:49 <dolio> It seems pretty smart about solving everything.
09:54:54 <ezyang> dolio: It's true.
09:55:06 <ezyang> It's kind of remarkable we've been able to get so far, quite frankly.
09:55:09 <dolio> Maybe I haven't done anything fancy enough.
09:55:14 <JoeyA> Thanks for the help.
09:55:43 <mm_freak> unrelated TVars shouldn't cause any performance hit
10:00:19 <Sgeo|TryHaskell> Is there a way to automatically determine, from type... n/m
10:00:25 <dolio> Actually, I guess it fails some basic stuff.
10:00:45 <Sgeo|TryHaskell> Was about to ask whether it must be strict, and was thinking particularly of length :: [a] -> Int
10:01:03 <dolio> If I try to write (a -> a) ~ a => (a -> a) -> a using the usual Y combinator format, it doesn't work.
10:01:04 <kmc> no
10:01:07 <kmc> length _ = 0
10:01:18 <dolio> Despite the fact that a and a -> a should be identical.
10:01:20 <Sgeo|TryHaskell> Indeed
10:01:42 <kmc> you could know that (a -> b -> b) *isn't* strict in its first arg
10:01:43 <kmc> except for seq
10:01:49 <kmc> which breaks this line of reasoning
10:01:54 <hpc> dolio: infinite type error?
10:02:17 <dolio> No. Rigid type mismatch or something.
10:02:19 <dmwit> hpc: Almost. Inaccessible code error, which is kind of impressive.
10:02:29 <hpc> interesting
10:02:53 <dolio> Actually...
10:02:56 <hpc> i suppose that means the function itself typechecks, but any values you pass to it would have to have infinite types?
10:02:56 <dmwit> You can never construct a proof that (a -> a) ~ a, so the the darn thing can never be called.
10:03:00 <dolio> This error message looks a little weird.
10:03:22 <dolio> It has the phrase "inaccessible code," so maybe it's detecting that it's impossible to fulfill the constraint.
10:03:45 <dmwit> I'm pretty sure that's what it's doing.
10:03:51 <dmwit> The paper talks about how they do that detection.
10:03:55 <dolio> Ah.
10:04:06 <dolio> I mean, that's one of the problems with extensional type theory.
10:04:08 <kmc> Sgeo|TryHaskell, also, usually you want to know more than just "strict or not"
10:04:14 <dolio> Why you lose strong normalization.
10:04:21 <dolio> You can write loops in false contexts.
10:04:26 <dmwit> right
10:04:34 <kmc> describing how much of the inputs are forced based on how much of the output is forced can get complicated
10:04:36 <dolio> In GHC, that'd probably correspond to looping the optimizer.
10:04:53 <ManateeLazyCat> Good night all. :)
10:04:55 <Saizan> yeah, but this check isn't complete either
10:10:00 <roconnor> dolio: OTT is a strongly normalizing extensional type theory
10:10:31 <roconnor> (interestingly, Coq isn't strongly normalizing)
10:15:16 <sm> morning all. yay cabal-file-th!
10:15:26 <Sgeo|TryHaskell> How do I submit patches, to, say, HUnit?
10:17:59 <Cale> http://hackage.haskell.org/package/HUnit says the maintainer is hunit@richardg.name -- you could try sending email there
10:28:16 <Sgeo|TryHaskell> On non-GHC systems, hashUnique :: Unique -> Int seems to merely cause the Int to wrap around when it would overflow
10:28:37 <Sgeo|TryHaskell> I guess it's not just to an Integer for efficiency purposes, otherwise Unique would simply be used?
10:28:45 <Sgeo|TryHaskell> Instead of bothering to hash it?
10:29:39 <dolio> roconnor: OTT isn't extensional type theory.
10:30:51 <dolio> roconnor: Also, what fails strong normalization in Coq, do you know? I've heard that, but I don't know if I've ever seen an example.
10:32:22 <leino> hello people, is there any way to get more usefull error messages from cabal? ('cabal install')
10:32:44 <dcoutts> leino: you mean rather than ExitException 1 ?
10:32:45 <roconnor> dolio: if you have a dead code in a let statement inside a fixed point, then there is no recursive guard check and you can do unrestricted recursive calls.
10:32:52 <roconnor> dolio: OTT is extensional
10:32:54 <dolio> Ah.
10:32:57 <dolio> No, it isn't.
10:32:59 <roconnor> yes it is
10:33:03 <leino> dcoutts: yeah
10:33:14 <dcoutts> leino: the real error will usually be earlier in the log
10:33:19 <dolio> There's no rule that deduces judgmental equality from propositional equality.
10:33:28 <roconnor> dolio: it proves functional extensionality
10:33:34 <dolio> Which is the defining aspect of extensional type theory.
10:33:37 <leino> dcoutts: I think I see the real error, but I have no idea what it's about
10:33:43 <roconnor> which is the defining aspect of extensional type theory
10:33:50 <dcoutts> leino: we can help you decode it
10:34:05 <leino> dcoutts: ok thanks
10:34:20 <leino> dcoutts: I am trying to do 'cabal install wx'
10:34:26 <dolio> roconnor: Then your definition of extensional type theory is different from the one that most people in academia use.
10:34:26 <leino> wxcore fails
10:35:15 <leino> dcoutts: it seems 'cabal install wxcore' generates .hs files from .h files, or something
10:35:48 <leino> dcoutts: and one line reads " ignore: parse error : //WXCOLORREF wxColour_GetPixel( TSelf(wxColour) _obj ); "
10:36:01 <dcoutts> leino: the trick is to use one of the paste services, e.g. hpaste
10:36:02 <leino> dcoutts: should I pastebin the whole thing?
10:36:02 <roconnor> @google extensional type theory
10:36:16 <leino> dcouts: ok one second
10:36:27 <roconnor> dolio: the first hit on google is: http://www.cs.nott.ac.uk/~txa/talks/constructive-06.pdf
10:36:53 <roconnor> dolio: the conculsion slide reads: "OTT is a decidable variant of Extensional Type Theory"
10:37:26 <roconnor> Hmm, I guess that may not imply that OTT is an Extensional Type Theory depending on what the word "variant" means
10:37:34 <tac-tics> roconnor: Is there a paper behind these slides?
10:38:27 <leino> dcoutts: http://hpaste.org/52844
10:39:35 <dcoutts> leino: yeah that's really unclear. This is specific to the wx package, it's doing lots of custom stuff
10:39:47 <roconnor> dolio: okay, I conceed that you are probably right
10:40:03 <leino> dcoutts: do you think it would help if I installed it manually?
10:40:09 <dcoutts> leino: it's not clear if that bit about a parse error is related, since it does carry on after, in the end we just get "setup: failed"
10:40:29 <dcoutts> leino: I expect if you do it manually you'll also get the "setup: failed" message and nothing else
10:40:34 <dcoutts> but you can try
10:41:02 <hpaste> Bummi pasted â€œGraphics and recursionâ€ at http://hpaste.org/52845
10:41:04 <Bummi> I would be extremely grateful if someone could take a look at my code and give me a hint/tip on how to make my outputs graphical. I don't know how to do it in the recursive "gameLoop"-function, how should I think? My goal is to use the gtk library to present the "putStrLn"'s. Using the library isn't the problem though, it's the way of thinking
10:41:24 <dcoutts> leino: if you try manually, you could also look for uses of  error "failed"  in the Setup.hs in the wx package in question
10:42:30 <leino> dcoutts: yeah I suppose so... I will try to see if the installer depends on something, maybe I have an old version of some tool that it uses.. or something
10:44:02 <dolio> roconnor: The thing that OTT does that is similar to ETT is that you can 'just add' the right equalities for types, and they work. But the mechanism they use to do that is fairly different.
10:44:30 <dolio> ETT commits to making all provably equalities compute by fiat, more or less.
10:44:40 <dolio> Provable.
10:45:30 <dolio> Or, any hypothesized equalities, even.
10:45:46 <sbi> you missed me, don't you?
10:45:59 <roconnor> well, all I care about is being able to use the functional extensionality theorem :)
10:46:13 <dolio> OTT does a really careful type-directed translation of equality.
10:46:33 <dolio> Yeah, that's what I care about too. OTT is all the good without the bad, more or less.
10:47:09 <dolio> You can see the difference in that you still need the equivalent of subst from ITT in OTT, though.
10:47:29 <dolio> Whereas in ETT it's just, "I proved A = B, so they're the same now."
10:48:35 <dolio> The latter being how T ~ U works in GHC, at least on the surface.
10:49:05 <dolio> If you look at the intermediate code, it inserts a lot of casts, though.
10:58:30 <leino> dcoutts: thanks for your help. I found some instructions on how to install wx manually. there are problems and workarounds for certain versions of the haskell platform so I'll read those. thanks again
11:00:38 <tsousa> what is the difference between a class and a instance in haskell?
11:00:57 <monochrom> like a set and its members
11:01:17 <tsousa> class is a group of functions right?
11:01:27 <monochrom> or like a specification and its implementations
11:01:57 <Cale> tsousa: Typeclasses are like predicates on types, and when they're true, it means that some functionality is available related to that type. An instance makes the predicate true for a given type, and says how the functionality is implemented.
11:02:38 <Cale> For example, there's a typeclass Read which in part looks like:
11:02:42 <Cale> class Read a where
11:02:50 <Cale>   read :: String -> a
11:03:11 <Cale> and then instances which say how to parse values of various types from strings
11:03:12 <bos31337> preflex: seen rl
11:03:13 <preflex>  rl was last seen on #go-nuts 106 days, 20 hours, 3 minutes and 32 seconds ago, saying: Rune makes sense in a way though; the term "character" is overloaded
11:03:19 <Cale> So that I can say:
11:03:25 <Cale> > read "123" :: Integer
11:03:34 <Cale> oh, is lambdabot dead?
11:04:00 <Cale> > read "123" :: Integer
11:04:07 <tsousa> Cale instance is to like treat data right? class do the hard work right?
11:04:11 <lambdabot>   123
11:04:29 <c_wraith> wow.  are there a few spinning mueval-core processes on lambabot's machine?
11:04:30 <Cale> tsousa: classes just say what's available, instances say how to do it for a given type
11:04:39 <tsousa> ok
11:04:48 <Cale> class Eq a where
11:04:54 <Cale>   (==) :: a -> a -> Bool
11:05:07 <Cale>   (/=) :: a -> a -> Bool
11:05:19 <Cale>   x == y = not (x /= y)
11:05:22 <Cale>   x /= y = not (x == y)
11:05:35 <gtirloni> like an interface, right?
11:05:36 <Cale> They are allowed to provide default implementations
11:06:11 <Cale> but as you can see here in the case of Eq, a valid instance will have to provide an implementation for either (==) or (/=) in order for the other default to work
11:06:19 <Cale> (otherwise you end up with an infinite loop)
11:06:33 <Cale> gtirloni: yes
11:07:00 <Cale> Unlike Java interfaces though, they're not conflated with the types of their members.
11:07:18 <gtirloni> ok thx
11:07:22 <Cale> Which is rather good when it comes to expressing that certain types have to be the same
11:07:23 <leino> 3~
11:07:34 <leino> oops sorry :)
11:07:35 <Cale> For example, we can write:
11:07:39 <tsousa> Cale, where can i see the == implementation?
11:07:46 <Cale> sort :: (Ord a) => [a] -> [a]
11:08:18 <engla> classes provide free-for-all functions. Anyone can declare an instance and step up to say, that function can be used with me
11:08:21 <Cale> If we had to write  sort :: [Ord] -> [Ord] (not valid Haskell), then it would be ambiguous whether the result list had the same type as the input list or not.
11:08:47 <tsousa> ok i understand know
11:08:48 <tsousa> thanks
11:08:49 <tsousa> :)
11:09:32 <kmc> gah why does Data.Sequence.index throw an exception instead of returning Nothing
11:09:54 <copumpkin> cause it's a plague
11:10:00 <Cale> tsousa: Well, the implementation of (==) for a lot of types is either derived (using the 'deriving' keyword in data declarations) or built-in... but it's easy to write one for a new datatype we define to see it
11:10:05 <copumpkin> people have an aversion to maybe and choose to infect their code instead
11:10:14 <copumpkin> kmc, embrace the power of thy spoon
11:10:42 <kmc> spooning leads to forking
11:10:43 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a) -- here's a binary tree datatype, with values of type a in each branching node
11:10:57 <roconnor> copumpkin: the worse thing about this plague is that it makes the error messages terrible.
11:10:59 <Ikarus> erm, can I have a filter that takes a pair from the head of a list and decides if the first one is passed ? or do I really need to do a map like action first to generate such pairs
11:11:04 <copumpkin> roconnor: yeah
11:11:10 <tsousa> Cale, no. i mean i want to see the haskell implementation of ==. do you know where can i find it?
11:11:12 <copumpkin> the power of spoon compels you!
11:11:16 <Cale> instance (Eq a) => Eq (Tree a) where -- I can say that if the values stored in the tree are comparable, then so are trees
11:11:30 <Cale>   Tip == Tip = True
11:11:36 <kmc> Ikarus, can you be more specific?  can you give an example of using this function?
11:11:54 <c_wraith> Ikarus: even better, a type signature.
11:12:02 <Cale>   Branch x l r == Branch y l' r' = x == y && l == l' && r == r'
11:12:08 <Cale>   _ == _ = False
11:12:20 <roconnor> case index ... of { Just x -> whatever; Nothing -> error "really specific error message about me being a bad programmer goes here" } would be so much better.
11:12:25 <Cale> Here's an implementation of (==) for my new Tree datatype
11:13:07 <c_wraith> Ikarus: do you want something like filterFst :: (a -> Bool) -> [(a, b)] -> [(a, b)] ?
11:13:11 <Cale> tsousa: (==) itself is defined in the Prelude, whose source code is part of GHC, and there's a (more readable) mock implementation as part of the Report
11:13:27 <Cale> tsousa: Inside the Eq typeclass, whose source I've already written here :)
11:13:28 <Ikarus> I'm now doing, "filter (\ (m,n) -> m == n + 2) list" after first making the list of such pairs (mapPairs (n:m:p) = (n,m) : mapPairs(m:p))
11:13:44 <c_wraith> oh, you want to work with consecutive elements of the list
11:13:48 <Ikarus> yes
11:13:54 <Ikarus> sorry, if that wasn't clear
11:14:10 <tsousa> Cale, thanks
11:14:10 <Cale> tsousa: The various instances of Eq for different types say how (==) is implemented. For things like Integer and Char, it's mostly implemented in terms of compiler primitives.
11:14:15 <c_wraith> we usually think "(a, b)" if you say "pair".  That's where the confusion came from. :)
11:14:27 <Cale> tsousa: But for types like Bool, it's pretty easy to write the code out manually:
11:14:33 <Cale> instance Eq Bool where
11:14:57 <Cale>   True == x = x
11:14:59 <Ikarus> c_wraith: yeah, I was actually turning it into that first so it worked, but I was wondering if there was a one step method
11:15:01 <Cale>   False == x = not x
11:15:26 <Cale> Or any number of other equivalent things :)
11:15:32 <kmc> :t \xs -> and $ zipWith (\m n -> m == n + 2) xs (tail xs)
11:15:33 <lambdabot> forall b. (Num b) => [b] -> Bool
11:15:41 <tsousa> Cale, thank you
11:15:51 <c_wraith> kmc: not the same thing.
11:15:57 <kmc> no?
11:16:10 <c_wraith> kmc: that compares each thing to the next, not the first to the second, the third to the fourth, etc
11:16:19 <Ikarus> c_wraith: uh, no
11:16:25 <Ikarus> kmc's is right
11:16:34 <c_wraith> oh, you had m:p, not p
11:16:43 <Ikarus> I want to compare the 1st to the 2nd, the 2nd to the 3rd, etc
11:17:00 <Cale> tsousa: One thing which is rather interesting for people coming from an OO perspective is that typeclass methods are allowed to be polymorphic in their result type
11:17:28 <Cale> tsousa: for example, like with Read, where the result type of the read operation determines which instance is selected
11:17:37 <kmc> :t \(xs@(x:_)) -> zipWith (==) (iterate (+2) x) xs
11:17:37 <lambdabot> forall a. (Num a) => [a] -> [Bool]
11:17:40 <Cale> > read "[1,2,3]" :: [Integer]
11:17:40 <lambdabot>   [1,2,3]
11:17:54 <Cale> > read "[[1,2,3],[4,5]]" :: [[Integer]]
11:17:55 <lambdabot>   [[1,2,3],[4,5]]
11:17:59 <Cale> > read "[[1,2,3],[4,5]]" :: Integer
11:17:59 <lambdabot>   *Exception: Prelude.read: no parse
11:18:04 <Cale> > read "503" :: Integer
11:18:05 <lambdabot>   503
11:18:52 <kmc> :t all (== (-2)) . ap (zipWith (-)) tail
11:18:53 <lambdabot> forall a. (Num a) => [a] -> Bool
11:19:16 <AlexMurphy> Wow....first time here to ask a question and it gets answwered even before I say anything...
11:19:18 <Cale> This is possible because the typeclass methods travel along a "separate path" to where they're used from the data they act on, whereas in OO, your polymorphism is based on the methods and data travelling together.
11:19:31 <Cale> AlexMurphy: What was the question? :)
11:19:33 <Ikarus> oh also can I have generic functions like [any_type] -> [(any_type,any_type)] ? and if so what is the syntax for it
11:19:40 <kmc> Ikarus, that
11:19:58 <kmc> but typically type variables are a single letter
11:20:07 <Ikarus> ah, cool :)
11:20:07 <Cale> :t let f = map (\x -> (x,x)) in f
11:20:08 <lambdabot> forall a. [a] -> [(a, a)]
11:20:09 <kmc> especially if they're so generic as to be meaningless
11:20:14 <AlexMurphy> How to read an integer from a string by using "read"
11:20:18 <AlexMurphy> :D
11:20:19 <Cale> AlexMurphy: :)
11:20:29 <grangium> Hi guys. I want to take elements of an infinite list until they exceed a certain value. Any ideas? I've been racking my brain for a while now.
11:20:32 <Eduard_Munteanu> Ikarus: mind that's equivalent to [a] -> [(a, a)]
11:20:42 <Cale> AlexMurphy: Often you don't actually have to write the ":: Integer" bit. It's only there to disambiguate the types.
11:20:48 <Eduard_Munteanu> Not ... [(a, b)]   (which would be rather pointless)
11:20:53 <kmc> > let f :: [any_type] -> [(any_type,any_type)]; f = map (join (,)) in f "abc"
11:20:54 <lambdabot>   [('a','a'),('b','b'),('c','c')]
11:21:02 <Cale> AlexMurphy: If other operations you do to the result of the reading pin the type down, you don't have to specify it.
11:21:09 <AlexMurphy> Hmmm I see....
11:21:12 <kmc> > let f :: [a] -> [(a,a)]; f = map (join (,)) in f "abc"
11:21:13 <lambdabot>   [('a','a'),('b','b'),('c','c')]
11:21:16 <Ikarus> kmc: okay, I'm starting to love Haskell, sadly I won't be continuing in it until next year at uni (and urgh, until that time it's OO and procedural languages)
11:21:22 <kmc> > let f :: [Î±] -> [(Î±,Î±)]; f = map (join (,)) in f [1,2,3]
11:21:23 <lambdabot>   [(1,1),(2,2),(3,3)]
11:21:28 <kmc> Ikarus, you can do it in your free time!
11:21:32 <AlexMurphy> Thanks Cale!
11:21:37 <Cale> AlexMurphy: no problem!
11:22:07 <AlexMurphy> This is my first day so I will just carry on.... :D
11:22:31 <Ikarus> kmc: what free time :P
11:22:57 <Sgeo|web_> I don't like the behavior of the List monad when it comes to infinite lists
11:22:57 <Cale> It's also worth pointing out that in real non-throwaway programs, you're a good bit more likely to see reads, which gives a (possibly empty) list of parses, instead of failing completely when there's something which doesn't parse.
11:23:01 <Eduard_Munteanu> @free time
11:23:02 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `time'\n\n"
11:23:28 <kmc> http://haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
11:23:46 <Cale> Sgeo|web_: Other behaviours don't produce a valid monad instance.
11:24:08 <Cale> (at least, for lists)
11:25:04 <copumpkin> bos: ooh, you're implementing a fourier-based correlation function?
11:25:10 <Cale> If you ignore the order of the lists, they may. Sets form a monad, but unfortunately the Set datatype in Haskell can't be made an instance of Monad, because of the Ord requirement for all of the operations on Sets.
11:25:31 <Cale> (and on top of this, the Set datatype doesn't allow infinite sets)
11:25:42 <Sgeo|web_> Is this proven? What if you add extra information to each list, say, a type, data InfList a = InfList Integer [a]
11:26:14 <copumpkin> dolio was talking about how to make a type of finite lazy lists in haskell
11:26:19 <Eduard_Munteanu> Sgeo|web_: what's that integer for an infinite list?
11:26:40 <Cale> The problem is that when you diagonalise, you would have to do it in such a way that associativity holds
11:26:45 <Sgeo|web_> Eduard_Munteanu: that's not a length, that's... something that perhaps my hypothetical monad could use to keep track of something
11:27:04 <Cale> You need join . fmap join to be the same as join . join
11:29:30 <bos> copumpkin: using the discrete cosine transform to do a better kernel density estimation
11:30:25 <copumpkin> bos: ah okay :) while you're playing with frequency domains you could also possibly switch the correlation code on large datasets to use them
11:30:33 <copumpkin> but maybe that's a job for me to do rather than bitch at you to do :P
11:30:43 <bos> copumpkin: hee! patches welcome, as they say :-)
11:30:59 <bos> my fft code is very basic, but it's good enough for now
11:31:14 <bos> i didn't want to hook up to fftw, since that vastly reduces portability
11:31:30 <bos> actually i *did* want to hook up to fftw, but portability
11:32:08 <copumpkin> yeah, it'd be nice
11:32:13 <copumpkin> but then you'd have to bundle ocaml in your package
11:32:20 <copumpkin> and that'd be the worst for a haskell package
11:32:27 <bos> ha ha
11:32:44 <copumpkin> what this calls for is an epic yak shaving expedition
11:32:49 <copumpkin> in replicating and improving fftw in haskell
11:32:55 <bos> oh man
11:33:02 <bos> i've already shaved enough yaks in the past 18 months
11:33:06 <byorgey> yaks of the world, beware!
11:33:09 <copumpkin> :)
11:33:16 <copumpkin> just think of all the nice wooly sweaters though
11:33:19 <copumpkin> you can be a real hipster
11:33:23 * byorgey was just about to say that
11:33:36 <copumpkin> or even a non-hipster, with wooly sweaters
11:35:20 <bos> i live in the mission. all the hipness rubs off, even on me. it's osmotic.
11:36:38 <shachaf> bos: The slides for CS240h are great, by the way.
11:37:10 <bos> shachaf: thanks! i can't tell you how much fun it is teaching the class. funnest thing since ... something else that was very fun!
11:37:16 <Sgeo|web_> :t join . join
11:37:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
11:37:26 <Sgeo|web_> :t join . fmap
11:37:26 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
11:37:27 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
11:37:27 <lambdabot>     In the second argument of `(.)', namely `fmap'
11:38:02 <Sgeo|web_> :t fmap
11:38:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:38:14 <shachaf> bos: A coworker is in it, so I've heard a little bit about it. It sounds good.
11:38:37 <shachaf> Sgeo|web_: join . fmap join === join . join
11:41:57 <donri> someone needs to implement markov chains for type signatures for generating random programs
11:47:43 <kmc> i just used Hayoo to see if anyone implemented this function and it came back with one of my own libraries
11:47:44 <kmc> x_x
11:47:58 <dafis> Is there an understandable explanation of Safe Haskell anywhere? I don't half understand the stuff in the ghc wiki.
11:48:06 <kmc> not that i've seen dafis
11:48:20 <shachaf> kmc: What function?
11:48:27 <monochrom> @remember kmc i just used Hayoo to see if anyone implemented this function and it came back with one of my own libraries
11:48:27 <lambdabot> It is stored.
11:48:58 <kmc> safeRead :: (Read a) => String -> Maybe a
11:49:09 <kmc> looks like it's in 'cgi' too
11:49:18 <dafis> Does anybody actually understand Safe Haskell?
11:49:21 <kmc> and probably internal in a bunch of projects
11:50:09 <parcs> the safe package has that
11:50:25 <kmc> oh cool
11:50:35 <kmc> different name from mine, and Hayoo doesn't do a smart enough type-search
11:50:36 <kmc> thanks
11:50:40 <shachaf> The safe package has all the safe functions.
11:50:52 <shachaf> Is it called "readMay"?
11:50:58 <kmc> yes
11:50:59 <shachaf> Why doesn't Hoogle index all of Hackage?
11:51:22 <shachaf> kmc: And let me guess, there's also "readOct" and "readDec"? :-)
11:51:28 <parcs> dunno but hayoo does
11:51:31 <kmc> ;P
11:51:35 <dafis> The shame is that there's readEither in Text.read, but it's not exported
12:01:56 <kmc> yay:   headMay >=> readMay >=> flip IM.lookup pts
12:04:03 <monochrom> is that pig latin haskell? every word ends with the same suffix
12:04:24 <joevandyk> does haskell have anything this simple for inserting into a postgresql database?  https://gist.github.com/1299334
12:04:32 <monochrom> headMay >=> readMay >=> flip IM.lookupMay pts
12:04:58 <joevandyk> i couldn't figure out how to get haskelldb to work, persistent seems to want me to declare types for everything up front
12:07:44 <Veinor> weird
12:07:53 <Veinor> isn't f . g $ h supposed to be equal to f $ g $ h
12:08:22 <Veinor> ...
12:08:24 <Veinor> ha
12:08:31 <shachaf> Veinor: For the most part.
12:08:46 <shachaf> > id . runST $ return 5
12:08:47 <lambdabot>   Cannot match a monotype with `forall s. GHC.ST.ST s a'
12:08:48 <shachaf> > id $ runST $ return 5
12:08:49 <lambdabot>   5
12:08:52 <Veinor> apparently this doesn't necessarily hold in the presence of... yeah
12:09:09 <shachaf> Veinor: This one's even more fun:
12:09:14 <shachaf> > runST (return 5)
12:09:15 <lambdabot>   5
12:09:16 <shachaf> > id runST (return 5)
12:09:17 <lambdabot>   Couldn't match expected type `m t'
12:09:17 <lambdabot>         against inferred type `forall s....
12:09:19 <shachaf> > (id runST) (return 5)
12:09:20 <lambdabot>   5
12:09:21 <Veinor> nice
12:09:26 <dafis> Veinor: runST $ something isn't really well-typed, but there's a special exception for that
12:09:40 <danr> yeah, ($) isn't dependently typed
12:10:00 <Veinor> i'm not using runST though! i'm just using something kind of similar
12:10:16 <erus`> > let a . b c = b (a c) in (reverse . head) [1..10]
12:10:17 <lambdabot>   <no location info>: Parse error in pattern
12:10:50 <erus`> > let (.) a b c = b (a c) in (reverse . head) [1..10]
12:10:51 <lambdabot>   10
12:11:05 <erus`> im a 1337 hax0r
12:11:25 <dafis> erus`: let (.) = flip (Prelude.) ?
12:12:02 <erus`> i dont import the prelude, except for head and reverse
12:12:09 <dafis> err, Prelude.(.)
12:12:41 <dafis> erus`: unless you take stern measures, it is implicitly imported
12:12:44 <hpaste> DanBurton pasted â€œWhy ()?â€ at http://hpaste.org/52848
12:13:26 <dafis> DanBurton: defaulting
12:13:29 <erus`> i take those stern measures, and then some
12:14:03 <dafis> DanBurton: ghci defaults to () as type unless it has reasons to use some other type
12:15:51 <edwardk> shapr: good!
12:16:22 <shapr> edwardk: wot?
12:17:02 <DanBurton> dafis: that's...unsavory
12:17:09 <DanBurton> dafis: is there a way to change the default?
12:17:47 <DanBurton> I mean without adding type signatures
12:18:02 <dafis> DanBurton: I don't think so, you have to tell ghci which type to use, ghci> foo :: IO Integer
12:18:16 <synonymous> How can I get GHCi to show me the type synonym of the type i get with :t?
12:18:34 <DanBurton> :i String
12:19:10 <DanBurton> ghci should responds "type String = [Char]"
12:19:19 <DanBurton> should be similar for whatever type synonym you ask it
12:19:21 <synonymous> DanBurton: cheers
12:19:42 <DanBurton> s/responds/respond
12:19:45 <shapr> :t undefined
12:19:46 <lambdabot> forall a. a
12:20:09 <DanBurton> undefined can be anything! your imagination is the limit.
12:23:03 <synonymous> DanBurton: actually, it's doesn't work for my own type synonyms. Here:
12:23:03 <synonymous> Loading package dph-prim-live-0.5 ... linking ... done.
12:23:03 <synonymous> Prelude> type Str = [Char]
12:23:03 <synonymous> Prelude> let a = (['a','b']::Str)
12:23:03 <synonymous> Prelude> :t a
12:23:03 <synonymous> a :: Str
12:23:03 <synonymous> Prelude> :i a
12:23:04 <synonymous> a :: Str 	-- Defined at <interactive>:1:5
12:23:27 <DanBurton> no, you should use :i Str
12:23:41 <kmc> don't paste into the channel
12:23:43 <kmc> use hpaste.org
12:23:44 <DanBurton> a is the name of the variable, Str the name of the type
12:24:24 <synonymous> ah of course
12:24:28 <synonymous> kmc: ok
12:31:15 <sipa> :i undefined
12:31:40 <FUZxxl> I always wondered.
12:31:46 <JoeyA> Is there a portable way to test if a path is a regular file?
12:31:48 <FUZxxl> If we take combinatoric logic,
12:31:57 <FUZxxl> there is the combinator S.
12:32:04 <JoeyA> System.Directory.doesFileExist checks if it is not a directory.
12:32:14 <FUZxxl> Which is essentially equal to ap, instanciated for (x ->)
12:32:16 <JoeyA> Meaning doesFileExist "/dev/tty" returns True
12:33:09 <FUZxxl> There are two special cases for S, one if the first term is free in that variable (.) and one if the second term is free in that variable (flip).
12:33:20 <FUZxxl> If one writes those three type signatures:
12:33:20 <JoeyA> Alternatively, is there such a thing as a path that is neither a directory nor a file on Windows?
12:33:22 <tsousa> in this code what is f ? http://dpaste.com/637568/
12:33:37 <sipa> JoeyA: "con:"
12:33:50 <FUZxxl> ap   :: (x -> a -> b) -> (x -> a) -> (x -> b)
12:34:07 <FUZxxl> (.) :: (a -> b) -> (x -> a) -> (x -> b)
12:34:10 <JoeyA> (if it's a symbolic link, I actually want to follow it in this case)
12:34:26 <FUZxxl> flip :: (x -> a -> b) -> a -> (x -> b)
12:34:54 <FUZxxl> and generalizes the (x ->) to an arbitrary (applicative) functor, one gets quite interesting functions:
12:35:05 <FUZxxl> ap :: f (a -> b) -> f a -> f b
12:35:16 <FUZxxl> fmap :: (a -> b) -> f a -> f b
12:35:29 <JoeyA> sipa: Thanks
12:35:30 <FUZxxl> ??? :: f (a -> b) -> a -> f b
12:35:49 <copumpkin> :t flip
12:35:50 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
12:36:11 <copumpkin> you're welcome
12:36:13 <FUZxxl> While the first two should be familiar to any Haskell programmer, I wasn't aple to find a generalized version of the second one...
12:36:17 <FUZxxl> wtf
12:36:33 <FUZxxl> is that lambdabots generalization of everything that can't run fast enough?
12:36:35 <yrlnry> JoeyA:  Maybe getFileStatus is the thing you want here?
12:36:53 <FUZxxl> @hoogle Functor f => f (a -> b) -> a -> f b
12:36:53 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:36:53 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:36:53 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
12:36:57 <JoeyA> yrlnry: getFileStatus is not available on Windows.
12:37:06 <FUZxxl> @djinn Functor f => f (a -> b) -> a -> f b
12:37:06 <lambdabot> Error: Class not found: Functor
12:37:09 <JoeyA> (unless there's a compat module that provides it)
12:37:23 <yrlnry> JoeyA:  I thought Windows was supposed to provide POSIX calls.
12:37:33 <yrlnry> Oh well, if you say it's not there, I believe you.
12:37:41 <JoeyA> getFileStatus is in the unix package.
12:37:49 <JoeyA> The unix package is not available for Windows.
12:38:02 <yrlnry> It's in System.Posix.Files.
12:38:58 <JoeyA> Just wondering, why do so many packages work around NHC?
12:39:05 <JoeyA> Is NHC the Windows of Haskell compilers?
12:39:06 <FUZxxl> wow....
12:39:13 <FUZxxl> djinn can't deduce this function.
12:39:36 <Cale> FUZxxl: djinn can't deduce anything involving type constructor polymorphism and has no idea what functors are
12:39:47 <FUZxxl> I just typed:
12:39:47 <FUZxxl> Djinn> class Functor f where fmap :: (a -> b) -> f a -> f b
12:39:47 <FUZxxl> Djinn> ? f :: Functor f => f (a -> b) -> a -> f b
12:39:47 <FUZxxl> -- f cannot be realized.
12:39:54 <FUZxxl> Cale
12:40:04 <FUZxxl> Cale: Thanks for the information
12:40:43 <parcs> :t fmap . flip ($)
12:40:44 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
12:44:36 <johnfn> can anyone point me in a direction for using lenses when one of the data members is a list (i.e. a tree with a list of nodes)
12:45:05 <johnfn> the problem is that i want to compose some accessors like  (node 5 . node 2) or something to access into the lists of lists
12:45:20 * hackagebot nixos-types 1.2 - Data types representing the Nix language  http://hackage.haskell.org/package/nixos-types-1.2 (PeterSimons)
12:45:22 * hackagebot cabal2nix 1.18 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.18 (PeterSimons)
12:45:36 <johnfn> but i feel like i'm kind of in over my head...
12:45:44 <shachaf> johnfn: What's the problem?
12:45:48 <Cale> johnfn: that looks right
12:45:57 <shachaf> johnfn: A lens is just a (getter, setter) pair; you can define them however you want.
12:46:00 <copumpkin> johnfn: I think it only really makes sense to have a lens into the head/tail of a list, with a Maybe.
12:46:11 <copumpkin> maybe I'm wrong though
12:46:30 <johnfn> ok so say that i make this lens like children = lens ...
12:46:52 <Cale> You can have a lens into the nth subtree of a tree though... you might have to do some funny things when you set it and the previous subtrees don't exist.
12:47:05 <copumpkin> yeah, that's what I meant
12:47:20 <johnfn> i get kinda stuck because i need a constructor for a list, and i'm not quite sure if i have one
12:47:23 <copumpkin> you could easily get/set the head to Nothing/Just a
12:47:38 <copumpkin> but what if the list was empty and you set the 5th element to True?
12:47:44 <copumpkin> what do you do for the elements leading up to that?
12:47:52 <Saizan> children :: Lens Tree -> [Tree], so to compose two of them in a he needs a lifter from Lens a b to Lens [a] [b] i think?
12:48:04 <Saizan> *in a row
12:48:23 <Saizan> s/->//
12:49:39 * obk pings edwardk
12:49:51 * edwardk is pinged
12:49:54 <edwardk> brb
12:50:07 * obk enters a holding pattern
12:50:10 <dmwit> Lens Tree [Tree] for picking out children is easy; and Default a => Int -> Lens [a] a for picking out the nth element shouldn't be too hard.
12:50:13 <dmwit> Then just compose them.
12:50:24 <copumpkin> eww
12:50:25 <copumpkin> Default
12:50:33 * dmwit nods agreement
12:50:51 <johnfn> alright, let's see...
12:51:14 <dmwit> copumpkin: But many lens formalisms come with a "create" action which is essentially the same.
12:51:20 <copumpkin> ah
12:51:43 <dmwit> So, get :: s -> v; put :: v -> s -> s; and create :: v -> s for when you're just getting started.
12:52:04 <dmwit> It's theoretically a bit unsettling, but pragmatically quite important.
12:52:28 <dmwit> Of course, here is where edwardk will disagree with me and say you just shouldn't use lenses that rely on having a create. =)
12:53:18 <copumpkin> I'm sort of in that same boat :)
12:53:31 <dmwit> (e.g. edwardk is okay with a map lens for fixed-size lists, but not okay with a map lens for Haskell lists)
12:53:38 <copumpkin> I also like the s -> (v, v -> s) approach
12:54:08 <copumpkin> but I am by no means a lens guru
12:54:20 <dolio> They just aren't the same abstraction.
12:54:30 <dmwit> (fixed-sized lists are essentially tuples)
12:54:34 <copumpkin> sure
12:54:47 <wto> @pl foo xs ys = [ xs !! y | y <- ys ]
12:54:47 <lambdabot> foo = flip flip [] . ((:) .) . (<-) . (| y) . (!! y)
12:55:03 <dmwit> wto: ?pl doesn't do list comprehensions
12:55:15 <wto> that explains the weird code!
12:55:15 <dmwit> wto: (did you notice that "(| y)" in there? =)
12:55:16 <copumpkin> data FList a where FNil :: FList (); FCons :: a -> FList as -> FList (a, as)
12:55:22 <copumpkin> then you can use my awesome new All constraint
12:55:24 <dolio> It doesn't make sense to add "create a whole from a single part" to an abstraction for, "accessing part of a whole," in general.
12:55:36 <copumpkin> instance All Show as => Show (FList as) where
12:55:41 <dmwit> dolio: indeed not
12:55:48 <dolio> And Ed wants the former thing.
12:55:51 <yebyen> does anyone know if "ael reload" can still hose your open calls?  my boss says that he remembers getting burned that way before
12:55:58 <dmwit> dolio: Though it does make sense in a surprisingly large number of circumstances. =)
12:56:15 <dmwit> dolio: No, Ed wants to *avoid* the former thing. =)
12:56:27 <dolio> Oh, sorry, he wants the latter.
12:56:29 <dolio> I got my things reversed.
12:56:35 <dylukes> wto:
12:56:36 <dylukes> @pl foo xs ys = do y <- ys; return x !! y
12:56:36 <lambdabot> (line 1, column 23):
12:56:36 <lambdabot> unexpected ";"
12:56:37 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
12:56:41 <yebyen> oh shit
12:56:42 <yebyen> i'm in #haskell
12:56:53 <dylukes> @. pl undo foo xs ys = do { y <- ys; return x !! y }
12:56:53 <lambdabot> foo = const ((return x !!) =<<)
12:57:09 <dylukes> wto: There you are.
12:57:11 <dmwit> dolio: Both Ed and I want the latter. We just disagree on what "in general" means, I guess.
12:57:15 <dylukes> @undo foo xs ys = do { y <- ys; return x !! y }
12:57:16 <lambdabot> foo xs ys = ys >>= \ y -> return x !! y
12:57:20 <dylukes> @pl foo xs ys = ys >>= \ y -> return x !! y
12:57:21 <lambdabot> foo = const ((return x !!) =<<)
12:57:24 <dylukes> shazam
12:57:40 <dylukes> oherp
12:57:56 <dylukes> @. pl undo xs ys = do y <- ys; return xs !! y
12:57:57 <lambdabot> xs = fix ((=<<) . (!!) . return)
12:58:03 <dylukes> @. pl undo xs ys = do y <- ys; return (xs !! y)
12:58:04 <lambdabot> xs = fix (fmap . (!!))
12:58:04 <dmwit> ?pl \xs ys -> ys >>= \y -> return (xs !! y)
12:58:04 <lambdabot> fmap . (!!)
12:58:14 <dmwit> dylukes: Needs more parentheses... yeah
12:58:21 <dylukes> dmwit: mine has a fix point :P
12:58:39 <dylukes> because it's wrong
12:58:46 <dylukes> @. pl undo (\xs ys -> do y <- ys; return (xs !! y))
12:58:46 <lambdabot> fmap . (!!)
12:58:56 <kmc> anyone know of a Haskell package to approximate ellipses and cubic splines as piecewise linear?
12:58:56 <dylukes> Well that's... simpler than expected, huh.
13:01:00 <ben> How comes a binding like "let 1 = 0" isn't illegal? It seems fairly useless.
13:01:31 <c_wraith> Yeah, it's kind of sad bindings that don't bind a name are allowed
13:01:33 <ion> Should all useless bindings be illegal?
13:01:45 <edwardk> dmwit: i'm a bastard like that ;)
13:01:47 <parcs> because 1 is a pattern and 0 is a value
13:02:02 <c_wraith> ion: the class of "bindings that don't bind a name" is easy to identify, and clearly useless
13:02:06 <ben> ion: All useless things should be illegal so the compiler can tell me I am doing something that probably isn't buying me anything
13:02:27 <edwardk> dmwit: i just argue that neither of the two notions of lenses subsumes the other and serve very different roles
13:03:04 <ben> I suppose it becomes slightly less useless if you make it let !1 = someExpressionValuedZero as some sort of gimmicky assert()
13:03:12 <dolio> And that 'lens' was given your definition first, of course. :)
13:05:15 <hpaste> copumpkin pasted â€œthe power!â€ at http://hpaste.org/52849
13:06:17 <donri> http://www.haskell.org/ghc/docs/latest/html/users_guide/assertions.html -- this claims that you can assert with a custom message which seems incorrect. is there a separate way that otherwise behaves the same?
13:06:28 <dmwit> edwardk++
13:08:38 <dmwit> Your link doesn't claim anything like what you say it does.
13:08:56 <mrsolo> man Network.Browser example is so out of date....
13:09:27 <mrsolo> or i am looking at the wrong version? hmm
13:09:53 <donri> dmwit, yes, it does
13:09:56 <szerf> why hoogle does not to install under windows
13:10:18 <donri> ...define an extended assert function which also takes a descriptive string to include in the error message ... Ghc offers a helping hand here, doing all of this for you.
13:11:54 <ben> I suspect that this assert function is exposed as Control.Exception.assert
13:12:06 <donri> it is
13:12:24 <dmwit> Anyway, no, I don't know of a way to get this behavior on your own.
13:12:35 <donri> ok thanks
13:12:52 <dmwit> It's probably possible with a bit of Template Haskell.
13:12:56 <donri> of course
13:13:10 <donri> it's also quite sufficient already as-is, since it points to the source of the assertion
13:13:21 <donri> just would be nice to also throw in a descriptive error
13:13:36 <dmwit> szerf: Maybe you should paste what you tried and the error it gave you somewhere online for us to look at?
13:13:39 <dmwit> ?hpaste
13:13:39 <lambdabot> Haskell pastebin: http://hpaste.org/
13:14:16 <hpaste> szerf pasted â€œhoogleâ€ at http://hpaste.org/52850
13:14:28 * DanBurton thinks there should be a pragma {-# LANGUAGE AllTheGoodStuff #-} as a shortcut for...all the good stuff
13:14:53 <donri> szerf, are you doing this from cygwin?
13:15:07 <szerf> from cmd
13:15:17 <donri> DanBurton, GHC_OPTIONS -fglasgow-exts ? :)
13:15:26 <szerf> i type "cabal install hoogle"
13:15:27 * ben thinks you should be able to activate extensions via import declarations and also reexport them
13:15:31 <donri> szerf, the error suggests you should try it in cygwin
13:15:56 <szerf> but where can i find cygwin ?
13:16:03 <donri> @google cygwin
13:16:04 <lambdabot> http://www.cygwin.com/
13:16:04 <lambdabot> Title: Cygwin
13:17:15 <DanBurton> @faq Hey Lambdabot, could you get a Hayoo extension?
13:17:16 <lambdabot> The answer is: Yes! Haskell can do that.
13:21:17 <DasIch> if I want to parse something like python or css whose encoding is defined with an optional declaration what would be the best way to go about that?
13:22:34 <Botje> cheat from an existing python/css parser ;)
13:23:12 <kmc> how does the declaration work
13:27:33 <donri> DasIch, http://hackage.haskell.org/package/language-python not doing it for you?
13:28:12 <DasIch> donri: "like"
13:30:10 <DasIch> donri: i'll look into what the parser does though, thanks
13:31:09 <donri> well typically you require the declaration to be in the first few lines which themselves must be compatible with a predefined encoding such as ASCII
13:31:53 <donri> so ... decode the first few lines as ASCII and see if there is such a declaration?
13:32:22 <donri> sorry if I'm being cap'n obvious, just not sure what you're really asking :)
13:33:11 <DasIch> donri: hReadLine doesn't exist ;)
13:33:33 <tsousa> Can someone please help me understand how can i do exercise 7 on 99 haskell problems? http://www.haskell.org/haskellwiki/99_questions/1_to_10
13:33:45 <kmc> tsousa, what did you try?
13:34:02 <tsousa> kmc, i dont know how to esolate the elemets
13:34:06 <donri> DasIch, but hGetContents et al are lazy so you can easily unlines after decoding ASCII
13:34:11 <kmc> esolate?
13:34:20 <kmc> tsousa, for this problem you have to define a new data type
13:34:23 <kmc> did you do that?
13:34:26 <donri> uh, lines*
13:35:01 <donri> assuming the decoding procedure is lazy too
13:35:08 <tsousa> kmc, like [[a,b]] and i need to extrat the b on all ?
13:35:13 <kmc> no
13:35:19 <donri> map snd
13:35:38 <kmc> tsousa, look at the examples.  List and Elem aren't defined for you in Haskell
13:35:43 <kmc> they're part of a new data type which you must define
13:35:49 <donri> esolate = isolate
13:35:52 <kmc> do you know how to define algebraic data types?
13:36:11 <tsousa> kmc, yes
13:36:14 <kmc> ok
13:36:23 <kmc> what's your definition of this type look like?
13:36:37 <kmc> as a first test, make sure you can type a value lik e(List [Elem 1, List [Elem 2, List [Elem 3, Elem 4], Elem 5]]) at ghci
13:36:52 <kmc> without having yet defined 'flatten'
13:37:24 <tsousa> Elem just add another element right?
13:37:34 <kmc> i don't know what that question means
13:38:10 <kmc> a NestedList is an Elem, or it's a List of NestedList's
13:38:19 <kmc> do you have a 'data' definition which matches that?
13:38:43 <tsousa> kmc, i dont think so
13:38:47 <kmc> ok
13:38:55 <kmc> what's your 'data' definition look like?
13:39:08 <kmc> (it doesn't matter whether you call it NestedList or something else)
13:39:18 <tsousa> kmc, i did not yet code anything i am still thinking in how i will do it
13:39:22 <kmc> ok
13:39:34 <kmc> well you have to define the data type first
13:39:39 <kmc> that's arguably part of the problem, not the solution
13:39:45 <kmc> arguably they should give it to you, but you'll learn more this way
13:39:56 <kmc> anyway once you have the data type you can define 'flatten' in the usual way
13:40:03 <tsousa> ok
13:40:12 <kmc> which is: pattern-matching on the constructors of its argument type
13:40:17 <tsousa> so i only need to declare the list type right?
13:40:25 <kmc> i don't know what that question means
13:41:00 <kmc> to solve the problem you need to define the type and then define this 'flatten' function
13:41:13 <kmc> you can define the type and test that before you define 'flatten'
13:41:17 <kmc> i recommend doing so
13:42:20 <tsousa> kmc, my doubt is what is Elem in that. i know how to declare the list type. the problem is that i dont know what is Elem in all that
13:42:34 <kmc> it's one of the data constructors declared along with your type
13:42:38 <kmc> @src Maybe
13:42:38 <lambdabot> data Maybe a = Nothing | Just a
13:42:45 <kmc> this declares a type constructor Maybe, and data constructors Nothing and Just
13:43:12 <kmc> you can tell it's a constructor because its name starts with an upper-case letter
13:45:03 <danr> Um, what do you think about this if-then-comment-do-indentation style? http://hpaste.org/52851
13:45:47 <dylukes> danr: seems reasonable to me.. I'd usually do
13:45:48 <dylukes> then do
13:45:51 <dylukes>   useFunPtr ...
13:46:02 <Cale> It's fine
13:46:18 <kmc> hackage has about 20% as many packages as PyPI
13:46:23 <danr> dylukes: yeah that's what I usually do, but I didn't want my line to be > 80 chars so I had to compromise a little
13:46:28 <danr> Cale: ok :)
13:46:36 <Cale> It's almost exactly how I'd indent it, except that I'd indent the 'do' a few more spaces so that it is where it would be were it on the same line as the 'then' or 'else'
13:46:38 <dylukes> as long as its labile its flexible
13:46:44 <dylukes> I wonder how to format this though:
13:46:54 <Cale> and the rest of that block accordingly
13:47:00 <dylukes> shuntingyard = callCC $ \k -> loop $ do { .... }
13:47:27 <Cale> But given that it doesn't start on the same line, it's okay as long as it's deeper than the 'then' or 'else' and everything lines up like that
13:47:32 <dylukes> loop p = fix (p >>) but thats another story
13:47:40 <dylukes> @pl (\p -> fix (p >>))
13:47:41 <lambdabot> fix . (>>)
13:47:46 <Saizan> loop = forever
13:48:08 <dylukes> oh true
13:48:21 <dylukes> anyways
13:48:32 <danr> I like forever = fix . (>>)
13:48:37 <dcoutts> kmc: your 20% is remarkably close, did you have to look that up? :-)
13:48:57 <kmc> i looked up the two numbers and divided
13:49:04 <dylukes> I'm trying to figure out how to get shunting yard with prefix/postfix/infix...
13:49:04 <Cale> dylukes: In cases like that, I tend to break the line after \k ->
13:49:05 <kmc> i did the division in python ;)
13:49:13 <dcoutts> heh, I did the division in hugs
13:49:21 <Cale> (If you're asking about layout)
13:49:25 <kmc> haha
13:49:31 <kmc> lambda: the ultimate desk calculator
13:50:30 <kmc> and about 15% of CPAN
13:51:16 <scooty-puff> is possible to restrict the scope of a data declaration to a single function?
13:51:23 <kmc> no
13:52:06 <scooty-puff> k
13:53:47 <preyalone> Anyone interested in porting Haskell to Haiku OS? I started a ticket at http://hackage.haskell.org/trac/ghc/ticket/5347
13:54:03 <kmc> by Haskell you mean GHC?
13:54:31 <preyalone> kmc: Yes.
13:54:54 <preyalone> cabal, etc etc would be good too, but we have to start from scratch
13:56:36 <Cale> Well, once you have GHC building, your job would likely be mostly complete, in that most of the other tools are written entirely in Haskell.
13:56:57 <kmc> once you have GHC and all the GHC-bundled libraries building
13:56:59 <dcoutts> preyalone: does haiku have a normal working toolchain, like gcc, make, autoconf etc?
13:57:08 <Cale> yes :)
13:57:16 <kmc> you'll have trouble with e.g. the 'unix' and 'Win32' packages
13:57:32 <kmc> iirc Haiku supports neither API, and there's lots of code that depends on having one or the other
13:57:42 <dcoutts> right, and the rts will not build
13:57:55 <dcoutts> and base assumes either unix or win32
13:58:17 <shachaf> I thought Haiku was vaguely unixy?
13:58:21 <kmc> yeah, you need to write platform-specific code for stuff like memory management
13:58:41 <preyalone> So the code will have to add #ifdef haiku directives, makefiles too.
13:58:42 <kmc> and of course GHC has to do mundane things like read and write files
13:59:02 <preyalone> I avoid the IO monad myself.
13:59:21 <preyalone> :)
13:59:50 <kmc> how do you, er, get things done?
14:00:26 <preyalone> kmc: jk, but I suppose you could input everything manually in GHCi
14:00:35 <Cale> You presumably want to see the results of your computations still, which will require some I/O somewhere to be working :)
14:00:43 <kmc> GHCi's prompt is basically an IO monad "do" block
14:00:48 <preyalone> aye
14:00:51 <kmc> with some extra sugar
14:02:04 <preyalone> Yeah, we'd have to write custom memory management code for GHC/Haiku.
14:02:12 <preyalone> But that's not even your first problem.
14:02:38 <preyalone> The "boot" script uses a bad shebang, so it can't find Haiku's perl.
14:04:28 <dcoutts> preyalone: I was just looking for docs on haiku's api, can't find any docs on the kernel kit, ie memory/threads/etc
14:06:20 <dcoutts> oh found it
14:10:18 <preyalone> Could future versions of GHC use a more general shebang in the Perl boot script? Something like #!/usr/bin/env perl
14:10:27 * hackagebot randfile 0.1.0.0 - Program for picking a random file  http://hackage.haskell.org/package/randfile-0.1.0.0 (JoeyAdams)
14:10:32 <shachaf> preyalone: I think you're supposed to pass -w to perl, or something.
14:10:41 <preyalone> https://gist.github.com/943516
14:10:41 <shachaf> Well, if they don't do that, then presumably it's possible.
14:21:27 <alpounet> edwardk, you around ?
14:25:27 * hackagebot kit 0.7.8 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.8 (NickPartridge)
14:27:01 <hpaste> int80_h pasted â€œproblem with mreq from Yesod.Form.Functionsâ€ at http://hpaste.org/52852
14:30:25 <Gabriel_> test
14:31:11 <Gabriel_> hello ?
14:32:04 <RaptorRarr> Rarr?
14:33:11 <Gabriel_> I need homework help... involving instances of class Show
14:34:27 <joe9> stuck in a compilation corner: I have a bunch of .hs files in a directory, each separate from the other. There is no Main.hs, each .hs file that I care about has a main :: IO () function. When I do a ghc --make, is there anyway I can tell ghc what the main function is?
14:34:36 <RaptorRarr> show Rarr = "Rarr"
14:34:54 <kmc> joe9, did you see ghc -main-is ?
14:35:17 <kmc> but i suggest cabalizing your project and using multiple "executable" stanzas
14:35:30 <joe9> i did, but, I thought that is for specifying the Main module, not the function. let me doublecheck.
14:35:48 <kmc> i thought you said they were all named 'main'
14:35:54 <kmc> also those aren't functions
14:37:01 <donri> with safe haskell, does "import safe" imply -XSafe in the imported module if it doesn't know about safe haskell itself?
14:37:10 <int80_h> kmc: could you offer an opinion on the nature of the instance error I posted? I don't think it's actually complaining about a missing instance.
14:37:11 <Gabriel_> so I have a data type Pf a =Equal a a, and I want to create an instance definition which says that if a type a is in the class Show, the type Pf a is also in the class Show
14:38:08 <int80_h> kmc: I mean I don't think the problem is a missing instance
14:39:04 <Gabriel_> so like i have , instance Show (Pf a) where show (Equal x y) = show x ++ "=" ++ show y
14:42:02 <RaptorRarr> Gabriel_: instance Show a => Show (Pf a)
14:50:19 <Gabriel_> ahhhhhhh thanks
14:51:12 <Sgeo|web> What uses are there for fix beyond anonymous recursive functions?
14:51:35 <edwardk> alpounet: yep
14:52:06 <ion> > fix ("anonymous recursion" :)
14:52:06 <lambdabot>   ["anonymous recursion","anonymous recursion","anonymous recursion","anonymo...
14:53:01 <ion> Not restricted to functions, really.
14:53:04 <Sgeo|web> > :t Tree
14:53:04 <lambdabot>   <no location info>: parse error on input `:'
14:53:14 <Sgeo|web> :t Tree
14:53:14 <lambdabot> Not in scope: data constructor `Tree'
14:53:41 <RaptorRarr> > fix brokenThing
14:53:42 <lambdabot>   Fixed.
14:53:48 <Entroacceptor> Sgeo|web: it's Node a
14:53:56 <RaptorRarr> Very useful for fixing broken things.
14:54:04 <Sgeo|web> :t brokenThing
14:54:05 <lambdabot> forall t. t -> Doc
14:54:09 <ion> (The parameter to fix is always a function indeed.)
14:54:28 <Sgeo|web> > brokenThing 5
14:54:30 <RaptorRarr> See, brokenThing needs to go to a Doc.
14:54:30 <lambdabot>   Fixed.
14:54:51 <RaptorRarr> It's all very consistent like that.
14:55:04 <Sgeo|web> How do I use Trees in lambdabot?
14:55:09 <RaptorRarr> The types tell all.
14:56:29 <Sgeo|web> I mean, under what thingy is it
14:56:34 <Sgeo|web> :t Data.Tree.Tree
14:56:35 <lambdabot> Not in scope: data constructor `Data.Tree.Tree'
14:56:36 <alpounet> edwardk, did you get my @tell ?
14:56:54 * Sgeo|web might be a bit lazy >.>
14:56:54 <RaptorRarr> Sgeo|web: I don't think lambdabot has any trees loaded.
14:57:15 <edwardk> probably
14:57:17 <RaptorRarr> Sgeo|web: Someone was playing around and told lambdabot to deforest the area.
14:57:19 <edwardk> i forgot its contents
14:57:25 <edwardk> but i'm pretty sure i received it
15:00:24 <Entroacceptor> the constructor to Tree is Node a (Forest a)
15:00:50 <Entroacceptor> :t Node 5
15:00:51 <lambdabot> forall t. (Num t) => Forest t -> Tree t
15:01:23 <Entroacceptor> can't type braclets atm :)
15:01:40 <Entroacceptor> *brackets
15:01:55 <Sgeo|web> :t Node
15:01:56 <lambdabot> forall a. a -> Forest a -> Tree a
15:02:10 <Sgeo|web> :t Node 5 2
15:02:11 <lambdabot> forall t. (Num t, Num (Forest t)) => Tree t
15:02:18 <hpc> :t Node 3 []
15:02:19 <lambdabot> forall t. (Num t) => Tree t
15:02:28 <dmwit> :t Node 5 [Node 2 []]
15:02:29 <lambdabot> forall t. (Num t) => Tree t
15:02:31 <hpc> type Forest t = [Tree t]
15:02:34 <Sgeo|web> Ok, this might not be quite what I want
15:02:37 <Sgeo|web> Oh, hmm
15:02:57 <Sgeo|web> Yeah, I think I had the wrong notion of "tree"
15:03:12 <hpc> or a notion of the wrong kind of tree
15:03:54 <Entroacceptor> how do you want your trees, then?
15:05:54 <alpounet> edwardk, it was about ad
15:09:42 <jrgarcia> I have a question about the Recursion section of Learn You a Haskell if someone has a moment to discuss...
15:10:22 <Entroacceptor> maybe? how will we ever know
15:10:40 <monochrom> that is the Halting Problem for recursion :)
15:10:54 <jrgarcia> My question is on the implementation of take' in the Recursion section.
15:11:04 <hpc> monochrom: clearly we need software transactional questioning, to avoid these deadlocks
15:11:22 <jrgarcia> I get everything up until the last line.
15:11:24 * monochrom wants software transaction irc, too
15:11:36 <jrgarcia> I understand most of that but it looks as though it is returning x each time.
15:11:56 <jrgarcia> When does each x being returned together get combined into a list?
15:12:05 <aristid> monochrom: clearly it is a fault of the universe that it does not provide true transactions
15:12:37 <edwardk> alpounet: i remember you mentioning somethingabout usingit for some kinda process stuff now that you mention it again
15:12:38 <jrgarcia> 'x' being the head of the list passed to take'
15:12:53 <jmcarthur> jgroszko: due to laziness, the list is constructed before any of its elements (i haven't looked at the example you are talking about though)
15:13:05 <jmcarthur> well, the cons constructor is, anyway
15:13:05 <Sgeo|web> Try Haskell's lessons seem to be a bit too space-sensitive
15:13:20 <monochrom> no, different x each time
15:13:21 <jmcarthur> jrgarcia: do you have a link to the page?
15:13:42 <jrgarcia> jmacarthur: http://learnyouahaskell.com/recursion about halfway down the page
15:13:55 <jmcarthur> ah i see
15:13:57 <monochrom> search for take'
15:14:12 <monochrom> do you already know pattern-matching?
15:14:15 <jrgarcia> Yeah
15:14:42 <jrgarcia> I understand how it gets to that line and I understand the recursion going on in that line. I just don't understand how it's being pushed out as a list
15:14:49 <Entroacceptor> the :
15:14:58 <hpc> > 1 : 2 : 3 : []
15:14:59 <lambdabot>   [1,2,3]
15:15:01 <hpc> :t (:)
15:15:02 <lambdabot> forall a. a -> [a] -> [a]
15:15:08 <jrgarcia> Oh... Yeah the :
15:15:09 <hpc> > 1 : [2, 3]
15:15:09 <lambdabot>   [1,2,3]
15:15:18 <monochrom> if I give actual parameter (4:(0:(5:[])), and it is pattern-matched against the pattern (x:xs) (because that's how the formal parameter is written), x becomes 4, xs becomes (0:(5:[]))
15:15:24 <sipa> jrgarcia: there is no such thing as "pushing out as a list"
15:15:32 <jrgarcia> I'm new to Haskell. Mostly a Ruby/C# programmer.
15:15:39 <sipa> you just have a series of : constructors
15:15:46 <jrgarcia> I just saw the : as a separation not as adding to a list.
15:15:48 <alpounet> edwardk, yeah, i would like to implement gradient descent
15:15:48 <jmcarthur> take 3 [1,2,3,4,5]  ==>  1 : take (3 - 1) [2,3,4,5]  ==>  1 : 2 : take (2 - 1) [3,4,5]  ==>  1 : 2 : 3 : take (1 - 1) [4,5]
15:16:01 <monochrom> ok, next, you recurse. so this time my actual parameter is (0:(5:[])), it is pattern-matched against (x:xs), this time x is 0
15:16:14 <alpounet> for several AI stuffs i wanna implement
15:16:17 <monochrom> you also see that empirically this works
15:16:18 <jmcarthur> jrgarcia: i think the easiest way to envision evaluation in haskell is to view it as a series of reductions
15:16:37 <jmcarthur> (as opposed to some idea of "execution")
15:16:44 <hpc> jrgarcia: revisit the stuff on data types once you are done reading through the recursion chapter
15:16:52 <jmcarthur> i mean *symbolic* reduction
15:16:55 <jrgarcia> sipa: excuse my crude terminology. I'm new to FP.
15:16:57 <hpc> it'll help you put all the pieces together, so to speak
15:17:07 <sipa> jrgarcia: no need to apologize
15:17:27 * jmcarthur notes that everybody else is saying things that appear unrelated to my answer, which may imply that i have misinterpreted the question
15:17:42 <jrgarcia> jmcarthur: Yeah, I see it now. It all makes sense, I'm just not used to reading this syntax.
15:18:08 <jrgarcia> Thanks, guys! You've been really helpful so far today! Best community I've dealt with yet.
15:18:08 <monochrom> well, there is always the question "but why your reduction steps"
15:19:03 <monochrom> and then you will have to go back to "(:) is a data constructor, and reduction rules concerning pattern-matching and data constructor say so"
15:19:55 <monochrom> the root is recognizing (:) as a data constructor rather than an abstract function
15:20:22 <alpounet> edwardk, can i rely on ad ?
15:20:29 <alpounet> is it efficient ?
15:20:46 <edwardk> yes
15:20:47 <edwardk> and yes
15:20:53 <monochrom> and also "data constructor" is not what other languages say about constructors
15:21:19 <edwardk> its been used rather extensively in scenarios with 10s of thousands of variables
15:24:52 <alpounet> edwardk, ok, i'll start using it for multilinear regression (next version of statistics-linreg) i think
15:25:27 <edwardk> sounds like a plan. let me know if it acts funny but i don't think it'll be a problem
15:26:38 <alpounet> edwardk, the interface is not that straightforward to get
15:26:42 <alpounet> but it should be quite easy
15:26:49 <alpounet> i suppose Vector is supported
15:26:53 <alpounet> since it's Traversable and all
15:26:59 <edwardk> yep
15:27:26 <edwardk> the main thing to consider is that the functions like diff take a function from an (AD s a -> AD s a)  and give you one from a -> a
15:27:43 <edwardk> the AD types are magically members of whatever numeric classes you have on a
15:27:49 <edwardk> that is why the crazy classes
15:28:08 <alpounet> ok
15:28:35 <alpounet> edwardk, ok. i'll start working on it in two weeks i think. I'll spend one week partying in sweden, then exams
15:28:39 <alpounet> matter of priorities.
15:29:09 <edwardk> FU f a ~ f (AD s a) -> AD s a       UF f a ~ AD s a -> f (AD s a)    UU a ~ AD s a -> AD s a       FF f g a ~ f (AD s a) -> g (AD s a)
15:29:26 <edwardk> basically they are shorthand for whether or not it takes a functor/foldable/traversable or a single value on each side
15:29:36 <JoeyA> You can't say unsafePerformIO $ atomically $ ..., but can you say atomically $ unsafePerformIO $ ... ?
15:29:39 <edwardk> that is probably the ugliest thing about reading the signatures
15:30:03 <alyx4234> hey can anyone tell me how to do this, Give definitions of the functions: between :: Int -> Int -> Int -> Bool ( between m n p returns True if n is between m and p )
15:30:04 <edwardk> grad (\[x,y] -> x * cos y) [1,2]
15:30:12 <edwardk> or vgrad (*) 1 2
15:30:35 <edwardk> grad checks that you don't have any perturbation confusion
15:30:45 <alpounet> edwardk, what does FU, UF and UU stand for by the way ?
15:30:47 <monochrom> between m n p = (m<n && n<p) || (p<n && n<m)
15:30:47 <edwardk> vgrad isn't capable of it due to limitations of haskell's type system
15:30:54 <edwardk> functor to unary, etc.
15:31:00 <alpounet> oh ok
15:31:08 <alyx4234> thank you mono
15:31:09 <edwardk> F = Functor or Foldable    U = Unary
15:31:35 <alpounet> in my case it's gonna be functor to unary then
15:31:36 <alpounet> nice
15:31:39 <RaptorRarr> compare m n == compare n p
15:31:46 <alpounet> i'll be able to work smth out quite quickly
15:31:50 <shachaf> JoeyA: You can say either, but you can't nest "atomically"s.
15:31:56 <monochrom> RaptorRarr wins
15:31:57 <shachaf> And you probably oughtn't do both.
15:32:04 <RaptorRarr> Rarr!
15:32:18 <JoeyA> shachaf: "cannot use atomically inside an unsafePerformIO or unsafeInterleaveIO. Any attempt to do so will result in a runtime error."
15:32:24 <JoeyA> http://hackage.haskell.org/packages/archive/stm/latest/doc/html/Control-Monad-STM.html#t:STM
15:32:28 <JoeyA> "You cannot *
15:32:41 <angstrom> `\n xs -> map (take n) $ tails xs'  <-  is there already something in the std lib, that does this? I can't seem to find anything in Data.List
15:32:46 * companion_cube is going to be careful not to write gotos when RaptorRarr is around
15:33:00 <RaptorRarr> What?
15:33:07 <RaptorRarr> Raptors get excited by gotos!
15:33:32 <shachaf> JoeyA: I think you can.
15:33:36 <JoeyA> Thanks
15:33:44 <shachaf> JoeyA: But if that thunk happens to be forced inside another atomically block, it'll fail.
15:33:53 <shachaf> Whoops.
15:34:01 <shachaf> I hope I didn't leave JoeyA with misinformation.
15:34:20 <edwardk> alpounet: look at the code in Numeric.AD.Newton and Numeric.AD.Halley for naive gradient descent
15:34:26 <RaptorRarr> For instance: http://stackoverflow.com/questions/3829761/fastest-way-to-get-the-number-in-tail-of-a-string/3843642#3843642
15:34:54 <RaptorRarr> goto improves that code!
15:36:51 <monochrom> eh? C? weak!
15:37:16 <monochrom> this is why Haskell supports arbitrary recursion. a better goto than goto.
15:37:40 <shachaf> FSVO "better"
15:37:54 <hpc> monochrom: because the only thing less readable than a goto is the CPS-transform of a goto
15:38:01 <kmc> it's so unsafe that they *actually check for it*
15:38:13 <alpounet> edwardk, awesome thanks!
15:39:08 <shachaf> kmc: elliott was complaining bitterly about that check in here recently.
15:39:10 <kmc> hmm Â«unsafePerformIO . atomically $ return 'x'Â» works in my ghci
15:39:20 <kmc> as well as some other trivial examples
15:39:27 <shachaf> kmc: Yes, it works, unless you happen to force it inside another atomically block.
15:39:31 <kmc> oh, i see
15:39:33 <shachaf> As you almost always will.
15:39:36 <shachaf> (I assume.)
15:39:37 <edwardk> alpounet: i have some other code lying around for doing newton's method when you are swimming in a space with an extra degree of freedom (e.g. homogeneously)
15:40:04 <kmc> then the alternative to the check is certain heap corruption of the structures implementing transactions, no?
15:40:21 <edwardk> somewhere else i should have code for doing so in spaces of hyperbolic signature as well
15:40:21 <kmc> iow sounds like the check is not conservative, it's just a nicer error message than segfault
15:40:48 <kmc> oh edwardk!
15:40:55 <edwardk> kmc: wassup?
15:41:02 <ddarius> Segfault would be the ideal situation.
15:41:11 <kmc> any tips on approximating parametric functions as piecewise linear
15:41:17 <ddarius> Mmm, Minkowski space.
15:41:19 <kmc> (in R2 say)
15:41:20 <kmc> do you know of existing haskell code to do this?
15:41:45 <edwardk> well, the trick is finding nice sample points
15:42:10 <hpc> kmc: start at x=0, interpolate with more points until error becomes unacceptable, then interpolate again past that?
15:42:10 <edwardk> linear is awkward. not able to go to polynomial?
15:42:25 <alpounet> edwardk, ok, i'm not gonna need this for now but would gladly take a look at it some time soon
15:42:38 <hpc> or polynomial interpolation followed by piecewise interpolation of that
15:43:12 <kmc> edwardk, maybe quadratic splines
15:43:14 <edwardk> http://www2.maths.ox.ac.uk/chebfun/ gives you a toolbox for piecewise approximation with chebyshev polynomials
15:43:32 <kmc> edwardk, but I could see sampling an arbitrary parametric function to polynomial, and then doing a polynomial-aware linear approximation of that
15:43:59 <kmc> i assume you can compute a closed form for the approximation error of a linear segment vs a polynomial, and subdivide until that's small
15:44:03 <edwardk> i was porting that to haskell when i veered off to playing with pade approximants and piecewise chebyshev-pade approximation, but that uses rational functions
15:44:06 <kmc> but not vs. an arbitrary functional
15:44:15 <kmc> function*
15:44:33 <edwardk> that'd work though you'd have two sources of error =/
15:44:38 <kmc> right
15:44:54 <ddarius> Doing the math starting from a polynomial would be pretty straightforward.
15:45:41 <edwardk> what kind of information do you have about the function? just a bunch of point samples? derivatives?
15:45:57 <edwardk> and how many samples relative to how many pieces are you looking for?
15:46:11 <kmc> i was hoping to do it from an arbitrary function (R -> R2) under some general assumption of differentiability etc
15:46:12 <edwardk> i mean in the limit you can just say sample every so often and use that as the linear guess ;)
15:46:16 <kmc> sure
15:46:34 <donri> RWH says large left folds should result in a stack overflow exception, but i instead got out of memory (requested 2097152 bytes)
15:47:21 <edwardk> donri: ghc will sometimes shift stuff from the stack to the heap, both are bad ;)
15:47:22 <kmc> and slightly less dumb, you can pick an Îµ and decrease Î”t until |f(t+Î”t) - f(t)| < Îµ
15:47:32 <edwardk> sure
15:47:51 <kmc> edwardk, the concrete problem at hand is that I want to write a G-code backend for 'diagrams'
15:47:55 * ddarius considers using a gaussian process model instead.
15:47:58 <kmc> for codes like these http://linuxcnc.org/docs/html/gcode.html
15:48:05 <edwardk> do you have anything you know about the function at all? convexity, etc?
15:48:16 <kmc> and i want to deal with ellipses as well as cubic splines
15:48:23 <kmc> 'cause both of those are primitives in 'drawings'
15:48:27 <kmc> but a more general solution would be fun :)
15:49:25 * fryguybob looks up and sees both diagrams and g-code in the same sentence.
15:49:36 <kmc> hi fryguybob!
15:49:42 <kmc> byorgey said I should talk to you about this project :)
15:50:04 <fryguybob> I have experience in both areas :D.  Diagrams was fun, g-code, not as much.
15:50:08 <kmc> heh
15:50:21 <fryguybob>  /was/is/
15:51:45 <alyx4234> im sorry to bother you guys again, but i need to define howManyequal :: Int -> Int -> Int -> Int, where the function shows how how many of its three arguments are equal, ex howManyEqual 34 25 34 = 2 thanks
15:52:26 <kmc> countEqual x xs = length (filter (== x) xs) -- alyx4234 this should help
15:52:36 <shachaf> alyx4234: Why do you need to define that? Seems like a weird function.
15:52:42 <kmc> "homework"
15:52:54 * kmc guesses
15:52:55 <alyx4234> thanks alot, im new to programming and am taking a intro course
15:53:02 <alyx4234> at uni
15:53:14 <alyx4234> part of the lab and my prof doesnt help
15:53:20 <kmc> fryguybob, so, any words of wisdom for me in this project?
15:53:44 <kmc> i will probably do linear approximation for everything (except possibly special-casing circular ellipses)
15:54:10 <fryguybob> It should be fairly straight forward, I don't remember what all you get for G-code I think it is abstract enough that if some machine can handle beziers you can give it some code for that.
15:54:11 <kmc> should be possible to pick a reasonable step size from an ellipse or cubic
15:54:34 <kmc> i'm targeting EMC2's g-code
15:54:47 <kmc> http://linuxcnc.org/docs/html/gcode.html
15:55:04 <kmc> it has... lines and circular arcs
15:55:24 <kmc> also quadratic b-splines and NURBs but it's not clear if anyone uses these
15:55:28 * hackagebot crypto-api 0.8 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.8 (ThomasDuBuisson)
15:56:31 <ddarius> Cast it into conformal geometry so you can optimize things to use arcs as well as lines.
15:57:13 <fryguybob> kmc: So for any given machine there is going to be some "resolution" that is somewhat optimal for it.  Typically things that consume g-code are not going to put much processing power on to it so you would want to approximate with those constraints in mind.
15:58:18 <fryguybob> For example, if you give it a circle with a huge radius that is basically a line it may not just be sub-optimal, it may do the wrong thing.
15:59:15 <kmc> hmm
15:59:21 <kmc> yeah
16:00:00 <fryguybob> Beziers are nice because you can subdivide and stay rational, there are some examples of that in diagrams that you could adapt to get line segments very easily.
16:00:19 <kmc> oh cool
16:00:22 <kmc> where's that?
16:00:24 <fryguybob> We also have conversion from cubic splines to beziers.
16:00:37 <kmc> ok, this is what i wanted to hear :)
16:01:17 <fryguybob> Looking for the code...
16:03:10 <fryguybob> http://www.patch-tag.com/r/byorgey/diagrams-lib/snapshot/current/content/pretty/src/Diagrams/CubicSpline.hs
16:03:51 <fryguybob> http://www.patch-tag.com/r/byorgey/diagrams-lib/snapshot/current/content/pretty/src/Diagrams/Segment.hs
16:04:39 <fryguybob> The Segment.hs code has arcLength and splitAtParam that kind of show how the subdivision works.
16:05:11 <fryguybob> byorgey worked out expansion and trimming by length with this.
16:08:33 <kmc> cool, thanks
16:15:27 <augur> hmm
16:15:42 <augur> so i seem to have forgotten one of the very important things about haskell's variable binding stuff
16:15:47 <augur> at least when it comes to lets
16:16:09 <augur> let doesnt use the outer scope for its clauses, it uses the same scope as it's creating
16:16:41 <sipa> hmm?
16:17:17 <augur> as noted in the subreddit:
16:17:26 <augur> > let x = 3 in (let x = x + 1 in x)
16:17:30 <lambdabot>   mueval-core: Time limit exceeded
16:17:50 <shachaf> augur: Well -- yes.
16:17:52 <augur> because the x in x+1 is the x on the left of that same ='s
16:17:53 <shachaf> Now you know.
16:17:55 <augur> not the higher x
16:18:03 <shachaf> > let ?x = 3 in (let ?x = ?x + 1 in ?x)
16:18:04 <lambdabot>   4
16:18:05 <dolio> You forgot that?
16:18:10 <dolio> > let x = 1 : x in x
16:18:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:18:13 <augur> gasp!
16:18:16 <augur> whats a ?x!?
16:18:27 <shachaf> @whatis ?x!?
16:18:27 <lambdabot> I know nothing about ?x!?.
16:18:29 <jmcarthur> this was a major stumbling block for me when learning to read ocaml, since ocaml does it the other way
16:18:39 <augur> dolio: yeah, i did forget that. :) i was thinking all schemeishly
16:18:45 <shachaf> Right, OCaml requires you to specify recursion explicitly.
16:19:00 <shachaf> I think letrec is silly as a non-default and shadowing is for-the-most-part evil.
16:19:05 <jmcarthur> me too
16:19:28 <shachaf> > let x = 3 in (let x' = x+1 in (let x = x'+1 in x))
16:19:29 <lambdabot>   5
16:19:48 <augur> i find shadowing easy to define an evaluator for
16:20:00 <DanBurton> whoa waitaminute
16:20:08 <DanBurton> you guys are talking about the comment I posted just aminute ago :)
16:20:15 <augur> for non-shadowing, you have to construct the environment and also use the environment
16:20:19 <augur> DanBurton: :)
16:20:37 <sipa> > let fix f = f (fix f) in fix (\f x -> x : f (x + 1))
16:20:37 <DanBurton> what's with the question mark syntax?
16:20:37 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
16:20:37 <lambdabot>    arising from a use of...
16:20:40 <shachaf> augur: If you have recursion, you might as well have it everywhere.
16:20:45 <augur> DanBurton: lambdabot weirdness
16:20:45 <sipa> > let fix f = f (fix f) in fix (\f x -> x : f (x + 1)) 0
16:20:46 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:20:54 <shachaf> augur: Huh? No.
16:21:00 <augur> shachaf: well it aint ghci
16:21:06 <augur> i get a parse error from ghci
16:21:30 <shachaf> augur: Well, did you :set -fglasgow-exts?
16:21:36 <augur> oh no
16:21:37 <augur> huh.
16:22:49 <shachaf> Every time I read Reddit comments I get annoyed.
16:23:06 <augur> whys that
16:23:07 <fryguybob> ImplicitParams right?
16:23:07 <bfig> have you tried google docs latexy function editor? how can i do a traditional max subscript?
16:23:08 <DanBurton> shachaf: lol. even /r/haskell comments?
16:23:34 <shachaf> Definitely.
16:23:50 <augur> im going to have to mess with my pseudohaskell interpreter now :\
16:24:05 <DanBurton> shachaf: why the reddit hate?
16:24:16 <bfig> how does fix relate to monadfix?
16:24:16 <shachaf> I don't hate the website, just the people.
16:24:26 * shachaf hates everybody.
16:24:28 <DanBurton> the redditor hate, then
16:24:40 <shachaf> Off-topic, anyway.
16:24:45 <DanBurton> I guess :P
16:24:59 <kmc> shachaf, you're sounding like me
16:25:17 <kmc> /r/haskell comments are fine
16:25:22 <shachaf> kmc: It rubs off, I guess.
16:25:27 <shachaf> Not all of them.
16:25:33 * DanBurton 's /r/haskell comments are *mighty* fine
16:25:34 <augur>  /r/haskell and /r/dependent_types are good
16:25:34 <kmc> except that the interesting articles don't get many
16:25:51 <augur> also, what is dons's connection to haskell?
16:25:57 <kmc> the articles with the most comments are the ones like "somebody kinda famous said something good or bad which is tangentially related to haskell"
16:26:00 <augur> im getting the impression he's deeply involved
16:26:06 <DanBurton> @google dons haskell
16:26:06 <kmc> or funny pictures
16:26:07 <lambdabot> http://donsbot.wordpress.com/
16:26:07 <lambdabot> Title: Control.Monad.Writer
16:26:16 <kmc> augur, worked at galois, wrote a bunch of libraries, co-authored RWH
16:26:25 <augur> ahh
16:26:38 <DanBurton> what happened to dons? Haven't heard much from him lately, he used to be on SO a lot more often
16:26:44 <Jafet> Shootout cowboy.
16:26:49 <DanBurton> also /r/haskell
16:26:55 <augur> hmm how can i do this now...
16:27:17 <augur> see, my general mental model of let expressions is sugar for lambdas
16:27:17 <shachaf> #haskell-wherearetheynow
16:27:22 <rwbarton> mathoverflow had a similar problem, the touchy-feely stuff with broad appeal got upvoted by everyone, while the actual technical questions only got upvoted by the people in that area
16:27:28 <augur> let x = y in z   --->   (\x -> z) y
16:27:36 <augur> which is perfectly happy to shadow
16:27:40 <rwbarton> not sure it is actually a problem, really
16:27:49 <augur> but if let is a special expression on its own, yeah. hmm.
16:28:01 <shachaf> I think it's a problem.
16:28:02 <Jafet> augur: the semantics of lambda calculus do not mention sharing
16:28:25 <kmc> it's not hard to avoid clicking fluff articles
16:28:31 <augur> Jafet: the semantics of the lambda calculus usually has shadowing.
16:28:36 <kmc> so long as the total number of articles is manageable
16:28:41 <shachaf> kmc: Well, it is if you're reading reddit.com
16:28:46 <Jafet> I said sharing, not shadowing, augur.
16:28:51 <kmc> fundamentally it's a lot of work to have a worthwhile opinion on, say, an ICFP paper
16:29:02 <augur> Jafet: oh well then im not sure what you're talking about then
16:29:02 <kmc> shachaf, right, I meant at the level of /r/haskell
16:29:16 <shachaf> reddit.com used to be mostly interesting articles. So did reddit.com/r/programming.
16:29:21 <rwbarton> if you read /r/haskell you can easily look at every article and figure out which ones are probably interesting to you without relying on votes
16:29:25 * shachaf feels like this is the wrong channel for complaining about that.
16:29:29 <Jafet> (let x = y in f x x) is genuinely different from (f y y), because the computation (and storage) of y is shared in the former instance.
16:29:46 <Jafet> (If y is a nontrivial computation.)
16:30:07 <augur> Jafet: oh i see, yeah, true. but (\x -> f x x) y does have sharing
16:30:15 <augur> well, not in the LC ofcourse
16:30:33 <kmc> augur, the way the STG paper treats that case is that y must already be a let-bound variable
16:30:40 <rwbarton> augur: there are a couple other differences between let and your lambda form also
16:30:58 <augur> kmc: i havent read the STG paper. :p
16:30:59 <kmc> so sharing is only introduced by let
16:31:11 <augur> really? wait so like
16:31:12 <kmc> and forcing is only introduced by case
16:31:16 <kmc> it's pretty elegant really
16:31:26 <augur> (\x -> f x x) y   will not share y? itll evaluate y twice?
16:31:40 <kmc> in Haskell it shares
16:31:42 <augur> ok
16:31:51 <shachaf> In Haskell or in GHC Haskell?
16:31:57 <kmc> in GHC Haskell fine
16:31:58 <kmc> i'm saying that the original authors of GHC considered this to be syntactic sugar
16:32:06 <Jafet> augur: well, that gets desugared into (let x = y in f x x), so yes
16:32:13 <shachaf> kmc: For most people I wouldn't be so picky, but, y'know... :-)
16:32:14 <augur> oh kmc, you mean the evaluation of   (\x -> f x x) y   is by reduction to ... what Jafet just said
16:32:17 <augur> ok
16:32:19 <augur> i see i see
16:32:30 <augur> hmm
16:32:36 <augur> see im treating lambdas as primary not lets
16:32:44 <Jafet> Glasgow Haskell is so awesome, that lambda calculus gets desugared into it.
16:32:50 <augur> we should stop saying Haskell is the LC then and start saying its the Let calculus!
16:32:52 <kmc> we need a term for "the graph-reduction operational semantics implied but not required by the Haskell Reports"
16:32:59 <shachaf> augur: Well, you still need lambdas.
16:33:03 <Jafet> The Report has sharing?
16:33:18 <DanBurton> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-440003.12
16:33:24 <kmc> iirc there are no lambdas in the original STG either
16:33:32 <kmc> let has the ability to define functions baked in
16:33:49 <augur> haha!
16:33:58 <Jafet> And now the obligatory
16:33:59 <Jafet> @src fix
16:33:59 <lambdabot> fix f = let x = f x in x
16:34:00 <augur> my interpreter required only one variable to be changed to get let sharing :)
16:34:06 <kmc> haha
16:34:26 <shachaf> fix f = f (fix f)
16:34:38 <monochrom> "the graph-reduction operational semantics implied but not required by the Haskell Reports" = lazy evaluation
16:34:40 <rwbarton> I like "let calculus"
16:35:03 <augur> basically i did something like   newEnv = ...; newEnv.bind(clause.var, clause.body.thunkInEnv(env)) ; ...
16:35:07 <shachaf> @let calculus = deriv calculus
16:35:08 <lambdabot>  <local>:4:11:
16:35:08 <lambdabot>      Occurs check: cannot construct the infinite type: a = Dif...
16:35:14 <augur> where env is the outer environment and newEnv is the inner one
16:35:15 <RaptorRarr> > let fix f = f (fix f) in fix brokenThing
16:35:17 <lambdabot>   Fixed.
16:35:22 <augur> so i just changed env to newEnv, problem solved.
16:35:24 <RaptorRarr> It works!
16:37:06 <shachaf> @ty fmap fix return
16:37:07 <lambdabot> forall a. a -> a
16:37:10 <shachaf> @ty fmap return fix
16:37:10 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> a) -> m a
16:37:16 <shachaf> @ty callCC (fmap return fix)
16:37:17 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => m (m b)
16:37:23 <rwbarton> oh, in fact, there is even a paper on call-by-need evaluation that uses the term "let-calculus"
16:37:53 <Jafet> @ty join $ callCC $ fmap return fix
16:37:54 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => m b
16:38:06 <shachaf> Jafet: That's not very useful...
16:38:34 <Jafet> How useful is callCC (fmap return fix)?
16:38:46 <kmc> :psyduck:
16:38:57 <augur> and it works! huzzah.
16:38:57 <shachaf> Jafet: I think it's "letCC".
16:39:00 <augur> such a simple change
16:39:07 <augur> i take by my statement that its wonky!
16:39:13 <RaptorRarr> kmc: Is that like deviantart smiley stuff?
16:39:38 <shachaf> Or is that "getCC"?
16:39:50 <shachaf> @let getCC = callCC (return . fix)
16:39:51 <lambdabot>  Defined.
16:40:47 <monochrom> I have something like that in my http://www.vex.net/~trebla/haskell/cont-monad.xhtml
16:41:03 <monochrom> so, it's useful for getting a jump label
16:41:53 <shachaf> Right, that's it.
16:42:19 <shachaf> The fmap is just for show.
16:42:38 <Jafet> Pointless show
16:44:31 <KitB> One of you is bound to be able to answer this quickly:
16:44:39 <KitB> (though I know it's off topic, sorry)
16:45:15 <augur> so someone mentioned haskell only forcing thunks during case
16:45:19 <KitB> if a=O(b), is b=Î©(a)?
16:45:38 <Jafet> b = o(a)
16:45:50 <DanBurton> KitB: yes
16:46:05 <KitB> DanBurton: I thought it made sense
16:46:15 <KitB> But I had a vague memory of a lecturer of mine saying it wasn't the case
16:46:20 <augur> in my evaluator im having it force thunks on all evaluations, so that in `f x`, the whole thing is forced, and then f is forced (but not x)
16:46:22 <jmcarthur> augur: or seq or bang patterns or strict fields or primitives
16:46:33 <jmcarthur> and there are probably other things
16:46:36 <augur> barring IO, is this going to cause any problems?
16:46:50 <Jafet> Hmm wait, I read \Theta
16:46:52 <jmcarthur> i'm not sure i understand
16:47:05 <KitB> Jafet: Omega
16:47:07 <jmcarthur> augur: are you saying you're forcing (f x) and then forcing (f)?
16:47:14 <DanBurton> KitB: a=O(b) means "a grows no faster than b", b=?(a) means "b grows no slower than a". It should be apparent that these statements are equivalent
16:47:28 <KitB> DanBurton: That's exactly what I thought
16:47:28 <DanBurton> put an omega where that ? is >,<
16:47:41 <KitB> But I could also be getting caught in the trap of thinking I know more than I do
16:47:43 <jmcarthur> augur: also, what is a value in your evaluator? whnf? hnf? nf?
16:47:45 <KitB> So I wanted to check
16:47:51 <Jafet> Forcing f is a prerequisite for forcing (f x).
16:47:57 <augur> jmcarthur: well, the expression `f x` is just an AST wrapped in a thing that flags whether its a thunk or not for my interpreter
16:48:02 <monochrom> augur: someone mentioned the STG paper only forcing thunks during case. not Haskell.
16:48:15 <jmcarthur> Jafet: not necessarily
16:48:37 <augur> jmcarthur: by default, everything is a thunk, so `f x` is "forced", which recursively forces `f`
16:48:39 <jmcarthur> Jafet: completely lazy evaluation, very lazy evaluation, optimal evaluation... all at least blur the lines
16:48:49 <monochrom> even assuming popular Haskell compilers, there are still levels of translations between Haskell and STG
16:48:57 <DanBurton> Also slightly off topic: is there a special way to write greek characters? I copy/pasted omega...not sure if it's just my irc client that's screwing with me or what
16:49:14 <augur> jmcarthur: so like, if the expression is `(\x -> x) 1`, forcing `\x -> x` produces a procedure, whereas prior to that its an unevaluated AST
16:49:15 <Axman6> DanBurton: what OS are you on?
16:49:18 <Jafet> Switch to a greek layout!
16:49:25 * KitB copied it from the wikipedia article on "Omega" :P
16:49:36 <KitB> Easier than opening charmap
16:49:38 <DanBurton> Axman6: windows, using Opera's built-in IRC client
16:49:44 <jmcarthur> augur: what is the distinction. is a procedure a compiled version of the ast?
16:49:50 <DanBurton> windows 7 to be precise
16:50:28 <augur> jmcarthur: its basically just a lambda abstraction + the environment the lambda abstract was evaluated in (typical scheme stuff)
16:50:56 <monochrom> I would do this in windows: install virtualbox, install linux inside virtualbox, install scim inside linux inside virtualbox, use that to enter greek letters, copy them back to windows
16:51:05 <jmcarthur> augur: that doesn't sound like evaluation to me
16:51:15 <Axman6> pfft, no clue then. OS X has a bunch of special characters bound to alt-<key>: Å“âˆ‘Â´Â®â€ \Â¨Ë†Ã¸Ï€â€œâ€˜Ã¥ÃŸâˆ‚Æ’Â©Ë™âˆ†ËšÂ¬â€¦Ã¦Î©â‰ˆÃ§âˆšâˆ«ËœÂµâ‰¤â‰¥Ã·
16:51:26 <DanBurton> monochrom: -___- yo dawg?
16:51:31 <monochrom> hehe
16:51:32 <augur> jmcarthur: its the evaluation of the lambda abstraction
16:51:34 <jmcarthur> maybe i'm misunderstanding though
16:51:48 <monochrom> but more, seriously, try my http://www.vex.net/~trebla/symbols/select.html
16:51:56 <jmcarthur> augur: you are performing reductions?
16:52:05 <jmcarthur> like... beta reductions?
16:52:23 <augur> jmcarthur: applying a procedure to a value does beta reduction, basically, yes
16:52:33 <jmcarthur> the application is a different matter
16:52:43 <Jafet> I would do this in windows: remove windows so that you don't have to fiddle with an oracle product
16:52:49 <jmcarthur> i'm talking about this step which i'm characterizing as compilation
16:53:09 <augur> but lambda abstractions dont directly beta reduce because you need environments
16:53:30 <DanBurton> ?????
16:53:33 <DanBurton> boo
16:53:33 <jmcarthur> environments can be treated in several different ways
16:53:37 * KitB is too tired to be doing vigorous proofs of big-oh stuff
16:53:59 <DanBurton> those were supposed to be symbols. It must be Opera..I should get a real IRC client :P
16:54:10 <KitB> DanBurton: irssi ;) :P
16:54:11 <shachaf> monochrom: Hah, your setjmp example is exactly the one I was going to give before.
16:54:14 <Jafet> Well, the scheme way is theoretically simplest.
16:54:33 <augur> jmcarthur: i just used the core of scheme's metacircular evaluator.
16:54:35 <shachaf> monochrom: Unfortunately this doesn't let you return a value from setjmp like the C version does.
16:54:37 <jmcarthur> maybe i'm not understanding what is meant by "the scheme way"
16:55:09 <Jafet> jmcarthur: as I understand it, a term and an environment.
16:55:54 <augur> jmcarthur: scheme interpreters basically have en evaluation rule like so:   eval env (Lam v b) = Proc v b env
16:56:12 <jmcarthur> so Proc is a closure
16:56:22 <augur> sure
16:56:22 <jmcarthur> ?
16:56:32 <Jafet> Yeah, it has no free variables
16:56:54 <augur> and then apply (Proc v b env) val = eval ((v,val):env) b
16:57:15 <jmcarthur> can you treat procs differently from lambdas, syntactically?
16:57:40 <augur> jmcarthur: procs arent something you create in code, they're just for the interpreter to use
16:57:40 <Jafet> env :: [a], the scheme way!
16:57:54 <augur> Jafet: env :: [(a,b)] surely :)
16:58:05 <jmcarthur> it sounds like a proc is still just a step you perform as part of beta reduction and is not itself a reduction in the syntactic sense, then
16:58:08 <monochrom> env :: [Any]
16:58:24 <Jafet> Pair = Cons Any Any
16:58:34 <jmcarthur> maybe i'm being overly strict about what a reduction is though
16:58:58 <jmcarthur> i'm the one that brought up crazy evaluation strategies earlier, after all. i should be more open minded about this
16:59:09 <augur> jmcarthur: pretty much. its just an internal way to use environments instead of substitution -- the body of the lambda still needs the environment it was defined it
16:59:27 <Jafet> I still don't understand what evaluation strategy lets you evaluate (f x) without evaluating f.
16:59:33 <Jafet> (In the general case.)
16:59:56 <augur> Jafet: partial evaluation! :p
17:00:22 <jmcarthur> Jafet: completely lazy evaluation evaluates the body of f lazily as it evaluates the application of f to x, for one example
17:00:46 <Jafet> Okay, but that still counts for me
17:02:00 <Jafet> Depending on what you mean by "body", Haskell already has that
17:02:10 <jmcarthur> Jafet: very lazy evaluation allows you to apply functions to values that aren't directly attached by an application node, such as when a function is hidden under a lambda and its argument is still outside the lambda
17:02:51 <augur> hmm. so right now im using procs also to wrap constructors, because i want constructors to look identical to normal functions, so procs have two flavors -- compound procedures and constructors
17:03:04 <jmcarthur> Jafet: ghc doesn't have completely lazy evaluation. if it did then it would be able to dynamically specialize
17:03:52 <Jafet> As in let f _ = \x -> y in f a b?
17:03:53 <augur> i wonder if i can eliminate procedures entirely with a special constructor AST
17:03:56 <hpaste> Husel pasted â€œBasic questionâ€ at http://hpaste.org/52854
17:04:56 <jmcarthur> Jafet: for a more interesting example, completely lazy evaluation would allow you to dynamically specialize an interpreter to the program it is interpreting (in other words, compilation for free)
17:05:16 <jmcarthur> a kind of high level JIT compilation, specifically
17:05:27 <Jafet> I think "evaluation" is really the wrong term for that
17:05:30 <jmcarthur> without necessarily having the nice low level optimizations that most JITs have
17:05:37 <jmcarthur> it really is evaluation though
17:06:07 <Jafet> I didn't realize we were bringing those details into semantics
17:06:12 <monochrom> @quote monochrom runghc
17:06:12 <lambdabot> monochrom says: just add #! /usr/bin/runghc to your haskell file. then type errors occur at runtime only.
17:06:19 <augur> jmcarthur: can you explain dynamic specializing/compilation for free?
17:06:21 <jmcarthur> we aren't. these details are an effect of the semantics
17:07:35 <rotflcopter> do you like regexp?
17:07:39 <rotflcopter> f=0;a="name:info:weight";echo "${a}" | sed -Ee 's;(^|[^:]*:|:[^:]*){'$f'}([^:]*);\2;' -e 's;([^:]*):.*;\1;'
17:08:07 <Jafet> monochrom: I've compiled a program that took 4GB memory to typecheck
17:08:24 <monochrom> my sympathy
17:08:32 <rotflcopter> wanted to apply this function in one step but sed got confused ;/
17:08:33 <jmcarthur> basically, in completely lazy evaluation, you introduce a new kind of runtime structure called a substitution node, and they can be lazily pushed down the AST, making appropriate copies of nodes on demand and replacing the appropriate variable when it finds it. substitution nodes also know where they have already visited and retain sharing if they visit a node they have visited before
17:09:01 <jmcarthur> but the point is that subtitution is not just a single evaluation step. its lazier than that
17:09:46 <Husel> monochrom: it still won't load. I'm using ghci if that makes any difference
17:09:53 <jmcarthur> so you can perform a substitution down one part of a tree and only duplicate that one part of the function body, but other reductions in the other parts of the function body will still be shared because they haven't been copied yet
17:10:43 <jmcarthur> the substitution node thing is just one person's implementation, but i think it's one of the easier ones to grasp
17:10:55 <augur> hm. i'd have to see this to understand it
17:10:56 <jmcarthur> well, actually, it's the only real implementation i know of, but still
17:11:49 <jmcarthur> augur: see Thyer's thesis "Lazy Specialization"
17:12:35 <jmcarthur> augur: also check out http://thyer.name/lambda-animator/
17:12:40 <Axman6> @google Thyer Lazy Specialization
17:12:41 <lambdabot> http://thyer.name/phd-thesis/
17:12:41 <lambdabot> Title: Lazy Specialization
17:12:42 <jmcarthur> in fact, the latter is more fun :)
17:13:36 <jmcarthur> the latter kind of depends on some knowledge from the former though
17:14:18 <jmcarthur> completely lazy evaluation is the combination of call-by-need and substitute-by-need
17:14:37 <augur> jmcarthur: is this an interpreter that shows ASTs and lets you step through their transformations?
17:14:39 <jmcarthur> and i think whnf is normally used with it
17:14:42 <jmcarthur> yes
17:14:55 <augur> jmcarthur: oh man, thats great
17:15:14 <jmcarthur> also see lambdascope on hackage
17:15:40 <augur> thats how i learn -- i need to see these visualizations to truly understand things
17:15:56 <jmcarthur> i think the visualization isn't very helpful in isolation though
17:16:03 <jmcarthur> you still need the text to really know what's happening
17:16:08 <augur> jmcarthur: oh of course
17:16:19 <augur> but i just cant think about these things without knowing what im thinking about
17:16:33 <augur> and people usually write papers that have no visualizations
17:16:37 <augur> so its hard for me to grok this stuff
17:17:28 <Husel> anyone have any suggestions? http://hpaste.org/52854
17:17:42 <jmcarthur> i think the most interesting contribution from that thesis is the notion of "substitute-by-*" as orthogonal to "call-by-*"
17:18:33 <shachaf> Husel: Well, first of all figure out the type of your function.
17:18:44 <shachaf> Husel: Then figure out what (:) does, and look up (++). :-)
17:18:57 <Husel> shachaf: this is what I had for the type, but it's probably wrong :(  printTree :: Tree -> String
17:19:05 <Husel> it doesn't accept that
17:19:11 <shachaf> Looks OK to me.
17:19:20 <shachaf> It depends on what you want the function to do.
17:19:30 <shachaf> Do you want it to convert a Tree to a String? If so, that type is correct.
17:19:36 <shachaf> Of course, the definition doesn't match the type. :-)
17:19:57 <jmcarthur> "call-by-*" relates to what you are doing with the argument of an application. "substitute-by-*" relates to what you are doing with the function of an application.
17:20:07 <Husel> not sure I understand
17:20:07 <Husel> the error it gives is that it has type *->*
17:20:16 <monochrom> change all your : to ++
17:21:23 <Husel> it compiles now :)
17:21:28 <RaptorRarr> All your cons are belong to plus.
17:21:36 <jmcarthur> "value" means you evaluate it in place and then use that in the result (and whether or not you copy it doesn't matter anymore since it's already evaluated). "name" means you copy it into the result as is. "need" means you use it in the result without copying and share any evaluations that occur because of the application.
17:21:43 <jmcarthur> augur: ^^
17:22:14 <hpaste> Louis11 pasted â€œParsec?â€ at http://hpaste.org/52855
17:22:26 <augur> jmcarthur: hm hm
17:22:42 <Louis11> Could anyone explain what the <- mean? And how I would go about adding in the 'else'? This is the first time I've seen this syntax
17:22:46 <jmcarthur> so call-by-need and substitute-by-need means you evaluate nothing and copy nothing until absolutely needed, and share the evaluations. this applies to both the argument *and* the function body
17:23:14 <jmcarthur> in most language, we have substitute-by-value
17:23:17 <jmcarthur> *languages
17:23:26 <RaptorRarr> Louis11: It's like assignment.
17:23:37 <jmcarthur> which means we evaluate the function and then copy its body during the application
17:23:53 <jmcarthur> (whether we evaluate under the lambda depends on what we define a value to be)
17:24:03 <Louis11> RaptorRarr: Ah, so similar to = in C?
17:24:20 <RaptorRarr> Louis11: It's analogous to it.
17:24:43 <Louis11> alright that clears things up significantly! Thanks :)
17:25:11 <RaptorRarr> You're welcome.
17:25:12 <jmcarthur> augur: unfortunately, from experience, completely lazy evaluation is tricky to implement efficiently :(
17:25:35 <augur> jmcarthur: fortunately for me im not after efficiency in my little fake-haskell :)
17:25:39 <jmcarthur> augur: i think there may be a project going on somewhere to get completely lazy evaluation into UHC though
17:25:43 <Louis11> Oh one more thing, how would I make it also follow the syntax in the bottom comment? Namely: IfStatement -> if '(' EXPRESSION ')' Statement [else Statement]. More specifically, how do I add in the conditional for the else statement. As in "the else may or may not be there"
17:25:51 <augur> jmcarthur: its a scripting language for a mathematica-like program aimed at linguistics, so
17:25:57 <jmcarthur> heh
17:26:20 <jmcarthur> it's also tricky to implement at all
17:26:27 <augur> its not _that_ tricky
17:26:44 <jmcarthur> well, it's not paper-worthy
17:26:49 <jmcarthur> (not anymore)
17:26:52 <augur> call by need, if i understand it correctly, is pretty easy to bolt onto a scheme interpreter
17:27:00 <jmcarthur> yeah i believe that
17:27:10 <jmcarthur> substitute-by-need i think isn't that hard either
17:27:12 <RaptorRarr> Louis11: I'm not sure how to use the parsing library you've got, but it would probably not call it body, but maybeElseAndMaybeBodyWeDontKnowYet or something shorter.
17:27:13 <jmcarthur> but the combination is
17:27:14 <augur> i mean, one of the SICP tasks is just that: make the interpreter lazy
17:27:23 <augur> it only takes like 40 lines of scheme to do
17:27:33 <jmcarthur> i'm surprised it's even that much
17:27:41 <Louis11> RaptorRarr: I believe it's parsec. This was a framework I was provided.
17:27:44 <augur> well, much of it is because scheme is a clunky language
17:27:49 <jmcarthur> i suppose
17:27:54 <augur> no convenient ADTs, no pattern matching
17:27:57 <Husel> shachaf, monochrom: thanks guys, it's working. :)
17:28:12 <RaptorRarr> Louis11: No, wait, that's not quite right. You need, whenever you encounter " else " in the text, to match it to the previous if somehow. Not sure how exactly.
17:28:45 <augur> jmcarthur: i once wrote a modified scheme interpreter that had case expressions. much easier to code with.
17:28:49 <Louis11> RaptorRarr: Yea, that's what I'm tripped up on.
17:28:59 <jmcarthur> yeah
17:29:20 <augur> at some point, after youve bolted on enough conveniences into scheme, you really do just get haskell minus types
17:29:27 <augur> at least in how it looks
17:29:28 <RaptorRarr> Louis11: It's probably something like "get the next statement. get the text else. if you fail, there's no else, if you succeed, get the next statement."
17:29:54 <Louis11> yea, that's what I assumed. But not quite sure how that would be implemented in haskell.
17:29:59 <blackdog> is there any way to work out what errors a library function might throw? hGetLine is a bit of a lie - if the other end is a pipe that closes unexpectedly, the whole thing blows up
17:30:25 <RaptorRarr> Louis11: The parsing libraries should have parsing thingies for alternatives.
17:31:03 <Louis11> i'll google it. Wasn't sure of the name before hand. I guess they are technically called alternatives?
17:31:41 <RaptorRarr> Louis11: http://book.realworldhaskell.org/read/using-parsec.html text search for alternative
17:32:02 <RaptorRarr> Louis11: Looks like there's a <|> operator.
17:32:27 <Louis11> ah, great, i'll give that a shot. Thanks again
17:32:33 <RaptorRarr> You're welcome.
17:33:12 <jmcarthur> augur: well, completely lazy evaluation is *far* easier than optimal evaluation, at least
17:33:25 <augur> jmcarthur: whats optimal evaluation?
17:33:40 <jmcarthur> augur: a crazy thing
17:33:47 <augur> O_O
17:33:59 <jmcarthur> augur: it does a ton of bookkeeping to perform as few beta reductions as possible
17:34:11 <augur> jmcarthur: crazy
17:34:39 <jmcarthur> augur: one implementation is basically the implementation of completley lazy evaluation with substitution nodes except that substitutions can move past each other and finish out of order and stuff
17:35:27 <jmcarthur> augur: i think lambdascope on hackage can do optimal evaluation
17:35:40 <Veinor> is there a way to get haskell-mode's inferior ghci to do tab completion when I hit tab?
17:38:31 <ybit> does anyone have experience with meta-language extensions for haskell?
17:43:54 <copumpkin> Î»> showAll (Cons 5 (Cons 7 (Cons True (Cons () Nil))))
17:43:55 <copumpkin> "57True()"
17:44:04 <copumpkin> using the magix
17:44:05 <copumpkin> foldrH :: All ctx as => Context ctx -> (forall a. ctx a => a -> b -> b) -> b -> HList as -> b
17:44:37 <copumpkin> showAll = foldrH showCtx (\x y -> show x ++ y) ""
17:44:49 <jmcarthur> awesome
17:45:48 <copumpkin> :)
17:46:06 <aavogt> copumpkin: will that really cut the number of classes occuring in HList-using code?
17:46:16 <copumpkin> absolutely
17:46:38 <copumpkin> consider that I don't have any classes defined in my hlist :P
17:46:46 <copumpkin> except for that All class, I guess
17:49:11 <copumpkin> (!) :: HList as -> Index as a -> a
17:49:11 <copumpkin> Cons a as ! Here = a
17:49:11 <copumpkin> Cons a as ! There i = as ! i
17:49:19 <copumpkin> much easier :P
17:49:40 <kmc> sweet
17:49:49 <copumpkin> that was already easy with GADTs though
17:49:53 <copumpkin> but the context stuff is fun
17:51:37 <rwbarton> so is showCtx just undefined :: Context Show?
17:51:46 <rwbarton> or some unique constructor
17:52:18 <copumpkin> no
17:52:23 <copumpkin> data Context (ctx :: * -> Constraint) = Context
17:52:31 <copumpkin> showCtx :: Context Show
17:52:34 <copumpkin> showCtx = Context
17:52:34 <copumpkin> :P
17:54:50 <copumpkin> oh, I can write any too
17:54:53 <copumpkin> well, maybe
17:55:22 <dylukes> Could anyone help me out?
17:55:30 <dylukes> This is hitting "error: unexpected EOF" https://gist.github.com/1299871
17:55:31 <augur> dylukes: well we COULD
17:55:34 <augur> but we wont 8D
17:56:11 <augur> dylukes: i dont see anything immediately leading to a parse error
17:56:23 <dylukes> the error is that it's hitting EOF.
17:56:26 <augur> but i would suggest commenting out bits and adding them back in one at a time to see whats parsing wrong
17:56:57 <augur> yeah i know
17:57:02 <augur> that means theres a parse error
17:57:10 <dylukes> no, I mean, after it parses 'l' its going to try to look for an operator,line 55.
17:57:25 <dylukes> but, it should just fail then... not error.
17:57:32 <augur> wait what
17:57:38 <copumpkin> boo, ghc is too dumb for Any
17:57:46 <copumpkin> it lets me write the instances if I fool it
17:57:51 <ybit> again, does anyone have experience with meta-language extensions for haskell?
17:57:54 <augur> is it _your parser_ thats throwing up this error, or is it ghc(i)?
17:57:59 <ybit> maybe i should as in haskell-cafe
17:58:01 <copumpkin> but then gives me a dumb error
17:58:50 <augur> dylukes: because an EOF error is when something is hitting the end of a _file_, and you're not reading any files or anything
17:59:02 <dylukes> the string is a "file"
17:59:06 <dylukes> EOF here being the end of the string.
17:59:16 <dylukes> this is an error from trifecta
17:59:19 <augur> i see
18:00:03 <augur> dylukes: try just parsing something simpler first, then
18:00:11 <dylukes> I have.
18:00:18 <augur> to pin point the minimal string that will throw this error
18:00:23 <augur> does "l" by itself parse?
18:00:32 <Sgeo|web> Would it be possible to do something similar to fix for making anonymous recursive functions in a strict language otherwise similar to Haskell?
18:00:37 <dylukes> yeah, a single symbol does,
18:00:40 <augur> hm!
18:00:42 <dylukes> but once there are any operators is the issue
18:00:47 <dylukes> a + b will hit the EOF
18:00:55 <augur> well, i dont know anything about trifecta :)
18:00:56 <augur> edwardk!
18:01:00 <dylukes> the reason is because once it parses operators and rhs's as pairs.
18:01:50 <edwardk> dylukes: you probably have consumed some input and are failing outside of a try in there somewhere
18:01:51 <rwbarton> heh, I got fooled for a moment by "let rec lhs = ..."
18:02:13 <dylukes> rwbarton:
18:02:14 <dylukes> :P
18:02:18 <edwardk> e.g. rec doesn't do so optionally
18:02:32 <edwardk> rwbarton: hah
18:02:34 <augur> hmm. eliminating lambdas will be tricky
18:02:34 <dylukes> It shouldn't need too though.
18:02:57 <dylukes> If it fails, the optional in expr should result in Nothing
18:03:15 <dylukes> maybe a well placed 'try'?
18:03:58 <joe9> does anyone know what causes this message: http://codepad.org/XWds3Fur Top level: attempting to use module `PatternResponses' (./PatternResponses.hs) which is not loaded
18:04:03 <augur> jafet left :(
18:04:11 <joe9> I am not sure if I messed up my ghc installation, which is causing this.
18:04:12 <edwardk> dylukes: no
18:04:32 <edwardk> optional doesn't try
18:04:32 <joe9> It worked until a few hours ago-- :m +PatternResponses
18:04:38 <augur> jmcarthur: if (\x -> y) z desugards to let x = z in y, what does (\x y -> z) w desugar to?
18:04:49 <dylukes> but, in the case of say 'a + b'
18:04:56 <dylukes> after reading 'b', it enters expr'
18:05:01 <dylukes> lookAhead $ infixOp table fails
18:05:11 <dylukes> so the optional in expr should result in Nothing
18:05:15 <dylukes> then the lhs is returned, so a + b
18:05:22 <dylukes> no?
18:05:23 <rwbarton> then rec recurses!
18:05:37 <jmcarthur> augur: (\x y -> z) w  ==>  (\x -> (\y -> z)) w  ==>  ...
18:05:47 <augur> jmcarthur: right but i mean
18:05:59 <augur> (\x -> \y -> z) w ==> let x = y in ...?
18:06:05 <jmcarthur> i see
18:06:06 <dylukes> edwardk: what exactly needs to be optional?
18:06:10 <augur> the y isnt bound, so it cant desugar
18:06:19 <augur> it has to stay a lambda
18:06:20 <DanBurton> let x = w in \y -> z
18:06:26 <jmcarthur> yeah
18:06:45 <augur> so this is .. progressive sugar?
18:06:50 <jmcarthur> so i take it you are calling the let form a proc?
18:07:09 <augur> like, it desugars along the way as opposed to all prior to compilation/interpretation
18:07:14 <rwbarton> "rec $ f lhs rhs" looks wrong to me, don't you want to loop back to expr'?
18:07:27 <DanBurton> in Haskell I wouldn't say let and lambda desugar to each other. Haskell let is other languages' letrec
18:07:27 <rwbarton> or at least not do what you do there
18:07:45 <jmcarthur> not sure i'd call it desugaring since they seem to mean different things
18:07:56 <augur> ok.
18:08:09 <jmcarthur> actually
18:08:11 <dylukes> rwbarton: !
18:08:51 <jmcarthur> augur: how does  (\x -> y) z  "desugar" to  let x = z in y? that looks more like beta substitution
18:08:55 <augur> so i should instead have eval (App (Lam v b) val) as one case, and eval (App f val) as another case
18:08:59 <augur> jmcarthur: dont ask me, ask Jafet! :P
18:09:06 <rwbarton> I agree that this is not "desugaring"
18:09:43 <jmcarthur> augur: what is "f" in the second case?
18:10:04 <augur> jmcarthur: just any non-Lam term
18:10:12 <jmcarthur> augur: a primop?
18:10:19 <dylukes> rwbarton: I think you're right, kind of. my lookAhead should probably be INSIDE the let
18:10:27 <rwbarton> it could be an application itself
18:10:43 <jmcarthur> ah yeah
18:10:55 <augur> rwbarton: or anything else
18:11:00 <augur> like, a partially applied constructor
18:11:16 <augur> but im going to wrap my constructors in lambdas anyway
18:11:24 <jmcarthur> is this untyped? if not, i'd be surprised if it is neither a lambda nor a primitive
18:11:25 <augur> so they should all evaluate to lambdas
18:11:36 <jmcarthur> ah my question is answered already then
18:11:40 <augur> jmcarthur: im foregoing primitives for now :)
18:11:54 <augur> hmm ok
18:12:12 <jmcarthur> well, i mean
18:12:28 <jmcarthur> i'd be surprised if it was a value that was not a lambda nor a primitive
18:12:34 <jmcarthur> if it's not a value then i am not surprised
18:13:47 <johnfn> I have Rect.hs that has data Rect = Rect Int Int Int int, but when I do import Rect in main.hs and try to make a Rect, it says the Rect data constructor isn't in scope. why is that?
18:14:20 <rwbarton> you probably wrote "module Rect (Rect) where ..."
18:14:27 <johnfn> i did
18:14:41 <jmcarthur> module Rect (Rect (..)) where
18:14:43 <rwbarton> try "module Rect (Rect(..)) where ..."
18:15:01 <johnfn> what's the (..)? or do i just write that literally?
18:15:06 <jmcarthur> literally
18:15:15 <rwbarton> (..) means export all constructors, or you can list them individually ("module Rect (Rect(Rect)) where")
18:15:17 <johnfn> ah, very nice
18:15:27 <jmcarthur> you could specify constructors yourself, but what's the point? ;)
18:15:43 <johnfn> so i'm guessing it happened because there's a collision with Rect the type and Rect the constructor?
18:15:59 <copumpkin> idH :: HList as -> HList as
18:15:59 <copumpkin> idH = foldrH Cons Nil
18:15:59 <jmcarthur> no, it happened because you didn't import the constructor
18:16:00 <copumpkin> :P
18:16:08 <jmcarthur> you only imported the type
18:16:11 <rwbarton> copumpkin, how does that type parameter 'as' work?
18:16:22 <copumpkin> it's right-nested tuples
18:16:26 <copumpkin> with a () terminator
18:16:29 <rwbarton> ah
18:16:31 <copumpkin> foldrH :: (forall a as. a -> b as -> b (a, as)) -> b () -> HList as -> b as
18:16:31 <johnfn> but intuitively saying module Rect (Rect) seems like it should export everything Rect-like
18:17:05 <jmcarthur> it does import every type called Rect ;)
18:17:39 <jmcarthur> import Module (Type (Constructor1, Constructor2, ...))
18:17:40 <johnfn> but i thought that generally writing module X (Y) exports types or functions of type Y?
18:17:56 <johnfn> ooooh
18:18:05 <johnfn> i understand! thanks
18:18:52 <rwbarton> if Y is capital, it exports the type Y, otherwise if it's a lowercase y it exports the value y
18:19:51 <augur> aha jmcarthur, rwbarton: got it :)
18:21:00 <jmcarthur> you're making me want to write an interpreter...
18:21:45 <rwbarton> copumpkin: if you just wanted to write your foldrH I think you could do without any type class at all
18:21:58 <copumpkin> rwbarton: yeah, I don't have a typeclass
18:22:14 <rwbarton> what about Any?
18:22:18 <rwbarton> er
18:22:24 <rwbarton> All
18:22:26 <copumpkin>     Cannot deal with a type function under a forall type:
18:22:27 <copumpkin>  :(
18:22:40 <copumpkin> rwbarton: that was a different definition of foldrH, which is now called foldrCtx
18:22:47 <rwbarton> ah
18:22:56 <rwbarton> that's the one I meant
18:22:58 <copumpkin> rwbarton: foldrCtx is when you have a heterogeneous list where all members belong to some context, then you can fold over that
18:23:02 <rwbarton> yeah
18:23:08 <rwbarton> well I can't test this but
18:23:29 <djahandarie> Wouldn't it be really really easy to make a really simple HList with constraint kinds?
18:23:35 <rwbarton> hmm
18:23:45 <copumpkin> djahandarie: what makes it simple is GADTs :P
18:23:48 <copumpkin> and type families
18:23:56 <copumpkin> but the contraint kinds make some parts of it a lot nicer
18:24:05 <copumpkin> instance All Eq as => Eq (HList as) where
18:24:09 <copumpkin> instance All Show as => Show (HList as) where
18:24:10 <copumpkin> and so on
18:24:19 <djahandarie> Well, yeah, aside from the GADT and Type Family part of it :)
18:24:37 <rwbarton> data HList :: ((* -> Constraint) -> Constraint) -> * where ...
18:24:42 <rwbarton> can I do this?
18:24:54 <copumpkin> don't see why not
18:25:07 <rwbarton> Nil :: HList (const ()) -- :( ?
18:25:14 <rwbarton> guess I need some type functions here
18:25:14 <copumpkin> yeah, no const
18:25:18 <copumpkin> class None a
18:25:20 <copumpkin> instance None a
18:25:34 <rwbarton> Cons :: a -> HList bs -> HList (\f -> (f a, bs f))
18:25:43 <copumpkin> yeah, none of that :P
18:25:47 <rwbarton> oh well
18:26:15 <djahandarie> Quick, to the agdamobile!
18:26:19 <copumpkin> :)
18:26:43 <dylukes> rwbarton: okay cleaned it up a bit
18:26:44 <dylukes> https://gist.github.com/1299303
18:26:45 <copumpkin> I was trying to write a fully general heterogeneous foldl
18:26:48 <copumpkin> but I can't do it
18:26:57 <djahandarie> In Haskell?
18:26:57 <copumpkin> because of that error I get
18:26:59 <copumpkin> yeah
18:27:06 <djahandarie> Which error? (Just walked in...)
18:27:07 <copumpkin>     Cannot deal with a type function under a forall type:
18:27:18 <edwardk> class MaybeC (c :: Constraint) where maybeC :: a -> (c => a) -> a
18:27:37 <edwardk> probably needs a witness
18:27:39 <edwardk> =/
18:27:40 <copumpkin> we're all having too much fun with this
18:28:14 <edwardk> copumpkin: my favorite line of the day:
18:28:15 <edwardk> instance (Class a, Class b, b ~ Class a) => Class (Class (Class a)) where
18:28:17 <copumpkin> one thing I tried earlier that failed, sadly, was
18:28:18 <copumpkin> on :: (ctx x, ctx y) => (b -> b -> c) -> (forall a. ctx a -> b) -> x -> y -> c
18:28:33 <copumpkin> edwardk: hah
18:28:38 <edwardk> copumpkin: it passes with the ~
18:28:54 <djahandarie> I find that I don't use ~ too often
18:28:56 <copumpkin> but not otherwise?
18:29:01 <edwardk> instance Instance (Class (Class (Class a))) where   type Context (Class (Class (Class a))) = (Class a, Class (Class a)) -- is also pretty good
18:29:11 <djahandarie> Because it's really easy to accidently prove something useless while you think you're doing something usefu
18:29:18 <edwardk> copumpkin: yeah
18:29:21 <djahandarie> Refl seems to be a safer bet usually
18:29:24 <edwardk> it spins forever like the fundep version
18:29:30 <copumpkin> ah, boo
18:29:54 <joe9> sometime ago, I had used a module which implemented a safer head. but, I have lost it now. Anyone remembers what it is?
18:29:55 <edwardk> djahandarie: i'm modeling the liskov subsitutability of constraints, so i'm needing a lot of funny types
18:29:58 <joe9> It is not Safe.hs
18:30:04 <joe9> i think.
18:30:05 <edwardk> :t listToMaybe
18:30:06 <lambdabot> forall a. [a] -> Maybe a
18:30:32 <edwardk> :t Data.Maybe.listToMaybe
18:30:33 <lambdabot> forall a. [a] -> Maybe a
18:30:45 <dylukes> edwardk: I hate to be bothering you but, I have no idea where to go from here: https://gist.github.com/1299303
18:30:59 <dylukes> same EOF thing, and I'm not sure how to handle it...
18:31:15 <edwardk> dunno, can't build trifecta right now. moved to ghc head to play with constraints for a bit
18:31:32 <djahandarie> Couldn't have moved to GHC HEAD in another folder? :P
18:31:55 <edwardk> possibly, but copumpkin gave me this beautiful little installer and tempted me with it for days
18:31:59 <djahandarie> lol
18:32:06 * copumpkin laughs evilly
18:32:10 <copumpkin> I builded it myselfff
18:32:16 <djahandarie> lol
18:32:21 <djahandarie> Constraint kinds are pretty awesome though
18:32:27 <djahandarie> Extension of the year, or something like that
18:32:38 <copumpkin> well, the kind polymorphism is going in too, soon
18:32:42 <edwardk> yeah
18:32:43 <copumpkin> and autolifting
18:32:48 <copumpkin> we'll have lots of sweet toys to play with
18:32:48 <djahandarie> Really?
18:32:51 <edwardk> kind polymorphism makes me happy
18:33:04 <edwardk> class Typeable (a :: k) -- finally!
18:33:04 <djahandarie> Autolifting?
18:33:10 <edwardk> one Typeable to rule them all
18:33:13 <djahandarie> lol
18:33:37 <copumpkin> djahandarie:
18:33:38 <copumpkin> data Nat = Zero | Suc Nat
18:33:43 <djahandarie> Oh, okay.
18:33:46 <copumpkin> data Vec :: * -> Nat -> * where
18:33:52 <copumpkin> Nil :: Vec a Zero
18:33:52 <edwardk> data Leibniz a b = Leibniz (forall f. f a -> f b) -- gets the right kinds too, so you can work with Leibniz Maybe or Leibniz Int, etc.
18:33:54 <djahandarie> Yes yes
18:34:24 <rwbarton> so how many ways are there to write unsafeCoerce in GHC HEAD currently
18:34:29 <djahandarie> Having more powerful kinds kind of makes constraint kinds not as cool
18:34:36 <edwardk> i think the iso hack still works
18:34:38 <Sgeo|web> > let x = 1 in (let x = 2 in x)
18:34:39 <lambdabot>   2
18:34:44 <dylukes> copumpkin: What is kind polymorphism?
18:34:48 <dylukes> auto lifting seems really neat.
18:34:53 <edwardk> djahandarie: au contraire, the best examples mix both =)
18:34:57 <copumpkin> what edwardk just wrote
18:34:58 <Sgeo|web> > let x = 1 in (let x = x+1 in x)
18:35:02 <lambdabot>   mueval-core: Time limit exceeded
18:35:17 <copumpkin> the kind of Leibniz is a -> a -> *
18:35:23 <copumpkin> where a could be *
18:35:26 <copumpkin> or (* -> *)
18:35:29 <copumpkin> or whatever
18:35:40 <dylukes> ah I see.
18:35:57 <djahandarie> edwardk, well, yeah, but kind constraints made some stuff a hell'a'lot less uglier, like RMonad. But proper kinds will make that even better
18:36:23 <edwardk> the main thing i'm looking forward to are nice indexing sets, yes
18:36:23 <djahandarie> Now we just need to lift functions automatically too
18:36:30 <edwardk> so we can build real categories, etc.
18:36:34 <djahandarie> Ya
18:36:37 <edwardk> (*,*) as a kind
18:36:41 <djahandarie> Hoot
18:36:43 <edwardk> that sort of thing
18:36:56 <edwardk> so we make the category and specify the kind of its objects
18:37:09 <djahandarie> You ever see my ugly hacking of that?
18:37:11 <edwardk> then (->) is just a Functor for kind *
18:37:15 <djahandarie> Actually, I don't even know if I finished that
18:37:20 <djahandarie> Probably didn't
18:37:35 <edwardk> i have a huge pile of this stuff in scala where i can use subtyping and huge bounded leibnizian equality tricks to fake it
18:37:51 <edwardk> so i've been playing with this for a long time
18:38:37 <edwardk> https://github.com/ekmett/magpie causes the scala compiler to emit illegal code into the jvm at last check
18:39:09 <edwardk> https://github.com/ekmett/magpie/blob/master/src/main/scala/magpie/subtype.scala is basically the subtyping machinery i'm lifting into constraints in haskell right now
18:39:31 <edwardk> minus the bounds
18:39:34 <hpaste> djahandarie pasted â€œlolâ€ at http://hpaste.org/52856
18:39:42 <djahandarie> That is where I was at with mine
18:39:47 <djahandarie> Broken at the moment though, didn't finish it
18:40:31 <djahandarie> Apparently I was in the middle of writing induction on constraints
18:41:15 <djahandarie> Oh, that Delay thing was pretty cool
18:41:29 <edwardk> *nods*
18:42:15 <djahandarie> It basically let me apply type families later on by just refering to them with a tag
18:42:34 <hpaste> edwardk pasted â€œLiskov Substitutability of Constraint Kindsâ€ at http://hpaste.org/52857
18:42:41 <edwardk> this is what i'm currently hacking up
18:43:16 <djahandarie> UndecidibleInstances, cop out :P
18:43:20 <edwardk> no
18:43:25 <edwardk> that is actually not needed
18:43:31 <djahandarie> Oh, nice
18:44:17 <edwardk> actually it apparently is with the Class (Class (Class)) stuff in there
18:46:24 <edwardk> basically the Class class is used to reify the subtyping relationship between a class and its superclasses while the Instance class is used to reify the relationship between an instance head and its context
18:46:45 <edwardk> both give rise to subtyping relationships on Constraint kinds that can be composed and manipulated
18:47:25 <djahandarie> I like how the majority of lines here are of the form "basically... [insert some crazy gibberish here]"
18:47:39 <edwardk> the channel or my code?
18:47:44 <djahandarie> The channel :P
18:48:23 <djahandarie> Wait, why have you been hacking on constraint kinds all day?! Don't you have work to do ;)
18:48:41 <edwardk> yep, figuring out issues with a type system that is very similar =)
18:48:54 <DrSyzygy> djahandarie: edwardk is one of the people who can plausibly claim to have THAT as his job
18:49:34 <DrSyzygy> Me, I spent the day writing a Java wrapper for a library I used to maintain, and then try to figure out how to recast statistician-speak about PCA into geometry language.
18:50:51 * djahandarie wonders off to go finish some school work :(
18:51:17 <augur> hmm
18:51:40 <augur> not using procedures makes using variable environments tricky
18:51:45 <ddarius> DrSyzygy: That should follow pretty easily from the geometric view of eigenvalues (?)
18:51:59 <augur> jmcarthur: does haskel use actual substitution or does it have environments?
18:52:13 <DrSyzygy> ddarius: Probably, but I lack too much intuition for what the covariance matrix does to easily figure it out on my own.
18:52:26 <edwardk> augur: implementation dependent
18:52:42 <augur> edwardk: ok
18:52:58 <augur> edwardk: is one method preferably, would you say?
18:53:46 <edwardk> augur: well, depends, with mutability you can gain a log factor doing the substitution, in exchange for your type checking process yielding ephemeral values and having to start all over if you need to backtrack
18:53:47 <ddarius> No serious implementation of anything uses substitution.
18:54:35 <edwardk> ddarius: depends on the notion of substitution being used i suppose
18:54:51 <edwardk> naive substitution no, but barendregt convention gets used a lot
18:55:50 <dylukes> 7.4 looks like it's going to offer at least 30 milliOlegs more type hackery :|
18:56:28 <edwardk> i just want kind polymorphism so i can clean up and generalize most of this stuff
18:56:45 <ddarius> class Category (hom :: k -> k -> *) where ...
18:56:52 <edwardk> yep
18:56:57 <edwardk> that will make my day
18:57:02 <edwardk> product categories!
18:57:08 <edwardk> i can forget semigroupoids for a while
18:58:03 * ddarius kind of feels like getting ice cream.
18:59:16 <edwardk> instance (Category (c :: kc -> kc -> *), Category (d :: kd -> kd -> *)) => Category (Product c d :: (kc,kd) -> (kc,kd) -> *)
18:59:18 * BMeph kind of feels like ddarius getting ice cream.
18:59:38 <edwardk> is there any place open that sells it at this hour here?
18:59:54 <augur> edwardk: whats barendregt convention?
19:00:17 <edwardk> augur: every binder gets a unique variable id, so you can perform substitution without dealing with certain capture issues
19:00:34 <augur> edwardk: ah
19:00:41 <edwardk> it means you need to have a globally fresh variable supply available though at pretty much all times
19:00:45 <edwardk> ghc uses it heavily for instance
19:01:12 <ddarius> The bindings to these unique variable ids are still held in an environment.
19:01:43 <rwbarton> edwardk: if I write "data Refl :: Constraint -> Constraint -> * where Refl :: Refl a a", does "equivToRefl :: (a :~ b) -> Refl a b ; equivToRefl (Equiv Dict Dict) = Refl" type check?
19:01:56 <edwardk> not necessarily, i can perform the substitution when i instantiate the quantifier.
19:02:21 <Louis11> What does the >> mean in an expression like: aToken TokElse >> statement ?
19:02:57 <ddarius> edwardk: No places like Cold Stone are open.
19:03:26 <kmc> Louis11, it's an operator
19:03:27 <kmc> @src (>>)
19:03:28 <lambdabot> m >> k      = m >>= \_ -> k
19:03:30 <edwardk> you mean :~ or ~ ?
19:03:35 <rwbarton> I mean :~
19:03:41 <edwardk> the one i gave?
19:03:50 <rwbarton> yes
19:03:59 <edwardk> er duh just looked at the next line
19:04:05 <Louis11> kmc: So is >> equivalent to >>= (bind)?
19:04:05 <kmc> Louis11, sequences two monadic actions, discarding the result of the first
19:04:10 <kmc> no
19:04:15 <kmc> m >> k      = m >>= (\_ -> k)
19:04:56 <BMeph> Louis11: It means, "Do the effect of the stuff before the '>>', but throw away it's value, then do the stuff after it."
19:04:57 <Sgeo|web> @src (>>)
19:04:58 <lambdabot> m >> k      = m >>= \_ -> k
19:04:58 <edwardk> rwbarton: not directly, going to play with it for a minute
19:05:07 <BMeph> *its
19:05:14 <EvanR_> BMeph: you dont have to explicitly throw away anything ;)
19:05:27 <kmc> for values of "effect" and "do" and "then" which may be surprising :)
19:05:33 <EvanR_> just do the effects
19:05:41 <edwardk> i wouldn't expect it to though
19:05:46 <BMeph> kmc: No to mention 'stuff'. ;)
19:06:07 <ddarius> @google "n-stuff"
19:06:09 <lambdabot> http://www.nstuffmusic.com/
19:06:09 <lambdabot> Title: Best Online Musical Instrument & Pro Audio Source | N'Stuff Music
19:06:11 <rwbarton> edwardk: because you don't expect the type checker to work that way, or because you think it is unsound?
19:06:13 <ddarius> hmm
19:06:15 <kmc> also "it", "of", and "the"
19:06:18 <edwardk> both =)
19:06:29 <rwbarton> hm, ok, why the latter?
19:06:30 <edwardk> one is real structural equality, the other is equivalence
19:06:40 <edwardk> ~ says that they have the same representation
19:06:53 <rwbarton> ok, so (x a, x a) /~ x a
19:07:02 <edwardk> (Eq b, Ord a, a ~ b) and (Ord a) don't necessarily have the same representation
19:07:23 <monochrom> since it's parser combinators, you can say, parse according to what aToken TokElse says, then parse according to what statement says
19:07:59 <rwbarton> I assume lambdabot doesn't have constraint kinds yet
19:08:16 <ddarius> It wouldn't help much if lambdabot did.
19:08:27 <edwardk> what i spent the last couple of evenings trying to do is figure out how i can make something like ~ work as bidirectional entailment on constraints in a haskell typechecker, since thats kinda what happens when ghc does unification on higher rank types anyways
19:08:31 <Louis11> BMeph: So if we are throwing out the value, what exactly is the point? Is the "effect" modifying something that is used in the second part, but not actually 'returning' a value?
19:08:56 <kmc> the exact point depends on which monad you're working in
19:08:57 <ddarius> Louis11: What's the point of a void function in C?
19:08:59 <kmc> > Nothing >> Just 3
19:09:00 <lambdabot>   Nothing
19:09:20 <kmc> for the Maybe monad, the point is "check if it's Nothing and return Nothing if so, regardless of the rest"
19:09:23 <EvanR_> in that case theres no value to throw away
19:09:38 <kmc> i.e. for Maybe, (>>) provides a very simple useful function you may have wanted before
19:09:46 <kmc> Nothing >> _ = Nothing;  Just _ >> x = x
19:09:59 <kmc> for the IO monad, the point is to perform IO effects
19:10:09 <kmc> (putStr "Hello, " >> putStrLn "world!")
19:10:11 <monochrom> aToken TokElse will likely consume a token, even if you ignore it
19:10:20 <kmc> we don't care about the result of putStr (it's just () anyway) but we want the effects
19:10:40 <kmc> this sounds like a parsing monad, so the actions can consume input and possibly fail, even if the result of that sub-parser is not used
19:10:56 <Louis11> ddarius: Doesn't return anything, just performs some operation. I take it >> is similar then?
19:11:04 <ddarius> Louis11: No.
19:11:58 <edwardk> rwbarton: basically equiv is carrying around a couple of coercions that know how to witness the isomorphism between a and b, we know they are isomorphisms because a and b being constraints have (theoretically) one unique inhabitant, if you ignore incoherent instances
19:11:59 <DanBurton> You could say that "for the Maybe monad, the point is to perform Maybe effects"
19:12:09 <ddarius> Louis11: I believe what you meant to say is correct, but what you said is rather far from what I believe you meant to say.
19:12:36 <ddarius> Everyone loves poset categories.
19:12:43 <EvanR_> DanBurton: doesnt seem very effectful
19:12:47 <edwardk> yep
19:12:47 <rwbarton> right.
19:12:48 <Louis11> ddarius: Well I know in C, a void function can take in parameters and work with those parameters inside of the function, but it does not return a value.
19:12:51 <kmc> DanBurton, I could say that, but I don't, because it's confusing :)
19:12:51 <monochrom> for the XMonad, the point is to perform X effects <duck>
19:13:03 <ddarius> monochrom: Exactly.
19:13:04 <DanBurton> It just depend on how you define "effect"
19:13:07 <kmc> Louis11, read my explanation :)
19:13:25 <EvanR_> DanBurton: then all we need is a single word in the language, and its definition is different in each instance ;)
19:13:50 <ddarius> koo
19:13:51 <DanBurton> EvanR_: precisely. That word is >>
19:14:02 <kmc> monads are about effects, as long as you redefine the word "effect" to mean "anything a monad could be about"
19:14:16 <kmc> similarly monads are containers, as long as you redefine the word "container" to mean "monad"
19:14:20 <EvanR_> DanBurton: well >>=
19:14:28 <EvanR_> otherwise you cant even make a turing machine
19:14:34 <kmc> they're analogies, somewhat better than "burrito", but still limited
19:14:47 <ddarius> Monads are a convenient way of abstractly modelling computational effects.  This is but one application.
19:14:52 <edwardk> i still say comonads are burritos
19:14:56 <rwbarton> so is (,) on constraints by definition associative, but not idempotent or commutative?
19:15:13 <rwbarton> and I suppose it would be unital as well
19:15:13 <EvanR_> comonads are chimichangas
19:15:16 <rwbarton> or is it none of those things?
19:15:24 <edwardk> the associativity idempotence and commutativity are all when its placed on the left of =>   but not part of how it is checked by ~, which is somewhat annoying
19:15:25 <DanBurton> Monads are <insert incoherent but surprisingly pertinent category theory here>
19:15:36 <ddarius> Interesting.
19:15:44 <rwbarton> Ah
19:15:46 <kmc> remember that time #haskell spent an hour talking about what monads are?
19:15:51 <ddarius> Let's just throw in an ACI unifier.
19:15:52 <kmc> good times
19:15:54 <edwardk> ~ is checking to see if it is structurally identical, which is why i had to make all those witnesses of equivalence
19:16:03 <EvanR_> what ARE monads REALLY
19:16:04 <DanBurton> kmc: what you mean every other day?
19:16:32 <edwardk> since a => (b => r) -> r  gives me a way to say that a constraint 'a' implies a constraint 'b'
19:16:37 <EvanR_> imagine figuring out ways to describe what groups were, over and over
19:16:38 <Louis11> monads are confusing O_O
19:16:42 <ddarius> DanBurton: He meant that time a quarter of an hour ago.
19:16:52 <Louis11> I suspect I should read up on them before continuing. Any good resources?
19:16:53 * DanBurton tries to join #monad but it says "you must be invited" :(
19:16:58 <EvanR_> groups seem to be about as complex as monads
19:17:03 <djahandarie> God damn, monads are not confusing at all, I can't believe we still suck at explaining this.
19:17:07 <ddarius> EvanR_: Groups are just simple groupoids.
19:17:29 <kmc> Louis11, a good resource is your Haskell tutorial
19:17:38 <kmc> Monads are easy but there are a lot of prerequisite concepts
19:17:47 <djahandarie> Groupoids are just categories where every morphism is invertible.
19:17:47 <kmc> it's something you should get to in the course of following the tutorial
19:17:52 <edwardk> and preordered classes are just thin categories
19:18:08 <Louis11> kmc: My haskell tutorial?
19:18:11 <kmc> yes
19:18:14 <kmc> how are you learning Haskell?
19:18:41 <EvanR_> to understand monads, dont use IO
19:18:42 <Louis11> google, irc mostly. I also have a book that I consult periodically
19:18:44 <EvanR_> youll get confused
19:18:47 <kmc> you should read that book
19:18:53 <kmc> I would be very suspicious of any standalone documents about monads
19:18:55 <kmc> here's why
19:18:56 <kmc> @where burrito
19:18:56 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
19:19:13 <kmc> Louis11, it really is not a difficult concept, but there's a lot of hype and misinformation and confusion
19:19:23 <kmc> and we joke about that every time it comes up, which probably makes things worse
19:19:26 <EvanR_> also they have the problem of being 'too simple'
19:19:33 <Louis11> i'll go grab my book and start reading :P
19:19:40 <kmc> yes, it feels like there should be more to "get" than there is
19:19:40 <EvanR_> if theres not enough complexity for the brain to attach to, it can slip through
19:20:00 <kmc> EvanR_, functional programming in general has the same problem
19:20:09 <Louis11> yea i've often heard (from phd candidates no less) that monads are extremely confusing, and difficult. I suppose that doesn't help my understanding much . . .
19:20:31 <kmc> phd candidates in...?
19:20:35 <EvanR_> kmc: might be why crap like c++ is so appealing
19:20:50 <kmc> EvanR_, it's one reason why Haskell beginners gravitate towards typeclass monstrosities rather than functional programming
19:20:52 <EvanR_> theres endless complexities to 'get'
19:20:53 <Louis11> kmc: Computer Science
19:21:08 <kmc> :/
19:21:28 <djahandarie> Fail
19:21:33 <Louis11> yea :-/
19:21:35 <EvanR_> > fail
19:21:35 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Base.String -> m a)
19:21:36 <lambdabot>    arising...
19:21:41 <EvanR_> > fail ""
19:21:42 <lambdabot>   No instance for (GHC.Show.Show (m a))
19:21:42 <lambdabot>    arising from a use of `M8868807558...
19:21:55 <kmc> EvanR_, a big pile of classes and instances and existential wrappers gives the mind something to hold on to
19:22:14 <kmc> solutions which are just some functions passed to other functions are so simple you'd never think of them
19:23:27 <monochrom> this may also explain why people hug platonism and "ingenious" math proofs and reject Dijkstra's "let the symbols do the work". apart from personal pride.
19:23:31 <kmc> and I'd say Haskell as a whole has endless complexities to 'get'
19:23:42 <BMeph> kmc: Also, types are strict. ;)
19:23:44 <kmc> but monads are only a small part of that
19:24:50 <EvanR_> i say this too simple theory is important in physics, the most successful theories end up being so simple no one gets it
19:24:59 <kmc> Louis11, you might want to start here in LYAH: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
19:25:03 <EvanR_> until they write best sellers for pop sci crowd
19:25:15 <EvanR_> with 500 pages of decorative language
19:25:17 <monochrom> and why people prefer to build systems so complicated it has no obvious errors, rather than systems so simple it has obviously no errors
19:25:27 <Louis11> kmc: One of the resources I've been consulting.
19:25:40 <djahandarie> I wonder if it's possible to define a category in terms of a monad.
19:26:10 <rwbarton> well, there's the "free category on a graph" monad
19:26:50 <rwbarton> of course, good luck saying what that means without defining category first
19:28:04 <EvanR_> i still havent gotten a straight answer regarding what js arrays are really
19:28:05 <shirt> anyone have an opinion about the fclabels package?
19:29:13 <monochrom> @quote array
19:29:14 <lambdabot> ghc says: DsExpr.dsExpr: Infinite parallel array!
19:29:19 <monochrom> @quote array
19:29:20 <lambdabot> gwern says: Haskell has the best arrays around; problem is, we don't know which module it is.
19:29:35 <EvanR_> lol
19:30:14 <monochrom> @quote nlogax array
19:30:14 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
19:30:18 <monochrom> that one
19:30:50 <EvanR_> thats a great quote
19:32:01 <monochrom> I also take that position in my HXT tutorial. Section title: "what are arrows?" Section content: "I won't answer this question."
19:33:04 <lolo> which is the best graphical API for haskell?, which one you recommed me?
19:33:42 <rwbarton> does IOListArrow actually satisfy the Arrow laws?
19:33:45 <monochrom> then I go ahead to show sample code of what HXT's arrow does, and say it's specific to HXT's arrows. there is nothing to show about unspecified arbitrary arrows, really.
19:34:10 <monochrom> I think so.
19:34:16 <copumpkin> IOListArrow?
19:34:43 <rwbarton> IOLA a b = a -> IO [b]
19:34:53 <monochrom> IOListArrow is in HXT
19:34:54 <copumpkin> isn't it just Kleisli of ListDonerightT IO??
19:35:12 <rwbarton> isn't that ListDoneWrongT IO
19:35:18 <copumpkin> oh, maybe
19:35:31 <copumpkin> I was assuming it'd be DoneRight, but it might be DoneWrong too
19:35:37 <rwbarton> But I don't actually know what the arrow laws are so...
19:35:45 <copumpkin> maybe we should parametrize ListT by a phantom type that represents whether it's done right or wrong
19:36:11 <EvanR_> or left
19:36:18 <monochrom> what does ListDoneRightT IO expand to?
19:36:48 <rwbarton> something like ListIO a = Nil | IO (Cons a (ListIO a))
19:37:00 <rwbarton> though I forget where exactly the IO should go
19:37:06 <monochrom> I see.
19:38:01 <rwbarton> You can try to write down a monad instance for IO [a] but it won't be associative
19:38:10 <rwbarton> I think sigfpe might have a blog post about this
19:39:10 <Saizan> http://www.haskell.org/haskellwiki/ListT_done_right#Implementation
19:48:31 <ddarius> A (small) category is a (2-)monad in the bicategory of spans of sets.
19:49:26 <DanBurton> > fail :: IO Int
19:49:27 <lambdabot>   Couldn't match expected type `GHC.Types.IO GHC.Types.Int'
19:49:27 <lambdabot>         against i...
19:49:54 <DanBurton> > fail :: IO ()
19:49:54 <lambdabot>   Couldn't match expected type `GHC.Types.IO ()'
19:49:55 <lambdabot>         against inferred typ...
19:50:03 <ddarius> fail expects an argument
19:50:05 <djahandarie> > fail "boat" :: IO Int
19:50:06 <lambdabot>   <IO Int>
19:50:09 <DanBurton> lol
19:50:36 <DanBurton> :t fail
19:50:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
19:50:57 <djahandarie> You know it's really good when it's directly referring to String.
19:51:46 <ddarius> BS.readFile "foo" >>= fail
19:52:18 <djahandarie> fail = return . unsafeCoerce
19:52:41 <ddarius> djahandarie: Feel free to verify the above definition of small category.
19:53:53 <Sgeo|web> djahandarie: I don't think that's quite the typical definition?
19:54:25 <Sgeo|web> fail = const launchMissiles
19:55:06 <monochrom> fail s = launchMissiles (dns_lookup s)
19:55:25 <djahandarie> ddarius, the 2-morphisms would be maps between spans?
19:55:34 <ddarius> Yes.
19:56:16 <djahandarie> ddarius, if we replace sets with V, do we get an enriched category?
19:56:50 <ddarius> You get a notion of an enriched category.
19:56:52 <djahandarie> i.e., a 2-monad on the bi-category Span(V) is a V-enriched category
19:56:55 <djahandarie> Cool
19:58:19 <ddarius> You can also do this construction on the coKleisli category of a monad on top of this bicategory and you'll get a generalized notion of multicategories.
19:58:54 <ddarius> Or rather a monad on Set.
19:59:39 <ddarius> Actually, I guess it wouldn't be a coKleisli category.
20:00:12 <ddarius> Or would it?
20:01:37 <ddarius> The notion of "enriched category" that you'd get would be basically the notion of an internal category.
20:03:36 <djahandarie> Is there a generalization of spans in the same way you can generalize an internal category from pullbacks to monoidal categories?
20:04:28 <rwbarton> for an internal category you need pullbacks, surely? Do you mean enriched category?
20:05:22 <djahandarie> http://ncatlab.org/nlab/show/internal+category+in+a+monoidal+category
20:05:38 <rwbarton> oh yes, you can do this also
20:05:56 <rwbarton> I didn't know it had been written down anywhere actually
20:07:07 <rwbarton> and sure, you replace a span from A to B by an A-B-comodule
20:07:09 <ddarius> djahandarie: The generalization would be that.
20:07:21 <djahandarie> Right.
20:08:53 <djahandarie> Okay, I need to take a break before my head explodes.
20:08:58 <kniu> hi
20:09:10 <kniu> I am stuck trying to figure out how to use the Haskell bindings of LLVM
20:10:01 <kniu> why is the function type in the type of the generator itself?
20:13:42 <Axman6> kniu: can you link to what you're talking about?
20:23:57 <kniu> Axman6: http://augustss.blogspot.com/2009/01/llvm-llvm-low-level-virtual-machine-is.html
20:24:16 <kniu> mAddMul :: CodeGenModule (Function (Int32 -> Int32 -> Int32 -> IO Int32))
20:28:09 <kniu> "Since the LLVM API is typed it's much easier to translate a typed abstract syntax tree than an untyped abstract syntax tree."
20:28:12 <kniu> Well there's my problem.
20:28:52 <Axman6> i don't think it's any more typed than LLVm itself is
20:31:00 <kniu> The problem I'm having is that my typed AST doesn't use GADTs
20:32:27 <kniu> I can't just pull the type of the thing I want to generate out of thin air.
20:36:12 <kniu> I got two choices here
20:36:17 <Axman6> kniu: there's some work being done on a simpler LLVM library, that just produces LLVM assembly text (derived from what's used in GHC)
20:36:22 <kniu> either I use the FFI instead,
20:36:25 <Axman6> m3ga: you about?
20:36:34 <kniu> or I convert my AST to use GADTs
20:36:38 <kniu> Axman6: oh?
20:36:43 <kniu> is it on hackage?
20:36:51 <Axman6> not yet i don't think
20:36:59 <m3ga> Axman6: yes
20:38:54 <m3ga> i'll just go back to what i was doing.
20:38:56 <Axman6> m3ga: any news on that simpler LLVM package? I remember seeing emails about it recently, but wasn't sure who was working on it
20:39:15 <m3ga> its on the haskell-llvm mailing list
20:39:31 <m3ga> i don't remember where the discussion ended up
20:39:55 <Axman6> kniu: http://projects.haskell.org/pipermail/haskell-llvm/2011-October/thread.html
20:40:49 <kniu> Axman6: thanks
20:40:59 <kniu> I can't quite find the docs
20:41:02 <Axman6>  Karacsony Mate seemed to say he'd try and do it... but that's about it
20:41:07 <kniu> for the LLVM C FFI
20:41:15 <kniu> like, what's on Hackage is extremely sparse.
20:41:34 <Axman6> i think the LLVM package assumes quite a bit of knownedge of LLVM itself
20:41:34 <kniu> and LLVM's website itself doesn't provide the C interface docs.
20:41:49 <kniu> well, it probably does
20:41:51 <Axman6> which is a shame
20:41:52 <kniu> I just can't find them.
20:42:13 <kniu> Axman6: a shame?
20:43:48 <ivanm> does it make sense for a graph traversal function to return some "Traversal type" to be used by the user?
20:44:26 <JoeyA> @hoogle traverse
20:44:27 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:44:28 <ivanm> (thus letting users be able to get the results of the traversal for their own ends without them needing to implement a similar such function)
20:44:28 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
20:44:37 <ivanm> if so, what, would a good type be?
20:44:45 <ivanm> JoeyA: ummm.... yeah, that doesn't apply here
20:45:02 <ivanm> I mean like "here is the results from doing a breadth-first traversal/search"
20:45:07 <JoeyA> LLVM: The easy-to-use compiler infrastructure nobody knows how to use.
20:45:22 <ivanm> @remember JoeyA LLVM: The easy-to-use compiler infrastructure nobody knows how to use.
20:45:23 <lambdabot> Done.
20:45:28 <JoeyA> lol
20:46:15 <JoeyA> ivanm: Is the graph mutable?
20:46:24 <ivanm> JoeyA: if you mean in-place, no
20:46:30 <JoeyA> okay
20:46:31 <ivanm> but yes, it's not a static graph
20:46:35 <JoeyA> hmm
20:46:42 <ivanm> just like FGL graphs, etc.
20:47:04 <ivanm> all I need this traversal for atm is re-labelling
20:47:24 <JoeyA> Suppose you want to grab all of the vertices in the graph.  Can the list be returned as a lazy list?
20:47:32 <ivanm> but I figured it could be used for creating a spanning tree, search, etc.
20:47:39 <ivanm> JoeyA: already done
20:47:44 <JoeyA> Or could edges or vertices be inserted, invalidating the list?
20:48:02 <ivanm> well, you can
20:48:18 <ivanm> same as with adding a value to a list and then the previously calculated length is wrong
20:48:19 <copumpkin> ivanm: is there a datastructure for DAGs that lets you insert edges/vertices and detect efficiently if it would stop being a DAG?
20:48:42 <ivanm> copumpkin: not that I know of
20:48:59 <ivanm> my graph _does_ have face-finding functions
20:49:20 <ivanm> and I've toyed with making them be part of the graph and recalculated each time you change it
20:49:29 <ivanm> but it probably isn't feasable
20:49:51 <JoeyA> Is there a mailing list where people review each other's Hackage modules?
20:51:47 <ajnsit> Is it possible to write a function that takes in ANY algebraic data type and returns an html form that basically creates an instance of the data type?
20:52:05 <ajnsit> or something similar to that
20:52:17 <ivanm> ajnsit: not AFAIK
20:52:24 <JoeyA> ivanm: Suppose we have a directed graph of values of type IORef Bool, and the user wants to write an IO action to traverse the graph starting from a set of reachable nodes and marking any reachable nodes.
20:52:50 <ivanm> JoeyA: maybe we're talking at cross-purposes here... :p
20:52:59 <ivanm> I have an existing (non-monadic) graph type
20:53:04 <JoeyA> ajnsit: class HTMLForm.  Go make it :-)
20:53:28 <JoeyA> (unless such a thing already exists)
20:53:28 <ivanm> I'm going to be adding traversal functions so that I can re-label it (so that the nodes are in BFS order)
20:53:28 <ajnsit> JoeyA, well but then I would need to derive an instance for each data type
20:53:36 <ddarius> One could make a generic function
20:53:39 <ajnsit> how can I make it generic
20:53:59 <ajnsit> ddarius, how?
20:54:00 <JoeyA> If you're using Template Haskell, I haven't a clue.
20:54:13 <ivanm> does it make sense to somehow have an intermediary function that returns some kind of "Traversal" type that gives you the results of doing the traversal that could then be consumed by the calling function?
20:54:26 <ivanm> if so, what information should this Traversal type have?
20:54:31 <ajnsit> JoeyA, not using Template Haskell
20:54:33 <ivanm> ddarius: Data.Typeable ?
20:54:47 <ivanm> possibly using syb or something as well
20:55:00 <JoeyA> ajnsit: You could say: instance (HTMLForm a, HTMLForm b) => HTMLForm (a, b)
20:55:24 <ajnsit> ivanm, I looked at Data.Typeable but I don't think it can do it
20:55:45 <ivanm> JoeyA: I think he wants so that you can do "data Foo = Bar | Baz" and can automatically use it without needing to create a specific instance
20:55:59 <kniu> well dang
20:56:05 <ivanm> ajnsit: AFAICT you need some kind of dynamic approach like that, or go via Show/Read
20:56:10 <kniu> they got a C++ tutorial and an OCaml tutorial.
20:56:12 <kniu> No C tutorial.
20:56:16 <rwbarton> ajnsit: Data.Data
20:57:13 <rwbarton> alternatively one of the other dozen or so generic programming frameworks
20:57:13 <ivanm> ajnsit: what would you want such a function for?
20:58:12 <ajnsit> ivanm, to avoid work :)
20:58:27 <ivanm> ajnsit: as in you need such functionality?
20:58:34 <ivanm> or you're just trying to think of something cool to do?
20:58:36 <Saizan> there's the rather new Generics extension too
20:58:44 <ivanm> if the former: _why_ do you need it?
20:59:36 <ajnsit> ivanm, well okay so I have this application that I want to convert to a web application
21:00:14 <ajnsit> and it involves creating datatypes and passing them around to multiple users
21:00:30 <ivanm> sounds like a use for Binary or something
21:00:35 <ajnsit> think of something like a bug tracker.. a bug is created and then goes through various users
21:00:44 <ivanm> or are you wanting end users to create actual values directly without some form of parsing, etc.?
21:00:53 <ajnsit> ivanm, yes
21:01:02 <Axman6> :|
21:01:04 <ajnsit> I'm fine with users having access to Haskell
21:01:06 <Axman6> not cool
21:01:18 <ivanm> ajnsit: wait, why would a bug tracker need users to be able to provide actual code _values_ ?
21:01:27 <ivanm> rather than just giving it as a text blog?
21:01:33 <ivanm> *blob
21:01:39 <ajnsit> ivanm, it's not really a bug tracker.. It's a generic application
21:02:01 <ajnsit> ivanm, so the user creates a data type, chooses which users need to create the data, approve the data etc.
21:02:29 <ajnsit> I need a way to allow an easy way for the user to create a datatype
21:02:36 <ivanm> ajnsit: _maybe_ using mueval?
21:02:48 <rwbarton> what?
21:03:09 <ajnsit> ivanm, even with eval, how would I derive a form from a datatype that the user entered?
21:03:53 <ivanm> nfi :p
21:03:54 <rwbarton> ajnsit, in practice, you will probably need to give some extra information anyways to customize the display
21:04:17 <rwbarton> unless you want your pop-up menu options to all be single words starting with a capital letter, etc.
21:04:22 <ivanm> I'm still trying to work out why you would want to be able to let users create new data types
21:04:26 <ajnsit> rwbarton, well this is not a production application.. its a small internal thing
21:04:38 <ivanm> some kind of meta-extending the web page at runtime or something?
21:05:21 <ajnsit> ivanm, entering a datatype seems the easiest thing to do
21:05:27 <rwbarton> ivanm, ajnsit wants to take "data Bool = False | True" and produce "<input type=menu><option>False</option><option>True</option></input>" or so
21:05:43 <ajnsit> rwbarton, yes exactly
21:05:58 <ivanm> rwbarton: wait, I thought he wanted the opposite
21:06:17 <Sgeo|web> In general, can/should I think of monad transformers like StateT s MaybeT IO a as IO(Maybe (State s a))?
21:06:25 <Sgeo|web> In that sort of backwards fashion?
21:06:25 <ajnsit> ivanm, nope. what rwbarton said
21:06:28 <ivanm> ajnsit: use a type-class, or use some kind of generic programming approach (which uses Data.Typeable)
21:06:40 <ivanm> you'll need Typeable instances, but they're derivable with the appropriate extension
21:06:48 <rwbarton> you can certainly do this with Template Haskell, and probably some generic frameworks give you access to the constructor/record field names which seems like the main obstruction here
21:06:59 <rwbarton> you need Data.Data instances
21:07:04 <ivanm> Sgeo|web: well, you have a State wrapped around a Maybe wrapped around IO
21:07:54 <Sgeo|web> I can see that my type is probably less useful than IO(State s (Maybe a)), but that's clearer written in that form, at least to me with my limited knowledge of Monad transformers
21:07:59 <ajnsit> ivanm, I looked at Typeable and it doesn't really allow me to traverse the data type
21:08:11 <ajnsit> rwbarton, I'll look into Data.Data
21:08:18 <ajnsit> thanks!
21:08:55 <ajnsit> I wonder if this will turn out to be a cool project :)
21:09:02 <JoeyA> My two cents: just make it a type class.  Writing the instances manually gives you a bit more flexibility, and shouldn't be too tedious if you define your forms in a declarative style.
21:09:07 <rwbarton> ajnsit, I've wanted something like this before
21:09:20 <ivanm> JoeyA: it could get tedious for large data types with many constructors
21:09:38 <JoeyA> true
21:10:25 <ajnsit> ivanm, plus it *should* be doable.. I don't see why I should have to write typeclasses when it's not strictly necessary
21:10:51 <Saizan> Sgeo|web: it's actually "s -> IO (Maybe (s,a))" because StateT is weird like that
21:10:55 <ivanm> ajnsit: well, you need something to let you examine the structure of a data type
21:11:04 <ivanm> which means either explicit instances, TH or using generic programming
21:11:22 <ajnsit> I found this - http://www.haskell.org/haskellwiki/TV
21:11:44 <ajnsit> which looks interesting.. but maybe I'm misinterpreting it
21:12:12 <ajnsit> ivanm, yup.. Hopefully Data.Data lets me do that
21:12:14 <ivanm> never heard of it
21:12:21 <ivanm> ajnsit: it should
21:12:26 <ivanm> but you willl need Typeable instances
21:12:38 <ivanm> so it won't quite do _any_ type automatically
21:12:38 <ajnsit> ivanm, okay
21:12:48 <ivanm> but Typeable is deriveable with the right extension
21:13:31 <Sgeo|web> Why can't Typeable be automatically derived?
21:13:38 <Sgeo|web> When would you not want to derive it?
21:15:25 <ivanm> Sgeo|web: it can be, it just needs a GHC extension
21:15:38 <ivanm> it isn't one of the default ones because it isn't in the Haskell Report (I think)
21:16:22 <rwbarton> ajnsit: yeah, TV is rather like what you want to do.  I think Conal may be working on an HTML-based version of that project actually
21:17:45 <kfish> Sgeo|web, sec 7.5.3 in http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html
21:17:58 <ajnsit> rwbarton, yeah but looking at it, TVs seem more focused on encapsulating behaviour
21:18:17 <ajnsit> I only want simple UI generation
21:20:02 <Sgeo|web> Hmm
21:20:05 <Sgeo|web> What happened to Bird?
21:20:19 <Sgeo|web> I kind of want a Sinatra-like thing, but "inactive" kind of scares me
21:20:20 <turrosec> putos
21:23:29 <ivanm> Sgeo|web: my guess is that the developer didn't want to bother maintaining it anymore
21:23:42 <ivanm> the three main web frameworks in Haskell are Yesod, Snap and Happstack
21:24:03 <ivanm> (though Happstack doesn't seem to be used for much new stuff anymore AFAICT)
21:24:12 <Sgeo|web> Are they all overkill for simple two second apps?
21:24:42 <Sgeo|web> Note: I've never really done web programming
21:24:44 <Sgeo|web> I want to start
21:25:53 <ajnsit> we need something like Zenity for GUI/Web apps in Haskell
21:26:28 <stepcut> ivanm: people still use happstack for new stuff.. they just don't talk about much, unless something breaks :)
21:26:40 <ivanm> heh, fair enough
21:26:50 <ivanm> Sgeo|web: well, if it's just static, then yes
21:27:48 <Sgeo|web> What about something for use by, say, an object in Second Life? Just a service that when passed a parameter, returns something
21:28:00 <Sgeo|web> Not static
21:28:27 <kfish> Sgeo|web, something like snap would be fine for that
21:28:39 <Sgeo|web> Is Snap better than Yesod for that?
21:28:49 <kfish> yesod would also be fine for that
21:28:49 <Sgeo|web> I know a (very, very little) more about Yesod than Snap
21:28:52 <ivanm> Sgeo|web: snap is simpler to pick up by all accounts
21:28:59 <Sgeo|web> Ah
21:29:12 <Sgeo|web> I should probably attempt to learn Iteratees
21:29:16 <stepcut> ivanm: oh really?
21:29:21 <ivanm> I think Yesod's main aim is to provide as much safety for associated data as possible (javascript, CSS, etc.)
21:29:27 <ivanm> stepcut: well, no TH
21:29:39 <ivanm> and less confusing types
21:29:49 <ivanm> which are the two complaints mentioned about Yesod usually
21:29:53 <ivanm> @google snap vs yesod
21:29:54 <lambdabot> http://stackoverflow.com/questions/5645168/comparing-haskells-snap-and-yesod-web-frameworks
21:29:54 <lambdabot> Title: web services - Comparing Haskell's Snap and Yesod web frameworks - Stack Overflo ...
21:30:19 <kfish> Sgeo|web, you shouldn't need iteratees to just return some data based on an input ... unless you're streaming out video or textures or something
21:31:08 <stepcut> ivanm: happstack has some pretty fine documentation .. and no TH
21:31:23 <ivanm> stepcut: right, but it doesn't have the "new and cool" factor anymore :p
21:31:34 <ivanm> I don't do web stuff anyway, so it all goes over my head :p
21:31:47 * ivanm goes back to playing with graphs
21:32:08 <stepcut> ivanm: :)
21:32:39 <ivanm> I'm trying to make chrisdone happy by replacing all my uses of fromJust with fromMaybe (error errMsg)
21:32:51 <ivanm> though it's sometimes difficult to work out what a good error message would be... >_>
21:33:04 <mightybyte> Sgeo|web: If you're interested in Snap, check out #snapframework.  We're pretty responsive to questions there.
21:33:18 <DanBurton> imho the TH in Yesod is pretty straightforward
21:33:40 <ion> https://gist.github.com/1300431 An example of Numeric.Probability.Distribution usage: solving the Monty Hall problem
21:33:56 <ion> Felt like a good way to get familiar with N.P.D :-)
21:34:18 <ivanm> which package is that from?
21:34:23 <ivanm> statistics?
21:34:25 <Saizan> stepcut: oooh, weird, happs had TH everywhere
21:34:26 <shirt> ivanm: if only ghc reported full/better stack traces for errors, you wouldn't have to do this :/ although you shouldn't be using fromJust that much anyway
21:34:44 <stepcut> Saizan: only in the acid stuff
21:34:46 <ion> @hackage probability
21:34:46 <lambdabot> http://hackage.haskell.org/package/probability
21:34:53 <ivanm> shirt: well, I have fromJust everywhere internally because it _should_ be safe
21:35:01 <ivanm> (especially since I worked out the bugs)
21:35:12 <stepcut> Saizan:  there is a little TH in happstack to deal with some ipv6 stuff. but that is internal only.. never called directly by users
21:35:26 <ivanm> I'm starting to replace them in places where the user could specify dodgy data though
21:36:17 <mightybyte> Saizan: Maybe you're thinking of the TH for happstack-state?
21:36:40 <Saizan> ivanm: "If you're reading this i'm a terrible programmer" is a good error, but add details about the source location :)
21:36:59 <ivanm> Saizan: heh
21:37:14 <ivanm> probably a good point; I've just said _why_ it occurs
21:37:22 <kfish> ivanm: sounds like a C programmer explaining why their code will never segfault
21:37:37 <stepcut> Saizan: these days, even if you use acid-state / safecopy, I think there are only two template haskell functions. deriveSafeCopy and inferIxSet. And you actually don't have to use inferIxSet anymore. That is optional.
21:37:38 <Saizan> mightybyte: yeah, i think so, and for deriving other classes
21:37:52 <Sgeo|web> I saw something about running Haskell web apps on Heroku, how suitable would that be for someone like me (generally not that knowledgeable about WAI and Heroku, but don't exactly need professional-quality workingness)
21:38:06 <ivanm> kfish: I use data-clist to represent the edges around a node
21:38:28 <stepcut> Saizan: So, I think deriveSafeCopy is really the only TH haskell function around these days..
21:38:33 <ivanm> so a lot of times it returns Maybe values (e.g. focus :: CircularList a -> Maybe a) because of the empty case, or the equivalent of find, etc.
21:38:57 <mightybyte> Saizan: And that's still totally different than Yesod's use of TH.
21:39:35 <ivanm> most of the times, I _know_ that the rotation is safe (well, admittedly, as long as the rest of my code is correct)
21:39:54 <ivanm> graph stuff gets fiddly :s
21:41:13 <stepcut> Sgeo|web: I am going to bed, check out the crash course, and see what you think, http://happstack.com/docs/crashcourse/index.html
21:41:14 <kfish> :)
21:41:21 * shapr hugs stepcut
21:41:50 <ddarius> ivanm: Just replace all the error messages with GUIDs.
21:42:15 <ivanm> ddarius: as in location GUIDs?
21:44:57 * stepcut boings
21:45:43 <Sgeo|web> I guess Yesod is more similar to something like Ur/Web than Snap is? (I don't understand Ur/Web _at all_, but it sounds cool)
21:47:25 <Sgeo|web> And none of these are similar to Seaside, which I'm guessing is pretty much the anti-Haskell way of approaching things, I'd guess?
21:47:35 <mightybyte> I'm sure there are people who would disagree with that characterization, but I think it does have some validity.
21:47:53 <Sgeo|web> mightybyte: which one, the Ur/Web comparison, or the Seaside remark?
21:47:59 <mightybyte> Ur/Web
21:48:22 <mightybyte> Funny you mention Seaside.  Someone else brought that up not too long ago.
21:48:43 <ivanm> OK, so I can abstract away the type of traversal (DFS vs BFS) by just saying whether to use a stack or a queue... is it that bad if - for simplicity - I use a Sequence to represent a stack as well as a queue?
21:49:11 <mightybyte> I tend to view continuation-based web servers/frameworks as an anti-pattern for web development.
21:49:23 <ivanm> (that way I won't have a type parameter leaking through my wrapper around how to do a traversal)
21:50:51 <Sgeo|web> Question about Yesod: Yesod stores session in an encrypted signed cookie, right? What if I want to increment a session variable, but don't want the user to be able to use the old session data
21:50:58 <Sgeo|web> That is, only the new session data should be valid
21:51:06 <Sgeo|web> And using the old one would be tampering
21:51:46 <Sgeo|web> The way I understand that Yesod does sessions, that would be at risk for an attack
21:52:00 <luite> Sgeo|web: yesod doesn't have built-in support for database-backed sessions, you can work around it by storing some unique id in the session itself and then use persistent or perhaps acid-state to store the data
21:52:14 <accel> does haskell work on osx lion?
21:52:16 <accel> i must know
21:52:20 <accel> otherwise i am fucked
21:52:21 <ivanm> accel: yes
21:52:24 <accel> as I just upgraded to osx lion
21:52:24 <accel> phew
21:52:26 <accel> i am saved
21:52:29 <ivanm> whether there is a prebuilt binary available is a different story :p
21:52:32 <accel> fuck
21:52:34 <luite> accel: yes ghc works, but 64 bit is a bit experimental
21:52:38 <accel> victory
21:52:45 <accel> anyone want to follow up with badness?
21:52:47 <luite> I had some issues with it
21:52:51 <Axman6> accel: you might have problems if you haven't installed Xcode 4.2
21:52:52 <accel> damn it
21:53:01 <accel> getting xcode 4.2 right now
21:53:02 <Axman6> uh, 4.1
21:53:02 <accel> all I care is this:
21:53:09 <accel> does haskell platform work with osx lion + xcode 4.2 ?
21:53:12 <luite> xcode 4.2 is probably problematic
21:53:28 <Axman6> accel: possibly not, 4.2 doesn't come with gcc
21:53:32 <luite> since it has removed gcc
21:53:37 <accel> damn it
21:53:41 <accel> i just got xcode 4.2
21:53:44 <accel> it doesn't come with gcc?
21:53:45 <accel> wtf
21:53:52 <Axman6> it comes with llvm-gcc and clang
21:54:02 <accel> you know what?
21:54:05 <accel> i don't think it matters
21:54:07 <accel> looks like my ghc
21:54:12 <accel> from my snowleopard still works
21:54:15 <accel> i.e. i upgraded from snow leopard
21:54:28 <accel> maybe i just not touch anything
21:54:34 <accel> and act like a bull in a china shop
21:54:36 <accel> and stand very very still
21:55:07 * ddarius doesn't think bulls stand very still in china shops.
21:55:34 <luite> Sgeo|web: this issue has been mentioned on the github issue tracker, there might be an additional backend for sessions in the database, but they prefer keeping the lighter weight clientsession because of its simplicity and performance
21:55:41 <accel> ddarius: have you ever seen a bull in a china shop in real life?
21:55:43 <holmak> you don't have to guess, it has been tested by Science
21:55:51 <holmak> mythbusters, at least
21:56:13 <shapr> really?
21:56:33 <holmak> Yep. It ran around really fast and knocked almost nothing over
21:57:27 <accel> really? cool
21:57:29 <Sgeo|web> How is Yesod's use of TH at all confusing?
21:57:31 <accel> I have never seen a bull in a china shop in real time.
21:57:44 <EvanR_> only turn based
21:57:50 <luite> Sgeo|web: it isn't really, in practice. but it can obscure error messages in some cases
21:58:23 <Sgeo|web> Ah
21:58:31 <luite> users don't really have to write TH, unless they want to seriously extend some core libraries
21:58:42 <Sgeo|web> I haven't actually written enough real Haskell code to actually be familiar with Haskell error messages in general
21:58:44 <holmak> accel, shapr: It is easily google-able, I will not defile #haskell with youtube links
21:58:55 <Sgeo|web> Just toy code usually
21:59:06 <ddarius> @where catsters
21:59:07 <lambdabot> http://www.youtube.com/user/TheCatsters
21:59:36 <Sgeo|web> Although my next idea is to write a monad for a math thing that I'm utterly clueless about and will watch a YouTube video to learn
21:59:38 <luite> Sgeo|web: ok, there is some disadvantage of Yesod there, since it tends to have more complex types than the alternatives
22:00:11 <ddarius> Monads 3 is entertaining.
22:00:11 <Sgeo|web> luite: Are these more complex types .. in what way are they a hinderance? Do I actually have to _understand_ them to use Yesod?
22:00:53 * ddarius recommends understanding integrated circuit design before progrmming.
22:01:06 <kfish> i like the bit in monads 3 where bruce willis blows up the automaton with a burrito
22:01:22 <shapr> me too!
22:01:24 <shapr> That's my favorite part!
22:02:05 * shirt waits for someone to add that to the quote catalog
22:02:13 <luite> Sgeo|web: nah you can work from the examples and most will be ok. but error messages can be scary
22:03:17 <Sgeo|web> How complicated are these types, exactly?
22:04:45 <Sgeo|web> @help where
22:04:45 <lambdabot> where <key>. Return element associated with key
22:04:48 <luite> Sgeo|web: well all web frameworks work in some monad transformer stack, that's still the same, in yesod you have some extra types for the typesafe urls
22:04:55 <Sgeo|web> @where goldilocks
22:04:55 <lambdabot> I know nothing about goldilocks.
22:05:35 <Sgeo|web> When someone makes a monad transformer stack, they usually make it so you don't have to worry about lift etc?
22:05:37 <stepkut> it's great that, (.) = (<<<), but I wish there was something similar for (>>>)..
22:05:43 <luite> Sgeo|web: yep
22:06:02 <Sgeo|web> Because I'm thinking of Haskellifying an obscure library for a virtual world
22:06:22 <Sgeo|web> Wondering whether I should provide a monad transformer stack for ease of use, and what it should include
22:06:42 <Axman6> stepkut: use (.), it's the backwards version of (.)
22:06:43 <stepkut> Sgeo|web: i usually do (via a class)
22:06:44 <Axman6> >_>
22:06:58 <stepkut> Axman6: :-/
22:07:02 <luite> Sgeo|web: you rarely need lift with Yesod, I know two exceptions: when calling something from the "master site" from within a widget, and there's another lift for some cases where you need exception handling
22:07:07 <Axman6> :P
22:07:09 <Sgeo|web> What do classes have to do with I don't want to write out the whole thing so I'll call it m.t.s.
22:07:14 <stepkut> Axman6: I don't get it
22:07:43 <luite> the latter is due to a limitation of monad-control, and I think yesod should be updated to remove the lift requirement
22:07:50 <Axman6> ah, don't worry
22:08:10 <stepkut> Axman6: I'm very worried!!!
22:09:18 <luite> Sgeo|web: and all frameworks require liftIO lifts if you use IO functions in your request handlers, but those are very simple to use
22:09:48 <stepkut> luite: only because people right functions with the type, IO a, instead of (MonadIO m) => m a :p
22:09:57 <stepkut> s/right/write/
22:10:02 <kfish> Axman6, only when using your ReverseIdentifiers extension
22:10:32 <Axman6> heh, glad someone got it, i was beginning to think it was a truly terrible joke
22:10:55 <kfish> continue with that thought, let us know where it ends up
22:10:58 <stepkut> for now I use, o = (>>>), f `o` g, but a single character would be nice
22:11:22 <stepkut> ($) = (>>>), almost makes sense... f $ g
22:11:47 <Sgeo|web> ($) = id
22:11:50 <kfish> Axman6, let pilf = flip flip in pilf
22:12:23 <rwbarton> f `o` g for f >>> g will seriously confuse many people
22:12:32 <luite> > ($) 1 -- not quite
22:12:33 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
22:12:33 <lambdabot>    arising from a use of `...
22:12:46 <Sgeo|web> luite: that's just ($) having a more restricted type
22:12:50 <ajnsit> are there any tutorials for using the Data.Data class? I have been trying to make sense of it for 15 minutes to no avail
22:13:42 <stepkut> rwbarton: I want to have a simple compositional parser like, (,) <@> "foo" . int . "-" . char, that returns (Int, Char).. or something to that effect
22:13:57 <stepkut> rwbarton: but, while that looks pretty.. the . go in the wrong direction
22:14:06 <stepkut> so that would really return (Char, Int)...
22:14:39 <rwbarton> :t <*
22:14:40 <lambdabot> parse error on input `<*'
22:14:41 <stepkut> that parser would, ideally, parse "fooa-2" into ('a', 2)
22:14:43 <rwbarton> :t (<*)
22:14:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
22:14:48 <stepkut> too noisy
22:15:05 <rwbarton> er
22:15:09 <rwbarton> it's one extra character
22:15:23 <stepkut> yeah, but you have to explicitly mark all the things you want to ignore
22:15:32 <stepkut> you can't have self-ignoring combinators..
22:15:48 <rwbarton> it doesn't look like you can do that with what you wrote either
22:16:04 <rwbarton> perhaps you should supply more context
22:16:14 <stepkut> rwbarton: I can do this, "foo" `o` int `o` "-" `o` char
22:16:25 <stepkut> but that is hard on the eyes I think
22:16:25 <rwbarton> with overloaded strings?
22:16:28 <stepkut> too many ` and "
22:16:29 <stepkut> yeah
22:16:47 <stepkut> with out overloaded strings it would be, lit "foo" `o` int `o` lit "-" `o` char
22:17:30 <stepkut> the goal is to make something that is atleast as easy to read as, "foo%c-%i", but which is also type-safe
22:18:19 <rwbarton> how exactly do you define these int and char and lit btw?
22:18:27 <stepkut> rwbarton: one moment
22:18:59 <Sgeo|web> Can wai-handler-webkit be made to work with frameworks other than Yasod?
22:19:24 <ivanm> Sgeo|web: most of them are
22:19:46 <luite> Sgeo|web: I think happstack can be used with wai soon
22:19:47 <ivanm> generally speaking, the Haskell web "frameworks" are just a collection of mix-and-match libraries that work with any framework
22:20:00 <ivanm> especially since WAI is aimed at being a generic interface between all of them
22:20:48 <stepkut> ivanm: except, currently only Yesod actually supports WAI. Happstack is moving towards it. But snap seems to be firmly against it still.
22:21:01 <ivanm> any idea why?
22:21:04 <ivanm> mightybyte: ^^
22:21:40 <stepkut> ivanm: they claim it is too early to standardize
22:21:42 <mightybyte> See my answer here.  http://stackoverflow.com/questions/7700619/standard-web-server-interface-equivalent-to-wsgi-rack-for-haskell/7716863#7716863
22:22:03 <Axman6> i think i've realised why web programming in haskell isn't doing that well (feel free to disagree with me), but you end up with so much non Haskell code compared to the code you write that makes everything work, it feels like it's all boilerplate
22:22:35 <stepkut> Axman6: non Haskell code?
22:22:49 <ivanm> stepcut: the CSS, Javascript, etc.
22:22:51 <Axman6> all the HTML/HTML producing code
22:22:59 <kmc> you think it's not doing well?
22:23:01 <Axman6> yeah, and those too
22:23:02 <stepkut> Axman6: ah
22:23:39 <ivanm> mightybyte: so you're saying that there's no real point in trying to devise a "common interface" until everyone has settled down into what each framework needs/wants out of such an interface
22:23:45 <Axman6> kmc: not really. there's wuite a bit of development being done, but compared to something like rails, the ratio of people using it is pretty low
22:23:48 <mightybyte> ivanm: Exactly.
22:23:57 <Veinor> i do admit when i was hacking on snap-login-example it felt like i was mostly writing boilerplate, some of which could definitely be derived for me
22:23:59 <luite> is WAI really meant to be a fixed standard? it make much more sense as a low-level http server and web-framework support library
22:24:03 <ivanm> Axman6: isn't that true in any language's web framework?
22:24:17 <mightybyte> There was more detailed discussion about this on the web-devel mailing list awhile back.
22:24:20 <luite> in that sense, it should just evolve with the requirements of the users, the web frameworks
22:24:31 <kmc> Axman6, I don't think comparing to Rails is useful
22:24:31 <Veinor> but at the same time i feel like this is not an intrinsic property of haskell webdev
22:24:31 <Axman6> ivanm: i remember it was quite a bit nicer in rails when i played with it years ago
22:24:37 <stepkut> luite: and indeed, it has..
22:25:07 <mightybyte> luite: The problem is that there isn't agreement on what the standard should be.
22:25:10 <Axman6> anyway, i don't have much desire to do any web programming these days anyway
22:25:12 <kmc> far more people know Ruby than know Haskell, and that will probably always be true
22:25:28 <kmc> and it's not a bad thing either
22:25:48 <Axman6> but, one of the main reasons people learnt ruby was to use rails
22:25:48 <kmc> focus on being good, not on being popular
22:25:57 <Axman6> for many people, rails is how they learny ruby
22:26:11 <kmc> i don't think Haskell's killer app will be a web framework
22:26:11 <Veinor> kmc: no point in being good if you don't get at least somewhat popular
22:26:29 <kmc> yeah but Haskell is already beyond "somewhat popular"
22:26:40 <mightybyte> We could easily put up Snap's interface as a competing standard to WAI, but there's not much point in that.
22:27:05 <kmc> anyway, I think the differential advantage of Haskell over Ruby is much smaller if you're making "just a webapp" than if you're making, say, a compiler
22:27:15 <Veinor> yeah.
22:27:24 <luite> kmc: there are many rails and django users unhappy about their languages though, especially for scaling (switching to some cps framework (node?) or erlang is a big step) and how fragile the apps are when refactoring
22:27:47 <kmc> personally, I'd be interested in Haskell web frameworks as a way to put a nice UI on some other Haskell project
22:28:05 <Veinor> otoh I feel like a lot of the boilerplate I was writing was just 'okay how do I get this to typecheck'; I don't think I ever had code that typechecked that didn't work
22:28:20 <Axman6> yeah, that's the only thing i've wanted to use web frameworks for too
22:28:22 <kmc> I'm not going to write a vanilla CRUD webapp in Haskell
22:28:26 <luite> unfortunately haskell cannot really offer the productivity of Rails yet, with any of the frameworks
22:28:38 <luite> unless you're doing something special
22:28:46 <kmc> that's not an interesting problem, so I want to use mature tools and write something a lot of other people can maintain
22:29:16 <Veinor> kmc: stop discouraging me! :(
22:29:34 <Axman6> i also remember it was no very hard at all to make a rails app that looked good, and did what you expected in a day or so
22:29:46 <kniu> are either lennart augustsson or bryan o sullivan here?
22:30:10 <kmc> i mean, if you want to evangelize Haskell to web programmers, that sounds great
22:30:18 <mightybyte> kniu: bos is here
22:30:20 <Veinor> imo, 'looks good' is orthogonal-ish to the framework
22:30:35 <kmc> i'm objecting to the idea that not as popular as rails â‡’ failure
22:30:51 <Axman6> well, that wasn't really my point
22:30:53 <Veinor> kmc: oh, sure. i guess i'd just like haskell to be more popular in general, you know?
22:30:56 <kniu> bos: what is the way to compile functions to LLVM using the high-level bindings?
22:31:08 <kmc> i have mixed feelings about Haskell being more popular in general
22:31:16 <kmc> I noticed today that Hackage has 20% as many packages as PyPI
22:31:22 <Axman6> my point is that people aren't using the haskell web frameworks because learning to use them seems to be quite a lot of work
22:31:28 <kmc> that's pretty damn popular for an obscure academic language nobody uses ;)
22:31:43 <Veinor> haha
22:31:53 <c_wraith> eh?  Learning Snap takes like...  about 20 minutes.
22:32:16 <c_wraith> depending on how much hackage hates you, installing it can take longer than that.
22:32:20 <Veinor> learning the basics of snap does; learning how to build a simple login webapp using snaplets took me a lot longer
22:34:45 <Axman6> c_wraith: i think my problem might have been i needed to know more about web programming in general
22:35:08 <Veinor> but like if i'd just wanted to do basic processing based on URL parameters, yeah I could've done that quickly
22:35:52 <luite> Axman6: I think that Yesod is actually aiming for some kind of Rails status, where people come to the language for the framework, that happens to be written in Haskell. That's also why they take more liberties with TH and QQ, the main point is to provide some framework that's as convenient as possible, making everything look like idiomatic haskell is less important
22:36:06 <c_wraith> Axman6: well, yes.  It's a complicated domain if you don't know anything about it.
22:36:41 <Veinor> luite: i think that sounds right. tbh i kind of like that, but i have some weird thing against yesod for no good reason. i just don't feel like using it, and i really can't explain why
22:37:48 <Axman6> Veinor: me too
22:37:59 <Axman6> the name puts me off actually, not sure why
22:38:40 <kmc> it's just hard for me to imagine an organization using Haskell for vanilla web development, when Rails and Django and PHP programmers are everywhere
22:38:41 <Axman6> the name feels old somehow, not new and fresh and cool. i don't get any feeling of  "hell yeah, i totally want to try playing with yesod!"
22:39:02 <mightybyte> kmc: My company uses Haskell for web development.
22:39:13 <kmc> i know there are a few
22:39:28 <kmc> but I don't think it will ever be close to as popular as Rails and Django and PHP
22:39:29 <mightybyte> Although admittedly, that's mainly because I'm there. :)
22:39:37 <kmc> and i think making it that popular would be a silly goal
22:39:50 <JoeyA> Yesod looks futuristic to me, as far as framework names go.
22:39:53 <JoeyA> @google Yesod
22:39:54 <lambdabot> http://www.yesodweb.com/
22:39:54 <lambdabot> Title: Yesod Web Framework
22:40:04 <kfish> Axman6, "yea, i verily seek to parlay with yesod!"
22:40:11 <kmc> the comparison to the adoption of Rails is not very accurate
22:40:16 <luite> Veinor: well, it certainly has a long way to go, I'm not quite happy about the quality of the code yet
22:40:17 <Veinor> http://en.wikipedia.org/wiki/Yesod_(Kabbalah)
22:40:21 <JoeyA> right
22:40:31 <kmc> because fundamentally Ruby is pretty similar to many other languages that most programmers would have seen before
22:41:05 <luite> Veinor: (I use Yesod in a personal project and I've committed a few relatively minor fixes and improvements)
22:41:15 <kmc> i mean if you know Perl or Python you can be writing decent Ruby code in an afternoon
22:41:25 <kmc> Haskell takes much much longer to learn
22:41:33 <kmc> especially if one claims the advantage over Ruby etc. is performance
22:41:34 <Veinor> luite: yeah.
22:41:43 <kmc> mightybyte, what advantages do you see from it?
22:41:51 <kmc> also, how many people work on the codebase besides you?
22:42:02 <mightybyte> kmc: from what?
22:42:08 <kmc> using Haskell for webdev
22:42:15 <mightybyte> Ahhh
22:42:24 <mightybyte> I'll steal a quote from someone else.
22:42:34 <mightybyte> "A spoonful of Haskell makes the web programming go down."
22:43:46 <mightybyte> Ahhh, it was Oejet who originally made that statement.
22:43:52 <kfish> i think haskell is good for projects that matter. if your web site doesn't matter, php/python/ruby are great because you can hire people you don't care about to work on it
22:43:56 <Axman6> i hope you don't mean it makes the server go down D:
22:44:24 <kfish> otoh, if your website matters then haskell is a good choice
22:44:44 <maustin> I've been learning Haskell on and off, and it makes complete sense - except for monads :)
22:44:44 <kmc> if your website doesn't matter then why are you doing it
22:44:56 <Veinor> maustin: monads come with experience
22:45:03 <luite> kfish: depends, it's probably difficult to find/train new programmers quickly if your site suddenly grows beyond expectations
22:45:07 <Axman6> there's a guy in #macosx who things that haskell is completely useless, even after finding about where it's used. he's a lot of un to play with
22:45:09 <mightybyte> And that quote is exactly what it was for me.  I've never liked web programming.  I wanted to build a website and I was using Drupal and PHP, but the underlying data model was complex.
22:45:10 <ddarius> kmc hasn't seen the web for the last 20 some years.
22:45:14 <luite> or if some of the existing team leave
22:45:20 <maustin> every time I think I know what it is, it's really only part of it
22:45:23 <Veinor> ddarius: hahaha
22:45:25 <mightybyte> It got so bad that I simply couldn't motivate myself to work on it.
22:45:35 <Axman6> maustin: monads make more sense once you just start using them. they're a lot easier to use than undetstand
22:45:40 <Axman6> understand*
22:45:56 <mightybyte> When I switched to Haskell, things became interesting again.  There was actually some intellectual stimulation.
22:46:06 <maustin> but I'm the type that like to know what's really going on
22:46:12 * kfish is looking forward to shans' talk about type-inferencing javascript (in haskell) at tonight's fp-syd :)
22:46:18 <ddarius> luite: It's not -that- hard to get Haskell coders.
22:46:33 <kmc> maustin, monads are simple, but the concept depends on a lot of others
22:46:40 <kmc> maustin, maybe you're confused about one of the prerequisite concepts
22:46:48 <Saizan> ddarius: not even for webdev?
22:47:02 <kmc> "Monad" is often the first case where you're expected to put together type classes, polymorphism over type constructors, higher-order functions, etc.
22:47:58 <kmc> i think monads are easy, but we still suck at explaining them
22:48:23 <kmc> and that in any case we'd have to wait 20 years for all the "lol, monads are so hard" articles to fall off the internet
22:48:26 <luite> ddarius: guess that also depends on where you're located, and whether they can work from home
22:48:43 <ddarius> luite: That's true.
22:48:54 <ddarius> Though the answer to the latter is very likely "yes."
22:49:33 <ivanm> @hoogle Map.insert
22:49:33 <lambdabot> No results found
22:49:36 <luite> yeah I guess if you use a haskell web framework you're likely in some startup that is probably a bit more flexible than some old-fashioned companies :)
22:49:44 <ivanm> @hoogle k -> a -> Map k a -> Map k a
22:49:44 <lambdabot> Data.Map insert :: Ord k => k -> a -> Map k a -> Map k a
22:49:44 <lambdabot> Data.Map insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
22:49:44 <lambdabot> Data.Map insertWithKey' :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
22:50:17 <kmc> "Haskell is good because it makes easy problems hard, so you're actually motivated to work on them"
22:50:20 <ddarius> Not-startup companies have probably even less problems with supporting non-geographically colocated developers.
22:50:39 <maustin> Take something simple:  Just 5 >>= (\x -> return x)  or  [1..5] >>= (\x -> return x)
22:50:57 <kmc> (\x -> return x)  â‰¡  return
22:51:03 <ddarius> kmc: You can't impress your friends by saying your learned something easy.
22:51:05 <kmc> and it's a law that foo >>= return â‰¡ foo
22:51:11 <kmc> but go on
22:51:29 <stepkut> Haskell is good, because even if your programmers suck.. bad haskell code is still pretty good
22:51:42 <kmc> luite, i agree with ddarius, my friends who work for the third-largest software company in the world report that they have a ton of remote workers
22:51:49 <maustin> Both Just 5  and  [1..5] create monads, or are monads? or I've heard that a monad isn't really a value.. akin to a microwave is to food
22:51:51 <kmc> stepkut, no.
22:51:57 <stepkut> kmc: oh ?
22:52:02 <ivanm> maustin: no
22:52:07 <kmc> maustin, "Maybe" and "[]" themselves are monads
22:52:11 <ivanm> they can be monadic _values_
22:52:15 <kmc> if Foo is a monad then Foo is a type constructor
22:52:19 <ivanm> (or monadic actions if you prefer)
22:52:32 <maustin> Maybe = Just a | Nothing
22:52:46 <ivanm> I think the constructors are the other way round, but yes
22:53:00 <ivanm> > Just 3 >>= show
22:53:01 <luite> kmc: Oracle?
22:53:01 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b'
22:53:01 <lambdabot>         against inferred ...
22:53:05 <kmc> luite, yeah
22:53:20 <ivanm> > Just 3 >>= (Just . show)
22:53:21 <lambdabot>   Just "3"
22:53:44 <copumpkin> faka fmap show
22:53:44 <stepkut> kmc: if I have to work with code written by a mediocre programmer, I would deal with the crap they write in Haskell than C++ or python
22:54:01 <Axman6> copumpkin: watch your language
22:54:05 * ddarius wonders if copumpkin has started to lose it.
22:54:19 <copumpkin> faka => aka => a.k.a. => also known as
22:54:36 <ivanm> copumpkin: yeah, I was trying to come up with a simple one-liner demonstrating the Maybe monad
22:55:08 <ddarius> ivanm: Best not to choose examples that involve >>= return . f
22:55:14 <ivanm> yeah
22:55:22 <ivanm> couldn't think of anything else though :
22:55:24 <ivanm> * :s
22:55:29 <ivanm> I suppose a Map lookup or something
22:55:29 <kmc> stepkut, well I've not worked with very many mediocre programmers
22:55:41 <kmc> but I expect they'd produce essentially zero usable code
22:55:55 <coppro> maustin: Monad is a typeclass
22:55:58 <kmc> that might still be an improvement over the equivalent in C++ or Python
22:56:17 <stepkut> kmc: :)
22:56:21 <kmc> maustin, do you understand algebraic data, pattern-matching, type classes, and polymorphic functions?
22:56:40 <maustin> Say you had an operator that does this:   5 >>= (\x -> x)
22:56:51 <coppro> maustin: answer kmc :)
22:56:56 <maustin> Basically without the monad part..  what does the monad add to this?
22:57:00 <ddarius> > (5 >>= id) 'a' 'b'
22:57:01 <lambdabot>   5
22:57:09 <kmc> you need to understand all of those things before you have any hope of understanding monads
22:57:15 <ivanm> ddarius: which Monad is that? the function Monad?
22:57:25 <ivanm> @type (5 >>= id)
22:57:26 <lambdabot> forall (m :: * -> *) b. (Num (m (m b)), Monad m) => m b
22:57:45 <ivanm> so that's the same as const . const 5 ?
22:57:54 <ivanm> maustin: don't try to understand monads if you're just starting out
22:58:02 <ivanm> and learn IO separately
22:58:03 <kmc> i can't imagine a circumstance where "as a microwave is to food" is a useful analogy
22:58:10 <ivanm> RWH's approach on this is really good IMHO
22:58:11 <kmc> it's too close to "burrito", it must be a joke
22:58:18 <mauke> maustin: I don't understand "without the monad part". (>>=) is a method from Monad
22:58:23 <ddarius> kmc: I have to say certainly for C++ I'd rather have mediocre Haskell over even "average" C++.
22:58:50 <kmc> I don't understand why Haskell beginners think they need to run out and learn monads immediately
22:58:54 <kmc> and skip over 5 chapters in the tutorial
22:59:08 <coppro> maustin: the monad offers nothing to that
22:59:08 <ivanm> kmc: because that's seen as _the_ big thing in Haskell for some reason
22:59:09 <kmc> and why anyone would expect success with this approach
22:59:18 <ivanm> ZOMG, everything in Haskell is a Monad!
22:59:27 <kmc> we need more comonads, to balance it out
22:59:27 <maustin> mauke  I was just saying if there were a similar operator
22:59:32 <mauke> maustin: similar to what?
22:59:36 <kmc> maustin, please answer my question before you ask more questions about monads
22:59:39 <ivanm> maustin: except there isn't
22:59:47 <mauke> ivanm: that doesn't help
22:59:47 <ivanm> if there was, then we wouldn't need Monads
22:59:52 <mauke> ivanm: disagree
23:00:09 <ddarius> For a couple of reasons, interesting comonads are more rare in Haskell than interesting monads.
23:00:11 <ivanm> mauke: well, what would be similar to >>= but not actually >>= ?
23:00:20 <mauke> ivanm: nothing
23:00:29 <ivanm> which is my point
23:00:32 <maustin> cps?
23:00:35 <mauke> ivanm: if there was, it would be Monad all over
23:00:51 <ivanm> isn't that pretty much what I said? ;)
23:00:56 <mauke> maustin: the point is that Monad is a common interface for several types
23:01:10 <mauke> maustin: every type has its own definition of >>=
23:02:14 <maustin> can I ask   are Just 5   and  [1..10]  the same type of monad?  vs IO or a state monad
23:02:24 <mauke> what do you mean by "type of monad"?
23:02:28 <mauke> also, none of them are monads
23:02:32 <kmc> you're all wasting your time
23:02:42 <kmc> maustin, you need to learn the basics first
23:03:00 <maustin> true kmc
23:03:06 <kmc> your questions make no sense and the answers are not going to make any sense either
23:03:08 <mauke> well, yeah. knowing the difference between values and types would help
23:03:13 <coppro> maustin: it's like walking into a nuclear reactor and asking to see the uranium
23:03:27 <mauke> coppro: oh, you mean you need to wear a spacesuit?
23:03:31 <kmc> it's like asking for lessons in nuclear reactor design and then ignoring everything because you don't know calculus
23:03:31 <ddarius> coppro: The uranium is the easy part.
23:03:38 <maustin> nice analogy coppro :)
23:03:47 <ddarius> (Well getting it isn't, but what it does isn't all that complicated.)
23:04:01 <mauke> it kills you
23:05:39 <djahandarie> Are we using analogies to explain why explanations via. analogy are bad?
23:05:50 <mauke> yes
23:05:53 <coppro> yup
23:05:59 <mauke> problem, officer?
23:06:15 <mauke> life is like an analogy
23:06:40 <stepkut> rwbarton: http://hpaste.org/52859
23:06:49 <quicksilver> mauke: ...it makes no sense and trying to understand it is pointless?
23:07:01 <stepkut> rwbarton: there is some extra crap in there, but see test1 / parser1
23:10:14 * stepkut goes to sleep
23:14:38 <Saizan> func could be given a more general type
23:15:27 <rwbarton> stepkut: you could reverse the roles of i and o, and then flip the order of composition so that you can use (.)
23:15:36 <rwbarton> possibly this is evil though :P
23:15:57 <stepkut> rwbarton: right. But that means I can't make it an Arrow instance
23:16:05 <stepkut> and it makes >>> and <<< extra confusing :)
23:16:14 <rwbarton> probably I'd just use >>>
23:16:25 <stepkut> I could make it a Contravariant Arrow though (I think)
23:16:27 <rwbarton> or make up a new name for it
23:16:38 <stepkut> so far the best alternatiev name I have is &
23:16:41 <rwbarton> (but certainly not `o`)
23:16:54 <rwbarton> f o g is used in some MLs for f . g
23:17:01 <stepkut> I got `o` from HaXml..
23:17:06 <stepkut> but that doesn't mean it is a good idea :)
23:17:12 <rwbarton> and `O` is often used for type-level composition in haskell
23:17:35 <rwbarton> > let (;;) = id in 3
23:17:36 <lambdabot>   <no location info>: parse error on input `;'
23:18:13 <Saizan> yeah, some unicode variant of ; would be good or \cdot
23:19:54 <rwbarton> > let (..) = id in 3
23:19:55 <lambdabot>   <no location info>: parse error on input `..'
23:20:09 <rwbarton> hm
23:20:13 <rwbarton> > let (...) = id in 3
23:20:14 <lambdabot>   3
23:20:17 <rwbarton> oh right
23:21:13 <rwbarton> does Hayoo not index base?
23:21:20 <stepkut> oh wait, I got it
23:21:41 <stepkut> in normal function application, we just use a blank space, like, Just 'c'
23:21:49 <stepkut> so I can just do
23:21:50 <stepkut> parser1 = ("foo" â£ char 'b' â£ char 'a' â£ char 'r')
23:21:57 <stepkut> where (â£) = (>>>)
23:21:58 <c_wraith> rwbarton: hayoo indexes all of hackage, and doesn't prioritize anything.
23:22:33 <rwbarton> It's not finding (++) from Prelude/Data.List
23:23:51 <c_wraith> you know, it might miss base, due to the fact that it can't be installed from hackage.
23:23:58 <c_wraith> that's just a random guess, though
23:24:21 <maustin> kmc: a little late, but yet I'm somewhat familiar with atds, pattern matching, type classes and polymorphic functions - but no, I have not done a lot of programming with them.  monads just seem like a different beast
23:25:40 <Axman6> anyone know if there's a way to block until an exception is thrown at you?
23:27:17 <c_wraith> forever $ threadDelay 10000000
23:27:29 <maustin> and it's pretty hard not to use them when you start off with "main = do"
23:27:34 <c_wraith> or whatever other large number you might want to put in there.
23:27:45 <Axman6> c_wraith: yeah, i guess that would work
23:27:56 <rwbarton> > let (?) = (+) in 3 ? 4
23:27:56 <lambdabot>   7
23:28:22 <c_wraith> maustin: ignore that it has anything to do with monads, and just say you're programming with IO.
23:28:25 <Axman6> wondering if there's a different way to simplelent IVars in haskell than how they're implemented in data-ivar
23:28:34 <rwbarton> > let (#) = (+) in 3 # 4
23:28:35 <lambdabot>   <no location info>: parse error on input `)'
23:28:39 <Saizan> maustin: you could run stuff in ghci in the meantime, so you don't need a main
23:28:54 <c_wraith> Axman6: did you look at the implementation in monad-par?  It's also complicated
23:29:00 <maustin> Im using hugs atm
23:29:26 <c_wraith> really, the fact that IO forms a monad is *almost* irrelevant.
23:29:40 <c_wraith> The only way that's relevant is that sometimes helper functions work in non-IO contexts, too
23:29:43 <Axman6> c_wraith: yeah, i've looked at it. it's pretty cool. but for the usage i'm after i think it could be useful to use exceptions
23:29:51 <rwbarton> Weird, that isn't a parse error in my local GHC.
23:29:59 <Saizan> maustin: hugs has an interactive mode too
23:30:08 <c_wraith> rwbarton: lambdabot has the MagicHash extension enabled
23:30:15 <rwbarton> even with MagicHash
23:30:19 <rwbarton> (also, why?)
23:30:28 <rwbarton> > 3# +# 4#
23:30:29 <lambdabot>   Not in scope: `+#'
23:30:43 <copumpkin> > I# 3#
23:30:44 <lambdabot>   Not in scope: data constructor `I#'
23:30:48 <copumpkin> :t 3#
23:30:49 <lambdabot> GHC.Prim.Int#
23:30:51 <copumpkin> o.O
23:31:12 <rwbarton> :t I#
23:31:13 <lambdabot> Not in scope: data constructor `I#'
23:31:59 <rwbarton> interesting, -fglasgow-exts makes it a parse error. Woo....
23:35:29 <rwbarton> aha, UnboxedTuples
23:37:03 <rwbarton> > 3#
23:37:04 <lambdabot>   Couldn't match kind `#' against `*'
23:37:08 <kmc> maustin, they're not a different beast.  "Monad" is the name of a type class.  that type class's methods are polymorphic functions (polymorphic in more than the type class variable).  the instances of Monad are type constructors; almost all of them are implemented as algebraic data types, and the methods implemented with pattern matching
23:37:25 <rwbarton> Is there any use of MagicHash in lambdabot that won't result in an error?
23:37:43 <rwbarton> besides ":t 3#"
23:37:44 <mauke> maustin: you can ignore monads if you just want to understand IO
23:37:48 <kmc> > I# 3#
23:37:49 <lambdabot>   Not in scope: data constructor `I#'
23:37:55 <kmc> oh copumpkin tried that
23:38:08 <ddarius> @hoogle #
23:38:09 <lambdabot> No results found
23:38:09 <kmc> maustin was trying to understand things other than IO earlier
23:38:25 <mauke> just sayin, nowhatimsayin
23:38:28 <kmc> maustin, "Monad" is an ordinary type class defined in the standard library.  it's not a language feature
23:38:36 <kmc> the only thing special about it is the "do" syntax
23:39:00 <kmc> but there's a straightforward translation from "do" syntax to ordinary function application
23:40:10 <kmc> > let f n = (# n+1, n+2 #) in case f 3 of (# x, y #) -> (x,y)
23:40:11 <lambdabot>   (4,5)
23:40:21 <rwbarton> aha, nice
23:40:33 <ddarius> :t (# 3# #)
23:40:34 <lambdabot> (# GHC.Prim.Int# #)
23:41:01 <ddarius> :t (# #)
23:41:02 <lambdabot> forall t. t -> (# t #)
23:41:08 <ddarius> Interesting.
23:41:14 <rwbarton> indeed
23:41:27 <mauke> intredasting.jpg
23:41:30 <kmc> :t join (# #)
23:41:30 <lambdabot>     Couldn't match expected type `a1 -> a'
23:41:31 <lambdabot>            against inferred type `(# a1 #)'
23:41:31 <lambdabot>     Probable cause: `(##)' is applied to too many arguments
23:41:35 <kmc> :t join (# , #)
23:41:35 <lambdabot>     Couldn't match kind `(#)' against `*'
23:41:36 <lambdabot>     When matching the kinds of `(# a1, a1 #) :: (#)' and `a :: *'
23:41:36 <lambdabot>       Expected type: a1 -> a1 -> a
23:42:14 <copumpkin> you can't even pass (#) into functions
23:42:17 <ddarius> ???.png
23:42:21 <kmc> right
23:49:11 <maustin> thank you kmc
23:55:53 <maustin> i'm waiting to have a zen moment, so i can do the Jim Carey "I have exercised the demons"
23:56:09 <mauke> misspelling intentional?
23:57:34 <maustin> sure
23:57:55 <osfameron> "Get thee behind me!" == "Heel!" ?
