00:02:41 <wavewave> Quantumplation: is there any reason why you cannot start that graph data structure from simple graph adjacent matrix?
00:04:06 <wavewave> Quantumplation: in many cases, you need several different representation of the same graph depending on the algorithm you are using.
00:05:29 <wavewave> Quantumplation: some algorithm is more adequate for inductive graph definition, some algorithm is more adequate for adjacent matrix representation.
00:05:29 * applicative proposes to mark his copy of System.IO.Unsafe, Foreign, etc with {-#LANGUAGE SafeHaskell#-}
00:13:48 <wavewave> hmm, I hate other language's generator w/o mathematical principle. it keeps adding more and more command with arbitrary rules.
00:15:06 <kmc> generator?
00:15:20 <wavewave> i am reading trampolining in javascript.
00:15:42 <wavewave> yield and such thigns
00:16:36 <wavewave> http://tobyho.com/2010/12/10/tranpolines-in-javascript-and/
00:17:19 <wavewave> mentioned haskell's I/O monad. both clever and beautiful
00:17:29 <wavewave> heh
00:18:09 <wavewave> and it requires you to change your mind-set completely and therefore is unlikely to gain a lot of mindshare.
00:19:43 <kmc> 404
00:19:46 <hydo> But it's called 'trampolining' and that sounds like fun, so it'll get more than if it were called something like 'monads'.
00:20:09 <companion_cube> monads are like trampolines.
00:20:22 <wavewave> oops sorry
00:20:38 <kmc> using Haskell's IO monad requires less mindset-changing than using all the parts of the language that aren't the IO monad
00:20:38 <wavewave> http://tobyho.com/2010/12/10/trampolines-in-javascript-and/
00:21:35 <hydo> kmc: hrm, I guess that's true - never thought of it like that before.
00:22:14 <wavewave> just got interested in this from latest Monad Reader issue.
00:22:45 <wavewave> about coroutine in haskell.
00:22:57 <wavewave> and check what's going on in other language.
00:24:01 <kmc> there's a straightforward description of IO which does not appeal to monads, abstract mathematics, or dubious analogies
00:24:37 <kmc> all it really requires is that you're comfortable with the idea of an imperative procedure as a first-class value
00:24:48 <kmc> which is a common thing in C#, Python, Ruby, and yes Javascript
00:26:18 <ben> kmc: You can take my burritos out of my cold, dead nuclear space suit >:[
00:26:34 <kmc> the difference is that those languages use the same construct for "function as a first-class value" and "imperative procedure as a first-class value"
00:26:43 <kmc> and Haskell has different concepts for each
00:26:55 <kmc> but I don't think this distinction is hard to learn, if it's framed correctly
00:27:02 <kmc> ben, :D
00:27:37 <hydo> good lord, I love that idea, kmc.
00:27:49 <hydo> errr... that description
00:28:15 <ddarius> frerich: That is the simplest domain that is useful.
00:28:44 <erus`> snap 0.6 comes with sessions and authentication built in :)
00:28:52 <ddarius> i <3 ι
00:29:04 <wavewave> lol
00:30:06 <wavewave> mighttpd 2 also now outbeats ngnix.
00:31:11 <kmc> wavewave, Haskell has plenty of design points which don't come from "mathematical principles"
00:31:14 <kmc> some of them are quite wtf
00:32:17 <wavewave> kmc: sure. but other languages cannot be compared, I think.
00:32:32 <kmc> i don't think Haskell is good because it's mathematical
00:32:35 <wavewave> kmc: btw, what's the most wtf design points of haskell, you think?
00:32:56 <companion_cube> rewriting systems are cool, tho
00:33:11 <kmc> it's good because it was designed by smart, careful people, who paid attention to what had been done before, and weren't under a lot of external pressure
00:33:51 <wavewave> kmc: I am not emphasizing mathematics but rather emphasizing consistency.
00:34:02 <kmc> yes, consistency is key
00:34:23 <kmc> too many languages pile on extra rules to second-guess the programmer
00:34:30 <kmc> and the programmer has to third-guess those rules
00:34:46 <wavewave> kmc: *nod*
00:34:59 <kmc> monomorphism restriction is one example of that in Haskell
00:35:32 <wavewave> this 'generator' thing in javascript looks very arbitrary to me.
00:35:38 <kmc> as for other wtf things
00:35:47 <kmc> the numeric class hierarchy is pretty bad
00:35:56 <wavewave> *nod*
00:36:19 <kmc> the original restrictions on type classes are far too severe and result in ugly hacks like Printf's IsChar
00:36:43 <elliott> Haskell is pretty awful and crufty, it's just that everything else is so much worse.
00:37:05 * elliott may have pretty high standards.
00:37:11 <companion_cube> why is the numerical hierarchy bad?
00:37:17 <kmc> layout has a rule like "if there is a parse error, insert a closing brace"
00:37:18 <elliott> companion_cube: there isn't one
00:37:29 <kmc> which is pretty obnoxious if you're trying to write a Haskell parser
00:37:47 <elliott> kmc: Haskell has never cared much about how easy things are on implementors :)
00:38:07 <kmc> elliott, no, I think that motivated most of said type class restrictions
00:38:17 <Quantumplation> wavewave: Hrm... I guess a good place to start would be to define some different graph representations and some helper functions for converting between them?
00:38:32 <elliott> kmc: OK, correction: The committee cared about it, but failed to actually help the situation any.
00:38:37 <wavewave> Quantumplation: yes, that's what I am suggesting..
00:38:56 <elliott> They probably shouldn't care nowadays, considering how much stuff uses advanced GHC extensions. :p
00:39:01 <kmc> also some regressions from Haskell 1.4
00:39:11 <elliott> What did Haskell 98 actually add over 1.4?
00:39:19 <wavewave> Quantumplation: in graph theory,  no single data structure fits for all purposes.
00:39:20 <kmc> H98 dropped the Eval class for seq, and it dropped monad comprehensions
00:39:31 <elliott> kmc: And dropped Void.
00:39:36 <Quantumplation> Ok cool.  So, lets list the ways to represent a graph: the obvious way, with node objects pointing to other node objects; an adjacency matrix;
00:40:12 <wavewave> Quantumplation: and also known algorithms are usually using several different reps.
00:40:21 <kmc> oh, that reminds me of class constraints on data, which are another H98 wart
00:40:46 <wavewave> Quantumplation: yeah.. at first stage, just use plain simple concrete types.
00:40:56 <kmc> and Monad not being a subclass of Functor
00:41:13 <wavewave> Quantumplation: later, you can generalize it very easily.. that's a merit of haskell.
00:41:55 <kmc> and then there are some features (like defaulting, or the meaning of pattern failure in 'do') which I think are good on balance, but are unquestionably a matter of pragmatic programming language design, and have no basis in mathematical principles
00:42:09 <wavewave> Quantumplation: since you are doing this, please implement graph isomorphism algorithm and contribute to hackage ;-)  (I just need it.)
00:42:31 <kmc> i wonder if SMT solvers are good at finding graph isomorphisms
00:42:36 <Quantumplation> hehe sure, want to join #thraskell?
00:42:36 <kmc> plenty of Haskell SMT work
00:44:16 <companion_cube> wait, if you represent graphs by nodes pointing to each others, you will have troubles for cycles
00:44:38 <wavewave> kmc: I didn't know how to use SMT for graph isomorphism problem. thanks for pointing this out.
00:44:59 <wavewave> companion_cube: therefore, adjacent matrix is good for that case.
00:45:20 <companion_cube> or Map Node [Node]
00:45:23 <wavewave> companion_cube: or simply pointer
00:45:26 <wavewave> yes..
00:45:37 <wavewave> pointer map I mean.
00:46:44 <wavewave> or... using tying the knot style inductive graph representation..
00:46:52 <wavewave> hmm, then what will happen?
00:47:21 <wavewave> to observe cycle, you need IO.
00:47:29 * companion_cube vaguely remembers having not understood a single word of thhis technique
00:48:22 <wavewave> companion_cube: it's just referring your result in you definition which is possible in lazy evaluation.
00:49:42 <wavewave> http://www.haskell.org/haskellwiki/Tying_the_Knot
00:50:19 <applicative> uh oh, yet another "why can't cabal install do ..." tempest in a teapot.  the ingrates!
00:54:44 * applicative hugs cabal install; shakes finger at angry so-called redditors
00:55:19 <c_wraith> I've just learned to treat my package database as transient :)
00:55:40 <c_wraith> "yeah, it's time to blow away ~/.ghc and try again"
00:56:02 <wavewave> or use cabal-dev
00:56:11 <applicative> yes, this is my wisdom, I just did it this morning, so I'm loving cabal install more than usual.
00:56:33 <applicative> cabal install is always best the first time
00:56:37 <wavewave> but in fact, I am not using cabal-dev
00:57:11 <c_wraith> cabal-dev does this weird thing where it assumes you aren't doing 20 random things at once.
00:57:15 <wavewave> i am just using global repository and enjoy solving conflict when it happens ;-P
00:58:34 <wavewave> after passing through mtl1/ mtl2 conflict period, now solving conflict is not so difficult relatively.
00:59:48 <applicative> wavewave, yes, that's when i was first learning haskell, the battle of the monad transformer libraries.  why, i didn't even know what a monad transformer was
01:00:26 <rotflcopter> hii
01:00:29 <rotflcopter> > (2/0)/(1/0)
01:00:30 <lambdabot>   NaN
01:00:37 <rotflcopter> how about 2 ?
01:00:44 <wavewave> applicative: you started haskell around similar time as I. :-D
01:01:32 <applicative> rotflcopter: why 2 rather than anything else
01:01:44 <applicative> rotflcopter: no, don't answer that
01:01:51 <wavewave> I am learning haskell by patching some package depending on mtl1 to mtl2 version.
01:02:21 <wavewave> like changing State s to StateT s Identity
01:03:17 <elliott> wavewave: uh, State s = StateT s Identity
01:03:24 <elliott> you can use the former just fine
01:03:37 <wavewave> elliott: it's not in mtl1
01:03:54 <elliott> oh, well right
01:04:05 <elliott> but i'm not sure why that matters if you're upgrading it :)
01:04:53 <wavewave> elliott: I don't remember it exactly.. but it was essentially due to that difference..
01:04:54 * applicative thinks (* -> (* -> *) -> * -> *) is a nice kind to start with 
01:05:21 <wavewave> elliott: It was probably when I fix hmatrix.
01:05:38 * wavewave is checking his old code.
01:07:40 * hackagebot zoom-cache 0.4.0.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.4.0.0 (ConradParker)
01:13:51 <wavewave> couldn't find it.
01:31:27 <hpaste> erus` pasted “snap configure error” at http://hpaste.org/53242
01:38:27 <Quantumplation> data Term = Term !Label ![Term] <-- what's the ! signify here?
01:38:59 <Saizan> Quantumplation: it makes the Term constructor strict in that argument
01:39:33 <Quantumplation> strict in what sense?
01:39:56 <Saizan> in the sense that Term undefined [] == undefined
01:40:15 <Saizan> (as an example)
01:40:41 <Quantumplation> this isn't the case usually? o.O
01:41:08 <Saizan> nope
01:41:48 <Quantumplation> what would Term undefined [] result in without the strict qualifiers?
01:41:58 <Saizan> > case undefined : [] of (_:_) -> ()
01:41:59 <lambdabot>   ()
01:42:06 <Saizan> Quantumplation: itself
01:42:43 <Saizan> Term undefined [] is already in weak head normal form if Term is not strict on its first field
01:43:05 <Quantumplation> :-S that went completely over my head
01:43:40 <Saizan> have you read something about lazyness and algebraic datatypes?
01:44:18 <Quantumplation> yes, but "something" being the key word.  I know what those terms mean individually
01:45:52 <Saizan> well, the point is that you can match on the outermost constructor of a value without forcing its contents
01:46:13 <Saizan> unless those contents are !-ones :)
01:47:27 <Quantumplation> i think it makes sense.  so, if I pass Term undefined [] to a function that only uses the list part of it, it won't care, right?
01:47:51 <Quantumplation> whereas, if it's strict, it will evaluate to undefined.
01:49:14 <Saizan> right
01:59:40 <o-_-o1> is it possible to have a step for map ?
01:59:58 <o-_-o1> I want to create a list of lists from a list
02:01:59 <wavewave> ?
02:02:16 <wavewave> what do you mean by a step for map?
02:02:17 <mah_b> o-_-o1: could you show some input/result example?
02:03:01 <o-_-o1> [0,1,2,3,4,5,6,7,8,9] = [[0,1],[2,3],[4,5],[6,7],[8,9]]
02:03:22 <wavewave> ?
02:04:16 <wavewave> you want to separate lists with a given number of elements?
02:04:23 <o-_-o1> yes
02:04:57 <wavewave> use splitEvery in Data.List.Split
02:05:09 <o-_-o1> wavewave: ok...wow
02:05:16 <o-_-o1> how is it even.... ?
02:05:39 <o-_-o1> Have you guys thought of every possible function in the universe ?
02:05:42 <wavewave> o-_-o1 : even?
02:06:01 <o-_-o1> ...even possible that such a function would exist.
02:06:05 <wavewave> everyone encounters simliar problem. :-)
02:06:18 <o-_-o1> ah...heh
02:07:55 <wavewave> I am also amazed by so many interesting functions in  haskell libraries.
02:09:17 <o-_-o1> Ok, when I try import Data.List.Split, it says could not find module...
02:09:27 <Nimatek> > let splitEvery _ [] = []; splitEvery n xs = take n xs : splitEvery n (drop n xs) in splitEvery 2 [1..10]
02:09:27 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
02:10:19 <o-_-o1> hmm...should I install any additional package ?
02:10:46 <wavewave> it's in split pacakge.
02:10:58 <wavewave> cabal install split
02:11:04 <o-_-o1> ah...ok, I don't think I have it
02:11:05 <o-_-o1> ok thanks
02:11:08 <Nimatek> Or just add the above function to your code.
02:11:45 <o-_-o1> ah...yeah that too
02:13:11 <wavewave> o-_-o1: probably, it's worth to look up functions in split since they will be quite useful some time. but if you are learning haskell now, you also had better implement those by yourself.
02:13:27 <o-_-o1> wavewave: yeah
02:13:56 <o-_-o1> wavewave: I think I have implemented something very similar
02:14:36 <jkff> Hey. I've got a "Redundant UNPACK pragma" warning on a strict field which is a newtype for Integer. Is it, like, that I can only use UNPACK on fields of primitive types?
02:15:13 <jkff> (I'm scattering strictness and unpacks across the Data.Time package, since my program is spending an awful lot of time in date/time manipulations)
02:17:41 <wavewave> jkff: interesting.. just today I read the latest issue of  Monad Reader and it mentioned Data.Time sluggishness.
02:17:41 * hackagebot snaplet-hdbc 0.6.0 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.6.0 (JurrienStutterheim)
02:18:13 <wavewave> jkff: the author says http-date is 20 times faster than Data.Time
02:18:24 <jkff> wavewave: Wow, thanks - that's a good pointer
02:19:25 <jkff> wavewave: Oh. It doesn't seem to have too many features :(
02:19:56 <mah_b> wavewave: http://www.mew.org/~kazu/material/2011-mighttpd.pdf files Date.Time under "show-stopper"
02:21:09 <wavewave> mah_b: yes, thanks for the link of the talk.
02:22:04 <wavewave> jkff: that's unfortunate if it doesn't fit your purpose.. but you can read the source file anyway ;-)
02:22:55 <jkff> wavewave: Actually, I also saw that date/time parsing is ridiculously slow, so I wrote a binding to strptime
02:23:08 <jkff> wavewave: Now I'm suffering on date/time *arithmetic*
02:24:50 <wavewave> for arithmetic, can we use just int and make some convenience function?
02:26:32 <jkff> wavewave: Probably that's what I'll have to do, but I'd do the world a bigger service if I sped up Data.Time instead :)
02:27:44 <wavewave> jkff: yup! and also you can make more convenient functions for http-date package, too ;-)
02:28:52 * wavewave thinks haskell community is somewhat synchronized.
02:33:24 <rotflcopter> is the time required for any transfer function evaluation of haskell a predictable constant independent of input values?
02:33:46 <jkff> rotflcopter: What do you mean under "transfer function evaluation"?
02:34:02 <Cale> Are you talking about Haskell or neural networks? :)
02:34:18 <rotflcopter> generating result from source data using a transfer function
02:34:33 <rotflcopter> Cale<< haskell :)
02:34:38 <Cale> Haskell functions are allowed to take as long as they like to evaluate
02:34:45 <rotflcopter> :(
02:34:49 <Cale> Haskell is Turing complete, and so they can even take forever
02:35:08 <wavewave> how can the result be predictable in your use case?
02:35:11 <Cale> (there's no way to ensure termination statically)
02:35:20 <rotflcopter> lets say i have a fix transfer function that should not take more time than 100us
02:35:26 <Cale> okay
02:35:36 <Cale> Then that's what it'll take
02:36:17 <rotflcopter> if an evaluation takes 50us
02:36:17 <Cale> If your implementation is always going to evaluate to a result in constant time, then that's what it'll do :)
02:36:47 <rotflcopter> using values of any floatingpoint magnitude it will take about 50us no?
02:37:14 <Cale> It depends on what the function is doing with the floating point values of course
02:37:35 <rotflcopter> 3d transformations
02:37:50 <Cale> If it's iterating some process until it reaches some kind of convergence, then it may take longer for some values than others
02:38:03 <rotflcopter> no, trying to avoid iteration
02:38:33 <rotflcopter> still planning to make a cnc test using ghc
02:38:43 <rotflcopter> i can define timing uncertainity
02:38:57 <rotflcopter> and can specify the maximum step rate accordingly
02:39:30 <Cale> If you're doing something that's hard realtime, then you're probably going to just want to use Haskell as a metalanguage, and write a Haskell program to generate code which is hard realtime.
02:39:53 <rotflcopter> well i define the step rate
02:40:03 <rotflcopter> it can be even 50 iterations/sec
02:40:06 <rotflcopter> ...
02:40:10 <rotflcopter> it will be just slow
02:40:13 <rotflcopter> but it will work
02:40:19 <Cale> okay
02:40:35 <rotflcopter> but i have hard realtime preempt kernel
02:40:58 <Saizan> anyhow, GC can always get in the way, unless you know you're not allocating anything
02:41:00 <rotflcopter> that makes things go a bit faster and more accurate
02:41:07 <wavewave> rotflcopter: garbage collection may cause problem
02:41:17 <daveo> can someone recommend a good install directions for debian squeeze, after apt-get install haskell-platform cabal install cabal-install errors out with exit error 1
02:41:19 <Cale> Is the CNC machine giving your Haskell program a lot of feedback? I usually thought these sorts of tasks were pretty static
02:41:20 <rotflcopter> wavewave<< what you mean by that?
02:41:41 <rotflcopter> Cale<< no, its open-loop right now
02:41:42 <rotflcopter> ;<
02:41:52 <Saizan> daveo: log?
02:42:18 <Cale> So, you can just statically generate all the input you're going to give to it beforehand
02:42:31 <Cale> and not have to worry so much about the time it takes to compute that input
02:42:35 <rotflcopter> so step uncertainity has to be determined, and then missing steps have to be inspected by testruns
02:42:44 <daveo> saiam: log? what do you need and how do i get it?
02:42:45 <wavewave> rotflcopter: You need to be careful not to generate too much retained garbage in this case.
02:42:55 <Cale> So it shouldn't matter how long the Haskell code takes to run ;)
02:42:55 <rotflcopter> Cale<< yes, its an option too...
02:43:14 <daveo> sorry Saizan; log? what do you need and how do i get it?
02:43:17 <Saizan> daveo: i mean that we need the output printed by cabal install cabal-install before it dies
02:43:27 <Saizan> daveo: put it on hpaste.org
02:43:30 <rotflcopter> but if possible i prefer on-the-fly like dvd writing :)
02:44:18 <daveo> Saizan: how do i redirect output from stdout to file?
02:44:38 <rotflcopter> Cale<< though it would be much data ;)
02:44:44 <Saizan> daveo: btw, did you run cabal update?
02:45:03 <wavewave> daveo : use pipe or >
02:45:34 <rotflcopter> given vectorgraphic input and rasterization of 80um x y 20um ʐ
02:45:49 <Cale> Yeah, it depends on how long it takes to compute the entire input to the CNC machine and how much data that really is. Another option is to give yourself a large enough buffer that any garbage collection or other blips in your program's performance aren't going to affect the process.
02:46:40 <wavewave> rotflcopter: you may be interested in llvm package in haskell for generating llvm code.
02:46:48 <rotflcopter> plus accelleration and deceleration speed
02:46:52 <Cale> rotflcopter: I seem to recall just the other week, someone was thinking about constructing a backend for the gloss drawing library for producing G-code
02:47:03 <daveo> Saizan: yes to update, i'll try again and then > and post
02:51:56 <hpaste> daveo pasted “cabal install cabal-install error” at http://hpaste.org/53247
02:52:53 <wavewave> daveo: unix has a problem
02:53:01 <wavewave> daveo: unix package.
02:53:10 <wavewave> daveo : you installed two versions of unix
02:53:52 <wavewave> daveo: how did you install ghc? haskell-platform?
02:54:13 <daveo> wavewave: ok, yes haskell-platform w/ apt-get
02:55:13 <wavewave> whats the version of haskell-platform in apt repository?
02:55:14 <rotflcopter> >((60000*0.1)/60)/(1.25/48)
02:55:20 <rotflcopter> > ((60000*0.1)/60)/(1.25/48)
02:55:21 <lambdabot>   3840.0
02:55:55 <daveo> wavewave: how do i ask apt-get?
02:55:57 <wavewave> daveo: wait.. you install cabal-install again?
02:56:00 <rotflcopter> 60000RPM, max 0.1mm/rotation, 48 step/revolution,1.25mm/step x,y axis
02:56:30 <daveo> it directs me to saying there is a newer version available
02:56:32 <rotflcopter> max 3840 step / sec
02:56:35 <wavewave> daveo: you don't have to do 'cabal install cabal-install'.  it's with haskell platform.
02:57:19 <wavewave> daveo: if you do not have a reason to do that, just don't install the newest version of cabal-install
02:57:41 <daveo> this whole thing started with trying to get xmonad running w/ yasnagesh (sp) whick fails with same error
02:57:43 <wavewave> if you do 'cabal install cabal-install', it will seek for the newest version.
02:57:59 <wavewave> okay..
02:58:25 <wavewave> daveo: one way is using constraint when doing cabal install
02:59:17 <wavewave> cabal install --constraint='unix==2.4.0.0'  xmonad
02:59:19 * daveo trying to constrain himself
02:59:31 <wavewave> maybe this can be helpful.
02:59:59 <wavewave> before that, you first ghc-pkg unregister unix-2.5.0.0
03:00:00 <gienah> daveo: wavewave: on gentoo we do: sed -e 's@unix >= 2.5@unix >= 2.4@' yeganesh.cabal
03:00:42 <wavewave> giehah : I am not familiar with gentoo. ;-P
03:01:14 <wavewave> giehah: sounds like modifying cabal file directly..
03:01:22 <gienah> wavewave: that doesn't matter, what I mean is yeganesh builds with that change
03:01:34 <rotflcopter> Cale<< my z resolution will be 0.0104166667mm x,y axis 0.0260416667mm /step
03:01:58 <wavewave> gienah: that's probably too difficult at this stage
03:02:09 <daveo> wavewave: gives the following: ghc-pkg unregister unix-2.5.0.0
03:02:09 <daveo> ghc-pkg: unregistering unix-2.5.0.0 would break the following packages: process-1.0.1.2 xdg-basedir-0.2.1 directory-1.0.1.0 directory-1.1.0.1 tar-0.3.1.0 (use --force to override)
03:02:09 <daveo>  
03:02:34 <wavewave> what does it show if ghc-pkg unregister unix-2.4.0.0
03:02:48 <gienah> wavewave: sounds dangerous, unix is ghc core lib
03:03:10 <wavewave> gienah: just check dependency..
03:03:21 <wavewave> gienah: if you don't do --force, it's okay.
03:03:51 <daveo> ghc-pkg unregister unix-2.4.0.0
03:03:52 <daveo> ghc-pkg: unregistering unix-2.4.0.0 would break the following packages: directory-1.0.1.0 haskell98-1.0.1.1 hpc-0.5.0.4 QuickCheck-2.1.0.3 haskell-src-1.0.1.3 process-1.0.1.2 xmonad-0.9.1 Cabal-1.8.0.2 X11-xft-0.3 xmonad-contrib-0.9.1 bin-package-db-0.0.0.0 ghc-6.12.1 process-1.0.1.2 Cabal-1.10.2.0 (use --force to override)
03:03:52 <daveo>  
03:04:08 <wavewave> daveo: okay.. unix-2.4 is the default library.
03:05:20 * gienah still likes my sed, thinks yeganesh is broken for ghc earlier than 7.2.1
03:05:26 <wavewave> just rename your .cabal and .ghc in your home directory
03:06:12 <wavewave> daveo : and do 'ghc-pkg list unix'
03:07:18 <wavewave> gienah: changing cabal file will be the last step when problem cannot be solved by using command line option.
03:08:12 <wavewave> daveo: you probably install unix-2.5 and its dependency in your user repository..
03:08:44 <gienah> wavewave: ok, I never use cabal install anyway, and I often hack the .cabal file
03:08:56 <wavewave> daveo: by removing .cabal and .ghc, you start with fresh zero user repository.
03:09:26 <daveo> wavewave: so i should be root when using cabal install ?
03:09:34 <wavewave> gienah: I am enjoying hacking cabal file, too. ;-)
03:09:41 <wavewave> daveo: nono.
03:10:03 <wavewave> daveo: just there are two repository... global and user
03:10:46 <wavewave> daveo: by apt-get,, system-wide global repository is installed. but when you do cabal install using your user account,
03:11:02 <wavewave> you're installing new packages in your user repository.
03:11:33 <wavewave> that's anyway recommended for doing experiment. especially as a starter
03:11:55 <wavewave> (althorugh more recommended way will be cabal-dev.. )
03:12:33 <wavewave> daveo: just erase or rename your .cabal and .ghc and check using  ghc-pkg list unix
03:13:16 <daveo> wavewave: unix-2.4.0.0
03:13:28 <wavewave> daveo: then cabal install --constraint='unix == 2.4.0.0'  (somepackage you want)
03:13:54 <wavewave> daveo: good.. now your local repo is fresh.
03:14:05 <wavewave> daveo: ah.. you need to do cabal update first.
03:15:42 <daveo> wavewave: doing same, will let you know how it goes, downloading update now, again calss for new version of cabal-install ignoring this time
03:16:27 <wavewave> daveo: good. hope that it will work well.
03:17:27 <daveo> cabal: cannot configure yeganesh-2.3. It requires unix >=2.5
03:17:27 <daveo> For the dependency on unix >=2.5 there are these packages: unix-2.5.0.0.
03:17:28 <daveo> However none of them are available.
03:17:28 <daveo> unix-2.5.0.0 was excluded because of the top level dependency unix ==2.4.0.0
03:17:31 <daveo>  
03:17:41 <daveo> sorry for flood
03:17:55 <wavewave> daveo: okay...
03:18:27 <erus`> any html/css guys in here?
03:19:07 <wavewave> daveo: now we try gienah's solution ;-)
03:19:32 <gienah> wavewave: daveo: or there's yeganesh-2.2.1 which does not have the unix constraint
03:19:52 <wavewave> gienah: ok, thanks.
03:20:15 <wavewave> daveo: try cabal install yeganesh-2.2.1 --constraint='unix == 2.4.0.0'
03:20:38 <wavewave> the constraint is just in case.
03:22:39 <wavewave> daveo: and then install the package you want also with --constraint='unix==2.4.0.0'
03:23:54 <wavewave> daveo: anyway, this is a basic way of resolving broken dependency problem..
03:24:02 <daveo> i'm thinking this might of worked! didn't throw errors
03:24:29 <daveo> !  thanks to both of you wavewave and gienah !
03:24:39 <wavewave> daveo: using --constraint... installing a package with explicit version number..
03:24:46 <wavewave> daveo: you're welcome.
03:24:55 <gienah> daveo: no worries
03:25:05 <wavewave> daveo: from time to time, ghc-pkg check
03:25:19 <daveo> what does the check do?
03:25:24 <wavewave> that will show if you have some broken packages.
03:25:54 <daveo> does ghc-pkg have --fix-broken or something?
03:26:03 <wavewave> daveo: no
03:26:13 <wavewave> daveo: just for information of your system.
03:26:51 <wavewave> ghc-pkg list, ghc-pkg unregister, ghc-pkg check, cabal install --constraint=blahbalh.. cabal install pkg-1.2.3.4
03:27:07 <daveo> okley dokie, i'll know more after messing with it awhile, probably be back again thanks
03:27:09 <gienah> wavewave: daveo: on gentoo haskell-updater is used to rebuild the broken global packages
03:27:12 <wavewave> these are what you need to know for basic resolution.
03:27:46 <wavewave> gienah: yes.. basically this is what os package manager need to solve.
03:28:09 <wavewave> daveo: remember 'cabal is not a package manager' it's not designed for that.
03:28:30 <gienah> wavewave: of course it is easier on gentoo as gentoo is a source based linux distribution, so the packages are rebuilt from the source code
03:28:47 <wavewave> gienah: *nod*
03:29:49 <wavewave> daveo: at the last moment, you may have to explicitly modify cabal package or source files.
03:30:08 <wavewave> daveo: but that's a little more challenging at this stage, I guess.
03:30:18 <o-_-o1> Is there a function to get only odd elements of a list ?
03:30:44 <wavewave> 'odd' means 1st, 3rd, 5th ... ?
03:30:51 <o-_-o1> Yes
03:31:24 <wavewave> map head  . (splitEvery 2)
03:32:00 <wavewave> o-_-o1 : is it okay?
03:32:43 <wavewave> :t splitEvery
03:32:44 <lambdabot> Not in scope: `splitEvery'
03:32:49 <o-_-o1> hang on let me install splitEvery
03:32:55 <o-_-o1> er...list.split
03:33:29 <wavewave> or you can use Nimatek's definition way above..
03:34:22 <o-_-o1> wavewave: that is not working
03:34:47 <wavewave> hm?? it was working on my computer
03:34:48 <o-_-o1> ah...it works
03:34:55 <wavewave> yeah.. ;-)
03:34:57 <o-_-o1> I did something wrong
03:35:04 <ion> @tell zzing let newton f df = iterateWhile (\a b -> abs (b-a) > 1e-7) (\x -> x - f x / df x); iterateWhile pred f = fix (\go x -> let x' = f x in if pred x x' then go x' else x') in newton (subtract 7 . (^2)) (*2) 2
03:35:04 <lambdabot> Consider it noted.
03:35:05 <o-_-o1> now I want the odd elements :p
03:35:34 <o-_-o1> er...even elements
03:35:44 <o-_-o1> got it
03:35:47 <o-_-o1> replaced head with last
03:36:01 <wavewave> yeah.
03:36:51 <wavewave> o-_-o1 : isn't it fun to combine functions and making a new func? ;-)
03:37:06 <o-_-o1> Yeah :-)
03:44:28 <danr> > map snd . fst . partition (even . fst) . zip [0..] $ "abcdefghijklm"
03:44:32 <lambdabot>   mueval-core: Time limit exceeded
03:45:13 <danr> > map snd . fst . partition (even . fst) . zip [0..] $ "abcdefghijklm"
03:45:16 <lambdabot>   "acegikm"
03:45:20 <danr> weird.
03:46:57 <o-_-o1> how to convert Float to Double ?
03:48:47 <danr> > let conv = (fromRational . toRational) :: Float -> Double
03:48:48 <lambdabot>   not an expression: `let conv = (fromRational . toRational) :: Float -> Doub...
03:50:12 <romildo> I am reading the section "Typed Pointers" of chapter 17 ("Interfacing with C: The FFI") of the Real World Haskell book. It can be read here: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html. There is a type definition: newtype PCRE = PCRE (Ptr PCRE), followed by a statement that a value this type has no runtime representation. That is not clear to me.
03:50:53 <romildo> s/a value this type/a value of this type/
03:52:11 <romildo> A newtype has the same representation as the type on the right hand side of the defintion, minus the data constructor.
03:52:47 <romildo> So the representation exists and it is: Ptr PCRE
03:54:35 <ibid> they probably mean that the newtype is indistinguishable from Ptr PRCE at runtime
03:54:41 <romildo> What I see is that this definition is recursive, and there is not a base case. So it may be difficult (or even impossible) to construct a value of the type.
03:54:55 <ibid> that's the only sense i can make of "no runtime representation" in the context
03:55:34 <ibid> romildo: you probably can create a null pointer?
03:57:10 <romildo> As I am just starting learning the FFI, I do not know much about the foreign types yet.
03:58:34 <rostayob> romildo: Ptrs are usually returned by C functions you call
03:58:54 <rostayob> but you can create Ptrs as well, and there is nullPtr as ibid was saying
03:59:06 <rostayob> also
03:59:07 <romildo> The main idea discussed in that book section is the definition of an abstract data type to represent a value that is built in C, and also handled in C. So the Haskell program should not build its own value, or handle it directly
03:59:13 <rostayob> @hoogle castPtr
03:59:13 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
03:59:14 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
03:59:14 <lambdabot> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
03:59:25 <rostayob> romildo: no, it doesn't
03:59:30 <rostayob> the newtype is just added type safety
03:59:49 <ibid> romildo: note that the newtype in question is recursive
03:59:53 <ibid> argh
03:59:55 <ibid> rostayob: ^^
04:00:11 <rostayob> it doesn't matter
04:00:21 <rostayob> again
04:00:21 <Cale> romildo: It might be worth noting that the type parameter to Ptr doesn't affect the representation of the pointer in any way
04:00:25 <rostayob> @hoogle castPtr
04:00:26 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
04:00:26 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
04:00:26 <lambdabot> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
04:00:40 <rostayob> the inner type of the Ptr is just type safety
04:00:50 <rostayob> but it doesn't affect the pointer at all, it's just a pointer
04:01:01 <Cale> The pointer is still just a number indicating an address in memory, no matter how we want to think of the data at that address as corresponding to a value of a given type
04:01:40 <Cale> So the type parameter to Ptr in some way "doesn't matter" -- at least not enough for this recursive use to be any real problem.
04:01:45 <rostayob> Ptr a corresponts do a* in C, but there is no automatic casting for haskell Ptrs
04:02:22 <rostayob> well not really corresponds, but you get the idea
04:02:46 <rostayob> also, you can't do pointer arithmetic with haskell pointers, afaik
04:02:52 <ibid> (clever trick, by the way, that recursive newtype.  i should actually read RWH some time:)
04:03:21 <Cale> It's a common idiom. I think RWH is explaining it a little bit awkwardly here in comparing it to an empty type
04:03:41 <rostayob> the recursive ptr thing is useful if you never marshal the data held by the pointer
04:03:42 <romildo> The alternative, much clerear definition por PCRE, algo given in the book, is with a nullary data type: data PCRE, which requires the EmptyDataDecls language extension.
04:03:50 <Cale> Because the resulting  newtype PCRE = PCRE (Ptr PCRE)  is not an empty type at all.
04:03:54 <romildo> s/algo/also/
04:04:13 <rostayob> romildo: yeah that's what I usually do
04:04:22 <ibid> Cale: nevertheless, this was the first time i ran into it :)
04:04:32 <Cale> ibid: yeah :)
04:05:08 <rostayob> ibid: recursive types are cool, newtype Inf a = Roll {unroll :: Inf a -> a}
04:05:26 <Cale> also, since the FFI understands newtypes in foreign import declarations, you can use this PCRE type in the types of the things you import, in any place where the corresponding C type involves a pointer
04:05:31 <rostayob> (that one is my favourite)
04:05:37 <Cale> You can't do that with an empty type
04:05:57 <ibid> rostayob: i know recursive types.  i just hadn't seen that particular idiom before
04:05:58 <rostayob> Cale: yeah but imho is clearer to just use Ptr PCRE, where PCRE is an empty data type
04:06:08 <romildo> I understood the idea, but I do not agree with the statement that a value of the type has no runtime representation. I think it is wrong and should be fixed in the book.
04:06:16 <ibid> (probably because i haven't used FFI much myself)
04:06:17 <Cale> rostayob: Probably not for the users of your library ;)
04:06:44 <rostayob> Cale: I usually write mid level bindings, those things wouldn't be exposed anyway
04:06:54 <Cale> rostayob: The idea being that you're probably going to wrap up the C library in a nicely abstract Haskell interface where the people using your library shouldn't have to see Ptr explicitly.
04:06:59 <rostayob> Cale: exactly
04:07:12 <rostayob> but I usually abstract over the C functions a bit
04:07:29 <Cale> The newtype can hide the representation as a pointer, even if all you do is foreign import, and save you a bit of wrapping work.
04:07:34 <rostayob> but yes in the end you'll have the Ptr hidden in some data type
04:07:42 <Cale> Sure, but nobody has to know :)
04:07:50 <rostayob> yeah
04:07:53 <Cale> The newtype is a datatype :)
04:08:16 <rostayob> yeah I get the point of doing that, I just find myself writing bare-bones binding to the C functions and then I abstract over them
04:09:21 <Cale> oh, interesting, it seems they still use Ptr PCRE even after discussing that
04:09:40 <Cale> (they don't have to)
04:10:32 <rostayob> btw, would anyone be interested in mid level bindings to KyotoCabinet? I can't be bothered to write the documentation
04:10:51 <rostayob> maybe I'll just put them undocumented on hackage
04:15:03 <Cale> http://www.youtube.com/watch?v=cYw2ewoO6c4 -- this is cute
04:19:27 <rs46> If I have a list [(IO a),(IO b),(IO c)] how do I produce a list [a,b,c] from it ?
04:19:41 <rostayob> :t sequence
04:19:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:20:16 <rs46> rostayob: great !
04:20:45 <rostayob> :)
04:22:10 <Axman6> rs46: you can only produce IO [a,b,c] from that, not just [a,b,c] (and a, b and c all have to be the same type)
04:22:31 <ketil> Did anybody here look at my draft paper on STM (posted to haskell-cafe yesterday)?
04:22:58 <ketil> (I notice from the logs that it got a bunch of downloads, but I didn't actually hear from anybody.)
04:23:34 <Cale> ketil: link?
04:24:17 <Cale> ah http://malde.org/~ketil/stmcluster.pdf
04:26:41 <jtannenbaum> see in #python I don't see scientific papers getting passed around
04:26:59 <Axman6> ketil: the abstract isn't very formal
04:27:06 <jtannenbaum> this is (a reason) why haskell will be my next language
04:30:46 <ketil> Axman6, thanks.  It wasn't really done yet.  New version now.
04:31:38 <ketil> Anyway, I'd be happy just to hear that it's "okay" - no grave errors.  I need to submit it today.
04:32:45 <Axman6> ketil: looks interesting. i'll have a read of it once i've rebooted
04:32:45 <ketil> jtannenbaum, I've  noticed SPJ does it occasionally.  I feel a bit uncomfortable doing it, I have this feeling papers should sorta be "secret" until publication.  But it's a silly sentiment.
04:33:44 <ketil> My main worry is that the monads stuff is too terse for the audience (bioinformaticians).  But I can't really expand it to a monad tutorial, and I point to "Composable Memory Transaction" by Harris et al - that's really great, I think.
04:34:05 <ketil> Anyway, I view it as a bit of Haskell marketing.
04:38:58 <hpaste> sefb1704 pasted “HaskellAdventure” at http://hpaste.org/53248
04:57:45 * hackagebot posix-timer 0.2.0.1 - Bindings to POSIX clock and timer functions.  http://hackage.haskell.org/package/posix-timer-0.2.0.1 (MikhailVorozhtsov)
04:57:47 * hackagebot data-flags 0.0.3.1 - A package for working with bit masks and flags in general.  http://hackage.haskell.org/package/data-flags-0.0.3.1 (MikhailVorozhtsov)
04:57:56 <o-_-o1> How to convert floating point to Integer ?
04:58:32 <ziman> :t (round,floor)
04:58:34 <lambdabot> forall a b a1 b1. (RealFrac a, Integral b, RealFrac a1, Integral b1) => (a -> b, a1 -> b1)
04:59:02 <o-_-o1> ah...thanks
04:59:19 <ziman> I think there's also something like
04:59:21 <ziman> :t ceil
04:59:22 <lambdabot> Not in scope: `ceil'
04:59:40 <rostayob> :t ceiling
04:59:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
05:00:15 <ClaudiusMaximus> :t [round, truncate, floor, ceiling]
05:00:16 <lambdabot> forall a b. (RealFrac a, Integral b) => [a -> b]
05:00:55 <sipa1024> :t (round, truncate, floor, ceiling) :: (a -> a, a -> a, a -> a, a -> a)
05:00:55 <lambdabot>     Could not deduce (RealFrac a, Integral a) from the context ()
05:00:55 <lambdabot>       arising from a use of `round' at <interactive>:1:1-5
05:00:55 <lambdabot>     Possible fix:
05:01:25 <ziman> it would be great if hoogle were able to answer queries like "Double -> Integer" with such polymorphic results
05:01:43 <rostayob> ziman: it is able
05:01:55 <ClaudiusMaximus> > [round, truncate, floor, ceiling :: Double -> Int] <*> [-1.75, -1.5 .. 1.75]
05:01:56 <lambdabot>   [-2,-2,-1,-1,-1,0,0,0,0,0,1,1,1,2,2,-1,-1,-1,-1,0,0,0,0,0,0,0,1,1,1,1,-2,-2...
05:02:46 * hackagebot snaplet-hdbc 0.6.1 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.6.1 (JurrienStutterheim)
05:02:52 <rostayob> ziman: it's just that in this case it kind of sucks for some reason http://www.haskell.org/hoogle/?hoogle=Float+-%3E+Integer
05:04:07 <ziman> yes, I would find "(RealFrac a, Integral b) => a -> b" a better match than "Integral a => a -> Integer" (hoogle's third)
05:04:15 <ziman> hm, maybe it's just the ordering of the results.
05:05:53 <ClaudiusMaximus> woop, data-memocombinators \m/  now if only there were an easy way to persist the memo table across multiple program runs...
05:16:44 <ClaudiusMaximus> would something like this make sense?  mkMemoM :: Monad m => (k -> m (Maybe v)) {- ^ lookup -} -> (k -> v -> m ()) {- ^ insert -} -> (k -> m v) {- ^ generate -} -> m (k -> m v) {- ^ memoized -
05:16:48 <ClaudiusMaximus> }
05:18:44 <ClaudiusMaximus> then with (m ~ IO, Read k, Read v, Show k, Show v)  appropriate lookup/insert functions could use a database...
05:19:12 <Cale> ClaudiusMaximus: I doubt you could write it usefully in an *arbitrary* monad...
05:19:34 <Cale> ClaudiusMaximus: (like, what if m = [])
05:19:53 <Cale> Well, hmm
05:20:09 <ClaudiusMaximus> maybe MonadState would be more appropriate?
05:20:12 <Cale> Maybe it wouldn't exactly be memoisation at that point.
05:20:17 <Cale> But it would still do something?
05:20:24 <Cale> But yeah, that's a decent "shape" for a generalised memoiser.
05:20:39 <Cale> Though you should also be aware of the pure approach to memoising functions :)
05:20:52 <Cale> http://hackage.haskell.org/package/data-memocombinators
05:21:05 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.2/doc/html/src/Data-MemoCombinators.html
05:21:23 <Cale> (the source code is slightly better documentation than the haddock)
05:21:40 <ClaudiusMaximus> yeah, i'm using it already, just a pain to recompute things when i tweak something unrelated in my program source and have to re-compute things after recompiling/runnin
05:21:54 <Cale> ah, I see
05:23:07 <Cale> yeah, the memocombinators approach doesn't really lend itself very well to writing the memo table to disk and restoring it :)
05:23:22 <Cale> though...
05:23:24 <Cale> hmm
05:25:34 <Cale> Yeah, there *may* actually be a sneaky way to extend the memocombinators approach to produce IO actions for querying/adding to the memo table, but you couldn't quite get away with such pretty and pure implementations of the memo tables themselves anymore.
05:25:35 <ClaudiusMaximus> i'll probably end up hacking some IO-heavy abomination into my code eventually, as for interactive use i need a progress bar so my pure function results in a list of progress updates, and the non-interactive version just takes the last in the list and converts Success to Just
05:26:18 <Cale> (which would involve some evil internally, but would mostly look like the memocombinators interface from the outside)
05:26:29 <ClaudiusMaximus> and i'd want to persistently memoize the interactive use results (without the irrelevant progress updates)
05:30:35 <whald> it isn't possible to derive the existential instance of a class, is it?
05:31:22 <whald> i mean using "deriving" or something, instead of writing it out by hand
05:32:48 * hackagebot OpenGLRaw 1.1.0.2 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-1.1.0.2 (JasonDagit)
05:32:50 * hackagebot OpenGL 2.4.0.2 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.4.0.2 (JasonDagit)
05:37:52 * hackagebot GLURaw 1.1.0.1 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/GLURaw-1.1.0.1 (JasonDagit)
05:37:54 * hackagebot GLUT 2.2.2.1 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.2.2.1 (JasonDagit)
05:59:15 <jtannenbaum> how would I make a function that takes the parameter inside to another function, in one expression (say, ((mod 3456 x) == 0)(x))
06:01:19 <silver> (\x -> (mod 3456 x) == 0) ?
06:02:11 <jtannenbaum> ah, haven't learned about "\x ->" yet I guess
06:02:22 <silver> this is called lambda expression
06:03:08 <jtannenbaum> o cool
06:04:08 <Botje> straight out of half-life!
06:07:49 <Axman6> jtannenbaum: you're probably used to lambda in python?
06:07:54 <jtannenbaum> yes
06:08:20 <tom_i> leave
06:08:22 <Axman6> well, haskell doesn't have the horrible syntax python does.
06:08:38 <tom_i> ./oops
06:08:49 <mux> that's a bit unnecessarily harsh on python, I think
06:09:45 <jtannenbaum> Botje: http://s3.amazonaws.com/lyah/lambda.png just got up to it
06:10:09 <jtannenbaum> use of lambda/map/filter/reduce are frowned upon in python pretty much
06:10:19 <Botje> seriously?
06:10:23 <Axman6> o.O
06:10:42 <jtannenbaum> er, maybe not recude
06:10:44 <jtannenbaum> reduce
06:10:52 <Axman6> pythonisters need to suck less >_<
06:11:10 <osfameron> they like their odd verbose and backwards list comprehensions
06:11:12 <jtannenbaum> but #python prefers listcomps are preferred over map/filter
06:11:22 <jtannenbaum> fdsfs
06:11:23 <mux> which makes sense.
06:11:31 <jtannenbaum> it's early/late
06:11:41 <mux> what makes less sense to me is that they actually removed reduce() from python 3
06:15:18 <sp3ctum> what, they did?
06:15:58 <cwl> runhaskell :     Ambiguous module name `Data.Aeson':
06:16:38 <cwl> how to tell runhaskell to use pkg aeson-native
06:16:47 <hpc> cwl: package imports, perhaps
06:16:48 <rostayob> sp3ctum: apparently: "Removed reduce(). Use functools.reduce() if you really need it; however, 99 percent of the time an explicit for loop is more readable."
06:17:02 <hpc> i forget the syntax; it's a ghc extension iirc
06:17:43 <frerich2> 'reduce' in Python would be a fold?
06:17:51 <rostayob> frerich2: yes, a foldr
06:18:01 <rostayob> ah no
06:18:01 <mauke> foldl
06:18:16 <sp3ctum> rostayob, wow, that's sad
06:18:17 <rostayob> yeah
06:19:02 <rostayob> sp3ctum: well idiomatic python avoids higher order programming
06:19:11 <rostayob> they even wanted to remove map i think
06:19:24 <hpc> rostayob: they wanted to remove map, reduce, and lambda
06:19:27 <sp3ctum> i never knew, that's pretty sad too
06:19:31 <rostayob> hpc: yes, that
06:19:31 <hpc> there was much bitching
06:19:42 <rostayob> guido is notoriously "against functional programming"
06:19:45 <hpc> though the way lambda is gimped, what's the point anyway
06:19:46 <rostayob> if it even mean anythin
06:19:48 <rostayob> g
06:19:57 <rostayob> *means
06:19:58 <mux> yet in a few cases there's nothing better than being able to pass functions concisely
06:20:07 <mux> even basic use cases such as sorting a damn list :)
06:20:16 * mux kicks Guido in the gonads.
06:20:33 <rostayob> http://www.artima.com/weblogs/viewpost.jsp?thread=98196
06:20:36 <mauke> mux: you don't need lambda to get concise sort
06:20:46 <mauke> just give sort special syntax
06:20:51 <hpc> after using CLisp for this AI class, i am seriously considering evaluating all languages i encounter based on their ability to write (.)
06:21:12 <mux> mauke: more ad-hoc syntaxic hacks that can't be reused in other code?
06:21:19 <mauke> mux: right
06:21:46 <hpc> for this GA assignment, it took me half an hour to stop reflexively trying to write 'map (map mutate) parents' in lispy syntax
06:22:15 <mauke> hpc: how about the ability to write g such that f(...) == f(g(...)) for all ...? :-)
06:22:23 <rostayob> I for one agree with python's philosophy of having just one way of doing things
06:22:30 <rostayob> (for a language like python)
06:22:38 <mauke> rostayob: but python doesn't work like that
06:22:46 <mauke> there are tons of ways
06:23:05 <rostayob> mauke: well but they try to have the least ways possible
06:23:11 <mauke> rostayob: I doubt that
06:23:14 <rostayob> for example the argument against map and filter are list comprehensions
06:23:18 <rostayob> mauke: I can assure you
06:23:20 <mauke> rostayob: how many ways are there to write a string literals?
06:23:32 <rostayob> haskell has taken the opposite direction
06:23:42 <sp3ctum> is '' for strings or characters in python?
06:23:46 <rostayob> and it's not a bad thing but python is a small and simple language
06:23:57 <mauke> and/or big and complicated
06:23:57 <rostayob> mauke: that doesn't really make a big difference in the code flow
06:23:58 <sp3ctum> iirc in haskell 'a' is for characters. is this right?
06:24:04 <rostayob> sp3ctum: yes
06:24:06 <mauke> rostayob: so?
06:24:10 <sp3ctum> ok, thanks
06:24:21 <rostayob> mauke: so it doesn't really matter if you can use ' and "
06:24:33 <rostayob> an example in haskell is having both let and where
06:24:49 <mauke> rostayob: the answer is 28, btw
06:24:52 <rostayob> you don't need both, it gives you the choice
06:25:09 <rostayob> python shouldn't give you the choice
06:25:32 <rostayob> mauke:  see http://www.python.org/dev/peps/pep-0020/
06:25:46 <rostayob> "There should be one-- and preferably only one --obvious way to do it."
06:25:52 <mauke> rostayob: yes, I'm aware of the hypocrisy
06:25:59 <rostayob> haskell, or perl, or whatever, are openly not like that
06:26:05 <rostayob> mauke: hypocrisy?
06:26:13 <mauke> rostayob: 28 ways to write string literals
06:26:19 <mauke> according to the language grammar
06:26:34 <rostayob> mauke: you're missing the point. writing a string literal in different way doesn't change the structure of a program
06:26:53 <mauke> rostayob: python violates "explicit is better than implicit" in a very fundamental way: scoping/binding
06:27:08 <rostayob> I wasn't talking about that now
06:27:28 <mauke> that's part of why I think it's hypocritical
06:27:53 <rostayob> I was just pointing out the haskell and python way when it comes to language design are very very different
06:28:02 <rostayob> but I think that python has it's place
06:28:43 <rostayob> mauke: mah I might agree with you on the scoping but I was talking about the "there is one way to do it" approach
06:29:27 <rostayob> I was trying to justify guido's stance on those hof :P
06:29:33 <mauke> "one way to do it" violates modularity
06:29:40 <rostayob> does it?
06:29:45 <rostayob> what do you mean?
06:30:12 <mauke> or maybe it violates non-primitives
06:30:24 <mauke> I'm thinking of how concatMap is made of concat and map
06:30:47 <mauke> whenever you write concatMap f xs, you could also write concat (map f xs)
06:31:07 <romildo> Which module defines toForeignPtr ?
06:31:08 <mauke> so: should we get rid of concat and map, or should we get rid of concatMap?
06:31:09 <rostayob> well you lose the beauty of combinators in python yes :P
06:31:19 <ClaudiusMaximus> @hoogle toForeignPtr
06:31:20 <lambdabot> Data.ByteString.Internal toForeignPtr :: ByteString -> (ForeignPtr Word8, Int, Int)
06:31:29 <mauke> this affects all functions, not just "the beauty of combinators"
06:31:57 <rostayob> mauke: combining functions has nothing to do with "there is only one way to do it"
06:32:02 <rostayob> we're talking about language features
06:32:11 <mauke> I think it does
06:32:32 <mauke> e.g. in Perl there is filter and concatMap built into the language (but no list comprehensions)
06:33:03 <mauke> but you can easily write a filter with concatMap
06:33:10 <rostayob> mauke: python just try to reduce the "how should I write this" moments
06:33:14 <mauke> does this violate "one way to do it"?
06:33:18 <rostayob> and I think it partly succedes
06:33:22 <romildo> @hoogle empty
06:33:23 <lambdabot> Control.Applicative empty :: Alternative f => f a
06:33:23 <lambdabot> Data.ByteString empty :: ByteString
06:33:23 <lambdabot> Data.IntMap empty :: IntMap a
06:33:33 <rostayob> mauke: yes, perl is the opposite
06:33:44 <mauke> rostayob: so your answer is "yes"?
06:34:06 <rostayob> yes
06:34:52 <rostayob> well wait
06:34:59 <rostayob> what do you mean with "built into the language"?
06:35:08 <rostayob> having filter and concatMap is not bad in itself
06:35:22 <rostayob> but python eschews hofs in genral
06:35:24 <rostayob> *general
06:35:35 <mux> the way perl is designed means that map == concatMap; it flattens list by default, and to prevent it you'd need references
06:35:43 <mauke> perl doesn't flatten lists
06:35:45 <mux> so in a way it's builtin
06:35:47 <rostayob> which is what gets people to say "pythonisters need to suck less >_<"
06:35:57 <mux> mauke: uh?
06:36:00 <rostayob> I think that there is a point in doing that
06:36:04 <rostayob> anyway I have to go
06:36:19 <mauke> mux: flatten is an action from A -> B. there is no A
06:36:43 <mauke> re: <rostayob> mauke: python just try to reduce the "how should I write this" moments
06:36:56 <mauke> how many ways are there in python to turn a string into its hex dump?
06:37:02 <mux> mauke: flattening a list means ((1,2),(3,4)) is the same as (1,2,3,4) to me
06:37:03 <mauke> that is, replace each char by two hex digits
06:37:06 <absentia> 2.7
06:37:11 <mauke> mux: that is ambiguous
06:37:38 <mauke> mux: is that perl syntax?
06:37:40 <rostayob> mauke: I don't care, again that is not the point, you're talking about the stdlib now, I'm talking about the language
06:38:06 <hpaste> rostayob pasted “there is more than one way of doing it” at http://hpaste.org/53252
06:38:14 <rostayob> ^^ that is how haskell goes
06:38:17 <mux> mauke: I think it conveyed the point accross
06:38:31 <mauke> mux: you're missing the point
06:38:42 <rostayob> and I'm not sure I agree, but haskell is too cool anyway
06:38:53 <mauke> mux: to "flatten" a list, you need to have nested lists in the first place
06:38:55 <rostayob> gotta go, bye
06:38:58 <mux> mauke: intentionally.
06:39:13 <mauke> mux: "nested list" doesn't make sense in perl
06:39:24 <mauke> that's why I'm saying there's no flattening going on
06:39:48 <mux> the two are perfectly equivalent to me (saying there are no nested lists, or that they are flattened by default)
06:39:54 <mauke> part of the problem/solution is that perl doesn't have a syntax for literal lists
06:40:16 <mauke> mux: what were they before their flattening?
06:40:52 <mux> I don't care, I think everyone understood what I meant, which was my only goal; I wasn't aiming at 100% correct terms or whatever :-)
06:41:08 <mauke> mux: I don't care; I only want *you* to understand
06:41:11 <osfameron> mauke: perl *does* have a syntax for literal lists.
06:41:12 <EvanR-work> 'my remarks were not meant to be construed as correct'
06:41:15 <mauke> osfameron: namely?
06:41:22 <osfameron> mauke: (1,2,3)
06:41:22 <mux> oh fuck that.
06:41:26 <EvanR-work> lol
06:41:47 <mauke> osfameron: no, that's the comma operator applied to (the comma operator applied to 1 and 2) and 3
06:41:51 <mauke> and some parens
06:42:01 <mauke> (,) is left associative in perl
06:42:13 <Saizan> snoc lists!
06:42:18 <osfameron> mauke: the result is a list though.
06:42:25 <cwl> how to list packages I've installed
06:42:25 <mauke> osfameron: yes, because , is list concatenation
06:42:39 <cwl> only those installed
06:42:40 <Botje> cwl: ghc-pkg list ?
06:42:50 <mauke> osfameron: and because concatenation is associative, (1 , 2) , 3 is the same as 1 , (2 , 3)
06:43:21 <cwl> Botje: I want to list all packages I've installed
06:43:38 <Botje> ah
06:43:43 <cwl> ah
06:43:45 <osfameron> mauke: are you thinking of something more like the arrayref literal constructor [1,2,3] ?  That certainly allows for nested lists.
06:43:47 <cwl> you are right
06:43:48 <Botje> maybe you can ask cabal, otherwise I wouldn't know :)
06:43:53 <mauke> osfameron: what
06:44:06 <mauke> osfameron: I'm talking about , isn't list literal syntax, it's ++
06:44:10 <mux> that's useless and unnecessary bikeshedding again
06:44:14 <mauke> and the parens are just for precedence
06:44:48 <mux> there is no need to bitch about how perl doesn't distinguish (1,(2,3)) from (1,2,3) when it makes perfect sense visually what is meant by nested list, even if internally perl wouldn't differentiate
06:45:04 <mauke> mux: but that is not how you notate lists in perl!
06:45:10 <mux> oh lord.
06:45:34 <mauke> this is like complaining that (1 2 3) doesn't what you want when it's obviously a list of three numbers
06:45:39 <osfameron> mauke: in that case I'm not understanding what you're getting at
06:46:06 <mux> mauke: it makes perfect sense to write it like this for people to understand what you mean, if they have had no prior exposure to perl's syntax
06:46:25 <mauke> mux: or semantics
06:46:34 <mauke> which is entirely unhelpful when I'm talking about how perl works
06:46:43 <ousado> what happened to #haskell? everytime I visit this channel these days perl is being discussed
06:46:44 <mux> except you're the only one talking about that
06:47:01 <mauke> yes
06:47:09 <mux> others were merely trying to explain why as you said, "concatMap is built into the language"
06:47:14 <gtirloni> ousado: it's a new extension :) jk
06:47:25 <mux> all the rest is at best off-topic
06:48:25 <mauke> mux: it's built into the language because perl started life without higher-order functions (but map was useful!), and it's concatMap because someone decided it was cool to make it work that way
06:48:28 <Botje> Inline.Perl
06:48:42 <mux> mauke: amen, let's go with that if you want. I don't mind.
06:49:24 <mauke> hmm, it might have been an implementation accident, actually
06:49:31 <mauke> like the /eieio thing
06:52:43 <mauke> I think the "perl flattens lists" thing is a bad meme, a bit like "in Haskell, IO is a tag on values returned from functions with side effects"
06:53:21 <mauke> in that it sort of works to a first approximation, but doesn't help you understanding other things
06:53:34 <mauke> and leads to questions such as "how do I extract the String from IO String?"
06:53:56 <shachaf> How do I extract the , from a nested list?
06:54:01 <mux> I think you could drop it. I also think that funnily, anyone not knowing perl would have understood perfectly what I meant, while your technically correct explanation wouldn't have helped anyone.
06:54:26 <EvanR-work> avoid discussions about perls implementation at all costs
06:54:29 <EvanR-work> no one is right
06:54:32 <mauke> mux: same for s/perl/haskell/ and s/lists/IO/
06:55:15 <Saizan> haskell flattens IO is right though: join
06:55:42 <EvanR-work> haskell flattens side effects
06:55:49 <mux> everytime you talk about perl in #haskell, god kills a kitten
06:56:06 <mauke> Saizan: that's you doing it, though, not the language :-)
06:56:07 <EvanR-work> good
06:56:38 <mauke> (incidentally, IO (IO String) makes no sense in the "IO is a tag" model)
06:57:04 <shachaf> mauke: That's why you have to join in straight away, before something gets confusing.
06:57:14 <shachaf> s/ in/ it/
06:58:30 <shachaf> Anyway, the "IO is a tag" model is obviously nonsense. Any Web 2.0 person can tell you that the whole point of tags is that each value has an unordered set of them associated with it.
06:59:36 <mauke> arranged in a rectangular cloud?
06:59:40 <sipa> but sometimes hierarchical tags are supported
06:59:45 <Saizan> isn't that what disciple is doing?
06:59:46 <sipa> like IO (IO String)
07:04:43 <gtirloni> does anyone know who i should talk to w.r.t haskell.org in other languages (as in country related, not perl)?
07:06:41 <geoffgeoff> haskell is OK
07:09:53 <geoffgeoff> yeah whaaaa
07:12:59 <geoffgeoff> hassskkeeelll yeaa
07:17:02 <scooty-puff_> i had a question related to a paper i'm reading, mostly regarding the notation - i can possibly give a link to the paper, or i can describe the expression
07:17:21 <scooty-puff_> (since the expression is easy enough to write):
07:17:28 <shachaf> scooty-puff_: You should probably do one or both of those. :-)
07:18:04 <scooty-puff_> the free vars tv of constraint C: tv(C) = { alpha | there exists alpha such that C /= (superscipt e) C }
07:18:21 <scooty-puff_> there exists == backwards E, such that == .
07:18:59 <scooty-puff_> (the paper is "Type Inference with Constrained Types", tv(C) is on page 3, bottom right)
07:19:05 <mauke> ∃α. C /=e C?
07:19:31 <mauke> ∃α. C ≠ᵉ C
07:19:32 <scooty-puff_> yes, but with the e in a superscript position
07:19:34 <scooty-puff_> yep
07:19:40 <mauke> that makes no sense
07:19:59 <scooty-puff_> ok, good, so not just me
07:20:08 <scooty-puff_> what does /=e mean?
07:20:35 <scooty-puff_> i read it as not equivalent, where free type vars are not considered equal unless they are the same
07:20:43 <scooty-puff_> *free type vars -> type vars
07:20:49 <mauke> link?
07:21:16 <armlesshobo> the haskell-platform complains that it requires 7.0.3 even though I have 7.2.1
07:21:18 <scooty-puff_>  http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.6992&rep=rep1&type=pdf
07:21:29 <armlesshobo> when i do a ./configure
07:22:48 <gtirloni> armlesshobo: what are you trying to do? install HP?
07:22:50 <scooty-puff_> (theres the question related to tv(C) on page 3, right column, near the bottom; and a question related to gen(...), very last page, related to Ea.C as well)
07:23:18 <armlesshobo> gtirloni: yes, build it from sources
07:25:08 <gtirloni> i guess the last one really needs 7.0.4 (or 7.0.3 on windows)..
07:27:25 <mightybyte> Anyone know if it's possible for me to fix this hackage build error?  http://hackage.haskell.org/packages/archive/snap/0.6.0.1/logs/failure/ghc-7.2
07:28:36 <hpc> mightybyte: install C++?
07:28:59 <mightybyte> hpc: But I don't run hackage. :)
07:29:46 <hpc> do you maintain snap?
07:31:09 <mightybyte> Yes
07:31:38 <hpc> you could try and eliminate the dependency on double-conversion-0.2.0.1
07:31:59 <hpc> i don't have any clue how to go about doing that though
07:32:08 <mightybyte> I doubt that's a viable option.
07:33:41 <hpc> that's the extent of my ability to debug hackage stuff :/
07:33:49 <mightybyte> The way I've done it locally is "cabal install blaze-textual --reinstall -fnative
07:38:37 <mightybyte> Is there a way to specify in a cabal file that certain build flags should be used when building dependencies?
07:40:17 <joe9> has anyone tried a per-directory or per-project or per-file ghci history? i feel that it would be good to have the ghci commands I used on a per-haskell-file basis, just so that I could store and remember the workflow later.
07:41:15 <mm_freak> joe9: no, but when working with files, you could throw in those definitions into the file
07:41:25 <mm_freak> just don't export them
07:41:58 <joe9> mm_freak, keep getting those warnings about unused functions
07:42:02 <joe9> when I do that.
07:42:12 <joe9> I have to keep them commented and all that.
07:42:15 <ClaudiusMaximus> isn't there per-directory .ghci? is it possible to put commands in there to use a different history file?
07:42:40 <joe9> oh, cool. did not know that there was a per-directory .ghci. will check it out.
07:43:42 <joe9> i probably need a wrapper oslt to ghci to use the history file that I am about to use the haskell file for.
07:44:01 <joe9> that probably means that I cannot use :load from the ghci prompt.
07:48:03 <ClaudiusMaximus> joe9: hm, seems not possible to set history file from inside ghci (or at least, it's not documented in :help)
07:49:49 <joe9> anyone with a good .ghci file, can you please paste it? something that stores a lot of history and has been customised to have different history dirs oslt?
07:51:27 <ClaudiusMaximus> joe9: http://haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html has a link to a wiki page
07:52:02 <joe9> ClaudiusMaximus: cool, thanks.
07:53:17 <joe9> ClaudiusMaximus: thanks, that page is very helpful.
08:10:21 <joe9> http://community.haskell.org/~ndm/darcs/hlint/hlint.htm i am trying to integrate the hlint into ghci. I am wondering about what I should be doing.
08:10:35 <joe9> what do I do with the script hlint.ghci
08:11:26 <joe9> http://codepad.org/eyDMTeus i have the hlint.ghci in my .cabal directory.
08:11:45 <joe9> "To use, add the contents to your GHCi startup file." -- is what the docs say.
08:11:54 <joe9> does that mean I need a :source hlint.ghci?
08:12:20 <mauke> no
08:12:36 <mauke> which part of "add the contents to your GHCi startup file" is unclear?
08:13:31 <joe9> mauke, does that mean that I just copy over the stuff in hlint.ghci into my .ghci?
08:13:36 <mm_freak> with the current RTS is there is reason to prefer libev over the normal concurrency?
08:13:36 <mauke> yes
08:13:56 <joe9> oh, ok. I was thinking that there was more smarts behind it.
08:14:18 <joe9> something that I link in and with every update of hlint, it automatically reads the new hlint.ghci
08:17:13 <byorgey> joe9: you could do it that way, with :script path/to/hlint.ghci
08:17:37 <joe9> byorgey: thanks. i did not know about the script command.
08:17:40 <joe9> that is better.
08:17:52 <byorgey> I didn't either.  I just started up ghci, typed :help, and looked through the commands. =P
08:21:59 <joe9> http://codepad.org/8Xy4QNKI
08:24:09 <joe9> byorgey: the script does not seem to work with hlint.ghci
08:24:25 <byorgey> joe9: hmm. does it work if you paste the contents of hlint.ghci into your .ghci?
08:26:00 <joe9> byorgey: no, that did not work, either. could be something else, then.
08:27:52 <joe9> anyone using hlint integration with ghci?
08:28:05 <joe9> i cannot seem to get it to work.
08:28:25 <joe9> i tried the :script and also copying the contents of hlint.ghci into .ghci
08:29:13 <mauke> sorry, my ghci is currently broken
08:30:19 <joe9> is what i get: http://codepad.org/CAgjKiGq
08:31:38 <Kaidelong> so from what I understand of Data.MemoCombinators
08:32:02 <Kaidelong> by default the kind of memoization that will be done is going to be looking up results on an int-tree, bit by bit
08:32:30 <Kaidelong> but the memocombinators work with anything else that has the general form in the type synonym
08:33:45 <ClaudiusMaximus> Kaidelong: i haven't checked the source, but i used   foo' = Memo.list Memo.char (foo :: String -> Bar)   without having to think too hard and it worked
08:36:13 <byorgey> Kaidelong: it does not look up results in an int-tree bit by bit.
08:36:24 <byorgey> perhaps other memoization libraries work that way.
08:37:29 <byorgey> Kaidelong: ah, you CAN build a memoizer that way using the 'bits' function.  But that is not the default.
08:39:14 <Kaidelong> so what does Int-Trie do exactly then?
08:40:42 <byorgey> Kaidelong: I don't understand your question.
08:41:31 <Kaidelong> just wondering what the fundamental data structure is. I presume it's something other than a tree that actually is descended bit by bit
08:43:19 <joe9> anyone using HsColour with ghci -Wall? I need to press an Enter after every command output to get the prompt again.
08:43:32 <joe9> ghci -Wall programmemory-to-eeprom.hs 2>&1 | HsColour -tty
08:43:36 <joe9> is this how to use it?
08:45:06 <dmwit> Kaidelong: No... I'm pretty sure that really is what the fundamental data structure is.
08:45:17 <dmwit> Kaidelong: I don't even think it does path compression!
08:48:05 <nexx> In the "learn you a haskell for great good" section about "(->) r" as an Applicative there is an example line "ghci> (pure 3) "blah"" which should result into 3
08:48:18 <Saizan> a lazy immutable trie can't do path compression
08:48:22 <byorgey> Kaidelong: there is no fundamental data structure in data-memocombinators.  functions are memoized by... other functions.
08:48:24 <nexx> But if I enter it into ghci I get the following error https://privatepaste.com/a63b2db275
08:48:39 <Kaidelong> byorgey: The "bits" function
08:48:40 <byorgey> Kaidelong: it's really rather zen.  You should read the source code.  It's quite short.
08:48:44 <nexx> Where is my mistake?
08:48:50 <Kaidelong> byorgey: I did
08:49:17 <Kaidelong> bits f = IntTrie.apply (fmap f IntTrie.identity)
08:50:04 <mauke> nexx: you're missing some import
08:50:56 <mauke> which is surprising, because that instance is in Control.Applicative
08:51:22 <byorgey> Kaidelong: if you use the 'bits' function, then yes, there really is nothing fancier going on than descending into a binary tree bit by bit
08:51:57 <Kaidelong> oh okay. I was thinking there'd be some clustering going on but I suppose not
08:52:12 <Kaidelong> bucketing?
08:52:13 <byorgey> Kaidelong: but that is only if you use the 'bits' function explicitly.  All the other stuf in Data.Memocombinators does not use that.
08:52:24 <Kaidelong> byorgey: char does
08:52:35 <Melvar> I wrote “type Brainfuck a = StateT (Tape a) IO ()” and attendant actions during a lecture. Is this as strange as I think it is?
08:52:42 <Kaidelong> through integral
08:52:57 <byorgey> oh, I see, so it does.
08:52:58 * hackagebot netlist 0.3.1 - Netlist AST  http://hackage.haskell.org/package/netlist-0.3.1 (AndyGill)
08:53:01 <Kaidelong> integral = wrap fromInteger toInteger bits
08:53:20 <byorgey> Kaidelong: the source of IntTrie is quite short as well: http://hackage.haskell.org/packages/archive/data-inttrie/0.0.5/doc/html/src/Data-IntTrie.html#IntTrie
08:53:43 <nexx> mauke if I understand you correct it's look like a brocken Control.Applicative on my computer?
08:54:14 <nexx> *broken
08:54:27 <byorgey> nexx: what version of ghc do you have?
08:55:04 <nexx> I'm using Haskell Platform 2011.2.0.1
08:55:30 <byorgey> nexx: try also importing  Control.Monad.Instances
08:55:59 <nexx> thx, now it works :-)
09:02:23 <bscarlet> Melvar: What's strange to you?
09:02:58 * hackagebot netlist-to-vhdl 0.3.1 - Convert a Netlist AST to VHDL  http://hackage.haskell.org/package/netlist-to-vhdl-0.3.1 (AndyGill)
09:08:16 <Melvar> bscarlet: I dunno, Haskell and Brainfuck just don’t seem to go together. Brainfuck and Monads even less so.
09:09:15 <alistra> that's quiter talk
09:10:19 <bscarlet> Melvar: heh. can't help you there.
09:12:26 <Ferdirand> what does the a parameter stand for ?
09:12:46 <Melvar> Ferdirand: the type of the cells of the tape.
09:13:07 <gwern> 'For our purpose, this library is simply too generic and unacceptably slow. About 30–40% of CPU time was spent in Data.Time functions. To alleviate the problem, we implemented the http-date package which directly uses ByteString and is about 20 times faster than Data.Time. '
09:13:56 <Melvar> Classical Brainfuck actions are of type Brainfuck Word8, I think. Boolfuck actions would have type Brainfuck Bool.
09:14:06 <Mortiffer_> just cause its hard to google.   When do i use "=>
09:14:13 <Mortiffer_> "=>"
09:14:27 <hpc> Mortiffer_: for type class contexts
09:14:30 <hpc> for example
09:14:37 <hpc> 5 :: Num t => t
09:14:43 <Ferdirand> Melvar: oah, I didn't know about boolfuck
09:14:49 <Ferdirand> forget about what I said then :)
09:14:51 <hpc> mappend :: Monoid a => a -> a -> a
09:14:53 <ClaudiusMaximus> Mortiffer_: http://www.haskell.org/onlinereport/decls.html#sect4.1.3
09:15:18 <ClaudiusMaximus> (bit heavy going though)
09:16:21 <shachaf> srh: Hey, they're talking about your language.
09:17:26 <Mortiffer_> ok so that would mean that t is Num
09:17:46 <Mortiffer_> ?
09:17:50 <Mortiffer_> and this " sum' :: (Num a) => [a] -> a  " means mussed be passed to sum as a 'Num'
09:17:59 * hackagebot ivy-web 0.2 - A lightweight web framework  http://hackage.haskell.org/package/ivy-web-0.2 (JamesDeng)
09:18:18 <sipa> it means that t is a type that belongs to the Num class
09:18:41 <bscarlet> Mortiffer_: I think of it as "Num" must be true of t (or a).
09:18:52 <sipa> i.e., t is a numeric type like Int or Double or Integer
09:19:03 <parcs> can you tell ghc to output the desugared versions of code with do/arrow notation?
09:20:05 <shachaf> parcs: Is there some -ddump- option?
09:21:31 <quicksilver> parcs: well it doesn't desugar it to haskell
09:21:36 <quicksilver> it desugars straight to core
09:21:50 <quicksilver> so the haskell desugaring is a theoretical notion only.
09:22:10 <parcs> is that the ddump
09:22:14 <parcs> -ds flag
09:23:51 <parcs> i guess i'll have to desugar arrow notation by hand :(
09:27:18 <quicksilver> there was a preprocessor for it
09:27:22 <quicksilver> a standalone one I mean
09:29:00 <quicksilver> http://www.haskell.org/arrows/download.html
09:29:42 <joe9> System.Console.Editline.Readline.stifleHistory 15000 -- when I add this line to my ghci.conf, I get this error from ghci: http://codepad.org/uyuZHtbu
09:29:58 <joe9> http://codepad.org/1sfu4s6N cabal install editline
09:30:51 <joe9> cabal install readline --reinstall works fine, Configuring readline-1.0.1.0.
09:33:34 <joe9> is there anyway i can extend the ghci history without using editline?
09:58:02 <FUZxxl> Hello!
09:58:22 <FUZxxl> What kind of polymorphism do typeclasses provide? (I know them, I just forgot the vocabulary)
09:59:34 <Cale> FUZxxl: I would just call it typeclass polymorphism usually. They're a way of restricting parametric polymorphism
09:59:59 <FUZxxl> Cale: Thank you.
11:28:16 --- topic: '["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin/spam issues: #haskell-ops"]'
11:28:16 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Sep 03 10:10:12 2011]
11:31:19 <parcs> JoeyA: ah..
11:33:00 <JoeyA> parcs: Still, it's extremely useful: if you recv bytes from a network connection and don't get an entire object, you can run the continuation when you get the rest of the object.
11:33:47 <JoeyA> And that's what cereal-enumerator takes advantage of.
11:38:21 <lambdanaut> arf <- getLine; let arf = "farts"
11:38:28 <lambdanaut> in a do expression
11:38:45 <lambdanaut> arf = farts overwrties arf being whatever getLine gave, right?
11:38:59 <shachaf> "overwrites"?
11:39:05 <bscarlet> lambdanaut: shadows, not overwrites.
11:39:08 <lambdanaut> right
11:39:22 <lambdanaut> Ok, just making sure!
11:39:26 <shachaf> That's just a syntactic thing, though.
11:39:48 <lambdanaut> yeah, I know there is some crazy underlying monadic dealio, but I prefer to just ignore it if I can
11:39:52 <ClaudiusMaximus> > let arf = "bacon" in let arf = "eggs" in arf
11:39:53 <lambdabot>   "eggs"
11:40:32 <JoeyA> If you compile with -Wall, you'll get a warning about that, though :(
11:40:56 <JoeyA> (about the shadowed variable)
11:41:05 <ClaudiusMaximus> > let arf = "bacon" in (let arf = (++ "eggs") in arf) arf
11:41:07 <lambdabot>   "baconeggs"
11:42:22 <bscarlet> lambdanaut: arf <- getline; let f x = x ++ arf; let arf = "bananas" the latter let will not change f.
11:43:43 <pnutbrtl> > map (+1) [1..10]
11:43:43 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
11:51:56 <Danl2620> dylukes: where is that tutorial?!?!
11:52:04 <Danl2620> dylukes: ;)
12:00:10 * hackagebot snap-core 0.6.0.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.6.0.1 (DougBeardsley)
12:05:10 * hackagebot snap-server 0.6.0.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.6.0.1 (DougBeardsley)
12:05:12 * hackagebot heist 0.6.0.1 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.6.0.1 (DougBeardsley)
12:05:14 * hackagebot snap 0.6.0.2 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.6.0.2 (DougBeardsley)
12:11:24 <zzo38> If I have a list of all values for two types, and the equality comparison of them, how can I make a list of all functions between those types?
12:13:41 <hpc> well now nobody can answer that question...
12:13:52 <bscarlet> if a tree falls...
12:14:42 <hpc> it would just be (,) <$> domain <*> codomain, yes?
12:15:02 <hpc> assuming the domain and codomain have the appropriate bottoms
12:15:16 <hpc> er no, it would be the cross product
12:15:17 <hpc> derp
12:23:00 <swarles> Im trying to install mtl1.1.0.2, can anyone help me through this error with cabal?
12:23:04 <hpaste> swarles pasted “cabal install mtl1.1.0.2” at http://hpaste.org/53259
12:23:44 <ristor2> Hi, How can I convert   (Just 2) to ExpQ for using it in templatehaskell?
12:24:22 <shachaf> ristor2: [|Just 2|]?
12:25:51 <swarles> Oh, i solved my problem
12:26:28 <ristor2> hmm, and that's the same for user-defined types? data Tree = Leaf Int | Node Tree Tree ? [| Node (Leaf 2) (Leaf 1)|] ? how should imports be?
12:28:00 <aavogt> yep. The parser didn't handle qualified names I think
12:28:06 <ristor2> shachaf , if "Just 2" is calculated then what should I do?
12:28:59 <ristor2> foo :: Maybe Int -> ExpQ
12:29:19 <aavogt> ristor2: what do you calculate it from?
12:29:27 <ristor2> string
12:29:36 <ristor2> its part of QQ
12:29:40 <ristor2> quasiquoter
12:29:58 <ristor2> first I parse the string to AST
12:30:47 <ristor2> then I want to use that AST  in template haskell
12:31:24 <ristor2> lets say String->Maybe Int , and Maybe Int -> ExpQ
12:31:46 <aavogt> @hoogle lift
12:31:46 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
12:31:46 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
12:31:46 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
12:32:25 <ristor2> that's exactly what I want , thanks!
12:39:42 <bungley> hey, i'm trying a haskell tutorial, and one of the examples in it doesn't work: http://pastie.org/2774877
12:39:47 <bungley> could someone point out what's up?
12:40:13 <ristor2> oh I have to instantiate Lift type-class for all the types in AST!
12:40:27 <ristor2> any generic/automatic way?
12:40:44 <ristor2> my AST is so large
12:41:14 <shachaf> @google template haskell lift
12:41:15 <lambdabot> http://hackage.haskell.org/packages/archive/ForSyDe/3.0/doc/html/Language-Haskell-TH-Lift.html
12:41:15 <lambdabot> Title: Language.Haskell.TH.Lift
12:41:26 <shachaf> According to that link, it's possible.
12:41:41 <shachaf> http://hackage.haskell.org/package/th-lift
12:41:53 <shachaf> bungley: Are you using YAHT? :-(
12:42:04 <shachaf> Anyway, "doesn't work" isn't very helpful to someone who's trying to help you.
12:42:13 <shachaf> You should explain how it doesn't work.
12:42:14 <bungley> ERROR "Guess.hs":17 - Syntax error in expression (unexpected symbol "doGuessing
12:42:39 <bungley> shachaf: not sure which tutorial, as i'm on the train i figured i'd just get the first one that was a pdf :)
12:42:44 <mauke> bungley: 1) you're using hugs
12:42:49 <mauke> bungley: 2) you're trying to type a program into it
12:42:50 <Axman6> doGuessing needs to be indented further than the do it is a part of
12:42:51 <bungley> of course, i could check
12:43:04 <bungley> mauke: tried in both hugs and ghc?
12:43:07 <shachaf> bungley: I think Learn You a Haskell is often recommended nowadays.
12:43:52 <shachaf> bungley: Also, what Axman6 says.
12:44:11 <bungley> shachaf: ok
12:44:32 <bungley> i had no idea haskell was indentation aware before today
12:44:44 <ristor2> shachaf any idea how does that library work?
12:45:00 <shachaf> ristor2: Nope. I've never used TH.
12:45:04 <shachaf> Presumably it does some THy magic.
12:45:10 <shachaf> bungley: You can provide layout explicitly.
12:45:26 <ristor2> ok how to use it?!
12:46:28 <bungley> yay, thanks all.
12:46:33 <shachaf> ristor2: I don't know. I could probably figure it out if I looked, but so could you, I assume.
12:46:50 <bungley> shachaf: what do you mean by that? throw more brackets about?
12:47:09 <shachaf> bungley: do { a; b; c }, for instance.
12:47:26 <shachaf> bungley: Layout is translation to braces and semicolons by a simple mechanical rule.
12:48:26 <bungley> shachaf: interesting
12:48:40 <bungley> i guess.
12:48:54 <shachaf> s/ion/ed/
12:50:07 <ristor2> ok I guess I have to pass the name of root datatype in my AST
12:50:14 <ristor2> as TH.Name
12:50:39 <ristor2> I assume there was a TH method to pass name of already existing datatype
12:50:43 <ristor2> any idea?
12:50:59 <shachaf> bungley: Anyway, I don't think I really recommend YAHT as an introduction to Haskell (mainly because I found it pretty misleading when I tried to learn from it).
12:51:10 <shachaf> ristor2: ''Name?
12:51:23 <bungley> i already know ocaml
12:51:36 <bungley> are there any tutorials recommended to people that know FP?
12:51:51 <shachaf> bungley: You could read the Gentle Introduction to Haskell.
12:51:58 <shachaf> That's the official tutorial, I believe. :-)
12:52:00 <shachaf> @where tutorial
12:52:00 <lambdabot> http://www.haskell.org/tutorial/
12:52:03 <c_wraith> bungley: I'd still recommend LYAH
12:52:05 <thoughtpolice> bungley: have you tried learn you a haskell, or real world haskell? if you know ocaml, those may be more to your tastes
12:53:01 <bungley> all i've tried is yaht
12:53:11 <kirindave> http://www.youtube.com/watch?v=v_0Yyl19fiI just blew my mind.
12:53:17 <hpc> @where lyah
12:53:17 <lambdabot> http://www.learnyouahaskell.com/
12:54:12 <bungley> well, thanks all
12:54:21 <bungley> hopefully they'll keep me entertained for the rest of my journey
12:54:37 <bungley> and hopefully you won't hear back from me too soon! :)
12:55:54 <byorgey> bungley: that's no fun! come back soon and ask questions =)
12:56:28 <shachaf> bungley: This channel survives on questions.
12:56:38 <shachaf> They're like nourishment. We would die off without them.
12:57:20 <applicative> kirindave, hm mr. lippmeier is using textmate...
12:57:27 <swarles> i've been trying out regex-tdfa, how do i do things like "243" =~ /\d\d\d/ like would be done in perl?
12:58:53 <applicative> kirindave, this javascript clone is pretty amazing, who would have thought it possible http://zokier.net/stuff/webgl-quasicrystal/
12:58:59 <DontFsckWithMe> Ok I'm just learning about monads. Some say they're a way of 'dealing with state'. But isn't better to say they're a way of 'simplifying dealing with state'?
12:59:20 <DontFsckWithMe> because the former implies that if Haskell had state, Monads wouldn't be useful
12:59:21 <copumpkin> that isn't what they're for at all
12:59:42 <kirindave> applicative, yeah well appealing to the GPU is pa powerful feature.
13:00:25 <DontFsckWithMe> copumpkin: by 'dealing' I mean 'simulating state-like behavior in a purely functional system'
13:00:32 <c_wraith> DontFsckWithMe: it's more accurate to say "monads are a very general interface that happens to work well for encapsulating state, as well as a bunch of other stuff.  And unlike most languages, haskell can actually represent the interface in code"
13:00:39 <copumpkin> DontFsckWithMe: that's just one use of them
13:00:47 <DontFsckWithMe> c_wraith: yes, you put my thoughts into words
13:00:59 <copumpkin> DontFsckWithMe: it'd be like saying "computers are a technique for browsing porn"
13:01:04 <copumpkin> yes, they are effective at that
13:01:09 <copumpkin> but that's not what they're "for"
13:01:16 <copumpkin> in fact, they're not "for" anything :P
13:01:19 <DontFsckWithMe> yes I agree
13:02:47 <c_wraith> DontFsckWithMe: it's important to note that many things are monads.  Haskell is just relatively uncommon among programming languages in that it can actually abstract the common interface into code.
13:03:42 <FUZxxl> Is there an easy-to-use library for handling program arguments?
13:03:51 <dylukes> Danl2620: I haven't finished it.
13:03:58 <shachaf> FUZxxl: I like getArgs.
13:04:02 <bscarlet> c_wraith: I haven't thought about that perspective. What about Monads makes it hard for other languages?
13:04:03 <dylukes> The way it's going right now it's not much of an "introduction" to parser combinators though.
13:04:14 <dylukes> I might rehash it that way though.
13:04:19 <FUZxxl> I mean, "automagical parsing and whatever"
13:04:19 <ristor2> any solution to pass fully quantified names in TH ? I cannot use ''A.B.Type
13:04:31 <FUZxxl> I know that there is System.Environment.getArgs.
13:04:51 <kirindave> bscarlet, one thing is that monads are sort of a pain to use unless you have type inference. See common lips and clojure examples. You have to explicitly define the monad in each block of code.
13:04:58 <FUZxxl> I also know System.Console.GetOpt, though I don't really ike it.
13:05:12 * hackagebot presburger 0.4 - Cooper's decision procedure for Presburger arithmetic.  http://hackage.haskell.org/package/presburger-0.4 (IavorDiatchki)
13:05:17 <c_wraith> bscarlet: having type constructors is important.  You need to be able to express the type "m a -> (a -> m b) -> m b", which requires being able to explicitly describe type constructors
13:05:19 <kirindave> bscarlet, an insufficiently smart type system makes them somewhat agonizing to work with even if it can do more than appeal to luck. :)
13:05:36 <kirindave> (in my opinion, scalaz falls into this category)
13:05:38 <bscarlet> "common lips"?
13:05:39 <applicative> DontFsckWithMe: it is really just a consequence of the kind of type type system Haskell has, with (a,b) [a] Either a b etc etc as you like, infinitely
13:05:51 <aditya`> Someone posted this : http://www.infoq.com/presentations/We-Really-Dont-Know-How-To-Compute on the programming.reddit.com, would it worth it to repost in the haskell sub-reddit? Sussman takes a shot (sort of) at Haskell specifically.
13:05:53 <kirindave>  bscarlet: haha, autocorrect is the best
13:05:59 <bscarlet> :-)
13:06:03 <applicative> DontFsckWithMe: when you 'add state' to this you will make a new type associated with each of those infinitely many
13:06:39 <kirindave> aditya`, because if there is one way that works over billions of years incrementally and with great loss, that must be the only way to do it. :)
13:06:52 <applicative> DontFsckWithMe: but then there is the question, how do things in the new state-dependent types relate to each other; how is is like and unlike the way the old non-state types relate to eacch other
13:06:57 <applicative> ha
13:07:19 <aditya`> kirindave: Nice.
13:07:36 * applicative wonders whether monad tutorials have ever killed anyone?  
13:07:42 <dylukes> Danl2620: I decided on JSON for what I'll be parsing.
13:07:55 <dylukes> JSON is *really* explicitly defined on the main page so it should be relatively free of confusion.
13:07:56 * applicative doubts that they can bring the dead back to life. 
13:08:14 <aditya`> Guys like him and Alan Kay have been saying for years that programs that model cells are the best way to build scalable systems.
13:08:31 <c_wraith> bscarlet: ok, that argument doesn't prevent implementing a generic monad interface in a dynamically-typed language.
13:08:35 <JoeyA> dylukes: Oh really?  Is 0x7F a valid character in a JSON string?
13:08:42 <kirindave> aditya`, yeah, but...
13:08:49 <dylukes> JoeyA: It says any unicode character.
13:08:52 <kirindave> aditya`, it's so inefficient and awkward.
13:09:02 <JoeyA> dylukes: Except control characters.
13:09:09 <dylukes> right.
13:09:46 <aditya`> I like that whenever the dynamic language guys use some metaphor based on cells they play up the evolution/cell biology angle, but never the terrorist one.
13:09:48 <dylukes> I can just use the prebuilt unicode charsets and exclude `control`.
13:09:48 <dylukes> :|
13:09:52 <kirindave> aditya`, oh rad
13:09:58 <DontFsckWithMe_> aditya`: I don't think he took a shot at all. He said it's the most advanced of our current languages.
13:10:00 <dylukes> aditya`: yerrorist one?
13:10:00 <JoeyA> The RFC says 00-1F are control characters.
13:10:00 <aditya`> kirindave: But it's real easy to get (something) up and running.
13:10:27 <dylukes> JoeyA: Yep, those are whats in the control CharSet.
13:10:28 <JoeyA> So going by the RFC, 7F (althgouh it is an ASCII control character) may appear in JSON text.
13:10:37 <dylukes> brb
13:10:44 * kirindave mutters.
13:10:46 <kirindave> This talk has me mad
13:10:55 <kirindave> The idea that there is a "language" to life...
13:11:04 <c_wraith> ah, so he's a wolfram disciple
13:11:15 <DontFsckWithMe_> applicative: what are you getting at
13:11:22 <kirindave> Hasn't this idea been thoroughly debunked?
13:11:29 * kirindave is straying into #haskell-blah territory.
13:11:34 <kirindave> Sorry
13:12:22 <DontFsckWithMe_> kirindave: you cannot debunk something that is not even an idea
13:12:31 <aditya`> DontFsckWithMe_: Based on the talk alone there is no shot. But I was in a Haskell workshop with him where he was more vocal on his distaste for category theory.
13:12:34 <DontFsckWithMe_> kirindave: but I still found his talk inspiring
13:12:38 <applicative> i was just saying that if you add 'state-dependent' types to this sort of type system, soon enough you'll notice State Int, and State (Int -> Int) and Int -> State Int hang together
13:13:38 <DontFsckWithMe_> applicative: which is the whole idea behind monads?
13:13:42 <applicative> DontFsckWithMe_:   thus you can apply an (Int -> Int) like (+ 1) to an Int like (1) but you cant apply
13:14:27 <applicative> a State (Int -> Int) to a State Int, the types don't match.  But there is a systematic connection, it's just a question of normalizing this
13:14:57 <dylukes> JoeyA: JSON spec says "any-Unicode-character-except-"-or-\-or-control-character"
13:15:05 <dylukes> So I'm going to go with 0x7F being forbidden.
13:16:19 * JoeyA crashes dylukes with a valid(?) JSON string containing 0x7F
13:16:30 <dylukes> Well I'm saying it's not valid.
13:16:31 <dylukes> :)
13:16:34 <dylukes> So I won't accept it.
13:17:02 <applicative> DontFsckWithMe_: that there will be such a systematic connection is obvious, the monad class lets you see how it is similar to quite different cases, thus even lists are a monad
13:17:53 <applicative> DontFsckWithMe_: but any one of the familiar Monads -- lists, Maybe, IO , State etc etc. can be worked with apart from this abstraction.
13:18:29 <DontFsckWithMe_> lists are monads? So bind is like map?
13:18:42 <JoeyA> bind is concatMap, so yes :-)
13:18:48 <DontFsckWithMe_> mind=blown
13:18:51 <applicative> DontFsckWithMe_: but when you grasp it a lot of things come together.  Similarly with simpler super-abstractions like Functor and Applicative, to take the usual examples
13:19:15 <JoeyA> > concatMap (\x -> [x, x, x]) [1,2,3]
13:19:16 <lambdabot>   [1,1,1,2,2,2,3,3,3]
13:19:34 <JoeyA> > [1,2,3] >>= \x -> [x, x, x]
13:19:35 <lambdabot>   [1,1,1,2,2,2,3,3,3]
13:19:40 <DontFsckWithMe_> considering I just learned about monads today, I'd say I'm doing pretty good
13:19:48 <applicative> > do {a <- [1,2,3]; return (a * a)}
13:19:50 <lambdabot>   [1,4,9]
13:19:50 <JoeyA> > do {x <- [1,2,3]; [x,x,x]}
13:19:51 <lambdabot>   [1,1,1,2,2,2,3,3,3]
13:20:36 <azaq23> @type mapM
13:20:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:20:51 <applicative> > [1,2,3] >>= \x -> [x,x,x]
13:20:53 <lambdabot>   [1,1,1,2,2,2,3,3,3]
13:20:53 <copumpkin> DontFsckWithMe_: lists are roughly "the nondeterminism monad"
13:20:59 <copumpkin> although you'd probably want sets for that, ideally
13:21:08 <copumpkin> or multisets?
13:21:15 <DontFsckWithMe_> azaq23: hah
13:21:24 <alistra> state monad is the coolest
13:21:56 <applicative> if you link of [1,2,3] as possible user inputs then the possible outputs are like those above
13:22:03 <copumpkin> alistra: it's one of the simplest :P
13:22:20 <alistra> copumpkin: which one is harder?
13:22:51 <Cale> DontFsckWithMe_: To be a little more precise terminology wise, the list type constructor is a monad (you could say "List is a monad")
13:22:52 * applicative favors the Identity monad
13:23:04 <Cale> Individual lists like [1,2,3] aren't monads.
13:23:20 <DontFsckWithMe_> yes they're monadic types
13:23:26 <DontFsckWithMe_> I think
13:23:28 <copumpkin> values, if anything
13:23:28 <applicative> grammar sort of gives out some point in there.
13:23:30 <Cale> monadic values
13:23:35 <kirindave> DontFsckWithMe_, don't even try to find a way to say it
13:23:43 <kirindave> Any way that you say it will give someone a chance to object.
13:23:43 <DontFsckWithMe_> Cale: yeah, instances of monadic types
13:23:45 <kirindave> ;)
13:24:00 <Cale> [] is a monad, [Integer] is a monadic type, [1,2,3] is a monadic value
13:24:24 <DontFsckWithMe_> kirindave: I can handle it, look at my nick
13:24:42 <copumpkin> [] is a monad when it has a couple of operations attached to it that satisfy laws
13:24:58 <DontFsckWithMe_> don't fsck with me and I won't fsck with you
13:25:00 <applicative> calling them all lists could be found objectionable too, there is no type that all the lists belong to.
13:25:22 <alistra> DontFsckWithMe_: why don't you just put Fuck there?
13:25:42 <srofit> because fuck that
13:25:47 <Cale> sudo tune2fs -c1 /dev/sda1
13:25:51 <DontFsckWithMe_> alistra: because it wouldn't be funny
13:26:02 <alistra> it isn't anyway
13:26:10 <alistra> everybody heard that joke already :|
13:26:10 <applicative> saying that getChar and "abcd" are monads just repeats the same loose speech one level up
13:28:53 <kirindave> Dang
13:28:57 <kirindave> Alistra going for the kill.
13:31:18 <applicative> I stopped thinking "getChar is a monad" was madness when I saw LYAH saying that getChar and "abcd" are Functors of Chars because you can apply 'fmap chr' to either one
13:31:57 <alistra> what the fuck am i reading, srsly
13:32:22 <DontFsckWithMe_> Cale: who doesn't use expletives every morning when they have to get up for work?
13:32:32 <Cale> why me?
13:32:47 <Cale> applicative: Yeah, that's weird use of terminology
13:32:52 <DontFsckWithMe_> Cale: that command you issued
13:33:32 <Cale> applicative: It's a way in which we could possibly abuse terminology, but it's odd.
13:34:00 <Cale> DontFsckWithMe_: heh
13:34:39 * byorgey still thinks "getChar is a monad" and "getChar is a Functor of Char" are madness
13:34:40 <applicative> It is, but it's a fact of experience, that "you can do fmap chr over it" unites a bunch of things, why not say they're uh, functors of chars? where that means, lists of chars or, maybe chars
13:35:18 <DontFsckWithMe_> byorgey: madness?
13:35:23 <blackh> So it's using monad to mean "has a type which is an instance of Monad and follows the laws". Shouldn't we do that?
13:35:29 <byorgey> overloading the same word to refer both to types and to values of that type is a pedagogical disaster.
13:35:43 <alistra> everithing is a monad
13:35:53 <applicative> or actions-that-return-chars or whatever
13:35:58 <blackh> byorgey: But surely we know that values can't be instances of type classes
13:36:07 <applicative> 1 is not a monad!
13:36:10 <monochrom> we, the learned, know, yes.
13:36:15 <blackh> I wouldn't say it to someone who was learning Haskell, thoughj
13:36:16 <byorgey> blackh: *I* know it, and *you* know it, but I'm talking about people just learning Haskell.
13:36:27 <blackh> Fair enough
13:36:31 <byorgey> overloaded terminology breeds imprecise thinking.
13:36:50 <byorgey> unless you are used to overloaded terminology, like many mathematicians
13:36:55 <byorgey> but that is a special learned skill.
13:36:58 <monochrom> "data X = X Int" is another disaster, and happens earlier
13:37:06 <byorgey> agreed.
13:37:12 <shachaf> monochrom++ # disaster
13:37:14 <shachaf> But very convenient.
13:37:27 <blackh> I remember when I was learning. The type name being the same as the constructor name had me very confused.
13:37:37 * applicative finds that the type checker keeps everything straight for him
13:37:38 <monochrom> oh, I totally support industrial strength code to do that, no objection there
13:38:12 <applicative> blackh, it's true, the older primers used MkFoo rather tediously though.  I'm not sure it was that much clearer....
13:38:29 <Cale> I think it's kinda telling that the mathematicians don't overload the meaning of monad :)
13:38:43 <ciaranm> yes they do!
13:38:51 <Cale> Oh?
13:38:57 <Cale> Where have you seen that?
13:38:59 <applicative> data Parser a = MkParser (String -> [(String, a)])
13:39:09 <ciaranm> i've seen them use it for "monadic" and "diadic" functions
13:39:14 <ciaranm> meaning taking one or two arguments
13:39:15 <Cale> Oh, not in that sense
13:39:30 <Cale> That's a completely different etymology
13:39:43 <Cale> (which happened to produce the same word)
13:39:58 <Cale> monad in the CT sense is monoid+triad
13:40:53 <shachaf> "Those two things that we use the same word for are completely different! That's not overloading!"
13:41:22 <Cale> It's not really the same word ;)
13:41:42 <brisingr> really?
13:41:48 <byorgey> yes, word identity includes etymology =)
13:41:56 <brisingr> I thought monad from haskell comes from monad from CT
13:42:00 <Cale> oh, yes
13:42:08 <brisingr> but the nomenclature?
13:42:11 <ciaranm> i think it's kinda telling that you can say "oh, that's just a monad" to completely arbitrary things in applied maths lectures without anyone disagreeing
13:42:12 <Cale> but 'monadic' in the sense of 'arity 1'
13:42:15 <Cale> is different
13:42:30 <brisingr> oh
13:42:44 <monochrom> "monadic second order logic" \∩/
13:44:01 <DukeDave> Aw, I was rather hoping there was something akin to XOR with Data.Set
13:44:01 <applicative> "monadic predicate calculus" whats wrong with that?  nothing very monadic about it.
13:44:01 <Cale> One monadic is monad + -ic and the other is mon- + -adic
13:44:17 <Cale> DukeDave: isn't there?
13:44:44 <DukeDave> Cale: Apparently not
13:45:25 <DukeDave> Cale: This would do it: http://en.wikipedia.org/wiki/Symmetric_difference
13:45:56 <Cale> oh, right, there's differenceWith, but no analogous thing for union
13:46:25 <Cale> er, actually, no, differenceWith also only exists for Map
13:46:37 <DukeDave> Boo
13:46:57 <Cale> I guess you can just do  (x `union` y) `difference` (x `intersection` y)
13:47:36 <applicative> thats what I was thinking
13:47:49 <byorgey> or (x `difference` y) `union` (y `difference` x)
13:47:49 <Cale> Or (x `difference` y) `union` (y `difference` x)
13:47:50 <shachaf> @pl \x y -> (x `union` y) `difference` (x `intersection` y)
13:47:50 <lambdabot> ap (ap . (difference .) . union) intersection
13:47:51 <Cale> yes
13:48:04 <DanBurton> OK guys, despite my better judgement, I've written a monad tutorial. Anyone care to critique? http://unknownparallel.com/monads.php
13:48:45 <salisbury> If your data structure sticks around for a while, it may be worth creating it as Data.Map, then converting
13:48:45 <FUZxxl> Is there a function that repeats a monadic action m a while / until a predicate a -> Bool holds?
13:48:47 <alistra> DanBurton: yet another monad tutorial?
13:49:21 <alistra> FUZxxl: there's monadic when, you can infintely recurse with that
13:49:35 <alistra> @hoogle when
13:49:35 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:49:39 <salisbury> Data.Map has a lot of convenience functions that make building the structure simple
13:49:52 <DanBurton> alistra: mine's called "Zero-Analogy Monad Tutorial"
13:50:16 <DanBurton> alistra: the name "Yet Another Monad Tutorial" was already taken :)
13:50:19 <dmwit> :t let swap = snd &&& fst in liftM2 union (uncurry difference) (uncurry difference . swap)
13:50:20 <lambdabot> Not in scope: `difference'
13:50:21 <lambdabot> Not in scope: `difference'
13:50:21 <shachaf> Some functions are monads! Type functions, that is.
13:50:31 <FUZxxl> alistra: Problem is: I need to return the output. I can alway fallback into recursion, though
13:50:49 <DanBurton> shachaf: "type functions"?
13:51:26 <Elf-King> Just trying out the tryhaskell.org... it's very nice :)
13:51:32 <DanBurton> shachaf: my target audience wasn't exactly the people that do type-level lambda calculus :P
13:51:53 <shachaf> DanBurton: Anyway, that tutorial looks very confusing from the perspective of someone who doesn't already know what it's talking about.
13:52:00 <DukeDave> Hmm, has anyone tried writing an "instance Monad Analogy"? :)
13:52:13 <dmwit> ?quote analog
13:52:14 <lambdabot> Wikipedia says: In topology, the long line (or Alexandroff line) is a topological space analogous to the real line, but much longer.
13:52:34 <byorgey> DanBurton: I would drop the section called "Monads are not hard to understand".  They ARE hard to understand at first, and if someone didn't already understand the stuff you wrote above, the content of that section is not going to help them.
13:52:38 * shachaf is of the opinion that the way to introduce "monads" is to introduce concrete cases without ever mentioning the M-word.
13:52:56 <byorgey> DanBurton: instead it would just make them feel stupid for not understanding something which is not hard to understand.
13:53:06 <shachaf> Later you can show that there are parallels and that they can be captured in their own type class and you can wrtie combinators that work for any instance of that type class.
13:53:20 <DanBurton> byorgey: how about if I rename it "Monads are not supposed to be hard to understand"?
13:53:32 <dmwit> shachaf++ it's why I love sigfpe's tutorial so much
13:53:33 <byorgey> DanBurton: no good.  Monads are not supposed to be anything.  They just are.
13:53:51 <DontFsckWithMe_> zen.
13:53:51 <hydo> hey, guys who know him: dons is ok, right?  I haven't seen hide nor hair except for once in a while a post on G+ since his move to NY.  It's just kind of weird not seeing him on SO or reddit.
13:53:58 <alistra>  and no examples DanBurton
13:53:58 <Cale> @remember byorgey Monads are not supposed to be anything.  They just are.
13:53:58 <lambdabot> It is stored.
13:53:59 <ciaranm> DanBurton: you don't include any of the terms "endo", "monoid", "adjoint" or "category" (except once which doesn't count)
13:54:02 <byorgey> DanBurton: that still has the same problem anyway.  "I'm finding this hard to understand, but it's not supposed to be!  Something must be wrong with me!"
13:54:03 <DanBurton> byorgey: well exactly. I'm not asserting they are supposed to be easy to understand. I'm asserting they' *not* supposed to be hard to understand. :)
13:54:33 <shachaf> They're also not supposed to be easy to understand.
13:54:33 <byorgey> DanBurton: such subtleties will be lost on your readers.
13:54:48 <EvanR-work> monads need a different name
13:54:50 <shachaf> For that matter, I don't typically like it when people say "they" when referring to "monads".
13:54:51 <dmwit> That's true. Nobody sat down and said, "Hm, let's invent something that's hard to understand. I'll call them monads.".
13:54:54 <dmwit> But so what?
13:55:10 <dmwit> Nobody cares that they weren't invented to be hard to understand if it turns out that they are hard to understand anyway.
13:55:16 <DanBurton> byorgey: I see where you're coming from. /sigh I was trying to avoid any feel-good fluff, but I also don't want to alienate new readers
13:55:17 <shachaf> What we need in this channel is some literary criticism.
13:55:28 <mightybyte> hydo: Yes, dons is alive and well.  I talked to him recently.  Seems like he's been really busy at work.
13:55:30 <shachaf> dmwit: Which one? "You could have invented monads"?
13:55:36 <int-e> dmwit: but the point is that you don't have to understand the concept to use any individual monad.
13:55:39 <dmwit> shachaf: the very same
13:55:48 <hydo> mightybyte: ok, cool.  Thanks!
13:55:57 * shachaf doesn't completely trust that one.
13:56:02 <dmwit> int-e: Then make that point. That point seems much more content-ful than "X is hard/easy to understand".
13:56:04 <EvanR-work> int-e: also, understanding the concept will not help you use any instance of monad ;)
13:56:08 <shachaf> dmwit: I like the introduction in Graham Hutton's book, which I think uses parsers?
13:57:22 <ciaranm> any tutorial that explains monads without category theory is fundamentally missing the point and isn't saying what monads are at all
13:57:36 <Elf-King> '
13:57:46 <Elf-King> woops ... sorry ... *hugs* all :)
13:57:51 * Elf-King bows out
13:57:57 <mdempsky> schroedinbug: [re 'disliking they']  Why?  What other pronoun should be used to refer to a set of monads?
13:57:59 <dmwit> ciaranm: That's, like... troll material for #haskell. =P
13:57:59 <DanBurton> ciaranm: well yes. I'm not trying to imbue deep understanding of what a Monad "really" is. I'm trying to imbue enough understanding so that people will be more comfortable with Monads in Haskell
13:58:22 <EvanR-work> the whole idea of monad 'tutorial' is flawed, like many categories of tutorials
13:58:33 <shachaf> @google crash monad tutorial
13:58:34 <lambdabot> http://patryshev.com/monad/m-intro.html
13:58:34 <lambdabot> Title: Crash Monad Tutorial
13:59:33 <EvanR-work> shachaf: well that has the 'outside world value' IO thing, which is weird
14:00:09 <mdempsky> shachaf: Er, that question was for you, not schroedinbug... (bad tab completion)
14:00:12 <dmwit> byorgey: By the way, I really like your campaign against "X is hard to understand". When/how did it start?
14:00:14 <shachaf> EvanR-work: Yes, I don't like that.
14:00:52 <byorgey> dmwit: Thanks.  I really don't remember.
14:01:02 * DanBurton changed the section header from "Monads are not hard to understand" to simply "Recap"
14:01:12 <shachaf> mdempsky: People can talk about the monad type class as "it".
14:01:35 <EvanR-work> "I am sure that if you approach the topic from categorical point of view, everything will look almost elementary. "
14:01:55 <EvanR-work> lol, almost = not ;)
14:01:56 <Cale> Monads aren't hard to understand if you start with an undergraduate degree in mathematics and already know what a natural transformation is ;)
14:02:04 <ciaranm> everything in category theory is obvious once you know what the definitions are
14:02:28 <brisingr> self-explanatory does not mean obvious
14:02:31 <ciaranm> which is why category theory doesn't have any theorems. everything's a definition, except for the occasional lemma
14:02:40 <byorgey> for sufficiently large values of "know"
14:03:03 <EvanR-work> ciaranm: how is it a theory then, if it doesnt have theorems ;)
14:03:18 <Cale> Heh, I think Yoneda's lemma should be called the Yoneda completion theorem
14:03:23 <shachaf> But what is confluence? It's a difficult question, because confluence is impossible to describe. One might ask the same about monads. What are monads? We just don't know.
14:03:38 <ciaranm> EvanR-work: "theory" to mathematicians is basically just a "topic"
14:04:07 <tgeeky> if I ever invent some famous theorem, I hope that they won't name it after me but instead name it after the denotation of the theorem or somehting
14:04:31 <dtrebbien> A mathematician might describe a mathematical theory as a collection of theorems related to a particular topic.
14:04:38 <ciaranm> whatever you do, don't invent lots of theorems
14:04:45 <alistra> Zero-Analogy Monad Tutorial
14:04:46 <alistra> from Haskell :: Reddit
14:04:47 <brisingr> monads are like rites of passage: "I can only show you the Monad, you're the one who has to understand it."
14:05:00 <EvanR-work> lol
14:05:02 <alistra> DanBurton: you're fast
14:05:21 <ciaranm> dtrebbien: i'd say s/theorems/definitions, propositions, lemmas, examples, theorems, corollaries/
14:05:27 <DanBurton> alistra: fast? What did I do fast?
14:05:32 <dtrebbien> ciaranm: True.
14:05:37 <alistra> ulpoad it to reddit
14:05:43 <dtrebbien> ciaranm: A mathematician needs to know the exact definition.
14:05:49 <ciaranm> i swear half the things in a complex analysis course are named "the cauchy something"
14:05:52 <alistra> i have it on my haskellreddit rss
14:05:55 <DanBurton> alistra: yeah I did that before presenting it to you guys :)
14:07:01 <mdempsky> ciaranm: Just wait until you get to cauchy monads.
14:07:14 <dtrebbien> ciaranm: In a little while, everthing will be Picard's.
14:07:43 <dtrebbien> ciaranm: Every. single. time. I was thinking of Jean-Luc
14:07:49 <gtirloni> DanBurton: thx for the tutorial. i'm slowly learning about monads and another perspective always help.
14:08:17 <homie`> and at a later step nothing of it will matter when you go to ∞ where no man has gone before!
14:08:21 <DanBurton> gtirloni: :) if anything in the tutorial is confusing please let me know
14:08:26 <homie`> lol
14:08:46 <dtrebbien> :)
14:09:17 <ciaranm> there's a "cauchy monad"? stop naming stuff after people who died before things existed. "cartesian" categories are bad enough.
14:09:42 <dtrebbien> Okay, an on-topic question: Is there a work-around for Haskell Platform ticket #187: http://trac.haskell.org/haskell-platform/ticket/187
14:10:07 <monochrom> no, not true that half of the things in complex analysis are named "the cauchy something". but half of the time you do hear "cauchy", because one thing --- the Cauchy-Riemann equation --- is pervasive.
14:10:16 <dtrebbien> I tried passing --external-lib-dirs to `cabal install`, but GHC still had trouble loading double-conversion.
14:10:16 <Danl2620> DanBurton: I'm reading it too. It's helpful so far.
14:10:33 <monochrom> (and therefore the other half of the time you hear "Riemann" XD )
14:10:43 <DanBurton> Danl2620: that's good to hear :)
14:10:46 <Danl2620> DanBurton: so there is a hierarchy of type classes?
14:11:11 <c_wraith> dtrebbien: the last few comments on http://hackage.haskell.org/trac/ghc/ticket/5289 have a work-around for linux systems
14:11:31 <dtrebbien> c_wraith: I'm on Windows. Will that matter?
14:11:59 <DanBurton> Danl2620: Oh yes.
14:12:15 <edwardk> preflex: xseen lispy
14:12:15 <preflex>  lispy was last seen on freenode/#haskell 5 days, 3 hours, 44 minutes and 38 seconds ago, saying: bah, so that -no_pie error is because I have xcode 3.2.something but I need a newer version like 3.2.3.
14:12:17 <c_wraith> dtrebbien: yes, it matters.  I have no clue how to work around it on windows or os x
14:12:18 <ciaranm> Danl2620: yes, and for hysterical raisins, Monad is in the wrong place in that hierarchy
14:12:27 <c_wraith> dtrebbien: the underlying problem is a ghc bug
14:12:28 <dtrebbien> c_wraith: Maybe I'll try an NTFS symbolic link.
14:12:36 <dtrebbien> I see.
14:12:39 <DanBurton> Danl2620: see http://haskell.org/haskellwiki/Typeclassopedia
14:12:40 <edwardk> @tell lispy now that you are actively maintaining HOpenGL be prepared for a flood of requests ;)
14:12:41 <lambdabot> Consider it noted.
14:13:11 <dtrebbien> c_wraith: Is GHC not able to look in multiple directories for import libraries?
14:13:29 <c_wraith> dtrebbien: it actually records the name of the library wrong, leading to it not being able to find it.
14:13:56 <Danl2620> DanBurton: you mention a Monad being a Pointed Applicative Functor... aren't all Applicative types Pointed?
14:13:59 <dtrebbien> c_wraith: I'm not sure that I understand. How does GHC record it wrong?
14:14:17 <DanBurton> Danl2620: Yes! I suppose that phrase is ambiguous
14:14:24 <c_wraith> dtrebbien: I'm not sure of the details...  That ghc ticket has them, though
14:14:28 <Danl2620> not at all... overspecified perhaps
14:14:35 <dtrebbien> c_wraith: Okay.
14:14:42 <dtrebbien> c_wraith: Thanks for the link to the ticket.
14:15:30 <Danl2620> it confused me a bit
14:15:51 <DanBurton> Danl2620: do tell. What's confusing?
14:16:07 <DanBurton> Danl2620: would it be clearer if I put "Poitned" in parenthesis?
14:16:08 <Danl2620> ciaranm: where should the Monad be in the hierarchy?
14:16:44 <Danl2620> DanBurton: maybe something like "beyond being an Applicative Functor (and therefore Pointed)"
14:17:04 <ciaranm> Danl2620: Monad should be in the same hierarchy as Functor, Applicative etc, and it isn't
14:17:37 <DanBurton> Danl2620: I like that. I'm totally stealing it.
14:17:53 <ciaranm> "Applicative Functor" is redundant too
14:18:02 <ciaranm> if it's with Capital Letters
14:18:08 <Danl2620> heh... that's true as well.
14:18:19 <ciaranm> "Applicative" is an "applicative functor" or an "applicative Functor"
14:18:38 <Danl2620> using Applicative as a noun sounds wrong
14:18:58 <Danl2620> but is technically correct
14:19:05 <Danl2620> ?
14:19:08 <shachaf> Hey, #haskell, who's for renaming Control.Category Control.Monoidoid?
14:19:23 <homie`> applicative apple
14:19:46 <monochrom> Monoidoid?!
14:19:57 <ciaranm> Danl2620: convention seems to be moving towards using adjectives for type classes
14:20:13 <homie`> monochrom: sounds like crystal structure
14:20:15 <ciaranm> Danl2620: and then treating those adjectives as nouns when you talk about the type class
14:20:19 <monochrom> and if I have the category of small categories, is that a monoidoidoid?
14:20:50 <Danl2620> ciaranm: I see. So to be grammatical and verbose you'd say "Applicative type" and "Functor type"?
14:21:27 <ciaranm> Danl2620: naah. i've accepted the notion that "Applicative" is a noun
14:22:00 <EvanR-work> "mon" ++ cycle "oid"
14:22:14 <EvanR-work> monpluscycloid
14:23:33 <ciaranm> i'm sure if you wave your hands enough and draw some arrows you can claim that "oid" being a cycle means it's a natural transformation
14:24:28 <homie`> paralleloid, rhomboid....
14:25:08 <ciaranm> does you rhomboid commute?
14:25:42 <DanBurton> Danl2620: The thing is, in the Haskell base libraries, Applicative is actually defined with a Functor constraint
14:26:03 <erkin> Good night.
14:26:17 <DanBurton> Danl2620: therefore whenever we refer to the Applicative typeclass, it is of course implied that it is an applicative functor, because Functor is a constriant
14:28:43 <ciaranm> it's a shame that you have to implement Functor too once you've implemented Applicative
14:29:24 <Danl2620> can you imagine of there were a "Learn Haskell the Hard Way" tutorial?  It would be epic
14:29:38 <ciaranm> lyah!
14:29:56 <Danl2620> the problem is I think there really only is the "hard way" in the long run
14:30:14 <hydo> Danl2620: no 'royal road', etc?
14:30:39 <ciaranm> there's got to be a way of teaching category theory without topology. shame lawvere's book sucks so badly.
14:30:40 <Danl2620> heh... yep just read that quote in byorgey's article
14:30:45 <kmc> learn haskell by arguing with zed shaw
14:30:52 <hydo> kmc: hahah
14:31:11 <homie`> cat theory !
14:31:14 <pumpkin> meow
14:31:16 <homie`> lol
14:31:18 <hydo> outspoken or not, I really like mongrel2
14:32:31 <kmc> i don't know anything about Zed Shaw except that he wrote Learn Python The Hard Way and is famous for upsetting people
14:32:36 <prototrout> Is there a way to see reverse dependencies on Hackage? (See which packages depend on a given package)
14:32:46 <kmc> prototrout, somebody had a hackage mirror that had that
14:32:50 <kmc> but i don't have the link :/
14:32:54 <parcs> @where hackage
14:32:54 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
14:32:56 <hydo> kmc: he's working on Learn C the Hard Way as well.
14:32:57 <parcs> @where revdeps
14:32:57 <lambdabot> "Show reverse dependencies" at <http://hackage.haskell.org/trac/hackage/ticket/576>,"Hackage with Reverse Dependencies" by Roel van Dijk at <http://bifunctor.homelinux.net/~roel/hackage/packages/
14:32:58 <lambdabot> hackage.html>,"Reverse Dependencies" at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html>,<http://packdeps.haskellers.com/reverse> -- `bifunctor.homelinux.net' is
14:32:58 <lambdabot> broken, use `81.26.216.99' instead
14:32:58 <ciaranm> prototrout: just look at normal dependencies on coHackage
14:33:07 <kmc> you can get http://hackage.haskell.org/packages/archive/00-index.tar.gz
14:34:59 <prototrout> parcs: Thanks! Thanks also kmc
14:35:48 <ciaranm> i'm not sure a "learn haskell the hard way" would be a good idea, since "the hard way" appears to be "by seeing what it does without understanding how or why it works"
14:36:28 <EvanR-work> as long as you stay out of IO, nothing can hurt you
14:36:36 <EvanR-work> except for _|_
14:36:41 <Danl2620> that's the Zed Shaw way, certainly.
14:36:54 <parcs> in what way does 'learn python the hard way' teach python the hard way?
14:37:00 <Danl2620> You could take the theoretical foundations approach, which would work better for Haskell
14:37:21 <ciaranm> it's like learning maths by looking at examples. it's going to get you hurt...
14:37:32 <Danl2620> EvanR-work: heh... you can't stay out of IO
14:37:44 <Danl2620> EvanR-work: main
14:37:49 <kmc> what does "the hard way" actually mean? what does ZS mean by it?
14:38:05 <EvanR-work> > Nothing >> Just 0
14:38:06 <lambdabot>   Nothing
14:38:08 <EvanR-work> eat that
14:38:09 <ciaranm> kmc: i think he means "admire my penis", to be honest...
14:38:13 <kmc> i've been thinking for years of writing a "haskell from first principles" tutorial
14:38:19 <kmc> i wouldn't call that "the hard way"
14:38:26 <kmc> it may be easier for many people
14:38:41 <EvanR-work> its my way or the hard way
14:38:58 <kmc> it's just that, instead of stopping every paragraph to say "this thing is kind of like java but not really", I would ask you to suspend your knowledge of other languages from the start
14:39:06 <ciaranm> lyah does a fairly good job of moving up from first principles
14:39:23 <Danl2620> kmc: yup... I learned Scheme in college that way and it was great
14:39:45 <kmc> MIT used to teach Scheme to CS freshman that way
14:39:49 <ciaranm> it's just they don't look like first principles because they're drawn as pictures of monsters
14:40:22 <ciaranm> there don't seem to be many mainstream languages that are built on principles, though
14:40:38 <EvanR-work> the hard way == knuth art of computer programming ;)
14:41:01 <ciaranm> the hard way is stuff that isn't in knuth that you have to find in the literature...
14:42:36 <EvanR-work> i have a question about category of sets
14:42:47 <ciaranm> http://learnpythonthehardway.org/book/ex45.html does this remind anyone else of really bad "a Monad is like a box" tutorials?
14:43:12 <homie`> black box approach ? ugh
14:43:14 <kmc> a monad is like a salmon
14:43:21 <homie`> or pandoras.....lol
14:43:23 <kmc> fish burrito
14:43:24 <kmc> nom
14:44:25 <EvanR-work> so we dont want to say that category objects form a set, because they might not. but what about the category of all sets, to define a set dont you need a 'is in' predicate, and since we can tell whether a set 'is in', is an object in the category, doesnt that lead to a set of all sets
14:44:59 <ciaranm> EvanR-work: which set theory are we working in here?
14:45:04 <EvanR-work> dunno
14:45:17 <EvanR-work> i was trying to talk about categories
14:45:20 <ciaranm> EvanR-work: the answer to your question depends upon whether your set theory of choice has just sets, or sets and classes, or something else
14:45:54 <EvanR-work> seems like 'is in' predicate isnt enough
14:46:06 <EvanR-work> seems weird though
14:47:11 <EvanR-work> but if it is, then the objects of that category form a set because all sets are in it, pretty simple test ;)
14:47:38 <EvanR-work> how about this question, whats an example category where the objects and or arrows dont form a set
14:48:20 <ciaranm> EvanR-work: you're arguing circularly there, although to see why you really need to decide how exactly you're defining a set
14:48:50 <homie`> recursively!
14:48:52 <homie`> lol
14:49:06 <ciaranm> you can define sets in terms of category theory if you want
14:49:08 <homie`> set of sets of set of sets of ......
14:49:12 <EvanR-work> a set is a test which tells you if the subject at hand is in the set or isnt
14:49:18 <EvanR-work> i just made that up
14:49:40 <homie`> like a christmas tree!
14:49:42 <homie`> lol
14:50:05 <EvanR-work> set :: ? -> Bool
14:50:15 <ciaranm> EvanR-work: if i'm remembering that mess correctly, just having membership doesn't stop you from having "the set of all sets" etc.
14:50:34 <EvanR-work> is that bad?
14:50:43 <ciaranm> EvanR-work: the usual solution is to have two "kinds" of set: the kind that behave, and the kind that don't have to
14:51:51 <ciaranm> EvanR-work: so the "set of all sets" is one of the "doesn't behave" kind, and anything you do on it gives you a "doesn't behave" result, unless you explicitly prove that your result is in fact well behaved
14:52:14 <EvanR-work> what exactly doesnt behave about it?
14:52:22 <ciaranm> EvanR-work: (this is all very vague and hand-wavy because you have to do it properly with lots of rotated As and Es for it to make sense)
14:52:38 <ciaranm> EvanR-work: the usual example of "doesn't behave" is "the set of all sets that don't contain themselves as members"
14:52:50 <EvanR-work> ah well thats another story
14:53:04 <ciaranm> no, that's the central plot
14:53:16 <EvanR-work> so thats one possible test i talked about
14:53:23 <EvanR-work> but that test doesnt make sense
14:53:31 <EvanR-work> so ha
14:53:37 <ciaranm> sure it does
14:53:47 <EvanR-work> no because you cant evaluate it sometimes
14:53:55 <EvanR-work> _|_
14:54:10 <ciaranm> that's "doesn't behave"
14:54:22 <ciaranm> which is sometimes called "proper class"
14:54:47 <EvanR-work> i wonder if its worth it to not simply throw that test out as nonsesne
14:55:06 <ciaranm> to do that you'd need a test to determine whether a test is nonsense
14:55:13 <ciaranm> and you're right back where you started
14:55:46 <EvanR-work> you could identify allowed logical statements
14:56:04 <EvanR-work> and the ones that make sense but arent covered by that language are SOL
14:56:10 <dmwit> EvanR-work: re: "whats an example category where the objects and or arrows dont form a set"
14:56:23 <xenocryst> I'm trying to make a vector data type but I'm not sure if this idea is good or not: data Vector dimmension element_type = V ([element_type], dimmension). Would this definition make proper use of types and all of that?
14:56:23 <dmwit> EvanR-work: The simplest possible category, that of sets with functions as arrows, is such a category.
14:56:28 <ciaranm> EvanR-work: if you do that then your language can't be powerful enough to deal with natural numbers
14:56:54 <ciaranm> EvanR-work: you really can't do much at all if you stick to languages that aren't strong enough to get you godeled
14:56:56 <dmwit> (Don't know the context, so I have no idea if that helps or not, but there it is.)
14:57:06 <EvanR-work> ciaranm: thats nuts
14:57:13 <EvanR-work> dmwit: yes its helpful
14:57:29 <Draconx> dmwit, I find it hard to believe that that's the simplest possible category.
14:57:32 <ciaranm> EvanR-work: godel's theorem? it's why computing exists!
14:57:33 <EvanR-work> ciaranm: do we know if natural numbers make sense? ;
14:57:35 <EvanR-work> ;)
14:57:45 <ciaranm> EvanR-work: we know that they can't be proven to be consistent
14:57:49 <ciaranm> (sort of)
14:57:54 <dmwit> Draconx: Sorry, "simplest possible" was an ill-defined criteria.
14:58:03 <dmwit> Draconx: What I meant was "everybody's first example of a category". =)
14:58:11 <EvanR-work> tomorrow someone may invent 'XYZ paradox' regarding naturals
14:58:28 <EvanR-work> then what
14:58:42 <Draconx> EvanR-work, mathematicians all over the world will be excited.
14:58:46 <ciaranm> EvanR-work: something a bit like the naturals (typically an inductively defined or infinite set) is typically an axiom
14:59:21 <ciaranm> EvanR-work: actually, it's worse than that: tomorrow someone might prove that ZF is consistent, in which case we'll know it's inconsistent and then we're screwed
14:59:31 <ddarius> ciaranm: Not really.
15:00:16 <EvanR-work> i dont know what it means to be proved consistent
15:00:17 <Draconx> ciaranm, well, that's only necessarily true if the proof is done within ZF.
15:00:17 <jtannenbaum> is there an easy way to time an expression's evaluation (I guess, a show) in ghci/haskell?
15:00:19 <ddarius> Inconsistency of something like Peano arithmetic would be significant.  Inconsistency of ZF would also be significant but mostly in an "intellectual" way, less so practically.
15:01:17 <ddarius> In all likelihood we'd just patch ZF up and not much would change.
15:01:35 <ddarius> There's clearly a sense in which a lot of math is "right."
15:01:58 <EvanR-work> ddarius: heh, is that like were clearly conscious/self aware? ;0
15:02:02 <ciaranm> that sense is that we haven't figured out why it's wrong yet
15:02:18 <ciaranm> EvanR-work: i'm sorry, you appear to be assuming some connection between maths and reality
15:02:32 <ddarius> ciaranm: No, that sense is that it helps us predict physical phenomena.
15:02:35 <EvanR-work> no
15:03:01 <EvanR-work> ciaranm: you appear to be drawing a connection between consciousness and reality ;)-
15:03:06 <homie`> math evolves according to the widings ones brain has ?
15:03:14 <homie`> lol
15:03:42 <ciaranm> EvanR-work: the existence or lack thereof of reality has no bearing upon maths!
15:03:53 <ddarius> ciaranm: Sure it does.
15:04:00 <homie`> lol
15:04:20 <homie`> box open.......
15:04:24 <EvanR-work> we wouldnt be as interested in probability if it wasnt for real casino games!
15:05:03 <ciaranm> the fact that the universe happens to appear at a glance to be playing by a similar set of rules to mathematicians is merely a convenient coincidence for physicists
15:05:34 <ciaranm> i'm with plato! (but not when it comes to little boys.)
15:06:19 <homie`> was aristo better ?
15:06:44 <ciaranm> aristotle was wrong because aliens think 2 + 2 = 4
15:07:11 <homie`> and that's obviously wrong......
15:07:15 <ddarius> Aliens think 2 + 2 = 4 because it reflects an aspect of reality.
15:07:40 <homie`> macro reality!
15:07:43 <ciaranm> 2 + 2 = 4 would still hold even if there wasn't a universe
15:07:46 <homie`> lol
15:07:47 <EvanR-work> ciaranm: i reserve the right to change this remark later, but with math on the brain, you see things that may not really be there, in the end whats the difference
15:08:19 <homie`> 1/2 + 1/2 = 2
15:08:40 <ciaranm> 2 + 2 = 4 probably doesn't have any real world examples
15:10:47 <homie`> even bee tree math tells it....
15:10:50 <homie`> lol
15:14:12 <EvanR-work> ciaranm: i really hate 2+2=4 as the universal objective 'truth' of math
15:14:29 <dtrebbien> @type fromMaybe
15:14:30 <lambdabot> forall a. a -> Maybe a -> a
15:14:38 <Cale> Platonism is to mathematical philosophy what theism is to ontology
15:15:51 <homie`> 1/2 parens + 1/2 parens = 2 people.....but 1 pair
15:16:24 <homie`> 1 parent = 1/2 parens
15:17:49 <homie`> lol
15:18:34 <Cale> Theists like to thank gods for the hard work of scientists, and platonists like to thank a mysterious imaginary world for the hard work done by mathematicians.
15:23:05 <ddarius> Thank Icosahedron!
15:23:12 <monochrom> thank cales
15:23:40 <monochrom> thank parametricity
15:23:52 <hpc> i pity the mathematicians that worship russell's paradox
15:24:04 <monochrom> thank barber!
15:24:10 <homie`> lol
15:24:35 <ciaranm> isn't the resolution that the barber is a woman?
15:27:27 <monochrom> or the barber is God :)
15:27:47 <kmc> by vectron's beard!
15:27:56 <ciaranm> or that the village is empty, possibly
15:34:30 <c_wraith> ack.
15:36:12 <dmwit> ack . is a dangerous command
15:36:23 <dmwit> damn near every file matches the "." pattern
15:37:40 <c_wraith> I've just tripped over the lack of restricted functors
15:38:01 <c_wraith> making this a dead end...
15:38:47 <coppro> 1/win 4
15:41:48 <c_wraith> bah.  Totally failing to make these type signatures sane in the docs.
15:42:17 <c_wraith> Everything I can think of to try to mask the complication ends up breaking my Functor instances, one way or another.
15:42:29 <mekeor> what does "Num (a -> b) => ..." mean? e.g in :t (0 $)
15:42:40 <mekeor> :t (0 $)
15:42:41 <lambdabot> forall a b. (Num b) => a -> b
15:42:43 <c_wraith> mekeor: it means you're treating a function as a number
15:42:57 <c_wraith> err, a number as a function
15:43:11 <kmc> lambdabot has some weird instances in scope
15:43:40 <kmc> mekeor, do you know how numeric literals are overloaded?
15:43:51 <mekeor> huh?
15:44:04 <kmc> :t 0
15:44:05 <lambdabot> forall t. (Num t) => t
15:44:13 <mekeor> kmc: oh, no, i dont.
15:44:17 <kmc> the way this works is, 0 is syntactic sugar for (fromIntegral (0 :: Integer))
15:44:26 <c_wraith> you don't even need lambdabot's instances to get that result, actually.
15:44:34 <kmc> actually sorry it's (fromInteger (0 :: Integer))
15:44:36 <kmc> :t fromInteger
15:44:37 <lambdabot> forall a. (Num a) => Integer -> a
15:45:02 <kmc> :t fromInteger (0 :: Integer)
15:45:04 <lambdabot> forall a. (Num a) => a
15:45:06 <hpc> kmc: or more confusingly, fromInteger 0
15:45:20 <hpc> > fix fromInteger
15:45:23 <lambdabot>   mueval-core: Time limit exceeded
15:45:59 <alistra> :t (\f x -> x (f x))
15:46:00 <lambdabot> forall t t1. ((t -> t1) -> t) -> (t -> t1) -> t1
15:46:33 <alistra> :t let f x = x (f x)
15:46:34 <lambdabot> <no location info>: not an expression: `let f x = x (f x)'
15:46:49 <alistra> :t let f x = x (f x) in f (1:)
15:46:50 <lambdabot> forall t. (Num t) => [t]
15:47:04 <alistra> :e let f x = x (f x) in f (1:)
15:47:37 <hpc> > let f x = x (f x) in f (1:)
15:47:38 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:47:49 <alistra> oh
15:48:14 <alistra> > (\x -> x x) (\x -> x x)
15:48:15 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
15:48:25 <alistra> damn you typed lambda calculus!
15:48:54 <kirindave> Man every time I try to read this functional pretty printer paper
15:49:07 <kirindave> I get hung up on the circular let binding. :\
15:49:20 <kirindave> How can a result be computed with its own result. *tears hair out*
15:49:23 <hpc> kirindave: recursion can be tricky that way
15:49:31 <alistra> > readFile "/etc/passwd" >>= print
15:49:32 <EvanR> kirindave: magic
15:49:32 <lambdabot>   <IO ()>
15:49:44 <monochrom> x = f x  is tenable if f is non-strict
15:49:52 <Iceland_jack> Hey, fairly new to Haskell: what's the best way of, given two+ lists of numbers, returning a list of equal length where each element is the sum of the elements in equal position in their respective lists ——— Something like: map (MAGIC) [1,2,3] [10,20,30] expecting ⇒ [11,22,33]
15:49:52 <kirindave> EvanR: The correct term is "The Arts Diabolical"
15:50:00 <monochrom> for example I'm sure you have no problem with x = 0:x
15:50:00 <hpc> what gets me is when someone writes a function with a 20-line where clause, with all of the functions being mutually recursive AND closing over function parameters
15:50:06 <hpc> making it a huge pain to refactor
15:50:06 <alistra> > performUnsafeIO $ readFile "/etc/passwd"
15:50:07 <lambdabot>   Not in scope: `performUnsafeIO'
15:50:10 <kirindave> Yes but this is not so simple a case
15:50:23 <Cale> Iceland_jack: zipWith (+)
15:50:33 <Cale> > zipWith (+) [1,2,3] [10,20,30]
15:50:34 <lambdabot>   [11,22,33]
15:50:39 <Iceland_jack> Cale: Clear and concise. Thank you
15:50:39 <kirindave> it's like let a@(b1,_,_) = ... including b1 ... in a
15:50:43 <alistra> > unsafePerformIO $ readFile "/etc/passwd"
15:50:44 <lambdabot>   Not in scope: `unsafePerformIO'
15:50:51 <kirindave> I understand it doesn't blow up immediately.
15:50:59 <Cale> Iceland_jack: If you have a list of lists instead, you could use map sum . transpose
15:51:05 <kirindave> What I don't understand is how it can ever be unraveled.
15:51:22 <Cale> > map sum . transpose $ [[1,2,3],[10,20,30],[100,200,300]]
15:51:24 <lambdabot>   [111,222,333]
15:51:41 <hpc> > transpose [[1,2,3],[10,20,30],[100,200,300]]
15:51:42 <lambdabot>   [[1,10,100],[2,20,200],[3,30,300]]
15:51:45 <monochrom> you can try hand-calculating (including ⊥) and see that it produces something useful
15:51:55 <tsousa> what is the problem here http://dpaste.com/642912/ ?
15:51:55 <alistra> >  readFile "/etc/passwd"
15:51:57 <lambdabot>   <IO [Char]>
15:52:06 <Iceland_jack> Cale: Great help! :)
15:52:17 <hpc> alistra: you're never going to get lambdabot to perform IO
15:52:24 <alistra> hpc :|
15:52:24 <hpc> not through mueval anyway
15:53:00 <hpc> all it does is call 'show' on the value you give it
15:53:19 <alistra> hmmm
15:53:23 <monochrom> what is xs[n] supposed to mean?
15:53:46 <monochrom> [xs !! n]
15:53:54 <tsousa> monochrom, retrive the element in the list xs in the n position
15:54:32 <monochrom> must it be a list? why not Int -> [a] -> (a,[a]), (xs !! n, take n xs ++ drop (n+1) xs)
15:55:08 <monochrom> seems counterproductive to say "I'm going to answer you with a list but it has exactly 1 item guaranteed!"
15:55:52 <tsousa> monochrom, it needs to be a caracter. i am doing the problem 20 in http://www.haskell.org/haskellwiki/99_questions/11_to_20
15:56:10 <monochrom> a character is still not a list
15:56:45 <alistra> > show
15:56:47 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Base.String)
15:56:47 <lambdabot>    arising f...
15:56:49 <tsousa> monochrom, so how can i improve it?
15:57:01 <alistra> > show 5
15:57:02 <lambdabot>   "5"
15:57:06 <alistra> > map
15:57:07 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> [a] -> [b])
15:57:07 <lambdabot>    arising...
15:57:21 <monochrom> exactly what I said.
15:57:55 <monochrom> @let rA n xs = (xs !! n, take n xs ++ drop (n+1) xs)
15:57:56 <lambdabot>  Defined.
15:58:03 <monochrom> > rA 1 "abcd"
15:58:05 <lambdabot>   ('b',"acd")
15:58:18 <monochrom> exactly what the example demands
15:58:22 <alistra> > instance Show ((a -> b) -> [a] -> [b]) where show _ = unsafePerformIO $ readFile "/etc/passwd"; show
15:58:24 <lambdabot>   <no location info>: parse error on input `instance'
15:58:26 <mauke> > splitAt 1 "abcd"
15:58:27 <lambdabot>   ("a","bcd")
15:58:50 <alistra> some day lambdabot!
15:59:14 <mauke> > let foo n (splitAt n -> (a, x : z)) = (x, a ++ z) in foo 1 "abcd"
15:59:15 <lambdabot>   ('b',"acd")
15:59:46 <alistra> > :m Control.Monad
15:59:47 <lambdabot>   <no location info>: parse error on input `:'
15:59:57 <tsousa> monochrom, yeh that solved thanks
16:00:16 <coppro> is iterate f x !! n the idiomatic way to apply f n times to x?
16:00:16 <alistra> > </>
16:00:18 <lambdabot>   <no location info>: parse error on input `</>'
16:00:59 <Happy0> so err... what happens if you give the bot something that would result in it flooding the channel? :P
16:01:13 <mauke> > [0 ..]
16:01:14 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:01:17 <Happy0> yes, like that =p
16:01:19 <Happy0> haha, nice
16:01:32 <c_wraith> > map (text . show) [1..]
16:01:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:01:38 <Happy0> xD
16:01:43 <Happy0> impressive
16:01:46 <alistra> [9999999999999999999999..]
16:01:47 <c_wraith> oh, right
16:01:51 <alistra> >[9999999999999999999999..]
16:01:54 <alistra> > [9999999999999999999999..]
16:01:55 <lambdabot>   [9999999999999999999999,10000000000000000000000,10000000000000000000001,100...
16:01:57 <Happy0> haha, oh dear...
16:01:58 <mauke> Happy0: it's just take 123 (show ...)
16:02:02 <mauke> and lazy evaluation
16:02:12 <alistra> ugh
16:02:17 <c_wraith> > text $ intercalate "\n" $ cycle "foo"
16:02:18 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:02:19 <lambdabot>         against inferred ty...
16:02:22 <Happy0> mauke: i'll have to google 'take', but thanks :)
16:02:24 <c_wraith> > text $ intercalate '\n' $ cycle "foo"
16:02:26 <lambdabot>   Couldn't match expected type `[a]'
16:02:26 <lambdabot>         against inferred type `GHC.Types...
16:02:26 <alistra> > undefined
16:02:27 <lambdabot>   *Exception: Prelude.undefined
16:02:32 <mauke> Happy0: use hoogle, not google
16:02:33 <Happy0> :m take
16:02:42 <mauke> but you can google hoogle
16:02:42 <Happy0> mauke: good point =p
16:02:44 <Happy0> will do xD
16:02:50 <alistra> > undefined `catch` (\e -> print "yo")
16:02:52 <lambdabot>   <IO ()>
16:02:53 <Happy0> one of my lecturers mentioned hoogle the other day
16:04:06 <c_wraith> hmm.  Constraint kinds would solve this documentation issue
16:04:38 <alistra> > let f x = f (x-1) in f (100)
16:04:56 <lambdabot>   thread killed
16:04:59 <Happy0> hahahaha
16:05:02 <alistra> damn you
16:05:17 <mauke> > fix error
16:05:20 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:05:31 <alistra> > let f x = do { forkIO (f x); return () }
16:05:32 <lambdabot>   not an expression: `let f x = do { forkIO (f x); return () }'
16:05:36 <Happy0> ohhhh dear
16:05:39 <alistra> > let f x = do { forkIO (f x); return () } in f 0
16:05:40 <lambdabot>   Not in scope: `forkIO'
16:05:46 <Happy0> xD
16:05:55 <alistra> > let f x = do { fix (f x); return () } in f 0
16:05:56 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> a
16:06:22 <alistra> it's hard without the imports
16:07:12 <Happy0> i'm admiring your attempts, though =p
16:07:25 <mauke> it's all been done before
16:07:49 <Happy0> ha
16:08:03 <mauke> @yhjulwwiefzojcbxybbruweejw
16:08:03 <lambdabot> "\"#$%&'()*+,\""
16:08:13 <mauke> @yhjulwwiefzojcbxybbruweejw
16:08:13 <lambdabot> "\""
16:08:31 <hpc> what the hell?
16:08:35 <brisingr> @awghwiuhaiwuh
16:08:35 <lambdabot> Unknown command, try @list
16:08:38 <brisingr> @awghwiuhaiwuhaweugahwiufhwjfh
16:08:38 <lambdabot> Unknown command, try @list
16:08:40 <alistra> @list
16:08:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:08:41 <brisingr> hmm
16:08:41 <hpc> @yhjulwwiefzojcbxybbruweejw
16:08:41 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
16:08:43 <hpc> @yhjulwwiefzojcbxybbruweejw
16:08:43 <lambdabot> "\"#$%&'()*+,\""
16:08:45 <hpc> @yhjulwwiefzojcbxybbruweejw
16:08:45 <lambdabot> Exception: <<loop>>
16:08:47 <hpc> what
16:09:01 <brisingr> @yhjulwwiefzojcbxybbruweejw
16:09:01 <lambdabot> Just 'J'
16:09:03 <brisingr> @yhjulwwiefzojcbxybbruweejw
16:09:03 <lambdabot> "\""
16:09:04 <brisingr> @yhjulwwiefzojcbxybbruweejw
16:09:04 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:09:06 <brisingr> @yhjulwwiefzojcbxybbruweejw
16:09:06 <lambdabot> "\""
16:09:08 <marienz> erm?
16:09:12 <brisingr> @yhjulwwiefzojcbxybbruweejw
16:09:12 <lambdabot> "\""
16:09:22 <marienz> is everything ok in here?
16:09:25 <hpc> is that some kind of history?
16:09:47 <mauke> @help yhjulwwiefzojcbxybbruweejw
16:09:47 <lambdabot> V RETURNS!
16:09:55 <alistra> > ioError
16:09:56 <lambdabot>   Overlapping instances for GHC.Show.Show
16:09:56 <lambdabot>                              (GHC.I...
16:10:03 <mauke> @help v
16:10:03 <lambdabot> let v = show v in v
16:10:11 <brisingr> if by ok you mean not okay then maybe
16:10:24 <hpc> @v
16:10:24 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:10:39 <brisingr> @v
16:10:39 <lambdabot> "\""
16:10:39 <hpc> who writes these things?
16:10:41 <brisingr> @v as
16:10:41 <lambdabot> "\"#$%&'()*+,\""
16:10:43 <brisingr> @v asasd
16:10:44 <lambdabot> Exception: <<loop>>
16:10:45 <brisingr> @v asasdff
16:10:45 <lambdabot> "\""
16:10:47 <brisingr> @v asasdffffff
16:10:47 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:10:49 <brisingr> what
16:10:52 <brisingr> this is confusing
16:10:57 <mauke> > let v = show v in v
16:10:57 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:11:04 <mauke> > let v = show (Just v) in v
16:11:05 <lambdabot>   "Just \"Just \\\"Just \\\\\\\"Just \\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\...
16:11:18 <mauke> > let v = show (head v) in v
16:11:21 <lambdabot>   mueval-core: Time limit exceeded
16:11:44 <mauke> > let v = show (take 1 v) in v
16:11:45 <lambdabot>   "\"\\\"\""
16:12:03 <mauke> > let v = show (Just (head v)) in v
16:12:04 <lambdabot>   "Just 'J'"
16:14:59 <alistra> > "a"
16:15:01 <lambdabot>   "a"
16:16:47 <alistra> > id $! readFile "/etc/passwd"
16:16:49 <lambdabot>   <IO [Char]>
16:17:08 <alistra> > id $! writeFile "ass"  "/etc/passwd"
16:17:09 <lambdabot>   <IO ()>
16:17:26 <Twey> Heh
16:17:31 <Twey> That's not how Haskell works…
16:17:38 <DukeDave> Here's one: I have a list of binary argument: [(+), (*)], and I would like a function which takes two Nums and returns the list of them applied to the list of binary functions :O
16:18:02 <DukeDave> But:
16:18:02 <DukeDave> :t  \x y -> Data.List.map ($x $y) [(+), (*)]
16:18:03 <mauke> alistra: adding id or $! doesn't change anything
16:18:05 <lambdabot> forall a b. (Num b) => (a -> b) -> a -> [b -> b]
16:18:21 <alistra> DukeDave: you apply functions to the args
16:18:33 <mauke> DukeDave: (\f -> f x y)
16:18:51 <Twey> DukeDave: That's not really going to work
16:18:53 <alistra> :t map2
16:18:54 <lambdabot> Not in scope: `map2'
16:18:58 <alistra> hmm
16:19:00 <alistra> @hoogle map2
16:19:01 <lambdabot> No results found
16:19:02 <DukeDave> Oh yes! A lambda
16:19:04 <DukeDave> #tired
16:19:08 <Twey> DukeDave: If you apply one (say (+)) to the two arguments, you'll only get one argument back
16:19:10 <DukeDave> Thanks :)
16:19:23 <Twey> DukeDave: & then you need to apply (*) to two arguments, but you have only one
16:19:29 <Twey> Where do you want to get the other argument?
16:19:53 <alistra> > mapM Just [1,2,3]
16:19:54 <lambdabot>   Just [1,2,3]
16:20:02 <Botje> @pl \f -> f x y
16:20:03 <lambdabot> flip ($ x) y
16:20:12 <alistra> @list
16:20:13 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:20:45 <alistra> pointfree is pointless
16:20:47 <Botje> :t let (x,y) = (1,2) in ($ x) . ($ y)
16:20:47 <alistra> :|
16:20:48 <lambdabot> forall a b a1. (Num a, Num a1) => (a1 -> a -> b) -> b
16:21:16 <alistra> > fmap Just [1,2,3]
16:21:17 <lambdabot>   [Just 1,Just 2,Just 3]
16:21:21 <DukeDave> Twey: I'm not sure I follow you, mauke gave the answer I needed..
16:21:27 <alistra> > mapM_ print [1,2,3]
16:21:28 <lambdabot>   <IO ()>
16:21:46 <Twey> DukeDave: Perhaps I just misinterpreted you
16:22:00 <Twey> Ohh.  I did.
16:22:14 <Twey> … no, I didn't.
16:22:40 <Twey> You have a list like [(+), (*)], and you want to thread two arguments through each function, right?
16:22:44 <Twey> Call them a and b
16:22:48 <DukeDave> Twey: Correct
16:22:49 <mauke> Twey: no
16:22:53 <Twey> So you thread a and b through (+) and…
16:22:57 <Twey> > a + b
16:22:59 <lambdabot>   a + b
16:23:05 <Twey> Now you have only one argument
16:23:12 <mauke> Twey: no, one result
16:23:12 <Twey> Where does the second argument to (*) come from?
16:23:16 <alistra> > a + v * c
16:23:17 <lambdabot>   a + v * c
16:23:20 <alistra> what
16:23:26 <Twey> mauke: One result which is intended to be the argument to (*)
16:23:27 <DukeDave> Oh, Twey: No, I'm mapping, not folding..
16:23:31 <alistra> :t a + v * c
16:23:33 <Twey> Ah, right
16:23:33 <lambdabot> Expr
16:23:36 <DukeDave> ;)
16:23:43 <hpc> > [a + b, a * b] -- DukeDave: this?
16:23:44 <lambdabot>   [a + b,a * b]
16:23:53 <Twey> Ah, yeah.  Okay.
16:24:01 <hpc> > [(+), (*)] <*> pure a <*> pure b
16:24:01 <lambdabot>   [a + b,a * b]
16:24:02 <DukeDave> hpc: Yeah, it reads nicely using a lambda (which didn't occur to me)
16:24:15 <DukeDave> Ooh, that's sexy too
16:24:23 * DukeDave was trying to force it using ($)
16:24:26 <hpc> applicative style is bitchin
16:24:26 <mauke> that's just two maps
16:24:52 <Twey> > (\x y -> map (($ (x, y) . uncurry) [(*), (+)]) 3 5
16:24:53 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:24:54 <mauke> :t \x y -> map ($ y) (map ($ x) [(+), (*)])
16:24:55 <lambdabot> forall a. (Num a) => a -> a -> [a]
16:24:56 <hpc> > map ($ b) . map ($ a) $ [(+), (*)]
16:25:01 <lambdabot>   mueval-core: Time limit exceeded
16:25:08 <hpc> > map ($ b) . map ($ a) $ [(+), (*)]
16:25:09 <Twey> > (\x y -> map (($ (x, y)) . uncurry) [(*), (+)]) 3 5
16:25:12 <lambdabot>   mueval-core: Time limit exceeded
16:25:13 <lambdabot>   [15,8]
16:25:16 <hpc> ...seriously?
16:25:28 <Twey> hpc: Haha >.<
16:25:34 <hpc> > map ($ b) . map ($ a) $ [(+), (*)]
16:25:35 <lambdabot>   [a + b,a * b]
16:25:48 <Twey> > (\x y -> map (($ y) . ($ x)) [(*), (+)]) 3 5
16:25:50 <lambdabot>   [15,8]
16:25:54 <Twey> She likes me.
16:26:17 <alistra> she?
16:26:55 <mauke> hmm. how many male bots are there?
16:27:11 <hpc> mauke: the one i maintain is male
16:27:14 <alistra> > getContents
16:27:15 <lambdabot>   <IO [Char]>
16:27:17 <brisingr> how does @free work?
16:27:21 <hpc> (my nick is Spock on another network; my bot's is Daa)
16:27:24 <hpc> *Data
16:27:35 <dmwit> brisingr: Look for Wadler's paper called "Theorems for Free!".
16:27:35 <Happy0> .players
16:27:43 <Happy0> oops, wrong channel
16:27:46 <dmwit> brisingr: (Exclamation point Wadler's, not mine. =)
16:28:01 <brisingr> thanks
16:28:04 <alistra> > seq (readFile "/etc/passwd") 5
16:28:04 <hpc> @free f :: (a -> b) -> [a] -> [b]
16:28:04 <lambdabot> h . k = p . g => $map h . f k = f p . $map g
16:28:05 <lambdabot>   5
16:28:13 <alistra> > seq (readFile "/etc/passwd" >>= print) 5
16:28:14 <lambdabot>   5
16:29:01 <alistra> > seq (readFile "/etc/passwd" >>= error) 5
16:29:03 <lambdabot>   5
16:29:13 <brisingr> who
16:29:14 <brisingr> a
16:29:16 <brisingr> nice
16:29:17 <mauke> alistra: you seem to be a bit unclear on the difference between evaluation and execution
16:29:18 <brisingr> free theorems
16:29:25 <brisingr> also, another premature carriage return
16:29:28 <brisingr> I'll go
16:29:33 <brisingr> thanks for the free theorems
16:29:53 <alistra> mauke: fill me in
16:30:06 <mauke> alistra: they're separate! \o/
16:30:26 <alistra> thanks, bro
16:30:40 <mauke> lambdabot does evaluation
16:30:47 <mauke> doing I/O requires execution
16:31:09 <mauke> evaluating an IO action has no side effects
16:31:29 <alistra> mauke: do you have a thing i can read about it?
16:31:29 <hpc> alistra: if it helps, evaluation is more analogous to compilation than running a program
16:31:39 <hpc> at least, in IO
16:31:43 <alistra> > x <- Just 5
16:31:43 <mauke> alistra: any haskell tutorial ever, I'd imagine
16:31:44 <lambdabot>   not an expression: `x <- Just 5'
16:31:46 <hpc> you evaluate an IO action, then you execute it
16:31:47 <Cale> evaluation means turning expressions into values
16:32:21 <mauke> you evaluate an expression, which may give you an IO action as a result
16:32:22 <Cale> execution means carrying out the effects described by an IO action value
16:32:30 <mauke> that IO action can then be executed (or not)(
16:33:17 <mauke> > length [putStr "hello", return (), getLine >>= print]
16:33:19 <lambdabot>   3
16:33:52 <mauke> > let bla = do { x <- getLine; print x } in length [bla, bla, bla]
16:33:53 <lambdabot>   3
16:34:35 <alistra> so evaluation = pure functions
16:34:39 <alistra> execution = io?
16:34:53 <hpc> alistra: pretty much
16:35:16 <alistra> so how is it done, that lambdabot doesn't execute
16:35:24 <mauke> er, it simply doesn't execute
16:35:40 <mauke> what do you mean by "how"?
16:35:49 <hpc> indeed; it evaluates 'show foo' for whatever foo you enter in
16:36:11 <alistra> my show $ print 5
16:36:15 <alistra> returns an error
16:36:35 <mauke> yes, you don't have an instance Show (IO a)
16:36:36 <alistra> does it have an instance Show IO a where show _ = "<IO>"
16:36:42 <mauke> yep
16:37:06 <alistra> can i instantiate a class in lambdabot?
16:37:28 <alistra> from the line :p
16:37:45 <hpc> alistra: nope; expressions only
16:38:12 <hpc> which restricts you to stuff like "let ... in ..." and "case ... of ..."
16:40:15 <monochrom> between "how does lambdabot achieves not executing" and "how does lisp achieves self-interpreting", I would say the latter is the marvelous one
16:40:17 * alistra wonders if on #php they can use eval()
16:40:18 * hackagebot MonadCatchIO-transformers 0.2.2.3 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.2.2.3 (AriePeterson)
16:41:12 <alistra> in their phpbot
16:44:02 <alistra> > :help
16:44:03 <lambdabot>   <no location info>: parse error on input `:'
16:44:38 <alistra> > callCC 5
16:44:39 <lambdabot>   No instance for (GHC.Num.Num (m a))
16:44:40 <lambdabot>    arising from a use of `e_15' at <int...
16:44:50 <alistra> yo, callCC
16:46:14 <alistra> uh i won't go out of the show :/
16:46:38 <alistra> > callCC $ \k -> do { k 5; return 8}
16:46:39 <lambdabot>   No instance for (GHC.Show.Show (m a))
16:46:39 <lambdabot>    arising from a use of `M4196966214...
16:47:42 <alistra> > callCC $ \k ->  k 5
16:47:43 <lambdabot>   No instance for (GHC.Show.Show (m b))
16:47:43 <lambdabot>    arising from a use of `M1237584758...
16:47:50 <monochrom> runCont (callCC (\k -> k True >> return False)) id
16:47:53 <monochrom> > runCont (callCC (\k -> k True >> return False)) id
16:47:54 <lambdabot>   True
16:49:13 <alistra> uh my continations are a bit rusty
16:49:29 <kmc> nobody wants a rusty continuation
16:50:52 <stribor> can anyuone provide little example of evaluating readsPrec from ghci
16:51:08 <alistra> > runCont (callCC (\k -> k True >> return False)) not
16:51:10 <lambdabot>   False
16:51:31 * monochrom grins
16:51:54 <kmc> > readsPrec 0 "3" :: [(Int, String)]
16:51:55 <lambdabot>   [(3,"")]
16:52:56 <stribor> kmc: but type of that function just says it takes Int as parametar
16:53:04 <kmc> uh?
16:53:06 <kmc> :t readsPrec
16:53:08 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
16:53:13 <kmc> the Int is the precedence level, I gave 0
16:53:16 <kmc> the string is "3"
16:53:30 <stribor> precedence level?
16:53:32 <kmc> the result has type [(Int, String)]; it returns a list of possible parses for that string, each with a parsed Int and a remaining string
16:53:33 <kmc> stribor, yes
16:53:41 <kmc> why are you trying to use readsPrec yourself?
16:53:48 <kmc> user code typically uses read or reads
16:53:57 <kmc> readsPrec is mostly used by GHC-generated instances of Read
16:53:57 <stribor> just want to know what it does
16:54:00 <kmc> ok
16:54:00 <stribor> curious i guess
16:54:04 <stribor> what is precedence
16:54:05 <kmc> well the docs should explain about precedence levels
16:54:29 <kmc> stribor, like operator precedence, you have to parse "2 + 3 * 4" as 2 + (3 * 4) and not (2 + 3) * 4
16:54:44 <stribor> kmc: ok
16:55:24 <kmc> you can find in the Report a description of the generated Read instances, including those for infix operators
16:55:28 <dylex> > readsPrec 10 "Just 5+2" :: [(Maybe Int, String)]
16:55:28 <lambdabot>   [(Just 5,"+2")]
16:55:32 <dylex> > readsPrec 20 "Just 5+2" :: [(Maybe Int, String)]
16:55:33 <lambdabot>   []
16:55:43 <dylex> > readsPrec 20 "(Just 5)+2" :: [(Maybe Int, String)]
16:55:44 <lambdabot>   [(Just 5,"+2")]
16:56:30 <stribor> kmc: can you give examplke of "reads" function
16:56:50 <kmc> > reads "3" :: [(Int, String)]
16:56:52 <lambdabot>   [(3,"")]
16:56:52 <kmc> @src reads
16:56:53 <lambdabot> reads = readsPrec minPrec
16:56:56 <kmc> > minPrec
16:56:58 <lambdabot>   Not in scope: `minPrec'
16:57:03 <kmc> hmm not in scope but i guess it's 0?
16:57:08 <alistra> @src print
16:57:09 <lambdabot> print x = putStrLn (show x)
16:57:15 <alistra> @src putStrLn
16:57:16 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
16:57:20 <alistra> @src putStr
16:57:21 <lambdabot> putStr s  = hPutStr stdout s
16:57:27 <alistra> @src hputStr
16:57:27 <lambdabot> Source not found. Sorry.
16:57:31 <alistra> :|
16:57:44 <alistra> cocktease
16:58:08 <mauke> @src hPutStr
16:58:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:58:12 <mauke> aww
16:58:23 <alistra> what
16:58:29 <Happy0> lmao
16:58:29 <alistra> @src bitch you just didn't
16:58:30 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:58:35 <shapr> Hey, watch the language.
16:58:49 <mauke> alistra: hPutStr = mapM_ . hPutChar
16:59:01 <alistra> @src hPutChar
16:59:02 <lambdabot> Source not found. Wrong!  You cheating scum!
16:59:11 <byorgey> at some point the implementations become magical and compiler-specific.
16:59:15 <alistra> he can insult me, and i can't unsult him?
16:59:39 <mauke> @nixon
16:59:39 <lambdabot> Certainly in the next 50 years we shall see a woman president, perhaps sooner than you think. A woman can and should be able to do any political job that a man can do.
17:00:01 <alistra> @futurama
17:00:02 <lambdabot> Unknown command, try @list
17:00:08 <kmc> aww nixon, so dedicated to gender equality
17:00:08 <alistra> uh
17:00:16 <kmc> "women can be just as amoral and sociopathic as i am!"
17:00:16 <alistra> @nixon
17:00:17 <lambdabot> Politics would be a helluva good business if it weren't for the goddamned people.
17:00:50 <mauke> alistra: did you mean: futamura
17:01:02 <alistra> i meant futanari
17:01:15 <alistra> @wiki futanari
17:01:15 <lambdabot> http://www.haskell.org/haskellwiki/futanari
17:01:18 <mauke> that's somewhat less on-topic
17:01:31 <shapr> alistra: dude, srsly
17:01:37 <mauke> http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html
17:01:45 <alistra> shapr: what?
17:02:03 <shapr> alistra: That's srsly off-topic.
17:02:33 <shapr> alistra: The rules here are, "Be Nice. Or else."
17:03:15 <alistra> shapr: what's not nice about what i've said, i haven't insulted anyone
17:03:19 <hpc> doctor futurama!
17:03:55 <shapr> alistra: Some topics are very off-topic on #haskell
17:04:09 <shapr> alistra: Sex is definitely one of those topics.
17:04:22 <alistra> it was a pun-joke
17:04:27 <shapr> alistra: On the other hand, that's very much on-topic in #haskell-blaha
17:04:27 <alistra> not a topic
17:04:35 <shapr> er, #haskell-blah
17:22:06 <shapr> OCCUPY #HASKELL!
17:22:46 <shapr> So, anyone using Hakyll lately?
17:22:52 <shapr> jfredett: O HAI
17:22:54 <shapr> any code?
17:23:55 <shapr> cscorley: Ever written any Haskell?
17:26:39 * shapr snores quietly
17:27:30 <byorgey> shapr: oddly enough, I was just trying to cabal install hakyll
17:27:34 <shapr> Yay!
17:27:45 <byorgey> doesn't build on ghc 7.2.1 currently =(
17:27:53 <byorgey> but I've used it in the pats and think it's great
17:27:56 <byorgey> *past
17:28:06 * byorgey -> dinner
17:29:48 <Sgeo|web> Is reading the code for mtl a good way to learn about monad transformers?
17:30:05 <parcs> sure
17:30:18 <parcs> actually read the source of 'transformers'
17:30:26 <monochrom> #haskell holds 99% of programmer talents? :)
17:30:32 <shapr> Sgeo|web: http://book.realworldhaskell.org/read/monad-transformers.html ?
17:30:55 <parcs> mtl just categorizes transformers
17:31:00 <parcs> transformers defines them
17:33:26 <Sgeo|web> So look at both?
17:34:42 <kmc> just look at 'transformers'
17:34:57 <kmc> mtl (and monads-fd and monads-tf) define some generic typeclass interfaces on top of those
17:35:16 <Sgeo|web> Why does this code talk about callCC?
17:35:20 <kmc> so that you can use 'get' with either StateT s  or ReaderT r (StateT s)
17:35:22 <Sgeo|web> Is it possible to use callCC without cont?
17:35:22 <kmc> which code?
17:35:29 <shapr> Sgeo|web: Cthulhu lives in callCC land. Watch out.
17:35:36 <Sgeo|web> http://hackage.haskell.org/packages/archive/transformers/0.1.4.0/doc/html/src/Control-Monad-Trans-Maybe.html
17:35:40 <cscorley> shapr: nope, virgin
17:36:06 <kmc> Sgeo|web, interesting, I hadn't seen that
17:36:11 <kmc> it lifts anything with callCC's type
17:36:19 <Sgeo|web> The thing with Real World Haskell is that it seems to require reading the prior chapters
17:36:23 <kmc> note that callCC is a function argument there; it does not presuppose its existence
17:38:45 <shapr> cscorley: Well, when you have some free time, I'll totally give you the #haskell intro
17:38:54 <shapr> It's been a long time since I've done a #haskell intro
17:39:09 <shapr> I should go read up in the archives how I used to do that...
17:45:00 <cscorley> hah. alright. lets plan for end of semester then
17:59:46 <monochrom> #haskell intro? has to look up how to do it? is it some kind of elaborate ceremony with so many pedantic details you can't possibly memorize?
18:00:22 <monochrom> almost like how to crown a king/queen? :)
18:01:34 <mauke> set up a crownjob
18:01:42 <monochrom> haha
18:54:02 <mike-burns> OK let's get some Aeson up in here on a Friday night!
18:54:04 <mike-burns> http://pastebin.com/z5rjEZNJ
18:54:07 <mauke> The paste z5rjEZNJ has been copied to http://hpaste.org/53266
18:54:12 <mike-burns> Oh, thank you.
18:54:30 <mike-burns> I have the above-pasted data types, JSON, and desired output.
18:54:40 <mike-burns> And I have no idea how to write parseJSON for this.
18:55:38 <mike-burns> http://hpaste.org/53267 - here's what I've tried.
18:56:28 <mike-burns> But I keep getting either mzero or "when expecting a [a], encountered Object instead", depending on what I do in the code.
18:58:26 <mike-burns> And obviously I'm going to refactor this out of IO once I get it working.
20:31:42 <shapr> QUIET!
20:31:48 <shapr> You guys are being TOO LOUD!
20:31:56 <shapr> SHADDUP!
20:32:16 --- mode: ChanServ set +o shapr
20:32:22 --- kick: shapr was kicked by shapr (BEAT IT! TOO LOUD!)
20:42:26 <jtannenbaum> heh, $ is the same as `id`, isn't it
20:42:59 <kmc> with a restricted type yes
20:43:03 <jtannenbaum> well, more explicitly defined-yea
20:43:07 <kmc> (and possibly different fixity?)
20:43:25 <shachaf> ($) x | x == True = x | otherwise = False
21:17:34 <augur> i just want you all to know
21:17:36 <augur> i love haskell
21:18:19 <lambdabot> augur: we love you too
21:18:26 <augur> hahaha
21:18:36 <augur> Cale: did you make lambdabot do that? :)
21:30:56 <parcs> one time i was eval'ing stuff privately with lambdabot and she replied with ":)" out of nowhere
21:43:09 <mauke> @bot
21:43:09 <lambdabot> :)
21:47:46 <parcs> no
21:47:51 <parcs> it was unprovoked
21:49:59 <mmos1127> How do I read and write 16-bit unsigned shorts (or maybe signed shorts) from/to a binary file which is just a sequence of them? I'm reading an existing file format, not sure of byte order but I have to conform to it.
21:57:40 <parcs> mmos1127: see 'Data.Binary.Put' in the 'binary' package
21:57:59 <mauke> pseq x y = seq x id y
21:58:02 <mauke> discus.
21:58:23 <mmos1127> Oh, looking for tutorials online, I just found one with Data.Binary. Thanks.
22:00:14 <Veinor> mauke: how is this different from seq?
22:00:37 <parcs> > seq (error "x") id (error "y")
22:00:38 <lambdabot>   *Exception: x
22:00:45 <parcs> > seq (error "x") (error "y")
22:00:46 <lambdabot>   *Exception: x
22:02:47 <Veinor> i have a 500kb corpus or so of posts. what's a reasonable way to search over this?
22:03:18 <mauke> grep
22:03:38 <Veinor> :P
22:05:27 <Veinor> i've considered just storing, for each post, a map of what words appear in it, and looking up in the maps.
22:05:30 <byorgey> 500k is not that big.  My journal.org file is 850k, and I keep it open in emacs and search through it all the time.
22:05:48 <Veinor> but yeah, i should probably actually test in-text searching first.
22:06:02 <Veinor> do i want Text or ByteString?
22:06:52 <shachaf> Veinor: If it's text, and you're not racist, you probably want Text.
22:07:08 <shachaf> Of course, Text is pretty evil for searching efficiently, so I hear.
22:07:09 <kmc> well, are the posts Unicode text or are they bytes?
22:07:14 <kmc> shachaf, it is?
22:07:22 <Veinor> i'm... fairly sure they're unicode text.
22:07:24 <shachaf> kmc: It uses UTF-16, which is variable-length.
22:07:36 <kmc> shachaf, sure, but you can normalize it and then use a byte search, no?
22:07:36 <Veinor> i think there might be one or two rogue unicode characters in there.
22:07:43 <kmc> they're all unicode characters
22:07:45 <mauke> shachaf: what's the problem with variable length?
22:07:56 <kmc> Veinor, I'd use a Map from Text, by default
22:07:56 <shachaf> Well, sure.
22:08:01 <shachaf> I suppose it's not such a big problem.
22:08:06 <Sgeo|web> Codepoint you're searching for would map into UTF-16, right?
22:08:10 <Sgeo|web> Erm, codepoints
22:08:11 <Veinor> the text hackage says getting a count is O(n*m), but that's an unlikely worst case. no average case.
22:08:16 <Sgeo|web> And then just search for those?
22:08:22 <Sgeo|web> o.O
22:08:33 <kmc> if it gets huge, you can share the keys using http://hackage.haskell.org/package/intern
22:08:39 <Veinor> kmc: i might! but then i lose expressiveness of search capability.
22:08:45 <kmc> ah yeah
22:08:55 <mauke> I'd probably use ByteString. because I'm hardcore.
22:08:56 <Veinor> i guess i should just try it and see
22:09:02 <kmc> there's also smallstring
22:09:05 <kmc> Sgeo|web, well for starters, a Unicode scalar value can map to either 2 or 4 bytes in UTF-16
22:09:19 <kmc> Sgeo|web, but also, there's not a unique way to represent a character as a sequence of scalar values
22:09:24 <Sgeo|web> kmc: but shouldn't the same scalar always map ... OH
22:09:33 <kmc> you'd have to normalize the strings
22:09:39 <kmc> which http://hackage.haskell.org/package/text-icu can do
22:09:44 <kmc> "When implementations keep strings in a normalized form, they can be assured that equivalent strings have a unique binary representation."
22:09:52 <kmc> but it's far from a trivial operation
22:10:03 <kmc> (it may be trivial to use this library, though)
22:12:48 <JoeyA> I have an action that reads bytes from a stream.  On failure, it leaves the stream in what I would call an "undefined" state, if I were programming in C.
22:13:17 <JoeyA> Since "undefined" typically refers to expressions that throw exceptions or cause infinite loops in Haskell, should I use a different word here?
22:14:00 <kmc> does it break the memory safety guarantees of the Haskell type system
22:14:05 <JoeyA> nope
22:14:16 <kmc> then i think "undefined" is fine
22:14:22 <kmc> maybe "unspecified" is better
22:14:25 <Veinor> apparently Text search is O(n+m) in the 'typical' case
22:14:28 <JoeyA> Though I suppose they are really the same concept: the value or state should not be used.
22:17:17 <tuv> what is the difference between function composition (f1 . f2) and just applying function successively?
22:17:31 <tuv> f1 (f2)
22:18:07 <tuv> what is the difference between function composition (f1 . f2) and just applying functions successively (f1 (f2))?
22:18:09 <mike-burns> Those have different types.
22:18:27 <kmc> (f . g) x  ≡  f (g x)
22:18:32 <mauke> tuv: f1 f2 calls f1, passing f2 as an argument
22:18:40 <mauke> tuv: it doesn't apply functions successively
22:18:46 <kmc> in C syntax, it's the difference between f(g) and f(g(x))
22:18:51 <kmc> (C/math syntax)
22:19:11 <JoeyA> Function composition is a monoid, whereas application is not.  In English: sticking a bunch of function applications together is easier with composition than with application.
22:19:23 <shachaf> In C syntax, "f x y" is f(x)(y)
22:19:29 <JoeyA> > ((+3) . (+7) . (*2)) 3
22:19:30 <shachaf> Well, I don't know if that's valid C syntax.
22:19:31 <lambdabot>   16
22:19:35 <shachaf> I guess it might as well be.
22:19:49 <JoeyA> > (+3) ((+7) ((*2) 3)))
22:19:50 <lambdabot>   <no location info>: parse error on input `)'
22:19:52 <JoeyA> > (+3) ((+7) ((*2) 3))
22:19:54 <lambdabot>   16
22:20:20 <JoeyA> :t (.)
22:20:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:20:38 <JoeyA> That's lambdabot's special definition of (.)
22:20:53 <JoeyA> (.) :: (b -> c) -> (a -> b) -> a -> c
22:21:59 <JoeyA> (.) takes two functions and returns a function that, when applied to a value, performs both.
22:22:10 <mauke> shachaf: f(x)(y) is valid C
22:22:29 <shachaf> mauke: Good.
22:22:36 * shachaf vaguely expected mauke to chime in there.
22:22:38 <JoeyA> Unfortunately, C doesn't have first-class functions.
22:22:38 <tuv> so f1 . f2 . f3 x = f1 (f2 (f3 x))
22:22:49 <kmc> you have the precedence wrong
22:22:56 <kmc> function application binds tighter than infix operators
22:23:01 <mauke> tuv: no, \y -> f1 (f2 ((f3 x) y))
22:23:03 <kmc> (f1 . f2 . f3) x = f1 (f2 (f3 x))
22:23:04 <mike-burns> (f1 . f2 . f3) x = f1 (f2 (f3 x))
22:23:08 <kmc> f1 . f2 . f3 $ x = f1 (f2 (f3 x))
22:24:00 <JoeyA> GCC has nested functions.  However, they do not support upward funargs.
22:25:02 <tuv> aha .. so (.) reduces two functions into one
22:25:06 <kmc> yes
22:25:09 <JoeyA> (an upward funarg is a value that persists after it has "gone out of scope", due to being bound to a closure that is still reachable)
22:25:14 <kmc> another way to write it is
22:25:20 <kmc> f . g = (\x -> (f (g x)))
22:25:24 <shachaf> JoeyA: What does that have to do with C syntax?
22:25:57 <kmc> you encounter things like f(x)(y) a lot in C
22:25:58 <JoeyA> shachaf: f(a)(b) is valid C, but isn't as useful as it is in Haskell.
22:26:15 <JoeyA> They're used for macros and functions returning callbacks.
22:26:21 <kmc> often as a result of someone explicitly building closure-like structs
22:26:58 <JoeyA> But you can't, for instance, compose two functions in C (without explicit context structures).
22:28:04 <kmc> maybe i should have said "Python syntax" instead of "C syntax"
22:28:09 <kmc> and then we would not need the whole digression :)
22:28:22 <shachaf> True.
22:28:32 <shachaf> Except that I'm the one who brought up f(x)(y)
22:30:19 <kmc> by the way, if your C code is running alongside a GHC RTS, you can use GHC to manage your C closures
22:30:46 <JoeyA> Has anyone used an idiom like this to define an action that is an infinite loop?  foo :: ... -> IO loop
22:30:59 <shachaf> @ty forever
22:31:00 <kmc> yeah
22:31:00 <JoeyA> (where loop is a dummy type variable that describes why the action does not return)
22:31:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
22:31:06 <kmc> but using an actual empty type is better
22:31:07 <shachaf> JoeyA: Like that?
22:31:16 <kmc> http://hackage.haskell.org/packages/archive/void/0.5.5/doc/html/Data-Void.html
22:31:23 <kmc> beware that 'vacuous' is unsound in GHC's type system
22:31:26 <kmc> but the rest should be ok
22:32:16 <kmc> hehe edwardk was nice enough to declare that the empty type is a semigroup
22:33:05 <shachaf> Oh, man. So many vacuous instances for that type.
22:34:29 <shachaf> I like how it's in Data.Void.
22:34:42 <kmc> why not
22:35:06 <shachaf> vacuous = unsafeCoerce
22:35:17 <shachaf> I guess that's safe because it can only contain _|_.
22:35:33 <kmc> yeah, assuming that functors are parametric
22:35:39 <kmc> but data families break that
22:36:06 <kmc> http://hpaste.org/52660
22:41:08 <shachaf> kmc: Hmm, so that can cause segmntation faults.
22:43:29 <shachaf> That seems kind of evil. I assume his point was to preserve _|_s?
22:43:55 <Saizan> note that the Functor instance there is not valid
22:44:01 <Saizan> but yeah, there's some evil
22:44:35 <shachaf> Saizan: Invalid instances shouldn't lead to segfaults.
22:44:37 <Saizan> the point is perfomance for tree structures
22:44:58 <shachaf> Saizan: You mean to avoid having to do things like "map id"?
22:45:05 <Saizan> yep
22:45:14 <shachaf> I guess that's fair, kind of.
22:45:16 <shachaf> But...
22:46:01 <shachaf> I wish there was a way to prove to GHC that a type was identical so you could unsafeCoerce safely.
22:46:56 <Saizan> to avoid map unwrapSomeNewtype ?
22:47:02 <shachaf> Right.
22:47:20 <shachaf> I mean, it should kind of already know.
22:47:38 <shachaf> Well, not quite.
22:48:25 <Saizan> there's a paper on the newish approach for newtypes that proposes to allow type annotations to work as casts, and shows how it's easy to check when the cast is a valid one
22:48:44 <Saizan> in a monomorphic situation though
22:48:59 <shachaf> Hmm.
22:49:19 <shachaf> I've often wished that newtypes were lighter-weight enough that they could replace almost all type synonyms.
22:51:09 <byorgey> Saizan: which paper is this?
22:53:23 <Saizan> byorgey: http://www.seas.upenn.edu/~sweirich/abstracts.html#weirich:newtypes iirc
22:53:23 <byorgey> shachaf: I was just wishing that the other day.  And I think I know a way it could be done.
22:53:52 <shachaf> byorgey: Oh?
22:53:55 <byorgey> Saizan: oh, that one.  I didn't realize they proposed allowing type annotations to work as casts.
22:54:08 <Saizan> byorgey: there's a small paragraph on it
22:54:25 <byorgey> well, I was just talking about this with Stephanie =)
22:54:39 <Saizan> suspected so :)
22:56:01 <byorgey> the idea would be to have a generic 'convert' primitive -- or maybe just type annotations.  If you have some expression e with type T and convert it to type S, it would 'anti-unify' T and S to see where they don't match
22:56:20 <byorgey> and then try to derive type equality coercions between them
22:57:02 <byorgey> of course, you have to track information about parametricity (as in that paper) or you end up with the same unsoundness that newtypes already have.
22:57:03 <shachaf> Hmm...
22:57:15 <shachaf> What's the unsoundness that newtypes have?
22:57:20 <shachaf> I guess I should read the paper.
22:57:34 <byorgey> shachaf: if you have  newtype N = N T
22:57:50 <byorgey> shachaf: then at the GHC core level there is just an equality N ~ T
22:58:19 <byorgey> however, type families are able to dispatch on whether something is N or T
22:58:33 <byorgey> for example you could have  type instance Foo N = Int; type instance Foo T = Char
22:59:10 <byorgey> so you don't want the user to have unrestricted access to that coercion N ~ T  because then they can derive  Int ~ Foo N ~ Foo T ~ Char
22:59:57 <byorgey> but it's safe to convert, say, [N] to [T], because [] is parametric
23:00:58 <shachaf> Hmm, I see.
23:03:45 <Saizan> IOW [N] and [T] are two source-level types for the same runtime type
23:11:31 <shachaf> @google 4700 m in feet
23:11:32 <lambdabot> http://www.flickr.com/photos/photomagister/200402262/
23:11:32 <lambdabot> Title: Fog at 4700 meters (15,400 feet) | Flickr - Photo Sharing!
23:11:46 <shachaf> Blah. (Or, rather, #-blah.)
23:49:46 <hpaste> “Mukesh Tiwari” pasted “Three loops in C++” at http://hpaste.org/53268
23:50:22 <keep_learning> Hello all
23:50:51 <keep_learning> I wrote a simple code in c++ using three loops and converted the same code in Haskell.
23:51:03 <ddarius> Don't use foldl.
23:52:36 <ddarius> For ret use foldl', for allst use foldr.
23:52:56 <ddarius> (With an irrefutable match against the pair.)
23:52:57 <salisbury> what is the matter with foldl?
23:53:39 <keep_learning> ddarius, Thank you
23:58:54 <keep_learning>  why foldr is considered better than foldl .  Only because of laziness or there is something else.
