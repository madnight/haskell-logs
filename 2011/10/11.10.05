00:00:02 <rostayob> is there a way to make ghc-mod work with hsc files,  apart from compiling the .hsc files to .hs manually?
00:06:39 <Barbapappa> haskell sucks
00:07:11 <kmc> good one
00:07:36 <newsham> ?faq can haskell continue after being insulted?
00:07:37 <lambdabot> The answer is: Yes! Haskell can do that.
00:07:47 <sipa> @vixen can haskell dust suck your floor?
00:07:48 <lambdabot> Politics would be a helluva good business if it weren't for the goddamned people.
00:09:38 <Axman6> @faq can haskell suck more?
00:09:39 <lambdabot> The answer is: Yes! Haskell can do that.
00:09:56 <Barbapappa> haskell, making it a little bit more difficult than it need be..
00:10:09 <Barbapappa> just for the heck of it
00:10:16 <Axman6> Haskell, finding bugs before you even knew they were there
00:11:03 <Barbapappa> in your pretty hello world progam?
00:11:05 <Axman6> i don't think we've ever had a real language troll who just spouted uninformed nonsense in here
00:11:12 <Axman6> yeah man
00:11:18 <sipa> Barbapappa: if haskell is hard, learn intercal!
00:11:35 <Axman6> main = putStrLn "Hello, world!" it all type checks!
00:11:35 <shachaf> @protontorpedo
00:11:36 <lambdabot> i have a win xp box
00:12:03 <shachaf> @protontorpedo
00:12:04 <lambdabot> scheme, lisp, php, python, perl, tcl, al banned
00:12:31 <Barbapappa> A proper man uses C. The end
00:12:54 <shachaf> kmc: Your prophecy has come true!
00:13:13 <moriramar> No, a proper man use neutrino, which is faster than C.
00:13:41 <sipa> The easiest language is always the one you already know.
00:13:48 <Axman6> but Haskell uses C, so it's a proper man!
00:13:49 <Blkt> good morning everyone
00:13:53 <shachaf> moriramar: I don't think that's how it works.
00:14:11 <Axman6> he's right
00:14:42 <Barbapappa> useless...
00:15:19 <moriramar> shachaf, Well, I dunno. LHC guys found neutrino faster than c, so...
00:16:05 <sipa> the bartender says "we don't serve neutrino's here"
00:16:17 <sipa> a neutrino walks into a bar
00:16:25 <moriramar> lol
00:16:35 <killerswan> if haskell is a proper man...
00:16:42 <killerswan> do we use haskell, or does it use us?
00:18:20 <antihoax> # sed -nr 's;^[ ]*([a-z,A-Z,0-9][a-z,A-Z,0-9,\-]*[ ]*):[ ]*([^ ][^ ]*).*;--\1="\2";p' ./config
00:18:20 <antihoax> --remote-repo="hackage.haskell.org:http://hackage.haskell.org/packages/archive"
00:18:20 <antihoax> --remote-repo-cache="/root/.cabal/packages"
00:18:32 <antihoax> ...
00:19:10 <Axman6> wut
00:19:37 <antihoax> cabalconfigfile
00:22:31 <kmc> ugh
00:32:45 <warpy> what is the difference between data-lens and lenses packages? which one should i use?
00:34:23 <quicksilver> warpy: see also fclabels and data-accessor
00:34:27 <quicksilver> warpy: you should use data-lens.
00:34:42 <warpy> yes. so many of them. i checked all of them
00:34:48 <warpy> which one is preferable?
00:34:58 <quicksilver> data-lens.
00:35:00 <kmc> hehe, i used to ask this question when there were only three
00:35:10 <kmc> what makes data-lens preferable
00:35:17 <kmc> more semigroupoids? ;P
00:35:58 <quicksilver> it has a more efficient representation, and it has a sane and systematic API, and it's current/active.
00:36:28 <warpy> rest are not being developed?
00:36:35 <quicksilver> it's a subjective call, but warpy was asking for advice and that's mine.
00:37:12 <quicksilver> warpy: "lenses" isn't being developed AFAIK; fclabels and data-accessor are though.
00:37:20 <quicksilver> fclabels would be my second choice, I guess.
00:37:35 <warpy> i like data-accessor over fclabels and lenses after reading their docs. havnt seen data-lens yet
00:38:08 <kmc> fclabels has a pretty thorough documentation
00:39:22 <warpy> point me to a data-lens tutorial please. it does not have an example in its doc unline fclabels and data-accessor
00:42:39 <quicksilver> some comparison in this SO answer : http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation
00:43:16 <shachaf> preflex: seen cmccann
00:43:16 <preflex>  cmccann was last seen on #haskell 14 days, 5 hours, 6 minutes and 46 seconds ago, saying: yes, I expect that terms common in OO were chosen deliberately in order to confuse newcomers as much as possible
00:56:16 <antihoax> ahm
00:56:32 <antihoax> why do i need the bootstrap.sh if i already have the cabal ?
00:57:52 <antihoax> i dont get it ;/
01:12:35 <cheater> http://cheater.posterous.com/twisted-deferreds-in-haskell
01:12:57 <cheater> @tell wavewave let me know if you'd like me to link to your page/blog/twitter here :) http://cheater.posterous.com/twisted-deferreds-in-haskell
01:12:57 <lambdabot> Consider it noted.
01:22:14 <warpy> quicksilver: can you hpaste a simple example of data-lens usage? i cant find any on google
01:27:09 <rostayob> @pl \len kcstrptr -> f kcstrptr (fi len)
01:27:10 <lambdabot> flip f . fi
01:27:48 <quicksilver> warpy: yeah, it's abit short on docs / tutorials. The types tell the story really.
01:29:04 <quicksilver> data Foo = MkFoo { fooA :: Int, fooB :: String }; a = lens fooA (\a x -> x { fooA = a }); b = lens fooB (\b x -> x { fooB = b});
01:29:45 <quicksilver> the you can do things like "foo^.a" and "foo^.b"
01:32:29 <warpy> quicksilver: cool! I'll try
01:32:56 <kmc> "the types tell the story" is a cop-opt ;P
01:33:11 <kmc> the degree depends on the library
01:35:43 <quicksilver> kmc: yes, but I'm talking about one particular library.
01:35:54 <quicksilver> and for this particular library, the types really do determine most of the functions.
01:36:24 <shachaf> data-lens seems nice.
01:36:35 <shachaf> I don't know if lens libraries are different enough to merit there being so many, though.
01:37:01 <Baughn> Almost certainly not. It's rather silly, really.
01:37:01 <quicksilver> probably not, but that's not really how it works :)
01:37:08 <Baughn> I think I'll make another one that we can all agree to use.
01:37:21 <shachaf> A lens library to end all lens libraries!
01:38:48 <kmc> just like the 9000 json and regex and xml libraries
01:41:55 <quicksilver> what we need is an adapter package any-lens which uses whichever lens package is available
01:42:29 <quicksilver> then we get potentially the disadvantages of all, without being able to guarantee the advantages of any.
01:42:39 <warpy> yes!
01:43:07 <shachaf> quicksilver++
01:46:47 <kmc> what we really need is a separate XML configuration file which describes the lenses to use
01:47:26 <tdammers> ...which the runtime would automatically request from a remote server
01:47:27 <kmc> this is loaded into a LensFactoryConfigurationSingleton which then informs an AbstractLensCreationFactory, turning it into a tree of LensCreationFactoryVisitors which produce lenses
01:47:31 <tdammers> ...through SOAP!
01:47:33 <shachaf> kmc: XML is too heavyweight and enterprisey. It needs to be a REST service.
01:47:45 <tdammers> but... but... SOAP!
01:49:01 <Baughn> shachaf: REST is old-fashioned and clunky. Make it a JSON service.
01:49:26 <warpy> pfft. all you need a UI that generates the XML configuration using the inputs from the user
01:50:05 <warpy> quicksilver: i've got getters working. how do i use the setters?
01:50:23 <shachaf> Presumably with a function called something like "set"?
01:50:40 <shachaf> getL, setL, modL
01:50:55 <warpy> i meant the operator, ^=
01:50:56 <quicksilver> warpy: (foo^=a) 5
01:51:03 <quicksilver> will give a new foo in which 'a' has been set to 5.
01:51:27 <quicksilver> erm
01:51:34 <quicksilver> sorry arguments all mixed up :)
01:51:52 <quicksilver> (a^=5) foo, rather
01:51:57 <frerich> How is that an improvement than 'foo { a = 5 }'? I guess it only really kicks in with nested data structures?
01:52:03 <quicksilver> frerich: precisely.
01:52:24 <quicksilver> frerich: it's an improvement because it's firstclass so you can pass it as a parameter and abstract it
01:52:26 <kmc> well also you can write \a -> (foo^=a) 5
01:52:31 <kmc> yeah
01:52:55 <quicksilver> nested structures are a good case in point
01:53:28 <warpy> also my case in which i have same update to apply to many record instances
01:53:37 <warpy> i can just make over them
01:53:42 <warpy> map*
01:53:48 <warpy> quicksilver: right?
01:53:51 <quicksilver> right.
01:53:51 <kmc> the regular syntax for that is not so bad
01:53:55 <kmc> map (\x -> x { a = 5 })
01:54:09 <quicksilver> map (a^=5) [ foo, anotherFoo, anotherOtherFoo ]
01:54:36 <quicksilver> the regular syntax only gets really bad if you want to (a) nest or (b) abstract out the field name
01:54:52 <kmc> it turns out you usually want to do one of those things ;)
01:54:55 <frerich> Yeah, I was also about to say that the record syntax is not so bad but now that I read quicksilvers code, it's kind of nice how it says 'set a to 5' more clearly without hiding it in a lambda.
01:55:10 <quicksilver> frerich: it's definitely not so bad in simple cases.
01:55:13 <frerich> It's like a pointless lambda, in case that makes sense.
01:55:16 <quicksilver> its generalising it that's annoying.
01:55:35 <kmc> i've found that Haskell records are better a cheap substitute for first-class modules than as actual data
01:56:13 <kmc> because you don't as often want to nest modules, or abstract over field names
01:58:09 <frerich> quicksilver: Hm, So if you have a list of structures containing other structures, you could do something along the lines of 'a^=b^=x' to set a field of an inner field?
01:58:10 * hackagebot hakyll 3.2.0.9 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.0.9 (JasperVanDerJeugt)
01:58:28 <quicksilver> frerich: a.b^=x, I think
01:58:47 <quicksilver> if you have (.) as Control.Category's (.)
01:59:23 <quicksilver> frerich: see also (a.b ^+= 5) to increment it by 5, etc.
01:59:44 <quicksilver> and compare that to
02:00:46 <frerich> Would that be the same as, erm... \x -> x { a = a { b = b + 5 } } ?
02:00:50 <quicksilver> \x -> x { a = a x { b = b (a x) + 5 } }
02:00:56 <quicksilver> I think.
02:00:57 <frerich> Oh, right.
02:01:09 <quicksilver> which is fairly horrid, even if I got it right.
02:01:23 <frerich> It's really nice that it's a function
02:02:04 <frerich> I think this would have saved a lot of code in some little programs I wrote, what a pity.
02:04:21 <tsousa> can someone help figure out how to do problem 7 on 99 haskell problems?http://www.haskell.org/haskellwiki/99_questions/1_to_10 http://www.haskell.org/haskellwiki/99_questions/1_to_10http://www.haskell.org/haskellwiki/99_questions/1_to_10
02:04:36 <quicksilver> frerich: well you need to write that code once to understand why this way is better :)
02:05:33 <Baughn> tsousa: Well, you'
02:05:48 <Baughn> tsousa: You're really supposed to do it yourself for maximum effect. Maybe if you tell us what you're stuck on?
02:06:21 <tsousa> Baughn, i dont know how i can divide the input to extrat the stuff that i want
02:06:53 <Baughn> tsousa: "Input"? These problems do not involve I/O.
02:07:00 <Baughn> tsousa: You should just be doing them in GHCi.
02:07:34 <tsousa> yes but like flatten (List [Elem 1, List [Elem 2, List [Elem 3, Elem 4], Elem 5]]) i dont care about the Elem stuff i just want the numbers
02:07:50 <tsousa> that is my problem. remove the rest and get the meat
02:08:10 <Baughn> tsousa: Pattern-matching.
02:08:23 <Baughn> foo (Elem n) = n
02:08:28 <Baughn> Or whatever
02:08:37 <tsousa> humm
02:13:41 <warpy> quicksilver: my code changed from >> turnRight (cleaner@Cleaner { .. }) =   return $ cleaner { direction = (right direction), perceptsHist = ([] : perceptsHist) } << to  >> turnRight = return . (direction ^%= right) . (perceptsHist ^%= ([] :)) <<
02:13:58 <warpy> much better
02:14:32 <quicksilver> yay :)
02:15:16 <killerswan> i scrolled up and saw you talking about SOAP and I think i had a flashback or a seizure or something
02:16:23 <warpy> killerswan: you are back in 2003.
02:16:56 <warpy> we use SOAP and SOA and all other enterprisey things
02:17:24 <sipa> ok, that's confusing
02:20:46 <tdammers> SOAP is kind of nice if you're in a click-and-drool mindset, and you want to connect components together over the web in a cross-platform way
02:20:57 <tdammers> of course it only really works well if both ends run on the same platform
02:21:24 <tdammers> and you have to throw considerable amounts of hardware at it to compensate for the bloat
02:35:14 <lysgaard> I want to define a num instance for: "f (Num a) => (a -> a)" is it possible?
02:35:35 <benmachine> lysgaard: what does 'f' mean here?
02:36:43 <napping> What is that syntax? f (Num a) in the constraint part??
02:37:08 <sipa> f must be a dictionary-to-dictionary function
02:37:10 <napping> Is this the new constraint families extension?
02:38:15 * hackagebot xml-catalog 0.2.0 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-0.2.0 (MichaelSnoyman)
02:38:40 <benmachine> I'm not sure it's anything at all, which is why I asked
02:41:49 <napping> yes, it does seem to be malformed
02:42:20 <napping> lysgaard: can you give a different description of what you want?
02:44:05 <ski> @remember quicksilver <quicksilver> what we need is an adapter package any-lens which uses whichever lens package is available <quicksilver> then we get potentially the disadvantages of all, without being able to guarantee the advantages of any.
02:44:06 <lambdabot> I will remember.
02:45:26 <napping> forall n . (Num n) => n -> n is a bit of an odd type - it's basically an expression in the Num operators with one free variable, isn't it?
02:46:11 <quicksilver> perhaps he meant, a Num istance for functons (a -> a)
02:46:24 <quicksilver> with the precondition that "a" be a Num.
02:46:32 <quicksilver> instance Num a => Num (a -> a)
02:46:33 <ski> quicksilver,frerich : it'd have to be `\x -> x { a = (a x) { b = b (a x) + 5 } }', because of the strange precedence of record creation/update syntax
02:46:51 <quicksilver> ski: thank you. I had a feeling my code wasn't quite ugly enough :)
02:46:58 * ski grins
02:53:42 <obiwahn> data car = {name::String, maxspeed::Int} <- car is a type constructor? id like to read more about the {... :: .. } construct that looks like a kind of struct what is it called?
02:54:04 <napping> that looks odd
02:55:22 <obiwahn> http://monads.haskell.cz/examples/example1.hs - the fist line that is not a comment
02:55:28 <obiwahn> ah
02:56:03 <donri> records
02:56:05 <obiwahn> a car was missing:) thanks donri :)
02:56:11 <obiwahn> and uppercase ...
02:56:13 <donri> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
02:59:11 <donri> beware that the named fields actually result in functions in the module namespace
02:59:23 <obiwahn> so name would be a function that looks up stuff
02:59:35 <obiwahn> that was my next question:)
02:59:55 <obiwahn> so sould do something like carname?!
03:00:13 <donri> yes, and you can also use the syntax for constructing values: Car{name = "Volvo", maxspeed = 666}
03:00:16 <obiwahn> is there any guideline on style?
03:00:41 <donri> some use prefixes, some use qualified modules
03:01:39 <obiwahn> do you have an example for the latter?
03:01:55 <donri> you can however use the same name in different constructors of the same type (data Car = Volvo {speed :: Int} | Saab {speed :: Int})
03:03:03 <donri> if you put a data type in a module you can import the module qualified: import qualified My.Car.Module as Car  and then you have Car.name etc
03:03:39 <obiwahn> alright:)
03:04:50 <donri> that is `Car.name someCar` not `someCar.name`, BTW
03:05:24 <Nimatek> donri: I remember thee.
03:05:29 <obiwahn> sure as it is function that operates on the car type:)
03:05:49 <obiwahn> or better takes a car as argument:)
03:06:17 <donri> Nimatek: hm, milk?
03:06:31 <Nimatek> Yes.
03:06:34 <donri> :D
03:09:55 <ketil> What's the easiest way to print .hs files?  Enscript?  a2ps?  Something else?
03:10:17 <sipa> lhs2tex :)
03:10:26 <quicksilver> I have used a2ps in the past
03:11:14 <ketil> a2ps doesn't support utf8, does it?
03:15:38 <Jafet> lp -- *.hs
03:16:36 <quicksilver> ketil: interesting point. I've never used utf8 in my source ... but interesting.
03:16:51 <Jafet> This is UTF-8!
03:16:56 <ketil> Usually not a big problem in source, no.  Just...nice to have.
03:17:42 <ketil> Jafet, eh, although technically correct, it isn't common to use the term "supports utf-8" to mean works for the subset of utf-8 characters that happen to be ASCII.
03:18:05 <Jafet> Well, it sort of counts as using UTF-8.
03:18:20 * ketil just did: a2ps -1 -C -l 120 *.hs 
03:18:27 * ketil goes to see how it turned out.
03:21:29 <obiwahn> i have an exam in 2 weeks about functional programming and i think that my prof is gonna ask simple tasks like how do get the max of a list before he comes to monads denonationl semantics, lambda caluclus typechecking and so on
03:22:16 <obiwahn> so what are good ways to get the max? i thought of fold max 0 list but what about negative numbers?
03:22:46 <Jafet> What about things that aren't numbers?
03:22:47 <kmc> maximum [] = error "empty list has no maximum";  maximum (x:xs) = foldr max x xs
03:23:11 <kmc> i.e.  maximum = foldr1 max , but with a more helpful error message
03:23:13 <obiwahn> Jafet: then i would need something like Ord a =>
03:23:29 <Jafet> @type foldl1' max
03:23:30 <lambdabot> forall a. (Ord a) => [a] -> a
03:24:17 <obiwahn> @src foldr1
03:24:17 <lambdabot> foldr1 _ [x]    = x
03:24:17 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
03:24:17 <lambdabot> foldr1 _ []     = undefined
03:24:19 <donri> of course, "maximum" already exists in the prelude yea?
03:24:27 <kmc> yep
03:24:27 <donri> @src maximum
03:24:28 <lambdabot> maximum [] = undefined
03:24:28 <lambdabot> maximum xs = foldl1 max xs
03:24:41 <donri> @type maximum
03:24:42 <lambdabot> forall a. (Ord a) => [a] -> a
03:24:48 <Jafet> I'm gonna write a foldl1Iı'
03:25:13 <lysgaard> I want to define a num instance for: "f :: (Num a) => (a -> a)" is it possible? That is. I have a function that takes a number and returns a number. I want to be able to eg. multiply a function with a constant to get a new function that returns the double.
03:25:14 <Jafet> > maximum []
03:25:15 <lambdabot>   *Exception: Prelude.maximum: empty list
03:25:16 <kmc> obiwahn, another choice is:  maximum [] = Nothing; maximum (x:xs) = Just (foldr max x xs)
03:25:47 <Jafet> lysgaard: people asked you what f was
03:25:56 <obiwahn> that is nice:)
03:26:18 <donri> maximum [] = minBound -- ;)
03:26:33 <lysgaard> Jafet: f is the function. It takes a number and returns a number.
03:26:55 <Jafet> @quote head.\[\]
03:26:56 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
03:27:07 <ski> > (cos ^ 2 + sin ^ 2) (pi / 3)  -- lysgaard
03:27:08 <lambdabot>   1.0
03:27:12 <ski> lysgaard : like that ?
03:27:43 <ski> lysgaard : you want `instance Num a => Num (rho -> a) where ...', in that case
03:28:12 <ski> > (2 * cos) 0
03:28:13 <lambdabot>   2.0
03:28:59 <Jafet> @instances-importing Data.NumInstances Num
03:28:59 <lambdabot> (a -> b), (a, b), (a, b, c), (a, b, c, d), Double, Float, Int, Integer
03:29:32 <obiwahn> lets say i have a sorted list and i want the median - how would i get it - calculate len and drop len/2 in case it is even?
03:30:15 <ski> obiwahn : i would try a hare-tortoise race
03:30:17 <Jafet> What if len is even?
03:31:00 <lysgaard> ski: Yeah, i think you got it.
03:31:16 <yottis> iirc the median is usually calculated as the average of the two middlemost elements
03:31:26 <yottis> if there is an even amount, that is
03:31:27 <kmc> meaning traverse the list twice simultaneously, at 1x and 2x speed?
03:31:37 <ski> yes
03:31:43 <kmc> that might perform a bit better than taking the length and dropping, but i doubt the code is as easy to follow
03:31:44 <yottis> but i'm sure it depends on the context
03:31:45 <Jafet> yottis, to a fortran programmer, everything is a number?
03:31:58 <kmc> unless the professor is asking specifically for very fast code, i'd go with simple + more obviously correct
03:32:22 <Jafet> kmc: no! space! leak!
03:33:04 <obiwahn> yottis: i have thought about quicksort and taking something else than first element because that would be worst case on sorted lists:)
03:33:56 <Jafet> But the input lists to quicksort usually aren't sorted.
03:34:02 <Jafet> ...right?
03:34:35 <lysgaard> ski: How do i say that the functions arguments have to be a instance of Num?
03:34:51 <ski> lysgaard : why do you want to say that ?
03:35:41 <Axman6> Jafet: in many real world situations, they are
03:35:44 <ski> > ((2 ^) + (3 ^)) 4
03:35:46 <lambdabot>   97
03:35:47 <ski> > ((2 ^) + (3 ^)) 4 :: Expr
03:35:48 <lambdabot>   2 * 2 * (2 * 2) + 3 * 3 * (3 * 3)
03:35:49 <obiwahn> i am not so sure:) sometimes only a few elements are inserted and then you want an update - worst case on sorted lists is not good ...
03:36:00 <ski> in this case the `4' is an `Integer'
03:36:10 <ski> > ((2 ^) / (3 ^)) (4 :: Integer)
03:36:11 <lambdabot>   0.19753086419753085
03:36:11 <Jafet> No wonder quicksort appears to be fast!
03:36:15 <Jafet> That scum.
03:36:39 <Axman6> actually, quicksort performs quite badly on sorted input
03:36:55 <Axman6> well, depending on how you chose your pivot
03:37:13 <ski> > let f True = pi; f False = exp 1 in  (f + f^2) False  -- lysgaard, here the inputs aren't even numbers
03:37:14 <lambdabot>   10.107337927389695
03:37:33 <Axman6> if you're using lists, you're almost certainly going to choose the first element
03:37:41 <ski> lysgaard : my point is that it seems to me that it is *irrellevant* whether the arguments to the functions are numbers or not
03:38:00 <ski> lysgaard : .. but maybe you have an example where you actually need to assume that ?
03:38:37 <obiwahn> ski: how does that fable relate to my problem? i am not sure what the idea is and how to apply it. take items from both ends and see waht is left?
03:38:52 <Jafet> ski: note that you're using an instance from a topology library or something
03:39:00 <ski> obiwahn : no, see what kmc said above
03:39:06 <lysgaard> ski: I can't reproduce what you did with lambdabot in my ghci prompt :S
03:39:28 <ski> Jafet : we need more instances of `Compact' and `Overt' ..
03:40:04 <lysgaard> ski: Do i need some extention?
03:40:39 <ski> <ski> lysgaard : you want `instance Num a => Num (rho -> a) where ...', in that case
03:40:52 <ski> lambdabot already has one of those in her source
03:41:22 <ski> (how to fill in the `...' being left as an exercise for you)
03:41:53 <ski> obiwahn : all clear ?
03:42:56 <obiwahn> not so sure:)
03:43:14 <ski> obiwahn : let's say you have a list written out in front of you
03:43:37 <ski> you point with one finger to the initial element, and with another pinger to the same initial element
03:43:37 <obiwahn> no that is clear:) i am not sure how to put it in haskel
03:43:51 <ski> then you advance one finger one element, and the other two elements
03:44:04 <Jafet> > let hare (x:_:xs) = x:hare xs; hare xs = xs in ap zip hare [0..]
03:44:05 <lambdabot>   [(0,0),(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20),(...
03:44:07 <ski> when the second finger reaches the end, the first is at about the middle
03:44:09 <obiwahn> when i reach with 2x speed the end it take the element a 1x speed
03:44:40 <ski> of course, you get two base cases
03:44:43 <Axman6> > map (id &&& (*2)) [0..]
03:44:44 <lambdabot>   [(0,0),(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20),(...
03:44:56 <ski> (a) second finger (hare) points to last element
03:45:01 <ski> (b) second finger (hare) points to element before last element
03:45:14 <Jafet> > zip [0..] [0,2..]
03:45:14 <lambdabot>   [(0,0),(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20),(...
03:46:58 <Grahack> hi all, I'm trying to try Yesod on debian squeeze. The cabal install stops at the skein package: 'src/Crypto/Skein/Internal.hsc:139:28: Malformed entity string' could someone help? Is it because of my ghc6 < 7 ?
03:47:14 <lysgaard> ski: To define those instances i have to make an instance of Show (rho -> a) since Num requires that, how do i do that?
03:47:56 <Jafet> You don't. show = undefined
03:48:10 <ski> lysgaard : yeah, that's a PITA, really. just punt and do `instance Show (rho -> a) where show = error "you lose !"'
03:48:26 * hackagebot simpleprelude 1.0 - A simplified Haskell prelude for teaching  http://hackage.haskell.org/package/simpleprelude-1.0 (JeanMarieGaillourdet)
03:48:27 <ski> (same for `Eq')
03:48:48 <Axman6> Jafet: or, show n = show (n undefined)
03:49:26 <ski> yeah, that might be nicer
03:49:30 <Jafet> Or the old caleskell instance
03:49:33 <Jafet> > id
03:49:34 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
03:49:34 <lambdabot>    arising from a use of `...
03:51:02 <mauke> > id :: String -> String
03:51:03 <lambdabot>   Overlapping instances for GHC.Show.Show
03:51:03 <lambdabot>                              (GHC.B...
03:51:13 <lysgaard> ski: Hmm, struggeling here. Do you know where in the lambdabot source this resides?
03:51:45 <Jafet> > fromEnum :: (Int -> Word8)
03:51:46 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
03:51:46 <lambdabot>         against inferred type...
03:51:51 <Jafet> > toEnum :: (Int -> Word8)
03:51:52 <lambdabot>   Overlapping instances for GHC.Show.Show
03:51:53 <lambdabot>                              (GHC.T...
03:52:07 <ski> lysgaard : Jafet's invocation above seemed to suggest it came from `Data.NumInstances'
03:52:35 <Jafet> @hackage vector-space
03:52:35 <lambdabot> http://hackage.haskell.org/package/vector-space
03:56:04 <derp> Mmmmyellow
03:58:26 * hackagebot simpleprelude 1.0.0.1 - A simplified Haskell prelude for teaching  http://hackage.haskell.org/package/simpleprelude-1.0.0.1 (JeanMarieGaillourdet)
04:03:02 <ion> mm_freak: Is your FRP-based IRC library available somewhere?
04:03:32 <mm_freak> ion: not yet…  i have a pre-alpha based on Animas, which i've written before netwire
04:04:07 <ion> mm_freak: I’d like to read the source. It might give me some insights when trying to learn FRP. :-)
04:04:42 <ion> mm_freak: Is Netwire the FRP library you prefer?
04:08:22 <mm_freak> ion: netwire is the FRP library i wrote =)
04:08:27 <ion> Ah :-)
04:08:45 <mm_freak> ion: you can't really learn FRP from the current source code…  it's a mess trying to get around all the limitations of animas
04:08:52 <ion> Ok
04:12:31 <mm_freak> ion: however, you may try to read the source code of netwire, especially for the Wire type constructor
04:12:52 <mm_freak> a wire is a computation, which may mutate itself for the next instance
04:12:57 <mm_freak> that's about all technically
04:13:32 <mm_freak> that's why it returns an output value and a new wire
04:13:40 <antihoax> ion <; some sneaky bastards were still hiding in the pstree
04:13:53 <antihoax> but looks like its over
04:14:02 <antihoax> (took 48 hours)
04:15:02 <peikos> hello
04:17:26 <peikos> is there an easy way to apply a function to both values in a split arrow computation? say, is there an easier way to write f &&& g >>> h *** h >>> uncury i, such that h is only needed once?
04:17:43 <ion> antihoax: Are you trolling perchance?
04:18:46 <ion> join (***) h
04:25:00 <peikos> @ion, thanks.. but what if the results of f and g are of two different types (but instancing shared classes)
04:25:00 <lambdabot> Unknown command, try @list
04:25:10 <peikos> ion: thanks.. but what if the results of f and g are of two different types (but instancing shared classes)
04:25:18 <peikos> sorry lambdabot
04:25:49 <ion> I’m not sure the type system has a solution for that. (I’ll be happy to be corrected on that.)
04:25:50 <peikos> so, say f &&& g >>> show >>> uncurry (++)
04:26:05 <peikos> arm show *** show of course
04:27:08 <peikos> hmm, that's too bad, I was hoping I could make it just a little more succint by removing the duplicate show
04:27:13 <napping> There's no generic solution, but you can write somthing like pairNum :: (Num a, Num b) => (forall n . Num n => n -> n) -> (a, b) -> (a, b); pairNum f (x y) = (f x, f y)
04:27:40 <peikos> thanks for the suggestion at least, this might still be helpful in some other instances :-)
04:28:36 * hackagebot yesod-auth 0.7.4 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.4 (MichaelSnoyman)
04:28:42 <ion> > let foo :: (Show a, Show b) => (forall z. Show z => z -> String) -> a -> b -> String; foo f a b = f a ++ f b in foo show 42 "bar"
04:28:44 <lambdabot>   "42\"bar\""
04:28:56 <ion> I guess that can’t be generalized.
04:30:41 <napping> there's not much of interest (forall z . Show z => z -> String) can do
04:31:11 <napping> might as well just special case a pair of shows, and apply a String->String function if needed
04:31:52 <peikos> hmm, thanks for the suggestion! now trying it out in my own software :-)
04:35:08 <ion> napping: Indeed. If there was a way to transfer any (caller-given) constraint from the parameter to the top level type (which i meant by generalization), what peikos asked for might work.
04:35:42 <peikos> this did indeed solve my problem.. at the moment it gave me more code instead of cleaning things up, but it might be worth it if used more than once. At the very least I'm now learning something about forall, which is greatly appreciated :-)
04:39:19 <napping> Well, there's also the question of how the result relates to the argument type. Some kind of higher-order matching a'la Agda might get you closer - until you thrown in MTPCs or type families
04:42:49 <peikos> sounds interesting to read into, thanks. this may all be going a little bit beyond the scope of my current goals, but definitely something to put on the readlist
04:43:49 <napping> It's more of an open question
04:45:58 <Twey> Is there a name for the gcd algorithm used in the Prelude (or, at least, in lambdabot)?
04:46:55 <donri> "the thingy"
04:47:05 <napping> Euclid's thingy?
04:47:10 <int-e> Euclid's algorithm?
04:48:37 * hackagebot persistent-mongoDB 0.6.3 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-0.6.3 (MichaelSnoyman)
04:53:38 * hackagebot yesod 0.9.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.3 (MichaelSnoyman)
04:57:34 <rs46> Hi, is there a list comprehension that loops forever through a finite list, generating an infinite list. i.e. [a,b,c] -> [a,b,c,a,b,c,a,b...] ?
04:57:51 <int-e> > cycle [1..3]
04:57:52 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
04:58:14 <rs46> thanks !
04:58:18 <saml> you're welcome
04:58:39 * hackagebot simpleprelude 1.0.0.2 - A simplified Haskell prelude for teaching  http://hackage.haskell.org/package/simpleprelude-1.0.0.2 (JeanMarieGaillourdet)
04:59:53 <int-e> rs46: (not a list comprehension, of course -- it's a library function. but it works well together with list comprehensions.)
05:00:59 <Jeanne-Kamikaze> so... when is the haskell phone coming out
05:01:06 <saml> yesterday will it be
05:01:12 <Jeanne-Kamikaze> lambda phone
05:01:18 <saml> yesterday.
05:01:25 <Jeanne-Kamikaze> orly ?
05:01:35 <saml> all my dreams seemed so far away
05:01:59 <saml> do you believe in yesterday oh suddenly
05:02:50 <Jeanne-Kamikaze> I like cradle of filth better
05:03:48 <dafis> never heard of them, I'm a Stones guy
05:03:58 <Twey> int-e, that's Euclid's?  The Wikipedia description of Euclid's seems more complicated…
05:06:13 <int-e> Twey: don't look at the description - look at the sample implementations
05:07:29 <dafis> Although, strictly speaking, it's a somewhat optimised Euclidean algorithm, the original did only subtractions, no divisions
05:08:47 <Twey> Ah, right
05:15:03 <tsousa> i am trying to solve problem 9 on 99 haskell problems, but i get this error http://dpaste.com/627872/  http://www.haskell.org/haskellwiki/99_questions/1_to_10
05:16:04 <mauke> pack = group
05:16:26 <mauke> tsousa: the error you pasted doesn't match your code
05:17:30 <tsousa> mauke, that is the code
05:17:36 <tsousa> :l problme9.hs
05:17:36 <mauke> no, it isn't
05:17:45 <tsousa> and only with group it doesnt work
05:17:54 <mauke> what do you mean by "it doesn't work"?
05:18:55 <donri> tsousa: the type signature is wrong, should be [[a]]
05:19:04 <tsousa> like it should with this input [1,1,1,1,2,3,3,] give me [[1,1,1,1],[2],[3,3]]
05:19:07 <donri> [a] -> [[a]]
05:19:11 <mah_b> try concat . group
05:19:18 <mauke> > group [1,1,1,1,2,3,3]
05:19:19 <lambdabot>   [[1,1,1,1],[2],[3,3]]
05:19:35 <mauke> tsousa: ^
05:20:09 <mah_b> ... no, don't
05:20:12 <donri> that's not a very useful answer to a tutorial problem though is it? :)
05:20:13 <tsousa> donri, that worked thanks
05:20:33 <donri> you should perhaps try to do it without stuff like Data.List
05:21:18 <tsousa> ok
05:21:46 <frerich> mauke: Hi, I just wanted to thank you for that nasty 'sizeof.c' snippet you uploaded (at least if I understood shachaf correctly)! It amused a few colleagues of mine. :-)
05:21:48 <dmwit> ?src gcd
05:21:48 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
05:21:48 <lambdabot> gcd x y = gcd' (abs x) (abs y)
05:21:48 <lambdabot>    where gcd' a 0  =  a
05:21:48 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
05:22:24 <donri> @check \x -> concat . group x == x
05:22:24 <dmwit> Twey: Yes, that's Euclid's.
05:22:25 <lambdabot>   Couldn't match expected type `a -> [[a1]]'
05:23:00 <dmwit> ?check \x -> (concat . group) x == x
05:23:01 <lambdabot>   "OK, passed 500 tests."
05:23:04 <Twey> dmwit: Cool, thanks.  ☺
05:23:12 <dmwit> ?check \x -> (concat . group) x == (x :: [Int])
05:23:13 <lambdabot>   "OK, passed 500 tests."
05:23:29 <donri> > group [1,2,3,1,2,3]
05:23:30 <lambdabot>   [[1],[2],[3],[1],[2],[3]]
05:23:41 <Clint> @src rem
05:23:42 <lambdabot> Source not found. Just try something else.
05:23:56 <dmwit> Clint: It's a typeclass function.
05:24:05 <dmwit> ?src Integral
05:24:05 <lambdabot> class  (Real a, Enum a) => Integral a  where
05:24:06 <lambdabot>     quot, rem, div, mod :: a -> a -> a
05:24:06 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
05:24:06 <lambdabot>     toInteger           :: a -> Integer
05:24:16 <Clint> ah
05:29:24 <Oxfaded> is there something like this build into the standard library: foldr (\a b->a b) 0 xs?
05:29:42 <mauke> :t foldr (\a b->a b) 0
05:29:43 <lambdabot> forall b. (Num b) => [b -> b] -> b
05:29:44 <sipa> @pl (\a b -> a b)
05:29:45 <lambdabot> id
05:29:57 <sipa> huh
05:30:21 <mauke> doesn't seem very useful
05:30:57 <mauke> :t foldr (.) id
05:30:57 <lambdabot> forall b. [b -> b] -> b -> b
05:31:33 <byorgey> > foldr (.) id [(+2), (*9), succ] $ 0
05:31:35 <lambdabot>   11
05:31:44 <byorgey> > foldr id 0 [(+2), (*9), succ]
05:31:45 <lambdabot>   11
05:31:52 <sipa> @type (\a b -> a b)
05:31:53 <lambdabot> forall t t1. (t -> t1) -> t -> t1
05:32:12 <byorgey> also known as ($)
05:32:16 <mauke> and id
05:32:49 <sipa> a `id` b = (id a) b = a b
05:32:51 <sipa> got it!
05:33:32 <Oxfaded> i want to string together a bunch of ReadS aka [(t0, String)] and return a single result
05:33:45 * hackagebot skein 0.1.0.1 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.1 (FelipeLessa)
05:34:01 <mauke> :t reads
05:34:02 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:34:11 <mauke> that's basically a state monad
05:34:39 <Grahack> haha, I was about to write: found the problem for skein, there shouldn’t be a space before the second " in lines 139 140 141, but Felipe fixed the package before
05:34:40 <mauke> Oxfaded: I don't understand your question. example?
05:34:50 <byorgey> @unmtl StateT String []
05:34:51 <lambdabot> err: `StateT String []' is not applied to enough arguments, giving `/\A. String -> [(A, String)]'
05:34:56 <byorgey> @unmtl StateT String [] a
05:34:57 <lambdabot> String -> [(a, String)]
05:38:15 <byorgey> > evalStateT (replicateM 4 (StateT reads)) "1 23 68 23 987 28" :: [Int]
05:38:16 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:38:17 <lambdabot>         against inferred type ...
05:38:33 <byorgey> > evalStateT (replicateM 4 (StateT reads)) "1 23 68 23 987 28" :: [[Int]]
05:38:34 <lambdabot>   [[1,23,68,23]]
05:39:06 <Oxfaded> foldr (\a b->a b) 0 $ take 10 $ repeat (1+). That basically applys the +1 function 10 times over and returns a cumulative result. Sort of like a poor mans sequence but without monads. Im asking if theres a version of fold were f=(\a b-> a b)
05:39:17 <byorgey> > runStateT (replicateM 4 (StateT reads)) "1 23 68 23 987 28" :: [([Int],String)]
05:39:18 <lambdabot>   [([1,23,68,23]," 987 28")]
05:39:35 <Axman6> :o
05:39:39 <byorgey> Oxfaded: no, there isn't.
05:40:10 <mauke> Oxfaded: again, (\a b -> a b) is just id
05:40:34 <mauke> > iterate (1+) 0 !! 10
05:40:35 <lambdabot>   10
05:40:47 <int-e> > (\a b -> a b) ()
05:40:48 <lambdabot>   Couldn't match expected type `t -> t1' against inferred type `()'
05:41:04 <byorgey> Oxfaded: we were pointing out that you can also do  foldr (.) id $ take 10 $ repeat (1+)  to compose the ten copies of (+1) into one function, which can then be applied to 0.
05:41:23 <Oxfaded> no (\a b -> a b) is of type :: (t1 -> t) -> t1 -> t
05:41:27 <mauke> foldr (.) id (replicate 10 (1+))
05:41:30 <Oxfaded> which is actually $
05:41:33 <mauke> Oxfaded: which is id
05:41:34 <byorgey> > id :: (t1 -> t) -> t1 -> t
05:41:35 <lambdabot>   Overlapping instances for GHC.Show.Show ((t1 -> t) -> t1 -> t)
05:41:35 <lambdabot>    arising f...
05:41:45 <int-e> Oxfaded: but it is  id  with a restricted type.
05:41:46 <mauke> <sipa> a `id` b = (id a) b = a b
05:41:46 <byorgey> Oxfaded: id can have that type as well.
05:42:00 <Oxfaded> ok true that
05:42:02 <Oxfaded> my bad
05:42:16 <byorgey> ($) is just id with a more restrictive type.
05:46:48 <Axman6> oh man, the comments here are apinfully ignorant :( http://developers.slashdot.org/story/11/10/04/1557206/ocaml-for-the-masses
05:47:28 <Axman6> painfully*
05:52:27 <hex___> hey all
05:55:06 <kosmikus> Axman6: :)
06:00:58 <byorgey> hi hex___
06:01:37 <hex___> hey byorgey
06:01:40 <hex___> how r u
06:02:31 <byorgey> hex___: I'm good, and you?
06:02:44 <hex___> great
06:03:04 <hex___> i am trying to learn haskell
06:03:26 <EvanR-work> following to ol' rabbit hole eh
06:03:26 <hex___> i want to use it for some general purpose problem solving
06:03:36 <hex___> yeah
06:03:39 <hex___> EvanR-work:
06:04:40 <EvanR-work> solveProblem :: Problem -> Solution
06:04:43 <EvanR-work> solveProblem = ?
06:05:10 <mauke> solveProblem = think >> writeDown solution
06:05:24 <hex___> like some data analysis problems
06:05:32 <EvanR-work> think >>= writeDown
06:05:34 <EvanR-work> \o/
06:05:50 <hex___> i meant the problem that require computation and thinking is already done
06:06:03 <EvanR-work> let haskell do the thinking
06:06:19 <EvanR-work> import StrongAI
06:06:45 <hex___> wats that?
06:06:54 <EvanR-work> joke
06:07:14 <hex___> was it.. :)
06:07:16 <mauke> import AI.Strong.Lazy
06:09:20 <EvanR-work> import AI.Strong.Bad
06:12:11 <hex___> what you use haskell for on a daily basis?
06:12:20 <geheimdienst> import Al.Bundy
06:12:24 <hex___> mauke EvanR-work byorgey
06:12:25 <geheimdienst> import Al.Jazeera
06:12:56 <mux> import AI.Unsafe.Skynet
06:13:09 <hex___> hi mux
06:13:21 <mux> hi
06:13:45 <moriramar> Excuse me, I am using mtl-2.0.1.0 (and ghc 7.0.4). Where is STT Transformer defined?
06:13:45 <int-e> forever $ forkIO terminator
06:13:57 <hex___> you are new to the language ?
06:14:07 <mux> and here I thought Skynet was implemented using STM ;-)
06:14:19 <mux> hex___: me? not exacty no
06:14:26 <int-e> mux: phew, would that avoid time paradoxes?
06:14:51 <mux> int-e: yes, but the T-1000 gets stuck indefinitely retrying transactions
06:15:20 <hex___> cool, are you working on something related to haskell?
06:15:31 <hex___> mux:
06:15:54 <int-e> moriramar: http://hackage.haskell.org/package/STMonadTrans -- heed the warning.
06:15:59 <mux> hex___: not at the moment
06:16:35 <hex___> mux: have you worked on something in the past?
06:17:03 <hex___> i am just curious ant the kind of projects that r possible ?
06:17:04 <moriramar> int-e, Thanks. And "heed the warning"? where is the warning?
06:17:05 <hex___> abt
06:17:40 <int-e> moriramar: in the package description on that page.
06:17:41 <napping> hex___: most frequently is little scripting stuff, pull data into ghci and work with it
06:17:56 <moriramar> int-e, Oh, you mean the warning in that package... I'm sorry. Thanks again.
06:18:10 <geheimdienst> hex___: haskell is a general-purpose language, in principle it can be used for anything
06:18:35 <napping> most recent bigger thing I did was a client for some http/json web server thing. aeson is pretty nice
06:18:47 <EvanR-work> aeson is boss awesome
06:19:10 <napping> Hmm, compared to json parser/validators I've seen in other languages I'd have to agree
06:19:16 <hex___> great
06:20:05 <napping> Guess I'm just comparing to other Haskell libraries for other things :)
06:21:08 <hpaste_> tsuraan pasted “trivial random server” at http://hpaste.org/52185
06:21:18 <tsuraan_> oops, wrong channel
06:22:26 <hex___> whats the haskell library for http and web protocol handling
06:22:40 <hex___> like opening an http url
06:24:00 <Entroacceptor> network.http
06:24:36 <si14> hi, guys. microbenchmark here: https://gist.github.com/e998884f24228ade8142 any suggestions? please don't hit me, I'm only learning Haskell :)
06:25:13 <napping> I was using http-enumerator, but that might be a bit complicated to start with (its simpleHttp is simple, though)
06:26:05 <Entroacceptor> on that, http://www.haskell.org/haskellwiki/Applications_and_libraries/Network is horribly broken
06:27:32 <napping> si14: you might try -fllvm
06:29:29 <Axman6> si14: use rem instead of mod
06:30:14 <dafis> si14: if you pass -optc-ffast-math, why are you not compiling via C (and then you should also pass -optc-O3)
06:30:31 <Axman6> si14: also, for someone who's just learning haskell, you've made a lot of very good decisions to make that code run fast
06:30:51 <napping> ah, good point. -optc-foo doesn't do much if you don't actually go through the C compiler
06:30:52 <dafis> si14: and, as Axman6 said, rem (and quot) instead of mod (and div)
06:31:12 <napping> I'm not sure Vector actually buys you much here, if you expect it to be fused away anyway
06:31:43 <geheimdienst> si14: you're doing quite well really :) no need to worry
06:31:44 <Axman6> yeah, i hadn't noticed that. the list version might end up being better
06:31:54 <si14> Axman6: well, I'm trying to learn Haskell in many levels :)
06:32:24 <Axman6> si14: try using lists instead of Vector
06:32:32 <si14> napping: list will be fused away too?
06:32:37 <Axman6> yes
06:32:45 <napping> sure, foldr/build
06:33:07 <Axman6> if we had supercompilation... :(
06:33:18 <napping> Vector is good if you actually need materialized arrays
06:33:43 <Axman6> well, it's also good for streaming data processing
06:33:50 <saml> is super compliation good?
06:33:53 <Axman6> it doesn't use arrays internally
06:34:37 <Axman6> saml: well, it can be. it can produce some very nice code (and basically subsumes a lot of optimisations like inlining and fusion [it's sort of fusion on steroids])
06:34:43 <si14> Axman6: AFAIK, supercompilation is on the way to GHC, isn't it?
06:34:51 <saml> is it web scale?
06:35:01 <si14> GHC status report may 2011 states that it well be done in a year or so
06:35:07 <Axman6> saml: it's web 3.1 scale
06:35:25 <Axman6> si14: hmm, i hadn't heard that. i thought it was much more immature than that
06:35:40 <Axman6> it would be lovely if that were true though =)
06:36:06 <si14> http://hackage.haskell.org/trac/ghc/wiki/Status/May11 search here on "supercompilation"
06:36:49 <EvanR-work> its aol 2.0 scale
06:37:41 <EvanR-work> actually 4.0 was the marketing blitz at the time
06:37:45 <EvanR-work> i think
06:37:51 <si14> oh, god! mod->rem and div->quot gave me huge boost!
06:38:13 <Axman6> faster than C? =)
06:38:15 <si14> 0.30 now instead of 0.44
06:38:25 <si14> nope, still not faster :)
06:38:45 <napping> I forget which is which, and which is what C does
06:38:48 <Axman6> yeah, if you know your numbers will always be positive, replacing mod with rem is always a good idea
06:38:49 <si14> is there any way to optimize out this (truncate . sqrt . fromIntegral) ?
06:38:59 <Axman6> napping: i believe C actually does mod
06:39:02 <napping> compiler options don't seem to help much
06:39:57 <geheimdienst> > 26/30
06:39:58 <lambdabot>   0.8666666666666667
06:40:07 <Axman6> si14: have you done any profiling?
06:40:22 <si14> Axman6: not yet. don't know how to do it yet
06:40:41 <geheimdienst> si14: that's really only a 15% difference between haskell and c. i think that's good enough for congratulations
06:41:01 <Axman6> indeed
06:41:10 <Axman6> si14: have you tried using the llvm backend?
06:41:14 <EvanR-work> bah its all big O of 1
06:41:14 <si14> geheimdienst: with -fvia-C it's 0.265 against 0.297. congrats to ghc team :)
06:41:23 <si14> Axman6: nope. I have strange errors
06:41:32 <Axman6> actual errors?
06:41:52 <si14> Axman6: Error: can't resolve `Main_main_srt' {.rodata section} - `Main_main_info' {.text; .text 58# section}
06:42:27 <Axman6> huh, fair enough. might be worth filing a bug.. or something
06:42:30 <hex___> i keep getting this error while trying to import nay module
06:42:32 <hex___> ERROR - Syntax error in expression (unexpected keyword "import")
06:42:34 <si14> weird, now it's ok
06:42:39 <si14> lol
06:42:41 <hex___> whats the problem??
06:42:42 <si14> it's faster than C now
06:42:57 <geheimdienst> @quote monochrom.c
06:42:58 <lambdabot> No quotes match. I've seen penguins that can type better than that.
06:43:02 <napping> strange, -fvia-C didn't seem to help here
06:43:02 <geheimdienst> @quote monochrom
06:43:02 <lambdabot> monochrom says: data DesCarte = forall a. Think a => Exist a
06:43:06 <si14> ah, no. just as good as C
06:43:32 <Axman6> hex___: can we see the code?
06:43:50 <hex___> i am just trying to do
06:43:57 <hex___> import network.http
06:43:59 <geheimdienst> hex___: you can only use import at the beginning of the file, before you start writing functions
06:44:03 <dafis> Axman6: C's % is rem
06:44:30 <si14> updated this one: https://gist.github.com/e998884f24228ade8142
06:44:51 <hex___> i can't write this statement on the interpreter iteself like python
06:45:12 <Axman6> hex___: case is important: import Network.Http
06:45:13 <dafis> @quote monochrom einstein
06:45:14 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
06:45:22 <geheimdienst> dafis: yeah, that one :)
06:46:07 <hex___> still the same error
06:46:11 <Axman6> hex___: which ghc are you using?
06:46:12 <hex___> with correct case
06:46:15 <hex___> hugs
06:46:20 <Axman6> urgh
06:46:25 <Axman6> use ghci
06:46:31 <Axman6> hugs is dead, long live ghc
06:46:42 <int-e> napping: isn't -fvia-C a no-op now?
06:46:44 <Axman6> seriously, hugs is junk if you want to do pretty much anything
06:46:45 <hex___> ok let me get it
06:46:54 <si14> oh, god. I've screwed tests, it was C results :) 0.266 against 0.297 though
06:46:59 <Axman6> hex___: just install the haskell platform
06:47:04 <napping> could be. It certainly warns me it's going away soon
06:47:25 <Axman6> yeah i believe the -fvia-C option has been removed now
06:47:40 <int-e> napping: (according to the release notes, as of ghc 7.2.1. sorry for the privmsg)
06:47:41 <Axman6> which is annoying for some, because it was the easiest way to port ghc to new architectures
06:47:41 <dafis> int-e: as of 7.2
06:48:16 <napping> ah, I'm still running 7.0.4
06:48:34 <dafis> napping: the effect of -fvia-C is very platform and gcc dependent
06:48:41 <erkin> Hello, a newbie question here. I'm trying to pipe the output of getEnvironment to writeFile. I tried {getEnvironment >>= writeFile "info.txt"} and {env <- get Environment ; writeFile getEnvironment "info.txt"} but it doesn't work.
06:49:00 <int-e> Axman6: I thought unregisterised builds still sort-of worked? Maybe I misunderstood.
06:49:01 <erkin> Presumably because writeFile needs a string to write and getEnvironment outputs tuples.
06:49:03 <geheimdienst> :t getEnvironment
06:49:04 <lambdabot> Not in scope: `getEnvironment'
06:49:05 <ion> @hoogle getEnvironment
06:49:06 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
06:49:11 <ion> @hoogle writeFile
06:49:12 <lambdabot> Prelude writeFile :: FilePath -> String -> IO ()
06:49:12 <lambdabot> Data.ByteString writeFile :: FilePath -> ByteString -> IO ()
06:49:12 <lambdabot> System.IO writeFile :: FilePath -> String -> IO ()
06:49:33 <Clint> what would be a sane way to use a [Field] (as in http://hackage.haskell.org/packages/archive/hsemail/1.7.1/doc/html/Text-ParserCombinators-Parsec-Rfc2822.html#t:Field ) as a map?
06:49:34 <ion> getEnvironment results in [(String, String)], writeFile name wants a String.
06:49:38 <erkin> So how can I convert the output into string?
06:49:38 <Axman6> int-e: that's all well and good, unless you need to target a new architecture
06:49:48 <geheimdienst> erkin: "show" is the function that converts things to Strings
06:49:58 <erkin> Thank you! I'll try that.
06:50:03 <geheimdienst> > show 42 -- converts Int to String
06:50:04 <lambdabot>   "42"
06:50:17 <ion> eger
06:50:19 <geheimdienst> > show (42,"lolcats") -- converts Tuple with an Int to String
06:50:20 <lambdabot>   "(42,\"lolcats\")"
06:50:24 <ion> eger
06:52:38 <EvanR-work> > read "(42,\"lolcats\")" :: (Int,String)
06:52:39 <lambdabot>   (42,"lolcats")
06:52:46 <EvanR-work> > read "(42,\"lolcats\")" :: Bool
06:52:47 <lambdabot>   *Exception: Prelude.read: no parse
06:53:26 <EvanR-work> parsing should be abolished, data should never leave its true form
06:53:52 <mauke> stringly typed languages
06:54:11 <tac-tics> EvanR: Then how would we marshall between categories?
06:54:20 <tac-tics> From language to language?
06:54:24 <tac-tics> Or from server to server?
06:54:55 <EvanR-work> the internet needs to support more modes than octet
06:55:00 <tac-tics> Perhaps string representations have their place, but their data type ought to be abstract
06:55:04 <Axman6> > read "1" :: Bool
06:55:05 <lambdabot>   *Exception: Prelude.read: no parse
06:55:10 <hex___> is their any option for a python like interpreter in ghci haskell-platform
06:55:25 <EvanR-work> if its text, its text. if its not, its not
06:55:33 <Axman6> what do you mean by python like interpreter?
06:55:36 <si14> Axman6: https://gist.github.com/e0defca3c750efeeeb36 list version is way worse
06:56:19 <hex___> the interactive interpreter
06:56:20 <Axman6> ghci is the interactive interpreter
06:56:24 <hex___> type python on your terminal, if you are on  linux
06:56:38 <hex___> got it
06:56:39 <Axman6> it stands for the Glasgow Haskell Compiler Interpreter
06:56:41 <hex___> thanx
06:56:58 <mauke> I'll interpret your compiler
06:57:10 <Axman6> or is it interactive
06:57:11 <Axman6> hmm
06:57:13 <applicative> > gcc
06:57:14 <lambdabot>   Not in scope: `gcc'
06:57:16 <Axman6> anyway, it does what you want
06:57:20 <applicative> right
06:57:36 <hex___> yeah
06:57:36 * Axman6 -> sleep
06:57:49 <Axman6> got an interview in the morning, i've already stayed up far too late >_____<
06:57:59 <applicative> Axman6, did you see how the thread ring entry is doing on the shootout lately?
06:58:32 <Axman6> no?
06:58:41 <Axman6> i remember that the C version cheats =)
06:59:01 <Axman6> and does what we were forbidden from doing basically
06:59:07 <applicative> yours is crushing C
06:59:21 <applicative> point it out at the interview :)
06:59:23 <Axman6> yeah? whoot! =D
06:59:31 <Axman6> ha, good call =)
07:00:02 <applicative> http://shootout.alioth.debian.org/u64q/performance.php?test=threadring
07:00:10 <Axman6> ha HA! beating Go too
07:00:25 <mauke> go too considered harmful
07:00:32 <EvanR-work> lool
07:00:45 <byorgey> go too considered harm, fool
07:00:46 <tac-tics> call/cc considered useless
07:00:50 <Axman6> @remember mauke Go too considered harmful
07:00:50 <lambdabot> Good to know.
07:02:02 <geheimdienst> uh, is that right? haskell is not a little faster than c, it's 20x faster? :-o woah
07:02:08 <geheimdienst> Axman6 ftw
07:02:46 <Axman6> applicative: huh, i wonder what happened to the cooperative """Threading""" C version they sued to have, that was imo cheating?
07:03:05 <Axman6> geheimdienst: everyone knows the best haskellers are from Australia
07:03:37 <int-e> geheimdienst: yeah, suffering from lack of light-weight thread support
07:04:18 <int-e> Axman6: I imagine that with a bit of tuning, gcc will compile away all the loops and it'll run in constant time :-P
07:05:12 <Axman6> int-e: well, i think that's not too far off what was happening with the I Can't Believe They're Not Co-routines version they had a while ago.
07:05:30 <Axman6> also, it's worth noting that the haskell one compiled with -threaded is significantly faster
07:05:38 <Axman6> without -threaded*
07:05:47 <int-e> Axman6: is it the one listed under "interesting alternative programs"?
07:06:10 <Axman6> the C++ one?
07:06:13 <roconnor> anyone know anything about ATS?
07:06:41 <copumpkin> hongwei xi does
07:06:43 <geheimdienst> roconnor: some kind of c-like thing with moar type system
07:06:45 <Axman6> roconnor: it's crazy
07:07:01 <Axman6> it's got a dependant type system
07:07:07 <Axman6> but, you can also embed C in it
07:07:22 <roconnor> that sounds impressive
07:07:36 <roconnor> I didn't think mutability and dependent types mixed very well
07:07:39 <napping> It's got linear types too, I think
07:07:56 <napping> It's like, let's add ALL the extensions
07:08:00 <Axman6> let me show you the implementation of insert sort, that is proven by the type system
07:08:14 <napping> I've been meaning to learn it, looks interesting if messy
07:08:17 <Axman6> napping: \o~/
07:08:58 <KirinDave> Wow
07:09:04 <KirinDave> Haskell beats Erlang on thread ring?
07:09:09 <KirinDave> Context switching like woah.
07:09:17 <bscarlet> my "Debug.Trace.trace" seems to mangle at least some non-ascii. Is this normal? If so, is there any workaround?
07:09:39 <c_wraith> thread ring is *really* good for haskell.  It's exactly what MVars were designed to do.
07:09:43 <napping> KirinDave: I think some of that comes down to defaults - erlang gets bigger stacks by default and stuff
07:09:49 <roconnor> bscarlet: could it be an improperly set encoding on stderr?
07:09:57 <KirinDave> napping: I am not sure that'd be it.
07:10:15 <KirinDave> napping: Erlang is _really_ good at starting new threads.
07:10:24 <KirinDave> Err, new actors
07:10:33 <Axman6> roconnor: quicksort, verified by the type system: http://www.cs.bu.edu/~hwxi/ATS/EXAMPLE/MISC/listquicksort.dats
07:10:53 <bscarlet> roconnor: Not sure, but I don't think so. I get different results from putStrLn & trace even after using hSetEncoding to set both stdout and stderr to utf8.
07:10:59 <Axman6> KirinDave: haskell's threads are even more hightweight
07:11:09 <napping> KirinDave: so is GHC
07:11:09 <c_wraith> KirinDave: it most comes from the scheduler being very tightly integrated with MVars.  Everything blocked on reading from an MVar isn't even scheduled to run.
07:11:17 <roconnor> Axman6: in place quicksort?
07:11:36 <Axman6> i'm not sure
07:11:59 <KirinDave> c_wraith: How would it do with tvars?
07:12:11 <applicative> the idea of a dependently typed in place sort is difficult, but fine
07:12:11 <Axman6> c_wraith: the other important part is that writing to an MVar causes the schedualer to wake up a waiting thread
07:12:26 <KirinDave> I know tvars are written in terms of mvars, so...
07:12:28 <napping> All this sounds like it should go for erlang threads and mailboxes
07:12:39 <c_wraith> KirinDave: TVars are *not* in terms of MVars
07:12:45 <bscarlet> > putStrLn "≠"
07:12:46 <lambdabot>   <IO ()>
07:12:51 <KirinDave> c_wraith: I thought I read that it was so?
07:13:02 <dmwit> bscarlet: Weird. Perhaps you can just encode the String yourself before calling trace as a workaround.
07:13:04 <KirinDave> I am really curious how well tvars and friends scale.
07:13:06 <c_wraith> KirinDave: Not at all.  STM is very different internally
07:13:40 <Axman6> KirinDave: they're not exactly designed for speed (though i don't know if they're slow or not)
07:13:58 <Axman6> :t let x = return (\y -> x) in x
07:13:59 <lambdabot>     Occurs check: cannot construct the infinite type: t = m (t1 -> t)
07:13:59 <lambdabot>       Expected type: t
07:13:59 <lambdabot>       Inferred type: m (t1 -> t)
07:14:08 <ion> mm_freak: In the example at <http://www.haskell.org/haskellwiki/Netwire#Using_a_wire> stepWire is called in an infinite loop. How does one model e.g. an IRC library (or anything where you get discrete events from somewhere and also need to implement network timeouts etc.) using NetWire? I take it an infinite loop doing mostly nothing is not involved? Please excuse my ignorance, i haven’t really grasped the concept yet. :-)
07:14:21 <bscarlet> dmwit: perhaps. But the whole idea of thinking of encoded strings as strings instead of [Word8] violates _my_ type system, if not that of most Haskell libraries. Thanks though.
07:14:23 <KirinDave> I mean, if I'm writing a server that needs to serve http requests at 10k r/s
07:14:29 <KirinDave> Is using a tvar automatically going to kill that?
07:14:34 <dmwit> bscarlet: I totally agree with you.
07:14:34 <c_wraith> KirinDave: STM might do ok for the thread ring benchmark, just because there's no contention in it.  In general, STM is great when there's low contention, but horrible when there's high contention.'
07:14:55 <Axman6> KirinDave: probably not. but if you only use a single tvar, then MVars are probably a better fit
07:15:16 <c_wraith> KirinDave: though that isn't an inherent property of STM, just GHC's implementation of it
07:15:18 <napping> KirinDave: there was a paper comparing things
07:15:22 <Axman6> STM should be used when you need to execute transactions involving multiple mutable variables that need to be atomic
07:15:24 <dmwit> bscarlet: Legacy's a bitch, ain't it?
07:15:53 <KirinDave> Well if there is contention on resources
07:16:00 <KirinDave> there aren't "fast" solutions.
07:16:19 <c_wraith> yes, but STM is worse than just coarse locking when there's high contention.
07:16:24 <KirinDave> Unless you can cheat like how you segment locking and lookup in non-blocking hash maps.
07:16:37 <c_wraith> because STM ends up with each transaction retrying simultaneously.  It can potentially livelock
07:16:58 <c_wraith> where coarse locking will always make progress, though perhaps at the cost of potential concurrency
07:16:59 <KirinDave> c_wraith: Haskell's solution doesn't necessarily force you into that, though?
07:17:08 <napping> In short, TMVars and such are a tiny bit slower than the non-STM versions on mircobenchmarks, but being able to actually combine operations seems to make up for that on even slightly larger programs
07:17:38 <Axman6> STM is magic, but not for performance.
07:17:44 <napping> c_wraith: GHC's implementation will not livelock. The only thing that can abort a transaction is another completing
07:18:01 <napping> you can starve a long-running transaction, but that's a different story
07:18:02 <Axman6> you use it for systems when being a bit slower is ok, but having inconsistant state is intollerable
07:18:48 <KirinDave> I understand there are these technical concerns, and I want to know them
07:18:54 <napping> (well, a transaction can retry itself, but that's not what I meant - and that puts the thread to sleep until a relevent TVar changes, so that wouldn't be livelock)
07:19:01 <KirinDave> But my big question is, when people write realistic concurrent apps what ends up happening?
07:19:28 <KirinDave> Does Snap or Yesod use STM?
07:19:31 <Axman6> when writing any large scale concurrent app, you need to minimise contention
07:19:39 <Axman6> i doubt it, there's no need to
07:19:53 <Axman6> but you can use STM when using Snap or Yesod
07:20:05 <KirinDave> I mean, I wrote this
07:20:05 <KirinDave> https://github.com/KirinDave/redis-conduit/blob/master/Tap/Redis.hs
07:20:08 <c_wraith> napping: I'm pretty sure a transaction will abort whenever it's not the only thing that's modified a TVar it wants to use when it tries to commit.  And because GHC lacks MVCC, anything else writing to the TVar, whether it commits or not, will show up.
07:20:08 <KirinDave> And I got it going fairly fast
07:20:20 <KirinDave> But never up to really truly high volumes
07:20:23 <bscarlet> dmwit: Yeah. Though well chosen communication can help. Renaming bad API's to include "Legacy" in the (new) name can be a surprisingly effective motivator.
07:20:51 <napping> c_wraith: updates to TVars are only published on commit, so if a TVar it wants has changed, that's because some other thread made some progress.
07:21:05 <Axman6> KirinDave: are you using a single tvar?
07:21:17 <napping> Doesn't mean performance can't crash, but it's not livelock
07:21:22 <EvanR-work> bscarlet: i prefer to name such codebases using combinations of "shitty" and "fucking retarded"
07:21:22 <c_wraith> ok, it won't livelock.
07:21:45 <KirinDave> Axman6: Here, I am. But there may be multiple redis consumers into one tvar.
07:21:59 <KirinDave> Axman6: I actually question if mvars really would be faster for this.
07:22:07 <Axman6> KirinDave: because if you are, i would strongly consider using IORefs and atomicModifyIORef
07:22:14 <c_wraith> But the failure state for STM is still "ever-growing number of transactions retrying, causing even more retrying"
07:22:19 <Axman6> which will almost certainly be faster
07:22:21 <roconnor> I was going to say, nothing is faster than atomicModifyIORef :D
07:22:24 <c_wraith> Axman6: atomicModifyIORef isn't better
07:22:32 <KirinDave> Don't stm transactions occur asynchronously?
07:22:33 <Axman6> c_wraith: it's faster
07:22:38 <c_wraith> it has the exact same failure state under load
07:22:40 <napping> again, a transaction that retries hasn't messed up anything that will make others retry
07:23:13 <Axman6> c_wraith: what do you mean? we're not down to just contention of a shared resource, which cannot be avoided
07:23:22 <KirinDave> Axman6: If the reading and parsing is longer than the time to commit, then an asynchronous approach will be faster.
07:23:26 <Axman6> now*
07:23:41 <c_wraith> napping: no, it causes ever-more retrying because there are even more threads scheduled to run, meaning that performance degrades much faster.
07:23:54 <Axman6> KirinDave: i have no idea what you mean by that
07:24:19 <KirinDave> I bet we could even do better, since the operation is append only for the writers. :\
07:24:34 <Axman6> but it should be noted that the time taken for atomicModifyIORef is not much more than an atomic test and set/atomic compare and swap instruction
07:24:45 <c_wraith> Axman6: no, because being blocked on an MVar causes the thread to be descheduled, they can't get into that situation.  Only one thread will ever be running at once.  This prevents you from getting into a situation where the number of threads churning keeps increasing.
07:24:46 <KirinDave> Axman6: That might be faster, I guess.
07:25:03 <mm_freak> ion: see how the webwire library does it…  you can well have a wire, which is only stepped when something actually happens
07:25:27 <ion> mm_freak: Will look, thanks.
07:25:35 <Axman6> c_wraith: who said anything about blocking?
07:25:49 <mm_freak> ion: this influences the time delta and hence also the frames per second…  a high frame is useful for games and simulations, while a network application doesn't necessarily need one
07:25:52 <c_wraith> Axman6: I did.  It's the key reason MVar performs better than STM or atomicModifyIORef under load
07:25:55 <Axman6> IORefs with atomicModifyIORef completely avoid blocking
07:26:05 <c_wraith> Axman6: because they busy-loop instead
07:26:09 <KirinDave> Yeah
07:26:11 <KirinDave> spinlock.
07:26:14 <mm_freak> ion: it has no other influence, and you can model your application without using time at all, because you still get mutating computations
07:26:22 <KirinDave> It's just like Java's AtomicRef.
07:26:35 <Axman6> c_wraith: but only N threads will be busy looping, where N is the number of cores
07:26:38 <KirinDave> Albeit in a faster execution environment.
07:26:42 <ion> mm_freak: Will the network timeouts and sockets be handled outside the wire? (How else do you step the wire only when you need to handle a timeout?)
07:26:46 <mm_freak> ion: see also the latest Session module, because the interface has changed a lot since the original 1.0.0 release
07:26:50 <Axman6> there will be progress made
07:27:04 <c_wraith> Axman6: there will be progress made, but it will slow as the number of threads being scheduled slows
07:27:17 <mm_freak> ion: this is up to you…  you can handle network input as part of the wire, but in the case of IRC i wouldn't do it
07:27:22 <c_wraith> Axman6: because it depends on the ghc scheduler, *not* the number of cores
07:27:44 <Axman6> why does it depend on the schedualer?
07:27:46 <mm_freak> ion: in my new library a separate haskell thread handles input, and the wire will handle output
07:27:51 <c_wraith> Axman6: creating the thunk used in the atomic CAS operation is an allocation, which allows the scheduler to change threads
07:28:10 <ion> mm_freak: Does the input thread run timers of some kind for timeouts?
07:28:21 <mm_freak> ion: it uses a custom enumerator
07:28:36 <mm_freak> ion: i suggest following my ANN posts on the -cafe list
07:28:46 <ion> mm_freak: Thanks, i’ll check them out.
07:28:49 <mm_freak> they should be very useful, if you plan to use netwire for networking
07:29:09 <napping> High contention is always a problem. TMVars also lead to blocked threads, if that's useful
07:29:16 <Axman6> c_wraith: and when it gets swapped back it, it executes the CAS, and moves on, and all threads contending do the same thing...
07:29:31 <napping> If you have high enough contention that a simple CAS is failing, you have bigger problems than the CAS failing
07:29:40 <Axman6> indeed
07:29:45 <c_wraith> Axman6: And if the thing it switched to updated the contents of the IORef, the CAS fails, and it retries.
07:29:51 <c_wraith> trust me, I've replicated this situation
07:29:57 <mm_freak> ion: btw, don't use the Concurrent module…  i haven't tested it thoroughly, and i suspect that it may be broken right now
07:29:57 <Axman6> hmm
07:30:00 <c_wraith> The performance crashes hard
07:30:17 <c_wraith> MVars, because they don't block,  avoid that crash, even if they're a bit slower overall
07:30:19 <Axman6> simon marlow's research seems to show otherwise
07:30:29 <Axman6> maybe that's true
07:30:31 <mm_freak> ion: not broken in that it doesn't work, but it will have different time semantics than the normal Arrow combinators
07:30:40 <c_wraith> err, because they *do* block
07:30:51 <napping> Did you try TMVar?
07:31:26 <ion> Just getting a grasp of FRP would be a nice start so i could use them if appropriate in future projects. The IRC protocol would be a nice, familiar example of doing stuff such as stepping the wire for network input and timeout handling, how to handle multiple servers and channels etc, any of which might provide some insights.
07:31:36 <c_wraith> napping: no, but in the coarse locking situation (there was only a single resource being accessed), I don't see that doing better than MVars.  Even if it didn't do worse.
07:31:43 <napping> It should be a bit slower than MVAR, but otherwise behave the same
07:33:35 <Axman6> anyway, sleep time for me! g'night all
07:33:45 <geheimdienst> g'night Axman6
07:34:27 <napping> I think the general question was whether STM is a good first recommendation for concurrency
07:35:19 <napping> You don't have to go outside STM to get blocking if that's what you need, but maybe you are saying that sticking to MVars will avoid contention being a problem in the first place?
07:35:59 <c_wraith> and my answer for STM being a good idea is "with the current implementation, only if you have a bunch of values you want to update small subsets of atomically"
07:36:00 <napping> also, I'm curious what you did that overloaded atomicModifyIORef. Something remotely realistic?
07:36:28 <c_wraith> load testing on an http server that was tracking the number of concurrent connections to it in a shared data structure
07:37:17 <c_wraith> It would hold up fine for 30 seconds or so, then just fall into ever-increasing slowness in response time, and ever-growing memory use
07:38:01 <napping> Sounds more like thunks accumulating, than the CAS actually failing
07:38:16 <c_wraith> I eventually tracked it to code using STM.  I tried going to atomicModifyIORef
07:38:20 <c_wraith> same issue
07:38:34 <c_wraith> I switched it to an MVar, and it stopped failing like that.
07:38:59 <mm_freak> ion: in its very simplest form a signal function has this type:  newtype SF a b = Time -> a -> (b, SF a b)
07:39:27 <mm_freak> it's a function, which receives the time delta to the last instant and an input…  it produces an output value and a new signal function, which should replace the current one
07:39:31 <napping> atomicModifyIORef wouldn't need to reallocate on a retry
07:39:38 <mm_freak> knowing this it is very simple to implement, for example, a local clock
07:39:51 <mm_freak> uhm…  add a constructor to that type
07:39:55 <c_wraith> napping: yes it does, it needs to create a new thunk because the argument would have changed
07:40:23 <napping> Maybe it does reallocate, but it's a primitive so it should be able to just overwrite the pointer in place
07:40:42 <c_wraith> hmm.  That's probably an optimization it doesn't have.
07:40:54 <mm_freak> ion: clock :: Time -> SF a Time; clock t' = SF (\dt _ -> let t = t' + dt in (t, clock t))
07:41:03 <c_wraith> I'm pretty sure the code at the moment is just a simple loop if the CAS fails
07:41:09 <napping> could be
07:41:19 <napping> anway, it's CASing in an unevaluated thunk
07:41:24 <napping> are you sure it wasn't those building up?
07:41:26 <mm_freak> ion: netwire really just extends this model to have a monad under the hood and allow signal inhibition (Either SomeException b) instead of just 'b'
07:42:12 <mm_freak> 'Wire m a b' models this:  Time -> a -> m (Either SomeException b, Wire m a b)
07:42:15 <napping> if it was thunks piling up, working on the CAS wouldn't help
07:42:37 <napping> (STM could maybe grow some heuristics about switching to conservative locking)
07:42:40 <c_wraith> napping: yes.  Until the failure point, memory use was flat.  After the failure point, the growth rate was pretty steep.  If it was just thunks building up, memory use should never have been flat
07:42:46 <mm_freak> ion: this is the basic idea of AFRP
07:43:32 <napping> hmm, I don't follow. I'm thinking a failure mode like this -
07:43:52 <mm_freak> ion: you will notice that 'timeFrom' in netwire is implemented like this 'clock' basically
07:44:07 <ion> mm_freak: Alright, thanks.
07:44:40 <napping> thread that consumes the tracking data peeks a it, wants to look something up, finds that it needs to force say 5 inserts. Finishes that, gets data out, logs it or whatever, goes to read again - now 10 insert thunks piled up. Forces them more slowly, writes the log, goes back - now 20, etc.
07:45:27 <c_wraith> napping: that's not consistent with how atomicModifyIORef works, though.
07:45:32 <napping> no?
07:45:53 <c_wraith> The function in question isn't evaluated, as you pointed out
07:45:57 <applicative> are there any simple example modules using netwire?  we weak minded un-FRPish types could do with a few I think.
07:46:05 <c_wraith> so how long it takes should be irrelevant
07:47:23 <napping> But that controlls how much work will be foisted onto the thread that finally does look at it. And if that thread is slowed down by the evaluation, there will be more time for more thunks to pile up in the IORef
07:47:56 <napping> Sounds like a nice testcase you have, did you send it in?
07:48:26 <napping> My theory could be tested by throwing a readIORef r >>= evaluate after the atomicModifyIORef
07:48:26 <c_wraith> napping: it was fiddly, and part of a *huge* amount of company code.  There was no sane way to reduce it.
07:48:52 * hackagebot parsec-numbers 0.0.2 - Utilities for parsing numbers from strings  http://hackage.haskell.org/package/parsec-numbers-0.0.2 (ChristianMaeder)
07:48:59 <c_wraith> You know, I think I did something like that, in order to prevent thunk leaks anyway.
07:49:40 <c_wraith> though atomicModifyIORef gives you an easier way to do that, in terms of returning (x, x) and just evaluating the return from it
07:50:46 <napping> hmm, interesting. I'll take a peek at the atomicModifyMutVar# code sometime
07:57:28 <dylukes> I have something of a dilemma.
07:57:51 <dylukes> I've defined a PrettyPrintable class for my AST objects:
07:57:51 <dylukes> class PrettyPrintable a where
07:57:54 <dylukes>   pretty :: a -> Doc
07:58:04 <dylukes> now... every single show instance is the same.
07:58:08 <dylukes> show = render . pretty
07:58:10 <dylukes> but I can't do
07:58:17 <dylukes> instance (PrettyPrintable a) => Show a \
07:58:18 <dylukes> :<
07:59:20 <mm_freak> dylukes: it wants undecidable instances, right?
07:59:24 <dylukes> yeah
07:59:32 <dylukes> but when I have them I get overlapping instances for stuff like ByteString :<
07:59:41 <dylukes> Which is weird, because ByteString isn't PrettyPrintable
08:00:16 <Phyx-> ghc doesn't look at the head
08:00:38 <zygoloid> dylukes: "instance (PrettyPrintable a) => Show a" means 'every type 'a' is an instance of Show. if you use a method of Show, a PrettyPrintable a instance must be available'
08:01:05 <zygoloid> it does not mean 'every type 'a' satisfying 'PrettyPrintable a' is an instance of Show'
08:01:06 <dylukes> But what I want to say is
08:01:10 <dylukes> so I want
08:01:10 <mm_freak> dylukes: to avoid that you can write a wrapper type
08:01:18 <mm_freak> newtype PrettyPrint a = PrettyPrint a
08:01:27 <dylukes> Yeah, I realize now what I "want" is existentials... eep.
08:01:31 <mm_freak> instance PrettyPrintable a => Show (PrettyPrint a)
08:01:43 <dylukes> yes, but then I'd have to wrap in PrettyPrint
08:01:47 <mm_freak> yes
08:02:09 <zygoloid> are you writing these PrettyPrintable instances by hand, or generating them somehow?
08:02:45 <mm_freak> dylukes: generally you should try to code type level algorithms to save typing…  it would be great, but unfortunately it doesn't work well in haskell
08:03:07 <mm_freak> s/should/shouldn't/
08:03:10 <dylukes> zygoloid: by hand.
08:03:21 <dylukes> I just want PrettyPrintable a to imply Show a
08:03:23 <dylukes> :\
08:04:01 <mm_freak> you can't without introducing a lot of problems
08:04:09 <dylukes> ble
08:04:12 <dylukes> brb
08:04:26 <zygoloid> dylukes: you should write Show instances for each type by hand too. but that's not so bad. define showsPrecPretty = {-...-}, then just write instance <whatever> where showsPrec = showsPrecPretty
08:04:28 <mm_freak> however, you can write your own Show class
08:04:49 <zygoloid> although non-derived Show instances are a little suspicious anyway
08:05:06 <mm_freak> class Show a => MyShow a where myShow :: PrettyPrintable a => a -> String
08:05:06 <zygoloid> (as in, you're probably using Show for something it's not meant for)
08:05:09 <mm_freak> that might work
08:05:23 <mm_freak> you will still have to provide the instances, but they can be empty
08:05:33 <mm_freak> just 'instance MyShow MyType'
08:06:30 <mm_freak> or you can wait for the ConstraintKinds extension, which will give you a few new possibilities =)
08:06:31 <dylukes> :\
08:06:35 <dylukes> Why was it you can't again?
08:06:57 <mm_freak> because you introduce ambiguity and make the instance inference process undecidable
08:07:04 <dylukes> :<
08:07:13 <dylukes> and half our GHC extensions DONT?
08:07:37 <mm_freak> as zygoloid said,  "instance X a => Y a" is not "every type which is an instance of X is also an instance of Y"
08:07:50 <mm_freak> it's "every type is an instance of Y"
08:09:01 <mm_freak> dylukes: the problem is:  even if it were to work like you intended it to, instances are always exported and nothing stops another module from writing a custom instance
08:09:31 <mm_freak> or, rather, that's /one/ of the problems
08:09:54 <parcs> mm_freak: do you have any documentation on how to use your netwire library?
08:10:02 <dylukes> well, I'm always just printing via the top level Program
08:10:13 <dylukes> so, I'll just write the show instance for that
08:10:31 <mm_freak> parcs: only outdated =/
08:10:48 <mm_freak> parcs: prior AFRP experience assumed?
08:11:04 <parcs> a for arrow? nope
08:11:15 <parcs> i'm comfortable with frp though
08:11:45 <mm_freak> too bad…  well, get comfortable with AFRP (a = arrowized), then you can easily learn the library from the haddock docs
08:12:03 <mm_freak> i'd recommend reading the Netwire wiki page
08:12:15 <mm_freak> it's for version 1.0.0, but it gives you the basic idea
08:12:21 <parcs> okay
08:12:37 <mm_freak> after that read the -cafe posts to get up to date
08:15:11 <mm_freak> i wonder how efficient the NominalDiffTime type is compared to Double
08:17:43 <c_wraith> isn't it just a newtype?
08:18:24 <quicksilver> mm_freak: it's based on Integer, so accurate but quite inefficient, relatively.
08:18:27 <parcs> it's a Fixed Pico which is an Integer
08:18:33 <c_wraith> ah
08:18:35 <mm_freak> ok, thanks
08:18:40 <mm_freak> @src NominalDiffTime
08:18:40 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:18:50 <mm_freak> lol
08:18:58 * quicksilver remarks that @src is useless and should be removed.
08:19:24 <quicksilver> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/time-1.2.0.3/src/Data-Time-Clock-UTC.html#NominalDiffTime
08:19:26 <c_wraith> it was once good for confusing people with @src IO
08:19:36 <mm_freak> @src IO
08:19:37 <lambdabot> Source not found. I feel much better now.
08:19:48 <c_wraith> @src ST
08:19:48 <lambdabot> newtype ST s a = ST (STRep s a)
08:19:53 <mm_freak> ok, lambdabot feels better for not confusing people so much anymore
08:26:36 <rwbarton> @src STRep
08:26:36 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
08:27:04 <rwbarton> what did @src IO use to say, someting along those lines?
08:27:18 <rwbarton> or just IO = ST RealWorld perhaps
08:27:22 <mm_freak> probably just ST RealWorld
08:28:52 * hackagebot xml-enumerator 0.4.2 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.4.2 (MichaelSnoyman)
08:30:48 <si14> guys, interesting question: is there unboxed int64?
08:30:53 <si14> in GHC, I mean
08:32:21 <rostayob> si14: you can use UNPACK
08:33:27 <rostayob> si14: Dopo il verdetto Amanda è scoppiata in lacrime. Poi ha abbracciato la seconda classificata.
08:33:38 <rostayob> oops, i meant this http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#unpack-pragma
08:33:53 * hackagebot statistics-linreg 0.2.1 - Linear regression between two samples, based on the 'statistics' package  http://hackage.haskell.org/package/statistics-linreg-0.2.1 (AlpMestanogullari)
08:34:02 <rostayob> the other is a nice joke is you understand italian anyway.
08:34:07 <si14> yeah, thanks.
08:34:49 <byorgey> si14: note that Int64 is defined as  = I64# Int64#
08:35:10 <rostayob> so yeah it's unboxed already
08:35:10 <byorgey> si14: Int64# is GHC's built-in unboxed 64-bit Int type
08:35:24 <rostayob> he probably meant in an ADT anyway
08:35:36 <si14> byorgey: then it's strange
08:35:53 <byorgey> si14: what's strange?
08:36:09 <si14> byorgey: I've found that in this https://gist.github.com/4bc37edb01ab466e709d code replacing Int with Int64 makes program run 40% slower
08:36:36 <rostayob> si14: that is indeed strange afaik GHC ints are 64 bits already
08:36:41 <byorgey> si14: is this on a 64-bit or 32-bit architecture?
08:36:47 <rostayob> > sizeOf (undefined :: Int)
08:36:48 <lambdabot>   Not in scope: `sizeOf'
08:36:51 <si14> byorgey: 64 bit with llvm backend
08:36:51 <rostayob> uff
08:37:27 <byorgey> si14: well, we have reached the limit of my knowledge, I don't know much about GHC optimization etc.
08:38:16 <byorgey> si14: if you pass -ddump-simpl to GHC you can see the generated GHC core code
08:38:32 <byorgey> si14: from there you can in theory see what is making the Int64 version slower
08:38:50 <byorgey> hopefully someone else can help you interpret it, because I can't
08:39:51 <napping> ghc-core is a tiny bit nicer than passing all those flags yourself
08:42:03 <dylukes> XD
08:42:16 <dylukes> I wrote a pretty printer for my AST
08:42:31 <trinithis> cool `takeWhileM (const [False, True]) === inits`
08:42:34 <dylukes> https://gist.github.com/1264979
08:42:43 <dylukes> this is what happens when you have too many parens >.>
08:44:42 <byorgey> trinithis: hah, neat =)
08:45:32 <byorgey> dylukes: would 'groom' not suit your needs?
08:45:42 <byorgey> @hackage groom
08:45:43 <lambdabot> http://hackage.haskell.org/package/groom
08:47:42 <joe9> groom is awesome. I use it all the time.
08:48:19 <byorgey> me too.
08:48:31 <byorgey> ezyang++
08:49:54 <byorgey> haha, wow, this whole time I thought the source code for groom would be rather complicated.
08:49:59 <byorgey> turns out it is only 12 lines of code.
08:50:30 <byorgey> it just reuses the parser + pretty-printer from haskell-src-exts
08:50:40 <byorgey> =)
08:53:53 * hackagebot xml-enumerator 0.4.2.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.4.2.1 (MichaelSnoyman)
08:58:32 <parcs> mm_freak: great tutorial. do you mind if i edit the complete code example to work with the latest version?
09:00:17 <elliott> Is there a reason there's no modifyTVar v f = readTVar v >>= writeTVar v . f in stm? It seems like an obvious addition to cut down on redundancy.
09:00:52 <joevandyk> I'm just starting to learn haskell.  I find it easiest to learn things by writing small libraries/functions with tests that prove that they work the work I think they should work.  I'm looking at QuickCheck, but I don't understand Haskell enough to use it.  Can someone provide a small sample of a stupid function and a QuickCheck test for it?  And how I can automatically run one or more of them from the command-line?
09:01:11 <joevandyk> I don't want to be typing stuff into ghci all the time
09:01:17 <joevandyk> most examples seem to use ghci
09:01:50 <elliott> @check \s -> reverse (reverse (s :: String)) == s
09:01:51 <lambdabot>   "OK, passed 500 tests."
09:02:01 <elliott> (note that this is not true for all strings :))
09:02:42 <tromp> but for all strings, it is not False
09:03:42 <elliott> true :P
09:03:53 <joevandyk> how can i run a bunch of those from the command line?
09:04:01 <joevandyk> what is @check ?
09:04:08 <tac-tics> joevandyk: Google tells me http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
09:04:22 <tac-tics> Maybe read through that and bring any quesitons you have about it
09:04:25 <joevandyk> tac-tics: i saw that, but it doesn't help
09:04:32 * tac-tics has never personally used quickcheck outside of lambdabot
09:04:39 <joevandyk> how can i run a bunch of quickcheck programs from the command line?
09:05:06 <tac-tics> > quickCheck (\s -> True)
09:05:07 <lambdabot>   Not in scope: `quickCheck'
09:05:10 <tac-tics> hmm
09:05:52 <elliott> joevandyk: you need a test harness of some kind.
09:06:15 <elliott> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#QuickCheck_v2 shows one
09:06:32 <elliott> there's pre-packaged things like chell though, but I don't have any experience with them so I can't help there
09:08:25 <joevandyk> elliott: thanks -- that should get me started.
09:08:46 <elliott> oh test-framework is the "popular" harness I think
09:09:12 <elliott> I know cabal can run a test harness for you but no more detail than that :P
09:11:28 <joevandyk> prop_reversereverse s = (reverse . reverse) s == id s
09:11:28 <joevandyk>     where _ = s :: [Int]
09:11:34 <joevandyk> what is _ ?
09:11:49 <int-e> joevandyk: a pattern that matches anything
09:11:52 <joevandyk> right
09:12:08 <int-e> joevandyk: the point is giving a type for s.
09:12:09 <joevandyk> is there a better way to write that function?
09:12:27 <int-e> give a type signature? prop_reversereverse :: [Int] -> Bool
09:12:28 <joevandyk> prop_reverse :: s::[Int] ?
09:12:37 <sp3ctum_> does _ match patterns that have >1 arguments?
09:13:01 <byorgey> sp3ctum_: what do you mean? patterns do not have arguments
09:13:21 <ststephen> sp3ctum: you mean like a type constructor with multiple args?
09:13:21 <lambdabot> ststephen: You have 1 new message. '/msg lambdabot @messages' to read it.
09:13:28 <sp3ctum> foo a b c has three, but i doubt _ will match all of them
09:13:51 * sp3ctum is slightly confused
09:13:58 <ststephen> you want foo _ _ _
09:14:04 <sp3ctum> yeah
09:14:33 <ststephen> is foo your function? or some kind of type constructor?
09:15:03 <int-e> joevandyk: or use ScopedTypeVariables  and use prop_reversereverse (s :: [Int]) = ...; personally I'd go for the explicit type signature for the function
09:15:38 <ststephen> sp3ctum: if foo is a function with three args and you don't care what they are, you would go "foo _ _ _ = [code]"
09:15:57 <quicksilver> int-e: PatternSignatures, not ScopedTypeVariables?
09:16:05 <ststephen> sp3ctum: if foo is a type constructor and fun is your function, and you wanted to match any foo, you would go "fun (foo _ _ _) = [code]"
09:16:30 <ststephen> sp3ctum: that is, assuming you didn't care what foo's children were
09:17:23 <dafis> quicksilver: PatternSignatures is deprecated, use ScopedTypeVariables
09:17:32 <KaffeeJunky123> hello, is there a function that returns the index of an element of a list in haskell?
09:17:46 <dafis> :t L.elemIndex
09:17:47 <lambdabot> Not in scope: `L.elemIndex'
09:18:08 <int-e> quicksilver: Warning: -XPatternSignatures is deprecated: use -XScopedTypeVariables
09:18:09 <parcs> `where _ = foo :: a` is pretty clever :P
09:18:18 <ststephen> :t Data.List.elemIndex
09:18:19 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
09:18:24 <elliott> parcs: I wonder if that even works
09:18:30 <elliott> seems like defaulting would kick in
09:18:32 <quicksilver> int-e, dafis : weird.
09:18:34 <elliott> and so the parameter would be [Integer] instead
09:18:37 <elliott> oh wait no
09:18:42 <ststephen> KaffeeJunky123: Data.List.elemIndex
09:18:45 <dafis> isn't Data.List L in lambdabot?
09:18:51 <int-e> quicksilver: says ghci 7.0.3, is 7.2.1 different?
09:18:52 <KaffeeJunky123> thank you very much
09:19:04 <quicksilver> int-e: don't ask me, I run 6.10 :)
09:19:07 <ststephen> dafis: i have no idea
09:19:16 <int-e> quicksilver: I should not ask. 7.2.1 is the same.
09:19:16 <ststephen> KaffeeJunky123: yw
09:19:23 <parcs> > let a = 5; _ = a :: Int in typeOf a
09:19:24 <lambdabot>   Integer
09:19:50 <dafis> quicksilver: 6.10??
09:20:00 <whald> hmm, I'm tempted to put IO below my parsec parser, because recently I'm feeling I should be able to reference external files from the file being parsed. these would then be read on demand. but I'm uncertain if that's a good idea, especially in the presence of parsec's "try" -- anyone has some advice on this?
09:20:12 <int-e> (but for some reason I was still using 7.0.3 by default.)
09:20:50 <quicksilver> dafis: there is no compelling reason for me to upgrade GHC version :)
09:21:00 <ststephen> is there a type class for things that act like "containers" - i.e. functions like isEmpty, elem, add, etc?
09:21:51 <dafis> quicksilver: bugfixes?
09:22:29 <ststephen> if there were, I would guess it would need to be multiparameter
09:22:33 <bfig> what is the usual way to go from  m a to  mT m' a ?
09:22:43 <ststephen> like class Container c a where...
09:23:05 <dafis> ststephen: probably better with type families
09:23:19 <bfig> if i want to go from a to MaybeT a i just return a, but if i have a Nothing i can't lift it to the transformer
09:23:38 <ststephen> dafis: whoah! never even heard of those
09:23:46 <ststephen> dafis: this language has so much crazy stuff
09:23:50 <ststephen> dafis: thx
09:25:02 <bfig> nevermind i got it
09:25:27 <joevandyk> I'm doing the 99 haskell problems.    http://www.haskell.org/haskellwiki/99_questions/1_to_10 The first problem is rewriting 'last'.  How can I write a QuickCheck program that tests that an error is raised on an empty list? And that for non-empty lists, the last element in the list is always returned?
09:26:37 <ststephen> joevandyk: myLast [] = error "empty list"
09:27:03 <ststephen> joevandyk: dunno what you mean by QuickCheck
09:27:06 <bfig> :t ask
09:27:08 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
09:27:09 <ClaudiusMaximus> @check \xs x -> last (xs ++ [x]) == x
09:27:11 <lambdabot>   "OK, passed 500 tests."
09:27:15 <bfig> :t asks
09:27:16 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
09:27:26 <benmachine> ststephen: http://hackage.haskell.org/package/QuickCheck
09:27:41 <hey_lu_> :t System.IO.UTF8.readFile
09:27:42 <lambdabot> FilePath -> IO String
09:27:43 <elliott> ststephen: you don't know about quickcheck? :o
09:27:48 <ststephen> benmachine: cool, thanks
09:28:05 <ststephen> elliott: nope checking it out now
09:28:08 <KaffeeJunky123> ststephen: I want to use the elemIndex of a certain element to get an element from another list at the same Index, but the !! operator does not like that D.L.elemIndex is returning a Maybe Int, because it's expecting an Int, does that mean I'll have to write my own function that returns an Int?
09:28:13 <dafis> ClaudiusMaximus: use some more interesting type than ()
09:28:15 <dylukes> byorgey: it might have :0
09:28:18 <dylukes> thanks for the recommendation
09:28:20 <benmachine> joevandyk: kind of tricky; errors like that produced by last [] cannot be inspected from pure code
09:28:42 <dafis> @check \xs x -> last (xs ++ [x]) == (x :: Int)
09:28:43 <lambdabot>   "OK, passed 500 tests."
09:29:03 <joevandyk> benmachine: ok -- so i guess how can i generate a quickquick property for non-empty lists only?
09:29:03 <hpaste_> “functional cockerel” pasted “ko-ko-ko-ko” at http://hpaste.org/52191
09:29:05 <ststephen> KaffeeJunky123: you have to handle both cases - the one where elemIndex returns Just x, and where it returns Nothing
09:29:42 <benmachine> joevandyk: easiest way, generate a list and an element, and cons them together
09:29:50 <dylukes> byorgey: I already wrote a pretty printer though :P
09:29:51 <dafis> KaffeeJunky123: what are you going to do if the thing you look for isn't in the list?
09:29:51 <ststephen> KaffeeJunky123: well, not necessarily both cases but you have to unwrap the Maybe Int to an Int
09:29:54 <KaffeeJunky123> ststephen: oh, okay that makes sense, so I can omit checking if the element is in the list :)
09:30:12 <KaffeeJunky123> because elemIndex already does that
09:30:13 <benmachine> joevandyk: notice that dafis' example will never empty-list error
09:30:17 <ststephen> KaffeeJunky123: yes it does
09:30:31 <ststephen> KaffeeJunky123: when something returns a Maybe that means "i might not actually have one of these for you"
09:30:37 <dylukes> https://gist.github.com/1265111
09:30:38 <dylukes> not bad
09:31:23 <joevandyk> benmachine: dafis: is that the best way to get a quickcheck property for non-empty lists?
09:31:37 <benmachine> I dunno about "best"
09:31:40 <benmachine> but it works :P
09:31:53 <benmachine> I think dafis' test is a sensible one to do
09:32:20 <dafis> benmachine: actually, it was ClaudiusMaximus', I just added a type signature
09:33:02 <dafis> @check \xs -> last xs /= '\b'
09:33:03 <lambdabot>   "*Exception: Prelude.last: empty list
09:33:46 <benmachine> oh right
09:33:49 <benmachine> I silly
09:34:01 <dmwit> ststephen: Did you get my message? (Dunno if lambdabot stayed up long enough to record it properly.)
09:34:43 <ion> @check (NonEmpty xs) -> last xs /= '\b'
09:34:43 <lambdabot>   Parse error at "->" (column 15)
09:34:45 <dylukes> How do I get STG output from GHC?
09:34:47 <ion> @check \(NonEmpty xs) -> last xs /= '\b'
09:34:48 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
09:34:48 <lambdabot>                     (Test.QuickC...
09:35:03 <dmwit> dylukes: I guess you don't; you get Core output from GHC.
09:35:09 <dylukes> you definitely can
09:35:11 <dylukes> I've done it before
09:35:15 <dylukes> I forgot the flag though
09:35:19 <dmwit> ok
09:35:23 <dafis> -ddump-stg?
09:35:50 <joevandyk> Thanks.  I have this code.  https://gist.github.com/1265120  Say I want to write myLast', myLast'', etc (i.e. using recursion).  I don't want to duplicate the quickcheck property for each test.  Best way to do that?
09:36:01 <ststephen> dmwit: yeah i never figured out htf to read it
09:36:16 <dmwit> ststephen: Just type ?messages
09:36:20 <ststephen> ?messages
09:36:21 <lambdabot> You don't have any new messages.
09:36:26 <dmwit> lol
09:36:31 <bfig> how do i unwrap some monad transformers for printing? i'm using a stateful computation and i want to print
09:36:53 <bfig> my type is something like this: MaybeT (Reader Env Int)
09:37:00 <dmwit> ststephen: Perhaps you already /msg'd lambdabot? If so, look for a conversation with lambdabot in your list of IRC interactions.
09:37:12 <ststephen> dmwit: new to irc - how do i access that
09:37:14 <dmwit> ststephen: Anyway, GADTs may allow you to make a Foldable instance for a BinomialHeap
09:37:19 <dmwit> ststephen: Depends on your IRC client.
09:37:31 <bfig> i tried runReaderT ( runMaybeT ( ... ) ) someEnv
09:37:37 <ststephen> dmwit: oh that's cool
09:37:42 <ststephen> dmwit: i'm in a browser right now
09:37:58 <byorgey> bfig: right, and did that not work?
09:38:06 <dmwit> ststephen: For example (of GADTs), something like data BH a where Leaf :: BH a; Bin :: Ord a => a -> BH a -> BH a -> BH a
09:38:31 <dmwit> ststephen: Are there tabs labeled "#haskell", "lambdabot", etc.? Or some such UI element? I would expect there to be.
09:38:39 <bfig> that gave me this byorgey  No instance for (Show (Data.Functor.Identity.Identity (Res Int)))
09:38:39 <bfig>       arising from a use of `print' at <interactive>:1:0-41
09:39:00 <dmwit> bfig: Don't forget to runIdentity!
09:39:11 <ststephen> dmwit: oh thanks! yeah it was a very inconspicuous tab at the top
09:39:12 <bfig> lol, really? :p
09:39:15 * bfig tries
09:39:25 <dmwit> ?hoogle Identity
09:39:26 <lambdabot> module Control.Monad.Identity
09:39:26 <lambdabot> Control.Monad.Identity newtype Identity a
09:39:26 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
09:39:35 <ststephen> dmwit: thank you, i will investigate GADT's
09:39:44 <bfig> not in scope runIdentity
09:39:48 <ion> runIdentity is like unsafePerformIO but for Identity.
09:39:58 <dmwit> bfig: Have you imported Data.Functor.Identity? ;-)
09:40:01 <byorgey> bfig: oh! use runReader, not runReaderT
09:40:08 <ion> Just like unsafePerformIO takes the a out of IO, runIdentity takes the a out of Identity.
09:40:16 <bfig> byorgey, that did it :DDD
09:40:23 <byorgey> bfig: Reader e is defined as ReaderT e Identity, which is why you ended up with an Identity left over
09:40:27 <bfig> yeasssss!!! i finally wrapped my head around this transformer stuff :)
09:40:47 <bfig> took me two weeks of staring at a single line of code but i finally did it
09:40:51 <byorgey> bfig: of course, runReader is essentially defined as runReaderT followed by runIdentity
09:40:56 <byorgey> bfig: awesome!
09:41:02 <bfig> =)
09:41:08 * byorgey gives bfig the Golden Lambda of Persistence Award
09:41:22 * bfig hangs it on the wall
09:41:43 <bfig> learning functional programming is a humbling experience :)
09:42:14 <byorgey> indeed
09:43:04 <dmwit> ststephen: Oh, and as for your question about whether there's a type class for containers... I guess there's a few.
09:43:08 <bfig> the hardest part is to understand how monads connect with all the hidden type polymorphism behind
09:43:11 <dmwit> ?hackage edison springs to mind
09:43:11 <lambdabot> http://hackage.haskell.org/package/edison springs to mind
09:43:39 <dmwit> ?hackage EdisonAPI actually, I guess
09:43:39 <lambdabot> http://hackage.haskell.org/package/EdisonAPI actually, I guess
09:44:01 <dmwit> (And there's EdisonCore for the implementations.)
09:44:19 <ststephen> dmwit: cool
09:44:33 <ststephen> dmwit: this is all just me screwing around with the language, trying to learn more about it
09:44:37 <dmwit> I think edwardk has a few libraries for container-like things, as well, but I can never remember the names of the appropriate packages.
09:45:51 <bfig> :t local
09:45:52 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
09:46:26 <xivix> hey, I trieid to find this in the wiki but I couldn't
09:46:39 <xivix> I read in LYAH that (>>=) is pronounced "bind"
09:47:06 <xivix> are there names for other operators, like (<$>), (<*>), (<|>)?
09:47:24 <benmachine> xivix: <$> is fmap, <*> is generally called ap
09:47:29 <luite> xivix: =<< is pronounced pu!q ;)
09:47:33 <benmachine> I don't know of a common name for <|>
09:47:54 <dmwit> http://haskell.org/haskellwiki/Pronunciation has some, perhaps you should add those ones, benmachine =)
09:48:19 <dylukes> @tell edwardk if you see me online after 6, ping me. I have some parser questions :).
09:48:19 <lambdabot> Consider it noted.
09:48:30 <dmwit> :t (<|>)
09:48:32 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
09:48:41 <dmwit> Maybe "or else" would be a decent pronuncation for that one.
09:49:42 <benmachine> dmwit: it's all a bit subjective
09:49:52 <benmachine> plenty of things on that page I never use, in any case :P
09:51:09 <xivix> at the bottom of the pronunciation page, there's ({)}
09:51:14 <xivix> what the hell is that?
09:51:24 <c_wraith> probably broken wiki markup
09:51:27 <benmachine> no
09:51:33 <benmachine> it's talking about (, {, ), and }
09:54:30 <ststephen> general question: what kind of projects are you guys using haskell for?
09:55:01 <dmwit> Haskell is good for what ails ya.
09:55:20 <frerich_> Hrm, after seeing yet another fancy HTML5 demo I would really like to work on some project which combines Haskell and HTML5.
09:55:34 <ststephen> i'm just interested in how widely used it is for applications, rather than academic stuff
09:55:36 <frerich_> Is there some open source effort or something like that? :)
09:56:19 <dmwit> Personally, I used it to build a daemon to play go for me on DGS; I used it to create a program which launches other programs; and, more infrequently, I hack on xmonad, a window manager.
09:56:42 <dmwit> I also have a half-built game that I swear someday I'm going to pretty up and publish. =P
09:56:44 <frerich_> ststephen: See http://www.haskell.org/haskellwiki/Applications_and_libraries#Haskell_applications_and_libraries
09:57:07 <ststephen> thanks dmwit and frerich_
09:57:27 <ststephen> i'm trying to come up with a cool project for myself, so i can really use it for something
09:57:39 <ststephen> other than implementing my own versions of all the obvious data structurey stuff
09:57:50 <melle> Hi all, noobish question: is it possible to import files relative? I'm reading RWH and I need a file from ch05/ to be included in a file in ch06/
09:58:05 <bfig> how do i divide two integers?
09:58:16 <dmwit> Oh, my homepage reminds me that I also use Haskell to split PDFs for easier Kindle reading, to compose multi-screen background images, and to visualize the Menger sponge.
09:58:18 <KaffeeJunky123> okay, I've now implemented a small toLower function that'll replace uppercase letters with lowercase ones: "toLower str = [if x `elem` ['A'..'Z'] then ['a'..'z']!!Data.Maybe.fromJust(x `Data.List.elemIndex` ['A'..'Z']) else x | x<-str]"  I endet up checking if the elemt exists because I couldn't think of a proper way to handle the case when Data.List.elemIndex returns nothing. Any suggestions how I could facilitate my function?
09:58:25 <dmwit> bfig: `div`, or cast then (/)
09:58:28 <ststephen> bfig: 7 `div` 2 == 3
09:58:31 <bfig> ty
09:58:41 <dmwit> > (3 `div` 4, fromIntegral 3 / fromIntegral 4)
09:58:42 <lambdabot>   (0,0.75)
09:59:58 <dmwit> KaffeeJunky123: Well, I assume this is just for your personal edification; otherwise, you should use the built-in toLower function which handles other Unicode letters slightly more correctly.
10:00:07 <dylukes> Hm :\
10:00:18 <dmwit> KaffeeJunky123: As for implementing it yourself, you might consider doing it the C way: casting to Int and doing arithmetic.
10:00:18 <dylukes> Can you do DataName.ConsName?
10:00:34 <bfig> it worksss!!! muahaahahaha
10:01:44 <KaffeeJunky123> dmwit: I'm just doing this to get more familliar with the whole haskell thing
10:02:01 <dmwit> > let toLower x = if 'A' < x && x < 'Z' then toEnum (fromEnum x - fromEnum 'A' + fromEnum 'a') else x in toLower 'B'
10:02:02 <lambdabot>   'b'
10:02:13 <dafis> > map (\c -> case elemIndex c ['A' .. 'Z'] of Nothing -> c; Just i -> ['a' .. 'z'] !! i) "Hello There"
10:02:14 <lambdabot>   "hello there"
10:02:57 <dafis> KaffeeJunky123: you can scrutinise with a case, or you could use fromMaybe or maybe
10:03:13 <Naresh> hi. what's the difference between these .pkgs: http://hackage.haskell.org/platform/mac.html and http://www.haskell.org/ghc/download_ghc_7_2_1#binaries ?
10:03:35 <dmwit> Naresh: The Haskell Platform includes GHC and a number of "blessed" libraries.
10:04:04 <hey_lu_> hello, how can i read unicode filenames prior to ghc-7.3.*? (System.IO.UTF8 seems not to work...)
10:04:06 <nomeata> Hi. Is there a even more verbose way of checking what happens with GHC’s rules than -ddump-rule-firings -dppr-debug? I’d like to exactly see the expressions replaced.
10:04:06 <Naresh> does it also contain hunit?
10:04:08 <dafis> > map (\c -> maybe c (['a' .. 'z']!!) $ elemIndex c ['A' .. 'Z']) "Hello There"
10:04:09 <lambdabot>   "hello there"
10:05:38 <dylukes> :O
10:09:48 <byorgey> Naresh: yes.
10:09:59 <Naresh> cool, thanks
10:10:28 <byorgey> Naresh: see http://hackage.haskell.org/platform/contents.html and http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/start.html
10:14:41 <joevandyk> what's wrong with this?  https://gist.github.com/1265234
10:14:53 <joevandyk> "Couldn't match type `a' with `[a]'"
10:15:41 <tac-tics> joevandyk: use (x:xs) instead of [x:xs]
10:15:43 <Eelis> joevandyk: that "[x:xs]" doesn't mean what you think it means
10:15:46 <tac-tics> [x:xs] is a list of lists
10:15:50 <joevandyk> son of a bitch
10:15:51 <joevandyk> thanks
10:15:57 <Eelis> joevandyk: let me guess, have you been learning Clean? ;)
10:16:11 <joevandyk> Eelis: no.
10:16:26 <Eelis> ok. [x:xs] is the Clean syntax for (x:xs)
10:16:39 <joevandyk> Ah
10:17:54 <Cale> grr, who decided that State s needs to be a type synonym for StateT s Identity?
10:18:20 <joevandyk> whee i'm a haskell genius: https://github.com/joevandyk/99h/blob/master/1.hs
10:18:45 <Cale> Now instead of the State data constructor, you can use  StateT . (Identity .)
10:18:55 <Cale> "great!"
10:19:04 <dafis> Cale: you can use state
10:19:05 <c_wraith> Uh.  or you can use the function named "state"
10:19:31 <Cale> I suppose that's okay as long as you don't need to pattern match
10:22:04 <kosmikus> I hear pattern synonyms will be in GHC soon
10:23:31 <xivix> joevandyk: what's that?
10:23:38 <Cale> It's still kinda annoying if you don't want to care about monad transformers.
10:24:17 <Cale> The reason I noticed is that I'm trying to explain to a friend the manner in which mapAccumL is related to the State monad.
10:24:49 <Cale> I suppose I'll just define my own State monad for the purposes of the email.
10:24:51 <kosmikus> there shouldn't usually be much need to look at the internals of State
10:25:07 <kosmikus> explaining things is such as reason, though
10:26:41 <Cale> Personally, I think monad transformers are a bit of a double edged sword. They're really good at helping to define certain things, but most people end up using them in ways that I find distasteful.
10:27:04 <Cale> If anything, I'd be moving to de-emphasise them in the libraries :P
10:32:32 <Cale> It's also better that I define my own, because mtl still gets the pairs backards
10:32:35 <Cale> backwards*
10:32:39 <Luke> can someone help me figure out how to make attoparsec read lines in reverse from the end of the file? is that possible?
10:32:52 <KirinDave> it's too bad it's hard to combine monad transformers with monad zippers
10:33:06 <KirinDave> Because MTL basically doesn't solve the problem of writing resuable middle-layer code at all
10:33:31 <Cale> Luke: just apply unlines . reverse . lines to the string before passing it to your parser?
10:33:40 <KirinDave> Fortunately most haskell code is shallow.
10:34:06 <Luke> Cale: thanks
10:34:42 <Cale> I think that any instance where you're using monad transformers should be a case where your clients can't tell that you are.
10:45:19 <parcs> why shouldn't you ever not use monad transformers to create your custom monad?
10:46:01 <copumpkin> negate that a few more times
10:47:32 <parcs> haha
10:48:51 <KirinDave> I still haven't seen an example of how you can write middle-layer code using the MTL
10:48:53 <bfig> i'm following http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements => how do i parse a binary infix expression?
10:48:57 <JuanDaugherty> double negatives are grammatical in some langs
10:49:08 <dmwit> parcs: Is your question, "When should you avoid using transformers?"?
10:49:15 <KirinDave> Like, if my middle-of-the-road process needs its own state and that state may be seaprate from all the other state in the stack and you don't know where in the stack the state will live
10:49:33 <KirinDave> The client adds their own state on top and things get weird, I think.
10:49:42 <parcs> dmwit: sort of
10:49:53 <dmwit> I think Cale is in the minority.
10:50:07 <dmwit> You should use transformers whenever they provide the functionality you need.
10:50:21 <parcs> the only reason i know of is efficiency
10:51:06 <dmwit> KirinDave: I think MonadRandom is a great example of successfully using middle-layer code with the MTL.
10:51:18 <dmwit> KirinDave: It's implemented as a StateT, but isn't an instance of MonadState.
10:51:20 <dmwit> Perfect.
10:51:57 <Cale> I generally think that most cases of people using monad transformers over IO are inappropriate, and that they'd end up with nicer code if they just used the features of IO more directly.
10:52:02 <parcs> there is an mtl variant that implements all transformers in terms of ContT
10:52:20 <Cale> (With the exception perhaps of ContT and some nondeterminism monad transformers)
10:53:06 <Cale> Monad transformers over lists are cool.
10:53:32 <Cale> (or other nondeterminism monads)
10:54:00 <monochrom> use existing monad transformers. hide your use.
10:54:22 <parcs> and i guess using monad transformers creates leaky abstractions
10:54:42 <dmwit> monochrom++
10:54:44 <Cale> parcs: Well, if you use them improperly and don't seal the abstraction up tight.
10:54:48 <tac-tics> Cale: Can you give an example of a cool MonadT over List?
10:55:18 <benmachine> StateT String [] String = ReadS
10:55:34 <benmachine> (I... think)
10:55:35 <Cale> tac-tics: StateT Puzzle [] where Puzzle is some type for representing a partially-solved puzzle is nice :)
10:55:41 <DevHC_> dmwit: u like to increment ppl via a language that we all hate?
10:55:41 <copumpkin> @unmtl StateT String [] String
10:55:41 <lambdabot> String -> [(String, String)]
10:55:46 <benmachine> oh
10:55:51 <benmachine> I meant StateT String []
10:56:00 <copumpkin> @unmtl StateT String []
10:56:01 <lambdabot> err: `StateT String []' is not applied to enough arguments, giving `/\A. String -> [(A, String)]'
10:56:03 <benmachine> StateT String [] Thing = ReadS Thing
10:56:11 <KirinDave> dmwit: Interesting.
10:56:25 * monochrom uses unsafePerformIO to hide his use of IO! XD
10:56:25 <Cale> @unmtl StateT Puzzle [] a
10:56:25 <lambdabot> Puzzle -> [(a, Puzzle)]
10:56:45 <Cale> (grr, it still annoys me how that's backwards)
10:56:55 <tac-tics> So StateT b [] a is a b-parser?
10:56:59 <mdwright> If i was looking for a book on the mathematics behind the concepts in haskell, is there one or two that anyone would recommend? (For background, I'm an undergraduate math/cs major that's just about finished my degree. I've got some background in abstract algebra, but not much else that seems relevant specifically to haskell)
10:57:04 <Cale> (,) Puzzle is a Functor instance
10:57:05 <Cale> but no
10:57:20 <Cale> It can't be (Puzzle, a), they had to make it (a, Puzzle)
10:57:27 <tac-tics> mdwright: http://www.cis.upenn.edu/~bcpierce/tapl/
10:57:32 <tac-tics> Is a good start
10:57:37 <benmachine> tac-tics: depends what you mean by a b-parser, but possibly
10:57:47 <monochrom> anyway, my "use existing monad transformers" is assuming they fit your purpose. if you say StateT s [] doesn't fit your purpose, of course don't use it.
10:57:55 <mdwright> tac-tics: thanks!
10:58:04 <Cale> tac-tics: It's a nondeterministic state machine whose states are indexed by values of type b
10:58:16 <benmachine> tac-tics: also depends what kind of parser; where there's no ambiguity in your language, StateT b Maybe a will be fine
10:59:27 <benmachine> I wrote a parser as a StateT String Maybe Exp once
10:59:32 <benmachine> it's pretty neat, you can do things like
10:59:33 <benmachine>       (')' : r) <- gets dropSpace
10:59:47 <benmachine> and it'll fail if the next character after whitespace is not a )
10:59:54 <parcs> whoa
10:59:59 <parcs> there are arrow transformers too
11:00:21 <kamaji> What's a ghci bus error?
11:00:30 <kamaji> I tried to run Numeric.LinearAlgebra.Tests.runBenchmarks
11:01:13 <monochrom> some bus errors are word alignment errors
11:01:47 <kamaji> Hm
11:01:53 <kamaji> All the tests claimed to pass though
11:01:59 <kamaji> actually .. i don't think that's true
11:02:25 <kamaji> Is this a problem with hmatrix then?
11:02:38 <kamaji> yeah, last line of tests is this: Cases: 67  Tried: 12  Errors: 0  Failures: 0zsh: bus error  ghci
11:02:49 <kamaji> so is that a 64-bit/32-bit thing going wrong?
11:04:15 <mm_freak> parcs: i'd be grateful in fact =)
11:04:35 <mm_freak> i'd really like to focus on coding instead of wiki-writing right now
11:04:43 <mm_freak> so any help with updating the page is welcome
11:04:57 <parcs> okay :)
11:05:39 <mm_freak> but one thing is that people would expect that the code runs with version 1.0.0, but it will not
11:06:10 <mm_freak> there have been many breaking changes…  so if you plan to update code, you should also update the particular section text to reflect your change
11:08:08 <hey_lu_> hello, how can i read unicode filenames prior to ghc-7.3.*? (System.IO.UTF8 seems not to work...)
11:08:43 <DanBurton> by...upgrading to ghc > 7.3.*?
11:09:21 <dmwit> Beautiful answer, DanBurton.
11:09:38 <mm_freak> huh?  i have GHC 7.0.3 and no problems with unicode filenames
11:09:56 <hey_lu_> well, i did that, but i didn't manage to install the haskell-platform with ghc-7.3.*
11:09:57 <mm_freak> wouldn't even know there is a 7.3
11:10:06 <parcs> mm_freak: i have a couple of hours to spare; i can update the entire page, if that's okay with you
11:10:18 <mm_freak> parcs: sure, i'd appreciate that
11:10:44 <elliott> Which page?
11:10:59 <hey_lu_> i think these problems are only on linux (ghc-7.3.* is availlable as source-tarball)
11:11:05 <mm_freak> elliott: http://haskell.org/haskellwiki/Netwire
11:11:31 <elliott> ghc-7.3 is, uh, out?
11:11:53 <elliott> mm_freak: ah
11:11:58 <hey_lu_> no, it's just a preview or whatever, i look where i got it from
11:12:16 * elliott thinks netwire looks cool, but arrowphobia prevents him from looking into it in too much depht
11:12:17 <elliott> depth
11:12:40 <hey_lu_> http://www.haskell.org/ghc/dist/current/dist/
11:13:11 <Yrogirg> is there a way to overload a function without type classes?
11:13:22 <dmwit> elliott: .odd are unstable (not releases); you can get them with git. .even are releases
11:13:26 <elliott> Yrogirg: Type classes are the overloading mechanism.
11:13:35 <elliott> Yrogirg: Why would you want to overload without using the overloading mechanism?
11:13:36 <elliott> dmwit: Ah.
11:13:41 <dmwit> elliott: As soon as .n is released, .n+1 starts in git =)
11:14:15 <s951> excuse me everyone, is ord and chr in ghci prelude?
11:14:15 <elliott> dmwit: Yeah, a brief Googling just showing a few date snapshots made me think that, but I couldn't fathom anyone trying to compile the Platform with such a build :P
11:14:22 <elliott> s951: Data.Char
11:14:24 <Reisen> Cale, saw this post today: http://notes-on-haskell.blogspot.com/2007/02/whats-wrong-with-for-loop.html, saw the top comment, thought 'Oh nice I learnt this yesterday', then I saw who commented
11:15:06 <Cale> Reisen: kekeke
11:15:19 <Cale> I am everywhere that a human evaluating machine is needed.
11:15:56 <Yrogirg> elliott : I want * to be both something like (AbelianGroup a) => Integer -> a -> a and (SemiGroup a) => a -> a -> a. Well, I'd be glad to have different names, but I can't imagine them.
11:16:03 <Reisen> Cale, I will be seeing you everywhere then I'm sure
11:16:13 <elliott> Cale: What's your reduction speed measured in Reducerons?
11:16:44 <elliott> Yrogirg: class Multiply a b | b -> a where (*) :: a -> b -> b
11:16:46 <Cale> elliott: Probably 10^-9 or something.
11:16:57 <mm_freak> elliott: i think arrows are the simplest, most efficient and most straightforward language for FRP
11:17:04 <elliott> Yrogirg: Or class Multiply a where type Blah a; (*) :: Blah a -> a -> a
11:17:16 <elliott> Yrogirg: It's ugly but any alternative would probably be worse
11:17:23 <mm_freak> and it's really not that hard…  when you use arrow syntax, the code looks very intuitive
11:17:40 <dmwit> elliott: That doesn't help with declaring the instances.
11:17:46 <dmwit> elliott: They'll still overlap.
11:17:48 <elliott> dmwit: Well, yeah, those would have to be done manually.
11:17:49 <Cale> Yrogirg: I recommend *^ for "scalar multiplication" type operations, with the convection that the ^ goes on the side of the vector.
11:17:59 <elliott> But I agree with Cale, use a different operator ideally.
11:18:06 <Cale> That or *.
11:18:20 <Cale> with the dot on the side of the vector again :)
11:18:28 <Cale> so that addition can be .+.
11:18:31 <Cale> or ^+^
11:18:31 <mm_freak> Yrogirg: have you looked into the vector-space library?
11:18:33 <elliott> mm_freak: well, I don't like how arrow notation is very "heavy" conceptually, in that unlike do notation it's a non-trivial transformation... and I'm not a big fan of the seeming "arbitrariness" of what goes into Arrow, nor the use of explicit products
11:18:43 <elliott> Maybe one day I'll start liking them and can enjoy efficient FRP :P
11:19:09 <Cale> elliott: On the other hand, that leaves a lot of room for optimisation of how the arrow notation is translated
11:19:28 <tac-tics> Can someone explain to me what arrows are in a space-suit-type analogy?
11:19:32 <Yrogirg> thank you Cale, I think I'll use this or invent something else later
11:19:34 <mm_freak> elliott: well, without arrow notation it can get very ugly, especially when you use some of the other arrow classes like ArrowChoice or ArrowLoop =)
11:20:03 <elliott> mm_freak: Well yeah, and the choice between "ugly tuple mess" and "unclear-semantics heavy notation" is not very appealing to me :P
11:20:13 <elliott> Cale: Yeah, it's a trade-off.
11:20:18 <mm_freak> elliott: for AFRP you really want to use the arrow notation, and it's not that nontrivial…  the rules are fairly simple, if you don't use the more advanced constructs like (| |)
11:20:37 <dmwit> tac-tics: Monads are side-effecting values; arrows are side-effecting functions.
11:20:47 <Cale> elliott: Once you throw in the operations fst :: (a,b) ~> a, snd :: (a,b) ~> b, swap :: (a,b) ~> (b,a), lassoc :: (a,(b,c)) ~> ((a,b),c) and rassoc :: ((a,b),c) ~> (a,(b,c)), then it's no longer something arbitrary
11:20:56 <tac-tics> dmwit: That is pretty succinct
11:21:00 <dmwit> tac-tics: Note that values can be functions if you like, but not functions can never be specialized to things like Int.
11:21:10 <Cale> elliott: it looks like the setup for a symmetric or braided monoidal category then :)
11:21:27 <dmwit> My grammar is pretty messed up.
11:21:35 <Cale> elliott: and as it happens, these operations are really handy in providing better translations of the arrow notation
11:21:38 <elliott> Cale: Don't arr provide those
11:21:54 <elliott> I don't really like arr either though, there seem to be a lot of things that are arrows if not for arr
11:21:54 <Cale> elliott: yes, but each arr is a black box which you want to avoid as much as possible
11:21:55 <dmwit> Anyway, arrows always have a domain and a codomain.
11:22:20 <rahul> Are Haskell's vectors lazy like lists?
11:22:20 <lambdabot> rahul: You have 1 new message. '/msg lambdabot @messages' to read it.
11:22:29 <Cale> The whole point of arrows over monads is to provide more ability to inspect computations at runtime and do analysis to improve performance.
11:22:31 <elliott> What are Haskell's vectors?
11:22:32 <elliott> the vector package?
11:22:37 <elliott> it offers some lazy vectors and some strict vectors
11:22:44 <elliott> Cale: Right.
11:22:47 <Cale> elliott: Depends what you mean by vectors?
11:22:52 <elliott> Cale: <rahul> Are Haskell's vectors lazy like lists?
11:22:56 <Cale> Er, rahul
11:22:58 <elliott> Ah
11:23:11 <mm_freak> rahul: lazy yes, but not like lists
11:23:27 <rahul> elliott: Yes, the vector package. Basically what I need is an indexed sequence type that is not strict.
11:23:29 <mm_freak> rahul: in a vector, the structure is strict, but the values can be lazy (unless you use an unboxed vector)
11:23:34 <Cale> rahul: If you mean the vector library on hackage, it provides both lazy and strict vectors.
11:23:50 <Cale> (and really strict unboxed vectors)
11:24:06 <dmwit> True or false: vectors are meant to be a better Array.
11:24:08 <mm_freak> rahul: however, note that the vector package performs stream fusion optimization, so it can happen that some of your vectors get optimized away
11:24:10 <elliott> Cale: Re inspection/analysis: it's definitely an advantage, but I can't shake the feeling that somebody's going to bake FRP notation into a compiler and have it heavily optimise it internally and have it be more convenient, if less generic. (Replace FRP with arrow use-case of choice.)
11:24:13 <Cale> er, does it provide lazy vectors?
11:24:22 <Cale> I thought it did, but now I'm unsure :)
11:24:37 <elliott> Cale: yes
11:24:40 <mm_freak> Cale: lazy-value vectors
11:24:42 <rahul> mm_freak: What is stream fusion optimization?
11:24:43 <mm_freak> not lazy-structure values
11:24:53 <elliott> well right
11:24:56 <mm_freak> rahul: turning a vector computation into a tight loop essentially
11:24:58 <Cale> mm_freak: Yeah, I thought there was an analogue to lazy bytestrings
11:25:01 <Cale> But perhaps not
11:25:05 <mm_freak> Cale: nope
11:25:14 <mm_freak> well, partly
11:25:19 <mm_freak> you can have Vector (Vector a) =)
11:25:38 <rahul> Okay. Thanks!
11:26:58 <mm_freak> elliott: that notation would probably be just arrow notation, but specialized to FRP =)
11:27:08 <mm_freak> same notation, but with additional knowledge
11:27:39 <elliott> mm_freak: I'm sure do notation has a more general form too :P
11:27:54 <mm_freak> elliott: which do-notation?
11:28:06 <mm_freak> for monads?
11:28:12 <elliott> Yeah.
11:28:34 <mm_freak> more general in that it has more features or less features?
11:29:06 <elliott> Like, at first there was the wacky stream-based IO, and then everyone basically settled on using monadic IO, then someone gave it its own very special imperative syntax (that happens to work for all monads too) and built it into the compiler.
11:29:17 <mm_freak> because arrow notation is kind of a do-notation with less features (unless you have ArrowApply, in which case they are equivalent in power)
11:29:19 <elliott> I kinda feel like the same is bound to happen with the usecases of arrows.
11:30:09 <mm_freak> elliott: i don't think that you will find special syntax for a special purpose notation in a general purpose language any time soon
11:30:15 <mm_freak> unless it's a generic combinator notation
11:30:37 <elliott> mm_freak: Really? Isn't that basically exactly what do notation was conceived as?
11:31:00 <elliott> "FRP notation" would kinda be the asynchronous/"interactive" analogue to do notation on IO.
11:31:38 <mm_freak> elliott: (A)FRP is neither asynchornous, nor interactive, and it is special purpose in that it wouldn't be a language feature
11:31:48 <mm_freak> FRP is a specific kind of performing looping and mutation
11:31:55 <mm_freak> AFRP at least
11:32:06 <elliott> I was handwaving wrt. asynchronous/interactive since they're the most commonly-cited/"original" examples of FRP :)
11:32:50 <mm_freak> i think the original non-arrow implementations of FRP indeed needed to be impure under the hood, but i'm not sure
11:32:55 <mm_freak> what was the first one?  Fran?
11:33:13 <elliott> I think so
11:33:55 <hey_lu_> what do you recommend for initially reading about FRP?
11:35:34 <mm_freak> hey_lu_: difficult, because FRP is really a family of concepts…  i would generally recommend going into the direction of arrowized FRP, but i myself haven't found any good resources to read
11:36:21 <mm_freak> hey_lu_: what really helped me to get it was a little hint from Cale…  just a type definition in fact =)
11:36:31 <hey_lu_> so arrows and then read a library? ;)
11:36:41 <mm_freak> newtype SF a b = SF (Time -> a -> (b, SF a b))
11:37:07 <mm_freak> yampa has a very complicated internal representation, but it boils down to this type
11:42:15 <xivix> could someone help me pointfree something?
11:42:48 <xivix> I want a function that returns its first argument +1
11:42:55 <Botje> @pl \x -> x + 1
11:42:55 <lambdabot> (1 +)
11:43:10 <xivix> with two arguments
11:43:24 <xivix> (\x _ -> x + 1)
11:43:33 <Botje> well, feed that to @pl :)
11:43:45 <xivix> what's @pl?
11:43:57 <Botje> a lambdabot plugin to make stuff pointfree
11:44:03 <Botje> @pl \a b c -> b + 3
11:44:03 <lambdabot> const (const . (3 +))
11:44:03 <xivix> @pl \x _ -> x + 1
11:44:04 <lambdabot> const . (1 +)
11:44:20 <xivix> I'm almost certain I tried that
11:44:26 <mm_freak> > const . succ $ 5
11:44:27 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a)
11:44:27 <lambdabot>    arising from a use of `...
11:44:31 <dcoutts> xivix: FYI: pl = (p)oint(l)ess
11:44:41 <mm_freak> > (const . succ) 5 3
11:44:42 <lambdabot>   6
11:45:01 <xivix> apparently not must have typo'd it
11:45:01 <mm_freak> xivix: honestly i wouldn't point-free that
11:45:13 <mm_freak> write \x _ -> succ x
11:46:05 <xivix> how does the @pl thing work?
11:46:16 <dcoutts> cunning and black magic
11:46:20 <dcoutts> there's a package on hackage
11:46:44 <benmachine> note: the fact that I maintain said package doesn't mean I understand it
11:46:52 <dcoutts> heh heh
11:47:12 <xivix> sounds like good software
11:47:38 <RichardBarrell> @pl \c -> if elem c [2..9] then replicate c c else [c]
11:47:38 <benmachine> lambdabot is mostly dark magic of one kind or another
11:47:38 <lambdabot> ap (ap (if' . flip elem [2..9]) (join replicate)) return
11:47:54 <mm_freak> i find @djinn more impressive
11:48:08 <mm_freak> @djinn Either e a -> Maybe e
11:48:09 <lambdabot> f a =
11:48:09 <lambdabot>     case a of
11:48:09 <lambdabot>     Left b -> Just b
11:48:09 <lambdabot>     Right _ -> Nothing
11:48:23 <dmwit> f _ = Nothing
11:48:30 <benmachine> dmwit: :P
11:48:35 <dmwit> ;-)
11:48:43 <RichardBarrell> @pl \c -> replicate (if c < 10 then c else 1) c
11:48:44 <lambdabot> replicate =<< flip (if' =<< (< 10)) 1
11:48:44 <dmwit> But yeah, it's nice that it's been fixed to be better about that kind of thing.
11:48:50 <tac-tics> dmwit has no appreciation for maximal linearity of his proofs
11:48:53 <tsousa> i already did the first 10 exercices from 99 haskell problems, and i also have read the 6 first chapters of lyah what do you guys recommend me to do next?
11:49:19 <mm_freak> tsousa: write a real application
11:49:27 <mm_freak> like a command line task manager or something
11:49:31 <xivix> read the rest of lyah
11:49:34 <RichardBarrell> Something easy like an IRC bot. :)
11:49:35 <lambdabot> RichardBarrell: You have 1 new message. '/msg lambdabot @messages' to read it.
11:49:59 <RichardBarrell> ski: you're a legend, thank you.
11:50:27 <xil> hello. I'm having some trouble with Gtk2Hs. Just trying to display a pretty simple window but I'm getting an error. I'll post the code and error to hpaste...
11:50:34 <xivix> tsousa: one of the chapters coming up is, "Functors, Applicative Functors and Monoids"
11:50:38 <hpaste_> xil pasted “code” at http://hpaste.org/52198
11:50:40 <xivix> doesn't get any better than that
11:50:42 <hpaste_> xil pasted “error” at http://hpaste.org/52199
11:51:50 <hey_lu_> is a frp/yampa Signal an event?
11:51:53 <mm_freak> i taught the IO monad to a friend without mentioning the word "monad"…  it popped up in a type signature from time to time, but i said:  "for now, ignore 'Monad' and replace 'm' by 'IO'"
11:52:10 <mm_freak> hey_lu_: no, a signal is a signal…  a time dependent value
11:52:15 <xivix> "Warm, fuzzy thing"
11:52:42 <mm_freak> hey_lu_: an event is a signal, which may be absent…  essentially where 'a' is a signal, 'Maybe a' is an event
11:52:53 <dcoutts> xil: there's actually two formats for these glade files
11:52:57 <OLiverr> hello again, I already asked yesterday or so a question but the situation is slightly different than I expected: the program which is compiled by ghc in a Windows environment runs only on the system where it was compiled and I discovered that two packages (pandoc and citeproc-hs) write some absolute paths to their installation directories in the cabal directory
11:52:58 <mm_freak> hey_lu_: but yampa has its own Maybe called Event
11:53:17 <OLiverr> e.g. citeproc_hs_libdir and exec_dir etc
11:53:20 <RichardBarrell> mm_freak: I find IO a little annoying to some programs - branchy stuff with awkward flow control. ContT IO is much nicer. :)
11:53:40 <OLiverr> so has anyone an idea how I can prevent this or if there might be some other reasons?
11:53:49 <dcoutts> xil: there's the old style .glade files which are loaded using libglade, there's new style .ui files which are loaded using the GtkBuilder api. The program called 'glade' can read and write both formats.
11:54:02 <mm_freak> RichardBarrell: i'll teach her CPS early…  one of her advantages is that she has absolutely no prior programming experience…  she is learning much faster than i did
11:54:18 <dcoutts> xil: you're using the old Glade API to load a file that is in the new GtkBuilder format. The solution is to use the new GtkBuilder API.
11:54:37 <dcoutts> xil: the API is almost identical, mostly just renamed functions.
11:54:38 <RichardBarrell> mm_freak: that's practically cheating and I like it. ;)
11:55:04 <mm_freak> hehe
11:55:23 <xil> dcoutts: I see....can you point me in the direction of a tutorial or the appropriate doc page?
11:56:02 <dcoutts> xil: just look at the API docs for Graphics.UI.Gtk.Builder
11:56:14 <xil> dcoutts: ah okay, thanks =]
11:56:18 <dcoutts> xil: it's in the gtk package, you no longer need the glade package
11:56:29 <mm_freak> OLiverr: i think there is a static linking mode in GHC
11:56:33 * Eduard_Munteanu waits for a wave of programmers who are comfortable with braided comonoidal profunctors but don't grok pointers :P
11:56:44 <hey_lu_> mm_freak: can you give me a real-world example of what a signal and what an event is?
11:56:45 <mm_freak> lol Eduard_Munteanu
11:57:22 <OLiverr> mm_freak,  but that's the default mode, isn't it?
11:57:43 <OLiverr> because I didn't pass no additional parameters and my executable is huge enough ;)
11:58:51 <mm_freak> hey_lu_: your signal network is essentially a function, which will be called continuously…  at every instant it can adjust itself, so at the next instant you will be calling a different signal network
11:59:31 <kamaji> I'm confused as to the difference between `sub` and (-)
11:59:42 <tac-tics> @src sub
11:59:42 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:59:44 <kamaji> - takes a Num, sub has some weird "Container" thing :|
11:59:45 <tac-tics> :t sub
11:59:47 <lambdabot> Not in scope: `sub'
12:00:02 <kamaji> :i sub
12:00:12 <mm_freak> hey_lu_: a signal is originally fed from outside…  it's a value, which can change at every instant…  for example your FRP system might process an audio signal…  at every instant it receives the next sample
12:00:12 <kamaji> oh ~
12:00:29 <tac-tics> kamaji The difference seems to be that (-) is a thing and sub isn't :)
12:00:58 <mm_freak> hey_lu_: an event is a signal of the form 'Event a'…  it can be present in one instant and absent in another
12:01:08 <mm_freak> hey_lu_: Event is really just Maybe
12:01:28 <mm_freak> technically there is no difference between an event signal and any other signal
12:01:48 <Cale> In Yampa that's true
12:02:07 <mm_freak> yes, it's true in yampa and animas
12:02:13 <Cale> But Yampa doesn't take advantage of the semantic difference between Events and other kinds of signals.
12:02:44 <mm_freak> yes, your library and netwire make a semantic difference between signals and events
12:02:56 <Cale> (An event with no occurrences has the same cost as an event which occurs all the time)
12:04:23 <mm_freak> Cale: but i don't want to scare him off yampa =)
12:04:53 <neillb> tsousa: Here are some other problems you should manage, having read that far: 1) http://blog.tmorris.net/haskell-exercises-for-beginners/ 2) p1-23 (and quite a few of the trees problems (p50-70)) of 99 haskell problems. 3) Functionally Solving Problems in LYAH (They're not presented as problems, but you can tackle them as such if you're careful not to read too far).
12:05:13 <xil> dcoutts: awesome, thank you. Seems I got it to compile and run, but I need to figure out a few quirks now
12:05:21 <dcoutts> xil: great
12:05:36 <mm_freak> OLiverr: i have no idea, sorry…  got no windows here
12:05:38 <xil> dcoutts: thanks again =]
12:06:34 <mm_freak> Cale: btw, how does your library deal with events?
12:06:55 <hey_lu_> mm_freak,Cale: thanks, i'll continue reading the introductory slides on yampa and come back when i feel like i get the ideas.
12:07:33 <mm_freak> hey_lu_: go ahead
12:12:19 <wires> what is the easiest most efficient way to do this (ie. which library): start with http + json REST style API to something, and then later add a scalable low-latency (UDP like) IO to the same something
12:14:16 <mm_freak> wires: probably WAI or Snap
12:15:25 <wires> mm_freak: thanks, i'll check those
12:16:20 <wires> actually, do you know about this "iterators" library by oleg? something like continuations for i/o ; i'm not sure
12:17:02 <byorgey> wires: iteratees
12:17:05 <wires> IIRC there is a improved implementation by someone from haskell community
12:17:36 <wires> or that was maybe even a point of discussion whether one approach was better than the other
12:17:41 <wires> byorgey: thank you
12:18:17 <byorgey> there are several implementations, I'm not up on the latest discussion of relative merits
12:18:27 <mm_freak> wires: if you want to work with WAI, check out the 'enumerator' library
12:18:29 <byorgey> @hackage iteratee
12:18:29 <wires> ha Bart Jacobs :)
12:18:30 <lambdabot> http://hackage.haskell.org/package/iteratee
12:18:36 <mm_freak> i don't know how Snap performs its I/O
12:18:44 <wires> funny coalgebras
12:18:49 <byorgey> @hackage enumerator
12:18:50 <lambdabot> http://hackage.haskell.org/package/enumerator
12:18:53 <byorgey> @hackage iterIO
12:18:54 <lambdabot> http://hackage.haskell.org/package/iterIO
12:19:06 <c_wraith> snap uses enumerator also
12:19:23 <mm_freak> wires: the 'enumerator' library is simple and fast, but has not as much features as the 'iteratee' or 'iterIO' libraries
12:19:43 <mm_freak> and 'iteratee' may also be faster in some cases
12:19:55 <wires> so then there are UDP /http libraries on top of those i suppose?
12:19:59 <mm_freak> its simplicity is really the top selling point
12:20:01 <wires> like snap
12:20:12 <s951> I'm a newbie; can someone please explain to me why 'truncate (div 8473 3600)' throws up a type error?
12:20:15 <wires> alright, nice, thanks
12:20:15 <mm_freak> there is no HTTP over UDP, unless you emulate TCP
12:20:37 <monochrom> truncate is not meant for integers
12:20:43 <monochrom> > div 8473 3600
12:20:44 <lambdabot>   2
12:20:45 <wires> (div 8473 3600) is not a list?/tracatable
12:20:47 <monochrom> is all you need
12:21:07 <wires> s/tracatable/Truncatable/
12:21:20 <Cale> :t truncate
12:21:21 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:21:23 <s951> But 'truncate 2' still runs on the interpreter ... :(
12:21:30 <Cale> s951: that 2 isn't an Integer
12:21:33 <monochrom> because "2" is polymorphic
12:21:40 <monochrom> > 2 :: Double
12:21:40 <mm_freak> s951: try this:  truncate (2 :: Int)
12:21:41 <lambdabot>   2.0
12:21:47 <monochrom> > 2 :: CReal
12:21:48 <lambdabot>   2.0
12:22:07 <wires> c_wraith, byorgey, mm_freak thnx
12:22:24 <wires> l8r
12:22:31 <wires> ;)
12:22:35 <s951> Ah, k. Thanks.
12:22:46 <s951> Sorry, this is after my first lecture, so I'm still pretty clueless on Haskell.
12:22:55 <mm_freak> no worries =)
12:22:58 <s951> Thanks.
12:26:16 <tkahn6> s951: try truncate (8473 / 3600)
12:29:04 <parcs> mm_freak: is there any way to make a wire efficiently run at, say, 60fps?
12:29:45 <mm_freak> parcs: a wire should run at a few ten thousand FPS out of the box
12:30:08 <Dodek> hello, i'm trying to write scheme sexps parser using parsec
12:30:23 <Dodek> unfortunatelly i cannot get single line comments to work
12:30:52 <Dodek> they work only if they're preceded by any token
12:31:14 <Dodek> so that "3 ;foo \n4" gets parsed correctly, but ";foo\n 3 4" not
12:31:18 <Dodek> https://github.com/xyzzyz/schaml/blob/test-comment/parser.hs
12:31:23 <Dodek> here's the code
12:32:28 <Luke> Anyone here have a problem with emacs haskell-mode when loading the file in GHCI (C-c C-l) emacs hangs?
12:34:19 <parcs> mm_freak: what would be the best way to limit the rate at which a wire runs?
12:34:56 <parcs> would i have to do that outside the wire?
12:35:04 <parcs> eg with threadDelay?
12:35:20 <tkahn6> parcs: what's a wire?
12:35:44 <parcs> tkahn6: it's part of the netwire package
12:35:47 <parcs> @hackage netwire
12:35:48 <lambdabot> http://hackage.haskell.org/package/netwire
12:35:49 <tkahn6> parcs: thanks
12:36:07 <RichardBarrell> Luke: I have not run into that, but TBH I'm not too fond of haskell-mode at the moment. Entirely too much warping my cursor from place to place.
12:36:38 <mm_freak> parcs: that's difficult…  usually when limiting framerates it's done in a hardware-bound way like waiting for the vertical refresh
12:37:12 <parcs> mm_freak: i see
12:37:14 <mm_freak> parcs: one way to do it is to keep track of the time distance to the last frame outside of the wire
12:37:15 <parcs> that makes sense
12:37:29 <Luke> RichardBarrell: it hasn't been working too well for me. Have you seen Chris Done's new haskell mode?
12:38:01 <Dodek> oh i worked it out
12:38:12 <parcs> mm_freak: okay, thanks
12:38:20 <mm_freak> parcs: you can also do it in the wire using the time deltas, but i don't think it belongs there
12:39:22 <mm_freak> parcs: you can do this, too:  avgFps 100 >>> arr (<= 60) >>> require_
12:39:37 <mm_freak> then the wire inhibits, whenever the average framerate over the last 100 frames goes above 60
12:40:22 <mm_freak> the same in proc notation:  fps <- avgFps -< (); require_ -< fps <= 60
12:41:33 <mm_freak> then in the main loop, whenever the wire inhibits, you can increase a thread delay
12:41:48 <parcs> neat
12:43:00 <Cale> mm_freak: Well, our system is really a system for incremental computation... from what I understand (I didn't write the implementation of our ArrowEvent typeclass), events maintain a bag of subscribers which get notified when the event occurs.
12:43:25 <mm_freak> Cale: i see
12:43:37 <mm_freak> ok, netwire takes a completely different approach
12:44:35 <mm_freak> parcs: but really this is the wrong way…  FPS limitation should be hardware bound, if you're writing a graphical application
12:45:44 <mm_freak> parcs: when you use SDL for your application, you can use the Graphics.UI.SDL.Framerate module
12:46:38 <t3eblinder> Hey guys. I've just readed a syntax like "funcName TypeConstr{..} = someCodeHere". I didn't seen that before. What does it?
12:46:38 <ski> RichardBarrell : hm, was that for Cauchy sequences ?
12:47:09 <mm_freak> t3eblinder: looks like record syntax
12:48:38 <basvandijk> t3eblinder: That's a record wildcard: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
12:48:39 <ski> > let isJust Just{} = True; isJust _ = False in map isJust [Nothing,Just undefined]
12:48:40 <lambdabot>   [False,True]
12:51:29 <t3eblinder> yes a record wildcard - this is really cool :-) Did not know that this is possible.
12:51:49 <Twey> > > let isJust = not . isNothing in map isJust [Nothing, Just undefined]
12:51:50 <lambdabot>   <no location info>: parse error on input `>'
12:51:53 <Twey> > let isJust = not . isNothing in map isJust [Nothing, Just undefined]
12:51:54 <lambdabot>   [False,True]
12:58:32 <Louis11> I need to convert an integer to a char. I found intToDigit, however anything > 9 gets converted into a letter. Any ideas?
12:59:29 <monochrom> > chr 65
12:59:30 <lambdabot>   'A'
12:59:32 <erasmas> Louis11: if you import Data.Char you can use chr and ord
12:59:34 <c_wraith> Louis11: math and intToDigit
12:59:47 <monochrom> if you don't like letters...
13:00:08 <monochrom> > chr 37
13:00:09 <lambdabot>   '%'
13:00:39 <basvandijk> Hi guys, just want to let you know that I'm working on a new package: vector-bytestring. Which provides ByteStrings as type synonyms of storable vectors of Word8s from the vector package. The package provides the same API as bytestring: https://github.com/basvandijk/vector-bytestring
13:01:11 <Jafet> > ([minBound,maxBound::Int], ord.[minBound,maxBound::Char])
13:01:13 <lambdabot>   ([-9223372036854775808,9223372036854775807],[0,1114111])
13:02:23 <Jafet> ByteString refers to Data.ByteString.Lazy.ByteString around here.
13:04:46 <basvandijk> Jafet: vector-bytestring also provides lazy ByteStrings. The idea is that by using Vectors from the vector package we can benefit from the stream-fusion in that library.
13:05:12 <elliott> Jafet: It does?
13:05:17 <elliott> Jafet: I interpret it to mean the strict variant.
13:05:43 <elliott> basvandijk: That sounds cool to me, they're the same basic thing after all
13:05:52 <elliott> Is it faster? :p
13:05:53 <basvandijk> elliott: indeed
13:06:04 <elliott> Cool.
13:06:14 <basvandijk> I haven't benchmarked it yet. I hope to do that this weekend
13:06:24 <elliott> Oh, I thought you said indeed to it being faster :)
13:08:19 <Louis11> hm, do I just import math? I get an error about not being able to find the module.
13:09:05 <Cale> Louis11: Module names don't start with lowercase letters, first of all
13:09:09 <Cale> (ever)
13:09:18 <ion> (never ever)
13:09:39 <Cale> Louis11: Secondly, there is no standard module by that name.
13:10:10 <Cale> If it's your own module in the same directory as the module you're writing, you can   import Math
13:10:19 <Cale> and then inside Math.hs, ensure that you have
13:10:21 <Cale> module Math where
13:10:25 <Jafet> Thirdly, it makes no sense at all to convert an integer to a Char.
13:10:26 <Cale> at the top of the file
13:10:28 <basvandijk> BTW I also ported the bytestring test-suite to vector-bytestring and all tests except for one pass
13:11:53 <Louis11> Jafet: I want to concat an integer with a string and it complains if it's an Int. Am I missing something?
13:12:27 <rvn_> Louis11, are you using the show function?
13:12:59 <Jafet> You're missing some sense.
13:13:23 <monochrom> you're totally miswording your goal
13:13:31 <rvn_> > "Hello " ++ show 123
13:13:32 <lambdabot>   "Hello 123"
13:14:11 <rvn_> Unless, you're talking about the concat function :3
13:14:16 <Louis11> rvn: No I wasn't using show. I wasn't aware I needed to, but that worked
13:14:25 <Louis11> nope your suggestion worked great, thanks :)
13:14:38 <ski> > "Hello " ++ show "string"
13:14:39 <lambdabot>   "Hello \"string\""
13:16:26 <monochrom> you could have not worded the question at all. instead, use good examples. I have an Int/Integer 123, I have a String "Hello ", from them I want to get the String "Hello 123".
13:18:07 <monochrom> granted, some other questions cannot be exemplified so easily
13:18:52 <rahul> Hi. What's the purpose of ArrowPlus typeclass and what does the function <+> do?
13:18:57 <rahul> :t <+>
13:18:58 <lambdabot> parse error on input `<+>'
13:19:04 <rahul> :t (<+>)
13:19:05 <lambdabot>     Ambiguous occurrence `<+>'
13:19:05 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
13:19:05 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
13:19:16 <monochrom> it is analogous to MonadPlus. do you already know MonadPlus?
13:19:18 <jaapweel> :t Control.Arrow.<+>
13:19:18 <c_wraith> heh.
13:19:19 <lambdabot> parse error on input `Control.Arrow.<+>'
13:19:26 <Kaidelong> @ty (Control.Arrow.<+>)
13:19:27 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
13:19:30 <rahul> monochrom: No:(
13:19:56 <rahul> a brief explanation with a small illustrative example would be appreciated.
13:20:06 <c_wraith> What's the equivalent of mzero?
13:20:26 <Kaidelong> > [] `mplus` [4,5,7] `mplus` [4,3]
13:20:27 <lambdabot>   [4,5,7,4,3]
13:20:44 <Kaidelong> > mzero :: [Int]
13:20:45 <lambdabot>   []
13:21:12 <Kaidelong> @instances-importing ArrowPlus
13:21:12 <lambdabot> Kleisli m
13:21:50 <rahul> Does it represent arrows that can be 'added'? (*Plus)
13:21:53 <rvn_> Would I be right in saying that Grapefruit is the most usable FRP (with grapefruit-ui-gtk) UI library?
13:22:06 <rahul> I dont know if that even make any sense
13:22:13 <Kaidelong> @ty enumFromTo <+> enumFromTo
13:22:14 <lambdabot>     Ambiguous occurrence `<+>'
13:22:14 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
13:22:14 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
13:22:26 <Kaidelong> @ty enumFromTo (Control.Arrow.<+>) enumFromTo
13:22:27 <lambdabot>     Couldn't match expected type `a b c'
13:22:27 <lambdabot>            against inferred type `[a b c]'
13:22:27 <lambdabot>     In the second argument of `enumFromTo', namely `enumFromTo'
13:22:30 <byorgey> rahul: yes
13:22:32 <hpaste_> Luke pasted “Attoparsec” at http://hpaste.org/52206
13:22:37 <Kaidelong> oh right
13:22:43 <byorgey> rahul: it represents arrows with some sort of "failure" and "choice"
13:22:53 <byorgey> raulike, "if this arrow doesn't work out, try this one instead".
13:22:54 <Kaidelong> @ty (enumFromTo 1) (Control.Arrow.<+>) (enumFromTo 0)
13:22:55 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `[t2]'
13:22:55 <lambdabot>     In the expression:
13:22:55 <lambdabot>         (enumFromTo 1) (Control.Arrow.<+>) (enumFromTo 0)
13:23:01 <rahul> byorgey: What does it mean for arrows to be added? I dont get it
13:23:02 <Luke> can someone help me with that hpaste? I can't figure out how to actually use attoparsec now that I've defined some combinators
13:23:33 <monochrom> when f may fail or g may fail or both, "f <+> g" says try them and go with whichever one that suceeds. things get funny if both suceeds; then it really depends on the particular ArrowPlus instance, there is no general law.
13:23:35 <Kaidelong> @ty (enumFromTo 1)
13:23:36 <lambdabot> forall t. (Num t, Enum t) => t -> [t]
13:23:46 <Kaidelong> hmm that's a kleisi arrow isn't it?
13:23:58 <Kaidelong> what am I doing wrong
13:23:58 * hackagebot snap-blaze 0.0.0.1 - blaze-html integration for Snap  http://hackage.haskell.org/package/snap-blaze-0.0.0.1 (JasperVanDerJeugt)
13:24:13 <ClaudiusMaximus> @ty (enumFromTo 1) Control.Arrow.<+> (enumFromTo 0)
13:24:14 <lambdabot>     No instance for (ArrowPlus (->))
13:24:15 <lambdabot>       arising from a use of `Control.Arrow.<+>' at <interactive>:1:0-46
13:24:15 <lambdabot>     Possible fix: add an instance declaration for (ArrowPlus (->))
13:24:17 <Luke> How would this attoparsec example actually be used? How does it look to call into it? https://bitbucket.org/bos/attoparsec/src/286c3d520c52/examples/RFC2616.hs
13:24:32 <monochrom> my http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml has an example of one particular instance
13:24:49 <rwbarton> Kaidelong: you need the KleisliArrow wrapper for what you tried to do above
13:24:54 <Kaidelong> oh right
13:25:32 <Kaidelong> > (Kleisli(enumFromTo 1)) Control.Arrow.<+> (Kleisli(enumFromTo 0)) $ 6
13:25:32 <lambdabot>   Couldn't match expected type `a -> b'
13:25:33 <lambdabot>         against inferred type `Contro...
13:26:36 <Kaidelong> > (\(Kleisli f) -> f 6) (Kleisli(enumFromTo 1)) Control.Arrow.<+> (Kleisli(enumFromTo 0))
13:26:37 <kqr> is there any neat way of exploding and imploding a string in haskell? i have my own implementation, but i'd like to think there is some kind of built in way of doing that already
13:26:37 <lambdabot>   Couldn't match expected type `a b t' against inferred type `[t1]'
13:26:37 <Clint> is there a better parsec combinator for dates than in System.Time.Parse?
13:26:51 <Kaidelong> > (\(Kleisli f) -> f 6) ((Kleisli(enumFromTo 1)) Control.Arrow.<+> (Kleisli(enumFromTo 0)))
13:26:52 <lambdabot>   [1,2,3,4,5,6,0,1,2,3,4,5,6]
13:26:56 <Kaidelong> finally
13:27:12 <Kaidelong> anyway there is a short example of how ArrowPlus can be used
13:27:18 <erasmas> Luke: looks like there's an error in your code on hpaste
13:28:14 <rahul> Kaidelong: Can you please explain that code?
13:28:39 <Kaidelong> well for anything that goes from an a to an m b, where m b is a monad, and an instance of mplus
13:29:03 <Kaidelong> you can add those two kleisli arrows by giving them the same input, then adding together the results from each
13:29:25 <Kaidelong> so that whole thing above there should be the equivalent to, hmm
13:29:59 <byorgey> rahul: is there some particular reason you are trying to learn about ArrowPlus?
13:30:30 <dankna> @hoogle foldl'
13:30:31 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
13:30:31 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
13:30:31 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
13:30:31 <kamaji> If I want to declare new type instances for a type under a different name should I use "type" or "newtype"?
13:30:42 <rahul> byorgey: http://twitter.com/#!/oxbow_lakes/status/121696055787130881
13:30:56 <Kaidelong> > (liftA2 mplus (enumFromTo 1) (enumFromTo 0)) 6
13:30:57 <lambdabot>   [1,2,3,4,5,6,0,1,2,3,4,5,6]
13:31:10 <engla_> kamaji: newtype, at least in standard haskell
13:31:22 <rvn_> @hoogle rec
13:31:23 <lambdabot> Language.Haskell.TH RecC :: Name -> [VarStrictType] -> Con
13:31:23 <lambdabot> Language.Haskell.TH.Syntax RecC :: Name -> [VarStrictType] -> Con
13:31:23 <lambdabot> Language.Haskell.TH recC :: Name -> [VarStrictTypeQ] -> ConQ
13:31:33 <kamaji> oh ok
13:31:50 <byorgey> rahul: I don't get it, what is that?
13:31:59 <erasmas> Luke: if you redo the hpaste I can take a look. I've been meaning to write an attoparsec intro for the wiki, so it'll help to see what questions there are
13:32:09 <Kaidelong> kamaji: if you were to use "type" you'd actually be unable to declare any new instances because the type synonym in the instance will just be rewritten to the type on the right side
13:32:15 <xil> hmmm...could someone help me with Gtk2Hs signals? I can't seem to find a tutorial and the "on*" functions for TreeView are "deprecated"
13:32:22 <byorgey> rahul: that does not look like Haskell code
13:32:32 <antilect> recursive datatypes = mindfuck :)
13:32:33 <Luke> erasmas: I actually found that bos had an example of how to run his attoparsec example in bitbucket so I'm hitting that now
13:32:36 <Luke> erasmas: thanks
13:32:54 <kamaji> Kaidelong: Oh, ok
13:33:03 <kamaji> so I can do something like "newtype MyFoo = Foo"
13:33:11 <kamaji> or "newtype MyFoo = Foo a" ?
13:33:15 <byorgey> kamaji: no, you have to give it a constructor
13:33:20 <kamaji> poop
13:33:21 <Kaidelong> well your contructor can't be nullary
13:33:29 <byorgey> newtype MyFoo = MyFooConstructor Foo
13:33:38 <Jafet> @instances Monoid
13:33:38 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
13:33:39 <byorgey> or often just  newtype MyFoo = MyFoo Foo
13:33:49 <Jafet> Using newtypes to define new instances is common.
13:33:53 <kamaji> (Foo is the type name, right?)
13:33:56 <dcoutts> xil: it's pretty similar, just use 'on'
13:33:58 <rahul> byorgey: It came up in a twitter discussion. It's a Scala code. Roughly equivalent to this Haskell: ((==) <$> a1 <*> a2 ) | isEmpty $ a1 <+> a2
13:33:59 <monochrom> xil: http://www.haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro#Signals
13:34:36 <Kaidelong> are you sure that scala <+> is equivalent to the haskell <+>?
13:34:46 <byorgey> rahul: I don't understand that code either.
13:34:54 <Kaidelong> as far as I'm aware most haskell projects don't really use <+>
13:34:57 <byorgey> rahul: ArrowPlus is really not all that common.
13:35:08 <rahul> :(
13:35:17 <xil> dcoutts monochrom: oho, haven't seen that anywhere. Thanks =]
13:35:18 <rahul> | :: Maybe a -> a -> a
13:35:27 <rahul> isEmpty :: Maybe a -> Bool
13:35:39 <rahul> a1, a2 :: Maybe a
13:35:59 <byorgey> rahul: 'Maybe a' is not an instance of ArrowPlus.
13:36:06 <Kaidelong> well in haskell "Maybe a" is not an arrow, let alone an ArrowPlus
13:36:21 <Kaidelong> it doesn't have the right kind for it even if you wanted it to be
13:36:34 <xil> lol, "You believe using Glade to design your user interface is a good idea."
13:36:36 <Kaidelong> perhaps <+> there is more like haskell's mplus, which is a lot more common, or mappend
13:36:51 <kamaji> do I have to re-derive the Eq/Ord/Show etc. classes for a newtype or does it keep them?
13:36:53 <Kaidelong> what's wrong with glade
13:37:08 <benmachine> @hoogle <+>
13:37:08 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
13:37:08 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
13:37:08 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
13:37:48 <Jafet> kamaji: normally you use newtype wrappers in places where you want a different instance to be used. Then you remove the wrappers. So there is no need to derive those.
13:38:06 <byorgey> rahul: so the idea is that if both a1 and a2 are (Just x), then you compare the x's for equality, and otherwise... what?
13:38:08 <kamaji> Jafet: sorry could you explain that further a little?
13:38:14 <Jafet> > Sum 1
13:38:15 <lambdabot>   Sum {getSum = 1}
13:38:40 <Jafet> > Sum 1 / 2
13:38:41 <lambdabot>   No instance for (GHC.Real.Fractional (Data.Monoid.Sum t))
13:38:41 <lambdabot>    arising from a...
13:38:49 <benmachine> kamaji: newtypes don't keep any of the instances of their parent type
13:38:59 <byorgey> kamaji: you have to re-derive them, but with the GeneralizedNewtypeDeriving extension you only have to write   deriving (Eq, Ord, Show, ...) after the newtype declaration
13:39:13 <benmachine> byorgey: actually, Eq, Ord, Show are all derivable anyway :)
13:39:13 <Jafet> You don't do anything with Sum other than sum things with mappend, so it doesn't need any instances.
13:39:15 <rahul> byorgey: case (a1, a2) of { (Just a, Just b) -> a == b; otherwise -> False }
13:39:31 <Jafet> But they were kind and did it anyway
13:39:31 <rahul> byorgey: That's what the tweeter was going for.
13:39:35 <byorgey> benmachine: yes, that's true, by the ... I meant you could use any other classes you wanted as well
13:40:03 <byorgey> rahul: I see.  And what does <+> do in Scala?
13:40:10 <kamaji> benmachine: Enum ends up not being derived though
13:40:15 <kamaji> which I need ^^
13:40:21 <benmachine> kamaji: you can't derive Enum?
13:40:29 <kamaji> it's got two enums in the type
13:40:35 <benmachine> hm
13:40:42 <benmachine> well, you can derive it with GeneralizedNewtypeDeriving :)
13:40:43 <Kaidelong> @ty \x y -> maybe False (liftA2 (==) x y)
13:40:43 <kamaji> it won't do it automatically even without the newtype
13:40:43 <lambdabot> forall a a1. (Eq a) => (a1 -> a) -> (a1 -> a) -> Maybe a1 -> Bool
13:40:52 <rahul> byorgey: It's not there in vanilla scala.
13:41:08 <kamaji> ok, so that's the best way to go?
13:41:11 <benmachine> GeneralizedNewtypeDeriving allows you to derive any class that the underlying type is an instance of
13:41:22 <rahul> byorgey: It's from a library named Scalaz, that was created by some Haskell refugees in an attempt to bring some of Haskell's goodness to Scala.
13:41:28 <Kaidelong> huh why did that not work
13:41:28 <byorgey> @type \a1 a2 -> fromMaybe False ((==) <$> a1 <*> a2)
13:41:29 <lambdabot> forall a. (Eq a) => Maybe a -> Maybe a -> Bool
13:41:34 <Kaidelong> oh
13:41:35 <Kaidelong> right
13:41:39 <byorgey> rahul: ^^^ that's how I'd do it in Haskell
13:41:40 <rahul> byorgey: So I assumed <+> does the same thing in Scala as it does in Haskell.
13:41:55 <byorgey> rahul: oh, I see.  apparently not. =)
13:41:57 <mainland> how does one mark a package deprecated on hackage?
13:42:30 <benmachine> :t curry (maybe False (uncurry (==)) . liftA2 (,))
13:42:31 <Kaidelong> rahul: the short explanation for that is that ArrowPlus is not that useful
13:42:31 <lambdabot>     Couldn't match expected type `Maybe (a, a)'
13:42:32 <lambdabot>            against inferred type `(a1, b1) -> (a1, (b, b1))'
13:42:32 <lambdabot>     In the second argument of `(.)', namely `liftA2 (,)'
13:42:34 <benmachine> hmph
13:42:38 <Kartoffelsalat> is passing around a lot of state in a StateT efficient or is there a better way? in C i would simply pass a pointer to struct around.
13:42:43 <monochrom> Great, another success of the XY Problem
13:42:57 <kamaji> How do I turn on GeneralizedNewtypeDeriving in GHCI?
13:43:00 <EvanR-work> Kartoffelsalat: thats what State does
13:43:09 <EvanR-work> so you dont have to
13:43:14 <rahul> byorgey: I wish they used same names as Haskell:(
13:43:14 <rahul> Kaidelong: :)
13:43:17 <paper_cc> kamaji: :set -XGeneralizedNewtypeDeriving
13:43:26 <kamaji> paper_cc: is it possible to do in the source file as well?
13:43:43 <rwbarton> you must do it in the source file
13:43:44 <kamaji> or does it have to be done with compiler flags/ghci flags
13:43:46 <Kartoffelsalat> i thought StateT is passing it by "call by value" not reference
13:43:48 <kamaji> oh
13:43:58 <Kartoffelsalat> wouldn't that be inefficient?
13:43:59 <rwbarton> well, or with compiler flags (but not ghci flags, I think)
13:44:01 <kamaji> {-# OPTIONS_GHC #-} ?
13:44:02 <EvanR-work> Kartoffelsalat: call by value and by reference is a giant world of troll bait
13:44:06 <rwbarton> {-# LANGUAGE GeneralizedNewtypeDeriving #-}
13:44:30 <kamaji> rwbarton: awesome, thanks
13:44:32 <EvanR-work> Kartoffelsalat: in haskell you dont have to worry about references because everything is immutable
13:44:42 <EvanR-work> its hidden from yuo
13:44:42 <monochrom> for various reasons, StateT ends up passing one pointer
13:44:46 <mainland> no hackage folks around? :)
13:45:06 <byorgey> mainland: I think it is possible but I don't remember how.  Try asking on the haskell-cafe mailing list.
13:45:14 <rahul> byorgey: From Scalaz sources, it seems the function belongs to a typeclass named Plus defined as:
13:45:22 <Jafet> Well, GHC uses neither. It uses call-by-name.
13:45:25 <rahul> byorgey: class Plus p where
13:45:36 <Jafet> Er, memoizing-call-by-name.
13:45:37 <rahul> byorgey: (<+>) :: p a -> p a -> p a
13:45:49 <Kartoffelsalat> ah ok. so if i have a data structure that contains large image data, a StateT would be ok?
13:46:00 <byorgey> rahul: ah, so that would be akin to MonadPlus
13:46:19 <EvanR-work> Kartoffelsalat: are you going to alter the pixels?
13:46:20 <kamaji> Hmm. I can't pattern match on constructors with newtype :\
13:46:27 <Jafet> let x = largeImage; y = largeImage; z = largeImage; gonzo = largeImage; -- oh noes
13:46:36 <Kartoffelsalat> yes pixels will be altered
13:46:43 <kamaji> newtype MyFoo = MyFoo Foo
13:46:46 <Kaidelong> @ty mplus
13:46:46 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
13:46:47 <kamaji> data Foo = A | B | C
13:46:56 <EvanR-work> Kartoffelsalat: then you better use IO
13:47:06 <kamaji> if MyFoo does a case on A, B or C, it says it's the wrong type
13:47:15 <Kartoffelsalat> ok thank you
13:47:18 <rwbarton> "MyFoo does a case on"?
13:47:21 <Jafet> kamaji: if you could pretend that Foo is a MyFoo, then it wouldn't be a *new* type, would it!
13:47:21 <Kartoffelsalat> i will try that
13:47:24 <EvanR-work> what theres way more to it :S
13:47:31 <Jafet> Think about it.
13:47:34 <rwbarton> the values of type MyFoo are MyFoo A, MyFoo B, MyFoo C
13:47:35 <kamaji> Jafet: but doesn't MyFoo get all the same things?
13:47:39 <rwbarton> and you can pattern match on thoes
13:47:47 <Kaidelong> @instances-importing MonadPlus
13:47:47 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
13:48:05 <Kaidelong> interesting that there is no instance for
13:48:10 <EvanR-work> Kartoffelsalat: have you looked into the issues involved with mutable arrays in haskell
13:48:14 <kamaji> rwbarton: oh...... weird
13:48:20 <Kaidelong> oh never mind, not that interesting
13:48:22 <EvanR-work> its not really related to State
13:48:24 <kamaji> why doesn't it assume A is a MyFoo A?
13:48:29 <Jafet> "I want a new type" "Use a newtype" "newtype is too hard, I don't really want a new type"
13:48:51 <Kartoffelsalat> EvanR-work: i used arrays before
13:48:58 <EvanR-work> mutable?
13:49:04 <Jafet> kamaji: that is what you sound like
13:49:05 <Kartoffelsalat> yes
13:49:13 <kamaji> lol
13:49:18 <EvanR-work> well if you are doing StateT over IO then you dont have a problem
13:49:27 <Kartoffelsalat> but i need to access them throuout the application between callbacks
13:49:29 <kamaji> I'm just asking how it works :p
13:49:52 <kamaji> I figured it would be more like a type synonym with different behaviour
13:49:55 <EvanR-work> depending on the complexity of what you just described, you probably dont need StateT
13:49:56 <Jafet> It can't assume A is MyFoo A, because it could very well be a MyBar A.
13:50:12 <kamaji> but it's in a function on a MyFoo
13:50:18 <Eduard_Munteanu> It'd be interesting to have type synonyms be opaque as far as error messages are concerned.
13:50:41 <Jafet> It could be a function on (MySpam s) => s, where s is MyFoo A or MyBar A.
13:50:41 <Kartoffelsalat> EvanR-work: ok maybe i just pass iorefs around
13:50:59 <EvanR-work> Kartoffelsalat: sounds like you just need to pass them to the callbacks
13:51:07 <kamaji> oh true.. then why do you not need to specify what kind of A normally?
13:51:12 <kamaji> why is it MyBar A by default?
13:51:19 <Kartoffelsalat> EvanR-work: i think you are right
13:51:30 <Kaidelong> kamaji: it isn't
13:51:35 <Kaidelong> there is no default
13:51:37 <Jafet> The type of A is Foo.
13:51:40 <kamaji> Kaidelong: but if I say "A" then it assumes the right type
13:51:44 <Kaidelong> you have to specify which newtype you want
13:51:53 <kamaji> sorry, by MyBar I meant Foo
13:51:54 <Jafet> That's because you defined it as a constructor of Foo.
13:52:11 <Jafet> It's not a constructor of any other type, so it can't be used as a constructor of any other type.
13:52:16 <Kaidelong> Foo is the default because Foo is the type of A until you shove it into a contructor
13:52:23 <kamaji> oh i'm getting mixed up with conflicting names and qualified import things
13:52:34 <kamaji> it's not related is it?
13:52:38 <kamaji> (rhetorical)
13:52:46 <kamaji> ok
13:52:47 <kamaji> right.
13:52:57 <Jafet> Well, it depends on how much drugs you're taking right now.
13:53:33 <kamaji> lol
13:53:36 <kamaji> clearly too many
13:54:25 <Jafet> A newtype is a new type, you can't sneak into a corner and pretend it isn't a new type somewhere else
13:55:07 <kamaji> wah :D
13:55:10 <kamaji> ok
13:55:12 <kamaji> I kinda get it
14:02:59 <rwbarton> perhaps it helps to mention that when you write "newtype MyFoo = MyFoo Foo", then MyFoo is a function with type Foo -> MyFoo
14:03:28 <dino-> rwbarton: newtype is too hard!
14:03:28 <kamaji> I think the problem is that I have nested newtypes
14:03:59 <monochrom> newtype Nest = NestCtor Nest
14:04:11 <Kaidelong> this should not be neccessary unless one of your instances has a constraint
14:04:16 <Kaidelong> IE the instance
14:04:29 <kamaji> well I wanted to treat the inner ones differently
14:04:31 <Kaidelong> (Monoid a) => Monoid (Maybe a)
14:04:39 <dino-> @seen Lemmih
14:04:40 <preflex>  Lemmih was last seen on #haskell 26 days, 10 hours, 42 minutes and 55 seconds ago, saying: Jafet: What does 'mapM_' have to do with it?
14:04:40 <lambdabot> Unknown command, try @list
14:04:52 <Kaidelong> if you do need that kind of constraint, there is no way around the nested newtypes
14:05:09 <Kaidelong> I know it is verbose, and seems unnecessary, but that's unfortunately how things are and I can't think of a better way
14:06:09 <Kaidelong> (I can think of a worse way though, which is to make a new type for the nested newtypes)
14:07:09 <monochrom> consider unsafeCoerce
14:07:20 <kamaji> Well the two types within my newtype are being treated not as newtypes because the newtype takes the original type in its constructor
14:07:29 <kamaji> well i'd rather do it "right"
14:08:26 <kamaji> It's only for a "Show" and "Read", I might just write methods and do it without having special instances for inside that type
14:08:44 <kamaji> also it's late and I'm terrible at explaining..... bedtime
14:08:46 <kamaji> thanks all
14:10:26 <Kaidelong> oh that's true
14:10:39 <Kaidelong> if you know unsafeCoerce is going to work, using it is pefectly fine
14:10:44 <Kaidelong> and might save you some code
14:11:03 <kamaji> I suppose... well maybe then
14:11:05 <kamaji> how unsafe is it? :p
14:11:17 <kamaji> well i'll look it up tomorrow
14:11:24 <kamaji> knapsackered for now
14:11:24 <Kaidelong> well if you unsafeCoerce two things that are actually of different types, then you crash your program
14:11:28 <Cale> uh, it's extremely unsafe
14:11:38 <Cale> Well, you may or may not crash your program
14:11:54 <byorgey> > unsafeCoerce 0 :: False
14:11:54 <Jafet> @quote ddarius unsafeCoerce
14:11:55 <lambdabot> ddarius says: isJust . unsafeCoerce
14:11:55 <lambdabot>   Not in scope: type constructor or class `False'Not in scope: `unsafeCoerce'
14:11:58 <Kaidelong> but newtype doesn't actually make a different type, it just lets you use different method dictionaries for instances
14:11:58 <byorgey> > unsafeCoerce 0 :: Bool
14:11:59 <lambdabot>   Not in scope: `unsafeCoerce'
14:12:17 <ski> .. using `unsafeCoerce' at type `a -> b' is only ok (i.e. well-defined) if `a' actually is the same type as `b'
14:12:26 <Jafet> Uh yes, it actually makes a different type
14:12:30 <elliott> ski: Or if b is Any.
14:12:45 <Kaidelong> Jafet: at the implementation level?
14:12:49 <elliott> Or if a is Any and the parameter was created by a call to (unsafeCoerce (x :: c)) where b === c.
14:12:54 <Kaidelong> I thought the whole point of using newtype was to avoid just that
14:12:57 <Jafet> Why are we even talking about the implementation
14:12:57 * ski hasn't really understood `Any', yet
14:13:08 <Kaidelong> Jafet: cause that's relevant to unsafeCoerce
14:13:21 <elliott> ski: You could just use () or whatever if not for silly implementation details about functions
14:13:42 <ski> elliott : or if `c' there was also any, but were created in a similar call which, transitively, started off from `b'
14:13:44 <elliott> Any isn't really special, it's just vague enough that GHC can't figure out how to break your usage :)
14:13:47 <ski> (i surmise)
14:13:55 <elliott> ski: yes, indede
14:13:56 <elliott> indeed
14:14:15 <elliott> ski: and you're also allowed
14:14:17 <elliott> Casting an unboxed type to another unboxed type of the same size (but not coercions between floating-point and integral types)
14:14:17 <elliott> Casting between two types that have the same runtime representation. One case is when the two types differ only in "phantom" type parameters, for example Ptr Int to Ptr Float, or [Int] to [Float] when the list is known to be empty. Also, a newtype of a type T has the same representation at runtime as T.
14:14:28 <ski> Kaidelong : well, i didn't talk about implementation above
14:14:45 <elliott> unsafeCoerce's semantics are not so clear. :p
14:15:08 <Kaidelong> well as they said there, a newtype doesn't make a new representation for the type, so unsafeCoerce is fine
14:15:23 <ski> elliott : actually, i think it would probably be nicer to have specific `toUniv :: a -> Univ' and `fromUniv :: Univ -> a' operations
14:15:38 <ski> (i.e., not using `unsafeCoerce' for this purpose)
14:15:50 <elliott> ski: Yes, I agree. thankfully those are easy to implement :P
14:16:06 <ski> .. also istr hearing `Any' was sometimes inserted instead of skolems into types
14:16:19 <elliott> ski: I think Any is just the final defaulting rule
14:16:23 <monochrom> "The following uses of unsafeCoerce# are supposed to work (i.e. not lead to spurious compile-time or run-time crashes):" ... "Casting between two types that have the same runtime representation." ... "a newtype of a type T has the same representation at runtime as T" straight from GHC haddock
14:17:17 <monochrom> but of course this channel is full of safeXXXX police
14:17:39 <ski> .. i.e. like SML/NJ, if you say `val f = id id', because the definiens isn't a syntactic value, that definition can't be generalized, so it invents a new type `X', not known to be equal to any other type, and `f' gets the type `X -> X'
14:17:49 <elliott> right
14:17:58 <Jafet> Not really, this discussion started from some newbie wanting haskell to lift his newtypes for him
14:17:59 <elliott> monochrom: safeXXXX police? :p
14:18:03 <Jafet> And then someone mentioned unsafeCoerce
14:18:15 <Jafet> safe XXX
14:18:30 <ski> (and the next time you have a similar non-value-binding that would otherwise be polymorphic, you get a different new type, of course -- unlike what i gather the situaion with `Any' was)
14:18:48 <monochrom> yes, the safeXXXX police wants you to replace fromJust by this safe version: safefromjust Nothing = Nothing, safefromjust (Just x) = Just x
14:19:28 <ski> of course, even better is to do what O'Caml (and i think Mlton) does : generate the signature `f : _a -> _a' where `_a' is a free (uninstantiated) type variable -- the first time `f' is used in a concrete way, `_a' will be instantiated
14:19:30 <Kaidelong> monochrom: Wanting to do away with things like head, fromJust, etc, is fair enough
14:19:34 <elliott> monochrom: yeah, they even want to restrict the Prelude function coerce :: a -> b (automatically applied whenever a type error occurs) to a -> a
14:19:44 <elliott> police state :P
14:20:11 <hpc> unsafeSafeFromJust x = case safeFromJust x of (Just x) -> x? :P
14:20:35 <Jafet> safeFromJust = teaspoon . fromJust
14:20:36 <Kaidelong> actually in the case of head there was a way to implement a non-empty list type for which head always works
14:20:45 <Kaidelong> moving the error to compile time
14:20:45 <monochrom> the logical conclusion of the safeXXXX police is that (==) should have type a -> a -> Maybe Bool
14:21:01 * ski . o O ( "Republic of Haskell - Side effects shall receive no mercy!", <http://lisperati.com/landoflisp/panel57.html> )
14:21:09 <elliott> fsvo logical, conclusion
14:21:14 <Jafet> False | True | FileNotFound
14:21:23 <hpc> Kaidelong: data NonEmpty a = FirstCons a [a]
14:21:35 <Kaidelong> yep
14:21:41 <hpc> is the only way i know of
14:21:47 <ski> Kaidelong : an alternative would be to have some kind of effect system note that `fromJust' is partial, in the type
14:22:24 <Kaidelong> ski: I like effect annotations for types and wonder if that might have been the better way to deal with side effects
14:22:32 <monochrom> here is how to obtain the logical conclusion. lambdabot has a Num instance for functions. Num is a subclass of Eq. Eq doesn't make too much sense for functions. currently the Eq instance for functions is full of partial functions. example:
14:22:39 <monochrom> > (\x -> 0) == (\x -> 0)
14:22:40 <lambdabot>   *Exception: (==): No overloading for function
14:22:56 <elliott> monochrom: that just means the Eq instance for functions in lambdabot amounts to the implementation of an unsafe function
14:22:57 <ski> Kaidelong : i think both approaches has merits
14:23:05 <monochrom> the safeXXXX police wants to replace such partial functions by Maybe.
14:23:05 <elliott> removing it is the logical conclusion, not changing Eq
14:23:33 <monochrom> well, if you remove the Eq instance, you have to remove the Num instance too.
14:23:39 <Cale> The correct solution isn't to make (==) involve Maybe, the correct solution is to remove the superclass constraints on Num
14:23:47 <elliott> monochrom: yes, Num does indeed have unfortunate design decisions
14:23:54 <elliott> (mistakes)
14:23:56 <Kaidelong> Cale: b-but, pattern matching!
14:23:59 <Kaidelong> although
14:24:10 <Kaidelong> in that case, wouldn't that make (==) = fail
14:24:13 <Kaidelong> a correct implementation?
14:24:17 <Cale> Kaidelong: n-patterns will still induce an Eq constraint, there's no problem with that
14:24:20 <Kaidelong> well fail "str"
14:24:22 <monochrom> yeah, the Eq is there for pattern matching. remove pattern matching for numbers, too?
14:24:31 <Cale> No.
14:24:35 <ski> (not all rings are discrete, e.g. the real numbers)
14:24:47 <Cale> monochrom: No!
14:24:58 <Kaidelong> I guess that's true
14:25:06 <Cale> If you use an n-pattern, then (==) will be used, and there will be an inferred Eq constraint
14:25:07 <elliott> monochrom: strawman :P
14:25:10 <Kaidelong> you could just take the pattern matching to mean (Eq a, Num a)
14:25:11 <hpc> or just make pattern matching only work on Eq x, Num x
14:25:14 <Kaidelong> rather than just (Num a)
14:25:17 <Kaidelong> that's a better way
14:25:18 <monochrom> what is n-pattern?
14:25:20 <Cale> Num doesn't need to be a subclass of Eq for that to work
14:25:25 <ski> Cale : yay for fine-grained constraints adding ! :)
14:25:29 <Cale> monochrom: Pattern matching against a number
14:25:36 <hpc> monochrom: fact 0 = 1 -- n-pattern
14:25:41 * ski wants refutable patterns in `do' to add `MonadZero' constraints
14:25:48 <Cale> ski: me too
14:25:55 <Jafet> #haskell, quadrophonic remastering
14:25:59 <Cale> Well, failable patterns
14:26:07 <ski> yeah
14:26:09 <Cale> (x,y) <- whatever
14:26:17 <Cale> shouldn't induce a MonadZero constraint
14:26:18 <monochrom> ok that begs the question, what type class constraint does the n-pattern "f 0 = 1" induce?
14:26:19 * ski forgets the exact definition of the terms in the report
14:26:23 <ski> Cale : *nod*
14:26:52 <Cale> monochrom: f :: (Num a, Eq a, Num b) => a -> b
14:26:59 <hpc> monochrom: (Eq n, Num n, Num m) => ...what Cale said
14:27:07 <ski> it might also be nice to allow non-deterministic patterns in a `do' (and in list/monad comprehensions, obviously)
14:27:10 <Kaidelong> @ty let f 0 = 1 in f
14:27:11 <lambdabot> forall t t1. (Num t1, Num t) => t -> t1
14:27:56 <Cale> because  f 0 = 1  is equivalent to  f x | x == 0 = 1, which is equivalent to  f x = case x == 0 of True -> 1
14:28:02 <monochrom> fine, that works
14:28:13 <Kaidelong> hmm does this mean
14:28:29 <Kaidelong> implementing your function with guards is safer than implementing it with n-patterns?
14:28:30 * ski wonders whether matching on `newtype' constructors, and matching on single-constructor `data' types should generate a `MonadZero' constraint
14:28:30 <Jafet> f x | x == fromInteger 0 = fromInteger 1
14:28:58 <monochrom> but don't forget that there are more partial functions like negate, div, recip, (^^)
14:28:58 <Cale> and then indeed, fromInteger shows up, and that's where you get the Num constraints
14:29:08 <mm_freak> does anyone know a way to get the next index as per Data.Ix.range?
14:29:09 <Kaidelong> it'd probably be simple to implement a GHC extension that erases the difference between the two methods
14:29:11 <Cale> negate isn't partial
14:29:23 <Kaidelong> oh wait no it isn't any safer
14:29:25 <monochrom> negate is partial for every natural number type
14:29:26 <ski> .. i suppose we might these special cases to not generate a `MonadZero' constraint .. at least not in the `newtype' case
14:29:30 <mm_freak> an efficient way that is
14:29:35 <Kaidelong> because Eq is a superclass of Num anyway
14:29:38 <mm_freak> so not by searching through the range list
14:29:52 <Cale> Sure, though it's questionable whether those should be instances of Num, per-se.
14:30:08 <Cale> But yeah
14:30:09 <ski> they ought to be an instance of `Rig'
14:30:13 <monochrom> fromIntegral should be partial when bits are lost
14:30:24 <rwbarton> `um'
14:30:44 <Jafet> (-) is already partial for Nat.
14:30:58 <ski> > fromIntegral 257 :: Int8
14:30:59 <lambdabot>   1
14:31:27 <monochrom> so, according to the safeXXXX police, fromIntegral :: (...) => a -> Maybe b
14:31:28 <ski> monochrom : hm, i'm not convinced of that
14:31:40 <elliott> monochrom: i'm unconvinced these safeXXXX police exist
14:31:45 <ski> hm
14:31:56 <ski> well, at least not in the case of `fromInteger'
14:32:22 <monochrom> they existed just 18 hours ago or something. look into the logs.
14:32:49 <ski> i think of `fromInteger' as the obvious morphism from the ring of integers into whatever ring the target is
14:33:00 <rwbarton> I remember multiple people wondering why (x + y) `mod` 256 :: Word8 didn't work
14:33:02 <ski> (and that doesn't need to be injective)
14:33:08 <elliott> I'm pretty sure nobody actually thinks Haskell should have no partial functions, because that would be called Agda
14:33:45 <ski> rwbarton : well, `mod n 0' ought to be `n' !
14:34:06 <rwbarton> well, true
14:34:15 <Jafet> Or 0, depending on which ring you think it is
14:34:41 <rwbarton> n = 0 * (n `div` 0) + (n `mod` 0) = n `mod` 0
14:34:42 <Jafet> Oh wait, it can't be a ring
14:35:18 <monochrom> sorry, 22 hours ago, search for the exact string "I've half a mind to propose removing fromJust" and start from there
14:35:21 <rwbarton> or just "modding out by the 0 ideal is doing nothing"
14:35:32 <ski> yea
14:36:15 * ski has a similar horn in the side wrt `gcd 0 0'
14:36:28 <rwbarton> oh man, don't get me started on that one!
14:36:30 <mm_freak> there are mfix and loop…  what about afix for Applicative?
14:37:20 <ski> mm_freak : hm, i'm not sure, but it might be "non-idiomatic", since typically applicative structures aren't meant to "depend on run-time data"
14:37:23 <monochrom> afix :: Applifix f => (a -> f a) -> f a ?
14:38:21 <mm_freak> ski: i'm not sure, since Applicative and Arrow are in some sense similar
14:38:27 <mm_freak> monochrom: something like that, yes
14:38:42 <mm_freak> perhaps that would even make MonadFix obsolete
14:38:42 <monochrom> otoh I don't know what laws it should satisfy. even mfix laws are elusive, i.e., the currently stated laws aren't adequate
14:39:03 <maurer> If I declare a datatype in module B, and re-export it in module A, how do I get documentation attached to the type to show up in A's documentation (module B is not user visible)
14:39:23 <mm_freak> maurer: it should by itself
14:39:57 <mm_freak> maurer: if you reexport the entire module B and it's hidden, then i'm not sure (but that would be pointless anyway)
14:40:11 <maurer> mm_freak: I am only re-exporting that type from it
14:40:12 <mm_freak> if you export symbols explicitly, then they should be in the exporting module
14:40:30 <mm_freak> regardless of whether B is exported or not
14:40:31 * maurer re-haddocks to double check
14:40:51 <maurer> Oh, looks like my haddock run was just stale, apologies
14:52:59 <Dodek> hey, suppose i write parser combinators in parsec
14:54:15 <hpaste_> vicvicvic pasted “Parse results as string” at http://hpaste.org/52208
14:54:23 <vicvicvic> whoops
14:54:23 <ocharles> Hrm, ghc-pkg list shows that I have text-0.11.1.5, but everytime I build someting with cabal (from hackage) it seems to rebuild that version of text
14:54:23 <Dodek> and i have parser foo
14:54:29 <ocharles> any idea what's going on there? seems very strange
14:54:48 <Dodek> hmm how can i explain it
14:55:09 <ocharles> I do have a bunch of broken packages which I'm fixing atm, maybe the problem will go away after that
14:55:22 <vicvicvic> is there a simple way of sort of just getting the string that you parsed with a parser in parsec? in my paste i do it with a little helper function but it seems kinda ugly...
14:56:37 <monochrom> ocharles: broken packages are deal to too many packages, not too few. eventually you may have to consider erasing ~/.ghc or a good part of it
14:56:43 <monochrom> s/deal/due/
14:57:22 <ocharles> monochrom: right, I've taken that approach in the past
14:57:44 <ocharles> fixing packages one-by-one atm is going well though
14:57:52 <vicvicvic> maybe fsNummer = (++) <$> count 4 digit <*> ((:) <$> char ':' <*> many1 digit) is clearer, heh :I it just feels like im missing something
14:58:14 <byorgey> vicvicvic: that's the best way I can think of to do that.  it's kind of strange which is why there's no nice way to do it.
14:58:20 <ocharles> meh, installing aeson breaks it gain
14:58:22 <ocharles> nuking time
14:58:37 <byorgey> vicvicvic: it's strange because you go to the effort of recognizing certain structure in the input and then just throw it away.
14:58:45 <byorgey> throw away the structure, that is.
14:58:46 <Dodek> ok, so i want to have a combinator that parses "#\foo", "#\bar", #\<single character", but fails on "#\<multiple characters different than foo and bar>"
14:58:51 <Dodek> how can i do that?
14:59:12 <bfig> what does 'data Stmt = String := Expr' means?
14:59:13 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml may hint at how to pinpoint erasure or avoid the problem to begin with. (but surely it's written in the humorous style of how to cause the problem)
14:59:42 <rwbarton> bfig: (:=) is just a data constructor written in infix notation there
14:59:43 <ocharles> bfig: I think (:=) is a type constructor
14:59:43 <vicvicvic> byorgey: yeah, i understand that :) maybe im going about it the wrong way then? i'm really just interested in verifying that the pattern is there
15:00:01 <ocharles> sorry, value constructor, not type, as rwbarton said
15:00:11 <rwbarton> like (:) for lists
15:00:12 <bfig> so data constructors can be infix? cool.
15:00:13 <dankna> @hoogle foldM
15:00:13 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
15:00:13 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
15:00:13 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
15:00:15 <ocharles> so it's just an infix function
15:00:23 <ocharles> bfig: data constructors are just functions :)
15:00:27 <monochrom> "data Stmt = String := Expr" is like "data Stmt = CTor String Expr" except you want it infix
15:00:50 <bfig> can you also do 'data Stmt = (:=) String Expr' ?
15:00:59 <monochrom> I believe no
15:01:14 <monochrom> too lazy to check the Haskell Report for that
15:01:50 <monochrom> but you can write (:=) "hello" undefined when you write a value
15:02:24 <vicvicvic> byorgey: or, is there maybe a simple way of just getting each subparser's result into a list?
15:02:41 <bfig> cool :)
15:02:49 <cgroza> Is Data.List.permutations lexicographical?
15:03:06 <maurer> http://hpaste.org/52209
15:03:14 <maurer> wtf is going on?
15:04:13 <cgroza> Is there a permutation function that does it lexicographicaly?
15:05:12 <c_wraith> it's hard to make lexicographic ordering efficient in haskell.
15:05:15 <c_wraith> I've tried.
15:05:16 <dafis_> maurer: float.h not in the search path??
15:05:40 <c_wraith> but singly-linked immutable lists are not a great data structure for permuting lexicographically
15:06:25 <dafis_> > permutations [0,1,2]
15:06:26 <lambdabot>   [[0,1,2],[1,0,2],[2,1,0],[1,2,0],[2,0,1],[0,2,1]]
15:06:44 <maurer> dafis_: Nevermind, this isn't a haskell problem, my toolchain became fuxed
15:06:46 <c_wraith> the algorithm used by permutations was chosen to be as fast as possible while being lazy
15:07:06 <c_wraith> > map (take 3) $ permutations [1..]
15:07:07 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[4,3,2],[3,4,2],[3,2,4],[4...
15:07:11 <cgroza> c_wraith: ok. thanks.
15:07:24 <c_wraith> that's right!  It can permute an infinite list!
15:09:41 <rwbarton> that's pretty neat, does that code eventually produce every sequence of three distinct elements of [1..]?
15:10:05 <ski> hm, i suppose that generates every permutation with finite support ?
15:10:06 <c_wraith> if it doesn't there's a bug in it. :)
15:10:32 <rwbarton> exactly once each, I should add
15:10:44 <c_wraith> exactly once, I doubt
15:10:54 <rwbarton> oh, it must not
15:11:01 <c_wraith> it should produce them all infinite times, in fact
15:11:05 <rwbarton> > map (take 1) $ permutations [1..]
15:11:07 <lambdabot>   [[1],[2],[3],[2],[3],[1],[4],[3],[3],[4],[2],[2],[4],[1],[1],[4],[2],[2],[4...
15:11:42 <mm_freak> > find (== [4,3,2]) . map (take 3) . permutations $ [1..]
15:11:44 <lambdabot>   Just [4,3,2]
15:11:45 <rwbarton> strange, what sequence is this
15:11:59 <mm_freak> > find (== [8,7,6]) . map (take 3) . permutations $ [1..]
15:12:01 <lambdabot>   Just [8,7,6]
15:12:11 <mm_freak> it's quite fast
15:12:17 <mm_freak> > find (== [15,14,13]) . map (take 3) . permutations $ [1..]
15:12:21 <lambdabot>   mueval-core: Time limit exceeded
15:12:26 <c_wraith> not that fast
15:12:26 * ski suspects it might use a lot of space for later elements
15:12:27 <c_wraith> :)
15:12:46 <mm_freak> @src permutations
15:12:46 <lambdabot> Source not found. Take a stress pill and think things over.
15:13:02 <c_wraith> Its source is rather large and complex
15:13:10 <c_wraith> it's probably the single most complicated function in Data.List
15:13:19 <rwbarton> not in OEIS
15:13:20 <mm_freak> thought so
15:14:06 <rwbarton> > concat $ map (take 1) $ permutations [1..]
15:14:07 <lambdabot>   [1,2,3,2,3,1,4,3,3,4,2,2,4,1,1,4,2,2,4,1,1,4,3,3,5,4,4,4,5,3,3,3,5,2,2,2,5,...
15:14:19 <c_wraith> rwbarton: why not just "map head"? :P
15:14:26 <rwbarton> hush :P
15:14:50 <rwbarton> it's called iterative design
15:14:54 <ion> concatMap! :-P
15:14:59 <shachaf> > concatMap (take 1) [[1,2],[],[3]]
15:15:00 <lambdabot>   [1,3]
15:15:31 <c_wraith> shachaf: sure, but how many permutations of an infinite list are going to be empty?
15:15:42 <hpc> > take 1 =<< [[1,2],[],[3]]
15:15:42 <lambdabot>   [1,3]
15:15:44 <hpc> :P
15:16:05 <ion> c_wraith: The (∞−9)th element is.
15:16:11 <rwbarton> > concat $ map (show . head) $ permutations [1..]
15:16:12 <lambdabot>   "12323143342241142241143354445333522253335222544451115222522251115333533351...
15:16:37 <c_wraith> that loses information...  If any of them ever reached two digits
15:17:09 <ion> head loses information
15:18:42 <c_wraith> > elemIndex 10 . map head . permutations $ [1..]
15:18:44 <lambdabot>   Just 362880
15:18:51 <c_wraith> That's...  quite a long ways in
15:19:01 <rwbarton> yeah I wasn't too worried about that :P
15:19:01 <dafis> 9!
15:19:09 <mm_freak> @let myPermutations = foldM (flip $ \y -> liftA2 (zipWith $ \l r -> r ++ y:l) inits tails) []
15:19:11 <lambdabot>  Defined.
15:19:17 <mm_freak> > myPermutations "abcd"
15:19:19 <lambdabot>   ["abcd","bcda","cdab","dabc","bcad","cadb","adbc","dbca","cabd","abdc","bdc...
15:21:17 <ski> > take 1 =<< permutations [0 ..]
15:21:17 <lambdabot>   [0,1,2,1,2,0,3,2,2,3,1,1,3,0,0,3,1,1,3,0,0,3,2,2,4,3,3,3,4,2,2,2,4,1,1,1,4,...
15:21:31 <ski> @oeis 0,1,2,1,2,0,3,2,2,3,1,1,3,0,0,3
15:21:40 <lambdabot>  Sequence not found.
15:22:24 <Pseudonym> > permutations "abc"
15:22:25 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
15:22:32 <sipa> > myPermutations "1111"
15:22:34 <lambdabot>   ["1111","1111","1111","1111","1111","1111","1111","1111","1111","1111","111...
15:22:37 <Pseudonym> I don't think that's canonical ordering.
15:22:48 <Pseudonym> Surely it'd be abc acb bac bca cab cba
15:22:53 <Pseudonym> Lexicographic.
15:23:16 <dafis> Pseudonym: but that wouldn't work well with infinite lists
15:23:44 <Pseudonym> Sure, but that explains why it's not on oeis.
15:27:58 <ski> @let select :: MonadPlus m => [a] -> m (a,[a]); select [    ] = mzero; select (a0:as0) = return (a0,as0) `mplus` liftM (second (a0 :)) (select as0)
15:27:59 <lambdabot>  Defined.
15:31:41 <ski> @let yourPermutations [] = return []; yourPermutations as0 = uncurry liftM . ((:) *** yourPermutations) =<< select as0
15:31:43 <lambdabot>  Defined.
15:31:50 <ski> > yourPermutations "abc" :: [String]
15:31:52 <lambdabot>   ["abc","acb","bac","bca","cab","cba"]
15:31:57 <Leemp2> Pardon my ignorance, but can anyone guide me to how i would find the "haddock-comments" for the hackage vty library? In the readme, it notes that the only documentation lies in the haddock-comments and the demo program.
15:32:07 <ski> ^ lexicographic
15:32:34 <mm_freak> Leemp2: either on hackage or in your local installation, if you have "Documentation: True" in your ~/.cabal/config
15:33:35 <Leemp2> Here: http://hackage.haskell.org/package/vty ?
15:34:55 <ocharles> Leemp2: you can build the documentation with `cabal haddock` too, if you have a check out of the source code
15:34:59 <mm_freak> Leemp2: yes, in the "Modules" section
15:35:05 <mm_freak> on that page
15:35:24 <mm_freak> the haddock documentation is automatically generated from the source code comments
15:35:32 <Leemp2> Ah hah
15:35:52 <Leemp2> So, likely this project has mostly api docs, more than straight "FAQ/Howto/etc" documentation?
15:36:09 <ocharles> probably, as is the sad case with 90% of stuff on hackage
15:36:52 <Leemp2> k. I had a hard time figuring out if it was this case, or of my insane newness to Haskell was leading to obvious shortfalls in my searching abilities. Thanks all :)
15:37:08 <Leemp2> Looks like i'll stick with some basic Snap tutorials for now. :)
15:38:30 <DukeDave> If I do "liftM (||) ma mb", and ma evaluates to True, will mb be 'run' ?
15:39:36 <dylukes> You mean evaluated?
15:39:39 <benmachine> dylukes: yes
15:39:40 <DukeDave> Context, I was to return false if a file doesn't exist (ma) or its contents have changed(mb); but the readFile used in mb will error if the file doesn't exist.
15:39:41 <benmachine> er
15:39:43 <benmachine> DukeDave: yes
15:39:57 <benmachine> I suspect you mean liftM2
15:40:04 <mm_freak> Leemp2: the good thing is that mostly you can very well learn a library by just looking at the API docs, because the types are very expressive
15:40:04 <dylukes> Maybe you want bracketing?
15:40:08 <DukeDave> benmachine: Ah, yes, indeed I do
15:40:24 <benmachine> DukeDave: if you want to do mb conditionally, you'll have to be a little cleverer
15:40:31 <mm_freak> Leemp2: also it's perfectly fine to write the whole documentation in haddock…  some people do that
15:40:36 <dylukes> or just use a case statement :|
15:40:53 <dylukes> mm_freak: I find a mix of haddock and examples is good :)
15:41:12 <DukeDave> dylukes: Are you suggesting I use a case statement?
15:41:14 <Leemp2> mm_freak: I'm *very* new, i just want to be able to write test code with a little more purpose than writing in GHCi while i go through this Haskell book
15:41:16 <benmachine> you can define something like ifM mb mt mf = do b <- mb; if b then mt else mf
15:41:18 <dylukes> DukeDave: you could.
15:41:37 <benmachine> then ifM will only execute one of mt and mf
15:41:42 <dylukes> case fileExists of True -> ...  False -> ...
15:41:51 <DukeDave> benmachine: Perhaps 'when' is what I'm looking for?
15:41:53 <Leemp2> mm_freak: Learning Haskell has made it very clear to me that my self tought programming "abilities" are lacking to say the least. :)
15:41:54 <mm_freak> Leemp2: i'm not sure where you can find book/tutorial-style documentation, but really, give the API docs a shot
15:42:02 <benmachine> DukeDave: that might do the trick, yeah
15:42:05 <DukeDave> But a 'when' which keeps its result :|
15:42:06 <dylukes> DukeDave: when is
15:42:09 <dylukes> @hoogle when
15:42:10 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
15:42:11 <benmachine> can't do that, sry
15:42:13 <dylukes> unit.
15:42:16 * DukeDave nods
15:42:19 <benmachine> nest the whens!
15:42:24 <mm_freak> Leemp2: don't worry…  the less you know about "programming", the easier it will be to pick up haskell
15:42:27 <dylukes> Stop whening!
15:42:56 <benmachine> MaybeT is probably overkill for your problem, but it's cute anyway
15:43:07 <Leemp2> mm_freak: Well, i was thinking more like getting a *basic* snap host running (seems very simple from a few sources), then as i gain knowledge, set out to write code on that website. Adding logic as i learn, etc.
15:43:08 <a11235> FYI: Steve Jobs died
15:43:31 <dylukes> a11235: just saw
15:43:50 <mm_freak> Leemp2: sounds fine to me
15:44:04 <DukeDave> "Twitter is over capacity" :|
15:44:13 <Leemp2> GHCi learning and hello world programs, in any language, tend to drain the humanity out of my soul. So i was looking for something i could write that actually did, something. Heh. :)
15:44:45 <erasmas> Leemp2: I'm jumping in late but have you checked out Real World Haskell? it's really engaging as you learn
15:45:14 <Leemp2> erasmas: I'm going through the Learn You a Haskell book at the moment. Do you suggest i pick up a 2nd book?
15:45:54 <Leemp2> erasmas: I'm not having a problem with learn you a haskell, it's just that languages, especially haskell, can be a lot to absorb without actually programming along the way. That's all :)
15:46:02 <erasmas> Learn You a Haskell is probably a better introduction, but when I was learning I worked through chapters of Real World Haskell at the same time.
15:46:03 <DukeDave> Ooh, what about: "do {fExists <- fileExist f; if (not fExists) return False else checkFileContents}"   ?
15:46:19 <erasmas> RWH lets you start building real things right away so it stays interesting. It's free (legally) online
15:47:33 <Leemp2> LYaH (Learn You a Haskell) did confuse me a bit with Currying though. It explained "multiThree 1 2 3" as if the function multiThree actually executes "multiThree 1", and actually processes that a bit. Which confused the hell out of me
15:48:02 <ion> (+) :: Integer → Integer → Integer
15:48:07 <ion> (+) 1 :: Integer → Integer
15:48:10 <Leemp2> I assume currying "stores" values (and returns functions) of any functions until all the parameter conditions are met?
15:48:11 <ion> (+) 1 2 :: Integer
15:48:33 <ion> plus a b = a + b
15:48:36 <ion> which is sugar for
15:48:45 <ion> plus = \a -> (\b -> a + b)
15:49:06 <ion> plus 1 = (\a -> (\b -> a + b)) 1 = (\b -> 1 + b)
15:49:12 <Leemp2> I should probably shut up, my poor ability to explain this in improper terms is going to lead to confusion to everyone and doubly so on me haha.
15:49:13 <ion> plus 1 2 = (\b -> 1 + b) 2 = 1 + 2
15:49:40 <Axman6> > map (min 1) [0..]
15:49:41 <lambdabot>   [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:50:03 <mauke> Leemp2: that sounds about right
15:50:23 <Axman6> Leemp2: that explanation was pretty accurate really
15:50:32 <Leemp2> Axman6, mauke: :)
15:51:51 <Daegalus> http://www.apple.com/stevejobs/
15:53:08 <monochrom> a coming-soon version of GHC will have GHCi supporting everything you could do in *.hs files
15:53:39 <monochrom> perhaps just almost everything. I forgot whether "module Haha where" is supported
15:53:49 <ion> Woot
15:54:05 <monochrom> anyway great news for those who like to learn at the prompt
15:54:16 <ion> Will it support referencing things defined later? :-P
15:54:32 <byorgey> haha, good question
15:55:25 <monochrom> and saves us the trouble of answering the FAQ "why can't I data X = X in ghci?" well now you can!
15:56:21 <byorgey> will it support writing  x = 3   rather than   let x = 3 ?
15:56:39 <byorgey> that's a ten times more FA'ed Q
15:56:44 <hpaste_> scooty-puff pasted “Interesting Memory Leak?” at http://hpaste.org/52210
15:57:12 <hpaste_> DukeDave pasted “openFile: resource busy (file is locked)” at http://hpaste.org/52211
15:58:16 <monochrom> next challenges are memory leaks and handle leaks :)
15:58:58 <byorgey> DukeDave: you can't do that with readFile and writeFile
15:59:02 <DukeDave> monochrom: Damn IO :(
15:59:12 <DukeDave> byorgey: Apparently not
15:59:40 <monochrom> I have a feeling that the deeqseqs hurt rather than help
15:59:42 <DukeDave> It seemed like an innocuous enough problem
15:59:44 * ddarius recommends getting rid of memory and files.
15:59:55 <stribor> i have in my program type MyType = [Int]....now when i am trying to interpret on ghci this ........:t MyType i get error "ot in scope: data constructor `MyType'
15:59:56 <ddarius> DeepSeq is sin.
16:00:18 <byorgey> DukeDave: I forget the precise explanation, but it's something to do with the fact that readFile is lazy
16:00:28 * DukeDave nods
16:00:29 <byorgey> so when it comes time to write the file it hasn't finished reading it yet
16:00:32 <DevHC_> given an association list (a list of (key,value)s) and a key, f finds the value for which (key,value) is contained in the list. which one of the following is the most correct to say:
16:00:32 <DevHC_> f looks up a key in a list
16:00:32 <DevHC_> f looks up a pair/entry in a list
16:00:32 <DevHC_> f looks up a value in a list
16:00:32 <DevHC_> ?
16:00:47 <DukeDave> byorgey: I had rather hoped that I could resolve it with "evaluate"
16:00:51 <scooty-puff> monochrom, just wanted to make sure that the values were fully evaluated without just printing them
16:01:17 <byorgey> DukeDave: you might.  but it's probably just as easy to explicitly open and close the file
16:01:29 <DukeDave> byorgey: Yeah, it doesn't work..
16:01:43 <stribor> why cant i get the type from ghci
16:02:51 <DevHC_> stribor: use :i
16:03:04 <DukeDave> byorgey: But I can't used openFile because the file may not exist..
16:03:21 <DukeDave> I suppose I could use it and perhaps do some error handling?
16:03:37 <byorgey> DukeDave: what? if the file doesn't exist you can't do readFile either.  what's the difference?
16:03:54 <stribor> DukeDave: why dave?
16:04:12 <DukeDave> Oh, sorry, getting confused :|
16:04:29 <byorgey> DukeDave: just keep what you have but replace readFile with an open followed by a read from the handle followed by a close.
16:04:46 <DukeDave> byorgey: Got it, thanks :)
16:05:19 <monochrom> scooty-puff: have you seen my http://www.vex.net/~trebla/haskell/lazy.xhtml ? its last case study "average" is a simple illustration of a phenomenon you must understand first before tackling more complicated programs
16:05:54 * B|V|eph likes "f matches (if it exists) a key in a key/value list." ;)
16:07:29 <scooty-puff> monochrom, reading noe
16:07:31 <scooty-puff> *now
16:11:34 <DukeDave> Noooo
16:11:49 <DukeDave> byorgey: So, here's an interesting fail..
16:12:26 <DevHC_> BMeph: unfortunately i can't use that terminology.
16:12:38 <hpaste_> DukeDave annotated “openFile: resource busy (file is locked)” with “openFile: resource busy (file is locked) (annotation)” at http://hpaste.org/52211#a52214
16:13:19 <DukeDave> byorgey: Without the hClose, the current line count is printed, but when I hClose then the line count is zero
16:13:53 <scooty-puff> monochrom, after a quick skim (before other topics come up), in the case i posted, the nonsharing versino was shown to leak memory - perhaps without the deepseq in a "real" environment, the assumption is fully evauation or atleast the full lists wouldn't be needed (this is after really quick skim)
16:14:04 <scooty-puff> "leak"
16:14:05 <BMeph> DevHC_: Then may I suggest: "f sends a message to the list, asking for a key matching its ":key" parameter"? :D
16:14:16 <monochrom> I think the original "given an association list (a list of (key,value)s) and a key, f finds the value for which (key,value) is contained in the list" is just fine.
16:15:45 <BMeph> I think it needs more talk about stack frames. No talk about computer evaluation is "real" without talking about stack frames - all of the C gurus say so! ;)
16:15:46 <monochrom> I don't see a non-shared version. xs is being shared by almost everyone
16:16:49 <scooty-puff> tails'' doesn't shared "map snd xs" similar to how tails' does - though i may be misinterpretting the .prof
16:17:03 <hpaste_> DukeDave annotated “openFile: resource busy (file is locked)” with “openFile: resource busy (file is locked) (annotation)” at http://hpaste.org/52211#a52215
16:17:13 <monochrom> well you have "tail' xs" and "tail'' xs". that shares xs.
16:17:20 <DukeDave> This works, but is hideous^
16:17:36 <scooty-puff> o right, meant in like tails' impl vs. tails'' impl
16:17:41 * DukeDave particular enjoys the dummy 'stdin'
16:18:25 <monochrom> I don't care what's in each stack frame. I say that at the asymptotic level, no one should care. the only important point is how many stack frames and why
16:18:28 <scooty-puff> my major concern is if i need to be aware of nonsharing where sharing could occur while writing anything in particular - if it will result in such horrible performance
16:18:37 <scooty-puff> ok
16:19:10 <monochrom> if you don't share, you re-compute, may save space and spend extra time
16:19:13 <scooty-puff> (at n == 100, tails' is 4% or mem, tails'' is 90%)
16:19:25 <scooty-puff> ok - so the deepseq is misleading in this example
16:19:52 <scooty-puff> (misleading to me anyways)
16:20:32 <monochrom> if you take 100 hours to compute one Int, you should share it, takes little space and saves multiple instances of 100 hours. if you compute a long long list, the best tradeoff is less obvious
16:21:44 <monochrom> this principle translated to alcohol: share your whiskey/brandy, don't share beer :)
16:22:41 <DevHC_> BMeph: nothx
16:22:45 <DukeDave> Bah, how is this so complicated :'(
16:23:04 <scooty-puff> k - now to go over the link
16:23:10 <DevHC_> BMeph, monochrom: i'm trying to pick a function name which is a bit longer than "lookup"
16:23:23 <DevHC_> which one of the following would be more correct:
16:23:32 <DevHC_> lookupEntry, lookupValue, lookupKey
16:23:35 <DevHC_> ?
16:23:55 <ddarius> monochrom is just trying to get you to give him your good alcohol.
16:25:15 <roconnor> @hoogle toIntegral
16:25:15 <lambdabot> No results found
16:25:29 <roconnor> @type toIntegral
16:25:30 <lambdabot> Not in scope: `toIntegral'
16:25:42 <roconnor> @type toInteger
16:25:43 <lambdabot> forall a. (Integral a) => a -> Integer
16:25:48 <BMeph> DevHC_: passAKeyToAssocListToGetValue. It'll make the Java crowd feel all Warm and Fuzzy! ;þ
16:26:33 <ddarius> BMeph: AssocList.valueFactory.setKey(key).get()
16:26:36 <DevHC_> lol
16:26:38 <tkahn6> @type fromIntegral
16:26:39 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:27:16 <DevHC_> this appears to be a very tough question!
16:27:25 <ddarius> That should probably be valueFactorySingleton to clarify.
16:27:37 <monochrom> it is tough because you reject the perfectly correct "lookup"
16:27:40 <monochrom> @type lookup
16:27:41 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
16:28:10 <monochrom> > lookup "x" [("y", 4), ("xx", 3), ("x", 2), ("x", 1)]
16:28:12 <lambdabot>   Just 2
16:28:20 <companion_cube> hey, i'm enjoying doing C!
16:28:24 <DevHC_> tell me something i don't know
19:00:45 --- topic: '["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin/spam issues: #haskell-ops"]'
19:00:45 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Sep 03 10:10:12 2011]
19:07:27 <DukeDave> jaapweel: Thanks again for the strace suggestion, this is just what I need
19:07:40 <jaapweel> DukeDave: np
19:07:43 <freeasjesus> what's the haskell chat channel called?
19:07:53 <jaapweel> freeasjesus: #haskell, you're in it
19:07:59 <donri> ^_^
19:08:11 <freeasjesus> jaapweel: I mean the off-topic one... I could've sworn I was in it the other week...
19:08:18 <jmcarthur> #haskell-blah
19:08:27 <freeasjesus> jmcarthur: <3
19:08:30 <DukeDave> Now I just have to figure out which part of "ReadMode" GHC doesn't understand :(
19:08:54 <jaapweel> Hmm… so you're trying to open a file in read mode and it actually opens it in writ emode?
19:09:06 <jaapweel> Does strace tell you what flags were passed to open()?
19:09:21 <jaapweel> (BTW, you can filter for a particular syscall, like e.g. strace -eopen to get only open() )
19:33:19 <monochrom> DukeDave: don't forget the possibility that you have two pieces of code, one says openFile ReadMode, another says openFile WriteMode or something
19:33:48 <DukeDave> monochrom: It's okay, it was an error in the logic
19:34:01 <DukeDave> Good suggestion though!
19:34:44 * DukeDave wishes we didn't actually have to *do* IO, can't we all just prove it works and be done?
19:35:23 <monochrom> that would be Coq or PVS or Isabelle etc
19:36:10 <monochrom> but sometimes I want IO done because that's how I have games to play
19:36:11 <shachaf> main :: IO (); main = undefined
19:37:00 <monochrom> (no fun just proving that Age of Empires III can display soldiers)
19:37:07 <shachaf> monochrom: Like Red Alert 3?
19:37:14 <shachaf> Oh.
19:37:24 <monochrom> yeah! except I'm still at Age of Empires III
19:37:38 <monochrom> I don't think my computer is capable of Red Alert 3.
19:37:55 <ddarius> monochrom: You could just prove that you would have fun playing the game and be done with it.
19:38:18 <shachaf> monochrom: Really? Even in the lowest settings?
19:38:27 * shachaf doesn't get why they had to make it 3D at all, of course.
19:38:32 <monochrom> I don't know for sure. I should find out one day
19:38:38 <ddarius> Gdel and Tarski would approve of this conversation.
19:38:53 <ddarius> shachaf: 2D games don't sell, silly.
19:38:55 <monochrom> Dijkstra too :)
19:40:06 <shachaf> ddarius: 2.5D, then.
19:41:02 <shachaf> ddarius: By the way, I suspect something is wrong with either your or my IRC client.
19:41:12 <shachaf> I see "G�del"
19:41:22 <luite> 2.5D, is that in Hausdorff dimensions?
19:47:41 <ddarius> "Descent theory has a somewhat formidable reputation among algebraic geometers. In fact, it simply says that under certain conditions homomorphisms between quasi-coherent sheaves can be constructed locally and then glued together if they satisfy a compatibility condition, while quasi-coherent sheaves themselves can be constructed locally and then glued together via isomorphisms that satisfy a cocycle condition."
19:47:49 <ddarius> And really, what could be clearer than that?
19:51:44 <Cale> "Ohhhhhhh... is that all."
19:52:17 <Saizan> seems easy to prove too, under certain conditions
19:54:03 <Lemonator> @hoogle liftIO
19:54:04 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
19:54:54 <tactics> ddarius: is what you said a real thing?
19:55:41 <ddarius> Yes.
19:56:59 <shachaf> preflex: seen monochrom
19:56:59 <preflex>  monochrom was last seen on #haskell 18 minutes and 4 seconds ago, saying: Dijkstra too :)
19:57:25 <Cale> I almost understand all the words in it.
19:59:12 <ddarius> The only thing I don't believe I've read a definition of is "quasi-coherent sheaf."  I know what a sheaf is.
20:00:40 <Cale> "A quasicoherent sheaf is a sheaf of modules over the structure sheaf of a space that is locally presentable in that it is locally the cokernel of a morphism of free modules."
20:04:58 <parcs> what's the cokernel of linux?
20:05:47 <DanBurton> erm...solaris?
20:06:19 <rwbarton> linux -> gnu -> gnu/linux
20:06:55 <rwbarton> linux is the kernel so gnu/linux must be the cokernel
20:07:09 <shachaf> flip (/) :: linux -> gnu -> gnu/linux?
20:08:07 <Cale> rwbarton: hahaha
20:08:36 <DanBurton> @quote rms
20:08:37 <lambdabot> newsham says: caffine transforms
20:08:50 <DanBurton> not exactly what I was looking for
20:08:52 <DanBurton> @botsmack
20:08:52 <lambdabot> :)
20:16:14 <DanBurton> So...regarding this: http://stackoverflow.com/questions/7546949/whats-the-smoothest-way-to-update-haskell-platform-to-latest
20:16:50 <DanBurton> why don't we have an upgrade tool?
20:17:48 * DanBurton glares menacingly at the 760 users in the room
20:17:58 <ddarius> DanBurton: I blame DanBurton.
20:18:16 <DanBurton> ddarius: I guess that's true. We don't have an upgrade tool because I didn't write one.
20:19:05 <DukeDave> Isn't this the beauty of a lazy language, the community just didn't bother writing it until someone actually tried to use one :)
20:19:14 <monochrom> due to technical reasons of GHC, there is no need to "upgrade"
20:19:40 <Cale> New versions of platform/GHC come out so rarely that I don't really feel much need to have a special upgrade too.
20:19:43 <Cale> tool*
20:19:48 <ivanm> DukeDave: well, first of all, it would be platform-specific...
20:20:02 <ivanm> and cabal-install is working towards having a concept of a "world" list of installed packages
20:20:41 <Cale> All I end up doing is installing the generic linux binary of the new GHC, and then running cabal install cabal-install just to make sure I have the latest of that, and then start installing stuff.
20:20:52 <ivanm> Cale: do you know of any way of abstracting out having a BFS vs DFS for re-numbering a graph?
20:20:56 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for why you can't reuse libraries when changing GHC anyway, and why you shouldn't replace certain libraries when keeping GHC
20:21:33 <monochrom> so, there is no such thing as "upgrade". you just install the new version, optionally nuke the old version.
20:22:07 <monochrom> see my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml for an easy scheme to keep multiple versions
20:22:51 <ddarius> ivanm: Abstract out the choice of stack v. queue?
20:23:20 <ivanm> ddarius: it's not quite that simple due to cycles in the graph
20:23:47 <ivanm> wait, actually... that might work though
20:23:54 <MjrTom> any quick insight into why EclipseFP is giving me "Loading package double-conversion-0.2.0.1 ... <command line>: can't load .so/.DLL for: stdc++ (addDLL: could not load DLL)"?
20:24:00 <ivanm> do the cycle testing and then if it hasn't been visited yet add it to the data structure
20:24:18 <MatrixFrog> MjrTom: mac/win/linux?
20:24:22 <MjrTom> win
20:24:27 <luite> MjrTom: hmm, that package has a known problem being incompatible with ghci and template haskell
20:24:35 <ivanm> MjrTom: there are some issues with that
20:24:46 <ivanm> you can explicitly build double-conversion to use native Haskell rather than C++
20:25:09 <MjrTom> ah ok I'll see about finding native haskell then - thx
20:25:31 <JoeyA> Is the exception masking state more complex than just "masked" or "not masked" ?
20:25:32 <ivanm> wait, I lie
20:25:49 <ivanm> that must have been some other library by bos that had that flag
20:26:10 <MjrTom> oh ... so I don't need a different Haskell?
20:27:10 <ivanm> nope
20:27:22 <ivanm> but compare for example blaze-textual vs blaze-textual-native
20:27:23 <luite> probably blaze-textual?
20:27:28 <ivanm> luite: yeah
20:27:58 <luite> yesod uses the forked -native versions to prevent these problems
20:28:38 <MjrTom> so, not the dl from http://hackage.haskell.org/platform/windows.html ? can you give me a clue where I should get the forked one?
20:29:40 <luite> MjrTom: no it's not included with the platform, probably installed by some other package that you cabal installed
20:35:34 <JoeyA> Is it safe to call the restore callback from mask in a child thread?
20:35:54 <JoeyA> (looking at the source code, it currently is, since that callback is simply Control.Exception.unblock
20:36:40 <JoeyA> (or possibly id, if exceptions were already blocked)
20:41:15 * DanBurton just got the sudden urge to register the domain name "hoogletime.com"
20:41:38 <MatrixFrog> stop
20:41:40 <MatrixFrog> hoogle time
20:41:51 <DanBurton> We should make t-Shirts
20:42:15 <shachaf> hoogle.org was just registered <2 weeks ago.
20:42:19 <shachaf> Now it's squatted.
20:42:31 <cheater> hi
20:42:40 <cheater> wavewave: you around? :)
20:43:53 <MatrixFrog> preflex: seen wavewave
20:43:54 <preflex>  wavewave was last seen on #haskell 20 hours, 20 minutes and 49 seconds ago, saying: anyway, need to sleep now.. good night haskellers.
20:44:24 <cheater> MatrixFrog: yeah, he was saying that to me. :p
20:44:35 <parcs> ghc should be a package that one can cabal install
20:45:08 <JoeyA> I think I noticed a bug in System.Timeout.  In theory, the timer thread is not killed (the killThread in there is a no-op).
20:45:59 <JoeyA> This is because 'bracket' masks exceptions when it executes the before and after actions.
20:46:31 <JoeyA> (or is ThreadKilled not affected by 'mask' ?)
20:47:16 <DanBurton> parcs: agree
20:47:39 <kmc> JoeyA, the timer thread or the thread running the user's action?
20:47:48 <JoeyA> kmc: The timer thread
20:47:53 <kmc> ah i see
20:47:53 <kmc> right
20:48:07 <kmc> well that's not a bug in the user-observable behavior, is it?
20:48:25 <JoeyA> It's not, except it leaks timer threads.
20:49:01 <JoeyA> Is there an action to tell me how many threads are currently running?
20:50:40 <JoeyA> Hmm, I'm not seeing a leak.
20:50:58 <JoeyA> (by looking at memory usage after running timeout over and over)
20:51:10 <JoeyA> (err, with forever)
20:51:26 <JoeyA> Unless it's just leaking slowly.
20:52:08 <bfig> which are the most important CT concepts applied in functional programming? i've seen functor/applicative functor/monad/natural transformation
20:52:30 <DanBurton> JoeyA: regarding "is there an action to tell me how many threads are currently running"..erm...no clue. But that seems like something you should be able to easily track manually.
20:52:41 <monochrom> natural transformation IMO. it's parametricity.
20:52:54 <JoeyA> DanBurton: Not when the threads are implemented in a library.
20:53:00 <bfig> what about adjoint functors?
20:53:01 <monochrom> @free reverse
20:53:02 <lambdabot> $map f . reverse = reverse . $map f
20:53:15 <monochrom> that is a statement of natural transformation
20:53:45 <DanBurton> @help free
20:53:46 <lambdabot> free <ident>. Generate theorems for free
20:54:09 <monochrom> @free id
20:54:10 <lambdabot> f . id = id . f
20:54:13 <bfig> is that related to the paper theorems for free? :p
20:54:18 <monochrom> yes
20:54:23 <bfig> awesome :)
20:55:12 <bfig> @free f::(a->b)->(c->d)->(a->d)
20:55:12 <lambdabot> h . q = f1 . g => p . f2 = f3 . k => p . f q f2 = f f1 f3 . g
20:55:32 <monochrom> put f = const x. then f . id = id . f  tells you x = id x. in fact...
20:55:40 <monochrom> @free myid :: a->a
20:55:41 <lambdabot> f . myid = myid . f
20:55:43 <bfig> @free f::(a->b)->(b->c)->(a->c)
20:55:43 <lambdabot> h . p = q . g => k . f1 = f2 . h => k . f p f1 = f q f2 . g
20:55:51 <monochrom> that tells you x = myid x
20:56:19 <monochrom> from the type a->a you can deduce much. that's parametricity and/or natural transformation
20:56:39 <monochrom> @free myfst :: (a,b) -> a
20:56:40 <lambdabot> f . myfst = myfst . $map_Pair f g
20:57:16 <monochrom> again, with suitable choices of f and g, that tells you x = myfst (x, y)
20:57:42 <bfig> @free weird :: (a->b->c)->d
20:57:42 <lambdabot> (forall x. h . p x = q (f x) . g) => k (weird p) = weird q
20:58:01 <kmc> @free unsafeCoerce :: a -> b
20:58:02 <lambdabot> g . unsafeCoerce = unsafeCoerce . f
20:58:35 <monochrom> that tells you that anything can happen. anything! :)
20:59:48 <DanBurton> @faq can Haskell make anything happen with unsafeCoerece?
20:59:49 <lambdabot> The answer is: Yes! Haskell can do that.
20:59:52 <JoeyA> Actually, it seems bracket isn't actually masking exceptions from being thrown to a child thread of the before action.
21:00:00 <JoeyA> and I don't understand why.
21:00:09 <JoeyA> forkIO is supposed to inherit the masked state of the parent.
21:00:23 <JoeyA> Maybe I'll try it in real GHC, rather than GHCi.
21:01:39 <monochrom> that reminds me. by default, GHCi does a forkIO to run your expression every time
21:02:43 <monochrom> -fno-ghci-sandbox turns it off
21:03:10 <monochrom> "Turn off the GHCi sandbox. Means computations are run in teh main thread, rather than a forked thread." is the exact wording. including "teh" :)
21:03:52 <tac> @check \n -> n * n * n == let odds = 1 : map (+2) odds in sum $ take n $ drop (n-1) odds
21:03:53 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n"
21:06:11 <hpaste_> “Joey Adams” pasted “forkIO doesn't inherit the mask state after all” at http://hpaste.org/52225
21:10:18 <JoeyA> Maybe my definition of "asynchronous exception" is wrong.
21:10:29 <JoeyA> I figured it meant "exception from another thread"
21:10:40 <kmc> that's one example of an async exception
21:10:58 <kmc> another is StackOverflow
21:10:59 <JoeyA> Does it not count an exception thrown by a parent thread?
21:11:11 <shachaf> @quote is.coming.from
21:11:12 <lambdabot> copumpkin says: <kmc> do you have a theory where the stack overflow is coming from? <copumpkin> joel spolsky
21:14:24 <hpaste_> “Joey Adams” pasted “Throwing exception to child thread within a mask doesn't block” at http://hpaste.org/52227
21:14:31 <JoeyA> There's a simpler example.
21:16:07 <monochrom> "Asynchronous exceptions may still be received while in the masked state if the masked thread blocks in certain ways; see Control.Exception."
21:16:09 <tac> @check \n -> n < 0 || n * n * n == let odds = 1 : map (+2) odds in sum $ take n $ drop (n*(n-1)`div`2) odds
21:16:10 <lambdabot>   "OK, passed 500 tests."
21:16:16 <tac> There we go
21:16:22 <monochrom> and then there begins very ugly details
21:16:49 <JoeyA> Where are those details?
21:17:02 <monochrom> threadDelay is likely interruptible
21:17:14 <monochrom> the "Control.Exception" is a hyperlink
21:17:57 <bfig> holy hell the ghc manpage is absurd
21:18:06 <bfig> how do i compile? :P
21:18:21 <monochrom> ghc my.hs
21:18:45 <shachaf> "ghc [option|filename]..."
21:19:03 <Clint> ghc --make monochroms.hs
21:19:24 <monochrom> --make can be omitted since version 7
21:19:39 <Clint> o rly
21:20:06 <bfig> i got version 6.12
21:20:46 <monochrom> then add --make
21:20:55 <bfig> i had a problem with the module name, that was it :p
21:21:04 <JoeyA> http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/Control-Exception.html#g:14
21:21:43 <JoeyA> The hyperlink from mask is broken.  It refers to the middle of the allowInterrupt function, rather than to that section.
21:30:52 <slack1256> let say i got a infinite list of primes
21:31:00 <slack1256> and i use in two differents functiones
21:31:30 <slack1256> do the functions share the same evaluated list (considering the two won't evaluate at the same lenght)
21:31:48 <slack1256> or sharing doesn't work that way in haskell?
21:32:36 <dolio> Depends.
21:32:52 <dolio> Are they both referencing the same named list?
21:33:57 <rwbarton> Most likely the answer is yes
21:34:12 <slack1256> yes, is a list from a cabal-package
21:35:03 <rwbarton> A case where the answer could be no is if each function was actually using a function call that produced the list of primes, then you couldn't know without inspecting the function
21:36:14 <slack1256> a of course, because under that case the primes would be under each function instead of on top of them right?
21:36:26 <shachaf> Cale: lambdabot is down, by the way.
21:36:32 <rwbarton> (Another case is if the infinite list of primes is given by a definition that violates the monomorphism restriction, and then you turn off the monomorphism restriction to get your code to compile)
21:37:14 <antihoax> heyh
21:37:40 <slack1256> no but in this case that doesn't apply because the primes are defined by [Int] not by "Integral a=> [a]"
21:38:05 <MjrTom> thx MatrixFrog, luite, and ivanm; my EclipseFP seems to be happy enough now - appreciate the insight
21:38:33 <slack1256> but now let say that mi original 2 functions using the same infinite list of primes where called in parallel
21:38:36 <rwbarton> Right, then they will be shared.  (Though the Haskell report doesn't actually require this, you can rely on GHC to behave that way)
21:39:10 <slack1256> do the list will be shared?
21:39:33 <rwbarton> yes
21:39:57 <rwbarton> Let's represent the list of primes initially by <thunk>
21:40:02 <slack1256> cool!
21:40:13 <rwbarton> one of the two threads will "enter" the thunk, do some computation, and rewrite the value to 2 : <thunk>
21:40:33 <slack1256> yes
21:40:33 <rwbarton> if the other thread doesn't try to read the value until that finishes, it won't have to recompute that 2
21:40:55 <rwbarton> if it does happen to demand the value while the first thread is computing, then I believe it will duplicate the computation for that thunk
21:41:50 <kmc> with GHC there is only a very small window where this can happen
21:41:51 <hpaste_> monochrom annotated “Throwing exception to child thread within a mask doesn't block” with “Throwing exception to child thread within a mask doesn't block (annotation)” at http://hpaste.org/52227#a52229
21:42:06 <kmc> otherwise entering a thunk which is in progress suspends the current Haskell thread until that thunk is evaluated
21:42:10 <rwbarton> ah, good
21:42:13 <kmc> by enqueueing it on a per-thunk waitqueue
21:42:17 <monochrom> JoeyA: give my paste a try
21:42:20 <rwbarton> Also, I skipped a lot of steps between <thunk> and 2 : <thunk>
21:42:24 <slack1256> mmm, interesting
21:42:54 <slack1256> thanks rwbarton & kmc. this save me some doubts
21:43:14 <slack1256> *saved
21:43:42 <monochrom> slack1256: my http://www.vex.net/~trebla/haskell/lazy.xhtml has a case study of this sharing at the end, "case study: average"
21:55:48 <shachaf> #haskell, your opinion of this statement: "monads are rules for chaining functions together"
21:55:58 <djahandarie> No?
21:56:08 <shachaf> That's what I said.
21:56:36 <kmc> "yes if you squint just right"
21:57:02 <kmc> like all the other statements  beginning with "monads are"
21:57:35 <kmc> i was going to talk about unsafeDupablePerformIO but i guess slack1256 left :/
21:57:53 <shachaf> "Monads are types m that have operations r :: a -> m a and b :: (a -> m b) -> m a -> m b that satisfy the laws ..."
22:00:01 <monochrom> I certainly use monads to chain something together. not sure if the something is functions. not sure if it is rules.
22:00:53 <monochrom> all in all I blame the common education of "express in your own words to show that you understand nothing"
22:01:24 <bfig> i have a parsec parser p::String->ParseError Expr, how do i use it in IO? ie, readFile fname >>= p ? i've tried lifting but it doesn't work
22:02:09 <bfig> following the type signatures i guess i have to convert ParseError Expr in IO (ParseError Expr) or something like that
22:03:19 <bfig> (nevermind return did it i'm such an idiot)
22:03:36 <rwbarton> you can also write  fmap p (readFile fname)  or a variety of equivalent things
22:03:59 <kmc> x >>= (return . f)   ≡  fmap f x
22:04:14 <bfig> :o unicode
22:04:20 <kmc> it's all unicode
22:04:36 <bfig> wow 3:07 am
22:04:56 <Rotaerk> just because you can follow a mathematical proof doesn't mean you understand the proof
22:04:59 <bfig> this last two days have been huge for my haskell skillz :)
22:05:08 <tkahn6> bfig you from europe?
22:05:25 <rwbarton> that'd be a weird part of europe
22:05:26 <Rotaerk> and just because you can determine whether something is a monad by evaluating it in terms of the formal definition doesn't mean you understand the concept of a monad
22:05:26 <bfig> actually from the socialist hell that is UrUgUaY
22:05:35 <tkahn6> ah that makes more sense
22:06:48 <bfig> Rotaerk, following a proof means understanding the proof. define understand in a meaningful sense?
22:07:41 <rwbarton> South America is not exactly south of North America. :)
22:07:55 <Rotaerk> bfig, well, you don't truly understand it until it feels/seems right... makes sense
22:08:11 <bfig> it feels right when you can follow it, doesn't it?
22:08:17 <Rotaerk> not necessarily
22:08:27 <monochrom> following a proof or determining whether something is a monad is closer to understanding than writing essays mincing words talking big talks
22:08:52 <KirinDave> monochrom: Should I regret trying to explain this to rubyists in their own language then?
22:09:22 <Rotaerk> if you actually understand it, then you can describe monads abstractly in a way that's not the same as repeating the formal definition
22:09:40 <Rotaerk> if you describe monads in a way that's not true, then you don't truly understand them
22:09:51 <monochrom> if you actually don't understand it, then you can still describe monads abstractly in a way that's not the same as repeating the formal definition
22:10:06 <Rotaerk> not correctly
22:10:29 <kmc> you can still do it correctly by accident
22:10:42 <Rotaerk> sure, like monkeys typing up shakespeare
22:10:42 <monochrom> that depends on who judges what is correctly. surely, the describer is sure that he/she is correct
22:10:47 <bfig> Rotaerk, why the hell do you care?
22:10:55 <Rotaerk> about?
22:11:33 <bfig> maybe einstein was just perceived as genius, maybe he just was crazy enough
22:11:42 <bfig> like a lucky monkey
22:12:07 <bfig> maybe you don't understand them and just by chance have stumbled through successful definitions one and over again... (ie you have no case)
22:12:19 <Rotaerk> I think you took what I said as a formal definition of understanding...
22:12:23 <monochrom> I don't use the lucky monkey argument. I'm fine with assuming it is not just luck.
22:12:35 <Rotaerk> that "X says things that are true about Y means they understand Y"
22:13:32 <Rotaerk> it's more that... if you understand it, then even if the proof is shown to somehow have a mistake, you still feel that it must be true, and that there is another correct proof out there
22:14:01 <monochrom> that is too subjective to my taste
22:14:09 <Rotaerk> understanding is very subjective
22:14:46 <Axman6> @hoogle hSetBuffering
22:14:46 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
22:15:09 <Rotaerk> proofs are just objective ways of communicating knowledge, but the individual doesn't understand it simply because they can read the proof
22:15:12 <monochrom> actually, if you don't understand it, then you still feel that it must be true. I just saw one delusion person acting like that in efnet #math
22:16:00 <monochrom> but of course you can resort to "surely he feels that he understands it, and who is to deny his right to feel"
22:16:26 <Rotaerk> it's about taking your incorrect intuitions, breaking them down, and causing the correct notion to become what's intuitive
22:16:35 <Rotaerk> the proof is the... path to doing that
22:17:34 <monochrom> last year, he felt that he had a proof for P=NP. his proof involved every mathy subject under the sun.
22:18:37 <Rotaerk> hmm I think that's what it comes down to... a proof is a formal expression of one's intuition
22:19:09 <Rotaerk> if a proof is wrong, the original intuition was likely wrong... to point out a flaw in the proof is to point out a flaw in the thought itself
22:19:25 <Rotaerk> but just because you can read the proof doesn't mean you've absorbed it into an intuitive form
22:19:50 <monochrom> just today, he said he had a new work on "the nature of the universe and our existence in it" "I have applied einsteints theory of relativity to economics" "it uses advanced discussions in game theory"
22:19:56 <Rotaerk> the form in which it's most powerful... where you can actually reason about it and ponder implications
22:20:01 <monochrom> he surely understands a lot
22:20:35 <monochrom> he is also of the belief "equations are the language and tools of math, not the theory"
22:21:28 <kmc> /r/haskell is going downhill
22:22:41 <kmc> /r/haskell links to a Slashdot article linking to an article not about Haskell which barely mentions Haskell but can be construed to say something positive about it
22:23:03 <kmc> big wankfest on reddit about how great Haskell is and how it's not appreciated by the masses because they're just too dumb
22:23:19 <kmc> big wankfest on Slashdot about how useless Haskell is and how all its advocates are elitist assholes or deluded fanboys
22:23:24 <kmc> nothing is learned by anyone
22:23:37 <shachaf> That's most of Reddit for you.
22:23:41 <kmc> i know :(
22:23:44 <Rotaerk> kmc, like what, stop wanking to haskell?
22:24:36 <KirinDave> kmc: Maybe it's time to move on. Haskell is to mainstream for you. :)
22:24:45 <kmc> i know, i've been learning agda recently ;)
22:25:14 <kmc> but seriously, I don't know of a better place than /r/haskell to get a stream of interesting articles about Haskell at a digestible rate
22:25:59 <monochrom> planet haskell may be better
22:26:04 <kmc> no, it's much worse
22:26:21 <kmc> it's *every* article from each of those hundreds of blogs
22:26:39 <monochrom> perhaps. but if r/haskell continues to worsen, you may see a crossover point :)
22:26:40 <kmc> so you get a bunch of vacation photos of someone's kids
22:26:41 <parcs> > succ 0.1
22:26:42 <lambdabot>   1.1
22:26:42 <kmc> yeah
22:26:55 <parcs> > succ 0.01
22:26:56 <lambdabot>   1.01
22:26:59 <shachaf> kmc: It's not just someone's, it's a Haskeller's!
22:27:10 <shachaf> kmc: As we know, Haskellers have superior kids to the normal population.
22:27:15 <kmc> srsly
22:27:26 <kmc> i mean for that matter i want to read interesting contentful articles about programming which don't involve haskell
22:27:29 <parcs> is succ x :: Double always x + 1
22:27:42 <KirinDave> kmc; Is anyone doing interesting things with agda?
22:27:42 <shachaf> thingsthatinterestkmc.com
22:27:49 <KirinDave> Is it time for planetagda
22:28:04 <shachaf> propagagda
22:28:28 <kmc> parcs, "suc x = x + 1" in GHC.Float
22:28:32 <kmc> don't know if it's guaranteed
22:28:55 <kmc> KirinDave, it depends on what you find interesting ;)
22:29:02 <KirinDave> kmc: I mean, haskell is on the bleeding edge of what you could use to write production software for the industry.
22:29:12 <kmc> don't remind me
22:29:24 <shachaf> *A* bleeding edge, maybe.
22:29:26 <parcs> @check \x -
22:29:26 <lambdabot>   Parse error at "-" (column 4)
22:29:41 <parcs> @check \x -> x + 1 == succ (x :: Double)
22:29:42 <lambdabot>   "OK, passed 500 tests."
22:29:45 <KirinDave> shachaf: Man, I want to see where else you can go?
22:30:07 <KirinDave> shachaf: Not scala, surely. :\
22:30:38 <kmc> i don't think Haskell is the bleeding edge
22:30:45 <kmc> there are dozens of examples of it being used successfully in The Industry
22:30:56 <kmc> surely the bleeding edge should have not-quite-yet-one example
22:30:57 <parcs> dozens?
22:30:57 <KirinDave> kmc: That is what the bleeding edge is. :0
22:31:22 <kmc> http://www.haskell.org/haskellwiki/Haskell_in_industry
22:31:34 <kmc> about half a dozen banks alone
22:31:42 <KirinDave> Sure
22:32:26 <kmc> i know of one project at a real company which used Ur/Web
22:32:37 <kmc> maybe that's the bleeding edge ;P
22:33:04 <KirinDave> Do people take Ur/Web seriously?
22:33:14 <KirinDave> Most security professionals I know don't.
22:33:37 <KirinDave> All those correctness promises haven't born out yet.
22:33:45 <kmc> i'm impressed that they've heard of it
22:34:08 <KirinDave> The ones I know have argued with the author about how backwards his ideais
22:43:06 <kmc> KirinDave, I'm curious why you jumped from Agda to "the bleeding edge... for the industry"
22:43:16 <kmc> i'm not learning Agda because i plan to apply it in The Enterprise
22:43:38 <KirinDave> kmc: That's just my prejudices showing. To me, all the most interesting stuff is in big distributed systems.
22:43:50 <kmc> i'm learning Agda because i'm afraid of Haskell being my Blub, and I want another challenge comparable to learning Haskell
22:43:53 <KirinDave> kmc: And the only place you can really work that angle is The Enterprise™.
22:44:34 <KirinDave> kmc: More prejudices: blub is a state of mind rather than a specific language.
22:44:52 <kmc> it's the state of mind where you don't want to learn new things?
22:44:53 <Rotaerk> I don't remember Picard ever mentioning haskell
22:45:06 <KirinDave> kmc: Or that there is nothing else worth learning.
22:45:10 <Rotaerk> I usually call that a "rut"
22:45:11 <kmc> *nod*
22:45:17 <KirinDave> That's blub
22:45:31 <kmc> i've tried and failed to put significant effort into learning Clojure or Scala
22:45:37 <kmc> because of this attitude
22:45:56 <shachaf> KirinDave: I think saying "X is at the bleeding edge" where X happens to be one of your favorite languages is a pretty good indicator that you're in some way limited to X in your thinking.
22:45:59 <kmc> I spent like three days on Clojure, got a beginner's feel for it, and came away with the attitude of "I could learn this for real if I had a project where I knew it was better than Haskell... and I don't"
22:46:23 <KirinDave> shachaf: It isn't necessarily wrong.
22:46:32 <shachaf> Of course, it could be that you're actually correct, but given how many communities like to think that sort of thing, I'd be suspicious of the claim.
22:46:36 <tkahn6> setting up a dev environment for clojure is a bitch if you don't wanna use emacs
22:46:41 <tkahn6> at least in my experience
22:46:49 <kmc> yeah it was a bit annoying
22:47:02 <KirinDave> There is always IDEA. :)
22:47:04 <kmc> every pain point i experienced in Clojure had to do with the Java toolchain underlying it
22:47:13 <Rotaerk> kmc, imo, you shouldn't learn the details of the language just for the sake of learning them; if scala/closure offer something new conceputally to you, learn that
22:47:15 <KirinDave> Yeah well at least you don't gotta use sbt or maven directly.
22:47:25 <kmc> Rotaerk, yeah
22:47:28 <kmc> and Agda does
22:47:41 <Rotaerk> but if you have no need to USE the language, don't bother learning the syntactical details and idiomatic usage patterns
22:47:44 <kmc> installing maven literally took down my entire system
22:47:45 <shachaf> The article where "Blub" was introduced, for example, is kind of hilarious in that it says something along the lines of "everyone thinks their language is the best, but LISP actually *is* the best, as you can see because of X".
22:47:59 <KirinDave> kmc: Are you employed?
22:47:59 <kmc> yep
22:48:02 <kmc> KirinDave, no
22:48:18 <Kaidelong> one amusing thing I remember had to do with the reasons why Qi proves LISP is better than Haskell
22:48:27 <Kaidelong> and one of them was that Qi has a turing complete typesystem
22:48:31 <Kaidelong> I couldn't stop laughing
22:48:46 <bfig> i'm building a cabal package, how do i need to write build-depends?
22:49:01 <kmc> KirinDave, why do you ask?
22:49:03 <bfig>   Build-Depends:     base >= 3 && < 5,Text.ParserCombinators.Parsec,Text.Parsec <- this is what i have now and it's failing
22:49:13 <KirinDave> kmc: Just curious what motivates you.
22:49:25 <companion_cube> Kaidelong: excellent
22:49:27 <cheater> bfig: i suggest look at other pkgs
22:49:31 <KirinDave> kmc: I mean, for me the most powerful system I've worked with for distributed systems was Erlang.
22:49:39 <cheater> bfig: oh, what you got there are modules not pkgs
22:49:42 <kmc> *nod*
22:49:44 <KirinDave> kmc: Erlang wasn't particularly… I dunno… nobel?
22:49:45 <cheater> bfig: you need to specify packages.
22:49:45 <bfig> cheater, where can i find the .cabal files?
22:49:55 <kmc> I don't have a particular desire to play with big distributed systems
22:49:57 <bfig> what do i need to write then?
22:49:58 <KirinDave> yeah
22:50:00 <bfig> Parsec only ?
22:50:04 <KirinDave> So what are you doing with agda?
22:50:10 <cheater> bfig: search your ~/.cabal for .tar.gz files to find the packages, untar to get cabal files (i think)
22:50:24 <cheater> bfig: you write the package which has got the module in it
22:50:25 <kmc> KirinDave, some of the exercises from http://as305.dyndns.org/aps/problem and others in that vein
22:50:41 <dolio> Qi has some interesting type stuff if I'm not mistaken.
22:50:42 <cheater> bfig: it's kind of stupid i know
22:50:51 <dolio> Being Turing complete isn't it.
22:50:52 <kmc> right now I'm bugging copumpkin about getting a copy of his proof that primality is decidable
22:50:59 <bfig> which one is the package with parsec?
22:51:20 <kmc> parsec comes in the package 'parsec'
22:51:29 <cheater> bfig: google for "hackage modulename"
22:51:36 <cheater> or i think you can use hoogle or hayoo
22:51:54 <shachaf> Require Import Definitions. \n Let Excluded_Middle P:P\/~P. \n intro;apply callcc;auto. \n Qed.
22:52:00 <shachaf> Is it just me, or is that proof a bit lacking?
22:52:07 <kmc> that's Coq for you
22:52:12 <kmc> coq proof scripts are not readable
22:52:15 <bfig> so it's Parsec-3.1.1 ?
22:52:26 <kmc> you have to step through them in an interactive proof system to have any idea what's going on
22:52:33 <kmc> that's one of the big differences between Coq and Agda
22:52:38 <cheater> kmc: there's a problem there called PHP, lol
22:52:42 <kmc> yep
22:52:45 <KirinDave> kmc: Unfortunately for me, I never had a very strong math background. Most of these are pretty dense to me.
22:52:46 <kmc> it's the PigeonHole Principle
22:52:58 <cheater> If n PHP programmers are put into m rooms with n > m, then at least one room must contain more than one PHP programmer.
22:53:04 <cheater> why does it
22:53:06 <bfig>   Build-Depends:     base >= 3 && < 5,Parsec-3.1.1 <- this fails
22:53:09 <cheater> what if i put all of them in room 0
22:53:21 <shachaf> KirinDave: The proofs?
22:53:24 <kmc> KirinDave, ah, my first introduction to dependently typed programming was http://www.cis.upenn.edu/~bcpierce/sf/
22:53:31 <cheater> oh right they assumed they'll be put so that there are no outliers.
22:53:39 <kmc> which is maybe more accessible
22:53:41 <kmc> i don't know really
22:53:51 <KirinDave> Fav'd for later.
22:54:03 <kmc> the actual problems on that 'aps' site are in Coq
22:54:14 <kmc> and you probably need to know some maths and/or Coq to translate them to Agda or another language
22:54:20 <bfig> cheater, what am i doing wrong there?
22:54:28 <cheater> bfig: just use "parsec"
22:54:38 <cheater> bfig: the name is parsec, not Parsec
22:54:50 <cheater> and the version number goes on the right of the inequality
22:55:07 <bfig> yeah! it worked :)
22:55:16 <cheater> also you should say the cabal should use parsec higher than 3.1 and less than 4
22:55:18 <cheater> or something like that
22:55:19 <bfig> pfft now it needs control.monad.reader
22:55:31 <cheater> never use the next major version, never use old versions that don't work
22:55:40 <cheater> no it needs Control.Monad.Reader
22:55:46 <cheater> capitalization is important
22:55:53 <bfig> i know, it's 4 am
22:55:54 <cheater> this isn't COBOL
22:55:58 <cheater> :)
22:56:21 <bfig> which package is it?
22:56:29 <bfig> Control.Monad.Reader ?
22:56:39 <kmc> mtl
22:56:39 <Kaidelong> I think that is in base, bfig
22:56:49 <kmc> @hoogle Control.Monad.Reader
22:56:49 <lambdabot> module Control.Monad.Reader
22:56:49 <lambdabot> Control.Monad.Reader newtype Reader r a
22:56:49 <lambdabot> Control.Monad.Reader Reader :: (r -> a) -> Reader r a
22:56:53 <kmc> hmm
22:57:06 <kmc> well the hoogle website will tell you anyway
22:57:08 <cheater> @hoogle Control.Monad
22:57:08 <lambdabot> module Control.Monad
22:57:08 <lambdabot> Control.Monad class Monad m
22:57:09 <lambdabot> Control.Monad.Instances class Monad m
22:57:11 <Kaidelong> well if it is mtl it'll still come with the haskell platform
22:57:18 <cheater> yeah that @hoogle is a bit limited.
22:57:40 <cheater> Kaidelong: why depend on the platform being installed? better not to
22:58:01 <rwbarton> you need to list the packages you use in the Build-Depends line in any case
22:58:38 <bfig> yeah it compiled now, it was mtl and also transformers
22:59:32 <rwbarton> what's the current state of mtl/transformers? I missed the past year or so of developments
23:01:00 <shachaf> rwbarton: As far as I understand, mtl-2 is now based on transformers.
23:01:08 <shachaf> Which uses monads-fd.
23:01:50 <shachaf> Wait, no.
23:01:55 <dolio> I don't think mtl references monads-fd.
23:01:57 <kmc> transformers does not use monasd-{tf,fd}
23:02:02 <dolio> The latter was retired.
23:02:11 <shachaf> Right, no monads-fd left.
23:02:12 <kmc> mtl-2 does not depend on monads-fd but provides a similar interface
23:02:26 <rwbarton> okay so mtl-2 and transformers are essentially now the same
23:02:31 <kmc> i guess mtl-2 is the de facto successor to monads-fd, but with some attempt to be mtl-1 compatible too
23:02:44 <kmc> rwbarton, well, transformers is a subset, and a H98-compatible subset at that
23:03:01 <rwbarton> OK, 'compatible' might be a better choice of word
23:03:04 <shachaf> Is monads-tf just dead?
23:03:06 <dolio> mtl now depends on transformers.
23:03:21 <parcs> shachaf: no
23:03:25 <parcs> why would you think that
23:05:10 <kmc> i think it's still usable
23:05:23 <rwbarton> there's also mtl-tf apparently
23:05:28 <parcs> some people prefer monads-tf because the implementation is nicer
23:05:31 <rwbarton> or maybe this is bitrotted
23:05:47 <kmc> monads-tf is self-proclaimed successor to mtl-tf
23:06:15 * shachaf is the self-proclaimed successor to monads-tf.
23:07:17 <rwbarton> okay, and monads-tf also uses transformers so the types themselves are compatible but the classes are not (obviously).
23:07:24 <rwbarton> Yes?
23:07:49 <shachaf> rwbarton: Yes.
23:08:07 <rwbarton> Okay, that's all pretty sane then I guess.
23:09:35 <monochrom> "cabal install shachaf"
23:10:05 <shachaf> monochrom: I'm so not Haskell 98 that I'm not even compatible with cabal.
23:10:26 <monochrom> but you're a successor of monads-tf
23:10:51 <shachaf> Right. monads-tf won't work with Hugs; I won't even work with Cabal.
23:11:28 <monochrom> <newbie mode> but I just want to install the bleeding edge package </newbie mode>
23:47:16 <rahul> hi guys. i am trying to define two combinators here but for some reason this gives a compiler error: http://ideone.com/LbIdG
23:48:11 <rahul> can someone please explain why?
23:49:43 <tkahn6> what is .: and :. supposed to do?
23:50:34 <KirinDave> rahul: It's complaining about :.
23:51:06 <tkahn6> it appears that might be a reserved thing
23:51:27 <rahul> tkahn6: I want to get rid of parentheses when using sections of (.)
23:51:31 <engla> it's probably understood as : (cons)
23:51:43 <rahul> KirinDave: Yes, but why? Is it some sort of reserved word?
23:51:48 <KirinDave> rahul: http://www.haskell.org/onlinereport/lexemes.html
23:51:57 <KirinDave> "An operator symbol starting with a colon is a constructor. "
23:52:09 <engla> : is a list constructor
23:52:10 <KirinDave> "An operator symbol starting with any other character is an ordinary identifier. "
23:52:27 <rahul> KirinDave: :(
23:52:36 <rahul> KirinDave: Can you suggest better names for these two?
