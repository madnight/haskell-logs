00:02:28 <tenei> I am still lost on how to define this <botje> ... so far i have thereExists = x : filter [n]
00:02:37 <tenei> im sure its not correct
00:05:06 <BlankVerse> all the examples that i see for parsing JSON use their own data type to store json , is ther any generic datatype for storing json in haskell
00:07:52 <tenei> need help writing a definition... can anyone help?
00:10:14 <strager> What's the difference between *> and >> ?
00:10:59 <tenei> someone please help
00:11:43 <AtnNn> BlankVerse: Value
00:11:56 <AtnNn> strager: >> is for monads, *> is for arrows
00:12:04 <strager> arrows?
00:12:06 <AtnNn> sorry, applicative
00:12:09 <tenei> axman6 available??
00:12:15 <Jafet> nejucomo: Int is a strict type; its WHNF is also its NF.
00:12:29 <BlankVerse> AtnNn: Value or JSValue?
00:12:49 <strager> I was curious because I wanted to use something like the reverse of >> (return first value, throw away second) and found <* (and *>)
00:13:18 <AtnNn> BlankVerse: it depends on the library you are using
00:13:38 <BlankVerse> AtnNn: which library has Value?
00:14:00 <AtnNn> BlankVerse: Data.Aeson
00:14:14 <BlankVerse> AtnNn: and is there something like Xpath ... i want to extract all the url fields out of the js object?
00:14:20 <Jafet> BlankVerse: why on earth do you want a "generic datatype"? Use a datatype specific enough to solve the problem.
00:14:38 <Jafet> Your question suggests a thinking error.
00:15:25 <BlankVerse> Jafet: do i need to create a datatype for every kind of json string that i encounter , when all i want is to get the data out of the json
00:16:20 <Jafet> And what type is this data?
00:18:42 <tenei> I am defining a function where I have two arguments and I need to check if something is in the list.
00:19:02 <tenei> can anyone help with this question
00:19:40 <sipa> what arguments, which list?
00:20:31 <exeter> hello, I'm looking a bit into Parsec (wow, that's quite a nice library!), but I have a problem with indentation. Let's say I have a .txt like this http://pastebin.com/h7MSn0Av , what's the correct (or simpler) way to tell parsec "read until there is a lower indentation"?
00:20:32 <mauke> The paste h7MSn0Av has been copied to http://hpaste.org/52547
00:20:44 <exeter> (initial indentation may vary, of course)
00:21:54 <tenei> Arguments: should evaluate to true if there are any elements in that list and False otherwise
00:22:36 <sipa> in what list?
00:22:50 <Jafet> exeter: so have your parser take the initial indentation as a parameter
00:22:57 <tenei> example: thereExists (\x -> x == 'a') "good"
00:26:25 <sipa> :t any
00:26:26 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:26:54 <sipa> tenei: any is what you want
00:27:49 <tenei> <sipa> i know, but i need to create the Haskell function thereExists... i dont think i can just use any
00:29:20 <tenei> can I say: thereExists(1==) [0,1,2,3,4,5] ????
00:30:14 <exeter> Jafet: thanks, but errr, how to calculate the initial indentatio in the first place? a lookahead?
00:31:03 <shachaf> tenei: I think it only works if you use five or more question marks.
00:31:32 <tenei> -_-
00:31:48 <tenei> <shachaf> ???????????
00:33:43 <shachaf> tenei: Are you the same person as kolieezy?
00:35:46 <Jafet> exeter: that's one way, sure
00:36:00 <Jafet> Hmm
00:36:02 <Jafet> @hackage indents
00:36:02 <lambdabot> http://hackage.haskell.org/package/indents
00:36:05 <Blkt> good morning everyone
00:36:08 <Jafet> That's another way
00:36:09 <frerich> tenei: If you merely want to check whether '1' is an element of some list, you can use the 'elem' function, like this: 1 `elem` [0,1,2,3,4,5]
00:36:28 <frerich> tenei: If you want to hae some random predicate, you can use 'any', like this: any (1 ==) [0,1,2,3,4,5]
00:36:43 <exeter> Jafet: thanks, it seems very powerful and elegant, so I wish to follow the "right" way of doing stuff
00:37:32 <Jafet> Is this some homework, or are there two people demanding an implementation of any in the last two hours?
00:38:29 <frerich> Jafet: Oh, I didn't realize - I didn't read my backlog that far. Just saw that question.
00:43:11 <Jafet> You can do it without lookahead, but it's uglier: parseBlock indent = try $ do (line, indent') <- parseFirstLine; guard $ indent <= indent'; block <- many (parseBlock indent'); return (cons line block)
00:43:13 * hackagebot frquotes 0.2.1 - Lexical extension for Quasi-Quotations using French-Quotes  http://hackage.haskell.org/package/frquotes-0.2.1 (NicolasPouillard)
00:43:14 <Jafet> Or something
00:44:47 <exeter> thanks thanks Jafet
00:45:31 <exeter> (it might seem silly, but I am always feeling overwhelmed when ploughing through a new package, even though it is well documented as parsec.)
00:48:42 <Jafet> Excerpt from frquotes: -- Substitutes UTF8 french quotes Â«...Â» for (frTop [$frQQ|...|])
00:48:54 <Jafet> I didn't know the french were this weird.
00:48:55 <geheimdienst> exeter: i think it's not silly at all, haddocks usually lack examples or any coherent big picture information. it is difficult to quickly assemble a puzzle without having seen the target picture
00:50:42 <exeter> geheimdienst: there's probalby a hidden "programmer's guild" where they all share examples and tutorials for complex apis and wear colourful robes :)
00:51:04 <sipa> rtfming all day
00:51:24 <geheimdienst> i thought that guild was #haskell. apparently it isn't. that explains a lot
00:51:33 * geheimdienst takes off his colorful robe
00:52:44 * exeter grabs geheimdienst's robe 
00:52:51 <exeter> there, in crowd!
00:56:35 <hpaste> blankverse pasted “json url extract” at http://hpaste.org/52548
00:57:11 <BlankVerse> v :: JSValue has a url field ... how do i get the list of urls out of v
00:58:41 <BlankVerse> is pattern matching the only way out
00:59:55 <BlankVerse> because that becomes too tedius ... and what if the JSValues are different for different urls , how do i "generically" extract the url "record" out
01:04:41 <cwl> https://github.com/snapframework/cufp2011/blob/master/src/Snap/Chat/ChatRoom.hs#L210
01:05:19 <cwl> will this drop not only self-sent message but also other unread messages
01:16:57 <Cale> cwl: It looks like it completely empties the channel, so long as it doesn't take more than 1 second, (in which case it will do nothing).
01:51:51 <erus`> anyone know a good provider for cheap webspace? (just for personal backups)
01:53:17 <mm_freak> erus`: your favorite VPS/server provider
01:53:40 <mm_freak> but a better alternative is to backup locally and place the backup somewhere else, like at work
01:53:54 <mm_freak> and encrypt it of course
01:55:10 <erus`> yeah that sounds like a better idea
01:55:19 <erus`> i will bury it somewhere in the park
01:55:31 <sipa> how much data?
01:55:43 <Jafet> Code its location on parchment in invisible ink
01:55:51 <erus`> well i have a 2tb drive, but im onlt using abour 200gb at the moment
01:56:20 <sipa> maybe have a look at tarsnap
01:56:23 <erus`> that is all data, i have a seperate drive for OS/applications
01:57:41 <erus`> i wish i had my own data centre
01:58:13 <Jafet> You can buy one for a few million bucks
01:58:33 <Jafet> It's more useful than a garage of Porsches and Bugattis
02:01:10 <erus`> i am the 1% wish a personal data centre
02:01:42 <wires> erus`, if you only want backup, try backblaze, cheaps, works, mostly write only...
02:01:53 <hpaste> “Lars Simon” pasted “parsing not implemented” at http://hpaste.org/52561
02:03:47 <mroman> Morning :)
02:04:40 <mroman> Can a function have more than 1 lazy arguments?
02:04:43 <Jafet> Backblaze monitors your filesystem with their proprietary daemon. Sounds trustworthy
02:04:46 <mroman> let myOr True _ = True; myOr _ True = True; myOr a b =  a || b
02:04:52 <Jafet> mroman: what's a lazy argument?
02:05:08 <mroman> Or is strict in it's second argument
02:05:14 <mroman> while myOr is strict in it's first argument.
02:05:16 <wires> Jafet, *shrug*
02:05:19 <mroman> (Or = ||)
02:05:24 <mroman> Jafet: I mean:
02:05:34 <mroman> (null $ reverse [1..]) || True
02:05:47 <mroman> ^- that does not terminate
02:05:47 <Jafet> mroman: or is strict in both arguments when the first one is False.
02:05:56 <mroman> but
02:06:20 <Jafet> However, to answer your intended question, read about amb and lub.
02:06:23 <Jafet> @hackage lub
02:06:23 <lambdabot> http://hackage.haskell.org/package/lub
02:06:41 <wires> Jafet, run rdiff-backup plus whatever crypto you want or whatever toots your horn, into a directory that backblaze picks up. the have unlimited storage for fixed price.. who cares
02:06:47 <mroman> Jafet: I need a function where both arguments are lazy.
02:07:30 <mroman> Because _ || True MUST always be True as does True || _
02:08:14 <mroman> But I actually my question is, why haskell behaves that way?
02:08:16 <Jafet> The problem with implementing that is that you cannot evaluate bottoms in pure haskell.
02:08:17 <mroman> I thought haskell was lazy.
02:08:29 <mroman> Turns out, it's not.
02:08:33 <Jafet> Laziness refers specifically to order of evaluation.
02:08:40 <Jafet> It does not mean what you think it means.
02:08:59 <Jafet> Er, laziness still defines a specific order of evaluation.
02:09:26 <mroman> Why does haskell evaluate values when matched against _?
02:09:30 <mroman> That makes no sense to me.
02:09:39 <Jafet> It does not.
02:09:54 <mroman> ah.
02:09:57 <ziman> it does not, but neither are they matched against _
02:10:11 <mroman> Yes, because either in the First one or the second one it's matched against True
02:10:17 <Jafet> Look, being a fucking jerk does not make my heart ache to explain things to you.
02:11:38 <erus`> who hurt you jafet?
02:12:19 <mroman> _ || True forces haskell to evaluate the second argument
02:12:22 <erus`> > let f _ = 123 in f undefined
02:12:23 <lambdabot>   123
02:12:31 <mroman> so it does not matter if the second pattern is True || _
02:12:31 <ziman> a function can have any number of lazy arguments, it's just || that is strict in at least one argument
02:12:35 <mroman> That's the problem, right?
02:13:59 <erus`> > True || error "Why is jafet so mad?"
02:14:00 <lambdabot>   True
02:14:51 <shachaf> erus`: Jafet is probably mad because mroman seems to be using the "be inflammatory/say wrong things on purpose in order to get answers to your questions" strategy.
02:15:07 <shachaf> It sometimes works in the short term but it tends to annoy people eventually.
02:22:39 <Jafet> hvr: wait, so you just typed Jaf^I?
02:29:47 <hvr> Jafet: something like that C:-)
02:30:12 <hvr> (hit ^I twice w/o noticing)
02:34:37 <mroman> damn WLAN :(
02:43:35 * hackagebot codec-mbox 0.1.0.0 - A library to read and write mailboxes in mbox format  http://hackage.haskell.org/package/codec-mbox-0.1.0.0 (NicolasPouillard)
02:48:12 <erus`> is there a builtin to check all element of a list are equal?
02:51:18 <Tefaj> and . zipWith (==) <*> tail
02:54:14 <frerich> erus`: Or maybe (== 1) . length . group
02:54:56 <erus`> > let alleq a = all ((head a) ==)  a in alleq [1,1,1,1]
02:54:57 <lambdabot>   True
02:56:04 <Tefaj> > let alleq a = all (head a ==) a in alleq []
02:56:05 <lambdabot>   True
02:56:10 <Tefaj> Oh nice
02:56:14 <jayesh> exit
02:59:38 <frerich> erus`: I think that's pretty nice; if you reorder it a bit to "alleq a = all (== head a) a' then it almost reads like plain english (all equal head of a)
03:00:36 <frerich> ...but I don't understand why it works on empty lists.
03:01:13 <erus`> because it never calls the function
03:01:34 <erus`> all [] = True ?
03:01:50 <Tefaj> > and []
03:01:50 <lambdabot>   True
03:02:03 <frerich> Ah!
03:03:04 <Rc43> Hi, guys.
03:03:18 <Rc43> > eval "1 + 2" []
03:03:19 <lambdabot>   Not in scope: `eval'
03:03:29 <Tefaj> A common typo.
03:03:52 <Rc43> lambdabot uses Prelude only?
03:04:33 <frerich> erus`: Hm, I was about to propose a tiny optimization (the function comparse the first element with itself for no good reason) like 'alleq (x:xs) = all (== x) xs' but now I see you'd need to add some 'alleq [] = True' in that case, too.
03:05:45 <Rc43> Guys, I can't make `eval' to work.
03:05:54 <Rc43> ghc 7.~
03:07:50 <mm_freak> frerich: i would use your variant anyway, because i believe it can be optimized more easily
03:10:33 <Tefaj> Because you need to check for equality on billions of lists
03:17:18 <hpaste> angstrom pasted “another approach to avoiding having duplication of `error "no"'” at http://hpaste.org/52562
03:22:17 <angstrom> I just can't think of a more elegant way to write this :\
03:23:53 * JuanDaugherty wonders why people cloak on IRC.
03:24:40 <rostayob> @pl \f x -> f x >> return ()
03:24:40 <lambdabot> flip flip (return ()) . ((>>) .)
03:26:26 <hpaste> frerich annotated “another approach to avoiding having duplication of `error "no"'” with “another approach to avoiding having duplication of `error "no"' (annotation)” at http://hpaste.org/52562#a52563
03:26:57 <frerich> angstrom: I just (attempted to) annotate your snippet, maybe this helps?
03:27:31 <rostayob> is there a name for foo f = f *** f?
03:27:52 <angstrom> frerich: so if the guard line 7 doesn't "trigger" the subsequent patterns are tried?
03:27:56 <angstrom> *on
03:28:15 <frerich> angstrom: Yep, it goes from top to bottom, looking for a matching pattern.
03:28:39 <angstrom> frerich: nice. didn't know you could exploit guards like that :-)
03:29:28 <JuanDaugherty> what's @pl supposed to do? The command list is uninformative.
03:29:48 <rostayob> JuanDaugherty: converts a function to point free form
03:29:55 <frerich> JuanDaugherty: I think it gives the 'point-less' version of some function
03:29:56 <JuanDaugherty> ah, thx
03:30:05 <angstrom> @pl \x -> x
03:30:05 <lambdabot> id
03:30:22 <rostayob> @pl \f g (a,b) -> (f a, g b)
03:30:22 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
03:30:35 <JuanDaugherty> the author of the document used "pointless"
03:30:48 <rostayob> as you can see it doesn't know about Arrow functions :P
03:31:30 <JuanDaugherty> which I took in its normal rather than math meaning
03:32:16 * frerich just had a personal record by answering two questions in #haskell in a row (and mostly correct, at that!). Maybe I'll slowly stop lurking after all. :-)
03:34:47 <JuanDaugherty> as in "pointless abstraction"
03:34:48 <quicksilver> JuanDaugherty: it's not a math meaning, it's a joke.
03:34:58 <quicksilver> JuanDaugherty: the real phrase is "point-free"
03:35:11 <quicksilver> "pointless" is a pun as if it so, this is really quite pointless.
03:35:21 <JuanDaugherty> yes, I know, I'm rather humourless ATM
03:35:25 <quicksilver> :)
03:35:29 <quicksilver> it's not a very good joke
03:35:47 <frerich> Ha, as a non-native speaker, this pun didn't even occur to me.
03:36:09 <frerich> hihihi
03:36:41 <quicksilver> JuanDaugherty: (people cloak on IRC so that if they annoy a skiddie, their IP doesn't get DOSed/hacked)
03:37:22 <JuanDaugherty> i c. I take it a "skiddie" is a script kiddie
03:39:01 <strager> Is there a simple way to check if a monad is actually a monad (i.e. fits the "Monad laws" described here: http://learnyouahaskell.com/a-fistful-of-monads#monad-laws )
03:39:45 <JuanDaugherty> no
03:40:26 <JuanDaugherty> conceptually simple: by inspection
03:47:26 <mm_freak> strager: not in haskell itself
03:48:10 <mm_freak> though for newtype-based monads it's easy to prove manually
03:53:45 <KitB> How can I enforce a size on a list in the type?
03:54:00 <KitB> (I don't want a tuple, I need list operations)
03:56:08 <quicksilver> KitB: there is no simple way.
03:56:30 <KitB> quicksilver: I had expect as such :/
03:57:19 <quicksilver> you can have a smart constructor which enforces it
03:57:41 <quicksilver> or you can define a list with a phantom type parameter which you fill with a type-level integer
03:57:52 <quicksilver> but for many use cases this is very inconvenient
03:58:04 <erus`> is there any way to get show to put qualified imports infront of bindings?
03:58:15 <hj> fgfg
03:58:17 <hj> erertr
03:58:19 <hj> hj
03:59:36 <KitB> quicksilver: Are there any libraries that implement this for me?
03:59:55 <KitB> I'm sure I can deal with not having it enforced by types but it would have been nice
04:00:07 <quicksilver> erus`: no. Show simply produces strings, it is compiled. It can't know what qualifications you have in scope.
04:00:16 <quicksilver> erus`: I agree that is inconvenient.
04:00:17 <quicksilver> :(
04:00:28 <quicksilver> KitB: almost certainly? :)
04:00:58 <KitB> quicksilver: Oh you :P
04:02:02 <quicksilver> KitB: You are so lazy that you cannot search the package list at hackage for the word "list" and you'd like me to do it for you.
04:02:06 <quicksilver> OK, here goes:
04:02:06 <quicksilver> http://hackage.haskell.org/packages/archive/fixed-list/0.1.5/doc/html/Data-FixedList.html
04:02:15 <KitB> Hah, no
04:02:23 <quicksilver> that's my first hit from hackage. I've never heard of it. It may be rubbish or excellent for all I know.
04:02:46 <KitB> I'm on a bit of a tight schedule so I'm not doing anything fancy unless there's a nice way of doing it that people can recommend
04:03:25 <cicatristeza> apart from conrad barski's pages, is there any other tutorial for drawing svg with haskell?
04:03:56 <mm_freak> KitB: if your constraints are not on the /length/ of the list, then it can be much easier to prove statically
04:04:26 <mm_freak> KitB: for example many applications don't need to know what the length of the list is, but only whether the list is empty or not
04:04:50 <KitB> mm_freak: I specifically need a list of length 70
04:04:58 <mm_freak> is it always that size?
04:05:01 <KitB> Always
04:05:14 <mm_freak> to you need it to be a list for some reason?
04:05:20 <mm_freak> s/^to/do/
04:06:00 <KitB> I'm not entirely sure just yet, but I don't want to be making a 70-tuple
04:06:16 <mm_freak> KitB: because for performance reasons i would use a Vector and build a safe interface around it
04:06:38 <KitB> I'm not caring about performance just yet
04:06:41 <mm_freak> that interface only allows operations, which will always take 70 element vectors and always produce 70 element vectors
04:06:53 <mm_freak> yes, but Vector also has a richer set of operations
04:07:02 <KitB> I think I shall have to leave it unsafe for the moment
04:07:31 <KitB> I have far too much work to do
04:07:46 <KitB> This is unfortunately not recreational :(
04:08:18 <mm_freak> well, i don't know your application, but it really sounds like you want an array instead of a singly linked list
04:08:25 <KitB> mm_freak: I agree
04:08:42 <KitB> It's a chromosome
04:08:45 <mm_freak> a vector is an array and the interface is the same, just that you will usually write all functions qualified
04:08:52 <mm_freak> import qualified Data.Vector as V
04:08:57 <KitB> For a genetic algorithm
04:08:59 <zenzike> has the binary package always been hidden by default, or has something changed/have I done something stupid?
04:09:00 <mm_freak> V.foldr, V.map, …
04:09:42 <quicksilver> zenzike: all packages are hidden by default in a sense. Except base. What do you mean?
04:10:29 <mm_freak> KitB: for the time being, you can at least only use operations, which will never alter the length of the list/vector
04:10:39 <KitB> mm_freak: I'll go with that
04:10:41 <KitB> Thanks
04:11:01 <mm_freak> if you have a compound operation, which uses smaller/larger vectors temporarily, write a wrapper function around that operation
04:11:04 <mm_freak> (.) is your friend =)
04:11:08 <zenzike> quicksilver: I mean that when I do ghc-pkg list, the only hidden ones are binary, ghc, haskell2010 anad haskell98
04:11:10 <quicksilver> (although hidden means more than one related thing, with packages, I think)
04:11:21 <quicksilver> zenzike: that's ghc's own internal copy of binary
04:11:22 <zenzike> quicksilver: I'm pretty sure binary didn't used to be hidden
04:11:23 <KitB> I'll be needing to modify elements in it too, any advice on that?
04:11:38 <mm_freak> KitB: can you bulk-modify them?
04:11:56 <quicksilver> zenzike: you get an external Binary with the haskell-platform but not with bare GHC installs
04:12:16 <zenzike> quicksilver: hm, seems strange that ghc needs me to add -package binary for my file to compile then ...
04:12:50 <mm_freak> KitB: with vectors it's easy to replace a single element or a list of elements by other elements…  but if you need a concrete representation of the resulting vector, then it will involve copying
04:12:55 <mm_freak> KitB: this is also true for lists
04:13:23 <KitB> mm_freak: I thought as much
04:13:45 <KitB> I'm fine with that, I don't need this to be particularly fast
04:13:47 <mm_freak> KitB: if you modify all elements, then the overhead is reasonable and you should just do it with V.map, V.generate, etc.
04:14:04 <KitB> I'll be doing it element at a time
04:14:07 <quicksilver> zenzike: I think I'm confused. GHC ships with an internal binary but you're not supposed to use it.
04:14:14 <quicksilver> zenzike: have ou installed the platform?
04:14:15 <erus`> how do i overload Show?
04:14:18 <KitB> In reality I could represent this chromosome as a bitstring
04:14:27 <quicksilver> zenzike: are you trying to use binary? or is this a surprise to you?
04:14:30 <KitB> But I'm being verbose for the moment
04:14:59 <zenzike> quicksilver: I probably have installed the platform at some point ... One of my files needs to use binary, but for some reason, I need to supply it as a package explicitly, since it's being hidden by default
04:15:07 <mm_freak> KitB: note that data structures are lazy…  instead of building an algorithm around a vector, you should build a vector around an algorithm as much as possible
04:15:13 <quicksilver> zenzike: are you using --make?
04:15:27 <mm_freak> KitB: look into the instinct library's 'activations' function to see how that works
04:15:29 <zenzike> quicksilver: whether or not I use --make I still need to supply -package binary
04:15:37 <quicksilver> zenzike: I think ghc's internal binary is supposed to be called ghc-binary, so there shouldn't be a conflict.
04:15:47 <KitB> mm_freak: I just need to get it working for the moment, it's only coursework
04:15:57 <quicksilver> zenzike: you can paste (1) the output of ghc-pkg list and (2) the error you get when you don't supply -package binary?
04:16:11 <zenzike> quicksilver: sure
04:16:11 <KitB> There would be little point in me making it releasable code either, as there's already a GA library on hackage
04:16:17 <KitB> and it's better than I think I could make it
04:16:19 <mm_freak> KitB: yes, and i'm giving you the most convenient solution as far as i know =)
04:16:24 <KitB> I see
04:16:32 <mm_freak> KitB: it's not that lists are slow, but they can get inconvenient, too
04:16:46 <mm_freak> as far as i see it, they are just not prepared for the kind of thing you want
04:17:09 <KitB> How about Vector?
04:17:38 <zenzike> quicksilver: http://hpaste.org/52566
04:17:49 <mm_freak> KitB: in general if you aren't performing some element-by-element stream operation you should think twice before using lists
04:17:53 <zenzike> quicksilver: that paste misses the fact that binary is blue ... which means hidden
04:18:23 <mm_freak> KitB: as said, Vector has the same interface with additional operations
04:19:00 <quicksilver> zenzike: I think, although I don't understand, that they've stoppd shipping a binary called 'ghc-binary' and started calling it 'binary' but nonetheless you are not supposed to use it
04:19:08 <quicksilver> and you should install binary yourself if you want to use it
04:19:19 <zenzike> quicksilver: fair enough. thanks for the hint.
04:19:31 <KitB> mm_freak: I am confuse, what would you recommend then?
04:19:49 <mm_freak> KitB: Vector
04:19:56 <KitB> Cool
04:19:58 <KitB> Thanks
04:20:04 <johan___> hi guys, I need help with an assignment. Can u help me?
04:20:10 * KitB imports Data.Vector as V
04:21:45 <johan___> Heeeeelp!
04:21:56 <quicksilver> johan___: just ask your question.
04:22:00 <johan___> Write a function insert list:: Eq a => (a, b​​) -> [(a, b​​)] -> [(a, b​​)], which takes in a key-value pairs, and a symbol table and returns a new symbol table where the new key-value pair is included. Note that if the key already exists replaces the old value of the key-value pair with the new value.
04:22:14 <quicksilver> johan___: although if the questions "Please do my homework for me" then it's not likely anyone will feel like helping.
04:22:28 <KitB> johan___: Where are you that they're setting Haskell as homework?
04:23:05 <johan___> at the uni <&:)
04:23:14 <KitB> Which one? :P
04:23:34 <quicksilver> zenzike: update - I still don't understand, but apparently just passing -package binary to use that binary is fine.
04:23:34 <johan___> GU in sweden
04:23:44 <KitB> Cool
04:23:45 <quicksilver> zenzike: I am told by people who should know :)
04:24:22 <KitB> johan___: open ghci and type ":t (:)"
04:24:40 <johan___> we have to use hugs :(
04:24:59 <KitB> I imagine hugs can do this too
04:25:03 <johan___> i tried :t but it doesn't help
04:25:10 <KitB> What does it tell you?
04:25:22 <KitB> (Does :t exist in hugs?)
04:26:05 <sp3ctum> i know it doesn't probably feel nice to hear, but the problem isn't too complex
04:26:27 <johan___> i can use :t to see what type something is
04:26:28 <KitB> johan___: Maybe try ":info (:)"
04:26:31 <KitB> aha
04:26:33 <KitB> Well then
04:26:35 <KitB> If :t is working
04:26:39 <KitB> Look closely at the types
04:26:42 <sp3ctum> johan___, http://learnyouahaskell.com/starting-out#an-intro-to-lists
04:27:01 <sp3ctum> i wish my school had haskell as a subject
04:27:09 <KitB> Mine did in first year
04:27:14 <johan___> i dont :(
04:27:22 <sp3ctum> hehe
04:27:29 <johan___> i've read that page but i won't help me
04:27:51 <johan___> i can't get the insert funtion to work
04:27:58 <KitB> johan___: You'll probably kick yourself once you find this one out.
04:28:17 <johan___> probably...
04:28:33 <KitB> :t (:)
04:28:34 <lambdabot> forall a. a -> [a] -> [a]
04:28:44 <KitB> ignore the forall part
04:28:52 <KitB> you have a -> [a] -> [a]
04:29:06 <KitB> What type does your function need to have?
04:29:18 <sp3ctum> it says it takes an element and a list and returns a new list
04:29:18 <johan___> insertList :: Eq a => (a, b) -> [(a, b)] -> [(a, b)]
04:29:33 <KitB> let's boil that down to basics
04:29:37 <KitB> you want
04:29:48 <KitB> (a,b) -> [(a,b)] -> [(a,b)]
04:29:57 <KitB> let's introduce a name for (a,b)
04:30:04 <KitB> Let's just call it c
04:30:11 <KitB> so you want c -> [c] -> [c]
04:30:27 <johan___> ok...
04:30:40 <KitB> and (:) :: a -> [a] -> [a]
04:30:59 <KitB> Because they're polymorphic types you can make a = c here
04:31:12 <KitB> (which is not to say the a from in (a, b))
04:31:23 <KitB> (You can't make that a=c because that would be recursive)
04:31:48 <KitB> In any case, you want a function of type a -> [a] -> [a]
04:31:57 <KitB> and there is a library function of that type
04:32:34 <KitB> I doubt you've been taught currying or point free style yet
04:32:48 <johan___> never heard of it
04:33:20 <KitB> What name does your function have to have?
04:33:26 <KitB> insertList
04:33:28 <KitB> ok
04:33:32 <KitB> My answer would be
04:33:38 <KitB> insertList = (:)
04:33:47 <KitB> But I wouldn't answer that if I were you
04:33:52 <KitB> in case they ask you to explain
04:33:57 <sp3ctum> heh
04:34:12 <johan___> ok :)
04:34:18 <sp3ctum> clever, KitB
04:34:21 * sp3ctum applauds
04:34:42 <KitB> johan___: and don't get dispirited, a lot of people have trouble with Haskell
04:34:53 <KitB> especially if they're accustomed to imperative programming
04:35:07 <KitB> It's like learning to program from scratch IMO
04:36:06 <sp3ctum> i agree, this would be pretty trivial for many imperative programmers
04:36:16 <KitB> >let insertList = (:)
04:36:27 * KitB doesn't know lambdabot very well
04:36:33 <KitB> > let insertList = (:)
04:36:34 <lambdabot>   not an expression: `let insertList = (:)'
04:36:42 <KitB> @let insertList = (:)
04:36:43 <lambdabot>  Defined.
04:36:48 <frerich> KitB: Maybe I missed something while reading the backlog, but johan's original task had the sentence " Note that if the key already exists replaces the old value of the key-value pair with the new value."
04:36:58 <KitB> Ooh
04:37:03 <KitB> That does complicate things
04:37:09 <sp3ctum> oops, i missed that too
04:37:19 <johan___> =/
04:37:33 <KitB> frerich: Thanks for pointing that out
04:37:40 <KitB> @unset insertList
04:37:41 <lambdabot> Unknown command, try @list
04:37:48 * KitB really doesn't know lambdabot
04:37:54 <KitB> @undef insertList
04:38:50 <KitB> johan___: Do you know list comprehensions yet?
04:38:58 <erus`> is there no string replace in the prelude?
04:39:02 <erus`> i mean platform
04:39:22 <erus`> @hoogle [a] -> [a] -> [a] -> [a]
04:39:22 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
04:39:23 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
04:39:23 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
04:40:48 <johan___> it's supposed to look like this
04:40:48 <johan___> insertList ("abc", 20) emptyList => [("abc",20)] insertList ("abc", 20) aList => [("foo",42),("bar",43),("baz",44),("abc",20)] insertList ("baz", 42) aList => [("foo",42),("bar",43),("baz",42)]
04:41:13 <johan___> hard too see =/ do you get it?
04:41:30 <KitB> I get the idea
04:41:41 <KitB> Have you seen list comprehensions?
04:41:47 <johan___> no?
04:41:54 <KitB> Hmm
04:41:59 <KitB> What *have* they taught you?
04:42:27 <johan___> nothing of value to this
04:42:28 <KitB> We did recursion -> comprehensions -> higher order functions -> data types -> functors -> ...
04:42:50 <quicksilver> I think you need to *try* to write something before people can usefully help you, johan___
04:42:56 <KitB> Actually I think they threw IO in before functors
04:43:01 <quicksilver> it's much easier to answer a specific misunderstanding or roadblock
04:43:05 <KitB> Indeed
04:43:26 <johan___> ok... wait two seconds
04:43:57 <johan___> insertList :: Eq a => (a, b) -> [(a, b)] -> [(a, b)]
04:44:01 <johan___> no, wait
04:44:19 <johan___> insertList :: Eq a => (a, b) -> [(a, b)] -> [(a, b)]
04:44:23 <johan___> insertList x [] = [x]
04:44:27 <johan___> insertList x (y:ys)
04:44:31 <johan___> | x <= y = x:y:ys
04:44:35 <johan___> | otherwise = y:insertList x ys
04:44:50 <johan___> that gives me the element first in list every time
04:45:12 <johan___> i want the value to be sorted
04:45:14 <frerich> johan___: I think one thing which would deserve clarification at some point (probably once you got *some* version going) is whether the given symbol table can contain the same symbol multiple times, and how the function should behave in such cases (should it update all occurrences of the symbol or just one of them, or what?).
04:45:20 <KitB> johan___: You should hpaste this
04:47:43 <johan___> sorry, i have to go. But thanks to you all... "I'll be back"
04:47:55 <sp3ctum> frerich, i don't think the assignment johan___ pasted defines what to do in that case
04:48:16 <KitB> I think it's assumed to be a set
04:49:11 <KitB> I seem to recall having a similar assignment in my first year, though we had a better understanding of Haskell before we were given such things
04:51:05 <quicksilver> I imagine the precondition is that each key occurs once
04:51:16 <quicksilver> and the routine is merely expected to preserve the invariant, not enforce/create it
04:51:26 <quicksilver> still, some people are very hard to help
04:51:54 <KitB> Many people have no grasp of Haskell whatsoever
04:52:02 <KitB> It takes a while
04:52:15 <quicksilver> of course
04:52:20 <quicksilver> but that wasn't my point
04:52:27 <quicksilver> my point was that he didn't know how to be helped :)
04:52:31 <quicksilver> not that he didn't know haskell.
04:52:42 <KitB> I think maybe he didn't know enough to ask for help properly
04:52:46 <quicksilver> if you are good at being helped, you ask lots of small precise questions to move your understanding on
04:52:53 <KitB> is what I'm saying
04:53:08 <KitB> It's hard to ask small, precise questions when you have no idea what's going on
04:53:13 <quicksilver> maybe. Hard to say, since he also refused to tell us what he knew
04:53:25 <sipa> in order to ask a question, you must already know most of the answer
04:53:29 <quicksilver> which is part of being good at being helped
04:53:38 <KitB> Quite possibly embarrassed
04:53:51 <quicksilver> if he'd said "the only haskell I've done so far is 3+4, I've never used a list" that would have helped
04:54:06 <quicksilver> if he'd said "I've done a couple of examples with map but never written my own function which works on lists"
04:54:09 <quicksilver> etc...
04:54:25 <KitB> I'd have been a little too shy to say such things when I was just starting in my first year
04:54:38 <robert[]> hi
04:54:42 <KitB> Hello
04:54:48 <robert[]> whatas up?
04:54:58 <KitB> Monads and shizzle
04:55:14 <robert[]> anyone know about highers order matching?
04:56:20 <erus`> meta haskell code: https://github.com/tm1rbrt/lambdurp/blob/master/prelude/parseprelude.hs
04:58:38 <hpaste> “Mukesh Tiwari” pasted “reading pcap” at http://hpaste.org/52568
04:59:04 <keep_learning> Any one here worked with Network.Pcap library ?
04:59:52 <keep_learning> I am trying to read a pcap file using this but at every run it prints different hex value
05:01:08 * frerich uses keep_learning's paste as an exercise to convert to 'do' notation :-)
05:03:06 <quicksilver> keep_learning: OH! When we discussed this the other day I didn't know you were using a "Network.Pcap" module from hackage.
05:03:11 <quicksilver> I didn't know any such thing existed.
05:03:58 <quicksilver> keep_learning: what is "loop" ?
05:04:11 <quicksilver> oh, it's from network.pcap
05:04:12 <keep_learning> quicksilver: i missed :(
05:04:12 <quicksilver> :)
05:04:30 <robert[]> what's the proof theoretic ordinal of second order arithmetic
05:04:43 <quicksilver> keep_learning: "every run it prints a different hex value"
05:04:50 <quicksilver> keep_learning: well surely that's what you'd expect?
05:04:54 <quicksilver> you're just printing a Ptr
05:05:02 <quicksilver> a Ptr just prints as the address...
05:05:07 <keep_learning> quicksilver: ohhh
05:05:27 <keep_learning> keep_learning: so how to print those values pointed by pointer
05:06:06 <keep_learning> q is pointer to  Word8 ?
05:06:29 <quicksilver> well it's just a pointer
05:06:35 <quicksilver> pointers can point to anything :)
05:06:39 <quicksilver> I would use the bytestring version myself
05:06:40 <quicksilver> loopBS
05:06:50 <quicksilver> then you get a bytestring for q, easier to work with
05:07:16 <keep_learning> quicksilver: great , thank you very much .
05:16:07 <KitB> Is there a flag I can give GHC to have it just typecheck my code?
05:17:01 <robert[]> KitB: just compile it
05:17:56 <KitB> robert[]: I was well aware that would typecheck it, is there something I can do that will make it not compile it but still typecheck it?
05:18:20 <robert[]> no
05:18:23 <thoughtpolice> KitB: i don't believe there is funny enough. you could probably write a quick tool with the GHC API that does it, but i'm surprised GHC can't do this from looking at the flags
05:18:34 <quicksilver> KitB: loading it into GHCi is faster than compiling and will typecheck it
05:18:37 <quicksilver> that's what I do in practic.
05:18:40 <KitB> I do that too
05:18:41 <robert[]> why would you ever want to
05:18:47 <quicksilver> robert[]: it's faster.
05:18:52 <robert[]> typecheck but not compile
05:18:53 <KitB> Or more specifically I just run :r whenever I want to typecheck
05:19:04 <KitB> robert[]: Because I might not have actually written anything yet
05:19:04 <frerich> KitB: I use ghci for this, too
05:19:11 <KitB> I could have a shedload of undefined functions
05:19:12 <robert[]> you can still compile it
05:19:14 <KitB> with type signatures
05:19:18 <KitB> I *can*
05:19:23 <KitB> But I want to not do that
05:19:26 <robert[]> why
05:19:37 <KitB> Because it takes a lot longer than just typechecking
05:19:41 <robert[]> oh
05:19:52 <robert[]> have you measured to the difference in speed?
05:19:56 <hpaste> “Mukesh Tiwari” pasted “Hex error ” at http://hpaste.org/52569
05:20:04 <robert[]> you might be prematurly optimizing
05:20:42 <KitB> Not if I wanted to say, make a file listener that would typecheck it whenever I changed it
05:21:21 <robert[]> there is a different optimization that solves your problem
05:21:24 <KitB> (which would be so useful, has anyone done that?)
05:21:31 <robert[]> emacs haskell mode does it
05:21:39 <KitB> I don't use emacs though
05:21:48 <robert[]> okay emacs haskell mode doesn't do it
05:21:52 <robert[]> happy?
05:21:58 <KitB> No?
05:22:07 <robert[]> changes are local so you only need to type check that one definition that changed
05:22:20 <KitB> But that can cascade across everything
05:22:22 <robert[]> what you are suggesting is re-typechecking the entire dependency graph
05:22:31 <keep_learning> I am trying to convert bytestring to Hex .  I tried to install this library http://hackage.haskell.org/package/hex but getting error http://hpaste.org/52569
05:22:33 <KitB> But that's relatively quick in practice
05:22:43 <robert[]> so you are optimizing in the wrong direction
05:22:53 <quicksilver> keep_learning: that error says that the hex package is broken
05:22:55 <thoughtpolice> KitB: ghc-mod does something like that, and automatically gives you the errs/warnings from ghc. but of course it's for emacs.
05:22:58 <robert[]> also you should learn to use emacs
05:23:09 <quicksilver> keep_learning: you could fix it by changing the cabal file but it probably isn't worth it.
05:23:22 <quicksilver> keep_learning: converting bytestring to hex is too trivial to install a module forit
05:23:43 <thoughtpolice> KitB: GHC doesn't do this yet but i'm surprised it doesn't. in practice i think ghc-mod (as well as other tools) use the GHC API to merely load the file, a la what GHCi would do.
05:24:37 <keep_learning> quicksilver: thank you
05:24:38 <thoughtpolice> so it's probably your best bet for right now to use ghci for quick tests. :/ at least the new GHCi in 7.4 will allow any kind of declaration at the prompt
05:25:24 <quicksilver> keep_learning: just use 'showHex'
05:25:56 <KitB> robert[]: I already have a text editor that I use and am very happy with, I don't have time right now to be spending learning the emacs bindings
05:25:57 <quicksilver> > concatMap (\s -> showHex s "") [80,90,100,110]
05:25:57 <lambdabot>   "505a646e"
05:26:11 <KitB> Though I *do* have to work with Matlab all the time so I'm getting some of them anyway
05:26:19 <thoughtpolice> of course, GHC mod also does what you suggest, which is that it effectively re-typechecks the entire dependency graph every time any file is modified
05:26:28 <thoughtpolice> and in practice, yeah, it's fast. ghci itself is pretty fast
05:27:22 <KitB> It is indeed, but I'd have trouble making a file listener that used ghci without making it kludgey
05:28:26 <dylukes> hey
05:28:35 <thoughtpolice> KitB: well, like I said, tools like GHC mod actually use the GHC API to basically invoke the compiler programmatically, and they just extract the err messages from the result. ghc-mod is fast and does what you suggest which is a one-shot full compilation on every file change.
05:28:41 <BlankVerse> result['data']['children'] is a JSArray
05:28:41 <dylukes> so I have a typeclass AbstractSyntax and I want to define an evaluation function.
05:28:44 <dylukes> It would be something like
05:28:56 <thoughtpolice> so you could build a listener just using the API. you don't even have to go as far as the actual *interpreter*, with the API I believe you can just run the typechecking stage
05:28:58 <BlankVerse> how do i get this list out when result is a JSValue
05:28:58 <dylukes> forall a. AbstractSyntax a => a -> b | a -> b
05:29:01 <dylukes> or b -> a, not sure
05:29:06 <dylukes> either way, I dont want to use fundeps
05:29:08 <KitB> thoughtpolice: I thought ghc-mod was an emacs mode?
05:29:13 <dylukes> How would I do this with a type family?
05:29:16 <KitB> If it can be run from a terminal
05:29:19 <KitB> then hooray
05:29:25 <thoughtpolice> KitB: i think it can be, actually
05:29:35 * KitB investigates
05:29:35 <thoughtpolice> KitB: it packages an executable that the emacs lisp mode just invokes transparently
05:30:11 <thoughtpolice> KitB: so you may be able to get it up and running for some other editor. but at the moment it doesn't do inotify like changes i think, the lisp mode re-saves the file on changes and then invokes the tool itself. this is one of the most annoying aspects of ghc-mod, tbqh
05:30:16 <sipa> dylukes: class AbstractSyntax a where { type EvaluatedType a :: *; eval :: a -> EvaluatedType a }
05:30:30 <erus`> ok guys you can test lambdurp now :) with the interpreter
05:30:31 <sipa> that's an associated type, not a type family really
05:30:47 <quicksilver> sipa: surely an associated type is a type family associated with a class?
05:30:50 <erus`> maybe i should post on slashdot or something, this is huge news
05:30:50 <dylukes> well, that's what I need heh :)
05:30:56 <dylukes> the only problem with that sipa,
05:31:08 <dylukes> is I don't want to define my eval function in the AbstractSyntax file
05:31:12 <robert[]> KitB: you don't have to time to use software that already does what you're talking abou..... but you do have time to ask people on IRC about the details of the insides of a compiler so that you can re-implement the wheel from scratch?
05:31:13 <dylukes> I want to put it elsewhere for cleanliness.
05:31:27 <dylukes> :\
05:31:30 <sipa> dylukes: the definition or the implementation?
05:31:45 <dylukes> the implementation
05:32:05 <sipa> you'll need an implementation for each instance of AbstractSyntax
05:32:08 <sipa> but it can be placed anywhere
05:32:27 <dylukes> oh, I can fill in instances partially in different places?
05:32:33 <dylukes> will they be pieced together?
05:32:39 <KitB> robert[]: I've been happily working this entire time, is there a reason you're attacking me?
05:32:53 <sipa> dylukes: no
05:33:11 <sipa> dylukes: but the instances do not have to be in the same place as the type class
05:34:00 <dylukes> well, this becomes an "Evaluatable" typeclass anyways. :\
05:34:25 <sipa> is AbstractSyntax the type or the class?
05:34:26 <dylukes> I might just do class AbstractSyntax a => Evaluatable a where ... in that file instead.
05:34:36 <sipa> ok
05:34:39 <sipa> that's possible
05:34:40 <BlankVerse> is there no decode in Data.Aeson like Text.JSON
05:35:23 <dylukes> it's a class.
05:35:28 <dylukes> I just made it to "group" all of my AST types.
05:36:08 <dylukes> Is there any way to enforce that there MUST be an Evaluatable a for every AbstractSyntax a?
05:37:18 <sipa> class Evaluatable a => AbstractSyntax a
05:38:04 <dylukes> that'll result in recursive dependencies :\
05:38:45 <dylukes> An import cycle.
05:38:56 <dylukes> Evaluation.hs has to import AbstractSyntax.hs
05:38:56 <dylukes> :P
05:39:01 <sipa> if you want both to imply eachother
05:39:07 <sipa> they are effectively the same type class
05:40:10 <rostayob> how do I fill a gtk drawing area with a color?
05:40:14 <dylukes> sipa: Yeah.
05:40:26 <dylukes> The problem is I don't want to define the evaluation stuff in AbstractSyntax.
05:40:49 <sipa> then just make evaluatable a subclass
05:41:08 <sipa> why is it a problem that someone can define an abstractsyntax that is not evaluatable?
05:41:26 <dylukes> I guess it's not really :\.
05:46:19 <erus`> @hoogle (a -> a) -> m a -> m a
05:46:20 <lambdabot> Data.IntMap updateMax :: (a -> a) -> IntMap a -> IntMap a
05:46:20 <lambdabot> Data.IntMap updateMin :: (a -> a) -> IntMap a -> IntMap a
05:46:20 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
05:46:47 <KitB>  Why am I not seeing "splitAt" exported from Data.Vector?
05:46:49 <erus`> @hoogle (a -> a) -> m [a] -> m [a]
05:46:49 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
05:46:49 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
05:46:50 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
05:48:49 <Jafet> :t (.)(.)(.) -- erus`
05:48:50 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:49:04 <KitB> But only on one machine :/
05:49:25 <Jafet> All your ghci are belong to Cale.
05:49:34 <erus`> i just used mapM (return . f)
05:50:07 <Jafet> :t mapM . (return.)
05:50:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b) -> [a] -> m [b]
05:51:22 <quicksilver> isn't mapM (return . f) the same as return . map f ?
05:51:49 <erus`> no
05:52:01 <hpaste> blankverse pasted “json url ” at http://hpaste.org/52573
05:52:18 <erus`> because f in yours is a m a -> a
05:52:25 <erus`> because f in yours is an       m a -> a
05:52:45 <BlankVerse> how do i get v['data']
05:52:59 <quicksilver> erus`: those two things have the same type
05:53:04 <quicksilver> erus`: my two, I mean ;)
05:53:20 <quicksilver> it doesn't matter what the type of f is, actually
05:53:27 <KitB> How can I find out which version of a library ghci is loading?
05:53:35 <Jafet> @ty (return .) . map
05:53:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> [a] -> m [b]
05:54:00 <Jafet> KitB: try ghc-pkg list
05:55:09 <KitB> Jafet: I did, it told me 0.9
05:55:17 <KitB> But I'm pretty sure I was getting 0.7
05:55:24 <KitB> (version of Vector)
05:55:38 <KitB> Whatever I was getting, it wasn't exporting splitAt
05:55:45 <magicman> @type liftM . map
05:55:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
05:56:04 <Jafet> I believe you can control which packages ghc(i) loads, on the command line
05:56:34 <quicksilver> doesn't ghci spit out messages
05:56:34 <erus`> @hlint sequence . mapM
05:56:34 <lambdabot> No module "sequence . mapM" loaded
05:56:41 <quicksilver> (loading vector-x.y ..... )
05:56:47 <KitB> I fixed it now
05:56:56 <KitB> Updated vector in cabal
05:57:16 <Jafet> Oh, ghci prints version numbers.
05:58:11 <KitB> Yeah, once it *actually* loads the thing
05:58:41 <Jafet> So use an arbitrary thing from vector
05:58:56 <KitB> Didn't know it would do that until just now
06:01:38 <John88> Sup guys? I have a tree and I want to write a function that is the type :: Trie a -> [a]  and returns all the values in the tree
06:02:16 <John88> the tree has keys and corresponding values
06:03:02 <Jafet> In other words, you want to write the Foldable instance?
06:03:48 <Jafet> trieValues = map snd . trieToList
06:04:13 <John88> Jafet: Well, that depends on what foldable does
06:04:16 <Botje> John88: so write your function, what's stopping you :)
06:04:53 <John88> Botje: My knowledge of haskell ;)
06:04:59 <erus`> @hoogle concatM
06:04:59 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
06:05:00 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
06:05:00 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
06:05:13 <Botje> John88: okay. what do you have so far and what's not working about it?
06:05:38 <erus`> @hoogle [m a] -> m [a]
06:05:39 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:05:39 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
06:05:39 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
06:05:39 <John88> Botje: I dont want help with the entire thing, I just want some tips on how to start :P
06:05:41 <Botje> John88: you want to descend in each path of your trie and return a list containing a word when you reach a leaf
06:05:52 <Botje> John88: what does you data defnition look like, for starters?
06:06:12 <Quantumplation> I'm really having trouble figuring out how I would write this function =/
06:06:32 <Botje> John88: http://en.literateprograms.org/Binary_Search_Tree_(Haskell)
06:06:50 <Botje> maybe the treeToList function will inspire you
06:07:30 <John88> Botje: Alright, Ill check it out. WIll probably be back here later anyways ;)
06:09:58 <Quantumplation> Anyone want to give me a bit of direction? http://hpaste.org/52574
06:11:40 <danmaftei> I have a map of 40 keys where values are probabilities stored as Doubles. foldl (+) 0 returns 1 as expected. However, I have a function which, among other things, performs this fold by keeping a running sum of the probabilities. Stepping through it, it turns out my final sum is 0.99999999998, not 1. Why would this be?
06:12:15 <mux> maybe that's just normal ieee754 imprecision?
06:12:23 <engla> danmaftei: fractions can't always be represented accurately with double.
06:12:36 <mux> at least this doesn't surprise me
06:12:49 <mux> if you need exact computations, you should use Rational
06:12:51 <danmaftei> mux, i figured as much, but foldl (+) 0 returns 1
06:13:21 <engla> danmaftei: it can depend on the order yes
06:13:31 <quicksilver> well, FP arithmetic is fragile
06:13:32 <mux> danmaftei: and have you established with 100% certainty that foldl (+) 0 and your running sum algorithm do the actualy same additions in the same order?
06:13:42 <Jafet> No associativity for you!
06:13:47 <mux> heh
06:13:57 <quicksilver> if you're on a machine with an x87 CPU (and if GHC chooses to use it) then you have 80bit precision for temporarys
06:14:08 <quicksilver> which means the answer you get depends on how often things get written to memory
06:14:15 <quicksilver> and how long they stay in regs
06:14:19 <danmaftei> mux: I have not. In fact, it wouldn't! My running sum is calculated by walking through the map in order. Map.fold likely walks through it in whatever internal reprseentation it uses.
06:14:38 <danmaftei> Sounds like I should use the Rational package.
06:15:14 <mux> it's a type synonym (== Ratio Integer IIRC)
06:15:46 <quicksilver> it's in base/Prelude
06:15:53 <quicksilver> you dont need any extra package for it.
06:16:39 <danmaftei> Moral of the story is, if you're doing NLP programming and storing tiny tiny probabilities, I should use Rationals, right?
06:17:02 <zenzike> quicksilver: ta, I saw the conversation on #ghc
06:17:03 <quicksilver> maybe. Or maybe a suitably high precision Data.Fixed
06:17:08 <quicksilver> zenzike: good :)
06:17:12 <quicksilver> zenzike: confusing, wasn't it?
06:17:44 <danmaftei> Last question, for high-precision arithmetic, are there other solutions besides Rationals and Data.Fixed?
06:18:06 <danmaftei> Uhh, I'll just google tha
06:18:06 <danmaftei> that*
06:18:07 <quicksilver> there are others. CReal is arbitrary precision irrational, but slow.
06:18:10 <danmaftei> thanks all
06:18:30 <cicatristeza> how do i draw some text using the diagrams package? where is it documented? cant find it Diagrams.Prelude
06:23:44 <erus`> @hoogle isCh
06:23:45 <lambdabot> Text.Printf class IsChar c
06:23:45 <lambdabot> Network.URI uriScheme :: URI -> String
06:24:00 <erus`> whats the function to test is char is printable?
06:24:36 <erus`> > chr $ fromIntegral 2.0
06:24:37 <lambdabot>   Ambiguous type variable `t' in the constraints:
06:24:38 <lambdabot>    `GHC.Real.Integral t'
06:24:38 <lambdabot>   ...
06:26:15 <TotoTitus> umm, i'm currently nearing the end of LYAH
06:26:27 <TotoTitus> and i took a sneak peek at Write Yourself a Scheme
06:26:40 <TotoTitus> and i've grasped monads, at an elementary level
06:26:40 <quicksilver> @hoogle isPrint
06:26:40 <lambdabot> Data.Char isPrint :: Char -> Bool
06:26:43 <TotoTitus> my question is:
06:26:45 <quicksilver> ^^ erus`
06:26:51 <TotoTitus> doesn't IORef break purity ?
06:26:55 <dylukes> Does anyone know of a tutorial for the haskell llvm bindings?
06:27:11 <TotoTitus> or rather, how does IORef not break purity ?
06:27:23 <quicksilver> TotoTitus: by being safely wrapped in the IO type.
06:27:34 <quicksilver> @hoogle readIORef
06:27:35 <lambdabot> Data.IORef readIORef :: IORef a -> IO a
06:27:47 <quicksilver> TotoTitus: ^^ if readIORef was "IORef a -> a" that would be a problem
06:28:04 <TotoTitus> i think i understand somehow
06:28:16 <TotoTitus> but, couldn't IORef be abused somehow
06:28:27 <TotoTitus> to lead to programs similar to those written in stateful languages ?
06:28:33 <TotoTitus> (state spaghetti)
06:28:41 <quicksilver> yes
06:28:52 <erus`> @hoogle Num -> Int
06:28:52 <quicksilver> you can write spaghetti in most languages
06:28:52 <lambdabot> Warning: Unknown type Num
06:28:53 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
06:28:53 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
06:29:04 <TotoTitus> there's syntactic/logic spaghetti
06:29:15 <TotoTitus> and there's state spaghetti, where well..you get the point
06:29:29 <erus`> quicksilver: how do i Double -> Int ?
06:29:35 <TotoTitus> one is bad code, the other is bad state management, sometimes they intertwine
06:29:51 <TotoTitus> am i making any sense ?
06:30:42 <quicksilver> erus`: round,ceil,floor depending which you want.
06:30:49 <erus`> ah cool
06:31:30 <TotoTitus> so in a way we have impurity...but it's wrapped purely, or something like that, does that make sense ?
06:31:58 <cicatristeza> can no one tell me how to draw text on svgs in haskell? :-(
06:32:47 <zenzike> quicksilver: turns out that if I do cabal --reinstall binary, then I don't have to supply the -package binary flag any more
06:33:11 <dcoutts_> zenzike: or ghc-pkg unhide binary
06:33:19 <zenzike> dcoutts_: ah ta :-)
06:33:38 * hackagebot mbox-tools 0.2.0.0 - A collection of tools to process mbox files  http://hackage.haskell.org/package/mbox-tools-0.2.0.0 (NicolasPouillard)
06:33:40 <dcoutts_> cicatristeza: try using cairo
06:34:03 <zenzike> I thought it was a bit wierd that binary would be  hidden even after a cabal install ... I think my packages must have been in some strange state
06:35:37 <cicatristeza> dcoutts_: cairo is for gui based things isnt it? all i want is a goddam svg, without any gui shit
06:36:18 <dcoutts_> cicatristeza: cairo is an image library, it can generate png, pdf, svg, as well as render direct to an X server
06:36:35 <dcoutts_> cicatristeza: it is used by gui libs, but it does not depend on gui libs
06:38:17 <rostayob> dcoutts_: I'm drawing a svg to a cairo surface, and I get a flickering
06:38:34 <rostayob> I guess I could use two surfaces, but that's kind of hacky
06:38:52 <rostayob> is there a way to pre-draw and display afterwards?
06:39:22 <dcoutts_> rostayob: using gtk?
06:39:29 <rostayob> dcoutts_: yep I'm using a DrawWindow
06:39:39 <dcoutts_> are you rendering only during the expose event?
06:39:44 <rostayob> and renderWithDrawable
06:39:49 <rostayob> dcoutts_: nope, also on key presses
06:39:57 <dcoutts_> rostayob: don't do that :-)
06:39:59 <dcoutts_> solved :-)
06:40:07 <rostayob> dcoutts_: oh right, so that's a problem?
06:40:24 <rostayob> so I should invalidate the surface instead of drawing?
06:40:25 <quicksilver> TotoTitus: a little bit, yes. Haskell doesn't stop you shooting yourself in the foot and it has all the same power of an imperative mutable language for doing that.
06:40:37 <dcoutts_> rostayob: gtk does all the double buffering. You should not draw outside of the expose event. Just invalidate and let it get redrawn.
06:40:46 <rostayob> dcoutts_: cool, thanks a lot.
06:40:51 <TotoTitus> thanks
06:40:56 <quicksilver> TotoTitus: however, what it *does* offer is a style of programming which makes that impossible (pure/persistent style)
06:41:11 <quicksilver> TotoTitus: ...together with a compiler/type system which *proves* you are doing it right.
06:41:11 <TotoTitus> quicksilver: thanks
06:41:30 <TotoTitus> so the only thing impure in Haskell is IO a
06:41:34 <quicksilver> you can create spaghetti gotos with the Cont monad, too :)
06:42:13 <kmc> TotoTitus, no
06:42:17 <kmc> IO actions are pure values like any other
06:42:27 <TotoTitus> though i'm really pretty much betting a significant part of my future work/career on functional programming
06:42:28 <kmc> TotoTitus, they *describe* IO which *could* be performed
06:42:40 <TotoTitus> that's my i'm learning Haskell
06:42:40 <kmc> evaluating a function which returns an (IO a) does not perform any IO
06:43:02 <kmc> IO actions are basically imperative programs that you manipulate as first-class values
06:43:03 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
06:43:21 <TotoTitus> kmc: i somehow grasp that, but i'm not really deep enough into Haskell, i'm on my way to finish LYAH
06:43:27 <sonoflilit> Hi
06:43:35 <engla> kmc: ah, just like how the c preprocessor treats c programs
06:43:38 * hackagebot mbox-tools 0.2.0.1 - A collection of tools to process mbox files  http://hackage.haskell.org/package/mbox-tools-0.2.0.1 (NicolasPouillard)
06:43:41 <sonoflilit> I'm trying to create a form field in Yesod
06:44:01 <TotoTitus> if i wanted to make money right now, i'd get a job in .NET and do C# like mad...but i'm learning Haskell instead
06:44:03 <Quantumplation> I'm having trouble importing Data.Array in leksah.  How do I get it to find the dependency?
06:44:05 <sonoflilit> I have trouble grasping some of the types among all the mess of type classes
06:44:08 <kmc> engla, that was conal's argument, yeah
06:44:29 <sonoflilit> I should mention I'm using yesod 0.8, not 0.9, which completely changed the forms API
06:45:23 <sonoflilit> in particular, toForm confuses me: http://hackage.haskell.org/packages/archive/yesod-form/0.1.0/doc/html/Yesod-Form-Core.html#t:IsForm
06:46:31 <sonoflilit> I'm trying to copy and modify code from Fields.hs, and they all use toForm, but I'm getting errors for being in the wrong monad
06:46:53 <sonoflilit> and I can't figure which monad toForm places me in from the weird type signature
06:47:34 <dylukes> anyone know how I can get more info on this?
06:47:36 <dylukes> Loading package llvm-0.10.0.1 ... can't load .so/.DLL for: lib.dylib (dlopen(lib.dylib, 9): image not found)
06:47:40 <dylukes> lib.dylib is very helpful.
06:48:38 <dylukes> >_>
06:49:13 <dylukes> TotoTitus: it takes maybe a day or two to pick up enough C# to use for work...
06:49:15 <dylukes> ih
06:49:17 <dylukes> he's gone.
06:49:33 <sonoflilit> dylukes: did you try -v to see where it's looking for the lib?
06:50:16 <dylukes> it doesn't seem to be looking for it at compile time.
06:50:22 <dylukes> This is an example in the llvm repo
06:50:31 <dylukes> so, it is doing its own linking etc...
06:52:00 <sonoflilit> so strace to see where it's looking for it at runtime?
06:52:16 <sonoflilit> btw, strace is awesome
06:52:19 <dylukes> strace?
06:52:32 <sonoflilit> are you on windows or linux?
06:52:42 <sonoflilit> or something else*
06:53:18 <doruk86> hi all. Newbie haskell question: maximum returns an Integer and I want to convert the result to an Int. How do I do this? Type-cast? If so, how?
06:53:30 <dylukes> sonoflilit: OS X
06:53:36 <dylukes> there's some equivalents (dtrace/dtruss)
06:53:56 <sonoflilit> I think dtrace does different things from strace
06:53:58 <sonoflilit> not sure though
06:54:06 <sonoflilit> and I think you have strace on OSX
06:54:34 <Ke> yup that is correct
06:54:34 <sonoflilit> maybe it needs installing
06:54:36 <yrlnry> doruk86: maximum does not return an Integer.  It returns an (Ord a) => a.
06:54:59 <dylukes> oh well
06:54:59 <Ke> though dtrace might be a superset of strace, not sure though
06:55:02 <dylukes> i g2g for a moment
06:55:20 <doruk86> of course, I meant that it returns an Integer in my case, as I pass it an [Integer]
06:55:37 <rostayob> dcoutts_: since you're here, I've got another question: is there a common pattern to write actions "do this every x ms while the y key is pressed"?
06:55:39 <Ke> or the functionality anyways
06:56:29 <sonoflilit> anyone grok yesod forms?
06:56:33 <sonoflilit> preferrable <= 0.8?
06:56:38 <dcoutts_> rostayob: no, but there's various ways you could do it
06:56:50 <yrlnry> doruk86: You cannot "cast" an Integer to an Int, because an Int is a machine integer, and fits into four or eight bytes, but an Integer is an unbounded integer.
06:56:55 <dcoutts_> rostayob: e.g. use a thread, or use a glib timer
06:57:13 <yrlnry> What would the "cast" do if the value was out of range for an Int?
06:57:28 <dcoutts_> rostayob: or just rely on the keyboard repeat, if that's appropriate
06:57:28 <rostayob> dcoutts_: ok, I didn't want to reinvent the wheel, thanks a lot
06:57:43 <yrlnry> doruk86:  Where did your [Integer] come from in the first place?
06:58:08 <rostayob> dcoutts_: mhm right... so a lot of "key pressed" events will be generated?
06:58:43 <dcoutts_> rostayob: iirc, there's three events, key down, key up, but also key pressed.
06:58:58 <doruk86> I get an [Integer] list I want to "truncate" this Integer to an Int. I know that the Integer would fit into an Int.
06:59:08 <rostayob> dcoutts_: yep, i'm going to try that ow
06:59:10 <rostayob> *now
06:59:35 <quicksilver> doruk86: map fromIntegral
07:01:54 <sonoflilit> what does "(FormResult ~ formResult)" mean?
07:02:10 <sonoflilit> or how do I pronounce it (so I could google)?
07:02:41 <kmc> sonoflilit, it's a type equality constraint
07:02:43 <kmc> GHC extension
07:02:59 <kmc> says that the type variable formResult must be instantiated to the type FormResult
07:03:40 <engla> doruk86: fromIntegral
07:05:38 <quicksilver> kmc: with a simple constraint like that I wonder why it wasn't instantiated and substituted?
07:05:50 <Quantumplation> [(ID, [innerID])] how do I find the maximum innerID over the whole list?
07:05:58 <kmc> quicksilver, me too
07:06:05 <kmc> :t maxBy (max . snd)
07:06:06 <lambdabot> Not in scope: `maxBy'
07:06:18 <kmc> :t maxWith (comparing (max . snd))
07:06:19 <sonoflilit> kmc: so if "data FormResult a = ..." then formResult must be FormResult a?
07:06:19 <lambdabot> Not in scope: `maxWith'
07:06:24 <copumpkin> maximum
07:06:26 <kmc> right
07:06:33 <kmc> :t maximumWith (comparing (maximum . snd))
07:06:33 <lambdabot> Not in scope: `maximumWith'
07:06:37 <kmc> god damn it
07:06:40 <copumpkin> By
07:06:42 <copumpkin> :P
07:06:54 <kmc> :t maximumBy (comparing (maximum . snd))
07:06:55 <lambdabot> forall a a1. (Ord a) => [(a1, [a])] -> (a1, [a])
07:06:58 <copumpkin> whee!
07:06:59 <kmc> there we go
07:07:13 <Quantumplation> ^.^
07:07:16 <kmc> well hmm
07:07:18 <copumpkin> that's actually slower than it needs to be
07:07:28 <kmc> :t maximum . concatMap snd
07:07:29 <lambdabot> forall a a1. (Ord a) => [(a1, [a])] -> a
07:07:33 <kmc> that's probably what you want
07:07:44 <copumpkin> you need to perform the world's simplest operation that has a fancy name
07:08:22 <copumpkin> kmc: that's different
07:08:33 <copumpkin> oh
07:08:38 <copumpkin> I guess it is what he wants though :)
07:08:40 * copumpkin shuts up
07:08:43 * JuanDaugherty had no idea LINQ used monads.
07:09:05 <copumpkin> embrace thy lord monad
07:09:09 <quicksilver> that's what microsoft want you to think, jamiltron
07:09:11 <quicksilver> !
07:09:13 <quicksilver> JuanDaugherty:
07:09:20 <quicksilver> typo + autocomplete = odd.
07:09:27 <kmc> the LINQ abstraction in C# is similar to the Monad abstraction in Haskell, and both are similar to the monad abstraction in category theory
07:09:34 <kmc> i'm not sure if that means "LINQ uses monads"
07:09:34 <JuanDaugherty> an article in this month's CACM wants me to think it too
07:11:23 <JuanDaugherty> whose authors is apparently a haskeller that's done work on reactive presumably arrows
07:11:46 <JuanDaugherty> s/authors is/author is/
07:16:35 <yrlnry> copumpkin: what's the name of the world's simplest operation that has a fancy name?
07:17:21 <kmc> wonder if http://www.reddit.com/r/haskell/comments/la9ey/why_learn_haskell_pdf_slides/ should be crossposted to /r/programming
07:17:22 <quicksilver> JuanDaugherty: Erik Meijer wrote (or co-wrote) the reactive thingy for .NET
07:17:33 <quicksilver> I'm not sure if he was closely involved with any of the haskell FRPs
07:17:38 <kmc> i don't wanna do it
07:17:42 <kmc> but i'd be curious to see what happens
07:17:45 <JuanDaugherty> is he somebody here?
07:17:45 <quicksilver> although he was involved in lots of haskell stuff
07:17:48 <quicksilver> no
07:19:15 <quicksilver> he was involved in haskell some years back - e.g. http://www.haskell.org/haskellwiki/HSP
07:19:19 <quicksilver> and I think some of the parsing stuff
07:20:03 <JuanDaugherty> yeah, I didn't really need to have CACM vetted but yeah thx, the main thing I looked at was to see if he or the other authors, had there been any, were MS employees
07:20:09 <JuanDaugherty> apparently not
07:20:22 <ben> This enumeratee businss is still stumping me. I don't think I've written a line of haskell that I've been content with since I found out about them several months ago. :(
07:20:27 <quicksilver> meijer is an MS employee, isn't he?
07:20:31 <quicksilver> I thought he was.
07:21:06 <erus`> > let f | (a:b) <- "hi" = a in f
07:21:07 <lambdabot>   'h'
07:21:36 <ben> What's the most elaborate discussion of the enumerator package that I can download and read at my leisure when offline?
07:21:40 <Nafai> quicksilver: Yeah, pretty sure he is.
07:21:46 <JuanDaugherty> quicksilver, yes, sorry his email is at microsoft.com
07:22:22 <JuanDaugherty> but at least it's not presented by a team of them. For that matter so is or was SPJ, no?
07:23:04 <JuanDaugherty> maybe MS Res. vs. a commercial division has a meaning
07:23:15 <erus`> > let f | ('(':')':a) <- "()" = a in f
07:23:16 <lambdabot>   ""
07:23:19 <erus`> > let f | ('(':')':a) <- "()e" = a in f
07:23:20 <lambdabot>   "e"
07:23:44 <quicksilver> ben: I think the problem is there are multiple packages?
07:24:04 <quicksilver> ben: the *idea* of enumerators is natural enough, but the *details* are fiddly and there are multiple approaches ;(
07:24:29 <ben> quicksilver: I'm trying to stick to the enumerator package so far, and I just can't wrap my head around what I think should be pretty straightforward applications of the idea
07:25:36 <ben> I've been fiddlin with it for a bit and hoped I could do some reading instead to relax
07:26:26 <frerich> kmc: I'll send that PDF of your slides to our internal dev@ mailing list, maybe it teases a few colleagues into trying Haskell :)
07:26:31 <quicksilver> ben: seen http://www.mew.org/~kazu/proj/enumerator/ ?
07:26:43 <quicksilver> frerich++ # subversive haskell
07:27:24 <ben> quicksilver: Not sure, it has beena while "_
07:27:31 <quicksilver> :)
07:27:31 <ben> I will give it another shot, cheers :)
07:27:42 <ben> I'll check back later tonight if I have any luck
07:27:43 <quicksilver> the yesod book has stuff on it too
07:28:00 <kmc> cool :)
07:31:55 <mmaruseacph2> @pf f x y z = if x then y else z
07:31:55 <lambdabot> Maybe you meant: bf pl
07:31:59 <mmaruseacph2> @pl f x y z = if x then y else z
07:31:59 <lambdabot> f = if'
07:37:18 <robert[]> mercury^ is a troll
07:37:36 <quicksilver> robert[]: hush
07:39:19 <Nathan> Hi guys, how do I convert a trie into a list?
07:39:27 <ingy> does anyone know why http://hackage.haskell.org/trac/ghc/ticket/5005 is still an issue on 7.0.3 and 7.0.4?
07:39:55 <kmc> Guest75470, what does your trie structure look like?
07:40:20 <Guest75470> kmc: Did you mean this: data Trie a = TrieNode (Maybe a) [(Char, Trie a)]                     deriving Show   ?
07:40:45 <kmc> yeah
07:40:53 <kmc> so what list do you want to get out of that?
07:41:26 <Guest75470> I just want a list so I can use take out the values from it (its a tree with key-value pairs)
07:41:49 <kmc> ok
07:41:52 <kmc> at a guess:
07:41:59 <quicksilver> ingy: presumably it got fixed in the 7.2 tree? I don't know.
07:42:14 <quicksilver> ingy: the bug says you won't get bitten by it if you compile on a recent enough kernel
07:42:32 <quicksilver> kernel version factors at compile time leaking into the executable's ABI is sucky, though.
07:42:34 <quicksilver> linux--
07:42:39 <quicksilver> or maybe
07:42:40 <quicksilver> glibc--
07:42:46 * quicksilver hides from the wrath of Drepper
07:42:53 <Dunno> Hi, are there any video tutorials for Haskell with a book.:9
07:42:59 <kmc> values (TrieNode val children) = maybeToList val ++ concatMap (values . snd) children
07:43:44 <Guest75470> kmc: Thanks, though Im kind of a noob...how would I write that in the .hs file?
07:44:01 <kmc> just like so
07:44:10 <kmc> if you like, you can put a type signature before it
07:44:17 <kmc> values :: Trie a -> [a]
07:44:21 <kmc> does it make sense how it works?
07:44:39 <Guest75470> Yeah, thats the type signature
07:44:42 <Guest75470> Ill give it a try
07:44:48 <ingy> quicksilver: it looks like it was resolved on March 12, how come it didn't get released?
07:44:56 <kmc> Guest75470, i can explain the code if you like
07:44:58 <quicksilver> ingy: well I'm assuming it got released in 7.2?
07:45:19 <Guest75470> kmc: Yeah it would  be great
07:45:31 <kmc> Guest75470, ok, do you know about pattern-matching?
07:45:34 <quicksilver> ingy: 7.0 was released November 2010, before that time.
07:45:44 <Guest75470> kmc: Kind of
07:45:50 * ingy is now trying to remember why he was told not to use 7.2 
07:46:14 <kmc> Guest75470, ok, well we match a pattern (TrieNode val children)
07:46:16 <ingy> quicksilver: i was talking about 7.0.3 though
07:46:17 <kmc> which will match any Trie
07:46:18 <quicksilver> because there is no haskell platform for 7.2 yet?
07:46:29 <quicksilver> ingy: yes, hence my suggestion "the fix was probably made in the 7.2 branch" ;)
07:46:29 <ingy> that was it
07:46:36 <kmc> Guest75470, 'val' is either Nothing or (Just x); maybeToList transforms that to [] or [x]
07:46:41 <kmc> so then we can use (++) with it
07:47:09 <Guest75470> kmc: what is maybetolist? Wont it give an error if I dont define it?
07:47:15 <Guest75470> kmc: Im using winhugs btw*
07:47:15 <kmc> import Data.Maybe
07:47:25 <kmc> :t maybeToList
07:47:26 <lambdabot> forall a. Maybe a -> [a]
07:47:28 <kmc> @hoogle maybeToList
07:47:28 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
07:47:43 <kmc> and 'children' has type [(Char, Trie a)]
07:47:53 <kmc> we want to recursively call 'values' on the second component of those pairs
07:47:58 <Guest75470> kmc: Hmm ok, but I cant seem to import that one in hugs :S
07:48:05 <kmc> put it at the top of the file?
07:48:12 <kmc> anyway it's easy to write maybeToList yourself
07:48:15 <kmc> @src maybeToList
07:48:16 <lambdabot> maybeToList  Nothing   = []
07:48:16 <lambdabot> maybeToList  (Just x)  = [x]
07:48:31 <Guest75470> Ok, so Ill write that instead of importing it?
07:48:40 <kmc> it's better to import
07:48:43 <ingy> quicksilver: where do the repos live? (I'm new to this)
07:48:43 <kmc> but if you actually can't, sure
07:48:55 <Guest75470> kmc: Winhugs is being a bitch so Ill just write it myself
07:49:35 <quicksilver> ingy: http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources?redirectedfrom=GhcDarcs
07:49:50 <Guest75470> kmc: Alright, Ive written the maybetolist by myself. What now? :)
07:49:58 <kmc> what do you mean, what now?
07:50:01 <quicksilver> ingy: in git (although, in fact, 7.0.x was released before the switch to git, the 7.0.x history *was* carried over when the repo was ported)
07:50:10 <ingy> and is there a way to bootstrap compile ghc (for mortals)?
07:50:17 <Guest75470> kmc: Do I just write that code you gave me and then it works?
07:50:24 <quicksilver> ingy: you need a working ghc
07:50:28 <quicksilver> it's not trivial for mortals ;)
07:50:44 <ingy> like 6.12?
07:51:36 <quicksilver> ingy: 6.12 should be able to compile 7.0 or 7.2, I think.
07:52:27 <bobzhang> hi, can anyone give some working examples about abstraction over typeclass?
07:52:28 <ingy> currently it seems that apt-get install haskell-platform is fail on natty
07:52:31 <Guest75470> kmc: It worked, thanks a ton :)
07:53:05 <kmc> Guest75470, and you understand why it works? :)
07:53:19 <kmc> bobzhang, it's hard to abstract over type classes
07:53:20 <Guest75470> kmc: Kind of, I'm reading it through as we speak
07:53:23 <kmc> but what do you mean bobzhang
07:53:32 <bobzhang> like typeclass as a constraint (maybe in ghc 7.4)
07:54:11 <kmc> if you search for the ConstraintKinds extension
07:54:13 <kmc> you can find some examples
07:54:26 <bobzhang> kmc: but I have only ghc 7.2
07:54:28 <Guest75470> kmc: So lets say I want the keys out of the same list, how would I do that?
07:54:44 <kmc> Guest75470, what did you try?
07:55:01 <kmc> i mean it's going to be pretty different
07:55:06 <bobzhang> kmc: are there other tricks to work around it?
07:55:14 <kmc> bobzhang, i'm not sure what you want to do
07:55:24 <kmc> Guest75470, because the keys of a trie are *paths* from the root
07:55:53 <bobzhang> kmc another question, is it possible to make record fileds a default value?
07:56:01 <kmc> i don't think so
07:56:03 <tsou> If i have f : A -> B and g : A -> C, what's the name of p : A -> B x C defined by  p = \x -> (f x, g x) ?
07:56:21 <roconnor> @type (&&&)
07:56:22 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:56:24 <kmc> @pl \x -> (f x, g x)
07:56:24 <lambdabot> liftM2 (,) f g
07:56:35 <hpc> > (f &&& g) x
07:56:36 <kmc> and yeah it's also f &&& g
07:56:36 <lambdabot>   Ambiguous type variable `c' in the constraints:
07:56:37 <lambdabot>    `GHC.Show.Show c'
07:56:37 <lambdabot>      a...
07:56:41 <hpc> > (f &&& g) x :: Expr
07:56:42 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
07:56:43 <lambdabot>         against inferred ...
07:56:47 <hpc> humbug
07:56:49 <bobzhang> like data Pr a = {pr : a -> Doc, prs : [a] -> Doc}, but I want prs to be a default value relies on pr unless I override it
07:56:56 <tsou> by name i meant.. mathematical name :P
07:56:58 <kmc> bobzhang, no, but you can define a 'default' record value and then use record update syntax on it
07:57:25 <roconnor> > (f &&& g) x :: (Expr, Expr)
07:57:26 <lambdabot>   (f x,g x)
07:57:26 <kmc> bobzhang, you might want a 'smart constructor'
07:57:39 <hpc> oh derp
07:58:02 <kmc> bobzhang, like makePr f = Pr { pr = f, prs = hcat . map f }
07:58:24 <kmc> then you can also say  (makePr f) { prs = ... }
07:58:25 <roconnor> tsou: I don't know what to call it other than (f x g) . Delta
07:58:26 <bobzhang> yeap, but I want (Pr Char) to be different
07:58:30 <bobzhang> like Show typeclass
07:58:32 <Guest75470> kmc: Well, you need to collect all the letters that you pass on your way to the end
07:58:40 <roconnor> tsou: I'd be interested in knowing a shorter name
07:58:41 <kmc> right
07:58:50 <bobzhang> kmc: how could I do this?
07:58:58 <robert[]> @tell yrlnry why igornig me
07:58:58 <lambdabot> Consider it noted.
07:59:00 <kmc> bobzhang, do what?
07:59:28 <tsou> roconnor: I think had seen it in Bird's book, but it's not with me at the moment
07:59:44 <Dunno> Does anyone know where I can power ppoints presentation for
07:59:45 <tsou> roconnor: what is your Delta?
07:59:48 <Dunno> OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part I
08:00:11 <roconnor> tsou: Δ(x) = (x,x)
08:00:19 <tsou> roconnor: (i get what it does, but how come the name?)
08:00:32 <roconnor> it's the name that I've seen in category theory stuff
08:00:33 <tsou> how come = how standard is it
08:00:35 <yrlnry> tsou:  it's short for the word "diagonal".
08:00:35 <lambdabot> yrlnry: You have 1 new message. '/msg lambdabot @messages' to read it.
08:00:42 <robert[]> yrlnry
08:00:45 <yrlnry> tsou:  that's a pretty common abbreviation.
08:00:51 <tsou> i see, thanks ;)
08:00:57 <yrlnry> YW
08:01:06 <hpc> yrlnry: short for "Δiagonal", you mean :P
08:01:10 <robert[]> > yrlnry
08:01:11 <lambdabot>   Not in scope: `yrlnry'
08:01:22 <tsou> heh
08:01:23 <kmc> HλLFLIFE
08:01:28 * monochrom shakes head
08:01:48 <monochrom> robert[]: if someone doesn't want to answer you, please just let go.
08:02:42 <tsou> so indeed i'm looking if there's a standard name for (f x g) . Δ
08:02:52 <yrlnry> Διαγώνιος
08:02:54 <quicksilver> robert[]: you described mercury^ as a troll earlier; did he also ignore you in PM? Please don't bore the channel with this kind of stuff.
08:03:13 <quicksilver> tsou: ***, dependinf what you mean by 'x'
08:03:34 <quicksilver> > (length *** tail) $ ([4,5,6],[7,8,9])
08:03:35 <roconnor> quicksilver: tsou wants the mathematical name
08:03:35 <lambdabot>   (3,[8,9])
08:03:41 * hackagebot DSH 0.7.3 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.7.3 (GeorgeGiorgidze)
08:03:43 <quicksilver> oh, sorry.
08:03:47 <roconnor> quicksilver: for (&&&)
08:04:07 <quicksilver> it is the diagonal map, as someone set
08:04:09 <quicksilver> said.
08:04:29 <roconnor> quicksilver: the diagonal map is (id &&& id), not (&&&) itself
08:04:43 <quicksilver> roconnor: yes, but mathematicians abuse notation all the time :)
08:05:00 <bobzhang> kmc: to make a tiny example
08:05:00 <robert][> yrlnry
08:05:05 <roconnor> well, I'd be tempted to call it (f Δ g) ... but I'm just making that up
08:05:09 <dolio> (f x g) . Δ is <f, g> if I'm not mistaken.
08:05:13 <bobzhang> if i have data Pr2 a = Pr2 {  pr2 :: a -> Doc , pr2s :: [a] -> Doc }
08:05:16 <quicksilver> composition/application, it's all the same to me
08:05:27 <roconnor> dolio: that seems familiar
08:05:28 <Dunno> Does anyone know where I can find power point presentation for -- OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part I
08:05:30 <bobzhang> and another typeclass class Generic g where unit :: g ()
08:05:48 <dolio> <f, g> is how the universal morphism for products is typically written.
08:05:56 <kmc> Dunno, when i google "A Taste of Haskell" the first result is http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-tutorial/index.htm
08:05:57 <monochrom> Richard Bird's "Algebra of Programming" uses "pair (f,g) a = (f a, g a)" in program code
08:06:00 <kmc> which has video and PDF slides
08:06:26 <Guest75470> kmc: Could you explain the code you gave me earlier? value (TrieNode val children) = maybeToList val ++ concatMap (valuesTrie . snd) children
08:06:32 <bobzhang> and another typeclass class Generic g => class GenercList g where list :: g a -> g [a]
08:06:33 <kmc> Guest75470, what about it?
08:06:39 <tsou> I guess the discussion we're having, kinda proves that even if a name of this things is given in a book (as I think) it's far from standard to use it without explaining it
08:06:41 <kmc> i explained some of it before, did that make sense?
08:06:55 <Guest75470> kmc: I remember something about pattern matching :P
08:07:04 <Dunno> OK.Thanks.:)
08:07:05 <robert][> @tell yrlnry PM me when you get a chance please
08:07:05 <lambdabot> Consider it noted.
08:07:06 <bobzhang> so how to write instance Generic Pr2, and GenericList Pr2?
08:07:09 <kmc> so we have value (TrieNode val children) = ...
08:07:19 <kmc> val :: Maybe a,  and children :: [(Char, Trie a)]
08:07:21 <kmc> right?
08:07:25 <Guest75470> kmc: Yup
08:07:39 <kmc> maybeToList val :: [a]
08:08:05 <kmc> we want to recursively call 'value' on all of the subtries
08:08:13 <kmc> the subtries are the second elements of those pairs in 'children'
08:08:19 <monochrom> and <f,g> in formulas when not coding
08:08:22 <kmc> so we'd map (value . snd)
08:08:27 <kmc> but that will give [[a]]
08:08:34 <kmc> i.e. a list of values, for each subtrie
08:08:40 <kmc> so we use concatMap to glue those sublists together
08:08:42 <kmc> @src concatMap
08:08:42 <lambdabot> concatMap f = foldr ((++) . f) []
08:08:49 <hpc> :t concatMap
08:08:50 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:08:52 <kmc> hmm well also concatMap f = concat . map f
08:09:12 <kmc> Guest75470, i think you have some inconsistent naming, you call it 'value' in one place and 'valuesTrie' in another
08:09:18 --- mode: ChanServ set +o monochrom
08:09:21 <tsou> monochrom: thanks!  and it's consistent with dolio ;)
08:09:24 --- mode: monochrom set +b *!*@pool-173-66-142-19.washdc.fios.verizon.net
08:09:24 --- kick: robert][ was kicked by monochrom (robert][)
08:09:29 <Guest75470> kmc: Sorry about that :P
08:09:32 <kmc> thanks monochrom
08:09:53 <dolio> I was wondering when that would happen.
08:14:11 <tsou> thanks all ;)
08:23:16 <sonoflilit> in yesod forms, I want to combine two fields into one
08:24:24 <sonoflilit> if I were using the Applicative instance, easy: newField = fieldsToTable (,) <$> field param <*> field differentParam
08:24:48 <sonoflilit> but I want to use the Monad instance, because I need to get some stuff from the DB
08:25:07 <sonoflilit> I cannot really figure how to translate this
08:25:37 <sonoflilit> if I could only use fieldsToTable from the monad instance (which entails wrapping everything in toForm)
08:26:05 <sonoflilit> can anyone help?
08:27:50 <Saizan> sonoflilit: s/<$>/`liftM`/ s/<*>/`ap`/
08:28:26 <sonoflilit> Saizan: I'm not sure I understand, but if I do...
08:28:40 <quicksilver> but there shouldn't be a problem using Applicative and Monad together?
08:28:48 <quicksilver> unless there is a missing instance (even then, it's easy to write)
08:28:53 <sonoflilit> the monad instance is not on the same datatype as the applicative
08:29:20 <kmc> instance Applicative Foo where { pure = return; (<*>) = ap }
08:29:34 <quicksilver> sonoflilit: whichever datatype is a monad should *also* be an applicative
08:29:42 <quicksilver> quite separate from any other datatype which might only be applicative
08:29:46 <quicksilver> if there are two datatypes.
08:29:54 <sonoflilit> you need to use the toForm function, which accepts an action in a different, FormInner, monad, and converts it into a GForm
08:30:03 <quicksilver> as you can see, I'm not familiar with the library in question :-/
08:30:15 <KirinDave> What is "impredictive polymorphism"?
08:30:33 <kmc> KirinDave, instantiating a type variable to a polymorphic type
08:30:42 <sonoflilit> quicksilver: but there's a certain function that I can use when I'm working in applicative style, fieldsToTable, that I wish I could use from GFormMonad
08:31:03 <Quantumplation> [(0,[1,2,3]),(1,[2,3]),(2,[3])]  I need a list comprehension, given that, that will form (x, y) where x is fst of each tuple, and y is the running total of pairings.  so, [(0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (2, 6)]
08:31:09 <Kaidelong> sonoflilit: You can!
08:31:14 <Kaidelong> that's what kmc just showed you
08:31:17 <Quantumplation> wait, nevermind, i think i figured it out
08:31:20 <Kaidelong> if you don't want to write the instance yourself
08:31:22 <KirinDave> kmc: I will probably need more to go on than that. :)
08:31:27 <kmc> KirinDave, context?
08:31:32 <Kaidelong> I think a WrappedMonad instance lives in Control.Applicative
08:31:43 <danr> KirinDave: http://blog.solaris.bytelabs.org/articles/2008/08/10/predicative-vs-impredicative-polymorphism-and-type-reconstruction
08:31:51 <Kaidelong> so that you can take your monad, put it in the WrappedMonad newtype, and use it as an applicative
08:31:56 <KirinDave> kmc: I saw a "newtype hack" in that cool thing on chaining and nesting  iteratees
08:32:05 <sonoflilit> ah, but here's the problem
08:32:07 <KirinDave> And actually I had written some of the code he had written. I was pumped!
08:32:23 <KirinDave> But the bit that did what I really wanted it to do?
08:32:25 <Kaidelong> but there is no harm in making an applicative instance of GFormMonad
08:32:28 <KirinDave> I didn't understand it
08:32:30 <sonoflilit> I don't want to just use it, I want to use its return value as the return value of my monadic action, and it's the wrong type
08:32:32 <KirinDave> danr: Ty, looking.
08:32:51 <sonoflilit> probably without being familiar with the library you couldn't help immediately :) but thanks
08:33:02 <sonoflilit> I'll spend more time trying to figure it out
08:33:16 <kmc> KirinDave, I can look at the code if it's available somewhere
08:33:24 <erus`> is there a reference type?
08:33:27 <quicksilver> gosh, what a mess of types
08:33:28 <quicksilver> (yesod)
08:33:34 <kmc> erus`, mutable reference cells?
08:33:36 <KirinDave> kmc: http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/92928
08:33:38 <quicksilver> I wonder that is the simplest way to do what yesod is trying to do
08:33:46 <quicksilver> I should take a proper look at it sometime.
08:33:56 <kmc> which bit KirinDave?
08:34:20 <Quantumplation> ok, nevermind, i need the list comprehension to be [(0, [1, 2, 3]), (1, [4, 5]), (2, [6])].  So, how would I build a list comprehension that, for each element, took the count of everything before it, and added that to each element of the array it was drawing from?
08:34:27 <erus`> kmc like computeLater (something a)  that returns some reference or something?
08:34:42 <Quantumplation> erg, it gets even worse, nevermind
08:34:53 <erus`> i have an infinite recursion problem :|
08:35:05 <kmc> erus`, that's how laziness works automatically
08:35:09 <KirinDave> kmc: Last example.
08:35:24 <KirinDave> erus`: Everything is computeLater. :)
08:35:34 <erus`> well its not in my code
08:35:41 <matthiasgorgens> If you'd like some of the abstractions that FRP gives you, but don't need continuous values (but do need continuous time), i.e. event based programming or so, what's a good library to look into?
08:35:41 <erus`> because monads or something
08:35:46 <copumpkin> if you have an imperative action that you want to compute later
08:35:49 <kmc> erus`, monads aren't un-lazy  by default
08:35:50 <copumpkin> you might want a future or something
08:35:56 <Quantumplation> bleh, this list comprehension is going to be so insane. x.x
08:35:59 <kmc> erus`, we can help you fix your code
08:36:03 <KirinDave> Indeed. Just wrap it in an intermediate value.
08:36:29 <erus`> kmc: ok go for it https://github.com/tm1rbrt/lambdurp/blob/master/testcompiler.hs
08:36:36 <erus`> that wont terminate
08:36:39 <erus`> :D
08:36:59 <erus`> because the function in examples/fib references itself
08:37:11 <kmc> KirinDave, so my understanding (from skimming only :/) is that he wants a list [take 2, take 3, take 4] :: [forall a. Enumeratee el1 el2 m a]
08:37:33 <kmc> but that's impredicative, because it instantiates the polymorphic type [t] at the polymorphic argument t = forall a. Enumeratee el1 el2 m a
08:37:48 <kmc> and GHC's support for impredicative polymorphism is bad and/or deprecated
08:38:07 <KirinDave> kmc: Yeah, since the enumeratees all have different values interally for a that have to match up with the next value in the list, right?
08:38:14 <kmc> i guess so
08:38:17 <dmwit> Quantumplation: I don't even understand the English.
08:38:18 <KirinDave> THe compiler CAN work it out, but not at the list level
08:38:23 <dmwit> description.
08:38:29 <Quantumplation> dmwit: heh, ok, let me try and state my problem clearer
08:38:42 <kmc> KirinDave, so the 'newtype trick' is that instead of making a list of polymorphic values, we make a list of monomorphic values which are newtype-wrapped polymorphic values
08:38:49 <kmc> the EI wrapper he defines
08:38:49 <dmwit> matthiasgorgens: I suppose conal has that "Push-Pull FRP" paper, which talks about event-based FRP implementation.
08:39:02 <dmwit> matthiasgorgens: I don't recall the name of the implementation on Hackage, though... maybe "reactive"?
08:39:05 <Quantumplation> I have a "descriptor" data structure, which takes the form [(nodeID, [edgeIDs])] which describes edges
08:39:14 <kmc> KirinDave, now you're not instantiating any type variables at polymorphic arguments
08:39:18 <matthiasgorgens> dmwit, yes, I read that paper.  It's quite nice.  But the bugs in the reactive library scare me.
08:39:20 <kmc> KirinDave, you're just making data with polymorphic components
08:39:23 <KirinDave> kmc: Why did Haskell drop this?
08:39:25 <dolio> That's still impredicative. It's just easier for GHC to figure out.
08:39:28 <KirinDave> kmc: Seems like a useful feature?
08:39:34 <kmc> which is supported by the PolymorphicComponents or RankNTypes extension
08:39:37 <kmc> KirinDave, it was never in Haskell
08:39:39 <KirinDave> Ah
08:39:52 <KirinDave> How could you rewrite that to use PolymorphicComponents?
08:39:57 <matthiasgorgens> dmwit: and I don't need the full power of FRP, because we only deal with discrete values.
08:39:59 <KirinDave> It'd just work naturally if you turned that on?
08:39:59 <dmwit> matthiasgorgens: There's probably 10-15 different implementations of FRP lying around in various places, but I don't think there's a canonical go-to implementation (yet).
08:40:00 <kmc> it's already so KirinDave
08:40:02 <kmc> yes
08:40:05 <Quantumplation> so, [(0, [1,2,3]), (1, [2, 3]), (2, [3])] describes 4 nodes, all connected to eachother
08:40:08 <kmc> EI has a polymorphic component
08:40:16 <KirinDave> Huh, that is an extension I need to check.
08:40:18 <dmwit> matthiasgorgens: So I'm not sure there's an answer to your question, unfortunately.
08:40:19 <kmc> KirinDave, the GHC ImpredicativeTypes extension causes big headaches for the type checker; I don't really know why
08:40:24 <Quantumplation> (the graph is undirected, so the edges only show up once)
08:40:30 <matthiasgorgens> dmwit: Thanks for the pointers.
08:40:42 <Quantumplation> I need to translate that into a list of node index / edge index tuples
08:40:42 <kmc> KirinDave, PolymorphicComponents is a weaker version of RankNTypes which only allows such quantification in data fields, and not in function arg types
08:40:54 <kmc> turning on RankNTypes is sufficient too
08:40:58 <KirinDave> kmc: I am reading about both now.
08:41:09 <kmc> in some sense the newtype is a 'hint' to the type checker
08:41:13 <Quantumplation> where edges are increasingly indexed from 0 to 1 as they appear
08:41:16 <dmwit> matthiasgorgens: I think Heinrich Apfelmus (?) has been talking up a new implementation on his blog, and quicksilver claims to have something nice.
08:41:19 <KirinDave> Man, learning haskell is so different from every other language.
08:41:33 <KirinDave> Stuff like this major change and what it enables just don't exist in a world like Scala. :|
08:41:37 <matthiasgorgens> KirinDave: Why?  I found it very similar to learning Clean.
08:41:37 <KirinDave> erus`: On your question
08:41:55 <Quantumplation> and if an edge connects two nodes, it must show up in both node's edge list
08:41:59 <KirinDave> matthiasgorgens: Maybe I am just used to the more commercial languages.
08:42:02 <KirinDave> erus`: So, we'd need to see more.
08:42:10 <matthiasgorgens> dmwit: Yes.  But I'm not actually that interested in FRP at the moment.  I want something weaker. ;o)
08:42:10 <kmc> KirinDave, really?  Scala's type system is pretty insane
08:42:15 <KirinDave> kmc: It is.
08:42:16 <erus`> i posted the link up there ^
08:42:19 <kmc> I think other languages are just less extension-happy than GHC Haskell
08:42:26 * dmwit nods supportively at matthiasgorgens
08:42:33 <kmc> (i don't necessarily mean insane bad, by the way)
08:42:38 <KirinDave> kmc: Indeed, but haskell's extensions can like… change the world.
08:42:48 <kmc> (but it's at least as complex as Haskell's and is up there with GHC Haskell)
08:42:50 <KirinDave> erus`: Well
08:42:50 <c_wraith> GCC has a ton of extensions too
08:42:57 <matthiasgorgens> KirinDave: That was more tongue in cheek.  Clean is almost identical to Haskell in what it takes to learn.
08:43:00 <KirinDave> c_wraith: it si true.
08:43:03 <dmwit> Quantumplation: That doesn't sound like an ideal place for a list comprehension to me.
08:43:07 <matthiasgorgens> It's also lazy, functional and statically typed.
08:43:17 <KirinDave> erus`: So your problem
08:43:34 <Quantumplation> well, i'm constructing an array out of it, so i'm not sure how else to do it
08:43:37 <dmwit> Quantumplation: You should consider bringing in more interesting data types -- finite maps and such.
08:43:42 <matthiasgorgens> KirinDave: If you want to keep learning, look into Prolog and Curry next.  And play around with Lisp's macros.
08:43:43 <erus`> yup?
08:43:45 <KirinDave> erus`: Is that if the fib parser cannot terminate, you can't evaluate it enough to determine if it is a "Right" or "Left"
08:43:51 <KirinDave> matthiasgorgens: I know lisp quite well
08:43:52 <Quantumplation> array (0..num) [comprehension]
08:43:57 <KirinDave> matthiasgorgens: Done production code in it, even.
08:44:04 <KirinDave> matthiasgorgens: Prolog too, at Powerset as part of NLP
08:44:18 <erus`> KirinDave: yes
08:44:21 <KirinDave> None of them even hold a candle to the depth I'm finding in #haskell
08:44:24 <matthiasgorgens> KirinDave: Cool.  I've never done production code in Lisp.  Though I played around a fair bit with PLT Scheme (not so much with Common Lisp.  That's too ugly.)
08:44:29 <erus`> KirinDave: how cani  design around this?
08:44:30 <matthiasgorgens> KirinDave: I do write production Haskell code, though.
08:44:30 <cicatristeza> ivan`: is this ivanm?
08:44:52 <Quantumplation> I need to have an array of these things because i'm tying the knot in the makeGraph function for a generic graph library i'm writing
08:44:57 <ivan`> cicatristeza: no
08:45:11 <KirinDave> erus`: Well, two ways
08:45:16 <cicatristeza> ivan`: well are you the fella who does graph theoretic things?
08:45:23 <KirinDave> erus`: For one, parsing a self-referential function shouldn't be an infinite loop. :\
08:45:33 <KirinDave> erus`: For two, instead of saying (Right a)
08:45:41 <kmc> another way to put it is that the Haskell committee was a lot more conservative than (say) the C++ committee, who kind of threw in everything they could
08:45:43 <KirinDave> Just say a.
08:46:00 <KirinDave> But I have no idea what compile will do later.
08:46:03 <erus`> KirinDave: its because i dont create a list of bindings :|
08:46:09 <erus`> i create a tree
08:46:16 <erus`> i need to make a list
08:46:20 <KirinDave> erus`: knot tying.
08:46:23 <erus`> i need to start again
08:46:37 <erus`> if i return a future it will just cause a space leak in the end anyway
08:46:41 <KirinDave> erus`: A circular tree can exist in haskell, although how you use one sanely is not something I can help you with. :)
08:46:44 <matthiasgorgens> kmc, Haskell started out as a really conservative language.  But the forbidden fruit of type classes nudge it onto the path of avant garde.
08:46:50 <kmc> yes
08:46:52 <Quantumplation> Unless someone has a better way to take write http://hpaste.org/52574
08:47:10 <KirinDave> kmc: Ty for the info!
08:47:26 <matthiasgorgens> Quantumplation: Could you draw a picture?
08:47:30 <ivan`> cicatristeza: nope
08:47:57 <KirinDave> kmc: I wouldn't be half as far along on this haskell thing were it not for your help. :)
08:47:59 <Quantumplation> matthiasgorgens: sure, give me a few minutes
08:48:05 <erus`> a map to bindings will fix it
08:48:09 <matthiasgorgens> Quantumplation: thanks.
08:48:15 <dylukes> Quantumplation: Do it all in fundeps. Logical style.
08:48:21 <dylukes> Type level. :D
08:49:00 <matthiasgorgens> Oleg did it before.
08:49:10 <dylukes> Oleg is *insane*.
08:49:14 <dylukes> (in a good way)
08:49:15 <yrlnry> @lambdabot messages
08:49:16 <lambdabot> Unknown command, try @list
08:49:22 <yrlnry> sorry, ment to /msg that.
08:49:23 <lambdabot> yrlnry: You have 1 new message. '/msg lambdabot @messages' to read it.
08:49:26 <kmc> KirinDave, glad to hear it's useful :)
08:49:50 <dylukes> matthiasgorgens: I don't think Edge and Node need to be different types?
08:50:00 <dylukes> They could be different constructors for the same type, no?
08:50:02 <matthiasgorgens> Quantumplation: so you want a recursive graph might out of a flat description?
08:50:04 <xil> hi. Do TChan's work with a thread made with forkOS?
08:50:12 <kmc> they should xil
08:50:14 <dylukes> Oh, I guess I see why not
08:50:18 <matthiasgorgens> might -> made.
08:50:27 <kmc> xil, the only difference between forkOS and forkIO semantics relates to FFI calls
08:50:29 <yrlnry> Isn't "Do TChan" a Brazilian musical act?
08:50:42 <matthiasgorgens> dylukes: Why would you want them to be of the same type?
08:50:59 <matthiasgorgens> dylukes: That would make the types express less about the structure of your problem.
08:51:10 <dylukes> matthiasgorgens: You could use GADT's and tag types.
08:51:23 <matthiasgorgens> dylukes: Yes, but why?
08:51:23 <xil> kmc: I see...well I get seg faults when I use os threads =/. In general I'm getting X Server errors otherwise
08:51:28 <dylukes> :\
08:51:29 <dylukes> true
08:51:31 <dylukes> lemme play with it
08:51:32 <kmc> oh dear
08:51:49 <roconnor> @where TTFP
08:51:49 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
08:51:51 <kmc> xil, do you have a small test case which demonstrates the segfaults?
08:52:40 <xil> kmc: the entire program is pretty small, but it uses Gtk2Hs. I can upload it if it'll help, but I only get the errors in the interpreter
08:52:50 <dylukes> matthiasgorgens: the XNetwork tyep is confusing me.
08:52:52 <cicatristeza> how do i convert a .lhs file to pdf?
08:52:54 <dylukes> Why (ID, [ID])?
08:52:57 <dylukes> what does that mean?
08:53:10 <dylukes> is it each nodeid and what its connected too?
08:53:12 <matthiasgorgens> dylukes: you mean the Descriptor type?
08:53:16 <dylukes> yeah
08:53:17 <kmc> xil, ah, it works compiled?
08:53:30 <kmc> there is known weirdness between gui libs and ghci... I don't remember details, sorry
08:53:33 <matthiasgorgens> dylukes: I'd like to know what ID is meant to be.
08:53:45 <xil> kmc: no, but it doesn't tell you about errors, just fails pretty hard, i.e. intermittently freezes the computer or just does nothing
08:54:04 <dylukes> matthiasgorgens: sems to be a synonyum for an integer
08:54:19 <matthiasgorgens> Quantumplation: Is Descriptor meant to be a adjacency list?
08:54:26 <Quantumplation> http://i.imgur.com/2w8oQ.png
08:54:46 <Quantumplation> essentially, yes, it's a specific format of describing graphs
08:55:04 <matthiasgorgens> Quantumplation: ok.
08:55:21 <hpaste> xil pasted “Failing Gtk2Hs” at http://hpaste.org/52580
08:55:48 <kmc> xil, you're using TChan over Chan because you need isEmpty?
08:56:23 <xil> kmc: I don't really need it, but I use it because it's the first way I thought to deal with my problem, so yet
08:56:23 <matthiasgorgens> Quantumplation: How about a functional representation of graphs?
08:56:25 <xil> s/yet/yes
08:56:28 <dylukes> Quantumplation: im playing with it
08:56:30 <dylukes> one moment :\
08:56:48 <Quantumplation> mat: not sure what you mean
08:56:51 <kmc> xil, hmm, I thought gtk2hs had some function IO a -> IO a for 'run this action in the special gtk thread'
08:56:55 <kmc> but now i forget what it's called
08:58:05 <xil> kmc: just so you know this is a fractal program for drawing the Mandelbrot set. The OS thread computes the Complex formula for the fractal, the other two threads are for drawing the points
08:58:30 <Quantumplation> ick, I gotta run to class, but i'll be back in an hour or so, i'll leave mIRC open.
08:59:08 <kmc> xil, why are you using forkOS for the computation?
08:59:10 <matthiasgorgens> Quantumplation: Sorry, not functional, but something like: data Graph = Graph ID [Graph]
08:59:33 <matthiasgorgens> Or rather:
08:59:42 <matthiasgorgens> data Node = Node ID [Node]
08:59:48 <matthiasgorgens> (Without edges.)
08:59:56 <xil> kmc: I don't really need to, but I liked the idea of the computation actually happening simultaneously to the other stuff, since I found out Haskell threads all actually run on one system thread
08:59:59 <matthiasgorgens> a node has an ID and a list of adjacent nodes.
09:00:06 <kmc> xil, that's not true
09:00:15 <xil> kmc: oh...
09:00:19 <kmc> xil, where did you read that?
09:00:29 <kmc> xil, if you compile with ghc -threaded -rtsops
09:00:36 <kmc> then you can say ./foo +RTS -N 20
09:00:42 <kmc> to get 20 OS threads
09:00:54 <kmc> it's typical to leave off the number, in which case it gives one OS thread per CPU core
09:01:08 <kmc> xil, forkOS does *not* give you more OS threads for Haskell computation.  the only guarantee relates to FFI calls
09:01:13 <kmc> it's very poorly named
09:01:29 <kmc> see documentation http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/Control-Concurrent.html#v:forkOS
09:01:42 <xil> kmc: I think in the docs for the two, but I don't remember now. So if I do want genuine threads I should use the RTS stuff, okay let me try that and see if at least the seg fault stops
09:01:59 <kmc> if anything you should be using forkOS on the GTK threads
09:02:05 <kmc> but I think GTK wants to be access from one thread only
09:02:29 <clsmith> can anyone help me with representing de bruijn indices in haskell as a monad using nested maybes? ^^; there's an article on it but i'm struggling to understand how the bind can be written without ending up with an infinite type
09:02:49 <dylukes> matthiasgorgens: how will you handle recursin?
09:03:05 <matthiasgorgens> dylukes: With laziness.
09:03:06 <dylukes> I guess you could construct it infinitely by giving each Node the entire definition
09:03:09 <kmc> xil, like i said I thought the gtk library provided some way to access that one magic gtk thread
09:03:11 <kmc> but i don't recall now :/
09:03:41 <Quantumplation> matthiasgorgens: unfortunately, my use case is critically dependent on both edges and nodes.  edges are going to get elaboration later on.
09:03:50 <xil> kmc: yeah I don't actually know the appropriate way to draw and maybe the threaded way I'm doing it is what's giving me X Server errors?
09:05:00 <matthiasgorgens> Quantumplation: doesn't matter.
09:05:04 <matthiasgorgens> Quantumplation: technique is the same.
09:06:38 <matthiasgorgens> Quantumplation: do you need the IDs?
09:06:49 <linduxed> hey guys, some time ago i asked about a haskell code formatter (basically to make haskell code that is syntactically correct but incredibly ugly, pretty again), but i can't find it in my logs
09:06:57 <linduxed> do you know what it was called?
09:08:31 <kmc> linduxed, haskell-src-exts can do this no?
09:08:50 <linduxed> kmc:  oh yeah that was the thing
09:08:58 <kmc> i don't know of a command-line tool to it
09:08:58 <linduxed> kmc: gonna google that then
09:09:03 <kmc> but it should be pretty easy to write
09:10:51 <linduxed> kmc: thx, that package's name was all i needed to find this: http://stackoverflow.com/questions/6870148/is-there-a-haskell-code-formatter
09:11:24 <matthiasgorgens> Quantumplation: Give me some minutes.
09:12:10 <syri> I searched on the net for examples of Automaton arrow. I failed to find any. Could someone suggest some examples?
09:14:05 <matthiasgorgens> syri: Are you using arrow in the Control.Arrow sense?
09:20:32 <bartavelle> hello, isn't there a nice syntax for this : http://hpaste.org/52584  ?
09:20:34 <dmwit> syri: I doubt there are examples of it other than what's in the paper that you are surely talking about.
09:20:47 <dmwit> bartavelle: yes
09:20:56 <bartavelle> i tried random things with >>= but couldn't get it right
09:20:58 <dmwit> Value . VariableReference <$> puppetVariable
09:21:02 <bartavelle> oh
09:21:14 <dmwit> :t <$>
09:21:15 <lambdabot> parse error on input `<$>'
09:21:17 <dmwit> :t (<$>)
09:21:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:21:25 <dmwit> <$> is fmap
09:21:44 <bartavelle> isn't that supposed to be applied on [] then ?
09:21:47 <dmwit> So you can write fmap (Value . VariableReference) puppetVariable or Value . VariableReference `fmap` puppetVariable if you prefer.
09:22:01 <dmwit> [] is only one of the many instances of Functor.
09:22:11 <bartavelle> i suppose i should read more
09:22:19 <bartavelle> thanks a lot ! i'll try to ponder on this
09:22:23 <dmwit> In lambdabot, you can even write Value . VariableReference . puppetVariable
09:22:23 <dmwit> =)
09:22:33 <dmwit> :t (.)
09:22:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:22:55 <matthiasgorgens> fmap (Value . VariableReference) puppetVariable
09:23:07 <syri> I found the Automaton arrow documentation. What is the title of the paper?
09:23:10 <dmwit> bartavelle: If you have more questions about Functor, you should feel free to ask them. We're here to help.
09:23:23 <bartavelle> ok i'll ask some more tomorrow
09:23:24 <bartavelle> thanks a lot
09:23:38 <dmwit> syri: Oh, okay. Let's see... I think it's from the Patterson paper on arrows... one second.
09:24:37 <dmwit> syri: "Arrows and Computation", one of the papers linked to from http://www.haskell.org/arrows/biblio.html
09:24:51 <dmwit> syri: Direct link http://www.soi.city.ac.uk/~ross/papers/fop.ps.gz
09:26:25 <dmwit> syri: Hm, that may not be it.
09:29:29 <dmwit> syri: Oh, yeah, that is it. Right there on page 3. =)
09:39:50 <syri> dmwit: Thank you. I wonder though why it has not found any practical uses.
09:40:44 <matthiasgorgens> Quantumplation: do you know Co-Monads?
09:41:16 <mysticc> what is the best way to concatenate to operators eg I want something of the sort (<$>).(<$>) but it looks messy and is not a operator ?
09:42:24 <Kaidelong> mysticc: AFAIK you can't. Although you could certainly define your own
09:42:25 <Kaidelong> like
09:42:45 <Kaidelong> (<$.$>) = (<$>).(<$>)
09:42:56 <Saizan> (fmap . fmap) is less messy
09:43:29 <dmwit> mysticc: http://www.haskell.org/haskellwiki/Infix_expressions
09:43:43 <Kaidelong> mysticc: Also this particular example sounds like you're working with two composed applicative functors
09:44:01 <matthiasgorgens> and they do compose, don't they?
09:44:21 <mysticc> matthiasgorgens: Yup got it right
09:44:23 <Kaidelong> yeah and I think fmap . fmap becomes the new fmap
09:44:31 <Kaidelong> so you would just be able to use <$>
09:44:39 <mysticc> Kaidelong: yeah but I prefer infix version ;)
09:44:52 <dmwit> Kaidelong: You probably need to use an explicit composition type.
09:44:58 <Kaidelong> mysticc: that definition makes a new infix operator
09:45:04 <Kaidelong> dmwit: You do
09:45:25 <Boxo> can one remove an individual defintion from lambdabot? @undefine seems to delete all definitions
09:45:34 <Boxo> @let diffseq xs = map (\(x,y) -> y-x) (zip xs (tail xs))
09:45:35 <lambdabot>  <local>:14:0:
09:45:35 <lambdabot>      Warning: Pattern match(es) are overlapped
09:45:35 <lambdabot>               I...
09:45:38 <dmwit> Kaidelong: Bonus points if you tell us the name if that type and what module to improt.
09:45:44 <dmwit> s/improt/import/
09:45:51 <dmwit> Boxo: no
09:46:04 <Kaidelong> I believe the library is called TypeCompose
09:46:07 <Kaidelong> conal wrote it
09:46:16 <Kaidelong> hmm, was the type called O?
09:46:37 <Twey> Yeah
09:46:44 <Twey> You write Foo `O` Bar
09:46:45 <dmwit> That's what I would call it.
09:46:49 <Kaidelong> ah well
09:46:53 <Kaidelong> you use :.
09:46:57 <Kaidelong> O is an alias for :.
09:47:04 <Twey> Oh, really?
09:47:07 <Kaidelong> so rather than using `O` you'd use :.
09:47:59 <conal> iirc, :. for the type ctor and O for the value ctor
09:48:05 <Kaidelong> the constructor is called O though
09:48:13 <Kaidelong> yeah
09:48:15 <conal> O gfa :: (g :. f) a
09:48:41 <Kaidelong> you also seem to have a type alias
09:48:48 <Kaidelong> type O = :.
09:48:54 <Kaidelong> you mention that it's for compatibility
09:48:58 <rostayob> dcoutts_: is signalDisconnect the only way to remove som function bound to an event? It would be cool to remove all the events for a certain eventmaks
09:49:53 <Kaidelong> anyway mysticc, most likely you are just working with something in the form (g :. f) anyway if you want to use (<$>).(<$>)
09:50:13 <dcoutts_> rostayob: yes, it means you can only disconnect handlers you know about, which makes it modular
09:50:34 <dcoutts_> you shouldn't be disconnecting handlers you don't have a handle on (ie don't have permission to fiddle with)
09:50:45 <conal> that's my clue also. if i write a Functor instance with (fmap.fmap), then i probably want to redefine the type and get Functor for free. ditto with Applicative
09:50:59 <rostayob> dcoutts_: uhm all right so I have to store the ConnectId somewhere and then remove it
09:51:06 <dcoutts_> right
09:51:15 <rostayob> dcoutts_: thanks again
09:51:34 <conal> my goal often is to eliminate code altogether, in favor of type definitions.
09:51:42 <conal> (value-level code)
09:52:06 <Kaidelong> the Functor/Cofunctor thing is regrettable
09:52:16 <Kaidelong> given that Cofunctor would be a more sensible name for Functor
09:52:48 <byorgey> Kaidelong: eh? why's that?
09:53:00 <Kaidelong> one isn't the dual of the other
09:53:21 <Kaidelong> but Functor is a covariant functor, and Cofunctor in TypeCompose is a contravariant functor
09:53:23 <Saizan> in fact i don't think anyone uses Cofunctor
09:53:33 <Kaidelong> Saizan: Really?
09:53:39 <Saizan> ah, then yeah, it's wrong
09:53:42 <Kaidelong> it seems to me like a pretty damn useful class
09:53:42 <byorgey> Kaidelong: oh, Co- as as opposed to Contra-.
09:54:00 <Saizan> Kaidelong: i mean as a term
09:54:14 <Kaidelong> Saizan: Yeah okay
09:54:28 <Kaidelong> just seems regrettable that the contravariant functor has to be called Cofunctor
09:54:52 <Saizan> i've seen ContraFunctor somewhere else in haskell
09:55:01 <Saizan> probably something by edwardk :)
09:55:11 <copumpkin> he called it ContraFunctor in category-extras
09:55:21 <copumpkin> he now just calls it Covariant
09:55:32 <donri> oh, this is the first time i've added a relative path to $PATH: cabal-dev/bin :)
09:55:36 <JuanDaugherty> it prolly would (CoFunctor used) be if having the goal of eliminating value level code actually worked to produce useful end function
09:55:41 <Saizan> copumpkin: not Contravariant?
09:55:44 <copumpkin> lol
09:55:46 <Kaidelong> Covariant and Contravariant probably are perfectly decent names
09:55:47 <copumpkin> yeah, that one
09:55:58 <Kaidelong> instead of Functor and Cofunctor
09:56:03 <Kaidelong> or Functor and ContraFunctor
09:56:16 <copumpkin> it's Functor and Contravariant
09:56:20 <copumpkin> nice and symmetric
09:56:24 <edwardk> contravariant
09:56:27 <copumpkin> Endofunctor and Contravariant
09:56:44 <shirt> i've converted my program to use Text and "aeson" package instead of String an "json" package and now my progam is twice as slow!
09:56:46 <edwardk> (thats the package)
09:56:57 <copumpkin> shirt: you probably fucked it up
09:57:09 * copumpkin is always very helpful
09:57:33 <edwardk> i swapped to that name because applicative is also an adjective describing a functor and it avoided a random abbreviation and the issue of which capitalization to use
09:58:09 <copumpkin> LaxMonoidalEndofunctorOnHask
09:58:19 <edwardk> that was a close runner up
09:58:37 <kmc> shirt, :(
09:58:48 <edwardk> it lost to StrongLaxMonoidalEndofunctorOnHask, which in turn lost in the final round to Contravariant
09:58:56 <edwardk> mostly due to typing fatigue
09:59:28 <copumpkin> ValueAddedProactiveDynamicSynergyParadigm
09:59:54 <copumpkin> class ValueAddedProactiveDynamicSynergyParadigm a where id :: a -> a
10:00:05 <edwardk> id = unsafeCoerce 12
10:00:09 <sp3ctum> copumpkin, sounds like something I should dump in a boring java program as a joke
10:00:12 <sp3ctum> one like my thesis
10:00:15 <kmc> shit man, we should have brackets and betting pools on these names
10:00:23 <sp3ctum> which nobody will ever evaluate code-wise
10:00:24 <copumpkin> it's actually stolen from something dolio wrote up on the board
10:00:48 <copumpkin> sp3ctum: as part of some software we're writing here
10:00:51 <aristid> copumpkin: VAPDSP
10:00:51 <edwardk> i advise that we leverage the ValueAddedProactiveDynamicSynergyParadigm in our next project
10:01:13 <copumpkin> we intend to!
10:01:30 <sp3ctum> O_o
10:01:40 <Saizan> you'll totally get energised by it.
10:01:57 <sp3ctum> I was going to say synergy but that's already in there
10:02:02 <sp3ctum> it's perfect
10:02:23 <aristid> it lacks Win-Win
10:02:53 <sp3ctum>  -> instance BullshitGenerator ValueAddedProactiveDynamicSynergyParadigm where {..}
10:03:07 <dolio> Do you mean: Win-Win-Win?
10:03:25 <copumpkin> sp3ctum: that isn't possible yet
10:03:38 <copumpkin> in GHC head, you could write that
10:03:40 <copumpkin> or actually
10:03:44 <copumpkin> not sure it's been merged in yet
10:04:00 <aristid> copumpkin: huh, what's the problem?
10:04:11 <copumpkin> ValueAddedProactiveDynamicSynergyParadigm is a typeclass
10:04:11 <sp3ctum> i'm new to haskell, so i don't understand. is the syntax off?
10:04:13 <copumpkin> * -> Constraint
10:04:20 <aristid> oh.
10:04:22 <dolio> Pretty sure it has.
10:04:38 <aristid> copumpkin: typeclasses have kinds now?!
10:04:43 <copumpkin> so BullshitGenerator is (* -> Constraint) -> Constraint
10:04:46 <copumpkin> which is crazy
10:04:50 <copumpkin> aristid: yeah
10:04:52 <dolio> Yes.
10:05:00 <dolio> They missed a massive opportunity, though.
10:05:02 <aristid> was it always that way?
10:05:06 <dolio> To have the constraint kind be o.
10:05:20 <hpaste> “Matthias Goergens” pasted “Tying the knot” at http://hpaste.org/52585
10:05:22 <edwardk> aristid: no, it was added recently by bolingbroke
10:05:41 <copumpkin> you know why he gets so much shit done?
10:05:41 <matthiasgorgens> Quantumplation: Something like http://hpaste.org/52585 should work for you.
10:05:43 <copumpkin> cause he's not on IRC
10:05:50 <edwardk> it makes me downright giddy. is it still going to be in 7.4.1?
10:05:57 <sp3ctum> i think that fills my haskell (._.) done, back to boring java for me
10:05:58 <edwardk> copumpkin: ouch
10:06:04 <sp3ctum> s,done,dose,
10:06:55 <Kaidelong> hmm did you post that hpaste?
10:10:34 <matthiasgorgens> Kaidelong: who are you talking to?
10:10:49 <Kaidelong> sp3ctum, but I take it that means the answer is no
10:10:56 <Kaidelong> I was trying to put his comments into context
10:13:23 <sp3ctum> oh sorry, i referred to my earlier comment
10:13:40 <sp3ctum> it's not my hpaste
10:14:26 <gwern> > 24 * 7
10:14:27 <lambdabot>   168
10:20:14 --- mode: monochrom set -b *!*@pool-173-66-142-19.washdc.fios.verizon.net
10:20:19 --- mode: monochrom set -o monochrom
10:24:47 <trinithis> I kicked my power cord off... did someone unsafePerformIO?
10:28:32 <int-e> hmmm. ask your parents.
10:29:09 <kmc> talk to your kids about unsafePerformIO before someone else does
10:29:16 <monochrom> haha
10:29:54 <trinithis> And keep your son away from my daughter! She's too young for IO.
10:30:23 <mm_freak> unsafePerformIO (getWrongGirl >>= sex)
10:30:27 <mm_freak> = nightmare
10:31:28 <kmc> it starts off so innocently, just a little unsafeInterleaveIO, but then they move on to unsafePerformIO, then unsafeDupablePerformIO, then unsafeCoerce
10:32:10 <kmc> pretty soon you're lying in a back alley using Foreign.Storable to directly manipulate GHC heap objects
10:32:21 <kmc> and casting ByteStrings into functions
10:32:55 <Saizan> do you mean that's not the way you're supposed to program?
10:33:13 <monochrom> does unsafeCoerce mean they try out human-pig IO?  <duck>
10:33:30 <Quantumplation> I'm back
10:33:44 <Saizan> just in time for bestiality
10:33:49 * hackagebot serialport 0.4.2 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.4.2 (JorisPutcuyps)
10:33:56 <int-e> monochrom: poor duck.
10:33:57 <kmc> there's never a bad time for bestiality
10:34:04 <monochrom> but java certainly casts byte arrays into classes and methods
10:34:41 <kmc> most Java code does not use this feature
10:35:03 <monochrom> I used it once to enhanced safety (!)
10:35:41 <luite> hmm, you always have to go through the verifier before the code is actually used, don't you?
10:35:54 <monochrom> yes, I didn't circumvent that part
10:36:27 <KirinDave> Setting up an ubuntu 10.11 box
10:36:33 <KirinDave> is there any problems with haskell on 64-bit platforms?
10:36:38 <Quantumplation> matthiasgorgens: alrighty, so what exactly is going on here? heh
10:36:42 <luite> KirinDave: should work fine
10:36:50 <Saizan> KirinDave: not on linux at least
10:36:53 <KirinDave> luite: Even with things like haskell's gtk bindings?
10:37:07 <luite> KirinDave: I had no problems with them on linux
10:37:15 <Quantumplation> Node nodeID edgeID <-- the type of the ID's is now a type parameter?
10:37:18 <kmc> KirinDave, not in general, but on OS X yes
10:37:21 <luite> on os x it's still experimental
10:37:43 <KirinDave> Yeah well I am leaping away from that OS like an action hero slomo-ing through a window as fire races up behind him.
10:37:57 <kmc> haha
10:38:14 <monochrom> I still haven't tried 11.10 beta2! and now 11.10 non-beta is out
10:38:20 <luite> linux is certainly easier to use with haskell than the alternatives
10:38:30 <kmc> i think GHC supported 64-bit platforms a long time ago
10:38:30 <KirinDave> Word
10:38:34 <kmc> some of them may no longer be supported :)
10:38:42 <KirinDave> Just wanted to make sure I wasn't lining myself up for hurtful things.
10:38:42 <shirt> upon further investigation, my program is 2-3% faster with Text and "aeson" package instead of String an "json" package :)
10:38:45 <dmwit> KirinDave: I use Haskell (and gtk2hs in particular) on a 64-bit Linux system and haven't yet had a problem with it.
10:38:55 <KirinDave> dmwit: This excites me :)
10:39:04 <kmc> shirt, cool, that's better than -50% :)
10:39:08 <erus`> maybe if simon peyton jones and simon marlow both grow beards haskell will take off... ?
10:39:09 <kmc> shirt, are you benchmarking with Criterion?
10:39:19 <KirinDave> shirt: That is very surprising.
10:39:21 <kmc> Unix : beard :: Haskell : bowtie
10:39:27 <dmwit> erus`: That would be terrible.
10:39:32 <kmc> http://en.wikipedia.org/wiki/File:Simon_Peyton_Jones_01.jpg
10:39:33 <KirinDave> shirt: Text+aeson+iteratees should be MUCH faster than alternatives.
10:39:54 <dmwit> kmc: Aw, SPJ_02.jpg doesn't exist.
10:40:09 <KirinDave> shirt: Text+aeson+iteratee I/O, for me, is faster even than that badass json parser in jackson.
10:41:24 <copumpkin> shirt: how are you calling it? are you converting to/from String?
10:41:37 <copumpkin> are you compiling with -O2?
10:42:04 <shirt> kmc: i set up criterion and planned to use it, but i had to abort that mission since my benchmark IO action doesn't clean up properly (it leaves dangling background threads)
10:42:12 <shirt> copumpkin: i'm compiling with -O
10:42:16 <kmc> ah :/
10:42:31 <kmc> if the background threads are sleeping then it shouldn't make that much difference
10:42:44 <shirt> copumpkin: i'm reading a bytestring from the network and feeding that into aeson
10:43:07 <copumpkin> shirt: try -O2, but it still seems weird
10:43:24 <kmc> try futzing with the garbage collector parameters too
10:43:27 <kmc> ./foo +RTS -A400M
10:43:28 <shirt> KirinDave: i think at this point most of the program time is spent doing network IO, that's why aeson maybe is not making much of a difference. also, my json is lots of very small fragments
10:43:40 <copumpkin> oh, that makes sense then
10:43:45 <KirinDave> shirt: How small?>
10:43:49 <monochrom> @kind Maybe
10:43:50 <lambdabot> * -> *
10:44:13 <shirt> KirinDave: json messages are about 100 characters/bytes
10:44:16 * monochrom now gets the joke
10:44:18 <KirinDave> shirt: It is still strange.
10:44:36 <Quantumplation> hrm, anyone know how to enable XTupleSections in leksah?
10:45:33 <shirt> kmc: thank i'll try playing around with those
10:45:39 <copumpkin> KirinDave: not if he's measuring the total time, including network time
10:46:07 <KirinDave> copumpkin: over short runs, I guess...
10:46:35 <shirt> i'm not measuring short runs, my benchmark takes several minutes
10:46:42 <copumpkin> if his JSON parsing is accounting for 4% of his total time, and he makes his JSON parser twice as fast, he'll only gain a couple of percent total
10:46:57 <copumpkin> you can stick a cost center around your parsing
10:47:24 <copumpkin> SCC stands for "Stick Cost Center"
10:47:31 <copumpkin> [here]
10:48:03 <shirt> hm... at this point i'm not too worried about performance. i just switched to aeson+Text since it seemed the right thing to do, and decided to measure performance just because i was curious
10:48:06 <elliott> copumpkin: is that seriously what scc expands to?
10:48:13 <copumpkin> I hope not :P
10:48:36 <copumpkin> shirt: the other consideration is that by converting to text, you're dealing with encodings
10:48:47 <copumpkin> whereas if you were using bytestring -> string -> json before, you were probably ignoring encoding
10:48:53 <copumpkin> (by using .Char8?)
10:48:56 <KirinDave> copumpkin: Over long runs gc costs should still net bigger wins, in my experience.
10:49:16 <KirinDave> I recently parsed and dumped about 30gb of json over the wire to binary disk format using haskell
10:49:21 <shirt> copumpkin: no, the "json" package does internal decoding of utf8 and returns correct Strings
10:49:23 <KirinDave> Aeson was HUGELY faster.
10:49:28 <copumpkin> oh, I see
10:49:31 <KirinDave> Iteratee parsing was even huger. HUGER.
10:49:33 * copumpkin shrugs then :)
10:49:43 <copumpkin> KirinDave: EPICLY HUGEREST?
10:49:52 <KirinDave> copumpkin: GOTTA GET HUGE.
10:49:54 <shirt> anyway, time for food
10:49:59 * copumpkin nods in approval
10:51:04 <trinithis> Heh, the creator of C died
10:51:19 <monochrom> one of them, not both
10:51:46 <trinithis> who's the other?
10:51:49 <pikhq> Ken Thompson.
10:52:00 <Quantumplation> Wait, who died?
10:52:01 <elliott> trinithis: also of unix
10:52:04 <elliott> Quantumplation: Dennis Ritchie :(
10:52:08 <pikhq> (who presently works for Google)
10:52:24 <elliott> aka R :-P
10:52:29 <Quantumplation> =(((((
10:54:38 <int-e> elliott: I wonder if they will call the book K&~R now.
10:55:25 <trinithis> haha
10:55:26 <dmwit> And then, in a few years, ~(K|R)
10:55:26 <monochrom> haha
10:55:53 <yrlnry> Ritchie invented C.  Ken Thompson is on record saying he had hardly anything to do with it.
10:55:57 <elliott> Thompson's only 68. (Well, "only".)
10:56:06 <monochrom> Kernighan
10:56:14 <elliott> Err, right.
10:56:14 <yrlnry> Kernighan did not invent C.
10:56:14 <trinithis> 1 more year for a fine year ahead of him
10:56:22 <dylukes> :t (.*.)
10:56:23 <lambdabot> Not in scope: `.*.'
10:56:24 <elliott> yrlnry: monochrom was correcting me.
10:56:26 <monochrom> alright
10:56:27 <dylukes> @src on
10:56:27 <lambdabot> (*) `on` f = \x y -> f x * f y
10:56:30 <yrlnry> Everyone thinks he did because he co-wrote the book with dmr.
10:56:32 <dylukes> wait
10:56:33 <dylukes> what
10:56:39 <elliott> Yeah, K is almost the age of R.
10:56:44 <dylukes> you're able to bind an operator name like that?
10:56:44 <yrlnry> Pardon me.
10:56:53 <dmwit> dylukes: yep
10:57:05 <dmwit> dylukes: Why not? =)
10:57:05 <pikhq> yrlnry: Thompson *did* work on B, though.
10:57:07 <tromp> :t filter
10:57:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:57:11 <tromp> :t mfilter
10:57:12 <dylukes> > let apply (*) x y = x * y in apply (+) 1 2
10:57:12 <lambdabot> Not in scope: `mfilter'
10:57:13 <lambdabot>   3
10:57:18 <dylukes> oh. hm.
10:57:19 <dylukes> thats convenient
10:57:30 <dylukes> I still don't quite get the usage case of `on`
10:57:30 <tromp> hmmm, mfilter is used on http://en.wikipedia.org/wiki/Trabb_Pardo-Knuth_algorithm
10:57:46 <dmwit> dylukes: It's typically used in conjunction with (==) or compare.
10:57:56 <dylukes> oh like
10:57:59 <dmwit> dylukes: Though I've used it with (++), e.g. (++) `on` show
10:58:08 <dylukes> reminds me of congruency
10:58:12 <int-e> @check let (.*.) = (+); (.+.) = max in \a b c -> a .*. (b .+. c) == (a .*. b) .+. (a .*. c)
10:58:13 <lambdabot>   "OK, passed 500 tests."
10:58:17 <dylukes> :t (==) `on` (+1)
10:58:18 <lambdabot> forall a. (Num a) => a -> a -> Bool
10:58:32 <dmwit> I guess I don't see the connection with congruency.
10:58:32 <dylukes> > ((==) `on` (+1)) 1 2
10:58:33 <lambdabot>   False
10:58:37 <dmwit> Oh, you mean like this?
10:58:38 <dylukes> > ((==) `on` (+1)) 2 2
10:58:43 <lambdabot>   True
10:58:47 <dmwit> > ((==) `on` (`mod` 3)) 6 9
10:58:49 <lambdabot>   True
10:58:57 <int-e> dylukes: I like using (?) for "unknown" binary operators.
10:59:07 <kmc> @src comparing
10:59:08 <lambdabot> Source not found. Take a stress pill and think things over.
10:59:10 <kmc> comparing f = compare `on` f
10:59:31 <elliott> int-e: That's not valid, I don't think.
10:59:37 <dylukes> > let comparing f = compare `on` f in comparing (!=) 2 3
10:59:38 <lambdabot>   Not in scope: `!='
10:59:47 <dylukes> let comparing f = compare `on` f in comparing (+) 2 3
10:59:59 <elliott> > let comparing f = compare `on` f in comparing pred 2 3
11:00:00 <lambdabot>   LT
11:00:05 <dmwit> I've also had a few places where "f (g x) (g y)" was right, but "on f g x y" wasn't. =(
11:00:06 <int-e> > let f (?) = 1 ? 2 in (f (+), f (-))
11:00:07 <lambdabot>   (3,-1)
11:00:08 <dylukes> > (++) `on` show "hello " "world"
11:00:09 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> a -> b'
11:00:09 <lambdabot>         against i...
11:00:11 <monochrom> > sortBy (comparing fst) [("hi", 3), ("ab", 4)]
11:00:11 <elliott> dylukes: comparing f x y = compare (f x) (f y)
11:00:12 <lambdabot>   [("ab",4),("hi",3)]
11:00:23 <monochrom> > sortBy (comparing snd) [("hi", 3), ("ab", 4)]
11:00:24 <lambdabot>   [("hi",3),("ab",4)]
11:00:31 <dylukes> :t (++) `on` show
11:00:32 <lambdabot> forall a. (Show a) => a -> a -> String
11:00:43 <dylukes> > ((++) `on` show) "hello " "world"
11:00:45 <pikhq> > (++) `on` show $ "hello " "world
11:00:45 <lambdabot>   "\"hello \"\"world\""
11:00:46 <lambdabot>   <no location info>:
11:00:46 <lambdabot>      lexical error in string/character literal at end o...
11:00:47 <pikhq> > (++) `on` show $ "hello " "world"
11:00:48 <lambdabot>   Precedence parsing error
11:00:48 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
11:00:50 <pikhq> Bleck.
11:01:02 <dylukes> nope, you don't want arguments to show.
11:01:05 <int-e> elliott: why wouldn't it be valid?
11:01:16 <dmwit> pikhq: See dylukes' parenthesization.
11:01:23 <elliott> int-e: Well, implicit parameters use ?.
11:01:30 <dmwit> > ((++) `on` show) 3 4
11:01:32 <lambdabot>   "34"
11:01:42 <elliott> int-e: It would be awful if they stopped you using ? as an operator name (e.g. f ?x).
11:01:55 <int-e> elliott: but they aren't Haskell98 nor 2010
11:02:01 <int-e> 11
11:02:11 <elliott> int-e: Yes, but usually extensions try and avoid doing things like that.
11:02:14 * dmwit looks forward to Haskell 201011
11:02:20 <elliott> Prelude> let (?) = undefined in ()
11:02:21 <elliott> ()
11:02:21 <elliott> Huh.
11:02:28 <pikhq> dmwit: Accursed syntax.
11:02:29 <dylukes> ?
11:02:32 <int-e> elliott: well, bang patterns are another such exception
11:02:35 <dylukes> elliott: why is that a surprise?
11:02:44 <elliott> dylukes: See above.
11:02:44 <hpc> :t ?)
11:02:45 <lambdabot> parse error on input `?'
11:02:47 <hpc> :t (?)
11:02:48 <int-e> since (!) is a perfectly valid infix operator per Haskell 98.
11:02:48 <lambdabot> Not in scope: `?'
11:02:57 <int-e> (and used, too, in Data.Array)
11:03:02 <elliott> int-e: Yes, so? Bang patterns don't stop you using it.
11:03:12 <elliott> Implicit parameters change the meaning of "foo (?) = f ?x".
11:03:33 <int-e> elliott: band patterns make  let foo !a = a  ambiguous.
11:03:37 <int-e> *bang
11:03:38 <dmwit> Language extensions change the meaning of a program. News at 11.
11:03:52 <elliott> int-e: Hmm, right.
11:04:01 <elliott> dmwit: Well, they shouldn't if they can avoid doing so.
11:04:15 <elliott> dmwit: "Make previously-invalid programs valid only" and all.
11:05:04 <zenzike> I've just noticed that ack doesn't support *.hsc files: it only does *.hs and *.lhs. I'm writing a patch to rectify that. Are there any haskell derived files that people use? Does *.lhsc even exist?
11:05:30 <mauke> echo $'--type-add\nhaskell=.hsc\n' >> ~/.ackrc
11:06:07 <zenzike> mauke: thanks :-) might be nice to add it to the default ack behaviour too though, no?
11:06:41 <erus`> whats the defuncto package to play sound in haskell?
11:06:55 <mauke> heh
11:07:00 <mauke> "defuncto"
11:07:02 <hpc> @hackage defuncto
11:07:02 <lambdabot> http://hackage.haskell.org/package/defuncto
11:07:04 <elliott> defuncto :D
11:07:09 <elliott> dibs on that name
11:07:12 <int-e> > let ?b = 1 in let b = 2; b ? a = b - a in b ? ?b
11:07:13 <lambdabot>   1
11:07:29 <hpc> elliott: sounds like how you define a functor in clisp
11:07:30 <int-e> elliott: as can be seen here, implicit parameters are whitespace sensitive.
11:07:39 <elliott> int-e: right
11:07:39 <hpc> "defun" => "defuncto"
11:07:49 <dmwit> erus`: (They're making fun of you because the term is "de facto".)
11:08:10 * elliott is merely appreciating the term, not mocking its usage
11:08:19 <dmwit> I think there's csound bindings, and sdl-sound bindings.
11:09:06 <erus`> defuncto is the functional equivalent
11:10:21 <erus`> i wish less packages required cygwin :(
11:10:21 * dmwit just looked at the "Sound" category of Hackage
11:10:25 <dmwit> There's a lot of packages there!
11:11:13 <dmwit> erus`: Use a real operating system. ;-)
11:11:40 <erus`> yes yes i know
11:11:54 <erus`> but games and things
11:11:54 <dunno> Is there any book about thinking in function or functional programming that you recommend
11:12:21 <monochrom> every haskell textbook
11:12:22 <dmwit> erus`: Wine works flawlessly for all the games I play.
11:12:30 <dmwit> erus`: (Did you know you can run Steam under Wine? =)
11:12:48 <erus`> yeah but last time i tried it wasnt ideal
11:12:57 <erus`> also drivers
11:12:59 <dmwit> erus`: Check out your game(s) at the Wine appdb and see what it says.
11:13:13 <dmwit> Drivers? What kind of card are you worried about?
11:13:17 * elliott finds Linux drivers better than Windows ones in general.
11:13:23 <erus`> dmwit: it doesnt have skyrim in there yet
11:13:28 <elliott> Unless you have a winmodem, in which case you have two problems, but I think we're past those days now.
11:13:55 <erus`> wireless card and ati hd 5670 or something
11:13:57 <dmwit> erus`: mmm, yeah, the very newest games take a little while to become supported
11:14:13 <elliott> (I thought Skyrim wasn't even out yet.)
11:14:15 <erus`> allthough im on a wired connection now
11:14:33 <dmwit> Wireless can sometimes be a pain (though that's improved a lot in the last two years). And yeah, nvidia is better about Linux support than ATI is.
11:16:44 <Clint> if i want to pretty-print a list of pathnames as a directory tree, do i want to use some kind of trie library?
11:17:21 <dmwit> How about Data.Tree?
11:17:31 <dmwit> :t Data.Tree.drawTree
11:17:32 <lambdabot> Tree String -> String
11:17:49 <elliott> Tries certainly aren't related.
11:17:52 <elliott> I don't think.
11:17:58 <elliott> Hmm, well maybe.
11:18:12 <dmwit> Tries are certainly related.
11:18:28 <dmwit> It's just Trie String, not Trie Char. =)
11:18:31 <elliott> Right.
11:24:10 <ader111> Does it make sense to generalize a special case of enumeratee that sends EOF when it gets it and passes EOF when it is done. This, I guess, can simplify the type for a lot of cases to become Step aIn m b -> Iteratee aOut m  b
11:29:20 <ader111> hello
11:30:58 <Clint> dmwit: i'll give it a shot, thanks
11:34:29 <kmc> what's the best way to convert a Rational to an ASCII decimal string?
11:34:32 <kmc> without losing precision
11:35:10 <kmc> @hoogle Rational -> String
11:35:10 <lambdabot> Prelude show :: Show a => a -> String
11:35:11 <lambdabot> Text.Show show :: Show a => a -> String
11:35:11 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
11:35:14 <kmc> ;P
11:35:22 <mrsolo> is there anybook on haskell 2010? or some detail discussions rather than the report itself?
11:35:28 <parcs> > show (5 % 7)
11:35:29 <lambdabot>   "5 % 7"
11:35:36 <kmc> mrsolo, it is very similar to Haskell 98
11:35:46 <parcs> > show (fromRational $ 5 % 7)
11:35:47 <lambdabot>   "0.7142857142857143"
11:35:51 <ader111> can anyone help, I jus want to make sure i am not missing somethting
11:37:03 <mrsolo> kmc, ya i like to know the minor details... just tried out ghc 7.x  it gave me deprecated warning all over the place :-)
11:37:04 <kmc> i'd rather not touch floating point
11:37:18 <kmc> mrsolo, that's probably a libraries thing, not Haskell 98 vs Haskell 2010
11:37:50 <kmc> http://www.haskell.org/pipermail/haskell/2009-November/021750.html has the list of extensions
11:38:25 <kmc> i'm outputting gcode, which uses decimal numbers both for positions and for discrete things like commands
11:38:43 <kmc> so e.g. command 33 is spindle-synchronized motion and 33.1 is rigid tapping
11:39:18 <kmc> i think it's okay because the implementation will round command numbers to the nearest 0.0001
11:39:28 <mrsolo> kmc thanks!
11:39:35 <kmc> by the way, yes, this is insane
11:41:11 <copumpkin> > any (>2) [1,1.10..2]
11:41:12 <lambdabot>   True
11:41:18 <copumpkin> :D
11:54:11 <Quantumplation> matthiasgorgens, you around?
11:54:58 <dmwit> kmc: "without losing precision"?
11:55:11 <dmwit> kmc: Most rationals cannot be represented precisely by a finite decimal representation.
11:56:48 <quicksilver> I assume kmc means "at a precision of my choice"
11:56:55 <dmwit> kmc: Convert to CReal.
11:57:02 <quicksilver> which is an interesting question, actually.
11:57:11 <quicksilver> yes, I was going to suggest that althuogh won't that be fairly slow?
11:57:24 <quicksilver> :t showCReal
11:57:25 <ben_m> Greetings everyone! I'm trying to parse a sentece with Parsec. I have (simplified), these definitions: sentence = noun >> verb; noun = string "I"; verb = string "go". However, I get an error "No instance for (Stream s0 m0 Char) arising from a use of `string'"
11:57:25 <lambdabot> Int -> CReal -> String
11:57:34 <parcs> > show (fromRational (5 % 7) :: CReal)
11:57:35 <lambdabot>   "0.7142857142857142857142857142857142857143"
11:57:36 <dmwit> Alternatively, multiply by 10^precision and round.
11:57:48 <dmwit> > show (floor (5%7 * 10^32))
11:57:49 <lambdabot>   "71428571428571428571428571428571"
11:57:50 <quicksilver> > showCReal 80 (fromRational (5%7))
11:57:50 <lambdabot>   "0.714285714285714285714285714285714285714285714285714285714285714285714285...
11:57:56 <parcs> > showCReal (301 % 10) (fromRational (5 % 7))
11:57:57 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:57:57 <lambdabot>         against inferred type ...
11:58:14 <parcs> > showCReal 10 (fromRational (301 % 10))
11:58:15 <lambdabot>   "30.1"
11:58:31 <parcs> luks gud
11:58:42 <kmc> yeah, I meant "at a precision of choice"
11:58:46 <kmc> (but was not at all clear about that)
11:58:46 <parcs> > showCReal 10 (fromRational (301 % 1000))
11:58:47 <lambdabot>   "0.301"
11:58:57 * hackagebot Hipmunk 5.2.0.4 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.4 (FelipeLessa)
11:59:02 <kmc> however in practice I will choose a precision less than whatever Double's is, so whatever
11:59:06 <quicksilver> kmc: multiply by 10^precision and round, I think.
11:59:09 <dmwit> kmc: So, yeah, I would suggest either using CReal, or multiplying and adding a decimal point in manual.
11:59:13 <kmc> cool, going via CReal is actually what i want
11:59:34 <kmc> i was worried about situations where I end up outputting G33.1000000007
11:59:40 <dmwit> heh
11:59:43 <kmc> and the g-code interpreter doesn't know about that command
11:59:49 <kmc> but like i said, it's supposed to round, so whatever
12:00:15 <Quantumplation> can I add type qualifiers for an instance? (implementing show on my generic type, need to have the type parameter also implement show)
12:00:22 <kmc> sure
12:00:26 <parcs> what library provides constructive reals?
12:00:30 <kmc> instance (Show a) => Show (Foo a) where ...
12:00:34 <kmc> parcs, 'numbers' and 'HERA'
12:00:36 <DukeDave> Hi all, what's a good way to "extend" the functionality of a type; so I have a Graph[1], and I'd like to store some extra information about the graph, but still be able to call the functions which reference Graph (without doing something like "graphFunction (getGraph anExtendedGraph)"
12:00:37 <DukeDave> [1] http://hackage.haskell.org/packages/archive/graph-wrapper/0.2.4/doc/html/Data-Graph-Wrapper.html
12:01:07 <schell> is there a path trick when using cabal to install libraries? i'm trying to install portaudio, which depends on c2hs > 0.15 … when I install c2hs (0.16) with cabal it doesn't seem to recognize it
12:01:09 <dmwit> DukeDave: If the graph-manipulating functions weren't declared to be part of a class, you're out of luck.
12:01:18 <kmc> DukeDave, you should probably just do the thing you don't want to do
12:01:19 <kmc> sorry
12:01:24 <DukeDave> dmwit: D'oh
12:01:30 <DukeDave> kmc: Ah
12:01:33 <dmwit> schell: Yes, there's a local and global package database.
12:01:40 <DukeDave> Does what I'm trying to do have a bad smell?
12:01:43 <dmwit> schell: ghc-pkg list c2hs will tell you which it's installed in.
12:01:50 <schell> cool
12:01:53 <dmwit> DukeDave: No.
12:01:53 <DukeDave> Or is this a known problem
12:02:03 <schell> then i just tell cabal which one to look in?
12:02:05 <kmc> DukeDave, not in particular, you might could work around it depending on context
12:02:19 <dmwit> schell: mmm... not quite =)
12:02:37 <DukeDave> My other thought was 'hiding' the Graph inside my new type, and then re-exposing all the functionality, but that seems like a lot of boilerplate..
12:02:39 <dmwit> schell: The default is for cabal to install everything locally.
12:02:58 <dmwit> schell: So we should see some more details on what went wrong.
12:03:17 <dmwit> schell: Show us your ghc-pkg list c2hs output, and the exact command you're trying to use to install portaudio (and how it fails).
12:03:20 <dmwit> ?hpaste
12:03:20 <lambdabot> Haskell pastebin: http://hpaste.org/
12:03:23 <quicksilver> DukeDave: what you're describing is somewhat related to the "expression problem"
12:03:24 <schell> looks like it did it in both (i'm on a mac) it installed in /Library/blah… and /Users/me/.ghc/blah...
12:03:33 <schell> [~] ➔ ghc-pkg list c2hs
12:03:40 <quicksilver> DukeDave: which, basically, is about how hard it is to write code which can be extended at both ends.
12:04:29 <DukeDave> quicksilver: Ah, I hadn't heard of that term
12:04:46 <frerich_> Is System.Console.GetOpt the standard way to handle command line options, or is there maybe a 'higher level' library available which not only does the parsing but also handles stuff like 'this argument is required' or 'if this argument is not given, default to XYZ' or maybe even 'if this argument is given, then that other argument must be given as well'?
12:04:52 <quicksilver> DukeDave: you can hope the library you are using was written polymorphically in the first place; you can attach data 'externally' such as in (Graph,ExtraStuff) or (Graph, Map VertexID ExtraStuff), or you can build a custom type which wraps graphs and re-exports everything.
12:04:58 <schell> sorry - my irc freaked
12:05:00 <kmc> frerich_, http://hackage.haskell.org/package/cmdargs is great
12:05:17 <kmc> http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm
12:05:18 <dmwit> schell: Please don't paste in-channel; use hpaste.org instead.
12:05:29 <schell> sorry - no prob
12:05:32 <dmwit> schell: (I know you didn't yet violate that rule, but it looked like you were about to. =)
12:05:41 <mdmkolbe> What is a good/commonly-used library for generic programming?  I'm familiar with SYB which has the advantage of being easy to use (just add "deriving" clauses), but it is widely regarded as slow.  I haven't kept track GP in Haskell.  I know there are a lot of options, but I'm wondering which libraries have established themselves as "winners".
12:05:52 <schell> i was about to ;)
12:06:08 <quicksilver> mdmkolbe: there is another new option in GHC 7.2 :)
12:06:18 <dreixel> mdmkolbe: nowadays I recommend http://www.haskell.org/haskellwiki/Generics
12:06:36 <schell> http://pastebin.com/bhvJ0CeE
12:06:38 <quicksilver> mdmkolbe: the one dreixel just linked, yes.
12:06:38 <mauke> The paste bhvJ0CeE has been copied to http://hpaste.org/52588
12:07:25 <frerich_> kmc: Wow, CmdArgs.Implicit looks very nice, like a DSL specifically for declaring the valid command line invocations. Thanks for pointing this out!
12:07:49 <kmc> the Implicit stuff is weird hax though
12:07:59 <kmc> but yeah it's useful
12:08:04 <frerich_> It looks very concise
12:08:06 <quicksilver> doesn't cmdargs have that hideous impure bit?
12:08:16 <kmc> yeah, the Implicit module does
12:08:17 <DukeDave> quicksilver: Hmm, I've actually got something very much like the "attach data 'externally'" pattern already, and I've found the following problem: It's all to tempting to modify one structure on its own, and then write some 'synchronisation' code to keep everything in check. I posted an example here a while back: http://hpaste.org/50899
12:08:19 <dmwit> schell: That output says c2hs is not installed at all.
12:08:21 <kmc> and iirc some ghc optimizations can break it
12:08:30 <schell> well shoot
12:08:30 <kmc> the Explicit module is only a bit more verbose and doesn't make me feel icky
12:08:32 <mdmkolbe> quicksilver, dreixel: I'll have to look into that.  How well does it perform?  Is this the clear winner for the future?
12:08:32 <dmwit> schell: What exact command did you run that made you think c2hs was installed?
12:08:35 <kmc> but use whichever you like :)
12:08:35 <elliott> ByteArray#s are garbage-collected, right? Or at least I can't find a free operation.
12:08:41 <frerich_> Uh-oh. Hacks? Impure? Optimizations can break? Maybe I shouldn't use Implicit after all...
12:08:41 <schell> cabal install c2hs
12:08:46 * frerich_ looks at explicit then
12:08:57 <dmwit> schell: ...well, it didn't work. Maybe paste the output from cabal install c2hs?
12:09:00 <elliott> frerich_: Apparently it doesn't actually break.
12:09:02 <schell> saw a bunch of output and a confirmation
12:09:05 <schell> oh god
12:09:08 <elliott> frerich_: But GHC updates tend to break the Implicit module itself.
12:09:17 <kmc> i mean, it has some function which is like  (a -> Annotation -> a)
12:09:19 <schell> it's so much output - i'm pretty sure it maxed out my terminal
12:09:24 <kmc> and then some backdoor side channel to recover the annotation from that 'a'
12:09:25 <dmwit> schell: It should be less the second time.
12:09:28 <kmc> so yeah, weird hax
12:09:30 <schell> k
12:09:36 <dmwit> schell: Since presumably it succeeded in installing at least some of the dependencies.
12:09:39 <quicksilver> DukeDave: I don't have much to say except "yes, that's the kind of problem you can get". Obviously good engineering practice is to structure your code with building blocks which each preserve your invariants.
12:09:41 <elliott> kmc: It is impure and gross, but I gather there's no way to actually make it not work from outside the Implicit module.
12:09:54 <quicksilver> DukeDave:
12:10:07 <quicksilver> DukeDave: this kind of comes up quite often in complex programs.
12:10:17 <schell> dimwit: lots and lots of text reloc msgs
12:10:30 <quicksilver> (in any language, although in other languages the lack of type system makes it easier to ignore the problem and make hideous runtime errors ;)
12:10:43 <dreixel> mdmkolbe: I'm pretty certain it performs much better than syb
12:11:10 <dmwit> schell: Try something like "cabal install c2hs 2>&1 | xclip" if it's still maxing out your terminal's scrollback.
12:11:11 <dreixel> i'm not entirely sure it performs as good as type-specific functions. But it should even be possible to make it so.
12:11:33 <dreixel> also depends on what you want to do, though
12:11:42 <DukeDave> quicksilver: Yeah, I'm very conscious of the potential for some very awkward bugs to creep in (in fact, one has already emerged)
12:11:49 <dreixel> if it's traversals of a big AST with some specific cases every now and then, syb might be easier.
12:11:57 <dreixel> for about anything else, the new generics framework should be better.
12:12:43 <ben_m> How do I parse a word with parsec? Instead of char 'f' >> char 'o' >> char 'o'?
12:12:57 <quicksilver> dreixel: it appears to provide a good answer to "how do I generate a sensible intermediate form of my datastructure before serialising to semi-structured data like JSON or XML
12:13:03 <mdmkolbe> dreixel: traversals are what I usually think of, what are examples of "anything else"?
12:13:06 <quicksilver> ben_m: string "foo"
12:13:27 <ben_m> quicksilver, No instance for (Stream s0 m0 Char)
12:13:36 <dreixel> mdmkolbe: well, serialization, for instance.
12:13:46 <schell> dmwit: http://pastebin.com/4UBe8rny - with the "ld: warning" stuff taken out
12:13:48 <quicksilver> ben_m: I don't understand what that means, but I know string "foo" is right ;)
12:13:48 <mauke> The paste 4UBe8rny has been copied to http://hpaste.org/52589
12:13:53 <quicksilver> ben_m: something else must be wrong.
12:14:00 <ben_m> I see.
12:14:01 <schell> dmwith: it's about 88k lines of ld warnings
12:14:38 <dmwit> schell: Uh... oh right. c2hs is an executable only
12:14:49 <dmwit> schell: So, the solution is to update your PATH.
12:14:56 <schell> ah, i see
12:15:06 <schell> add /Users/schellscivally/Library/Haskell/ghc-7.0.3/lib/c2hs-0.16.3/bin to my path?
12:15:10 <dmwit> schell: Sorry for the wild goose chase.
12:15:11 <dmwit> yeah
12:15:14 <schell> or symlink c2hs?
12:15:19 <quicksilver> ben_m: Streams don't normally pop up in user error message in parsec
12:15:19 <dmwit> wait
12:15:23 <schell> no, thanks - i wouldn't have figured that out
12:15:24 <quicksilver> ben_m: perhaps you can paste your code?
12:15:28 <ben_m> Sure
12:15:49 <dmwit> I mean, I guess that's the right thing to add to your path. But it's super weird.
12:15:50 <ben_m> quicksilver, http://pastie.org/private/kdms1loptcflrfb1l3xsq
12:15:58 <dmwit> Have you messed with your .cabal/config a lot?
12:16:04 <schell> no, not at all
12:16:16 <schell> i installed Haskell Platform and that's it
12:16:28 * schell super noob
12:16:28 <dmwit> So weird. At least here, it installs all executables to the same bin (not some package-name-specific bin like it seems to be doing for you).
12:16:42 <schell> maybe i should re-install?
12:16:46 <dmwit> Anyway, take a look at that directory. If the c2hs executable is in there, then yeah, add that to your path.
12:17:16 <dmwit> Be sure to remember to export your modified path before continuing. =)
12:18:07 <dmwit> Is there any way to guide instance selection in GHC? Something like "default", but for my own class?
12:18:25 <dmwit> (Just another attempt to solve the question I just posted on StackOverflow.)
12:18:49 <mysticc> is there something else similar to sqlite but nonrel for which I dont need to run any server ??
12:19:03 <Dybber> Do I have to be approved in some way, to post messages to Haskell-Cafe? I just got the response "You are not allowed to post to this mailing list, and your message has been automatically rejected"
12:19:22 <dmwit> Join the mailing list.
12:19:33 <ben_m> quicksilver, sorry, my internet is very unstable right now. Did you say anything?
12:19:41 <dmwit> (Note that joining the mailing list does not necessarily imply receiving mail from the list.)
12:19:53 <quicksilver> ben_m: your module loads perfectly under Parsec 2
12:20:01 <ben_m> Weird.
12:20:07 <quicksilver> ben_m: unfortunately I don't have parsec 3 on this machine.
12:20:22 <quicksilver> but it's supposed to be backwards compatible and your example is pretty simple.
12:20:29 <dmwit> mysticc: I think happstack has some persistence modules.
12:20:32 <quicksilver> ben_m: can you paste the exact error message in full?
12:20:32 <Dybber> dmwit: And not the other way around either I guess, as I have been receiving it for a couple of years now, but never send anything before.
12:20:35 <ben_m> sure
12:20:39 <erus`> can you turn the GC off for a period of time ?
12:20:43 <quicksilver> mysticc: check out acid-state
12:20:54 <dmwit> Dybber: Compare the email address you're receiving at and the email address you're sending from, perhaps.
12:21:03 <ben_m> quicksilver, http://pastie.org/private/56e8vxlh2e2uod3belujwa
12:21:06 <dmwit> Dybber: Especially with services like gmail it's easy to get a mismatch there.
12:21:13 <schell> dmwit: awesome! looks like i got portaudio installed
12:21:18 <dmwit> schell: Great!
12:21:21 <desaiu> I'm trying to understand this: http://www.haskell.org/haskellwiki/Parametric_polymorphism
12:21:22 <schell> thanks
12:21:42 <desaiu> Can someone explain?
12:21:47 <tac-tics> desaiu: What don't you understand about it?
12:22:01 <tac-tics> desaiu: Do you know Java or C# at all?
12:22:05 <desaiu> No
12:22:16 <dmwit> That's a terrible explanation of parametric polymorphism.
12:22:18 <tac-tics> That makes things a little more difficult :)
12:22:21 <quicksilver> ben_m: look I googled it for you :)
12:22:22 <quicksilver> http://stackoverflow.com/questions/6723208/trivial-parsec-example-produces-a-type-error
12:22:33 <quicksilver> pretty weird though
12:22:35 <desaiu> I thought parametric polymorphism was that functions accept any type of value as their arguments
12:22:37 <ben_m> I tried googling obviously
12:22:46 <ben_m> Didn't find that site, let me read :D
12:22:54 <tac-tics> desaiu: Basically, lowercase letters in types are type variables.
12:23:02 <tac-tics> desaiu: You can replace them with any other type
12:23:10 <tac-tics> @type map
12:23:11 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:23:27 <tac-tics> @type map :: (Int -> b) -> [Int] -> b
12:23:28 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
12:23:29 <lambdabot>     In the expression: map :: (Int -> b) -> [Int] -> b
12:23:31 <desaiu> That is foreign to me
12:23:35 <ben_m> quicksilver, thanks a ton, it compiles now.
12:23:40 <tac-tics> bah
12:23:44 <desaiu> (a -> b) -> [a] -> [b] What is this?
12:23:56 <desaiu> a to be to a to b?
12:24:12 <quicksilver> ben_m: I think that might even be a GHC bug although I'm not sure
12:24:15 <desaiu> a tupe of a to b emits a list element of a and a list element of b
12:24:18 <tac-tics> @type map :: (Int -> Int) -> [Int] -> [Int]
12:24:20 <lambdabot> (Int -> Int) -> [Int] -> [Int]
12:24:25 <tac-tics> @type map :: (Int -> Float) -> [Int] -> [Float]
12:24:26 <lambdabot> lexical error at character '\FS'
12:24:38 <tac-tics> damnit lambdabot
12:24:43 <tac-tics> @type map :: (Int -> Float) -> [Int] -> [Float]
12:24:44 <lambdabot> (Int -> Float) -> [Int] -> [Float]
12:24:54 <desaiu> > a . b == a -> b
12:24:55 <lambdabot>   <no location info>: parse error on input `->'
12:25:04 <tac-tics> You see how changing a to Int and b to Float gives map a new type?
12:25:53 <desaiu> I gives a new type of [Int] -> [Float], right?
12:25:58 <desaiu> What does the arrow represent?
12:26:07 <tac-tics> The -> is a function
12:26:13 <tac-tics> A - > B is a function from A to B
12:26:45 <tac-tics> for example, (+1) is an Int -> Int
12:26:53 <Dybber> dmwit: Ugh, you where right. I had apparently subscribed with a different address than my primary. Thanks!
12:27:15 <tac-tics> (+) by itself is an Int -> Int -> Int
12:27:22 <tac-tics> which is a shorthand for Int -> (Int -> Int)
12:27:26 <desaiu> So the tuple (Int functioning on Float) is a function of a list of Int which performs its operations from the output of a list of Float?
12:28:29 <desaiu> That's what I think I see when reading (Int -> Float) -> [Int] -> [Float]
12:28:59 <mm_freak> desaiu: no tuples involved there
12:29:15 <mm_freak> it's a function of a function and a list and produces a list
12:29:42 <rwbarton> (Int -> Float) is the type of a function that has a parameter of type Int and outputs a value of type Float
12:30:29 <rwbarton> "a function of a list of Int which performs its operations from the output of a list of Float" looks like word salad to me.
12:30:31 <Cale> desaiu: A function of type (Int -> Float) -> [Int] -> [Float] will take as its parameters a function, and a list of Ints. The function must take an Int as its parameter and produce a Float.
12:30:54 <frerich_> What's a good way to submit patches to packages? I believe I found a bug in the documentation of CmdArgs and I'd like to submit a patch to fix it, but it's unclear to me whether I should mail it directly to the author or whether there's a bug tracker or the like.
12:31:32 <Saizan> depends on the package, does it have a homepage url?
12:32:00 <frerich_> Yes it does, good point, I'll go look there for more input.
12:32:07 <frerich_> So there is no 'standard' interface but it's per package?
12:32:14 <Cale> desaiu: This might be even more mindbending, or it might help, so I'll say it anyway: you can also think of this type as (Int -> Float) -> ([Int] -> [Float]), that is, a function of this type consumes a function of type Int -> Float, and produces a function [Int] -> [Float]
12:32:22 <Saizan> frerich_: yep
12:32:26 <mm_freak> frerich_: if all else fails, contact the maintainer or perhaps the original author
12:32:49 <Cale> desaiu: In fact, this view on it is the "real" one -- all functions in Haskell have exactly one parameter.
12:33:13 <Cale> desaiu: and those with more than one parameter are just producing other functions as their result :)
12:35:38 <dmwit> Hm, maybe this is calls for rank-2 types!
12:35:39 <dmwit> yay
12:36:11 <schell> if i wanted to compile portaudio on my own, from source are there any special cli args i need to supply? can i just type ghc --make PortAudio.hsc?
12:36:26 <dmwit> schell: cabal install did compile it
12:36:58 <dmwit> schell: If you want to build it without installing it, you can just type "cabal build" from inside the source directory.
12:37:01 <schell> dmwit: i know, but i think there must be some inconsistency between the version on hackage and the version on github
12:37:11 <dmwit> or maybe "cabal configure && cabal build" if you haven't configured yet.
12:37:27 <dmwit> schell: Oh, then just "cabal install" from within the git repository directory.
12:37:29 <dmwit> =)
12:37:41 <schell> ahh
12:37:42 <schell> okay
12:38:58 * hackagebot quicklz 1.5.0.9 - QuickLZ compression for ByteStrings  http://hackage.haskell.org/package/quicklz-1.5.0.9 (AustinSeipp)
12:39:44 <anandjeyahar> is there a command i can use in ghci to list the operations i can do on a type?
12:39:56 <dmwit> No.
12:40:00 <dmwit> You can use Hoogle, though.
12:40:04 <dmwit> ?hoogle Int -> String
12:40:05 <lambdabot> Prelude show :: Show a => a -> String
12:40:05 <lambdabot> Text.Show show :: Show a => a -> String
12:40:05 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
12:40:12 <frerich_> Saizan: Thanks for the home page tip, turns out there was a bug tracker linked from there. Filed a bug report, now lets hope it's not a luser error. :-)
12:40:29 <mysticc> @Hoogle liftIO
12:40:29 <lambdabot> Maybe you meant: google hoogle
12:40:43 <mysticc> :Hoogle liftIO
12:40:52 <mysticc> :i liftIO
12:40:57 <mysticc> :t liftIO
12:40:58 <lambdabot>     Ambiguous occurrence `liftIO'
12:40:58 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
12:40:58 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
12:41:05 <dmwit> mysticc: You had it right the first time, just use a lower-case h in hoogle
12:41:17 <mysticc> @hoogle liftIO
12:41:18 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
12:41:57 <anandjeyahar> so i can cabal install hoogle right?
12:42:48 <dmwit> Yes, though I think using the web interface is quite common, too.
12:43:34 <frerich_> Is 'Neil Mitchell' here sometimes?
12:44:05 <dmwit> Aww, rank two types can't be instances of type classes?
12:44:06 <DukeDave> @seen ndm
12:44:06 <lambdabot> Unknown command, try @list
12:44:07 <preflex>  ndm was last seen on #haskell 298 days, 35 minutes and 32 seconds ago, saying: if you don't, then there was a parse error
12:44:16 <mdmkolbe> Does Uniplate have a way to handle mutually recursive types?  E.g. An AST that have not just an Expr type, but Expr, Statement, Type, etc.
12:44:41 <monochrom> the parser error ate ndm :)
12:44:55 <Saizan> mdmkolbe: multiplate does
12:45:03 <DukeDave> frerich_: I think that's him ^
12:45:06 <edwardk> *nom*
12:45:31 <elliott> I really wonder why Data.Sequence doesn't expose its FingerTree.
12:45:35 <edwardk> yes ndm does show up every once in a while, but not often recently
12:46:00 <mm_freak> dmwit: you could wrap them in a newtype
12:48:18 <kmc> frerich_, i found a bug in CmdArgs and posted it on the bug tracker
12:48:28 <kmc> ndm fixed it and uploaded within a couple of days
12:48:33 <kmc> i was quite pleased :)
12:48:45 <angstrom> is there an alternative to `reverse . sort' when I want to sort a list decreasingly?
12:48:52 <kmc> :t sortBy
12:48:53 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:48:58 <kmc> :t sortBy (flip compare)
12:48:58 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:49:11 <kmc> > sortBy (flip compare) "is there an alternative to `reverse . sort' when I want to sort a list decreasingly?"
12:49:12 <lambdabot>   "ywwvvtttttttttssssssrrrrrrroooonnnnnllliiiihhgeeeeeeeeeedcaaaaaa`I?.'     ...
12:49:22 <angstrom> sweet :-)
12:49:30 <elliott> angstrom: You could use GHC.Exts.Down.
12:49:35 <elliott> (I have no idea why GHC.Exts.Down exists.)
12:50:32 <kmc> you can play lots of fun tricks with sortBy and compare
12:50:41 <kmc> > sortBy (comparing length `mappend` compare) (words "here is a list of words to sort first by length and then alphabetically")  -- thanks to Cale
12:50:42 <lambdabot>   ["a","by","is","of","to","and","here","list","sort","then","first","words",...
12:51:33 <kmc> that uses the Monoid instance for functions and for Ordering
12:51:50 <kmc> it's a good example of why you want to capture the Monoid abstraction in a library
12:52:13 <keep_learning> i am trying to compile a haskell program but i am getting Elliptic_prime.hs:2:8:
12:52:13 <keep_learning>     Could not find module `Random'
12:52:14 <keep_learning>     It is a member of the hidden package `haskell98-2.0.0.0'.
12:52:14 <keep_learning>     Use -v to see a list of the files searched for.
12:52:20 <edwardk> it looks even prettier with Data.Semigroup and <> for extra confusion
12:52:28 <keep_learning> Is Random is removed ?
12:52:32 <kmc> keep_learning, are you building with ghc --make?  what GHC version?
12:52:43 <kmc> the haskell98 package is hidden by default in recent ghc
12:52:51 <kmc> use:  ghc -package haskell98
12:52:51 <keep_learning> kmc, ghc-7.2.1
12:52:55 <kmc> or even ghc -XHaskell98
12:53:01 <kmc> (not sure about the latter)
12:53:09 <kmc> better would be to modify the program to use the more recent hierarchical modules
12:53:11 <kmc> e.g. System.Random
12:53:16 <kmc> (fsvo 'better')
12:54:03 <automatous> exit
12:54:12 <automatous> oops, disregard :)
12:59:43 <xil> hello, I'm wondering if someone could do me the favor of running my code to see if it works. It displays the Mandelbrot set. However, when I run it nothing happens and then my computer starts slowing down dramatically until I kill it. I'm wondering if anyone else can get it to work. I uses Gtk2HS
12:59:48 <hpaste> xil pasted “Mandelbrot” at http://hpaste.org/52590
12:59:56 <rwbarton> what could be more tempting!
13:01:24 <kmc> we need the glade file too, no?
13:01:30 <xil> oh whoops
13:02:45 <rwbarton> also, I guess, how are you compiling it?
13:02:46 <xil> uh....how do I get the glade file uploaded
13:03:05 <xil> rwbarton: interpreter. When I compile it it doesn't work even more
13:03:26 <rwbarton> oh
13:03:51 <rwbarton> Well in my experience this kind of program tends to work less well in the interpreter, I'd focus your efforts on getting it to work compiled first
13:05:10 <monochrom> do you add -threaded to the compile command? (you should)
13:05:14 <xil> here's a link to the glade file if anyone wants to try making it work while I experiment with compiling http://dl.dropbox.com/u/9533360/mandelbrot.glade
13:05:35 <xil> monochrom: I will, thanks. Haven't compiled yet so I can't say I'm doing it =P
13:05:35 <elliott> xil: What on earth is ONULL/INULL for?
13:05:39 <elliott> You never send them, and error out on receiving them.
13:05:50 <Robert_ha> Im having trouble with my trie. I want to retrieve the keys from it. (It is a trie with key-value pairs). Any sugestions? :)
13:06:18 <xil> elliott: not sure yet. I felt like putting it there. I'm pretty noob at message passing so I'm figuring things out as I go
13:06:47 <dmwit> Robert_ha: My suggestion is to give us more information.
13:06:56 <elliott> xil: Nah; remove it and add it if you really need it. It's ugly :-)
13:06:59 <Robert_ha> dmwit: What information do you want?
13:07:03 <elliott> xil: (And if you do need it, at least call it something other than "NULL".)
13:07:03 <dmwit> "It doesn't work." is too vague of a problem to solve.
13:07:09 <rwbarton> IPointNotFound
13:07:16 <copumpkin> Robert_ha: put yourself in our shoes, and ask yourself what you'd need to know to help yourself
13:07:37 <Robert_ha> Im guessing the type of the tree would help, let me get it for you..brb :P
13:07:49 <copumpkin> Robert_ha: or in other words, can you help me with my foot? it hurts
13:08:01 <dmwit> copumpkin: Cut it off. Then it won't hurt.
13:08:17 <Robert_ha> lol
13:08:31 <monochrom> xil: I want to confirm with you: you have 3 threads. are drawer and drawFunc the only 2 threads who will call Gtk2Hs actions?
13:09:06 <xil> compiled with "ghc -threaded --make Main.hs" and the window shows up, but nothing gets drawn except the black background and after 10 seconds or so my whole computer starts lagging
13:09:10 <aristid> dmwit: i don't think that's always true
13:09:25 <xil> monochrom: yes
13:09:26 <dmwit> xil: You cannot use gtk2hs with -threaded if you also call gtk2hs functions from multiple threads.
13:09:34 <xil> ah
13:09:34 <aristid> dmwit: AFAIK organs can hurt even if they are not physically present :)
13:09:53 <rferranti> true
13:09:58 <dmwit> aristid: I've filed a bug against $DEITY, thanks for the report.
13:10:11 <xil> dmwit: I'd love to not put those things in threads but I don't know how. There aren't any signals for me to latch on to for this sort of thing
13:10:14 <Robert_ha> The datatype is: data Trie a = TrieNode (Maybe a) [(Char, Trie a)]  deriving Show
13:10:29 <dmwit> xil: Use postGUIAsync or postGUISync.
13:10:40 <Robert_ha> I think its called a prefix tree?
13:10:49 <aristid> dmwit: $DEITY, the bash/perl god of ugly variable names?
13:10:52 <dmwit> Robert_ha: What have you tried?
13:10:59 <monochrom> use both -threaded and postGUI[A]Sync
13:11:47 <Robert_ha> dmwit: My first thought was to try and convert it into a list told me there is an easier way but he wont tell me
13:12:02 <rwbarton> xil: I'm not sure why you readTVarIO the pmap on line 74 and then write back the same value on line 77.
13:12:03 <keep_learning> i am trying to import Data.Binary on ghci but getting error .
13:12:14 <Robert_ha> dmwit: He told me I should be able to search through the tree via recursion and find the values and keys that way
13:12:20 <hpaste> monochrom annotated “Mandelbrot” with “Mandelbrot (annotation)” at http://hpaste.org/52590#a52591
13:12:22 <copumpkin> Robert_ha: you should indeed
13:12:55 <monochrom> there, xil, and add -threaded. I also have a gtk2hs example at http://www.vex.net/~trebla/haskell/gtk-interact.xhtml
13:13:03 <copumpkin> Robert_ha: you pick off the head of your string, look it up in the [(Char, Trie a)] bit, and then if you find it, search for the tail in the Trie a bit
13:13:08 <Robert_ha> It sounds good and all but it's hard for a beginner like me to implement it. Haskell is really different from languages like C and Java O_O
13:13:11 <hpaste> “Mukesh Tiwari” pasted “Data.Binary ” at http://hpaste.org/52592
13:13:40 <xil> rwbarton: are you sure it's the same value? I have a long explanation for why I thought that the TVar would fix my problem. It didn't but I just haven't removed it
13:13:42 <dmwit> Mukesh Tiwari: ghc-pkg expose binary
13:14:20 <abdallah> Is there any good implementation of strict haskell ?
13:14:35 <elliott> dmwit: Might becabal-dev.
13:14:39 <rwbarton> Well, something else might have stored another value in pmap in the meantime
13:14:44 <elliott> abdallah: DDC?
13:14:53 <elliott> It's not Haskell though.
13:14:58 <elliott> But it's similar in many ways.
13:15:17 <rwbarton> but "drawPoint p gc (x,y)
13:15:20 <xil> rwbarton: that's the only place I write to the TVar. But I thought that drawing to 'p' changes it, making it worthwhile to write it back
13:15:21 <rwbarton> " doesn't change the valut of p
13:15:23 <abdallah> elliott: thx, I'll have a look
13:15:24 <xil> ah
13:15:30 <rwbarton> nothing can change the value of p
13:15:33 <elliott> abdallah: It's not "usable" though.
13:15:43 <rwbarton> (except shadowing p with a new binding)
13:15:43 <elliott> abdallah: If you're looking for something "real-world".
13:16:28 <xil> rwbarton: basically I did that to make sure that a change to the Pixmap in the drawer function resulted in a change that would be seen when the drawFunc function tried to put the Pixmap on the DrawingWindow I supply
13:16:31 <abdallah> elliott: no, I was just asking just out of curiosity.
13:16:37 <elliott> OK.
13:17:35 <keep_learning> Any one please http://hpaste.org/52592
13:17:39 <rwbarton> xil: you can think of 'pmap' in main as itself like an IORef, or better some kind of IO array.
13:17:50 <dmwit> keep_learning: See my message to Mukesh Tiwari above.
13:18:19 <xil> rwbarton: so calling the GTK functions on it all reference the same Pixmap
13:18:41 <elliott> keep_learning: Are you using cabal-dev by any chance?
13:19:07 <keep_learning> elliott, no
13:19:13 <elliott> xil: You can know, at least, that a local variable "p" will never, ever change value.
13:19:20 <rwbarton> yes, you can see from the types, for instance, that drawPoint is not returning a new modified version of the Pixmap.
13:19:35 <elliott> xil: It might be a reference to a value, and what that reference references might change, but the variable itself will always hold the same reference.
13:19:38 <xil> elliott: yeah I see that now, didn't notice it when I wrote the thing
13:19:42 <elliott> Right.
13:20:22 <hpaste> “Mukesh Tiwari” annotated “Data.Binary ” with “Data.Binary  (annotation)” at http://hpaste.org/52592#a52593
13:20:25 <xil> rwbarton: gotcha
13:20:36 <rwbarton> If it did, you'd have code that looks like do { p <- readTVarIO pmap; ... ; p' <- drawPoint p gc (x, y); atomically $ writeTVar pmap p' }
13:20:48 <elliott> keep_learning: sudo
13:21:02 <rwbarton> or perhaps drawPoint might be a pure function in that case, so "let p' = drawPoint ..."
13:21:07 <schell> how do i tell ghc to use a certain library if i have more than one version installed?
13:21:37 <keep_learning> elliott, no output
13:21:42 <monochrom> dmwit: because mainGUI is a blocking FFI safe call, one is forced to -threaded if one ever forkIO's.
13:21:45 <tsousa> i am reading LYAH and it is implementing search trees, but i dont understand what Node does. can someone explain me?
13:22:04 <elliott> keep_learning: Good.
13:22:34 <monochrom> or rather s/mainGUI is/mainGUI boils down to/
13:22:47 <engla> tsousa: link to page/section?
13:23:17 <monochrom> there is indeed much misinformation about gtk2hs multithreading because 0.11 and 0.12 are different.
13:23:19 <hpaste> “Mukesh Tiwari” annotated “Data.Binary ” with “Data.Binary  (annotation) (annotation)” at http://hpaste.org/52592#a52594
13:23:40 <monochrom> and all blog articles are stuck at 0.11
13:23:41 <keep_learning> elliott, so do i need to install it ?
13:23:45 <tsousa> engla, http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures tree section
13:23:55 <elliott> keep_learning: Just try using it again.
13:24:08 <sipa> Node "does" nothing, it is a data constructor (i assume)
13:24:10 <elliott> Oh, /me looks at latest paste.
13:24:15 <elliott> keep_learning: Yes, just try using it again.
13:24:58 <abdallah> ??
13:24:59 <engla> tsousa: Node has the same role in the tree that Cons has in the linked list
13:25:01 <keep_learning> elliott, thank you . Now its  working :)
13:25:29 <tsousa> engla, i dont know what Cons does
13:25:42 <elliott> keep_learning: np
13:25:43 <sipa> tsousa: what other languages do you know?
13:25:56 <tsousa> sipa, Python
13:27:04 <engla> tsousa: the tree is a recursive data type.. and every piece of it is either a node or an empty tree. Each node carries a value and "links" to two child trees. So each node is a value-labeled point in the tree illustration
13:27:20 <nh2> what is the state of scion with ghc 7?
13:27:33 <tsousa> engla, yes that i know
13:27:42 <danr> nh2: I want to know as well. I cannot get the lookup identifier to work
13:28:16 <nh2> there is a ghc 7 branch here: https://github.com/hvr/scion but I don't know if it is the latest code
13:29:57 <tsousa> engla, but what does this data definition means http://dpaste.com/633823/
13:31:07 <dmwit> tsousa: It means a tree is either empty (EmptyTree), or it's a node with an element and two subtrees (Node a (Tree a) (Tree a)).
13:31:52 <dmwit> Moreover, it asks the compiler to automatically generate functions to convert to and from String, as well as compare two trees for equality.
13:31:59 <tsousa> dmwit, but how Haskell know what is a Tree because it is defined?
13:32:15 <dmwit> tsousa: Haskell knows what a Tree is because that line defines what a Tree is.
13:32:16 <engla> tsousa: you should read the text from the link you posted. I don't think I can explain it better than that sorry. Start with the list example
13:40:26 <MarkDBlackwell> <blown away by the Ordering monoid>
13:42:36 <Cale> MarkDBlackwell: It's nice, isn't it?
13:42:58 <Cale> MarkDBlackwell: with the lifting instance for functions, you get a nice way to combine comparator functions
13:43:09 <nh2> anyone using Yi?
13:43:29 <Cale> > sortBy (comparing length ++ compare) (words "here is a bunch of words to sort by length and then alphabetically")
13:43:30 <lambdabot>   ["a","by","is","of","to","and","here","sort","then","bunch","words","length...
13:43:45 <Cale> > sortBy (flip (comparing length) ++ compare) (words "here is a bunch of words to sort by length and then alphabetically")
13:43:47 <lambdabot>   ["alphabetically","length","bunch","words","here","sort","then","and","by",...
13:44:01 <MarkDBlackwell> Cale, Yes. elegant to use. Yes, I see combining in LYAH. :) Two thought questions: as the Functor laws aren't the only laws (there are also the Monoid laws; I seem to detect a pattern), why doesn't Haskell enforce the laws? Is it because it would have to check every value?
13:44:04 <tac-tics> nh2: I don't think Yi is currently being actively developed
13:44:32 <MarkDBlackwell> Cale, hm, interesting.
13:44:34 <Cale> MarkDBlackwell: Yeah, kinda. Laws like that in general aren't possible to automatically prove.
13:45:06 <MarkDBlackwell> Cale, when you say prove, is that coterminous with enforcing in program execution?
13:45:07 <nh2> tac-tics: last commit is from yesterday, but indeed not much activity in the last months
13:45:19 <Cale> MarkDBlackwell: Well, enforcing statically.
13:45:27 <tac-tics> nh2: Basically, Yi is just there when you feel like writing a research paper about a monadic text editor
13:45:39 <ksf> A high-level language is one that lets you gloss over irrelevant detail. A low-level language is one that allows you to specify relevant detail.
13:45:41 <tac-tics> nh2: There have been a few boughts of activity, but it's not a sustained project
13:46:11 * ksf , therefore, wants inline llvm assembly.
13:46:21 <Cale> MarkDBlackwell: I suppose you could make it check them at runtime, but that's not really great -- it'll just be a (rather major) performance hit, and the only option you have at that point is to crash the program if the law fails, which isn't so nice.
13:46:27 <MarkDBlackwell> Cale, meaning, 'can`t be notated', or, 'can`t be checked at compile time'?
13:46:28 <nh2> tac-tics: can it embed compile error messages into the code (like emacs with scion)? That's the main thing I need
13:46:46 <MarkDBlackwell> Cale, I hear you.
13:46:58 <tac-tics> nh2: I couldn't tell you. I toyed around with it years ago.
13:47:06 <tac-tics> nh2: And half the time, the build was broken :/
13:47:14 <k0ral> dcoutts_: ping ?
13:47:20 <Cale> So if you want to check it at compile time, yeah, you kinda have infinitely many values to test in the general case, though that's not how these things are usually verified -- typically, they're proved by combining properties that are known about other things.
13:47:35 <Cale> Systems like Coq and Agda can do that.
13:48:01 <Cale> Eventually, Haskell might be able to (in fact, it might be able to right now, at the cost of a lot of hassle)
13:48:03 <nh2> tac-tics: these days, cabal install yi just works, I'm amazed by that.
13:48:34 <Cale> But requiring the programmer to provide proofs for the laws is often really inconvenient. :)
13:48:44 <MarkDBlackwell> Thought No. 2: LYAH is pretty highly mathematical in places; are there tutorials that explain Haskell (heretically) by example use cases, or non-mathematically?
13:49:01 * tac-tics stayed up until 4am last night providng that x `mod` y is, in fact, a total function
13:49:08 <tac-tics> (for nonzero y)
13:49:20 <MarkDBlackwell> Cale thanks. :)
13:49:21 <dcoutts_> k0ral: mm?
13:49:25 <KirinDave> MarkDBlackwell: My wife is reading LYAH. She's never done more than basic algebra in her life. She finds it approachable
13:49:42 <KirinDave> I even caught her playing with GHCi to do the bills the other night.
13:49:48 <burp> can I use Foreign.Marshal.Alloc.free on an mallocArray allocated array?
13:49:49 <Cale> Well, there's Real World Haskell... I don't know if that's very mathematical, but to be honest, LYAH didn't seem all that mathematical to me. (I don't count though, because I have a mathematics degree)
13:49:57 <KirinDave> MarkDBlackwell: So I dunno if it's mathmatical to a degree that turns people off.
13:50:07 <k0ral> dcoutts_: I'm fiddling around with the attributes and signal implementations of glib
13:50:07 <monochrom> if LYAH is highly mathematical, kindergarten is postdoc math
13:50:10 <burp> the documentation says, "Free a block of memory that was allocated with malloc, mallocBytes, realloc, reallocBytes, Foreign.Marshal.Utils.new or any of the newX functions in Foreign.Marshal.Array or Foreign.C.String."
13:50:16 <burp> and if you ask me, that excludes mallocArray
13:50:39 <dcoutts_> k0ral: ah yes
13:50:39 <k0ral> dcoutts_: something I can't get is: where is connectGeneric called ?
13:50:46 <MarkDBlackwell> KirinDave, at the risk of making myself a pariah, I mean for myself (!) The applicative functors section of LYAH is like a stream of blah to me, although I could grasp usage examples. :)
13:50:54 <dcoutts_> k0ral: generated code
13:51:04 <KirinDave> MarkDBlackwell: Did you just read that chapter in isolation?
13:51:17 <k0ral> dcoutts_: where is the *generating* code ?
13:51:28 <desaiu> And I'm back! Cale, I wasn't ditching you, needed to take a nap, still tired though :)
13:51:34 <KirinDave> MarkDBlackwell: because that's the only description of applicative functors that I'd say is natural.
13:51:42 <Cale> desaiu: no problem
13:52:01 <dcoutts_> k0ral: the Signals.hs (e.g. in gtk) is generated by the callbackGen from gtk2hs-buildtools, in the tools/ dir in the source repo
13:52:06 <KirinDave> MarkDBlackwell: LYAH is meant to be read sorta left-to-right across the chapters. <$> and >>= are approached as an "aha" moment built on top of actually writing code without them.
13:52:09 <Cale> MarkDBlackwell: Do you already understand monads?
13:52:11 <dcoutts_> k0ral: erm, Signals.chs
13:52:11 <KirinDave> MarkDBlackwell: It's not meant to be read in isolation.
13:52:21 <MarkDBlackwell> KirinDave, no, inexplicably, from the beginning, but I'm not a natural INTJ mathematician, is the way I explain it.
13:52:33 <KirinDave> MarkDBlackwell: Neither am I.
13:52:47 <Cale> MarkDBlackwell: (if you do, then it's kinda easy to explain what applicative functors are about)
13:52:48 <KirinDave> MarkDBlackwell: But seriously, LYAH is the best tutorial we have on all of these.
13:52:59 <desaiu> Cale: I don't understand "all functions in Haskell have exactly one parameter."
13:53:06 <MarkDBlackwell> Cale, Monoids seem, at the beginning of their LYAH explanation, like group theory, so, easy.
13:53:08 <Cale> desaiu: Okay, let's have a look :)
13:53:10 <monochrom> perhaps it is just because "<*>" is not English
13:53:15 <desaiu> Yay!
13:53:25 <KirinDave> desaiu: It is true, if weird.
13:53:38 <Cale> > let f x y = x + y in map (f 4) [10,20,30,40]
13:53:39 <lambdabot>   [14,24,34,44]
13:53:46 <monochrom> but then it is the same as saying 漢 is highly mathematical
13:54:03 <Cale> Here, 'map' is used to apply the function (f 4) to each element of the list [10,20,30,40]
13:54:05 <KirinDave> @type
13:54:06 <lambdabot> <no location info>: not an expression: `'
13:54:07 <KirinDave> Does that work?
13:54:10 <KirinDave> @type (+)
13:54:11 <lambdabot> forall a. (Num a) => a -> a -> a
13:54:34 <KirinDave> desaiu: It's a function that takes a number, yields up a function that takes another number, and finally yields up their sum
13:54:47 <Cale> f may look like it takes two parameters, but it really takes x, and gives another function, which eats y, and finally gives the sum x + y
13:54:59 <KirinDave> desaiu: Thus (+1) has type a -> a.
13:55:05 <copumpkin> Num a => a -> a
13:55:15 <KirinDave> True.
13:55:30 <MarkDBlackwell> Cale, KirinDave, I think the Haskell is probably easy, just there are different ways of explaining and 'verbosing' about the pattern, to different kinds of minds. After this, I am going to read another tutorial, so I was wondering if there is an example-based one. Actually, contrarily, I was planning to read, 'A Gentle Introduction.'
13:55:56 <KirinDave> MarkDBlackwell: I do not know of a better tutorial on applicative functors and monads than LYAH from the beginning
13:56:14 <dmwit> MarkDBlackwell: I strongly recommend "You Could Have Invented Monads (and Maybe You Already Have)"
13:56:26 <desaiu> KirinDave: yields up a function, which function?
13:56:29 <MarkDBlackwell> KirinDave, thanks.
13:56:30 <monochrom> A Gentle Introduction doesn't have Applicative. old age.
13:56:30 <Rmx> or wikipedia page :p
13:56:38 <dmwit> desaiu: The function that adds one to things.
13:56:38 <desaiu> Cale: and gives another function, which function?
13:56:41 <KirinDave> desaiu: So let's say (+)
13:56:42 <elliott> MarkDBlackwell: Please note that the kind of gentleness that the Gentle Introduction offers is likely to make most sense to you if you look to, e.g. sandpaper as a paragon of gentleness.
13:56:49 <MarkDBlackwell> dmwit, thank you for the suggestion; I'll look at it. :)
13:56:59 <KirinDave> desaiu: (+4) is like saying 4 + _ = ...
13:57:07 <elliott> KirinDave: No it's not.
13:57:08 <Cale> MarkDBlackwell: A gentle intro is good, but it's old (though probably not really out of date, it doesn't cover any newer abstractions), and its name is somewhat deceptive. It's only gentle in comparison with just reading the Haskell Report.
13:57:24 <Cale> desaiu: The function \y -> x + y
13:57:24 <desaiu> > :type +
13:57:24 <lambdabot>   <no location info>: parse error on input `:'
13:57:26 <KirinDave> elliott: Howso?
13:57:28 <elliott> :t (+)
13:57:29 <lambdabot> forall a. (Num a) => a -> a -> a
13:57:29 <desaiu> >type +
13:57:30 <KirinDave> desaiu: In parenthesis
13:57:36 <MarkDBlackwell> elliott, I've heard it described as abrasive or like a barracuda, but I don't know how. Rude?
13:57:38 <Cale> desaiu: So f 4 is equal to \y -> 4 + y
13:57:44 <elliott> KirinDave: Because (+4) is nothing like saying 4 + _ = ...
13:57:45 <dmwit> (+) :: Num a => a -> (a -> a)
13:57:52 <elliott> KirinDave: I'd have to ask you how you think it is to tell you how it isn't, though.
13:57:58 <desaiu> o_O
13:58:01 <elliott> MarkDBlackwell: It kind of assumes you know ML.
13:58:05 <monochrom> I don't find A Gentle Introduction sandpaper-like. it's just idea, examples, idea, examples... how can that be sandpaper?
13:58:10 <desaiu> What is -> in that type definition
13:58:17 <elliott> desaiu: function
13:58:24 <dmwit> MarkDBlackwell: I found the Gentle Introduction quite nice when I was reading it.
13:58:25 <Cale> Oh, what I wrote is not a type definition
13:58:27 <elliott> desaiu: a -> b is a function from a to b; a -> (a -> a) is a function from a to (a function from a to a).
13:58:28 <desaiu> so a is a function of a of a of a, etc.
13:58:28 <KirinDave> elliott: Actually, in Scala (4 + _) is the syntax for \x -> 4 + x :)
13:58:29 <dmwit> Some people say that it moves a bit fast.
13:58:34 <elliott> desaiu: a -> a -> a === a -> (a -> a)
13:58:34 <desaiu> It doesn't say what that function is, I don't think
13:58:35 <monochrom> instead, verbose philosophical tutorials are the sandpaper. all the mincing words obstruct progress
13:58:37 <elliott> KirinDave: oh
13:58:42 <MarkDBlackwell> Cale, thanks, there, I was not looking for gentleness, but for a rigorous syntax and semantics description, like for a programmer.
13:58:48 <KirinDave> elliott: I kinda like the "cut" notation for lambdas.
13:58:52 <MarkDBlackwell> dmwit, thanks.
13:58:53 <KirinDave> elliott: It appeals to my inner child.
13:59:03 <elliott> MarkDBlackwell: The Haskell Report isn't that formal, if you really want precise semantics.
13:59:12 <elliott> MarkDBlackwell: Though language extensions mess heavily with that.
13:59:14 <MarkDBlackwell> monochrom, so, examples... sweet!
13:59:18 <Cale> MarkDBlackwell: Yeah, then it'll be pretty good. You might also like to check out the Report. As far as language specs go, it's fairly readable.
13:59:35 <desaiu> Maybe I should look at the source of (+) to see what it does
13:59:36 <monochrom> but LYAH has even more examples than A Gentle Introduction
13:59:47 <MarkDBlackwell> elliott, I don't know ML, but I could pick it up.
13:59:56 <elliott> MarkDBlackwell: You probably don't want to. Haskell is much nicer. :p
14:00:08 <dmwit> desaiu: (++) is probably a better choice
14:00:09 <rwbarton> the... source of (+)?
14:00:19 <dmwit> desaiu: (+) is implemented as a call to hardware for the basic types.
14:00:24 <MarkDBlackwell> dmwit, Gentle moves fast, you mean.
14:00:27 <desaiu> I wonder how to grep for the source of + in ghc
14:00:30 <dmwit> MarkDBlackwell: Yes.
14:00:55 <dmwit> desaiu: grep for "instance.*Num" or some such thing.
14:00:55 <sipa> @src (+)
14:00:55 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:01:02 <KirinDave> MarkDBlackwell: I can only speak for myself in this
14:01:03 <rwbarton> desaiu: for Integer, for example, it's going to make an FFI call to gmp
14:01:11 <KirinDave> MarkDBlackwell: But for me the hard part was not getting the types for applicative functors
14:01:12 <dmwit> desaiu: But again, I recommend something simpler to start with.
14:01:13 <MarkDBlackwell> monochrom, words obstruct sometimes, true.
14:01:14 <elliott> dmwit: Pretty sure (+) on Int becomes something ending with a hash in GHC.Prim.
14:01:16 <dmwit> ?src (++)
14:01:16 <lambdabot> []     ++ ys = ys
14:01:17 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:01:17 <lambdabot> -- OR
14:01:17 <lambdabot> xs ++ ys = foldr (:) ys xs
14:01:18 <elliott> dmwit: So you'd have to look at the RTS.
14:01:22 <KirinDave> MarkDBlackwell: It was seeing WHY you'd use them and in what cases they make sense.
14:01:22 <elliott> Or maybe the compiler, dunno.
14:01:24 <dmwit> elliott: My point exactly.
14:01:42 <rwbarton> a + b for Int is just (I# a) + (I# b) = I# (a +# b), I think
14:01:49 <elliott> dmwit: Mind you, I don't think (+) becomes a "hardware call" on Int. It still has to deal with strictness and boxing.
14:01:52 <Cale> desaiu: Well, the Haskell part of the definition of (+) is going to look pretty simple, and won't reveal much about why it's currying :)
14:01:52 <KirinDave> MarkDBlackwell: So also reading code that uses <$> and <*> and/or uses applicative parsers is probably going to be as good as it gets.
14:02:02 <rwbarton> anyways yes, look at (++).
14:02:08 <elliott> desaiu: When you say "f x y = ..."
14:02:12 <elliott> desaiu: You are saying "f = \x -> \y -> ..."
14:02:15 <Cale> desaiu: (because it's just a normal function definition)
14:02:42 <Cale> desaiu: I should make sure you understand lambda...
14:02:46 <Cale> You know what \x -> x + 5 means, yeah?
14:02:48 <desaiu> Oh man! I have to learn what currying is before I can understand what a -> a -> etc means? Oh boy.
14:02:56 <KirinDave> desaiu: Not really.
14:02:59 <MarkDBlackwell> elliott, well, I've come to Haskell as my first lispy language, in that way, after learning a little Prolog.
14:03:01 <desaiu> s/Oh man/Wait
14:03:03 <Cale> desaiu: Well, it'll help :)
14:03:09 <KirinDave> desaiu: open up ghci and play.
14:03:11 <rwbarton> Most likely you will learn them at the same time
14:03:11 <elliott> desaiu: It's simple.
14:03:23 <angstrom> rwbarton: what's |# and +# ? made me wonder
14:03:25 <elliott> desaiu: OK, you know how you can say (a,b) -> c?
14:03:32 <Cale> desaiu: When you write f x y z in Haskell, it means ((f x) y) z
14:03:33 <KirinDave> desaiu: Write your own + (don't use operator characters, call it myPlus)
14:03:35 <desaiu> KirinDave: Good advice~!
14:03:37 <KirinDave> desaiu: And play with it.
14:03:49 <elliott> KirinDave: That won't help if desaiu doesn't actually get what (a -> b -> c) means.
14:03:50 <dmwit> angstrom: Primitive operations. Not implemented in Haskell, usually.
14:03:54 <rwbarton> angstrom: GHC-internal stuff.  I# (it's the letter I, not a |) is the constructor for Int and +# is the operation of addition on unboxed ints
14:04:10 <angstrom> ah. I see :-)
14:04:10 <elliott> desaiu: Are you _still_ suffering with YAHT? :-)
14:04:20 <KirinDave> elliott: Understanding can guide intuition, but the converse is also true. :)
14:04:27 <Cale> So, f is applied first to x, giving another function, which is applied to y, giving another function which is applied to z, and that gives you whatever your result is.
14:04:36 <desaiu> elliott: I've never been suffering with it, I'm suffering with school though :P
14:04:44 <Cale> So function application is left-associative
14:05:04 <desaiu> Because I can't close #haskell or YAHT or any haskell related CS topic on wikipedia :P
14:05:10 <Cale> and dually, the -> in types is right associative to go along with it
14:05:23 <Cale> So when you write f :: Int -> Char -> Bool -> String
14:05:26 <Cale> it means
14:05:35 <Cale> f :: Int -> (Char -> (Bool -> String))
14:05:37 <desaiu> elliott: No, I don't know how can say (a,b) -> c
14:05:52 <desaiu> 16:10 < Cale> desaiu: When you write f x y z in Haskell, it means ((f x) y) z
14:05:55 <elliott> desaiu: Have you seen a type signature before? Honest question.
14:06:00 <desaiu> I can understand that, thanks for the clarification
14:06:31 <MarkDBlackwell> KirinDave, I do like the <*> elegant syntax, etc.  So, you mean the use cases for applicative functors -- getting an intuitive feel for them, I guess.
14:06:34 <desaiu> KirinDave: I don't think I can write myPlus right now, I haven't gotten that far in the tutorial
14:06:38 <desaiu> I don't think, maybe I can
14:06:55 <KirinDave> desaiu: Well there is a good place to start.
14:06:58 <desaiu> I did write a myMap, but it was really just copying YAHT's hints
14:07:00 <Cale> So, if we have f :: Int -> (Char -> (Bool -> String)), and x :: Int, y :: Char, and z :: Bool
14:07:02 <Cale> then:
14:07:12 <Cale> f x :: Char -> (Bool -> String)
14:07:15 <KirinDave> MarkDBlackwell: I lurve me my Applicative instance for Either and Maybe. :)
14:07:19 <desaiu> elliott: I think a type signature is something like a :: foobar
14:07:19 <Cale> (f x) y :: Bool -> String
14:07:26 <Cale> ((f x) y) z :: String
14:08:03 <KirinDave> I gotta get back to work :\
14:08:13 <Cale> and we can leave off all the parens there, because of the way that -> and function application associate
14:08:20 <monochrom> MarkDBlackwell: under suitable conditions (satisfied usually), do { x<-getLine; y<-getChar; return (f x y)} = f <$> getLine <*> getChar.
14:08:48 <monochrom> but yikes, that probably requires knowing do { x<-getLine; y<-getChar; return (f x y)} first
14:09:39 <RomyEatsDrupal> Hi, question from a Haskell newbie.  I have GHC installed in my Debian Linux virtual machine (which I am running inside my Mac Os x Terminal), and I am trying to run a haskell script with the command "runHaskell (documenthere.hs)" but GHC does not recognize ''runHaskell''
14:09:43 <elliott> monochrom: I think that is always true. Unless you shadow getLine/getChar but that's like saying 0+0 == ().
14:09:44 <MarkDBlackwell> monochrom, was that for me?
14:09:47 <elliott> Under certain conditions :P
14:09:51 <monochrom> yes
14:09:59 <elliott> dom96: lowercase h
14:10:01 <RomyEatsDrupal> http://lisperati.com/haskell/ht1.html is the link I am referencing… can anyone give some tips? :)  thank you
14:10:03 <elliott> erm
14:10:05 <elliott> RomyEatsDrupal: Lowercase h
14:10:06 <elliott> RomyEatsDrupal: And no parens
14:10:30 <elliott> RomyEatsDrupal: That tutorial is old though.
14:10:34 <elliott> RomyEatsDrupal: You should try YAHT :-)
14:10:38 <elliott> erm
14:10:40 <elliott> RomyEatsDrupal: You should try LYAH :-)
14:10:42 <elliott> I blame desaiu.
14:10:43 <monochrom> it can fail if you are naughty and define b<*>c to "do c first, do b after", and it violates no law actually.
14:10:48 <Cale> LYAH is the new YAHT
14:10:54 <desaiu> the x :: Int, y etc. tripped me. I've never seen a comma used like that unless the two objects were enclosed in parens
14:10:55 <elliott> monochrom: IO comes with an Applicative instance :P
14:10:59 <desaiu> like (x, y)
14:11:05 <Cale> desaiu: Oh, sorry
14:11:18 <Cale> desaiu: That comma was just part of my English sentence :)
14:11:21 <Cale> (not code)
14:11:24 <mysticc> given a haskell file can I find its package dependencies based on the imports it makes
14:11:27 <monochrom> yes sure, but the order it picks is arbitrary, only by popular demand.
14:11:28 <MarkDBlackwell> monochrom, x is a member of getLine, y is drawn from getChar, etc. do you mean, is equivalent code to that nice applicative functor expression at the end. Yes, raising. It's good.
14:12:05 <RomyEatsDrupal> elliott: the lowercase h helped, thank you!
14:12:06 <elliott> RomyEatsDrupal: (http://learnyouahaskell.com/ if you didn't know)
14:12:09 <mysticc> @hoogle Text.JSON
14:12:09 <lambdabot> No results found
14:12:15 <mysticc> @hoogle json
14:12:16 <lambdabot> No results found
14:12:20 * elliott can spot at least one error on http://lisperati.com/haskell/ht1.html without trying.
14:12:28 <RomyEatsDrupal> hm, elliott you think that tutorial is fairly useless?  i just appreciate how simplistic it is.
14:12:29 <desaiu> > :t (+)
14:12:30 <lambdabot>   <no location info>: parse error on input `:'
14:12:50 <elliott> RomyEatsDrupal: Well, it's pretty old, and LYAH is really good. It's also pretty "simplistic" in the early stages.
14:12:51 <monochrom> it is simplistic and it still blows your mind
14:12:58 <elliott> monochrom: RomyEatsDrupal is referring to http://lisperati.com/haskell/ht1.html
14:13:00 <elliott> not LYAH
14:13:03 <MarkDBlackwell> monochrom, Cale, elliott, thanks! gotta go, now.
14:13:13 <RomyEatsDrupal> also, i have that book Learn You a Haskell-- I spent a few hours in the beginning but I thought straight tup interactive examples would help
14:13:15 <desaiu> :t (+)
14:13:16 <lambdabot> forall a. (Num a) => a -> a -> a
14:13:22 <desaiu> :t (++)
14:13:23 <monochrom> I see. nevermind.
14:13:23 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:13:28 <MarkDBlackwell> I will look at 'you could have invented'.
14:13:30 <elliott> RomyEatsDrupal: Hmm? LYAH goes to interactive examples on the very second page.
14:13:48 <desaiu> ?src ++
14:13:49 <lambdabot> []     ++ ys = ys
14:13:49 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:13:49 <lambdabot> -- OR
14:13:49 <lambdabot> xs ++ ys = foldr (:) ys xs
14:13:55 <RomyEatsDrupal> elliott: indeed, it does, via the haskell prompt, but i was seeking a full script from which to learn
14:14:28 <Cale> RomyEatsDrupal: That tutorial mostly looks fine
14:14:32 <elliott> RomyEatsDrupal: LYAH has you making your own modules fairly early on.
14:14:36 <elliott> RomyEatsDrupal: So I wouldn't worry about it.
14:14:38 <desaiu> ?src +
14:14:38 <lambdabot> Source not found. Where did you learn to type?
14:14:42 <RomyEatsDrupal> Cale: are you referring to the picnic Haskell tutorial?
14:14:44 <desaiu> ?src (+)
14:14:44 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:14:45 <Cale> Yeah
14:14:46 <Quantumplation> type NodeID a = a; type EdgeID a = (NodeID a, NodeID a); can NodeID and EdgeID implement show?
14:14:53 <RomyEatsDrupal> Thank you elliott
14:14:57 <desaiu> I almost get it
14:15:18 <RomyEatsDrupal> by the way, I live in New York city.  Does anyone know of any Haskell groups here?
14:15:20 <elliott> Cale: Well, it lies about Int. And promotes "monad" fear-mongering on the second page. :-)
14:15:26 <Cale> Oh, does it?
14:15:30 <RomyEatsDrupal> Or anyone live here in New York?
14:15:41 <Cale> I guess I haven't actually read it, I just looked at the code examples.
14:15:59 <Quantumplation> Romy: I do.
14:16:01 <elliott> Cale: Yeah, it has a big "WARNING: THIS WILL MAKE NO SENSE \n Monads are weird and mathematical! Spooky! \n FORGET YOU EVER READ THAT NEVER TRY AND UNDERSTAND MONADS".
14:16:20 <Cale> One other criticism I have right off is that it's overusing type synonyms
14:16:33 <Cale> and that it seems to be using 'let' a whole lot...
14:16:39 <elliott> Cale: Also it promotes generating XML with string concatenation.
14:16:49 <Cale> heh
14:16:54 <desaiu> Back to my original question
14:16:55 <desaiu> 14:28 < desaiu> I'm trying to understand this: http://www.haskell.org/haskellwiki/Parametric_poly
14:16:56 <Cale> okay, so it has some problems
14:16:58 <desaiu> morphism
14:16:58 <rwbarton> Most of these things are explicitly apologized for in "What's Bad about this Code?" sections
14:17:01 <desaiu> 14:28 < desaiu> Can someone explain?
14:17:09 <Cale> desaiu: okay
14:17:13 <elliott> desaiu: That's a really bad page, as someone pointed out when it was first brought up.
14:17:20 <int-e> elliott: Have a warm fuzzy thing. It's good for your nerves.
14:17:24 <desaiu> elliott: dmwit brought that up
14:17:28 <Cale> desaiu: Let's start with a simpler example of parametric polymorphism than map
14:17:30 <elliott> Looks like someone wrote it without really being sure if they're right and then nobody made it better: http://www.haskell.org/haskellwiki/index.php?title=Parametric_polymorphism&action=history
14:17:34 <Cale> desaiu: length is good...
14:17:36 <RomyEatsDrupal> Neat, Quantumplation , where in New York?
14:17:36 <elliott> int-e: Soothing.
14:17:37 <Cale> :t length
14:17:38 <lambdabot> forall a. [a] -> Int
14:17:49 <int-e> elliott: thanks
14:17:52 <Cale> So for any type a, length will take a list of values of type a, and produce an Int
14:18:10 <desaiu> so length takes a list of variables and produces an integer
14:18:11 <Cale> This is because length doesn't actually examine the elements of the list, and so doesn't need to know what type they are.
14:18:19 <Cale> It takes a list of values of any type
14:18:19 <desaiu> s/variables/elements
14:18:27 <desaiu> Okay
14:18:38 <Cale> For example, it can take a list of Integers, or a list of Strings, or a list of Chars (which is a string)
14:18:43 <Cale> > length [1,2,3]
14:18:44 <lambdabot>   3
14:18:46 <Cale> > length "Hello"
14:18:47 <lambdabot>   5
14:18:59 <Cale> > length ["Hello", "there", "world"]
14:19:00 <lambdabot>   3
14:19:01 <desaiu> > length 1:2:3:4:5:[]
14:19:01 <lambdabot>   No instance for (GHC.Num.Num [a])
14:19:02 <lambdabot>    arising from the literal `1' at <inter...
14:19:10 <Cale> > length (1:2:3:4:5:[])
14:19:11 <lambdabot>   5
14:19:29 <desaiu> Why do you have to enclose it in parens?
14:19:37 <Cale> desaiu: One important little syntax thing to remember is that function application binds more tightly than any infix operator
14:19:50 <Cale> So what you wrote means: (length 1):2:3:4:5:[]
14:19:51 <copumpkin> @remember xplat you just need to write a corresponding set of modules for well-hung coinduction
14:19:51 <lambdabot> Done.
14:19:54 <kmc> what do you call the set whose elements are "clockwise" and "counterclockwise"
14:20:06 <elliott> kmc: Clockwiseosity.
14:20:08 <desaiu> Oh
14:20:19 <Cale> and then the compiler complained that it doesn't know how to think of 1 as a list
14:20:25 <Cale> (as required for length)
14:20:35 <desaiu> Got it, functional application being insanely high on the fixity scale
14:20:43 <Cale> yep
14:21:15 <Cale> ($) on the other hand is at the other end of the fixity scale, but f $ x = f x
14:21:20 <Cale> So you could write:
14:21:23 <desaiu> So length is an example of parametric polymorphism because it takes as an argument any type?
14:21:25 <sipa> > length "blaa"::String
14:21:26 <lambdabot>   Couldn't match expected type `GHC.Base.String'
14:21:26 <lambdabot>         against inferred typ...
14:21:27 <Cale> > length $ 1 : 2 : 3 : 4 : 5 : []
14:21:28 <lambdabot>   5
14:21:48 <Cale> desaiu: Yeah, there's an arbitrary type parameter 'a' in the type
14:22:23 <desaiu> Is there an example where parametric polymorphism isn't allowed?
14:22:34 <Cale> Well, C doesn't allow it.
14:22:38 <Cale> if you know C.
14:22:41 <desaiu> In Haskell :)
14:23:07 <desaiu> All functions allow this in Haskell?
14:23:28 <Quantumplation> can someone explain the arrow monad to me?
14:23:29 <desaiu> wait wait, length doesn't allow just any parameter/argument
14:23:41 <Cale> Well... in Haskell, it's pretty much allowed anywhere in types, so long as your definition doesn't depend in any way on a value, it can be polymorphic
14:23:55 <Cale> desaiu: Right, it requires a list of values of any type.
14:23:57 <ziman> does DPH allow polymorphism?
14:24:05 <tac-tics> DPH?
14:24:06 <copumpkin> not really, no
14:24:09 <copumpkin> not yet, anyway
14:24:13 <desaiu> So, parametric polymorphism, in Haskell, is a function that allows more than one type of argument?
14:24:15 <ziman> not yet, afaik, yes
14:24:19 <desaiu> or just any type of argument?
14:24:37 <desaiu> ?DPH
14:24:38 <lambdabot> Unknown command, try @list
14:24:38 <int-e> @type id
14:24:39 <lambdabot> forall a. a -> a
14:24:45 <dolio> DerP Haskell
14:24:46 <ziman> tac-tics, data-parallel haskell
14:24:48 <tac-tics> ah
14:24:51 <desaiu> !define DPH
14:24:56 <desaiu> !DPH
14:24:58 <tac-tics> @where dph
14:24:59 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
14:25:02 <int-e> ^ id takes an argument of any type and returns a value of the same type. (in fact, the same value)
14:25:09 <desaiu> Thanks tac-tics
14:25:19 <rwbarton> desaiu: "Polymorphism" refers to functions (or other kinds of values) that can be used at more than one type.
14:25:24 <tac-tics> desaiu: Lambdabot is a picky mistress.
14:25:29 <monochrom> great, now we're going to argue what "any" means
14:25:42 <Cale> desaiu: Well, something is parametrically polymorphic if it has a type variable in its type.
14:25:48 <Cale> desaiu: like length does
14:25:50 <int-e> in this case, the type has one parameter, namely 'a'.
14:25:59 <monochrom> much simpler to say: a polymorphic function lets the caller pick the actual type
14:26:00 <rwbarton> "Parametric" means we only wrote a single length function, we didn't write it separately for [Bool] -> Int and for [Char] -> Int and for ....
14:26:00 <ziman> desaiu, if the type signature of that function contains variables, you can substitute any type for each of those variables
14:26:00 <Cale> (or type parameter, if you will)
14:26:17 <desaiu> tac-tics: would replacing "at" with "with" in your sentence still be correct?
14:26:25 <desaiu> That would help me understand what you said
14:26:29 <Cale> Yeah, that's an important thing: we don't have to implement length for each type we want it to work on
14:26:47 <desaiu> rwbarton: Whoops, I mean in your sentence above,
14:26:57 <tac-tics> desaiu: Which sentence?
14:27:01 <Cale> We implement it once, and use it at any type of list because our implementation doesn't care what type the elements of the list are.
14:27:05 <rwbarton> yes, I think so
14:27:06 <desaiu> 16:32 < rwbarton> desaiu: "Polymorphism" refers to functions (or other kinds of values) that can be used at more than one type.
14:27:30 <tac-tics> that wasn't me, but yeah. "can be used *on* more than one type"
14:27:32 <desaiu> "at more than one type" to "with more than one type"
14:27:39 <tac-tics> or with
14:27:44 <desaiu> Ah, okay
14:27:47 <Cale> desaiu: There are cases where we want polymorphism, but unrestricted parametric polymorphism isn't quite right though.
14:27:50 <desaiu> So, now I understand :)
14:27:54 <rwbarton> what I mean is you can use 'length' somewhere where its type is [Bool] -> Int, and again somewhere else where its type is [Char] -> Int.
14:27:56 <Cale> desaiu: For example, consider a function for sorting lists.
14:28:11 <Cale> desaiu: We want to be able to sort many types of lists using the same algorithm
14:28:15 <desaiu> 16:32 < Cale> desaiu: Well, something is parametrically polymorphic if it has a type variable in its type.
14:28:19 <monochrom> god, this is worse than I anticipated. I anticipated arguing over "any". you guys bring it further down to arguing over prepositions
14:28:19 <desaiu> That confuses me
14:28:31 <Cale> desaiu: like the 'a' in length :: [a] -> Int
14:28:48 <Cale> The 'a' is allowed to be substituted for any type
14:28:59 <tac-tics> desaiu: another simple example is "id"
14:29:00 <tac-tics> @type id
14:29:01 <lambdabot> forall a. a -> a
14:29:03 <Cale> which is why you'll sometimes see that reported as:
14:29:08 <dolio> Can Haskell implement any computable function?
14:29:10 <Cale> length :: forall a. [a] -> Int
14:29:15 <tac-tics> id just returns its argument
14:29:15 <Cale> dolio: yes?
14:29:25 <xil> hello. Wondering if I can get some help again. Getting an error I don't understand. Pastebinning now
14:29:30 <hpaste> xil pasted “error” at http://hpaste.org/52595
14:29:51 <desaiu> :t length
14:29:52 <lambdabot> forall a. [a] -> Int
14:30:08 <ziman> desaiu, a single function can have different types in Haskell. The types available are constrained by the "type template", which is the most-general type signature parameterized by type variables. By substituting types for these variables, you get different specializations; each one of them is a valid type for that function.
14:30:15 <desaiu> "forall a. [a] -> Int" <--- What is that together called
14:30:20 <Cale> xil: What's the type of mapMaybe?
14:30:32 <Cale> desaiu: a type
14:30:48 <Cale> desaiu: specifically, it's the type of length
14:31:00 <desaiu> A type, then, doesn't seem to tell exactly what the function does, more like what it produces
14:31:01 <xil> Cale: (a -> Maybe b) -> [a] -> [b]
14:31:20 <Quantumplation> fmap (fst &&& (:[])) <-- what does this do?
14:31:22 <desaiu> foall a. [a] -> Int doesn't seem to tell me that it's counting a list
14:31:27 <int-e> desaiu: right. it's not a complete specification of the function's behaviour, the specification is partial
14:31:29 <desaiu> Am I wrong?
14:31:33 <desaiu> Okay, good
14:31:37 <Cale> desaiu: Yeah, you can think of types as properties of the program which the compiler will enforce before it will let you run it.
14:32:12 <tac-tics> desaiu: yep. The type is a "loose" definition. Many different functions can have the same type, but do different things.
14:32:23 <tac-tics> desaiu: (+) and (*) are both Int -> Int -> Int, for example :)
14:32:28 <desaiu> 16:37 < ziman> desaiu, a single function can have different types in Haskell. The types available are constrained by the "type template", which is the most-general type signature parameterized  by type variables. By substituting types for these variables, you get different specializations; each one of them is a valid type for that function.
14:32:33 <desaiu> That's mindblowing
14:32:45 <Cale> Quantumplation: it applies the function (fst &&& (:[])) to the elements of some structure (or the result of some computation), and fst &&& (:[]) is the same as (\x -> (fst x, [x]))
14:32:51 <tac-tics> @type id :: Int -> Int
14:32:52 <lambdabot> Int -> Int
14:32:56 <tac-tics> @type id :: Bool > Bool
14:32:57 <lambdabot>     Couldn't match expected type `(>)' against inferred type `(->)'
14:32:57 <lambdabot>       `>' is a rigid type variable bound by
14:32:57 <lambdabot>           an expression type signature at <interactive>:1:11
14:33:05 <tac-tics> @type id :: Bool -> Bool
14:33:06 <lambdabot> Bool -> Bool
14:33:17 <tac-tics> id, as seen two different ways
14:33:25 <tac-tics> the most general one, of course, is
14:33:26 <tac-tics> @type id
14:33:27 <lambdabot> forall a. a -> a
14:33:28 <Cale> id x = x -- the definition of id
14:33:47 <desaiu> I can see that tac-tics
14:33:54 <tac-tics> (ignore the forall a. part. It's not important, and can always be dropped, as far as you're concerned)
14:33:55 <Cale> Because its behaviour doesn't depend on the value of x in any way, its type is generalised
14:34:21 <RomyEatsDrupal> so elliott you say you saw an error in the lisperati haskell tutorial?
14:34:24 <desaiu> To know that the type definition (<-- did I phrase that correctly?) doesn't actually tell you what the function does is helpful to know :)
14:34:29 <Cale> Yeah, if you leave the forall out, then any type variables you put in a type signature will be automatically forall'd at the top of the signature.
14:34:38 <Quantumplation> Cale: so, given some list of elements, it maps (\x -> (fst x, [x])) over that list?  So, it should be a list of tuples presumably.  it takes a list of tuples, and generates a new list of tuples? or... hrm.
14:34:55 <elliott> desaiu: It does sometimes.
14:34:58 <Cale> desaiu: It does tell you a good bit about it though. It's often the single most important piece of documentation.
14:35:20 <Cale> Quantumplation: yes
14:35:22 <dolio> It's not because its behavior doesn't depend on x that it can be generalized.
14:35:23 <ziman> desaiu, that said, you can encode various constraints on the values accepted/produced by a function in its type.
14:35:28 <dolio> It's because its behavior doesn't depend on a.
14:35:36 <tac-tics> desaiu: If you have a function of type [a] -> Int, for all you know, it could just return 0 for every input.... or maybe the length + 1.... you don't know until you have the definition.
14:35:37 <monochrom> Int->Int gives you little information. but a->a gives you almost full information.
14:35:40 <Cale> Quantumplation: It looks like you're looking at some heavily golfed or obfuscated code?
14:36:00 <elliott> Cale: I wouldn't call fmap (fst &&& (:[])) obfusctaed.
14:36:12 <elliott> Cale: I also doubt the context is lists if it's fmap.
14:36:13 <Cale> elliott: Well, no...
14:36:17 <elliott> fmap (fst &&& pure) is nicer, though.
14:36:29 <Cale> elliott: But thinking about what that function does makes it seem a little suspect
14:36:30 <desaiu> tac-tics: The type definition or the definition as in the definition of the function?
14:36:40 <desaiu> as in the source code
14:36:44 <tac-tics> the function definition
14:36:49 <desaiu> as in source code?
14:36:56 <tac-tics> we usually just call "the type definition" "the type"
14:37:05 <Quantumplation> Cale: I am writing a generic graph library as one of my first projects in haskell, both to help with my own research and to learn haskell
14:37:14 <Quantumplation> and I was having trouble with the makeGraph function, and someone helped me out
14:37:19 <desaiu> and the source of the function "the definition"?
14:37:21 <Quantumplation> so i'm trying to understand their code
14:37:25 <tac-tics> @let one_plus_length xs = length xs + 1
14:37:26 <lambdabot>  Defined.
14:37:27 <ziman> desaiu, yes.
14:37:34 <desaiu> Noted
14:37:36 <tac-tics> @type length_plus_one
14:37:37 <lambdabot> Not in scope: `length_plus_one'
14:37:38 <kmc> hmm i'm breaking my own rule about type names vs. constructor names
14:37:41 <Cale> Quantumplation: It might be just fine in context, but it looks a little weird to me in isolation :)
14:37:45 <tac-tics> @type one_plus_length
14:37:46 <Quantumplation> http://hpaste.org/52585
14:37:46 <lambdabot> forall a. [a] -> Int
14:37:48 <tac-tics> @type length
14:37:48 <lambdabot> forall a. [a] -> Int
14:37:50 <kmc> data FooMode = Bar | Baz; data Command = ... | FooMode FooMode
14:37:54 <kmc> this does seem reasonable however
14:38:08 <Cale> oh!
14:38:21 <Cale> Okay, so that's why they're doing that :)
14:38:33 <Cale> M.fromListWith (++) makes it seem much more reasonable :)
14:38:35 <monochrom> one information you can deduce from [a]->Int is that the Int answer does not depend on element details
14:38:41 <Quantumplation> hehe
14:38:50 <Cale> though that could be map and not fmap, given that it's a list
14:39:10 <Quantumplation> I have to write this lab report now, but would you be free in an hour or so to help me pick this apart?  it's really mind-bending trying to write a recursive structure like this heh
14:39:23 <c_wraith> holy crap, I got threadscope running.  Um, how do I generate a data file for it?
14:39:26 <Cale> Quantumplation: maybe... I really shouldn't be here, I have work to get done :)
14:39:38 <Quantumplation> hehe, alright, well, if I see you around some time then? =P
14:39:59 <Cale> Quantumplation: But yeah, M.fromListWith (++) will take a list of key/value pairs, and if two pairs have the same key, it combines them with (++)
14:40:06 <Cale> (combines the values)
14:40:11 <ClaudiusMaximus> c_wraith: compile with eventlog flag and use an rts option - probably, can';t remember the details right now
14:40:14 <ziman> desaiu, but, as others have already pointed out, if you have a function with the type (a -> a), you can readily infer what the function *does*, given only the type. Since the type of values is unknown (any "a"), the function cannot "look at" the value that it receives as its input. Hence the only sensible way how the function can deal with the value is to return it untouched.
14:40:20 <Quantumplation> Cale: ahhh, ok
14:40:25 <monochrom> suppose I have myfun :: [a] -> Int, and you test it with myfun [True, False, False] = 2. then you can predict myfun ['a', 'c', '0'] = 2. note I'm saying nothing about myfun ['a'].
14:40:27 <c_wraith> ClaudiusMaximus: to the docs I go, I guess!  Thanks :)
14:40:31 <desaiu> I feel like I'm the annoying guy who just doesn't get it, but I'm going to ask anyway. ziman, you blew my mind with the "a single function can have different types in Haskell..." sentence. Would you mind explaining that to me?
14:40:38 <ziman> desaiu, (there is one other possibility — to not return at all)
14:41:06 <donri> annoying :( http://www.haskell.org/haskellwiki/opensearch_desc.php
14:41:26 <Cale> desaiu: Well... look at length. Its type allows it to be applied to [Int] or [Char]. That's all he means.
14:41:31 <tac-tics> desaiu: When a function has type variables in its type, you are free to replace the type variables with *concrete* types, like Int, Char, or String.
14:41:54 <monochrom> the price you pay is that the programming language forbids you from writing "myfun (x:xs) = what is the type of x? if it's Char, do one thing; if it's Int; do some other thing..."
14:42:02 <xil> no one's got any ideas why I'm getting this error? It all looks alright to me =/
14:42:09 <c_wraith> ClaudiusMaximus: yep.  compile with -eventlog, run with +RTS -ls
14:42:22 <Cale> desaiu: also, pay attention to what monochrom is saying
14:42:31 <Cale> desaiu: It's kinda important :)
14:42:44 <desaiu> That's not really the part that blew my mind, it was the stuff after that
14:42:48 <desaiu> The type template
14:43:06 <monochrom> no, don't pay attention to me, since I don't prepend "desaiu:" to every sentence. clearly, I am talking to no one.
14:43:27 <desaiu> Is the type template defined in the definition?
14:43:33 * tac-tics always suspected monochrom talked to himself in chat
14:43:33 <Cale> monochrom: hehe
14:44:01 * hackagebot passage 0.1 - Parallel code generation for hierarchical Bayesian modeling.  http://hackage.haskell.org/package/passage-0.1 (ChadScherrer)
14:44:02 <desaiu> I'm trying to pay attention to everyone, it just takes awhile for me to get to everyone :)
14:44:14 <Cale> desaiu: "type template" isn't really a thing... that was worded a bit strangely, at least from my view
14:44:49 <Cale> desaiu: But I guess you can think of types which have type variables in them as being like templates in that you can plug in anything you want for the variables
14:44:57 <kmc> woah (re: 'passage')
14:45:03 <Cale> and the function will work on those types
14:45:47 <desaiu> Do you specify what types variables can be in the definition of the function?
14:45:51 <monochrom> see how Cale's two lines is shorter and clearer than the whole "type template" paragraph
14:46:14 <Cale> desaiu: no
14:46:24 <Cale> desaiu: They can be any type at all, because the definition doesn't care.
14:46:35 <Cale> desaiu: (The definition is *required* not to care)
14:46:42 <Cale> If I write something like:
14:46:46 <Cale> length :: [a] -> Int
14:46:51 <Cale> and then try to define length like...
14:46:52 <monochrom> the caller picks the type. so the function's author have no choice. it's the caller's choice
14:47:01 <Cale> length [n] = n
14:47:07 <Cale> I will get a type error
14:47:13 <Cale> because this assumes n = Int
14:47:16 <Cale> n :: Int
14:47:17 <Cale> sorry
14:47:35 <Cale> and that means that n couldn't really have any type at all, like the signature says
14:48:00 <desaiu> That doesn't make sense, that the definition is required not to care. That makes me think that any function with variables can have variables of any type. But I thought we already established this isn't the case with length which, e.g., doesn't take an Int as an argument
14:48:02 <Cale> Whatever definition I give for length, it had better work for lists of strings as well as it does for lists of Int
14:48:20 <Cale> Well, length looks at the structure of the list
14:48:26 <Cale> but it doesn't look at the elements of the list
14:48:30 <desaiu> Ah
14:49:06 <Cale> That is, it doesn't decide what to produce based on the values of those list elements. It doesn't pattern match them at any point.
14:49:21 <monochrom> the function's author does not know that "a" does not become Int. but he/she also doesn't know that "a" becomes Int. he/she just doesn't know either way.
14:49:43 <desaiu> But then is that true parametric polymorphism by my twisted definition which states that a function in haskell should be able to take any type as an argument, not just a list, but maybe a tuple or an Int as a variable?
14:50:12 <Cale> desaiu: Well, for any type a, length can have type [a] -> Int
14:50:20 <monochrom> your definition says that "myfun :: a" is the only true parameteric polymorphism
14:50:23 <Cale> desaiu: So it's like a "parameter" in that regard.
14:50:45 <Cale> In Haskell, the type parameters are invisible where they're supplied (the compiler supplies them automatically)
14:50:52 <Cale> but you can imagine a language where you had to write:
14:51:01 <Cale> length Int [1,2,3]
14:51:15 <Cale> Where you applied length to a type parameter to get which one you wanted
14:51:23 <Cale> length Char "Hello"
14:51:41 <Cale> (but this isn't Haskell at that point)
14:51:54 <Cale> So it's like there's an invisible parameter there, saying which type you're applying length at.
14:51:55 <elliott> (I really wish we had that.)
14:52:03 <Cale> elliott: Oh?
14:52:22 <Cale> You can sort of have it, by giving length an explicit type signature where you use it:
14:52:31 <elliott> Cale: Well, I often want to specialise a function to get things to work out, but I have to use an ugly type signature instead.
14:52:32 <Cale> (length :: [Int] -> Int) [1,2,3]
14:52:37 <Cale> ah
14:52:59 <monochrom> if you write directly in GHC's core language, you have the full pleasure of writing "length @ Int [1,2,3]"
14:53:05 <Cale> yeah
14:53:08 <Cale> desaiu: Does that make sense?
14:53:09 <elliott> Cale: It would let you say "foo :: String -> String; foo = show . read @Int" :-)
14:53:14 <elliott> OK, so that's not the most compelling example.
14:53:22 <elliott> monochrom: I wish GHC had a Core parser, too :P
14:53:27 <rwbarton> you need some way also to deal with functions that have more than one type parameter
14:53:33 <desaiu> I thought I understood what parametric polymorphism in Haskell was earlier by thinking it meant that a function can take as an argument any type, but the types it could take would be defined in the function definition. I think this was just stated as incorrect. But then, I think my next "aha" moment was burned too, which is I thought it meant that a function's argument can be of  any type, but length doesn't allow for anything but a list, it just doesn
14:53:34 <KirinDave> Ha, are we still explaining to poor desaiu what a -> b -> c means?
14:53:41 <desaiu> I will read what everyone said while I typed tat out
14:54:09 <Cale> desaiu: Well, the 'any' type can be a parameter to some other type constructor
14:54:25 <Cale> Like with [a]
14:54:37 <Cale> desaiu: Or consider:
14:54:42 <Cale> fst :: (a,b) -> a
14:54:46 <Cale> fst (x,y) = x
14:54:47 <edwardk> sweet! galois has taken up the torch of hbc (the bayes compiler, not lennart's toy) and appears to have built shiny new stuff
14:55:02 <Cale> desaiu: In this case, the type signature of fst actually does tell us what it does.
14:55:15 <Cale> (there's only one defined value of that type)
14:55:25 <monochrom> if your type has some type variables, it is already parametric polymorphic. [a]->Int is parameteric polymorphic. does not contradict the fact that you're still stuck with list and number.
14:55:44 <sipa> but it is a list of *anything*
14:55:46 <sipa> but still a list
14:55:54 <Cale> edwardk: Wait, there are two hbc's?
14:55:58 <monochrom> there is always a restriction.
14:56:13 <sipa> :t undefined
14:56:13 <lambdabot> forall a. a
14:56:53 <Cale> edwardk: I think I only knew about Lennart's compiler.
14:57:11 <edwardk> cale: the other is a hierarchical bayes compiler by hal daume
15:02:04 <Tordek> hi
15:02:57 <nolrai23> Okay I am using the Haskell extension for eclipse, which means I am messing with cabal files for the first time, how do I tell cabal I am using an library?
15:03:39 <dmwit> nolrai23: build-depends: library-name >= min-version
15:03:50 <dmwit> e.g. build-depends: base >= 4 && < 5
15:03:58 <dmwit> Tordek: hi
15:05:51 <nolrai23> dmwit: thanks!
15:46:17 <donri> HTF or test-framework?
15:47:23 <desaiu> Prelude> :list (++)
15:47:24 <desaiu> cannot list source code for ++: module GHC.Base is not interpreted
15:47:41 <mm_freak> donri: i don't know test-framework, but i like the way HTF handles testing
15:48:18 <mm_freak> though i'm thinking about writing a test framework myself based on an automaton arrow…  it's amazing how many uses i find for this kind of arrow
15:48:30 <mm_freak> i never thought that i would use anything else than the function arrow
15:50:31 <donri> test-framework runs tests in parallell, supports quicktest1 and doctest and generally seems to have some good things going for it as listed here http://batterseapower.github.com/test-framework/
15:50:46 <donri> but otoh it doesn't seem to inject line/file info etc, like htf does
15:50:55 <kmc> @src (++) -- desaiu
15:50:55 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:50:57 <kmc> bah
15:50:59 <kmc> @src (++)
15:51:00 <lambdabot> []     ++ ys = ys
15:51:00 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:51:00 <lambdabot> -- OR
15:51:00 <lambdabot> xs ++ ys = foldr (:) ys xs
15:51:22 <donri> quickcheck* doh'
15:52:00 <donri> also not clear if test-framework does diffing
15:52:34 <donri> or pretty data printing; looks like neither
15:53:49 <desaiu> ?src (++)
15:53:50 <lambdabot> []     ++ ys = ys
15:53:50 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:53:50 <lambdabot> -- OR
15:53:50 <lambdabot> xs ++ ys = foldr (:) ys xs
15:53:56 <desaiu> ?src (++) @kmc
15:53:57 <lambdabot> Source not found. My mind is going. I can feel it.
15:54:05 <desaiu> Was just curious if that would work :)
15:54:16 <donri> What are you doing, Dave.
16:07:30 <gwern> -2147483647 days since last int accident
16:09:41 <joo> Hah!
16:10:02 <JoeyA> > maxBound :: Int
16:10:03 <lambdabot>   9223372036854775807
16:10:11 <JoeyA> At least 64-bit OSes have more time to prepare.
16:12:43 <tensorpudding> it's not soon, but it's probably at some point before the heat death of the universe
16:14:50 <kmc> 2^64 clock cycles at 3 GHz is less than 200 years
16:15:12 <gwern> could always optimize away the incrementing loop as a call to a RNG :)
16:15:17 <tensorpudding> we're talking days
16:15:29 <tensorpudding> not clock cycles
16:15:32 <kmc> yes yes
16:15:52 <elliott> ?remember gwern -2147483647 days since last int accident
16:15:52 <lambdabot> Done.
16:16:58 <kmc> this discussion reminds me of http://www.youtube.com/watch?v=5q-BH-tvxEg
16:29:56 <JuanDaugherty> looks like not much if any of a jvm/java ffi/bridge/whatever, and less now than in the past
16:34:49 <lucca> JuanDaugherty: might be viable to use or call haskell via the c interface and JNI... but ...why?
16:35:18 <JuanDaugherty> for the obvious purpose, lucca, yes, I was aware of that
16:35:40 <JuanDaugherty> just checking to make sure I wasn't misappraising the situation
16:36:05 <lucca> there is probably an xmlrpc option, if that works better
16:40:30 <JuanDaugherty> prolly people have taken that whole "haskell is java for academics" thing to heart and consider it a natural enemy
16:40:59 <JuanDaugherty> whence interfaces to a lot of lesser langs but java-haskell languishes
16:42:35 <dmwit> More likely nobody who gets paid to do Haskell has needed to bridge to Java yet.
16:42:53 <dmwit> If that happened, there would surely be a bridge within a month or two.
16:43:00 <gwern> more like no one is conscientiousness enough to keep the bridges working
16:43:05 <gwern> how many have there been now? 3 attempts?
16:43:26 <JuanDaugherty> depending on how you count
16:44:29 <JuanDaugherty> how/what
16:45:48 <Saizan> dmwit point still stands, if those were used in production somewhere they'd get maintained
16:48:24 <xil> I'm having a weird problem. I have this function http://hpaste.org/52598 and it's printing "extract" but not "new". Anyone have any ideas why that could be?
16:49:01 <kmc> well, is newPnts getting evaluated anywhere?
16:49:08 <kmc> it's not obvious from this code that it would be
16:49:43 <kmc> does extractMessage force evaluation of its second argument?
16:50:43 <xil> oh I neglected to include another function. again = processor input. So basically newPnts gets evaluated every time processor is called because it becomes 'pnts'
16:51:35 <aavogt> processor seems to take 2 arguments
16:51:36 <xil> extractMessage eventually calls 'again pnts'
16:51:38 <rwbarton> but processor never evaluates its argument pnts
16:51:47 <int-e> it's never evaluated though
16:51:54 <rwbarton> unless extractMessage does
16:52:14 <xil> rwbarton: well it does that map. The function that's mapped evaluates each element. Does that not count?
16:52:22 <bgamari> Igloo: Is there actually a plan for getting stack traces by ghc 7.4.1?
16:52:39 <rwbarton> it won't "do" that map until the value is demanded somewhere
16:53:20 <rwbarton> it'll just build a thunk whose body is   trace "new" $ mapMaybe .....
16:53:38 <int-e> xil: usually, let foo = bar baz  does not evaluate anything; instead, it creates a so-called thunk that represents the  bar baz  computation. the computation will only happen when the value of  foo  is actually examined.
16:54:13 <Igloo> bgamari: I don't know if it will be done in time
16:54:15 <kmc> Debug.Trace does a good job demonstrating why lazy languages separate evaluation and execution
16:54:38 <rwbarton> xil: presumably some one of processor, again, extractMessage is intended to use the pnts argument at some point?
16:54:53 <nolrai23> Hey is there a standard multiset for haskell?
16:55:03 <monochrom> unfortunately no
16:55:12 <kmc> there are multiset libs on hackage
16:55:19 <kmc> or you can use Map k Integer
16:55:28 <xil> well it's really 'increment' that does the evaluation, of the points in 'pnts'
16:55:47 <int-e> xil: nope, because that never gets executed either
16:55:50 <nolrai23> kmc: That was what I was going to do.
16:55:51 <rwbarton> but the list(?) pnts, what do you use it for
16:56:30 <hpaste> xil pasted “everything” at http://hpaste.org/52599
16:56:37 <xil> okay there's all the code, but I'll explain briefly
16:56:47 <nolrai23> (Its just lookup x m == Nothing, and lookup x m == Just 0, are differnt and shouldn't be)
16:57:12 <xil> essentially all the work is done by increment, which examines each element and writes to a TChan if it needs to
16:57:25 <xil> but you're saying that that doesn't count. So I don't know what to do then to force it
16:57:29 <rwbarton> what?
16:57:39 <int-e> xil: well, processMessage just discards its second argument. so indeed nothing will ever examine the newPnts values
16:57:46 <rwbarton> something is wrong here
16:57:52 <dmwit> xil: Yeah, this argument is never used. So... why do you have it?
16:57:57 <monochrom> if you write "let newPnts = undefined", nothing will break
16:57:59 <int-e> xil: what are you trying to do?
16:58:06 <rwbarton> increment is not at all what you wanted to write
16:58:29 <rwbarton> you want something of type ... -> IO something
16:58:36 <bgamari> Igloo: Fair enough
16:58:46 <bgamari> It is good to hear that it's on the radar, however
16:59:02 <xil> dmwit: I thought it was being used, that's why I use it. What I care about really is each element in that list of points. I'm trying to evaluate each element and determine if I need to inform another thread of anything, at which point I write to a TChan
16:59:10 <xil> int-e: ^
16:59:22 <int-e> xil: return $ when (not cont) $ atomically $ writeTChan output $ UpdatePoint ((x,y),iters+1) <-- there's a big misconception in this line
16:59:31 <xil> rwbarton: so if it's output is of type IO then it'll evaluate it?
16:59:33 <rwbarton> that line does exactly nothing
16:59:41 <int-e> xil: this "statement" has no effect whatsoever.
16:59:48 <xil> I see
16:59:49 <dmwit> xil: rwbarton is right; you really messed up with increment
16:59:58 <xil> haha, I didn't know what I was doing
17:00:07 <xil> but I needed a way to be able to remove elements from the list
17:00:17 <xil> I guess I can just compose filter and map
17:00:25 <xil> oh not quite
17:00:35 <int-e> xil: you're trying to create a side effect in a pure computation; this is not possible (... a white lie). You really have to stay in IO for such side effects to happen.
17:00:53 <xil> int-e: when you put it that way I can see why it didn't work
17:01:13 <elliott> <int-e> xil: return $ when (not cont) $ atomically $ writeTChan output $ UpdatePoint ((x,y),iters+1) <-- there's a big misconception in this line
17:01:17 <elliott> int-e: Is the "return" here IO's return?
17:01:24 <int-e> elliott: nope. it's in Maybe
17:01:25 <elliott> I guess probably not from the context.
17:01:30 <elliott> int-e: Right.
17:01:37 * elliott wonders: sequenceMaybe :: Maybe (m a) -> m (Maybe a)
17:01:43 <elliott> ?hoogle Maybe (m a) -> m (Maybe a)
17:01:43 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
17:01:43 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
17:01:43 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
17:01:49 <elliott> Aww. (Is Maybe Traversable?)
17:01:53 <dmwit> yes
17:01:56 <elliott> Yay.
17:02:42 * shachaf recommends that the order of Bool be reversed.
17:02:47 <shachaf> > False > True
17:02:48 <lambdabot>   False
17:02:51 <shachaf> That's backwards.
17:03:09 <monochrom> I like the current order.
17:03:23 <shachaf> If it was reversed, a <= b would mean actual logical implication.
17:03:27 <shachaf> In the direction of the arrow.
17:03:50 <monochrom> screw the direction of the arrow. <= is not logical implication.
17:04:08 <benmachine> you can always defined (=>) = (<=) :P
17:04:08 <shachaf> Hmph.
17:04:12 <benmachine> *define
17:04:15 <shachaf> benmachine: Untrue.
17:04:19 <benmachine> oh
17:04:22 <shachaf> data Bool = False | True | Untrue
17:04:23 <benmachine> fair point
17:04:37 <rwbarton> it is?
17:04:44 <benmachine> => is syntax
17:04:44 <monochrom> ⇐ is logical implication, ≤ is less-or-equal, <= is just ascii gibberish
17:05:05 * clsmith agrees with monochrom 
17:05:20 * benmachine disagrees with monochrom 
17:05:26 * benmachine goes to bed without explaining why
17:05:38 <kmc> is there any way to 'group' the many constructors of a data type in haddock?
17:05:46 <clsmith> monochrom: except in types ofc
17:06:16 <clsmith> actually => could be considered distinct from <= i guess, but it is confusing
17:06:25 <int-e> monochrom: well, ⇐ and ≤ are just unicode gibberish without context.
17:06:51 <tkahn> hey all i'm getting     Couldn't match expected type `SB.ByteString'
17:06:51 <monochrom> I just like to call ascii gibberish :)
17:06:53 <tkahn>                 with actual type `Data.ByteString.Lazy.Internal.ByteString'
17:07:06 <shachaf> tkahn: One is strict, the other is lazy.
17:07:09 <rwbarton> @hoogle mapMaybe
17:07:09 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
17:07:09 <lambdabot> Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
17:07:09 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
17:07:14 <int-e> they have established meanings in math, but likewise, <= has established meanings in various programming languages.
17:07:18 <shachaf> tkahn: I recommend that you fix the error.
17:07:29 <tkahn> shachaf: i know :) what's the best way to convert?
17:07:38 <ddarius> <= is Unicode gibberish as well.
17:07:41 <monochrom> btw for those of you who like 1970s terminals and ascii so much, mplayer has a rendered that does ascii.
17:07:46 <tkahn> from lazy to strict i guess
17:07:49 <monochrom> s/rendered/renderer/
17:07:51 <shachaf> tkahn: It's in the documentation somewhere.
17:08:02 <shachaf> Strict to lazy is easier than lazy to strict, of course.
17:08:29 <kmc> tkahn, toChunks / fromChunks on Lazy
17:08:37 <tkahn> kmc: thanks i'll look at that
17:08:49 <shachaf> kmc: That'll convert to [SB.ByteString], but you still need to concat it or something.
17:08:57 <xil> thank you all! Changed it to IO and it works. I have to be more careful about that laziness. I'll definitely be more aware of it now
17:09:04 <kmc> correct
17:09:23 <hjulle> Is there a simpler way to express this?
17:09:25 <hjulle> ?pl as l1 l2 = map (\x -> map ($x) $ map (,) l1) l2
17:09:25 <lambdabot> as = map . flip (map . flip id) . map (,)
17:09:45 <Jafet> VLC also has ascii output
17:09:54 <hjulle> >  map (\x -> map ($x) $ map (,) [1..3]) [5..8]
17:09:55 <shachaf> hjulle: Probably. But what's wrong with the pointful way of expressing it?
17:09:55 <lambdabot>   [[(1,5),(2,5),(3,5)],[(1,6),(2,6),(3,6)],[(1,7),(2,7),(3,7)],[(1,8),(2,8),(...
17:09:58 <ddarius> monochrom: Yes, and it's -awesome-.
17:10:31 <clsmith> i disagree with mplayer and vlc ascii animations. my terminals are proper paper teletypes. i print the data and bind a flipbook
17:10:34 <hjulle> shachaf: It is hardly any clearer than the pointless
17:11:18 <hjulle> shachaf: What I _should_ have asked is for a _clearer_ way to express it.
17:11:51 <Jafet> clsmith: no, print them on good old paper tape and apply a projector.
17:12:00 <rwbarton> map ($x) $ map (,) y is map (,x) y with TupleSections
17:12:21 <rwbarton> unless I've got it backwards
17:12:58 <hjulle> rwbarton: Yeah, that simplifies it a bit, thanks
17:13:29 <Jafet> as l1 l2 = [ [ (y, x) | y <- l1 ] | x <- l2 ]
17:13:29 <rwbarton> personally I tend to find it easier to just write [ [ (i,j) | i <- [1..3] ] | j <- [5..8] ]
17:13:32 <monochrom> paper is too new-fangled. weave the movie into clothes like Hollerinth did
17:13:36 <rwbarton> no mental gymnastics required
17:13:52 <Jafet> That makes it rather clear that your subscripts have the wrong letters
17:14:45 <Jafet> Then as l1 l2 = flip (liftM2 (,))
17:14:54 <Jafet> s/l1 l2 //
17:15:02 <hjulle> rwbarton: Yeah, I forgot about list comprehensions.. :P
17:15:09 <Jafet> Also, as is a horrible name for a function
17:15:17 <rwbarton> Jafet: not quite, liftM2 does a join/concat.
17:15:55 <hjulle> Jafet: I was going to write asdf, but I was too lazy :P
17:16:07 <BMeph> @quote C.assembly
17:16:07 <Jafet> @src liftM2
17:16:07 <lambdabot> No quotes match. My brain just exploded
17:16:07 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:16:21 <BMeph> Awww. :/
17:16:26 <Jafet> @undo [ [ (i, j) | i <- xs ] | j <- ys ]
17:16:26 <lambdabot> concatMap (\ j -> [concatMap (\ i -> [(i, j)]) xs]) ys
17:16:42 <Jafet> Hmm
17:16:45 <Jafet> @ pl undo [ [ (i, j) | i <- xs ] | j <- ys ]
17:16:50 <Jafet> @. pl undo [ [ (i, j) | i <- xs ] | j <- ys ]
17:16:50 <lambdabot> ((xs >>=) . flip flip [] . ((:) .) . flip (,)) `fmap` ys
17:17:43 <hjulle> What does undo do?
17:18:10 <JoeyA> I guess it removes do notation.
17:18:16 <rwbarton> it converts do-notation to use of >>=, also works on list comprehensions
17:18:36 <Jafet> Well, it doesn't seem to optimize stuff
17:18:38 <JoeyA> @undo do {x <- readLn; y <- readLn; print $ x + y}
17:18:38 <lambdabot> readLn >>= \ x -> readLn >>= \ y -> print $ x + y
17:18:41 <hjulle> Of course :)
17:19:10 <JoeyA> Too bad >>=\x produces a syntax error (you need a space between the >>= and \ )
17:19:39 <JoeyA> Oh well, someone might want to define an emoticons module...
17:19:50 <c_wraith> actually, the -> is the syntax error there.
17:19:56 <c_wraith> >>=\ is a valid operator
17:20:02 <BMeph> JoeyA: Of course. ">>=\" is a legitimate operator. ;)
17:20:18 <JoeyA> I've made my contribution to the Acme category.  Does someone want to tackle an emoticons package?
17:20:42 <donri> "cabal test" doesn't seem to be very well supported, is it used much?
17:20:42 <Jafet> Make sure to use the :- constructor
17:20:51 <BMeph> Jafet: Fix it; write an optimizer script. ;)
17:21:11 <JoeyA> > let f (a :-< b) = a + b
17:21:12 <lambdabot>   not an expression: `let f (a :-< b) = a + b'
17:21:16 <monochrom> > let 5 >>=\ 5 = 5 in 5 >>=\ 5
17:21:17 <lambdabot>   5
17:21:25 <monochrom> scary
17:21:31 <JoeyA> > let f (a :-< b) = a + b in undefined
17:21:32 <lambdabot>   Not in scope: data constructor `:-<'
17:22:07 <Jafet> @hoogle (:-)
17:22:07 <lambdabot> No results found
17:22:22 <monochrom> that is for data types. data Whee = Int :-< Int
17:22:35 <JoeyA> right
17:22:46 <clsmith> :-< is a very sad face
17:23:25 <monochrom> > let 5 \∩/ 5 = 5 in 5 \∩/ 5
17:23:25 <lambdabot>   5
17:23:30 <monochrom> \∩/
17:24:10 <JoeyA> > let a ~~~> b = a + b in 3 ~~~ 5
17:24:11 <lambdabot>   Not in scope: `~~~'
17:24:25 <JoeyA> > let a ~~~> b = a + b in 3 ~~~> 5
17:24:26 <lambdabot>   8
17:24:48 <JoeyA> > let ----------------------> b = a + b in 3 ----------------------> 5
17:24:49 <lambdabot>   <no location info>: parse error on input `---------------------->'
17:24:55 <JoeyA> pff
17:25:11 <monochrom> you missed an "a"
17:25:20 <JoeyA> > let a ----------------------> b = a + b in 3 ----------------------> 5
17:25:21 <lambdabot>   8
17:25:32 <JoeyA> > let (---------------------->) b = (+ b) in 3 ----------------------> 5
17:25:33 <lambdabot>   8
17:25:36 <JoeyA> Fixed :P
17:27:19 <JoeyA> > let f (a :-) b) = a + b in undefined
17:27:20 <lambdabot>   <no location info>: parse error on input `)'
17:27:24 <JoeyA> (thought so)
17:29:24 <dcoutts_> donri: cabal test got an overhaul and is now relatively useful
17:29:43 <dcoutts_> donri: are you looking at the old test hook, or the new test suite support?
17:30:05 <dmwit> > let ~a ~> ~b = a + b in 3 ~> 5
17:30:06 <lambdabot>   8
17:30:53 <donri> dcoutts_, duno, reading the user guide and running latest haskell-platform. none of the common test tools seem to integrate with cabal-test? i'm currently using exitcode-stdio and had to add exitFailure myself
17:31:05 <hjulle> Btw, what would be a good name for the "as"-function?
17:31:07 <donri> doesn't look like hunit supports "detailed"
17:31:53 <dcoutts_> donri: right, the detailed one is not yet in any release, and so there's no glue code yet for hunit or QC
17:32:18 <dcoutts_> donri: it was done initially last year as a GSoC project, and it's only now maturing
17:32:27 <donri> aha
17:32:30 <hjulle> dmwit: What does the ~:s before the variables do?
17:33:19 <dmwit> hjulle: It's an irrefutable match; it says to avoid evaluating the argument even far enough to check that it matches the pattern.
17:33:24 <dmwit> For these patterns it's a bit silly, but consider
17:33:42 <dmwit> > let f ~(Just x) = 3 in f Nothing
17:33:43 <lambdabot>   3
17:33:55 <hjulle> aha
17:34:05 <ddarius> Because a variable pattern is already irrefutable.
17:34:45 <hjulle> so, a ~-pattern does always match?
17:34:49 <dmwit> yes
17:35:00 <dmwit> Hence the term "irrefutable".
17:35:24 <shachaf> dmwit: Well, the match actually *can* be refuted...
17:35:56 <Jafet> > let a ‑> b = map (second (`lookup` b)) a in [(1,2), (3,4)] ‑> [(2,3), (3,4), (4,5)]
17:35:57 <lambdabot>   [(1,Just 3),(3,Just 5)]
17:35:58 <hjulle> I don't know what irrefutable means though...
17:36:09 <ddarius> If you change the definition of refuting a match.
17:38:31 <hjulle> Jafet: Why is that not a syntax error?
17:39:03 <Jafet> Because it wasn't gibberish
17:39:08 <JoeyA> Is that the -XImpregnableDependencies module at work?
17:39:12 <JoeyA> err, extension
17:39:30 <rwbarton> "‑>" starts with a unicode character.  I can tell, because it looks terrible in my terminal's font.
17:39:47 <JoeyA> > map ord "‑>"
17:39:48 <lambdabot>   [8209,62]
17:39:58 <JoeyA> evil
17:40:05 <JoeyA> > map ord "-‑"
17:40:06 <lambdabot>   [45,8209]
17:40:22 <JoeyA> > "‑>"
17:40:23 <lambdabot>   "\8209>"
17:41:07 <hjulle> ah, thats cheating...
17:41:27 <Jafet> I wonder if you made a library with names like these
17:41:48 <Jafet> Also cyrillic a's
17:42:46 <hjulle> Jafet: It would probably be very appreciated. ^^
17:42:55 <Jafet> > heаd []
17:42:56 <lambdabot>   Nothing
17:43:18 <hjulle> > head []
17:43:19 <lambdabot>   *Exception: Prelude.head: empty list
17:43:48 <hjulle> map ord "> heаd []"
17:43:53 <hjulle> > map ord "> heаd []"
17:43:54 <lambdabot>   [62,32,104,101,1072,100,32,91,93]
17:44:09 <Jafet> > "heаd []"
17:44:09 <lambdabot>   "he\1072d []"
17:47:34 <elliott> If I feel vaguely uneasy using Int and check explicitly that a small but representative sample of the data-set doesn't overflow it, I should just use Integer, right? :-P
17:48:01 <JoeyA> I cast my vote for Int64
17:48:12 <Clint> @src draw
17:48:12 <lambdabot> Source not found. You type like i drive.
17:48:44 <elliott> JoeyA: I'm on 64-bit. That is literally Int.
17:49:12 <elliott> Hmm, I guess it would be very unlikely if it overflowed an Int, considering the magnitude of it.
17:49:17 <Clint> why would the pattern [t] not match but (t:ts) match?
17:49:32 <JoeyA> elliott: But if you're writing code intended to be portable, Int isn't guaranteed to be that big (particularly on 32-bit systems)
17:49:51 <Saizan> [t] only matches singleton lists
17:49:57 <JoeyA> I'd say Int64 if it mattered to me.
17:50:04 <monochrom> > case "x" of [t] -> t
17:50:04 <lambdabot>   'x'
17:50:08 <monochrom> works for me
17:50:12 <JoeyA> But Int is pretty decent for indexes of things in memory, given the 32-bit address space.
17:50:34 <JoeyA> > case "xyz" of [t] -> t
17:50:35 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
17:50:37 <elliott> JoeyA: That's true. But then I'd have to use Data.ByteString.Char8.readInteger, which might be, like, whole milliseconds slower.
17:50:43 <JoeyA> > case "xyz" of (t:ts) -> t
17:50:44 <Clint> Saizan: thanks
17:50:44 <lambdabot>   'x'
17:50:54 <elliott> JoeyA: I don't really care about portability that much.
17:51:28 <JoeyA> I'd recommend sticking with Int if you'll be working with objects that fit in memory.
17:51:44 <JoeyA> But you probably shouldn't take recommendations from a quack like me.
17:52:05 <elliott> JoeyA: They aren't measuring object sizes or indices in this case.
17:53:47 <JoeyA> Then use your own judgment.  I'm just not a fan of using Integer just to feel cozy, given its worse performance and gmp dependency.  maxBound :: Int64 is pretty darn big.
17:53:49 <ddarius> A millisecond is an extremely long time.
17:53:57 <JoeyA> Indeed
17:54:13 <JoeyA> (for a single operation, that is)
17:54:26 <JoeyA> (not that Integer operations take that long)
17:54:34 <ddarius> Depends on the Integer.
17:54:42 <elliott> gmp doesn't bother me, but I'm dealing with a large data set, so performance does.
17:54:44 <JoeyA> heh
17:54:47 <elliott> I'm sure I'll be fine with Int.
17:56:04 <JoeyA> One other thought (again, I'm a quack): if you're keeping large data sets in memory, you're Doing It Wrong (tm), at least from an idealistic perspective.
17:56:14 <JoeyA> But if you have that much RAM to throw around, go nuts.
17:56:52 <elliott> JoeyA: I'm not keeping it in memory.
17:57:05 <elliott> JoeyA: I'm just saying that Integer is slow, Int is fast, and I'm running this over a lot of data (many gigabytes).
17:57:11 <elliott> So I'll take any micro-optimisation :-P
17:57:29 <kmc> Integers that would fit in Int are special-cased
17:57:30 <ddarius> Gigabytes?  Pssh.
17:57:33 <kmc> they might not be that much slower
17:57:48 <ddarius> Correctness?  Pssh.
17:57:48 <kmc> (they also might be much slower, if the Int version is getting unboxed)
17:59:04 <elliott> ddarius: Hey, I said many gigabytes (it's about eight hundred of 'em).
17:59:16 <elliott> It's not very big, but I'll still take a millisecond's improvement.
17:59:36 <elliott> kmc: Yeah; it did add quite a bit in my tests, though.
17:59:51 <monochrom> not convinced that it's productive to argue over this
18:00:10 <elliott> We're arguing?
18:00:34 <monochrom> I think so
18:00:49 <JoeyA> Have you done the necessary philosophical optimizations?
18:00:53 * ddarius tries to think of how to mix English and Hebrew into a single word.
18:00:54 <JoeyA> Like "how did I get here?"
18:01:13 <JoeyA> ddarius: I think the Yiddish figured that out a long time ago.
18:01:15 <ddarius> JoeyA: Well, your mother and your father ...
18:01:43 <JoeyA> your parents?
18:02:27 <monochrom> Alephnull is likely English and Hebrew in one word
18:02:29 <ddarius> JoeyA: I doubt my parents had anything to do with you getting here.
18:02:42 <JoeyA> lol
18:02:54 <ddarius> Hebrew and German.
18:03:09 <hjulle> ddarius: Your parents?
18:03:16 <hjulle> ;-)
18:03:48 <JoeyA> Germanwordsstapledtogether can be, I've been told.
18:04:04 <JoeyA> (err, observed)
18:04:16 <JoeyA> Nobody's flat-out said that to me.
18:04:47 <hjulle> JoeyA: so can swedish words too
18:05:17 <hpaste> donri pasted “HTF fails to install, ghc: could not execute: cpphs” at http://hpaste.org/52600
18:05:22 <JoeyA> I wish I knew a second language like all the cool kids...
18:05:34 <donri> ideas welcome
18:05:59 <JoeyA> donri: which cpphs
18:06:06 <JoeyA> Do you have your ~/.cabal/bin in your PATH?
18:06:22 <JoeyA> For me, it's at /home/joey/.cabal/bin/cpphs
18:06:46 <JoeyA> What's cabal-dev?
18:07:04 <donri> directory-local cabal-install
18:10:07 <hjulle> What is the easiest way to trace the source of an exception?
18:10:11 <donri> fun: fedora installed a ghc-cpphs package for me, but it only includes the library
18:10:55 <monochrom> @where stacktrace
18:10:55 <lambdabot> I know nothing about stacktrace.
18:10:59 <JoeyA> The best way to install Haskell is to start with absolutely nothing at all, and run cabal install ...
18:11:01 <monochrom> @where stack
18:11:01 <lambdabot> I know nothing about stack.
18:11:05 <monochrom> @where callstack
18:11:05 <lambdabot> I know nothing about callstack.
18:11:15 <hjulle> :P
18:11:15 <monochrom> I forgot the keyword
18:11:16 <JoeyA> You'll need a fixpoint combinator to do that, though.
18:11:22 <kmc> @where rts-xc
18:11:22 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
18:11:27 <mantovani> I'm reading the book
18:11:34 <monochrom> that one
18:11:37 <mantovani> but I don't know answer this question ,http://nopaste.snit.ch/87312
18:12:02 <JoeyA> http://nopaste.snit.ch/87312 (repasting so lazy people like me can click on it)
18:12:08 <monochrom> the problem is that if I could remember the "xc" part I wouldn't need a reminder
18:12:08 <mantovani> ion: ^
18:12:10 <mantovani> ^^
18:12:50 <donri> aah there's a separate "cpphs" package
18:13:06 <mantovani> I did the exercise 2 and 3
18:13:08 <mantovani> very easy
18:13:09 <mantovani> but this one...
18:13:14 <JoeyA> mantovani: For one, it can't launch missiles.
18:13:17 <monochrom> what is "3 comments"?
18:13:30 <mantovani> this is the book real world haskell
18:13:38 <mantovani> I think it is avariable online
18:13:41 <mantovani> and the people can comment
18:13:52 <mantovani> I download the pdf version
18:14:06 <JoeyA> (assuming things like unsafePerformIO and unsafeCoerce aren't used)
18:14:29 <hjulle> monochrom: How would I do it from ghci?
18:14:45 <mantovani> I"m just a newbie with a book, with a question to solve..
18:15:05 <mantovani> "What are a few things that this function clearly
18:15:06 <mantovani> cannot do?"
18:15:10 <monochrom> but parametricity says that there exists i such that for all list xs of length at least i+1, f xs = xs !! i
18:15:31 <mantovani> what monochrom ?
18:16:07 <monochrom> why is suddenly everyone caring about me?
18:16:13 <JoeyA> mantovani: The key thing to notice is that, because [a] -> a is polymorphic in a (without contexts, e.g. (Eq a) => ) the function can't do anything *to* those values.
18:16:18 <JoeyA> It can only marshal them around.
18:16:31 <monochrom> but I forgot how to do debugging etc in ghci. I only know that it can be done. read the user guide
18:17:07 <hjulle> Which user guide?
18:17:28 <JoeyA> mantovani: There's a simple logical reason why: for that function to work with lists of *any* type a, it can't do type-specific things like add them up, etc.
18:17:35 <mantovani> JoeyA: this section is about polymorphic ^^
18:17:47 <monochrom> and by "there exists i such that for all list xs of length at least i+1, f xs = xs !! i" I mean for example if you have tested that f [3,1,4] gives you 1 (the 2nd item) then f [x,y,z,t] gives you y (the 2nd item again)
18:17:52 <JoeyA> mantovani: For example, what could foo :: [Int] -> Int do that bar :: [a] -> a can't?
18:18:00 <hjulle> The glorious one?
18:18:11 <mantovani> math operations ?
18:18:14 <JoeyA> correct
18:18:18 <JoeyA> foo = sum
18:18:25 <JoeyA> :t sum :: [Int] -> Int
18:18:25 <lambdabot> [Int] -> Int
18:18:32 <JoeyA> :t sum :: [a] -> a
18:18:32 <mantovani> sorry but what means :t ?
18:18:33 <lambdabot>     Could not deduce (Num a) from the context ()
18:18:33 <lambdabot>       arising from a use of `sum' at <interactive>:1:0-2
18:18:33 <lambdabot>     Possible fix:
18:18:42 <mantovani> I"m just in the 2 cap
18:18:56 <JoeyA> mantovani: It tells the lambdabot IRC bot to tell us the type of something.
18:19:00 <JoeyA> :t foldr
18:19:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:19:05 <mantovani> humm
18:19:11 <JoeyA> :t 2+2
18:19:12 <lambdabot> forall t. (Num t) => t
18:19:13 <mantovani> I know what mens the arrows
18:19:13 <monochrom> sorry, I erred. it won't always give you the 2nd item.
18:19:25 <JoeyA> mantovani: Which arrows?
18:19:28 <mantovani> JoeyA: ->
18:19:32 <JoeyA> The arrows in [Int] -> Int ?
18:19:35 <mantovani> I know what it means
18:19:50 <JoeyA> (a -> b -> b) -> b -> [a] -> b uses the same arrows, and they mean the same thing.
18:19:53 <mantovani> JoeyA: can you see my program of the b question ?
18:20:00 <mantovani> just to check it ?
18:20:33 <mantovani> http://nopaste.snit.ch/87316
18:20:35 <mantovani> the problem
18:20:42 <mantovani> and the question,
18:20:47 <monochrom> if you have tested that f [3,1,4] gives you 1 (the 2nd item), then f [x,y,z] gives you y (the 2nd item). it's important that the length is 3 throughout. if the list has a different length, the function may pick another item.
18:20:58 <JoeyA> A simpler name would be penultimate :-)
18:21:03 <JoeyA> @google penultimate
18:21:05 <lambdabot> http://itunes.apple.com/us/app/penultimate/id354098826?mt=8
18:21:05 <lambdabot> Title: Penultimate for iPad on the iTunes App Store
18:21:08 <JoeyA> ...
18:21:15 <JoeyA> @google define:penultimate
18:21:15 <lambdabot> http://itunes.apple.com/us/app/penultimate/id354098826?mt=8
18:21:15 <lambdabot> Title: Penultimate for iPad on the iTunes App Store
18:21:17 <mantovani> http://nopaste.snit.ch/87317
18:21:19 <JoeyA> ........
18:21:24 <mantovani> JoeyA: this is the problem ^
18:21:48 <monochrom> JoeyA: 13 comments? No comments? :)
18:22:00 <mantovani> the pdf is just web copy...
18:23:04 <JoeyA> mantovani: Your function guards against the length being too long.  I don't think they expected you to do that.
18:23:20 <JoeyA> Also, lastButOne's type signature is [a] -> [a], rather than [a] -> a
18:23:39 <mantovani> let me try fix it
18:23:40 <JoeyA> You can't return an empty list using the latter type.
18:23:42 <mantovani> to [a] -> a
18:23:52 <mantovani> what is latter type ?
18:24:06 <JoeyA> latter type?  What do you mean?
18:24:11 <JoeyA> That's the type of last
18:24:16 <mantovani> ok
18:24:31 <JoeyA> It takes a list of items of type a, and returns a value of type a.
18:24:38 <JoeyA> > let penultimate = last . init in penultimate [1..5]
18:24:39 <lambdabot>   4
18:24:44 <JoeyA> > let penultimate = last . init in penultimate [1..2]
18:24:46 <lambdabot>   1
18:24:52 <JoeyA> > let penultimate = last . init in penultimate [1..1]
18:24:53 <lambdabot>   *Exception: Prelude.last: empty list
18:25:02 <rwbarton> You're probably intended to write this function using pattern matching and recursion
18:25:15 <JoeyA> Yeah, what he said.
18:25:26 <mantovani> JoeyA: but the book didn't teach recursion yeat
18:25:40 <JoeyA> oh
18:26:01 <mantovani> JoeyA: how can I change the [a] -> [a] to [a] -> a ?
18:26:20 <mantovani> I try take off the [] in the "then" and in the "else" but din't work =/
18:26:35 <mantovani> because the head function returns a char
18:26:39 <mantovani> -> a
18:27:02 <mantovani> in the theory I just remove the [head .. ]
18:27:05 <JoeyA> mantovani: There's a fundamental reason you can't: you can't return "nothing" instead of a.
18:27:07 <mantovani> around the head
18:27:21 <mantovani> humm
18:27:37 <mantovani> JoeyA: in this away if you give [1] as parameter its returns []
18:27:40 <mantovani> because the else
18:27:40 <JoeyA> Your function, if it's of type [a] -> a, *has* to return a single value (or otherwise fail)
18:27:48 <mantovani> ok
18:27:59 <JoeyA> mantovani: Right, with the [a] -> a signature, you don't get to fail that way.
18:28:47 <JoeyA> You could use error, e.g. penultimate xs = if length xs >= 2 then head (...) else error "penultimate: List too small"
18:28:47 <mantovani> http://nopaste.snit.ch/87318
18:28:53 <mantovani> I'm trying get this assinagure
18:29:02 <mantovani> humm
18:29:04 <mantovani> good ideia
18:29:13 <JoeyA> mantovani: An empty string has a completely different type.
18:29:28 <JoeyA> That might type check, but if it does, it'll be weird
18:29:33 <mantovani> ok
18:30:03 <JoeyA> You want a function of type [a] -> a, but you'll get ??? -> [Char]
18:30:05 <mantovani> works!
18:30:23 <mantovani> http://nopaste.snit.ch/87322
18:30:38 <JoeyA> mantovani: Yup
18:30:41 <mantovani> thank yoo very mych JoeyA
18:30:47 <mantovani> haskell is my third programming language
18:30:54 <mantovani> my first functional pure
18:31:04 <mantovani> very hard for the first look
18:31:09 <JoeyA> Bear in mind that length xs forces the whole list.  You can use pattern matching to make it faster (which I guess you'll learn about later).
18:31:54 <mantovani> http://book.realworldhaskell.org/read/types-and-functions.html
18:31:58 <mantovani> I'm in this charapeter
18:32:04 <mantovani> chapter*
18:32:08 <JoeyA> mantovani: Here's what I've learned about Haskell, and to a lesser extent programming in general: Implementation code is hard to read, and will always be hard to read.  However, types in Haskell are a beautiful way to organize code.
18:32:31 <JoeyA> @pl \a b c d -> a - zipWith (+) b d
18:32:31 <lambdabot> (const .) . (. zipWith (+)) . (.) . (-)
18:33:02 <JoeyA> Don't think you have to be a Haskell whiz to read that.  Nobody can (at least not at a glance).
18:33:08 <JoeyA> (except maybe some people...)
18:33:38 <mantovani> when I start with Perl I can't read the golf-code too
18:33:41 <mantovani> like
18:33:54 <mantovani> perl -nE '}{say$.' < 'foo.txt'
18:34:06 <mantovani> count the lines of a file
18:34:09 <JoeyA> Programming is messy business.  Types and functions and such are just a nice way to organize code.
18:34:31 <JoeyA> (and to verify it's correctness, in statically-typed languages)
18:34:43 <mantovani> static and strong
18:35:16 <JoeyA> mantovani: Short Haskell code is often easy to read.  Apparently, *all* Perl code is hard to read :P
18:35:28 <mantovani> hahahaha
18:35:47 <JoeyA> To count the lines of input in Haskell: main = getContents >>= print . length . lines
18:35:55 <mantovani> JoeyA: modern perl is pretty easy do read
18:36:35 <mantovani> https://github.com/mantovani/Correios/blob/master/lib/Correios/Send/Mail.pm
18:36:42 <mantovani> very cleary ^
18:37:39 <JoeyA> use Moose; <-- What does that do?  :D
18:38:02 <Rotaerk> mantovani, what language is that
18:38:05 <JoeyA> I agree, that is very clear.
18:38:08 <monochrom> two write-only languages are perl and latex. indeed you can see how that pans out in their respective niches
18:38:11 <JoeyA> Rotaerk: perl
18:38:13 <mantovani> this is a modern OOP for Perl
18:38:17 <mantovani> this is fucking insane
18:38:19 <mantovani> wait a moment
18:38:22 <Rotaerk> it's kind of scary
18:38:31 <mantovani> it is pretty insane
18:38:40 <monochrom> i.e., does any mathematician maintain their math paper latex code like you maintain code?
18:38:43 <mantovani> https://metacpan.org/module/Moose::Manual
18:38:45 <mantovani> JoeyA: ^
18:38:58 <JoeyA> Here's some reasonable-ish Haskell code for mail: http://hackage.haskell.org/packages/archive/ismtp/3.0.1/doc/html/src/Network-Smtp-Session.html
18:39:04 <JoeyA> err, readable-ish *
18:39:10 <mantovani> let me check it
18:39:16 <mantovani> hahaah
18:39:21 <mantovani> I can't read this
18:39:22 <mantovani> :P
18:39:22 <JoeyA> (it actually implements the protocol, rather than using sendmail)
18:39:29 * mantovani too noob
18:39:47 <mantovani> humm
18:40:19 <mantovani> JoeyA: did you see what is moose ?
18:40:24 <mantovani> just OOP concepts
18:40:34 <JoeyA> Interesting
18:40:40 <mantovani> https://metacpan.org/module/Moose::Manual::Concepts
18:40:52 <mantovani> I like perl because all modules have very cool manual
18:41:03 <mantovani> and perl have almost 100K modules
18:41:39 <JoeyA> mantovani: Haskell's pretty good about that, too: http://hackage.haskell.org/packages/archive/pkg-list.html
18:42:22 <JoeyA> Documentation with Haddock looks pretty nice: http://hackage.haskell.org/packages/archive/acme-missiles/0.1.0.0/doc/html/Acme-Missiles.html
18:42:33 <mantovani> hahaha
18:42:34 <JoeyA> It's easy to get the hang of, too.
18:42:44 <mantovani> I love ACME modules
18:42:56 <mantovani> how can I install this modules ?
18:43:00 <JoeyA> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:acme
18:43:02 <mantovani> there is "cpan" from haskell ?
18:43:03 <JoeyA> cabal install ...
18:43:07 <mantovani> very nice!
18:43:11 <JoeyA> e.g. cabal install acme-missiles
18:43:37 <mantovani> I'm design a web crawler framework
18:43:45 <mantovani> this is why I start studing haskell
18:43:54 <monochrom> after reading Ken Shan's comment on Dart, and through the long time influence of conal, I am beginning to think that readability is equivalent to denotativity, i.e., how readable equals how denotative
18:43:56 <mantovani> I think I'll do the backend in haskell
18:44:02 <mantovani> and the frontend in Perl
18:44:22 * mantovani installing canal
18:44:43 <Cale> Ghost OP
18:44:45 <mantovani> JoeyA: see this insane module https://metacpan.org/module/AAAAAAAAA
18:44:47 <JoeyA> mantovani: If you're just now learning Haskell, don't start working on projects with deadlines in it just yet.
18:44:56 <JoeyA> lol
18:44:59 <mantovani> JoeyA: this is a personal project
18:45:05 <DukeDave> Erm, how does this work? http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
18:45:13 <monochrom> even conventional imperative languages can be quite readable because "x:=x+1" denotes a simple state-transition function and if you have "x:=x+1; x:=x+1" you just compose, that's it.
18:45:19 <mantovani> they transform all your souce code in "AAAAAA..."
18:45:26 <JoeyA> I think that joke came from Uncyclopedia: http://uncyclopedia.wikia.com/wiki/AAAAAA!
18:45:27 <mantovani> and the program still works
18:45:28 <DukeDave> I.e. How does it type check, without knowing the number of args ?
18:45:38 <mantovani> yoy can't JoeyA this is a compiler exercise
18:45:55 <mantovani> just put "use AAAAAAAAA;"
18:46:06 <mantovani> in the beggining of your program
18:46:14 <mantovani> and all the source code will be come AAAA
18:46:18 <mantovani> everything
18:46:23 <mantovani> and it will compile
18:46:23 <JoeyA> Will it still work?
18:46:24 <mantovani> hehe
18:46:26 <mantovani> yes
18:46:28 <JoeyA> lol
18:46:31 <JoeyA> figure
18:46:31 <mantovani> very very insane
18:46:33 <JoeyA> figures*
18:46:42 <Saizan> DukeDave: it's going to accept any number of arguments you're giving it, and complain at runtime if the format string doesn't use that many
18:46:57 <shachaf> unsafeEvilPrintf
18:47:10 <JoeyA> Yeah, Haskell has a lot of catching up to do as far as the Acme namespace is concerned.
18:47:13 <DukeDave> I'm a little confused how it fits in to the type system though?
18:47:14 * mantovani doing canal update
18:47:20 <DukeDave> I mean, it doesn't use TH, right?
18:47:27 <shachaf> DukeDave: Look at the source.
18:47:29 <Saizan> no, it uses typeclasses
18:47:36 <Saizan> but yeah, look at the source
18:47:45 <shachaf> @source Text.Printf
18:47:45 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
18:47:58 <JoeyA> http://hackage.haskell.org/package/acme-now is a good example of a joke that only makes sense in Haskell.
18:47:59 * shachaf sighs at Content-Type.
18:48:09 <monochrom> hehe
18:48:11 <shachaf> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Text-Printf.html
18:48:21 <mantovani> JoeyA: let the cabal finish the update
18:49:21 * ddarius Referrers shachaf to an RFC.
18:49:23 <kmc> JoeyA, i liked your acme-missiles package
18:49:30 <JoeyA> thanks
18:49:42 <KirinDave> I too liked it.
18:49:47 <JoeyA> Is there a way to safely launch one salvo of missiles from STM?
18:50:03 <JoeyA> ("safely" is quite a stretch...)
18:50:14 <ddarius> People always think of printf backwards.
18:51:00 <monochrom> atomically fission
18:51:28 <JoeyA> Ah, I suppose there should be an Acme.Missiles.Fusion
18:52:33 <mantovani> JoeyA: http://nopaste.snit.ch/87327
18:52:46 <shachaf> ddarius: Fine.
18:52:51 <kmc> from STM you can't launch missiles, only bombers
18:52:52 <JoeyA> mantovani: Hmm...
18:52:53 * shachaf sighs at his stupid browser's handling of Content-Types.
18:52:55 <JoeyA> @hoogle void
18:52:56 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
18:52:58 <kmc> because bombers can be recalled
18:53:07 <JoeyA> mantovani: Really old ghc, perhaps?
18:53:20 <SubaruFre> Hosted a bunch of software on my webserver if anyones interested, business package hosting so unlimited bandwidth/250tb of space, lol...regardless, just hit the downloads section at http://www.subarufreaks.com you don't have to actually care about the subarus, its just my domain name lol
18:53:21 <mantovani> Glasgow Haskell Compiler, Version 6.12.3, for Haskell 98, stage 2 booted by GHC version 6.12.3
18:53:24 <JoeyA> (more precisely, base)
18:53:28 <JoeyA> Hmm, that's not too old
18:53:38 <mantovani> I'm usibing ubuntu 11.04
18:53:39 <ddarius> Just like in Dr. Strangelove.
18:53:42 <kmc> right
18:53:48 <kmc> that's a bug in the STM implementation
18:54:05 * hackagebot augeas 0.5.0 - A Haskell FFI wrapper for the Augeas API  http://hackage.haskell.org/package/augeas-0.5.0 (JudeNagurney)
18:54:13 <JoeyA> Indeed, void was introduced in 4.3.0.0.  I didn't know that.
18:54:30 <mantovani> JoeyA: http://nopaste.snit.ch/87328
18:54:35 <mantovani> complete -v
18:54:47 <shachaf> "void" is taken. :-(
18:55:11 <ddarius> "Please download my trojans."
18:55:26 --- mode: ChanServ set +o monochrom
18:55:31 --- mode: monochrom set +b *!*@71.184.161.32
18:55:31 --- kick: SubaruFre was kicked by monochrom (SubaruFre)
18:55:42 <mantovani> JoeyA: acme-now worked
18:55:58 <mantovani> how can I use that ?
18:56:08 <mantovani> :load acme-now
18:56:11 <monochrom> evaluate "now", get a time
18:56:23 <monochrom> read the doc for more details
18:56:24 <ddarius> get -the- time
18:57:43 <mantovani> monochrom: how I load it ?
18:58:26 <monochrom> oh, one moment
18:58:53 <mantovani> ok
18:58:54 <ingy> anyone know an easy way to get cabal to build over 7.2.1?
18:59:00 <monochrom> :load Acme.Time.Now
18:59:09 <monochrom> then ask for "now"
18:59:41 <monochrom> yes, see the topic, first item
19:00:05 <mantovani> monochrom: http://nopaste.snit.ch/87329
19:00:25 <monochrom> sorry, not :load
19:00:35 <monochrom> :module + Acme.Time.Now
19:00:56 <mantovani> worked :)
19:01:01 * elliott hopes mantovani is not actually trying to use Acme.Time.Now.
19:01:36 <shachaf> ingy: 7.2.1 is considered a "technology preview" release, I think.
19:02:04 <shachaf> Unless there's a good reason you want to use it, you might best off waiting for the release of 7.4.
19:02:16 <mantovani> now I have my forever now time
19:02:20 <mantovani> I stoped the time ?
19:02:23 <mantovani> >:)
19:02:43 <mantovani> thank you monochrom and JoeyA
19:04:09 <ingy> shachaf: if you've followed any of my drama in #perl6 I think it's the only option :)
19:04:22 <shachaf> ingy: Ah, I haven't.
19:04:44 <ingy> shachaf: basically < 7.2 doesn't work on some kernels
19:04:58 <shachaf> Really? What kernels?
19:05:06 <ddarius> Haskell: It's The Only Way To Do It
19:05:13 <ingy> bug 5005
19:05:15 <shachaf> Oh, was this moritz's thing with issue 5500?
19:05:21 <shachaf> Oh, 5005.
19:05:26 <monochrom> then again perl6 is also a kind of technology preview
19:05:32 <ingy> :P
19:06:58 <shachaf> ingy: He's using a pre-2.6.27 Linux?
19:07:14 <mantovani> ingy: are u perl6 core developer ?
19:07:23 <ingy> no
19:07:57 <ingy> I hack on various things in perl 6 from time to time
19:08:16 <QinGW> What language is used to develop perl6?
19:08:28 <mantovani> C, javascript, haskell
19:08:29 <mantovani> a lot
19:08:30 <shachaf> English.
19:08:34 <ingy> there are over 6 completely different implementations of the Perl 6 spec
19:08:35 <mantovani> perl 6 is a speceficaition
19:08:39 <mantovani> specification*
19:08:40 <ingy> C#
19:08:53 <mantovani> flavio glock implemented perl 6 using javascript
19:08:55 <dylukes> Pugs, Rakudo...
19:08:57 <mantovani> >:)
19:09:07 <mantovani> (not all, but he did)
19:09:31 <ingy> yes
19:09:50 <ingy> audreyt was into js as a future back in 06
19:10:03 <shachaf> ingy: Does GHC 6.12 work on the old kernels?
19:10:18 <mantovani> audreyt implemented 90% of perl 6 in one weekend
19:10:21 <ingy> shachaf: there are different problems
19:10:23 <mantovani> this is true ingy ?
19:10:37 <ingy> not true
19:10:58 <mantovani> ops is she
19:11:10 <mantovani> but she did a perl6 in haskell ?
19:11:12 <ingy> but audreyt is capable of things beyond delief
19:11:17 <ingy> belief
19:11:22 <ingy> yes
19:11:33 <ingy> that is what I am reviving now
19:11:39 <mantovani> cool
19:11:54 <mantovani> I meet larry wall in this year
19:11:56 <ingy> audrey and I are old anc close friends
19:11:58 <mantovani> he if fucking cool
19:12:04 <mantovani> niec
19:12:06 <mantovani> nice*
19:12:11 <shachaf> ingy: I went through the Pugs code yesterday and fixed almost all of the deprecation warnings, by the way.
19:12:23 <ingy> mantovani: I'm staying at his house next Tuesday night
19:12:27 <ingy> :D
19:12:39 <mantovani> she drink ?
19:12:55 <ingy> shachaf++
19:13:07 <ingy> mantovani: Larry's house
19:13:18 <ion> < mantovani> ion: ^
19:13:20 <ion> Huh?
19:13:28 * mantovani envy
19:13:43 <dylukes> Why all the envy for meeting people who designed/invented languages?
19:13:51 <ingy> it's just a house :)
19:13:51 <dylukes> You can email any one of them and strike up a conversation if you want.
19:13:53 <elliott> ingy: Oh, are you the person to blame for surprising me when a new Pugs came out on Hackage?
19:14:07 <dylukes> Wait. Pugs updated?
19:14:11 <mantovani> ingy: I don't think so
19:14:12 <ingy> elliott: no
19:14:12 <mantovani> :P
19:14:17 <mantovani> it is not just a house :P
19:14:29 <ingy> :)
19:14:59 <mantovani> https://www.facebook.com/photo.php?fbid=1802281849834&set=a.1802281329821.2094799.1023460091&type=3&theater
19:15:34 <mantovani> he is the guy :P
19:15:53 <ingy> :)
19:16:01 <ingy> where was that at?
19:16:13 <JoeyA> In a Haskell package, is it safe to switch from a 4-digit version number to a 3-digit one?
19:16:16 <dmwit> When byorgey told me about superclass equality constraints, I scoffed that they would hardly ever be useful. Now I want them all the time. =(
19:16:16 <shachaf> preflex: seen audreyt
19:16:17 <preflex>  audreyt was last seen on #perl 1 year, 81 days, 6 hours, 55 minutes and 19 seconds ago, saying: someone sent me this in pvt ?    < yugio> DCC SEND startkeylogger 0 0 0   < what is this?  ..
19:16:21 <JoeyA> If so, does that require a major version bump?
19:16:24 <dmwit> Why did I have to learn about this??
19:16:29 <edenc> ingy: do you realize you have my name tatooed on your arm?
19:16:33 <pchiusano> Cale: you around?
19:16:38 <mantovani> ingy: was a Perl Workshop in São Paulo Brazil
19:16:39 <dylukes> mantovani: I've never met Larry, but: https://fbcdn-sphotos-a.akamaihd.net/hphotos-ak-snc3/13033_1262338523191_1371563053_747354_181892_n.jpg
19:16:39 <kfish> JoeyA, x.y.z implies x.y.z.0
19:16:42 <dylukes> Best I can do haha.
19:16:44 <JoeyA> Thanks
19:16:49 <dylukes> This was from a couple years ago.
19:16:58 <ingy> edenc: I believe you
19:17:20 <ingy> mantovani: where do you hail from?
19:17:46 <mantovani> what ?
19:17:54 <ingy> where d you live
19:18:02 <mantovani> brazil
19:18:08 <mantovani> with edenc
19:18:13 <edenc> ugh, no
19:18:18 <edenc> he lives quite far from me
19:18:20 <mantovani> but (far way)
19:18:27 <ingy> I am planning to visit flavio soon
19:18:39 <mantovani> flavio lives in amsterdam, right ?
19:18:39 <edenc> flavio's in amsterdam
19:18:41 <ingy> he does not know this yet ;)
19:18:47 <edenc> he works for booking.com now
19:18:54 <ingy> oh, I heard he was at booking
19:18:55 <edenc> well, has been working for about 2 years
19:19:00 <mantovani> ingy: you can go here, edenc host you in him house
19:19:04 <mantovani> you are welcome!
19:19:11 <ingy> dang, I was at booking 2 weeks ago
19:19:24 <ingy> mantovani: sounds good
19:19:30 <mantovani> if he didn't I do :)
19:19:32 <mantovani> you are welcome
19:19:33 <Cale> pchiusano: hhi
19:19:34 <Cale> hi*
19:19:46 <ingy> you guys ever heard of kragen?
19:19:54 <edenc> nope
19:19:56 <mantovani> nope
19:19:58 <mantovani> what is it ?
19:20:23 <ingy> he's a hacker from SF living in Buenos
19:20:34 <JoeyA> mantovani: You should be able to cabal install acme-missiles now.  Thanks for letting me know about it not building on GHC pre-7.
19:20:48 <mantovani> JoeyA: do I have to update cabal before ?
19:20:54 <JoeyA> I think so.
19:21:01 <mantovani> let me try, one moment
19:21:23 <edenc> ingy: we have a problem in brazil, and I dare say south america
19:21:43 <edenc> communities don't bond very well because everyone is mostly caring about their own business
19:21:50 <ingy> mantovani: anyway, looking for people to visit in south america
19:21:51 <JoeyA> Does hackagebot only print when major releases occur?
19:22:11 <mantovani> ingy: you can stay in my house I live 5 minutes from the airport
19:22:13 <ingy> edenc: we'll have to fix that
19:22:17 <mantovani> I can see the airplanes :)
19:22:26 <edenc> ingy: we're trying
19:22:49 <ingy> mantovani: I'll be there sometime in the next 3 months :)
19:23:04 <mantovani> ok, this is my email: daniel.oliveira.mantovani@gmail.com
19:23:45 <edenc> ingy: oh wow, we can probably get a small workshop going
19:23:57 <ingy> mantovani: you've got mail
19:24:01 <edenc> or a tech meeting, or whatever
19:24:05 * hackagebot acme-missiles 0.1.1 - Cause serious international side effects.  http://hackage.haskell.org/package/acme-missiles-0.1.1 (JoeyAdams)
19:24:08 <ingy> edenc: sounds great
19:24:10 <edenc> or just plain beer
19:24:14 <mantovani> yeh!
19:25:02 <ingy> man I con't believe I missed meeting flavio
19:25:26 <ingy> I will likely be back there around xmas
19:25:31 <edenc> he's a nice guy
19:25:33 <mantovani> JoeyA: works!
19:25:40 <JoeyA> yay
19:25:44 <JoeyA> be careful with it.
19:25:44 <mantovani> let me execute
19:25:48 <JoeyA> nooooo!@
19:25:52 <mantovani> ?
19:26:00 * JoeyA finds a fallout shelter
19:26:09 <JoeyA> :-)
19:26:22 <mantovani> how I use that ?
19:26:29 <JoeyA> ghci
19:26:31 <mantovani> :module
19:26:33 <mantovani> ?
19:26:34 <JoeyA> :m Acme.Missiles
19:26:37 <JoeyA> launchMissiles
19:26:43 * ingy goes off to apply the topical patch...
19:26:50 <mantovani> dude, my computer will stop or something like that ?
19:26:55 <JoeyA> No.
19:26:58 <mantovani> ok
19:27:42 <mantovani> JoeyA: it just print a message in my terminal ?
19:27:48 <JoeyA> right.
19:27:50 <JoeyA> that's it
19:27:57 <mantovani> really ????????
19:28:21 <JoeyA> kinda boring.
19:28:33 <mantovani> dude are you serius ?
19:28:34 <mantovani> :P
19:28:51 * JoeyA wonders if it should start killing threads after 15-ish seconds.
19:29:42 <mantovani> everything is normal
19:29:43 <mantovani> o.0
19:31:26 <mantovani> JoeyA: anyway, :P
19:33:45 <elliott> mantovani: You just launched intercontinental missiles.
19:33:46 <elliott> Way to go.
19:34:07 <JoeyA> mantovani: Don't expect it to launch missiles.  Don't expect it to even deliver a payload at all.  All you need to know about launchMissiles :: IO () is that it produces side effects, and Side Effects are Bad.
19:34:36 <ingy> mantovani: Larry Wall just helped me get cabal working on GHC 7.2.1 :)
19:35:13 <JoeyA> heh
19:35:25 <ingy> (I used Larry's old program called patch ;)
19:36:56 <mantovani> humm
19:37:38 <edenc> "man patch" sounds weird
19:38:03 <mantovani> hahahaha
19:38:38 <ddarius> info patch
19:39:05 <mantovani> ingy: larry wall likes a lot of haskell ?
19:39:44 <ddarius> The Perl and Haskell community have a very long history
19:40:00 * mantovani curious
19:40:17 <levi> An early implementation of perl 6 was written in Haskell.
19:40:25 <mantovani> by audrey
19:40:43 <ddarius> levi: Much longer than that.
19:41:48 <levi> I didn't mean to imply that that was the beginning, just a significant point.
19:41:53 <ingy> levi: Pugs (the haskell impl) was the first implementation
19:42:26 <ingy> it had performance issues that are now solved
19:42:33 <ingy> by doing nothing :)
19:42:37 <shachaf> ingy: How did that work?
19:42:41 <ingy> Moore++
19:43:24 <edenc> heh
19:43:27 * ddarius suspects that that should be Marlow++
19:43:45 <shachaf> JaffaCake++ ?
19:44:16 <mantovani> shachaf: syntax error
19:44:16 <Axman6> yeah, I was thinkning the same thing =)
19:44:29 * mantovani kidding
19:44:30 <Axman6> GHC has come a long way in the last few years
19:45:04 <shachaf> GHC 6.6 was the best release.
19:46:02 <desaiu> data BinTree a = Leaf a | Node (BinTree a) a (BinTree a)
19:46:08 <desaiu> What does the | symbol represent?
19:46:27 <shachaf> desaiu: "or", as in a sum type.
19:46:29 <desaiu> How would I find this out without asking in here?
19:46:37 <desaiu> I thought it was Or, but I wasn't sure
19:46:44 <desaiu> || is also or IIRC
19:46:49 <shachaf> desaiu: Read the syntax.
19:46:52 <kmc> a completely different sense of "or"
19:46:53 <shachaf> (||) is completely different.
19:47:06 <kmc> you'd find out by reading a Haskell tutorial or the Report or the Gentle Introduction or the cheat sheet
19:47:10 <desaiu> :t (||)
19:47:11 <lambdabot> Bool -> Bool -> Bool
19:47:15 <desaiu> Ah, that's why
19:47:16 <shachaf> desaiu: http://learnyouahaskell.com/making-our-own-types-and-typeclasses explains it. :-)
19:47:23 <desaiu> :t (|)
19:47:24 <lambdabot> parse error on input `|'
19:47:28 <kmc> it means that a value of type (BinTree a) is built with a Leaf constructor or a Node constructor
19:47:31 <kmc> it's part of the syntax of Haskell
19:47:36 <kmc> it's not an infix operator like (||) is
19:47:58 <desaiu> It's hard to google for symbols and get accurate results
19:48:30 <shachaf> That's why you read an introduction to the syntax of Haskell first. Then you can Hoogle/Hayoo for symbols.
19:49:12 <kmc> @google haskell cheat sheet
19:49:14 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
19:49:14 <lambdabot> Title: Haskell Cheat Sheet
19:49:18 <kmc> desaiu, ^^^^^^
19:49:52 <desaiu> Very nice!
19:50:02 <desaiu> I need a poster of that
19:50:31 <kmc> it's 13 pages
19:50:54 <ingy> shachaf: I don't see your commits :\
19:50:57 <desaiu> Need a large poster of that laminated to my desk
19:52:08 <desaiu> shachaf: Hayoo gives no useful results for |
19:52:14 <kmc> right
19:52:19 <kmc> because it's not a user-defined infix operator
19:52:22 <shachaf> ingy: I didn't commit yet. I'm slightly uncertain about a few of the changes.
19:52:22 <kmc> it's part of the syntax of Haskell
19:52:28 <kmc> you can't Hayoo search for = either
19:52:55 <shachaf> ingy: There are some autogenerated files whose generating scripts I can't find, for instance.
19:53:24 <ingy> shachaf: does 'make -C Pugs' work?
19:54:29 <shachaf> ingy: The build works, yes.
19:54:37 <kmc> @where reserved_symbols
19:54:37 <lambdabot> .. : :: = \ | <- -> @ ~ =>
19:54:49 <ddarius> @where stmt
19:54:49 <lambdabot> I know nothing about stmt.
19:54:54 <kmc> desaiu, ^^^^^ those are all the special symbols in Haskell
19:55:15 <kmc> that list can be found in the Haskell 2010 Report as well
19:56:25 <magicman> ` is special too, right?
19:56:38 <kmc> yes
19:56:50 <kmc> but the grammar in the Report treats it separately
19:56:52 <kmc> good point
19:57:01 <magicman> Ahh, okay.
19:57:14 <kmc> also, if you're reading "Haskell" code which uses GHC extensions, there are a few more things you can run into
19:58:07 <magicman> > take 10 [0, -1 ..]
19:58:08 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
19:58:12 <magicman> Oh, wow.
19:58:16 <ingy> shachaf: and Pugs/pugs runs?
19:58:26 <magicman> > succ (-1)
19:58:27 <lambdabot>   0
19:58:30 <shachaf> ingy: Well, yes.
19:58:36 <kmc> > succ (-1.0)
19:58:37 <lambdabot>   0.0
19:58:43 <ingy> shachaf: I would commit it, at least on a branch
19:59:18 <kmc> well more than a few ;)
19:59:43 <ddarius> > until (uncurry(==)) (id&&&succ) (0.0 :: Float)
19:59:44 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
20:00:02 <ddarius> > until (uncurry(==)) (id&&&succ) (0.0, 1.0) :: (Float, Float)
20:00:03 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
20:00:04 <magicman> > (take 3 [-1, 0 ..], take 3 [0, -1 ..], take 3 [0, 1 ..], take 3 [1, 0 ..])
20:00:05 <lambdabot>   ([-1,0,1],[0,-1,-2],[0,1,2],[1,0,-1])
20:00:30 <shachaf> ingy: I'm not sure about e.g. PUGS_HAVE_PERL5.
20:00:33 <magicman> Ahh, of course.
20:00:52 <ddarius> Also it should be snd&&&(succ.snd)
20:01:24 <ddarius> :t (...)
20:01:25 <lambdabot> Not in scope: `...'
20:02:33 <Jafet> :t (L.…)
20:02:34 <lambdabot> parse error (possibly incorrect indentation)
20:02:36 <kmc> ! -< >- -<< >>- * ∷ ⇒ ∀ → ← ↢ ↣     ★ [| |] $( # (#) ? ?? (| |)
20:02:48 <Jafet> :t L.(…)
20:02:49 <lambdabot> parse error (possibly incorrect indentation)
20:02:51 <kmc> not a comprehensive list
20:03:59 <Jafet> Wait, why doesn't :t work with unicode
20:05:29 <elliott> Jafet: because lambdabot is old and crusty
20:05:54 <Jafet> :t let (☃) = unsafeFreeze in (☃)
20:05:56 <lambdabot> parse error (possibly incorrect indentation)
20:06:02 <shachaf> Jafet: It doesn't even work with Unicode-substitution characters like е. :-(
20:06:02 <ingy> shachaf: does http://moritz.faui2k3.org/svn-search/search.pl?q=audreyt;offset=1720 give a clue?
20:06:29 <ddarius> "Finally, the last section contains a short history, as well as some pretentious remarks of a philosophical nature."
20:09:01 <shachaf> ingy: I'm not sure. I guess I'll commit something and see.
20:09:06 <shachaf> It should work.
20:09:06 <ingy> shachaf: I have an idea
20:09:21 <shachaf> Lines like these in Pugs make me rather wary:
20:09:27 <shachaf> instance (Ord a) => Ord (Tree a) where compare _ _ = EQ
20:09:27 <shachaf> instance Ord (TMVar a) where compare x y = compare (addressOf x) (addressOf y)
20:09:47 <Axman6> heh
20:09:48 <ingy> just commit on a branch and put your concerns in the commit msg, and I'll poke audrey to comment
20:10:01 <Jafet> The latter might have been written by an intern.
20:10:38 <ingy> shachaf: ^^
20:12:02 <ddarius> The latter is fairly sensible except that presumably this address is not guaranteed to be stable.
20:12:39 <ingy> shachaf: I'm off to zzz. See you next week. mantovani, edenc: nice to meet you, see you in future weeks. :)
20:12:42 <shachaf> ddarius: Right.
20:12:59 <edenc> ingy: will be looking forward to it
20:13:00 <kmc> shachaf, you gotta order your locks, man
20:13:00 <ddarius> The Ord a constraint on the Tree instance seems a bit strange.
20:13:58 <kmc> is that addressOf a supported operation on TMVars?
20:14:02 <kmc> or something they hacked in?
20:14:13 <shachaf> kmc: It's implemented in terms of unsafeCoerce#
20:14:18 <mantovani> ingy: nice to meet you too!
20:14:23 <kmc> sigh
20:14:26 <mantovani> ingy: cya
20:14:59 <kmc> it would be okay for vars created in IO to be orderable, right?
20:15:23 <ddarius> kmc: Of course it would be.
20:15:26 <kmc> i'd have to think more about vars created in STM
20:15:39 <ddarius> Not by their addresses though.
20:16:01 <kmc> because of GC, etc?
20:16:15 <ddarius> (Or rather, the garbage collector would be restrained if it was required to maintain that invariant.)
20:17:00 <kmc> i guess the clean way to do this is to pair your vars with a StableName when you create them
20:17:08 <kmc> except that the documented guarantees on StableName are too weak
20:17:10 <ddarius> Certainly some garbage collection algorithms preserve the orderings of addresses.
20:17:33 <ddarius> You could just generate an integer from some global supply.
20:17:54 <kmc> but that would require a global variable
20:17:58 <Jafet> In any case, it's bad to rely on your implementation using a particular method for GC
20:18:02 <kmc> which people keep telling me are never ever the right solution to anything ;P
20:18:16 <kmc> i should add this to my list of counterexamples, actually
20:18:41 <ddarius> Memory is a global variable.
20:21:31 --- mode: monochrom set -b *!*@71.184.161.32
20:21:36 --- mode: monochrom set -o monochrom
20:28:00 * shachaf learns of the existence of "wobbly types".
20:28:32 <ddarius> That was an earlier approach to handling GADTs.
20:28:39 <elliott> Wobbly types?
20:41:05 <kmc> that was the predecessor to Fc?
20:41:26 <mantovani> que /win 2
20:41:29 <mantovani> ops
20:47:49 <ddarius> "The object Ω above is sometimes called the strong-subobject classifier, since it classifies strong subobjects, but also sometimes called a weak subobject classifier, since it satisfies a weaker property than an ordinary subobject classifier."
20:51:40 <kmc> what a difference a hyphen makes
20:52:36 <kmc> what a difference an ASCII hyphen-minus makes
20:53:40 <dylukes> ddarius: wha?
21:02:12 <elliott> > foo
21:02:13 <lambdabot>   [1,3,5,7,9]
21:02:14 <elliott> > foo :: [Rational]
21:02:16 <lambdabot>   [1 % 1,3 % 1,5 % 1,7 % 1,9 % 1,11 % 1]
21:02:22 <elliott> Why does Rational do the same nonsense that the floating-point types do?
21:02:25 <elliott> There's no imprecision to worry about.
21:03:22 <Axman6> [0.1,0.3..1.0] :: [Rational]
21:03:25 <Axman6> > [0.1,0.3..1.0] :: [Rational]
21:03:26 <lambdabot>   [1 % 10,3 % 10,1 % 2,7 % 10,9 % 10,11 % 10]
21:03:31 <copumpkin> isn't it great?
21:03:34 <copumpkin> I love it
21:03:37 <Axman6> ouch
21:03:41 <elliott> copumpkin: Yes but why for Rationals???
21:03:47 <elliott> I can HALF understand floating point types doing it.
21:03:52 <copumpkin> it's not because of floating point rounding
21:03:53 <elliott> But Rationals are... rational.
21:03:59 <copumpkin> it's because the enumeration is b0rked
21:04:02 <elliott> copumpkin: Um, no.
21:04:07 <elliott> I mean.
21:04:10 <elliott> None of the integral types do that.
21:04:10 <Axman6> elliott: he's right
21:04:14 <shachaf> elliott: You sure thought they were rational, didn't you?
21:04:14 <Axman6> the definition is dumb
21:04:25 <elliott> Axman6: The only justification I've heard for fractional types was "allow going over half the step to avoid rounding issues".
21:05:19 <shachaf> «For Float and Double, the semantics of the enumFrom family is given by the rules for Int above, except that the list terminates when the elements become greater than e3 + i∕2 for positive increment i, or when they become less than e3 + i∕2 for negative i.»
21:05:29 <elliott> Right. Rational isn't Float or Double.
21:05:32 <shachaf> Yes.
21:05:52 <elliott> So copumpkin's/Axman6's explanation doesn't convince me :P
21:05:59 <Nafai> Is there an easy way to tell if you have any packages installed with cabal that can be upgraded?
21:06:15 <elliott> Nafai: "cabal upgrade", but only do it if you know what you're doing.
21:06:45 * ddarius should talk to David Spivak.
21:06:59 <napping> how do you use Text.Regex.TDFA?
21:08:29 <napping> the haddocks claim instances RegexContext Regex String String and RegexMaker Regex CompOption ExecOption String, but trying ("abc([0-9]*)def" =~ "abc123def") :: String gives an error No instances for (RegexMaker Regex CompOption ExecOption [Char],
21:08:29 <napping>                       RegexContext Regex [Char] String)
21:09:44 <Axman6> ouch
21:10:23 <solidsnack> napping: Is this from within a source file? From GHCi?
21:11:04 * elliott is very sceptical of the overloaded (=~) thing.
21:11:21 <ddarius> You're behind the curve on that one.
21:11:52 <shachaf> (=~) is such a great operator!
21:11:57 <shachaf> It does exactly what you want.
21:12:08 <shachaf> @ty (=~)
21:12:09 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
21:12:29 <shachaf> forall arg1 arg2 target. (Function arg1 arg2 target) => arg1 -> arg2 -> target
21:12:30 <napping> ghci, with Text.Regex.TDFA imported - with Text.Regex.TDFA.String added I can match with a result of String, but not the modes that actually capture
21:13:04 <ddarius> Clearly should be generalized to (Category hom1, Category hom2, ...) => hom1 source1 (hom2 source target)
21:13:17 <ddarius> Or more generally, Semigroupoid
21:17:22 <dorjesm> newbie to haskell here. what's the preferred ssl library. there seem to be a handful but none are really complete
21:18:11 <ddarius> Which one meets your needs?
21:18:13 <Axman6> i think Yesod has done quite a bit of work getting SSL working well.
21:18:17 <Axman6> could be wrong
21:19:07 <dorjesm> I'm still not fluent enough to understand which ones are more canonical haskell and which ones would meet my needs. I
21:19:19 <dorjesm> I'll look at what yesod uses thanks :)
21:19:23 <elliott> ddarius: It should just be generalised to every single type.
21:19:27 <elliott> (=~) :: (Magic a) => a
21:20:29 <luite> dorjesm: I don't think yesod supports ssl directly
21:20:38 <ion> There should be an undefined on the type level.
21:21:03 <Axman6> (forall a. a)?
21:21:30 <solidsnack> napping: Still building/downloading; I recently reset Cabal on this computer.
21:21:50 <ion> Nah, even that’s defined. :-)
21:23:06 <napping> It looks like it defines the magic =~, but then doesn't provide any instances other than the one with a string result
21:32:47 <napping> so, better use Perl?
21:35:31 <ion> Better drink my own piss.
21:35:38 <Skola> hahaha
21:35:42 <elliott> napping: Better use a different package.
21:37:37 <kmc> wow this channel can get pretty kinky
21:38:15 <solidsnack> napping: It sounds awful but I sometimes just parsec.
21:39:39 <napping> whatever happened to Text.Regex?
21:41:30 <solidsnack> My package database is very broken now, hmmm.
21:41:59 <Axman6> kmc: i guess you don't spend time on reddit
21:42:22 <Axman6> this isn't a bad thing, avoiding all the memejerking on reddit is worth doing
21:42:30 <kmc> i love haddock, I always end up writing things like '@)@'
21:42:39 <kmc> little weirdo smiley faces peeking out from next to my code
21:43:37 <shachaf> kmc: Are you haddocking you Acme module?
21:43:42 <kmc> no
21:43:49 <kmc> that's already done
21:43:49 * shachaf looked for it on Hackage today but it wasn't there.
21:43:56 <ManateeLazyCat> Hi forks. :)
21:43:59 <ManateeLazyCat> kmc: How are you ? Long time no see. :)
21:44:17 <kmc> hi ManateeLazyCat :)
21:44:19 <kmc> i'm good
21:44:22 <kmc> how goes with you?
21:44:39 <ManateeLazyCat> kmc: No bad. :)
21:44:47 <ManateeLazyCat> kmc: Busy on python code and linux deepin project.
21:44:57 <ManateeLazyCat> kmc: I haven't write Haskell code some months.
21:45:10 <ManateeLazyCat> kmc: Shame.
21:48:16 * elliott wonders why http://hackage.haskell.org/package/monadacme includes a renamed version of Identity/IdentityT.
21:48:20 <elliott> And nothing else.
21:48:42 <KirinDave> A joke perhaps?
21:50:23 <parcs> > 32000 / 24 / 365
21:50:23 <lambdabot>   3.65296803652968
21:50:25 <elliott> KirinDave: Identity isn't very funny.
21:50:46 <solidsnack> parcs: On call duty?
21:51:13 <KirinDave> elliott: A wise man once said, "Humor is a many funny thing."
21:51:36 <ddarius> KirinDave: That had no funny, so it is not humor.
21:52:17 <parcs> solidsnack: hehe, no :P the hard drive on this laptop reports 32000 power-on hours
21:52:59 <KirinDave> ddarius: So noted.
22:27:37 <kmc> you know what hackage really really really needs?
22:27:48 <kmc> tags anyone can add to a package
22:28:05 <kmc> right now the 'Categories' feature is totally useless
22:28:28 <Axman6> it also needs a complusory change log feature
22:28:31 <kmc> but if they were easily editable I think it would be a lot more useful
22:29:32 <kmc> i think Hackage 2.0 already supports this feature
22:29:42 <kmc> change logs would be nice too
22:30:12 <tgeeky> kmc: i almost said exactly the same thing a few minutes ago
22:30:16 <kmc> haha
22:30:35 <kmc> tags won't require much effort from uploaders (or anyone else)
22:30:45 <kmc> and would be super useful
22:30:52 <tgeeky> I was going to say (re: monadacme) -- it's a prime example that there's not enough information in tagging/attributes, and that there's no good reason that the author should be the final say on categorization
22:31:49 <tgeeky> kmc: are you involved with hackage2.0?
22:31:50 <tgeeky> i should
22:31:56 <tgeeky> (get involved)
22:32:19 <kmc> i'm not
22:32:21 <kmc> and i should :)
22:32:21 <Axman6> i think as whole, we're missing some easy way to connect a module with its package
22:32:41 <Axman6> i have no idea how to fix that though
22:32:48 <tgeeky> Axman6: ... that is essentially the only thing hackage does, no?
22:32:51 <tgeeky> it's a namespace for cabal
22:32:57 <kmc> you can use Hayoo, no?
22:32:59 <kmc> or do i misinterpret
22:33:15 <Axman6> tgeeky: not really. there's no way to look at a piece of code and know where all the imports are coming from
22:33:41 <Axman6> i think C++ solves this with name spaces, but in true C++ style, in a really ugly way
22:33:58 <kmc> meh, namespaces are one of the best features in C++ imo
22:34:21 <tgeeky> Axman6: Would mandatory qualified imports give you enough information to know what's going on (even if unwieldy?)
22:34:26 <Axman6> it would be nice to be able to look at an import line and know where it comes from
22:34:29 <kmc> you get things like the ability to do a qualified import, and then unqualify it in a local scope
22:34:48 <Axman6> tgeeky: no, i still don't know what package the import comes from then
22:34:56 <kmc> you sort of know if you're using Cabal
22:35:02 <kmc> because you've declared your dependencies
22:35:06 <kmc> and you can usually guess from there
22:35:18 <tgeeky> yes, although I think if you're writing software to automate this process
22:35:22 <Axman6> kmc: yeah, that is pretty nice
22:35:29 <tgeeky> all dependencies should be duplicated in .cabal and in the individual files
22:35:33 <tgeeky> as well as pragmas
22:35:39 <tgeeky> Axman6: ok
22:35:51 <tgeeky> Axman6: if I said, every import must specify the package explicitly?
22:35:54 <kmc> anyway, these would be welcome improvements, but I think the urgent critical issue right now is the difficulty of finding the right library on Hackage
22:36:11 <tgeeky> Axman6: import "my-prelude" Prelude; import "base" Control.Monad?
22:36:18 <kmc> when you've not yet started a project and you want to know the best way to do $X in Haskell
22:36:24 <tgeeky> kmc: yes, but that's the tagging problem
22:36:35 <kmc> tags would help a lot, yeah
22:36:36 <Axman6> tgeeky: yep, that works. it would be nice if that was mandetory
22:36:39 <Axman6> uh, sp
22:36:47 <kmc> I also think a mechanism for arriving on a consensus about the quality of a package would be useful
22:36:57 <kmc> most "product review" voting systems are broken
22:36:58 <tgeeky> Axman6: the downside, is that I don't think you can do packageimports and qualified in the same line
22:37:12 <Axman6> bleh -_-
22:37:32 <kmc> like I'm not proposing that each package have a rating from 1-5 stars (most would have like 2 votes, at either 1 or 5)
22:37:43 <Axman6> tgeeky: if that gets fixed, having a GHC flag that demands that you do that would be great for large projects
22:37:45 <tgeeky> kmc: I would prefer one where voting isn't even possible
22:38:02 <kmc> I'd like a way to submit one-sentence feedback about a package
22:38:07 <Axman6> yeah
22:38:15 <kmc> which is sorted into "positive" and "negative" and a few of each are displayed
22:38:17 <tgeeky> Axman6: well, one could write a bit of software like
22:38:23 <tgeeky> @hackage fix-imports
22:38:24 <lambdabot> http://hackage.haskell.org/package/fix-imports
22:38:48 <tgeeky> Axman6: and simply make it automatically insert packages where they can be resolved
22:38:50 <Axman6> actually, PHP's doc system has something nice. there's official docs, and also people can comment, and do things like give example usage, ask for help etc
22:38:53 <tgeeky> Axman6: actually, that's interesting
22:38:59 <kmc> yes
22:39:07 * hackagebot http-enumerator 0.7.1.2 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.1.2 (MichaelSnoyman)
22:39:09 * hackagebot yesod-static 0.3.1.2 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.3.1.2 (MichaelSnoyman)
22:39:09 <Axman6> that is something i've wanted in hackage for a while
22:40:04 <ddarius> MSDN supports comments on the reference documentation, but it is pretty much completely unused.
22:40:48 <kmc> every PHP script is grown by pasting together examples from said docs
22:40:57 <Axman6> heh
22:40:59 <tgeeky> Axman6: if you were to do such an implementation (make fix-imports automatically resolve and automatically insert packageimports, then you could spell the end of ambiguious imports like with NumericPrelude and Prelude)
22:41:00 <kmc> and yeah it's nasty and the language is horrible and it encourages bugs and security holes
22:41:01 <Axman6> this is true
22:41:06 <kmc> but.... people get shit done
22:41:11 <tgeeky> I think?
22:41:19 <tgeeky> someone correct me on that?
22:41:19 <kmc> people who are not skilled professional programmers can throw together a website in this manner
22:41:24 <kmc> and I think that's remarkable
22:41:30 <kmc> and it's worth emulating the good parts of that
22:41:38 <Axman6> tgeeky: sounds like that may be true
22:41:58 <tgeeky> Axman6: my request is actually differental imports
22:42:17 <tgeeky> Axman6: where you import a package, but reserve the right to rename or mask some functions
22:42:39 <ddarius> It's easy to do things when you ignore concerns of correctness.
22:42:40 <Axman6> Ada has something like that i think
22:42:46 <kmc> ddarius, no, it's still pretty hard
22:42:54 <Axman6> well, you can rename things though (it's slightly more powerful than macros)
22:43:00 <tgeeky> Axman6: something that's equivalent to module MyPrelude ( {explicit listing of 470 methods} ); import Prelude ( {explicit listing of 490 methods} )
22:43:19 <Nafai> I've got some code that used dbus-core and dbus-client 0.8.x, and APIs seem completely changed in 0.9.x, has anyone done porting between the two?
22:43:20 <kmc> by the way, was there any specific objection to the way namespaces work in C++?
22:43:29 * tgeeky knows nothing about them
22:43:54 <kmc> in my time using C++ (thankfully in the past) it was one of few language features which never bit me
22:44:04 <kmc> anonymous namespaces are a little weird, but I think they're a good feature on balance
22:44:12 <kmc> and that's a side thing
22:44:29 <tgeeky> kmc: didn't you do blog post about fixed-preicision arithmetic?
22:44:35 <kmc> did i?
22:44:41 <tgeeky> what's your site?
22:44:47 <kmc> http://mainisusuallyafunction.blogspot.com/
22:45:04 <tgeeky> kmc: btw, I rather liked your slides
22:45:28 <ddarius> kmc: Also, PHP is specifically designed for making web sites and I think (to varying degrees) you'd find that most HTML templating approaches allow non-skilled designers to "throw together a website."
22:46:04 <kmc> thanks tgeeky
22:46:30 <kmc> ddarius, PHP is more of a real programming language, though
22:46:30 <tgeeky> kmc: guess you didn't, is that background image a "default" one for wordpress or something?
22:46:45 <kmc> tgeeky, it's one of blogspot's themes, yeah
22:46:55 <tgeeky> kmc: someone else using your blog style did :O
22:46:55 <kmc> it's not the default and I"ve not personally seen another site use it, but I'm sure there are some
22:47:43 <kmc> ddarius, anyway, I won't claim that PHP is better than other "web app frameworks"
22:47:45 <kmc> it's clearly not
22:47:48 <Axman6> kmc: oh, that's you? i've been loving a lot of the stuff you've done lately on your blog =)
22:47:58 <kmc> but it was successful in its goal
22:48:00 <kmc> Axman6, thanks :)
22:48:04 <kmc> what would you like to see more of?
22:48:33 <Axman6> well, the debug-diff stuff looks very cool
22:48:39 <kmc> i have three posts at varying states of completion:
22:48:51 <Axman6> the pi calculus stuff was pretty cool
22:48:56 <kmc> - curry-howard isomorphism for casual functional programmers; continuations, call/cc and the law of the excluded middle
22:49:09 <kmc> - some tricks with self modifying code in C
22:49:21 <kmc> - picking a random function of type (Integer -> Bool) in Haskell
22:49:42 <Axman6> if i had to pick one, i'd probably say "yes"
22:49:49 <Axman6> they all sound good, keep writing!
22:49:56 <kmc> haha thanks
22:50:24 * shachaf votes for self-modifying code in C.
22:50:33 <kmc> it'll probably be that one next, as it's nearly done
22:50:36 <shachaf> Mainly because you've already talked about the other two in IRC to various extents.
22:50:59 <kmc> yeah
22:51:02 <Axman6> i'd love to see more about continuations. they're not a concept i really grok
22:51:23 <kmc> hmm
22:51:24 <ddarius> PHP didn't start off as that much more of a real programming language.
22:51:36 <kmc> continuations are kind of a side note on the C-H post
22:51:49 <kmc> i could also do a proper explanation of continuations as a separate post
22:51:59 <kmc> i'd have to come up with some examples
22:52:31 <Axman6> i've seen some cool stuff that you can do with them, but i don't really understand them
22:52:56 <kmc> yeah
22:53:03 <ddarius> There have been several articles on continuations via CH.
22:53:06 <kmc> it's one of those concepts which is simple to state but hard to grasp
22:54:22 * ddarius thinks the shortest route to actually understanding continuations is understanding continuation passing style.
22:54:31 <kmc> i agree
22:54:38 <kmc> and that approach fits well in Haskell
22:54:56 <ddarius> It also fits well with assembly.
22:55:45 <kmc> Axman6, what part of the explanation of continuations should be expanded?
22:56:00 <kmc> like where have you run into difficulty in the past
22:57:05 <kmc> maybe that's not a reasonable question to ask
22:57:26 <Axman6> i can't remember, it's been a while since i last gave learning to use them a shot. I think things like the Cont monad confused me because they abstracted too much away too early for me
22:57:34 <kmc> yeah
22:58:07 <kmc> you can work with explicit CPS style first
22:58:25 <Axman6> yeah, a nice tutorial on that would be great
22:58:32 <kmc> then there's no hidden magic, just functions
22:58:34 <kmc> also it's webscale ;)
22:59:11 <Axman6> "Lambda as a Service"
22:59:14 * Axman6 likes this idea
22:59:30 <Axman6> "Have you got LaaS?"
23:02:20 <kmc> it's weird that a simple transformation with ordinary functions can give your code magical time traveling powers
23:02:50 <ddarius> Not calling continuations "magic time traveling" is also helpful.
23:03:16 <kmc> it's weirder still that there's a deep connection between this and double negation in classical logic
23:03:19 <Axman6> heh, indeed
23:03:40 <kmc> it's definitely a different way to think about the law of the excluded middle
23:03:57 <kmc> you claim "not P" and then if somebody provides a counterexample, you go back in time and claim the opposite
23:04:02 <kmc> ddarius, always raining on my parade
23:04:17 <ddarius> Given the connections between continuations and concurrency, and classical (linear) logic and concurrency, it's not so outlandish.
23:05:29 <kmc> so what would be some good examples for a blog post on continuations (in Haskell)
23:05:37 <ddarius> The "left adjoint of sums" view is also a somewhat interesting perspective.
23:05:58 <kmc> something I could demonstrate in CPS and then wrap up nicely in the Cont monad
23:06:21 <ddarius> Anything you demonstrate in CPS will be able to be "wrapped up nicely" in the Cont monad.
23:06:47 <kmc> again with the parade
23:07:08 <kmc> I'm aware that the two are equivalent through a small transformation
23:07:10 <ddarius> CPS is monadic style with the Cont monad.  If you can't "wrap it up nicely" with the Cont monad, you aren't using CPS.
23:07:18 <kmc> there will still be some examples where it's nicer than others
23:07:37 <kmc> for example, because some Monad-generic function happens to do what i want
23:08:16 <ddarius> That suggests an obvious way of finding an example.  Look at what Monad-generic functions do.
23:08:47 <kmc> *nod*
23:09:02 <dolio> What's the adjunction?
23:10:32 <Axman6> kmc: are these 'why learn haskell' slides new?
23:11:02 <kmc> yeah
23:11:08 <kmc> i gave the talk on Tuesday
23:11:20 <kmc> there was an older 'prerelease' version but i never publicized it
23:11:49 <Axman6> ah, i may have seen that. it all seems quite familliar.
23:12:10 <ddarius> (B <-) -| (B +) which definitely doesn't hold in Set, but can hold in categories where you have something like continuations.
23:12:13 <Axman6> I really like the logger example, i'd never thought of doing that. makes the syntax really nice
23:13:38 <shachaf> Is that the log <- mkLogger; log "foo"; log "bar" thing?
23:14:26 <kmc> yeah
23:14:28 <kmc> is this 'global-variables' library really any better than #define global_var(name, ty, val) name :: IORef ty; name = unsafePerformIO (newIORef val); {-# NOINLINE name #-}
23:14:47 <kmc> it does force the refs to be monomorphic (which is important) but I suspect a small additional hack would suffice
23:14:58 <kmc> otherwise it seems worse in several ways
23:15:06 <kmc> but I've only just started reading the code
23:15:18 <kmc> several people mentioned it here, which is why I bring it up
23:15:32 <shachaf> That logger thing seems a lot like a toy example that's not as useful as soon as you want to add any sort of functionality like "shut down logger".
23:16:34 <kmc> shachaf, the 'outer' code which needs to make decisions like 'shut down logger' can work with a 'logger object', and the rest of the code (which just needs logging) can work with the closure
23:17:07 <kmc> i've heard the same thing about the futures in 'spawn'
23:17:12 <shachaf> I suppose that's true.
23:17:21 <kmc> but most of the time, I really do just want the result
23:17:21 <shachaf> kmc: Because you can't killThread etc.?
23:17:24 <kmc> yeah
23:17:36 <Axman6> shachaf: yeah, that's the logger thing i meant
23:17:43 <kmc> you could have spawn :: IO a -> IO (ThreadId, IO a)
23:17:45 <ddarius> The logger example is also a completely standard pattern for working with concurrent channels, the benefits and (notably) the problems of it are covered in Reppy's thesis, Higher Order Concurrency.
23:18:08 <kmc> but then things like mapM f xs >>= sequence don't work out as nicely
23:18:16 <kmc> ddarius, oh, I should read that thesis then!
23:18:30 <Hayshi> quick question: will (!!) only tell me the item at a certain point in the list that I ask for, or can it tell me the placement in the list for each item?
23:19:07 <companion_cube> higher order concurrency ? like sending closures on channels to be evaluated on other threads?
23:19:28 <Axman6> Hayshi: (!!) only does one thing, it retrieves items at an index in a list. it's just a normal function
23:19:31 <Axman6> @src (!!)
23:19:32 <lambdabot> xs     !! n | n < 0 = undefined
23:19:32 <lambdabot> []     !! _         = undefined
23:19:32 <lambdabot> (x:_)  !! 0         = x
23:19:32 <lambdabot> (_:xs) !! n         = xs !! (n-1)
23:19:42 <shachaf> At one point I used something along the lines of data ThreadHandle = ThreadHandle ThreadId (MVar ())
23:19:44 <kmc> companion_cube, or creating a channel c and then returning (writeChan c)
23:19:53 <kmc> companion_cube, so your caller doesn't see the chan, and can't read from it, but can only write
23:20:01 <companion_cube> ah , nice
23:20:10 <shachaf> With a join function :: ThreadHandle :: IO ()
23:20:15 <companion_cube> a kind of encapsulation then
23:20:22 <kmc> > zip [0..] "you can do this Hayshi"
23:20:23 <lambdabot>   [(0,'y'),(1,'o'),(2,'u'),(3,' '),(4,'c'),(5,'a'),(6,'n'),(7,' '),(8,'d'),(9...
23:20:23 <shachaf> (I guess that should be generalized to MVar a.)
23:20:24 <Hayshi> so how would I input an item and get that item's index?
23:20:30 <kmc> :t findIndex
23:20:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
23:20:47 <kmc> lists really are not the right structure for this, though
23:20:50 <shachaf> But in that case spawn would probably have sufficed and been simpler.
23:20:52 <companion_cube> i wrote a  small program in which a resource (a connection) was held in a thread, and other threads needing this resource sent this thread continuations
23:21:05 <kmc> companion_cube, in Haskell?
23:21:06 <Hayshi> hmmm ok
23:21:07 <shachaf> @ty find
23:21:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
23:21:12 <companion_cube> kmc: yep
23:21:15 <Axman6> Hayshi: you seem to be treating lists as some kind of array, you probably don't want that
23:21:15 <shachaf> @ty elemIndex
23:21:16 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
23:21:20 <shachaf> Hayshi: But you probably don't want that.
23:21:25 <shachaf> Well, maybe.
23:21:34 <ddarius> Higher Order Concurrency is how that common pattern for encapsulating protocols has a significant flaw.
23:21:39 <companion_cube> like a Chan (Resource -> IO ())
23:21:42 <Axman6> companion_cube: to guarantee some kind of ordering?
23:22:02 <companion_cube> no, to keep the resource isolated in one thread
23:22:10 <companion_cube> and use of that resource serialized
23:22:30 <Axman6> i have a package called AVar that's somewhat related. it's supposed to emulate mutable variables, but implemented as a thread that accepts requests on a Chan
23:22:39 <Axman6> companion_cube: yeah, that's really what i meant
23:22:48 <companion_cube> then yes
23:22:51 <Axman6> i don't think anyone has ever even looked at AVar :(
23:22:59 <Axman6> i wrote it a long time ago, mainly for fun. didn
23:23:10 <Axman6> didn't really expect anyone to look at it anyway
23:23:26 <Axman6> there's probably a lot I could fix now
23:23:48 <Axman6> also, i have a feeling it will space leak, because it probably builds up a big chain of catch calls
23:23:54 <kmc> the variables of 'global-variables' are not named and scoped through the normal Haskell module system
23:23:57 <kmc> but through strings
23:24:22 <Axman6> :|
23:24:24 <kmc> it looks like there's no way for a library using 'global-variables' to prevent unrelated code from interfering with its variables
23:24:29 <Axman6> @hackage global-variables
23:24:29 <lambdabot> http://hackage.haskell.org/package/global-variables
23:24:37 <kmc> also, if two modules declare a global-variable with the same name, the result is undefined behavior
23:25:25 <kmc> also the implementation is full of weirdness and links to GHC bug tracker and...
23:25:38 <kmc> and at the core it's still just using unsafePerformIO on a MVar
23:26:30 <shachaf> kmc: What does a gray slide indicate?
23:26:35 <kmc> ?
23:26:47 <shachaf> In your whyhaskell slides.
23:27:06 <kmc> which slide number?
23:27:24 <shachaf> Oh. It was apparently my PDF viewer.
23:27:30 <kmc> *nod*
23:27:44 <shachaf> https://docs.google.com/viewer?url=http%3A%2F%2Fwww.ugcs.caltech.edu%2F~keegan%2Ftalks%2Fwhy-learn-haskell%2Ftalk.pdf
23:27:59 <dolio> ddarius: Is (B +) : C^op -> C there? Or is (B <-) : C -> C?
23:29:07 <ddarius> <- is not just an alternative for ->.  The name isn't at all standardized.  (B+) is obviously a covariant endofunctor.
23:29:20 <dolio> Okay.
23:30:07 <Axman6> obviously
23:30:10 <kmc> "Avoid having to pass references explicitly throughout the program in order to let distant parts communicate...Enable a communication by convention scheme, where e.g. different libraries may communicate without code dependencies."
23:30:16 <kmc> uh, these are supposed to be good things?
23:30:27 <Axman6> :|
23:30:36 <Axman6> sounds like a 'code smell'
23:30:44 <kmc> i mean global variables are a code smell
23:30:47 <kmc> but sometimes necessary
23:31:03 <kmc> this is like "let's have global variables and let's also make them invisible to the Haskell module system"
23:31:06 <Axman6> necessary?
23:31:37 <kmc> 'necessary' being code for 'by far the best way to solve a problem'
23:31:42 <ddarius> Think about the opportunities for dependency injection!
23:31:45 <Axman6> and "Let's let totally unrelated libraries interact without the user's knowledge, or even the library author's"
23:32:49 * ddarius likes capabilities and so could never like this package.
23:33:01 <kmc> heh
23:33:24 <kmc> so how can i rewrite my one-line macro to also force the ref to be monomorphic?
23:34:28 <ddarius> Lean on the monomorphism restriction.
23:34:34 <kmc> any other way?
23:34:42 <kmc> actually, I think this library lets you create "polymorphic refs" which are secretly one different ref for every TypeRep
23:34:49 <kmc> so it does not let you unsafeCoerce
23:35:03 <kmc> but god help you if you accidentally use an Integer ref as an Int in one place
23:35:10 <napping> yuck
23:35:17 <kmc> combine that with defaulting and it's a real party
23:36:15 <napping> your macro could use the monomorphism restriction by being name = ... :: IORef ty
23:36:33 <kmc> but suppose the user disables the dreaded mmr
23:36:35 <shachaf> But everyone disables the monomorphism restriction.
23:36:52 <shachaf> We need a way to selectively choose extensions for parts of a file.
23:36:57 <napping> you probably want to allow IORef holding polymorphic types anyway
23:37:10 <Axman6> you do?
23:37:19 <ddarius> Just implement (old) SML's imperative type variables.
23:37:46 <napping> I don't know if you want to, but it's only forall t . IORef ..t.. that breaks type safety
23:38:13 <kmc> only?
23:38:32 <kmc> i mean,  ∀t. IORef (Maybe t) is still bad, right?
23:38:44 <napping> yeah, that's what ..t.. was for
23:38:46 <ddarius> napping: Doesn't that cover all the cases?
23:38:49 <kmc> ah i see now
23:38:57 <napping> IORef (∀t . Maybe t) should be safe
23:39:02 <kmc> "IORef holding polymorphic types" is impredicative, anyway
23:40:15 <napping> so actually, moving the type signature into the body should be enough - that way it's not implicitly closed over free variables
23:40:27 <napping> implicitly generalized, rather
23:41:11 <shachaf> napping: Why?
23:42:52 <napping> #define global_var(name, ty, val) name = unsafePerformIO
23:42:52 <napping>       (newIORef val) :: IORef (ty) ; {-# NOINLINE name #-}
23:43:50 <shachaf> napping: Oh, in that sense.
23:44:09 <napping> Say val is Nothing - is there anything you could supply for ty to make "name" come out with type forall t . IORef (Maybe t)?
23:44:55 <shachaf> Apparently.
23:45:01 <dolio> Maybe t
23:46:32 <napping> wait, how does that work?
23:46:54 <shachaf> IORef (Maybe t) === forall t. IORef (Maybe t)
23:49:43 <napping> hmm, MonoPatBinds?
23:50:52 <copumpkin> forall t. IO (IORef (Maybe t)) is fine too
23:52:42 <kmc> would it be a dick move for me to write an article about the 'global-variables' package being harmful
23:54:23 <coppro> no
23:54:36 <napping> copumpkin: I don't see how you would share the IORef
23:56:26 <copumpkin> you wouldn't
23:56:30 <copumpkin> :D
23:56:55 <dolio> You could wrap that unsafePerformIO in a return, but that also would not be okay.
23:56:57 <napping> well, that's fine
23:59:55 <dolio> So, global-variables keeps track of a global mutable variable containing a map containing global mutable variables?
