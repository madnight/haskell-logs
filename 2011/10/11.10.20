00:06:28 <Sgeo|web> > "hi"
00:06:29 <lambdabot>   "hi"
00:07:13 <Sgeo|web> @tell
00:07:14 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
00:07:18 <Sgeo|web> @help tell
00:07:19 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
00:07:42 <Sgeo|web> Hi aftran
00:07:47 <Sgeo|web> > (sin + cos) x
00:07:48 <lambdabot>   sin x + cos x
00:07:53 <aftran> Hi.  :)
00:08:05 <Sgeo|web> > (sin * sin + cos * cos) 100
00:08:06 <lambdabot>   0.9999999999999999
00:08:17 <Sgeo|web> ...yay floating point?
00:08:24 <Sgeo|web> > (sin * sin + cos * cos) 100 :: Ratio
00:08:25 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
00:08:42 <Sgeo|web> :t (sin * sin + cos * cos) 100
00:08:43 <lambdabot> forall a. (Floating a) => a
00:08:53 <ddarius> :k Ratio
00:08:54 <lambdabot> * -> *
00:09:01 <mauke> > (sin^2 + cos^2) 100 :: CReal
00:09:02 <lambdabot>   1.0
00:09:06 <Axman6> > (sin * sin + cos * cos) 100 :: Rational
00:09:06 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
00:09:07 <lambdabot>    arising from a us...
00:09:42 <Sgeo|web> I wish @src (+) would work here
00:09:46 <Sgeo|web> @src (+)
00:09:46 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
00:09:57 <mauke> Sgeo|web: which (+) do you want to see the source for?
00:10:11 <Sgeo|web> mauke: the Num (a -> a) instance
00:10:15 <Axman6> Sgeo|web: well, it's a member of a class, so it doesn't have one source
00:10:18 <mauke> Sgeo|web: (+) = liftA2 (+)
00:10:27 <Sgeo|web> @src liftA2
00:10:27 <lambdabot> liftA2 f a b = f <$> a <*> b
00:11:24 * Sgeo|web pokes aftran 
00:12:26 <aftran> Okay, that makes sense.
00:12:58 <ddarius> @google "Ralf Hinze" lifting
00:13:00 <lambdabot> http://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf
00:13:00 <lambdabot> Title: Lifting Operators and Laws
00:18:14 <Blkt> good morning everyone
01:29:03 <laoda> hello everybody!
01:29:17 <laoda> give a echo
02:20:56 <malc_> does edwardk still visits here?
02:21:16 <Ptival> @seen edwardk
02:21:16 <lambdabot> Unknown command, try @list
02:21:20 <Ptival> meh
02:22:43 <dafis> preflex: seen edwardk
02:23:27 <dafis> aw, preflex is away :(
02:23:35 <Ptival> we're doomed
02:23:43 <malc_> thanks to both of you anyways
02:24:10 <malc_> memoization is not haskell's strong point it seems
02:24:11 <dafis> malc_: but I can tell you that edwardk still visits here
02:24:30 <malc_> dafis: thank you
02:24:48 <dafis> malc_: in how far is it not Haskell's strong point?
02:25:22 <malc_> dafis: well you two rushed of evaluating stuff instead of trying to recall
02:26:02 <dafis> malc_: that's the irc illness ;)
02:26:09 <Ptival> it's too impure :(
02:26:24 <malc_> heh
02:30:36 <dhun_233> a few month ago I wrote a simple haskell program to calculate the nth element of the arithmetic series. It was as fast as the c version, now it is awfully slow, what happend?
02:30:43 <Sgeo|web> I am muddling my way through a problem
02:30:48 <Sgeo|web> In a horrible way
02:31:06 <Sgeo|web> I _think_ some value that I seem to need to pass in will end up being discarded
02:31:15 <Sgeo|web> Would it be sensible to just throw undefined in there
02:31:20 <frerich> dhun_233: Assuming you didn't change the program, maybe you're running it on a different (slower) computer now? Or the system is busy with other stuff?
02:32:48 <dhun_233> no this must be something more strange. The point is that ghc usually transfroms recursion into iteration, but somehow that disappered
02:33:00 <dafis> dhun_233: code?
02:33:08 <dafis> @where paste
02:33:08 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
02:34:47 <dhun_233> http://hpaste.org/52863
02:34:47 <frerich> I just noticed the 'placeholders' library at https://github.com/ahammar/placeholders, which intends to provide a substitute for 'undefined' when prototyping Haskell programs. I think the idea is pretty neat - is anybody aware of similiar efforts?
02:36:24 * Sgeo|web uses error instead
02:36:31 * Sgeo|web watches his program call him an idiot
02:36:43 <dafis> dhun_233: firs thing tht jumps out is that you're using Integers in Haskell, not fair, probably.
02:37:23 <dhun_233> I experimented with Int instead of Integer didn't help
02:38:56 <dafis> dhun_233: I get a stack overflow with 7.2.1, btw
02:39:32 <Sgeo|web> The fact that I felt a need to shoehorn a useless value in should probably be treated as a warning sign, I guess
02:39:38 <Sgeo|web> I don't think I really grok scanr
02:41:38 <dhun_233> dafis I currently don't have stack overflow
02:41:48 <dafis> dhun_233: looking closer, it's obvious why it doesn't work, the recursion is x + f (x-1), so all the x must be put on the stack before any evaluation can occur
02:42:13 <dafis> dhun_233: compiler version? compile options?
02:42:38 <dhun_233> The Glorious Glasgow Haskell Compilation System, version 6.12.1
02:43:19 <Sgeo|web> scanr may be the wrong function for my purposes, hmm
02:43:51 <dhun_233> ghc --make h.hs
02:44:52 <dhun_233> can I somehow rewrite it such that ghc can resolve the recursion
02:45:06 <dafis> dhun_233: okay, will try with 6.12.3, what version produced the fast code?
02:45:34 * hackagebot arithmoi 0.2.0.0 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.2.0.0 (DanielFischer)
02:45:54 <dhun_233> I don't know anymore, it is also possible that I changed to the code, but I am sure that me and one other person checked that it worked
02:45:55 <dafis> dhun_233: what? no optimisations??????
02:46:20 <dhun_233> that might be the point
02:46:24 <dhun_233> how can I enable them
02:48:29 <dhun_233> I tried with -O9 which dind't help much
02:48:36 <mauke> -O2
02:48:39 <dafis> dhun_233: -O or -O2; there are few situations where -O2 produces better code (some in which it is worse, even), but for my latest lib, -O2 gave a factor of 2 speedup in several modules
02:48:43 <mauke> -O9 doesn't exist
02:49:18 <mauke> also, rm *.o
02:49:46 <dafis> dhun_233: but optimisations won't help you here, you must change the code so that evaluation can take place while going
02:50:43 <dafis> oh, wow, I uploaded 0.2.0.0 some ten hours ago and hackagebot reports it *now*
02:50:59 <dhun_233> it helped a bit to do:     g n= sum (take (n+1) (iterate (+1) 0))
02:51:34 <dafis> dhun_233: try sum [1 .. n]
02:53:11 <Sgeo|web> TIL that random is almost literally a State monad type... thingy
02:55:04 <dhun_233> dafis that helped but it still is a factor of 30 slower than c
02:56:22 <dafis> dhun_233: hmm, compiled with -O2, using Int, that's 15ms here, I don't think C would be 30 times faster
02:57:02 <dafis> 32ms on Integer
03:00:18 <dafis> On the other hand, ghc doesn't fuse away the list :( making a tail recursive worker with accumulator, it's down to 2ms
03:01:24 <dhun_233> can you give me the code that does it ?
03:03:58 <dhun_233> I can get rid of the factor of 30 to c here, likely because of recursion
03:04:42 <dafis> dhun_233: annotated your paste
03:04:56 <Sgeo|web> Would be helpful if I decided to take care of state stuff at the same time I was taking care of state stuff...
03:05:35 * hackagebot hxmppc 0.2.3 - Haskell XMPP (Jabber Client) Command Line Interface (CLI)  http://hackage.haskell.org/package/hxmppc-0.2.3 (NicolasPouillard)
03:10:03 <dhun_233> now it is even fast than c
03:10:09 <dhun_233> ok that helper
03:10:15 <dhun_233> thanks a lot dafis
03:19:01 <erus`> nothing is faster than ruby
03:27:13 <dafis> erus`: not even rails?
03:37:08 <ksf> still no icfp2011 videos?
03:37:37 <ksf> you know, there are less funded people who actually *stream* presentations and stuff...
03:38:09 <ksf> or is it because ACM is evil?
03:38:54 <quicksilver> doubt it. I imagine it's just because human beings have to do the work and they're busy and have other priorities
03:40:38 * hackagebot NanoProlog 0.2.3.2 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.2.3.2 (JurrienStutterheim)
03:42:27 <ksf> I rather suspect it's because doing a presentation is enough to put the whole thing into your list of references. utter contempt for everything but academia.
03:57:09 <ivanm> is there a data structure which would let me add data in a linear fashion (preferably snoc but just cons would work) but also has better membership testing than O(n) ?
03:58:16 <quicksilver> you mean you want ordered data with fast membership testing?
03:58:25 <gienah> ivanm: there is Data.Sequence
03:58:30 <quicksilver> I don't think there is a single structure which does that.
03:58:39 <ivanm> quicksilver: that's what I figured
03:58:39 <quicksilver> gienah: data.sequence doesn't have fast membership testing.
03:58:51 <gienah> quicksilver: right
03:58:51 <quicksilver> I'd pair a sequence with a Set, probably
03:58:53 <ivanm> gienah: same as for lists: it's O(n)
03:59:02 <ivanm> quicksilver: yeah, I was thinking of doing that
04:00:11 <ivanm> I currently have Map a Int where each new Int is monotonically increasing, but doing map fst . sortBy (compare `on` snd) . M.assocs doesn't seem that great :s
04:08:13 <erus`> > let f x y = y in f 1 == f 1
04:08:14 <lambdabot>   *Exception: (==): No overloading for function
04:08:32 <erus`> Why can't we test equality of partially applied functions?
04:09:05 <erus`> easy todo in an interpreter, harder in a compiler
04:12:38 <ivanm> erus`: the fact that it's partially applied doesn't have much to do with it
04:12:47 <ivanm> testing equality of functions is the difficult bit
04:12:56 <ivanm> e.g. (2*) == (\x -> x + x)
04:13:24 <ivanm> there is a package that will let you define such an instance for a -> b, _if_ the domain of a is finite and enumerable
04:13:37 <ivanm> because it goes and checks for every single possible input
04:14:04 <erus`> ah
04:14:36 <ivanm> erus`: so, in your example, it's trivially obvious because the first parameter is ignored
04:14:53 <ivanm> to actually implement such a "feature" would probably require too many special cases, etc. to make it useful
04:15:32 <clsmith> hey all. is there a function (foo :: Int -> String -> String) such that, say, (foo 4 ['A'..'Z'] = ["AAAA","AAAB".."ZZZZ"]) ?
04:15:42 <erus`> i didnt think about the 2 * x = x + x thing
04:15:49 <clsmith> *-> [String]
04:15:52 <dafis> f x y = if Collatz sequence of x ends in 1 then y else y+1
04:16:22 <dafis> > "ABCDE" >>= replicate 4
04:16:23 <ivanm> clsmith: you mean combinations with repeats?
04:16:23 <lambdabot>   "AAAABBBBCCCCDDDDEEEE"
04:16:33 <ivanm> dafis: not what he said
04:16:35 <erus`> clsmith: yeah hang on
04:16:42 <clsmith> ivanm: yeah, i think that's what i mean
04:16:44 <ivanm> clsmith: I've got such a function available if you want it
04:16:47 <dafis> ivanm: yes, just noticed myself
04:17:15 <dafis> > replicateM 3 "ABC"
04:17:15 <lambdabot>   ["AAA","AAB","AAC","ABA","ABB","ABC","ACA","ACB","ACC","BAA","BAB","BAC","B...
04:17:18 <quicksilver> > replicateM 4 ['A'..'Z']
04:17:18 <ivanm> clsmith: can you guarantee that your input list doesn't have repeats?
04:17:19 <lambdabot>   ["AAAA","AAAB","AAAC","AAAD","AAAE","AAAF","AAAG","AAAH","AAAI","AAAJ","AAA...
04:17:29 <ivanm> dafis: they aren't unique combinations
04:17:39 <ivanm> you have ABA and AAB and BAA
04:17:53 <clsmith> oh, non-unique combinations is ok
04:18:01 <erus`> i have a unique 1 if u want
04:18:17 <clsmith> i think replicateM is what i want
04:18:23 <clsmith> thanks though :)
04:19:01 <hpaste> ivanm pasted “combinations with repeats” at http://hpaste.org/52868
04:19:07 <ivanm> clsmith: ^^ that's what I use
04:19:13 <ivanm> where all combinations are unique
04:19:42 <ivanm> hence the Multiset bit in the type sig... :s
04:19:55 <ivanm> so that code isn't _quite_ right...
04:20:11 <clsmith> <interactive>: out of memory (requested 1048576 bytes)
04:20:13 <clsmith> :$
04:20:26 <ivanm> which one is that for? mine or replicateM ?
04:20:29 <clsmith> replicateM
04:20:53 <dafis> @src replicateM
04:20:53 <ivanm> yeah, it's not that surprising if n is large
04:20:54 <lambdabot> replicateM n x = sequence (replicate n x)
04:21:14 <ivanm> clsmith: it gets n copies of the input list and then takes selections from each one in turn
04:21:25 <dafis> clsmith: yeah, sequence is evil for this
04:40:40 <srhb> Hi, I'm a Haskell newbie coming from SML. I want to use Emacs to play around with Haskell, but I miss being able to send the code of my current buffer to a Haskell inferior buffer like I could with SML-mode with C-c C-b - is there something similar for Haskell? Haskell-mode doesn't seem to do it.
04:41:48 <quicksilver> C-c C-l, srhb ?
04:42:10 <srhb> quicksilver: Huh, I seem to have completely missed that, I'll check it out. Thank you!
04:42:29 <ivanm> or, if you use chrisdone's stuff, F5
04:42:58 <quicksilver> also, you can rebind keys according to your preference :)
04:43:53 <srhb> Perhaps I'm misunderstanding something - but I can't seem to write what I can in the hugs process, can I? For example, if I type in "Hello World" in the hugs buffer it works fine, but if I add it to my test file and C-c C-l, I get an error.
04:44:00 <dylukes> @hoogle (a -> b -> c -> d) -> (a -> c -> b -> d)
04:44:00 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
04:44:01 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
04:44:01 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
04:44:21 <dylukes> I want the lambda argument to maybe to come last...
04:44:32 <ivanm> dylukes: flip . f ?
04:44:38 <dylukes> :t maybe
04:44:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:44:48 <dylukes> :t flip (maybe undefined undefined)
04:44:49 <lambdabot> forall a b a1. a -> Maybe a1 -> b
04:44:54 <ivanm> > flip . maybe
04:44:55 <lambdabot>   Overlapping instances for GHC.Show.Show
04:44:55 <lambdabot>                              (b -> ...
04:45:04 <dylukes> :t flip . maybe
04:45:04 <ivanm> @type flip . maybe
04:45:05 <lambdabot> forall b a. b -> Maybe a -> (a -> b) -> b
04:45:05 <lambdabot> forall b a. b -> Maybe a -> (a -> b) -> b
04:45:23 <dylukes> :t maybe
04:45:24 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:45:29 <dylukes> that works.
04:45:49 <srhb> I guess I can just copy my whole buffer and paste it into the hugs process instead. Just seems needlessly complicated compared to the C-c C-b of SML-mode.
04:45:54 <frerich> Out of curiousity (I have no need for this, just wondering): is there a way to have a generit 'zipWithN' which could be implemented in terms of 'zipWithN-1', basically taking an arbitrary number of arguments? Would template haskell be able to do this?
04:46:08 <ivanm> srhb: you write a Haskell module in a file, then C-c C-l will load that module in ghci
04:46:14 <Ptival> srhb: you probably need to bind what you typed in the repl to a name in your file
04:46:14 <dylukes> :t flip maybe
04:46:15 <lambdabot> forall b a. (a -> b) -> b -> Maybe a -> b
04:46:16 <dylukes> :t flip . maybe
04:46:17 <lambdabot> forall b a. b -> Maybe a -> (a -> b) -> b
04:46:28 <dylukes> heh?
04:46:35 <dylukes> how exaxctly does this work
04:46:52 <srhb> Ptival: But then I get no output in the hugs process? For instance, foo = "Hello World" gives me no output (but no errors either)
04:46:54 <ivanm> dylukes: it applies the first parameter from the .
04:46:58 <ivanm> then it flips the other two
04:47:03 <ivanm> @type \ f -> flip . f
04:47:04 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f1 (f (a -> b)) -> f1 (a -> f b)
04:47:12 <Ptival> srhb: then you type foo and you get "Hello World"
04:47:12 <ivanm> grrrr @ Caleskell
04:47:19 <dylukes> :P
04:47:26 <srhb> Ptival: Ok, I guess it's just not entirely analogous. Hm.
04:47:37 <ivanm> srhb: so it's not a sequence of commands to execute
04:47:49 <ivanm> it's the actual code from your module
04:47:53 <srhb> ivanm: Is there a way to do that instead? It seems to be a great learning tool.
04:47:58 <ivanm> so it doesn't interpret them a line at a time
04:48:01 <ivanm> srhb: no
04:48:04 <srhb> Shame.
04:48:09 <ivanm> ghci is only now getting the ability for arbitrary commands
04:48:11 <dylukes> :t (.)
04:48:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:48:22 <dylukes> :t (Prelude..)
04:48:23 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:48:30 <ivanm> srhb: how is it any more "great" than saying "type this into ghci" ?
04:48:35 <dylukes> @type \f -> flip (Prelude..) f
04:48:36 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
04:48:41 <ivanm> or "write your actual function into a file and load that file into ghci" ?
04:48:47 <srhb> ivanm: Because sometimes I have more than one line that I constantly edit and want to reevaluate
04:49:07 <dylukes> @type maybe
04:49:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:49:09 <ivanm> srhb: evaluate, C-<up>, edit, evaluate
04:49:11 <ivanm> (in emacs)
04:49:15 <dylukes> @type (\f -> flip (Prelude..) f) maybe
04:49:16 <lambdabot> forall c a a1. (((a1 -> a) -> Maybe a1 -> a) -> c) -> a -> c
04:49:18 <srhb> I just like the whole "buffer->REPL" functionality of sml-mode. I guess it's just a matter of taste
04:49:33 <srhb> ivanm: That;s a poor man's substitute for being able to just throw the entire buffer over there. But thank you anyway. :)
04:49:45 <ivanm> srhb: at first it feels like that
04:49:53 <ivanm> but I've found that it means you tend to have more code you don't save
04:50:05 <ivanm> that said, having in addition the ability to save sessions or something would be nice
04:50:15 <ivanm> (i.e. every time you reload that file, evaluate these commands)
04:50:35 <quicksilver> srhb: constantly editing multiple lines is fine. You just put those lines in a file
04:50:42 <dafis> ivanm: .ghci?
04:50:45 <quicksilver> (which is interpreted as a module but you don't need a module statement)
04:51:17 <srhb> quicksilver: I'll play around with that and see if I like it. :) Thanks.
04:51:23 <srhb> Dashing now, will be back fore more guru wisdom
04:51:24 <ivanm> dafis: could do that, but you'd have to keep changing .ghci every time you want to work on something else :p
04:51:52 <dafis> ivanm: yes, or separate directories for each file :)
04:52:11 <ivanm> dafis: but then every time you want to test something _else_ in the file...
04:52:39 <dafis> yes, true
05:05:51 <clsmith> okay, so replicateM 6 seems to result in a huge amount of memory usage. is that because of sequence? how could i write a function which does the same thing but without the swelling?
05:07:29 <clsmith> although it's only using 1MB of memory. can i somehow give it more to work with? :/
05:07:58 <mm_freak> clsmith: writing it yourself you will end up with the same function…  what do you want to do and in which monad?
05:08:13 <ivanm> clsmith: I pasted a hpaste link earlier with a different implementation...
05:08:28 <ivanm> mm_freak: he's wanting combinations with repeats allowed
05:08:42 <clsmith> ivanm: you said it considered "AAB" and "BAA" the same thing?
05:08:50 <ivanm> clsmith: yes
05:08:56 <mm_freak> ah, replicateM is convenient here, but also a memory eater =)
05:08:57 <clsmith> i want them separate
05:08:59 <ivanm> but then it's a matter of concatMap permutations
05:09:14 <mm_freak> combinations or permutations?
05:09:26 <mm_freak> i.e. with repeat or without?
05:09:29 <ivanm> mm_freak: concatMap permutations . combinations
05:09:53 <ivanm> if combinations returns only unique combinations
05:10:03 <clsmith> i basically want (foo 4 ['A'..'Z'] = ["AAAA","AAAB".."BAAA".."ZZZZ"]
05:10:03 <mm_freak> replicateM would include the permutations right away
05:10:31 <mm_freak> yes, that's precisely repliacateM's behaviour
05:10:41 <mm_freak> > replicateM 4 ['a'..'z']
05:10:43 <lambdabot>   ["aaaa","aaab","aaac","aaad","aaae","aaaf","aaag","aaah","aaai","aaaj","aaa...
05:10:46 <ivanm> it's also a memory hog
05:10:48 <clsmith> okay, so i want exactly what replicateM does, except i don't want it to explode <.<
05:11:04 <mm_freak> then write it non-monadically
05:11:07 <clsmith> i'm basically then mapping over the result
05:11:25 <clsmith> how would i go about that? <.< sorry, not great at haskell yet
05:12:22 <mm_freak> well, here is the simplest, ugliest, but probably fastest solution:  combs a b c d = [a,b,c,d] : combs (next a b c d)
05:12:46 <mm_freak> write a 'next' function and use unfoldr or iterate…  or write 'combs' yourself
05:13:33 <mm_freak> it's also completely lazy running in O(1) memory
05:14:06 <mm_freak> the pattern itself is not ugly, btw, i use it a lot…  but the 'next' function may look ugly =)
05:14:40 <mm_freak> you can also extend it to process a list of values instead of a fixed set of values, but then for efficiency you should represent it as least-significant-first
05:32:00 <mah_b> Is something like this possible: data ListNElements a (n :: Int) = ListNElements a (ListNElements a (n-1))? I haven't found anything about a mechanism like that. How can I work around this?
05:32:47 <sipa> you want type-level integers?
05:33:01 <quicksilver> mah_b: short answer No. Slightly longer answer Well, sort of. Best answer: you really don't want to.
05:33:27 <mah_b> sipa: yes
05:33:46 <mah_b> quicksilver: any idea how I could archive something similar?
05:34:03 <Axman6> mah_b: languages like Agda have dependant types, which is what you're after
05:34:12 <quicksilver> mah_b: http://hackage.haskell.org/package/type-level-0.2.4
05:34:19 <quicksilver> has a fairly complete implementation of type-level numbers
05:34:26 <Axman6> mah_b: do you really need to know the length of the list in the type system?
05:34:28 <quicksilver> although not, actually, the application to lists.
05:34:54 <quicksilver> see also http://www.ict.kth.se/forsyde/files/tutorial/tutorial.html#FSVec
05:35:00 <quicksilver> which referes, I think, to the types from that package.
05:36:12 <Eduard_Munteanu> "You really don't want to"? :)
05:36:39 <quicksilver> I think not
05:36:50 <Eduard_Munteanu> I think we want dependent types, they're just not here yet :)
05:36:51 <quicksilver> there are too many things you can't do, and haskell really doesn't have the infrastructure for it
05:37:04 <quicksilver> I meant, you really don't want to in haskell, Eduard_Munteanu
05:39:27 <mah_b> quicksilver: all solutions work through somehow encoding numbers in the type system. i thought of a more elegant solution (like c++ template<int>) :(
05:41:02 <mah_b> quicksilver: what do you mean by "infrastructrue"?
05:41:10 <Jaak> if you try to use values of Int on type level you somehow just have to encode numbers in type system
05:41:16 <Axman6> imo, that's not at all an elegant solution
05:41:44 <Jaak> C++ just does that implicitly
05:42:39 <Axman6> mah_b: why do you actually need this functionality?
05:44:59 <mah_b> Axman6: i want to be able to assure a certain length of lists? (I know I could wrap it somehow). I was looking for a elegant solution, but Mr. Google has found none. So I asked the question.
05:45:46 <quicksilver> mah_b: there is nothing inelegant about numbers in the type system.
05:46:00 <quicksilver> mah_b: numbers in the type system are the correct and elegant approach, notionally.
05:46:15 <quicksilver> What is inelegant is our range of options for doing that in haskell.
05:46:33 <quicksilver> Other languages which specialize in being dependently typed fair better - see agda and epigram
05:46:40 <quicksilver> (they have other disadvantages though)
05:47:00 <quicksilver> it's an area of active research
05:47:27 <mah_b> quicksilver: of course, but they add a lot of boilerplate. Of course I could also write all my numbers as (succ (succ ... null)), but I don't want to. and using template haskell is imho a "hack".
05:48:08 <quicksilver> As I said, that is "our range of options for doing that in haskell"
05:49:06 <Axman6> mah_b: if you need that, which i highly doubt you do, then Agda is the way to go
05:50:19 <mah_b> Axman6: you're right. I probably will just write a bunch of accessors that will assure the length.
05:50:40 * hackagebot timeplot 0.3.9 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.9 (EugeneKirpichov)
05:50:55 <Axman6> well, it's easy enough to make a type that maintains the invariants you want without the type system needing to do it
05:51:13 <Axman6> also, what's an accessor?
05:51:19 <mm_freak> mah_b: there are ready-made libraries for doing that in haskell
05:52:39 <mm_freak> it's ugly, if you have to write it yourself
05:53:08 <mah_b> Axman6: a function that accesses a datastructure to get something out (C#/Jave term)
05:54:14 <mah_b> mm_freak: nice to know that those exist. Would you mind telling me some name?
05:55:04 <mm_freak> mah_b: i'm not sure, but try HList
05:55:51 <mm_freak> there is also a library specifically for type arithmetic on hackage, but you'll have to look yourself for that one
05:56:13 <mm_freak> an efficient one that is, one that doesn't succ =)
05:57:21 <quicksilver> mm_freak: I pasted the link already
05:57:49 <quicksilver> http://hackage.haskell.org/package/type-level-0.2.4
06:00:40 * hackagebot carettah 0.0.5 - A presentation tool writtten with Haskell.  http://hackage.haskell.org/package/carettah-0.0.5 (KiwamuOkabe)
06:00:54 <hpaste> fryguybob pasted “GHC build” at http://hpaste.org/52872
06:01:21 <fryguybob> I'm trying to build GHC and I get the error ^^, any ideas?
06:06:02 <erus`> http://hpaste.org/52873 C with generics and garbage collection. what do you think?
06:06:22 <quicksilver> fryguybob: try in #ghc?
06:11:25 <benmachine> erus`: and nullable types? ew :P
06:11:44 <erus`> good point
06:11:50 <mah_b> erus`: why are you using "object"? I think "struct" would be the better suited to C.
06:12:08 <erus`> because it can be inhereted
06:12:14 <erus`> multiple inheritance
06:13:50 <erus`> maybe i can fuse haskell style algebraic types into a C type language
06:13:59 <osfameron> that would be interesting
06:14:46 <Eelis> erus`: C++ has Boost.Variant
06:15:41 <mah_b> erus`: ok, that sounds great. Another issue would be where to place semicolon and $. Especially the latter. It doesn't get used in like 5/14, but has to be used everywhere else.
06:15:51 <mah_b> * like = line
06:16:21 <erus`> mah_b: only use a $ in the object/function definition, not the body
06:17:15 <mah_b> erus`: yes, noew I see. How would you allow nesting of generics? using "(" and ")"?
06:18:07 <erus`> like a list (list int) foo; ?
06:29:58 <erus`> @src Generic
06:29:58 <lambdabot> Source not found. Sorry.
06:34:20 <anita> greetings
06:43:50 <daveo> if i have the file people.txt in the same location as my file.hs, what's wrong with the line -- people_text <- readFile "people.txt" -- it throws a parse error
06:43:57 <daveo> i'm following a tutorial
06:46:18 <dylukes> parseTest myExpr "-a! + --b * c"
06:46:18 <dylukes> >>> Add (Neg (Fac (Sym 'a'))) (Mul (Neg (Neg (Sym 'b'))) (Sym 'c'))
06:46:23 <dylukes> TT^TT It works.
06:47:26 <dylukes> I feel so satisfied right now. Maybe I should keep going and do mixfix... I'm pretty sure there's a general representation here.
06:47:56 <dylukes> Or rather, parsers are either (op ...) or (lhs op ...)
06:48:45 <siracusa> daveo: Where did you put that line?
06:49:31 <daveo> siracusa: http://lisperati.com/haskell/ht2.html
06:50:03 <daveo> inside a
06:50:16 <daveo> "tutorial.hs" file
06:50:41 <siracusa> That won't work, you have to put it inside a do-block
06:51:14 <dylukes> So the problem I'm having with postifx operators is
06:51:36 <dylukes> if I have an expression like "a *" (where there is an infix *, but no postfix *)
06:51:55 <dylukes> then it tries t parse it as infix, it fails when it can't parse a rhs, then tries infix
06:52:10 <dylukes> and then this fails
06:52:15 <dylukes> so it just returns the lhs :\
06:52:22 <daveo> siracusa: thanks, i had indention wrong
06:52:39 <dylukes> ah, here we go, I think.
06:53:18 <dylukes> yeah, removing the optional works, but then "a * b" results in an unexpected EOF
06:54:28 <dylukes> it's like... if the rhs isn't there, it could be either, it's an infix,
06:54:31 <dylukes> postfix*
06:54:37 <dylukes> or, it could be the end of the expression
06:54:42 <dylukes> or, it could be an error
06:54:53 <benmachine> dylukes: are you sure your grammar is unambiguous?
06:55:05 <dylukes> "a *" is incomplete
06:55:27 <dylukes> "a * b" is not, but there COULD be subsequent expressions after the b, and its not handling that correctly when there arent.
06:55:42 <dylukes> "a !" is not incomplete, because ! is postfix.
06:55:47 <dylukes> I'll figure it out
06:55:51 <dylukes> I have vocab quiz to do now.
07:01:27 <erus`> maybe i dont need garbage collection...
07:01:37 <hpaste> Shotor pasted “take sequence print randoms” at http://hpaste.org/52877
07:01:51 <hpaste> Shotor pasted “take sequence print randoms” at http://hpaste.org/52878
07:03:49 <int-e> @type randoms `fmap` newStdGen
07:03:50 <lambdabot> forall a. (Random a) => IO [a]
07:04:21 <mah_b> erus`: if you do something like raii, you shouldn't need.
07:06:29 <Husel> how do I stop the window from closing once main has finished?
07:06:34 <hpc> Husel: on windows?
07:06:39 <Husel> yes
07:06:56 <hpc> the hacky way is just to end main with "interact id"
07:07:06 <hpc> then exit your program with ctrl+D iirc
07:07:14 <RaptorRarr> Husel: You can use command line switches for cmd.exe.
07:07:56 <Husel> hpc: it works, thanks :)
07:08:10 <Husel> RaptorRarr: cmd.exe?
07:08:22 <Husel> you mean in my compiled .exe file?
07:08:31 <hpc> Husel: cmd.exe is the terminal program
07:09:06 <Husel> ah, okay
07:10:34 <Husel> is there a way to make ghci automatically run main without compiling?
07:10:43 <Husel> without having to type "main"?
07:10:55 <Cale> Husel: um, why?
07:11:00 <Cale> You can use runghc/runhaskell
07:11:01 <Husel> laziness :P
07:11:28 <Cale> I guess you could put 'main' in your .ghci
07:11:52 <mercury^> Not a good idea. :)
07:12:01 <Cale> yeah, that'd be awkward
07:12:21 <Husel> Cale: runhaskell works :) thanks
07:13:17 <mercury^> If you are using a unix shell you can also put #!/usr/bin/runhaskell or something like it into the first line.
07:22:25 <matthiasgorgens> How do I use QuickCheck in practice?
07:22:44 <Cale> matthiasgorgens: by applying quickCheck to properties that you write
07:22:46 <matthiasgorgens> My modules normally only export some subset of their functions.
07:23:03 <matthiasgorgens> Should I put the quickcheck properties in the module, or should I have a wrapper module?
07:24:20 <Cale> I normally just do whatever's most convenient, which is usually just sticking the properties in the same module. If you're worried about dependencies, you can always comment or ifdef out the tests.
07:24:41 <matthiasgorgens> Hmm, ifdef could be useful.
07:41:52 <rostayob> @djinn a -> (a -> b) -> b
07:41:53 <lambdabot> f a b = b a
07:42:34 <yrlnry> @djinn (a, a->b) -> b
07:42:34 <lambdabot> f (a, b) = b a
07:42:52 <rostayob> @djinn (a, b) -> a
07:42:53 <lambdabot> f (a, _) = a
07:42:59 <geheimdienst> what would be a haskell approximation of clojure's atoms? a pointer to one piece of data that can be changed atomically without race conditions http://clojure.org/atoms
07:43:27 <hpc> MVar?
07:43:45 <Cale> IORef?
07:44:07 <Cale> It's impossible to observe a half-mutated IORef
07:44:50 <geheimdienst> hpc, that was my first guess as well, but mvars seem a little weaker ... "readMVar, swapMVar, withMVar, modifyMVar_ and modifyMVar are simply the composition of a takeMVar followed by a putMVar with exception safety. These only have atomicity guarantees if [some condition]"
07:45:19 <geheimdienst> cale, i think that's a bingo
07:45:56 <Cale> Of course, we have something better in the form of TVars
07:46:01 <kmc> (so does clojure)
07:46:21 <Cale> You can do arbitrary transactions across multiple TVars with all-or-nothing semantics.
07:46:46 <kmc> modifyMVar is atomic if you follow a certain convention
07:46:50 <kmc> which is to block on an empty mvar
07:46:56 <Cale> yeah
07:49:25 <noam>  /join #clojure
07:49:30 <noam> oops
07:52:12 <hpc> is there a good resource that explains the differences between IORef, MVar, etc, with repsect to threading?
07:52:41 <kmc> just the haddock docs, afaik
07:52:57 <kmc> RWH might talk about it
07:53:15 <Solunac_> exit
07:53:18 <kmc> i've been unable to get a straight answer on whether readIORef and writeIORef are safe to use in a multithreaded context
07:53:24 <kmc> guaranteed safe, i mean
07:53:25 <kmc> they usually work
07:53:37 <kmc> atomicModifyIORef has an explicit atomicity guarantee
07:53:58 <parcs> i think atomicModifyIORef uses a global lock
07:54:05 <parcs> at least, that's what its documentation implies
07:54:08 <kmc> i thought it uses an atomic compare-and-swap
07:54:10 <kmc> in GHC
07:54:15 <kmc> and that's why it can't be made strict
07:54:24 <kmc> MVars have explicit blocking behavior which is kind of like a lock
07:54:43 <kmc> and TVars have the guarantees you get from STM generally
07:54:43 <geheimdienst> hpc: i'd read it for sure
07:54:48 <doelie> Hello
07:54:48 <doelie> Is there a name for this recursion pattern?
07:54:48 <doelie> mapfold :: (s -> i -> (s, o)) -> s -> [i] -> [o]
07:54:48 <doelie> mapfold f s (i:is) = (o:os) where (s', o) = f s i os = mapfold f s' is
07:54:55 <int-e> kmc: yes, it does use compare-and-swap
07:54:55 <kmc> (which are very strong)
07:54:57 <parcs> "If you only have one IORef, then using atomicModifyIORef to access and modify it will prevent race conditions."
07:54:59 <kmc> :t mapAccumL
07:55:01 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:55:13 <kmc> parcs, the point is that you can't modify two IORefs atomically at once
07:55:33 <benmachine> kmc: isn't it possible to implement read/write in terms of atomicModify?
07:55:37 <kmc> yes
07:55:59 <geheimdienst> haddock sez "Extending the atomicity to multiple IORefs is problematic, so it is recommended that if you need to do anything more complicated then using Control.Concurrent.MVar.MVar instead is a good idea." (wonder why mvar and not tvar, but whatever ...)
07:56:54 <Cale> Probably because that documentation was written before STM existed.
07:56:56 <kmc> STM didn't exist / wasn't polished
07:56:58 <kmc> is my guess
07:57:06 <Cale> But it's true nonetheless.
07:57:07 <parcs> kmc: oh, i misinterpeted
07:57:19 <kmc> also STM can perform much worse than MVar
07:57:19 <Cale> TVar is another good option as well.
07:57:23 <Cale> yes
07:57:25 <kmc> (or also much better, so it would be silly for the docs to take a side on these grounds)
07:57:48 <hpc> doesn't STM only perform significantly worse in cases where MVars would give incorrect output?
07:58:12 <hpc> (ie, when it has to retry a computation)
07:58:21 <kmc> that doesn't imply MVars would give incorrect output
07:58:28 <kmc> it implies that there would be some blocking and locking going on
07:58:32 <hpc> ah
07:58:34 <geheimdienst> if we throw correctness out the window, i can make arbitrary programs arbitrarily fast
07:58:45 * geheimdienst , wizard optimizer
07:58:46 <int-e> does STM have MVar's fairness guarantees?
07:58:48 <hpc> > fix id -- the fastest infinite loop in the west
07:58:52 <lambdabot>   mueval-core: Time limit exceeded
07:58:55 <kmc> locking-based systems will beat optimistic lock-free systems at high contention
07:58:59 <hpc> aw, it didn't <<loop>>
07:59:16 <kmc> with optimistic lock-free, you can have 100 threads each try to do the same thing repeatedly stepping on each other's toes
07:59:45 <kmc> adding a lock will make them run sequentially in some arbitrary order
07:59:49 <kmc> but only once each
08:00:08 <kmc> STM doesn't have to be implemented in an optimistic lock-free fashion, though
08:00:10 <hpc> ah, that makes more sense
08:00:24 <kmc> it would be cool if GHC's STM could detect contention and add some locking dynamically
08:00:52 <hpc> it would also be hard, i would think
08:01:17 <int-e> well, retry does not retry immediately -- it waits for one of the used TVars to be changed before re-running the code.
08:01:38 <parcs> kmc: but then the documentation says "Extending the atomicity to multiple IORefs is problematic, so it is recommended that if you need to do anything more complicated then using Control.Concurrent.MVar.MVar instead is a good idea." you can't modify two MVars atomically at once either
08:02:28 <kmc> the intent is that emptying the MVar is like taking a lock
08:02:50 <int-e> I suspect with all the freedom that STM gives you (future actions can depend arbitrarily, albeit deterministically, on previous results) it's hard to do much better.
08:03:09 <kmc> much better at contention?
08:03:33 <int-e> yeah.
08:03:47 <kmc> the bad case is one where you're retrying the same actions over and over
08:04:12 <kmc> so you already know what's going to happen
08:04:12 <kmc> i think it's pretty easy, conceptually
08:04:13 <int-e> I guess you can steal some heuristics from databases -- for example, when a transaction has failed for a certain number of times, let it run alone.
08:04:39 <kmc> associate with each TVar a lock; if you retry a transaction n times, take the lowest-numbered locks from any of those tvars and try again
08:04:56 <int-e> but even that doesn't quite fit STM, where transactions can wait for certain conditions (using retry)
08:06:03 <kmc> parcs, you can modify two MVars atomically if you assume that readers will block on an empty MVar, which is the default behavior
08:06:04 <c_wraith> well, STM could distinguish between explicit retry and failure at commit-time
08:06:57 <int-e> True.
08:08:32 <leino> is there any way to "overload" an instance declaration? say for instance that I want to use something which is an instance of Show, but I want to provide my own show function for it
08:11:15 <dumael> leino: overlapping instances ?
08:11:26 <geheimdienst> leino: this? http://haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
08:11:34 <kmc> i doubt crazy GHC extensions are the right aswer
08:11:43 <kmc> leino, what are you actually trying to do?
08:12:02 <kmc> can you either a) write a new function, that isn't 'show',  or b) invent a new type
08:12:19 <leino> kmc: hehe I'll tell you, hold on a sec
08:12:45 <kmc> if you want to "override" the Show instance for String, you can do something like
08:12:58 <kmc> data MyString = MyString String;  instance Show MyString where ...
08:12:59 <leino> ok I have a datatype for univariate polynomials (polynomials in one variable)
08:13:14 <kmc> (usually you'd use "newtype" not "data", but the differences between them are not super relevant)
08:13:23 <leino> and I do a bunch of multivariate calculations with them by taking univariate polynomials as coefficientes
08:13:27 <leino> *coefficients
08:13:36 <leino> so I can stack them
08:15:46 <leino> the problem is that, if I want to show a polynomial like "(x+1)*y^2" and y is the "topmost" variable, it will come out as "x+1*y^2"
08:16:11 <leino> in some cases I am stacking three of these on top of each other and the output is hard to read
08:16:35 <leino> so I simply want to include parenthesis for the coefficients in the show function for UPolys
08:17:54 <leino> kmc: that's what I'm really trying to do
08:22:40 <leino> I think overlapping instances might be what I want... just need a hack to get readable (unambiguous) output. it will end up in latex format anyway
08:24:12 <mah_b> are you able to figure out how many summands the polynomial contains?
08:25:17 <leino> not in general (in the above example, yes of course)
08:25:44 <mah_b> so how do you want to figure out when to add braces?
08:25:46 <leino> at least not from output, I assume that's what you mean
08:26:14 <kmc> leino, why do you need to use 'show' for this?
08:26:21 <leino> I would add the braces in the overridden show function
08:26:31 <kmc> you can write your own function that returns a String
08:26:44 <leino> kmc: I output these stacked UPolys in larger structures like matrices and vectors, it would be simplest
08:26:51 <kmc> ok
08:27:05 <kmc> isn't UPoly a data type you defined?
08:27:21 <leino> its part of an algebra package I need to use
08:27:24 <kmc> ah
08:27:32 <kmc> so it already has a Show instance you don't control :/
08:27:39 <leino> yep
08:27:42 <kmc> well the "right way" is like
08:27:55 <kmc> newtype MyUPoly = MyUPoly UPoly;  instance Show MyUPoly where ...
08:28:04 <kmc> it's kind of cumbersome though
08:28:31 <leino> that would be a lot of code to change
08:29:03 <leino> or I guess I could newtype UPoly = ... if I import UPoly qualified
08:29:12 <kmc> yeah
09:30:48 <n1tn4tsn0k> How to read some numbers splitted by whitespace from stdin?
09:31:03 <n1tn4tsn0k> Is there something line C scanf in haskell?
09:31:38 <n1tn4tsn0k> * like
09:31:57 <engla_> n1tn4tsn0k: getLine and read in proper combination
09:33:19 <n1tn4tsn0k> engla_, this way I need to parse string char by char.
09:33:45 <stepkut> n1tn4tsn0k: parsec?
09:34:33 <stepkut> n1tn4tsn0k: there are also a bunch of regex libraries.. but those won't actually turn the strings into numbers.. or give good error messages
09:35:06 <n1tn4tsn0k> stepcut, no i should use standard libraries only.
09:35:37 <stepkut> n1tn4tsn0k: with parsec you would do something like, do x <- int ; skipMany1 whitespace ; y <- int ; skipMany1 whitespace ; x <- int ; return (x, y, z)
09:35:46 <RaptorRarr> @type partition
09:35:47 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:38:26 <kmc> > let f :: String -> [Integer]; f = map read . words in f "12 345 67"
09:38:27 <lambdabot>   [12,345,67]
09:38:39 <kmc> n1tn4tsn0k, ^^^^
09:39:07 <n1tn4tsn0k> :)
09:41:06 <n1tn4tsn0k> kmc, thank u. :)
09:56:47 <hpaste> paolino pasted “replace a node in ntree” at http://hpaste.org/52882
09:58:16 <paolino> hello , I'm trying to replace a node in a ntree without using a zipper. The code I pasted seems to work, but maybe there is a cleaner solution
10:01:40 <MisterKite> hey, just a quick homework question. I have to do this " Implement a function zeroCommPf::Natural -> Pf Natural which returns a proof
10:01:40 <MisterKite> that for a natural n::Natural (the supplied argument), it is the case that (Plus Zero
10:01:40 <MisterKite> n) is equal to n."   and my data constructor for naturals is "data Natural = Zero | Succ Natural | Plus Natural Natural
10:01:40 <MisterKite> deriving (Show, Eq)"
10:02:51 <mah_b> what bis Pf a?
10:02:54 <mah_b> * bis = is
10:03:18 <MisterKite> sorry for spacing. It is also provided that  For the Base case, build a proof that (Plus Zero Zero) is equal to Zero.  How do i write this base case? I'm messing up on syntax
10:03:48 <MisterKite> Pf a is a type from a previous problem that is "data Pf a = Equal a a"
10:05:37 <Gracenotes> does anyone have an example of a ridiculously long, but nonetheless useful, list comprehension?
10:06:10 <mike-burns> I have neither, no.
10:06:16 <Gracenotes> heh. well, something that has a lot of logic compressed together
10:06:59 <Gracenotes> trying to come up with some relational-ish thing which could be the target of optimization
10:17:34 <tsousa> in this code     data Bool = False | True   a bool only can be False or True right? but in this one     data Maybe a = Nothing | Just a   what is Just ?
10:18:06 <paolino> tsousa: Just is a constructor
10:18:15 <paolino> like True and False
10:18:29 <paolino> but takes an argument of type a
10:18:31 <tsousa> what it construct?
10:18:45 <engla_> it constructs Maybe a
10:19:05 <engla_> Just :: a -> Maybe a
10:19:12 <kirindave> Does it work in here?
10:19:14 <kirindave> @type Just
10:19:15 <lambdabot> forall a. a -> Maybe a
10:19:18 <kirindave> There you go, sir.
10:19:20 <kirindave> :)
10:19:37 <paolino> tsousa: a tag around some values, which builds a new value of its type
10:19:46 <engla_> tsousa: a constructor is not reducable, so to speak
10:20:03 <engla_> tsousa: just like (1:2:[])  (the same as [1,2]) you can't reduce it
10:20:07 <tsousa> like in this code data NestedList a = Elem a | List [NestedList a] what Elrm does?
10:20:22 <mauke> it builds a NestedList
10:20:31 <Botje> it's a data constructor.
10:20:32 <kirindave> tsousa, just so, only it it builds a Maybe instead of a NestedList
10:21:08 <tsousa> men i am not understanding
10:21:16 <paolino> tsousa: it wraps a value of type 'a'
10:21:48 <tsousa> wraps in what?
10:22:06 <paolino> it's like a container for the value
10:22:09 <parcs> tsousa: do you have a phd in category theory? if not, there's your problem
10:22:27 <tsousa> lol
10:22:32 <tsousa> i am not even in the univ
10:22:41 <tsousa> i am a self learner
10:24:19 <parcs> there is no substitute for a phd in category theory
10:24:38 <tsousa> parcs, are you a troll?
10:25:10 <cheater> hi
10:25:25 <parcs> at the moment, yes
10:25:26 <Cale> tsousa: He seems to be trying ;)
10:25:40 <paolino> tsousa: you understand the use of Maybe ?
10:26:14 <parcs> tsousa: what material are you reading?
10:26:23 <Cale> tsousa: A value of type NestedList a is either of the form  Elem x, where x has type a, or it is of the form List xs where xs is a list of values of type NestedList a
10:27:15 <Cale> tsousa: For example, List [Elem 1, List [Elem 2, Elem 3], Elem 4] :: NestedList Integer
10:27:28 <tsousa> Cale, so Elem a is just a value?
10:27:32 <Cale> "NestedList" is a terrible name, given that it's a tree
10:28:00 <Cale> Elem :: a -> NestedList a
10:28:06 <paolino> a value of type "NestedList a"
10:28:08 <Cale> List :: [NestedList a] -> NestedList a
10:29:02 <tsousa> like List(Elem 4) will create [4] ?
10:29:10 <tsousa> or [[4]] ?
10:29:16 <paolino> neither
10:29:38 <paolino> those are not of type NestedList a
10:29:59 <paolino> they are of type [Int] and [[Int]]
10:31:22 <tsousa> paolino, so what will create?
10:31:29 <paolino> Elem 4 is a value, an inhabitant of values of type NestedList a
10:32:12 <tsousa> yes
10:32:17 <paolino> NestedList Int, sorry
10:32:18 <Cale> List (Elem 4) is a type error, because List expects a list of values of type NestedList a as its parameter, while Elem 4 is just of type NestedList Integer
10:32:40 <tsousa> Cale, so what will be the output?
10:32:43 <Cale> List [Elem 4] is valid though
10:32:56 <Cale> List [Elem 4] is a thing, already completely evaluated
10:33:09 <Cale> It is its own result, I guess
10:34:00 <tsousa> humm thanks
10:34:32 <paolino> Like a tower with rooms and people inside, it's a value, a thing
10:34:34 <tsousa> so that type is recursive declared right?
10:34:39 <Cale> yeah
10:34:59 <Cale> We can write a function to determine the number of Elems in a NestedList like this:
10:35:12 <tsousa> this haskell types freacks me out a bit. but haskell is a greate language
10:35:12 <Cale> size (Elem x) = 1
10:35:25 <Cale> size (List xs) = sum [size x | x <- xs]
10:36:10 <tsousa> Cale, xs is the elements in the list?
10:36:27 <Cale> xs is a list of NestedLists
10:36:40 <Cale> For example...
10:36:57 <Cale> size (List [Elem 1, List [Elem 2, Elem 3], Elem 4])
10:37:26 <Cale> -> sum [size (Elem 1), size (List [Elem 2, Elem 3]), size (Elem 4)]
10:37:53 <Cale> -> sum [1, sum [size (Elem 2), size (Elem 3)], 1]
10:38:03 <Cale> -> sum [1, sum [1, 1], 1]
10:38:11 <Cale> -> sum [1, 2, 1]
10:38:11 <tsousa> nice
10:38:17 <Cale> -> 4
10:38:32 <Cale> (that is not the actual order of evaluation, but that doesn't matter)
10:39:14 <tsousa> i create another list just putting another List. cool stuff
10:39:14 <tsousa> Good Times eheh
10:39:37 <dmwit> ?src replicateM
10:39:38 <lambdabot> replicateM n x = sequence (replicate n x)
10:46:21 <angstrom> how'd I go about mapping over a list, such that each application "depends" on the outcome of the previous one?
10:46:53 <Botje> there's a mapAccumL
10:47:30 <geheimdienst> angstrom: you might be looking for foldr?
10:53:22 <angstrom> geheimdienst: by "depends" I meant, "changes behaviour", if that makes sense. e.g., `f [0,1,2,0,4] -> [Nothing, Just 1, Nothing, Nothing, Just 4]' where Just is used on each element after 0 and Nothing otherwise
10:53:44 <RaptorRarr> angstrom: zipWith, tail
10:54:40 <RaptorRarr> > let f xs = Nothing:zipWith (\a b -> if a == 0 then Just b else Nothing) xs (tail xs) in f [0,1,2,0,4]
10:54:41 <lambdabot>   [Nothing,Just 1,Nothing,Nothing,Just 4]
10:55:00 <angstrom> RaptorRarr: :-)
10:58:22 <angstrom> RaptorRarr: and what about `f [2, 1, 4, 1, 5] -> [Nothing, Just 1, Just 4, Nothing, Just 5]'? it's kindof the reverse approach, where each number dictates how many Justs will be applied
11:05:39 <angstrom> afaict, it's a stateful computation. so the state monad would make sense, no?
11:07:15 <geheimdienst> angstrom: how is that second thing supposed to work? the number after a Nothing says how many Justs follow?
11:08:26 <mah_b> geheimdienst: imho each element that is followed by "1" gets Nothing.
11:09:02 <mah_b> geheimdienst: no, not :)
11:09:29 <mah_b> @type mapAccumL
11:09:30 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:10:54 <mah_b> > snd $ mapAccumL (\a x -> if a == 0 then (x, Nothing) else (a-1, Just x)) 0 [2,1,4,1,5]
11:10:55 <lambdabot>   [Nothing,Just 1,Just 4,Nothing,Just 5]
11:12:24 <angstrom> mah_b: I see. so, indeed, mapAccum it is!
11:18:02 <DanBurton> :t mapAccum
11:18:02 <lambdabot> Not in scope: `mapAccum'
11:18:08 <DanBurton> :t mapAccumL
11:18:09 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:18:16 <DanBurton> oh wait lol :P
11:18:23 <DanBurton> that's what I get for not reading the whole chat history
11:19:57 <DanBurton> @info mapAccumL
11:19:57 <lambdabot> mapAccumL
11:20:02 <DanBurton> .
11:20:12 <DanBurton> @botsmack
11:20:12 <lambdabot> :)
11:22:40 <hpaste> Cale annotated “replace a node in ntree” with “replace a node in ntree (annotation)” at http://hpaste.org/52882#a52884
11:22:51 <Cale> oh
11:26:37 <dylukes> Hey
11:27:11 <dylukes> Is there a way without dependent types a type (in this case a function) parameter to a type with arity corresponding to a nat?
11:27:18 <dylukes> like, can I take value nats to type nats? :\
11:27:26 <copumpkin> sure
11:27:34 <dylukes> data Op p a = Op p Nat (Function with Arity Nat)
11:27:35 <copumpkin> :)
11:27:57 <copumpkin> data Op p a = forall n. Op p (Nat n) (Fun n)
11:28:12 <dylukes> Is Fun in base?
11:28:14 <copumpkin> not sure GHC accepts that, though
11:28:15 <copumpkin> no
11:28:29 <copumpkin> I think it should accept it though
11:28:39 <copumpkin> sometimes its head explodes if you use a type function in higher-rank types
11:28:57 <dylukes> mm, nevermind then
11:29:14 <copumpkin> what?
11:29:22 <copumpkin> it's not that hard, but it's tricky to work with
11:29:26 <dylukes> yeah
11:29:33 <dylukes> I was wondering for generalizing operators.
11:29:36 <copumpkin> typically you'd just write Fun n as Vec n a -> ...
11:29:40 <dylukes> What I'm seeing is two types of operators.
11:29:49 <dylukes> Those with a left hand side
11:29:51 <dylukes> and those without.
11:30:05 <dylukes> postfix operators are the same as unary infix operators.
11:30:20 <dylukes> At least, with a pratt parser they seem roughly equivalent, give or take an issue I'm having...
11:30:38 <dylukes> I get either correct handling, but no errors,
11:30:47 <dylukes> or incorrect, and errors (even where not appropriate...)
11:30:50 <dylukes> It's hard to explain...
11:31:31 <dylukes> It's like, say I have a * b
11:31:40 <dylukes> where * happens to be both postfix and infix.
11:31:57 <dylukes> this shouldn't be ambiguous, and I'm admitting lookahead...
11:33:47 <dylukes> But the problem is after a * b it can't differentiate between "there isnt another expression" and unexpectedly missing one...
11:33:49 <dylukes> *sigh*
11:34:13 <dylukes> @hoogle Fun
11:34:13 <lambdabot> Language.Haskell.Syntax fun_tycon :: HsType
11:34:13 <lambdabot> Language.Haskell.Syntax fun_tycon_name :: HsQName
11:34:13 <lambdabot> module Data.Function
11:40:50 * hackagebot NanoProlog 0.2.3.3 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.2.3.3 (DoaitseSwierstra)
11:42:19 <BrianHV> I want to write a TH splice that takes a type signature so that I can generate a function with said signature. however, doing this gives me a "Not in scope: type variable `a'" error: $(macroDefineFunction [t|(a -> a -> a)|] "myConst" ["p1", "p2"] "p1")
11:48:20 <shachaf> blbrown_win3: What's "t"?
11:48:37 <shachaf> Er.
11:48:43 <shachaf> BrianHV, I mean.
11:50:21 <BrianHV> shachaf: the "Type" quoter. http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html#id712116
11:50:46 <shachaf> Oh, I thought it was your own operator.
11:51:33 <Cale> BrianHV: what happens if you put in an explicit forall?
11:51:36 <shachaf> Well, you could add "forall a." in front...
11:52:29 <shachaf> Looks like it just doesn't do it?
11:52:42 <shachaf> Or at least didn't in 2007: http://www.haskell.org/pipermail/template-haskell/2007-February/000592.html
11:53:44 <BrianHV> I had to add RankNTypes, but that compiles...
11:53:49 <BrianHV> more verbose than I was hoping for though
11:54:16 <saml> pronk is awesome
11:54:23 <shachaf> You could implement a quasiquoter that does it. :-)
11:55:18 <BrianHV> shachaf: I'd rather not reimplement a haskell type signature parser. is there something in Language.Haskell somewhere that I can call to get a type's parse tree?
11:56:42 <shachaf> BrianHV: Language.Haskell.parseType?
11:57:54 <elliott> http://hackage.haskell.org/trac/ghc/changeset/b59fe25a24c4b913a9935c71b1b42a060ab53dcc/utils -- does this mean that the Show/Eq superclasses of Num are finally gone???
11:58:23 <DanBurton> YES PLEASE
11:58:34 <elliott> I found http://haskell.1045720.n5.nabble.com/Proposal-Remove-Show-and-Eq-superclasses-of-Num-td4808712.html
11:58:37 <elliott> but there's nothing about it actually being committed
11:58:53 <BrianHV> shachaf: sounds promising...
11:59:58 <Cale> That's probably actually in Language.Haskell.Exts.Parser
12:01:18 <mgsloan1> yup, I use the one in exts
12:02:34 <shachaf> Hmm, http://hackage.haskell.org/trac/ghc/changeset/c49210958cf2ab403baf146d7f92eef499788e0e
12:02:55 <dafis> elliott: IT'S COMMITTED, IN 7.4 THEY WON'T BE
12:03:01 <BrianHV> I found one in meta, but I'll check out exts too
12:03:05 <elliott> dafis: YAYAYAYAAYAYAYAYAYAYAYAYAYAY
12:03:07 <BrianHV> ...later. gotta run now.
12:03:09 * dafis hates caps lock
12:03:09 <BrianHV> thanks for the help!
12:03:21 <elliott> dafis: it is _completely_ appropriate here
12:03:33 <dafis> rare luck
12:03:40 <elliott> dafis: So is Functor a superclass of Monad too? ;-)
12:03:50 <shachaf> elliott: As if this actually changes anything significant.
12:03:52 <geheimdienst> oh great, more code breakage :(
12:03:54 <shachaf> Num is still broken.
12:03:57 <dafis> nope, that's for the future
12:04:04 <elliott> shachaf: Yes, but _warm fuzzies_.
12:04:06 <shachaf> Now some existing code will be broken as well as Num.
12:04:23 * elliott thinks we should just add some change that makes every single existing piece of code broken, and then we can fix everything without worrying about that.
12:04:39 <elliott> Say, change "module" to "module named".
12:04:50 <shachaf> @slap elliott
12:04:50 * lambdabot beats up elliott
12:05:00 <dolio> Not all modules start with a module header.
12:05:10 <dolio> Try again.
12:05:17 <elliott> dolio: No, that's required now.
12:05:19 <elliott> Obviously.
12:05:28 <dolio> Oh of course.
12:06:26 <etpace> @hoogle (a -> m b) -> [a] -> [(a,b)]
12:06:26 <lambdabot> No results found
12:06:33 <etpace> @hoogle (a -> m b) -> [a] -> m [(a,b)]
12:06:33 <lambdabot> No results found
12:06:37 <geheimdienst> i wish when they burden everyone with a breaking change, they wouldn't do that for so little
12:07:21 <augur> does the first order section of TAPL address using type checking to find particular instantiations of polymorphic functions, or just checking of polymorphic functions?
12:07:21 <etpace> :t \f xs -> mapM (\x -> f x >>= (x,)) xs
12:07:22 <lambdabot> Illegal tuple section: use -XTupleSections
12:07:32 <shachaf> geheimdienst: Yes.
12:07:35 <etpace> :t \f xs -> mapM (\x -> f x >>= \x' -> (x, x')) xs
12:07:35 <lambdabot> forall a a1. (Monad ((,) a)) => (a -> (a, a1)) -> [a] -> (a, [a1])
12:07:38 <shachaf> Say, replace Num with category-extras.
12:07:44 <geheimdienst> imho they should have said, if we break things, let's remove these superclasses and at least address 1 or 2 other grievances
12:07:44 <shachaf> That would be reasonable. Right?
12:08:14 <elliott> shachaf: Replace Num with Functor.
12:08:16 <geheimdienst> category-extras, eh?
12:08:31 <shachaf> elliott: Make Functor a superclass of Num!
12:08:35 <shachaf> Then everyone's happy, right?
12:08:38 <dafis> etpace: you could have simply writtne (,) x
12:08:44 <dafis> written*
12:08:56 <elliott> shachaf: No, Arrow.
12:08:58 * copumpkin loves doing return . unsafePerformIO
12:09:11 <DanBurton> @slap copumpkin
12:09:12 * lambdabot clobbers copumpkin with an untyped language
12:09:20 <shachaf> copumpkin: Did something happen on Reddit again?
12:09:23 <copumpkin> no no
12:09:25 <copumpkin> I actually wrote it
12:09:28 <copumpkin> on purpose
12:09:32 <dolio> unsafeInterleaveIO = return . unsafePerformIO
12:09:54 <copumpkin> yeah, but I can never remember where unsafeInterleaveIO lives
12:09:54 <DanBurton> @src unsafeInterleaveIO
12:09:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:10:21 <elliott> copumpkin: same place as Perform, no?
12:10:27 <copumpkin> oh, okay
12:10:30 * copumpkin uses that instead then
12:10:33 <DanBurton> @hoogle unsafeInterleaveIO
12:10:33 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
12:11:47 <DanBurton> looks like the source is a little nastier than "return . unsafePerformIO" http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-IO.html
12:11:52 <copumpkin> yeah
12:14:13 <elliott> DanBurton: It's equivalent, modulo silly GHC avoid-duplicate-work stuff
12:14:54 <dafis> elliott: avoiding work is never silly
12:15:02 <copumpkin> in my case, it's unnecessary
12:15:12 <copumpkin> as duplicating the work will give me the same result and launch no missles
12:15:14 <copumpkin> missiles
12:15:16 <dolio> It's about what you get by inlining all the definitions and reducing a little.
12:15:26 <elliott> copumpkin: Use unsafeDupableInterleaveIO then.
12:15:29 <elliott> You know, for the _speed_.
12:15:32 <copumpkin> lol
12:16:08 * dafis wonders how many of the people always using 'launch missiles' actually remember the times
12:16:31 <elliott> The time someone actually launched a missile with unsafePerformIO?
12:17:03 <Botje> it was unsafeLegend.. wait for it.. ary!
12:17:11 <dafis> no, the time when launching missiles was a realistic threat
12:17:33 <elliott> It is, thanks to industry-strength acme-missiles technology.
12:17:38 <elliott> Oh gosh, it's grown.
12:18:11 <RaptorRarr> I launch missiles all the time.
12:18:21 <RaptorRarr> It's part of my job as a raptor.
12:18:33 <dolio> Nobody ever wrote missile command systems in Haskell, so it was never a threat.
12:18:40 <RaptorRarr> http://www.buzzfeed.com/adamd/raptor-shark-rpg-hb6
12:18:50 <dafis> I thought the job of raptors was to kill users of goto?
12:18:56 <RaptorRarr> Kill?
12:19:01 <RaptorRarr> We get excited by goto!
12:19:08 <RaptorRarr> Overly excited
12:20:32 <RaptorRarr> No killing here: http://xkcd.com/292/
12:21:21 <kmc> it has been [0] hours since the last xkcd reference
12:21:26 <dafis> fifth panel
12:22:03 <RaptorRarr> In the fifth panel, the raptor opens some champagne and starts jumping excitedly on a trampoline.
12:23:06 <kmc> in the fourth panel, a man is showing off his unusual physical ability
12:35:55 <n1tn4tsn0k> Is there a standard operator to invert parameters of function?
12:36:29 <RaptorRarr> flip
12:36:39 <RaptorRarr> @src flip
12:36:40 <lambdabot> flip f x y = f y x
12:36:54 <n1tn4tsn0k> Thank you.
12:36:58 <RaptorRarr> You're welcome.
12:37:04 <n1tn4tsn0k> :)
12:37:10 <Ferdirand> @pl \f x y -> f y x
12:37:11 <lambdabot> flip
12:37:19 <Ferdirand> @pl \f x y z -> f x z y
12:37:20 <lambdabot> (flip .)
12:37:32 <Ferdirand> @pl \f x y z t -> f x y t z
12:37:32 <lambdabot> ((flip .) .)
12:37:37 <n1tn4tsn0k> 0_0
12:37:41 <n1tn4tsn0k> wowow
12:37:42 <n1tn4tsn0k> :D
12:38:08 <shachaf> @ty (`on`(1/))
12:38:09 <lambdabot> forall b c. (Fractional b) => (b -> b -> c) -> b -> b -> c
12:38:21 <RaptorRarr> @yw
12:38:22 <lambdabot> Couldn't find fortune file
12:38:26 <Ferdirand> @pl \f x y z t -> f y x t z
12:38:27 <lambdabot> ((flip .) .) . flip
12:38:49 <Ferdirand> now you know how to arbitrarily reorder parameters using only flip and (.) !
12:39:38 <RaptorRarr> @pl \f x y z t -> f t x y z
12:39:39 <lambdabot> (((flip .) . flip) .) . flip
12:40:29 <Ferdirand> @pl \f x y z t -> f t y z x
12:40:29 <lambdabot> flip . ((flip . (flip .) . flip) .) . flip
12:40:36 <Ferdirand> bubble sort ftw
12:41:22 <Ferdirand> oh no that's not bubble sort
12:52:06 <basvandijk> Hi guys, I'm trying to get the new hackage-server to build but I get a link error
12:52:22 <basvandijk> In one of the module there's an FFI import
12:52:27 <basvandijk> foreign import ccall unsafe "crypt" cCrypt :: CString-> CString -> CString
12:52:42 <basvandijk> When linking I get: undefined reference to `crypt'
12:53:09 <elliott> you might need some extra c lib, what platform?
12:53:10 <c_wraith> UnixUtils package?
12:53:14 <basvandijk> crypt is exported from unistd.h
12:53:22 <elliott> e.g. -lcrypt
12:53:22 <elliott> or w/e
12:53:56 <c_wraith> man.  That import should *not* be unsafe.
12:53:59 <basvandijk> elliott: Yes man 3 crypt says link with -lcrypt. I gues I have to add that to the cabal somewhere
12:54:10 <elliott> it's... extra-c-libraries: crypt
12:54:12 <elliott> or something like that
12:54:14 <c_wraith> Along with crypt not being thread-safe
12:54:28 <basvandijk> elliott: I will try
12:54:36 <dcoutts> basvandijk: ah yes, max was testing on osx where it's in libc, I've got a patch
12:54:50 <basvandijk> dcoutts: great!
12:54:51 <elliott> c_wraith: Ah, in Modern Haskell we don't consider threads when marking functions pure.
12:54:57 <elliott> c_wraith: cf. Data.Text.ICU.Convert
12:55:07 <elliott> "Note: this structure is not thread safe. It is not safe to use value of this type simultaneously from multiple threads."
12:55:14 <c_wraith> elliott: It can be pure.  But it shouldn't be marked safe.
12:55:25 <elliott> We need pure-ish functions.
12:55:30 <elliott> Like, you can call it from pure code, but only if you ask nicely.
12:55:55 <c_wraith> because there are args you can pass to crypt that will make it take tenths of a second to run
12:55:57 <elliott> basvandijk: it's "extra-libraries: crypt"
12:56:04 <basvandijk> elliott: thx
12:56:05 <elliott> c_wraith: yeah
12:56:20 <basvandijk> dcoutts: can you push the patch?
12:57:37 <basvandijk> elliott: it works, thanks
12:57:39 <mdempsky> Why is ``liftIO :: IO a -> StateT b (ReaderT c IO) a'' okay, but I can't cast just ``lift'' to the same type, I have to use ``lift . lift''?
12:57:41 <elliott> basvandijk: :)
12:57:47 <elliott> mdempsky: because lift only goes one level
12:58:04 <elliott> liftIO uses instances to go arbitrary depths
12:58:33 <mdempsky> elliott: I don't follow; liftIO uses instances of MonadIO and lift uses instances of MonadTrans, no?
12:58:44 <elliott> mdempsky: yes
12:58:52 <elliott> mdempsky: MonadIO is not a specialisation of MonadTrans or anything like that
12:59:03 <elliott> compare http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-Trans-Class.html and http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-IO-Class.html
12:59:03 <mdempsky> Right.
12:59:27 <elliott> mdempsky: MonadIO means "IO is at the bottom of this hierarchy", MonadTrans means "this monad has another one below it that you can get to"
12:59:29 <elliott> really roughly, anyway :)
12:59:40 <elliott> (or rather, it can have /any/ monad below it that you can get to)
13:00:28 <mdempsky> Ohh, I see the distinction now.
13:00:30 <mdempsky> Thanks!
13:00:52 * hackagebot stm-linkedlist 0.1.0.0 - Mutable, doubly linked lists for STM  http://hackage.haskell.org/package/stm-linkedlist-0.1.0.0 (JoeyAdams)
13:02:18 <kmc> anyone know if there's a way to set the 'background color' using diagrams-cairo?
13:02:36 <kmc> it seems not -- the background is really transparent, and if you want an opaque background you need to draw a square
13:07:34 <sully> @pl \e->"s="++show(s++e)++s++e
13:07:35 <lambdabot> ("s=" ++) . ap ((++) . show . (s ++)) (s ++)
13:08:45 <rferranti> O_o
13:09:04 <elliott> yeah, don't do that :P
13:09:06 <sully> (trying to golf a quine-alike)
13:09:44 <dcoutts> basvandijk: sorry it was on another machine, redid it and pushed
13:10:17 <basvandijk> dcoutts: got it, thanks!
13:12:02 <rferranti> reminded me about this http://www.gotw.ca/gotw/078.htm
13:12:08 <dcoutts> basvandijk: btw, if you want to fix the bug elliott pointed out... :-)
13:12:14 <elliott> I pointed a bug?
13:12:22 <dcoutts> elliott: crypt vs crypt_r
13:12:26 <elliott> That wasn't me :)
13:12:29 <dcoutts> oh sorry
13:12:30 <basvandijk> Oh the unsafe/safe issue?
13:12:37 <elliott> That was c_wraith.
13:12:45 <dcoutts> ah yes, c_wraith
13:13:10 <c_wraith> crypt_r is better, but it only exists in gnu libc, so not an option on os x
13:13:20 <c_wraith> @hackage nano_cryptr
13:13:20 <lambdabot> http://hackage.haskell.org/package/nano_cryptr
13:13:26 <dgpratt> well, I've dared to attempt an answer involving understanding of Monads on SO...
13:13:59 <hajimehoshi> > 1 + 1
13:14:00 <lambdabot>   2
13:14:18 <dgpratt> ...I'd love it if someone found the answer useful, but honestly I'm more worried that my answer might be innacurate or misleading...
13:14:57 <elliott> hmm, I need an unsafeInterleaveState
13:15:58 <dgpratt> ...so please feel free to correct my understanding and/or explanation: http://goo.gl/mMmla
13:17:40 <sully> @pl \e -> f (s ++ e)
13:17:41 <lambdabot> f . (s ++)
13:19:09 <elliott> dgpratt: why the url shortener
13:20:32 <dgpratt> elliott: no great reason, I guess; just trying to be...discrete (although that's not quite the right word)
13:20:40 <elliott> heh :)
13:21:17 <kmc> discreet?
13:21:46 <sully> @pl \e-> show e ++ e
13:21:47 <lambdabot> (++) =<< show
13:21:56 <dgpratt> kmc: yep, that one
13:22:21 <elliott> oh, using lazy state with a strict structure fixed everything
13:22:36 <Sgeo|web> "In general the person defining foo needs to ensure this, but, thankfully, in Haskell, all functions you can possibly define are Scott Continuous." what does that mean?
13:22:53 <Sgeo|web> http://playingwithpointers.com/archives/590
13:23:23 <dgpratt> kmc: before today, I might've claimed I was good with the English, but honestly, I never realized those were two different words with different spellings
13:23:23 <kmc> Sgeo|web, you know about the lattice of partially-defined values?
13:23:56 <Sgeo|web> ....I think I know what a partially-defined value is, but not what a lattice is
13:24:16 <ciaranm> Sgeo|web: you know those pastry things that have criss crossed decoration on top?
13:24:22 <kmc> well you have for example  ⊥ < (⊥,⊥) < (2,3)
13:24:31 <kmc> each one is "more defined" than the previous
13:24:42 <kmc> also (2,⊥) and (⊥,3) are each above ⊥ and below (2,3)
13:24:50 <kmc> but (2,⊥) and (⊥,3) are incomparable to each other
13:25:05 <kmc> Sgeo|web, ezyang and conal have some good blog posts about it... here's one http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
13:25:19 <saml> where is Severe defined?
13:25:19 <kmc> anyway this forms a partial order
13:25:31 <dgpratt> ooh, we're talking about Haskell types being a partial order aren't we (aren't we?)?
13:25:39 <kmc> haskell values
13:25:43 <kmc> values containing ⊥s
13:26:01 <dgpratt> kmc: oh, oops, values of course
13:26:18 <saml> https://github.com/mailrank/pronk/blob/master/lib/Network/HTTP/LoadTest/Report.hs
13:26:19 <dgpratt> anyways, good stuff, I showed up just in time
13:26:30 <saml> line 90
13:26:35 <Sgeo|web> WHat's Scott Continuous?
13:26:39 <kmc> i'm getting to it Sgeo|web
13:26:55 <Botje> dgpratt: monads as contexts agree with how I intuitively approach them
13:26:55 <saml> effect h OutlierVariance{..} =
13:27:05 <saml> what is that OutlierVariance{..} ?
13:27:16 <kmc> anyway you can define this relation ≤ on partially-defined values
13:27:20 <Botje> saml: matching on a data constructor without matching any of the fields
13:27:42 <saml>     case ovEffect of   where does ovEffect come from?
13:27:42 <ClaudiusMaximus> saml: -XRecordWildcards perhsp?
13:28:28 <Sgeo|web> Does this relation only look at how well defined it is? That is, is 3 ≤ 2?
13:28:39 <kmc> no they're incomparable
13:28:41 <saml> http://hackage.haskell.org/packages/archive/criterion/latest/doc/html/Criterion-Analysis.html  it's from here
13:28:49 <dgpratt> Botje: yeah, that's an idea I've come to relatively recently (and not on my own); I think it's a hard idea to see/appreciate if your background is imperative langs, though
13:28:58 <ClaudiusMaximus> saml: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html#record-wildcards
13:29:00 <kmc> (though numbers are weird, as built-in abstract types... better to work with user-defined algebraic data only, if you're being precise)
13:29:17 <Sgeo|web> 'a' and 'b' then
13:29:21 <saml> ClaudiusMaximus, thanks
13:29:26 <kmc> also incomparable
13:29:34 <kmc> that is neither 'a' ≤ 'b' nor 'b' ≤ 'a'
13:29:41 <kmc> by the way http://hackage.haskell.org/package/lub defines cool functions for playing with these things
13:29:43 <Sgeo|web> Even though they're both fully defined, huh.
13:29:44 <saml> man, how do you navigate through haskell code?
13:29:51 <Botje> dgpratt: on the contrary .. try/catch is a fine example of the Either monad.
13:29:51 <saml> too much grep and looking at hoogle
13:30:07 <kmc> Sgeo|web, right, neither one is more defined than the other, but they're not equal
13:30:07 <saml> is there a good ide? or do you just load code in ghci?
13:30:14 <Botje> dgpratt: and less obvious is null as the Maybe monad. *especially* now that java 7 and the likes are adding the ?. operator
13:30:18 <saml> can cabal start ghci with the package loaded?
13:30:21 <saml> cabal shell ?
13:30:28 <kmc> Sgeo|web, we want this relation to be a partial order, and one of the partial order axioms is that (a ≤ b) and (b ≤ a) implies (a = b)
13:30:34 <ClaudiusMaximus> saml: :browse and :info are useful in ghci
13:30:50 <Sgeo|web> Ah
13:31:00 <saml> let's say you checked out a haskell project.. it's cabal project thankfully.
13:31:14 <kmc> that library defines 'lub', which is a cool function
13:31:20 <kmc> lub (3, undefined) (undefined, 4) = (3,4)
13:31:27 <saml> how do you start navigating?  do you HAVE TO cabal install? and you import packages?
13:31:34 <ClaudiusMaximus> saml: or the haddock html documentation you get with 'cabal install' (after enabling it in .cabal/config if necessary)
13:31:36 <dcoutts> saml: we had a GSoC student work on that exact project this summer, integrating his patches is on my TODO list
13:32:00 <saml> dcoutts, which one? pronk or criterion?
13:32:31 <kmc> Sgeo|web, anyway, you can now talk about monotonic functions
13:32:34 <ClaudiusMaximus> saml: ~/.cabal/share/doc/index.html
13:32:34 <saml> i'm mainly interested in what "estimates severely affected by outliers (54.5%) "  means  when pronk reports that
13:32:35 <dcoutts> saml: we're talking about cabal ghci here right?
13:32:52 <kmc> Sgeo|web, that is, a function f such that f(x) ≤ f(y)  whenever  x ≤ y
13:33:10 <kmc> and all Haskell functions have this property
13:33:18 <saml> what does outlier mean?
13:33:20 <kmc> if the input becomes more defined, the result can't become less defined
13:33:24 <saml> in the context of http load test
13:33:36 <kmc> Sgeo|web, Scott continuity is a stronger criterion than that
13:33:47 <kmc> and I can't explain it precisely but you can probably look at the wikipedia article and have some idea what it means
13:33:50 <kmc> http://en.wikipedia.org/wiki/Scott_continuity
13:34:15 <kmc> brb
13:34:25 <dgpratt> Botje: yes, there are an increasing number of relatable examples; besides LINQ, there is the new 'async' keyword in C# seems to approximate some kind of Monad (CPS?)
13:35:09 <ClaudiusMaximus> saml: in the context of statistics, an outlier is a value greatly different from the majority of values, which might distort the averages, or something (long time since i did stats)
13:35:10 <dgpratt> err "...C# *that* seems..."
13:35:30 <saml> oh i see
13:35:32 <Botje> yep, futures are monadic :)
13:38:05 <basvandijk> dcoutts: I send you a mail with the crypt patch and another patch that updates the deps of hackage-server
13:39:01 <gtirloni> quick beginner question: what are the "-- @" comments that i see in, let's say, hpaste.org code ?
13:39:47 <tarrasch> gtirloni, line highlights perhaps?
13:39:49 <dcoutts> basvandijk: ok ta
13:39:56 <elliott> gtirloni: haddock comments, most likely
13:40:00 <dolio> The problem with lub, of course, is that Haskell types aren't a lattice.
13:40:10 <elliott> gtirloni: it's an API documentation tool, generates html from lightweight markup in comments
13:40:17 <tarrasch> oh, what elliott said ofc
13:40:22 <elliott> gtirloni: e.g. http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/Control-Applicative.html
13:40:30 <Sgeo|web> in hpasted code?
13:40:44 <cheater> dolio: what would that give you?
13:40:46 <elliott> Sgeo|web: ?
13:40:52 <gtirloni> ah, got it. thanks!
13:40:59 <gtirloni> ex. https://github.com/chrisdone/amelie/blob/master/src/Main.hs
13:41:12 <Sgeo|web> elliott: Do people generally paste in code from libraries etc?
13:41:13 <elliott> gtirloni: huh, I don't know what _that_ is.
13:41:38 <elliott> Sgeo|web: I don't get what you mean, hpaste is generally used for pasting code to show to others to demonstrate something or get help with a problem
13:41:51 <elliott> gtirloni: that's, uh, really confusing
13:43:32 <elliott> gtirloni: dunno, maybe someone else knows. that's definitely not haddock stuff
13:45:14 <gtirloni> ok
13:47:41 <dafis> gtirloni, elliott: it is haddock markup
13:47:48 <elliott> it is?
13:47:49 <gtirloni> perhaps something related to Snap?
13:47:57 <elliott> dafis: I've never seen anything like that
13:48:07 <gtirloni> i'm reading about haddock.. the '-- @' isnt supposed to have anything after the @ i guess
13:48:07 <elliott> especially this "trigger, next, label, task" stuff
13:48:09 <dafis> section 3.8.4 of the user guide
13:48:19 <elliott> dafis: nope
13:48:22 <elliott> that makes no sense in context
13:48:25 <elliott> see https://github.com/chrisdone/amelie/blob/master/src/Main.hs
13:50:15 <dafis> elliott: ah, yes, that's not haddock markup
13:50:46 <saml> wow RecordWildCards makes haskell nice
13:50:57 <saml> will this be in Haskell12 ?
13:51:05 <saml> there will be another report on 2012, right?
13:52:31 <kmc> there's supposed to be
13:52:41 <kmc> no word yet on which extensions will be accepted, afaik
13:53:06 <kmc> RecordWildCards is useful but I have some qualms
13:53:47 * elliott doesn't like the record punning stuff
13:54:01 <elliott> it's legitimising shadowing :P
13:54:28 <shachaf> RecordWildCards actually shadows the names of the accessors?
13:54:37 <shachaf> That seems kind of horrible.
13:55:04 <dolio> They let you do local opens of records-as-modules.
13:55:11 <saml> how about f a = a.asdf
13:55:14 <elliott> shachaf: Yep.
13:55:26 <elliott> dolio: If only we actually had records-as-modules
13:55:36 <elliott> saml: See TDNR.
13:55:46 <dolio> open m in ... = let M { .. } = m in ...
13:56:03 <elliott> dolio: They can't even contain types.
13:56:39 <dolio> Yeah, well, baby steps.
13:56:52 <dolio> If you don't mind the types being opaque, you can use existential quantification.
13:57:07 <dolio> And open m in ... = case m of M { .. } -> ...
13:57:39 <dolio> Of course, that doesn't give you a name for the type easily.
13:57:46 <saml> is there pair coding haskell group?
13:57:55 <saml> i want to see how people actually code over the shoulder
13:58:05 <saml> any convention or hackathon?
14:02:34 <ybit> too bad its dependent on x86
14:02:46 <saml> ybit, what does depend on x86?
14:02:51 <ybit> harpy
14:03:10 <ybit> oh sorry
14:03:34 <ybit> i guess that wouldn't make any sense to you
14:03:51 <ybit> came out of nowhere, thought i was in window 8
14:04:23 <saml> i use windows8 beta
14:04:42 <saml> are you looking for jit library?
14:05:30 <acowley> Anyone have any thoughts on the use of things like prelude-plus? Having code overwhelmed by imports is a bit distasteful.
14:05:43 <saml> i think RecordWildCard should not elide fields
14:05:58 * hackagebot newtype-th 0.2 - A template haskell deriver to create Control.Newtype instances.  http://hackage.haskell.org/package/newtype-th-0.2 (MichaelSloan)
14:06:01 <saml> Foo{a = a, ..}  b, c should not be exposed
14:06:17 <shachaf> What's the point of the "..", then?
14:06:38 <saml> shachaf, how does it work without +XRecordWildCard?
14:06:45 <shachaf> ?
14:06:53 <saml> don't you have to Foo{a=a, _ ,  _} ?
14:06:57 <shachaf> No.
14:08:59 <saml> oh yah I can do  f (Foo{a=a})
14:09:05 <saml> why do we need RecordWildCard?
14:09:05 <elliott> or just Foo{a} with puns
14:09:14 <saml> it looks like it's not useful
14:09:16 <elliott> saml: Foo{..} rather than Foo{a,b,c,d,e,f,g}
14:09:20 <elliott> for large records
14:10:13 <saml> but if you need to access b,c,d,e,f,g   it's better if you put them explicitly
14:21:19 <DukeDave> Here's one: In lots of my type signatures I have this form: "(Foo a) => Map Int a", is there a sensible way to write a type synonym for this?
14:21:28 <DukeDave> Something like FooMap
14:23:42 <kmc> saml, there are hackathons sometimes
14:24:03 <shachaf> DukeDave: Kind of, but you often want the constraint in the outer type signature.
14:24:07 <shachaf> It depends on what you're trying to do.
14:24:57 <copumpkin> I wonder
14:25:02 <copumpkin> if the plural of criterion is criteria
14:25:08 <copumpkin> is the plural of hackathon hackatha?
14:25:14 <copumpkin> hackatha christie
14:25:29 <DukeDave> shachaf: It's purely to make my type signatures more manageable
14:25:30 <hpc> copumpkin: agatha is the plural of agathon
14:25:48 <shachaf> DukeDave: What kind of type signature?
14:26:31 <accel> i'm on osx lion + xcode 4.2; is there any sane way to double click + install haskell platform?
14:26:44 <dylukes> no. GHC 7.0.3/7.0.4 don't work
14:26:49 <DukeDave> shachaf: "(Foo a) => Map Int a",
14:26:53 <dylukes> Install 7.2.1, and follow http://is.gd/LXRBhh
14:27:09 <shachaf> DukeDave: If that's the only type signature you have, then just write that?
14:27:35 <shachaf> type Syn a = Foo a => Map Int a, or something.
14:27:36 <accel> that looks horrible
14:27:40 <accel> I thikn I will downgrade back to snowleopard
14:27:45 <accel> and wait for a new haskell platform binary
14:27:56 <elliott> accel: it's not that bad
14:28:04 <elliott> just takes ten minutes
14:28:23 <DukeDave> shachaf: So that form is valid?
14:28:32 <shachaf> DukeDave: I don't know.
14:28:36 <accel> how close do I have to travel to the spedd of light for it to only take 10 minutes on my earth machine?
14:28:46 <shachaf> Does your compiler get mad at you if you try to do that?
14:29:16 <accel> someimes it accuses me of ditching it and using llvm
14:29:24 <DukeDave> shachaf: Illegal polymorphic or qualified type: EdgeData ed => M.Map Edge ed, Perhaps you intended to use -XRankNTypes or -XRank2Types
14:29:42 <elliott> DukeDave: Note that shachaf included the "a" in the "type Syn a".
14:29:43 <shachaf> DukeDave: Are you using a nested type or something?
14:29:49 <shachaf> I asked what your full type signature was.
14:30:45 <volvic> hope this questions makes sense to someone.
14:30:55 <volvic> i'm toying around with Snap and Heist, and I'm basically trying to implement a nested loop to match a nested data structure. to simplify, i have a list of lists of tuples and I would like to mark the view up using Heist.
14:31:06 <DukeDave> shachaf: I mainly asked because I wasn't sure whether to use a type synonym or a newtype..
14:31:13 <volvic> i know that a single loop, to iterate over the inner list of tuples, can be achieved using mapSplices (mapping over a splice that uses runChildrenWithText), but this does not work when the child nodes of the spliced template themselves should be mapped over
14:31:20 <DukeDave> shachaf: It's not a nested type, no
14:31:20 <volvic> or have I missed something?
14:31:43 <DukeDave> elliott: Noted :)
14:32:08 <volvic> accel: it worked for me, more or less exactly that easily
14:32:34 <heatsink> DukeDave, Syn a -> Int means (Foo a => Map Int a) -> Int, which is a rank-2 type
14:32:54 <volvic> but i cleaned out the 6.1x Haskell Platform i had installed previously (everything apart from the cabal binary)
14:33:06 <heatsink> because the dictionary constraint is on the left side of an arrow
14:33:32 <DukeDave> heatsink: Where did the -> come from?
14:34:00 <elliott> DukeDave: If you didn't have one, you wouldn't be getting that message.
14:34:15 <saati> hi, can i make 'reverse . take n . reverse' faster?
14:34:26 <elliott> saati: yes, use a different structure (such as Seq)
14:35:25 <DukeDave> elliott: Where "that message" is the "enable RankNTypes" message?
14:35:40 <elliott> DukeDave: Yep.
14:36:03 <DukeDave> elliott: Erm, well I'm not :O
14:36:08 <elliott> DukeDave: Paste yer code
14:36:11 <shachaf> DukeDave: You should probably -- yes.
14:37:02 <heatsink> DukeDave, I guessed that you are somtimes using 'Syn' as part of a bigger type.  I used (->) because it's a reasonable way to construct an example of a bigger type.
14:37:54 <acowley> I'm really using lenses everywhere now. I only wish the data-lens syntax lent itself to guesswork exploration a bit more.
14:38:34 <DukeDave> Code coming up ;)
14:40:01 <saati> elliott: thanks, it did make it a bit faster
14:40:12 <elliott> saati: :)
14:40:22 <hpaste> DukeDave pasted “RankNTypes required” at http://hpaste.org/52889
14:41:25 <elliott> DukeDave: are you sure the error is on that line
14:41:58 <DukeDave> elliott: I've double, double checked..
14:42:10 <acowley> you can't have contexts on type synonyms, can you?
14:42:12 <elliott> dunno then, ask shachaf :D
14:42:39 <DukeDave> Curiously I follow an identical pattern above, and that doesn't complain (assuming the type checker parsers the file from start to end)
14:43:56 <shachaf> DukeDave: Can you @paste something that I can compile?
14:43:59 <hpaste> DukeDave annotated “RankNTypes required” with “RankNTypes required (including similar working type synonym)” at http://hpaste.org/52889#a52890
14:44:08 <acowley> You usually want to put contexts on the functions that operate on the data. If you really need contexts on data types, then GADTs support it. Alternately, you can just make the dictionary an explicit field of your data type.
14:44:26 * elliott wonders if DukeDave might not really want M.Map Edge (Position, Position).
14:44:35 <shachaf> Is there any reason not to -- yes, what elliott said.
14:45:12 <elliott> shachaf: Well, maybe the users of DukeDave's library specify the ed values, which contain information other than Position, then extract the extra data after some fancy selection process is done to it.
14:45:19 <elliott> shachaf: Or maybe not.
14:45:20 <acowley> this is a variant of the typeclass anti-pattern luqui wrote about
14:45:35 <saati> @hoogle maxInt
14:45:35 <elliott> acowley: Well, it /does/ have additional use here, as above, but unless DukeDave is doing that then it falls under that.
14:45:35 <lambdabot> No results found
14:45:42 <elliott> DukeDave: Anyway, you should make Edge a real data-type.
14:45:43 <elliott> Not a synonym.
14:45:51 <elliott> Probably Vertex and Port too (newtypes).
14:45:52 <saati> why does this happen? where is maxInt?
14:46:00 <elliott> saati: Nowhere.
14:46:03 <elliott> > maxBound :: Int
14:46:04 <lambdabot>   9223372036854775807
14:46:16 <acowley> elliot: if he had a proper existential with constraint ed, there's nothing else he could do
14:46:19 <saati> that'll do thanks :)
14:46:26 <elliott> acowley: he doesn't
14:46:30 <elliott> he has
14:46:37 <elliott> foo :: (EdgeData ed) => ... M.Map Edge ed ...
14:47:30 <acowley> right, having the constrained polymorphism on a function would be reasonable
14:48:10 <shachaf> Still, that type class makes me suspicious.
14:48:30 <elliott> Me too.
14:48:35 <elliott> As do the type synonyms.
14:48:36 <shachaf> You can always do M.Map Edge (ed,(Pos,Pos))
14:48:46 <DukeDave> elliott: Yes, the users already have the map values, then they just make it an instance of EdgeData to expose the position..
14:48:55 <elliott> DukeDave: Alright. But make those synonyms real types already.
14:49:10 <DukeDave> elliott: Why do you think I should make Edge a real data-type??
14:49:14 <shachaf> Type synonyms are evil.
14:49:23 <elliott> DukeDave: Because there is no reason not to.
14:49:28 <shachaf> People usually use them just because they're more convenient.
14:49:28 <elliott> Type synonyms need to be justified, not the other way around.
14:49:37 <shachaf> elliott++ # agreeing with me
14:49:40 <elliott> A real data-type gives you more safety, more self-documentation (in the use of constructors etc.), ...
14:49:58 <DukeDave> elliott: I guess they do
14:50:10 <DukeDave> Does it make the compiler see them differently though?
14:50:38 <shachaf> Sure. The compiler will do type-checking.
14:50:40 <elliott> DukeDave: That's not a good enough question to answer properly.
14:50:42 <acowley> Yes. You will get type checking.
14:50:43 <shachaf> That's a good thing.
14:51:00 <elliott> DukeDave: Also you can add strictness annotations to the constructor fields, etc., if you want MOAR SPEED later.
14:51:20 <elliott> DukeDave: If you use a newtype, there'll be no boxing, so there's no overhead. Do that for the Vertex and Point types.
14:51:34 <elliott> Edge should probably look like:
14:51:37 <elliott> data Blah = Blah Vertex Port
14:51:40 <elliott> data Edge = Edge Blah Blah
14:51:42 <cirno_the_greate> elliott: ocaml?
14:51:46 <elliott> cirno_the_greate: ?
14:51:56 <DukeDave> elliott: Thanks
14:52:23 <cirno_the_greate> or haskell? Which language you write bot
14:52:31 <elliott> cirno_the_greate: I write bot?
14:52:36 <elliott> This is #haskell.
14:52:39 <cirno_the_greate> oooooops
14:52:44 <cirno_the_greate> pardon moi
14:52:52 <cirno_the_greate> thought it was #aichallenge window
14:53:03 <acowley> we're all AIs
14:53:34 <yitz> @vixen in which language are you written?
14:53:34 <lambdabot> They're not like us. They smell different, they look different, they act different.  The trouble is, you can't find one that's honest.
14:56:26 <kmc> i like how @vixen was switched out for @nixon because Nixon is *less* offensive?
14:56:45 <kmc> masturbation jokes vs. casual racism and political fraud on a massive scale
14:57:33 <DukeDave> elliott: So, the type synonyms are gone, but it still wants me to enable RankNTypes :|
14:58:18 <shachaf> That quote is about... Italians?
14:59:48 <rapeghost> someone from #bitcoin-otc told me this channel sucks
15:00:06 <ciaranm> sorry, haskell doesn't support sucking
15:00:08 <acowley> DukeDave: You really shouldn't be putting constraints on types. It's usually a sign of problems, and typically doesn't do what you want it to do.
15:00:14 <rapeghost> hmm
15:00:18 <rapeghost> fair enough
15:00:24 <acowley> @faq can haskell suck?
15:00:24 <lambdabot> The answer is: Yes! Haskell can do that.
15:00:25 <shachaf> copumpkin?
15:00:49 <ciaranm> i don't think copumpkin can suck either. but he can blow.
15:01:05 <mm_freak> we have quite a troll rate here recently
15:01:35 <mm_freak> one way to look at it is that haskell is gaining quite a popularity
15:01:39 <copumpkin> what?
15:01:40 <DukeDave> acowley: Well, I only wish to do it to compact type signatures
15:02:20 <DukeDave> That is, "to make my type signatures more compact" :)
15:02:20 <ciaranm> copumpkin: well blowing is just sucking in SexActs^op, isn't it?
15:02:30 <copumpkin> probably
15:03:30 <acowley> DukeDave: I understand that, but it's probably a misuse of constraints. Perhaps you want to accept values from a user as long as they are instances of some class. Then you should have appropriate constraints on your function types.
15:04:08 <acowley> DukeDave: As you build larger programs with a wider variety of constraints, this will certainly become a pain point, and is the impetus behind the constraint alias work.
15:04:37 <DukeDave> acowley: Ah, so it's a known 'issue' then
15:04:52 <DukeDave> I have, incidentally given up and returned to long, multi-line type signatures
15:04:55 <ciaranm> DukeDave: being able to construct, say, a tree with a single function in it is often handy, even if you can't search for it or add anything else
15:05:36 * DukeDave stares blankl
15:06:18 <acowley> DukeDave: luckily it's not *just* a known issue, it's also a code smell. You often find that when you want something like an existential with a constraint (i.e. something you can map a variety of types into), you should really just be working with the result of that mapping.
15:06:49 <ciaranm> DukeDave: if you think carefully, if you're doing a tree of Ordy things, you can do certain tree operations even if the tree doesn't contain Ordy things. you can create a single element tree, and you can see whether the tree is empty, for example.
15:07:47 <acowley> DukeDave: For instance, you might imagine a list of existentials where you have a Show constraint on the elements of the list. This is great, it's like heterogenous lists! But no, it's just silly: you should just "show" the values before putting them into a plain old [String].
15:08:29 <shachaf> acowley: But I want to "shows" the values sometimes!
15:09:21 <acowley> shachaf: map (show&&&shows) myVals
15:09:30 <shachaf> acowley: And showsprec!
15:09:37 <elliott> :D
15:09:43 <acowley> shachaf: I can keep adding &&&s, too :P
15:10:12 <ciaranm> :t (,,,,,,,,,,,,,,,,,,,,,,,,,)
15:10:13 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (a, b, c,
15:10:13 <lambdabot>  d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)
15:11:03 <acowley> I have a use of arr9 in some code I'm working on right now!
15:11:04 <ciaranm> yay for operators longer than most function names
15:11:31 <shachaf> @pl \a b c d e -> (((a,b),c),d,e)
15:11:32 <lambdabot> ((((,,) .) . (,)) .) . (,)
15:11:42 <shachaf> arr9? :-(
15:11:57 <acowley> shachaf: I had to define it myself :(
15:12:05 <acowley> shachaf: it was for parsing a large record from some XML
15:12:08 <DukeDave> acowley: Will mapping a 'selector' function first, instead of using a type-class, result in a  'copy' of the map though?
15:12:09 <ciaranm> shachaf: it's what pirates say to their children on their birthday
15:12:10 <shachaf> acowley: Maybe there's a lesson in that...
15:13:01 <acowley> shachaf: There were several lessons. My first approach to dealing with this data model was to make my record a monoid so that I could mix-in different fields as they were parsed
15:13:27 <acowley> shachaf: arr9 turned out to be better: less code and faster
15:13:46 <DukeDave> I.e, in the worse case, where the type-class exposes everything, you'll have to duplicate the Map entirely in memory, before passing it off.
15:14:09 <DukeDave> However if we just use a type-class to expose everything, it won't be copied..
15:14:12 <acowley> DukeDave: Yes. I think you should be putting your constraint on your function types.
15:15:39 <acowley> DukeDave: But if you find yourself wanting to mix different users' values of different types that are all members of the same type class, then you end up in the scenario where you might as well just do the projection up-front and not mince about with fancyness.
15:15:40 <DukeDave> acowley: But you object to the idea of having some kind of type synonym like "type MapFooableThings f :: Foo f => Map Int f"
15:18:55 <acowley> DukeDave: It's not my objection, I don't think it's allowed by the language standard.
15:19:30 <acowley> DukeDave: But I could be wrong about that!
15:20:58 <DukeDave> acowley: Okay, thanks for all you help..
15:21:43 <int80_h> I have a foo.has and a bar.O, how do I compile them into an executable? I'll need to use the --make flag.
15:21:48 <int80_h> I mean bar.o
15:21:59 <int80_h> er foo.hs and bar .o
15:22:21 <Sgeo|web> Does GHCi have a thing that will occasionally check for ^C no matter what?
15:22:59 <acowley> int80_h: you can just pass them both to ghc. --make is the default in relatively recent GHCs
15:23:38 <vixen> there's a typo in the tutorial...
15:23:47 <vixen> So if we wanted to get the age of our villain, we could do:  let villain = (28,"CHIRS") in fst villain
15:23:56 <vixen> chirs
15:23:57 <vixen> ?
15:24:50 <RaptorRarr> > let villain = (28, "CHIRS") in fst villain
15:24:52 <lambdabot>   28
15:25:11 <RaptorRarr> CHIRS is a perfectly good villain name.
15:25:19 <acowley> DukeDave: I'm looking at the report, and I think I'm right that there's just no room in the grammar for a constraint where you want it.
15:25:42 <acowley> Would you trust someone named CHIRS?
15:25:50 <RaptorRarr> No, I wouldn't.
15:26:07 <RaptorRarr> Especially since it would likely be an acronym, being capitalized like that.
15:26:23 <RaptorRarr> Who names their kids like that? People who turn their kids into villains! That's who!
15:26:35 <periodic> What if he got a name change?
15:26:51 <periodic> once he'd settled on a career path?
15:26:53 <RaptorRarr> It would indicate he might not want to be a villain anymore, which would be a good sign.
15:27:15 <periodic> Maybe *he* changed his name to CHIRS!
15:27:28 <acowley> So we should encourage CHIRS to take control of his life; turn things around!
15:27:41 <periodic> Good point.  A name doesn't make a man!
15:27:51 <acowley> He's not a villain, he's just misunderstood! All because of that stupid, stupid typo...
15:27:51 <periodic> What if we just aliased him?
15:27:57 <periodic> hero = villain?
15:28:05 <acowley> type synonyms really are dastardly
15:28:47 <periodic> or instance Show Villain where show = "I am a hero!"
15:29:15 <hpaste> int80_h pasted “problem with hiding packages” at http://hpaste.org/52893
15:29:36 <acowley> oh upper version constraints, you are merciless
15:29:49 <int80_h> go on
15:30:17 <int80_h> so what's going on here?
15:31:31 <BrianHV> why would my attempt to import an empty module in ghci cause a "module is not loaded" error?
15:31:35 <acowley> int80_h: use a PackageImports
15:32:40 <int80_h> acowley, where can I find out how to use PackageImports?
15:33:37 <acowley> int80_h: http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports
15:34:10 <acowley> Just stick {-# LANGUAGE PackageImports #-} in your problematic file, and qualify the disputed module with the package you want to use
15:34:51 <int80_h> cool
15:35:30 <int80_h> import "mtl" Control.Monad.Reader
15:35:40 <int80_h> like that? I found an hpaste on how to use it in ghci
15:36:21 <elliott> acowley: I'm not sure that's a good idea...
15:36:27 <elliott> shouldn't we be suggesting ghc-pkg hide or something first?
15:36:36 <BrianHV> this isn't me, but I'm having effectively the same problem. http://hpaste.org/50805
15:36:51 <int80_h> ghc-pkg hide will screw up my main module
15:37:25 <acowley> elliot: Yes, it's a band-aid fix. But I found it really helpful in the mtl-2 transition.
15:37:48 <elliott> acowley: fair enough
15:37:51 <acowley> A cabal file should be in the project's near future
15:38:09 <int80_h> I thought of using a cabal file, but this module is really small
15:38:10 <kmc> buh package imports :/
15:38:30 <int80_h> is it just better to use a cabal file for this module?
15:38:50 <acowley> int80_h: is that module the entire project you're working on?
15:39:23 <int80_h> acowley: no. SO far I only have two, soon to be three modules
15:39:45 <elliott> int80_h: you realise that cabal libraries contain multiple modules?
15:40:46 <kmc> it's always better to use cabal file
15:40:50 <kmc> cabal file is best file
15:41:03 <kmc> package imports are not intended for use outside ghc core libraries
15:41:06 <elliott> all my files are cabal files
15:41:09 <int80_h> elliot: I thought I could make a cabal file just for this module and use the Build-Depends keyword to sort this problem out. I was hoping for something simpler.
15:41:14 <kmc> all my shootings be drive-bys
15:41:22 <elliott> int80_h: you want a cabal file for your library/program
15:41:26 <elliott> or multiple libraries/programs
15:41:29 <elliott> not one per module
15:41:52 <kmc> module being small is not really an excuse not to use cabal
15:41:59 <elliott> yeah
15:41:59 <acowley> package imports is handy when you're loading things into GHCi
15:42:06 <int80_h> elliot: Well I'm not sure how to sort this problem in one cabal file. One module will want the package that conflicts with the other.
15:42:09 <acowley> all modules should be small!
15:42:17 <elliott> int80_h: one cabal file can support multiple libraries
15:42:22 <elliott> int80_h: otoh, it sounds like what you have is a Problem
15:42:30 <elliott> and you should fix the Problem, not the symptoms :P
15:42:34 <kmc> if two modules in the same library need to import modules of the same name from different packages...
15:42:39 <kmc> then you do need PackageImports afaik
15:42:47 <kmc> and yes, you have a Problem
15:43:07 <kmc> you can fix it with more packages which just re-exports those modules under distinct names
15:43:22 <elliott> or just finding better dependencies :P
15:43:40 <elliott> wait
15:43:43 <elliott> "Data.Aeson is conflicting with another package"
15:43:46 <elliott> int80_h: that's definitely a problem
15:43:50 <acowley> it does sound like a Problem
15:43:50 <int80_h> well, I have to use aeson, and yesod uses a conflicting package that has a Data.Aeson
15:43:52 <elliott> install aeon-native or aeson, not both
15:43:58 <elliott> int80_h: yes, but those are the same api
15:44:01 <elliott> just use the one yesod depends on
15:44:02 <kmc> oh, *this problem*
15:44:05 <kmc> sigh
15:44:11 <elliott> it's not a _different_ aeson, it's just a slightly different implementation
15:44:15 <elliott> the api is the exact same
15:44:18 <int80_h> oh *(^^*^*^ really?!
15:44:19 <elliott> so you should just only have one installed
15:44:24 <int80_h> grr
15:44:27 <int80_h> thanks :)
15:44:30 <elliott> :)
15:44:39 <elliott> int80_h: have fun with ghc-pkg unregister :P
15:44:44 <kmc> some day someone will invent a language free of dependency hell
15:44:49 <kmc> by inventing a language nobody uses
15:44:52 <int80_h> cab delete ha snap easy
15:44:57 <elliott> kmc: just don't offer any import mechanisms at all
15:45:07 <elliott> kmc: all libraries are done by "static source linking" (ctrl+c/ctrl+v)
15:45:18 <kmc> all modules are baked into the interpreter and available implicitly in the global namespace
15:45:30 <kmc> the approach taken by a certain popular hypertext processor
15:45:45 <elliott> kmc: then they ruined it by inventing PEAR
15:45:51 <elliott> (thankfully, nobody knows how to use PEAR)
15:58:40 <prokii> Any good examples for reading/writing from/to RS232?
15:59:52 <prokii> I am playing with the SerialPort which seems nice, but I am not sure how to handle blocking reads and write requests.
16:03:04 <kmc> handle them in what sense?
16:03:19 <kmc> i've used the serialport package
16:03:25 <kamaji> weird
16:03:35 <kamaji> why can't I do "let f = max" and then "f 1 2" ?
16:03:41 <kmc> > let f = max in f 1 2
16:03:42 <lambdabot>   2
16:03:50 <kmc> prokii, i have some code here that uses it http://hackage.haskell.org/packages/archive/crystalfontz/0.1/doc/html/src/Hardware-LCD-CFA635.html
16:04:00 <kmc> it's not the prettiest code I've ever written but it does work :)
16:04:42 <kmc> prokii, the general approach to handling concurrent IO in GHC Haskell is to create multiple threads
16:04:52 <Cale> kamaji: I'd guess the monomorphism restriction.
16:04:55 <kmc> there are various properties of the language and implementation which make this work better than in most languages and implementations
16:05:05 <kamaji> Cale: what's that?
16:05:16 <kamaji> well, google first...
16:05:45 <Cale> kamaji: Bindings which don't explicitly take function parameters and which don't have explicit type signatures are required to be monomorphic by Haskell 98
16:06:23 <kamaji> huh. fair enough. I was just reading this: http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:06:31 <kamaji> can't say I quite understand why but i'll just bind parameters, hehe
16:06:36 <kmc> the restriction is stupid
16:06:38 <Cale> It's really dumb
16:06:47 <kmc> it's supposed to make the performance of haskell code less surprising to beginners
16:06:50 <kmc> but that's such a lost cause anyway
16:06:58 <kamaji> hahahaha, i'll say
16:07:07 <Cale> and it just ends up confusing people
16:07:12 <kamaji> was that a pointed barb at me~~
16:08:18 <Cale> There was a time back before forM was in Control.Monad where I wasted about an hour trying to work out why some computation I'd written in ST wouldn't work
16:08:35 <Cale> and it turned out to be because I'd written  forM = flip mapM
16:09:32 <kamaji> :<
16:09:34 <Cale> Which looks fine, except that it silently got a type with ST () in it
16:09:51 <elliott> > id runST
16:09:52 <lambdabot>   Overlapping instances for GHC.Show.Show
16:09:52 <lambdabot>                              ((fora...
16:09:54 <Cale> and then runST choked on it
16:09:57 <elliott> shachaf: Bah, you do the thing.
16:10:36 <Cale> (It was not so obvious because my computation was kinda long and forM was just used in the middle of it somewhere)
16:10:48 <kmc> actually, I don't think we should give up on performance reasoning by beginners — but I think the answer lies in tools and education, not language features
16:11:11 <kmc> we need more really good articles about graph reduction, for example
16:11:12 <hatomic> hello. I was hoping someone could help me let GHC find some libs. Specifically, I am following this page http://www.haskell.org/haskellwiki/WxHaskell/Building_with_styledTextCtrl_support - the last command on a windows shell gives me "target ` [ a bunch of wx-config --lib here ] ' is not a module or a source file
16:12:42 <Cale> hatomic: I'm amazed that even works on the windows shell to any degree
16:13:24 <Cale> hatomic: It must be that bash expands the words in the result of the command there to separate args to ghc, while the windows shell treats the entire output as one arg
16:13:25 <shachaf> elliott: > id runST (return 5)
16:13:29 <shachaf> > id runST (return 5)
16:13:29 <lambdabot>   Couldn't match expected type `m t'
16:13:30 <lambdabot>         against inferred type `forall s....
16:13:31 <shachaf> > (id runST) (return 5)
16:13:32 <lambdabot>   5
16:13:34 <elliott> Yes. Everyone clap.
16:13:49 <elliott> Cale: No, it's just that Windows doesn't do backticks.
16:13:49 * RaptorRarr puts his claws together.
16:13:54 <elliott> AFAIK.
16:15:12 <Cale> elliott: You'll be happy to know that newer GHCs don't accept either
16:15:27 <Cale> It was an experimental hack which was around for a short time
16:16:05 * ddarius wonders about RaptorRarr's new nick.
16:16:13 <elliott> Cale: runST still has special hooks in the type-checker, though, doesn't it?
16:16:22 <Cale> I don't think so...
16:16:26 <Cale> Does it?
16:16:37 <hatomic> Cale: thanks
16:17:09 <elliott> Cale: Well, someone told me it was.
16:17:14 <elliott> I forget who.
16:17:32 <Cale> I would be quite surprised
16:18:01 <Cale> Even the hack which caused (id runST) to work there wasn't specific to runST
16:19:39 <elliott> Cale: Well, it surprised me too. But they sounded very knowledgable and authoritative.
16:19:42 <dylukes> Cale: What special hooks in the type checker are there?
16:19:50 <elliott> Probably I could grep the logs if I cared enough.
16:20:25 <Cale> dylukes: I can't think of any special exceptions which work for specific values.
16:20:49 <dylukes> I mean, are there any in general?
16:20:55 <dylukes> special exceptions.
16:21:09 <Cale> If there are, then I don't know about them
16:21:23 <kmc> i thought it was ($) that had the hax
16:21:31 <kmc> or maybe "all functions of the same type as ($)"
16:21:43 <kmc> > runST $ return 5
16:21:44 <lambdabot>   5
16:21:47 <dylukes> :t ($)
16:21:47 <kmc> > runST `id` return 5
16:21:47 <lambdabot> forall a b. (a -> b) -> a -> b
16:21:48 <lambdabot>   Couldn't match expected type `m t'
16:21:48 <lambdabot>         against inferred type `forall s....
16:21:53 <dylukes> How would $ have had :\
16:21:55 <dylukes> hax*
16:21:59 <elliott> kmc: nice
16:22:05 <kmc> > let f :: (a -> b) -> a -> b; f = id in runST `f` return 5
16:22:06 <lambdabot>   5
16:22:09 <shachaf> elliott: I don't think runST ever had special hooks in the type checker.
16:22:10 <elliott> Gotta love rank-n types.
16:22:12 <shachaf> Nor $.
16:22:25 <shachaf> Or maybe it did once, but I don't think that explains the current behavior.
16:22:30 <kmc> so that's not indicative of hax, but it definitely can't specialize id to a polytype
16:22:30 <dylukes> I goes it's somewhat odd that TWO of the arguments go to the left ...
16:22:32 <dylukes> like, why its not
16:22:38 <dylukes> a `$` b -> a -> b
16:22:44 <dylukes> but... there are plenty of functions like that
16:23:08 <shachaf> > let foo :: (a -> b) -> a -> b; foo = id in runST `foo` return 5
16:23:09 <lambdabot>   5
16:23:48 <Cale> dylukes: what does a `$` b mean?
16:24:32 <dylukes> ah...
16:24:40 <shachaf> Wait, kmc said exactly that above.
16:24:52 <mike-burns> Timing!
16:31:26 <shirt> m is a MonadZero and i have (f :: m a), i'd like to be able to do something like (f >> g) where the result is that of f if f is not mzero, otherwise the result is that of g
16:32:00 <rwbarton> It sounds like you want MonadPlus
16:32:14 <shirt> rwbarton: oops, that's what i meant!
16:32:18 <shirt> rwbarton: m is MonadPlus
16:32:40 <dylukes> That's not what MonadPlus will do though.
16:32:54 <dylukes> You want MonadOr
16:32:59 <rwbarton> well, depends on the monad
16:33:16 <dylukes> morelse satisfies morelse mzero b = b
16:33:17 <dylukes> morelse a mzero = a
16:33:19 <dylukes> morelse mzero b = b
16:33:19 <dylukes> morelse a mzero = a *
16:33:23 <shirt> dylukes: the thing is, i have no choice. i'm already using Parser from aeson package, and it is MonadPlus
16:33:27 <rwbarton> Or I guess I'm not sure what you mean by "something like (f >> g)"
16:33:39 <rwbarton> I suggest you back up and say what you really want to do
16:33:41 <dylukes> shirt: add StandaloneDeriving to your LANGUAGE pragma.
16:33:50 <dylukes> and then `deriving instance MonadOr Parser`
16:33:52 <cheater> to me it sounds like Maybe.
16:33:58 <dylukes> if it already has Monoid and MonadPlus, you're good.
16:34:20 <dylukes> part of the point of type classes is also that they're open, so you can instance it even if its in another library :P
16:34:32 <shirt> i'm using aeson package, it has a Parser monad. i have (f :: Parser a). i'd like to try parsing using f, and if that fails then try using (g :: Parser a)
16:34:42 <dylukes> shirt: Yes, you want MonadOr.
16:35:01 <elliott> dylukes: What?
16:35:02 <rwbarton> er
16:35:04 <elliott> Where is MonadOr?
16:35:11 <rwbarton> you need alternation built into your Parser type
16:35:12 <elliott> shirt: You want Alternative, probably.
16:35:28 <kmc> MonadPlus or Alternative
16:35:28 <shirt> elliott: Parser is also an instance of Alternative
16:35:33 <dylukes> elliott: It's part of a proposal... MonadOr == Alternative
16:35:34 <dylukes> I believe.
16:35:36 <rata_> hi
16:35:41 <elliott> shirt: Then use (<|>)
16:35:50 <dylukes> shirt: yeah, then just use choice or it's binary op version (<|>)
16:36:10 <rwbarton> (... or mplus)
16:36:19 <shirt> elliott, dylukes: thanks i'll try
16:36:20 <dylukes> plus does not have that behavior.
16:36:29 <dylukes> he wants
16:36:32 <dylukes> f mzero b = b
16:36:50 <dylukes> oh, I guess that would be the same for mplus.
16:36:51 <dylukes> meh.
16:36:51 <dylukes> :P
16:37:20 <yitz> shirt: in Maybe you would do f `mplus` g
16:37:58 <yitz> oh. my screen was scrolled up. sorry.
16:39:09 <dylukes> The difference is MonadPlus satisfies left distribution while Alternative (MonadOr) has left catch.
16:39:54 <AlexMurphy> Hi everyone. Can you pointme to a resource (URL, PDF, book) that teaches how to read type signature slike this one ->      (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:39:55 <AlexMurphy>    Thanks!
16:40:07 <dylukes> AlexMurphy: you'd read that as
16:40:14 <dylukes> well, >>= is called "bind"
16:41:07 <dylukes> Bind is a function with a type, where for all types a and b, (m a) -> (a -> m b) evaluated to  (m b)
16:41:18 <dylukes> or m a evaluates to (a -> m b) -> m b ...
16:41:36 <dylukes> (>>=) (m a) -> (a -> m b) evaluates to  (m b)
16:41:37 <dylukes> *
16:41:48 <ion> …
16:42:01 <dylukes> m is some data type with kind * -> *
16:42:10 <dylukes> meaning it takes a single other type as a parameter.
16:42:11 <ion> You’re mixing values and types.
16:42:28 <dylukes> evaluates to something of type *
16:42:31 <dylukes> type m b *
16:42:33 <dylukes> gah
16:42:36 <AlexMurphy> The non caps letters are values????
16:42:44 <dylukes> the non caps are types
16:42:55 <dylukes> as you said yourself, its a TYPE signature.
16:43:10 <dylukes> a and b have kind *, m has kind * -> *
16:43:15 <ion> @type (>>=) `asAppliedTo` (undefined :: [Integer])  -- ‘m’ is [] and ‘a’ is Integer
16:43:15 <dylukes> because m can be applied to another type.
16:43:16 <lambdabot> forall b. [Integer] -> (Integer -> [b]) -> [b]
16:43:29 <AlexMurphy> Hmmm..... let me wrap my head around what you said for a bit and try something .
16:43:32 <ion> > [1,2,3] >>= \num -> [num]
16:43:34 <lambdabot>   [1,2,3]
16:43:34 <dylukes> [a] = m a
16:43:44 <ion> > [1,2,3] >>= \num -> []
16:43:45 <lambdabot>   []
16:43:51 <ion> > [1,2,3] >>= \num -> [num, num*10]
16:43:52 <lambdabot>   [1,10,2,20,3,30]
16:43:59 <dylukes> With something like 'm a', m is a data type like... Maybe a
16:44:05 <dylukes> notice the type Maybe has a type parameter
16:44:05 <ion> @source [] (>>=)
16:44:06 <lambdabot> [] (>>=) not available
16:44:11 <ion> @src [] (>>=)
16:44:11 <lambdabot> xs >>= f     = concatMap f xs
16:44:23 <dylukes> so it's written as having kind * -> *
16:44:45 <dylukes> all types (for most purposes) have kind *
16:44:55 <dylukes> so 'm a' is just a type where m :: * -> *, and a :: *, and m is applied to a
16:45:16 <dylukes> :t asAppliedTo
16:45:17 <lambdabot> forall t b. (t -> b) -> t -> t -> b
16:45:32 <dylukes> @src asAppliedTo
16:45:32 <lambdabot> Source not found.
16:45:36 <dylukes> ...Caleskell?
16:45:38 <AlexMurphy> Now it makes more sense
16:45:51 <dylukes> It's like in certain other languages where you have Array<Int>
16:46:11 <AlexMurphy> Yes...that's it...
16:46:13 <dylukes> It's like saying, for any type that takes one parameter (we'll call that m), and one type we'll use as a parameter (which we'll call a)
16:46:17 <dylukes> just, there's no < >
16:46:42 <dylukes> you use spaces. No < > or ( ) or what not
16:46:52 <dylukes> Actually, the haskell Array type is (Array i e)
16:46:56 <dylukes> Array :: * -> * -> *
16:47:04 <dylukes> Two parameters.
16:47:17 <ion> f `asAppliedTo` x = f `asTypeIn` ($x)
16:47:21 <AlexMurphy> OK....thanks a lot dylukes.
16:47:21 <ion> @src asTypeIn
16:47:21 <lambdabot> a `asTypeIn` f = a where _ = f a
16:47:22 <lambdabot> infixl 0 `asTypeIn`
16:48:11 <AlexMurphy> I'm just starting and haven't gotten the hang of this. :D
16:48:14 <dylukes> AlexMurphy: Just remember, data types are to types as functions are to values (kinda).
16:48:36 <elliott> dylukes: No, type functions are.
16:48:45 <dylukes> elliott: I said (kinda) :P...
16:48:58 <dylukes> Just trying to make the kind signature thing make sense.
16:49:12 <AlexMurphy> I see where you are going. :D
16:49:18 <dylukes> But yes, elliot is right.
16:49:29 <dylukes> You can actually have functions on types using TypeFamilies...
16:49:51 <dylukes> For natural numbers implemented as types instead of values... and so forth. That's beyond the scope here though, so don't worry about it.
16:50:02 <dylukes> It'll just confuse you more.
16:50:07 <AlexMurphy> Uff....
16:50:25 <dylukes> It's an extension. It's not something you're likely to have to use for quite a while :).
16:50:51 <AlexMurphy> I'll just read the entire chat a second time now....and really, thanks a lot.
16:51:02 * elliott thinks this is one of those trainwreck explanations.
16:51:16 <dylukes> elliott: yeah... ufh. You're not helping though.
16:51:21 <elliott> :D
16:51:25 <dylukes> Yeah sure, why don't we just introduce type families now.
16:51:30 <dylukes> data Z
16:51:32 <dylukes> data S n
16:51:35 <AlexMurphy> O.o
16:51:35 <dylukes> type family x :+ y
16:51:39 <dylukes> type instance Z :+ y = y
16:51:40 <acowley> longshot: has anyone here used graphics-formats-collada?
16:51:40 <elliott> AlexMurphy: Hey dude: CONSTRAINT KINDS.
16:51:46 <elliott> AlexMurphy: They add a new kind for constraints.
16:51:49 <dylukes> type instance S x :+ y = S (x : + y)
16:51:53 <elliott> You can use type families to have constraint families indexed by types.
16:51:54 <elliott> It's great.
16:51:59 <dylukes> Stop elliott ...
16:52:03 <rwbarton> heh
16:52:04 <elliott> It lets you make Set a Monad (isn't normally because of Ord constraints), given a new Monad class.
16:52:18 <elliott> AlexMurphy: Now please sign this document, it's a petition to get Functor a superclass of Monad, and to split Num up into algebraic typeclasses.
16:52:24 * elliott 's work here is done.
16:52:33 <dylukes> AlexMurphy: Ignore him, by the time you're proficient enough, hopefully GHC 7.4 will be out with its awesome bag of new tirkcs.
16:52:35 <mike-burns> Hasn't everyone signed that petition?
16:52:45 <dylukes> Where is it?
16:52:45 <kmc> wow shachaf, one of your many puns made it to HWN
16:52:45 <AlexMurphy> don't worry... I'll just save what elliott is writing for later....
16:52:45 <kmc> congrats
16:52:45 <dylukes> I need to sign it again, just in case I forgot before.
16:52:52 <dylukes> kmc: ?
16:53:19 <kmc> by the way, how do i get my uploads featured in HWN?
16:53:45 <copumpkin> why can't a newtype GADT refine its indices? is it because of the secret invisible equality proof that comes with it not being sufficiently one-membered?
16:54:06 <elliott> AlexMurphy: Exercise: Answer copumpkin's question.
16:54:10 <AlexMurphy> dylukes: ok....I'll just stick to the language and away form the magic trick du jour!
16:54:14 <dylukes> #haskell is now in maximum overtroll.
16:54:19 <mike-burns> Haha elliott .
16:54:27 <copumpkin> kmc: I'd email daniel santa cruz
16:54:39 <elliott> kmc: I bet it's based on the announce list?
16:54:42 <kmc> i guess that works ;P
16:54:50 <dylukes> AlexMurphy: Don't do it. This is one of those "stay up all night but still never figure it out, but then come back a few years later and do it in minutes" type exercises...
16:54:53 <elliott> Or wherever people post that stuff :P
16:54:58 <copumpkin> he also checks the @remembers
16:55:11 <copumpkin> @remember heydaniel kmc wants his uploads featured on HWN
16:55:12 <lambdabot> I will never forget.
16:55:12 <AlexMurphy> elliot: how much time do I have? A month or two???
16:55:57 <elliott> AlexMurphy: Mm... ten seconds. Your computer will self destruct in eleven.
16:56:01 <AlexMurphy> elliott: how much time do I have? A month or two???
16:56:06 <acowley> copumpkin: you mean a newtype of a GADT that is less polymorphic?
16:56:07 <dylukes> AlexMurphy: You're already out of time.
16:56:12 <AlexMurphy> **bum**
16:56:13 <elliott> Nice knowing you, AlexMurphy.
16:56:21 <elliott> Try F# next time.
16:56:31 <copumpkin> acowley: newtype Moo a where Moo :: Int -> Moo Int
16:56:39 <AlexMurphy> Nice knowing you both.... dylukes and elliott
16:56:52 <acowley> I didn't even know you could do that!
16:56:58 <copumpkin> it complains if you do
16:57:00 <copumpkin> :P
16:57:01 <acowley> oh
16:57:09 <copumpkin> that's represented secretly as newtype Moo a where Moo :: (a ~ Int) => Int -> Moo a
16:57:10 <acowley> what does it complain about?
16:57:12 <kmc> copumpkin, hax
16:57:17 <copumpkin> but the ~ has no runtime representation
16:57:19 <copumpkin> so I'm not sure why
16:57:21 <acowley> oh, well, that makes sense
16:57:35 <kmc> yeah I'm sure I'm missing out on users by not posting to the list
16:57:37 <acowley> it could just be the existing constraint mechanism
16:57:41 <copumpkin>     A newtype constructor must have a return type of form T a1 ... an
16:57:41 <kmc> but i can't keep up with all the haskell communities online
16:57:45 <kmc> gotta pick a few
16:58:44 <acowley> actually, how are ~ managed at type check time?
16:58:49 <acowley> s/managed/represented
16:59:36 <kmc> are you asking about GHC implementation details, or about the theory?
17:00:10 <acowley> GHC, but it if there's insight into representation choices from the theory then that could work too
17:01:18 <acowley> what copumpkin is trying to do seems like it should be possible
17:01:49 <mike-burns> Needs more Zombocom.
17:02:20 <copumpkin> I agree
17:02:20 <rwbarton> what if it was newtype Moo a where Moo :: b -> Moo Int
17:02:50 <copumpkin> then you'd have an existential newtype and wouldn't be able to do much with it
17:03:05 <rwbarton> well I could `seq` it
17:05:05 <ddarius> copumpkin: Did you read the paper just before OutsideIn(X) or that paper?
17:05:25 <copumpkin> nope
17:05:25 <copumpkin> it tells me why I'm stupid for wanting that? :)
17:05:51 <ddarius> Possibly.
17:05:57 <acowley> It might say why it would be difficult to check
17:06:20 <rwbarton> I don't think checking is the problem...
17:06:23 <ddarius> There is an "interesting" interaction between newtype deriving and GADTs that is related to how GHC represents newtypes now.
17:07:13 <rwbarton> a newtype is expected to share the runtime representation of another type, but what type is that for Moo Bool in either my example or copumpkin's example
17:07:34 <acowley> rwbarton: it's the representation at type check time that I'm worried about
17:07:53 <rwbarton> for typechecking purposes can't you just s/newtype/data/g?
17:07:57 <copumpkin> rwbarton: it's empty?
17:08:31 <acowley> rwbarton: that's the question the paper might answer
17:08:55 <kfish> #define newtype data
17:08:57 <rwbarton> copumpkin, so is the representation also empty?
17:09:05 <copumpkin> newsham: it shouldn't matter, because you can't touch it?
17:10:07 <rwbarton> (am I newsham?)
17:10:09 <shachaf> kmc: ?
17:10:17 <copumpkin> lolwtf
17:10:21 <copumpkin> how did I type newsham
17:10:22 <shachaf> Oh.
17:10:32 <rwbarton> ok :)
17:10:47 * copumpkin checks himself into the mental ward
17:10:59 <rwbarton> I'm just thinking about this aloud, but what if I write   f :: Moo a -> String; f x = x `seq` "hello"
17:11:16 <tensorpudding> you should try it
17:11:38 <copumpkin> rwbarton: it could pass something isomorphic to () around for it
17:11:57 <rwbarton> yes, maybe
17:12:22 <tensorpudding> i don't see how you create a value of type Moo a though
17:12:40 <rwbarton> tensorpudding: I can't try it, because GHC rejects copumpkin's definition of Moo that I am talking about
17:12:56 <tensorpudding> i suppose you'd need that one GHC extension?
17:13:15 <tensorpudding> the one relating to existentials
17:14:24 <rwbarton> anyways, I'm certainly not claiming I can prove that there are no sensible semantics for this newtype definition, just saying from thinking about this sort of thing, it makes sense to me that someone decided to disallow them
17:15:53 <acowley> haven't we gone a bit far afield here, though? The actual error message is just one about the grammar of newtypes.
17:16:33 <hpaste> dgpratt pasted “valid monad?” at http://hpaste.org/52895
17:16:41 <dgpratt> aknowledging that it is utterly silly and useless, is that a proper Monad?
17:17:14 <shachaf> dgpratt: I don't see why not.
17:17:26 <Cale> dgpratt: Well, it "satisfies" the laws, in a way. I'd be more comfortable with  data Trivial a = Trivial
17:17:26 <acowley> I think this all comes down to newtype representation in the type checker.
17:17:38 <Cale> with return x = Trivial, and Trivial >>= f = Trivial
17:17:39 <shachaf> Cale: Sure, that's the second-best Monad.
17:18:05 <dgpratt> Cale: I was just wondering if there was anything that could be even more 'trivial'
17:18:08 <rwbarton> acowley: surely you should design the grammar of newtypes to only allow the things you actually know how to represent!
17:18:34 <acowley> rwbarton: yes, but it can also be more conservative for the sake of implementors
17:18:55 <Cale> dgpratt: But yeah, the monad laws are universal properties, so a type with no values will automatically satisfy them.
17:19:28 <newsham> eek!  what did I do now?
17:19:31 <Cale> (or only one value, since the laws are equational, and there's only one possible outcome)
17:19:40 <dgpratt> Cale:  interesting
17:23:13 <dgpratt> hey, wait a sec...
17:23:53 <dgpratt> has anyone done or seen an equivalent Monad definition?
17:24:32 <dgpratt> otherwise, I'm thinking I may have invented a novel Monad!
17:26:06 <dgpratt> you guys don't seem very excited
17:26:41 <copumpkin> oh, I'm too busy throwing a party
17:26:53 <copumpkin> needed to run down to the liquor shop to get a bottle of champagne
17:27:04 <dgpratt> copumpkin: in my honor, I presume?
17:27:06 <copumpkin> yeah
17:27:15 <dgpratt> copumpkin: awesome
17:32:18 <ddarius> dgpratt: This monad has been brought up before.
17:32:30 <dgpratt> ddarius: Nooooooooo!
17:33:01 <dgpratt> ddarius: I just want you to know that you've just ruined my day
17:33:11 <ddarius> dgpratt: It's what I'm best at.
17:35:57 * hackagebot HROOT 0.6.8 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.8 (IanWooKim)
17:38:58 <rata_> what happened to data.array.diff?
17:40:25 <dgpratt> ddarius: you also ruined copumpkin's evening too, I'm sure; I hope you feel good about yourself
17:54:06 <blasedef> hello haskell peeps
17:54:18 <blasedef> anyone in here have experience with OCR?
17:54:21 <RaptorRarr> Wait, I'm a peep?
17:54:30 * RaptorRarr tastes himself.
17:54:34 <RaptorRarr> Needs more sugar.
17:57:03 <augur> so if my interpreter implements type classes, when i type check an expression, it's going to need to specialize functions/constants to the type class in question, right
17:57:51 <juhp> bit early in most parts but started #VirtuaHac
17:57:54 <augur> but that means that once i type check, the expression will have to be tagged with the specific type/value in question, but that will only be possible once type checking resolves the types right
17:58:45 <augur> so should i do type substitution into the expression after i type check?
18:04:16 <Saizan> you want to convert your expressions to more explicitly annotated ones as a result of typechecking
18:04:40 <jmcarthur> i just realized how strange it is that OverloadedStrings allows me to use string literals to pattern match on byte strings
18:04:50 <jmcarthur> *bytestrings
18:05:52 <jmcarthur> quite right, shapr!
18:09:55 <jeffcutsinger> http://www.reddit.com/r/Christianity/comments/lio26/i_wish_to_read_study_the_entire_bible_cover_to/c2t5ude
18:10:02 <jeffcutsinger> Oops
18:10:08 <jeffcutsinger> Wrong channel.
18:11:36 <augur> Saizan: hmm. so hows this: everything has a metavar for is type, and the checking process, once it resolves, goes back and substitutes in?
18:12:47 <augur> Saizan: so like   (f :: ?t) (x :: ?t')   =>   ?t = ?t' -> ?t''  =>  (f :: ?t' -> ?t'') (x :: ?t')
18:12:59 <augur> presumably ?t' and ?t'' would be resolved as well
18:13:08 <mm_freak> jmcarthur: what's strange about that?
18:13:11 <thoughtpolice> @seen edwardk
18:13:11 <preflex>  edwardk was last seen on #haskell 22 hours, 55 minutes and 50 seconds ago, saying: and preordered classes are just thin categories
18:13:11 <lambdabot> Unknown command, try @list
18:13:14 <Saizan> something like that
18:13:34 <Saizan> the end product is usually something resembling a church-style lambda calculus
18:13:45 <augur> Saizan: ??
18:14:17 <Saizan> i.e. where lambdas have a type annotation for their arguments, and you have explicit type abstraction and instantiation
18:14:55 <augur> not entirely sure i follow the second half there
18:15:38 <mm_freak> jmcarthur: note that you need an Eq instance for pattern-matching with overloaded strings
18:16:36 <Saizan> the second part is like in Agda where polymorphic functions are just ones with arguments in Set n, but keeping everything explicit
18:18:39 <augur> Saizan: oh i see
18:18:51 <augur> hmm
18:26:52 <lambdanaut> I've got a datatype    Data Foo = Foo {getBar :: Int; getBlag :: Bool; getBlug}    Can I get a bunch of functions like putBar  putBlag  and putBlug without explicitely declaring them?
18:27:20 <lambdanaut> functions that would deconstruct a Foo and insert a new value into those positions
18:27:31 <shachaf> lambdanaut: Yes, there are some libraries that will auto-generate those with TH.
18:27:34 <shachaf> @hackage data-lens
18:27:34 <lambdabot> http://hackage.haskell.org/package/data-lens
18:27:52 <shachaf> Lens libraries also give you composable (getter,setter) pairs.
18:29:00 <lambdanaut> thank you!
18:29:41 <shachaf> @hackage data-lens-template
18:29:42 <lambdabot> http://hackage.haskell.org/package/data-lens-template
18:33:52 <BadLadCrud> Anyone pretty familiar with the "Write Yourself a Scheme in 48 Hours" wikibook? I'm looking for opinions on implementing numeric type coercion
18:34:26 <accel_> it's the best book I have ever read
18:34:31 <accel_> on implementing scheme in haskell in 48 hours
18:34:47 <shachaf> BadLadCrud: I don't know if anyone who's familiar with it is in here, but you could ask your question and see if anyone has ideas.
18:36:57 <jmcarthur> mm_freak: the weird thing is that i thought OverloadedStrings just applied fromString to string literals
18:37:35 <shachaf> jmcarthur: Doesn't it?
18:38:04 <jmcarthur> mm_freak: but apparently it either special cases bytestrings or evaluates them at compile time (and if the latter, i wonder what happens if you make an instance for functions or use unsafePerformIO or something)
18:38:37 <rata_> does anyone know what happened to data.array.diff?
18:38:58 <jmcarthur> rata_: DiffArrays were always slow and were eventually removed
18:39:06 <shachaf> jmcarthur: Does the same thing happen if you call fromString yourself without OverloadedStrings?
18:39:06 <jmcarthur> rata_: there is a package around somewhere, maybe not on hackage
18:39:20 <jmcarthur> shachaf: i don't think that would be legal in a pattern...
18:39:35 <shachaf> Pattern?
18:39:46 <shachaf> Ah, I would've thought that would have just translated to Eq.
18:40:03 <jmcarthur> shachaf: "<jmcarthur> i just realized how strange it is that OverloadedStrings allows me to use string literals to pattern match on byte strings"
18:40:21 <shachaf> Oh, I missed that.
18:40:36 <djahandarie> Wait, it lets you do that?
18:40:39 <djahandarie> That is really strange..
18:40:40 <jmcarthur> yes
18:40:42 <djahandarie> Haha
18:40:44 <shachaf> djahandarie: Sure, just like Num does.
18:40:45 <djahandarie> Never really noticed
18:40:57 <shachaf> I wonder what will happen with the Eq superclass constraint taken away from Num.
18:41:05 <jmcarthur> i guess it never occurred to me how strange it was for Num, either
18:41:11 <djahandarie> Same
18:41:24 <jmcarthur> i really do wonder what happens if you use unsafePerformIO in fromInteger or fromString
18:42:46 <rata_> jmcarthur: oh ok... thanks
18:43:12 <jmcarthur> it is at least less magical now that i realize it requires Eq
18:43:17 <jmcarthur> but still
18:43:29 <copumpkin> jix_: did you ever finish that splay tree in haskell, by the way?
18:44:18 <shachaf> jmcarthur: Which part is the surprising part, in that case? That it evaluates the code at compile-time?
18:44:38 <Saizan> but it doesn't, does it?
18:44:46 <jmcarthur> maybe it doesn't
18:44:54 <BadLadCrud> For numeric type coercion in "Write Yourself a Scheme...", I know I can write primitives that consume algebraic datatypes to accomodate it, but the code ends up with a lot of repeated crap. There's a better way, right?
18:44:55 <shachaf> Oh, there's a RULES declaration for it.
18:44:56 <jmcarthur> but if not, when at runtime does it?
18:45:04 <shachaf> {-# RULES "ByteString pack/packAddress" forall s . pack (unpackCString# s) = inlinePerformIO (B.unsafePackAddress s) #-}
18:45:05 <jmcarthur> RULES?
18:45:16 <jmcarthur> err
18:45:21 <shachaf> Presumably that's what happens with string literals.
18:45:49 <jmcarthur> that looks like a different thing
18:46:04 <shachaf> Wait, maybe I'm misunderstanding what you're saying.
18:46:12 <shachaf> BadLadCrud: Can you give an example?
18:46:18 <Saizan> jmcarthur: foo "bar" = .. gets desugared to foo x | fromString "bar" == x = .. presumably
18:46:27 <jmcarthur> Saizan: ah!
18:46:28 <shachaf> Saizan: That's what I'd guess.
18:46:36 <shachaf> How else would it work?
18:46:46 <ddarius> shachaf: Elves.
18:46:52 <shachaf> ddarius has a point.
18:47:09 <shachaf> Anyway, it's simple enough to test.
18:47:17 <jmcarthur> i think Saizan is correct
18:48:10 <BadLadCrud> shachaf, http://pastebin.com/hTHSuKaU <-- 5 lines showing coercion with algebraic datatypes
18:48:12 <mauke> The paste hTHSuKaU has been copied to http://hpaste.org/52898
18:48:55 <BadLadCrud> daaaamn, hpaste, why you so pretty? :)
18:50:02 <kmc> well it's hard for a pastebin to be uglier than pastebin.com ;)
18:51:02 <shachaf> jmcarthur: Yep, it calls an Eq instance, including whatever unsafePerformIO that Eq instance causes.
18:51:06 <mm_freak> jmcarthur: pattern-matching against string literals is a syntactic extension of OverloadedStrings
18:51:21 <mm_freak> jmcarthur: it really just performs an Eq comparison under the hood
18:51:24 <shachaf> Presumably it won't be inlined evaluated at compile-time if it does actual arbitrary IO.
18:51:30 <mm_freak> you could do the same with view patterns
18:51:37 <mm_freak> or with classic guards
18:51:42 <iFire> Can I confuse friends and enemies if I use monads in C++ templates?
18:52:06 <shachaf> BadLadCrud: Well, sometimes you'll define that sort of thing at the language level.
18:52:34 <shachaf> BadLadCrud: Or maybe have + auto-coerce its second argument to the type of its first, or something horrible like that.
18:54:30 <BadLadCrud> shachaf, Shouldn't there be a way to have something like a Functor, which will promote internal values according to a rank, and coerce incoming parameters?
18:54:52 <shachaf> BadLadCrud: I'm not sure what you mean.
18:55:36 <ddarius> iFire: That would be a perfectly natural thing to do.
18:56:39 <shachaf> jmcarthur: IsString ByteString is evil anyway. :-)
18:57:04 <BadLadCrud> shachaf, yeah -- I tried writing a Coerce type as a Functor instance, and it turned out horribly :P
18:57:22 <jmcarthur> shachaf: it's handy for ascii protocols
18:58:09 <shachaf> BadLadCrud: It vaguely seems to me like type-aware + is the sort of thing you'd implement in the language, with primitives for per-type addition and such.
18:58:13 <BadLadCrud> shachaf, I thought somehow the 'undetermined type' would be usable as a 'contained computational context' in a Functor or Monad
18:58:29 <shachaf> BadLadCrud: I'm not quite sure what you mean by that.
18:58:53 <jmcarthur> what is a Coerce type?
19:00:08 <BadLadCrud> jmcarthur, more like 'Coercible', something I tried to write, and failed -- partly because I didn't really know what it should be. I hoped it would just reveal itself to me as I implemented the Functor and Applicative instances
19:00:40 <Sgeo|web> What should one use for efficient text?
19:00:40 <shachaf> BadLadCrud: What is "Coercible" supposed to do?
19:00:44 <jmcarthur> all i can tell is that it has something to do with coercion
19:00:53 <jmcarthur> Sgeo|web: try the text package
19:01:18 <BadLadCrud> lispAdd <*> LispVal <*> LispVal
19:01:32 <jmcarthur> Sgeo|web: if somebody says bytestring, ignore them unless you know what you're doing
19:01:36 <micahjohnston> what's a good cross-platform media library to use with Haskell? SDL + Haskell doesn't really work well on Mac and Windows
19:01:42 <jmcarthur> Sgeo|web: if somebody says String they are trying to trick you
19:01:54 <shachaf> BadLadCrud: What si the actual data type?
19:02:10 <shachaf> jmcarthur: For small strings String might well be more efficient than Text.
19:02:22 <shachaf> (So I've heard.)
19:02:31 <jmcarthur> not sure i see why that would be
19:03:11 <BadLadCrud> shachaf, the Coerce type is thus-far a failure. The LispVal is an algebraic datatype, some of which are number-types
19:03:42 <Sgeo|web> jmcarthur: I know a little about unicode issues, and that I want a text type to not have to deal with them so badly. That is, no collection of bytes, but a collection of codepoints
19:03:47 <jmcarthur> BadLadCrud: we're pressing to find out what semantics you had in mind. we understand that you couldn't implement it or make it fit into Functor
19:03:53 <shachaf> I'm not really sure what you're trying to do, but it doesn't sound a lot like a functor to me.
19:04:03 <bfig> hello. question about the pair functor: what does it transform?
19:04:04 <shachaf> However, I don't know. :-)
19:04:18 <jmcarthur> Sgeo|web: String and Text both can do that, and Text is more efficient most of the time
19:04:25 <bfig> (i'm reading Gibbons paper calculating functional programs. page 7)
19:04:36 <bfig> (err: 6)
19:04:40 <jmcarthur> bfig: you mean as in Functor ((,) a)?
19:04:53 <jmcarthur> bfig: you do you mean  data Pair a = Pair a a?
19:05:00 <BadLadCrud> jmcarthur, shachaf : I'll get an hpaste of my entire evaluation library for you
19:05:04 <bfig> i have no idea. let me write it jmcarthur
19:05:30 <Sgeo|web> Is it part of Haskell Platform?
19:06:08 <bfig> (citing from the text) the Set functor Pair is defined as follows: \n On objects, Pair A = { (a_1, a_2) | a_1 in A, a_2 in A }, ...
19:06:12 <bfig> nevermind i got it >_>
19:06:16 <jmcarthur> Sgeo|web: i think so
19:06:16 <micahjohnston> is GLFW a good one?
19:06:32 <bfig> Pair {3,4} = {(3,4),(3,3),(4,4)}
19:06:36 <jmcarthur> micahjohnston: GLFW_b i think is better supported across platforms
19:06:40 <bfig> :)
19:06:50 <jmcarthur> bfig: interesting...
19:07:15 <jmcarthur> i'm not sure that's what it is
19:07:21 <hpaste> BadLadCrud pasted “eval lib” at http://hpaste.org/52899
19:07:30 <jmcarthur> oh wait
19:07:45 <jmcarthur> if you meant {3,4} as the type containing 3 and 4, then i agree
19:07:49 <Sgeo|web> Some of the documentation talks about fusion
19:07:52 <micahjohnston> jmcarthur: wht would be the difference between that and plain old glfw?
19:07:57 <micahjohnston> jmcarthur: what's the _b?
19:07:58 <Sgeo|web> How would I make my own functions subject to fusion?
19:08:15 <jmcarthur> micahjohnston: it just distinguishes it from the other bindings i guess
19:08:24 <micahjohnston> ok
19:08:30 <micahjohnston> hm, it sayas it doesn't play well iwth forkIO
19:08:31 <jmcarthur> Sgeo|web: google stream fusion and read a paper or two
19:08:36 <micahjohnston> I was planning on heavy use of that
19:08:54 <jmcarthur> micahjohnston: you just have to make sure that you always use it within the same OS thread (the main thread works)
19:09:04 <Saizan> Sgeo|web: if you use the combinators provided by the library you'll get it for free
19:09:09 <jmcarthur> micahjohnston: all the graphics libs i know of have this limitation
19:09:30 <jmcarthur> micahjohnston: you can still use other threads so long as they don't directly use glfw
19:09:54 <Saizan> Sgeo|web: i.e. if you define your functions by composing ones that already fuse
19:09:57 <BadLadCrud> jmcarthur, shachaf : That's where it left off http://hpaste.org/52899 <-- not compilable at this point. I want to know if it's possible to write a Functor type which will help to write functions that consume coercible types
19:10:11 <micahjohnston> jmcarthur: ah ok, thanks
19:11:09 <jmcarthur> BadLadCrud: what is the type parameter intended to be?
19:11:28 <micahjohnston> jmcarthur: the threads would be building up instructions for drawing anyway, so that's nice
19:11:31 <jmcarthur> BadLadCrud: as it stands it just looks like Coerce tags your value
19:12:31 <jmcarthur> BadLadCrud: it's definitely possible to make a Functor instance. i just don't know what it's useful for
19:12:34 <BadLadCrud> jmcarthur, I didn't really have something clear in mind. I know it's terrible. It's the result of trying to find an abstraction that I don't understand
19:12:42 <jmcarthur> ah
19:13:14 <jmcarthur> basically fmap just has to apply the function to any field that has type g
19:13:38 <BadLadCrud> jmcarthur, you see how terrible it would be to write 'lplus' with 5 different internal types, right?
19:13:41 <jmcarthur> i'm not sure you'll have much luck with Applicative though
19:14:02 <shachaf> Is there any particular reason you're trying to use Functor/Applicative?
19:14:03 <BadLadCrud> I'm planning on having exact rational types
19:14:32 <BadLadCrud> no reason really, I ws just experimenting with it, to see if I could make a Functor out of it
19:15:20 <coppro> what's the best way to print a Rational as a decimal number?
19:15:34 <BadLadCrud> I had the "box" analogy put in my mind for Functors and Monads
19:15:36 <shachaf> coppro: To what precision? Potentially infinite?
19:15:43 <shachaf> I'm not sure I understand what you're trying to make, but a Functor -- oh.
19:15:47 <shachaf> Functors are not boxes.
19:15:57 <shachaf> @quote kmc functor.*box
19:15:57 <lambdabot> No quotes match. My pet ferret can type better than you!
19:15:59 <micahjohnston> you can think of them as producers
19:16:01 <micahjohnston> sometimes, at least
19:16:04 <BadLadCrud> shachaf, yeah... I know
19:16:09 <Sgeo|web> @hoogle (a,b) -> (b,a)
19:16:09 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
19:16:09 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
19:16:09 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
19:16:15 <jmcarthur> functors are thingies that have fmap
19:16:22 <ion> Data.Tuple.swap IIRC
19:16:25 <Cale> coppro: Convert it to a Float or Double using realToFrac? Unless you need more digits, that's a reasonable way.
19:16:40 <shachaf> BadLadCrud: Anyway, a Functor must be completely ignorant of the type it's applied to.
19:16:41 <jmcarthur> :t snd &&& fst
19:16:42 <lambdabot> forall a c. (a, c) -> (c, a)
19:16:58 <shachaf> I.e. it must give you a type F t for every possible t.
19:16:59 <jmcarthur> :t Data.Tuple.swap
19:16:59 <lambdabot> Not in scope: `Data.Tuple.swap'
19:17:11 <ion> lambdabot has an ancient version of everything, she lacks swap.
19:17:15 <Cale> If you want to think of a functor as a box, then it has to be a box which can have any kind of values in it.
19:17:24 <BadLadCrud> shachaf, yeah, I've come to understand that much in my failings.
19:17:33 * gwern rules hawiki with an iron fist, imposing the death penalty on all spam accounts
19:17:36 <BadLadCrud> Cale, that's the ticket
19:17:44 <shachaf> gwern: Isn't hawiki long dead? :-)
19:17:46 <coppro> Cale: fracToReal?
19:18:01 <gwern> shachaf: dammit I'm a doctor not a milkman not a lawyer not a captain
19:18:01 <Cale> :t realToFrac
19:18:02 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
19:18:05 <gwern> shachaf: what else should I call it
19:18:12 <Cale> > realToFrac (1 % 50) :: Double
19:18:13 <lambdabot>   2.0e-2
19:18:16 <shachaf> HaskellWiki
19:18:27 <ion> > realToFrac (1 % 50) :: CReal
19:18:28 <lambdabot>   0.02
19:18:33 <Cale> > showFFloat (Just 3) (realToFrac (1 % 50) :: Double) ""
19:18:34 <lambdabot>   "0.020"
19:18:37 <gwern> shachaf: and write out 'skell' every time?
19:18:52 <shachaf> Hawiki was that other wiki.
19:19:07 <shachaf> gwern: For what it's worth "ha" means "the" in Hebrew, and is stuck onto the beginnings of words without a space.
19:19:09 * Cale misses the old Moinmoin wiki
19:19:14 <gwern> shachaf: le roi est mort...
19:19:26 * ddarius also misses that wiki.
19:19:30 <Cale> It was so much more community-oriented than the new one.
19:19:35 <Cale> People had conversations there
19:19:47 <gwern> -_- you can have conversations on the current one
19:19:52 <shachaf> I guess people can have conversations on talk pages?
19:19:56 <ddarius> HaskellIrcPastePage was a lo-tech solution that was quite a success.
19:19:56 <shachaf> gwern would know, being a Wikipedia expert.
19:20:09 <shachaf> Also a Wookiepedia expert, if I remember correctly.
19:20:26 <Cale> The new one looks like wikipedia, so nobody talks on it.
19:20:26 <Cale> Because wikipedia isn't really a wiki in spirit
19:20:37 <Cale> yeah
19:20:44 <gwern> shachaf: haven't been on wookieepedia in ages
19:20:56 <shachaf> Not since the Maru days?
19:20:59 * hackagebot cqrs 0.1.0 - Command-Query Responsibility Segregation  http://hackage.haskell.org/package/cqrs-0.1.0 (BardurArantsson)
19:21:05 <Cale> HaskellIrcPastePage ended up having a lot of cool snippets on it.
19:21:08 <gwern> shachaf: pretty much
19:21:12 <shachaf> Cale: There's a surprising amount of discussion on Wikipedia; it's just not on the article pages.
19:21:21 <ddarius> Cale: There were also interesting interactions.
19:21:21 <shachaf> gwern: At one point you claimed never to have heard of it.
19:21:32 <shachaf> Why did the old wiki turn into the new wiki, anyway?
19:21:35 <gwern> shachaf: such is life
19:22:14 <Cale> There was a whole section of the old wiki for beginner questions and answers with lots of interaction going on all the time
19:22:34 <ddarius> That was a pretty good page too as well as the CommonHaskellIdioms
19:22:34 <Cale> I think it also had to do with not needing an account to use the wiki
19:23:02 <kmc> StackOverflow is probably a better venue for Q&A
19:23:13 <kmc> there's a cost to being fragmented
19:23:28 * shachaf doesn't edit wikis as a matter of principle.
19:23:33 <shachaf> Hmm, http://web.archive.org/web/20060831090007/http://www.haskell.org/hawiki/CommonHaskellIdioms
19:23:36 <kmc> there's already too much to follow :)
19:24:13 <Cale> I was immediately resentful of StackOverflow's existence when I discovered it
19:24:30 <shachaf> Cale: Why?
19:24:54 <Cale> Because there were already good forums for Q&A on Haskell, and it just fragmented those further.
19:27:16 <Cale> also, the points thing doesn't make any sense to me
19:27:23 <shachaf> That's true.
19:27:35 <ddarius> Cale is just upset because he lost StackOverflow.
19:27:35 <kmc> let's all move to Quora :D
19:27:36 * shachaf doesn't in general use StackOverflow.
19:27:44 <shachaf> They deleted my account once.
19:27:52 <shachaf> @quote stack.overflow.is
19:27:53 <lambdabot> copumpkin says: <kmc> do you have a theory where the stack overflow is coming from? <copumpkin> joel spolsky
19:28:08 <kmc> herp derp
19:28:15 <RaptorRarr> Haha
19:28:45 <Cale> ddarius: ?
19:29:04 <Cale> Is the lost thing some joke about the points?
19:29:12 <shachaf> Cale: Seems to be.
19:29:17 <shachaf> Those StackOverflow points were probably sour anyway.
19:29:21 <kmc> shit, i lost
19:29:43 <kmc> i'm playing the game where you lose every time you remember that you live in New England and it's going to be winter soon
19:29:55 <shachaf> kmc: I recommend moving to CA.
19:31:34 <deech> Hi all, Simon Marlow posted a few weeks ago that he thought he'd cracked stack traces. Has there been any follow-up code or documentation?
19:33:24 <Cale> deech: cracked?
19:33:57 <ddarius> kmc: Indeed.
19:35:18 <shachaf> Cale: Yes, the universe put this nasty DRM around evaluating Haskell and JaffaCake is cracking it bit by bit.
19:35:40 <shachaf> That's how new pieces of GHC get written. You don't think actual *people* do it, do you?
19:35:43 <deech> Cale: Something to the effect of "I finally think I know how to get stack traces working". I can't find the Google+ link.
19:35:53 <napping> Does gloss work from ghci?
19:36:21 <shachaf> deech: Oh, https://plus.google.com/107890464054636586545/posts/CfKEHZuqviy
19:36:34 <Cale> napping: I had trouble with that
19:36:49 <deech> Wait is "cracked" the wrong word? I always thought it meant solved.
19:37:05 <napping> It fails for me with some freeglut message; I wonder if it works for others
19:37:14 <napping> The FAQ about -fno-ghci-sandbox suggests it's at least possible
19:37:25 <ion> crack, v. 9. (tr) to solve or decipher (a code, problem, etc)
19:38:17 <Cale> I kind of find the idea of a stack trace to be a bit antithetical to the way that Haskell programs actually run
19:39:08 <napping> Well, I was hoping that meant a trace of what created the code that was running
19:39:58 <deech> Cale: Perhaps, but right now I can't tell where the error generated by the "error" function is coming from.
19:40:00 <Cale> I guess you could carry around annotations at runtime, for an exorbitant fee. :)
19:40:22 <Cale> deech: what's the error message?
19:40:38 <ddarius> If you are going to pay an exorbitant fee, just record absolutely everything that happens.
19:41:36 <shachaf> Cale: This was the original post: https://plus.google.com/107890464054636586545/posts/XE4T6hHm3tK
19:42:16 <deech> Cale: any function that uses "error" to terminate the program, like "head" which seems like the canonical example.
19:42:32 <Cale> deech: Yeah, I mean, in your specific case
19:43:42 <deech> Cale: nothing specific right now, just wondering about it in general.
19:44:01 <sm> I'm using a SampleVar to share some mutable state between threads. It feels a bit clunky, is there a better/simpler way ?
19:44:23 <deech> sm: TVar's?
19:44:56 <Cale> sm: You know about IORef/MVar/Chan and STM?
19:45:29 <Cale> If SampleVar has the right blocking semantics for you, then it's probably the best thing.
19:45:33 <shirt> Cale: are those all of the options?
19:45:49 <Cale> shirt: well... there are a few others.
19:46:32 <sm> I know enough to be a bit confused about which to use
19:46:43 <Cale> That's most of them from the base library.
19:46:48 <kmc> we need a flow chart
19:46:50 <kmc> :D
19:46:52 <sm> eg are http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/GHC-Conc.html#t:TVar and http://hackage.haskell.org/packages/archive/stm/latest/doc/html/Control-Concurrent-STM-TVar.html#t:TVar different ?
19:46:57 <Cale> sm: Most people end up using MVars for the most part.
19:47:17 <kmc> sm, the GHC.* modules are usually providing implementations for the "standard" ones
19:47:19 <Cale> sm: One is a re-export of the other
19:47:31 <Cale> sm: You're not really meant to import GHC.Conc
19:47:39 <Cale> unless you really need to for some reason
19:47:51 <sm> cool
19:48:07 <shachaf> Cale: It's annoying that :i TVar will tell you that it's from GHC.Conc.
19:48:18 <sm> what feels clunky about samplevars is reading destroys it so I have to write back every time. I think I moved from mvars some time back for some reason
19:48:22 <shachaf> (No matter which module you imported it from.)
19:48:29 <Cale> Yeah, it should also tell you which of your imports you got it from
19:48:31 <kmc> annoying? i find that quite useful
19:48:39 <kmc> though displaying both would be ideal
19:48:41 <shachaf> kmc: Well, OK, it should tell you both.
19:48:56 <shachaf> I have a big .ghci so that I can :i anything in order to tell what to import to get it.
19:49:02 <Cale> sm: Maybe you just want an IORef?
19:49:19 <kmc> it should be easy to implement the semantics you want on top of MVar
19:49:21 <sm> I guess it was the warnings, "susceptible to race conditions, deadlocks or uncaught exceptions"
19:49:30 <Cale> sm: If you want nothing to block, then you should just use IORef
19:49:34 <kmc> sm, warnings where?
19:49:38 <sm> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-MVar.html#t:MVar
19:49:47 <shachaf> kmc: MVar documentation.
19:49:53 <Cale> You will be subject to race conditions, but if you use SampleVar like that, you're subject to race conditions anyway.
19:49:59 <kmc> oh wow that's way more docs than the Platform version of that module
19:50:18 <kmc> sm, I think that's saying "concurrent programming is hard"
19:50:46 <kmc> i mean MVars are not especially dangerous compared to lock-like constructs in other languages
19:50:51 <sm> Cale: how's that ? thread A reads the samplevar, thread B tries to and blocks, A replaces the value, B unblocks and reads it....
19:50:57 <kmc> we just have high standards and so promote STM as the alternative
19:51:33 <Cale> sm: Which is identical to: Thread A reads the IORef, Thread B reads the IORef, nobody blocks.
19:52:53 <sm> alright.. I'd better rethink with a clear mind
19:52:56 <Cale> sm: If you always replace the same value into a SampleVar after reading it, then you end up with all the same problems concurrency-wise as IORefs have.
19:53:17 <Cale> But that might be "no problems at all" for many programs
19:53:17 <Sgeo|web> SampleVar?
19:53:24 <shachaf> Sgeo|web: Exactly.
19:53:27 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/Control-Concurrent-SampleVar.html
19:54:15 <sm> my problem with mvar might have been related to exceptions
19:54:41 <Cale> sm: Actually, you get one new problem ;)
19:54:53 <Cale> sm: Consider this: Thread A reads the SampleVar, Thread B writes the SampleVar with a new value, Thread A writes back the original value
19:55:18 <Cale> So now reads on the SampleVar, because they're replacing the value, have a race with other threads trying to write it.
19:55:36 <Cale> resulting in lost updates
19:55:36 * shachaf wonders why they called it a SampleVar.
19:55:37 <napping> isn't B blocked until the value is replaced?
19:55:52 <shachaf> Isn't the Haskell tradition to take a random letter and stick it in front of the word "Var"?
19:55:54 <Cale> no, because you can always write to an empty SampleVar
19:56:05 <sm> I thought so, but Cale's right, put doesn't block
19:56:10 <napping> ah, that's the semantics
19:56:24 <Cale> Writing to a SampleVar never blocks
19:56:37 <Cale> only reading an empty SampleVar blocks
19:56:55 <Cale> and reading a nonempty SampleVar empties it
19:57:49 <Sgeo|web> So Text handles text more accurately than String does?
19:58:05 <sm> I "just" want a shared global app state var which all threads can access in an exception- and thread-safe way
19:58:22 <Cale> sm: You can use IORef across threads just fine
19:58:38 <Cale> sm: It's just that you might end up with weird race conditions and such
19:58:39 <ddarius> Sgeo|web: They are both accurate.
19:58:41 <jmcarthur> IORef with atomicModifyIORef can actually get you really far
19:58:48 <hpaste> mike1127 pasted “class problem” at http://hpaste.org/52900
19:59:16 <mmos1127> My question posted at above link ^^^
19:59:22 <Cale> sm: But it's impossible to see a half-written IORef, for instance.
20:00:02 <sm> yes, and won't atomicModifyIORef take care of updates ? As long as I keep things simple anyway
20:00:19 <Cale> mmos1127: {-# LANGUAGE ... #-}
20:00:41 <jmcarthur> operations on the state can only be atomic when they are pure though
20:00:49 <jmcarthur> with atomicModifyIORef
20:01:16 <jmcarthur> it uses a really nifty trick with laziness
20:01:32 <jmcarthur> it just replaces the value in the ref with a thunk
20:01:42 <sm> well this looks very straightforward.. waait, what's this fine print at the end. That doesn't sound so great: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-IORef.html#g:2
20:01:49 <jmcarthur> and then it later gets evaluated
20:02:42 <companion_cube> when a haskell program has several threads that share a thunk, and which evaluate it concurrently, what happens? is the thunk rewritten several times ?
20:02:43 <jmcarthur> sm: what is surprising about that text?
20:02:58 <jmcarthur> companion_cube: that is possible, yes
20:02:59 <napping> It's usually only written once
20:03:00 <jmcarthur> but won't always happen
20:04:02 <kmc> companion_cube, in GHC there is a small race condition which can result in duplicated work of that form
20:04:13 <kmc> if you are unlucky
20:04:15 <companion_cube> so writes to a thunk should be atomic, i guess
20:04:15 <Cale> companion_cube: only if they happen at almost identically the same time
20:04:21 <kmc> by far the most common outcome is that one thread ends up waiting for the other
20:04:25 <companion_cube> uh, ok
20:04:30 <kmc> a thunk under evaluation is replaced with a "whitehole"
20:04:39 <napping> The results will always be the same, so it's okay if it's overwritten
20:04:47 <kmc> evaluating a whitehole makes the current thread sleep until the other thread has finished
20:04:57 <Sgeo|web> It shouldn't actually matter except due to time, unless you're using unsafePerformIO, I think
20:05:05 <napping> so it uses cheap writes to mark that evaluation is in progress
20:05:07 <kmc> Sgeo|web, uPIO has a global lock to prevent trouble here
20:05:07 <sm> jmcarthur: it's not surprising, I just can't presently understand it well enough to know if this meets the requirements I mentioned
20:05:17 <kmc> unsafeDupablePerformIO does not; that's the difference
20:05:17 <companion_cube> yep, a thunk has a deterministic valu
20:05:18 <napping> so there's a window of a few cycles that might let two threads start at once
20:05:20 <companion_cube> value*
20:05:23 <shachaf> kmc: Oh, so it doesn't use atomic instructions?
20:05:28 <kmc> IO performed inside uDPIO might occur more than once
20:05:38 <kmc> shachaf, I'm not sure what instructions are used
20:05:46 <sm> but I'll try it next session. Thanks, all
20:05:47 <Sgeo|web> You know what would be interesting? A language where time and space complexity were part of types
20:05:47 <napping> but you save a bunch of time not taking locks
20:05:49 <shachaf> Someone was asking about that in here recently.
20:06:16 <jmcarthur> sm: what is the access pattern you need?
20:06:16 <Cale> sm: If you're scared, just use MVar
20:06:27 <companion_cube> wow, earthquake again?
20:06:32 * ddarius wants to build a Hall Effect Thruster.
20:06:35 <napping> Also, when threads are switched the stack is walked to see whether you are working on anything that another tread also managed to start working on
20:06:44 <napping> and if so the work is canceled
20:07:00 <kmc> ddarius, you should do it!
20:07:07 <kmc> companion_cube, where?
20:07:52 <companion_cube> the Bay
20:07:55 <companion_cube> I'm not sure
20:08:39 <kmc> at one point Kazakhstan had the fourth-largest nuclear arsenal in the world
20:09:01 <jmcarthur> unsafePerformIO uses an MVar under the hood
20:09:05 <jmcarthur> iirc
20:09:12 <shachaf> An MVar? Really?
20:09:23 <kmc> companion_cube, SF bay?
20:09:26 <jmcarthur> i am 90% certain
20:09:36 <kmc> why not an MVar?
20:09:43 <companion_cube> kmc: yes, i'm in palo alto
20:09:55 <shachaf> companion_cube: You are? Were you at the bahaskell meeting yesterday?
20:10:09 <sm> Cale: ok I see. So these are ordered something like ... -> IORef -> MVar -> SampleVar -> TVar -> ...
20:10:13 <kmc> my friend in SF says "it went thud, once"
20:10:20 <sm> in complexity/safety
20:10:24 * shachaf didn't notice anything today.
20:10:30 <ddarius> kmc: Maybe California finally broke off.
20:10:32 <Cale> SampleVar is actually weaker than MVar
20:10:32 <kmc> sm, I don't see how you can order them linearly
20:10:54 <companion_cube> shachaf: no, and i should
20:11:05 <Cale> MVar blocks on writes to a full MVar
20:11:07 <jmcarthur> each can be good in different circumstances
20:11:12 <shachaf> companion_cube: Yes! You're coming to the next meeting, right?
20:11:14 <jmcarthur> i don't actually know what SampleVar is though
20:11:14 <Cale> which is the only difference between MVar and SampleVar
20:11:18 <sm> hm.
20:11:21 <jmcarthur> ah
20:11:32 <companion_cube> shachaf: when and where is it? :)
20:11:37 <jmcarthur> sm: how is the access pattern you need?
20:11:42 <jmcarthur> s/how/what/
20:12:09 <sm> jmcarthur: a shared global app state var which all threads can access in an exception- and thread-safe way
20:12:09 <sm>     
20:12:24 <jmcarthur> sm: define "access"
20:12:26 <sm> I'm just updating counters & timestamps & stuff
20:12:50 <shachaf> companion_cube: Usually the third Wednesday of the month, in SF (near the Caltrain station).
20:12:57 <sm> usually one thread modifies and the other(s) read, but I might have two writers
20:12:57 <jmcarthur> sm: is this just a single global state then. is each modification to it a pure computation?
20:13:01 <Cale> sm: I'd say go with MVar
20:13:25 <jmcarthur> i'm quite a fan of atomicModifyIORef when it's applicable
20:13:30 <companion_cube> shachaf: then i may come next month!
20:13:33 <Cale> sm: When one thread wants to update, it should take the MVar, read the value, decide how to update, and then write the updated value back.
20:14:07 <shachaf> companion_cube: There's also bacat, in theory usually the week after bahaskell in Mountain View, though this month's meeting might be moved.
20:14:35 <sm> jmcarthur: eh yes I think so.
20:14:47 <Cale> Yeah, you may also be able to get away with IORef and atomicModifyIORef, but the thing about counters makes it sound like you'll be forced into using atomicModifyIORef and not just plain reading/writing the IORef
20:15:14 <jmcarthur> yeah when sharing IORefs across threads I pretty much never use readIORef or writeIORef
20:15:18 <Cale> Because if two threads read the counter at the same time, and then try to increment it, it'll only be incremented once then
20:15:27 <jmcarthur> well... unless i have some write-only stuff going on
20:15:34 <jmcarthur> and read-only
20:16:55 <jmcarthur> basically, if a thread reads and then writes, it pretty much has to use aMIOR
20:17:13 <Cale> IORef can be good as a sort of inexact version of a channel actually :)
20:17:20 <jmcarthur> threads that only ever read or only ever write don't have to, though
20:17:24 <Cale> (where you drop elements on the floor if they're not read in time)
20:18:34 <Cale> Anyway, one good way to set up communication between your threads is to create the IORef/MVar/whatever at the top level, and then define in terms of it a function for writing, and an action for reading the state.
20:18:38 <jmcarthur> an IORef (Sequence a) can even make a decent queue
20:18:43 <Cale> and then pass those down to your threads
20:19:08 <napping> Is there a quick way to get criterion-stye KDEs from a histogram?
20:19:09 <sm> let's see if I can be more concrete.. what brought this on is rss2irc has an option to limit the number of polls it will attempt. The iterationsleft counter is used by the normal feed reader loop, but also by an outer loop which catches exceptions
20:19:09 <Cale> You then get pretty precise control over who has read or write privileges
20:19:31 <napping> I've imported all the libraries and computed them the same way, but it takes a bit
20:19:32 <Cale> and you can change the semantics of reading and writing that state from a central location
20:20:52 <sm> (this particular case is all in one thread, but I think a global state var is the solution. The top level monitor thread will also read it right before it exits the program for logging)
20:21:11 <sm> righto, will do
20:21:37 <Cale> By "top level", I mean up in 'main' or wherever you create your threads
20:21:42 * sm nods
20:21:52 <Cale> I would never advocate actually defining top level globals ;)
20:22:41 <Cale> Passing handles to these things around explicitly is good for you, it builds character ;)
20:23:03 <jmcarthur> i've used top level globals to help provide pure interfaces over terrible ffi bindings
20:23:19 <sm> but through exceptions ? I suppose I could always include the last state in the exception...
20:23:23 <jmcarthur> i guess ffi bindings is redundant
20:23:25 <Cale> Yeah, well, when FFI is involved, anything goes
20:23:55 <Cale> C libraries are awful, and having to do more evil to cancel out some of their evil is fair.
20:31:56 <kmc> not all C libraries are awful
20:33:48 <kmc> writing bindings for udis86 was really pleasant
20:34:18 <kmc> it keeps all state in a struct which you allocate yourself
20:37:50 <JoeyA> Is my understanding of a Chan (or TChan) correct? :   A Chan is a first-in first-out queue that can be read from or written to by any thread.  Every item written to a Chan will be read exactly once (unless you use dupChan).  readChan will block if there are no items available in the channel.  writeChan will never block; items will simply pile up in memory if nobody is reading the channel.
20:38:29 <kmc> sounds correct to me
20:38:40 <Cale> http://www.airliners.net/aviation-forums/general_aviation/read.main/336291/ -- this guy sure lost his bet.
20:38:51 <kmc> JoeyA, well, an item is read at most once, not exactly once
20:39:05 <kirindave_> Is there any way to get haskell to build in parallel?
20:39:19 <kirindave_> I just spend a long time building highlighting-kate with 7 idle cores.
20:39:28 <kmc> Cale, O_O
20:39:30 <parcs> make -jn
20:39:38 <kirindave_> I guess I should qualify that
20:39:44 <kirindave_> cabal-install
20:39:44 <kmc> kirindave_, Cabal / ghc --make can't do it :/
20:39:49 <irene-knapp> wowwwwww Cale
20:39:57 <kirindave_> kmc: Bummer.
20:39:57 <kmc> if you write a custom Makefile you can parallelize with make -j
20:40:05 <kmc> in fact GHC has some support for generating makefiles
20:40:09 <kmc> so GHC itself can be built in parallel ;)
20:42:29 <companion_cube> Cale: wow, the guy must feel a bit stupid now
20:43:22 <NemesisD> anyone know where I could look at the source code for Either's instances? they don't seem to be in the haddock source for Data.Either
20:44:06 * JoeyA wishes Haddock could link to the source code of instances (can it?)
20:44:14 <bfig> small question about the categorical notion of monads: the haskell alternative of monads should be a-> m a right?
20:44:33 <Cale> bfig: That's the type of return
20:44:37 <Cale> = eta
20:44:43 <NemesisD> i don't think it can
20:44:51 <NemesisD> which is frustrating
20:45:15 <Cale> NemesisD: Aren't most of them just the derived instances?
20:45:22 <Cale> NemesisD: which instance in particular?
20:45:25 <bfig> but in general, you define instance monad m, which is not a function wrapper necessarily. you can bind something that is not a 'real monad'
20:45:27 <NemesisD> Cale: applicative
20:45:32 <bfig> like m a
20:45:42 <Cale> bfig: For each type t, you have a type m t
20:46:14 <bfig> that's not what i mean. my point is, when you bind something like > return 4 >>= putStrLn
20:46:25 <Cale> bfig: with natural transformations 1 -> m and m^2 -> m, which correspond to polymorphic functions of types a -> m a and m (m a) -> m a respectively
20:46:28 <bfig> there is only one monad there, putStrLn
20:46:33 <Cale> putStrLn isn't a monad
20:46:36 <Cale> IO is a monad
20:46:54 <bfig> well, monadic object maybe?
20:47:08 <Cale> putStrLn :: String -> IO ()
20:47:19 <Cale> so it's a function constructing monadic actions, I guess :)
20:47:33 <bfig> my point is, shouldn't the *whole thing* should be the monad_
20:47:41 <Cale> The monad is the type constructor
20:47:46 <Cale> IO
20:47:53 <bfig> i'm talking from the category viewpoint
20:47:57 <Cale> I am too
20:48:11 <Cale> In category theory, a monad is a functor T
20:48:16 <Cale> (primarily)
20:48:23 <Cale> together with some natural transformations
20:48:30 <Cale> eta :: 1 -> T
20:48:35 <Cale> and mu :: T^2 -> T
20:48:58 <ybit> hey you guys
20:49:02 <ybit> http://pastie.org/private/slpq2zpqiezgyhfkpk5i3a
20:49:05 <ybit> looking for thoughts
20:49:13 <Cale> A functor has two parts: a mapping on objects of the category (in this case our objects are types)
20:49:23 <ybit> he makes a point i think
20:49:26 <Cale> which is provided by a type constructor in Haskell
20:49:42 <Cale> and a mapping on arrows
20:49:55 <Cale> (our arrows are functions in Haskell)
20:50:01 <bfig> that is the bind right?
20:50:05 <Cale> no
20:50:06 <Cale> fmap
20:50:14 <Cale> fmap :: (a -> b) -> (f a -> f b)
20:50:30 <Cale> fmap says how arrows a -> b get sent to arrows f a -> f b by the functor
20:51:15 <Cale> (of course, we get an endofunctor in Haskell, because there's no second category to talk about)
20:52:05 <Cale> So our natural transformation eta: 1 -> T will have components at each type X,  eta_X: X -> T X
20:52:12 <Cale> :t return
20:52:13 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:52:37 <Cale> ^^ those components are provided by the polymorphic function return
20:52:41 <bfig> ok, so the  a -> m b part is just a trick, the 'a' at the start
20:52:59 <Cale> Parametricity can be used to show that these really are the components of a natural transformation (that the naturality squares commute)
20:52:59 <bfig> the bind doesn't do anything with monads, it is a weird notation
20:53:03 <Cale> Hm?
20:53:16 <bfig> the monads are m a, m b. how do you bind those two?
20:53:16 <Cale> Well, x >>= f is another way to write join (fmap f x)
20:54:19 <Cale> There's an alternative presentation of monads from category theory in terms of "Kleisli triples", and >>= roughly corresponds to the * in that notation.
20:54:29 <bfig> that way it makes sense, but if you want to construct from a->b something a -> m b you can't use something straightforward.
20:54:46 <bfig> * == >=> ?
20:54:50 <Cale> Well, you can compose with the component of eta at b
20:55:04 <Cale> no, * = (=<<), iirc
20:55:07 <bfig> :t >=>
20:55:08 <lambdabot> parse error on input `>=>'
20:55:12 <Cale> :t (>=>)
20:55:13 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
20:55:16 <Cale> :t (<=<)
20:55:17 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
20:55:29 <Cale> (<=<) is also called "Kleisli composition"
20:56:09 <Cale> (=<<) corresponds to Kleisli extension
20:56:12 <Cale> :t (=<<)
20:56:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
20:56:17 <Cale> yeah
20:56:25 <Cale> (-)* : Hom(X, TY) -> Hom(TX, TY)
20:56:32 <Cale> so, that's right
20:56:43 <Cale> under change of notation :)
20:58:00 <Cale> http://en.wikipedia.org/wiki/Kleisli_category#Extension_operators_and_Kleisli_triples
21:00:17 <Cale> ybit: Went back and looked at your paste...
21:01:25 <ybit> Cale: yes?
21:01:30 <Cale> ybit: I'm not really certain what to say about it, except that in mathematics there is no time, so the difference between something having a type and something that will have a type once we work out what it is is inconsequential.
21:02:12 <Cale> (provided we know that we can do so :)
21:02:32 <Cale> I hate metaphysics ;)
21:02:53 <ybit> Cale: this is in regards to a generative geometry that someone is working on
21:03:01 <johnfn> i want to write some code in do notation, but i don't want to be in the IO monad - how might i do that?
21:03:04 <ybit> so i think it is important in this application
21:03:22 <parcs> is it possible to define a monad instance for newtype Compose m n a = Compose (n (m a))
21:03:23 <mmos1127> I wrote a program that writes a prompt via 'putStr', then reads a line via getLine. The interpreted version worked fine, but the compiled version doesn't write the prompt until just before the program exits. What am I doing wrong?
21:03:31 <bfig> johnfn, just write it
21:03:47 <bfig> johnfn, if it isn't in the IO monad it won't be. if it is, it will be.
21:03:52 <mmos1127> is there a command to flush std out or something like that?
21:03:52 <Cale> parcs: only in conjunction with some additional stuff.
21:04:04 <parcs> Cale: like what?
21:04:16 <bfig> johnfn, i think you can do unsafePerformIO if you really really don't want it there
21:04:16 <Cale> parcs: If m and n are monads, then Compose m n is only a monad if you have a distributive law
21:04:44 <Cale> which... why did you define Compose backward ;___;
21:04:46 <ybit> i guess you could try the template haskell + zeano, but trying to re-encode that data might be too much of a pain
21:05:07 <Cale> anyway, http://en.wikipedia.org/wiki/Distributive_law_between_monads
21:05:16 <Sgeo|web> johnfn: what do you want to use do notation for, exactly?
21:05:23 <parcs> Cale: hehe, i was thinking of making 'Compose m' a monad transformer
21:05:34 <Sgeo|web> It occurs to me that there is an Identity monad that does nothing...
21:05:58 <johnfn> Sgeo|web, i'm trying to implement an algorithm that seems a lot more clear to me if considered more imperatively
21:06:21 <Sgeo|web> johnfn: what imperative features are you looking for, precisely?
21:06:26 <johnfn> bfig, the problem is that something like this https://gist.github.com/1303082 explodes
21:06:49 <Sgeo|web> There's two pure ways to do something that looks like variables
21:06:51 <Cale> parcs: Certainly, there's a way to define Compose m as a monad transformer for many choices of m, but sometimes there's no way to do it, and sometimes there's more than one way
21:07:06 * ybit has school work to do attend to, thanks for looking at the paste
21:07:06 <Cale> parcs: (and some monad transformers don't arise in that fashion)
21:07:13 <bfig> johnfn, pure is not a monad
21:07:15 <Sgeo|web> One of which is preferable to the other
21:07:25 <Cale> ybit: I guess I don't really understand the question
21:07:29 <Sgeo|web> johnfn: would using a large let...in... work for you?
21:07:37 <bfig> johnfn, also, if you're doing IO, you will either need to lift your monad to IO or write it in IO
21:07:43 <Cale> ybit: It would be helpful to see some example code with a property that you'd like to ensure
21:07:50 <ion> johnfn: Add type annotations to things.
21:07:58 <johnfn> bfig, right, i want do without the monad, if that makes sense?
21:08:11 <Sgeo|web> johnfn: what do you want to do with do without the monad?
21:08:16 <bfig> johnfn, do ~ monad notation.
21:08:23 <Sgeo|web> Describe it
21:08:24 <Cale> johnfn: Why do you want do? Why not just let?
21:08:27 <Sgeo|web> let exists outside of do
21:08:40 <Cale> johnfn:  tester = let x = 5; y = 6 in x + y
21:08:41 <bfig> use let, enters and scope
21:08:47 <johnfn> essentially i was writing out the alg and i ended up with like nested lets and ifs
21:08:56 <johnfn> with like 5 nested lets and ifs*
21:09:05 <Cale> johnfn: You shouldn't have to nest lets
21:09:08 <Sgeo|web> nested lets?
21:09:08 <johnfn> and it was kind of a readability disaster
21:09:09 <ion> Paste the code.
21:09:13 <johnfn> alright
21:09:26 <Sgeo|web> If you want a new x and uncreative to think of a name, try x'
21:09:33 <kmc> noooo
21:09:39 <kmc> you will inevitably typo x' as x
21:09:45 <Sgeo|web> Note: My advice may be bad
21:09:45 <Cale> kmc: hehe
21:09:50 <kmc> and the type system will not catch it because they have the same type
21:09:55 <Cale> I agree with Sgeo|web's advice :)
21:09:57 <kmc> and you'll spend ages tracking down weird infinite loops
21:10:04 <Cale> But yeah, be careful
21:10:04 * kmc once burnt twice something
21:10:07 <kmc> i prefer x0, x1, etc.
21:10:15 <Cale> Noooo
21:10:17 <ion> Or hide the x from the scope in the first place.
21:10:22 <ion> if appropriate
21:10:24 <Cale> you will inevitably typo 1 as 0
21:10:34 <kmc> haha
21:10:50 <kmc> sometimes i wish for non recursive let
21:10:50 <Cale> the keys are like, right next to each other
21:10:59 <kmc> you can use «do  x <- return (x+1)» for this sort of thing
21:11:01 <kmc> but it's gross
21:11:20 <bfig> or use arrows :)
21:11:21 <parcs> Cale: i see.. i had this totally amazing idea of creating a generic monad to monad-transformer transformer
21:11:46 <Cale> parcs: yeah, there's a little extra bit you need to specify
21:11:53 <Sgeo|web> I suppose I'd be shot for suggesting the Identity monad
21:11:59 <Cale> parcs: which is usually about as hard as defining a monad transformer in the first place ;)
21:12:18 <kmc> it is much easier to transform monad transformers to monads than the other way 'round ;)
21:12:20 <Cale> parcs: if you have join :: m (m a) -> m a and a join :: n (n a) -> n a
21:12:33 <Sgeo|web> You get do notation, without it actually being of any use!
21:12:36 <Cale> parcs: and you want to define join :: m (n (m (n a))) -> m (n a)
21:13:05 <shachaf> kmc: But what about monad transformer transformers? Eh?
21:13:07 <Cale> parcs: then you need something to "swap the middle n and m" which satisfies some laws appropriate to getting the monad laws to work later
21:13:23 <ion> Monad cotransformers, anyone?
21:13:25 <Cale> that is, you need  dist :: n (m a) -> m (n a)
21:13:57 <johnfn> https://gist.github.com/1303085
21:14:05 <Cale> so that you can write join = fmap join . join . fmap dist
21:14:44 <ion> johnfn: It would be much easier to understand your code if it didn’t lack type annotations for everything.
21:14:46 <bfig> johnfn, you have a maybe, you don't need to ask if it is just
21:14:50 <Sgeo|web> > runIdentity $ do { x <- 5; return x }
21:14:50 <lambdabot>   No instance for (GHC.Num.Num (Data.Functor.Identity.Identity a))
21:14:51 <lambdabot>    arising...
21:15:07 <Sgeo|web> ...o.O?
21:15:16 <Sgeo|web> > runIdentity $ do { x <- 'x'; return x }
21:15:17 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
21:15:17 <lambdabot>         against inferred type...
21:15:22 <Cale> johnfn: Don't use if isJust
21:15:28 <Cale> johnfn: use case :)
21:15:31 <Sgeo|web> against inferred type....what?
21:15:36 <Cale> case createdNode of
21:15:39 <Cale>   Nothing -> ...
21:15:44 <Cale>   Just newNode -> ...
21:15:52 <bfig> use creatednode >>=  :)
21:16:07 <bfig> it's weird because everything is a monad :|
21:16:11 <Cale> But I don't know how you want to handle the Nothing case
21:16:19 <Cale> bfig: that may or may not work :)
21:16:20 <johnfn> ion, sorry, i should have realized that was important to include - i edited the gist
21:16:22 <ion> sgeo: x <- pure 5
21:16:33 <ion> or x <- Identity 5
21:16:34 <Sgeo|web> Oh, duh
21:16:41 <Cale> or x <- return 5
21:16:44 <Sgeo|web> > runIdentity $ do { x <- return 'x'; return x }
21:16:45 <lambdabot>   'x'
21:16:48 <bfig> how could it stop working? isn't everything autolifted to IO?
21:17:00 <bfig> (unless you explicitly type it?)
21:17:02 <Cale> bfig: ???
21:17:16 <Cale> bfig: nothing is autolifted to IO
21:17:33 <ion> Travelling back and forth in the timeline, i keep forgetting the Monad class still includes ‘return’ instead of depending on Pointed at this point in time.
21:17:33 <Sgeo|web> Isn't what johnfn's doing the exact use case of the Maybe monad?
21:17:42 <Cale> Sgeo|web: maaaaybe
21:17:48 <Sgeo|web> No, wait
21:17:52 <Cale> Sgeo|web: part of his code is missing, so I can't tell
21:18:01 <Cale> there's an if with a then, but no else
21:18:21 <johnfn> i don't think so, because there's no real "failing state"
21:18:22 <johnfn> hmm
21:18:40 <Cale> (which is a syntax error)
21:18:42 <johnfn> i mean i could just post like the 100 lines i have but i had an impression that you guys might not be interested in seeing it
21:18:49 <bfig> just use >>=, if it doesn't compile, liftIO it :)
21:18:54 <Cale> bfig: ???
21:19:00 <bfig> won't that work?
21:19:02 <MatrixFrog> johnfn: that's what hpaste is for
21:19:05 <Cale> bfig: that doesn't make any sense in this context
21:19:13 <Sgeo|web> I usually figure out what I want to do by the time my code compiles correctly
21:19:39 <Cale> 1) Dump all code on hpaste
21:19:42 <Cale> 2) "HALP"
21:19:46 <Cale> 3) ...
21:19:49 <Cale> 4) Profit!
21:19:54 <Sgeo|web> Unless I decide to use error because my types are expecting a value and I have no meaningful value to give it so I figure what's the worst that can happen then my program calls me an idiot
21:20:15 <Sgeo|web> ^^happened yesterday
21:20:15 <MatrixFrog> calls you an idiot? maybe you should use kinder error messages
21:20:52 <Sgeo|web> But it called me an idiot at runtime not compiletime, so trying to cheat the types with _|_ is a bad idea
21:20:57 <Cale> error "You fucking moron. I need to hire a better programmer to write me."
21:21:20 <Jafet> Daisy daisy do
21:21:36 <ion> Haskell should have sudoers(5)-style “Defaults insults”. I love it.
21:21:47 <Cale> @src ghjfksa
21:21:47 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:21:49 <Cale> @src ghjfksa
21:21:50 <lambdabot> Source not found. Take a stress pill and think things over.
21:22:07 <ion> s/Haskell/GHC/
21:22:28 <Cale> At one point, GHC had a bug where it deleted your source code if there was a type error.
21:22:39 <Cale> Best bug ever.
21:23:15 <ion> Agreed. Alas, it should take into account that the code may exist in a VCS and take care of that, too.
21:23:18 <edwardk> preflex: xseen ezyang
21:23:19 <preflex>  ezyang was last seen on freenode/#haskell 1 day, 11 hours, 29 minutes and 1 second ago, saying: It's kind of remarkable we've been able to get so far, quite frankly.
21:23:25 <keep_learning> what is command line extension to use haskell98-2.0.0.0  with ghc-7.2.1 . Could not find module `IO` It is a member of the hidden package `haskell98-2.0.0.0'
21:23:39 <Cale> keep_learning: Try just --make
21:23:48 <Cale> keep_learning: if that doesn't work -package haskell98
21:23:54 <Cale> or -package haskell98-2.0.0.0
21:23:56 <kmc> haskell98 is hidden in GHC 7.2 iirc
21:24:01 <kmc> so -package haskell98 is probably required
21:24:02 <Cale> ah
21:24:08 <kmc> or maybe -XHaskell98
21:24:26 <mmos1127> is there a command to flush std out or something like that?
21:24:29 <mmos1127> I wrote a program that writes a prompt via 'putStr', then reads a line via getLine. The interpreted version worked fine, but the compiled version doesn't write the prompt until just before the program exits. What am I doing wrong?
21:24:40 <Cale> mmos1127: You've got it :)
21:24:46 <Cale> mmos1127: hFlush stdout
21:24:56 <Cale> mmos1127: Or just  hSetBuffering stdout NoBuffering
21:25:05 <Cale> import System.IO  to get this stuff
21:26:12 <Cale> You'll also probably want to ensure that stdin is set on LineBuffering
21:26:24 <Cale> (so that backspace works)
21:27:45 <Cale> johnfn: Did you paste more of your code somewhere?
21:27:57 <Cale> johnfn: It might be that there's an overall more idiomatic approach
21:28:47 <ion> Better to use explicit hFlush rather than NoBuffering. It’s much more efficient.
21:28:48 <johnfn> Cale, yeah, give me a bit though, i've been writing a lot of code without testing along the way so i want to clean it up a bit first
21:29:32 <Cale> ion: If it's all quick interactive stuff though, it probably doesn't matter
21:38:04 <mmos1127> Cale: thanks
21:41:00 * hackagebot HROOT 0.6.9 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.9 (IanWooKim)
21:42:59 * kmc wonders if the author of HROOT could choose a more descriptive synopsis
21:43:28 <companion_cube> ROOT is an experimental physics framework, afai
21:43:32 <companion_cube> afaik*
21:43:57 <Cale> http://hackage.haskell.org/packages/archive/HROOT/0.6.9/doc/html/HROOT-Class-Interface.html#t:Existable -- interesting class name
21:44:34 <Cale> I kinda want it to be called Beable ;)
21:45:03 <Cale> http://www.kibo.com/exegesis/index.shtml#BEABLE
21:46:55 <DanBurton> so are any of you guys planning on participating in the upcoming VirtuaHac?
21:47:16 <shachaf> What's the difference between that and working on a thing while being in #haskell?
21:47:31 <DanBurton> well it's basically the same
21:47:45 <DanBurton> except it's a generally more concerted effort to actually get stuff done
21:48:40 <DanBurton> @where virtuahac
21:48:40 <lambdabot> http://www.haskell.org/haskellwiki/VirtuaHac
21:50:03 <Sgeo|web> Can just anyone upload to hackage?
21:50:41 <Saizan> you've to request an account first, but yes
21:51:05 <Sgeo|web> @hoogle I forgot what I wanted to Hoogle for a half hour ago
21:51:06 <lambdabot> Can't think of anything more interesting to search for?
21:51:07 <lambdabot> No results found
21:53:08 * MatrixFrog did not know about virtuahac. nice!
22:04:42 <ivanm> I seem to recall seeing a message on libraries@ about a patch to containers so that you could do something like Map k a -> Set k -> Map k a
22:04:48 <ivanm> at the time, I thought it was ridiculous
22:04:51 <ivanm> now I want/need it :s
22:05:23 <ivanm> what's my best bet, turn that Set into a useless Map and use M.instersection?
22:05:34 <ivanm> @hoogle Set a -> Map a b
22:05:35 <lambdabot> Data.Map singleton :: k -> a -> Map k a
22:05:35 <lambdabot> Data.Map delete :: Ord k => k -> Map k a -> Map k a
22:05:35 <lambdabot> Data.Map deleteAt :: Int -> Map k a -> Map k a
22:05:49 <ivanm> there's no inverse to keysSet?
22:08:09 <Cale> ivanm: could have been me
22:08:18 <Jafet> filterWithKey (const . (`S.member` s))
22:08:34 <Cale> Well, I didn't write a patch
22:09:01 <ivanm> Jafet: huh, would that be better off than m `M.intersection` (M.fromAscList . map (flip (,) ()) . S.toAscList $ s) ?
22:09:47 <Jafet> Well, I'm not a walking Criterion.
22:09:57 <ivanm> awwwwwwww!
22:10:14 <Jafet> (I'm very sedentary.)
22:10:14 <ivanm> OK, the patch was for differenceKeysSet
22:10:19 <ivanm> which isn't what I'm after anyway
22:10:46 <Jafet> Use Map k Void!
22:10:52 <ivanm> heh
22:11:04 <ivanm> so, map (flip (,) undefined) then?
22:11:14 <ivanm> (since IIRC, you can't create a Void value)
22:11:33 <Jafet> Oh, hm, *AscList is indeed probably more efficient
22:13:11 <ivanm> hmmm..... your way is O(n*log m)
22:13:39 <ivanm> mine is O(n + m)
22:14:34 <ivanm> so yeah, using ascList is probably better
22:15:14 <ivanm> no, wait
22:15:27 <ivanm> gah, I've just managed to confuse myself :s
22:15:39 * Jafet waits.
22:17:52 <ivanm> no, yes, O(n+m) is < O(n*log m) for m < n
22:19:22 <ivanm> I know that the set is a subset of the keys of the map
22:21:11 <kofman> was haskell written by mathematicians for mathematicians
22:22:26 <ivanm> kofman: it was written by computer scientists for computer scientists
22:22:38 <ivanm> so if you consider CS to be a sub-set of mathematics, then yes
22:22:44 <Cale> And computer scientists are a *kind* of mathematician
22:22:51 <shachaf> @quote kmc mathematicians
22:22:51 <lambdabot> No quotes match. You type like i drive.
22:22:55 <shachaf> ?
22:22:58 <ivanm> Cale: what kind? * ? * -> * ?
22:22:58 <ivanm> :p
22:23:06 <ivanm> @quote kmc math
22:23:07 <lambdabot> kmc says: it's important to show that Haskell is usable not just for useless maths, but also for real-world tasks such as rendering teapots
22:23:15 <ivanm> shachaf: ^^ that one?
22:23:21 <shachaf> No.
22:23:25 <ivanm> @quote kmc math
22:23:26 <lambdabot> kmc says: if a math paper is not written using LaTeX, it might as well be written with crayon
22:23:30 <ivanm> @quote kmc math
22:23:30 <lambdabot> kmc says: programming is inherently mathematical.  furthermore, the connection between haskell and maths is overblown by people who don't understand the language
22:23:45 <shachaf> @remember kmc Haskell isn't really designed by mathematicians. it's designed by people who programmers would consider to be mathematicians and mathematicians would consider to be programmers
22:23:46 <lambdabot> It is stored.
22:24:15 <kofman> i'm a C programmer, it was my first impression of the language
22:24:40 <shachaf> kofman: Well, clearly, by the above quote.
22:24:40 <ivanm> kofman: it's more that we're not ashamed of recognising the mathematical underpinnings of our programming
22:25:13 <ivanm> and it does tend to make mathematical programming nicer
22:26:13 <kofman> I just realized I haven't seen what a loop looks like in haskell
22:26:29 <ivanm> kofman: we don't have them as recognised in C, etc.
22:26:31 <shachaf> kofman: Usually it looks like recursion.
22:26:38 <shachaf> In one form or another.
22:26:40 <kofman> what does network code look like then?
22:26:43 <shachaf> Often it looks like a list.
22:26:45 <ivanm> we use either a higher-order function that does something similar, or directly recurse
22:26:54 <ivanm> kofman: like code...
22:27:04 <ivanm> @src sum
22:27:05 <lambdabot> sum = foldl (+) 0
22:27:10 <shachaf> kofman: Depends on the code.
22:27:10 <ivanm> ^^ adding up all numbers in a list
22:27:22 <ivanm> kinda similar to Java's for-each loops
22:27:26 <kmc> :t map
22:27:27 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:27:29 <kofman> I'm scared of all of the sudden
22:27:29 <kmc> @src map
22:27:29 <lambdabot> map _ []     = []
22:27:30 <lambdabot> map f (x:xs) = f x : map f xs
22:27:43 <ivanm> is it possible to define map in Java yet?
22:27:48 <kmc> kofman, read RWH, it has some examples of network code
22:27:49 <kmc> @where rwh
22:27:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:27:58 <Cale> kofman: But it might also look something like  forM [1..10] $ \x -> print x
22:28:06 <kofman> I'll check them out
22:28:12 <shachaf> Or it might look like: forever (print "hello")
22:28:17 <ivanm> last time I tried I had to re-create the list myself, and I couldn't work out if the order was guaranteed so I directly iterated rather than using a for-each loop
22:28:19 <kofman> oh this is amazing thank you
22:28:22 <Cale> kofman: (note that forM isn't a built-in language feature, just a library function)
22:28:23 <kmc> kofman, Haskell has a feature-complete imperative language built in... the "revolutionary" thing is that it supports paradigms other than imperative
22:28:36 <kmc> in fact imperative programs are first-class values which are manipulated by functional programs
22:28:43 <kmc> it's all very cool, but takes some getting used to
22:28:50 <DanBurton> basically, with the power that map, filter, and fold provide, "for loops" start feeling underpowered and crufty in comparison
22:28:58 <kmc> you have to start small, and don't worry about mapping C features to Haskell 1:1
22:29:13 <ivanm> or m:n in general
22:29:20 <ivanm> generally speaking, don't try and see analogues
22:29:22 <kmc> ω:ω
22:29:25 <shachaf> kmc: Sadly they're often awkward, despite what people sometimes say (and despite being perhaps nicer conceptually).
22:29:41 <kmc> it's not perfect
22:29:49 <ivanm> shachaf: what are awkward?
22:29:52 <shachaf> ivanm: If you're translating straight C code with variables to IORefs, say.
22:29:56 <kmc> it takes a lot of learning to get to a point where it seems reasonable at all
22:29:59 <ivanm> oh, right
22:30:04 <shachaf> You can't say if (i < j), you have to say i <- readIORef iV; j <- readIORef jV; ...
22:30:07 <shachaf> Or something.
22:30:09 <ivanm> yeah, don't try and translate code
22:30:17 <kmc> shachaf, if I had to write a lot of code in that style, I'd make a few definitions like (=:) = writeIORef
22:30:20 <kofman> well my world feels very complete. I have a fine understanding of instruction sets -> asm -> c
22:30:22 <ivanm> shachaf: liftM2 (<) i j !
22:30:28 <shachaf> kmc, ivan: Sure.
22:30:43 <kmc> and maybe make / get a preprocessor that implements Habit's monadic case and monadic do
22:30:54 <kofman> in other words there's nothing that c can do that can't be done in asm, and by those standards there shouldn't be anything in haskell that can't be done in asm or therefore c
22:30:56 <kmc> kofman, that's not a complete world at all, on either end
22:30:56 <ivanm> kmc: what's Habit?
22:31:06 <kmc> kofman, of course languages are equivalent in a technical sense
22:31:18 <ivanm> kofman: well, sure, but you would do it completely differently in Haskell
22:31:19 <shachaf> But it still becomes awkward. whenM ((<5) <$> read i) $ modifyIORef j (+) <someapplicativething> read i, etc.
22:31:20 <kmc> languages exist to be used by humans and are easier or harder to use in various ways
22:31:33 <ivanm> (if you actually took a Haskelly approach rather than trying to make a 1:1 code correspondence)
22:31:35 <kmc> kofman, anyway, nobody here is forcing you to learn Haskell, if you're just here to tell us it's useless then you can get out
22:31:36 <Cale> kofman: There are things which are practical to do in C which are impractical to do by flipping bits in a machine by hand.
22:31:47 <kofman> oh I'm here cause I'm curious
22:32:14 <kmc> if you don't know *any* languages higher level than C, you have a really impoverished view of programming
22:32:18 <ivanm> Cale: wait, you mean they developed C for a reason and not just to get people to have to manage memory by hand? :p
22:32:35 <Cale> and there are things which are practical to do in Haskell, which are impractical to do in C (which seems not to stop people from doing them in C anyway)
22:32:55 <kofman> I'm familiar with java, C#, Python, Perl, Objective C, and Ruby
22:33:05 <Jafet> ivanm: but but garbage collection is for academics and dutchmen
22:33:05 <kofman> the latter 2 I really didn't like
22:33:28 <ivanm> Jafet: what about dutch academics?
22:33:40 <kofman> the new standard of C++ comes with garbage collection in the form of smart pointers
22:33:44 <applicative> academics and dutchmen?
22:33:55 <kmc> smart pointers with reference counting?  yeah, that's not true garbage collection
22:34:01 <ivanm> Cale: what would you consider to be practical in Haskell but not C ?
22:34:03 <kmc> it's also super useful
22:34:14 <kmc> ivanm, manipulating strings without causing gaping security holes
22:34:16 <ivanm> (since I haven't done anything not in Haskell for a while so can't really think about anything atm)
22:34:40 <Jafet> Well, ivanm, the only languages before C with garbage collection I know are lisp and algol
22:34:40 <ivanm> kmc: so "practical" is a measure of how safe/easy it is to do something?
22:34:41 <kofman> kmc there are _s functions for string manipulation
22:35:08 <Cale> ivanm: yeah. It's a measure of how easy it is to do a good job, I'd say :)
22:35:27 <ivanm> Cale: so does that make Agda, etc. more or less practical than Haskell? :p
22:35:51 <kofman> this is sort of why I'm here, I'm curious to see how haskell can fit into my tool set for when I'm trying to do task A vs task B
22:36:04 <kofman> I found python to be my language of choice for anything string related
22:36:07 <shachaf> ivanm: It depends on what a good job is.
22:36:15 <Cale> ivanm: Well, there are a lot of things for which it's still harder to do a good job of them in Agda than it is in Haskell.
22:36:31 <kmc> kofman, http://mainisusuallyafunction.blogspot.com/2011/10/slides-from-why-learn-haskell.html here's my overview of interesting features in Haskell and why you should learn the language
22:36:34 <ivanm> is that because of the language or lack of libraries?
22:36:47 <kmc> obviously a slides from a 1-hour talk are not enough to learn anything; it's just a taste
22:37:00 <Cale> ivanm: Probably *mostly* the latter
22:37:11 <Cale> ivanm: Though I don't really know Agda well enough to say
22:37:15 <ivanm> kofman: OK, consider this: with Haskell, you get a similar typing system where you don't declare variables, they're inferred for you, etc. but it's _static_ and hence it checks that you're not trying to add a String to an Int
22:37:27 <ivanm> (compared to Python)
22:38:05 <shachaf> Type checking and type inference are somewhat blurred together in my head.
22:38:07 <kmc> there ought to be a better answer to "why learn Haskell / what is it good for" than the 5 people who happen to be in the channel typing out their own prepared speeches from memory
22:38:17 <ivanm> heh
22:38:24 <shachaf> True.
22:38:28 <shachaf> @where why
22:38:28 <lambdabot> I know nothing about why.
22:38:39 <edwardk> type checking: someone wrote a type down, is it correct?    type inference: what is the type would this code have?
22:38:54 <shachaf> edwardk: Sure, sure, I understand the difference.
22:39:08 <kmc> kofman, see also http://haskell.org/haskellwiki/Introduction and http://haskell.org/haskellwiki/FAQ#The_real_world and http://www.cs.utexas.edu/~shmat/courses/cs345/whyfp.pdf
22:39:14 <ivanm> @faq Does using Haskell let me develop stuff faster, more easily and with more guarantees than any other language?
22:39:14 <lambdabot> The answer is: Yes! Haskell can do that.
22:39:21 <edwardk> type inference is "why we can't have nice things" in Haskell ;)
22:39:22 <shachaf> I just think of them as being more similar than I did previously.
22:39:48 <kmc> it's not faster *and* more easily *and* more guarantees than *every* language
22:39:51 <ivanm> edwardk: well, don't we have type inference?
22:39:54 <kmc> but it's a remarkably good balance between those
22:39:57 <shachaf> ivanm: Guarantees like guaranteeing to shoot your foot off?
22:40:03 <ivanm> or do you mean "why can't we do stupid stuff" ?
22:40:04 <edwardk> ivanm: no the problem is we do, and that we want to keep it ;)
22:40:05 <shachaf> ivanm: Right, and therefore we don't have nice things.
22:40:08 <ivanm> shachaf: right
22:40:21 <ivanm> (to the guarantees)
22:40:50 <edwardk> ivanm: without it you can write all sorts of crazy cool things, with it, it takes a lot less code to write the smaller set of things we _can_ write (for the most part, there are notable exceptions)
22:41:02 <ivanm> kmc: so, are you proposing we once-again re-word the pitch at the top of haskell.org to make it more buzz-word friendly?
22:41:05 <Jafet> shootFoot:: IO (Either SomeException ())
22:41:12 <kmc> no
22:41:22 <ivanm> or just have something extra we can pull out?
22:41:32 <shachaf> Maybe SomeException?
22:41:40 <ivanm> some agreed-upon and concise "Why Haskell" page?
22:41:45 <kmc> i'm proposing that we could write about these things, and refine those documents to the point where they can be linked to
22:41:50 <ivanm> rather than every re-hashed set of slides someone does?
22:41:52 <kmc> and furthermore this has been done or at least attempted several times
22:42:02 <ivanm> s/several/many/
22:42:15 <kmc> there's a lot of common questions which should have nice polished answers
22:42:21 <kmc> "why is Haskell good", "what is monad", etc.
22:42:23 <Jafet> Just e <- shootFoot
22:42:23 <shachaf> kmc: I expect that you don't see all the people who look up "why should I learn Haskell", find an answer, and then don't join the channel until they've already learned some. :-)
22:42:37 <kmc> but instead, asking one of these questions whips the entire channel into a frenzy
22:42:48 <kmc> everyone pounding out their own half-baked explanation as quickly as possible
22:42:48 <ivanm> /join #why-haskell
22:42:58 <kmc> and usually the original question asker gets bored
22:43:04 <kmc> and the frenzy persists
22:43:09 <Cale> Probably because everyone's answer to why Haskell is good is a bit different
22:44:22 <applicative> and kofman seems to have his particular expertise and interests; it looks like remarks were fitted to his case.
22:44:39 <kmc> I do this too, but I've been trying harder to save things
22:44:52 <shachaf> Haskell is good because kmc rants is in #haskell.
22:44:55 <dolio> Haskell is good for writing programs. Done.
22:45:12 <kofman> i'm actually a game developer by trade, so while I certainly see the value of a functional programming language like haskell in say writing a camera system
22:45:21 <ivanm> #haskell: where we smother you with helpfulness!
22:45:41 <ivanm> kofman: hmmm, there have been some games written in Haskell
22:45:50 <Cale> kofman: Cool, I'm working for a startup, and we're writing a game in Haskell :)
22:45:59 <kofman> it's hard to imagine at the moment at least what complex systems may look like ... for instance a state machine
22:45:59 <ivanm> that well-known game guy said Haskell had good features, but isn't quite the right language at this time to replace C++
22:46:06 <kmc> Cale, when's the expected release date?
22:46:16 <shachaf> Will it be iPhone-only?
22:46:17 <Cale> kmc: I'm not sure
22:46:18 <ivanm> and FRP looks like it might be feasible in future for this kind of stuff
22:46:25 <Jafet> Don't you need a PhD to write games in Haskell?
22:46:29 <ivanm> Cale: are you actually anywhere close to getting an app to the iPhone yet?
22:46:32 <Cale> shachaf: It'll be iPhone first. We hope to support other platforms.
22:46:43 <kmc> kofman, I don't think you'll find an example of a state machine in Haskell to be particularly enlightening if you're just starting to learn
22:46:47 <ivanm> Jafet: Cale is a ringer they get, don't tell people though or they'll have to fire him!
22:47:05 <Cale> what?
22:47:20 <kmc> kofman, you have to learn (and re-learn) a ton of things before Haskell looks like it could be useful for anything
22:47:43 <Cale> Jafet: Yeah, I only have a BMath
22:48:05 <Jafet> ...well, will you get a PhD before completing the game?
22:48:13 <Cale> No :)
22:48:21 <Cale> Maybe after? :)
22:48:48 <novodinia> what's an atomic value?
22:48:57 <kmc> can you give us some context?
22:49:08 <Jafet> Only if the game is timeless.
22:49:33 <novodinia> "examples of expressions include atomic values such as the integer 5, the character 'a', and the function \x -> x+1...
22:49:42 <kmc> where's that from?
22:49:42 <ivanm> Cale: so, I think I've got a generic way of doing either a DFS or BFS based traversal for my planar graph library, and can use it to get the connected components; in that use-case, does it matter which traversal I use in your opinion?
22:49:55 <Cale> novodinia: Things which can't be broken into smaller parts
22:50:02 <ivanm> novodinia: link/source ?
22:50:03 <novodinia> Cale: ty
22:50:10 <kmc> novodinia, I think the sentence will be just as useful if you pretend the word "atomic" isn't there
22:50:25 <kmc> (I'm not sure whether they're trying to say functions are atomic, or aren't)
22:50:42 <ivanm> can't \ x -> x + 1 be broken up into (+) and the integer 1 ?
22:50:56 <Cale> ivanm: Well, not by pattern matching ;)
22:51:02 <ivanm> true
22:51:16 <Cale> ivanm: I don't have an opinion on whether you use BFS or DFS, but I'm not a graph algorithms expert.
22:51:28 <ivanm> you're not? :o
22:51:30 <ivanm> :p
22:51:42 <ivanm> there are probably more efficient ways of doing it, but eh
22:51:48 * quicksilver is stunned. \exists foo . Cale is not <foo> expert?
22:52:03 <ivanm> I've spent all this time making my traversing stuff extensible, so I might as well make use of it!
22:52:15 <ivanm> even though all I want it for is to be able to do a BFS-based relabelling of a graph...
22:52:50 <Jafet> Planar graph? You can just walk around the outsides of the connected components
22:53:01 <Cale> Scumbag torrents. Download 99.99% of the file in 2 minutes, spend 30 minutes on the last piece.
22:53:09 <ivanm> Jafet: to do a relabelling?
22:53:17 <ivanm> Cale: ugh
22:53:21 <Jafet> No, to find the connected components.
22:53:27 <ivanm> though I question why you're downloading scumbags... :p
22:53:44 <ivanm> Jafet: oh, right...
22:54:05 <Cale> http://knowyourmeme.com/memes/scumbag-steve
22:54:07 <ivanm> yeah, my face-finding code assumes it's a single component
22:54:30 <ivanm> Cale: apparently that's one way RIAA, etc. track who's downloading stuff they shouldn't
22:54:42 <ivanm> by having torrents that don't finish and tracking IPs of who gets them
22:54:51 <ivanm> (or try to, anyway)
22:55:02 <kmc> and Cale was never heard from again
22:55:31 <ivanm> Jafet: but to be able to use that approach to find connected components, you need to know which edges are _on_ the outer face of each component
22:55:42 <Cale> I'm fairly sure that it's just that my client sucks at the endgame.
22:55:45 <ivanm> and I'm working on the unit sphere rather than the unit disc
22:55:51 <ivanm> Cale: which client?
22:55:58 <Cale> Deluge
22:56:03 <Jafet> Okay, 3D graphs are very different from 2D ones
22:56:14 <Jafet> Oh, it's still 2D
22:56:14 <ivanm> Cale: never had any problems with them...
22:56:17 <ivanm> Jafet: yeah, just on the sphere
22:56:29 <ivanm> well, I suppose there's no reason why you can't treat it as being on the disc
22:56:37 <ivanm> but there's no indication in the implementation of "outer face"
22:56:48 <Jafet> I have no idea; it might fail for some corner cases
22:57:19 <ivanm> so I'm not quite sure what happens about getting the dual of a graph with more than one component
22:57:44 <ivanm> (in my current implementation)
22:58:11 <ivanm> I think as it stands, you'll get two "outer face" nodes, and they'll remain unconnected
22:58:24 <Cale> I also have a feeling that there are torrent clients out there which try not to give other peers their last piece (because that would finish the file, and lots of people disconnect after that)
22:58:44 <ivanm> ugh
22:58:59 <jix_> copumpkin: IIRC I did... but I only implemented the minimum I needed and it wasn't pretty I think there are better splay tree implementations in haskell by now
22:59:07 <ivanm> Cale: though I thought that by the protocol, if you don't have a high share ratio you'll be shoved down the queue
22:59:58 <copumpkin> ah
23:00:13 <Cale> ivanm: I'm pretty sure it only uses very local information about that in general.
23:00:20 <ivanm> I think I heard of a new splay tree implementation recently...
23:05:34 <hatomic> running "ghc --make my-app.hs $(wx-config --libs std,stc)" inside a bash shell, as suggested in http://www.haskell.org/haskellwiki/WxHaskell/Building_with_styledTextCtrl_support returns "ghc.exe: unrecognised flags: -mthreads", which is the first thing wx-config spits out. This inside a bash shell. What am I doing wrong now?
23:05:56 <kmc> what do you get from the wx-config command by itself
23:06:00 <Cale> hatomic: Oh, you're using bash on windows?
23:06:06 <hatomic> yes
23:07:40 <hatomic> wx-config alone shows the usage help. wx-config --libs shows  -mthreads -LC:\Dev\Lib\wxWidgets\lib\gcc_dll -lwxmsw28u_stc -lwxmsw28u -lwxtiff -lwxjpeg -lwxpng -lwxzlib -lwxregexu -lwxexpat -lkernel32 -luser32 -lgdi32 -lcomdlg32 -lwxregexu -lwinspool -lwinmm -lshell32 -lcomctl32 -lole32 -loleaut32 -luuid -lrpcrt4 -ladvapi32 -lwsock32 -lodbc32
23:07:52 <Cale> that's not usage help
23:08:10 <Cale> that's the specific flags which would normally be spliced into that ghc command
23:08:23 <kmc> hatomic, so try those flags without -mthreads
23:08:25 <Cale> though I don't think -mthreads works
23:08:54 <Cale> (GHC doesn't recognise that)
23:09:13 <Cale> the rest of them are possibly fine though
23:09:15 <hatomic> is there a way to pass it manually?
23:09:31 <Cale> yeah, just type all that stuff at the end of the GHC command in place of the $(...)
23:09:42 <kmc> preferably copy-paste ;)
23:09:54 <ivanm> kmc: copy-paste-edit !
23:09:57 <Cale> $(command) means to run command and splice its output into the commandline where it occurs
23:12:23 <hatomic> There is one more problem. Linking styledTextCtrl.exe ... and then it produces "undefined reference to" errors. I think the STC installation is not good.
23:14:51 <hatomic> I installed wxPack 2.8.12. It worked fine. The only thing missing is styledTextCtrl. So I followed the steps on the haskell wiki and built wxwidgets\contrib\build\stc. However, I don't know if this is the right thing to make it work. Any hints?
23:15:17 <ivanm> Jafet: going back to using your suggestion on using outer face traversal to determine connected components: to split the graph up, wouldn't you then need to do some form of traversal to get the actual sub-graph that makes up each component?
23:38:07 <solidsnack> Is anyone here familiar with algorithms to construct a string that is not a substring of a given string, yet is not "too" long?
23:38:59 <ivanm> solidsnack: not off the top of my head; what for?
23:39:22 <solidsnack> Say you want to construct a HEREDOC delimiter for a string handed to you as input...
23:39:39 <solidsnack> You need to create a string that does not appear in the input string.
23:40:32 <kmc> i expect something fairly dumb, which uses a decent string search, will perform just fine
23:41:16 <ivanm> yeah
23:41:25 <kmc> you have a (possibly empty) candidate string
23:41:36 <kmc> you search for it, find the set of all next characters
23:41:36 <solidsnack> Aye.
23:41:47 <solidsnack> I see.
23:41:49 <ivanm> another alternative: get all the sub-strings of length n
23:41:58 <ivanm> then generate a random string of length n and check if it's there
23:42:21 <solidsnack> Sure but then I've got to thread randomness.
23:42:49 <ivanm> Supply monad?
23:43:05 <Sgeo|web> Thought: List monad
23:43:13 <kmc> Thought: List
23:43:16 <kmc> (of random numbers)
23:43:22 <Sgeo|web> For each character in the string, put in a list of characters that aren't that character
23:43:41 <ivanm> kmc: just call randoms to get an infinite list of random Chars?
23:43:43 <Sgeo|web> Wait, no
23:43:45 <kmc> yeah
23:43:48 <solidsnack> Say the string is very, very long -- like 4 megabytes.
23:43:51 <Sgeo|web> That's "all strings that aren't the given string"
23:44:24 <Sgeo|web> What's the minimum time complexity that this can be done in anyway?
23:44:28 <ivanm> solidsnack: construct a lazy trie
23:44:38 <solidsnack> ivanm: Yes, this was an idea.
23:44:52 <solidsnack> Now you have the trie. How does the search go?
23:44:55 <ivanm> and then get some weird prefix and append it onto a list of random chars
23:45:09 <solidsnack> Weird prefix?
23:45:16 <ivanm> keep going through the trie matching your infinite list and until you find the first char that doesn't have a match in the trie
23:45:47 <laziest> solidsnack: how about just picking a substring of input of desired length, adding 1 to each character, and using it after checking it for substring?
23:45:48 <ivanm> (the weird prefix is just to try and cut down how much into the trie you have to go in; e.g. if it's English text, start with zzzz or something)
23:46:03 <ivanm> solidsnack: that way, you're not continually re-searching, you're just going further into existing searches
23:46:37 <ivanm> laziest: with suitable mod'ing/checking for control characters?
23:46:48 <laziest> yes.
23:46:59 <solidsnack> I was hoping to restrict delimiters to be only hex digits, actually.
23:47:50 <laziest> And substring checking can be *very* efficient: see Boyer-Moore algorithm.
23:47:55 <solidsnack> In principle, for a string of length n, I need at most 1 + floor (logBase 16 n) hex digits.
23:47:59 <ivanm> solidsnack: well, just generate your infinite list appropriately then
23:48:14 <solidsnack> laziest: Very efficient is still 3n.
23:48:38 <ivanm> laziest: it still requires completely re-searching; the aim of my approach was that you didn't have to go through the entire string again
23:49:11 <solidsnack> ivanm: I am not sure how that part works, though; how do I avoid re-searching?
23:49:12 <laziest> No, not entire string. If your constructed string is length m, and the original is n, then just n/m.
23:49:32 <solidsnack> laziest: That's a best case figure.
23:49:38 <laziest> Ya.
23:49:51 <solidsnack> Worst case is 3n.
23:50:21 <solidsnack> Hope for the best, plan for the worst :)
23:51:32 <laziest> I am not sure there can exist something which can construct a non-substring without analyzing the original in O(n) time.
23:51:56 <solidsnack> laziest: Well, it's not so much that as doing it n times.
23:52:20 <solidsnack> Say my random supply begins with substrings from the input...
23:52:41 <laziest> Oh, but how likely it is that a random string (or a systematic one, like adding 1 for every character) will be a substring?
23:53:05 <laziest> the likelyhood will go down exponentially with the length of the constructed string.
23:53:13 <Jafet> It depends on m, of course.
23:53:13 <solidsnack> laziest: That's true.
23:53:25 <Jafet> If m is large compared to n, you can do better.
23:53:37 <laziest> Jafet: exactly.
23:53:42 <solidsnack> Well, here n is the length of the input string.
23:53:46 <laziest> yes.
23:53:48 <ivanm> damn, because of one possible corner use-case, I have to choose between possibly storing every value three times rather than two, or else make it sllightly slower :s
23:53:50 <solidsnack> At least, that's how I've been using it.
23:53:52 <solidsnack> What's m?
23:54:02 <Jafet> The length of the non-substring to be constructed.
23:54:26 <solidsnack> Oh. Well, m should be as small as possible.
23:54:40 <laziest> How about m=50?
23:54:48 <Jafet> Then it's trivially O(n).
23:54:54 <Jafet> You may want to look up "antidictionaries"
23:55:18 <laziest> Jafet: but the input can be anything. solidsnack: am I right?
23:55:32 <solidsnack> laziest: Yes, any bytes whatever.
23:56:26 <laziest> I don't think there is anything better than O(n). The input has to be scanned at least once.
23:56:35 <solidsnack> laziest: Right.
23:56:43 <solidsnack> But random supply is N^2.
23:56:56 <solidsnack> Worst case.
23:57:05 <laziest> What's N? same as n?
23:57:10 <solidsnack> Yes, right.
23:57:13 <laziest> and why square?
23:57:31 <solidsnack> Because we do an O(N) operation N times.
23:57:45 <solidsnack> Say our random supply is the substrings in the input.
23:57:54 <solidsnack> Or rather, starts with it.
23:58:01 <solidsnack> This is, I think, the worst imaginable case.
23:58:09 <laziest> Oh, that is being too complicated. Can you not just create any random string?
23:58:26 <solidsnack> It's not complicated, it's simple.
23:58:32 <laziest> I mean complex
23:58:49 <solidsnack> The analysis is simple.
23:58:49 <laziest> no no.
23:58:49 <solidsnack> I just stop at the worst case.
23:58:54 <laziest> I am saying why not just any random string?
23:59:08 <laziest> or systematic?
23:59:18 <solidsnack> I can't control the strings.
23:59:27 <solidsnack> So, they are set by an adversary.
23:59:28 <laziest> no, I am talking about the delimiter strings.
23:59:50 <solidsnack> The random supply I can't set either, though.
23:59:59 <solidsnack> It's random...so it comes from the adversary...
