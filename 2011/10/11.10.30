00:05:35 <kmc> perhaps the narrower question "who is running Haskell on multi-core ARM pre-v6"
00:07:00 <copumpkin> oh, I vaguely remember there being an old unregistered build of GHC for some linux arm distro
00:07:20 <kmc> there's an unreg'd GHC in current debian-armel
00:08:21 <copumpkin> so I guess they were doing shit like that to support threading on a single-core machine
00:08:22 <kmc> does that mean the MVar locking performance on debian-armel will always suck? because debian's a binary distro and will build conservative packages?
00:08:38 <copumpkin> probably
00:08:49 <kmc> sux
00:08:59 <kmc> this is probably the #1 thing holding back Haskell in The Enterprise
00:09:03 <copumpkin> at least until this latest push to make arm a first-class platform in GHC goes mainstream
00:09:08 <kmc> *nod*
00:09:09 <copumpkin> like totally
00:09:14 <kmc> well the code to do better locking on newer ARM is already there
00:09:28 <kmc> you just need to certify that you won't run the code on pre-ARMv6
00:09:33 <kmc> and that's done when you compile GHC
00:09:51 <copumpkin> yeah
00:10:05 <copumpkin> but what about all the mote users out there!?
00:10:10 <copumpkin> I need haskell on my motes
00:10:16 <kmc> wtf is a mote
00:10:31 <copumpkin> http://en.wikipedia.org/wiki/Sensor_node
00:10:56 <kmc> mmm yes
00:10:58 <kmc> mote clouds
00:11:39 <copumpkin> I used to play with them sometimes for my advisor
00:11:49 <copumpkin> had little 400mhz arm cpus with linux
00:12:01 <kmc> the highest tech way to answer the question "who farted in the lab"
00:12:16 <copumpkin> the fart sensor cost extra
00:12:17 <kmc> mesh network of explosive gas sensors
00:12:41 <copumpkin> besides, everyone already knew who farted in the lab
00:12:45 <copumpkin> cause it was always this one guy
00:13:06 <kmc> haha
00:13:09 <kmc> proof by prior distribution
00:14:47 <kmc> yeah debian armel has ghc-7.0.4
00:15:16 <kmc> (in unstable)
00:16:30 <copumpkin> ah
00:30:20 <dmwit> It's official: virtual machines are awesome.
00:30:30 <handonson> Is it possible to get the command line arguments as ByteStrings?
00:32:12 <dmwit> No, but you can get them as Strings and pack them.
00:32:12 <ddarius> pack them
00:32:17 <dmwit> Or encode them.
00:32:25 <handonson> Damn.
00:32:29 <handonson> I see.
00:33:15 <kmc> that won't give you the actual bytes passed by the operating system
00:33:27 <handonson> Huh.
00:34:07 <handonson> I guess it depends on what OS it is
00:34:10 <dmwit> getArgs seems to do the Right Thing here -- it gives me ["\8592"] when I pass a ← as the first argument.
00:34:26 <kmc> which ghc? some of that stuff changed in 7.2
00:34:56 <kmc> handonson, one (cumbersome) solution is http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#using-own-main
00:35:15 <handonson> iirc the handling of FilePath also differs on different OSs
00:37:14 <dmwit> Indeed, it may even differ between file systems on a single OS.
00:37:30 <dmwit> Isn't that lovely?
00:40:23 <handonson> kmc: I'd love to use that kludge solution for now
00:40:32 <handonson> Will it cause any overhead by any chance?
00:40:43 <kmc> don't think so
00:41:51 <handonson> Aww, but I'm too ignorant to understand that document directly. I've never really used FFI except some Ptrs for OpenGL.
00:42:19 <ddarius> There's a cure for ignorance.
00:43:41 <kmc> documents!
00:44:04 <kmc> handonson, we can help
00:44:06 <ddarius> There isn't a cure for knowledge, so tread carefully.
00:44:14 <kmc> alcohol?
00:44:19 <copumpkin> time cures all knowledge
00:45:13 <ddarius> "Take this pill.  You'll feel better in 200 years."
00:45:14 <kmc> i've never made a Haskell program with a C man, but I've made Haskell libraries which are called from Java, which is like... the same thing but worse
00:45:31 <kmc> C main*
00:46:35 <ddarius> @google site:hackage.haskell.org automata
00:46:36 <lambdabot> http://hackage.haskell.org/packages/archive/compdata/0.4.1/doc/html/Data-Comp-Automata.html
00:46:37 <lambdabot> Title: Data.Comp.Automata
00:47:31 <ddarius> Implicit parameters...
00:47:34 <handonson> I assume the idea is, to write something like main.c, pass the char *argv[] to haskell with FFI, and change the project cabal file to pass certain flags to ghc... Is that right?
00:47:51 <kmc> sounds about right
00:48:30 <handonson> What document should I be looking at to learn how to do this?
00:49:13 <handonson> Are char[] and ByteString easily exchangeable?
00:49:18 <ddarius> Yes.
00:49:44 <ddarius> Not trivially, though.
00:50:41 <ddarius> @hoogle packCString
00:50:41 <lambdabot> Data.ByteString packCString :: CString -> IO ByteString
00:50:41 <lambdabot> Data.ByteString.Char8 packCString :: CString -> IO ByteString
00:50:41 <lambdabot> Data.ByteString packCStringLen :: CStringLen -> IO ByteString
00:53:35 <handonson> I'm re-reading the FFI chapter of RWH, but it doesn't seem to cover calling Haskell functions in C
00:54:35 <handonson> or calling Haskell code at all
00:55:16 <ddarius> @where ffi
00:55:16 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
00:55:18 <ddarius> Read that.
00:56:00 <handonson> Cool
01:18:58 <augur> i wonder why haskell doesnt have _ for type variables
01:27:47 <Saizan> when haskell was born types were supposed to be inferrable :)
01:28:17 <augur> Saizan: well no what i mean is
01:28:30 <augur> _ -> a -> _ would just be b -> a -> c
01:28:45 <augur> theyd just be type variables as usual
01:29:08 <augur> but would emphasize the irrelevancy of the type
01:29:16 <augur> not for any real purpose other than visual emphasis
01:29:20 <ddarius> That case rarely comes up.
01:29:25 <augur> i suppose
01:29:57 <augur> i just saw the discussion on reddit about heterogeneous lists and someone had the type (a, (b, (c, d))) -> c for their third function
01:30:12 <augur> and it just struck me how much more readable itd be as (_, (_, (a, _))) -> a
01:30:58 <ddarius> Consider how much better it would be in Miranda.
01:31:07 <augur> (tm)
01:31:10 <augur> i dont know miranda
01:31:27 <augur> unrelatedly, are there any commonly used VMs thats nice for functional languages?
01:31:42 <applicative> @type let f  (_, (_, (a, _)))  = a in f
01:31:43 <lambdabot> forall t t1 t2 t3. (t, (t1, (t2, t3))) -> t2
01:32:11 <applicative> the signature is not the best documentation in this case, it seems true
01:33:08 <Saizan> (*,(**,(***,(****)))) -> ***
01:33:40 <applicative> is that the Miranda signature?
01:37:58 <applicative> If a language has type inference, why not name it after the Miranda rule: "You have the right to remain silent; anything you say can and will be held against you..."
01:38:34 <kmc__> haha
01:39:02 <kmc__> UHC has an extension like that augur
01:39:05 <kmc__> iirc
01:39:07 <kmc__> partial type signatures
01:39:20 <kmc__> but they can do more
01:39:32 <augur> hm
01:40:14 <kmc__> basically it lets you introduce unification variables in addition to the quantified variables
01:41:09 <kmc__> so i can write «($) :: ?t -> ?t;  f $ x = f x»
01:41:14 <kmc__> (making up the syntax because i forgot what it is)
01:41:34 <kmc__> ?t is unified with (a -> b) to give the expected type signature (a -> b) -> (a -> b)
01:41:35 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
01:41:41 <kmc__> lambdabot ;P
01:42:17 <kmc__> whereas «t -> t» implicitly universally quantifies the t, and that implementation is too specific
01:42:35 <kmc__> they're kind of like the "existential variables" in Coq, but not very much like existential quantification in GHC Haskell I think, but I'm not sure
01:44:02 <kmc__> «f :: ?t -> Maybe ?t; f n = Just (n+1)»
01:44:27 <Saizan> if you were expressing the typing problem formally they'd be existentially quantified in the meta-language
01:45:28 <kmc__> anyway I think this is cool, because type signatures are machine-checkable documentation, but sometimes you only want to document certain parts and not other irrelevant clutter
01:45:58 * hackagebot openid 0.2.0.0 - An implementation of the OpenID-2.0 spec.  http://hackage.haskell.org/package/openid-0.2.0.0 (TrevorElliott)
01:46:08 <Saizan> yeah, and it's also quite cheap to implement
01:46:10 <kmc__> also useful when a small part of a signature is needed to resolve ambiguity
01:47:45 <kmc__> cheap because you're doing unification anyway?
01:47:55 <Saizan> yeah
01:49:47 <kmc__> but i guess what augur proposed is different
01:49:59 <kmc__> because each underscore would be a fresh quantified variable, not a fresh unification variable
01:50:17 <augur> VMs for functional languages?
01:52:00 <kmc__> to what degree do you emphasize "VM" versus "shared compiler backend"
01:52:05 <Saizan> i suspect augur meant _ to work like in agda, i.e. the latter
01:52:39 <kmc__> there's http://www.cs.st-andrews.ac.uk/~eb/epic.php
01:52:44 <augur> kmc__: like Java VM but for functional languages. lots of people compile imperative languages to the Java VM, but is there any equivalent for functional languages?
01:52:59 <kmc__> lots of people compile functional languages to the Java VM
01:53:05 <kmc__> it's not pretty though
01:53:21 <k0ral> hi, I'm working with Dyre, so that my application can be configured in haskell; moreover, I made some optional extra modules the user can decide to include or not; these modules work with some parameters, and I'd like to allow the user the change them through the haskell configuration file, how can I do ?
01:53:30 <kmc__> for this conversation to get anywhere you'll have to define "functional language", and that usually triggers a bunch of pointless discussion
01:55:20 <ddarius> "functional language" = [Haskell]
01:55:40 <kmc__> yeah that's a popular definition
01:55:54 <companion_cube> on #haskell
01:56:35 <companion_cube> you shoud write "functional language = Just Haskell"
01:56:43 <kmc__> does anyone know if CIL supports tail calls and such things better than JVM?
01:57:26 <ddarius> I believe the 64-bit CLR always optimized tail calls.  There is also a tailcall operation, but I heard (vaguely) that it is actually slower than a normal call.
01:57:36 <kmc__> Epic looks like a rather pleasant language, maybe I should use it
01:57:40 <kmc__> who needs type checking
01:57:41 <ddarius> (But it should still have better space behavior.)
01:57:51 <ddarius> Certainly not Epigram.
01:59:32 <kmc__> is it using conservative garbage collection? :/
02:00:24 <ddarius> It's using the Boehm GC.
02:00:52 <kmc__> does it somehow communicate to the gc which words might be heap pointers?
02:01:03 <kmc__> i don't remember if boehm supports that
02:05:23 <ddarius> kmc__: Looking at the code, I'm pretty sure it isn't doing anything like that.
02:05:35 <kmc__> :/
02:06:39 <kmc__> i wonder how it handles this "lazy" annotation
02:07:36 <ddarius> Maybe I'm wrong.  Let me check some more.
02:17:03 <ddarius> kmc__: I'm going to say it currently doesn't communicate this to the Boehm GC, but it looks like the Boehm GC is just a stop-gap.
02:17:29 <kmc__> *nod*
02:18:07 <kmc__> i don't know the language well enough to know whether it lets you hide pointers where a generic Epic garbage collector would not find them
02:20:03 <kmc__> is this Int type boxed or unboxed?
02:20:38 <kmc__> is there documentation of the language, as opposed to how to run the compiler?
02:21:58 <handonson> There's a { f :: IO () } that does some I/O with the stdio in the Haskell code, and main.c calls it.
02:22:25 <handonson> "./Main > output" (where ./Main is the compiled Haskell code) works fine
02:22:51 <handonson> but "./main > output" (where ./main is the compiled C code) doesn't write anything to "output."
02:23:01 <handonson> The weird thing is, "./main" works.
02:23:07 <handonson> I can see the output in the terminal.
02:23:26 <ddarius> kmc__: I would highly expect the Int to be unboxed.
02:23:41 <ddarius> In fact, why would it be boxed?
02:24:44 <handonson> But "./main > output" doesn't write (although it does touch the file, resulting in an empty output file)
02:25:03 <handonson> How on earth can this happen?
02:25:34 <kmc__> buffering.
02:25:34 <kmc__> handonson, is your code calling hs_exit?
02:25:50 <handonson> Yes
02:26:34 <handonson> Oh, buffering? So the output is somehow not flushed when the program exits?
02:26:49 <kmc__> *nod*
02:26:51 <handonson> That's odd.
02:26:56 <handonson> But makes sense.
02:27:05 <handonson> How do you flush it?
02:27:26 <kmc__> in general programs can detect whether stdout is a terminal (man 3 isatty) and do arbitrarily different things
02:27:46 <kmc__> for example 'ls' usually uses multiple columns but 'ls | cat' will not
02:28:01 <kmc__> one common behavior is to change buffering
02:28:11 <kmc__> line buffering for terminals, large blocks for other files
02:28:18 <ddarius> Industry Standard Architecture TeleType
02:28:44 <kmc__> handonson, it should be flushed when the GHC RTS shuts down, which is why I'm wondering if hs_exit is being called
02:28:46 <kmc__> can you hpaste your code?
02:28:59 <handonson> Sure. Hold on a second.
02:30:19 <hpaste> handonson pasted “The C code calling some Haskell code” at http://hpaste.org/53307
02:31:17 <hpaste> handonson pasted “The Haskell code that gets called” at http://hpaste.org/53308
02:32:08 <augur> ddarius: what's the simplest type system that is undecidable?
02:34:26 <kmc> handonson, what's your compiler command line
02:34:39 <handonson> kmc: the Haskell code reads with Data.ByteString.getContents, and writes with Data.ByteString.putStr
02:34:43 <handonson> Uhm...
02:35:18 <handonson> ghc --make -no-hs-main -optc-O main.c XM -o main
02:35:43 <handonson> This was the command I used to compile it
02:35:54 <kmc> yeah, I get the same behavior
02:36:08 <kmc> the workaround is to do «hFlush stdout» at the end of main
02:36:29 <handonson> aw.
02:36:52 <handonson> Is it possible to do that on the C side?
02:38:09 <kmc> i think not easily, as the buffering is done by GHC
02:38:23 <handonson> Isn't this a bug?
02:38:34 <kmc> i think fflush(stdout) will not help, but you could try
02:38:36 <kmc> handonson, seems so
02:38:38 <ddarius> kmc: You could simply export another function that does hFlush stdout.
02:38:44 <kmc> well yeah
02:39:14 <handonson> Where should we file this bug
02:39:14 <kmc> handonson, you should see if it's in the ghc bugtracker already, and if not, report it
02:40:41 <kmc> http://hackage.haskell.org/trac/ghc/
02:44:06 <k0ral> I can't get the purpose of the reader monad: it's supposed to hide the shared parameters, but I end up writing runReader _ parameters everywhere
02:44:25 <k0ral> could anyone enlighten me ?
02:44:37 <dobblego> k0ral: do you have example usage code?
02:44:38 <ddarius> Use ask.
02:45:12 <ddarius> And/or you're doing it wrong.
02:45:13 <k0ral> ddarius: I use ask, that's my point actually: without the reader monad, I passed the parameter as argument, now I have to write both runReader _ parameters, and then ask parameter
02:45:44 <ddarius> Then you're doing it wrong.
02:46:12 <k0ral> what's the right way ?
02:46:58 <ddarius> To not use runReader more than once.
02:48:29 <k0ral> are you suggesting I wrap all my code with a single runReader ?
02:48:48 <ddarius> That's how it should normally be.
02:49:07 <k0ral> hmmm
02:49:21 <ddarius> It sounds like you are not using the reader monad as a monad.
02:49:34 <dobblego> let's see the actual code
02:49:44 <k0ral> I guess I'm not since I never compose the functions
02:50:14 <k0ral> my aim is to hide the parameters, I'm tired of passing them to each function
02:50:50 <k0ral> dobblego: the actual code is quite "big", I'd better tell you what it is doing
02:50:51 <ghosting> Anybody know where I could find out about different methods of core dumping?
02:51:15 <ghosting> I wanna try it in haskell
02:52:05 <k0ral> dobblego: I have a bunch of functions related to a given feature of my application, and I map some keys to these functions
02:52:35 <k0ral> this given feature has specific parameters I want to share to this bunch of functions, and only to these ones
02:52:40 <dobblego> we can't fix your code if we can't see it -- ddarius can only give you hints like he has
02:53:26 <k0ral> dobblego: fine then, I'm pasting it
02:58:30 <handonson> http://hackage.haskell.org/trac/ghc/register The CAPTCHA is too difficult for a human being. I just failed twice.
02:58:46 <Cale> rolltop
02:58:56 <handonson> Especially hard for people who are not familiar with cursive Roman characters.
02:59:04 <Cale> oh, it's easy if you are...
02:59:49 <Cale> If it helps, they all seem to be English words.
03:00:36 <ddarius> handonson: Perhaps run an OCR script on it.
03:01:48 <kmc_> http://i.imgur.com/1R7gk.png
03:01:54 <handonson> ddarius: Hahaha... to completely contort the purpose, huh?
03:02:26 * ddarius is not sure what blind people are supposed to do.
03:02:27 <hpaste> koral pasted “Shared environment ?” at http://hpaste.org/53309
03:02:57 <k0ral> dobblego: http://hpaste.org/53309
03:04:04 <k0ral> dobblego: my goal is to allow the user to change some parameters of all the functions, without having to pass every parameter to every function
03:05:13 <k0ral> as parameters I mean e.g. the directory where to store bookmarks, the dmenu options
03:16:53 <luite> is there a way to make monad-control bracketing functions not lose side-effects somehow (or a different package with similar functionality but without this limitation?)
03:22:43 <handonson> kmc__: searched, couldn't find, so filed. http://hackage.haskell.org/trac/ghc/ticket/5594
03:23:16 <handonson> :(
03:28:54 <angstrom> how'd I match a range of occurrences with Parsec? like egrep's {n,m}, that is.
03:29:11 <Saizan> luite: how do they lose side-effects?
03:33:02 <luite> Saizan: the pre/post actions lose any non-IO side effects
03:37:10 <luite> Saizan: there are other limitations, like that it looks impossible to make a valid instance for monad transformers like Iteratee
03:37:11 <Saizan> mh, monad-control seems less sane than i'd have expected
03:38:03 <Saizan> i expect some monad transformers to be hard to embed into IO too
03:39:17 <luite> yes that's the problem... anyway the result is just that exception handling in a more complicated application just sucks and i have no idea how to fix it....
03:40:07 <Saizan> tried with MonadCatchIO-* ?
03:42:14 <luite> not yet, but the library wheren I'm running into this problem has switched from MonadCatchIO to monad-control because it had problems with the former, leaking resources (which sounds exactly like finalizers not being run properly)
03:42:58 <Saizan> maybe it's because it backtracks the state in catch, ugh
03:44:01 <luite> meh this all sounds like a huge mess.
03:44:28 <Saizan> there was a package that handled this better, but it had ugly type signatures :)
03:44:37 <luite> which one?
03:44:41 <Saizan> maybe you'd better roll your one
03:44:49 <Saizan> i'm not finding it
03:44:53 <luite> monad-peel seems to have the same limitations as monad-control btw
03:45:01 <luite> same approach, but slightly different implementation
03:45:53 <Saizan> http://hackage.haskell.org/packages/archive/interleavableIO/0.0.1/doc/html/Control-Monad-Trans-InterleavableIO.html <- this one
03:46:19 <Saizan> the ugliness comes from the long names, mostly
03:46:28 <luite> hmm, 2008, no updates...
03:47:26 <Saizan> yeah, it needs a bit of love but the idea is saner i think
03:51:28 <Saizan> btw, if you're using StateT s over a MonadIO you should consider ReaderT (IORef s) instead
03:52:20 <luite> well in reality the stack is something like ReaderT ErrorT StateT Iteratee IO
03:54:47 <luite> (I still think it should be IterateeT ;p )
03:54:53 <Saizan> ErrorT over IO can also be problematic, unless you really want two separate stacks of exception handlers
03:55:47 <luite> actually I was hoping to remove ErrorT by introducing some uncatchable exception hierarchy
03:55:57 <luite> (uncatchable for the user that is)
03:57:02 <Peaker> is there some library to unify error handling of ErrorT and IO?  A "finally" and "bracket" that guarantee what you want in both?
03:57:50 <luite> I don't know of any, but I'd be happy if I could get it to work without the ErrorT at all
03:58:54 <Saizan> i don't think you can make an exception type that won't be catched when catching SomeException, but i have never tried
04:00:15 <luite> Saizan: I think it's possible if you have some type class that includes a catch function that the user must use
04:00:24 <luite> you can check for the uncatchable exceptions there and rethrow
04:00:56 <Saizan> ah, true
04:28:21 <hpaste> aavogt pasted “ffi to quadpack dqagi” at http://hpaste.org/53311
04:38:47 <luite> Saizan: I think I'm going to try to replace monad-control in Yesod with a manual implementation of that interleaveIO approach with IORefs next week or so, in an experimental branch
04:39:31 <luite> IORefs are kind of ugly and I'm not sure how they'd perform, but imho losing side effects is kind of inexcusable...
04:40:42 <erus`> where does cabal install packages on linux?
04:40:55 <aavogt> ~/.ghc and ~/.cabal
04:42:20 <erus`> i have neither :(
04:44:53 <aavogt> erus`: and you've installed packages as that user with cabal-install?
04:45:09 <erus`> i just ran cabal install snap
04:45:28 <erus`> ls -a in my home directory doesnt show .cabal or .ghc
04:46:26 <erus`> and snap isnt in my PATH
04:52:41 <Peaker> erus`: maybe you have configured cabal for global installations by default somehow?
04:52:59 <erus`> hmm
05:00:15 <erus`> why is life so hard :'(
05:05:19 <Phyx-> erus`: beause it's meant to be a very personalized kinda torture
05:05:20 <ClaudiusMaximus> erus`: you didn't use sudo by reflex with install command?  (that would do a user install as root, iirc)
05:05:28 <morel> erus`: i'm also currently trying to install snap
05:05:44 <morel> erus`: you could join #snapframework
05:05:50 <erus`> i think i might have been su when installing it
05:06:09 <erus`> i did this like a month ago and it was so easy. wtf am i doing wrong
05:16:15 <erus`> it was because i was su i think. works now
05:16:41 <morel> erus`: so one should do "cabal install snap" as root or normal user?
05:16:51 <luite> normal user
05:16:58 <morel> okay :)
05:17:16 <luite> imho it's best to do that with everything
05:17:41 <erus`> to any unix whizz' : how do i give a user permission to rw everything in a folder recursively ?
05:17:46 <handonson> What do you people think about having the character syntax ('a') overloadable so it could be something other than Char
05:18:20 <morel> erus`: chmod -R u=rw folder/
05:18:44 <morel> (if i understood you correctly)
05:18:53 <Phyx-> isn't '' already overloaded in TH?
05:20:42 <handonson> I don't know anything about template haskell, but isn't almost everything overloadable in TH?
05:22:01 <handonson> it seemed that you can define your own language syntax
05:24:49 <Botje> handonson: we already have StringLike
05:26:55 <luite> you mean IsString?
05:27:13 <Botje> uh, that
05:32:27 <Cale> handonson: What would you want it to be?
05:33:05 <Cale> Some other representation of unicode characters? :)
05:33:45 <shlevy> Is there a mapM for Data.Maps? Something like Monad a => (b -> a c) -> Map d b -> Map d (a c)
05:34:19 <hpc> shlevy: yes; it's called fmap ;)
05:34:26 <Cale> :t Data.Traversable.mapM
05:34:27 <morel> @hoogle fmap
05:34:27 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
05:34:27 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
05:34:27 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
05:34:27 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:34:42 <morel> @hoogle fmap
05:34:42 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
05:34:42 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
05:34:42 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
05:34:56 <hpc> shlevy: perhaps you mean mapM :: Monad m => (a -> m b) -> Map d a -> m (Map d b)
05:34:56 <Cale> Yeah, I guess you want fmap though, given the type you wrote
05:35:12 <hpc> which would be the traversable mapM that cale just pointed out
05:35:13 <shlevy> hpc: Whoops, yeah
05:35:15 <ion> :t Data.Map.map `asAppliedTo` (\a -> undefined :: Monad m => m b)
05:35:16 <lambdabot> forall a k (m :: * -> *) b. (Monad m) => (a -> m b) -> M.Map k a -> M.Map k (m b)
05:35:17 <shlevy> Sorry
05:35:29 <shlevy> Is there a mapM for Data.Maps? Something like Monad a => (b -> a c) -> Map d b -> a (Map d c)
05:35:32 <hpc> @src asAppliedTo
05:35:32 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:35:37 <shlevy> That's what I should have written :)
05:35:39 <hpc> :t asAppliedTo
05:35:39 <lambdabot> forall t b. (t -> b) -> t -> t -> b
05:35:56 <hpc> oooh, i like that function
05:36:23 <hpc> asAppliedTo f x y = f y?
05:36:26 <morel> @src asAppliedTo
05:36:26 <lambdabot> Source not found. Sorry.
05:36:55 <hpc> or rather, asAppliedTo f x = f
05:36:57 <ion> f `asAppliedTo` x = f `asTypeIn` ($ x)
05:37:01 <ion> @src asTypeIn
05:37:01 <lambdabot> a `asTypeIn` f = a where _ = f a
05:37:01 <lambdabot> infixl 0 `asTypeIn`
05:37:17 <hpc> oh, or that
05:37:42 <shlevy> Ah, didn't realize traversable came with a mapM.
05:37:46 <shlevy> Thanks!
05:38:37 <ion> @type Data.Traversable.mapM `asTypeIn` \mapM -> mapM undefined (undefined :: Data.Map.Map k a)
05:38:37 <lambdabot> forall a (m :: * -> *) b k. (Monad m) => (a -> m b) -> M.Map k a -> m (M.Map k b)
05:42:05 <FrankenFaust> unpacking haskell-platform :D
05:43:04 <shlevy> Is there a type for representing hashsums?
05:43:21 <rotflcopter> string i guess
05:43:30 <rotflcopter> or long hexadecimal
05:43:31 <shlevy> rotflcopter: Well, yeah :D
05:43:43 <ion> rotflcopter: They aren’t really text, unless serialized in some text format.
05:44:21 <ion> ByteString may or may not be useful.
05:45:17 <shlevy> Hmm, Crypto just uses [Octet] for the output of SHA256
05:46:20 <shlevy> Eh, I don't need efficient processing, maybe I'll just use String
05:47:44 <ion> They are not text. String represents text.
05:47:52 <ion> It’s not about efficiency.
05:48:28 <shlevy> ion: Ok, fair enough
05:48:41 <shlevy> I'll use Crypto then
05:49:53 <ion> Strings are linked lists of Unicode characters. Not very appropriate for hash values, unless specifically converted to a text representation.
05:51:12 <shlevy> Well, the end result needs to be written to a text file that is parsed by a program that expects a text representation
05:51:33 <shlevy> So in the end I need to get that string
05:52:42 <ion> So you need a type for representing hashes and a type for text. String is fine for the latter.
05:53:39 <yitz> though nowadays you should consider Data.Text
05:53:49 <shlevy> ion: In Crypto it's [Octet], where type Octet = word8. Will show [Octet] be the standard text representation of a hash?
05:54:12 * shlevy knows little about text representations of hashes
05:54:15 <yitz> shlevy: no you'll probably render is as hexidecimal or something
05:55:13 <shlevy> Hmm... word8 has a PrintfArg instance, maybe I can use that
05:56:08 <ClaudiusMaximus> > let pad = reverse . take 2 . (++ "00") . reverse ; hex x = pad (showHex x "") ; hexes = concatMap hex in hexes $ (iterate (* 33) 1 :: [Word8])
05:56:10 <lambdabot>   "0121416181a1c1e10121416181a1c1e10121416181a1c1e10121416181a1c1e10121416181...
05:56:48 <shlevy> Ah, showHex
06:00:11 <shlevy> Is there a way to download a file without calling an external process?
06:00:30 <shlevy> hmm, download-curl
06:02:15 <yitz> > let showHex8 b = map (intToDigit . fromIntegral) [shiftR b 4, b .&. 0xf] in showHex8 (223 :: Word8)
06:02:17 <lambdabot>   "df"
06:04:13 <ion> > Text.Printf.printf "%02x" 223 :: String  -- should work, but printf is rather nasty.
06:04:14 <lambdabot>   "df"
06:06:59 <yitz> yeah i'd go with showHex here, like ClaudiusMaximus said
06:15:25 <handonson> Cale: some representation of Unicode character other than a 32-bit word, yes
06:15:34 <handonson> But also, sometimes, just Word8.
06:15:53 <handonson> You know, when you're working with ByteStrings.
06:16:11 <handonson> ' ' == 32 could be handy.
06:18:36 <hpc> sign = shr (' '-1)? :P
06:19:22 <Cale> handonson: If you want to treat the elements of ByteStrings as 8-bit characters, you can use the functions under Data.ByteString.Char8 though :)
06:20:17 <yitz> handonson: you could define a simple quasiquoter to do that. the syntax would look something like [c|X|] where X is your character.
06:20:44 <yitz> handonson: not sure why that would be much better than just saying c 'X' though, where c is some function you define.
06:20:52 <handonson> yitz: or I could just use Data.ByteString.Internal.c2w
06:21:03 * hackagebot ghc-parmake 0.1 - A parallel wrapper for 'ghc --make'.  http://hackage.haskell.org/package/ghc-parmake-0.1 (MikhailGlushenkov)
06:21:21 <yitz> handonson: yes. but Internal is not guaranteed to have a stable interface over versions though.
06:21:41 <handonson> yitz: I doubt c2w will ever change.
06:21:49 <handonson> or disappear or renamed
06:23:07 <yitz> handonson: probably not. but if you depend on enough unsupported things, eventually you'll be sorry.
06:23:36 <yitz> handonson: and it will make people reviewing your code nervous.
06:23:52 <yitz> handonson: but yeah, it will almost certainly work.
06:24:40 <handonson> yitz: Fine. Just copy the one-line definition of c2w and use it in my code. Look, that wasn't my point at all.
06:24:53 <yitz> yep
06:25:30 <handonson> The point was I know how to do this without overloading the character syntax, and I'm just curious about what could be done if that feature was there
06:27:55 <yitz> handonson: that's not exactly what TH is for.
06:28:30 <handonson> Did I ever say that was what TH was for?
06:29:11 <yitz> handonson: TH is not for overloading existing syntax, which is what you want to do.
06:29:36 <handonson> I think I said with TH you *can* define your own syntax
06:30:08 <handonson> I didn't say that was what TH was for
06:31:20 <yitz> handson: you said  < handonson> I don't know anything about template haskell, but isn't almost everything overloadable in TH?
06:31:25 <yitz> handonson, sorry
06:31:57 <handonson> Yes?
06:32:04 <yitz> handonson: so the answer is no, you can't really overload syntax in TH.
06:33:40 <handonson> yitz: No, you're ignoring the conversation context. Of course, that statement alone is false. You can't change the Haskell syntax with TH's quasi-quotation feature
06:34:22 <handonson> But I was answering P·hyx-'s suggestion, which was how '' was overloadable with TH
06:36:04 * Phyx- just said that enabling TH will make the parser exibit different behaviours for '' and meant nothing more
06:37:18 <yitz> perhaps my irc client missed some of the conversation. i saw that handonson asked whether '' syntax can be overloaded, and Phyx- suggested TH. the answer is no, TH doesn't overload syntax.
06:37:29 <aspiers> anyone here running ghc >= 7 on openSUSE?
06:40:58 <handonson> In fact, I shouldn't be saying any of these, because I have NEVER used TH at all, only have a vague concept of how it manipulates the AST and introduces a DSL with quasi-quotation, and most importantly have no interest in it
06:41:15 <yitz> aspiers: i'm not, but did you see this: http://www.reddit.com/r/haskell/comments/loen8/haskell_for_enterprise_linux/
06:42:09 <Phyx-> yitz: I never even said that
06:42:17 <aspiers> yitz: isn't that for RHEL/CentOS?
06:42:29 <yitz> aspiers: oh right sorry.
06:42:57 <aspiers> yitz: if so, not sure why they are likening it to rvm which is truly distro-agnostic
06:42:58 <yitz> handonson: yeah i'm not a big TH fan myself. but for various reasons i've needed to learn more details about how it works lately.
06:42:59 <Phyx-> yitz: he asked if it was a good idea to overload ''. I just pointed out/referenced that TH does it just as a reference
06:43:09 <Phyx-> yitz: i never said he could do it with TH
06:43:11 <yitz> Phyx-: it does?
06:44:09 <thomasp> hi. how do you write binary literals in haskell?
06:44:12 <Phyx-> yitz: i've seen some TH code were '' does not contain a single char. I've never compiled said code nor know much about TH. which is why my reply was in the form of a question
06:44:31 <yitz> Phyx-: perhaps within a quasiquote.
06:44:56 <yitz> thomasp: varous ways, depending on what kind of binary literal you want
06:45:16 <Saizan> '' is TH's syntax to quote type names
06:45:48 <yitz> thomasp: you can write it as a list of numeric bytes, for example, or as a byte-string converted from a string of text.
06:46:03 * hackagebot regex-applicative 0.1.5 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.1.5 (RomanCheplyaka)
06:46:08 <yitz> thomasp: or you can write a string of hexidecimal and convert that pretty easily
06:46:20 <handonson> I thought Phyx- was talking about quasi-quotation, so that was why I asked "isn't everything possible" within the quasiquote
06:46:26 <handonson> Apparently I misread
06:46:28 <yitz> handonson: oh i see
06:46:44 <thomasp> okay, so what would be haskell way of saying e.g. 11110000?
06:46:58 <yitz> handonson: everything is possible inside a quasiquotation except |]
06:47:14 <yitz> > 0x11110000
06:47:16 <lambdabot>   286326784
06:47:27 <yitz> ah that's hex though
06:47:27 <handonson> yitz: I doubt he meant it.
06:47:31 <handonson> Yeah
06:47:35 <yitz> > 0xf0
06:47:36 <lambdabot>   240
06:47:43 <thomasp> i want it to be easy readable
06:47:47 <thomasp> if possible .)
06:47:56 <monochrom> octal is closest to binary
06:48:10 <aspiers> monochrom: how is octal closer than hex?
06:48:14 <yitz> monochrom: why is octal closer than hexidecimal?
06:48:15 <ClaudiusMaximus> :t readIntAtBase
06:48:16 <lambdabot> Not in scope: `readIntAtBase'
06:48:40 <monochrom> fewer bits per digit. the ideal is 1 bit per digit. octal has 3. hex has 4.
06:49:01 <yitz> monochrom: got it
06:49:20 <handonson> closest because binary is 2-ary, octal is 8-ary, decimal is 10-ary, and hexadecimal is 16-ary? :)
06:49:48 <monochrom> curry is 17-ary going on 18-ary
06:49:55 <monochrom> @quote monochrom curry
06:49:56 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
06:50:17 <ClaudiusMaximus> if you want it to look binary, i guess something like b :: String -> Integer and use b "01010101" - not ideal because runtime failure is a possibility :(
06:50:47 <yitz> ClaudiusMaximus: since we're talking about quasiquotation...
06:50:52 <monochrom> use quasiquotation. [b|01010011|] :)
06:51:03 * hackagebot ghc-parmake 0.1.1 - A parallel wrapper for 'ghc --make'.  http://hackage.haskell.org/package/ghc-parmake-0.1.1 (MikhailGlushenkov)
06:51:26 <yitz> oh, parallel make for ghc!
06:51:34 * monochrom learned quasiquotation two days ago
06:51:38 <handonson> ClaudiusMaximus: Maybe Integer -> Integer? so 0x10 will somehow become 2 (0b10)?
06:51:56 <handonson> oh, runtime failure still exists.
06:52:36 <handonson> maybe define a custom data type
06:52:44 <handonson> data Bin = O | I
06:53:17 <handonson> myBinaryValue = pack [I, I, I, I, O, O, O, O]
06:53:34 <yitz> handonson: or Word 2. You could give it a Num instance, then use 0 and 1
06:53:38 <yitz> Word2
06:53:50 <ClaudiusMaximus> Word1 ?
06:53:56 <ghosting> Where should I start if I wanna make a module for the haskell library
06:54:09 <yitz> oh right Word1
06:54:24 <handonson> yitz: Doesn't that require GHC hackery?
06:54:29 <yitz> nope
06:54:36 <handonson> I thought Word family was provided by GHC
06:55:01 <aspiers> hmm, looks like the openSUSE community and Haskell community do not overlap :(
06:55:03 <yitz> handonson: some names like that are defined in Data.Word, that's all.
06:55:04 <ClaudiusMaximus> ghosting: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program has a section on libraries
06:55:20 <Peaker> does anyone remember the name of the ML-like language with C semantics?
06:55:22 <aspiers> damnit, maybe I'll have to package the entire Haskell platform just so I can run git-annex :(
06:55:36 <handonson> quasi-quotation seems to be the best answer so far, but the learning curve of TH might be too steep for thomasp
06:55:53 <yitz> aspiers: more likely just the openSUSE and set of the people paying attention to this channel at them moment don't overlap.
06:56:02 <yitz> aspiers: try the haskell cafe mailing list.
06:56:24 <aspiers> yitz: no, that statement was based on the complete lack of ghc 7 rpms for openSUSE
06:56:51 <yitz> aspiers: the rh-style rpms are not usable?
06:57:47 <aspiers> oh I stand corrected
06:58:00 <aspiers> http://download.opensuse.org/repositories/home:/ptrommler:/devel:/languages:/haskell/openSUSE_Factory/
06:58:02 <aspiers> phew
07:00:57 <yitz> aspiers: the haskell platform team should be notified - the link for openSUSE on the HP Linux page points to stuff that is *much* older.
07:01:41 <aspiers> yitz: well, the correct solution would be to ask ptrommler to coordinate with the owner of the official repos
07:01:45 <aspiers> I'll do that
07:02:00 <yitz> aspiers: there should be an openSUSE rpm that just installs the platform
07:02:47 <yitz> aspiers: if you've already got one for a recent version of ghc, that should be pretty easy to set up.
07:04:00 <yitz> Peaker: C semantics?
07:07:16 <aspiers> yitz: agreed, there should be
07:22:35 <handonson> yitz: but [Word1] will erroneously accept input like [1, 1, 1, 2, 0, 0, 0, 0]
07:23:22 <handonson> while [Bin] will raise a compile-time error with input like [I, I, I, U, O, O]
07:23:42 <shlevy> Why is this giving me an indentation error?
07:23:43 <shlevy>   let file = case file' of
07:23:43 <shlevy>     Left msg -> fail msg
07:23:43 <shlevy>     Right text -> text
07:24:10 <Phyx-> the arguments to the case should be indented atleast as deeply as the case
07:24:10 <ion> let file = either fail id file'
07:24:28 <handonson> no, that's not true
07:24:29 <Phyx-> err alternives*
07:25:18 <handonson> shlevy: I hate that behavior too. let wants everything inside the block to be indented one level deeper than it
07:25:51 <handonson> shlevy: and case wants that too, which is a headache
07:25:51 <shlevy> handonson: But it is indented one level deeper?
07:25:53 <shlevy> Aaah
07:25:57 <shlevy> So I need two levels?
07:26:20 <shlevy> Nope, didn't help :-/
07:26:23 <handonson> Haskell may consider it one level, no matter how many spaces you put there
07:26:30 <shlevy> When I put the case on a separate line still didn't work
07:26:31 <handonson> so you have to
07:26:33 <handonson> let
07:26:36 <handonson>    file = ...
07:26:41 <handonson>         Left ...
07:26:57 <shlevy>   let file =
07:26:57 <shlevy>     case file' of
07:26:57 <shlevy>       Left msg -> fail msg
07:26:57 <shlevy>       Right text -> text
07:27:04 <shlevy> Oh
07:27:06 <shlevy> Ok
07:27:30 <shlevy> That did it, thanks
07:27:35 <ghosting> :t const
07:27:37 <lambdabot> forall a b. a -> b -> a
07:27:53 <Phyx-> or you could have just indented the alternatives to the case as as deep as the case itself
07:27:58 <Phyx-> which part of that exactly is "untrue"
07:28:03 <handonson> shlevy: by the way, you should be able to greatly shorten that code just as ion pointed out
07:29:06 <handonson> Phyx-: by "argument" I thought you meant x in { case x of ... }
07:29:23 <handonson> but you corrected it to alternatives, which makes your original statement true
07:30:02 <handonson> maybe "argument" just sufficed and I was wrong to see it that way
07:30:27 <handonson> wait
07:31:16 <handonson> never mind, everything I said was gibberish
07:31:48 <erus`> how do i define an MVar at the parent scope of m file
07:32:01 <erus`> i can only define an IO (MVar [String])
07:32:12 <handonson> :)
07:33:09 <ClaudiusMaximus> erus`: ACIO (though i don't know if it's implemented anywhere yet)
07:33:22 <handonson> I firmly believe that the frequency of a question means something really needs to be done either to the language/library or the implementation
07:33:29 <handonson> ClaudiusMaximus: in JHC, afaik
07:34:15 <handonson> erus`: It is impossible to define a top-level { myMVar :: MVar a } with GHC. I mean, without some hacking.
07:34:23 <handonson> erus`: but sometimes, hacking is the answer.
07:34:37 <erus`> i can just define it in main and pass it to my handlers i guess
07:35:10 <handonson> erus`: that way is apparently approved by the general public
07:35:12 <shlevy>  Ah, either is much nicer than case. Thanks, ion
07:35:44 <handonson> erus`: or, use this, which is approved (at least) by kmc and me. http://hackage.haskell.org/package/safe-globals
07:35:49 <shlevy> ion: I'm assuming it's specifically for Either a b?
07:35:54 <ion> :t either
07:35:55 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
07:36:01 <handonson> yup
07:36:34 <shlevy> ion: Maybe I defined my own type with Left and Right constructors :P
07:37:01 <ion> Maybe you’re doing it wrong. ;-)
07:38:00 <Cale> erus`: Yes, that's what I recommend.
07:39:11 <shlevy> Ah, there's something extremely satisfying about a successful haskell compilation
07:39:14 <Cale> erus`: In fact, you can do even more refined things like that too. Instead of passing the v :: MVar t around, you can pass (readMVar v) and (writeMVar v) to the places which are supposed to be reading and writing the MVar, to enforce how it gets used.
07:39:17 * shlevy hasn't coded haskell in several months
07:39:34 <erus`> ah thats handy
07:40:39 <Cale> erus`: This also has the advantage that you can later do things like change the implementation from MVar to Chan if you decide that you'd like the parts of your program to communicate differently, or add consistency checks of some sort, without touching the code which is using the MVar.
07:42:22 <handonson> shlevy: That's why I found this article amazing. It describes exactly how I feel when I code in Haskell. You might have already seen it... http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
07:44:11 <handonson> erus`: here's why we couldn't come up with an orthodox, community-consent solution http://www.haskell.org/haskellwiki/Top_level_mutable_state
07:44:41 <shlevy> handonson: Yeah, definitely describes how I feel. My day-to-day is C (haven't yet been brave enough to try Haskell for systems-level programming) and C# (my co-workers need to read what I write). But I always come back.
07:45:44 <kk`> handonson, that article/email is absolutely hilarious.
07:45:53 <kk`> But very accurate, I must say ;)
07:46:43 <handonson> kk`: one of the Great Classic Haskell Literature already, I think.
07:48:26 <shlevy> Is it possible to write a production-level (in terms of performance and features) kernel in idiomatic Haskell?
07:48:53 <shlevy> If the answer to that is yes I may just switch over... It's the rt library dependency that gets me though every time I think about it
07:49:11 <mm_freak> shlevy: it is possible to write a kernel in haskell, and it has been done as a proof of concept (see the HOUSE project)
07:49:28 <mm_freak> HOUSE is a standalone operating system written in haskell
07:50:06 <shlevy> Ooh, there's an associated paper!
07:50:10 <mm_freak> shlevy: the run-time system is one of the things that makes haskell so great…  yes, it's big, but it's also largely useful
07:50:18 <shlevy> I know what I'm reading on my next plane ride
07:50:30 <shlevy> mm_freak: I'm assuming House integrates it into the kernel somehow?
07:50:31 <mm_freak> you might also be interested in the HASP project
07:51:13 <mm_freak> part of HASP is a haskell-like language specifically designed for systems programming
07:51:29 <mm_freak> shlevy: HOUSE is fully written in haskell, no external dependencies
07:51:33 <erus`> @hoogle liftIO
07:51:33 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
07:51:41 <mm_freak> i.e. no linux
07:53:05 <shlevy> mm_freak: Surely some ASM? Or does Haskell allow inlining?
07:53:49 <mm_freak> i don't know what they used to interface with the hardware…  likely some ASM is there, but not necessarily in the mainstream code…  more likely in the run-time system
07:54:37 <ClaudiusMaximus> halvm might be interesting to you too
07:56:27 <mm_freak> shlevy: if you want to experiment with functional operating system kernels, HASP is probably the project to investigate…  haskell by itself is not really suitable, although not impossible to use
07:56:43 <mm_freak> shlevy: if what you want to write is a server program or something like that, then i would totally go for haskell
08:13:39 <kk`> shlevy, I remember reading somewhere that MIT were doing a course for systems/kernel programming in functional languages.
08:22:09 <mike-burns> I can never remember how to export a record from a module, and every time I search Google I get no results that jump out at me.
08:22:15 <mike-burns> Any advice on what to search for?
08:22:37 <mm_freak> mike-burns: RecordTypeName(..)
08:22:38 <shachaf> mike-burns: "Foo(..)"?
08:22:48 <mm_freak> for the full record that is
08:22:50 <mike-burns> OK, I'll ask in here again next time.
08:22:56 <mike-burns> Thanks.
08:24:19 <mm_freak> mike-burns: think about exporting a list of record accessors…  then you might remember the ".."
08:48:34 <mm_freak> is there a way to examine the code generated by arrow notation on a higher level than core?
08:49:55 <byorgey> mm_freak: it would seem not =(
08:49:58 <shachaf> mm_freak: Doesn't GHC translate arrow notation straight to Core?
08:49:59 <byorgey> I wanted that the other day too
08:49:59 <copumpkin> you need to do way instain mother
08:51:26 <mm_freak> bad =/
08:51:50 <mm_freak> i would love to see particularly how GHC translates this:  proc x -> case x of …
08:52:12 <mm_freak> because sometimes i feel urged to write that with the ArrowChoice combinators directly, which is very inconvenient
08:53:29 <byorgey> https://github.com/ghc/ghc/blob/master/compiler/deSugar/DsArrows.lhs
08:54:49 <mm_freak> byorgey: does that do exactly what GHC does?
08:54:57 <copumpkin> that is GHC
08:55:17 <mm_freak> oh, yes…  and indeed, it's translating to core =/
08:55:45 <mm_freak> is that more efficient?
08:56:00 <copumpkin> does anything desugar to plain haskell?
08:56:20 <byorgey> I doubt it
08:56:55 <byorgey> "plain Haskell" has to be desugared too
08:57:21 <mm_freak> true
08:57:40 <mm_freak> so perhaps i should learn reading core output…  last time i tried it was really confusing
08:59:21 <copumpkin> it's mostly annoying cause of all the qualified names
08:59:30 <copumpkin> if you strip the modules off it's a lot better
09:01:04 * hackagebot hssqlppp 0.4.0 - SQL parser and type checker  http://hackage.haskell.org/package/hssqlppp-0.4.0 (JakeWheat)
09:01:06 * hackagebot gsc-weighting 0.1.1.1 - Generic implementation of Gerstein/Sonnhammer/Chothia weighting.  http://hackage.haskell.org/package/gsc-weighting-0.1.1.1 (FelipeLessa)
09:01:11 <byorgey> isn't there a package that does that for you, and colorizes stuff etc?
09:03:03 <copumpkin> ghc-core
09:03:09 <copumpkin> I didn't think it stripped the module names though
09:03:11 <gwern> @quote
09:03:11 <lambdabot> br1 says: [13:52] <br1> viajas distinto pero viajas
09:03:36 <incluye> how do I get the square root of an int
09:03:53 <MrOrdinaire> sqrt(<int>)
09:04:05 <copumpkin> there are special algorithms for that
09:04:25 <incluye> > sqrt 3
09:04:26 <lambdabot>   1.7320508075688772
09:04:28 <incluye> huh
09:04:30 <incluye> :t 3
09:04:31 <lambdabot> forall t. (Num t) => t
09:04:38 <copumpkin> > sqrt (fromIntegral 3)
09:04:40 <lambdabot>   1.7320508075688772
09:04:42 <incluye> what is this garbage
09:04:49 <copumpkin> that's what you might want
09:04:55 <copumpkin> but probably not if the int can be large
09:05:54 <incluye> well, ghc is choking on [2..(floor $ sqrt n)] where n fulfills Num
09:06:06 <incluye> "Could not deduce (Enum a) from the context (Num a)"
09:06:29 <copumpkin> it has a point
09:06:36 <copumpkin> give it a specific type
09:06:39 <copumpkin> or ask for Enum a
09:06:58 <incluye> i don't even understand you
09:07:54 <incluye> give what a specific type
09:07:58 <incluye> how do I ask it something
09:08:46 <mjo> Im guessing that to use the [a..b] notation, the 'a' and 'b' need to be of type Enum.
09:09:08 <hpc> :t enumFromTo
09:09:10 <lambdabot> forall a. (Enum a) => a -> a -> [a]
09:09:11 <hpc> yes
09:09:14 <shlevy> Shouldn't floor give an Enum-erable type?
09:09:26 <mjo> If all you've specified (or the type checker has inferred, or whatever) is that it's a Num, it can't deduce that it's an Enum also.
09:10:00 <incluye> oh okay
09:10:11 <shlevy> :t floor
09:10:12 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:10:36 <shlevy> Hm, I assumed Integral -> Enum
09:10:43 <incluye> me too
09:10:46 <incluye> that is a mistake
09:11:11 <shlevy> :info Integral
09:11:20 <shlevy> No idea how to ask about a type class :)
09:11:22 <shlevy> :t Integral
09:11:23 <lambdabot> Not in scope: data constructor `Integral'
09:11:28 <hpc> i wonder if it would be theoretically possible to get an Enum instance for Integral a => a
09:11:28 <shlevy> Didn't think soo
09:11:40 <hpc> @src Integral
09:11:41 <lambdabot> class  (Real a, Enum a) => Integral a  where
09:11:41 <lambdabot>     quot, rem, div, mod :: a -> a -> a
09:11:41 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
09:11:41 <lambdabot>     toInteger           :: a -> Integer
09:12:00 <Phyx-> @src Integral Int
09:12:00 <lambdabot> Source not found. Do you think like you type?
09:12:05 <shlevy> @src Integer
09:12:06 <lambdabot> data Integer = S# Int#
09:12:06 <lambdabot>              | J# Int# ByteArray#
09:12:22 <copumpkin> why is that even in lambdabot?
09:12:37 <hpc> copumpkin: for fun
09:12:40 <shlevy> Is Integer Enum?
09:12:43 <copumpkin> yes
09:12:59 <shlevy> Ok, then yes you can write an Enum instance for Integral a :)
09:13:02 <dylex> the problem is more about the 2.  Just add  a ::Int or ::Integer cast
09:13:24 <Phyx-> copumpkin: cauze it's cool! :P
09:14:06 <dylex> > let n = 100 in [2..floor (sqrt n)] :: [Int]
09:14:07 <lambdabot>   [2,3,4,5,6,7,8,9,10]
09:15:29 <shlevy> let n = 101 in [2..floor $ sqrt n]
09:15:33 <copumpkin> let me guess what this is for :)
09:15:34 <stribor> i have parser called myParser (checks string) and i want to test it using testParser
09:15:36 <shlevy> > let n = 101 in [2..floor $ sqrt n]
09:15:36 <copumpkin> PRIMALITY TESTING
09:15:37 <lambdabot>   [2,3,4,5,6,7,8,9,10]
09:15:45 <incluye> nope
09:15:51 <shlevy> Hm, works even when not a square
09:15:51 <stribor> testParser myParser "" "testingstring"
09:15:52 <incluye> proper divisors
09:16:11 <stribor> what am i doing wrong in the baove
09:16:13 <copumpkin> well, something relating to divisibility, yeah :)
09:17:49 <stribor>  can someone show me exampke of using function "parseTest"
09:19:19 <Phyx-> stribor: err.. i think in order for anyone to help they'd need code
09:19:23 <Phyx-> at the very least a type
09:19:32 <shlevy> :t parseTest
09:19:33 <lambdabot> Not in scope: `parseTest'
09:19:37 <shlevy> Thought not
09:19:49 <stribor> wel i have parser which is called "myParser" that checks the string
09:19:59 <stribor> id like to test it using parseTest
09:20:19 <Phyx-> ...
09:20:34 <shlevy> stribor: What is parseTest?
09:20:58 <Phyx-> stribor: yes, but we can't really help without knowing the type of parseTest and myParser
09:21:13 <stribor> its function in parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()Source  The expression parseTest p input applies a parser p against input input and prints the result to stdout. Used for testing parsers.
09:22:03 <Phyx-> ah, parsec
09:23:52 <Phyx-> stribor: have you tried parseTest myParser <input>
09:24:42 <yitz> > let isqrt n = stable $ iterate (f n) (n `div` 2); stable (x:xs@(x':_)) | x == x' = x | otherwise = stable xs; f x y = (y*y + y + x) `div` (y + y) in isqrt 105
09:24:43 <lambdabot>   10
09:24:51 <yitz> > let isqrt n = stable $ iterate (f n) (n `div` 2); stable (x:xs@(x':_)) | x == x' = x | otherwise = stable xs; f x y = (y*y + y + x) `div` (y + y) in isqrt 1005
09:24:52 <lambdabot>   32
09:25:43 <yitz> > let isqrt n = stable $ iterate (f n) (n `div` 2); stable (x:xs@(x':_)) | x == x' = x | otherwise = stable xs; f x y = (y*y + y + x) `div` (y + y) in isqrt 786435897365897346
09:25:44 <lambdabot>   886812211
09:26:07 <yitz> 886812211^2
09:26:10 <yitz> > 886812211^2
09:26:12 <lambdabot>   786435897578708521
09:27:02 <yitz> incluye: ^
09:28:23 <aconbere> hey, I'm running into a reported bug trying to install process 1.1.0.0 through cabal
09:28:31 <aconbere> where processFlags.h isn't found
09:28:32 <hpaste> stribor pasted “parser” at http://hpaste.org/53317
09:28:45 <aconbere> http://hackage.haskell.org/trac/ghc/ticket/5449
09:28:53 <stribor> i want to test above parser and see what it does....checks the string followed by space
09:28:55 <aconbere> I'm not really sure how to proceed
09:28:55 <stribor> i want to try to test it
09:30:01 <mysticc> is there a pure haskell image manipulation library ?
09:30:23 <rostayob> mysticc: "pure"?
09:30:27 <rostayob> mysticc: gloss is really nice
09:30:34 <rostayob> but I don't get what you mean with pure in this context
09:30:38 <mysticc> rostayob: I mean no bindings and all ...
09:30:39 <rostayob> ah
09:30:48 <rostayob> ah image manipulation in that sense
09:30:48 <mysticc> only in haskell
09:30:59 <shlevy> Hmm, downloading every .cabal and .tar.gz in hackage oddly enough takes quite some time
09:31:00 <rostayob> then, I don't know, I thought you wanted some graphics related lib :P
09:31:03 <yitz> mysticc: nothing very complete. what kinds of operations do you need?
09:31:18 <stribor> is there way to test parser above
09:31:22 <mysticc> rostayob: I just need to read and scale an image .. but only in haskell
09:31:43 <mysticc> yitz: just scaling to a given resolution ..
09:31:53 <rostayob> mysticc: I'm not sure then... why the only haskell requirement?
09:31:54 <mysticc> yitz: very minimal functionality ...
09:32:31 <mysticc> rostayob: dont want the c bindings to mess around with the concurrency ... lets just say I want ... :p
09:32:36 <aconbere> hmpf
09:32:53 <mysticc> rostayob: Also play with it a little bit ... :)
09:33:07 <mysticc> yitz: Any suggestions ..
09:34:37 <hpc> mysticc: System.Cmd.rawSystem "convert" (params as a list go here)
09:34:50 <hpc> no C bindings :P
09:35:41 <mm_freak> incluye: if highest possible performance is not a concern to you, but you want correctness, then i suggest flipping this inside out
09:35:44 <mysticc> hpc: That is what I am doing .. but I want to have some code with which I can play around and implement my own algos
09:35:59 <mm_freak> > let n = 1000 in takeWhile (\x -> x*x < n) [1..]
09:35:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:36:04 <mm_freak> > let n = 100 in takeWhile (\x -> x*x < n) [1..]
09:36:04 <lambdabot>   [1,2,3,4,5,6,7,8,9]
09:36:36 <mm_freak> incluye: if performance is also important, you should implement one of the fast integer square root algorithms
09:36:42 <stribor> hpc: can you help me how to test the parser from example i found online
09:36:52 <yitz> mysticc: perhaps the bmp package will do it for you. (author is well known in the community, writes good code)
09:37:06 <stribor> hpc: http://hpaste.org/53317
09:37:12 <mm_freak> 'sqrt' only gives you floating point square roots, which will become imprecise after about 53 binary digits for the usual Double type
09:37:26 <hpc> > let n = 1000; sn = sqrt n in takewhile (< sn) [1..] -- fixed that for you ;)
09:37:26 <lambdabot>   Not in scope: `takewhile'
09:37:31 <yitz> mysticc: so a search for image (etc.) on hackage and a number of things come up, you can try them and see how they work.
09:37:33 <hpc> > let n = 1000; sn = sqrt n in takeWhile (< sn) [1..] -- fixed that for you ;)
09:37:34 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
09:37:40 <mm_freak> hpc: no, you didn't fix it…  in fact you messed it up
09:37:53 <mm_freak> please review the context
09:38:57 <Phyx-> stribor: I've never used Parsec, but I dont beleive the type of your parser is correct
09:39:00 <shlevy> When would I want to use Serializable over just Show+Read?
09:39:17 <mm_freak> shlevy: speed, size, correctness
09:39:21 <Phyx-> stribor: well, it depends on what you want to do
09:39:34 <mm_freak> Read+Show are not expected to be working together, even though the often do
09:39:43 <stribor> Phyx-: i just want to see what it does to string
09:39:50 <stribor> want to see what is the output
09:39:58 <shlevy> mm_freak: Oh, I assumed that was the expectation
09:39:59 <shlevy> Hmm
09:40:14 <Phyx-> stribor: parseTest (myParser "string to recognize") "input string"
09:40:57 <yitz> > (read.show) $ 1.0/0
09:40:58 <lambdabot>   *Exception: Prelude.read: no parse
09:41:10 <stribor> Phyx-: ok thank you
09:41:45 <mm_freak> shlevy: consider a generic type for series…  you could write Show to print an approximation, but then Read would yield something different from what you showed originally
09:41:54 <mm_freak> series → number series
09:42:09 <mm_freak> Show is mostly useful for debugging
09:42:12 <shlevy> Oh, maps are serializable anyway. Ok
09:42:25 <shlevy> I don't know why I thought they weren't
09:42:30 <mm_freak> hehe
09:42:33 <shlevy> Ah, the key needs to be Orderable
09:42:34 <yitz> mm_freak, incluye: the algorithm i demonstrated above is pretty good for some purposes
09:43:23 <ClockFrog> is list comprehension kinda like map?
09:43:25 <mm_freak> yitz: i didn't read everything, just wanted to provide a correct way to do without a square root algorithm =)
09:43:26 <stribor> Phyx-: type of the output is IO()
09:43:47 <mm_freak> ClockFrog: if you only have a single clause with a single binding, then yes, kinda
09:43:57 <yitz> ClockFrog: that's one of the things it can do
09:43:58 <mm_freak> > [ succ x | x <- [1..10] ]
09:43:59 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
09:44:20 <mm_freak> ClockFrog: but in that case you should use map ;)
09:44:24 <mm_freak> > map succ [1..10]
09:44:25 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
09:45:00 <shlevy> Nice, Version is Ord-erable
09:45:19 <ClockFrog> ok cheers
09:45:42 <ion> > succ . [1..10]
09:45:44 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
09:45:48 <stribor> can someone give example of using "spaces" function from Parsec.Char
09:46:05 <hpc> :t spaces
09:46:05 <lambdabot> Not in scope: `spaces'
09:46:31 <ion> parse (spaces *> string "foo" <* eof) "" "    foo"
09:47:12 <ion> It’s not a function, just a value.
09:49:00 <shlevy> How do I write a ByteString to file?
09:49:04 <shlevy> writeFile doesn't like it
09:49:07 <shlevy> :t writeFile
09:49:08 <lambdabot> FilePath -> String -> IO ()
09:49:13 <shlevy> :t ByteString.writeFile
09:49:14 <lambdabot> Couldn't find qualified module.
09:49:16 <shlevy> nope
09:49:20 <hpc> shlevy: there's an IO module for bytestrings you can use
09:49:34 <shachaf> shlevy: Try that with the actual module that contains ByteString. :-)
09:50:04 <shachaf> @hoogle FilePath -> ByteString -> IO ()
09:50:04 <shlevy> :t Data.ByteString.writeFile
09:50:04 <lambdabot> Data.ByteString appendFile :: FilePath -> ByteString -> IO ()
09:50:04 <lambdabot> Data.ByteString writeFile :: FilePath -> ByteString -> IO ()
09:50:04 <lambdabot> Data.ByteString.Char8 appendFile :: FilePath -> ByteString -> IO ()
09:50:05 <lambdabot> FilePath -> BSC.ByteString -> IO ()
09:50:16 <shlevy> :D
09:50:18 <shlevy> Whoops
09:51:36 <shlevy> Hm, tuples of Serializables aren't Serializable?
09:51:55 <mm_freak> shlevy: which serialization library are you using?
09:52:06 <shlevy> mm_freak: cereal, I think
09:52:29 <mm_freak> in cereal tuples are serializable
09:52:33 <mm_freak> look at the instances
09:52:34 <shlevy> Nope, it claims I should. I guess one of my types isn't
09:52:45 <mm_freak> (Serialize a, Serialize b) => Serialize (a, b)
09:53:01 <shlevy> Yeah, I see it
09:53:20 <shlevy> Ah, right, my custom data type. Duh
09:53:47 <shlevy> Is there a better way to write an instance than just using a tuple that has each of the fields of my type?
09:54:10 <Phyx-> stribor:yes because parseTest prints the results to stdout
09:54:49 <mm_freak> shlevy: what would be better than that?
09:55:08 <Phyx-> stribor: that's why it's enforcing that whatever it is you're producing is a showable
09:55:12 <shlevy> mm_freak: No idea, just sometimes what I think is obvious ends up being dumb :)
09:56:04 * hackagebot hamlet 0.10.4 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.10.4 (MichaelSnoyman)
09:56:06 * hackagebot persistent 0.6.4 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.6.4 (MichaelSnoyman)
09:56:08 * hackagebot shakespeare 0.10.2 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-0.10.2 (MichaelSnoyman)
09:57:46 <wyfrn> hey guys ... is there a simpler way to return Nothing in a function of typ [Int] -> StateT String Maybe [Int] than StateT $ \_ -> Nothing ?
09:58:27 <mm_freak> shlevy: well, i don't see a better way =)
09:58:33 <Botje> lift (fail "") ?
09:58:45 <mm_freak> wyfrn: lift mzero
09:58:51 <Botje> ah
09:59:05 <mm_freak> wyfrn: or lift empty, if you are the applicative guy =)
09:59:36 <wyfrn> mm_freak: thx
10:01:10 * hackagebot wai-extra 0.4.4 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.4 (MichaelSnoyman)
10:01:12 * hackagebot wai-test 0.1.2 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-0.1.2 (MichaelSnoyman)
10:01:14 * hackagebot yesod 0.9.3.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.3.1 (MichaelSnoyman)
10:01:16 * hackagebot yesod-auth 0.7.5 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.5 (MichaelSnoyman)
10:01:18 * hackagebot yesod-core 0.9.3.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.3.3 (MichaelSnoyman)
10:02:20 <wyfrn> mm_freak: what moudle contains empty? google did not help me a lot ...
10:02:51 <mm_freak> wyfrn: Control.Applicative
10:03:03 <wyfrn> thx
10:03:21 <mm_freak> wyfrn: the Alternative type class containing 'empty' is basically a generalization of MonadPlus, which contains mzero
10:06:08 <shlevy> mm_freak: Put is pretty easy, I just pattern match on the fields and put the tuple. Tips on writing the get?
10:06:20 * hackagebot yesod-default 0.4.0 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-0.4.0 (MichaelSnoyman)
10:06:22 * hackagebot bind-marshal 0.1 - Data marshaling library that uses type level equations to optimize buffering.  http://hackage.haskell.org/package/bind-marshal-0.1 (CoreyOConnor)
10:07:03 <shlevy> :t Data.Serialize.get
10:07:04 <lambdabot> Couldn't find qualified module.
10:07:25 <HugoDaniel> must be uppercase
10:07:27 <mm_freak> shlevy: 'get' is basically a parser
10:07:41 <mm_freak> shlevy: look into the *.Get module
10:07:50 <mm_freak> there are combinators for writing Get computations
10:07:54 <shlevy> mm_freak: Right, and I want to utilize the parser already written for tuples and just pop the results into a constructor
10:08:12 <shlevy> Ok, will check it out
10:08:15 <joeyh> are there any good workarounds for Eq not being supported for functions? (My bad workaround is data TaggedFunc = TaggedFunc Int (a -> b) )
10:08:27 <mm_freak> joeyh: no
10:09:00 <mm_freak> shlevy: in that case just use the Serialize instance for tuples ;)
10:10:21 <shlevy> mm_freak: Sorry if this is dumb, but... How? I'm only exporting my type, not the constructor, so end users can't get the tuple themselves.
10:10:24 <mysticc> How to convert a string to bytestring ..?
10:10:38 <shlevy> :t Data.ByteString.pack
10:10:39 <lambdabot> [Word8] -> BSC.ByteString
10:11:06 <mysticc> shlevy: I want [Char] -> Bytestring ?
10:11:07 <shlevy> @hoogle String -> ByteString
10:11:07 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
10:11:07 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
10:11:07 <lambdabot> Prelude read :: Read a => String -> a
10:12:38 <mm_freak> shlevy: get >>= \(a, b, c, d) -> …
10:12:52 <shlevy> Aah, ok
10:14:05 <shlevy> Alternatively do (a, b) <- get; return Constructor (a, b)?
10:14:12 <shlevy> erm, Constructor a b
10:14:17 * shlevy tries it
10:14:18 <byorgey> return $ Constructor a b
10:14:35 <byorgey> uncurry Constructor <$> get
10:14:44 <byorgey> =)
10:15:01 <shlevy> :t uncurry
10:15:01 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:15:19 <shlevy> Ah, cool :)
10:16:25 <shlevy> :t <$>
10:16:26 <lambdabot> parse error on input `<$>'
10:16:31 <shlevy> :t \<$\>
10:16:32 <lambdabot> parse error on input `\<$\>'
10:16:36 <Clint> :t (<$>)
10:16:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:16:43 <shlevy> doh
10:18:41 <shlevy> @hoogle (<$>)
10:18:41 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
10:19:13 <byorgey> shlevy: do foo <- m; return (f foo)   is always equivalent to   fmap f m
10:19:20 <byorgey> which can also be written  f <$> m
10:19:41 <brisingr> Any references for learning graphs? I've seen the monad.reader issue 5 and tried to learn from source code but it takes a hell of a lot of concentration
10:22:00 <mm_freak> shlevy: you can also use a variant of liftA*
10:22:15 <mm_freak> or a combination of (<$>) and (<*>)
10:22:55 <mm_freak> shlevy: but then you have to make sure that you serialize in the same order, i.e. don't use the Serialize instance of tuples
10:24:41 <wyfrn> mm_freak: i got the following small function http://hpaste.org/53320 ... why lift mzero / lift empty don't produce the same results as if i would return a StateT $ \_ -> Nothing ?
10:25:26 <shlevy> :t first
10:25:26 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
10:25:45 <shlevy> > first (1, 2)
10:25:46 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
10:25:46 <lambdabot>    arising from a use of `Control...
10:25:56 <mm_freak> shlevy: fst
10:26:10 <mm_freak> wyfrn: they should
10:26:15 <mm_freak> wyfrn: you can also write lift Nothing
10:26:20 <Botje> isn't StateT $ \_ -> Nothing :: StateT s m (Maybe a) ?
10:26:29 <shlevy> > fst (1, 2)
10:26:30 <lambdabot>   1
10:26:35 <shlevy> mm_freak: Thanks
10:26:41 <mm_freak> Botje: no, it's StateT s Maybe a
10:26:58 <mm_freak> newtype StateT s m a = StateT (s -> m (a, s))
10:27:45 <wyfrn> if i use return Nothing i get following error: Couldn't match expected type `[Int]' with actual type `Maybe a0'
10:28:16 <wyfrn> and if i use mzero / empty the result always matches Just
10:28:48 <wyfrn> whats broken? my brain or ghci?
10:30:53 <parcs_> @remember wyfrn whats broken? my brain or ghci?
10:30:53 <lambdabot> Done.
10:31:10 <mm_freak> wyfrn: lift Nothing, not return Nothing
10:31:21 <mm_freak> return Nothing :: StateT s m (Maybe a)
10:31:26 <mm_freak> lift Nothing :: StateT s Maybe a
10:31:45 <maurer> Does anyone know where the HaTeX repo is? I can only seem to find source dumps
10:32:07 <mm_freak> return Nothing = StateT (\s -> Just (Nothing, s))
10:32:16 <mm_freak> lift Nothing = StateT (const Nothing)
10:32:23 <wyfrn> mm_freak: ahhh ... thx ... it's hard to understand the monadtransformers for a noob :-(
10:32:28 <mysticc> @hoodle Char -> Word8
10:32:29 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
10:32:29 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:32:29 <lambdabot> Prelude error :: [Char] -> a
10:33:46 <JoeyA> > floor $ log 0
10:33:47 <lambdabot>   -17976931348623159077293051907890247336179769789423065727343008115773267580...
10:33:51 <obcode> hi all, I have done 'yesod init' ... on Gentoo with yesod 0.9.3. starting 'yesod devel' gives me: "devel.hs: socket: unsupported operation (Address family not supported by protocol)" Any hints?
10:34:40 <obcode> is this a know issue with GHC 7.0.4 and network-2.3.0.4?
10:34:47 <mm_freak> obcode: i suggest asking that question on the mailing list
10:35:03 <mm_freak> there is a yesod mailing list, but you can also ask on the haskell-cafe list
10:35:56 <obcode> mm_freak: k, I tried already in #yesod, but there seem to noone awake at the moment :-)
10:36:08 <obcode> thanks!
10:43:41 <stribor> Text.ParserCombinators.ReadP.string "myString"
10:43:51 <stribor> > Text.ParserCombinators.ReadP.string "myString"
10:43:52 <lambdabot>   Not in scope: `Text.ParserCombinators.ReadP.string'
10:50:01 <tsousa> http://dpaste.com/644285/ how can i fix it?
10:52:13 <rostayob> http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf whoa
10:52:54 <tsousa> can someone please help me?
10:53:43 <mah_b> tsousa: take n xs ++ [char] ++ drop n xs
10:53:54 <mah_b> @type (++)
10:53:55 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:54:18 <tsousa> thanks
10:54:22 <mah_b> :t (++)
10:54:23 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:54:37 <dylex> tsousa: or better, take n xs ++ char : drop n xs  (or even better, use splitAt)
10:54:50 <mah_b> tsousa: (++) :: [a] -> [a] -> [a]
10:55:31 <mah_b> what Prelude is this?
10:55:39 <mysticc> I have a Bytestring and I want to split it into substrings (similar to Data.ByteString.splitWith) at a character (say x) only when the next character is not y ... What is the optimal way of doing it ?
10:57:40 <rostayob> byorgey: are there plans for that ( http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf ) to be in mainline GHC?
10:58:27 <rostayob> byorgey: that would change everything
10:58:31 <rostayob> I'm excited.
10:59:09 <dylex> mysticc: probably loop over elemIndices x, check if y is next, and extract each substring
10:59:50 <copumpkin> rostayob: in 7.4, assuming they can get it all finished by the end of this month :P
10:59:53 <copumpkin> i.e. tomorrow
11:00:29 <rostayob> oh maaaaaan! that would be awesome
11:00:40 <rostayob> but... but, it's not the same language anymore
11:00:55 <erus`> its stronger and faster
11:01:06 <rostayob> like at this point, with ConstraintKinds and this, GHC haskell is very different from haskell98
11:01:10 <rostayob> like, very different
11:01:17 <erus`> and we can do all manner of type wankery
11:01:18 <copumpkin> that's a good thing
11:01:31 <rostayob> well I personally can't wait
11:01:36 <erus`> lots more gloating
11:01:38 <byorgey> rostayob: yes, if everything goes as planned it will be in 7.4
11:02:03 <byorgey> rostayob: of course, you will still have to enable it with a flag
11:02:03 <erus`> I can't wait to feel even more superior to imperative language users
11:02:08 <copumpkin> lol
11:02:13 <byorgey> so you can still program in Haskell 2010 if you want.
11:02:17 <copumpkin> erus`: my thoughts exactly
11:02:18 <rostayob> byorgey: yep. thanks for the hard work :)
11:02:26 <byorgey> http://hackage.haskell.org/trac/ghc/wiki/Status/Oct11  is mind-blowing
11:02:32 <rostayob> this is AWESOME
11:02:58 <rostayob> byorgey: it is indeed!
11:03:02 <byorgey> declarations at the ghci prompt... kind polymorphism & promotion... ConstraintKinds... monad comprehensions...
11:03:07 <rostayob> i love this language.
11:03:18 <rostayob> some day, i'll contribute. maybe.
11:03:45 <companion_cube> declarations in the prompt, at least \o/
11:03:54 <byorgey> rostayob: there's no time like the present!
11:03:55 <opqdonut> nice
11:04:09 <rostayob> byorgey: well I'm not skilled enough! yet
11:04:15 <rostayob> but I'm learning fast eheh
11:04:18 <byorgey> rostayob: look at the trac and pick a simple fix that needs fixing
11:04:25 <byorgey> rostayob: nonsense.
11:04:32 <rostayob> byorgey: I'll look into that
11:04:40 <copumpkin> "Work on adding contracts to Hsakell, along the lines of Dana Xu's these, but using a first order logic theorem prover to check contract satisfaction (with Koen Claessen, Dimitrios Vytiniotis, Charles-Pierre Astolfi, and Nathan Collins)."
11:04:44 <copumpkin> HELL YEAH
11:04:44 <copumpkin> :P
11:04:50 <byorgey> haha, awesome
11:04:51 <rostayob> cloud haskell too
11:04:51 <copumpkin> (in the future)
11:04:56 <rostayob> we're going to take over
11:04:57 <rostayob> the world
11:05:00 <mvj2111> :Q
11:05:08 <rostayob> the haskell technocracy
11:05:10 <rostayob> ok enough.
11:05:13 <byorgey> oh yeah, and a proper module/package system!
11:05:14 <mvj2111> whoops, this isn't vim, and i was holding the shift key; double fail
11:05:19 <rostayob> but jokes aside, this is really really cool
11:09:09 <mm_freak> byorgey: have you seen module/package systems of mainstream languages?
11:09:17 <mm_freak> me neither, because there is nothing there…
11:11:08 <byorgey> mm_freak: does OCaml count as mainstream?
11:11:24 <rostayob> I think that Haskell counts as mainstream
11:11:34 <byorgey> well, Haskell does not have a nice module/package system =)
11:11:47 <copumpkin> someone should overhaul that :P
11:11:51 * copumpkin puts finger on nose
11:11:53 <mysticc> in the case statement if I have same action for many pattern can I write as p1|p2|p3 -> action or I have to repeat p1-> action p2->action ...?
11:11:55 <rostayob> oh well. OCaml one is really sophisticated right?
11:11:57 <byorgey> copumpkin: they ARE, that's what I was just saying =)
11:12:00 <rostayob> or ML even
11:12:07 <copumpkin> byorgey: who's they? :o
11:12:08 <rostayob> SML
11:12:35 <byorgey> copumpkin: http://hackage.haskell.org/trac/ghc/wiki/PackageLanguage
11:12:37 <mm_freak> byorgey: not really…  i don't think ocaml is used much more than haskell
11:12:48 <byorgey> copumpkin: Scott Kilpatrick & Derek Dreyer
11:13:03 <mvj2111> OCaml is getting towards mainstream
11:13:05 <mm_freak> is there any research on haskell with unlifted types?  i.e. with types without bottom?
11:13:21 <mm_freak> that would be a feature i would find great
11:13:25 <mvj2111> intro CS classes at harvard, penn, and probably others are using ocaml now
11:13:40 <mvj2111> and the jane street guys have been vocal evangelists
11:13:50 <copumpkin> byorgey: oh t,ath!
11:13:51 <copumpkin> that!
11:13:55 <copumpkin> (wtf?)
11:14:05 <mm_freak> mysticc: case … of … where myAction = …
11:14:39 <byorgey> t,ath   -- sounds like some sort of bloodthirsty deity
11:14:41 <mm_freak> > case 3 of 2 -> yes; 3 -> yes; 4 = "no" where yes = "yes"
11:14:42 <lambdabot>   <no location info>: parse error on input `='
11:14:47 <mysticc> mm_freak: ?? could not understand what you said
11:14:50 <mm_freak> > case 3 of { 2 -> yes; 3 -> yes; 4 = "no" } where yes = "yes"
11:14:50 <lambdabot>   <no location info>: parse error on input `='
11:14:54 <mm_freak> bah
11:14:57 <mm_freak> you get the point
11:15:02 <mm_freak> oh
11:15:06 <mm_freak> > case 3 of { 2 -> yes; 3 -> yes; 4 -> "no" } where yes = "yes"
11:15:06 <lambdabot>   <no location info>: parse error on input `where'
11:15:13 <mm_freak> ok, anyway
11:15:16 <byorgey> copumpkin: watch your language, you don't want to take t,ath's name in vain
11:15:21 <erus`> why is everyone calling a generic person "she" these days? i only see it in haskell related stuff...
11:15:22 <copumpkin> lol
11:15:32 <byorgey> lest he smite you
11:15:38 <copumpkin> byorgey: surely you mean "He"
11:15:41 <copumpkin> with an uppercase H
11:15:48 <copumpkin> erus`: maybe the haskell community is more sensitive to gender biases?
11:15:48 <mysticc> mm_freak: yeah now understood ...
11:15:49 * copumpkin shrugs
11:16:00 <byorgey> copumpkin: oh, t,ath! so I did!
11:16:11 <erus`> its PC gone mad
11:16:14 <mm_freak> erus`: because if that person is evil, you can point at a woman
11:16:24 <copumpkin> erus`: why is that any different from calling a generic person he? is that PC?
11:16:24 <erus`> OK that makes more sense :)
11:16:40 <rostayob> mm_freak: how would unlifted types + pattern matching work?
11:16:44 <rostayob> always irrefutable?
11:16:53 <erus`> copumpkin: usually you would try to catch the largest selection of the audience
11:16:58 <mm_freak> i think, the correct term for a generic person is "they"
11:17:16 <copumpkin> erus`: really?
11:17:36 <rostayob> mm_freak: and with seq too
11:17:37 <copumpkin> what's the point of that? so they can identify with the random person being spoken about in a technical article?
11:17:42 <mm_freak> rostayob: the unliftedness is about reduction, but yes, you would basically have to match all cases
11:17:52 <erus`> copumpkin: it just stands out when i read "she"
11:18:16 <copumpkin> erus`: oh, so we should be PC to appeal to your hypersensitivity to gender issues? ;)
11:18:17 <mm_freak> rostayob: just like in agda basically
11:18:29 <rostayob> mm_freak: I'm afraid I don't know agda yet :)
11:18:36 <rostayob> but does agda have seq?
11:18:38 <mm_freak> though i think in agda this is encoded in the type system, which is not the case for haskell
11:18:49 <erus`> copumpkin: i dont mind lol i just wonder why all haskell documents seem todo it
11:18:55 <mm_freak> in other words, you couldn't express the type of x = x
11:19:10 <copumpkin> erus`: because their authors think it's a nicer thing to do, and choose to do so
11:19:20 <rostayob> mm_freak: you mean giving up general recursion?
11:19:46 <rostayob> then haskell would be a very different language
11:20:01 <mm_freak> rostayob: giving up recursion without reduction…  you can't pass a list verbatim to a recursive call
11:20:11 * copumpkin is confused
11:20:12 <hpaste> morel pasted “cabal fails to install snap” at http://hpaste.org/53326
11:20:25 <erus`> Why stop there? They should think of the poor people who don't identify with either gender. When will they be acknowledged?
11:20:39 <erus`> Transgender people too
11:20:43 <mm_freak> rostayob: i think technically it means that you have to remove one constructor, before passing on
11:21:22 <rostayob> mm_freak: yeah I get what you're saying, but it would be a radically different language at the type level wouldn't it?
11:21:36 <copumpkin> erus`: #haskell-blah
11:21:53 <ski> mysticc : unfortunately yes, Haskell doesn't have disjunctive patterns (as O'Caml, and some SML implementations have)
11:21:59 <mm_freak> i think you can have this constraint, without having to change the type system, if there would be a way to declare types unlifted
11:22:26 <mm_freak> like:  add :: Num a => a -> a -> 'a
11:23:05 <mm_freak> perhaps it could be a feature of a special function type constructor
11:23:30 <mm_freak> sum :: Num a => a --> a
11:23:55 <rostayob> mm_freak: yeah but if you keep recursive types, you can still write expressions of type :: a
11:24:25 <rostayob> I mean does it make a big difference to eliminate recursion without reduction if you have recursive types?
11:24:45 <rostayob> you can always have infinite types, so reduction doesn't give you many properties - i suppose
11:25:27 <mm_freak> rostayob: infinite recursion is fine, but it has to be consuming or producing (corecursion)
11:25:40 <copumpkin> it has to be producing
11:26:06 <copumpkin> if you're just consuming something, you must terminate
11:26:15 <rostayob> mm_freak: mhm ok. what would be the advantages? that you know that your functions are "doing something" :P?
11:26:16 <mm_freak> copumpkin: if you consume codata?
11:26:28 <copumpkin> mm_freak: you have to produce codata as you go along
11:26:35 <copumpkin> > sum [1..]
11:26:39 <lambdabot>   mueval-core: Time limit exceeded
11:26:41 <copumpkin> that doesn't terminate or do anything productive
11:26:49 <mm_freak> ah, true
11:27:00 <copumpkin> > scanl1 (+) [1..]
11:27:02 <mm_freak> rostayob: it would catch certain errors at compile time
11:27:05 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
11:27:05 <copumpkin> that'd be allowed
11:27:09 <copumpkin> because it produces something
11:27:18 <mm_freak> i see…  so a codata consumer must use corecursion itself
11:27:40 <mm_freak> makes sense
11:27:42 <copumpkin> mm_freak: yeah, you might look at it as a codata observer more than a consumer
11:27:56 <JoeyA> You can't say unsafePerformIO $ atomically $ ... (well, maybe you can, but it's very unsafe).  Is it okay to spawn a thread in unsafePerformIO that does the atomically instead?  i.e. unsafePerformIO $ forkIO $ atomically $ ...
11:28:07 <ski> mm_freak : well, it could induct on inductive data, as well
11:28:20 <rostayob> mm_freak: like? wouldn't copumpkin example (sum [1..]) be valid in your model?
11:28:26 <mm_freak> copumpkin: anyway…  anything planned for haskell to support statically checked total functions?
11:28:38 <ski> mm_freak : `xs !! Zero = Head xs; xs !! Succ n = Tail xs !! n'
11:28:42 <mm_freak> rostayob: i have no model…  i'm just saying it's a great feature =)
11:28:43 <copumpkin> mm_freak: not that I know of :)
11:28:52 <copumpkin> it'd be an interesting project to think about
11:28:55 <mm_freak> ski: of course
11:28:56 <JoeyA> If you're wondering why I'd want to do something so crazy: I want to write log messages to a TChan, so they can be picked up by my application and handled.
11:29:26 <rostayob> mm_freak: yeah but what errors would you get? the fact that you'll never fail pattern matching?
11:29:31 <mm_freak> JoeyA: you don't need unsafePerformIO for that
11:29:53 <JoeyA> mm_freak: I want to have a log function that can be used from pure code, sort of like Debug.Trace.
11:30:37 <mm_freak> rostayob: the fact that your function terminates or is always productive…  one error it would catch is trying to sort/sum/last/… an infinite list
11:30:39 <JoeyA> If that pure code happens to be evaluated within an STM transaction, it will result in nested transactions.
11:30:52 <hpaste> morel pasted “cabal trying to install vector-0.9” at http://hpaste.org/53328
11:30:59 <JoeyA> (unless I do the forkIO thing or similar)
11:31:00 <rostayob> mm_freak: ok, so yes that the function is "doing something" in my words :P
11:31:02 <mm_freak> rostayob: i write a lot of long running programs, and sometimes i'd love to ensure that it will get to a conclusion at some point
11:31:16 <hpaste> morel pasted “cabal trying to install vector-0.9 #snap” at http://hpaste.org/53329
11:31:17 <rostayob> mm_freak: but I still don't get how you can ensure that with infinite types
11:31:26 <ski> JoeyA : as long as it can't be observed from non-`IO' code, and as long as you're ok with optimizations mangling your code to duplicate a trace or to merge traces, it should be fine
11:32:07 <rostayob> mm_freak: even if you always have to reduce, you can keep reducing forever (see sum [1..])
11:32:42 <mm_freak> JoeyA: never done that, sorry…  i'd have a very bad feeling about having something like that in production code
11:33:03 <ski> `sum [0 ..] :: CoNat' is fine
11:33:04 <JoeyA> I'll probably just not have a pure logging function.
11:33:16 <rostayob> ski: what's CoNat?
11:33:17 <mm_freak> rostayob: in agda 'sum' would have to be producing, too
11:33:19 <copumpkin> ski: yeah, that'd make it productive again
11:33:25 <rostayob> apart from remining me of vomit eheh
11:33:31 <copumpkin> we actually used to have Natural in lambdabot
11:33:34 <copumpkin> but it disappeared once
11:33:38 <copumpkin> we don't speak of those times anymore
11:33:41 <JoeyA> If I ever need one, I suppose I could write it to a regular Chan and have a thread consume it.
11:33:41 <ski> rostayob : like natural numbers, but with greatest fixpoint (i.e. coinductive) instead of least fixpoint (inductive)
11:33:46 <mm_freak> rostayob: have a lazy natural number type or something like that
11:34:17 <ski> rostayob : so, given a `CoNat' you can check whether it is `Zero', or it is `Succ n', for a new `CoNat' `n'
11:34:30 <ski> rostayob : and `inf = Succ inf' is a valid `CoNat'
11:34:47 <copumpkin> rostayob: lazy naturals, basically
11:34:53 <copumpkin> data CoNat = Zero | Suc CoNat
11:34:53 <rostayob> oh, ok. but enforcing reduction is not enough to make haskell have this property
11:35:47 <rostayob> yeah so is the classical numeral as defined aith ADT. I'm not sure I see how sum [1..] would be "producing" anyway...
11:36:00 <mm_freak> rostayob: the property i'm asking for is not ensured termination, but ensured productivity…  it may not be useful to you, but as said, i'm writing a lot of long running applications sometimes with complex data dependencies
11:36:06 <ski> rostayob : it will produce `Succ' after `Succ'
11:36:13 <mm_freak> haskell is very useful at catching errors here, but there are some errors, which still slip through
11:36:15 <rostayob> ski: oh, right.
11:36:35 <copumpkin> rostayob: it depends how addition is defined on that type
11:36:39 <copumpkin> and how the fold is happening
11:36:44 <copumpkin> since sum is foldl, it won't produce
11:36:55 <rostayob> mm_freak: I agree with you that it's a great property to have, I'm just saying that I don't see how just enforcing reduction make it happen
11:37:05 <copumpkin> but if sum were foldr, and addition on CoNat were only strict on its left argument
11:37:12 <copumpkin> then sum could be productive
11:37:17 <ski> *nod*
11:37:19 <mm_freak> rostayob: i didn't claim that anyway ;)
11:37:46 <rostayob> copumpkin: yep I see how that works now
11:38:44 <rostayob> is agda normalizing?
11:39:49 <copumpkin> yeah
11:40:25 <rostayob> I'll have to try that once I know a bit more about types
11:40:34 <copumpkin> it's actually pretty simple to play with
11:40:45 <copumpkin> its "model" is a lot more consistent than haskell's
11:40:47 <rostayob> but this new extension to ghc haskell will probably postpone that moment ehehe
11:41:05 * hackagebot hierarchical-clustering 0.4 - Fast algorithms for single, average/UPGMA and complete linkage clustering.  http://hackage.haskell.org/package/hierarchical-clustering-0.4 (FelipeLessa)
11:41:11 <rostayob> copumpkin: yeah but I'm a very practical person and I mostly learn by doing, and I'm not sure I can do much with agda
11:41:25 <copumpkin> sure you can, if you don't want to make programs that do IO
11:41:32 <copumpkin> :)
11:41:38 <copumpkin> you can do IO too, but it's less fun
11:41:47 <rostayob> and I can compile it to js! eheh
11:42:57 <copumpkin> http://www.haskell.org/haskellwiki/ItaloHaskell/Summer_2008
11:43:16 <rostayob> copumpkin: oh oh oh!
11:43:28 <copumpkin> revive it and get Saizan and xerox to go :P
11:43:33 <copumpkin> preflex: seen xerox
11:43:33 <preflex>  xerox was last seen on #perl 42 days, 5 hours, 12 minutes and 40 seconds ago, saying: woldrich: do you know how to nuke everything and start over with the perl modules via aur
11:43:54 <rostayob> copumpkin: the problem is that I don't live in Italy anymore ehe
11:43:58 <copumpkin> oh yeah
11:43:59 <rostayob> but I'd come if I can
11:44:10 <rostayob> and monterosso is nice
11:44:49 <rostayob> focaccia di recco yo
11:45:00 <rostayob> that's the main attraction for me in that area
11:45:11 <copumpkin> looks like the organizer was also not living in italy at the time :P
11:45:15 <copumpkin> since he has a +44 number
11:45:25 <rostayob> is someone livin in italy?
11:45:28 <rostayob> *living
11:45:30 <mm_freak> what's the current state of writing real world applications in agda?
11:45:49 <copumpkin> mm_freak: needs more people to push it :P you can write IO code but you need to FFI out to haskell for most things
11:45:56 <copumpkin> most of the agda writers don't really care about that sort of stuff yet
11:46:03 <mm_freak> i see
11:46:05 * hackagebot gsc-weighting 0.2 - Generic implementation of Gerstein/Sonnhammer/Chothia weighting.  http://hackage.haskell.org/package/gsc-weighting-0.2 (FelipeLessa)
11:46:16 <rostayob> yeah but, isn't agda a theorem prover? i don't think it was devised as a real-world programming language right?
11:46:19 <mm_freak> is there a sensible way to integrate agda modules into a haskell project?
11:46:24 <rostayob> no sorry a proof assistant
11:46:27 <rostayob> not theorem prover :P
11:46:40 <mm_freak> rostayob: you can use it as such, but i think the original idea was really to write algorithms
11:47:01 <rostayob> mhm... thinking about it I think that ML was created for a similar purpose
11:47:29 <rostayob> maybe in 30 years agda will be used in the real world, like ML!
11:47:32 <rostayob> ehe
11:48:01 <ski> ML was intended as a Meta-Language to write tactics for a theorem prover in
11:48:04 <stepcut> in my limited experience, writing real-world agda programs is not that different from Haskell
11:49:31 <copumpkin> yeah, although you might have to understand more to write programs that agda can see terminate
11:50:57 <mm_freak> is it possible to integrate algorithms in agda into a haskell project?  i know it's possible the other way around
11:51:28 <mm_freak> i'd write haskell mostly, but use the more powerful agda type system for some algorithms
11:51:56 <ski> i think you can extract Haskell code from an Agda program
11:53:01 <Saizan> MAlonzo compiles to haskell, but the toolchain might not be set up to provide you modules to use from haskell
11:55:20 <copumpkin> it just generates haskell files
11:55:32 <copumpkin> so you can probably just pull them into your project if you want
11:56:20 <mm_freak> great, i'll try that out
11:59:14 <copumpkin> mm_freak: keep in mind that you're an adventurer in a new land :P
11:59:36 <copumpkin> nobody has ever done much with malonzo
12:24:46 <mm_freak> copumpkin: alright =)
12:24:49 <mm_freak> well, there is another option
12:24:58 <mm_freak> does anyone have experience with idris in production?
12:25:09 <copumpkin> you can ask edwinb on other channels
12:25:12 <copumpkin> since he writes it
12:31:06 <hpaste> morel pasted “just a message to #snap: it works great!” at http://hpaste.org/53336
12:36:01 <shapr> I'm excited about constraint kinds letting me build compound typeclass synonyms.
12:36:26 <shapr> > type String a = (Show a,Read a)
12:36:27 <lambdabot>   <no location info>: parse error on input `type'
12:36:32 <shapr> > f :: String a => a -> a
12:36:34 <lambdabot>   Type constructor `GHC.Base.String' used as a class
12:36:38 <shapr> > f = read . show
12:36:39 <lambdabot>   <no location info>: parse error on input `='
12:36:42 <shapr> That's gonna be awesome!
12:36:58 <shapr> ybit: Right?
12:37:17 <shapr> Is anyone using GHC 7.4?
12:37:48 <copumpkin> I'm using a recentish build of 7.3 :)
12:37:53 <shapr> I've still got ghc 6.12 on my desktop :-( When will Ubuntu get updated?
12:38:01 <sipa1024> that sounds like an ubuntu version
12:38:04 <shachaf> shapr: I think the new version of Ubuntu uses GHC 7?
12:38:13 <shapr> Oh, perhaps I should update!
12:38:13 <copumpkin> screw distro builds
12:38:17 <copumpkin> why wait for them?
12:38:26 <shapr> I haven't had time to do much else.
12:39:04 <shapr> Anyway, I'm reading and enjoying http://hackage.haskell.org/trac/ghc/wiki/Status/Oct11 linked by copumpkin
12:39:08 <copumpkin> :)
12:39:13 <Cale> ^^ I agree with copumpkin. Even if your distribution has the latest version of GHC and the packages, it will have a tendency to swap them out from under you unexpectedly, which will cause all kinds of problems for locally installed packages when it happens.
12:39:13 <copumpkin> I stole it from byorgey
12:39:36 <shapr> So, what's up with the second part of the Contraint Kinds bullet point?
12:40:09 <copumpkin> it will finally let us have native restricted monads
12:40:11 <copumpkin> among other things
12:40:16 <shapr> I think it says that a typeclass can now include a typeclass constraint, is that right?
12:40:19 <copumpkin> or functors, or whatever else
12:40:26 <copumpkin> yeah, pretty much
12:41:01 <shapr> So, we could make a really fine-grained Numeric tower, and how the existing typeclasses still work, right?
12:41:27 <shapr> At least, at compile time.
12:41:38 <copumpkin> one thing missing from that is default superclass instances
12:41:42 <copumpkin> but that should be coming soon I think
12:41:51 <shapr> Where's that coming from?
12:42:31 <copumpkin> not sure, but there was some talk about it recently on one of the mailing lists
12:42:33 <copumpkin> can't remember where
12:43:28 <Peaker_> Most super-class constraints are implementable-given-subclass-method.  There are exceptions, such as Num and Eq/Show (which are often considered a bad thing!)  Are there some useful examples of subclasses that don't supercede the superclass power?
12:44:12 <shapr> Ooh, byorgey has been working with SPJ, Weirich and Dimitrios on optimizing GHC's type checker?
12:44:17 <shapr> byorgey++
12:44:19 <Peaker_> if Haskell were to separate superclass relationship such as Functor=>Applicative, and Eq=>Num -- how many of the latter kind would we have, and would they be a good idea?
12:44:39 <stribor> > readsPrec 1 "make"
12:44:40 <lambdabot>   []
12:44:48 <stribor> > readsPrec 0 "make"
12:44:50 <lambdabot>   []
12:45:12 <copumpkin> > readsPrec 0 "()"
12:45:13 <lambdabot>   [((),"")]
12:45:47 <stribor> why am i getting error when i do readsPrec  0 "myString"
12:46:19 <Guest2308> > readsPrec 0 "myString"
12:46:20 <lambdabot>   []
12:46:22 <copumpkin> what are you trying to read "myString" as?
12:46:24 <Guest2308> youre not
12:46:39 <copumpkin> > readsPrec 0 "\"myString\"" :: [(String,String)]
12:46:40 <stribor> > readsPrec 0 "make"::String
12:46:40 <lambdabot>   [("myString","")]
12:46:41 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:46:41 <lambdabot>         against inferred type...
12:47:15 <EvanR> :t readsPrec
12:47:15 <xrl> I'm committing my Haskell learnings to words, thought it might interesting to this crowd: http://xrl.tureus.com/haskell-and-binary-streams-parsing-with-field . Critiques are welcome (and may be necessary).
12:47:18 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
12:49:56 <shapr> xrl: Hey, this looks cool, thanks!
12:50:36 <shapr> xrl: Will you be trying with parsers other than attoparsec so you will be able to answer why you used attoparsec?
12:51:35 <shapr> xrl: You can do TDD with QuickCheck, sort of...
12:52:54 <hpaste> Hiroaki pasted “I try to learn” at http://hpaste.org/53337
12:53:10 <xrl> shapr: attoparsec is fine for now, I'm more interested in zmq than parsing. I'm aiming to do ZMQ inside of a halvm :)
12:53:14 <sm> how do I look up the maximum value of Int ?
12:53:24 <shachaf> > maxBound :: Int
12:53:24 <lambdabot>   9223372036854775807
12:53:33 <sm> that's it! thanks
12:53:40 <monochrom> hiroaki_: a `div` 2
12:54:11 <sm> and that's a suspicious number, lambdabot
12:54:21 <hiroaki_> but i want the rest of the division
12:54:27 <monochrom> > 2^63 :: Integer
12:54:28 <lambdabot>   9223372036854775808
12:54:30 <hiroaki_> 5 mod 2 = 1 right?
12:54:37 <monochrom> yes
12:55:27 <hiroaki_> i want to check if the number is even
12:55:31 * sm learns not to threadDelay for more than 35 minutes
12:56:05 <monochrom> your "if mod a 2 == 0" is already successfully checking even
12:56:16 <xrl> shapr: I'll probably expose the ZMQ functionality through a FFI. Maybe I can write a drop-in replacement for libzmq ;-)
12:56:27 <hiroaki_> but it does not work with hugs
12:56:48 <monochrom> what did you do, verbatim, that does not work?
12:57:28 <monochrom> preferrably as recorded by a keylogger and mouselogger
12:58:13 <hiroaki_> i gives an compiler error:
12:58:18 <hiroaki_> wait i got it
12:58:26 <hiroaki_> div does not work with Integer
12:58:29 <Cale> hiroaki_: You either want div a 2 or a `div` 2
12:58:35 <Cale> div does work with Integer
12:58:41 <monochrom> > div 394829304829384923084 2938493289489343
12:58:42 <lambdabot>   134364
12:58:50 <hiroaki_> o.k.
12:59:02 <monochrom> <monochrom> hiroaki_: a `div` 2
12:59:07 <hiroaki_> but it works with `quot` now
12:59:08 <Cale> Backticks turn an ordinary function name into an infix function
12:59:28 <Cale> div and mod go together, and quot and rem go together
12:59:30 <hiroaki_> ahhh, o.k.
12:59:31 * monochrom shakes head. why do people ask and not read answers
12:59:51 <hiroaki_> what is rem?
13:00:23 <Nisstyre> Can someone explain what's wrong with this code? http://codepad.org/9r6iZW5I I'm just not getting why it doesn't work right now
13:00:29 <Nisstyre> the error message is included there
13:01:03 <Nisstyre> I translated this from someone's JS code, so that's why I have the retarded names
13:02:01 <Cale> hiroaki_: stands for remainder
13:02:27 <Cale> hiroaki_: It's the same thing as mod, except it has a different convention with respect to how it handles negative numbers
13:02:36 <Cale> > (-1) `mod` 5
13:02:38 <lambdabot>   4
13:02:41 <Cale> > (-1) `rem` 5
13:02:42 <lambdabot>   -1
13:02:50 <Cale> > (-1) `div` 5
13:02:51 <lambdabot>   -1
13:02:55 <Cale> > (-1) `quot` 5
13:02:56 <lambdabot>   0
13:03:09 <hiroaki_> ah, now i got it. thank you very much
13:04:54 <Cale> 99% of the time, div and mod are what you actually want to calculate, but quot and rem apparently often have a faster implementation in hardware
13:33:11 <brisingr> Any references for learning graphs? the monad.reader issue 5 and source code are rather obscure
13:33:24 <brisingr> I know the best way to learn it is source code, but still
13:33:46 <rekahsoft> hi all..just been playing around with implementing binary search tree's in haskell..its definitly been a good way to see the beauty of haskell and the awesome parallels beween hsakell and mathematics
13:34:44 <rekahsoft> now my one question is that i have a data type called Tree has two value contructors..one being Empty and the other representing a Node a (Tree a) (Tree a)..
13:34:51 <dmos> I've embarked on the quest to install lambdabot which seems to be some sort of rite of passage...
13:35:36 <dmos> I saw the ordeal DanBurton went through some days ago to get it running on 7.2, I on the other hand am trying to get it going on the current haskell platform. Do I have to expect the same problems he encountered or were those mostly caused by ghc 7.2 upgrades.
13:36:06 <rekahsoft> now my question is: i have a function node that i want users to be able to use..if enforces the orderability property of BSD's..so i want to only export the Empty Value constructor for users and instead of them directly using the Node value constructor they are to use the node function
13:36:27 <rekahsoft> i can put the code up if that will help i just figured it was a pretty simple fix..
13:36:33 <brisingr> dmos: you have to expect manually installing dependencies
13:37:14 <brisingr> also, get mueval-core, without it the ">" evaluation is pretty garbage
13:37:44 <brisingr> the problem is lambdabot calls mueval using two parameters
13:37:48 <brisingr> can't remember which
13:37:56 <rekahsoft> currently i have module BinarySearchTree (Tree (Empty), node, etc..) in hopes that when exporting the Tree datatype it would onlt export the value contructor Empty but it seems to be exporting both?
13:38:02 <dmos> Did that for mueval (darcs), but mueval and lambdabot fight over the mtl dependency (mueval wants 1, lb 2)
13:38:05 <brisingr> that have been changed from "--foobar" to "--foo-bar"
13:38:05 <hpc> brisingr: lambdabot calls the mueval binary
13:38:21 <hpc> using System.Process or something like that
13:38:22 <brisingr> hpc: right
13:38:31 <rekahsoft> let me just go check to ensure that its not because i loaded the old file in the same ghci and Node is just hanging around residually
13:38:47 <hpc> with params to set extensions, a whoooooole bunch of imports, and then finally the expression
13:38:54 <hpc> iirc that's it
13:38:58 <brisingr> the problem is, it has commands "--foobar" and "--blabaz" in the old version and "--foo-bar" and "--bla-baz" in the new one
13:39:07 <brisingr> (not actually called like that)
13:39:17 <brisingr> and lambdabot calles "--foobar" and "--bla-baz"
13:39:17 <dmos> hpc: so If I remove the mueval dependency, then it should work (as it just calls out to the installed binary)?
13:39:38 <hpc> dmos: in theory, yes
13:39:49 <dmos> ok, trying that.
13:40:03 <brisingr> no, wait, that was quickcheck
13:40:06 <hpc> i found out the hard way that calling mueval as a library function puts the responsibility on you to catch exceptions
13:40:17 <brisingr> installing lambdabot is up there with explaining monads
13:40:35 <hpc> brisingr: installing lambdabot is up there with uninstalling norton antivirus
13:40:49 <hpc> let's not kid ourselves, monads are far easier
13:41:11 <brisingr> you can reinstall the os and get rid of norton. if you reinstall the os lambdabot isn't magically there
13:41:21 <hpc> brisingr: it should be :P
13:41:36 <brisingr> we should write something called lambdabOS
13:41:49 <hpc> brisingr: lambDOS
13:42:21 <brisingr> actually I intend to make a custom debian-based live distro designed specifically for haskell
13:42:34 <brisingr> with lambdabot and everything
13:42:47 <erus`> haskell on debain...
13:43:18 <brisingr> can't convince myself to do it. experience says that it's faster to create a linux distro from scratch than to install lambdabot
13:43:56 <erus`> im gonna rewrite lambdabot in python
13:44:55 <brisingr> I'm gonna make vixen a one-liner in order to invoke it using "> ". THEN WE WILL BECOME UNSTOPPABLE
13:46:09 <brisingr> seriously though, where are my graphs??
13:46:15 <brisingr> I want my graphs
13:46:26 <dmos> speaking of rewriting lambdabot, there's some vague mention of a lambdabot2 effort. Is that vaporware or is something brewing?
13:46:39 <companion_cube> it has a dependency on hurd
13:46:43 <companion_cube> oh, wait
13:46:59 <brisingr> seriously, if lambdabot2 is gonna be alive
13:47:02 <brisingr> I wanna be part of it
13:47:24 <brisingr> complete with a new revamped vixen and polymorphic nicknames
13:48:13 <brisingr> yes lambdanaut. FLEE SO LAMBDABOT CAN USE YOUR NICK
13:48:32 <brisingr> we might as well make lambdabot distributed
13:57:08 <joep> good evening. am i right in thinking that a large class of functions, such as map, zip and so on, can be implemented using folds? Does anyone have a link to an online paper or list of functions expressed as folds?
13:59:02 <shapr> joep: Tried asking google scholar for "haskell fold" ?
13:59:08 <iande> joep: you are correct, let me see if I can fid you a proper link
13:59:11 <sadger> map' :: (a -> b) -> [a] -> [b]
13:59:14 <sadger> map' f xs = foldr (\x acc -> f x : acc) [] xs
13:59:19 <sadger> take from learn you a haskell
13:59:24 <sadger> http://learnyouahaskell.com/higher-order-functions
13:59:29 <iande> n/m, sadger's got it
13:59:35 <sadger> :)
13:59:43 <sadger> knew i saw it somewhere
13:59:49 <ddarius> map f = foldr ((:) . f) []
13:59:51 <erus`> you can make filter/reduce with a fold?
14:00:08 <sadger> on the same page you also get
14:00:11 <sadger> maximum' :: (Ord a) => [a] -> a
14:00:13 <sadger> maximum' = foldr1 (\x acc -> if x > acc then x else acc)
14:00:17 <sadger> reverse' :: [a] -> [a]
14:00:19 <sadger> reverse' = foldl (\acc x -> x : acc) []
14:00:23 <sadger> product' :: (Num a) => [a] -> a
14:00:25 <sadger> product' = foldr1 (*)
14:00:29 <sadger> filter' :: (a -> Bool) -> [a
14:00:31 <sadger> and so on
14:00:34 <ciaranm> erus`: filter/reduce is just a catamorphism, isn't it?
14:00:36 <sadger> ah it didnt paste very well
14:00:51 <joep> sadger: thanks there a quite a few listed there
14:01:17 <sadger> no problem that is a good book btw free online
14:01:43 <erus`> i have an idea brewing for an esoteric language with only fold :P
14:01:46 <iande> I'll second that, the printed version is worth its price, too
14:02:14 <ciaranm> the printed version includes at least one fairly horrible error
14:02:22 <iande> plus, it comes with stickers
14:02:22 <ddarius> erus`: See Charity.
14:02:27 <joep> erus`: yeah, i'm using fold as a primitive for some research i'm doing, so i'm reexpressing everything else as folds. just saving my brain some pain by looking them up
14:02:32 <ciaranm> wait. stickers?
14:02:36 <iande> haha
14:02:51 <iande> mine did, including an octopus one
14:03:05 <iande> but, yeah there are a couple typos, and I remember seeing one jarring error...
14:03:14 <ciaranm> joep: know about banana brackets / catamorphisms? they're usually a nicer primitive than fold
14:04:03 <erus`> ddarius: you have a url?
14:04:09 <ddarius> zip = foldr (\x xs ys -> case ys of [] -> []; y:ys' -> (x,y):xs ys') (const [])
14:04:17 <ddarius> @google Charity programming language
14:04:18 <lambdabot> http://en.wikipedia.org/wiki/Charity_(programming_language)
14:04:18 <lambdabot> Title: Charity (programming language) - Wikipedia, the free encyclopedia
14:04:45 <ddarius> ciaranm: "Catamorphism" is just another word for fold.
14:05:17 <shachaf> Is foldl a catamorphism?
14:05:20 <ciaranm> ddarius: no! catamorphism is the generalisation of fold!
14:05:39 <shachaf> ciaranm: How is it the generalisation?
14:05:41 <shachaf> "fold" isn't limited to lists.
14:05:44 <ddarius> shachaf: Yes and no.  It can be expressed with foldr, but it isn't itself a fold.
14:06:04 <shachaf> "It can be expressed with foldr" means that it's a list operation, more or less. :-)
14:06:06 <ciaranm> schroedinbug: catamorphisms aren't limited to Hask
14:06:18 <ciaranm> er, not schroedinbug. shachaf.
14:06:32 <shachaf> And folds are?
14:06:49 <joep> ddarius: can i turn that into zipWith as     zipWith f = foldr (\x xs ys -> case ys of [] -> []; y:ys' -> (f (x,y) xs) ys') (const [])
14:07:02 <ciaranm> unless you want to spend lots of time generalising folds yourself, then yes
14:07:27 <shachaf> joep: zipWith has no reason to use tuples anywhere.
14:07:32 <mkscrg> so i've got a 3-param typeclass with two functions, each of which involves 2 of the 3 types. this causes some ambiguous type variable errors from ghc. how do i do this?
14:07:36 <ddarius> Categorists are more likely to understand the term "fold" than "catamorphism."  The term "catamorphism" comes from the Squiggolist school which were basically proto-Haskell programmers.  It is not widely used.
14:08:19 <ddarius> I personally would lilke the "catamorphism" etc. language to die.
14:09:48 <shachaf> And replaced with what?
14:10:22 <dylex> mkscrg: functional dependencies might be what you need, if the one of the arguments fully determines another one: class Foo a b c | a b -> c where ...
14:10:25 <ddarius> shachaf: Fold and unfold as they already are.
14:10:39 <shachaf> What about all the other foomorphisms?
14:11:07 <ddarius> shachaf: If I said "Oh, that is a zygomorphism" would you immediately know what I meant?
14:11:32 <shachaf> No.
14:11:41 <ddarius> shachaf: So what use is the terminology?
14:12:21 <ciaranm> if you said to a c++ programmer "oh, that is a functor" would they know what you meant?
14:12:27 <shachaf> Presumably there exist people who would. I don't know what a zygomorphism is, but that doesn't necessarily mean there shouldn't be a word for it.
14:13:03 <ciaranm> if you said "oh, that is a natural transformation" you'd probably lose half the people in here. that doesn't mean it's a bad term.
14:13:05 <companion_cube> if you said to a php programmer "oh, that is a module", would they know what you are talking about?
14:13:08 <shlevy> Why can't you encode to a lazy bytestring from cereal?
14:14:00 <hpaste> mkscrg pasted “MultiParamTypeClasses with ambiguous type variables” at http://hpaste.org/53339
14:14:04 <ddarius> ciaranm: Yes, but this "zygomorphism" terminology is basically used only by Haskellers and yet the vast majority of them get absolutely no information from it.  I'm not using this term outside its audience.  It has no audience.
14:14:11 <mkscrg> dylex: you may be right, but here's a clarifying paste: http://hpaste.org/53339
14:14:54 <ciaranm> ddarius: that's an argument for better education and making it harder to code without understanding things, not an argument against the term
14:15:09 <edwardk> ciaranm: which term?
14:15:20 <mkscrg> dylex: I get ambiguous type variable errors because uniqueChildId doesn't specify parent in its signature
14:15:23 <ciaranm> edwardk: *morphism for some value of *
14:15:24 <mkscrg> (i think)
14:16:02 <edwardk> like zygohistomorphic prepromorphism?
14:16:14 <smoge> Hi!
14:16:26 <smoge> How can I get the prime factors of integer N ?
14:16:39 <companion_cube> smoge: this is not a primitive
14:16:43 <companion_cube> you  have to write code
14:16:52 <edwardk> smoge: loop over all the numbers up to square root of n and keep trying to divide
14:16:52 <smoge> do you know a implementation?
14:16:58 <shachaf> You could use someone else's code.
14:16:59 <ciaranm> zygohistomorphic prepromorphisms are only one step sillier than ruby's Enumerable#each_with_index.
14:17:00 <FUZxxl> smoge: Check out:
14:17:03 <FUZxxl> @hoogle primes
14:17:03 <lambdabot> No results found
14:17:05 <shachaf> @google haskell prime factors
14:17:06 <lambdabot> http://www.haskell.org/haskellwiki/99_questions/31_to_41
14:17:06 <lambdabot> Title: 99 questions/31 to 41 - HaskellWiki
14:17:07 <FUZxxl> @hoogle isPrime
14:17:07 <lambdabot> No results found
14:17:28 <iande> on the topic of the underlying category theory of haskell, does anyone have any good book recommendations for category theory in general?
14:17:30 <dylex> mkscrg: Well, "| parent -> child, child -> childid" will fix that, but will add additional restrictions to which instances you can make
14:17:31 <shachaf> ciaranm: #each_with_index isn't that silly, in the context of Ruby, is it?
14:17:37 <ciaranm> it's just that people are given a basic intuition about block control structures in intro to programming classes, but they're not taught about the recursion equivalent
14:17:39 <FUZxxl> @hoogle Data.Numbers.Primes
14:17:39 <lambdabot> No results found
14:17:42 <FUZxxl> wtf
14:17:59 <ciaranm> shachaf: right. but each_with_index_and_helper_function probably would be.
14:18:00 <edwardk> only one? i'm pretty sure that at least someone somewhere has used Enumerable#each_with_index in anger. i've yet to see a zygohistomorphic prepromorphism in the wild *and i coined the term*
14:18:11 <FUZxxl> smoge: Okay. Check this out: http://hackage.haskell.org/packages/archive/primes/0.1.1/doc/html/Data-Numbers-Primes.html
14:18:17 <iande> ciaranm: #each_with_object
14:18:24 <FUZxxl> you have to install the primes package first, rhough.
14:18:30 <shlevy> Hmm, Data.Binary uses lazy bytestrings. Any other differences between cereal and Binary?
14:18:35 <iande> in my opinion, that was a silly addition given the existence of #inject
14:18:53 <shachaf> ciaranm: Didn't Ruby 1.9's Enumerable get rid of the each_with_index thing, anyway?
14:19:15 <shachaf> iande: inject is very different, isn't it?
14:19:16 <iande> shachaf: no, #each_with_index is still in 1.9.2
14:19:23 <ciaranm> iande: #inject is just a catamorphism!
14:19:25 <FUZxxl> oops.... I gave you the wrong link.
14:19:27 <iande> shachaf: inject is roughly equivalent to foldl
14:19:36 <FUZxxl> The right one is http://hackage.haskell.org/packages/archive/primes/latest/doc/html/Data-Numbers-Primes.html
14:19:39 <iande> ciaranm: haha, so I've gathered :P
14:19:53 <shachaf> iande: Right. Whereas presumably each_with_object implies -- oh, I misunderstood.
14:20:08 <shachaf> What's the point of each_with_object, then?
14:20:14 <iande> shachaf: it's mostly about the ultimate return value of the function
14:20:16 <shachaf> Ah, in-place mutation?
14:20:49 <iande> which can be done with #inject, but the return value is ultimately the accumulator, whereas #each_with_object returns the collection again, like #each
14:21:08 <shachaf> Oh.
14:21:53 <kstt`> hi
14:22:19 <iande> but, anyway, I would like to learn more about category theory in general
14:22:35 <ddarius> ciaranm: Teaching people this terminology would be like teaching them the language of some small tribe that no longer exists.  All it does it put up barriers to communication, and I can assure you, you won't gain much from it.  Even the tribe rarely used anything beyond the basics.
14:22:37 <ciaranm> here's the thing, though: ruby gets away with having lots of fancy goto-replacing control structures, many of which have unobvious names like "inject", and many of which are extremely specific specialisations. doing the same for recursion should be a good thing.
14:23:24 <ciaranm> ddarius: some terminology has to be selected. the concepts are useful enough to have names.
14:23:31 <ddarius> We should make unobvious names for recursion patterns people don't use and you say this is a good thing?
14:23:38 <kstt`> why isn't cabal simply bound to a ghc install with all packages kept alongside ? Inspite of my infinite effort to prevent cabal-install from breaking, it keeps getting confused in trivial situations.
14:24:02 <ciaranm> the names are arbitrary. we have to learn them, just like we have to learn every other name.
14:24:07 <mkscrg> dylex: just read the wiki page on fundeps. looks like what i need. thanks
14:24:15 <ciaranm> "class" and "object" and "method" aren't exactly obvious...
14:24:23 <ddarius> ciaranm: Yes, fold and unfold are foundationally important.  Paramorphism is "fold with parameter" and apomorphism is "unfold with early termination" and hylomorphism is "fold of unfold" beyond that, the terminology was essentially never used.
14:24:27 <ghosting> Could I use Maybe for every case that may exist in my program
14:24:56 <ddarius> ciaranm: Yes, but there is a large group of people that know what those mean.  No one uses the term zygomorphism.
14:25:19 <c_wraith> edwardk doesn't count :)
14:25:23 <ciaranm> ddarius: there's a large group now. twenty years ago that wasn't the case.
14:25:49 <ddarius> No, twenty years ago there was a large group.  Not as large, but still quite large.  Entire communities.
14:25:52 <edwardk> ciaranm: tarmo uustalu who did as much as anyone to foster the adoption of them hates them
14:26:47 <ddarius> ciaranm: I'm saying literally -no one- uses this terminology.
14:27:01 <Nimatek> Speaking of them in terms of folds and undfolds is much better, really.
14:27:07 <edwardk> ciaranm: catamorphism/anamorphism are useful, its neat that there is a generalized scheme given a monad or a comonad and a distributive law by which you can extend each, but the others really don't occupy a _useful_ space.
14:27:43 <edwardk> paramorphisms are probably the edge of usefulness for this abstraction because they arise in various induction principles
14:28:16 <ddarius> edwardk: Yes, but that can be described as "fold with parameter" or (if you don't have higher order functions) "primitive recursion."
14:28:22 <edwardk> its not just that the others aren't understood. they _have_ been understood, they've just been found wanting
14:28:45 <edwardk> yep
14:29:00 <ciaranm> have a look at ruby's insanely long list of block-based control abstractions that people actively use. recursion should be treatable the same way.
14:29:51 <edwardk> we do, we have mapM, forM, sequence, traverse, etc. those are useful, the non-trivial foomorphisms? not so much
14:30:07 <ddarius> ciaranm: a) I don't want insanely long lists of things, I want small lists of composable things, b) I don't care what ruby does, c) even if we want an insanely long list of specific recursion schemes, the *morphism terminology is still not what should be used to describe them.
14:30:22 <edwardk> i gave a language for describing the composition of these things, by building up monad transformers and composite distributive laws, but the result wasn't actually useful for modeling what people want to do
14:30:54 <edwardk> the names are a historical accident because lambert meertens liked greek and latin roots. when there were 3 it was a forgivable quirk
14:31:20 <edwardk> now that there are 20 and they can be composed? not so much
14:31:41 <aristid> edwardk: how could they be named better?
14:31:46 <Nimatek> Many of them are redundant, especially forM.
14:31:46 <ciaranm> so you want a small set of composable things, and you don't want the names to be composable?
14:32:13 <edwardk> ciaranm: i like the names being composable. i just think that they are crappy names
14:33:01 <kstt`> ciaranm: I know ruby quiet well but fail to see your point about recursion.
14:33:04 <ddarius> ciaranm: How is "hylo" more composable than "foldUnfold" ?
14:33:17 <ciaranm> most of maths is built upon crappy names. it's just that some of those crappy names have been around for long enough that we're used to them.
14:33:20 <edwardk> or refold
14:33:36 <mercury^> Yeah, ‘refold’ is excellent.
14:33:47 <edwardk> ciaranm: the difference here is you have about 8 people who use this formalism in anger. ;)
14:33:55 * ddarius has never seen paraparamorphism.
14:33:58 <edwardk> so the concrete hasn't set yet
14:34:16 <ddarius> edwardk: And those 8 people moved on to other things about 20 years ago.
14:34:20 <edwardk> yep
14:34:30 * Saizan wants a kerokeromorphism
14:34:35 <edwardk> you occasionally get a paper by hinze or one by gibbons that still uses the names
14:34:39 <edwardk> and thats it
14:34:48 <edwardk> uustalu and vene have decided the whole thing was a bad idea
14:35:05 <ciaranm> kstt`: if you think of goto as a primitive, while, for etc as being a first level abstraction and all the stuff in Enumerable as a second level, then you can think of explicit recursion as being like goto, folds or whatever we call them as being the second level and the composed stuff as being the third level
14:35:07 <edwardk> and meertens, meijer and fokkinga have better things to do
14:35:17 <tomprince> I would say that there are too many of them for pepople to usefully remember them,.
14:35:31 <ciaranm> then someone should come up with a list of good names to use and stick them in a widely read paper before it's too late!
14:35:52 <edwardk> ciaranm: well, the problem is their original selling point was hylo fusion, but that never panned out
14:35:58 <edwardk> so there isn't a compelling _usecase_
14:36:20 <edwardk> and there is no real point in developing the theory more until there is
14:36:42 <geekosaur> I have to dig out a math text to figure them out... which means I'm more likely to reimplement them with a name I can remember
14:36:59 <edwardk> if you look at stuff like the stream fusion we use, its basically a glorified form of destroy/unfoldr fusion
14:37:13 <edwardk> geekosaur: worse, there isn't a math text on the topic
14:37:19 <ciaranm> i don't see how "fold" is any more obvious than "cata"
14:37:23 <edwardk> geekosaur: you have a chapter on meijer's dissertation
14:37:24 <kstt`> geekosaur: you can also alias them in a "MyVocabulary.hs" module
14:37:27 <Saizan> the point is that, additionally, reimplementing them would be a bad design decision
14:37:44 <edwardk> and then you have a chapter here and there in fokkinga's dissertation, and a few papers by vene
14:37:49 <ddarius> ciaranm: It is slightly more intuitive, but even if it isn't.  It is more widely used and less pretentious.
14:38:25 <edwardk> ciaranm: like i said, cata vs fold isn't bad, but the vocabulary of the pseudo-greek/latin roots doesn't scale and actively gets in the way of comprehension
14:38:27 <ddarius> ciaranm: Do you know what "cata" means by the way?
14:38:30 <Nimatek> ciaranm: It's even more intuitive than 'reduce' imo.
14:38:31 <Saizan> the only downside of fold is that you have to specify "not the list fold, and no not even the Foldable fold"
14:38:37 <edwardk> and it isn't even that orthogonal
14:38:50 <edwardk> there are at least two generalized apomorphisms needed
14:38:52 <ciaranm> ddarius: same as "catastrophe"!
14:38:57 <ddarius> ciaranm: Which means?
14:39:05 <ciaranm> ddarius: to fall down
14:39:18 <edwardk> ciaranm: which is exactly what that terminology is doing on the job ;)
14:39:31 <ddarius> ciaranm: So "cata" means?
14:39:49 <aristid> cata means tasting
14:40:12 <aristid> google translate says so, so it must be true
14:40:19 <aristid> it's spanish
14:40:24 <ciaranm> if you "fold" something you end up with the same thing in a different shape. if you "cata" it you end up with a big thing squished into a little thing.
14:40:55 <ddarius> "cata" means down/downward.  (And incidentally, "strophe" means step.)
14:41:17 <edwardk> kata- and ana- are fine, hylo- is questionable, para-, zygo-? histo-? futu-? dyna-? apo-? gapo-? ggapo-? chrono-? and two different metamorphisms, etc.
14:41:42 <aristid> kataanahyloparazygohistofutudynaapogapoggapochronomorphism
14:41:54 <brisingr> are they mathematical names
14:42:01 <ddarius> brisingr: No.
14:42:17 <brisingr> that explains why my math teacher doesn't know about them
14:42:18 <edwardk> brisingr: they are names coined by one random computer scientist who had grad students
14:42:59 <edwardk> brisingr: his grad students have all grown up and moved out into industry rather than remain in academia, so there really from a school of thought standpoint they 'died childless'
14:43:00 <ddarius> brisingr: The people who could tell you what a "futumorphism" is off the top of their head, can be counted on one hand.
14:43:09 <aristid> edwardk: you used them in category-extras, so you didn't always hate these names?
14:43:25 <shlevy> Does the lazy ByteString's writeFile not write lazily? I'm not seeing the file show up in the filesystem as my program runs.
14:43:26 <edwardk> i added them to category extras to understand the terminology. it wasn't an endorsement
14:43:28 <brisingr> ddarius: you can count 31 people on one hand
14:43:44 <ddarius> brisingr: Name six of these 31 people.
14:43:53 <aristid> edwardk: and in the process you learned that they were not optimal?
14:43:58 <edwardk> yes
14:44:05 <brisingr> Cale, Cale, Cale, Cale, Cale and Cale
14:44:10 <Cale> wat
14:44:16 <edwardk> i repackaged them in recursion-schemes and largely forgot about them =P
14:44:24 <aristid> Cale: you count as 31 people.
14:44:26 <ddarius> I'm going to say Cale doesn't know what a futumorphism is off the top of his head.
14:44:32 <geekosaur> I think e was snarking about counting in binary not claiming 31 greekomorphism freaks exist
14:44:38 <brisingr> Cale, you are the 6 people who know what "futumorphisms" means off the top of their heads
14:44:40 <Cale> ddarius: you are correct
14:44:47 <brisingr> damn
14:45:02 <aristid> > 2^5
14:45:03 <lambdabot>   32
14:45:10 <edwardk> i do and have even used them effectively, but i don't find them to be an effective way to think about problems
14:45:15 <Cale> In fact, I've never bothered to understand futumorphisms, apart from determining that they're some sort of recursion scheme.
14:45:16 <aristid> can't you count 32 people on one hand?
14:45:33 <brisingr> if you count 32 you can't count zero
14:45:35 <ddarius> aristid: If you don't include counting 0.
14:45:35 <brisingr> which is bad
14:45:43 <ciaranm> and in the mean time people are still mixing in recursion logic with working stuff out logic
14:45:49 <aristid> ddarius: that sounds like a wasteful decision
14:45:50 <edwardk> a futumorphism is basically an anamorphism that can build multiple layers at a time because it returns the answer in the form of a free monad of the base functor
14:46:33 <aristid> if you say so
14:47:54 <edwardk> it is the less useful bastard cousin of the histomorphism which can see a cofree comonad of context, and so gets used when you want to tie yourself in knots trying to think through dynamic programming problems that way
14:47:58 <Cale> I'm sold on (at least specialised) catamorphisms being a good idea for general code, but past that the usefulness of giving names to these things starts to get dubious quickly.
14:48:22 <edwardk> and histomorphisms are already the territory of bored graduate students
14:49:07 <Cale> If I have a recursion scheme which only shows up in 1/100000 of the code I write, it's actually probably better for readability to just write the recursive definition in a direct style.
14:49:08 <kmc_> brisingr, they're mathematical names in a sense
14:49:12 <kmc_> i mean, what is math
14:49:14 <edwardk> cale++
14:49:33 <kmc_> higher math has so many subfields with so much specialized terminology
14:49:51 <edwardk> kmc_: yes, but there are more names in this field than practitioners ;)
14:49:58 <ciaranm> if you have an iteration scheme that shows up in only one place, would you recommend goto?
14:50:02 <kmc_> hehe
14:50:06 <edwardk> and almost as many names as there are examples
14:50:13 <brisingr> kmc_: I mean like "official" math. haskell is "in a dark corner selling cocaine" type of math
14:50:23 <ddarius> ciaranm: That is actually what -is- recommended.
14:50:28 <kmc_> ciaranm, in most languages you can't write new iteration schemes
14:50:29 <aristid> oO
14:50:45 <kmc_> so you don't have a choice
14:50:45 <edwardk> ciaranm: the problem is that naming something a zygoprepromorphism doesn't help you implement it or reason about it
14:51:14 <kmc_> brisingr, what's "official" math then?
14:51:27 <edwardk> it makes someone go dig up fokkinga's thesis, puzzle through 200 pages, and then come back to read 5 lines of code
14:51:37 <hpc> kmc_: it's the kind that doesn't pay well
14:51:50 <brisingr> the stuff you find in a math textbook in a resp...
14:51:51 <brisingr> gah
14:51:55 <edwardk> oh and then they have to go grab category-extras to puzzle through how you compose zygo and prepro
14:51:57 <hpc> :D
14:51:59 <tech2> Is there a reason they can't have the names but not be a part of a general library?  These things do have to have names, and I guess they have to be described somewhere (that's the problem with language really, it's only useful as a means of describing things when more than one party is involved)
14:51:59 <Cale> ciaranm: I suppose perhaps. There are only so many ways you tend to be able to do something and still call it "iteration" though, and I think they're covered for the most part by reasonably common control structures.
14:52:00 <brisingr> official math is the one #math won't lynch you for
14:52:05 <kmc_> heh brisingr
14:52:06 <edwardk> then they can read the 5 lines
14:52:20 <kmc_> brisingr, so nothing of category theory is official math?
14:52:29 <ddarius> brisbin: #math will lynch you for a lot of actual math.
14:52:33 <kmc_> brisingr, 'cause I've heard #math has started turning away CT questions
14:52:34 <brisingr> not if you mention haskell it isn't
14:52:37 <ciaranm> Cale: sure, and most recursion is just a fold
14:52:39 <Cale> If #math gives you problems, please let me know
14:52:40 <kmc_> because of those fucking haskell weenies
14:52:50 <Cale> I'm an op there, but I don't watch the channel as much as I used to.
14:53:16 <Cale> and so I'm afraid it's sort of become less friendly than it used to be
14:53:25 <edwardk> tech2: the real question is what value do the names add here? the gang of four design patterns all talk about things that happen over and over again in real code. zygomorphisms don't just happen in your code typically ;)
14:53:26 <kmc> ciaranm, anyway the alternative to mapM isn't goto, it's explicit recursion
14:53:37 <kmc> and the same in other languages, to greater or lesser degree
14:53:40 <edwardk> and if they do, the insight that it is a zygomorphism doesn't lead to better ways to implement it
14:53:47 <kmc> rolling your own iteration functions as HOFs is not unheard of in other languages
14:53:52 <brisingr> Cale, don't worry, there was a couple of months ago a guy who told me to gtfo, but still... I kinda understand the guy
14:54:14 <brisingr> (and it's not stockholm syndrome)
14:54:26 <ddarius> brisingr: That's what they all say.
14:54:33 <stribor> i saw few example sonline where it says type Parser a b = ....
14:54:36 <edwardk> anyways, off to the movies
14:54:41 <edwardk> later
14:54:41 <stribor> what is a and b for
14:54:44 <ddarius> I don't see how someone saying gtfo is a kidnapper.
14:55:16 <Cale> stribor: b will typically be the type of the result of the parser (what structure it has turned the input into)
14:55:26 <ski> stribor : do you understand `data Maybe a = Nothing | Just a' ?
14:55:28 <Cale> stribor: a could be different things depending on the library
14:55:39 <Cale> stribor: But maybe the type of the input
14:55:40 <stribor> ski: yes
14:55:45 <stribor> what about a then?
14:56:07 <stribor> oh ok
14:56:09 <ski> stribor : `a' is possibly the type of tokens the parsers will parse
14:57:13 <tech2> edwardk: GoF fits for particular languages, agreed. I take the point. But you need to describe these things _somehow_ and they need to be written down _somewhere_. So, either we use words others have used before us, or we make things up and make sure others _start_ using them. We can't just take the 3rd option of not describing something at all though can we?
14:57:36 <ddarius> tech2: Sure we can.
14:57:37 <ski> (stribor : i was unsure whether you were asking about what type parameters were, or about what roles `a' and `b' in that specific case had)
14:57:48 <stribor> type myParser  a b = [a] -> b
14:57:57 <stribor> can anyone explain this example
14:58:06 <ddarius> It's a syntax error.
14:58:14 <tech2> ddarius: so, we just stop talking about it then? :)
14:58:21 <ddarius> tech2: That would be nice.
14:58:53 <ski> stribor : `[a] -> b' isn't so useful generally as a parser type, since there's no way for such parsers to signal parse failure
14:59:06 <ddarius> Also, we have a way to describe them.  Code.  Just like the Gang of Four patterns before, during, and after the publication of the book.
14:59:10 <stribor> ski: i just wants to know that this definition means
14:59:27 <ciaranm> you can describe iteration using "jump" instructions
14:59:29 <Eduard_Munteanu> Types must start with an uppercase letter.
14:59:35 <kstt`> stribor: it does not mean much
14:59:42 <shlevy> Is Traversal.mapM particularly unlazy?   dataMap <- Traversable.mapM (Traversable.mapM (extractHashes . extractPackageIdentifier)) hackage
14:59:45 <shlevy>   ByteString.putStrLn $ encode (elemAt 0 dataMap)
14:59:45 <shlevy> whoops
14:59:54 <ddarius> tech2: There's also no need to "make sure others start using them."  If they are useful, they will start being used.
14:59:56 <stribor> what does myParser take (lets pretend it does make sense)
14:59:57 <ski> stribor : also, it's not composable : i.e. you can't build a larger parser of that form out of smaller ones, since each parser will require all the input and will not return the part it haven't eaten so that the next parser can continue from there
15:00:25 <ski> stribor : btw, ddarius was commenting on that you probably meant `type MyParser a b = [a] -> b' (note the capitalization)
15:00:51 <ciaranm> ddarius: people didn't start using design pattern terms until they got a book and publicity
15:00:55 <tech2> ddarius: if it's as small a subset of people who know/care about this area, although many may not care then we fall back on each man reinventing the wheel because his favoured terminology doesn't yield any hits.
15:01:05 <ddarius> ciaranm: Yes, but people did use the patterns.
15:01:28 <ski> ddarius : well, only to the extent people (who find it useful) hear about it at all -- a truism, of course
15:01:36 <ciaranm> ddarius: they used the patterns implicitly, and often without realising that there was a pattern there, and often not in the best way
15:01:37 <ddarius> ski: Yes.  I agree.
15:02:06 <ciaranm> the value of GoF was that it took common things, gave them names (that's listed as one of their major points), and documented best practices for things
15:02:11 <ddarius> ciaranm: Yes, but the situation you want to do is where people -aren't- using the patterns.
15:02:14 <ski> stribor : are you reading some kind of parser tutorial ?
15:02:25 <ddarius> You want to take uncommon things and give them useless names.
15:02:29 <shlevy> Is Traversal.mapM particularly unlazy? The following goes through every map before printing even though it doesn't need to.
15:02:32 <kstt`> stribor: if you capitalize the type, then it becomes valid haskell.
15:02:32 <shlevy>   dataMap <- Traversable.mapM (Traversable.mapM (extractHashes . extractPackageIdentifier)) hackage
15:02:35 <shlevy>   ByteString.putStrLn $ encode (elemAt 0 (snd $ elemAt 0 dataMap))
15:02:44 <ciaranm> ddarius: eh, nearly all recursion follows one of three or four patterns
15:02:56 <shlevy> ByteString is lazy ByteString
15:03:16 <stribor> ski: i am just trying to understand it....tutorials that i read show examples
15:03:20 <stribor> let me show you one
15:03:26 <kstt`> stribor: as for its usage, MyParser will be a type constructor, so it will operate at the type level (in the signature). No way to use it in the body of a function.
15:03:29 <ddarius> ciaranm: Yes.  That's far less than the number of *morphisms there are.  I'm fine with naming those few patterns we use.  They are already named.
15:03:48 <hpaste> stribor pasted “parser” at http://hpaste.org/53340
15:03:56 <ddarius> ciaranm: In fact, fold is in GoF (under a different name) and there is another book of patterns that does explicitly include fold.
15:04:11 <stribor> ski: how would i try to this example on ghci
15:04:23 <kmc> what name ddarius?
15:04:32 <kmc> i'll bet not 'catamorphism'
15:04:48 <kstt`> stribor: if you understand types, and types signature, you just have to substitute a and b to know the resulting type.
15:05:18 <stribor> kstt`: i know the types just confused what types means here in parsers
15:05:19 <ddarius> kmc: The Interpreter pattern and the Visitor pattern.
15:05:31 <ciaranm> "visitor" is just "algebraic data types done badly"
15:05:38 <ciaranm> and it's a horrible name
15:05:55 <kstt`> stribor: then substitute it in type signature
15:06:03 <kmc> *nod*
15:06:10 <ddarius> Folds are just turn an ADT into its Church encoding.
15:06:32 <ddarius> And indeed, this is exactly what the standard encoding of ADTs into OO accomplishes.  It operates -exactly- the same way.
15:06:36 <kstt`> b -> Parser a b == b -> ([a] -> b)  == b -> [a] -> b
15:07:07 <kstt`> stribor: given a 'a' and a list of 'b', it will produce a b
15:07:18 <kstt`> oops, that's the other way round
15:07:24 <kmc> boost::variant's visitors look almost like pattern-matching :)
15:07:31 <kstt`> given a 'b' and a list of 'a', it will produce a 'b'
15:07:52 <stribor> i am getting error "type constructor or class `Parse'"
15:08:37 <Saizan> shlevy: for IO it's pretty unlazy, yes
15:11:10 <ddarius> Anyway, I think I'm going to the same movie edwardk is.
15:12:22 <stribor> can anyone help me with this error "Not in scope: type constructor or class `Parse'
15:12:44 <ski> stribor : you haven't defined `Parse'
15:12:45 <shachaf> ddarius: Which one is that?
15:13:00 <stribor> ski: how do i define it?
15:13:48 <ski> stribor : you said `type myParser  a b = [a] -> b' before, which is a syntax error, as ddarius noted
15:14:03 <ski> stribor : i suggested changing that to `type MyParser a b = [a] -> b'
15:14:22 <ski> stribor : if you want to call it `Parse' instead of `MyParser', that is fine, too
15:14:34 <ski> but you have to make up your mind about what to call it
15:15:33 <stribor> ski: yeah you right i had to define type
15:15:35 <ivanm> how important is it that "x == read (show x)" ?
15:15:40 <stribor> i did...no errors now
15:15:45 <shachaf> ivanm: Maximally important.
15:15:52 <ski> ivanm : very important, imo
15:16:02 <ivanm> for my graph library, I have it that read . show returns a value that is isomorphically equivalent, but some of the internal values may differ
15:16:14 <ivanm> shachaf, ski: damn, I was afraid of that
15:16:16 <ski> ivanm : that is ok, imo
15:16:23 <ivanm> that means my Show/Read instance needs to expose more internals
15:16:29 <ivanm> ski: oh, good-o
15:16:45 <ski> ivanm : well, mostly ok, anyway
15:16:48 <ivanm> heh
15:17:11 <shachaf> ivanm: I think that's fine.
15:17:23 <ivanm> there's one function in the library that means that I can't keep an invariant present to guarantee equality
15:17:53 <ClaudiusMaximus> ivanm: does  show . read . show = show
15:18:01 <ivanm> ClaudiusMaximus: yes
15:18:22 <ski> stribor : anyway, you seem to be missing to code at the end of `someParser  val inp = [(val,inp)' -- maybe only a `]' is missing, though
15:18:24 <ClaudiusMaximus> cool
15:18:25 <ivanm> what happens is, each edge is represented by two half-edges with unique IDs
15:18:49 <ivanm> it always happens that abs (edge1 - edge2) == 1, but I can't guarantee which one is higher
15:18:55 <ivanm> it depends on how you construct the graph
15:18:59 <ivanm> loops are the big problem...
15:19:27 <ivanm> for Show/Read, I'm representing each of them with the same unique value edgeID `quot` 2
15:19:33 <ski> ivanm : i don't see how "read . show returns a value that is isomorphically equivalent, but some of the internal values may differ" is a potential problem, given that `(==)' doesn't expose the internal differences
15:19:50 <ivanm> ski: the edges use an abstract identifier
15:20:12 <ivanm> and each has an inverse
15:20:41 <ivanm> my current plans for Show/Read have that that order _may_ be flipped, as in the Show/Read instances I'm using the same identifier for both directions
15:20:53 <ivanm> rather than recording both identifiers
15:21:39 <ivanm> e.g. I might have an edge from n1 to n2 with edge identifiers of e1 and e2; after read . show, those edge identifiers might be the other way round
15:21:53 <dmos> I see the benefits of tools like cabal-dev, but lets say I use the dist tools like those in Arch linux which install most of my tools into --global.
15:22:01 <dmos> Can I tell cabal-dev to only use _some_ packages from --global or how can I get around the fact that global is now overflowing?
15:22:02 <ivanm> but since users can't construct those identifiers, it shouldn't matter
15:22:02 <stribor> ski: ill show you this..giv me sec
15:22:15 <ivanm> dmos: why is global overflowing?
15:22:17 <ski> ivanm : and can you observe the order of the identifiers ?
15:22:36 <ivanm> ski: when you construct the graph you get the individual values
15:22:40 <hpaste> stribor pasted “some parser” at http://hpaste.org/53342
15:22:47 <ivanm> but constructor and deconstructor functions arne't exposed
15:23:06 <ski> stribor : next time, annotate the original paste with updates
15:23:08 <dmos> ivanm: if I'd use distribution specific tools which always install into --global (unlike if I use cabal under my user)
15:23:20 <ivanm> so, if someone records an edge identifer from constructing a graph, and then does read . show for some reason, that edge identifier might not be for the edge they think it is
15:23:21 <cgroza> Hello everyone. Is there a math function that allows me to calculate the square roots of imperfect squares with a precision of100 digits?
15:23:30 <ivanm> dmos: yeah, but how does that make it overflow?
15:23:39 <ivanm> is there a limit to how many Haskell packages you're allowed to install? :p
15:23:40 * ski wonders what "imperfect squares" might be
15:23:50 <ivanm> cgroza: precisely 100 digits?
15:23:55 <kmc> does Data.Fixed do it?
15:23:59 <dmos> ivanm: no, not physically, but it makes the dependency game a lot harder and less flexible.
15:24:00 <ivanm> ski: same
15:24:10 <cgroza> ivanm: the requirement is 100. It could be more but no less.
15:24:26 <stribor> ski: i wanna see what it does.......someParser "somestring"
15:24:28 <ivanm> dmos: on my gentoo box, I used the package manager for everything except packages I was developing & testing
15:24:42 <ivanm> cgroza: Data.Fixed, Data.CReal, etc.
15:24:48 <cgroza> ski: thought I used the right term. Anyway, numbers whose square roots are irrational numbers.
15:24:51 <ski> ivanm : i see .. i would try to find a way to avoid that, or document the deficiency
15:25:04 <cgroza> ivanm: thanks.
15:25:24 <cgroza> ski: no need for efficiency. I only have to do it for [0..100]
15:25:35 <ivanm> ski: well, I could avoid that by preserving both edge identifiers in the Show/Read serialisation, but it does lead to some duplication and exposing of internals
15:25:41 <dmos> ivanm: let's say you're developing and testing an application which depends on a new version of a core dependency. Eg. you're preparing your app for a new GHC release or something.
15:25:55 <ivanm> dmos: OK, in that case I'd use cabal-dev or something
15:26:05 <stribor> ski: ok i got it working
15:26:13 <stribor> ski: but i dont get the point of it
15:26:17 <ivanm> or maybe a chroot with only that GHC installed
15:26:24 <dmos> ivanm: that's what I'm asking. Can I exclude stuff --global with cabal-dev.
15:26:41 <stribor> ski: it takes 2 paramethars and puts them into list of pairs
15:26:52 <ivanm> dmos: I've never used cabal-dev; are you saying that if something is available in the global pkg-db it uses that by default?
15:26:56 <ski> stribor : your `someParser' is a building-block, out of which one can more easily build more complex (and useful) parsers
15:27:36 <ski> stribor : the intent is that `someParser val' will be the parser that eats zero tokens from the input, and produces `val' as parsed result
15:27:40 <stribor> ski: ok i get that.......but couldnt i get some thing by doing this someFunction a b = [(a,b)]
15:27:56 <ivanm> stribor: someParser looks like the return/pure instance for parsec, etc.
15:28:04 <ski> stribor : sure, but the point is to build an abstraction
15:28:06 <dmos> ivanm: no, I'm talking about the problem of having a single transaction space for dependencies, and everything has to be updated in lockstep aka dependency hell.
15:28:13 <ski> ivanm : indeed
15:28:45 <stribor> ski: you said "someParser val"......but it takes 2 parametars not only one
15:28:50 <ivanm> dmos: well, you _can_ have multiple versions of a (non-boot) library installed in the global pkg-db
15:28:54 <ski> stribor : well, it's curried
15:29:26 <ivanm> stribor: you typically have a "runParser :: [a] -> Parse a b -> b" function which then evaluates the parser for you
15:29:30 <ski> stribor : `someParser val' is a function that waits until we pass it another input (locally named `inp') before giving back a certain list
15:29:34 <stribor> ski: i tried to run it by just doing          someParser "somestring"   but it dodnt work with one parametar
15:29:43 <ivanm> in your case, it'd be: runParser inp p = fst $ inp p
15:29:54 <ivanm> no, wait, make that: head . fst $ inp p
15:29:57 <ski> stribor : but we want to focus on the `someParser val :: Parse a b' part
15:30:19 <dmos> ivanm: ok. Only one would be active then and the others hidden?
15:30:35 <stribor> ski: ok in order to make a parser.......what do we need to do...
15:30:45 <stribor> ski: first we define the type for the parser....right?
15:30:46 <ivanm> dmos: well, Cabal-the-library would hide all the ones that don't best suit your dependencies
15:30:51 <ski> stribor : as ivanm says, one would typically define a `runParser' function, and run it like `runParser (someParser val) "somestring"', for some value of `val'
15:31:02 <ski> stribor : yes
15:31:17 <stribor> ski: then we write parser right?
15:31:21 <ivanm> stribor: you also need base combinators to use with that parser, and typically Monad/Applicative instances
15:31:33 <ivanm> then you can start to write parsers using those base combinators
15:31:34 <ski> stribor : your parser type `Parse a b' will be *implemented* by the type `[a] -> [(b,[a])]', but that's just one possible implementation of it
15:32:05 <ski> stribor : we want to focus on the abstract idea of a parser, not on the implementation (except when we're writing the implementation, of course)
15:32:06 <ivanm> stribor: most parser implementations use a newtype or something so that the internal details of the parser aren't exposed, so that you can't use them without the parser combinators
15:32:06 <stribor> ski: what are the other?
15:32:50 <dmos> ivanm: ok. Is having multiple versions of the same package in --global something that's common among Haskell developers and works usually without making trouble, or is it problematic?
15:32:56 <ski> stribor : one other possible variant is making a GADT datatype with a constructor for each primitive kind of parser
15:33:17 <ivanm> dmos: can be problematic for packages that don't have upper bounds (happened with base, mtl, etc.)
15:33:35 <ski> (or, with some CPS tricks, one can avoid using GADTs in favour of traditional data types)
15:33:39 <ivanm> but it's common to have at least Cabal have multiple copies if you're not running the latest-and-greatest version of GHC installed
15:34:10 <dmos> ivanm: don't have upper bounds in the cabal files of the packages that depend on them, I assume. So it's a quality control issue of cabal packages in general?
15:34:19 <ivanm> yeah
15:34:23 <dmos> k
15:34:28 <stribor> ski: i have to read on about ths,...so confusing
15:34:32 <ski> stribor : it might be a good idea to first picture the basic primitive parsers (and primitive ways to build new parsers from old parsers) -- only then focus on the implementation of them
15:34:37 <ivanm> hence why hackage now requires an upper bound on base
15:34:42 <ivanm> (which some people don't like)
15:34:45 <ski> stribor : are you faimilar at all with the idea of abstract data types ?
15:34:54 <stribor> ski: no
15:35:24 <ski> stribor : ok, consider this problem : implement a data type of rational numbers, and common operations on them
15:35:25 <stribor> ski: is ADT important when you learning parsers
15:35:34 <stribor> ski: ok
15:35:36 <stribor> ski: and
15:35:36 <megajosh2> Probably
15:35:54 <megajosh2> If you're going to parse, what'll be the representation of your parsed values?
15:35:56 <ski> stribor : ADTs is important for most kinds of data type design
15:36:22 <megajosh2> I forget exactly what an ADT is...
15:36:26 <stribor> ski: well you have numerator..you have denomiator...and you have char '\'
15:36:28 <megajosh2> Is it a datatype that has a type argument?
15:36:49 <ski> stribor : so, how to write a datatype for that ?
15:37:04 <ski> stribor : let's assume the numerator and denominator are both `Integer's, for simplicity
15:37:13 <stribor> ski: ok
15:38:03 <Cale> megajosh2: An algebraic datatype is a tagged union (sum) of Cartesian products of other datatypes (possibly including itself)
15:38:29 <ski> Cale : .. though abstract data types where the topic here :)
15:39:00 <Cale> I see
15:39:27 <megajosh2> Sorry, Cartesian product?
15:39:28 <Cale> It was hard to tell without reading carefully, as you were talking about GADTs as well :P
15:39:36 <ski> stribor : so, any suggestion for how to define a type `Rational' ?
15:39:42 <megajosh2> I just looked it up and it looks analogous to `zip`
15:39:50 <ski> C: Cale
15:39:51 <Cale> megajosh2: Not zip...
15:39:59 <Cale> megajosh2: But forming all possible pairs
15:40:02 <stribor> ski: data Rational = ?
15:40:05 <megajosh2> Ah
15:40:10 <ski> stribor : that's a good start, yes
15:40:12 <megajosh2> So more like (>>=) on lists?
15:40:24 <stribor> ski: i dont know whats next ):
15:40:24 <Cale> yeah, or sequence
15:40:32 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
15:40:34 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
15:40:40 <megajosh2> :t sequence
15:40:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:40:50 <Cale> ^^ the Cartesian product of those three lists
15:40:57 <megajosh2> Ah, I see it
15:41:06 <Cale> At least, if they were sets :)
15:41:16 <ski> stribor : ok, so let's say `data Rational = R Integer Integer'
15:41:17 <shachaf> > [[1..]..]
15:41:18 <lambdabot>   No instance for (GHC.Enum.Enum [t])
15:41:18 <lambdabot>    arising from a use of `e_11' at <int...
15:41:19 <shachaf> Aw.
15:41:30 <stribor> ski: ok
15:41:31 <megajosh2> shachaf: That would be scary
15:41:49 <ski> stribor : this means that each value of type `Rational' will be a value of shape `R x y', where `x' and `y' are `Integer's
15:42:16 <ski> stribor : and let's say the first `Integer' will represent the numerator, and the second the denominator
15:42:18 <stribor> ski: whats R
15:42:44 <ski> stribor : `R' is the data constructor, that combines the two `Integer's together into a single value of type `Rational'
15:43:31 <megajosh2> :t ([1..3]>>=)
15:43:31 <lambdabot> forall t b. (Num t, Enum t) => (t -> [b]) -> [b]
15:43:36 <ski> stribor : compare with `data Maybe a = Nothing | Just a', here `Just' is the data constructor that given an argument of type `a' will form a value of type `Maybe a'
15:44:01 <ski> (also `Nothing' is a data constructor, which is already a value of type `Maybe a', since it takes no arguments)
15:44:02 <stribor> ski: ok
15:44:16 <megajosh2> :t [1..3]>>=map (+1)
15:44:16 <lambdabot> forall a. (Num [a], Enum [a], Num a) => [a]
15:44:20 <megajosh2> [1..3]>>=map (+1)
15:44:20 <shlevy> @hoogle (a, IO b) -> IO (a, b)
15:44:21 <lambdabot> No results found
15:44:25 <megajosh2> > [1..3]>>=map (+1)
15:44:26 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
15:44:26 <lambdabot>    arising from a use...
15:44:28 <shlevy> Boo
15:44:32 <megajosh2> ha
15:44:42 <megajosh2> Man I've been away from Haskell so long
15:45:01 <ski> stribor : so, let's say we represent the rational number `2 / 3' as `R 2 3' which has type `Rational'
15:45:10 <stribor> ski: ok
15:45:18 <ski> stribor : now, we have a potential problem
15:45:36 <ski> stribor : `2 / 3' is the same rational number as e.g. `4 / 6'
15:45:54 <ski> stribor : so the question is, how do we represent the rational number `4 / 6' ?
15:45:56 <stribor> ski: ok
15:46:12 <ski> any suggestion ?
15:46:24 <stribor> ski: no ):
15:46:25 <ski> (there's more than one possible answer here)
15:46:51 <shlevy> Hmm... Is there any way to "pull the IO out" of a tuple?
15:47:03 <shlevy> I have (a, IO b) and want IO (a, b)
15:47:11 <tech2> simplest suggestion would be to reduce all num/den pairs by their GCD, but that could get costly.
15:47:30 <tech2> they're the same number after all.
15:47:41 <kmc> \(x,ya) -> do { y <- ya; return (x,y) }  -- shlevy
15:48:06 <shlevy> kmc: Oh, duh. I don't use patterm matching enough.
15:48:11 <ski> stribor : i hope you know that every rational number can be presented as a fraction where the numerator and denominator have no common factors (except from `1' and `-1')
15:48:37 <kmc> shlevy, you could do it without pattern matching.... \p -> do { y <- snd p; return (fst p, y) }
15:48:38 <Saizan> you can use uncurry instead of matching here :)
15:48:40 <kmc> but that's pretty clearly wrong
15:48:43 <kmc> heh that too
15:49:08 <ski> stribor : e.g. in `4 / 6', the numerator and denominator have the common factor `2', which we can cancel out : `4 / 6  =  (2 * 2) / (2 * 3)  =  2 / 3'
15:49:49 <ski> stribor : however, `2 / 3' can't be simplified any further
15:49:54 <stribor> ski: yes
15:50:35 <ski> stribor : so, the idea is : represent the rational number `a / b' as `R n d', where `n' and `d' are `a' and `b', but with the largest common factor cancelled out
15:50:46 <wavewave> hi
15:50:46 <lambdabot> wavewave: You have 1 new message. '/msg lambdabot @messages' to read it.
15:50:51 <ski> stribor : that way, both `2 / 3' and `4 / 6' will be represented as `R 2 3'
15:51:33 <ski> stribor : so, these two ways to write the *same* rational number will have the *same* representation in Haskell, which is good
15:51:56 <stribor> ski: ok..
15:52:34 <ski> stribor : so, we can implement equality, `(==)', on `Rational's, just by `R n0 d0 == R n0 d1  =  n0 == n1 && d0 == d1' -- in fact, this is what we'll get if we add `deriving Eq' after the definition `data Rational = R Integer Integer'
15:53:23 <stribor> ski: how does this relate to parsers and parsing
15:53:59 <ski> *nod*, i'll come to one aspect of that, now
15:54:10 <stribor> ski: cool:)
15:54:18 <ski> one can implement `(*)', and `(+)' in mostly the normal way
15:54:49 <ski> but one have to remember to simplify the new fractions one construct, anytime they might become non-normalized
15:55:21 <ski> e.g. if you multiply `a / b' and `c / d', the simplest is to just say the result is `(a * c) / (b * d)'
15:55:57 <ski> but then, if you multiply `R 2 3' by `R 3 4', you will get `R 6 12' instead of `R 1 2', which we really want to get
15:56:06 <ski> why do we want to get `R 1 2' ?
15:56:28 <ski> because otherwise `R 2 3 * R 3 4  ==  R 1 2' will evaluate to `False'
15:56:37 <stribor> ski: ok
15:56:50 <ski> so, we must make sure to normalize the fractions all the time
15:56:54 <ski> *and*
15:57:11 <ski> we must also forbid code outside this library/module to directly construct rational numbers
15:57:21 <shlevy> Is there any way to print out the type of a value for diagnostic purposes?
15:57:31 <Axman6> :t "Hello"
15:57:32 <lambdabot> [Char]
15:57:49 <shlevy> Axman6: Outside of ghci?
15:57:50 <Axman6> but not within a program (not without something mueval anyway)
15:57:52 <ski> i.e. you can't write `R 4 6' outside the library, to foil all our hard work to ensure nothing goes wrong
15:58:07 <Saizan> > typeOf "hello"
15:58:08 <lambdabot>   [Char]
15:58:26 <Axman6> shlevy: why do you think you need to do this?
15:58:27 <ski> stribor : so, what we do is : we export the *type* `Rational' from the module, but we *don't* export the constructor `R'
15:58:32 <shlevy> Axman6: Diagnostics
15:58:39 <stribor> ski: yes information hiding
15:58:47 <shlevy> > :t typeOf
15:58:48 <lambdabot>   <no location info>: parse error on input `:'
15:58:51 <shlevy> :t typeOf
15:58:52 <lambdabot> forall a. (Typeable a) => a -> TypeRep
15:59:07 <ski> stribor : and since the constructor isn't visible outside the module, the only way to construct (and analyze) values of type `Rational' is to use the (other) operations exported by the module
15:59:24 <stribor> ski: ok
15:59:26 <ski> stribor : let's take a step back and see what we've really done here
15:59:36 <shlevy> Eh, got what I needed
15:59:39 <Axman6> shlevy: but all types are known at compile time. you shouldn't get any morte information from the types at runtime. in fact, types do not exist at runtime
16:00:38 <ski> stribor : we *want* to express a set/type `{R 1 1,R 1 2,R 1 3,R 2 3,R 1 4,R 3 4,...}' that only contains values of form `R n d', where `n' and `d' have no common factors
16:01:04 <stribor> ski: ok
16:01:29 <ski> stribor : in math notation, we want the set `{R n d | gcd n d == 1}'
16:01:55 <ski> stribor : however, we can't express exactly this type in Haskell.. so we approximate this with the type `{R n d | n,d :: Integer}', that contains *all* pairs of integers
16:02:18 <stribor> ski: ok
16:02:49 <ski> stribor : but, by cleverly hiding the constructors of the type `Rational', we can make it so that it is only possible (if we haven't made any mistake) to construct values of form `R n d' where `n' and `d' have no common factors
16:03:31 <stribor> ski: ok
16:04:00 <ski> stribor : so, we have managed to express a *subset* of the set `{R n d | n,d :: Integer}' (namely the subset we actually wanted), by means of only allowing elements in that subset to be constructed
16:04:45 <ski> stribor : now i'll sketch the main other way to implement `Rational' numbers -- to emphasize that the above is only *one* implementation of the idea of rational numbers
16:05:15 <ski> stribor : instead of always cancelling out common factors in the numerator and denominator, we can just leave them be
16:05:43 <ski> stribor : so, we represent `2 / 3' e.g. as `R 2 3', and `4 / 6' as `R 4 6', even though these two numbers are supposed to be the same
16:05:52 <stribor> ski: ok
16:06:00 <ski> stribor : the trick is that we define `(==)' so that `R 2 3 == R 4 6' is `True'
16:06:24 <ski> stribor : and we do this by `R n0 d0 == R n1 d1  =  n0 * d1 == n1 * d0'
16:06:53 <ski> (if you want, you can check out the math to see that that will work)
16:07:15 <ski> anyway, now we have in a sense the opposite problem as before
16:07:21 <stribor> ski
16:08:05 <ski> the problem before was that maybe someone could manage to construct `R 4 6' so that our `(==)' would answer `False' to `R 2 3 == R 4 6'
16:08:37 <ski> now the problem is that we can construct both `R 2 3' and `R 4 6', but the program is never supposed to notice any difference between them
16:09:15 <ski> our redefined `(==)' doesn't notice any difference between those -- but we have to make sure that no other operation can notice any difference wither
16:09:19 <ski> s/wither/either/
16:10:13 <ski> specifically, we still have to hide the `R' constructor, this time not to disallow just anyone from *constructing* values of type `Rational', but to disallow just anyone to *deconstruct* values of type `Rational', by pattern-matching
16:10:54 <ski> stribor : ok, this was more or less a short crash-course in abstract data types
16:12:09 <stribor> ski: now parsers?
16:13:36 <ski> to conclude : Abstract Data Types can be used (a) to disallow construction of values we don't really want; (b) to disallow matching on values to notice difference that we wish weren't there; and maybe most important : (c) to be able to swap out one implementation of the type (and basic/primitive operations) for another, and have code which uses the ADT to just keep working (maybe more efficiently than before, though)
16:14:03 <osaunders> If you want to look up things bidirectionally is the recommended method to have two separate maps: Map a b and Map b a?
16:14:32 <rferranti> bimap
16:14:54 <ski> ADTs are also useful as a way to *forget* about the tricky interal details about how something is implemented, and concentrate only on the abstract idea of the thing implemented
16:15:03 <ski> stribor : so, we want to have a type of parsers
16:15:22 <stribor> ski: type of parsers?
16:15:30 <osaunders> rferranti: Ah thanks
16:16:04 <ski> stribor : and we generally want that type to be abstract -- from this follows that we must provide flexible enough building-block so that users can build the parsers they want without having to dig inside the implementation
16:17:23 <stribor> ski: ....why would users wants to build parsers
16:17:25 <stribor> whats point of them
16:17:47 <ski> stribor : well, the user here is the user of the library, i.e. a programmer
16:17:54 <stribor> ski: ok
16:18:06 <stribor> ski: what would they use these parsers for
16:18:30 <ski> stribor : e.g. if you want to parse Haskell, you want one parser which parses expressions, one which parses types, one which parses declarations, and so on
16:18:48 <stribor> ski: parse Haskell?now i am lost
16:19:04 <ski> stribor : well, let's take a simpler example
16:19:32 <ski> stribor : let's say we want to parse arithmetical expressions like `(12 + 34) * 385'
16:19:56 <stribor> ski: why would we want to do that???
16:20:12 <Axman6> stribor: if you're building a compiler, being able to do that is vital
16:20:20 <ski> stribor : it's just a (simplistic) example
16:20:24 <stribor> ski: ok
16:21:06 <ski> stribor : but consider various config files for programs, XML, Regular expressions, &c.
16:21:15 <stribor> ski: ok
16:21:50 <ski> stribor : there's lots of information that is usually stored as text. and to do anything useful with that text in a program, you usually have to parse the text into a more malleable format (to the computer)
16:21:51 <stribor> ski:ok we we want to parse `(12 + 34) * 385'
16:21:55 <ski> yes
16:22:05 <ski> stribor : we want one parser which can parse numerals like `12',`34',`385'
16:22:54 <ski> stribor : let's say we call that parser `parseInteger'
16:24:01 <osaunders> If a graph is strongly connected does that mean it is directed?
16:24:35 <ski> stribor : hm, so say `parseInteger :: Parser Char Integer', if we're parsing a `String' (a list of `Char's)
16:24:59 <stribor> ski: ok wait please
16:25:09 <stribor> whats Parse?
16:25:33 <ski> your Abstract Data Type of parsers, that you are going to define :)
16:25:47 <stribor> ski
16:25:47 <ski> we're using the magic of Wishful Thinking, here
16:26:01 <kmc> osaunders, not necessarily, but perhaps some authors mean it that way
16:26:18 <ski> we imagine we have a `Parser' type, and try to figure out what we'd like to do with it
16:26:30 <ski> stribor : yes ?
16:26:38 <stribor> ski: yes?
16:26:39 <kmc> osaunders, any connected undirected graph would be strongly connected
16:26:42 <stribor> ski: what do you mean
16:26:49 <ski> <stribor> ski
16:26:56 <ski> it seemed to me you wanted to ask something ?
16:26:56 <kmc> especially if you're using the definition where an undirected graph is a directed graph where edges come in opposite pairs
16:27:06 <stribor> ski: no
16:27:10 <ski> ok
16:27:42 <ski> one good tool when designing parsers is to write the grammar one want to parse using the BNF notation
16:28:01 <stribor> ski: id just like to keep it simple and plainas possible
16:28:28 <osaunders> kmc: Data.Graph is suitable for directed and undirected graphs, correct?
16:28:37 <kmc> i don't know; haven't used it
16:29:14 <ski> stribor : ok, let's simplify the problem to just parse expressions like `12+34+385', then -- i.e. just numerals and addition, no multiplication, no brackets
16:29:31 <stribor> ski: yes
16:29:57 <ski> stribor : so, an expression here can either be a numeral, or numeral, a plus sign, and another expression
16:31:00 <ski> e.g. `12+34+385' is of the second form : it consists of `12',`+',`34+385'
16:31:31 <stribor> ski: ok
16:31:31 <ski> and `34+385' is here again an exressopn of the second form : it consists of `34',`+',`385'
16:31:49 <ski> finally, the expression `385' is of the first form : it is just a numeral `385'
16:31:51 <osaunders> kmc: I thought you had done everything! :)
16:32:48 <ski> stribor : so, let's say we want to define `parseExpression :: Parser Char [Integer]' (let's say we want to get the list of terms in the sum -- we could compute the sum directly, if you prefer)
16:33:27 <stribor> ski: wait.....we gonna define Parser ourselves?
16:33:33 <kmc> haha
16:33:34 <stribor> ski: whats Char
16:33:38 <ski> stribor : something of type `Parser Char [Integer]' is something that when given a list of `Char's (i.e. a string) as input, will try to parse it and return a `[Integer]' as parsed result
16:33:42 <ski> @src String
16:33:43 <lambdabot> type String = [Char]
16:33:53 <ski> > 'x'   -- is a `Char'
16:33:54 <lambdabot>   'x'
16:33:58 <ski> > ['x','y']
16:34:00 <lambdabot>   "xy"
16:34:12 <ski> a `String' is a list of `Char's, in Haskell
16:34:22 <stribor> ski: ok
16:34:41 <ski> stribor : yes, of *course* we're going to define `Parser' ourselves -- that's the whole *point* of this ! :)
16:34:47 <monochrom> not very efficient but conceptually simpler
16:34:48 <shlevy> Is there any way to "step through" a Haskell program? I'm having a bad lack of laziness and I'm trying to find out where.
16:34:48 <stribor> ski: ok :)
16:34:58 <osaunders> > reverse ".wollef doog a s'ereht ,ecuas elppa dlo eht ssaP"
16:34:59 <lambdabot>   "Pass the old apple sauce, there's a good fellow."
16:35:13 <ski> @where stepeval
16:35:13 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
16:35:21 <shlevy> ski: Thanks
16:35:25 <ski> shlevy : you might try that one, though it's a bit limited
16:35:57 <monochrom> ghci has a debugger too, but I haven't used it
16:36:16 <osaunders> monochrom: I never got it to work
16:36:37 <ski> stribor : first, we're going to postulate an operation `(<|>) :: Parser t a -> Parser t a -> Parser t a'
16:36:38 <monochrom> some conditions apply
16:36:48 <gentleben> monochrom: I have not found the debugger useful in actual applications
16:37:00 <gentleben> we build our own RTS extensions
16:37:14 <stribor> ski: postiulate?
16:37:16 <monochrom> it may be a case of: to understand lazy evaluation, you must first understand lazy evaluation :)
16:37:19 <ski> stribor : the idea is that the parser `parseX <|> parseY' will parse all the things `parseX' parses, and in addition, also all the things 'parseY' parses
16:37:39 <stribor> ski: ok.i am lost
16:38:01 <ski> stribor : i.e. yes, we imagine we have already written the building-block `(<|>)', because that seems like a useful idea
16:38:15 <gentleben> nah, interpreters can't debug some of our apps because it takes to long to repro in a ghci
16:38:26 <stribor> ski: give me few mibnutes...i have to step away from comp
16:38:30 <ski> stribor : the idea is : we define `parseExpression = parseSimpleExpression <|> parseComplexExpression'
16:38:33 <monochrom> I actually ran into ghci debugger a while ago with :print, and figured out what it does
16:38:35 <ski> stribor : ok
16:38:58 <aavogt> I asked this (FFI) question earlier today, but there were no suggestions http://hpaste.org/53311
16:39:27 <shlevy> Anyone willing to look over a 77 LOC program to help me figure this out? I'm not really sure where to start.
16:39:29 <monochrom> probably the most important value of :print is finding out how much a top-level value has been evaluated so far
16:40:19 <monochrom> eww, aavogt, do you have a 42" screen?
16:40:36 <aavogt> no, it wrapped as I was typing it out
16:41:02 <ski> monochrom : have you tried `Observe' ?
16:41:14 <monochrom> no, what is Observe?
16:41:59 <monochrom> oh, a funky library that finds out thunk details
16:43:29 <ski> <http://hackage.haskell.org/packages/archive/hood/latest/doc/html/Debug-Hood-Observe.html>
16:44:14 <ski> it's fun to observe functions : i.e. on which arguments they have been applied, and what the corresponding results were
16:45:24 <shlevy> Can you mapM over an infinite list in IO?
16:45:37 <kfish> what happens if you try?
16:45:38 <monochrom> it will not terminate.
16:45:49 <ski> you can do tricks with `unsafeInterleaveIO'
16:46:09 <ski> (you can also `mapM_' over an infinite list)
16:46:10 <sm> hey all.. I think there is a way now to query the RTS for current heap size - am I right ?
16:46:15 <shlevy> Hmm, ok.  So I really want map instead of mapM and evaluate each member of the list one at a time?
16:46:16 <geheimdienst> monochrom: sometimes you want that, see "forever" etc.
16:46:30 <shlevy> ski: What's mapM_?
16:46:56 <ski> shlevy : there's not much point to use `mapM' instead of `mapM_', since you can't get the resulting list anyway
16:46:56 <kmc> mapM but discarding results
16:46:58 <monochrom> it is a less efficient infinite loop than forever.
16:47:00 <ski> @type mapM
16:47:01 <ski> @type mapM_
16:47:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:47:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:47:15 <kmc> mapM or mapM_ over an infinite list works just fine
16:47:18 <kmc> and it does what you'd expect
16:47:22 <kmc> performing IO forever
16:47:41 <kmc> so the answer is "yes you can mapM over an infinite list"
16:47:49 <monochrom> actually, forever and mapM_ has a much better chance of non-terminating than mapM
16:47:57 * ski hopes `sequence_ (repeat act)' is as efficient as `forever act' (asymptotically), but doesn't know
16:48:31 <geheimdienst> i tested this and it does what i expect, until i interrupt it. "main = mapM print [1..]". no "tricks with unsafeInteleaveIO" are necessary
16:48:34 <shlevy> Right, so I don't want to mapM at all because that performs all the IO before finishing, I want to perform the IO one at a time
16:49:12 <shlevy> Sorry, when I say "can you on an infinite list" I meant "with any hope of termination if you only access finite amount of the resulting list"
16:49:18 <kmc> ah
16:49:24 <kmc> that breaks a basic property of Haskell, then
16:49:27 <aavogt> unsafeInterleaveIO does that
16:49:45 <kmc> because the IO would be executed as you evaluate the resulting list
16:49:52 <kmc> which means you have evaluation causing execution
16:49:55 <ski> shlevy : you can do that with `unsafeInterleaveIO', and also with concurrency
16:50:28 <ski> hm, no, i retract that last part
16:50:45 <ski> (though it is true with declarative concurrency in Oz)
16:50:56 <shlevy> So the only way to print, say, the first 5 members of an [ IO String ] without evaluating all the IO at once is unsafeInterleaveIO?
16:50:57 <kmc> shlevy, and all kinds of things can go wrong.  the list you produce doesn't really act like a pure value anymore
16:51:01 <kmc> no
16:51:08 <kmc> :t sequence . take 5
16:51:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:51:20 <kmc> shlevy, but you can't print an IO String.  there's no String inside an IO String
16:51:34 <ski> shlevy : `[IO String]' is very different from `IO [String]'
16:51:42 <kmc> an IO String is not a "wrapped String".  it's an imperative program which has not yet been executed
16:52:10 <kmc> shlevy, IO actions are first-class values and so you can use 'take' etc. with lists of them
16:52:54 <JoeyA> sequence in a strict monad produces a stack overflow when the produced list is too long, at least last time I tried it (in GHC 6.12).  I think it's better in GHC 7, but I could be wrong.
16:53:10 <JoeyA> (by "strict monad", I'm referring to IO.  I didn't try it in any other monad)
16:54:15 <shlevy> Ok, I'm not understanding something, so I'll try my real example. I have a value of type [IO (String, [(Version, PackageHashes)])], and I want execute the first action and print the String of the resulting first element. Can I do that without executing the whole list?
16:54:37 <tomprince> Yes.
16:54:38 <kmc> yes
16:54:42 <shlevy> How?
16:54:46 <kmc> did you see «sequence . take 5»?
16:55:03 <kmc> a list of IO actions is a list, so you can do things like take the first 5 elements
16:55:10 <kmc> sequence :: [IO a] -> IO [a]
16:55:11 <shlevy> :t sequence
16:55:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:55:13 <shlevy> Aaah
16:55:14 <shlevy> Ok
16:55:18 <kmc> also sequence_ :: [IO a] -> IO ()
16:55:36 <ski> shlevy : however, note that each time you do this, the `IO'-actions will be executed again -- which you might not like
16:55:43 <Saizan> ore directly: \xs -> case xs of (x:xs) -> do x; ..
16:55:57 <kmc> shlevy, the unsafeInterleaveIO business is for a different question, which we thought you were asking
16:56:00 <shlevy> ski: Only doing it once, just to make my work more lazy
16:56:27 <shlevy> I want to generate the list of actions, execute them one by one, and serialize the data after each execution
16:56:27 <kmc> shlevy, you'd need that if you had [IO String] and you wanted to produce a [String] such that each IO String is only executed when the corresponding String is evaluated
16:56:37 <kmc> you can see why that would break the normal guarantees of Haskell
16:56:40 <shlevy> Aaah, yeah
16:56:49 <kmc> it's how readFile works
16:56:53 <kmc> and why readFile breaks
16:56:54 * ski ponders a `thunkIO :: IO a -> IO a' operation that caches the result -- would that be bad ?
16:56:56 <shlevy> Ok, I see
16:57:18 <shlevy> :t seq
16:57:19 <lambdabot> forall a t. a -> t -> t
16:57:24 <kmc> ski, you can implement that in ordinary haskell, right?
16:57:56 <ski> kmc : try ? :)
16:58:53 <mauke> thunkIO :: IO a -> IO (IO a)
16:58:59 <JoeyA> It could use an MVar (Either (IO a) a).
16:59:00 <ski> mauke : indeed
16:59:05 <kmc> *nod*
16:59:18 <kmc> how would your thunkIO differ from unsafeInterleaveIO?
16:59:27 <ski> the idea would be to `map thunkIO' over the infinite list
16:59:42 <monochrom> I used a Posix signal handler to accomplish thunkIO :)
17:00:02 <JoeyA> Oh, I was thinking IO a -> IO a.
17:00:13 <ski> kmc : well, the first time `thunkIO act' is executed, `act' would be executed, the next time the cached result would just be recalled
17:00:52 <JoeyA> Same idea, though.
17:01:35 <ski> JoeyA : with `IO a -> IO (IO a)', there's no problem. it's the `IO a -> IO a' variant that could be problematic
17:01:43 <dibblego> are there strict tuples lying around anywhere?
17:01:59 <monochrom> no, write your own strict records
17:01:59 <ski> dibblego : there's unboxed tuples in GHC, those are strict
17:02:12 <dibblego> ah yeah ta
17:02:29 <kmc> they're not first-class values though
17:02:36 <ski> yea
17:02:41 <JoeyA> Got it.
17:02:44 <ski> (that's the point of them, in fact)
17:02:46 <JoeyA> err
17:06:56 <shlevy> does appendFile work on non-existent files?
17:07:10 * monochrom figures out thunkIO :: IO a -> IO a by a trick of interpreting the question!
17:07:20 <monochrom> thunkIO = id.
17:08:25 <monochrom> Example usage: the first time you need it, "x <- thunkIO action", action is executed and you get the answer in x. afterwards, the answer is cached in x, you can refer to x as many times as you like. :)
17:08:58 <ski> that doesn't satisfy `join (liftM2 (,)) . thunkIO = liftM (join (,)) . thunkIO'
17:09:27 <ski> (but, good try ;)
17:10:28 <ski> @type join (liftM2 (,))
17:10:28 <ski> @type liftM (join (,))
17:10:29 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m a2 -> m (a2, a2)
17:10:30 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (a1, a1)
17:10:48 <hpc> see, the a2 and a1 are different!
17:11:03 <monochrom> a1 is larger than a2
17:11:14 <ski> hehe, they're the same, up to alpha-conversion
17:12:18 * ski ponders filing a feature request to make GHC use de-Bruijn notation in types
17:12:28 <monochrom> \∩/
17:12:46 <shlevy> Hmm, I think I do want unsafeInterleaveIO, but again that's probably because I'm misunderstanding. I have a [IO String] and I want to Binary.encode the [String] that would result from sequencing the [IO String], but doing it one action at a time.
17:13:34 <ski> shlevy> :t Binary.encode
17:13:42 <hpc> :t sequence
17:13:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:13:58 <shlevy> :t Binary.encode
17:13:59 <lambdabot> Couldn't find qualified module.
17:14:04 <shlevy> :t Data.Binary.encode
17:14:05 <lambdabot> forall a. (Data.Binary.Binary a) => a -> BSLC.ByteString
17:14:26 <ski> shlevy : you want to `Binary.encode' each `String', or the whole `[String]' as one value ?
17:14:27 <hpc> :t Data.Binary.encode .: fmap join . sequence
17:14:28 <lambdabot> forall a (g :: * -> *). (Data.Binary.Binary a, Functor g, Monad g) => [g [a]] -> g BSLC.ByteString
17:14:35 <micahjohnston> @pl (\(a,b) n -> (a*n,b+1))
17:14:36 <lambdabot> uncurry ((. (1 +)) . flip . ((,) .) . (*))
17:14:43 <micahjohnston> aw, can it have Applicative?
17:14:46 <hpc> :t Data.Binary.encode .: fmap join . sequence $ [getLine]
17:14:47 <lambdabot> IO BSLC.ByteString
17:14:47 <shlevy> ski: The whole string as one value, but incrementally producing the actual bytestring
17:14:54 <hpc> shlevy: ^
17:15:01 <shlevy> ski: Sorry, the whole [String] as one value
17:15:22 * hpc has no clue how strict/lazy that is
17:15:42 <shlevy> hpc: What's .: ?
17:16:04 <ski>   (.:) = (.) . (.)
17:16:17 <shlevy> :t .:
17:16:18 <lambdabot> parse error on input `.:'
17:16:22 <shlevy> :t (.:)
17:16:23 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
17:16:34 <micahjohnston> :t (+) .: (+1)
17:16:35 <lambdabot> forall a (g :: * -> *). (Num a, Num (g a), Functor g) => g a -> g (a -> a)
17:16:36 <hpc> shlevy: basically, a second level of function composition
17:16:48 <dibblego> coincidentally, the exact same function was discussed on #scala just 20 minutes ago
17:16:50 <hpc> and i was using (.:) = fmap fmap fmap, btw
17:16:54 <micahjohnston> > (+) .: (+1) 4 5
17:16:56 <lambdabot>   No instance for (GHC.Show.Show (f (g (a -> a))))
17:16:56 <lambdabot>    arising from a use of `...
17:16:57 <micahjohnston> > (+) .: (+1) 4
17:16:59 <lambdabot>   No instance for (GHC.Show.Show (f (g (a -> a))))
17:16:59 <lambdabot>    arising from a use of `...
17:17:00 <micahjohnston> eh
17:17:05 <ski> hpc : `sequence' will not terminate executing an infinite list of `IO'-actions
17:17:21 <hpc> oh, the list of actions is infinite
17:17:41 <shlevy> hpc: Not really, just really really long and I want to get some output before I have all of it
17:17:50 <shlevy> hpc: But it could be infinite and I'd have the same question
17:18:02 <ski> shlevy : so, it sounds like you want `unsafeInterleaveIO', unless you can restructure you code in another way
17:18:30 <hpc> i would go with a restructure
17:19:09 <shlevy> ski: Well... Any idea what the overhead of recreating the [String] by deserializing each String then creating the list, vs deserializing the [String] directly?
17:19:12 <hpc> even a combinator like [IO String] -> IO (String, [IO String]) would be immensely helpful
17:19:19 <ski> hm .. `interleaveACIO' would not be as problematic, yes ?
17:19:38 <hpc> (this, next) <- step actions
17:19:44 <hpc> ...
17:19:46 <hpc> and recurse
17:21:30 <shlevy> hpc: But I assume Binary.encode encodes a list of Strings differently than just shoving the encoding of several strings next to each other
17:22:33 <hpc> shlevy: it's just a bytestring
17:22:46 <hpc> i doubt it can encode lists of strings
17:23:18 <shlevy> Instances: Binary Char, Binary a => Binary [a]
17:23:34 <shlevy> http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html
17:25:33 <shlevy> :t unsafeInterleaveIO
17:25:34 <lambdabot> Not in scope: `unsafeInterleaveIO'
17:25:51 <magicman> shlevy: The source for the list instance says "put l  = put (length l) >> mapM_ put l"
17:25:51 <joe9> http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf just came upon this. Does this make Haskell have the type mechanism flexibility of Agda?
17:28:01 <Cale> joe9: Some of it, not all of it
17:28:07 <ivanm> shlevy: Binary encodes lists (including Strings) by specifying the length of the list, and then encoding every in turn
17:28:15 <joe9> oh, ok. thanks. Cale
17:28:20 <ivanm> so it has to traverse the list twice
17:28:22 <shlevy> magicman: Not so good at monads outside of do notation, is that put l = do put length l; mapM_ put l;?
17:28:30 <ivanm> bah, missed that magicman just said that
17:28:35 <ivanm> shlevy: yup
17:28:39 <ski> @type System.IO.Unsafe.unsafeInterleaveIO
17:28:40 <lambdabot> forall a. IO a -> IO a
17:28:51 <shlevy> Damn
17:29:14 <ivanm> shlevy: and it can't be changed for backward-compatibility reasons
17:29:15 <shlevy> So what does Binary gain by using lazy bytestrings?
17:29:47 <ivanm> shlevy: well, it has to create _something_
17:30:01 <ivanm> and the choice of lazy vs strict is, I believe, so that you don't have to keep appending as much
17:30:09 <ivanm> and there are no bounds (modulo memory) of the length
17:30:21 <shlevy> ivanm: But if it has to traverse the entire structure it's encoding anyway...
17:30:30 <ivanm> since basically, L.ByteString = [S.ByteString]
17:30:33 <ivanm> shlevy: huh?
17:30:51 <ivanm> shlevy: do you mean using ByteString as an output value, or doing put on a ByteString ?
17:31:02 <ivanm> which are two separate things
17:31:49 <shlevy> When doing encode on [a], the first few bytes in the ByteString can't be generated until it evaluates (length l), so you don't really gain much by laziness
17:32:12 <shlevy> You certainly can't lazily encode an infinite list
17:32:16 <ivanm> right
17:32:23 <ivanm> but that has nothing to do with using a Lazy ByteString
17:32:52 <ivanm> the "laziness" in terms of bytestring usage is about concatenating together smaller BS, the length of the BS and reading/writing it to disk
17:33:13 <shlevy> What is the benefit of having a Lazy ByteString, if not making it so you don't need to read all of the data to encode the start of it?
17:33:22 <ivanm> note that binary uses a builder under the hood (rather than directly creating a BS), and that blaze-builder is apparently destined to replace the existing one
17:33:44 <ivanm> shlevy: the actual creation of it and reading/writing to disk/network
17:33:45 <shlevy> Ah, so the resulting ByteString doesn't need to stay in memory all at once. That's something, at least
17:33:49 <ivanm> not the actual encoding/decoding stuff
17:33:50 <ivanm> right
17:34:20 <ivanm> so the serialisation/deserialisation isn't lazy
17:34:26 <ivanm> but using the serialised value _is_
17:34:38 <shlevy> I see
17:35:14 <shlevy> I guess the cost of making serialization lazy would be losing the ability to know exactly how far ahead to seek in the ByteString to find the end of the list
17:35:31 <shlevy> You have to scan until you find some terminator char
17:35:32 <ivanm> right
17:35:45 <ivanm> shlevy: it's always possible to do a newtype wrapper around a list and create your own serialisation
17:36:20 <shlevy> Yeah, this is a one-off thing so that's going to be a bit overkill. There's a better answer.
17:36:28 <ivanm> e.g. [a,b,c] --> put a; put 1; put b; put c; put 0
17:37:11 <ivanm> i.e. "0 means end of list; any other Word8 value is a cons"
17:41:06 * hackagebot time 1.4.0.1 - A time library  http://hackage.haskell.org/package/time-1.4.0.1 (AshleyYakeley)
18:06:30 <dunpeal> Hey. What's the best place to look up non-alphabetic methods like !!?
18:06:42 <geheimdienst> @hoogle (!!)
18:06:43 <lambdabot> Prelude (!!) :: [a] -> Int -> a
18:06:43 <lambdabot> Data.List (!!) :: [a] -> Int -> a
18:06:51 <geheimdienst> dunpeal: try hoogle or hayoo
18:07:07 <dunpeal> thanks
18:07:19 <geheimdienst> (hoogle's web interface links you to the docs, hoogle in here only gives you the module and type)
18:07:37 <Cale> You can also look in Haddock's documentation index
18:07:49 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html
18:07:56 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index-33.html
18:08:01 <mauke> !! isn't a method
18:08:32 <kmc> just call it a function
18:12:13 <ddarius> (+) isn't a function.
18:12:17 <TomMD> > fix (\x -> error $ "Connection reset by " ++ x)
18:12:21 <lambdabot>   mueval-core: Time limit exceeded
18:13:05 <aristid> :t (+)
18:13:06 <lambdabot> forall a. (Num a) => a -> a -> a
18:13:14 <aristid> ddarius: yes, it is a function
18:13:24 <ddarius> (+) is a method.
18:13:40 <aristid> a polymorphic function
18:14:16 <kmc> isn't it also a function
18:14:26 <kmc> or is your point that it's a name for a family of different functions?
18:15:04 <ddarius> The latter, except that I wouldn't really say it's my point, I'm just being excessively pedantic.
18:18:53 <kmc> *nod*
18:19:16 <kmc> i'd recommend beginners not worry about what "method" means in Haskell and just call them all "functions"
18:19:31 <ddarius> As would I.
18:20:00 <kfish> what does method mean?
18:20:12 <ddarius> Type classes contain methods.
18:20:36 <kmc> methods are names which are ad-hoc overloaded by type classes
18:20:46 <kmc> (+) is a method because you give a different definition of (+) for every Num type
18:20:57 <Cale> minus the ad-hoc part
18:20:58 <kfish> yeah, i sometimes feel more comfortable talking about type class interface functions
18:21:03 <kmc> (note that by this definition a method need not be a function)
18:21:07 <kmc> (like minBound)
18:21:12 <kfish> but i guess method == function with implicit dictionary or something
18:21:20 <aavogt> ddarius: maxBound is a method too?
18:21:24 <ddarius> aavogt: Yes.
18:21:30 <ddarius> kfish: A method is just a name.
18:21:32 <kmc> Cale, well, it's common in Haskell communities to refer to type classes as "ad-hoc polymorphism"
18:21:35 <ddarius> It has no "body."
18:21:51 <kmc> there are views in which methods are single functions, like kfish said
18:22:00 * Cale often hates the way that the original typeclasses paper was cleverly titled "how to make ad-hoc polymorphism less ad-hoc"
18:22:14 <kmc> either with an implicit dictionary or an implicit type-evidence parameter you can case on
18:22:16 <ddarius> From an implementation oriented perspective, methods are projections of a dictionary.
18:22:33 <ddarius> I.e. the names of the fields.
18:22:46 <Cale> Because it's really not very much like ad-hoc polymorphism, apart from the fact that you're telling implementations apart by static discrimination on types.
18:23:10 <Cale> That doesn't account for the fact that you can define new typeclass polymorphic things simply by using others.
18:23:13 <kfish> i guess i'm just allergic to the word method, i'd prefer to talk about dictinoaries and polymorphism if they're relevant, but generally just talk about functions and types
18:23:24 <ddarius> Wouldn't class C a where f :: a be like ad-hoc polymorphism?
18:23:56 <ddarius> kfish: Dictionaries are not relevant.  They are an implementation detail and even then, not in all implementations.
18:24:06 <Cale> ddarius: Somewhat, except that you could then define more polymorphic values just by using f
18:24:19 <ddarius> Cale: That is a point.
18:26:42 <ddarius> Cale: You can get that effect with C++ templates, but that's not saying much.
18:27:02 <ddarius> (templates + the ad-hoc overloading provided by C++)
18:27:05 <Cale> C++ templates are closer to parametric polymorphism
18:27:10 <ddarius> Not really.
18:27:20 <Cale> (also not the same at all)
18:32:55 * ddarius thinks what Cale really hates is the term "ad-hoc polymorphism."
18:36:26 <shlevy> Isn't Data.Map.fromAscList kinda unHaskellish in trusting the programmer to maintain the integrity of the data?
18:37:08 <Eduard_Munteanu> Might be just unAgda-ish :)
18:37:13 <ddarius> shlevy: Only in that it doesn't have "unsafe" in its name.
18:37:38 <ivanm> shlevy: it can boost performance if you know what you're doing
18:37:57 <ivanm> and to that extent there are lots of "I assume the inputs are in this format" functions
18:38:11 <ivanm> e.g. head
18:38:24 <shlevy> ivanm: Yeah, like the Map serialization :) But one of the nice things about Haskell is not needing to trust other programmers as long as you grep  for unsafe in their code :)
18:38:26 <copumpkin> Eduard_Munteanu: I'm providing something like that for AVL trees that asks for a proof of orderedness
18:38:36 <ivanm> shlevy: yeah, not quite
18:38:43 <copumpkin> shlevy: so what about head?
18:38:48 <ivanm> that's not really sufficient
18:38:49 <shlevy> ivanm: head is a bit different... It will crash, not give data in a bad format
18:39:11 <Eduard_Munteanu> copumpkin: nice. Are AVL proofs still giving you headaches?
18:39:18 <shirt> i have a list. how do i count how many times each unique element appears?
18:39:19 <ivanm> Data.Map.mapMonotonic (recently bit me because I forgot my helper function was using it because in all my other uses it _was_ monotonic)
18:39:38 <ivanm> shirt: map (\ as -> (as, length as)) . group . sort
18:39:41 <copumpkin> Eduard_Munteanu: yeah, but I took a bit of a break from them cause of that termination checker issue, that I need to check with drAgda about
18:39:56 <ivanm> that should be head as
18:39:58 <copumpkin> Eduard_Munteanu: something that is clearly structurally recursive is getting labeled as not-obviously-terminating
18:40:02 <ivanm> @pl \ as -> (head as, length as)
18:40:03 <lambdabot> liftM2 (,) head length
18:40:17 <Eduard_Munteanu> BTW, I'm having a go at record update syntax... (no promises, though :D)
18:40:18 <ivanm> @type map (liftM2 (,) head length) . group . sort
18:40:19 <copumpkin> :t (head &&& length)
18:40:19 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
18:40:21 <lambdabot> forall c. [c] -> (c, Int)
18:40:33 <ivanm> copumpkin: ooooohhhhh
18:40:38 <shlevy> Hm... I think sometimes I really want Haskell to be Agda
18:40:38 <ivanm> I always forget about &&&
18:40:41 <copumpkin> :t map (length &&& head) . group
18:40:43 <lambdabot> forall a. (Eq a) => [a] -> [(Int, a)]
18:40:53 <copumpkin> :t concatMap (uncurry replicate)
18:40:55 <lambdabot> forall b. [(Int, b)] -> [b]
18:40:55 <ivanm> copumpkin: that assumes its already sorted though
18:40:57 <shirt> ivanm: thanks, but is there a more efficient way? that "length" looks a bit scary
18:41:01 <copumpkin> ivanm: nah, that's just RLE :)
18:41:11 <ivanm> shirt: well, that's only doing a length on the number of each unique element
18:41:12 <ddarius> You guys are doing it wrong.
18:41:19 <ivanm> so it isn't scary, unless you have [1,1..] :p
18:41:20 * copumpkin is always doing it wrong
18:41:22 <ivanm> ddarius: O RLY?
18:41:40 <shirt> ivanm: i realize that, but this is a big list, with lots of duplicates
18:41:49 <ivanm> shirt: an alternative is to fold along the list using a Map with Map.update
18:41:55 <ivanm> @hoogle Data.Map.update
18:41:56 <lambdabot> Data.Map update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
18:41:56 <lambdabot> Data.Map updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
18:41:57 <lambdabot> Data.Map updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
18:42:04 <ivanm> or is it alter?
18:42:07 <ivanm> @hoogle Data.Map.alter
18:42:08 <lambdabot> Data.Map alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
18:42:13 <ivanm> @hoogle Data.Map.insertWith
18:42:14 <lambdabot> Data.Map insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
18:42:14 <lambdabot> Data.Map insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
18:42:14 <lambdabot> Data.Map insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
18:42:18 <ivanm> ^^ that's the one
18:42:43 <shlevy> I just remember the last time I went to #agda I was discouraged from writing a program that needed to do IO :)
18:42:45 <ddarius> > M.fromListWith (+) . zip (flip (,) 1)
18:42:46 <lambdabot>   Couldn't match expected type `[a -> k]'
18:42:46 <lambdabot>         against inferred type `a1 -...
18:43:20 <ivanm> @type foldl' (\ mp v -> M.insertWith (+) v 1 mp) M.empty -- shirt
18:43:22 <lambdabot> forall b a. (Num a, Ord b) => [b] -> M.Map b a
18:43:31 <ddarius> :t M.fromListWith (+) . map (flip (,) 1)
18:43:32 <lambdabot> forall a k. (Num a, Ord k) => [k] -> M.Map k a
18:43:37 <shirt> ivanm: thanks, that sounds good. out of curiosity, can you maybe think of another way that doesn't require an Ord instance?
18:43:55 <ivanm> shirt: not if you want it to be efficient
18:43:57 <ddarius> > M.fromListWith (+) . map (flip (,) 1) $ "aaabbcabc"
18:43:59 <lambdabot>   fromList [('a',4),('b',3),('c',2)]
18:44:23 <ivanm> shirt: you could use  [(a,Int)] but you'd have to traverse the entire list each time you wanted to add a value
18:44:33 <ivanm> shirt: so it would only work if you have a small number of unique values
18:44:41 <ivanm> if so, that would probably be roughly equivalent to using a Map
18:45:09 * ddarius suspects fromListWith is evil though.
18:45:29 <ivanm> @src fromListWith
18:45:29 <ivanm> :p
18:45:29 <lambdabot> Source not found. Sorry.
18:46:03 <ivanm> ddarius: it's using some kind of strict left-fold apparently
18:46:08 <shirt> ivanm: what about your first solution, using a modified implementation of "group" that also does counting?
18:46:16 <blackdog> if you're doing it in a batched way, it's just as good - building the map ni the first place is n log n, and sorting and grouping should be n log n + n, so the same asymptotically
18:46:18 <shirt> ivanm: maybe i should read the implementation of group...
18:46:34 <ivanm> shirt: sure you could do that
18:46:41 <ivanm> but that's going to be O(n^2)
18:46:58 <shirt> ivanm: because of the initial sort?
18:47:03 <ivanm> @src foldl'
18:47:03 <lambdabot> foldl' f a []     = a
18:47:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:47:30 <ivanm> OK, the only way that foldlstrict differs from foldl' is that it uses a "go" function rather than recursing directly...
18:47:34 <ivanm> :s
18:47:39 <shirt> ivanm: err wait, sort requires Ord anyway, oops
18:47:54 <ivanm> shirt: yes, hence why you'd have O(n^2) to try traversing the list each time
18:48:12 <ivanm> shirt: because you'd be doing something similar to nub then
18:48:21 <ddarius> ivanm: Yes, but it is using insertWithKey not insertWithKey'
18:48:38 <ivanm> shirt: note also that because of fusion, you might find that the intermediate lists might not really exist anyway
18:49:01 <ivanm> ddarius: bah, missed that difference
18:49:08 <ivanm> yeah, I'm looking at it and not sure I trust it either
18:49:34 <ddarius> > M.fromListWith (+) . map (flip (,) 1) $ replicate 'a' 1000000
18:49:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:49:35 <lambdabot>         against inferred type ...
18:49:41 <ddarius> > M.fromListWith (+) . map (flip (,) 1) $ replicate 1000000 'a'
18:49:44 <lambdabot>   fromList [('a',*Exception: stack overflow
18:49:47 <ddarius> Ta da
18:49:51 <ivanm> yay :s
18:49:59 <ivanm> ddarius: you obviously need a strict + ! :p
18:50:05 * ivanm should go to uni...
18:50:20 <ivanm> bye all
18:51:03 <ddarius> :t M.fromListWith'
18:51:04 <lambdabot> Couldn't find qualified module.
18:51:10 <ddarius> :t Data.Map.fromListWith'
18:51:11 <lambdabot> Not in scope: `Data.Map.fromListWith''
18:53:18 * ddarius is not sure why you'd ever what fromListWith
18:53:30 * ddarius despairs of the Haskell community.
19:00:54 <lucca> ddarius: what's wrong with it?
19:01:11 <lucca> the with is for the combining function... like if you're counting things, I guess?
19:02:28 <kmc> or accumulating a list of values at that key
19:03:11 * BMeph looks for Agent.007.fromRussiaWithLove... ;þ
19:04:25 <kmc> haha
19:04:45 <BMeph> Does anyone know off-hand of a package for finding poly roots, using CReal?
19:11:07 * hackagebot sized-types 0.3.4.0 - Sized types in Haskell.  http://hackage.haskell.org/package/sized-types-0.3.4.0 (AndyGill)
19:26:07 * hackagebot http-date 0.0.1 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.1 (KazuYamamoto)
19:26:09 * hackagebot diagrams-lib 0.4.0.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.4.0.1 (BrentYorgey)
19:51:27 <mm_freak> does anyone know of a list monad transformer implementation, which provides a MonadFix instance?
19:57:42 <mm_freak> i'm getting the impression that there is an inherent problem with MonadFix and ListT
19:58:02 <mm_freak> but [] is a MonadFix, so it feels like it must be possible
20:04:19 <Cale> mm_freak: Are you talking about the not-really-a-monad-transformer version from the mtl?
20:05:37 <Tekmo> See this: http://www.haskell.org/haskellwiki/ListT_done_right
20:05:40 <monochrom> the mtl doens't have ListT
20:05:44 <Tekmo> Yes it does
20:05:52 <Tekmo> http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-List.html
20:06:30 <monochrom> oh well
20:10:01 <ddarius> lucca: It's lazy in a way that will almost never help you and almost always hurt you.
20:10:24 <Cale> epic thread bump?
20:10:40 <mm_freak> Cale: i'm talking about a proper ListT
20:10:53 <Tekmo> Did you read the first link I gave you?
20:11:11 <mm_freak> Tekmo: long ago, but it's unrelated to my question
20:11:17 <mm_freak> thanks though
20:12:32 <mm_freak> what i really need is Kleisli (ListT m) with ArrowLoop, and this requires MonadFix for ListT
20:13:06 <mm_freak> i have searched through many ListT libraries (logict, monadLib, monatron, etc.), but none of them have MonadFix
20:13:24 <Tekmo> I'm trying to see if it's possible to just write one\
20:13:57 <c_wraith> > mfix $ \x -> ["foo" ++ x]
20:13:59 <lambdabot>   ["foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoof...
20:14:14 <c_wraith> oh, that's just for [], not ListT
20:14:21 <mm_freak> yes, that's only for []
20:16:09 <mm_freak> @src mfix []
20:16:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:16:09 <ddarius> > fix ("foo"++) -- mfix (fmap f) = fix f
20:16:11 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
20:16:16 <mm_freak> @src [] mfix
20:16:16 <lambdabot> mfix f = case fix (f . head) of
20:16:16 <lambdabot>            []    -> []
20:16:16 <lambdabot>            (x:_) -> x : mfix (tail . f)
20:16:23 <ddarius> return (fix f)
20:16:28 <ddarius> ...
20:51:52 <User638> err
20:51:54 <User638> Lol
21:02:50 <kmc> lol indeed
21:03:07 <kmc> it seems like GHC has a lot of additional complexity to support static objects in addition to heap-allocated objects
21:03:26 <ddarius> We should get rid of the heap.
21:03:36 <kmc> an interesting proposal ddarius
21:03:50 <kmc> what of the alternative where all objects are heap allocated, and the program simply copies a chunk of static memory into the heap at startup
21:03:53 <kmc> what are the disadvantages?
21:04:04 <kmc> (well, you might need to relocate it too)
21:06:57 <ddarius> The copy and extra heap pressure are two disadvantages.  Also, you're less able to exploit the addresses.
21:07:49 <kmc> right, there are some places where GHC does a pointer comparison to decide if a value is heap or static allocated
21:07:49 <kmc> b
21:07:55 <kmc> but you wouldn't need to do that anyway
21:08:02 <luite> are there generalized exception handling packages (with alternative transformers?) that have: execWriterT ((tell "a" >> error "x" >> tell "b") `catch` \(_::SomeException) -> tell "c")  result in "ac" ?
21:09:02 <kmc> the time it takes to copy is a concern, but probably not a huge one
21:09:10 <kmc> on my machine I can copy 100MB in the C heap in about 0.1s
21:09:33 <kmc> it will also increase peak memory residency at startup, but not long-term
21:10:07 <kmc> you can probably unmap the static data pages once you're done with them
21:10:17 <kmc> or just trust the OS to evict them if there's pressure on physical memory
21:10:26 <kmc> because they will be clean copies of pages on disk
21:11:01 <ddarius> Any Simon Marlow is the better one to ask.
21:11:15 <kmc> *nod*
21:12:33 <Eduard_Munteanu> What if the static objects were layed out as in the heap?
21:13:32 <kmc> they mostly are
21:13:35 <kmc> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Dynamicvs.Staticobjects
21:14:00 <Saizan> luite: implement MonadWriter (ReaderT (IORef w)) w ;)
21:14:16 <Eduard_Munteanu> "They are never moved, because pointers to such objects are scattered through the object code, and only the linker knows where."
21:14:41 <luite> Saizan: yeah I thought about that, but I wonder what kind of issues you run into when you have forkIO with things that might leak the IORef
21:14:51 <kmc> yeah probably to support my scheme, ghc would have to include a custom dynamic linker
21:14:51 <ddarius> Which be the "exploiting the addresses" I mentioned.
21:14:53 <kmc> but it already does :)
21:14:55 <Eduard_Munteanu> Well, if this was a contiguous zone, then I guess you could mmap that part and treat is as a heap, no?
21:15:02 <Saizan> luite: in that case you want a MVar
21:15:22 <Eduard_Munteanu> s/is/it/
21:15:35 * Eduard_Munteanu wonders how he makes those typos
21:15:57 <luite> Saizan: nah I don't mean because of atomic updating, but because of multiple threads interfering with the same accumulator
21:16:08 <Saizan> luite: i wonder if one can do this with continuations instead
21:16:23 <Eduard_Munteanu> (well, in some far-fetched theory, dunno what complications may arise)
21:16:51 <luite> Saizan: maybe, but plain old exceptions are still required in any practical library
21:17:11 <kmc> mm, I suppose the code would look more like conventional PIC
21:17:25 <kmc> when I call Data.List.sort I have to go through a PLT entry which can be updated if the garbage collector moves it
21:17:30 <Eduard_Munteanu> The idea was to avoid copying if possible.
21:17:33 <Saizan> luite: i mean a WriterT that works like you want when interacting with plain exceptions
21:17:53 <luite> oh ok, maybe
21:19:20 <copumpkin> preflex: seen basvandijk
21:19:21 <preflex>  basvandijk was last seen on #haskell 3 days, 9 hours, 53 minutes and 8 seconds ago, saying: Eelis: case-insensitive-0.4 is released
21:25:52 <Eduard_Munteanu> Dang, can't find a hasktags (or similar stuff) ebuild for Gentoo...
21:27:36 <marvinalone> so i have a bunch of tokens, and they all have a line number associated with them. some of them have other data as well. what's a good way to model this in haskell?
21:28:14 <marvinalone> currently I have data Token = FooToken Int | BarToken Int | BazToken IntString | ..., but that's really cumbersome
21:29:39 <lucca> records or tuples?
21:30:05 <kmc> data Token = Token Int TokenData
21:30:12 <kmc> data TokenData = Foo | Bar | Baz String | ...
21:30:19 <dylex> Eduard_Munteanu: there's hothasktags in the haskell overlay.
21:30:47 <marvinalone> kmc: containment is the way to do it then?
21:31:00 <marvinalone> kmc: because there is nothing inheritance-like?
21:31:02 <Eduard_Munteanu> Oh, thanks. I should get it through layman and 'eix' it, I was browsing the git repo.
21:31:24 <copumpkin> marvinalone: you currently have (x * a) + (y * a) + (z * a) and kmc changed it to a * (x + y + z)
21:31:25 <copumpkin> :)
21:31:33 <kmc> there isn't anything inheritance-like, and to me this containment solution is much simpler than anything in any traditional OOP language
21:31:36 <copumpkin> distributive law ftw
21:31:49 <marvinalone> copumpkin: yes, it's still an improvement, no doubt about it :-)
21:31:52 <kmc> but my mind is warped by exposure to this dangerous functional programming stuff ;)
21:32:15 <marvinalone> kmc: well, mine is warped the other way around
21:32:22 <marvinalone> kmc: as you can probably tell :-)
21:32:34 <copumpkin> quick, we need an abstract superclass
21:32:42 * copumpkin reaches for the interface
21:32:46 <kmc> is there a specific operation you're trying to do with the containment solution, which is cumbersome?
21:32:48 <kmc> maybe we can help
21:32:59 <kmc> it's certainly not a perfect solution but neither is inheritance ;)
21:34:04 <marvinalone> kmc: so far, my cumbersome solutions have been for things like defining them all, getting the line numbers back out, etc. bookkeeping stuff.
21:34:07 <ddarius> Implementing an (Java-style) interface would have some good aspects, but wouldn't actually solve the problem.
21:34:37 <kmc> marvinalone, well with the two-type solution, you'll have a single function to get the line numbers
21:35:18 <kmc> a lot of OOP languages encourage you to have big monster classes because defining a class is cumbersome
21:35:35 <kmc> in Haskell defining a type is ~one line of code and so it's more reasonable to have lots of finely divided types
21:35:38 * ddarius isn't sure what solution marvinalone was envisioning a la inheritance that wouldn't require downcasting.
21:35:58 <kmc> also pattern-matching is compositional, so the code to get at deeply-nested structures doesn't grow at such an alarming rate
21:36:29 <marvinalone> ddarius: well, if i was writing this in java, I'd have only one getLineNumber() call. the way I had it, i had one for each token type.
21:36:47 <kmc> marvinalone, but you won't with the two-type solution I gave
21:36:58 <ddarius> marvinalone: Well that corresponds exactly to what kmc did.
21:36:59 <marvinalone> kmc: it is true, i'm changing it now
21:37:55 <ddarius> And I recommend viewing it from the perspective copumpkin suggested.
21:38:18 <ddarius> Most such manipulations are perfectly legitimate (or at least perfectly enough...)
21:39:16 <marvinalone> i hope i can make these work with the scanner and parser generators. i think i might have picked a poor project to learn a new language ...
21:39:23 <mjo> Is there some way to hide specific non-exhaustive pattern warnings using {-# yeah_I_know #-} or something similar?
21:39:42 <ddarius> mjo: Make them exhaustive with a wildcard case.
21:40:03 <mjo> Doing that adds about thirty seconds of run time =)
21:40:13 <kmc> marvinalone, you're using a parser generator?
21:40:31 <marvinalone> kmc: yes
21:40:31 <kmc> marvinalone, in Haskell we typically prefer parsing libraries, which are part of the language, to external generators
21:40:37 <ddarius> It shouldn't because they get compiled into an exhaustive case as one of the first things in going from Haskell to Core.
21:40:39 <kmc> Parsec is the most popular parsing library, but there are many alternatives
21:41:03 <marvinalone> kmc: it's part of the project requirements. i'm taking a compiler course, and badgered the prof to let me do it in haskell. now i'm paying for it :-)
21:41:07 <kmc> Haskell is expressive enough that you can write a grammar and make it *look* like BNF, but at the same time have a real Haskell term which can be abstracted etc
21:41:09 <kmc> ugh
21:41:14 <kmc> tell your prof to stuff it and that you'll do it the right way
21:41:17 <mjo> In that case, I require {-# this_shouldn't_get_slower #-} =P
21:41:32 <ddarius> "Part of the language" is poorly worded, though a good alternative way of stating it isn't coming to me right now.
21:41:40 <kmc> mjo, {-# OPTIONS_GHC -fno-warn-something #-}
21:41:47 <kmc> but it's file-level :/
21:42:09 <marvinalone> i know about parsec, but this time, it's not an option
21:42:15 <mjo> I suppose I can put grep -v in my makefile but that's almost guaranteed to have me cursing myself in a few weeks
21:42:18 <kmc> marvinalone, why not?
21:42:30 <marvinalone> kmc: because of the class's requirements
21:42:33 <kmc> tell your prof to stuff it and that you'll do it the right way
21:42:39 <kmc> you already got approval to use a weird language
21:42:41 <kmc> how much harder can it be
21:43:13 <marvinalone> to turn it around, i've spent my political capital to let me choose the language. now i have none left.
21:43:29 <kmc> yeah, I am skeptical of the concept of political capital
21:43:32 <kmc> in politics as well :)
21:43:37 <kmc> anyway do what you like
21:43:51 <kmc> but I'm afraid it will be much harder to get help with Happy than with Parsec
21:44:01 <ddarius> "You can use whatever language you want.  One can write Java in any language."
21:44:01 <kmc> indeed ddarius
21:44:09 <marvinalone> i have an extension of this project in mind, one that has real applications. i might switch it then.
21:44:14 <tomprince> I might suggest that that things like parsec *are* parser generators, just integrated into the languge.
21:44:27 <tomprince> Or, that that argument could at least be made.
21:44:36 <kmc> yeah, I assume the rule is so that you won't make some awful home-brew parser
21:44:43 <kmc> Parsec is definitely not that
21:45:11 <marvinalone> the school is (proably, behind my back) making the argument that everyone who has gone through this course knows how to use lex and yacc.
21:45:21 <tomprince> i.e. an embedded dsl, rather than an external one.
21:45:33 <kmc> I don't think Happy is close enough to YACC to make that claim, anyway
21:45:44 <kmc> can you just do a side project to demonstrate knowledge of yacc
21:45:54 <pikhq> *Bleh*, lex & yacc. I suspect manual parsing in a sane language is preferable.
21:46:15 <tomprince> That is what clang did for c/c++
21:46:28 <kmc> this sounds like a great course if you need to know how to write a compiler in 1980
21:46:33 <lucca> lex and yacc have their uses.  alex&happy are the analogous tools for haskell, and have mostly the same characteristics, for good or ill.
21:46:35 <kmc> snark snark snark
21:46:39 <pikhq> tomprince: It's strictly necessary for C++.
21:46:55 <pikhq> C++ cannot be parsed without evaluation of the type-level lambda calculus.
21:47:10 <marvinalone> i can probably get the parser done in alex, and then do the real compiler stuff in parsec, but at that point i already have a parser. this thing won't be for the ages, so i'm fine with that.
21:47:43 <marvinalone> that's not terribly clear wording: what i mean is, once i've turned in a parser, they won't care about that part anymore and i can switch it out
21:47:49 <kmc> ah ok
21:48:13 <ddarius> You definitely don't want to make the parser in Alex, unless you have some really trivial syntax.
21:49:47 <ddarius> "As far as humans are concerned, these alkaloids can be desirable, toxic, or both."
21:51:01 <Saizan> informative
21:51:11 <ddarius> "Capsaicin extract is used to make pepper spray, a useful deterrent against aggressive mammals."
21:51:14 * ddarius is finished.
21:51:41 <kmc> http://en.wikipedia.org/wiki/File:Mammal_Diversity_2011.png
21:53:30 <kmc> @nixon
21:53:30 <lambdabot> Government enterprise is the most inefficient and costly way of producing jobs.
22:01:54 <ddarius> Witchcraft, you are so hilarious.
22:34:36 <mzero> everyone must be coding!
22:35:54 <kmc> everyone's in #haskell-blah
22:36:10 <mzero> is there a haskell-blah?
22:36:19 <mzero> OMG - there is!
22:36:49 <mzero> is *that* where we send all those "this FP stuff is academic nonsense" folks?
22:38:49 * mzero waits none-too-patiently for OS X 10.7 to install on a fresh partition so he can test a candidate of HP 2011.3...
22:44:06 <sdcvv> Hello. Can you compile this short code from answer: http://stackoverflow.com/questions/7866375/why-does-ghc-think-that-this-type-variable-is-not-injective/7950263#7950263
22:44:42 <sdcvv> preferably in GHC 7.2
22:46:29 <mzero> why isn't that     fin (ErrorEff h) = h    ?
22:46:41 * mzero might not just understand such constructs, of course
22:47:09 <copumpkin> ErrorEff is the type constructor
22:47:11 <mzero> wait - nevermind
22:47:28 <mzero> yes, that form of Constructor (what is it called) throws me
22:48:55 <sdcvv> it seems to me it's a bug, but I don't have 7.2 at the moment
22:49:34 <copumpkin> you should attach that reduction to the ticket: http://hackage.haskell.org/trac/ghc/ticket/5591
22:53:02 <stepkut> is there a way to extend this function:
22:53:03 <stepkut> comp :: (b -> c) -> (a -> b) -> (a -> c)
22:53:03 <stepkut> comp g f = g . f
22:53:19 <stepkut> so that 'f' can take any number of arguments :-/
22:53:34 <stepkut> seems-like... no
22:53:42 <stepkut> but I should have gone to bed 2 hours ago:)
22:53:52 <sdcvv> stepkut: how do you plan to use it?
22:54:14 <sdcvv> stepkut: perhaps comp g f = (g .) . f
22:54:52 <ddarius> There is a way to sort of do it, but the answer is mostly "no" since there is an essential ambiguity to how "deeply" you want to compose.
22:55:14 <stepkut> yeah
22:55:48 <stepkut> the way I actually want to use it is a bit different
22:55:49 <stepkut> one moment
22:58:24 <stepkut> what I actually have is more like:
22:58:25 <stepkut> foo :: (b' -> b) -> (b -> c) -> (b' -> c)
22:58:25 <stepkut> foo f g = \b -> g (f b)
22:58:25 <stepkut>  
22:58:59 <sdcvv> stepku: foo f g = g . f, or foo = flip (.)
22:59:03 <sdcvv> *stepkut
22:59:15 <stepkut> but I want the b' part to be any number of terms
22:59:21 <stepkut> so I could also have:
22:59:58 <stepkut> foo2 :: (b'' -> b' -> b) -> (b -> c) -> (b'' -> b' -> c)
22:59:58 <stepkut> etc
23:00:12 <stepkut> but having to have foo1 through fooN is annoying
23:00:38 <ddarius> If you collect your parameters into tuples, then (.) does what you want.
23:00:44 <marvinalone> I must be retarded. Why doesn't this work?: i where i = 1
23:00:59 <ddarius> Otherwise how is it suppose to know how deeply you want to apply the function?
23:01:17 <sdcvv> marvinalone: you can write a declaration: j = i where i = 1, or an expression: let i = 1 in i
23:01:23 <ddarius> marvinalone: Because that is not valid syntax.  'where' is part of the function declaration syntax, it is not an expression on its own.
23:01:43 <marvinalone> ddarius: it needs a function to determine its scope?
23:02:05 <ddarius> marvinalone: No, it is just part of the function declaration syntax.
23:02:19 <marvinalone> i see
23:02:39 <stepkut> ddarius: right.. though there is really only one useful implementation of foo2 I think?
23:02:46 <sdcvv> it doesn't need to be function, for example a = b where b = 5 compiles, but there are no functions here
23:02:55 <stepkut> ddarius: i mean, there is a clear pattern here.. just not one we can exploit in Haskell AFAIK
23:03:39 <ddarius> stepkut: There is a pattern and you could capture it, but you still need some way of saying how deeply to apply the passed in unary function.  One way or another you need a way to specify that.
23:03:45 <marvinalone> sdcvv: a is a function, no?
23:03:55 <sdcvv> marvinalone: no, it's a number
23:03:56 <stepkut> how deeply?
23:04:52 <marvinalone> sdcvv: i'd say b is a function, too. it takes zero arguments and returns 5. then again, i'm the beginner here.
23:05:33 <sdcvv> marvinalone: conal.net/blog/posts/everything-is-a-function-in-haskell
23:05:47 <sdcvv> http://conal.net/blog/posts/everything-is-a-function-in-haskell
23:05:51 <ddarius> If f :: a -> b and g :: b -> c and I write g . f, how deeply should g be applied. What if b is (x -> y)?  What if y is (u -> v)?
23:07:22 <stepkut> I want 'f' to be apple to all the arguments, and then I want g to be apply to the result..
23:07:29 <stepkut> deeply does not mean anything to me
23:07:30 <jtannenbaum> then g . f will still be of type (a -> c)?
23:07:57 <sdcvv> stepkut: compose (.)
23:07:58 <ddarius> stepkut: Then that is what (.) does.  Every function in Haskell has exactly one argument and one result.
23:08:08 <sdcvv> stepkut: for example (.).(.).(.) :: (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
23:09:18 <stepkut> sdcvv: but I don't know how many I need in advance
23:09:23 <stepkut> one moment
23:10:30 <mzero> stepkut - perhaps you could put together a short code example on hpaste for us to see... I think in general there are other ways around this
23:11:01 <marvinalone> sdcvv: thanks, great explanation
23:14:07 <stepkut> what I want is impossible
23:14:12 <stepkut> just annoying that it is
23:14:29 <stepkut> if I have the function:
23:14:31 <stepkut> grr :: (c -> a) -> (a -> b) -> (c -> b)
23:14:46 <ddarius> There are ways to get something like what you seem to want, as I've said several times, but you haven't actually unambiguously defined what you want.
23:14:55 <ddarius> You are assuming Haskell has a notion of arity that it does not have.
23:15:27 <stepkut> I can do, grr (undefined :: c -> a) (undefined :: a -> b -> b' -> b'') , with no problem
23:16:32 <stepkut> because b -> b' -> b'' is a valid substitution for b in (a -> b)
23:16:54 <mzero> stepkut - show us the bigger picture - I bet you don't actually need a generalized version of (.)
23:17:54 <stepkut> mzero:  one moment
23:20:10 <ddarius> stepkut: How many arguments does: f :: a -> b -> c have?
23:31:19 <hpaste> stepcut pasted “arrow parser fmap-like” at http://hpaste.org/53352
23:33:22 <stepkut> so, the essence of the problem is that is easy for me to build a parser that parses, 2011 10 31. But it is messy to convert from, Integer -> Int -> Int -> a, to Day -> a. Even though fromGregorian has the type, Integer -> Int -> Int -> Day
23:33:57 <hpaste> o-_-o pasted “splitEvery for Vector” at http://hpaste.org/53353
23:34:14 <o-_-o1> I am writing splitEvery for Data.Vector
23:34:17 <stepkut> I can use functions like amap2 - amapN. But it is annoying to have all those functions since they clearly all have the same pattern, just a different number of arguments
23:34:37 <o-_-o1> see above paste, but how do I write a function pattern for empty Data.Vector ?
23:35:01 <o-_-o1> The above function fails to compile with error: Split.hs:7:35: Qualified name in binding position: DV.empty
23:35:36 <stepkut> the best solution I have so far is this function: amap :: a -> RouteParser a b -> RouteParser (b -> c)  c
23:35:38 <ivanm> o-_-o1: use guards with DV.null or something
23:35:48 <ivanm> if you really want, use ViewPatterns
23:35:49 <lucca> everything has zero arguments
23:36:06 <o-_-o1> lucca: yeah I saw that wrong paste :-)
23:36:34 <o-_-o1> ivanm: are functions with guards optimized as well as the other ones by GHC ?
23:36:58 <ivanm> I don't think there's any practical difference...
23:37:04 <o-_-o1> ivanm: ok
23:37:22 <stepkut> amap fromGregorian ymd
23:37:25 <stepkut> which works fine..
23:39:54 <stepkut> but amap does not turn fromGregorian into an arrow. Just into a function that modifies an arrow.
