00:00:16 <solidsnack> And the adversary can induce N^2 behaviour.
00:00:39 <laziest> So what is your goal? is it just to check whether a string fits your criteria, or to create a such a string?
00:00:49 <solidsnack> laziest: To create the string.
00:01:01 <solidsnack> Given an input string, create the HEREDOC delimiter for it.
00:01:20 <laziest> You can then just take a substring of the input,
00:01:24 <laziest> and modify it in a systematic way.
00:01:26 <laziest> forget random.
00:01:45 <laziest> It will be exponentially little likely that it will be a substring.
00:02:17 <solidsnack> laziest: Well, actually, if it's a systematic way, than I bet I can construct an input that requires N comparisons to be made.
00:02:45 <laziest> that's true.
00:02:50 <laziest> so do you want to avoid such things?
00:03:13 <solidsnack> I want to have good worst case bounds.
00:03:13 <laziest> Do you think your input can be constructed in real cases to slow down your algorithm?
00:03:56 <laziest> Or how about this: Just generate one random number, say between 1 to 255,
00:04:08 <laziest> and use it to modify the chosen substring systematically.
00:04:22 <laziest> Will that have this problem?
00:04:32 <Sgeo|web> :t pure
00:04:33 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
00:06:07 <laziest> solidsnack: you there?
00:06:31 <solidsnickers> Dropped wifi, sorry.
00:06:56 <solidsnickers> laziest: I would rather think about the characteristics/safety of the algorithm than try to make guesses about the data.
00:08:32 <solidsnickers> laziest: Last thing I saw was: Do you think your input can be constructed in real cases to slow down your algorithm?
00:08:53 <laziest> ok. I will paste the rest.
00:09:03 <laziest> Or how about this: Just generate one random number, say between 1 to 255,
00:09:09 <laziest> and use it to modify the chosen substring systematically.
00:09:14 <laziest> Will that have this problem?
00:09:24 <solidsnickers> Good question, I don't know.
00:10:15 <solidsnickers> Say the data contains all such strings, like, it is a countdown of things.
00:10:21 <solidsnickers> I could see this issue.
00:10:27 <laziest> Hmmm.
00:10:51 <solidsnickers> I think really, we have an interesting difference in philosophy.
00:11:05 <laziest> Even after randomizing which substring to modify?
00:11:08 <laziest> Eh?
00:11:22 <solidsnickers> Randomness doesn't affect the worst case in any way.
00:12:17 <laziest> You mean to say even if the chosen delimiter strings were completely random, you want to make sure you have a good worst case?
00:12:27 <solidsnickers> Yes, absolutely.
00:12:46 <solidsnickers> In part because, I want very short delimiter strings.
00:12:56 <laziest> Ah.
00:13:03 <solidsnickers> For a 4M string, 4 hex digits should be enough.
00:13:36 <laziest> It could have all those combinations though.
00:13:40 <solidsnickers> Or no, 8 hex digits.
00:14:54 <solidsnickers> Actually, 6 is enough.
00:15:11 <laziest> Hm.
00:15:17 <solidsnickers> Maybe I have to loosen that, though.
00:15:36 <laziest> Too tight.
00:16:00 * hackagebot tagged-list 1.1 - Lists tagged with a type-level natural number representing their length.  http://hackage.haskell.org/package/tagged-list-1.1 (GregoryCrosswhite)
00:16:05 <solidsnickers> Too tight?
00:16:10 <johnfn> is there an easy way to get the inferred type of some function/object, ideally for help understanding type errors?
00:16:29 <solidsnickers> johnfn: In the interpreter, using :type
00:16:47 <laziest> no, just what you said. we said it at the same time.
00:17:02 <solidsnickers> I see.
00:17:10 <johnfn> solidsnickers, thanks, i do know about :type, but it has some limitations like i can't get the :type of a variable in a where block (can i?)
00:17:29 <johnfn> and since i have type errors it's kinda hard to load the whole thing in ghci
00:17:54 <solidsnickers> johnfn: Well, you can replace definitions with undefined till it loads :)
00:18:04 <johnfn> :-)
00:18:11 <johnfn> i never thought of that...
00:18:30 <solidsnickers> johnfn: I am not sure that there has ever evolved a way to do what you want though; I'm not aware of anyway to poke at the variables in a where block.
00:18:43 <johnfn> hm, ok thanks
00:18:43 <laziest> solidsnickers: can't think of anything rightaway.
00:19:11 <johnfn> one day im imagining a haskell ide that shows inferred type on mouseover
00:19:20 <solidsnickers> laziest: The random approach can certainly work. The idea of loading all the data in to a lazy trie appeals to me.
00:19:35 <Sgeo|web> mouseover might not be ideal, what about types of expressions?
00:19:48 <laziest> What's a trie?
00:20:01 <ivanm> @google wikipedia trie
00:20:02 <lambdabot> http://en.wikipedia.org/wiki/Trie
00:20:02 <lambdabot> Title: Trie - Wikipedia, the free encyclopedia
00:20:04 <solidsnickers> A "prefix tree" or lookup tree, if you like.
00:20:05 <johnfn> Sgeo|web, you could do something clever :-)
00:20:24 <laziest> Oh.
00:20:55 <laziest> I was thinking in terms of "tails", perhaps they have a connection.
00:21:14 <ivanm> laziest: tails, and then merge those with common prefixes
00:21:21 <ivanm> to get yourself a tree
00:21:31 <laziest> Yes.
00:21:34 * ivanm just realised that his fancy parser does that under the hood
00:21:55 <laziest> Ok, see you. Lunch time.
00:21:59 <solidsnickers> Cheers.
00:22:14 <solidsnickers> Been good talking with you all; I'm logging out for the evening.
00:34:11 <Blkt> good morning everyone
00:36:01 * hackagebot xcb-types 0.6.1 - Parses XML files used by the XCB project  http://hackage.haskell.org/package/xcb-types-0.6.1 (AntoineLatter)
00:39:36 <ybit> wee! #haskell
00:40:06 <ion> urine!
00:40:34 <ybit> (6, 'a') :: (Num t) => (t, Char) -- i guess you can read this as t of any type Num and t of any type Char?
00:41:17 <ion> t is any type that’s an instance of Num and Char is, well, Char.
00:41:21 <Cale> For any type t, if t is an instance of Num, then (6, 'a') can have type (t, Char)
00:41:31 <shachaf> What does "t of any type Char" mean?
00:41:48 <ybit> probably any of the ascii values
00:41:54 <ybit> ascii characters*
00:41:57 <shachaf> t is a type, not a value.
00:42:11 <ybit> ah
00:42:13 <Cale> Yeah, so for example, (6,'a') :: (Integer, Char) is valid
00:42:22 <Cale> as well as (6,'a') :: (Double, Char)
00:42:33 <shachaf> ybit: Any reason for using the tuple?
00:42:38 <Cale> :t 5
00:42:39 <lambdabot> forall t. (Num t) => t
00:42:42 <ybit> it's just an example
00:42:44 <Cale> :t 5 :: Integer
00:42:45 <lambdabot> Integer
00:42:49 <Cale> :t 5 :: Double
00:42:50 <lambdabot> Double
00:42:55 <Sgeo|web> :t undefined
00:42:56 <lambdabot> forall a. a
00:43:01 <shachaf> I guess maybe to highlight the difference between forall t. Num t => (t,Char) and (forall t. Num t => t,Char)?
00:43:10 <Cale> > 5 :: Double -- sometimes the show instance prints it differently
00:43:11 <lambdabot>   5.0
00:43:19 <Cale> > 5 :: Complex Double
00:43:20 <lambdabot>   5.0 :+ 0.0
00:43:22 <ybit> the (Num t) part is confusing me
00:43:25 <Cale> > 5 :: Rational
00:43:26 <lambdabot>   5 % 1
00:43:34 <Cale> ybit: That's a typeclass constraint
00:43:43 <ybit> oh, type classes, haven't gotten there yet
00:43:49 <Sgeo|web> I don't think you can do (forall t. Num t => t,Char)
00:43:56 <Cale> It means that t can't just be *any* type, but has to support a certain set of operations
00:44:09 <Cale> (specifically, the operations (+), (*), fromInteger, and a few others)
00:44:28 <Sgeo|web> (and it's not duck-typing, it has to refer to the actual class that defines those operations)
00:44:41 * Sgeo|web glares in Python's and Ruby's direction for no reason
00:45:07 <Cale> :t (+)
00:45:07 <lambdabot> forall a. (Num a) => a -> a -> a
00:45:25 <Sgeo|web> Hmm, what if you want to write an instance for something, but if it's not installed or whatever, don't want the compile to fail?
00:45:40 <Cale> ^^ this says that the arguments to, and the result of (+) all have the same type, and that it can be any type which is an instance of Num
00:45:41 <Sgeo|web> *but if the class is not installed
00:45:58 <Cale> Sgeo|web: ?
00:45:59 <Sgeo|web> I guess the instance could be defined in a separate module?
00:46:09 <Cale> Sgeo|web: Instances can go in a separate module
00:46:16 <Sgeo|web> And then if someone wants to use the type as an instance of the class, they can import that module too
00:46:20 <Cale> But you can't write an instance for a class which doesn't exist
00:47:49 <shachaf> Sgeo|web: Why not?
00:48:16 <shachaf> Sgeo|web: Also, type classes are a lot like duck typing.
00:48:56 <Sgeo|web> shachaf: except you're not relying on everyone agreeing that a method named something means do whatever
00:49:02 <ivanm> shachaf: they are?
00:49:42 <shachaf> ivanm: Yes, except more static/formalized/compiler-checked.
00:50:08 <MatrixFrog> i thought part of the definition of duck typing was that it was not formalized or compiler-checked
00:50:38 <ion> Except for that part, of course. :-P
00:50:54 <ion> He said “a lot like”, not “equal to”.
00:50:56 <kmc> they're pretty similar except for all the differences
00:51:18 <Sgeo|web> Scala has, iiuc, something more like duck-typing than type-classes are.
00:51:37 <shachaf> kmc: Right.
00:51:38 <Sgeo|web> It looks at the name of the methods, but does that at compile-time
00:51:45 <ion> “foo :: Num t => t -> t; foo = negate”: foo takes anything that quacks like a Num and throws negate at it.
00:51:46 <shachaf> A superset of a subset.
00:52:45 <fr4nk> hi there
00:53:07 <fr4nk> just downloaded & installed the haskell plattform for windows
00:53:41 <fr4nk> question: how i change directory with space in it?
00:54:11 <shachaf> fr4nk: In ghci or in the Windows prompt or what?
00:54:30 <fr4nk> yes in ghci windows prompt, i loaded prelude and want to change the dir
00:54:45 <Sgeo|web> "internally, a Text value is represented as packed UTF-16 data."
00:54:47 <fr4nk> :cd "My Documents" i got a lot of errors
00:54:56 <Sgeo|web> What is 'packed' as opposed to what I assume is unpacked
00:54:59 <shachaf> fr4nk; I don't think you need quotes.
00:55:23 <fr4nk> i tried it every way i an imagine, i cant get into a folder which contains spaces
00:55:32 <shachaf> Sgeo|web: I presume they mean "next to each other in memory".
00:55:36 <shachaf> Like an array.
00:55:42 <shachaf> fr4nk: Why do you need to chdir from ghci?
00:55:50 <Sgeo|web> Ah
00:55:57 <fr4nk> i wanna run a *.hs file i wrote..
00:55:58 <shachaf> If what you're trying isn't working, just exit ghci, chdir, and then rerun it.
00:56:06 <shachaf> fr4nk: You don't usually use ghci to run .hs files.
00:56:30 <Cale> fr4nk: On linux, you can just write the spaces normally without any quotes and it'll work... I don't know about windows
00:56:38 <Ptival> shachaf: I do :\
00:57:06 <fr4nk> hm ok i will try it under linx later on
00:57:21 <Cale> I usually run ghci with the name of the .hs file on the commandline though
00:57:38 <shachaf> Ptival: To *run* them? As in :main?
00:57:43 <Cale> (so I'm already in whatever directory I need to be in)
00:57:52 <shachaf> Cale: Sure, but I wouldn't consider that running.
00:57:59 <shachaf> Also, I'd just chdir first and then run ghci.
00:58:04 <shachaf> Or run ghci with the full path.
00:58:06 <Ptival> shachaf: ok, if you don't consider that running :)
00:58:12 <fr4nk> but our exercise teacher showed us to load our own files (for homework for example)
00:58:16 <Ptival> probably to test some functions, which could happen to be main
00:58:26 <ion> > fst ((6, 'x') :: (forall a. Num a => a, Char))
00:58:27 <lambdabot>   6
00:58:46 <ion> > (show . fst) ((6, 'x') :: (forall a. Num a => a, Char))
00:58:46 <lambdabot>   Cannot match a monotype with `forall a. (GHC.Num.Num a) => a'
00:59:04 <Cale> fr4nk: it is weird that you can't get that to work... it's definitely a bug if it still doesn't work without the quotes
00:59:12 <ion> Why does ghci/lambdabot show the value but i can’t do that explicitly?
00:59:48 <shachaf> > show (fst ((6, 'x') :: (forall a. Num a => a, Char)))
00:59:49 <lambdabot>   "6"
00:59:59 <shachaf> ion: It's a Rank-N types thing, I'm guessing.
01:00:24 <fr4nk> alright, i opened cmd changed dir to my files and then run ghci
01:00:32 <fr4nk> now load works :)
01:01:16 <Cale> also probably ImpredicativeTypes
01:01:27 <Cale> as well as aggressive defaulting
01:01:38 <shachaf> Oh, you weren't running ghci from cmd.
01:01:49 <mysticc> @Hoogle JsonParser
01:01:49 <lambdabot> Maybe you meant: google hoogle
01:01:54 <mysticc> @hoogle JsonParser
01:01:55 <lambdabot> No results found
01:02:18 <mysticc> which package the module JsonParser belongs to ??
01:03:07 <Sgeo|web> :t intersperse
01:03:08 <lambdabot> forall a. a -> [a] -> [a]
01:03:14 <Sgeo|web> :t interpolate
01:03:15 <lambdabot> Not in scope: `interpolate'
01:03:17 <Cale> hmm, apparently nothing on Hackage has a module by that name
01:03:29 <Sgeo|web> @hoogle [a] -> [a] -> [a]
01:03:29 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
01:03:30 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
01:03:30 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
01:03:41 <Cale> There's a Text.JSON.JSONParse in JSON-Combinator
01:03:57 <Sgeo|web> What's the thing that takes a list and puts it between all elements of a list?
01:04:14 <Cale> :t intersperse
01:04:15 <lambdabot> forall a. a -> [a] -> [a]
01:04:28 <ion> :t intercalate
01:04:29 <lambdabot> forall a. [a] -> [[a]] -> [a]
01:04:37 <Cale> right
01:04:44 <ion> There’s also that which you might or might not want.
01:04:48 <Cale> :t concat . intersperse
01:04:49 <lambdabot>     Couldn't match expected type `[[a]]'
01:04:49 <lambdabot>            against inferred type `[a1] -> [a1]'
01:04:50 <lambdabot>     Probable cause: `intersperse' is applied to too few arguments
01:04:59 <Cale> :t (concat .) . intersperse
01:05:00 <lambdabot> forall a. [a] -> [[a]] -> [a]
01:05:04 <Cale> yeah, it's just that :)
01:05:27 <Sgeo|web> Pointfree gives me headaches
01:05:38 <Sgeo|web> @unpl (concat .) . intersperse
01:05:38 <lambdabot> (\ d g -> concat (intersperse d g))
01:07:13 <cheater> :t intersperse
01:07:14 <lambdabot> forall a. a -> [a] -> [a]
01:21:01 * hackagebot xhb 0.5.2011.10.21 - X Haskell Bindings  http://hackage.haskell.org/package/xhb-0.5.2011.10.21 (AntoineLatter)
01:29:02 <dixie_> Is there any reason when Haskell do a copy of the immutable data? I would like to transform list of data entries to kind of tree where single item will be within tree multiple times. I hope that they will actually use single copy in memory...
01:33:15 <quicksilver> dixie_: they will be a single copy yes
01:33:17 <Jafet> Sure, they are shared in Glasgow Haskell.
01:55:50 <dixie_> quicksilver: thats great... in C++ I would use pointers
01:56:01 <quicksilver> dixie_: in haskell everything is a pointer :)
01:56:03 <dixie_> haskell hides this for me ;)
02:15:37 <Sgeo|web> Does hint habve a thing where I can tell it to compile an expression as untrusted?
02:18:08 <erus`> > take 5 $  fix (1:)
02:18:09 <lambdabot>   [1,1,1,1,1]
02:18:21 <Tinned_Tuna> > fix (1:)
02:18:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:18:32 <Tinned_Tuna> learn something new every day...
02:21:48 <Sgeo|web> > fix (\fact x -> if x == 0 then 1 else x * fact (x - 1)) 5
02:21:49 <lambdabot>   120
02:21:55 <Sgeo|web> Tinned_Tuna: ^
02:22:19 <Sgeo|web> fix brokenThing
02:22:22 <Sgeo|web> > fix brokenThing
02:22:24 <lambdabot>   Fixed.
02:22:40 <Tinned_Tuna> Sgeo|web: secretly using let somewhere in a private message? :-p
02:23:00 <Sgeo|web> I didn't define it, someone else did or something
02:23:08 <Sgeo|web> It's part of the bot, I guess
02:23:51 <Sgeo|web> Or do you mean with the factorial example?
02:25:21 * Sgeo|web did not cheat with factorial
02:28:34 <erus`> why do people write more than 80 characters on a line
02:28:37 <erus`> shame on them
02:28:39 <ben> 78
02:29:36 <frerich> erus`: I hear there are editors and fonts and resolutions and displays these days which are able to display more than eighty characters without reducing readability too much.
02:29:54 <erus`> frerich: but now we can panel different window
02:30:07 <ben> I'm a fan of having multiple editor windows open horizontally adjacent
02:31:11 <erus`> any one who has lines longer than 80 chars or uses spaces instead of tabs generally has a low IQ
02:31:28 * frerich shrugs
02:31:51 <erus`> or uses the phrase 'web scale'
02:32:33 <erus`> I need to learn a less ambiguous language
02:32:45 <int-e> #haskell may not be the best place for promoting tabs over spaces.
02:33:55 <bartavelle> surely people who can handle longer lines have a higher IQ
02:34:54 <int-e> but the same argument can be made for people who can express themselves succinctly.
02:35:14 <bartavelle> I suppose this problem will not be solved in our lifetime
02:35:49 <Ferdirand> there should be a pair of tab-in/tab-out characters
02:36:15 <ben> int-e: Surely conserving vertical space is also part of expressing yourself succinctly
02:37:46 <bartavelle> what is the name of the utility that refactors an expression so that it is full of "." and unreadable to me ?
02:37:54 <erus`> google dart seemed to fizzle out then... go was a bigger deal when it was released
02:37:59 <Ferdirand> acting as invisible curly braces
02:38:00 <Ferdirand> or, since we already have curly braces, train our editors to treat them as such
02:38:00 <erus`> bartavelle: @pl
02:38:12 <bartavelle> there is a command line equivalent, right ?
02:38:18 <int-e> @pl \a b c d -> d b c a d
02:38:19 <lambdabot> flip flip id . ((flip . (ap .)) .) . flip (flip . (flip .) . flip . flip id)
02:38:23 <bartavelle> flip
02:38:27 <bartavelle> wow
02:38:41 <Eduard_Munteanu> bartavelle: you can (try to) install lambdabot locally
02:38:59 <Eduard_Munteanu> Otherwise, no, ghci itself doesn't provide it.
02:39:15 <bartavelle> ah, I thought somebody would have written just this part of lambdabot as a standalone command
02:39:26 <Eduard_Munteanu> Oh, it might be.
02:39:29 <erus`> someone gave me a script to integrate lambdabot into ghci
02:39:55 <Eduard_Munteanu> @hackage pointfree
02:39:56 <lambdabot> http://hackage.haskell.org/package/pointfree
02:40:05 <bartavelle> ah nice
02:40:54 <Eduard_Munteanu> You may also send private messages to lambdabot.
02:41:30 <gienah> erus`: GHCi on Acid is an extension to GHCi (Interactive GHC) for adding useful lambdabot features. git://github.com/chrisdone/goa.git
02:41:49 <gienah> erus`: GOA and lambdabot may be difficult to build
03:05:16 <Ikarus> Is this an odd way to generate pairs (assumes (x,y) == (y,x)) natPairs = [ (x, y-x) | y <- [0..], x <- [0..(floor ((fromInteger y) / 2))] ]
03:05:59 <quicksilver> y`div`2 is a simpler way to write floor((fromInteger y)/2)
03:06:06 <quicksilver> probably faster, as well.
03:06:24 <quicksilver> apart from that, looks fine to me
03:07:42 <Ikarus> nice :)
03:16:04 * hackagebot concorde 0.1 - Simple interface to the Concorde solver for the Traveling Salesperson Problem  http://hackage.haskell.org/package/concorde-0.1 (KeeganMcAllister)
03:28:51 * Baughn is very surprised to not find a fast integer log2 function anywhere..
03:32:41 <dafis> Baughn: why?
03:33:15 <Baughn> dafis: Well, it's a fairly fundamental function
03:33:21 <dafis> Baughn: there is one, in integer-gmp as of ghc-7.2, also in arithmoi
03:33:40 <Baughn> OIC. Then I'm surprised about hayoo not finding it. :P
03:33:58 <Baughn> (Of course I'm still on 6.12)
03:34:14 <dafis> arithmoi works with 6.12
03:34:24 <Baughn> Which is great.
03:34:36 <dafis> :)
03:34:52 <Baughn> ..I see. Thanks for this library. :)
03:35:02 <dafis> de nada
03:35:05 <Baughn> Er
03:35:12 <Baughn> Math/NumberTheory/Utils.hs:156:1: The type signature for `bitCountInt' lacks an accompanying binding
03:35:47 <dafis> Oops, CPP failure, I think give me a couple of minutes to fix it
03:36:03 <dafis> I think,*
03:36:05 <Baughn> Go ahead. I'm going to go ahead and upgrade ghc, though.
03:44:11 <dafis> Hmm, I had a copy-pasto, but that was in #if __GLASGOW_HASKELL__ >= 703, so shouldn't hit 6.12
03:46:52 <Sgeo|web> > let { b = a; a = 5 } in b
03:46:53 <lambdabot>   5
04:16:36 <erus`> let { a = b; b = a; } in a == b
04:16:49 <erus`> > let { a = b; b = a; } in a == b
04:16:53 <lambdabot>   mueval-core: Time limit exceeded
04:17:07 <erus`> haskell, why can't you reason?
04:22:44 <frerich> Hm, I think Haskell could be used to build a really really nice DSL for build systems. Is there a project like this already?
04:22:59 <frerich> As in, a make replacement.
04:23:10 <frerich> (or the self-made JavaScript-based stuff we use in this company, urgs...)
04:25:43 <Baughn> frerich: cabal?
04:25:45 <dafis> Baughn: I got warning-free builds with 6.12.3, 7.0.4, 7.2.1 and 7.3.forgotwhenexactly, uploaded to hackage, if you still have your previous 6.12 installed, could you try again with that?
04:25:59 <Baughn> dafis: Sorry..
04:26:06 <quicksilver> frerich: http://community.haskell.org/~ndm/shake/
04:26:08 <frerich> Baughn: I'm not too familiar with Cabal, but I thought it's actually something built on top of Make?
04:26:17 <frerich> Baughn: I was thinking of something where the 'Makefiles' are actual Haskell scripts.
04:26:18 <Baughn> frerich: No, it doesn't use Make.
04:26:19 <dcoutts> frerich: yes, I agree. It's actually more tricky than it looks.
04:26:27 <Baughn> frerich: But it's also very haskell-specific, I think
04:26:46 <dafis> Baughn: okay, would just have been interesting
04:27:07 <frerich> quicksilver: That looks nice, it's exactly what I had in mind :-)
04:27:11 <dcoutts> frerich: ndm's shake is one decent approach. I have some other ideas I'm exploring.
04:27:51 <dcoutts> frerich: and btw, cabal's build system is not built on anything like this, cabal's build system is actually very primitive, which is my motivation for looking at this issue
04:28:00 <quicksilver> frerich: also hake
04:28:01 <dafis> Does anyone here understand Safe Haskell?
04:28:07 <quicksilver> frerich: http://hackage.haskell.org/package/hake
04:28:11 <dcoutts> dafis: I think I do
04:28:17 <frerich> dcoutts: Excellent? Unfortunately (?) have to deal with different build systems in the different projects here at work (mostly automake/autoconf, cmake, plain GNU make and qmake - and then there's a self-made build system...) and whenever I have to touch something I wish for things like 'filter' or 'map' or having functions as first class citizens.
04:28:27 <frerich> dcoutts: s/Excellent?/Excellent!/ :-)
04:28:44 <frerich> quicksilver: That's interesting, too!
04:29:13 <dcoutts> frerich: so something like hake would give you that. I'm aiming at something more ambitious where you cannot write incorrect build rules (enforced by a combo of static and dynamic checks).
04:30:28 <dafis> dcoutts: I don't :(, so, if I have a package using lots of unsafeFreeze/Thaw/... (but no IO), but in a safe way (unless ghc itself does the wrong thing), should I mark it as safe, trustworthy, or isn't it worth bothering at all?
04:31:07 <dcoutts> dafis: if you think you're using unsafe features in such a way that the external exposed interface can only be used safely then you mark that module as trustworthy
04:31:47 <dcoutts> dafis: then if other people believe that you've audited it correctly then they can indicate they trust your package, and so believe your trustworthy annotations
04:32:26 <dcoutts> you can't mark your module as safe, because it's not, it is using unsafe features.
04:33:17 <dcoutts> if you don't bother at all then it means people trying to compile modules in the safe subset of haskell cannot make use of your module
04:33:44 <dafis> dcoutts: okay, and if I don't bother, the modules can't be in safe haskell at all?
04:33:45 <dcoutts> dafis: clear as mud?
04:33:55 <dcoutts> dafis: right
04:34:10 <frerich> dcoutts: That sounds really interesting :-)
04:34:17 <dafis> muddy, but much clearer than what's written in the ghc wiki
04:34:43 <dcoutts> dafis: we need some user-oriented docs in the haskell wiki imho
04:35:16 <dcoutts> it should start with the simple case, ie compiling modules using the safe language subset
04:35:18 <frerich> dcoutts: I worked on the inhouse build system (Which basically runs all the 'Makefiles' containing JavaScript) to make it able to execute jobs in parallel,  so I do have some experience with build systems. However, I'm still quite new to Haskell. This might be a good project for me :-)
04:35:30 <frerich> dcoutts: You don't happen to have something on github yet or the like, do you?
04:35:51 <dafis> dcoutts: I agree, now find someone qualified to write the page ;)
04:36:29 <dcoutts> dafis: the trick is to write it how you see it, then point it out to the authors, they'll be so annoyed by all the mistakes they'll fix it ;-)
04:36:48 <dafis> which authors?
04:36:50 <dcoutts> frerich: sorry, nothing usable yet.
04:36:56 <dcoutts> dafis: safe haskell authors
04:37:19 <dafis> that's David Terei and?
04:37:21 <dcoutts> right
04:37:41 <dcoutts> and co-authors :-)
04:39:04 <basvandijk> The only thing I don't understand about Safe Haskell is why I have to explicitly mark modules as Thrustworthy. I would be useful to mark modules as Unsafe (which I believe will be possible in ghc-7.4). However why shouldn't I mark a module as Thrustworthy?
04:39:20 <basvandijk> s/I/It
04:40:16 <dcoutts> frerich: this approach of demanding correctness makes it all rather difficult to come up with the right DSL, I only just worked out a scheme that I think looks promising
04:40:39 <ion> I like the concept of thrustworthy modules.
04:40:41 <dcoutts> basvandijk: because if you're marking something as Thrustworthy then you have a proof obligation
04:41:02 <ion> Haskell – code you can thrust.
04:41:10 <basvandijk> dcoutts: Yes but that's an *informal* proof obligation right?
04:41:16 <dcoutts> basvandijk: sure
04:41:35 <basvandijk> users of your package have to trust you
04:41:51 <ion> or thrust
04:41:55 <basvandijk> But isn't that the case by default
04:41:57 <dcoutts> basvandijk: they have to trust that you've marked things appropriately
04:42:26 <dcoutts> basvandijk: remember that it's still ok for packages to export unsafe stuff from modules, they just have to not mark those modules as trustworthy
04:42:34 <frerich> quicksilver: Thanks for pointing out 'Shake'! "Hake" is pretty much what I was envisioning, but "Shake" appears to be not only express the targets in Haskell scripts, it also has some interesting ideas for tracking dependencies and handling generated files.
04:42:43 <frerich> Too bad it doesn't appear to be open source. :-/
04:42:48 <dcoutts> basvandijk: consider the base package, obviously we will have to "trust" the authors of the base package or we'll never get anything done.
04:43:03 <dcoutts> basvandijk: but base contains System.IO.Unsafe which exports unsafePerformIO
04:43:17 <dcoutts> basvandijk: but that's fine, because System.IO.Unsafe is not marked trustworthy
04:43:29 <basvandijk> dcoutts: Yes, I see your point
04:43:40 <dcoutts> so it's not something the compiler can infer
04:43:59 <dafis> although, with the names, you can trust that these functions are unsafe
04:44:12 <dcoutts> so an explicit annotation of "yes I believe this module does export a safe interface despite my use of unsafeMumble..."
04:44:17 <dafis> so in that sense, it's trustworthy ;)
04:44:17 <dcoutts> is required
04:44:57 <dcoutts> then the Unsafe marking is again totally different
04:45:01 <quicksilver> frerich: yes, not sure what the back story is on shake's license. NDM's other stuff has been open.
04:45:02 <dcoutts> which is confusing
04:45:16 <quicksilver> frerich: someone started the task of reimplementing shake but I don't know how far it got
04:45:17 <dcoutts> quicksilver: developed at work
04:45:20 <quicksilver> still it has interesting ideas as you say.
04:45:29 * dcoutts isn't satisfied with shake
04:45:55 <quicksilver> https://github.com/batterseapower/openshake
04:45:56 <dcoutts> though I admit it's very practical where as my stuff is vapourware
04:50:35 <frerich> Is 'batterseapower' here? :-)
04:50:56 * Baughn makes ritual offerings to laziness. Thank Eris for laziness.
04:52:38 <cirno_the_greate> is there any tool to draw function diagram for sources?
04:52:45 <cirno_the_greate> from
04:53:19 <dcoutts> frerich: he's called mbolingbroke here, and he's not around at the moment
04:53:45 <quicksilver> cirno_the_greate: http://hackage.haskell.org/package/SourceGraph
04:54:14 <quicksilver> cirno_the_greate: see also the good answers in http://stackoverflow.com/questions/3431225/tools-for-generating-haskell-function-dependency-control-flow-graph
04:54:33 <cirno_the_greate> quicksilver: thanks alot
04:57:24 <frerich> dcoutts: Oh, it's Max Bolingbroke, even a Haskell newbie like me recognizes *that* name :-)
04:58:30 <dcoutts> :-)
04:59:37 <quicksilver> frerich: still, the battlefield of software development is strewn with the corpses of under-used make replacements
04:59:51 <quicksilver> I remember when Aegis was going to be The Answer; and SCons
04:59:58 <frerich> quicksilver: Absolutely.
05:00:38 <frerich> quicksilver: I used to be deeply involved with KDE (a graphical desktop environment for Unix-like systems) and for each of the switches between CVS->SVN->CMake there were just discussions with endless alternatives :-)
05:03:05 <frerich> but unfortunately, since I started tinkering with Haskell, I'm subconsciously (I guess I didn't spell that correctly) comparing everything with it. And usually the comparison is in favor of Haskell. :-/
05:05:09 <Peaker> Trying to run EclipseFP -- after a seemingly successful install, gives me a stuck gray square
05:05:17 <Peaker> with no diagnostics
05:05:20 <Peaker> computing really sucks these days
05:08:19 <quicksilver> the diagnostics are very *clearly* displayed, Peaker.
05:08:30 <quicksilver> in a text file in the basement, in a locked filing cabinet located in a disused lavatory with a sign on the door saying ‘Beware of the Leopard’.
05:09:28 <Peaker> :-)
05:09:31 <geheimdienst> peaker: with xmonad? there's something you need to do (iirc set an environment variable to a magic value) because java hates elite window managers :)
05:09:39 <geheimdienst> you should find it by teh google
05:09:44 <Peaker> geheimdienst: oy vey.. thanks
05:09:46 <dafis> shouldn't that have been upgraded to Tiger or Lion by now?
05:10:56 <geheimdienst> yeah, upgrading to lion, that'll sure fix some glitches *cough* *cough*
05:11:49 <dafis> geheimdienst: not familiar with Macs, what's the deal with Lion?
05:13:33 <geheimdienst> i'm unfamiliar too, i only keep hearing that you should skip the first one or two versions of any new apple thingy, if you value your nerves and/or data :)
05:14:15 <quicksilver> that's true of very much software and hardware
05:14:19 <luite> it was said to be buggy and slow, and many people didn't like the ipad inspired new app launcher
05:14:27 <quicksilver> you should skip the .0.1 point release of most GHCs for example :)
05:15:18 <luite> but I don't think it was that bad, or at least I didn't notice too much buggyness... one thing to be aware of is that the latest xcode (4.2) for lion cannot compile GHC
05:15:19 <geheimdienst> quicksilver: well, "people do that for me" ;) i think the arch linux packages wisely went from 6.12 to 7.0.2 or something
05:15:24 <luite> because it doesn't come with gcc anymore
05:15:42 <Janni> Hi.
05:17:00 <Janni> I have a question about the semantics of let. I'm not sure if there is a difference between Haskell's let and GHC core's let...
05:17:39 <Janni> In the FloatIn module of the GHC sources a comment says laziness would be lost in the following transformation:
05:18:01 <Janni> A)  let a = e in \b -> case a of
05:18:21 <Janni> B)  \b -> let a = e in case a of
05:18:32 <Janni> C)  \b -> case e of
05:19:03 <Janni> Can anyone tell me, which transformation step changes the semantics?
05:19:35 <Saizan> in haskell those have the same semantics, except that one would expect more sharing from A)
05:19:56 <quicksilver> that's what the comment is referring to
05:20:07 <quicksilver> "laziness would be lost" means loss of sharing
05:20:44 <dmwit> (laziness means both the late-evaluation thing *and* the sharing thing)
05:20:56 <Janni> Hmm. Where would $a$ have to be used in order to lose sharing?
05:21:08 <quicksilver> putting it inside the lambda like that
05:21:12 <quicksilver> as in (B)
05:21:28 <quicksilver> means that each time that lambda is actually applied to a parameter you get a 'fresh' a
05:21:40 <quicksilver> whereas with the a outside, it's shared between all uses of the lambda
05:22:00 <Janni> I see.
05:22:26 <Janni> I always think of let merely as a syntactic element to describe edges in the term graph...
05:22:31 <Janni> which is apparently wrong...
05:22:55 <dmwit> I think that's actually not such a bad way to understand it.
05:23:08 <Janni> I think that's the way Haskell's semantics should be defined.
05:23:14 <dmwit> What you've got to keep in mind, though, is that application of a function makes a copy of the function body's term subgraph.
05:23:27 <Janni> OK. Thanks.
05:23:28 <dmwit> If the let is in that body, you get a new copy of that edge.
05:23:39 <dmwit> If the let is outside the body... no new copy. =)
05:24:00 <dylukes> Is there a Multimap in base/collections?
05:24:02 <dylukes> @hoogle Multimap
05:24:02 <lambdabot> No results found
05:24:11 <dmwit> What does a multimap do?
05:24:16 <quicksilver> dylukes: Map k (Set v) ?
05:24:17 <dylukes> Multiple values per key.
05:24:21 <Janni> I see, that transformation wouldn't actually violate the semantics, because whether a computation is shared or not doesn't concern semantics, right?
05:24:22 <dylukes> quicksilver: derp.
05:24:26 <dylukes> quicksilver: well player.
05:24:27 <dylukes> played*
05:24:29 <quicksilver> or Map k [v] if you allow duplicates.
05:24:48 <dmwit> Janni: Depends what you mean by "violate the semantics", I suppose.
05:24:50 <dylukes> No duplicates... plus Set traversal is probably a bit nicer.
05:24:54 <quicksilver> Janni: not denotational semantics, certainly.
05:25:01 <dmwit> Janni: (Haskell is not actually specified to have lazy semantics -- only non-strict.)
05:25:17 <quicksilver> Janni: you can of course define "semantics" in a way which makes sharing explicit if you choose to.
05:25:26 <Janni> I understand. Thanks for the help.
05:25:28 <quicksilver> and then it would :)
05:25:46 <dmwit> quicksilver: You say "of course" -- but my understanding was that it's kind of hard and took people a while to do that right. =P
05:26:10 <quicksilver> dmwit: surely they never doubted it was possible, though :)
05:26:17 <dmwit> heh
05:26:29 <quicksilver> you can of course climb up everest with a chicken on your head doesn't mean that I personally could perform this feat
05:26:34 <quicksilver> or that anyone has ;)
05:30:10 <osfameron> @faq can haskell climb up everest with a chicken on its head?
05:30:10 <lambdabot> The answer is: Yes! Haskell can do that.
05:31:20 <int-e> @faq Can Haskell cause insomnia?
05:31:21 <lambdabot> The answer is: Yes! Haskell can do that.
05:31:32 <cirno_the_greate> @faq Can Haskell cure cancer?
05:31:32 <lambdabot> The answer is: Yes! Haskell can do that.
05:33:13 <Baughn> @faq Can Haskell beat Haskell to the punch?
05:33:13 <lambdabot> The answer is: Yes! Haskell can do that.
05:33:18 * Baughn loves laziness.
05:33:31 <hpc> @faq can haskell really be far even as decided to use even go want to do look more like?
05:33:32 <lambdabot> The answer is: Yes! Haskell can do that.
05:33:39 <dylukes> So, if I have two parsers, lets call them p1 and p2,
05:33:44 <dylukes> I have the following logic
05:33:56 <dylukes> if p1 fails, it could be for three reasons
05:34:00 <Peaker> Why is the "Build" option for my Haskell project in EclipseFP eternally gray?
05:34:03 <dylukes> one of those is a failure, one of them implies p2
05:34:31 <dylukes> I essentially want to get a "failure reason" from one of the parsers.
05:39:42 <Peaker> Except for XFCE/xmonad in which 80%+ of the things I tried worked, my recent experiences with software have been less than half success rate to use the software for its intended purpose.. Software doesn't only suck, it's getting worse
05:41:27 <dafis> Peaker: maybe it's not the software software getting worse but your choices ;)
05:42:56 <Peaker> dafis: now I'm trying to use the SpawnOn extension of xmonad, and it too, does not seem to work as intended :-(
05:43:09 <dafis> awww
05:43:11 <Peaker> Using cabal-install generally fails way too much, too.
05:43:26 <dafis> sorry, didn't mean to cause that
05:43:29 <Peaker> Getting corrupt package databases from using "cabal-install" is pretty bad, too
05:44:36 <dafis> Peaker: That's something I only ever had once (way back when mtl/transformers was a new war)
05:45:19 <Peaker> I get it all the time now, I got it after I tried to install yesod.. also get linkage errors on various Hackage packages with the new Ubuntu
05:45:26 <dafis> guess it's because I don't install web or graphics stuff
05:45:31 <dylukes> Okay...
05:45:37 <dylukes> So I have two parsers, p1 and p2
05:45:42 <dylukes> if p1 fails, it can do so for two reasons
05:45:51 <dylukes> well three
05:45:54 <dylukes> but in two of those 
05:45:59 <dylukes> p2 should then be tried
05:45:59 <dafis> dylukes: wre three a few minutes ago
05:46:08 <dylukes> no answer.
05:46:10 <dylukes> but what do AFTER p2
05:46:13 <dylukes> depends on why p1 failed.
05:46:16 * dafis was tooo slooow again
05:47:16 <dafis> dylukes: have you p1 and p2 under your control?
05:47:25 <dylukes> yep
05:47:35 <dylukes> what they are is routines for infix and postfix operators
05:47:38 <dylukes> so its something like
05:47:41 <dylukes> infix can fail because
05:47:49 <dylukes> 1) not an infix operator
05:47:50 <dafis> then p1' :: Parser (Either Reason P1Result)?
05:47:57 <dylukes> 2) no right hand side
05:48:13 <dylukes> if its because of 1), then just try parsing it as postfix.
05:48:24 <dylukes> If its because of 2), also try parson it as postfix.
05:48:34 <dylukes> But AFTER trying that, if postfix fails,
05:48:49 <dylukes> what to do differs.
05:49:00 <dylukes> Because the infix parser could also just be at the END of the expression.
05:49:03 <dylukes> :\
05:49:31 <dylukes> i.e, a * b_ (at the underscore)
05:49:38 <dafis> dylukes: could p2 succeed in a situation where p1 would succeed?
05:50:09 <dylukes> Yes, but consider
05:50:14 <dylukes> If ++ is infix and postfix
05:50:19 <dylukes> first I try ++ which has a rhs
05:50:24 <dylukes> then I try ++ which doesn't have a rhs.
05:50:55 <dafis> yeah, that was the point, whether trying p2 first is an option at all
05:51:01 <dylukes> No.
05:51:03 <dylukes> p1 is more restrictive.
05:52:08 <dafis> dylukes: p1 tries to parse expr infixop expr, p2: expr postixop?
05:52:28 <dylukes> expr p = do lhs <- expr0; expr' p lhs
05:52:37 <dylukes> expr' lhs = ... what I'm writing ...
05:52:53 <dylukes> the lhs is parsed, then each [op, rhs] pair is parsed, and applied with the lhs to form the new lhs.
05:52:57 <dylukes> It's kind of a fold really.
05:53:05 <dylukes> abstractly speaking...
05:53:19 <dylukes> I'm using lookahead mind you.
05:53:37 <dylukes> Since I only consume operators with lower precedence than the current precedence p
05:53:56 <dafis> lower?
05:54:10 <dylukes> greater*
05:54:21 <dylukes> anyways, here's the broken old one
05:54:21 <dafis> makes more sense
05:54:22 <dylukes> https://gist.github.com/1303797
05:54:35 <dylukes> expr0 is either the terminal expression, or a prefixed expr
05:54:41 <dylukes> (this handles nested prefix nicely)
05:58:37 <dylukes> so, it really comes down to infix ops, or non-infix ops
05:58:44 <dylukes> prefix/non-prefix*
06:00:59 <dafis> dylukes: perhaps (op,rhs) <- lookAhead $ do ... ?
06:01:24 <dylukes> what is ...?
06:02:01 <dylukes> that sounds roughly good though.
06:02:10 <dafis> mostly what you do after the lookAhead anyway
06:03:24 <dylukes> hm...
06:03:44 <dylukes> I can't do more lookaheads though.
06:03:47 <dafis> so, (InfixOp a q f) <- infixOp table; guard (case...} >= p); ...
06:03:57 <dylukes> ah mm.
06:04:12 <lpsmith> Out of curiousity, is there a way to set the number of capabilities inside Haskell code,  maybe somewhere in the GHC API?
06:04:21 <dylukes> capabilities?
06:04:24 <lpsmith> programattically, that is
06:04:28 <dylukes> Do you mean extensions?
06:04:40 <quicksilver> no, he means capabilities
06:04:45 <dylukes> What are capabilities? :<
06:04:47 <dafis> CPUs and such, I think
06:04:47 <quicksilver> = OS threads, roughly
06:04:58 <lpsmith> no, capabilites,  threads that can execute haskell code
06:05:09 <quicksilver> or, rather, the maximum number of OS threads the RTS will schedule at once
06:05:12 <dylukes> You can use {-# OPTIONS_GHC ... #-} to specify any flags to GHC.
06:05:17 <lpsmith> I'm writing a blog post about our conversation, quicksilver, for the benefit of the rest of the community.  It's just about done.
06:05:34 <quicksilver> it certainly isn't possible to change at runtime in old/current GHC versions
06:05:45 <quicksilver> I think runtime changing of key RTS features is being considered
06:05:50 <quicksilver> lpsmith: which conversation?
06:06:03 <lpsmith> from a little over a week ago
06:06:09 <quicksilver> excellent.
06:06:12 <lpsmith> about safe and unsafe calls
06:06:17 <quicksilver> is it in the style of socrates?
06:06:23 <lpsmith> uhh, no :)
06:06:41 <dylukes> dafis: No, I can't just do that, because then the guard would just unconditionally fail the whole thing.
06:07:09 <dylukes> dafis: It's possible the infix version of an operator's precedence isn't enough, but the postfix is. :\
06:07:57 <dafis> dylukes: I meant for that guard to be within the infix branch
06:07:58 <dylukes> that guard is equivalent to "no infix operator parsed"
06:08:30 <lpsmith> quicksilver: "the maximum number of OS threads the RTS will schedule at once" sounds weird to me,  as GHC has no control over the scheduling of OS threads.   I know what you meant though.
06:08:32 <dylukes> but if I'm using choice, how can I get the failure reason to the postfix case :P
06:08:52 <quicksilver> lpsmith: well, the RTS does its own scheduling of its pool of RTS threads
06:08:59 <lpsmith> right :)
06:09:03 <quicksilver> it guarantees no more than X are alive at once
06:09:07 <quicksilver> it sleeps the others
06:09:19 <mauke> I slept your mom
06:09:22 <quicksilver> for a slightly strange definition of 'alive' mind you.
06:09:38 <quicksilver> busy doing FFI calls counts as asleep.
06:10:06 <lpsmith> well, that doesn't quite sound right either.  More like the maximum number of OS threads that GHC will use to execute Haskell code.
06:10:07 <dafis> dylukes: ah, but that may recur too deeply :(
06:10:13 <dylukes> dafis: Worst case I give up and runStateT...
06:10:15 <dylukes> :\
06:10:59 <dafis> dylukes: or make the parser one returning Either ReasonOfFailure Result
06:11:39 <dylukes> and then not use <|>
06:11:39 <dylukes> mm
06:13:39 <tsanhwa> hi, with attoparsec, what parse may consume all characters except char ',' if not preceeded by char '\'
06:13:43 <bluescreen303> Hi all, I'm planning on implementing a network protocol for a game (nothing serious, school project). I would like to minimize the amount of IO code (protocol logic/state). I'm thinking of something like a state machine or automaton, maybe FRP, but it's all still very vague in my head. I looked at hackage to see if there are any protocol-builder edsls, but without luck. Does anyone know of such a thing? Or good reading material a
06:13:45 <bluescreen303> bout it?
06:14:26 <quicksilver> bluescreen303: A simple protocol could just write "length word; data object serialised by Data.Binary"
06:14:30 <lpsmith> but yeah, being able to set the number of capabilities at run time would be nice for creating executables that "just work" on different CPU configurations.
06:14:59 <quicksilver> bluescreen303: that would be fine for many simple cases and would let you concentrate on your data structures and functions.
06:16:39 <bluescreen303> quicksilver: it's not about the serialization. more about state and logic. say like a "greeting" message, and certain possible requests. the protocol can also be in a different "state" where different commands become available. So basically I would like a way to describe the possible conversations.
06:17:13 <quicksilver> bluescreen303: Oh, I understand your question.
06:17:33 <quicksilver> No, I don't think I have heard of one. I agree this sounds like a nice case for an EDSL.
06:17:55 <shirt> game network protocols can get pretty complex. it would be cool to have haskell bindings for ENet
06:18:07 <dylukes> dafis: Maybe I should use MaybeT and arrows :P.
06:18:10 <dylukes> That might get a bit...
06:18:16 <dylukes> Probably a bit arcane.
06:18:35 <bluescreen303> thought so too :)  but am I correct to assume this kind of thing is usually captured using an automaton? Or did I get that term completely wrong?
06:19:16 <quicksilver> bluescreen303: that's the right term, yes.
06:19:34 <bluescreen303> ok, then at least I have a starting point.
06:19:38 <quicksilver> bluescreen303: some of the internet RFCs explicitly describe protocols as automata
06:19:58 <bluescreen303> ah, that's nice to know... I'll start there :)
06:21:00 <bluescreen303> and do you think it's worth looking at some frp library for this too? I feel this kind of thing can be described in such a thing, but I'm a bit affraid that all libs still focus on building GUIs only
06:23:03 <bluescreen303> I mean state machines/automata can be turned into behaviours/signals, I've seen that used for UI examples. But I haven't seen any uses beyond/besides that.
06:36:13 * hackagebot hub 0.0 - A utility for multiplexing multiple GHC installations  http://hackage.haskell.org/package/hub-0.0 (ChrisDornan)
06:39:11 <deech> Are the Haskell Shootout submissions a good guide to optimizing Haskell code for performance?
06:40:04 <dylukes> The only good guide to optimizing any code is an in-context suite of benchmarks.
06:40:16 <dylukes> with realistic datasets that mirror actual use cases.
06:40:25 <benmachine> iirc the shootout programs tend to be highly non-idiomatic
06:40:32 <dylukes> benmachine: ^
06:40:45 <benmachine> so they're as fast as possible but to the point of barely being haskell
06:42:34 <deech> Are there better real world examples then? Maybe something from Hackage.
06:42:56 <dylukes> http://book.realworldhaskell.org/read/profiling-and-optimization.html
06:42:59 <dylukes> Might be helpful.
06:43:07 <dylukes> I like that it focuses on measuring first..
06:43:14 <dylukes> Optimization without metrics is silliness.
06:43:24 <deech> dylukes: Read it. Looking for something in the wild.
06:44:24 * Baughn prefers to think of lazy evaluation as programming with time travel. It's fine just so long as you don't cause any causal loops.
06:45:34 <szablica> \help
06:59:17 <kk`> :t liftIO
06:59:18 <lambdabot>     Ambiguous occurrence `liftIO'
06:59:18 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
06:59:18 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
06:59:39 <EvanR-work> :t Control.Monad.Trans leftIO
06:59:40 <lambdabot>     Not in scope: data constructor `Control.Monad.Trans'
06:59:40 <lambdabot> Not in scope: `leftIO'
07:00:35 <EvanR-work> kk`: MonadIO m => IO a -> m a
07:01:48 <mauke> :t Control.Monad.Error.liftIO
07:01:49 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
07:02:08 <EvanR-work> :t Control.Monad.Trans.liftIO
07:02:09 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
07:02:20 <EvanR-work> error?
07:02:56 <quicksilver> evidence of the limitaitons of the haskell re-export system, EvanR-work
07:03:04 <quicksilver> there isn't a sensible notion of canonical name
07:03:17 <quicksilver> so it's arbitrarily selecting one of the places it is re-exported
07:03:22 <quicksilver> I think.
07:07:12 <benmachine> quicksilver: no I think it might actually be different functions
07:07:49 <benmachine> or not
07:07:50 * benmachine shrug
07:08:52 <quicksilver> benmachine: no, because the point is that Control.Monad.Trans.liftIO and Control.Monad.Error.liftIO *both* have the same type - and that type refers to Control.Monad.Error.MonadIO.
07:09:16 <benmachine> quicksilver: oh right
07:09:23 <benmachine> good point, I missed that bit
07:09:51 <benmachine> I think there is usually a canonical name kind of though
07:10:12 <benmachine> inasmuch as :i tells you where something is defined
07:10:26 <benmachine> @type Control.Monad.IO.Class.liftIO
07:10:27 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
07:10:38 <quicksilver> the canonical name should be Control.Monad.Trans.MonadIO
07:10:42 <quicksilver> that's where it's defined.
07:10:47 <quicksilver> but that's not what you get
07:11:04 <quicksilver> (Control.Monad.Error re-exports it I presume)
07:23:30 <Guest33870> @pl f x y = y x
07:23:31 <lambdabot> f = flip id
07:23:44 <saml> what is essence of sum type?
07:23:49 <saml> why do we need sum type?
07:23:57 <saml> history of sum type? where did it come from?
07:26:34 <kalven> where is it going in the future?
07:28:28 <saml> i mean.. what is its advantage over duck typing?
07:34:34 <PatrickRobotham> saml: You can have type classes, and catch type errors at compile time.
07:34:49 <saml> isn't typeclasses duck typing?
07:35:00 <saml> type classes don't have much to do with tagged union
07:35:53 <PatrickRobotham> saml: Type classes give a guarantee that certain operations will work on values of this type.
07:36:05 <saml> so that's duck typing
07:36:07 <EvanR-work> no, its not duck typing, insofaras duck typing has a consistent meaning
07:36:29 <EvanR-work> duck typing is a run time type check to make sure you can do an operation on an object, if you cant, error
07:36:39 <EvanR-work> haskell does compile time type checks
07:36:53 <saml> no.. duck typing means HasA typeclass
07:37:09 <EvanR-work> not in python where they invented the stupid concept of duck typing
07:37:21 <EvanR-work> it means has a method
07:37:29 <EvanR-work> else runtime error
07:37:31 <saml> if this data is instance of HasGetHttpRequest type class,  then you can apply functions in HasGetHttpRequest to the data
07:37:57 <EvanR-work> duck typing implies a runtime check
07:38:33 <EvanR-work> its described as a innovative feature but its just the typical lack of robust type checking in the language design
07:39:09 <EvanR-work> of course things may be different now in python 3
07:39:22 <EvanR-work> i doubt it though
07:42:08 <Peaker> EvanR-work: Duck typing is not only runtime type checking -- it is also checking for support of a particular feature, rather than a specific tye
07:42:43 <EvanR-work> right, it checks for method with the name 'quack', which may or may not mean anything of importance
07:43:31 <EvanR-work> i just said it implies a runtime type check rather than a more sophisticated system
07:43:31 <Peaker> saml: Sum types are when you have multiple possibilities
07:43:43 <Peaker> saml: The value is one or the other
07:44:01 <saml> Peaker, why not put all values together ?  (possiblevalue1, possiblevalue2, ...)
07:44:03 <saml> as a product
07:44:16 <EvanR-work> (True,False) ?
07:44:26 <EvanR-work> > (True,False)
07:44:27 <lambdabot>   (True,False)
07:44:27 <saml> and select one as you need.. and compiler will optimize unused value
07:44:30 <saml> hahaha
07:44:33 <saml> got cha
07:44:44 <saml> it'll be more like (True,False)[0]  for True
07:44:46 <Peaker> saml: You don't necessarily have possiblevalue1, you only have the other
07:44:57 <EvanR-work> saml: how about True by itself
07:44:58 <saml> (True, False)[1]
07:45:04 <saml> yup...
07:45:24 <saml> but i'm just wondering if we absolutely need sum type when we have product type
07:45:26 <EvanR-work> you cant index tuples
07:45:33 <Peaker> saml: consider:  hypotheticalOpenFile :: FileName -> IO (Either Error Handle)   -- are you suggesting replacing the Either with both Error *and* Handle?
07:45:43 <saml> yup
07:45:59 <EvanR-work> youre talking about how to implement the two features, not eliminating one feature
07:46:00 <Peaker> saml: then what Error do you put in there when you have a handle, and what handle do you put in there when you had an error?
07:46:08 <saml> in this language.. every data will be product type. and sum type is represented by product[index]
07:46:32 <saml> (Error "blah", Handle handle)[1]
07:46:38 <EvanR-work> you need to separate the languages features from the implementation details
07:46:44 <saml> yup exactly!
07:46:52 <Peaker> saml: That sucks :-)  In terms of safety mainly, and also in terms of memory efficiency
07:46:57 <saml> but.. theoretically.. i was wondering where sum type came from
07:47:06 <Peaker> saml: What's the type of (Error "blah", Handle handle)[index] ?
07:47:12 <saml> it looks like.. product type and accessing one field at a time can suffice
07:47:19 <EvanR-work> saml: they form the basis of all data types
07:47:20 <Peaker> saml: consider the type of that "access"
07:47:22 <Peaker> gotta go
07:47:26 <EvanR-work> 0 | 1 | 2 | 3 ...
07:48:23 <EvanR-work> data [a] = [] | a : [a]
07:50:24 <EvanR-work> saml: in ordinary usage sum types are very expressive ways to handle data and denote programs
07:50:37 <copumpkin> saml: it "comes from" a primitive, or a 2-member product type if you look at it differently
07:50:44 <EvanR-work> most mainstream systems dont have good ways to do them
07:52:30 <copumpkin> saml: you can think of a sum a product whose first member is a "tag" and whose second member contains the members of that tag (ideally, whose type depends on the tag's value)
07:52:33 <saml> what's wrong with  class BaseClass {}      class DataConstructor1 extends BaseClass {}  class DataConstructor2 extends BaseClass {}
07:52:34 <saml> in java
07:52:42 <copumpkin> ask ##java
07:52:45 <copumpkin> :P
07:52:47 <saml> data BaseClass = DataConstructor1 | DataConstructor2
07:52:47 <EvanR-work> ouch
07:52:56 <saml> it sounds like single level inheritance
07:53:02 <copumpkin> saml: you can't ever assume BaseClass won't have other implementations
07:53:08 <copumpkin> but that is how scala does ADTs
07:53:13 <saml> oh so complicated
07:53:18 <saml> why programming so complicated?
07:53:21 <EvanR-work> haskell is simple
07:53:28 <EvanR-work> youre previous experience is complicated
07:53:31 <EvanR-work> your
07:53:36 <EvanR-work> forget all that
07:53:42 <saml> no.. i agree haskell is simple
07:53:54 <saml> but there's gatta be something simpler
07:54:03 <hpc> yeah, haskell is just the category of morphisms on computable objects :P
07:54:04 <saml> that can express all of java, haskell
07:54:17 <EvanR-work> people naturally, it seems, like complex stuff because if its too simple they cant get their head around it, unfortunately theres long term serious costs with complexity
07:54:32 <EvanR-work> saml: java is horrible, why do you want to express it
07:54:33 <saml> haskell currently is complex with all ghc extensions
07:54:46 <EvanR-work> you dont need to use the ghc extensions
07:54:47 <saml> some underlying concepts are simple though
07:54:49 <copumpkin> agda is way simpler
07:55:02 <erus`> lambdurp...
07:55:10 <hpc> EvanR-work: that's usually because of complexity introduced by overly simplistic generalities
07:55:18 <EvanR-work> hpc: o_O
07:55:34 <hpc> the basics of haskell are more complex than the basics of java
07:55:44 <hpc> but the complex stuff is more consistent
07:56:06 <hpc> hence it being harder to learn
07:56:19 <EvanR-work> if the basics are 'side effects' then yeah you can finishthe intro faster, but now youre screwed big time with completing anythnig ;)
07:56:37 <tdammers> actually, the basics of haskell are way simpler
07:56:53 <Saulzar> Anyone having a go at the google ai-contest thing? I'm just re-writing the base code ... it seems a little icky
07:57:29 <tdammers> the haskell one looks unfinished
07:57:38 <EvanR-work> tdammers: id love to see a dual-introtutorial for java and haskell, not to help people learn java, but to help java refugees see the differences
07:57:40 <erus`> how does one enter?
07:58:19 <Saulzar> hm, it compiles and works but it's written by a haskell beginner...  not that I can do much better but we
07:58:21 <EvanR-work> going to be a big difference is code size ;)
07:58:22 <Saulzar> we'll see :)
07:58:48 <tdammers> erus`: you sign up?
07:59:18 <erus`> not yet
07:59:19 <Saulzar> yeah just go to ai-contest.com and register
07:59:35 <erus`> no but how do you send in your binary?
07:59:45 <Saulzar> You upload your source
07:59:50 <erus`> pfff
08:00:02 <hpc> EvanR-work: it would be interesting to see the comparison of generics and type classes
08:00:04 <Saulzar> Unfortunately that means you're stuck with whatever they have in their ghc 6.12 install
08:00:05 <erus`> i wanna write my in some obscure language they cant compile
08:00:22 <EvanR-work> hpc: yeah, are those used in java at all?
08:00:32 <tdammers> erus`: then you're encouraged to ask about it and they'll see what they can do for you
08:00:33 <mike-burns> Generics are.
08:00:43 <EvanR-work> generics are like haskell polymorphism right
08:00:51 <EvanR-work> not type classes
08:00:56 <tdammers> but I doubt they'll go any further than install the basic requirements on their reference system
08:01:05 <erus`> generics are like forall a
08:01:18 <EvanR-work> yeah so the comparison wuold be between type classes and interfaces
08:01:21 <tdammers> you'll have to write your bot from scratch, without a starter pack
08:01:25 <EvanR-work> and generics and forall a
08:01:28 <hpc> idiomatic generics is very different from idiomatic type classes
08:01:37 <quicksilver> java generics are more like haskell Dynamic
08:01:51 <EvanR-work> oh, typeof
08:01:56 <EvanR-work> ugly
08:02:08 <hpc> there are a lot of hoops to go through to get something analogous to Monoid, for instance
08:02:41 <EvanR-work> can you make a java interface for Monoid?
08:03:03 <EvanR-work> IMonoid ;)
08:06:13 * hackagebot HarmTrace 1.0 - Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-1.0 (JosePedroMagalhaes)
08:06:32 <EvanR-work> answer seems to be no because of the binary method problem
08:06:51 <EvanR-work> and theres no way to refer to 'this type'
08:08:24 <erus`> how are sound waves combined? is it just the average of both?
08:08:25 <EvanR-work> nvm you can
08:08:36 <EvanR-work> erus`: no, that would be bad
08:08:50 <b_jonas> it's complicated
08:09:02 <EvanR-work> in principle just add them
08:09:07 <tdammers> actually, combining sound waves isn't hard
08:09:16 <erus`> EvanR-work: yeah if i played two sin waves at half a hz apart it would be silence
08:09:39 <EvanR-work> which can happen in real life
08:09:57 <EvanR-work> if youre talking about computers, it gets a little more complex because you usually have an overflow for loud noises
08:10:08 <tdammers> erus`: No, that's not what's going to happen
08:10:14 <EvanR-work> best way is to avoid that with small amplitude signals
08:10:37 <tdammers> you'd get a signal where the amplitude peaks every 2 seconds
08:10:56 <tdammers> and in between peaks, the signals cancel each other out for an infinitely small amount of time
08:10:57 <EvanR-work> he means half a wavelength
08:11:09 <tdammers> that's not the same though ;)
08:11:12 <EvanR-work> total destructive interference
08:11:13 <erus`> whats the difference?
08:11:41 <EvanR-work> erus`: you werent very exact with your description of what youre adding
08:11:42 <tdammers> Hz is a unit of frequency, defined as full phases per second
08:12:19 <EvanR-work> two equal f waves shifted over will result in a louder or quieter version of the same f
08:12:26 <tdammers> altering the frequency and applying a phase shift are two different things, although they are related in many situations
08:12:54 <EvanR-work> different f and you get beating
08:13:15 <erus`> lower the tempo for a bit until you get a beatmatch
08:13:19 <erus`> then crossfade
08:13:30 <erus`> put your hands in the air like a retard
08:13:58 <EvanR-work> if the question is how do i combine two arbitrary noises like IRL, just add them
08:14:10 <EvanR-work> if the question is how to combine simple waveforms to get cool sounds, then theres more answers
08:14:25 <erus`> so two sine waves at half a wavelength apart is silence?
08:14:37 <EvanR-work> if you add them, of course
08:14:50 <erus`> if i play them at the same time
08:14:55 <erus`> is that addition
08:14:59 <EvanR-work> yes
08:15:04 <tdammers> but there's other ways of combining two signals, which yield other interesting effects
08:15:18 <tdammers> phase modulation, amplitude modulation, vocoding, ...
08:15:36 <EvanR-work> once you get into that the possibilities are endless ;)
08:15:50 <erus`> did you see that post on reddit the other day
08:15:56 <erus`> 1 line sound generation
08:16:06 <erus`> wiriting the the unix sound device with c
08:16:23 <EvanR-work> yes
08:16:29 <EvanR-work> dont try that at home
08:17:25 <erus`> im on windows anyway :(
08:17:34 <erus`> i only run *nix in a vm
08:17:40 <erus`> because drivers et all
08:17:47 <EvanR-work> then sound should work
08:25:10 <erus`> does anyone know of an intermediate language that compiles to java/.net/javascript ?
08:25:26 <EvanR-work> haskell
08:25:36 <tensorpudding> coffeescript
08:25:43 <erus`> where is the .net compiler for haskell?
08:25:51 <tensorpudding> compiles to javascript
08:25:54 <EvanR-work> why would you want just a thing
08:25:57 <EvanR-work> such
08:26:02 <tensorpudding> doesn't afraid of anybrowser
08:26:03 <erus`> target for a compiler
08:26:15 <tensorpudding> ironhaskell doesn't exist yet
08:26:38 <EvanR-work> youll have to use poormans haskell, F#
08:26:47 <ben> Does anyone target nacl with haskell yet
08:26:50 <tensorpudding> there is a jaskell though
08:27:23 <tensorpudding> but jaskell isn't a haskell on the jvm, but a different language
08:27:26 <erus`> im sure i have heard of something like this before
08:27:50 <quicksilver> there are several projects for haskell to each of the above
08:27:55 <quicksilver> they're pretty much all bitrotted
08:28:02 <quicksilver> ghcjs might possibly be the least bitrotted
08:28:22 <quicksilver> they never seem to get the traction/support to keep them alive
08:29:55 <engla> I've "found" a new toy functional language. C++ with constexpr restriction. It only allows expressions, no statements, and && and || and ?: provide laziness. Recursion allowed..
08:30:26 <hpc> engla: bonus points if you can work CPP in somehow
08:31:16 <erus`> engla: where is the Fibonacci example?
08:32:34 <engla> erus`: there won't be as no datastructures can be created, only consumed
08:32:47 <engla> erus`: so you can foldr over initializer lists  if you produce numbers or so
08:33:04 <aristid> engla: you could use struct and typedef to make lists
08:33:12 <aristid> or is typedef forbidden?
08:33:23 <yrlnry> But no malloc, so where would you get the list nodes from?
08:33:31 <aristid> compiler
08:33:44 <aristid> i guess you also need templates
08:33:45 <yrlnry> Or you can call malloc, I guess, but you can assign the result pointer anywhere.
08:33:51 <erus`> vector<int> { 1, 2, 3 } is an expression in C++0x
08:33:53 <engla> well you can produce std::initializer_lists
08:34:17 <EvanR-work> c++ o_O
08:34:46 <erus`> and C++0x has lambda's so i think this is too easy :)
08:34:46 <aristid> erus`: i kind of thought about boost::mpl::vector_c, rather than std::vector
08:35:01 <shirt> engla: sounds like featherweight java
08:36:00 <tac-tics> So does C++0x have GC then?
08:36:11 <shirt> @google featherweight c++
08:36:13 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/gj.html
08:36:13 <lambdabot> Title: Wadler: GJ, Pizza, and Java
08:36:28 <erus`> tac-tics: nope
08:36:48 <shirt> don't need GC if you never use "new" :)
08:36:53 <thoughtpolice> http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2670.htm
08:37:02 <thoughtpolice> there's this, which i'm not sure is still on track or whatever
08:37:08 <erus`> shirt cant use polymorphism if you dont use new :(
08:37:33 <shirt> erus`: sure you can
08:37:53 <erus`> ok you cant hold a list of polymorphic types
08:38:24 <shirt> erus`: right, you are very restricted
08:38:25 <dylukes> dafis: I think I figured out a more general approach.
08:38:29 <dylukes> Which should be easier :)
08:38:44 <erus`> shirt if i could do that i wouldnt hate C++ :)
08:38:47 <dylukes> dafis: I've been reading the implementation journal type stuff for JSLint, which uses the same style of parser.
08:39:09 <aristid> erus`: of course you can use polymorphism without new.
08:39:26 <dylukes> What it does it specify an operator as having a nullDenotation, or a leftDenotation.
08:39:26 <erus`> i meant in a vector
08:40:11 <aristid> erus`: well, strictly speaking, pointers in a vector do not have to point to the heap either
08:41:14 * hackagebot vhd 0.1 - Implementation of the Virtual Hard Disk (VHD) disk format  http://hackage.haskell.org/package/vhd-0.1 (VincentHanquez)
08:41:21 <shirt> aristid: you're gonna have to be very careful with such a vector, making sure it outlives all of its containing elements
08:42:32 <aristid> shirt: sure. but then, you always have to be very careful in c++ :)
08:45:10 <dafis> dylukes: what are the meanings of those denotations?
08:45:19 <dylukes> dafis: null denotation applies where there is no lhs
08:45:25 <dylukes> left denotation applies where there is a lhs.
08:45:56 <dylukes> they're essentially continuation monadic actions. (or rather, functions producing said actions)
08:46:21 <dafis> you'd need a rightDenotation, however, iirc (not that that should change much)
08:46:55 <dylukes> you mean for when there's explicitly right, but no left?
08:48:01 <dylukes> but yeah, essentially, the big change here is,
08:48:19 <dylukes> the default left/null/right denominations are something similar to the routines I defined before...
08:48:23 <dafis> dylukes: I thought you already have the lhs, and need op + possibly rhs
08:48:36 <dylukes> but they can be overwritten, meaning you can define mixfix like this :)
08:49:01 <dafis> but, I'm off eating for now, so...
08:49:30 <dylukes> you can do mix fix by ... say...
08:50:14 <dylukes> "?" is a left denotated operator, and its left denotation parses an expression with p = 0 expects ":", then parses the end with p = 0
09:00:07 <zul_netbsd> Hello all
09:00:44 <zul_netbsd> I have a probably stupid question, but I'm quite newbie on haskell, and I can't find the right thing to do
09:00:51 <zul_netbsd> I have two methods hello ::  TclservHandle -> IO (Maybe String)
09:00:56 <zul_netbsd> and replyTo ::  TclservHandle -> [Char] -> IO Bool
09:01:25 <zul_netbsd> and I try to combine them with something like testReply handle = hello handle >>= (fmap replyTo) handle
09:02:19 <zul_netbsd> but the type checker definitively does not seem happy
09:02:45 <zul_netbsd> maybe someone can give me a hint to the right direction
09:04:01 <geheimdienst> zul_netbsd: maybe try writing the whole thing in do notation: testReply handle = do ms <- hello handle ; ...
09:04:42 <geheimdienst> i think do notation is much more accessible than juggling around fmap :)
09:04:53 <alpounet> indeed
09:07:40 <zul_netbsd> I still need one fmap to "wrap" against the Maybe, and it seems I get the correct syntax with the do notation
09:09:32 <zul_netbsd> hum, the return type is IO (Maybe (IO Bool))
09:10:25 <alpounet> paste your code
09:12:23 <kmc> triple monad all the way
09:12:36 <hpc> across the effective topos
09:12:41 <hpc> what's its semantics?
09:12:51 <zul_netbsd> http://hpaste.org/52913
09:14:01 <zul_netbsd> my issue is with "testReply" and testReply2
09:16:43 <zul_netbsd> I expected IO Bool
09:17:10 <zul_netbsd> but definitively ghc is right :)
09:18:16 <geheimdienst> i'd try writing it in the most direct way possible, i.e. "case ms of ..."
09:20:28 <Taejo> zul_netbsd: think about, what is the type of (hello handle), (fmap (replyTo handle)) and (>>=)
09:21:33 <Taejo> or in testReply, what is the type of ms and (fmap (replyTo handle))
09:22:12 <aristid> or don
09:22:22 <aristid> or don't think: ask ghci
09:22:33 <Taejo> zul_netbsd: if I'm correct, GHC is telling you testReply :: TclservHandle -> IO (IO String)
09:23:50 <zul_netbsd> testReply :: TclservHandle -> IO (Maybe (IO Bool))
09:24:38 <Taejo> ah, I missed the type of Hello
09:24:43 <Taejo> *hello
09:25:20 <Taejo> still, if you look at the types of the components, you will see why the whole thing has the type it does
09:26:51 <copumpkin> TacticalGrace: do you know if roman still has/checks his unsw email address?
09:27:53 <zul_netbsd> I don't doubt that ghc is right :D, but I'm not sure to understand the interaction between >>= and fmap in testReplay2
09:28:16 <zul_netbsd> fmap (replyTo handle)) is of type (Functor f) => f [Char] -> f (IO Bool)
09:28:18 <nand`> Typing :t (\a b -> compare (snd a) (snd b)) gives me “Ord a => (a1, a) -> (a2, a) -> Ordering” as expected. However, typing let foo = (\a b -> compare (snd a) (snd b)) and then :t foo gives me “(a, ()) -> (a1, ()) -> Ordering”. Why?
09:28:39 <nand`> This causes problems later on unless I manually specify the first quoted type
09:28:50 <zul_netbsd> hello h is of type IO (Maybe String)
09:28:57 <Taejo> nand`: the monomorphism restriction and GHCi's extended defaulting rules
09:29:12 <zul_netbsd> and >>= is of type (Monad m) => m a -> (a -> m b) -> m b
09:29:54 <zul_netbsd> (>>= fmap (replyTo h)) :: (Functor m, Monad m) => m (m [Char]) -> m (IO Bool)
09:30:11 <nand`> Taejo: meaning what exactly?
09:30:32 <zul_netbsd> I expected that the Monad was IO and Functor Maybe
09:31:31 <ion> All monads are functors and many functors are monads.
09:31:40 <Taejo> nand`: the monomorphism restriction says (roughly) that if you don't declare type, and you have a binding without arguments (f = ..., not f x = ....) then it must not have any typeclass restrictions (like Ord a =>)
09:32:31 <Taejo> if you try to do this, GHC will make the type variable Integer or Double in some cases, and GHCi extends this to sometimes defaulting to ()
09:32:40 <nand`> Taejo: oh, okay. But why is this? What sense does it make / where is it needed?
09:32:56 <mauke> nand`: basically, it makes no sense and you can simply disable it
09:33:04 <Taejo> nand`: IIRC, most here will argue that it should have been a warning, not an error
09:33:42 <Taejo> nand`: disable it with -XNoMonomorphismRestriction
09:33:52 <nand`> Taejo: alright, thanks for clearing it up
09:34:03 <Taejo> zul_netbsd: are you aware that Maybe is a monad as well as a functor?
09:34:23 <Taejo> and so is IO
09:34:26 <zul_netbsd> yes :)
09:34:37 <aristid> all well-behaved monads are functors
09:35:06 <Taejo> all monads are functors but some badly behaved Monads are not Functors
09:35:49 <Taejo> zul_netbsd: I'd do what geheimdienst suggested: write it without using the functor instance for Maybe, but instead case analysis
09:36:03 <Taejo> then when it's clear, you can possibly go back
09:36:24 <zul_netbsd> ok, I will do that
09:37:47 <sm> good morning
09:37:52 <zul_netbsd> thanks for your help, but I need your leave
09:38:14 <zul_netbsd> I need to leave ...
09:38:18 <angstrom> is there a way to pattern-match constructors?
09:38:21 <zul_netbsd> see you, and thanks again
09:38:34 <kmc> angstrom, constructors are the thing which one pattern-matches
09:38:41 <sm> I believe calling exitSuccess in a subthread prints progname: ExitSuccess to stdout, is there any way to prevent that ?
09:38:41 <kmc> (data constructors, not type constructors)
09:38:58 <kmc> > let f (Just x) = x; f Nothing = 0 in f (Just 2) -- pattern-matching the constructors of Maybe
09:38:59 <lambdabot>   2
09:40:29 <angstrom> kmc: I want to do something like `data C a = A a | B a | ...  f :: C a -> b -> C b   f (c _) x = c x'
09:40:57 <kmc> oh, that is trickier
09:41:03 <kmc> i recommend refactoring your data type
09:41:07 <angstrom> (I think that's basically what >>= for Just is doing, no?)
09:41:12 <kmc> data CT = A | B | ...; data C a = C CT a
09:43:16 <Taejo> with the ViewPatterns extension, in `foo f (f -> x) = ...`, does the f in the view pattern refer to the argument?
09:44:50 <Taejo> a brief experiment indicates it does
09:45:25 <Taejo> so you could do a kind of patterns-as-argument using that, but kmc's suggestion is better
09:45:32 * Taejo just interested in the hack value
09:45:54 <int-e> Taejo: yes. "Any variables in expr are bound occurrences. Variables bound by patterns to the left of a view pattern expression are in scope." says http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
09:46:21 <int-e> with the even crazier example, example ((f,_), f -> 4) = True
09:46:43 <Taejo> hmm, interesting that an order of evaluation is specified
09:46:57 <int-e> no, it's just about scope
09:47:21 <int-e> which affects the evaluation order, of course.
09:47:48 <Taejo> right
09:48:34 <Taejo> ok, off to the shops to acquire supper
09:51:08 <mm_freak> if affects the dependencies, which specifies evaluation order, but you can also use (i always forget what those things are called) lazy patterns
09:51:16 <mm_freak> (~(f, _), f -> 4)
09:51:32 <mm_freak> irrefutable i think
09:53:05 <kk`> Is there a way of making a function with a 'IO a -> Maybe a' type without wrapping up an unsafePerformIO's result in a Just?
09:53:12 <kk`> Or am I missing something obvious
09:53:47 <mauke> const Nothing
09:53:53 <int-e> mm_freak: well, that particular example will be equivalent to ((f, _), f -> 4) modulo different kinds of bottom, since the value of f is demanded in the pattern.
09:54:53 <mm_freak> kk`: that was mauke's way of saying that yes, most likely you are missing something obvious
09:54:55 <int-e> const (Just (error "no can do"))
09:55:58 <kk`> mm_freak, ok :p
09:56:38 <ion> kk: Imagine ‘IO a’ contains a string with human-readable instructions for generating a value of type ‘a’ and a human implements the IO part of the RTS. How would you convert ‘io ("Read an integer from standard input and result in it")’ to ‘Just Integer’?
09:57:08 <ion> kk: ‘IO a’ does not “contain” an ‘a’, it contains instructions that result in an ‘a’ upon execution.
09:57:48 <mm_freak> kk`: however, look at the (>>=) function, which might help you here…  it has the following type signature:  IO a -> (a -> IO b) -> IO b
09:57:48 <kk`> Ok. I think i've got it.
09:58:12 <mm_freak> it takes such a 'recipe' and constructs a new one, which uses the result of it
09:58:35 <mm_freak> getLine >>= putStrLn
09:59:00 <Rc43> Hi, guys.
10:00:43 <dylukes> ion: well logically I'd eval (unsafePerformIO) the IO part, then stick it in Just :).
10:01:11 <dylukes> *troll*
10:01:23 * ion covers his ears. THERE’S NO unsafePerformIO. THERE’S NO unsafePerformIO. THERE’S NO unsafePerformIO.
10:01:40 <mm_freak> dylukes: i think it's not very kind to confuse beginners
10:01:46 <mm_freak> not even as a joke
10:01:52 <dylukes> alright...
10:02:31 <Rc43> About a week ago I have talked about something like IOC in haskell. Look at it http://rghost.net/26566361
10:02:33 <dylukes> ion: well logically I'd use a monadic bind (>>= :: m a -> (a -> m b) -> m b)) where "m" is IO, and "b" is Maybe String.
10:02:38 <Rc43> http://pastebin.com/vJRKu5DJ how to use it
10:02:39 <mauke> The paste vJRKu5DJ has been copied to http://hpaste.org/52914
10:02:46 <dylukes> ion: better?
10:03:02 <ion> dylukes: Yes
10:03:03 <Rc43> It is just a sketch and I am beginnary.
10:03:04 <mm_freak> dylukes: better ;)
10:03:10 <dylukes> Or if I fell like sugaring it I'd do s <- action; return (Just s)
10:03:24 <mike-burns> Rc43: I feel like IOC is just how you do things in functional programming.
10:03:31 <mm_freak> Rc43: that's an 8 MiB tarball…  could you summarize?
10:03:34 <ion> Which means «Just <$> action»
10:04:10 <mm_freak> kk`: why do you want such a function anyway?  it almost sounds like you want this instead:  IO a -> IO (Maybe a)
10:04:26 <mm_freak> kk`: there is something similar, which may be what you are looking for:  IO a -> IO (Either SomeException a)
10:04:30 <mm_freak> it's from Control.Exception
10:04:31 <kk`> I had IO (Maybe a) but I had a feeling there was a more conside way
10:04:34 <Rc43> mm_freak, it consists of core app that uses module by the iface, and it has 2 different test implementations, which I can switch run-time.
10:04:42 <Rc43> But usage is by interface.
10:04:47 <kk`> Well, something slightly simpler anyway
10:04:47 <dylukes> ion: mm
10:05:13 <dylukes> kk`: nope.
10:05:49 <mike-burns> Rc43: You can write FORTRAN in any language. Doesn't mean you should.
10:05:56 <Rc43> I have posted it to know if it can be useful with better implementation.
10:06:06 <mm_freak> what is IOC?
10:06:27 <Rc43> mm_freak, inversion of control (dependency injection)
10:06:44 <Rc43> mike-burns, why FORTRAN?
10:06:44 <kk`> Isn't dependency injection just one way of achieving inversion of control?
10:06:50 <mm_freak> Rc43: you get that for free in haskell, but in a different way
10:07:14 <mike-burns> Rc43: I picked FORTRAN because the famous quote is for FORTRAN.
10:07:15 <Rc43> mm_freak, how to implement similar?
10:07:20 <mm_freak> Rc43: remember that you can have polymorphic types and pass functions around in haskell easily
10:07:35 <mm_freak> Rc43: a simple example of this is 'map'
10:07:41 <Rc43> mike-burns, didn't understand you =/
10:07:43 <mm_freak> > map (+ 1) [1..10]
10:07:44 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
10:08:27 <Rc43> mm_freak, emmm
10:08:42 <mm_freak> Rc43: if you think about it, you will find the IOC pattern there
10:08:45 <mm_freak> :t map
10:08:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:09:09 <mm_freak> the non-IOC variant would be addOne
10:09:17 <mike-burns> I'm not going to download a taball of code, but I'm going to guess there's some misuse of typeclasses going on.
10:09:21 <mm_freak> > let addOne = map (+ 1) in addOne [1..10]
10:09:22 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
10:09:36 <mm_freak> that way you can pass simple functions or whole loggers, displayers, etc.
10:09:43 <Rc43> mm_freak, you shouldn't work with an implementation in IOC.
10:09:56 <mm_freak> ?
10:10:22 <Rc43> mm_freak,  or ...
10:10:27 <mike-burns> Haskell is not a duckt-typed language.
10:10:47 <mm_freak> Rc43: i'm just telling you that IOC is done very differently in haskell, much different from how it is done in most object-oriented languages
10:11:29 <mm_freak> it is, in a sense, builtin
10:12:31 <Rc43> mm_freak, my purpose was set the whole module of functions runtime
10:12:56 <Rc43> mm_freak, and do it in similar way for different types of modules
10:13:06 <ksf> why does ghc require libncursesw?
10:13:15 <Rc43> mm_freak, may be it can be implemented like data types but i am not sure
10:13:18 <ksf> just for unicode in/output?
10:13:29 <mm_freak> Rc43: unfortunately modules are not first class in haskell…  however, values are, and they can contain functions
10:13:52 <mm_freak> Rc43: also separate plugins from dependency injection…  you can combine the two later, but don't implement them as the same thing
10:14:44 <Rc43> mm_freak, what you mean in `combine the two later' ?
10:15:20 <aninhumer> mike-burns: as long as it quacks in a way provably equivalent to a duck it's a duck.
10:15:32 <mm_freak> Rc43: for example a logger…  in haskell a logger "object" would be just a function like LogLevel -> String -> IO ()
10:15:49 <mm_freak> Rc43: you can have such a function in a module, load that module and pass its function to the computation, which needs a logger
10:16:05 <mm_freak> the receiver should only wait for a logger, not for a whole module
10:16:20 <Rc43> mike-burns, there is no typeclasses
10:16:38 <Rc43> lol 8 mb is a huuuuuuuuge trouble
10:16:49 <mike-burns> Yup.
10:16:50 <Rc43> (it compiled)
10:16:55 <Rc43> *is
10:17:24 <hatomic> woohoo I love Haskell
10:17:25 <mm_freak> Rc43: generally we have to recompile anyway…  so it's better to make a pure source tarball instead
10:17:44 <mike-burns> Oh you wanted me to download a binary and run it?
10:17:48 <ksf> Rc43, strip the binary and be surprised.
10:17:49 <mm_freak> unless you have everything statically compiled and have binaries for all the different platforms here =)
10:18:07 <mike-burns> Should I sudo this binary, too?
10:18:24 <Rc43> no
10:18:27 <ksf> ...and what's left then is mostly library code, it's not like ghc would bloat your application code.
10:18:44 <Rc43> it works only on ghc >= 7
10:18:51 <Rc43> (btw)
10:19:02 <mm_freak> anyway, i think the source code is the most interesting part here
10:19:18 <mm_freak> most people won't have to compile it to examine it
10:19:35 <Rc43> I have understood it already, is it necessary to reupload it or it isn't interesting?
10:20:09 <mm_freak> Rc43: if you reupload it, i will look into it after having a bath =)
10:20:27 <mm_freak> because i'm not sure i understand what you want to do anyway
10:21:38 <Rc43> http://rghost.net/26570841
10:22:17 <Rc43> mm_freak, exactly because of it I uploaded it but not just told on channel :)
10:23:41 <saml> Rc43, what is it?
10:24:07 <mike-burns> Can't you use hpaste or pastebin?
10:25:19 <Rc43> mike-burns, there are 6 files
10:25:46 * mike-burns goes back to work.
10:26:15 <Rc43> whois mike-burns
10:26:27 <saml> he's creator of haskell language
10:26:58 <Rc43> > US
10:26:59 <lambdabot>   Not in scope: data constructor `US'
10:27:03 <Rc43> > 8 mb is huge
10:27:04 <lambdabot>   Not in scope: `mb'Not in scope: `is'Not in scope: `huge'
10:37:36 <bfig> where would Jeremy Gibbon's paper 'Calculating functional programs' fall from the point of view of theory?
10:37:43 <bfig> generic programming?
10:38:10 <saml> waht is that paper about?
10:39:06 <saml> it looks like it's about equational reasoning
10:39:14 <bfig> saml, Abstract. Functional programs are merely equations; they may be ma-
10:39:14 <bfig> nipulated by straightforward equational reasoning. In particular, one can
10:39:14 <bfig> use this style of reasoning to calculate programs, in the same way that
10:39:14 <bfig> one calculates numeric values in arithmetic. Many useful theorems for
10:39:14 <bfig> such reasoning derive from an algebraic view of programs, built around
10:39:15 <bfig> datatypes and their operations. Traditional algebraic methods concen-
10:39:17 <bfig> trate on initial algebras, constructors, and values; dual co-algebraic meth-
10:39:19 <bfig> ods concentrate on final co-algebras, destructors, and processes. Both
10:39:21 <bfig> methods are elegant and powerful; they deserve to be combined.
10:39:26 <bfig> sorry, that was meant to be a single line
10:39:39 <saml> how do you make multiline into single line?
10:39:51 <bfig> no idea...
10:40:12 <ion> Paste it to vim, merge with J, copy the line back to the clipboard.
10:40:13 <bfig> it is the abstract, i figured it was a paragraph, not a series of stacked lines
10:40:13 <saml> you would replace \n with empty
10:40:25 <saml> so that is O(n)
10:40:49 <saml> but let's say multilines are already printed out.
10:40:54 <saml> how woudl you undo IO action?
10:41:04 <saml> should we rebuild IO in terms of reactability ?
10:41:05 <bfig> you don't
10:41:06 <ion> With a time machine, of course.
10:41:51 <saml> let t = putStrLn someString Now;       takeStrBack t
10:41:56 <mm_freak> Rc43: that's essentially a plugin test, no?
10:42:32 <saml> in quantum computing, can you revert to superimposed state after observing qbit?
10:42:41 <mm_freak> saml: no
10:43:05 <saml> so computation is energy transfer. work is done, right?
10:43:05 <mm_freak> saml: after measurement the state transforms to the measured state
10:43:28 <dmwit> saml: yes
10:43:41 <mm_freak> not at all…  you can have loops and everything, but you can't revert from measurement to the original state
10:43:53 <saml> so functional programming doesn't have a chance, right?
10:44:04 <saml> it does not describe energy transfer
10:44:08 <mm_freak> sure it does…  in fact haskell is a great language for quantum computations
10:44:13 <dmwit> Functional programming has a chance, but you must add linearity.
10:44:30 <mm_freak> you just can't use the normal functional programming…  you need a DSL for quantum computations
10:44:59 <ion> killGrandfather :: IO ()
10:45:08 <ion> {-# LANGUAGE CausalityViolations #-}
10:45:24 <hpaste> dmwit pasted “emulating GADTs... almost =)” at http://hpaste.org/52922
10:45:27 <mm_freak> ion: {-# LANGUAGE Neutrinos #-}
10:45:56 <saml> dmwit, what does liniarity mean?
10:46:11 <saml> is it related to linear algebra, linear type?
10:46:16 <dmwit> saml: Linear types, yes.
10:46:29 <mm_freak> saml: all computations in quantum mechanics are represented by unitary matrices, hence linear
10:46:30 <dmwit> Linear types express the constraint that a value may only be observed once.
10:46:38 <dmwit> s/observed/used/ sorry
10:46:42 <mm_freak> not linear types, that solves a different problem
10:46:48 <mm_freak> you can well read a quantum state twice
10:46:52 <dmwit> observation uses a value of a linear type and gives back a non-linear value =)
10:46:53 <saml> how is that possible?
10:47:02 <saml> type has number of observation property?
10:47:10 <saml> i thought type was about value
10:47:23 <dmwit> saml: Types are about what you want them to be about.
10:47:35 <mm_freak> somebody listening?  no?  alright…
10:47:39 <dmwit> First you decide what constraints are important, then you design a type system with those constraints. =)
10:48:02 <dmwit> mm_freak: What do you mean by "you can read a quantum state twice", exactlyL
10:48:14 <saml> let's say this value is integer (interprete this 32bit data as two's complement).    so, linear type is saying that  this value is integer and it can only be read once?
10:48:19 <dmwit> mm_freak: Once you make an observation, that thing is in a different state.
10:48:44 <mm_freak> dmwit: you can measure the same photon twice…  with certain setup and measurement parameters you will get the same state out
10:48:51 <mm_freak> linear types are not powerful enough
10:49:15 <dmwit> mm_freak: If you can guarantee you get the same measurement twice, you're not measuring the same state twice. =)
10:49:45 <mm_freak> the point here is that every operation must be representable as a unitary matrix…  you can't really encode the quantum properties in the type system
10:50:14 <mm_freak> that's the "linearity" of quantum physics…  it is fundamental and has little to do with measurement
10:50:19 <dmwit> saml: yes
10:50:35 <dmwit> mm_freak: We're talking about two different kinds of linearity, I'm afraid.
10:50:57 <saml> i'm not sure how linear type is useful
10:51:00 <dmwit> mm_freak: There's quantum operations (which are linear operators), and observations (which are well-represented by linear types).
10:51:08 <saml> it looks like it is constraining a lot.
10:51:16 <dmwit> saml: Yes, it is very constraining.
10:51:27 <dmwit> saml: It has to be: quantum mechanics is very constraining. =)
10:51:31 <mm_freak> dmwit: that really depends on your DSL
10:51:42 <saml> what is linearity have to do with linear type?
10:51:46 <mm_freak> dmwit: i would only need RankNTypes
10:51:58 <dmwit> mm_freak: Yes, for sure. But a DSL that has no interface between classical and quantum computing doesn't seem very useful to me, and that interface is where linear types arise.
10:52:32 <dylukes> Is there a non-silly way to refer to "this record" within the definition of a record?
10:52:36 <dmwit> saml: Linearity in the quantum mechanics sense and linearity in the type theory sense are not really related, as mm_freak and I have been observing together for a few minutes now.
10:52:45 <dmwit> dylukes: field?
10:52:48 <mm_freak> dylukes: let rec = Record { … } in rec
10:52:49 <saml> what does linearity mean?
10:52:55 <dylukes> mm_freak: No I mean like
10:53:12 <dylukes> let rec = Record { a = ...; b = a rec + 1}
10:53:18 <mm_freak> saml: linearity means that after observation you have to forget about the old state…  the type system forces you to
10:53:25 <erus`> dylukes: doesnt that work?
10:53:27 <mm_freak> dylukes: yes, we mean the same thing =)
10:53:43 <saml> what does linearity have to do with linear algebra?
10:54:02 <mm_freak> saml: nothing in this case…  dmwit is referring to the destructive measurement process in quantum physics
10:54:03 <ion> fix (\rec -> Record { a = …; b = a rec + 1 })   -- Alternative way to put it
10:54:16 <mm_freak> saml: linear types wouldn't allow you to measure the same state twice
10:54:27 <saml> i would like to know meaning of linearity in general
10:54:29 <mm_freak> saml: they would force you to measure one state and then its outcome
10:54:37 <saml> wiki says "resembling line"
10:54:41 <dylukes> ion: that's prettier
10:54:54 <mm_freak> dylukes: i think the let variant is prettier
10:55:02 <dylukes> No, it adds MORE layout :<
10:55:21 <mm_freak> there is also 'where'
10:55:27 <dylukes> yeah true
10:55:30 <mm_freak> or just a simple binding
10:55:39 <mm_freak> myRec = Record { … }
10:56:15 <saml> what about    rec {b = rec a + 1} ?
10:57:03 <mm_freak> saml: quantum mechanics is a linear theory in the "resembling line" sense
10:57:16 <mm_freak> saml: but that has nothing to do with linear types
10:57:37 <saml> oh you can only use pattern matching to acccess a field in a record
10:57:57 <mm_freak> saml: a rec instead of rec a
10:58:01 <saml> yup
10:58:08 <saml> rec {a = b rec + 2}
10:58:19 <ion> Or one of the lens packages.
10:58:24 <saml> maybe record field should be  prefixed with :
10:58:32 <mm_freak> saml: why?
10:58:33 <saml> :b rec + 2
10:58:38 <saml> to look like clojure :P
10:58:49 <mm_freak> i found clojure ugly
10:58:52 <saml> or prefixed with .     .b rec + 2
10:59:47 <mm_freak> the lisp languages always had a wierd syntax to me, and no, it's not about the parentheses
11:00:41 <Rc43> mm_freak: have time to look at my files? I have reuploaded them. And I am going to use such way not only for binding haskell modules but e.g. C written , too.
11:01:19 <mm_freak> Rc43: yes, i asked a question:  so you're essentially just testing plugins
11:01:26 <mm_freak> can't see a DI pattern there
11:01:58 <Rc43> TestModuleIface and Impl?
11:02:17 <mm_freak> Rc43: yes, that's dynamic modules
11:02:46 <Rc43> mm_freak, ok, is this code ugly or norm?
11:03:14 <mm_freak> Rc43: doesn't look particularly ugly to me…  the 'plugins' stuff right now makes it ugly a bit, but there is little you can do about it
11:03:40 <mm_freak> Rc43: just one thing:  in Iface you really should specify the type signature
11:03:45 <engla> erus`: I was thinking of lists before (c++ static fib), it's of course possible to implement a "fib(n)" function in this constexpr "language"
11:04:00 <erus`> paste
11:04:30 <Rc43> mm_freak, yeah, really
11:04:57 <Rc43> mm_freak, so i shouldn't search more beautiful ways? thanks for watching
11:04:58 <erus`> engla: i meant lazy list :)
11:05:33 <mm_freak> Rc43: one more beautiful way is to embed a haskell interpreter and interpret source files there
11:05:55 <mm_freak> real compiled plugins are a mess right now, at least for type safety
11:06:14 <Rc43> mm_freak, i am afraid that in future i will need fast code
11:06:15 <mm_freak> manatee has done some work in this direction in his framework
11:06:29 <mm_freak> also there is the direct-plugins library with a sligthly nicer interface
11:07:05 <engla> erus`: lazy list can't be done :)  this is the simple case. unfortunately this pastebin only has gcc4.5 so it doesn't work there. (4.6 does here) http://ideone.com/49fc6
11:07:38 <engla> erus`: also this is how foldr can be done at compile time c++11 http://kaizer.se/wiki/log/post/C++_constexpr_foldr/
11:07:39 <Rc43> mm_freak, will look at it
11:08:51 <erus`> engla: haha cool :)
11:10:00 <erus`> what is this wizardry?:  typename F::result_type
11:11:27 <engla> erus`: a class may contain typedefs
11:13:06 <erus`> its actually quite readable
11:13:30 <engla> right, c++'s newest compile time language is better than the old one (template metaprogramming)
11:13:48 <engla> and still functional
11:14:33 <erus`> engla: is the F::return_type necessary or just a hint?
11:14:52 <rferranti> necessary
11:15:26 <DukeDave> engla: Please don't mention template metaprogramming, I came here to get away from that ;)
11:15:26 <engla> necessary, and it reduces typing. if you pass a function object that doesn't have it, you can instead specify the return type and first arg type
11:15:28 * DukeDave shudders
11:15:59 <engla> DukeDave: sure but haskell taught be how to even begin understanding it
11:16:00 <balor> If f :: a -> b, is it correct to say that "f returns type b"?
11:16:09 * balor is just checking terminology
11:16:14 <erus`> F::first_argument_type <- how many does it go upto? onehundredandfirst_arguement_type
11:16:19 <copumpkin> balor: f returns a value of type b
11:16:26 <balor> copumpkin, thanks
11:16:32 <DukeDave> It's going to be interesting to see where it goes, that's for sure..
11:16:46 <DanBurton> balor: or alternatively, the output of function f has type b
11:18:18 <DanBurton> I try to avoid saying "returns" when talking about Haskell functions, to avoid confusion with "return"
11:18:46 <engla> f :: a -> b  f maps a to b?  or does that confuse us with fmap
11:19:09 <DanBurton> significant whitespace makes the meaning clear :)
11:19:25 <engla> also better not choose example functions named f
11:19:34 <hpaste> “Mukesh Tiwari” pasted “Monad Transformer” at http://hpaste.org/52929
11:19:46 <keep_learning> hello all
11:19:53 <DanBurton> keep_learning: hello
11:20:02 <balor> DanBurton, thanks.  I think that's more what I'm looking for
11:20:15 <keep_learning> I am trying to understand monad transformer and wrote this code http://hpaste.org/52929
11:20:27 <keep_learning> DanBurton, hello
11:20:41 <keep_learning> but i am getting compiler error
11:21:02 <keep_learning> could some one please tell me what is wrong with this code .
11:21:15 <byorgey> keep_learning: please paste the error along with the code
11:21:40 <byorgey> keep_learning: you have a 'put' inside a call to 'liftIO'
11:21:46 <byorgey> liftIO takes an IO action
11:22:01 <byorgey> keep_learning: you probably want  (liftIO $ print a) >> put ...
11:22:14 <byorgey> i.e. only lift the print action, not the entire  print >> put ... >> gcD
11:22:30 <DanBurton> keep_learning: I'm assuming the tilde isn't supposed to be there on line 8?
11:23:01 <keep_learning> DanBurton, yes , it should not be there .
11:23:59 <keep_learning> byorgey, thank you .
11:24:47 <keep_learning> DanBurton, that was because i copied it for vim . From next time  , i will check everything before posting
11:27:59 <hpaste> DanBurton annotated “Monad Transformer” with “Monad Transformer (my small prettifications)” at http://hpaste.org/52929#a52930
11:36:14 <amtal> What's the policy on missing/busy/inactive/unreachable packages on hackage?
11:36:46 <hpaste> anandjeyahar pasted “long_running factorial” at http://hpaste.org/52931
11:37:13 <amtal> I've got a bug patch for a 3 year old package that hasn't been updated, and have the feeling the authors are either MIA or uninterested.
11:37:47 <anandjeyahar> why does this fibonacci function take a long time to compute. i guess the way i have written results in some tail-call recursion. But that's just a vague guess. can somebody throw light on what i am missing
11:40:00 <Sgeo|web> tail-call recursion is generally a good thing for efficiency
11:40:19 <shachaf> Sgeo|web: That's not really true in Haskell the same way it's often true in strict languages.
11:41:05 <Sgeo|web> Oh
11:41:12 <keep_learning> One case in which we must use lift is when we create a monad transformer stack in which instances of the same typeclass appear at multiple levels.
11:41:12 <shachaf> Sgeo|web: A lot of Haskell functions are purposefully not tail-recursive.
11:41:37 <shachaf> anandjeyahar: That's a very awkward way to write the Fibonacci function.
11:41:42 <shachaf> (It's also not a factorial. :-) )
11:41:49 <shachaf> Is there any reason you did it like that?
11:41:54 <keep_learning> Does this mean that if we have all monad transformers are different in stack then we don't need to use lift ?
11:42:52 <shachaf> Sometimes.
11:43:24 <shachaf> Monad transformer classes often have convenient shortcuts for that (which are also kind of ugly, in my opinion).
11:44:08 <anandjeyahar> shachaf: really i just wanted to write some haskell code and was implemented with pattern matching, the first feature i remembered.
11:44:18 <anandjeyahar> was lazy to learn other stuff or lookup...
11:44:58 <keep_learning> shachaf, but when i removed liftIO from my gcD then i am getting compiler error .
11:45:14 <shachaf> keep_learning: You need liftIO for IO actions that are defined on IO.
11:45:16 <byorgey> amtal: usual procedure is (1) make a reasonable effort to contact the author(s) first, (2) send a message to haskell-cafe explaining the situation and proposing to take over maintainership of the package
11:45:26 <shachaf> keep_learning: Just look at the types. :-)
11:45:27 <byorgey> amtal: (3) if no objections, upload a new version listing you as the maintainer
11:46:20 <shachaf> anandjeyahar: Well, that implementation won't be efficient no matter what language you write it in.
11:46:53 <byorgey> that implementation makes an exponential number of recursive calls to fibonacci.  Function results are not memoized in Haskell.
11:47:35 <byorgey> fetching the last element of a list is also O(n), although in this case that is dominated by the recursion pattern
11:48:36 <byorgey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
11:48:37 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
11:49:05 <byorgey> that's one efficient way to generate a list of Fibonacci numbers
11:49:11 <Sgeo|web> ......function results aren't memoized?
11:49:20 <Sgeo|web> That seems.. why?
11:49:21 <byorgey> Sgeo|web: no.
11:49:30 <amtal> byorgey: thanks
11:49:46 <byorgey> Sgeo|web: for example,  f 3 + f 3  will (usually) compute f 3 twice, although it depends on the compiler
11:50:01 <byorgey> Sgeo|web: the problem is that the result could be really huge
11:50:14 <byorgey> Sgeo|web: so you trade time for memory, and this isn't always a good trade
11:50:43 <DanBurton> > let fibs = unfoldr (\(a,b) -> Just (a, (b, a+b))) (0,1) in take 20 fibs
11:50:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
11:50:50 <anandjeyahar> byorgey:interesting.. but looks like i need to pay more attention than i can manage right now.. will research it over the weekend and put up a post of sorts..
11:50:53 <byorgey> Sgeo|web: so the programmer has to specify sharing/memoization
11:51:09 <DanBurton> unfolds are fun :)
11:51:41 <byorgey> indeed =)
11:52:05 <kk`> Couldn't memoization be useful in certain cases though
11:52:15 <byorgey> kk`: yes, absolutely.
11:52:32 <byorgey> kk`: but it doesn't need special language/compiler support.
11:52:57 <kk`> That's true, but perhaps the special support could be welcome to some people.
11:52:58 <byorgey> kk`: for example, see the data-memocombinators package on Hackage
11:52:58 <shachaf> I wonder if a MonadState instance that "logs" each state as it changes would be reasonable.
11:53:18 <kk`> byorgey, I'll check it out now.
11:53:42 <DanBurton> for example, to compute a really big fibonacci number, you only need to keep 2 numbers in memory. memoization would typically keep all of the preceding numbers in memory
11:53:47 <shachaf> kk`: You need good justification to add something to a language, as opposed to a library or something, if possible.
11:53:50 <mm_freak> kk`: the rule of thumb is, if you want to memoize a result, give it a name
11:54:06 <keep_learning> take 10 . map fst .  iterate (\(a , b ) -> ( b , a + b ) ) $  ( 0 , 1 )
11:54:11 <mm_freak> kk`: you can also create a data structure to give a whole range of results a name
11:54:12 <shachaf> And there's what mm_freak said, though that doesn't always work.
11:54:45 <mm_freak> shachaf: when does it fail?
11:54:51 <keep_learning> let fib =  map fst .  iterate (\(a , b ) -> ( b , a + b ) ) $  ( 0 , 1 ) in take 10 fib
11:54:57 <kk`> shachaf, since libraries already exist and are sufficient enough, it would probably be a nearly superfluous addition.
11:55:32 <DanBurton> keep_learning: if you want lambdabot to run it, put > in front
11:55:42 <DanBurton> > take 10 . map fst .  iterate (\(a , b ) -> ( b , a + b ) ) $  ( 0 , 1 )
11:55:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
11:55:56 <shachaf> mm_freak: Well, you can't adapt a simple recursive fibonacci to do that in a straightforward way, can you?
11:56:00 <keep_learning> DanBurton, thank you .
11:56:20 <mm_freak> shachaf: i would know how to do it at least for finite fibonacci sequences
11:56:20 <dafis> > fix ((0:) . scanl (+) 1)
11:56:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:56:33 <sp3ctum> I notice there's no unfoldl. I wonder why
11:56:49 <shachaf> sp3ctum: What would it do?
11:57:02 <shachaf> Seems like a weird function to have.
11:57:04 <Cale> sp3ctum: because foldr is the real fold ;)
11:57:13 <Cale> foldl is an imposter
11:57:16 <shachaf> Cale++
11:57:16 <sp3ctum> Cale, what do you mean
11:57:17 <copumpkin> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html#v:unfoldl
11:57:22 <kk`> @hoogle unfoldl
11:57:23 <lambdabot> No results found
11:57:28 <Cale> http://cale.yi.org/share/Folds.svg
11:57:31 <DanBurton> o_O never thought about it
11:57:32 <shachaf> copumpkin: OK, but Data.Sequence is different from []. :-)
11:57:59 <Cale> foldr f z replaces each (:) in the construction of a list with f, and any [] with z
11:58:36 <DanBurton> Cale: is there a similar explanation of unfoldr?
11:59:12 <copumpkin> Maybe (a,_) lives under lists
11:59:22 <DanBurton> @remember Cale foldr is the real fold; foldl is an imposter
11:59:22 <lambdabot> Okay.
11:59:26 <copumpkin> it is the fabric from which lists are woven
11:59:40 <hpaste> “Ertugrul Söylemez” pasted “Finite Fibonacci sequence” at http://hpaste.org/52932
11:59:49 <mm_freak> shachaf: http://hpaste.org/52932
12:00:05 <DanBurton> copumpkin: that sounds really deep, but at the same time, means almost nothing to me
12:00:06 <Cale> foldl does something a bit strange, and, as you can see in the picture, the nodes which were deeper in the list end up in a shallow position in the resulting expression
12:00:18 <copumpkin> DanBurton: I always aim for that
12:00:31 <shachaf> mm_freak: Well, sure.
12:00:34 <copumpkin> mm_freak: now write the same thing with an unboxed vector
12:00:37 * DanBurton is now friends with copumpkin <3
12:00:42 <shachaf> mm_freak: It's just not an obvious transformation, I think.
12:00:45 <copumpkin> DanBurton: :)
12:00:59 <shachaf> I mean, you did more than "giving it a name". :-)
12:01:07 <copumpkin> DanBurton: lists are either nil, or a pair of an element and another list, right?
12:01:15 <mm_freak> copumpkin: that wasn't my intention…  my intention was to use Vector for memoization
12:01:18 <DanBurton> copumpkin: right-o
12:01:52 <copumpkin> DanBurton: so Maybe (a, ...) is roughly equivalent to one "slice" of a list, right?
12:01:59 <copumpkin> we don't really know what belongs in that ... bit
12:02:05 <copumpkin> ideally it'd be the rest of the list
12:02:07 <DanBurton> copumpkin: oh I get it now. a List is either Nothing or Just (a, AnotherList)
12:02:11 <copumpkin> yeah
12:02:13 <erus`> every gta game ever for £5 on steam...
12:02:17 <Cale> What copumpkin is trying to say is that lists of values of type a are a fixed point of the functor which sends the type t to Maybe (a,t) :)
12:02:19 <copumpkin> but then we'd be writing Maybe (a, (Maybe (a, Maybe (a, ...))))
12:02:35 <sp3ctum> Cale, can you show me how to read the picture you pasted? from that it seems to me that foldr f [1..5] starts from the number 1
12:02:43 <copumpkin> DanBurton: we can't write that in haskell, but we can either fudge it, or still use the fact that lists are composed of that for our unfold
12:02:48 <sp3ctum> and I think it should start at 5, then work backwards to 1 (from the right)
12:03:03 <Cale> sp3ctum: The thing on the left of the |--> is the list being given to foldr f z
12:03:34 <Cale> sp3ctum: The lines lead out from the bottom of a function to the top of its arguments
12:04:04 <Cale> So the list is 1 : (2 : (3 : (4 : (5 : []))))
12:04:15 <Cale> and foldr f z transforms that to
12:04:28 <Cale> f 1 (f 2 (f 3 (f 4 (f 5 z))))
12:04:53 <sp3ctum> ah, i see that now, thanks
12:04:58 <Cale> which has the same shape, but with each (:) replaced with f and the [] with z
12:05:05 <Cale> and it really does start at the top
12:05:29 <Cale> foldr f z (1 : ...) = f 1 (foldr f z ...)
12:05:38 <Cale> control then passes to f
12:05:50 <Cale> if f doesn't use its second parameter, the foldr doesn't continue
12:06:32 <coppro> Hey, is there a way to print a Rational in decimal notation? I could be using really large numbers so turning it into a floating-point number is unsuitable
12:06:32 <Cale> (It's important to remember that lazy evaluation is outermost-first)
12:07:44 <Cale> > showFFloat (Just 20) (473894 % 732189) ""
12:07:45 <lambdabot>   No instance for (GHC.Float.RealFloat (GHC.Real.Ratio t))
12:07:45 <lambdabot>    arising from a ...
12:07:49 <Cale> er...
12:07:50 <sp3ctum> i've not thought about folds working like that, cool
12:07:58 <dolio> coppro: I think there isn't. There probably should be one, though.
12:08:11 <coppro> indeed
12:08:13 <Cale> oh, right, RealFloat /= RealFrac
12:08:25 <dafis> easy to write, if efficiency doesn't matter
12:08:33 <coppro> yeah, it doesn't
12:08:38 <Cale> You could always convert via CReal :)
12:09:06 <Cale> > showCReal 200 (realToFrac (473894 % 732189))
12:09:07 <lambdabot>   "0.647229062441528075401296659742225026598323656870015801930922207244304407...
12:09:49 <coppro> > showCReal 200 (realToFrac (1 % 7))
12:09:49 <lambdabot>   "0.142857142857142857142857142857142857142857142857142857142857142857142857...
12:09:54 <dolio> > showCReal 200 (realToFrac (1%2))
12:09:55 <lambdabot>   "0.5"
12:10:06 <dolio> Oh, it's actually intelligent about that.
12:10:23 <Cale> yeah, it seems to cut off trailing zeroes
12:10:27 <dolio> That's probably the best way.
12:10:46 <copumpkin> but what if there was a 1 way deep down :(
12:10:47 <opqdonut> showCReal seems overkill
12:11:03 <burp> > showCReal 200 (realToFrac (1%2) + 1e-300)
12:11:04 <lambdabot>   "0.5"
12:11:04 <opqdonut> copumpkin: well if there are none in the 200 digits that were given as the precision
12:11:04 <Cale> It is overkill, but it's already written ;)
12:11:23 <burp> > showCReal 200 (realToFrac (1%2) + 1e-100)
12:11:23 <Cale> > showCReal 400 (realToFrac (1%2) + 1e-300)
12:11:23 <lambdabot>   "0.500000000000000000000000000000000000000000000000000000000000000000000000...
12:11:24 <lambdabot>   "0.500000000000000000000000000000000000000000000000000000000000000000000000...
12:11:54 <copumpkin> wow
12:12:48 <dylukes> Why is writing parses such a tarpit XD.
12:12:52 <dylukes> parsers*
12:12:53 <Cale> > approxRational pi 0.1
12:12:54 <lambdabot>   16 % 5
12:12:55 <dylukes> a fun one though...
12:12:59 <Cale> > approxRational pi 0.01
12:13:00 <lambdabot>   22 % 7
12:13:04 <Cale> > approxRational pi 0.001
12:13:04 <dolio> You're pretty much stuck with this issue unless you go with a different output format.
12:13:05 <lambdabot>   201 % 64
12:13:12 <dolio> Like continued fractions.
12:13:15 <hpc> dylukes: because deterministic pushdown automata are strictly less powerful than nondeterministic ones
12:13:33 <copumpkin> sad, isn't it
12:13:49 <dylukes> I should suggest edwardk make a non-deterministic trifecta.
12:14:00 <dylukes> instead of ever failing it returns a tree of all possible parsing interpretations.
12:14:11 <dylukes> whoo.
12:14:24 <hpc> it would be interesting to write a parallel parser
12:14:36 <dylukes> It would be interesting for natural language parsing.
12:14:53 <Cale> If you need to write a parser, you probably don't want to write a parser. If you want to write a parser, you probably don't really need one.
12:15:17 * dylukes is writing a small compiler.
12:15:20 * dylukes kind of needs it.
12:15:29 <dylukes> Granted, what I'm writing right NOW, I do not.
12:15:29 <dylukes> :
12:15:30 <dylukes> :P*
12:15:47 <Cale> But at least there's Parsec and friends :)
12:16:10 <hpc> when confronted with a problem, compiler authors say "I'll just use yacc"; then they have two problems
12:16:12 <dylukes> and Trifecta!
12:17:32 <Cale> Man, I just can't win with X these days. I switched back to metacity from compiz, and now I don't have horrible random freezes involving YouTube, but I do get random rectangles of my background picture blitted on top of my windows occasionally.
12:17:43 <Cale> I guess that's better?
12:18:01 <shachaf> Cale: I have a similar issue with metacity.
12:18:17 * shachaf will just wait until kmcwm is released, or something.
12:18:47 <Cale> I'm not using Xmonad until someone writes a module to make it look and work like metacity.
12:23:09 <bfig> fcr, :)
12:23:19 <fcr> hi bfig :)
12:24:37 <ybit> hi guys
12:24:43 <ybit> Multiple declarations of `Main.x'
12:24:48 <ybit> What is x considered?
12:25:00 <dafis> a top level binding
12:25:05 <dafis> I suppose
12:25:11 <ybit> hrm...
12:25:18 <ybit> i'm trying to figure out how to say this
12:25:20 <hpaste> DanBurton pasted “Fun with lists (cool unfold?)” at http://hpaste.org/52933
12:25:29 <dylukes> @hoogle (a -> a -> a) -> ([a] -> a)
12:25:30 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
12:25:30 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
12:25:30 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
12:25:48 <ybit> i'm trying to demonstrate what destructive updates are why haskell will not allow them
12:25:51 <dafis> ybit: perhaps hpaste the code, we could tell you more if we can see it
12:26:01 <ybit> i'm not sure what to call the x in `Main.x
12:26:08 <parcs> type annotation?
12:26:10 <ybit> it's just
12:26:12 <ybit> x = 1
12:26:13 <DanBurton> ybit: a binding?
12:26:14 <ybit> x = 2
12:26:15 <monochrom> that will cause multiple declarations, yes. please don't do it
12:26:35 <DanBurton> ybit: or call it what the error calls it: a "declaration"
12:26:37 <monochrom> anyway, it is not allowed, and you're seeing it
12:26:51 <ybit> i understand, i'm trying to create some tutorials
12:26:51 <ybit> sfasdfdfdfdfdf
12:26:53 <dolio> DanBurton: You should use newtype instead of data.
12:26:56 <ybit> test
12:26:58 <ybit> hrm
12:27:08 <ybit> sorry about that
12:27:40 <DanBurton> dolio: aye. good catch
12:27:49 <ybit> would you say "the binding x in the program Main"?
12:28:00 <Cale> In the module Main
12:28:09 <ybit> thanks cale
12:30:58 <copumpkin> DanBurton: mapJustSnd is also fmap . fmap
12:31:21 <copumpkin> well
12:31:25 <DanBurton> fmap on a 2-tuple maps the function onto the second element?
12:31:27 <copumpkin> :t fmap .: fmap
12:31:28 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
12:31:29 <copumpkin> yeah
12:31:36 <monochrom> you could say "haskell doesn't let you update x". of you could say "it hasn't even crossed haskell's mind, haskell doesn't even know you mean to update x"
12:31:37 <copumpkin> hmm, fail
12:31:46 <DanBurton> let mapJustSnd = fmap .: fmap
12:31:52 <DanBurton> @let mapJustSnd = fmap .: fmap
12:31:53 <lambdabot>  Defined.
12:31:58 <dolio> :t fmap . fmap
12:31:59 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:32:00 <copumpkin> nah, that was b0rked
12:32:02 <dolio> That's the right one.
12:32:04 <copumpkin> it was fmap . fmap
12:32:20 <DanBurton> yeah that signature looks better
12:32:28 <DanBurton> @undefine
12:32:35 <DanBurton> @let mapJustSnd = fmap . fmap
12:32:36 <lambdabot>  Defined.
12:32:55 <DanBurton> > mapJustSnd (+1) $ Just ('a', 3)
12:32:57 <lambdabot>   Just ('a',4)
12:33:17 <DanBurton> where is the tuple instance for functor?
12:33:49 <ybit> why does ghci seemingly allow destructive updates?
12:33:56 <ybit> i.e. you can do let x = 1
12:34:02 <ybit> and then in the next let x = 2
12:34:09 <ybit> > let x = 1
12:34:11 <lambdabot>   not an expression: `let x = 1'
12:34:12 <DanBurton> it's variable shadowing
12:34:17 <opqdonut> shadowing, yeah
12:34:19 <DanBurton> > let x = 1 in let x = 2 in x
12:34:20 <lambdabot>   2
12:34:22 <rferranti> the second it's just nested
12:34:32 <copumpkin> you can shadow in C too
12:34:35 <opqdonut> let x = 1; let x = x+1; in ghci doesn't do what you think
12:34:48 <dylukes> okay, I don't get this :|
12:34:49 <monochrom> > let x=1 in (let x=2 in x)+x
12:34:50 <lambdabot>   3
12:34:54 <dylukes> say I have
12:34:55 <copumpkin> dylukes: wat
12:35:18 <dylukes> data MyRecord m t = MyRecord { foo :: m t, bar :: t -> t -> m t }
12:35:20 <dylukes> or something like that
12:35:26 <copumpkin> mkay
12:35:28 <hpc> monochrom: i remember there being a bug related to that
12:35:33 <hpc> > let x=1 in let x=2 in x+x
12:35:34 <lambdabot>   4
12:35:37 <hpc> > let x=1 in let x=2 in x + x
12:35:38 <lambdabot>   4
12:35:39 <basvandijk> DanBurton: You can find instance Functor ((,) a) in Control.Monad.Instances
12:35:40 <copumpkin> hpc?
12:35:48 <dylukes> when I set foo to say
12:35:50 <dylukes> a Bytestring
12:36:02 <DanBurton> basvandijk: thanks :) kinda a strange place to put it, but w/e
12:36:03 <dylukes> in my myRecord = MyRecord { ... }
12:36:13 <dylukes> then it says for bar that it can't deduce t ~ bytestring
12:36:15 <dylukes> :\
12:36:15 <copumpkin> a ByteString won't fit in foo
12:36:19 <hpc> copumpkin: you do some nested let-ins, and at some point the meaning changes when you add or remove spaces
12:36:21 <dylukes> my specific example
12:36:22 <dylukes>   OperatorTable {
12:36:23 <dylukes>     operator = ident emptyOps
12:36:24 <dylukes>   , lookupOp = flip Map.lookup $ Map.fromList [("a byte string", undefined)]
12:36:25 <dylukes>   }
12:36:32 <dylukes> (overloaded strings are here)
12:36:44 <copumpkin> a ByteString won't fit in m t
12:36:47 <monochrom> if you set foo to a bytestring, what is m?
12:36:49 <dylukes> its not m t
12:36:56 <dylukes> well, it is, bt notice
12:36:58 <dylukes> ident emptyOps
12:37:04 <dylukes> that IS m Bytestring
12:37:12 <dylukes> oh... fuck
12:37:14 <dylukes> wait no
12:37:17 <dylukes> its good, point free
12:37:21 <copumpkin> give us more code
12:37:25 <copumpkin> in a paste
12:37:34 <monochrom> what is the type of ident emptyOps?
12:38:00 <dylukes> https://gist.github.com/1304765
12:38:43 <dylukes> ident emptyOps :: m ByteString
12:38:48 <dylukes> (ident :: MonadParser m => IdentifierStyle m -> m ByteString)
12:38:51 <copumpkin> myOpTable :: MonadParser m => OperatorTable t p m Expr
12:38:55 <copumpkin> look at that t
12:39:24 <dylukes> yeah?
12:39:32 <monochrom> so t is ByteString?
12:39:37 <dylukes> yeah
12:39:42 <copumpkin> myOpTable :: forall t. MonadParser m => OperatorTable t p m Expr
12:39:44 <copumpkin> FORALL t
12:39:45 <copumpkin> :)
12:40:00 <monochrom> oh, right
12:40:03 <dylukes> Whenever I add for all's, it complains about the other variables.
12:40:11 <copumpkin> myOpTable :: MonadParser m => OperatorTable ByteString p m Expr
12:40:14 <copumpkin> that's what you gave it
12:40:15 <dylukes> for all t. -> Not in scope type variable all the other ones.
12:40:15 <bfig> i'm a bit confused, what does a.foldr x y z mean?
12:40:25 <dylukes> copumpkin: but why is for all not the default?
12:40:30 <copumpkin> no, it is
12:40:30 <incluye> bfig: . is function composition
12:40:36 <copumpkin> I wasn't talking about the forall syntax
12:40:40 <incluye> probably better written a . foldr x y z
12:40:44 <dylukes> ah... I see.
12:40:50 <bfig> of course but what does it mean?
12:40:58 <dylukes> So what should I do, just specify my t?
12:40:58 <copumpkin> dylukes: by writing t there on its own, you mean your definition works for all choices of t. You only provided one such choice
12:40:59 <monochrom> yeah, you're like "whee :: IO t; whee = return True"
12:41:03 <incluye> (f . g) x = f (g x) I think
12:41:05 <copumpkin> dylukes: yeah, write what I wrote: myOpTable :: forall t. MonadParser m => OperatorTable t p m Expr
12:41:07 <copumpkin> shit
12:41:13 <incluye> > (+1) . (-2) 3
12:41:13 <lambdabot>   No instance for (GHC.Num.Num (f a))
12:41:13 <lambdabot>    arising from a use of `e_1123' at <i...
12:41:15 <dylukes> no, that doesn't work XD.
12:41:17 <incluye> D'oh
12:41:17 <copumpkin> myOpTable :: MonadParser m => OperatorTable ByteString p m Expr
12:41:18 <ybit> can someone explain to me how variable shadowing in ghc works?
12:41:20 <dylukes> That's the same thing as what I have.
12:41:21 <dylukes> Yeah
12:41:22 <incluye> > ((+1) . (-2)) 3
12:41:23 <dylukes> there we go
12:41:24 <lambdabot>   -1
12:41:26 <incluye> There you go
12:41:52 <dylukes> Trying to make a generalized infix/prefix/postfix/mixfix parser :P
12:41:55 <Cale> ybit: consider something like  x = 1; y = let x = 2 in x + x
12:42:05 <monochrom> you can't be polymorphic when you aren't polymorphic. (useless tautology!)
12:42:12 <Cale> ybit: The x in the definition of y has nothing to do with the x = 1 at the top level
12:42:12 <bfig> :t \a op zero list -> a.foldr op zero list
12:42:13 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> f a -> f a) -> f a -> [a1] -> f b
12:42:29 <copumpkin> myOpTable :: exists t. MonadParser m => OperatorTable t p m Expr
12:42:32 <copumpkin> that would've worked
12:42:35 <copumpkin> had it been possible to write it
12:42:43 <Taejo> ybit: you're just declaring a new variable with the same name
12:42:45 <copumpkin> wouldn't be very useful though
12:42:48 <Cale> ybit: It's a separate binding altogether, but it makes the top level binding of x inaccessible inside the definition of y.
12:42:59 <Cale> (because it steals the name)
12:43:00 <monochrom> yeah, don't go existentialism
12:43:01 <hpc> > let let x = 2 in x = y in y
12:43:02 <dylukes> So what's the reason GHC doesn't have exists again?
12:43:02 <lambdabot>   <no location info>: Parse error in pattern
12:43:05 <hpc> aw
12:43:11 <dylukes> Like, what was the bug?
12:43:16 <Cale> dylukes: bug?
12:43:24 <dylukes> Er, w/e keeps it from working
12:43:24 <dylukes> not bug.
12:43:26 <dylukes> fault.
12:43:45 <copumpkin> dylukes: it never did
12:43:47 <DanBurton> type error! (when you fix the type errors, it magically works, right?)
12:43:58 <copumpkin> dylukes: besides, writing it as exists would typecheck your definition
12:44:02 <copumpkin> but then you wouldn't be able to use it much
12:44:20 <dylukes> Well, I know.
12:44:42 <bfig> why does the functor arise there?
12:45:04 <dylukes> hey but the way, where can I set default GHC stuff?
12:45:13 <copumpkin> dylukes: Bool :: exists a. a
12:45:22 <ybit> how does ghci store the bindings?
12:45:28 <dylukes> but copumpkin, Bool :: *  :\
12:45:28 <dylukes> No?
12:45:30 <ybit> Main.x
12:45:39 <copumpkin> I meant True :)
12:45:42 <dylukes> ah
12:45:57 <dylukes> Wouldn't you say True :: Bool though?
12:46:03 <monochrom> you can set ghci defaults in .ghci
12:46:04 <dylukes> Bool  :: exists a. a is true... but its not useful :\
12:46:04 <ybit> Main.x wouldn't work
12:46:10 <dylukes> monochrom: what's the format?
12:46:26 <copumpkin> dylukes: same with True :: exists a. a
12:46:37 <dylukes> er, I meant True >_<
12:46:49 <monochrom> ghci commands, line by line, for example :set -fglasgow-exts
12:47:03 <copumpkin> my point is that True now has two valid types
12:47:06 <copumpkin> and in fact, many more
12:47:35 <ybit> does ghci store variablas as something like a = 1 as a.1, a =2 as a.2, etc.? i'm a bit confused if it isn't obvious
12:47:39 <shachaf> Why doesn't GHC have exists? :-(
12:48:00 <hpaste> DanBurton pasted “Main.hs” at http://hpaste.org/52934
12:48:11 <DanBurton> ybit: ^
12:48:14 <ybit> k
12:48:36 <monochrom> you can just enter "x", too
12:48:55 <monochrom> it works for me, so I don't understand the question
12:49:34 <DanBurton> shachaf: because you didn't code it into GHC?
12:51:06 <DanBurton> @where virtuahac
12:51:06 <lambdabot> http://www.haskell.org/haskellwiki/VirtuaHac
12:51:16 <DanBurton> wonder if anything is going on yet
12:52:07 <bfig> how can i make lambdabot write my function as a lambda abstraction?
12:52:17 <ybit> DanBurton: that didn't really clarify what i'm trying to understand. i wrote example.hs, wherein the contents were the exact same as your paste. i imported it in ghci and was able to seemingly destroy x's value
12:52:41 <bfig> ie, op id = \a -> a
12:52:41 <ybit> i'm trying to understand how variable shadowing actually works in ghci
12:53:03 <DanBurton> ybit: "let" in ghci shadows variables in the same way as any old let
12:53:32 <ybit> well, i can visualize how it works i suppose
12:53:50 <ybit> and that's good enough
12:53:53 <ybit> oi shapr[
12:53:53 <bfig> :t id
12:53:54 <lambdabot> forall a. a -> a
12:55:05 <hpaste> DanBurton annotated “Main.hs” with “Main.hs (annotation)” at http://hpaste.org/52934#a52935
12:55:12 <DanBurton> ybit: does this help? ^
12:55:15 <dylukes> http://hackage.haskell.org/packages/archive/type-level/0.2.4/doc/html/Data-TypeLevel-Num-Aliases.html
12:55:17 <dylukes> why does this...
12:55:19 <dylukes> why...
12:55:24 <dylukes> are they chosen at random?
12:56:31 <Taejo> dylukes: what do you mean, at random?
12:56:42 <dylukes> like... there's no particular rhyme or reason to the choice in aliases
12:56:47 <DanBurton> dylukes: looks pretty exhaustive to me
12:56:56 <dylukes> It's not 5000->0
12:57:05 <dylukes> it stops around 4900 and goes to random octal numbers.
12:57:29 <dylukes> er, lower
12:57:47 <dylukes> at D4097
12:58:06 <byorgey> dylukes: uh, they aren't random
12:58:08 <dylukes> unless... oh... it's just putting different versions of some numbes.
12:58:09 <Taejo> dylukes: they're in decreasing numeric value, but the ranges are different for different bases
12:58:22 <dylukes> Yeah, now I see... still... this file...
12:58:29 <dylukes> >.<
12:59:06 <DanBurton> yeah glancing at that file was a big wtf at first o_O
12:59:29 <Taejo> dylukes: if you're looking for huge source files with little code content, try CPoly in crypto-api
12:59:37 <Taejo> compiling that overheated my laptop
12:59:47 <dylukes> which was that one file with the massive type signature?
12:59:53 <dylukes> the really terrifying one
13:00:41 <brisingr> hmm..
13:00:47 <brisingr> I think I might know the one
13:01:22 <brisingr> it looked something like (a -> b -> c -> d -> e) -> (b -> c -> d -> e) -> (c -> d -> e) -> (d -> e) -> e
13:01:31 <brisingr> but a b c d e were massive things too
13:01:52 <dylukes> Well, what I'm debating now is... Each operator of whatever arity carries around a constructor for its AST node, of that arity.
13:02:17 <dylukes> So I need to have a type function from Unary | Binary | ... -> a -> a | a -> a -> a ...
13:02:40 <dylukes> So I'm thinking maybe I'll use type level nats for the arity or something?
13:02:47 <dylukes> And then defined the type function inductively?
13:03:03 <brisingr> sounds more readable that way, yeah
13:03:16 <brisingr> bonus it's more "mathematical"
13:04:03 <dylukes> What package should I use for them?
13:04:05 <dylukes> type-level?
13:04:39 <brisingr> no idea, and you shouldn't rely on me
13:04:44 <brisingr> funny thing happened today
13:04:47 <dylukes> I'm asking in general.
13:05:30 <shapr> brisingr: met a Haskeller on the street?
13:05:33 <brisingr> yeah, I'd use that one
13:05:35 <brisingr> no
13:05:52 <brisingr> I tried to join #haskell and typed ghci instead
13:06:11 <shapr> haha
13:06:14 <DanBurton> :)
13:06:16 <shapr> That is funn!
13:06:17 <shapr> y
13:06:50 <brisingr> (dylukes: yeah, type-level looks good)
13:07:10 <brisingr> also, I converted 2 hardcore C++ users to haskell
13:07:24 <brisingr> the first one with foldr (liftM2 (:)) [[]]
13:07:33 <brisingr> the second one with the binary search tree implementation
13:07:36 <dylukes> :t foldr (liftM2 (:)) [[]]
13:07:37 <lambdabot> forall a1. [[a1]] -> [[a1]]
13:07:52 <dylukes> > (foldr (liftM2 (:)) [[]]) [[0,1,2,3,4,5]]
13:07:53 <lambdabot>   [[0],[1],[2],[3],[4],[5]]
13:07:58 <dylukes> h, dur.
13:08:01 <dylukes> oh*
13:08:02 <brisingr> try it with 2 sublists
13:08:14 <dylukes> > (foldr (liftM2 (:)) [[]]) [[0,1,2,3,4,5], [6,7,8,9,0]]
13:08:15 <lambdabot>   [[0,6],[0,7],[0,8],[0,9],[0,0],[1,6],[1,7],[1,8],[1,9],[1,0],[2,6],[2,7],[2...
13:08:34 <brisingr> pretty cool
13:08:34 <dylukes> > (foldr (liftM2 (:)) [[]]) [[0,1,2], [3,4,5]]
13:08:35 <lambdabot>   [[0,3],[0,4],[0,5],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5]]
13:08:45 <brisingr> it works with any number of sublists
13:09:02 <brisingr> it was a class assignment in C
13:09:23 <brisingr> the guy almost strangled me when he saw it
13:09:29 <bfig> :help list
13:09:33 <bfig> :help
13:09:36 <bfig> !help
13:09:40 <brisingr> @help
13:09:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:09:41 <brisingr> ?
13:09:45 <bfig> @help list
13:09:45 <lambdabot> list [module|command]
13:09:45 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
13:10:18 <bfig> @help unlambda
13:10:18 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
13:11:18 <bfig> @help pointy
13:11:18 <lambdabot> pointful <expr>. Make code pointier.
13:12:30 <incluye> @pl \a b c d -> a b (c d)
13:12:30 <lambdabot> ((.) .)
13:12:42 <incluye> @pl \a b c d -> a (b c) d
13:12:42 <lambdabot> (.)
13:12:58 <bfig> i don't understand the type of this: \a op zero list -> a.foldr op zero list
13:12:59 <incluye> @unpl ((.)$(.))
13:12:59 <lambdabot> (\ b c e f -> b c (e f))
13:13:01 <bfig> :t \a op zero list -> a.foldr op zero list
13:13:02 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> f a -> f a) -> f a -> [a1] -> f b
13:13:15 <bfig> ghci gives me other type
13:13:26 <ybit> how to exit ghci from within eshell? :P
13:13:34 <ybit> ctl-d no workey
13:13:40 <bfig>  :exit ?
13:13:41 <Cale> bfig: Yeah, that's because (.) is fmap in lambdabot :)
13:13:45 <brisingr> :q
13:13:52 <acowley> I wish everyone just put their code on github
13:13:55 <ybit> :q it is
13:13:59 <ybit> thanks brisingr
13:14:06 <Cale> I wish everyone just put their code on hackage
13:14:17 <bfig> Cale, what is composition?
13:14:35 <dylukes> Ooh, I had a great idea for trolling the dynamic language fanatics.
13:14:36 <Cale> Function composition is (f . g) x = f (g x)
13:14:42 <incluye> (f . g) x = f (g x)
13:14:44 <incluye> oh
13:14:50 <bfig> emm... in lambdabot
13:14:54 <dylukes> Create a language in which whenever an identifier can't be found, it uses a fuzzy match to make a best guess.
13:14:56 <dylukes> Silently.
13:15:01 <Cale> In lambdabot, it's been generalised to (.) = fmap
13:15:03 <incluye> > (succ . pred) 1
13:15:05 <lambdabot>   1
13:15:05 <acowley> Cale: Every day I feel guilty that I don't have any packages on hackage
13:15:06 <kamaji> dylukes: nice.
13:15:17 <Taejo> dylukes: I believe it's been done
13:15:23 <bfig> i don't understand where the hell all the functors come from
13:15:29 <bfig> @unpl \a op zero list -> a.foldr op zero list
13:15:29 <lambdabot> \ a op zero list d -> a (foldr op zero list d)
13:15:31 <Cale> and for the functor (->) e, we have that fmap f g x = f (g x)
13:15:37 <acowley> Cale: But I don't know that it's the place for trivial helper modules, and it's not so great if your library has a dependency outside of hackage
13:15:46 <incluye> :t foldr
13:15:46 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:16:02 <aristid> :t Data.Foldable.foldr
13:16:03 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
13:16:03 <kamaji> What's wrong with this? getLine >>= return.read.words :: IO [Int]
13:16:04 <Cale> fmap :: (a -> b) -> f a -> f b, so when f = (e ->), we get  fmap :: (a -> b) -> (e -> a) -> (e -> b), which is exactly the type of composition
13:16:25 <aristid> :t getLine >>= return.read.words
13:16:26 <bfig> shouldn't this be just (a->b)->(c->a->a)->a->[c]->b ?
13:16:26 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
13:16:26 <lambdabot>       Expected type: String
13:16:27 <lambdabot>       Inferred type: [String]
13:16:37 <Cale> kamaji: you want map read
13:16:37 <aristid> :t getLine >>= return.map read.words
13:16:37 <kamaji> oh....
13:16:38 <lambdabot> forall a. (Read a) => IO [a]
13:16:38 <kamaji> nevermidn
13:16:41 <kamaji> damn, too slow~
13:16:50 <Cale> kamaji: You also probably want fmap
13:16:52 <aristid> kamaji: also, >>= return . x is the same as fmap x
13:16:59 <acowley> My plea for github is that there is a package I use that no longer builds. I patched the source on hackage to make it work and emailed the maintainer. The maintainer thanked me, but hasn't pushed a new version and the repository isn't public, which means I can't patch against the maintainer's HEAD version.
13:16:59 <dylukes> > 1 == 1 == 2
13:17:00 <lambdabot>   Precedence parsing error
13:17:00 <Cale> fmap (map read . words) getLine
13:17:00 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
13:17:08 <kamaji> hold the phone
13:17:12 <kamaji> what now?
13:17:12 <kamaji> :D
13:17:36 <bfig> Cale, can i pm you?
13:17:47 <Cale> acowley: I don't use git, so I don't know much about github, except that people link to it fairly often
13:17:52 <Cale> bfig: sure
13:17:57 <hiptobecubic> Cale, it' great
13:18:00 <kamaji> fmap ((map read).words) getLine
13:18:01 <kamaji> ?
13:18:01 <hiptobecubic> it's*
13:18:08 * Cale is a darcs fan :)
13:18:25 <acowley> Cale: I use git for everything, but it's really the visibility of forks that is so helpful for this kind of small-scale distributed development
13:18:31 <kamaji> oh I forgot the type
13:18:37 * DanBurton likes the concept of darcs, but has never seriously used it..
13:18:52 * byorgey likes the practice of darcs
13:19:03 <dafis> acowley: do you know git well?
13:19:08 <byorgey> (I also like the concept)
13:19:35 * aristid doesn't like the experiences he's had with darcs so far
13:19:50 <aristid> like failing to fetch the xmonad repo with 2.5, and it only worked once i downgraded to 2.4
13:19:57 <acowley> Cale: For instance, I wanted to try the ad package on something, but performance was fatally bad, so I forked on github, sped it up, and clicked the button for my change to be pulled back in. edwardk looked at the patch and approved it, and now everything is merged.
13:20:25 <acowley> dafis: Probably not. I use it constantly, but end up googling for references all the time.
13:20:42 <acowley> dafis: If you have a specific question, I can certainly try to answer it...
13:21:05 <aristid> acowley: github is really nice, indeed
13:21:14 <Cale> acowley: In the past, I haven't been so afraid to just upload a new version of something I'm not the maintainer of on Hackage if the maintainer is unresponsive, but I'm not sure if that's considered rude or not :)
13:21:28 <dafis> how can I put a repo to the state of some fixed date?
13:21:33 <Cale> Hackage has no security, so it's easy to do, at least :)
13:21:46 <acowley> Cale: sounds potentially rude, but in my case the maintainer did respond to my email
13:22:10 <parcs> :t liftM join . join . liftM ?dist
13:22:11 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1. (Monad m, Monad m1, ?dist::a1 -> m1 (m (m a))) => m1 a1 -> m1 (m a)
13:22:11 <acowley> dafis: Figure out which commit you want by searching by date, then checkout the commit using its hash
13:22:26 <aristid> no preflex?
13:22:33 <dafis> Cale: it's rude for a while, if you don't get a reaction from the maintainer after x weeks, it's okay
13:22:40 <aristid> how to find out when edwardk last said something?
13:22:48 <kamaji> If I'm defining + for a 2D vector, e.g. "type Vector a = (a,a)", what's the best way to do it? I end up with ambiguous references to the original +
13:23:11 <parcs> :t liftM join . join . liftM ?dist :: (Monad m, Monad n) => m (n (m (n a))) -> m (n a)
13:23:12 <lambdabot>     Could not deduce (?dist::n (m (n a)) -> m (n (n a)))
13:23:12 <lambdabot>       from the context (Monad m, Monad n)
13:23:12 <lambdabot>       arising from a use of implicit parameter `?dist'
13:23:19 <dafis> acowley: I don't want a specific commit, I want the state of the entire ghc repo tree at the end of June :(
13:23:21 <kamaji> Prelude.+ I mean
13:23:46 <parcs> Cale: the definition of join you provided last night doesn't seem to work
13:23:47 <acowley> dafis: ultimately you need a specific commit. What if there were multiple commits on the day you want?
13:23:59 <Cale> parcs: hm?
13:24:11 <Cale> join = fmap join . join . fmap dist ?
13:24:23 <parcs> yeah
13:24:24 <Cale> (that's not recursive :)
13:24:33 <dafis> acowley: yeah, that's a problem, especially with so much branching and merging going on in the ghc tree
13:24:42 <parcs> :t fmap join . join . fmap ?dist
13:24:43 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Monad m, Functor f, Monad f, ?dist::a1 -> f (m (m a))) => f a1 -> f (m a)
13:24:50 <parcs> you said dist :: n (m a) -> m (n a)
13:25:34 <Cale> hrm
13:26:04 <parcs> i follow why that definition works but ghc doesn't :P
13:26:11 <ybit> when it's said that haskell doesn't allow for destructive updates, is that just for variables, or just in general for all expressions?
13:26:35 <kmc> what it means is that values are values
13:26:42 <kmc> they don't change over time
13:26:52 <dmwit> ybit: What would "destructive update" even mean for expressions?
13:26:56 <kmc> but there are things like IORefs whose contents can change over time
13:27:01 <Sgeo|web> > take 10 . fst $ let { x = 1:2:3:y; y = (-1):(-2):(-3):x } in (x,y)
13:27:03 <lambdabot>   [1,2,3,-1,-2,-3,1,2,3,-1]
13:27:04 <kmc> ybit, http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/Data-IORef.html
13:27:09 <kmc> it's a simple mutable variable
13:27:09 <parcs> :t liftM join . join . liftM ?dist :: (Monad m, Monad n) => m (n (m (n a))) -> m (n a) -- Cale
13:27:10 <lambdabot>     Could not deduce (?dist::n (m (n a)) -> m (n (n a)))
13:27:10 <lambdabot>       from the context (Monad m, Monad n)
13:27:10 <lambdabot>       arising from a use of implicit parameter `?dist'
13:27:14 <dmwit> (3 + 4) += 7 -- uh, what?
13:27:15 <ybit> dmwit: heh :) good point
13:27:18 <ybit> yes, values
13:27:53 <copumpkin> only *Refs are valid lvalues
13:28:58 <parcs> Cale: oh!
13:29:05 <DanBurton> ybit: it means what it means. You can't typically "destructively" update a variable, "destructive" meaning that you lose the previous value
13:29:25 <Sgeo|web> That... is easier than I imagined it would be. I once thought, you know, say you had a Person type, and it contains a spouse, how could something contain itself
13:29:32 <Sgeo|web> Then I think I was told it could be done.
13:29:36 <parcs> :t let join' :: (Monad m, Monad n) => (forall a. n (m a) -> m (n a)) -> m (n (m (n a))) -> m (n a); join' f = liftM join . join . liftM f
13:29:37 <lambdabot> <no location info>:
13:29:37 <lambdabot>     not an expression: `let join' :: (Monad m, Monad n) => (forall a. n (m a) -> m (n a)) -> m (n (m (n a))) -> m (n a); join' f = liftM join . join . liftM f'
13:29:38 <Sgeo|web> Now I see how easy it really is
13:29:42 <parcs> :t let join' :: (Monad m, Monad n) => (forall a. n (m a) -> m (n a)) -> m (n (m (n a))) -> m (n a); join' f = liftM join . join . liftM f in join'
13:29:43 <lambdabot> forall (n :: * -> *) (m :: * -> *) a. (Monad n, Monad m) => (forall a1. n (m a1) -> m (n a1)) -> m (n (m (n a))) -> m (n a)
13:30:03 <parcs> notice the rank-2 type
13:31:07 <Cale> yeah :)
13:31:32 <Sgeo|web> I think I want to show off that let to imperative friends
13:32:00 <parcs> Cale: do you know of a package that implements this already?
13:32:11 <Cale> parcs: I think so, hang on
13:34:26 <Cale> parcs: Oh, conal's TypeCompose library used to have it, but doesn't seem to anymore, because there's more than one way to do it.
13:34:53 <Cale> (There are other ways than just this sort of distributive law to turn a composition of two monads into a monad)
13:35:14 <Cale> But it is still in a comment in the Control.Compose module of that package
13:35:46 <parcs> interesting
13:37:54 <Sgeo|web> data Person = Person (Maybe Person)
13:38:04 <Sgeo|web> Would it even make sense to make that an eq?
13:38:10 <Sgeo|web> What happens with recursive persons
13:38:18 <Cale> hrm, I just thought of something. I wonder how often two different monads give rise the the same applicative functor?
13:38:24 <kmc> it makes perfect sense
13:38:31 <kmc> you can even derive that instance
13:38:42 <kmc> it's isomorphic to the natural numbers
13:38:54 <kmc> (ignoring ⊥)
13:38:56 <kmc> 0 = Person Nothing; 1 = Person (Just (Person Nothing)), etc
13:39:03 <Sgeo|web> So what happens when a Person contains emself indirectly?
13:39:15 <Sgeo|web> Because I'm more thinking the Maybe Person is a spouse
13:39:35 <Sgeo|web> There's no way to enforce a two person spouse-ness, is there?
13:39:36 <kmc> «let p = Person (Just p) in p == p» will not return
13:39:44 <kmc> that's ⊥
13:40:57 <ybit> !vote
13:41:03 <Sgeo|web> I guess by not exporting the constructor...
13:41:17 <DanBurton> You should have more data than simply a pointer to someone's spouse in order to determine if the person is equal to a given person
13:41:51 <ybit> Vote: What are the best reaons for why no side effects are important?
13:41:55 <Sgeo|web> marry :: Person -> Person -> (Person, Person)
13:42:06 <DanBurton> It's like saying: is this person Dan Burton? Well, this other person is his spouse. Is that person Dan Burton's spouse? well, that person's spouse is the first person we were considering...
13:42:15 <ybit> i'm taking the angle that it allows you the user to more easily reason about the output of a function.
13:42:26 <elliottt> ybit: more optimizations
13:42:53 <ybit> how so?
13:43:04 <Sgeo|web> marry a b = let { x = (Person . Just) y; y = (Person . Just) x } in (x,y)
13:43:21 <morel> how should i design a function f such that e.g.:   f "+ 1 2 3  (- 5   123)9  -12 (+(+1 2) 9)(-1 7)    10" == ["+","1","2","3","- 5 123","9","-12","+ (+1 2) 9","-1 7","10"]    -- ?
13:44:19 <applicative> Cale, isn't if often argued that there's only one way of making a monad instance for a given type X :: * -> * ?
13:44:23 <morel> (i'm writing a calculator for lispy expressions...)
13:44:55 <Cale> applicative: It's often the case, but there's nothing which ensures it.
13:45:25 <Cale> Well, it's often the case that there's only one nonidiotic monad instance
13:45:33 <applicative> Cale, hmm, I will study...
13:45:40 <Cale> Or there will be only a couple, like with State
13:47:52 <parcs> applicative: Maybe has four valid monad instances
13:49:13 <copumpkin> it does?
13:49:39 <mm_freak> ybit: it lets you write in certain styles, which would be impossible or dangerous without referential transparency
13:49:56 <mm_freak> applicative: for every nontrivial monad, there is also a trivial instance
13:50:02 <parcs> the one it has one, the one where you keep the first Just value, one where you keep the last Just value, and one where you always return Nothing
13:50:15 <parcs> s/the one it has one/its current one
13:50:18 <mm_freak> return = const SomeConstant
13:50:25 <copumpkin> those sound like they'd violate some laws
13:50:30 <copumpkin> especially the always nothing one
13:50:31 <mm_freak> _ >>= _ = SomeConstant
13:50:41 <parcs> copumpkin: i don't think so
13:51:07 <copumpkin> return a >>= f  ≡  f a
13:51:22 * applicative hasn't noticed battling monad instances in the libraries, but he's still reasoning
13:51:26 <copumpkin> oh you mean return _ = Just too?
13:51:27 <copumpkin> Nothing
13:51:39 <copumpkin> then that violates m >>= return  ≡  m
13:52:38 <parcs> oh :P
13:52:45 <parcs> well three is plenty
13:52:54 <copumpkin> no, I'm pretty sure the other two violate other laws
13:53:33 <copumpkin> think of it from the join/fmap/return perspective
13:53:40 <copumpkin> you need it to be a functor
13:53:48 <copumpkin> so fmap has to return Nothing/Just depending on what it's fed
13:53:52 <ybit> mm_freak: can you given me an example of such a style?
13:53:57 <copumpkin> return must be Just
13:54:03 <copumpkin> or it doesn't fit with fmap for pointed
13:54:26 <copumpkin> and how many Maybe (Maybe a) -> Maybe a functions can you think of that satisfy join . join = join . fmap join?
13:54:50 <mm_freak> ybit: sharing/memoization
13:55:16 <mm_freak> ybit: it also allows you to make certain assumptions when transforming functions or even IO computations
13:55:37 <parcs> copumpkin: i see. thanks
13:55:48 <mm_freak> finally it really gives meaning to some concepts like functors, monads, arrows, etc.
13:56:08 <mm_freak> i think this would be much more difficult with support for side effects
13:56:19 <hpaste> DanBurton pasted “Fun with People and weddings” at http://hpaste.org/52940
13:56:45 <ybit> mm_freak: that's very interesting
13:56:59 <ybit> i will understand this at some point, i'm not there yet
13:57:15 <ybit> i will avoid those details
13:57:22 <mm_freak> ybit: you understand it best by using haskell for some time and then going back to a language with side effects =)
13:57:28 <ybit> :)
13:57:49 <ybit> the point i'm making about lazy evaluation is that it allows for manipulation of large lists
13:57:55 <DanBurton> @hoogle (a -> b -> Bool) -> Maybe a -> Maybe b -> Bool
13:57:56 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:57:56 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:57:56 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
13:58:05 <ybit> i assume there are other uses
13:58:19 <DanBurton> Any ideas on a cleaner way of defining "maybeBool" in my latest paste?
13:59:04 <shachaf> fromMaybe False (liftM2 f a b)?
13:59:04 <copumpkin> the double-Nothing = True bit is annoying
13:59:09 <copumpkin> shachaf: no
13:59:12 <shachaf> Oh, right.
13:59:22 * shachaf missed that.
13:59:56 <DanBurton> yeah it's not monadic/applicative due to that little caveat
14:00:15 <DanBurton> as far as I can tell
14:00:36 <shachaf> This spouse thing is a bit strange.
14:01:02 <DanBurton> @pl let maybeBool _ Nothing  Nothing  = True; maybeBool _ Nothing  _        = False; maybeBool _ _        Nothing  = False; maybeBool f (Just x) (Just y) = f x y in maybeBool
14:01:02 <lambdabot> (line 1, column 139):
14:01:02 <lambdabot> unexpected "x"
14:01:02 <lambdabot> expecting operator or ")"
14:01:22 <DanBurton> doh
14:01:51 <shachaf> pl doesn't really work with things that do pattern-matching.
14:02:00 <DanBurton> aw
14:02:16 <Sgeo|web> :t compare
14:02:17 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
14:02:29 <Sgeo|web> @hoogle a -> a -> Maybe Ordering
14:02:29 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:02:29 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
14:02:30 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
14:02:40 <Sgeo|web> Bluh
14:02:58 <copumpkin> @ty \a b -> a == b || fromMaybe False (liftM2 f a b)
14:02:59 <lambdabot>     No instance for (SimpleReflect.FromExpr Bool)
14:02:59 <lambdabot>       arising from a use of `f' at <interactive>:1:42
14:03:00 <lambdabot>     Possible fix:
14:03:15 <copumpkin> that's annoying though cause it adds constraints to a and b
14:03:29 <DanBurton> I'm starting to think that single/married should be two different constructors
14:03:37 <copumpkin> yes
14:04:11 <Sgeo|web> Wait, why?
14:04:33 <DanBurton> it just seems cleaner
14:04:37 <DanBurton> hard to say exactly
14:04:51 <kamaji> Hrm, how do I have a type annotation when unboxing IO ? e.g. "x <- fmap read getLine :: Int"
14:04:53 <Sgeo|web> What about if a person had a lot of other data
14:04:59 <shachaf> kamaji: :: IO Int
14:05:18 <copumpkin> @ty \f a b -> ((&&) `on` isJust) a b || fromMaybe False (liftM2 f a b)
14:05:18 <shachaf> Or x :: Int <- ..., but you need an extension for that.
14:05:19 <lambdabot> forall a. (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool
14:05:24 <DanBurton> Sgeo|web: true point
14:05:24 <copumpkin> DanBurton
14:05:33 <copumpkin> :P
14:05:39 <shachaf> Or fmap (read :: String -> Int) ...
14:05:41 <DanBurton> copumpkin: ok...what? o_O
14:05:55 <kamaji> shachaf: oops, I was getting a second error and thinking it was the first one!
14:06:01 <kamaji> thanks, hehe
14:06:01 <shachaf> copumpkin: :-(
14:06:10 <copumpkin> just a sec, needs moar goalf
14:06:12 <shachaf> Sometimes you should just write a function out.
14:06:30 <DanBurton> copumpkin: cool usage of `on` though
14:06:49 <kk`> :t on
14:06:50 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:07:30 <DanBurton> @hoogle on
14:07:31 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:07:31 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
14:07:31 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
14:09:11 <copumpkin> DanBurton: almost  done
14:09:46 <shachaf> pumpkingolfing?
14:10:17 <copumpkin> I lost something though
14:10:18 <copumpkin> but yeah
14:10:21 <copumpkin> :t curry . liftM2 (||) (uncurry ((&&) `on` isJust)) . (fromMaybe False .) . uncurry . liftM2
14:10:22 <lambdabot> forall a2. (a2 -> a2 -> Bool) -> Maybe a2 -> Maybe a2 -> Bool
14:10:31 <copumpkin> hand-golfed by copumpkin
14:10:33 <copumpkin> in italy
14:10:37 <copumpkin> okay, not italy
14:10:49 <copumpkin> however, the `on` forced it to be homogeneous
14:10:52 <DanBurton> isn't that...longer than it was before?
14:10:54 <copumpkin> in which case you could do other trickier stuff
14:10:58 <shachaf> That's not golf!
14:10:58 <copumpkin> DanBurton: but it's pointfree!!
14:11:04 * shachaf caught copumpkin red-handed.
14:11:15 <geheimdienst> golfing in haskell means to make it more complicated. if it gets longer, so be it
14:11:21 <copumpkin> no no
14:11:24 <shachaf> @pl \f a b -> ((&&) `on` isJust) a b || fromMaybe False (liftM2 f a b)
14:11:24 <DanBurton> @pl \f a b -> ((&&) `on` isJust) a b || fromMaybe False (liftM2 f a b)
14:11:24 <lambdabot> ap (ap . ((||) .) . ((&&) `on` isJust)) . ((fromMaybe False .) .) . liftM2
14:11:25 <lambdabot> ap (ap . ((||) .) . ((&&) `on` isJust)) . ((fromMaybe False .) .) . liftM2
14:11:25 <copumpkin> it had pattern matching in it before
14:11:26 <copumpkin> that's evil
14:11:29 <DanBurton> jinx
14:11:39 <copumpkin> huh?
14:11:49 <copumpkin> no, I hand-golfed it
14:11:52 <DanBurton> we asked lambdabot to pl at the same time
14:11:57 <shachaf> Yes, your version was better.
14:12:02 <copumpkin> lambdabot's golfing sucks
14:12:16 <DanBurton> I love lambdabot's sectioned composes, though
14:12:20 <DanBurton> and gratuitous use of ap
14:14:00 <liyang> :t \ f a b -> fromMaybe (a == b) (f <$> a <*> b)
14:14:01 <lambdabot> forall a. (Eq a) => (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool
14:14:22 <GreaseMonkey> i love the sort of shit where you do e.g. in c (cond ? somefunct : anotherfunct)(foo, bat)
14:14:25 <GreaseMonkey> *bar
14:14:47 <GreaseMonkey> not sure what on does though
14:14:53 <GreaseMonkey> or isJust
14:15:09 <DanBurton> (if cond then somefunct else anotherfunct) foo bat -- in haskell
14:15:12 <liyang> I think that works. Apart from the extra Eq constraint.
14:15:30 <GreaseMonkey> if haskell didn't constantly spew type errors i'd love it
14:15:31 <copumpkin> liyang: yeah, I was trying to avoid Eq
14:15:38 <copumpkin> GreaseMonkey: it doesn't
14:15:40 <elliottt> GreaseMonkey: lol
14:15:43 <Sgeo|web> It spews type errors when you're wrong
14:15:44 <copumpkin> and the type errors are your friend
14:15:47 <copumpkin> s
14:16:03 <copumpkin> liyang: sounds like your solution needs some hand-golfing
14:16:06 <GreaseMonkey> then again i might just be using a crap type error findery interpreter
14:16:10 <Sgeo|web> Do you prefer to run quickly and see errors at run-time, or compile and see errors then
14:16:23 <DanBurton> @pl \f a b -> fromMaybe (a == b) (f <$> a <*> b)
14:16:24 <lambdabot> ap (ap . (fromMaybe .) . (==)) . (. (<*>)) . (.) . (<$>)
14:16:31 <GreaseMonkey> i prefer to compile and find errors then but i like to know how to fix them
14:16:34 <parcs> sometimes ghc spews errors when it's wrong
14:16:37 <DanBurton> lambdabot just loves ap
14:16:45 <Sgeo|web> :t ap
14:16:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:16:51 <GreaseMonkey> i suspect hugs might just be a bit crap in that department
14:16:56 <GreaseMonkey> line numbers would be nice!
14:17:18 <Sgeo|web> People still use hugs?
14:17:37 <GreaseMonkey> heh, ... that's what we're told to use for COMP304 (programming languages)
14:17:44 <GreaseMonkey> the other language we covered in that was prolog
14:18:26 <liyang> copumpkin: To avoid the Eq constraint there's always
14:18:29 <liyang> :t \ f a b -> fromMaybe (on (==) isNothing a b) (f <$> a <*> b)
14:18:30 <lambdabot> forall a. (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool
14:19:02 <copumpkin> liyang: oh yeah, that was almost my solution, except I was stupid and wrote isJust instead of isNothing :)
14:19:09 <copumpkin> except it's a bit cleaner cause it avoids the ||
14:19:22 <copumpkin> okay, time for moar gola
14:19:24 <copumpkin> golf
14:19:29 <copumpkin> @pl \ f a b -> fromMaybe (on (==) isNothing a b) (f <$> a <*> b)
14:19:29 <lambdabot> ap (ap . (fromMaybe .) . on (==) isNothing) . (. (<*>)) . (.) . (<$>)
14:19:32 <copumpkin> meh
14:19:35 <copumpkin> WEAK
14:20:54 <DanBurton> @pl \f a b -> foo (bar a b) (f <$> a <*> b)
14:20:54 <lambdabot> ap (ap . (foo .) . bar) . (. (<*>)) . (.) . (<$>)
14:21:15 <DanBurton> @pl \f a b -> foo (bar a b) (baz f a b)
14:21:16 <lambdabot> ap (ap . (foo .) . bar) . baz
14:21:28 <copumpkin> @ty curry . liftM2 fromMaybe (uncurry (on (==) isNothing)) . uncurry . liftM2
14:21:29 <lambdabot> forall a2. (a2 -> a2 -> Bool) -> Maybe a2 -> Maybe a2 -> Bool
14:21:30 <copumpkin> there we go
14:21:33 <DanBurton> @pl \a b -> foo (bar a b) (baz a b)
14:21:33 <lambdabot> ap (ap . (foo .) . bar) baz
14:21:35 <copumpkin> that's liyang's version, hand-golfed
14:22:19 <kmc> i've noticed that a lot of small (but non-trivial) Haskell programs are mostly imports
14:22:34 <kmc> that's a good sign, means we have effective code reuse etc
14:22:40 <kmc> but i still wish to shrink these programs
14:22:51 <DanBurton> kmc: import Magic; main = doMagic
14:22:54 <kmc> specifically i wish GHC would let you re-export a qualified import of another module
14:23:01 <acowley> kmc: Yes!
14:23:10 <acowley> we need more tools for cutting down import lists
14:23:43 <geheimdienst> absolutely. i'm sick of pulling in Control.Applicative just for <$>, and C.Arrow just for &&&
14:23:54 <acowley> I try to keep my modules less than 100 lines, but end up wrestling with unwieldy import lists
14:24:06 <acowley> that's why I'm very tempted to start using prelude-plus
14:24:16 <morel> geheimdienst: i dont know both of the operators you mentioned ... >.>
14:24:18 <DanBurton> acowley: YES. I was about to say that.
14:24:25 <kmc> the poor man's solution to the import list problem is CPP
14:24:28 <DanBurton> A lot of it could be fixed with a slightly beefed-up prelude
14:24:36 <morel> @src <$>
14:24:36 <lambdabot> f <$> a = fmap f a
14:24:37 <acowley> import BeefyPrelude
14:24:41 <liyang> I think import qualified Foo.Baz as Foo (Cow) should mean that you do not have to qualify Cow.
14:24:53 <morel> @src &&&
14:24:53 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
14:25:00 <morel> @src arr
14:25:00 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:25:03 <kmc> @type (&&&)
14:25:03 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:25:06 <kk`> :t arr
14:25:06 <geheimdienst> morel: <$> is fmap ... somefunc <$> foo ...
14:25:06 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
14:25:08 <kmc> (&&&) has this super generalized type
14:25:11 <kmc> but for functions it's:
14:25:12 <acowley> liyang: Yeah I would prefer that, too
14:25:18 <kmc> (b -> c) -> (b -> c') -> b -> (c, c')
14:25:22 <geheimdienst> > (succ &&& pred) 42
14:25:23 <lambdabot>   (43,41)
14:25:26 <acowley> it's frustrating to need two imports to import, say, types unqualified and functions qualified
14:25:33 * corpumpkin coughs
14:25:35 <geheimdienst> it just does 2 functions on the same argument
14:25:49 <morel> a
14:25:58 <shachaf> acowley: I sometimes put those on the same line.
14:25:59 <liyang> import Data.Map (Map); import qualified Data.Map as Map
14:26:04 <DanBurton> :t (&&&) `asAppliedTo` succ
14:26:05 <ben> How do I import Data.Enumerator without it squatting all over the Prelude names and without having to qualify all the names that aren't squatting over Prelude names?
14:26:05 <lambdabot> forall c c'. (Enum c) => (c -> c) -> (c -> c') -> c -> (c, c')
14:26:06 <shachaf> import qualified Data.Map as M; import Data.Map (Map)
14:26:11 <kmc> > (succ *** pred) (10, 20)
14:26:12 <lambdabot>   (11,19)
14:26:22 <acowley> shachaf: I don't think I like that :/
14:26:26 <shachaf> ben: List 'em out.
14:26:32 <shachaf> Or just import qualified.
14:26:33 <acowley> shachaf: it's also worse if the module name is longer
14:26:37 <shachaf> I think qualified imports migh tnot be that bad.
14:26:37 <ciaranm> what haskell needs is overloading, so you wouldn't have to have * and ** and *** and ****
14:26:39 <kmc> i think except for "standard" modules you should always import qualified or with an explicit list
14:26:55 <DanBurton> @t let anyFunc :: a -> b; anyFunc = undefined in (&&&) `asAppliedTo` anyFunc
14:26:55 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:26:55 <kmc> THE REASON: someone reading you code needs to know where a name came from
14:26:56 <ben> Putting E.>>== everywhere looks fairly silly, imo
14:27:02 <DanBurton> :t let anyFunc :: a -> b; anyFunc = undefined in (&&&) `asAppliedTo` anyFunc
14:27:02 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
14:27:09 <acowley> kmc: I agree; that's what I do
14:27:16 <kk`> @hoogle (>>==)
14:27:16 <lambdabot> No results found
14:27:20 <kmc> if it's qualified or in the explicit list, a simple text search finds it
14:27:26 * shachaf should start adding "THE REASON:" after every IRC line. :-)
14:27:35 <acowley> kmc: and that's with the understanding that I am generally the hypothetical future reader
14:27:36 <kmc> of course sufficiently fancy IDEs m ake this problem go away
14:27:46 <corpumpkin> shachaf: why?
14:27:52 <corpumpkin> (that's a cue, by the way)
14:27:56 <shachaf> kmc: Also there exist tools that will auto-fix your import list if you do that.
14:28:00 <kmc> cool
14:28:15 <kmc> there are some exceptions... if my entire module is just using one DSL, I might import that DSL unqualified
14:28:20 <acowley> corpumpkin: THE REASON: is that it will confuse people who might expect it before every line. THE REASON:
14:28:21 <kmc> similarly modules from the same project, depending
14:28:22 <shachaf> corpumpkin: Yes, I understood, but decided not to take it further.
14:28:28 <shachaf> THE REASON: I didn't want to spam the channel.
14:28:30 <DanBurton> the thing that bothers me about qualified imports is the use of . which I usually think of as compose
14:28:32 <Sgeo|web> Considering that lazy I/O is considered distasteful, is laziness actually useful for anything other than recursive data structures?
14:28:39 <corpumpkin> shachaf: fail. acowley beat you to it
14:28:40 <acowley> this is reasonable spam
14:28:48 <corpumpkin> it even has the word reason in it
14:28:48 <ben> Sgeo|web: &&
14:28:53 <kmc> Sgeo|web, "recursive data structures" encompasses most of CS
14:28:56 <kmc> so no
14:29:04 <ben> && is lazy even in CC
14:29:07 <ben> in C, I mean
14:29:27 <kmc> Sgeo|web, my "why learn haskell" slides have a few examples of how laziness makes code more composable
14:29:40 <kmc> http://mainisusuallyafunction.blogspot.com/2011/10/slides-from-why-learn-haskell.html
14:29:45 <copumpkin> phew
14:29:46 <kmc> "Why Functional Programming Matters" has a longer treatment of the same idea
14:29:48 <copumpkin> I'm back
14:29:51 <dylukes> Hm.
14:29:59 <DanBurton> Sgeo|web: laziness allows a producer and consumer to work together rather nicely. The producer only produces the minimum amount that the consumer needs
14:30:02 <dylukes> why can't I do:
14:30:03 <dylukes> type family ArityToFun
14:30:04 <dylukes> type instance ArityToFun Unary = (->)
14:30:10 <ybit>         A function can have a definite value
14:30:12 <ybit>         although its argument is undefined.
14:30:20 <dylukes> It says "family instance has too many parameters `ArityToFun'
14:30:20 <ybit> i need a simple example of this
14:30:33 <corpumpkin> copumpkin: ohai
14:30:40 <shachaf> dylukes: You need an argument, presumably?
14:30:44 <kmc> dylukes:  type family ArityToFun t
14:30:48 <Cale> ybit: f x = 0
14:30:52 <kmc> or:  type family ArityToFun t :: * -> *
14:31:00 <kmc> err * -> * -> *
14:31:07 <Cale> ybit: Even if we apply x to something undefined, f x will be 0 regardless
14:31:17 <Cale> er, apply f to something undefined rather
14:31:24 <Cale> > let f x = 0 in f undefined
14:31:25 <lambdabot>   0
14:31:29 <dylukes> kmc: Then how would I do binary?
14:31:30 <dylukes> :P
14:31:30 <copumpkin> dylukes: you can't write it that way
14:31:35 <Cale> > let f x = 0 in fix f
14:31:36 <lambdabot>   0
14:31:43 <ybit> Cale: why is that important?
14:31:51 <copumpkin> dylukes: why are you writing Unary as its own constructor by the way?
14:32:02 <dylukes> it's an alias to Succ Zero
14:32:04 <kmc> ybit, (False && longComputation)
14:32:12 <kmc> returns False, in Haskell or C or most languages
14:32:15 <ybit> ah, but that's a lot like lazy evaluation
14:32:21 <Cale> ybit: well, it means that if we apply f to something complicated to calculate, we actually don't have to calculate that thing to know the value of f x
14:32:27 <kmc> but in those other languages it's a special built-in
14:32:33 <kmc> you can't define your own short-circuiting functions
14:32:49 <Sgeo|web> Why isn't * lazy in Haskell?
14:32:53 <Cale> ybit: It can literally take forever to calculate x, but we can know f x instantly regardless.
14:33:01 <Cale> Sgeo|web: what do you mean *?
14:33:07 <dylukes> Sgeo|web: Multiplication? It is lazy.
14:33:08 <Cale> Sgeo|web: multiplication?
14:33:17 <Cale> Multiplication on which type? :)
14:33:18 <Sgeo|web> 0 * _ = 0
14:33:19 <hpc> (*) has different implementations for different numeric types
14:33:19 <dylukes> With the boxed types, anyhow...
14:33:24 <Cale> Multiplication on integers is strict
14:33:26 <ybit> and is it safe to say that non-strict evaluation, strong-static typing, and purity are the major components of haskell? that's what wikipedia seems to imply since it doesn't mention the other features until later in the wiki
14:33:36 <DanBurton> > 0 * undefined
14:33:36 <Cale> non-strict semantics, lazy evaluation
14:33:37 <lambdabot>   *Exception: Prelude.undefined
14:33:38 <Sgeo|web> Cale: why is multiplication on integers strict?
14:33:49 <Cale> Sgeo|web: Because it's efficient to do it that way.
14:34:02 <Cale> Sgeo|web: (in the general case)
14:34:07 <kk`> What types is (*) lazy with then?
14:34:15 <DanBurton> Haskell's type system doesn't exactly capture zero-ness
14:34:20 <Cale> kk`: Mostly user-defined ones :)
14:34:22 <ciaranm> ybit: the major components of haskell are a list of words copied from the back of a category theory textbook
14:34:24 <kmc> kk`, inductive natural numbers
14:34:31 <kk`> Ok
14:34:39 <kmc> also computable real numbers represented as functions
14:34:43 <johnfn> alright, i'm at my wits end. i'm getting Prelude.(!!): index too large despite never using !! in my code
14:34:44 <kmc> (sort of)
14:34:48 <Cale> ybit: um, Haskell has a lot of features, but yes.
14:35:09 <byorgey> johnfn: can you paste your code on hpaste.org, along with the complete error?
14:35:11 <hpc> johnfn: you might be using another function that uses (!!)?
14:35:13 <Cale> johnfn: well that's frustrating. What libraries are you using?
14:35:14 <dylukes> byorgey: ^
14:35:25 <kmc> ciaranm, no, those are almost universally libraries, not language features
14:35:26 <byorgey> dylukes: ?
14:35:36 <dylukes> Just pointing to what yu said.
14:35:48 <johnfn> Maybe, Ord, Trace, Lens.Common, Category, List... so i guess that probably doesn't help
14:35:53 <byorgey> dylukes: oh.
14:36:21 <Cale> johnfn: Trace is Debug.Trace?
14:36:28 <johnfn> yeah
14:36:49 <Cale> okay, hmm
14:36:51 <johnfn> what i tried so far was ghci -fbreak-on-exception and then :trace main and then :hist, but i get "Empty history. perhaps you forgot to use :trace?"
14:37:07 <Cale> yeah, the ghci debugger is often less than helpful
14:37:23 <Cale> Yeah, could you paste your code?
14:37:27 <johnfn> sure
14:38:46 <Sgeo|web> Can hint handle compiling modules at runtime?
14:39:19 <Cale> Sgeo|web: I think so. I know it will load compiled .o files if they're hanging around.
14:39:27 <kmc> Sgeo|web, 'plugins' packgae can
14:39:48 <Sgeo|web> Do hint and plugins make use of the new untrusted compilation stuff?
14:39:56 * Sgeo|web has a specific use case in mind
14:40:03 <kmc> ybit, GHC Haskell has a bunch of practical features which are rare and useful yet unrelated to that stuff
14:40:07 <Cale> They make no special use of it
14:40:12 <kmc> ybit, like good lightweight threads, STM, efficient concurrent IO
14:40:15 <Cale> But just provide an interface to GHC
14:40:24 <Cale> You can turn on that flag if you want
14:40:32 <Cale> Sgeo|web: also see mueval
14:40:33 <Sgeo|web> Ok
14:40:35 <kmc> ybit, the stuff in Haskell a language theorist will focus on is different from the stuff a commercial user will focus on
14:40:51 <kmc> (both strengths and flaws)
14:40:52 <ben> @hoogle [a] -> Int -> Maybe a
14:40:52 <lambdabot> Prelude (!!) :: [a] -> Int -> a
14:40:53 <lambdabot> Data.List (!!) :: [a] -> Int -> a
14:40:53 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
14:40:54 <Cale> Sgeo|web: which is a nice little self-contained safe evaluator for the commandline/use from other programs
14:41:04 <hpaste> johnfn pasted “!!? But I never called !!...” at http://hpaste.org/52942
14:41:22 <Sgeo|web> A codenomic is a game with players where players can vote to change the code of the game, including the code that allows for voting etc.
14:41:25 <johnfn> impressive... that saves me one less copy paste
14:41:35 <Cale> johnfn: line 30
14:41:46 <Cale> johnfn: You did call !!
14:41:48 <Sgeo|web> Haskell kind of would be a ... challenge, to implement one in, but I think that would be interesting
14:42:02 <johnfn> yeah, but i wrapped it in a check
14:42:08 <Cale> johnfn: your check is off by one
14:42:09 <Cale> ;)
14:42:17 <Cale> if val = length list
14:42:24 <Cale> then list !! val will be applied
14:42:24 <johnfn> embarrassing :D
14:43:16 <johnfn> can you take a quick peek at lines 21-25
14:43:18 <Sgeo|web> Isn't !! generally a bad idea, suggesting that arrays be used instead for random access?
14:43:41 <Cale> Sgeo|web: yeah, often
14:43:54 <Cale> Sgeo|web: or some other structure
14:44:13 <Cale> What's with the _initial _underscores?
14:44:16 <hpc> johnfn: protip: runtime length checks and stuff like that are never to be trusted when you get errors like that
14:44:40 <ben> I suppose (++ repeat Nothing) . map Just would be in bad taste
14:44:54 <DanBurton> is there any way to define pattern match synonyms?
14:45:02 <hpc> ben: haha
14:45:19 <johnfn> line 25 `show n` is just a wrapper around showHTree above, but when i stub out show n it works (no !!), but stubbing out the showHTree method to "derp" still causes an error
14:45:22 <DanBurton> For example, instead of matching on (Succ Zero), I want to match on One
14:45:29 <kmc> Sgeo|web, arrays kind of suck too; you can't update them efficiently
14:45:30 <liyang> DanBurton: SHE can do it.
14:45:37 <DanBurton> @where she
14:45:38 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
14:45:46 <kmc> Sgeo|web, but Map, IntMap, Sequence, HashMap are all possible alternatives
14:46:00 <kmc> these support efficient updates because they're tree-shaped
14:46:12 <dafis> kmc: sure, as long as you use STUArrays
14:46:16 <kmc> the updated "copy" will consist mostly of pointers into the old one
14:46:46 <kmc> sorry, I meant immutable arrays, used with pure functional update
14:47:03 <dafis> kmc: I gathered that
14:47:03 <kmc> as that's a more direct alternative to lists
14:47:05 <liyang> I always read that as STFUArrays.
14:47:28 <kmc> if you're willing to rewrite your algorithm in imperative style and accept various unfortunate consequences of that
14:47:45 <kmc> then yes you can use efficient mutable arrays
14:48:10 <kmc> but we have efficient data structures for functional code, so it's usually not worth the bother
14:48:15 <dafis> kmc: some algorithms just are a better fit for imperative
14:48:32 <erus`> dafis: like a brainfuck interpreter
14:48:33 <kmc> yeah
14:48:42 <dafis> kmc: a 10x speedup is worth the bother, IMO
14:48:42 <kmc> again, we were talking about the question of rewriting list code to use arrays
14:48:57 <kmc> dafis, a 10x speedup is almost never worth the bother
14:49:08 <kmc> because most of the code you write is already fast enough
14:49:41 <erus`> will ghc optimize vector writes?
14:49:42 <Cale> johnfn: sorry, what works/fails in each case?
14:49:49 <erus`> Vector *
14:49:51 <kmc> also the statement "some algorithms just are a better fit for imperative" is skewed by the fact that algorithms texts nearly always present algorithms in imperative style
14:50:02 <kmc> some of them are quite suitable to functional style, but you have to think harder, not just copy out of the book
14:50:16 <kmc> and there are real advantages to using functional style
14:50:24 <kmc> it's not just "do it the Haskell way because we're ideological purists"
14:50:35 <johnfn> Cale, the entire program doesnt crash if i write show n = "derp". But if i write showHTree indent n = "derp" then i get !! error
14:50:40 <liyang> We're not?!
14:50:51 <Taejo> we are, but that's not the reason
14:50:51 <kmc> i'm not
14:50:52 <yarou> lol
14:50:59 <johnfn> Cale, wait, that's not precisely true
14:51:00 <dafis> kmc: think of sieves, I haven't seen a functional variant of a sieve that wasn't awful when it came to performance
14:51:18 <Cale> dafis: really?
14:51:19 <kmc> dafis, I won't dispute your example, because I never said there were no examples
14:51:25 <Cale> dafis: because they exist :)
14:51:28 <kmc> but really, most code you write is already fast enough
14:51:33 <johnfn> Cale, if i write "showHTree i n = "herp"", no error. "showHTree i (Node ch mbr lhv) = "herp"", then i get an error
14:51:37 <kmc> maybe that's not true for sieves, but that would be the exception
14:51:38 <dafis> Cale: great where?
14:51:52 <Cale> johnfn: that indicates that the error is in constructing one of the nodes of your tree
14:52:02 <johnfn> ooooh right
14:52:10 <Cale> johnfn: the latter is different in that it pattern matches on the tree, forcing it to be evaluated
14:52:26 <johnfn> right ok i understand now
14:52:26 <johnfn> tricky :)
14:52:41 <Cale> dafis: Have you seen: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
14:52:58 <dafis> Cale: that was one I was well aware of
14:53:46 <Cale> The main problem with the list-based sieves isn't that they're functional, it's that they're using a list where a priority queue is needed.
14:54:42 <Cale> Choice of datastructure is still very important
14:55:05 <dafis> Cale: don't get me wrong, I like the idea of functional sieves, but when it matters, fast random access is really important to get acceptable performance
14:55:28 <Cale> Who said fast random access is at odds with purity?
14:56:16 <dafis> Cale: access and mutation
14:56:20 <kmc> who said it? people who think the difference between O(log n) and "O(1)" is enormous
14:56:30 <Cale> kmc ;)
14:56:54 <Cale> dafis: Are you aware of Data.Map? :)
14:57:01 <kmc> again I'm not contesting that sometimes you need imperative code for performance
14:57:11 <Cale> Data.IntMap can simulate a heap with pointers
14:57:28 <kmc> I think such situations are much rarer than believed
14:57:31 <Sgeo|web> Can all imperative code that you might need for performance reasons be done in ST?
14:57:34 <Cale> If you *really* need it
14:57:43 <Cale> Usually there's something cleverer than that
14:57:53 <kmc> picking the right data structure — knowing about things like IntMap, HashMap, Sequence, functional priority queues — matters a lot more
14:58:01 <dafis> kmc: the difference between O(1) and O(log n) makes a difference, if you sieve a bit further
14:58:28 <ciaranm> O tells you nothing about how fast your code will run
14:58:33 <kmc> dafis, I refuse to believe that the theoretical difference between O(1) and O(log n) is *ever* the right way to talk about the performance of real code
14:58:45 <Cale> dafis: You can't access any datastructure which can grow arbitrarily large in O(1) time.
14:58:57 <kmc> if you want to talk about exact cycle counts and cache misses, and relate that to some constant or logarithmic function, go ahead
14:59:01 <dafis> Cale: I am aware of Data.Map, *most* of the time it's perfectly fine, but sometimes it isn't
14:59:03 <copumpkin> Cale: you can, if you're god
14:59:08 <Cale> The reason is that your keys are O(log n) size
14:59:18 <Cale> so O(1) doesn't give you time to read your whole index
15:00:11 <Cale> Any function whose range has n distinct elements takes at least O(log n) time to compute.
15:00:39 <Cale> So a lot of datastructures textbooks lie
15:00:48 <kmc> we need to camp outside Data Structures 101 classes
15:00:52 <dafis> kmc: the theoretical difference isn't so important, the practical difference is a factor of 10 for small bounds vs a factor of 20 for larger bounds (and 30 for still larger, ...), which shouldn't be brushed off, but the factor of 10 for small bounds *is* important, practically, though not theoretically
15:00:55 <kmc> and hand out pamphlets with such inconvenient truths
15:01:03 <DanBurton> why have like 50 people suddenly joined #haskell in the same minute?
15:01:04 <copumpkin> DanBurton: a netsplit
15:01:09 <copumpkin> where 50 people parted it before that
15:01:18 <DanBurton> ah
15:01:25 <ciaranm> dafis: and how big are your constants? what's 1 * 100 vs 10 * 10?
15:01:40 <Saizan> dafis: if that's what you want to talk about you shouldn't use big O notation
15:01:42 <kmc> so how come there are 20% as many Haskell libraries as Python libraries (on public databases), when there's nowhere near 20% as many Haskell programmers
15:02:03 <Cale> kmc: haha
15:02:06 <kmc> do Haskell programmers upload more? is the bar for sharing something lower? finer subdivision of projects? better code reuse?
15:02:14 <dafis> Saizan: I didn't bring that into the discussion
15:02:18 <kmc> more people uploading to hackage vs. just throwing it on github
15:02:23 <ciaranm> kmc: because python programmers are busy writing "real" code rather than inventing new prefixes to stick before "morphism"
15:02:52 <kmc> ciaranm, are you enjoying yourself
15:02:53 <copumpkin> there's more of a tendency in haskell to write libraries that solve a problem fairly generally
15:02:56 <copumpkin> rather than one-off programs
15:02:58 <kmc> you seem to have a bug up your butt today
15:03:11 <Saizan> dafis: you did :) dafis : kmc: the difference between O(1) and O(log n) makes a difference, if you sieve a bit further
15:03:20 <Sgeo|web> morphicmorphism
15:03:26 <copumpkin> morphomorphism
15:03:39 <copumpkin> I think a morphomorphism should be a morphism from levitation
15:03:47 <copumpkin> one where you're given the shape of your data as well as the data
15:03:54 <copumpkin> so it's a generic morphism
15:04:05 <dafis> Saizan: that was a quote by kmc, I haven't mentioned O before
15:04:24 <kmc> ciaranm, anyway it doesn't make sense, wouldn't one share "real" code as  well?
15:04:28 <ciaranm> kmc: you seem to be thinking that i think that isms are a bad thing. quite the opposite -- i look forward to the day when i can replace half my code with three banana brackets
15:05:15 <ciaranm> kmc: "real" code solves a specific problem, and doesn't generalise. "abstract nonsense" code solves lots of problems, one of which happens to be the one you were supposed to be solving
15:05:46 <kmc> it sounds pretty different when you put it that way
15:06:04 <dafis> Saizan: 00:07 <kmc> who said it? people who think the difference between O(log n) and "O(1)" is enormous
15:06:21 <ciaranm> kmc: there's not much use for making a library out of a program that counts the number of purple monkeys in a tree, but there is a use for a library that counts things having a property in another thing.
15:06:23 <kmc> ciaranm, if Haskell libraries generalize better, then there should be fewer Haskell libraries, not more
15:06:32 <kmc> so it doesn't explain the observed fact
15:06:43 <copumpkin> people attempt to generalize more
15:06:48 <copumpkin> and create more libraries
15:06:52 <kmc> when I browse Hackage I see a lot of quite specific things
15:06:59 <dgpratt> since I've never encountered the same problem twice in slightly different  form/context, I've decided to write only 'real' code from now on
15:07:00 <copumpkin> it doesn't mean we actually reuse them
15:07:03 <shachaf> Not necessarily. It could be taht things that aren't libraries at all in Python become libraries in Haskell.
15:07:12 <copumpkin> yeah
15:07:18 <Cale> It really annoys me when people say that hashtable lookups cost O(1) time.
15:07:24 <kmc> and attempted solutions to general problems (e.g. lenses, lazy IO / enumerators) have 5 competing solutions
15:07:29 <dafis> Cale: me too
15:07:35 <kmc> so that inflates the ranks too
15:08:08 <ciaranm> hash table lookups are clearly O(n) if your hash function is a function
15:08:11 <shachaf> All that fragmentation is a bit sad.
15:08:37 <shachaf> Everyone should just pick one lens library which isn't data-accessors and be done with it.
15:08:53 <Cale> Well, by resizing your hashtable, you can get logarithmic time, at least until access to memory becomes non-uniform :)
15:09:21 <Cale> But computing the hash always takes at least log time.
15:09:28 * applicative begins a study of data-accessor
15:09:50 <Cale> and looking things up in an array really takes log time, even if the machine model tries to hide that from you
15:09:55 <Draconx> Cale, it really annoys me when people complain about misuse of asymptotic analysis and then make exactly the same class of mistakes in their rants.
15:10:01 <ciaranm> you only get log time if your input happens to be nice, or if you've got something sneaky in there that isn't usually mentioned in data structure courses
15:10:18 <shachaf> Cale: Would you be happier if people said O(64)? :-)
15:10:27 <Cale> Might as well say O(1) then
15:10:33 * applicative ceases studying data-accessor, he can't take the C's and T's
15:10:34 <Cale> O(64) and O(1) is the same set of functions
15:10:46 <shachaf> Right.
15:10:51 <shachaf> How about O(k), then?
15:11:02 <Cale> Why not O(log n)?
15:11:16 <monochrom> O(k) no problem!
15:11:27 <kmc> why not O(log n)? marketinG!
15:11:31 <shachaf> No, hash tables are faster than things that aren't hash tables, remember? :-)
15:11:32 <Draconx> Cale, because for comparison-based data structures such as hash tables, one usually counts the number of comparisons.
15:11:40 <kmc> same as "why not threads", gotta call them goroutines
15:12:00 <Cale> kmc: lol
15:12:09 <shachaf> Are "goroutines" just cooperative threads?
15:12:18 <Cale> Draconx: and computing hash functions is considered to be free?
15:12:19 * shachaf is missing the fancy o key.
15:12:24 <Draconx> however, someone who says "O(1) time" without mentioning a specific computational model model is talking nonsense.
15:12:33 <Draconx> s/model model/model/
15:13:02 <shachaf> I recommend that we call hash tables O(fast) and linked lists O(slow).
15:13:37 <sagelywizard> How about O(web-scale)?
15:14:24 <Draconx> Cale, it all depends on what you care about.  We count comparisons because it's easy to discuss.  As soon as you start counting the cost of array lookups, you need to bring complex computational models into play.
15:14:55 <aristid> > map length ["O(fast)", "O(1)"]
15:14:55 <lambdabot>   [7,4]
15:15:11 <aristid> shachaf: saying O(1) is much more efficient than saying O(fast), though
15:15:37 <copumpkin> yeah O(fast) is a statement about the datastructure as a whole
15:15:39 <copumpkin> not operations on it
15:15:49 <shachaf> copumpkin:: Right.
15:16:06 <copumpkin> data Right = Wrong
15:16:09 <copumpkin> copumpkin = Wrong
15:16:11 <copumpkin> copumpkin :: Right
15:16:16 <shachaf> Precisely.
15:16:49 <aristid> copumpkin: now prove it formally with agda :P
15:17:48 <ciaranm> proving it informally with agda would be even more impressive
15:18:17 <copumpkin> aristid: http://hpaste.org/52943
15:19:10 <aristid> copumpkin: that proves you wrong, not right
15:19:27 <Saizan> no, that proves he *is* wrong
15:19:35 <aristid> proof : copumpkin ≡ wrong
15:19:52 <applicative> data Wrong : Set where  Right : Wrong ; copumpkin : Wrong; copumpkin = Right
15:20:00 <shachaf> If copumpkin is wrong, I don't want to be right.
15:20:08 <copumpkin> aww
15:20:16 * copumpkin hugs shachaf 
15:20:27 <Hilbert_> Hey, can somebody explain this code to me              let 2 + 2 = 5 in 2 + 2
15:20:40 <copumpkin> Hilbert_: it's defining an operation (+)
15:20:43 <applicative> Hilbert it's a perversion
15:20:55 <copumpkin> > let 2 + 2 = 5 in 2 + 3
15:20:55 <lambdabot>   *Exception: <interactive>:3:4-12: Non-exhaustive patterns in function +
15:20:57 <applicative>  >  let 2 + 2 = 5 in 2 + 2
15:21:02 <copumpkin> that's because it isn't the usual (+)
15:21:06 <copumpkin> because you just redefined it
15:21:13 <applicative> >  let 2 + 2 = 5 in 2 + 2
15:21:14 <lambdabot>   5
15:21:36 <applicative> > let f 2 2 = 5 in f 2 2
15:21:37 <lambdabot>   5
15:21:38 <copumpkin> > let 2 + 2 = 5; x + y = x P.+ y in 2 + 3
15:21:39 <lambdabot>   5
15:21:43 <copumpkin> > let 2 + 2 = 5; x + y = x P.+ y in 2 + 2
15:21:43 <lambdabot>   5
15:21:47 <copumpkin> there we go
15:22:06 <sipa> > let x + 3 = 2*x in 3 + 3 + 3 + 3
15:22:07 <lambdabot>   24
15:22:31 <copumpkin> Hilbert_: it's just like something different
15:22:41 <copumpkin> > let 5 % 3 = 7 in 5 % 3
15:22:41 <lambdabot>   7
15:22:47 <Hilbert_> Can you just refine  function like that always?
15:22:48 <copumpkin> you can define an operator locally
15:22:50 <copumpkin> yeah
15:22:52 <Sgeo|web> If I did something like:
15:22:55 <copumpkin> it shadows the definition
15:23:08 <copumpkin> on the outside of that in part, it's still the same as it was before
15:23:12 <copumpkin> the name is just reused
15:23:15 <Sgeo|web> data Container a = Container { one :: a, two :: a, three :: a } etc
15:23:26 <Sgeo|web> Do I get O(1) reads and updates?
15:24:04 <Hilbert_> What do you mean by "shadows the definition"?
15:24:21 <copumpkin> > let a = 5 in (let a = 6 in a)
15:24:22 <lambdabot>   6
15:24:27 <copumpkin> > let a = 5 in (let a = 6 in a) + a
15:24:28 <lambdabot>   11
15:24:47 <copumpkin> Hilbert_: in different scopes, the name has different meanings
15:25:32 <applicative> >  (\(+) -> 1 + 0) (*)
15:25:33 <lambdabot>   0
15:25:38 <applicative> >  (\(+) -> 1 + 0) (+)
15:25:39 <lambdabot>   1
15:27:04 <shachaf> Sgeo|web: What does O(1) mean there?
15:27:10 <Hilbert_> Okay I understand know, but why are inbuit operators not protected keywords?
15:27:56 <Sgeo|web> shachaf: I guess that if I were to extend that data type with a four, it... hmm
15:27:58 <shachaf> Hilbert_: Why should they be?
15:28:13 <shachaf> Sgeo|web: Also, there are no updates in Haskell. :-)
15:28:21 <copumpkin> Hilbert_: they're not built in. They're just in the standard library or prelude
15:28:27 <Sgeo|web> Well, not technically updates, but returning a new etc.
15:28:31 <copumpkin> Hilbert_: in a different library, I may want to use (*) for something else
15:28:37 <copumpkin> @src on
15:28:37 <lambdabot> (*) `on` f = \x y -> f x * f y
15:28:38 <shachaf> You can construct a new Container which has all the values equal to the old one other than one, but that'll copy all the (pointers to the) old values, if that matters to you.
15:29:17 <Sgeo|web> I guess it has to copy all the pointers, and not just "This value is identical to that one except for pointer foo"
15:29:24 <Sgeo|web> ?
15:29:45 <shachaf> Well, it could do that, but I doubt it does.
15:30:52 <Sgeo|web> Is there a Haskell data structure that does do that?
15:31:30 <ciaranm> Sgeo|web: "Purely Functional Data Structures" may be of interest here
15:31:42 <copumpkin> DiffArray, sort of, backwards
15:31:48 <shachaf> Sgeo|web: If you do that it presumably means that Foo can't be garbage-collected.
15:31:49 <copumpkin> but don't use that
15:32:21 <shachaf> Also if you update N times might have to go all the way back to the original Foo to get a value.
15:32:35 <Sgeo|web> Don't use DiffAray?
15:32:38 <Sgeo|web> Why not?
15:33:01 <shachaf> Because... Because we're different to them.
15:33:58 <Sgeo|web> To make a DiffArray you need IO? BLUH
15:34:32 <Sgeo|web> Or am I misunderstanding?
15:34:44 <mm_freak> shachaf: a Map does not copy the whole structure
15:34:52 <shachaf> A DiffArray pretends to be purely-functional but secretly does mutationalizing when you update it, as I understand, and keeps a diff.
15:35:01 <mm_freak> it copies only the changed part
15:35:16 <shachaf> mm_freak: Oh, well, sure, but the "Node [...] [...]" part does presumably cpoy the pointer it doesn't change.
15:35:30 <Sgeo|web> How does it work? Does it use unsafePerformIO or something?
15:35:43 <shachaf> Sgeo|web: No, it just has a pointer to the old branch.
15:35:57 <dolio> It does use unsafePerformIO, of course.
15:36:14 <shachaf> Map uses unsafePerformIO?
15:36:16 <mm_freak> DiffArray should be safe, but it's also not very useful
15:36:21 <mm_freak> shachaf: DiffArray uses it
15:36:21 <dolio> DiffArray
15:36:24 <shachaf> Oh.
15:36:27 <shachaf> Well, yes.
15:36:50 <mm_freak> for most array stuff i would recommend to use the vector package
15:36:52 <dmwit> Note that a data structure that just stores diffs has its own costs: field access is O(number of diffs that didn't touch that field), for example, not O(1).
15:37:01 <mm_freak> repa is also nice, but it's currently also very slow
15:37:09 <mm_freak> compared to pure vector that is
15:38:05 <mm_freak> and in haskell often when you /think/ you need mutation you don't really
15:43:38 <erus`> http://hpaste.org/52945 what do you guys think?
15:44:44 <erus`> sits somewhere between functional languages and C(++)
15:45:02 <erus`> but without null types and pointers and all that pain
15:45:08 <erus`> everything is pass by value
15:46:13 <monochrom> perhaps it's great marketing to always say "is a C style language"
15:46:29 <dafis_> erus`: C++'s inheritance syntax should be eradicated from history
15:46:55 <monochrom> haskell is a C style language designed to be safe and simple. it does away with <long list> and adds <long list>
15:47:30 <hpc> lol
15:47:45 <mm_freak> erus`: are you reinventing D?
15:47:47 <mm_freak> or haxe?
15:48:09 <erus`> mm_freak: more like go but safer
15:48:16 <erus`> minimal is key
15:48:24 <erus`> i havnt looked at haxe
15:48:42 <mm_freak> i found go extraordinarily ugly
15:49:03 <mm_freak> as if the syntax of existing languages isn't complicated enough
15:49:07 <mm_freak> it's like C-style perl
15:50:29 <mm_freak> i think a language can only be considered good, if you can convince haskell programmers with it =)
15:50:53 <kmc> then only Haskell can be considered good
15:50:56 <kmc> and maybe Agda
15:51:26 <applicative> Agda good; erus`lang bad
15:51:48 <hpc> there was an article comparing go to algol 68
15:51:57 <kmc> yep
15:52:00 <mm_freak> kmc: it doesn't have to be better than haskell…  just convince haskell programmers that it really improves things
15:52:20 <kmc> i've come around to thinking Go is a social good
15:52:21 <hpc> it made the point that almost all language design is furthering functional style, and that it's unfortunate imperative style hasn't seen the same development
15:52:45 <kmc> take a memory-safe garbage-collected OOP language, simplify it further, then make it look weird and el33t so that C programmers will use it
15:52:51 <Sgeo|web> C# recently got async stuff, which, iiuc, is a monad?
15:52:56 <kmc> be sure to avoid the stink of academia or The Enterprise
15:53:11 <mm_freak> well, go is for systems programming according to its developers…  but for me it seems to fail even at that
15:53:11 <mm_freak> i wouldn't write anything in go
15:53:26 <kmc> Sgeo|web, tons of things in every language are conceptually a monad... the question is whether your language lets you capture the idea of "monad" in a library, and write code generic over all monads
15:53:47 <mm_freak> Sgeo|web: do you mean F#?
15:53:49 <kmc> C#'s LINQ syntax has connections to monad comprehensions / "do" syntax
15:53:58 <mm_freak> F# has monad-style syntax
15:54:06 <hpc> and if you want to be really pedantic, your language needs a category for the monad to inhabit
15:54:28 <Sgeo|web> kmc: yes, but C# has special syntax for async, I think, and I'm just wondering why not generalize that syntax to work with other programmer-defined monads
15:54:42 <mm_freak> Sgeo|web: look into F#
15:54:54 <kmc> i think LINQ already generalizes in that way
15:55:01 <kmc> probably they're duplicating features to some extent
15:55:04 <mm_freak> it has a syntax resembling haskell's 'do', which supports simple custom monads
15:55:22 <erus`> we need some sort of monoid in the catagory of endofunctors?
15:55:28 <mm_freak> it doesn't go as far as haskell, though…  you can't have monad transformers as easily
15:56:07 <erus`> monad transformers are horrible anyway :(
15:56:14 <mm_freak> erus`: why?
15:56:24 <hpc> erus`: they aren't horrible, they just don't generalize well
15:56:31 <erus`> just look ugly to me
15:56:37 <erus`> hard to reason about as a haskell noob
15:56:52 <erus`> monads and stuff look elegant
15:57:09 <mm_freak> erus`: often you generalize some control structure over a monad…  being able to use a monad transformer there makes things really flexible
15:57:38 <mm_freak> for example generalizing my beloved automaton arrow over a monad makes it a lot more useful
15:57:56 <mm_freak> newtype Auto m a b = Auto (a -> m (b, Auto m a b))
15:58:01 <kmc> imo monad transformers are most useful when they're abstract
15:58:18 <hpc> FT: why isn't there a MonadLift t m | t -> m where lift :: m a -> t m a?
15:58:21 <mm_freak> now you can have underlying state by using a StateT monad
15:58:25 <hpc> s/lift/something better/
15:58:27 <kmc> that is, if my library defines some complicated monad internally, it's better to do some transformer instead
15:58:36 <mm_freak> hpc: see the contstuff library
15:58:37 <hpc> instance MonadLift EitherT Either where lift = ...
15:58:43 <mm_freak> hpc: it defines LiftFunctor
15:58:44 <kmc> i think monad transformers frequently aren't worth it when you're working with simple mtl monads
15:58:46 <hpc> ooh
15:59:05 <mm_freak> hpc: but it defines it only for its own transformers, so it's probably not very useful for mtl/transformers
16:00:58 <mm_freak> hpc: wait a minute…  perhaps we are talking about different things
16:01:07 <mm_freak> perhaps you mean MonadTrans?
16:01:08 <hpc> mm_freak: no, that looks exactly like what i wanted
16:01:16 <mm_freak> i see
16:01:29 <hpc> mm_freak: i just wrote my 'lift' wrong :P
16:01:41 <mm_freak> it's essentially:  liftF :: m (Maybe a) -> MaybeT m a
16:01:48 <hpc> yeah, that
16:02:04 <hpc> though i was thinking liftF :: Maybe a -> MaybeT m a
16:02:12 <hpc> which is trivially yourLiftF . return
16:02:21 <hpc> so nvm :P
16:02:22 <mm_freak> yeah, it proved to be a very useful combinator…  i should port it to transformers
16:03:11 <hpc> mm_freak: in an older iteration of my IRC bot i needed to write it myself to lift Maybe into the huge main transformer type my bot used
16:03:32 <mm_freak> oh, writing a bot library, too? =P
16:03:38 <cheater> why was your bot using a huge transformer type
16:03:40 <cheater> ?
16:03:46 <hpc> cheater: it was easier at the time
16:03:59 <hpc> mm_freak: not a library, and i don't think anyone would want the current iteration
16:04:00 <cheater> what would you do instead?
16:04:09 <hpc> it's tied into my website's database too much now :P
16:04:15 * hpc >>= undefined
16:04:34 <mm_freak> i see =)
16:04:57 <cheater> hey you know what would be cool
16:05:11 <cheater> if i could somehow manipulate the order in which ghc does its type inference
16:05:30 <mm_freak> cheater: how is that order relevant?
16:05:30 <cheater> so that i could say "ok, this function is supposed to be inferred first"
16:05:39 <cheater> mm_freak: what
16:05:49 <cheater> oh
16:05:50 <amtal> I'm trying to use uniplate to extract data from an AST. With SYB, there was a `listify :: (r -> Bool) -> a -> [r]` that used a predicate to extract stuff. What's the equivalent in Uniplate?
16:06:07 <cheater> yeah it's relevant because if you have an error, then you end up having stuff inferred incorrectly
16:06:30 <cheater> and if the inference starts where the error is, then 99% of your program is incorrectly typed
16:06:40 <cheater> and this then means you can't easily track down the bug.
16:06:42 <mm_freak> cheater: isn't it better to specify your program better, i.e. provide more type signatures?
16:06:46 <cheater> no
16:06:52 <cheater> why would you do that? you have type inference
16:07:03 <cheater> do you wear a belt and suspenders?
16:07:18 <mm_freak> i always have type signatures for all top level definitions and most second level definitions
16:07:34 <mm_freak> helps me catch errors earlier in my development cycle
16:07:45 <cheater> that's nice, but that's not the only way to go
16:08:30 <mm_freak> sometimes type signatures also help me to find that my whole idea is broken, when trying to write them
16:08:53 <engla> writing out the type helps you see how to implement it
16:09:12 * DanBurton loves types
16:09:40 <mm_freak> yeah…  type inference is a good feature for /inside/ your definitions…  but at least your top level definitions should have a specification
16:09:43 <cheater> why is it important to talk about the same basic practices over and over
16:09:56 <blackdog> mm_freak: for delivery, sure
16:10:09 <mm_freak> cheater: anyway, it's not possible
16:10:17 <cheater> why would you say that
16:10:25 <mm_freak> because nobody implemented it
16:10:25 <blackdog> it's nice to have that flexibility while you're working out the structure
16:10:48 <cheater> so it isn't impossible, it's just not available
16:10:57 <cheater> there's a very big difference here
16:11:10 <mm_freak> alright, it's not available
16:11:39 <mm_freak> blackdog: i'm working out the structure /through/ type signatures
16:12:24 <mm_freak> once the type signatures compile, i start with the actual definitions
16:12:51 <Sgeo|web> Can you have type signatures that compile without actual definitions?
16:12:59 <Sgeo|web> Well, I guess you could do whatever = undefined
16:13:00 <mm_freak> Sgeo|web: myFunc = undefined
16:13:40 <blackdog> mm_freak: i find my problem is often that the type i pick isn't general enough
16:13:58 <blackdog> so it's often worth at least asking the compiler what it thinks the type is and then fixing it
16:14:32 <mm_freak> blackdog: it's a common problem among beginners that they overgeneralize…  you don't have to provide the most general type signature possible
16:14:51 <mm_freak> in fact, you shouldn't, because the more general your type signature, the more invalid programs the compiler will accept
16:15:37 <mm_freak> the compiler can only come up with the most general type signature, not with a reasonably general type signature…  for example it would happily infer 'a' for a point-free version of the id function
16:15:39 <ddarius> mm_freak: That's not true.
16:15:48 <blackdog> mm_freak: at least working with yesod, the monad transformer stacks are pretty hairy.
16:16:07 <mm_freak> ddarius: what exactly?
16:16:08 <blackdog> and if you pick a less general type, you'll quite often get an incomprehensible error message back
16:16:36 <ddarius> That the more general a type is the more invalid programs it allows.
16:17:16 <mm_freak> ddarius: if you view type signatures as specifications, it is true…  of course 'invalid' with respect to the intended application
16:17:55 <mm_freak> blackdog: one of the cases, where it suggests to write a Num instance for SqlPersist? ;)
16:18:37 <monochrom> beginnners overgeneralize their types and overspecializes their approaches
16:18:56 <blackdog> mm_freak: ha, i haven't seen that one yet.
16:19:28 <mm_freak> blackdog: i'm not sure i've seen it either, but yes, its suggestions can be weird
16:19:37 <mm_freak> i got used to them though
16:19:51 <Sgeo|web> hlint isn't part of Haskell Platform?
16:20:14 <monochrom> isn't.
16:20:27 <blackdog> Sgeo|web: never further than a 'cabal install' away :)
16:20:41 <Sgeo|web> Should I cabal install or apt-get?
16:20:45 <Sgeo|web> I apt-get'd the platform
16:20:59 <mm_freak> Sgeo|web: if you have it in an apt repository, use apt
16:21:08 <Sgeo|web> Note that this computer system is not long for this world, so I don't really care _that_ much
16:21:11 <aepe> Something strange is happening here: http://ideone.com/ZmZo5
16:21:18 <mm_freak> itf it's not as terribly outdated as everything in debian =)
16:21:25 <aepe> The code is at the top and ghci's output at the bottom
16:21:51 <aepe> After I evaluate a function in ghci, it changes type o.O
16:22:01 <aepe> What's going on here?
16:22:27 <monochrom> ghci uses the name "it" for its own purpose, namely, "the most recent answer"
16:22:56 <c_wraith> hmm.  when profiling, which direction is drag again?  Time between allocation and first use, or time between last use and GC?
16:22:58 <monochrom> of course, initially, there was no most recent answer, so there was no "it" other than yours
16:23:11 <monochrom> afterwards, you get shadowing!
16:23:24 <monochrom> so, just name your function something else
16:23:27 <mm_freak> uh, that's good to know
16:24:04 <aepe> Ah, that makes sense
16:24:30 <aepe> What other ghci specific features are there?
16:24:53 <c_wraith> extended type defaulting
16:25:01 <c_wraith> ghci will default a lot more types than ghc will.
16:25:35 <mm_freak> also it will ignore your .cabal file, so if you have clashing module names, you will get errors where cabal compiles it fine
16:28:28 <Sgeo|web> I guess I should be using hlint a lot?
16:28:35 <Sgeo|web> Do experienced Haskellers use hlint?
16:28:42 <blackdog> Sgeo|web: hell to the yes.
16:29:04 <blackdog> ghc-mod is nice if you're using emacs - it'll run it automatically.
16:29:54 <mm_freak> i'm not using it — shame on me…  but yes, you should
16:30:36 <Sgeo|web> It only had 2 suggestions for my junky code, wow
16:31:19 <ddarius> Sgeo|web: Maybe you caused it to blow a fuse.
16:31:58 <dgpratt> the last time I used it, it only gave me one suggestion: give up!
16:34:50 <monochrom> I don't use hlint
16:37:28 <ddarius> monochrom: You probably shouldn't use hlint.
16:39:33 <DanBurton> why not use hlint when it is just a cabal install away? :P
16:41:02 <monochrom> in protest of its religion of camel case
16:42:59 <monochrom> and I disagree with 50% of its other warnings
16:43:50 <mm_freak> monochrom: what do you use?
16:43:58 <monochrom> myself
16:43:59 <copumpkin> his head
16:44:27 <mm_freak> monochrom: i mean what name style do you use?
16:45:26 <monochrom> germanstyle if not too bad, else space if supported, else ' if supported, else _ if supported, else I murder the language
16:45:29 <ddarius> mono'chrom
16:46:38 <Sgeo|web> People use things other than camelCase with Haskell?
16:46:54 <mm_freak> never thought about using a different style
16:47:02 <monochrom> but I take comfort in the fact that if I wrote "programmiensprachen" hlint wouldn't be able to suggest "why not programmienSprachen"
16:47:06 <mm_freak> just find underscores extremely ugly
16:47:41 <Sgeo|web> There exists a language that strips _ from identifiers and is case-insensitive, so myVar and my_var are the same
16:47:41 <mm_freak> germanstyle doesn't support the editor too well
16:48:53 <sdf12> In some text editors, emacs for example, you can do glasses mode. That will allow you to transparently switch between camel case and underscores. I've always thought that kind of rendering should be an editor preference anyhow.
16:49:04 <dafis> monochrom: it should, however, suggest programmiersprachen
16:50:16 <dolio> Dashes are the best, but not many languages support them.
16:50:32 <monochrom> yes, I forgot -
16:50:33 <Sgeo|web> "Case is insignificant in Nimrod and even underscores are ignored: This_is_an_identifier and ThisIsAnIdentifier are the same identifier. This feature enables you to use other people's code without bothering about a naming convention that conflicts with yours. It also frees you from remembering the exact spelling of an identifier (was it parseURL or parseUrl or parse_URL?)."
16:50:39 <Sgeo|web> http://www.force7.de/nimrod/tut1.html
16:53:14 <applicative> > let m_A_p = map ; e_VEN =even in m_A_p e_VEN [2,3,4]
16:53:15 <lambdabot>   [True,False,True]
16:53:37 * applicative is feeling the Nimrod 'freedom'
16:54:58 <ybit> http://www.youtube.com/watch?v=ryxIy6ioJVw
16:55:08 <ybit> starting to create some tutorials for haskell
16:55:30 <monochrom> "this video is private"
16:55:47 <mm_freak> ab	who?
16:55:48 <applicative> youtube dixit:  This video is private. Sorry about that.
16:55:52 <mm_freak> ybit: who?
16:56:07 <ybit> me
16:56:35 <ybit> probably good for the smart 13-16yr olds
16:56:40 * hackagebot arithmoi 0.2.0.1 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.2.0.1 (DanielFischer)
16:56:42 <ybit> ..when they are done
16:58:48 <copumpkin> oh, dafis is daniel fischer
16:59:02 <mm_freak> ybit: i remember you asking why purity is a good feature…  i'm not really sure you are ready to teach haskell
16:59:16 <ybit> mm_freak: i'm never ready
16:59:24 <ybit> this is me learning
16:59:28 <mm_freak> don't take it personally, but there are a lot of tutorials, which teach how to write bad code in haskell
17:00:02 <ybit> not taking it personally, i often start stuff that shouldn't be started, so i'm used to it :)
17:00:05 <Sgeo|web> Even in imperative languages, it makes sense to write pure functions, they're more reusable
17:01:55 <copumpkin> even gcc has an attribute for marking pure functions
17:03:29 <kmc> Haskell is an imperative language
17:03:46 <kmc> and yes, pure functions are useful when doing imperative programming in Haskell
17:04:15 <ybit> take it up with wikipedia
17:04:45 <kmc> i second the suggestion against learning haskell by teaching it
17:05:22 <ybit> aww
17:05:24 <Cale> Make tutorial, keep hidden from everyone, return to tutorial in 2 years, laugh at self, repeat.
17:05:33 <ybit> i thought about that
17:05:46 <sdf12> Cale: My strategy exactly for learning new stuff.
17:06:41 <monochrom> I support learning by teaching. but don't teach other people. get some hello kitties, teddy bears, and winnie the poohs. teach them.
17:07:01 <monochrom> oh, how could I forget kerokeroppi!?
17:07:13 <sdf12> ybit: Though it's been said that you need expert feedback to progress rapidly, so maybe show them to someone who can give you good feedback.
17:07:31 <ybit> #haskell maybe?
17:07:45 <monochrom> anyway, that's what I did when I was a kid. I took my mother's teacher handbook (she's a teacher) and started teaching...
17:08:17 <luite> I bet your hello kitties are really smart now
17:08:25 <sdf12> ybit: Seems like a winning strategy.
17:09:24 <ybit> umkay, have some hw to work on
17:09:36 <Cale> Yeah, helping people here is usually a good way to refine your strategy for teaching things.
17:09:55 <mm_freak> i agree, particularly you have other people to correct you
17:10:37 <mm_freak> even with about five years of haskell experience, ddarius still invalidates all my answers constantly =P
17:12:09 <ddarius> Teaching tends to be a good way to get better at teaching.
17:12:53 <monochrom> I have a donkey. A freebie from one year's ACM programming contest. He has a label that says...
17:12:53 <kmc> i think writing out an explanation of something and showing it to a few people here is a decent strategy
17:13:00 <kmc> ah, as sdf12 said
17:13:03 <monochrom> "It's all Greek to me"
17:13:13 <kmc> just don't be surprised if the answer is "you are completely confused, go read this and this"
17:13:35 <monochrom> I still can't get him to understand basic haskell. it's all greek to him. he also looks sleepy.
17:14:00 <kmc> this will help you know if you actually understand something, versus having some heuristic ability to work around your lack of understanding
17:14:09 <shachaf> BASIC Haskell? As in augustss's thing? :-)
17:14:15 <monochrom> hahaha
17:15:37 <rhyceu> Hi, I am just learning Haskell and I have come across something I don't *quite* understand yet
17:15:45 <mrsolo>  haskell is difficult :-<
17:16:07 <rhyceu> the "Just" function -- is it just used for when you want to wrap a type/function/whatever in a function?
17:16:15 <kmc> no
17:16:26 <kmc> it's defined as part of Maybe
17:16:31 <rhyceu> right, I saw that
17:16:33 <kmc> Maybe is a simple example of an algebraic data type
17:16:34 <kmc> @src Maybe
17:16:35 <lambdabot> data Maybe a = Nothing | Just a
17:16:53 <kmc> Just is a data constructor, which makes it special compared to an ordinary function
17:16:54 <monochrom> no, wrapping is not its purpose
17:16:58 <ybit> kmc: writing about haskell didn't seem like a good idea since there are already decent resources available
17:17:01 <kmc> because you can pattern-match on it
17:17:30 <rhyceu> ...and it allows it to be multi-valued, ie, nothing
17:17:31 <monochrom> its purpose is more like to have two possibilities: no answer; has answer, it is _____
17:17:36 <ybit> also, i want videos to watch while i'm chowing on pizza and lasagna
17:17:56 <kmc> (Maybe T) is a type which is like T except with an extra "Nothing" value
17:18:12 <kmc> but the way Haskell works, you need to wrap the non-Nothing values, to say that they're of type Maybe T
17:18:17 <kmc> and that wrapper is named Just
17:18:25 <monochrom> I suggest Italian operas for your pizza and lasagna sessions. I like lasagna too.
17:18:40 <copumpkin> yes!
17:18:44 <sdf12> ybit: If you're just looking to improve, I think it will be easier for experts to quickly read an explanation you've written as opposed to watching a video. This way they can correct your thinking faster.
17:18:48 * dafis likes lasagna, but not opera
17:18:56 <copumpkin> nothing better with a slice of pizza than tosca
17:19:15 <rhyceu> kmc, ok: I was looking through some examples where they do something like [Just 1, Just 2, Just 3, Nothing]
17:19:22 <kmc> *nod*
17:19:31 <advall> ping saadam
17:19:44 <rhyceu> to me
17:20:18 * rhyceu is getting the exact example
17:21:23 <rhyceu> let d1 = [Just 5, Nothing, Nothing, Just 8, Just 9]::[Maybe Int] \n putStrLn (show d1)
17:21:34 <ybit> umkay, general vibe is fsck no ybit, get back to work, read! read! read! so i guess that's what i'll do
17:21:51 <monochrom> [Just 1, Just 2, Just 3, Nothing] combines the list type with the Maybe type. it may be a tall order at the moment.
17:22:14 <sdf12> ybit: I'd add to that: write! write! write! (code that is)
17:22:17 <rhyceu> So my question is this:
17:22:21 <kmc> ybit, I think writing down your understanding and showing it to people here is a fine way to learn
17:22:42 <kmc> just don't expect what you write to be widely useful
17:22:59 <rhyceu> is it written that way to give it a homogeneous type so that it can function as a list?
17:23:06 <kmc> yeah
17:23:22 <advall> fuck saadam!!
17:23:26 <advall> bää
17:23:46 <rhyceu> because, without the nothing's, it "shows" just fine
17:23:57 <rhyceu> ie, let a = [1,2,3] \b show a
17:23:57 <kmc> it should either way
17:24:10 <kmc> right that has type [Int]
17:24:23 <kmc> but you can't have Nothing as an element in [Int]
17:24:35 <rhyceu> right, because it's Maybe a
17:24:38 <kmc> you can have Nothing as an element in [Maybe Int], but now you can't have 3, you must write (Just 3)
17:24:40 <kmc> *nod*
17:25:18 <rhyceu> this is sorta what I meant about "wrapping" types
17:25:33 <rhyceu> it just seemed to me that it allows you to wrap a type to make it uniform
17:25:45 <kmc> Int is already plenty uniform
17:26:03 <kmc> Maybe Int is *less* uniform, in a sense
17:26:07 <rhyceu> right, but if you wanted to have empty places in the list....
17:26:08 <kmc> I think you understand how Maybe and Just work
17:26:17 <dafis> rhyceu: as an example, let zero low high f be a function that finds a zero of the function f in the interval [low,high], then some functions don't have a zero in that interval, indicated by a return value of Nothing, othershave one, the result is then (Just zero)
17:26:30 <kmc> rhyceu, they aren't really empty places
17:26:36 <kmc> i mean Nothing is a value like any other
17:26:44 <mm_freak> rhyceu: [Maybe a] seems to be a reasonable way to have a list with holes
17:26:46 <kmc> and Maybe is just a simple example of algebraic data
17:26:58 <kmc> there's a whole world of fancy things you can do with algebraic data
17:27:05 <kmc> and you can store any of those types in a list
17:27:11 <kmc> in fact the list itself is algebraic data
17:27:19 <kmc> setting aside Haskell's special syntax for lists, you have
17:27:21 <mm_freak> rhyceu: but those aren't exactly "holes" per se as there /are/ values, but you can distinguish having a value and not having a value at a certain spot
17:27:23 <kmc> data List a = Nil | Cons a (List a)
17:27:26 <rhyceu> right, it could be data Whatever a = Nothing | Just a
17:27:46 <kmc> anyway I think you understand the mechanics of Maybe and Just
17:28:03 <rhyceu> so the usage of "Nothing" is just idomatic then, yes?
17:28:06 <Volis> Did anyone see the IEEE coding challenge?
17:28:10 <kmc> rhyceu, what do you mean?
17:28:22 <Cale> Well, the name Nothing is just a name
17:28:26 <mm_freak> rhyceu: Nothing is a predefined constructor of the predefined Maybe type
17:28:44 <rhyceu> say, null in java has special meaning. Nothing is arbirary, but thought of in the same way?
17:28:50 <Cale> yeah
17:28:58 <mm_freak> other languages use Option instead of Maybe, Some instead of Just and None instead of Nothing…  nothing special here
17:29:02 <Cale> It's not built-in to the language, but it's part of the standard library
17:29:14 <kmc> the main difference is that 'null' is a member of *every* type in Java, and so it creeps in where you don't expect it
17:29:15 <rhyceu> like, if I had a function that returned "null" -- idomatically we would expect it to be Nothing in haskell
17:29:23 <kmc> rhyceu, yes, most likely
17:29:27 <rhyceu> ok cool
17:29:29 <kmc> of course Java designs don't translate to Haskell designs 1:1
17:29:36 <mm_freak> rhyceu: null is conceptually different from Nothing, because Nothing belongs to a certain type
17:29:40 <Volis> Here's the question, http://pastebin.com/un0Y7x0P
17:29:42 <mauke> The paste un0Y7x0P has been copied to http://hpaste.org/52946
17:29:54 <rhyceu> you guys are really helpful; I really appreciate it!
17:29:56 <kmc> the thing about Maybe is that it forces you to consider the Nothing case when you want to get at the data inside
17:29:58 <kmc> (to some degree)
17:30:10 <kmc> the other thing about it is that it's a library definition and not builtin
17:30:16 <kmc> so you can build more complicated things that work similarly
17:30:29 <rhyceu> I mean, it's good to be able to talk to some knowledgeable folks about this ;)
17:30:31 <mm_freak> null creeps the hell out of me in every language
17:30:41 <rhyceu> ok, so one more question and I'll get out of your hair
17:30:47 <rhyceu> Function composition
17:30:55 <mm_freak> rhyceu: no worries =)
17:31:27 <rhyceu> doSomething = (reverse . sort) is the same as (\x -> reverse(sort x)) yes?
17:31:33 <monochrom> yes
17:31:52 <mm_freak> without language extensions, yes
17:31:55 <rhyceu> the manner in which "x" is pipelined into the function seems somewhat magical to me
17:32:00 <rhyceu> what is oging on there?
17:32:05 <rhyceu> and why isn't it:
17:32:06 <dmwit> Let's demagic it!
17:32:09 <shachaf> rhyceu: It's just defined to be exactly that.
17:32:15 <mm_freak> rhyceu: (f . g) = \x -> f (g x)
17:32:17 <mercury^> (.) f g x = f(g(x))
17:32:20 <shachaf> (.) f g = \x -> f (g x)
17:32:27 <rhyceu> doSomething x = (reverse . sort (x))
17:32:35 <mm_freak> rhyceu: (x) = x
17:32:44 <shachaf> rhyceu: No, that's not it. doSomething x = (reverse . sort) x
17:32:45 <monochrom> if you want, that's doSomething = reverse (sort x)
17:32:46 <rhyceu> mm_freak, ok
17:32:49 <dmwit> doSomething = reverse . sort = (.) reverse sort = (\f g x -> f (g x)) reverse sort = \x -> reverse (sort x)
17:32:59 <monochrom> sorry, doSomething x = reverse (sort x)
17:33:14 <mm_freak> rhyceu: haskell has no visible operator for application, which can be confusing for someone coming from a C-like language where you would write f(x)
17:33:20 <mm_freak> rhyceu: in haskell you write just f x
17:33:27 <kmc> hey Cale, does nymphaea work on recent GHC?
17:33:31 <kmc> it wants base ≤ 4.1
17:33:39 <Cale> kmc: I haven't tried it in a very long time
17:33:51 <kmc> i'm a little surprised not to find a L-systems library
17:34:15 <mrsolo> rhyceu, i higly recommend 'learn you a haskell for great good' book.. it has clearer explanation for lots of stuffs :-)
17:34:15 <Cale> I'm a bit surprised it even says base <= 4.1, I don't remember doing that
17:34:17 <monochrom> L-systems are hard to use
17:34:21 <rhyceu> so why are doSomething x = (reverse . sort) x and doSomething = (reverse . sort) the same?
17:34:25 <copumpkin> @let zomg = fix . (>=>)
17:34:26 <lambdabot>  Defined.
17:34:31 <copumpkin> :t zomg
17:34:32 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
17:34:42 <rhyceu> mrsolo -- I'm working my way through RWH and LYH at the same time, cross referencing
17:34:53 <monochrom> because "f x = g x" and "f = g" are the same
17:34:59 <dmwit> rhyceu: Why would they be different?
17:35:00 <Cale> rhyceu: Because that's what it means for two functions to be equal
17:35:01 <mrsolo> rhyceu, i think LYH is better
17:35:06 <mrsolo> RWH has lots of errors
17:35:11 <Sgeo|web> (reverse . sort) is a function that sorts and argument then reverses it
17:35:17 <mrsolo> simple errors that trip newbies
17:35:21 <Cale> Two functions are equal if when applied to the same value, they give the same results
17:35:22 <mm_freak> rhyceu: remember equations from school?  the "=" operator really defines an equation…  you are performing "apply x to both sides"
17:35:29 <rhyceu> monochrom: head just exploded
17:35:31 <mm_freak> f = f implies f x = f x
17:35:36 <Sgeo|web> doSomething x = (reverse . sort) x takes the (reverse . sort) function and applies it to x, when given an x
17:35:54 <Sgeo|web> THat's equiv. to saying that doSomething is the same as reverse . sort
17:35:57 <rhyceu> I get that, from a math perspective it just seems so implicit
17:36:00 <monochrom> head explosion is good
17:36:17 <mercury^> Is there another name for vertical composition, i.e. ((. fmap).(.))?
17:36:24 <mm_freak> rhyceu: in haskell many of the mathematical principles hold
17:37:16 <mm_freak> rhyceu: f x = y is really a nicer way to say:  f = \x -> y
17:37:28 <mm_freak> now just evaluate the (.) part on paper
17:37:38 <rhyceu> mm_freak -- AH that's what I was looking for
17:37:44 <mm_freak> f . g = \x -> f (g x)
17:37:50 <Sgeo|web> Doesn't RWH still say to download GHC directly?
17:37:56 <mm_freak> doSomething = f . g = \x -> f (g x)
17:38:04 <mercury^> Hmm, in Cale's Haskell that would look like ((.(.)).(.))
17:38:23 <mm_freak> so doSomething x = f (g x), because doSomething = \x -> f (g x)
17:38:46 <rhyceu> mm_freak: does the syntax support two arguments?
17:39:07 <monochrom> \x y -> x + x * y
17:39:12 <mercury^> @pl ((.(.)).(.))
17:39:12 <lambdabot> (. (.)) . (.)
17:39:18 <rhyceu> omg
17:39:30 <mm_freak> rhyceu: on its surface yes
17:39:30 <monochrom> shorthand for \x -> \y -> x + x * y
17:39:35 <mm_freak> f x y = …
17:39:45 <mm_freak> f = \x y -> …
17:40:12 <Sgeo|web> And \x y -> is the same as \x -> \y ->
17:40:29 <mm_freak> yes, but that needs explanation
17:40:55 <mm_freak> rhyceu: all functions in haskell accept only a single argument, but you are allowed to write a function, which returns another function
17:41:04 <mm_freak> \x -> (\y -> x + y)
17:41:05 <rhyceu> currying, yes?
17:41:10 <Sgeo|web> Yes
17:41:11 <mm_freak> yes, that's currying at work
17:41:26 <Cale> hey! you could at least replace some of those with map :)
17:41:56 <mm_freak> rhyceu: it's useful to remember that application is left-associative:  f x y = (f x) y
17:41:59 <rhyceu> haha, it's starting to make sense... I guess that's reflected in the type system... eg: why you write Int -> Int -> Bool etc
17:42:14 <mm_freak> yes, the -> operator is right-associative
17:42:19 <Cale> Yeah, Int -> Int -> Bool means Int -> (Int -> Bool)
17:42:20 <mm_freak> a -> b -> c = a -> (b -> c)
17:42:28 <Cale> and f x y means (f x) y
17:42:33 * cocaine clogs your nostrils
17:42:50 <rhyceu> snap
17:43:00 <mm_freak> :t (+)
17:43:01 <lambdabot> forall a. (Num a) => a -> a -> a
17:43:04 <mm_freak> :t (+) 3
17:43:05 <lambdabot> forall t. (Num t) => t -> t
17:43:10 <mm_freak> :t ((+) 3) 5
17:43:11 <lambdabot> forall t. (Num t) => t
17:43:15 <Sgeo|web> It's still not entirely intuitive to me (but I'm semi-beginner)
17:43:45 <rhyceu> so basically, composition is enabled solely because all haskell functions take one argument
17:43:50 <Sgeo|web> I had to think for a bit, after understanding that fix can pass a function to itself, how to use that sensibly
17:44:03 <Sgeo|web> That I wouldn't have to write, say, fix (\fact -> \x -> whatever)
17:44:11 <mm_freak> rhyceu: you can hack together composition in non-curried languages, but it's much uglier
17:44:20 <mm_freak> and less well defined
17:44:24 <Cale> rhyceu: Well, that makes it reasonable to compose more functions than would otherwise be possible
17:44:46 <mm_freak> in haskell you can tell exactly what f . g means
17:44:54 <Cale> If map took a pair instead of being curried, you couldn't write things like  map head . group . sort
17:45:00 <rhyceu> Would someome mind showing me an example of a function composition with two arguments? like, how would I write \x -> \y -> x + x * y in composition notation?
17:45:10 <Cale> > map head . group . sort $ "mississippi"
17:45:12 <lambdabot>   "imps"
17:45:20 <kmc> @pl \x -> \y -> x + x * y
17:45:21 <lambdabot> liftM2 (.) (+) (*)
17:45:28 <kmc> ooh that's... surprisingly nice
17:45:29 <Cale> keke
17:45:29 <mm_freak> rhyceu: ideally you wouldn't
17:45:42 <rhyceu> mm_freak: why?
17:45:50 <mm_freak> function composition with multiple arguements tends to make your code harder to read
17:45:55 <Cale> Usually things which repeat a function parameter don't turn out so nice, but that one works out kinda
17:45:57 <mercury^> > (.) <$> (+) <*> (*) 3 4
17:45:58 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> f b)
17:45:58 <lambdabot>    arising from a use of...
17:45:58 <shachaf> kmc: "nice" as in "I'd want to see that in a piece of code I'm reading"?
17:46:00 <cocaine> kekekekekekeke oooooooooooOOOOOOOOOOOOOOOOOOOO
17:46:17 --- mode: ChanServ set +o copumpkin
17:46:21 --- kick: cocaine was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
17:46:25 --- mode: copumpkin set -o copumpkin
17:46:26 <mercury^> > (.) <$> (+) <*> (*) $ 3 4
17:46:26 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:46:27 <lambdabot>    arising from a use of `...
17:46:35 <mercury^> > (.) <$> (+) <*> (*) $ 3 $ 4
17:46:36 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
17:46:37 <lambdabot>    arising from a use of `...
17:46:40 <mercury^> :(
17:46:45 <mm_freak> rhyceu: some haskell tutorials suggest that point-free style is the ultimate perfect style, which is not true
17:46:50 <Cale> mercury^: FOILED BY THE INCORRECT ASSOCIATIVITY OF $
17:46:57 <kmc> mm_freak, do they really?
17:47:07 <shachaf> Cale: The first time that's ever happened in this channel!
17:47:17 <rhyceu> mm_freak: as a beginner I admit it is very strange
17:47:19 <Cale> > ((.) <$> (+) <*> (*)) 3 4
17:47:21 <lambdabot>   15
17:47:24 <rhyceu> because it seems to swallow up the arguments
17:47:25 <sdf12> mm_freak: Would those happen to be written by APL fans?
17:47:29 <mm_freak> kmc: well, i found myself being mislead in the beginning
17:47:34 <mm_freak> sdf12: possibly =)
17:47:42 <Clint> @unpl liftM2 (.) (+) (*)
17:47:42 <lambdabot> ((+) >>= \ b -> (*) >>= \ a -> return (\ h -> b (a h)))
17:47:59 <Cale> rhyceu: Mainly, I say focus first on trying to write things in terms of composition (.) and then see where you can make things points-free later.
17:48:11 <mm_freak> rhyceu: it's not strange at all, as long as you really define linear data flow:  f = g . h . i
17:48:12 <Cale> If you get used to chaining things in the form  f . g . h $ x
17:48:43 <Cale> then it becomes more natural to remove the "$ x" at the end sometimes :)
17:48:44 <shachaf> > let f = g . h . i in f . g . h $ x
17:48:44 <lambdabot>   Couldn't match expected type `f a'
17:48:45 <lambdabot>         against inferred type `SimpleRef...
17:48:58 <coppro> how do you search for functions matching a type?
17:49:06 <shachaf> coppro: Hoogle.
17:49:09 <Cale> @hoogle Char -> Int
17:49:10 <lambdabot> Data.Char digitToInt :: Char -> Int
17:49:10 <lambdabot> Data.Char ord :: Char -> Int
17:49:10 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
17:49:40 <coppro> @hoogle Monad m => m a -> m b -> m a
17:49:41 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
17:49:41 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
17:49:41 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
17:49:46 <coppro> ...
17:49:53 <coppro> that's not what I want :/
17:49:54 <mm_freak> coppro: looking for (<*)?
17:49:57 <dafis> rhyceu: I think everybody should play around with point-freeing moderately early to get a feel for it and why not to overuse it, but that it can also make things clearer sometimes
17:50:07 <mm_freak> coppro: it's in Control.Applicative
17:50:09 <Sgeo|web> coppro: try the Hoogle website?
17:50:10 <shachaf> @hoogle Applicative m => m a -> m b -> m a
17:50:10 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
17:50:10 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
17:50:11 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:50:14 <coppro> mm_freak: thanks
17:50:20 <Sgeo|web> Oh
17:50:51 <rhyceu> Cale: I feel like an idiot asking this question, but what is the difference between these?
17:51:00 <rhyceu> show $ show "a"
17:51:02 <rhyceu> and
17:51:15 <mm_freak> coppro: unfortunate case…  hoogle can't find that one, becase Applicative is not a superclass of Monad
17:51:27 <mm_freak> should be, but isn't =/
17:51:31 <rhyceu> show . show $ show "a"
17:51:39 <coppro> ah, right
17:51:41 <copumpkin> > fix show
17:51:42 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:51:44 <Cale> one of them applies show one more time than the other
17:51:48 <coppro> I'm surprised there isn't a (<<)
17:51:50 <Cale> so, it'll be quoted once more
17:51:58 <rhyceu> show . show "a" <-- not valid
17:52:03 <Cale> show . show $ "a"
17:52:09 <Cale> or  (show . show) "a"
17:52:13 <mm_freak> coppro: (<<) would probably be flip (>>), which is not the same as (<*)
17:52:27 <Cale> show . show "a" parses as  show . (show "a")
17:52:36 <Cale> because function application binds more tightly than any infix operator
17:52:37 <shachaf> mm_freak: I'd expect << to be <* for the same reason <* isn't flip >*. :-)
17:52:44 <Cale> but show "a" is a string
17:52:50 <Cale> so, that becomes a type error
17:52:55 <mm_freak> shachaf: it would be unintuitive, because you also have (=<<)
17:53:07 <Cale> $ is function application, but with really low precedence
17:53:12 <copumpkin> well, with (<<) there are two options of what to do, whereas =<< can only do one thing
17:53:17 <dmwit> > iterate show "a"
17:53:18 <lambdabot>   ["a","\"a\"","\"\\\"a\\\"\"","\"\\\"\\\\\\\"a\\\\\\\"\\\"\"","\"\\\"\\\\\\\...
17:53:19 <copumpkin> this is why we need indexed monads
17:53:21 <coppro> makes sense I suppose
17:53:23 <shachaf> mm_freak: That doesn't work the same way?
17:53:23 <Cale> So you can use it to apply a chain of composed functions to a value
17:53:24 <copumpkin> so the type tells you which you're getting
17:53:27 <Sgeo|web> indexed monads?
17:53:36 <mm_freak> shachaf: (=<<) = flip (>>=)
17:53:48 <mm_freak> i'd find it confusing, if (<<) where not flip (>>)
17:53:53 <mm_freak> s/where/were/
17:54:11 <shachaf> Oh. Hmm.
17:54:39 <rhyceu> Cale: (show . show) "a" makes sense to me, for some reason show . show $ "a" is a little bizzare... Ah! I think I get it
17:55:00 <rhyceu> Cale: so $ forces "a" to be applied last, after the composition
17:55:07 <mm_freak> rhyceu: f $ x = f x
17:55:07 <Cale> $ is just defined in the Prelude like  f $ x = f x
17:55:24 <copumpkin> Sgeo|web: return :: a -> m i i a; (>>=) :: m i j a -> (a -> m j k b) -> m i k b
17:55:26 <mm_freak> rhyceu: it just lets you leave out the parentheses, because ($) has a very low priority
17:55:40 <wavewave> hi~
17:55:40 <Cale> But the precedence is set really low (so that it happens last)
17:55:53 <mm_freak> f . g . h $ x = (f . g . h) x
17:55:53 <rhyceu> whereas, without, we are left with: show . (show "a") which is wrong
17:55:59 <Cale> "happens" as far as parens go, not really with regard to evaluation order :)
17:56:06 * dmwit waves at wavewave
17:56:18 <Cale> yeah
17:56:18 <rhyceu> oh man, this is all really helpful
17:56:31 <mm_freak> with (f . g . h x) you would get:  f . g . (h x), so you would compose (f . g) and whatever the result of h x is
17:56:32 <rhyceu> I'm really glad this resource exists haha
17:56:34 <wavewave> copumpkin: it looks like arrow in a sense?
17:57:16 * wavewave waves dmwit
17:57:33 * wavewave waves at dmwit with a full wave
17:57:53 <rhyceu> ok, I'm going to go bury my head in some more RWH/LYH for a bit... Thanks a lot guys, this has been very helpful!
17:58:06 <rhyceu> I'm sure I'll be back ;)
17:58:18 <parcs> is there an implementation of indexed monads on hackage anywhere? i can only find one in edwardk's obsolete category-extras package
17:58:34 <mm_freak> parcs: obsolete?
17:58:34 <dmwit> Isn't it called rmonad?
17:58:40 <mm_freak> scary, yes, but obsolete?
17:58:50 <dylukes> category-extras is obsoleted.
17:58:54 <dylukes> He split it up.
17:59:04 <parcs> 21:07:41         wavewave | copumpkin: it looks like arrow in a sense?
17:59:07 <mm_freak> dmwit: no, that's something different…  RMonad uses ConstraintKinds to allow constraints on the argument type
17:59:08 <parcs> oops
17:59:12 <parcs> http://hackage.haskell.org/package/category-extras-0.53.5
17:59:26 <mm_freak> dmwit: like:  (>>=) :: Num a => m a -> (a -> m b) -> m b
17:59:41 <mm_freak> dylukes: good to know
18:00:12 <mm_freak> dmwit: RMonad finally makes Set a monad =)
18:00:54 <shachaf> mm_freak: No it doesn't.
18:00:57 <shachaf> It makes it an RMonad.
18:01:01 <dylukes> Can't we use constraint kinds for this?
18:01:03 * shachaf regards RMonads with suspicion.
18:01:12 <mm_freak> dylukes: RMonad does exactly that
18:01:22 <wavewave> dylukes: yes.
18:01:26 <mm_freak> shachaf: not sure if they are real monads in the categorical sense
18:02:39 <mm_freak> probably you would have to restrict the Hask category for that
18:03:40 <shachaf> mm_freak: Well, depending on the constraint of the RMonad, fmap etc. could do arbitrary operations on the values.
18:03:42 <wavewave> http://dorchard.wordpress.com/2011/10/18/subcategories-in-haskell-exofunctors
18:04:39 <wavewave> this makes haskell functor make sense more.
18:05:51 <Sgeo|web> Suppose I want to express what would typically be a top-level definition as an expression
18:06:05 <Sgeo|web> I know I can do pattern matching with case and have it still look somewhat acceptable
18:06:07 <Sgeo|web> What about guards?
18:06:24 <mm_freak> Sgeo|web: you can use guards wherever you can use patterns
18:06:27 <Sgeo|web> if/then/else chain?
18:06:32 <Sgeo|web> Wait, what?
18:06:37 <wavewave> ?
18:06:46 <mm_freak> > (\x | even x -> x^2) 6
18:06:47 <lambdabot>   <no location info>: parse error on input `|'
18:06:52 <mm_freak> ok, almost everywhere
18:07:04 <mm_freak> uhm
18:07:22 <Sgeo|web> I think an if/then/else chain would be indented ugily
18:07:27 <Sgeo|web> uglyly
18:07:30 <Sgeo|web> ugily
18:07:57 <mm_freak> Sgeo|web: perhaps Maybe with 'guard'?
18:08:23 <wavewave> Sgeo|web : I don't understand your question. What do you want with guard?
18:08:33 <mm_freak> do x <- firstComp; guard (even x); y <- secondComp x; guard (odd y); return (x + y)
18:08:34 <Cale> Sgeo|web: the key to indenting if/then/else is to make sure that then and else line up
18:08:51 <dafis> case x of { y | cond1 -> e1; | cond2 -> e2; |cond3 ... }
18:09:17 <Cale> Yeah, you can do:  case () of _ | guard1 -> ... | guard2 -> ...
18:09:35 <Cale> Whenever you'd otherwise have multiple nested if/then/else's
18:10:08 <blackdog> Cale: ha, that's a neat trick
18:10:13 <looopy> somebody should start from scratch and make a scala only IDE that feels as good as xcode4 o_O;
18:10:14 <mm_freak> or use ContT with callCC =)
18:10:35 <Cale> looopy: What, no Haskell support?
18:10:39 <blackdog> looopy: you like the xcode user experience??
18:10:42 <looopy> whoa my bad
18:10:42 <looopy> =P
18:10:49 <looopy> wrong room but yes
18:10:53 <Cale> Of course, most Haskell users would never use an IDE anyway :P
18:11:05 <looopy> lol emacs
18:11:11 <blackdog> Cale: what do you mean? emacs is unimaginable luxury!
18:11:25 <Cale> blackdog: vim + ghci + terminals!
18:11:28 <looopy> equally nice..equally nice.  i'm just having a 'praise apple' moment..most likely a subliminal message sent through the screen.
18:11:59 <wavewave> code browsing is quite painful in current haskell setup.. I hope some better support in haddock.
18:11:59 <Cale> Actually, what little I've used of XCode, I've really hated its UI
18:12:09 <looopy> i prefer vim but i'll admit the syntax highlighting seemed better on emacs....though it may just be my color scheme
18:12:31 <Cale> There are tiny 16x16 buttons with indecipherable little icons on them that hide crucial parts of the interface
18:12:31 <looopy> Cale: really? it's kind of great...just little subtle things
18:12:39 <rhyceu> I've been using ideah and text mate
18:12:53 <Sgeo|web> > (\x -> case () of | (x > 5) -> 10; otherwise -> 0 } 3
18:12:54 <lambdabot>   <no location info>: parse error on input `|'
18:13:01 <blackdog> looopy: my big beef with it is that it conflates project config etc with the IDE
18:13:15 <Sgeo|web> > (\x -> case () of _ | (x > 5) -> 10; _ | otherwise -> 0 } 3
18:13:16 <lambdabot>   <no location info>: parse error on input `}'
18:13:27 <Sgeo|web> > (\x -> case () of { _ | (x > 5) -> 10; _ | otherwise -> 0 } 3
18:13:27 <lambdabot>   <no location info>: parse error on input `3'
18:13:32 <blackdog> if i have a cabal change, it's easy to see in git logs - all that's hidden away in XML in xcode
18:13:34 <Sgeo|web> > (\x -> case () of { _ | (x > 5) -> 10; _ | otherwise -> 0 }) 3
18:13:35 <lambdabot>   0
18:13:42 <wavewave> yeah..
18:13:42 <Cale> and one of the most important things for me, the interface to add signatures to a mobile device is hidden away inside the "Organizer" which is under the "Window" menu, usually reserved for managing the open windows of the program!
18:13:43 <Sgeo|web> > (\x -> case () of { _ | (x > 5) -> 10; _ | otherwise -> 0 }) 10
18:13:44 <lambdabot>   10
18:13:52 <Cale> Try guessing that :)
18:14:06 <looopy> blackdog: ahh i can see that.  but for iphone dev...you're really not meant to leave. in that case it's nice.  but yeah i can definitely agree that it's a 'niche' IDE
18:14:17 <looopy> a very small niche...but still pleasant
18:14:36 <wavewave> I need siri for haskell emacs IDE
18:14:50 <blackdog> looopy: the problem is that if you're collaborating with other people, if you've both changed configuration details and try to merge, you generally end up with a horrible mess.
18:14:52 <wavewave> just speak types and find the function.
18:15:04 <Cale> Organizer itself has a somewhat ironic name given that it seems to be a bag of miscellaneous stuff that Apple couldn't be bothered finding better places for :P
18:15:11 <looopy> blackdog: even  with xcode 4 and using git?
18:15:12 <Sgeo|web> @djinn (a -> a) -> a
18:15:12 <lambdabot> -- f cannot be realized.
18:15:24 <wavewave> or speak "show me the code"
18:15:25 <blackdog> looopy: yep
18:15:30 <looopy> <- lone wolf
18:15:33 <looopy> hmm good to know...
18:15:39 <Sgeo|web> @djinn a -> b -> a
18:15:39 <lambdabot> f a _ = a
18:15:53 <blackdog> admittedly i was only tangentially connected with the iOS code, but being "the git guy" i'd usually get called over to untangle the mess
18:16:07 <looopy> lol
18:16:08 <blackdog> i think a lot of iOS guys are lone wolves
18:16:51 <Cale> There was a point in the 1980s when Apple's UI design was based on real thinking about how to make things usable, but lately they've been doing some mix of cargo culting old stuff without really considering if the rationale which made it good still applies, and making stuff that looks shiny but doesn't work very effectively.
18:17:01 <BMeph> > (\x -> case () of { _ | (x > 5) -> 10; | otherwise -> 0 }) 10
18:17:02 <lambdabot>   <no location info>: parse error on input `|'
18:17:20 <looopy> yeah, hobbyists
18:17:22 <BMeph> > (\x -> case () of { _ | (x > 5) -> 10 | otherwise -> 0 }) 10
18:17:23 <lambdabot>   10
18:17:23 <rhyceu> Cale: That said, I do think Lion represents a step in the right direction… It's much more minimal
18:17:32 <blackdog> Cale: you talking about the dev environment or the consumer stuff?
18:17:37 <Cale> blackdog: both
18:17:46 <Cale> Like, consider what happens when you accidentally miss clicking the menu bar by a couple pixels near the top of the screen
18:17:50 <blackdog> the iOS interface is a pretty big break from the past, i think
18:17:54 <rhyceu> That said, the new Xcode is a little insulting the way it looks
18:18:01 <Cale> OOPS, your menu is gone and replaced by the finder's menus!
18:18:14 <blackdog> they don't have their best minds working on MacOS any more, i think
18:18:18 <wavewave> I miss old DOS style CUI. he
18:18:29 <Cale> Now you have to go to the opposite edge of the screen and find your program in the dock, or click in one of its windows before you can try again
18:18:31 <wavewave> turbo C style IDE
18:18:33 * BMeph wishes there was an OS with an "Undo" button
18:18:50 <dmwit> > exp pi
18:18:51 <lambdabot>   23.140692632779267
18:19:01 <dmwit> > log 29.99
18:19:01 <lambdabot>   3.4008639927609177
18:19:05 <Sgeo|web> How about a pure functional OS?
18:19:17 <blackdog> Unsend that email!
18:19:22 <wavewave> Sgeo|web : there was , I remember...
18:19:25 <wavewave> house?
18:19:47 <luite> Cale: or you press command-tab to go back
18:20:19 <wavewave> @google house functional os haskell
18:20:20 <lambdabot> http://programatica.cs.pdx.edu/House/
18:20:20 <lambdabot> Title: House
18:20:24 <kmc> ummmmmm.  OS written in Haskell != pure functional OS
18:20:30 <Cale> Not to mention that the home/end/pgup/pgdn keys do something different from absolutely every other keyboard ever, and the only way to configure them back to sanity is by creating a text file in an (as far as I know) undocumented format in a location which doesn't exist by default.
18:20:46 <kmc> IIRC from their paper it's not particularly denotational
18:20:55 <wavewave> kmc: yeah yeah.. that's true... :-P
18:21:12 <wavewave> how about zipper FS  ?
18:21:13 <coppro> What is the purpose of the underlying monad in Parsec and why might I use it?
18:21:24 <kmc> coppro, do you mean, why is Parsec a monad transformer?
18:21:26 <luite> it's a bit annoying that apple makes so much fuss about all those multitouch things while the keyboard shortcuts are usually much more convenient, but unfortunately not consistent across applications
18:21:34 <blackdog> kmc: reminds me of the verified l4 guys
18:21:50 <blackdog> they have a haskell model, and the first thing is a state monad with MachineState as the parameter :)
18:22:04 <wavewave> @google ZFS haskell oleg
18:22:07 <lambdabot> http://hackage.haskell.org/package/ZFS-0.0
18:22:07 <lambdabot> Title: HackageDB: ZFS-0.0
18:22:26 <BMeph> Did anyone ever write an OS in OCaml? Or did they just claw out their eyes first? ;)
18:22:48 <Cale> iTunes has an approach to organising music which is worse than just using the filesystem, and enforces its use
18:22:49 <wavewave> anyone tried ZFS?
18:23:24 <rhyceu> wavewave: the one from Sun?
18:23:24 <luite> oh I don't really mind iTunes, it works for me :)
18:23:25 <wavewave> kmc: it looks like more 'functional'
18:23:37 <wavewave> rhyceu: no. above link.
18:23:47 <blackdog> wavewave: apparently it's a bit of a memory hog
18:23:53 <wavewave> Zipper File System.
18:23:53 <Cale> It doesn't seem to scale
18:23:55 <kmc> BMeph, I heard of a project to rewrite parts of Minix in OCaml
18:24:03 <kmc> I don't understand why everyone is so harsh on ocaml here
18:24:07 <kmc> turf wars? ;)
18:24:22 <Sgeo|web> What's the difference between Control.Monad.CC and Cont?
18:24:24 <Cale> When you have 16k songs, you kinda need more than one level of hierarchy
18:24:28 <kmc> I like Haskell's syntax better, but I don't think ocaml is "claw your eyes out" bad
18:24:32 <wavewave> ZFS introduction sounds like a joke.. ;-)
18:24:42 <luite> hmm, right, my song collection on my laptop (my only apple computer), is relatively small
18:24:55 <rhyceu> is there any hostility toward the Erlang crew? ;)
18:24:59 <BMeph> kmc: I suspect it's good-natured ribbing, combined with a lingering bad taste of jdh. :)
18:25:05 <dafis> kmc: not claw your eyes out, but I find it very ugly
18:25:12 <sdf12> kmc: You have a link to the minix ocaml port?
18:25:15 <Cale> rhyceu: no, I think we're on good terms ;)
18:25:20 <wavewave> no unsafe operation, no GHC/ Unix threads, no concurrency problem, thread can't even do IO and can't mutate any global state.
18:25:26 <kmc> sdf12, no, I heard about it in person from a friend forever ago
18:25:44 <luite> but OS X was the first OS where I really thougth that 4GB ram wasn't enough to do daily stuff
18:25:55 <rhyceu> heh, I wanted to pick up a functional-style language and I found Erlang much easier to understand, but Haskell much more general purpose
18:26:02 <sdf12> kmc: Oh, ok. Sounds like a fun project.
18:26:17 <rhyceu> hence why I am now a newly-minted Haskell noob.
18:27:38 <wavewave> haskell is a last boss. you should fight against it at last in the long journey of PL.
18:28:00 <kmc> not even close
18:28:00 <blackdog> wavewave: ah, i see you haven't played Agda: ReHaskellator.
18:28:24 <wavewave> blackdog: agda is actually the next game.
18:29:02 <blackdog> btw - has anyone here got deep experience with concatenative languages?
18:29:13 <BMeph> kmc: Seriously, I think the impetus for fibbing OCaml comes from ML users being the only people that seem to make a habit of putting Haskell down as a major pasttime. Other language users usually stick to "doesn't work the way I think"-style comments.
18:29:26 <blackdog> i've played with Cat a few times, but it just feels like hacking around with point-free operators. am i missing the big picture?
18:29:32 <BMeph> Er, for *ribbing OCaml, I mean.
18:29:44 <kmc> I've not noticed that about ML users
18:29:59 <sdf12> blackdog: Wouldn't call it deep, but you can write a Forth interpreter pretty easily.
18:30:19 <kmc> if you go on /r/programming you can find many anti-Haskell comments and I think most of them are from people who don't know ML either
18:30:19 <wavewave> BMeph: indeed. haskell people are quite balanced in evaluating languages in my opinion.
18:30:30 <kmc> not mine
18:30:34 <BMeph> blackdog: I was a serious FORTH programmer, but that was about twenty years ago. :)
18:30:54 <wavewave> BMeph: at least, it seems that haskell users are often a master of other languages.
18:31:07 <blackdog> sdf12: so, reasonably advanced language in an embedded space?
18:31:12 <kmc> i think if "haskell people" are more fair in evaluating other languages, it's a mere accident from knowing lots of other languages
18:31:13 <blackdog> i guess that's not a bad trade-off.
18:31:35 <kmc> i'm also not convinced it's true anyway
18:31:44 <wavewave> kmc: that's probably true.
18:31:47 <kmc> our community does a lot of self-congratulating over how smart and nice and fair we are
18:32:01 <BMeph> I like the way FALSE is organized. I'm also a pervert, so YMMV. ;)
18:32:02 <blackdog> kmc: how modest and fair and reflective of you!
18:32:07 <kmc> ;)
18:32:14 <Saizan> and kmc is here to ruin the day everytime
18:32:19 <kmc> haha
18:32:21 * kmc grumpy old man
18:32:24 <sdf12> blackdog: That seems to be the main use-case for forth. I haven't ever worked in it a production environment.
18:32:32 <wavewave> kmc: in my opinion, haskell community has the strongest connection with language specialists... that's the reason why.
18:33:10 <wavewave> I doubt that in java community, it is easy to meet general language experts like in haskell community.
18:33:28 <DanBurton> There are Java experts? *ducks*
18:33:29 <Saizan> anyhow i think the haskell community got enough large and diverse that the validity of any such statements are going to depend on who you think of as "haskell people", everyone will have his own slice
18:33:40 <blackdog> wavewave: it might be a community size thing.
18:33:43 <monochrom> I used to be a Java expert.
18:33:55 <kmc> Cale, "GHC's garbage collection is rather broken when it comes to ForeignPtrs to large data."
18:33:55 * monochrom almost typed: I used to be a Java export. :)
18:33:59 <kmc> what does / did that refer to?
18:33:59 <blackdog> we're still too small that you can reasonably expect to have learned haskell as your first language and never go outside.
18:34:11 <blackdog> (even if that were a terribly good idea)
18:34:17 <sdf12> I'd be curious to see a demographic for #haskell. Education level, age group, years programming in haskell, etc.
18:34:20 <BMeph> wavewave: Java isn't really fair to compare, since the knowledge space is so vast, it's difficult to find a concentration of experts in anything, even at Oracle. ;)
18:34:38 <wavewave> that's true.. My statement is not value-riden. just think some peculiarity of haskell community as of now.
18:35:16 * DanBurton is still in denial that Sun got consumed by Oracle
18:35:53 * BMeph has too much unfortunate experience to deny the Setting of Sun... :(...
18:36:34 <BMeph> dsf12: I think nomeata handles those stats. :)
18:39:19 <Cale> kmc: Um, I forget the details. It's probably been fixed by now :)
18:40:08 <luite> hmm, the problem I had with foreignPtr finalizers was that GHC didn't know how much memory they used. they could remain allocated for a long time even under memory pressure
18:41:36 <Cale> One thing that I could still complain about is that it seems almost impossible to interface GHC's garbage collection with a foreign GC in a way that'll properly collect cycles.
18:42:05 <EvanR> when GCs collide
18:43:01 <Cale> luite: oh, I think that's right
18:43:51 <ddarius> As far as I know, there aren't many GCs that would interact well with other GCs.
18:44:34 <Cale> There can be a long lag between when the ForeignPtr becomes unreachable and the finalizer gets run to clean up the resources on the other side.
18:44:42 <Cale> and that can result in problems
19:01:36 <thoughtpolice> @seen edwardk
19:01:36 <lambdabot> Unknown command, try @list
19:02:37 <thoughtpolice> hm, wonder where preflex is
19:08:06 <MatrixFrog> @seen preflex
19:08:06 <lambdabot> Unknown command, try @list
19:08:09 <MatrixFrog> :(
19:27:38 <incluye> @pl \n -> take n $ scanl1 (+) [1..]
19:27:38 <lambdabot> ($ scanl1 (+) [1..]) . take
19:28:18 <incluye> @pl \n -> (scanl1 (+) [1..]) !! n
19:28:18 <lambdabot> (scanl1 (+) [1..] !!)
19:30:27 <dmwit> ?pl \n -> scanl1 (+) [1..n]
19:30:27 <lambdabot> scanl1 (+) . enumFromTo 1
19:30:51 <dmwit> ?pl \n -> foldr1 (+) [1..n]
19:30:51 <lambdabot> foldr1 (+) . enumFromTo 1
19:33:27 <kmc> Cale, yeah, I can't offhand think of why GHC would care about the size of data pointed to by a ForeignPtr
19:33:31 <kmc> or how it could even know
19:33:48 <Cale> kmc: Well, right...
19:34:29 <Cale> kmc: It would be nice to have some system to give it a hint about the kind of size that those are attached to.
19:35:43 <kmc> why?
19:35:50 <wavewave> what's difference btwn @pl and ?pl ?
19:35:56 <kmc> none afaik
19:37:33 <dmwit> wavewave: All commands can be started with either a @ or an ?, no difference.
19:41:06 <wavewave> kmc, dmwit : I see.
19:41:14 <keep_learning> Now there is no update for euler problems on haskellwiki .
19:43:41 <joof136> hi
19:44:26 <wavewave> hi
19:44:28 <wavewave> hm
19:49:05 <coppro> hey, anyone here familiar with template haskell?
19:49:43 <c_wraith> a few of us have used it
19:49:47 <c_wraith> what's the question?
19:52:17 <bfig> ??
19:54:05 <aavogt> coppro: what about it?
19:55:23 <alexmurphy> > "\"\\"
19:55:24 <lambdabot>   "\"\\"
19:55:30 <coppro> c_wraith: if I have the name "xyz" bound, how do I get its value as an Exp?
19:55:42 <alexmurphy> > length "\"\\"
19:55:43 <lambdabot>   2
19:56:01 <kmc> [| xyz |]
19:56:01 <fryguybob> > text  "\"\\"
19:56:02 <lambdabot>   "\
19:56:18 <alexmurphy> Ohhh....
19:56:30 <alexmurphy> Thanks fryguybob
19:59:28 <coppro> kmc: oooh
19:59:35 <coppro> thanks
20:00:50 <aavogt> VarE (mkName "xyz") -- gives the actual type you asked
20:01:30 <c_wraith> aavogt: except it does the wrong thing.  he wanted the value, not the name
20:01:31 <aavogt> but it's better to use Q
20:01:49 <coppro> what c_wrait said
20:02:49 <coppro> if I just use the name, my understanding is that it will dynamically bind the name at use time
20:03:07 <c_wraith> coppro: kmc's th example desugars to a call to Language.Haskell.TH.lift
20:03:19 <c_wraith> coppro: *if* the name is a local variable
20:03:33 <coppro> yeah, and then that fails because Lift is undefined?
20:03:54 <c_wraith> If it's a type that doesn't have a literal representation in haskell, yes.
20:03:59 <kmc> a metaprogram value must be transformed to literal syntax to be embedded in the object program
20:04:09 <coppro> argh
20:04:44 <c_wraith> you can add Lift instances for your own data types, but things like functions cannot generally be lifted
20:04:46 <coppro> damn Ratio and its lack of constructors :(
20:05:24 <c_wraith> huh.  there really isn't a Lift instance for Ratio.  That's annoying.
20:05:34 <kmc> you can write that instance easily enough, constructors or no
20:06:11 <c_wraith> yeah, that one's not so bad.  just use the numerator and denominator destructors
20:06:14 <coppro> how would I write that instance?
20:06:20 <coppro> waitwhat?
20:06:25 * coppro is confused!
20:06:46 <c_wraith> ratio has accessors (I guess is a better term) to get the numerator and the denominator.
20:07:31 <c_wraith> lift x = let n = numerator x ; d = denominator x in [| n % d |]
20:07:32 <Sgeo|web> Can I do something like, having, say, Nomic be a newtype wrapper around a function of the type
20:07:34 <aavogt> coppro: if you use 'xyz as the Name, it won't be dynamically bound
20:07:40 <coppro> aavogt: oh
20:07:49 <Sgeo|web> (Nomic -> Nomic) -> Nomic -> Nomic?
20:07:55 <Sgeo|web> Wait, I don't think thats waht I want
20:08:25 <Sgeo|web> Can I have Nomic be a wrapper around values of the type Nomic -> Nomic?
20:08:25 <coppro> aavogt: oh, but it can't go out of scope?
20:08:33 <coppro> I'm getting a stage error
20:08:40 <coppro> c_wraith: thanks
20:08:56 <c_wraith> coppro: I'm not 100% sure that's right, but it's close if it isn't. :)
20:09:04 <hpaste> kmc pasted “lift Ratio” at http://hpaste.org/52947
20:09:24 <c_wraith> hey, looks like kmc agrees with me
20:09:28 <kmc> :)
20:09:36 <kmc> you beat me to it c_wraith but mine is a full module ;)
20:09:38 <c_wraith> but all pretty and fully working and stuff.
20:09:51 <kmc> silly that there's no function which returns (n,d)
20:10:14 <aavogt> coppro: TH names like that don't respect module scoping
20:10:45 <kmc> 'xyz gives you a Name which refers to whatever xyz is in scope here
20:10:47 <coppro> kmc: make another module :P
20:10:49 <Sgeo|web> More concretely, what happens if I try to do:
20:11:00 <Sgeo|web> data Nomic = Nomic (Nomic -> Nomic)?
20:11:10 <kmc> Sgeo|web, what happens is now you have this data type ;P
20:11:20 <Sgeo|web> So it will compile?
20:11:26 <coppro> is Lift not derivable
20:11:27 <coppro> ?
20:11:47 <kmc> coppro, not intrinsically, but there's http://hackage.haskell.org/package/th-lift
20:12:02 <Sgeo|web> That's the right sort of type for what I want to do, but I don't see a useful way to define an appropriate Nomic -> Nomic
20:12:24 <Sgeo|web> I could include extra data in there, I guess
20:12:29 <kmc> using TH to derive instances for TH's class for deriving TH syntax from values
20:12:32 <kmc> how fucking meta is that
20:12:46 <Sgeo|web> And then the Nomic -> Nomic would be how to use the data to make a new Nomic
20:13:02 <kmc> Sgeo|web, you can check yourself whether it compiles :)
20:13:17 <kmc> Sgeo|web, it's common for an embedded functional language to have something like
20:13:27 <kmc> data Val = VInt Int | VFun (Val -> Val)
20:13:40 <coppro> hrm
20:13:48 <coppro> how do I do this so that I get just an Exp and not a Q Exp?
20:14:04 <coppro> or do I have to work inside the Q monad?
20:14:12 <coppro> I've done so well in pretending that's not the easiest way!
20:14:35 <c_wraith> for this, you will need to either work in Q, or write a whole bunch of code yourself
20:14:37 <aavogt> it's easier if you use Q, since you get to use [| |] and so on
20:14:42 <coppro> ugh
20:14:48 <coppro> aavogt: you should clearly come by and fix my code :P
20:14:53 <Sgeo|web> I think in this case my Nomic -> Nomic will be included along with the other data
20:14:59 <kmc> TH wants you to use Q most places
20:15:03 <c_wraith> I mean, it's not like working in Q is bad either, since actual splices are in Q anyway
20:15:10 <kmc> of course you can convert a to Q a using good old return
20:15:21 <coppro> my issue is I'm trying to make a record construction expression
20:15:35 <coppro> and I need a Q [(Name, Exp)]
20:15:39 <Sgeo|web> But I want the types to be able to change at runtime... that is, I want to be able to ... switch the types I'm using
20:16:01 <Sgeo|web> COmpile with plugins or something then switch Nomic over to using a different ... type
20:16:13 <Sgeo|web> data Nomic = Nomic (Nomic -> Nomic) NomicData
20:16:19 <kmc> hey Sgeo|web maybe you should use http://hackage.haskell.org/package/dyre
20:16:23 <Sgeo|web> Then be able to define a different NomicData
20:16:49 <Sgeo|web> Well, no, but a NomicData2 maybe
20:17:15 <Sgeo|web> kmc: hmm
20:17:43 <kmc> coppro, how's that a problem?
20:17:46 * ddarius considers a type system for code that can change the type system.
20:18:29 <coppro> kmc: I don't want to have to think out the series of binds :P
20:18:35 <Sgeo|web> I guess I could use a typeclass instead of a concrete type
20:18:48 <kmc> "do" syntax might help
20:18:58 <Sgeo|web> data Nomic = (NomicData a) => Nomic (Nomic -> Nomic) a
20:19:00 <coppro> do syntax is evil :P
20:19:04 <coppro> (I'm kidding)
20:19:18 <Sgeo|web> Then new NomicData's can define wahtever, and it's easy to switch over
20:19:21 <Sgeo|web> Am I being coherent?
20:19:26 <ddarius> Systematically using (>>=) will produce something very similar to do notation.
20:20:06 <ddarius> Except for refutable patterns, do notation provides very little beyond what you could get without it.
20:20:44 <kmc> coppro, once you're using TH, you've already lost any kind of aesthetic high ground
20:20:44 <kmc> :)
20:20:57 <ddarius> Unfortunately true.
20:21:09 <coppro> kmc: :P
20:21:11 <wavewave> Sgeo|web : you want a hot-pluggable code?
20:21:19 <coppro> kmc: I'm also using Parsec :D
20:22:25 <Sgeo|web> wavewave: yes
20:23:04 <adrake> ddarius: something like http://en.wikipedia.org/wiki/Dependent_types
20:23:13 <adrake> ddarius: those are fun systems :D
20:23:33 <ddarius> adrake: Dependent types don't change the type system.
20:24:10 <adrake> how much change do you want that they couldn't emulate the effect you're after?
20:24:22 <adrake> (not arguing, just sort of curious)
20:24:25 <wavewave> Sgeo|web: what about defining your datatype in some module which is dynamically loaded using ghc-api and before hot-swapping, serialize your datatype and reloading new dynamic module and deserialize it?
20:24:58 <Sgeo|web> Hmm
20:25:16 <wavewave> Sgeo|web: it's long statement... I know :-P
20:25:31 <Sgeo|web> Is ghc-api reasonably easy to use?
20:25:47 <wavewave> Sgeo|web: I can show you some of my code.
20:25:58 <luite> it's ok, but it can change considerably between compiler versions
20:26:23 <Sgeo|web> Sure, I guess, but.. hmm
20:26:51 <Sgeo|web> I still want to work out what exactly the types would be if... hm
20:27:01 <luite> in the site I'm working on I only support one ghc version because of that
20:28:00 <wavewave> Sgeo|web : https://github.com/wavewave/HEPUtil/blob/master/src/HEP/Util/GHC/Plugins.hs
20:29:29 * Sgeo|web is utterly clueless what's going on there
20:29:46 <wavewave> Sgeo|web : wait a minute, ;-)
20:30:51 <wavewave> Sgeo|web : https://github.com/wavewave/jobtester/blob/master/lib/HEP/Automation/JobQueue/Tester/Job.hs
20:30:51 <ddarius> adrake: Ideally, you'd be able to provide a completely different type checking algorithm each "iteration."  Of course, the appropriate notion of "type safety" gets cloudy.
20:31:17 <wavewave> Sgeo|web : In Job.hs, see line 32
20:31:31 <ddarius> adrake: You could -embed- such a thing into a dependently typed language.  You could very likely embed it in System Fω as well.
20:32:33 <wavewave> "(eventsets,webdavdir)" is a haskell expression that you would like to obtain.
20:33:11 <adrake> fair enough
20:33:16 <Sgeo|web> huh?
20:33:23 <adrake> that's an interesting prospect :P
20:33:24 <wavewave> Sgeo|web : pluginCompile just evaluate the expression and insert it to haskell value.
20:33:56 <wavewave> Sgeo|web : and pluginCompile has the necessary code for doing that.
20:33:57 * Sgeo|web thinks that thinking about the types involved from a theoretical perspective may be easier
20:34:17 <Sgeo|web> Is it easy to define a new type in a plugin and make it conform to a pre-existing typeclass?
20:35:24 <wavewave> Sgeo|web: I do not have any specific idea on what would be the best approach for your question. I just inform you of how to use ghc-api for hot-plugging,
20:35:58 <wavewave> Sgeo|web: what you want to do need ghc-api / dynamic recompilation in any case.
20:36:19 <Sgeo|web> I think there are wrapper libraries though like plugins or hint
20:36:54 <luite> I don't think hint is compatible with ghc 7.2
20:36:55 <wavewave> Sgeo|web: plugins is deprecated in favor of ghc-api
20:37:13 <ddarius> Sgeo|web: You should be thinking in terms of abstract data types.
20:37:28 <luite> I removed all hint dependencies of my code when I upgraded to ghc 7.2
20:37:50 <Sgeo|web> ddarius: hmm?
20:37:57 <Sgeo|web> You mean GADTs? Or what?
20:38:01 <gienah> luite: hint builds with ghc 7.2 from the secret repo: http://darcsden.com/jcpetruzza/hint
20:38:03 <ddarius> wtf?
20:38:44 * gienah thinks the hint repo is secret as hackage specifies another repo 
20:38:51 <luite> gienah: ah
20:39:12 <luite> gienah: I wanted to remove if anyway since I had to hack it to get access to some GHC internals
20:39:31 <Sgeo|web> Hmm
20:39:32 <wavewave> hot-pluggable code is quite tricky.
20:39:55 <Sgeo|web> I guess I can't make the code that does the hot-plugging easily hot-pluggable itself?
20:40:08 <luite> had to add some form of defaulting to my code that isn't really possible with hint
20:41:19 <wavewave> anyway, in my case, I use that plugin code quite usefully. by this way, I use haskell source code as some data file.
20:42:26 <wavewave> Sgeo|web : BTW, yi editor is made as the whole code as hot-pluggable.
20:42:56 <wavewave> Sgeo|web: you may have some interesting idea from some of yi documentation.
20:46:59 <ddarius> Sgeo|web: Sure you can.
20:47:32 <coppro> one more: I'm getting an issue with read; any easy way to see what it's being called on (unsafePerformIO?)
20:48:28 <wavewave> https://github.com/yi-editor/yi
20:50:31 <wavewave> Sgeo|web : Yi.Dynamic may give us some hints for pluggable code design.
20:51:17 <wavewave> hmm, maybe not..
20:51:40 * wavewave is navigating yi codebase..
20:52:44 <coppro> what's lambdabot's feature to find the type of something in an expression?
20:52:53 <MatrixFrog> @type map
20:52:53 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:53:05 <MatrixFrog> > :t map
20:53:06 <lambdabot>   <no location info>: parse error on input `:'
20:53:07 <Axman6> :t let foo = ?x
20:53:07 <lambdabot> <no location info>: not an expression: `let foo = ?x'
20:53:15 <Axman6> :t let foo = ?x + 7 in foo
20:53:16 <lambdabot> forall a. (Num a, ?x::a) => a
20:55:05 <byorgey> coppro: Debug.Trace?
20:55:20 <byorgey> coppro: (which uses unsafePerformIO of course!)
20:56:24 <wavewave> Hmm, yi is using dyre.. dyre is the final answer.
20:59:06 <incluye> > ?x + 7
20:59:07 <lambdabot>   mueval-core: internal error: PAP object entered!
20:59:07 <lambdabot>      (GHC version 6.12.3 f...
20:59:19 <c_wraith> ooh.
20:59:24 <c_wraith> nice crash
20:59:38 <incluye> i know right!
20:59:43 <incluye> GHC bug
20:59:58 <parcs> no
21:00:01 <parcs> hint bug
21:00:15 <Sgeo|web> What is ?x
21:00:22 <incluye> dunno
21:00:32 <c_wraith> uh.  "PAP object entered" is definitely a GHC bug
21:00:49 <Sgeo|web> What's a PAP object?
21:00:53 <incluye> dunno
21:01:04 <c_wraith> part of the STG machinery ghc generates
21:01:10 <c_wraith> it stands for "partial application"
21:01:21 <c_wraith> a partially applied function should never be entered.
21:01:30 <parcs> c_wraith: hint is interfacing with the ghc api poorly i think
21:01:46 <wavewave> ?x is implicit variable?
21:01:46 <lambdabot> Maybe you meant: . ? @ v
21:01:46 <parcs> ghci doesn't reproduce that
21:01:56 <c_wraith> yes, ?x is an implicit variable
21:02:01 <Sgeo|web> What's an implicit variab;e?
21:02:08 <c_wraith> kind of dynamic scoping
21:02:15 <c_wraith> it's generally a bad idea in real code
21:02:24 <byorgey> a feature of GHC that is used only for doing type inference in lambdabot =P
21:02:37 <parcs> and ghci!
21:02:44 <byorgey> yes, and ghci
21:02:45 <Axman6> > let foo = ?x + 7 in let x = 4 in (foo, let x = 12 in foo)
21:02:45 <lambdabot>   mueval-core: internal error: PAP object entered!
21:02:46 <lambdabot>      (GHC version 6.12.3 f...
21:02:53 <Axman6> wut
21:03:01 <parcs> (foo,
21:03:13 <c_wraith> > let x = ?y in (let y = 5 in x)
21:03:14 <lambdabot>   mueval-core: internal error: PAP object entered!
21:03:14 <lambdabot>      (GHC version 6.12.3 f...
21:03:26 <byorgey> @type ?y
21:03:27 <lambdabot> forall t. (?y::t) => t
21:03:36 <byorgey> @type let x = ?y in x
21:03:37 <lambdabot> forall t. (?y::t) => t
21:03:44 <byorgey> @type let x = ?y in (let y = 5 in x)
21:03:45 <lambdabot> forall t. (?y::t) => t
21:03:50 <Axman6> :t let foo = show ?x in foo
21:03:51 <lambdabot> forall a. (Show a, ?x::a) => String
21:05:02 <Sgeo|web> huh?
21:05:16 <ddarius> :t 3 :: (a ~ Int) => a
21:05:17 <lambdabot> Int
21:05:24 <Sgeo|web> Is this the same as implicit parameters which I've heard nasty things about?
21:05:32 <byorgey> Sgeo|web: yes
21:05:35 <wavewave> iyes
21:07:36 <parcs> what nasty things have you heard?
21:07:40 <wavewave> Sgeo|web : https://github.com/yi-editor/yi/blob/master/yi/src/library/Yi/Boot.hs seems to have how to use dyre for  your purpose.
21:07:43 * ddarius has some evil ideas for unintended uses of constraint kinds.
21:09:26 <byorgey> ddarius: ooh, do tell =)
21:10:15 <ddarius> byorgey: Implicit parameters should be a constraint like any other.
21:10:54 <byorgey> ddarius: are they not?
21:11:27 <ddarius> I have no idea how constraint kinds would react to them.  My GHC is 7.0.1 I think or thereabouts.
21:11:33 <wavewave> Sgeo|web : the documentation in Config.Dyre module in dyre package is better..
21:12:00 <byorgey> ddarius: they are definitely handled in very similar ways to equality and type class constraints
21:12:09 <byorgey> ddarius: so I would be surprised if they didn't have kind Constraint.
21:12:34 * wavewave is happy that today he learned about dyre!
21:12:35 <ddarius> byorgey: Yes, that's my opinion as well.
21:12:54 <byorgey> ddarius: and you think this will lead to evil unintended uses?
21:12:56 <Sgeo|web> It's an unmemorial name though
21:13:20 <eggsby> Hi guys.  I'm new to haskell and trying to learn, could anyone explain to me why I might get a 'not in scope' error? http://pastie.org/2738822
21:13:26 <wavewave> Sgeo|web: yeah, I think I have heard of it before. just forgot it.
21:13:27 <eggsby> Is something like 'sort' not builtin?
21:13:42 <ddarius> byorgey: I suspect that the case of implicit parameter constraints wasn't considered, and implicit parameters can lead to evilness on their own, so it's not much of a stretch.
21:13:57 <byorgey> eggsby: to get 'sort' you must  import Data.List
21:14:00 <dalaing_home> you might need import Data.List
21:14:03 <ddarius> eggsby: What languages do you know?
21:14:16 <eggsby> thank you byorgey.  I'm trying to follow along with this google tech talk and he never mentioned that
21:14:22 <eggsby> ddarius: python and javascript
21:14:30 <byorgey> ddarius: true.
21:14:43 <byorgey> eggsby: cool, you've come to the right place.  feel free to ask more questions as you go along.
21:14:57 <eggsby> :D very nice to see such a warm community
21:15:03 <wavewave> yeah.. we are proud of #haskell
21:15:11 <Sgeo|web> I guess you could say import is similar to Python's import
21:15:21 <ddarius> eggsby: I'm just curious which languages engender this "every function should be a builtin" mentality.
21:15:23 <Sgeo|web> Or is it include, I forget now
21:15:38 <Sgeo|web> ddarius: PHP?
21:15:55 <eggsby> ddarius: the concept of importing isn't at all foreign, the hangup was that I was watching a video and the guy said 'write this and the code will work', it didnt :)
21:16:03 <eggsby> http://www.youtube.com/watch?v=b9FagOVqxmI for reference
21:16:46 <Sgeo|web> @hoogle (RandomGen a) => a -> [b] -> [b]
21:16:48 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
21:16:48 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
21:16:48 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
21:16:59 <ddarius> eggsby: I find the very terminology of "builtin" nonplussing.
21:17:02 <Sgeo|web> Does Hoogle not take notice of class constraints?
21:17:02 <wavewave> yeah. writing import .... on the precious space of presentation is wasteful.
21:17:53 <wavewave> oh.. I briefly thought lambdabot just left.
21:18:05 <kmc> most of the "builtin" stuff in Haskell comes from 1 line of syntactic sugar
21:18:15 <eggsby> wavewave: makes since, including the import solved it, back to watching this whirlwind tour :) Thanks everyone!
21:18:20 <kmc> which is to say, your module implicitly does "import Prelude" if it does not explicitly import Prelude
21:18:29 <Sgeo|web> Is random-shuffle in Platform?
21:18:57 <MatrixFrog> easy way to find out: open a ghci, type it
21:19:11 <dalaing_home> eggsby: there's a github repo with the code that goes along with the talk if you get stuck with other imports or issues-  https://github.com/mtnviewmark/haskell-amuse-bouche
21:19:11 <MatrixFrog> ghci will either go "oh yes, that function. of course" or "what now? idk what you're talking about"
21:19:16 <Sgeo|web> Mightn't help if I install non-platform stuff
21:19:42 <byorgey> Sgeo|web: I doubt it
21:19:56 <eggsby> dalaing_home: *slaps forehead* can't believe I missed that.  thank you
21:19:57 <byorgey> Sgeo|web: what's wrong with installing non-platform stuf?
21:20:33 <Sgeo|web> http://hackage.haskell.org/packages/archive/random-shuffle/0.0.2/doc/html/System-Random-Shuffle.html what.
21:20:39 <Sgeo|web> Maybe I should read Oleg's paper
21:20:42 <MatrixFrog> at the end of the talk eggsby is watching, he mentions there IS actually some haskell code being used in google. anyone know where?
21:20:47 <MatrixFrog> or is it a closely guarded secret?
21:21:30 <wavewave> MatrixFrog: I heard that google used haskell internally. not sure thogh
21:21:43 <ddarius> There is a paper about it.
21:21:52 <wavewave> facebook also use it.
21:22:04 <wavewave> ddarius: exactly, that's what I heard from.
21:22:06 <MatrixFrog> i was under the impression almost no one did
21:22:17 <djahandarie> There is always someone at Google who does everything.
21:22:21 <MatrixFrog> then there was a reddit thread the other day where FOUR people said they were hiring haskell programmers
21:22:22 <djahandarie> There are even people into n-categories there.
21:22:22 <wavewave> some haskell /python comparison.
21:22:51 <ddarius> MatrixFrog: There is an entire page of companies that use Haskell, and it is far from comprehensive.
21:23:14 <wavewave> @google google haskell python
21:23:16 <lambdabot> http://k1024.org/~iusty/papers/icfp10-haskell-reagent.pdf
21:23:16 <lambdabot> Title: Experience Report: Haskell as a Reagent
21:23:19 <MatrixFrog> sure, but i somehow had the idea that they were all very small or in foreign countries
21:23:42 <Sgeo|web> Someone needs to slap the author of System.Random.Shuffle and get them to switch their function names around and hide the requirement of knowing the length of the list
21:23:48 <MatrixFrog> does lambdabot have a @tldr command :P
21:23:55 * ddarius doesn't know which countries are foreign to MatrixFrog.
21:24:02 <MatrixFrog> ones that aren't the USA
21:24:21 <MatrixFrog> but on that thread i was talking about, there were FOUR people hiring, and THREE in the US
21:24:24 <MatrixFrog> i was kind of amazed
21:24:55 <wavewave> facebook uses haskell for updating script or something like that, I heard.
21:25:12 <MatrixFrog> and erlang for chat, iirc
21:25:13 <ddarius> For refactoring PHP.
21:25:28 <wavewave> ddarius: ah... you're right.
21:25:44 <wavewave> probably now they are using more.
21:29:47 <bfig> how can i upgrade to ghc latest version_
21:30:59 <Axman6> by downloading and installing it
21:31:28 <byorgey> bfig: go to haskell.org/ghc, go to the download page for the latest version, download a binary package, install
21:31:49 <bfig> no way to apt-get the lastest thing? :(
21:32:03 <MatrixFrog> not the very latest, no, i don't think so
21:32:15 <ddarius> If the latest thing is in your package repository, you can do that.
21:32:18 <wavewave> bfig: only if apt-get has newest version different from your package.
21:33:10 <wavewave> s/your package/your current package on your system
21:33:45 <bfig> it only has 6.12... :|
21:34:00 <wavewave> bfig: install haskell platform.
21:34:47 <wavewave> bfig: if you don't want to mess your system, you can install ghc/ haskell platform on your local directory.
21:35:09 <bfig> i think i found a way to install it
21:35:18 <bfig> synaptic to the rescue wohoo
21:35:31 <bfig> (i want to install some agda compiler)
21:36:02 <wavewave> good. I remember the latest ubuntu has ghc 7
21:36:19 <Sgeo|web> Adga vs Haskell?
21:36:30 <wavewave> ?
21:36:38 <Sgeo|web> Wait, can Agda only do proofs?
21:36:41 <augur> Sgeo|web: no
21:36:46 <djahandarie> Haskell can only do proofs.
21:36:56 <Sgeo|web> Or can I write a game with it?
21:37:04 <Sgeo|web> The way I can with Haskell
21:37:05 <augur> Sgeo|web: probably not yet
21:37:08 <djahandarie> Theoretically.
21:37:15 <augur> does anyone know of a good example where type inference leads to unexpected types?
21:37:16 <djahandarie> But, practically, no.
21:37:22 <wavewave> if you prove it. ;-P
21:37:39 <augur> Sgeo|web: agda can be as inexpressive as haskell, if you like
21:37:47 <wavewave> practical libraries are much missing.
21:37:49 <byorgey> augur: define "unexpected"
21:37:52 <augur> but it can also be _more_ expressive
21:38:26 <augur> byorgey: well, just where your inferred type isnt necessarily the most intuitive thing. perhaps to the extent that you cant use the function because you let the type be inferred
21:38:44 <augur> i recall seeing some examples of this, where not providing a type signature leads to expected behavior
21:38:50 <parcs> > id runST (return 5)
21:38:51 <lambdabot>   Couldn't match expected type `m t'
21:38:51 <lambdabot>         against inferred type `forall s....
21:39:05 <Sgeo|web> What's the id for?
21:39:10 <Sgeo|web> > runST (return 5)
21:39:10 <lambdabot>   5
21:39:29 <Sgeo|web> Oh, it should do nothing there
21:39:34 <augur> huh.. parcs why does that happen
21:39:56 <Axman6> :t id
21:39:57 <lambdabot> forall a. a -> a
21:39:58 <Axman6> :t runST
21:39:59 <lambdabot> forall a. (forall s. ST s a) -> a
21:40:14 <wavewave> :t runST (return 5)
21:40:15 <lambdabot> forall t. (Num t) => t
21:40:29 <copumpkin> > (+1) `id` 5
21:40:29 <wavewave> :t id runST
21:40:30 <lambdabot>   6
21:40:30 <lambdabot> forall a. (forall s. ST s a) -> a
21:40:35 <Axman6> i don't think a -> a matches ((forall s. ST s a) -> a) -> ((forall s. ST s a) -> a)
21:40:43 <copumpkin> no, it just did
21:40:55 <Axman6> hmm
21:41:10 <Axman6> well then smarty pants, you tell us why it doesn't work then :P
21:41:11 <copumpkin> > (id runST) (return 5)
21:41:12 <lambdabot>   5
21:41:16 <copumpkin> > id runST (return 5)
21:41:17 <lambdabot>   Couldn't match expected type `m t'
21:41:17 <lambdabot>         against inferred type `forall s....
21:41:37 <wavewave> hmm
21:41:41 <copumpkin> > runST $ return 5
21:41:42 <lambdabot>   5
21:41:59 <byorgey> augur: oh, well, type inference cannot handle higher-rank types, so if you are intending to use a function with a higher-rank argument I suppose that could be unexpected/confusing
21:42:13 <augur> ok
21:42:16 <copumpkin> > let f = id `asTypeOf` ($) in f runST (return 5)
21:42:16 <byorgey> augur: but usually in those situations it will just fail to typecheck rather than giving you something unexpeced.
21:42:17 <lambdabot>   5
21:42:37 <copumpkin> > (id `asTypeOf` ($)) runST (return 5)
21:42:38 <lambdabot>   Cannot match a monotype with `forall s. GHC.ST.ST s a'
21:42:41 <byorgey> augur: Haskell has the property that every type which is inferred is (in a technical sense) the *most general* type
21:42:46 <copumpkin> :)
21:43:10 <augur> byorgey: yeah. i was thinking of cases where over genericity is unexpected and leads to weird behavior
21:43:26 <byorgey> augur: it can't possibly lead to weird *behavior*.
21:43:30 <wavewave> copumpkin: still don't get it.. what's going on?
21:43:37 <augur> byorgey: weird from the programmers perspective! :P
21:43:59 <copumpkin> wavewave: very funky rules on when you're allowed to instantiate type variables to polymorphic types
21:44:19 <byorgey> augur: I suppose if you are thinking that your program has some concrete type and it turns out that the type is actually more general, that can be unexpected
21:44:32 <byorgey> augur: but it will still work in exactly the same way as it would have if it had the more specific type.
21:44:41 <byorgey> augur: that's what I mean by "it can't lead to weird behavior".
21:44:53 <augur> ok
21:45:04 <byorgey> a more general type just means that more programs will type check.
21:45:17 <byorgey> but programs that type check under both the specific and general type will behave the same.
21:45:26 <wavewave> copumpkin: it can be serious if a programmer does not know the above splitting f is a solution.
21:45:45 <parcs> augur: (>>) putStrLn putStrLn "foo" vs liftM2 (>>) putStrLn putStrLn "foo"
21:46:03 <copumpkin> that kind of shit only arises in this kind of situation, and can be avoided by annotating with a more precise type
21:46:12 <parcs> the first one prints foo once, the second one twice
21:46:25 <aavogt> is there a difference between using alloca with poke inside there, vs. new?
21:46:26 <parcs> hmm, this probably isn't what you're asking for though
21:46:34 <augur> ok.
21:46:41 <byorgey> @type (>>) putStrLn putStrLn "foo"
21:46:42 <lambdabot> IO ()
21:46:45 <aavogt> (when the two things seem to achieve the same thing)
21:46:58 <wavewave> copumpkin: I see, thanks.
21:48:58 <Sgeo|web> :t >=>
21:48:58 <lambdabot> parse error on input `>=>'
21:49:01 <Sgeo|web> :t (>=>)
21:49:02 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
21:49:50 <Sgeo|web> So it combines two functions that return a monad....
21:49:50 <wavewave> aavogt: it seems that new is implemented using malloc and poke.
21:50:16 <Sgeo|web> So does getLine ... no
21:51:02 <wavewave> aavogt: ah, sorry, you are asking alloca.
21:51:06 <byorgey> Sgeo|web: you can think of (a -> m b) as a "function from a to b which can also have side effects"
21:51:24 <byorgey> Sgeo|web: from that point of view, (>=>) is just function composition
21:51:39 <byorgey> it composes the functions, and ensures that the "side effects" happen in order
21:52:16 <byorgey> no, forget about ensuring they happen in order.  it just combines all the effects.
21:53:27 <Sgeo|web> Is the case () of idiom common?
21:54:44 <copumpkin> what's it for?
21:55:35 <Sgeo|web> Instead of if/then/else chains
21:55:36 <wavewave> Sgeo|web : it should not be..
21:56:15 <Sgeo|web> Are if/then/else chains considered ok?
21:57:00 <djahandarie> Sgeo|web, your question had some ambiguous syntax in it...    case () of    is actually valid Haskell. Were you just using () as a placeholder?
21:57:08 <ddarius> Down with Booleans!
21:57:10 <parcs> refactor the chain into a function and use guards instead
21:57:17 <wavewave> Sgeo|web : BTW, how do you use 'case () of ' instead of 'if then else'?
21:57:47 <parcs> case () of _ | p1 -> e1 | p2 -> e2 | p3 -> e3 ...
21:57:56 <aavogt> I do that sometimes
21:58:02 <Sgeo|web> parcs: would you need ; and more _?
21:58:19 <parcs> > case () of _ | p1 -> e1 | p2 -> e2 | p3 -> e3
21:58:19 <lambdabot>   Not in scope: `p1'Not in scope: `e1'Not in scope: `p2'Not in scope: `e2'Not...
21:58:21 <parcs> nope
21:58:25 <Sgeo|web> But yeah, that
21:58:31 <djahandarie> I would never do that. And I wouldn't use if/then/else either.
21:58:42 <djahandarie> 02:21 < ddarius> Down with Booleans!
22:01:31 <copumpkin> ugh
22:02:57 <hpaste> wavewave pasted “case () of ” at http://hpaste.org/52948
22:04:06 <djahandarie> You can get rid of that let binding :P
22:04:17 <djahandarie> And the case too
22:04:18 <wavewave> is it just simpler to use local function definition?
22:05:02 <wavewave> djahandarie: I know... the question is when deep in the let-definition, probably.
22:05:38 <djahandarie> I suppose.
22:05:56 <djahandarie> I don't like functions like that anyways. If I have random numbers lying around in my program, I'm doing it wrong.
22:06:30 <monochrom> <monochrom> down with ()!
22:09:00 <hpaste> wavewave annotated “case () of ” with “case () of  (annotation)” at http://hpaste.org/52948#a52949
22:10:57 <hpaste> monochrom annotated “case () of ” with “case () of  (annotation)” at http://hpaste.org/52948#a52950
22:11:10 <monochrom> you can, in fact, do what is in my paste
22:11:29 <hpaste> wavewave annotated “case () of ” with “case () of  (annotation) (annotation)” at http://hpaste.org/52948#a52951
22:12:21 <wavewave> monochrom : uh.. the same.
22:12:41 <monochrom> we wrote them simultaneously
22:12:59 <monochrom> but hpaste has ruled which one was first :)
22:13:32 <wavewave> Sgeo|web : isn't it better than "case () of"?
22:13:50 <Sgeo|web> That's weird
22:16:37 <wavewave> hmm
22:16:44 <Sgeo|web> I have no idea how I'd remember that syntax
22:17:16 <Sgeo|web> Can you do something like that whereever there's an =?
22:17:48 <wavewave> Sgeo|web : you mean x = >
22:17:53 <wavewave> x = ?
22:18:01 <Sgeo|web> yeah
22:18:51 <wavewave> Sgeo|web : you can make some combinator functions.
22:31:11 <hpaste> wavewave annotated “case () of ” with “case () of  (annotation) (annotation) (annotation)” at http://hpaste.org/52948#a52952
22:31:32 <wavewave> Sgeo|web :  do not puke.
22:34:16 <wavewave> forgive my fromJust.. it should be replaced
22:34:38 <eyu100> how do I get flymake to detect my cabal packages?
22:35:00 <eyu100> I import Control.Monad.Random and flymake says it can't be found, but when I load the file in ghci it works perfectly
22:54:00 <ddarius> wavewave: oor = <|>
22:54:35 <ddarius> And otherwise already is True.
22:55:32 <wavewave> ddarius: ah, yes. thanks.
22:55:50 <ddarius> wwhere is almost guard.
22:56:52 <ddarius> :t fmap snd . find fst
22:56:52 <lambdabot> forall b. [(Bool, b)] -> Maybe b
22:57:32 <wavewave> ddarius: yes. we can rewrite this just using MonadPlus. .
22:57:45 <ddarius> Or alternative.
22:57:49 <ddarius> s/a/A/
23:02:03 <wavewave> ahhh, i need sleep now
23:02:29 <wavewave> so many things to learn ~~
23:02:50 <wavewave> see ya #haskell
23:38:41 <augur> TaPL 22.3 has a typing rule for lambdas where the type of the lambda is known to be T -> T'. does this mean i should pre-annotate lambdas with such a type?
23:39:37 <dalaing_home> gah - spolier alert - I'm about to start on TaPL soon
23:39:39 <dalaing_home> :)
23:40:13 <augur> i mean, the application rule doesnt use function types on the recursive case
23:40:15 <companion_cube> at the end of the book, the bad guys die and the hero mary the princess
23:40:21 <augur> it puts the function type in the unifier
23:40:22 <dalaing_home> noooo
23:40:46 <ddarius> dalaing_home: You'll never guess how it ends.
23:41:15 <dalaing_home> ddarius: that's a spoiler on it's own - now I know that it terminates...
23:41:36 <ddarius> dalaing_home: But you don't know if it's confluent.
23:41:49 <augur> oh no, confluence
23:41:58 <dalaing_home> well now I _have_ to read it
23:41:58 <augur> you might have woken gio D:
23:42:00 <Cale> It ends with an appendix of notational conventions!
23:42:26 <Cale> Also, Snape kills Dumbledore
23:42:48 <ddarius> Never could trust Dumbledore anyway.
23:43:04 <augur> Cale, ddarius: what should i do!
23:43:05 <augur> D:
23:44:04 <ddarius> I highly suspect that there are no annotations.  The syntax either disallows or requires "annotations."
23:44:37 <augur> i mean annotations in my ADTs
23:45:10 <augur> its just, the rule for application explicitly is stated as not using -> types in the recursive steps
23:45:23 <augur> but the rule for lambdas is stated in terms of a -> type
23:45:43 <ddarius> If you manifestly have a lambda, you know it's a function type.
23:45:52 <augur> right i know, but
23:46:06 <augur> if i have an application, i also manifestly know the function has a function type
23:46:21 <ddarius> No you don't.
23:46:30 <augur> well, i know it needs to
23:46:49 <ddarius> Yes, the information is going in a different direction there.
23:46:52 <augur> hm
23:46:55 <augur> but
23:47:25 <augur> i dont see how this proof system can be used to define an actual algorithm is all
23:48:12 <augur> if i try to type check (\x -> x) y : T, using this system, i never end up trying to try check \x -> x : T' -> T
23:48:36 <augur> sure i know lambdas are function types, but thats not what this system provides
23:50:12 <augur> it says   G :- f x : T | C U C' U {T' = T'' -> T}   <=   G :- f : T' | C   G :- x : T'' | C'
23:51:02 <augur> so no matter what the function is, the proof says i have to try proving its type to be T'
23:51:05 <augur> not T'' -> T
23:52:16 <augur> i suppose since T and C are being calculated thats ok tho
23:52:17 <augur> hmm
23:52:25 <ddarius> And presumably you also have to solve the constraint T = T'' -> T
23:52:30 <ddarius> s/T/T'/
23:52:35 <augur> yeah, they're somehow separating that out
23:52:43 <ddarius> Yes, that's typical practice.
23:54:37 <augur> ive never done unification like this
23:54:41 <augur> building up constraints first
23:54:48 <augur> ive only ever done it where you unify as you go
23:57:28 <ddarius> It's essentially equivalent.  However, this form allows a better separation of concerns in theory and ready generalization to more interesting constraint domains in both theory and practice.
