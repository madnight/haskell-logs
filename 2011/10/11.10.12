00:13:44 * hackagebot Stream 0.4.6 - A library for manipulating infinite lists.  http://hackage.haskell.org/package/Stream-0.4.6 (WouterSwierstra)
00:13:48 <dncr> If (data A = A String deriving Show) and (a = A "ŋ") then how do I get from a to the output of: A "ŋ"?  (putStrLn $ show a) outputs: A "\331".
00:14:21 <MHD> dncr: You need some kind of unicode console for that...
00:14:42 <MHD> dncr: I think WinGHCi can do that...
00:14:59 <Axman6> or implement your own instance of Show: instance Show A where show (A str) = "A \""  ++ str ++ "\""
00:15:09 <Axman6> but, you probably don't want to do that
00:15:29 <Axman6> > read ""∑"" :: String
00:15:30 <lambdabot>   Not in scope: `
00:15:35 <Axman6> o.O
00:15:40 <dncr> ok so this has to do with maintaining the behavior of (show) before ghc supported unicode as well?
00:15:44 <Axman6> > read "\"∑\"" :: String
00:15:44 <lambdabot>   "\8721"
00:15:50 <Axman6> huh, maybe that does work
00:17:36 <dncr> even when i use Data.Text instead of String I see this
00:18:04 <dncr> strange world
00:20:44 <Cale> dncr: While it's sometimes inconvenient that you can't read the strings directly (I can imagine with non-English strings floating about it would get strange), Show instances are intended mainly for debugging, and it's sometimes helpful to know exactly what string it is (rather than deal with invisible characters and potentially non-normalised unicode, etc.)
00:21:17 <Cale> If you want to print the string to the terminal, you have to actually use putStr or putStrLn
00:21:27 <Cale> (without also using Show)
00:22:31 <cwl> @type liftIO
00:22:32 <lambdabot>     Ambiguous occurrence `liftIO'
00:22:32 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
00:22:32 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
00:23:56 <Cale> blah, that's still happening :P
00:24:08 <cwl> liftIO :: (MonadIO m) => IO a -> m a
00:24:20 <cwl> is liftIO unsafe?
00:24:26 <Cale> no
00:24:58 <Cale> Instances of liftIO will be structures involving IO actions somehow.
00:25:10 <cwl> for example, test = liftIO someIOAction :: Snap Int
00:25:11 <Cale> Or, of MonadIO rather
00:25:33 <cwl> someIOAction can do *any* IO
00:25:34 <Cale> yeah, that's fine, it defines test as a Snap action which performs some IO if executed
00:25:38 <cwl> but Snap Int cannot
00:25:46 <Cale> It must be able to
00:25:50 <Axman6> listIO is how it does it
00:25:51 <Cale> if it's an instance of MonadIO
00:25:57 <Axman6> liftIO*
00:26:05 * Axman6 always does that
00:26:07 <dncr> hm ok
00:26:33 <Axman6> @src MonadIO
00:26:34 <lambdabot> Source not found. My mind is going. I can feel it.
00:26:37 <Axman6> :(
00:26:37 <cwl> Cale: instance of MonadIO can do whatever IO Monad can do?
00:26:51 <Cale> yes
00:26:57 <Cale> via liftIO
00:27:02 <Axman6> that's kinda the point of it
00:27:24 <cwl> Cale: I see, thank you
00:27:33 <Axman6> it's often used with monad transformers like StateT, so you can have (pure) state that's threaded through code that also needs IO
00:27:35 <cwl> need to learn more about MonadIO
00:28:22 <Axman6> or ReaderT where you pass around a config data type which might determine what to do in certain situations (like what file to log output to)
00:32:03 <Blkt> good morning everyone
00:36:01 <cwl> Blkt, morning?
00:36:18 <cwl> lol, afternoon for me
00:40:44 <Blkt> cwl: good for you then, you can go home from work
00:40:49 <Blkt> I just started...
00:41:16 <Axman6> evening Blkt
00:41:25 <Blkt> hi there
00:41:33 <Axman6> cwl: where in the world are you?
00:48:24 <mroman> Has anybody experience with TCache or persistent STM?
00:49:32 <mroman> I can execute atomic operations (and therefore threadsafe) with STM, but how do I get the result of that to IO?
00:50:18 <Axman6> using the function atomically
00:51:11 <mroman> But I can't use IO inside atomically?
00:51:16 <Axman6> no
00:51:24 <mroman> That's my problem.
00:51:28 <Axman6> well, not safely. i can't remember is there's a backdoor in STM
00:51:42 <quicksilver> there is a backdoor in STM
00:51:44 <Axman6> you really should not be doing that though
00:51:45 <quicksilver> unsafeIOtoSTM
00:51:48 <mroman> atomically just guarantees me the saneness of my data while im in the STM Monad.
00:52:00 <Axman6> yes
00:52:04 <mroman> but there is no guarantee after that so I can write the data to disk
00:52:06 <quicksilver> but you can't use that without understanding how it all works fairly well
00:52:32 <Axman6> mroman: you need to devise another way of doing things atomically on disk then
00:52:42 <quicksilver> since your IO action could be performed in a transaction which gets rolled back.
00:52:59 <Axman6> and also run many times
00:53:13 <quicksilver> Yes, you'll have to devise your own disk-based consistency
00:53:16 <mroman> And that'll give me corrupt data too @retry
00:53:30 <Saizan> you'll always get a sane snapshot out of a STM transaction
00:53:37 <Axman6> you could use file locking
00:53:44 <Axman6> but... then you may run into problems
00:53:58 <mroman> Axman6: I need to look the data for STM too.
00:53:59 <Axman6> (ie, lock the file, run the STM action, get the result, write to the file, unlock)
00:54:18 <Axman6> that should be fairly trivial to do with an MVar actually
00:54:21 <mroman> Since after I modified something in STM, I want _that_ data on disk without other stm transactions modifying it before it was written to disk.
00:54:31 <gaze__> man... sure would be cool if persistent STM provided atomicity to disk... as in, used a journal on disk and all that.
00:55:00 <mroman> persistent STM would be totally cool, yeah ;)
00:55:14 <Saizan> it seems like you want acid-state
00:55:20 <Axman6> yeah
00:56:30 <mroman> hm. yes @acid
00:56:58 <shachaf> mroman: No, a package called acid-state.
00:57:15 <quicksilver> I think there are good reasons that STM is not an on-disk journalling transaction system.
00:57:29 <quicksilver> it's specifically intended to be lightweight, software and (relatively speaking) fast.
00:57:45 <quicksilver> I'm not sure you can square those design goals with fsync().
00:57:45 <hpaste_> bartavelle pasted “parsec question” at http://hpaste.org/52511
00:57:53 <gaze__> oh yeah... obviously you wouldn't normally want that
00:57:55 <bartavelle> well, I have this question :)
00:57:56 <mroman> shachaf: I got that @acid-state
00:58:08 <gaze__> but OOOOOOOOOOOOOOOOOOOHHHH acid-state was just what I was looking for :D
00:58:58 <gaze__> I wonder how it actually groks the data structure that you're making persistent though
00:59:34 <quicksilver> by typeclass instances, gaze__
00:59:45 <quicksilver> which can be generated by TH if you want.
01:00:35 <gaze__> Hmm? I'm confused
01:01:01 <quicksilver> in principle, it groks the data structure by you writing lots of fiddly instances
01:01:09 <quicksilver> to turn the data structure inside out.
01:01:21 <quicksilver> however, in practice you can use the TH supplied to write those instances for you.
01:02:01 <gaze__> I'm curious what the code the TH generates looks like
01:02:07 <cwl> @src callCC
01:02:07 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
01:02:18 <quicksilver> then look at the noTH examples
01:02:24 <quicksilver> which show how to write it by hand :)
01:03:16 <quicksilver> helloworldNoTH at http://mirror.seize.it/acid-state/examples/
01:10:11 <gaze__> it's not obvious to me how the structure is being turned inside out, especially given that it's only one string.
01:15:41 <gaze__> quicksilver: I feel like this is sorta getting near -XDeriveDataTypable... do you know of any good tutorials for this stuff?
01:16:09 <mroman> Is that the new magic auto-derive Feature?
01:16:25 <Rc43> Hi, guys.
01:16:52 <mroman> Ah no. That's generic deriving.
01:16:53 <Rc43> Can anybody tell me what is `runhaskell' binary for?
01:17:07 <shachaf> Running Haskell.
01:17:09 <mroman> Rc43: It compiles and runs .hs files on-the-fly
01:17:10 <shachaf> Well, a Haskell prgoram.
01:17:13 <quicksilver> gaze__: well it certainly *requires* data typeable
01:17:19 <quicksilver> gaze__: and it requires Binary too
01:17:27 <quicksilver> and between those two you already have quite a lot.
01:17:41 <Rc43> mroman, thanks
01:18:27 <shachaf> It doesn't necessarily compile, nor are the files necessarily .hs files. :-)
01:18:50 <gaze__> quicksilver: I believe it. I just haven't found any simple intros to Data.Data... I've run into several issues recently that I think could be greatly helped by understanding Data.Data a bit better.
01:25:34 <erus`> @hoogle [m a] -> m [a]
01:25:35 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
01:25:35 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
01:25:35 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
01:26:25 <ion> @hoogle x (m a) -> m (x a)
01:26:26 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
01:26:26 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
01:26:26 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
01:32:54 <erus`> is this silly: return $ either Left (buildBindings bs) (sequence epis)
01:33:39 <erus`> ah yes i can use a bind
01:58:32 <lpsmith> out of curiousity, can GHC run more than one safe FFI call to C at a time in separate threads?   Or are all safe C calls done in a single thread?
01:58:58 <quicksilver> it creates one thread per call AFAIK lpsmith
02:00:17 <lpsmith> that seems pretty heavyweight...  but maybe that's a large reason why a safe call to a trivial c function takes ~100ns on my laptop, whereas a unsafe call takes ~7ns
02:02:48 <quicksilver> lpsmith: I think the canonical write-up of this stuff is http://community.haskell.org/~simonmar/bib/concffi04_abstract.html
02:03:01 <quicksilver> lpsmith: for specific answers you can try to grab JaffaCake in IRC ;)
02:03:10 <lpsmith> thanks
02:03:56 <ClaudiusMaximus> i certainly get full utilisation of 4 cores from single-threaded foreign code using forkIO in haskell
02:06:20 <lpsmith> ClaudiusMaximus: yeah,  well, my application is not that demanding,  and honestly the only reason I care is I'm trying to make a PostgreSQL access library worth using.    Chris Done has an excellent start,  and I think his approach of implementing the protocol in native Haskell has a lot of advantages,  but the downside is there is a lot of missing functionality.
02:07:04 <lpsmith> So,  I'm working on a fork of his library that uses libpq
02:08:00 <lpsmith> to support e.g. encrypted connections and asynchronous notification and the like.
02:10:18 <lpsmith> I'm thinking I should implement a version that uses blocking, synchronous, safe FFI calls, and then maybe explore implementations using non-blocking, asychronous, unsafe FFI calls.
02:10:54 <lpsmith> GHC seems well positioned for implementing blocking, synchronous interfaces on top of non-blocking async interfaces  :)
02:11:16 <ClaudiusMaximus> i had a nightmare with scripting my gtk app, until i realized i wanted the scripting to be a separate thread and not callback based - i ended up with somthing like:  script = do v <- newEmptyMVar ; runAction Action{ onSuccess = putMVar v True ; onFailure = putMVar v False } ; takeMVar v
02:11:43 <ClaudiusMaximus> then    forkIO script >> mainGUI
02:12:06 <quicksilver> lpsmith: you don't pay the fork cost each time though
02:12:14 <quicksilver> lpsmith: the RTS maintains a *pool* of threads for FFI
02:12:29 <quicksilver> so if you do a lot of concurrent FFI generally there should be spare threads hanging around.
02:12:51 <quicksilver> conversely unsafe FFI blocks a capablility entirely.
02:15:14 <erus`> is there a group . sort ?
02:16:05 <earthy> erus`: group . sort :P
02:16:31 <ClaudiusMaximus> > group . sort $ "group . sort $"
02:16:32 <lambdabot>   ["   ","$",".","g","oo","p","rr","s","t","u"]
02:19:00 <erus`> i cant believe thats not a prelude function
02:19:09 <erus`> 'sames' or something
02:19:54 <shachaf> erus`: Why, exactly, when you have group . sort?
02:20:20 <erus`> because its a common thing, right?
02:20:33 <quicksilver> yeah, it's not necessarily worth giving something a new name
02:20:36 <erus`> there are plenty of other functions that are simply a composition of two
02:20:39 <quicksilver> it's a hard trade-off
02:21:17 <quicksilver> I would argue that "group . sort" is a better name because you immediately know what it does
02:21:23 <quicksilver> (assuming you understand group and sort)
02:21:29 <quicksilver> whereas "sames" you'd have to remember.
02:21:43 <erus`> Im gonna march on cambrige. "We are the 99% who use group . sort"
02:22:25 <shachaf> erus`: The whole point of composition is that you don't need to name those things.
02:22:41 <quicksilver> I've always thought that concatMap is a bit silly, in fact
02:22:54 <shachaf> quicksilver: I suspect it's just because of (>>=) that it's there.
02:22:55 <erus`> quicksilver: i use it loads
02:22:58 <quicksilver> although more justified since (concat.).map is a bit uglier to write
02:23:01 <shachaf> Also, it's (concat .) . map
02:23:15 <shachaf> I guess mapM etc. are justified, though.
02:23:26 <quicksilver> shachaf: in *practice* though, it's concat $ map ....
02:23:42 <quicksilver> but abstractly it's (concat.).map
02:23:44 <shachaf> quicksilver: Or concat . map f ...
02:23:49 <quicksilver> nod
02:23:55 <shachaf> gdi
02:24:50 <lpsmith> ClaudiusMaximus: yeah,  I think callbacks and async and the like are really pretty important for a low-level interface,  but not the one that you actually want to write your application in
02:24:53 <shachaf> @ty let map = fmap in map concat . map
02:24:54 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
02:25:47 <shachaf> lpsmith: No, the only way your programs can scale is by writing them in explicit CPS.
02:26:00 <shachaf> It's a well-known Internet fact.
02:26:04 <lpsmith> lol
02:27:08 <lpsmith> quicksilver: what's a capability?
02:27:20 <quicksilver> lpsmith: an honest-to-goodness hardware thread
02:27:39 <quicksilver> hmm or maybe not. Maybe it's an OS thread.
02:27:45 <shachaf> quicksilver: Hardware thread? Not OS thread?
02:27:50 <quicksilver> OS thread.
02:28:04 <lpsmith> well, but that doesn't make any sense to me
02:28:06 <shachaf> I doubt you get to decide that you're just going to take over a hardware thread. :-)
02:28:17 <quicksilver> unsafe FFI is for things which are *really* fast
02:28:19 <lpsmith> though it would be nice to know the answer to these kinds of questions
02:28:26 <quicksilver> like calling libc's version of 'atan'
02:28:28 <lpsmith> I mean,  a blocking safe call is going to block an OS thread, for sure
02:28:50 <quicksilver> so the RTS doesn't do anything clever to wrap the call
02:28:54 <quicksilver> except register save/restore
02:29:03 <quicksilver> so, it blocks that OS thread
02:29:08 <lpsmith> but unsafe stops the whole haskell runtime, doesn't it?
02:29:09 <quicksilver> and you only have a limited number of those
02:29:18 <quicksilver> no, not the whole runtime.
02:29:22 <quicksilver> just that OS thread.
02:29:37 <lpsmith> but that's what safe does
02:29:37 <quicksilver> if you're reading something that says it blocks the whole runtime you're reading something old about the non-threaded RTS
02:29:44 <lpsmith> so what's the difference between safe and unsafe?
02:29:45 <quicksilver> no, safe doesn't blcok anything at all, lpsmith
02:30:01 <lpsmith> that would be quite a miracle
02:30:03 <quicksilver> safe is run in a special OS thread which is put aside for the purpose of running FFI
02:30:08 <lpsmith> hmm
02:30:17 <quicksilver> so your normal haskell code has as many capabilities as it normally has
02:30:28 <quicksilver> unsafe is run in the current OS thread and blocks it
02:30:32 <JaffaCake> if you make a safe FFI call, we spin up a new OS thread to continue running the rest of the Haskell threads
02:30:38 <quicksilver> (which has a side effect of blocking *everything* if a GC comes up)
02:30:50 <lpsmith> capability meaning an OS thread capable of running Haskell?
02:30:51 <quicksilver> but hopefully your unsafe FFI calls never take long enough that that matters.
02:31:18 <quicksilver> yes. The number of capabilities is the number of OS threads the RTS is using to run your actual haskell.
02:31:26 <quicksilver> normally you choose it to be the number of cores you have.
02:31:28 <quicksilver> e.g. +RTS -N4
02:32:02 <shachaf> quicksilver: Well, number of "cores" the OS sees, I imagine.
02:32:27 <lpsmith> ok,  so i don't actually have to run +RTS -N2 to prevent safe calls from blocking the haskell runtime,  I don't have to mess with that at all
02:32:35 <lpsmith> Things are making a bit more sense
02:32:38 <shachaf> (Including "hyper-threading" cores, I mean.)
02:32:49 <JaffaCake> lpsmith: exactly
02:33:12 <erus`> @hoogle a -> Ordering
02:33:12 <lambdabot> Prelude id :: a -> a
02:33:13 <lambdabot> Data.Function id :: a -> a
02:33:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
02:33:28 <JaffaCake> lpsmith: neither do you have to use forkOS, another common misconception
02:33:49 <quicksilver> lpsmith: but you do have to use the threaded RTS :)
02:34:06 <erus`> @hoogle [Char] -> [Char] -> Ordering
02:34:07 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
02:34:07 <lambdabot> Data.Time.Format readTime :: ParseTime t => TimeLocale -> String -> String -> t
02:34:07 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
02:34:34 <quicksilver> forkOS is up there beside cabal in the Haskell Hall of Hideous Naming Horrors.
02:34:50 <shachaf> What's wrong with "cabal"?
02:35:14 <quicksilver> shachaf: the fact that the binary 'cabal' lives in a package called 'cabal-install' which is option, whilst the library 'cabal' comes with GHC
02:35:21 <shachaf> Oh, *that*. Sure.
02:36:37 <shachaf> How do bound threads interact with safe FFI calls?
02:37:54 <quicksilver> if a haskell thread is bound then all the FFI from that haskell thread will occur in some particular, chosen, FFI thread
02:38:34 <lpsmith> JaffaCake: ok, yeah, this is making a lot more sense to me,  and have to admit it's a lot better approach than the vague misconceptions I had about how it worked.
02:38:38 <quicksilver> not necessarily the OS thread which was already running that haskell. In fact, I believe it will certainly *not* be that one, since the FFI threads are a disjoint pool ( JaffaCake ? )
02:38:48 * hackagebot zoom-cache 0.2.1.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.2.1.0 (ConradParker)
02:38:50 <shachaf> quicksilver: Ah, I see.
02:39:30 <shachaf> For some reason I thought FFI calls happened from the same OS thread running the Haskell code in the bound thread.
02:40:04 <JaffaCake> quicksilver: no, in fact the implementation uses the same OS thread to run the Haskell code and the FFI calls in a bound thread
02:40:29 <JaffaCake> it turns out to be tricky to hand off an FFI call to a different thread, much easier to make it in the same thread
02:40:50 <shachaf> Ah. That might have been why I thought that. :-)
02:41:21 <Saizan> so basically a bound thread is in a one to one mapping with and OS one?
02:41:28 <JaffaCake> exactly
02:41:42 <shachaf> There are at least as many OS threads as there are bound threads?
02:41:43 <quicksilver> JaffaCake: does that mean that while bound threads are making safe FFI calls another generic thread is freed from the 'pool' to act as a capability?
02:41:53 <JaffaCake> shachaf: yep
02:42:00 <shachaf> forkOS actually *does* fork an OS thread, then?
02:42:07 <JaffaCake> quicksilver: right
02:42:14 <JaffaCake> shachaf: yes
02:42:17 <shachaf> Oh.
02:42:19 <JaffaCake> forkOS gives you 1-1 threads
02:42:29 <quicksilver> JaffaCake: ...and when the safe FFI completes, you will have "one more capability than expected" until next time the RTS has a chance to do its book-keeping?
02:42:30 <erus`> forkOS does a git clone of ubuntu?
02:42:54 <JaffaCake> quicksilver: not one more capability, no
02:43:19 <shachaf> When the forkOS-spawned thread terminates, an OS thread does also?
02:43:28 <JaffaCake> quicksilver: the OS thread returning from the FFI call is blocked until the other OS thread relinquishes the capability
02:43:48 <JaffaCake> shachaf: yes
02:44:05 <shachaf> Hmm. I guess bound threads are more heavyweight than I thought, then.
02:44:18 <shachaf> I was under the impression that if you didn't make any FFI calls, forkOS was nearly identical to forkIO.
02:44:39 <JaffaCake> I'll add that to the list of misconceptions about forkOS :)
02:45:17 <JaffaCake> we really need to find a way to document this so that it doesn't confuse people
02:45:21 <Saizan> so, forkOS is actually a better name than the misconceptions would make it look
02:46:16 <JaffaCake> so it *does* fork an OS thread, but the common misconception is that people think they need to do this to make FFI calls that don't block everything
02:46:40 <JaffaCake> because they have a preconception about lightweight threads vs. OS threads
02:47:20 <robert[]> haskell
02:48:21 <shachaf> Yes, I suppose my misconception was overcorrected from one side to the other.
02:48:31 <lpsmith> That bit about easier to make the safe call in the current thread and then migrating the capability to another thread reminds me a bit of the superior Erlang idiom to writing network servers;  the process that accepts a connection serves that client,  but forks another worker thread right at the beginning.
02:49:52 <JaffaCake> ah, I didn't know they did that
02:52:38 * shachaf freezes system by forkOSing 10000 threads.
02:54:15 <quicksilver> JaffaCake: aha.
02:55:17 <quicksilver> JaffaCake: so what happens if you fork more OS threads than capabilities?
02:55:38 <TotoTitus> i have trouble understanding a monad
02:55:56 <TotoTitus> look:
02:56:02 <JaffaCake> quicksilver: each capability can be animated by only one OS thread at a time, the others block (if they aren't doing FFI calls)
02:56:32 <quicksilver> JaffaCake: *nod*
02:56:32 * shachaf ought to read all the RTS commentary and such sometime.
02:56:33 <JaffaCake> bound threads are still scheduled by the RTS scheduler, as with other Haskell threads
02:56:59 <TotoTitus> [1,2] >>= \n -> ['a', 'b'] >>= \ch -> return (n, ch)
02:56:59 <JaffaCake> when a bound thread is scheduled, we hand over to its OS thread
02:57:16 <quicksilver> and freeze some other OS thread
02:57:24 <quicksilver> to keep the number of capabilities fixed?
02:57:55 <JaffaCake> right, the current OS thread releases the capability, and hands it over to the other OS thread
02:58:10 <TotoTitus> i do not understand, how does the rightmost lambda know of the 'n' binding of the previous lambda ?
02:58:24 <shachaf> TotoTitus: It's how lambdas work.
02:58:26 <shachaf> @google lexical scope
02:58:27 <lambdabot> http://en.wikipedia.org/wiki/Scope_(computer_science)
02:58:27 <lambdabot> Title: Scope (computer science) - Wikipedia, the free encyclopedia
02:58:38 <TotoTitus> no, i'm familiar with closures
02:58:57 <TotoTitus> i am reading LYAH, and the author previously used
02:58:59 <quicksilver> TotoTitus: would it help if I added some parens?
02:59:08 <shachaf> > [1,2] >>= \n -> (['a', 'b'] >>= \ch -> return (n, ch))
02:59:08 <quicksilver> [1,2] >>= (\n -> h)
02:59:09 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
02:59:15 <quicksilver> gah
02:59:16 <TotoTitus> Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))
02:59:21 <TotoTitus> he used parantheses
02:59:22 <shachaf> > ([1,2] >>= \n -> ['a', 'b']) >>= \ch -> return (n, ch)
02:59:23 <lambdabot>   [(n,'a'),(n,'b'),(n,'a'),(n,'b')]
02:59:25 <TotoTitus> were those just for emphasis ?
02:59:26 <quicksilver> [1,2] >>= (\n -> h)
02:59:37 <quicksilver> yes, they're just for emphasis
02:59:42 <quicksilver> but don't they answer your question?
02:59:47 <quicksilver> about how n is in scope.
02:59:55 <TotoTitus> i thought that somehow that forced the lexical scoping
02:59:56 <robert[]> hello
03:00:01 <robert[]> "scope"
03:00:06 <quicksilver> scoping is always lexical.
03:00:09 <robert[]> this is just lambda calculus
03:00:39 <quicksilver> the parents are implicit just because of the way we parse lambda, and because of the fixity of >>=
03:00:55 <shachaf> quicksilver: More the way we parse the lambda. :-)
03:01:18 <TotoTitus> ok, so in what order does [1,2] >>= \n -> (['a', 'b'] >>= \ch -> return (n, ch)) evaluate ?
03:01:35 <shachaf> TotoTitus: *Evaluate*? You don't know. :-)
03:01:37 <quicksilver> the left-most >>= is the outermost function call
03:02:01 <quicksilver> prefix notation might be clearer?
03:02:03 <TotoTitus> i think i understand
03:02:05 <quicksilver> if I call it bind:
03:02:10 <TotoTitus> go on
03:02:27 <quicksilver> bind [1,2] (\n -> bind ['a','b'] (\ch -> return (n,ch)))
03:02:51 <quicksilver> so it calls bind with two parameters, a list and a function.
03:03:31 <TotoTitus> the function itself calling bind
03:03:40 <quicksilver> well bind is just my renamed >>=
03:03:42 <shachaf> TotoTitus: "\x -> ..." always reads ... as far to the right as it can.
03:03:47 <quicksilver> I thought it might be easier to read
03:04:07 <quicksilver> shachaf: (no, it doesn't. I should have said the "infixity" of >>=; the special always to the right rule is not correctly implemented in haskell)
03:04:26 <quicksilver> shachaf: (id \x -> x) is a parse error.
03:04:37 <TotoTitus> tis' funny, i think i found monads easier to understand than functions as applicative functors (or so i feel)
03:04:39 <shachaf> Oh, I see.
03:04:50 <shachaf> > id do [] -- Also an error. :-(
03:04:50 <quicksilver> shachaf: some people consider this a bug in the haskell lexical syntax :)
03:04:51 <lambdabot>   <no location info>: parse error on input `do'
03:08:05 <TotoTitus> [1, 2] >>= \n -> ['a', 'b']
03:08:15 <TotoTitus> how do i make lambdabot evaluate this ?
03:08:30 <quicksilver> > [1, 2] >>= \n -> ['a', 'b']
03:08:31 <lambdabot>   "abab"
03:08:43 <quicksilver> TotoTitus: however please note that this is *not* a subexpression of the question you first asked.
03:09:07 <TotoTitus> yes, i can somehow feel that
03:09:13 <lpsmith> ok,  I suppose there is one other issue I was thinking about;  is there a way to incrementally produce results from IO?   As in,  I want to read things from IO in and put them in a list,  left-to-right,  as soon as they are available,   but I also want evaluation to proceed whether or not there is any demand for that list.   Thus unsafeInterleaveIO doesn't do what I want in this case.
03:09:21 <TotoTitus> though i can't grasp it completely yet
03:09:29 <quicksilver> lpsmith: unsafeInterleaveIO *never* does what you want.
03:09:34 <lpsmith> heh
03:09:51 <quicksilver> unless what you want is to abandon the bright light of understandable semantics and be eaten by a grue.
03:10:18 <lpsmith> but it's fun to venture into the land of unsafeInterleaveIO from time to time!
03:10:47 <quicksilver> you can probably unsafePerformIO a bunch of takeMVars or something
03:11:05 <quicksilver> but don't blame me when the demons break into your kitchen and eat your cookies.
03:11:13 <lpsmith> lol
03:11:39 <quicksilver> takeMVar is a reasonable way of blocking until something becomes available
03:11:39 <lpsmith> Well, I'd like to be able to hide the latency of fetching results from a database query, eventually
03:11:54 <lpsmith> make the parts of a pure list available ASAP
03:12:03 <quicksilver> I'd *hate* to use a database library which hid such vile things behind a pure interface
03:12:08 <quicksilver> please don't make it the default.
03:12:09 <lpsmith> (a pure list read in from a network socket, that is)
03:12:31 <lpsmith> but you shouldn't know that it's going on
03:12:43 <quicksilver> I will do when my network cable is unplugged
03:12:56 <quicksilver> and I suddenly get an IO error in an expected part of a pure computation
03:12:58 <quicksilver> with no way to recover
03:13:17 <lpsmith> It'll keep reading stuff and generating the list whether or not your pure code wants to look at it.
03:14:11 <quicksilver> I understand what you are describe, lpsmith
03:14:15 <quicksilver> I simply do not like it :)
03:14:41 <lpsmith> why not though?
03:14:43 <quicksilver> I lose control over when IO errors are reported and I lose control over when memory is consumed.
03:14:58 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-March/023073.html
03:15:05 <lpsmith> well, point taken to some degree about the IO
03:15:29 <quicksilver> ^^ one of many tants about interleaved IO on the -cafe, but particular DB relevant
03:15:35 <quicksilver> and from oleg.
03:15:38 <quicksilver> s/tants/rants/;
03:16:05 <lpsmith> I dont' see how it's as bad as you think.  After all, if you try to look at it from the same IO thread,  you are going to have to wait until the whole thing is read in.
03:16:05 <quicksilver> the capability you describe is interesting if not exposed behind a pure interface.
03:16:26 <quicksilver> just give me a IO [Future a] for some appropriate definition of Future
03:16:30 <quicksilver> (MVar may be enough)
03:19:41 <Alan> How do i get hGetLine to not leave the \r on the end from \r\n ?
03:23:44 <quicksilver> Alan: if you're in the write LineEndingMode it will translate automatically
03:24:05 <quicksilver> Alan: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#g:25
03:24:51 <Alan> hmm, i think i found it
03:24:51 <Alan> hSetNewlineMode
03:25:54 <quicksilver> yup
03:26:15 <Alan> yeah, i'm interacting with IRC which specifies \r\n line endings
03:26:39 <Alan> so i'm just putting the socket into a CRLF only lineending mode and using hGetLine and hPutStrLn
03:26:50 * quicksilver nods
03:26:56 <quicksilver> sounds like a plan!
03:26:59 <Alan> awesome
03:27:04 <Alan> nice to be validated :)
03:27:06 <quicksilver> traditionally all network services have used \r\n
03:27:16 <quicksilver> well, all text-based ones
03:27:21 <quicksilver> HTTP,SMTP,NNTP etc.
03:27:26 <Alan> strange that haskell doesn't have an automatic mode for that :P
03:27:45 <quicksilver> perhaps it is
03:28:02 <Alan> easy enough to make my own NewlineMode for it though
03:28:03 <quicksilver> hSetNewlineMode isn't hard to do though :)
03:32:31 <Alan> having great fun here, using parsec to parse IRC events...
03:48:51 * hackagebot exception-transformers 0.3.0.1 - Type classes and monads for unchecked extensible exceptions.  http://hackage.haskell.org/package/exception-transformers-0.3.0.1 (GeoffreyMainland)
03:53:51 * hackagebot exception-monads-tf 0.3.0.1 - Exception monad transformer instances for monads-tf classes.  http://hackage.haskell.org/package/exception-monads-tf-0.3.0.1 (GeoffreyMainland)
04:03:50 * hackagebot exception-mtl 0.3.0.1 - Exception monad transformer instances for mtl2 classes.  http://hackage.haskell.org/package/exception-mtl-0.3.0.1 (GeoffreyMainland)
04:32:03 <Alan> I swear i alternate between being amazed and disgusted at the IO monad...
04:35:23 <erus`> i have a retarded whitespace error
04:35:29 <erus`> it might be a bug in ghc
04:36:22 <quicksilver> erus`: unlikely. Show us?
04:36:27 <erus`> nope i'm the retarded one
04:38:38 <shachaf> quicksilver: It's very likely. GHC is full of bugs: http://hackage.haskell.org/trac/ghc/ticket/5492
04:39:34 * quicksilver isn't entirely sure what shachaf's poitn is
04:39:43 * shachaf isn't either.
04:39:45 * shachaf goes to sleep.
04:44:53 <erus`> > let _ = 7 in 87
04:44:53 <lambdabot>   87
04:44:54 <keep_learning> hello all
04:44:59 <keep_learning> i have a pcap file
04:45:09 <keep_learning> and  i am  able to read the data part
04:45:14 <absence> has anyone used the portaudio bindings? i just get silence when writing to the stream
04:45:28 <keep_learning> but not the packet time
04:45:47 <keep_learning> which i think resides in packet header
04:46:20 <keep_learning> is it possible to read the packet  header in haskell ?
04:46:42 <dmwit> ?faq is it possible to read the packet  header in haskell ?
04:46:42 <lambdabot> The answer is: Yes! Haskell can do that.
04:46:46 <erus`> keep_learning: which module?
04:46:56 <quicksilver> a pcap file is just a file
04:47:04 <quicksilver> surely haskell can read any file as well as any other language?
04:47:27 <dmwit> ?faq surely haskell can read any file as well as any other language?
04:47:27 <lambdabot> The answer is: Yes! Haskell can do that.
04:47:39 <dmwit> Okay, now I feel like a proper smartass.
04:47:46 <Eelis> @seen porges
04:47:46 <lambdabot> Unknown command, try @list
04:47:46 <preflex>  porges was last seen on #haskell 5 hours, 47 minutes and 4 seconds ago, saying: is anyone familiar with Alex? - more specifically, how to hack it to accept unicode inputs for the regex sections
04:48:12 <erus`> dmwit: you cant start a question with surely
04:48:32 <dmwit> Surely that's not true, is it?
04:49:01 <erus`> Surley that is not true </statement> <question> is it? </question>
04:49:22 <dmwit> I'm only surly because it's early.
04:49:28 <keep_learning> quicksilver: when i am opening the pcap file
04:49:44 <erus`> im gonna post on english.stackexchange.com
04:49:45 <keep_learning> i am getting data but not able to get pkt-time
04:50:51 <quicksilver> keep_learning: why are you not able to get it?
04:52:51 <keep_learning> quicksilver:  i don't know but if i am opening the same file in wireshark then its showing every thing quite well
04:53:02 <quicksilver> keep_learning: you're answering the wrong question :)
04:53:09 <quicksilver> a pcap file is just a file. In a weird format.
04:53:22 <quicksilver> what is preventing you reading the information from that file in haskell?
04:53:28 <quicksilver> perhaps you just don't understand the format?
04:53:33 <quicksilver> that's not haskell's fault...
04:53:47 <keep_learning> quicksilver: Yes , i think so :)
04:53:53 * hackagebot language-c-quote 0.3.0.1 - C/CUDA quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.3.0.1 (GeoffreyMainland)
04:53:56 <keep_learning> quicksilver: thank you
04:54:49 <quicksilver> there seems to be some info about the byte-level format at http://wiki.wireshark.org/Development/LibpcapFileFormat
04:57:08 <erus`> dmwit: i saw you post on reddit the other day. is that the same dmwit?
04:57:57 <Alan> ?faq solve world hunger
04:57:57 <lambdabot> The answer is: Yes! Haskell can do that.
04:58:07 <dmwit> Yes.
04:58:20 <Alan> awesome
04:58:41 <dmwit> erus`: Yes. Which post? (Or is it something embarassing...?)
04:58:52 <Alan> food = nom : food
04:58:54 * hackagebot libltdl 0.1.0.3 - FFI interface to libltdl  http://hackage.haskell.org/package/libltdl-0.1.0.3 (GeoffreyMainland)
04:58:54 <erus`> in jailbait
04:58:56 <Alan> problem solved
04:59:28 <keep_learning> ?faq haskell can read pcap file ?
04:59:28 <lambdabot> The answer is: Yes! Haskell can do that.
04:59:43 <dmwit> huh
04:59:51 <keep_learning> ?faq how :)
04:59:51 <lambdabot> The answer is: Yes! Haskell can do that.
05:00:20 <dmwit> erus`: Must not be the same dmwit. I can't find any posts in jailbait by me in the last month.
05:00:48 <dmwit> (I'm pretty sure I've never posted in jailbait.)
05:00:56 <robert[]> Lets think about simple type theory
05:01:04 * dmwit shrugs
05:01:08 <dmwit> robert[]: Yes, let's!
05:01:14 <robert[]> (A -> B) -> A -> B
05:01:16 <erus`> i cant believe they close jailbate. Reddit is full of self righteous pricks
05:01:23 <absence> what's the easiest way to output streaming audio in haskell?
05:01:31 <robert[]> erus`: reddit has been full of censorship well before this
05:01:51 <robert[]> erus`: if you're only picking that up now... well it's probably because someone told you to think it
05:02:32 <erus`> robert[]: i havnt seen much else censored, unless by idiot mods
05:02:50 <dmwit> This is probably a bit off-topic.
05:03:00 <dmwit> try #haskell-blah =)
05:03:54 * hackagebot mainland-pretty 0.1.0.3 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.1.0.3 (GeoffreyMainland)
05:03:56 * hackagebot ref-fd 0.3.0.1 - A type class for monads with references using functional  dependencies.  http://hackage.haskell.org/package/ref-fd-0.3.0.1 (GeoffreyMainland)
05:04:22 <robert[]> rt
05:04:57 <angstrom> @pl \n l -> filter (==n) l
05:04:58 <lambdabot> filter . (==)
05:05:04 <robert[]> they proably shut it down to troll free speechers
05:10:43 <robert[]> simple type lambda calculus
05:10:52 <robert[]> the types system is jwhat exactly?
05:11:03 <Harwin> Haskell looks confuse.
05:11:08 <robert[]> if T, T' is a type then T -> T' is
05:11:11 <robert[]> but what else?
05:11:24 <dmwit> robert[]: STLC usually comes with a few base types.
05:11:38 <dmwit> robert[]: Bool, Nat, and String are popular choices.
05:11:39 <robert[]> and what is the type of \x -> x?
05:11:53 <dmwit> robert[]: \x -> x is not an STLC term. \x : Bool -> x is.
05:11:59 <dmwit> (And then the type is obvious.)
05:12:47 <dmwit> I suppose you could specify a STLC in which \x -> x was a term, and then for any particular choice of type T that's well-formed in context G, you could say G |- \x -> x : T -> T
05:13:23 <dmwit> (Unlike in Haskell, STLC terms in that system wouldn't necessarily have principle types.)
05:13:54 * hackagebot ref-tf 0.3.0.1 - A type class for monads with references using type families.  http://hackage.haskell.org/package/ref-tf-0.3.0.1 (GeoffreyMainland)
05:15:14 <dmwit> Writing code in STLC is no fun at all.
05:15:51 <dmwit> gotta run
05:15:54 <robert[]> lets use STLCK
05:15:59 <robert[]> as a notation for proofs
05:16:05 <robert[]> of propositional logic
05:17:01 <robert[]> maybe #haskell
05:17:03 <robert[]> is a good place to ask
05:17:10 <robert[]> > who here does normalization proofs
05:17:11 <lambdabot>   Not in scope: `who'Not in scope: `here'Not in scope: `does'Not in scope: `n...
05:17:28 <robert[]> theoretical question about normalization proof
05:18:55 <robert[]> how about using numbers in the type system
05:19:02 <robert[]> (1 -> 2) -> 1 -> 2
05:19:06 <robert[]> instead of letters
05:19:17 <robert[]> (X -> Y) -> X -> Y
05:20:39 <sipa> to solve what problem?
05:21:14 <robert[]> my view is that type systems are jnust another lambda calculus
05:21:23 <robert[]> infact they ARE lambda calculus
05:21:28 <sipa> yes
05:21:42 <sipa> second-order
05:21:52 <robert[]> wonderful
05:22:09 <sipa> System F is lambda calculus on the level of both values and types
05:22:27 <sipa> and you can go further by introducing calculus over the "type of types", called kinds
05:22:36 <robert[]> nice
05:22:43 <robert[]> the language is universaly
05:22:46 <robert[]> truly universal
05:27:43 <erus`> (1 -> 2) -> 1 -> 2 = 2
05:27:49 <erus`> why not 2
05:28:16 <robert[]> hmmm
05:28:52 <robert[]> and then 3?
05:29:36 <erus`> why have number as types?
05:30:00 <erus`> do you mean like 2 = S (S Z)
05:30:13 <erus`> but then what about floating point?
05:30:20 <erus`> and minus numbers?
05:30:40 <robert[]> no
05:30:42 <robert[]> just natural numbers
05:30:52 <robert[]> I dont beleive in interegers
05:30:56 <robert[]> or anything beyond
05:31:31 <erus`> what about a type that takes a type and returns a type to a type type type type....
05:31:35 <robert[]> haha
05:33:36 <sipa> you dawg we heard you like types so we made a type of the types of the types of the types ...
05:33:54 * hackagebot srcloc 0.1.1.1 - Data types for managing source code locations.  http://hackage.haskell.org/package/srcloc-0.1.1.1 (GeoffreyMainland)
05:33:56 * hackagebot symbol 0.1.1.1 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.1.1.1 (GeoffreyMainland)
05:44:39 <erus`> @list
05:44:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:44:47 <harriotq> I fell in love with Haskell.  However, here's my initial impression on actually trying to use the platform:  70% of packages I've tried so far fail to compile or install for some other (sometimes even unmeantioned) reason on os x 10.6.  I don't mean to say this as a complaint or anything.  Just an observation from a random new user.
05:45:31 <erus`> @djinn (a, b) -> (m c a, b)
05:45:31 <lambdabot> -- f cannot be realized.
05:45:53 <ketil> There's no built-in xor function?  (Bool -> Bool -> Bool)?
05:46:20 <luite> harriotq: do most of those depend on a non-haskell library?
05:46:22 <erus`> @djinn m c (a, b) -> (m c a, b)
05:46:22 <lambdabot> -- f cannot be realized.
05:46:52 <applicative> harriotq, yes, hackage is huge now and its been there for a few years, but there's a new version of the compiler every five minutes, etc
05:46:55 <harriotq> luite: dependencies are so wide and varied, as a new user, it's very hard to tell
05:47:02 <erus`> @djinn m (a, b) -> (m a, b)
05:47:02 <lambdabot> -- f cannot be realized.
05:47:30 <sipa> erus`: that would amount to extracting the return value b out of the monadic action
05:47:45 <erus`> bummer
05:47:49 <sipa> @djinn m (a, b) -> (m a, m b)
05:47:49 <lambdabot> -- f cannot be realized.
05:48:02 <applicative> harriotq: which version of ghc are you using on os x?
05:48:03 <sipa> given that m is a monad, it can
05:48:12 <sipa> but djinn doesn't know that :)
05:49:02 <applicative> harriotq I have very good luck with the 32 bit haskell platform ghc 7.0.2 linking with system c libraries and homebrew nonsense
05:49:03 <harriotq> applicative: 7.0.3 (the default platform)  Also tried compiling the latest, but then even more packages fail because they haven't been updated in a while and some even require base < 4.4
05:50:23 * applicative can remember if he had a reason for preferring 7.0.2 over 7.0.3
05:50:31 <harriotq> oh that, yes I'm trying to run on x86_64
05:51:23 <applicative> harriotq, yes, I dropped that since I couldn't compile newer ghc's with it (my incompetence no doubt) but then I found a lot of other stuff 'just worked'
05:53:05 <harriotq> Is there a way to tell if some package depends on some native library or not, just by using cabal?
05:53:55 <harriotq> I surely fetched the archive.tar (or something) and that helps a lot
05:54:19 <Alan> manyTill anyChar (try (char ':' <|> string " :" <|> eof))
05:54:47 <Alan> Couldn't match expected type `Char' against inferred type `[Char]'
05:54:54 <Alan> what's going on there :|
05:55:43 <Boney_> Alan: the [] around the type denote the list type.
05:55:55 <Alan> i understand the error
05:56:05 <Boney_> oh right.
05:56:06 <Boney_> sorry.
05:56:08 <Alan> I don't understand how it applies to this particular line :|
05:56:13 <robert[]> preservation and progress
05:56:16 <robert[]> lets talk about it
05:56:16 <sipa> :t char
05:56:17 <lambdabot> Char -> Doc
05:56:43 <harriotq> maybe a package system is not that helpful as an idea to begin with, because how could it possibly work?  even in theory
05:56:54 <Boney_> Alan: in that case I'm not farmiliar enough with parsec to awnser.
05:57:05 <Boney_> which is what it looks like your using (as far as I can guess)
05:57:25 <hpaste_> Alan pasted “strange error” at http://hpaste.org/52516
05:57:30 <Alan> http://hpaste.org/52516
05:57:35 <Alan> oh
05:57:35 <Alan> hahah
05:58:17 <sipa> :t manyTill
05:58:17 <lambdabot> Not in scope: `manyTill'
05:58:21 <erus`> @hoogle (a -> m (b, a)) -> a -> m (b, a)
05:58:21 <lambdabot> No results found
05:58:37 <erus`> @hoogle (a -> m (b, a)) -> a -> m [b]
05:58:37 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
05:58:48 <danr_> So, which is the standard pretty printing library for Haskell nowadays?
05:59:22 <sipa> erus`: what do you want to do?
05:59:30 <erus`> unfold with a monad
06:00:41 <applicative> harriotq, maybe there could be some way for cabal install to warn you about C libraries and so on.
06:01:03 <Alan> anybody got an idea what is causing my error?
06:01:21 <applicative> harriotq, but the main thing to look out for is how recently the package has been updated. If not for 6 months you are likely to have to 'update' it yourself, which is usually simple
06:02:16 <quicksilver> Alan: char ':' <|> string ": " doesn't typecheck
06:02:41 <quicksilver> Alan: the first is a Parser returning Char and the second is a Parser returning String
06:02:48 <Alan> quicksilver: AH, i see
06:02:55 <quicksilver> similarly "eof" is a Parser returning ()
06:03:10 <Alan> I don't actually care about the result of the parser
06:03:20 <Alan> (as evidenced by it being in the second part of a manyTill)
06:03:41 * quicksilver nods
06:03:51 <quicksilver> you can ignore the results of parsers with $>
06:03:53 <quicksilver> :t ($>)
06:03:54 <lambdabot> Not in scope: `$>'
06:03:54 * hackagebot alsa-gui 0.0.1 - Some simple interactive programs for sending MIDI control messages via ALSA  http://hackage.haskell.org/package/alsa-gui-0.0.1 (HenningThielemann)
06:04:00 <quicksilver> erm
06:04:02 <quicksilver> :t (<$)
06:04:03 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
06:04:05 <quicksilver> that one :)
06:04:15 <quicksilver> I'm not sure if parsec has it by another name
06:04:40 <quicksilver> (() <$ char ':') <|> (() <$ string " :") <|> eof
06:05:38 <Alan> kinda like the functor equivalent of const?
06:05:47 <applicative> or manyTill anyChar (try ((string ":" <|> string " :" <|> fmap (const "eof!") eof)))
06:05:55 <robert[]> I have a question
06:05:57 <robert[]> about names
06:06:01 <robert[]> if anyone knows STLC?
06:06:06 <robert[]> simple typed lambd acalculus
06:06:22 <quicksilver> Alan: yes.
06:06:23 <sipa> robert[]: please stop asking to ask
06:06:28 <sipa> robert[]: just ask if you have a question
06:06:35 <quicksilver> Alan: it is, actually "fmap (const ())"
06:06:46 <absence> i was hoping import qualified Data.Array.Repa as R followed by import Data.Array.Repa ((:.), Z) would let me use Z and :. without R prefix, but i get data constructor not in scope errors. what am i missing?
06:06:53 <quicksilver> the other way you see it written is
06:07:08 <quicksilver> (char ':' >> return ()) <|> (string " :" >> return())
06:07:11 <Alan> :t fmap
06:07:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:07:25 <quicksilver> Alan: like this:
06:07:30 <quicksilver> > fmap (const ()) [1,2,3,4]
06:07:31 <lambdabot>   [(),(),(),()]
06:07:57 <quicksilver> absence: that's not how you import constructors
06:08:03 <erus`> @hoogle a -> m [a] -> m [a]
06:08:04 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
06:08:04 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
06:08:04 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
06:08:09 <Alan> > map (const ()) [1,2,3,4]
06:08:10 <lambdabot>   [(),(),(),()]
06:08:13 <Alan> heh
06:08:21 <quicksilver> import Data.Array.Repa(TypeName((:.),Z))
06:08:36 <quicksilver> where TypeName is the name o fthe type hose are constructors for.
06:08:55 * hackagebot air 2011.7.25 - air  http://hackage.haskell.org/package/air-2011.7.25 (JinjingWang)
06:08:58 <Alan> quicksilver: i see ...
06:10:10 <Alan> :t <*
06:10:11 <lambdabot> parse error on input `<*'
06:10:18 <Alan> :t (<*)
06:10:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
06:10:35 <Alan> :t (<$)
06:10:36 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
06:10:46 <absence> quicksilver: ah, thanks
06:10:49 <Alan> hmmm
06:11:10 <quicksilver> Alan: <* takes two actions and performs both, but returns the value from the left
06:11:27 <quicksilver> Alan: <$ takes an action on the right (which it performs) and a plain value on the left (which it returns)
06:11:39 <quicksilver> x <$ a === pure x <* a
06:11:51 <quicksilver> or replace pure with return if you're more familiar with that.
06:12:25 <Alan> ok
06:12:52 <Alan> @hoogle (<$)
06:12:53 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
06:12:53 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
06:12:53 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
06:13:54 * hackagebot vector-bytestring 0.0.0.0 - ByteStrings as type synonyms of Storable Vectors of Word8s  http://hackage.haskell.org/package/vector-bytestring-0.0.0.0 (BasVanDijk)
06:15:08 <Ferdirand> hello, wise people of #haskell
06:17:12 <Entroacceptor> Be welcome, dear stranger.
06:17:13 <applicative> absence import qualified Data.Array.Repa as R; import Data.Array.Repa (Z (..) , (:.) (..))
06:18:22 <robert[]> I have a queston baout simple typed lambda calculus
06:18:31 <robert[]> is that acceptable
06:18:57 * hackagebot hack2-handler-warp 2011.10.12 - Hack2 warp handler  http://hackage.haskell.org/package/hack2-handler-warp-2011.10.12 (JinjingWang)
06:18:58 * hackagebot hack2-handler-snap-server 2011.10.12 - Hack2 Snap server handler  http://hackage.haskell.org/package/hack2-handler-snap-server-2011.10.12 (JinjingWang)
06:19:09 <Entroacceptor> robert[]: try and see if you get flamed or ignored
06:19:09 <quicksilver> robert[]: when sipa said "14:12 < sipa> robert[]: please stop asking to ask
06:19:19 <applicative> absence, :. and Z are constructors of themselves, so to speak
06:19:19 <quicksilver> he wasn't tell you not to discuss it
06:19:32 <quicksilver> he was just saying, ask the question.
06:19:56 <applicative> what is the question robert[]
06:19:58 <erus`> http://stackoverflow.com/questions/7740793/is-this-a-common-function
06:20:14 <deech`> Hi all, someone just asked me if using pattern-matching on tuple argument to a function is better to extract the elements is better than using "fst" and "snd". Is it true that pattern-matching (without the "_" wildcard) forces the elements of the tuple even if they are not being used, whereas "fst" and "snd" don't?
06:20:36 <dmwit> ?tell ketil (/=) is the built-in xor
06:20:36 <lambdabot> Consider it noted.
06:20:50 <earthy> deech`: yes. unless you use an irrefutable match.
06:21:52 <deech`> earthy: Thanks!
06:21:59 <quicksilver> erus`: there are a few possible ways to write unfoldM, see http://www.haskell.org/pipermail/haskell-cafe/2003-April/004144.html
06:22:03 <earthy> deech`: so  f (x,y) = foo x y    *will* force the tuple, whereas   f ~(x,y) = foo x y    and f t = foo (fst t) (snd t)  will not force the tuple
06:22:19 <magicman> > case undefined of {(a,b) -> const 5 a}
06:22:20 <lambdabot>   *Exception: Prelude.undefined
06:22:24 <earthy> note that this forcing only holds for the tuple, not it's elements...
06:22:30 <magicman> > case undefined of {~(a,b) -> const 5 a}
06:22:31 <lambdabot>   5
06:22:57 <applicative> erus` I see an unfoldrM in http://hackage.haskell.org/packages/archive/monad-loops/0.3/doc/html/Control-Monad-Loops.html
06:23:14 <erus`> aw man i got a downvote :(
06:23:33 <erus`> but no vote for close
06:24:00 <erus`> unfoldr doesnt return a list though. Is it still the same thing?
06:24:05 <applicative> erus` and check out vector http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector-Fusion-Stream-Monadic.html
06:24:12 <dmwit> deech`: earthy is being imprecise (and possibly so are you): the pattern f (x, y) = foo x y will *not* force the *elements* of the tuple.
06:24:55 <earthy> dmwit: I stated that. explicitly. :)
06:24:55 <dmwit> It forces only as much as necessary to match that pattern, namely, it forces evaluation until it's sure that the (,) constructor is used.
06:24:58 <magicman> > let f (x,y) = 5 in f (undefined, undefined)
06:24:59 <lambdabot>   5
06:25:18 <dmwit> earthy: Okay. But you answered "yes" to a question whose answer was "no", so I just thought I'd double-check. =)
06:25:46 <dmwit> ah
06:25:48 <dmwit> I see, you said that later.
06:25:52 <dmwit> =)
06:25:57 <earthy> oh, wait, right, I didn't read the end of the sentence very closely
06:25:58 <earthy> my bad
06:26:00 * dmwit reads slowly
06:26:31 <deech`> dmwit, earthy: Thanks for the clarification, I was wrong in my assumptions.
06:26:39 <applicative> There isn't an extension that permits sections of type operators, right?  I guess it would be TypeOperators.
06:26:51 <erus`> i did just write Control.Monad.Loops.unfoldrM
06:27:04 <robert[]> dmwit:,
06:27:12 <robert[]> ever seen this before
06:27:41 <robert[]> Gamma |- s : S  and  Gamma,S |- t : T ==>  Gamma |- t[0:=s] : T
06:28:35 <robert[]> t[0:=s] means substitute s into variable with index 0
06:28:55 * hackagebot nemesis 2011.10.12 - a Rake like task management tool  http://hackage.haskell.org/package/nemesis-2011.10.12 (JinjingWang)
06:30:19 <Ferdirand> I was wondering what would be the proper abstraction to wrap any algo that operates on integers, into something that operates on any bounded inputs of class Eq or Ord
06:31:08 <quicksilver> applicative: well you can't partially apply normal types, so it would only be left sections
06:31:17 <quicksilver> applicative: and that would seem a bit half-hearted? :)
06:31:56 <Ferdirand> I was under the impression I needed the opposite of what Functor provides
06:32:32 <applicative> quicksilver, right, i wanted a left section, (r :-) but a suitable extension was too much to hope for.
06:32:55 <applicative> Ferdirand: is there only one opposite of what Functor provides
06:33:33 <Ferdirand> applicative: no, that's the problem. I found about co/contrafunctor (a -> b) -> f b -> f a
06:33:54 * hackagebot DSH 0.7.1 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.7.1 (GeorgeGiorgidze)
06:34:09 <Ferdirand> here I'd need (Wrapped a -> Wrapped a) -> a -> a
06:34:19 <KitB> If I wanted to make a type synonym for a list of some type that was an instance of a typeclass, how would I do that?
06:34:27 <KitB> i.e.
06:34:36 <Ferdirand> and make that work on higher arity functions too
06:34:41 <robert[]> hih
06:34:51 <KitB> type NumList = (Num a) => [a]
06:34:59 <Ferdirand> there's got to be some crazy abstract nonsense that matches that abstraction, i'm sure
06:36:58 <quicksilver> Ferdirand: you could try something which explicitly uses an Iso a Int
06:37:06 <applicative> KitB, dont put class constraints on types. Put them on the functions; you'll have to anyway
06:37:08 <quicksilver> to convert from a to Int, perform algorithm, and convert back
06:37:34 <Ferdirand> hoogle doesn't know Iso it seems
06:38:38 <applicative> if Wrapped is applicative and there is an extract function  then ferdirand ff x = extract $ ff <*> pure x , no?
06:39:10 <quicksilver> Ferdirand: data Iso a b = MkIso (a -> b) (b -> a)
06:39:27 <quicksilver> I'm not sure if it exists anywhere in particular. I'd expect it to be in category-extras but I can't see it.
06:39:27 <KitB> applicative: I want the type to be easily readable as exactly what it is though (and the NumList example is not what I'm actually doing)
06:42:15 <kmc_> deech`, no, pattern-matching a tuple does not necessarily force the *elements*
06:42:22 <kmc_> deech`, it forces the tuple constructor itself
06:42:26 <kmc_> fst and snd will do the same thing
06:42:28 <KitB> applicative: -XRank2Types sorts it out the way I want it
06:43:45 <kmc_> it looks like others gave enough examples to clarify that, so, cool :)
06:43:47 <applicative> KitB, I can't believe it's doing anything but making it legal, but I'm not sure.  If you are willing to wrap you can do all kinds of goofy things.
06:43:54 * hackagebot maid 2011.10.12 - A simple static web server  http://hackage.haskell.org/package/maid-2011.10.12 (JinjingWang)
06:44:41 <Ferdirand> quicksilver, applicative: thanks. I think i'll start with a non-polymorphic non-abstract version.. i'm not grokking the crazy abstract nonsense enough here.
06:45:20 * applicative should have called it lowerFerdinand :: (W a -> W b) -> (a -> b)
06:45:48 <bscarlet> Is it possible to write a Monad or Monad transformer that provides an interface to state within the monad like IORef does for IO? I presume at least something like existential types would be required, but I can't seem to figure out a way to do it. (Would I need dependent types?)
06:46:29 <kmc_> bscarlet, the question is like "can I implement ST in pure Haskell"?
06:48:35 <quicksilver> the answer appears to be no, bscarlet
06:48:46 <quicksilver> that is, you can't implement a fully polymorphic newSTRef
06:48:59 <bscarlet> kmc_: I guess, yeah. I haven't looked at ST much. I had lumped it together with IO.
06:49:04 <quicksilver> you can implement one which works for a given set of types (i.e. typeclass constrained)
06:49:06 <kmc> yeah, it's very similar
06:49:11 <quicksilver> in a way, it's strange that you can't do this.
06:49:20 <kmc> the implementation of ST and IO is almost the same in GHC
06:49:21 <quicksilver> it is an expressibility hole that peple have noted before
06:49:35 <kmc> bscarlet, the simplest way to do something like ST in pure Haskell would involve Data.Dynamic
06:49:54 <Saizan> or just unsafeCoerce
06:50:09 <kmc> yeah, if you enforce abstraction of STRefs properly, you can use unsafeCoerce
06:50:15 <kmc> but neither is quite "pure Haskell"
06:50:22 <quicksilver> unsafeCoerce alone isn't enough
06:50:29 <quicksilver> you need some reification of types
06:50:32 <Saizan> how so?
06:50:40 <Saizan> the reference identity is enough
06:50:58 <Saizan> it's not like ST compares types
06:50:59 <quicksilver> oh, I see.
06:51:02 <applicative> deech` if you want the function to get inside the tuple you also need to define strict pairs, or something with fields fitted to the material.
06:51:11 <Cale> You can implement ST, it's just runST that's the tricky bit ;)
06:51:24 <bscarlet> Yeah, I was wondering about the pure question. Thanks.
06:52:36 <kmc> type Store = Map Int Dynamic; newtype ST s a = ST (Store -> (a, Store)); newtype STRef s a = STRef Int
06:53:45 <kmc> there's also a garbage collection problem here
06:54:00 <bscarlet> Yeah, I figured I'd need weak references too.
06:54:02 <applicative> deech` show your friend p 30 ff of http://blog.johantibell.com/2010/09/slides-from-my-high-performance-haskell.html They worked for me :)
06:54:36 <kmc> yeah
06:54:48 <kmc> if you're using RTS magic like weak references, then you might as well use real refs ;)
06:58:21 <cwl> TimeoutManager for Snap
06:58:45 <cwl> forkIO $ managerThread tm  in function initialize
06:59:14 <cwl> does it create a thread for each timeoutManager?
06:59:41 <kmc> i don't know anything about Snap, but forkIO does create a Haskell thread, yes
07:00:03 <kmc> which in GHC is not the same as an OS thread
07:00:22 <cwl> kmc: http://snapframework.com/docs/snap-server-hpc/Snap.Internal.Http.Server.TimeoutManager.hs.html source code here, not much
07:00:49 <cwl> kmc: I just think it cost too much resource
07:01:06 <kmc> GHC's threads are very cheap
07:01:15 <kmc> you can spawn 100,000 of them on a modest machine
07:01:32 <cwl> kmc: wow
07:01:32 <kmc> there's a whole subsystem to efficiently manage timeouts and IO across many threads
07:01:33 <kmc> do you have evidence that this is a problem?
07:02:05 <cwl> kmc: nope, just feeling
07:02:16 <kmc> ok
07:02:55 <cwl> kmc: just regard the thread as something like process for the OS
07:03:02 <kmc> yeah
07:03:07 <kmc> that's not how it works in GHC
07:03:21 <kmc> you have only one OS thread per CPU core
07:03:22 <cwl> how it works in GHC
07:03:30 <kmc> (oversimplifying, but it's on that order of magnitude)
07:04:01 <kmc> you can spawn millions of threads and do timeouts and blocking IO from all of them
07:04:15 <kmc> the runtime system will implement that with efficient calls to your OS's event-based IO mechanisms
07:04:19 <kmc> e.g. select, kqueue, epoll
07:04:49 <kmc> it seems most programmers have an attitude of "avoid threads at all costs", and will go through bizarre contortions to do so
07:04:58 <kmc> in GHC Haskell, threads actually don't suck, they're a reasonable tool for solving problems
07:05:00 <kmc> even small problems
07:05:38 <tibbe> any questions re the I/O manager?
07:05:41 <cwl> having each thread for one timeout manager makes the code clean
07:05:57 <cwl> :-)
07:06:14 <cwl> It is too great that thread is cheap
07:06:29 <kmc> yes
07:06:34 <kmc> it really is a killer feature of Haskell
07:06:34 <tibbe> so we want one I/O manager thread per CPU core, as the I/O manager thread actually makes a block sys call (to epoll)
07:08:54 * hackagebot monad-atom 0.2.0 - Monadically convert objects to unique atoms and back.  http://hackage.haskell.org/package/monad-atom-0.2.0 (GrzegorzChrupala)
07:11:47 <tristes_tigres> If threads in GHC runtime are so good, can one use GHC runtime as VM targeted by other languages?
07:11:50 <rostayob> when I try to run simple commands with the graphviz library, I get "fd:4: hClose: resource vanished (Broken pipe)"
07:12:02 <kmc> tristes_tigres, I've thought about that
07:12:11 <tristes_tigres> kmc: and ?
07:12:16 <kmc> still thinking :)
07:12:21 <josiah14> I'm coming from an asm, C++, Java background
07:12:22 <kmc> i think the simplest way is to compile your language to Haskell
07:12:27 <kmc> http://hackage.haskell.org/package/berp is an example of this
07:12:28 <tristes_tigres> Penny for your thoughts!
07:12:35 <josiah14> what math should I learn/relearn for programming Haskell
07:12:53 <robert[]> math??
07:13:01 <kmc> josiah14, I don't think there's any particular math you need, why do you ask?
07:13:33 <Alan> hmmm... so i want to get lines from a network socket as a lazy list
07:13:37 <robert[]> there's a haskell thread ono the 4chan science board
07:13:45 <robert[]> should I linked it?
07:13:46 <josiah14> I saw some solutions for the fibionacci sequence that were pretty math intensive to get the computer to comput the sequence quickly (utilizing identities, matrix algebra, logarithms, etc.)
07:13:49 <Alan> am i making a [IO String] or a IO [String] ?
07:13:59 <kmc> IO [String]
07:14:04 <kmc> a single IO action which produces a list
07:14:05 <robert[]> josiah14: that's math people playing around, not normal haskell
07:14:07 <kmc> not a list of IO actions
07:14:20 <josiah14> made me a little concerned that I'll have to brush up on my identites and such
07:14:24 <Alan> but surely it is a list of IO actions?
07:14:27 <kmc> josiah14, what if you saw some C++ code for the fibionacci sequence that were pretty math intensive to get the computer to comput the sequence quickly
07:14:33 <Alan> hGetLines h = hGetLine h : hGetLines
07:14:44 <kmc> Alan, that would be a list of IO actions, yes
07:14:45 <Alan> erm, i missed the last h
07:14:49 <Alan> but you get the idea
07:14:54 <kmc> but that's not useful
07:14:59 <josiah14> i suppose thats a good point
07:15:01 <kmc> in this case
07:15:19 <kmc> i'm sure i can find such codes
07:15:28 <kmc> a lot of insane mathematical / numerical stuff is written in C, C++, Fortran
07:16:02 <josiah14> they seem to be the easiest to write fast running math intensive software in
07:16:06 <josiah14> for whatever reason
07:16:08 <kmc> yeah
07:16:19 <Alan> ... i just realised i'm dumb
07:16:27 <Alan> i'm looking at repeat (hGetLine h)
07:16:30 <kmc> easiset or at least most common
07:16:36 <Alan> right?
07:16:37 <josiah14> I like other languages a lot, but if I'm concerned about writing an algorithm to do a fast computation, I go to C++
07:16:41 <kmc> Alan, yeah
07:16:57 <kmc> josiah14, do you try it in a high-level language first?
07:17:04 <kmc> often people overestimate their need for speed
07:17:28 <josiah14> sometimes.  Most of the time, Java or C# is sufficient
07:17:31 <josiah14> like you said
07:17:32 <tristes_tigres> josiah14: you should go for Fortran if you need fast computations
07:17:46 <kmc> Haskell is a good language for writing simple code and getting respectable performance
07:17:55 <kmc> even if it's not as fast as hand-tuned C code
07:18:00 <tristes_tigres> not C++
07:18:09 <josiah14> but if im writing a calculation that i know will be hit fairly consistently and frequently, i go to C++
07:18:15 <josiah14> i actually dont know fortran
07:18:29 <josiah14> i would probably use it if i did
07:18:29 <tristes_tigres> josiah14: Modern fortran is quite nice
07:19:02 <Alan> :t mapM_
07:19:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:19:34 <kmc> Alan, the problem with "lazy IO" is that it breaks a fundamental rule of Haskell.  normally, forcing evaluation (of list cells) can't cause execution
07:19:37 <josiah14> maybe fortran will be my next project after Haskell
07:19:51 <kmc> Alan, so all the "lazy IO" primitives in the standard library are implemented using unsafeInterleaveIO
07:20:05 <kmc> that's not to say an IO action can never return an unevaluated thunk
07:20:13 <kmc> but it can't return a thunk whose forcing executes more IO
07:20:15 <kmc> without said hacks.
07:20:19 <tristes_tigres> josiah14: comapred to C++ or Haskell, it's a simple language
07:21:08 <josiah14> good to know, so it wont be as daunting as Haskell is, then
07:21:08 <josiah14> haha
07:21:20 <tristes_tigres> besides, most (good) libraries for numerical work are in fortran
07:21:21 <josiah14> i like haskell, but its a lot to absorb
07:22:09 <kmc> yes
07:23:39 <josiah14> actually i was looking at a comparison of a Euler problem implemented in C++, Python, Haskell, and Erlang, and Haskell was the second fastest, very close to C++.  So i realize, once I master the language, in many cases the difference between C++ and Haskell wont matter for me.
07:23:58 <Alan> hGetContents is lazy?
07:24:04 <kmc> yeah Alan
07:24:09 <quicksilver> Alan: hGetContents is broken.
07:24:16 <quicksilver> "lazy" means something else.
07:24:31 <kmc> josiah14, yeah.  I find that the naive Haskell code is usually fast enough, and you can optimize from there, up to and including calling a C function
07:24:38 <Alan> am I going about this wrong?
07:24:46 <kmc> josiah14, so you can get great speed, when you need it, otherwise you have good speed with low effort
07:24:51 <quicksilver> lazy evaluation is a very clever evaluation scheme which defers work until necessary while still sharing it between subexpressions.
07:24:57 <tristes_tigres> josiah14: In Haskell it is harder to reason about performance, than in imperative languages
07:25:00 <kmc> josiah14, it seems that C++ code always runs fast but it's a lot of work to get it working at all
07:25:06 <Alan> I want to express my computation as mapping an evaluation function over the lines of input
07:25:15 <geekosaur> problem is, Haskell libs have this thing the call "lazy I/O", which is more or less broken by design
07:25:17 <Alan> which *must* be evaluated lazily because... it's a network socket
07:25:26 <quicksilver> "interleaved IO" (like getContents) is a nasty (but something useful) way of concealing IO within pure operations
07:25:36 <geekosaur> ^^ that
07:25:38 <tristes_tigres> a lot of stuff going on behind the scenes in Haskell
07:25:42 <Alan> and the current way i'm doing it feels very ugly, because it's basically an infinite loop
07:25:46 <geekosaur> there are better ways to do it
07:25:58 <quicksilver> unfortunately some people call this "lazy" because there is a strong natural analogy with lazy evaluation
07:26:04 <quicksilver> but I really think it would be better to use another word :(
07:26:28 <geekosaur> that said, infinite loop is quite the proper way to do many things in Haskell, becuase data-directed evaluation (possibly a better name than "lazy" means infinite isn't, necessarily
07:26:36 <kmc> tristes_tigres, that's mostly not about 'imperative' versus 'functional', though
07:26:45 <josiah14> kmc:  Yah, i noticed that.  My intro computer language was C++, and I remember just getting bizarre errors that even my professors had trouble with
07:26:48 <Alan> what i really want it something like "mapM_ eval $ repeat (hGetLine h)"
07:27:09 <tristes_tigres> kmc: you mean, more about lazy vs strict?
07:27:19 <quicksilver> Alan: well, you may really want "fmap lines hGetContents"
07:27:20 <kmc> lazy vs. eager, to be precise
07:27:26 <quicksilver> but it's nasty
07:27:26 <kmc> tristes_tigres, and also just that Haskell is a very high-level language
07:27:33 <kmc> that's why there's a lot going on behind the scenes
07:27:37 <quicksilver> because you can't deal sensibly with error conditions
07:27:53 <quicksilver> (which are quite likely on sockets)
07:27:59 <tristes_tigres> geekosaur: why "lazy IO" is broken by design?
07:28:06 <Alan> quicksilver: will that method take into account hSetNewlineMode?  does hGetContents translate newlines according to the newline mode?
07:28:08 <geekosaur> see above
07:28:13 <quicksilver> Alan: yes.
07:28:16 <kmc> Haskell is also an imperative language, and it's easier to reason about the performance of imperative loops over arrays and the like.  but harder to reason about their correctness, and to use them, and to compose them etc.
07:28:22 <tristes_tigres> geekosaur: error conditions?
07:28:30 <geekosaur> there can be proper lazy I/O, but Haskell's "lazy I/O (note scare quotes) is "unsafe interleaved I/O", which has lots of ugly gotchas
07:28:42 <kmc> Haskell programmers generally value working code over fast code, which is not the norm in all language communities
07:28:55 * hackagebot hack2-contrib 2011.10.12 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2011.10.12 (JinjingWang)
07:28:57 * hackagebot maid 2011.10.13 - A simple static web server  http://hackage.haskell.org/package/maid-2011.10.13 (JinjingWang)
07:28:59 <geekosaur> error/exception conditions, and even end of file
07:29:16 <Ke> I think people rather value cheap and easy code than fast code
07:29:34 <geekosaur> worse is that there is no way to detect anything even remotely exceptional, becuase it's taking place in what is supposedly pure code
07:30:05 <geekosaur> it's a convenient but unfortunate design
07:30:28 <kmc> yeah
07:30:38 <kmc> "lazy IO" is great for quick scripts and the like
07:30:46 <Alan> so what is the correct thing to do? an infinite loop with hGetLine in it and checking hIsEOF, hIsReadable or whatever?
07:30:58 <josiah14> my biggest roadblock to actually using Haskell is that nobody at my company knows any functional programming
07:31:05 <tristes_tigres> geekosaur: recently in dicsussion of Node.js they commented favourably about Haskell's asynchronous I/O. I haven't looked into those matters closely
07:31:20 <kmc> right
07:31:21 <josiah14> im learning haskell just cuz my brain is bored and needs something new to chew on
07:31:34 <geekosaur> the *correct* thing to do, well, I said there are ways to do lazy I/O right?  one of the best of those ways is enumeratees
07:31:35 <kmc> that's a great reason :)
07:31:43 <tristes_tigres> josiah14: your brain won't get bored on Haskell, trust me :-)
07:31:44 <geekosaur> but, they're a bit harder to wrap one's head around
07:31:58 <kmc> tristes_tigres, right, node.js wants you to turn your code inside-out (explicit continuation-passing style) to get the benefits of OS-level event-based IO
07:32:06 <josiah14> its silly, really, everyone with a college degree in comp sci should know functional programming, but I cant claim i had that chance either
07:32:25 <Alan> the first language we did in my CS course was Scheme
07:32:26 <kmc> tristes_tigres, in GHC Haskell you use threads and blocking IO, which is a more natural style, and the implementation handles the OS-level event-based IO automatically
07:32:45 <josiah14> thats really good news for me, tigres
07:32:48 <Alan> and we did Haskell in 3rd year
07:33:02 <kmc> everyone with a college degree in comp sci should have experience with at least 6 languages
07:33:09 <kmc> that does not seem to be the case though :/
07:33:18 <josiah14> not at all
07:33:25 <Alan> (Colin Runciman is at our university)
07:33:36 <josiah14> Well, I was computer engineering, which steered me more towards embedded
07:33:38 <tristes_tigres> kmc: So, is Haskell IO broken by design, or isn't? I am gettin confused here
07:33:44 <josiah14> but i still feel li should have gotten way more programming
07:33:44 <kmc> ?
07:33:59 <kmc> tristes_tigres, are you talking about the "lazy IO" discussion with geekosaur, or the async IO discussion with me?
07:34:02 <kmc> they're not related
07:34:19 <tristes_tigres> kmc: I see, I haven't really learned IO stuff in any detail
07:34:35 <geekosaur> the standard library's so-called lazy IO is broken by design.  IO in general is not, and there are non-broken lazy IO implementations
07:34:48 <Alan> kmc: enough experience that their knowledge isn't tied to one language...
07:34:54 <kmc> right
07:35:04 <tristes_tigres> and the non-broken async IO is in which lib?
07:35:08 <dylukes> geekosaur: Could you elaborate?
07:35:21 * geekosaur prepares to repeat himself
07:35:30 <dylukes> I've always seen lazy IO as pretty broken, if only because errors are not immediately propogated :\
07:35:33 <dylukes> I mean, iteratees are nice.
07:35:34 <kmc> tristes_tigres, the thing I was talking about, re node.js, is not related to lazy IO
07:35:39 <geekosaur> actually I'll repeat someone else
07:35:43 <kmc> it's related to the performance of many threads doing IO at once
07:35:44 <geekosaur> <quicksilver> "interleaved IO" (like getContents) is a nasty (but something useful) way of concealing IO within pure operations
07:35:53 <quicksilver> dylukes: well yes, that is one of the main problems.
07:35:57 <geekosaur> <geekosaur> worse is that there is no way to detect anything even remotely exceptional, becuase it's taking place in what is supposedly pure code
07:36:04 <quicksilver> dylukes: another is the management of resources (database handles, say)
07:36:10 <geekosaur> yep
07:36:50 <quicksilver> there is also http://www.mail-archive.com/haskell-cafe@haskell.org/msg21306.html
07:36:56 <quicksilver> maybe I shold teach lambdabot that
07:37:00 <quicksilver> @where+ perils http://www.mail-archive.com/haskell-cafe@haskell.org/msg21306.html
07:37:01 <lambdabot> Okay.
07:37:02 <geekosaur> lazy I/O that works properly:  http://hackage.haskell.org/packages/archive/pkg-list.html#cat:enumerator
07:37:24 <tristes_tigres> geekosaur: and ther asynch io is...?
07:37:28 <tristes_tigres> is in
07:37:35 <rostayob> is anybody using the graphviz library? trying to run basic commands fails with "fd:4: hClose: resource vanished (Broken pipe)"
07:37:48 <tijn>         texts       <-  System.Directory.getDirectoryContents ( dirIn )
07:37:48 <tijn>         let texts2  =   drop 2 texts
07:37:48 <tijn>         let texts3  =   [readFile x | x <- texts2]
07:38:15 <geekosaur> rostayob: I would make sure graphviz is on your $PATH, with that error
07:38:24 <josiah14>    
07:38:25 <geekosaur> and that it's not choking on some broken dotfile
07:38:29 <tijn> Hi I try to read all files in a directory, and put the read strings in a list
07:38:43 <quicksilver> tijn: readFile is an action, you need to 'run' it
07:38:44 <quicksilver> try
07:38:44 <erus`> who is john millikin?
07:38:58 <tijn> I now have [IO String] and try to map a [String] out of it
07:39:00 <kmc> tijn, http://www.haskell.org/haskellwiki/Introduction_to_IO
07:39:01 <quicksilver> texts3 <- sequence [readFile x | x <- texts2]
07:39:07 <rostayob> geekosaur: graphviz? an executable?
07:39:22 <quicksilver> tijn: ^^. That's an odd way to write it but it is the closest to what you already have.
07:39:34 <quicksilver> tijn: more normal would be "texts3 <- mapM readFile texts2
07:39:34 <donri> does that apply to readFile as well?
07:39:40 <tijn> do you have a better solution? I'm eager to learn
07:39:57 <geekosaur> the graphviz library, last I checked, is a way to manipulate the graphviz executable from Haskell
07:39:58 <rostayob> geekosaur: oh god you're right i was missing the executable. i tought that it didn't need anything
07:40:04 <rostayob> yes, i didn't know that
07:40:14 <geekosaur> becuase there's no nice library form of graphviz itself
07:41:16 <tijn> quicksilver, Thnx!
07:41:26 <geekosaur> tristes_tigres: I don't think I understand what you're asking.  I'm also not a master of enumeratees, so if you're asking how to do asynch IO with them, my answr is "it's probably possible but I don't know how"
07:41:37 <rostayob> geekosaur: thanks a lot that was the problem
07:41:52 <kmc> tristes_tigres, what do you mean by "async IO"?
07:42:03 <tijn> is there a strict version of mapM? I get openFile: resource exhausted (Too many open files)
07:42:14 <tristes_tigres> geekosaur: my question is really much more simple
07:42:58 <quicksilver> tijn: ah, your problem is that readFile is broken.
07:43:19 <quicksilver> amusingly this is one of the canonical examples of the lazy IO brokenness we have just been discussing ;(
07:43:24 <geekosaur> yep
07:43:43 <geekosaur> was just thinking "wait isn't readFile the same fail as hGetContents?"
07:43:47 <tijn> quicksilver, how do I solve it? Or is there a different and really much better way to read all files in a directory and put the strings in a list?
07:43:48 <tristes_tigres> kmc: during discussion of Node.js they said that Haskell io is asynchronous behind the scenes
07:44:03 <kmc> tristes_tigres, yes, that's what i was talking about
07:44:22 <geekosaur> yes, that's the interleaved IO design.  the one that we are saying is broken :)
07:44:22 <kmc> when you do IO from many threads, the GHC runtime system implements it with efficient OS-level mechanisms like select, epoll, kqueue, etc.
07:44:32 <kmc> geekosaur, no, I don't think that's what they're talking about at all
07:44:41 <kmc> tristes_tigres, which contrasts with the node.js philosophy
07:44:46 <tristes_tigres> kmc: I guess I was confusing interleaved and asynchronous
07:45:07 <kmc> tristes_tigres, in node.js you are expected to write your code in a contorted style to get the benefits of epoll or whatever
07:45:14 <quicksilver> tijn: texts3 <- mapM (\x -> do t <- readFile x; length t `seq` return t) texts2
07:45:19 <kmc> in Haskell you write it in the natural style with threads
07:45:44 <quicksilver> tijn: calculating the length of each read-in file (t) with 'length' forces the whole thing so the file gets closed.
07:45:55 <kmc> tristes_tigres, you could use the term "asynchronous IO" in another context to describe the interleaved stuff
07:46:05 <Alan> @hoogle Monad m => (a -> m b) -> m [a] -> m ()
07:46:05 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
07:46:06 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
07:46:06 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
07:46:11 <kmc> but if someone is contrasting node.js with Haskell, they probably mean the thing I said
07:46:20 <Alan> hmm
07:46:54 <tristes_tigres> kmc: so what is broken isn't behind-the-scenes implementation, but the way standard library uses it?
07:46:55 <Alan> i think i've gotten lost in monads :(
07:47:11 <quicksilver> tristes_tigres: almost everything isn't broken.
07:47:19 <kmc> tristes_tigres, you're still trying to talk about these two things together
07:47:23 <kmc> when I think they are almost totally unrelated
07:47:26 <kmc> i don't understand
07:47:28 <quicksilver> tristes_tigres: it's just a couple of high-profile functions: hGetContents/getContents/readFile, basically.
07:47:37 <geekosaur> ah
07:47:39 <quicksilver> which use unsafeInterleaveIO, which is the real culprit.
07:47:49 <kmc> which has nothing to do with the GHC IO manager
07:47:52 <jeltsch> Hi, what is the easiest way for installing cabal-install with GHC 7.2.1? Several libraries that come with GHC 7.2.1 seem to be to new for even the current cabal-install.
07:47:54 <quicksilver> outside of those, the garden is sweet and smells of roses.
07:47:55 <tristes_tigres> kmc and quicksilver: just give me an url to cure my ignorance
07:48:04 * geekosaur is not familiar with node.js aside from as a reported example of conorted ingenuity :)
07:48:10 <kmc> IO performed via unsafeInterleaveIO is performed through the IO manager, as is all other IO
07:48:18 <Alan> mapM_ recv $ fmap lines $ hGetContents h
07:48:34 <kmc> tristes_tigres, it does not make sense to ask for a document on "here's why you should not conflate X and Y"
07:48:42 <kmc> in most cases
07:48:44 <Alan> and recv is String -> ReaderT a IO ()
07:49:06 <tristes_tigres> kmc: I mean on criticism of lazy IO in standard library
07:49:18 <kmc> ah, I expect you can find documents about that
07:49:22 <kmc> but I don't have a link
07:49:32 <Alan> :t liftIO
07:49:33 <lambdabot>     Ambiguous occurrence `liftIO'
07:49:33 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
07:49:34 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
07:49:49 <Alan> :t Control.Monad.Logic.liftIO
07:49:49 <lambdabot> forall a (m :: * -> *). (Control.Monad.Logic.MonadIO m) => IO a -> m a
07:50:05 <quicksilver> tristes_tigres: did you try the link I pasted?
07:50:08 <quicksilver> @where perils
07:50:08 <lambdabot> http://www.mail-archive.com/haskell-cafe@haskell.org/msg21306.html
07:50:14 <Alan> :t liftM
07:50:15 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:50:32 <tristes_tigres> quicksilver: ah, missed it, thanks
07:50:46 <Alan> how does liftM and fmap differ?
07:50:51 <Alan> :t fmap
07:50:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:50:53 <kmc> historical reasons only
07:51:10 <tijn> quicksilver, Thnx!  Works like a charm :-)
07:52:11 <Alan> oh
07:52:17 <Alan> i think i just worked out what i need to do...
07:53:19 <Alan> liftIO (fmap lines $ hGetContents h) >>= mapM_ recv
07:53:29 <simon> how good is the System.Fuse module/package?
07:53:31 <Alan> does that have stupid redundancy in it?
07:53:55 * hackagebot DSH 0.7.2 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.7.2 (GeorgeGiorgidze)
07:54:32 <geheimdienst> simon: seems pretty okay, but i have only used it a little bit
07:57:24 <bscarlet> Hmm. ContT doesn't seem to pass "fail" down to the wrapped Monad like other transformers. Why not?
08:03:22 <c_wraith> I doubt there's a good reason for that.  There's easily a bad reason, though:  fail sucks and should always be implemented as error.  I'm sympathetic to that viewpoint.
08:04:50 <bscarlet> c_wraith: I'm familiar with the existence of the viewpoint, but not the justification. Would you care to offer one, preferably w/o too much prejudice?
08:06:23 <kmc> i think programming pattern-match failure in 'do' is really useful
08:06:29 <kmc> especially in list comprehensions
08:06:44 <kmc> just move 'fail' (back) into its own class
08:07:02 <c_wraith> it's not part of the mathematical underpinnings of monads.  It was originally added just for the sake of providing customizable behavior for failed pattern matches in bindings, but *why* should that be customizable?  Why not just treat them the same way as every other failed pattern match?
08:07:32 <bscarlet> kmc: "back"?
08:07:33 <kmc> because it's very useful, and Haskell is a programming language, not a mathematical masturbation contest
08:07:37 <kmc> (don't tell Reddit, though)
08:07:42 <geheimdienst> kmc++
08:07:47 <kmc> bscarlet, it was so in Haskell 1.4, iirc
08:07:49 <kmc> which is pre-98
08:07:50 <c_wraith> It's not useful, though.  It's just an obfuscation technique.
08:07:54 <Ferdirand> kmc++ too
08:07:58 <kmc> @src catMaybes
08:07:58 <lambdabot> catMaybes ls = [x | Just x <- ls]
08:08:01 <kmc> not useful?
08:08:06 <c_wraith> right.  that's exactly my example
08:08:15 <c_wraith> catMaybes is nicely obfuscated by that abuse
08:08:30 <c_wraith> Why not actually write code that says what it does?
08:08:36 <kmc> that's circular
08:08:43 <kmc> what the code does is defined by the rules of the language
08:08:57 <Ferdirand> I find that version crystal clear, that's just my opinion
08:09:02 <kmc> please argue that this is actually obfuscation
08:09:22 <quicksilver> I think that's a very natural extension of list comprehensions
08:09:23 <kmc> merely using pejorative words to describe something is not an argument
08:09:34 <quicksilver> "All x such that "Just x" is a member of ls"
08:09:57 <kmc> anyway putting it in a separate MonadFail should remove the criticism about "mathematical underpinnings", weak as that is to begin with
08:10:25 <geheimdienst> what is the Maye monad's implementation of fail? no-op?
08:10:30 <geheimdienst> *Maybe
08:10:30 <kmc> @src Maybe fail
08:10:31 <lambdabot> fail _      = Nothing
08:10:41 <geheimdienst> thanks
08:10:44 <c_wraith> It can't be a no-op, due to the type
08:10:53 <kmc> that list-comprehension syntax matches common math syntax, by the way
08:10:57 <c_wraith> and in many cases, the type forces it to be error
08:10:59 <geheimdienst> didn't know @src could do that
08:11:15 <c_wraith> (or other forms of bottom)
08:11:32 <c_wraith> kmc, you've just gone in a circle.  "forget math.  that's the correct math notation"
08:11:34 <kmc> @src is just a database of code snippets with names
08:11:34 <lambdabot> Source not found. Are you on drugs?
08:11:44 <quicksilver> even the Maybe example is useful
08:11:45 <kmc> c_wraith, that's not a circle, it's attacking from two sides
08:11:52 <robert[]> circualar logic is true
08:11:56 <kmc> circular reasoning = circle of implications
08:11:57 <kmc> :t fix
08:11:58 <lambdabot> forall a. (a -> a) -> a
08:12:04 <quicksilver> do Foo x <- blah; Bar z <- bam; return [x,z]
08:12:11 <quicksilver> ^^ really useful in the maybe monad
08:12:18 <quicksilver> a list of assertions about the form of certain things
08:12:27 <quicksilver> and you get 'Nothing' if the form was other.
08:12:32 <ClaudiusMaximus> lpsmith: (was out for a few hours...); yes, these low-level concurrent/async callbacks were to build the wrapper that lets me write "renderManyImages :: [(ImageSpecification, FilePath)] -> IO ()"
08:12:36 <quicksilver> you can then `mplus` that with other alternatives
08:12:41 <kmc> c_wraith, I'm saying that holding to the mathematical underpinnings is not a big deal *and* that it's not far anyway
08:12:43 <kmc> how is that circular?
08:13:24 <kmc> anyway you've still presented no argument
08:13:44 <KirinDave> I was just reading http://apfelmus.nfshost.com/blog/2011/10/11-frp-concurrent-events.html
08:13:54 <lpsmith> ClaudiusMaximus: that's quite ok,  I was out for a few hours myself
08:13:58 <KirinDave> it kinda suggests that FRP is a fool's errand entirely? Is that the wrong takeaway?
08:13:59 <c_wraith> It's tough to present an argument for something so obvious.  It takes time and care to sort it out.
08:14:30 <lpsmith> Honestly,  I really like  the syntax  [ x | Just x <- xs ]
08:14:41 <kmc> c_wraith, ok, well I'm always here, so you can get back to me :)
08:14:57 <kmc> I really am interested in hearing a justification for that position
08:15:04 <kmc> (as bscarlet was too)
08:15:30 <KirinDave> Because if frp implementations can't even get their flow control sorted w.r.t. their underlying toolkits
08:15:37 <lpsmith> Of course,  I also liked n+k patterns, and didn't completely understand why people were so against them.    On the other hand, I wasn't *that* attached to them either.
08:15:40 <kmc> like I said, I'm unhappy with 'fail' being in the Monad class, but it would be perfectly fine in a separate class
08:15:44 <KirinDave> Then that is a pretty big problem for writing frp libraries.
08:15:54 <jeltsch> wna.
08:15:59 <kmc> n+k patterns are a little weird and a little useful
08:16:10 <kmc> programmable pattern-match failure in 'do' is a little weird and a lot useful
08:16:13 <mm_freak> KirinDave: it's not fair to generalize this problem to FRP…  it's a problem of reactive-banana
08:16:20 <jeltsch> What do these errors mean: “SpecConstrFunction `$wa{v X3AR1} [lid]'
08:16:21 <jeltsch>       has one call pattern, but the limit is 0
08:16:23 <jeltsch>     Use -fspec-constr-count=n to set the bound
08:16:25 <jeltsch>     Use -dppr-debug to see specialisations
08:16:43 <byorgey> jeltsch: IIUC those can be ignored
08:16:46 <mm_freak> KirinDave: there is no problem with recursive data dependencies at least in arrowized FRP
08:16:53 <lpsmith> kmc:  I basically agree.   I'd be much more upset about losing pattern-match failure in do.
08:17:01 <KirinDave> mm_freak: Through that sorcerous do rec notation. :)
08:17:04 <mm_freak> and personally i think that monadic FRP is just wrong
08:17:07 <quicksilver> mm_freak: I don't think it's about recursive data dependencies
08:17:09 <byorgey> although I don't know what they mean.
08:17:31 <kmc> also view patterns are a natural generalization of n+k, and are supported by GHC, and may be standardized one day
08:17:39 <quicksilver> mm_freak: I think that paradox is about events which take time to process themselves generating new events which are supposed to occur midway through the processing
08:17:41 <KirinDave> mm_freak: Yeah well Arrows don't exactly have a great reputation right now.
08:17:57 <geekosaur> it's not an werror, it's the compiler saying that a possible opportunity for an oprtimization was skipped
08:18:16 <lpsmith> aye,  but using view patterns to express n+k is a bit syntactically awkward
08:18:17 <mm_freak> quicksilver: that's an instance of this problem:  do rec x <- integral 0 -< x
08:18:19 <kmc> why does this one missed optimization merit a warning?
08:18:32 <mm_freak> quicksilver: at least that's how it translates to AFRP
08:18:37 <dmwit> byorgey: Are you talking about the bug where spurious strange garbage would be printed on old GHC's? If so, what jeltsch pasted doesn't look like that bug to me...
08:18:39 <lpsmith> Though I'd definitely give up n+k for view patterns
08:18:43 <KirinDave> mm_freak: Are there any working afrp frameworks right now?
08:18:48 <mm_freak> quicksilver: in AFRP you solve it through a one-instant delay
08:18:55 <geekosaur> basically a polymorphic function can be optimized by automatic specialization to the types it's used at... but that hapens recursively and the limit to automatic specialization gets divided up over the recursive invocations
08:18:57 <mm_freak> KirinDave: yampa, animas, netwire
08:19:08 <dmwit> (That bug never had the "has one call pattern, but the limit is 0" or later parts.)
08:19:13 <KirinDave> mm_freak: That work with gtk+?
08:19:34 <mm_freak> KirinDave: i'm not sure…  i'm giving higher priority to an OpenGL graphics framework right now
08:19:39 <jeltsch> dmwit: What do you mean? Are these messages a problem or not?
08:19:44 <byorgey> dmwit: maybe we are thinking of different bugs, because I've definitely seen ghc print what jeltsch pasted
08:19:57 <dmwit> ok
08:19:59 <geekosaur> kmc: I think because that code is being overhauled and they wanted some feedback on it
08:20:06 <dmwit> jeltsch: When in doubt, prefer byorgey to me. =)
08:20:10 <KirinDave> mm_freak: Fair enough. I was hoping to learn more about FRP by porting notational velocity to linux.
08:20:12 <kmc> interesting
08:20:15 <geekosaur> at least, I recall spec-constr being worked over in the ghc7 series
08:20:16 <kmc> i see those warnings quite a lot
08:20:33 <kmc> geekosaur, do you have a link to more information on this, or should i just Google?
08:20:51 <mm_freak> KirinDave: as i said, honestly i believe that monadic FRP just won't work in general…  it will always hit limits
08:20:59 <mm_freak> IMO FRP is just not a monad
08:21:00 <geekosaur> google.  I think the fine detail is that the meaning of -fspec-constr-limit changed, and they dont have a good idea of what the new default should be
08:21:09 <KirinDave> mm_freak: Fair enough.
08:21:10 <geekosaur> but dont quote me, corner a Simon :)
08:21:29 <quicksilver> mm_freak: your comment "personally i think that monadic FRP is just wrong" makes no sense to me. FRP is a programming technique not a data type, it can't possibly be a monad.
08:21:44 <byorgey> jeltsch, dmwit: http://hackage.haskell.org/trac/ghc/ticket/5125
08:21:50 <KirinDave> dmwit: Hey, I had some random questions for you about your xmonad config and cgoban. Can I bug you for a moment in #haskell-blah?
08:21:51 <quicksilver> in a particular implementation of FRP there may, or may not be, data types which obey the monad lawys
08:22:00 <quicksilver> in and of itself that's not a very interesting fact about them.
08:22:03 <KirinDave> mm_freak: Haha, they have you now.
08:22:04 <dmwit> KirinDave: How about #xmonad?
08:22:12 <dmwit> I don't frequent #haskell-blah any more.
08:22:14 <mm_freak> quicksilver: i was searching for FRP implementation techniques, which don't require mutation
08:22:17 <dmwit> or if it's go related, #go...
08:22:38 <conal> i'd expect to see the monad-or-not question directed to the semantic model, not an implementation.
08:22:41 <dmwit> byorgey: Okay, cool.
08:22:46 <mm_freak> quicksilver: i think that FRP in its simplest form is an automaton, and it is easy to see that automatons can't be represented monadically
08:23:04 <quicksilver> mm_freak: again I think  you are mixing different levels of abstraction
08:23:05 <conal> and then an implementation is either faithful to its semantics or isn't.
08:23:21 <quicksilver> conal: different sense of the word implementation.
08:23:46 <quicksilver> conal: an "implementation" can still be a semantic thing; but my point is that "being a monad" is a property of a type constructor, not a concept.
08:24:19 <quicksilver> mm_freak: an automaton is an abstract concept which you could make precise in many many ways. Some of those might happen to involve things which happen to be monads, others might not.
08:24:28 <quicksilver> "automatons are not monads" is a tautology certainly
08:24:39 <quicksilver> but it doesn't mean "no monads should be used in the solution of this problem"
08:24:58 <jeltsch> .
08:25:14 <mm_freak> quicksilver: ok, perhaps it's more fair to say that i'm judging by experience with existing implementations
08:25:36 * quicksilver nods
08:25:38 <mm_freak> monadic FRP implementations seem more complicated to me and so far have always involved impure stuff under the hood
08:25:51 <quicksilver> mm_freak: mine does not
08:26:02 <quicksilver> (unless you think IO is somehow essentially impure)
08:26:12 <conal> quicksilver: ah. i guess we were talking about different questions.
08:26:21 <mm_freak> no, IO is fine, but unsafePerformIO is not
08:26:49 <mm_freak> quicksilver: then i'd be very interested…  how do you do it?  references?
08:27:25 <quicksilver> mm_freak: http://www.haskell.org/pipermail/reactive/2008-December/000151.html
08:27:37 <quicksilver> mm_freak: I'd love to discuss it more with you someday but not today I have a lot to get done this afternoon :)
08:28:00 <mm_freak> sure =)
08:28:08 <robert[]> hi
08:28:26 <robert[]> ive got a fact about type systems
08:28:45 <mm_freak> quicksilver: but is there an actual implementation, which i could check out?
08:28:51 <robert[]> if G|-s:S and G,S|-t:T then G|-t[0:=s]:T?
08:28:58 <robert[]> whats this called
08:29:14 <robert[]> infact I generalized it
08:29:33 <quicksilver> mm_freak: yes, in the source linked in that post
08:29:53 <quicksilver> mm_freak: well actually that was the reply to my post, for some reason, since it had higher goole rank
08:30:39 <mm_freak> ah, alright
08:30:41 <mm_freak> thanks
08:33:01 <matthiasgorgens> We have a generator program (in haskell) that takes an description for remote procedure calls (rpc) over dbus in xml and produces bindings for several languages including haskell.  At the moment the representation for the produced haskell is just strings.  Would it be a sane idea to use template haskell for a stronger data type?  Or should I look into something different?
08:33:21 <Alan> gah, i really need to work out my data structure...
08:33:52 <monochrom> it suffices to use haskell-src or haskell-src-ext for a stronger data type
08:35:19 <matthiasgorgens> thanks!
08:36:55 <dmwit> robert[]: It's called the substitution lemma.
08:37:31 <dmwit> robert[]: (You probably need to decrement all the other deBruijn indices, too, no?)
08:38:20 <kmc> matthiasgorgens, I'd use haskell-src-exts
08:38:31 <kmc> unless you specifically want to splice it with TH
08:38:43 <kmc> in which case you can still use h-s-e via haskell-src-meta
08:39:07 <matthiasgorgens> kmc: Yes, I found that, and we'll probably use that, since we are using ghc anyway with a couple of extensions.
08:39:15 <kmc> cool
08:39:39 <matthiasgorgens> I'm just looking for generators for other languages, too.  There's a language-c package, for example.
08:40:33 <kmc> you could also use a generic pretty-printing library like http://hackage.haskell.org/package/pretty
08:40:45 <kmc> which still has many advantages over gluing together Strings
08:42:21 <kmc> bbl
08:43:21 <matthiasgorgens> kmc, interesting.
08:43:33 <robert[]> I am not sure
08:43:55 * hackagebot PropLogic 0.9.0.1 - A system for propositional logic with default and fast instances of propositional algebras.  http://hackage.haskell.org/package/PropLogic-0.9.0.1 (DavidFox)
08:44:17 <matthiasgorgens> kmc, I'll make a note.  The rewrite is not urgent at the moment, it's just that the generator is a bit ugly.
08:51:03 <Alan> hmmm
08:52:42 <Alan> how would you usually go about making something similar to a "normal language" class hierarchy?
08:52:57 <Eelis> what do you mean by "normal language"?
08:53:29 <Alan> I mean class in the way that something like Java would have it
08:53:49 <Eelis> please come back when you have a real question.
08:54:02 <Alan> yeah, sorry, i realised i'm not explaining myself very well there
08:54:22 <robert[]> who here know about normalization proof
08:54:31 <Quantumplation> data MyType = A Int | B String;  Is it possible to write a function / data constructor that only accepts parameters of type B?
08:54:40 <robert[]> your name is so funny Quantumplation
08:54:53 <robert[]> not possible
08:55:02 <Alan> haha, i use quantumplating in everyday language :|
08:55:20 <robert[]> what does it mean??
08:55:42 <Alan> probably what you think it means
08:55:44 <copumpkin> Quantumplation: you can sort of do that with GADTs and phantom types
08:56:01 <robert[]> i tihink it's meaningless
08:56:10 <sipa> Quantumplation: data MyTypeA = A Int; data MyTypeB = B String; data MyType = MA MyTypeA | MB MyTypeB
08:56:38 <Quantumplation> =[ I'm trying to write a generic graph library, and my initial thought was to have data Element = Node ID | Edge (Node, Node, ID) | Cycle [Node] | Path [Node] | Graph [Element]
08:57:06 <Quantumplation> or would Element be a type class?
08:57:13 <eyebloom> When a haskell program actually does create a side effect, where does that happen? Does an IO monad essentially return an action and a continuation and the runtime system performs the action and then evaluates the continuation?
08:57:57 <Saizan> eyebloom: that's a good model of the situation, yep
08:58:39 <Saizan> the implementation can be more subtle but you don't have to wrory about that
08:58:55 * hackagebot PropLogic 0.9.0.2 - A system for propositional logic with default and fast instances of propositional algebras.  http://hackage.haskell.org/package/PropLogic-0.9.0.2 (DavidFox)
08:59:26 <eyebloom> Saizan: How so?
08:59:33 <bscarlet> Quantumplation: you called "B" a type. It's not. It's a constructor. MyType, Int, and String are the types in your example.
09:00:20 <Saizan> eyebloom: GHC for example just implements the IO type via side-effecting functions
09:01:40 <Saizan> that's why it can easily offer unsafePerformIO :)
09:04:21 <eyebloom> I'm not sure I understand. So essentially the side effecting function is just forcing evaluation and then executing the side effect in order to keep proper execution order?
09:04:29 <bscarlet> Quantumplation: for instance, you can't say Path [Node], you could only say Path [Element].
09:04:34 <robert[]> I have a q about STRONG normailzation
09:05:06 <eyebloom> Rather than some central runtime, waiting for a returned value?
09:05:29 <sipa> robert[]: maybe if you asked it, someone might step up and say "hey i know the answer"
09:06:59 <byorgey> robert[]: let's hear it
09:07:26 <Saizan> eyebloom: no, i mean that GHC implements IO as something like IO a = () -> a; but where that function type can perform side-effects as if it was ML or an imperative language
09:08:24 <robert[]> weak normalization: every term has a finite sequence of reductions to a normal form
09:08:34 <robert[]> strong normalization: there is no infinite reduction sequence
09:08:49 <dolio> It actually implements it as Token -> (a, Token), to enforce ordering via data dependencies.
09:08:50 <robert[]> is that right so far?
09:08:54 <byorgey> robert[]: right
09:09:00 <robert[]> so weak normaliztion is proved by induction on an ordinal
09:09:06 <dolio> But that's a poor model for IO.
09:09:10 <robert[]> and strong is proved by Taits candidates
09:09:21 <robert[]> yes?
09:09:39 <robert[]> in fact you can't prove strong normalization by induction on an ordinal... you need sets of terms
09:09:43 <byorgey> are you talking about weak/strong normalization for some particular system?
09:09:58 <robert[]> intuitionist logic of lambda calculus
09:10:06 <byorgey> surely weak + strong normalization may be proved by a huge number of methods, depending on what system you are proving them for
09:10:17 <robert[]> simple types, and more
09:10:22 <robert[]> system F
09:10:26 <robert[]> etc
09:10:57 <robert[]> it's not possible to prove strong normalization by a simple induction on a large enough orginal
09:11:12 <byorgey> ok
09:11:18 <byorgey> so what's the question?
09:11:32 <robert[]> the consistency of arithmetic is proved by induction on an orfinal
09:11:39 <robert[]> therefore its a weak normalization
09:11:43 <robert[]> and does not actually prove consistency
09:12:01 <dolio> The proof method doesn't determine whether it's strong or weak normalization.
09:12:43 <robert[]> the result is
09:12:47 <robert[]> arithmetic is in danger
09:13:13 <dylukes> I realized my weird operator mess yesterday was basically ap :<
09:13:23 <dylukes> :t (<$) . (<$>)
09:13:23 <lambdabot> forall (f :: * -> *) b a b1 (f1 :: * -> *). (Functor f, Functor f1) => (a -> b1) -> f b -> f (f1 a -> f1 b1)
09:13:24 <dylukes> :t
09:13:28 <byorgey> > let 2 + 2 = 5 in 2 + 2  -- oh noes! the laws of arithmetic are failing!
09:13:28 <dylukes> :t 'ap'
09:13:29 <lambdabot>   5
09:13:29 <lambdabot>     lexical error in string/character literal at character 'p'
09:13:32 <dylukes> :t ap
09:13:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:13:35 <dylukes> kind of, rahter
09:13:41 <dylukes> except the other way around...
09:13:44 <dylukes> and plus an argument ...
09:13:49 <dylukes> and in two functors
09:13:51 <dylukes> :3
09:14:11 <robert[]> any arguiemtns
09:14:29 <robert[]> I think that we have seen gentzens so called "proof" fall to dust before our eyes
09:14:31 <byorgey> robert[]: that doesn't make sense.  even if it is not possible to prove SN of lambda calculi using induction on an ordinal (which I don't really know anything about), that says nothing about proofs about arithmetic.
09:14:49 <robert[]> the logic of arithmetic  is simply lambda calculus
09:14:59 <robert[]> that is the unversal langauge which all logic is built upon
09:15:59 <dylukes> robert[]: what about SK
09:16:01 <dylukes> :\
09:16:15 <robert[]> dylukes: I can teach you the relations
09:16:22 <robert[]> its equivalence
09:16:23 <dolio> All women are mortal. Ted Nugent is mortal. Therefore Ted Nugent is a woman.
09:16:26 <dolio> Any arguments?
09:16:26 <dylukes> dont please
09:17:24 <robert[]> flippant
09:17:31 <robert[]> you know SK is irrelevant why mention it
09:18:20 <robert[]> it appears i have exposed a serious flaw in the foundations
09:19:05 <robert[]> who knows about theproof  theory of strong normaliazion
09:19:08 <dolio> No. It appears your argument isn't even valid.
09:19:17 <tromp> therefore all men are women
09:19:20 <quicksilver> robert[]: I think this conversation would be best continued elsewhere.
09:19:31 <quicksilver> #haskell is not the forum for ramblings on the consistent of arithmetic
09:19:33 <robert[]> dolio it doesn't follow your syllogism
09:19:45 <quicksilver> #haskell-blah would be a reasonable starting place
09:19:52 <copumpkin> or overflow
09:19:56 <quicksilver> yes.
09:19:57 <JuanDaugherty> *consistency
09:20:11 <JuanDaugherty> (completeness actually)
09:20:27 <JuanDaugherty> neither
09:22:18 <robert[]> well
09:22:27 <robert[]> turns out consistency comes from weak normalizaton
09:22:30 <robert[]> so the proof is fine
09:22:31 <JuanDaugherty> anybody know of any new app server projects, or just the same ole usual suspects
09:22:44 <robert[]> I found that on the page
09:22:58 <robert[]> byorgey: ^
09:23:25 <JuanDaugherty> i.e., yesod, snap, and happstack.
09:24:34 <dolio> Your argument is flawed for other reasons, too.
09:24:44 <dylukes> having at the least three large app server projs in one language is significant in of itself JuanDaugherty
09:24:57 <dylukes> are you looking for one with a different featureset
09:24:58 <dylukes> ?
09:25:05 <robert[]> dolio: why?
09:25:26 <JuanDaugherty> yes, one which is more a general app server than a web server
09:25:51 <copumpkin> what does it mean to be an app server?
09:25:58 <JuanDaugherty> mehbe like a jboss for haskell
09:26:11 <dolio> You went from "Proof method A isn't usually used for proofs like B" to "Proof method A is used, therefore it's not a proof of B."
09:26:18 <dolio> That doesn't follow.
09:26:19 <copumpkin> I want to serve up things other than text/html
09:26:22 <copumpkin> I NEED AN APPLICATION SERVER
09:26:50 <dolio> Unless you've proved that it's impossible to prove B using proof method A.
09:27:05 <Saizan> that's what robert[] claimed, though
09:27:29 <robert[]> you can't prove strong normalization using ordinal induction, you need candidats
09:27:37 <dolio> Prove it.
09:27:56 <robert[]> its a theorem
09:28:38 <dylukes> and?
09:28:47 <dylukes> you can prove theorems. That's kind of the poiint.
09:28:47 <robert[]> as said I mistakenly thought you needed strong normalization for consistency, therefore this is not an obstruction for the consistency of arithmetic
09:28:55 * hackagebot CC-delcont-alt 0.0.0.0 - Three new monad transformers for multi-prompt delimited control  http://hackage.haskell.org/package/CC-delcont-alt-0.0.0.0 (KidoTakahiro)
09:28:57 <robert[]> dylukes: you're talking again....
09:28:57 * hackagebot CC-delcont-ref 0.1.0.0 - A monad transformers for multi-prompt delimited control using refercence cells  http://hackage.haskell.org/package/CC-delcont-ref-0.1.0.0 (KidoTakahiro)
09:28:59 * hackagebot CC-delcont-exc 0.1.0.0 - A monad transformers for multi-prompt delimited control  http://hackage.haskell.org/package/CC-delcont-exc-0.1.0.0 (KidoTakahiro)
09:29:06 <dylukes> robert[]: and?
09:29:07 <parcs> ooo
09:29:10 <parcs> sounds shiny
09:29:17 <rwbarton> dylukes: have you heard of Quora's LiveNode? I'd like to have something like that in Haskell
09:29:18 <robert[]> dont
09:29:30 <JuanDaugherty> and that's it ladies and germs, it's just a theorem
09:29:43 <dylukes> robert[]: On an unrelated note. Stop being a dick, please.
09:30:06 <dylukes> rwbarton: no I'm not familiar with it, sorry.
09:30:07 <dolio> Anyhow, normalization is irrelevant.
09:30:33 <robert[]> yes
09:30:38 <robert[]> @dolio
09:30:38 <lambdabot> Unknown command, try @list
09:30:48 <robert[]> at least, the type of normalization
09:30:58 <dolio> No, normalization at all.
09:31:02 <robert[]> oh really?
09:31:08 <robert[]> how is that
09:31:51 <rwbarton> dylukes, it's for handling live updates (ajax) transparently. when it builds a page to send to the client, it tracks what database entries were queried to generate that page; then when those entries change, it sends the new information over a long-polling connection
09:32:06 <dylukes> Oh, interesting :\.
09:32:20 <dylukes> That's a neat idea.
09:32:22 <dolio> Because consistency isn't identical to normalization of some calculus.
09:32:36 <robert[]> its close enough
09:32:40 <rwbarton> Yeah, as far as I know there is no public implementation of anything like it currently though.
09:32:50 <robert[]> just a few inferences away
09:33:24 <luite> rwbarton: hmm, that would be interesting, haskell should be able to handle many concurrent connections easily
09:33:55 * hackagebot CC-delcont-cxe 0.1.0.0 - A monad transformers for multi-prompt delimited control  http://hackage.haskell.org/package/CC-delcont-cxe-0.1.0.0 (KidoTakahiro)
09:34:45 <rwbarton> (some slides illustrating the idea for those who are interested: http://www.quora.com/Shreyes-Seshasai/Tech-Talk-Webnode2-and-LiveNode)
09:37:10 <luite> websockets support was recently added to yesod, I think snap also has support. with acid-state and some trigger mechanism it should be doable with relative ease
09:38:48 <shirt> is +RTS -N1 the same as not passing in anything?
09:38:57 * hackagebot CC-delcont-alt 0.1.0.0 - Three new monad transformers for multi-prompt delimited control  http://hackage.haskell.org/package/CC-delcont-alt-0.1.0.0 (KidoTakahiro)
09:38:59 * hackagebot CC-delcont-cxe 0.1.0.1 - A monad transformers for multi-prompt delimited control  http://hackage.haskell.org/package/CC-delcont-cxe-0.1.0.1 (KidoTakahiro)
09:40:25 <robert[]> http://en.wikipedia.org/wiki/Barendregt%E2%80%93Geuvers%E2%80%93Klop_conjecture
09:42:50 <robert[]> dolio: Statman showed in 1977 that the normalisation problem is not elementary recursive
09:43:14 <tac-tics> At some point, you have to take a leap of faith that your shit's gonna terminate.
09:43:27 <robert[]> tac-tics: haha
09:48:59 <erus`> i wish my phone ran debian
09:49:06 <erus`> with apt-get et all
09:49:40 <robert[]> why
09:50:36 <erus`> because i have autism
09:50:41 <robert[]> ok
09:50:44 <JuanDaugherty> android jb'd is semi debian, uses apt's
09:51:15 <erus`> can you like apt-get aps?
09:52:08 <tac-tics> apt-get install apt-get
09:52:28 <erus`> andoird is getting more locked down with every new phone
09:52:47 <erus`> might aswel just give up on freedom
09:52:50 <sipa> android isn't; what manufactures make from it is
09:53:00 <donri> poor maemo
09:53:16 <erus`> sipa: i agree but a phone needs a manufacturer
09:53:21 <jonafan> well, it is until the android 3+ source gets released
09:53:29 <tac-tics> erus`: Android is kind of a disappointment. Also, #haskell-blah anyone?
09:53:32 <sipa> erus`: -> buy a phone, root it
09:53:43 <robert[]> erus`: you're talking about freedom yet you use debian??
09:53:53 <matthiasgorgens> @pl \f -> f a b
09:53:53 <lambdabot> flip ($ a) b
09:53:55 * hackagebot CC-delcont-cxe 0.1.0.2 - A monad transformers for multi-prompt delimited control  http://hackage.haskell.org/package/CC-delcont-cxe-0.1.0.2 (KidoTakahiro)
09:54:12 <copumpkin> take it to #haskell-blah or elsewhere
09:56:19 <tibbe> I'm extending Cabal to support benchmarks and could use some feedback on error messages. Executable and test suite sections can't have the same name in .cabal files and Cabal used to spit out an error if they did, like so: "These test sections share names with executable sections: foo". Now I'm also adding benchmark sections but it makes it harder to give good error messages. Can anyone come up with something better than "These executable, test, and/or benchm
09:56:19 <tibbe> sections share names: some-exe, some-test, some-benchmark"?
09:56:55 <donri> I wonder what Schrödinger has to say about non-strict semantics.
09:58:21 <donri> Relevantly, due to buffering, 'cat' is lazy.
09:58:32 <tac-tics> donri: I don't think he'd have much of an opinion. I've never heard of a _|_-valued experiment
09:59:28 <robert[]> what about quantum haskell
09:59:35 <robert[]> with superposition types
10:00:56 <kmc> robert[], there's a few quantum packages on hackage
10:01:17 <tromp> type Quantum a = a -> Amplitude ?!
10:01:51 <robert[]> a monad?
10:02:10 <kmc> that's not a monad
10:02:30 <kmc> it's a space station
10:03:20 <benmachine> tibbe: you could just say "these components of your package"? or "the names of every component in your package should be unique, these names are used multiple times: foo"
10:03:34 <kmc> hmm i thought there were several libs but now i just find http://hackage.haskell.org/package/quantum-arrow
10:03:35 <benmachine> *each component in your
10:03:55 <kmc> "The arrow is defined over any instance of MonadRandom, so if you want to get especially crazy, you can experiment with what quantum computation is like when observables include invoking continuations."
10:04:02 <kmc> ...
10:04:16 <opqdonut> :D
10:04:52 <kmc> http://guidesmedia.ign.com/guides/9846/images/psyduck.gif
10:04:53 <byorgey> that's not a quantum arrow package
10:04:56 <benmachine> is there an interesting contravariant version of applicative or monad?
10:04:56 <byorgey> it's a space station
10:05:11 <benmachine> huh, lots of space stations around lately
10:05:35 <byorgey> that's not a benmachine
10:05:38 <byorgey> it's etc.
10:05:43 * benmachine is etc.
10:06:29 <kmc> their representation is essentially type StateVec a = [(a, Complex Double)]
10:07:01 <kmc> but you have an untracked invariant that the vector of magnitudes is normalized
10:07:55 <kmc> i wonder what high-level languages for quantum computers would look like
10:07:58 <Reisen> Probably a silly question, but, I'm assuming the IO type in Haskell is treated special by the compiler right? Like, what makes it so that IO is treated as unpure, that other types I might define lack?
10:08:06 <kmc> Reisen, IO is not impure
10:08:14 <kmc> values of IO type are ordinary, pure values
10:08:21 <kmc> they are descriptions of imperative actions which have not yet occurred
10:08:28 <robert[]> its runby an interpreter
10:08:36 <Reisen> kmc, Where is the impurity then?
10:08:38 <robert[]> main :: IO a
10:08:44 <tibbe> benmachine: good idea
10:08:47 <kmc> the magic thing is that the runtime system will actually perform the action described by 'main'
10:08:47 <tac-tics> kmc: There are a few already. There was a post on QML the other day on Reddit.
10:09:06 <monochrom> the compiler treats the IO type specially
10:09:11 <tac-tics> kmc: The big constructs are linear types and limited non-determinism
10:09:25 <kmc> Reisen, the key is that evaluation ≠ execution
10:09:30 <kmc> evaluating a function application never performs IO
10:09:34 <kmc> even if the result of the function is an IO action
10:10:11 <kmc> (by 'never' i mean 'unless you explicitly break the rules')
10:10:13 <Reisen> Hmm, so how does the compiler determine whether a function will be an execution?
10:10:15 <kmc> Reisen, http://www.haskell.org/haskellwiki/Introduction_to_IO
10:10:21 <kmc> Reisen, that question doesn't make sense
10:10:29 <Reisen> I'm probably massively misunderstanding here
10:10:45 <kmc> Reisen, values of type (IO T) are imperative programs that you manipulate as first-class values
10:10:46 <Reisen> Let me take a look at that page first, one moment
10:11:01 <kmc> Haskell programs are pure functional programs which compute imperative programs (and then run them)
10:11:26 <kmc> (conceptually; the reality of an implementation like GHC is much different)
10:11:34 <benmachine> kmc: would it be fair to say that the imperative program has impure semantics?
10:11:43 <sipa> sure
10:11:52 <tac-tics> Reisen: In some particular cases, IO does "cheat" the type system. But you it doesn't need to.
10:12:02 <kmc> how does IO cheat the type system?
10:12:21 <benmachine> kmc: as much as I like the evaluaton/execution explanation, I feel like you're saying "there's no problem" when I don't think that's true
10:12:23 <tac-tics> kmc: Sorry. I should say, compilers can cheat the system. And they often do it in IO.
10:12:26 <benmachine> there's a problem it's just comparatively small
10:12:36 <kmc> no problem of what sort?
10:12:43 <benmachine> kmc: wrt purity
10:12:54 <kmc> i don't know what you mean
10:13:21 <benmachine> I'm arguing that the 'imperative program' that you talk about is impure
10:13:35 <kmc> sure
10:13:38 <kmc> i'm not disputing that
10:13:38 <benmachine> ok cool
10:13:41 <sipa> that imperative program is represented by a valud of type IO a, it sure is impure
10:13:54 <benmachine> then we have no argument, except (I guess) how important it is to mention that :P
10:14:03 <Reisen> Alright, I'm extremely confused
10:14:13 <monochrom> reading http://www.haskell.org/haskellwiki/Introduction_to_IO will only reinforce the fact that the IO type is treated special by the compiler, none the least because it cannot be a user-defined type.
10:14:17 <benmachine> Reisen: sorry, I distracted from the explaining it by talking about how to explain it
10:14:29 <Reisen> benmachine, It's alright
10:14:37 <kmc> Reisen, the IO type has a special implementation, but it does not have special semantic rules
10:14:41 <kmc> much like, say, Int
10:15:00 <kmc> Int is an ordinary Haskell type, you work with it like any other (abstract) data type, but it has a special machine-level implementation
10:15:10 <kmc> same with IO
10:15:23 <tromp> http://en.wikipedia.org/wiki/Quantum_programming#Quantum_lambda_calculi
10:15:56 <Reisen> kmc, perhaps my confusion here is coming from the fact that I don't understand what you mean by evaluation and execution here
10:16:15 <kmc> Reisen, evaluation is what happens when you apply a function to an argument and then ask for the result
10:16:20 <kmc> it's the pure computational part of Haskell
10:16:43 <kmc> execution is what happens when you take a description of some IO and actually perform the IO so described
10:16:59 <robert[]> tromp++
10:17:05 <companion_cube> so you first have to evaluate an IO before you perform it, right?
10:17:08 <kmc> yes
10:17:16 <kmc> you have to know what to do before you do it
10:17:34 <kmc> though this is somewhat opaque to the programmer, because the IO type is abstract
10:17:37 <kmc> its constructors are not exposed
10:17:41 <kmc> (in normal haskell)
10:17:54 <kmc> you can use 'seq' to evaluate an IO action without executing it
10:18:05 <kmc> nothing much will happen
10:18:11 <Reisen> kmc, at the risk of saying something completely wrong and misunderstanding everything you said
10:18:21 <Reisen> putStrLn "hello" then is pure, applying putStrLn to that argument is pure
10:18:26 <Reisen> but what the function DOES to do that is inpure?
10:18:31 <sipa> no
10:18:37 <sipa> putStrLn is pure
10:18:40 <sipa> it takes a string
10:18:53 <sipa> and creates an imperative program that will print a message
10:19:11 <sipa> however, applying putStrLn to a string does not execute that program
10:19:17 <sipa> it merely builds a description of it
10:19:38 <sipa> now, if you do that in a main function
10:19:50 <sipa> you hand that description to the Haskell runtime
10:19:59 <sipa> which *will* execute it, and perform impure side effects
10:20:03 <kmc> 'main' isn't a function but otherwise that's correct
10:20:17 <sipa> kmc: apologies - i keep making that mistake
10:20:28 <Reisen> Ok, so the question I have then is, how exactly are the 'impure function' putStrLn create, created
10:20:33 <Reisen> I'm assuming that's the special part
10:20:34 <kmc> it's not an impure function
10:20:39 <kmc> but yes, that's special
10:20:44 <kmc> it's like asking how to implement (+) for Int
10:20:50 <kmc> it's something the compiler gives you as a primitive
10:20:51 <sipa> Reisen: it's indeed special, and hidden from the user
10:20:59 <kmc> i can go into the details of how GHC does it
10:21:04 <benmachine> well, it must either be special or built out of special parts
10:21:04 <kmc> but that's not helpful to understanding IO conceptually
10:21:06 <Reisen> Hang on, mind quickly clarifying pure/impure because I think
10:21:07 <kmc> it's probably actively harmful
10:21:10 <Reisen> I've misunderstood what it means to be either
10:21:18 <kmc> I think you should abandon the terms "pure" and "impure" entirely
10:21:18 <companion_cube> main is the IO execution entry point, i guess
10:21:21 <benmachine> e.g. you could write putStrLn [] = putChar '\n'; putStrLn (x:xs) = putChar x >> putStrLn xs
10:21:25 <opqdonut> well putStrLn is easy to define in terms of putChar
10:21:25 <kmc> i think you'll find nothing in haskell is "impure"
10:21:26 <opqdonut> yeah
10:21:36 <tac-tics> "purity" is kinda a meta-concept
10:21:57 <kmc> all functions are pure functions, putStrLn included
10:21:59 <benmachine> purity is a concept that's mostly applicable in languages with a more general notion of "function"
10:22:14 <kmc> *cough*more broken*cough*
10:22:17 <benmachine> :P
10:22:20 <kmc> Reisen, given a string, putStrLn always returns the same imperative program
10:22:31 <kmc> i mean given the same string it returns the same program
10:22:35 <robert[]> i need a proof of weak normalization
10:22:40 <kmc> and applying that function has no observable effect
10:22:42 <kmc> so it's a pure function
10:22:42 <Reisen> So I am to think here then for example
10:22:44 <sipa> and it does not do anything but compute that imperative program
10:22:45 <robert[]> simple typed lambda calculus
10:22:57 <FUZxxl> @djinn (a->x->b) -> (b->x->c) -> (a->x->c)
10:22:57 <lambdabot> f a b c d = b (a c d) d
10:23:12 <Quantumplation> is `elem` part of a typeclass?
10:23:15 <Reisen> Let me ask a different question then, I know you recommend abandoning the idea of pure/impure but
10:23:17 <sipa> :t elem
10:23:18 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:23:19 <byorgey> Quantumplation: no
10:23:20 <kmc> Quantumplation, no
10:23:21 <Reisen> I'd still like to understand this
10:23:33 <sipa> Reisen: try to explain it as you understood it
10:23:33 <kmc> Reisen, if you'd like to understand it, then you should abandon the idea of pure/impure
10:23:46 <FUZxxl> :t >=>
10:23:47 <lambdabot> parse error on input `>=>'
10:23:51 <FUZxxl> :t (>=>)
10:23:51 <kmc> Reisen, do you understand what I mean when I say putStrLn returns an imperative program?
10:23:52 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:23:56 <Reisen> What about something like readLine, I can understand that readLine will always return the same program, that would make it pure, same output. But that program must get a value back to haskell, and that value could be different, isn't that impure?
10:24:07 <Reisen> kmc, not entirely, I imagined it as more of an abstract idea
10:24:08 <kmc> i don't know, is it?
10:24:12 <FUZxxl> @help djinn
10:24:12 <lambdabot> djinn <type>.
10:24:12 <lambdabot> Generates Haskell code from a type.
10:24:12 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
10:24:14 <sipa> Reisen: it doesn't get a value back into haskell
10:24:17 <kmc> you're the one pushing this word "impure"
10:24:19 <kmc> what does it mean to you?
10:24:24 <sipa> it only describes a program that does something to it
10:24:32 <Reisen> What I thought it meant, was something that didn't return the same output for the same input
10:24:36 <tac-tics> Reisen: the "getting a value back" to Haskell part is what bind (aka >>=) does
10:24:48 <kmc> Reisen, you are right that the steps of IO execution and Haskell evaluation will be interleaved
10:24:53 <kmc> (>>=) :: IO a -> (a -> IO b) -> IO b
10:25:02 <kmc> Reisen, it's not really an abstract idea.  programs can manipulate programs
10:25:06 <sipa> Reisen: assume you have an action readInt :: IO Int, and a function writeInt :: Int -> IO ()
10:25:08 <kmc> a compiler or an interpreter does this
10:25:14 <sipa> Reisen: ok?
10:25:18 <Reisen> Ok
10:25:29 <robert[]> "syntactic finitary methods are too weak to prove normalization"
10:25:30 <sipa> you are writing a program that reads a number, and outputs its double
10:25:30 <Quantumplation> hrm... When defining my Edge type, obviously an Edge has two endpoints.  What's the best way to store this for an undirected graph (so, essentially, order of the two endpoints doesn't matter)
10:25:53 <tac-tics> @type getLine >>= (\line -> putStrLn line)
10:25:54 <lambdabot> IO ()
10:25:57 <sipa> Reisen: that would be: readInt >>= (\x -> writeInt (x*2))
10:26:12 <Reisen> sipa, ok
10:26:19 <kmc> Reisen, are you confused about what the semantics of Haskell are?
10:26:19 <benmachine> Quantumplation: you could choose a canonical order and be sure to always use the same one?
10:26:20 <kmc> or are you confused about whether the philosophical term "impure" applies to the semantics of Haskell?
10:26:50 <kmc> sorry, got to run.. brb
10:26:53 <sipa> Reisen: all you've done now is say: "I'd like to get a program, that first performs readInt, and when it receives an answer, doubles it, and pass it to writeInt"
10:27:00 <Reisen> kmc, I honestly don't know how to answer that, but I think my confusion is probably the second, as I've no idea how purity would apply to haskell
10:27:20 <sipa> Reisen: so you've combined two "programs"
10:27:31 <Reisen> sipa, ok
10:27:46 <sipa> the second one however refers back to haskell (the doubling)
10:27:59 <byorgey> "refers back to Haskell"?
10:28:53 <sipa> byorgey: (\x -> writeInt (x*2)) is a description of an imperative program that receives an integer, and outputs its double
10:29:07 <sipa> but the description of that doubling is done in Haskell
10:29:07 <tac-tics> Reisen: Honestly, IMO, it's easier to "just write some programs" and then worry about how it works afterwards :)
10:29:40 <byorgey> sipa: the description of the whole thing is done in Haskell.  I don't understand the distinction you are trying to make.
10:29:51 <Reisen> tac-tics, yeah, I have been playing with Haskell, but I'm really only learning it out of spare time interest, and so finding out how it works i the most interesting part
10:30:00 <Reisen> is
10:30:17 <tac-tics> Reisen: the pattern ioCommand >>= (\value -> ...) is how you run a command, get the value, and then do something with it
10:30:28 <sipa> i guess i see "elementary" actions of type IO a as not being part of Haskell - they are only exposed as black boxes
10:30:34 <tac-tics> Reisen: If you want to know HOW the IO monad works, start with the State monad
10:30:39 <sipa> but Haskell is used to combine them
10:30:39 <Quantumplation> benmachine: Alright, so Edge (Node, Node) where the first is the one with the lower NodeID.  How would I allow the user to say Edge (10,11) or Edge (11,10) and result in the same data: Edge (10,11).  I'd prefer the USER wasn't constrained by such semantics
10:30:48 <Reisen> tac-tics, hang on
10:31:04 <Quantumplation> do I have to write a helper function, makeEdge, or is there some easier way?
10:31:22 <Reisen> tac-tics, I thought I understood what (>>=) did, but I'm a little confused by what you said, basically just to see if giving an example helps
10:31:24 <Reisen> With the single program
10:31:29 <Reisen> main = putStrln "Hello"
10:32:01 <Reisen> What is different about putStrLn to every other function, that makes this a function that can do something with side-effects
10:32:10 <sipa> it doesn't
10:32:23 <sipa> it is only a description of something that does side effects
10:32:50 <Reisen> sipa, hmm, I haven't read a lot about purity, let me describe the way I see things working
10:32:54 <benmachine> Quantumplation: what I'd do is define a function 'edge' instead of exposing the Edge constructor directly
10:33:28 <Quantumplation> *nods* alrighty, thank ye
10:33:31 <Reisen> The way I understood it was, if you could prove a function was pure, you could guarantee that a function will execute successfully, and even reason what the value will be
10:33:45 <Reisen> So you could for example, optimize out functions that do nothing, because they're pure, and have no side-effects
10:34:12 <sipa> Reisen: in that case (except for exceptions), all haskell functions are pure
10:34:26 <Reisen> Right, that's how I had it explained to me
10:34:28 <tac-tics> Reisen: That's now how Haskell works (although other languages work on that principle)
10:34:42 <sipa> Reisen: even putStrLn is pure
10:34:45 <Reisen> That haskell was completely pure, and that IO was black magic that did impure things with no more explanation other than 'magic'
10:34:59 <sipa> Reisen: you give it a String, and given some string, it will always compute the same IO () object
10:35:06 <sipa> and that is *all* it does
10:35:25 <Reisen> sipa, yeah so my confusion is why does Haskell not remove putStrLn from the compiled program, what makes it different that haskell can make putStrLn execute something special, and not assume it can remove it without changing the program
10:35:37 <sipa> Reisen: because it is used as return value of main
10:35:48 <sipa> so you're doing something with it, namely returning it to the runtime
10:35:51 <tac-tics> Reisen: An object of type IO a is essentially "a function which takes as input the entire world, and returns a value of type a and a modified world"
10:36:21 <bscarlet> Reisen: your criterion for removing something is a little strong. You can't remove something just 'cause it has no side effects. You've got to preserve the result of the function too.
10:36:32 <tac-tics> So putStrLn is really "a function which takes the whole world (including the console), and returns a unit value (aka "()") and an updated version of the world where you printed to the console"
10:37:12 <Reisen> bscarlet, but surely you only have to preserve it if the output matters, which is the side-effect part. Which seems to be main, that main is treated as the single point that everything is important
10:37:17 <tac-tics> Reisen: and getLine is really "a function which takes the whole world (including the console), and returns the first line of the standard input, and an updated version of the world where it has one less line of standard input"
10:37:44 <sipa> Reisen: that's correct
10:37:58 <Reisen> tac-tics, little confused by 'world' here
10:38:09 <sipa> Reisen: main is the entry point - the runtime asks you to give it an imperative program by evaluation main
10:38:22 <rwbarton> I don't think this "World -> (a, World)" viewpoint is going to be very helpful right now
10:38:24 <bscarlet> Reisen: yes, two ways. Firstly, main is the topmost point in the program, so it's that final result which matters. Secondly, the _way_ that it matters is that the IO action to which it evaluates will be executed.
10:38:25 <tac-tics> Reisen: It means a representation of the whole world
10:38:34 <Reisen> sipa, oh, oh hang on, so would I be right in imagining this as
10:38:36 <Reisen> until main returns
10:38:37 <Reisen> nothing happens
10:38:45 <rwbarton> yes!
10:38:47 <sipa> yes!
10:38:50 <rwbarton> haha :)
10:38:51 <Reisen> Ahhhh
10:38:54 <Reisen> Ok
10:38:56 * hackagebot global-variables 1.0 - Namespaced, global, and top-level mutable variables without  unsafePerformIO.  http://hackage.haskell.org/package/global-variables-1.0 (JeanMarieGaillourdet)
10:39:02 <Reisen> Rofl
10:39:04 <Reisen> I got there in the end
10:39:05 <Reisen> Thank you
10:39:06 <sipa> however
10:39:12 <tac-tics> Reisen: Say, you're only IO primitives are putStrLn and getLine. The the whole "world" is a data structure which contains the lines of standard input and the lines of standard output
10:39:19 <sipa> when the runtime starts executing the program you've computed with main
10:39:30 <bscarlet> Reisen: yes! except that "until" isn't so well defined. :-)
10:39:31 <sipa> parts of your haskell program will need to be evaluated
10:40:18 <Reisen> Right, I'm more clear now, tac-tics also I think I see what you mean by worlds then. The 'programs' putStrLn describe are your worlds
10:40:41 <rwbarton> it's pretty well-defined in actuality, but it might not be obvious what the definition is at first.
10:40:43 <sipa> no
10:40:50 <sipa> they describe interactions with the world
10:41:01 <Reisen> I meant like
10:41:31 <Reisen> The worlds he talks about returning
10:41:46 <Reisen> When chaining together IO actions
10:41:54 <Reisen> You're working with a new world that has been interacted with
10:42:09 <Reisen> Actually that sounds really abstract, not even sure what I'm talking about
10:42:30 <Reisen> I'm pretty happy with the understanding I think I have here, where IO actions are just descriptions of what will happen, and those descriptiosn are always he same
10:42:35 <Reisen> So I'll just stick to that
10:42:59 * tac-tics will not use the word "World" next time, in favor of something more tangible.
10:43:05 <rwbarton> now you can think about main = readInt >>= (\x -> writeInt (x*2))
10:43:06 <Reisen> Rofl
10:44:36 <slack1256> tac-tics what could be a better term? (for me to also use it)
10:45:07 <tac-tics> slack1256: "World" is the standard term, actually. In GHC, the data type is even called, RealWorld#
10:45:23 <slack1256> yeah, i think that is why everybody use it
10:45:26 <Quantumplation> so is there no conventional inheritence in Haskell?  I wanted to have one root type, Element, which represents any kind of element on a graph, and then various others (node, edge, cycle, path, claw, etc) and be able to define functions like isPath :: (Element a) => a -> Boolean; isPath Node a [b] = True; isPath Path [xs] = True, etc.
10:45:32 <Quantumplation> Am I just approaching this all wrong? o.O
10:45:47 <slack1256> but something as the current state for me makes most sense, after all the IO monad is just a glorified state monad
10:45:51 <tac-tics> Quantumplation: There's no inheritence at all in Haskell
10:46:02 <rwbarton> Quantumplation: those all sound like different types
10:46:10 <tac-tics> slack1256: Yup
10:47:01 <Quantumplation> i mean, a Graph might be made up of a list of elements, so I can describe a graph as a cycle and a path, or something.
10:47:14 <Quantumplation> (shit, gotta run to class, bbl)
10:52:59 <kmc> the world-transformer analogy for IO can be useful
10:53:09 <kmc> but it's fundamentally incorrect
10:53:25 <kmc> the world can change in between your actions
10:53:43 <kmc> and your actions can run concurrently in non-deterministic ways
10:53:49 <monochrom> none the least because the type RealWorld# hardly holds data from the outside world
10:54:04 <kmc> yeah, the GHC implementation of IO looks superficially like the world-transformer analogy
10:54:10 <kmc> but that's misleading too
10:54:17 <kmc> I'm not sure this analogy is more helpful than the truth
10:54:30 <dmwit> My quantum world transformer analogy beats the pants off your normal world transformer. It has no problem handling non-determinism: simply enter all possible next worlds.
10:54:49 <slack1256> ?
10:55:32 <KirinDave> kmc: Does the world-transformer metaphor inherently suggest sequencing? I guess I never really considered that angle.
10:55:49 * tac-tics plans to reinvent the real world state transformer representation of IO by using unsafeInterleaveIO with some kind of existential typing to account for unknown programs running in parallel.
10:55:59 <monochrom> world transform + determinism gives sequencing
10:56:23 <sipa> the idea is that if you have two IO actions a and b, and they are represented as RealWorld -> (a, RealWorld) transformations
10:56:48 <sipa> then the assumption is that the RealWorld object received by b in (a >> b) is the one produced by a
10:56:50 <sipa> (at least, that's how i interpret it)
10:57:00 <kmc> i thought the point of the RealWorld was that you can write a Monad instance for it
10:57:06 <kmc> (which is the same as the Monad instance for State)
10:57:18 <kmc> and then yes, your definition of (>>=) encodes that assumption
10:57:24 <slack1256> IO glorified state monad
10:57:30 <kmc> but it's not, at all
10:57:30 <sipa> well, yes, in actual implementation it may be true
10:57:42 <sipa> but then the RealWorld doesn't have much relation with The Real World (tm)
10:58:05 <kmc> stop talking about the GHC implementation of IO like it has anything to do with the state-transformer analogy of IO
10:58:10 <tac-tics> IO = exists f : RealWorld -> RealWorld such that (w:  RealWorld) -> (a, f w)
10:58:11 <kmc> they're really totally different
10:58:19 <kmc> the "functions" inside GHC's IO newtype aren't functions
10:58:21 <sipa> yes, i was talking about the analogy, not the implementation
10:58:23 <kmc> and the world token represents nothing
10:59:04 <kmc> it's just introducing artificial data dependencies so that lazy evaluation of the underlying impure "functions" will implement the semantics of IO execution
10:59:14 <parcs> RealWorld seems to have no constructors
10:59:16 <kmc> so it's totally weird and backwards compared to how Haskell works
10:59:19 <parcs> that's pretty deep
10:59:20 <kmc> RealWorld is a phantom type
10:59:30 <kmc> it's used in a phantom type position
10:59:33 * tac-tics thinks kmc has finally convinced him of this fact
10:59:53 <kmc> (State# t) has no constructors either
11:00:02 * bscarlet thinks kcm has convinced him of not (this fact)
11:00:04 <kmc> it's a primitive type which has a 0-bit runtime representation
11:00:10 <kmc> which fact?
11:00:11 * tac-tics tears up a bit, and mumbles under his breath about how he's going to go back to writing Monad Taco-analogy tutorials. 
11:00:22 * dmwit believes in his heart that (this fact)
11:00:28 <sipa> wow wow wait, Taco?
11:00:34 <sipa> i thought it was a burrito!
11:00:43 * tac-tics thinks burrito is too hard to spell
11:00:53 <parcs> sipa: well a taco is like a burrito
11:00:56 <sipa> my world view falls apart!
11:00:56 <dmwit> expressed in modal logic: ♥(this fact)
11:01:00 <kmc> (an unboxed type)
11:01:05 <tac-tics> Plus, Tacos can leak more easily than burritos. Just like IO :D
11:01:10 <sipa> loi
11:02:23 <bscarlet> kmc: Your arguments seem to depend on problems with specific limited definitions of what a RealWorld might be/represent, and I'm not sure I buy those limitations.
11:02:40 <plat0> kmc: What are you suggesting as the "right way"?
11:02:57 <monochrom> Tacology
11:03:09 <kmc> plat0, the right way to explain IO?
11:03:21 <plat0> Explain or rthink f it.
11:03:25 <plat0> *think of it.
11:03:25 <bscarlet> Tacoology, actual.
11:03:30 <kmc> IO actions are imperative programs
11:03:36 <kmc> they're descriptions of IO which has not yet occurred
11:03:51 <bscarlet> Tacology goes together with Ticology
11:04:01 <plat0> So you require non-strict semantics?
11:04:07 <kmc> i do?
11:04:26 <dmwit> plat0: The right way to think of it is to read Tackling the Awkward Squad, where they give an operational semantics for IO programs.
11:04:36 <plat0> Yeah, otherwise you can't do main = do { print "hi"; main }
11:05:32 <plat0> With strict semantics that never terminates.
11:05:49 <plat0> zygoloid explained this to me.
11:05:58 <kmc> plat0, the right-hand argument to (>>=) is a function anyway
11:06:45 <plat0> Sure, but if you have strict evaluation, you're going to try to evaluate it before doing any IO.
11:06:55 <kmc> in a strict language i'd do like «newtype IO a = (() -> ImperativeProgram a)»
11:06:58 <plat0> I don't think you can do monadic IO with strict evaluation, but I may be wrong.
11:06:59 <kmc> that works, right?
11:08:00 <sipa> you can only evaluate functions for which you have an argument
11:08:01 <plat0> You mean faking the non-strictness by wrapping it in a function call?
11:08:11 <kmc> yeah
11:08:11 <plat0> Sounds plausible.
11:08:22 <sipa> so you could avoid all strictness by turning IO a actions into () -> IO a functions
11:08:32 <kmc> that's a standard technique for getting non-strict semantics in strict languages
11:08:36 <dmwit> plat0: main = fix (\main' -> print "hi" >> main') -- looks fine in a strict language, fix's argument is a function (and therefore evaluated)
11:08:40 <kmc> (you can't get actual lazy eval strategy without some extra work)
11:09:13 <dmwit> plat0: Along with main = print "hi" >> main being syntactic sugar for a call to fix, of course.
11:10:01 <plat0> You mean the monad instance should use fix in its >>= rule?
11:10:08 <dmwit> I do not mean that.
11:10:22 <parcs> how is it determined whether a package announcement should be posted on the ML or net
11:10:24 <parcs> not*
11:10:37 <dmwit> parcs: Would you like to write an announcement email?
11:10:43 <dmwit> If so, it goes on the mailing list. =)
11:11:15 <plat0> Oh ok, syntactic sugar, i.e. new syntax.
11:11:34 <dmwit> No, the same syntax.
11:11:54 <monochrom> we know how to get lazy evaluation out of an eager language. it is just sometimes even being odd.
11:11:55 <plat0> But do you mean 'main = print "hi" >> main' should be translated to 'fix (\main' -> print "hi" >> main')'?
11:13:05 <dmwit> Seems like a pretty easy translation to me. Any binding "f = expr" in which "expr" mentions "f" can be replaced by "f = fix (\f -> expr)".
11:13:55 <dmwit> Eh, it's probably not that simple.
11:14:09 <dmwit> But I think GHC already does this kind of analysis, identifying which collections of bindings are mutually recursive.
11:14:13 <monochrom> it is that simple. it is just not always done.
11:14:37 <monochrom> oh, yes, GHC computes mutually recursive groups.
11:14:58 <monochrom> the type-checker is the first customer of that.
11:15:11 <dmwit> uh huh
11:15:40 <dmwit> Oh, I was answering a different question than the one plat0 asked. Yes, I do mean that translation should be done.
11:15:52 <dmwit> (And sort of is, even now.)
11:15:58 <plat0> OK
11:17:10 <parcs> dmwit: some package announcement are posted on the haskell ML, which is supposed to be low-volume
11:19:41 <dmwit> parcs: Yeah. I'm not sure there's a written policy anywhere.
11:20:34 <monochrom> you can announce nothing, too
11:21:24 <monochrom> or your package is binding haskell to some linux API, so you announce in Linus's mailing list :)
11:23:35 <dmwit> This global-variables announcement is a bit disingenuous.
11:23:45 <dmwit> "Look ma, no unsafePerformIO!"
11:23:51 <dmwit> ...but it uses unsafePerformIO.
11:25:34 <monochrom> we need more such libraries
11:26:15 <JuanDaugherty> is there like a hrails?
11:26:23 <monochrom> no
11:26:57 <Taejo> JuanDaugherty: there are Haskell web frameworks. I have no idea how Rails-like they are
11:27:08 <dmwit> yesod, snap, and happstack are the three most popular web libraries.
11:27:23 <dmwit> Like Taejo, I'm super ignorant about how railsy they are.
11:27:28 <rudyl313> Is there a good rule of thumb for when I should use a Map and when I should use a type with record syntax?
11:27:49 <JuanDaugherty> there are not like grails/rails at all
11:28:01 <sipa> rudyl313: whether you know the keys at compile time?
11:28:02 <JuanDaugherty> *they are not
11:28:03 <dmwit> rudyl313: Yes. When you know the keys statically, use a record.
11:28:08 <parcs> you shouldn't ever need global variables, and if your system is complex enough to require them then that package will at most remove an INLINE pragma and a call to unsafePerformIO
11:28:12 <rudyl313> JuanDaugherty: there are web frameworks like Snap and Yesod, but not very rails-like
11:28:27 <dmwit> parcs: It's thread-safe, at least.
11:28:33 <dmwit> So that's one bug down.
11:28:38 <rudyl313> dmwit: so theres not case for using a Map if you know the keys ahead of time?
11:28:50 <dmwit> rudyl313: Rules are made to be broken.
11:28:55 <JuanDaugherty> rudyl313, yes I just mentioned them an hour or so back
11:28:57 <Taejo> rudyl313: depends what operations you want to perform
11:29:15 <monochrom> Map and record are pretty unrelated
11:29:26 <rudyl313> do both retrieve values quickly?
11:29:32 <rudyl313> what if I have a boatload of keys?
11:29:38 <rudyl313> making a type would seem hard
11:29:45 <rudyl313> I mean annoying
11:29:49 <monochrom> only overlap is "I have 100 names to refer to 100 booleans".
11:29:52 <JuanDaugherty> (2 hours)
11:30:19 <parcs> dmwit: and the conventional way is not?
11:30:45 <kmc> parcs, i don't think needing global variables is a matter of "complex"
11:30:51 <kmc> there are some very simple examples where it's very hard to avoid
11:31:05 <parcs> like what?
11:31:14 <kmc> FFI bindings
11:31:25 <kmc> where you need a global lock or a global "initialized library yet?" flag
11:32:06 <dmwit> rudyl313: You may be interested in this question on SO: http://stackoverflow.com/questions/7561670/haskell-beginner-question-defining-pairs-similar-to-http-statuses/7563173
11:32:34 <monochrom> but if it is "I have 78 names to refer to 12 drummers drumming, 11 pipers piping, 10 lords-a-leaping... and a patridge in a pear tree", you can't even use Map, so there is no way you can compare how Map does it with how record does it.
11:33:10 <dmwit> I later learned that answer isn't quite right (for example, functions on big enumerations get compiled to jump tables, not linear lookup -- go GHC!). But it's a good start.
11:33:46 <parcs> kmc: do you have a more concrete example?
11:34:28 <kmc> you have a thread-unsafe C library; you want the Haskell API to be thread-safe
11:34:40 <kmc> you protect the C calls with a global MVar lock
11:35:08 <kmc> or maybe you have a global Chan so that requests can be sent to a dedicated library-worker bound thread
11:35:17 <kmc> (of course you hide these things from the user)
11:35:39 <parcs> ah, yeah. but ffi is an outlier :P
11:35:52 <plat0> Shouldn't the lock be implemented C-side?
11:36:32 <dmwit> Haskell's concurrency is better than C's concurrency.
11:36:50 <kmc> I don't enjoy writing concurrent code in C, do you?
11:37:34 <kmc> also I expect the Haskell-side lock to interact nicely with the GHC green-thread scheduler in a way the C-side lock won't without lots of extra work
11:38:07 <kmc> though that may only matter if it lets you use "foreign import unsafe", which is dubious anyway
11:38:23 <plat0> Basically the whole system should be written in Haskell.  That's my favoured solution :)
11:38:38 <kmc> meh, that's often a poor use of time
11:39:48 <plat0> Are there any standard uses of IO (IO a) values?
11:39:57 <sipa> :t join
11:39:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:40:04 <kmc> plat0, http://hackage.haskell.org/packages/archive/spawn/0.3/doc/html/Control-Concurrent-Spawn.html
11:40:42 <kmc> do { future <- spawn (getHTTP "http://blah"); ... other stuff ...;  result <- future }
11:41:43 <plat0> OK that's nice.
11:42:01 <kmc> then for example  parMapIO f xs = mapM (spawn . f) >>= sequence
11:42:03 <plat0> I was just trying to think of good examples of IO which cannot be done in terms of Arrows.
11:42:26 <kmc> concurrent imperative programming with higher-order functions and closures is great
11:42:30 <dmwit> I've had m (IO a) values, where m was an instance of MonadIO (and had to be).
11:43:01 <kmc> this is my favorite example of why treating 'imperative' and 'functional' like enemies is stupid
11:43:22 <dmwit> Something to do with catching exceptions in MonadIO-ic code, let's see...
11:43:26 <dmwit> :t catch
11:43:26 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
11:44:11 <kmc> (er, that's parMapIO f xs = mapM (spawn . f) xs >>= sequence)
11:44:28 <kmc> :t (>>= sequence)
11:44:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [m a] -> m [a]
11:45:10 <kmc> plat0, there's also incremental IO things
11:45:49 <kmc> data Nom a = Moar (IO (a, Nom a)) | Kthx
11:46:06 <dmwit> parMapIO f xs = mapM (unsafePerformIO . spawn . f) xs
11:46:13 <kmc> nooooo
11:46:29 <dmwit> =)
11:46:37 <plat0> kmc: what do you mean incremental io things?
11:46:45 <monochrom> I have IO (IO Blah) because I want to return a procedure for you to use later (in fact you can use it over and over again). for example the procedure gives you "the next thing in a message queue" when you use it". but to create this procedure, I need to do my own IO first, like, creating the message queue.
11:46:47 <kmc> plat0, i gave an example
11:47:03 <kmc> plat0, an IO action which gives you a partial result and another IO action to get more
11:47:14 <plat0> OK so it keeps returning you stuff as long as it keeps Moaring
11:47:19 <Quantumplation> data myType = N Int String;  How do I write a function that takes [myType] but allows me access to Int and String? I don't like record syntax x.x
11:47:41 <kmc> plat0, yeah
11:47:49 <Quantumplation> myFunc (N a b):xs = ; isn't working
11:48:02 <kmc> SPJ's "Beautiful Concurrency" paper defines  choose :: [(STM a, a -> IO ())] -> IO ()
11:48:03 <dmwit> Ah, here we go:
11:48:03 <tac-tics> Quantumplation: you need more paraens
11:48:05 <dmwit> Main.hs:37:transCatch :: MonadIO m => IO a -> (IOError -> m a) -> m a
11:48:06 <dmwit> Main.hs:38:transCatch io m = join . liftIO $ catch (liftM return io) (return . m)
11:48:10 <kmc> which isn't exactly what you asked for, but is nicely higher-order
11:48:17 <tac-tics> Quantumplation: myFunc ((N a b): xs) = ...
11:48:20 <Quantumplation> ah, ok
11:48:22 <Quantumplation> sweet =D
11:48:25 <ion> “myFunc (N a b):xs” = “(myFunc (N a b)):(xs)”
11:48:33 <dmwit> plat0: Not quite IO (IO a) there, but m (m a) for a MonadIO m. =)
11:48:34 <tac-tics> Quantumplation: and I believe you can actually lose the inner pair around (N a b)
11:48:35 <plat0> monochrom: but when is it /really/ necessary to return an IO Blah rather than a state token which is passed to a stateToken -> IO Blah?
11:48:50 <kmc> never
11:48:58 <plat0> Or rather, when is it /best expressed/ in that way.
11:49:02 <kmc> right
11:49:15 <kmc> i think it's best expressed in the simplest way
11:49:20 <plat0> I agree.
11:49:34 <kmc> i think actions producing actions are simpler than actions producing tokens which may separately be redeemed for more actions
11:49:50 <monochrom> I don't understand what the hell a state token has to do with giving you a procedure for reading a queue.
11:50:33 <plat0> If you have a function stateToken -> IO Blah, then one of the former yields one of the latter.
11:50:37 <monochrom> should I give you a RealWorld# state token so you can perform arbitrary I/O?
11:50:53 <monochrom> no, sorry, I understand even less as you explain.
11:50:54 <plat0> Maybe "state" was the wrong word.
11:52:48 <plat0> What I'd like to know are some circumstances when it's really *far* more convenient to return an 'IO a', rather than return a 'b' which you later feed to a 'b -> IO a'.
11:53:32 <monochrom> I can only see that some people ask "why not give the queue / a handle to the queue, then let the user use readChan?"
11:53:46 <kmc> plat0, that seems backwards
11:54:04 <monochrom> my first answer is "maybe it is Chan today, but tomorrow I change my mind and it is TChan"
11:54:09 <kmc> you're asking after situations where the extra complexity is not justified
11:54:13 <kmc> when you have not justified it yourself
11:54:31 <kmc> how about I define (+) :: Int -> Int -> AdditionResult and then getAdditionResult :: AdditionResult -> Int
11:54:41 <monochrom> my second answer is "if you have a handle to my Chan/TChan/whatever, I can't stop you from writing to it"
11:54:49 <kmc> then we can rename (+) to AdditionResultFactoryProxySingleton
11:55:57 <plat0> Yes I see your point, but the reason I ask is that computations of type a -> IO (IO b) cannot be done using Arrows.
11:56:14 <plat0> And most IO stuff you will want to do *can* be done using Arrows.
11:56:35 <plat0> So it seems that it's quite special things that will ever use IO (IO a) -> IO a
11:57:22 <kmc> what's the argument that most IO stuff you will want to do *can* be done using Arrows?
11:59:52 <plat0> "most" is not clearly defined, but this is why I asked what natural uses of IO (IO a) there are.  If spawn is one of the least complicated then it seems like it's special stuff that involves running computations in interesting ways that can't be done with Arrows.  I find that interesting.
11:59:55 <kmc> can you write some nontrivial IO code using Arrow?
12:00:08 <plat0> Not all of it, but most of it.
12:00:13 <kmc> can i see it?
12:00:30 <kmc> can you write sequence :: [IO a] -> IO [a]
12:00:50 <plat0> No of course not.  That is "special stuff that involves running computations in  interesting ways that can't be done with Arrows.
12:00:53 <plat0> "
12:01:06 <kmc> define "special"
12:01:13 <kmc> sequence is not that special, I use it frequently
12:01:17 <plat0> This is what I'm trying to get a feel for.
12:01:31 <plat0> I'm not trying to imply it's rare.
12:01:32 <kmc> sequence = mapM id
12:01:38 <kmc> so you can't write mapM either
12:01:40 <Saizan> sequence should be doable
12:02:03 <rwbarton> isn't something that's the complement of "most of it" fairly described as "rare"?
12:02:05 <plat0> I'm trying to distinguish what can be done with arrows from what can't.
12:02:51 <plat0> rwbarton: No I don't think so.  Most of the letters I write are not "z" but I'd hardly call "z" rare.
12:03:08 <kmc> plat0, the thing is, «IO (IO a) -> IO a» is the type of 'join', and for a pointed functor, either join and (>>=) is enough to recover the other.  so a variant of IO without join is probably lacking (>>=)
12:03:20 <monochrom> @type (>=>)
12:03:20 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:03:26 <kmc> what does the Arrow class give you to make up for that?
12:03:30 <kmc> i think not very much
12:03:36 <monochrom> if you can rewrite your stuff with >=>, you can use Arrow
12:03:56 <rwbarton> why can't you just set a = () then?
12:04:02 * hackagebot asn1-data 0.6.1 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.6.1 (VincentHanquez)
12:04:05 * rwbarton is confused
12:04:19 <Saizan> you can write join with (>=>) :)
12:04:20 <plat0> Yes and you can use >=> for anything that doesn't involve IO (IO a)
12:04:26 <Saizan> i'm not sure if that's what plat0 means
12:04:42 <plat0> No, writing join with >=> is cheating :)
12:05:03 <Saizan> ?type \x -> (const x) >=> id
12:05:04 <lambdabot> forall a (m :: * -> *) c. (Monad m) => m (m c) -> a -> m c
12:05:04 <plat0> I mean in arrow implementation that doesn't give you access to the monad instance of IO.
12:05:22 <kmc> i'd like to see some IO code written in this style
12:05:43 <plat0> You can write anything in this style which doesn't implicitly use IO (IO a)
12:06:08 <kmc> can you write mapM
12:06:23 <Saizan> ?type let sequenceA [] = arr (const []); sequenceA (x:xs) = (x &&& sequenceA xs) >>> arr (uncurry (:)) in sequenceA
12:06:24 <lambdabot> forall (a :: * -> * -> *) b a1. (Arrow a) => [a b a1] -> a b [a1]
12:06:57 <Saizan> ?type let sequenceA [] = arr (const []); sequenceA (x:xs) = (x &&& sequenceA xs) >>> arr (uncurry (:)) in \f -> sequenceA . map f
12:06:58 <lambdabot> forall (a :: * -> * -> *) b a1 a2. (Arrow a) => (a2 -> a b a1) -> [a2] -> a b [a1]
12:07:29 <plat0> kmc: no you can't write MapM
12:07:42 <kmc> mapM is pretty damn useful
12:07:47 <kmc> but the thing Saizan wrote looks close
12:08:15 <Saizan> mapM is not much, since Applicative is enough
12:10:17 <plat0> Well I don't think the Arrow structure of IO would give you an Applicative either.
12:10:39 <plat0> So this is interesting.  I will think about how to do MapM.
12:10:40 <trinithis> > verySafeLaunchNuclearMissles
12:10:42 <lambdabot>   "Launching missles in T minus 10, 9, 5, 7, 3, 2, 1, launching!"
12:10:49 <Saizan> well, you'd be wrong
12:11:30 <FUZxxl> :t verySafeLaunchNuclearMissles
12:11:31 <lambdabot> [Char]
12:13:24 * sipa is glad it isn't IO [Char]
12:13:51 <plat0> Saizan: what I mean is that if you have a type ArrowIO which implements the Arrow class, then that doesn't give you enough to get an Applicative.
12:14:03 * hackagebot certificate 0.9.4 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.9.4 (VincentHanquez)
12:14:15 <plat0> Of course if you still have access to >>= then that's a different matter ...
12:14:41 <Saizan> plat0: yeah, and for every type k you can write an instance of Applicative (k a) just by using Arrow k
12:20:44 <plat0> Applicative (k a) is the functor Hom(a,-) in the category k?
12:21:27 <Saizan> yeah
12:21:59 <plat0> OK, so you're saying I can use that and sequenceA to get MapM
12:22:13 <Saizan> "mapM" but yes
12:22:29 <plat0> That's nice!
12:22:30 <Saizan> you still can't get join though
12:22:50 <plat0> No I know.  You have to have a monad for that.
12:23:11 <plat0> The Arrow k is half of the adjunction.  You don't get a join without the other half.
12:23:29 <plat0> This is what I'm trying to work out.  What IO can you reasonably do without join?
12:24:03 * hackagebot tls 0.8.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.8.1 (VincentHanquez)
12:24:36 <rwbarton> I still don't understand what exactly you are proposing to do
12:24:42 <rwbarton> what is ArrowIO?
12:24:52 <sipa> :k ArrowIO
12:24:53 <lambdabot>     Not in scope: type constructor or class `ArrowIO'
12:25:02 <sipa> :k Num
12:25:03 <lambdabot>     Class `Num' used as a type
12:25:03 <lambdabot>     In the type `Num'
12:25:05 <ingy> greetings
12:25:10 <rwbarton> is ArrowIO a b a newtype of a -> IO b?
12:25:21 <plat0> Yeah it could be, say.
12:25:21 <Saizan> i'm assuming so
12:25:29 <plat0> Or a reimplementation of IO.
12:25:30 <rwbarton> and I have an instance Arrow ArrowIO
12:25:36 <ingy> I was wondering if I could ask for help with: https://gist.github.com/1282262
12:25:37 <plat0> It's basically the Kleisli category of the IO monad.
12:26:10 <plat0> But I'm thinking of it's algebraic structure rather than actually implementing it.
12:27:17 <rwbarton> oh I see where I am confused, ok
12:27:21 <plat0> Essentially I think the question is "what IO actions can you build without using the monad structure"?
12:27:23 <Saizan> you can't write something equivalent to ifM :: m Bool -> m a -> m a -> m a
12:28:01 <Saizan> ifM m t f = do b <- m; if b then t else f
12:28:32 <plat0> OK, so conditionally running computations.  That makes sense.
12:29:43 <DanBurton> @let ifPrime b t f = if b then t else f
12:29:43 <lambdabot>  Defined.
12:29:49 <DanBurton> :t liftM3 ifPrime
12:29:50 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m a2 -> m a2
12:30:08 <Saizan> yeah, that's not the same thing
12:30:31 <DanBurton> how is liftM3 if' different than your version?
12:30:34 <DanBurton> won't it behave the same?
12:30:38 <Saizan> no
12:30:39 <kmc> it runs both branches regardless
12:31:02 <benmachine> > liftM3 ifPrime (Just True) (Just 7) Nothing
12:31:03 <lambdabot>   Nothing
12:31:16 <DanBurton> ooh
12:31:28 <benmachine> @let ifM m t f = do b <- m; if b then t else f
12:31:28 <DanBurton> @let ifM m t f = do b <- m; if b then t else f
12:31:28 <lambdabot>  Defined.
12:31:29 <lambdabot>  <local>:5:0:
12:31:29 <lambdabot>      Warning: Pattern match(es) are overlapped
12:31:29 <lambdabot>               In...
12:31:31 <benmachine> :P
12:31:32 <DanBurton> :)
12:31:36 <plat0> Actually ArrowIO is not the Kleisli category, since that implicitly contains a way to run computations.  I'll have to think harder about what I mean by ArrowIO.  Thanks for the useful ideas.  Sorry if I annoyed you by being vague.
12:31:45 <DanBurton> > ifM (Just True) (Just 7) Nothing
12:31:47 <lambdabot>   Just 7
12:31:50 <benmachine> et voila
12:32:24 <benmachine> interesting point: liftA3 ifPrime needs only Applicative
12:32:27 <benmachine> whereas ifM needs Monad
12:32:37 <benmachine> (liftA3 is the same as liftM3)
12:32:44 <benmachine> (roughly)
12:35:15 <DanBurton> let ifA b t f  = (\x -> if x then t else f) <$> b -- doesn't work because it needs monadic "join"?
12:35:48 <Saizan> check the type
12:36:06 <DanBurton> :t let ifA b t f = (\x -> if x then t else f) <$> b in ifA
12:36:07 <lambdabot> forall (f :: * -> *) b. (Functor f) => f Bool -> b -> b -> f b
12:36:42 <ingy> is this the right channel to ask about cabal issues?
12:36:56 <DanBurton> @let ifA b t f = (\x -> if x then t else f) <$> b
12:36:57 <lambdabot>  Defined.
12:37:23 <DanBurton> ingy: sure; doesn't guarantee anyone active right now knows how to help, though :(
12:37:33 <DanBurton> > ifA (Just True) (Just 7) Nothing
12:37:35 <lambdabot>   Just (Just 7)
12:37:50 <ingy> DanBurton: ok, thx
12:38:15 <shirt> http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/Control-Concurrent.html#g:12
12:38:20 <DanBurton> ah...the `b` is polymorphic, in this case when you feed it applicatives it becomes `f a`
12:38:40 <shirt> Is the code there under "Terminating the program" absolutely correct? i'm getting "thread blocked indefinitely in an MVar operation" in waitForChildren
12:39:54 <erus`> could someone build the haskell bindings to openal for me :) (windows)
12:40:48 <DanBurton> erus`: Maybe during VirtuaHac?
12:41:08 <erus`> when is that?
12:41:22 <erus`> DanBurton: they are on hackage i just cant compile them
12:41:52 <DanBurton> erus`: its a "virtual" hackathon later this month
12:42:24 <DanBurton> @where virtuahac
12:42:24 <lambdabot> I know nothing about virtuahac.
12:42:36 <DanBurton> @where+ virtuahac http://www.haskell.org/haskellwiki/VirtuaHac
12:42:36 <lambdabot> Good to know.
12:43:55 <Eidel> Can you check the type of a variable? Like, "(Num 2) == type Num" or something
12:44:20 <DanBurton> Eidel: in the interpreter you can use :t to check the type of an expression
12:44:47 <DanBurton> but type checking is done at compile time, not necessarily run time
12:44:48 <kmc> the Num defined in Prelude is not a type
12:44:54 <kmc> anyway, Eidel, check out Data.Typeable
12:44:59 <kmc> but I should ask why you want to do this
12:45:09 <kmc> because it's unusual and probably indicates a bad design somewhere
12:46:32 <Eidel> Ok. Maybe ill have to do something else. Im using recursion in a data structure.. Dont want to have to many different guards, rather have an if-else
12:46:50 <kmc> why are those your two alternatives?
12:46:55 <kmc> can't you use pattern-matching instead?
12:47:01 * DanBurton thinks guards are prettier than if/else
12:47:15 <kmc> Eidel, do you have a small example you can put on hpaste?
12:48:39 <erus`> is there an audio library that is known to build on windows?
12:48:45 <Eidel> kmc: I think i will use pattern matching. Thanks
12:49:02 <kmc> pattern-matching is usually the better option when it is available
12:49:38 <Eidel> :) I like it. Haskell is a great language
12:49:41 <shirt> erus`: SDL should work
12:50:14 <erus`> i think that needs cygwin too
12:50:48 <shirt> erus`: no
12:51:12 <shirt> erus`: you just need to unzip the binary SDL dev files from the sdl site
12:51:32 <erus`> SDL-0.6.2 failed during the configure step. The exception was:
12:51:52 * DanBurton hearts pattern matching
12:52:02 * tac-tics pattern matches in his sleep.
12:52:54 <shirt> erus`: you can ignore that. read the instructions: http://mirror.seize.it/hsSDL/hssdl/WIN32
12:53:55 <rata_> what's the simplest library to draw a grid? (may be to a png file or to a window)
12:54:36 <tac-tics> rata_: GLUT is pretty simple for drawing graphics
12:59:52 <shachaf> tibbe: You moved to SF?
13:00:16 <shachaf> tibbe: You should come to bahaskell! http://groups.google.com/group/bahaskell
13:00:24 <tibbe> shachaf: I did
13:00:31 <tibbe> shachaf: I signed up for the mailing list
13:00:36 <tibbe> I'll look out for the next meeting
13:01:07 <shachaf> tibbe: I think it'll be next week.
13:01:55 <tibbe> shachaf: do you know where?
13:02:23 <shachaf> tibbe: EngineYard, near the last Caltrain station.
13:03:06 <rata_> isn't there something like "draw array"?
13:03:25 <shachaf> tibbe: What brought you here?
13:03:42 <tibbe> shachaf: that sounds close enough
13:03:44 <Taejo> rata_: what does the array contain? points on a curve, bitmap data, ...?
13:03:46 <tibbe> shachaf: what time?
13:03:52 <tibbe> shachaf: work
13:04:10 <rata_> Taejo: bitmap data for example
13:04:23 <shachaf> tibbe: Usually 19:00.
13:04:24 <Taejo> rata_: there are several bitmap libraries
13:04:26 <tibbe> shachaf: I don't see any announcement of the next meetup
13:04:42 <Taejo> pgm has a nice interface but it's greyscale only; I haven't used any of the others
13:06:10 <shachaf> tibbe: It's usually on the third Wednesday of the month, I think.
13:06:17 <shachaf> It's not confirmed yet.
13:06:31 <shachaf> tibbe: Do you want to talk about something? :-)
13:07:32 <tibbe> shachaf: the meeting after that I could. I'm in the middle of moving at the moment so I don't have time to prepare
13:08:33 <rata_> Taejo: have you used one?
13:09:28 <Taejo> rata_: I like pgm, but it's greyscale only, and only outputs PGMs (an uncompressed format)
13:10:15 <kmc> shachaf, the last Caltrain station is in Gilroy :)
13:10:19 <rata_> for what I need now, greyscale is ok, even black and white is ok =)
13:11:59 <Botje> hmm
13:12:03 <Eidel> :r
13:12:06 <Botje> anyone know of a nice exercise involving Maps?
13:12:12 <Botje> I can only come up with a phone book :[
13:13:51 <shachaf> kmc: When I go there on the Caltrain, they announce "this is the last stop".
13:13:51 <DanBurton> Botje: you mean Map as in the data type?
13:14:08 <DanBurton> Botje: or the higher-order function `map` ?
13:14:16 <kmc> shachaf, you are educated stupid
13:14:35 <Botje> first
13:14:44 <Botje> the data type
13:14:44 <shachaf> Four simultaneous stations in a single rotation of the train?
13:14:45 <kmc> (that, and the Gilroy service is weekdays rush hour only)
13:14:58 <kmc> what's the exercise for, Botje?
13:15:18 <DanBurton> Botje: try this: implement "mode" (most common element in an unordered list) by using an IntMap
13:15:36 <shachaf> kmc: I meant last going north, of course.
13:15:38 <DanBurton> mode :: [a] -> a
13:15:48 <DanBurton> mode :: Eq a => [a] -> a
13:15:50 <kmc> ah
13:15:50 <DanBurton> rather
13:15:58 <Botje> DanBurton: ooh, frequency tables! there's an idea
13:16:01 <kmc> implement an evaluator for arithmetic expressions with variables
13:16:05 <Botje> thanks :)
13:16:09 <kmc> using Map to hold the environment
13:16:15 <Botje> kmc: tomorrow's haskell class :)
13:16:20 <kmc> :)
13:16:22 <angstrom> when I do `:t (. (==))' I get `Eq a => ((a -> Bool) -> c) -> a -> c'. but when I do `let f = (. (==))' and then `:t f' I get `((() -> Bool) -> c) -> () -> c'. why is that? and what does it mean?
13:16:28 <Botje> they're not quite up to evaluators yet
13:16:34 <shachaf> angstrom: Monomorphism restriction.
13:16:40 <kmc> yeah, also normal people don't find evaluators interesting ;)
13:16:42 <shachaf> @google monomorphism restriction
13:16:43 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:16:44 <lambdabot> Title: Monomorphism restriction - HaskellWiki
13:16:58 <angstrom> shachaf: thanks.
13:17:11 <DanBurton> angstrom: to avoid this, you can give f an explicit type in the let statement
13:17:24 <angstrom> ah. I see
13:17:26 <kmc> find duplicate files in a directory, using a Map from hashes to lists of filenames
13:18:43 <DanBurton> @google uses for the map data structure
13:18:44 <lambdabot> http://en.wikipedia.org/wiki/Associative_array
13:18:44 <lambdabot> Title: Associative array - Wikipedia, the free encyclopedia
13:19:11 <DanBurton> first example - phonebook -___-
13:19:19 <ingy> hi shachaf
13:19:32 <shachaf> ingy: Hello!
13:19:42 <DanBurton> @google casting spels lisp
13:19:43 <lambdabot> http://www.lisperati.com/casting.html
13:20:00 <shachaf> ingy: Want to come to the bahaskell meeting? It's likely on the 19th, though it's not certain yet.
13:20:24 <DanBurton> That lisp tutorial uses associative arrays somehow. I don't recall quite how, though; it's been a while.
13:20:32 <ingy> shachaf: ok. need a speaker? :)
13:21:03 <shachaf> ingy: Quite possibly. Do you have something to speak of?
13:21:17 * DanBurton wants to come to bahaskell. Anyone willing to pay for a plane ride? ;)
13:21:33 <erus`> where is it?
13:21:41 <DanBurton> ba = bay area
13:21:42 <shachaf> DanBurton: kmc has priority on the bahaskell plane-ticket-to-CA budget.
13:21:45 <ingy> shachaf: quite possibly. :)
13:21:45 <DanBurton> California
13:21:55 <ingy> shachaf: can you look at https://gist.github.com/1282262 for me?
13:22:24 <DanBurton> shachaf: fair enough
13:22:27 <shachaf> ingy: If so you should email Ivan.
13:22:44 <shachaf> ingy: Hmm, what version of GHC/haskell-platform are you running?
13:23:39 <shachaf> You might be best off downloading the GHC 7 binary and installing haskell-platform yourself. Ubuntu tends to be quite outdated with its Haskell packages.
13:23:52 <ingy> shachaf: 2010.1.0.0.1ubuntu0.1
13:23:55 <shachaf> (Installing cabal should still work, though.)
13:24:33 <ingy> i've been down many roads. seems something fundamental is broke.
13:25:00 <Quantumplation> data Node = N ID [Edge]; data Edge = E ID (Node, Node);  Graphs are described by [(nodeID, [otherNodeID's])].  How would I construct that, when in order to construct the node, you need to construct the edges, and in order to construct the edges, you need to construct the nodes. :-S
13:25:32 <shachaf> ingy: Hmm, does `ghc-pkg check` say anything useful?
13:25:32 <rferranti> you are fucked lol
13:26:13 <ingy> shachaf: on natty, i purge and install haskell-platform. rm -fr ~/.cabal. cabal update. cabal install cabal-install. boom
13:26:37 <ingy> seems like that should work at a minimum
13:26:54 <ingy> shachaf: I'll gist you the output
13:26:59 <shachaf> Hmm. Is there anything in /usr/{local,}lib/ghc-* after you purge?
13:27:09 <DanBurton> Quantumplation: erm...use "undefined" as a very hacky base case?
13:27:33 <DanBurton> Quantumplation: that or...looks like Nodes can have an empty list of edges
13:27:56 <ingy> shachaf: trying again...
13:28:30 <DanBurton> Quantumplation: that or...it's ok to recursively define stuff. let n = N 123 [e]; e = E 234 (n, n)
13:29:07 <Quantumplation> even if it references something "ahead" of what you're defining?
13:29:36 <erus`> Quantumplation: there is no order in source files
13:29:36 <shachaf> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
13:29:37 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
13:29:37 <DanBurton> remember in Haskell, nothing is sequenced unless it's a monadic action that you explicitly sequence
13:29:39 <erus`> its not liek c
13:29:59 <DanBurton> well, what I said isn't quite true, but it's the general idea of it.
13:30:02 <shachaf> DanBurton: Monadic actions don't have any magic sequencing powers. :-(
13:30:02 <Quantumplation> ah, ok...
13:30:21 <DanBurton> shachaf: but >>= magically sequences stuff for some monads
13:30:23 <shachaf> ingy: I don't know very much about Ubuntu's packaging of Haskell. I gave up on it at one point and just installed the GHC binary myself. :-)
13:30:58 <shachaf> DanBurton: And ++ magically sequences things for some lists. It's just a function.
13:31:32 <ingy> shachaf: interestingly I had it all working fine, but a debian guy couldn't do it, so I started from scratch, and now all is fail
13:31:33 <DanBurton> shachaf: well, yes. But ++ doesn't sequence actions...last time I checked.
13:31:54 <DanBurton> shachaf: fsvo "sequence"
13:32:40 <trinithis> Does anyone feel like it is okay to make instances of Monad that do not follow the monad laws?
13:32:49 <shachaf> DanBurton: Sure it does. data Action = Print String | Exit Int; [Print "Hello"] ++ [Print "World"]
13:32:52 <cgroza> DanBurton: it just uses data dependency to simulate sequencing
13:33:04 <shachaf> trinithis: IO doesn't follow the laws.
13:33:12 <trinithis> how so?
13:33:14 <DanBurton> trinithis: as long as when you don't use it as if it followed laws
13:33:15 <shachaf> trinithis: But in general, no, it's not really OK. :-)
13:33:38 <DanBurton> s/when you/---
13:33:53 <DanBurton> oh you know what I meant :P
13:34:15 <ingy> shachaf: nothing in those lib/
13:34:26 <shachaf> trinithis: ((undefined :: IO Int) >>= return) =/= undefined
13:34:46 <trinithis> mm
13:34:49 <DanBurton> shachaf: couldn't you say that about any monad? Isn't undefined cheating?
13:34:58 <donri> > sequence_ $ [print 1] ++ [print 2]
13:35:00 <lambdabot>   <IO ()>
13:35:35 <shachaf> > ((undefined :: Maybe Int) >>= return) `seq` 5
13:35:35 <Kaidelong> DanBurton: >> can act like a ++ for things of type IO () and is just a special case of >>=
13:35:36 <lambdabot>   *Exception: Prelude.undefined
13:35:36 <geekosaur> I think he's referring to a specific violation of the monad laws by (>>=) for IO
13:35:58 <shachaf> ingy: Hmm. And does `ghc-pkg check` say anything?
13:36:33 <Kaidelong> pretty sure it'd act associative and that you could have a "zero" for it in terms of the operations that actually happen (return ())
13:36:34 <DanBurton> > ((undefined :: IO Int) >>= return) `seq` 5
13:36:35 <lambdabot>   5
13:36:40 <DanBurton> WHAT
13:37:00 * DanBurton 's brain explodes
13:37:33 <AtnNn> danburton: seq only evaluates to whnf
13:38:07 <DanBurton> > return undefined :: IO Int
13:38:07 <lambdabot>   <IO Int>
13:38:11 <shachaf> AtnNn: The point is that (>>= return) *doesn't* evaluate to WHNF. :-)
13:38:38 <DanBurton> shachaf: but...but...why??? o_O
13:38:54 <Kaidelong> DanBurton: Cause then you could do IO and return a pure value
13:39:01 <shachaf> Kaidelong: Huh?
13:39:01 <Kaidelong> using what you just did
13:39:08 <rwbarton> > ((undefined :: IO Int) >>= (undefined :: Int -> IO Int)) `seq` 5
13:39:09 <lambdabot>   5
13:39:15 <rwbarton> >>= is effectively a constructor
13:39:23 <shachaf> What rwbarton said.
13:39:26 <Kaidelong> shachaf: Am I wrong?
13:39:28 <rwbarton> if you like that view of IO
13:39:30 <shachaf> It's still a violation, though, isn't it?
13:40:02 * DanBurton is still clueless
13:40:13 <rwbarton> possibly, you have to be ultra-careful while stating the monad laws if you care about _|_ though
13:40:30 <cgroza> DanBurton: Are you trying to understand the IO monad?
13:40:32 <rwbarton> specifically, you must not accidentally eta expand/reduce them
13:40:46 <DanBurton> cgroza: basically, yes
13:40:54 <Kaidelong> Mmm I guess you don't need to actually run an IO action to check if it is bottom
13:40:58 <cgroza> DanBurton: I tried that and gave up already.
13:41:06 <Kaidelong> so I suppose it doesn't mess with purity actually
13:41:08 <Kaidelong> sorry shachaf
13:41:09 <shachaf> rwbarton: Is the "normal" version of the Monad laws accidental eta-expanded/reduced?
13:41:28 <DanBurton> cgroza: well *someone* ought to know the logic behind why it works the way it does
13:41:36 <AtnNn> > ((undefined :: Maybe Int) >>= return) `seq` 6
13:41:38 <lambdabot>   *Exception: Prelude.undefined
13:41:57 <DanBurton> > ((undefined :: [Int])) >>= return `seq` 6
13:41:58 <lambdabot>   *Exception: Prelude.undefined
13:42:35 <DanBurton> dare I ask...how is >>= implemented for IO, then?
13:42:54 <Kaidelong> from what I understand >>= is magical for IO
13:42:55 <rwbarton> shachaf: I haven't really thought about it, since I don't care about _|_ that much.
13:43:10 <rwbarton> But I would say the canonical form of the laws is the one in terms of join and return
13:43:12 <kmc> (>>=) for IO in GHC?
13:43:19 <DanBurton> Kaidelong: -____-
13:43:31 <shachaf> @src IO (>>=)
13:43:32 <lambdabot> m >>= k     = bindIO m k
13:43:33 <kmc> GHC implements IO with impure 'functions' and implements sequencing with fake data dependencies
13:43:35 <Kaidelong> and I'm not sure if the GHC take on it can even be written in Haskell, but I think there are ways to implement >>= for which you can
13:43:41 <DanBurton> kme: sure
13:43:50 <engla> properties with _|_ are _|_-lessly boring
13:43:51 <Kaidelong> well pure haskell
13:44:07 <shachaf> DanBurton: Keep in mind that the GHC implementation is very implementation-specific and isn't something you need to care about in general.
13:44:31 <kmc> and it's an ugly hack ;)
13:44:39 <DanBurton> shachaf: so as far as the language goes, does the Haskell 2010 report specify that it's OK for IO to break the monad laws then?
13:44:47 <shachaf> Probably not.
13:45:02 <kmc> i think it's informally agreed that the laws don't matter wrt ⊥
13:45:28 <shachaf> Hah, the Report specifies the Monad laws using "==".
13:45:31 <DanBurton> Perhaps I should ask this: does the GHC implementation of the IO monad break the monad laws *excluding* _|_ ?
13:45:36 <shachaf> I wonder if it's implying that all Monads must be in Eq.
13:45:48 <kmc> DanBurton, I don't think so
13:45:53 * Kaidelong can't think of how you'd be able to make >>= not associative
13:45:55 <Quantumplation> (a -> b) -> [a] -> [b] <-- which list operator is this? map, foldr/l, scanr/l?
13:46:02 <shachaf> Quantumplation: map
13:46:04 <kmc> i mean, it depends on your equality
13:46:04 <ingy> shachaf: It seems haskell-platform doesn't cleanly install https://gist.github.com/1282498
13:46:10 <shachaf> @hoogle (a -> b) -> [a] -> [b]
13:46:10 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
13:46:10 <Quantumplation> kk, thankee
13:46:10 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
13:46:10 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
13:46:22 * DanBurton hearts hoogle
13:46:27 <Quantumplation> oo, hoogle? *googles* =P
13:46:35 <kmc> you can probably distinguish x from foldr (>>) id ([x] ++ replicate 10000 (return ()))
13:46:38 <kmc> by checking the runtime ;P
13:46:48 <kmc> (foldr (>>) (return ()) i mean)
13:46:48 <DanBurton> @where hoogle
13:46:48 <lambdabot> http://haskell.org/hoogle
13:46:55 <donri> @google hoogle
13:46:56 <lambdabot> http://www.haskell.org/hoogle/
13:46:56 <lambdabot> Title: Hoogle
13:46:59 <donri> @hoogle google
13:46:59 <lambdabot> Google rocks!
13:47:00 <lambdabot> No results found
13:47:02 <donri> ^_^
13:47:04 <DanBurton> o_O
13:47:05 <kmc> @. google nixon
13:47:06 <lambdabot> http://www.brainyquote.com/quotes/quotes/r/richardmn116923.html
13:47:06 <lambdabot> Title: The presidency has many problems... at BrainyQuote
13:47:18 <kmc> @. google . elite nixon
13:47:19 <lambdabot> No Result Found.
13:47:39 <Kaidelong> kmc: Wouldn't that be a monoid law anyway?
13:47:48 <kmc> it follows from a monad law
13:47:52 <Kaidelong> ooh
13:48:20 <shachaf> ingy: Hmm. That looks like something is messed up with the package manager, or something.
13:48:23 <kmc> i think?
13:48:47 <DanBurton> > ((undefined :: IO Int) >=> return) `seq` 3
13:48:47 <lambdabot>   Couldn't match expected type `a -> m b'
13:48:48 <lambdabot>         against inferred type `GHC....
13:49:03 <DanBurton> > ((undefined :: Int -> IO Int) >=> return) `seq` 3
13:49:04 <lambdabot>   3
13:49:27 <DanBurton> > ((undefined :: Int -> IO Int) <=< return) `seq` 3
13:49:28 <lambdabot>   3
13:49:28 <kmc> how about return x vs. foldr1 (>=>) (replicate 10000 return) x
13:49:34 <kmc> the laws are nicer in terms of (>=>) anyway
13:49:56 <shachaf> kmc: But the implementation of (>>=) from (>=>) is ugly.
13:50:12 <DanBurton> implementation of >>= from join is nice
13:50:30 <kmc> :t join . fmap ?f
13:50:31 <lambdabot> forall (m :: * -> *) a a1. (Monad m, ?f::a1 -> m a, Functor m) => m a1 -> m a
13:50:39 <shachaf> The laws in terms of join/fmap/return are probably nice, but I never remember them.
13:51:17 <c_wraith> whoa...  global-variables package.  Interesting.
13:51:31 <DanBurton> Yeah I saw that too
13:51:46 <DanBurton> but where are the docs on how to use it? >,<
13:53:17 <Quantumplation> http://pastebin.com/c39fQVB8 it's complaining about XNetwork on line 4, what am I doing wrong? x.x
13:53:19 <mauke> The paste c39fQVB8 has been copied to http://hpaste.org/52524
13:53:38 <kmc> join . fmap join ≡ join . join
13:53:50 <kmc> join . fmap return ≡ join . return ≡ id
13:53:51 <kmc> i think
13:54:33 <rwbarton> that looks right
13:54:39 <mauke> Quantumplation: parens
13:54:40 <DanBurton> :t join . fmap return
13:54:41 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m a -> m a
13:54:45 <kmc> (i cheated and looked it up)
13:54:50 <DanBurton> gasp
13:54:55 <DanBurton> @where monadlaws
13:54:55 <lambdabot> http://www.haskell.org/haskellwiki/Monad_Laws
13:54:59 <shachaf> Just like monoid laws, really.
13:55:20 <shachaf> Are there only two laws?
13:55:45 <DanBurton> somebody should add that version of the monad laws to the wiki page
13:55:46 <rwbarton> That was three laws, associativity and left and right units
13:56:09 <shachaf> Oh, yes.
13:56:19 <Quantumplation> mauke: if I remove the parens, it complains about a parse error on makeGraph
13:56:46 <mauke> Quantumplation: you're missing some
13:58:24 <kmc> can we just say  join ≡ fmap join,  return ≡ fmap return
13:58:29 <Quantumplation> I think I found it.  I was misunderstanding what $ did
13:59:44 <kmc> and join . return ≡ id
13:59:51 <shachaf> > join [["ab","cd"],["ef","gh"]]
13:59:52 <lambdabot>   ["ab","cd","ef","gh"]
13:59:52 <shachaf> > fmap join [["ab","cd"],["ef","gh"]]
13:59:53 <lambdabot>   ["abcd","efgh"]
14:00:16 <kmc> apparently not
14:00:45 <kmc> > (join . join) [["ab","cd"],["ef","gh"]]
14:00:46 <lambdabot>   "abcdefgh"
14:01:28 <kmc> > (join . join) [ [["ab","cd"],["ef","gh"]] , [["AB","CD"],["EF","GH"]] ]
14:01:30 <lambdabot>   ["ab","cd","ef","gh","AB","CD","EF","GH"]
14:01:34 <kmc> > (join . fmap join) [ [["ab","cd"],["ef","gh"]] , [["AB","CD"],["EF","GH"]] ]
14:01:36 <lambdabot>   ["ab","cd","ef","gh","AB","CD","EF","GH"]
14:02:04 <shachaf> If you'll forgive the horrible abuse of notation, join (m1 (m2 (m3 a))) == m12 (m3 a), whereas fmap join (m1 (m2 (m3 a))) == m1 (m23 a)
14:02:26 <kmc> mm
14:02:27 <shachaf> The only guarantee you get is that you get the same m123 either way.
14:02:32 <kmc> so that's the associativity law
14:02:48 <shachaf> Similarly to monoids, if you express that as m1 * m2 * m3
14:03:55 <Quantumplation> http://hpaste.org/52527 am I on the right track for a cyclic definition? having the findEdges seems really weird to me x.x
14:04:29 <kmc> shachaf, so you're saying it's not guaranteed that m12 (m3 a) ≡ m1 (m23 a), but if I squash it again, the two have to be equal
14:04:31 <kmc> that makes sense
14:04:40 <shachaf> Yep.
14:05:16 <rwbarton> so, the objection was that undefined >>= return is not undefined?
14:05:31 <rwbarton> when we should have m >>= return equal to m
14:05:50 <shachaf> That was my objection, unless I misunderstand the monad laws.
14:05:59 <rwbarton> so let's see which unit law that is
14:06:24 <rwbarton> m >>= f = join (fmap f m)
14:07:10 <kmc> shachaf, thanks for explaining
14:07:24 <rwbarton> so it's saying   join (fmap return m) = m
14:07:53 <erus`> :t join
14:07:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:07:56 <shachaf> > fmap (return::Int->IO Int) (undefined::IO Int) `seq` 5
14:07:57 <lambdabot>   5
14:07:59 <rwbarton> While the "real" law is   join . fmap return = id
14:08:24 <shachaf> Ah, I see.
14:08:25 <rwbarton> > (join . fmap (return::Int->IO Int)) (undefined::IO Int) `seq` 5
14:08:27 <lambdabot>   5
14:08:39 <rwbarton> So, it looks like it doesn't satisfy that law either.
14:09:17 <erus`> > join . fmap return 1
14:09:18 <lambdabot>   No instance for (GHC.Num.Num (f (m a)))
14:09:18 <lambdabot>    arising from a use of `e_11' at ...
14:09:40 <erus`> > join $ fmap return 1
14:09:41 <lambdabot>   No instance for (GHC.Num.Num (m a))
14:09:41 <lambdabot>    arising from a use of `e_11' at <int...
14:09:59 <rwbarton> I was hoping the difference between those two laws would somehow account for this `seq` issue, but I guess not.
14:10:03 <ion> > (join . fmap return) [1]
14:10:04 <lambdabot>   [1]
14:10:58 <shachaf> seq is stupid anyway.
14:11:29 <shachaf> No one said you should be able to force IO values.
14:11:57 <rwbarton> That's pretty much my conclusion also.
14:12:56 <shachaf> > fmap id (undefined::IO Int) `seq` 3
14:12:56 <lambdabot>   3
14:16:30 <Quantumplation> how do I map a data constructor over a list?  so something like, data Edge = E (Int, Int); map (E) [(Int, Int)]
14:17:00 <sipa> zipWith
14:17:07 <shachaf> Quantumplation: If you have it defined like that, then you can just do what you said.
14:17:13 <cgroza> Quantumplation: use a lambda?
14:17:47 <cgroza> :t zipWith
14:17:48 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:17:49 <DanBurton> Quantumplation: Not the best solution, but you could try: map (uncurry E)
14:17:58 <DanBurton> Quantumplation: if you are stuck with a list of tuples
14:18:15 <shachaf> DanBurton: Well, you don't even need that, since E is defined to take a tuple.
14:18:21 <shachaf> Not that you want to define E to take a tuple.
14:18:25 <DanBurton> shachaf oh right
14:18:29 <Quantumplation> ah, forgot to curry the first parameter to the data constructor
14:19:12 <Quantumplation> it was data Edge = E Int (Int, Int) not just E (Int, Int)
14:24:14 <msieradzki> I have cabal package that references C binding of C++ library and it seems to require -fPIC for ghci lib and dynamic lib but cabal adds -fPIC only for C-sources for dynamic lib. Is there any easy workaround for that?
14:25:23 <msieradzki> (C-sources contains .cpp file that just won't link properly without -fPIC when using -shared and somehow GHCi asks for dynamic version of whole cabal/ghc package)
14:26:08 <msieradzki> I don't exactly understand what is GHCi using: does it load static-like special version for GHCi or does it use dynamically-linked ghc package or just the dynamically-linked C++ library?
14:35:04 <shachaf> preflex: seen mzero
14:35:05 <preflex>  mzero was last seen on #haskell 1 day, 15 hours, 23 minutes and 30 seconds ago, saying: adding them to my cabal file and getting all the version numbers right?  :-)
14:37:49 <Quantumplation> if I have a findNode :: Graph -> ID -> Node; what's the proper behavior if a node with ID is not found? undefined? or do I have to wrap Node in Maybe for all my code?
14:38:17 <kmc> Maybe
14:38:24 <sipa> make it findNode :: Graph -> ID -> Maybe Node
14:38:33 <kmc> unless a) you know it can never actually happen, or b) you really want the entire program to crash in that case
14:38:41 <sipa> or findNodeWithDefault :: Node -> Graph -> ID -> Node
14:38:45 <kmc> it's not reasonable to return 'undefined' and then catch it elsewhere
14:38:54 <kmc> so it really is "crash whole program, kthx"
14:39:08 <Quantumplation> but then anything that uses findNode has to use Maybe Node, right?
14:39:16 <kmc> 'has to use'?
14:39:23 <kmc> when you call a function, you have to use its return type
14:39:26 <companion_cube> unsafePerformProgramCrash
14:39:51 <kmc> the callers of findNode can themselves return a Maybe value, or they can make it go away by pattern-matching
14:39:59 <kmc> or using one of the functions like fromMaybe or 'maybe'
14:39:59 <Quantumplation> ah
14:40:00 <Quantumplation> ok
14:40:01 <kmc> :t fromMaybe
14:40:02 <lambdabot> forall a. a -> Maybe a -> a
14:40:03 <kmc> :t maybe
14:40:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:44:03 <Quantumplation> if I use fromMaybe, what's the behavior when I pass it Nothing?
14:45:25 <monochrom> @type fromMaybe
14:45:26 <lambdabot> forall a. a -> Maybe a -> a
14:45:39 <shachaf> @src fromMaybe
14:45:39 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
14:45:45 <monochrom> fromMaybe "hello" Nothing = "hello"
14:46:07 <Quantumplation> ah ok
14:46:43 <shachaf> > fromMaybе "hello" Nothing
14:46:44 <lambdabot>   "or is it?"
14:46:58 <dcoutts_> msieradzki: are you including the C code directly into the Haskell package, or compiling a separate C lib and having the Haskell package link to it externally?
14:48:20 * monochrom blinks blinks
14:48:33 <monochrom> > "fromMaybе"
14:48:34 <lambdabot>   "fromMayb\1077"
14:48:37 <monochrom> hehe
14:51:06 <msieradzki> C++ directly (which has C interface) in  C-sources in cabal
14:51:51 <dcoutts_> msieradzki: I see, and then you have problems loading it in GHCi
14:52:03 <dcoutts_> unless you compile with -fPIC
14:52:22 <msieradzki> yes because -fPIC for G++ tells it to generate vtable symbols in other way
14:52:45 <dcoutts_> msieradzki: my suggestion would be to build the C++ code as an external shared lib, and have the Haskell package depend on that externally
14:52:58 <dcoutts_> then ghci will load the external shared lib
14:53:00 <msieradzki> to be concrete
14:53:09 <msieradzki> bullet cabal package depends on bullet .so files
14:53:29 <msieradzki> cabal package has huge Bullet.cpp which defines Bullet C++ wrapper with C interface
14:53:57 <donri> > "hello"
14:53:58 <lambdabot>   "hello"
14:53:58 <dcoutts_> msieradzki: you could try using cc-options: -fPIC
14:54:02 <msieradzki> what I just told you before that was on my tiny test case which tried to mimic it but it doesn't reference anything outside, just C-sources and c2hs
14:54:04 <msieradzki> hmm
14:54:46 <dcoutts_> msieradzki: honestly, it's a bit of a miracle if ghci can load the Haskell static lib if it contains object code from g++
14:55:09 <dcoutts_> dynamically loading static .a libs is somewhat black magic
14:55:49 <msieradzki> cc-options hasn't helped, I'm checking --verbose=3 if it was really passed
15:02:00 <msieradzki> first funny thing is that it seems that vtable symbol gets generated at link time
15:02:44 <msieradzki> my cpp file is called a_bind.cpp and in dist/build neither a_bind.dyn_o nor a_bind.o have set to non-zero
15:02:53 <msieradzki> then libHSx...so magically has it
15:02:59 <mebaran151> what are the best data types for Datetime and Money
15:03:24 <mebaran151> I'm putting together a simple webapp, but I'm not quite sure how to handle the Data.Fixed types
15:03:34 <msieradzki> while HSx-0.1.o (which I think is used by ghci) doesn't have it
15:20:29 <kate_r> hi
15:20:44 <shirt> yo
15:23:32 <hpaste_> “Mukesh Tiwari” pasted “Pcap file decoding” at http://hpaste.org/52530
15:24:18 <kate_r> does anyone know how to logically express that if for some x of type A then f(x) = 0 but if x is of type B then f(x) = 1?
15:26:43 <shirt> kate_r: what is the type of f?
15:27:03 <mebaran151> maybe make types A and types B instance some predetermined interface?
15:27:19 <keep_learning> Hello every one
15:28:19 <keep_learning> I am working with pcap and wrote this program http://hpaste.org/52530
15:29:00 <kate_r> shirt, let's say it's polymorphic 'a => 'b
15:29:49 <kate_r> mebaran151, but how do i express that logically?
15:29:53 <keep_learning> could some one please tell me how to print the capture time in print $ hdrSeconds p in   hour : min : sec Day : Month : year format
15:30:48 <keep_learning> Also the data part in Hex format so how to print it normal readable format
15:31:52 <mebaran151> kate_r, I'm a bit of haskell newbie myself, but it sounds like what typeclasses are meant for
15:33:48 <shirt> kate_r: yeah, you could use typeclasss to achieve this, but it looks like you're trying to do something weird
15:33:54 <mebaran151> something like class MyF a where f :: a -> Int
15:34:56 <mebaran151> then you'd have an instance likes instance MyF Type1 where f _ = 1
15:35:10 <mebaran151> and then instance MyF Type where f _ = 2
15:36:48 <kate_r> yeah
15:36:59 <kate_r> but how could i express typeclass in a logical expression?
15:37:11 <mebaran151> what do you mean by a logical expression?
15:37:24 <Axman6> o.O
15:38:02 <kate_r> mebaran151, as in a formal logical formula.
15:38:20 <kmc> kate_r, what problem are you actually trying to solve
15:38:30 <Axman6> class ToInt a where toInt :: a -> Int; instance ToInt Bool where toInt a = 0; instance ToInt Char where toInt a = 1
15:38:49 <hvr> kmc: suspecting an XY problem? :)
15:38:53 <kate_r> kmc, i'm just trying to write it down on paper.
15:39:20 <Axman6> well, i guess the type of toInt in my example would be the logical formula: ToInt a => a -> Int
15:39:49 <Axman6> if ToInt a has been defined (ie there is an instance of ToInt for some a) then toInt had the type a -> Int
15:40:11 <Axman6> class constraints are basically predicates
15:40:14 <kate_r> hmm
15:40:23 <kmc> hvr, yes
15:40:32 <kmc> hvr, "how do I use type classes in bizarre way X" is a common question here
15:40:36 <Axman6> they take a type and say, does this type implement this class? if yes, then the rest of the type can be satisified
15:40:44 <kmc> the answer is almost always "don't use type classes, why did you want to use type classes"
15:42:10 <mebaran151> kmc: probably a result of the Java interface school of how to work with stuff
15:42:47 <kmc> yes
15:42:58 <hvr> or maybe just the term 'type-class' is misleading given the usual meaning of 'class' in programming
15:43:07 <kmc> i think it's deeper than the name collision
15:43:13 <tac-tics> kmc: Maybe that's evidence type classes are poorly explained.
15:43:14 <kmc> Java teaches you that every new behavior requires a new type
15:43:17 <tac-tics> (or at least, poorly named)
15:43:33 <kmc> this is partially because "Java is OOP" but mostly just because Java has weak abstraction
15:43:38 <kmc> it needn't be the case in OOP
15:43:43 <kmc> anyway, in Haskell, behaviors are first-class values
15:43:50 <Pseudonym> hvr: Actually, the usual meaning of "class" in programming is overloaded.
15:43:55 <DukeDave> Ooh, excellent, a discussion on type-classes, here's something I need to get involved in
15:44:09 <Pseudonym> If you say "class Foo" in Java, you're doing THREE separate things.
15:44:11 <kmc> when I do OOP in Haskell, I try to use Haskell types as interfaces
15:44:15 <kmc> not Haskell type classes
15:44:22 <Pseudonym> 1. Declaring a type, "class Foo".
15:44:31 <Axman6> Pseudonym: with only two words? that's super efficient!
15:44:37 <Pseudonym> 2. Declaring a set of types, "class Foo", which is Foo and all of its subtypes.
15:44:39 <kmc> you can make a record of functions
15:44:53 <Pseudonym> 3. Declaring that the type "class Foo" is a member of the class "class Foo".
15:45:20 <Pseudonym> The term "class" actually comes from Goedel-Bernays-von Neumann type theory.
15:45:24 <mebaran151> kmc: how do you dispatch on type sans typeclasses ?
15:45:39 <Pseudonym> A set is a collection of things. In programming, we call that a "type" (more or less).
15:45:58 <DukeDave> kmc: I'm intrigued by your statement: "when I do OOP in Haskell, I try to use Haskell types as interfaces, not Haskell type classes"
15:45:59 <Pseudonym> So, for example, an Int may be the set of whole numbers in the range [-2^63,2^63-1]
15:46:08 <Pseudonym> A "class" is a collection of sets.
15:46:18 <Pseudonym> The two are distinguished to avoid Russell's paradox.
15:46:19 <DukeDave> I suspect it's connected to something I said, which you questioned, yesterday.
15:46:32 <Pseudonym> That's pretty much what Haskell does.
15:46:46 <Pseudonym> A type is a collection of values, and a class is a collection of types.
15:47:03 <DukeDave> Pseudonym: That's a lovely statement
15:47:14 <DukeDave> I wish someone had said that a few years ago :)
15:47:19 <Axman6> @remember Pseudonym A type is a collection of values, and a class is a collection of types.
15:47:20 <lambdabot> Done.
15:47:28 <Pseudonym> It took me 10 years to work it out.
15:47:31 <Axman6> useful to have recorded somewhere
15:47:32 <DukeDave> :D
15:48:31 <DukeDave> May I interject with a classes/types/data-structures problem..
15:48:36 <Pseudonym> Sure.
15:48:47 <Pseudonym> BTW, there's a catch, and that's why it took me 10 years.
15:48:51 <Pseudonym> But I'll get to that later.
15:48:57 <DukeDave> It's something I've brought up a few times in here, and still haven't reached a conclusion..
15:49:02 <DukeDave> Firstly: http://hpaste.org/50899
15:49:08 <DukeDave> A briefly explaination
15:49:11 <Axman6> no get to it now! My whole life might have been a lie D:
15:49:20 <DukeDave> Ha
15:49:32 <Pseudonym> Axman6: data A = A (A -> Bool)
15:49:36 <roconnor> @seen ski
15:49:36 <lambdabot> Unknown command, try @list
15:49:36 <preflex>  ski was last seen on #haskell 1 day, 7 hours, 18 minutes and 2 seconds ago, saying: * ski phaws
15:49:39 <Pseudonym> Perfectly valid Haskell type.
15:49:49 <Pseudonym> But think of it as a set.
15:50:00 <Pseudonym> It's declaring a bijection between A and 2^A.
15:50:15 <Pseudonym> Which we KNOW is impossible.
15:50:40 <Pseudonym> Axman6: Your task is to work out what's wrong.
15:50:45 <Pseudonym> Nobody help him. :-)
15:50:50 <DukeDave> I just don't know what a sensible approach is
15:51:06 * DukeDave nods
15:51:12 <kmc> mebaran151, why do you want to dispatch on types?
15:51:21 <hvr> Pseudonym: what does 2^A mean?
15:51:43 <kmc> mebaran151, usually you can dispatch on constructors
15:52:00 <kmc> or do something the value already knows how to do, i.e. call a function stored inside the data structure
15:52:00 <kate_r> Axman6, the code you gave just now, is that valid haskell?
15:52:01 <Pseudonym> hvr: It's the power set of A.
15:52:05 <mebaran151> I'm new to the whole business, so forgive my naivete
15:52:19 <Pseudonym> Which is isomorphic to the set of functions of type A -> Bool.
15:52:21 <Axman6> kate_r: which code?
15:52:23 <mebaran151> kmc: how do you do constructor dispatch?
15:52:28 <kmc> pattern matching
15:52:46 <kate_r> Axman6, class ToInt a where toInt :: a -> Int; instance ToInt Bool where toInt a = 0; instance ToInt Char where toInt a = 1
15:52:49 <mebaran151> I see, but how do you get the value in the function in the first place to pattern match again?
15:52:55 <kmc> i don't follow
15:52:55 <Pseudonym> A function chi_S :: A -> Bool can be thought of as a set S, where x `elem` S if and only if chi_S x = True.
15:53:27 <Axman6> kate_r: yes, that's perfectly valid
15:53:28 <kate_r> Axman6, but isn't polymorphism in haskell parametric? i thought one can't inspect types with parametric polymorphism.
15:53:38 <Pseudonym> hvr: Did that make sense?
15:53:40 <Axman6> eh?
15:53:59 <Axman6> kate_r: that's an example of probably the most trivial type class you can have
15:54:19 <Pseudonym> ...which makes it an excellent example.
15:54:25 <mebaran151> alright so let's say I'm a neophyte OOP'er: and I define two data structures
15:54:27 <mebaran151> Cat and Dog
15:55:01 <mebaran151> when I call talk on Cat I want to get the string Meow and when I call talk on Dog I want to get bark
15:55:06 <hvr> Pseudonym: if you were describing a characterstic function, then it made sense to me :)
15:55:16 <Pseudonym> hvr: Right.
15:55:20 <hvr> Pseudonym: I just didn't recognize the 2^A notation
15:55:24 <mebaran151> what's the better way to accomplish this without resorting to typeclasses?
15:55:37 <Pseudonym> hvr: We use that notation because for finite sets, |2^A| = 2^|A|
15:56:16 <Pseudonym> Or |2|^|A| where 2 is any set of cardinality 2.
15:56:25 <Pseudonym> e.g. Bool
15:56:50 <mebaran151> I'd figure you create a Talk type class and define talk :: Talk a => a -> String or what not
15:59:20 <shirt> mebaran151: data Animal = Animal { talk :: String }; let dog = Animal { talk = "bark" }
15:59:46 <Pseudonym> class Animal a where
15:59:50 <Pseudonym>     talk :: a -> String
15:59:58 <Pseudonym> data Dog = Dog
16:00:01 <Pseudonym> instance Animal Dog where
16:00:07 <Pseudonym>     talk _ = "bark"
16:00:18 <mebaran151> shirt: I get that; but kmc claimed there was a better way
16:00:32 <shachaf> Pseudonym: That's kind of evil, isn't it?
16:00:33 <shirt> mebaran151: my way is the better way. it doesn't use type classes
16:00:38 <Pseudonym> shachaf: Why?
16:00:50 <mebaran151> I think do it in the data object is a lot more like prototypical object OOP and type class methods seems more classical
16:01:13 <mebaran151> *I think to do it
16:01:26 <shachaf> Pseudonym: It seems like an abuse of type classes. What's the point of it?
16:01:40 <Pseudonym> Dog is-a Animal
16:02:00 <Pseudonym> In this simple example, there's no point, but this is the Haskell typeclass way to do it.
16:02:21 <shirt> mebaran151: if you use type classes, you can't have a list containing different types of animals. with my way you can have a [Animal] and do stuff like (map talk animals)
16:02:40 <shachaf> If you insist on using type classes. But do you really want to use type classes?
16:02:43 <Pseudonym> shirt: Kind of yes and kind of no.
16:03:00 <mebaran151> I don't think the interface heavy style of programming really works in Haskell
16:03:20 <Pseudonym> data ANIMAL = exists t. ANIMAL t
16:03:21 <mebaran151> I was just asking what the alternate construction was
16:03:26 <Pseudonym> Now you can have a list of ANIMAL.
16:03:59 <tac-tics> mebaran151: Out of curiosity, why do you think it doesn't work.
16:05:24 <angstrom> something like `bla (x:x:_) = "yay"' isn't possible with patterns, right?
16:05:27 <geheimdienst> mebaran151: if you're just starting with haskell, be aware that typeclasses are almost certainly not what you want. they are kind of a background feature of the language that is not very often used, compared to an OO language. also remember that typeclasses are very different from what java or python would call a class
16:05:37 <Axman6> angstrom: no
16:05:40 <Axman6> us eguards
16:05:42 <Axman6> use*
16:05:45 <geheimdienst> mebaran151: what "shirt" said to you earler seems like a good start to me
16:05:49 <angstrom> Axman6: ok
16:05:55 <mebaran151> not that it doesn't work; but it's counter productive and in seems more rigid
16:06:21 <angstrom> howso?
16:06:54 <mebaran151> most of the time in my short adventures with Haskell, I find it's much better to code very specifically and iterate from there
16:07:11 <amtal> I'm trying to fix a bug in a library that's using parsec 2.1.0.0, and need a bit of help understanding what <|> and similar do. Am I correct in thinking that a <|> b runs a, and if it fails, runs b... But if a consumes some input before failing, the state is not backtracked to b?
16:07:28 <amtal> I think this is the behaviour I'm seeing, though looking at <|>'s definition I don't understand how that is.
16:07:38 <Saizan> @quote premature.generalization
16:07:38 <lambdabot> No quotes match. My brain just exploded
16:07:56 <Saizan> @quote monochrom premature
16:07:56 <lambdabot> monochrom says: premature generality is the root of OOP
16:09:02 <Saizan> amtal: it a consumes input and fails it won't run b
16:09:39 <mebaran151> I tend to just use the language as the framework, rather than trying to make into some general ethereal description of the problem I might try to solve later
16:10:20 <amtal> What do I do backtracking with? 'try'?
16:10:30 <angstrom> yes
16:10:37 <mebaran151> it also makes it easier for a newbie like me to figure out his own type problems, if everything is nice and concrete
16:11:16 <amtal> Oh my god yes, it works :) CoreErlang's gonna be able to parse all possible files now! :)))
16:11:39 <Axman6> parse ALL the files!
16:11:59 <mebaran151> the only thing I don't quite know if I'm massing is if I can dispatch on functional arity, or if I need a whole other function to wrap default arguments
16:12:40 <Saizan> you can't
16:13:17 <Saizan> well, unless you use a typeclass, but i wouldn't do that
16:13:29 <Axman6> leave that to printf
16:14:20 <Saizan> often one just makes a record type for all the optional arguments and provide a value of it to use as default
16:15:05 <Kaidelong> you can also use the (Maybe a) type rather than a, although that adds the noise of passing Nothings
16:15:20 <Saizan> record update syntax makes it easy to provide only a subset of them explicitly on the spot
16:16:15 <kmc> mebaran151, that was one of my two proposed 'better ways', the other is just data Animal = Dog | Cat
16:16:17 <Saizan> you want Maybe A if you don't have another sensical default value for the 'A' argument
16:22:24 <msieradzki> dcoutts, I think I have a solution it's so weird but it works, I moved all the C++ including the wrapper with C interface into separate shared library to which haskell package links dynamically
16:22:28 <msieradzki> it seems to work somehow in ghci
16:23:47 <msieradzki> because the usual ld -x -r cpp_wrapper.o haskell_package.o doesn't use weird C++ linking magic that fills vtable symbols for inline virtual functions
16:25:24 <geheimdienst> mebaran151: one possibility is doing it like xmonad. it has a huge record (data XConfig = { ... about 20 fields ... }) and the main function you use ("xmonad") is then used like this: xmonad $ defaultConfig { borderColor = "#000" }
16:25:29 <Gothmog_> Hey!
16:25:40 <Gothmog_> I've got a question about the Haskell type system.
16:25:46 <Gothmog_> What are the means to do something like "data A = ...; data B = ...; data C = A | B"?
16:25:53 <kmc> that
16:26:09 <kmc> (data C = CA A | CB B though)
16:26:11 <Axman6> i think you probably want data C = A A | B B
16:26:18 <Axman6> or something
16:26:19 <geheimdienst> that means: use the default config for everything, except borderColor which is overwritten to be the string "#000"
16:26:57 <Gothmog_> Axman6: Mhm, I'm not sure. To be more specific:
16:27:24 <Axman6> it sounds like you want something like inheritance?
16:27:37 <Axman6> as in, C is a combination of A and B?
16:27:52 <Axman6> so and constructor of A or B is a valid constructor for C?
16:27:53 <amtal> For cabal dependencies - is it normal for a package to depend on 'parsec == 2.1.0.0' or should that be far more relaxed?
16:27:56 <Gothmog_> I have a binary tree, i.e. "data Tree a = Leaf a | Node (Tree a) a (Tree a)
16:28:25 <amtal> ll cabal versions
16:28:51 <Gothmog_> I want to create a list, which entries are either of type Tree a or of some other type...
16:28:52 <Axman6> amtal: so you don't want the library to work with parsec 2.1.0.1?
16:29:10 <Gothmog_> sth like data SpaceTree a = Space | Tree a
16:29:11 <amtal> I'd like it to work with everything, and am wondering how loose I can make the requirements.
16:29:20 <kmc> Gothmog_, so, do that
16:29:32 <kmc> except that each type needs new constructors
16:29:37 <kmc> by the way, you can use the existing Maybe type
16:29:38 <Axman6> Gothmog_: then you need a new type: data SpaceTree a = Space | Tree (Tree a)
16:29:45 <kmc> [Maybe (Tree a)]
16:30:57 <kmc> i recommend against having a constructor named the same as a type
16:31:04 <kmc> unless it's a constructor of that type and is the only constructor
16:31:34 <Gothmog_> kmc: Yeah, I don't want a Tree constructor. I think, what Axman6 wrote is what I was looking for.
16:31:55 <kmc> that is a Tree constructor
16:32:13 <Gothmog_> Ehm, yeah.
16:32:23 <angstrom> should I use `genericLength' instead of `fromIntegral . length'?
16:32:33 <kmc> [Space, Tree Leaf, Tree (Node Leaf 3 Leaf)]
16:32:34 <Gothmog_> But I may call it ...= Space | T (Tree a) or the like.
16:32:36 <kmc> sure
16:32:45 <kmc> @src Maybe
16:32:46 <lambdabot> data Maybe a = Nothing | Just a
16:32:46 <Gothmog_> k, hang on a sec :)
16:33:39 <Gothmog_> I don't want Nothing instead of Space, I probably want something like Space Int
16:33:47 <kmc> ok, sounds good
16:34:10 <kmc> btw you can define a function like sTree x y z = T (Tree x y z)
16:34:16 <kmc> can make the syntax a little nicer
16:35:26 <Gothmog_> Okay.
16:35:40 <monochrom> I am neutral on type name = value name if it is code written by advanced programmers for advanced programmers. I'm royally against it in educational settings.
16:36:13 <Egbert9e9> just installed binary package of ghc 7.2.1 with "./configure --prefix=$HOME/local" and I get this when I run "cabal install cabal-install": http://pastebin.com/KUtFb1jm
16:36:33 <Kaidelong> @src genericLength
16:36:33 <lambdabot> genericLength []    = 0
16:36:33 <lambdabot> genericLength (_:l) = 1 + genericLength l
16:36:46 <Axman6> Egbert9e9: it's probably a bad idea to define your own prefix
16:36:48 <Kaidelong> huh I see
16:36:57 <geheimdienst> monochrom: you mean data Foo = Foo?
16:37:02 <Axman6> cabal uses ~/.cabal by default
16:37:03 <monochrom> yes
16:37:15 <shachaf> Is there a strict tail-recursive genericLength?
16:37:26 <Kaidelong> > length $ () : replicate (maxBound :: Int) ()
16:37:30 <lambdabot>   mueval-core: Time limit exceeded
16:37:33 <Kaidelong> awww
16:38:03 <Kaidelong> @src length
16:38:03 <Egbert9e9> Axman6: I install ghc 7.2.1 into $HOME/local so now ghc and its many symlinks live in $HOME/local/bin/
16:38:04 <lambdabot> Source not found. Where did you learn to type?
16:38:09 <Egbert9e9> installed
16:38:15 <Gothmog_> Now, I get an error message I don't understand from ghc, regarding the following function
16:38:15 <monochrom> I suppose you will write a strict tail-recursive genericLength yourself
16:38:20 <Gothmog_> tshow :: Eq a => [SpaceTree a] -> String
16:38:21 <Gothmog_> tshow ts | [] == filter (/=Space) ts =[]
16:38:22 <Gothmog_> tshow ts = showline ts ++ tshow (nextline ts)
16:38:25 <Axman6> Egbert9e9: that's fine, but let cabal do its thing
16:38:38 <Gothmog_> Inferred type is less polymorphic than expected
16:38:40 <Gothmog_> ...
16:38:43 <Axman6> Gothmog_: use null instead of [] == ...
16:38:59 <Kaidelong> @ty null
16:38:59 <lambdabot> forall a. [a] -> Bool
16:39:03 <mauke> Gothmog_: remove the explicit type signature
16:39:07 <Kaidelong> > null [()]
16:39:08 <lambdabot>   False
16:39:12 <Kaidelong> > null []
16:39:13 <lambdabot>   True
16:39:29 <Kaidelong> @ty ([]==)
16:39:30 <lambdabot> forall a. (Eq a) => [a] -> Bool
16:39:38 <Kaidelong> > [] == []
16:39:39 <lambdabot>   True
16:39:41 <Gothmog_> kk
16:39:46 <Gothmog_> ty
16:39:50 <Kaidelong> > [length] == []
16:39:51 <lambdabot>   False
16:39:54 <Kaidelong> wait what
16:40:13 <Kaidelong> > [getLine] == []
16:40:14 <lambdabot>   No instance for (GHC.Classes.Eq (GHC.Types.IO GHC.Base.String))
16:40:14 <lambdabot>    arising ...
16:40:17 <Kaidelong> there we go
16:40:25 <mauke> > (length + 1) "42"
16:40:26 <lambdabot>   3
16:40:35 <Kaidelong> oh right
16:40:45 <Kaidelong> that stupid superclass of Num
16:41:10 <Gothmog_> Now I've got some other problems, but I think I've got to track them down myself before I bother you anymore. ;-)
16:41:13 <Gothmog_> thanks. :)
16:42:32 <byorgey> it's not stupid =)
16:42:41 <byorgey> > let x = id in (3*x + 2) 4
16:42:42 <lambdabot>   14
16:43:33 <mauke> > deriv (3 * ask + 2) x
16:43:34 <lambdabot>   3 * 1
16:43:58 <Egbert9e9> Axman6: so, when installing from the binary tarball of ghc 7.2.1, I shouldn't set the prefix to a user directory?
16:44:10 <Axman6> no
16:44:18 <Axman6> just do cabal install foo
16:44:28 <Axman6> much less likely to break everything
16:44:29 <byorgey> @type ask
16:44:30 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
16:44:39 <Axman6> @instances MonadReader
16:44:39 <lambdabot> r ((->) r), r (ErrorT e m), r (RWST r w s m), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
16:44:49 <byorgey> ah, I see
16:44:57 <byorgey> @type ask :: a -> r
16:44:58 <lambdabot>     Couldn't match expected type `r' against inferred type `a'
16:44:58 <lambdabot>       `r' is a rigid type variable bound by
16:44:58 <lambdabot>           an expression type signature at <interactive>:1:12
16:45:01 <byorgey> @type ask :: a -> a
16:45:02 <lambdabot> forall a. a -> a
16:45:11 <augur> if i wanted to write a type checker for basic haskell-style types, could i do it in two stages -- a top down phase that pushes out to axioms, and a bottom up phase that unifies the resultant type contexts?
16:45:22 <cicatristeza> what is the function, that takes a list, groups the elements, and then returns a list conataining only one instance of each element?
16:45:40 <Axman6> there isn't one
16:45:45 <Egbert9e9> maybe I should just wait the night and the many hours Oneiric Ocelot upgrade ~_~
16:45:46 <Axman6> but it's easy to define
16:46:04 <Axman6> > map head . group$ [1,1,2,3,2,2,2,2,3,5,5,5,6,4,5]
16:46:06 <lambdabot>   [1,2,3,2,3,5,6,4,5]
16:46:44 <byorgey> augur: yes, see TaPL section 22.3
16:46:49 <augur> byorgey: <3
16:46:51 <cicatristeza> Axman6: you see the sumbers 2, 3, and 5 repeated, i do not want this
16:47:03 <cicatristeza> i want it as: [1, 2, 3, 4, 5, 6]
16:47:10 <mauke> cicatristeza: Set.toList . Set.fromList
16:47:19 <Axman6> > map head . group . sort $ [1,1,2,3,2,2,2,2,3,5,5,5,6,4,5]
16:47:19 <augur> byorgey: i find myself in need of a haskell-like language but not precisely haskell x.x
16:47:21 <lambdabot>   [1,2,3,4,5,6]
16:47:34 <mauke> > S.toList . S.fromList $ [1,1,2,3,2,2,2,2,3,5,5,5,6,4,5]
16:47:36 <lambdabot>   [1,2,3,4,5,6]
16:47:42 <cicatristeza> thanks
16:47:54 <mauke> > nub [1,1,2,3,2,2,2,2,3,5,5,5,6,4,5]
16:47:55 <lambdabot>   [1,2,3,5,6,4]
16:47:57 <BMeph> mauke WINS!
16:48:02 <cicatristeza> nub it is!
16:48:10 <mauke> > nub [0 ..]
16:48:11 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:49:44 <cicatristeza> > length $ nub [0..]
16:49:48 <lambdabot>   mueval-core: Time limit exceeded
16:49:54 <cicatristeza> aha
16:51:39 <mebaran151> geheimdienst: you can overwrite record fields?
16:53:01 <Brandon_R> Hello guys
16:53:11 <Axman6> 'lo
16:53:33 <Brandon_R> What's up
16:53:39 <Brandon_R> just checking out haskell here
16:54:04 <Pseudonym> Back.
16:54:25 <cicatristeza> its the funny wording ofnub that threw me. lyah mentions this too i think.
16:54:25 <geheimdienst> mebaran151: it's not really overwriting, but you can think of it like that. you start with the record defaultConfig, then change one or more of the fields by saying defaultConfig { foo = ..., bar = ... }. it's called record-update syntax. technically you get back a new record with the changed values (the original one is still available)
16:55:06 <Brandon_R> So, what you guys working on
16:55:08 <Brandon_R> anything cool?
16:56:10 <copumpkin> nah, I only work on really boring stuff
16:56:24 <Quantumplation> Brandon_R: I'm working on a generic graph library, specifically that lets you work directly with the embeddings themselves, in order to aid my research into the thrackle problem.
16:56:36 <Brandon_R> Nice
16:56:43 <Brandon_R> how long have you been programming in haskell
16:56:53 <mdxbhmt> >nub "hheelloo"
16:57:16 <mdxbhmt> > nub "hheelloo"
16:57:17 <lambdabot>   "helo"
16:57:26 <Quantumplation> I've been in love with haskell for about 2 years, but not actually coded anything more complex than a few project euler problems.  I just barely started on my first "real" project
16:58:06 <Axman6> Quantumplation: two years and you haven't been spending time in here? tut tut tut
16:59:08 <xil> hi. Is there a variant on 'map' that automatically discards any '()'s from the resulting list?
16:59:20 <Pseudonym> xil: () has type ()
16:59:29 <Pseudonym> If a list contains ()'s, it can only contain ()'s.
16:59:45 <xil> oh damnit. I thought () could be of any type
16:59:48 <Pseudonym> No.
16:59:51 <Pseudonym> I think you want Maybe.
17:00:02 <geheimdienst> xil: you might be looking for mapMaybe if you want your function to be able to throw out things from the list
17:00:05 <Pseudonym> @src Maybe
17:00:06 <lambdabot> data Maybe a = Nothing | Just a
17:00:24 <geheimdienst> > mapMaybe (\x -> if even x then Nothing else Just x) [1..10]
17:00:25 <lambdabot>   [1,3,5,7,9]
17:00:47 <geheimdienst> ^^ throws out the even elements
17:00:51 <xil> I actually only use the () for removing things from the list. I have a function that returns something or nothing, so I could change it to return something using Maybe, but then my question still holds about the map function that automatically removes Nothings from the result
17:00:53 <xil> oh
17:01:04 <Pseudonym> Also:
17:01:07 <xil> haha, I should have looked oh geheimdienst's thing before I said anything
17:01:13 <geheimdienst> ;)
17:01:17 <Axman6> it's called filter p . map f
17:01:21 <Pseudonym> [ x | Just x <- [Nothing,Just 42,Just 3,Nothing,Just 5] ]
17:01:26 <Pseudonym> > [ x | Just x <- [Nothing,Just 42,Just 3,Nothing,Just 5] ]
17:01:27 <lambdabot>   [42,3,5]
17:01:48 <geheimdienst> Haskell™. Answering Your Question Before You Asked It.™
17:01:57 <xil> Axman6: but doesn't that run through the list twice? I know it's a constant difference, but it's still slower no?
17:02:03 <xil> geheimdienst: haha
17:04:01 <Pseudonym> geheimdienst: That would be a prosomorphism.
17:04:30 <dmwit> xil: It likely fuses to a single pass with -O2.
17:04:51 <geheimdienst> Pseudonym: i don't know what that is
17:04:52 <mdxbhmt> shouldn't it be always?
17:05:21 <mdxbhmt> or a better question, why the compiler would not want to fuse ?
17:06:44 <c_wraith> fusion is implemented as a series of RULES directives, which the compiler only uses with -O2.  mostly because they can be really slow.
17:06:56 <Pseudonym> geheimdienst: In the spirit of the bananas, lenses etc paper, you add a Greek word to "morphism" to make a category theory joke.
17:07:09 <Pseudonym> Mathematicians, for example, refer to obscure connections as "cryptomorphisms".
17:07:23 <Pseudonym> A prosomorphism would be a connection to the future.
17:08:47 <geheimdienst> oh i see :) i had prosody in my head for some reason
17:09:51 <cicatristeza> Quantumplation: could you tell me more about your graph project?
17:12:28 <Brandon_R> I have a question
17:12:31 <cicatristeza> anyone else working with graphs or combinatorics here? i'd be most interested in chatting
17:12:39 <cicatristeza> !ask
17:12:40 <Brandon_R> can haskell be used to create high performance chat servers?
17:13:23 <kmc> @faq can haskell be used to create high performance chat servers?
17:13:23 <lambdabot> The answer is: Yes! Haskell can do that.
17:13:42 <Brandon_R> Thanks
17:13:59 <Axman6> cicatristeza: talk to ivanm when he's around
17:14:33 <Axman6> Brandon_R: Haskell has some fantastic features that make writing high performance servers quite easy
17:14:46 <Brandon_R> nice
17:14:48 <Brandon_R> any links?
17:14:53 <Brandon_R> to get me started
17:15:18 <kmc> @where lyah
17:15:18 <lambdabot> http://www.learnyouahaskell.com/
17:15:20 <kmc> @where rwh
17:15:20 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:15:33 <Quantumplation> http://hpaste.org/52532 causes nastiness
17:15:37 <sm> how can you print the help explicitly with cmdargs ?
17:15:56 <Quantumplation> er, all of those types deriving (Show)
17:15:56 <cicatristeza> Axman6: thanks
17:16:06 <cicatristeza> anyone here use the HaskellForMaths package?
17:16:18 <sm> I'm using helpText def $ cmdArgsMode myopts, and getting an incomplete help string
17:16:35 <Quantumplation> cicatristeza: join #Thraskell if you wanna chat about my project
17:17:10 <cicatristeza> how do i output the days of the first of each month, starting from 2014 to 2020
17:17:23 <cicatristeza> assume monday=1, tue=2 etc
17:17:37 <sm> hm maybe I'm running into "Annotated records... will only contain annotations on their first use"
17:19:00 <geheimdienst> sm: would it help to do something like this? withArgs ["--help"] main
17:19:06 <Brandon_R> what is the accecpted solution for handling sockets
17:19:14 <Brandon_R> threaded or evented like node.js
17:19:33 <Brandon_R> checking out learn you some haskell now
17:20:07 <kmc> Brandon_R, threaded
17:20:15 <Brandon_R> oic
17:20:20 <kmc> GHC's runtime system will use event-based IO transparently
17:20:22 <sm> geheimdienst: thanks, not sure, but this helped: convert to a pure mode with cmdArgsMode, then reuse that
17:20:22 <kmc> you just spawn threads
17:20:23 <geheimdienst> Brandon_R: haskell threads are very very lightweight, so you should have no trouble with making bazillions of threads
17:20:33 <kmc> you can create 100,000 threads on a standard system and do blocking IO from all of them
17:20:41 <kmc> the runtime system will implement that with kqueue or epoll or whatever
17:20:59 <kmc> so you don't have to turn your code inside out, like you do with node.js
17:21:06 <Brandon_R> :)
17:21:10 <Brandon_R> I'll check it out
17:21:24 <Brandon_R> so its basically the same way like erlang, lightweight threads
17:21:27 <geheimdienst> sm: i really don't know what to think of CmdArgs. it somehow looks clever but it also freaks me the hell out :-/
17:21:46 <kmc> Brandon_R, yeah, Erlang is the only other language / implementation I'm aware of which embraces this strategy
17:22:16 <Axman6> Brandon_R: events are a horroble way to program, and unnecessary when you have a good threading system like GHC does
17:22:36 <kmc> basically in Haskell you have to un-learn the rule that "threads suck and should be avoided at all costs"
17:22:52 <kmc> they're actually a reasonable way to solve problems, even small problems
17:22:53 <Brandon_R> haskell does require a new way of thinking
17:23:03 <Axman6> very much so
17:23:05 <kmc> yep
17:23:15 <Axman6> but it's very much worth it
17:23:46 <mokus> Haskell's theme song is Al Yankovic's "everything you know is wrong" ;)
17:24:08 <shachaf> There are other lightweight thread implementations than in Erlang and Haskell, aren't there?
17:24:26 <Axman6> not many that i know of
17:24:26 <kmc> shachaf, with IO managers?
17:24:38 <shachaf> kmc: What does "IO manager" mean?
17:24:58 <kmc> well, you can't let a blocking IO call block the whole OS thread
17:25:03 <shachaf> Is it something that can't be implemented as a library?
17:25:13 <augur> koninkje_away: ping
17:25:14 <shachaf> Right, using non-blocking I/O.
17:25:17 <augur> xplat: ping
17:25:21 <geheimdienst> before haskell happened to me, i was like "oh let's program something in python", "oh let's try perl no", etc. i don't have that anymore. i tried to do something in python once, but it just sucks compared to haskell :)
17:25:41 <Quantumplation> if i'm implementing the show function and want to contatenate the string representation of an integer and other stuff, how do I convert the integer to a string?
17:25:46 <geheimdienst> s/no/now
17:25:47 <kmc> Quantumplation, show
17:25:56 <Quantumplation> oh, haha, that's relatively simple
17:25:58 <cicatristeza> how do i write this the right way: k =  isLeapYear $ digitToInt [2012]
17:25:58 <kmc> shachaf, the key property I'm after is that the IO manager aggregates a bunch of non-blocking IO requests into a more efficient call into the OS
17:26:19 <shachaf> kmc: How often can you really do that?
17:26:23 <shachaf> Or are you just referring to buffering?
17:27:03 <Axman6> cicatristeza: i can't tell what you're trying to do
17:27:03 <geheimdienst> shachaf: he means poll, so anytime your program waits on a file descriptor or N file descriptors, all that the OS ever sees is one poll call
17:27:04 <kmc> shachaf, I'm referring to the fact that 100 GHC threads can make 100 unrelated OS calls and the result is not 100 OS threads calling read(2) but one OS thread calling epoll(2)
17:27:12 <kmc> unrelated IO operations*
17:27:15 <geheimdienst> or select ot whatever the kids call it these days :)
17:27:24 <cicatristeza> Axman6: trying to find if a year is leap year or not
17:27:39 <geheimdienst> :t digitToInt
17:27:40 <lambdabot> Char -> Int
17:27:40 <shachaf> Oh, sure. But you can implement that as a library on top of an evented interface as soon as you have lightweight threads, can't you?
17:27:44 <cicatristeza> k =  isLeapYear $ digitToInt '2012'
17:27:48 <Axman6> why is digitToInt needed?
17:27:48 <kmc> shachaf, probably
17:27:56 <kmc> do such libraries exist in other languages?
17:27:59 <Brandon_R> I think its Year Mod 4 == 0
17:28:00 <Axman6> cicatristeza: you mean "2012"?
17:28:10 <kmc> shachaf, I'd think it needs to hook into the lightweight thread scheduler
17:28:11 <Axman6> Brandon_R: it's more complicated than that
17:28:32 <Brandon_R> :(
17:28:33 <shachaf> kmc: As in that article I linked to before, in C++. Admittedly that was for coöperative threads.
17:28:51 <geheimdienst> shachaf: you have some bird droppings on that one o
17:28:56 <cicatristeza> Axman6: isLeapYear needs an int
17:29:06 <shachaf> geheimdienst: It keeps happening to me. :-(
17:29:07 <Axman6> cicatristeza: then you should use read
17:29:16 <Axman6> > read "2012" :: Int
17:29:16 <lambdabot>   2012
17:29:34 <cicatristeza> indeed, thanks
17:29:40 <Axman6> though, read is probably a bad idea, unless you've checked that the string containts a valid year
17:29:48 <shachaf> > rеad "4062"
17:29:50 <lambdabot>   4063
17:30:03 <cicatristeza> why would lambdabot do that?
17:30:09 <Axman6> so what?
17:30:11 <Axman6> do*
17:30:16 <luqui> woah that's weird
17:30:20 <geheimdienst> shachaf: stop trolling the newbies
17:30:21 <byorgey> hehehe
17:30:24 <kmc> > "rеad"
17:30:24 <geheimdienst> :)
17:30:25 <lambdabot>   "r\1077ad"
17:30:35 <copumpkin> we call him shachaf the evil
17:30:40 <cicatristeza> nice one
17:30:45 <kmc> shachaf registers bankofamеrica.com
17:30:48 <shachaf> > reverse "shachaf the evil"
17:30:49 <lambdabot>   "live eht fahcahs"
17:30:57 <shachaf> > "bankofamеrica.com"
17:30:57 <lambdabot>   "bankofam\1077rica.com"
17:31:08 <shachaf> Sadly that turns into a weird xn-- URI.
17:31:10 <luqui> shachaf, are you really registering that?
17:31:13 <shachaf> Stupid racist domain name people.
17:31:23 <kmc> shachaf, what, you think the people you're phishing will notice?
17:31:28 <kmc> it's all just computer code gibberish
17:31:37 <shachaf> kmc: If they won't notice, what's the point of getting the fancy domain in the first place?
17:31:39 <kmc> however I think you aren't allowed to register such domains
17:31:54 <Brandon_R> boa is going to fail anyways
17:31:59 <kmc> shachaf, yeah, you can just get mysuperonlinebankcreditcardverify.com
17:32:00 <shachaf> kmc: What if I start a company called Bank of Amеrica?
17:34:06 <shachaf> kmc: Anyway, is there a problem with something like read :: Int -> Handle -> IO String; read len h = do { res <- newEmptyMVar; asyncRead len h (\s -> putMVar res s); takeMVar res }?
17:34:23 <shachaf> Where asyncRead registers something for epoll and so on.
17:34:30 <kmc> not that I'm aware of
17:35:06 <kmc> you can implement events on top of threads with blocking IO, and vice versa
17:35:29 <shachaf> Right.
17:35:38 <kmc> but has this been done
17:35:39 <shachaf> So why do you need an I/O manager?
17:35:47 <kmc> that library is an IO manager
17:35:47 <shachaf> Ah.
17:35:59 <kmc> i don't think we're actually talking about anything
17:36:04 <shachaf> kmc: There are things like http://swtch.com/libtask/
17:36:26 <shachaf> Anyway, you're probably right.
17:36:56 <kmc> it looks like that has an "IO manager" built in
17:37:05 <shachaf> Right.
17:37:15 <kmc> thanks for the link
17:37:33 <kmc> I will add it to my list of implementations which work this way
17:37:51 <shachaf> Sadly non-blocking I/O on disk files in Linux is much more difficult than socket I/O.
17:38:07 <kmc> :/
17:38:23 <shachaf> In fact, I wonder how GHC does it.
17:38:39 <shachaf> Does it just use a thread pool of workers that do blocking I/O or something?
17:39:22 <kmc> i think so
17:40:00 <shachaf> You can use POSIX aio, whose GNU implementation is really stupid.
17:40:22 <shachaf> Or you can use io_submit and its ilk, which only work with O_DIRECT right now, I believe.
17:40:31 <geheimdienst> can't you just open a file in whateversome "O_ASYNC" mode and then stick the fd into poll()?
17:41:00 <shachaf> geheimdienst: No, poll will always tell you that there are bytes available.
17:41:34 <kmc> silly linux
17:41:54 <Quantumplation> if I wanted to display each item in a list without the [], how would I do so?  map show xs isn't working
17:42:03 <kmc> :t concatMap show
17:42:04 <lambdabot> forall a. (Show a) => [a] -> [Char]
17:42:07 <Quantumplation> ah, coolio
17:42:11 <Quantumplation> ^.^
17:42:16 <hpc> :t (show >>=)
17:42:17 <lambdabot> forall a b. (Show a) => (String -> a -> b) -> a -> b
17:42:27 <hpc> :t (show =<<) -- rather
17:42:28 <lambdabot> forall a. (Show a) => [a] -> [Char]
17:42:58 <geheimdienst> "yeah the list monad is perfectly simple ... uh wait, maybe i need the other operator ..."
17:43:20 <geheimdienst> (j/k)
17:44:02 <hpc> geheimdienst: :P
17:44:11 <shachaf> geheimdienst: j
17:45:05 <hpc> geheimdienst: i swear, that happens every time i use bind explicitly
17:45:19 <hpc> i can't remember the last time i picked the right direction the first time
17:45:39 <shachaf> hpc: Just remember: The monster goes into the >>=
17:45:58 <geheimdienst> and comes out on the other side wearing a spacesuit
17:46:55 <hpc> oh, now it makes sense
17:56:59 <dmwit> :t intercalate ", " . map show
17:56:59 <lambdabot> forall a. (Show a) => [a] -> [Char]
17:57:06 <dmwit> > [3, 4]
17:57:07 <lambdabot>   [3,4]
17:57:11 <dmwit> Oh, no space.
17:57:29 <dmwit> Quantumplation: intercalate "," . map show -- more pedantically answers your question
17:58:10 <dmwit> :t intersperse
17:58:11 <lambdabot> forall a. a -> [a] -> [a]
17:59:29 <shirt> how can i tell cabal to build only one out of many of the executables in the package?
18:00:36 <dmwit> shirt: Make them conditional on a flag.
18:00:45 <dmwit> s/them/the executable blocks/
18:01:28 <shirt> alrighty then. would be nice if i could give an executable name as an argument to cabal build
18:07:20 <sm> hey all. why is cabal complaining about other-modules here ? It looks normal: https://gist.github.com/1283090
18:08:04 <sm> I'm using 0.11.2. It works fine with another similar-looking cabal file.
18:08:34 <luite> sm: shouldn't you use a module name instead of a filename there?
18:09:38 <sm> luite: genius! thank you!
18:10:02 <sm> I totally could not see that the other cabal file didn't have .hs. Thanks again. :)
18:10:54 <kmc> my "Why learn Haskell?" slides are now online.  http://mainisusuallyafunction.blogspot.com/2011/10/slides-from-why-learn-haskell.html
18:11:13 <kmc> tell your friends, confound your enemies, &c.
18:11:37 <shachaf> kmc: Luckily we can do it using the same slides!
18:12:09 <geheimdienst> nice. thanks kmc
18:12:09 <dolio> Not enough info on fibonacci web servers.
18:12:16 <dolio> How will I make an informed decision.
18:12:24 <shachaf> dolio: No, Haskell can't do those.
18:12:31 <kmc> only factorial web servers
18:12:33 <shachaf> You have to use IRC.
18:16:34 <dmwit> type hackery =(
18:17:25 <wavewave> ?
18:22:14 <luite> kmc: interesting talk, did you feel that the audience understood the higher order equational reasoning and IO actions as data?
18:22:39 <kmc> i have no idea honestly
18:22:58 <wavewave> who are the audience btw?
18:23:03 <kmc> probably did, they were pretty smart dudes / dudettes
18:23:06 <kmc> MIT students mostly
18:23:23 <kmc> also people like copumpkin who already know Haskell and showed up for mysterious reasons
18:23:30 <kmc> (cookies most likely)
18:23:34 <luite> hehe
18:23:56 <dmwit> wavewave: I'm trying to write easily-inferrable instances with FlexibleInstances turned on. It's not easy, and none of the tricks I could think of worked.
18:24:01 <kmc> it's okay if some people didn't understand every slide
18:24:15 <kmc> the general idea is to bombard them with cool stuff so they'll go read up on their own
18:24:20 <dmwit> I think ~ could work, but it's pretty new, and I think people generally want some backwards compatibility in xmonad.
18:24:20 <kmc> you can't actually teach the language in one hour
18:24:40 * kmc likes to be explicit about when he's teaching vs. when he's evangelizing
18:24:48 <dmwit> I should probably produce a reduced test case that's hard.
18:24:52 <dmwit> Maybe tomorrow.
18:26:15 <copumpkin> kmc: I didn't even realize there would be food, but the food was very delicious
18:26:28 <kmc> it was!
18:26:50 <kmc> the SIPB people did a great job organizing
18:26:51 <luite> kmc: yeah that's why I asked specifically about those two parts, they're probably a bit more abstract or foreign to people coming from other languages. your talk has enough other stuff to keep their attention even if you lost them on those parts :)
18:27:10 <wavewave> attracting to haskell can be quite diverse
18:27:35 <kmc> fun fact: I didn't use the word "functional" anywhere in the talk :)
18:27:45 <kmc> (well, in  the slides)
18:27:47 <copumpkin> kmc: or "monad", other than when you talked about xmonad
18:27:53 <copumpkin> I looked out for it
18:27:57 <kmc> no i mention "a monad is like a burrito"
18:28:07 <kmc> just as an example of "people say confusing shit, pay no mind"
18:28:34 <kmc> i was trying really hard to avoid the trap of asserting FP is The Way and then arguing Haskell is the best functional language
18:29:20 <devildue> Do you have access to http://www.ancestry.com and could look up a person's name?
18:29:26 <wavewave> kmc: it is really hard to avoid. :-)
18:29:47 <jmcarthur> devildue: did you perhaps mean to ask that in #haskell-blah?
18:30:25 <luite> by the way those http requests per second look a little low, yesod has posted some 80k/sec benchmarks (ok, that was a simple hardcoded response), and 150000 unpublished on a faster server
18:30:53 <kmc> luite, those aren't concurrent requests are they?
18:30:56 <geheimdienst> kmc, some comment to that effect really should be on the haddock pages for Control.Monad and a few other things. i was looking at them just today and sure enough it points you in exactly the wrong direction. "monads are a concept from a branch of mathematics known as category theory ..."
18:30:57 <wavewave> to people who at least know FP is important, persuading them to haskell is not so difficult, I think.
18:31:09 <kmc> the big deal with the IO manager is that you can handle 10,000 clients *at once*
18:31:23 <kmc> (maybe not such a big deal with a quick HTTP GET, but on a long-running session...)
18:31:29 <kmc> wavewave, exactly
18:31:36 <kmc> and I think convincing people FP is important in one hour is really hard
18:31:51 <kmc> i think only a few people can do that well
18:32:02 <kmc> so I aimed for "here's why Haskell is better for the things you're already doing"
18:32:14 <mebaran151> kmc: I liked the approach of your talk
18:32:21 <luite> kmc: oh it isn't quite clear from the slide that all the clients are connected at the same time
18:33:44 <kmc> yeah, i suppose not
18:33:49 <luite> oh by the way, this was a question in the yesod channel, yesod recently added websockets support (snap also has it, I think), which should go really well with the new IO manager
18:33:53 <kmc> nice
18:33:57 <kmc> yes
18:34:01 <luite> what would be a good demonstration application to show off haskell's capabilities in that area?
18:34:31 <wavewave> The methodology I usually use to make people towards FP is basically emphasizing "first-class function"
18:35:03 <ddarius> "First-class functions, they're like objects with only one method! !"
18:35:26 <wavewave> showing that every language tries to do that but in very ugly way.
18:36:06 <devildue> COME ON!
18:36:23 <wavewave> ddarius: if someone argue like that, I just accept it.. yes. that's an achievement in OOP.
18:36:33 <wavewave> but we do it much simpler.
18:37:09 <wavewave> at least, someone who can argue like that at least know function object is importatn.
18:37:13 <ddarius> Not really.  We do it far less verbosely than many OO languages, but that is fairly superficial.
18:38:44 <wavewave> ddarius: you mean 'mathematically sound'?
18:39:28 <ddarius> I don't see where I said anything that sounded anything like "mathematically sound."
18:40:04 <wavewave> ddarius: ahh.. I don't get what you mean by 'superficial' there.. so just guessed it.
18:40:43 <shachaf> Is there a point to this SPECIALISE pragma? {-# SPECIALISE runSTM :: SIO () -> STM () #-}; runSTM :: SIO a -> STM a
18:40:53 <ddarius> @wn superficial
18:40:55 <lambdabot> *** "superficial" wn "WordNet (r) 2.0"
18:40:55 <lambdabot> superficial
18:40:56 <lambdabot>      adj 1: being or affecting or concerned with a surface; not deep or
18:40:56 <lambdabot>             penetrating emotionally or intellectually;
18:40:56 <lambdabot>             "superficial similarities"; "a superficial mind"; "his
18:40:57 <lambdabot> [10 @more lines]
18:41:05 <kmc> shachaf, maybe GHC can do extra clever optimizations when a data type has only one constructor
18:41:06 <wavewave> ddarius: I got the meaning wrong. okay. :-P
18:41:25 <shachaf> kmc: Well, it gives a warning: SPECIALISE pragma for non-overloaded function `runSTM'
18:41:32 <kmc> just a guess
18:41:33 <kmc> heh
18:41:36 <shachaf> So I assume there isn't.
18:41:39 <kmc> oh, it's not typeclass-overloaded
18:41:43 <kmc> i guess that's what it means
18:41:45 <shachaf> Right.
18:41:55 <kmc> meh
18:41:57 <kmc> who wrote the code?
18:41:58 <shachaf> Does SPECIALISE do anything for non-typeclass-overloaded cases?
18:42:10 <shachaf> kmc: 唐鳳
18:42:11 <dolio> I don't remember it having anything to do with type classes.
18:42:19 <ddarius> I'm pretty sure the user guide would say so if it did.
18:43:56 <ddarius> kmc: יהוה
18:44:16 <devildue> haf> Does SPECIALISE do anything for non-typeclass-overloaded cases?
18:44:16 <devildue> -> *Sawyer* If a non programmer moved to Silicon Valley, would they have to work at Wal-Mart?
18:44:16 <devildue> <shachaf> kmc: 唐鳳
18:44:16 <devildue> <
18:44:19 <devildue> oh well
18:44:25 <devildue> The plant then took the guano molecule into it's root... going up it's stalk or shoot it deftly
18:44:25 <devildue> turned into a pollen grain, swept up by a bee taking it to it's nest
18:44:28 <devildue> The nest gave birth to a larvae, which turned into a pupae, and finally into an adult bee
18:44:28 <devildue> The molecule went into the bee's stinger during growth.  Then some kid got stung...
18:44:29 <devildue> it really hurts when it comes from bird shit
18:44:30 <devildue> You fug ug fagheads.
18:44:31 <devildue> Wear your baseball hat backwards with an ass on the back and we'll call you asshat
18:44:34 <kmc> @where ops
18:44:34 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
18:44:39 <devildue> They see me mowin' my front lawn
18:44:39 <devildue> I know they're all thinkin' I'm so
18:44:40 <devildue> White and nerdy
18:44:41 <devildue> Think I'm just too white and nerdy
18:44:42 <devildue> Think I'm just too white and nerdy
18:44:44 <devildue> Can't you see I'm white and nerdy
18:44:45 <devildue> Look at me, I'm white and nerdy
18:44:45 --- mode: ChanServ set +o mauke
18:44:46 --- mode: mauke set +b *!*@user-38lci5j.dialup.mindspring.com
18:44:50 <wavewave> hmm
18:44:51 <geheimdienst> thanks mauke
18:44:56 <kmc> mauke++
18:45:04 --- kick: devildue was kicked by mauke (devildue)
18:45:54 --- mode: mauke set -o mauke
18:47:01 <Sawyer> guys, I have a question. I am reading learn you a haskell for great good.  there's a sample code like this:
18:47:11 <Sawyer> applyLog :: (Monoid m) => (a,m) -> (a -> (b,m)) -> (b,m)
18:47:15 <parcs> does type-class-dictionary passing incur an overhead?
18:47:19 <Sawyer> applyLog (x,log) f = let (y,newLog) = f x in (y,log `mappend` newLog)
18:47:23 <shachaf> The GHC documentation is unclear on SPECIALISE.
18:47:24 <ddarius> parcs: Of course it does.
18:47:37 <ddarius> shachaf: Nothing for it but the source code then.
18:47:49 <luite> parcs: yeah the difference between that an a specialized function can be huge
18:48:06 * ddarius originally though applyLog was going to be something more interesting than it turned out to be.
18:48:27 <parcs> i presume specialize makes a totally monomorphic copy of a function which reduces the the amount of times the dictionary has to be passed
18:48:56 <ddarius> There's more to it than that (at least, more potential benefits than that.(
18:49:08 <parcs> e.g in plusTwo x = x + 1 + 1, the dictionary has to be passed to plusTwo and + twice, so three times
18:49:15 <parcs> with specialize it would be passed once
18:49:29 <Sawyer> my question is, in the defination here : applyLog (x,log) f = let (y,newLog) = f x in (y,log `mappend` newLog), should it be  let y = f x in (y,log `mappend` newLog) ??
18:49:47 <mauke> Sawyer: no
18:49:54 <mauke> Sawyer: where would newLog come from then?
18:50:12 <wavewave> f :: a -> (b,m)
18:50:20 <ddarius> parcs: It presumably wouldn't be passed at all in that case, nor is it likely to be that naive in the former case.
18:50:39 <wavewave> y :: b
18:52:19 <Sawyer> mauke, if you write let (y, newLog) =  f x in (y,log `mappend` newLog), how did the compiler know, whether the f x applies to y or newLog?
18:52:44 <mauke> Sawyer: huh?
18:52:45 <wavewave> f x gives its value matched to (y,newLog)
18:52:49 <mauke> Sawyer: what do you mean by "applies to"?
18:52:53 <wavewave> not one of them.
18:54:42 <wavewave> Sawyer: output of f x is (b,m) type, so (y,newLog) = f x means first of the result tuple is y, second of the result tuple is newLog.
18:55:14 <luite> dylukes:
18:55:19 <luite> wtf
18:55:20 <luite> oops
18:55:39 <wavewave> Sawyer: so y is of type b, and newLog is of type m  by "type-inference"
18:56:05 <Sawyer> wavewave, yeah, I am reading and thinking.
18:56:05 <wavewave> Sawyer: did you get this point now?
18:57:56 <parcs> ddarius: yeah.. so what the heck does it do?
18:59:50 <ddarius> parcs: Once it knows the type is Int, say, it statically knows what dictionary to use, so it can completely inline that immediately and simplify.
19:00:20 <parcs> why wouldn't it do that by default?
19:00:26 <ddarius> Similarly, it can reuse the dictionary in the former case because it knows they are all the same dictionary and the definitions can be inlined to not require naively passing in the dictionary.
19:00:50 <ddarius> parcs: Because that means compiling a different function for every type.
19:01:01 <Sawyer> wavewave,  the function defination is like applyLog (x,log) f, if I see f x in the function body, I think it's applying x to f, so how come f x be a tuple type here? so how did you know that f x is a (b,m) type?
19:01:03 <parcs> but.. speed
19:01:06 <parcs> :P
19:01:16 <ddarius> parcs: You have infinite amount of disk and RAM?
19:01:33 <parcs> i'm not sure
19:01:47 <ddarius> But yes, with a whole program compiler, you could specialize every case statically.  Alternatively, the code could be generated at run-time.
19:02:02 <wavewave> Sawyer :applyLog gets a function f as the second argument. f is from the beginning a function when passing to applyLog.
19:02:27 <ddarius> (Though, you probably still won't want to even with a whole program compiler, and also it's not quite true that you could do every case.)
19:02:47 <parcs> because of existentials?
19:02:58 <wavewave> applyLog :: (Monoid m) => (a,m) -> (a -> (b,m)) -> (b,m)
19:03:41 <wavewave> Sawyer : in applyLog (x,log) f  ,  (x,log) is (a,m) type and f is (a -> (b,m)) type.
19:03:42 <ddarius> That's one reason, but not the only one.
19:04:08 <wavewave> Sawyer: as you see from the type signature of applyLog
19:04:15 <shirt> ddarius: the performance of my program can change if i move a function from one module to another?
19:04:30 <Sawyer> wavewave, oh, yes, seems clear to me now.
19:04:42 <wavewave> Sawyer: Now you got it! ;-)
19:05:04 <mebaran151> Data.Fixed
19:05:15 <mebaran151> whoops sorry guys wrong window :)
19:05:16 <Sawyer> wavewave, thank u very much, you're very helpful!
19:05:33 <wavewave> Sawyer : applyLog takes a function as an argument. such a function is called higher-order function
19:05:43 <mebaran151> emacs can sometimes be very confusing, though once I get an integrated debugging mode, it will be unstoppable
19:06:02 <ddarius> shirt: Definitely.
19:06:03 <Sawyer> wavewave, I know that, I learnt that when I was learning scala
19:06:08 <wavewave> Sawyer: function can take a function as an argument, and also give a function as a result.
19:06:11 <ddarius> (in GHC)
19:06:35 <wavewave> Sawyer: oh, yeah. if you know other functional language, you can get it easily.
19:06:39 <ddarius> (or in Haskell in general.  Technically, the performance of your program can change due to the phase of the moon as far as the Report cares.)
19:08:45 <shirt> ddarius: interesting
19:38:59 <lightstep> how does one get cabal-install on windows? i installed the haskell platform but it's not on my path (perhaps not installed)
19:40:23 <msieradzki> check if it isn't in bin in haskell platform
19:40:36 <msieradzki> if it's not (I don't remember if it is there by default) get it from cabal-install website
19:43:56 <coppro> What good matrix libraries exist?
19:44:43 --- mode: ChanServ set +o mauke
19:44:44 --- mode: mauke set -b *!*@user-38lci5j.dialup.mindspring.com
19:45:34 --- mode: mauke set -o mauke
19:45:57 <lightstep> it wasn't in the bin directory of the install, so i downloaded the exe and now bootstapping again, just in case
19:47:03 <Axman6> coppro: hmatrix
19:47:19 <Axman6> coppro: i believe it uses BLAS internally
19:56:33 <coppro> Axman6: thanks
20:06:26 <milkpost> is it ridiculous to think that pandoc will ever support multi markdown syntax?
20:27:26 <coppro> I'm a little annoyed that hmatrix doesn't do Rational
20:44:38 <tgeeky> milkpost: what specifically is multi markdown syntax?
20:45:16 <tgeeky> milkpost: nevermind, looking it up
20:45:21 <milkpost> just minor things
20:45:23 <Axman6> an extension to markdown
20:45:29 <milkpost> table format, how equations are defined
20:45:52 <milkpost> there are parts to both pandoc extensions and multi markdown that I dislike.  not sure how i feel about either
20:46:11 <milkpost> LaTeX syntax is allowed in pandoc, but needs to be a "comment" in multimarkdown
20:46:28 <milkpost> $…$ is recognized in pandoc, but have to use \\[ \\] and \\( \\) for math in multimarkdown
20:46:58 <milkpost> a header of "blah 2" gets an id of "blah-2" in pandoc but "blah2" in mmd.  minor BS
20:51:47 <tgeeky> milkpost: interesting. I was aware of many different markdown specifications, but not MMD
20:52:01 <milkpost> yeah there are too many to count, it's rediculous
20:52:09 <milkpost> i blame gruber, he should've thought about this shit
20:53:35 <milkpost> the mmd way of doing tables though seems to be the *common* way to do it though
20:54:25 <milkpost> which i guess has all come out of this "markdown extra"
20:55:43 <ddarius> It will support it if you provide a patch.
20:55:46 <tgeeky> milkpost: I'm actually working on something loosely related (read: inspired by) markdown, but with an emphasis on areas of text (as opposed to lines of text), and multi-line math
20:56:11 <milkpost> ddarius: yes, I am thinking about this, but I am a wreck with haskell.  will get to work on it
20:56:12 <tgeeky> milkpost: but it's too far off to be useful
20:56:32 <tgeeky> milkpost: the guy who made pandoc is making pandoc2
20:56:41 <milkpost> yeah but it's really experimental?
21:28:14 <parcs> what's a sensible type of an indexed-monad-based `catch`?
21:28:51 <bfig_> what's an indexed monad?
21:29:32 <parcs> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed.html#t:IxMonad
21:30:44 <shachaf> instance Ord (TMVar a) where compare x y = compare (addressOf x) (addressOf y)
21:30:51 <shachaf> addressOf :: a -> Word; addressOf x = W# (unsafeCoerce# x)
21:31:45 <Axman6> does that work? o.O
21:32:08 <shachaf> I would guess that that depends on what you mean by "work".
21:33:01 <mike-burns> Well we're in #haskell so ... does that compile?
21:33:40 <shachaf> λ> unsafeCoerce# "I hope not." :: Bool
21:33:41 <shachaf> True
21:33:53 <Axman6> :(
21:33:55 <mike-burns> It works!
21:33:56 <kolieezy> how would I create a Haskell funtion letitBe take a function of one arguement and a list as arguments?
21:34:00 <Axman6> what happens if you do that with []?
21:34:07 <shachaf> I assume False.
21:34:16 <tgeeky> never assume!
21:34:19 <shachaf> Yep.
21:34:28 <shachaf> @quote ddarius isJust
21:34:28 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
21:34:30 <tgeeky> damn. assume awway!
21:34:51 <mike-burns> kolieezy: What's it do with this function and list?
21:34:57 <Axman6> kolieezy: can you be more clear/give an example of what you'd like?
21:35:05 <bfig_> parcs, that is hardly helpful :p
21:35:13 <coppro> > unsafeCoerce [] :: Bool
21:35:13 <lambdabot>   Not in scope: `unsafeCoerce'
21:35:36 <parcs> bfig_: but that's exactly what it is
21:35:48 <bfig_> what the hell is 'j' about?
21:35:59 <kolieezy> okay... I want the function letitBe to evaluate to True if the list contains any elements and false otherwise.
21:36:04 <bfig_> sounds like a functor with some extra meat
21:36:23 <Axman6> > not . null $ []
21:36:25 <lambdabot>   False
21:36:28 <Axman6> > not . null $ [1]
21:36:30 <lambdabot>   True
21:36:33 <mike-burns> kolieezy: letitBe _ = not . null
21:36:45 <mike-burns> But that hardly seems helpful.
21:36:48 <shachaf> kolieezy: Is this a homework question?
21:36:59 <kolieezy> no it is not...
21:37:16 <bfig_> kolieezy, letitBe f  = (not.null)
21:37:18 <kolieezy> it is an example i came up with in liew of a question
21:37:29 <bfig_> nevermind mike already wrote that
21:37:51 <mike-burns> kolieezy: More importantly, what can we explain such that you can write this yourself?
21:38:19 <kolieezy> thanks for all the help... mike burns i will try and figure this out for a sec.brb
21:38:31 <mike-burns> OK, that works too.
21:38:33 * mike-burns wanders off.
21:40:26 <kolieezy> is not null meaning TRUE?
21:40:53 <shachaf> kolieezy: No.
21:41:23 <kolieezy> ok..... *thinking* brb
21:41:28 <bfig_> kolieezy, not is a function that maps true to false, false to true
21:41:36 <bfig_> it is a function, so it can be composed
21:41:44 <bfig_> not :: Bool -> Bool
21:42:05 <bfig_> null is a function that takes a list and returns a boolean: null :: [a]->Bool
21:42:50 <bfig_> . has this signature: (.) = (b->c)->(a->b)->(a->c)
21:42:56 <bfig_> (.) ::. ...
21:43:19 <Axman6> @src (.)
21:43:19 <lambdabot> (f . g) x = f (g x)
21:43:19 <lambdabot> NB: In lambdabot,  (.) = fmap
21:43:23 <kolieezy> bfig: ah, i see...
21:43:39 <Axman6> > (f . g . h) x
21:43:40 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:43:40 <lambdabot>    `GHC.Show.Show a'
21:43:40 <lambdabot>      a...
21:43:46 <Axman6> > (f . g . h) x :: Expr
21:43:47 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:43:47 <lambdabot>    `SimpleReflect.FromExpr ...
21:43:51 <Axman6> -_-
21:44:02 <Axman6> > (f . g . h :: Expr -> Expr) x :: Expr
21:44:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:44:03 <lambdabot>    `GHC.Show.Show a'
21:44:03 <lambdabot>      a...
21:44:10 <Axman6> die in a hole lambdabot
21:46:32 <shachaf> > ((f::Expr->Expr) . (g::Expr->Expr) . (h::Expr->Expr) :: Expr -> Expr) (x::Expr) :: Expr
21:46:34 <lambdabot>   f (g (h x))
21:46:39 <shachaf> Axman6: So simple!
21:46:59 <Axman6> yeah i could see it was going there, and gave up
21:47:26 <shachaf> > ((f::Expr->Expr) . ((g::Expr->Expr) . (h::Expr->Expr) ) :: Expr -> Expr) (x::Expr) :: Expr
21:47:27 <lambdabot>   f (g (h x))
21:47:29 <shachaf> Grr.
21:47:37 * shachaf gives up on annotating the rest of it.
21:47:44 <shachaf> In fact, you can't annotate infix operators!
21:47:48 <Quantumplation> http://hpaste.org/52537 Other than all the redundant brackets, can anyone help me clean up this code a bit?
21:47:48 * shachaf never realized that.
21:48:27 <shachaf> Please don't length. :-(
21:50:03 <Axman6> Quantumplation: length foo > 0 === not (null foo)
21:50:14 <Axman6> and the latter will work with infinite lists
21:51:32 <parcs> bfig_: indexed monads are like monads but with extra type information. they can help implement static invariants of monadic code, like requiring that all thrown exceptions must be explicitly caught or else the code won't compile (which i just implemented :P)
21:52:08 <bfig_> cool
21:52:27 <Axman6> Quantumplation: that's a pretty strange type you've defined there
21:52:44 <ddarius> Indexed monads are to monads as categories are to monoids?
21:52:53 <Axman6> parcs: care to share the code? =)
21:53:43 <Quantumplation> I'm writing a generic graph library, yet I'm rather new to actually coding in Haskell (been an admirerer from afar for a long time, and i'm still rather grounded in imperitive languages), so any advice on my type design would be much appreciated
21:54:15 <Quantumplation> admirer*
21:56:35 <Axman6> you probably want to use filter to implement the stuff you're doing in the where clause
21:56:57 <Axman6> rather than ending up with the string "[1,2,,3,,,6]" or something
22:01:26 <Quantumplation> Right, i just iterated on it until I got it working, i'm now in the cleanup stage.  so far I've replaced the intercalate stuff with show (map showedges edges), trying to simplify the showedges part
22:06:53 <kolieezy> having trouble creating a .hs file on my computer. How do i do this correctly?
22:07:43 <Rotaerk> new file, name it something with ".hs" at the end
22:08:14 <Quantumplation> if on windows, make sure you have folder settings set to "show extensions for known filetypes"
22:08:27 <Quantumplation> or you'll just be naming it something.hs.txt
22:09:38 <kolieezy> still having trouble, i'm new to all of this
22:09:50 <Rotaerk> trouble how
22:11:12 <kolieezy> figuring out how to create the .hs file in my folder. Quantumplation gave a good explanation but... working on getting my directory to recognize my  source file is difficult
22:12:16 <Jafet> Why do you want to create that file?
22:12:21 <Jafet> Your editor creates it for you.
22:12:41 <kolieezy> because I am trying to create a Haskell function but I keep getting an error saying "NOT IN SCOPT"
22:12:59 <kolieezy> scope*
22:13:41 <Jafet> It seems that you are confusing multiple problems.
22:13:52 <kolieezy> :(
22:14:18 <kolieezy> ok, well the main thing I am trying to do is create a Haskell funtion, but I keep getting that error.
22:15:36 <Quantumplation> is there any way to run interpreted from within leksah?
22:15:46 <Jafet> "Create a Haskell funtion [sic]" where?
22:16:20 <Jafet> If you want to create a file containing a Haskell function, then use a text editor and create it.
22:19:28 <kolieezy> right so I am wanting to create the Haskell function letitBe which takes one arg and a list of args. it should be true if function is true for anything in the list. false otherwise. But I'm wondering if I need to create a  source code for this letitBe function to be recognized in scope.
22:20:22 <shachaf> kolieezy: Why are you wanting that?
22:20:30 <Jafet> That depends on which scope it's supposed to be recognized in.
22:20:37 <Axman6> kolieezy: well, you've just described the function 'any'. but it's worth implementing yourself inductively to learn
22:21:05 <Quantumplation> woot, leksah rocks.
22:21:19 <Jafet> For ghci, you load the source file with :load.
22:22:17 <kolieezy> because I thought that's what I was supposed to do :/
22:23:25 <Quantumplation> http://hpaste.org/52539 this looking better? any other tips for cleaning this up?
22:23:47 <Jafet> kolieezy, describe, one more time, exactly what you did and exactly what you wanted to do.
22:24:08 <kolieezy> ok..
22:24:19 <Quantumplation> oo, the parameter for that lambda has some variables i can replace with _
22:25:01 <strager> I receive "Not in scope: 'opChar'" but I don't understand why.  http://slexy.org/view/s2FDacKtFB
22:25:27 <Axman6> kolieezy: do you want foo even [1,3,5] to return false, but foo even [1,2,3] to return true?
22:25:54 <Jafet> Well, strager, because it isn't in scope.
22:26:06 <Jafet> parseFactor = (do ...) where { ... }
22:26:49 <Jafet> Use a let-binding instead.
22:26:56 <kolieezy> i typed in letitBe n = (not.null)
22:27:10 <strager> A let where?
22:27:36 <strager> I could put the case when <-'ing to opChar
22:27:50 <Jafet> do opChar <- oneOf "*/"; let op = frob opChar; return (grob op)
22:28:05 <kolieezy> I want this function (letitBe) to take a function of one argument and a list as arguments.... eval to True if the func evals to true for any elements in the list and False otherwise.
22:28:07 <Axman6> kolieezy: that was in response to what you asked for before. that will not do what you've just asked for
22:28:20 <Jafet> The quirk about where is that it applies to the definition `parseFactor', not to its expressions
22:28:38 <Axman6> kolieezy: this is exactly what the 'any' function does:
22:28:39 <Axman6> :t any
22:28:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:28:44 <Axman6> > any even [1,2,3]
22:28:44 <lambdabot>   True
22:28:48 <Axman6> > any even [1,3,5]
22:28:49 <lambdabot>   False
22:29:32 <Jafet> I don't think breadth-first is the best way for kolieezy to figure out his problems.
22:29:54 <kolieezy> ok.. Axman6, im starting to understand...
22:30:06 <Axman6> no, the next stop was going to be to walk him through implementing any
22:30:08 <kolieezy> so any can be thought of as a function?
22:30:15 <Axman6> any is a function
22:30:24 <kolieezy> great... ok...
22:30:28 <geheimdienst> Quantumplation: in line 8, you can swap the two branches (if null edges then "" else ...). line 14 has an unused variable (n1id). for line 17, the convention is actually to put a "where" that's trailing a function to be the first word of a new line. also "filter notEmpty" is "filter (not . null)", afaict
22:30:43 <geheimdienst> hope this helps :) use any of the advice you want
22:30:49 <strager> That worked Jafet; I didn't know you didn't need an 'in' expression for a 'let'
22:30:53 <Axman6> it's a function that takes a function from a's to Bool's (a -> Bool), and a list of a's [a], and trutnrs a Bool
22:31:00 <Axman6> that's what the type says:
22:31:03 <Axman6> :t any
22:31:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:31:33 <Jafet> strager: that wasn't an expression.
22:31:45 <ddarius> trutnr :: b -> m b
22:31:55 <strager> Jafet: Yeah, I understand
22:31:59 <strager> I didn't know you could use let like that
22:32:04 <Jafet> @undo do a <- b; let x = f a; g x
22:32:04 <lambdabot>  Parse error at end of input
22:32:11 <Jafet> @undo do a <- b; let x = f a; g x;
22:32:11 <lambdabot>  Parse error at ";" (column 28)
22:32:15 <Jafet> @undo do { a <- b; let x = f a; g x }
22:32:15 <lambdabot>  Parse error at "}" (column 31)
22:32:19 <kolieezy> oh  okay.. i see.
22:32:21 * ddarius wonders how many tries it will take Jafet.
22:33:22 <kolieezy> can I say(in relation to my problem) :t letitBe?
22:33:46 <Jafet> @undo do { a <- b; let { x = f a }; return x; } -- lithp in mah haskel??
22:33:46 <lambdabot> b >>= \ a -> let { x = f a} in return x
22:33:48 <kolieezy> ugh, nvm its "Not in Scope"
22:33:58 <kolieezy> i keep having that problem. im not understanding.
22:34:32 <ddarius> You don't understand scoping?
22:34:45 <geheimdienst> kolieezy: are you using ghc or ghci?
22:35:05 <kolieezy> ghci
22:35:22 <kolieezy> should i use ghc?
22:36:36 <geheimdienst> ok fine. are you sure you have the right file loaded? in ghci, type ":load XYZ.hs" (for example) if you are writing into the file XYZ.hs
22:37:00 <geheimdienst> (you can also type haskell directly into ghci)
22:39:10 <anacrolix_> hi
22:39:35 <kolieezy> ok... and this is the problem that started where I needed help with creating the .hs file in my directory
22:40:56 <anacrolix_> can i extract a value as by <- without bindign to a name?
22:42:06 <Jafet1> :t liftM
22:42:07 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:42:40 <kolieezy> letitBe (\x -> True) [1..]
22:47:29 <Quantumplation> hrm.  introducing my friend to haskell, and he's wondering if there's any corporations/software/jobs actually using it, or if it's strictly research oriented
22:47:49 <Jfaet> Yes.
22:47:56 <Jfaet> ...
22:48:06 <Quantumplation> examples?
22:48:41 <shachaf> @google are there any corporations/software/jobs actually using haskell
22:48:42 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
22:48:43 <lambdabot> Title: Haskell in industry - HaskellWiki
22:49:04 <Quantumplation> ^.^ was just looking through that
22:49:09 <Jafet> Wait, you mean research excludes corporations/software/jobs?
22:49:10 <Quantumplation> just wondering if anyone here had some favorites
22:49:37 <shachaf> Quantumplation: Presumably, if someone here had a favorite, they would put it on the wiki page.
22:50:44 <anacrolix_> what's wrong with this? cp <- (readfile emptyCP path) >> forceEither
22:51:15 <shachaf> anacrolix_: The mainthing that's wrong with it is that it lacks context.
22:52:01 <anacrolix_> i want to do forceEither on the context returned from the readfile
22:52:03 <geheimdienst> Quantumplation: what i'd say is if you love programming, haskell is for you. if you love money and programming is only incidental for you, haskell might be difficult for you
22:53:09 <anacrolix_> this doesn't work either: let cp = forceEither $ readfile emptyCP path
22:53:41 <shachaf> anacrolix_: You should probably read a little bit about how IO in Haskell works.
22:53:59 <Jafet> EDOESNOTWORK
22:54:14 <shachaf> It'll be more effective than taking random guesses until the type-checker lets something through. :-)
22:54:21 <shachaf> It's probably different from what you're used to.
22:54:23 <geheimdienst> anacrolix_: be aware, if you use forceEither, the assumption is that you know what you're doing
22:54:39 <anacrolix_> i don't, but i have no idea how to handle the error monad i get otherwise
22:54:51 <Jafet> If you love money and you're really really smart, you can apply to Tsuru or Jane St.
22:55:01 <anacrolix_> is it always necessary to bind the result to something?
22:55:33 <geheimdienst> anacrolix_: you can use (>>=) to shove the result directly into the next function
22:55:41 <anacrolix_> this works, but i don't see why i have to use 'val':    val <- readfile emptyCP path; let cp = forceEither val
22:55:42 <shachaf> Wait, forceEither is fromJust for Either?
22:55:58 <anacrolix_> it's from Data.Either.Utils
22:56:05 <shachaf> anacrolix_: You don't have to use Val.
22:56:12 <geheimdienst> normally you take apart an Either with case of Left x -> ... ; Right x -> ...
22:56:20 <shachaf> For example, you can use: Right cp <- readfile emptyCP path
22:56:32 <shachaf> Or, cp <- forceEither <$> readfile emptyCP path
22:56:37 <geheimdienst> shachaf: it's from missingh, as i recall it's a little unsafe in the "head" way
22:56:50 <Jafet> This is little more than brute forcing the type system.
22:56:52 <anacrolix_> shachaf: that's what i was after
22:57:01 <shachaf> anacrolix_: However, you should really figure out what this actually means (to the degree it means anything :-) ).
22:57:17 <anacrolix_> what the hell is <$>
22:57:40 <shachaf> It's a function designed especially to annoy you.
22:57:41 <ddarius> Jafet: I'm pretty sure you can apply to those regardless of whether you love money or are very smart.
22:57:44 <geheimdienst> Jafet: sometimes the program really can't do anything except print a message and exit. forceEither might be okay then
22:58:04 <geheimdienst> anacrolix_: it's the same as fmap. it's sometimes handy, but not essential
22:58:25 <anacrolix_> i don't see why forceEither is required, if the type returned from readfile has both Left and Right anyway
22:58:32 <anacrolix_> can't you just pick the one you want?
22:59:09 <geheimdienst> anacrolix_: should be possible, yes.
23:00:33 <shachaf> anacrolix_: That's not how Either works.
23:00:41 <shachaf> anacrolix_: It has *either* a Left or a Right.
23:00:44 <shachaf> That's why it's called Eiher.
23:01:01 <geheimdienst> shachaf: "Right r <- readfile ..." should work shouldn't it?
23:01:12 <shachaf> geheimdienst: Right.
23:01:31 <shachaf> geheimdienst: It's better than forceEither, certainly (so is let Right foo = ...).
23:01:53 <Jafet> ESHOULDWORK
23:01:54 <geheimdienst> yeah. pattern match fails give you the line number. i assume forceEither doesn't
23:02:27 <shachaf> #define forceEither forceEitherMsg #__LINE__
23:03:27 <geheimdienst> and pass it all through hsc2hs? oh, you
23:04:07 <shachaf> No, just {-# LANGUAGE CPP #-}
23:04:21 <Jafet> We should do this for all of base, certainly
23:04:21 <Quantumplation> Bank of America Merril Lynch, Haskell is being used for backend data transformation and loading.  <-- Now that's impressive...
23:05:03 <geheimdienst> they're crashing all right, but at least not because of haskell
23:07:47 <luite> Quantumplation: what does that mean? which data?
23:08:11 <shachaf> luite: Impressive data.
23:08:53 <geheimdienst> data they use to confuse themselves about their own derivatives
23:10:08 <luite> perhaps they're directional derivatives... where the principal direction is down, obviously
23:10:52 <geheimdienst> or over. from everyone over to goldman sachs
23:11:20 <Jafet> Hill-tumbling optimization
23:11:26 <Quantumplation> luite: no idea, copy/pasted from the wiki heh
23:20:31 <tenei> what does it mean to create a haskell function? does it mean xyzB (\x -> x == 'a') "happy"
23:21:34 <BlankVerse> how to extract a String out of IO String in ghci?
23:21:43 <Jafet> You must use a magical wand of function creation.
23:21:59 <tenei> magical wand??
23:22:09 <BlankVerse> str :: IO String
23:22:26 <BlankVerse> i want let s = the string inside str
23:23:14 <Jafet> @where lyah
23:23:14 <lambdabot> http://www.learnyouahaskell.com/
23:24:06 <BlankVerse> like in a do block we can do s <- str , is there something similar in ghci
23:24:22 <Jafet> ghci is basically a big do-block.
23:24:29 <geheimdienst> BlankVerse: try it, it works
23:25:16 <BlankVerse> geheimdienst: yep it does
23:25:23 <BlankVerse> Jafet: thanks for the insight
23:25:42 <tenei> hi, can I get help with my question on creating a haskell func?
23:26:39 <tenei> is saying "create" the same as saying "write" or "define"
23:27:03 <geheimdienst> tenei: i'm not really sure what you're asking, but normally you just use your favorite editor to write the function into a file, then do "runhaskell yourfilename.hs", or in ghci ":load yourfilename.hs"
23:28:47 <tenei> because I was asked to create a function of some sort... yet I was given the example: xyzB (\x -> x == 'a') "happy" and i'm wondering if that example has already created a function or if I need to write the function into a file, then I can do that provided example.
23:33:00 <Botje> depends on the type of xyzB.
23:33:27 <Botje> if xyzB :: (a -> Bool) -> [a] -> [a] then no.
23:33:42 <Botje> tenei: however, my crystal ball says you are asked to reimplement filter or break or somesuch.
23:33:58 <tenei> xyzB= thereExists
23:34:12 <Botje> try to always give as much information possible, even if it's homework :)
23:34:22 <Botje> so yes, you are given an example use of your function
23:34:26 <Botje> from that you can deduce the type
23:34:44 <Botje> and the name gives further clues to the type and its workings.
23:35:20 <Botje> so you need to write the definition (and type) of thereExists to a file, load that file
23:35:31 <Botje> and your example invocation above should return something meaningful.
23:36:08 <tenei> ok... is there a site reference you recommend to help me with that process?(writing the definition and such) :) thanks so much
23:37:37 <nejucomo> The ghc 7 io manager is based on kqueue/epoll.  Is there a direct interface to those in the ghc7 stdlib now?  I can't find it.
23:39:24 <BlankVerse> let str = simpleHTTP (getRequest "http://www.reddit.com/r/nsfw.json") >>= getResponseBody
23:39:30 <BlankVerse> let str = simpleHTTP (getRequest "http://www.reddit.com/r/nsfw.json") >>= getResponseBody
23:39:35 <BlankVerse> how to get the list of urls
23:39:50 <BlankVerse> s <- str
23:40:05 <BlankVerse> s is a json string
23:40:07 <geheimdienst> nejucomo: you just spawn tons of threads, read from things, wait on sockets, etc. and the ghc runtime works its magic
23:40:34 <BlankVerse> how do i get a list of urls from s?
23:41:32 <nejucomo> geheimdienst: I specifically want access to the underlying asynchronous API.
23:41:45 <nejucomo> I see there's an epoll package in hackage.
23:42:42 <geheimdienst> i'm not sure about how to get at the underlying structure ...
23:46:21 <tenei> Botje still there?
23:46:27 <jairavax> Hello.
23:46:34 <luite> hm, I think it's not possible to get to the internals directly
23:47:00 <luite> you can of course replicate some of the functionality, but some of it will be extremely difficult, or impossible
23:47:07 <Botje> tenei: uh, i would start by learning haskell :)
23:47:09 <luite> especially thread scheduling
23:47:10 <jairavax> So if I wanted to make a really basic text adventure, with no prior Haskell experience, what would be a good guide to look at? I usually use this as my first "Hello world," when learning a new language.
23:47:26 <jairavax> Like, "Type 'north' to go north."
23:47:27 <Botje> tenei: learn you a haskell, for example
23:47:46 <Botje> jairavax: be warned, I/O is very different from other languages.
23:48:14 <tenei> can i use scheme?
23:48:19 <jairavax> Botje: sounds cool. put and such.
23:48:32 <Botje> tenei: uh .. if you have to do it in haskell .. i .. guess .. nt?
23:49:00 <tenei> well i know i need a text editor to create this "definition" right?
23:49:12 <Botje> yes, any text editor will do
23:49:40 <tenei> okay, but the language i use to create this definition is HASKELL.
23:49:47 <tenei> correct?
23:50:03 <Botje> if you have to write a haskell program, yes
23:50:05 <strager> What's the ! mean before params of a data type?  e.g. data Symbol = Symbol !Int !String -- http://hackage.haskell.org/packages/archive/symbol/0.1.1.1/doc/html/Data-Symbol.html
23:50:13 <Botje> strager: strictness annotation
23:50:41 <Botje> makes it so the two arguments are immediately evaluated if the Symbol constructor is evaluated
23:51:07 <strager> K
23:51:08 <strager> Thanks
23:52:43 <tenei> does my definition look like this: thereExists n = not.null
23:52:51 <tenei> otherwise = Fales
23:52:51 <tenei> false*
23:52:52 <Botje> probably not.
23:53:06 <Botje> look at the input you were given, the first argument is a function and the second a list
23:53:13 <Botje> so your thereExists function should take at least two arguments
23:53:17 <Botje> *exactly
23:53:18 <Botje> oops, gotta run
23:53:26 <tenei> oh no!
23:53:30 <tenei> thank you
23:53:34 <tenei> botje
23:55:34 <nejucomo> Botje: Does strictness annotation mean that field is never stored as a thunk?  Or could the !Int in the Symbol constructor be WHNF?
23:55:48 * nejucomo can write haskell, but still is confused by laziness.
23:56:05 <Botje> nejucomo: WHNF, yes.
23:56:06 <nejucomo> I guess that means I can write haskell with unknown performance characteristics.
23:58:28 <BlankVerse> decode s :: Result String
23:58:37 <BlankVerse> gives me "Unable to read String"
23:59:35 <BlankVerse> do i need to create my own data type JSContainer and use decode s :: Result JSContainer
