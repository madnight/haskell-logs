00:07:08 <bru`> Hi
00:07:47 <shachaf> bru`!
00:11:10 <kmc> hi bru`
00:11:43 <Twey> « Note: Functon webkit_web_frame_get_global_context can't binding now, Because it need JSGlobalContextRef exist in JavaScriptCore. » — what does this mean?
00:12:12 <Twey> (context: http://hackage.haskell.org/packages/archive/webkit/0.11.0/doc/html/Graphics-UI-Gtk-WebKit-WebFrame.html )
00:14:25 <Twey> JavaScriptCore is WebKit's JS engine, right?  So surely it must have this feature if other languages can bind to it?
00:25:38 * hackagebot hlint 1.8.17 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.17 (NeilMitchell)
00:33:37 <rostayob> Why isn't there a function Handle -> Handle in System.IO?
00:33:42 <rostayob> and just in GHC.IO?
00:34:24 <shachaf> There's a function Handle -> Handle in Prelude.
00:34:26 <Twey> id
00:34:32 <rostayob> @hoogle Handle -> Handle
00:34:33 <lambdabot> Prelude id :: a -> a
00:34:33 <lambdabot> Data.Function id :: a -> a
00:34:33 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
00:34:33 <JoeyA> lol
00:34:48 <rostayob> shachaf: yeah, that wouldn't work :P
00:34:55 <Twey> Why not?
00:34:57 <shachaf> What are you trying to do?
00:35:02 <JoeyA> @hoogle Handle -> IO Handle
00:35:03 <lambdabot> Control.Exception evaluate :: a -> IO a
00:35:03 <lambdabot> Control.OldException evaluate :: a -> IO a
00:35:03 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
00:35:12 <shachaf> I don't imagine a function :: Handle -> Handle could do very much useful.
00:35:18 <rostayob> shachaf: http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-IO-Handle.html#v:hDuplicate
00:35:57 <Twey> What about it?
00:36:01 <rostayob> i want to use an existing Handle to read/write without changing the position of the original handle
00:36:14 <kmc> hmm, you want a wrapper on something like UNIX's dup(2)?
00:36:17 <Twey> hDuplicate seems about right, then
00:36:17 <shachaf> rostayob: That's -> IO Handle. Completely different.
00:36:24 <rostayob> shachaf: yep right, sorry
00:37:05 <rostayob> anyway, is there something like that outsite the GHC api?
00:37:53 <kmc> GHC.*  ≠  GHC API
00:38:17 <kmc> GHC API is the package 'ghc' i.e. the modules which make up the compiler itself
00:38:32 <rostayob> oh right. is there something like that outside the ghc libraries?
00:38:48 <kmc> also "The two Handles will share a file pointer, however"
00:38:52 <kmc> so it's not what you want?
00:39:15 <rostayob> mhm right...
00:39:52 <rostayob> so is calling openFile each time the only way?
00:40:02 <kmc> hmm dup(2)'d fds also share offset
00:40:26 <kmc> what's the larger problem you're trying to solve?
00:40:54 <rostayob> reading from the same file concurrently
00:41:21 <rostayob> i'm writing a library to have a list on disk
00:42:26 <kmc> a linked list?
00:42:57 <rostayob> kmc: no, a list, see it like Serialize a => [(Int32, a)] where the int is the size
00:43:20 <rostayob> so i can skip over elements
00:43:44 <rostayob> i also plan to have bigger "jumps" somewhere, it's basically a skip list on disk but without the ordering
00:43:50 <kmc> i'm confused by the exchange "a linked list?" "no, a list"
00:44:00 <kmc> because in my mind a list is by default a linked list
00:44:11 <kmc> ok
00:44:19 <rostayob> kmc: well what i mean is that the list is serialized in one ByteString
00:44:23 <kmc> so it's a sparse vector?
00:44:26 <JoeyA> rostayob: If you duplicate system handles, you duplicate file descriptors, which are limited in number.
00:45:04 <JoeyA> So you might be better off just recording positions and seeking.
00:45:08 <rostayob> kmc: why sparse? is just a serialized list, but with a fast lookup on the index
00:45:45 <rostayob> relatively fast
00:46:08 <Twey> That's why we write ±√4
00:46:10 <kmc> they won't all be the same size?
00:46:17 <Twey> Er
00:46:19 <rostayob> kmc: the serialized items? no
00:47:06 <rostayob> JoeyA: so you're just saying to sync reads?
00:47:07 <kmc> did you consider using memory-mapped IO, by the way?
00:47:14 <rostayob> kmc: i did
00:47:35 <rostayob> but it's more complex in haskell
00:47:37 <JoeyA> rostayob: Hmm, I didn't take threads into account, sorry.
00:47:37 <shachaf> Does GHC have an interface to pread?
00:47:54 <shachaf> You can't use GHC's fancy I/O manager with memory-mapped IO, presumably, can you?
00:47:55 <rostayob> I'd probably mmap in C
00:48:13 <rostayob> shachaf: I don't think i know about that
00:48:24 <shachaf> About what?
00:48:36 <rostayob> ghc's IO with mmap
00:49:04 <kmc> there is a package on Hackage for pread
00:49:32 <rostayob> shachaf: where can i find info on that?
00:49:56 <shachaf> Aha. pread would probably be the simplest answer for what you asked for, anyway.
00:50:05 <kmc> if you don't need portability
00:50:15 <rostayob> kmc: in alternative to mmap in haskell i was thinking of storing chunks of the file in weak pointers
00:50:26 <rostayob> kmc: nah screw portability
00:50:30 <kmc> :D
00:51:21 <kmc> UNIX will outlive the human race
00:51:34 <Anon_> lol
00:51:38 <Anon_> well
00:51:42 <Anon_> the problem is
00:51:52 <Anon_> every major OS except Windows is Unix-based
00:51:56 <shachaf> kmc: Does that package work with GHC's fancy I/O manager?
00:51:57 <Anon_> we need something different
00:52:00 <Anon_> some fresh air
00:52:04 <Anon_> i mean fresh ideas
00:52:10 <kmc> don't know shachaf
00:52:10 <Anon_> somethign different from UNIX!!!
00:52:25 <rostayob> kmc: http://hackage.haskell.org/packages/archive/unix-io-extra/0.1/doc/html/System-Posix-IO-Extra.html this right?
00:52:30 <rostayob> looks a bit raw
00:52:42 <kmc> yeah
00:52:48 <kmc> yes to both
00:52:58 <rostayob> mhm...
00:53:59 <rostayob> the problem with mmap is that i need that data structure on disk to store and retrieve huge amounts of irc logs, and my machine is 32bit
00:54:14 <rostayob> so i'd be useless anyway
00:54:19 <rostayob> well for me :P
00:54:49 <rostayob> but i'll a new laptop soon so
00:54:58 <rostayob> i could write a simple C core with bindings
00:55:53 <shachaf> It looks like it just calls pread.
00:57:07 <rostayob> yeah it's link of ugly
00:59:12 <rostayob> *kind
01:00:12 * shachaf worries that this rabbit hole of GHC handles has no end.
01:00:26 <rostayob> if i want to use mmap i think i can get away with it with 2 or 3 C functions
01:00:39 <rostayob> to call from haskell
01:05:22 <rostayob> mhm.
01:05:39 <RichardBarrell> Pretty sure there's at least one interface to mmap on Hackage.
01:06:43 <rostayob> RichardBarrell: yes but they're either really specific (mmap-bytestring) or just bindings to the C functions
01:06:53 <kmc> there's also vector-mmap
01:07:05 <kmc> i wouldn't say mmap-bytestring is specific
01:07:29 <rostayob> well i can't do what i want with mmap-bytestring
01:07:42 <kmc> why not?
01:07:47 <kmc> the main thing is it's immutable
01:07:57 <kmc> otherwise, seems like a basic building block for mapping immutable data
01:08:37 <rostayob> kmc: because you can't modify the ByteString after you mapped it
01:09:12 <rostayob> also, i'm not sure how fast it is to traverse the mmapped bytestring
01:09:19 <rostayob> i just want to skip to some offsets
01:09:33 <kmc> you can get a mutable vector from vector-mmap
01:09:41 <kmc> bytestrings don't need to be traversed at all
01:10:05 <kmc> they are contiguous byte arrays in memory
01:10:21 <kmc> you're at the mercy of your OS's IO scheduler and page fault handler
01:10:59 <rostayob> right, so 'drop bignumber bs' is good
01:13:56 <rostayob> mhm, so how does it work when growing the vector?
01:14:00 <rostayob> does the file grow accordingly?
01:14:07 <rostayob> and the mmapped region with the file?
01:16:30 <rostayob> ok, no
01:16:48 <rostayob> which is kind of a problem, but this library: http://hackage.haskell.org/package/mmap-0.5.7 looks really nice
01:16:53 <rostayob> i missed it for some reason
01:17:28 <kmc> mutable vectors don't grow, do they?
01:18:06 <rostayob> @hoogle grow
01:18:06 <lambdabot> No results found
01:18:28 <rostayob> kmc: http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector-Storable-Mutable.html#g:8
01:18:48 <kmc> aha
01:18:52 <kmc> so they can :)
01:19:03 <rostayob> kmc: yes, but i still have a problem, the file size
01:19:15 <rostayob> but that mmap library makes things a lot easier
01:20:21 <rostayob> mmap is even portable
01:20:25 <rostayob> (the library)
01:20:51 <kmc> yeah
01:20:55 <kmc> it works on both operating systems ;)
01:20:58 <engla> what is a fast way to round doubles to a specific precision? (for comparison purposes/implementing Ord (Double, Double))
01:21:01 <rostayob> kmc: ehehe
01:22:29 <Ke> engla: you still might have numbers that have infinitesimal difference and compare inequal
01:22:42 <engla> Ke: not when rounding them
01:22:50 <Ke> when rounding them
01:23:12 <engla> hm ok, I see what you mean
01:23:12 <Ke> use if (fabs(x-y) < epsilon)
01:24:25 <engla> I guess that's what I have to do, only it's not pretty to express it for a pair of doublees
01:24:28 <engla> *doubles
01:24:49 <Johannes2> Are there going to be problems if I have a (==) definition on some data type which isn't identical to (\x, y -> EQ == (compare x y))?
01:25:34 <rostayob> Johannes2: well you can, but while would you want to have that?
01:25:36 <Johannes2> Say... if I have a tuple (String, a) which is ordered according to the string part only, but equality in the == sense demands that each part of the tuple is actually equal
01:25:44 <engla> Ke: you mean abs right, there is no fabs function (?)
01:26:12 <rostayob> Johannes2: it's valid haskell, but it'd be annoying i guess. what are you trying to do?
01:26:13 <Ke> engla: yes, that was in c notation while I forgot the haskell one
01:26:39 <engla> fine. I guess abs from Num will be fine
01:27:12 <Johannes2> Well, it'll be part of a part of speech tagger. The string is a morpheme and the other type is a part-of-speech tag.
01:27:50 <rostayob> Johannes2: why can't you define compare to behave the same way? you need to sort stuff?
01:28:23 <Johannes2> Well, because I can't imagine any natural way to "order" part-of-speech tags
01:28:23 <Johannes2> :/
01:28:34 <Johannes2> Equality is an entirely different matter
01:28:49 <rostayob> Johannes2: i don't really know what part-of-speech tags are. anyway the answer is: you can do it, but i'm not sure you want to do it :P
01:29:05 <Johannes2> Part of speech tags? Well, let me give an example
01:29:12 <JoeyA> You can implement Eq without implementing Ord.
01:29:30 <Johannes2> Oh, sure. But it might be useful if I want to use them in maps, for instance.
01:29:58 <Johannes2> McFeeley/NP noted/VBD the/AT immaculate/JJ lawn/NN and/CC gardens/NNS :/: each/DT blade/NN of/IN grass/NN cropped/VBN ,/, bright/JJ and/CC firm/JJ ;/. ;/.
01:30:32 <rostayob> Johannes2: can't you compare the tuples with f x y = fst x == fst y?
01:30:33 <JoeyA> If you want a fancy, application-specific definition of equality, you'll probably want to write your own class for it.
01:30:37 <rostayob> leaving equality as it should be?
01:30:45 <rostayob> yeah what JoeyA said
01:30:59 <Johannes2> Yes, that's how equality will be defined, rostayob.
01:31:07 <Johannes2> And I don't plan to do anything odd with equality
01:31:19 <rostayob> Johannes2: yes but can't you leave equality as it is (it'll derived for you) and use that function separately
01:31:20 <JoeyA> > (1/0) == (1/0)
01:31:21 <lambdabot>   True
01:31:25 <Johannes2> It's ordering that I kind of want to base solely on the string tuple containing the morpheme
01:31:26 <shachaf> You can't get a version of base earlier than 3.0.3.1?
01:31:28 <JoeyA> > (0/0) == (0/0)
01:31:29 <lambdabot>   False
01:31:42 <rostayob> JoeyA: ah ok, well it's the same
01:31:50 <kmc> shachaf, try an old ghc tarball
01:31:54 <rostayob> define your own :: Foo -> Foo -> Ordering
01:31:54 <kmc> they must be stashed somewhere
01:32:06 <JoeyA> Why does this Attoparsec parser succeed on "foobaz" ?  ((string "foo" *> string "bar") <|> (string "foo" *> string "baz"))
01:32:11 <Johannes2> Rather than using compare?
01:32:22 <rostayob> Johannes2: yes
01:32:24 <JoeyA> Doesn't the first alternative consume foo?
01:32:33 <Johannes2> That seems counterproductive! It wouldn't be a part of the Ord class then.
01:32:37 <rostayob> compare is meant to return EQ only for... equal elements
01:32:50 <JoeyA> > compare (0/0) (0/0)
01:32:51 <rostayob> if you define compare to return EQ for elements with a different second element
01:32:51 <lambdabot>   GT
01:33:00 <JoeyA> > (0/0) > (0/0)
01:33:02 <lambdabot>   False
01:33:42 <rostayob> Johannes2: well yes but if you define compare as you said, you won't be able to insert tuples with different second element in a map
01:34:06 <Johannes2> Oh hey, I guess that you're right >_>
01:34:09 <rostayob> Johannes2: would that be the expected behaviour?
01:34:17 <rostayob> (maybe it is i don't know :P)
01:34:51 <Johannes2> Well, I'm guessing that ("Tree", NP) and ("Tree", JJ) would both map to the same thing
01:35:00 <Johannes2> Which is bad
01:35:08 <rostayob> yeah exactly
01:35:11 <Johannes2> I'll just think about how to do this differently.
01:35:19 <Johannes2> Thank you.
01:35:22 <rostayob> np
01:37:43 <JoeyA> Are constant expressions in a program evaluated once?
01:37:49 <JoeyA> Or might they be evaluated multiple times?
01:38:50 <JoeyA> In my case, I want to quickly test whether a ByteString is one of a collection of alternatives.
01:39:13 <JoeyA> (of which there are about 10)
01:39:42 <JoeyA> Meh, I guess a simple case statement would be fine.
01:39:46 <Botje_> if they are constants they will be lifted to top-level CAFs
01:40:04 <Botje_> but look at the core to be sure :p
01:43:22 <JoeyA> Thanks
01:44:42 <hpaste_> cheater pasted “why does this not print the numbers?” at http://hpaste.org/51998
01:44:54 <cheater> i was expecting it to print the ints one by one
01:45:14 <cheater> like in a foreach loop
01:45:34 <shachaf> Because main is :: IO (), so you can only <- IO actions.
01:45:58 <cheater> NOOOOooooooooooooo
01:46:00 <shachaf> You can do something like forM_ l print, though.
01:46:01 <Botje_> x <- l would mean that l is an IO action.
01:46:15 <cheater> i want to do this in the list monad
01:46:28 <cheater> i thought the list monad has got do notation
01:46:34 <cheater> how do i do it like this?
01:46:50 <Eduard_Munteanu> It doesn't have 'print' or other IO actions.
01:47:33 <cheater> aha
01:47:51 <cheater> ;t forM_
01:47:55 <cheater> :t forM_
01:47:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
01:48:42 <Botje_> closest you can get with the list monad is do { x <- l; return (print x) }, which is [IO a]. If you pass it to sequence you get an IO [a] that does what you want
01:49:10 <cheater> what if i want to do something like in python:
01:49:16 <cheater> for i in l:
01:49:26 <cheater>   myfunc(1, 2, i)
01:49:38 <cheater> i need to pass the other parameters too and don't want to use an ugly lambda
01:49:44 <shachaf> Maybe you could use ListT somehow?
01:49:46 <cheater> and also want to nest for's
01:49:56 <shachaf> However, you probably don't want to.
01:50:30 <Eduard_Munteanu> result <- forM xs $ \x -> do ...
01:51:19 <cheater> what if i want to nest?
01:51:34 <cheater> say i have two lists and want to pass combinations
01:51:50 <cheater> in python i would just do:
01:51:53 <cheater> for i in l:
01:51:58 <cheater>   for j in k:
01:52:06 <cheater>     myfunc(i, j)
01:52:23 <Eduard_Munteanu> result <- forM (zip xs ys) $ \(i, j) -> do ...
01:52:33 <cheater> that's not a zipper
01:52:36 <Eduard_Munteanu> Oh, those combinations.
01:52:39 <cheater> yes
01:52:44 <Botje_> cheater: liftM2 myfunc l k
01:52:51 <Eduard_Munteanu> You can just nest forM/forM_ then.
01:52:58 <rostayob> forM_ [(x, y) | x <- xs, y <- ys] (uncurry myfunc)
01:53:02 <rostayob> there you go
01:53:12 <rostayob> no, curry
01:53:15 <rostayob> not uncurry
01:53:25 <cheater> i don't like indian
01:53:46 <rostayob> he's american
01:53:55 <cheater> Eduard_Munteanu: hmm, how would i nest forM's?
01:54:14 <rostayob> you don't need to nest forMs to do that
01:54:31 <cheater> don't be so needy, i want to give Eduard a chance too
01:54:58 <rostayob> > forM_ [(x, y) | x <- [0,1,2], y <- [4,5,6]] (curry (\x y -> print y >> print x)
01:54:59 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:55:07 <rostayob> > forM_ [(x, y) | x <- [0,1,2], y <- [4,5,6]] (curry (\x y -> print y >> print x))
01:55:08 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> ())
01:55:08 <lambdabot>    arising from a use of ...
01:55:15 <rostayob> :t forM_ [(x, y) | x <- [0,1,2], y <- [4,5,6]] (curry (\x y -> print y >> print x))
01:55:16 <lambdabot> forall b. (Show b) => b -> ()
01:55:18 <Eduard_Munteanu> forM_ xs $ \x -> do
01:55:27 <Eduard_Munteanu>     forM_ ys $ \y -> do
01:55:32 <cheater> ahh
01:56:08 <rostayob> > forM_ [(x, y) | x <- [0,1,2], y <- [4,5,6]] print
01:56:09 <lambdabot>   <IO ()>
01:56:10 <cheater> @hoogle forM_
01:56:11 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
01:56:11 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
01:56:21 <rostayob> why doesn't lambdabot execute IO actions again?
01:56:38 <cheater> splendid thanks Eduard_Munteanu
01:57:03 <cheater> that is exactly what i have been looking for
01:57:07 <Eduard_Munteanu> rostayob: so we don't pwn it :)
01:57:32 <rostayob> Eduard_Munteanu: mah
01:57:38 <rostayob> oh, and it's uncurry not curry.
01:57:46 <rostayob> i hate thos two functions. always mess them up
01:57:46 <shachaf> > putStrLn " <IO ()>"
01:57:47 <lambdabot>   <IO ()>
01:59:30 <rostayob> Cale: can't you execute lambdabot with a user with no permissions?
01:59:38 <rostayob> i guess you can't do too much damage then
02:00:14 <Botje_> arbitrary code execution -> root -> jailbreak -> game over
02:00:23 <Botje_> so .. no :]
02:00:26 <shachaf> Botje_: Not necessarily.
02:00:42 <rostayob> Botje_: not if lambdabot is run by a user that can't do anthing to the system
02:00:48 <JoeyA> But... but... I thought Haskell was pure!
02:01:09 <Botje_> there's still privilege escalation exploits
02:01:29 <Botje_> and most of them don't require any file I/O
02:01:29 <shachaf> It might be nice if lambdabot had a restricted pseudo-IO environment.
02:01:29 <kmc> nice shachaf
02:01:31 <rostayob> then you have a bigger problem
02:01:34 <Johannes2> instance Functor (Show a, Read a) => Morpheme a where
02:01:34 <Johannes2> 	fmap f (Morpheme m t) = Morpheme (f m) t
02:01:34 <shachaf> kmc: ?
02:01:42 <kmc> putStrLn
02:01:43 <kmc> there are some pure models of IO on Hackage aren't there?
02:01:48 <Johannes2> I get this error, and it's kind of confusing: "`fmap' is not a (visible) method of class `Morpheme'"
02:01:51 <Johannes2> Morpheme isn't even a class!
02:02:09 <rostayob> Johannes2: well you're treating like one
02:02:13 <Johannes2> Am I?
02:02:22 <rostayob> it should be "instance Functor (Morpheme a) where; ..."
02:02:41 <Johannes2> Oh! Okay
02:02:44 <rtharper> what does it mean to map over a morpheme?!
02:02:58 <rostayob> Johannes2: if 'a' is the inner type, you can't enforce those Show and Read
02:03:16 <Johannes2> Well, it maps over the non-tag component of the morpheme.
02:03:16 <rostayob> what does Morpheme look like?
02:03:42 <Johannes2> data (Show a, Read a) => Morpheme a = Morpheme a BPOSTag deriving Eq
02:04:07 <shachaf> Johannes2: data constraints? What is this, 1998?
02:04:13 <rostayob> well you can't do "instance Functor (Morpheme a)"
02:04:18 <rostayob> Morpheme a has kind *
02:04:31 <rostayob> you can do "instance Functor Morpheme"
02:04:33 <cheater> morning rtharper
02:04:47 <rostayob> but you can't put a constraint on the parametrized type
02:04:51 <rostayob> (in the functor instance)
02:04:53 <rtharper> good morning cheater
02:05:08 <Johannes2> Well, I'll give that another go then.
02:05:25 <rtharper> someone doing some NLP?
02:05:50 <rostayob> Johannes2: also, i don't think that data declaration is valid
02:05:56 <rostayob> is it some language extension?
02:05:57 <Johannes2> No instances for (Show b, Read b)
02:05:57 <Johannes2>       arising from a use of `Morpheme'
02:05:57 <Johannes2>     In the expression: Morpheme (f m) t
02:06:01 <Johannes2> :S
02:06:06 <rostayob> Johannes2: post the code :P
02:06:14 <Johannes2> Wow, the code is huge
02:06:29 <Johannes2> Okay! Well, I'll open pastebin then
02:06:34 <rostayob> well the Morpheme declaration and the instance
02:08:55 <rostayob> Johannes2: btw, if you are a beginner, read LYAH
02:09:00 <rostayob> @where LYAH
02:09:00 <lambdabot> http://www.learnyouahaskell.com/
02:09:03 <Johannes2> http://pastebin.com/2087vQHW
02:09:05 <mauke> The paste 2087vQHW has been copied to http://hpaste.org/52001
02:09:12 <rostayob> it has crystal clear chapters on types
02:09:19 <Johannes2> I read through A Gentle Introduction to Haskell, actually
02:09:24 <rostayob> wow.
02:09:27 <rostayob> that's a big data type.
02:10:05 <Johannes2> I didn't include their instantiation in show and read
02:10:16 <Johannes2> But BPOSTag is instantiated in show and read, if it means anything.
02:10:55 <rostayob> Johannes2: the solution is: remove those constraints on the data constructor
02:11:03 <rostayob> i didn't even know you could do that
02:11:26 <Johannes2> Oh, hm! Dangerous.
02:11:28 <rostayob> you'll have to put constraints on the functions operating on Morpheme
02:11:31 <Johannes2> Okay. I'll take them out then.
02:11:33 <rostayob> :t fmap
02:11:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:11:44 <rostayob> there is no Show or Read here
02:11:47 <rostayob> on 'b'
02:11:54 <rostayob> so that can't type check
02:12:59 <rostayob> Johannes2: do you see the issues? GHC can't be fure that the function used with fmap will return something that's an instance of Show and Read
02:13:02 <rostayob> types are cool
02:13:19 <rostayob> *GHC can't be sure
02:14:21 <Johannes2> I'm unsure why the type of f can't be checked and matched against the type constraints on the functor instantiation
02:14:44 <rostayob> the type of f is already known, a -> b
02:14:46 <rostayob> :t fmap
02:14:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:14:54 <rostayob> you can't put additional constrainst on 'b'
02:14:59 <rostayob> it's already there
02:15:20 <Johannes2> I guess that I just didn't know that you couldn't impose additional constraints!
02:15:41 <rostayob> Johannes2: nope, you can't, it'd be quite a mess if you could :)
02:15:54 <rostayob> it'd be another type class
02:16:04 <rostayob> @info Functor
02:16:04 <lambdabot> Functor
02:16:05 <Johannes2> Thanks for helping me out.
02:16:12 <rostayob> oops that doesn't work here
02:16:15 <rostayob> Johannes2: np
02:18:58 <rostayob> Johannes2: but really, read LYAH, even just the chapter on the types
02:19:02 <rostayob> they're pretty good
02:19:45 <Johannes2> Would that cover much ground that wouldn't already have been covered in A Gentle Introduction to Haskell?
02:20:18 <rostayob> Johannes2: never read that, but it can't hurt - since your ideas are still confused on that (and it's perfectly normal, it took months for me eheh)
02:20:45 <Johannes2> Well, it looks fairly well-set-out. I might take a look. Thanks!
02:33:40 <cheater> @undo do x <- func; x
02:33:40 <lambdabot> func >>= \ x -> x
02:34:03 <cheater> @undo do (x, y) <- func; x
02:34:03 <lambdabot> func >>= \ (x, y) -> x
02:37:01 <cheater> @hoogle [a] -> Int -> [a]
02:37:01 <lambdabot> Prelude drop :: Int -> [a] -> [a]
02:37:01 <lambdabot> Prelude take :: Int -> [a] -> [a]
02:37:01 <lambdabot> Data.List drop :: Int -> [a] -> [a]
02:38:29 <cheater> :t takeWhile
02:38:30 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:38:43 <cheater> does takeWhile stop on the first failure?
02:39:06 <rostayob> > takeWhile (const False) [1..]
02:39:07 <lambdabot>   []
02:39:11 <kmc> yes
02:39:18 <kmc> that's the difference between takeWhile and filter
02:39:28 <kmc> @check \xs -> takeWhile even xs == filter even xs
02:39:29 <lambdabot>   "Falsifiable, after 9 tests:\n[-5,2,-5,-1]\n"
02:39:38 <kmc> it doesn't shrink?
02:40:49 <kmc> Prelude> :m + Test.QuickCheck
02:40:52 <kmc> Prelude Test.QuickCheck> quickCheck (\xs -> takeWhile even xs == filter even xs)
02:40:57 <kmc> *** Failed! Falsifiable (after 4 tests and 4 shrinks):
02:40:57 <kmc> [1,0]
02:41:39 <Eduard_Munteanu> @check \xs -> length (takeWhile even xs) <= length (filter even xs)
02:41:40 <lambdabot>   "OK, passed 500 tests."
02:42:10 <cheater> :t pure
02:42:11 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
02:43:07 <Eduard_Munteanu> @check \xs -> length (takeWhile even xs) > length (filter even xs)
02:43:07 <lambdabot>   "Falsifiable, after 0 tests:\n[-1,1]\n"
02:43:16 <Eduard_Munteanu> @check \xs -> length (takeWhile even xs) == length (filter even xs)
02:43:16 <lambdabot>   "Falsifiable, after 2 tests:\n[1,2,-1,4]\n"
02:44:06 <shachaf> @check \x -> x /= 12345
02:44:06 <lambdabot>   "OK, passed 500 tests."
02:44:13 <Jaxan> :')
02:44:20 <cheater> > takeWhile even [1..10]
02:44:21 <lambdabot>   []
02:44:26 <cheater> > takeWhile even [0..10]
02:44:27 <lambdabot>   [0]
02:44:43 <Johannes2> Ugh, is there a way of "show"ing a String so that it doesn't have quotes without manually discarding them?
02:44:53 <shachaf> @check (/=123)
02:44:53 <lambdabot>   "Falsifiable, after 448 tests:\n123\n"
02:44:55 <shachaf> @check (/=123)
02:44:56 <lambdabot>   "OK, passed 500 tests."
02:46:39 <hpaste_> cheater pasted “how do i get ints out of IO?” at http://hpaste.org/52003
02:46:52 <Eduard_Munteanu> Johannes2: you just don't show it
02:47:02 <cheater> i have an IO Int but need to put it into a function that takes an Int, what do?
02:47:21 <Botje_> you execute it like any other IO action.
02:47:25 <Johannes2> Well, sure. But I'm unfortunately dealing with a generic type a
02:47:27 <cheater> how?
02:47:29 <Botje_> width' <- width
02:47:40 <rostayob> Johannes2: you can't
02:47:41 <Johannes2> And trying to show type a, which CAN be a string, but if it's a string it displays with quotes.
02:47:53 <kmc> oh dear cheater
02:47:57 <cheater> kmc yes
02:48:01 <cheater> what is going on
02:48:04 <kmc> you've asked like the key question of #haskell
02:48:12 <kmc> the nexus around which our entire world revolves
02:48:13 <cheater> have i
02:48:15 <cheater> why
02:48:15 <rostayob> Johannes2: show on strings will always behave the same, i find it annoying as well from times to times
02:48:21 <kmc> http://haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
02:48:30 <rostayob> cheater: unsafePerformIO
02:48:49 <rostayob> :t unsafePerformIO
02:48:50 <lambdabot> Not in scope: `unsafePerformIO'
02:48:57 <rostayob> @hoogle unsafePerformIO
02:48:57 <lambdabot> Foreign unsafePerformIO :: IO a -> a
02:48:57 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
02:49:01 <rostayob> ignore the suspicious name
02:49:11 <Eduard_Munteanu> Johannes2: you might want to use your own typeclass for converting stuff to strings
02:49:15 <cheater> why don't i ignore you instead
02:49:19 <shachaf> @remember monochrom How do I extract the IO out of IO String?
02:49:19 <lambdabot> It is stored.
02:49:23 <rostayob> cheater: go on
02:49:29 <Eduard_Munteanu> Johannes2: for strings, it should be id, and for everything else show
02:49:50 <shachaf> kmc possesses such a type class.
02:49:52 <Johannes2> Cool, thanks.
02:49:54 <shachaf> Or did you just use Typeable?
02:49:54 <rostayob> Johannes2: or you could use Typeable, but that'd be kind of ugly
02:50:03 <rostayob> @hoogle cast
02:50:03 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
02:50:03 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
02:50:03 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
02:50:05 <cheater> kmc possesses a lot of class.
02:50:08 <rostayob> (the first one)
02:50:37 <Eduard_Munteanu> Nah... just    class (Show a) => MyShow a
02:50:40 <shachaf> @hoogle unsafeCoerce
02:50:40 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
02:50:53 <rostayob> Johannes2: strangeShow x = case cast x :: Maybe String of; Just s -> s; Nothing -> show x
02:51:03 <rostayob> but yeah that's not nice.
02:51:05 <Eduard_Munteanu> Then you can make instances for String and a. You might need the overlapping instances extension, though, I guess.
02:51:16 <Eduard_Munteanu> Erm...
02:51:21 <rostayob> the separate type class solution is ugly as well
02:51:47 <Eduard_Munteanu> class MyShow a    and the instances would be better off specifying their requirements
02:51:47 <rostayob> you don't even need the type annotation actually
02:51:55 <shachaf> rostayob: No type necessary. :-)
02:51:56 <shachaf> Right.
02:53:07 <rostayob> Johannes2: gotta go, good luck eheh
02:53:15 <Johannes2> Thanks!
02:53:16 <Johannes2> Later.
02:53:34 <shachaf> @ty liftA2 fromMaybe show cast
02:53:35 <lambdabot> forall a. (Show a, Typeable a) => a -> String
02:53:51 <cheater> :t mvWAddStr
02:53:52 <lambdabot> Not in scope: `mvWAddStr'
02:53:55 <shachaf> @let to_s = liftA2 fromMaybe show cast
02:53:56 <lambdabot>  Defined.
02:54:03 <cheater> @type mvWAddStr
02:54:04 <lambdabot> Not in scope: `mvWAddStr'
02:54:09 <cheater> @hoogle mvWAddStr
02:54:09 <lambdabot> No results found
02:54:25 <shachaf> > [(1 `to_s`), ("abc" `to_s`)]
02:54:26 <lambdabot>   ["1","abc"]
02:54:50 <co_dh> @free (a->b) ->( [a] -> [b])
02:54:51 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
02:55:02 <co_dh> @help
02:55:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:55:06 <co_dh> @help free
02:55:07 <lambdabot> free <ident>. Generate theorems for free
02:55:16 <co_dh> @free map
02:55:17 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
02:55:22 <shachaf> @free f :: (a->b) -> ([a] -> [b])
02:55:22 <lambdabot> h . k = p . g => $map h . f k = f p . $map g
02:55:32 <co_dh> shachaf: thanks
02:56:16 <co_dh> @type join
02:56:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:56:27 <co_dh> @free join
02:56:28 <lambdabot> Expected variable or '.'
02:57:00 <co_dh> @free j :: [[a]] -> [a]
02:57:01 <lambdabot> $map f . j = j . $map ($map f)
02:59:09 <co_dh> @type map
02:59:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:59:57 <co_dh> why @free map gives different result to @free f :: ( a->b) ->([a]->[b]) ?
03:00:21 <co_dh> oh, there are the same. my mistake
03:11:54 <hpaste_> cheater pasted “how do you noop in IO?” at http://hpaste.org/52004
03:12:19 <cheater> i'm not sure what to do with an if that doesn't have anything in the else branch
03:12:22 <kmc> return ()
03:12:27 <kmc> you can also use 'when' from Control.Monad
03:12:36 <kmc> also, there's a syntactic variant of "let" for use in "do" blocks
03:12:45 <kmc> where you omit the "in" and align the next "do" statement with the "let"
03:12:45 <cheater> oh right ok i was confused
03:13:04 <cheater> how does that look kmc
03:13:29 <kmc> i think 'return' does not do what you think it does
03:13:35 <kmc> it can't early-exit a block
03:13:41 <kmc> 'return' is perhaps poorly named
03:13:53 <kmc> it just takes a value and gives you a dummy IO action which does no IO and produces that value
03:14:01 <cheater> yeah i got tricked
03:14:05 <cheater> i figured out what return does
03:14:10 <cheater> i just forgot for a sec
03:15:26 <tsousa> can someone please help me understand why curried functions are usefull?
03:16:06 <JoeyA> map (subtract 10) [1..10]
03:16:09 <JoeyA> > map (subtract 10) [1..10]
03:16:10 <lambdabot>   [-9,-8,-7,-6,-5,-4,-3,-2,-1,0]
03:16:18 <hpaste_> kmc annotated “how do you noop in IO?” with “how i would write it (for cheater)” at http://hpaste.org/52004#a52005
03:16:48 <kmc> tsousa, it just reduces the syntactic overhead of using higher-order functions
03:17:13 <Botje_> tsousa: map (f p) instead of map (\x -> f p x)
03:17:26 <cheater> FOR ME <3
03:17:30 <kmc> yes
03:17:34 <kmc> it's like a song title right
03:17:53 <cheater> it's like we're on Soul Train
03:18:00 <kmc> more like crazy train
03:18:06 <tsousa> Botje_, didnt understand your last example
03:18:12 <cheater> esoteric train?
03:18:46 <cheater> :t when
03:18:47 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:18:53 <cheater> what does when do?
03:18:58 <Botje_> tsousa: if f is a function that expects two arguments, giving it one returns a new function that expects one more
03:19:02 <Botje_> cheater: what do you think it does?
03:19:10 <cheater> i'm not sure.
03:19:15 <cheater> what if the predicate doesn't fire?
03:19:16 <Botje_> cheater: what do the docs say it does?
03:19:24 <cheater> i'm not sure
03:19:27 <cheater> they're still loading
03:19:39 <cheater> in fact the google results are still loading
03:19:44 <tsousa> Botje_, yes that i understand but why do that?
03:19:44 <kmc> @src when
03:19:45 <lambdabot> when p s = if p then s else return ()
03:19:47 <kmc> cheater, ^^
03:19:48 <cheater> how on earth do i get the docs for a function, automatically?
03:19:53 <Botje_> tsousa: because \x -> f p x is ugly to write
03:19:55 <cheater> kmc: ah nice
03:19:58 <Botje_> compared to just "f p"
03:20:01 <cheater> man
03:20:12 <cheater> hackage should have like a function name search with links
03:20:15 <tsousa> i dont know what \x means
03:20:18 <kmc> cheater, i'd hoogle it and then search the module at http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html
03:20:25 <Botje_> cheater: you mean like hoogle and hayoo do?
03:20:25 <kmc> tsousa, it's an anonymous function
03:20:27 <kmc> lambda abstraction
03:20:35 <cheater> that's the retardedest way to use documentation ever kmc
03:20:43 <kmc> tsousa, (\x -> e) is a function which takes an argument named x and evaluates to the body e
03:21:17 <tsousa> ok thanks
03:21:42 <kmc> in some languages lambda is a lot heavier and so you're looking at a bigger difference
03:22:04 * shachaf is still of vague opinion that lambda syntax should only allow one argument at a time.
03:22:31 <kmc> e.g. javascript  map(add(4), xs)  vs.  map(function(x) { return add(4,x); }, xs)
03:22:40 <kmc> in some languages lambda is less heavy syntax
03:23:12 <kmc> c#  map(add(4), xs)  vs.  map(x => add(4,x), xs)
03:23:18 <kmc> note: i don't actually know javascript or c#
03:24:46 <mauke> map { $_ + 4 } @xs
03:24:52 <kmc> :D
03:24:53 <mauke> (but that's not a lambda)
03:24:57 <kmc> what crazy esolang is that mauke
03:25:07 <mauke> perl
03:25:09 <kmc> ;)
03:25:20 <moriramar> Excuse me, I am reading third block at https://secure.wikimedia.org/wikibooks/en/wiki/Haskell/Polymorphism#runST . However, ghci even complain about type of runST (newSTRef "abc"). Is it expected?
03:25:35 <kmc> moriramar, yes, because the ref would escape
03:25:38 <mauke> moriramar: yes, that's the point
03:25:40 <hpc> mauke: technically, all perl lambdas are \(@_) -> ... :P
03:25:57 <mauke> yeah
03:26:02 <kmc> the strange type of runST ensures that STRefs cannot escape the runST
03:27:05 <Eduard_Munteanu> :t newSTRef
03:27:06 <lambdabot> forall a s. a -> ST s (STRef s a)
03:27:26 <moriramar> kmc, So both lines (  v   = runST (newSTRef "abc") ;  foo = runST (readVar v)) are wrong in the block.
03:27:37 <Eduard_Munteanu> The 's' can't be allowed to leak.
03:28:00 <moriramar> Eduard_Munteanu, kmc, mauke, Thank you.
03:28:58 <Eduard_Munteanu> > runST (newSTRef "abc" >>= readSTRef)
03:28:59 <lambdabot>   "abc"
03:29:14 <Eduard_Munteanu> > runST (newSTRef "abc" >> return ())
03:29:15 <lambdabot>   ()
03:29:26 <Eduard_Munteanu> > runST (newSTRef "abc")
03:29:26 <lambdabot>   Inferred type is less polymorphic than expected
03:29:27 <lambdabot>    Quantified type variable...
03:34:26 <Nakuro> hi everyone
03:35:33 <kmc> hi Nakuro
03:45:18 <Nakuro> i am a little noob in haskell, and i had follow some tutorials, but the programs i created are always to simple, in much cases is a program that doing some simple task. One question that i want to ask is if can anyone give me a website or something that i can find some programs in haskell with more complexity.
03:45:23 <Nakuro> For example, in some imperative languages is common with a more little of experience, we construct some simple applications that manage "clients", "products"  or something like that with some options to manage something.
03:45:30 <Nakuro> In haskell i didn't see nothing like that, and now i think: "ok, i learned haskell i know some concepts and i build some simple examples, but now i liked to put in practice this knowlege i program some simple useful application", but honestly i don't know how :)
03:45:48 <Nakuro> can anyone give me some hints?
03:45:52 <Nakuro> :)
03:46:19 <ben> Did you read Real World HAskell?
03:47:36 <kmc> Nakuro, take a look at xmonad.  it's a tiling window manager for X Windows in about 500 lines of Haskell (plus a ton of add-ons).  there's also lots of talks etc. about its design and implementation
03:48:13 <kmc> Haskell isn't much used for CRUD business apps to my knowledge
03:48:16 <kmc> ( http://en.wikipedia.org/wiki/Create,_read,_update_and_delete )
03:48:30 <kmc> you could look at some of the webapp frameworks though
03:49:34 <Nakuro> i followed Learn You a Haskell for Great Good!
03:50:39 <kmc> i recommend reading or at least skimming both LYAH and RWH
03:52:26 <ski> moriramar : it is important that the mutations performed by `writeSTRef' and the accessing done by `readSTRef' happen in a defined order
03:53:37 <moriramar> So, about things like (runST . newSTRef), runST requires the result should remain the same type without considering the type s, while STRef s a is not a valid result type. ?
03:53:39 <Nakuro> don't exist any website with some examples of simple applications in haskell, when i can extract some ideas?
03:54:39 <llano> Nakuro: i think you can download hackages, full of examples.
03:54:40 <Eduard_Munteanu> moriramar: btw, you can't use   runST . newSTRef
03:54:47 <moriramar> Eduard_Munteanu, yes, i mean that.
03:54:52 <ski> moriramar : if you could say `do ref <- newSTRef 0; ...; let {foo = runST (writeSTRef ref "abc"); bar = runST (readSTRef ref)) }; ..foo..bar..', there there couldn't be an explicit ordering between the read and the write to `ref'
03:55:05 <kmc> Nakuro, look at xmonad and the examples in RWH
03:55:12 <Eduard_Munteanu> moriramar: your result type cannot contain that 's'
03:55:16 <kmc> and maybe http://mainisusuallyafunction.blogspot.com/2010/10/tour-of-real-toy-haskell-program-part-1.html
03:55:42 <moriramar> Eduard_Munteanu, ski, Thanks a lot.
03:55:43 <Eduard_Munteanu> moriramar: it's universally quantified, so only the stuff inside the runST block knows what it is.
03:55:44 <ski> moriramar : so, the `s' in `ST s a' and in `STRef s a', together with the rank-2 type `runSTRef :: (forall s. ST s a) -> a' conspire together to disallow you from not specifying the order like that :)
03:56:05 <Eduard_Munteanu> (and even there it's phantom)
03:57:21 <ski> moriramar : this also means that while you can use several different "state threads" (each being started and finished off by a single `runST'), you can't mix references from one of the threads in any of the others -- which is of course also good
03:57:22 <Nakuro> hum, i am going to follow your suggestions, i am going to research a little.  thank you guys:)
03:57:29 <kmc> yep, good luck Nakuro :)
03:57:36 <kmc> be sure to come back with specific questions about code
03:57:55 <kmc> (I wrote that last blog article for precisely this purpose, so you can bug me about it if anything is confusing or unclear)
03:58:03 <ski> (though it *would* maybe be useful if you could have "sub-state-thread", where an inner "thread" could read and modify references in an outer one ?)
03:58:06 <moriramar> ski, Well, a perfect design.
03:59:53 <ski> moriramar : btw, if you were wondering, `ST' stands for "State Thread"
04:00:15 <kmc> but not for the "threads" of concurrency
04:00:19 <Twey> I thought it was ‘State Transformer’
04:00:20 <ski> indeed
04:00:27 <Twey> :-\
04:00:31 <kmc> Twey, I've seen both
04:00:38 <Twey> Haha
04:00:39 <kmc> of course this is massively confusing with State and StateT
04:00:40 <moriramar> ski, Ah, I just found that in a corner in RWH.
04:00:45 <Twey> It's just ST — nobody knows what it means :þ
04:00:48 <kmc> and to make it worse _All About Monads_ names their State monad ST
04:00:55 <Twey> Nice
04:01:09 <moriramar> kmc, Yes, I remember I asked here 2 days ago whether ST has something to do with StateT...
04:01:51 <kmc> i think ST is just "state" contracted to two letters to remind you that under the hood it's like IO
04:02:03 <kmc> that's how i think of it anyway
04:05:55 * hackagebot seqloc-datafiles 0.2.1 - Read and write BED and GTF format genome annotations  http://hackage.haskell.org/package/seqloc-datafiles-0.2.1 (NicholasIngolia)
04:19:14 <malorie> I want to define a data type with (many) constructors which all have the same type. is this the way to go? http://ideone.com/MxSkJ
04:20:45 <Botje_> I think it's an error, even.
04:20:56 <malorie> howso?
04:21:04 <kmc> did you consider data BlaFlavor = Foo | Bar | Baz | ...;  data Bla = Bla BlaFlavor String String
04:21:15 <Botje_> okay, it's not. nevermind :)
04:21:21 <malorie> kmc: I think that's what I was looking for :-)
04:30:45 <augur> wunki_off: ping
04:31:16 <limetree> isPrime x = not $ any (\y -> x `mod` y == 0) (enumFromTo 2 (floor (sqrt x))) -- what's wrong with that? the definition goes through but I get ambigious type variables when I run it.
04:32:18 <mauke> limetree: you're using both mod and sqrt with x
04:32:23 <mauke> mod requires integers
04:32:29 <mauke> sqrt requires floating point numbers
04:32:39 <mauke> there is no type that is both
04:32:46 <hpc> :t mod
04:32:47 <lambdabot> forall a. (Integral a) => a -> a -> a
04:32:48 <hpc> :t sqrt
04:32:49 <lambdabot> forall a. (Floating a) => a -> a
04:33:18 <hpc> it's possible to make a type that is an instance of both, but it would be A Bad Thing (TM)
04:33:41 <limetree> aah. do I need some conversion then?
04:33:49 <mauke> (takeWhile (\n -> n * n <= x) [2 ..])
04:33:51 <shachaf> > mod parent up
04:33:53 <hpc> :t fromIntegral
04:33:53 <lambdabot>   5
04:33:53 <lambdabot> forall a b. (Integral a, Num b) => a -> b
04:33:59 <hpc> :t realToFrac
04:34:00 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
04:34:07 <hpc> limetree: take your pick
04:34:12 <limetree> thanks
04:34:26 <mauke> it's better not to use sqrt
04:34:42 <mauke> hpc: realtoFrac?
04:34:42 <limetree> I guess
04:34:47 <mauke> hpc: why?
04:34:56 <mauke> > let isPrime x = not $ any (\y -> x `mod` y == 0) (takeWhile (\n -> n * n <= x) [2 ..]) in isPrime 91
04:34:56 <lambdabot>   False
04:35:06 <hpc> mauke: er, derp
04:35:20 <hpc> the numeric classes are too damn confusing
04:35:32 <benmachine> > 13 * 7
04:35:33 <lambdabot>   91
04:36:27 <cheater> hey if i have two functions calling eachother recursively in the tail then that's OK, right?
04:36:34 <cheater> i have something like:
04:36:50 <cheater> work = ... handleKey            handleKey = ... work
04:36:54 <augur> man
04:36:59 <mauke> cheater: depends on the ...
04:37:01 <augur> that was the fastest two upvotes ive ever gotten
04:37:09 <cheater> mauke: a case expression.
04:37:15 <augur> i posted a reply to wunki on reddit and within like two minutes i get upvotes
04:37:17 <augur> thats nuts
04:37:26 <ski> moriramar : "Lazy functional state threads" by Simon Peyton-Jones and John Launchbury in 1994-06 at <http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html#monads> explains `ST'
04:37:43 <ski> Twey : you might be interesting in that, if you haven't read it yet
04:37:43 <mauke> > let even n = n == 0 || odd (pred n); odd n = even (pred n) in even 91
04:37:47 <lambdabot>   mueval-core: Time limit exceeded
04:38:44 <benmachine> > let even n = n == 0 || odd (pred n); odd n = n == 1 || even (pred n) in even 91
04:38:48 <lambdabot>   mueval-core: Time limit exceeded
04:38:49 <benmachine> er
04:38:50 <benmachine> no
04:39:04 <cheater> mauke: why does that time out?
04:39:07 <benmachine> > let even n = n /= 1 && (n == 0 || odd (pred n)); odd n = even (pred n) in even 91
04:39:08 <lambdabot>   False
04:39:14 <benmachine> cheater: no base case for odd numbers
04:39:16 <mauke> > let even n = n == 0 || not (odd (pred n)); odd n = n == 1 || not (even (pred n)) in even 91
04:39:18 <lambdabot>   *Exception: stack overflow
04:39:26 <Johannes2> Hummmmm
04:39:29 <Johannes2> What might cause this?
04:39:32 <Johannes2> (read $ show $ take 3 $ parseBC c) :: [[Morpheme]]
04:39:32 <Johannes2> *** Exception: Prelude.read: no parse
04:39:50 <augur> Johannes2: linguistics ey?
04:39:53 <benmachine> mauke: that's even more wrong :P
04:39:57 <Johannes2> Yep.
04:40:03 <augur> Johannes2: whats your last name?
04:40:04 <hpc> Johannes2: your show and read are expecting different types?
04:40:08 <ion> read fails to parse the value as a [[Morpheme]].
04:40:09 <hpaste_> cheater pasted “recursion” at http://hpaste.org/52007
04:40:17 <cheater> is that ok?
04:40:32 <ion> Btw, (read . show . take 3 . parseBC) c :: [[Morpheme]] might be a nicer way to put that.
04:40:48 <benmachine> Johannes2: a bad Show instance
04:40:52 <Johannes2> Well! I've done a pretty good job of establishing bijection between String and Morpheme
04:41:04 <benmachine> or, well, not bad as such, but a non-derived show instance
04:41:09 <Johannes2> Although
04:41:10 <Johannes2> Ugh
04:41:13 <Johannes2> Here we go, sorry
04:41:18 <augur> Johannes2: last name :O
04:41:21 <Johannes2> Last name?
04:41:24 <augur> yours!
04:41:27 <moriramar> ski, Thanks, I checked that, but it is a little difficult to me.
04:41:28 <augur> what is it
04:41:30 <Johannes2> What a strange question!
04:41:32 <hpc> augur: lol
04:41:36 <benmachine> that is a weird question
04:41:42 <ski> kmc : (re "ST is just "state" contracted to two letters"), i suppose it could have been that -- i've always thought of it as "State Thread" after reading aforementioned paper, though
04:41:45 <Johannes2> ,,/,,
04:41:45 <mauke> cheater: looks ok
04:41:50 <augur> Johannes2: are you austrian
04:41:50 <ski> (re "to remind you that under the hood it's like IO", i think that's less likely :)
04:41:52 <Johannes2> I can see how that might be causing problems :(
04:41:53 <mauke> cheater: line 16 is probably redundant
04:41:56 <Johannes2> French, actually.
04:42:07 <augur> ok so not my Johannes!
04:42:35 <benmachine> augur: also you can whois people to find out their names
04:42:44 <ski> moriramar : you can skip the parts that you don't understand (and maybe come back to them later) -- i think the paper contains good explanations of things, though
04:42:49 <benmachine> augur: also you could offer your own name instead, that might be more polite :P
04:42:54 <augur> benmachine: that presupposes they have their real name on there!
04:42:57 <mauke> benmachine: [citation needed]
04:43:10 <augur> offering my own name wouldnt be nearly as humorous
04:43:11 <cheater> mauke: indeed
04:43:17 <cheater> mauke: why does it look ok?
04:43:40 <benmachine> mauke: wrt being even more wrong? <ref>< lambdabot>   *Exception: stack overflow</ref>
04:43:51 <mauke> benmachine: no, re: you can whois people to find out their names
04:44:00 <benmachine> mauke: oh, well, you can sometimes
04:44:00 <kmc> ski, yeah, I was just advancing it as my mnemonic interpretation, not as the origin
04:44:10 <benmachine> and if you can't maybe it's because they don't like strangers finding out their names :P
04:44:20 <mauke> cheater: because of the code and such
04:44:24 <ion> augur: IRC has this thing called /whois.
04:44:35 <mauke> ion: ...
04:44:43 <augur> ion: like i said to benmachine, that presupposes they have their real name on there
04:44:57 <augur> for instance, mauke's "real name" is apparently ω̈
04:45:15 <hpc> alternatively, it presupposes that people aren't chatting through a proxy?
04:45:15 <benmachine> I see no reason to doubt this.
04:45:16 <cheater> mauke: what is it about the code that makes it look ok?
04:45:24 <mauke> cheater: the absense of errors
04:45:29 <hpc> you can get a rough location from the ISP part of the whois
04:45:33 <augur> hpc's real name is hpc
04:45:42 <mauke> *absence
04:45:45 <augur> cheater's real name is cheater
04:45:52 <ion> augur: You were interested of Johannes2’s real name, not mauke’s AFAIU.
04:45:54 <augur> hpc: ip doesnt much help since people move :P
04:45:55 * cheater researches restraining orders
04:46:00 <augur> ion: yes, i was
04:46:14 <augur> ion: and since i dont expect people to have their real names in their whois, its not my first instinct
04:46:16 <tsousa> in the curried what is the function that its passed to the next argument?
04:46:26 <augur> tsousa: what
04:46:38 <tsousa> like max 4 5
04:46:41 <Eduard_Munteanu> augur: they do, fairly commonly in here
04:46:48 <augur> tsousa: what about it
04:47:03 <augur> Eduard_Munteanu: perhaps this is true!
04:47:12 <augur> that is however irrelevant
04:47:13 <tsousa> 4 is evalueted then there is a function that is passed to evaluet the 5
04:47:15 <tsousa> right?
04:47:18 <shachaf> tsousa: There's no "currying" involved in normal Haskell definitions, by the way. "currying" has a specific meaning.
04:47:23 <shachaf> tsousa: No.
04:47:29 <augur> tsousa: well no
04:47:33 <tsousa> so?
04:47:40 <shachaf> tsousa: (max 4) is evaluated, and it's a function that takes 5 as an argument.
04:47:52 <augur> i mean, if you want to pretend haskell is strict, you evaluate max and 4, and apply max to 4
04:48:07 <augur> then you evaluate 5 and apply the value of (max 4) to 5
04:48:09 <tsousa> max 4 is a function?
04:48:16 <augur> yes
04:48:25 <ski> @type max (4 :: Integer)
04:48:26 <lambdabot> Integer -> Integer
04:48:29 <ski> @type max 4
04:48:30 <lambdabot> forall t. (Num t, Ord t) => t -> t
04:48:37 <mauke> @src max
04:48:37 <lambdabot> max x y = if x <= y then y else x
04:48:38 <tsousa> humm ok
04:48:39 <ski> > map (max 4) [0,1,2,3,4,5,6,7]
04:48:40 <lambdabot>   [4,4,4,4,4,5,6,7]
04:48:56 <augur> its that function of one argument that takes a number and gives you back either that number, if its bigger than 4, or 4 if its lower!
04:48:57 <ski> > map (max x) [0,1,2,3,4,5,6,7]
04:48:58 <lambdabot>   [max x 0,max x 1,max x 2,max x 3,max x 4,max x 5,max x 6,max x 7]
04:49:20 <tsousa> another question, in partial applyied function the functions doesnt need a name for the arguments?
04:49:25 <augur> max 4 = \x -> if x < 4 then 4 else x
04:49:30 <mauke> tsousa: I don't understand that question
04:49:42 <augur> i concur with mauke
04:49:45 <ski> > map (\y -> max 4 y) [0,1,2,3,4,5,6,7]  -- tsousa you can do this too, if you want
04:49:46 <lambdabot>   [4,4,4,4,4,5,6,7]
04:50:17 <ski> there `y' is a local name for the argument of the function passed to `map', and it is here just passed as second (i.e. last) argument to `max'
04:50:18 <ion> @pl \y -> max 4 y
04:50:18 <lambdabot> max 4
04:50:28 <ski> (i.e. as *the* argument to the `max 4' function)
04:50:31 <ion> @unpl max 4  -- does unpl know max wants another argument?
04:50:31 <lambdabot> max 4
04:50:33 <shachaf> augur: More like max 4 = let y = 4 in \x -> if x < y then y else x -- :-)
04:50:38 <tsousa> ok thanks
04:50:43 <ski> ion : probably not
04:50:58 <augur> shachaf: :P
04:51:28 <augur> tsousa: dont forget that "max" is just a variable
04:51:36 <augur> that is bound to some lambda term
04:51:50 <augur> namely, max = \x y -> if x < y then y else x
04:51:59 <antilect> Love python :)
04:52:04 <antilect> Love haskell
04:52:07 <augur> the syntax   max x y = if x < y then y else x   is merely notation
04:52:10 <antilect> Love \o/
04:52:13 <ion> which is the same as max = \x -> \y -> if x < y then y else x
04:52:39 <ion> max = (\x -> (\y -> if x < y then y else x))
04:53:16 <augur> tsousa: consequently, max 4 isn't just some partially applied function hanging out in space
04:53:36 <augur> its a lambda term -- \y -> if 4 < y then y else 4
04:53:39 <ion> (\x -> (\y -> if x < y then y else x)) 4 = (\y -> if 4 < y then y else 4)
04:54:00 <shachaf> Well, kind of.
04:54:07 <tsousa> augur, i didnt know that max was just a variable. i dont think that it is explained in the high order function in lyah
04:54:17 <nandchan> I'm looking at the libraries/tools described at http://www.haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages but they all describe how to call /other/ languages from within haskell
04:54:21 <augur> tsousa: possibly not!
04:54:29 <kish> man this looks tough
04:54:33 <nandchan> What if I want to do the reverse? I want to run a haskell script inside a larger library written in other languages
04:54:34 <kish> i hate your gay syntax
04:54:44 <augur> tsousa: in haskell, because functions are first class, there's no point in this stuff not being variables
04:54:46 <kmc> @where ops
04:54:46 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:55:04 <Botje_> don't we hug trolls in #haskell? :)
04:55:15 <shachaf> Botje_: We summon ops to hug them.
04:55:16 <augur> Botje_: no, we make them have gay sex
04:55:21 <Eduard_Munteanu> nandchan: there's a way to call Haskell code from C, I'm unsure about other languages
04:55:21 --- mode: ChanServ set +o Igloo
04:55:29 --- mode: Igloo set +b *!*@unaffiliated/spice
04:55:29 <ion> Or alternatively prevent them from doing that.
04:55:33 --- kick: kish was kicked by Igloo (kish)
04:55:38 <shachaf> PreciousMetals: seen Igloo
04:55:44 <nandchan> Eduard_Munteanu: Link? I was trying to find stuff on google but I didn't really discover any leads
04:55:50 <shachaf> PreciousMetals: preflex would also do.
04:55:50 <Eduard_Munteanu> preflex: seen Igloo
04:55:50 <preflex>  Igloo was last seen on #ghc 5 minutes and 31 seconds ago, saying: How do I globally make "git push" behave like "git push --tags"?
04:55:58 <nandchan> If it's just from within C that's fine, I can call C just fine from within my language of choice
04:56:07 <nandchan> and failing that I'll just write a wrapper library in C
04:56:07 <augur> tsousa: does that make sense tho?
04:56:30 <kmc> nandchan, yeah, that's the usual way to go
04:56:38 <kmc> the other is to use separate processes with some kind of RPC
04:56:56 <nandchan> hmm
04:56:58 <Eduard_Munteanu> nandchan: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
04:57:36 <nandchan> well, if this helps you suggest me the best plan of action, what I'm doing is working on a library for color management. I want to allow users to define color transformations using haskell functions (of the type Color -> Color), then calling those from within my program
04:57:47 <nandchan> these would be saved as plaintext and loaded during runtime
04:57:52 <nandchan> + called a ton of times
04:57:56 <nandchan> synchronously
04:58:36 <moriramar> ski, Thanks a lot.
04:58:38 <Eduard_Munteanu> You might want to use the GHC API for that I suppose.
04:59:03 <nandchan> In particular, I'm a bit worried about speed. I'm running the functions well over 100 million times within a few seconds
04:59:04 <nandchan> If there's a significant overhead of running a haskell function like that, I might just scrap the idea
04:59:04 <Botje_> nandchan: worst case you can use ghc to compile a dynamic library and dlopen/dlsym it
04:59:36 <nandchan> Eduard_Munteanu: thanks for the link, it looks like I can work with that
04:59:36 <ski> moriramar : yw :)
05:00:27 <ski> (moriramar : also, it's good to get in the habit of reading papers. some experimental features in GHC are only decumented in papers)
05:01:10 <moriramar> ski, I will.
05:02:12 <ski> most of the papers talking about features that are (or could have been) in extensions to Haskell are not that hard to read, for the most part
05:03:47 <ski> also Philip Wadler has many good papers in the sub-directories at <http://homepages.inf.ed.ac.uk/wadler/topics/>
05:04:34 <limetree> I'm not understanding a warning I'm getting. I have import Test.QuickCheck in my file, and it's telling me the import is redundant (unless I want to import "instances alone")
05:04:50 <kmc> did you use anything from that module?
05:04:56 <ski> e.g. in <http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html>, <http://homepages.inf.ed.ac.uk/wadler/topics/monads.html> and <http://homepages.inf.ed.ac.uk/wadler/topics/strictness-analysis.html>
05:05:11 <nandchan> Eduard_Munteanu: how easy is it to interface with C structures?
05:05:39 <limetree> kmc: oh, that's what it means. I was just testing in ghci.
05:05:47 <limetree> so in the file itself there was nothing
05:06:05 <kmc> right
05:08:09 <Eduard_Munteanu> nandchan: dunno, I haven't looked into the FFI interface much
05:08:23 <nandchan> Fair enough
05:08:37 <nandchan> thanks for pointing me in the right direction, I'll play around with it
05:09:04 <tsousa> http://dpaste.com/624915/ in this function can someone explain to me the fist line?
05:09:24 <augur> tsousa: the first line is the type signature
05:09:34 <augur> lets step through it piece by piece
05:09:37 <tsousa> yes i know
05:09:46 <augur> the symbols a, b, c are type variables here
05:09:58 <augur> they can be instantiated to any type when the function is used
05:10:02 <Twey> ski: Interested, but no time to read — the very worst state in which to be :<
05:10:05 <augur> [a] just means a list of a's
05:10:18 <tsousa> why is that (a->b->c)->[a]->[b]->[c] is the logic of that
05:10:25 <augur> well
05:10:41 <augur> what zipWith does is take a function and two lists
05:11:12 <augur> and creates a third list where each element, say the ith element, is gotten by applying the function to the ith element of the original two lists
05:11:50 <augur> for instance, you might have the lists [1,2,3], ["x", "y", "z"], and you want to create the list where the ith element is a pair consisting of each of the ith elements of those two lists
05:11:55 <Twey> zipWith (++) ["a", "b", "c"] ["1", "2", "3"] = ["a1", "b2", "c3"]
05:12:03 <augur> ie [(1, "x"), (2, "y"), (3, "z")]
05:12:42 <augur> that is to say, you have a list of type [Int] and a list of type [String], and you want a list of type [(Int,String)]
05:12:44 <tsousa> augur, and that is the third list?
05:12:49 <augur> tsousa: indeed!
05:12:54 <tsousa> humm
05:12:55 <tsousa> nice
05:13:16 <tsousa> augur, and f is the function right?
05:13:19 <augur> right
05:13:30 <augur> so you need a function that combines each a and b to form a c
05:14:01 <augur> so that you can go through the [a] and [b] lists, producing from the elemenets the new elements of the [c] list
05:14:43 <tsousa> ok  thank you
05:14:46 <tsousa> i get know :)
05:14:52 <augur> in terms of equations, you want to take xs :: [a], and ys :: [b] and create the list zs :: [c] such that zs !! i == f (xs !! i) (ys !! i)
05:15:16 <augur> the ith's element of zs is the result of combining the ith elements of xs and ys
05:15:33 <augur> so you need 3 things: the combining function, and the two lists to combine
05:15:40 <augur> and you get back the combined list
05:15:46 <augur> (a -> b -> c) -> [a] -> [b] -> [c]
05:15:49 <tsousa> Haskell is pretty tricky but have some nice ideias
05:16:07 <augur> you can do this outside of haskell you know
05:16:19 <augur> and you can use a different type for this as well, to make it more like what yo'd find elsewhere
05:16:24 <ChongLi> tell me about it
05:16:33 <ChongLi> I'm trying to learn parsec
05:16:33 <tsousa> :)
05:16:35 <augur> zipWithC :: (a -> b -> c, [a], [b]) -> [c]
05:16:43 <tsousa> augur, thank you :)
05:16:44 <ChongLi> and every single error is "no instance of"
05:16:51 <augur> or maybe zipWithC' :: ((a,b) -> c, [a], [b]) -> [c]
05:16:54 <ChongLi> or no instance for
05:17:25 <augur> koninkje_away!
05:18:04 <ChongLi> I don't get it
05:18:14 <ChongLi> how do I make sense of these errors?
05:18:24 <augur> ChongLi: what are the errors specifically?
05:18:33 <ChongLi>  No instance for (Stream s0 m0 Char)
05:18:33 <ChongLi>       arising from a use of `many1'
05:19:27 <cheater> when should i be using snake_case in my code?
05:20:24 <hpaste_> ChongLi pasted “Parsec Stuff” at http://hpaste.org/52008
05:21:20 <cheater> never? always?
05:21:27 <cheater> can i use it for variable_names ?
05:22:09 <ChongLi> seems there are more people with questions than with answers at the moment? :)
05:22:09 <cheater> come on guys, don't disappoint
05:22:25 <augur> cheater: what is snake_case?
05:22:36 <cheater> you just typed it
05:22:45 <shirt> I'm using OverloadedStrings extension with text package, but I get lots of ambiguous type errors when ghc can't decide if a string literal should be String or Text. Is there a way to force all string literals to be Text?
05:22:45 <augur> explain with more words please
05:22:56 <cheater> explain_with_more_words_please
05:23:10 <augur> oh i see, you mean the thing anti-camelcase people do
05:23:13 <ski> Twey : yeah :/
05:23:18 <cheater> yes
05:23:25 <augur> afaik the convention in haskell is to use camel case not underscores
05:23:29 <cheater> should i be using camelCase for my values?
05:23:29 <cheater> ok
05:23:41 <augur> ive never seen an underscored name in haskell ever
05:23:49 <Twey> You have been sheltered
05:23:56 <augur> Twey: ;)
05:30:03 <Botje> I had to use underscores recently, as gedit didn't like the function name if'
05:30:13 <Botje> hot pink on red, anyone?
05:30:21 <Twey> This is a good reason to change editors
05:30:27 <Botje> yep
05:40:32 <ion> Underscores work rather well in stuff like prop_plus_naturals_returnNonNegative as kind of structure separators.
05:40:58 <ion> Like / in path names
05:42:07 <augur> proofs? in haskell? surely you jest
05:42:57 <cheater> ion: mhm
05:42:59 <ion> Nah, not proofs. Something weaker. :-P
05:47:20 <dino-> @seen Lemmih
05:47:21 <preflex>  Lemmih was last seen on #haskell 22 days, 2 hours, 22 minutes and 25 seconds ago, saying: Jafet: What does 'mapM_' have to do with it?
05:47:21 <lambdabot> Unknown command, try @list
05:47:46 <Botje> Those last quotes are always so .. plain
05:48:00 <ski> preflex: xseen mmorrow
05:48:01 <preflex>  mmorrow was last seen on freenode/#ghc 1 year, 256 days, 10 hours, 55 minutes and 19 seconds ago, saying: * mmorrow is rtfm'ing
05:48:16 <Botje> just once, I'd like to see something like 'Ooh, I just figured out how to compose monads! brb'
05:48:51 <ski> Botje : it would be worrying if they had figured that out, but then appeared lost in action ..
05:49:07 <Botje> exactly. we could organize a rescue mission :)
05:49:26 <osfameron> i am stuck in a monad! send halp!
05:49:38 <ski> well, maybe one would be in order in the case of mmorrow (let's not forget TheHunter)
05:50:02 <hpc> preflex: seen thehunter
05:50:02 <preflex>  thehunter was last seen on #testma 86 days, 18 hours, 31 minutes and 51 seconds ago, saying: http://pastebin.com/arycSMpi
05:50:04 <mauke> The paste arycSMpi has been copied to http://hpaste.org/52009
05:50:14 <hpc> >.>
05:50:40 <ski> iirc copumpkin(?) figured out a phone number to a relative of mmorrow, but i'm not sure if he attempted a call
05:51:06 <ski> hpc : TheHunter disappeared several years ago (3 ?, 5 ?, i don't recall)
05:51:29 <hpc> ski: so not 86 days :P
05:51:45 <ski> nah, that's someone else
05:51:54 <hpc> preflex: seen TheHunter
05:51:55 <preflex>  TheHunter was last seen on #testma 86 days, 18 hours, 33 minutes and 44 seconds ago, saying: http://pastebin.com/arycSMpi
05:51:55 <mauke> The paste arycSMpi has been copied to http://hpaste.org/52009
05:52:00 * copumpkin yawns
05:52:02 <hpc> oh, not case-sensitive
05:58:17 <ski> TheHunter was e.g. the author of the interesting "Fun With Linear Implicit Parameters" at <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> in the Monad.Reader at <http://www.haskell.org/haskellwiki/The_Monad.Reader> (now apparently at <http://themonadreader.wordpress.com/> (also see <http://www.haskell.org/haskellwiki/The_Monad.Reader/Previous_issues>)
06:02:21 <ski> <http://webcache.googleusercontent.com/search?q=cache:OcmHud8p7OAJ:www.cse.unsw.edu.au/~dons/irc/haskell/05.02.15> has TheHunter talking about that in #haskell
06:02:42 <ski> and that was in 2005 -- i'm not sure when after that he disappeared
06:03:20 <copumpkin> oh wow, koninkje_away looks nothing like how I imagined him to! I was expecting someone with a large sword and long hair like on his website
06:06:41 <MaskRay> Is there Parsec's binary for Windows?
06:10:51 <augur> copumpkin: what does koninkje_away look like? :o
06:11:00 <augur> besides a big blank space
06:11:11 <copumpkin> check the haskell reddit, edwardk posted a video :)
06:14:02 <rostayob> I don't understand why the mmap functions return an offset. is is just your offset to page boundary
06:14:28 <copumpkin> "the mmap functions"
06:14:38 <rostayob> http://hackage.haskell.org/packages/archive/mmap/0.5.7/doc/html/System-IO-MMap.html#t:Mode
06:21:18 <augur> copumpkin: which video
06:21:31 <augur> oh the smoothing one
06:21:33 <augur> i see
06:21:44 <augur> i didnt watch that because i figured it was edwardk lol
06:28:54 <augur> koninkje_away needs to talk more
06:38:54 <rostayob> ok, today i can't find the functions i want. is there a function that writes a ByteString in existing CString (Ptr CChar)?
06:39:20 <rostayob> i could poke each char but that's horrible
06:41:33 <Nibble> after using emacs for quite a while with haskell-mode, I want something similar for vim
06:41:38 <Nibble> because I want a decent text editor
06:41:46 <Nibble> suggestions? :D
06:42:18 <rostayob> ok, I found copyBytes, which will do
06:44:19 <ddarius> Nibble: vim
06:44:31 <ddarius> Oh, you want a haskell-mode for vim.
06:44:42 <ddarius> There are several options available.
06:44:56 <ski> <http://haskell.org/haskellwiki/Editors#Syntax_highlighting_and_formatting_support> mentions <http://www.vim.org/scripts/script.php?script_id=2356>
06:45:24 <ski> (/me has no idea whether that is the best one, though)
06:45:47 <rostayob> Nibble: there's a really nice haskell mode for vim, http://projects.haskell.org/haskellmode-vim/
06:45:53 <rostayob> but you probably know that already
06:46:32 <Nibble> rostayob: I have found that it is not equal with the tools there exist for emacs
06:46:39 <Nibble> which is too bad
06:46:54 <Nibble> but meh, ed ftw
06:47:15 <Nibble> also, brb
06:47:28 <rostayob> ed? wat?
06:47:30 <rostayob> ehe
06:48:29 * ski also finds <http://tokyoenvious.xrea.jp/vim/indent/haskell.vim>,<http://www.vim.org/scripts/script.php?script_id=1968>,<http://www.vim.org/scripts/script.php?script_id=2062> in his link dump
06:49:37 <rostayob> Nibble: have you tried ghc-mod? that makes haskell-mode even better
06:49:39 <rostayob> a lot better
06:59:31 <akosch> Can I use ghci-debugger from inside vim? Are there any vim plugins which integrate the two?
06:59:41 <ddarius> Mathematical popularizations are annoying.
07:01:57 <ddarius> "The idea of an existence proof [..] was unsettling to mathematicians of the old school.  In time this method of proof was pretty much fully accepted.  As well it should have been.  Existence proofs, to be sure, aren't at all troubling in everyday, nonmathematical life.: If I manage a stadium, for instance, that has 50,000 seats, and I count 49,999 people filing through the gates for an open-seating concert, I can be s
07:01:57 <ddarius> ure of the existence of an empty seat, even if I don't know precisely where it is."
07:06:50 <hpc> ddarius: to be fair, it is at least partially correct
07:07:01 <hpc> using the pigeonhole principle is an existence proof method
07:07:44 <ddarius> The problem isn't that the example isn't an existence proof.
07:09:03 <hpc> what is the problem?
07:10:07 <cheater> instead of doing x <- foo; myfunc a x y z          can i somehow put foo in the arguments of myfunc somehow?
07:10:26 <hpc> cheater: in that example? not easily
07:10:46 <ddarius> That the example given is at all on par with what mathematicians worried about and the insinuation that any mathematician ever would have been "unsettled" by that example.
07:10:47 <hpc> cheater: if you have something like x <- foo; y <- bar; func x y
07:10:54 <hpc> cheater: you can do func <*> foo <*> bar
07:11:03 <hpc> er, func <$> foo <*> bar
07:11:27 <hpc> ddarius: ah
07:11:36 <cheater> i don't
07:11:40 <cheater> the other parameters are literals
07:12:29 <hpc> @@ @pl @undo (do {x <- foo; myfunc a x y z})
07:12:29 <lambdabot>  flip (flip (myfunc a) y) z =<< foo
07:12:49 <hpc> ^ would be roughly how you would have to do it
07:15:03 <cheater> that sucks
07:15:10 <cheater> i was hoping for something better
07:16:17 <ddarius> hpc: If nothing else, it's a common fallacy of extrapolating the infinite case from the finite case, though ultrafinitists would also include finite cases where computations would be forever infeasible.
07:16:59 <Nibble> ddarius: yeah
07:17:03 <Nibble> that's what I thought too
07:24:57 <Cale> ddarius: It sometimes seems as if the pop math writers look at all the bad pop sci articles and say "I can do better than that!"
07:26:21 <benmachine> can they? do they?
07:26:46 <augur> Cale: there are pop math writers?
07:27:18 <benmachine> vi hart probably counts as popular mathematics
07:27:28 <benmachine> (difference is she's completely brilliant)
07:27:28 <rostayob> also, richard gardner
07:27:31 <rostayob> but he's great
07:27:35 <benmachine> hah
07:27:38 <rostayob> ehehe
07:27:41 <benmachine> (also she isn't in author as such)
07:27:46 <benmachine> *an
07:28:01 <rostayob> no, not richard
07:28:03 <rostayob> martin gardner
07:28:08 <benmachine> oh him, I've heard of him
07:28:12 <rostayob> man those books
07:28:22 <rostayob> my only serious maths education until i was like 19
07:29:02 <rostayob> they're brilliant
07:29:09 <rostayob> it's a shame that no one is doing things like that now
07:29:33 <rostayob> or maybe they are and i don't know :P
07:29:38 <ddarius> Another annoying passage: [Relating to the Prime Number Theorem] Why primes, the building blocks of all integers, should be intimately linked to e, the constant of growth and decay, can only be answered by [God] Himself."
07:29:50 <rostayob> ddarius: ahah that's that?
07:29:53 <rostayob> *what's that
07:34:35 <jamii> braindead: what do I call a function f s.t.    x >= y    =>   f(x) >= f(y)
07:34:56 <jamii> clearly I need more caffeine to jumpstart my memory
07:35:14 <augur> jamii: monotonic
07:35:21 <jamii> augur: thanks
07:35:33 <augur> tho usually its phrased in terms of <= not >=
07:35:37 <augur> same thing tho
07:36:04 <shirt> hello
07:36:07 <augur> hello!
07:37:54 <shirt> what is the internal format of Data.Text? Is it a single contiguous block of memory?
07:38:34 <augur> irrelevant is what it is
07:39:30 <shirt> i'm curious about performance of using Text as keys in a Data.Map versus ByteString
07:39:48 <RichardBarrell> *Kinda* irrelevant because you couldn't randomly index into a block of text even if it was just a contiguous block of memory, because it uses a variable-length representation of unicode codepoints (specifically UTF-16).
07:40:42 <RaptorRarr> shirt: Why not just test it?
07:40:53 <RichardBarrell> Still matters for runtime details, though. Last I heard, Data.Text was implemented under the hood with Data.Array.STUArrays and lots and lots of careful use of unsafePerformIO.
07:40:54 * hackagebot HTF 0.8.1.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.8.1.0 (StefanWehr)
07:41:55 <shirt> RaptorRarr: I'd like to first know what i'm testing :)
07:42:04 <RichardBarrell> shirt: ah, that's it. Data.Text provides both strict and lazy types. AUIU they're work same way as Data.ByteString: the strict ones are single blocks of contiguous memory and the lazy ones are lists of strict ones.
07:43:16 <shirt> RichardBarrell: so if i compare performance of Text versus ByteString containing UTF16 encoded string, then performance should be identical?
07:43:20 <RichardBarrell> I believe that the strict ByteStrings and Text strings have (start,end) indexes into their arrays so that taking substrings is O(1).
07:43:33 <RaptorRarr> shirt: Use Text, then use ByteString, see which is faster for your application.
07:43:42 <RichardBarrell> No, because they have different implementations and implement different semantics. :)
07:44:28 <benmachine> it depends a bit on where you're getting them from, as well
07:44:54 <RichardBarrell> Data.ByteString holds sequences of octects where Data.Text holds sequences of unicode codepoints. If you're actually working on text, then you should usually be using Data.Text for its features, but if your data is actually bytes then you should use ByteString.
07:45:13 <RichardBarrell> You should use the one that fits the semantics of your program, really.
07:47:15 <RichardBarrell> I believe that they are currently not all that far apart in performance. Last I heard, Data.ByteString has a couple implementation issues that (dcoutts? I think?) is still chewing on because they make it a little slower than it could be.
07:47:54 <augur> preflex: seen koninkje_away
07:47:54 <preflex>  koninkje_away was last seen on #haskell 62 days, 17 hours, 37 minutes and 8 seconds ago, saying: edwardk: Correction, from working on Dyna. Dana is Luke Palmer's baby
07:48:00 <augur> oh wow
07:48:31 <RichardBarrell> Of course when you start using really thrashing your CPU's L2 cache with long strings then you're going to see them diverge a bit more, but don't let that stop you using the one with the semantics that actually fit your program.
07:49:11 <RichardBarrell> I hate to go all Mindless-Self-Indulgence on the room, but could someone please shut me up? I'm bored and rambling.
07:50:17 <benmachine> RichardBarrell: everyone's always worried about bytestring performance
07:50:20 <benmachine> this is not because it's bad :P
07:50:48 <benmachine> I agree with you in general though
07:51:32 <RichardBarrell> It's not *bad* but I do remember someone (I am almost certain that it was dcoutts) at anglohaskell a couple years back talking about moving Data.ByteString from ForeignPtr to STUArray because the GC has an easier time with the latter.
07:52:50 <RichardBarrell> BTW yes, ByteString and Text values *do* have start and end indexes, so taking substrings is indeed O(1) and shares the parent string's underlying array. Similar to Java's strings, in that regard.
07:53:37 <benmachine> RichardBarrell: what I meant to imply was, people keep worrying about bytestring's performance because it's a high-performance library
07:53:41 <benmachine> and very widely used
07:53:51 <benmachine> the fact that we keep trying to make it faster doesn't mean it's not already fast
07:53:56 <RichardBarrell> I got that but I was also rambling.
07:54:00 <benmachine> anyway, things that were two years ago might have happened by now :P
07:54:02 <RichardBarrell> Sorry. :)
07:54:11 <RichardBarrell> Eh, it's still ForeignPtr.
07:54:18 <benmachine> maybe GHC got better
07:54:47 <antihoax> hii
07:54:52 <RichardBarrell> But this is GHC we're talking about, so maybe they just made foreign array allocation faster instead of rewriting ByteString to stop using it. ;)
07:54:59 <benmachine> yes
07:55:08 <benmachine> they are always doing magic in GHC HQ
07:56:27 <antihoax> what do you think which is better in haskell: looping through float values and creating redundant rounded integer table then filtering it || settng up a logic to only store uniq values in table?
07:58:55 <antihoax> btw how do i round a float value to closest integer?
07:59:38 <benmachine> antihoax: round
07:59:41 <benmachine> :t round
07:59:41 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:59:59 <antihoax> ohh thanks :)
08:00:06 <Draconx> > round (1/0) :: Integer
08:00:06 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:00:10 <antihoax> hahaha
08:00:12 <antihoax> 1/0
08:00:40 <Draconx> apparently 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216 is the closest integer to positive infinity.
08:00:46 <antihoax> cool
08:00:55 * hackagebot seqloc-datafiles 0.2.1.1 - Read and write BED and GTF format genome annotations  http://hackage.haskell.org/package/seqloc-datafiles-0.2.1.1 (NicholasIngolia)
08:01:10 <copumpkin> > 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216 :: Double
08:01:11 <lambdabot>   Infinity
08:01:14 <copumpkin> > 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137215 :: Double
08:01:15 <lambdabot>   Infinity
08:01:48 <antihoax> + and - infinity ?
08:02:20 <antihoax> howcome they are unequal? ;/
08:02:25 <antihoax> there is an error in the matrix
08:02:41 <[1]confab> neo?
08:02:45 <antihoax> :)
08:02:47 <[1]confab> or smith
08:03:15 <antihoax> neo just found the error hes not the error
08:03:38 <[1]confab> smith was right?
08:04:35 <RaptorRarr> antihoax: Regarding your question, what are you needing this table for?
08:05:10 <antihoax> ghc-7.0.3 is 857MB without the cabals
08:05:29 <antihoax> RaptorRarr<< to store xy values for pixels in array
08:05:55 <antihoax> floating point values need rasterization before display
08:06:44 <RarrRaptor> Ahh.
08:10:54 * hackagebot samtools 0.2.0.1 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.2.0.1 (NicholasIngolia)
08:11:05 <cheater> how do i make an Int from an Integer?
08:11:27 <rostayob> cheater: fromInteger
08:11:30 <rostayob> :t fromInteger
08:11:30 <lambdabot> forall a. (Num a) => Integer -> a
08:11:49 <cheater> thanks
08:11:51 <rostayob> in general, fromIntegral is the number converter
08:11:53 <rostayob> :t fromIntegral
08:11:54 <lambdabot> forall a b. (Integral a, Num b) => a -> b
08:13:04 <shirt> > show (if True then 5 else "foo")
08:13:04 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
08:13:05 <lambdabot>    arising from the literal ...
08:13:14 <shirt> what extension do i need to use to make that work?
08:13:33 <antihoax> the library
08:13:38 <RarrRaptor> Bah.
08:13:45 <ClaudiusMaximus> any nice ways to manage lazy data flow in IO code?  like only performing actions when their input has changed
08:13:52 <RarrRaptor> Sorry, were those random or sequential or what floats?
08:13:57 <azaq23> shirt: this doesn't typecheck, there's no extension - though you can do show 5, I guess that's what you want
08:13:57 <rostayob> shirt: that's immmmppppossible
08:14:02 <rostayob> unless
08:14:21 <rostayob> you use rank-n types or existential types or whatever
08:14:31 <RarrRaptor> Can't you use existential types or something for that?
08:14:57 <ddarius> rostayob: It's not impossible, but GHC doesn't do it, though you could do something like it with GADTs.
08:16:01 <rostayob> ddarius: can't you say 'strange :: forall a. Show a => a = if True then 5 else "foo"'?
08:17:16 <rostayob> yes you can
08:17:32 <rostayob> shirt: you can use rank-n types
08:17:46 <rostayob> ah no
08:17:48 <rostayob> mhm...
08:19:19 <dolio> Something like that type would only work if the quantification were existential.
08:20:08 <hpaste_> shirt pasted “rostayob” at http://hpaste.org/52010
08:20:12 <rostayob> shirt: you can get close: http://hpaste.org/52010
08:20:34 <rostayob> or you could wrap your existentially qualified value in an existential type
08:20:41 <rostayob> shirt: anyway you can hack your way around that problem
08:21:44 <cheater> what's the maximum that an Int can hold?
08:21:54 <rostayob> > maxBound :: Int
08:21:54 <lambdabot>   9223372036854775807
08:22:38 <zygoloid> there's no maximum that an Int can hold, in theory :)
08:22:48 <RarrRaptor> It varies based on 32/64 bit
08:22:48 <RarrRaptor> Use Int32, Int64 for consistency.
08:22:53 <ClaudiusMaximus> (less on 32bit, even less in '98)
08:23:00 <rostayob> > maxBound :: Int32
08:23:01 <lambdabot>   2147483647
08:23:18 <rostayob> cheater: in genral, use maxBound for bounded types
08:23:19 <RarrRaptor> lambdabot's on a 64-bit machine.
08:23:38 <ClaudiusMaximus> > bitSize (0::Int)
08:23:39 <lambdabot>   64
08:23:48 <RarrRaptor> @src bitSize
08:23:49 <lambdabot> Source not found. You untyped fool!
08:23:53 <RarrRaptor> @hoogle bitSize
08:23:54 <lambdabot> Data.Bits bitSize :: Bits a => a -> Int
08:23:58 <ClaudiusMaximus> > bitSize (0::Integer) -- grrr
08:23:58 <RarrRaptor> Ooh!
08:23:59 <lambdabot>   *Exception: Data.Bits.bitSize(Integer)
08:24:04 <rostayob> RarrRaptor: hard to find the source for a class method ehe
08:24:14 <RarrRaptor> Yes :)
08:24:14 <cheater> ClaudiusMaximus: how much is it in '98?
08:24:50 <zygoloid> the Report says that Int is guaranteed to be Bounded, and can contain at least [-2^^29, 2^^29-1]
08:25:05 <cheater> what is ^^?
08:25:09 <ClaudiusMaximus> rationale is pointer tagging?
08:25:11 <rostayob> power
08:25:12 <absence> i have a toy type Coord [a] which i've made an instance of Functor (for mapping over the wrapped array) and Num. abs and signum are easily implemented using fmap (i.e. abs = fmap abs), but the binary functions are more messy. "Coord a - Coord b = Coord (zipWith (-) a b)" works, but can it be made more concise?
08:25:14 <zygoloid> > n^^5
08:25:15 <lambdabot>   n * n * (n * n) * n
08:25:31 <ion> > n^^(-3)
08:25:32 <lambdabot>   recip (n * n * n)
08:25:35 <ion> > n^(-3)
08:25:36 <lambdabot>   *Exception: Negative exponent
08:25:53 <benmachine> absence: you don't have to specify (-) if you specify (+) and negate
08:25:59 <rostayob> :t (^^)
08:25:59 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
08:26:04 <rostayob> :t (^)
08:26:04 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
08:26:11 <cheater> ok thx
08:26:32 <rostayob> since haskell is well typed working with different representations of numbers can be a bit verbose
08:26:36 <absence> benmachine: that's true, but i still have the exact same problem for (+) and (*)
08:26:44 <benmachine> absence: alternatively, you could define pointWise :: (a -> b -> c) -> Coord a -> Coord b -> Coord c
08:26:53 <benmachine> and then (+) = pointWise (+)
08:26:54 <benmachine> etc.
08:27:36 <absence> benmachine: there's no way to make it fit using fmap i suppose?
08:27:43 <ClaudiusMaximus> pointWise op = Coord $ zipWith op `on` unCoord  -- would this make sense?
08:28:10 <benmachine> absence: actually there kind of is if you specify an Applicative instance as well
08:28:20 <ClaudiusMaximus> ah, that restricts the type too much..
08:28:36 <benmachine> ClaudiusMaximus: well, in general it does, but it doesn't restrict it too much for (+) and (*)
08:28:37 <ClaudiusMaximus> and i probably got it wrong
08:28:52 <benmachine> ClaudiusMaximus: I suspect your fixity might be a bit fishy, because `on` has fixity zero
08:28:53 <ClaudiusMaximus> not $ but some .:.:.:.
08:28:56 <benmachine> but it might work
08:28:58 <absence> benmachine: i was thinking about that, but got stuck with <*>
08:29:11 <benmachine> absence: stuck in what sense
08:29:40 <ClaudiusMaximus> @src ZipList (<*>)
08:29:40 <lambdabot> Source not found. Wrong!  You cheating scum!
08:29:52 <KirinDave> Dang, lambdabot
08:29:57 <KirinDave> You went all crazy on the man.
08:30:30 <absence> benmachine: that i don't fully understand it yet, and couldn't figure it out by looking at the Maybe implementation
08:30:48 <benmachine> absence: oh right, learn!
08:30:51 <benmachine> :)
08:31:21 <KirinDave> Are we talking about how awesome the applicative instances for Maybe and Either are?
08:32:27 <absence> benmachine: the Maybe implementation has a function wrapped in Maybe as the first parameter, and it sounds a bit strange to wrap a function inside my Coord type :)
08:32:41 <absence> of <*> that is
08:32:43 <benmachine> absence: it's not that strange!
08:33:10 <benmachine> vectors of functions are totally a thing that's allowed
08:33:46 <benmachine> absence: if you get it right, then you'll be able to define (+) = liftA2 (+)
08:35:09 <absence> benmachine: yes, that's about what i want :)
08:35:20 <ClaudiusMaximus> is FRP things like reallocating buffers when window size changes, regenerating mipmaps when new details are drawn, recalculating visible things when viewport changes - some of which kind of thing i do every frame so far, which is clearly suboptimal :/
08:35:31 <ClaudiusMaximus> ?
08:39:14 <ddarius> You could use FRP for those things, but those aren't what FRP is.
08:40:21 <ClaudiusMaximus> ok
08:41:20 <shirt> rostayob: cool thanks!
08:41:22 <ClaudiusMaximus> i'm wondering how to restructure my program without having to spend days fixing bugs each time i look at it :( too much mutable state
08:41:45 <mauke> I misread cojones as cojoins
08:44:51 <absence> benmachine: awesome, "Coord f <*> Coord x = Coord $ zipWith ($) f x" does the trick. are there better ways to express that?
08:45:14 <benmachine> absence: no, not really. btw what did you give for pure?
08:45:55 <RarrRaptor> absence: Would zipWith id work?
08:46:24 <benmachine> RarrRaptor: yes
08:46:27 <benmachine> ($) = id
08:46:30 <benmachine> with a different type
08:46:36 <absence> benmachine: undefined :D probably not a long-term good idea
08:46:52 <benmachine> absence: not a good short term idea, depending on how liftAn is implemented
08:47:09 <RarrRaptor> I personally like: Coord (zipWith id f x)
08:47:15 <jmcarthur> absence: for variable length lists, that is not going to form a valid applicative
08:47:20 <rostayob> shirt: np
08:47:28 <RarrRaptor> Or Coord (zipWith id fs xs)
08:47:29 <jmcarthur> absence: if the lists are fixed-length or infinite, it works
08:47:29 <benmachine> jmcarthur: what, pure = undefined? I'd say not :P
08:47:37 <absence> RarrRaptor: id is nice, thanks
08:47:39 <jmcarthur> benmachine: no, i mean that definition of (<*>)
08:47:44 <RarrRaptor> You're welcome.
08:47:45 <benmachine> jmcarthur: sure it does
08:47:47 <jmcarthur> benmachine: there is no pure for which that is a valid applicative
08:47:53 <benmachine> jmcarthur: cf. ZipList
08:48:00 <jmcarthur> oh
08:48:02 <jmcarthur> i'm thinkign monad
08:48:05 <jmcarthur> *thinking
08:48:07 <benmachine> yeah, you can't monad it
08:48:09 <jmcarthur> dur
08:48:13 <benmachine> but I don't think you'd want to anyway
08:48:23 <jmcarthur> the monad requires diagonalization
08:48:23 <benmachine> given what I guess Coord means
08:48:26 <benmachine> right
08:48:48 <benmachine> absence: the upshot is you've got to define pure f such that pure f <*> x = fmap f x
08:48:50 <KirinDave> Isn't there a weaker version of the idea in Applicative, Applyable, in which there is no pure?
08:48:55 <KirinDave> I think I saw that in a library.
08:48:57 <benmachine> KirinDave: yes
08:49:03 <jmcarthur> Apply
08:49:20 <jmcarthur> some people also go for a Pointed class which is just pure
08:49:35 <benmachine> http://hackage.haskell.org/packages/archive/semigroupoids/1.2.6/doc/html/Data-Functor-Apply.html
08:49:56 <absence> benmachine: so i guess pure x = Coord [x]?
08:50:00 * monochrom renames Applicative to Appointed - Apply and Pointed!
08:50:12 <jmcarthur> absence: no that won't work
08:50:24 <absence> ah no
08:50:25 <absence> ziplist
08:50:36 <absence> zipwith i mean
08:50:40 <jmcarthur> > zipWith id [succ] [1,2,3,4]
08:50:41 <lambdabot>   [2]
08:50:46 <jmcarthur> > fmap succ [1,2,3,4]
08:50:47 <lambdabot>   [2,3,4,5]
08:51:21 <jmcarthur> > getZipList $ pure succ <*> ZipList [1,2,3,4]
08:51:22 <lambdabot>   [2,3,4,5]
08:51:30 <KirinDave> Oh wow
08:51:33 <KirinDave> $>
08:51:35 <KirinDave> That's useful
08:51:38 <jmcarthur> yes
08:51:57 <benmachine> I use <$ a lot, don't think I've ever needed $>
08:52:08 <absence> it has to be the same as ziplist right? pure x = Coord (repeat x)
08:52:14 <jmcarthur> yeah
08:52:50 <ion> There’s a ($>)?
08:52:55 <jmcarthur> i'm a little confused about making a Coord Applicative, really
08:53:01 <jmcarthur> based on the name
08:53:18 <absence> maybe it would make more sense for Coord to be Coord (ZipList a) rather than Coord [a]
08:53:25 <jmcarthur> yes
08:54:00 <jmcarthur> where i'm confused is where you would use the applicative instance apart from simply lifting numeric operations (which you could just lift by making type class instances anyway)
08:54:37 <absence> how do you lift them using type class instances?
08:54:50 <jmcarthur> instance Num a => Num (Coord a)
08:54:53 <jmcarthur> etc.
08:55:02 <benmachine> jmcarthur: well, his original question was asking about neat ways to lift things
08:55:06 <jmcarthur> ah
08:55:16 <benmachine> so I thought, liftA2
08:55:22 <jmcarthur> well you could certainly use ZipList in the implementation to make writing that instance less painful
08:55:25 <absence> yes.. (+) = liftA2 (+) is a lot nicer than the non-applicative alternative
08:56:11 <absence> i'll try that, it makes more sense anyway
09:02:21 <benmachine> hmm, is it a free theorem that (f <$> (a <|> b)) = (f <$> a) <|> (f <$> b)?
09:02:58 <benmachine> or, if not a free theorem, does it follow from the properties of fmap and the parametricity of <|>|
09:03:01 <benmachine> *<|>
09:05:14 <absence> since ZipList doesn't derive stuff like Eq or Show, do i have to implement them manually, or is there a way around it?
09:05:38 <benmachine> absence: there's a GHC extension that lets you do so, but I think the idea is that you just getZipList and then use that
09:06:05 <mauke> (that sucks)
09:06:14 <benmachine> (agreed)
09:06:24 <mauke> deriving instance is probably the way to go
09:09:59 <Saizan> benmachine: if we assume (<$>) is really the action on morphisms of the functor then it's pretty much the naturality condition for (<|>)
09:10:39 <benmachine> Saizan: so, yes?
09:11:29 <Saizan> benmachine: yep
09:11:33 <benmachine> k :P
09:12:44 <absence> benmachine: hm.. what's that extension called?
09:13:05 <benmachine> absence: StandaloneDeriving
09:13:25 <benmachine> absence: it lets you write 'deriving instance Show a => Show (ZipList a)'
09:13:32 <benmachine> anywhere in your program
09:15:55 * hackagebot hledger-lib 0.16 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.16 (SimonMichael)
09:15:57 * hackagebot hledger 0.16 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.16 (SimonMichael)
09:15:59 * hackagebot hledger-web 0.16 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.16 (SimonMichael)
09:16:01 * hackagebot hledger-vty 0.16 - A curses-style console interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-vty-0.16 (SimonMichael)
09:16:14 <RarrRaptor> hackagebot: Flooder
09:20:37 <alpounet> no, simon is
09:21:03 * hackagebot hledger-chart 0.16 - A pie chart image generator for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-chart-0.16 (SimonMichael)
09:21:41 <antilect> Who put the HELL in haskell?
09:21:44 <antilect> :D
09:22:25 <absence> benmachine: how do i specify both Eq and Show in the deriving instance expression?
09:22:32 <benmachine> absence: you write two
09:23:14 <absence> benmachine: if i do that, it complains about duplicate instance declarations
09:23:25 <benmachine> you write two, with different heads
09:23:37 <roconnor> sm: congratz on a new hledger release
09:24:49 <absence> benmachine: sorry, my bad. forgot to remove the instance i implemented first :P
09:24:57 <benmachine> :P
09:33:18 <monochrom> kashell? :)
09:33:55 <monochrom> "kashell is a mod of haskell. in kashell, keywords become heywords, and handles become kandles" :)
09:36:02 <antihoax> cheater<< it was 16 bit ;>
09:36:27 <antihoax> no EAX
09:36:56 <cheater> antihoax: ? :)
09:37:06 <antihoax> 286 386 486 computers...
09:37:26 <antihoax> old dos used 16 bit mode
09:37:26 <ddarius> Freakin' vim interpreted my numbers as octal.
09:37:39 <antihoax> and windows 3.1
09:40:38 <cheater> antihoax: why are you telling me? :)
09:40:45 <antihoax> you asked
09:40:49 <cheater> when?
09:41:05 <antihoax> was reading back
09:41:13 <cheater> can you paste in the line?
09:41:20 <antihoax> you were asking what was int size before 32 bit
09:42:06 <cheater> have i? :)
09:42:13 <cheater> i think i haven't but thanks for the info :)
09:42:21 <cheater> maybe we're both confused :)
09:48:15 <absence> hm, if i wrap a ZipList using newtype, it seems i have to construct them by writing Coord (ZipList someList) rather than just Coords someList. is there some way around that?
09:49:15 <benmachine> absence: I think it was a bad idea to wrap a ZipList in the first place :P you could always define a function coords = Coords . ZipList
10:03:43 <absence> benmachine: ah right. hm, you mean it's better to just wrap a regular list? seems i can't derive Functor or Applicative without further language extensions anyway, so there may not be as much benefit as i first thought
10:03:55 <benmachine> mm
10:05:50 <absence> well, all this has been quite an interesting learning experience :) i think i'll revert to wrapping [] and call it a day. thanks for all the help!
10:06:31 <byorgey> absence: it depends which Applicative instance you want.
10:07:04 <byorgey> > (+) <$> [1,2,3] <*> [10,100,1000]
10:07:05 <lambdabot>   [11,101,1001,12,102,1002,13,103,1003]
10:07:24 <byorgey> > getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [10,100,1000]
10:07:24 <lambdabot>   [11,102,1003]
10:09:30 <absence> byorgey: wrapping the Num implementation results in about as much code as reimplementing it, so i can get the ziplist variant with a regular list
10:10:24 <donri> anyone used text.xml.monad and care to give a total noob some hints to get started? already managed text.xml.light but can't figure out the monad version :(
10:11:14 <byorgey> absence: oh, you're trying to make a Num instance for lists?
10:17:50 <absence> byorgey: yes
10:19:09 <Cale> donri: Can't say that I blame you, this is a weirdly designed library.
10:20:00 <erus`> @hoogle [a] -> [a] -> Int
10:20:01 <lambdabot> Data.Graph.Inductive.Internal.Queue MkQueue :: [a] -> [a] -> Queue a
10:20:01 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
10:20:01 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
10:20:08 <erus`> @hoogle [a] -> [a] -> Integer
10:20:09 <lambdabot> Data.Graph.Inductive.Internal.Queue MkQueue :: [a] -> [a] -> Queue a
10:20:09 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
10:20:09 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
10:20:14 <Cale> It defines a monad and monad transformer, and then proceeds to use it in basically none of the types of any of its definitions.
10:20:43 <Cale> (though I guess with appropriate type parameters it satisfies the typeclass constraints :P)
10:21:13 <Cale> newtype XmlT e s m a = XmlT { fromXmlT :: ErrorT e (ReaderT s m) a }
10:21:13 <Cale>     deriving (Functor, Monad, Applicative, MonadPlus, Alternative)
10:21:52 <Cale> ^^ why is that necessary, and what the heck does it have to do with XML? (Answer: it doesn't have anything to do with XML)
10:22:55 <cheater> :t >>=
10:22:56 <lambdabot> parse error on input `>>='
10:23:04 <Cale> :t (>>=)
10:23:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:23:11 <cheater> thanks cale
10:23:29 <RaptorRarr> Cale: You're enabling him to continue cheating.
10:23:58 <donri> Cale: tldr i should just avoid it all together? :)
10:24:35 <Cale> donri: I dunno. I probably would. It looks like it contains a bunch of stuff that other libraries already do more sanely.
10:24:55 <donri> what do you recommend for xml?
10:25:18 <donri> hxt looks a little over-designed for my needs, but i might be missing something
10:26:28 <Cale> Honestly, XML itself seems a little over-designed for anyone's needs. ;)
10:26:34 <donri> true :)
10:26:39 <ozataman> When using Data.Vector, if there is an element of the vector that is accessed millions of times, would there be a speed benefit to encapsulating the vector into a datatype and unpacking the frequently used element as a constructor field?
10:27:01 <Cale> But hmm, hexpat-pickle seems kinda nice.
10:27:30 <Cale> I haven't really used it much myself.
10:28:31 <donri> ah yea that looks like a simpler variant of hxt, thanks
10:34:12 <ddarius> Cale: We should go back to SGML.
10:39:10 <xivix> is Word a type alias for Word8 in Data.Word?
10:39:45 <doserj> > maxBound::Word
10:39:46 <lambdabot>   18446744073709551615
10:39:55 <doserj> > maxBound::Word8
10:39:56 <lambdabot>   255
10:39:59 <xivix> then it's a system word
10:40:00 <xivix> 64
10:40:01 <xivix> cool
10:40:02 <doserj> yes
10:40:15 <doserj> 32 or 64 bit
10:41:29 <xivix> what if it's compiled for a 16-bit machine?
10:41:31 <xivix> :P
10:50:17 <rostayob> why isnt' there a '(a -> c) -> Either a b -> Either c b'?
10:52:30 <ddarius> :t \f -> f +++ id
10:52:31 <lambdabot> forall b c b'. (b -> c) -> Either b b' -> Either c b'
10:52:40 <ddarius> :t (+++id)
10:52:41 <lambdabot> forall b c b'. (b -> c) -> Either b b' -> Either c b'
10:53:29 <rostayob> ah, right.
10:53:31 <rostayob> ddarius: thanks
10:53:48 <dmwit> :t \f -> bimap f id
10:53:49 <lambdabot> Not in scope: `bimap'
10:53:58 <dmwit> =3
10:54:07 <rostayob> but then my code will be too terse :(
10:55:56 <zzo38> What is your opinion about the specifications I wrote for the experimental Cabal fields called X-Printout-Mode, X-Printout-Main, X-Printout-Others, and X-Printout-Require? If is something wrong, you can suggest the thing I could changed
10:56:04 <rostayob> getSize bs xn = id +++ (, BS.drop (sizeOf (undefined :: Int32)) bs) $ runGet' bs xn
10:56:17 <rostayob> i mean i'm not sure i'll be able to read those things in 2 hrs.
10:57:50 <dmwit> Oh, if you wanted (id +++), why not just use fmap?
10:58:19 <rostayob> dmwit: yes right, id +++ is fmap
10:58:38 <rostayob> but i needed it here:  (const (xn, bs)) +++ id $ runGet get bs
10:58:43 <dmwit> true, true
10:58:44 <wavewave> hi.
10:58:52 <dmwit> So then the symmetry is nice.
10:59:00 <rostayob> ehe
10:59:10 <rostayob> but jokes aside
10:59:17 <rostayob> in haskell, too much can happen in one line
10:59:48 <dmwit> Why not name a few subsidiary functions?
10:59:58 <dmwit> drop32 = drop (sizeOf (undefined :: Int32))
11:00:03 <dmwit> for example
11:00:08 <wavewave> in principle, everything can be in 'one line' in functional program.
11:00:18 <rostayob> dmwit: i don't think i'll ever use that again
11:00:29 <rostayob> wavewave: yeah but in haskell you actually write those lines without thinking
11:00:31 <dmwit> rostayob: You were just complaining about readability.
11:00:38 <dmwit> One way to improve readability is to name subexpressions.
11:00:47 <kqr> is there any simple way of having optional parameters in haskell, or is the preferred way to have a helping function with a different type signature, which only calls the real function, but with the default arguments attached?
11:00:54 <rostayob> dmwit: yes but the thing is that haskell gives you the possibility of doing those things. you need self control
11:01:14 <dmwit> It is possible to write unreadable code in *any* language, rostayob.
11:01:47 <rostayob> dmwit: in haskell i find myself writing those line without noticing. it's not a complaint, it's just a statement about the power of haskell :P
11:01:47 <dmwit> kqr: One common pattern is to use a record with defaults for the optional parameters.
11:01:58 <dmwit> kqr: This gives both optional and named parameters at once. =)
11:02:06 <wavewave> rostayob: I think that writing a short code always makes better readability eventually.
11:02:42 <kqr> dmwit, hm, that sounds a little overkill for my purposes. i might look into it once i really need it
11:03:12 <kqr> can you even have two functions of the same name but with different types in haskell?
11:03:23 <zzo38> How have experimental Cabal fields been used previously (and now)?
11:03:33 <kqr> apparently not
11:03:33 <zzo38> kqr: You can have classes
11:03:42 <rostayob> kpal: just use a Maybe type
11:03:45 <dmwit> kqr: http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/
11:03:49 <rostayob> sorry, kqr
11:03:51 <wavewave> kqr:: use typeclass ?
11:03:59 <dmwit> kqr: grep for FooOptions and read the code snippet, that's all you need to understand
11:04:10 <kqr> dmwit, i will
11:04:20 <kqr> dmwit, but i feel compelled to read the whole article
11:04:23 <dmwit> kqr: And yes, the way to have two functions with the same name but different types is either via modules (in which case they really have different (qualified) names) or typeclasses.
11:04:28 <rostayob> kqr: if you need just one optional paramenter, with no default, you can use a Maybe type
11:04:41 <kqr> rostayob, that sounds interesting
11:04:57 <rostayob> well you can have an hard coded default
11:05:01 <rostayob> you get what i mean
11:05:08 <kqr> rostayob, but it would still require me to call the function with "Nothing" in the place of the optional parameter?
11:05:11 <rostayob> (which is what you want i think)
11:05:13 <rostayob> kqr: yes
11:05:23 <kqr> i'd like to avoid that
11:05:33 <dmwit> If your default value happens to make sense as a default value for that type globally across your entire codebase, you might get some mileage out of
11:05:36 <dmwit> ?hackage data-default
11:05:36 <lambdabot> http://hackage.haskell.org/package/data-default
11:05:46 <rostayob> kqr: why?
11:05:56 <dmwit> e.g. if it's an Int, and the default would be 0
11:06:19 <dmwit> Or if it's a list, and the default would be []
11:06:49 <kqr> rostayob, in this particular example, the function takes two arguments
11:06:58 <kqr> rostayob, on the first call, they both should be set to the same thing
11:07:01 <dmwit> "foo def x" is not much worse than "fooDef x"
11:07:40 <kqr> rostayob, and from an interface point of view, the call really should be "f x", and the caller should not have to care about the implementation
11:07:58 <kqr> rostayob, either "f x x" or "f x Nothing" is implementation dependent and not at all declarative
11:08:09 <rostayob> kqr: well you can't have variadic functions in haskell, it's a small price for a nice type system
11:08:25 <dmwit> posh
11:08:31 <dmwit> You can very well have variadic functions.
11:08:36 <rostayob> ok, don't link oleg now...
11:08:44 <rostayob> that'd make things worse ehe
11:09:01 <dmwit> class Foo a where foo :: a; instance Foo (Int -> Bool) where foo = even; instance Foo (Int -> Int -> Bool) where foo x y = even (x + y)
11:09:07 <dmwit> No Oleg.
11:09:09 <dmwit> Just plain type classes.
11:09:15 <dmwit> (That's what they're for!)
11:09:31 <zzo38> You can write a function that does that if you want to have, such as    f' = join f   if you want to write "f' x" instead of "f x x"
11:10:09 <rostayob> dmwit: well if you throw polymorphism and typeclasses in the mix you can but it's not the same really
11:10:11 <rostayob> and it's not that nice
11:10:15 <rostayob> i mean i wouldn't do it
11:10:41 <hpaste_> wavewave pasted “Default parameter” at http://hpaste.org/52013
11:10:59 <wavewave> hmm.. dmwit already gave that solution...
11:11:04 <dmwit> =)
11:11:12 <rostayob> yes ofc you can define something like that, but it's not nice
11:11:28 <rostayob> he's worrying about the user calling the functions without worrying
11:11:43 <rostayob> i don't think that type annotating every argument is a better solution than a record, or a Maybe
11:11:51 <wavewave> kqr: but this method is not very good..
11:11:54 <dmwit> I agree.
11:11:57 <wavewave> rostayob: I agree.
11:11:59 <rostayob> actually you could make it better with fundeps :P
11:12:00 <dmwit> I think a record is the right thing.
11:12:02 <rostayob> but whatever
11:12:05 <dmwit> That's why I suggested it first. =)
11:12:15 <wavewave> dmwit: I also think so.
11:12:32 <dmwit> wavewave++ for thinking like me =)
11:12:50 <wavewave> I had encountered the same problem when I am translating c++ library
11:13:01 <wavewave> which has lots of default parameters.
11:13:34 <pdhborges> hi! is ghc able to inline funtion arguments?
11:13:49 <wavewave> dmwit: thnx!
11:14:34 <dmwit> Hm, inline function *arguments*?
11:14:50 <dmwit> Usually inlining goes the other way -- replacing a function call by its definition.
11:15:11 <wavewave> @wavewave
11:15:11 <lambdabot> Unknown command, try @list
11:15:17 <hpc> sometimes it does beta reduction
11:15:17 <dmwit> GHC is of course capable and smart about doing the latter.
11:15:20 <dmwit> ?karma wavewave
11:15:21 <lambdabot> wavewave has a karma of 1
11:15:29 <wavewave> poor me.
11:15:29 <pdhborges> yes, for example "foldl (++) "" <list>"
11:15:29 <monochrom> replacing "const (3+4) (5/6)" by "(3+4)", yes
11:15:39 <hpc> which i suppose would be kind of like inlining function arguments
11:15:47 <pdhborges> (++) who'd be inlined inside the fold
11:16:10 <monochrom> eh? if you don't inline the foldl first, there is nothing else to inline
11:16:32 <pdhborges> ah! okay
11:16:46 <dmwit> monochrom: Maybe he wants to transform that to foldl (\x y -> {- definition of ++ here -}) "" <list>
11:16:50 <dmwit> ?
11:17:00 <wavewave> maybe he is asking conditional inline?
11:17:13 <dmwit> Yeah, anyway, your question isn't quite precise enough to answer yet.
11:17:19 <wavewave> not inline (++) in general, but inline it in fold?
11:17:35 <pdhborges> yeah I the question wash;t very good
11:18:47 <wavewave> pdhborges: if (++) is inlined in its own definition, it's always inlined.. indep of whether it's in fold or other function.
11:19:45 <zzo38> What do you know of experimental fields in Cabal files?
11:20:05 <dmwit> zzo38: For this kind of thing, I would expect a mailing list to be a better medium.
11:20:26 <dmwit> Have you considered writing to haskell-cafe?
11:21:26 <wavewave> I had no experience to write to a haskell-cafe yet. Still some psychological barrier to me.
11:21:38 <pdhborges> wavewave: in my head it would be very tricky to inline a function argument
11:21:49 <pdhborges> inside a recursive function
11:21:50 <pdhborges> for example
11:22:31 <zzo38> What is a haskell-cafe?
11:22:54 <dmwit> http://haskell.org/haskellwiki/Mailing_lists
11:23:53 <zzo38> I don't have email
11:24:13 <wavewave> pdhborges: http://www.haskell.org/pipermail/glasgow-haskell-users/2011-June/020468.html
11:25:07 <pdhborges> thanks wavewave
11:25:13 <monochrom> suppose you write code "f (\x -> blah x blah)". the machine code generated by GHC represents that code by a call to f with actual argument as a pointer to a piece of code for \x -> blah x blah
11:25:16 <dmwit> You don't have email?
11:25:34 <wavewave> it seems that recursive function cannot be inlined.
11:25:51 <zzo38> Yes, I don't have email
11:25:59 <monochrom> now suppose you write code "f g" and define "g x = blah x blah" elsewhere. the machine code generated by GHC represents "f g" by a call to f with actual argument as a pointer to a piece of code for \x -> blah x blah
11:26:02 <dmwit> How did you find an ISP that doesn't give you an email address? O_o
11:26:13 <dmwit> Never mind.
11:26:32 <monochrom> in other words whether you inline g yourself or not, you get the exact same code
11:26:48 <zzo38> They do give me an email address but now the mailbox is full of spam message so I never use it. If anyone send more message to there, it will be rejected due to full mailbox.
11:26:51 <monochrom> (throughout I assume f is not inlined, of course)
11:26:52 <dmwit> I suppose you also don't want to open a free email account, for whatever reason.
11:26:59 <zzo38> I do have a UNIX mail at FreeGeek Vancouver.
11:27:04 <mm_freak> are storable vectors (Data.Vector.Storable) unboxed?
11:27:09 <zzo38> But it currently doesn't work anyways.
11:27:30 <pdhborges> monochrom: but imagine f defined as a recursive function taking g as another function
11:27:38 <wavewave> pdhborges: I am not sure what's going on inside ghc.. I need to read carefully the thread linked above.
11:28:04 <monochrom> the way GHC generates code, I don't actually see what "inline the argument" means. if you have another execution model in which it is meaningful and makes a difference in representation, tell me
11:28:44 <pdhborges> ghc could specialize f for g eliminating the inner calls
11:28:47 <monochrom> nevermind how f is defined. I am talking about the *application* "f g" without f inlined.
11:29:09 <monochrom> if you inline f, then it depends.
11:29:13 <elliott> It sounds like pdhborges is talking about specialisation.
11:29:20 <pdhborges> yes
11:29:37 <elliott> Which is much much harder than pdhborges probably thinks it is. :)
11:29:57 <monochrom> well you have to inline f first to see any further opportunities for other inlines
11:30:31 <monochrom> my point is "inline the argument" is meaningless without "inline the function"
11:30:34 <dmwit> zzo38: I suppose another option, if you absolutely won't open a gmail account, would be to write up your ideas on a web page and post it to haskell.reddit.com or something like that.
11:30:43 <pdhborges> monochrom: no
11:30:49 <elliott> Does reddit require an email address to sign up nowadays?
11:30:50 <pdhborges> you could generate another function
11:30:56 <elliott> pdhborges: that would be inlining
11:30:57 <pdhborges> and not inline it on the call sites
11:31:10 <elliott> well... inlining and then uninlining :P
11:31:11 <monochrom> and with "inline the function", "inline the argument" is also meaningless because it becomes "inline the function" again for another function.
11:31:13 <dmwit> elliott: nope
11:31:36 <pdhborges> ok thanks!
11:31:38 <wavewave> zzo38, dmwit: or Stack Overflow
11:31:54 <elliott> Isn't Stack Overflow for questions?
11:32:04 <monochrom> suppose f is defined as: f h = (h 0, h 1). and you use it with "f g".
11:32:26 <monochrom> you inline the function, get (g 0, g 1).
11:32:29 <antihoax> heyh
11:32:41 <monochrom> then you inline functions again, get (blah 0 blah, blah 1 blah)
11:32:41 <wavewave> stackoverflow.com
11:32:44 <dmwit> Yeah, SO doesn't seem like the right place for fostering a discussion.
11:32:46 <hpc> monochrom: first you get (\h -> (h 0, h 1)) g
11:33:02 <monochrom> it's all "inline the function" throughout. there is no "inline the argument"
11:33:04 <hpc> (just to list all the steps)
11:33:41 <dmwit> antihoax: back atcha
11:34:04 <antihoax> trying to free up space on hdd
11:35:05 <antihoax> but dont want to do uniqhardlinker.r for everything
11:35:50 <antihoax> things dont break hardlinks before editing ;/
11:36:24 <dmwit> I have no idea what you're saying.
11:36:35 <mm_freak> is it in any way whatsoever possible to have a comonadic store, which uses a Storable-based array/vector under the hood?
11:36:52 <antihoax> dmwit<< you dont have linux?
11:36:57 <mm_freak> i guess not
11:37:08 <elliott> I, too, have no idea what antihoax is talking about.
11:37:08 <zzo38> Can I ask on IRC instead?
11:37:15 <mm_freak> (at least without the new ConstraintKinds extension)
11:37:27 <dmwit> Yes, I have Linux. But I've never heard of uniqhardlinker.r, and I have no idea what editing has to do with linking, hard or soft.
11:37:33 <antihoax> ahm
11:37:36 <antihoax> well i wrote that
11:38:13 <wavewave> zzo38: what was your question?
11:38:56 <dmwit> zzo38: You can, and did, several times. But you didn't get much of a response. I'm suggesting that you'll get a better response elsewhere.
11:39:03 <zzo38> My question is related to experimental fields in Cabal. How often are they used and what ways?
11:39:22 <dmwit> (At any given time, there are only ~15 people active in this channel, whereas over time you will rack up thousands of views in other fora.)
11:40:35 <antihoax> interested in a bash script that generates sha sums of files, then hardlinks ones that have identical content?
11:40:54 <dmwit> No.
11:41:01 <zzo38> Such as, do you have any suggestion/comment/complaint about this specification?   http://sprunge.us/jgfB   (It is plain text file you do not need to load a web-browser, just use curl or wget)
11:41:08 <dmwit> I don't expect it would find many duplicates. Do you find otherwise?
11:41:14 <antihoax> yes
11:41:16 <antihoax> :)
11:41:21 <dmwit> Are the duplicates non-empty?
11:41:27 <antihoax> yep
11:41:43 <mauke> antihoax: how does it deal with hash collisions?
11:41:45 <elliott> antihoax: You could use a deduplicative filesystem of some kind.
11:41:47 <antihoax> like jpg files
11:41:52 <elliott> antihoax: Also, that sounds very dangerous to me.
11:41:55 <elliott> Hardlinking changes semantics subtly.
11:41:58 <antihoax> mauke<< yes
11:42:05 <mauke> antihoax: "yes" doesn't answer "how?"
11:42:07 <elliott> Many editors will mess it up.
11:42:09 <antihoax> it does a compare too if match
11:42:21 <elliott> If you have files A and B hardlinked to the same inode, and edit A, it depends on your editor whether B changes too or not.
11:42:36 <elliott> So I would definitely advise against running such a script, at least on files that will ever be written to, ever.
11:42:43 <antihoax> well this is the reason i dont prefer it on everything ;/
11:42:51 <antihoax> editing doesnt break link
11:43:13 <mauke> antihoax: if you have A, B linked to inode 1 and C, D linked to inode 2, and inodes 1 and 2 have identical contents, what does your script do?
11:43:14 <wavewave> zzo38: are you suggesting some new syntex in cabal file?
11:43:19 <antihoax> though new mcedit asks to break link before saving
11:43:25 <wavewave> s/syntex/syntax
11:43:46 <dmwit> antihoax: So, total, how much space do you calculate you have saved with this script?
11:44:31 <zzo38> wavewave: Actually it is experimental fields. Cabal already accepts and ignores them.
11:44:43 <antihoax> well i have done a few web mirrors and much
11:45:20 <wavewave> zzo38: ah. I see.. I think they are rarely used..
11:45:31 <antihoax> images are often repeated
11:46:00 <antihoax> and if you have a photo album you may have multiple copies of an image in seperate dirs...
11:46:31 <antihoax> or archives on your hdd that are same
11:46:39 <zzo38> Well, the one I made up is specification of a way to use them for preparing printouts of literate programming, it can be processed by separate programs that still access the same Cabal package.
11:47:06 <wavewave> zzo38: if you need those option, then you really need to post it either on haskell-cafe or cabal-devel
11:47:11 <monochrom> well last night someone asked for haskell projects, and one suggestion said to find duplicate files and hardlinkize them. so the point is haskell exercise rather than what benefits or traps it brings you
11:47:55 <antihoax> mauke<< it does not care about inodes, generates shasum of every file, then sorts, and unlinks duplicate enrties, relinks with name.
11:48:09 <zzo38> wavewave: It is not important to haskell-cafe or cabal-devel. The cabal programmers do not need to do anything about it. The Cabal API already support it. What I ask, is, to improve what I have in that document.
11:48:09 <monochrom> although, there is an implicit "the project should lead to a useful program" and you could argue how useful this scheme is
11:48:32 <mauke> antihoax: that doesn't answer my question
11:48:32 <zzo38> Some sections I did not write, but if you know about those things you can help too
11:48:46 <mauke> antihoax: what will the results look like?
11:48:52 <zzo38> Or, if you find anything you think is wrong and could be made differently, you can tell me I might correct it
11:49:28 <antihoax> del inode 2 and relink all files to inode 1
11:49:42 <mauke> you can't delete inodes
11:49:45 <mauke> you can't link to inodes
11:50:17 <wavewave> zzo38: the discussion like that is  why there are webpages like haskell-cafe and reddit exist. Here, it is very easy to be forgotten in oblivion.
11:50:23 <antihoax> well i have been using it for years
11:50:28 <antihoax> and it works
11:50:47 <mauke> but you can't tell me what it does
11:51:04 <antihoax> i can link the source on http if you want to debug
11:51:12 <zzo38> I would rather not load the web-browser for everything, and I have no accounts on those webpages.
11:51:25 <mauke> no, I already have a script to find duplicates
11:51:27 <antihoax> ok then wget
11:51:28 <elliott> haskell-cafe is not a webpage
11:51:57 <zzo38> Then why did you say it is?
11:51:59 <mauke> I was just interested how you deal with edge cases I've found
11:52:18 <antihoax> http://z-labor.com/tmp/scripts/uniqhardlinker.r
11:52:43 <mauke> haha, in bash?!
11:52:53 <antihoax> yes
11:52:54 <mauke> I can almost smell the performance
11:52:58 <zzo38> Anyone using literate Haskell programming could probably help with this specification
11:53:00 <antihoax> its good ;)
11:53:33 <mauke> antihoax: bzzt, overwrites my files
11:53:50 <mauke> antihoax: breaks if filenames contain \n
11:53:52 <antihoax> it deletes them
11:53:58 <antihoax> then creates hardlink
11:53:59 <zzo38> I could write the program that reads these X-Printout- fields by myself. But first I want to correct the specification.
11:54:06 <mauke> antihoax: no, it overwrites sha1sum.txt.1234
11:54:08 <wavewave> zzo38: yeah.. this is open-source. you can also help it by writing some code on it. Or making a good document and persuasive agument.
11:54:13 <antihoax> hahaha
11:54:41 <elliott> zzo38: I didn't say haskell-cafe was a webpage
11:54:46 <antihoax> im sure you store your creditcard numbers in that file
11:55:23 <wavewave> elliott, zzo38: sorry I said haskell-cafe as a webpage.. just a mistake. ;-P
11:55:28 <zzo38> wavewave: I know, that is what I say! I can write the program myself. But first I want to correct the specification, and that is what I ask you to review, and if you know anything about it, to tell me about to correct it
11:55:38 <mauke> antihoax: it ignores all filenames containing /sha1sum?txt?1234 in any directory
11:55:56 <antihoax> eerm
11:56:39 <antihoax> did i miss root part?
11:56:47 <mauke> antihoax: I'm not that far yet but I bet it gives bogus results if the files sha1sum.asd.1234 and sha1sum.uniq already exist
11:57:05 <wavewave> zzo38: sorry that I don't know what the options are. If you do not get much answer from here, then please think that at this moment, people here do not know much about that.
11:57:21 <antihoax> no since it deletes them first
11:57:31 <mauke> antihoax: where?
11:58:07 <antihoax> > "./sha1sum.asd.$$"
11:58:08 <lambdabot>   "./sha1sum.asd.$$"
11:58:08 <zzo38> wavewave: Is there IRC for literate Haskell or for Cabal package? Maybe they know it better.
11:58:13 <antihoax> this means to overwrite
11:58:18 <mauke> antihoax: yes. that doesn't delete them
11:58:25 <antihoax> yes it does
11:58:28 <mauke> antihoax: and it only overwrites them after you've computed their sha1sums
11:58:30 <antihoax> >> means append
11:58:54 <monochrom> I'm pretty sure mauke knows shell scripts and redirections
11:58:55 <mauke> antihoax: so now sha1sum.uniq contains wrong hashes
11:59:05 <antihoax> grep -v './sha1sum.txt.'"$$"
11:59:12 <antihoax> this will not fail
11:59:18 <antihoax> because you cant have / in filenames :P
11:59:22 <mauke> antihoax: it will fail but in a different case
11:59:23 <antihoax> and $ means line end
11:59:31 <mauke> antihoax: your pattern doesn't contain $
11:59:38 <antihoax> and $ means line end can be included
11:59:46 <antihoax> though ...
12:00:00 <antihoax> well yes ;/
12:00:42 <antihoax> didnt think about what if you have files starting with "./sha1sum.txt.$pid"
12:00:52 <mauke> not starting with
12:01:20 <antihoax> files cant have "/" in filename
12:01:21 <wavewave> zzo38: I do not know any.. unfortunately, the best option is still to write an email to the developer.
12:01:26 <mauke> antihoax: it will find any file that matches the glob pattern sha1sum?txt?$pid*
12:01:41 <mauke> antihoax: they do if they include a directory path
12:01:55 <mauke> as is the case here
12:02:39 <zzo38> What developer?
12:04:54 <antihoax> mauke<< change it to grep -v '^\./sha1sum.txt\.'"$$"'$'
12:05:01 <wavewave> zzo38: cabal-devel@haskell.org . refer to cabal webpage. http://www.haskell.org/cabal
12:05:01 <zzo38> I am not asking a question about the developer, anyways. What I ask is in case anyone has opinion about this document, that I wrote, and if you have comment/complaint/question, how to correct it, etc.
12:05:01 <mauke> antihoax: still wrong
12:05:02 <antihoax> if it bothers you
12:05:11 <antihoax> mauke<< change it to grep -v '^\./sha1sum\.txt\.'"$$"'$'
12:05:13 <antihoax> nah
12:05:21 <mauke> slightly better
12:05:32 <mauke> antihoax: still breaks if filenames contain \n
12:05:58 <antihoax> :)
12:06:09 <wavewave> zzo38: that mailing list is not only for question. exactly for comment/complaint/question.. any suggestion will be welcome and actually they may be very welcome to the suggestion like you have.
12:06:27 <antihoax> hm well std linux utils use \n as line end
12:06:40 <mauke> \n is the line end
12:06:47 <antihoax> your shasum file has them too
12:07:13 <antihoax> ah
12:07:58 <mauke> inefficiencies: you spawn one sha1sum process per file
12:08:05 <zzo38> I am not trying to suggest anything to them. I can write a separate program to deal with it, by myself. Are you familiar with any of the things mentioned in the document (such as literate Haskell, Plain TeX, LaTeX, XeTeX, etc)?
12:08:41 <mauke> you don't take advantage of existing hardlinks: all files with the same content will be unlinked and relinked, regardless of whether they're already the same inode
12:09:50 <antihoax> well it was better than nothing
12:10:08 <zzo38> How many people in this channel using literate Haskell anyways?
12:10:10 <mauke> sha1sum.tmp.$$ is completely unnecessary
12:10:16 <limetree> (1,) 2 -- why is this illegal?
12:10:27 <Peaker> limetree: because you've not enabled the TupleSections extension?
12:10:33 <mauke> you only look at its last line anyway
12:10:35 <antihoax> mauke<< i believe the disk read speed will give the limit
12:11:01 <antihoax> 2.2GHz amd64 does 100MB/s sha1sum below 40% cpu usage
12:11:02 <limetree> Peaker: is there a reason it's an extension? it seems perfectly logical
12:11:29 <mauke> antihoax: ah, -type f saves you. otherwise you'd be completely screwed by symlinks
12:11:39 <wavewave> limetree: just missed from haskell98? maybe that's the reason.
12:11:50 <limetree> I mean, (,) 1 2 works fine.
12:11:50 <antihoax> ahah yes
12:12:32 <limetree> so sections is not a general concept?
12:12:50 <mauke> limetree: sections only work on operators
12:12:54 <mauke> , is not an operator
12:12:59 <wavewave> limetree: I think that's because of ,
12:13:03 <antihoax> i wrote this in 2008
12:13:18 <antihoax> in 2009 i ave used -type f in another script
12:13:20 <antihoax> ;/
12:13:21 <wavewave> , should be accompanied with ( )
12:13:26 <antihoax> time to upgrade some
12:13:40 <wavewave> limetree: so lexically different from other operators.
12:13:49 <zzo38> How much do you do literate programming?
12:14:21 <limetree> wavewave: ok, I think I get it
12:14:34 <wavewave> zzo38: I don't do much with literate programming.
12:15:43 <wavewave> limetree: in addition,  ',' is not only binary op. but also arbitrary op with ( )
12:15:57 <zzo38> OK. Do you do much with LaTeX or ConTeXt? If you know of those you still might be able to help me that I can write those parts of the document
12:15:58 <wavewave> (,) (,,) (,,,) , something like that.
12:16:24 <limetree> so it's kind of a special case?
12:16:29 <antihoax> mauke<< i see, add %s to printf in this line fn2="`printf '%s' "$sumline" | cut -c43-`"
12:16:39 <antihoax> this solves the '\' bug
12:17:01 <mauke> antihoax: what \ bug?
12:17:14 <antihoax> "\n" file
12:17:18 <antihoax> for example
12:18:02 <antihoax> ahm but still not ok wait
12:20:32 <hpaste_> wavewave pasted “several examples of tuple sections” at http://hpaste.org/52016
12:20:58 <wavewave> limetree: see the pasted code.
12:22:18 * wavewave is not sure that writing a code using tuple section too much is good or not though 
12:23:51 <limetree> I wanted to do map (x,) list, but I ended up doing map (\y -> (x,y)) list
12:24:35 <wavewave> limetree: so with tuple section, is it done well?
12:24:41 <mauke> map ((,) x)
12:24:56 <wavewave> I mean with TupleSections extension
12:26:10 <limetree> wavewave: what do you mean, "done well"?
12:26:16 <wavewave> hmm. tested. no problem using x in tuple secton with TupleSections extension.
12:26:31 <limetree> your code does what I would expect
12:27:28 <wavewave> limetree: Tuple section itself is fancy, but I hope that the same thing can be done with records.
12:28:11 <Cale> I don't really care about tuple sections or record construction sections, but I would like sections of case.
12:28:29 <Cale> case of ...  should expand to  \fresh -> case fresh of ...
12:28:31 <wavewave> Cale: I agree it very much.
12:28:49 * wavewave is searching now lambdacase. 
12:30:28 <wavewave> lambda-case, lambda-if, record construction section...
12:32:04 <wavewave> http://hackage.haskell.org/trac/ghc/ticket/4359  it seems that we will have it sooner or later.
12:33:39 <mmos1127> How do I convert a Rational to a Float? Is there some kind of "fromFractional" or something?
12:33:50 <wavewave> readToFrac
12:33:54 <monochrom> > realToFrac (1 % 2)
12:33:55 <lambdabot>   0.5
12:34:02 <wavewave> heck..
12:34:04 <wavewave> real..
12:34:08 <monochrom> hehe
12:34:28 <mmos1127> umm, how did lambdabot know you wanted realToFrac (1%2) :: Float?
12:34:47 <mauke> mmos1127: that's not Float, that's Double
12:34:56 <monochrom> default to Double
12:34:57 <parcs> can't you tell the difference?
12:34:57 <wavewave> mmos1127 ?
12:35:00 <parcs> jeeze
12:35:18 <monochrom> > realToFrac (1 % 10000000000)
12:35:19 <lambdabot>   1.0e-10
12:35:19 <mmos1127> i'm curious are there other common instances of Fractional?
12:35:32 <monochrom> > realToFrac (1 % 10000000000) :: Rational
12:35:33 <lambdabot>   1 % 10000000000
12:35:35 <monochrom> :)
12:35:51 <mmos1127> are Float and Double instances of Real?
12:36:12 <monochrom> yes
12:36:20 <mauke> mmos1127: you can ask ghci for that information
12:36:37 <mmos1127> couldn't it be just as sensibly fracToReal as realToFrac (for my purposes)?
12:36:39 <monochrom> yeah, :info Double, :info Real, etc
12:36:58 <mmos1127> I'm just curious, don't quite understand the underlying organization of the classes and functions
12:37:00 <monochrom> well, I don't care about names
12:37:04 <wavewave> fromFractional <=> realToFrac
12:37:30 <wavewave> wait a minute.
12:37:41 <monochrom> the Haskell 2010 Report has the complete organization of the classes and functions
12:37:41 <mauke> mmos1127: fracToReal makes no sense
12:39:22 <wavewave> I was confused with fromRational.
12:39:43 <monochrom> @type fromRational
12:39:44 <lambdabot> forall a. (Fractional a) => Rational -> a
12:39:59 <Cale> :t toRational
12:40:00 <lambdabot> forall a. (Real a) => a -> Rational
12:40:33 <Cale> realToFrac converts from something that can be converted to a Rational number to something which can be converted from a Rational number
12:40:46 <Cale> The Real class is misnamed, imo, but that's what it means
12:41:35 <Cale> So, for example, it's possible to convert Float and Double to Rational, and then convert that Rational to Complex Float or CReal or something
12:41:49 <Cale> (Or indeed, Float or Double)
12:42:26 <Cale> You can't apply realToFrac to complex numbers, because complex numbers don't naturally map to Rationals.
12:44:06 <Cale> It's a bit bewildering at first, but it makes a good deal of sense for the most part.
12:45:03 <wavewave> Cale: I see.. that makes sense.. I was wondering why realToFrac is named like that.
12:45:53 <antihoax> hmm
12:46:14 <antihoax> mauke<< $ sha1sum "./\e\b"
12:46:14 <antihoax> \da39a3ee5e6b4b0d3255bfef95601890afd80709  ./\\e\\b
12:47:14 <ddarius> @index isPrefixOf
12:47:15 <lambdabot> Data.List
12:47:36 <wavewave> haskell number types are somewhat weird.
12:48:29 <wavewave> I didn't pay much attention to it until now.. hmm.
12:50:19 <wavewave> Real, Integral, Fractional, RealFrac, RealFloat ..
12:51:07 <wavewave> Num, Float
12:51:11 <wavewave> Floating.
12:53:14 * hackagebot netwire 1.2.6 - Arrowized FRP implementation  http://hackage.haskell.org/package/netwire-1.2.6 (ErtugrulSoeylemez)
13:07:32 <TotoTitus> good evening (well..at least those on European time)
13:08:13 <TotoTitus> uhh, consider the following code
13:08:27 <TotoTitus> fmap (+) [1..5]
13:08:43 <TotoTitus> what we get is a list of partially applied functions
13:08:48 <companion_cube> yes
13:09:14 <TotoTitus> how do i elegantly supply an argument to each of the functions in the list ?
13:09:17 <TotoTitus> something like
13:09:22 <wavewave> zipWith?
13:09:25 <companion_cube> > fmap (+) [1..5] `fmap` ($ 42)
13:09:26 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
13:09:26 <TotoTitus> mapApply 1 functionList
13:09:42 <wavewave> ah.. the same argument for all?
13:09:45 <TotoTitus> yes
13:09:45 <Saizan> companion_cube: wrong argument order
13:09:46 <shachaf> > sequence [succ,pred,(*2)] 5
13:09:47 <lambdabot>   [6,4,10]
13:09:52 <TotoTitus> the same argument
13:09:53 <shachaf> > map ($ 5) [succ,pred,(*2)]
13:09:53 <companion_cube> Saizan: oops
13:09:54 <lambdabot>   [6,4,10]
13:10:28 <wavewave> :t sequence
13:10:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:10:29 <TotoTitus> i've never seen $ used like that
13:10:37 <elliott> I have
13:11:01 <wavewave> :t ($)
13:11:02 <lambdabot> forall a b. (a -> b) -> a -> b
13:11:37 <companion_cube> > map ($ 42) $ fmap (+) [1..5]
13:11:38 <lambdabot>   [43,44,45,46,47]
13:11:55 <TotoTitus> thanks
13:12:07 <TotoTitus> :t ($ 42)
13:12:08 <lambdabot> forall a b. (Num a) => (a -> b) -> b
13:12:33 <companion_cube> TotoTitus: similar to that
13:12:44 <TotoTitus> it is twirling my brain somewhat
13:12:46 <companion_cube> > map (\f -> f 42) $ map (+) [1..5]
13:12:47 <lambdabot>   [43,44,45,46,47]
13:12:47 <TotoTitus> but i am getting it
13:12:48 <RarrRaptor> $ is like flip, but quicker.
13:12:57 <TotoTitus> i tried to avoid the lambda
13:12:59 <elliott> :t flip 42
13:13:00 <lambdabot> forall (f :: * -> *) a b. (Num (f (a -> b)), Functor f) => a -> f b
13:13:03 <elliott> Beautiful beautiful Caleskell.
13:13:21 <TotoTitus> LYAH said to avoid lambdas if partially applied functions work
13:13:33 <TotoTitus> that's why i needed a cool solution
13:13:34 <elliott> TotoTitus: that's good advice sometimes but not nearly always :)
13:13:41 <companion_cube> TotoTitus: you can start with explicit code and then use point free codfe
13:13:42 <TotoTitus> as in ?
13:13:44 <companion_cube> code*
13:14:08 <napping> If you already have a named function that can be partially applied, it's good advice
13:14:08 <wavewave> TotoTitus: All functions are basically lambda ultimately.
13:14:11 <elliott> TotoTitus:
13:14:16 <companion_cube> like, first write the lambda version, then notice that  \f -> f 42  is  \f -> f $ 42  is ($ 42)
13:14:23 <elliott> ?pl \a b c d -> a >>= (b + c (d a)) / (b/d)
13:14:24 <lambdabot> ap ((.) . (.) . (.) . (>>=)) ((`ap` (/)) . ((flip . (liftM2 (/) .)) .) . flip ((.) . (.) . (+)) . flip (.) . flip id)
13:14:29 <elliott> TotoTitus: which do you prefer?
13:14:57 <napping> If you need to do more than just leave off the last argumnet to get a points-free versions, it's no longer so clear which is better
13:15:17 <wavewave> TotoTitus: although it is a good advice, you do not have to stick to it too stubbornly.
13:15:30 <TotoTitus> yeah, common sense is good
13:16:46 <TotoTitus> wow, these ($) examples were really great, i knew ($) 'delayed' evaluation, but i had not thought of this
13:16:47 <napping> TotoTitus: I'm saying that making this sort of points free definition is no longer just partial application
13:17:04 <companion_cube> ($) just changes associativity
13:17:22 <companion_cube> ie  f x  and  f $ x  are exactly the same
13:17:23 <TotoTitus> uhh, and fixity
13:17:43 <companion_cube> but  f $ x y  is  f (x y) and not  (f x) y
13:17:55 <TotoTitus> the closest thing i can think of
13:18:03 <TotoTitus> uhh..thing..think
13:18:08 <TotoTitus> in other languages
13:18:13 <TotoTitus> is Lisp's apply
13:18:47 <TotoTitus> m
13:18:48 <wavewave> Hm, I am confused whether ($) introduce additional laziness there.
13:18:50 <companion_cube> kind of, yes
13:19:02 <companion_cube> @ TotoTitus
13:19:14 <wavewave> I guess not.
13:19:16 <TotoTitus> (apply #'(lambda(x) (+ x 1)) 1)
13:19:45 <shachaf> $ doesn't have anything to do with laziness.
13:20:17 <companion_cube> TotoTitus: that's because CL has a difference between functions and values, right?
13:20:22 <napping> it won't let you apply a function to a list of arguments either
13:21:19 <wavewave> shachaf: yes. I figured it out now.. I was wondering if evaluation to WHNF makes some difference between f $ x and f x .
13:21:24 <TotoTitus> (mapcar #'(lambda(x) (* x x)) '(1 2 3 4 5)), does this do it ?
13:21:29 <TotoTitus> companion_cube
13:21:38 <companion_cube> i guess the compiler totally removes ($)
13:21:53 <elliott> companion_cube: it couldn't remove ($) in all cases
13:22:00 <companion_cube> TotoTitus: it's map (\x -> x * x) [1..5]
13:22:11 <companion_cube> elliott: not in case of partial application, of course
13:22:22 <elliott> right
13:22:40 <companion_cube> ($ 5) is a proper function, for instannce
13:23:25 <mauke> :t map . join (*)
13:23:26 <lambdabot> forall a b. (Num b) => (a -> b) -> [a] -> [b]
13:23:32 <aristid1> 5 can be a proper function, too
13:23:48 <mauke> > map 5 [1,2,3,4]
13:23:49 <lambdabot>   [5,5,5,5]
13:24:14 <companion_cube> aristid1: you're going to confuse people :)
13:24:18 <companion_cube> (including probably me)
13:24:24 <parcs> > flip 5 . [1,2,3,4]
13:24:25 <lambdabot>   No instance for (GHC.Num.Num (f (a -> b)))
13:24:25 <lambdabot>    arising from a use of `e_1512...
13:24:28 <aristid1> companion_cube: why would it confuse anybody? :)
13:24:46 <shachaf> > map car [1,2,3,4,5]
13:24:48 <lambdabot>   [car,car,car,car,car]
13:24:49 <wavewave> > 5 1
13:24:50 <lambdabot>   5
13:24:52 <parcs> ghc fails at instance resolution
13:24:54 <aristid1> > 5 . [1..5]
13:24:55 <companion_cube> because "5" is a  (Numeral t) => t, right ?
13:24:56 <lambdabot>   [5,5,5,5,5]
13:25:00 <companion_cube> and people expect it to be an Int
13:25:06 <aristid1> companion_cube: (Num t) => t, yes
13:25:13 <wavewave> my ghci cannot interprete 5 1
13:25:16 <elliott> parcs: that <lambdabot>   No instance for (GHC.Num.Num (f (a -> b)))
13:25:18 <elliott> is because of caleskell
13:25:20 <elliott> :t flip
13:25:21 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:25:23 <companion_cube> but it's a bit confusing at first
13:25:27 <aristid1> wavewave: you lack the crazy instance declarations that lambdabot has.
13:25:33 <parcs> > flip (5 :: a -> Int) . [1,2,3,4]
13:25:34 <lambdabot>   Couldn't match expected type `a -> b'
13:25:35 <lambdabot>         against inferred type `GHC.Ty...
13:26:09 <companion_cube> aristid1: is it an instance for Applicative ? like   pure i = const i ?
13:26:09 <parcs> oh rite
13:26:23 <cgroza> Hello everyone. Lets say I hava the function: fun x y z = x + f + z . How would I partially apply the second argument?
13:26:32 <napping> make a lambda
13:26:45 <wavewave> hmm I guess it's defining fromInteger .
13:26:54 <TotoTitus> map 5 [1,2,3,4,5]
13:27:03 <companion_cube> > map 5 [1..5]
13:27:04 <lambdabot>   [5,5,5,5,5]
13:27:05 <cgroza> napping: is there any other way without it? something like let fun2 = fun _ 10 _
13:27:10 <mauke> cgroza: no
13:27:14 <napping> (\x -> fun x myY), or perhaps flip fun myY
13:27:16 <TotoTitus> ...? why is this working ??
13:27:26 <cgroza> mauke: ok
13:27:30 <cgroza> napping: ok thanks.
13:27:31 <TotoTitus> doesn't map expect a function ?
13:27:35 <mauke> TotoTitus: because 5 is a function
13:27:38 <mauke> in this case
13:27:50 <companion_cube> > let f x y z = x+y+z in  \x z -> f x 42 z -- cgroza
13:27:51 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
13:27:51 <lambdabot>    arising from a use...
13:27:54 <napping> the lambda syntax is sufficiently lightweight nobody has bothered to make an even lighter abbreviation
13:27:56 <parcs> cgroza: flip fun 10 is another way
13:28:04 <TotoTitus> why is 5 a function ?
13:28:08 <TotoTitus> is it a constant function ?
13:28:10 <wavewave> I think this already makes lots of confused people. ;-P
13:28:13 <TotoTitus> \_ -> 5 ?
13:28:14 <companion_cube> TotoTitus: it's because of typeclasses
13:28:20 <companion_cube> yes it is
13:28:25 <napping> TotoTitus: because lambdabot has some strange Num instances loaded
13:28:33 <TotoTitus> my local ghc explodes
13:28:39 <wavewave> fromInteger is defined for a -> Int
13:28:41 <companion_cube> > 5 ++ [2,3]
13:28:42 <lambdabot>   No instance for (GHC.Num.Num [t])
13:28:42 <lambdabot>    arising from a use of `e_1523' at <int...
13:28:46 <napping> pointwise operations on functions
13:28:46 <TotoTitus> :t 5
13:28:47 <companion_cube> oh, too bad :/
13:28:47 <lambdabot> forall t. (Num t) => t
13:28:59 <TotoTitus> so lambdabot can infer
13:29:00 <mauke> TotoTitus: http://mauke.dyndns.org/stuff/haskell/fun.hs does similar terrible things; it's not what lambdabot uses, though
13:29:15 <TotoTitus> that in that context, 5 must be a function
13:29:19 <companion_cube> exactly
13:29:27 <companion_cube> and it has an instance for making 5 a function
13:29:33 <TotoTitus> where does this happen? In Read ?
13:29:34 <companion_cube> which is  \_ -> 5
13:29:46 <mauke> TotoTitus: what do you mean by "where"?
13:30:11 <TotoTitus> i mean, due to the context
13:30:20 <mauke> type checking
13:30:21 <TotoTitus> 5 is read, like
13:30:22 <wavewave> TotoTitus: Easiest way is define Num (a-> Integer)
13:30:28 <TotoTitus> Read 5 :: Function
13:30:28 <mauke> map requires a function
13:30:40 <mauke> no, compilation doesn't use Read
13:31:09 <TotoTitus> uh, but this is an interpreter, isn't it ?
13:31:21 <mauke> does it matter?
13:31:24 <companion_cube> i think it uses GHC in the backend
13:31:30 <donri> note that the literal "5" is Num a => a
13:31:36 <mauke> the interpreter doesn't use Read either
13:31:38 <companion_cube> so it may compile lines from irc
13:32:11 <TotoTitus> well, there you go, i learned some stuff today
13:32:38 <mauke> when the compiler sees 「5」 in your code, it does something like 「fromInteger integer_5」
13:32:53 <mauke> where integer_5 is a constant of type Integer
13:33:34 <companion_cube> TotoTitus: cool! about the pointfree stuff, remember that you must find a balance between concision and readability
13:33:49 <TotoTitus> thanks people
13:33:56 <TotoTitus> companion_cube, Chell would be proud
13:33:57 <companion_cube> so sometimes an explicit lambda is better than a clever pointfree expression
13:34:02 <companion_cube> ^^
13:34:15 <TotoTitus> internet pop/gaming culture is viral
13:34:56 <TotoTitus> i bet a couple people here understand what 'Mentlegen' is, hehe
13:35:37 * wavewave is wondering if he can understand TotoTitus's last statement. 
13:35:55 * mauke clusters around a cigarette
13:36:13 * companion_cube lacks some reference here
13:36:54 <napping> TotoTitus: do you write much lisp?
13:37:11 <wavewave> fromInteger hack can make something funny. like L Augustsson' basic embedded in haskell.
13:37:22 <dafis> > let m = 568216269524841399 in (fromRational (fromInteger m / (2^1081)), encodeFloat m (-1081))
13:37:23 <lambdabot>   (2.193251079533551e-308,2.1932510795335517e-308)
13:37:30 <RaptorRarr> TotoTitus: All your nongaming are belong to us!
13:37:39 <dafis> damn, we're just too clever
13:37:45 <TotoTitus> no, i've left Lisp before learning it properly
13:37:54 <TotoTitus> it was my first introduction to functional prog.
13:38:08 <RaptorRarr> dafis: There's probably something that can get the max and min bounds for the exponent so we can have that abstracted.
13:38:58 <dafis> RaptorRarr: the fromRational is closer to the true value, encodeFloat's problem is double rounding
13:39:19 <wavewave> http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
13:39:40 <TotoTitus> for great justice ! I am leaving, thank you for all teh assistance
13:40:28 <TotoTitus> sleep :: Time -> IO Sleep
13:40:54 <mauke> sleep :: Time -> IO Refreshed
13:41:16 <ion> I didn’t read the discussion, but perhaps some of this code is useful: The minimum and maximum positive, finite floats https://gist.github.com/1188115
13:41:21 <wavewave> sleep :: Time -> IO ( forall a. a )
13:43:21 <RaptorRarr> dafis: Ahh, I see
13:44:57 <dafis> ion: The problem is that encodeFloat first rounds m to 53 bits, giving a 1 in the last bit, then, scaling gives a denorm, so it's rounded to 52 bits. Since the penultimate bit was 1, it rounds up again.
13:45:30 <dafis> fromRational only rounds once, so correctly rounds down.
13:46:30 <dafis> But if we let encodeFloat do what fromRational does, performance goes down the drain.
13:47:07 <antihoax> mauke<< how do you like the new regexp ? grep -v '^[\\]*[ ]*[0-9,a-f,A-F][0-9,a-f,A-F]*[ ][ ]*[\*]*[\.]*[/]*sha1sum\.txt\.'"20075"'$'
13:47:52 <mauke> antihoax: not at all
13:48:06 <mauke> the whole thing is flawed
13:48:06 <antihoax> its needed to be accurate
13:52:18 <xil> hello. I have a floating point variable that needs to wrap. I'm wondering if it's faster to put "mod 3" everywhere, or to use Ints for all my calculations and normalize the range so that it wraps around naturally because of the boundedness of Int
13:52:57 <ddarius> > read "09d"
13:52:58 <lambdabot>   *Exception: Prelude.read: no parse
13:53:01 <ddarius> > read "09"
13:53:02 <lambdabot>   *Exception: Prelude.read: no parse
13:53:06 <mauke> xil: you can't mod floats
13:53:07 <ddarius> > read "9e"
13:53:08 <lambdabot>   *Exception: Prelude.read: no parse
13:53:17 <mauke> > read "()"
13:53:18 <lambdabot>   ()
13:53:20 <dafis> > read "09" :: Int
13:53:21 <lambdabot>   9
13:53:22 <xil> mauke: there's a fixed mod function in Data.Fixed I think, or something like that
13:53:29 <ddarius> > read "9e" :: Int
13:53:30 <lambdabot>   *Exception: Prelude.read: no parse
13:53:34 <xil> mauke: that can handle more datatypes
13:53:38 <mauke> xil: I don't think Data.Fixed uses floats
13:53:46 <dafis> > read "0x9e" :: Int
13:53:47 <lambdabot>   158
13:53:51 <napping> xil: does performance really matter that much?
13:53:53 <dankna> Data.Fixed is fixed-point math, hence the name
13:54:08 <dankna> but yes, the mod function in there is general-purpose
13:54:38 <xil> napping: sadly yes. I'm doing waaaay too many floating point operations, so if I can significantly cut down the computations it would help. But if the improvement of using Ints isn't significant then no
13:54:54 <dankna> xil: in general this is something that the only way to know is to actually do the measurement
13:55:01 <dankna> xil: anything we could tell you would only be a guess
13:55:38 <napping> using fixedpoint with strange scaling would support addition nicely, but multiplication could be hard
13:56:30 <xil> dankna: right =/
13:56:48 <xil> napping: hmmm....indeed
13:57:12 <xil> I'll go with floats for now then. Probably easier to code anyway. I can always change it later
13:57:29 <dankna> yeah
14:07:11 <absence> "(,,) <$> [0,1,-1] <*> [0] <*> [0,1,-1]" results in [(Int, Int, Int)]. what do i have to do to make it [[Int]] instead?
14:07:56 <companion_cube> :t map (\(x,y,z) -> [x,y,z])
14:07:57 <lambdabot> forall t. [(t, t, t)] -> [[t]]
14:08:59 <companion_cube> or even  (\x y z -> [x,y,z]) <$> ... in your expression
14:09:33 <RarrRaptor> @hoogle Monad m => (a -> b -> c) -> m a -> m b -> m c
14:09:34 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:09:34 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:09:34 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
14:09:58 <RarrRaptor> > liftM3 (,,) [0, 1, -1] [0] [0,1,-1]
14:09:59 <lambdabot>   [(0,0,0),(0,0,1),(0,0,-1),(1,0,0),(1,0,1),(1,0,-1),(-1,0,0),(-1,0,1),(-1,0,...
14:10:04 <RarrRaptor> Hmm...
14:10:32 <RarrRaptor> companion_cube's is the best.
14:11:46 <absence> ah right. thanks :)
14:16:38 * BrianHV wants a functional language with typeclasses and constrained side effects that compiles to javascript.
14:17:16 <tgeeky> like haskell with ghcjs?
14:17:33 <BrianHV> yeah. if I could get ghcjs to compile... :)
14:20:31 <johnfn> ok... in ghci: floor 5 gives 5. but let x = 5 and then floor x gives an error
14:20:46 <johnfn> what's the rationale here?
14:20:52 <johnfn> (and what is going on?)
14:21:20 <aavogt> it decides on a type for x already (and that type doesn't support floor)
14:21:25 <RaptorRarr> > let x = 5 in floor x
14:21:26 <lambdabot>   5
14:21:31 <RaptorRarr> Oh, I see.
14:21:47 <Nioate> am I correct that there is no way to add a custom finalizer to a ForeignPtr?
14:22:03 <RaptorRarr> Finalizers are the work of SATAN since they may never run.
14:22:28 <Nioate> that's fine
14:22:33 <Nioate> (in this case)
14:22:38 <aavogt> johnfn: if you do the same thing in a file it'll work
14:22:49 <monochrom> @let x = 5
14:22:51 <lambdabot>  Defined.
14:22:54 <monochrom> @type x
14:22:55 <lambdabot>     Ambiguous occurrence `x'
14:22:55 <lambdabot>     It could refer to either `L.x', defined at <local>:13:0
14:22:55 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/L.hs:74:0-32
14:22:58 <monochrom> @type L.x
14:22:59 <lambdabot> forall t. (Num t) => t
14:22:59 <aavogt> well if you have   main = do let x = 5; print (floor x)
14:23:09 <monochrom> oh, lambdabot won't default that one
14:23:14 <monochrom> @undefine
14:23:45 <RaptorRarr> > let x :: Integer; x = 5 in floor x
14:23:46 <lambdabot>   No instance for (GHC.Real.RealFrac GHC.Integer.Type.Integer)
14:23:46 <lambdabot>    arising fro...
14:23:51 <monochrom> anyway, at ghci, it's a combination of monomorphism restriction and defaulting and being forced to pick a type without knowing the future
14:23:58 <johnfn> aavogt, that makes me feel a little more sane...
14:24:31 <RaptorRarr> @type floor
14:24:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:24:32 <johnfn> alright, i see
14:24:45 <RaptorRarr> johnfn: Try let x :: RealFrac; x = 5
14:24:53 <RaptorRarr> johnfn: Try let x :: RealFrac a => a; x = 5
14:25:08 <aavogt> monochrom: predicting the future isn't really a restriction since it might be able to pick a different type when more information is known
14:25:15 <zmv> > let x = 'a' in floor x
14:25:16 <lambdabot>   No instance for (GHC.Real.RealFrac GHC.Types.Char)
14:25:16 <lambdabot>    arising from a use of...
14:25:21 <zmv> ):
14:25:22 <aavogt> but that might be just as confusing (and isn't implemented)
14:25:29 <zmv> no floor for "a"
14:25:56 <monochrom> well I don't expect type inference to be Schrödinger's cat
14:27:34 <RaptorRarr> > let x :: Num a => a; x = 5 in floor x
14:27:34 <lambdabot>   5
14:27:51 <RaptorRarr> Why doesn't it default to that?
14:28:26 <monochrom> enough information to not default to Integer
14:29:34 <monochrom> @type typeOf
14:29:36 <lambdabot> forall a. (Typeable a) => a -> TypeRep
14:29:39 <monochrom> neat
14:29:56 <monochrom> > let x :: Num a => a; x = 5 in (floor x, typeOf x)
14:29:58 <lambdabot>   (5,Integer)
14:30:12 <monochrom> haha
14:30:16 <ion> saizan: Line 40 https://gist.github.com/1188115#L40
14:30:50 <ion> saizan: The ‘asTypeOf’ is kind of redundant, but makes me feel safer about it. :-)
14:31:06 <ion> compared to just ‘const’
14:31:51 <RaptorRarr> monochrom: How did that work?
14:31:58 <RaptorRarr> > floor (5 :: Integer)
14:31:59 <lambdabot>   No instance for (GHC.Real.RealFrac GHC.Integer.Type.Integer)
14:31:59 <monochrom> two different x's
14:31:59 <lambdabot>    arising fro...
14:32:10 <Saizan> maybe there's a better name than fix_ :)
14:32:12 <RaptorRarr> How are there two?
14:32:28 <RaptorRarr> My brain!
14:32:30 <monochrom> you explicitly ask for polymorphic x, no?
14:32:45 <ion> saizan: Yeah, ideas are appreciated. :-) It’s indeed not a fixed-point combinator anymore.
14:33:01 <RaptorRarr> So that makes separate uses into different 'objects'?
14:33:03 <hpc> Saizan: fix_ f = ()? :P
14:33:11 <RaptorRarr> Oh, I see.
14:33:16 <RaptorRarr> x is a function.
14:33:26 <monochrom> > (maxBound `asTypeOf` 'x', maxBound `asTypeOf` True)
14:33:27 <lambdabot>   ('\1114111',True)
14:33:42 <aavogt> if you use Debug.Trace you can see if things get re-evaluated
14:33:45 <monochrom> two different maxBound
14:34:29 <monochrom> btw this is the rationale for the monomorphism restriction. "how can there be two x's?" ok let's force it to one x.
14:35:16 <antihoax> mauke<< http://z-labor.com/tmp/scripts/uniqhardlinker.r
14:35:29 <antihoax> has workarounds :)
14:35:40 <mauke> antihoax: http://mauke.dyndns.org/stuff/perl/dupes
14:35:47 <RaptorRarr> Be back in a bit
14:35:50 <monochrom> the x in floor x is likely defaulted to Double, but I don't know how to show it
14:36:02 <antihoax> tried with $\[]  $\[];,-?:  a  \e  \e\b  fdd  n  \n  \;[]"+!n  \n\n
14:36:22 <elliott> the battle of bash vs perl?
14:36:49 <antihoax> :)
14:36:56 <hpc> elliott: more like the massacre of all shell scripts
14:37:01 <monochrom> no, the battle of so complicated there is no obvious error, vs so simple there is obviously no error
14:37:01 <elliott> antihoax: have you considered using backslashes and $() so you don't end up typing something like "'`'"$fn1""'
14:37:25 <elliott> monochrom: I don't think either of those scripts meet the latter criteria :P
14:37:26 <antihoax> no
14:37:34 <elliott> antihoax: pls consider it for me
14:37:35 <monochrom> haha ok!
14:37:38 <antihoax> <;
14:38:52 <mauke> elliott: my script has the advantage of obviously not destroying any data
14:39:07 <mauke> elliott: it opens files, reads stuff, and prints to stdout
14:39:20 <elliott> heh
14:39:20 <hpc> mauke: the advantage of not destroying any data obviously? :P
14:39:33 <elliott> mauke: sysopen... do you have something against the standard file apis of every major language? :p
14:39:44 <stianhj> I'm having some problems grokking an exercise in the monad chapter of LYAH. Not quite sure how to approach the problem. Maybe some type signatures could help me along. Problem/exercies description: http://hpaste.org/51988
14:40:00 <mauke> elliott: sysopen is a standard file api
14:40:12 <elliott> mauke: standard high-level apis :p
14:40:30 <mauke> elliott: I don't need high-level stuff here
14:40:51 <mauke> especially not buffering because I'm reading whole blocks anyway
14:40:59 <elliott> I'm sure you don't need Perl either
14:41:21 <mauke> no, but I don't want to write my own hash tables, md5 implementation, etc.
14:41:57 <dankna> we do have md5 on Hackage
14:42:26 <mauke> Haskell is even higher level than Perl
14:42:31 <antihoax> mauke<< good thing you asked, i fixed the \ bug...
14:42:35 <mauke> this is entirely the wrong direction :-)
14:42:45 <dankna> heh okay
14:42:52 <dankna> I missed what you were doing exactly, so you may well be correct
14:43:14 <mauke> dankna: scroll down to the middle of the file; there's a --help message there
14:43:45 <dankna> oh I see, duplicate-file-finding
14:44:02 <dankna> you know, both Mac and Win now have disk-wide metadata indices which you could leverage to do this much faster
14:44:17 <mauke> OS: linux
14:44:19 <dankna> well, slower in development time probably, but faster in runtime
14:44:20 <dankna> fair enough
14:44:23 <antihoax> and when you give sha1sum a flename containing \ it escapes the \ in filename, and puts a \ before the sumline ;/
14:45:26 <antihoax> i believe its a bug in coreutils
14:46:54 <antihoax> dankna<< zfs has sums and experimental deduplication thoug i wouldnt preer it for home use
14:47:15 <antihoax> though, prefer
14:48:21 <dankna> right, hm
14:49:14 <elliott> antihoax: zfs has the major downside that you, uh, can't use it with linux.
14:49:22 <elliott> except via fuse, or a module no distributor will ever, ever ship
14:49:23 <antihoax> ;<
14:49:32 <elliott> also: oracle controls it
14:49:46 <antihoax> there is a native zfs for linux currently being ported
14:50:01 <elliott> which no distributor will ever, ever ship
14:50:03 <antihoax> google knows about
14:50:06 <elliott> because it inherently violates the license
14:50:09 <elliott> to ship a binary of it
14:50:22 <antihoax> its a rewrite i believe...
14:50:30 <elliott> huh
14:50:35 <mauke> elliott: just use gentoo :-)
14:50:46 <elliott> mauke: then I'd have to use gentoo :p
14:50:47 <antihoax> zfsonlinux.org or smg
14:51:15 <elliott> doesn't look like a rewrite from their faq
14:51:48 <antihoax> they may be reverse engineering? ;)
15:13:14 * hackagebot HROOT 0.6.5 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.5 (IanWooKim)
15:14:38 <ezyang> Is 'type' an OK name for things that are not kinded '*'?
15:14:56 <napping> probably
15:14:59 <mm_freak> ezyang: strictly speaking no, they are type constructors
15:15:16 <mm_freak> but most people talk about "the Maybe type"
15:15:21 <napping> what's the general word for thing which have kinds, otherwise?
15:15:50 <mm_freak> ezyang: usually you would try to find a more appropriate word, which contains the kind implicitly
15:15:55 <mm_freak> like "monad" or "functor"
15:16:16 <ezyang> I want to talk about all of the things that have kinds.
15:16:26 <sully> "constructor", is what I've heard
15:16:26 <mauke> napping: I say "type constructor"
15:16:33 <napping> (conversely, if anything with a kind is a type, "things of kind *" is a bit clumsy for naming the types that expressions might occupy
15:17:30 <wavewave> can't we use type for everything including *->* ... , and higher-kinded type for types which is not *?
15:17:42 <dafis> "type expression", if it may contain type variables
15:18:01 <napping> I think type would be quite acceptable for talking about type theory in general
15:19:00 <wavewave> to distinguish, we may use a word 'concrete type' for * kind.
15:19:35 <napping> "type constructor" if you are woried people might be confused with pre-1.2 Haskell
15:19:44 <mm_freak> wavewave: i prefer to think of things of kind * as types
15:19:52 <napping> or want to emphasize that you include higher-kinded things
15:20:04 <mm_freak> * -> * are a special case of type functions, which i would call type constructor or in some cases type family
15:20:15 <mm_freak> because something of kind * -> * describes many types
15:20:59 <mm_freak> it also helps to characterize things of higher kinded types like (* -> *) -> *, which takes a family of types and produces a type
15:23:51 <mm_freak> does category theory actually capture objects, which are not of kind *?
15:26:45 <BMeph> Is there an entry in the h-wiki that specifies what parts of GHC have been broken out , and are usable programmatically?
15:27:07 <Cale> mm_freak: Um, some of them at the very least. For example, functors.
15:27:12 <BMeph> Or for that matter, if there's a specific GHC wiki, is there something there?
15:27:42 <mm_freak> Cale: are those objects in Hask or does Hask only cover *?
15:27:54 <Cale> http://www.haskell.org/haskellwiki/GHC/As_a_library ?
15:28:04 <Cale> mm_freak: Hask only covers *
15:28:07 <ddarius> Cale: Cat is cartesian closed, so that includes various other functors.  Furthermore, we can model Haskell type constructors as functors |Hask| -> Hask.  That covers just about everything.
15:28:14 <BMeph> Cale: Thank you, checking it out now.
15:28:19 <Cale> ddarius: indeed
15:28:57 <mm_freak> are kind variables possible in haskell?
15:29:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/index.html
15:29:05 <mm_freak> MyType :: a -> a
15:29:19 <benmachine> mm_freak: not yet :>
15:29:21 <Cale> mm_freak: no, there's no kind polymorphism (yet)
15:29:25 <ddarius> mm_freak: Not currently, but there is nothing stopping it.
15:29:27 <kmc> they are in UHC, iirc
15:29:27 <Cale> SOON
15:29:35 <kmc> there's no explicit kinds at all in Haskell
15:29:36 <mm_freak> alright
15:29:40 <ddarius> Omega is a Haskell-like language with a much richer kind system including kind polymorphism.
15:29:45 <kmc> hmm, is that true?
15:29:55 <benmachine> Cale: huh, I thought SOON was an in-joke in a different community I was in, where does it come from?
15:30:04 <benmachine> unless you've independently invented it which is admittedly possible :P
15:30:15 <Cale> http://knowyourmeme.com/memes/soon--2 ?
15:30:28 <kmc> yes "However, unlike types, kinds are entirely implicit and are not a visible part of the language"
15:31:27 <benmachine> oic
15:31:31 <benmachine> how ordinary
15:32:21 <mm_freak> there are lots of languages with a richer type system, but i don't know a single one which i would use in production
15:33:14 * hackagebot samtools-iteratee 0.2.2 - Iteratee interface to SamTools library  http://hackage.haskell.org/package/samtools-iteratee-0.2.2 (NicholasIngolia)
15:33:16 * hackagebot samtools-enumerator 0.1.2 - Enumerator interface to SamTools library  http://hackage.haskell.org/package/samtools-enumerator-0.1.2 (NicholasIngolia)
15:44:54 <kniu> hey guys
15:45:03 <kniu> I just got a crazy idea
15:45:14 <Jafet> Give it back.
15:45:25 <kniu> what if typeclasses were just types instead?
15:46:00 <RaptorRarr> kniu: Then we'd have Ruby or Java or something.
15:46:35 <donri> a value can only be one type but its type can be instances of multiple classes, so what do you propose instead?
15:46:42 <kniu> like, instead of existing in a completely separate universe, we treat typeclasses as types that have an associated "default" value.
15:46:59 <kniu> And then combine that with implicit parameters
15:47:16 <Jafet> "Yo dawg we heard you like dictionaries"
15:47:27 <kniu> okay, yeah
15:48:15 <kniu> it's basically making typeclasses be the types of the dictionaries that implement them and making the implicit dictionary passing a part of the language.
15:49:51 <Jafet> And how does this make programming more awesome?
15:51:33 <Saizan> kniu: i'm told scala does something like that
15:53:30 <byorgey> kniu: most Haskell implementations do something like that anyway.
15:53:45 <byorgey> kniu: are you proposing that you could explicitly pass dictionary arguments if you wanted to?
15:56:45 <rostayob> kniu: Scala implicits do exactly that
15:56:45 <ezyang> The "explicit if I wanted to" causes... problems.
15:57:15 <antihoax> mauke<< wget http://z-labor.com/tmp/scripts/uniqhardlinker.r
15:57:32 <antihoax> it handles nonprintable characters now
16:02:50 <byorgey> ezyang: how?
16:03:38 <rostayob> ezyang: iirc in scala you can pass implicits explicitely
16:11:12 <kniu> byorgey, kinda
16:11:24 <kniu> I think it would make "handling" typeclasses simpler.
16:11:53 <kniu> If they're just types, you can form tuples of them, create aliases, use type families, etc.
16:12:03 <rostayob> kniu: you might want to take a look at scala's implicits, there was a paper describing them
16:12:16 <ezyang> byorgey: You don't get to assume a data structure with a specific type will have a well-defined ordering.
16:12:22 <rostayob> haskell type classes are a lot more powerful
16:12:32 <rostayob> and elegant if you ask me
16:13:22 <rostayob> kniu: also, take a look at this: http://code.google.com/p/scalaz/
16:13:34 <byorgey> kniu: actually, using the new ConstraintKinds extension you can generically reify type class dictionaries and do all those things
16:14:18 <byorgey> ezyang: I don't understand what you mean.
16:16:22 <ezyang> erm, sorry >_<
16:16:45 <Saizan> byorgey: e.g. they give you a Map X Y built with one dictionary for Ord X and you use it with another dictionary
16:16:48 <Saizan> byorgey: boom
16:16:53 <ezyang> Saizan's got it.
16:17:30 <byorgey> ah, yes, I see now
16:17:44 <byorgey> I vaguely recalled there was a problem along those lines but had forgotten how it worked.
16:19:02 <RaptorRarr> Is there a way to cabal install CReal?
16:19:32 <hpc> @hoogle CReal
16:19:33 <lambdabot> No results found
16:20:13 <kmc> RaptorRarr, you have to know the package it's in
16:20:17 <byorgey> RaptorRarr: cabal install numbers
16:20:20 <kmc> HERA provides one implementation of CReal but it's completely undocumented
16:20:37 <kmc> has CReal been used in "practical" code?
16:20:59 <hpc> kmc: i used it for the calculator on my IRC bot
16:21:06 <hpc> not sure how practical that counts as :P
16:21:12 <RaptorRarr> byorgey: Thanks :)
16:21:30 <hpc> (i went back to Double because i couldn't plug all the strange non-termination conditions)
16:21:32 <RaptorRarr> kmc: Not sure, but someone wants to know the best Ratio Int32 approximation to pi.
16:23:36 <benmachine> Ratio Int32 would only be about 10 decimal digits, wouldn't it?
16:23:41 <benmachine> if it helps I know like 30 >_>
16:24:09 <hpc> > maxBound :: Int32
16:24:10 <lambdabot>   2147483647
16:24:34 <benmachine> > length "3.141592653589793238462643383"
16:24:35 <lambdabot>   29
16:24:43 <hpc> > pi :: CReal
16:24:43 <benmachine> well, close enough
16:24:44 <lambdabot>   3.1415926535897932384626433832795028841972
16:25:08 <hpc> holy sit
16:25:40 <kmc> why not do the calculation on Ratio Int32?
16:26:28 <hpc> it's a lot of numbers to go through if you brute-force it, but there's almost certainly tricks to reduce how much searching you have to do
16:27:14 <kmc> hmm
16:27:42 <kmc> how does CReal do it?
16:27:51 <kmc> since it's giving rational approximations to n digits
16:28:36 <benmachine> I don't think you brute-force it, there are cleverer ways
16:28:36 <kmc> does it promise to give the best approximation at each step, or just a sequence which converges?
16:28:48 <elliott> kmc: it's just cauchy sequences I think
16:29:01 <benmachine> it must be cauchy sequences that know how fast they converge
16:29:07 <hpc> i thought it did some Cont Integer trickery
16:29:19 <benmachine> data CReal = CR (Int -> Integer)
16:29:21 <benmachine> if it helps
16:29:23 <elliott> CReal in lambdabot is Few Digits?
16:29:25 <elliott> istr it wasn't
16:29:26 <elliott> I forget
16:29:41 <hpc> CReal uses show, which is 40 digits
16:29:43 <benmachine>   pi = 16 * atan (fromRational (1 % 5))
16:29:44 <benmachine>                 - 4 * atan (fromRational (1 % 239))
16:30:16 <benmachine> atan seems to be indirectly a power series
16:30:33 <hpc> i should go through that module again
16:30:39 <hpc> i might actually understand some of it now
16:31:25 <ion> Does the atan trickery with those constants result in pi exactly or just a good approximation?
16:31:47 <benmachine> ion: I'd be entirely unsurprised if it was exact
16:31:47 <hpc> ion: it converges on pi if you ask for all the digits
16:32:26 <hpc> if you ask for some digits, it gives that many digits, as if they were from the exact answer
16:32:34 <ion> I mean outside CReal, as an algebraic equation.
16:32:38 <ddarius> ion: That is a traditional representation of pi that converges rather quickly.
16:33:10 <hpc> oh, algebraically
16:35:02 <hpc> ion: https://secure.wikimedia.org/wikipedia/en/wiki/Atan2#Definition -- solve :P
16:35:25 <benmachine> atan2 is not involved
16:35:42 <hpc> oh, wait nvm
16:35:50 <hpc> yeah, just noticed wrong function
16:36:35 <ion> > 5 * atan 1 :: CReal
16:36:36 <lambdabot>   3.9269908169872415480783042290993786052465
16:36:37 <ion> err
16:36:38 <ion> > 4 * atan 1 :: CReal
16:36:39 <lambdabot>   3.1415926535897932384626433832795028841972
16:36:49 <ion> > 4 * atan 1 - pi :: CReal
16:36:50 <lambdabot>   0.0
16:37:55 <ion> http://www.cygnus-software.com/misc/pidigits.htm
16:38:04 <ddarius> ion: If you are too lazy to prove it yourself, you can look up Machin's formula.
16:38:06 <zmv> tsc tsc
16:38:14 <zmv> pi is not the true circle constant
16:38:20 <zmv> :|
16:39:11 <ion> zmv: http://www.thepimanifesto.com/
16:39:50 <benmachine> the pi manifesto is basically unconvincing imo
16:40:07 <benmachine> RaptorRarr: http://numbers.computation.free.fr/Constants/Pi/piApprox.html this might be helpful?
16:41:29 <ion> Haha, that page seems to use Ö in the place of √.
16:41:44 <ion> Some charset issue.
16:59:40 <buhman> how do I make shebangs in haskell?
17:00:55 <Saizan> there's a pi manifesto as a reply to the tau one?
17:02:39 <companion_cube> buhman: i'd say  #!/usr/bin/env runhaskell
17:03:18 <buhman> copumpkin: but # isn't a comment delimiter in haskell is it?
17:04:01 <geheimdienst> buhman: ghc makes an exception for the first line in a file
17:04:08 <Cale> buhman: runghc will be fine with it
17:05:32 <companion_cube> and anyway i think the kernel removes the shebang line, doesn't it?
17:05:32 <buhman> Cale: oh, really?
17:10:56 <elliott> companion_cube: no
17:31:19 <kmc> is that #! behavior in the Report or is it non-standard?
17:34:39 <Cale> The report doesn't say anything about runghc/runhaskell
17:39:53 <ion> Are there Haskell compilers that can’t handle a #! line?
17:40:29 <Cale> Probably
17:40:39 <Cale> Though it's not like it's a difficult feature to handle :P
17:41:01 <geheimdienst> i think we should have a runhaskell variant which compiles first and caches the binary somewhere, to speed up future runs ...
17:41:19 <parcs> there is one
17:41:24 <parcs> on hackage somewhere
17:41:33 <geheimdienst> interesting, will look
17:43:21 <parcs> @hackage runghc
17:43:21 <lambdabot> http://hackage.haskell.org/package/runghc
17:44:00 <geheimdienst> ah thanks :) the name makes it kind of unfindable
17:44:14 <parcs> yeah
17:45:22 <Eduard_Munteanu> geheimdienst: don't you also want a JIT? :P
17:46:59 <JoeyA> Can I has Haddock for SQL?
17:48:09 <geheimdienst> Eduard_Munteanu: i dunno, i guess if you use runhaskell on a script 100x and it does the compiling only 1x instead of 100x, that's already a big improvement
17:48:41 <Eduard_Munteanu> Yeah, I guess so.
17:49:22 <geheimdienst> you could then make that one compilation process faster by JITtery, but i think that's a vastly smaller improvement for vastly more effort. so "get the low-hanging fruit" and all that :)
17:49:33 <llano> JoeyA: what is Haddock
17:49:56 <ion> Tintin’s friend.
17:50:11 <ion> Someone should make a piece of software related to Haskell documentation named Tintin.
17:50:13 <JoeyA> The thing what makes documentation like this: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:map
17:50:14 <Eduard_Munteanu> @google haddock haskell
17:50:15 <lambdabot> http://www.haskell.org/haddock/
17:50:15 <lambdabot> Title: Haddock
18:09:31 <elliott> I wish showConcatMap :: (a -> ShowS) -> [a] -> ShowS was in Text.Show.
18:10:57 <benmachine> :t foldr ((.) . shows) id
18:10:58 <lambdabot> forall a. (Show a) => [a] -> String -> String
18:11:19 <elliott> benmachine: easier: flip . foldr
18:11:29 <elliott> and that has the actual type I want too :P
18:11:35 <benmachine> :t flip . foldr
18:11:36 <lambdabot> forall b a. (a -> b -> b) -> [a] -> b -> b
18:11:42 <benmachine> :o
18:11:44 <elliott> > (flip . foldr) shows [0,9]
18:11:45 <lambdabot>   Overlapping instances for GHC.Show.Show
18:11:45 <lambdabot>                              (GHC.B...
18:11:48 <elliott> gah
18:11:49 <elliott> > (flip . foldr) shows [0,9] ""
18:11:50 <lambdabot>   "09"
18:12:00 <benmachine> wow, how abobut that
18:12:03 <benmachine> -b
18:12:19 <elliott> benmachine: well it's easy to see:
18:12:32 <elliott> (showString "a" . showString "b") is like ("a" ++ "b")
18:12:43 <geheimdienst> :t shows
18:12:43 <elliott> (showString "a" . showString "b") x = showString "a" (showString "b" x)
18:12:43 <lambdabot> forall a. (Show a) => a -> String -> String
18:12:50 <elliott> so if we replace showString by our specific shows function...
18:12:56 <elliott> then it's an obvious foldr
18:13:07 <elliott> and the x is the zero argument of the foldr
18:13:14 <elliott> which in ShowS is the rest of the string, to prepend to
18:13:17 <benmachine> fair enough
18:13:22 <elliott> I guess it is not quite "easy" :)
18:19:09 <wavewave> JoeyA: what does it mean by haddock for SQL?
18:19:55 <geheimdienst> wavewave: he's gone
18:20:03 <wavewave> ah..
18:20:31 <wavewave> she's gone~~
18:21:00 <wavewave> making haddock document more semantic will be great.
18:24:49 <ion> @type (\f -> mconcat . map f) `asAppliedTo` (undefined :: a -> ShowS)
18:24:50 <lambdabot> forall a. (a -> ShowS) -> [a] -> ShowS
18:26:20 <ion> @type foldMap `asAppliedTo` (undefined :: a -> ShowS)
18:26:21 <lambdabot> Not in scope: `foldMap'
18:26:25 <ion> @type Data.Foldable.foldMap `asAppliedTo` (undefined :: a -> ShowS)
18:26:26 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => (a -> ShowS) -> t a -> ShowS
18:26:45 <ion> elliott: foldMap!
18:26:56 <elliott> ion: omg really? :D
18:27:04 <elliott> > foldMap shows [0,9] ""
18:27:05 <lambdabot>   Not in scope: `foldMap'
18:27:09 <elliott> > Data.Foldable.foldMap shows [0,9] ""
18:27:10 <lambdabot>   "09"
18:27:15 <elliott> ion: thank you :D
18:27:48 <ion> Took a while to figure out “there’s something familiar about \f -> mconcat . map f” :-)
18:28:06 <elliott> oh hmm
18:28:08 <elliott> > Data.Foldable.foldMap shows [0,9] "oh dear"
18:28:09 <benmachine> wait
18:28:09 <lambdabot>   "0oh dear9oh dear"
18:28:11 <elliott> ion: nope
18:28:15 <ion> Oh :-(
18:28:19 <benmachine> yeah I was about to say, not the monoid you want
18:28:21 <elliott> ion: because the Monoid instance for functions, etc.
18:28:25 <elliott> I could use ala from the newtype package
18:28:27 <benmachine> you want the Endo monoid
18:28:27 <elliott> but at that point uhh
18:28:29 <ion> Yeah, didn’t think it through.
18:28:29 <benmachine> but faff
18:28:31 <elliott> nice dependency
18:28:43 <elliott> I got so happy there too :(
18:28:45 <ion> This is what i get for looking blindly at the types.
18:28:47 <elliott> ion has crushed my soul.
18:29:27 <ion> And not thinking what the a -> b monoid instance actually does.
18:38:46 <ddarius> The Monoid instance for functions used to be the Endo instance.
18:39:27 <ion> Oh? Interesting.
18:39:36 <ion> When was this?
18:40:21 <elliott> ddarius: That's a flexible instance, isn't it?
18:40:26 <elliott> Since it's (a -> a).
18:42:27 <ddarius> http://www.haskell.org/ghc/docs/6.4/html/libraries/base/Data.Monoid.html
18:44:06 <ion> > ala' Endo foldMap shows [False, True] "!"
18:44:07 <lambdabot>   Not in scope: `foldMap'
18:44:14 <ion> > ala' Endo Data.Foldable.foldMap shows [False, True] "!"
18:44:15 <lambdabot>   "FalseTrue!"
18:44:32 <elliott> why ala' instead of ala?
18:44:54 <ion> > ala Endo (\f -> Data.Foldable.foldMap (f . shows)) [False, True] "!"  -- with ala
18:44:56 <lambdabot>   "FalseTrue!"
18:44:56 <elliott> ddarius: I wonder why that was changed
18:44:59 <elliott> ion: ah
18:46:24 <mm_freak> can i use view patterns in a record pattern match?  like:  let Point { pointX = realToFrac -> x, pointY = realToFrac -> y } = myPoint
18:46:32 <ddarius> Yes.
18:46:33 <mm_freak> it gives me a syntax error with this variant
18:46:52 <ddarius> Try adding parentheses.
18:47:10 <mm_freak> indeed, thanks
18:52:57 <hpaste_> zuserm pasted “Silly Monad” at http://hpaste.org/52021
18:53:38 <zuserm> I was wondering if that was a monad.
18:54:24 <Axman6> it satisfies the monad laws, so yes
18:54:25 <ddarius> Yes, it is (modulo the usual caveats.)
18:54:45 <ddarius> Notably, it is an example of a monad where return is not a mono.
18:55:04 <zuserm> Not a mono?
18:55:06 <Axman6> no mono
18:55:08 <Axman6> >_>
18:55:52 <Axman6> ddarius: what's a mono?
18:56:18 <Rotaerk> spanish for monkey
18:56:20 <ddarius> monomorphism
18:57:12 <ddarius> f is a mono if for all g and h, f . g = f . h => g = h.
18:57:37 <zuserm> ddarius: what are the usual caveats?
18:59:32 <ddarius> return undefined >>= f = f undefined by the monad laws.  Your return fails this law when f is strict.
19:00:59 <zuserm> right
19:01:05 <elliott> ddarius: Wouldn't "_ >>= f = f undefined `seq` Silly" sort that out?
19:01:42 <benmachine> elliott: what if f was strict, but you did 'return () >>= f'
19:02:01 <elliott> oh, right
19:02:15 <ddarius> What you want is a type that has one value, not two.
19:02:34 <benmachine> but we're calling these the usual caveats because I think some of the standard monads break them too
19:02:38 <benmachine> (I presume)
19:03:16 * benmachine tries to remember how to test them
19:41:18 <confusedCabal> is this a good place to ask for help with a cabal issue?
19:42:44 <mzero> sure
19:42:58 <shachaf> confusedCabal: This is a much better to place to ask about cabal issues than about asking about cabal issues. :-)
19:43:04 <shachaf> (Go ahead.)
19:45:08 <confusedCabal> I'm trying to do 'cabal install cabal-install' but it fails unable to find the header file zlib.h and when i use the command line argument --extra-include-dirs=PATH to specify it's location it still fails the same way. Am I missing something?
19:45:38 <confusedCabal> its*
19:47:09 <mzero> OS you are on?
19:48:25 <confusedCabal> I'm using Ubuntu
19:49:46 <shachaf> confusedCabal: Are you sure zlib.h actually exists?
19:50:22 <shachaf> In Ubuntu you might need to install zilb1g-dev, or something of the sort.
19:50:30 <eduardo> hello there, I'm trying to install "ghc-mod" via Cabal without success, I get the following output:
19:50:33 <eduardo> cabal: cannot configure ghc-mod-0.6.1. It requires ghc -any
19:50:35 <eduardo> There is no available version of ghc that satisfies -any
19:50:55 <eduardo> I already did cabal update.
19:51:02 <confusedCabal> doing a 'find . -name "zlib.h"' i find it in multiple locations such as '/usr/src/linux-headers-2.6.38-11/include/linux/zlib.h'
19:51:07 <eduardo> Is that a bug or something?
19:51:18 <shachaf> confusedCabal: linux-headers is probably not the zlib.h that you want. :-)
19:51:34 <shachaf> confusedCabal: Install the package I mentioned and it should work.
19:51:41 <confusedCabal> ah i'll look into the zilb1g-dev thank you
19:51:57 <shachaf> zlib1g-dev, rather.
19:53:07 <parcs> edwardk: has your IxMonad stuff from category-extras been spliced into its own package?
19:53:18 <edwardk> parcs: not yet
19:53:30 <parcs> edwardk: okay :)
19:54:12 <confusedCabal> thanks for the help installing the zlib1g-dev made cabal work
19:54:12 <edwardk> parcs: i have a toy project locally with a bunch of indexed Foo types in it, that i used to work out a bunch of details about indexed stores, but i haven't pushed one to github or hackage
20:10:45 <Saizan> eduardo: it's asking for ghc the library there
20:10:53 <Saizan> eduardo: how did you get your ghc?
20:11:44 <smop_> can someone help me setup hakyll with cygwin? I'm having trouble installing unix-2.5.0.0
20:12:28 <Saizan> eduardo: if you got it from your distro you might need to install some more packages too
20:25:40 <ezyang> So, I once heard that being lazy gives you some optimizations but forces you to give up others. Is there any treatment of this topic?
20:32:09 <RaptorRarr> ezyang: I'm not sure, but it's a bit like breadth-first evaluation order or something.
20:32:55 <RaptorRarr> You don't dive down and get the first value, you leave things as thunks.
20:33:55 <ezyang> I don't understand.
20:35:49 <RaptorRarr> If you have f (2 + 3) [1..], eager evaluation would evaluate 2 + 3 until it was completely done, then it would evaluate [1..] until it was completely done, then it would evaluate f 5 [1..] until it was done.
20:36:26 <RaptorRarr> It's sort of depth first that way. It goes down the branch of the expression tree until it's handled that branch completely.
20:37:12 <ezyang> Right, but I don't see how that characterizes optimizations.
20:37:13 <zuserm> ezyang: I think I remember seeing something about it on the existential type blog
20:37:26 <ezyang> zuserm: That would be the equational translations.
20:37:46 <RaptorRarr> ezyang: Well, a major benefit of laziness is skipping unnecessary evaluations, I think.
20:37:53 <zuserm> I thought he said something about optimizations also.
20:38:01 <RaptorRarr> ezyang: If you go all depth-first, you cannot skip anything.
20:38:29 <ezyang> RaptorRarr: I'm thinking of transformational optimizations, not algorithmic ones.
20:39:06 <ski> s/depth-first/call-by-value/,s/breadth-first/call-by-need/
20:40:16 <RaptorRarr> Ahh, I see.
21:02:41 <ivanm> @tell chrisdone fresh emacs session, open up a haskell file, and I get an error "Debugger entered--Lisp error: (void-variable *hs-project*)"; the stack trace shows that it goes hs-mode() -> hs-tags-generate-interactive() -> hs-project() -> error
21:02:41 <lambdabot> Consider it noted.
21:03:40 <ezyang> Relooked at "The Point of Laziness", and yeah, I'm pretty sure it's the equations he was talking about.
21:11:18 <eduardo> Saizan, yes, I got it from my distro (Fedora 15)
21:11:54 <eduardo> Saizan, but doing cabal install it is supposed to resolve dependencies (in case they are) but it doesn't...
21:15:07 <Cale> eduardo: cabal install only follows dependencies that are on hackage. The ghc api is generally included with ghc, but if you got it from your distribution, sometimes the people who make the packages for the distributions like to split things into smaller parts.
21:15:14 <ivanm> where does ghci get the value of PATH from?
21:16:24 <geheimdienst> ivanm: getEnv "PATH" in ghci gives the expected result for me (linux)
21:18:12 <ivanm> @hoogle getEnv
21:18:12 <lambdabot> System.Environment getEnv :: String -> IO String
21:18:12 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
21:18:25 <ivanm> geheimdienst: yeah, no I was trying to work out the PATH stuff for doing :! commands
21:18:29 <ivanm> but I worked out what that issue was
21:20:03 <ivanm> *sigh* OK, the ghci run within emacs emits a different value for `:! echo $PATH ' than the one that I launch in a terminal
21:20:16 <ivanm> and I have the sneaking suspicioun that it's because of how I launch emacs...
21:21:00 <Cale> eduardo: I don't see a separate package for that in fedora though.
21:21:40 <eduardo> Cale, it is via Cabal
21:21:50 <geheimdienst> if you have something like "PATH=someaddition:$PATH" in your shell's startup files, anything launched from a terminal could easily see a different PATH than e.g. something launched from your window manager or whatever
21:21:53 <eduardo> cabal update, then: cabal install ghc-mod
21:21:56 <geheimdienst> ivanm: ^^
21:22:08 <eduardo> Cale, ^
21:22:10 <ivanm> geheimdienst: yeah
21:22:14 <Cale> eduardo: I'm aware. The problem is that you're missing the 'ghc' package which is supposed to come with ghc itself.
21:22:23 <eduardo> oh
21:22:39 <ivanm> geheimdienst: I think the issue is that emacs doesn't read ~/.bashrc when launching :/
21:22:39 <eduardo> sounds crazy
21:22:50 <ivanm> (nor ~/.bash_profile, which sources ~/.bashrc here)
21:22:56 <ivanm> eduardo: which version of GHC?
21:23:19 <ivanm> the ghc library that comes with GHC got renamed in a recent version IIRC
21:23:22 <ivanm> to ghc-lib or something
21:23:28 <ivanm> (IIUC your problem)
21:23:30 <eduardo> ivanm, ghc-7.0.2-16.3.fc15.x86_64
21:23:49 <Cale> eduardo: Yeah. Unfortunately, I've never been able to trust my system package manager to install GHC correctly, so I just install the generic linux binary from the GHC website. It tends to solve a lot of those kinds of problems.
21:24:14 <ivanm> eduardo: did you paste an error message earlier?
21:24:21 <eduardo> ivanm, yes
21:24:38 <eduardo> ivanm, Resolving dependencies...
21:24:38 <eduardo> cabal: cannot configure ghc-mod-0.6.1. It requires ghc -any
21:24:39 <eduardo> There is no available version of ghc that satisfies -any
21:24:40 <ivanm> can you paste it again please? you obviously pasted it before I joined the channel
21:24:44 <eduardo> ^
21:24:45 <ivanm> eduardo: "ghc-pkg list ghc"
21:25:06 <eduardo> /usr/lib64/ghc-7.0.2/package.conf.d
21:25:06 <eduardo> /home/eduardo/.ghc/x86_64-linux-7.0.2/package.conf.d
21:25:06 <ivanm> maybe even "ghc-pkg list | grep ghc"
21:25:27 <ivanm> preflex: seen juhp
21:25:27 <preflex>  juhp was last seen on #ghc 57 days, 19 hours, 31 minutes and 44 seconds ago, saying: okay patch posted to trac
21:25:47 <eduardo> :O
21:25:57 <ivanm> OK, preflex is lying
21:26:02 <ivanm> juhp was on yesterday
21:26:14 <ivanm> and he works for redhat and deals with haskell packaging on fedora
21:26:52 <ivanm> eduardo: what does "ghc-pkg list | grep ghc" say?
21:27:29 <geheimdienst> ivanm: fwiw, i set all that stuff in .zlogin (zsh startup file if invoked as a login shell, not sure about bash equivalent). .zlogin then starts the x server. maybe not the best solution, but the entire session has a consistent environment because it all descends from that one zsh process
21:27:44 <ivanm> geheimdienst: oh, so you login to a tty first?
21:27:49 <ivanm> and then startx from there?
21:28:27 <eduardo> ivanm, /usr/lib64/ghc-7.0.2/package.conf.d: ghc-prim-0.2.0.0
21:28:27 <eduardo> /home/eduardo/.ghc/x86_64-linux-7.0.2/package.conf.d:
21:28:41 <ivanm> yeah, your ghc install looks b0rked
21:28:45 <eduardo> doesn't says anything after the last ":"
21:28:51 <ivanm> you should have ghc-binary there as well
21:29:02 <eduardo> certainly this problem is new to me
21:29:08 <ivanm> looks like the fedora packagers don't expose the ghc internal libraries
21:30:48 <geheimdienst> ivanm, kind of :) ... i have "/bin/login -f myusername" in inittab. the system boots, becomes my user and starts zsh, which reads .zlogin and does xinit (~ startx)
21:31:05 <ivanm> so you use password-less login?
21:31:15 <ivanm> *tsk, tsk*
21:31:15 <ivanm> :p
21:31:36 <geheimdienst> i do this because the hard drive is encrypted via luks, so i felt a graphical login manager is redundant. same for logging in to a console
21:31:54 <ivanm> oh, so you have to log in to start the actual machine?
21:31:58 <geheimdienst> so it asks a pass phrase when booting. without it, no boot
21:32:08 <ivanm> and I take it you've disabled remote access?
21:33:09 <geheimdienst> no i can still do that, i have a regular user and password. it's just that the first session uses /bin/login -f to skip the password prompt
21:33:15 <eduardo> ivanm, I found something, not sure if it's relevant. I downloaded the package via GitHub and when doing "cabal configure" it says 'ghc' is one of the missing dependencies; opening the .cabal file there are some dependencies that specify a minimum version, and others (like ghc, enumerator, ghc-paths) doesn't.
21:33:33 <ivanm> that doesn't make a difference
21:33:43 <ivanm> as Cale said earlier, the problem is with how fedora packaged GHC
21:33:59 <elliott> does anyone package ghc right?
21:34:15 <ivanm> elliott: gentoo, exherbo...
21:34:15 <ivanm> :)
21:34:25 <ivanm> well, OK, I dunno if gentoo does man pages
21:34:28 <elliott> Never heard of exherbo
21:34:30 <eduardo> ok, thanks, I'll ask on #fedora
21:34:33 <ivanm> they didn't last time I bothered to check
21:34:44 <eduardo> at least we know where the problem resides now
21:34:46 <ivanm> elliott: consider it a conceptial fork (as in the idea was taken, not code) of gentoo
21:34:52 <elliott> but as always the problem with using gentoo is that you have to use gentoo :P
21:35:01 * ivanm fails to see the problem
21:35:28 <elliott> ivanm: do they support non-glibc libcs? I always felt the only reason you'd want to use Gentoo -- i.e. being able to swap out core parts of the system without problems -- was hampered by the fact that they loved to remove support for it...
21:35:41 <gienah> man ghc works for me with dev-lang/ghc doc use flag on gentoo
21:35:53 <ivanm> elliott: I use gentoo/exherbo to be able to customise my system how I want it
21:35:59 <ivanm> gienah: OK, around 6.10 it wasn't shipped
21:36:07 <ivanm> (i.e. when I wanted it :p)
21:36:18 <Cale> Too bad bos isn't here, it seems he's involved in the construction of that fedora package. Maybe he knows what the deal is with it.
21:36:38 <ivanm> elliott: not sure about using elibc though; I suspect that it would be possible to do so if someone wanted it enough to add support it
21:36:45 <elliott> elibc?
21:36:46 <ivanm> the changes would be rather large though (changing deps, etc.)
21:36:59 <ivanm> elliott: isn't that the main non-glibc libc?
21:37:24 <Cale> eduardo: bos (Bryan O'Sullivan) is often around here, you might try to catch him sometime
21:37:31 <Cale> preflex: seen bos
21:37:31 <preflex>  bos was last seen on #haskell 2 days, 7 hours, 50 minutes and 40 seconds ago, saying: @src groupBy
21:37:31 <elliott> you might be thinking of eglibc which isn't non-glibc really, it's a derivative of glibc that pulls from upstream (and probably the most-used Linux libc on the desktop)
21:37:38 <elliott> but I'm not interested in using eglibc :P
21:37:46 <eduardo> Cale, thanks :P
21:37:59 <ivanm> which libc are you interested in then?
21:38:01 <elliott> I seem to recall Gentoo used to support non-standard libcs... or was it static linking they used to support? anyway :)
21:38:07 <elliott> ivanm: mostly musl these days
21:38:13 <ski> preflex: xseen bos
21:38:14 <preflex>  bos was last seen on freenode/#haskell 2 days, 7 hours, 51 minutes and 22 seconds ago, saying: @src groupBy
21:38:33 <ivanm> elliott: what's that?
21:38:42 <elliott> ivanm: http://www.etalabs.net/musl/
21:38:46 <elliott> it's the hot new thing :P
21:38:55 <Cale> eduardo: But a good immediate solution to your problem is just to install ghc from http://haskell.org/ghc/download_ghc_7_0_4#x86linux and then run the bootstrap.sh script from http://hackage.haskell.org/packages/archive/cabal-install/0.10.2/cabal-install-0.10.2.tar.gz
21:39:33 <ivanm> elliott: do any other distros support it?
21:40:15 <elliott> ivanm: there are a few little mini-distros based around musl, but no, no distro supports swapping out components like the libc for largely historical reasons... isn't the whole point of Gentoo and its ilk that it's the only thing that can do such extensive customisation? :P
21:40:18 <elliott> this is kind of off-topic though.
21:40:29 <ivanm> -blah?
21:41:03 <elliott> meh, ok, just extend my tab list further :P
21:41:08 <ivanm> heh
21:41:24 <eduardo> Cale, do you recommend install ghc/cabal via source?
21:42:23 * eduardo already has a clone
21:48:13 <ivanm> eduardo: Cale uses the generic unix binary available at haskell.org/ghc
22:09:18 <ivanm> @tell chrisdone worked out my hasktags problem: had to set PATH inside emacs (couldn't work out how to do so by reading .bashrc so I gave up and used setenv) so that when it launched ghci it could use ;! and find hasktags in its PATH
22:09:19 <lambdabot> Consider it noted.
22:10:01 <auastro> Hi all
22:10:19 <auastro> kind of complex question sorry, but I've been working on it for a while and I'm totally stumped
22:10:34 * ivanm waves idly in auastro's general direction
22:10:50 <auastro> I'm trying to combine a CC-delcont CCT monad
22:10:55 <auastro> and a StateT monad
22:11:11 <auastro> but I want to be able to store the prompts inside the state monad
22:11:39 <ivanm> ummmm.... I have no idea what a "CC-delcont CCT monad" is... :p
22:12:01 <auastro> ok
22:12:07 <ivanm> and by "prompt", do you mean you're developing an interactive terminal environment?
22:12:15 <ivanm> there's a package providing a Prompt monad on hackage IIRC
22:12:28 <Cale> he means: http://hackage.haskell.org/packages/archive/CC-delcont/0.2/doc/html/Control-Monad-CC.html
22:12:33 <auastro> yeah
22:12:37 <auastro> well I'm developing a programming language
22:12:38 <ivanm> Cale: ahhh
22:13:08 <auastro> I want to be able to use delimited continuations inside my language
22:13:36 <auastro> and the way I've chosen to do it, is use delimited continuations inside the language interpreter
22:14:06 <auastro> anyway, the problem doesn't have much to do with delimted continitsions
22:14:28 <auastro> essentially the CCT monad uses Rank 2 types
22:14:44 <auastro> to make it referentially transparent from the outside
22:14:47 <Cale> hmm
22:15:14 <auastro> this obviously poses a problem because I can't store the continuations in the state monad
22:15:35 <auastro> because if I did, they could escape, because the state is produced at the end by the StateMonad
22:15:52 <Cale> Right, because that would let you do things which the types are actually trying to prevent you from being able to do, yes.
22:15:58 <auastro> exactly
22:16:58 <auastro> so basically, I think I have to either write some sort of State+CC magic monad, which I'm not about to do
22:17:01 <Cale> So here's a question to think about: can you write code with the meaning that you want without using StateT?
22:17:18 <Cale> Just passing parameters?
22:17:38 <auastro> Cale: that's a pretty good idea, maybe I should just convert all my state stuff to use an IORef
22:17:54 <auastro> wait, no that's doesn't work does it
22:17:56 <moriramar> Excuse me, I am using haskellmode in vim but got some problem. http://pastebin.com/9jzz9GVH When I open this file with gvim and press _t when cursor is on is42/main, it even cannot report their type.
22:18:08 <Cale> Oh, if you're over IO, then StateT is usually a bit silly.
22:18:16 <Cale> (at least in my opinion)
22:18:18 <moriramar> Should I do something before _t?
22:19:15 <shachaf> Cale: As opposed to Reader IORef or something of the sort?
22:19:17 <ivanm> moriramar: I don't use vim, but the code looks alright
22:19:21 <ivanm> albeit weirdly formatted
22:19:31 <Cale> shachaf: As opposed to just passing IORefs around
22:19:38 <ivanm> (and the mutual recursion using main looks odd)
22:19:56 <moriramar> ivanm, "weirdly foramtted"? ... well, i intended to make it look like that.
22:20:01 <Cale> ReaderT/WriterT/StateT are usually more trouble than they're worth over IO
22:20:05 <ivanm> moriramar: note also that "otherwise" is an alias for True for use with guards
22:20:16 <auastro> Cale: you're correct
22:20:24 <ivanm> moriramar: oh? why did you want to start a new highly indented line for "=  getLine >>= is42" ?
22:20:26 <moriramar> ivanm, i haven't got a better way to write that recursion. do you have some suggestion? thanks
22:20:34 <ivanm> rather than "main = getLine >>= is42" ?
22:21:00 <ivanm> moriramar: my general prefernce is that if you're going to do a recursion, use a helper function rather than within main
22:21:18 <moriramar> ivanm, you mean, main = f where f = xxx?
22:21:19 <ivanm> though you could possibly do something like this:
22:21:24 <ivanm> moriramar: yeah
22:21:26 <auastro> Cale: I actually had the State monad only, but I needed to be over IO so added that and never got around to changing the older code
22:22:09 <ivanm> @type let main = do { x <- getLine; unless (x == "42") (putStrLn x >> main) }
22:22:10 <lambdabot> <no location info>:
22:22:10 <lambdabot>     not an expression: `let main = do { x <- getLine; unless (x == "42") (putStrLn x >> main) }'
22:22:16 <ivanm> @type let main = do { x <- getLine; unless (x == "42") (putStrLn x >> main) } in main
22:22:17 <lambdabot> IO ()
22:22:43 <auastro> Cale: so yeah, I guess I just pass my state around stashed in an IORef
22:22:51 <moriramar> ivanm, I see. I will rewrite that. I start a new line for every >>= and = since words before them might be too long sometimes. and i don't like do-notation.
22:23:01 <Cale> auastro: Or try just passing pure parameters around, if possible.
22:23:08 <ivanm> moriramar: sure, but the usual practice is to indent them to be left of the = sign
22:23:27 <moriramar> ivanm, left? like what?
22:24:03 <Cale> auastro: Which if you can work out how to do it, should suggest a way to abstract over doing so, and you might figure out how to use the StateT transformer after all, or at least have some new ways to put things together.
22:24:14 <auastro> Cale: yeah, unfortunately I can't do that, because in the interpreted language you could close over variables, which means very non-local state changes
22:24:17 <ivanm> moriramar: e.g. your code re-formatted: http://pastebin.com/Y4dxREyu
22:24:20 <mauke> The paste Y4dxREyu has been copied to http://hpaste.org/52028
22:24:33 <ivanm> though there are still other things you could change there
22:24:48 <Cale> auastro: Yeah, so you'd be doing lots of tupling the state with results of subcomputations.
22:25:00 * ivanm wonders why mauke's script didn't trigger earlier when moriramar pated his initial version
22:25:11 <moriramar> ivanm, ahahaha
22:25:19 <ivanm> moriramar: e.g. if you have one fixed String as input to is42, I'd be tempted to just pattern-match on it
22:25:20 <auastro> Cale: which is essentially what the state monad is for
22:25:23 <moriramar> ivanm, because i am not as cute as you. :)
22:25:25 <Cale> auastro: It's probably awkward but possible. If IORef suits you fine, then there's nothing wrong with just using IORef anyway :)
22:25:31 <ivanm> cute? moi?
22:25:33 <ivanm> perish the thought!
22:25:58 <moriramar> ivanm, ... pattern-match on a actual String?
22:26:12 <ivanm> sure
22:26:21 <auastro> Cale: using the IORef doesn't quite fix everything, I still have to pass it around everywhere to prevent my continuations from escaping
22:26:36 <auastro> Cale: maybe I should write a hidden state monad.
22:26:45 <ivanm> > let is42 "42" = True; is42 _ = False in map is42 [ "42", "43"]
22:26:46 <lambdabot>   [True,False]
22:27:09 <auastro> Cale: that uses the type system to guarantee that the state it self cannot escape
22:27:24 <cheater> hi
22:27:31 <cheater> how do i get the fields out of this thing? http://hackage.haskell.org/packages/archive/vty/4.7.0.4/doc/html/src/Graphics-Vty-DisplayRegion.html#DisplayRegion
22:27:32 <moriramar> ivanm, i havn't know that. I thought i can only pattern-match them to variables and then judge them with guards. thanks.
22:27:46 <cheater> as in, i have a DisplayRegion d and want to get the region_width
22:28:15 <ivanm> cheater: region_width myDisplayRegion
22:28:20 <ivanm> or do an explicit pattern match
22:28:26 <Cale> cheater: region_width is also a function which extracts that field
22:28:28 <cheater> how do i pattern match?
22:28:33 <cheater> on this?
22:28:44 <ivanm> cheater: getRegionWidth (DisplayRegion width height) = width
22:28:49 <Cale> foo (DisplayRegion { region_width = rw } = ...
22:28:57 <Cale> er, missed a )
22:29:06 <ivanm> dammit, I was about to nit-pick you on that...
22:29:07 <ivanm> ;)
22:29:18 <Cale> You can pattern match either just by listing the things in order or using the record syntax
22:29:24 <cheater> why is ivanm's version not using braces?
22:29:33 <ivanm> cheater: because I'm not using the record fields
22:29:35 <Cale> because the record syntax is optional
22:29:36 <ivanm> just the structure
22:29:42 <shachaf> You don't even need the parentheses, do you?
22:29:46 <ivanm> note that Cale isn't bothering to mention the height in his
22:29:51 <ivanm> shachaf: no
22:29:53 <cheater> yeah
22:29:56 <moriramar> ivanm, seems a lot better now. thank you. btw, you say "indent them to be left of the = sign", what is "them"? >>= and >>?
22:29:59 <ivanm> but it usually makes it easier to read IMHO
22:29:59 <cheater> onteresting
22:30:04 <shachaf> @ty let foo Identity{runIdentity=x}=x in foo
22:30:05 <lambdabot> forall t. Identity t -> t
22:30:07 <cheater> interesting
22:30:08 <ivanm> moriramar: yup, like I did in my paste
22:30:14 <ivanm> (in the second guard)
22:30:33 <shachaf> @ty let foo (Identity){runIdentity=x}=x in foo
22:30:34 <lambdabot> Parse error in pattern
22:30:42 <auastro> Cale: there is actually nowhere for my continuation to go, because my main is basically just (runState . runCCT)
22:30:52 <ivanm> shachaf: yeah, that doesn't work though
22:30:52 <cheater> what if i'm in a do block, and want to get a pair of (h, w)?
22:30:58 <shachaf> Yep.
22:30:59 <cheater> what's the best way to do that?
22:31:01 <moriramar> ivan`, i got it. thank you!
22:31:13 <ivanm> cheater: ummm.... get both fields separately and return a pair?
22:31:17 <Cale> cheater: The thing on the left of <- is a pattern, and you can match on it
22:31:18 <ivanm> or to do it in a one liner:
22:31:22 <ivanm> @type liftM2 (,)
22:31:23 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
22:31:26 <Cale> cheater: or use let
22:31:30 <ivanm> @type liftM2 (,) length head
22:31:31 <lambdabot> forall a. [a] -> (Int, a)
22:31:31 <shachaf> @hoogle Either a a -> a
22:31:31 <lambdabot> Data.Either rights :: [Either a b] -> [b]
22:31:32 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
22:31:32 <Cale> Or case :P
22:31:33 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
22:31:42 <Cale> (but here probably let is fine)
22:31:52 <shachaf> @ty either id id -- I guess there's no shorter name for it?
22:31:53 <lambdabot> forall b. Either b b -> b
22:31:54 <cheater> cale: hmm, so i would do DisplayRegion w h <- display_bounds [ ?
22:31:56 <ivanm> cheater: I realise you won't like this suggestion, but this is usually covered in tutorials...
22:31:59 <Cale> yep
22:32:09 <cheater> i like cale's idea
22:32:09 <auastro> Cale: Maybe I should just coerce the continuations once I have them, because haskell esentially can't express a proof that there is nowhere for my continuations to go.
22:32:22 <cheater> ivanm: yes, but all tutorials suck :D
22:32:27 <ivanm> O RLY?
22:32:38 <ivanm> you have read every single tutorial that ever was and ever will be?
22:33:01 <cheater> and some that never will
22:33:07 <Cale> auastro: I have almost no experience with delimited continuations. I've played around with Cont (which doesn't use higher-rank types), but that's about it.
22:33:30 <Cale> It's curious to me that you've managed to find a use for them :)
22:33:37 <shachaf> Cale: callCC *should* use rank-3 types, shouldn't it?
22:33:53 <Cale> I dunno, maybe?
22:34:05 <ivanm> cheater: so you would rather ask us how to do every little thing you run across when all these questions have been answered numerous times in formats designed to help an individual grasp these concepts?
22:34:20 <ivanm> Cale: wait, there's something that you aren't an expert in using? :o
22:34:21 <ivanm> :p
22:34:35 <auastro> Cale: continuation monad just encapsulates a rewrite to CPS style, so it's actually safe to return a continuation from the Cont monad
22:34:36 <shachaf> callCC :: ((forall b. a -> m b) -> m a) -> m a
22:34:42 <Cale> auastro: yeah
22:35:02 <auastro> sorry that was meant to be directed at shachaf
22:35:03 <cheater> ivanm: there's something to be said about bidirectional communication
22:35:17 <ivanm> true, for specific topics
22:35:23 <shachaf> auastro: Which was?
22:35:30 <ivanm> but it does get repetitive for these kinds of rather basic areas
22:35:38 <Cale> Don't give beginners a hard time for asking questions
22:35:40 <auastro> shachaf: continuation monad just encapsulates a rewrite to CPS style, so it's actually safe to return a continuation from the Cont monad
22:35:44 <Cale> All questions welcome
22:35:47 <shachaf> Oh. Did I say it wasn't?
22:36:04 <ivanm> so whilst it may be new/novel to the person learning, it can get irritating for the person answering if they have to answer similar questions on a regular basis
22:36:29 <Cale> Everything is okay in theory as long as they pass it forward
22:36:33 <Cale> :)
22:36:36 <shachaf> Cale: By the way, a while ago we were talking about MonadExit for early-return, which it turned out to be a bad idea for -- I think the answer is just Either, with runEarlyReturn = either id id and earlyReturn = Left.
22:36:47 <shachaf> (Or Cont, of course. But Cont does everything.)
22:37:09 <auastro> I'm writing a programming language where the delimited continuation is the main data structure
22:37:27 <cheater> ivanm: and yet, your answer wasn't as good as Cale's
22:37:47 <ivanm> which answer?
22:37:51 <ivanm> we both provided several :p
22:38:04 <cheater> he told me to pattern match on the <- which was what i was looking for exactly
22:38:08 <Cale> auastro: How does that work? :)
22:38:25 <ivanm> cheater: OK, for your eventual answer
22:38:26 <cheater> this took several iterations of going back and forth and respecifying
22:38:29 <ivanm> s/answer/question/
22:38:34 <ivanm> you didn't specify which Monad you were using
22:38:34 <cheater> a tutorial doesn't give you that.
22:38:40 <cheater> yes, i have not.
22:38:57 <ivanm> nor if you were obtaining that value within the Monad
22:39:01 <cheater> i hadn't known i have had to
22:39:14 <ivanm> and I in general prefer not to do those kind of pattern matchings, unless I know I'm within the Maybe monad or something
22:39:24 <cheater> why?
22:39:41 <ivanm> as IIUC, that's why the fail method is in Monad: for when you can't pattern match on a result on the LHS of a <-
22:39:49 <bwright> \ f x . x :: (T1 => T2) => T1
22:39:51 <bwright> is that correct?
22:39:57 <bwright> or have I messed up my typing
22:40:03 <ivanm> e.g. do (a:as) <- return [] ; ...
22:40:16 <ivanm> cheater: so I was trying to give you the more general answer
22:40:17 <cheater> ah but in this situation the type ensures that i get that
22:40:24 <ivanm> rather than a more specific one that might apply to your context
22:40:37 <ivanm> in this one specific instance, yes
22:40:43 <cheater> see, a tutorial wouldn't have told me all that from this unique perspective
22:40:46 <shachaf> ivanm: Well, fail is in Monad for evil reasons.
22:40:49 <cheater> maybe you should write a new tutorial
22:40:50 <cheater> or something
22:41:07 <cheater> for other tutorially-inclined people
22:41:09 <auastro> Cale: essentially you can save a delimited continuation, then access the variables inside the continuation like it was an object
22:41:14 <ivanm> shachaf: yeah, but isn't the eventual goal to get rid of it?
22:41:27 <ivanm> cheater: I think chrisdone's tryhaskell was trying to do that
22:41:30 <shachaf> ivanm: Like the good old days of Haskell 1.4...
22:41:35 <ivanm> but he doesn't seem to be working on it more
22:41:38 <ivanm> shachaf: heh
22:42:22 <ivanm> cheater: thinks like that are things you typically end up picking up more by writing a lot of code IMHO
22:42:23 <Mathing231> If I wanted to make a math quiz at various levels for my students, are there math libraries already defining things such as the little things like quadratic formulas to the larger things like derivatives for Haskell yet?  Or, perhaps might you all recommend something like sage for a task like that?
22:42:33 <ivanm> I agree that things like this do end up coming out better in two-way communication
22:42:43 <cheater> ivanm: that's what i'm doing right now, writing code
22:42:47 <ivanm> but for bulk things like "how do I get a field out of a constructor", tutorials typically work better
22:42:56 <cheater> ivanm: so where's the objection? ;)
22:43:05 <cheater> ok
22:43:07 <ivanm> Mathing231: you're wanting something matlab-ish I take it?
22:43:23 <cheater> ivanm: but i didn't even know what to search for
22:43:35 <ivanm> cheater: which is why tutorials normally cover everything :p
22:43:37 <auastro> Cale: the delimited continuation forms sort of a cross between a closure, a continuation and an object
22:43:41 <cheater> ivanm: for example, i didn't know it's called "getting a field out of a constructor" until you mentioned it now
22:43:43 <Mathing231> ivanm: I want to be able to code using a module/library.
22:44:01 <ivanm> Mathing231: but you want that kind of interactive environment?
22:44:05 <auastro> Cale: It sort of unifies control, stack data, and heap data
22:44:10 <ivanm> if so, I don't think there is anything like that really for Haskell
22:44:17 <Mathing231> ivanm: Ideally, I'd like to implement it online, possibly to help my students learn.  So, yes.
22:44:18 <bwright> Given
22:44:20 <bwright>  [] ⊢ λx y. x :: α ⇒ β ⇒ α
22:44:24 <bwright> what is  [] ⊢ λx y. x :: α ⇒ β ⇒ α
22:44:25 <ivanm> though I seem to recall reading something about someone writing something like that recently...
22:44:28 <bwright> ugh unicode ___
22:44:30 <ivanm> some kind of plotting thing online
22:44:58 <Cale> auastro: huh, interesting.
22:44:59 <ivanm> bwright: I think that defines empty lists using church encoding
22:45:05 <bwright> Alright take this
22:45:11 <bwright> \x y. x and \x y.y
22:45:20 <ivanm> bwright: church booleans
22:45:30 <bwright> \x y. x :: (a => b) => a => b
22:45:36 <bwright> what is the typeof(\x y. y)
22:46:01 <bwright> wait fail.
22:46:02 <bwright> :(
22:46:10 <ivanm> lambda calculus doesn't always translate directly to Haskell
22:46:20 <ivanm> e.g. Y-combinator, church exponentiation
22:46:21 <ivanm> etc.
22:46:27 <bwright> \x y. x :: a => b => a, \x y. y :: a => b => b
22:46:42 <ivanm> bwright: not really
22:46:43 <Mathing231> ivanm: the graphics part doesn't concern me much.  I'd like something that would solve a specific class of problems for practice and then compares the solution to the input. for a generated problem.
22:46:48 <bwright> yes I didn't think so.
22:46:51 <ivanm> bwright: \ x y . x :: a -> a -> a
22:46:55 <bwright> No.
22:47:04 <bwright> [] ⊢ λx y. x :: α ⇒ β ⇒ α
22:47:10 <bwright> [x ← α] ⊢ λy. x :: β ⇒ α
22:47:13 <ivanm> oh, right
22:47:17 <bwright> [x ← α, y ← β] ⊢ x :: α
22:47:19 <bwright> So that is false.
22:47:22 <ivanm> yeah, it's been a while since I've done that stuff
22:47:24 <auastro> Cale: anyway I won't take any more of you're time, but I think that I need to either write a hidden state monad, or just unsafe coerce on the "thread" type, because I know it's safe.
22:47:27 <bwright> But I am just confused about the other way around
22:47:28 <bwright> :(
22:47:31 <ivanm> (but I think I might be tutoring it in a couple of weeks... :p)
22:47:40 <bwright> nice.
22:48:02 <bwright> oh I am dumb
22:48:03 <bwright> nvm
22:48:17 <auastro> Cale: or just pass the state around everywhere, but I really don't want to do that, because I would require rewriting a lot of code
22:49:55 <Mathing231> ivanm: Perhaps a better question, how can I differentiate a function in Haskell?
22:50:13 <auastro> member:identifier:mathing231: symbolically or numerically?
22:50:37 <auastro> * sorry editor fart
22:50:39 <Mathing231> symbolically  ex: ax^n + bx + c
22:50:52 <ivanm> Mathing231: there is some old symbolic manipulation stuff written in Haskell
22:51:01 <ivanm> not sure how good it is though
22:51:11 <ivanm> there might even be some libraries that do it
22:51:13 <ivanm> @where hayoo
22:51:14 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
22:51:17 <Cale> Mathing231: Well, depends on your representation of the function.
22:51:21 <ivanm> ^^ try searching for things like derive, differentiate there
22:51:50 <Mathing231> Cale: sin(tan(x))*x^(sin(x))
22:51:53 <Cale> Mathing231: How are you representing that thing? As an expression tree? As a literal function Double -> Double?
22:52:04 <Cale> As a string?
22:52:11 <Mathing231> yes, a string
22:52:15 <Mathing231> It'd have to be user input
22:52:18 <Cale> Well, first you need to parse it
22:52:23 <Mathing231> right
22:52:24 <Cale> and form an expression tree
22:52:46 <Cale> and then once you have an expression tree, the usual rules for differentiation are typically quite easy to implement
22:53:17 <Cale> The only somewhat tricky part is simplifying the result to the point where it's sane to read, but a few ad-hoc rules tend to go a long way there.
22:53:21 <Mathing231> easy enough, it's just a question of whether or not those things are defined already or whether I should attempt solving only specific problem sets that I choose.
22:54:24 <auastro> Mathing231: there are a few open source computer algebra systems, perhaps you could use them in tandem with your course
22:55:07 <Mathing231> I'm considering working directly with sage.
22:55:13 <auastro> Mathing231: or do you really want to do everything in haskell?
22:55:36 <bwright> ivanm:  Γ[x ← τ1 ] ⊢ t :: τ2 Γ ⊢ (λx. t) :: τ1 ⇒ τ2
22:55:44 <bwright> ivanm: that is the abstraction axiom for type checking
22:55:47 <ivanm> yeah, I don't remember that much :)
22:55:48 <orclev> anyone know what the appropriate channel is to ask a question about nickserv? is there like a freenode ops channel?
22:55:49 <Cale> Of course, one option, if the thing is allowed to be Haskell code, is implementing Num and other classes for your expression type to produce values of your expression datatype from what looks like numerical Haskell expressions :)
22:55:49 <Mathing231> Oh, no, not at all, I want the best/most practical solution that can grow into the best tool.
22:56:01 <Cale> > x^2 + y^2 :: Expr
22:56:02 <lambdabot>   x * x + y * y
22:56:03 <ivanm> orclev: yeah, I think so
22:56:05 <bwright> ivanm: It explains it though.
22:56:23 <Cale> ^^ though that Expr isn't a good one for your use, as it's just strings
22:56:26 <auastro> Cale: DSL for the win!
22:56:49 <Cale> > foldr f z [1..5]
22:56:50 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
22:57:03 <ivanm> orclev: look on the freenode website?
22:57:49 <auastro> > foldr (*) z [1..5]
22:57:50 <lambdabot>   1 * (2 * (3 * (4 * (5 * z))))
22:58:41 <auastro> Cale: cool! is that a lambdabot only feature? can I run it locally?
22:58:43 <ivanm> @hoogle Seq a ->  Bool
22:58:44 <lambdabot> Data.Sequence null :: Seq a -> Bool
22:58:44 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
22:58:44 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
22:59:57 <Cale> auastro: http://hackage.haskell.org/package/simple-reflect
23:00:01 <orclev> ivanm: thanks, found the info I needed on the freenode site... in the FAQ of all places... suprisingly rare that a question I have is actually answered in a FAQ
23:00:18 <ivanm> heh
23:00:32 <orclev> turns out my nick expired and someone sniped it out from under me, oh well, maybe it'll expire again and I can snipe it back
23:00:51 <auastro> Cale: thanks!
23:00:54 <auastro> bye all
23:01:11 <orclev> is there a channel sepcifically for haskell platform, or would a question about it be appropriate here?
23:01:24 <shachaf> orclev: Here is probably fine.
23:01:38 <shachaf> The alternative would be #ghc if it's about GHC, possibly.
23:02:05 <ivanm> well, for bug-reports and internals of GHC
23:02:07 <orclev> ok, I was looking at the release schedule, and according to it, the next version was supposed to have been released a few months ago... is the site just out of date and no one has bothered to update it?
23:02:07 <ivanm> just using GHC is here
23:02:15 <ivanm> orclev: pretty much
23:02:32 <ivanm> orclev: note that GHC 7.2.1 is a preview release and not intended for end users
23:03:01 <shachaf> That's why the minor version number, 2, is odd.
23:03:10 <ivanm> shachaf: heh
23:03:13 <orclev> yeah, I'm running 7.0.3 right now... unfortunately it has a nasty bug that's causing me some issues, but the bug has been fixed in later versions
23:03:29 <shachaf> ivanm: That kind of sounds like an after-the-fact thing when everyone had problems with the release.
23:03:32 <ivanm> orclev: just install 7.0.4 and whatever libraries, etc. you need yourself
23:03:42 <ivanm> shachaf: it was announced like that IIRC
23:03:47 <ivanm> 7.4 should be coming out soon now
23:03:56 <ivanm> (they were waiting until after ICFP I think)
23:04:34 <orclev> is the next release of haskell platform waiting on 7.4 then?
23:04:47 <ivanm> I think so
23:05:09 <ivanm> they were going to do one on 7.0.4, but they were busy and were expecting 7.4 to come out soon anyway
23:06:25 <cheater> what does 7.4 bring in comparison to 7.0.4?
23:09:25 <ivanm> cheater: well, it will have most of the features in 7.2
23:09:35 <ivanm> but since it isn't out yet, who knows? :p
23:10:25 * orclev is having the hardest time finding release notes for GHC...
23:10:53 <shachaf> @google ghc 7 release notes
23:10:54 <lambdabot> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/release-7-0-1.html
23:10:54 <lambdabot> Title: 1.5.�Release notes for version 7.0.1
23:13:08 <orclev> ah, I see, you need to navigate to the users guide and it's inside of that... users guide always takes you to the latest release it looks like though, so that's a bit annoying
23:13:33 <ivanm> orclev: but I think it contains release notes for older versions (at least for point changes)
23:13:43 <cheater> ivanm: :p
23:14:46 <Mathing231> Cale: I'm struggling to see the implications of what you meant, but my guess is that it was for developing the expression tree?
23:15:05 <cheater> hey guys, if i have a module declared like this: "module X.Y (module X.Y.Z)" and in my module i do "import qualified X.Y as Y" then how do I access the Z?
23:15:23 <ivanm> cheater: all of Z is now part of Y
23:15:31 <cheater> oh really?
23:15:32 <cheater> hmm
23:15:33 <ivanm> you can't differentiate between the stuff exported by Z
23:15:36 <ivanm> cheater: yeah
23:15:42 <cheater> ok, makes sense
23:15:42 <cheater> thanks
23:15:45 <ivanm> so if X.Y.Z exports foo, then you have Y.foo
23:16:00 <ivanm> cheater: see, stuff like that _isn't_ always as explicitly covered in tutes... :p
23:16:32 <orclev> ok, so it looks like 7.4 (based on what's in 7.2) will likely add DPH support, the "Safe" extension to support better sandboxing, Compiler Plugins, and a dozen or so language changes/tweaks
23:16:40 <cheater> ivanm: how should i know
23:16:54 <ivanm> cheater: read a tute, then ask any questions you have after reading it :p
23:16:59 <cheater> ivanm: i just skip all that and encircle the mine field with a ten mile radius
23:17:01 <cheater> :D
23:17:05 <ivanm> heh
23:17:52 <ivanm> cheater: OK: if it's something basic (as in what you'd expect for first year uni students who've never programmed before and thus only write one or two module programs by the end of it), it'd be in a tute
23:18:21 <ivanm> if its' more complex (organisational, monads, extensions, etc.) then it probably won't be (though maybe in RWH)
23:19:09 <ivanm> cheater: as for me biting your head off earlier: I think in part that might have been from a few years back when we had HaskellLove in here, who wanted to learn Haskell just by asking us questions so he could do Project Euler
23:19:16 <orclev> since haskell tends to be a bit tougher than a lot of other languages in terms of learning curve I've found quite a few tutorials that cover a lot of the more complex aspects as well
23:19:23 <ivanm> so I think that kinda put me off people asking repeated "basic" questions here :/
23:19:29 <cheater> ivanm: i don't know what would be in a first year uni course
23:19:39 <ivanm> orclev: yeah, but not always as well organised
23:20:00 * ezyang personally thinks it should always be OK to ask for, at least, a Google term. 
23:20:05 <orclev> ivanm: true, and you tend to have to do a lot of digging on your own... lots of time spent with google
23:20:13 <ivanm> ezyang: *nod*
23:20:22 <ivanm> cheater: hmmmm.... basic usage of functions, data structures, etc.
23:20:43 <cheater> ivanm: i understand "basic usage of functions" as calling functions with parameters
23:20:46 <cheater> that's all
23:20:54 <ivanm> cheater: right
23:20:55 <cheater> anything beyond is wildly different from anything i've known before
23:20:58 <ivanm> I meant also defining them
23:21:05 <cheater> even defining them is different.
23:21:14 <ivanm> even an idea of what functions are in the Prelude
23:21:21 <ivanm> cheater: so tutorials cover that ;)
23:21:32 * orclev finally figured out the concept that (->) is a type a week or so ago... suddenly the Arrow class made a whole lot more sense
23:21:50 <ivanm> but yeah, I do have a kind of vague idea about doing a tutorial/online book which focusses on developing one specific library/field
23:22:06 <ivanm> but since not that many people are interested in graph theory... :P
23:22:17 <ivanm> orclev: heh
23:22:29 <orclev> learn you a haskell really helped me when I first started
23:23:27 <akosch> are there any powerful template languages out there for html (loops, conditions, etc.)? I would need the template files to be compiled at runtime, because the user needs to edit them and doesn't have ghc installed...
23:24:09 <orclev> akosch: snap uses one that's runtime compiled I think... need to go lookup what it is
23:25:00 <orclev> akosch: heist, looking up the details of it now
23:25:45 <akosch> orclev: thanks!
23:26:42 <orclev> akosch: may not be powerful enough for you... I didn't see much support for looping or other control statements, although I did just give the documentation a quick once over so I might have missed it
23:29:06 <akosch> orclev: hm, I can't seem to find the documentation at all. could you please paste a link to it?
23:29:45 <orclev> akosch: http://snapframework.com/docs/tutorials/heist
23:30:03 <orclev> akosch: there's probably some API docs floating around there as well
23:30:37 <orclev> akosch: http://hackage.haskell.org/package/heist
23:32:46 <akosch> orclev: thanks, it seems to support some kind of looping via runNodeList (but not really inside the template)
23:33:06 <akosch> orclev: guess I'll have to install PHP then ;)
23:33:55 <orclev> akosch: if you can get around the runtime compile requirement yesod has Hamlet which has full support for just about everything in the template (and it type safe to boot)
23:35:39 <akosch> orclev: sadly I can't see how I could get around that
23:35:42 <ivanm> akosch: there's the ones in Yesod
23:35:45 <ivanm> Hamlet, etc.
23:36:00 <ivanm> they all use Template Haskell and are thus verified, etc. at compile time
23:36:11 <ivanm> oh, wait, you wanted at _runtime_
23:36:14 <orclev> ivanm: yeah, just mentioned that :P... one of his requirements was runtime parsing of the tamplae
23:36:19 <ivanm> I missed that
23:36:41 <ivanm> having a run-time templating engine requires the compiler to be there
23:36:51 <ivanm> you could always take a wiki approach using gitit...
23:38:02 <akosch> orclev: suppose I wanted to write my own, do you by any chance know any nice ones (not necessarily for haskell) which I could base my syntax on?
23:38:47 <akosch> ivanm: wiki approach? doesn't sound like it supports loops/conditions
23:39:00 <ivanm> no
23:39:22 <ivanm> akosch: the Shakespeare (from Yesod) languages seem to have nice syntax
23:39:43 <ivanm> but wouldn't it just be easier to install GHC, etc. than write your own templating language implementation? :p
23:40:24 <ivanm> that said, I don't do any web stuff (apart from a very simple static website using pandoc)
23:40:32 <akosch> ivanm: installing ghc is not an option. :(
23:40:45 <ivanm> why not?
23:40:48 <orclev> akosch: if you're going to roll your own, I'd recommend finding some C templating language and just writing bindings too it... it's either that or if you're using haskell getting comfortable with the likes of alex/happy
23:40:49 <ivanm> (just curious)
23:41:02 <ivanm> orclev: why alex/happy?
23:41:13 <ivanm> uu-parsinglib, polyparse, parsec, ...
23:41:33 <ezyang> It depends on what you're trying to do. Parser generators can be useful.
23:41:34 <ivanm> alex/happy are only useful if you have a full grammar for the language
23:41:46 <ivanm> ezyang: he wants to write his own HTML templating language
23:42:09 <orclev> ivanm: I wasn't sure how much control he wanted, he mentioned looping and control statements
23:43:15 <akosch> another approach would be to use something in javascript: I could compile my templates in the browser and send them to the server in both plain and compiled form
23:43:53 <cheater> that sounds like such a bad idea
23:43:57 <ivanm> yeah
23:44:05 <akosch> cheater: yeah, I have that bad feeling about it too
23:44:07 <ivanm> akosch: why do you want user-editable HTML templates?
23:44:15 <ivanm> especially with loops and conditionals?
23:44:25 <cheater> few cmses have that
23:45:39 <akosch> because I'm generating something else from the HTML and I want to give the user much control about it with a reasonably simple interface (e.g. easy to write)
23:46:45 <cheater> :t Graphics.Vty.update
23:46:46 <lambdabot> Couldn't find qualified module.
23:46:51 <ezyang> Huh.
23:47:08 <cheater> :t Graphics.Vty.mkVty
23:47:09 <lambdabot> Couldn't find qualified module.
23:47:13 * ezyang suddenly at this funny idea that you could easily make a provably terminating templating language with loops based on structural recursion. 
23:47:16 <ivanm> cheater: lambdabot doesn't have all modules available
23:47:23 <cheater> yeah
23:47:36 <cheater> i'm lost now
23:47:48 <Rmx> Hi, how can I use a dll in haskell code?
23:47:52 <ezyang> Sorry, ignore me, cheater :-)
23:47:54 <cheater> how do i use the "update" function mentioned here? http://hackage.haskell.org/packages/archive/vty/4.7.0.4/doc/html/Graphics-Vty.html
23:48:02 <ivanm> Rmx: as in a non-Haskell .dll?
23:48:03 <Rmx> I want to use FMOD for sound
23:48:05 <cheater> what is it, just a function?
23:48:10 <Rmx> hm..
23:48:18 <ezyang> cheater: Yes.
23:48:22 <ivanm> Rmx: you'd probably need to write FFI bindings
23:48:23 <Rmx> ok.. I'll first look more in detail :)
23:48:24 <ezyang> More specifically, it's a field accessor.
23:48:29 <cheater> i tried but giving it a Picture gives me a type error
23:48:33 <Rmx> ok
23:48:44 <Rmx> I go to take a look at what's a FFI binding
23:48:48 <orclev> the FFI support in haskell is awesome, I wish other langauges did as well
23:48:52 <cheater> *i tried giving it a Picture but that gives me a type error*
23:48:59 <cheater> i guess that's a bit more intelligible.
23:49:14 <ezyang> so its true type is Vty -> Picture -> IO ()
23:49:18 <ivanm> Rmx: see the chapter in Real World Haskell
23:50:25 <Rmx> thanks:)
23:51:21 <cheater> ezyang: ah
23:52:59 <cheater> ezyang: ok, that makes a lot more sense
23:53:17 <akosch> something like this would be nice for my template problem from earlier: http://velocity.apache.org/engine/releases/velocity-1.5/user-guide.html#what_can_velocity_do_for_me
23:53:26 <cheater> ezyang: are field accessors a special feature in haskell?
23:53:36 <cheater> ezyang: or are they just something defined by the user?
23:53:48 <ivanm> cheater: Haskell
23:53:57 <ivanm> note that you can use them to do updates
23:54:29 <ivanm> data Foo = Bar { baz :: Int }; ...... setZero foo = foo { baz = 0 }
23:54:45 <ivanm> but there's no nice in-built way to apply a function to a field
23:54:58 <ivanm> that's what prompted the development of data-accessor, lenses, fc-labels, etc.
23:55:12 <ivanm> which use TH to generate setter functions, etc.
23:55:18 <orclev> akosch: also look at freemarker
23:55:23 <cheater> aha
23:55:31 <cheater> does data-lens use TH too?
23:56:44 <cheater> @undo do let i = x; foo i
23:56:44 <lambdabot>  Parse error at end of input
23:56:53 <cheater> @undo do {let i = x; foo i}
23:56:53 <lambdabot>  Parse error at "}" (column 21)
23:57:08 <cheater> huh?
23:57:17 <ivanm> @pl \ x -> maybe x g $ f x
23:57:18 <lambdabot> ap (flip maybe g) f
23:57:22 <cheater> @undo do {let i = x in foo i}
23:57:23 <lambdabot> let { i = x} in foo i
23:57:45 <akosch> orclev: interesting... I'm thinking how I could get around this "object" approach used in these template systems, maybe use JSON objects instead?
23:59:57 * hackagebot combinat 0.2.4.1 - Generation of various combinatorial objects.  http://hackage.haskell.org/package/combinat-0.2.4.1 (BalazsKomuves)
23:59:58 * hackagebot digestive-functors-blaze 0.1.1.0 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.1.1.0 (JasperVanDerJeugt)
