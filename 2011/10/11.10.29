00:02:25 <ibid> mainly because of laziness issues
00:04:06 <hpaste> Harishankar pasted ‚ÄúNumber to (Indian) system of words‚Äù at http://hpaste.org/53269
00:04:47 <vharishankar> Wow, I cannot believe I did that program...
00:05:13 <vharishankar> Number to words: http://hpaste.org/53269 (indian system)
00:05:47 <salisbury> any recommendations on a yaml package?
00:13:03 <vharishankar> Why so quiet
00:24:11 <vharishankar> Having started learning haskell only for a few days, I'm impressed at how easily I can mentally model a problem in the functional way...
00:24:47 <vharishankar> Of course this is not to say I've really got the more advanced concepts yet
00:30:13 <Veinor> man i really hope someone ports hint to 7.2 soon
00:31:36 <dobblego> hint or hlint?
00:32:19 <c0w> hlindt
00:33:15 <Veinor> dobblego: hint
00:33:41 <Veinor> as far as i know hlint wouldn't need any work to deal with a new ghc
00:34:21 <c0w> hlindtor
00:34:24 <gienah> Veinor: hint builds with ghc 7.2 from the secret repo: http://darcsden.com/jcpetruzza/hint
00:35:14 <Veinor> ooh
00:45:26 * hackagebot cblrepo 0.3.0 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.3.0 (MagnusTherning)
00:51:34 <jtannenbaum> what's the standard cartesian product function, if one exists?
00:51:48 <dobblego> liftM2 (,) ?
00:51:50 <shachaf> jtannenbaum: Depends on what sort of cartesian product you want.
00:51:54 <shachaf> There's liftM2 (,)
00:52:06 <shachaf> You can always use a list comprehension or something.
00:52:10 <shachaf> Or lift a different function.
00:53:12 <jtannenbaum> I just did pduct xs ys = [(x, y) | x <- xs, y <- ys]
00:53:21 <jtannenbaum> surprised there isn't a standard/prelude function
00:54:13 <c0w> typically you don't want the actual pairs
00:54:14 <dobblego> that is liftM2 (,)
00:54:15 <jtannenbaum> haven't learned about monads yet so
00:54:17 <c0w> you want to apply a function to them
00:54:20 <Maxdamantus> Then you'd probably expect a 3D one.
00:54:25 <c0w> and liftM2 does that
00:54:27 <jtannenbaum> true; I'm coming from python
00:54:27 <dobblego> that is liftM2 (,) xs ys
00:54:30 <c0w> liftM3 does three
00:54:35 <c0w> you can also do arbitrarily many of them
00:54:58 <c0w> > sequence [[1,2,3],[4,5],[7,8],[9,10]]
00:54:59 <lambdabot>   [[1,4,7,9],[1,4,7,10],[1,4,8,9],[1,4,8,10],[1,5,7,9],[1,5,7,10],[1,5,8,9],[...
00:55:16 <c0w> or with different types if you use <*> or similar
00:55:20 <JoeyA> There's also (,,,,) <$> a <*> b <*> c <*> d <*> e
00:55:36 <JoeyA> (which requires an Applicative instance)
00:56:09 <JoeyA> > (,,) <$> [1,2] <*> [3,4] <*> [5,6]
00:56:11 <lambdabot>   [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
00:57:58 <vharishankar> I am not sure how to fix the spacing problem in this one: http://hpaste.org/53269 (there are sometimes more than one space between words)
00:59:10 <Maxdamantus> Probably in the case of 0 digits.
00:59:45 <vharishankar> Maxdamantus: not sure ??
01:04:25 <Maxdamantus> vharishankar: no.
01:04:45 <Maxdamantus> vharishankar: where do you appear to get more than one space between a word?
01:05:03 * ddarius exposes the compiler to his language.
01:05:13 <vharishankar> I modified the program again, so I will paste the new one again
01:08:29 <Maxdamantus> vharishankar: I think you'd just need to make a special case for n == 0: st
01:08:34 * Maxdamantus shrugs.
01:08:49 <vharishankar> Maxdamantus: I added a case for that
01:09:15 <vharishankar> I think it would be easier just to remove the redundant spaces with another function
01:09:39 <vharishankar> instead of adding the logic in the code for generating the phrase
01:10:01 <Sgeo|web> Can you make an applicative instance that handles multiple infinite lists sanely?
01:10:35 <Maxdamantus> Just make the function return the list of words, then use the `words` function on it.
01:10:53 <Maxdamantus> unwords*
01:10:58 <Veinor> Sgeo|web: http://hackage.haskell.org/packages/archive/control-monad-omega/0.2/doc/html/Control-Monad-Omega.html
01:11:00 <Veinor> ?
01:11:26 <vharishankar> Maxdamantus: that sounds a better idea
01:11:35 <Sgeo|web> Veinor: Ooh, thanks
01:11:45 <Sgeo|web> Why was I being told that it's mathematically not a monad or something?
01:11:47 <vharishankar> > words ["abc", "def" ]
01:11:49 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
01:11:49 <lambdabot>         against inferred type...
01:12:05 <Veinor> it might not satisfy the laws or something? i don't know
01:12:26 <Maxdamantus> > unwords ["one", "hundred", "thousand"]
01:12:27 <lambdabot>   "one hundred thousand"
01:12:58 <shachaf> > (unwords . words) "ab c "
01:13:00 <lambdabot>   "ab c"
01:13:15 <vharishankar> Maxdamantus: thanks. I now got it
01:13:38 <vharishankar> My program uses one lakh to denote one hundred thousand :)
01:13:42 <vharishankar> Indian system.
01:13:46 <kmc> Omega only satisfies the laws if you promise not to care about the order of results
01:14:55 <Maxdamantus> Is that used in "Indian English", too?
01:15:01 <Sgeo|web> Order of results?
01:15:22 <kmc> right, you can "run" an (Omega a) and get an [a]
01:15:43 <vharishankar> Maxdamantus: yes?
01:16:13 <Maxdamantus> http://en.wikipedia.org/wiki/Indian_English#Numbering_system
01:16:13 <kmc> and operations which are supposed to be no-ops for monads ‚Äî applying (>=> return) or (return >=>) or re-associating (f >=> (g >=> h)) to ((f >=> g) >=> h) ‚Äî can change the order of results in that list
01:16:15 <Maxdamantus> Fun.
01:16:19 <jtannenbaum> the on function from Data.Function reminds me of mathematics.. I assume the name is from that
01:16:20 <vharishankar> Maxdamantus: Indian system 100,000 = one lakh 1,00,000 (we use commas differently too)
01:16:23 <kmc> but not the set of members of that list
01:16:37 <kmc> jtannenbaum, what is it in maths?
01:16:46 <Sgeo|web> So, I might get an ['a', 'b'] and a ['b', 'a'], and if I consider them the same it satisfies the Monad laws?
01:16:48 <kmc> i thought the name was just so it reads well in e.g. (compare `on` snd)
01:16:52 <Sgeo|web> That should really be in the documentation
01:16:53 <kmc> yeah
01:16:56 <kmc> isn't it?
01:17:13 <kmc> "Warning: Omega is only a monad when the results of runOmega are interpreted as a set; that is, a valid transformation according to the monad laws may change the order of the results. However, the same set of results will always be reachable."
01:17:29 <jtannenbaum> ((==) `on` (>0)) sort of means "equal on the area/feild/group/whateverthing where >0 determines an element's characteristic"
01:17:46 <jtannenbaum> I don't know anything about groups or feilds so don't hurt me
01:17:48 <vharishankar> I will rewrite my program to use list instead of one single string
01:18:13 <kmc> jtannenbaum, I think you're just applying what I said to a math example
01:18:15 <kmc> but sure
01:18:19 <Sgeo|web> kmc: where are you seeing that?
01:18:34 <kmc> http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html
01:18:41 <kmc> module docs for the latest version
01:18:44 <jtannenbaum> I didn't start talking about `on` because of anything you said, it was a general comment from reading lyah
01:19:08 <kmc> i meant (compare `on` snd)
01:19:20 <jtannenbaum> ooh
01:20:11 <vharishankar> Maxdamantus: Thanks once again for the guidance.
01:24:10 <ziman> @quote gentle.introduction
01:24:11 <lambdabot> kmc says: i started to read the "tutorial" and it was incomprehensible. makes the Gentle Introduction to Haskell look like Teach Yourself PHP in 24 Hours
01:25:14 <kmc> (regarding the tutorial for ATS)
01:26:07 <companion_cube> :D
01:26:38 <companion_cube> were they prove their quicksort, but the proof is horrible?
01:28:17 <ziman> my gf was looking for an alternative to lyah and she picked the "gentle introduction" so I had to explain. :)
01:28:57 <jtannenbaum> I'm confused what this is all saying about lyah and this gentle introduction
01:46:35 <kmc> THUNK
01:48:26 <arcatan> the sound of evaluating Haskell?
01:48:59 <kmc> yes
01:49:06 * kmc falls into a BLACKHOLE and is never seen again
01:50:58 * companion_cube bumps the thread evaluating kmc 
01:51:37 <arcatan> when i was young and learning Haskell, we didn't have these LYAHs or RWHs, only the gentle introduction :|
01:52:07 * kmc too
01:52:15 <kmc> i got by; i used these exercises
01:52:17 <kmc> @where cs11
01:52:17 <lambdabot> http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
01:52:21 <kmc> there are 5 sometimes
01:52:31 <arcatan> well, there was YAHT too, that was pretty decent
01:53:38 <kmc> i read _All About Monads_ too
01:53:48 <kmc> which was helpful, though it's confusing or downright wrong in some places
01:53:53 <kmc> it at least gives you an example for each mtl monad
01:56:44 <arcatan> the examples were nice, otherwise I didn't understand anything. (I wasn't super clever back then, unlike now.)
02:23:12 <zhulikas> danny1 is a bot
02:23:15 <zhulikas> advertising some stuff
02:39:26 <Abraxas> can someone tell me what the g in this function does: reverse xs = foldr (\x g y -> g (x : y)) id xs []
02:40:43 <Abraxas> without renaming: reverse bs = foldr (\b g x -> g (b : x)) id bs []
02:41:31 <Abraxas> and why the id is needed
02:41:40 <Abraxas> or how any of this works, really :D
02:42:50 <kmc> do you understand foldr generally?
02:43:17 <Abraxas> i think so
02:45:37 <kmc> @type foldr
02:45:38 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:45:55 <kmc> so that lambda has 3 arguments, but the type (a -> b -> b) suggests only 2 arguments
02:46:11 <kmc> the reason is that b (the accumulator type) itself is a function
02:46:33 <kmc> :t let ff x g y = g (x : y); rev xs = foldr ff id xs [] in ff
02:46:34 <lambdabot> forall a t. a -> ([a] -> t) -> [a] -> t
02:46:41 <kmc> that's the type of the lambda term
02:46:49 <kmc> so b = [a] -> t
02:48:06 <kmc> so your foldr accumulator is a function
02:48:08 <Saizan> adding rev to that let didn't change the type of ff, btw
02:48:21 <kmc> and "id" is the 'initial value' of the accumulator, and is also a function
02:56:14 <Abraxas> id is needed to correctly complement the type definition, right?
02:56:28 <kmc> *nod*
02:57:34 <kmc> ok i'm improvising this explanation as i go but
02:57:35 <Abraxas> only recently learned that you can always chop up the type def in two parts and solve argument/result domain or whatever it's called
02:57:37 <hpaste> kmc pasted ‚Äúsome folds‚Äù at http://hpaste.org/53270
02:58:03 <kmc> if you play with that "go" function in ghci you'll find that
02:58:08 <kmc> go xs ys ‚â° reverse xs ++ ys
02:58:36 <kmc> QuickCheck is a good way to test such intuitions also
02:59:35 <kmc> so at each step of the fold, the accumulator is a function that will take y and will append the reverse of the list we've seen so far onto y
02:59:38 <kmc> on the left
02:59:48 <kmc> which is why in the end we apply it to []
02:59:53 <kmc> to append the reverse of the whole list onto []
03:00:11 <kmc> now how does this 'go' function actually work
03:00:14 * kmc ponders
03:00:48 <ben> Veinor: do you work with google yet
03:00:49 <kmc> go (x:xs) ys = go xs (x:ys)
03:01:35 <kmc> yes that makes sense
03:01:55 <kmc> (reverse (x:xs) ++ ys) ‚â° reverse xs ++ (x:ys)
03:03:10 <kmc> ok so i understand how it works but not how someone would come up with it :)
03:03:25 <Abraxas> yeah exactly :D
03:03:27 <Saizan> one could also explain this by writing reverse with foldl and then showing how foldl is written with foldr
03:03:33 <Abraxas> i mean, i don't understand how it works, yet, either
03:03:58 <Abraxas> yeah, foldl to foldr conversion
03:04:08 <Abraxas> if you understand that
03:04:42 <Abraxas> there is a good explanation on stackoverflow, but i need so many more to understand it
03:04:51 <Abraxas> *much more
03:05:54 <Saizan> ?type \f z xs -> foldr (\x k acc -> k (f acc x)) id xs z
03:05:55 <lambdabot> forall a a1. (a1 -> a -> a1) -> a1 -> [a] -> a1
03:06:30 * kmc resolves again to read "Adjoint Folds and Unfolds"
03:06:54 <Abraxas> thanks!
03:07:07 <Abraxas> i'll look at it later
03:10:28 <kmc> there ought to be a derivation of that one, starting with the ordinary code for foldl, and then replacing pattern-matching by the church encoding of lists, which is foldr
03:10:31 * hackagebot json-builder 0.2.3 - Data structure agnostic JSON serialization  http://hackage.haskell.org/package/json-builder-0.2.3 (LeonSmith)
03:14:33 <jtannenbaum> I'm playing around, and I'm getting "non-exhaustive patterns in function" for quicksortBy f (x:xs) = if null xs then [] else (quicksortBy f (filter (f x) xs)) ++ [x] ++ (quicksortBy f (filter (not . (f x)) xs))
03:15:10 <jtannenbaum> my regular quicksort with <= and > works fine when put like this
03:18:02 <kmc> "if null xs" is a red flag
03:18:12 <kmc> it means you probably should be pattern-matching on xs instead
03:18:19 <kmc> you should run ghc always with -Wall
03:18:27 <kmc> and it will tell you which patterns were not matched
03:18:44 <kmc> you don't have a case for quickSortBy f []
03:20:35 * hackagebot hstyle 0.2.0.2 - Checks Haskell source code for style compliance.  http://hackage.haskell.org/package/hstyle-0.2.0.2 (JasperVanDerJeugt)
03:21:58 <jaspervdj> https://github.com/mightybyte/hstyle/commit/0f65b451f8682c96075f062b91fc276c2184de98
03:22:10 <jaspervdj> ugly hacks for haskell-src-exts :-(
03:22:34 <kmc> :(
03:23:35 <kmc> jtannenbaum, also I think your handling of the 'null' case is not correct either
03:23:42 <kmc> it means that quicksortBy f [x] = []
03:24:22 <kmc> i don't think you need a special case for null xs
03:24:37 <kmc> filter p [] = []
03:24:45 <kmc> so quicksortBy f (filter p []) = []
03:25:04 <kmc> so you get [] ++ [x] ++ [] which is [x] which is correct
03:26:57 <jtannenbaum> thanks, I'll try
03:35:40 <jtannenbaum> oh I think this is hilarious http://paste.pound-python.org/show/14402/
03:36:14 <jtannenbaum> unless I'm thinking wrong haskell seems to think it's solved Collatz?
03:36:18 <Saizan> Abraxas, kmc: the derivation goes like this http://hpaste.org/53272
03:37:57 <kmc> hehe "16:1: Warning: Use foldr"
03:37:57 <kmc> thanks HLint!
03:39:03 <kmc> cool Saizan
03:39:22 <kmc> jtannenbaum, :)
03:39:36 <Feuerbach> jtannenbaum: no, it just isn't smart enough to see that 'even' and 'odd' cover all cases
03:39:43 <jtannenbaum> ah yea
03:39:48 <Saizan> i hope the "you know that .." isn't too handwavy
03:40:07 <kmc> jtannenbaum, i'd use "otherwise" for the second guard
03:40:11 <Feuerbach> jtannenbaum: simply replace "odd n" with "otherwise"
03:40:22 <kmc> there's no need to check if the number is odd after you know it's not even
03:40:37 <jtannenbaum> true.. this is what lyah had anyways
03:40:40 <kmc> though your version does read nicer as mathematics
03:40:44 <kmc> *nod*
03:41:06 <kmc> if you want to shut up the warning you can put in chain _ = error "Can't happen"
03:41:16 <kmc> at the bottom
03:41:20 <kmc> of course now the warning is useless for finding real mistakes ;)
03:41:59 <kmc> any code i'm actually shipping, i try to make Wall-clean, so I'll put in such cases with an error message that uniquely identifies the location
03:42:07 <kmc> and maybe a comment to explain why that case is impossiblee
03:42:17 <hpaste> angstrom pasted ‚Äúproblem with Nothing in a Parser‚Äù at http://hpaste.org/53273
03:44:51 <asfandahmed4> my assignment is to make a simple database application in c++
03:50:00 <hpaste> angstrom annotated ‚Äúproblem with Nothing in a Parser‚Äù with ‚Äúproblem with Nothing in a Parser (annotation)‚Äù at http://hpaste.org/53273#a53274
03:50:08 <angstrom> sweet :-)
03:54:40 <kmc> what's the problem angstrom?
03:55:28 <angstrom> kmc: just solved it. I was trying to do `liftM Nothing', which didn't work. :i Monad gave me the right hint, though ;-)
03:55:40 <angstrom> btw, is there an operator for `liftM`?
03:55:50 <kmc> <$>
03:55:56 <kmc> liftM and (<$>) and fmap are all the same
03:56:02 <kmc> conceptually
03:56:14 <kmc> liftM works on Monads, the other two on Functors
03:56:25 <angstrom> yeah. but that doesn't matter?
03:56:26 <kmc> every Monad should be an instance of Functor but this is not guaranteed, for dumb historical reasons
03:56:36 <angstrom> I see
03:57:18 <kmc> according to some people, 'map' and (.) should also be made aliases for fmap :)
03:57:49 <angstrom> afaik, map was once an alias for fmap, no?
03:58:00 <kmc> in Haskell 1.4 or earlier? likely
03:58:10 <angstrom> yeah. something like taht
03:58:42 <wavewave> hihi
04:00:38 <wavewave> I almost got an idea on how to use coroutine and monad-control for GUI programming in producer/consumer style
04:02:28 <wavewave> widget = event producer (enumerator),  callback or business log = event consumer ( iteratee )
04:04:01 <wavewave> the latest issue of Monad Reader was very helpful.
04:08:05 <wavewave> btw, can anyone explain why ContT monad is treated differently in many cases?
04:08:57 <wavewave> I want some theoretical understanding.
04:09:05 <kmc> how is it treated differently?
04:09:41 <wavewave> for example, in monad-control package, ContT does not have an instance of MonadControl
04:10:14 <kmc> *nod*
04:10:23 <wavewave> It's also often said ContT must be at the top of Monad Transformer stack.
04:10:45 <kmc> i know there is a distinction between "algebraic monads" and those with "control effects"
04:10:55 <kmc> the former being the ones you can write using http://hackage.haskell.org/package/operational
04:10:57 <wavewave> I have some vague feeling but want to have exact understanding.
04:12:00 <wavewave> thanks for the link!
04:12:04 <kmc> and I think the algebraic monads admit these operators like liftControl in a systematic way
04:12:20 <wavewave> hmm
04:12:26 <kmc> i don't know much about this but maybe i have provided things to google
04:13:48 <wavewave> looks like a real imperative programming in ProgramT monad in operational package.
04:15:47 <Saizan> are you sure ContT can't be implemented with ProgramT?
04:15:48 <wavewave> probably with ContT, you can do anything. so it can screw up the meaning of the other monad transformers.
04:16:23 <kmc> Saizan, I'm not sure
04:16:29 <kmc> I have a vague idea that you have to do something weird to do so
04:17:03 <Saizan> viewT returning stuff wrapped in m doesn't look promising, in fact
04:17:14 <kmc> have not tried, this is based on a few brief second-hand discussions
04:19:42 <wavewave> hmmm.
04:20:35 <wavewave> continuation is  a hole.
04:21:08 <wavewave> that makes everything inside out...
04:22:07 <wavewave> without continuation, a function is a disk
04:22:55 <wavewave> interface as  a boundary..
04:23:16 <wavewave> but w/ continuation, it's annulus.
04:23:32 <kmc> i can't tell whether what you're saying is utter nonsense, or a very precise connection between the lambda calculus and topology which I have little hope of understanding
04:24:15 <wavewave> so you can invert it.
04:24:37 <wavewave> kmc: just my intuition.
04:25:38 <wavewave> now I am trying to make gtk2hs widget as a generator coroutine.
04:26:08 <wavewave> all of them are in IO monad with callback functions.
04:27:01 <wavewave> now I embed the whole IO monad into CoroutineT IO and MonadControl
04:27:33 <wavewave> I make holes in call back functions.. and make them as an outside..
04:28:23 <wavewave> connect those holes with yield functions..
04:28:56 <wavewave> then, I can make them as generator (producer) which can be combined with iteratee (consumer).
04:29:41 <wavewave> and all GUI will have the same producer part. so programmers only worry about consumer part.
04:30:28 * ski wonders whether wavewave has looked at composable continuations
04:31:07 <wavewave> ski: thanks for indicating that keyword. I'll look it up.
04:31:10 <ski> @where composable-continuations
04:31:11 <lambdabot> <http://community.schemewiki.org/?composable-continuations-tutorial>
04:31:37 <wavewave> thanks
04:31:58 <ski> has a short description, including how one can use composable continuations to turn internal iteration (like `mapM_' e.g.) into external iteration (like a stream, possibly with effects at each step)
04:32:34 <wavewave> ski: sounds like enumerator / iteratee relation.
04:32:55 <ski> that's more or less why i mentioned it
04:33:36 <ski> (i haven't looked much at enumerators or iteratees, but what you were talking about sounded possibly related to internal vs. external iteration)
04:34:12 <wavewave> It seems that all advanced (or complicated) FP design is related to continuations. It's a kind of design pattern in FP.
04:34:43 <wavewave> although we don't like the term (design pattern)
04:35:25 <wavewave> ski: have you read the latest issue of monad reader about coroutine?
04:36:35 <kmc> it's important to identify "design patterns", as they represent libraries or language features which should exist but don't
04:36:47 <ski> wavewave : you might also want to check out "Representing Monads" by Andrzej Filinski, see <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/> -- this talks about how to reflect any (computational) monad, using composable/delimited continuations (or equivalently, using ordinary non-delimited continuations and a piece of mutable state)
04:37:32 <wavewave> ski: thanks!
04:37:42 <kmc> in any language you will have patterns appear in practice, and then disappear as people write abstractions or otherwise figure out better ways
04:37:55 <kmc> in that respect i have no problem with the term "design patterns"
04:38:10 <kmc> the problem is that certain engineering communities have given up on the second part
04:38:13 <ski> wavewave : also see TheHunter's <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters> about abusing `unsafePerformIO' and linear implicit parameters to get monadic reflection in Haskell
04:38:40 <kmc> they identify patterns so that you can type them out every time, and they hold this up to be a great virtue instead of a perhaps necessary evil
04:38:41 <wavewave> kmc: probably, the reason why people do not like design 'pattern' is that we often make a library for a given identified pattern and then we can just use it.
04:38:56 <kmc> as for continuations, I'm not sure they represent a pattern in this sense
04:39:09 <kmc> they're a very general concept and so can be related to a lot of things
04:39:30 <kmc> GHC doesn't have linear implicit params anymore, does it?
04:39:45 <wavewave> kmc: if we say design 'library', many feel happy..  ( I personally like the word 'pattern', so it doesn't matter to me. )
04:40:15 <ski> wavewave : Filinski's "Abstracting Control" and "Representing Control", about CPS-transformation and also composable continuations, are also good
04:40:18 <kmc> wavewave, in my mind a pattern suggests a library which hasn't been written yet
04:40:35 <ski> wavewave : "have you read the latest issue of monad reader about coroutine?" -- no
04:40:48 <kmc> Haskell is better for abstracting out patterns than a language like Java
04:40:58 <kmc> but it is still a lot worse than a language like Lisp or maybe even Python
04:41:25 <ski> kmc : what about the "worker-wrapper" pattern of defining a local worker function that does the main work, while the wrapper initializes and finalizes ?
04:41:25 <kmc> in Haskell there is much more effort towards making the abstracted patterns robust and statically correct
04:41:32 <wavewave> ski: thanks for all references. It definitely takes time for me to digest all. ;-)
04:42:01 <kmc> ski, hmm... it's not clear what library would make that go away
04:42:16 <wavewave> sounds like coroutine is a very restrictive subset of CPS style (but happens quite often in practice.)
04:42:18 <kmc> though better optimizations could prevent it from being necessary on performance grounds
04:42:42 <ski> wavewave : btw, what monadic reflection does is basically let you write `reify (reflect [1,2] * [3,4])' to get `[3,4,6,8]', but for any monad, not just for the list monad
04:42:45 <kmc> i can cop out and say that's a "style" rather than a "pattern"
04:42:50 <kmc> but that's pretty arbitrary
04:42:54 <ski> (: kmc
04:43:19 <kmc> my canonical example of patterns in Haskell are the little record-updater functions like \r x -> r { f = x }
04:43:26 <kmc> writing one out for each f
04:43:39 <kmc> so then the lens libraries are an example of replacing a pattern with a library
04:44:00 <ski> kmc : also, there's many versions of it, you can have the worker be an accumulator, or you can add an auxilary result (which you ignore in the top-call), or you can add a continuation argument, &c.
04:44:23 <wavewave> ahh, so many things to learn.
04:44:27 <kmc> perhaps more fundamental examples are 'map' and 'foldr' and the like
04:44:41 <kmc> turning common recursion patterns into library functions
04:45:55 <wavewave> I hope that there is a 'middle-high' level book like 'functional patterns' or 'functional design' something like that.
04:46:13 <wavewave> Starting from Monad/ Applicative
04:46:21 <ski> kmc : btw, mercury has optimizations which can effectively turn `(a ++ b) ++ c' into `a ++ (b ++ c)', and other similar things, to achieve tail calls
04:47:06 <wavewave> Monad stack, CPS, Coroutine, Delimited Continuation, Composable Continuation, Lens.... etec
04:47:28 <wavewave> kind of counter part of 'design patterns' in oop
04:48:09 <wavewave> in haskell, with examples of a real hackage library :-)
04:49:12 <wavewave> targetting LYAH -> beginner, RWH -> middle, Functional Pattern -> middle high
04:49:21 <kmc> nice
04:49:36 <rostayob> wavewave: what's "Functional Pattern"?
04:49:40 <rostayob> ah
04:49:47 <rostayob> an imaginary book
04:49:53 <wavewave> rostayob: I am saying my hope.. ;-)
04:50:39 <wavewave> haskell wiki and wikibook is doing a part of that service. but we need more systematic way of gathering info.
04:51:10 <wavewave> probably, at first step, we can gather info from wikibook.
04:51:27 <gienah> wavewave: there is the book: "The Fun of Programming"
04:51:49 * wavewave is looking for the book. 
04:52:07 <ski> "Patterns in Functional Programming" by Jeremy Gibbons, <http://lambda-the-ultimate.org/node/4256>
04:52:36 <wavewave> oh. yeah.. this is good.
04:52:42 <gienah> wavewave: you can find it on amazon.co.uk
04:53:57 <ski> "Functional Programming Patterns" by Eugene Wallingford at <http://www.cs.uni.edu/~wallingf/patterns/functional/>
04:54:22 <wavewave> ski: is "Patterns in functional programming" out as a printed ?
04:55:17 <ski> i don't know
04:55:37 * hackagebot lambdacube-engine 0.2.3 - 3D rendering engine written entirely in Haskell  http://hackage.haskell.org/package/lambdacube-engine-0.2.3 (CsabaHruska)
04:55:45 <wavewave> gienah, ski : thanks for sharing these invaluable infos.
04:56:13 <ski> istr another paper/thesis as well, but can't seem to find it atm
04:56:25 <ski> (about patterns in FP, i.e.)
04:58:06 <wavewave> yeah. now material is abundant.. we just need a very good writer in writing those in a LYAH or RWH style.
04:58:25 <ski> wavewave : ah, i was thinking about : "A Functional Pattern System for Object-Oriented Design" by Thomas K¸hne at <http://homepages.mcs.vuw.ac.nz/~tk/fps/>
04:58:45 <wavewave> hope Patterns in Functional Programming is very good for reader like me.
05:00:17 <gienah> wavewave: a really mind bending book is "The Algebra of Programming" which is also available at amazon.co.uk
05:00:23 <wavewave> ski: the last book sounds like targetting more OOP people.
05:00:37 <wavewave> gienah: I bought the book ;-P
05:00:37 * hackagebot lambdacube-examples 0.2.2 - Examples for LambdaCube  http://hackage.haskell.org/package/lambdacube-examples-0.2.2 (CsabaHruska)
05:01:01 <wavewave> gienah: ah.. no.. I borrowed the book from library.
05:01:05 <ski> wavewave : yes. i mentioned it because that was the one i was thinking about first, and it's somewhat related
05:01:28 <wavewave> gienah: I bought other book from R. Bird.. Functional Pearls..
05:02:11 <gienah> wavewave: neat, another mind bending book :-)
05:02:41 <wavewave> Ahh.. another request for an imaginary book!
05:02:48 <wavewave> Some EDSL
05:03:29 <wavewave> I found that there are several books on DSL design in OOPL.. but couldn't find in haskell.
05:04:00 <gienah> wavewave: there is some info on EDSL in the 3rd edition of "The Craft of Function Programming" by Simon Thompson
05:04:19 <wavewave> although information is scattered in many places.
05:05:02 <gienah> wavewave: The Craft is an introductory Haskell textbook, it starts at the very beginning
05:05:19 <ski> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/> is relevant, i suppose
05:05:54 <wavewave> gienah: yeah... that's targetting beginner / beginner-middle
05:06:15 <gienah> wavewave: yes
05:07:35 <wavewave> good~
05:08:37 <ski> wavewave : btw, if it wasn't clear, composable continuations and delimited continuations are the same thing -- aka sub-continuations
05:09:23 <wavewave> ski: ah, I see. I thought they were different. thanks for clarification.
05:09:38 <jtannenbaum> "Will it help you knock up a webserver with Java enterprise whatevers? No - not remotely." - the only reviewer of The Algebra of Programming on amazon.com
05:10:12 <kmc> heh
05:10:42 <jtannenbaum> kmc, your name reminds me of kc green, so I picture you as him
05:10:51 <wavewave> jtannenbaum: in fact, the algebra of programming is too advanced to me though it's great.
05:10:51 <ski> @quote enterprise.industry
05:10:52 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
05:10:52 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
05:10:56 <ski> @quote enterprise.variant
05:10:56 <kmc> that suggests an unorthodox approach to webserver development
05:10:56 <lambdabot> DRMacIver: says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprise variant functors. Commutative UML diagrams.
05:11:36 <kmc> haha jtannenbaum
05:12:04 <kmc> i read Gunshow but I... can't totally say I 'get' it
05:12:12 <jtannenbaum> I met him at NYCC
05:12:39 <kmc> it seems like it's usually trying to be deliberately unfunny in this weird forced way
05:12:52 <jtannenbaum> lately it hasn't been that funny
05:13:32 <kmc> but as personal accomplishments go, "invented dick butt" is way better than anything I've done
05:13:56 <jtannenbaum> he drew dickbutt for me (although it was in a book that my friend bought)
05:14:02 <wavewave> great.. i'm stuffed too much.
05:14:28 <jtannenbaum> kmc: http://s1-05.twitpicproxy.com/photos/large/424943891.png
05:16:01 <wavewave> I am going to make gtk2hs coroutine library soon.. stay tuned. ;-)
05:16:05 <jtannenbaum> I still can't believe I met the guy who invented dickbutt. So, many, people, around the world, know about it and I met the guy
05:16:10 <jtannenbaum> ok sorry for offtopic
05:17:24 <wavewave> btw, anyone knows about the status of haskell in android?
05:17:43 <wavewave> if anyone cares?
05:19:02 <kmc> i wrote some lousy hacks to make it kind of work with GHC 6.12
05:19:05 <kmc> not yet released
05:19:07 * ski just found a "Design Patterns in Dynamic Language" by Peter Norvig at <http://norvig.com/design-patterns/>
05:19:12 <kmc> they belong to iPwn Studios
05:19:53 <kmc> you can bug Cale or RyanT5000 about it
05:20:10 <wavewave> I see. thanks.
05:20:23 <kmc> if their iPhone game ever gets released, maybe they will work on the android version
05:21:07 <wavewave> ipwn studios uses haskell : yay!
05:21:20 <kmc> eh
05:21:35 <kmc> wait to celebrate until they actually produce something
05:21:37 <wavewave> the first sentence in tech . I like it. it says everything!
05:21:43 <kmc> the game is, what, two years late?
05:22:31 <kmc> right now it's not sounding like a success story, it's sounding more like the worst-case haskell horror story
05:22:51 <kmc> "we tried to do something that's been done a thousand times before in other languages, we got mired in abstract nonsense, and now the product is 2 years late"
05:22:59 <wavewave> what was the main obstacle? lack of tools?
05:23:03 <vharishankar> I guess game development is not haskell's strong point
05:23:12 <kmc> that's a stupid conclusion to draw
05:23:19 <kmc> i'm sorry but it's really not supported
05:23:23 <vharishankar> Games are inherently stateful
05:23:29 <kmc> ugh
05:23:43 <vharishankar> Using a stateless paradigm is like trying to fit a square into a round hole
05:24:06 <kmc> Haskell is a fine pragmatic language for stateful imperative programming
05:24:12 <kmc> if they'd written the game in that style in Haskell it might be done by now
05:24:14 <jtannenbaum> squares are 2-dimensional and holes are usually 3, so that's a pretty strong statement
05:24:18 <wavewave> haskell is actually the best imperative language.
05:24:19 <vharishankar> Might be, but there are other languages suitable for it
05:24:22 <kmc> the problem is exactly what you said, even though I think it's not what you meant
05:24:59 <kmc> which is that they're trying to write the game in a pure functional style using functional reactive programming, which is basically an active research topic
05:25:05 <kmc> and also writing it for unsupported platforms
05:25:28 <vharishankar> I am a newbie -- but seems to me that there is NO such thing as this size fits all
05:25:29 <wavewave> I think FRP is not the best approach in my opinion.
05:25:48 <vharishankar> And that includes haskell and anything else created by human beings.
05:25:58 <kmc> vharishankar, Haskell is the language I use for most day-to-day imperative programming.  stuff like GHC's lightweight threads with IO manager, good datastructures, good performance generally at a high level of abstraction...
05:26:06 <kmc> these are not functional programming purist mathematical obsessions
05:26:13 <kmc> they are good practical features in a practical programming language
05:26:19 <jtannenbaum> whoa practial argument derailed to philosophical assertions never seen that before on a programming language irc channel in ever
05:26:54 <jtannenbaum> practical too
05:27:06 <vharishankar> kmc: yes, but again -- you can shape your solution to the tool you are using. But that is not the point.
05:27:16 <wavewave> vharishankar: if I can clarify it more, conventional saying about haskell is now completely obsolete.
05:27:20 <kmc> you don't get it but I don't really care to argue the point
05:27:29 <mm_freak> can i insert a line feed into a haddock comment?
05:27:37 <kmc> yours is a common viewpoint among beginners, who have not really learned how to do effective imperative programming in Haskell
05:28:11 <ben> Clearly the biggest problem is that modifyIORef is such an unwieldy way to say C's =
05:28:12 <kmc> it is hard to learn, but once you know it, it's quite pleasant
05:28:14 <vharishankar> kmc: agreed. But I know some fundamentals now. Point is, haskell wasn't designed with game programming in mind, was it?
05:28:24 <ben> vharishankar: Neither was C, C++, C#
05:28:35 <mm_freak> wavewave: FRP is not the best approach for what?
05:28:39 <mm_freak> games?
05:28:44 <kmc> C wasn't designed with game programming in mind.  actually, C was designed to write UNIX, and UNIX was designed to play Space Travel, so I retract my original point
05:28:47 <dobblego> I have had to deal with the "X is inherently stateful" claims before
05:30:00 <jtannenbaum> python was designed specifically for the xkcd comic about flying
05:30:04 <drbean> I can't have a function called 'class'?
05:30:08 <wavewave> mm_freak: yeah, for games or GUI programming at this moment.
05:30:13 <kmc> drbean, correct; it is a reserved word
05:30:32 <mm_freak> wavewave: i wouldn't use anything else, but then i'm an FRP implementor myself
05:30:51 <ben> You can't have a function called 'class' to protect haskell from lawsuits by OOP language implementors
05:31:08 <kmc> use 'klass'
05:31:11 <wavewave> mm_freak : not downgrade FRP at all. I want to say that it is too radical for some practical matters.
05:31:19 <ski> (it's not obvious that the operation of replacing the contents of a mutable cell is a good way to model stateful application domains ..)
05:31:31 <mm_freak> wavewave: yes, you need skilled programmers for FRP, that's true
05:31:41 <hpc> use classTMUsedWithPermission
05:31:50 <mm_freak> if you have them, FRP is probably the one true way to write anything, which is not a batch program =)
05:31:57 <ben> Really?
05:32:03 <wavewave> mm_freak: actually I like FRP idea much much more than any other paradigm.
05:32:09 <ben> As a total beginner I have no idea what problem FRP is really solving nor at all how it does that
05:32:17 <ben> it seemed fairly niche to me, as that
05:32:29 <ben> Clearly you guys need better PR
05:32:32 <wavewave> mm_freak: but problem is that it is hard to combine it with usual IO action.
05:32:36 <mm_freak> ben: declarative programming‚Ä¶  FRP solves the problem of state and complicated data dependencies
05:32:51 <mm_freak> stateful programming with no imperative programming at all
05:33:01 <vharishankar> mm_freak: sounds interesting.
05:33:11 <ben> That sounds fairly holy-grail
05:33:14 <wavewave> mm_freak: whenever I need a new feature of IO, I need to rethink about it in FRP way.. that's why it's not the best at this moment.
05:33:33 <mm_freak> wavewave: not at all‚Ä¶  i advocate AFRP (FRP using arrows), and with yampa it's hard‚Ä¶  but with netwire it's trivial
05:33:37 <kmc> seriously, we should just rename the language and start over on all the branding
05:33:47 <mm_freak> wavewave: execute -< putStrLn "blah"
05:33:48 <mm_freak> =)
05:34:04 <kmc> "Do you like the idea of using Haskell, but wish it had pragmatic real-world features?  Imperative state when you need it, lightweight threads, good Unicode support?  And the ability to call C when you really need to?"
05:34:13 <wavewave> mm_freak: Hmm.. I wasn't aware of netwire.  Good to have this discussion ;-D
05:34:21 <ben> kmc: hah
05:35:07 <mm_freak> wavewave: it's my own library, using some of the basic ideas of yampa, but extending them far beyond‚Ä¶  right at this moment i'm working actively on netwire 2.0.0 for a new project
05:36:05 <wavewave> mm_freak: I see. Looks pretty good! I will try it.
05:36:06 <vharishankar> I am amazed at how some problems can be reduced to functional paradigm with some mental reconditioning. But it still boggles my mind at least how complex writing an arcade game must be in Haskell.
05:36:27 <kmc> vharishankar, you're still conflating "Functional paradigm" with "Haskell"
05:36:42 <mm_freak> vharishankar: if you are new to haskell and coming from an OOP language, it will be hard at first, because you need to wrap your mind around new concepts
05:36:56 <mm_freak> and basically forget OOP as you go
05:37:01 <wavewave> mm_freak: right now, I am considering coroutine as an alternative of FRP in GUI programming.
05:37:28 <kmc> look, you can argue Haskell is a bad imperative language because it's hard to learn.  but if you *haven't* learned it, then you can't argue it's a bad imperative language for those who *already know* it
05:37:29 <wavewave> mm_freak: though both can coexist very productively.
05:37:31 <ben> kmc: I'm not disagreeing with you but I suppose there's not a dearth of "using haskell pragmatically with explicity state blah blah blah" tutorials
05:37:43 <kmc> ?
05:37:45 <mm_freak> wavewave: coroutines are fine for simple programs, but they start to become unwieldy as your data and control dependencies get more complicated
05:37:45 <vharishankar> mm_freak: cannot forget OOP so easily ;-)
05:37:51 <ski> not quite Haskell, but : "Clean Game Library" <http://cleangl.sourceforge.net/>
05:37:53 <ben> It's all about state being evil
05:37:55 <mm_freak> vharishankar: i know, i came from C++ myself
05:38:03 <mm_freak> vharishankar: but it's possible, if you really want to
05:38:09 <ski> (note that Clean is also pure, like Haskell)
05:38:09 <kmc> ben, what about RWH?
05:38:31 <wavewave> mm_freak: I guess so.. making FRP and coroutine coexist beautifully is my next step of thinking now.
05:38:32 <vharishankar> But why would I want to? I want to continue writing programs in as many languages as I can. Just to keep my horizons wide
05:38:32 <kmc> RWH has plenty of stateful stuff; they show how to write network servers, and a GUI app with gtk2hs, and STM, and how to bind a C library
05:38:46 <cgroza> Hello. Is there any sorting function that takes a function argument? I am trying to sort a list of lists by their length.
05:38:48 <vharishankar> I've ordered RWH online
05:38:56 <dobblego> cgroza: sortBy
05:39:00 <kmc> :t sortBy
05:39:01 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
05:39:04 <mm_freak> nowadays i'm constantly annoyed at work, because they insist on putting everything into objects
05:39:05 <cgroza> dobblego: thanks.
05:39:17 <mm_freak> if it were me, i would use no OO at all
05:39:23 <vharishankar> I am not a programmer by profession so I can pick and choose
05:39:30 <mm_freak> wavewave: that would basically be netwire 2.0
05:39:43 <wavewave> mm_freak: anyway.. probably, my thought on FRP is mainly because there are not many FRP tools easily useable now.. your package may change my mind ;-)
05:39:53 <mm_freak> wavewave: the new version will allow backtracking and concurrency
05:39:55 <kmc> ben, I've personally been very annoyed at times by the Haskell community's emphasis on functional orthodoxy... but I've also seen that emphasis decline over the years, as Haskell is used more and more as a realistic, multiparadigm language
05:40:01 <wavewave> mm_freak: great!
05:40:21 <kmc> ben, I do think some degree of nudging away from state is necessary, because the default in programming education and in other languages is to use state everywhere for no reason
05:40:29 <ski> > sortBy (comparing length `mappend` compare) (words "the quick brown fox jumps over the lazy dog")
05:40:30 <lambdabot>   ["dog","fox","the","the","lazy","over","brown","jumps","quick"]
05:40:31 <kmc> that's why Haskell's position of "use state when you need it" seems radical
05:40:32 <ski> cgroza ^
05:40:41 <ben> But it also seems unwieldy?
05:40:52 <kmc> absent the weird status quo, "use state when you need it" would be the obvious compromise
05:41:01 <ski> cgroza : see "Monoids? In my programming language?" by Cale at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx>
05:41:04 <vharishankar> kmc: agreed, but you can reduce state dependency even in other programming languages. I guess it's up to the programmer's mindset also to an extent
05:41:05 <mm_freak> wavewave: the last 1.* version to include FRP.NetWire.Concurrent (i removed it at some point) was also allowing simple concurrency‚Ä¶  there were concurrent variants of the (&&&), (***) and (<+>) combinators, but they are gone now, because in the old concept they were not really useful
05:41:16 <mm_freak> wavewave: in the you library you can just say:  x <- fork -< xs
05:41:18 <cgroza> ski: thanks.
05:41:18 <kmc> vharishankar, true, however in most languages the standard library will fight you
05:41:20 <mm_freak> just like in the list monad
05:41:29 <mm_freak> wavewave: s/you/new/
05:41:32 <kmc> and other people's code
05:41:51 <kmc> the revolutionary thing about Haskell is not that the language demands purity, but that the std lib supports purity
05:41:57 <Phyx-> ski: why the `mappend`/
05:41:59 <Phyx-> ?
05:42:05 <kmc> in truth the language as commonly implemented does not demand purity
05:42:16 <wavewave> mm_freak: I see.. thanks for the detail explanation.
05:42:20 <vharishankar> kmc: any examples? Not to challenge you, but I was curious about this behaviour
05:42:26 <kmc> about which?
05:42:31 <kmc> you can challenge me :)
05:42:40 <vharishankar> about standard library affecting state
05:42:46 <wavewave> kmc likes to be challenged.
05:42:49 <ski> Phyx- : "first sort according to length, then for each length, use the nomal ordering"
05:42:53 <jtannenbaum> am I too late to make to obvious joke about haskell and libertarians
05:42:54 <kmc> well... you're writing a Python class, one of its methods returns a list
05:42:57 <kmc> user can mutate that list
05:42:58 <ski> Phyx- : see Cale's reddit comment i linked to above
05:43:03 <mm_freak> kmc: the revolutionary thing about haskell is that you can create your own control structures easily and without giving up any code beauty
05:43:25 <kmc> do you a) copy the list every time you return it, or b) trust the user not to modify it, or c) give up on purity and treat your own object as state
05:43:34 <mm_freak> common lisp has done this before, but haskell has really brought it to the edge
05:43:37 <kmc> you can make an immutable list type in Python
05:43:40 <kmc> in fact it exists, it's the tuple
05:43:41 <vharishankar> kmc: by user you mean the programmer?
05:43:47 <kmc> the programmer using your class, yes
05:44:00 <kmc> but, for example, there's no standard immutable map
05:44:08 <kmc> and there wasn't an immutable set until they realized they needed one and added it, iirc
05:44:11 <jtannenbaum> heh, think of a programmer as a user and yourself as a program programmer
05:44:27 <ben> "user" is relative ;)
05:44:34 <ben> the superlative is end-ser
05:44:37 <ben> end-user
05:44:40 <wavewave> user is mighty in tron
05:44:49 <vharishankar> OK right. Got it
05:45:00 <rostayob> is there a way to generate a list of unique elements in a Gen?
05:45:03 <kmc> despite being generally insane, C++ actually has a better story here than most languages
05:45:10 <ski> mm_freak : complicated binders are still hard to make
05:45:18 <rostayob> I mean, is there a pre-defined combinator to do that
05:45:21 <mm_freak> ski: what is a "complicated binder"?
05:45:29 <kmc> though of the "real world" C++ code I've seen, relatively little of it uses const correctly
05:45:41 <mm_freak> rostayob: Gen?
05:45:42 <ben> kmc: What do you think of boost?
05:45:42 <ski> mm_freak : macros which bind variables in some non-trivial way
05:45:42 <vharishankar> My brother who is a virtualbox developer swears that C is the best programming language because it's bascially a cross-platform assembly language.
05:45:52 <vharishankar> He writes device drivers, by the way
05:45:55 <mm_freak> ski: give me an example
05:45:56 <wavewave> it's a little funny that we can do stateful programming very easily in haskell but we are discouraging it at all cost.. ;-P
05:45:56 <dobblego> rostayob: why must they be unique?
05:45:58 <kmc> ben, Boost is high quality and adheres closely to C++ as it was intended to be used
05:46:09 <kmc> it's written by the top C++ wizards
05:46:12 <wavewave> to avoid success at all costs. ;-)
05:46:13 <ben> kmc: I figure boost is kind of in the direction of haskell from C++
05:46:19 <mm_freak> vharishankar: then C is probably indeed the best language for him, although i would consider C++
05:46:21 <ben> there's a parser combinator library in there for god's sake
05:46:24 <kmc> many of their libraries are explicitly reimplementing Haskell features, yes ;)
05:46:27 <rostayob> dobblego: because I'm generating another data structure given a random list, I think I'll just do "nub" afterwards
05:46:57 <kmc> I'm talking more about random C++ code I've seen in corporate or educational settings (which is not all that much)
05:47:00 <vharishankar> mm_freak: my brother says every programmer should think like the compiler. He trashes all "high-level" programming :-)
05:47:17 <ben> That tends to be the common subset of stuff you can express in java and c++
05:47:20 <wavewave> vharishankar: 'best' is subjective any way.
05:47:20 <kmc> my uncle's gardener's sister says that Haskell is for dumb-tards
05:47:25 <mm_freak> vharishankar: many old school C programmers do that‚Ä¶  i would just ignore it ;)
05:47:25 <kmc> let's all argue about that
05:47:45 <ben> templates are evil, references are evil, abstraction is evil. java-style class hierarchy all the way!
05:47:52 <wavewave> vharishankar: I am surrounded by people who think fortran is the best language.
05:48:01 <wavewave> seriously.
05:48:03 <vharishankar> wavewave: Ah fortran.
05:48:05 <rostayob> mm_freak: QuickCheck thing to generate arbitrary values
05:48:06 <ben> Physicists?
05:48:10 <wavewave> yes.
05:48:11 <kmc> fortran is best for certain things
05:48:16 <mm_freak> rostayob: oh, sorry then
05:48:17 <vharishankar> Fortran is still used by a lot of people
05:48:25 <wavewave> in fact, it's best in some of my domain.
05:48:26 <mm_freak> vharishankar: number crunchers mainly
05:48:28 <ski> mm_freak : e.g. the "crossing scopes" in `[..x0..x1..y0..y1.. | x0 <- xs0,x1 <- xs1 x0 | y0 <- ys0,y1 <- ys1 y0]'
05:48:34 <kmc> fortran is still good for....... formula translation
05:48:42 <wavewave> probably in physics most.
05:49:09 <ski> mm_freak : all the variables bound in the two "parallel" branch chains are in scope in the `..x0..x1..y0..y1..' expression
05:49:45 <mm_freak> ski: i don't see a nontrivial binding there‚Ä¶  what i see is a zipWith over two lists
05:49:50 <vharishankar> But actually I find the (some of the) tutorials of haskell more scary than haskell.
05:50:05 <ski> mm_freak : the scope is non-trivial
05:50:23 <vharishankar> I forced myself to sit down and write my own code from what I learned. Copy-pasting tutorials is not the way.
05:50:29 <mm_freak> ski: how?  zipWith (\(x0, x1) (y0, y1) -> ‚Ä¶)
05:50:34 <wavewave> vharishankar: about haskell stateful computation, the point is not that haksell cannot do that, but that the programming paradigm we would like to have in haskell discourages it. (but not banned)
05:51:15 <mm_freak> ski: i know only one case, where (possible) scope is not always trivial‚Ä¶  arrow computations without ArrowApply
05:51:17 <ski> mm_freak : you have to explicitly enumerate all the bound variables in a tuple, which is distracting and clunky
05:51:33 <wavewave> vharishankar: and in fact, by avoiding stateful computation, you can learn that many of stateful computation is unnecessary.
05:51:43 <mm_freak> ski: that doesn't make it nontrivial‚Ä¶  it just makes it harder
05:51:57 <vharishankar> wavewave: Right.
05:52:08 <wavewave> vharishankar: but for necessary cases like game programming, we do stateful computation definitely.
05:52:24 <mm_freak> ski: but really i would have no difficulty with the zipWith variant‚Ä¶  the list comprehension took me longer to comprehend
05:52:29 <wavewave> vharishankar: actually in much more clean way than other languages.
05:52:31 <ski> mm_freak : it means that the mapping from the sugar to the unsugared form is larger (and not so local), so if you don't happen to have the sugar implemented, it's more noise
05:52:35 <vharishankar> wavewave: I figure that might be the case.
05:52:42 <ski> mm_freak : another example is foof-loop <http://mumble.net/~campbell/scheme/foof-loop.txt>
05:52:58 <wavewave> vharishankar: one very famous example is FRP.
05:53:14 <vharishankar> One thing I like about haskell is that it can be compiled. One of the few languages that are so high level and yet can be compiled natively.
05:53:32 <kmc> yeah
05:53:37 <kmc> it doesn't make sense to me that there are so few
05:53:39 <wavewave> vharishankar: and it's comparable with C.
05:53:44 <ben> That comes down to praisin the static type system doesn't it
05:53:52 <kmc> sort of
05:54:08 <vharishankar> wavewave: FRP sounds interesting. Must try to read up on that topic
05:54:21 <kmc> i mean, lots of languages are JIT-compiled now, including dynamically typed ones
05:54:29 <wavewave> vharishankar: haskell web server is as fast as or even faster than nginx written in C (which is known as the fastest webserver.)
05:54:35 <kmc> and I think JITs have the potential to outperform static compilers, even for static languages like Haskell
05:54:41 <ski> mm_freak : that library implements in Scheme something like Olin Shivers' "The Anatomy of a Loop" at <http://www.ccs.neu.edu/home/shivers/papers/loop.pd>
05:54:47 <ben> But don't they spend half their time inferring where types are really static
05:54:54 <wavewave> vharishankar: definitely, webserver does stateful calculation.
05:55:12 <kmc> you *can* compile Java to native code, it just doesn't work that well and not many people do it
05:55:17 <kmc> (ahead of time, I mean)
05:55:28 <vharishankar> wavewave: yes, but why do so many haskell tutorials almost scare programmers away?
05:55:33 <mm_freak> ski: as i see it it solves problems found in scheme, but i can't really reproduce them in haskell
05:55:37 <mm_freak> ski: in haskell you have (.)
05:55:50 <vharishankar> Except LYAH I found nothing approachable.
05:55:52 <hpc> vharishankar: i would guess because they don't like having to unlearn so much
05:56:08 <wavewave> vharishankar: that's a little misfortune in haskell.
05:56:14 <ski>   "Writing loops with tail-recursive function calls is the equivalent of writing them with goto's."
05:56:30 <sipa1024> :t sortBy
05:56:31 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
05:56:34 <vharishankar> hpc: That is one problem. But without LYAH I would have run away first time. :-)
05:56:38 <wavewave> vharishankar: we need to have more and more approachable tutorials and books. I agree.
05:56:47 <ski> mm_freak : it's related to the problem that `fold's and `map's aren't as composable as we'd like
05:56:48 <mm_freak> vharishankar: as a beginner FRP might scare you‚Ä¶  i would suggest to learn the basics first
05:56:53 <kmc> yeah, more tutorials would be good
05:57:05 <kmc> but there is still a fundamental gap that needs to be crossed
05:57:09 <ben> I want tutorials that use the gloss web frontend
05:57:15 <vharishankar> mm_freak: thanks. I don't plan to go too deep before I am more comfortable.
05:57:19 <kmc> i'm glad that Haskell programmers are mostly people who are willing to learn something hard and stick with it for a while
05:57:20 <wavewave> vharishankar: haskell history is a little weird in many aspects compared with others.
05:57:28 <geheimdienst> i made the mistake of doing what i'd do in java/python/c#/..., which is looking at the official docs. in haskell, that's scary
05:57:35 <ski> (btw, one can do `(compose f ...)' in Scheme as well)
05:57:54 <vharishankar> My brother also suggested learning LISP.
05:58:04 <wavewave> vharishankar: haskell was not targetting to become a main stream language.
05:58:07 <kmc> we can and should make the language more accessible, but it will never be as accessible as PHP, and that's a good thing
05:58:21 <vharishankar> wavewave: I guess so.
05:58:28 <kmc> vharishankar, Common Lisp?
05:58:29 <mirari> *gasp* you dare mention PHP in this realm?
05:58:30 <hpc> kmc: or if it is, it won't be because the language changed
05:58:34 <kmc> vharishankar, Common Lisp is an ugly beast of a language
05:58:36 <mm_freak> ski: i'm not sure‚Ä¶  are you concerned about the explicit argument passing you need sometimes?
05:58:42 <kmc> vharishankar, I recommend Scheme or Clojure
05:58:53 <vharishankar> kmc: OK.
05:58:59 <kmc> hpc, yeah, there is some hope that CS education and programmer mindsets will change, and Haskell will seem less foreign
05:59:01 <wavewave> vharishankar: some cool idea happened in 80's (lazy evaluation) and researchers gathered and make a kind of best language in their mind..
05:59:02 <mm_freak> ski: as someone working a lot with arrows i'm completely comfortable with doing that from time to time
05:59:03 <kmc> I'm not holding my breath
05:59:09 <vharishankar> kmc: I am not sure if he suggested Common Lisp.
05:59:14 <hpc> haha, me neither
05:59:30 <wavewave> vharishankar: so it became an experiment base of all new ideas.
06:00:02 <hpc> kmc: the move from java to python as the most common first language is very tenuously helpful
06:00:32 <kmc> some CS programs just want to pump out people who know whatever language is used by industry for programmers as replaceable parts
06:00:35 <hpc> just the fact that it has map/filter/reduce/lambda at all is a huge step towards functional style not being magic
06:00:37 <kmc> which will never be Haskell
06:00:59 <wavewave> vharishankar: so in haskell, we more think about what the ideal programming style is than practicality.
06:01:02 <mm_freak> hpc: not sure about that‚Ä¶  there is one thing java has in common with haskell:  the static type system and a poor form of type variables (called "generics")
06:01:15 <wavewave> vharishankar : I mean in its development history.. not nowadays.
06:01:31 <kmc> Java's type system is almost a strawman argument against static types
06:01:35 <hpc> mm_freak: i think in general, functional style is more useful than static types
06:01:37 <vharishankar> wavewave: that's interesting.
06:01:53 <kmc> anyway this has all been said here before many many many times
06:02:05 <ski> mm_freak : that paper is concerned about writing loops in general. some common kinds of loops can be captured by functions like `map',`filter',`foldr', but if you have an explicit recursive loop that has aspects of both a `map' and a `foldr' e.g., it's not so easy to compose a `map' and a `foldr' (and still traverse the input only once)
06:02:06 <hpc> very few static type systems are strong enough to provide anyting more useful than "you forgot to cast this to Object" errors
06:02:13 <wavewave> vharishankar: so new idea comes, then the language adapts faster than rejecting.
06:02:42 <mm_freak> hpc: sure, but python is not good at that either‚Ä¶  for example the purely functional answer to stream processing is usually iteratees‚Ä¶  python has generators instead, which are inherently imperative
06:02:55 <mm_freak> it really only has some very basic combinators like map and reduce (foldl)
06:03:11 <ski> vharishankar : i suggest learning Scheme before Common Lisp
06:03:13 <wavewave> vharishankar: one good effect of that is that definitely haskell is 'the' most advanced language widely used.
06:03:19 <hpc> iteratees are kind of poorly implemented in haskell, imo
06:03:28 <vharishankar> wavewave: thanks.
06:03:29 <hpc> the iteratee package is impenetrable
06:03:37 <hpc> as is the enumerator package
06:03:40 <wavewave> vharishankar: the bad effect is that we didn't care about users much until recently.
06:03:53 <vharishankar> ski: I read that Scheme is not so standardized.
06:04:08 <mm_freak> ski: the point is, you don't need to‚Ä¶  using lists properly will happily optimize the entire list structure away
06:04:14 <vharishankar> wavewave: I was not even aware of haskell until recently (I had read the term, but never associated it with anything significant)
06:04:19 <ski> vharishankar : Scheme is more regular and beautiful than Common Lisp, imno
06:04:26 <ski> s/imno/imo/
06:04:28 <wavewave> vharishankar: even among well-trained programmers, some time we argue about what the best style is...
06:04:47 <wavewave> vharishankar: I recommend an article..
06:04:49 <hpc> wavewave: it's obviously the prolog style :P
06:04:51 <vharishankar> wavewave: actually haskell is what has made me feel like I'm learning programming afresh.
06:04:54 <ski> vharishankar : also, if you're going to learn a Lisp, you should definitely learn hygienic macros, which means learning Scheme
06:05:12 <wavewave> @google being lazy with class
06:05:14 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf
06:05:15 <lambdabot> Title: A History of Haskell: Being Lazy With Class
06:05:27 <mm_freak> hpc: the enumerator library implements them nicely‚Ä¶  the only ugly thing in enumerator is the needed distinction between Iteratee and Step
06:05:32 <vharishankar> ski: will do.
06:05:41 <wavewave> vharishankar : read the above material... it should be fun.
06:05:47 <Phyx-> ski: ah, that's interesting, thanks
06:05:54 <ski> Phyx- : monoids ?
06:06:01 <vharishankar> wavewave: thanks. Going off to read it now.
06:06:21 <vharishankar> will be back later. Thanks so much for the excellent discussion.
06:06:34 <mm_freak> vharishankar: have fun =)
06:06:42 <ski> vharishankar : other Lisps (than Scheme) also have macros, but only non-hygienic ones
06:06:54 <vharishankar> mm_freak: I will :-)
06:07:07 <hpc> ski: what's the difference between non-hygenic and hygenic?
06:07:18 <ski> hpc : respecting static/lexical scope
06:07:26 <hpc> ah
06:07:26 <vharishankar> ski: I am afraid I am not familiar with that term, but I will go off and study them :-)
06:07:45 <ski> hygienic macros respect lexical scope, unhygienic macros don't
06:08:24 <mm_freak> scheme/racket are probably better than most other functional languages, but they couldn't replace haskell for me
06:09:05 <ski> let's say you define a macro `and', so that `(or <expr0> <expr1>)' expands to `(let ((temp <expr0>)) (if temp temp <expr1>))'
06:09:12 <ski> s/and/or/
06:10:31 <ski> if we've defined `or' as a non-hygienic macro, then `(let ((temp 3)) (or (f temp) (g temp)))' will expand to `(let ((temp 3)) (let ((temp (f temp))) (if temp temp (f temp))))'
06:11:08 <ski> and so the `temp' in `(g temp)' will not refer to `3', but to the local variable the macro introduced, breaking the lexical scope
06:11:53 <ski> while if `or' is defined as a hygienic macro, the local variable `temp' which the macro introduces will effectively be renamed, so that `temp' in `(g temp)' will not refer to it
06:12:13 <hpc> ski: so you don't need to use stuff like gensym
06:12:29 <ski> this first important aspect of hygienic macros can be simulated by manually generating a new name to use instead of `temp', in the macro
06:12:46 <ski> the second important ascpect of hygienic macros can't be simulated with `gensym', though
06:12:51 <wavewave> mm_freak: does netwire have gtk2hs binding?
06:13:18 <ski> consider a module that defines a function `f', and a macro `m' whose uses will expand to code which refer to `f'
06:13:33 <ski> now say the module exports the macro `m', but not the function `f'
06:13:55 <ski> so the macro now expands to an expression containing a reference to an identifier not exported by the module
06:15:14 <ski> (btw, systems for hygienic macros commonly also give you a way to define non-hygienic ones, but only to the extent that you ask for it, so the default is hygienic, so you don't have to think about it normally)
06:16:10 <wavewave> BTW, one relatively unknown good book is haskell road to math
06:16:24 <ski> e.g. in Common Lisp, one would define `or' above to use `gensym' to generate the `temp' identifier, but one wouldn't normally think about making sure `if' and `let' in the expanded code refers to the normal syntax bindings for those
06:16:52 <wavewave> The Haskell Road to Logic, Maths and Programming
06:17:02 <ski> (e.g. if you make an EDSL, you might want to redefine `if' and `let' in a local scope .. e.g. you might want `if' to combine a stream of booleans with two other streams into a new stream)
06:17:06 <wavewave> I think this is also a good introduction book.
06:17:21 <wavewave> In fact, this is the 'first' book I read about haskell
06:17:42 <zeiris>   ski thanks for that overview
06:17:47 <zeiris> the export thing in particular
06:17:47 <ski> yw
06:18:16 <mm_freak> wavewave: no, netwire is a pure FRP library‚Ä¶  you can combine it with gtk2hs, but there is no ready-made runtime for now
06:18:40 <mm_freak> wavewave: none is planned either, because i would likely go for wx instead
06:18:47 <wavewave> mm_freak : okay.. I may try it if possible ;-P
06:19:03 <kmc> ski, do you consider Template Haskell to be an example of hygenic macros?
06:19:14 <kmc> it solves both problems to some degree
06:19:14 <wavewave> mm_freak: for me, gtk2hs is important since I would like to use a pen of my tablet pc.
06:19:22 <mm_freak> wavewave: it's not difficult to integrate netwire with libraries, which don't force you into an opaque main loop‚Ä¶  i'm not sure whether gtk2hs does
06:20:01 <ski> kmc : i don't know TH very well, but from what i've understood, it's not fully hygienic, at least
06:20:25 <wavewave> mm_freak: it's a little bit unfortunate that open source gui development is now very fragmented.
06:20:30 <kmc> well, you can explicitly construct names which might shadow at the binding site
06:20:40 <wavewave> mm_freak: especially after smart phones.
06:20:52 <kmc> but the names you bind in a quotation will not
06:21:02 <kmc> (there's also an explicit gensym in the Q monad)
06:21:27 <kmc> also name resolution is done at splice time
06:21:32 <wavewave> now everything is confined to a certain  platform....
06:21:33 <kmc> with some rather complicated rules
06:21:43 <kmc> er, at quote time, I mean
06:21:47 <kmc> but anyway it solves the second problem
06:22:06 <kmc> if your quotation refers to a name you imported, then when you splice, it will still refer to that name and not some other name at the splice site
06:22:27 <wavewave> mm_freak : did you compare your library with reactive-banana?
06:23:02 <wavewave> mm_freak : looks pretty different but would you remind me of what's the main difference in your thought?
06:23:10 <kmc> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/template-haskell-2.5.0.0/Language-Haskell-TH-Syntax.html#t:NameFlavour rather complicated...
06:24:25 <ski> kmc : i remember seeing some discussion about how to handle some scope issues in TH (maybe on trac or on mailing list) but i can't seem to find it atm
06:24:52 <mm_freak> wavewave: the main difference is that reactive-banana uses monadic FRP and is to some extent specialized to GUIs
06:25:36 <kmc> ski, *nod* I expect there are bugs and corner cases
06:25:42 <mm_freak> wavewave: netwire uses an arrow instead and is more generic‚Ä¶  for example i write network applications with it
06:26:12 <mm_freak> wavewave: one example of what that looks like is the webwire library on hackage‚Ä¶  it's a highly experimental reactive web framework
06:26:15 <wavewave> mm_freak: I see. thanks.
06:26:24 <ski> kmc : also, last i checked, there were (what i percieved as) problems with quasi-quotations -- might be fixed now
06:26:43 <kmc> you mean the [foo| ... |] quasiquotes?
06:27:02 <wavewave> mm_freak : oh.. you made web framework, too? that's what I wanted to see.  FRP version of web framework.
06:27:10 <mm_freak> wavewave: the problem AFRP solves in network programming is mainly complicated inter-request data dependencies and actions based on them
06:27:36 <ski> i don't recall the details, but i think it was about quasi-quotations for Haskell phrases (expressions, declarations, &c.), yes
06:27:36 <mm_freak> yes, i did, but it's very simple and right now only useful as a proof of concept
06:29:35 <wavewave> mm_freak : do you have a public repository for netwire 2.0?
06:30:57 <mm_freak> wavewave: not right now, but i can create one, if you wish
06:31:49 <wavewave> mm_freak : I want to watch the development procedure like in github if you don't mind ;-)
06:32:06 <rostayob> Is there some CPP variable indicating that cabal is compiling? I want to the Arbitrary instance for my data structure when using cabal
06:33:01 <rostayob> mm_freak: are there any non-trivial examples using netwire? last time I checked there was something really simple on the wiki
06:33:37 <kmc> rostayob, as a hack you could use the macros in dist/build/autogen/cabal_macros.h
06:33:50 <kmc> i.e. #ifdef VERSION_base
06:33:53 <wavewave> mm_freak: how is the memory use in netwire? Doesn't it have memory leak problem usually present in FRP due to retained state?
06:33:55 <kmc> you can also just put -D flags in your cabal file
06:34:06 <mm_freak> rostayob: i'd say that webwire is the one non-trivial example, which you can find online
06:34:06 <kmc> and there may be a correct direct answer to your question, which I'm unaware of
06:34:19 <kmc> why is this what you want, by the way?
06:34:34 <mm_freak> wavewave: AFRP doesn't have that problem‚Ä¶  you can create it by allowing it explicitly
06:34:54 <rostayob> kmc: because I don't want to expose the QuickCheck stuff
06:34:59 <mm_freak> wavewave: for example there is the 'dam' wire, which might leak, when used incorrectly, but it's all documented in the haddock manual
06:35:02 <rostayob> so that it's not a dependency
06:35:12 <wavewave> mm_freak: I see...
06:35:25 * wavewave is looking for dam in haddock manual.
06:35:30 <rostayob> mm_freak: I'm a fairly practical person and webwire is another library, I think there were some webwire examples as well but really simple
06:35:33 <kmc> rostayob, ah, that makes sense, I think you were missing a word in your original explanation
06:35:48 <mm_freak> wavewave: it doesn't leak in the time leak sense though, but rather in the "queue not emptied quickly enough" sense
06:35:56 <rostayob> kmc: yeah I'm not that good with words :P
06:36:02 <kmc> rostayob, perhaps the best way (the way used by 'containers', anyway) is to do #ifdef TESTING
06:36:12 <mm_freak> rostayob: yes, you can find them in the -cafe archives
06:36:13 <kmc> and then you explicitly pass -DTESTING to ghc when you want the special testing behavior
06:36:37 <kmc> and otherwise it's normal
06:36:40 <rostayob> mm_freak: I remember those but they didn't explain much
06:36:53 <rostayob> kmc: ok, I'll do that then
06:37:12 <kmc> they use it for a lot of things... extra exports, deriving Show on normally-abstract types, and QuickCheck
06:37:53 <rostayob> yep makes sense, I should have check
06:38:02 <rostayob> considering that I'm creating a container (sort of) as well
06:38:14 <rostayob> also, every time I use QuickCheck I remember why it's soo good
06:38:16 <rostayob> *so good
06:38:52 <kmc> QuickCheck deserves "soo good" if not "sooo good"
06:39:20 * ski . o O ( `data So : Bool -> Set where Oh : So True' )
06:39:29 <rostayob> kmc: ehe
06:40:51 * wavewave thinks that some time later we will see a return of arrow haskeller band.
06:41:24 <wavewave> monad clan vs arrow clan
06:41:53 <mike-burns> I'm trying to figure out how to use Aeson, or any other JSON lib. Perhaps someone can walk me through this?
06:42:09 <mike-burns> http://pastebin.com/z5rjEZNJ - I have these data types, input JSON, and desired output.
06:42:09 <mauke> The paste z5rjEZNJ has been copied to http://hpaste.org/53266
06:42:15 <wavewave> mike-burns : what's your question?
06:42:19 <chridi> hmh.. if i have a "data Player = Player1 | Player2" in a module, i cannot export it, but if i want to use it i get an error "not in scope"
06:42:25 <wavewave> mike-burns: oh..
06:43:05 <rostayob> mike-burns: have you tried this http://hackage.haskell.org/packages/archive/aeson/0.3.2.12/doc/html/Data-Aeson-Generic.html ?
06:43:08 <mike-burns> I've been playing with Commit instances of FromJSON.
06:43:27 <wavewave> mike-burns : use deriving Data, Typeable
06:43:32 <vharishankar> > unwords ["this", "", "is", "a", "test"]
06:43:33 <lambdabot>   "this  is a test"
06:43:51 <mike-burns> wavewave: Oh! What's that do? Is that documented?
06:43:56 <mike-burns> I'm trying to use Aeson, by the way.
06:43:58 <vharishankar> Why is "" treated as an extra space in unwords?
06:44:00 <wavewave> mike-burns : derive (Show, Data, Typeable) ... then it's automatic.
06:44:13 <rostayob> you don't need Typeable
06:44:15 <rostayob> but anyway
06:44:19 <wavewave> mike-burns: import Data.Aeson.Generic
06:44:20 <hpc> @src unwords
06:44:20 <lambdabot> unwords [] = ""
06:44:20 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
06:44:27 <mike-burns> Interesting.
06:44:51 <vharishankar> hpc: so using [] instead of "" has the same effect?
06:44:53 <rostayob> mike-burns: Data gives you some reflection over concrete types, so those functions try to convert from and to with that information
06:44:55 <hpc> :t intercalate
06:44:56 <lambdabot> forall a. [a] -> [[a]] -> [a]
06:45:04 <rostayob> mike-burns: you're probably better off declaring your own instance anyway
06:45:18 <wavewave> mike-burns : haskell is the best language of generics ~~
06:45:34 <hpc> > intercalate " " ["this", "is", "", "a", "test"]
06:45:35 <lambdabot>   "this is  a test"
06:45:42 <hpc> that's how it works, basically
06:45:46 <kmc> wavewave, you've tried all the languages ever?
06:45:47 <hpc> put a space between all the elements
06:45:53 <mike-burns> I've tried declaring my own instance, using dummy data just to make sure I get te right number of result. http://hpaste.org/53267
06:45:55 <vharishankar> hpc: OK
06:45:56 <geheimdienst> vharishankar: you could always use filter (not . null) to throw out all the empty strings ...
06:45:58 <wavewave> kmc: no. ;-P
06:46:00 <mike-burns> But that gives me "mzero".
06:46:08 <vharishankar> geheimdienst: thanks.
06:46:22 <rostayob> also, "generics" is quite an overloaded word in pls
06:46:27 <mm_freak> wavewave: arrows are great for powerful abstractions, which simply aren't monads =)
06:46:31 <lambdanaut> What's the difference between (%!) and (%!%)  ?.. seen as the name of a function in a type signature
06:46:54 <wavewave> what I am saying is what I think. don't take too seriously. ;-P
06:47:12 <lambdanaut> I gather it has something to do with putting operators inbetween operands
06:47:39 <wavewave> kmc: but at least, I can say that haskell is the best language of generic among what I used.
06:47:49 <Eduard_Munteanu> lambdanaut: that's just the name
06:47:50 <rostayob> wavewave: what do you mean "language of generic"?
06:47:57 * mike-burns sighs
06:48:05 <mike-burns> Thanks for the help, rostayob and wavewave .
06:48:19 <wavewave> language for generic programming.
06:48:20 <lambdanaut> Eduard_Munteanu: So the % don't mean anything?
06:48:31 <lambdanaut> syntactically I mean
06:48:37 <Eduard_Munteanu> Nope.
06:48:41 <ski> lambdanaut : what's the difference between `ab' and `aba' ?
06:48:44 <hpc> > let (%!) = (+) in 15 %! 22
06:48:45 <lambdabot>   37
06:48:50 <lambdanaut> oh, haha thanks!
06:48:55 <wavewave> I remember there were some comparison about generics among languages.  let me find.
06:49:20 <vharishankar> Sorry for the IRC n00bishness, but how do people get that text within the chat window to say "So-and-so is doing this"?
06:49:30 <Eduard_Munteanu> Generics == C(++)'s idea of polymorphism?
06:49:33 <vharishankar> (I have always used online forums)
06:49:33 <rostayob> vharishankar: /me ?
06:49:42 <hpc> Eduard_Munteanu: java's idea of polymorphism
06:49:48 * rostayob is doing this
06:49:50 <hpc> as i understand it, designed by one of the simons
06:49:51 <Eduard_Munteanu> Ah.
06:49:56 <vharishankar> rostayob: thanks. I got to go and read up on IRC commands.
06:50:05 <Eduard_Munteanu> I think I've seen something like that for the upcoming C standard, though
06:50:07 * vharishankar wishes there was a way to learn everything overnight
06:50:09 <rostayob> Eduard_Munteanu: that was my point, in Java generics mean something completely different from examples
06:50:15 <vharishankar> Ha. it works.
06:50:25 <rostayob> it's magic
06:50:37 <rostayob> Eduard_Munteanu: while in haskell it means "generic traversal of ADTs"
06:50:49 <vharishankar> rostayob: it's funny, but I've never used IRC before #haskell.
06:51:07 <rostayob> vharishankar: #haskell is one of the greatest excuses for IRC eheh
06:51:09 <hpaste> chridi pasted ‚Äúnot in scope‚Äù at http://hpaste.org/53275
06:51:32 <vharishankar> rostayob: hehe...
06:51:46 <chridi> why cant i use P1 or P2 in a program where I import foo
06:51:48 <chridi> ?
06:52:30 <hpc> chridi: module Foo (P(..)) where ... -- that (..) there exports all the constructors
06:52:43 <hpc> chridi: you could also export P(P1, P2) iirc
06:52:53 <chridi> aaah
06:52:54 <chridi> thx :D
06:53:07 <chridi> i tried exporting P1 and P2, but they are no functions
06:53:50 <hpc> chridi: the idea is to allow programmers to export types but not constructors, for things like Rational
06:54:20 <ben> or IO~
06:54:24 <hpc> values are built with a function (%) instead of the constructor (:%), so it's possible to guarantee that stuff like (6 / 2) is reduced to (3 / 1)
06:54:24 <mm_freak> chridi: to export selectively (probably not a good idea for most things):  module Module (MyType(MyConst1, MyConst2))
06:54:28 <hpc> and also IO
06:55:03 <chridi> thanks.. works this way :)
06:55:52 <wavewave> @google A comparative study of language support for generic programming
06:55:54 <lambdabot> http://osl.iu.edu/publications/prints/2003/comparing_generic_programming03.pdf
06:55:54 <lambdabot> Title: A Comparative Study of Language Support for Generic Programming
06:56:31 <wavewave> rostayob , kmc : justification of my statement.
06:56:40 <wavewave> though it's old..
06:56:51 <wavewave> but now haskell has associated type
06:57:07 <rostayob> wavewave: they're talking about type classes there
06:57:24 <rostayob> which is my point, people use "generic programming" for the most different things
06:58:04 <rostayob> in that case, type classes and type parameters in data structures
06:58:24 <rostayob> but in haskell "generic programming" means something else
06:58:42 <mike-burns> OK, updated it with (Data, Typeable): http://pastebin.com/MetE14K1  and this is the code I'm trying, by the way: http://hpaste.org/53267 . It gives me "mzero" as a result.
06:58:44 <wavewave> rostayob: okay. but anyway parameterized type is at least regarded as a 'generic' programming way in generic sense of generics ;-)
06:58:44 <mauke> The paste MetE14K1 has been copied to http://hpaste.org/53276
06:59:50 <mike-burns> Error mzero  specifically.
07:00:40 <rostayob> wavewave: wat?
07:01:17 <rostayob> wavewave: the thing is that you were talking about Data and Typeable, which are not the generic programming that paper talks about
07:01:26 <rostayob> but anyway that's an interesting paper
07:01:50 <wavewave> rostayob: I understand your point indeed.
07:02:37 <wavewave> rostayob: I deliberately mix the meaning of generic in the previous statement.
07:02:43 <rostayob> eiffell is hilarious
07:02:43 <rostayob> they even say "in haskell generics mean something else" eheh
07:03:01 <mike-burns> But I want [Commit] as a result, not mzero.
07:03:55 <wavewave> rostayob: I guess when people use generics outside haskell community, they often just mean parameterized type.
07:04:07 <rostayob> mike-burns: I can't look at your code now, maybe later, but try to use Aeson.Generic in the meantime
07:04:10 <Abraxas> @help
07:04:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:04:44 <mike-burns> I had been. Ah well, maybe someone else will know in a few hours.
07:04:47 <wavewave> although they can have more support of runtime rep of type in dynamic language
07:05:16 <wavewave> which is usually what generics means in haskell community.
07:05:47 <wavewave> anyway, at least, I can safely say that haskell is the best language for generics. I would say so everywhere.
07:06:15 <mike-burns> It's awful at generics. I tried to use Data.Generics just now and it didn't magically work.
07:06:43 <mike-burns> I don't even understand it.
07:08:14 <wavewave> mike-burns : what was the problem you encounter?
07:08:24 <mike-burns> OK, updated it with (Data, Typeable): http://pastebin.com/MetE14K1  and this is the code I'm trying, by the way: http://hpaste.org/53267 . It gives me "mzero" as a result.
07:08:24 <mauke> The paste MetE14K1 has been copied to http://hpaste.org/53276
07:08:31 <mike-burns> But I want [Commit] as a result, not mzero.
07:09:58 <Abraxas> :t let ff x g y = g (x:y)
07:09:59 <lambdabot> <no location info>: not an expression: `let ff x g y = g (x:y)'
07:11:06 <wavewave> mike-burns: actually, I cannot interprete what you pasted.. so it it a result or a specification you want?
07:11:14 <Abraxas> :t let ff x g y = g (x : y); rev xs = foldr ff id xs [] in ff
07:11:16 <lambdabot> forall a t. a -> ([a] -> t) -> [a] -> t
07:11:40 <Abraxas> why is it t and not b?
07:11:41 <wavewave> mike-burns: last one is [Commit], isn't it?
07:12:08 <mike-burns> wavewave: It only gives me (Error mzero), never (Success [Commit]).
07:12:24 <hpc> :t let ff x g y = g (x : y) in ff
07:12:25 <lambdabot> forall a t. a -> ([a] -> t) -> [a] -> t
07:12:42 <hpc> :t let ff x g y = ?g (x : y) in ff
07:12:43 <lambdabot> forall a t t1. (?g::[a] -> t1) => a -> t -> [a] -> t1
07:12:53 <hpc> :t let ff x ?g y = g (x : y) in ff
07:12:54 <lambdabot> Parse error in pattern
07:13:05 <wavewave> mike-burns: is the last ,  in commits in JSON in your exampe valid?
07:13:37 <wavewave> mike-burns: I am ignorant of exact specification of JSON.
07:13:56 <mike-burns> wavewave: It should be valid; it was originally a longer JSON string than I cut down to two examples.
07:14:09 <mike-burns> I could have screwed up the editing, but I included the URL that generated it above.
07:14:59 <chrisdone> hey. i'm using libusb and libusb_process_events is sometimes returning LIBUSB_ERROR_INTERRUPTED meaning it was interrupted e.g. by a signal
07:15:00 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
07:15:14 <chrisdone> does the GHC runtime send signals to interrupt IO so that it can GC or something?
07:15:31 <chrisdone> i have the same test case code running from C and no such interrupt is ever sent
07:17:03 <mike-burns> wavewave: It's probably worth noting that the desired data structure contains massaged and extra data; the repo name is not in the JSON, for example, and the shortened SHA is derived from the real SHA.
07:20:29 <wavewave> mike-burns: I see. wait a minute. I am actually making my own test of your case.
07:25:39 <hpaste> wavewave annotated ‚Äúpastebin.com/MetE14K1‚Äù with ‚Äúpastebin.com/MetE14K1 (annotation)‚Äù at http://hpaste.org/53276#a53277
07:26:08 <wavewave> mike-burns: would you try this code? it looks working.
07:26:13 <mike-burns> Trying it now!
07:26:50 <wavewave> mike-burns: no wait. .
07:27:00 <wavewave> mike-burns: wait a moment.
07:28:35 <mike-burns> Yeah.
07:28:52 <mike-burns> Oh I have to run to the Scala meetup now.
07:29:09 <mike-burns> wavewave: Thanks a bunch for the help and suggestions. If you get it let me know; I idle in here.
07:40:39 * hackagebot freenect 1.0 - Interface to the Kinect device.  http://hackage.haskell.org/package/freenect-1.0 (ChrisDone)
07:41:29 <hpaste> geheimdienst pasted ‚Äútrapd-in-io-monad-plz-halp‚Äù at http://hpaste.org/53278
07:42:15 <geheimdienst> so, i've again managed to confuse myself. i was under the impression "x <- a ; blah x" is the same as "blah =<< a", but apparently it isn't
07:42:21 <geheimdienst> (see paste)
07:42:48 <sipa1024> @src (=<<)
07:42:48 <lambdabot> f =<< x = x >>= f
07:45:02 <profmakx> t looks like a spaceship!
07:46:18 <geheimdienst> apparently >>= dispatches based on the types of its arguments, and wants them to be of the same type. what i had in mind was just "unwrapping" the IO Client into Client, since the do block is IO. (same goes for =<<)
07:47:03 <sipa1024> >>= needs sometfing of type m a, and something of type a -> m b
07:47:13 <byorgey> geheimdienst: x <- a; blah x   is the same as  blah =<< a.   x <- a; let foo = blah x  is not.
07:47:23 <mah_b> isnt x <- a; let z = blah x === z <- (a >>= blah)?
07:47:53 <byorgey> mah_b: only if blah has the right type.
07:47:54 <geheimdienst> byorgey: :-o you mean because of the DMR?
07:47:59 <byorgey> in this case, the monads do not match.
07:48:04 <byorgey> geheimdienst: no, just because.
07:48:23 <mah_b> byorgey: so it should be z <- liftM blah a?
07:48:49 <wavewave> mike-burns:  you cannot use just generic because of two things. First, top-level commits is not defined as your data type.. Second, the name of field is different from your data type record field name (generic library assumes so.)
07:48:52 <byorgey> no. geheimdienst is trying to mix two different monads.
07:49:15 <Peaker> geheimdienst: it is the same -- in your paste you're comparing a simple binding of "x" to an ErrorT value, vs. binding an IO and ErrorT value
07:49:15 <geheimdienst> interesting. the let isn't essential, i initially ran into the problem when it was part of a larger expression: [(stuff, f =<< connectSession)]
07:49:24 <wavewave> mike-burns : in this case, you should use FromJSON or choose your field name carefully so that it can match with the JSON field names
07:49:28 <byorgey> connectSession :: IO Client;  f :: Client -> ErrorT Errno IO Entry.   connectSession >= f  does not typecheck because  IO  is not the same as  ErrorT Errno IO.
07:49:37 <byorgey> the error message is a good one.
07:49:47 <wavewave> mike-burns: I would use FromJSON. it's easy to use.. wait a minit.
07:51:11 <geheimdienst> :t (=<<)
07:51:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:51:20 <ski>   liftIO connectSession :: ErrorT Errno IO Client
07:51:42 <ski>   f =<< liftIO connectSession :: ErrorT Errno IO Entry
07:52:03 <mm_freak> is there something along the lines of 'fail' for pattern match failures in arrow notation?
07:52:14 <mm_freak> like for:  Just x <- someComp -< someInput
07:52:55 <mm_freak> an ArrowChoice requirement would be fine
07:53:12 <wavewave> mike-burns: even I found the reponame does not exist in your JSON.
07:54:02 <geheimdienst> ok, so the root cause is the m in that type signature. what i tried would need something like (a -> n b) -> m a -> n a
07:54:47 <ski> mm_freak : <http://www.haskell.org/arrows/syntax.html> : "Patterns that could fail aren't yet handled as specified, partly because the preprocessor currently doesn't have access to all imported modules to figure out whether constructors are unique. (And maybe the specified treatment isn't such a great idea anyway.)"
07:54:52 <byorgey> mm_freak: I seem to recall that it works with zeroArrow from the ArrowZero class
07:55:02 <byorgey> mm_freak: and ArrowChoice
07:55:38 * ski isn't sure `ArrowChoice' is relevant here
07:56:31 <ski> (mm_freak : of course, that doesn't explain whether the GHC implementation supports it or not ..)
07:56:54 <byorgey> ski: if you follow the "as specified" link it gives a translation involving ArrowChoice and ArrowZero
07:57:09 <byorgey> it might be possible to do with out ArrowChoice but I'm not sure
07:57:23 <ClaudiusMaximus> http://www.haskell.org/arrows/sugar.html section "Translation"
07:57:29 <ClaudiusMaximus> oh, i'm slow...
07:57:35 <byorgey> =)
07:57:42 <mm_freak> byorgey: oh, indeed
07:57:42 <geheimdienst> thanks everyone for the competent help :) the liftIO fixed it, thanks ski
07:57:45 <mm_freak> thanks
07:58:05 <mm_freak> ski: i'm sure that ArrowChoice is a requirement
07:58:07 <byorgey> no idea whether that page at all corresponds to what GHC actually implements.  There have been serveral slightly different arrow notation proposals over the years.
07:58:20 <Abraxas> when i have this: foldl' f z xs = foldr step id xs z where step x g a = g (f a x)...i cannot say that id=x and so on...how can i systematically identify all the types?
07:58:24 <ski> mm_freak : for `case' and `if', sure
07:58:55 * ski was however pondering potentially failing patterns, as well as patterns matching in more than one way
07:59:10 <mm_freak> ski: it needs something like (||| zeroArrow)
07:59:32 <ski> "it" being ?
07:59:33 <mm_freak> i'm pretty sure it does need it anyway
07:59:48 <mm_freak> ski: catching the failing pattern
08:00:09 <mm_freak> but i have no arrow at hand, which supports ArrowZero, but not ArrowChoice =)
08:00:26 <ski> hm, i see
08:00:27 <mah_b> Abraxas: no, first g = id, and x is the first elem of the list.
08:00:44 * ski wonders whether one could sensibly remove that constaint
08:00:55 <mm_freak> > (proc _ -> returnA -< "yes, i have arrow notation") ()
08:00:56 <lambdabot>   Pattern syntax in expression context:
08:00:57 <lambdabot>      proc (_) -> returnA -< "yes, i h...
08:01:18 <mah_b> Abraxas: then, g = a -> id (f a x) and x = next element.
08:01:56 <mm_freak> ski: i don't think you can do it without ArrowChoice, because catching the failing pattern match effectively makes an implicit 'case' with a catch-all
08:02:13 <mah_b> Abraxas: when we now evalu. step, we get a -> id (f (f a x1) x2). and so on. you can see the pattern of foldr.
08:02:28 <hpaste> wavewave annotated ‚Äúpastebin.com/MetE14K1‚Äù with ‚Äúpastebin.com/MetE14K1 (annotation)‚Äù at http://hpaste.org/53276#a53279
08:02:57 <wavewave> how can I send a message using lambdabot? @tell?
08:03:16 <ski> mm_freak : one could possibly make a new primitive -- the question is whether there's any point in doing that
08:03:31 <mah_b> @tell wavewave let's test tell
08:03:31 <lambdabot> Consider it noted.
08:03:49 <mm_freak> ski: why?  ArrowChoice is there for exactly that purpose
08:03:53 <wavewave> @tell mike-burns I made a successful version of the parser and append it to the original hpaste.
08:03:53 <lambdabot> Consider it noted.
08:04:05 <ski> @help ask
08:04:06 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
08:04:33 <mm_freak> ski: you could do it with ArrowApply, of course, but then you would require arrows with builtin handlich of pattern match failures to be monadic arrows
08:04:45 <mm_freak> handling*
08:05:00 <ski> mm_freak : it's not clear to me that this is requires the full power
08:05:07 <ski> s/this is/this use/
08:05:20 <wavewave> @tell mike-burns To use generic, you should have matched record field name with the field name used in JSON. In this case, do not use generic. using generic without understanding it may be difficult since the error message is very cryptic.
08:05:20 <lambdabot> Consider it noted.
08:05:40 * hackagebot freenect 1.0.1 - Interface to the Kinect device.  http://hackage.haskell.org/package/freenect-1.0.1 (ChrisDone)
08:05:58 <Abraxas> mah_b: can't help myself but i must be missing something fundamental
08:06:14 <mah_b> Abraxas: whats wrong?
08:06:16 <Abraxas> step id up there, and step x g... down there
08:06:17 <mm_freak> ski: i think it does‚Ä¶  this feature requires conditional structure:  either proceed with the rest of the computation or proceed with zeroArrow
08:06:24 <Abraxas> but g=id?
08:06:26 <mm_freak> this is exactly the purpose of ArrowChoice
08:06:52 <mm_freak> ski: it's not apparent from the way ArrowChoice is defined, though
08:07:04 <Abraxas> id is the first argument in the call to step, but second in the definition?
08:10:07 <wavewave> @tell mike-burns http://hpaste.org/53275#a53279
08:10:07 <lambdabot> Consider it noted.
08:10:27 <wavewave> @tell mike-burns oops : http://hpaste.org/53276#a53279
08:10:27 <lambdabot> Consider it noted.
08:12:38 <Abraxas> the strange thing is that you can play around with haskell for quite some time and still don't understand something that's probably still basics...i am confused as hell
08:13:41 <Abraxas> i don't get where the x is coming from, how it goes in front of the id aka g
08:15:37 <Abraxas> x=z, but how does it swap places
08:16:20 <mah_b> Abraxas: http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+afoldl+f+z+xs+%3D+foldr+%28%5Cx+g+a+-%3E+g+%28f+a+x%29%29+id+xs+z%0D%0Ain+afoldl+%28%2B%29+0+%5B1%2C2%2C3%5D
08:17:10 <mah_b> Abraxas: the whole trick is to have an accumulator that is a function.
08:18:46 <mah_b> Abraxas: the 4. evauluation step shows this.
08:20:40 * hackagebot freenect 1.0.2 - Interface to the Kinect device.  http://hackage.haskell.org/package/freenect-1.0.2 (ChrisDone)
08:21:30 <Saizan> Abraxas: seen this? http://hpaste.org/53272
08:22:27 <mm_freak> can i somehow hide specific instances defined in other libraries for the purpose of debugging?
08:23:19 <Abraxas> no, thanks =)
08:23:38 <Saizan> also reverse = foldl (flip (:)) []
08:24:01 <Abraxas> i was about to ask for a step eval
08:24:07 <Abraxas> ty
08:24:24 <ski> @where stepeval
08:24:25 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
08:24:35 <Abraxas> lol
08:24:59 <ski> (for easy reference)
08:25:06 <Abraxas> i should really play around with that a lot
08:25:46 <Abraxas> although i've seen the stepeval for this posted on stackoverflow
08:31:34 <mm_freak> byorgey, ski: i was wrong‚Ä¶  pattern match failures are not catched in proc/do
08:32:05 <mm_freak> quite unfortunate =/
08:32:32 <byorgey> oh, too bad =(
08:32:39 <mm_freak> i tried with a custom arrow and with Kleisli Maybe
08:34:02 <mm_freak> proc _ -> do 3 <- Kleisli (const $ Just 4) -< (); returnA -< ()  -- throws an exception instead of giving me Nothing
08:35:53 <ski> ok
08:42:12 <Abraxas> starting to grasp it, but i think i need to know a few things without which this seems like "magic"
08:42:35 <Abraxas> and i can't exactly say what :D
08:42:44 <byorgey> Abraxas: I missed the context, what code are you contemplating?
08:43:34 <Abraxas> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+afoldl+f+z+xs+%3D+foldr+%28%5Cx+g+a+-%3E+g+%28f+a+x%29%29+id+xs+z%0D%0Ain+afoldl+%28%2B%29+0+%5B1%2C2%2C3%5D   and   http://hpaste.org/53272
08:43:49 <Abraxas> foldl to foldr
08:43:58 <Abraxas> *as
08:44:54 <byorgey> oh, yeah, that's tricky
08:44:57 <Abraxas> i already struggle with flipping it
08:45:13 <Abraxas> why i can do that
08:45:31 <byorgey> Abraxas: oh, the definition in the hpaste is wrong
08:45:44 <byorgey> Abraxas: foldl1 calls foldl but it should call foldl1
08:46:13 <byorgey> so it's the same as foldl but just with its last two arguments switched
08:46:20 <SeroPositief> DOWS
08:46:53 <Saizan> ah, yeah, sorry
08:48:25 <hpaste> byorgey annotated ‚Äúfoldl derivation‚Äù with ‚Äúfoldl derivation (fix errors)‚Äù at http://hpaste.org/53272#a53281
08:49:20 <BlankVerse> how to resolve dependency hell in cabal :
08:50:03 <BlankVerse> http://dpaste.com/643561/
08:50:41 <Abraxas> so in foldl' f z xs = foldr step id xs z where step x g a = g (f a x) it seems like two versions of step are used, one implicitly flipped
08:50:48 <byorgey> BlankVerse: what are you trying to build?
08:50:54 <BlankVerse> a yesod app
08:50:55 <Abraxas> i don't get that
08:52:21 <Saizan> Abraxas: nope, it's just one version of step
08:52:39 <byorgey> Abraxas: first, foldr step id (a:b:c:[]) = step a (step b (step c id)),  right?
08:52:55 <cebrian> Hi, I have a problem looking for a common pattern
08:53:01 <cebrian> say you have a list of strings
08:53:06 <byorgey> now we can apply that whole thing to z and use the definition of step
08:53:19 <cebrian> and I'd like a Map with the first ocurrence of a word with a given letter
08:53:28 <cebrian> how would you implement that
08:53:46 <cebrian> foldl does not help because I need to check the accumulated structure
08:53:56 <byorgey> Abraxas: step a (step b (step c id)) z --> step b (step c id)) (f z a) --> (step c id) (f (f z a) b) --> etc.
08:53:57 <cebrian> when checking for the solution
08:54:08 <hpc> :t foldl
08:54:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:54:11 <hpc> :t foldr
08:54:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:54:26 <cebrian> any ideas on how this could be implemented
08:54:29 <cebrian> ??
08:55:58 <byorgey> cebrian: I think just a normal foldl works, in conjunction with insertWith
08:56:25 <byorgey> if you do  insertWith const  it will insert a value if the key doesn't exist, and ignore the new value if it does
08:56:45 <byorgey> unless I am misunderstanding what you're trying to do
08:57:22 <cebrian> mmm
08:57:34 <byorgey> BlankVerse: it looks like http-enumerator requires an old version of asn1-data.
08:57:35 <Abraxas> ok i see
08:57:36 <cebrian> perhaps you are right, I'll try to implement that
08:57:41 <cebrian> thanks
08:57:56 <Abraxas> laziness + id
08:58:12 <byorgey> BlankVerse: one thing to try would be:  cabal unpack http-enumerator; cd http-enumerator; $EDITOR http-enumerator.cabal; cabal install
08:58:38 <byorgey> BlankVerse: when you edit the .cabal file change the upper bound for asn1-data to <0.7, and hope it works
08:58:56 <Abraxas> i am still trying to take parts of a definition and apply them somewhere else, disregarding laziness
08:59:17 <byorgey> Abraxas: I don't see what laziness has to do with anything.
08:59:48 <Abraxas> even worse then
08:59:57 <Abraxas> i think i understand it but i am wrong
09:00:23 <byorgey> Abraxas: laziness just affects what order things are evaluated in.  If you disregard infinite loops and undefined/error, laziness vs. strictness doesn't change the *meaning* of the code
09:00:25 <Abraxas> just left to right application then
09:01:11 <Abraxas> like in the stepeval, i should just read through it before starting to read something else and get hung up on that other thing
09:01:23 <byorgey> Abraxas: yeah, remember that  f a b c == (((f a) b) c)
09:02:42 <Abraxas> i mean, the step id is folded through the list first, then the id was applied and i have the order as in the def...that totally confused me
09:03:53 <byorgey> Abraxas: if it makes you feel any better, I have been programming in Haskell almost exclusively for about four years, and I still can't understand that definition of foldl by just staring at it
09:04:06 <hpc> byorgey: i don't think anyone can :P
09:04:10 <byorgey> sometimes you just have to carefully work through the steps of evaluation on an example, like I did above
09:04:11 <hpc> @src foldl
09:04:12 <lambdabot> foldl f z []     = z
09:04:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:04:22 <hpc> the explicit definition is waaaaay easier to visualize
09:04:31 <hpc> (for certain values of easy, ofc)
09:04:41 <byorgey> hpc: agreed
09:04:53 <cebrian> byorgey: I have a problem with insertWith syntax
09:04:58 <cebrian> say I have
09:05:13 <cebrian> let words = ["tree","icecream", "top"]
09:05:25 <cebrian> I want a Map in return as
09:05:54 <cebrian> fromList [("t","tree"),("i","icecream")]
09:06:04 <Abraxas> this does indeed make me feel better, thanks :D
09:06:16 <cebrian> where I would have a Map of at least 26 values
09:06:35 <cebrian> the word is always the first encountered
09:06:40 <cebrian> in the list
09:06:42 <byorgey> cebrian: ok, so a map from each letter to the first word in the list starting with that letter?
09:06:47 <byorgey> right, OK
09:06:48 <cebrian> yes
09:08:00 <Abraxas> i should have been staring at the stepeval before trying anything else
09:09:38 <byorgey> cebrian: so the idea is to do a foldl so the first thing inserted into the Map will be the first thing in the list
09:10:17 <byorgey> cebrian: but instead of a normal insert you do insertWith which lets you specify how to combine the values in case there is already a mapping for the key being inserted
09:10:27 <byorgey> in this case, we just want to ignore the new value
09:10:50 <byorgey> so I guess that is actually  insertWith (flip const) instead of  insertWith const,  because the new value is the first argument to the combining function
09:11:03 <byorgey> > const "new" "old"  -- not what we want
09:11:04 <lambdabot>   "new"
09:11:16 <byorgey> > (flip const) "new" old"  -- that's better, keep the old value
09:11:17 <lambdabot>   <no location info>:
09:11:17 <lambdabot>      lexical error in string/character literal at end o...
09:11:25 <d-snp> hey, how would I extract the portnumber from this data type? http://www.haskell.org/ghc/docs/6.10.3/html/libraries/network/Network-Socket.html#v%3ASockAddrInet
09:11:33 <d-snp> it doesn't seem to have a field..
09:12:08 <cebrian> byorgey: but with the insertWith
09:12:13 <cebrian> I have to specify a Map
09:12:25 <cebrian> how that map interacts with fold's map?
09:12:27 <Abraxas> in the step eval, why is id [] = id...or what happens there?
09:14:03 <parcs> d-snp: through pattern matching on SockAddrInet
09:14:15 <mirari> I'm reading the "History of Haskell" from HOPL-3 and in that paper the authors write that Haskell can be written in "declarative" and "expression" style. Which of these styles are consider the better? I'm new to Haskell, but quickly thinking about Real World Haskell leads me to believe that the declaritive is prefered.
09:15:11 <byorgey> cebrian: the first argument of foldl' is a function which takes as its first argument the current Map.  you pass that Map as the argument to insertWith.
09:15:46 <byorgey> cebrian: so  foldl' (\m w -> ... )  -- pass m as an argument to insertWith
09:16:20 <cebrian> ok, let write it down
09:16:22 <byorgey> Abraxas: the second argument to foldr is the value that should replace the empty list
09:16:25 <cebrian> ok, let me write it down
09:16:34 <byorgey> > foldr f z (a:b:c:[])
09:16:35 <lambdabot>   f a (f b (f c z))
09:16:45 <byorgey> Abraxas: see, z replaced the empty list at the end
09:16:50 <byorgey> in this case z =id
09:17:06 <McManiaC> I want this extension: http://npaste.de:8080/qGP/
09:17:37 <byorgey> d-snp: I don't know the answer to your question, but you do know that is the documentation for ghc 6.10.3 ?
09:17:55 <cebrian> wow, works like a charm
09:18:02 <cebrian> byorgey, foldl (\m w -> insertWith (flip const) (head w) w m) empty words
09:18:16 <cebrian> thank you a lot
09:18:41 <embwbam> I'm only halfway through reading a book on Haskell (read: noob here), and I'm trying to install miku, the web framework, as my first cabal package. Miku installs, but not hack2-handler-snap-server (which it apparently requires) - https://gist.github.com/1324724 - Any idea what I'm doing wrong?
09:19:10 <embwbam> I don't know enough to understand the error messages, really, or to know if I'm running the wrong version of ghc, or something
09:19:12 <BlankVerse> byorgey: when in unpacked http-enumerator , it was already <0.7 ....
09:19:28 <BlankVerse> byorgey: but cabal install shows that it had <0.6
09:20:17 <hpc> embwbam: one of the packages has a broken dependency, i think
09:20:40 <embwbam> hpc: does that happen a lot for cabal packages? Or is this kind of a freak occurance?
09:20:41 <hpc> embwbam: one of the packages changed what it was doing, and the other package depended on the old behavior, is my guess
09:21:10 <embwbam> hpc: Do the packages not depend on other packages at a particular version number to prevent that?
09:21:15 <hpc> embwbam: i don't know much about hackage as a whole, or how to fix the error without contacting the maintainer
09:21:29 <embwbam> hpc: Cool, I'll do that
09:21:32 <hpc> i know it's possible though, so someone else can probably help
09:21:41 <hpc> and yeah, contact the maintainer anyway :P
09:21:57 <Abraxas> ok thanks!
09:22:00 <geheimdienst> i'm working with a library that gives me Data.Text a lot. the rest of the program uses String. any trickery to avoid pack-unpack hell? possibly involving polymorphism or whatnot
09:22:42 <byorgey> cebrian: you're welcome =)
09:23:08 <byorgey> BlankVerse: hmm, maybe it was a different version of http-enumerator
09:23:54 <monochrom> (A) rewrite the rest to use Text too, may be a benefit. (B) write your own type class to polymorphize over Text and String, there is none yet and everyone seems to want one
09:24:34 <geheimdienst> monochrom: interesting, what are the benefits under A?
09:24:42 <monochrom> perhaps faster
09:25:16 <BlankVerse> byorgey: how do i make cabal use that version for dependency resolution?
09:25:40 <byorgey> BlankVerse: --constraint 'foo ==0.99.3' or whatever
09:25:40 * hackagebot hashable 1.1.2.2 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.1.2.2 (JohanTibell)
09:25:45 <BlankVerse> byorgey: because cabal is using the older verion for sure
09:26:08 <byorgey> BlankVerse: unfortunately, if cabal is using the older version its probably because some other package requires it
09:26:24 <hpc> geheimdienst: i think there's an extension that turns string literal stuff into IsString s => s, if that's the kind of packing trouble you have
09:26:37 <BlankVerse> byorgey: i think i can check which other package depends on that older package
09:27:05 <geheimdienst> hpc: yeah, unfortunately the Strings floating around are not just string literals in source code
09:27:14 <byorgey> BlankVerse: at least --constraint=blah should give you a better error message
09:27:29 <monochrom> IsString polymorphizes for string literals only, i.e., "hello world" --> String or ByteString or Text
09:28:25 <monochrom> a much fatter type class is usually wanted, e.g., polymorphic_lines :: a -> [a]
09:28:43 <BlankVerse> byorgey:  --constraint=DEPENDENCY    , here dependeny is only the v ersion?
09:29:07 <BlankVerse> cabal install --constraint 'http-enumerator=0.7.1.2'
09:29:12 <BlankVerse> cabal: dependency expected
09:30:13 <geheimdienst> monochrom: you mean the typeclass should have generic variants of all kinds of prelude functions?
09:30:14 <copumpkin> @ask tibbe have you considered renaming the Hashable class to just Hash, since it seems like Haskell tries to avoid the -able naming convention wherever possible (think of Show, Read). You could use ConstraintKinds to provide synonym for effortless migration, too!
09:30:14 <lambdabot> Consider it noted.
09:30:28 <monochrom> yes
09:30:55 <tibbe> copumpkin: I considered it at some point yes
09:30:55 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
09:31:13 <tibbe> copumpkin: but I want Hash for a new type for Word :)
09:31:33 <copumpkin> Hashed?
09:31:39 <tibbe> yeah
09:31:45 <copumpkin> I mean, that could be another shorter name
09:31:54 <copumpkin> but it's really not that big a deal. It just sticks out a bit :)
09:31:54 <tibbe> I think we're really bad at naming classes actually
09:32:06 <copumpkin> we are, but I also hate -able :P
09:32:08 <tibbe> IsString
09:32:11 <byorgey> BlankVerse: http-enumerator ==0.7.1.2
09:32:21 <copumpkin> yeah, that makes me shudder and is what made me think of it (people were just talking about it)
09:32:26 <tibbe> but we can't use Map for a map type class as it's taken, etc
09:32:28 <byorgey> BlankVerse: the format is 'package-name version-constraint'
09:32:42 <tibbe> we use the same naming scheme both for types and type class, that will not really work out
09:32:43 <byorgey> BlankVerse: version-constraint can be something like ==version or <version etc.
09:32:44 <monochrom> s/Applicative/Applicable/  XD
09:33:10 <monochrom> s/Num/Computable/ XD XD
09:33:11 <copumpkin> tibbe: the only option is to do like the C# people do
09:33:19 <copumpkin> and stick an I prefix onto everything ;)
09:33:21 <copumpkin> INum
09:33:23 <copumpkin> IHash
09:33:27 <copumpkin> :P
09:33:29 <byorgey> Stringable!
09:33:39 <copumpkin> Stranglable
09:33:44 <byorgey> haha
09:33:44 <monochrom> IWhack
09:34:28 <monochrom> http://ars.userfriendly.org/cartoons/?id=19980920
09:37:02 <monochrom> Functor -> IMap, Applicative -> IApply, Monad -> IBind, MonadZero -> IFail
09:37:04 <geheimdienst> a one-letter prefix or suffix wouldn't be too bad really. we have things like mapM and forM_ already, and it's short and clear
09:37:49 <hpc> and no risk of apple suing because the 'I' is capitalized
09:39:30 <monochrom> the one-letter prefix of C# is definitely a logical consequence of Microsoft Hungarian notation, iN, szName, wtfBBQ
09:40:01 <copumpkin> NSNum
09:40:13 <copumpkin> NSRealFloat
09:40:22 <copumpkin> (wtf is up with the RealFloat name, anyway)
09:40:31 <geheimdienst> i think in small doses, hungarian notation can clarify things nicely (if you go overboard of course it becomes silly)
09:40:32 <monochrom> real and float
09:40:50 <hpc> geheimdienst: like for handle operations and stuff like that
09:40:54 <hpc> hBlah
09:40:56 <copumpkin> @src Real
09:40:57 <lambdabot> class  (Num a, Ord a) => Real a  where
09:40:57 <lambdabot>     toRational      ::  a -> Rational
09:40:59 <copumpkin> that's the best joke ever
09:41:25 <monochrom> hungarian notation was appealing when in the 1980s you couldn't hover your cursor over a name and have its type displayed
09:41:35 <Philippa> GHC representations/rank-n question: aside from boxing, is there any run-time cost to keeping a value known-polymorphic?
09:41:38 <hpc> @quote add copumpkin @src Real ... <copumpkin> that's the best joke ever
09:41:39 <lambdabot> No quotes for this person. My brain just exploded
09:41:48 <hpc> @remember copumpkin @src Real ... <copumpkin> that's the best joke ever
09:41:48 <lambdabot> Done.
09:41:51 <copumpkin> Philippa: I don't think so
09:41:55 <monochrom> hungarian notation does not scale to Haskell types
09:42:33 <Philippa> copumpkin: just realised it doesn't actually buy me as much as I'd like anyway, but thanks :-)
09:43:34 <geheimdienst> copumpkin: "yeah let's stick our company initials to the beginning of all classes. that will surely never change. and at the low cost of cluttering everything, it saves you from all those situations where you momentarily forget what platform you're programming for"
09:43:38 <Philippa> supposing I've got object- and meta-level representations of some term type - the latter getting to carry things like metavariables - anyone got a way to do that so that you can do a "possibly not all object-level" -> object-level cast without any additional construction?
09:43:52 <copumpkin> geheimdienst: it's just cause objc doesn't have namespacing
09:44:01 <Philippa> (obv. you're going to have to pattern-match the whole term to check it's not 'contaminated')
09:44:04 <copumpkin> so that was their lame attempt at making it so
09:44:22 <BlankVerse> cabal install http-enumerator --constraint '==0.7.1.2' byorgey
09:44:50 <BlankVerse> i cant have 2 versions of same package installed at the same time , right?
09:45:24 <luite> BlankVerse: you can
09:45:30 <monochrom> can. but not always useful.
09:45:44 <BlankVerse> luite: i need to keep 2 versions so that my app works
09:46:05 <BlankVerse> their are 2 dependencies in my app which required different versions of same package
09:46:06 <luite> depending on multiple versions in a single app is likely to cause problems
09:46:36 <monochrom> some scenerios cause problems, and some other scenerios cause no problem.
09:46:39 <BlankVerse> so i should change the dependeny for the older app to use the newer version
09:47:43 <luite> which apckage requires the older one?
09:47:49 <BlankVerse> when i do cabal unpack http-enumerator  , its cabal file requires  asn1 < 0.7
09:48:02 <BlankVerse> but when i do cabal install , it says it requires asn1 < 0.6
09:48:59 <monochrom> strange?
09:49:16 <luite> do you already have one installed?
09:50:35 <monochrom> also, "asn1-data             >= 0.5.1   && < 0.7", totally shouldn't force two versions on you
09:51:27 <monochrom> (straight from http://hackage.haskell.org/packages/archive/http-enumerator/0.7.1.3/http-enumerator.cabal )
09:51:30 <McManiaC> wooh, I just got a context reduction stack overflow error message
09:51:30 <BlankVerse> ghc-pkg list gives http-enumerator-0.7.1.2
09:52:04 <monochrom> 0.7.1.2 still say "asn1-data             >= 0.5.1   && < 0.7"
09:53:11 <BlankVerse> monochrom: i get this error
09:53:12 <BlankVerse> http://dpaste.com/643584/
09:53:17 <McManiaC> http://npaste.de:8080/dKF/
09:53:18 <McManiaC> :D
09:53:30 <geheimdienst> it occurs to me that "first letter lowercase for functions, capital letter for types" is a kind of hungarian notation already. maybe for typeclasses we need a new case for letters ... moar capital letters
09:53:37 <BlankVerse> monochrom:  ghc-pkg list | grep asn
09:53:37 <BlankVerse>     asn1-data-0.6.1
09:53:49 <qwer123> What does :t nospell affect ?
09:54:37 <monochrom> http-enumerator-0.6.7?! I thought you said <BlankVerse> ghc-pkg list gives http-enumerator-0.7.1.2
09:54:56 <BlankVerse> ghc-pkg list | grep http-en http-enumerator-0.7.1.2
09:55:13 <BlankVerse> cabal install sees http-enumerator-0.6.7
09:55:21 <monochrom> cabal update?
09:55:22 <BlankVerse> but ghc-pkg sees http-enumerator-0.7.1.2
09:56:16 <BlankVerse> cabal is updateed
09:56:20 <BlankVerse> but still same error
09:56:34 <qwer123> Sorry, I meant: What does :set Nospell do
09:58:17 <luite> BlankVerse: what are you trying to install?
09:58:33 <BlankVerse> a yesod-demo app
09:58:41 <luite> it must be somethign else forcing the lower http-enumerator, look here: http://packdeps.haskellers.com/reverse/http-enumerator
09:58:44 <luite> which one?
09:58:47 <BlankVerse> http://paste.pocoo.org/show/500059/
09:59:37 <luite> hmm, that depends on an older yesod, do you really want to install that?
10:02:00 <monochrom> I wonder if relaxing the yesod constraint just works. "yesod        >= 0.8     && <= 0.9"
10:02:03 <monochrom> err
10:02:20 <monochrom> "yesod        >= 0.8     && < 1.0"
10:02:37 <luite> probably 0.10
10:03:17 <monochrom> you should have pasted http://paste.pocoo.org/show/500059/ much earlier and said "I am doing 'cabal install' on that"
10:03:30 <hpc> does cabal have a "show me what i need to install this" option?
10:03:35 <monochrom> all along I was thinking you were "cabal install http-enumerator"
10:03:43 <hpc> such a thing would be nice to have on hackage as well
10:03:52 <monochrom> --dry-run
10:04:00 <hpc> a complete tree, not just the stuff listed in the .cabal file
10:04:08 <hpc> groovy
10:04:18 <luite> BlankVerse: there have been a few changes in the yesod api, I don't think it will run without changes on 0.9
10:04:24 <monochrom> as a flat list, not as a tree, but still valuable
10:04:49 <monochrom> (it could be a DAG)
10:05:04 * copumpkin has been working with tries of HLists in haskell without realizing it!
10:05:40 * hackagebot text 0.11.1.7 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.7 (BryanOSullivan)
10:05:42 * hackagebot hack2-handler-snap-server 2011.10.30 - Hack2 Snap server handler  http://hackage.haskell.org/package/hack2-handler-snap-server-2011.10.30 (JinjingWang)
10:07:58 <luite> BlankVerse: btw it's probably a good idea to use cabal-dev for these things, web apps tend to have a huge number of dependencies, and that can mess up your package db
10:10:30 <qwer123> :set nospell is just a vim-command
10:10:45 <qwer123> <> to :set spell
10:15:40 * hackagebot network 2.3.0.7 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.7 (JohanTibell)
10:16:41 <monochrom> BlankVerse: add --constraint='certificate < 0.9.2'. here is the resolution: http://paste.pocoo.org/show/500068/
10:17:10 <monochrom> but what luite says about cabal-dev. sandbox it.
10:21:27 <BlankVerse> does cabal-dev install not reuse the global/user packages?
10:21:47 <monochrom> it reuses global. not sure about user.
10:27:37 <BlankVerse> can i explicitly make it use pre-installed packages .. installing yesod in sandbox takes a lot of time
10:28:14 <monochrom> I don't know.
10:35:45 <AfC> Is there a way to ask cabal to pre-fetch (ie, while you still have network access) all the tarballs for a given install run?
10:44:39 <monochrom> use 'cabal install --dry-run ____' to get a list. for each in the list, 'cabal fetch ____'
10:44:51 <mirari> I have a data type declaration like: data Inst = Push Int | Pop | Branch [Inst]  [Inst] | etc, but now I need to be able to distinguish between different the different constructors, so i'm thinking about wrapping Inst in some other data type, but then I still need extra constructors to handle the "Branch" constructor. How is such a problem best modeled in Haskell?
10:46:14 <mauke> mirari: what's the problem?
10:47:23 <monochrom> pattern matching distinguishes between the different constructors
10:47:24 <mirari> Whether or not its a good idea to wrap my data type
10:47:41 <mauke> mirari: why wrap?
10:47:51 <mirari> Because if apply the pattern again (because I need some other extra data) I might end up with some thats wrapped alot of times
10:47:57 <monochrom> case x of { Push n -> .... ; Pop -> .... ; Branch xs ys -> ... }
10:48:07 <mauke> mirari: why wrap?
10:48:20 <mirari> mauke: Well if there are 20 constructors, then it makes sense not to repeat them all, but only the ones that are necessary for the types to compile?
10:48:27 <mauke> what?
10:48:29 <mirari> or atleast, that's what I was thinking
10:48:52 <monochrom> I only see 3 constructors
10:49:16 <mirari> Yes, but the real instance has around 15+
10:49:34 <monochrom> then bite the bullet and write 15 patterns
10:50:07 <mirari> okay :)
10:53:02 <Abraxas> (\x -> foldr (||) False . map (==x)) 2 [1..5] == (\x -> foldr ((||).(==x)) False) 2 [1..5]
10:53:26 <Abraxas> if i want to replace || with f in general, how do i have to write it for the equation to hold?
10:54:02 <mauke> huh?
10:54:31 <Abraxas> (\x -> foldr f False . map (==x)) 2 [1..5] == (\x -> foldr (f.(==x)) False) 2 [1..5]
10:54:35 <Abraxas> then f must be Bool
10:54:55 <monochrom> pick a variable to replace Bool
10:54:57 <Abraxas> can i define the type with the same notation
11:01:11 <goll1951> ! lista
11:02:50 <goll1951> ciao
11:02:54 <goll1951> ! lista
11:03:03 <BlankVerse> any library for scaling images size in haskell
11:13:11 <mm_freak> is there a library for writing .o object files?
11:15:16 <fazzone> @pl \a b -> map (a b)
11:15:16 <lambdabot> (map .)
11:15:41 * hackagebot type-level-tf 0.2.1 - Type-level programming library (type families)  http://hackage.haskell.org/package/type-level-tf-0.2.1 (CoreyOConnor)
11:20:06 <dmwit> BlankVerse: There's half a dozen.
11:20:26 <dmwit> BlankVerse: gd, the imagemagick bindings, devil, I think gtk2hs can do it, ...
11:20:36 <BlankVerse> dmwit: i want one which is pure haskell
11:20:55 <dmwit> oooookay
11:20:57 <BlankVerse> dmwit: which of them is purely haskell?
11:21:02 <dmwit> (why?)
11:21:24 <BlankVerse> just so that i can forkIO those functions
11:21:50 <hpc> you can't forkIO foreign calls?
11:21:55 <BlankVerse> because that would be a major chuck of time in my webapps response time
11:21:57 <dmwit> yeah, what?
11:21:58 <BlankVerse> hpc: can i?
11:22:03 <dmwit> Of course you can.
11:22:18 <dmwit> There's very few C libraries that use thread-local state.
11:22:22 <BlankVerse> hpc: but what if those block on a database ..
11:22:27 <dmwit> (OpenGL and gtk are perhaps the most famous of them.)
11:22:37 <BlankVerse> i was using this sqlite library
11:22:39 <mekeor> It's damn bummer that "(read "+" :: (Num a => a -> a -> a)) 1 2" doesn't work :(
11:22:43 <BlankVerse> and it gave me out of sequence errors
11:23:12 <BlankVerse> Database.HDBC.Sqlite3
11:23:12 <dmwit> mekeor: Try using "hint" or some such thing.
11:23:21 <dmwit> mekeor: (If you really want a Haskell interpreter.)
11:23:39 <BlankVerse> i was forkIOing a function which had a database query call , and it barfed !!!
11:23:52 <mekeor> dmwit: you mean hlint?
11:24:07 <mekeor> no?
11:24:27 <dmwit> mekeor: I do not mean hlint.
11:24:35 <mekeor> what's hint?
11:24:41 <dmwit> ?hackage hint
11:24:42 <lambdabot> http://hackage.haskell.org/package/hint
11:25:04 <monochrom> forkIO and FFI work fine. add -threaded if you think something blocks unexpectedly
11:25:10 <hpc> hint == Haskell INTerpreter
11:25:19 <mike-burns> wavewave: Ah, the Commit data type is a good idea.
11:25:19 <lambdabot> mike-burns: You have 4 new messages. '/msg lambdabot @messages' to read them.
11:25:34 <monochrom> in fact, see my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
11:25:35 <mike-burns> Thanks for helping me figure this out.
11:26:04 <mekeor> monochrom: whom did you talk to?
11:26:12 <mekeor> hpc: ah, okay; i see.
11:26:35 <monochrom> if you forgot -threaded, no big deal actually, worst comes to worst you get pretty sequential behaviour
11:26:43 <geheimdienst> is there a standard function that does essentially "\p x -> if p x then Just x else Nothing"?
11:26:46 <mekeor> dmwit: so, what exactly is hint?
11:26:55 <mekeor> dmwit: an alternative to GHCi or hugs or what?
11:27:02 <mekeor> dmwit: i still didnt get it‚Ä¶ oO
11:27:11 <hpc> @@ @hoogle @type \p x -> if p x then Just x else Nothing
11:27:11 <dmwit> mekeor: It's a Haskell interpreter. It lets you turn a String containing Haskell code into a Haskell value.
11:27:12 <lambdabot>  Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:27:12 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:27:12 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
11:27:15 <BlankVerse> btw , how do i forkIO on this :
11:27:16 <geheimdienst> (for when you're mucking around in the Maybe monad and want to throw in condition
11:27:17 <BlankVerse> main = sequence $ fmap download urls
11:27:19 <geheimdienst> )
11:27:25 <hpc> geheimdienst: doesn't look like it
11:27:28 <BlankVerse> urls is a list
11:27:30 <dmwit> mekeor: e.g. (intepret "(+)" = (+))
11:27:36 <mekeor> dmwit: O_O
11:27:37 <hpc> geheimdienst: oh, guard
11:27:38 <hpc> :t guard
11:27:39 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
11:27:43 <mekeor> dmwit: COOL!
11:27:53 <hpc> > guard False :: Maybe ()
11:27:54 <lambdabot>   Nothing
11:28:01 <hpc> > guard True :: Maybe ()
11:28:01 <lambdabot>   Just ()
11:28:12 <geheimdienst> awesome, thanks hpc :)
11:28:43 <mekeor> dmwit: actually, i'm currently writing a calculator in haskell‚Ä¶‚Ä¶ but due to hint, that's quite senseless since i could just use the interpret function! O_O
11:29:21 <mekeor> oh my god!
11:29:36 <geheimdienst> no wait, guard always gives out "m ()", i want "m a" ...
11:29:54 <alistra> when?
11:30:03 <alistra> uh no
11:30:23 <dmwit> geheimdienst: guard True >> return x
11:30:41 * hackagebot cblrepo 0.3.1 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.3.1 (MagnusTherning)
11:30:42 <dmwit> geheimdienst: In fact, I find "ensure p x = guard (p x) >> return x" quite useful.
11:30:50 <dmwit> I've used it quite a lot.
11:31:01 <dmwit> ensure :: MonadPlus m => (a -> Bool) -> a -> m a
11:31:15 <dmwit> > let ensure p x = guard (p x) >> return x in ensure odd 3
11:31:16 <lambdabot>   No instance for (GHC.Show.Show (m b))
11:31:16 <lambdabot>    arising from a use of `M7068258841...
11:31:22 <dmwit> > let ensure p x = guard (p x) >> return x in ensure odd 3 :: [Integer]
11:31:24 <lambdabot>   [3]
11:31:35 <dmwit> > let ensure p x = guard (p x) >> return x in [3..] >>= ensure odd
11:31:37 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
11:31:58 <dmwit> etc.
11:32:44 <alistra> :t let ensure p x = guard (p x) >> return x in ensure
11:32:45 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => (b -> Bool) -> b -> m b
11:32:52 <alistra> alistra@bialobrewy ~ % hoogle mfilter
11:32:52 <alistra> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
11:33:02 <alistra> uh nearly
11:33:05 <dmwit> ensure saves you a return =)
11:33:11 <monochrom> BlankVerse: main = do { vs <- mapM (\u -> do {v <- newEmptyMVar; forkIO (download u >>= putMVar v); return v}) urls; mapM takeMVar vs }
11:33:41 <geheimdienst> dmwit: thanks ... i guess what i'd hoped for was that "ensure" was in the standard library under some name :)
11:33:41 <byorgey> yeah, mfilter has a funny type.
11:34:01 <hpc> what a delightful combinator
11:34:11 <byorgey> since (a -> m a) can always be turned into (m a -> m a) it gives you no extra power
11:35:17 <BlankVerse> monochrom: reddit: SqlError {seState = "", seNativeError = 5, seErrorMsg = "step: database is locked"}
11:35:20 <BlankVerse> reddit: thread blocked indefinitely in an MVar operation
11:36:01 <BlankVerse> monochrom: http://paste.pocoo.org/show/500110/
11:36:47 <monochrom> oh then it is because the database hates concurrency?
11:37:44 <BlankVerse> monochrom: any database that doesnt hate concurrency?
11:37:51 <monochrom> postgresql
11:38:00 <monochrom> iirc mysql too
11:38:06 <byorgey> @let ensure p x = guard (p x) >> return x
11:38:08 <lambdabot>  Defined.
11:38:14 <dylex> BlankVerse: anything that's not sqlite really
11:38:30 <BlankVerse> dylex: will postgre work fine?
11:38:36 <alistra> @let show _ = "aa"
11:38:38 <lambdabot>  Defined.
11:38:42 <alistra> > 4
11:38:43 <lambdabot>   4
11:38:51 <byorgey> :t \p ma -> ma >>= ensure p  -- mfilter defined in terms of ensure
11:38:53 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> m a -> m a
11:38:58 <alistra> > show "sda"
11:39:00 <lambdabot>   Ambiguous occurrence `show'
11:39:00 <lambdabot>  It could refer to either `L.show', defined at ...
11:39:06 <monochrom> or perhaps the database likes concurrency, but you need multiple connections
11:39:07 <dylex> BlankVerse: yes.  You'll just have to make a new connection to the database in the new process.
11:39:30 <byorgey> :t \p -> mfilter p . return  -- ensure defined in terms of mfilter
11:39:30 <alistra> @let a >>= b = "a"
11:39:31 <lambdabot> Not in scope: `mfilter'
11:39:32 <lambdabot>  Defined.
11:39:48 <alistra> > 5 >>= 2
11:39:50 <lambdabot>   Ambiguous occurrence `>>='
11:39:50 <lambdabot>  It could refer to either `L.>>=', defined at <l...
11:39:53 <alistra> :D
11:39:59 <monochrom> "forkIO (talk_to_db h)" (same h for every thread) is clearly a PEBKAC rather than forkIO's failure with FFI
11:40:53 <monochrom> sigh. I should just keep myself out of these discussions when another paticipant has demonstrated a clearly warped blame assignment model.
11:41:12 <byorgey> dmwit: I like 'ensure', it turns a predicate into an arrow in a Kleisli category
11:41:21 <byorgey> dmwit: mfilter seems rather clunkier by comparison
11:41:41 <dmwit> Maybe today is the day I get up the energy to make a libraries@ proposal.
11:42:02 <byorgey> if you do I will +1 it!
11:43:00 <hpc> librarys@?
11:44:20 <dmwit> ?index mfilter
11:44:21 <lambdabot> bzzt
11:45:07 <dmwit> hpc: If I wanted to put ensure next to mfilter, it would have to go in base, which is maintained by the "libraries@haskell.org" mailing list.
11:45:25 <hpc> oh
12:00:15 <colah> I'm getting ready to upload a haddock documented library I've made to hackagedb. When I run cabal haddock I get nice documentation, but when I do the test upload of my sdist tarball I don't get nice hyperlinks to haddock documentation. I suspect I need to add something to my .cabal file?
12:02:10 <dmwit> colah: Hackage has a build-bot for building the library and documentation, but it doesn't run immediately.
12:02:27 <dmwit> It's got a queue, and can take up to a day or two to add documentation links.
12:02:51 <hpc> i thought it did builds every 6 hours
12:03:06 <mekeor> is it actually possible to write two modules, say A and B, where A import B and B imports A ?
12:03:18 <colah> dmwit: Ah, so I probably won't see documentation when I just upload it.
12:03:21 <colah> OK, thanks :)
12:03:22 <hpc> mekeor: yes, but no
12:03:28 <mekeor> hpc: hehe :)
12:03:33 <mekeor> hpc: so what?
12:03:35 <hpc> mekeor: to elaborate, it's possible, but not even remotely practical
12:03:50 <dmwit> Wow, that's totally untrue.
12:03:54 <dmwit> It's possible and practical.
12:03:59 <hpc> you have to make some other special file that represents the parts of A that aren't mutually recursive
12:04:00 <mekeor> hpc: hm. i see.
12:04:00 <dmwit> Read the documentation for .hs-boot files.
12:04:10 <monochrom> mekeor: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
12:04:12 <mekeor> hpc: okay; thanks :)
12:04:12 <hpc> dmwit: .hs-boot files are a pain
12:04:28 <dmwit> I would take issue with that.
12:04:38 <monochrom> I wouldn't make a pain judgement for other people than me. usually anyway.
12:04:43 <dmwit> There's about a dozen packages on Hackage that use them to good effect.
12:04:47 <mekeor> monochrom: cool! great; thanks!
12:05:53 <monochrom> but it is certainly more efficient to utter "it's a pain" than finding the right url to paste
12:06:20 <monochrom> opinions are cheap. too cheap. ignore all opinions.
12:07:10 <hpc> what i mean is, the .hs-boot file is basically the same as just making a third module to break the cycle
12:07:55 <monochrom> my only gripe is that it doesn't like A importing A.
12:10:17 <dmwit> monochrom: Huh, that's an odd gripe. What's the use case for that?
12:15:37 <parcs> module MyLongModuleName where import qualified MyLongModuleName as A; id x = id; main = return (A.id 5)
12:15:48 <parcs> vs return (MyLongModuleName.id 5) :P
12:16:20 <dmwit> That's... actually a pretty good use case.
12:16:22 <dmwit> Thanks!
12:19:38 <john_r_watson> I have some seriousl long Newb question - trying to write a compiler in Haskell.  I Have an AST represented by different data types: data Program = Program MainClass [ClassDecl], MainClass = MainClass String String Statement, Statment = ..., Exp = ,etc.  The problem comes when I try to perform some kind of traversing operation (pretty printing) of these data types I hit a wall since writing something like myPrint (Program m cs) =
12:19:38 <john_r_watson> ... and myPrint (MainClass a b s) = won't type check.  I tried to write a "visitor pattern" of sorts where I said each of these was an instance of an "acceptor" class, but this merely delayed my hitting the type checking error again (wrote an instance of a visitor w/ one function: visit :: (Monad m, Acceptor a) => a -> v -> m v), and all the various data types implemented Acceptor (which just forward to visit).  But type checking fa
12:19:38 <john_r_watson> when I try to use pattern matching to deduce what kind of acceptor I am dealing with. "Couldn't match expected type `v' against inferred type `MainClass' `v' is a rigid type variable bound by the type signature for `accept'".  I know one solution is to simply make all these data types be the same and have different constructors like: data Ast = Program (...) | MainClass (...) | Statement | Exp...., and to pattern match on the
12:19:38 <john_r_watson> constructors, but I liked specifying the types of Exp like: Plus = Plus Exp Exp.  Plus shouldn't be able to take any arbitrary Ast, but only Exp types.
12:19:54 <dmwit> In the future, please
12:19:55 <dmwit> ?hpaste
12:19:56 <lambdabot> Haskell pastebin: http://hpaste.org/
12:20:04 <dmwit> your code instead of pasting it in-line.
12:20:05 <john_r_watson> ah... sorry
12:20:15 <dmwit> Bonus points if you put your error on there, too.
12:20:20 <parcs> yeah thats really hard to read
12:20:59 <john_r_watson> was hoping it was more of a general design thing... working on hpaste...
12:28:40 <hpaste> ‚ÄúJohn Watson‚Äù pasted ‚ÄúFailed Visitor Pattern‚Äù at http://hpaste.org/53287
12:29:01 <john_r_watson> Thanks for anyone that looks
12:30:09 <fazzone> how exactly is it 'failed'
12:30:48 <john_r_watson> oh right I forgot error sorry - one sec
12:31:29 <dmwit> myPrint is not well-typed.
12:32:15 <byorgey> john_r_watson: also, Acceptor and Visit seems redundant.
12:32:40 <dmwit> Yeah, I would say you want a multi-parameter typeclass here.
12:32:47 <ddarius> Trying to recreate the Visitor pattern in Haskell seems redundant.
12:32:49 <dmwit> class Visitor a v where visit :: a -> v -> m v
12:32:55 <byorgey> john_r_watson: just make a single type class:  class Pretty a where pretty :: a -> String
12:33:08 <dmwit> Or yeah, skip the pattern and just write the class you actually want.
12:33:15 <merijn> wtf *is* the visitor pattern?
12:33:15 <dmwit> That's probably better advice.
12:33:18 <byorgey> john_r_watson: then just implement Pretty for each type of syntax.
12:33:38 <byorgey> all this stuff with Visitor, Accept, etc. seems way too over-general
12:34:01 <dmwit> Or use one of the many pretty-printing libraries available on Hackage. =)
12:34:36 <john_r_watson> ddarius: agreed. I don't think Visitor makes sense in a functional lang, but I tried
12:34:41 <byorgey> indeed.  In that case you'll still have to implement a Pretty class and a pretty method for each type, but then you could give pretty the type  a -> Doc
12:34:41 <merijn> Ah, 5s of glancing at wikipedia and visitor pattern seems like a kludge to work around lack of sane operator overloading?
12:35:32 <Saizan> no, it's a way to work around the lack of ADTs
12:35:51 <john_r_watson> byorgey: Yeah, I envisioned creating various traversing operations
12:36:06 <john_r_watson> byorgey: one could type check, one (this one) would simply print AST
12:36:24 <Saizan> the visitor pattern is basically implementing the fold for the datatype
12:38:53 <ddarius> What Saizan said.
12:38:53 <mekeor> Are (default) strings (in Haskell) UTF-8 ?
12:39:19 <dmwit> mekeor: No.
12:39:20 <john_r_watson> Can I limit a constructors arguments to a "specific constructor of a given type"?
12:39:27 <dmwit> mekeor: Strings are sequences of Unicode codepoints.
12:39:45 <john_r_watson> AST = Exp... | Plus Exp Exp (just the idea here)
12:39:52 <byorgey> john_r_watson: no
12:40:09 <mekeor> dmwit: so how many bits does one char have?
12:40:12 <byorgey> john_r_watson: you may be interested in using some sort of generic traversal library, such as uniplate
12:40:27 <john_r_watson> byorgey: I'll check it out thanks
12:40:35 <dmwit> mekeor: GHC uses a machine word, I think.
12:40:35 <byorgey> john_r_watson: it makes dealing with these sorts of large ASTs *much* nicer
12:40:41 <mekeor> (dmwit: actually, i'm a noob in encodings‚Ä¶)
12:40:50 <dmwit> mekeor: String's are not encoded yet.
12:41:10 <dmwit> mekeor: If you want a particular encoding, you need to use a library like "encoding" or so to convert a String into a sequence of bytes.
12:41:14 <byorgey> > ord (maxBound :: Char)
12:41:15 <lambdabot>   1114111
12:43:07 <copumpkin> > ord maxBound
12:43:09 <lambdabot>   1114111
12:43:13 * copumpkin tsk tsk
12:43:14 <ddarius> > maxBound :: Char
12:43:15 <lambdabot>   '\1114111'
12:46:14 <mekeor> dmwit: okay, ty
12:46:18 <merijn> s/particular encoding/UTF-8
12:51:14 <merijn> I have C code expecting to call a vararg (C) function. How can I implement that function in Haskell and export it using the FFI?
12:51:43 <erus`> when is the next platform release expected
12:51:43 <lambdabot> erus`: You have 1 new message. '/msg lambdabot @messages' to read it.
12:54:32 <dmwit> merijn: Have fun with that.
12:55:00 <merijn> dmwit: Not the answer I wanted to hear :(
12:58:31 <merijn> I guess an alternative would be exporting constructors to C and implementing the vararg function itself in C...
12:58:49 <ddarius> merijn: What do you want the Haskell function to look like?
12:59:24 <dmwit> merijn: (The FFI specifically outlaws binding to vararg functions, and recent GHC's in fact will crash if you try.)
12:59:43 <dmwit> http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/release-6-10-1.html <- see the release notes for 6.10.1, for example
13:00:59 <merijn> ddarius: The C function I have now takes an id and N arguments, where the value of N is determined by the id. I need/want to do the same in Haskell without forcing the calling code to do a lot of wrapping
13:01:25 <dmwit> Do the arguments have different types?
13:01:31 <dmwit> If not, why not an array?
13:02:00 <dmwit> If so, then you'll just have to write a less varargs-y interface in C, I'm afraid.
13:02:05 <merijn> dmwit: Different types (only 3 different ones, but mixed)
13:02:40 <fazzone> > let f a b c = show a ++ b ++ show c in f 1"4"2
13:02:41 <lambdabot>   Ambiguous occurrence `show'
13:02:42 <lambdabot>  It could refer to either `L.show', defined at ...
13:02:53 <fazzone> L.show?
13:02:53 <dmwit> ?undefine
13:03:02 <dmwit> > let f a b c = show a ++ b ++ show c in f 1"4"2
13:03:04 <lambdabot>   "142"
13:03:14 <fazzone> cool that you don't need spaces with the quotes
13:03:27 <byorgey> fazzone: L is the module containing all the stuff imported by lambdabot
13:03:42 <merijn> dmwit: Is it possible to export constructors to C using FFI?
13:03:51 <dmwit> Earlier some rogue defined an extra show just to trip people up. =P
13:03:57 <ddarius> merijn: They are just functions.
13:04:23 <ddarius> merijn: At any rate, Haskell doesn't have vararg functions, so I still don't know what you expect the Haskell function to look like.
13:05:00 <dmwit> ddarius: Personally, I would expect a new data type with one constructor per ID number.
13:05:19 <merijn> ddarius: For my purposes a haskell function accepting 1 list would be sufficient
13:05:20 <dmwit> Then a function that took a value in that type (rather than being a vararg function).
13:06:14 <merijn> ddarius: I'm just stuck with a C interface expecting a vararg function. So I need to translate from that vararg call to something sane in Haskell. But not sure what the best approach is
13:06:24 <donri> f = \x -> f  -- varargs!
13:06:44 <dmwit> donri: Looks like an occurs check error to me.
13:06:55 <dmwit> :t let f = \x -> f in f
13:06:56 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
13:06:56 <lambdabot>     Probable cause: `f' is applied to too few arguments
13:06:56 <lambdabot>     In the expression: f
13:06:57 <donri> yes, "infinite type" :)
13:06:58 <copumpkin> f = f -- varargs!
13:07:07 <copumpkin> > let f = f in f 5 3 5 3 7 1 1
13:07:11 <lambdabot>   mueval-core: Time limit exceeded
13:07:13 <donri> f x = f
13:07:25 <companion_cube> how does Printf work then?
13:07:32 <merijn> companion_cube: Typeclass hackery
13:07:39 <merijn> :t Printf
13:07:40 <lambdabot> Not in scope: data constructor `Printf'
13:07:48 <dmwit> :t printf
13:07:49 <lambdabot> forall r. (PrintfType r) => String -> r
13:07:58 <companion_cube> heh
13:08:03 <copumpkin> :k Mu ((->) Int)
13:08:05 <donri> also template haskell e.g. $(zipN 3)
13:08:05 <lambdabot> *
13:08:18 <ddarius> merijn: No matter what you do, you will have to make the vararg function in C and it will call your Haskell.
13:08:18 <dmwit> merijn: So, here's what I would do.
13:08:35 <dmwit> err... never mind
13:08:50 <merijn> dmwit: Aww...anticlimax
13:08:56 <dmwit> I'm making an hpaste.
13:10:50 <Happy0> i'm a haskell noob and i'm a bit stuck with something... see if you have
13:10:51 <Happy0> data Decl = Var
13:10:51 <Happy0> 	deriving (Read, Show)
13:10:56 <Happy0> and type Var = String
13:11:05 <Happy0> how do you construct a Decl ? :S
13:11:28 <Happy0> i thought it meant i could treat a declr like a string, but the interpreter says it got a [char] when it expected a decl
13:11:37 <merijn> Happy0: "data Decl = Var" declares a new type "Decl" with one constructor "Var"
13:11:51 <merijn> Happy0: That combination of lines probably does not do what you think
13:12:07 <Happy0> marijn: haha, i agree, it probably doesn't
13:12:14 <Happy0> and thanks
13:12:43 <merijn> You'd want to do "type Decl = String" directly
13:13:08 <Happy0> merijn: the problem is, this is part of what we've been given
13:13:15 <Happy0> although i guess i'd be free to do that..
13:13:23 <Happy0> but maybe we've been given it like that for a reason
13:13:30 <Happy0> (the exercise is to write an interpreter)
13:14:10 <merijn> Happy0: The alternative is to do "data Decl = Var String" which defines Decl to be a type with one constructor (Var), which accepts a string argument
13:14:23 <byorgey> Happy0: confusingly, in  data Decl = Var;   type Var = String,  the two occurrences of Var are unrelated
13:14:38 <byorgey> types and data constructors occupy different namespaces.
13:14:56 <Happy0> merijn: thanks, i think i will play around with that idea
13:14:56 <ddarius> Data constructors being values.
13:15:03 <Happy0> byorgey: thanks for helping me understand haskell a bit better
13:15:15 <merijn> Happy0: What are you reading to learn haskell?
13:15:35 <Happy0> merijn: lecture slides, examples... googling stuff ;x
13:15:40 <Happy0> i don't have a haskell textbook
13:15:54 <merijn> Happy0: Go read Learn You a Haskell
13:15:57 <merijn> @where lyah
13:15:58 <lambdabot> http://www.learnyouahaskell.com/
13:16:11 <merijn> It is better than most stuff Le Google finds :)
13:16:12 <hpaste> dmwit pasted ‚Äúvarargs‚Äù at http://hpaste.org/53290
13:16:12 <Happy0> merijn: cheers, i've seen it before, it looks good... and it's written in an amusing style xD
13:16:23 * ddarius would expect google to find lyah.
13:16:27 <dmwit> merijn: There's probably 101 errors there, but maybe the idea of the binding is coming through.
13:16:31 <dmwit> merijn: If not, ask me. =)
13:16:36 <merijn> dmwit: Thanks, I'll check it out
13:16:43 <Happy0> it's funny, or scary that i've got this far in writing my parser without a solid understanding of types / constructors
13:16:54 <merijn> :D
13:17:48 <ddarius> dmwit: You have this backwards.
13:17:57 <dmwit> Oh, do I?
13:18:15 <dmwit> The goal isn't to call a varargs function from Haskell?
13:18:22 <ddarius> dmwit: I'm pretty sure merijn wants to -present- a Haskell function as a vararg function, not use an existing vararg function.
13:18:41 <dmwit> aha
13:19:01 <merijn> dmwit: No, I have C code calling a vararg function to construct a value, this value then needs to be put into a Chan in the haskell code
13:19:22 <dmwit> Now I'm confused.
13:19:34 <merijn> I guess the easiest solution is to export constructors, have a C vararg call the relevant constructors and then call a haskell function to write the value into a Channel
13:19:53 <dmwit> If the interface between Haskell and C doesn't include the vararg function, then what's the question?
13:20:10 <dmwit> (I mean, you say the interface is a function which *calls* a vararg function -- bit isn't itself a vararg function?)
13:20:17 <mike-burns> What's the best way to get the datetime from 7 days ago?
13:20:28 <ddarius> dmwit: merijn has to provide the vararg function that that function calls.
13:20:35 <merijn> dmwit: I didn't want to have generate a bunch of C functions every time
13:20:52 <merijn> I'll just explain in more detail
13:21:19 <Happy0> merijn: i got it working by changing decl into a 'type' like you suggested... hopefully there won't be any consequences later =p
13:21:19 <ddarius> merijn: The approach that requires the least amount of C code would be to write your vararg function in C and just package the arguments in a generic way, then do all the handling on the Haskell side.
13:21:48 <dmwit> aaaaah, I think I'm getting the picture
13:21:51 <ClaudiusMaximus> :t addUTCTime (-7 * 60 * 60 * 24)
13:21:52 <lambdabot> Not in scope: `addUTCTime'
13:21:58 <merijn> I have an existing C runtime which I want to reimplement in Haskell. The runtime calls out to other C code (FFI call from haskell) this C code produces zero or more values which need to go back into the runtime
13:23:00 <mike-burns> ClaudiusMaximus: Interesting.
13:23:03 <merijn> Right now the external C code calls a vararg runtime function to construct a value and do whatever needs to be done. This vararg function's work needs to now be done by a function provided by the haskell runtime
13:23:11 <dmwit> But the approach doesn't seem so different. Instead of writing a bunch of functions on the C side and importing each, you write a bunch of functions (constructors?) on the Haskell side and export each. Then call the appropriate one from the varargs function that you write.
13:24:33 <merijn> dmwit: Yes, that seems the only sane option. My original question was just wondering whether it could all be done in haskell
13:25:05 <dmwit> I don't think so. Sorry. =/
13:25:21 <dmwit> (The FFI definitely won't produce or consume varargs functions.)
13:25:50 <erus`> Is there a package that implements some kind of permanent MVar ?
13:26:04 <dmwit> What does "permanent" mean?
13:27:05 <erus`> the mvar is persistent when i stop the program and start it again
13:27:16 <erus`> if it were to crash
13:27:33 <merijn> Aren't those called files and databases?
13:27:50 <erus`> merijn: yeah some kind of abstract access to a database
13:28:06 <dmwit> happstack provides a persistence layer.
13:28:53 <JoeyA> I wonder if it would be a good idea to apply the STM concept to parallel build systems.
13:29:12 <JoeyA> The problem I encounter over and over is makefiles where make -j2 doesn't work because the dependencies aren't written correctly.
13:29:14 <dmwit> Rolling back builds seems tricky.
13:29:34 <JoeyA> That's why the build actions would have to be "pure" in a sense.
13:30:18 <merijn> "type" creates a synonym supporting all the same functions, whereas newtype creates a new data element which just happens to have the same implementation as the type on the right, no?
13:30:36 <merijn> s/data element/data type
13:31:01 <dmwit> merijn: yes
13:31:24 <dmwit> newtypes are a figment of the type-checker's imagination
13:31:33 <dmwit> (Don't remember who said that first. =)
13:32:09 <fazzone> I mean, in a statically-typed language, aren't all types sort of "figments of the type-checker's imagination"?
13:32:59 <dmwit> Well, at least with "data" types, the constructor tags still exist in memory somewhere at run time.
13:33:04 <dmwit> But with newtype, there's not even that.
13:33:05 <JoeyA> @quote imagination
13:33:05 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
13:35:30 <ddarius> dmwit: It was probably me.
13:36:06 <merijn> @pl \x -> f x >>= g
13:36:06 <lambdabot> (g =<<) . f
13:38:15 <merijn> @hoogle (a -> m b) -> (m b -> m c) -> a -> m c
13:38:16 <lambdabot> No results found
13:40:06 <dmwit> ddarius: sounds like your style, yeah
13:40:16 <dmwit> merijn: (>=>)
13:40:20 <dmwit> :t (>=>)
13:40:22 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:40:54 <merijn> dmwit++
13:42:18 <sipa1024> @djinn a -> (a -> b) -> b
13:42:19 <lambdabot> f a b = b a
13:42:44 <sipa1024> @pl \a b -> b a
13:42:45 <lambdabot> flip id
13:43:02 <sipa1024> :t flip id
13:43:03 <lambdabot> forall a b. a -> (a -> b) -> b
13:43:17 <byorgey> @. pl djinn a -> (a -> b) -> b
13:43:17 <lambdabot> f = flip id
13:43:46 <copumpkin> @@ @pl @djinn a -> (a -> b) -> a
13:43:47 <lambdabot>  f = const
13:47:46 <mike-burns> How can I import but hide one instance definition from the imported module?
13:48:58 <ClaudiusMaximus> not possible afaik - instances are always exported/imported (presumably to avoid accidental overlap/incoherence)
13:49:11 <mike-burns> Ah, that's what I had remembered. Bummer.
13:49:56 <ClaudiusMaximus> if you need a different instance, maybe define a newtype?
13:50:08 <mike-burns> Oh yeah, good idea!
13:51:13 <ClaudiusMaximus> @src Last mappend
13:51:14 <lambdabot> Source not found. I am sorry.
13:54:13 <ClaudiusMaximus> @check \xs -> not (null (xs :: [Int])) ==> (fromJust . getLast . mconcat . map (Last . Just)) xs == last xs
13:54:14 <lambdabot>   No instance for (Test.QuickCheck.Testable
13:54:14 <lambdabot>                     (Test.QuickCh...
13:55:24 <ClaudiusMaximus> @check \xs -> (null (xs :: [Int])) || (fromJust . getLast . mconcat . map (Last . Just)) xs == last xs
13:55:25 <lambdabot>   "OK, passed 500 tests."
13:55:45 * hackagebot biostockholm 0.1 - Reading and writing Stockholm files (multiple sequence alignment, used by Rfam and Infernal).  http://hackage.haskell.org/package/biostockholm-0.1 (FelipeLessa)
13:56:58 <merijn> There's no select like function for Chan's, right?
13:58:43 <osfameron> @pl (\i -> (fst i) * (snd i))
13:58:43 <lambdabot> uncurry (*)
14:02:01 <merijn> @hoogle [IO a] -> IO a
14:02:02 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
14:02:02 <lambdabot> Network withSocketsDo :: IO a -> IO a
14:02:02 <lambdabot> Control.Exception block :: IO a -> IO a
14:03:35 <erus`> Guys, can i test if running windows inside a setup.hs haskell setup file?
14:05:03 <ddarius> merijn: No, there isn't.
14:05:27 <erus`> how can i get operating system name
14:05:42 <osfameron> ffs, haskell's number types are a real pain
14:05:45 * hackagebot biocore 0.2 - A bioinformatics library  http://hackage.haskell.org/package/biocore-0.2 (KetilMalde)
14:06:04 * osfameron wonders why he's expected to care about the difference between Int and Integer,  or Float and Double
14:06:06 <merijn> ddarius: And neither is there a way to have a list of IO actions and return the first one to finish, I guess by the looks of Hoogle?
14:06:26 <ddarius> merijn: That's easy enough to do.
14:06:57 <merijn> ddarius: How? I remember looking for something like that a few months ago and not finding anything
14:08:06 <merijn> oh, wait
14:08:15 <ddarius> \actions -> do mvar <- newEmptyMVar; mapM_ (\action -> forkIO (action >>= putMVar mvar)) actions; readMVar mvar
14:08:34 <ddarius> I believe kmc's spawn package or some package like that provides more robust forms of this.
14:08:42 <merijn> ddarius: Yeah, I just realised that
14:09:06 <merijn> There's absolutely no reason to even care about a list of channels if I can be woken up and be told which one to read :p
14:09:42 <merijn> That's what I get for trying to make things more complicated then necessary...
14:09:47 <Veinor> erus`: System.IO.os
14:09:54 <Veinor> er, System.Info.os
14:11:36 <dmwit> erus`: In your .cabal file, you can wrap blocks in "if os(windows)".
14:11:52 <erus`> i need it in the Setup.(l)hs
14:11:55 <erus`> but i found...
14:12:12 <erus`> Distribution.System.buildOS
14:13:42 <erus`> i do need the ghc directory now though
14:15:44 <fazzone> @pl \f x -> (x, f x)
14:15:44 <lambdabot> ap (,)
14:18:49 <MichaelSom> Hi @all, I'm Michael
14:21:19 <PatrickRobotham> hi MichaelSom :)
14:23:20 <erus`> is there a symonim for         \n l -> take (length l - n) l
14:23:34 <erus`> synonym*
14:24:39 <cacodaemon> drop?
14:26:03 <erus`> ah yeah
14:26:06 <erus`> stupid hangover
14:27:32 <mhitza> hey gay I was wondering of you could help me out
14:27:47 <mhitza> how could I apply a list of functions over a value
14:28:01 <mhitza> sort of like a fold but couldn't express it in those terms
14:28:32 <fazzone> :t map ($)
14:28:32 <lambdabot> forall a b. [a -> b] -> [a -> b]
14:29:18 <mhitza> thanks fazzone, I know that but haven't expressed is well
14:29:21 <fazzone> @pl \a -> map (a$)
14:29:21 <lambdabot> map
14:29:49 <mhitza> considering I have a list of [(+1), (+2), (+3)] and want to apply it that to 1 the result would be 7
14:29:51 <fazzone> mhitza: [a -> b] -> a -> [b]  ?
14:30:02 <mhitza> that's why I sayd I wanted to express it in terms of fold, but couldn't
14:30:40 <fazzone> mhitza, <*> ?
14:30:48 <FUZxxl> Does anybody knows something about the state of supercompilation in GHC?
14:31:10 <mhitza> fazzone, lemme check it's type signature
14:31:31 <Quantumplation> Is there a difference between a >>= b >>= c and a >>= (c . b)?
14:31:42 <mhitza> fazzone, no not really
14:31:52 <Cale> Quantumplation: the type?
14:31:53 <mhitza> I mean I want to apply that list of functions like a filter
14:32:26 <mhitza> apply the first function on the value; that value apply it to the second function; that returned value to the third function and return after the final computation
14:32:33 <Quantumplation> Cale: I mean, functionally.  like, is that essentially what chaining >>= does?
14:32:43 <mhitza> actually I want to convert the list of function to a combination of them
14:32:43 <Cale> Quantumplation: they're not the same
14:33:55 <Quantumplation> Ah.  What would the difference be?
14:34:14 <Cale> :t \a b c -> a >>= b >>= c
14:34:14 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => m a -> (a -> m a1) -> (a1 -> m b) -> m b
14:34:22 <Cale> :t \a b c -> a >>= (c . b)
14:34:22 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => m a -> (a -> a1) -> (a1 -> m b) -> m b
14:34:35 <Cale> ^^ look how the type of b is different
14:34:43 <Quantumplation> ah
14:34:48 <Cale> So they're incomparable, because they combine different sorts of things
14:34:49 <merijn> Is it possible to use pattern guards with case?
14:35:09 <Quantumplation> so it doesn't have the extra "pull the variable out of the monad" step from b to c
14:35:30 <merijn> Quantumplation: Correct
14:35:39 <Quantumplation> because the function b would be something that doesn't return a monadic context
14:36:00 <Cale> Your terminology is all weird, but it's clear that you have the right idea
14:36:32 <Cale> merijn: It should be
14:36:44 <Quantumplation> heh, my terminology is ALWAYS weird since i'm usually an autodidact.  I learn concepts, and the terminology fades away with time.
14:37:47 <mhitza> hey guys, how can I do this? f [a, b, c] d = c . b . a $ d ?
14:38:30 <hpc> > foldl (.) id [a, b, c] x
14:38:31 <lambdabot>   Couldn't match expected type `a -> a'
14:38:31 <lambdabot>         against inferred type `Simple...
14:38:41 <hpc> > foldl (flip (.)) id [a, b, c] d
14:38:42 <lambdabot>   Couldn't match expected type `b -> b'
14:38:42 <lambdabot>         against inferred type `Simple...
14:38:43 <merijn> Actually, I think I don't even need pattern guards
14:38:51 <mhitza> thanks hpc
14:38:59 <erus`> @hoogle const
14:38:59 <lambdabot> Prelude const :: a -> b -> a
14:38:59 <lambdabot> Data.Function const :: a -> b -> a
14:38:59 <lambdabot> Control.Applicative newtype Const a b
14:39:15 <erus`> @hoogle a -> b -> b
14:39:15 <lambdabot> Prelude seq :: a -> b -> b
14:39:15 <lambdabot> Control.Parallel par :: a -> b -> b
14:39:15 <lambdabot> Control.Parallel pseq :: a -> b -> b
14:39:18 <hpc> > (mconcat . reverse) [a, b, c] x -- this should be it
14:39:19 <lambdabot>   Couldn't match expected type `t -> t1'
14:39:19 <lambdabot>         against inferred type `Simpl...
14:39:26 <hpc> screw it
14:39:31 <fazzone> :t foldl1 (.)
14:39:32 <lambdabot> forall a. [a -> a] -> a -> a
14:39:34 <hpc> something like that
14:40:24 <erus`> @hoogle a -> (b -> a)
14:40:24 <hpc> > (mconcat . reverse) [f, g] x :: Expr -- the Expr definitions can be such a pain at times
14:40:24 <lambdabot> Prelude const :: a -> b -> a
14:40:24 <lambdabot> Data.Function const :: a -> b -> a
14:40:25 <lambdabot> Prelude seq :: a -> b -> b
14:40:25 <lambdabot>   No instance for (Data.Monoid.Monoid SimpleReflect.Expr)
14:40:25 <lambdabot>    arising from a u...
14:40:39 <erus`> @hoogle a -> (a -> b)
14:40:39 <lambdabot> Prelude asTypeOf :: a -> a -> a
14:40:39 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:40:39 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
14:40:50 <ghosting> What are some cool things I can do with System.IO.Unsafe
14:40:59 <hpc> ghosting: you can segfault! :D
14:41:28 <fazzone> mhitza: foldl1 (.)  is what you want, except backwards
14:41:43 <fazzone> mhitza: i.e. foldl1 (.) [a,b,c] d = a . b . c $ d
14:42:22 <ghosting> How do you do that
14:42:36 <merijn> Is there a nice way of writing "case bar of { Foo && someBool -> expr1; _ -> expr2 }"? I can never freaking figure out this case syntax :\
14:42:45 <mhitza> fazzone, than is it what hpc had next: foldl1 (flip (.))
14:43:04 <mhitza> right?
14:43:35 <fazzone> mhitza: yes
14:44:10 <ClaudiusMaximus> > case Just 42 of { Nothing -> "huh" ; Just k | odd k -> "odd" ; _ -> "probably even" }
14:44:11 <lambdabot>   "probably even"
14:44:42 <merijn> ClaudiusMaximus: Thanks
14:49:47 <Phyx-> :t \x -> case x of { I# y -> return y; }
14:49:49 <lambdabot> Not in scope: data constructor `I#'
14:50:01 <Phyx-> :t \x -> case x of { Just y -> return y; }
14:50:02 <lambdabot> forall t (m :: * -> *). (Monad m) => Maybe t -> m t
14:50:23 <Phyx-> :t fromJust
14:50:24 <lambdabot> forall a. Maybe a -> a
14:50:34 <Phyx-> :t return . fromJust
14:50:35 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe a -> m a
14:54:42 <levicc00123> +
15:02:44 <mhitza> fazzone, don'
15:02:53 <mhitza> fazzone, don't know can't make this work: foldl1 (.) [snd, snd] (1, (2, (3, (4, 5))))
15:03:19 <fazzone> >foldl1 (.) [snd, snd] (1, (2, (3, (4, 5))))
15:04:13 <mhitza> > foldl1 (.) [snd, snd] (1, (2, (3, (4, 5))))
15:04:14 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b)
15:05:36 <fazzone> mhitza: you can't use a fold for something like that
15:05:51 <Phyx-> :t foldr (.) [snd . snd]
15:05:53 <lambdabot> forall a b a1. [((a1, (a, b)) -> b) -> (a1, (a, b)) -> b] -> [(a1, (a, b)) -> b]
15:06:12 <mhitza> I didn't knew I couldn't, when I started my question I sayd I wasn't able to do as a fold and came here to ask of another way
15:06:12 <Phyx-> :t foldr (.) [snd , snd]
15:06:14 <lambdabot> forall a b. [((a, b) -> b) -> (a, b) -> b] -> [(a, b) -> b]
15:06:38 <fazzone> mhitza: Well why didn't you give us the counterexample that proved fold didn't work?
15:07:17 <mhitza> fazzone, counterexample, I wasn't even able to mentally build it out. That's why I've asked :)
15:07:44 <fazzone> mhitza: out of curiosity, where are you from (what is your native language)?
15:07:51 <mhitza> from Romania
15:07:52 <dylex> mhitza: that will work as long as each step of the fold has the same type, e.g.
15:07:57 <dylex> > foldl1 (.) [succ, pred, (+3)] 5
15:07:59 <lambdabot>   8
15:08:10 <Phyx-> exactly
15:08:37 <Phyx-> the type of snd . snd cauzes the problem in the fold
15:08:43 <mhitza> dylex, yeah but they won't
15:10:13 <mhitza> dylex, but I'm not constrained to a fold, I only want to apply those functions as a chain of functions upon the input
15:10:25 <kmc> heh there are a lot of romanian haskellers it seems
15:10:28 <dylex> mhitza: if the contents of the list are dynamic (determined at runtime), you can't do what you want with static types
15:10:33 <mhitza> so if you know of an alternative that could do that, would be ok
15:10:46 <dylex> mhitza: but if you know the functions, then you apply:  (f1 . f2 . f3 ...)
15:11:00 <mhitza> the function list is build at runtime
15:11:04 <mhitza> repeat x (snd)
15:11:14 <fazzone> heh
15:11:15 <merijn> Hmm
15:11:39 <Phyx-> :t foldl (>>>) id
15:11:41 <mhitza> I can do it with a custom function
15:11:41 <lambdabot> forall c. [c -> c] -> c -> c
15:11:50 <fazzone> is this at all related to the 'heterogeneous lists' post in r/haskell?
15:11:50 <mhitza> but I tought I could do it with the built in ones
15:11:51 <Phyx-> :t foldr (.) id
15:11:52 <lambdabot> forall b. [b -> b] -> b -> b
15:11:56 <mhitza> fazzone, yes :)
15:12:21 <merijn> If I define "simpleStream = (newChan, Nothing)" then newChan will only be executed once, right?
15:12:29 <fazzone> Wasn't that ruled to be either impossible or unbelievable unwieldy in the comments though?
15:12:57 <mhitza> fazzone, yeah but I got a couple of hours to spare so i'd tought I'd hack a bit at it
15:13:20 <erus`> how can i add an include directory to cabal?
15:13:29 <erus`> for C headers?
15:13:40 <dylex> merijn: actually, with just that, newChan won't be executed at all, since you haven't evaluated it in IO.  You could then use simpleStream to create any number of channels, however.
15:13:44 <fazzone> mhitza: Wasn't it ruled impossible to write an analog of (!!) that type-checks?
15:14:39 <mhitza> fazzone, haven't read through all the comments
15:14:42 <erus`> You know what im just gonna do this is linux. Enough in enough :P
15:14:45 <merijn> dylex: That's what I wanted, I just wasn't sure whether I would end up just having one Chan used by everything that used "simpleStream"
15:14:54 <mhitza> and it's easier to get things out by trying out
15:14:59 <mhitza> at least, for me
15:15:08 <merijn> oh, doh
15:15:30 <merijn> I think I f'ed up the type. That explains my confusion :)
15:16:23 <eiro> can i read a list into separated variables ? something like  ( patern, filename ) <- getArgs
15:16:35 <fazzone> mhitza: it's easier to prove things doable by trying them out :)
15:17:00 <merijn> eiro: That won't work, but "pattern : filename : rest <- getArgs" should
15:17:17 <mhitza> fazzone, yeah, and with your questions you made me realize some things out
15:17:23 <eiro> oh yeah
15:17:28 <merijn> eiro: pattern and filename become the first and second item of the list, rest is whatever the remainder is
15:17:33 <dylex> eiro: or, [pattern, filename] <- getArgs (you can use an arbitrary pattern on the left of an arrow), but either way you'll get a runtime exception if there are missing args.
15:17:34 <mhitza> fazzone, and I understand why it cannot be written in a type checkable way
15:17:40 <merijn> eiro: Of course if the list is to short you'll crash
15:17:55 <mhitza> fazzone, although I see that there is a package for that anyway HList
15:18:57 <eiro> yep: tested :)
15:19:18 <eiro> so i have to raise an error
15:23:26 <eiro> thanks for help
15:23:33 <eiro> (going to sleep)
15:25:38 <merijn> @pl x >>= return . f
15:25:38 <lambdabot> f `fmap` x
15:27:50 <Danl2620> @type <*>
15:27:50 <lambdabot> parse error on input `<*>'
15:28:00 <Danl2620> @type (<*>)
15:28:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:29:06 <Danl2620> @type (<$>)
15:29:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:35:17 <FUZxxl> How is an event called, that may occur, but has a probability of zero (such as, that when choosing an arbitrary real number you get a natural number)?
15:36:37 <kmc> an event of probability zero, or of measure zero
15:37:32 <FUZxxl> yeah, but I want to emphasize that even if the event's probability is zero it still might happen.
15:37:48 <kmc> is your audience unfamiliar with probability theory?
15:38:22 <FUZxxl> kmc: Not really. But I am a little bit.
15:38:39 <FUZxxl> I recall that there was a specific word for that, but I forgot it.
15:39:25 <kmc> all I can say is that in probability theory, an event of probability 0 which still might happen is called "an event of probability 0"
15:39:46 <FUZxxl> kmc: Thanks
15:45:22 <hpaste> merijn pasted ‚Äúselectable stream‚Äù at http://hpaste.org/53294
15:45:36 <merijn> Ok, what am I missing here?
15:46:11 <merijn> oh, duh
15:46:18 <merijn> nvm, I'm an idiot
15:48:07 <monochrom> heh I see too
15:48:34 <merijn> That's what I get for rewriting the function without touching the type signature
16:03:10 <FUZxxl> map (+b) [a,b,c,d,e,f,g]
16:03:17 <FUZxxl> > map (+b) [a,b,c,d,e,f,g]
16:03:18 <lambdabot>   [a + b,b + b,c + b,d + b,e + b,f + b,g + b]
16:03:31 <FUZxxl> > map (\x-> x*y+b) [a,b,c,d,e,f,g]
16:03:32 <lambdabot>   [a * y + b,b * y + b,c * y + b,d * y + b,e * y + b,f * y + b,g * y + b]
16:03:48 <FUZxxl> > foldr1 (+) [1..10] :: Expr
16:03:49 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + 10))))))))
16:04:11 <FUZxxl> > foldr1 (>>=) [a,b,c,d,e,f] :: Expr
16:04:11 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
16:04:25 <FUZxxl> > foldr (>>=) [a,b,c,d,e,f] id :: Expr
16:04:26 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
16:04:31 <FUZxxl> > foldr (>>=) id [a,b,c,d,e,f]  :: Expr
16:04:32 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
16:04:53 <FUZxxl> > foldr (>>=) return [a,b,c,d,e,f]  :: Expr
16:04:54 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
16:04:59 <FUZxxl> > foldr (>>=) return [a,b,c,d,e,f]  :: IO Expr
16:05:00 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
16:08:22 <byorgey> foldr (>>=) return [a,b,c]  would be  a >>= (b >>= (c >>= return))
16:08:29 <byorgey> if c :: m a  then  (c >>= return) :: m a
16:08:47 <byorgey> but b >>= ...  requires the  ... to be a function
16:09:16 <byorgey> perhaps you want  foldr (>=>) return
16:12:58 <ddarius> An event of probability zero is described as "almost never" occurring.
16:16:04 <FUZxxl> ddarius: Thanks! That was exactly what I was looking for!
16:16:56 <HugoDaniel> o q √© q bomba a√≠ de saunas hj ?
16:18:07 <Ferdirand> is it when the probability is zero ? or where it converges towards zero ?
16:21:35 <morel> i installed ghc on my debian but there's no 'ghci'. why??
16:27:11 <morel> i mean, the executable doesnt exist. there's no command "ghci"‚Ä¶
16:28:28 <tomprince> Is there a way to get 'Ord TypeRep', without 7.2?
16:29:59 <FUZxxl> Did you try running ghc -interactive?
16:30:05 <FUZxxl> morel: Did you try running ghc -interactive?
16:30:10 <monochrom> strange, what command did you issue to install ghc?
16:30:35 <monochrom> debian doesn't split ghci into another package iirc
16:31:14 <FUZxxl> Is ghc one of the programs that find out there function from argv[0]?
16:31:33 <monochrom> no
16:31:40 <FUZxxl> If yes, you could simply try ln -s /usr/bin/ghci /usr/bin/ghc
16:31:45 <FUZxxl> monochrom: damned.
16:31:56 <byorgey> tomprince: you could make  compare = compare `on` show
16:32:02 <byorgey> tomprince: ugly hack but it ought to work OK
16:32:07 <monochrom> /usr/bin/ghc and /usr/bin/ghci are both shell scripts
16:32:31 <FUZxxl> byorgey: No... that would lead to an infinite loop.
16:32:56 <byorgey> FUZxxl: no it wouldn't.  They are different 'compare's.
16:33:04 <monochrom> more precisely, /usr/bin/ghc is a symlink to /usr/bin/ghc-<version>, which is one shell script. /usr/bin/ghci is a symlink to /usr/bin/ghci-<version>, which is another shell script.
16:33:05 <byorgey> the first is for TypeReps and the second is for Strings
16:34:32 <monochrom> ghc -interactive should work as expected, yes, but the debian package has ghci
16:35:59 <monochrom> http://packages.debian.org/sid/i386/ghc/filelist has ghci
16:36:15 <FUZxxl> byorgey: ?!? Maybe I didn't understand the rules of shadowing correctly.
16:36:22 <morel> i just did "sudo apt-get install ghc"
16:36:42 <morel> and "ghc -interactive" doesnt work
16:36:46 <byorgey> FUZxxl: 'compare' is a type class method.  So which implementation of 'compare' is chosen depends on the type.
16:36:53 <FUZxxl> byorgey: Ah! It's an instance, isn't it?
16:37:01 <FUZxxl> well... okay... got it.
16:37:05 <byorgey> FUZxxl: for example, suppose we had a class  ToInt a where toInt :: a -> Int
16:37:18 <byorgey> FUZxxl: then I could have  instance ToInt a => ToInt [a] where toInt = sum . map toInt
16:37:30 <monochrom> ghci6? http://packages.debian.org/squeeze/i386/ghc6/filelist
16:37:32 <byorgey> same thing: that isn't recursive even though it looks like it
16:37:45 <monochrom> that's debian stable for you
16:38:55 <erus`> is there an eidotr that does haskell indenting for you? like you press return and it indents till the end of the previous variable or w/e
16:39:11 <morel> monochrom: i use ghc 7.0.4
16:39:19 <Botje> erus`: vim is correct most of the time.
16:39:27 <Botje> I imagine emacs with haskell-mode can do it as well
16:39:46 <monochrom> emacs with haskell-mode with the right setting works cool (default setting not right)
16:40:07 <monochrom> (or maybe rather s/default/entry-level/)
16:41:52 <monochrom> except that it doesn't take into account the do-if-then-else introduced in Haskell 2010.
16:43:30 <parcs> morel: --interactive
16:44:19 <erus`> im moving from gedit
16:44:24 <erus`> because i want to be 1337
16:45:23 <Botje> eh
16:45:31 <Botje> don't spend time fighting your ditor
16:45:43 <Botje> it took me the better part of ten years to get fluent in vim
16:45:50 <Botje> I imagine it's about the same in emacs
16:46:29 <Botje> (have I really been using linux for ten years? wow)
16:46:34 <morel> parcs, thanks!
16:46:34 <monochrom> just 2-4 weeks for me
16:47:02 <ddarius> Botje: I bet Bram Moolenar wrote the code for vim in nano for the first dozen years.
16:47:03 <morel> FUZxxl: "ghc --interactive" says: "<command line>: not built for interactive use"
16:47:12 <FUZxxl> morel... okay...
16:47:15 <FUZxxl> that's strange.
16:47:28 <FUZxxl> What says ghc -V?
16:47:40 <monochrom> check PATH, re-arrange and/or eliminate bad entries
16:47:44 <morel> FUZxxl: The Glorious Glasgow Haskell Compilation System, version 7.0.4
16:47:48 <monochrom> "which ghc"
16:47:53 <Botje> ddarius: didn't he bootstrap using an existing vi or ex?
16:47:55 <dmwit> Surely Bram Moolenar used vi while making vim.
16:48:38 <FUZxxl> dmwit: The real question is: how did they write the first editor?
16:48:45 <Botje> typewriter.
16:48:53 <ddarius> Punch cards.
16:49:18 <monochrom> they bootstrapped something like ed from a card punch
16:50:06 <monochrom> ed is something simple enough to hand-write on paper (even in head) and then go punch into cards
16:51:02 <FUZxxl> ddarius: Urgh... punch cards...
16:51:25 <monochrom> 5 years ago rumours went that a Microsoft interview question was "write an editor" (implicit: by hand, on paper) so bootstrapping an editor was supposed to be "trivial"
16:52:21 <hpc> monochrom: cat '#!vim' > editor.sh
16:52:41 <aristid> relevant: http://www.gnu.org/fun/jokes/ed.msg.html
16:53:12 <morel> is it possible that the command "ghci" doesn't exist because of the CPU-architecture of that computer? it's an ARM-processor‚Ä¶
16:53:47 <monochrom> wait, how can ed take only 24 bytes on disk?!
16:54:27 <monochrom> haha 5.89824e37
16:54:53 <monochrom> how can you have 5.89824e37 bytes of disk space on your Timex Sinclair?!
16:55:12 <aristid> monochrom: he may have tinkered with the output of ls :)
16:55:14 <monochrom> (you can hardly have that today even)
16:55:16 <Sgeo|web> Why can't the compiler just see any data declaration that looks like a potential newtype and make it a newtype?
16:55:30 <monochrom> yeah I suppose I should just hahahahaha
16:55:42 <Sgeo|web> And then you wouldn't need newtype, I'd think
16:55:49 <Botje> Sgeo|web: because data allows bottoms
16:55:56 <monochrom> and oh, the date of /bin/ed is Oct 29  1929  hahaha
16:56:18 <aristid> monochrom: WYGIWYG!
16:58:07 <monochrom> Turing hasn't even finished highschool in 1929 XD
17:05:51 <qwer123> getting error with haskell-fastcgi: http://pastebin.com/MaswHBVn                             That's my lighttpd.conf: http://pastebin.com/Q9bZ0Myf
17:05:54 <mauke> The pastes MaswHBVn Q9bZ0Myf have been copied to http://hpaste.org/53297 http://hpaste.org/53298
17:06:11 <qwer123> the problem is from test_IO.fcgi ??
17:10:48 * hackagebot simple-sendfile 0.1.3 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.1.3 (KazuYamamoto)
17:15:48 * hackagebot skein 0.1.0.3 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.3 (FelipeLessa)
17:19:14 <hpaste> ‚ÄúJoey Adams‚Äù pasted ‚ÄúWhat's wrong with this use of unsafeUseAsCStringLen?‚Äù at http://hpaste.org/53299
17:19:52 <kmc> i don't know, what's wrong with it?
17:20:13 <JoeyA> explaining; lemme type
17:20:15 <JoeyA> :-)
17:20:18 <kmc> ok sorry
17:20:22 * kmc should probably be more patient
17:20:34 <JoeyA> When I use the code above in my application, crc32Update 0x10d04a90 "" returns 0 in some cases, which is wrong.
17:20:47 <kmc> (i usually put the problem description in the paste, so it's easier for me to spam it at more people :)
17:20:50 * hackagebot hierarchical-clustering 0.3.1.2 - Algorithms for single, average/UPGMA and complete linkage clustering.  http://hackage.haskell.org/package/hierarchical-clustering-0.3.1.2 (FelipeLessa)
17:21:03 <JoeyA> ah
17:21:13 <JoeyA> When I replace unsafeUseAsCStringLen with useAsCStringLen, it works.
17:21:42 <JoeyA> So it seems like there's something wrong with this code.
17:22:29 <JoeyA> (There is a CRC32 wrapper in Hackage already, but I'm concerned about its FFI signature and use of unsafeForeignPtrToPtr: http://hackage.haskell.org/packages/archive/digest/0.0.1.0/doc/html/src/Data-Digest-CRC32.html)
17:22:46 <kmc> did you check whether c_crc32 is modifying the buffer?
17:23:25 <JoeyA> It shouldn't be.  The corresponding zlib function uses a const pointer for that argument.
17:23:29 <kmc> yeah, using unsafeForeignPtrToPtr without touchForeignPtr anywhere is worrying
17:23:43 <kmc> JoeyA, still, i'd check... print the bytestring before and after
17:24:22 <kmc> also does it still happen when you execute this in IO, instead of using unsafePerformIO?
17:25:18 <JoeyA> Note that this happens without optimization.
17:25:29 <kmc> and with?
17:25:42 <JoeyA> I didn't test that, at least not on the library side.
17:26:03 <JoeyA> I'll try seq'ing the result.
17:26:18 <JoeyA> Meh, I'll try printing the string before and after first.
17:26:18 <kmc> JoeyA, my other advice is to put a breakpoint (or a printf) on the C function, and see what's actually getting passed
17:26:34 <JoeyA> hmm
17:27:23 <kmc> what did you mean by "0 in some cases"? it's nondeterministic?
17:27:29 <JoeyA> Right
17:27:42 <JoeyA> I have Put and Get actions (in cereal)
17:27:47 <JoeyA> In Put, it's returning 0 (incorrect)
17:27:52 <JoeyA> in Get, it's returning the correct value.
17:27:55 <kmc> odd
17:28:16 <kmc> can you write a self-contained test case where it does the wrong thing?
17:28:41 <JoeyA> Maybe on Monday.  I have to get this done fast.
17:28:45 <qwer123> Anyone can help?
17:28:53 <qwer123> getting error with haskell-fastcgi: http://pastebin.com/MaswHBVn                             That's my lighttpd.conf: http://pastebin.com/Q9bZ0Myf
17:28:54 <mauke> The pastes MaswHBVn Q9bZ0Myf have been copied to http://hpaste.org/53297 http://hpaste.org/53298
17:29:09 <JoeyA> err, Tuesday
17:31:01 <JoeyA> Who would have though unsafe would be so... unsafe?
17:31:55 <ddarius> @hoogle reallyUnsafe
17:31:55 <lambdabot> No results found
17:33:34 <stribor> is there any way to simulate while condition
17:33:45 <stribor> can function "until" do that
17:33:51 <hpc> :t until
17:33:52 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:33:58 <JoeyA> Maybe I should try using a safe foreign import...
17:34:02 <hpc> > until (> 5) succ 0
17:34:03 <lambdabot>   6
17:34:19 <stribor> how would i simulate while
17:34:31 <hpc> :t untilM
17:34:32 <lambdabot> Not in scope: `untilM'
17:34:58 <byorgey> stribor: are you doing something monadic? or you just want to iterate a function as long as some condition is met? or ... ?
17:35:18 <stribor> byorgey:  yes
17:35:25 <stribor> byorgey: just want to iterate
17:35:46 <byorgey> stribor: how about  takeWhile cond . iterate f ?
17:36:12 <stribor> byorgey: lovely:)....let me play with it:)
17:36:18 <byorgey> > takeWhile (<23) . iterate (+3) $ 0
17:36:20 <lambdabot>   [0,3,6,9,12,15,18,21]
17:36:25 <kmc> for monadic stuff there'http://hackage.haskell.org/package/monad-loopss
17:36:28 <kmc> ugh http://hackage.haskell.org/package/monad-loops
17:36:31 <JoeyA> kmc: unsafeUseAsCStringLen is giving a NULL pointer.  Isn't that something?
17:37:01 <kmc> heh, awkward
17:37:11 <dmwit> byorgey: Well, I got as far as building the latest GHC and cabal configure'ing base. But cabal build base crapped out with a longer error than my terminal's scrollback.
17:37:13 <JoeyA> I'll try forcing the bytestring.
17:37:19 <kmc> sounds like a bug in unsafeUseAsCStringLen
17:37:25 <kmc> maybe you can write up a test case and report it
17:37:43 <JoeyA> Maybe on Tuesday :-)
17:37:46 <byorgey> dmwit: are you sure you're supposed to build base with cabal?
17:37:52 <dmwit> No.
17:37:57 <dmwit> But it does have a base.cabal file...
17:38:04 <byorgey> are there Makefiles anywhere?
17:38:16 <byorgey> that could be just so that it will have the right metadata show up on Hackage
17:38:16 <dmwit> All the makefiles have "nhc" in their name.
17:38:24 <byorgey> after all, cabal install base  does not work
17:38:38 <dmwit> Right. That's a fair point.
17:38:51 <JoeyA> It happens even if I `seq` the string.
17:39:26 <byorgey> dmwit: an error longer than your terminal's scrollback is pretty epic though.
17:39:32 <byorgey> good work.
17:39:43 <dmwit> =)
17:40:12 <stribor> byorgey: takeWhile return type is list of some arbitrary type
17:40:16 <JoeyA> Copy-pasting from the internet: "I had not appreciated that this [unsafeUseAsCStringLen] can return a null pointer for an empty ByteString."
17:40:39 <JoeyA> Here is the offending line in zlib: if (buf == Z_NULL) return 0UL;
17:40:54 <byorgey> stribor: yes
17:41:31 <JoeyA> It shouldn't do that, but I suppose it does...
17:43:33 <JoeyA> kmc: Here is the offending line in ByteString: empty = PS nullForeignPtr 0 0
17:44:26 <JoeyA> A null pointer for an empty string is perfectly valid.  The documentation for the unsafeUse* functions should warn about it, I suppose.
17:44:37 <stribor> byorgey: what i want to do is this.....while (some function that returns boolean) do (someFunction whose return type is myCustomType)
17:45:27 <dmwit> ?hackage monad-loops
17:45:27 <lambdabot> http://hackage.haskell.org/package/monad-loops
17:45:47 <dmwit> stribor: Perhaps one of those will help. If not, perhaps you could send a patch to them with a loop in your style. =)
17:46:17 <stribor> dmwit: wish i am that good so i can actually submit patch:)
17:46:32 <dmwit> stribor: You may also be interested in this function:
17:46:33 <dmwit> :t until
17:46:35 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:46:54 <dmwit> > until (>37) (\x -> 3 * x + 1) 6
17:46:55 <lambdabot>   58
17:47:12 <stribor> thanks you
17:48:19 <Sgeo|web> @djinn (a -> Bool) -> (a -> a) -> a -> a
17:48:20 <lambdabot> f a b c =
17:48:20 <lambdabot>     case a c of
17:48:20 <lambdabot>     False -> b c
17:48:20 <lambdabot>     True -> c
17:48:38 <Sgeo|web> Hmm
17:48:50 <Sgeo|web> Those choices for what to do with false and true seem arbitrary
17:49:21 <dmwit> It attempts to use each argument. Otherwise it would probably just give you f a b c = c
17:49:37 <byorgey> stribor: what is the input type of someFunction?
17:50:22 <byorgey> or is it a monadic action?
17:50:32 <byorgey> or just a normal function?
17:51:23 <byorgey> stribor: if you could write down a concrete type for what it is you want to do, that would be a great start.
17:52:37 <stribor> byorgey: just normal function
17:52:43 <stribor> byorgey: i have function which returns my custom type
17:52:57 <byorgey> stribor: yes, and what does it take as input?
17:53:06 <stribor> i wamnt to execute that function repeatedly while some cond is true
17:53:19 <byorgey> it has type  MyCustomType -> MyCustomType ?
17:53:59 <stribor> myCustomType1->myCustomType2->myCustomType2
17:54:14 <stribor> thats the function i want to evaluate repeatedly
17:54:27 <byorgey> ok, and where does the value of MyCustomType1 come from?
17:54:47 <dmwit> :t \predicate function constantValue startingValue -> until predicate (function constantValue) startingValue
17:54:48 <lambdabot> forall t a. (a -> Bool) -> (t -> a -> a) -> t -> a -> a
17:54:49 <stribor> data = myCustomType1
17:55:16 <Ferdirand> @pl \f t -> dropUntil t . iterate f
17:55:16 <lambdabot> flip ((.) . dropUntil) . iterate
17:55:21 <Ferdirand> yuck
17:55:34 <dmwit> ?pl \p f c s -> until p (f c) s
17:55:35 <lambdabot> (.) . until
17:55:51 <stribor> dmwit: pl?
17:55:55 <byorgey> maybe stribor wants (not . predicate)
17:56:20 <byorgey> stribor: you still haven't written down the full type of what you want.
17:56:27 <byorgey> (MycustomType2 -> Bool) -> ... ?
17:56:52 <stribor> oh yeah i am just playing with "until" functino
17:56:56 <byorgey> until you write down a type we are just guessing.
17:56:56 <stribor> give me few
17:57:00 <dmwit> stribor: "pl" stands for "stupid Haskell tricks"
17:57:02 <byorgey> ok =)
17:59:33 <hpaste> swarles pasted ‚ÄúHaskell IRC Bot ‚Äù at http://hpaste.org/53300
18:00:03 <swarles> I was trying to extend the haskell bot on the haskell wiki, can anyone help/
18:00:05 <swarles> ?*
18:00:05 <lambdabot> Maybe you meant: . ? @ v
18:00:25 <swarles> Errors at the bottom of the paste ;p
18:00:51 * swarles is only 4 days into actually understanding haskell to a significant point
18:01:00 <dmwit> swarles: Did you miss a _?
18:01:09 <dmwit> doNumeric "371" _ _ = write (...)
18:01:20 <swarles> o.o
18:01:30 <dmwit> swarles: Same on the next line, needs another _.
18:01:35 <swarles> Oh ok
18:01:44 <dmwit> oh wait
18:01:47 <dmwit> Hold on.
18:02:08 <swarles> i thought that sounded weird o.o
18:02:15 <swarles> it should only take two arguments
18:02:50 <hpaste> stribor pasted ‚Äúwhile‚Äù at http://hpaste.org/53301
18:03:06 <stribor> byorgey: thats kind of what i want to implement
18:03:12 <dmwit> swarles: That is a bizarre error.
18:03:18 <swarles> o.o
18:03:27 <swarles> should i try it with runhaskell?
18:03:34 <dmwit> No, that should make no difference.
18:03:43 <dmwit> swarles: Out of curiosity, could you try changing the second line to
18:03:55 <dmwit> doNumeric _ _ = \_ -> return ()
18:03:55 <dmwit> ?
18:04:00 <swarles> o. o.o
18:04:01 <swarles> ok*
18:04:10 <byorgey> stribor: that doesn't make sense yet.  What is Type3?
18:04:24 <byorgey> stribor: and you can't just 'do' a function, you have to specify where it gets its inputs from
18:04:39 <stribor> byorgey: data = Type3
18:04:44 <swarles> it changed nothing
18:04:50 <swarles> should i put that line first?
18:04:51 <dmwit> stribor: data = Type3 isn't real Haskell.
18:05:04 <byorgey> stribor: so overall you want  (Type3 -> Type2 -> Bool) -> (Type1 -> Type2 -> Type2) -> ... ?
18:05:06 <dmwit> swarles: Nah.
18:05:08 <byorgey> stribor: what goes in the ... ?
18:05:24 <byorgey> stribor: what do you want to get out at the end?
18:05:29 <stribor> Type2
18:05:46 <byorgey> it should be the first Type2 for which the predicate is False?
18:05:56 <dmwit> swarles: Give me a second, I'm installing regex-pcre and I'll try to reproduce your error.
18:06:01 <swarles> okie dokie
18:06:04 <swarles> thank you
18:06:39 <stribor> why cant output from Type1 -> Type2 -> Type2) be fed back to Type1 -> Type2 -> Type2)
18:06:49 <stribor> oh no...that wont work
18:06:59 <byorgey> it can, but you have to pass a Type1 as well
18:07:32 <stribor> partially aplied function?
18:07:43 <hpc> swarles: doNumeric takes two parameters?
18:07:56 <byorgey> @type \thing1 thing2 thing3 predicate step -> until (not . predicate thing3) (step thing1) thing2
18:07:57 <lambdabot> forall t t1 a. t -> a -> t1 -> (t1 -> a -> Bool) -> (t -> a -> a) -> a
18:08:07 <byorgey> stribor: something like that? ^^^
18:08:09 <swarles> it takes the numeruc, and the line of text
18:08:15 <swarles> numeric*
18:08:26 <hpc> swarles: change the type of doNumeric to String -> String -> Bot ()
18:08:42 <hpc> your type is String -> String -> String -> Bot (), hence the error
18:08:57 <dmwit> swarles: The change I suggested fixes the error I see.
18:08:57 <stribor> byorgey: ok..i have to look little more into this....thank you
18:09:11 <dmwit> swarles: However, there's *another* error, which the change I suggested doesn't touch, and which you didn't tell us about.
18:09:12 <hpc> it sees doNumeric "blah" _ = write x y, and decides that the RHS of the equals sign has to be of type String -> Bot ()
18:09:18 <hpc> because that's what your type signature says
18:09:45 <dmwit> hpc: write takes another argument (surprise!)
18:09:52 <dmwit> hpc: So his type signature is correct.
18:10:39 <swarles> wait, dmwit so i need to add another _ to each line?
18:11:07 <dmwit> No, you should change the second line to doNumeric _ _ = \_ -> return ()
18:11:29 <swarles> i did that o.o
18:11:51 <vernon1> hello any java progammers here?
18:12:02 <swarles> but it still produces the error on doNumeric "371" _
18:12:26 <dmwit> swarles: You also haven't applied "doNumeric" to enough arguments in "testDrive".
18:12:33 <vernon1> hello?
18:12:36 <dmwit> swarles: You've provided it only two, but its type requires three.
18:12:43 <hpc> vernon1: quite likely, though you will find more over in that direction... ->
18:12:51 <dmwit> vernon1: This channel is for Haskell. Try #java or ##java.
18:13:24 * swarles facepalms
18:13:35 <swarles> i didnt give 2 arguments to write
18:14:07 <swarles> it compiled :)
18:14:33 <swarles> Thank you for helping!
18:17:42 <hpc> swarles: there's some design mistakes in that tutorial, the definition of 'write' being one of them imo
18:19:24 <swarles> I dont like that it immediately parses the content of the message
18:19:32 <swarles> ie whats after the second :
18:19:46 <swarles> i prefer to know the type of message and its origin
18:23:31 <parcs> haskell98-2.0.0.0 seems to break a lot of packages :(
18:23:54 <dmwit> Yes, but basically you should just take it out of their dependency list and use base instead.
18:23:57 <parcs> luckily a --constraint 'haskell98 < 2' fixes it
18:24:05 <parcs> or that
18:24:31 <dmwit> A lot of packages depend on haskell98 and base, when they really should depend on exactly one of them.
18:55:52 <qwer123> these packages are offline?? http://hackage.haskell.org/packages/archive/mohws/latest/doc/html/Paths_mohws.html#v:getLibDir
19:11:57 <xrl> how can I convert a ByteString of length 8 to a Word64?
19:12:34 <copumpkin> @hackage binary
19:12:34 <lambdabot> http://hackage.haskell.org/package/binary
19:12:52 <copumpkin> http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Get.html
19:13:32 <xrl> so I have to build a Data.Binary.Get monad, the run the monad... then I have to run it inside of the attoparsec monad
19:14:13 <copumpkin> not sure why you're parsing binary stuff with attoparsec
19:14:21 <copumpkin> but yes, if you are, that's what you should probably do
19:14:26 <copumpkin> you also need to decide on your endianness
19:14:42 <xrl> I'm parsing stuff with attoparsec... because someone on here recommended it :)
19:15:06 <xrl> and it is indeed working, just need to do some bytestring conversions
19:15:38 <vernon9> can anyone here help me over msn?
19:15:49 <vernon9> not sure how the chat room works
19:16:01 <xrl> vernon9: just ask your question
19:16:09 <copumpkin> vernon9: I doubt most people are willing to give away their msn information to a stranger
19:16:16 <vernon9> thats true
19:16:18 <xrl> vernon9: and the 2nd step is to always hang around.
19:16:26 <vernon9> im trying to edit this script
19:16:51 <vernon9> but have no idea how to shrink it down i know u guys will find this easy its my third class in java
19:17:01 <copumpkin> we don't do java here
19:17:07 <vernon9> no java?
19:17:08 <copumpkin> how did you find us, out of curiosity?
19:17:10 <copumpkin> no
19:17:19 <vernon9> i typed java chat room
19:17:20 <copumpkin> this channel is called #haskell because we do haskell :)
19:17:26 <copumpkin> in ##java, you might find java :)
19:17:30 <xrl> vernon9: haskell is a language all its own -- very far from java in fact
19:17:48 <vernon9> ##java
19:17:55 <copumpkin> type /join ##java
19:17:56 <kmc_> /join ##java
19:18:12 <vernon9> thx
19:18:17 <copumpkin> good luck!
19:21:40 <xrl> copumpkin: how can I do a Data.Binary.Get.getWord64be, alone, in runGet in one fell swoop?
19:21:56 <xrl> I know the byetstring I will be sending in is 8 bytes long
19:22:01 <vernon9> its not working /join## java
19:22:14 <copumpkin> you didn't write what we told you to write
19:22:16 <xrl> the hashes go next to java
19:22:22 <jtannenbaum> /join is the command, ##java is the channel name
19:22:22 <xrl> that too
19:22:43 <copumpkin> xrl: runGet getWord64be :: ByteString -> Word64
19:22:43 <jtannenbaum> "/join ##java" copy what's between the quotes
19:23:02 <xrl> copumpkin: oh, I have to force the type sig?
19:23:06 <copumpkin> no
19:23:10 <copumpkin> I'm just saying what type it'll have
19:23:23 <vernon9> i type it but nothing appears
19:23:42 <xrl> vernon9: are you on a website accessing this chatroom?
19:23:47 <vernon9> yea
19:23:59 <copumpkin> which website?
19:23:59 <xrl> copumpkin: what you wrote works... I thought I tried that already! thanks
19:24:03 <kmc> vernon9, go to http://webchat.freenode.net/
19:24:10 <kmc> put in ##java where it says "channels"
19:25:24 <vernon9> ight ok got it to work thanks guys
19:25:31 <Happy0> kmc: the problem is that you have to be registered to ac- oh, apparently not then :|
19:25:55 <Happy0> i thought you had to be identified..
19:27:47 <kmc> bah, if I want to link to a page explaining what Cmm is...
19:27:49 <kmc> is there such a page?
19:28:04 <kmc> iirc the C-- project has a website, but it's not really the same thing
19:28:36 <copumpkin> there's only the ghc commentary page
19:28:41 <copumpkin> which has quite a bit
19:28:44 <kmc> i couldn't find that even
19:28:45 <copumpkin> but I wouldn't call it a language reference
19:28:58 <copumpkin> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType
19:29:21 <kmc> ok thanks
19:29:31 <kmc> wasn't linked to from the top level Commentary
19:29:36 <kmc> and I fail at searching
19:29:50 <copumpkin> np :)
19:42:49 <hpaste> xrl pasted ‚ÄúUsing Get in Attoparsec‚Äù at http://hpaste.org/53302
19:43:54 <xrl> can someone point to how I use Data.Binary.Get inside of Data.Attoparsec? I need to get the value out of the Get monad and use it for AP.take
19:48:12 <xrl> I guess pattern matching is starting to make more sense :)
19:50:47 <slack1256> does anybody know if RWH is making a 2nd edition?
19:51:35 <copumpkin> interesting combination of languages in this project: http://git.megacz.com/?p=wix.git;a=tree;f=src;h=7995362a74b255c21c814fa5b673fa9eec87cb85;hb=HEAD
19:52:04 <xrl> slack1256: I hope so :-)
19:52:15 <ddarius> copumpkin: Not -that- surprising.
19:52:43 <byorgey> slack1256: yes, I think they are
19:52:45 <slack1256> xrl: i also hope so. I'll definetly buy it if the make it
19:53:15 <copumpkin> ddarius: I guess it's just not a combination I've seen before
19:53:48 <slack1256> cool!, then i should save some $ for it.
19:59:40 <kmc> found 258449 outliers among 159999 samples (161.5%)
20:00:39 <kmc> O_O_O
20:01:05 <xrl> any tips on that hpaste I had? I'm totally lost in the monad in monad :(
20:01:50 <slack1256> xrl: what hpaste?
20:01:59 <xrl> http://hpaste.org/53302
20:02:33 <xrl> I need to move a bytestring -> word64. I'm trying to use Data.Binary.Get inside of the Data.Attoparsec monad
20:04:09 <copumpkin> kmc:lol
20:04:55 <kmc> that was... an odd criterion run
20:04:58 <kmc> now it's back down to 2%
20:05:07 <copumpkin> bos might want to know about that
20:05:19 <kmc> yeah
20:05:22 <xrl> slack1256:  this paste gets further in the typecheck, http://hpaste.org/53303
20:05:26 <kmc> unfortunately i have no idea what caused it or how to reproduce
20:05:32 <xrl> compile error at the end
20:05:38 <kmc> it was on the clock resolution estimation
20:05:40 <kmc> the actual results for that run were sane
20:06:23 <slack1256> xrl: ok, thanks :), let me take a look (but i don't promise anything, i'm no expert on Data.Binary)
20:06:42 <xrl> any monad help would be great :)
20:06:49 <kmc> ok it happened again :/
20:09:15 <hpaste> kmc pasted ‚Äúcost of noDuplicate#‚Äù at http://hpaste.org/53304
20:09:22 <kmc> these results are not really surprising
20:09:28 <kmc> i just generated them so I thought I'd share :)
20:18:25 <ddarius> "He calls the flat-figure-eight the 'instant-death knot.'"
20:20:35 <byorgey> (Arrow (~>), Monoid m) => [a ~> m] -> (a ~> m)   -- anyone want to have a go at implementing this in a nice way?
20:21:37 <xrl> any idea what I should do for the error: "Couldn't match expected type `Word64' with actual type `m0 Word64'"
20:25:31 <byorgey> @type let combine [] = arr mempty; combine (a:as) = (a &&& combine as) >>> arr (uncurry mappend) in combine
20:25:32 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a, Monoid c) => [a b c] -> a b c
20:25:51 <byorgey> that works, but I wonder if there's a way to do it without the explicit recursion.
20:26:07 <byorgey> oh, duh, it's just a fold.  ignore me =)
20:28:43 <o-_-o> How do I read a file directly into a vector ?
20:29:58 <mike-burns> xrl: Something to do with a monad, most likely.
20:30:07 <BMeph> Anyone care to show me a clever way to do this one - mapAndFoldM :: (Monad m) => (a -> x -> m (a, y)) -> a -> [x] -> m (a, [y])
20:30:11 <mike-burns> o-_-o: What's in the file?
20:30:38 <o-_-o> it has a single integer per line
20:31:46 <copumpkin> :t mapAccumR
20:31:46 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
20:31:58 <copumpkin> @src mapAccumR
20:31:58 <lambdabot> Source not found. It can only be attributed to human error.
20:32:02 <BMeph> I can do it by just writing it out, but it feels odd to do so, seeing how much like (Data.List.)mapAndAccumL and (Control.Monad.)mapAndUnzipM it looks.
20:32:51 <ddarius> BMeph: If you flip the arguments to the passed in function and the output, it should look familiar.
20:33:23 <xrl> so I think I've figured out the monad problem but I'm having trouble differentiating between a monad's type class and data values: http://hpaste.org/53305
20:34:39 <xrl> I think it has to do with my forcing "AP.Done" in the function header
20:35:50 <xrl> hmm, maybe I can force the function header to something appropriate :)
20:37:19 <BMeph> ddarius: StateT's mapM?
20:39:42 <ddarius> Yes.
20:40:49 <copumpkin> oh, clever
20:41:42 <o-_-o> let xv = fromList . Prelude.map (read::String -> Complex Double) . Prelude.drop 4 . lines $ a
20:41:49 <BMeph> Dang it, ddarius, why aren't you a MAJ, and assigned to Monterrey, to pal around with oleg, already? :)
20:41:55 <o-_-o> I did this to read a pgm file into a Data.Vector
20:42:01 <o-_-o> and it is just hanging at fromList
20:42:20 <o-_-o> The first four lines are header, the rest are the grayscale data
20:42:43 <o-_-o> is there a more efficient way to read a list of integers from a file into a Data.Vector ?
21:14:25 * ddarius doesn't know what a MAJ is.
21:14:45 <ddarius> Unless you mean Major.
21:18:11 <ddarius> Actually, Goodfellow AFB maintains a geographically separated unit in Monterey, California.
21:26:32 <DanBurton> Does anyone here have experience using Haskell as a CGI scripting language?
21:28:02 <xrl> DanBurton: have you looked at any of the popular haskell web frameworks? snap, yesod, happstack?
21:28:52 <kmc> "cgi isn't cool anymore"
21:29:12 <xrl> kmc: no, that's not what I'm saying... just wondering if he REALLY wants CGI? :)
21:29:37 <kmc> if you build against wai then you can use your same code with CGI or FastCGI or whatever framework
21:29:40 <xrl> I'm sure haskell would be just fine for cgi since it doesn't have to bring up a big fat runtime
21:29:43 <stepcut>  DanBurton: There used to be a glue layer that would let you use happstack to write CGI apps
21:29:54 <stepcut> DanBurton: or FastCGI
21:29:59 <kmc> xrl, the GHC runtime is pretty substantial
21:30:12 <xrl> do a process per request?
21:30:16 <xrl> *to do
21:30:58 <kmc> but yeah I guess startup times are small
21:31:41 <xrl> kmc: standard CG is like invoking a command line script. the arguments are just passed in through env variables
21:31:43 <xrl> or so I think ;)
21:31:51 <kmc> i'm aware
21:32:52 <kmc> I am a web programming expert, I wrote my dorm's quotes board in plain Perl CGI with no framework when I was a teenager
21:32:54 <kmc> ;)
21:33:13 <kmc> it used a revolutionary extensible NoSQL key-value document storage backend
21:33:25 <kmc> which is to say a flat file of key=value pairs
21:34:28 <xrl> I'm a web programming expert, too... I program in rails and have a stacktrace 30 levels deep ;)
21:34:41 <kmc> but do you have a stackoverflow 30,000 points deep :O
21:34:54 <xrl> I'm in the 60s... :)
21:35:20 <xrl> so my monad problem isn't being resolved... to stackoverflow I go :)
21:35:31 <kmc> monads mo' problems
21:35:56 <xrl> it's not even monads, it's making sense of the types
21:36:03 <rien> are only three-lettered nicknames allowed voice?  ;)
21:36:06 <xrl> I can't tell if I'm better or worse after staring at it for 2 hours
21:36:12 <Cale> xrl: Sorry, what was your monad problem?
21:36:35 <xrl> Cale: do you want stack overflow karma for helping? :)
21:36:39 <Cale> No
21:36:41 <xrl> haha
21:36:43 <Cale> But I'll help here
21:36:53 <Cale> I don't believe in stack overflow
21:37:45 <xrl> Cale: http://hpaste.org/53306
21:38:23 <Cale> return G.runGet G.getWord64be bs <-- this looks pretty fishy :)
21:38:32 <Cale> Remember that return isn't a keyword
21:38:33 <xrl> yes, yes it does
21:38:37 <Cale> It's an ordinary function
21:38:45 <xrl> oh ya
21:39:08 <Cale> So you're probably looking for  return (G.runGet G.getWord64be bs)
21:39:22 <Cale> Or: return $ G.runGet G.getWord64be bs
21:39:28 <xrl> ya, that makes sense. new error: "Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString' with actual type `B.ByteString'"
21:39:51 <Cale> okay, so that's the difference between lazy and strict bytestrings
21:40:12 <Cale> B is Data.ByteString, which has the strict ByteString type in it
21:40:27 <xrl> how do I know which kind I want?
21:40:29 <DanBurton> stepcut: I certainly have looked at those projects (yesod, snap, etc). At the moment, though I was looking into web hosting with nearlyfreespeech.net ( http://example72.nfshost.com/versions.php )
21:41:16 <Cale> Binary works with lazy bytestrings
21:41:46 <xrl> Cale: I think attoparsec can use either lazy or strict bytestrings
21:41:47 <luite> DanBurton: you can also use free heroku hosting
21:42:09 <xrl> so if I simply change the qualified import that should make things click
21:42:10 <Cale> If not, you can apply Data.ByteString.Lazy.fromChunks to a lazy bytestring (like the one you're getting from runGet) to turn it into a strict one
21:42:15 <Cale> But yeah
21:42:27 <Cale> (I don't know attoparsec well, but that sounds reasonable
21:42:31 <Cale> )
21:42:37 <stepcut> DanBurton: GHC 6.8.3 :p
21:43:04 <stepcut> DanBurton: do you run FreeBSD  on any of your dev machines?
21:43:12 <Cale> xrl: I also just stumbled onto http://hackage.haskell.org/package/attoparsec-binary
21:43:15 <xrl> Cale: ruh roh, attoparsec only deals with strict bytestrings
21:43:22 <Cale> which looks relevant to what you're doing
21:43:29 <xrl> Cale: good catch!
21:43:42 <xrl> holy smokes
21:43:46 <DanBurton> stepcut: I don't have my own machines, besides my laptop. That's why I was looking at hosting
21:44:33 <DanBurton> (I run Windows and ubuntu on my laptop)
21:45:35 <DanBurton> luite: how much can you do with free hosting w/ heroku?
21:45:41 <stepcut> DanBurton: if you want to use Haskell with NFS you are going to need some way to build Haskell applications that can run on their servers (which seem to use FreeBSD). Running the GHC compiler is fairly resource intensive.. I wonder if they would actually allow that..
21:46:08 <stepcut> DanBurton: if you had a dev machine, you could build locally and then upload executable..
21:46:32 <xrl> Cale: whoa, it compiles! :)
21:46:32 <luite> DanBurton: you get 300MB ram I think, and a pretty limited postgresql db, you can run one full web app with that as long as you don't have too much data
21:46:44 <luite> DanBurton: but you must use your own machine to build the binary
21:46:52 <mightybyte> DanBurton: I just read something where a guy was saying that he ran a Snap app on Heroku.
21:47:01 <DanBurton> stepcut: I could probably throw FreeBSD on into VirtualBox if I needed to
21:47:20 <mightybyte> Said it worked fine if he compiled it on a separate machine running ubuntu.
21:47:24 <stepcut> DanBurton: yeah. That is how I test Happstack support for FreeBSD
21:47:24 <luite> I believe heroku requires a 64 bit linux binary
21:47:24 <DanBurton> mightybyte: got links?
21:48:09 <mightybyte> http://news.ycombinator.com/item?id=3170848
21:48:15 <DanBurton> luite: what about bandwidth?
21:48:25 <DanBurton> mightybyte: cool, thanks :)
21:49:37 <luite> DanBurton: hmm, not sure, don't think there are major limitations
21:49:38 <mightybyte> DanBurton: prgmr.com and linode.com are some pretty cheap VPS hosting providers that I've used for Haskell standalone apps.
21:49:54 <xrl> I'm dealing with a frame-oriented protocol and I'm using attoparsec so I can possibly use timeout to cleanup slow/dead connections... what's a good way to build sessions out of frames? a higher order type which is made up of many frames?
21:50:12 <luite> DanBurton: yesod also runs on heroku by the way, someone in #yesod mentioned using it in production
21:50:21 * DanBurton finds it amazing that a web hosting starting with the letter "H" doesn't directly support Haskell.
21:50:26 <xrl> err, not sessions per se, but "messages". the frames have FIN bits which let me know if my message buffer is complete
21:51:50 <xrl> for heroku, do you have to compile on a similar linux install?
21:52:11 <DanBurton> mightybyte: I've been looking at cheap VPS solutions, but the price point is always still upwards of $10 per month. The attractive thing about nearlyfreespeech is that if your site has very little traffic, then you pay pennies
21:52:12 <luite> yep, you have to build a statically linked executable that will run on their machines
21:52:47 <vharishankar> Hi, is there any easy way to find out which package to import for a function in ghci?
21:52:57 <DanBurton> prgmr.com looks pretty cheap though
21:53:08 <mightybyte> DanBurton: Yeah.  It's one of the cheapest ones I've found.
21:53:14 <xrl> vharishankar: hoogle on haskell.org
21:53:14 <vharishankar> DanBurton: I host on nearlyfreeshpeech and I can heartily recommend them
21:53:19 <DanBurton> vharishankar: hayoo?
21:53:30 <vharishankar> xrl: Thanks.
21:53:34 <luite> DanBurton: you probably want at least the 1024MB RAM option if you build on their machines
21:54:05 <vharishankar> DanBurton: thanks.
21:54:07 <rien> DanBurton: I love you! I was trying to remember the name of this very site today!
21:54:21 <rien> and googling like a mad man for the most nonsense keywords...
21:55:14 <vharishankar> Is there any way to do it without an internet connection though?
21:55:22 <vharishankar> I have downloaded the documentation
21:55:27 <DanBurton> @where hayoo
21:55:27 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
21:55:39 <DanBurton> @where hoogle
21:55:39 <lambdabot> http://haskell.org/hoogle
21:55:43 * stepkut finds it difficult to build anything substatial with less than 2GB
21:55:51 <stepkut> even with 4G I often run into swap hell
21:55:56 <DanBurton> I believe if you have hoogle installed on your machine then it can index all the packages you have installed
21:56:15 <stepkut> though installing gold helped
21:56:24 <vharishankar> DanBurton: thanks. I will look into that.
21:56:26 <luite> 2GB works ok for me with web apps (a 2GB Ubuntu VM)
21:56:52 <DanBurton> @index unfoldr
21:56:53 <lambdabot> Data.List
21:57:04 <DanBurton> lambdabot knows where some stuff is too. Not sure if it is limited to base
21:57:08 <DanBurton> @where StateT
21:57:08 <lambdabot> I know nothing about statet.
21:57:10 <stepkut> luite: my web apps are pretty big :)
21:57:16 <luite> where the VM only runs the web apps and some very basic services
21:57:35 <luite> stepkut: ah what kind of things are you building?
21:57:51 <bmh> Is there a straight forward way of getting line numbers when I crash? I'm encountering a strange error where I'm dying when calling fromJust on a Nothing after casing Just / Nothing
21:58:07 <stepkut> luite: a website that allows you to construct and prove arguments using first order logic, among other things
21:58:29 <luite> ah is it that complex to build?
21:58:55 <luite> I'd expected something with a huge number of dependencies
21:59:07 <stepkut> luite: well, it does have a huge number of dependencies..
21:59:08 <mightybyte> The trick to cheap hosting is to not build on the server.
21:59:21 <mauke> bmh: why are you calling fromJust?
21:59:27 <DanBurton> bmh: um what? Why would you use fromJust if you used a case statement to match the Just case?
21:59:41 <luite> stepkut: is it already online somewhere?
21:59:51 <bmh> This sounds like a very reasonable explanation of the error I'm seeing :)
22:00:01 <stepkut> luite: an alpha version is here, http://seereason.com/
22:00:09 <stepkut> luite: a bit rough in the UI still
22:00:26 <stepkut> luite: here is a very simple proof, http://www.seereason.com/web//W_Theorem/TheoremId/1
22:00:34 <stepkut> not sure if you have to be logged in to see that
22:00:42 <DanBurton> > case (Just 3) of Nothing -> 0; Just x -> x
22:00:43 <lambdabot>   3
22:00:53 <DanBurton> > case (Just 3) of Nothing -> 0; Just x -> fromJust x
22:00:54 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
22:00:54 <lambdabot>    arising from a use of...
22:01:20 <bmh> DanBurton: I see what I'm doing wrong
22:01:33 <luite> stepkut: ah looks interesting
22:01:42 <stepkut> luite: one of the missing pieces is the code that renders the formulas as normal prose
22:01:43 <DanBurton> bmh: ah good :)
22:01:44 <bmh> I have a map of type Map a (Maybe a)
22:02:01 <bmh> I was forgetting to sanity check the contents after doing my lookup
22:02:22 <stepkut> luite: so next to, ‚àÄx: SocratesS1(x)‚áíManS2(x), it would say, "Socrates is a Man"
22:02:38 <bmh> DanBurton: I promise I'm not doing something horrendously stupid with that type.
22:02:51 <stepkut> luite: ‚àÄx: ManS2(x)‚áíMortalsS3(x) "All men are mortals", etc.
22:03:23 <luite> stepkut: what do you want to use it for? a teaching tool, or do you have other applications in mind?
22:04:30 <stepkut> luite: other applications
22:12:17 <BMeph> Sorry for wandering off, ddarius: I meant "Major", yes.
22:12:43 <vharishankar> > intercalate "," ["this,is,a,sentence,which,must,split,on,comma"]
22:12:45 <lambdabot>   "this,is,a,sentence,which,must,split,on,comma"
22:12:59 <vharishankar> hmm...
22:13:16 <DanBurton> huh?
22:13:29 <vharishankar> DanBurton: Not sure. I want words to split on comma or any character
22:13:39 <DanBurton> intercalate is for *putting* commas in there
22:14:01 <DanBurton> @hoogle String -> String -> [String]
22:14:02 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
22:14:02 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
22:14:02 <lambdabot> System.FilePath.Posix addExtension :: FilePath -> String -> FilePath
22:14:06 <vharishankar> I thought intersperse was for that??
22:14:29 <kmc> vharishankar, look at the 'split' package
22:14:32 <DanBurton> hmm time for me to look at the docs
22:14:50 <vharishankar> kmc: thanks.
22:15:00 <byorgey> @src intercalate
22:15:00 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
22:15:05 <byorgey> vharishankar: ^^^
22:15:05 <stepkut> I love this proposal, http://hackage.haskell.org/trac/ghc/ticket/4481
22:15:23 <stepkut> Let's make it happen :)
22:15:31 <byorgey> Oops, trac detected an internal error!
22:16:09 <kmc> stepkut, it'll be less painful with that one recently proposed ghc feature...
22:16:09 <DanBurton> "fail does not belong in monad" AMEN
22:16:19 <kmc> default superclass instances or something
22:16:38 <stepkut> heh
22:16:51 <DanBurton> that will be nice. Any ETA on when that will be implemented in GHC?
22:16:57 <kmc> lets us revise Monad to be a subclass of Functor, and attach some code that says "btw, if anyone's library defines a Monad instance without Functor, use this Functor instance:"
22:17:06 <kmc> (which would be fmap = liftM)
22:17:10 <stepkut> I will start using pure instead of return under the assumption that this proposal will eventually become reality
22:17:18 <kmc> so it lets you rejuggle the hierarchy without breaking everything
22:17:29 <kmc> stepkut, if the proposal becomes reality then certainly 'return' will be a synonym for 'pure'
22:18:05 <stepkut> kmc: hopefully with a DEPRECATED pragma. Might as will fix the deprecation warnings now
22:18:24 <stepkut> ;)
22:18:32 <vharishankar> OK I found that Data.List.Split does the job
22:18:40 <ddarius> DanBurton: That's a library feature not a GHC feature.
22:18:45 <ddarius> Also, Pointed is pointless.
22:19:10 <DanBurton> deprecate "return" ==> all libraries ever emit deprecation warnings
22:19:14 <stepkut> ddarius: because all Pointed instances are Applicative?
22:19:30 <vharishankar> > splitOn "," "a,b,c,d"
22:19:32 <lambdabot>   Not in scope: `splitOn'
22:19:40 <stepkut> ddarius: that is, anything that can be Pointed can also be Applicative?
22:19:56 <DanBurton> lambdabot's packages don't include split? D:
22:20:05 <byorgey> stepkut: no, just because it isn't very useful
22:20:09 <ddarius> stepcut: Because the only reasonable law for a Pointed instance is the free theorem and knowing that something is only Pointed says very little.
22:20:15 <stepkut> byorgey: I use pure/return all the time!
22:20:35 <byorgey> stepkut: yes, but if you were ONLY allowed to use pure/return, you wouldn't be able to do very much.
22:20:48 <byorgey> you always use pure/return in conjunction with <*> and >>= .
22:20:49 <stepkut> pure and fmap
22:21:21 <DanBurton> I heard someone suggest once that we replace all of the various "runFoo" functions with "coPure"
22:21:23 <vharishankar> DanBurton: neither am I able to import Data.List.Split from within ghci
22:21:34 <DanBurton> @package split
22:21:34 <lambdabot> http://hackage.haskell.org/package/split
22:21:56 <vharishankar> DanBurton: So it's not part of haskell's built-in library?
22:22:03 <DanBurton> vharishankar: nope
22:22:08 <byorgey> vharishankar: just 'cabal install split'
22:22:19 <DanBurton> vharishankar: but if you have cabal-install, you can do what byorgey just said
22:22:33 <byorgey> and if you don't have cabal-install, you did something wrong in a previous step
22:22:53 <stepkut> byorgey: I might want to write a polymorphic function that only uses pure/fmap. But the called will use that function with a concrete type where than can do something more useful..
22:22:58 <vharishankar> byorgey: I've not installed cabal-install . I only have ghci and ghc
22:23:13 <byorgey> vharishankar: how did you install ghc?
22:23:16 <DanBurton> vharishankar: you didn't install the Haskell Platform?
22:23:33 <vharishankar> I use Debian. I just installed the ghc compiler
22:23:40 <DanBurton> ooh
22:23:44 <vharishankar> I must install the haskell-platform meta-package I guess
22:23:47 <byorgey> vharishankar: OK, just  apt-get install haskell-platform
22:24:26 <vharishankar> OK
22:24:47 <vharishankar> Seems to want to pull in a lot of dependencies for that... so I'll install cabal-install
22:26:11 <byorgey> vharishankar: what sort of dependencies?
22:26:26 <kmc> i'm not sure the 'return' alias should be deprecated in that case
22:26:27 <byorgey> vharishankar: the point of the Haskell Platform is that it gives you a whole bunch of standard Haskell libraries and tools
22:26:39 <kmc> do you propose to deprecate one of fmap and (<$>) also?
22:27:20 <vharishankar> byorgey: thanks. I'll install haskell-platform. It tries to pull in a lot of -dev packages. I am downloading something big now, so I thought I will do that later.
22:27:21 <stepkut> kmc: that bug replaces fmap with map. So yeah. it is useful to have map and <$> I think
22:27:31 <byorgey> vharishankar: OK, sure.
22:27:51 <vharishankar> byorgey: is haskell-platform the recommended haskell distribution?
22:28:18 <vharishankar> It seems to be the preferred method...
22:28:18 <byorgey> vharishankar: yes.
22:28:25 <Cale> Personally, I never use the debian/ubuntu packages for Haskell stuff. They fragment things into a lot of tiny pieces, and automatically replace package versions out from under you which can cause problems for packages installed via cabal.
22:28:32 <stepkut> kmc: and we should get rid of MonadPlus and just use Monoid as well I think ..
22:28:47 <Cale> It's easy enough to just install the generic linux binary, and then cabal-install
22:29:03 <stepkut> ...and mappend should be <>. And then Haskell will be perfect :p
22:30:13 <vharishankar> Cale, where does cabal install put the installation into?
22:30:21 <vharishankar> I mean the packages
22:30:27 <Cale> ~/.cabal and ~/.ghc
22:30:47 <vharishankar> And haskell compiler will detect the packages from there?
22:30:52 <Cale> yeah
22:31:09 <vharishankar> That seems reasonable, instead of installing into system folders.
22:31:11 <Cale> Well, ~/.ghc contains information which makes them available to ghc
22:31:15 <Cale> yeah
22:31:38 <Cale> It's also much easier to deal with if you accidentally screw up your dependencies
22:32:22 <vharishankar> Many of the useful functions are in libraries. :-(
22:32:43 <Cale> You can always just blow away ~/.ghc (and optionally ~/.cabal except the config file), and then reinstall packages with cabal. If you screw up your global packages, you can end up in a position where reinstalling ghc is the easiest way to fix things.
22:33:00 <mauke> how dare they put commonly needed code in reusable software components
22:33:08 <vharishankar> Cale: that is so.
22:33:13 <Cale> (so always install as user unless you have a good excuse :)
22:33:16 <kmc> don't Monoid and MonadPlus have divergent instances in some cases
22:33:18 <kmc> like Maybe?
22:33:22 <Cale> mauke: :)
22:33:32 <kmc> Just x `mplus` Just y = Just x
22:33:39 <kmc> Just x `mappend` Just y = Just (x `mappend` y)
22:33:56 <stepkut> ah yes
22:34:07 <stepkut> I remember that now
22:34:08 <kmc> maybe this is confusing and we'd be better off picking one
22:34:12 <vharishankar> mauke: I guess part of the problem is that what is useful is so subjective.
22:34:12 <Cale> NO!
22:34:16 <Cale> I use both regularly
22:34:16 <stepkut> it's been years since I last figured that out
22:34:26 <kmc> haha Cale, I vaguely expected this reaction
22:34:35 <kmc> what's a cool example of the Monoid instance for Maybe
22:34:49 <Cale> lol, fizzbuzz
22:35:14 <ddarius> mauke: Don't worry, most programmer's avoid that mistake.
22:35:22 <Cale> (also, combining configuration values)
22:35:51 <kmc> it's true that some of 'split' should be in the standard library
22:35:57 <kmc> but the standard library is also a library ;)
22:36:03 <ddarius> kmc: Why?
22:36:20 <kmc> why should 'words' be in?
22:36:28 <ddarius> Historical reasons.
22:36:57 <kmc> Haskell definition of "standard library" is a little arbitrary... it can mean Prelude, the modules mandated by the Report, the modules which ship with GHC and Hugs, the modules which ship with GHC, the modules which ship with Platform, ...
22:37:08 <ddarius> Indeed.
22:37:55 <ddarius> But the split package is not exactly something that needs to be version-locked with GHC or even tested against other libraries.
22:37:55 <vharishankar> kmc: yes, a bit confusing for a new user. :)
22:37:56 <kmc> Platform is of course a sneaky attempt to expand the "standard library" without Committee approval ;)
22:38:06 <luite> bah why are exceptions so difficult in monad transformers :(
22:38:28 <kmc> Haskell has the best culture of code reuse I've seen
22:38:30 <ddarius> kmc: The "committee" will rightfully never include OpenGL into the "standard library."
22:38:50 <kmc> which yeah means putting things in the "standard library" is less important
22:39:05 <Cale> kmc: Do you get what I'm saying about fizzbuzz though? There's a pretty cute solution :)
22:39:14 <kmc> Cale, I have'nt seen the code
22:39:32 <Cale> > let fizzbuzz n = fromMaybe (show n) $ ("fizz" <$ guard (n `mod` 3 == 0)) `mappend` ("buzz" <$ guard (n `mod` 5 == 0)) in map fizzbuzz [1..]
22:39:33 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
22:39:45 <Cale> > let fizzbuzz n = fromMaybe (show n) $ ("fizz" <$ guard (n `mod` 3 == 0)) `mappend` ("buzz" <$ guard (n `mod` 5 == 0)) in map fizzbuzz [12..]
22:39:46 <lambdabot>   ["fizz","13","14","fizzbuzz","16","17","fizz","19","buzz","fizz","22","23",...
22:39:52 <kmc> (oh except for the part where cabal downloads are unencrypted and uploads are barely authenticated or audited... so every time you cabal install you're taking a huge risk with your machine)
22:39:53 * kmc whistles
22:40:22 <Jafet> kmc: that's the real reason why you don't install --global!
22:40:22 <DanBurton> I sort of wish there was a more "exclusive" Hackage, that required packages to have a certain level of documentation, maintenance, and especially easy-to-satisfy dependencies
22:40:47 <kmc> Jafet, yeah, because it's so hard to escalate from user to root on a typical Linux desktop ;)
22:40:48 <ddarius> kmc: This is hardly different from the current credit card system.
22:41:29 <kmc> DanBurton, you should run it :D
22:41:30 <luite> DanBurton: there is, but we won't tell you since it also has requirements for users ;)
22:41:43 <kmc> are the requirements "works at galois"
22:41:56 <DanBurton> kmc: :)
22:42:23 * ddarius is waiting for kmc to upload a malicious package.
22:42:49 <DanBurton> kmc: I have entertained the idea of starting something like that. Maybe if I ever graduate I'll get around to doing that...
22:42:49 <mauke> > iterate (concatMap (\c -> if c == 'A' then "A CAT" else [c])) "A"
22:42:51 <lambdabot>   ["A","A CAT","A CAT CA CATT","A CAT CA CATT CA CAT CA CATTT","A CAT CA CATT...
22:43:10 <Cale> mauke: lol
22:43:27 <DanBurton> conCATmap
22:44:51 <Cale> > iterate (concatMap (\c -> case c of ' ' -> "   "; '#' -> "# #")) "#"
22:44:52 <lambdabot>   ["#","# #","# #   # #","# #   # #         # #   # #","# #   # #         # #...
22:45:05 * ddarius doesn't understand why we are doing this.
22:45:19 <DanBurton> ddarius: Fun! Duh.
22:45:21 <Cale> Cantor dusty
22:45:40 <ddarius> Also (>>=)
22:45:52 <ddarius> Or intercalate.
22:46:43 <mauke> > iterate (concatMap (\c -> [c, ' ', c])) "#"
22:46:45 <lambdabot>   ["#","# #","# #   # #","# #   # #         # #   # #","# #   # #         # #...
22:47:16 <Jafet> > iterate (=<< (ap ( :) ((' ' :) . (:[]) )) "#"
22:47:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
22:59:03 <dmwit> > iterate (\s -> s ++ map (const ' ') s ++ s) "#"
22:59:05 <lambdabot>   ["#","# #","# #   # #","# #   # #         # #   # #","# #   # #         # #...
22:59:58 <dmwit> > iterate (concat . sequence [id, map (const ' '), id]) "#"
23:00:00 <lambdabot>   ["#","# #","# #   # #","# #   # #         # #   # #","# #   # #         # #...
23:03:14 <kmc> 4:20 smoke MagicHash every day
23:03:50 <DanBurton> @quote kmc 4:20 smoke MagicHash every day
23:03:50 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
23:03:53 <DanBurton> doh
23:03:58 <DanBurton> @remember kmc 4:20 smoke MagicHash every day
23:03:59 <lambdabot> I will remember.
23:07:03 <bluephoenix47> Does anyone know of a more recent version of a library similar to this Concurrent Haskell Debugger: http://www.informatik.uni-kiel.de/~fhu/chd/
23:07:31 <bluephoenix47> This one doesn't appear to have been updated in several years, and required a library which appears to have died
23:19:53 <dmwit> bluephoenix47: Wow, GHC 5. That's pretty ancient.
23:20:18 <bluephoenix47> Yea :/ I managed to find a slightly more recent version. sorting through the dependencies now
23:20:28 <gienah> bluephoenix47: there is threadscope: http://hackage.haskell.org/package/threadscope
23:21:01 <bluephoenix47> well, I don't need performance information so much, just general concurrency debugging
23:22:33 <DanBurton> "concurrency debugging" sounds like an oxymoron
23:22:56 <DanBurton> I'm sure it can be done, but it certainly isn't easy.
23:23:48 <dmwit> DanBurton: Reading the paper now. It seems they sacrificed performance 100% to make it possible.
23:24:25 <dmwit> They wrote an entire scheduler as a central (single-threaded) GUI.
23:24:33 <dmwit> If I understand it correctly.
23:26:01 <ddarius> bluephoenix47: It looks like much of the ideas could be quickly reimplemented.
23:26:27 <dmwit> concur
23:26:34 <bluephoenix47> define quickly
23:27:04 <ddarius> bluephoenix47: You could have all the hooks in less than a day and some of the GUI.  You could probably have an acceptable GUI in less than a week.
23:27:22 <bluephoenix47> My adviser wants it by tomorrow.
23:27:22 <dmwit> I was going to say two weeks.
23:27:33 <dmwit> But I'm not as good as ddarius. =)
23:27:39 <ddarius> Tell your adviser to write it.
23:27:55 <DanBurton> lol
23:28:20 <ddarius> There is a lot of good (and not so good) debugging technology that has bitrotted.
23:28:22 <bluephoenix47> haha.. I found a 6.8 version. it looks like it needs 'sourceview' which isn't in the package database
23:28:38 <ddarius> That's probably part of Gtk2hs
23:28:54 <DanBurton> @where gtk2hs
23:28:55 <lambdabot> http://haskell.org/gtk2hs/
23:29:03 <bluephoenix47> Yea, the most recent version is called gtksourceview2. But this package doesn't recognize it as sourceview
23:29:03 <dmwit> You're in luck. The sourceview package is *also* bitrotted.
23:29:14 <bluephoenix47> v.v
23:29:17 <ddarius> 6.8 wasn't that long ago.
23:29:22 <DanBurton> fsvo "luck"
23:30:04 <bluephoenix47> hm.. well, maybe I can convince it gtksourceview is good enough
23:30:09 * DanBurton wonders when gtk2hs will hit 1.0
23:30:20 <ddarius> There's Gtk3 now
23:31:04 * ddarius checks how the economy is doing.
23:57:09 <kmc> who's running GHC on ARM pre-v6? http://hackage.haskell.org/trac/ghc/browser/rts/OldARMAtomic.c
23:57:32 <AfC> Do the gtk2hs hackers hang out here? I'd give them a hand if I knew who they were.
23:58:45 <kmc> running Haskell on a featurephone? ;)
23:59:42 <kmc> anyway whoever they are they can't be too happy about the speed of mvar locking
