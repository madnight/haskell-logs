00:05:29 * hackagebot safe-globals 0.1 - Safe top-level mutable variables which scope like ordinary values  http://hackage.haskell.org/package/safe-globals-0.1 (KeeganMcAllister)
00:08:43 <shachaf> kmc++ # making evil more convenient, one package at a time
00:08:59 <kmc> thanks shachaf
00:09:16 <kmc> http://mainisusuallyafunction.blogspot.com/2011/10/safe-top-level-mutable-variables-for.html
00:12:34 <adrake> this is a pretty funny heap profile:
00:12:35 <adrake> http://hax.so/misc/wtfheap.png
00:13:10 <adrake> the yellow bit curving down at the end is particularly entertaining, I really have no idea what's going on there
00:15:58 <elliott> kmc: in the "Type clashes" section, I assumed you had moved on to talk about your library; so "it" read as safe-globals to me, and I started hating your library :-)
00:16:14 <kmc> oh no
00:16:40 <shachaf> Yes, make the h1 an h2 or something.
00:16:48 <elliott> shachaf: Or just clarify it :P
00:16:51 <kmc> the h2s look crappy
00:17:00 <kmc> the only place i refer to the library as "it", i have the name in the previous sentence
00:17:16 <elliott> kmc: yeah, but I was skimming :-)
00:17:18 <copumpkin> sometimes I wish I had dependent type sin haskell
00:17:21 * copumpkin grrs
00:18:00 <shachaf> copumpkin wishes to transgress.
00:18:51 <copumpkin> aha, I found a cleanish hack for this case
00:19:16 <shachaf> That's what non-dependent languages are like, one cleanish hack after another.
00:19:46 <copumpkin> oh wait, no I didn't
00:20:10 <copumpkin> damn types
00:20:23 <elliott> You should disable the type system.
00:20:40 <copumpkin> no no, I want more types
00:21:07 <copumpkin> I need to reason about the structure of this hlist without having a value of it
00:21:15 <copumpkin> "hlist"
00:21:24 <Blkt> good morning everyone :D
00:23:30 <kmc> hi Blkt
00:23:43 <frerich> I saw 'Int16' in Data.Int, but where is the type for unsigned 16 bit integers defined?
00:24:01 <kmc> Data.Word.Word16
00:24:16 <Blkt> hi kmc
00:24:31 <frerich> kmc: Ah, it's called a word, thanks.
00:25:01 <kmc> :)
00:35:29 * hackagebot acme-colosson 0.1 - Determines whether it is numberwang.  http://hackage.haskell.org/package/acme-colosson-0.1 (KeeganMcAllister)
00:37:47 <copumpkin> kmc: excellent!
00:38:35 <elliott> kmc: That tarball is way too big to contain the rules of Numberwang.
00:38:55 <kmc> lack of a library to determine whether it is numberwang was the main thing holding back Haskell in The Enterprise
00:39:14 <copumpkin> I think this might be the final puzzle piece that was missing
00:39:16 <kmc> Scala and Clojure have the advantage of easy access to existing Java numberwang libraries
00:39:26 <copumpkin> now I'll finally be able to sell haskell to my boss
00:39:31 <copumpkin> and then we can use nothing but haskell
00:39:34 <copumpkin> at work :D
00:39:57 <kmc> future versions will also support wordwang, nümberwang, and wangernumb
00:40:12 <kmc> elliott, it's emergent, you see
00:40:14 <copumpkin> oh wow
00:40:18 <copumpkin> ambitious I see
00:40:40 <elliott> kmc: That must be slow. Genetic algorithms only operate at like a kparsec/s on standard numberwang formulae.
00:40:54 <elliott> I'm sticking to the tried-and-tested C++ WANGKt.
00:41:01 <elliott> It uses threads, so you know it's fast.
00:41:20 <Nevin> hi guys
00:41:59 <kmc> hi Nevin
00:42:11 <erus`> elliott C++11 threads?
00:42:22 <kmc> buh need to download TM&WL series 4
00:43:21 <elliott> erus`: No, it uses Windows threads.
00:43:23 <elliott> On every platform.
00:43:38 <Nevin> I am picking up Haskell, company will going to need to x'mas party lucky draw webpage, so I am yhinking to use
00:43:48 <Nevin> thinking to use it as a small project
00:43:51 <Nevin> to learn
00:44:16 <Nevin> not sure if it's a right approach though :-)
00:44:35 <copumpkin> Nevin: you mean the numberwang package?
00:44:48 <copumpkin> I think we should have several different numberwang packages
00:45:02 <copumpkin> just like we have several packages for vector-like things
00:45:07 <copumpkin> and several packages for parsers
00:45:08 <kmc> vectorwang
00:45:18 <kmc> attowangsec
00:45:22 <copumpkin> oh burn
00:45:26 <Nevin> I am sorry, what's that?
00:45:29 <copumpkin> I'm scared to read your latest blog post kmc
00:45:30 <elliott> kmc: You need some RULE pragmas in that.
00:45:44 <kmc> derive-wang-th-mtl-catch-transformers-2.0
00:45:45 <elliott> kmc: Stream fusion Numberwang, maybe?>
00:45:49 <elliott> Otherwise it just can't be fast.
00:45:55 <kmc> -enumerators
00:46:10 <elliott> numberwang-enumerator
00:46:10 <kmc> Nevin, we're just joking around, probably because it's 4 AM here
00:46:22 <kmc> numberwang-extras
00:46:22 <copumpkin> why am I not asleep yet
00:46:25 <copumpkin> lol
00:46:29 <copumpkin> conumberwang
00:46:31 <elliott> numberwang-tiling
00:46:34 <Nevin> @kmc: hahaha
00:46:34 <lambdabot> Unknown command, try @list
00:46:46 <elliott> Come on, they have to be applicable somehow.
00:46:51 <Nevin> kmc: haha
00:47:16 <Nevin> where are you guys? I am from Hong Kong
00:48:32 <ion> Oh, we’re in the same local group. I’m in Finland.
00:50:34 <Nevin> ion: Finland is pretty far from here :-)
00:50:48 <kmc> usually on the show it is numberwang
00:50:52 <kmc> more than 50% of the time
00:50:59 <kmc> but we may assume the contestants are experienced players
00:51:11 <kmc> having watched many shows and practiced with the authorized home game
00:54:43 <QinGW`> Nevin: I am from Bei Jing.
00:55:40 <Nevin> QinGW`: oh hi how are you?
00:56:18 <QinGW`> Nevin: hi, Do you have functional course in college?
00:58:53 <Nevin> QinGW`: There's no such course when I am still in school. Not sure if t hey have it now.
01:00:02 <QinGW`> Nevin: okay, I am reading real world haskell, but It is a big problom to me.
01:00:21 <QinGW`> I am lost.
01:01:20 <mauke> preflex: ? lyah
01:01:21 <preflex>  http://learnyouahaskell.com/
01:01:23 <QinGW`> Have you ever come BJ or other place in China mainland?
01:01:46 <Nevin> QinGW`: to me I think "Learn yourself a haskell" is better
01:03:13 <lysgaard> Is there a way to show a number as a binary stirng of 0 and 1s?
01:03:35 <Axman6> it's pretty eacy to implement
01:03:37 <Axman6> easy*
01:04:13 <mauke> lysgaard: the easiest way is Text.Printf.Mauke
01:04:28 <mauke> the second easiest way is a bit more complicated because I have to look it up
01:04:32 <mauke> :t showIntAtBase
01:04:33 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
01:04:51 <mauke> > showIntAtBase 2 intToDigit 123 ""
01:04:52 <lambdabot>   "1111011"
01:05:34 <danr> > showIntAtBasse 2 intToDigit 42 ""
01:05:35 <lambdabot>   Not in scope: `showIntAtBasse'
01:05:41 <danr> > showIntAtBase 2 intToDigit 42 ""
01:05:42 <lambdabot>   "101010"
01:05:43 <danr> hmpf
01:07:24 <QinGW`> > showIntAtBase 16 intToDigit 15 ""
01:07:25 <lambdabot>   "f"
01:07:54 <danr> > showIntAtBase 32 intToDigit 31
01:07:55 <lambdabot>   Overlapping instances for GHC.Show.Show
01:07:56 <lambdabot>                              (GHC.B...
01:07:57 <danr> > showIntAtBase 32 intToDigit 31 ""
01:07:58 <lambdabot>   "*Exception: Char.intToDigit: not a digit 31
01:08:04 <danr> ouch!
01:08:30 <danr> where is showIntAtBase defined?
01:09:52 <Axman6> @hoogle showIntAtBase
01:09:52 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
01:10:05 <danr> Axman6: ty
01:11:34 <lysgaard> Looks good.
01:12:26 <lysgaard> If i have: data Dir = GoLeft | GoRight, I'd like to generate all possible combinations of left and right of length n, would this be the best way to do it?
01:13:11 <Axman6> > replicateM 4 "01"
01:13:12 <lambdabot>   ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","101...
01:13:35 <Axman6> in your case, replicateM n [GoLeft, GoRight]
01:13:58 <lysgaard> Axman6: Wow, magic replicateM ... =)
01:14:06 <Axman6> indeed
01:14:19 <Axman6> it's not so magic if you understand the list monad
01:14:24 <Axman6> @src replicateM
01:14:25 <lambdabot> replicateM n x = sequence (replicate n x)
01:14:29 <Axman6> heh
01:14:30 <Eelis> what use is category theory for functional programmers? i mean, it seems everybody agrees that you don't need to understand any category theory to see that monads are a nice useful abstraction. so, what would be an example of some idiom in functional programming that you really /do/ need category theory for to appreciate it and make effective use of it?
01:15:16 <elliott> > [0..] >>= flip replicateM "ab"
01:15:18 <lambdabot>   ["","a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","...
01:15:22 <elliott> nice enumerator
01:15:35 <Axman6> it's something like: replicateM n _ | n <= 0 = return []; replicateM n xs = do {x <- xs; ys <- replicateM (n-1) xs; return (x:ys) }
01:16:02 <elliott> you can use list comprehensions there :P
01:16:14 <Axman6> it's not just for lists
01:16:36 <Axman6> that's another way to define replicateM, not... replicateMListsOnly :P
01:16:48 <elliott> oh right, "return []" threw me off
01:16:49 <elliott> ALSO
01:16:51 <elliott> monad comprehensions
01:17:08 <Axman6> yeah
01:26:34 <b_jonas> Do GADTs actually give any new semantics?
01:27:19 <b_jonas> I mean, instead of a GADT, couldn't you just use a traditional algebraic type instead, but wrap the constructors to restrict their type and use those wrappers for all construction (but not for deconstruction)?
01:27:47 <b_jonas> Is there anything GADTs allow me to prove to the compiler that I couldn't prove by using traditional algebraic types?
01:29:08 <mauke> GADTs are existentials
01:29:34 <b_jonas> yes, existential types fall out as a special case
01:29:45 <b_jonas> but what if you enable existentials and higher order types as a start
01:29:51 <b_jonas> do GADTs then give anything new?
01:29:57 <elliott> GADTSyntax :-)
01:30:18 <b_jonas> right, they're certainly new syntax, but I specifically asked about "new semantics"
01:30:28 <elliott> I think not, then.
01:30:39 <b_jonas> maybe they do give some new semantics, I just don't understand their type rules. I don't know.
01:30:48 <opqdonut> elliott: are you sure?
01:30:54 <elliott> opqdonut: Nope.
01:31:15 <opqdonut> AFAICT gadts are as powerful as fundeps
01:31:25 <b_jonas> really?
01:31:26 <b_jonas> how?
01:31:45 <opqdonut> I'm researching
01:33:00 <elliott> b_jonas: I think it's obvious that you can do it as existentials + rank-n, since it's trivial to rewrite the signatures in that form.
01:33:07 <elliott> You basically drop the arrows and move quantifiers before the constructor name.
01:33:24 <mauke> elliott: how so?
01:33:33 <elliott> Well, I might be missing something.
01:33:35 <elliott> But
01:33:50 <elliott> Foo :: (Blah a, Foo q) => a -> Foo a -> q -> MyType a
01:33:50 <elliott> -->
01:33:51 <mauke> data Foo :: * -> * where { Bar :: String -> Foo Int }
01:34:06 <elliott> mauke: Hmm, right, it's the return that's the hard part.
01:34:16 * elliott feels dumb now.
01:39:39 <b_jonas> mauke: in the case of that example, my question is, suppose you instead write data Foo a = Bar String; bar :: String -> Foo Int; bar = Bar;
01:39:56 <b_jonas> and then replace all uses of Bar as a value with bar (but keep Bar in patterns)
01:40:03 <b_jonas> would that break anything?
01:40:08 <mauke> I don't know
01:40:35 <Eduard_Munteanu> opqdonut: maybe along with asstypes?
01:41:56 <mauke> pondering data Expr :: * -> * where { Eq :: (Eq a) => Expr a -> Expr a -> Expr Bool; If :: Expr Bool -> Expr a -> Expr a -> Expr a }
01:42:09 <b_jonas> I'm starting to suspect GADTs were invented by people who don't like record notation: they give us GADT fooling us into thinking they're something new and shiny, and as a side effect we stop using record syntax because it doesn't work with GADT.
01:42:25 <opqdonut> but it does?
01:42:38 <opqdonut> e.g. http://www.haskell.org/ghc/docs/6.6/html/users_guide/gadt.html
01:42:51 <opqdonut> (first google hit for "record gadt")
01:43:01 <b_jonas> opqdonut: ah, right
01:43:06 <b_jonas> but nobody knows that
01:43:10 <opqdonut> I do
01:43:14 <opqdonut> I've even used it
01:43:17 <b_jonas> hmm
01:43:56 <opqdonut> though I'm not sure GADTs are worth the small improvements they bring over normal phantom types
01:43:59 <opqdonut> (having used both)
01:44:35 <b_jonas> but maybe GADTs do give something general but I don't see that because everyone shows special-case applications only
01:45:07 <b_jonas> special cases like phantom type stuff, existential stuff, no constructors, etc
01:46:52 <freeasjesus> Question to all the elderly Haskell people: have you noticed a growth in interest in Haskell recently (last year or two)?>
01:50:04 <int-e> good question. http://www.haskell.org/pipermail/haskell-cafe/ volume actually shows a decline, but the traffic was split (haskell-beginners, stackoverflow, etc.)
01:51:07 <erus`> how do you guys compile data into your binaries and access it at runtime?
01:51:44 <int-e> Anyway, I thought the interest was fairly stable over the last two years.
01:51:46 <khs> How can I write a function like Function :: IO Type -> Type ?
01:51:52 <mauke> khs: you can't
01:52:02 <Axman6> khs: no!
01:52:22 <khs> why?
01:52:32 <mauke> khs: because where are you going to get a value of type Type from?
01:53:05 <Axman6> because the poinbt if the IO monad is to make sure pure code does not have side effects
01:53:11 <Axman6> point*
01:53:11 <mauke> if you think "oh, I'm just going to extract it from IO Type", you're confused, because IO Type doesn't "contain" a Type in it
01:53:20 <int-e> erus`: I try to avoid this for large amounts of data. You can go through FFI, but constant expressions in Haskell tend to generate big code.
01:53:28 <mauke> IO is not a "container" or "tag"
01:53:37 <khs> Oh, ok
01:53:38 <int-e> (not to mention that they also bog down the compiler)
01:53:58 <mauke> khs: do you know any other programming languages?
01:54:10 <khs> yes
01:54:14 <mauke> which ones?
01:54:18 <khs> c, java, c++, python...
01:54:23 <Axman6> they're all wrong
01:54:26 <Axman6> >_>
01:54:26 <khs> hehe
01:54:42 <mauke> .oO( no, only java and c++ are wrong, and only c++ is really wrong )
01:54:58 <elliott> Everything is wrong.
01:55:16 <khs> I have a (very) basic understanding of functional languages
01:55:25 <mauke> khs: you can think of IO Type as containing a string of python code
01:55:30 <elliott> freeasjesus: haskell has practically exploded in popularity in the past few years
01:55:40 <elliott> I mean, this channel was not one of the largest on freenode that long ago :)
01:55:47 <ion> khs: “do foo <- bar; …”: bar :: IO a, foo :: a, the type of the entire expression is IO b.
01:55:51 <mauke> khs: and e.g. putStr s = "sys.stdout.write(" ++ show s ++ ");"
01:56:13 <mauke> khs: that is, putStr constructs a program that (when executed) will print the string it was given as an argument
01:56:43 <khs> So, I want to use the ghc api to make CoreModule from a file, and inspect it using ghci...
01:57:02 <khs> would that be possible then?
01:57:04 <Axman6> do you know haskell?
01:57:15 <khs> I have taken some tutorials (in a hurry for a project)
01:57:15 <Axman6> because... thats a pretty advanced task
01:57:18 <b_jonas> > let { extractIO :: IO Int -> Int; f = 4; } in extractIO (fmap read GetLine) :: Int
01:57:19 <lambdabot>   The type signature for `extractIO' lacks an accompanying bindingNot in scop...
01:57:21 <b_jonas> 4
01:57:23 <mauke> what's a CoreModule?
01:57:25 <freeasjesus> elliott: Yes, I've noticed. So anyone know why Haskell has suddenly become so popular? It's not like it's a new thing
01:57:29 <b_jonas> > let { extractIO :: IO Int -> Int; extractIO = 4; } in extractIO (fmap read GetLine) :: Int
01:57:30 <lambdabot>   Not in scope: data constructor `GetLine'
01:57:33 <b_jonas> 4
01:57:37 <b_jonas> hmm
01:57:56 <erus`> freeasjesus: everyone is jumping on the hipster haskell bandwagon
01:58:02 <elliott> freeasjesus: RWH, LYAH
01:58:04 <b_jonas> > let { extractIO :: IO Int -> Int; extractIO = 4; } in extractIO (fmap read 4etLine) :: Int
01:58:05 <lambdabot>   Not in scope: `etLine'
01:58:07 <b_jonas> 4
01:58:08 <b_jonas> argh
01:58:17 <khs> It's part of a project for school, have to dump core to a format that is easily parseable, ie, fully parenthesized
01:58:17 <elliott> freeasjesus: dons transformed into Haskell promotion machine, began colonising galaxy
01:58:19 <elliott> freeasjesus: xmonad
01:58:29 <elliott> perfect storm, really
01:59:28 <Axman6> freeasjesus: for one, people are realising that sane concurrency is a lot easier when (shared) mutable state is not the default
02:00:04 <quicksilver> #haskell's growth has been anything but sudden
02:00:16 <quicksilver> it's been a very gradual growth over the last 10 years
02:00:30 <quicksilver> dons used to graph it but that bitrotted
02:01:00 <erus`> haskell is great until you need monad transformers and stuff. Then i feel like writing that code in C(++)
02:01:17 <elliott> quicksilver: You can graph it just by scraping the tunes page.
02:01:23 <freeasjesus> elliott: what's "dons"?
02:01:24 <elliott> erus`: That's why you avoid monad transformers.
02:01:32 <elliott> freeasjesus: Don Stewart
02:01:49 <erus`> elliott sometimes i have no choice, if i need todo IO in an Either
02:02:18 <freeasjesus> According to wikipedia, he is a faith healer... no mention of haskell from the mighty ctrl+f
02:02:29 <erus`> lol
02:02:35 <elliott> Yeah, there's only one person called Don Stewart in the world :P
02:02:56 <luite> erus`: hm, monad transformers get better after a while, but unfortunately there are a few problems that don't appear to have a satisfactory solution
02:02:58 <b_jonas> we also have channel logs for this channel
02:03:01 <elliott> He's one of the authors of bytestring, RWH, countless else, [...], yadda yadda.
02:03:06 <b_jonas> from which we could make statistics
02:03:10 <luite> like exception handling
02:04:23 <b_jonas> I have the channel logs for between 2007-05 to 2009-11 downloaded here
02:04:50 <elliott> You don't need that.
02:04:54 <elliott> http://tunes.org/~nef/logs/haskell/ lists the file sizes.
02:05:00 <elliott> Admittedly you have to download in batch old logs now; sigh.
02:05:11 <elliott> I mean, graphing file size is a fairly decent measure of growth.
02:05:16 <b_jonas> hmm, true
02:05:20 <elliott> But IME the graph tends to just look like /.
02:05:26 <elliott> For just about any channel.
02:05:26 <b_jonas> I downloaded it for searching
02:06:19 <b_jonas> though it has the file sizes rounded to kilobyte only
02:07:11 <b_jonas> ah, it has the old logs in zip now
02:07:12 <b_jonas> great
02:07:21 <b_jonas> that's easier than having to download it separately
02:08:34 <elliott> Should be rsync really.
02:09:05 <b_jonas> possibly, but a http server is probably easier for the maintainers to set up
02:09:12 <b_jonas> I'm glad they provide logs at all
02:10:20 <elliott> Nobody really maintains clog, it just crashes every now and then and someone restarts it. :p
02:11:08 <b_jonas> elliott: sort of like my irc bots, yes
02:11:39 <b_jonas> whenever I go to holiday for a week, it very likely goes down and I restart it only wnen I return
02:11:52 <b_jonas> I know I should fix it, but I'm lazy
02:25:29 <cvic_> most Haskell programmers are lazy
02:28:52 <JuanDaugherty> which is famously with hubris and the other vice a virtue of programmers
02:29:03 <JuanDaugherty> impatience
02:30:27 <JuanDaugherty> a more cogent and related complaint is the blithering conception that pure functionality results magically somehow in useful end function, practical apps
02:31:37 <JuanDaugherty> that because you can express powerful abstractions in haskell that somehow is enough in and of itself
02:31:57 <JuanDaugherty> which in an academic setting it might be
02:35:52 <frerich> Hm. I recently noticed this tendency to abstract over all kinds of containers (say: Data.Map) by passing functions instead of 'plain containers'. Like, I had a function which took a 'Map String String' and used it to perform some lookup (asserting that the key exists) and I rewrote this to take a 'String -> String' instead. Is this (try to use functions to abstract of containers as arguments) a good school of thought, or is does it usually cause more harm?
02:36:17 <frerich> I only have little pet projects so I don't really notice a big benefit, but I'd like to get some good habits.
02:39:27 <quicksilver> frerich: it's not a bad idea. Certainly don't be scared of passing functions around.
02:39:48 <quicksilver> there are some practical disadvantages - they're hard to serialise into a file format.
02:40:28 <flux> it allows more flexibility in the caller side to decide the argument
02:40:54 <frerich> quicksilver: That's a good point. Another thing I noticed is that sometimes a function taking a Data.Map really does quite a few different things so I would actually need to pass a whole range of functions to abstract over all those map operations, and that's annoying.
02:40:58 <flux> I use the approach sometimes
02:41:21 <flux> if you need more than one function, then maybe it's not the best way
02:41:40 <flux> I wouldn't be too worried about needing to refactor/rewrite  th code either, especially if it's small
02:41:42 <frerich> flux: So far, my limit is two. :-) If I need three operations, I just pass the container directly.
02:42:17 <frerich> flux: Oh yeah, it doesn't make much difference in my case but I'd like to get a few good habits so that I don't use techniques which don't scale nicely (or which couple software components for no good reason) lateron, in larger projects.
02:42:47 <frerich> So a rule of thumb like "If in doubt, pass functions if you need <= 2 operations on the container" is maybe not bad.
02:43:51 <flux> you might also consider passing tuples
02:44:01 <flux> they are easier to pass around from the function to other functions
02:44:22 <quicksilver> the really important point is the one flux made
02:44:25 <quicksilver> it's not hard to refactor
02:44:29 <quicksilver> so don't worry too much :)
02:44:33 <quicksilver> worrying is the enemy of done.
02:44:41 <quicksilver> s/ing//;
02:44:58 <flux> see, there quicksilver is demonstrating the point by refactoring his sentence ;-)
02:45:02 <quicksilver> that kind of refactoring is really easy in haskell because if you make any mistake, there will be an immediate type error.
02:45:55 <frerich> Hm that's true
02:46:16 <quicksilver> in python, on the other hand, that kind of refactoring will create bugs which will live in your program *forever*
02:46:27 <quicksilver> this is why python is so great
02:46:33 <quicksilver> consultancy income guaranteed for life
02:47:34 * JuanDaugherty is happy to hear pythong disparaged.
02:47:44 <whald> do I understand right that when having a Vector (a, b) (from the vector package), this will internally be handled like a (Vector a, Vector b)?
02:49:36 <whald> and if this is so, is there an easy to improve the (a == b) case so that the elements are packed next to each other? it seems I have to write a quite lot of boilerplate (Unbox instance) to accomplish this
02:58:56 <JuanDaugherty> way
03:07:15 <dcoutts> byorgey: see getInstalledPackages
03:07:55 <frerich> Hi, as part of my IRC client program, I have some code which parses an (optional) --port command line argument to a port number. The small function which does this is at http://hpaste.org/52787 but there are a few things about it which I've been wondering (and I suspect people here can give some insight):
03:08:01 <dcoutts> whald: why do you want to do that?
03:08:22 <frerich> 1. Can I somehow move the 'parsedPort' definition further in? It's only used in the false branch of the outer 'if', so I'd like to restrict the scope to that.
03:08:42 <elliott> frerich: You should really use where, not let.
03:08:52 <frerich> 2. If I wanted to use 'where' instead of 'let ... in' here, where would I put the 'where' clauses? I tried to put them on the same level as the 'if' but I couldn't get that to work, I always got a syntax error.
03:09:05 <whald> dcoutts: I expect better cache utilization. from my c++ times I know this can easily give 5-10% performance gain.
03:09:26 <elliott> frerich: http://hpaste.org/52787
03:09:30 <elliott> frerich: Seemy annotation.
03:09:40 <elliott> (I didn't replicate the Unicode nonsense, you'll have to do that :P)
03:10:04 <quicksilver> frerich: you really should *not* use where instead of let.
03:10:09 <whald> dcoutts: that is, for my use case at least
03:10:18 <quicksilver> let is perfectly cromulent :)
03:10:27 <elliott> quicksilver: Um, guards are clearly the right thing to use here.
03:10:31 * quicksilver sees context
03:10:32 <elliott> And you can't do those with let.
03:10:53 <elliott> frerich: BTW -- Port -- make that PortNumber.
03:10:55 <frerich> quicksilver: My dictionary doesn't know what "cromulent" means, and neither do I :-)
03:10:55 <elliott> There's a type for that.
03:10:57 <dcoutts> whald: ok, so yeah you need to define your own data type which will look much like a pair, and then add an unbox instance
03:11:07 <quicksilver> elliott: hmm but == [] is code smell
03:11:07 <elliott> frerich: Oops, s/Seemy/See my/
03:11:10 <opqdonut> frerich: cromulent is a perfectly cromulent word
03:11:18 <elliott> quicksilver: Yes, I can refactor this further...
03:11:21 <opqdonut> (it's a joke, google it)
03:11:32 <frerich> Oh... lost in translation.
03:11:40 <geheimdienst> frerich: you should embiggen your dictionary
03:11:47 <mauke> frerich: try urbandictionary.com for all your translation needs
03:11:56 <opqdonut> or wiktionary, for that matter
03:12:03 <mauke> http://www.urbandictionary.com/define.php?term=cromulent
03:12:20 <frerich> It didn't even occur to me to look anywhere else than dict.leo.org, my one-stop-shop for translations :-}
03:12:26 <quicksilver> hmm
03:12:29 <hpaste> elliott annotated “Ugly port argument parsing” with “Ugly port argument parsing (annotation) (annotation)” at http://hpaste.org/52787#a52789
03:12:39 <elliott> frerich: That's better.
03:12:41 <quicksilver> hpaste is using a proportional font in its textarea on my browser
03:12:45 <mauke> dict.leo.org is ok for plain english, but if you want to speak internets, you should turn to urbandictionary
03:12:45 <geheimdienst> frerich: this should settle it http://en.wikipedia.org/wiki/Cromulent#Embiggen_and_cromulent
03:12:46 <quicksilver> that's annoying to edit
03:13:00 <elliott> frerich: No ugly partial functions, no duplication of PortNumber, etc.
03:13:11 <whald> dcoutts: somewhere in the vector package there is a hint for the "minimum complete definition" of an Unbox instance, but it seems rather incomplete (if I trust GHC) -- an "optimized" version I have working is here: http://code.google.com/p/bling-raytracer/source/browse/src/Graphics/Bling/Spectrum.hs#37
03:13:43 <quicksilver> yes, I like elliott's last version
03:13:51 <quicksilver> although with only two guards I think if/then/else is fine too
03:13:54 <whald> dcoutts: I'll do a similar thing in another place soon, do you see any redundancy in this?
03:14:29 <whald> dcoutts: it just seems to be quite a lot of code for the job, which makes me wonder if i'm doing s.t. wrong :-)
03:14:43 <frerich> quicksilver, elliott: So having two nested if's is not so nice, but having a 'case' on the outside and an 'if' on the inside is ok?
03:15:01 <elliott> frerich: let→if→if is definitely a code smell. But mine has improvements beyond that:
03:15:13 <elliott> frerich: It avoids partial functions completely, and uses pattern matching in place of other destructing.
03:15:24 <quicksilver> and it avoids naming things which are only used once
03:15:24 <elliott> Also, it avoids that duplicated Port type; clearly the most important aspect :-)
03:15:37 <elliott> frerich: But there's actually no "if" on the inside there.
03:15:42 <elliott> It's guards, which IMHO are the nicer solution here.
03:15:43 <quicksilver> not having to name 'parseResult' is nice
03:16:02 <elliott> Admittedly if would not be so abhorrent either, but I think this is nicer; keeps indentation down and makes it more "line-based" IMHO.
03:16:04 <frerich> elliott: Oh yes, not in yours, I was thinking of what quicksilver wrote ("although with only two guards I think if/then/else is fine too")
03:16:12 <elliott> frerich: Right.
03:16:50 <frerich> but yes, I see that your version is much nicer. I tried to use pattern matching instead of 'fst . head' but I couldn't figure out how to rewrite the function like that. :-}
03:17:11 <elliott> case is really nice :-)
03:17:28 <frerich> And using guards with case is not something I did before either, that's a nice trick. If I have a 'if' and I deconstruct something shortly before just to check that in the if, then maybe I want to use case with pattern matching.
03:17:53 <elliott> IMO, deconstruction in general suggests something is a bit odd.
03:17:59 <elliott> As in, through functions.
03:19:04 <cvic_> "How to avoid Haskell code smell" or "Haskell Refactoring"  (yeah, better title)
03:19:13 <cvic_> I'd read that.
03:19:21 <frerich> A small side note: do people really not put a space after a comma in Haskell types? As in "(Int,String)"?
03:19:36 <frerich> I always put a space there due to ar eflex, but then remove it again because nobody else seems to do that :)
03:20:05 <cvic_> It's shorter without the space
03:20:19 <whald> frerich: the space makes it easier to the (my) eye, i *love* it :-)
03:20:34 <cvic_> I always put it, because I'm a newbie Haskeller
03:20:36 <frerich> Well, yeah. I'm not going to get dragged into *why* a space makes sense (or not), I just want to know what's common (or if both are really common)
03:20:47 * cvic_ shrugs 
03:21:39 <quicksilver> elliott: actually I disagree. Deconstruction through functions is fine.
03:21:48 <quicksilver> elliott: it's better to use 'foldr' than manually case on lists.
03:21:51 <quicksilver> (if a foldr is what you want)
03:21:52 <elliott> I said it's a sign something is odd, not proof
03:21:55 <dcoutts> whald: I doubt much attention has been paid to making the unbox instances small/simple
03:21:57 <elliott> Sure, foldr is fine
03:22:02 <elliott> Something like fst/snd/tail makes me worry a bit
03:22:22 <quicksilver> in general, deconstruction through functions is better, especially with complex datatypes, and may be required for abstract data types.
03:22:29 <elliott> frerich: I think the space is ubiquitous when a type involved is more than one word.
03:22:37 <quicksilver> however, fst/snd/head are indeed code smell.
03:22:39 <elliott> frerich: And rarer perhaps when it's a short name.
03:22:39 <quicksilver> especially head.
03:22:42 <cvic_> What's deconstruction?
03:22:44 <quicksilver> (tail not so much)
03:22:56 <elliott> frerich: But you can just do whatever, I think the Unicode explosion will be much more confusing ;-)
03:23:06 <whald> dcoutts: so i'll just continue doing it this way, thanks for having a look
03:23:11 <frerich> quicksilver: "fst/snd/head are idneed code smell" is a really useful remark, I'll keep that in mind.
03:23:19 <elliott> cvic_: going from a value to its primitive constituents, for some value of all those words
03:23:23 <quicksilver> frerich: I put spaces around -> but never around ,. I can't explain why, I don't think.
03:23:30 <elliott> cvic_: fst and snd deconstruct tuples; head and tail and listToMaybe deconstruct lists
03:23:33 <cvic_> Ah, got it
03:23:49 <elliott> cvic_: things like foldr, maybe, either are more folds than deconstructions, even though they're roughly equivalent in the latter two cases
03:24:06 <quicksilver> > map (either length (+3)) [Left "foo", Right 8, Left "xxxxx"]
03:24:07 <lambdabot>   [3,11,5]
03:24:17 <frerich> fst and snd deconstruct tuples? Really? I thought deconstructing involves the constructor (say: in pattern matching)
03:24:25 <quicksilver> ^^ elliott very artificial example, but I'd rather use "either" than a case match
03:24:37 <elliott> quicksilver: yeah, like I said, those are more folds to my eye than deconstruction
03:24:47 <elliott> quicksilver: which makes little sense, but it's how I see it :)
03:24:59 <elliott> it's when types are inductive that it starts being problematic, I think
03:25:35 <frerich> elliott: Thanks for making me aware of the Network module, I suspect there are more types in there I'm duplicating right now. :-)
03:25:39 <mm_freak> if someone is remembering the 'forall' question i asked yesterday…  it makes a lot more sense, when you use the function arrow in prefix notation
03:25:49 <elliott> frerich: How are you writing an IRC client without Network? FFI? :-P
03:26:04 <quicksilver> elliott: I think the partiality is the real warning arrow, not using deconstructor functions.
03:26:14 <elliott> quicksilver: yeah -- still, fst/snd aren't partial
03:26:16 <quicksilver> elliott: that's why head is bad but foldr is good.
03:26:22 <quicksilver> elliott: true. tuples are just odd.
03:26:26 <frerich> elliott: Well actually, the 'core' functions are all undefined yet. :-}
03:26:33 <elliott> maybe it's like: if there's /more than one piece of data/ you can extract, then deconstruction functions are a smell
03:26:35 <frerich> elliott: I only played with parsing IRC messages and getopt yet.
03:26:38 <elliott> because they're separated in location of code
03:31:43 <absence> is there a "the" frp library, which is where most activity is going on, etc? from the outside it looks like a tangled mess of forked and abandoned libraries :) (i realise frp is an ongoing research topic)
03:32:33 <elliott> reactive-banana is unforked to my knowledge ;-) but it's based around plugging into existing event-based gui frameworks and doesn't attempt to be strong on the properties or be innovative or anything. netwire looks cool, it's arrow-based, but I have no experience with it, ask mm_freak I guess :P
03:33:42 <absence> elliott: thanks :) so the banana one is mainly for guis?
03:34:06 <elliott> yeah, at least that is the original design goal; I think it's applicable for games etc. too but I haven't yet proved that to myself yet :-)
03:34:15 <mm_freak> absence: i'm working actively on the netwire library and use it in production…  reactive-banana is also actively developed
03:34:17 <elliott> well, there is the wxAsteroids example
03:34:58 <erus`> is there a learn yourself a arrows tutorial?
03:35:40 <Hex__> nick Hexx
03:35:43 <mm_freak> absence: while reactive-banana builds on established methods netwire has more of an experimental, innovative flavour
03:36:52 <mm_freak> for GUIs you should definitely go with reactive-banana, as there is already GUI code built using it…  for applications like games, network programs and others you might be interested in netwire
03:37:01 <absence> interesting :)
03:37:15 <gienah> erus`: there's a chapter in the "Fun of Programming", a chapter in the Haskell wikibook, and a section in a masters thesis on hxt
03:37:18 <absence> yes, i'm mostly interested in non-gui applications
03:37:28 <absence> the yampa synth example was inspiring
03:38:15 <mm_freak> absence: i don't know how reactive-banana works or how to learn it…  to understand netwire you need to understand the automaton arrow
03:39:58 <gienah> @google "A Cookbook for the Haskell XML Toolbox with Examples for Processing" thesis
03:40:00 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/cookbook/doc/thesis.pdf
03:40:00 <lambdabot> Title: A Cookbook for the Haskell XML Toolbox with Examples for Processing RDF Document ...
03:44:34 <absence> mm_freak: if that's the same arrow as in yampa, i should be ok
03:46:13 <dalaing_home> erus`: I found some of the links at the end of this http://www.haskell.org/haskellwiki/Arrow useful
03:46:38 <absence> another question: is it possible to map/traverse over e.g. the rows of a 2d repa array?
03:47:10 <dalaing_home> erus`: "programming with arrows" and the ross patterson link in particular - although I'm still relatively new to them
03:48:16 <elliott> mm_freak: heh, that page has your arrow parsers
03:55:35 * hackagebot blaze-builder-enumerator 0.2.0.3 - Enumeratees for the incremental conversion of builders to  bytestrings.  http://hackage.haskell.org/package/blaze-builder-enumerator-0.2.0.3 (SimonMeier)
04:00:47 <bfig_> Cale, hey, i'me seeing http://www.haskell.org/arrows/, i was wondering which tool did you use to make the diagrams? :)
04:07:07 <Cale> bfig_: inkscape
04:07:39 <bfig_> cool :)
04:07:50 <bfig_> gonna dl and try it =)
04:08:08 <Cale> yeah, it's quite nice
04:13:08 * Eduard_Munteanu usually goes with Dia for diagrams
04:13:20 <Eduard_Munteanu> But I guess I should have a look at inkscape as well.
04:18:32 <bfig_> g2g, see you around
04:21:55 <pt114> monad question...
04:22:49 <pt114> why would i use "liftM sin (Just 0)" when i can just do "Just (sin 0)" and get the same result: "Just 0.0"
04:24:03 <pt114> anyone out there?
04:24:32 <Cale> pt114: You wouldn't :)
04:24:50 <pt114> what is the difference?
04:24:51 <Cale> pt114: But consider something like  liftM sin x  where x :: Maybe Double
04:25:07 <Cale> Now you can't just reach in there and apply sin to what might be Just 0
04:25:18 <Cale> and that's what liftM does for you then
04:25:35 * hackagebot BiobaseFR3D 0.2.2.0 - Importer for FR3D resources  http://hackage.haskell.org/package/BiobaseFR3D-0.2.2.0 (ChristianHoener)
04:25:57 <Cale> yeah?
04:26:15 <pt114> hmm, still don't get it
04:26:16 <Cale> of course, it's always possible to pattern match:
04:26:31 <Cale> case x of Nothing -> Nothing; Just x -> Just (sin x)
04:26:42 <Cale> but that gets tedious if you have to do it more than a few times
04:27:11 <Cale> That's the pattern which liftM/fmap is capturing in the case of Maybe
04:27:51 <pt114> ok now i seem to see the point
04:31:36 <sipa> pt114: the point is simply that it is more general - monads don't add anything, they just generalize an existing pattern
04:32:29 <pt114> yes it sure does
04:33:25 <mm_freak> absence: it's the same basic idea, but the internal representation is different, because netwire has some features yampa doesn't have, notably signal inhibition…  it also takes a monad argument
04:33:44 <mm_freak> absence: yampa has this basic idea:  newtype SF a b = SF (Time -> a -> (b, SF a b))
04:34:17 <mm_freak> netwire has this:  newtype Wire m a b = Wire (WireState -> a -> m (Either SomeException b, Wire m a b))
04:34:48 <mm_freak> the Either is what gives you signal inhibition and based on that ArrowZero and ArrowPlus instances
04:35:32 <mm_freak> elliott: my parser arrow is different
04:35:35 * hackagebot Grempa 0.2.0 - Embedded grammar DSL and LALR parser generator  http://hackage.haskell.org/package/Grempa-0.2.0 (OlleFredriksson)
04:36:12 <mm_freak> it's more like an iteratee than a state arrow
04:36:17 <elliott> mm_freak: ah
04:42:39 <absence> mm_freak: i see. that looks a lot more flexible, though i'm too inexperienced with arrows and frp to immediately think of a use case. they seem like a superset of the yampa arrows though, so i can start slow :)
04:44:40 <absence> is it possible to map/traverse over e.g. the rows of a 2d repa array?
05:00:22 <sanjoyd> Are the template haskell expressions "run" during program compile time?
05:00:37 <int-e> yes.
05:00:42 <sanjoyd> Thanks!
05:00:55 <int-e> if you don't like "run", "evaluate" is a suitable replacement.
05:01:25 <mm_freak> absence: they are not really a superset…  the Either replaces yampa's switches
05:01:42 <mm_freak> and it completely removes the need for a specific event type
05:02:25 <int-e> (but "run" is appropriate since they are evaluated in the Q monad ... with access to IO even.)
05:02:26 <mm_freak> to require a certain event you can now just say:  onWhateverEvent -< ()
05:02:35 <mm_freak> or:  require_ -< x > 30
05:02:46 <mm_freak> in yampa you would need to use switches
05:07:29 <absence> mm_freak: ohh, that is nice
05:15:21 <elliott> When was Control.Monad.void added?
05:18:09 <int-e> elliott: http://hackage.haskell.org/trac/ghc/ticket/3292 ... added in base-4.3, I think.
05:18:17 <elliott> ah, thanks
05:18:19 <int-e> (or ghc 7)
05:21:26 <rtharper> anyone know when the "July" release of Haskell Platform will be out?
05:21:30 <geheimdienst> i recall gwern saying how he lobbied for void to be added
05:22:14 <elliott> rtharper: maybe next July :D
05:22:55 <mm_freak> data Stream a = Chunks [a] | EndOfStream  -- is there a library defining such a type?
05:23:02 <rtharper> waah
05:23:16 <rtharper> enumerator?
05:23:23 <mm_freak> rtharper: less special purpose
05:23:32 <mm_freak> just a generic library for possibly finite streams
05:23:45 <geheimdienst> mm_freak: i thought that was the typical iteratee thing. there's several different packages on hackage. istr enumerator is newer than iteratee
05:23:58 <rtharper> mm_freak: what is too special purpose Enumerator, the fact that it uses Iteratee?
05:24:37 <mm_freak> i'm looking for a library that specifically only defines a stream type with the corresponding instances
05:24:42 <mm_freak> no iteratees or anything
05:24:48 <rtharper> ah, I would just do that yourself, then
05:24:53 <mm_freak> alright
05:26:12 <Peaker> I installed the current Haskell Platform, with cabal-install ver 0.10.2 (1.10.1.0 Cabal ver).   and cabal install -v xmonad-extras is not verbose like I thought it used to be -- it doesn't tell me why it chose certain package versions
05:26:24 <Peaker> wasn't it "cabal install -v" to get a detailed plan?
05:27:05 <Peaker> oh, it's now -v3
05:35:36 * hackagebot CC-delcont-ref-tf 0.1.0.0 - A monad transformers for multi-prompt delimited control using refercence cells  http://hackage.haskell.org/package/CC-delcont-ref-tf-0.1.0.0 (KidoTakahiro)
05:58:31 <ao> hey all, i have quick question
05:58:47 <ao> i'm using (fromList . toList) to convert Data.Vector.Unboxed to Data.Vector.Storable but it just doesn't feel right.. any ideas?
05:58:47 <cvic_> shoot
06:00:58 <EvanR> ao: why not
06:01:18 <EvanR> its just like using a for loop in C or php or something
06:03:19 <ao> ok thanks then
06:03:43 <EvanR> hm maybe not, these vectors might be weird animals
06:03:55 <EvanR> never used them
06:05:46 <ao> just that i thought unboxed vectores are stored internally in continuous array and storables are "pinned" pointers there was a way to convert between them without copying or converting to lists first
06:06:00 <mm_freak> ao: there is a converter function for vectors
06:06:28 <mm_freak> ao: see the 'convert' function in (for example) Data.Vector.Unboxed
06:06:46 <mm_freak> that should give you a fast copying conversion
06:07:02 <mm_freak> i don't think it is able to pin right away, though
06:07:32 <ao> facepalm.. was looking at 0.5 docs :)
06:07:38 <ao> thanks
06:07:42 <mm_freak> you're welcome
06:09:39 <absence> if i have a repa array (z :. y :. x :. c), can i map/traverse over x and y, and for each index operate on a slice with c?
06:09:43 <adrake> I feel a little dirty writing WriterT w (ReaderT r (..)) a
06:09:53 <rtharper> adrake: you should
06:10:01 <rtharper> adrake: That's not to say I have a better idea
06:10:13 <adrake> rtharper: then we're in the same boat :P
06:10:34 <hpc> adrake: you should take a look at RWS sometime
06:10:36 <rtharper> adrake: monad transformers are dirty in general
06:13:51 <adrake> hpc: is that for performance reasons, or to get rid of the giant monad stack of doom, both, or some other reason?
06:16:05 <adrake> ooh, and Data.Accessor.Monad.Trans.RWS exists
06:18:15 <hpc> adrake: in general it's just a lot easier
06:18:29 <hpc> im not entirely qualified to talk about performance
06:18:40 <hpc> but i would expect it to be not slower
06:19:12 <adrake> yeah, I can't imagine it'd be slower
06:19:23 <adrake> but it saves a bunch of useless code
06:20:07 <geheimdienst> so ... no way of attaching a "where" to a lambda?
06:20:37 * hackagebot CC-delcont-ref-tf 0.1.0.1 - A monad transformers for multi-prompt delimited control using refercence cells  http://hackage.haskell.org/package/CC-delcont-ref-tf-0.1.0.1 (KidoTakahiro)
06:20:46 <ccasin> geheimdienst: you can use let instead
06:21:34 <byorgey> geheimdienst: 'where' only attaches to declarations
06:21:39 <byorgey> not expressions
06:22:24 <amtal> Are there any packages/programs that use Netwire I can use as examples?
06:23:03 <geheimdienst> ok thanks guys. got that straight now.
06:25:37 * hackagebot CC-delcont-ref-tf 0.1.0.2 - A monad transformers for multi-prompt delimited control using refercence cells  http://hackage.haskell.org/package/CC-delcont-ref-tf-0.1.0.2 (KidoTakahiro)
06:31:03 <mm_freak> amtal: webwire is based on netwire, but other than that there are currently no examples online, i think…  except someone else has written some
06:31:31 <mm_freak> there is a wiki page about netwire, which is partly outdated
06:31:39 <mm_freak> but it should give you the idea
06:32:23 <absence> is there a more elegant way to express this with repa, or is that the right way? fromFunction (Z :. 512 :. 512 :. 512) \(Z :. y :. x :. z) -> fromList (Z :. 512) (getZ x y) ! (Z :. z)
06:35:39 <khs> can anyone elaborate on this?
06:35:42 <khs> main: panic! (the 'impossible' happened)
06:35:42 <khs>   (GHC version 7.0.3 for x86_64-unknown-linux):
06:35:42 <khs> 	Could not find module `Module':
06:35:42 <khs>   It is a member of the hidden package `ghc-7.0.3'.
06:35:42 <khs>   Use -v to see a list of the files searched for.
06:36:10 <Axman6> why did you call a module Module?
06:36:25 <Axman6> well, i assume that's what up, i probably shouldn't do that
06:36:41 <khs> I did not, ghc did
06:36:51 <Axman6> what do you mean?
06:36:58 <khs> I'm using the ghc api
06:37:00 <byorgey> one of the modules in the ghc package is called Module
06:37:12 <byorgey> that's certainly not the reason for the panic
06:37:17 <Eduard_Munteanu> You probably need -package ghc
06:37:31 <khs> compiled it using that, get this error when running it
06:38:14 <byorgey> khs: well, it is definitly a GHC bug
06:38:20 <byorgey> that may or may not make you feel any better
06:38:41 <byorgey> khs: have you looked on the GHC bug tracker to see if anything similar has already been reported?
06:39:08 <khs> no, I haven't
06:39:14 <khs> I'm very new to haskell
06:39:35 <elliott> very new and using ghc api?
06:40:16 <khs> yes, part of project for my masters
06:40:37 * hackagebot fst 0.9.0.1 - Finite state transducers  http://hackage.haskell.org/package/fst-0.9.0.1 (ThomasHallgren)
06:40:40 <elliott> heh, ok
06:55:28 <balor> Is there some idea of a /standard/ way of presenting Haskell in LaTeX documents?
06:55:37 <dmwit> lhs2tex?
06:56:27 <dmwit> This is going to make me sound stupid, I'm sure, but what do I do in Parsec if I have a list of tokens and I want to accept any one of them next?
06:56:45 <EvanR-work> the great thing about standards
06:56:53 <mauke> choice
06:57:26 <dmwit> choice takes a list of parsers, not a list of tokens.
06:57:52 <EvanR-work> the most basic parser is the one that accepts a single token
06:58:01 <dmwit> Yes. How do I construct it?
07:00:05 <EvanR-work> are you actually parsing a token stream or a character stream
07:00:12 <dmwit> I'm actually parsing a token stream.
07:00:20 <dmwit> The tokens are String, not Char.
07:00:37 * hackagebot scyther-proof 0.3.1 - Automatic generation of Isabelle/HOL correctness proofs for security protocols.  http://hackage.haskell.org/package/scyther-proof-0.3.1 (SimonMeier)
07:00:43 <mononofu> does anyone know why this works: (round $ (length heading) / 2 )
07:00:51 <dmwit> mononofu: It doesn't.
07:00:52 <mononofu> while this doesn't: (floor $ (length heading) / 2.0 )
07:01:03 <mononofu> ah
07:01:05 <mononofu> interesting xD
07:01:05 <dmwit> > round $ length [3,4] / 2 -- type error
07:01:06 <lambdabot>   No instance for (GHC.Real.RealFrac GHC.Types.Int)
07:01:07 <lambdabot>    arising from a use of ...
07:01:19 <dmwit> > round $ genericLength [3, 4] / 2
07:01:20 <lambdabot>   1
07:01:21 <mononofu> yeah, I get that error too, but only for the second one
07:01:23 <mauke> dmwit: I guess then you get to have fun with 'token'
07:01:34 <dmwit> mauke: Where's that?
07:01:35 <EvanR-work> dmwit: token, tokenPrim... maybe
07:01:44 <mauke> Text.Parsec.Prim
07:01:50 <byorgey> dmwit: you can look at the implementation of 'satisfy' in Text.Parsec.Char
07:01:54 <byorgey> it uses tokenPrim
07:02:00 <mononofu> dmwit: ah, yes, that fixed it
07:02:00 <dmwit> that type looks horrible
07:02:06 * byorgey agrees
07:02:08 <mononofu> dmwit: thanks :)
07:02:17 <byorgey> why there isn't something to do this in Parsec already I have no idea
07:02:18 <EvanR-work> looks like parsec is set up to be most convenient on character streams
07:02:18 <adimit> Iteratee question: Given custom data type X, and an i :: Iteratee ByteString m X, and a monadic action x :: X -> IO (), how do I compose i and x, so that for every X that comes out of i, x gets executed?
07:02:34 <EvanR-work> when the task of parsing tokens is conceptually simpler
07:02:40 <dmwit> Forget it. I was going to point out how easy a particular parsing problem was with Parsec, but this right here means it's not easy for a non-initiate.
07:03:22 <adimit> doesn't work with I.mapM_, I.mapChunksM_, which would be the obvious ideas, because X has no NullPoint instance. I don't care what a NullPoint instance is, I don't think I need to know what it is either.
07:04:00 <Peaker> #xmonad seems very idle -- anyone knows how to set inactive border color?
07:04:42 <majoh> Peaker: normalBorderColor
07:05:13 <majoh> (focusedBorderColor for the focused window border)
07:06:03 <EvanR-work> dmwit: if you find or know of a lib which is good for arbitrary token streams, let me know ;)
07:07:12 <jweofijm> @pl \x y z -> if x then y else z
07:07:13 <lambdabot> if'
07:08:52 <mm_freak> adimit: liftIO
07:09:06 <mm_freak> adimit: assuming MonadIO m
07:09:28 <mm_freak> liftIO :: MonadIO m => IO a -> m a
07:09:37 <szerf> i have a problem with cabal , i want to install scion to use eclipse as IDE with fp plugin but he refuse
07:09:39 <mm_freak> and there is:  MonadIO m => MonadIO (Iteratee a m)
07:09:53 <hpc> :t lift -- adimit: a more general function, for when you aren't just dealing with IO
07:09:54 <lambdabot>     Ambiguous occurrence `lift'
07:09:54 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
07:09:54 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
07:10:12 <hpc> :t Control.Monad.Error.lift -- rather
07:10:13 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
07:10:51 <adimit> mm_freak, hpc, second, I'll need to first kill ghc before I can try it out. monads and mtl are competing for the lift/liftIO import
07:13:08 <szerf> so , any help ?
07:14:11 <adimit> mm_freak: … I'm not exactly sure how to use liftIO here. I can lift neither x nor i, obviously.
07:15:36 <adimit> and I.mapChunksM_ (liftIO . x) does just the same thing it did before: not compile, since X doesn't fulfil NullPoint.
07:15:44 <adimit> (X is a HashMap btw.)
07:17:01 <byorgey> szerf: what error(s) do you get?  please paste the error output somewhere like hpaste.org
07:17:18 <szerf> ok
07:17:41 <szerf> he want ghc 6.12
07:18:50 <szerf> but when i install this version he cannot install a package named bytebuffering or somthing
07:19:16 <mononofu> thanks for your advice from before, but shouldn't this work? (floor $ ((genericLength heading) + totalLen) / 2 )
07:19:47 <mononofu> i know the error disappears if i remove totalLen, but that's just 2*5 + len
07:19:59 <mononofu> and len is genericLength of some other string
07:20:12 <szerf> so i cannot install it nor to ghc 7.2 nor to ghc 6.12
07:20:38 * hackagebot arithmoi 0.1.0.1 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.1.0.1 (DanielFischer)
07:21:11 <byorgey> mononofu: what is the type of totalLen?
07:21:46 <mononofu> how can I display that? (just started learning haskell)
07:21:48 <byorgey> szerf: what do you mean, it wants ghc 6.12?  6.12 is a bit old at this point
07:21:57 <mononofu> I know I can use :t in ghci, but in a script?
07:22:05 <byorgey> :t in ghci is the only way
07:22:06 <lambdabot> parse error on input `in'
07:22:23 <szerf> yes so what can i do to install scion ?
07:22:23 <byorgey> just load your file into ghci with :load
07:22:33 <mononofu> byorgey: well, that's where I get my error ^^
07:22:36 <byorgey> szerf: it probably works on ghc 7.0
07:22:43 <szerf> no
07:22:57 <byorgey> mononofu: well, comment out whatever is giving you the error first =)
07:23:13 <byorgey> szerf: you said it doesn't work on 6.12 or 7.2.  It doesn't work with 7.0 either?
07:23:17 <mononofu> byorgey: I just did. could it have anything to do with using let .. in .. ?
07:23:33 <szerf> look at this http://hackage.haskell.org/package/scion
07:23:46 <byorgey> mononofu: it's possible you're running into the evil Monomorphism Restriction
07:24:03 <mononofu> byorgey: what's that?
07:24:13 <byorgey> szerf: also, you still have not showed us what actual error message you are getting
07:24:56 <byorgey> oh, goodness, I didn't realize scion was so out of date
07:24:58 <hpc> mononofu: with top-level definitions, stuff that "looks like values" has to be monomorphic
07:25:03 <hpc> aka, not polymophic
07:25:06 <hpc> so
07:25:07 <byorgey> all the package versions it depends on are quite old
07:25:11 <mononofu> so I have to define a type?
07:25:13 <hpc> id x = x -- this :: a -> a
07:25:21 <hpc> id = \x -> x -- this :: () -> ()
07:25:33 <byorgey> szerf: sorry, I don't know how to get it to work then
07:25:37 <hpc> indeed
07:25:44 <mauke> > groupBy (<=) [1,2,3,3,2,3,4,7,9,12]
07:25:45 <lambdabot>   [[1,2,3,3,2,3,4,7,9,12]]
07:25:47 <EvanR-work> it defaults to () ?
07:25:48 <hpc> a type signature will fix it, as will an extension that turns it off
07:26:08 <szerf> so can you suggest to me an IDE other than leksah ?
07:26:10 <hpc> EvanR-work: yes, or Int if it has a Num constraint, or String if it has an IsString constraint
07:26:22 <EvanR-work> thats pretty bad
07:26:33 <joe9> i have a .hs file and a shared library that i use in the .hs file. I can do "ghci -Wall TestCommon.hs ../../staging/libctests.so" and everything works fine. I want to put this in a script with runghc, but am not able to figure out how: http://codepad.org/NlFXvD3Q
07:26:39 <joe9> any thoughts, please?
07:26:47 <szerf> tow use in windows
07:26:52 <EvanR-work> hpc: do you recommend no monomorphism restriction extension
07:27:09 <hpc> EvanR-work: nah, you should have type signatures anyway so it doesn't really matter much
07:27:49 <mononofu> the type signature didn't really change anything
07:28:20 <mauke> :t break
07:28:21 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:30:34 <EvanR-work> :t fix
07:30:35 <lambdabot> forall a. (a -> a) -> a
07:30:53 <EvanR-work> > break . fix == id
07:30:54 <lambdabot>   Couldn't match expected type `[a]'
07:30:55 <lambdabot>         against inferred type `a -> GHC....
07:31:43 <mauke> :t fix . return
07:31:44 <lambdabot> forall a. a -> a
07:32:09 <mononofu> I should be able to have multiple definitions in one where clause, right?
07:32:14 <mauke> proposal: let's rename return to break
07:32:34 <hpc> mauke: and break to return? :D
07:32:50 <mauke> no, to div
07:32:50 <EvanR-work> then it would really confuse noobs, you think return breaks now
07:32:55 <mauke> (it's the opposite of span)
07:33:48 <EvanR-work> :t return
07:33:49 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
07:33:58 <EvanR-work> how the hell did you compose and get a -> a
07:34:09 <mauke> :t fmap fix return
07:34:10 <lambdabot> forall a. a -> a
07:34:15 <dmwit> mononofu: yes
07:34:17 <mauke> my flow is tight
07:34:22 <EvanR-work> caleskell
07:34:25 <dmwit> mononofu: Make sure they are all indented the same amount.
07:34:31 <mauke> EvanR-work: no, just haskell
07:34:40 <EvanR-work> but . isnt fmap
07:34:45 <dmwit> mononofu: Even if the first binding is on the same line as the where. =)
07:34:52 <mauke> EvanR-work: but fmap is .
07:35:09 <mononofu> dmwit: I need to indent by spaces !
07:35:13 <chra> @src .
07:35:14 <lambdabot> (f . g) x = f (g x)
07:35:14 <lambdabot> NB: In lambdabot,  (.) = fmap
07:35:30 <dmwit> mononofu: No, you don't need to. You may use tabs, if you use them consistently.
07:35:43 <EvanR-work> use tabs and youll be banished to hell
07:35:48 <dmwit> mononofu: (Actually, you may use tabs even if you use them inconsistently, so long as you treat them as padding out to eight spaces.)
07:35:58 <dmwit> EvanR-work: I disagree.
07:36:01 <dmwit> I know I'm in the minority.
07:36:12 <dmwit> But tabs for indentation/spaces for alignment has served me quite well.
07:36:12 <si14> @pl \f g x y = f (g x) (g y)
07:36:12 <mononofu> dmwit: well, that didn't really work for me, so I'll switch to spaces
07:36:13 <lambdabot> (line 1, column 10):
07:36:13 <lambdabot> unexpected "="
07:36:13 <lambdabot> expecting pattern or "->"
07:36:23 <si14> @pl \f g x y -> f (g x) (g y)
07:36:23 <lambdabot> join . ((flip . ((.) .)) .) . (.)
07:36:27 <si14> omg.
07:36:39 <EvanR-work> too close for tabs, switching to spaces
07:36:41 <dmwit> EvanR-work: (I do consider it a bug that Haskell treats tabs as padding to eight spaces, though.)
07:37:12 <EvanR-work> dmwit: mixing them sounds like a recipe for disaster
07:37:16 <kmc> i consider it a bug that Haskell accepts tabs at all
07:37:23 <mauke> @pl \f g -> f (g x) (g y)
07:37:24 <lambdabot> (`ap` ($ y)) . (. ($ x))
07:37:25 <dmwit> forall x, x spaces is not equal to a tab, x spaces is not greater than a tab, and x spaces is not less than a tab.
07:37:30 <dmwit> EvanR-work: I haven't found it so.
07:37:43 <kmc> also EvanR-work++
07:37:59 <si14> mauke: still quite scary, though.
07:38:07 <elliott> block languages like C etc. can be reasonably indented with tabs
07:38:14 <elliott> alignment-based languages like Haskell not so much
07:38:14 <dmwit> EvanR-work: Perhaps your text editor is insufficient. =)
07:38:16 <mononofu> I still don't get it why this doesn't work :( http://pastebin.com/29MM4DXW
07:38:18 <mauke> The paste 29MM4DXW has been copied to http://hpaste.org/52796
07:38:20 <KitB> Is anyone in here experienced with Graphics.Rendering.Chart ?
07:38:21 <mononofu> errors: http://pastebin.com/wdhYEDu3
07:38:23 <mauke> The paste wdhYEDu3 has been copied to http://hpaste.org/52797
07:38:26 <elliott> because whether to use space-alignment or tab-indentation is very ambiguous in each case
07:38:28 <mm_freak> adimit: perhaps i don't understand what you are trying to do
07:38:36 <Peaker> dmwit: the problem is that most text editors don't do tabs-for-all-but-alignment well, and in collaborative environments you'll end up with people that mess it up
07:38:50 <Peaker> dmwit: and the benefit of viewer choosing indent size is miniscule
07:38:53 <mauke> mononofu: you misspelled separator
07:39:01 <mm_freak> adimit: to embed 'm' actions into an 'Iteratee a m' you either write the iteratee in raw, or you use 'lift' with the monadic interface
07:39:04 <EvanR-work> dmwit: using some strategy that only works in mondodimensional-emacs is kind of missing the point of whitespace discipline
07:39:09 <mononofu> mauke: whooops, thanks, english is not my native language ^^
07:39:09 <mauke> mononofu: you're trying to use / on an Int
07:39:14 <jeffcutsinger> If any text editor ever got tabs correct I'd use them.
07:39:18 <mm_freak> adimit: if 'm' is a transformer stack with IO at the bottom, you can lift IO actions using liftIO
07:39:18 <Peaker> dmwit: whereas the disadvantage of having it always get messed up eventually is pretty huge and causes unnecessary rcs conflicts, too, when people are tempted to fix these issues
07:39:28 <KitB> jeffcutsinger: What counts as correct tabs?
07:39:34 <dmwit> mononofu: len is an Int; fix it.
07:39:35 <kmc> i think it's pretty much impossible to get tabs right in plain text
07:39:40 <mm_freak> adimit: generally it's good style to use liftIO for IO actions, even when m = IO
07:39:41 <mauke> dmwit: it should be an Int
07:39:43 <mauke> the problem is /
07:39:50 <EvanR-work> dmwit: by the same logic, if youre text editor was so all-powerful, you could do 'nice things' with just spaces
07:39:52 <kmc> what you want are identified alignment markers
07:39:54 <elliott> The real solution is to golf all our code and have our editors indent it with elastic tabs.
07:39:57 <elliott> FLAMEWAR OVER everyone go home I win.
07:39:58 <kmc> *nod*
07:40:04 <elliott> See, kmc agrees.
07:40:07 <dmwit> mauke: If he really wants rounding, div is not the right solution. fromIntegral is.
07:40:12 <jeffcutsinger> The text editor should never ever assume that tabs line up with anything.
07:40:14 <mononofu> dmwit: wait, I can divide Ints using / ?
07:40:15 <mauke> dmwit: he doesn't
07:40:26 <mm_freak> mononofu: no
07:40:28 <jeffcutsinger> And they always do assume that.
07:40:32 <EvanR-work> jeffcutsinger: i dont know how you stop it from sometimes showing the illusion that they do
07:40:35 <dmwit> mononofu: No, you can't.
07:40:38 <mononofu> mm_freak: but it works in ghci?
07:40:42 <kmc> another approach for Haskell would be to allow tabs and spaces but treat n spaces as incomparable to k tabs
07:40:46 <mauke> mononofu: no, it doesn't
07:40:52 <mm_freak> mononofu: if you use number literals, you are not dividing Int
07:41:02 <mononofu> mauke: implicit conversion to floating point?
07:41:03 <mm_freak> mononofu: you are dividing Num a => a, which is just defaulted to Double
07:41:04 <kmc> so it's an error if the "width of a tab" would ever affect layout
07:41:08 <mauke> mononofu: no
07:41:13 <dmwit> kmc: That is my preferred solution.
07:41:38 <mm_freak> mononofu: try this:  (3 :: Int) / 4
07:41:44 <jeffcutsinger> At work where the style guidelines are to use tabs I turn visible whitespace on, and make the marker color very "mild". Almost unnoticeable. But just noticeable enough to see when they get mixed up.
07:42:12 <mononofu> ahh
07:42:21 <mononofu> I get it now, thanks everybody :D
07:42:35 <KitB> Why don't you just use an editor which can convert tabs to spaces while editing then back to tabs when saving?
07:42:54 <mauke> KitB: what would that achieve?
07:43:02 <KitB> mauke: Not sure
07:43:02 <mm_freak> KitB: doesn't solve the interoperability problem, unless you have an indentation standard, which makes it unambiguous
07:43:07 <KitB> I'm not entirely concentrating
07:43:09 <mauke> KitB: it would break my code
07:43:20 <EvanR-work> it would put tabs in source code for no reason
07:43:25 <EvanR-work> if everyone had that editor
07:43:31 <elliott> Did you not listen to my automatic elastic tab golfing solution I can't believe there is even disagreement in the world any more.
07:43:35 <elliott> It should have ended all wars with its genius.
07:43:43 <KitB> Specifically for him his work has style guidelines requiring tabs
07:43:57 <EvanR-work> his guidelines are stupid
07:44:05 <KitB> I agree, personally
07:44:08 <KitB> But he has to follow them
07:44:22 <dmwit> Converting spaces to tabs intelligently is not possible.
07:44:27 <Cale> mononofu: It is a sort of funny concession to the fact that numeric literals are all polymorphic in Haskell. Numeric defaulting exists which (by default, heh) will choose the first thing from (Integer, Double) which satisfies the typeclass constraints, provided that numeric constraints are involved, and no non-Prelude classes are involved.
07:44:38 <EvanR-work> wrong, you can quit your job, move to another country, and invade poland
07:45:29 <mm_freak> an elastic tabs mode for haskell would be great…  then i would feel safer using unicode arrows and a variable width font
07:45:31 <mononofu> Cale: that's actually quite cool, I just confused it with implicit conversion / casting :)
07:45:46 <dmwit> mononofu: There is no implicit casting.
07:45:56 <mononofu> dmwit: exactly ^^
07:46:01 <EvanR-work> tabs is an anachronistic space optimization solution for back when source code had to fit in a total of 16k of disk space
07:46:27 <dmwit> Tabs may have started as a space optimization, but now they are a configuration optimization.
07:46:35 <quicksilver> I think the whole idea that tabs might be a space optimisation is pure fiction
07:46:45 <quicksilver> tabs are a way to line up data in columns
07:46:47 <EvanR-work> if the editor can magically do that sort of thing, it doesnt need tabs
07:46:49 <elliott> I can't believe we're actually having a tabs-vs-spaces war in 2011.
07:47:01 <kmc> it's a rather tame war
07:47:09 <elliott> It's as tame as it is unconvincing for everyone involved :P
07:47:10 <kmc> 'morning coppro
07:47:13 <kmc> er copumpkin too
07:47:16 <elliott> copprumpkin
07:47:22 <copumpkin> ?
07:47:25 <copumpkin> oh hai!
07:47:35 <Cale> elliott: Well, everyone here should already be convinced in the direction of spaces anyway...
07:47:43 <EvanR-work> quicksilver: a pretty bad solution to that
07:47:49 <elliott> Cale: Except for the three people arguing not which is kind of the entire reason it's happening.
07:47:53 <Cale> heh
07:48:10 * elliott might be the fourth person if the language wasn't Haskell.
07:48:41 <Cale> I think that the Haskell compiler should treat tabs as a lexical error.
07:48:43 <dmwit> I keep fighting the good fight for tabs, but it's an uphill battle against some nasty misconceptions. And I don't have a whiteboard. =/
07:49:03 <dmwit> Cale: And I think the compiler should treat tabs as incomparable to spaces (but legal).
07:49:30 <EvanR-work> no text editor takes tabs as a column liner-upper guide
07:49:32 <mauke> dmwit: that will be confusing as long as tabs look exactly like spaces
07:49:37 <Cale> Actually, if I could remove support for tabs from all text editors, I would. :)
07:49:50 <quicksilver> dmwit: I'm quite in favour of appropriately implemented smart tabs. But it doesn't keep me up at night.
07:49:53 <dmwit> mauke: Luckily, tabs need not look exactly like spaces!
07:50:11 <mauke> dmwit: then why use '\9' at all?
07:50:16 <mauke> choose some other character
07:50:25 <joe9> has anyone seen this error: lexical error at character '\DEL', everything works fine with ghci but not with runghc. http://codepad.org/3qNo0eQL
07:50:29 <dmwit> mauke: a tab by any other name...
07:50:44 <fryguybob> Cale++
07:51:02 <Peaker> dmwit: what benefit do you get from tabs? There are huge disadvantages...
07:51:12 <Cale> joe9: It looks like ghc is trying to parse a .so file as Haskell source?
07:51:25 * roconnor_ use ANSI escape codes in his text files to highlight bits of source code
07:51:31 <osfameron> tabs feel so right in theory...
07:51:32 <Peaker> dmwit: Getting a fixed indent width is a small price to pay to avoid tab hell
07:51:35 <joe9> oh, ok.
07:51:51 <dmwit> Peaker: I disagree. There need not be hell, and you get a variable indent width.
07:51:55 <EvanR-work> osfameron: not to me
07:52:24 <EvanR-work> if its for 'tab'les, then in theory you should be working on a table, spreadsheet or something, not a text file
07:52:29 <dmwit> Other people have terrible taste in indent width.
07:52:40 <Peaker> dmwit: in theory, there need not be hell, in practice, not all text editors support non-hell-tabs, and if you collaborate with other developers, some are bound to use these editors
07:52:51 <elliott> I think that tabs should be used, but every indentation if eight spaces of greater should be expanded to spaces; tabs will be used at width seven, and indentation shall be done to pi levels (you round pi after multiplying it by the indentation depth).
07:52:54 <Cale> Indent width is a stupid thing to care about. What matters is whether or not and how things line up vertically.
07:52:54 <EvanR-work> dmwit: to get variable indent width, you dont need tab characters
07:53:01 <Peaker> dmwit: If you don't collaborate with people that have other editor preferences, then you're lucky :)
07:53:04 <elliott> Also, we should embed backspace characters in comments to signify obsolete notes.
07:53:05 <osfameron> EvanR-work: it seems like they'd map to nesting level, which is nice and elegant.
07:53:18 <osfameron> but yes, lining up vertically is much more important
07:53:21 <elliott> I must be getting close to a position so absurd everyone will leap to disagree with me.
07:53:30 <dmwit> EvanR-work: Okay, I'm intrigued. What's your idea?
07:53:36 <EvanR-work> osfameron: after 11 levels of php indentation i question the sanity of anyone who calls it elegant
07:53:42 <elliott> dmwit: Sounds like elastic tabs.
07:53:54 <Peaker> dmwit: I have been suffering greatly from dumb revision control conflicts and horrors from attempting to fix space/tabs' mixup that "need not" be there, but are just impossible to iron out completely (people tinker with new editors and mess it up all the time)
07:53:55 * Cale chooses essentially random indent widths, and just ensures that everything lines up.
07:53:55 <dmwit> Elastic tabs require new coding effort. My proposal doesn't.
07:54:16 <dmwit> Also, it's elastic tabstops, not elastic tabs.
07:54:25 <elliott> dmwit: Sure, your proposal requires coercing dumb editors to do the right thing.
07:54:31 <jeffcutsinger> elliott, I agree strongly, except I will fight to the death to ensure the use of e, not pi.
07:54:31 <dmwit> hm?
07:54:35 <elliott> dmwit: Emacs does the definite wrong thing by default if you let it use tabs f.e.
07:54:41 <elliott> dmwit: by treating it as compression of a space
07:54:42 <dmwit> My dumb editor does the right thing already.
07:54:47 <Peaker> elliott: as well as vim
07:54:49 <mononofu> can't I use putStr in map ?
07:54:52 <elliott> dmwit: Lemme guess, you indent by hand?
07:54:56 <Cale> mononofu: You can...
07:54:57 <dmwit> No, I :set ai
07:54:58 <joe9> cale, any thoughts on how I can tell through runghc that it is a shared library?
07:55:00 <elliott> jeffcutsinger: Can we arrive at a compromise?
07:55:01 <joe9> the docs suggest that .so is read as a shared library.
07:55:03 <joe9> but, something seems to be off.
07:55:04 <Cale> mononofu: You'll get a list of IO actions as the result
07:55:06 <elliott> jeffcutsinger: Mean of e and pi.
07:55:17 * EvanR-work goes on the space warpath
07:55:28 <jeffcutsinger> elliott, deal.
07:55:36 <mononofu> Cale: so "main = do map putStr myList" should work?
07:55:40 * hackagebot NanoProlog 0.2.3 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.2.3 (DoaitseSwierstra)
07:55:40 <elliott> jeffcutsinger: Excellent. Now to get it onto hackage.
07:55:40 <byorgey> Does anyone know if Daniel Fischer hangs out in here?
07:55:48 <elliott> mononofu: main must be an IO action, not a list of IO actions
07:55:51 <Cale> mononofu: If you want to run each of them, then you can apply sequence to the resulting list to combine them into a single action. Or, you can just use mapM, which is the same :)
07:55:58 <danr> mononofu: mapM_ putStrLn myList
07:55:59 <geheimdienst> byorgey: i thought he was dafis
07:56:01 <dafis> byorgey: I do
07:56:09 <dafis> geheimdienst: I am
07:56:20 <byorgey> dafis: aha! I never made the connection
07:56:22 <mononofu> yes, it works :D
07:56:23 <byorgey> dafis++
07:56:24 <Cale> mononofu: It won't work because as elliott pointed out, main has to be an IO action
07:56:27 <byorgey> for your arithmoi package
07:56:33 <mononofu> you guys are great, thank you very much :)
07:57:04 <byorgey> dafis: I have wanted a simple package with basic number theory functions for a long time, but lacked the expertise to make an efficient one myself
07:57:05 <elliott> jeffcutsinger: Aww, this rounds upsettingly close to just using integral indentation width.
07:57:18 <dafis> byorgey: nice, glad you like it, any suggestions for improvement? It's less of a hassle to change while it's still new
07:57:26 <elliott> jeffcutsinger: How about this scheme proposed long ago: "i use dynamic indentation, i indent lines k times, if they are used O(n^k) times during a run of the program"
07:57:31 <dmwit> > (exp 1 + pi) / 2
07:57:32 <lambdabot>   2.929937241024419
07:57:34 <byorgey> dafis: I'm just trying it out now, if I have suggestions I will let you know
07:57:44 <elliott> Might require some GHC hacking to get it to like that.
07:57:52 <Peaker> dmwit: in your struggle to improve a relatively unimportant thing (configurable indent size), along with your ignoring of the editor choices of others -- you end up losing something extremely important and going into tab hell
07:58:07 <EvanR-work> epicycles
07:58:15 <Peaker> \t must die...
07:58:30 <EvanR-work> dmwit probably likes vertical tabs too!
07:58:36 <dmwit> heh
07:58:44 <EvanR-work> makes about as much sense
07:58:47 <dmwit> I've never seen a use for vertical tabs, but if I do I probably won't hesitate to use them.
07:59:02 <Peaker> dmwit: what editors do your colleagues use?
07:59:08 <EvanR-work> dont accept code from dmwit its infested
07:59:08 <dmwit> I'm interested to see a language in which "vertical alignment" is a sensible thing.
07:59:14 <dmwit> Peaker: emacs, vim
07:59:31 <Peaker> dmwit: none of them use Eclipse or such?  How do you configure their editors to use tabs sensefully?
07:59:50 <dmwit> Unfortunately, when collaborating, I'm still forced to use spaces.
07:59:51 <Cale> there should be a character which causes the following text to be rendered at a random position on the screen
08:00:01 <dmwit> I'm fighting just as much of an uphill battle there as I am here. =)
08:00:35 <Peaker> dmwit: your battle involves limiting everyone to using non-default-configured vim/emacs, as I don't know of any other editor that can do tabs correctly
08:00:57 * dmwit nods sadly
08:00:57 <elliott> The Peaker I knew would point out that we should just be sharing ASTs anyawy :-P
08:01:19 <elliott> Everyone needs to get more interesting positions in this debate!
08:01:24 <elliott> Someone seriously argue that we just shouldn't indent, please.
08:01:42 <Peaker> elliott: indeed, but that's not ready yet :)
08:01:44 <EvanR-work> seems like the solution to having nice-for-you editing is to use a specialized editor yourself, not force everyone else to deal with your metadata, or to use your tool
08:01:54 <dmwit> We shouldn't use layout! {;} all the way
08:02:07 <Peaker> EvanR-work++
08:02:12 <elliott> OK, here's my try: Common knowledge per Torvalds is that any level of indentation past three is a bug.
08:02:16 <elliott> We should not encourage bugs.
08:02:23 <elliott> Also, every definition should fit onto one screen.
08:02:28 <Peaker> elliott: Torvalds says 8 is the only senseful tab width.. :)
08:02:32 <elliott> Instead of indentation, our editors should just have three background colours for each level of indentation.
08:02:36 <elliott> As in, instead of whitespace indentation.
08:02:37 * dmwit goes off to buy a huge screen
08:02:39 <elliott> If it goes over that, it's red.
08:02:49 <elliott> So we should just use that instead of indentation.
08:02:53 <dafis> Peaker: kwrite used to be able to treat tabs correctly (replacing them with spaces on load), but it seems that configuration option was removed :(
08:03:03 <dmwit> Peaker: You see? Some people have horrible taste in widths. =)
08:03:05 <elliott> dafis: That's certainly not correctly.
08:03:06 <kmc> http://hackage.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances "class (Tweedle dum, Tweedle dee) => Rum dum dee where"
08:03:14 <elliott> dafis: In that it's literally impossible to retain semantics in that way.
08:03:17 <Nafai> elliott: but that makes code even more inaccessible for visually impaired people. :(
08:03:32 <dafis> elliott: eradicating tabs is the correct way ;)
08:03:34 <Peaker> dafis: ah, that's not what I meant -- I meant senseful tabs as in: "tabs for indent, spaces for everything else".  Replacing all tabs with spaces is senseful only when you don't have to deal with merges later
08:03:37 <Nafai> elliott: Though that does remind me of colorForth, I believe color of the code is syntactically significant
08:03:38 <elliott> Nafai: No: The TTS will just shout for deeper indentation.
08:03:45 <byorgey> dafis: so for computing gcd or coprimality of two Integer values, I should use the extendedGCD function?
08:03:58 <Peaker> dmwit: I'd really rather read their code indented in bad taste -- than to have to deal with spurious merge conflicts ever again
08:04:11 <elliott> dmwit: If only ais were here, so he could convince you that tabs are literally eight spaces and anyone who's ever thought anything else is just participating in the longest shared delusion in human history.
08:04:26 <Peaker> dmwit: merge conflicts are a source of real pain, and potential bugs -- bad taste indent are a source of 10 sec of readjusting to reading someone else's code..
08:04:33 <dafis> byorgey: extendedGCD is for when you also want coefficients u,v such that a*u + b*v == gcd a b
08:04:52 <EvanR-work> Peaker: not only some editors take liberties with tabs here, some people actively go change the indentation before committing ;)
08:05:11 <dafis> byorgey: that uses normal extended Euclidean algorithm, no problem with types
08:05:16 <dmwit> Peaker: People/editors that silently change indentation should be shot.
08:05:39 * hackagebot BiobaseXNA 0.5.6.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.5.6.0 (ChristianHoener)
08:06:44 <byorgey> dafis: I know, but it looks like all the other functions use a binary GCD algorithm, and it says that is very slow for Integer
08:07:01 <byorgey> dafis: extendedGCD looks like the only one that uses the euclidean algorithm (?)
08:07:28 <dafis> byorgey: yes
08:07:56 <jeffcutsinger> elliott, sounds sufficiently crazy.
08:07:56 <Peaker> dmwit: It goes like this: A) someone allows tabs because he doesn't understand the notion of "spaces for alignment" or because his own editor works and to hell with others -> B) Others edit code with different tab widths, it gets completely messed up --> C) Everyone can't read the code, until someone silently fixes the tabs all to spaces and makes sure the indent is sane --> D) merge conflicts
08:07:59 <Peaker> dmwit: every single time
08:08:26 <Cale> ^^ I agree with Peaker
08:08:29 <Peaker> dmwit: actually the most common A step is "Editor comes with tabs on by default" without spaces for alignment
08:08:35 <byorgey> dafis: oh! never mind, I forgot we already have the 'gcd' function in the Prelude =)
08:08:47 <dafis> byorgey: yep :D
08:09:26 <Peaker> dmwit: The cost of D dwarfs any potential benefit of tabs by so much that it's totally, absolutely, vehemently not worth it
08:09:29 <EvanR-work> > gcd 1230481092384 45720394850293485
08:09:30 <lambdabot>   3
08:09:40 <dafis> > gcd 0 0
08:09:41 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
08:09:48 <elliott> Peaker: VCSes should really have mergers for indentation built-in.
08:09:53 <elliott> That isn't even very pie-in-the-sky.
08:09:55 <dafis> no longer :)
08:09:58 <dmwit> Peaker: Yes, if you break the "tabs for indentation, spaces for alignment" rule, you are definitely in for pain.
08:10:03 <kmc> omg you're still talking about this
08:10:13 <elliott> kmc: I know! Nobody is even humouring my great ideas.
08:10:28 <elliott> OK, what if the program was actually indented in reverse.
08:10:36 <elliott> Normal lines were indented as far as the program nests, and it goes down to the left margin.
08:10:39 * hackagebot DSH 0.7.4 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.7.4 (GeorgeGiorgidze)
08:10:42 <EvanR-work> spaces for alignment, why. why would you do that
08:10:46 <elliott> And you used... NUL bytes to do it.
08:10:49 <Peaker> dmwit: and if you don't -- that means no coworkers are allowed to use anything but vim/emacs -- with a specific configuration enabled. In my workplace (and many others) that's not practical at all, and the downsides of forcing editors on them also outweigh any benefit of tabs
08:11:11 <KitB> This conversation is *still* happening??
08:11:24 <KitB> Should you guys not take this into #haskell-offtopic
08:11:26 <EvanR-work> tabs are theoretically repugnant!
08:11:30 <kmc> Ferry is a better name than DSH
08:11:33 <monochrom> this is what you get for "programs are plain text files"
08:11:40 <KitB> Or whatever the channel is called
08:11:50 * dmwit apologizes
08:11:54 <dmwit> I should have stopped long ago.
08:13:28 <kmc> "programs are plain text files" is unfortunate, but it's one of those lowest-denominator decisions which enables a lot of diversity and experimentation and such
08:13:57 <kmc> popular languages which require a special IDE, version control system, etc. are rare
08:14:06 <kmc> most of them seem to be aimed at "non-programmers"
08:14:31 <geheimdienst> i'm trying to think of an alternative ... i guess xml is out. some complicated undebuggable binary thing would be unfortunate
08:14:31 <kmc> but maybe yi and darcs would work better ;)
08:14:34 <EvanR-work> real programmers write code (and webpages) byte by byte to spoonfeed the computer
08:14:44 <EvanR-work> when they really shouldnt
08:14:57 <elliott> kmc: It's all Unix's fault. (Watch as I pass the blame up to electrons themselves.)
08:14:58 <kmc> XML is fine, if you're actually putting a decent presentation layer on it
08:15:01 <dafis> EvanR-work: nibble by nibble, I would think
08:15:16 <EvanR-work> kmc: typing xml isnt fine
08:15:18 <kmc> XML is a decent data model but forcing humans to deal with XML concrete syntax is unforgivable
08:16:51 <kmc> the assumption is that your code is stored as XML (or YAML or JSON or S-expressions or haskell-src-exts Show or whatever the hell)
08:17:04 <kmc> and your editor displays that as haskell concrete syntax with your favorite indentation settings etc
08:17:16 <kmc> and your VCS can do diffs and merges at the AST level
08:17:28 <kmc> but you don't have to see XML concrete syntax
08:17:45 <EvanR-work> i think storage shouldnt be in text either
08:18:02 <kmc> probably but it's not an interesting question
08:18:04 <KitB> You guys are forgetting one problem with this (or maybe you aren't, again I'm not concentrating):
08:18:09 <EvanR-work> just leave it in tree form
08:18:10 <KitB> Everyone uses text editors
08:18:28 <KitB> It would be truly infeasible to move people away from text editors
08:18:34 <kmc> yeah I said that a while ago
08:18:37 <monochrom> everyone using text editors is an effect, not a cause.
08:18:52 <kmc> EvanR-work, what does "leave it in tree form" mean?
08:18:52 <KitB> monochrom: It's a self-fulfilling prophecy
08:19:10 <kmc> assuming you're still using a byte-oriented OS, how do you represent trees as bytes on disk
08:19:14 <monochrom> in fact, stepping outside the programmer's ivory tower and looking at the real world, everyone uses Office
08:19:14 <KitB> It's an effect that causes itself
08:19:24 <EvanR-work> kmc: well you gotta reject disks and tcp/ip
08:19:32 <KitB> monochrom: I wouldn't say ivory tower is the phrase to use there
08:19:40 <KitB> and I wouldn't say that's analogous either
08:19:50 <kmc> yeah, a lot of programmers are anti-intellectual and still out of touch with the real world
08:20:18 <monochrom> have you even seen Greg Wilson's http://third-bit.com/blog/archives/4302.html ?
08:21:18 <KitB> monochrom: Ooh shiny things that would be impractical to implement
08:22:06 <EvanR-work> WYSIWYG source code lol
08:22:19 <KitB> monochrom: I'm beginning to think you're trolling
08:23:22 <EvanR-work> s Bill Gates once said, “We always overestimate the change that will occur in the next two years and underestimate the change that will occur in the next ten.”
08:23:50 <kmc> ooh i like http://acko.net/blog/on-termkit
08:24:10 <kmc> this is a good example of combining text input with rich graphical output
08:24:15 <kmc> which is how more things should work
08:24:26 <KitB> termkit does look awesome
08:25:24 <joe9> is there a linux port yet? according to the webpage, not yet..
08:26:38 <KitB> If someone shows me that non-text programming can be done I'll love it, but I'm not seeing that happening
08:26:42 <Nafai> joe9: There have been some patches submitted that are in the git repo that add Linux support
08:26:51 <Nafai> joe9: I tried it out a couple months ago
08:26:58 <joe9> Nafai: ok, cool. did you like it?
08:27:15 <joe9> or, was it took much space-consuming?
08:27:23 <joe9> on the terminal, I mean.
08:27:32 <Nafai> It certainly was interesting, but yeah, the space use was an adjustment
08:27:46 <monochrom> EvanR-work: he is not saying WYSIWYG source code. he is saying what you already agreed above: storage shouldn't matter, display and editing shouldn't be in raw storage format, you should be able to choose how to display and edit, for example sometimes you want to see a table (but storage isn't in table form)
08:29:25 <EvanR-work> monochrom: yes, but open office puts a bad image in my head
08:30:45 <geheimdienst> storage of source code is already quite different from how it's displayed ... for instance the display includes colors, folding, and display of types pulled from haddock index files (or some such)
08:31:22 <dtrebbien> I'm trying to install the curl Haskell package on Windows.
08:31:30 <dtrebbien> So far I have managed to compile cURL.
08:31:42 <dtrebbien> I installed it to C:\Program Files (x86)\cURL
08:32:27 <dtrebbien> When I try to cabal install curl, it succeeds, but upon importing Network.Curl, I see "can't load .so/.DLL for: curl (addDLL: could not load DLL)"
08:32:41 <dtrebbien> (I have made a few, minor changes to the cabal file.)
08:32:54 <dcoutts> finding .dlls at runtime on windows is a pita
08:33:07 <dcoutts> simplest thing is to make sure the .dll is on the %PATH%
08:33:07 <dtrebbien> dcoutts: Yes
08:33:18 <dtrebbien> My question is: what is the expected name of the DLL?
08:33:20 <dcoutts> either that or copy the .dll into the same dir as the .exe you built
08:33:30 <dtrebbien> What DLL file name is GHCi looking for?
08:33:36 <dcoutts> dtrebbien: probably curl.dll
08:33:46 <joe9> has anyone seen this error: lexical error at character '\DEL', everything works fine with ghci but not with runghc. http://codepad.org/3qNo0eQL
08:34:01 <joe9> it seems to be reading it as a source file instead of as a shared library
08:34:18 <dcoutts> dtrebbien: sometimes the static .lib/.a name does not match the .dll name, that's a further pain
08:34:20 <joe9> and I have no idea on how to tell it that it is a shared library.
08:34:30 <dcoutts> dtrebbien: but you can check your curl installation
08:34:39 <dtrebbien> dcoutts: That's how it is in this case.
08:34:40 <Cale> joe9: Perhaps just try compiling rather than using runghc?
08:34:51 <joe9> cale, no, let me try that.
08:34:53 <joe9> thanks
08:35:07 <dtrebbien> dcoutts: I thought that because the import library references the correct DLL name, then it would be alright.
08:35:15 <shellox_> hi
08:35:22 <dtrebbien> dcoutts: Apparently not.
08:35:39 <dcoutts> dtrebbien: it would be fine if you compiled an .exe
08:35:55 <dtrebbien> dcoutts: I see :)
08:35:56 <joe9> cale, it compiles. thanks.
08:36:01 <dtrebbien> dcoutts: I'll have to try it.
08:36:08 <shellox_> i tried let addMe :: Int -> Int in ghci, but i always get the error     The type signature for `addMe' lacks an accompanying binding
08:36:11 <dcoutts> dtrebbien: because that'd use the system linker, but ghci has to load the .dll itself using LoadLibrary() which means it needs to know what it's called
08:36:44 <dtrebbien> dcoutts: Is there some way to override the DLL name?
08:36:50 <dcoutts> dtrebbien: it can be fixed by setting extra-ghci-libraries separately from the usual extra-libraries
08:36:55 <dtrebbien> The cabal file uses "Extra-libraries:  curl"
08:37:19 <dcoutts> dtrebbien: you'd alter the package reg using ghc-pkg describe curl > curl.pkg; edit curl.pkg; ghc-pkg update < curl.pkg
08:37:52 <dcoutts> dtrebbien: when editing the curl.pkg, you'd set the extra-ghci-libraries to be the real name of the dll (minus the .dll extension)
08:38:18 <Cale> shellox_: Probably what you want to do is make a new .hs file with a complete definition for addMe in it, and then load that in ghci, either with :l myfile.hs or by running ghci with that file. :r can then be used to reload it whenever you edit your definitions.
08:38:57 <Cale> shellox_: But if you really want to define the whole function at the ghci prompt, you can put a semicolon to separate the type signature from the binding and squish everything onto one line
08:41:19 <dtrebbien> dcoutts: It didn't work for me.
08:41:25 <shellox_> Cale: I got the same errue while loading from an external file
08:41:30 <Peaker> kmc: btw, if you store the code in a different way than it is displayed, then why not take advantage of a smart data structure? One that doesn't need a separate index -- but has O(1) inter-code references rather than names?
08:41:35 <adimit> mm_freak: sorry, I was away, eating.
08:41:38 <dtrebbien> dcoutts: It still is looking for "curl"
08:41:41 <Peaker> kmc: (such that a large project scales w.r.t finding definitions, etc)
08:41:52 <Cale> shellox_: Yeah, you have to define what addMe does
08:42:02 <Cale> shellox_: for example,  addMe x = x + 5
08:42:44 <adimit> mm_freak: well, I want for every chunk of BS input, to produce a HashMap (X), and then I want to do something in IO with that hash-map, per chunk (in this case, commit to database.)
08:43:52 <dcoutts> dtrebbien: did you re-register it? does ghc-pkg describe curl now show the modified extra-ghci-libraries line?
08:43:56 <shellox_> Cale: ok, thanks, I got it
08:44:40 <dtrebbien> dcoutts: Oh. Extra-ghci-libraries is still blank.
08:45:25 <EvanR-work> Peaker: .net 'assemblies' can be decompiled complete with names
08:45:58 <dcoutts> dtrebbien: check you did those steps right and check if any errors were reported
08:46:04 <dcoutts> dtrebbien: I've got to go, sorry
08:46:10 <EvanR-work> and in MOO the programs were stored in compiled form, and decompiled (without remarks) and with newly generated indentation formatting
08:46:37 <dtrebbien> dcoutts: No problem. Thanks for your help.
08:46:49 <mm_freak> adimit: you can do this after the iteratee is finished, but you can also do it while processing
08:46:53 <mm_freak> adimit: why HashMap?
08:47:20 <hpaste> copumpkin pasted “yay, all” at http://hpaste.org/52806
08:47:25 <copumpkin> yay
08:47:31 <kmc> source code is already stored in a different way than it is displayed
08:48:01 <kmc> it's stored as (say) UTF-8 encoded byte sequences, and displayed as Unicode characters in some font with highlighting etc
08:48:40 <adimit> mm_freak: yeah, I'd like to do it *while* processing, in order to keep the memory usage down. Waiting for the iteratee to finish would be wasting 2GB of memory.
08:48:40 <kmc> anyway yeah, that would be a good feature Peaker
08:49:07 <mm_freak> adimit: are you using the monadic interface to iteratees?
08:49:40 <adimit> mm_freak: in a simplified scenario, I'm just counting words, and committing word counts to a database. I'm hash-tabling chunkwise (with 65KB chunks,) in order to minimize disk hits.
08:49:46 <et999> @pl x
08:49:46 <lambdabot> x
08:49:55 <geheimdienst> kmc: yo, also folding, and on a good day haskellmode can tell you the types of library functions
08:50:05 <et999> @pl   x * x
08:50:06 <lambdabot> x * x
08:50:07 <adimit> mm_freak: not that I'm aware of. I was under the impression the monadic interface for iteratees kind of made them sequential.
08:50:16 <adimit> i need them to be synchronous.
08:50:16 <et999> @pl   \ x -> x * x
08:50:17 <lambdabot> join (*)
08:50:54 <mm_freak> adimit: normally the iteratee would return only one item each time…  the enumerator is responsible for chunked reading
08:51:23 <mm_freak> adimit: it's just a different interface, but you can only use the predefined iteratees that way
08:51:38 <mm_freak> particularly you can't really write enumerators or enumeratees using the monadic interface
08:51:43 <et999> @pl   \x -> x * x
08:51:43 <lambdabot> join (*)
08:51:54 <et999> @pl   square x = x * x
08:51:54 <lambdabot> square = join (*)
08:51:59 <Cale> > join (*) 5
08:52:00 <lambdabot>   25
08:52:34 <adimit> mm_freak: interesting. I have so far only used the predefined combinators.
08:53:20 <adimit> mm_freak: I've found the iteratee package's documentation to be opaque. Or maybe me too dumb. I like iteratees, but sometimes, I feel like I'm too dumb to figure out how to do simple stuff. Like this, it should really be very simple.
08:53:33 <mm_freak> adimit: in any case, if you need to collect chunks of input in the iteratee, you are using iteratees wrongly
08:53:53 <mm_freak> i found the 'enumerator' package much easier to understand
08:54:06 <mm_freak> but 'iteratee' is really just a CPS-transformed variant of it
08:54:37 <mm_freak> (the 'iteratee' package is older, btw, just in case it sounds like i'm suggesting the opposite)
08:55:10 * elliott considers plugging iterIO :-)
08:55:20 <adimit> mm_freak: yeah, I knew that :-) I had the false ambition to want to understand the *real* stuff, i.e. oleg's notes & lato's implementation.
08:55:53 <mm_freak> adimit: 'enumerator' is a more direct translation of oleg's original idea
08:56:17 <geheimdienst> for error monads, is there a library function that does basically "either throwError return"? i have a pure, non-monadic Either which i'd like to run through a bunch of ErrorT functions, i.e. i think i need to "convert" it first
08:57:06 <kmc> i've not found this function, and i've written it myself many times :/
08:58:49 <adimit> mm_freak: but oleg does use tons of CPS in his notes… bah. Maybe I should've chose enumerator. Now I have a pile of code written depending on lato's package.
08:58:54 <geheimdienst> kmc, thanks. seems like a weird omission
08:59:29 <mm_freak> geheimdienst, kmc: there is a more general principle here, and i've defined a class for it in the contstuff package:  LiftFunctor
08:59:31 <kmc> *nod*
08:59:38 <kmc> there are a lot of weird omissions in the standard libs :/
08:59:45 <mm_freak> but it's only for the contstuff MTs, which may not be useful for you
08:59:55 <kmc> i see
09:00:12 <geheimdienst> mm_freak: hmm, interesting ...
09:00:53 <geheimdienst> incidentally, how would we do the same for monadic Maybe? just "return"?
09:01:17 <adimit> mm_freak: one question (sorry to nag, but you're like the first person in #haskell who doesn't go "iteratee? never used it":) if you're saying i'm not using iteratees correctly for doing chunk-wise processing, what else should I use?
09:03:16 <geheimdienst> oh, missingh has it under the name of eitherToMonadError. missingh++
09:03:59 <rostayob> When writing a type signature, why can I write foo :: (forall a. Show a) -> whatever and not foo :: [forall a. Show a => a] -> whatever?
09:04:42 <Axman6> because []'s are reserved for list syntax?
09:04:46 <adimit> rostayob: try foo:: (forall a. Show a) => [a]
09:04:57 <dtrebbien> @t ShowS
09:04:57 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:04:57 <kmc> rostayob, the latter is a non-Haskell type
09:05:01 <adimit> and actually, you want no forall a., at all.
09:05:07 <kmc> it's a list of values, each one of which must be polymorphic
09:05:24 <kmc> "i give you a list, you pick an element, you pick a type, i give you a value of that type"
09:05:28 <kmc> whereas plain old [a] is "you pick a type, i give you a list of that type"
09:05:50 <adimit> ah, the old mixed list.
09:05:51 <kmc> it's not a mixed list either
09:06:05 <adimit> oh, I thought that was what you meant.
09:06:28 <kmc> mixed list would be "i give you a list, you pick an element, i tell you what its type really is"
09:06:37 <kosmikus> no, a mixed list would be [exists a. ... => a]
09:06:43 <kmc> existential, not universal quantification
09:07:04 <kosmikus> but kmc has this under control, it seems :)
09:07:22 <kmc> i can take the 4th element of foo :: [forall a. Show a => a], call it x, and then demand to use x as an Int and as a Bool
09:08:04 <kmc> [forall a. Show a => a] is not going to have useful values
09:08:19 <kmc> just things like ⊥, [], [⊥], [⊥, ⊥], ⊥ : ⊥, etc
09:08:21 <rostayob> kmc: yes I agree with you, but why is the notation like that for functions?
09:08:29 <rostayob> isn't (->) a type constructor like []?
09:08:48 <kmc> yes
09:08:57 <Cale> rostayob: Because you haven't turned on ImpredicativeTypes
09:09:07 <kmc> but the extension to allow a polytype as an argument to (->) is different from the extension to allow it as a polytype to other tycons
09:09:36 <dolio> (->) is magic
09:09:55 <kmc> ImpredicativeTypes is deprecated, or was for a while
09:09:56 <Cale> {-# LANGUAGE ImpredicativeTypes #-}
09:09:58 <dolio> GHC is very muddled about its impredicativity.
09:10:14 <kmc> it's better to say «data Foo = Foo (∀a. Show a => a);  foo :: [Foo]»
09:10:17 <Cale> my current ghc (7.0.3) accepts   foo :: [forall a. Show a => a] -> Int; foo xs = length xs
09:10:33 <kmc> which requires only -XPolymorphicComponents
09:10:37 <Cale> when ImpredicativeTypes is turned on
09:10:47 <rostayob> kmc: yep right, but isn't the notation kind of ambiguous?
09:10:54 <Cale> rostayob: How so?
09:10:55 <kmc> is it?
09:11:53 <rostayob> mhm... I just can't reconciliate the fact that forall a. Show a =>  a -> b means something different to [forall a. Show a]
09:12:09 <kmc> well obviously they mean different things; the second one is a list
09:12:34 <kmc> your first example has quantification outside the type constructor, and the second one has it inside
09:12:41 <kmc> ∀a. ( (Show a) => a -> b) )
09:12:58 <rostayob> kmc: well in the first example the forall quantification is inside the (->) type constructor
09:13:10 <Dodek> hello, i have a function which returns (Float, Float, Float), and i want to use these values with a function GLfloat -> GLfloat -> GLfloat -> Foo, but haskell compiler will not accept them. how can i do it? GLfloat is of course a type alias for Float.
09:13:18 <kmc> not in «forall a. Show a =>  a -> b»
09:13:35 <mm_freak> adimit: no worries, i'm happy to help =)
09:13:45 <kmc> let (x, y, z) = f whatever in g x y z -- Dodek
09:13:46 <mm_freak> adimit: try to write your iteratees in raw form
09:13:52 <rostayob> well what about foo :: Show b => (forall a. Show a => a -> String) -> b -> String
09:13:57 <Dodek> kmc: that's what i do
09:13:59 <Cale> Dodek: realToFrac
09:14:03 <rostayob> you do have a quantification inside (->) in that case
09:14:16 <kmc> Dodek, can you put your actual code and error on hpaste?
09:14:32 <kmc> rostayob, so what about it?
09:14:44 <adimit> mm_freak: you mean piece them together with liftI, icont, idone?
09:14:48 <rostayob> kmc: well that seems to conflict with "you can't put forall inside a type constructor"
09:14:51 <kmc> the extension to enable ∀ within an argument to (->) is different from the extension to allow it as an argument to other type constructors
09:14:51 <adimit> doing that right now.
09:14:56 <kmc> neither is allowed in Haskell, of course
09:15:08 <kmc> the reason for these being different extensions is probably implementation details
09:15:15 <kmc> the latter has proved a lot more problematic for the GHC devs
09:15:19 <kmc> but anyway you can enable both in current GHC
09:15:36 <mm_freak> adimit: sorry, i'm more experienced with the enumerator library
09:15:38 <kmc> functions *are* quite special in a lambda calculus
09:15:44 <Cale> GLfloat is a newtype of CFloat which is itself a newtype of Float, but they're conceptually potentially different types
09:15:50 <hpaste> Dodek pasted “float -> glfloat” at http://hpaste.org/52807
09:16:05 <kmc> maybe you should use realToFrac Dodek
09:16:12 <kmc> > realToFrac (3 :: Double) :: Float
09:16:13 <lambdabot>   3.0
09:16:21 <rostayob> kmc: my problem here is that the use of "forall" sometimes confuses me here
09:16:25 <rostayob> i mean forall as a word
09:16:30 <hpaste> Dodek annotated “float -> glfloat” with “float -> glfloat (annotation)” at http://hpaste.org/52807#a52808
09:16:38 <Cale> You can use realToFrac, but if you have performance issues with that, you may want to consider adding a RULES pragma to rewrite the realToFrac into an unsafeCoerce
09:16:49 <Dodek> kmc: here you are
09:17:34 <Cale> Personally, I find it a bit odd that the OpenGL library decided to define its own newtypes
09:17:36 <Chaze> hi there. i remember finding some page of 'todo projects/research' related to the haskell language
09:17:38 <adimit> mm_freak: ah, ok. I meant, writing them from ground up instead of using combinators to lift functions into iteratees. I think the equivalent in enumerator would be to write your own iteratee with a step function that does pattern matching on a stream (Chunk/EOF/…) and use yield, continue, returnI, etc.
09:17:40 <Chaze> lost the bookmark :/
09:17:43 <Cale> rather than just using Float/Double/etc.
09:17:46 <Chaze> anyone knows something like that?
09:17:57 <kmc> rostayob, do you know about System F?
09:18:02 <adimit> mm_freak: because I didn't understand what writing an iteratee in raw form means.
09:18:04 <kmc> it's a nice setting in which to explore polymorphism
09:18:23 <kmc> i wrote a little article which kind of relates Haskell and System F
09:18:24 <kmc> http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
09:19:04 <hjulle> kmc: Which method are you using for entering "∀" etc. in irc?
09:19:30 <adimit> xcomp, most likely :-D
09:21:36 <Cale> I can type ∀ using the latex table for IBus, by tapping Ctrl-Space to put me in latex mode and then \fo (which completes to \forall)
09:22:27 <hjulle> adimit: What is xcomp? I couldn't find anything by googling it.
09:22:48 <adimit> hjulle: X11's composite character system.
09:23:22 <kmc> hjulle, http://mainisusuallyafunction.blogspot.com/2010/10/typing-mathematical-characters-in-x.html
09:23:37 <adimit> you can assign some key to be your xcompositor key, and then there's also the option to use a dotfile (I thinkith was .Xcomposite or so) to define custom keystrokes & symbols.
09:24:15 <adimit> yeah, kmc just posted it :-)
09:24:28 <Cale> haha, ☭
09:24:31 <hjulle> kmc: thanks
09:24:47 * Cale binds Caps Lock to compose
09:25:28 <adimit> i've bound caps lock to escape. best thing i ever did in my life.
09:25:44 <Axman6> what do you use escape for?
09:25:49 <adimit> vim
09:25:57 <Axman6> ah
09:26:03 <Chaze> caps lock has to be backspace, can't even imagine anything else :P
09:26:31 <kmc> mine is ctrl
09:26:44 <Chaze> is anyone actually using caps lock as it is? :)
09:26:52 <adimit> whatever it is, caps lock should never be caps lock.
09:26:53 <kmc> i code on a keyboard which actually puts backspace in a convenient place
09:27:07 <jtg> caps lock is ctrl, clearly
09:27:17 <hjulle> Chaze: No, it is annoying to use computers which do that. (Mine is esc)
09:27:43 <adnam> WHATEVER DO YOU MEAN
09:28:07 <rostayob> kmc: no I don't know System F. yet.
09:28:40 <rostayob> kmc: but anyway, the keyword forall doesn't mean much in terms of logic in haskell right?
09:28:42 <hjulle> adimit: Did you try to press control/escape/backspace? :P
09:28:57 <hjulle> :s/adimit/adnam
09:29:32 <kmc> rostayob, it doesn't mean anything in Haskell.  it's not in Haskell
09:29:51 <Cale> heh
09:29:56 <Cale> It is in GHC Haskell
09:30:02 <rostayob> kmc: ok, in GHC Haskell then :P
09:30:06 <kmc> and in GHC it does relate to logic
09:30:27 <Cale> It means several things in GHC Haskell, depending on where you put it.
09:30:27 <kmc> it means more or less the same thing it means in System F
09:30:35 <kmc> at least in the way you were using it
09:30:43 <Cale> but yeah, they're all pretty much "the same thing"
09:30:48 <kmc> and under the Curry–Howard isomorphism, System F corresponds to the fragment of second-order intuitionistic logic that uses only universal quantification
09:30:48 <rostayob> I mean while a type 'a -> b' can be seen as 'a -> b' in logic, 'forall a b. a -> b' does not mean 'forall a b. a -> b' in loic
09:30:53 <kmc> yes it does
09:31:08 <rostayob> ok, then i don't know enough logic
09:31:12 <kmc> *nod*
09:31:17 <rostayob> it means something in what logic?
09:31:27 <kmc> i don't understand the question
09:31:37 <kmc> let me give a concrete example
09:31:44 <kmc> ∀ p q.  (p, q) → (q, p)
09:31:44 <Chaze> Ok, asking again: I want to write a Haskell-related BSc thesis. I recall some page of open research problems related to the language, but can't seem to find it again. Any ideas on where to find that?
09:31:58 <monochrom> it matches perfectly with universal quantification in intuitionistic logic
09:32:17 <kmc> rostayob, for all propositions p,q, if  p and q then q and p
09:32:20 <rostayob> kmc: ok second order logic is when you can quantify over the predicates right?
09:32:28 <kmc> rostayob, you're right that it's not quite the same as first-order ∀
09:32:29 <kmc> yeah
09:32:48 <companion_cube> and also you can have lambdas in your terms
09:32:56 <monochrom> oh, 2nd order, nevermind
09:43:02 <monochrom> "forall t" gives the user freedom to choose what t stands for. so the question is who is the user.
09:43:07 <kmc> what's the best library for loading a png file?
09:43:21 <kmc> i see stb-image, pngload, and Codec-Image-DevIL
09:43:30 <monochrom> at the outermost position, or at the return type position, the user is the caller
09:43:32 <kmc> from reading docs I have some problems with each, but probably I should get less picky
09:44:05 <monochrom> at the argument position, e.g., (forall t. ...) -> Int, the user is the callee
09:44:21 <kmc> oh i guess gd can do it too
09:44:35 <monochrom> generally, at positive positions, user=caller; at negative positions, user=callee
09:45:18 <monochrom> example: ((forall t. ...) -> r) -> r caller chooses t
09:46:31 <monochrom> whereas caller has freedom, callee has obligation (of providing something that works regardless what t becomes); and vice versa
09:48:53 <ocharles> Does anyone know how to enable the 'detailed' test-suite type in cabal?
09:49:11 <ocharles> http://www.haskell.org/cabal/users-guide/#test-suites indicates it exists, but my cabal returns "available test types are: exitcode-stdio-1.0"
09:49:31 <ocharles> (1.10.2.0)
09:49:50 <Zarroc> .
09:51:30 <dmwit> kmc: And the imagemagick bindings.
09:51:38 <dmwit> kmc: What are you looking to do with it after you load it?
09:51:46 <dmwit> (And gtk2hs, I think.)
09:58:29 <geheimdienst> ocharles: from reading the docs, it seems to me that detailed-1.0 is only possible when no "main-is" field is in the description. have you doublechecked that?
09:58:33 <mannu> hi
09:59:30 <mannu> when i use brace expansion like this in bash: echo {1..2}{a,b,c} it evaluates to "1a 1b 1c 2a 2b 2c"
09:59:33 <mannu> what is this called?
09:59:48 <kmc> it's not haskell
10:00:03 <kmc> dmwit, just get the color values of some pixels
10:00:07 <adrake> mannu: http://www.gnu.org/software/bash/manual/bashref.html#Brace-Expansion
10:00:11 <adrake> mannu: "Brace expansion"
10:00:13 <adrake> also, not haskell
10:00:15 <kmc> i didn't know about imagemagick bindings
10:00:17 <mannu> ...
10:00:21 <mannu> i just typed it was brace expansion
10:00:31 <mannu> i want to know what the operation on data structures are called when you do like that on lists or sets
10:00:38 <adrake> cartesian product?
10:00:39 <copumpkin> cartesian product
10:00:44 <mannu> thanks :)
10:00:50 <copumpkin> > liftA2 (,) [1,2] [a,b,c]
10:00:51 <lambdabot>   [(1,a),(1,b),(1,c),(2,a),(2,b),(2,c)]
10:01:07 <adrake> > (,) . [1,2] [a,b,c]
10:01:08 <lambdabot>   Couldn't match expected type `t -> f a'
10:01:08 <lambdabot>         against inferred type `[a1]'
10:01:13 <adrake> > (,) <$> [1,2] <*> [a,b,c]
10:01:13 <lambdabot>   [(1,a),(1,b),(1,c),(2,a),(2,b),(2,c)]
10:01:14 <adrake> rather
10:01:51 <copumpkin> > (,) <$> [1,2] <**> [a,b,c]
10:01:52 <lambdabot>   Couldn't match expected type `(b1 -> (a, b1)) -> b'
10:01:52 <lambdabot>         against inferre...
10:02:12 <copumpkin> > [1,2] <**> [a,b,c] <$> (,)
10:02:13 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
10:02:15 <copumpkin> boo
10:02:22 <copumpkin> :t (<**>)
10:02:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
10:03:06 <kmc> dmwit, do you have a recommendation between them?
10:03:27 <dmwit> kmc: Oh, whoops, didn't see that you had responded.
10:03:35 <dmwit> gd is pretty darn simple if that's all you want.
10:03:41 <copumpkin> > [1,2] <**> (flip (,) <$> [a,b,c])
10:03:43 <lambdabot>   [(1,a),(1,b),(1,c),(2,a),(2,b),(2,c)]
10:03:46 <copumpkin> there we go
10:03:50 <copumpkin> guh
10:04:47 <dmwit> ...and it works on Windows.
10:04:56 <kmc> fuck windows
10:05:06 <kmc> seriously, i'm writing a small tool for my own use, portability is not a concern
10:05:10 <copumpkin> kmc: you forgot to say winblow$
10:05:17 <copumpkin> micro$oft winblow$
10:05:23 <kmc> exactly
10:06:02 <mannu> thanks for the help guys. i'll continue fiddling around now
10:06:05 <dmwit> loller$kate$
10:06:21 <kmc> hmm but gd wants me to execute an IO action for every "getPixel" request
10:06:37 <kmc> some of the others give like a UArray, which might be more convenient
10:07:48 <dmwit> well, okay
10:08:43 <rwbarton> I've been using repa-devil which uses Codec-Image-DevIL
10:09:03 <erus`> :t (:=)
10:09:04 <lambdabot> Not in scope: data constructor `:='
10:09:11 <erus`> what does := mean in a pattern
10:09:16 <kmc> ah cool
10:09:21 <kmc> erus`, it's a data constructor
10:09:23 <kmc> just written infix
10:09:46 <erus`> ah ok
10:09:59 <kmc> thanks for the suggestion rwbarton, it looks good
10:10:25 <kmc> now i just need to learn about repa :)
10:11:46 <kmc> "If you don't like turnips then this library probably isn't for you"
10:12:43 <obiwahn> sombody in this channel told me a about a page where it is possible to enter a term and watch the eval steps ... where can that be found ... i can't find it in my history && logs:(
10:14:45 <obiwahn> ah:) http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
10:17:01 <Egbert9e9> so I've installed Ubuntu 11.10's haskell-platform and I want to install leksah using cabal-dev, but I get the following error: http://pastebin.com/h2TMSMrr
10:17:02 <mauke> I have copied your paste h2TMSMrr to http://hpaste.org/52815 - pray I don't copy it any further.
10:25:31 <dafis> Egbert9e9: your ghc is too new for leksah
10:32:08 <aristid> is leksah unmaintained?
10:33:25 <Egbert9e9> dafis: okay, thanks
10:38:37 <sm> morning all. Which macports package will fix "Missing C library: crypt" ?
10:43:51 <c_wraith> sm: where are you getting that from?
10:43:59 <c_wraith> sm: also, probably nowhere.
10:46:09 <Egbert9e9> How do you generate documentation for packages installed using cabal?
10:46:35 <c_wraith> Egbert9e9: you can enable documentation in ~/.cabal/config
10:46:44 <Egbert9e9> ah, okay
10:46:50 <c_wraith> Egbert9e9: I don't know any clean way of generating documentation for anything already installed
10:46:53 <kmc> if you have a cabalized project dir you can say "cabal haddock --hyperlink-source"
10:46:57 <mots_> hey
10:47:00 <mots_> i need help
10:47:07 <luite> c_wraith: but you won't get source links :(
10:47:43 <luite> I use a script that rebuilds all docs with source links for all installed pkgs
10:47:46 <Veinor> i wonder how hard it'd be to build a haskell 'call tree', where a links to b if b appears anywhere in a's definition
10:47:47 <mots_> i have a function, numberOfOcc :: Char -> String -> Integer that returns how often an integer is in a string
10:47:49 <kmc> mots_, you can just ask your question :)
10:48:06 <sm> c_wraith: installing Unixutils. I see lispy had the same problem at http://tunes.org/~nef//logs/haskell/11.05.07
10:48:14 <Veinor> mots_: generalize it to (Eq a) => a -> [a] -> Integer ?
10:48:20 <solidsnack> mots_: And it doesn't work?
10:48:22 <mots_> now i somehow need to write a function that tells me the most common char of a string
10:48:25 <Egbert9e9> Will it create documentation for all dependencies or just top package?
10:48:28 <solidsnack> Oh.
10:48:37 <mots_> Veinor, I'm new to haskell and functional programming
10:48:45 <mots_> quite good in java, python and c#
10:48:45 <kmc> :t M.fromListWith (+) . map (\x -> (x, 1))
10:48:46 <lambdabot> forall a a1. (Num a, Ord a1) => [a1] -> M.Map a1 a
10:48:55 <mots_> but can't do anything in haskell :D
10:49:00 <luite> mots_: if you sort the string first, then group, then sort by group length, then you'd have the answer
10:49:06 <c_wraith> sm: huh.  I really have no clue whether that links against something gnu-specific or not..
10:49:08 <Cale> mots_: Well, a kinda bad algorithm which would use numberOfOcc would be to apply it to every character in the string
10:49:15 <Cale> mots_: with that string, of course
10:49:25 <Cale> mots_: and then take the maximum of the resulting list
10:49:29 <kmc> :t sortBy (comparing snd) . M.toList . M.fromListWith (+) . map (\x -> (x, 1))
10:49:30 <lambdabot> forall b a. (Ord b, Num b, Ord a) => [a] -> [(a, b)]
10:49:57 <kmc> > sortBy (comparing snd) . M.toList . M.fromListWith (+) . map (\x -> (x, 1)) $ "hello mots_"
10:49:59 <lambdabot>   [(' ',1),('_',1),('e',1),('h',1),('m',1),('s',1),('t',1),('l',2),('o',2)]
10:50:11 <Veinor> :t M.findMax . M.fromListWith (+) . map (,1)
10:50:12 <lambdabot> Illegal tuple section: use -XTupleSections
10:50:17 <kmc> here import qualified Data.Map as M
10:50:20 <Veinor> :t M.findMax . M.fromListWith (+) . map $ \x -> (x,1)
10:50:20 <lambdabot>     Couldn't match expected type `[(k, a)]'
10:50:21 <lambdabot>            against inferred type `[a1] -> [b]'
10:50:21 <lambdabot>     In the second argument of `(.)', namely `map'
10:50:31 <c_wraith> sm: if there's just a binding to the C crypt function, you don't need to pass -lcrypt on os x.  If it's using any of the gnu extensions, you're pretty much out of luck.
10:50:33 <Veinor> oh, derp
10:50:34 <kmc> findMax will go by keys, not values :/
10:50:50 <Veinor> oh, it does? that's unfortunate
10:50:59 <kmc> > head . sortBy (flip $ comparing snd) . M.toList . M.fromListWith (+) . map (\x -> (x, 1)) $ "this is a test"
10:51:01 <lambdabot>   (' ',3)
10:51:15 <sm> c_wraith: I suspect it's using it. I tried commenting out the extra-lib dependency and it failed
10:51:33 <c_wraith> sm: looks like it's just crypt...  that should be ok.  Maybe it is in a lib.  let me check.
10:51:35 * sm is trying to install ipprint for nicer ghci printing
10:51:44 <kmc> TupleSections is nice but i always feel silly turning it on
10:52:07 <Veinor> i'm pretty sure there's also a fold that'll do what you want
10:52:19 <mots_> Cale, the kinda bad algorithm sounds like something i would understand
10:52:25 <mots_> how would i do that in haskell?
10:54:33 <sm> it's looking for shadow.h, maybe port can tell me what package that's in...
10:55:32 <c_wraith> sm: I can link a small program that uses crypt(3) on osx without any linker flags at all
10:55:48 * hackagebot arithmoi 0.1.0.2 - Efficient basic number-theoretic functions.  Primes, powers, integer logarithms.  http://hackage.haskell.org/package/arithmoi-0.1.0.2 (DanielFischer)
10:55:56 <c_wraith> sm: so I really have no clue why it's failing, but clearly that package is not built for os x
10:56:14 <sm> c_wraith: yeah, it probably worked on older osx
10:56:22 <Veinor> mots_: maximumBy (flip numberOfOcc string) string
10:56:30 <Veinor> oh, no
10:57:01 <Veinor> mots_: maximumBy (compare `on` flip numberOfOcc string) string, but that'll be really annoyingly slow
10:57:09 * sm looks at making ipprint work without it
10:57:42 <sm> hey, ipprint is only 37 lines :)
10:58:02 <mots_> Veinor, ERROR file:.\test2.hs:24 - Undefined variable "on"
10:58:03 <mots_> :O
10:58:22 <Veinor> on is in Data.Function
10:58:24 <dafis> mots_: import Data.Function
10:58:45 <dafis> grrr
10:58:45 <Veinor> also you want comparing (in Data.Ord), not compare. whoops.
10:58:45 <luite> is that a hugs error?
10:58:46 <Veinor> (and maximumBy is in Data.List)
10:59:00 <c_wraith> sm: know what's totally awesome about that binding to crypt?  It's not thread-safe.  yay.
10:59:07 <mots_> yeah, thats a hugs error
10:59:20 <mots_> also, Can't find imported module "Data.Function"
10:59:39 <luite> right, I was afraid of that ;p
10:59:41 <Veinor> ... you don't have Data.Function?
11:00:13 <luite> better install the Haskell Platform with GHC
11:00:31 <luite> unless you're required to do everything in hugs for homework
11:00:40 <mots_> luite: it's for college, and it should work with hugs
11:01:06 <Veinor> why doesn't hugs have Data.Function? O_o
11:01:34 <sm> c_wraith: all this hassle just so ipprint can get the terminal width.. I'll make it use vty or something easier
11:02:27 <luite> mots_: you can make your own on, see http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Function.html#on
11:06:00 <sm> jeez what am I doing shaving this beast.. I'll hard-code the frickin width
11:06:56 <luite> sm: hehe doing html or css or something?
11:10:37 <kmc> hugs hasn't been updated in 5 years
11:10:44 <sm> luite: just debugging rss2irc
11:11:08 <sm> trying to print my Bot and Opts data types more clearly
11:11:25 <sm> so, exploring pretty print libraries. There seem to be quite a few
11:11:34 <luite> ah
11:12:13 <monochrom> Data.Function is fairly recent. hugs is before that time.
11:12:42 <monochrom> hugs probably doesn't even have "on" and "comparing"
11:13:22 <monochrom> windows 3.0 doesn't have the "start" button
11:13:48 <luite> hmm, is there a hoogle for searching hugs functions? huggle or somethign?
11:13:59 <monochrom> no
11:14:28 <sm> quite a few pretty print libs, but nothing obvious to use for debugging like in php/python/ruby
11:14:39 <monochrom> easiest to download, unpack hugs and see what's inside
11:15:27 <monochrom> most modules stay as source code in hugs (it's an interpreter), you can peek inside
11:16:02 <sm> where's a hackage with reverse dependencies ?
11:16:44 <sm> roel's is down
11:16:44 <luite> monochrom: meh that's a lot of work just for helping people on irc ;)
11:17:05 <monochrom> O(0) amortized over time
11:17:28 <monochrom> in fact I had it installed long ago. trivial to look up things now
11:18:15 <luite> I'd hope that the cumulative number of people doing homework in hugs would be convergent
11:20:18 <elliott> when it is said that the action in alwaysSucceeds only executes at the end of a transaction, that's at the end of a /successful/ transaction, right?
11:20:20 <elliott> never one about to retry
11:20:24 <elliott> my testing confirms this, just checking
11:24:48 <MrFenix> @pl (\ x -> mappend (f x) (g x))
11:24:49 <lambdabot> liftM2 mappend f g
11:25:53 <dafis> sm: http://81.26.216.99/~roel/hackage/packages/hackage.html
11:27:19 <int-e> @unpl ap (mappend . f) g
11:27:19 <lambdabot> ((\ k -> mappend (f k)) >>= \ b -> g >>= \ a -> return (b a))
11:28:24 <MrFenix> ((\ k -> mappend (f k)) >>= \ b -> g >>= \ a -> return (b a))
11:28:24 <MrFenix> cause I am evil in league with perl 666 :D
11:30:43 * hackagebot HROOT 0.6.7 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.7 (IanWooKim)
11:31:27 <elliott> Is there a way to circumvent `atomically`s desire not to be nested? I know, I know...
11:33:09 <Cale> elliott: Uhh, it doesn't make sense, type-wise
11:33:17 <Cale> Why do you want to nest it?
11:33:31 <Cale> (what would that even mean?)
11:33:40 <sipa> :t atomically
11:33:41 <lambdabot> Not in scope: `atomically'
11:33:48 <elliott> Cale: atomically actually errors out if you nest it (hint: it can't be done safely).
11:33:49 <sipa> @hoogle atomically
11:33:49 <lambdabot> Control.Exception data NestedAtomically
11:33:49 <lambdabot> Control.Exception NestedAtomically :: NestedAtomically
11:33:50 <lambdabot> Control.OldException NestedAtomically :: Exception
11:33:53 <mm_freak> adimit: exactly
11:33:55 <elliott> That's why newTVarIO and friends exist.
11:33:58 <elliott> So you can use them from inside unsafePerformIO.
11:34:01 <elliott> At least that's what the docs say.
11:34:18 <Cale> But why do you want to do that?
11:34:44 <elliott> Cale: It... involves unsafeIOToSTM.
11:35:01 <Cale> ... don't use that then?
11:35:02 <Cale> :)
11:35:07 <elliott> It's just a proof of concept :'(
11:35:08 <shachaf> elliott: I certainly hope that "using unsafeIOToSTM" isn't your only motivation.
11:35:26 <elliott> shachaf: I set myself one Haskell task today and it was to use unsafeIOToSTM. (Not really.)
11:36:45 <Cale> I wonder if I'll seriously regret it if I upgrade to Oneiric Ocelot.
11:37:04 <shachaf> Cale: Have you seriously regretted every other Ubuntu upgrade you've ever made?
11:37:09 <Cale> Ubuntu's upgrades have been nothing but hassle for me for the last several versions.
11:37:21 * shachaf has had a similar experience.
11:37:55 <Cale> I really need to just switch back to Debian, but that's even more trouble :P
11:38:14 <elliott> Cale: I decided to just stop updating once Unity happened, and my life since has been excellent up until the point I decided I couldn't avoid it forever
11:38:21 <elliott> which marked a dramatic drop in happiness
11:38:27 <Tinned_Tuna> Cale: with Ubuntu, I stay away from distupgrade like the plague
11:38:35 <BlankVerse> Cale: try arch ! , great support for haskell packages especially..
11:38:40 <KitB> Is there a good way to track how far along a computation you are in Haskell?
11:38:58 <earthy> KitB: depends.
11:39:15 <earthy> if the computation computes a *list* of results lazily, then yes
11:39:15 <monochrom> you can use ghci's debugger
11:41:18 <Cale> Arch looks like way more of a pain to set up than Debian, or even dealing with Ubuntu's brokenness repeatedly.
11:41:27 <KitB> Cale: Not really
11:41:35 <KitB> It's pleasant if you just follow the guide
11:41:42 <Tinned_Tuna> why not Slackware!?
11:41:55 <KitB> and it's great for those of us who use alternative stuff
11:41:59 <KitB> (like xmonad)
11:42:01 <Cale> https://wiki.archlinux.org/index.php/Beginners%27_Guide -- this guide?
11:42:08 <KitB> Precisely that
11:42:12 <Cale> I know how to do all the stuff in there, but I don't want to have to do it.
11:42:25 <KitB> You don't have to worry about the majority of it
11:42:27 <Cale> That's why I have a linux distribution
11:42:37 <KitB> You just do a base install
11:42:43 <KitB> Then add your DE of choice
11:43:12 <elliott> KitB: "You don't have to worry about it, you just have to do it."
11:43:20 <KitB> elliott: Well it's not a worry
11:43:25 <KitB> It's just typing a few commands
11:43:38 * elliott can confirm to Cale that initial Arch setup is tedious exactly because it's just typing a few commands.
11:43:39 <KitB> It's like doing a really quick and painless Gentoo install
11:43:43 <elliott> Except a few is more like a hundred.
11:43:55 <elliott> There's no thought in it so you don't even get a fake mental reward.
11:43:59 <KitB> elliott: I don't know what you're doing that makes it take that many commands
11:44:10 <KitB> Put in install media
11:44:11 <KitB> boot from
11:44:16 <KitB> /arch/setup
11:44:23 <KitB> or whatever that is
11:44:28 <elliott> If you can get a usable desktop in Arch in ten commands, then you have an overly lax definition of usable
11:44:51 <KitB> !?
11:44:58 <KitB> Let's move this to #haskell-blah
11:45:14 * monochrom watches the degradation from "arch is no worry" to "it's just like gentoo"
11:45:21 <geheimdienst> i have a .hsc file, which i ran cabal build on, which gave me a .hs file. so far so good. now in ghci when i try to ":load Fuse.hs" (note "hs"), it tells me "System/Fuse.hsc:450:32: Illegal symbol '.' in type" (note "hsc")
11:45:53 <elliott> KitB: Nah, let's not.
11:46:14 <KitB> elliott: Why not?
11:48:45 <KitB> No good point, I should be working.
11:51:54 <hpaste> “Dylan Lukes” pasted “Nice little Trifecta” at http://hpaste.org/52819
11:54:50 <dmh> agreed
11:57:55 <sm> hm, where is that Show instance for UTCTime
11:58:46 <MrFenix> @pl (\ x y -> Nothing)
11:58:46 <lambdabot> const (const Nothing)
11:59:28 <monochrom> Data.Time.LocalTime IIRC
11:59:57 <monochrom> at ghci prompt, import enough to get the Show instance, then :Info UTCTime to find out who is responsible
12:00:49 <sm> monochrom: thanks. import Data.Time () did the trick
12:01:07 <monochrom> yes I generally just import Data.Time
12:01:35 * sm did a binary search of 40 imports.. I think your way was better
12:01:58 <monochrom> haha
12:02:30 <shachaf> monochrom: That doesn't help if the module the Show instance comes from isn't the one you usually want to import.
12:02:53 <shachaf> instance Show Foo -- defined in GHC.Prim.Unsafe.Unportable.Instances
12:03:44 <monochrom> that is rare
12:04:33 <shachaf> Not all that rare.
12:06:08 <monochrom> if GHC.Prim.Unsafe.Unportable.Instances happens, with 99% probability it finds its way to Prelude, so no one actually asks to begin with
12:06:25 <geheimdienst> haskell, land of bizarre instances coming from god knows where
12:06:33 <geheimdienst> make that: from simon knows where
12:08:13 <monochrom> when someone actually asks, 99% of the time the question is "where is Show ByteString", and :info's answer is an unexposed module, sure, but by omitting a suitable suffix you arrive at the most specific exposed module
12:34:00 <dylukes> I feel like my haskell is getting more idiomatic.
12:34:01 <dylukes> http://hpaste.org/52819
12:34:47 <MrFenix> @pl (\ (a, a) -> (return a, return a))
12:34:48 <lambdabot> liftM2 (,) return return . snd
12:35:33 <DanBurton> Wasn't really shorter, lambdabot :P
12:35:40 <MrFenix> @pl (\ f (a, a) -> (f a, f a))
12:35:40 <lambdabot> (. snd) . (ap =<< ((,) .))
12:35:44 <MrFenix> :D
12:35:46 <MrFenix> hahaha
12:35:51 <tew88> I've defined a data type 'Coin' with two value constructors (Heads and Tails.) I'm wanting to simulate a coin flip. I'm using: random ( mkStdGen n ) :: ( Coin, StdGen ), but get a compiler error saying that there's "No instance for (Random Coin)". Where do I place this type definition? (Disclaimer: I'm a novice, just trying to jump ahead to test something out)
12:36:05 <dylukes> do notation is silly.
12:36:20 <dylukes> Who needs it :)
12:36:24 <DanBurton> @let map2 f (a,b) = (f a, f b)
12:36:25 <lambdabot>  Defined.
12:36:28 <byorgey> MrFenix: return *** return
12:36:28 <jweofijm> @pl \x y -> (x, y)
12:36:28 <lambdabot> (,)
12:36:40 * DanBurton hearts do notation
12:36:43 <MrFenix> thank you @ byorgey
12:36:44 <dylukes> tew88: Could you paste the relevant code?
12:36:59 <c_wraith> :t join (***)
12:37:00 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
12:37:12 <DanBurton> @pl (\f (a,b) -> (f a, f b))
12:37:12 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
12:37:20 <DanBurton> wtf o_O
12:37:33 <byorgey> tew88: do you know about type classes?
12:37:36 <c_wraith> > join (***) (+1) (3, 7)
12:37:37 <lambdabot>   (4,8)
12:37:41 <tew88> dylukes: http://hpaste.org/52821
12:38:02 <tew88> byorgey: To an extent!
12:38:14 <byorgey> tew88: well, you need to make an instance of the Random type class for your Coin type
12:38:20 <byorgey> tew88: http://hackage.haskell.org/packages/archive/random/latest/doc/html/System-Random.html#t:Random
12:38:27 <tew88> Ahha. Thanks :)
12:38:28 <byorgey> tew88: you just need to implement randomR and random
12:38:53 <tew88> Excellent. Thanks for the pointers!
12:38:58 <byorgey> tew88: which you can implement simply by using the existing Random instance for Bool and converting to Coin
12:39:03 <dylukes> bte
12:39:04 <dylukes> btw*
12:39:05 <dylukes> http://hpaste.org/52819
12:39:10 <dylukes> am I doing the statement/expression/term thing right?
12:39:24 <dylukes> All my terms are expression though :P.
12:40:20 <dylukes> I also don't know how this magically makes "1.0 + 2.0 + 3.0" work...
12:40:36 <sm> when you call throw in a do block you can be pretty sure the following line isn't executed - right ?
12:40:37 <dylukes> 1.0 + 2.0 is still an expression (not a term)
12:40:40 <byorgey> tew88: by the way, randomness in Haskell tends to be more difficult/annoying than in imperative languages, because of the requirement of purity
12:41:08 <byorgey> tew88: so if you get frustrated I hope you won't conclude that the entire language is annoying =)
12:41:21 <EvanR-work> alternatively, the randomness makes way more sense
12:41:40 <EvanR-work> most systems dont give you the option of saving and restoring a generator
12:41:45 <byorgey> well, from a certain point of view, yes =)
12:41:45 <EvanR-work> with the stdlib
12:42:07 <luite> it is easier to not make mistakes making a repeatable random process in haskell :)
12:42:10 <tew88> byorgey: I've invested in dead-tree books. I'm motivated and determined... at the moment at least ;)
12:42:18 <byorgey> tew88: great =)
12:42:21 <EvanR-work> also in normal systems you usually dont have a REAL guarantee that your results are sufficiently random
12:42:26 <byorgey> tew88: well, feel free to ask lots of questions in here
12:42:33 <EvanR-work> because the generator gets reset in an unpredictable way
12:42:53 <luite> EvanR-work: hmm, whcih systems do that? and how is haskell better?
12:43:01 <EvanR-work> php javascript
12:43:13 <EvanR-work> C (if you dont seed)
12:43:22 <tew88> byorgey: I'm certain it'll be a useful resource! Is there somewhere that I can view the sourcecode for the implementations of random for other types?
12:43:36 <dylukes> EvanR: There's an easy solution.
12:43:38 <luite> in haskell you often have to split generators, the theory of which is rather shaky
12:43:39 <tew88> As in... somewhere standard, other than hitting Google
12:43:59 <dylukes> Connect an ardunio to your computer, read the value in an un-plugged analog input pin.
12:44:04 <EvanR-work> luite: why would you often have to split generators
12:44:06 <dylukes> Hurray for random static in the air.
12:44:13 <DanBurton> so what exactly is Text.Trifecta?
12:44:26 <EvanR-work> dylukes: thats not even good enough a lot of the time
12:44:27 <dylukes> DanBurton: Edwardk's parser combinator library. It's <3.
12:44:37 <DanBurton> what's so special about it?
12:44:38 <dylukes> EvanR-work: Put 9999 monkeys with alphasmarts in a room.
12:44:53 <dylukes> DanBurton: It has built in diagnostics, error reporting, syntax highlighting...
12:45:00 <dylukes> all figured out just from your parsers.
12:45:05 <luite> EvanR-work: it depends on your system of course, but if you have some pure-ish part that requires some unknown amount of randomness, it's usually much easier to give it an infinite list than to make everything monadic
12:45:17 <EvanR-work> i agree
12:45:17 <byorgey> tew88: yes, search for things on hoogle:  haskell.org/hoogle, click through to the documentation, then click on the "Source" links on the right-hand side
12:45:20 <dylukes> for example
12:45:31 <dylukes> https://gist.github.com/1296506
12:45:32 <byorgey> tew88: don't search for Haskell documentation on google, you are likely to get old versions of things
12:45:34 <EvanR-work> luite: was that supposed to contradict anything i said?
12:45:44 <dylukes> DanBurton: ^ see above
12:45:48 <MrFenix> @pl (\ x -> f x x)
12:45:48 <lambdabot> join f
12:45:57 <luite> EvanR-work: well, there isn't really a good way to do that other than splitting a generator
12:45:57 <dylukes> tew88: Always add inurl:hackage
12:46:05 <dylukes> tew88: Then you can find the most up to date stuff.
12:46:07 <luite> EvanR-work: unless that's the only place in the program where you need randomness
12:46:18 <byorgey> tew88: many of the Random instances are defined here: http://hackage.haskell.org/packages/archive/random/latest/doc/html/src/System-Random.html#Random
12:46:53 <tew88> byorgey, dylukes: Thank you. I'll go and tinker and come back later if I run into any problems.
12:46:58 <EvanR-work> luite: id avoid splitting
12:47:28 <EvanR-work> and infinite lists arent really practical
12:47:35 <luite> EvanR-work: that's possible, but then haskell is likely to be less convenient
12:48:14 <EvanR-work> less convenient than what?
12:48:22 <byorgey> dylukes: no, google ends up finding old versions of things on Hackage too
12:48:32 <byorgey> Hackage archives all versions of everything ever.
12:48:37 <dylukes> byorgey: Ys, but you can click to the newest version.
12:48:42 <luite> EvanR-work: than an impure language where you can just call rand() or similar, that mutates the rng behind the scenes
12:48:42 <dylukes> So it gets you there faster.
12:48:57 <byorgey> well, but you have to know that.
12:49:01 <EvanR-work> luite: like i said, those suck for various reasons
12:49:19 <dylukes> it makes me happy when numterm = NumExpr <$> (try double <|> fromIntegral <$> natural) makes perfect sense.
12:49:25 <dylukes> and so forth
12:49:31 <dylukes> applicative notation is satisfying and nice.
12:49:44 <EvanR-work> restoring a generator and inability to handle sane generator resets (like if the script reloads)
12:49:45 <luite> EvanR-work: you can just replace the usual rand with a high quality rng and make sure you properly seed it. that's just a limitation of the standard lib, not the language
12:49:58 <edwardk> preflex: xseen byorgey
12:49:59 <preflex>  byorgey was last seen on freenode/#haskell 1 minute and 1 second ago, saying: well, but you have to know that.
12:50:05 <DanBurton> It seems strange to me that the Random class requires you to implement randomR. What if the data type you're working with isn't ordered?
12:50:06 <EvanR-work> luite: i began this diatribe by complaining about standard libs
12:50:09 <luite> perhaps not php or js, but surely in the "more serious" languages
12:50:17 <dylukes> luite: You're implying rand in any other language is a true RNG.
12:50:29 <byorgey> hey edwardk
12:50:32 <EvanR-work> uhm what is more serious than php, js, and C
12:50:32 <dylukes> rand/rand32/jrand(48)/arc4_random/random/...
12:50:36 <dylukes> non of them are true RNGs.
12:50:37 <EvanR-work> and haskell
12:50:42 <dylukes> They're all just PRNGs.
12:50:49 <dylukes> The only true randomness you can get is to read out of /dev/random
12:51:01 <EvanR-work> dont be dogmatic, thats arguably not random either
12:51:14 <dylukes> EvanR-work: Depends.
12:51:20 <luite> dylukes: no, I just say that it's possible to get a higher quality RNG without problems, perhaps I should say PRNG to make it explicit that I'm still talking about repeatable random processes
12:51:20 <EvanR-work> and bohmian mechanics would say the same thing about quantum physics
12:51:22 <dylukes> On some systems /dev/random is limited (blocking) randomness.
12:51:30 <dylukes> On some it's an alias to /dev/urandom, which is just yarrow.
12:51:43 <dylukes> (or sometimes its both, and has true randomness until it runs out)
12:51:45 <EvanR-work> i wasnt referring to that
12:52:18 <dylukes> luite: I think on a computer it's almost always fair to just imply PRNG by RNG...
12:52:36 <EvanR-work> the distinction is meaningless
12:52:55 <EvanR-work> perhaps you want to make a distinction between computational rng and physical rng
12:53:00 <EvanR-work> but it doesnt make any more random
12:53:22 <EvanR-work> depending on your interpretation of quantum mechanics and chaos
12:53:36 <dylukes> Computational PRNG's are predictable though.
12:53:38 <EvanR-work> pseudo sounds disrespectful ;)
12:53:43 <dylukes> Physical ones are not because you don't have enough information.
12:53:53 <EvanR-work> or other reasons
12:53:54 <dylukes> (and theoretically, you cannot have enough information, if you want to be pedantic)
12:53:54 <DanBurton> Or if you want to get all philosophical, you could simply say randomness does not exist at all.
12:53:59 <luite> EvanR-work: well there's an important semantic difference, in haskell you can do more "cheating" with efficient splitting, if you assume that you're working with a non-repeatable RNG
12:54:06 <dylukes> (Uncertainty Principle n'at)
12:54:24 <EvanR-work> dylukes: youre just saying you dont have a computable model, and if you do have a computable model, it doesnt make it predictable, see halting turing machines
12:54:39 <dylukes> mm, true
12:54:56 <EvanR-work> so computable vs physics is a better disctinction
12:54:59 <EvanR-work> physical
12:55:52 <EvanR-work> DanBurton: thats what im saying ;)
12:58:02 <EvanR-work> another interesting question is whether there is a theoretical difference between a high quality RNG algorithm and a high quality RNG with physical source of entropy
12:58:07 <EvanR-work> if you only have the output
12:59:33 <luite> one theoretical difference is of course the Kolmogorov complexity
12:59:53 <luite> not that that's terribly useful in general :0
13:00:08 <EvanR-work> heh, ok so you only have the output
13:00:20 <EvanR-work> and you take the kolmogrov complexity of each
13:00:22 <EvanR-work> what do you get ;)
13:01:03 <EvanR-work> for the algorithm, you may or may not get your code
13:01:16 <EvanR-work> for the physical generator, you dont get your code
13:01:21 <EvanR-work> because there is no code
13:01:21 <luite> well it's not computable, but you have an upper bound with the algorithm
13:01:30 <mokus> for the algorithmyou get a finite number
13:01:35 <EvanR-work> i didnt ask for it to be computed
13:01:38 <mokus> for a truly random sequence you may not
13:02:13 <luite> mokus: you can not, otherwise it's not truly random :)
13:02:13 <EvanR-work> take a finite slice of the generator, like the history of the universe
13:02:16 <mokus> it doesn't have to be the code you started with in the PRNG case, and more than likely it wouldn't
13:02:28 <mokus> luite: real numbers are rationals, just not vice versa
13:02:30 <EvanR-work> now will you get numbers that are wildly different for KC
13:02:50 <mokus> luite: i would argue that a 'truly random' sequence can appear structured by pure chance
13:03:02 <EvanR-work> luite: i did not say that one of the streams was purely random
13:03:50 <mokus> luite: it just happens to be a probability-0 event
13:05:51 <EvanR-work> someone was talking about 'truely random' and i was discounting that, instead talking about algorithms (with infinite space ;) vs an algorithm connected to a loose transistor ;)
13:06:15 <EvanR-work> whats the difference
13:06:59 <luite> dunno I don't want to get all too philosophical with determinism in physics, don't know enough about it
13:07:07 <mokus> for finite output, there is no difference - for the full infinite sequence, luite has it right - kolmogorov complexity is the easiest way to find a difference
13:07:23 <ranveer5289> can someone direct me to good video tutorial resources related to haskell...
13:07:30 <EvanR-work> mokus: does that work for infinite space?
13:07:49 <luite> EvanR-work: infinite space for what?
13:07:51 <mokus> if your program can be infinite, though, then you've essentially defined a program with a random oracle, and then you're just giving an alternate definition of "truly random"
13:07:57 <EvanR-work> memory
13:08:20 <mokus> oh, just infinite memory? then kolmogorov complexity still applies
13:08:29 <mokus> i thought you meant the program's text could be infinite
13:08:34 <luite> EvanR-work: with a PRNG you usually assume that your initial state is finite, that's all that matters
13:08:41 <EvanR-work> no you have finite program to start with and an infinite tape for keeping track
13:08:58 <mokus> kolmogorov complexity refers to the size of the program text
13:09:17 <mokus> so the existence of any program that outputs a sequence witnesses an upper bound on that sequence's kolmogorov complexity
13:09:20 <luite> which includes the seed in this case
13:09:29 <EvanR-work> yes
13:09:34 <mokus> yes, the seed must be considered part of a program
13:10:00 <mokus> for a "random" sequence, though, there need not exist a finite program which can output the sequence
13:10:31 <mokus> so, its kolmogorov complexity is not defined (or is infinite, if you prefer)
13:11:01 <EvanR-work> i guess to determine whether the transistor based algorithm is truely random youd need to know if the universe were computable
13:11:07 <mokus> for a finite prefix of the output, though, there is no difference - every finite sequence is computable
13:11:35 <mokus> yep, that's ultimately a phileosophical question
13:11:42 <mokus> i don't believe science can ever resolve it
13:12:43 <EvanR-work> in the mean time a pretty mediocre sized program + seed would be practically indistinguishable
13:13:03 <EvanR-work> and higher performance than linux /dev/random
13:13:27 <mokus> unless you know any interesting statistical properties of the particular sequences generated by the program
13:14:33 <EvanR-work> gah
13:19:41 <roconnor> EvanR-work: isn't it called /dev/urandom ?
13:19:59 <roconnor> I mean the mediocre sized program + seed is /dev/urandom
13:20:03 <adrian65436534> hey new haskell user here
13:20:17 <adrian65436534> http://pastebin.com/yP6gpg35
13:20:19 <mauke> The paste yP6gpg35 has been copied to http://hpaste.org/52822
13:20:37 <adrian65436534> why am i getting   "Couldn't match expected type `HTree' with actual type `[t0]'"
13:20:50 <adrian65436534> printTable ['h', ['j','k'] ]
13:21:06 <erus`> adrian65436534: that list is invalid
13:21:23 <erus`> [['h'], ['j', 'k']] maybe?
13:21:33 <monochrom> because ['h', ['j','k'] ] is not even a HTree
13:21:45 <roconnor> ['h', ['j','k'] ] is a list.  You need to write (Branch (Leaf 'h') (Branch (Leaf 'j') (Leaf 'k'))) instead
13:21:52 <monochrom> it is the same hopelessness as printTable True
13:22:06 <EvanR-work> roconnor: theres still a program involved with /dev/random
13:22:13 <roconnor> acutally ['h', ['j','k'] ] isn't even a well-typed list
13:22:25 <DanBurton> adrian65436534: btw, welcome to Haskell! :)
13:22:28 <EvanR-work> its not raw measurements of your sound card or something
13:22:29 <roconnor> EvanR-work: oh interesting; to remove bias?
13:22:46 <EvanR-work> roconnor: and a limiter for measuring 'entropy'
13:22:50 <EvanR-work> so it knows when to block
13:22:54 <roconnor> pfft
13:22:56 <roconnor> lame
13:23:38 <EvanR-work> you generally cant take any real life measurement and expect to use it as a rng
13:24:07 <monochrom> even if you read from a Geiger counter, you still need post-processing
13:24:39 <roconnor> EvanR-work: why not after post-processing?
13:25:01 <roconnor> I mean after the Feynmann bias removal post-processing
13:25:38 <roconnor> Well, I guess if you are only using partially random sources
13:25:41 <roconnor> like mouse movements
13:25:51 <roconnor> okay
13:26:01 <erus`> int rand() { return 4; }
13:26:11 <erus`> chosen by dice roll
13:26:15 <erus`> xkcd
13:26:41 <DanBurton> @google xkcd rand fair dice roll
13:26:42 <lambdabot> http://xkcd.com/221/
13:26:43 <lambdabot> Title: xkcd: Random Number
13:26:46 <EvanR-work> roconnor: yeah but thats just a program ;)
13:27:00 <EvanR-work> you know whats almost random, the cosmic background radiation
13:27:00 <monochrom> PGP asks you type monkey-type at the keyboard until its postprocessor feels it is enough. (it measures inter-key time)
13:28:04 <Ke> http://loldebian.files.wordpress.com/2008/05/randomness.png =oP
13:28:20 <erus`> lol
13:29:03 <adrian65436534> Thank you roconnor, monochrome and DanBurton
13:29:10 <adrian65436534> i understand now
13:29:55 <DukeDave> I recently installed an SSH client for my Android phone which has a nice touch for gathering entropy:
13:29:55 <DukeDave> http://www.youtube.com/watch?v=i0wBmC-5Vu0       (from 25secs)
13:30:04 <kmc> shake the phone?
13:31:01 <erus`> why not read the radio noise
13:31:06 <erus`> true randomness
13:31:13 <adrian65436534> Anyone here develop haskell on a mac? What IDE do you use if any?
13:31:14 <kmc> it's probably harder to access
13:31:39 <luite> adrian65436534: not really an IDE, but I use emacs
13:31:56 <luite> not only on mac, but also on linux and windows :)
13:32:09 <kmc> phones have an applications processor running android or whatever, and a completely separate baseband processor that handles radio stuff and usually runs a proprietary RTOS
13:34:05 <erus`> root the phone :)
13:34:18 <adrian65436534> ah ic
13:34:19 <DukeDave> Ooh, I wonder how good GPS data would be
13:34:25 <adrian65436534> i use leksah but it crashes all the time
13:34:27 <DukeDave> That's got to be quite noisy
13:34:51 <kmc> erus`, root on the Linux install running on the applications processor gives you no special power over the baseband processor
13:35:28 <erus`> reverse the driver?
13:35:42 <kmc> driver?
13:35:47 <erus`> ok plug a usb radio antenna into the phone
13:36:10 <kmc> i want to store a set of points in R2, such that I can efficiently ask for the points in order of increasing distances from some point
13:36:22 <erus`> and carry round a car battery in a backpack
13:36:31 <kmc> the KdTree package looks suitable, but are there any others
13:37:31 <kmc> in particular it would be nice if i could get a lazy list of *all* the points in sorted order, and not just the k closest ones
13:39:10 <erus`> kmc: whatcha making?
13:40:08 <kmc> just a graphics project
13:40:46 <DanBurton> "lazy" and "sorted" don't usually work together
13:40:56 <kmc> sure they do
13:41:19 <kmc> you can write a comparison sort for lists which produces the first element in O(n) time
13:41:31 <kmc> that's nice because then «minimum = head . sort»
13:42:43 <DanBurton> I suppose so
13:43:54 <DanBurton> though you need to inspect the entire list in order to sort at all, requiring O(n) space
13:44:52 <DanBurton> <<minimum = foldl1 min>> is a more likely candidate for being optimized into O(1) space
13:45:03 <kmc> *nod*
13:45:22 <hpc> but if you are going to be sorting anyway, it's convenient to know you can just do that
13:45:27 <kmc> but the point with «minimum = head . sort» isn't performance, it's composability
13:45:50 <DanBurton> composability with what?
13:46:10 <DanBurton> Not sure I catch your drit
13:46:12 <DanBurton> *drift
13:47:38 <kmc> well it's a digression but
13:47:40 <kmc> i used it recently to argue that lazy evaluation makes programs more composable
13:47:53 <kmc> because the producer knows how to do something and the consumer decides how much of it is done
13:47:59 <kmc> decoupling these things
13:48:16 <DanBurton> ah
13:48:27 <kmc> i think Hughes made the same argument in "Why functional programming matters"
13:48:32 <kmc> with different examples
13:48:43 <DanBurton> that certainly makes sense
13:49:31 <DanBurton> and you're certainly right that a lazy sort can be composed nicely with head, requiring only the first element of the sorted list to be determined
13:50:13 <DanBurton> my point was simply that any form of sorting forces the spine of the list it attempts to sort
13:50:36 <kmc> yeah
13:51:12 <DanBurton> well in fact in order to make comparisons, it basically forces deepseq on the list, or rather, seq deep enough to perform comparisons
13:51:19 <kmc> a sort can't be a lazy consumer so much, but it can be a lazy producer
13:51:28 <DanBurton> yes
13:51:30 <DanBurton> that
13:53:35 <shachaf> Hooray, you can use a function in its own view pattern.
13:53:48 <kmc> :O
13:54:00 <kmc> do you have a particularly mind-bending exmalpe
13:54:04 <shachaf> No. :-(
13:54:09 <shachaf> That's what I was hoping someone would present.
13:54:46 <roconnor> shachaf: as in using the function recursively to make a view pattern?
13:54:54 <Twey> That's terrifying
13:55:15 <shachaf> roconnor: Yes.
13:55:20 <kmc> length [] = 0; length (_ : length -> n) = 1 + n
13:55:35 <kmc> that's not so mind-bending
13:57:33 <byorgey> hah, neat =)
14:00:35 <roconnor> kmc: ... I almost prefer that
14:00:59 <kmc> also KdTree doesn't seem to have an efficient way to add points on the fly
14:01:05 <kmc> but maybe there is no such way with kd-trees
14:08:59 * steakknife wonders which haskell packages for ontologies && graph dbs are good.
14:14:16 <jweofijm> @pl \a b c d -> a d b c
14:14:16 <lambdabot> (flip .) . flip
14:14:52 <d-snp> hey, I'm trying to understand monads, and I get the feeling a monad is like a lambda
14:15:07 <d-snp> is that somehow true? :P
14:15:24 <kmc> no
14:15:45 <kmc> a monad is a type constructor
14:15:52 <kmc> supporting operations "return" and (>>=)
14:16:02 <kmc> and obeying certain laws regarding them
14:16:25 <d-snp> "One should read “M a” as the type of a computation that returns a
14:16:27 <d-snp> value of type a"
14:16:29 <kmc> monads don't have very much in common
14:17:01 <kmc> so it's a fool's errand to come up with an analogy which encompasses all of them
14:17:11 <kmc> the 'computation' analogy is okay but not perfect
14:17:26 <augur> im in some sort of absurd discussion on reddit with some knob who doesnt understand what im saying
14:17:30 <augur> about haskell
14:17:37 <augur> so frustrating
14:17:37 <dmwit> d-snp: There is a beautiful paper by Phil Wadler which gives a lambda-like syntax for Arrows. It turns out any Monad gives rise to an Arrow (called the Kleisli Arrow). So there is some connection.
14:17:57 <kmc> augur, happens all the time
14:18:17 <augur> kmc: its about that haskell post mortem post
14:18:17 <kmc> don't waste your time posting in reddit comment threads
14:18:36 <augur> and i took issue with the claim that code written in haskell is a small subset of code that works
14:18:46 <augur> primarily on the grounds that the same is true for any language
14:18:50 <steakknife> god, reddit is craigslist with voting.
14:19:20 <kmc> if I wanted to hear about someone being wrong on reddit I would read reddit
14:19:30 <steakknife> heh
14:19:39 <d-snp> dmwit: is it called "the arrow calculus" ?
14:19:51 <donri> i found that after i understood monads, all the analogies made sense
14:20:03 <dmwit> d-snp: it is
14:20:04 <kmc> i find that they make less sense than ever
14:20:11 <donri> tldr they just confuse you if you don't already understand monads
14:20:23 <kmc> like, is Maybe Int a "computation"?
14:20:27 <kmc> no it's just an Int or Nothing
14:20:41 <donri> but that's not maybe-as-a-monad?
14:21:01 <kmc> you just look at what (>>=) does and decide whether it's useful for you
14:21:05 <kmc> like any other function
14:21:16 <donri> anyway i meant mostly the joke-analogies "monads are space suits" etc
14:21:22 <DukeDave> d-snp: Has someone mentioned the Typeclassopedia yet? That has helped me no end..
14:21:33 <donri> they make joke-sense past understanding monads (but don't help in gaining that understanding)
14:21:38 <DanBurton> @where typeclassopedia
14:21:39 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:21:40 <steakknife> ➨.ws/monads_tutorial btw
14:21:53 <kmc> i think the original "space suits" analogy was not intended as a joke
14:22:06 <DukeDave> Oh a side note, isn't there some kind of "monadic if/else" of the form: Bool -> (a -> m b) -> (a -> m b) -> a -> m b
14:22:08 <kmc> and lots of others in that vein
14:22:23 <kmc> that *is* if/else
14:22:40 <kmc> :t if True then return else return
14:22:41 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:22:41 <steakknife> The monadic laws seem the best way, at least for me, to understand how they work.
14:22:42 <DukeDave> Ha, sorry, my Bool is in m
14:22:47 <DanBurton> now it would be different if you had a <<m Bool>>
14:22:52 <companion_cube> monads are like space suits <-- if you open them with unsafOpenSpaceSuit, you die?
14:23:14 <DukeDave> DanBurton: I do :)
14:23:15 <DanBurton> DukeDave: no that's not predefined
14:23:23 <kmc> no, the one-way property of IO is special to IO and is not a property of monads in general
14:23:26 <DanBurton> :t ifM
14:23:27 <lambdabot> Not in scope: `ifM'
14:23:50 <Peaker> Monads are like Applicatives, where you're allowed to fuse wrapped values even in the "inside" position
14:23:58 <DanBurton> @let ifM b t f = do v <- b; return (if v then t else f)
14:23:59 <lambdabot>  Defined.
14:24:03 <DukeDave> Ooh, I see it here: http://hackage.haskell.org/packages/archive/yjtools/latest/doc/html/src/Control-Monad-Tools.html#ifM
14:24:04 <kmc> and you couldn't write a reasonable function « (Monad m) => m a -> a » no matter how "unsafe" you allow it to be
14:24:08 <Peaker> (in many monads, translating to peeking at the results)
14:24:14 <d-snp> how come this channel is always so active
14:24:19 <d-snp> and full with helpful people?
14:24:21 <DanBurton> we were talking about thise the other day
14:24:36 <DukeDave> DanBurton: ifM is exactly what I wanted, and I'm using it in exactly the way it is defined :D
14:24:41 <Peaker> d-snp: Haskell makes us so productive we write all the code in the first 10 minutes of the day, and have the rest of the day off :)
14:24:42 <DanBurton> d-snp: Haskell has this weeeeird effect on some academics, making them insanely helpful
14:24:49 <steakknife> :D
14:25:08 <DanBurton> > ifM (Just True) (Just 7) Nothing
14:25:09 <lambdabot>   Just (Just 7)
14:25:22 <DanBurton> oh should probably not bother with the return
14:25:26 <DanBurton> @undefine
14:25:29 <DukeDave> s/have the rest of the day off/write more monad tutorials
14:25:36 <DanBurton> @let ifM b t f = do v <- b; if v then t else f
14:25:37 <lambdabot>  Defined.
14:25:41 <DanBurton> > ifM (Just True) (Just 7) Nothing
14:25:43 <lambdabot>   Just 7
14:25:47 * hackagebot air 2011.10.19 - air  http://hackage.haskell.org/package/air-2011.10.19 (JinjingWang)
14:26:05 <kmc> i'm here because helping people with beginner questions and complaining about Java and PHP is a lot easier than writing useful software and solving problems
14:26:12 <DanBurton> :t bool
14:26:12 <lambdabot> Not in scope: `bool'
14:26:19 <DanBurton> @let bool b t f = if b then t else f
14:26:20 <lambdabot>  Defined.
14:26:21 <DukeDave> DanBurton: Am I crazy to think that should be in the Prelude? Or at least Control.Monad?
14:26:38 <DanBurton> > liftM2 bool (Just True) (Just 7) Nothing
14:26:39 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a -> t'
14:26:39 <lambdabot>         against infe...
14:26:43 <DanBurton> boo
14:26:45 <DukeDave> kmc: Have you ever considered being a politician? ;)
14:26:47 <DanBurton> :t liftM2 bool
14:26:48 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m (a2 -> a2)
14:26:53 <kk`> :t ($)
14:26:54 <lambdabot> forall a b. (a -> b) -> a -> b
14:26:55 <dmwit> :t liftM bool
14:26:56 <lambdabot> forall t (m :: * -> *). (Monad m) => m Bool -> m (t -> t -> t)
14:27:13 <DanBurton> > liftM3 bool (Just True) (Just 7) Nothing
14:27:15 <lambdabot>   Nothing
14:27:17 <steakknife> DukeDave: have kmc solve things at the policy level?  I'd vote for that. :)
14:27:30 <dmwit> DanBurton: Bad.
14:27:37 <dmwit> DanBurton: It executes both branches every time.
14:27:38 <DanBurton> DukeDave: so the question is, do you write it like ifM, or like liftM3 bool ?
14:27:50 <dmwit> DanBurton: liftM3 bool is different, no?
14:27:51 <DanBurton> dmwit:  right
14:27:56 <dmwit> ah
14:28:20 <DanBurton> I know this because someone showed me that the other day >xD. I thought liftM3 bool would be the same, but it is not
14:28:33 <dmwit> > liftM bool (Just True) >>= \f -> f (Just 7) Nothing
14:28:34 <lambdabot>   Just 7
14:28:38 <hpc> :t bool
14:28:38 <lambdabot> forall t. Bool -> t -> t -> t
14:28:40 <dmwit> ick
14:28:44 <Peaker> kmc: I find myself here when I am forced to wait for my computer.. then it takes me a while to go back being productive
14:28:46 <hpc> :t if'
14:28:47 <lambdabot> Not in scope: `if''
14:28:49 <kmc> liftM3 can also be written for Applicative
14:29:00 <kmc> this ifM is a prototypical example of something Applicative *can't* do
14:29:02 <Saizan> to play with Constraint kinds you need some unreleaded ghc?
14:29:05 <dmwit> > Just True >>= \b -> bool b (Just 7) Nothing
14:29:07 <lambdabot>   Just 7
14:29:11 <DukeDave> steakknife: I was eluding to kmc's statement that he prefers answering questions and complaining, rather that solving problems ;)
14:29:12 <kmc> namely, choose a later action based on the result of an earlier action
14:29:13 <Afzal> why doesn't this line work
14:29:13 <Saizan> *unreleased
14:29:15 <Afzal> @data Bit  = 0 | 1 deriving (Eq, Show)
14:29:15 <lambdabot> Unknown command, try @list
14:29:29 <kmc> Afzal, because data constructors must start with an upper-case letter
14:29:37 <steakknife> Peaker: http://buyafuckingssd.com/ (swearing thanks to crucially)
14:29:44 <adrian65436534> why am i getting "Exception: src/Main.hs:(22,1)-(45,20): Non-exhaustive patterns in function Main.printTable"
14:29:44 <dmwit> ?pl \c t f -> (>>=) c (\b -> bool b t f)
14:29:44 <lambdabot> (. (flip . flip bool)) . (.) . (>>=)
14:29:44 <DanBurton> @src liftM3
14:29:45 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
14:29:53 <adrian65436534> http://pastebin.com/CXWV3Bt8
14:29:53 <Afzal> any alternate that i could try to do this?
14:29:56 <mauke> The paste CXWV3Bt8 has been copied to http://hpaste.org/52823
14:29:57 <kmc> adrian65436534, because your function 'printTable' is missing a case
14:30:01 <dmwit> :t (. (flip . flip bool)) . (.) . (>>=)
14:30:01 <kmc> Afzal, data Bit = Zero | One
14:30:01 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
14:30:06 <Afzal> oh..
14:30:08 <hpc> @src liftA3
14:30:09 <lambdabot> Source not found. Maybe you made a typo?
14:30:22 <dmwit> Afzal: data Bit = O | I; type Bit = Bool
14:30:34 <Afzal> is that O and I letters?
14:30:38 <dmwit> yes =)
14:30:40 <dmwit> a cute hack
14:30:45 <Afzal> no way to use numbers then?
14:30:46 <DukeDave> DanBurton: Why are the two approaches different? :|
14:31:03 <dmwit> instance Num Bit where fromInteger 0 = O; fromInteger _ = I
14:31:09 <dmwit> Afzal: Like that. =)
14:31:13 <DukeDave> Oh I see, does it always evaluate both branches..
14:31:14 <hpc> Afzal: numbers are literals, not identifiers
14:31:16 <Afzal> :D i'll try that
14:31:16 <hpc> so no
14:31:19 <DanBurton> check out the source for liftM3, it executes each action
14:31:20 <Peaker> Afzal: no way to get a compile-time error for 2 :: Bit
14:31:27 <DukeDave> DanBurton: Interesting..
14:31:27 <kmc> DukeDave, s/evaluate/execute/
14:31:29 <adrian65436534> that paste was wrong heres the right one http://pastebin.com/jCpU48iX
14:31:31 <mauke> The paste jCpU48iX has been copied to http://hpaste.org/52824
14:31:31 <Afzal> thanks!
14:31:32 <Peaker> (while allowing 0::Bit,1::Bit)
14:31:43 <Afzal> k
14:31:58 <hpc> you'll also want to implement the rest of Num, if you go thar route
14:32:14 <dmwit> adrian65436534: ack, the parentheses
14:32:32 <DukeDave> kmc: Yes! You open the burrito, not just look what's in side, don't you? :D
14:32:35 <dmwit> adrian65436534: also, ack, the IO, and ack, the repetition
14:32:44 <DukeDave> Well spotted
14:33:04 <dmwit> adrian65436534: ack, the partiality
14:33:08 <adrian65436534> new to haskell sorry :|
14:33:09 <dmwit> adrian65436534: You don't have a case for leaves.
14:33:15 <kk`> :t (&&&)
14:33:16 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:33:19 <Peaker> dmwit: you are the human hlint
14:33:53 <Peaker> adrian65436534: your paste was copied to hpaste, where you get automated feedback from hlint
14:34:10 <dmwit> adrian65436534: If you turn on warnings, the compiler will give you a warning saying you don't have a case for leaves, to, so I recommend it. =)
14:34:28 <Peaker> adrian65436534: You can add as your first line: {-# OPTIONS -Wall #-} to enable warnings
14:34:28 <kmc> yeah you should always use ghc -Wall
14:34:41 <dolio> I don't know.
14:34:47 <dolio> -Wall warns about a lot of stupid stuff.
14:34:47 <Peaker> kmc: lots of people dislike top-level type decl's for everything
14:34:52 <dmwit> s/to,/too,/
14:35:02 <Peaker> but exhaustiveness is an important check
14:35:10 <adrian65436534> hmm ok I'm confused tho i have a case for 1 leaf and 1 branch, then 2 leaves, then 1 branch and 1 leaf, then 2 branches
14:35:17 <kmc> fine "you should always use ghc -Wall and occasionally disable specific warnings for specific files"
14:35:27 <dmwit> adrian65436534: All of your cases begin with Branch. That doesn't strike you as odd?
14:35:37 <dmwit> adrian65436534: Why don't any of your cases begin with Leaf?
14:35:48 <hpc> "you should always never remember to occasionally forget to not enable -Wall"
14:35:51 <dmwit> adrian65436534: (When you answer that, you will see that your function can be simplified rather a lot.)
14:36:09 <dolio> I don't drink poison, every day!
14:36:31 <adrian65436534> i think I'm confused by the syntax lol
14:37:05 <adrian65436534> ill fool around with it and check back in
14:37:09 <adrian65436534> thanks for the help
14:38:12 <Cale> adrian65436534: What should printTable (Leaf 'a') do?
14:38:18 <dmwit> adrian65436534: What would...
14:38:21 <dmwit> what Cale said.
14:38:51 <DanBurton> Man someday I should get around to making a typical .hs template file to start out with, including -Wall, -O2, and maybe even  -NoImplicitPrelude
14:38:53 <adrian65436534> OHHHHHHHH
14:39:01 <adrian65436534> i don't have a function to handle just one leaf
14:39:04 <dmwit> DanBurton: Don't forget NoMonomorphismRestriction!
14:39:04 <adrian65436534> DOH
14:39:18 <DanBurton> dmwit: YES that too
14:39:21 <kmc> i specify -Wall in my cabal files
14:39:26 <kmc> (and cabal does -O by default)
14:39:31 <kmc> DanBurton, why -XNoImplicitPrelude?
14:39:42 <DanBurton> I want to start using a cooler Prelude
14:39:47 <DanBurton> Not sure which one to pick yet
14:39:51 <DanBurton> Maybe I'll make my own
14:40:02 <Cale> I think the signal/noise ratio with -Wall is too low
14:40:19 <dmwit> Is there a -WsomeL
14:40:24 <dmwit> s/L/?/
14:40:33 <hpc> -Wall isn't a substitute for just learning the language style, in any event
14:41:34 <steakknife> btw concurrent editing scratchpad: http://piratepad.net/haskell (free fork pre-acquisition, yay)
14:42:37 <hpaste> DanBurton pasted “man ghc (warnings section)” at http://hpaste.org/52825
14:43:36 <DanBurton> That was from ghc 6.12.3
14:44:18 <DanBurton> steakknife: yay multiplayer Haskell!
14:44:24 <kmc> i don't buy the "-Wall is too noisy" claim
14:44:43 <kmc> I've written a lot of -Wall-clean Haskell code
14:44:59 <steakknife> Dan: :D
14:45:24 <steakknife> that would be pretty cool… some ghci plugin that adds an invite code.
14:45:40 <DanBurton> Doesn't look like it's made for code, though
14:46:16 <steakknife> It's pretty fun to see live changes though.
14:46:20 <DanBurton> yeah
14:46:46 <dafis> kmc: most of my code is -Wall clean when I'm done with it
14:46:48 <sagelywizard> Do the Haskell libcurl bindings support the HTTP DELETE method? Pardon my density, but I can't seem to find any reference to non-GET/PUT/POST/HEAD methods.
14:47:02 <steakknife> The time slider is pretty neat, all versions are saved.
14:55:53 <hpc> sagelywizard: i didn't think any of the headers were really used besides GET/POST and very rarely HEAD
14:57:29 <kmc> REST? WebDAV?
14:57:59 <rferranti> i use PUT a lot
14:58:22 <luite> I use PUT and DELETE in my wiki, at least I have implemented it on the server side :)
14:58:41 <donri> I don't always use GET, but when I do it's for destructive data updates.
14:58:50 <DanBurton> I'm looking around the bindings, but I don't really see any easy way to specify which method to use
14:58:54 <d-snp> :D
14:58:54 <rferranti> donri, i love you lol
14:59:00 <kmc> GET /fire/the/missiles HTTP/1.1
14:59:05 <d-snp> :D
14:59:07 <DanBurton> T_T
14:59:13 <hpc> unsafeGETMissles
14:59:25 <donri> HEAD /fire/the/missiles  just checkin' out them headers
15:00:00 <hpc> donri: it still fires the missles, but only outputs the steps it took to launch them, not where it went or if it exploded
15:00:00 <rferranti> warHEADs
15:00:01 <DanBurton> you'd think there would be a type for this. data RestMethod = Head | Get | Post | Put | Delete
15:00:09 <d-snp> GET /fire.php?what=missiles :(
15:00:21 <steakknife> was (.)(.) the missiles operator used elsewhere? ;)
15:00:24 * DanBurton glares at the mention of PHP
15:00:35 <hpc> d-snp: GET /fire.php?what=missles&password=hunter2 -- fixed
15:00:40 <d-snp> :D
15:00:51 <steakknife> PHP, there's the problem. :D
15:00:57 <kk`> :t (.)(.)
15:00:58 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
15:00:59 <hpc> except it would a twitter-style GET string
15:01:08 <hpc> d-snp: GET /fire.php#!what=missles&password=hunter2
15:01:16 <hpc> because who needs standards
15:01:35 <d-snp> so now the question is, what is the correct RESTful way of firing missiles?
15:01:48 <hpc> DELETE /japan
15:01:54 <kmc> hpc++
15:01:56 <steakknife> how many missiles do you have?
15:01:58 <d-snp> are missiles a resource? or is the firing of missiles are resource?
15:02:05 <d-snp> lol.. the target is the resource :P
15:02:10 <rferranti> hpc, good one =)
15:02:51 <sagelywizard> So, is there a Haskell HTTPS client which supports the DELETE method?
15:03:42 <kmc> http://www.foo.be/docs/tpj/issues/vol2_1/tpj0201-0004.html
15:04:27 <mike-burns> The firing is the resource.
15:04:44 <rferranti> firing sounds like an action
15:05:33 <DanBurton> sagelywizard: I'm not familiar with any
15:05:43 <DanBurton> sagelywizard: and my google-fu is not finding any
15:05:53 <kmc> article title: Perl and Nuclear Weapons Don't Mix
15:06:00 <rferranti> also one should keep into consideration you can't use gpl software to fire missiles afaik
15:06:49 <steakknife> POST/DELETE /noun/verb for anything explosive seems appropriate.
15:06:53 <Afzal> list of chars is a string right?
15:06:55 <steakknife> ymmv, but that's how i roll.
15:07:15 <donri> POST /new-missile; PUT /missiles/1 location=them%20nazis&state=exploded; GET /nazis --> 404
15:07:30 * steakknife shudders
15:08:38 <donri> :t "ohai"
15:08:39 <lambdabot> [Char]
15:08:44 <donri> Afzal, ^
15:08:51 <DanBurton> sagelywizard: check out plain old Network.HTTP http://hackage.haskell.org/packages/archive/HTTP/4000.1.2/doc/html/Network-HTTP.html
15:09:03 <donri> > 'h':'i':[]
15:09:03 <lambdabot>   "hi"
15:09:14 <d-snp> CREATE /missiles/firing location=japan
15:09:17 <d-snp> .. I think
15:09:23 <rferranti> i'd expect something like PUT /missiles/1 POST /missiles/1/trigger
15:09:26 <kmc> rferranti, that depends, does delivering a warhead to a target count as distributing binaries
15:09:27 <DanBurton> sagelywizard: the Request type has a RequestMethod http://hackage.haskell.org/packages/archive/HTTP/4000.1.2/doc/html/Network-HTTP-Base.html#t:RequestMethod
15:09:37 <d-snp> I think the firing of missiles is a resource you create..
15:09:49 <shachaf> DanBurton: That's not https, though.
15:10:05 <DanBurton> shachaf: ah, right >,<
15:10:16 <d-snp> the webserver can just respond with the results of the firing
15:10:21 <donri> surely the curl bindings can do it?
15:10:25 <donri> @faq curl?
15:10:25 <lambdabot> The answer is: Yes! Haskell can do that.
15:10:47 <d-snp> ehh s/CREATE/POST ofc
15:11:04 <DanBurton> "Haskell can do that" is not the same as "the library bindings have been written to do that" :P
15:11:13 <donri> ;)
15:11:28 <rferranti> d-snp, why creating with post vs put ?
15:11:33 <Nafai> .
15:11:41 <donri> POST is for creating, PUT is for updating
15:11:42 <steakknife> http://›.ws/RESTful
15:11:54 <rferranti> donri, put is for creating, post is for bulk
15:11:59 <d-snp> rferranti: because you create a new resource instead of updating one
15:12:43 <rferranti> i'm used to create with id = put, create and expect an id to be generated = post
15:13:27 <donri> http://en.wikipedia.org/wiki/Restful#RESTful_web_services disagrees
15:14:02 <rferranti> donri, it doesn't really
15:14:13 <donri> http://en.wikipedia.org/wiki/HTTP_method#Request_methods also says that PUT is for existing resources
15:14:37 <rferranti> ?
15:14:38 <donri> although it says something similar for POST, but also notes that POST may result in creation
15:14:43 <rferranti> Uploads a representation of the specified resource.
15:15:07 <rferranti> doesn't say anything about nor creation nor updating
15:15:17 <donri> also see POST
15:15:41 <rferranti> it just says "may"
15:15:45 <donri> i could certainly be wrong, but it's what i was always taught WRT REST
15:16:02 <DanBurton> steakknife's article says the difference is idempotency. PUT must be idempotent, POST doesn't have to be
15:16:21 <rferranti> DanBurton, yup, i agree with that
15:16:39 <rferranti> that's why i said put = with an id, post = bulk
15:17:01 <DanBurton> so if you are the unsafePerformIO type, then always use POST and forget about PUT
15:17:49 <rferranti> lol
15:18:09 <DanBurton> POST is like PUT++
15:18:38 <rferranti> in my mind post is just "what dirty thing i need to do and can't with other verbs"
15:19:35 <DanBurton> :) that's probably the best way to think about it
15:20:55 <rferranti> i tend to divert conversations into OT, sorry about that and good nite :)
15:21:16 <Philippa> PUT is meant to correspond to mutable variable semantics in some sense whereas POST isn't, basically
15:22:09 <donri> rather, other way around according to that blog post?
15:22:43 <DanBurton> I personally think of PUT like Map.insert
15:22:55 <d-snp> hey, I don't get something about typeclassopedia,it defines a Pointed f, with a pure method
15:23:11 <d-snp> and it looks like pure :: a -> f a
15:23:20 <DanBurton> d-snp: right, what's not to get about that?
15:23:23 <d-snp> how would I call this pure function?
15:23:36 <DanBurton> > pure 3 :: Maybe Int
15:23:37 <lambdabot>   Just 3
15:23:40 <d-snp> ahh
15:23:46 <d-snp> with ::, ok thanks :D
15:23:52 <donri> well.
15:23:54 <DanBurton> :: isn't how you *call* it though
15:24:08 <donri> it's typically inferred from the "context"
15:24:21 <DanBurton> I just used :: to force a specific inferrence
15:24:22 <donri> but there is little context in a single line :)
15:24:32 <d-snp> yeah, that's exactly what I was wondering about :)
15:24:33 <DanBurton> > head $ pure 3
15:24:33 <lambdabot>   3
15:24:38 <donri> do you know monads yet?
15:24:54 <d-snp> still working on it :P, going a bit slow
15:25:12 <DanBurton> > isJust $ pure 3
15:25:13 <lambdabot>   True
15:25:13 <donri> ah. well, pure is exactly the same thing as monadic "return".
15:25:53 * steakknife wonders . . . level of effort to clone EtherPad with a ghci shared-session plugin.
15:26:11 <shachaf> steakknife: How shared do you want it?
15:26:15 <shachaf> There's always screen -x...
15:26:29 <steakknife> was thinking that.
15:26:31 <DanBurton> The Pointed typeclass means exactly what the type signature of "pure" says. Given a Pointed type f, there is always a way to lift a value of type "a" into the Pointed "f a"
15:26:32 <donri> add some omgsocial features to tryhaskell? :)
15:26:37 <steakknife> :D
15:26:40 <steakknife> haha
15:28:10 <donri> "you don't make 500 million type errors without making some enemies"
15:28:19 <donri> tryhaskell: the social network
15:28:31 * DanBurton laughs
15:29:26 * DanBurton wants to make an MMO: "Haskell: Quest for the Perfect Prelude"
15:29:47 <steakknife> The virtual goods would start showing up on eBay.
15:30:02 <luite> donri: I'm trying to do that actually, a tryhaskell wiki with facebook and google logins :)
15:30:03 <DanBurton> Massively Multiplayer Online Haskell Hackathon
15:30:33 <steakknife> Is there some way to spell that as a palindrome?
15:30:48 <DanBurton> o_O! erm...
15:31:00 <rferranti> is Pointed something in between applicative and functor?
15:31:29 <Philippa> it's sideways
15:31:37 <Philippa> basically it's pure from Applicative but no fmap
15:31:50 <Philippa> (let alone ap)
15:32:13 <rferranti> so functor gets fmap, pointed gets pure and applicative both right?
15:32:15 <DanBurton> rferranti: have you seen the diagram in typeclassopedia?
15:32:25 <Philippa> no, applicative has pointed
15:32:25 <DanBurton> basically, yes
15:32:35 <Philippa> sorry, misparse on my part
15:32:35 <rferranti> DanBurton, i'm a complete newbie, i don't know what typeclassopedia is
15:32:37 <Philippa> yeah, you're right
15:32:39 <rferranti> i'll google that
15:32:48 <DanBurton> @where typeclassopedia
15:32:49 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
15:32:50 <Philippa> it's an article well worth reading if you're new
15:32:54 <DanBurton> that's what it is :)
15:32:55 <steakknife> god i love surfraw.
15:33:08 <rata_> hi
15:33:24 <d-snp> :t ($)
15:33:25 <lambdabot> forall a b. (a -> b) -> a -> b
15:33:41 <Philippa> (it'll be in for an interesting update when ConstraintKinds've settled down enough that we have constraintable replacements for the Pointed, Functor & kids family - I've discovered that Monad really wants at least two equivalent classes)
15:34:42 <d-snp> :t (<*>)
15:34:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:35:39 <donri> d-snp, you know you can do that both in ghci and a pm to lambdabot? :)
15:37:44 <DanBurton> is the typeclassopedia diagram available by itself somewhere on the Haskell wiki?
15:38:05 <rferranti> DanBurton, wow that clarifies a lot of doubts
15:38:42 <d-snp> donri: k sry :P
15:38:47 <byorgey> Philippa: indeed! =)
15:39:24 <DanBurton> rferranti: yeah typeclassopedia is pretty amazing. Definitely all Haskellers should read it
15:39:55 <Philippa> byorgey: you know the two I have in mind?
15:39:56 <donri> d-snp, just a friendly suggestion :)
15:40:23 <byorgey> Philippa: no, do tell
15:40:43 <byorgey> Philippa: I just meant "indeed, it will be in for an interesting update!"
15:40:43 <Philippa> ah. So you can pick a constraint that happens to prohibit join, but you get something that's stronger than an Applicative still
15:40:58 <byorgey> really?
15:41:03 <Philippa> whereas signifying "and the constraint supports join" matters
15:41:17 <Philippa> yeah. Stronger because you still get the scoping you expect from do
15:41:33 <byorgey> I'm not really following
15:41:44 <Philippa> (so it's in the ballpark of an arrow with most of the trimmings classes other than the loop and apply ones)
15:42:15 <Philippa> so the obvious way to restrict a monad is you place a typeclass or similar constraint on the values it can 'contain', right?
15:42:25 <Philippa> and then bind only operates on those and can thus take advantage of that constraint?
15:42:52 <byorgey> right
15:43:08 <Philippa> (return's not really supposed to give a toss, but there are circumstances where it's allowable because in some sense the changes its making /are/ equalities in the subcategory of Hask your constraint's defining)
15:43:14 <DanBurton> There what do you guys think? I uploaded the diagram and added it to the wiki: http://www.haskell.org/haskellwiki/Typeclassopedia
15:43:21 <DanBurton> Is that violating any copyright crap?
15:43:29 <byorgey> Philippa: right, ok
15:43:39 <Philippa> (example I've got: you have a constraint system of some sort and return substitutes metavariables for anything you know about them)
15:43:44 <byorgey> DanBurton: awesome, thanks
15:43:50 <byorgey> DanBurton: it is not violating any copyright crap
15:44:12 <Philippa> so. What happens if you didn't include an instance for MyConstraint a => MyConstraint (MyRestrictedMonad a) ?
15:44:38 <Philippa> (and your restricted monad class /doesn't include join/, of course)
15:44:39 <DanBurton> Well if it is, then they can just take it down. All I did was a printscreen from the PDF, and crop -> save via M<S Paint
15:44:47 <byorgey> I see, then you can't type join
15:45:15 <benmachine> what does the bind look like?
15:45:20 <Philippa> yeah. And it turns out to be useful still
15:45:41 <byorgey> Philippa: fascinating.
15:45:47 <benmachine> MyConstraint a, MyConstraint b => m a -> (a -> m b) -> m b?
15:45:53 <byorgey> DanBurton: it definitely isn't =)
15:45:56 <benmachine> or is it MyConstraint a b?
15:45:57 <benmachine> or what
15:46:03 <Philippa> benmachine: the former
15:46:19 <Philippa> I might not've directly required it on b because I wasn't bothering with a typeclass
15:46:39 <benmachine> so then join m = m >>= id gets a type inferred of (MyConstraint b, MyConstraint (m b)) => m (m b) -> m b
15:46:43 <benmachine> I see
15:47:32 * benmachine needs to be in bed rather than thinking about this, though :P
15:47:36 <Philippa> yeah. And that not-actually-a-monad class is /still useful/
15:47:41 <DanBurton> byorgey: is Typeclassopedia under some sort of creative commons license, or is it just kind of out there public domain-ish?
15:48:59 <Philippa> (because the /only/ restriction you get is that the monadic language is first-order on its own computations: you can use higher-order haskell to make decisions about what to run next so long as all the relevant types're allowed under your constraint and you did include an instance for MyConstraint a, MyConstraint b => MyConstraint (a -> b), right?)
15:49:38 <byorgey> DanBurton: since it was published in the Monad.Reader it is under the Monad.Reader license...  aaaand I just realized that isn't really specified anywhere.
15:49:43 <Philippa> DanBurton: you probably know this, but there're multiple uses of public domain in US law (and probably other jurisdictions) and the IP-relevant one is very different to the others
15:50:09 <dmwit> Can ternary search trees be understood as tries where the "next node" is implemented as a binary search tree with character keys?
15:50:14 <DanBurton> byorgey: it might be nice to specify a permissive CC license
15:50:37 <byorgey> DanBurton: yes, I agree
15:50:53 <Philippa> you'd have to get authors' permissions for the existing articles, but yeah
15:51:28 <byorgey> I seem to recall something about previous versions being released under a "BSD-like" license
15:51:31 <byorgey> but I can't find it anywhere
15:51:44 <byorgey> you'd think being the current editor I would know more about this. =P
15:52:13 <DanBurton> :) I'd recommend a plain ol' CC-BY
15:52:58 <dmwit> As the author, you of course have the freedom to release it under multiple licenses.
15:53:03 <byorgey> sounds good to me, at least for future editions.
15:53:15 <dmwit> Even if you don't know the Monad Reader's license, you can choose another license to release it under.
15:53:34 <obiwahn> @src (!!)
15:53:34 <lambdabot> xs     !! n | n < 0 = undefined
15:53:34 <lambdabot> []     !! _         = undefined
15:53:34 <lambdabot> (x:_)  !! 0         = x
15:53:34 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:53:40 <byorgey> I didn't know that but I guess it makes sense.
15:55:06 <byorgey> OK, I hereby release the Typeclassopedia under a CC-BY-NC license.
15:55:09 <rferranti>  how do you pronounce <*> ?
15:55:12 <Philippa> unless the author assigned copyright (possibly implicitly: see the US's "work for hire" provisions) they retain copyright
15:55:18 <Philippa> and thus the right to relicense
15:55:33 <Philippa> rferranti: "ap" usually
15:55:33 <DanBurton> peace out everybody :) stay type-classy
15:55:33 <Philippa> or "apply"
15:55:35 <rferranti> thank you
15:55:39 <Philippa> as in "fmap ap ap ap ap"
15:55:45 <rferranti> ahha
15:56:00 <dafis> :t fmap ap ap ap ap
15:56:01 <lambdabot>     Occurs check: cannot construct the infinite type:
15:56:02 <lambdabot>       a = (a -> a1 -> b) -> a
15:56:02 <lambdabot>       Expected type: ((a -> a1 -> b) -> a -> a1) -> a -> a1 -> b
15:56:21 <hpc> :t ap ap ap ap
15:56:22 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
15:56:22 <lambdabot>     Probable cause: `ap' is applied to too few arguments
15:56:22 <lambdabot>     In the second argument of `ap', namely `ap'
15:56:39 <hpc> we need to go deeper!
15:56:51 <hpc> :t fix ap
15:56:52 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
15:56:52 <lambdabot>     Probable cause: `ap' is applied to too few arguments
15:56:53 <lambdabot>     In the first argument of `fix', namely `ap'
15:57:03 <Philippa> dafis: you're supposed to intersperse values! Also remember to use a non-borken Prelude :p
15:57:13 <c_wraith> :t fix (ap ?f)
15:57:14 <lambdabot> forall (m :: * -> *) b. (?f::m (b -> b), Monad m) => m b
15:58:53 <obiwahn> how is !! pronounced?
15:59:14 <c_wraith> I just don't use it, to avoid that conundrum.
15:59:19 <shachaf> c_wraith++
15:59:21 <dafis> bang-bang
15:59:23 <shachaf> "not not"
15:59:27 <dafis> (just kidding)
16:00:10 <dmwit> obiwahn: How is a[b] pronounced in C?
16:00:20 <c_wraith> obiwahn: actually, I don't use it because it's rarely actually what I want.  Avoiding that conundrum is a side-effect.
16:00:30 <evincar> dmwit: "a sub b"
16:00:43 <dafis> *(a+b)
16:01:38 <evincar> So, I've got a minor problem with a program, if anyone would be willing to help me work through it.
16:02:01 <dafis> wel?
16:02:07 <dafis> *ll
16:02:21 <dmwit> int main() { int x[32]; 0[x] = 1[x] = 64; return printf("%d\n", *x); }
16:02:46 <c_wraith> evincar: go ahead and hpaste it
16:03:19 <shachaf> evincar: Unfortunately this channel is full of mean people who won't help anyone with their Haskell problems.
16:03:38 <dafis> shh! don't tell!
16:03:39 <shachaf> But we might make an exception for you just this once, *maybe*, if you describe your problem.
16:03:43 <evincar> Unfortunately. :P
16:03:45 <evincar> I'm using the SDL binding, and passing [SDL.Resizable] in SDL.setVideoMode.
16:03:54 <evincar> But something's up with the way I'm handling events.
16:04:10 <evincar> Because when I resize the window twice, it proceeds to alternate between the current and previous sizes.
16:04:12 * dafis is out, wth is SDL?
16:04:18 <evincar> Still responds to other events, though.
16:04:20 <c_wraith> game-library
16:04:47 <c_wraith> evincar: does the window resize back and forth, or are you just getting event streams that seem wrong?
16:05:32 <evincar> c_wraith: The window changes size. setVideoMode is getting called repeatedly.
16:05:46 <evincar> processEvents :: [SDL.Event] -> Maybe (IO EditorState) -> Maybe (IO EditorState)
16:05:54 <c_wraith> Huh.  Are you sure you're not calling it in your event loop somewhere?
16:06:08 <evincar> Well, that's what I'm trying to figure out.
16:06:20 <evincar> ghc -package SDL -package SDL-image Pal.hs -o Pal
16:06:21 <evincar> Crap, wrong paste.
16:06:40 <evincar> processEvents _ Nothing = Nothing
16:06:49 <evincar> processEvents [] finalState = finalState
16:07:03 <evincar> processEvents (e:es) currentState = do newState ← processEvent e currentState processEvents es (Just newState)
16:07:14 <evincar> Welcome to my world without newlines, apparently.
16:07:17 <c_wraith> please use hpaste instead..  just much easier to read
16:07:55 <evincar> Alright, didn't know the preferred way of doing it in here.
16:08:28 <kfish> morning TacticalGrace
16:08:28 <c_wraith> @where hpaste
16:08:29 <lambdabot> http://hpaste.org/
16:08:53 <TacticalGrace> kfish: Morning!
16:09:01 <kmc> turns out my worrying about kd-trees was unwarranted
16:09:08 <kmc> linear search on hundreds of points performs just fine
16:10:22 <kmc> 'cause computers are fast
16:10:59 <ddarius> Why would you use a kd-tree for hundreds of points?
16:11:34 <kmc> i would if the API were convenient enough
16:12:12 <kmc> i should clarify that I'm linear-searching all the points when adding a new one
16:12:18 <kmc> so it's quadratic in that "hundreds of points" figure
16:12:23 <kmc> and still performs just fine
16:12:51 <ddarius> kmc: As would I.  That it's quadratic isn't really relevant.
16:13:18 <kmc> can you elaborate on what is relevant?
16:14:10 <hpaste> evincar pasted “SDL.VideoResize” at http://hpaste.org/52829
16:14:33 <evincar> Well, there it is...apologies for the length.
16:18:05 <dmwit> Surely setVideoMode causes a VideoResize event, causing your loop.
16:18:16 <dmwit> Not an SDL expert here.
16:19:30 <evincar> It shouldn't, but damn, it does.
16:24:00 <evincar> I could swear that's a bug in the SDL library, actually.
16:24:33 <mrsolo> hi, what's general technic on reducing haskell's runtime memory footprint?
16:24:41 <evincar> Because the SDL docs say SetVideoMode should be called in response to VIDEORESIZE events.
16:24:59 <rtharper> mrsolo: looking for unnecessary laziness, unboxing values where possible
16:25:06 <hpc> mrsolo: heap profiling helps
16:25:34 <hpc> rtharper: also unnecessary strictness
16:25:39 <rtharper> hpc: aye
16:26:10 <hpc> sometimes -O will help your memory usage too, just because it does some helpful code transformations
16:26:47 <hpaste> hato pasted “help with IO [String] -> [String]” at http://hpaste.org/52830
16:27:10 <mrsolo> okay thx
16:28:27 <hatomic> Hi. Just posted hpaste.org/52830 Maybe I'm having a blank, can't get IO [String] into [String]
16:28:39 <hpc> hatomic: you aren't supposed to
16:28:48 <shachaf> hatomic: That is something nobody can do.
16:29:02 <hpc> hatomic: better to bring whatever you want to do with it into IO
16:29:09 <shachaf> [String] is a list of Strings. If you want to put an IO [String] into a list, it would have to be a list of type [IO [String]] -- Ignore this line.
16:29:14 <hpc> there's a number of combinators that make it easy
16:29:16 <alpounet> mrsolo, you may want to take a look at Johan Tibell's "High Performance Haskell" talk slides, for example
16:29:22 <alpounet> or the RWH chapter about this
16:29:41 <hpc> hatomic: also, configure firefox to keep 'http://'
16:29:51 <hpc> it's under about:config, search for 'trimurl' or something
16:30:04 <shirt> how do i shuffle a list?
16:31:50 <dmwit> ?hackage random-shuffle
16:31:50 <lambdabot> http://hackage.haskell.org/package/random-shuffle
16:32:29 <maurer> I am getting
16:32:30 <maurer> hSeek: unsupported operation (Function not implemented)
16:32:38 <hpc> maurer: what are you using it on?
16:32:40 <maurer> Is this because I am interacting with a file improperly?
16:32:52 <maurer> hpc: /proc/25151/mem
16:33:03 <shachaf> Can you seek on files in /proc?
16:33:08 <maurer> shachaf: Yes.
16:33:08 <hpc> dunno if it's possible to seek those kinds of files
16:33:14 <hpc> oh, hmm
16:33:15 <tibbe> argh
16:33:25 <tibbe> I'm writing the intro to a performance tutorial
16:33:25 <maurer> hpc: My question is whether the error message is from the filesystem, or whether it's from haskell telling me I'm doing something weird
16:33:34 <dmwit> tibbe++
16:33:34 <shachaf> maurer: strace to the rescue!
16:33:34 <tibbe> can't find a succinct way to express why performance matters
16:33:40 <hpc> and you are opening it with openFile?
16:33:44 <maurer> hpc: This is from a haskell tracing library I'm writing. It works correctly on one thread, I'm trying to extend it to two
16:33:51 <tibbe> why is writing the intro always the hardest part?
16:33:57 <shirt> dmwit: thanks, but the type seems to be wrong. it doesn't return the updated RandomGen
16:34:15 <dmwit> shirt: Yes, that's a bit unfortunate.
16:34:30 <dmwit> shirt: Use a splittable generator, or send in a patch to that library.
16:34:33 <maurer> OK, it's from the system, not from haskell
16:34:41 <mrsolo> alpounet, noted..thx!
16:34:42 <shachaf> strace++
16:34:44 <alpounet> tibbe, great, keep me posted! i'm quite much into this these days, read a lot and tested a bunch of tricks to improve performances. I'm starting to seriously get a grasp of this
16:34:46 <maurer> lseek(4, 18446744073709551578, SEEK_SET) = -1 ENOSYS (Function not implemented)
16:34:50 <shirt> dmwit: ok :)
16:34:51 <maurer> Time to figure out what the deal is
16:35:03 <hatomic> Thanks for the comments - I'll fix the browser.
16:36:00 <tibbe> alpounet: will do
16:36:09 <hpc> maurer: try doing it in C and see what happens
16:36:12 <tibbe> alpounet: the point of this tutorial is to make that process faster
16:37:17 <alpounet> tibbe, yeah. the hardest part for me has been to get over the "oh damn i'm never gonna understand that Core" impression
16:37:27 <tibbe> alpounet: right
16:37:54 <tibbe> alpounet: so I'll try to cover everything I covered in my High-Performance Haskell talk but in more depth
16:38:56 <BrianHV> how do I escape "name" in this TH expression so that the function being spliced in is named by the parameter to makeFunction?  makeFunction name = runQ [d|name x = "Hello, " ++ x|]
16:40:10 <mrsolo> another question, if i want make a simple http get request, which module should i use?
16:40:12 <maurer> hpc: It is probably not a "doing it in haskell" problem.
16:40:31 <dmwit> shirt: Oh, some other libraries seem to have nicer interfaces.
16:40:40 <alpounet> tibbe, awesome! that was definitely something missing. i've wandered through slides, papers, the GHC commentary, old mailing list topics, code from bryan, dons, you and a few others, etc to learn what i now know...
16:41:02 <dmwit> ?hackage random-extras in particular looks quite nice
16:41:03 <lambdabot> http://hackage.haskell.org/package/random-extras in particular looks quite nice
16:41:06 <tibbe> alpounet: I hope to get to something I can point people to when they have problems
16:42:05 <mrsolo> hmm i guess HTTP..first one on the cabal search result :-)
16:42:38 <dcoutts> mrsolo: the HTTP package is not too bad, it's what cabal-install itself uses
16:42:59 <shirt> dmwit: looks good
16:43:08 <dcoutts> mrsolo: usual thing is to use the Network.Browser module
16:43:30 <mrsolo> okay will use that intead
16:43:36 <alpounet> tibbe, yeah. i'm most likely gonna write quite a few (and already have) scientific computing / AI libraries in the upcoming months so that's really a great deal for me
16:52:29 <kmc> BrianHV, I doubt you can use a splice in that position.  you'll probably have to use the AST combinators directly
16:53:19 <BrianHV> kmc: ok. does TH get less cryptic with familiarity? :)
16:54:47 <kmc> less cryptic but not really less cumbersome
16:56:15 * BrianHV successfully makes the aforementioned code work with the manual AST
16:56:46 <BrianHV> but that's a lot of code for a simple splice. clearly I'll have to think carefully about where TH is actually a good idea
16:57:35 <ddarius> Simply make a quasiquoter for quasiquotation.
16:58:18 <BrianHV> I can't tell if you're serious or not. ;)
16:58:32 <shachaf> If you can understand ddarius, he's probably not being serious.
17:00:05 <shachaf> Is an associative unital quasiquote just called a "quote"?
17:07:26 <evincar> If I have a value x of type IO a, how can I write the equivalent to x{y=z} where x is of type a?
17:08:00 <kmc> fmap (\xx -> xx {y=z}) x
17:08:25 <kmc> if you're doing lots of record updates you might be interested in a package like fclabels
17:08:37 <shachaf> Or data-lens
17:08:44 <evincar> Nah, just the one.
17:08:51 <shachaf> s/Or/In particular,/
17:09:38 <kmc> data-lens is popular in countries like australia, such as new zealand
17:10:00 <shachaf> kmc: See my substitution.
17:10:35 <dafis> Is NZ like Australia?
17:10:35 <stribor> guys why is this foldr (/) 2 [8,12,24,4]  returning 8.0 rather than just 8
17:10:45 <stribor> > foldr (/) 2 [8,12,24,4]
17:10:46 <lambdabot>   8.0
17:10:50 <dafis> :t (/)
17:10:51 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:10:53 <kmc> because (/) is defined only on Fractional types
17:11:00 <kmc> it defaults to Double or something
17:11:07 <dafis> stribor: because of (/)'s type
17:11:07 <kmc> > foldr div 2 [8,12,24,4]
17:11:08 <shachaf> Double trouble
17:11:08 <lambdabot>   8
17:11:15 <stribor> kmc: thank you:)
17:11:41 <stribor> > :t ($)
17:11:41 <lambdabot>   <no location info>: parse error on input `:'
17:11:47 <stribor> > :t $
17:11:48 <lambdabot>   <no location info>: parse error on input `:'
17:12:03 <hpc> :t ($)
17:12:04 <lambdabot> forall a b. (a -> b) -> a -> b
17:12:27 <dmwit> Does foldr (/) (or foldr div) have a sensible meaning?
17:12:28 <hpc> > ":t is a ghci thing, and also a separate lambdabot command"
17:12:29 <lambdabot>   ":t is a ghci thing, and also a separate lambdabot command"
17:12:48 <hpc> > foldr div 0 [x,y,z]
17:12:49 <lambdabot>   x `div` (y `div` (z `div` 0))
17:13:13 <hpc> dmwit: doesn't look like it
17:13:21 <hpc> foldl' (/) would make more sense
17:14:15 <Afzal> @faq spaces
17:14:16 <lambdabot> The answer is: Yes! Haskell can do that.
17:14:20 <Afzal> @help spaces
17:14:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:14:25 <Afzal> help spaces
17:14:29 <Afzal> @list
17:14:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:14:41 <kmc> you seem to have exceeded the powers of lambdabot's sophisticated natural language processing
17:14:52 <Afzal> ... :(
17:15:01 <Afzal> googlebot to the rescue
17:15:28 <kmc> or you could ask the humans :)
17:15:44 <Afzal> what's the other way to write spaces besides "      " ?
17:15:50 * hackagebot NanoProlog 0.2.3.1 - Very small interpreter for a Prolog-like language  http://hackage.haskell.org/package/NanoProlog-0.2.3.1 (JurrienStutterheim)
17:15:54 <kmc> other way?
17:16:16 <Clint> with a pencil
17:16:18 <Afzal> no other way .. ohkay, then maybe my friend was just using a custom variable like spaces = "   "
17:16:21 <Afzal> lol @ clint
17:16:23 <dmwit> > replicate 10 ' '
17:16:23 <Afzal> alright thanks guy
17:16:24 <lambdabot>   "          "
17:16:26 <Afzal> guys*
17:16:35 <shachaf> > map pred "!!!!!!"
17:16:36 <lambdabot>   "      "
17:16:45 <kmc> i like shachaf's way
17:16:53 <shachaf> kmc: I like to call it the kmc cypher.
17:17:07 <dmwit> > pred."!!!!!"--maximize your punctuation density!!!!
17:17:09 <lambdabot>   "     "
17:18:57 <donri> > "\u0020"
17:18:58 <lambdabot>   <no location info>:
17:18:58 <lambdabot>      lexical error in string/character literal at chara...
17:19:06 <donri> > '\u0020'
17:19:07 <lambdabot>   <no location info>:
17:19:08 <lambdabot>      lexical error in string/character literal at chara...
17:19:14 <kmc> womp womp
17:19:30 <dmwit> > '\0020'
17:19:31 <lambdabot>   '\DC4'
17:19:36 <donri> oh :)
17:19:47 <dmwit> Everything is Unicode, no need to say it explicitly.
17:19:48 <donri> i thought afzal wanted something like that
17:19:54 <dmwit> > '\x20'
17:19:55 <lambdabot>   ' '
17:19:56 <donri> i blame python
17:20:30 <dmwit> hm...
17:20:34 <dmwit> > '\&3'
17:20:34 <lambdabot>   <no location info>:
17:20:35 <lambdabot>      lexical error in string/character literal at chara...
17:20:54 <dmwit> Okay, so that one is special to String. Makes plenty of sense.
17:20:54 <donri> > '\20'
17:20:55 <lambdabot>   '\DC4'
17:21:13 <donri> > '\32'
17:21:13 <lambdabot>   ' '
17:21:18 <dmwit> > ['\20', toEnum 20, '\x20']
17:21:19 <lambdabot>   "\DC4\DC4 "
17:21:26 <Clint> > '\040'
17:21:27 <lambdabot>   '('
17:21:32 <dmwit> > '\o40'
17:21:33 <lambdabot>   ' '
17:22:03 <donri> > ['\32' .. '\127']
17:22:04 <lambdabot>   " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg...
17:22:10 <donri> yay
17:22:58 <donri> Char is Enum by some standard ordering of unicode?
17:23:01 <dmwit> > foldr (.) id (replicate 32 succ) . ['\0'..]
17:23:03 <lambdabot>   " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg...
17:23:17 <dmwit> donri: By codepoint, yes.
17:23:19 <kmc> by Unicode code points yes
17:23:31 <donri> and i take it the first few are based on ASCII?
17:23:50 <kmc> that's how unicode works yeah
17:23:50 <dmwit> Unicode coincides with ASCII for the first 128 codepoints, yes.
17:24:20 <hpc> that is to say, all of ASCII is also in unicode
17:24:31 <dmwit> indeed
17:24:37 <hpc> (but only the first half of latin-1)
17:24:37 <kmc> > toEnum 0xD800 :: Char
17:24:38 <lambdabot>   '\55296'
17:24:44 <donri> well, ascii is both an encoding and a character set isn't it?
17:24:49 <kmc> yeah
17:24:58 <donri> or is that what charset means, hm
17:25:05 <Clint> it isn't
17:25:09 <dmwit> hpc: Hm? I thought latin-1 coincided with Unicode, too.
17:25:10 <kmc> the ASCII character set coincides with Unicode, and the ASCII encoding coincides with UTF-8
17:25:13 <hpc> donri: unicode is a charset and there are different encodings of it
17:25:33 <hpc> dmwit: no, because characters with MSB on mark multibyte chars
17:25:37 <hpc> in UTF8 at least
17:25:48 <kmc> Latin-1 codepoints coincide with Unicode codepoints
17:25:54 <kmc> but Latin-1 byte encoding does not coincide with UTF-8
17:26:04 <dmwit> ah, ah
17:26:07 <dmwit> Yes, okay, of course.
17:26:43 <stribor> can someone help me with this operator ($)
17:26:47 <kmc> yes
17:26:53 <dmwit> I never expect encodings to coincide, anyway. Any that do are pure coincidence.
17:26:58 <dmwit> ?src ($)
17:26:59 <lambdabot> f $ x = f x
17:27:14 <kmc> the coincidence of ASCII with Latin-1 and UTF-8 is very useful
17:27:24 <c_wraith> UTF-8 is amazingly well-designed.
17:27:47 <c_wraith> especially given that it was essentially sketched out over a weekend by a few engineers who wanted something with its properties.
17:28:16 <ddarius> ... isn't it "well-designed" because it has certain properties ... ?
17:28:30 <c_wraith> ddarius: yes, but it also is a standard encoding.
17:28:40 <kmc> http://en.wikipedia.org/wiki/UTF-8#Design
17:28:45 <c_wraith> the amazing part is that the unicode committee recognized it was really good. :)
17:28:55 <kmc> the amazing part is that it's good and yet people use it
17:29:11 <shachaf> I want negative Unicode codepoints
17:29:15 <hpc> kmc: no, i think java still uses UTF16
17:29:24 <kmc> did I imply otherwise?
17:29:28 <dmwit> Well, if Java doesn't use it, nobody uses it.
17:29:35 * dmwit sticks his tongue out
17:29:36 <hpc> it's the way of the world
17:29:38 <dylukes> hpc: Nope, Java uses a modified UCS-2
17:29:40 <dylukes> >_>
17:29:45 <dylukes> So it's EVERY SO SLIGHTLY incompatible :).
17:29:56 <dylukes> It works for 99% of cases, and is wrong in the others. Whee.
17:29:57 <kmc> by "slightly" you mean "incorrect for most Unicode characters"
17:30:05 <kmc> but people mostly don't use those characters
17:30:10 <dylukes> Yeah, exactly.
17:30:14 <dylukes> Goddammit Java.
17:30:35 <dmwit> stribor: (If you can ask a more exact question, we can formulate a more exact answer. If we've already answered whatever question you had... well, great! =)
17:30:40 <dylukes> strager: generally speaking
17:30:44 <dylukes> stribor: *
17:30:50 <dylukes> f $ g x = f (g x)
17:30:52 <kmc> hey at least they aren't encoding supplemental plane characters as UTF-16 surrogate pairs and then encoding each of those codepoints individually with UTF-8
17:30:57 <kmc> apparently this is a popular scheme too
17:31:01 <stribor> dmwit: can you write simple examle using foldr
17:31:02 <dylukes> it's just a way to order things other than parens really...
17:31:17 <stribor> i meant using foldr ($) something somelist
17:31:20 <dylukes> You can think of $ as meaning "group everything to the right of this as ( )"
17:31:34 <monochrom> @type ($)
17:31:35 <lambdabot> forall a b. (a -> b) -> a -> b
17:31:36 <dmwit> > foldr ($) 0 [(+1), (*2), (^5)]
17:31:37 <lambdabot>   1
17:31:39 <kmc> or you can think of it as an ordinary user-defined infix operator
17:31:50 <dmwit> > foldr ($) 6 [(+1), (*2), (^5)]
17:31:51 <lambdabot>   15553
17:31:53 <donri> unicode/utf-8 compat with ascii might be convenient, but also causes a whole lot of confusion
17:32:03 <dmwit> > 6^5 * 2 + 1
17:32:03 <lambdabot>   15553
17:32:09 <dylukes> kmc: btw we stopped quoting a split second after you left.
17:32:14 <kmc> ok
17:32:21 <stribor> ok cool..let me study those 2 examples
17:32:25 <monochrom> @type foldr
17:32:26 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:32:43 <dmwit> stribor: Try this one on, too:
17:32:50 <dmwit> > foldr f z [a,b,c]
17:32:51 <lambdabot>   f a (f b (f c z))
17:33:14 <dmwit> sorry
17:33:20 <dmwit> > foldr ($) z [f,g,h]
17:33:21 <lambdabot>   f (g (h z))
17:34:36 <stribor> dmwit: thank you
17:38:37 <joe9> need some ideas, please? I have a [Word8], and I want to split it into a [[Word8]], based on a list of [Length], where Length = Int.
17:38:56 <joe9> basically, split a list into sublists based on the lengths of the sublists in another list.
17:40:28 <joe9> @hoogle split
17:40:28 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
17:40:28 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
17:40:29 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
17:40:50 <joe9> @hoogle Data.List.split
17:40:50 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
17:40:50 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
17:41:31 <nejucomo> Why do I see 0 people here?  How odd.
17:41:48 <nejucomo> Flaky client?
17:41:58 <shachaf> nejucomo: Nah, the channel's just empty.
17:42:01 <shachaf> Try again another tim.
17:42:10 <kmc> joe9, maybe http://hackage.haskell.org/package/split can help you
17:42:19 <kmc> but you can also do the recursion directly
17:42:23 <joe9> kmc, thanks.
17:43:28 <nejucomo> Ah, I was just about to ask how to do a thing, then started describing the type I wanted, then realized I should hoogle, then got what I was looking for.
17:43:32 <joe9> splitPlaces seems to d oit
17:43:38 <nejucomo> (This experience is new to me coming from python land...)
17:44:03 <kmc> :t let takes [] _ = []; takes (n:ns) xs = (let (first, rest) = splitAt n xs in first : takes ns rest) in takes
17:44:04 <lambdabot> forall a. [Int] -> [a] -> [[a]]
17:44:44 <kmc> :t let { takes [] _ = []; takes (n:ns) xs = first : takes ns rest where (first, rest) = splitAt n xs } in takes
17:44:45 <lambdabot> forall a. [Int] -> [a] -> [[a]]
17:44:59 <joe9> @hoogle splitPlaces
17:44:59 <lambdabot> No results found
17:45:11 <joe9> kmc, that is doing what I wanted.
17:46:06 <kmc> :t let takes [] _ = []; takes (n:ns) xs = take n xs : takes ns (drop n xs) in takes
17:46:06 <lambdabot> forall a. [Int] -> [a] -> [[a]]
17:47:03 <ddarius> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
17:47:03 <lambdabot> f a b c = a (\ d -> b d c)
17:55:45 <evincar> Hmm. Hoogle has failed me...there's no such thing as (a -> b) -> m a -> b apparently.
17:56:14 <evincar> Obviously I'm not thinking about this right.
17:56:23 <ddarius> evincar: Correct.
17:57:23 <evincar> Eh, if Stack Exchange has taught me anything, it's that people are usually asking the wrong questions.
17:57:53 <kmc> i assume 'm' is intended to be an arbitrary monad?
17:58:17 <DanBurton> EvanR: that type signature sounds eerily similar to The Function Which Shall Not Be Named
17:58:24 <kmc> in that case, correct, it does not exist
17:58:31 <kmc> for example you could apply id and specialize and get IO a -> a
17:58:32 <DanBurton> doh wrong tab. evincar ^
17:58:44 <kmc> however it can exist for particular monads, and also for some type constructors 'm' which are not monads
17:59:09 <evincar> kmc: Right. I'm still learning how to coexist comfortably with Haskell's type system.
17:59:20 <EvanR> DanBurton: what, unsafePerformIO ? ;)
17:59:23 <EvanR> i wasnt paying attention
17:59:32 * DanBurton gasps
17:59:32 <EvanR> nvm wasnt even talking to me
17:59:35 <kmc> there's no way to 'unsafePerform' an arbitrary monad, though
17:59:46 <EvanR> back to the GOP debate
17:59:52 <engla> @type foldMap
17:59:52 <lambdabot> Not in scope: `foldMap'
17:59:55 <evincar> I need to get a Bool given an IO a and an (a -> Bool) accessor.
17:59:56 <DanBurton> EvanR: yeah, the autocomplete is weak with me today :)
18:00:07 <kmc> fmap accessor ioAction
18:00:13 <kmc> fmap :: (a -> b) -> (IO a -> IO b)
18:00:15 <ddarius> :t (. unsafePerformIO)
18:00:16 <lambdabot> Not in scope: `unsafePerformIO'
18:00:25 <ddarius> A pox on you!
18:00:25 <kmc> evincar, did you see http://www.haskell.org/haskellwiki/Introduction_to_IO
18:01:02 <evincar> kmc: Yes. When I use fmap I get "couldn't match IO Bool against Maybe Bool".
18:01:11 <evincar> So I guess I got led astray.
18:01:11 <kmc> then try using it differently
18:01:22 <kmc> the thing is, your (IO a) doesn't have an 'a' hiding inside
18:01:30 <kmc> it's a description of how one could perform IO to produce an 'a'
18:01:38 <kmc> so you're going to end up with another IO-description
18:01:47 <Axman6> evincar: can you share your code?
18:01:56 <kmc> the Intro to IO makes this more clear
18:02:00 <ddarius> Axman6: What are you, a communist?
18:03:34 <hpaste> evincar pasted “Useless Title” at http://hpaste.org/52832
18:04:40 <Cale> ☭
18:04:57 <evincar> kmc: I understand that, but like I said, I was misled by the other type error.
18:05:18 <ddarius> Cale: He's Axman, not Hammer and Sickle man.
18:05:44 <dolio> ddarius: Have you read the directed type theory section of Licata's thesis, by the way?
18:05:57 <ddarius> dolio: Not yet, but I did read the proposal.
18:06:01 <ddarius> dolio: Have you?
18:06:10 <dolio> Yeah, I went through it all last night.
18:06:27 <ddarius> Huzzah.
18:06:32 <dolio> It's quite dense.
18:06:36 <ddarius> Yes.
18:11:53 <steakknife> denser than knuth's taos? :)
18:16:08 <steakknife> s/s\?/cp/
18:17:32 <shachaf> evincar: getLine :: IO String contains a String as much as /bin/ls contains a list of files.
18:17:52 * shachaf scrolls down.
18:17:58 <shachaf> Never mind.
18:18:10 <kmc> first string in my /bin/ls is /lib64/ld-linux-x86-64.so.2
18:18:51 <kmc> hmm a g-code backend for 'diagrams' would be fun
18:19:26 <kmc> use 'diagrams' to control your CNC plasma cutter
18:21:12 <steakknife> plasma cutter as a turing machine: that'd be a neat hack
18:21:20 <steakknife> sorry, i mean… |-| @ C |<
18:21:32 <kmc> @elite hack
18:21:32 <lambdabot> h4xx
18:21:50 <kmc> well g-code is one of these "turing-complete poorly and by accident" languages
18:22:12 <steakknife> and you don't mean perl ;)
18:24:00 <shachaf> Oh, "G-code" doesn't refer to G-machine code. :-(
18:24:41 <dylukes> :t (. System.IO.Unsafe.unsafePerformIO )
18:24:42 <lambdabot> forall a b. (a -> b) -> IO a -> b
18:32:56 <ddarius> steakknife: Probably quite a bit denser that TAOCP.
18:34:04 <steakknife> Let's see compared to general relativity.
18:36:52 <Cale> G-code optimiser for next ICFP contest
18:37:45 <steakknife> Let's just extend type ontologies into n-dim tensor spaces. }:)
18:37:51 <Cale> Something about G-code reminds me of ICFP contests, anyway
18:38:21 <steakknife> Invent some new dimensions along the way. :D
18:42:37 <kmc> it already supports 9
18:46:28 <hello_world> how do I convert a list of tuples into a string?
18:46:46 <donri> what are the tuples of?
18:46:58 <hello_world> (Char, String)
18:46:59 <donri> maybe you want "show"
18:47:44 <donri> concat $ map (:) list -- maybe?
18:47:48 <shirt> f x = y x (g "foo")
18:48:01 <shirt> will (g "foo") be evaluated each time f is called, or only once during program startup/compilation?
18:48:32 <donri> > concat . map (:) $ [('x',"foo"),('y',"bar")]
18:48:33 <lambdabot>   Couldn't match expected type `[a]'
18:48:33 <lambdabot>         against inferred type `[a1] -> [...
18:48:40 <shachaf> shirt: Each time.
18:48:49 <shachaf> shirt: Well, it depends on your compiler, of course.
18:49:01 <donri> oh silly me
18:49:11 <shachaf> f = let z = g "foo" in \x -> y x z will probably evaluate it once, though.
18:49:50 <donri> > concat . map ((:) . curry) $ [('x',"foo"),('y',"bar")]
18:49:51 <lambdabot>   Couldn't match expected type `[a]'
18:49:51 <lambdabot>         against inferred type `[a1] -> [...
18:49:52 <kmc> > show [('x', "foo"), ('y', "bar")]
18:49:53 <lambdabot>   "[('x',\"foo\"),('y',\"bar\")]"
18:50:42 <kmc> hello_world, we don't know which particular function of type [(Char, String)] -> String you wanted
18:50:44 <kmc> there are many
18:50:55 <shirt> shachaf: what about using a let but no lambda?
18:51:13 <donri> > concat . map (curry (:)) $ [('x',"foo"),('y',"bar")]
18:51:14 <lambdabot>   Couldn't match expected type `[a]'
18:51:15 <lambdabot>         against inferred type `b -> [(a1...
18:51:18 <shachaf> shirt: That depends. Is the let inside the lambda or outside?
18:51:23 <donri> > concat . map (uncurry (:)) $ [('x',"foo"),('y',"bar")]
18:51:24 <donri> argh
18:51:25 <lambdabot>   "xfooybar"
18:51:26 <shachaf> shirt: There has to be a lambda, one way or the other, because it's a function.
18:51:47 <shirt> shachaf: f x = let z = g "foo" in y x z
18:51:47 <donri> hello_world, ^ that anything like what you want?
18:52:02 <kmc> i've noticed #haskell gets a lot of underspecified questions
18:52:08 <kmc> which set off a flurry of guessing
18:52:12 <shachaf> shirt: That's f = \x -> let z = g "foo" in y x z
18:52:22 <shachaf> So it'll probably reëvaluate it each time.
18:52:35 <donri> kmc, part of the fun! yay!
18:53:34 <ddarius> kmc: Are you sure that you haven't just noticed that #haskell gets a lot of people that like to guess at underspecified questions?
18:53:43 <shirt> shachaf: ok thanks
18:53:45 <kmc> can't it be both
18:54:23 <kmc> i guess i should be thankful
18:55:05 <kmc> "how do I write haskell program" --- several weeks pass ---> xmonad is born
18:55:16 <donri> :D
18:55:17 <ddarius> I doubt that #haskell gets noticeably more underspecified questions than most PL channels.
18:55:51 <monochrom> it gets significantly more answers to each underspecified questions
18:55:54 <tgeeky> ddarius: if you know someone smart enough to fix that, then bring them here!
18:56:03 <tgeeky> monochrom: ;0
18:56:26 <ddarius> monochrom: That's what I'm suggesting is what kmc is noticing.
18:57:20 <monochrom> I know someone smart enough to fix it, but he is banned
18:57:39 <tgeeky> monochrom: just our luck!
18:58:16 * ddarius eats a peach.
18:58:51 <tgeeky> I noticed that about 10 hours or so in here
18:59:01 * ddarius hasn't been eating a peach for ten hours.
18:59:20 * ddarius has a very good idea to whom monochrom is referring.
18:59:22 * DanBurton wonders if monads are like peaches
19:02:40 <jeffcutsinger> Monads come from a can, they were put there by a man, in a factory downtown.
19:04:09 <steakknife> They say "help i'm stuck in a monad factory.  return help or fail."
19:04:41 <djahandarie> Don't forget to join forces.
19:05:56 <kmc> byorgey, are you around to answer a few questions about 'diagrams'?
19:06:03 <kmc> (or anyone else who's written a backend)
19:06:12 <tgeeky> roconnor: what is the connection, if any, between your PhD thesis and you writing multiplate?
19:07:05 * ddarius has the option of moving into this guy's condo: http://www.amazon.com/Cooking-Geeks-Science-Great-Hacks/dp/0596805888
19:07:08 <roconnor> tgeeky: none
19:07:51 <roconnor> tgeeky: multiplate arose because I was trying to do some generic programming for the Mathscheme project at McMaster.
19:09:38 <tgeeky> roconnor: thanks.
19:20:03 <realitygrill> so I have a stupid question
19:20:32 <realitygrill> i'm going through LYAH, and it has an example of making a list
19:20:41 <realitygrill> and accessing the list element through !!
19:21:17 <realitygrill> but I am befuddled, the list indices seem to start at -1 rather than 0... b !! 0 gives me the 2nd element of the list
19:21:41 <kmc> > "foo" !! 0
19:21:42 <lambdabot>   'f'
19:21:51 <kmc> can you show us the example you're trying?
19:21:53 <byorgey> kmc: sorry, I'm headed to bed right now, but can answer questions tomorrow
19:22:24 <realitygrill> yeah.
19:22:34 <realitygrill> > let b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
19:22:35 <lambdabot>   not an expression: `let b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3...
19:22:52 <dmwit> realitygrill: Try "let b = ... in ..." instead.
19:22:56 <shachaf> You have to type expressions in one line in lambdabot.
19:23:00 <realitygrill> b !! 2 gives me [1,2,2,3,4]
19:23:01 <realitygrill> oh
19:23:06 <kmc> > let b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] in b !! 0
19:23:07 <lambdabot>   [6,6,6]
19:23:20 <kmc> > let b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] in b !! 2
19:23:21 <lambdabot>   [5,3,3,3]
19:23:27 <realitygrill> hmm ghci is being weird to me
19:23:31 <shachaf> > [6,6,6] !! 0 -- It's the second element!
19:23:32 <lambdabot>   6
19:23:32 <realitygrill> oh wait
19:23:42 <kmc> maybe you defined (!!) yourself and made a mistake?
19:23:53 <byorgey> realitygrill: I think you are being weird to ghci ;)
19:23:57 <realitygrill> so, I wonder if it makes a difference that originally the list b did not have 6,6,6
19:24:06 <realitygrill> and was cons-ed on
19:24:18 <kmc> you can't modify anything in place
19:24:19 <shachaf> Did you say "let b = [6,6,6] : b"?
19:24:29 <kmc> but you can create a new name binding which shadows the original one
19:24:33 <byorgey> just evaluating [6,6,6] : b  does not change b
19:24:34 <shachaf> That defined b as an infinite (cyclic) list [[6,6,6],[6,6,6]...]
19:24:43 <kmc> that's what happens if you do "let b = ..." twice in ghci
19:24:54 <realitygrill> no, i only used let b once
19:24:59 <kmc> > let b = [6,6,6] : b in b !! 12
19:24:59 <lambdabot>   [6,6,6]
19:25:02 <shachaf> How did you cons it on, then?
19:25:04 <realitygrill> and in fact LYAH has the same output
19:25:11 <shachaf> Just "[6,6,6]:b"? That doesn't modify b.
19:25:13 <realitygrill> [6,6,6]:b
19:25:16 <realitygrill> yes
19:25:19 <realitygrill> oh
19:25:31 <byorgey> it's a good thing to
19:25:33 <byorgey> *too
19:25:34 <shachaf> All that does is make a new list whose head is [6,6,6] and whose tail is b.
19:25:42 <byorgey> if 1 + 2 modified 2 we would all be in trouble
19:25:43 <dmwit> > let b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] in ([6,6,6]:b, b !! 2)
19:25:44 <lambdabot>   ([[6,6,6],[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]],[5,3,3,3])
19:25:46 <kmc> thanks byorgey, i'll ask you tomorrow
19:25:52 <realitygrill> yeah, yeah, functional
19:25:53 <realitygrill> ok cool
19:26:13 <shachaf> I'd say you can't mutate anything, but kmc would immediately show off unsafeEvil.
19:26:25 <djahandarie> shachaf, not if you say "in Haskell".
19:26:32 <byorgey> kmc: ok, talk to you later
19:26:48 <shachaf> djahandarie: I originally had "in Haskell", and then I realized kmc would say "no, that was in GHC", so I took it off.
19:26:55 <shachaf> But that lessens the effect.
19:27:00 <djahandarie> :P
19:27:02 <ddarius> safeEval
19:27:43 <realitygrill> err, now I'm curious... what is that..
19:27:55 <dmwit> never mind
19:28:00 <dmwit> ;-)
19:28:56 <realitygrill> lol. is there a reason why in Scheme lists can contain anything, and iirc little schemer teaches that tuples can only have numbers... and that seems somewhat opposite Haskell?
19:29:14 <kmc> i didn't know scheme had anything called "tuple"
19:29:17 <dmwit> Yes, there is a reason: Scheme's type system sucks.
19:29:27 <shachaf> kmc: They call it a "cons".
19:29:29 <kmc> meh that's a super confrontational way to put it
19:29:35 <shachaf> (cons a b) -- tuple of a and b
19:29:36 <dmwit> (this sentence intentionally crafted as flamebait)
19:29:57 <kmc> realitygrill, Scheme is dynamically typed, and allows lists to contain elements of different types in an unstructured way
19:30:13 <kmc> and a list is built out of pairs, which can be used for other things
19:30:21 <kmc> in other words it unifies Haskell's (:) and (,) constructors
19:30:35 <realitygrill> hm...
19:30:39 <kmc> "lists" are just a convention regarding a particular way to use pairs
19:30:52 <shachaf> And it unified [] and ()
19:31:16 <realitygrill> ok that makes sense
19:31:36 <kmc> shachaf, and False
19:31:37 <hpaste> DanBurton pasted “weird typeclass stuff” at http://hpaste.org/52833
19:32:12 <DanBurton> any clues on how to make this paste work?
19:32:18 <shachaf> kmc: I thought Scheme had an explicit False.
19:32:27 <shachaf> #f
19:32:56 <kmc> hmm, and it's not the same as list nil
19:33:01 <kmc> i thought they were but i think you're right
19:33:08 <shachaf> And the atom 'nil is also not the same as '()
19:33:23 <shachaf> You might be thinking of Common Lisp. :-)
19:33:38 * shachaf prefers to spend minimal time doing that.
19:34:13 <dmwit> DanBurton: class HasEmpty (l a) => List l a where ... ?
19:34:14 * ddarius would say Scheme doesn't contain lists.
19:34:39 <dmwit> DanBurton: Alternately, class List l where empty :: l a; ...
19:34:43 <DanBurton> dmwit: but List needs to be a class of types with kind * -> *
19:34:46 <dmwit> (And just skip the HasEmpty class.)
19:35:03 <dmwit> DanBurton: What I suggested was a MPTC with types of kind * -> * and *.
19:35:19 <DanBurton> MPTC?
19:35:22 <DanBurton> what's that
19:35:22 <shachaf> ddarius: It has a primitive "list?"
19:35:25 <DanBurton> oh nvm
19:35:28 <dmwit> DanBurton: (Note the lack of parentheses around l a in the class declaration.)
19:35:28 <DanBurton> multiparameter typeclass?
19:35:30 <dmwit> yes
19:35:43 <realitygrill> so.. head == car, tail == cdr..
19:36:04 <kmc> or fst ≡ car, snd ≡ cdr
19:36:07 <kmc> depending on how you look at it
19:36:11 <mendez> ^what they said
19:36:36 <kmc> after all, you can apply Scheme's car and cdr to things which aren't lists
19:36:41 <kmc> you can apply them to arbitrary pairs
19:36:47 <realitygrill> oh, yes.
19:37:07 <kmc> (and you can't apply them to '(), which *is* a list)
19:37:29 <shachaf> You can make lists whose tail is the car and whose head is the cdr.
19:37:29 <dmwit> DanBurton: If you don't merge the two classes, you're probably going to need UndecidableInstances. Which is a bit... unsavory.
19:37:47 <kmc> i'm fine with UndecidableInstances
19:38:03 <kmc> it's just allowing things whose meaning would be clear from the Haskell 2010 rules
19:38:17 <kmc> unlike OverlappingInstances or IncoherentInstances
19:38:51 <DanBurton> I'm already using pragmas for Flexible, Undecidable, and Overlapping Instances :P
19:39:00 <shachaf> Not Incoherent?
19:39:06 <DanBurton> not yet
19:39:08 <kmc> what problem are you trying to solve?
19:39:17 <DanBurton> making Prelude better
19:39:27 <kmc> 'better'
19:39:36 <DanBurton> fsvo "better" obviously :P
19:39:38 <dmwit> kmc: I dunno. Isn't it a bit odd that, despite the fact that *my* module doesn't require UndecidableInstances, the fact that I'm using your library (which does) means I could make the compiler loop?
19:40:01 <dmwit> I'd probably be pissed off if that ever happened.
19:40:15 * shachaf makes note in the "how to annoy dmwit" file.
19:40:38 <kmc> dmwit, is there a way for your module to make mine loop, which isn't intrinsically a bug in my module?
19:40:45 <dmwit> shachaf: =)
19:40:52 <kmc> that is, is the bug found when you compile my module or yours
19:40:59 <kmc> also why is the compiler looping a big deal
19:41:39 <dmwit> The answer to the first question is yes for *most* uses of UndecidableInstances.
19:42:28 <dmwit> So the bug is in my module, it's found when I compile my module, and it's found by the compiler taking an inordinate amount of time (possibly looping but we'll never know for sure thank you very much).
19:43:02 <kmc> doesn't GHC use a finite context-resolution stack?
19:43:11 <kmc> won't it bail out of loops within a fraction of a second on default settings?
19:43:21 <shachaf> You can make GHC actually loop.
19:43:22 <dmwit> Probably.
19:43:39 <kmc> you can make GHC loop using known bugs, but it has nothing to do with UndecidableInstances
19:43:57 <dmwit> I haven't actually used many libraries that enabled UndecidableInstances, I think.
19:44:06 <dmwit> And I think that's a reasonably good thing.
19:44:11 <kmc> you can also write a Template Haskell splice that calls "error"
19:44:16 <kmc> or an ordinary type error
19:44:18 <kmc> or use #error in CPP
19:44:29 <dmwit> kmc: Those don't loop, they exit immediately.
19:44:35 <dmwit> (Though of course your TH can loop.)
19:44:38 <kmc> see: finite context-resolution stack
19:45:38 <parcs> dmwit: you don't use mtl? :P
19:45:54 <dmwit> parcs: Oh man, you mean mtl uses UI?
19:46:24 <parcs> yeah
19:46:31 <kmc> my GHC hits the stack size limit of 21 in 0.1 seconds
19:46:51 <kmc> i suspect that most of that time is spent printing the error message
19:47:31 <kmc> so yes, it's a compile-time error like #error or whatever
19:47:49 <dmwit> Well, maybe I'm feeling a little bit convinced, then.
19:47:56 <kmc> unless you're also mucking with -fcontext-stack
19:48:31 <shachaf> I thought you could make GHC actually loop non-bugfully with UndecidableInstances.
19:48:36 <kmc> oh yeah?
19:48:37 <dmwit> I guess there's no really good way to tell the difference between good code that needed a bigger stack and bad code... but maybe that doesn't come up enough to matter.
19:48:42 <shachaf> I might be wrong.
19:48:57 <kmc> dmwit, I think it comes up a lot if you're trying to do actual computation with the type class system
19:49:08 <kmc> (same thing happens in C++, by the way)
19:49:42 <dmwit> right
19:50:07 <dmwit> But DanBurton's class names don't look like the typical ones people use when they're bootstrapping a usable type-level language.
19:50:12 <dmwit> So he's probably okay.
19:50:30 <dmwit> Alright, you've convinced me.
19:50:51 <kmc> :)
19:52:03 <kmc> needing UndecidableInstances *is* a general warning sign in the direction of "you're doing something complicated with type classes and you should be doing functional programming instead"
19:52:09 <kmc> but only generally
19:53:17 <copumpkin> typeclass wankery precludes functional programming?
19:53:39 <ddarius> copumpkin: Take your sinful relational programming elsewhere.
19:53:44 <copumpkin> :)
19:56:47 <kmc> not precludes
19:56:54 <shirt> i need a data structure like a dense IntMap, so if i delete an element from the middle, all of the later keys will shift by one. what should i use?
19:58:06 <kmc> but there's a common design where instead of writing a function that takes a function, you make a type class and some new types and instances and then a function with a polymorphic type bounded by that class
19:58:21 <kmc> because.. i don't know why, really.  because it's kind of like what you'd do in Java
19:59:26 <kmc> and instead of making a data structure which holds functions, you make a data structure holding existential wrappers for that type class
20:02:42 <levi> kmc: I'll bet the Java people think the Haskellers that make Monads in Java are pretty bizarre, too. ;)
20:03:49 <Cale> shirt: Data.Sequence
20:04:13 <kmc> not really the same thing
20:04:29 <Cale> shirt: It has log time/space splitting and merge, so you can delete elements from the middle cheaply.
20:04:53 <shirt> Cale: thanks i'll take a look. i also need fast lookup based on index
20:05:01 <Cale> yeah, it has that too :)
20:05:42 <c_wraith> kmc: I think it's because java-style OO teaches that if you want different behavior, you need a different type.  And then they assume that's true in haskell, too
20:05:49 <kmc> yeah
20:06:42 <kmc> "java-style OO" is a charitable way to describe it
20:07:11 <kmc> 'cause this isn't the case with OOP in C# or Python or Ruby or Javascript or Perl or OCaml or Haskell or Scala or F# or ...
20:08:31 <c_wraith> it's also what a lot of schools teach as what OO "is".  Sadly.
20:09:45 <c_wraith> things like the liskov substitution principle.  (ick.  how does that even make sense?)
20:10:19 <kmc> it makes sense to me
20:10:26 <kmc> it's a principle of subtyping, not of OOP per se
20:10:35 <kmc> it's also totally violated by every practical OOP system
20:11:05 <kmc> to the extent that the JavaSchools teach LSP they will have to field a lot of awkward questions from their JavaStudents
20:14:28 <levi> I think it's often taught when they teach design patterns and whatnot.
20:51:27 <desaiu> I'm going through list comprehensions
20:51:31 <desaiu> [ x | x <- [50..100], x `mod` 7 == 3]
20:53:20 <desaiu> Does that say that x is equal to every number between 50 and 100, but that you want only those which when `mod` is applied to them, the remainder is 3? And then, is this piped to x? The part at the beginningof the list, i.e. this->  x |
20:54:20 <shachaf> It's the same as filter (\x -> x `mod` 7 == 3) [50..100]
20:54:33 <desaiu> What's the \x?
20:54:43 <shachaf> A lambda.
20:54:51 <parcs> desaiu: yes
20:54:53 <shachaf> I think Haskell introductions that aren't YAHT talk about that. :-)
20:55:07 <shachaf> x isn't really "equal" to anything. You could think of it as equalling all the values of the list nondeterministically, I guess.
20:55:21 <desaiu> I suppose, I should just finish reading one of these tutorials before asking questions then, I haven't gotten to lambdas
20:56:01 <parcs> > [ x | x <- [50..100], x `mod` 7 == 3]
20:56:02 <lambdabot>   [52,59,66,73,80,87,94]
20:56:21 <desaiu> What's the order this is interpreted?
20:56:39 <shachaf> Left-to-right after the |
20:56:55 <desaiu> What does the x | do?
20:57:03 <shachaf> Nothing, on its own.
20:57:06 <desaiu> It's throwing me for a loop
20:57:06 <DanBurton> It is like set notation
20:57:11 <shachaf> What does the "ybe" do in "Maybe"?
20:57:26 <mike-burns> You can read this as "x such that x draws from the range 50 to 100 and x modulus 7 is 3".
20:57:37 <desaiu> Or rather, it's it's throwing me for an infinite map function? Bad humor.
20:57:47 <mike-burns> Save the bad humor for the end of the tutorial.
20:57:55 <parcs> > [ x + 1 | x <- [50..100], x `mod` 7 == 3]
20:57:56 <lambdabot>   [53,60,67,74,81,88,95]
20:58:19 <desaiu> mike-burns: +1 for "such that"
20:58:30 <DanBurton> [x | x <- S, x < 2] is meant to look a lot like { x ? S | x < 2 }
20:58:57 <desaiu> It's just like set notation, got it.
20:59:13 <shachaf> DanBurton: Is that a literal question mark?
20:59:14 <companion_cube> but you also have a notion of order.
20:59:16 <kmc> shachaf, that's deep, man
20:59:18 <desaiu> I was reading that as x OR something something something, but I knew it wasn't right
20:59:24 <DanBurton> shachaf: it was supposed to be the "in" symbol >,<
20:59:26 <desaiu> OR is always || right?
20:59:37 <desaiu> I've seen some lines with just one | symbol though
20:59:49 <mike-burns> We'll need more context than this.
20:59:55 <DanBurton> shachaf: the sideways pitchfork without a handle
21:00:04 <desaiu> Can an OR statement be just one of these symbols: |
21:00:05 <shachaf> kmc: Dude, this is a channel for deep people.
21:00:08 <parcs> desaiu: | is synax
21:00:10 <shachaf> We're all so deep in here.
21:00:11 <parcs> syntax
21:00:27 <dmwit> desaiu: no
21:00:35 <kmc> shachaf, deeply superficial?
21:00:46 <desaiu> | is to always be read as "such that"?
21:00:54 <DanBurton> desaiu: | is usually used for "guards" in Haskell
21:00:57 <shachaf> | can have different meanings.
21:01:01 <DanBurton> @google lyah guard
21:01:02 <lambdabot> http://learnyouahaskell.com/a-fistful-of-monads
21:01:03 <lambdabot> Title: Learn You a Haskell for Great Good! - A Fistful of Monads
21:01:04 <shachaf> But you can probably read all of them "such that".
21:01:18 <DanBurton> hm not the right page :P
21:01:19 <desaiu> DanBurton: I tried reading simon's work on pattern guards the other night, I'm not ready for it.
21:01:35 <DanBurton> desaiu: there's a difference between guards and pattern guards
21:01:38 <desaiu> @google yaht guard
21:01:40 <lambdabot> http://www.yachtcrew.ca/training.html
21:01:40 <lambdabot> Title: Yacht Crew Register
21:01:55 <shachaf> desaiu: ...Did you try to read about guards in YAHT?
21:01:56 <desaiu> Think I will choose DanBurton's link
21:01:58 <DanBurton> desaiu: regular guards are rather simple
21:01:59 <shachaf> No wonder it was confusing.
21:02:00 <tgeeky> guard is specifically the monad (guard) function?
21:02:06 <tgeeky> @src guard
21:02:06 <lambdabot> guard True  =  return ()
21:02:06 <lambdabot> guard False =  mzero
21:02:07 <DanBurton> desaiu: no don't that's a bad link
21:02:18 <shachaf> tgeeky: No, it's Haskell guard syntax. As in |.
21:02:43 <tgeeky> shachaf: yeah, i thought that was 'pattern guard'
21:02:50 <desaiu> shachaf: Not yet, I'm at Type Basics in YAHT
21:03:01 <DanBurton> desaiu: here try this one: http://learnyouahaskell.com/syntax-in-functions#guards-guards
21:03:06 <desaiu> And school has been slamming me hard lately
21:03:11 <tgeeky> shachaf: oh, no. nevermind. I had that wrong.
21:03:45 <desaiu> Thanks DanBurton, that's what I've been seeing
21:08:14 <desaiu> Is there a functional programming competition I can enter when I'm through with this?
21:08:29 <desaiu> I figure such a thing would be fun
21:09:31 <adrake> there's the icfp contest
21:09:41 <adrake> which is a lot of fun
21:10:07 <desaiu> I'm not in a school which participates in ACM
21:10:15 <companion_cube> but it's better to do it in teams
21:10:17 <adrake> you don't need to be affiliated with any school
21:10:19 <adrake> just a team
21:10:22 <desaiu> Really!
21:10:23 <adrake> or you could solo it
21:10:24 <desaiu> Okay!
21:10:34 <desaiu> I don't mind going solo
21:10:35 <companion_cube> it's tough for a solo guy :)
21:10:41 * adrake and a bunch of friends gathered in a conference room at Mozilla HQ
21:10:50 <adrake> no schools or other orgs involved :P
21:10:58 <desaiu> I know a guy I can pair up with
21:11:09 <desaiu> two of them
21:11:16 <DanBurton> when is the icfp contest?
21:11:33 <DanBurton> *the next one
21:11:54 <adrake> I think it is usually in June?
21:12:02 <Sgeo|web> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/packages/HUnit-1.2.2.3/doc/html/Test-HUnit.html
21:12:12 <Sgeo|web>     test1 = TestCase (assertEqual for (foo 3), (1,2) (foo 3))
21:12:29 <Sgeo|web> I don't know if that's an error in the Haddock comments or what, butn just wanted to point that out
21:12:33 <desaiu> Then again, these guys probably wouldn't want to put their reputations on the line
21:12:36 <desaiu> I can go solo
21:12:36 <adrake> it is some number of months before ICFP, which is september 9 next year
21:12:48 <adrake> desaiu: you can enter pseudonymously, I'm pretty sure
21:13:05 <adrake> team names were the only publicly visible thing last year
21:13:07 <desaiu> I can't figure out where to sign up
21:13:07 <shachaf> adrake: I thought that's what pretty much everybody did, going by the team names.
21:13:15 <adrake> desaiu: it doesn't exist yet for next year
21:13:22 <adrake> wait a while :P
21:13:50 <adrake> shachaf: yeah. I didn't deal with the actual submission form, if they wanted real names and such for prize purposes etc
21:14:47 <desaiu> Okay, those problems are over my head right now, I'm going to focus on the tutorial
21:15:47 <adrake> (you can also enter ICFP-contest in any language, not just haskell, but :P)
21:15:53 <desaiu> No way
21:15:56 <adrake> last summer I got suckered into doing it in SML
21:16:07 <adrake> that was uh... informative, as to why I stopped using SML
21:16:12 <shachaf> adrake: How did that end up happening, anyway?
21:16:25 <shachaf> I thought it was weird that you didn't use a practical language like Haskell.
21:16:41 <adrake> sully walked over to my desk and was like "Want to join our ICFP-contest team? starts in ten minutes"
21:16:46 <adrake> and that was the first I had heard of the contest
21:16:55 <adrake> and they were a ML team
21:17:06 <shachaf> Ah.
21:17:12 <adrake> and I fought bitterly to switch, but rpearl didn't know any haskell at all
21:17:17 <adrake> so we stuck with ML
21:17:23 * companion_cube knows a good team which uses OCaml
21:17:24 * shachaf misread "I fought bitterly to switch to perl"
21:17:48 <adrake> shachaf: it was possible to do pretty well with bash :P
21:18:02 <companion_cube> i hope some teams use cobol
21:18:04 <ddarius> Bitter combatants make the best teams.
21:18:12 <adrake> if you ignored board state and played a /really/ /good/ fixed strategy
21:18:23 <adrake> companion_cube: I am toying with the idea of doing it in verilog next year
21:18:37 <companion_cube> unlambda.
21:19:22 * shachaf didn't participate in the contest, although two coworkers did.
21:19:24 <shachaf> Maybe I should try next time.
21:19:27 <companion_cube> uh, if I was in a team among the 10 first, I would quickly compile aall my code to unlambda before i submit it, to impress people ^^
21:19:39 <companion_cube> yay,  big #haskell team!
21:21:00 <shirt> should i worry about "Warning: orphan instance:" ?
21:21:20 <shachaf> Is it your instance?
21:21:26 <shirt> yeah
21:21:46 <tgeeky> your irresponsible clod!
21:22:00 <tgeeky> damn, grammar mistake ruins a borderline joke.
21:22:06 * tgeeky backs away slowly
21:22:27 <shachaf> shirt: Well, you should know, then.
21:22:41 * ddarius never feels even the remotest desire to take part in programming competitions.
21:23:14 <shirt> shachaf: i read the docs and i understand why i'm getting the warning but i don't understand why it's bad
21:23:39 <shachaf> That's actually the main reason I've never done it, with s/ddarius/shachaf/
21:23:54 <shachaf> shirt: Well, you could easily have multiple modules defining orphan instances, for instance.
21:25:27 <shirt> shachaf: hm... i'm only using the instance internally in the module. can i not export it? will that help?
21:26:23 <shachaf> You can't not export instances.
21:40:56 <Afzal> guys... i'm getting overfull because of a long line in my literate haskell code
21:41:24 <shachaf> Is this a TeX question?
21:42:00 <Afzal> ...sorta.. :/
21:47:19 * ddarius briefly considers implementing TeX in the type system.
21:49:19 <DanBurton> @google hatex
21:49:20 <lambdabot> http://www.haskell.org/haskellwiki/HaTeX
21:49:20 <lambdabot> Title: HaTeX - HaskellWiki
21:51:55 <kniu> so I'm trying to use the LLVM bindings
21:51:59 <kniu> and I run into this:
21:52:00 <kniu> Loading package llvm-0.10.0.1 ... can't load .so/.DLL for: lib.so (lib.so: cannot open shared object file: No such file or directory)
21:52:06 <kniu> lib.so?
21:53:42 <rotflcopter> hey
21:54:01 <kniu> hi
21:56:04 <NemesisD> anyone have a preferred package for md5sums? i'm seeing pureMD5, nano-md5, Crypto
21:56:22 <NemesisD> i don't want to require a dependency that everyone hates
21:57:01 <Afzal> hey guys
21:57:04 <NemesisD> nano-md5 looks pretty darn simple
21:57:06 <Afzal> is there a way to "break" a line
21:57:07 <Afzal> ?
21:57:14 <Afzal> !pastebin
21:57:31 <NemesisD> http://hpaste.org
21:57:34 <hpaste> afzal pasted “testtree” at http://hpaste.org/52834
21:57:40 <Afzal> say a line like that
21:58:02 <Afzal> it's too long for the literate haskell and i really just wanna be done with this assignment :(
21:58:10 <NemesisD> yeesh
21:58:14 <Afzal> how how?
21:58:40 <NemesisD> have you tried just breaking the line where it looks good?
21:58:40 <shachaf> Afzal: Why are you putting it all on one line?
21:58:46 <Afzal> ...umm, coz it's the input for the function
21:59:48 <Afzal> @nemesisD: ghci doesn't like that
21:59:49 <lambdabot> Unknown command, try @list
22:00:26 <Afzal> actually
22:00:27 <Afzal> nvm
22:00:35 <Afzal> tabbing the new lines did it!
22:00:43 <Afzal> what about a string that's too long?
22:01:35 <Afzal> (that breaking the line manually doesn't work with a string)
22:02:31 <NemesisD> http://www.haskell.org/haskellwiki/Poor_man's_here_document
22:03:18 <NemesisD> i like the destitute man's heredoc with unlines
22:03:24 <NemesisD> gets the job done
22:03:53 <Afzal> thanks!
22:06:10 <Veinor> NemesisD: that first one is uhhhhhh
22:06:15 <Veinor> a thing
22:06:42 <NemesisD> nano-md5 uses unsafePerformIO, but don stewart wrote it. it probably isn't evil?
22:07:39 <Veinor> it looks like it uses unsafePerformIO because it has to call out to the ffi
22:07:40 <NemesisD> also doesn't compile
22:08:23 <Veinor> hpaste the error?
22:09:58 <hpaste> NemesisD pasted “nano-md5” at http://hpaste.org/52835
22:10:43 <Veinor> weird
22:10:45 <Veinor> does the same thing for me
22:12:28 <shachaf> Installs for me.
22:12:28 <NemesisD> is there some system library i need?
22:12:35 <shachaf> With some warnings, though.
22:13:43 <NemesisD> maybe i should stick with the pure haskell implementation. nano-md5s api is delightfully simple but i'm writing a library and I don't want it to drive away users
22:13:47 <Veinor> i've got libssl-dev installed
22:13:53 <Veinor> so that's not it
22:14:14 <shachaf> nano-md5 looks old.
22:14:46 <NemesisD> yup
22:17:44 <NemesisD> crypto has surprisingly few dependencies
22:18:13 <NemesisD> i wish i could tell which was more commonly installed
22:26:30 <kniu> it seems that you can't use the LLVM bindings in a ghci session
22:26:32 <kniu> bummer.
22:27:10 <NemesisD> i'm confused. i've added OverloadedStrings as an extension and yet using a literal "foobar" tells me to add an instance declaration for (Data.String.isString ByteString)
22:27:26 <shachaf> NemesisD: Well, there's no instance for it.
22:27:33 <shachaf> Except in a module whose name you're not allowed to know.
22:27:36 <shachaf> (But it ends in Char8.)
22:27:43 <shachaf> This is because ByteStrings aren't Strings.
22:28:01 <shachaf> What should "Привет" turn into as a ByteString?
22:28:20 <NemesisD> hell if i know
22:28:30 <shachaf> Well, it would depend on your encoding.
22:29:51 <NemesisD> utf i suppose. i'm just trying to rig up a demo of this md5 function
22:30:11 <shachaf> Just pack it manually.
22:30:52 <shachaf> You have a function :: [Word8] -> ByteString and also an evil one :: String -> ByteString
22:30:52 <NemesisD> well there it wants word8s
22:33:38 <NemesisD> bingo
22:37:01 <luite> what's a good way to debug reproducible segfaults in a haskell program?
22:37:46 <c_wraith> Attempt to narrow down what expression causes it, examine that expression further?
22:38:58 <luite> it doesn't always happen at the same place, but I can more or less reliably crash my app
22:39:33 <c_wraith> oh, run it from gdb, and get a stack trace.  That can narrow it down to native code, or something ghc generates...
22:42:05 <luite> hmm, that's tricky because my app is run with runhaskell, most of it is compiled
22:43:34 <c_wraith> that should still work
22:45:45 <mahiwaga> waddup
22:45:51 <mahiwaga> <<< noob user.
22:45:58 <mahiwaga> just found haskell today
22:47:34 <c_wraith> well, if you have any questions, just ask.  And if you don't have questions, feel free to lurk and see what you can absorb.  Just be aware some conversations here are not representative of the state of most haskell use. :)
22:48:00 <shachaf> c_wraith: So 'bout them zygohistomorphic prepromorphisms?
22:48:15 <c_wraith> I hear they prepromorph
22:48:29 <c_wraith> zygohistomorphically
22:48:58 <kmc> is there a portable way to silence stdout from a System.Process subprocess?
22:49:10 <kmc> on unix i can open /dev/null and pass it as a Handle
22:49:47 <shachaf> Can you still open NUL in Windows? :-)
22:50:15 <c_wraith> Hmm.  I thought there was some interface that let you specify the three handles for a subprocess.
22:50:28 <shachaf> c_wraith: Right, but presumably kmc wants something portable.
22:50:41 <kmc> there is, it's System.Process
22:50:56 <kmc> but how do I get a Handle which will discard all data written to it
22:51:00 <kmc> portably
22:51:09 <shachaf> I think the standard in Windows is that processes don't print anything to stdout. :-)
22:51:28 <c_wraith> Oh, I see.
22:51:55 <c_wraith> what does CreatePipe do?
22:52:28 <kmc> creates a pipe you can read in the parent process
22:53:08 <kmc> if you don't read from that pipe, the buffer can fill up and the child process will block on write
22:53:20 <kmc> i don't know if actually works that way on Windows
22:53:27 <c_wraith> looks like your best portable option is to use CreatePipe and fork a thread that just reads from it.
22:53:32 <c_wraith> That *should* work
22:53:36 <kmc> bleh
22:53:37 <kmc> ok
22:53:58 <luite> hmm it looks like it doesn't segfault after all, but just exits with strange error codes
22:54:33 <luite> I had a lot of ExitFailure 11, some ExitFalure 13, and now ExitFailure 139
22:55:03 <luite> does the ghc runtime have specific exit codes?
22:55:18 <shachaf> 139 is segfault.
22:55:35 <kmc> > 139 - 128
22:55:36 <lambdabot>   11
22:56:05 <luite> meh why don't I see more info or a core file somewhere? I'm new to OS X
22:56:17 <luite> does it hide them? I've already increased the ulimit
22:57:04 <c_wraith> I've never tried to get a core file on osx
22:57:14 <luite> ah /cores
22:59:46 <mauke> http://blogs.perl.org/users/mauke/2011/09/exit-statuses-and-how-works.html
23:03:04 <luite> hmm, bt is quite useless, is that always from the thread that caused the segfault?
23:03:53 <c_wraith> are you running the threaded runtime?
23:04:33 <c_wraith> I guess you're doing whatever runghc does.  and I have no clue what runtime it uses.
23:05:15 <luite> me neither, and I can't compile it to a full app because I have some libiconv problems
23:05:16 <NemesisD> guh anyone ever use puremd5? i can't seem to figure out how i'm supposed to get the output MD5Digest type into something that is actually useful
23:06:04 <c_wraith> @hackage pureMD5
23:06:04 <lambdabot> http://hackage.haskell.org/package/pureMD5
23:06:39 <NemesisD> i'm going to be annoyed if i have to call show on it and then pack that into a Text or something
23:08:16 <mauke> Serialize MD5Context
23:10:09 <c_wraith> that isn't really any better
23:10:44 <c_wraith> I mean, sure, you can convert it to a ByteString that way
23:11:00 <shachaf> What would you want to do with it?
23:11:06 <NemesisD> ohhh
23:11:27 <NemesisD> encode . md5 works just peachy. i've never encountered the serialize instance before
23:12:55 <luite> all backtraces end in __psynch_cvwait(), and then _pthread_cond_wait(), waitCondition()
23:14:31 <c_wraith> if those are segfaulting, it sounds like something is getting corrupted.  Are there C bindings involved anywhere?
23:15:07 <luite> yeah I'm suspecting heap corruption, it's a yesod web app, so it has approximately a zillion dependencies
23:15:20 <c_wraith> OS X is 64-bit on most systems now, and many C bindings are only tested on 32 bit systems.
23:15:30 <c_wraith> That can cause problems
23:15:37 <kmc> :(
23:15:46 <luite> ugh...
23:15:49 <kmc> these days i expect more libs are tested only on 64-bit
23:16:00 <kmc> maybe that's true on Linux and not OS X
23:16:13 <c_wraith> yeah, I meant the ones written on linux
23:19:50 <luite> bah I don't want to run two linux virtual machines on my laptop for this
23:21:37 <luite> I can now compile an executable, by adding /opt/local/lib to my extra-lib-dirs
23:21:56 <c_wraith> that probably won't tell you any more
23:26:14 <luite> probably not, but it is a lot harder to crash the executable than the interpreted program
23:26:23 <luite> in fact, I haven't been able to crash it
23:26:28 <luite> with at least 100 reloads
23:26:56 <luite> but that's rather annoying since yesod devel requires that the program is loded with runhaskell
23:27:12 <luite> maybe some problem with the ghc dynlinker?
23:30:08 <luite> mey I guess i'll just move everything into a linux vm then
23:32:20 <drdo> Does anyone know if there are videos of the talks at ICFP 2011 available?
23:35:28 <slack1256> what category theory books do you guys recommend?
23:55:07 <bartavelle> Hello, I'm trying to write an alternative compiler for puppet, and I'm not sure how to handle the "include" keyword
23:55:25 <bartavelle> contrary to C it just says i should load the class, but the class itself is in the top level scope
23:55:55 <bartavelle> the parser is in Parsec, and I'm trying to do all interpretation in pure code, so I'm not sure how to process include from the pure code
23:56:04 * hackagebot ghc-mod 0.6.2 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.6.2 (KazuYamamoto)
23:56:12 <bartavelle> and in Parsec, I'm not sure how to put something top level when I'm parsing ...
23:56:21 <bartavelle> if anybody has a clue, that would be nice
23:59:13 <ibid> bartavelle: is the include a textual one or semantic one?  i mean, closer to C #include or haskell import
