00:01:09 <orclev> akosch: an object in OO is just a data structure with some functions attached to it
00:02:10 <cheater> jeezus
00:02:14 <cheater> this is wrenching my head
00:02:28 <akosch> orclev: yes and I think JSON would be perfect to replace it, since it's just the data and supports all the types I need
00:05:06 <orclev> is there a cleaner way to write something like: map id &&& map show >>> uncurry zip
00:05:18 <akosch> now I just need to invent a language where you can express stuff like "if the number of elements in this list is odd, then... else..."
00:06:07 <orclev> akosch: add support for modulus and you're nearly there
00:06:27 <auastro> has anyone here put an IORef inside an IORef
00:06:32 <auastro> ?
00:06:46 <akosch> orclev: nearly, just need to implement it ;)
00:06:59 <orclev> auastro: is that kind of like putting a bag of holding inside a bag of holding? </geek>
00:07:16 <auastro> orclev: yes, yes it is
00:07:42 <auastro> I see no reason why it wouldn't work, however are there any pitfalls?
00:08:27 <orclev> auastro: I speak with no authority or knowledge whatsoever, but I shouldn't think so... conceptually an IORef is essentially a void* so far as I know
00:10:41 <orclev> auastro: testing on ghci it seems to work
00:10:55 <orclev> readIORef test >>= readIORef
00:11:09 <auastro> orclev: thanks
00:11:33 <auastro> orclev: also unfortunately I just realised that it doesn't solve my problem, but oh well
00:11:47 <orclev> auastro: lol, what's your problem?
00:13:17 <auastro> orclev: long story, essentially I want to be able to store a Rank 2 type inside a state-like monad
00:13:37 <auastro> * an object with a rank 2 type
00:14:04 <auastro> like an STRef
00:15:51 <auastro> orclev: but don't worry about it, I can just unsafeCoerce the thread type, If i really wanted to do this fully inside the haskell type system I think I would need some kind of hidden state monad
00:16:22 <auastro> orclev: that didn't allow you to ever see the state that came out.
00:26:00 <hpaste_> cheater pasted “Vty broken?” at http://hpaste.org/52029
00:26:20 <cheater> anyone know why Vty would be giving such unpredictable behaviour?
00:32:50 <hjulle> Does anyone know of a way to dynamically update a plot while doing calculations?
00:35:39 <cheater> i read that as "during hallucinations"
00:38:00 <hjulle> lol
00:39:12 <cheater> and yea, generally the idea is to put your calculation in a coroutine
00:39:31 <cheater> and have that coroutine yield consecutive values to put in the graph
00:39:53 <cheater> then the context the coroutine is yielding to updates the graph every time it gets a new value.
00:39:56 * hackagebot blaze-html 0.4.2.0 -   http://hackage.haskell.org/package/blaze-html-0.4.2.0 (JasperVanDerJeugt)
00:41:25 <hjulle> My problem is that i do not find any way to update the graph... :/
00:42:05 <hjulle> I am currently using Chart for plotting, but i could change if neccesary
00:44:59 <hjulle> Is there any library which support "lazy" plotting? i.e. plotting the data as soon as it gets some?
00:48:57 <ivanm> @tell chrisdone the ghci buffer doesn't like <<loop>> situations...
00:48:57 <lambdabot> Consider it noted.
00:49:22 <ivanm> hjulle: I think most of them want all of it to get bounds
00:49:54 <ivanm> hjulle: what you would want to do is have some kind of canvas output with a refresh rate or something and then do a scanl over the list of data
00:50:04 <ivanm> so you plot over increasing sub-sets of the data
00:50:11 <ivanm> not sure if plot supports a canvas output
00:50:44 <ivanm> oh, renderableToWindow in Graphics.Rendering.Chart.Gtk
00:50:55 <ivanm> you may even be able to use updateCanvas, I'm not sure
00:52:36 <cheater> hjulle: you throw away the old graph and build the new graph.
00:52:42 <hjulle> The problem is that renderableToWindow doesn't return anything.
00:54:42 <hjulle> But I think createRenderableWindow might work if I manage to get it working.
00:57:30 <rostayob> not strictly haskell: how do on-disk databases engines usually check that the file is not corrupted?
00:57:36 <rostayob> apart from something going wrong
00:59:46 <hjulle> [dynamic plot] Hmm... After looking at the source it seems like everything I need is there, but it's not exported :/
01:01:57 <cheater> fork
01:02:24 <cheater> rostayob: they don't
01:02:32 <ksf> are videos from icfp2011 and related things like the symposium somewhere on the net?
01:03:49 <rostayob> cheater: really? so most dbs just hope that the file stays the same?
01:04:00 <rostayob> because that's what i'm doing now with some on-disk data structures
01:04:06 <rostayob> stranges haskell i've ever written btw
01:05:40 <cheater> rostayob: they replay the log, and if it parses, then it's ok.
01:05:56 <m3ga> ksf: they will be, but haven't been yet
01:07:20 <rostayob> cheater: ok, what i missed was this: http://en.wikipedia.org/wiki/Transaction_log
01:07:43 <rostayob> yeah but how do they detect the inconsistency
01:09:09 <shachaf> Were you the person who was asking about reading and seeking yesterday?
01:09:45 <nihtml> win 2
01:09:51 <rostayob> shachaf: yes
01:10:02 <shachaf> It sounds like you're heading towards an ad hoc, informally-specified, bug-ridden, slow implementation of half of a database.
01:10:09 <shachaf> Why not just use a database of some sort?
01:10:14 <rostayob> shachaf: just a sec
01:10:14 <shachaf> nihtml: Alt-2.
01:10:29 <ksf> why not just use acid-state?
01:11:05 <rostayob> shachaf: absolutely, that's what it's going to be, i just want to learn something
01:11:22 <rostayob> reinventing a broken wheel is a good exercise imho
01:11:41 <rostayob> ksf: i want to store things that don't fit in RAM
01:12:15 <ksf> I think you can do that with acid-state.
01:12:30 <ksf> it's more flexible than the happstack thingie.
01:13:19 <rostayob> ksf: no you can't
01:13:24 <rostayob> acid-state is all in ram
01:14:01 <ksf> you don't need to commit to ram everything you commit to log, though. because you've got control over both.
01:14:57 * hackagebot wikipedia4epub 0.0.12 - Wikipedia EPUB E-Book construction from Firefox history.  http://hackage.haskell.org/package/wikipedia4epub-0.0.12 (RadoslavDorcik)
01:14:59 * hackagebot epub 0.0.6 - EPUB E-Book construction support library  http://hackage.haskell.org/package/epub-0.0.6 (RadoslavDorcik)
01:15:03 <ksf> you could, e.g., keep all keys in ram to provide fast lookup, and leave most values on disk.
01:16:06 <rostayob> ksf: yeah, right now all i wanted is just a stream on which you can append elements with an aided lookup
01:16:10 <rostayob> ksf: https://github.com/rostayob/diskstream/blob/master/Data/Disk/Stream.hs
01:16:20 <rostayob> but again it's not a serious thing
01:16:48 <dixie_> hmmm, with upload of new versions I removed "This package is obsolete..."
01:16:50 <cheater> in ghc, is there a way to print out the type of a value?
01:16:57 <cheater> i mean when i'm in a program
01:16:59 <cheater> not :t
01:17:04 <rostayob> :t typeRep
01:17:05 <lambdabot> Not in scope: `typeRep'
01:17:10 <rostayob> @hoogle typeOf
01:17:11 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
01:17:11 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
01:17:11 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
01:17:14 <rostayob> :t typeOf
01:17:15 <lambdabot> forall a. (Typeable a) => a -> TypeRep
01:17:21 <rostayob> cheater: this is your best show
01:17:22 <rostayob> *shot
01:17:25 <shachaf> rostayob: ?
01:17:25 <shachaf> Oh.
01:17:28 <ksf> > typeOf "abc"
01:17:29 <lambdabot>   [Char]
01:17:38 <cheater> thanks
01:17:43 <rostayob> np
01:17:53 <shachaf> Usually when the question is "how do I get the type of a thing", your best shot is "don't do it", not typeOf.
01:18:28 <rostayob> shachaf: i agree you shouldn't do it, but that's half a solution
01:19:14 * shachaf isn't sure what the problem is.
01:19:22 <shachaf> I guess I should just not answer.
01:19:38 <rostayob> shachaf: ?
01:20:03 <cheater> @hoogle Word -> Int
01:20:04 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
01:20:04 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
01:20:04 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
01:20:19 <rostayob> cheater: fromIntegral again?
01:21:44 <cheater> no fromEnum
01:21:54 <rostayob> ah
01:21:56 <cheater> finally Vty is yielding
01:22:02 <cheater> the idea is not to use Vty
01:22:05 <rostayob> vty the console thing?
01:22:06 <cheater> because it's broken
01:22:07 <cheater> yes
01:22:12 <cheater> instead i use putStr
01:22:17 <Gracenotes> :o
01:22:19 <cheater> and hFlush
01:22:27 <cheater> and just use Vty for colors and stuff
01:31:02 <rostayob> cheater: anyway, as shachaf said, why are you trying to get the type of something at runtime? that's quite an ugly thing to do
01:31:43 <ksf> type annotations for serialisation?
01:31:53 <rostayob> yeah that's a good use for Typeable
01:32:16 <rostayob> but i don't think that's what he was doing
01:33:22 <cheater> no i'm just debugging
01:47:46 <ivanm> @hoogle Seq a -> [a]
01:47:46 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
01:47:47 <lambdabot> Prelude repeat :: a -> [a]
01:47:47 <lambdabot> Data.List repeat :: a -> [a]
01:49:48 <hpaste_> Sebastian pasted “Hierachy” at http://hpaste.org/52030
01:52:45 <Sebasti0n> I created a hierachy data structure. I want to traverse it and find all leafs and then compare those leafs with an object. that is no problem, but after the comparison i want to jump back into the hierachy at the leaf which returned true for that comparison. how would I be able to do that? I use zippers to go up and down the tree but I cannot keep a zipper for every leaf as that would be a memory hug, right?
01:53:46 <Sebasti0n> what I came up with was just to remember the way for every leaf and the traverse the hierachy again to the leaf, but I hope to find a better way of doing what I want to do
01:54:50 <shachaf> Sebasti0n: I'm not quite sure what you mean. Can you @paste your code, maybe?
01:55:42 <Sebasti0n> The hierachy looks like this: http://hpaste.org/52030
01:56:23 <Sebasti0n> I want to traverse the hierachy and find every leaf and compare the leafs with an object I want to insert into the hierachy
01:57:25 <shachaf> Oh, you did @paste.
01:58:27 <Sebasti0n> the new object will be inserted into the hierachy at the position of the leaf which has the smallest distance to the new object
01:59:07 <Sebasti0n> now I first need to find the leaf that is closest to the object, and then insert the new object at that position (e.g. the parent of the leaf)
01:59:45 <Sebasti0n> I cant seem to think of an easy way to do this
02:03:16 <Sebasti0n> @shachaf: Do you need more information for being able to help me?
02:03:17 <lambdabot> Unknown command, try @list
02:03:47 <cheater> more brain cells
02:06:02 <shachaf> Sebasti0n: Is "remembering the way for every leaf" particularly different from keeping a zipper for every leaf?
02:07:07 <antilect> Sudoku solver :3
02:07:10 <antilect> Made in Haskell
02:07:23 * shachaf suspects he doesn't understand something, at any rate.
02:07:29 <shachaf> antilect: Haskell is a country now?
02:07:41 <antilect> :3
02:08:47 <akosch> looking for a web-server in haskell; i've looked at happstack-server and snap-server and i'm leaning towards the latter because I really don't need any high-level stuff. my only concern is about stability because snap is relatively new and calls itself "developer prerelease"
02:09:09 <RaptorRarr> Haskell: it's like a whole nother country
02:09:17 <Sebasti0n> shachaf: I wouldnt say so. but for remember the way i wouldn't need to store the tree like I need to do in a zipper
02:09:57 <luite> akosch: I wouldn't worry too much about stability. it mostly means that the API is more likely to change
02:10:32 <luite> akosch: the warp server is also relatively easy to use (and faster), hoogle uses it for example, you can use it if you don't need the high-level yesod bits
02:10:40 <akosch> luite: ok, I can live with that (if it doesn't change too much) :)
02:10:51 <akosch> luite: thanks, i'll check it out
02:11:17 <shachaf> akosch: There's also Warp.
02:12:25 <akosch> are there any comparisons (maybe with benchmarks)?
02:12:53 <luite> they're all probably fast enough
02:13:12 <rostayob> according to their benchmarks, warp is the fastest
02:13:15 <luite> warp is said to be the fastest with over 100k reqs per second on some benchmark
02:13:18 <rostayob> but it's also pretty low level
02:13:51 <shachaf> Warp and Snap's web server are pretty similar as far as levelness.
02:14:08 <akosch> luite: wow, I don't really need that
02:14:12 <rostayob> akosch: warp works with this data type: http://hackage.haskell.org/packages/archive/wai/0.4.2/doc/html/Network-Wai.html#t:Application , so it's not fancy at all
02:14:17 <akosch> luite: ... but it can't hurt
02:14:36 <rostayob> type, not data type
02:16:01 <rostayob> shachaf: well the Snap monad has some functionality in itself
02:16:28 <rostayob> Application is just Request to Iteratee
02:16:49 <akosch> rostayob: looks fine to me: I don't need anything fancy
02:17:13 <shachaf> rostayob: That's what Warp's application is too, isn't it?
02:17:16 <shachaf> Or something pretty close.
02:17:36 <rostayob> shachaf: type Application = Request -> Iteratee ByteString IO Response
02:18:05 <rostayob> Warp helps you just giving you the pre packaged Request
02:18:09 <rostayob> (which is really nice)
02:18:32 <rostayob> Snap does more stuff: http://hackage.haskell.org/packages/archive/snap-core/0.5.4/doc/html/Snap-Types.html#t:Snap
02:19:58 <akosch> rostayob: well routing may become handy
02:20:30 <luite> you can use simple guards for basic routing with warp
02:20:50 <luite> for more higher level routing you can switch to yesod
02:21:00 <rostayob> akosch: just pick one, they're both good and similar in functionality anyway
02:21:10 <rostayob> they even have similar names ehehe
02:23:07 <RaptorRarr> This is Haskell! Take a few months to write a monad or two that lets you switch between them with ease. Then, write it in that.
02:24:34 <akosch> hm, how do I get the data from POST in warp?
02:24:59 <freeasjesus> [ x | x <- [5..439], x `mod` 3 == 0]
02:25:01 <akosch> do I need to url-decode myself?
02:25:13 <rostayob> akosch: http://hackage.haskell.org/packages/archive/wai/0.4.2/doc/html/Network-Wai.html#t:Request
02:25:20 <aristid> akosch: maybe you should look into using yesod or snap instead of warp directly.
02:25:29 <rostayob> akosch: the post stuff is in the headers, not in the url. anyway it's all decoded already in the Request.
02:25:30 <Saulzar> Met some people who's startup was using haskell+yesod the other day
02:25:31 <freeasjesus> how do i get the robot to compile
02:25:31 <freeasjesus> ?
02:25:39 <aristid> Saulzar: cool, who?
02:25:54 <Saulzar> They're called hachicode
02:25:57 <RaptorRarr> [6, 9..439]
02:26:10 <rostayob> akosch: ah, decode. right.
02:26:20 <Saulzar> Unfortunately they didn't seem to interested in giving me a job, but I didn't ask directly either :-)
02:26:24 <aristid> Saulzar: getting rewarded for shopping? that's fairly boring :D
02:26:32 <Saulzar> Yeah..
02:27:42 <freeasjesus> how do i get the robot to compile my code?
02:28:10 <antilect> lambdabot,
02:28:15 <antilect> How do I use it? :)
02:28:23 <Rmx> add > before your lambda expression
02:28:25 <luite> RaptorRarr: there's already Wai for that, which can use multiple backends
02:28:26 <Rmx> > 3+ 3
02:28:27 <lambdabot>   6
02:28:29 <freeasjesus> antilect: yes
02:28:45 <Rmx> > :t map
02:28:45 <antilect> rmx thx
02:28:46 <lambdabot>   <no location info>: parse error on input `:'
02:28:46 <freeasjesus> > [ x | x <- [5..439], x `mod` 3 == 0]
02:28:47 <lambdabot>   [6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,8...
02:28:56 <Rmx> > :t []
02:28:57 <lambdabot>   <no location info>: parse error on input `:'
02:29:00 <luite> RaptorRarr: although it probably doesnt support all snap features, so it might not be an ideal match
02:29:05 <antilect> listcomprehensions are so nice :)
02:29:06 <rostayob> :t []
02:29:07 <lambdabot> forall a. [a]
02:29:10 <antilect> How did I ever live without it before
02:29:11 <Rmx> but I don't know <hat to types for types)
02:29:16 <mauke> Rmx: :t
02:29:19 <freeasjesus> > [ x | x <- [5..439], x `mod` 3 == 0]
02:29:20 <lambdabot>   [6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,8...
02:29:24 <freeasjesus> he's not doing it...
02:29:25 <freeasjesus> ah
02:29:35 <shachaf> antilect: List comprehensions are overrated.
02:29:58 <antilect> shachaf, if you say so :)
02:30:23 <luite> aristid: you need the requestBody source, quite low level
02:30:36 <luite> oops, I meant akosch
02:31:02 <luite> akosch: yesod has lookupPostParam and lookupGetParam for those
02:32:04 <rostayob> luite: the headers are in requestHeaders
02:32:20 <luite> yes but POST data is part of the body, not the headers
02:32:24 <mauke> turns out my deduplication script saves me 2.6 GiB
02:32:33 <akosch> luite: I see... I'll have only a single POST parameter so it shouldn't be too much of a hassle
02:32:38 <rostayob> luite: uhu? is it?
02:32:54 <freeasjesus> > [ x*y | x <- [1..5], y <- [99..210], y `mod` 3 == 0]
02:32:55 <lambdabot>   [99,102,105,108,111,114,117,120,123,126,129,132,135,138,141,144,147,150,153...
02:33:02 <akosch> rostayob: yes, luite is right: http://en.wikipedia.org/wiki/POST_%28HTTP%29
02:33:28 <rostayob> oh wow, that's pretty ugly
02:33:30 <akosch> rostayob: "POST requests also include a message body. This allows for arbitrary length data of any type to be sent to the server."
02:33:49 <rostayob> yeah, i guess i never had to worry about that...
02:33:49 <freeasjesus> rostayob: :(
02:34:07 <aristid> mauke: what does it deduplicate?
02:34:08 <akosch> rostayob: there is a max query length for urls i believe
02:34:08 <luite> akosch: I'm not sure how to decode the body, you can look at how lookupPostParam in Yesod is implemented, it probably uses some Wai/warp function to do the decoding.
02:34:24 <mauke> aristid: files
02:34:34 <luite> does it hardlink them?
02:34:37 <mauke> yes
02:34:46 <aristid> sounds dangerous
02:34:55 <luite> yeah, if you modify one...
02:35:10 <aristid> we totally need deduplicating filesystems :)
02:35:14 <mauke> I don't modify them
02:35:23 <aristid> mauke: is it in a special read-only folder?
02:35:36 <mauke> no
02:35:41 <shachaf> btrfs has a copy-on-write cp, I hear.
02:35:41 <luite> aristid: doesn't zfs do block-level deduplication?
02:35:48 <shachaf> btrfs will deadlock your kernel and eat your data, I hear.
02:35:53 <aristid> luite: it might
02:36:13 <aristid> shachaf: efficiency AND adventure! yay!
02:37:20 <freeasjesus> > [ x `mod` y | x <- [1..5], y <- [99..210], y `mod` 3 == 0]
02:37:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:37:27 <luite> buh my new laptop feels much slower than my old one because it doesn't have an ssd
02:38:26 <paolino1> move the ssd :-)
02:39:15 <kqr> if i have a certain kind of data (represented as a list, none the less, but standing for something else), and i'd like to attach a few functions to that, like to det the n:th element (taking in consideratoion that the list does not mean an ordinary list), how would i best do that? (my first instinct was to do something object-oriented-ish, but some googling discouraged me)
02:39:31 <akosch> luite: thanks, but I think I might just use yesod itself: speed is a non-issue; I'm happy if it can handle one request / second ;)
02:39:57 <shachaf> kqr: I don't think I understand. What does something object-oriented-ish have to do with what you're trying to do?
02:40:03 <shachaf> What *are* you trying to do? Can you rephrase?
02:40:17 <luite> akosch: hehe, yesod itself is plenty fast. the next version should have a faster route matcher (but that only really matters if you have thousands of requests per second)
02:40:19 <kqr> i'm sorry, i just woke up and i haven't been able to type normally yet
02:40:24 <kqr> i'll try to rephrashe
02:40:25 <luite> akosch: err
02:40:33 <luite> akosch: if you have thousands of routes
02:40:34 <Eduard_Munteanu> Is it something like an array?
02:40:45 <luite> and high reqs per second :p
02:41:04 <Eduard_Munteanu> Or a map?
02:41:06 <akosch> luite: I'll have around 100, tops...
02:42:17 <luite> akosch: you usually do need to recompile your yesod app if you change your templates by the way
02:42:45 <akosch> luite: I won't be using yesod templating
02:43:12 <Eduard_Munteanu> You could just provide a separate lookup function, or use an existing interface (typeclass).
02:43:12 <akosch> luite: this will be a JSON-rpc server
02:43:34 <luite> akosch: oh right, I have something similar
02:43:55 <kqr> i have some kind of data which i represent as a list, but which isn't really a list. because it isn't really a list, i can't use the normal list functions to make operations upon it (of course i can, but it would be confusing and require a lot of redundant typing.) what i want is to construct my own functions to do operations upon that list, and that part is fine. but somehow i want to "attach" those functions to that special list type, by means other tha
02:43:58 <akosch> luite: and I need to serve some static files too (probably)
02:43:58 <luite> you'll probably have some Handler RepJson handlers
02:44:16 <kqr> is that perhaps a bad idea and unnecessary?
02:44:29 <shachaf> kqr: Well, you can just make a new type.
02:44:44 <luite> akosch: the default yesod setup serves static files from /static, and generates typesafe urls for those
02:44:47 <shachaf> newtype Foo a = Foo [a]
02:44:55 <shachaf> Then write functions that operate on Foos.
02:45:02 <yitz> kqr: in what ways is your data different from a list?
02:45:05 <luite> akosch: but you can add your own routes if you need something else
02:45:06 <kqr> shachaf, that sounds like what i want to do, yeah
02:45:14 <shachaf> kqr: There you go.
02:45:26 <shachaf> kqr: If you need indexing into the list, by the way, [] is a bad type.
02:45:41 <shachaf> kqr: Depending on what you want, Data.Sequence might be good.
02:45:50 <akosch> luite: good to know. as for the JSON part I think I'll just use routes for namespacing, then handle individual request methods according to the spec
02:45:57 <kqr> yitz, it represents a form of two dimensional grid or, if you like, a binary tree
02:46:13 <kqr> yitz, perhaps there are better types already for those?
02:46:20 <luite> paolino1: yeah I planned to buy an ssd, but I bought the wrong size ski boots last week, so I have to buy another pair... those things are expensive so the ssd has to wait :(
02:46:37 <yitz> kqr: yes there are many ways. it depends on the kinds of operations you'll be needing.
02:47:08 <yitz> kqr: that question is really independent of haskell. you have to decide what representation you're using, in the abstract.
02:48:12 <kqr> yitz, it's difficult, coming from C, where you simply used an array for efficiency and lack of a better option
02:49:02 <shachaf> kqr: Well, if you have an abstract type, you can always change it later. Which was presumably the point.
02:49:10 <yitz> kqr: most of the time even in C you have something else higher-level in mind. you also need to think about the bit-twiddling at the array level due to the nature of C.
02:49:21 <luite> akosch: ah I don't really know the json-rpc spec, what does it say about the req methods?
02:49:36 <paolino1> luite: there are some 60 gb at less than 80 euro around, prices are going steadly down on those.  Time for me to leave my 32 gb soon.
02:49:52 <luite> paolino1: nah I need 250GB or so
02:50:05 <luite> need some virtual machines and some large programs an data
02:50:21 <paolino1> eh, that is different :-/
02:50:27 <akosch> luite: it's really brief spec: http://json-rpc.org/wiki/specification
02:50:29 <luite> ~300 euro I think
02:50:49 <yitz> shachaf, kqr: yes if you have in mind at least a partial list of operations you'll need, then you can easily get a first implementation which you can change later.
02:51:08 <luite> for crucial m4
02:51:14 <kqr> yitz, well yeah, what i want can be viewed as a binary tree or a 45° rotated grid, but with no order to the leaves and branches, whatsoever. i think i'm most comfortable thinking of it as a tree, even though it really is a grid. (it's for experimenting with dijkstra's algorithm)
02:51:39 <akosch> luite: you can use anything for transport (GET,POST,etc.), I prefer POST because it doesn't get cached by proxies
02:52:00 <limetree> what do you guys use for haskell programming on windows?
02:52:13 <yitz> kqr: ok, yeah, sounds like the grid part is really just how you're thinking of rendering it visually, but not really an essential part of the data type.
02:52:39 <kqr> yitz, exactly
02:52:59 <luite> akosch: ah right, hmm, yeah yesod cannot inspect the json data for routing unfortunately, a simple library could help
02:53:38 <yitz> kqr: also, if you're experimenting with dijkstra, perhaps you don't want to fix which node is the root of the tree.
02:53:40 <akosch> luite: I thought so, I was planning on using yesod routing just for namespacing
02:54:15 <akosch> luite: but I don't think I'll need a library: simple guards should suffice
02:54:54 <kqr> yitz, the tree is the place where i want to find a path from the top to the bottom
02:55:01 <kqr> yitz, so in this case, the root should be fixed
02:55:41 <luite> akosch: oh you don't need one of course, but it would be nice if json-rpc service routing could be specified the same way. I think it could easily be a library that's yesod subsite with its own routing table
02:55:57 <Eduard_Munteanu> kqr: try looking at Data.Map's API
02:56:25 <yitz> kqr: oh ok. and it's a binary tree, always exactly 2 children to each non-leaf node?
02:56:32 <kqr> yitz, yup
02:56:40 <kqr> Eduard_Munteanu, i'll take a look
02:56:57 <Eduard_Munteanu> http://haskell.org/ghc/docs/latest/html/libraries/containers-0.4.1.0/Data-Map.html
02:57:30 <akosch> luite: it would be nice indeed :)
02:57:31 <Eduard_Munteanu> To avoid naming conflicts you're supposed to import it qualified.
02:57:40 <yitz> kqr: so then something like data BinaryTree a = Leaf a | Node (BinaryTree a) (BinaryTree a) might suit you
02:58:27 <luite> akosch: so write it and send a merge request on github ;p
02:58:33 <kqr> yitz, probably, but then i got thinking, might there already be a type for that among the standard types?
02:58:34 <akosch> luite: I'll think about it :)
02:58:45 <akosch> how do I set the content-type of a response in yesod btw?
02:59:11 <yitz> kqr: there are so many kinds of tree types that people often just roll their own in each case.
02:59:21 <kqr> oh, alright
02:59:36 <luite> akosch: the RepJson response automatically does that, otherwise I think you return a pair of content type and content from your handler
02:59:37 <yitz> kqr: the classic tree type is Data.Tree, but that is a rose tree (i.e. any number of children to each node)
02:59:57 <shachaf> yitz: s/that/because/
03:00:07 <shachaf> type Tree = Mu []
03:00:10 <Eduard_Munteanu> There isn't a common interface (as in a typeclass) for this, AFAIK. I wonder if that'd make sense, though.
03:00:40 <akosch> luite: great! thanks for the help, I'll try and hack something together now
03:00:54 <aristid> Eduard_Munteanu: given that trees are distinguished by the vastly differing needs of available operations, i don't think that would be easy to design
03:01:06 <luite> akosch: ask me in #yesod if you need more help
03:01:15 <luite> or the other people there :)
03:01:58 <yitz> shachaf: not really because - although i agree that Data.Tree is far underused.
03:02:23 <akosch> luite: thanks, will do. one more thing: where is the content-type of static files decided? is it based on the file extension? is it configurable?
03:03:27 <yitz> shachaf: when Map, Set, or Sequence are appropriate, i think those are well-known and well-used. other than that, nothing much else has really caught on.
03:04:40 <kqr> yitz, i realised now that most of the nodes share childs with each other
03:04:58 <yitz> kqr: ah so it's a graph, not a tree?
03:05:14 <kqr> i'm not sure what's the difference between a graph and a tree
03:05:17 <luite> akosch: yeah, there's a list of extensions to content type somewhere. I'm not sure it's configurable with the standard static files server, but it's certainly possible to serve files with custom content types (I have a program that serves static files with custom content type, for example if you request x.ext, then it tries to thread the file x.ext.mime for the content type, if that file doesn't exist it falls back to the extension
03:05:32 <yitz> kqr: a tree is a connected graph with no cycles
03:05:36 <luite> tries to read
03:05:39 <luite> not thread
03:06:13 <kqr> yitz, think of it a little like pascals triangle
03:06:32 <ivanm> I don't think I've ever seen Data.Tree being used
03:06:51 <yitz> kqr: yeah that has cycles doesn't it?
03:06:54 <Athas> How do I print a rounded floating-point number?
03:07:02 <yitz> @type round
03:07:02 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:07:09 <ivanm> there's also printf
03:07:10 <yitz> > round 3.5
03:07:11 <lambdabot>   4
03:07:13 <ivanm> and see the Numeric module
03:07:25 <kqr> yitz, depends on what i cycle is. i haven't studied maths in english
03:07:26 <yitz> > round 4.5
03:07:27 <lambdabot>   4
03:07:27 <ivanm> Athas: wait, do you mean rounded to an Int or a specified number of decimal places?
03:07:30 <Axman6> > printf "%2.2f" pi :: String
03:07:31 <lambdabot>   "3.14"
03:07:33 <akosch> luite: I probably won't need to customize the standard list anyway, maybe if something goes wrong...
03:07:36 <ivanm> kqr: you can draw a loop
03:07:40 <ivanm> (in the graph)
03:07:55 <yitz> Axman6: eww printf
03:08:07 <kqr> ivanm, yitz, well, yeah. it wouldn't make sense to go upwards in the triangle, but you could draw a loop, sure
03:08:09 <Axman6> but it's a lovely hack!
03:08:10 <Axman6> :P
03:08:24 <yitz> Axman6: that it is, yes :)
03:08:34 <ivanm> Axman6: type-sig wise you mean?
03:08:51 <Axman6> there are times it nice to use, but for string formatting it's usually not
03:08:54 <Athas> ivanm: wait, I seem to have misinterpreted something in Haskells behaviour.  I thought its Show instance for Doubles did not perform rounding.
03:09:08 <ivanm> Athas: it doesn't
03:09:18 <dafis> well, ...
03:09:23 <ivanm> Athas: except for possibly "pretty-ing" the values
03:09:23 <dafis> it does
03:09:24 <ivanm> > 0.1
03:09:25 <lambdabot>   0.1
03:09:32 <Athas> ivanm: yes, that's waht I mean.
03:09:35 <tsousa> can someone please explain to me this lambda? http://dpaste.com/625543/
03:09:36 <ivanm> ^^ not actually represented fully like that
03:09:38 <ivanm> Athas: ahhh
03:09:51 <ivanm> yeah, unlike Python, the Show instance for Doubles, etc. does that by default
03:10:03 <dafis> kind of, it produces the shortes representation that gets parsed back to the original
03:10:20 <ivanm> tsousa: appends the value on the end of the list
03:10:31 <Axman6> @check \x -> read (show x) == (x :: Double)
03:10:32 <lambdabot>   "OK, passed 500 tests."
03:10:56 <aristid> Axman6: what IS nice to use for string formatting?
03:11:06 <ivanm> > let f = (*2) in (\ acc x -> acc ++ [f x]) [1..10] (-3)
03:11:07 <tsousa> ivan`, in this case \acc x is a function ?
03:11:07 <yitz> kqr: a cycle is a list of 4 or more adjacent nodes, all different from each other except the last equals the first.
03:11:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,-6]
03:11:18 <ivanm> tsousa: a lambda function, yes
03:11:22 <ivanm> which takes two arguments
03:11:23 <Axman6> that's a good question actually
03:11:36 <ivanm> aristid: pretty-printing libraries
03:11:38 <Axman6> i'd use printf, i'd like to know if there's a better way
03:11:40 <kqr> yitz, yeah, and it depends on if you consider the graph to be directed or not
03:11:49 <ivanm> coupled with the functions in Numeric for custom representation of floating-point values, etc.
03:11:57 <tsousa> ivanm, -> indicates the body of the function right?
03:12:00 <yitz> kqr: right. i'm thinking of undirected graphs.
03:12:01 <ivanm> tsousa: yeah
03:12:20 <tsousa> ivanm, thanks
03:12:22 <ivanm> yitz: what are discussing graphs for?
03:12:27 <kqr> yitz, for all intents and purposes here, i could consider my graph directed, as the only sensible walking would be "downwards," or further towards the leaves
03:12:59 <yitz> ivanm: kqr is writing a program that uses them and is trying to decide what representation to use
03:13:10 <ivanm> wow... my program now spends about 15% of the time just adding edges to the graph...
03:13:22 <ivanm> kqr: what are you doing?
03:14:04 <kqr> ivanm, i want to experiment with dijkstras algorithm on a graph similar to pascal's triangle, only with no ordering whatsoever to the nodes
03:14:44 <ivanm> pascal's triangle is a graph?
03:14:56 <ivanm> oh, you mean something like this? http://en.wikipedia.org/wiki/File:TrianguloPascal.jpg
03:15:07 <kqr> ivanm, precisely
03:15:09 <ivanm> or this? http://en.wikipedia.org/wiki/File:Yanghui_triangle.gif
03:15:16 <ivanm> so it's not a Tree then
03:15:23 <ivanm> it's definitely a graph
03:15:33 <kqr> ivanm, they look the same to me, only rotated 45°
03:15:35 <ivanm> fgl has djikstra's implemented
03:15:53 <ivanm> kqr: the first one has an extra edge in it from how I'm looking at it
03:15:58 <ivanm> or maybe I'm looking at it wrong... :p
03:17:29 <kqr> anyways, i know how to represent it as a list or as an array, but that doesn't feel like the most logical choice
03:18:11 <kqr> a binary tree would be possible, but there are so many shared nodes, and i haven't used binary trees before, so i don't know how well they handle that
03:18:21 <ivanm> it's not a tree, it's definitely a graph
03:18:29 <ivanm> most graph implementations in Haskell use a Map under the hood
03:18:54 <ivanm> because unlike an array-based one, you don't have to worry about "ZOMG, it's not big enough!"
03:19:37 <kqr> okay
03:20:13 <ivanm> very simplistically, an unlabelled graph is: type Graph a = Map a [a]
03:20:23 <ivanm> where the list represents the edges
03:20:50 <ivanm> if you want labels, you can do something like: type Graph n nl el = Map n (nl, [(n,el)])
03:21:11 <kqr> oh my
03:21:19 <kqr> i probably need to read up on both types and maps
03:21:24 <ivanm> heh
03:21:30 <ivanm> OK, let's go back a couple of steps
03:21:36 <ivanm> a Map is a lookup-table/dictionary
03:21:38 <yitz> Axman6: well there are the functions in Numeric. You can combine those with list operations on String to get some other things fairly simply.
03:21:48 <kqr> ivanm, i managed to catch that, yeah
03:21:55 <ivanm> "Map k v" has keys of type `k' with values of type `v'
03:22:00 <freeasjesus> > [ x `mod` y | x <- [1..5], y <- [99..210], y / 2 == 0]
03:22:01 <lambdabot>   Ambiguous type variable `t' in the constraints:
03:22:01 <lambdabot>    `GHC.Real.Fractional t'
03:22:01 <lambdabot> ...
03:22:01 <yitz> Axman6: still not the full generality of printf without things getting pretty hairy though.
03:22:34 <yitz> Axman6: that said, in my own work, i never need anything more than that.
03:22:40 <ivanm> > let m = M.fromList [(1,'e'), (3,'6'), (-2,'!')] in M.lookup 3 m
03:22:41 <lambdabot>   Just '6'
03:22:47 <Axman6> for output of simply formatted strings, i doubt you'll find anything much more convenient than printf
03:22:57 <ivanm> Axman6: yeah
03:23:11 <ivanm> but if you're doing some kind of large output, you should almost definitely be using a pretty-printing library
03:23:15 <yitz> Axman6: right, when you need stuff more complex than what is in Numeric.
03:23:16 <Axman6> sure
03:23:19 <kqr> > :t M.fromList [(1,'e'), (3,'6'), (-2,'!')]
03:23:19 <lambdabot>   <no location info>: parse error on input `:'
03:23:26 <kqr> oh
03:23:30 <ivanm> kqr: drop the ">"
03:23:32 <kqr> can lambdabot do that?
03:23:34 <kqr> :t M.fromList [(1,'e'), (3,'6'), (-2,'!')]
03:23:35 <lambdabot> forall t. (Num t, Ord t) => M.Map t Char
03:23:37 <kqr> cool
03:23:41 <ffr> what should I do if during cabal install some dependent package is compiling forever?
03:23:44 <ivanm> @type M.fromList [(1,'e'), (3,'6'), (-2,'!')]
03:23:45 <lambdabot> forall t. (Num t, Ord t) => M.Map t Char
03:23:58 <ivanm> ffr: either wait, or kill it
03:24:12 <ffr> but I need that package
03:24:12 <ivanm> if you kill it, you then don't have the package you _did_ want ;)
03:24:19 <ivanm> which package is taking forever?
03:24:21 <kqr> ivanm, but yeah, i'm with you so far now
03:24:26 <ivanm> and is it actually stuck?
03:24:35 <ivanm> kqr: OK, so "type" is a way of describing an alias
03:24:56 <ivanm> by having "type Graph = Map Int [Int]", I can now just use the term "Graph" everywhere in type sigs
03:25:01 <ivanm> note that it's only a documentation thing
03:25:14 <ivanm> it won't prevent you from mixing a Graph up with any other "Map Int [Int]"
03:25:14 <shachaf> Don't use type. :-(
03:25:17 <ffr> Crypto.CPoly
03:25:21 <kqr> ivanm, okay
03:25:30 <ivanm> shachaf: as a quick`n`dirty thing to demonstrate what I'm talking about, why not?
03:25:40 <shachaf> type is evil.
03:25:41 <ivanm> or for internal details to avoid writing large type signatures everywhere?
03:25:46 * shachaf wishes newtype was more convenient.
03:26:03 <ivanm> shachaf: you mean without that pesky constructor to worry about?
03:26:04 <ivanm> ;)
03:26:20 <shachaf> ivanm: Exactly.
03:26:23 <ivanm> I would definitely love for type to have similar compile-time guarantees to newtype
03:26:24 <yitz> ivanm: and deconstructor
03:26:36 <shachaf> Almost everywhere that people use type, they should bs using newtype.
03:26:43 <shachaf> type UserId = String -- :-(
03:26:55 <kqr> ivanm, and would Map Int [Int] in my case be a mapping from the "level" number to the list of nodes on that level?
03:27:10 <ivanm> kqr: no: each Int is a node
03:27:31 <ivanm> so saying "M.lookup 3 myGraph" would get you an adjacency list for the `3' node
03:27:39 <ivanm> I know that the stuff I'm hacking on I just managed to get two different aliases mixed up (it actually all cancelled out in the end though)
03:27:50 <kqr> ivanm, ahaaa
03:27:54 <ivanm> but actually having a newtype would be too much of a hassle
03:28:32 <shachaf> ivanm: You should figure out a way of making newtype less of a hassle.
03:28:58 <ivanm> shachaf: my intuition is that you need constructors for type inference
03:29:10 <kqr> ivanm, but then perhaps a separate type for the nodes would be in place, if the smame number happens to occur twice in the triangle?
03:29:10 <ivanm> so if we didn't have type inference and explicit type tagging, then it might be possible
03:29:14 <ivanm> but I'm not a type theorist
03:29:28 <ivanm> kqr: right, that's when the concept of labels come into play
03:29:31 * shachaf unsafeCoerce
03:30:07 <ivanm> kqr: so we have three possible "values": some type we use as an abstract node ID type
03:30:32 <ivanm> (in FGL, this is a type alias of Int; the current graph library I'm hacking on uses an opaque newtype of Int so you can't accidentally mix and match)
03:30:53 <yitz> shachaf: what you want is something that automatically creates a type class, and automatically lifts to a method every function that mentions the original type.
03:30:57 <ivanm> you then have some kind of value tagged on to the nodes to represent a value; in your case, the value in that part of the triangle
03:31:10 <yitz> shachaf: but do really want that?
03:31:11 <ivanm> similarly, you can have a label for edges
03:31:12 <shachaf> yitz: ...I hope that's not what I want.
03:31:26 <ivanm> shachaf: agreed
03:31:38 <yitz> shachaf: :)
03:32:00 <ivanm> kqr: so, in your case we want Int node labels, and we don't care about edge labels so let's use ()
03:32:08 <ivanm> or just not bother at all
03:32:17 <kqr> ivanm, yeah
03:32:19 <yitz> shachaf: otherwise, i think we're kind of stuck with constructors and deconstructors for newtypes. which means people will sometimes be too lazy to use them.
03:32:34 <ivanm> to distinguish between node IDs and node labels, let's do: newtype Node = Node { nodeValue :: Int }
03:32:49 <ivanm> we then have: type Graph = Map Node (Int, [Node])
03:32:51 <yitz> shachaf: look on the bright side, at least we have the newtype deriving extension.
03:33:27 <ivanm> adding extra type safety (which is one of the main strengths/features of Haskell), you'd probably use a custom type to represent "NodeInformation" or something (for the label and the adjacency list) and then wrap the map in a newtype
03:35:39 <yitz> ivanm: what's the extra Int you added?
03:35:46 <ivanm> yitz: the node label
03:35:59 <ivanm> since he wants to store the actual value in the Pascal Triangle for each node
03:36:30 <yitz> ivanm: oh. hmm, are you sure we want all of that in the same map?
03:36:48 <ivanm> yitz: sure, why not?
03:36:59 <ivanm> is there any real advantage in having a second map just for the node label?
03:37:14 <yitz> ivanm: oh i see ok
03:54:11 <ivanm> is Seq.>< lazy?
03:54:24 <ivanm> wait, nvm
03:54:34 <ivanm> dammit, I need some lazy form of Seq.length...
03:55:35 <ivanm> is there a way of saying "is this Seq have more than `n' values" which doesn't require traversing (and hence constructing) the entire Sequence?
03:56:56 <kqr> some variation of take?
03:58:11 <ivanm> hmmm, that could work
03:58:13 <ivanm> thanks kqr
04:00:10 <ivanm> so if Seq.>< lazy, then this would be even better
04:01:10 <JuanDaugherty> what operator is ".><" ?
04:01:25 <ivanm> JuanDaugherty: >< is like ++ but for sequences
04:01:31 <JuanDaugherty> ah
04:01:42 <ivanm> it's also a log-based factor rather than O(n)
04:06:14 <jmcarthur> ivanm: another way would be to index with lazy naturals, but you would have to go with a different kind of fingertree for that and other kinds of indexing would be slower
04:06:27 <ivanm> well, I'm not using indexing
04:06:37 <jmcarthur> it still doesn't make >< lazy enough to avoid that operation i think
04:06:49 <ivanm> the operations I'm doing are: viewl, <|, |> and <>
04:07:19 <ivanm> I can't use dlists because of the viewl requirement
04:07:23 <jmcarthur> i think i would just try to split the list at index n and see if the right side is empty or not
04:07:32 <ivanm> jmcarthur: huh, even better
04:07:41 <jmcarthur> s/list/sequence/
04:08:33 <ivanm> jmcarthur: actually, elemIndexL would probably be even better
04:08:36 <jmcarthur> i think the entire sequence basically has to be constructed though
04:08:38 <ivanm> no, wait, duh
04:08:40 <ivanm> that's dumb
04:09:09 <jmcarthur> it just has good algorithmic complexity
04:09:11 <Eduard_Munteanu> Yeah, I guess you'd have to define your own length in terms of foldr on Peanos or something like that.
04:09:29 <ivanm> why isn't there a Maybe version of Seq.index? :/
04:09:35 <ivanm> Eduard_Munteanu: *nod*
04:09:37 <Eduard_Munteanu> @hoogle safeindex
04:09:38 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
04:09:54 <ivanm> as it stands though, after adding in all this functionality to my program, it went from 2:30 to 4:30
04:10:17 <ivanm> by testing the length of the sequence to filter some values out, it dropped to 3:30
04:10:24 <ivanm> by using take rather than length, it's 3:10
04:11:11 <ivanm> wait, that 3:08 is a lie, because I should have been using drop rather than take... so it;s 3:10 for no results :s
04:13:27 <Eduard_Munteanu> I guess you could try using fold{l,r}WithIndex for that.
04:17:17 <ivanm> Eduard_Munteanu: for a lazy length?
04:17:31 <Eduard_Munteanu> Nah, for safe indexing.
04:18:41 <Eduard_Munteanu> You can't do lazy length without using some notion of lazy numbers.
04:18:57 <ivanm> yeah
04:20:26 <Eduard_Munteanu> I wonder why Haskell doesn't use lazy numbers by default, though.
04:21:01 <ivanm> performance
04:21:06 <ivanm> (is my guess)
04:21:47 <Rmx> hello, I'm using windows 7, I installed OpelAL, using msys, all complete without problem, but when I do "ghc-pkg list", openAL n'apparait pas
04:21:55 <Eduard_Munteanu> Or convenience? I imagine it should be possible to use seq to deal away with the laziness, or unboxed numbers.
04:22:23 <Rmx> but it's magic because ALUT (open al Utility toolkit, that rely on openAL install after without problem
04:22:38 <ivanm> Rmx: you install the _Haskell_ OpenAL library?
04:22:39 <Rmx> I can write code using import Sound.ALUT
04:22:46 <Rmx> yes
04:22:52 <ivanm> you sure you aren't just missing it?
04:22:53 <Rmx> but when I compile
04:22:57 <ivanm> or it isn't called a different name?
04:22:57 <Rmx> I have runtime error :
04:23:06 <Rmx> no, no different name
04:23:19 <ivanm> not a user vs global package db issue?
04:23:52 <Rmx> how should I check?
04:24:00 <Rmx> when I compile, I have this kind of errors
04:24:01 <Rmx> C:\Users\remi\AppData\Roaming\cabal\ALUT-2.2.0.0\ghc-7.0.3/libHSALUT-2.2.0.0.a(Initialization.o):fake:(.text+0x1c5): undefined reference to `alutExit@0'
04:24:02 <Rmx> C:\Users\remi\AppData\Roaming\cabal\ALUT-2.2.0.0\ghc-7.0.3/libHSALUT-2.2.0.0.a(Config.o):fake:(.text+0x2a5): undefined reference to `alutInit@8'
04:24:02 <Rmx> C:\Users\remi\AppData\Roaming\cabal\ALUT-2.2.0.0\ghc-7.0.3/libHSALUT-2.2.0.0.a(Config.o):fake:(.text+0x339): undefined reference to `alutExit@0'
04:24:02 <Rmx> C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x365): undefined reference to `alIsSource'
04:24:12 <Rmx> notice the '\' and '/'
04:24:21 <ivanm> doesn't look like it compiled properly then
04:24:44 <Rmx> that's what I thought
04:24:48 <Rmx> so I compilated again
04:24:53 <Rmx> but all succed without problem
04:25:03 <Rmx> succeed*
04:25:20 <ivanm> but "ghc-pkg list ALUT" doesn't list it?
04:25:22 <Rmx> can't it be linked to those '\' and '/'
04:25:25 <ivanm> what about "cabal list ALUT" ?
04:25:28 <ivanm> Rmx: I don't think so
04:25:34 <ivanm> I think it's a problem finding the C libraries
04:25:38 <Rmx> no, ghc-pkg list show ALUT o_O
04:25:42 <ivanm> huh
04:25:43 <Rmx> that's the main problem
04:25:48 <Rmx> it's illogical
04:25:51 <ivanm> does "ghc-pkg check" complain?
04:26:14 <ivanm> Rmx: does it work if you find the ALUT dll and copy it into the directory with your source?
04:27:15 <Rmx> yes, ghc-pkg complains a lot
04:27:20 <Rmx> and I'll try to ass the dll
04:27:26 <Rmx> but I'll try a reboot
04:27:34 <Rmx> and any cleaning
04:27:41 <Rmx> and see if it works under linux
04:27:45 <Rmx> thanks for the tips
04:27:49 <Rmx> I come back after
04:27:54 <Rmx> add*
04:27:57 <Rmx> not ass
04:28:26 <akosch> i've tried snap init, compiled the project and it worked fine. but when trying with snap init -b i get the pasted messages http://pastebin.com/3MMv9QBU i assume the app can't read the log files, but why are the warnings all garbled?
04:28:27 <mauke> The paste 3MMv9QBU has been copied to http://hpaste.org/52036
04:28:56 <mauke> multithreading, fuck yeah
04:29:21 <Rmx> Loading package ObjectName-1.0.0.0 ... linking ... done.
04:29:21 <Rmx> Loading package StateVar-1.0.0.0 ... linking ... done.
04:29:21 <Rmx> Loading package Tensor-1.0.0.1 ... linking ... done.
04:29:21 <Rmx> Loading package OpenAL-1.4.0.0 ... linking ... ghc: unable to load package `OpenAL-1.4.0.0'
04:29:32 <Rmx> now, it shows in ghc-pkg list
04:29:38 <Rmx> as well as ALUT
04:29:46 <Axman6> :|
04:29:49 <Rmx> and no, dll doesn't change anything
04:30:23 <Rmx> but package list is now correct, and problem seems more clear
04:30:26 <Rmx> any idea?
04:35:46 <tsousa> can someone explain to me why do i need length in this functions? http://dpaste.com/625581/
04:36:22 <mauke> you don't
04:37:26 <tsousa> yes but why is there?
04:38:14 <mauke> I don't know; I didn't write that code
04:39:16 <opqdonut> tsousa: what do you want the function to do?
04:39:22 <tsousa> mauke, that code was on lyah
04:39:46 <opqdonut> instead of length+takeWhile+scanl+map you could write a recursive function that does all of that
04:39:50 <tsousa> that code should give me the sqrt of all number under 1000
04:40:04 <opqdonut> well that it doesn't do
04:40:35 <mauke> tsousa: why do you think it should do that?
04:40:39 <opqdonut> it gives you the largest number n such that the sum of the square roots of [1..n] is <1000
04:40:58 <tsousa> yes
04:41:19 <mauke> > [1 ..]
04:41:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:41:24 <mauke> > map sqrt [1 ..]
04:41:24 <lambdabot>   [1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.449489742...
04:41:30 <mauke> > scanl1 (+) (map sqrt [1 ..])
04:41:31 <lambdabot>   [1.0,2.414213562373095,4.146264369941973,6.146264369941973,8.38233234744176...
04:41:41 <mauke> > takeWhile (< 1000) (scanl1 (+) (map sqrt [1 ..]))
04:41:41 <lambdabot>   [1.0,2.414213562373095,4.146264369941973,6.146264369941973,8.38233234744176...
04:41:45 <mauke> > length (takeWhile (< 1000) (scanl1 (+) (map sqrt [1 ..])))
04:41:46 <lambdabot>   130
04:41:50 <mauke> > length (takeWhile (< 1000) (scanl1 (+) (map sqrt [1 ..]))) + 1
04:41:51 <lambdabot>   131
04:43:42 <tsousa> ok i know understand the code
04:43:43 <tsousa> thanks
04:43:57 <opqdonut> mauke: I was about to recommend hpaste for that, but it seems it doesn't work http://hpaste.org/steps/52038
04:45:51 <cheater> is there a different name for take n $ repeat c           ?
04:46:12 <ClaudiusMaximus> replicate
04:46:36 <mauke> @hoogle Int -> a -> [a]
04:46:36 <lambdabot> Prelude replicate :: Int -> a -> [a]
04:46:37 <lambdabot> Data.List replicate :: Int -> a -> [a]
04:46:37 <lambdabot> Prelude drop :: Int -> [a] -> [a]
04:49:30 <cheater> thx mauke
04:50:15 <aristid-andro> cheater: ClaudiusMaximus was faster
04:54:44 <cheater> aristid-andro: but mauke lasted longer before he finished
04:55:13 * ClaudiusMaximus refactoring algorithm :: IO (Maybe X) {- IO for updating progress bar -} into algorithm :: [Progress] where data Progress = StillWorking | Fail | Success X
04:56:11 <cheater> so you don't want to actually show the progress?
04:56:40 <ClaudiusMaximus> cheater: well, now i can test the algorithm in ghci with mapM_ print algorithm
04:56:54 <Rmx> I can understand that linux had more popularity amongst developpers years ago, but it looks like all those errors I have when I try to link openAL (C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x365): undefined reference to `alIsSource'
04:56:54 <Rmx> C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x1579): undefined reference to `alSourcei'
04:56:54 <Rmx> C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x1621): undefined reference to `alSourceUnqueueBuffers'
04:56:54 <Rmx> C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x16b1): undefined reference to `alSourceQueueBuffers'
04:56:54 <Rmx> C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x1741): undefined reference to `alGetSourceiv'
04:56:55 <Rmx> C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x17d1): undefined reference to `alSourcefv'
04:56:55 <Rmx> C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x1861): undefined reference to `alGetSourcefv'
04:56:56 <Rmx> C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x25aa): undefined reference to `alSourcefv'
04:56:56 <Rmx> C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x301d): undefined reference to `alSourcePlayv'
04:56:57 <Rmx> C:\Users\remi\AppData\Roaming\cabal\OpenAL-1.4.0.0\ghc-7.0.3/libHSOpenAL-1.4.0.0.a(Source.o):fake:(.text+0x30c1): undefined reference to `alSourcePausev'
04:56:57 <Rmx> ....)
04:56:59 <ClaudiusMaximus> cheater: whereas before i'd have to recompile the gtk app
04:57:07 <dmwit> Rmx: Please don't paste in here.
04:57:12 <Rmx> sorry
04:57:13 <dmwit> Use a pastebin like hpaste.org.
04:57:19 <Rmx> is just linked to naming conventions
04:57:20 <cheater> ClaudiusMaximus: useful
04:57:34 <Rmx> not being coherent between linux and windows
04:57:41 <dmwit> Rmx: If you're on GHC 6.12 or earlier, you can probably fix all of those by simply adding --make to your compile line.
04:58:09 <Rmx> what a shame to see all this time spent to solve this kinds of things :(
04:58:20 <ClaudiusMaximus> Rmx: naming conventions smells like stdcall vs ccall or whatever the options are for ffi
04:58:28 <Rmx> yes
04:58:31 <Rmx> I'm under windows
04:58:43 <Rmx> so I'm stuck?
04:58:56 <Rmx> except changing all bindings myself?
04:58:59 <Rmx> am I right?
04:59:15 <dmwit> If that's the problem, then yes, you would have to patch the bindings yourself.
04:59:16 <cheater> if you're under windows you're stuck anyways
04:59:25 <Rmx> :/
04:59:59 <Rmx> I can't afford to use linux and so loose 90 percet of targeted audience
05:00:17 <Rmx> and neither feel confident doing so for such a library as OpenAL
05:00:32 <dmwit> Rmx: The Haskell FFI *does* offer stdcall. It comes standard with GHC.
05:00:41 <Rmx> ok ok..
05:00:47 <Rmx> I'll see what I can do..
05:00:55 <Rmx> but grr, I'm tired of deceptions like this
05:00:59 <Rmx> it's way much too often
05:01:08 <dmwit> > (7777777 ^ 7777777) `mod` 10000000
05:01:15 <lambdabot>   mueval: ExitFailure 1
05:01:15 <lambdabot>  mueval-core: Time limit exceeded
05:01:19 <Rmx> sorry for flooding, and thanks for help
05:01:19 <Rmx> bye
05:01:45 <dmwit> todun: Oh, hi, is this the same Todun from Scala Club? =)
05:01:54 <dmwit> oh, he left
05:01:58 <dmwit> bleh
05:02:58 <zenzike> hello all, I'm trying to extract some information from a site using tagsoup, except I need to be logged in to the website in order to get to the page I need. Does anybody have any suggestions about how this might be done?
05:04:01 <dmwit> Network.Browser offers cookie facilities.
05:04:06 <zenzike> (I imagine this will require holding cookies)
05:04:09 <dmwit> libcurl likely does as well.
05:04:16 <zenzike> dmwit: thanks
05:11:19 <cheater> http://cheater.posterous.com/haskell-curses
05:11:33 <cheater> Using Haskell to easily build interactive text-mode applications with HSCurses, NCurses or Vty
05:29:21 <engla> what does (..) do in haskell?
05:29:45 <hpc> engla: depends on where it is; it's syntax
05:29:46 <dmwit> enumFromTo
05:29:49 <dmwit> or enumFromThenTo
05:29:54 <dmwit> > enumFromTo 1 10
05:29:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
05:29:57 <hpc> > [1..10]
05:29:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
05:30:00 <dmwit> > enumFromThenTo 1 4 10
05:30:01 <lambdabot>   [1,4,7,10]
05:30:02 <engla> oh oh something obvious. so that's why it's reserved
05:30:10 <hpc> > [1, 4...10]
05:30:10 <engla> I wanted to define it as an operator
05:30:10 <lambdabot>   Not in scope: `...'
05:30:16 <hpc> > [1, 4..10]
05:30:16 <lambdabot>   [1,4,7,10]
05:30:22 <hpc> indeed
05:30:29 <ion> It also has a meaning in export lists.
05:30:37 <dmwit> engla: You can enable OverideableSyntax or some such thing, import the Prelude hiding enumFromTo/enumFromThenTo, and define them yourself.
05:30:50 <hpc> you can put "(..)" after a type in an export list to say "also export the constructors"
05:30:53 <dmwit> engla: ...but it will still only be available in the limited syntactic forms given by lists.
05:30:59 <yitz> engla: use ...
05:31:08 <yitz> > let (...) = (+) in 2 ... 3
05:31:08 <lambdabot>   5
05:31:12 <hpc> or (.:)
05:31:43 <engla> yeah probably ...
05:33:27 <Axman6> > let a ... b = [a..b] in 1 ... 10
05:33:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
05:33:38 <Afzal> how do i know if "(a,x)" contains a? :/
05:33:42 <Afzal> sorry, ultra-newb here
05:33:54 <dmwit> What does "contains" mean?
05:34:10 <dmwit> Are you looking for "fst"?
05:34:11 <Afzal> it's present in the string
05:34:13 <dmwit> > fst (5, "hey")
05:34:14 <lambdabot>   5
05:34:22 <hpc> > let x = (1, 2) in (fst x) == 1
05:34:23 <lambdabot>   True
05:34:26 <Afzal> no, "(a,x)" is a string sadly
05:34:26 <dmwit> Oh, you mean the literal string "(a,x)"?
05:34:34 <dmwit> > 'a' `elem` "(a,x)"
05:34:35 <lambdabot>   True
05:34:42 <Afzal> o thanks!
05:34:43 <hpc> > let x = read "(1, 2)" in (fst x) == 1
05:34:43 <lambdabot>   Ambiguous type variable `b' in the constraint:
05:34:44 <lambdabot>    `GHC.Read.Read b' arising...
05:34:56 <hpc> > let x = read "(1, 2)" :: (Int, Int) in (fst x) == 1
05:34:57 <lambdabot>   True
05:34:59 <dmwit> > "a" `isInfixOf` "(a,x)"
05:35:00 <lambdabot>   True
05:35:13 <Afzal> cool, thank you very much
05:36:07 <engla> isInfixOf is from Data.List
05:38:25 <mauke> @free map
05:38:26 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
05:49:37 <rahul> Given a file path, is there a way to read the file as a list of strings?
05:51:00 <byorgey> lines `fmap` readFile path
05:52:15 <aristid> now, just for fun, imagine the java code to do the same thing
05:52:42 <cheater> how about not
05:53:03 <aristid> cheater: free to choose
05:53:08 <cheater> phew
05:53:15 <RaptorRarr> No, don't imagine it! It will ruin your ability to think clearly!
05:53:23 <cheater> yes
05:54:36 <hjulle> Is there a version of zip which raises an error if the lists are not of equal size?
05:55:38 <aristid> hjulle: write it?
05:55:56 <hjulle> ok
05:57:13 <mzero> hjulle: raise an error? what a mean thing to do to a Haskell program!
05:57:40 <RaptorRarr> > let zimg [] [] = []; zimg (x:xs) (y:ys) = (x, y):zimg xs ys; zimg _ _ = error "ZIMG!" in zimg [1..10] [2..11]
05:57:40 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
05:58:03 <rahul> Thanks, byorgey
05:58:49 <hjulle> mzero: I could try to statically encode the length in the type, but I think this should suffice in this case. ;-)
05:59:09 <mzero> ah - it is a static length issue --
05:59:28 <Nimatek> > let myZip xs ys | length xs == length ys = Right zip xs ys; | otherwise = error "not same length" in myZip [1..10] [1..11]
05:59:29 <lambdabot>   <no location info>: parse error on input `|'
05:59:30 <mzero> here I was worried you were going to like try to catch that error and then do something
05:59:40 <Nimatek> > let myZip xs ys | length xs == length ys = Right zip xs ys | otherwise = error "not same length" in myZip [1..10] [1..11]
05:59:41 <lambdabot>   Couldn't match expected type `[a] -> [a1] -> t'
05:59:41 <lambdabot>         against inferred ty...
06:00:36 <mzero> you want   Right (zip xs ys)
06:00:37 <ion> > zip [1..10] [0..]
06:00:38 <lambdabot>   [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9)]
06:00:44 <Nimatek> mzero: Indeed.
06:01:11 <ion> > zip [1..] [0..]
06:01:11 <lambdabot>   [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9),(11,10),(12,1...
06:03:51 <hjulle> mzero: [errors] I have programmed a bit in Erlang too, so I be used to
06:03:54 <shirt> when i run 'cabal install -ffoo x', is the 'foo' flag passed to all of the dependencies, or just to x?
06:04:03 <hjulle> "letting things crash"
06:04:36 <mzero> shirt: that is a good question - I wish I knew!
06:04:39 <hjulle> Argh, my "enter"-key is to close to "'" :P
06:10:10 <rahul> lambdabot sometimes yields code with if' function. in what module does this function reside?
06:10:31 <hpc> @hoogle if'
06:10:32 <lambdabot> No results found
06:10:39 <hpc> rahul: a lambdabot exclusive!
06:10:49 <rvn_> rahul, http://www.haskell.org/haskellwiki/If-then-else
06:10:49 <hpc> (if' x y z) = if x then y else z
06:11:20 <rahul> Yes, very easy to define, but it'd've been better if Prelude provided it :-(
06:15:08 <hpc> another less popular function to use is (x ?? y) p = if p then x else y
06:15:38 <rahul> I have just started using EclipseFP. Every time I use an expression like [1 .. n] it issues a warning saying that it is "defaulting the constraint to Integer". It's annoying. How do I make this warning go away?
06:15:44 <Ke> why not also at least remove map while you are at it =oP
06:15:48 <ion> @type (??)
06:15:49 <lambdabot> Not in scope: `??'
06:15:50 <rahul> @hoogle (??)
06:15:51 <lambdabot> No results found
06:16:19 <hpc> rahul: give the list a type signature; type defaulting is an annoying thing
06:16:50 <hpc> or give the function around it a signature; not sure how eclipsefp works
06:17:12 <hpc> (??) :: a -> a -> Bool -> a
06:17:28 <ion> Yeah, the type of (??) is obvious, i just wanted to see if it’s defined in lambdabot.
06:17:39 <rahul> hpc: ok
06:23:36 <mm_freak> the OpenGL library should make more use of other libraries
06:23:40 <mm_freak> like vector-space
06:35:00 <shirt> i can't figure out how to pass flags to cabal
06:35:27 <applicative> -fblah
06:35:42 <applicative> shirt, do you mean flags specified in the .cabal file?
06:36:01 <shirt> yeah. i'm trying: cabal install -fnative aeson --dry-run
06:36:18 <shirt> hoping that -fnative will be passed to the blaze-textual dependency, but it's not
06:37:24 <alpounet> shirt, you should install blaze-textual separately, thus passing it the options you want
06:37:31 <moriramar> Excuse me, does "module modid where" clause require indentation of the body?
06:37:45 <ion> no
06:38:04 <applicative> oh, yeah, otherwise there's be a wreck with all the things with -ftesting and so on
06:38:09 <shirt> alpounet: i can't install blaze-textual separately, because of the version constraints, aeson wants to reinstall it anyway
06:38:21 <applicative> morimar, no, you can if you like though no one does
06:38:55 <alpounet> shirt, do you have another package depending on a separate version of blaze-textual ?
06:38:59 <alpounet> otherwise you can just reinstall it
06:39:07 <alpounet> or, better, use cabal-dev for your project :p
06:39:48 <moriramar> ion, thanks.
06:43:29 <applicative> shirt, the most up to date hackage aeson can use the most up to date hackage blaze-textual
06:44:29 <luite> shirt: there's a fork of those packages that automatically build with the native flag, aeson-native
06:44:29 <shirt> applicative: yeah, but aeson needs an old version of deepseq, and this seems to cause a cascade of dependency hell
06:44:43 <shirt> luite: hm...
06:45:45 <luite> shirt: it's annoying because you can have incompatible dependencies, but yesod depends on the -native versions because of the incompatibilities with the faster c++ version
06:46:36 <applicative> i was just noticing http://hackage.haskell.org/package/blaze-textual-native
06:46:40 <rvn_> @hoogle spawn
06:46:41 <lambdabot> No results found
06:46:42 <shirt> luite: would be really nice if the underlying ghc bugs would be fixed so that -native would no longer be needed
06:47:27 <alpounet> shirt, use cabal-dev to avoid the dependency hell
06:47:28 <luite> shirt: yeah, that's the ultimate goal, but I personally think that the default build option should be the most compatible one
06:47:36 <luite> so -fnative
06:47:40 <alpounet> probably the simpler solution
06:47:42 <rvn_> @t forkIO
06:47:42 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:47:53 <luite> alpounet: that doesn't solve this problem though
06:48:09 <rvn_> @type forkIO
06:48:09 <lambdabot> Not in scope: `forkIO'
06:48:20 <rvn_> @hoogle forkIO
06:48:20 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
06:48:27 <alpounet> well, there probably won't be any problem anymore with the multiple versions of blaze-textual
06:49:40 <shirt> alpounet: thanks i'll look into it
06:50:10 <shirt> luite: i agree
06:50:42 <applicative> rvn_: you mean this spawn?  spawn :: NFData a => Par a -> Par (IVar a)
06:54:59 <shirt> argh, aeson-native has a compile error and doesn't build
07:00:28 <applicative> shirt, hm, just installed 'cabal install aeson-native' without trouble, it carried blaze-textual-native with it.
07:01:42 <rostayob> are type parameters scoped in the body of the function? i vaguely remember that they weren't
07:02:21 <ClaudiusMaximus> no, but you can enable ScopedTypeVariables or use `asTypeOf` etc
07:03:13 <rostayob> ClaudiusMaximus: it doesn't seem to work with ScopedTypeVariable - referring to type parameters in the function type signature
07:03:31 <ion> Please paste your code.
07:03:46 <ClaudiusMaximus> ah, ScopedTypeVariables only extends the scope if you use explicit forall
07:04:16 <rostayob> ClaudiusMaximus: you're right, thanks
07:04:22 <ClaudiusMaximus> or something along those lines, probably to avoid confusing errors if you enable the extension for code that doesn't expect it
07:04:24 <rostayob> why is that?
07:04:30 <rostayob> yeah it works with the forall
07:05:30 <hpc> doesn't that extension make forall required?
07:05:44 <copumpkin> required only if you want the scoping
07:05:45 <lambdabot> copumpkin: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:06:02 <hpc> ah, could have sworn there was an extension that made it mandatory
07:07:54 <mm_freak> hpc: that extension would conflict with ScopedTypeVariables
07:42:40 <antihoax> hi :)
07:46:03 <Rc43> Hi, guys.
07:47:42 <Rc43> I am reading about continuations on wiki. There is example with sandwich (http://en.wikipedia.org/wiki/Continuation#First-class_continuations).  What is special here for continuations? It seems that simple function call is described.
07:50:23 <Saizan> Rc43: the special part is that you've kind of forgotten that you've made the sandwich yourself
07:50:37 <Saizan> Rc43: but i'm not sure this is a great analogy
07:52:03 <Rc43> Saizan, in programming context I can't get analogy with forgetting of cooking. Seems like just procedure.
07:54:01 <Saizan> Rc43: yeah, it doesn't show much of the possible uses of a continuation once you "have it in your pocket", e.g. you could call it multiple times
07:56:26 <Rc43> Ah, it seems I have understood. When I call procedure I give it arguments, when I remembered this call I can use procedure multiple time without remembering of arguments I have used to call it first time. Right?
07:57:30 <Saizan> that's not the point
07:58:03 <Saizan> the point is that you've reified "the rest of the program" as a procedure which you can then call as you please
07:58:34 <Saizan> after the reification it does look like any other procedure
07:58:51 <Rc43> It is just jump to the past?
07:59:02 <Saizan> no
08:01:43 <Saizan> Rc43: normally if you have a program like "f(); g();" f is not informed of the fact that g() will come after it, but with first-class continuations the body of f can obtain whatever will come after it as a continuation
08:03:43 <Peaker> I don't get the IVar business and the Par monad -- seems to be a step back from nice pure compositions back into imperative land with no static guarantees...
08:03:59 <Saizan> Rc43: e.g. in haskell with ContT you could say "main = flip runContT return $ do x <- callCC (\k -> do k 1; k 2); liftIO $ print x" and that would print both 1 and 2, so you see that k refers to what comes after the callCC
08:04:54 <Saizan> Peaker: they are still write-once
08:04:58 <Rc43> Saizan, i will try it now
08:05:17 <Saizan> ?type runContT
08:05:18 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
08:05:20 <Peaker> Saizan: yeah, but it's a dynamic write once -- so you lose static guarantees, what if there are two writes?
08:06:13 <Saizan> Peaker: you lose some, but it's still a long way from that to mutation
08:07:03 <Peaker> yeah, it's not all the way back to imperative land, but it's halfway there.. What's the benefit of losing these static guarantees?
08:08:22 <Saizan> i've not used it myself, but i'd guess easyness of reasoning about when things get evaluated
08:08:41 <Rc43> I haven't installed Control.Monad.Cont =/
08:08:54 <Saizan> cabal install mtl
08:09:34 <Saizan> Peaker: Simon Marlow seems to have quite a bit written about haskell parallelism on its research page, maybe you'll find an answer there
08:09:37 <Saizan> *his
08:09:42 <parcs> use Control.Monad.Trans.Cont
08:10:10 <Peaker> Saizan: Ah, I was hoping someone could explain it shortly, so I don't have to do the research :-)
08:10:13 <antihoax> just wondering if it would be possible to program fpgas with ghc
08:10:29 <KirinDave> Simon's docs of the current state of ghc parallelism are like a manual that also teaches fundamentals of modern parallelism.
08:10:40 <KirinDave> It's an amazing and depressing documnt.
08:11:10 <sshc> #haskell, I'm going to be alone for the next few hours with nothing but paper and pencils.  How do you suggest I be productive with this time in a way that pertains to Haskell?
08:11:36 <antihoax> can someone enlighten a bit ? how is variable changing implemented in ghc ?
08:11:36 <shirt> KirinDave: where is this article?
08:11:48 <antihoax> you know, user interaction
08:12:20 <KirinDave> shirt, http://community.haskell.org/~simonmar/par-tutorial.pdf
08:12:25 <Peaker> antihoax: what do you mean by "variable changing"?  IORefs?
08:12:53 <ion> ~simonpar/mar-tutorial
08:13:12 <parcs> sshc: print out a long paper, read it
08:13:25 <KirinDave> sshc: Print out THAT paper and read it, if you haven't already.
08:13:33 <antihoax> i mean i have a circle with xy coordinates for example, draw it out, and interpret up down left right keys accordingly to move the circle center in the coordinate system, then redraw
08:14:11 <antihoax> i'd need some variable i think
08:14:15 <KirinDave> It's crazy. I work with java.util.concurrency all day long.
08:14:38 <KirinDave> and even comparing it to clojure and scala's concurrency stuff (even giving Scala the Akka library), Haskell still feels 10 years ahead.
08:15:04 <Noob> hey ... I'm looking to write a function in Haskell that takes in a string which contains two expressions (expr1, expr2) and want to be able to read the expressions
08:15:08 <KirinDave> I do not understand how the java concurrency stuff can be so insanely conservative.
08:16:09 <sshc> parcs, KirinDave: Excellent.  Thanks
08:17:23 <KirinDave> sshc: Enyoy.
08:22:48 <tsousa> where can i see the code of some standard librarys?
08:23:11 <Cale> tsousa: The Haddock documentation has little source links on the right
08:23:14 <hpaste_> Non pasted “New” at http://hpaste.org/52043
08:24:12 <hjulle> tsousa: Try searching for them on Hoogle and click the source links as Cale said
08:24:15 <antihoax> nobody makes interactive programs in ghc?
08:24:26 <Peaker> antihoax: there are various ways to implement that
08:24:29 <Cale> antihoax: ?
08:24:35 <Silvah> antihoax: nobody makes no programs in GHC.
08:24:51 <Cale> antihoax: What do you mean by that?
08:24:58 <Peaker> antihoax: one of the easiest for a beginner, is to have your main loop be recursive -- and just recurse with a new x,y coordinate
08:25:06 <Peaker> <antihoax> i mean i have a circle with xy coordinates for example, draw it out, and interpret up down left right keys accordingly to move the circle center in the coordinate system, then redraw
08:25:18 <Cale> okay
08:25:23 <antihoax> Peaker<< wont i have stack overflow after some tome?
08:25:32 <antihoax> time
08:25:32 <Cale> antihoax: What's a stack? :)
08:25:38 <Peaker> antihoax: nope
08:25:54 <antihoax> if i do something recursively then it will eat away all my memory no?
08:25:59 <Cale> antihoax: The GHC evaluator happens to have a stack in it, but this stack isn't a call stack.
08:26:31 <Cale> antihoax: (it's a pattern matching stack, used to hold case expressions who are waiting for their scrutinee to be evaluated enough that they can pattern match)
08:26:36 <Cale> There is no call stack.
08:27:17 <parcs> "Care should be taken when calling forkOS: it creates a complete new OS thread, so it can be quite expensive."
08:27:29 <Peaker> antihoax: memory use of something like:   game pos = do { newPos <- gameIteration ; game newPos }     will use constant memory
08:27:52 <Peaker> parcs: I thought forkOS may re-use an existing OS thread, and not necessarily create a new one
08:27:53 <parcs> i remember this channel telling me that forkOS does NOT create a new OS thread... you liars
08:27:54 <antihoax> ok thanks
08:30:04 <Cale> antihoax: Basically, if you're used to programming in some other language, throw out all your intuition about how programs written a certain way will perform time/space wise, because Haskell is quite literally backwards with respect to the order in which it evaluates stuff :)
08:30:21 <antihoax> ASM pascal C
08:30:29 <Cale> It requires different intuition :)
08:30:34 <antihoax> C++ bash javascript
08:30:45 <antihoax> AVR ASM
08:30:52 <incluye> Cale: backwards?
08:30:58 <Cale> incluye: Yes :)
08:31:00 <antihoax> PHP
08:31:10 <Cale> Expressions in Haskell are evaluated outermost-first
08:31:22 <incluye> oh, right
08:31:33 <Cale> So if you have, say,  f (g (h x)), this evaluates f first, passing the expression g (h x) as the parameter
08:32:16 <antihoax> Cale<< i have no problem with logic functions
08:32:27 <Cale> While in strict languages, you'd evaluate h x first.
08:32:43 <Silvah> Cale: what if one is used to programming in another functional language with lazy eval? Should she then throw out all her intuition about how programs written a certain way will perform time/space wise, too? :P
08:32:52 <parcs> Peaker: no, it says that forkOS was created to handle FFI calls to libraries with (OS-)thread-local storage.
08:32:53 <Cale> Silvah: No, but there aren't many of those.
08:33:48 <Saizan> parcs: but that only imples that the haskell thread will always be executed in the same OS thread, i don't think it also implies no other haskell thread can run in that OS thread
08:33:49 <Cale> Silvah: If you are already familiar with another nonstrict functional programming language, then you probably know what you're doing enough to know that what I have to say there doesn't apply to you :)
08:34:01 <Peaker> parcs: yeah -- so as long as it consistently maps to the same OS thread, it's legal
08:34:07 <Peaker> parcs: many-to-one is allowed, just not one-to-many
08:34:23 <Peaker> parcs: (all forkOS's can return the same OS thread, if they wish)
08:35:25 <Peaker> though it would be nice to have a way to actually create an OS thread -- in case you have some ugly blocking FFI's and you don't want them to unnecessarily block other threads
08:36:01 <ion> Any ideas for a name for a function of type (a -> a) -> a you apply to your function which wants a ⊥ of the same type as its return value as a parameter? Implemented as foo f = fix (f . (error "foo value was evaluated" `asTypeOf`))
08:41:32 <monochrom> forkOS solves both blocking FFI and thread-local at once.
08:42:08 <Peaker> monochrom: if it chooses to run more things in that OS thread, it may unnecessarily wait?
08:42:41 <monochrom> as far as the latest paper on forkOS, it does not
08:43:54 <Cale> antihoax: I'll make you a little example game in Gloss :)
08:45:18 <monochrom> the correct incantation is "import foreign safe" and forkOS and link with "-threaded". when one OS thread is FFIing, another OS thread runs other green threads. so far this doesn't need forkOS actually; forkIO will do. forkOS further buys you thread-local
08:46:13 <monochrom> the paper is only outdated in the "only one capability" regard. we now have multiple capabilities (RTS -N flag)
08:47:19 <shirt> monochrom: so if i use forkIO to call a blocking C function like sleep(1000), and run 100 of those in parallel, then 100 the runtime will make sure to spawn 100 OS threads?
08:48:06 <monochrom> "one capability" means all green threads, if not in FFI mode, are time-multiplexed on one OS thread
08:48:14 <Saizan> i guess the key is that the runtime will never attach two haskell threads to the same OS thread when you use forkOS twice, so that one doesn't have to wait for the other to use the SO thread
08:48:27 <antihoax> Cale<< thanks :) dont bother, i'll find examples, havent read all sotes yet
08:48:36 <hjulle> ion: When would you need such a function? (just curious)
08:48:36 <antihoax> *sites
08:48:48 <monochrom> yes, 100 blocking safe FFI calls is 100 OS threads, plus 1 thread for whatever other Haskell code is still running
08:49:07 <Peaker> Saizan: doesn't that imply that forkOS will always yield a new OS thread?
08:49:22 <antihoax> im still here in studying http://learnyouahaskell.com/starting-out#ready-set-go
08:49:23 <shirt> monochrom: and then as each thread completes, it's OS thread will be terminated?
08:49:31 <Saizan> Peaker: not always :)
08:49:41 <monochrom> I forgot. likely.
08:49:54 <monochrom> Peaker, see the paper for real
08:50:12 <monochrom> I'm looking for its url
08:50:34 <ion> hjulle: As an alternative to ScopedTypeVariables: at the end https://gist.github.com/1188115
08:51:06 <antihoax> Cale<< btw im willing to make a vectorgraphic cad software in ghc using primitives
08:51:16 <antihoax> this is why i need user interaction
08:52:15 <monochrom> http://community.haskell.org/~simonmar/papers/conc-ffi.pdf
08:52:31 <ion> hjulle: With ScopedTypeVariables the equivalent could be written like: floatMinNorm :: forall a. RealFloat a => a; floatMinNorm = let a :: a; a = undefined; … = floatRange a; …
08:53:39 <erus`> is there any disadvantage to using the type system as much as possible
08:53:45 <erus`> speed hit or something?
08:53:59 <ion> As opposed to what?
08:54:33 <erus`> well sometimes you can encode stuff in strings or whatever
08:54:52 <erus`> which may mean less code to write but lacks the type safety of using custom types
08:55:00 <ion> *That* sounds like something that comes with a speed hit.
08:55:03 <KirinDave> erus`, well there is a performance benefit at runtime. As opposed to encoding things in streams, which is a performance penalty at runtme.
08:55:42 <KirinDave> erus`, I have heard stories of very complicated code being slow to compile, but I have been told such code usually exercises bugs in the compiler as opposed to fundamental limitations.
08:56:43 <stianhj> I have logNumber n = Writer (n, ["Got number " ++ show n]), and in a do block a <- logNumber 3; b <- logNumber 4; return (a*b) .. I don't get the multiplication in the return?
08:57:38 <ion> @type \n -> Writer (n, ["foo"])
08:57:39 <lambdabot> Not in scope: data constructor `Writer'
08:57:48 <monochrom> as it happens, every forkOS implies a new OS thread actually. how that OS thread is used is tricky, though
08:57:48 <ion> @type \n -> Control.Monad.Writer.Writer (n, ["foo"])
08:57:48 <lambdabot>     Not in scope: data constructor `Control.Monad.Writer.Writer'
08:58:09 <yitz> @hoogle Writer
08:58:09 <lambdabot> module Control.Monad.Writer
08:58:09 <lambdabot> Control.Monad.Writer.Lazy newtype Writer w a
08:58:09 <lambdabot> Control.Monad.Writer.Lazy Writer :: (a, w) -> Writer w a
08:58:13 <hpaste_> Cale pasted “CIRCAL GAEM (lol)” at http://hpaste.org/52044
08:58:18 <ion> @type \n -> Control.Monad.Writer.Lazy.Writer (n, ["foo"])
08:58:19 <lambdabot>     Not in scope: data constructor `Control.Monad.Writer.Lazy.Writer'
08:58:22 <ion> meh
08:58:23 <Cale> antihoax: ^^ :)
08:58:38 <stianhj> :P
08:58:57 <stianhj> newtype Writer w a = Writer { runWriter :: (a, w) }
08:58:59 <ion> @type \n -> writer (n, ["foo"])
08:59:00 <lambdabot> forall a. a -> Writer [[Char]] a
08:59:02 <stianhj> something like that
08:59:05 <ion> @type tell ["foo"]
08:59:06 <lambdabot> forall (m :: * -> *). (MonadWriter [[Char]] m) => m ()
08:59:11 <Cale> antihoax: It's not much of a "game" as such, but it gives you some idea of one way to structure things.
08:59:38 <ion> @type \n -> n <$ tell ["foo"]
08:59:39 <lambdabot> forall a (f :: * -> *). (MonadWriter [[Char]] f, Functor f) => a -> f a
08:59:42 <hjulle> ion: [fix_] How about fixNoEval or something like that?
08:59:51 <antihoax> okey i can use some bootstrap for syntax :)
09:00:16 <monochrom> suppose you forkOS (long_haskell_thing >>= long_FFI_thing) and it creates OS thread T. the haskell part may run in any OS thread; the FFI part must run in T. yes there is much thread switching if necessary.
09:00:24 <ion> hjulle: Thanks, but that’s a bit verbose and also i probably should get rid of the word “fix” as it’s not a fixed-point combinator anymore.
09:00:42 <hjulle> true
09:00:51 <Cale> antihoax: If you cabal install gloss, that should get a window up on the screen with a circle in it that you can accelerate using the arrow keys.
09:01:11 <antihoax> im on it
09:01:36 <antihoax> though my / is full right now, so i have to prefix to another place
09:01:39 <Cale> Gloss unfortunately doesn't work for me in GHCi, so I have to ghc --make instead.
09:02:17 <antihoax> but hopefully i can make it work
09:02:23 <yitz> Cale: http://dac4.designacourse.com:8000/game
09:02:49 <stianhj> ion: not quite sure what to do with that
09:04:38 <jonrafkind> is it still the case that in template haskell you must prefix template functions with $?
09:04:58 <yitz> stianhj: what do you mean that you don't get the multiplication in the return?
09:05:02 <ion> If you call them in the top level of a module, you don’t.
09:05:28 <jonrafkind> ion, so you mean if you call a template inside a function you need $?
09:05:40 <Cale> jonrafkind: Yeah, I think so...
09:05:41 <ion> jonrafkind: AFAIU yes.
09:06:00 <jonrafkind> ok, any idea how haskell manages to figure things out at the top level?
09:06:03 <ion> stianhj: Just a slightly higher-level way to write the same thing.
09:06:13 <Cale> jonrafkind: Expressions can't occur at the top level otherwise
09:06:20 <Cale> So it's syntactically unambiguous.
09:06:23 <jonrafkind> oh ok
09:06:50 <yitz> @type (<$)
09:06:51 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
09:06:55 <ion> > let f a = writer (a, ["got " ++ show a]); g a = a <$ tell ["got " ++ show a] in runWriter ((+) <$> f 42 <*> g 42)
09:06:57 <lambdabot>   (84,["got 42","got 42"])
09:06:58 <cheater> http://cheater.posterous.com/haskell-curses
09:06:58 <stianhj> yitz, the result of do { a <- logNumber 3; b <- logNumber 4; return (a*b) } is (12, ["Got number 3", "Got number 4"])
09:07:06 <cheater> tutorial on using haskell with curses style libs
09:07:15 <yitz> stianhj: that looks perfect
09:07:41 <yitz> stianhj: actually, that's the result of runWriter on the do block
09:07:42 <stianhj> but i don't get where the `mappend` of the strings happens, in the return (a*b).. what are the types of a and b..
09:07:54 <stianhj> yes, with runWriter
09:07:57 <MatrixFrog> "Good for things where curses is not available" me: oh good so it'll work on windows!
09:08:04 <MatrixFrog> "does not work on Windows."
09:08:09 <MatrixFrog> me: d'oh!
09:08:29 <monochrom> it seems "Got number 3" is caused by logNumber 3
09:08:35 <ion> @type runWriter (do a <- return 3; b <- return 4; return (a*b))
09:08:36 <lambdabot> forall w a. (Num a, Monoid w) => (a, w)
09:08:44 <ion> Their type is Num a => a
09:08:48 <monochrom> a,b are probably Integer's
09:09:01 <yitz> stianhj: a and b are some numeric type. both must be the same type. the two messages are mappend'ed in the type [String]
09:09:16 <monochrom> the type of logNumber 3 is the interesting part
09:09:42 <stianhj> it has type Writer [String] Integer
09:10:06 <monochrom> yes. it is an awesome type
09:10:08 <stianhj> and a in a <- logNumber 3 is a touple of (3, ["Got number 3"])
09:10:15 <stianhj> ?
09:10:18 <monochrom> no, a stays Integer
09:10:22 <stianhj> oh
09:10:53 <monochrom> if you have "x <- m" and m has type Blah Blah Blah Integer, then x has type Integer. no exception.
09:11:11 <stianhj> ok
09:11:50 <MatrixFrog> is there a standard name or pronunciation for the <*> operator
09:11:58 <MatrixFrog> (reading about Applicative in lyah)
09:11:59 <Cale> MatrixFrog: "ap"
09:12:26 <monochrom> <*> is Kuso Katamoto
09:12:26 <Cale> (given that it's analogous to ap for monads)
09:12:43 <MatrixFrog> cool, and that's short for "apply" i suppose?
09:13:10 <Cale> yeah
09:13:19 <ion> They’re APplicative functors. :-)
09:14:09 <MatrixFrog> of course
09:14:15 <Cale> http://www.google.ca/search?q=%22Kuso+Katamoto%22
09:14:18 <Cale> ^^ lol
09:14:25 <yitz> monochrom: it has type Integer even when there is an exception. x <- error "Bang!" :: IO Integer -- :)
09:14:33 <stianhj> monochrom, but what happens to the Got number 3 from logNumber 3 when you a <- logNumber 3 if a is an Integer?
09:14:43 <ion> yitz: Yes
09:14:54 <monochrom> hidden and passed around underground
09:15:08 <ion> @type let a :: Integer; a = error "blah" in a
09:15:09 <lambdabot> Integer
09:15:11 <Cale> stianhj: It is collected along with the rest of the written strings and shows up in the final output when you runWriter
09:15:13 <monochrom> do you know that the do-notation is translated to the >>= operator?
09:15:33 <monochrom> the >>= operator keeps and passes on the "Got number 3" part
09:15:35 <stianhj> monochrom, i was just thinking about that
09:16:08 <monochrom> of course, someone else did the hard work of coding up >>= to do that. it is not supposed to be trivial
09:16:29 <stianhj> let me write it out with >>=
09:16:44 <yitz> monochrom: so then <$ is called Jacquelin von, I suppose.
09:16:55 <KirinDave> This is an interesting game.
09:17:12 <monochrom> oh, you find my short list of standard names afterall :)
09:17:14 <KirinDave> So I realized I had been pronouncng "::" as "has type of"
09:17:20 <KirinDave> is that the right way to say it?
09:17:46 <monochrom> even better, google finds it :)
09:17:49 <yitz> monochrom: Cale googled it
09:18:21 <monochrom> people are going to complain to me that my Kuso names are more googlable than my cabal scaremongering article!
09:19:53 <monochrom> hrm, when did code.google.com start logging irc?
09:21:04 <MatrixFrog> google is spying on us RIGHT NOW!
09:22:09 <yitz> KirinDave: you can also pronounce it "paamayim nekudotayim"
09:22:43 <KirinDave> yitz, sometimes I just say, "Mah Johnson" in a deep, guttural grunt.
09:22:49 <yitz> KirinDave: but then people might suspect you of being a php programmer
09:23:27 <shirt> why hasn't there been a new release of haddock in over a year?
09:23:40 <yitz> KirinDave: oh, Mah Johnson, very nice. i think you recommand that to monochrom
09:24:23 <yitz> shirt: because it still seems to work, and no one has worked on improving it?
09:24:32 <monochrom> I think people already call it colon colon
09:25:33 <shirt> yitz: so the project is not dead?
09:25:56 <yitz> shirt: oh no it's a deeply built-in part of the haskell ecosystem
09:26:01 <ion> :♋ colon cancer
09:26:01 <aristid> monochrom: i don't. i call it Doppelpunkt Doppelpunkt
09:26:37 <yitz> aristid: why not Doppledopplepunkt?
09:26:38 <monochrom> double (double point) is going to be Cale's next example of lazy evaluation :)
09:26:50 <aristid> yitz: because that's harder to say
09:27:27 <yitz> aristid: i don't believe that (even though i myself can't pronounce either one)
09:28:18 <aristid> yitz: they're not hard to pronounce :)
09:29:07 <yitz> aristid: am i allowed to merge the final t in the first word with the initial D in the second word?
09:29:08 * monochrom wonders if Deustche Neuspracchen is Doppelplusgute
09:29:14 <aristid> yitz: google translate can pronounce it for you
09:29:40 <aristid> yitz: only if you speak it with high speed
09:29:54 <aristid> why doesn't google translate allow linking to it? dammit
09:30:05 <monochrom> Doppelpunkt is double punk!
09:30:06 * hackagebot lhs2TeX-hl 0.1.4.0 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.4.0 (AlessandroVermeulen)
09:30:17 <aristid> monochrom: lol
09:30:44 <yitz> aristid: http://www.forvo.com/word/paamayim_nekudotayim/
09:31:07 <monochrom> "we put the punk back into punktful programming"
09:31:13 <aristid> yitz: click on the microphone symbol: http://translate.google.com/#de|de|Doppelpunkt
09:31:48 <yitz> aristid: http://www.forvo.com/search/doppelpunkt/
09:35:11 <engla> haskell should have more german terminology
09:35:22 <engla> instead of Monad, Einheit
09:35:40 <brisingr> Funktor
09:36:22 <engla> Morphismus
09:36:28 * ion is tempted to godwin the discussion
09:36:36 <engla> instead of arrow?
09:36:48 <engla> dunno, maybe it would be pretty latinized anyway
09:36:58 <monochrom> ApplikativFunktorMonadPlusPlus
09:37:11 <applicative> class Kategorie
09:37:21 <monochrom> (surely all your camelcasing is already German enough)
09:37:27 <ion> klasse
09:37:29 <Johannes2> Given Haskell's laziness, if I try to evaluate 0 * someFunction, will someFunction be evaluated as well?
09:37:44 <Johannes2> And mutatis mutandis for someFunction * 0?
09:37:47 <ion> > 0 * undefined
09:37:48 <lambdabot>   *Exception: Prelude.undefined
09:37:52 <Johannes2> Hum
09:37:54 <MatrixFrog> Johannes2: you can find out by asking ghci to do 0*undefined
09:37:56 <monochrom> unfortunately * still evaluates both. at least for Integer's *
09:38:01 <Johannes2> How sad
09:38:04 <applicative> Johannes2: * is strict
09:38:05 <Johannes2> Thank you.
09:38:22 <monochrom> but if you define your own Num, you can make it lazy
09:38:25 <MatrixFrog> i often think haskell should have "lazy numbers" though what exactly that means is quite vague in my mind
09:38:34 <engla> or even define your own version of *
09:39:22 <monochrom> you won't easily have both 0*x being lazy in x and y*0 being lazy in y in GHC
09:39:23 <engla> > let { (*.) 0 y = 0; (*.) x y = x*y } in 0*undefined
09:39:24 <lambdabot>   *Exception: Prelude.undefined
09:39:31 <engla> > let { (*.) 0 y = 0; (*.) x y = x*y } in 0*.undefined
09:39:32 <lambdabot>   0
09:39:35 <applicative> you can certainly make instances of Num that are lazy all over the place.
09:40:04 <applicative> there is that Stream library, with the name of Hinze in it somewhere, with a spectacular Num instance...
09:40:28 <MatrixFrog> http://hackage.haskell.org/package/hinze-streams must be it
09:41:48 <Johannes2> Wow! What an esoteric description!
09:42:07 <applicative> ah yes, that's it MatrixFrog
09:43:12 <applicative> I don't think that instance of (*) is too strict :)
09:44:31 <ion> > let a *! b = assuming (a == 0) 0 `unamb` (assuming (b == 0) 0 `unamb` a*b) in length [0..] *! 0
09:44:32 <lambdabot>   Not in scope: `assuming'Not in scope: `assuming'Not in scope: `unamb'Not in...
09:46:23 <ion> let a *. b = unambs [assuming (a == 0) 0, assuming (b == 0) 0, a * b] in length [0..] *. 0
09:47:49 <yitz> there have been several implementations of lazy natural numbers floating around for years, e.g. the one by John Meacham.
09:52:07 <ion> let (*.) = parAnnihilator (*) 0 in length [0..] *. 0
09:52:14 <ion> parAnnihilator does exactly that.
09:53:23 <Blkt> good evening everyone
09:53:36 <ion> Reading through Unamb, there are constantly better and better ways to do that. :-P
09:53:48 <ion> length [0..] `pmult` 0
09:53:51 <applicative> good evening Blkt
09:53:57 <Blkt> hi there
09:53:59 <ion> pmult also handles the case of one of the terms being 1.
10:05:27 <shirt> can i use haddock to document each argument of a record field that is a function?
10:18:48 <rostayob> shirt: what? you can document single arguments in functions and single record fields if that's what you're asking
10:18:56 <rostayob> but i'm not sure that's what you're asking :P
10:23:38 <CDS> Hi all, I am working on a program that does substitution. I have a function subst:: Subst -> Expr -> Expr. My Subst type is defined as  [(String, Expr)] and my Expr type is Num Integer | Var String.  If I use the lookup function, how would i then proceed to actually do the substitution (change the value)?
10:24:50 <Cale> CDS: by pattern matching, probably...
10:25:25 <Cale> subst dict (Var name) = lookup name dict
10:26:08 <Cale> subst dict x = x -- normally there would be some recursive cases before this, but your Expr type is simple
10:26:12 <ezyang> CDs: You need to invoke the constructor to rebuild the data type.
10:26:32 <ezyang> f (Just x) = Just (x + 1)
10:27:16 <Cale> He actually doesn't because his substitutions already contain expressions to be used :)
10:27:51 <ezyang> Oh yeah, there is no recursive case for Exp. Heh.
10:29:07 <CDS> not yet at least, i'm supposed to make it also have Add Expr Expr | Mul Expr Expr
10:29:24 <Cale> yeah, you'd also have:
10:29:25 <CDS> just trying to get the basics working
10:29:43 <Cale> subst dict (Add e1 e2) = Add (subst dict e1) (subst dict e2)
10:30:22 <CDS> hmm never used the dict before
10:32:11 <Cale> Well, you use the dict in the variable case when you make the substitution
10:32:23 <Cale> otherwise you just pass it along
10:36:48 <CDS> Ok, but how do I look it up in the expr
10:37:16 <CDS> if i have subst (v, f) e. I want to find all the "v" in e and change them to f
10:37:39 <ezyang> That's hwo you do it. You recursively walk through e looking for e.
10:38:20 <CDS> but I want to find v.
10:38:45 <missingfaktor> i am working thru the book haskell school of expression and i need a little help in installing the library SOEGraphics
10:38:58 <ezyang> erm *v
10:38:59 <missingfaktor> cabal install SEOGraphics doesnt work :(
10:39:10 <ezyang> missingfaktor: What is the error message?
10:39:49 <missingfaktor> ezyang: cabal: There is no package named 'SOEGraphics'. You may need to run 'cabal update' to get the latest list of available packages.
10:40:09 <ezyang> is it SOE or SEO?
10:40:13 <ezyang> Did you run 'cabal update'?
10:40:24 <dafis> School Of Expression
10:40:27 <missingfaktor> ezyang: SOE
10:40:47 <missingfaktor> ezyang: I ran it once before IIRC. Didn't run it again.
10:40:50 <ezyang> Are you sure that's the right name?
10:40:58 <ezyang> I don't see soegraphics, but I do see soegtk
10:41:12 <missingfaktor> ezyang: How do I find out what
10:41:19 <missingfaktor> ezyang: is the right name?
10:41:33 <ezyang> Well, I assume the book you're reading has instructions on how to install its library...
10:41:40 <ezyang> Anyway, I think you want 'cabal install soegtk'
10:41:48 <missingfaktor> ezyang: Let me check
10:42:03 <MatrixFrog1> http://hackage.haskell.org/packages/archive/pkg-list.html has all the packages on one page so you can just ctrl-F for "soe" or "seo"
10:42:25 <MatrixFrog1> and if you do that, you'll come to the conclusion of what ezyang just said :)
10:42:44 <missingfaktor> ezyang, MatrixFrog1: Yes, that was it. Thanks a lot guys. :-)
10:43:28 <dafis> missingfaktor: you need to install gtk2hs-buildtools (I think that's the name) first, the gtk* packages need them to build
10:44:25 <missingfaktor> dafis: Yeah, cabal did say that. Thanks!
10:44:33 <TotoTitus> good evening
10:54:55 <donri> i like colours. yay colours! is there some package to colourize ghc errors / ghci stuff like :t / maybe even live syntax highlighting in ghci?
10:54:58 <MatrixFrog> are there quickcheck properties for the "laws" the compiler can't check?
10:55:15 <ezyang> MatrixFrog: What lows?
10:55:25 <ezyang> *laws
10:55:27 <hpc> the ones for functor, etc?
10:55:41 <MatrixFrog> i'm not sure what those would look like, but i think you could definitely use quickcheck to verify that mempty `mappend` x = x is true for all x
10:55:46 <MatrixFrog> for a given monoid instance
10:55:55 <Saizan> donri: you could pipe it through hscolour
10:56:01 <MatrixFrog> hpc, yeah, functor, applicative, monoid...
10:56:21 <hpc> MatrixFrog: there isn't anything, and i doubt there will be
10:56:31 <hpc> the best you could do anyway is say "i can't find a counterexample"
10:56:48 <MatrixFrog> isn't that always true of quickcheck though?
10:56:58 <Nioate> quickcheck is just for doing fuzzing, correct? if I want specific test cases, I still have to use something like hunit
10:57:22 <donri> but certainly QC is *all about* testing laws like that?
10:57:32 <hpc> in some cases you can use quickcheck to enumerate all inputs and check their outputs
10:57:38 <MatrixFrog> it's better than nothing, and using hunit + quickcheck is better than explicit hunit tests alone
10:57:46 <hpc> @check \x -> x == ()
10:57:46 <donri> http://hackage.haskell.org/package/checkers ?
10:57:46 <lambdabot>   "OK, passed 500 tests."
10:59:45 <donri> MatrixFrog: ^
10:59:56 <MatrixFrog> cool :)
10:59:57 <danr> hpc: nice ^^
11:00:35 <donri> @check \x -> length x < 100
11:00:35 <lambdabot>   "Falsifiable, after 241 tests:\n[(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
11:00:38 <aristid> @check \x -> x < 1000
11:00:39 <lambdabot>   "OK, passed 500 tests."
11:00:42 <aristid> @check \x -> x < 1000
11:00:43 <lambdabot>   "OK, passed 500 tests."
11:00:45 <aristid> :D
11:01:09 <morolin> Does anyone know if alex and parsec play nicely together?  And if they do, is there documentation of them playing nicely?  The parsec pdf doesn't mention alex, and I couldn't find anything in about 15 minutes of googling.
11:01:25 <danr> aristid: :D
11:01:46 <aristid> it proves that all numbers are below 1000, i think
11:01:55 <ezyang> lolwut
11:01:56 <MatrixFrog> @check (== 0)
11:01:57 <lambdabot>   "Falsifiable, after 1 tests:\n1\n"
11:02:06 <MatrixFrog> @check (\x -> x == 0)
11:02:07 <lambdabot>   "Falsifiable, after 0 tests:\n2\n"
11:02:23 <aristid> @check \x -> x < 10
11:02:24 <lambdabot>   "Falsifiable, after 18 tests:\n11\n"
11:02:24 <MatrixFrog> @check \x -> x == 0
11:02:25 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
11:02:28 <aristid> @check \x -> x < 100
11:02:28 <lambdabot>   "Falsifiable, after 257 tests:\n104\n"
11:02:33 <aristid> @check \x -> x < 200
11:02:34 <lambdabot>   "OK, passed 500 tests."
11:03:01 <danr> aristid: This sort of proves that Haskell is ultrafinitist: http://en.wikipedia.org/wiki/Ultrafinitism
11:03:03 <donri> @check (<150)
11:03:03 <lambdabot>   "Falsifiable, after 437 tests:\n176\n"
11:03:22 <donri> @check (<180)
11:03:22 <lambdabot>   "Falsifiable, after 455 tests:\n191\n"
11:03:32 <donri> @check (<199)
11:03:32 <lambdabot>   "OK, passed 500 tests."
11:04:05 <aristid> i think we can make some statements about the distribution of numbers generated by that generator
11:04:15 <aristid> it's NOT uniform, for example
11:05:54 <byorgey> "uniform" is meaningless for Integer
11:06:42 <morolin> @check \x -> x > -199
11:06:42 <lambdabot>   "OK, passed 500 tests."
11:06:44 <donri> @check (/= "abc")
11:06:44 <lambdabot>   "OK, passed 500 tests."
11:06:49 <byorgey> QuickCheck is designed to try "small" values first and progress to "larger" values
11:06:51 <donri> @check (/= "a")
11:06:51 <lambdabot>   "OK, passed 500 tests."
11:07:06 <morolin> It does also check negative numbers
11:07:28 <byorgey> @check (\x -> x /= -1)
11:07:29 <lambdabot>   "Falsifiable, after 41 tests:\n-1\n"
11:07:35 <Peaker> I'd like Arbitrary to interleave values testing all sorts of interesting infinite sequences (exponentially growing, enumerating all, ...)
11:08:06 <byorgey> it's easy enough to write your own generator and use that in place of the default Arbitrary instance
11:08:29 <morolin> Peaker: it'll take infinite time to check against infinite sequences, which is a bit longer than I'd like to wait.
11:09:50 <Peaker> morolin: it's nice to be able to slice more and more of an infinite sequence to get more testing
11:10:38 <donri> what if your bug relies on the same exponential sequence
11:12:43 <morolin> Peaker: IIRC, that is entirely possible to do with quickCheck.  I don't recall how to do it, though.
11:13:05 <Chris_San> Hi I am a complete newbe in haskell, can someone give me some advice about a good book about this language, by the way it is also the first time I participate here and in an IRC channel in general.
11:13:52 <donri> @lyah
11:13:52 <lambdabot> Unknown command, try @list
11:13:59 <donri> @list
11:13:59 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:14:02 <engla> Chris_San: great! This is the most recommended book http://learnyouahaskell.com/
11:14:03 <TotoTitus> google 'learn you a haskell for great good'
11:14:12 <TotoTitus> it is a fantastic book
11:14:26 <TotoTitus> i am in process of assimilation
11:14:38 <TotoTitus> ugh that sounded weird
11:14:47 <aristid> @where lyah
11:14:47 <lambdabot> http://www.learnyouahaskell.com/
11:14:55 <donri> ah
11:15:01 <TotoTitus> :t putStrLn
11:15:02 <lambdabot> String -> IO ()
11:15:03 <aristid> @where rwh
11:15:04 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:15:10 <RaptorRarr> Lyah! You're a lyah!
11:15:24 * TotoTitus pats lambdabot
11:15:25 <donri> and you're a pirate dinosaur
11:15:25 <Chris_San> thank you I will visit those websites to learn more
11:15:27 <Cale> Chris_San: Be sure to ask lots of questions here :)
11:15:33 <RaptorRarr> Well, yes.
11:15:33 <aristid> RaptorRarr: Rwh! You're a rwh!
11:15:43 <RaptorRarr> Haha
11:15:47 <Chris_San> I haven't even run a hello world in haskell
11:15:49 <morolin> Chris_san: As I see it, Real World Haskell has more information useable to actually solve things, whereas Learn You a Haskell is more about how to think in haskell and motivations of the language.  As for IRC, it's a strange place.
11:15:56 <RaptorRarr> rwhaaar!
11:16:21 <TotoTitus> morolin yet, a cozy place
11:16:57 <morolin> TotoTitus: I don't know if there are many places on freenode that I'd call cozy.  But sure.
11:17:13 <TotoTitus> i find this place cozy, probably it's just how i feel
11:17:27 <Saizan> @quote tropical
11:17:28 <lambdabot> No quotes match. Just what do you think you're doing Dave?
11:17:32 <danr> yesod or happstack?
11:17:39 <Saizan> we lost the tropical quote?
11:17:45 <morolin> I guess. 800+ people doesn't really mesh with my definition of "cozy"
11:17:46 <donri> happstack
11:17:57 <engla> morolin: crowded is cozy
11:18:00 <MatrixFrog> lyah has colorful pictures
11:18:05 <Chris_San> thank you morolin I read about how haskell makes you a better programmer in how to solve problems
11:18:13 <MatrixFrog> let's not underestimate how important that is
11:18:15 <ezyang> Re "Is it possible to represent such polymorphism?": clearly this means we should have implicit type families >:-)
11:18:21 <Cale> There are 800 people, but most of them are idling most of the time
11:18:22 * TotoTitus gazes over the channel
11:18:30 <donri> haskell doesn't make you a better programmer, haskell makes you a haskell programmer. haskell is better for programming.
11:18:44 <TotoTitus> i didn't expect such a sylogism
11:18:56 <TotoTitus> actually..no..it's not a sylogism
11:19:38 <morolin> donri:  There are some programs that it's a lot more of a pain to write in Haskell.  However, knowing functional programming paradigms, and having a language that makes thinking about complex data structures easier, I feel, has made me better at programming in other paradigms.
11:19:39 <Cale> I think using Haskell actually does lead you to certain conclusions about good programming practices that are rather hard to come by if you spend all your time programming in imperative languages with effects everywhere.
11:20:02 <MatrixFrog> it's not just effects
11:20:15 <MatrixFrog> i feel like i often notice things in Java that are "wrong"
11:20:23 <MatrixFrog> like the way that compareTo returns -1, 0, or 1
11:20:25 <TotoTitus> yeah! From now on, when i write in a stateful language, i will isolate statefulness in its own cage
11:20:29 <MatrixFrog> rather than LT, EQ, or GT
11:20:47 <aristid> MatrixFrog: haskell's Ord is totally broken, too
11:20:55 <hpc> aristid: how?
11:20:56 <TotoTitus> artistid: Why ?
11:21:00 <aristid> especially the Ord instance for Double :)
11:21:16 <shirt> rostayob: something like, data X = X { y :: U -> V -> W }
11:21:18 <MatrixFrog> you can't accidentally take two Orderings and try to add them together because the compiler will say that Ordering is not an instance of Num
11:21:25 <hpc> aristid: the Double instance is exactly how it should be defined
11:21:29 <shirt> rostayob: and be able to document the individual U and V arguments
11:21:35 <MatrixFrog> but you could accidentally take the results from some compareTo calls and add them
11:21:51 <hpc> (it's the spec that sucks)
11:21:55 <Cale> shirt: I don't think you can do that, at least, I haven't seen it done.
11:22:00 <aristid> hpc: well, sure
11:22:16 <MatrixFrog> i assume the double instance is just the same as how d1 < d2 works in any other languages that supports IEEE floating point? is it not?
11:22:17 <aristid> hpc: which spec do you mean tho? IEEE 754 or Ord?
11:22:33 <hpc> the Double instance for Ord
11:22:37 <aristid> MatrixFrog: it's the same for d1 < d2, but compare behaves differently
11:22:39 <hpc> and the IEEE spec
11:22:56 <aristid> hpc: i think it would be better if the instance did not exist
11:23:01 <Cale> aristid: why?
11:23:09 <aristid> Cale: well actually it wouldn't
11:23:14 <aristid> that would be terribly impractical
11:23:43 <hpc> aristid: you mean that it would be nice if we didn't have to break the "Ord laws" to define the instance
11:23:56 <Cale> Floating point is a tricky compromise.
11:24:26 <aristid> hpc: yes, and especially not have this weird behavior of compare
11:24:26 <Cale> It's hard to come up with something which has the same performance properties and better semantics.
11:24:45 <Cale> If you use CReal, then comparison operations become potentially nonterminating
11:24:57 <aristid> Cale: NaN also exists for a good reason, i think. but it doesn't fit within haskell's Ord typeclass.
11:25:23 <tsousa> http://dpaste.com/625764/ why this code isnt giving me the last element?
11:25:34 <hpc> Cale: perhaps make all the comparison functions undefined for NaNs and infinities (though i suppose infinity > everything is fine)
11:25:49 <Cale> tsousa: Well, let's calculate what it does to [1,2,3]
11:25:57 <shirt> Cale: i tried, doesn't seem to work: parse error on input `->'
11:26:02 <donri> tsousa: because you're continuing til the list is empty then returning an empty list
11:26:11 <RaptorRarr> To figure out where NaN should fit, we ask ourselves "how great is NaN, really?"
11:26:14 <Cale> tsousa: mylast (1:2:3:[]) = mylast (2:3:[]) = mylast (3:[]) = mylast [] = []
11:26:27 <RaptorRarr> If NaN is just super duper, we put it greater than everything else.
11:26:45 <aristid> the _point_ of NaN is that it doesn't fit anywhere
11:26:51 <tsousa> Cale, yes
11:27:03 <RaptorRarr> > compare (0.0/0.0) 5
11:27:04 <lambdabot>   GT
11:27:08 <TotoTitus> i have a question about applicative functors
11:27:12 <RaptorRarr> > compare (0.0/0.0) (1.0/0.0)
11:27:13 <lambdabot>   GT
11:27:17 <TotoTitus> in the context of functions being applicative functors
11:27:26 <TotoTitus> :t (<*>) :: Function
11:27:27 <lambdabot>     Not in scope: type constructor or class `Function'
11:27:30 <tsousa> Cale, how can i tell haskell when it's the last element that it needs to show it?
11:27:30 <RaptorRarr> NaN is super duper, according to the Haskell crowd.
11:27:33 <MatrixFrog> TotoTitus sounds good. i was just reading about that in lyah
11:27:36 <Cale> > decodeFloat (0/0)
11:27:37 <lambdabot>   (-6755399441055744,972)
11:27:47 <TotoTitus>  f <*> g = \x -> f x (g x)
11:27:58 <ezyang> @type (<*>)
11:27:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:27:59 <TotoTitus> What does f x (g x) mean ?
11:28:05 <RaptorRarr> tsousa: f [x] = ...
11:28:08 <MatrixFrog> tousa: look at the way [1,2,3] got reduced. at some point during that reduction you want to say "wait, hang on, you're doing it wrong!" -- what is that point?
11:28:13 <ddarius> > compare 5 (0.0/0.0)
11:28:14 <lambdabot>   GT
11:28:15 <RaptorRarr> TotoTitus: It means f with two arguments: x and g x.
11:28:17 <TotoTitus> f is a single-param function
11:28:22 <Cale> TotoTitus: It means f applied to x and the result of applying g to x
11:28:24 <donri> tsousa: sure you want [a] -> [a] not [a] -> a?
11:28:26 <ezyang> TotoTitus: It returns a function.
11:28:27 <aristid> > 5 > (0.0/0.0)
11:28:28 <lambdabot>   False
11:28:32 <TotoTitus> nonono
11:28:34 <Cale> f must have two parameters
11:28:35 <RaptorRarr> TotoTitus: It would produce a function then.
11:28:37 <TotoTitus> Why does f take two arguments ?
11:28:40 <aristid> > (0.0/0.0) > 5
11:28:41 <lambdabot>   False
11:28:43 <Cale> because:
11:28:44 <morolin> I asked this a bit earlier, but, Does anyone know if alex and parsec play nicely together?  And if they do, is there documentation of them playing nicely?  The parsec pdf doesn't mention alex, and I couldn't find anything in about 15 minutes of googling.
11:28:45 <TotoTitus> Wait, f is a functor
11:28:47 <TotoTitus> Right.
11:28:48 <aristid> RaptorRarr: see how fucked up it is? :)
11:28:49 <RaptorRarr> TotoTitus: Like it takes an argument, produces a function that takes another argument.
11:28:55 <Cale> (<*>) :: f (a -> b) -> f a -> f b
11:29:00 <Cale> and here f = (e ->)
11:29:09 <RaptorRarr> aristid: Ahh.
11:29:14 <Cale> so (<*>) :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
11:29:23 <RaptorRarr> aristid: So, the Haskell people punted on how great NaN is.
11:29:23 <Cale> or:
11:29:24 <TotoTitus> Yes, you are right
11:29:31 <Cale> (<*>) :: (e -> a -> b) -> (e -> a) -> e -> b
11:29:33 <TotoTitus> we are partially applying function composition
11:29:40 <TotoTitus> first time
11:29:42 <Cale> ?
11:29:44 <TotoTitus> then completing it
11:29:50 <TotoTitus> f x (g x)
11:29:53 <Cale> There's no composition in that...
11:29:59 <aristid> RaptorRarr: at least when using compare. when using (<), (<=), (>), (>=), (==) and (/=), it's consistent with IEEE 754.
11:30:05 <m42a> > compare (0.0/0.0) (0.0/0.0)
11:30:06 <lambdabot>   GT
11:30:16 <TotoTitus> Nono, i'm onto something...wait
11:30:17 <aristid> > (0.0/0.0) == (0.0/0.0)
11:30:18 <Cale> But function composition is closely related, in that it's the fmap for this functor
11:30:18 <lambdabot>   False
11:30:19 <RaptorRarr> aristid: Ahh, I see.
11:30:22 <aristid> > (0.0/0.0) /= (0.0/0.0)
11:30:23 <lambdabot>   True
11:30:30 <m42a> NaN can't equal itself
11:30:32 <donri> > let mylast [] = Nothing; mylast [x] = Just x; mylast (_:xs) = mylast xs in mylast [1,2,3]
11:30:33 <lambdabot>   Just 3
11:30:38 <ddarius> morolin: Alex can produce a list of tokens and parsec has always been able to parse an arbitrary list of tokens.
11:30:38 <m42a> so clearly it's greater
11:30:53 <donri> tsousa: ^
11:31:10 <MatrixFrog> Toto: what might help is to write out the instance in a way that makes sense to you, and then prove that your way is equivalent to the way it's done in whatever you're reading (lyah i assume)
11:31:12 <Cale> tsousa: You need to pattern match the case where there's only one element
11:31:35 <Cale> tsousa: for example, you could insert the case   mylast [x] = [x]
11:31:44 <Cale> in the middle of that definition you had
11:31:55 <morolin> ddarius: Yea, this makes sense, but I was hoping to see an example of someone using parsec that way, and I couldn't find it.  *shrug*
11:31:58 <tsousa> oh nice
11:32:02 <tsousa> thanks you :)
11:32:05 <Cale> > let mylast [] = []; mylast [x] = [x]; mylast (x:xs) = mylast xs in mylast [1..10]
11:32:06 <lambdabot>   [10]
11:32:24 <TotoTitus> I got it !! Wait a sec..
11:32:46 <Cale> TotoTitus: well, there's only one thing that the function (<*>) could be here, because of its type
11:32:51 <TotoTitus> Since functors in the case of functions mean function composition
11:32:59 <TotoTitus> in f (<*>) g
11:33:01 <Cale> @djinn (e -> a -> b) -> (e -> a) -> (e -> b)
11:33:01 <lambdabot> f a b c = a c (b c)
11:33:15 <TotoTitus> f 'arrives' as (r ->) (a->b)
11:33:34 <TotoTitus> f has already been composed with something
11:33:42 <Cale> ?
11:33:51 <Cale> I'm confused :)
11:34:06 <Cale> f :: e -> a -> b
11:34:14 <Cale> g :: e -> a
11:34:21 <Cale> f <*> g :: e -> b
11:34:24 <TotoTitus> When we wrap a function into a functor
11:34:27 <TotoTitus> Just (*3)
11:34:52 <TotoTitus> The applicative extracts the function, untouched by the functor, and does mapping with it
11:34:53 <MatrixFrog> in that case, the functor is Maybe. you're talking about the case where the functor is ((->) r)
11:35:11 <TotoTitus> In the case the function is wrapper in a functor, which is a function itself
11:35:16 <TotoTitus> This is function composition
11:35:27 <TotoTitus> The applicative extracts the original function, before it was composed
11:35:30 <Cale> TotoTitus: that's not a particularly good way to think of it, because it makes it sound like there's only one function
11:35:36 <TotoTitus> with the functor within which it resides
11:35:43 <donri> don't forget partial application
11:35:50 <Cale> (which is true in the case of Maybe, but untrue in most other cases)
11:36:13 <TotoTitus> I think my reasoning was correct, even though the explanation was rather contrived
11:36:17 <TotoTitus> wait, i'll do some tests
11:36:42 <Cale> But hey, in any monad at least, you can expect that  f <*> x = do f' <- f; x' <- x; return (f' x')
11:37:19 <Cale> But don't think of <- as "unwrapping"
11:37:49 <Cale> If you want to look at it in a containery way, <- means "choosing from"
11:38:23 <Cale> That is, v <- x means "choose v from x"
11:38:31 <TotoTitus> thanks for the example...though i haven't gotten really into monads yet
11:38:37 <Cale> In a computational mindset, it means "run x to get the result v"
11:39:37 <aristid> and in a (almost) literal way, it's x >>= \v -> ...
11:40:09 <Cale> So in the IO monad for example, we might write  readIORef r <*> getLine  to get a function from r :: IORef (String -> a), and apply it to a string read from the user all at once.
11:40:22 <Cale> (admittedly somewhat contrived)
11:41:27 <ddarius> Cale: In SML, that would be (!r) getLine
11:41:33 <TotoTitus> SML ?
11:41:43 <Cale> another programming language
11:41:49 <Cale> (strict, with effects)
11:42:24 <Cale> ghci> :m + Data.IORef
11:42:24 <Cale> ghci> :m + Control.Applicative
11:42:28 <Cale> ghci> r <- newIORef (reverse :: String -> String)
11:42:28 <Cale> ghci> do x <- readIORef r <*> getLine; putStrLn x
11:42:28 <Cale> hello
11:42:28 <Cale> olleh
11:42:42 <missingfaktor> TotoTitus: (+) <$> (*10) <*> (+11) returns you function: f n = n * 10 + (n + 11)
11:43:15 <Cale> ghci> writeIORef r id
11:43:15 <Cale> ghci> do x <- readIORef r <*> getLine; putStrLn x
11:43:15 <Cale> hello
11:43:15 <Cale> hello
11:47:43 <heatsink> Are there tools for analyzing profiling output?
11:48:10 <heatsink> I'd like to break down the execution time of a cost-center by the cost-centers it was called from.
11:48:29 <ddarius> fix analyzeTheOutputOf
11:48:48 <heatsink> The .prof file looks like it has all that information, but not in a useful form.
11:50:20 <heatsink> @src analyzeTheOutputOf
11:50:20 <lambdabot> Source not found. Do you think like you type?
11:50:34 <heatsink> @src ddarius
11:50:35 <lambdabot> Source not found. I feel much better now.
11:51:05 <ststephen> hi
11:51:11 <heatsink> hi
11:51:25 <ststephen> i have a question about type classes
11:51:32 <byorgey> heatsink: perhaps try http://blog.foldr.in/tkyprof-a-web-based-interactive-visualizer-fo ?
11:51:36 <byorgey> ststephen: ask away
11:51:55 <ststephen> first of all
11:52:09 <ststephen> is there a type class for things that are "list-like", i.e. have heads and tails?
11:52:35 <heatsink> byorgey, neat
11:52:44 <ststephen> I'm trying to implement a generalized fold
11:52:45 <MatrixFrog> there's Functor, which is kind of for things that are "list-like" in a sense, but not the sense you mean
11:52:49 <ststephen> yeah
11:52:53 <MatrixFrog> but there is a Foldable class :)
11:52:58 <heatsink> ststephen, There's the 'Foldable' class for generalized folds
11:53:04 <MatrixFrog> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Foldable.html#t:Foldable
11:53:05 <ststephen> ok cool; more general question then:
11:53:21 <ststephen> suppose i am implementing a heap of some kind
11:53:35 <ststephen> there's a natural way to turn a heap into a list
11:53:37 <byorgey> ststephen: there is also http://hackage.haskell.org/package/ListLike
11:53:57 <ststephen> ooh let me check that out
11:54:26 <hSDL> Hai guys
11:54:30 <heatsink> By heap, do you mean a data structure with a O(1) extract-minimum operation?
11:54:45 <ststephen> yes
11:54:57 <ststephen> i'm thinking of a binary tree implementation though
11:55:10 <ststephen> leftist heap, say
11:55:16 <shirt> where can i find the ultimate explanation of foldl, foldr, foldl', foldr' ?
11:55:26 <heatsink> @src foldl
11:55:26 <lambdabot> foldl f z []     = z
11:55:27 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:55:36 <heatsink> @src foldr'
11:55:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:55:41 <hSDL> Is there any way , how I can SIMPLY install hSDL (SDL bindings for Haskell) in windows vista?  In ubuntu it was quit easy
11:55:41 <MatrixFrog> source != explanation
11:55:45 <MatrixFrog> at least not generally
11:55:48 <Botje> I don't think a foldr' would make sense
11:56:12 <engla> shirt: http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29#List_folds_as_structural_transformations
11:56:51 <byorgey> shirt: see http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27  and also http://www.haskell.org/haskellwiki/Fold
11:57:47 <byorgey> ststephen: perhaps you want to write a Foldable instance for your heap?
11:57:56 <byorgey> ststephen: it includes a toList method
11:58:15 <ststephen> @byorgey maybe
11:58:16 <lambdabot> Unknown command, try @list
11:58:20 <ststephen> @list
11:58:20 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:58:33 <ststephen> i'm an irc noob so bear with me
11:58:48 <byorgey> no worries =)
11:58:48 <MatrixFrog> when you start something with "@" lambdabot thinks you're telling it to do something
11:58:59 <MatrixFrog> nbd
11:59:02 <ststephen> groovy
11:59:05 <hpc> (the same applies if you start with '?', or a few other characters i think)
11:59:27 <byorgey> ststephen: if addressing someone in particular it's customary to prefix with  nick: ...
11:59:34 <ststephen> cool
11:59:50 <hpc> ststephen: you can tab-complete "nick: " in most clients
11:59:56 <TotoTitus> where is the functor definition for (-> r) located ? what import do i need ?
12:00:15 <Botje> Control.Monad.Instances has the monad one
12:00:27 <byorgey> I think it has the functor instance as well.
12:00:28 <Botje> and also the functor
12:00:30 <Botje> yes
12:00:44 <TotoTitus> yes, thanks
12:01:08 <MatrixFrog> i think you'll see that the official instance is slightly different from lyah's, but of course they're equivalent
12:01:11 <ststephen> byorgey: it doesn't look like Foldable is what I want
12:01:25 <byorgey> ststephen: ok. what are you trying to do?
12:02:15 <ststephen> byorgey: lemme think for a sec
12:02:38 <shirt> engla, byorgey: thanks
12:03:21 <ststephen> byorgey: here's what i'm trying to do
12:04:18 <ststephen> byorgey: suppose i have: data LHeap = Empty | Node Int a (LHeap a) (LHeap a)
12:04:25 <ststephen> the "Int" is the rank of the heap
12:04:52 <ststephen> byorgey: and yeah, so I want to turn that heap into a list
12:05:02 <ststephen> byorgey: it does look like Foldable's toList function is what I want
12:05:18 <ststephen> byorgey: but how would I declare LHeap as a Foldable instance?
12:05:59 <Sebasti0n> when i have a function returning a double value and the return type is fun :: (Floating a) => a why does the compiler not allow that?
12:06:30 <ststephen> Sebasti0n: that type signature would imply a itself is a float, not a function that return a float
12:06:58 <ststephen> Sebasti0n: so the function "fun" is not really a function, but a value
12:07:06 <Sebasti0n> true, then fun :: (Floating a) => Int -> a
12:07:12 <heatsink> Sebasti0n, the return type says that the function is capable of returning any Floating type
12:07:20 <byorgey> Sebasti0n: if the return type is  (Floating a) => a  then the function must be able to return ANY Floating type of the caller's choosing
12:07:24 <heatsink> Sebasti0n, but actually the function is only capable of returning a specific floating type, 'Double'
12:07:58 <byorgey> ststephen: instance Foldable LHeap where ...
12:08:09 <lucca> base >=4 && <3 && >=2 && <5 .... am I reading that requirement wrong, or will that be very challenging to meet?
12:08:16 <byorgey> ststephen: you only have to define foldMap and you get the other methods for free
12:08:30 <heatsink> That looks like a very odd constraint, lucca
12:08:32 <ststephen> byorgey: yeah thank you; i guess i'm just trying to get my head around Foldable
12:08:37 <ststephen> byorgey: thanks very much
12:09:01 <lucca> heatsink: result of bootstrap.sh on cabal-install on ghc-7.2.1 minimal.
12:09:17 <byorgey> ststephen: alternatively if you enable the  DeriveFoldable  extension and have GHC generate the Foldable instance for you
12:09:19 <heatsink> lucca, I think you'll have to look outside the real numbers to satisfy that version requirement :)
12:09:26 <Sebasti0n> ststephen: but when a function can only return a double it still suffices the constraint that the return type is of class floating, right?
12:09:26 <dankna> bootstrap.sh often needs manual edits, depending on exact versions of things
12:09:30 <byorgey> ststephen: here's a blog post I wrote about it: http://byorgey.wordpress.com/2010/03/03/deriving-pleasure-from-ghc-6-12-1/
12:09:35 <lucca> ... going to sheepishly return to the haskell-platform for now, I think.
12:09:38 <ststephen> byorgey: ok cool
12:09:39 <hpc> obviously you want base version NaN
12:09:49 <byorgey> ststephen: although you will may find it instructive to implement it yourself
12:09:54 <ststephen> byorgey: when would Foldable be derivable - for Monoids?
12:09:57 <heatsink> lol@hpc
12:11:18 <byorgey> ststephen: no, Monoid is involved, but types which are instances of Monoid cannot be Foldable
12:11:31 <byorgey> Foldable is intended for "container" types like trees, lists, heaps, ...
12:12:15 <ststephen> byorgey: okay
12:12:15 <hpc> byorgey: lists are monoids...
12:12:21 <hpc> [a], rather
12:12:47 <MatrixFrog> wait, but list is a monoid. so it's possible for a type to be both. i think you mean it's not *generally* true that if a type is a Monoid, it can also be a Foldable?
12:12:51 <byorgey> hpc: well, OK, you have to interpret what I said literally
12:12:59 <byorgey> [a] is a monoid but it is not Foldable.  [] is Foldable.
12:13:04 <hpc> MatrixFrog: what he means is they have different kinds
12:13:11 <byorgey> right.
12:13:16 <MatrixFrog> ohhh i see
12:13:25 <hpc> or, (Maybe a) might be a monoid, and Maybe is a Foldable
12:13:33 <hpc> (if such instances exist)
12:13:48 <Peaker> > Just [1] `mappend` Just [2]
12:13:49 <lambdabot>   Just [1,2]
12:13:51 <ststephen> byorgey: ok, new question
12:13:59 <ststephen> byorgey: related
12:14:21 <ststephen> byorgey: my LHeap is only going to be foldable if the type it contains are orderable
12:14:38 <byorgey> ststephen: why is that?
12:15:06 <byorgey> I understand why you would want a heap to contain orderable data but I don't see what it has to do with folding.
12:15:07 <ststephen> byorgey: because the way you turn an LHeap into a list is to first take the root node
12:15:13 <ststephen> byorgey: then merge the two subtrees
12:15:28 <heatsink> You certainly need to test ordering when building the LHeap
12:15:28 <ststephen> byorgey: but merging requires an ordering on the values
12:15:29 <heatsink> Do you need to test ordering when folding the LHeap?
12:15:36 <byorgey> oh, I see what you're saying.
12:15:46 <ststephen> yeah it's not just recursing down the tree
12:15:51 <heatsink> O I C
12:15:53 <ststephen> you have to rebuild it at each step
12:16:10 <ststephen> yeah that's why i was thinking of making some kind of "Listlike" class
12:16:23 <ststephen> so that head would return the root, tail would return the merged subtrees
12:16:29 <ststephen> and then a fold would work as expected
12:16:29 <byorgey> ststephen: ok, in that case Foldable is (sadly) not what you want.
12:16:41 <ststephen> :,(
12:16:44 <byorgey> ststephen: I don't see what a listlike class would buy you.
12:16:58 <byorgey> ststephen: just write your own function  toList :: Ord a => LHeap a -> [a]
12:17:16 <ststephen> byorgey: yeah i guess i was trying to do it in the most general way possible
12:17:26 <byorgey> ststephen: that IS the most general way possible.
12:17:28 <ststephen> byorgey: i was thinking - folds assume that you are taking values from a list
12:17:42 <ststephen> byorgey: but what if you want some other kind of object that can act like a list
12:17:50 <ststephen> byorgey: then you could fold up that object
12:18:03 <byorgey> then you just compose toList with a function to convert from a list to your other kind of object.
12:18:05 <ststephen> byorgey: maybe not so important in this case but i thought it was an interesting idea
12:18:24 <ststephen> byorgey: ok
12:19:29 <byorgey> ststephen: also, folds don't (in general) assume you are taking values from a list.
12:19:33 <byorgey> although the Foldable class does.
12:20:02 <aristid> byorgey: somebody said that Foldable should be reduced to the toList function
12:20:21 <ezyang> If it's fused away, I guess that could be equivalent.
12:20:21 <ststephen> byorgey: oh cool - i assumed from the type sig of folds, they always required lists
12:20:25 <byorgey> aristid: it could be.
12:20:47 <MatrixFrog> ststephen, the standard folds do require lists
12:20:58 <MatrixFrog> but the Data.Foldable module defines more general folds
12:20:59 <byorgey> ststephen: what do you mean, "the type sig of folds"?  do you mean foldl and foldr?
12:21:07 <ststephen> byorgey: yes
12:21:21 <byorgey> ststephen: those are just some folds for lists in particular.
12:21:30 <byorgey> the concept of a "fold" is more general.
12:21:39 <ststephen> byorgey: right
12:22:23 <Saizan> the Foldable class isn't this more general version though
12:22:36 <Saizan> you've to read about "catamorphisms" to see it
12:23:14 * antihoax is frying potatoes and eating while reading irc
12:23:41 <MatrixFrog> om nom nom
12:23:59 <ststephen> ok i'm going to ask a different question
12:24:07 <byorgey> real generalized folds can be found in http://hackage.haskell.org/packages/archive/recursion-schemes/2.0/doc/html/Data-Functor-Foldable.html
12:24:15 <byorgey> but that is not for the faint of heart =)
12:24:46 <ststephen> whoahhh! comonads
12:25:31 <byorgey> antihoax: careful that you don't get mixed up and eat the frying pan, read the potatoes, etc.
12:26:22 <MatrixFrog> if the real world had a good type system, then the compiler would prevent him from making such mistakes
12:27:41 <TotoTitus> Wait.
12:27:51 * MatrixFrog waits
12:27:54 <TotoTitus> (r -> a -> b) -> (r -> a) -> (r -> b)
12:28:06 <TotoTitus> Is applicative for functions, right ?
12:28:23 <MatrixFrog> that's the type signature of (<*>)
12:28:27 <TotoTitus> Ok, good
12:28:28 <TotoTitus> Then:
12:28:33 <MatrixFrog> for the specific Applicative instance you're looking at
12:28:39 <TotoTitus> f <*> g = \x -> f x (g x)
12:28:43 <TotoTitus> Why isn't it
12:28:46 <TotoTitus> \x -> f (g x) x
12:29:03 <TotoTitus> Since g returns 'a', and f expects 'a' to be its second parameter
12:29:29 <TotoTitus> expects something of type 'a'
12:29:47 <MatrixFrog> the first parameter to f, is x
12:29:51 <MatrixFrog> which has type r
12:30:02 <MatrixFrog> the second parameter is (g x) which has type a, as you said
12:30:06 <Cale> TotoTitus: look at the type :)
12:30:18 <Cale> (<*>) :: f (a -> b) -> f a -> f b
12:30:37 <MatrixFrog> i think toto's type signature is easier to understand in this case
12:30:39 <Cale> (<*>) :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
12:30:48 <MatrixFrog> yeah, that one :)
12:31:12 <Cale> and then we can remove some redundant parens:
12:31:17 <TotoTitus> I'm not looking for concrete examples, i am just figuring this thing abstractly
12:31:18 <Cale> (<*>) :: (e -> a -> b) -> (e -> a) -> e -> b
12:31:43 <Cale> So in the expression (f <*> g) x
12:31:50 <Cale> f :: e -> a -> b
12:31:53 <Cale> g :: e -> a
12:31:58 <Cale> x :: e
12:32:24 <Cale> and we're trying to make a value of type b
12:32:36 <TotoTitus> Yes, go on
12:32:39 <Cale> So to do this, we must use f somehow, because it's the only thing which can make a value of type b
12:32:53 <TotoTitus> So we plug in
12:32:53 <Cale> and to use f, we need a value of type e and a value of type a
12:33:02 <Cale> We have a value of type e, namely x
12:33:07 <Cale> So f x :: a -> b
12:33:14 <TotoTitus> And we get the a from g
12:33:16 <Cale> right
12:33:19 <TotoTitus> thanks
12:33:21 <Cale> So g x :: a
12:33:26 <Cale> and f x (g x) :: b
12:33:29 <Cale> as needed
12:33:36 <antihoax> hey Cale bored? :)
12:33:45 <Cale> antihoax: What's up?
12:33:53 * antihoax is frying potatoes and eating while reading irc
12:33:54 <byorgey> ststephen: what was your different question?
12:33:59 <antihoax> want some?
12:34:25 <Cale> I'm incorporeal, I'm afraid.
12:34:30 * byorgey fries some lambdas
12:34:42 * TotoTitus fries some brains
12:35:25 <byorgey> I'm incorporeal, I'm afraid, and I'm hungry
12:37:07 * heatsink gives byorgey some food for thought
12:38:05 <heatsink> Maybe, (), and Bool go to the Lone Star Bar.  The bouncer stops Maybe and says, "we don't serve your kind here."
12:38:24 <byorgey> hahaha
12:38:39 <byorgey> @remember heatsink Maybe, (), and Bool go to the Lone Star Bar.  The bouncer stops Maybe and says, "we don't serve your kind here."
12:38:39 <lambdabot> Good to know.
12:38:51 <heatsink> =)
12:41:43 <Botje> *groan* :P
12:42:22 <loupgaroublond> heatsink, i think you meant thought for food
12:42:41 <Peaker> Maybe and () can probably go past selection as a couple
12:43:35 <aristid> but Maybe has to go first
12:44:18 <aristid> :t mkPT
12:44:19 <lambdabot> Not in scope: `mkPT'
12:44:21 <loupgaroublond> this is where punctuation really matters
12:44:33 <lucca> dankna: you were right; grabbing darcs cabal and hand-editing the versions made it workable
12:44:50 <lucca> no NaNs needed >_>
12:45:57 <JoeyA> foreign import ccall "stdio.h malloc" c_realloc :: Ptr a -> CSize -> IO (Ptr a)
12:46:05 <JoeyA> Why didn't Haskell's type checker catch that mistake?
12:46:23 <JoeyA> We demand a mind-reading compiler!
12:47:28 <Jeanne-Kamikaze> does that actually compile ?
12:47:42 <JoeyA> Yup
12:47:47 <Jeanne-Kamikaze> why ?
12:47:51 <geheimdienst> what's the mistake?
12:47:59 <Jeanne-Kamikaze> how can you pass two args to malloc ?
12:48:11 <JoeyA> The mistake is importing malloc, and using realloc's signature.
12:48:24 <dafis> geheimdienst: for one, it should be stdlib
12:48:29 <Jeanne-Kamikaze> yeah
12:48:32 <Jeanne-Kamikaze> that too
12:48:37 <JoeyA> Oh, I didn't catch that.
12:48:47 <JoeyA> I make more C mistakes in Haskell than I do in C, apparently...
12:48:52 <geheimdienst> oh right ...
12:49:10 <dafis> JoeyA: leet is when you make Haskell mistakes in C
12:49:24 <geheimdienst> but doesn't it blow up in the linking step, or something? doesn't it at least give a warning about symbol not found ...?
12:49:24 <JoeyA> lol
12:49:38 <JoeyA> dafis: Do you have any examples of that?
12:49:52 <engla> geheimdienst: the linker can't know about function signatures.
12:50:11 <JoeyA> geheimdienst: If you declare malloc incorrectly, GCC may warn you, but your program will compile.
12:50:27 <geheimdienst> right. kinda sad really
12:50:28 <Jeanne-Kamikaze> and then it ignores the whatever extra arguments you passed to it ?
12:50:36 <dankna> lucca: ah good!
12:51:30 <dafis> JoeyA: unfortunately, I'm not that leet :(
12:53:53 <hpc> i can't even think of anything i would say is a "haskell mistake"
12:53:54 <heatsink> Jeanne-Kamikaze: It passes all arguments normally, even though the function doesn't expect them.  The exact behavior depends on how argument-passing works in the C ABI for the platform.
12:54:11 <hpc> when i think i find something, it applies to all general program design
12:54:19 <Jeanne-Kamikaze> ok
12:59:29 <JoeyA> hpc: How about building up a huge thunk for a number and getting a stack overflow?
12:59:43 <JoeyA> (e.g. if you're tallying something using an IORef)
13:00:06 <JoeyA> (an example of a "haskell mistake")
13:00:09 <Peaker> it could be nice to auto-generate FFI imports based on debug info
13:00:11 <hpc> heh
13:00:55 <TotoTitus> why doesn't this work?
13:01:03 <TotoTitus> (+) . (+3) $ 2 4
13:01:07 <heatsink> Haskell doesn't support refactoring class hierarchies well.  Like the duplication of functionality between Functor and Monad.
13:01:15 <hpc> TotoTitus: you are applying 2 to 4
13:01:23 <heatsink> Resulting in things like the duplication of functionality between Functor and Monad.
13:01:31 <TotoTitus> oh.
13:01:34 <aristid> TotoTitus: try ((+) . (+3)) 2 4
13:02:22 <TotoTitus> Hmm, what about (+) . (+3) $ 2 $ 5
13:02:28 <heatsink> liftM = fmap for Monad instances, but it must be re-declared for every monad instance.
13:03:17 <aristid> :t (+) . (+3)
13:03:18 <lambdabot> forall a. (Num a) => a -> a -> a
13:03:38 <TotoTitus> it works, but additional parentheses are needed
13:03:40 <hpc> TotoTitus: best not to (ab)use ($) like that ;)
13:03:54 <hpc> the parens will be clearer imo
13:04:05 <heatsink> > fix $ when False
13:04:06 <lambdabot>   No instance for (GHC.Show.Show (m ()))
13:04:07 <lambdabot>    arising from a use of `M639173634...
13:04:23 <hpc> > (fix $ when False) :: Maybe ()
13:04:24 <lambdabot>   Just ()
13:04:43 <hpc> > mzero :: Maybe ()
13:04:44 <lambdabot>   Nothing
13:04:55 <hpc> > mempty :: Maybe ()
13:04:55 <lambdabot>   Nothing
13:04:57 <aristid> :t when False
13:04:58 <hpc> huh
13:04:58 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> m ()
13:05:05 <hpc> oh right
13:05:18 <heatsink> You're probably thinking of 'guard'
13:05:25 <hpc> :t guard
13:05:26 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:06:01 <ybit> Did anyone see the presentation Algorithm is not a four letter word? I'd like to know how to create simple graphical mazes like that in haskell
13:07:33 <MatrixFrog> http://www.jamisbuck.org/presentations/rubyconf2011/index.html would be the one i guess
13:07:44 <MatrixFrog> i didn't but i'll go through the slides now...
13:08:08 <ybit> MatrixFrog: that's the one
13:12:08 <MatrixFrog> i'm too tired to follow all this graph theory stuff right now :-/
13:12:21 <ybit> i don't blame you
13:12:34 <ybit> i just want to know how to make simple mazes as in the examples
13:12:51 <ststephen> ybit: check this site out http://www.astrolog.org/labyrnth/algrithm.htm
13:13:01 <ststephen> ybit: it's a site about maze algorithms
13:13:11 <ststephen> ybit: best source i've found
13:13:41 <ybit> nice!
13:14:13 <ybit> not sure if hopengl is the best method for creating simple mazes though
13:14:35 <ybit> i know the crew behind nikki went with the qt's lib for this
13:15:28 <ybit> this being displaying graphics
13:15:47 <rahul> F1!
13:15:52 <MatrixFrog> it seems to me that the maze generation algorithm is separate from how you display the mazes
13:15:57 <rahul> http://stackoverflow.com/questions/7629275/why-do-i-get-ambiguous-type-variable-error-here
13:16:17 <MatrixFrog> so it should be easy enough to change the display method without changing the graph theory stuff
13:17:16 <Saizan> rahul: because there's no way to decide which Monoid instance you want to use
13:17:33 <MatrixFrog> the 5's are of type 'a'
13:17:44 <MatrixFrog> wait no
13:17:46 <MatrixFrog> the first 5 is Int
13:17:48 <MatrixFrog> the second one is a
13:18:00 <MatrixFrog> and then (times 5 5) is also of type 'a'
13:18:08 <rahul> So it should pick Monoid Int no?
13:18:18 <Saizan> no
13:18:27 <MatrixFrog> no, because the first 5 could be an Int while the second could be Double or something
13:18:33 <Saizan> because the type of the second argument isn't restricted by the type of the first
13:18:34 <lucca> xhtml seems to break on ghc-7.2; it's trying to use safe but the implicit prelude include breaks that
13:19:12 <MatrixFrog> so you could do: main = print $ times 5 x where x = (5 :: Int)
13:19:13 <dafis> lucca: ghc-pkg trust base
13:19:24 <MatrixFrog> or even, i think, main = print $ times 5 (5 :: Int)
13:19:28 <lucca> hmmm
13:19:38 <rahul> How do I fix it without requiring an ugly type annotation at application site?
13:19:51 <dafis> lucca: if you don't trust base, who you're gonna trust?
13:20:01 <Saizan> rahul: you could give a more restrictive type to times
13:20:11 <Saizan> rahul: i.e. times :: Int -> Int -> Int
13:20:13 <lucca> dafis: right.  Is that something not done by default, or how did I untrust it?
13:20:23 <shirt> how can i add a single element to the end of a list?
13:20:35 <Saizan> > [1..3
13:20:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:20:40 <Saizan> > [1..3] ++ [4]
13:20:42 <lambdabot>   [1,2,3,4]
13:20:42 <rahul> Saizan: I want it to work with any monoid. And I can think of no reason why it shouldn't.
13:20:43 <Twey> shirt: Short answer: list ++ [element]
13:20:50 <Twey> shirt: Long answer: don't
13:21:10 <dafis> lucca: it's an oversight in 7.2, it's shipped with base not trusted by default, although it should be (and was intended to, just somebody forgot)
13:21:27 <Twey> shirt: Explanation of long answer: appending to singly-linked lists is *slow* (O(n)), & so you should probably use a different data type, like Seq
13:21:46 <Saizan> rahul: then you'll need type annotations when the specific monoid you want can't be inferred from context, usually you won't be using numeric literals so it shouldn't be much of a problem
13:22:11 <shirt> Twey: is the short answer really the best way? there's no dedicated function that doesn't require putting the element inside a list?
13:22:17 <aristid> > length.["list ++ [element]","don't"]
13:22:19 <lambdabot>   [17,5]
13:22:31 <aristid> Twey: liar! the long answer was actually shorter!
13:22:31 <Twey> shirt: No, because you shouldn't be doing it
13:22:41 <Twey> aristid: Only in text!  Look deeper!
13:22:46 <MatrixFrog> rahul, actually Int doesn't even have a Monoid instance. or rather, it has two, but they're on newtypes, not on Int itself
13:23:05 <shirt> Twey: ok, i'll explain what i'm doing
13:23:20 <shirt> i have a lazy ByteString that i need to convert to a strict ByteString and add a single character to the end
13:23:45 <shirt> so i'm doing: B.concat (BL.toChunks (encode val) ++ [B.singleton 0])
13:23:52 <Twey> shirt: If you're working with characters, use Text
13:23:58 <Twey> ByteStrings are for bytes (binary data)
13:24:06 <shirt> yeah, i need ByteString here
13:24:09 <Twey> Ah, that is a byte.  Okay.
13:24:20 <Twey> Yeah, that's probably the best way
13:24:57 <shirt> ok thanks :)
13:25:20 <rahul> Saizan: Okay.
13:26:02 <rahul> MatrixFrog: That's weird. :( I am a Scala programmer and have been recently looking at Haskell. Scala does have a Monoid instance for Int.
13:26:32 <rahul> (Sum is the default. Product one comes as a wrapper.)
13:27:23 <aristid> rahul: haskell only provides both Sum and Product as wrappers, not native. but then, for all Num, not just Int.
13:27:55 <dafis> shirt: if you're appending *one* element to a list, that's fine, it becomes baad if you do it repeatedly
13:28:13 <dafis> s/baad/bad/
13:29:22 <aristid> :t BL.snoc
13:29:23 <lambdabot> Couldn't find qualified module.
13:29:29 <aristid> @hoogle snoc
13:29:29 <lambdabot> Data.ByteString snoc :: ByteString -> Word8 -> ByteString
13:29:30 <lambdabot> Data.ByteString.Char8 snoc :: ByteString -> Char -> ByteString
13:29:30 <lambdabot> Data.ByteString.Lazy snoc :: ByteString -> Word8 -> ByteString
13:29:45 <aristid> shirt: why not use Data.ByteString.Lazy.snoc?
13:30:17 <ddarius> class Monoid m where one :: m; (*) :: m -> m -> m; class CommutativeMonoid m where zero :: m; (+) :: m -> m -> m; instance Monoid Int where one = 1; (*) = (Prelude.*); instance CommutativeMonoid Int where zero = 0; (+) = (Prelude.+)
13:30:26 <rahul> aristid: Okay. I am adding Monoid instances for all Nums (unwrapped). Is there any harm in doing that?
13:30:39 <MatrixFrog> aristid: is there any reason rahul can't use Sum as the default, for his particular program?
13:30:42 <ddarius> rahul: It won't work.
13:30:42 <aristid> rahul: yes. it's an orphan instance. don't do that.
13:30:54 <aristid> well that too
13:31:00 <MatrixFrog> (sorry didn't notice you were already talking about that idea...)
13:31:22 <rahul> aristid: Orphan instance means?
13:31:33 <MatrixFrog> wouldn't orphan instances be bad for a library, but maybe kinda ok for a program?
13:31:39 <aristid> rahul: it means the instance is not where the type is
13:31:42 <MatrixFrog> @where orphan instance
13:31:42 <lambdabot> I know nothing about orphan.
13:31:53 <MatrixFrog> @help
13:31:53 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:31:55 <MatrixFrog> @list
13:31:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:32:21 <MatrixFrog> @url orphan instances
13:32:21 <lambdabot> I know nothing about orphan.
13:32:30 <MatrixFrog> http://www.haskell.org/haskellwiki/Orphan_instance
13:33:04 <MatrixFrog> basically, if type T is an instance of typeclass C, that fact should be declared either where T is defined, or where C is defined
13:33:06 <Kaidelong> is there an IO action for immediate, normal termination?
13:33:10 <MatrixFrog> if not, it's an orphan instance
13:33:15 <aristid> @hoogle exit
13:33:15 <lambdabot> module System.Exit
13:33:15 <lambdabot> System.Exit data ExitCode
13:33:16 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
13:33:41 <rahul> Okay. Time for bed now. :)  Thanks for the help. I appreciate it a lot.
13:33:57 <MatrixFrog> hehe ok. night then
13:36:55 <antilect> http://i.imgur.com/Cn8JF.gif
13:37:08 <antilect> list
13:37:13 <antilect> lambdabot, list
13:37:18 <Kaidelong> *** Exception: ExitSuccess
13:37:20 <Kaidelong> this is fine, right?
13:37:51 <lucca> http://hackage.haskell.org/package/haddock's reported build failure seems to be that same problem; someone trying to build xhtml without trusted base.  Fixing that it has some alex type problem in Lex.x...
13:38:02 <Guest14229> map2Tree (+) (Branch 1 Tip (Branch 2 Tip Tip)) (Branch 3 Tip Tip) --  should return (Branch 4 Tip Tip)
13:38:18 <Guest14229> map2Tree :: (a -> b -> c) -> Tree a -> Tree b -> Tree c
13:38:24 <Guest14229> map2Tree f = foldTree Tip (\x t1 t2 y t3 t4 -> f x y (t1 t3) (t2 t3))
13:38:45 <Guest14229> Any idea on how I can get this to work?
13:39:31 <Botje> depends -- what is the question?
13:39:48 <hpaste_> newbie pasted “map2Tree” at http://hpaste.org/52051
13:40:08 <Guest14229> http://hpaste.org/52051
13:40:38 <Guest14229> I'm trying to see how I have 2 trees in my lambda function
13:41:04 <Cale> Guest14229: So, I guess you need to turn the first tree into a function which eats a second tree.
13:41:47 <Guest14229> I need to implement map2Tree using foldTree
13:41:48 <Botje> you might want to look at zip is expressed using foldr
13:41:48 <Cale> foldTree :: b -> (a -> b -> b -> b) -> Tree a -> b
13:42:04 <Cale> So if you want to get something of type  Tree a -> Tree b -> Tree c
13:42:22 <Cale> then you'll need b in the type of foldTree to be replaced by Tree b -> Tree c
13:47:47 <hpaste_> Cale annotated “map2Tree” with “map2Tree (annotation)” at http://hpaste.org/52051#a52052
13:47:52 <Cale> Guest14229: ^^
13:48:19 <Cale> Guest14229: It's not terribly elegant, but as you can see, it can be done :)
13:48:46 <Guest14229> hmm..thanks
13:48:52 <Rc43> Hi.
13:49:05 <Rc43> How can I map list with an IO action?
13:49:17 <Cale> Rc43: mapM perhaps?
13:49:23 <Cale> Rc43: I'm not sure exactly what you mean
13:49:33 <Cale> Rc43: can you describe what you're trying to do?
13:49:36 <hpaste_> newbie annotated “map2Tree” with “map2Tree (annotation)” at http://hpaste.org/52051#a52053
13:49:41 <Rc43> It seems it is good.
13:56:56 <hpaste_> 007 pasted “intersperse” at http://hpaste.org/52054
13:57:52 <dfsda> Hi i'm trying to write intersperse using foldr but I keep getting an extra element at the end of the list
13:57:53 <dfsda> how can i remove it?
13:57:56 <dfsda> http://hpaste.org/52054
13:58:01 <Rmx> import qualified Data.Trie as T  =>  Could not find module `Data.Trie':
13:58:01 <Rmx> ghc-pkg check return no error with bytestring-trie, and ghc-pkg list show me bytestring-trie-0.2.3 in the list
13:58:16 <dfsda> I tried to use init but it gives me an error
13:58:22 <RaptorRarr> > let intersperse i = foldr(\x xs -> x : i : xs) [] in intersperse 'z' "zomg"
13:58:22 <Rmx> what should I do?
13:58:23 <lambdabot>   "zzozmzgz"
13:58:45 <RaptorRarr> > let intersperse (x:xs) = foldr(\x xs -> x : i : xs) [x] xs in intersperse 'z' "zomg"
13:58:46 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
13:58:46 <lambdabot>         against inferre...
13:59:04 <RaptorRarr> > let intersperse i (x:xs) = foldr (\y ys -> y : i : ys) [x] xs in intersperse 'z' "zomg"
13:59:05 <lambdabot>   "ozmzgzz"
13:59:13 <RaptorRarr> > let intersperse i (x:xs) = foldr (\y ys -> i : y : ys) [x] xs in intersperse 'z' "zomg"
13:59:15 <lambdabot>   "zozmzgz"
13:59:30 <RaptorRarr> No idea. Something like that, though.
13:59:32 <Cale> let intersperse i = foldr(\x xs -> case xs of [] -> [x]; _ -> x : i : xs) [] in intersperse ' ' "zomg"
13:59:36 <Cale> > let intersperse i = foldr(\x xs -> case xs of [] -> [x]; _ -> x : i : xs) [] in intersperse ' ' "zomg"
13:59:37 <lambdabot>   "z o m g"
13:59:41 <RaptorRarr> Yay!
13:59:55 <dfsda> Yaay!
14:01:17 <shirt> aristid: because i already have a list of ByteString. my intuition tells me that concatting n+1 ByteString together is faster then concatting n ByteString together and then applying snoc
14:01:18 <Twey> I'm finding the FFI literature a bit impenetrable.  Can anybody link me to a good introduction to creating foreign bindings to libraries in Haskell, with the current tools?
14:01:33 <shirt> aristid: oh wait, you are talking about lazy snoc.... hm.....
14:04:02 <MatrixFrog> Twey, i think rwh has some good stuff on that
14:05:11 <MatrixFrog> instead of "instance Monad ((->) r) where" could you write "instance Monad (r ->) where" and have it mean the same thing?
14:07:33 <Rmx> all my dependencies bug
14:08:05 <Rmx> most of packages seems to be invisible for ghc
14:08:16 <RaptorRarr> @kind ((->) r)
14:08:17 <lambdabot> Not in scope: type variable `r'
14:08:22 <RaptorRarr> @kind ((->) Int)
14:08:23 <lambdabot> ? -> *
14:08:25 <Rmx> despite the fact they're shown in ghc-pkg list
14:08:29 <RaptorRarr> @kind (Int ->)
14:08:30 <lambdabot> parse error on input `)'
14:08:35 <Rmx> and not broken by ghc-pkg check
14:08:39 <Rmx> what's wrong
14:08:46 <Rmx> I'm under windows..
14:08:48 <MatrixFrog> so i guess the answer to my question is no
14:08:54 <Rmx> help please, I'm getting mad
14:09:01 <Saizan> Rmx: how are you building this?
14:10:41 <Rmx> with ghci
14:10:51 <Rmx> I can't even load my code
14:11:17 <Rmx> it Could not find module `...
14:11:23 <Rmx> for most of my modules
14:11:27 <Rmx> it's just impossible
14:11:32 <Rmx> so I just reinstall them
14:11:36 <Rmx> check everything is fine
14:12:07 <Rmx> but everything is illogical when I try
14:12:10 <Saizan> run ghci with the -v flag and paste a log of what's happening
14:12:17 <Saizan> on hpaste.org
14:12:21 <Rmx> thanks
14:12:46 <Saizan> btw, paste the messages ghci will print when starting up too
14:14:40 <Twey> MatrixFrog: Only with InfixTypeOperators (IIRC)
14:14:53 <Twey> Errr
14:14:57 <Twey> No, that's not the right extension
14:15:04 <Twey> TypeOperatorSections?
14:15:11 <Saizan> we have that?
14:15:13 <MatrixFrog> ok that makes sense
14:16:40 <Twey> I'm pretty sure there's an extension
14:16:46 <Twey> Damned if I can remember the name
14:17:37 --- mode: zelazny.freenode.net set +o Igloo
14:19:45 <Saizan> maybe it's included in TypeOperators
14:20:49 <Rmx> anyway, thanks for proposing your help, I'll fist sleep some hours, and start from a clean installation
14:20:50 <Rmx> bye
14:44:44 <eyebloom> Would anyone be able to explain why f and g won't compile in this toy example: http://codepad.org/5BUWs03u
14:45:12 <eyebloom> better this one: http://codepad.org/dCrXroDO
14:45:29 <RaptorRarr> f (Arguments a b c) =
14:45:36 <RaptorRarr> Should fix it
14:45:45 <RaptorRarr> Or x y z rather
14:46:30 <RaptorRarr> f (Arguments x y z) = ReturnVal x y z
14:46:39 <eyebloom> Says undefined data constructor
14:46:45 <eyebloom> http://codepad.org/jn1L56Be
14:47:01 <RaptorRarr> Hmm, misread, sorry.
14:47:26 <RaptorRarr> You need to have f (somefunctionherekthx) = whatsit
14:47:55 <eyebloom> Basically I'm trying to define a generic function type and then tack a few arguments infront of the generic type.
14:48:42 <RaptorRarr> The type of f is (a -> b -> c) -> (a, b, c)
14:49:14 <RaptorRarr> There should be no instance of that except const (bottom, bottom, bottom)
14:49:42 <eyebloom> Is there a way to define Arguments so that it doesn't end up wrapped in parenthesis like  that.
14:49:53 <hpc> eyebloom: no
14:50:17 <hpc> eyebloom: it isn't good style anyway; it hides the 'real type' of the function
14:50:25 <RaptorRarr> I guess const bottom works, too.
14:50:55 <RaptorRarr> > let bottom = bottom in bottom
14:50:59 <lambdabot>   mueval-core: Time limit exceeded
14:51:04 <eyebloom> Ok well, my basic goal is to define a type of function.
14:51:16 <RaptorRarr> Why not just do a -> b -> c as the type?
14:52:24 <Eduard_Munteanu> *The* type of functions?
14:53:05 <RaptorRarr> Eduard_Munteanu: a -> b?
14:53:46 <Eduard_Munteanu> Yeah, given a suitable interpretation.
14:54:30 <fazzone> Is  \as b -> map (const b) as   always, sometimes, or never better than   \as b -> replicate (length as) b   ?
14:55:13 <eyebloom> Here is something more like what I was thinking: http://codepad.org/XOcRkrbr
14:55:15 <hpc> > [1,2,3] <$ 5
14:55:16 <lambdabot>   No instance for (GHC.Show.Show (f [t]))
14:55:16 <lambdabot>    arising from a use of `M19288240...
14:55:25 <eyebloom> In case your curious.
14:55:26 <hpc> > 5 $> [1,2,3]
14:55:27 <lambdabot>   Not in scope: `$>'
14:55:31 <hpc> bah
14:56:16 <lucca> > 5 <$ [1,2,3]
14:56:17 <lambdabot>   [5,5,5]
14:56:27 <hpc> yeah, that
14:57:22 <fazzone> Where does $> come from?
14:57:43 <fazzone> * <$
14:57:59 <Kaidelong> should be from Control.Applicative
14:58:11 <Kaidelong> which I think is part of base, although it might not be
14:58:16 <hpc> it is
14:58:25 <lucca> <3 Control.Applicative
14:58:39 <hpc> @quote golf.*applicative
14:58:39 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
14:59:16 <hpc> someone said a while back, if the first three lines of your golfing program aren't "import Control.Applicative; import Control.Monad; import Control.Arrow", you are doing something wrong
15:00:29 <hpaste_> dontKnowTrig pasted “Fractal Tree” at http://hpaste.org/52057
15:00:57 <hollaAt> Can someone give me a quick trig lesson?
15:01:24 <hollaAt> I can't figure out how to calculate the data points to draw a fractal tree http://hpaste.org/52057
15:02:18 <drdo> Is there something i can read about the implementation of ghc's (or something similar) parallel runtime system?
15:04:51 <martinOB> hello
15:06:52 <martinOB> I'm trying to run the examples for Conal Elliott's TV library but I get some error messages. can anyone help? :)
15:07:03 <kate_r> hi
15:07:16 <martinOB> hi kate_r
15:07:30 <hollaAt> hi :)
15:08:30 <kate_r> if i have a function foo of type a => b => c and bar of type a, is "foo bar" an *eta-contraction* of "\lambda x. foo bar x"?
15:09:35 <hollaAt>  I can't figure out how to calculate the data points to draw a fractal tree http://hpaste.org/52057
15:09:36 <byorgey> kate_r: yes
15:09:40 <RaptorRarr> I don't know what an eta-contraction is, but those are equivalent.
15:10:17 <Eduard_Munteanu> One way through eta reduction I suppose.
15:11:17 <kate_r> thanks
15:11:41 <Eduard_Munteanu> s/reduction/conversion/
15:12:04 <byorgey> hollaAt: I'm sorry to hear that. Do you have a specific question to ask about it?
15:12:36 <Eduard_Munteanu> hollaAt: do you have any specific trigonometry questions? I'm unsure about the fractal parts.
15:13:10 <hollaAt> Yes, so i'm trying to draw a series of lines that represent branches
15:13:29 <byorgey> hollaAt: what library are you using?
15:13:37 <Eduard_Munteanu> Straight lines?
15:13:48 <byorgey> is it gloss?
15:13:56 <hollaAt> yes i'm using gloss
15:14:02 <hollaAt> yes they are straight lines
15:14:29 <hollaAt> i'm given the starting x,y coordinates an angle and the delta and I have the sizes of each branch
15:15:01 <hollaAt> i'm having trouble using those inputs to calculate the line coordinates
15:15:36 <byorgey> hollaAt: is this homework or just for fun?
15:15:51 <hollaAt> just for fun...trying to learn how to use gloss
15:16:00 <eatnumber1> how can I curry the pair constructor?
15:16:28 <RaptorRarr> @type (,) 5
15:16:29 <lambdabot> forall t b. (Num t) => b -> (t, b)
15:16:35 <hollaAt> i have some examples on drawing circles, was trying to see if i can do something with trees
15:17:09 <Eduard_Munteanu> hollaAt: so 'fractal' should give you a line segment starting at (x, y) with 'delta' as length and 'angle' as the slope?
15:17:27 <hollaAt> yes
15:17:28 <eatnumber1> RaptorRarr: great, thanks
15:17:38 <RaptorRarr> eatnumber1: No problem.
15:17:43 <hollaAt> a line goes from (x1,x2) to (x3,x4)
15:18:21 <RaptorRarr> otherEndpoint angle (x, y) = (..., ...)?
15:18:26 <hollaAt> delta is actually not the length...delta is the rotation
15:18:31 <RaptorRarr> Ahh, length too.
15:19:26 <Eduard_Munteanu> hollaAt: what's the difference between delta and angle?
15:19:47 <Eduard_Munteanu> Wait, is this 2D or 3D?
15:19:54 <hollaAt> 2d
15:20:53 <hollaAt> delta is the direction that its drawn in and the angle is the how far wide the branches are
15:21:20 <hollaAt> ie delta is -<  vs >- (the direction of the tree)
15:22:11 <Eduard_Munteanu> hollaAt: oh, so fractal always draws two lines which also branch and so on
15:22:29 <hollaAt> yah
15:23:26 <hollaAt> http://davis.wpi.edu/~matt/courses/fractals/trees.gif
15:26:35 <Eduard_Munteanu> hollaAt: how does r + x make sense there?
15:26:36 <incluye> @pl \a -> 1/a
15:26:36 <lambdabot> (1 /)
15:26:38 <incluye> er, duh
15:26:57 <Eduard_Munteanu> fractal delta angle x y (Branch r t1 t2) = ...
15:27:16 <hollaAt> it doesn't...i was trying to play around with different things
15:27:24 <hollaAt> but couldn't get the math to work
15:28:32 <Eduard_Munteanu> hollaAt: I think you need to keep track of the slope when you branch
15:29:32 <hollaAt> hmm..ok
15:29:57 <Eduard_Munteanu> hollaAt: say you start at 0, and branch 30 degs apart. Then when you go on the left or right branch, you have to branch with respect to the previous slope.
15:31:57 <Eduard_Munteanu> You also seem to ignore delta.
15:33:36 <Luke> when I upgrade to a later version ghc, does it keep both versions of ghc's packages with cabal?
15:34:05 <Luke> is there a way to prune that out?
15:34:55 <hollaAt> I wasn't sure how to take it into account in the formula
15:35:58 <hpaste_> ulidtko pasted “cabal install failure” at http://hpaste.org/52058
15:36:06 <ulidtko> hey
15:36:15 <ulidtko> could anybody help with the issue?
15:38:26 <Eduard_Munteanu> ulidtko: did you try to 'cabal update'?
15:38:32 <ulidtko> yeah, i did
15:38:33 <Saizan> ulidtko: cabal install happy and make sure ~/.cabal/bin is in your $PATH
15:38:59 * Eduard_Munteanu wonders if LD_LIBRARY_PATH needs to be set as well
15:39:15 <Saizan> happy is not even a library
15:39:39 <Saizan> or at least cabal is searching for teh executable there
15:39:56 <Eduard_Munteanu> Ah.
15:42:26 <ulidtko> it seems that worked
15:42:32 <ulidtko> thank you guys
15:44:36 <amtal> Hey cool, if all your functions have 1 argument which is an N-tuple where N is the number of arguments they should have... Your Haskell code looks sorta like C!
15:44:52 <amtal> I'm totally going to try and use that to sell Haskell to someone. "Hey, doesn't this look familiar?"
15:45:17 <ststephen> amtal: when i first started with haskell, i wrote every function like that
15:46:52 <Axman6> but all functions already have only one argument
15:47:56 <amtal> I kind of realize that intellectually, but definitely don't think of foo as a function that returns a function that returns a function usually. Unless I'm doing stuff with partial application.
15:48:54 <Saizan> the compiler doesn't either, fortunately
15:48:56 <ststephen> the only time i actually think of it that way is when i define a function as some kind of fold of another function or something
15:49:30 <Saizan> still there's no reason to use parentheses and commas to group arguments :)
15:52:44 <ddarius> amtal: If you go crazy enough, you can make your Haskell code look almost exactly like C.
15:52:58 <monochrom> compiler turning "f x y = True" into a 2-ary function is a pretty standard shortcut. IIRC SPJ's books on implementing functional languages cover it
15:54:08 <monochrom> looking like C is crazier than looking like BASIC!
15:56:47 <RaptorRarr> Looking like you're BASIC is crazier than looking like you're crazy.
15:56:55 <monochrom> haha
15:59:29 <ddarius> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
16:02:03 <amtal> There was that BASIC EDSL that compiled to LLVM.
16:02:09 <amtal> It was a nice blog post.
16:13:37 <Veinor> man i hope tracebacks get implemented soon
16:16:25 <napping> what does GHC.Show.showMultiLineString do?
16:16:26 <lambdabot> napping: You have 1 new message. '/msg lambdabot @messages' to read it.
16:17:03 <napping> it's used in template-haskell-2.6.0.0
16:17:08 <napping> which I'd like to build under 6.12
16:17:20 <napping> rather, I'd like to build aeson under 6.12
16:19:05 <gienah> napping: you could build aeson-0.3.2.11 under ghc 6.12, that was the last release before the ghc dependency was bumped
16:19:39 <napping> if the dependency was bumped, shouldn't cabal install have complained?
16:20:19 <gienah> napping: I don't know, as I don't use cabal install
16:20:36 <napping> what do you use?
16:20:46 <gienah> napping: there were lots of changes going from 0.3.2.11 -> 0.3.2.12 : http://hdiff.luite.com/cgit/aeson/commit/?id=17e962339742377750a0c083ba14d7b18e63824d
16:20:57 <gienah> napping: I build it on gentoo with an ebuild
16:26:09 <napping> is it even meant to be possible to upgrade template-haskell?
16:26:15 <gienah> napping: I see from the 0.3.2.12 aeson.cabal file that the ghc dependency was only indirectly bumped by bumping the template-haskell dependency
16:26:35 <gienah> napping: my guess is no it would not be possible to bump template-haskell in ghc 6.12
16:26:35 <napping> and the template-haskell dependency is incorrect
16:27:58 <gienah> napping: I'm not sure I haven't tried loosending the template-haskell dependency in aeson 0.3.2.12 and trying to build it with ghc 6.12
16:28:29 * gienah tries doing that
16:28:41 <napping> I'm trying to set things up to build on a cluster with just 6.12.3
16:28:56 * napping prepares a bug report for template-haskell dependencies
16:30:08 <Saizan> napping: it's not meant to be possible to upgrade template-haskell
16:31:02 <napping> why does cabal-install try?
16:31:35 <Saizan> because it's not really informed of this
16:32:16 <napping> ah, it also tries to install base
16:32:19 <napping> if I ask
16:36:01 <napping> If template-haskell is supposed to ship with ghc, shouldn't it have an exact dependences on the corresponding base?
16:37:26 <gienah> napping: that was easy, aeson 0.3.2.12 just builds with ghc 6.12.3 after sed -e 's@template-haskell >= 2.5@template-haskell >= 2.4@' -i aeson.cabal
16:38:09 <napping> why does it depend on template-haskell?
16:38:23 <gienah> napping: because it uses template-haskell
16:38:31 <napping> I don't see that listed
16:39:08 <gienah> napping: its there, just search for template-haskell in: http://hackage.haskell.org/packages/archive/aeson/0.3.2.12/aeson.cabal
16:39:36 <napping> http://hackage.haskell.org/packages/archive/aeson/0.3.2.10/aeson.cabal
16:39:39 <napping> I don't see it
16:40:02 <Saizan> different versions
16:41:08 <napping> ah. Well, 0.3.2.11 seems to work
16:42:04 <gienah> napping: yes 0.3.2.11 should just work with ghc 6.12.3, and aeson 0.3.2.12 at least seems to compile with ghc 6.12.3 after the above sed
16:42:42 <napping> well, it's probably easier to distribute the example code with a version that will build more cleanly
16:43:21 <napping> good to know the other will compile. I guess it just wasn't tested with the older GHC
16:45:27 <aristid> heh http://augustss.blogspot.com/2009/02/regression-they-say-that-as-you-get.html
16:47:15 <napping> "Let's do a simple benchmark comparing Haskell to C."
16:47:30 <napping> (next post)
16:51:31 <napping> Saizan: is it explained somewhere that it shouldn't be upgraded?
16:52:24 <Saizan> napping: not sure
16:54:37 <dankna> @hoogle foldM
16:54:37 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:54:37 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
16:54:38 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
16:55:44 <Nisstyre> @hoogle fmap
16:55:45 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
16:55:45 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
16:55:45 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
16:55:50 <Nisstyre> cool
17:45:08 <JoeyA> I need a fixpoint combinator in real life.
17:45:28 <JoeyA> I'm creating an issue in Redmine, and want to refer to the issue number in a git commit message.
17:45:32 <hydo> man wouldn't that be nice.
17:45:45 <JoeyA> But I also want to refer to the commit in the issue.
17:46:52 <shachaf> JoeyA: Presumably issues can be annotated later?
17:46:57 <JoeyA> Yup
17:47:03 <JoeyA> That's what I'll do.
17:47:06 <shachaf> Mutation!
17:47:08 <JoeyA> That's what fixpoint combinators do.
17:47:14 <shachaf> It's the cure to all your troubles.
17:47:18 <JoeyA> Laziness under the hood.
17:47:26 <JoeyA> Err, laziness uses mutation under the hood.
17:47:51 <shachaf> You don't need laziness for a fixed-point combinator.
17:52:19 <RaptorRarr> Therefore, lazy people are actually mutants.
17:55:43 <mm_freak> interestingly i find value recursion (aka 'mfix' and 'loop') much more useful than structural recursion in practice
18:00:24 <kmc> that's how mfix for IO works
18:00:45 <kmc> @src fixIO
18:00:45 <lambdabot> Source not found. My brain just exploded
18:01:57 <kmc> fixIO k = do { ref <- newIORef (throw NonTermination); ans <- unsafeInterleaveIO (readIORef ref); result <- k ans; writeIORef ref result; return result }
18:02:49 <kmc> JoeyA, you have a funny definition of "real life" ;)
18:02:58 <JoeyA> lol
18:03:17 <kmc> any particularly cool examples of using fixIO?
18:03:34 <MatrixFrog> @tell bonus typo in "for a few monads more": "So let'use throw out our floating points and use Rational for our probabilities:"
18:03:35 <lambdabot> Consider it noted.
18:05:32 <mm_freak> kmc: i've seen a cool, but probably not very useful example here:  a thread, which kills itself
18:05:51 <mm_freak> rec thrId <- forkIO (killThread thrId)
18:06:23 <kmc> heh
18:06:36 <kmc> that's not too hard to arrange without fixIO, though
18:06:39 <MatrixFrog> like the "machine that turns itself off"
18:06:43 <kmc> hehe
18:06:49 * MatrixFrog runs off to google-land to try and find that video
18:07:29 <napping> not too hard, if you don't mind adding more state
18:07:59 <MatrixFrog> http://www.youtube.com/watch?v=ul9jqqVzMWk
18:08:18 <MatrixFrog> plus there are many others if you look at the related videos, including one in lego
18:15:10 * hackagebot cabal-ghci 0.2.0 - Set up ghci with options taken from a .cabal file  http://hackage.haskell.org/package/cabal-ghci-0.2.0 (EtienneLaurin)
18:35:10 * hackagebot pec 0.1.1 - pec embedded compiler  http://hackage.haskell.org/package/pec-0.1.1 (BrettLetner)
18:41:15 <mm_freak> kmc: i find much more uses for 'loop' than for 'mfix'
18:41:26 <mm_freak> though mostly they use 'mfix' under the hood
18:41:30 <Kaidelong> @hoogle loop
18:41:31 <lambdabot> Control.Arrow loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
18:41:31 <lambdabot> Data.Graph.Inductive.Example loop :: Gr Char ()
18:41:31 <lambdabot> Data.Graph.Inductive.Example loop' :: IO (SGr Char ())
18:41:52 <Kaidelong> how would that even work
18:42:10 <Kaidelong> well
18:42:11 <mm_freak> Kaidelong: think in arrow notation
18:42:21 <mm_freak> rec x <- someArrow -< x
18:42:32 <mm_freak> returnA -< x
18:43:57 <mm_freak> for example in a simple FRP implementation you could have a point, whose current position is its current acceleration, such that it runs away from the origin in an increasing speed
18:44:33 <mm_freak> rec { v <- integral -< x; x <- integral -< v }; returnA -< x
18:45:18 <RaptorRarr> @type (-<)
18:45:19 <lambdabot> Not in scope: `-<'
18:45:34 <mm_freak> RaptorRarr: that's arrow notation, -XArrows
18:46:03 <RaptorRarr> I just noticed the nifty a <- b -< c picturesque arrowness of it all.
18:48:22 <amtal> Does anyone know where wolfgang alpha is hosted nowadays?
18:48:27 <kmc> a ← b ⤙ c
18:49:40 <MatrixFrog> *wolfram alpha
18:49:46 <MatrixFrog> unless that's some other thing i don't know about :)
18:49:58 <RaptorRarr> amtal: wolframalpha.com?
18:50:58 <RaptorRarr> Wolves with RAM do better for computation than wolf gangs of old-style calculating professionals.
18:51:01 <mm_freak> rival company…  bertram beta
18:52:11 <mm_freak> we've also got edeltraut eta and sieglinde sigma
18:52:22 <llano> can i use keyword `newtype` refering to a nonexisting type, like, newtype PC = screen -> Int -> [screen]
18:52:39 <mm_freak> llano: newtype defines a new type
18:53:02 <mm_freak> llano: but you can write type aliases for existing types:  type PC screen = screen -> Int -> [screen]
18:53:09 <MatrixFrog> llano: types need to be capitalized. Screen, not screen
18:53:27 <napping> or it's a type varible
18:53:29 <mm_freak> probably 'screen' is indeed meant as a type variable
18:53:35 <llano> mm_freak: even screen is not defined?
18:53:48 <napping> newtype PC screen = PC (screen -> Int -> [screen]) would be allowed
18:53:53 <RaptorRarr> Do arrows use -< before their arguments rather than nothing, like monads, essentially to make it type check?
18:53:54 <mm_freak> llano: if a type you use is not defined, you get an error =)
18:53:55 <MatrixFrog> right, didn't see that. usually in examples i've seen, type params are one letter. but obviously they don't have to be
18:53:59 <napping> you need to mention parameters on the left of the definition, and put a constructor on the rightr
18:54:03 <mm_freak> llano: you mean 'screen' to be a type variable?
18:54:13 <llano> yes
18:54:19 <llano> type variable
18:54:37 <mm_freak> llano: you probably want 'type' for type aliases instead of 'newtype' for new types
18:54:52 <RaptorRarr> Or is it to let the parser know it's arrows not monads?
18:55:24 <napping> RaptorRarr: an arrow is not a function. The -< bit is where you provide an a to an arr a b
18:55:25 <mm_freak> RaptorRarr: the full arrow notation goes like this:  proc x -> someArrow -< someInputToSomeArrow
18:56:05 <mm_freak> the -< construct lets you specify the input to the arrow on the LHS
18:56:48 <mm_freak> there is also a do-notation for arrows, which goes like this:  proc x -> do result1 <- arrow1 -< input1; result2 <- arrow2 -< input2; arrow3 -< input3
18:57:56 <mm_freak> all this is compiled to the usual arrow combinators
18:57:56 <RaptorRarr> Yeah, that's the one I meant.
18:58:00 <llano> mm_freak: i just want to use a generic fun as a parameter, and this func contains a type variable as a parameter. And i don't know how define this func's signature.
18:58:03 <mm_freak> it has nothing to do with monads
18:58:24 <napping> I think the parser uses the "proc" to tell that it's an arrow "do" block
18:59:53 <mm_freak> the parser uses 'proc' to tell that you are writing an arrow computation…  by using 'do' you can compose multiple such arrow computations and give the intermediary results names
19:00:18 <mm_freak> llano: depends on what the function should do
19:00:57 <mm_freak> llano: in haskell there is a very strong relation between a function's type and its purpose
19:03:05 <RaptorRarr> @type (>>=)
19:03:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:03:10 <llano> mm_freak: yes, i hope this func can be used to deal with Int, but also String, for instance: a -> String.But when i used newtype to define this, the compiler told me "not in scope, a type variable"
19:03:31 <mm_freak> llano: what should the function do?
19:03:44 <mm_freak> for example a function of type a -> String makes little sense
19:04:07 <RaptorRarr> const "zomg" is a very important function.
19:04:41 <mm_freak> RaptorRarr: ever gave that function a name?
19:05:08 <MatrixFrog> constZomg
19:05:10 <napping> type variables are only implicitly scoped in type signatures
19:05:10 <MatrixFrog> obviously
19:05:11 <llano> mm_freak: ok, perhaps i need make my question more clear. Let me think for a while.
19:05:38 <napping> In a definition (data,type,newtype) they need to be arguments on the left side of the =
19:06:27 <mm_freak> llano: "how can i make this typecheck?" is the wrong question to ask…  remember that types are the specification of your program
19:06:27 <monochrom> "do" is just a reserved word. it is chosen for the arrow notation because reserving "proc" is already bad enough, i.e., no one wants more reserved words
19:07:13 <donri> we're quite reserved about that
19:07:37 <mm_freak> monochrom: 'do' is a particularly sadly chosen word IMO
19:08:00 <mm_freak> according to the GHC manual 'proc' stands for 'procedure', which is even worse
19:08:31 <amtal> Wolfgang alpha was a badass Haskell+web browser clone of wolfram mathematica notebooks.
19:08:40 <MatrixFrog> mm_freak: true, but what would have been a better word?
19:08:46 <amtal> The main site appears to have gone down and I don't think source was ever released, just curious if I'm wrong.
19:08:56 <mm_freak> MatrixFrog: i'd be totally happy with 'arrow'
19:09:02 <mm_freak> or perhaps 'pass'
19:09:06 <MatrixFrog> mmmk
19:11:28 <mm_freak> but more pratically it would be great if the arrow notation's (| |) syntax allowed $ instead of parentheses
19:12:55 <mm_freak> (| event $ … |) instead of (| event (…) |), not because it looks nicer, but because emacs' haskell-mode would be better at indenting this properly for me
19:13:24 <MatrixFrog> sounds like it belongs at http://www.reddit.com/r/fossworldproblems :)
19:18:41 <RaptorRarr> amtal: Oh, wow.
19:21:43 <amtal> Yeah :D
19:21:57 <amtal> I think it's by the same guy as Haskell for Children.
19:24:06 <Veinor> hmm
19:24:31 <Veinor> if i'm in, say, the IO monad, is there a shorthand way to say 'when this condition is true, do X and 'return' immediately'
19:24:57 <Veinor> basically like guard but that does something
19:25:02 <napping> 'return'?
19:25:03 <shachaf> Veinor: "return"?
19:25:46 <shachaf> You want something like the C-style foo(x) { if (x == 0) return Nothing; ... }?
19:25:54 <mm_freak> Veinor: "returning" makes little sense, but if what you're looking for is shortcutting, you probably want to have a look at ContT
19:25:57 <Veinor> basically
19:26:05 <shachaf> mm_freak: ContT is such a mess. :-(
19:26:13 <mm_freak> shachaf: huh?  why?
19:26:19 <RaptorRarr> @type when
19:26:21 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:26:24 <shachaf> You have to liftIO everything, for instance.
19:26:27 <shachaf> mm_freak: EitherT would probably do just as well, by the way.
19:26:42 <RaptorRarr> @type unless
19:26:43 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:26:45 <mm_freak> true, in some cases EitherT or MaybeT would also help
19:26:56 <mm_freak> but i like how you can use 'forever' and 'abort' inside of ContT
19:27:23 <shachaf> I wonder if the standard library should have a separate type for the monad Either x x.
19:28:06 <Veinor> oh, i could always write my own, something like guardMsg True = const (return ()); guardMsg False x = x >> const mzero
19:28:07 <shachaf> What do forever and abort do for ContT?
19:28:31 <mm_freak> shachaf: 'forever' does what its name states
19:28:46 <mm_freak> and abort ignores the current continuation, i.e. aborts the whole ContT computation
19:28:59 <mm_freak> :t abort
19:28:59 <lambdabot> Not in scope: `abort'
19:29:08 <mm_freak> :t ContT . const . return
19:29:08 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => a1 -> ContT a1 m a
19:29:55 <shachaf> Veinor: Oh, what you want isn't what I thought, then.
19:30:07 <shachaf> Veinor: That'll throw an exception, which is presumably different from "returning".
19:30:51 <Veinor> what i'm actually doing is, i'm writing a snap handler and i want to say 'if the values given don't satisfy this predicate, abort early and show the user an error'
19:31:03 <napping> oh, snap has a thing like that
19:31:13 <Veinor> called?
19:31:14 <mm_freak> Veinor: use snap's builtin facilities for that
19:45:13 <Luke> I'm trying to use emacs haskell-mode's inferior-haskell-load-file but whenever I call it, emacs hangs. anyone know how to fix this problem?
19:47:29 <vicapow> Hello!
19:47:57 <kmc> hi vicapow
19:48:24 <vicapow> I'm trying Haskell at tryhaskell.org
19:49:24 <NemesisD> anyone here reasonably experienced with the enumerator library
19:51:01 <mm_freak> NemesisD: just ask
19:51:05 <JoeyA> Looks like I will be in a few days.  I'll have to use the iteratee interface of http-enumerator so I can cap download size.
19:51:20 <Cale> vicapow: hello!
19:51:33 <Cale> vicapow: Feel free to ask any questions you might have :)
19:51:33 <NemesisD> ok so i'm designing something that paginates a web resource. the api call it makes may have a link in it to the next page
19:51:58 <vicapow> Cale: will do! Thank you
19:52:06 <NemesisD> so i've got: type PaginatedResult = (Maybe Link, Result)
19:53:01 <NemesisD> i'm trying to figure out how to design it such that one of the components receives paginated results, passes them through and then can tell the request enumerator to stop
19:53:33 <mm_freak> NemesisD: are you using WAI?
19:54:01 <NemesisD> mm_freak: no, using aeson and http-enumerator
19:54:16 <mm_freak> i see, well, what's the problem?
19:54:45 <NemesisD> i just don't know how to fit the pieces together so far. i know i'll have an enumerator that produces requests, i don't know what that pagination part should be
19:54:58 <mm_freak> you can't tell the enumerator to stop in the enumerator framework
19:55:05 <mm_freak> but you can just stop asking for more
19:56:40 <NemesisD> i yeah thats what i mean, but the part that is confounding me is this component needs to feed some state back into the enumerator in the form of the link
19:57:06 <mm_freak> there is no way to feed anything back to an enumerator from an iteratee
19:57:23 <mm_freak> you probably want an enumeratee instead of an iteratee
19:58:52 <NemesisD> yeah that's what i've been writing so far, just having a little bit of a tough time figuring out how it will look. all the enumeratees i've written so far have been simple transformations with Data.Enumerator.List
19:59:06 <mm_freak> for example, if your input is a stream of articles (Iteratee Article m b) and you want to paginate that stream (Iteratee [Article] m b), you actually want an Enumeratee Article [Article] m b
20:00:49 <mm_freak> if, instead, your input is a stream of requests, you may have misunderstood the role of the enumerator framework in the http-enumerator library
20:01:46 <NemesisD> http-enumerator just happens to be what i'm using to make  the http requests, i'm going to generate requests and in one of the intermediate steps, execute it and get the bytestring body as a whole
20:02:34 <mm_freak> you want to de-paginate?
20:02:54 <NemesisD> your first assessment is close but its more that the resource on the web is paginated and i want to abstract that, i want to hide from the user that multiple request are being made, it will instead just stream data in chunks, and each chunk just happens ot be a page
20:03:00 <NemesisD> yeah thats a good way to put it
20:04:10 <mm_freak> note that enumerators are for streams, so depagination is as simple as writing an enumerator for it
20:04:27 <mm_freak> there is essentially little difference between reading pages from a web resource and reading bytes from a file
20:05:05 <dalaing> adimit: have you had any time for that iteratee article / tutorial? (or was that someone else?)
20:05:29 <mm_freak> but realize that you will have an enumeration instance, which is completely unrelated to http-enumerator's instance
20:06:33 <NemesisD> mm_freak: yeah. it was just a coincidence that i'm using that. snoyberg puts out some nice code
20:07:49 <NemesisD> so wait this will be one big enumerator then?
20:08:56 <mm_freak> yes
20:10:25 <JoeyA> Why is http (in http-enumerator) of type Iteratee ByteString m a ?  Wouldn't that make it a consumer rather than generator?
20:11:02 <mm_freak> JoeyA: it /is/ a consumer
20:11:12 <mm_freak> it consumes the stream from the server
20:12:53 <JoeyA> mm_freak: Ah, but what "server" is it consuming from, if I'm indicating that information as arguments to http?
20:15:19 <mm_freak> JoeyA: i'm not sure, but it's probably an enumeratee…  it feeds the second argument iteratee the rest of the response body, parsing only the headers
20:15:41 <mm_freak> it's not apparent from the type signature that it works that way
20:16:20 <mm_freak> a truly low level HTTP iteratee would rather have a type like:  Iteratee ByteString m Response
20:16:43 <JoeyA> Thanks
20:30:55 <NemesisD> my brain still isn't wanting to figure out how to loop through pages in this monad
20:31:12 <NemesisD> i'm wondering if control.monad.loops would help
20:34:26 <dmoctezuma> ivan` == ivanm?
20:34:48 <shachaf> Nope.
20:34:51 <shachaf> Also /= ivant
20:35:00 <dmoctezuma> oh :(
20:35:04 <shachaf> However, ivan` == ivan.
20:36:06 <shachaf> NemesisD: What are you trying to do?
20:37:13 <NemesisD> shachaf: i'm writing a depaginator for a web api. it will fetch the resources page by page and make that pagination transparent to the user by chunking the results by page
20:38:01 <NemesisD> the part tripping me right now is maintianing the state of whether or not there is a next page
20:40:14 <NemesisD> i have to keep enumerating results until either the remote resource runs out or the user doesn't want anymore, and whether or not there are any more pages is returned in the response of the current page
20:47:34 <shachaf> Is a separate type isomorphic to (\x -> Either x x) justified?
20:48:20 <c_wraith> (Bool, x)?
20:48:40 <c_wraith> Not the greatest idea either.
20:48:42 <napping> just Bool
20:48:46 <c_wraith> But ignoring bottoms, it's isomorphic
20:48:54 <shachaf> I mean as a monad.
20:49:06 <c_wraith> Oh
20:49:10 <c_wraith> Uh
20:49:13 <c_wraith> I don't think that works
20:49:15 <shachaf> Hmm, maybe it doesn't actually work as well as I'd hoped.
20:49:19 <c_wraith> :t (>>=)
20:49:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:49:26 <shachaf> Right, because a /= b?
20:49:28 <c_wraith> yep
20:49:35 * shachaf hmphs.
20:49:35 <napping> (forall x . x -> Either x x) is approximately Bool
20:49:43 <napping> either Left, Right, or undefined
20:53:41 <shachaf> c_wraith: Well, I suppose it's a monad in the boring way. :-)
20:54:19 <c_wraith> shachaf: the useless way, you mean? :)
20:55:13 <shachaf> c_wraith: Hey, don't be dissin' on Identity.
20:55:27 <shachaf> It's in the top 3 best monads.
20:55:31 <c_wraith> Heh, ok, I guess it is identity.
20:55:45 <shachaf> c_wraith: Identity + a secret Bool!
20:55:50 <shachaf> What more can you ask for?
20:56:09 <c_wraith> you actually have two choices for >>= then
20:56:21 <c_wraith> oh, no you don't.  it has to preserve the secret bool
20:56:22 <shachaf> Oh, true.
20:56:26 <shachaf> Oh. True.
20:56:28 <c_wraith> in order to obey the monad laws
20:56:36 * shachaf is apparently one step behind c_wraith.
20:57:29 * shachaf still thinks (either id id) might be reasonable library function.
21:08:28 <killerswan> With Data.Text, I find myself writing ugly things like `T.putStrLn $ T.pack $ "A label: " ++ show data`.  Is there a better way?
21:08:45 <shachaf> killerswan: -XOverloadedStrings.
21:08:52 <shachaf> And (++) = mappend
21:08:57 <shachaf> It might help a bit.
21:09:15 <killerswan> oooooh, this is going to make me very happy :)
21:10:24 <shachaf> You still need to T.pack/fromString (show data), though.
21:12:22 <Peter_> I'm trying to run the data parallel simple example on http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell#A_simple_example
21:12:57 <Peter_> I'm using 7.2.1 and get an error DotP.hs:17:33: Not in scope: `fromPArrayP'
21:13:16 <Peter_> It was mentioned in June on a mailing list, but not resolved.
21:14:46 <Peter_> Anyone here knows about DPH changes associated with 7.2
21:24:27 <kmc> killerswan, well in that particular example, there's little point to packing the string just before printing it
21:24:50 <kmc> killerswan, also, many prefer (f . g . h $ x) over (f $ g $ h $ x)
21:25:08 <kmc> because (f . g . h) is a well-typed subexpression, and so are (f . g) and (g . h)
21:25:14 <kmc> whereas (f $ g) and (g $ h) aren't
21:25:38 <shachaf> > runST $ return $ 5
21:25:38 <lambdabot>   5
21:25:39 <shachaf> > runST . return $ 5
21:25:40 <lambdabot>   Inferred type is less polymorphic than expected
21:25:40 <lambdabot>    Quantified type variable...
21:27:10 <shachaf> "The preferences of the many are outweighed by the preferences of the Yuri."
21:29:46 <moriramar> @type runST
21:29:47 <lambdabot> forall a. (forall s. ST s a) -> a
21:30:26 <shachaf> > runST (return 5)
21:30:27 <lambdabot>   5
21:30:34 <shachaf> > let ($) = id in runST $ return 5
21:30:35 <lambdabot>   Couldn't match expected type `m t'
21:30:35 <lambdabot>         against inferred type `forall s....
21:33:20 <moriramar> @type runST . return
21:33:21 <lambdabot>     Couldn't match expected type `forall s. ST s a'
21:33:21 <lambdabot>            against inferred type `m a1'
21:33:21 <lambdabot>       Expected type: a1 -> forall s. ST s a
21:35:36 <moriramar> kmc, Excuse me. Is there any paper or wiki or tutorial about this?
21:36:05 <kmc> about what?
21:36:11 <kmc> and why me specifically?
21:36:39 <parcs> you're The One
21:37:25 <moriramar> kmc, I am sorry.
21:37:36 <moriramar> kmc, I mean papers about " because (f . g . h) is a well-typed subexpression, and so are (f . g) and (g . h)"
21:38:01 <shachaf> They'll write papers about anything these days.
21:38:11 <kmc> i don't know of a paper specifically about that
21:38:18 <kmc> it's just a fact about function composition
21:38:33 <shachaf> Just look at the types.
21:40:58 <kmc> you could find a proof that function composition is associative
21:41:43 <shachaf> Even fmap is associative.
21:41:47 <shachaf> Whenever the types match.
21:42:07 <shachaf> Of course, moriramar is asking about the types specifically.
21:42:11 <moriramar> kmc, shachaf, Thanks. I shall find tutorial about this.
21:42:28 <moriramar> shachaf, ?
21:42:31 <kmc> there's really not much to it
21:43:05 <kmc> if (f . g . h) is well-typed then f :: c -> d,  g :: b -> c,   h :: a -> b
21:43:13 <kmc> for appropriate choices of types a,b,c,d
21:43:22 <kmc> then you can see that (f . g) and (g . h) are also well-typed
21:44:45 <moriramar> kmc, return :: Monad m => a -> m a, runST :: forall a. (forall s. ST s a) -> a. So what's the problem with runST . return?
21:45:26 <donri> @source (.)
21:45:26 <lambdabot> (.) not available
21:45:38 <kmc> the problem is that it requires instantiating one of the type variables in the type of (.) to a polymorphic type
21:45:48 <kmc> which GHC isn't prepared to do automatically
21:45:58 <kmc> runST's type isn't valid Haskell, anyway
21:46:35 <moriramar> kmc, because rank2 polymorphic type?
21:46:40 <kmc> yeah
21:46:46 <kmc> you can't even write it in Haskell
21:46:48 <kmc> there's no "forall"
21:47:21 <moriramar> kmc, is it supported by any new Haskell standard?
21:47:33 <kmc> no
21:47:47 <kmc> but it's been supported by several Haskell implementations for a while
21:48:08 <shachaf> It's supported in standard "Haskell".
21:48:16 * shachaf stops being confusing.
21:48:48 <NemesisD> i figured out my problem. Data.Enumerator.List has a nice stateful enumerator called unfold
21:52:15 <kmc> i didn't mean to imply that you should avoid runST because it's not standard Haskell
21:52:36 <kmc> just that some properties of the language break when you turn on extensions
21:52:43 <kmc> the thing about (.) being an example
21:58:16 <moriramar> kmc, to me?
22:02:15 <kmc> whatever
22:13:47 <{][3473|^> <kmc> am i bovvered
22:44:35 <FLOWERPOWER> Hi, I need some help understanding nested monad transformers, in this code http://pastebin.com/HEK9dJ3m , why doesn't fun1 compile? am I missing a deriving term for the first state? Thanks, much appreciated
22:44:38 <mauke> The paste HEK9dJ3m has been copied to http://hpaste.org/52063
22:48:46 <Haskill> can someone PLEASE help me with my haskell homework?
22:48:49 <Haskill> please :(
22:49:31 <Haskill> it's probably a 5-minute thing for you pros
22:49:34 <danr> FLOWERPOWER: you use GeneralizedNewtypeDeriving
22:49:47 <shachaf> Haskill: Well, we generally don't provide answers for homework, but if you have a specific question that you haven't been able to figure out you could ask it and see.
22:50:01 <danr> but you do not derive MonadTrans
22:50:04 <danr> So you cannot use lift
22:50:19 <Haskill> ok, i'll try to phrase this properly.
22:50:52 <shachaf> Haskill: (I don't mean a homework question, I meant a question of yours about some specific thing.)
22:51:22 <Haskill> how would i go about making a function that takes [(String, Expr)], and replaces Var v with f for each pair in (v,f) in the String?
22:51:29 <Haskill> i know, i just don't know where to start
22:51:35 <Haskill> give me a nudge or something :(
22:51:54 <Haskill> Expr is a defined type given by the prof
22:52:15 <shachaf> Haskill: I don't think you understand your own question very well, let alone how to solve it. :-)
22:52:24 <Haskill> i know! ...
22:52:28 <danr> Haskill: recursively go through the tree, pattern matching on the different consturctors in the Expr datatype
22:52:28 <tensorpudding> Haskill, what type signature would this function have, exactly?
22:52:39 <Haskill> signature?
22:52:44 <donri> oh dear
22:52:52 <shachaf> Haskill: How have you been learning Haskell?
22:53:21 <Haskill> did a basic tutorial, this is the first assignment that our prof's given us with haskell :/
22:54:16 <shachaf> Haskill: You should probably do some more basic tutorials or read some more introductions or something.
22:54:42 <{][3473|^> Haskill: have a look at my tutorial
22:54:46 <Haskill> ?
22:54:59 <{][3473|^> http://cheater.posterous.com/first-haskell-script
22:55:12 <Haskill> thanks, i'll do this first now
22:55:44 <donri> @where LYAH
22:55:45 <lambdabot> http://www.learnyouahaskell.com/
22:57:22 <shachaf> {][3473|^: I don't think your tutorial is going to be very helpful for Haskill, since it talks about very different things.
22:57:43 <{][3473|^> it explains the basics of pattern matching, and looping
22:58:05 <{][3473|^> those are the two things he needs to solve his problem
22:58:46 <{][3473|^> the only thing left is to splice the string that he has, and that's simple
22:58:59 <tensorpudding> Haskill, so describe how this function would treat (v,f), what would the output be?
23:01:51 <FLOWERPOWER> danr: hmm, is there a way to have haskell derive MonadTrans automatically? I haven't found a way to express it in the deriving clause...
23:02:57 <danr> FLOWERPOWER: I was actually trying it myself, it seems a bit tricky for state transformers.
23:03:23 <FLOWERPOWER> Yeah, I've been baning my head at if for a while now :)
23:03:26 <danr> On the trac page, they just write deriving MonadTrans, but it seems to be ill-kinded in you example (http://hackage.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving)
23:05:03 <shachaf> danr: Well, you only want to derive MonadTrans if you're actually making a monad transformer.
23:05:11 <danr> shachaf: yeah it struck me
23:05:20 <danr> This is not a monad transformer :)
23:05:38 <danr> FLOWERPOWER: I guess you have to do this
23:05:40 <danr> fun1 = MyState1 $ lift get
23:05:43 <shachaf> Why are you stacking MonadStates? :-(
23:06:02 <danr> shachaf: that's a good question. FLOWERPOWER: you could use two states in a tuple
23:06:41 <FLOWERPOWER> Not sure this will be the solution in the end... I'm using one state for SDL (graphics) and one state for application state
23:08:29 <FLOWERPOWER> hmm, I may actually have a look at using two states in either a tuple or a record... seems to be a nicer sorution to the problem
23:09:04 <shachaf> Yes. I doubt you want to stack StateTs.
23:09:11 <shachaf> For that matter, are you even sure you want to derive MonadState?
23:10:46 <FLOWERPOWER> Well, yes.. otherwise I can't even get the out-most state
23:11:53 <shachaf> FLOWERPOWER: No, I mean that you might want to define your own primitives for your monad instead of using State's primitives.
23:12:03 <shachaf> I don't know what your exact problem is, of course.
23:12:36 <Blkt> good morning everyone
23:13:16 <FLOWERPOWER> Yes, that may very well be the case - I'm just trying out some ideas so it seemed simple enough to just use state to begin with
23:37:23 <Haskill> little question, why does it say "parse error" when i put a perfectly fine let statement in?
23:37:49 <shachaf> Haskill: Probably because it's not a perfectly fine let statement.
23:37:52 <danr> Haskill: well, you didn't then. You can paste your code at hpaste.org if you want others to look at it
23:37:59 <shachaf> There's no such thing as a "let statement" except in a do block, for one.
23:38:02 <Haskill> ah nvm, get it
23:38:03 <Haskill> got*
23:38:06 <shachaf> Haskill: You don't use let in top-level code.
23:38:16 <Haskill> hmm, yeah i removed it and it worked
23:39:09 <donri> ghci is different from .hs files
23:39:14 <Haskill> hmm
23:39:30 <Haskill> yeah, it doesn't work like python IDLE :(
23:40:01 <donri> i think it's fixed in dev version
23:40:06 <shachaf> There's no way it could.
23:40:28 <shachaf> donri: I suspect you still need to use "let" in the development version.
23:40:37 <donri> oh
23:44:11 * hackagebot hakyll 3.2.0.8 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.0.8 (JasperVanDerJeugt)
23:45:50 <Haskill> ok, say I have  s = [("k",7),("m",2)] ... why doesn't fst s work?
23:46:33 <erus`> Haskill: because its a list
23:46:47 <shachaf> Because fst takes a 2-element tuple and gives you the first element of that tuple.
23:46:52 <Haskill> but "kstst" is a list of chars and fst "kstst" works :s
23:46:53 <shachaf> I.e., fst (a,b) = a
23:46:54 <erus`> > let s = [("k",7),("m",2)] in fst $ head s
23:46:55 <lambdabot>   "k"
23:47:00 <shachaf> Haskill: No it doesn't.
23:47:00 <etpace> > fst "kstst"
23:47:01 <lambdabot>   Couldn't match expected type `(a, b)'
23:47:02 <lambdabot>         against inferred type `[GHC.T...
23:47:06 <Haskill> oh it doesn't
23:47:08 <etpace> > head "kstst"
23:47:09 <Haskill> :( wow...i suck
23:47:09 <lambdabot>   'k'
23:47:19 <Haskill> oh so head works with a list.
23:47:33 <Haskill> thank you once again!
23:48:25 <erus`> i want to create a sandbox in which an economy can emerge
23:49:17 <dmoctezuma> Haskill, if you want to do something to each element on a list, you can use List Comprehension
23:49:29 <shachaf> Haskill: head works with a list, but it's often not how you want to work with lists.
23:50:09 <dmoctezuma> Haskill, learnyouahaskell.com has some examples on that.
23:53:57 <Haskill> no, i'm just trying to acquaint myself with the things i'm dealing with in this assignment
23:56:30 <Haskill> is it 'mapping' when you replace something in an expression with something else?
23:57:51 <shachaf> Probably not.
23:57:54 <Haskill> then what's that called? :/
23:58:10 <shachaf> It depends on what you mean.
23:58:10 <erus`> substitution
23:58:19 <shachaf> One might use the word "replace".
23:58:31 <Haskill> yes, substitution is what we are required to do..
23:58:36 <erus`> i wish i went to uni
23:58:40 <Haskill> but i was looking for a haskell terminology
23:58:51 <Haskill> i wish they didn't teach haskell at my university -_-
23:59:08 <{][3473|^> it's called substitution in all languages.
