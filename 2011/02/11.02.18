00:00:06 <othiym23> kernoil: iPhone apps are mostly written in C with a thin layer of Smalltalk over the top ;)
00:00:13 <lispy> shachaf: our module system is our weakest selling point
00:00:24 <cads> Cale, I hear that during wartime at one point, huge rooms of human computers would work on intelligence encryption tasks for the military
00:00:40 <kernoil> othiym23: i though iphone was written in Objective C
00:00:43 <kernoil> which is OO
00:00:44 <Adamant> cads: they did, and for general calculations before that
00:00:46 <lispy> cads: that sounds like Bletchly park (how ever  you spell it)
00:00:56 <shachaf> lispy: Well, for some people, at least.
00:00:58 <Adamant> "calculator" used to be a job description
00:00:59 <Bynbo7> kernoil: Objective-C is a pretty small extension to C
00:01:00 <cads> each would work with their section of code, and since it was an intermediate step, no one computer could ever know what he was working on
00:01:02 <othiym23> Objective C is mostly C with a Smalltalk-like object system bolted onto the side of it
00:01:12 <Bynbo7> it's not like C++ which is quite different to C in many ways
00:01:17 <cads> lispy: I think that was the place
00:01:37 <kernoil> oh
00:01:46 <cads> I think the whole thought is from a scene portrayed in the book Cryptonomicon :)
00:01:53 <Adamant> cads: unless Feynman figured it out and told them :P
00:01:53 <Bynbo7> kernoil: do you really think that OOP is the only way to write useful programs?
00:01:59 <lispy> cads: Alan Turing proved, during WW2 that the tape is mighter than the tank
00:02:04 <othiym23> but people use non-OO languages because different languages embody different paradigms, and different paradigms are better for thinking about different kinds of problems
00:02:13 <shachaf> lispy: Have there been better proposals for implementation abstraction in Haskell?
00:02:13 <kernoil> Bynbo7: it makes everything so much easier
00:02:24 <Adamant> lispy: he proved that the tape let you know where to put your tanks better.
00:02:27 <Bynbo7> it's not the only way of making things much easier
00:02:33 <alpounet> kernoil, actually, it doesn't
00:02:37 <shachaf> OO is pretty weird.
00:02:38 <alpounet> OO has its pros and cons
00:02:39 <othiym23> kernoil: modularity and encapsulation / low coupling and high cohesion make things either, OO is just a means towards that end
00:02:43 <alpounet> just like functional programming :)
00:02:51 <cads> lispy: I think we'll figure out the encrypted computing problem and see computing processes that can safely run themselves in any environment without worrying about being manipulated
00:02:53 <othiym23> easier*
00:03:07 <Adamant> cads: homomorphic encryption
00:03:13 <cads> lispy: re. not trustin the users
00:03:14 <lispy> Adamant: and yet the British abused him for being gay :(  I'm grateful that in 2010 they had the grace to admit it was a mistake
00:03:17 <cads> Adamant: exactly :)
00:03:19 <Adamant> of course, when RSA goes, it goes
00:03:33 <Adamant> lispy: part of it was that his wartime record never came up
00:03:36 <Adamant> IIRC
00:03:36 <kernoil> </troll>
00:03:38 <cads> Adamant: or obfuscated gates
00:03:40 <kernoil> too tired to go anymore
00:03:41 <Adamant> it was still so secret
00:03:42 <kernoil> night gents
00:03:51 <lispy> Adamant: ah, I had not heard that before
00:04:11 <Adamant> UK-USA alliance unloaded a lot of old, broken, German and Japanese equipment to the Third World
00:04:19 <Bynbo7> successful trolling is meant to piss people off :\
00:04:25 <lispy> Adamant: It's sad regardless.  Thank god they abolished the laws that he was prosecuted under.
00:04:38 <Adamant> except of course, they didn't tell anyone they had it broke.
00:04:46 <Adamant> yeah
00:04:50 <Jafet> Trolls get DTS 5.1.
00:04:55 <othiym23> there's a really good bit about Bletchley Park in the most recent, mammoth Connie Willis time travel novel
00:05:30 <cads> Adamant: heh, the third world has been so fubar'd it really boggles the mind
00:05:34 <othiym23> and about what working there during the war must have been like for the people who weren't Turing and the other math geniuses
00:05:52 <Adamant> othiym23: you might visit the museum sometime
00:06:03 <Adamant> I haven't been, but I bet it covers that
00:06:17 <othiym23> Adamant: I might, the next time I get over to the UK
00:06:49 <othiym23> Adamant: if you haven't read any Connie Willis, she does a ferocious amount of research on her books, and when they're about time-traveling history postdocs, she kinda has to kick it up a few notches
00:07:08 <cads> othiym23: interesting to think how unreal the capabilities the mathematicians and engineers were unearthing seemed to the military people asking them to do it
00:07:21 <othiym23> and unlike Stephenson, she's not intent on putting every last bit of research there on the page so you can be impressed at how smart she is
00:07:28 <cads> or whatever non-technical people that were exposed to any of the idea
00:07:30 <cads> s*
00:07:46 <othiym23> I think most of the people at Bletchley really had no idea what the hell was going on
00:07:52 <Adamant> ah. I'm sure it's good, but I kind of ended my wandering in that genre after reading most of Turtledove's stuff
00:08:13 <Adamant> I would guess they had suspicions but kept their mouth shut
00:08:29 <Adamant> remember, you did not talk about Codebreaking Club at that time
00:09:26 <Adamant> I have relatives that worked on classified projects from WWII that didn't talk about anything until what they worked on came to light later very, very publically so there was no longer a need for secrec
00:09:48 <othiym23> Adamant: the calculators were mostly women who would have been shopgirls or teachers if the war hadn't come along
00:09:54 <cads> do you guys understand knowledge free proofs?
00:10:10 <Adamant> like crypto style?
00:10:13 <othiym23> Adamant: fair enough, but I think Connie's head would explode if she were compared to Turtledove
00:10:28 <Adamant> othiym23: I make no comparisons or judgements
00:16:35 <dancor> what is the maximum amount of "computational power" a terminating language can have
00:17:18 <dancor> it certainly can't solve the problem of being an interpreter for a nonterminating language
00:18:59 <othiym23> dancor: http://lambda-the-ultimate.org/node/3470
00:21:32 <dancor> ty
00:22:06 <othiym23> sometimes when I pass along LtU links, I want to just stick "good luck, buddy!" on the end, reflexively
00:22:16 <othiym23> there's a lot of arguing and proof-waving in that thread
00:25:20 <dancor> this is -blah but it's quiet here: i was wondering about the set of computable vector graphics.  i think we can say monochrome on [0,1) w.l.o.g.
00:25:49 <dancor> is the set of finite-time-computable vector graphics a proper subset?
00:26:39 <dancor> or if something is not producable in finite time then it's not "computable"?
00:27:24 <dmwit> Not sure what vector graphics has to do with this.
00:27:33 <dmwit> Something that's not finite-time computable isn't computable.
00:27:46 <dancor> ok
00:28:30 <dancor> i guess i'm just thinking that a non-terminating postscript program could still be considered to produce something "in the limit"
00:29:41 <dancor> and i guess the set of limits-of-non-terminating-postscript [0,1)'s is all possible [0,1)'s, not just the computable ones?
00:29:44 <dmwit> Most definitions of computability don't really bother with side effects.
00:29:51 <dmwit> Only what's on the tape when the machine halts matters.
00:29:56 <dancor> i see
00:30:22 <dmwit> Not sure about that last question
00:30:34 * hackagebot hulk 0.1 - IRC daemon.  http://hackage.haskell.org/package/hulk-0.1 (ChrisDone)
00:30:41 <othiym23> from screwing around with sending raw Postscript to laser printers back in the day, I think most implementations of PS took an end-run around the problem by putting a watchdog on the interpreter and having it terminate computation after a fixed interval
00:30:59 <othiym23> I know that it was fairly trivial to overflow the stack
00:31:51 <dancor> ha well this is all theoretical
00:32:31 <dmwit> I don't have a proof, but my gut tells me that not all possible [0,1]'s are limits of computable sequences.
00:33:27 <dancor> new meaning to the "limit" of computation
00:33:42 <othiym23> it's a real problem, though
00:33:46 <dmwit> I guess here by "all possible [0,1]'s", I mean "everything in the power set of the interval [0,1]", and by limits of computable sequences, I guess I probably mean limits of monotonically increasing sets of intervals.
00:34:08 <dolio> Are we talking real numbers?
00:34:23 <dmwit> monotonically increasing *finite, computable* sets of intervals
00:34:26 <dmwit> dolio: Yeah, I think so.
00:34:48 <dolio> There are uncountably many reals between 0 and 1, but only countably many computable reals.
00:34:52 <jonkri> if someone has a good understanding of the enumerator library i would really grateful if someone could tell me how to get started with parseBytes of Text.XML.Enumerator.Parse. i know what an Iteratee, Enumerator and Enumeratee is on a type level, but i don't know how to connect it all together. i have a ByteString that i want to generate XML events from. thanks
00:34:58 <dmwit> dancor: In fact, isn't it true that given any representation of a real, there's an uncomputable real?
00:35:05 <dmwit> Yeah, what dolio said.
00:35:17 <flamingspinach> dmwit: what? given any hair on my head, there's an uncomputable real
00:35:18 <cads> dancor: I think your question could be an interesting question phrased in more elementary geometry terms :)
00:35:52 <dmwit> flamingspinach: s/there's an uncomputable real/there's a real that's uncomputable in that representation/, then
00:36:14 <flamingspinach> oh. Then s/any representation of a real/any representation of reals/ as well, I expect
00:36:19 <dmwit> Yes.
00:36:36 * hackagebot hulk 0.1.1 - IRC daemon.  http://hackage.haskell.org/package/hulk-0.1.1 (ChrisDone)
00:36:40 <dmwit> My English goes wonky this late at night. =(
00:36:43 <dmwit> My maths, too.
00:36:51 <cads> dancor: like, there's a program that we can show computes the cantor set, though it never halts
00:37:21 <cads> dancor: is that the kind of thing you were talking about? like, infinitary figures drawn by programs that have eternity to run?
00:37:33 <dancor> cads: yes
00:37:47 <othiym23> doesn't the existence of transcendental numbers pretty much stipulate that there are uncomputable reals?
00:38:10 <dolio> No.
00:38:16 <jho> Is there a way to tell Haskell to ignore invalid characters instead of choking on them when reading from a Handle?
00:38:34 <Dae_> If I have a foreign function that is pure in haskell terms, but needs allocated memory, would the haskell gods slay me down for using unsafePerformIO?
00:38:43 <dmwit> jho: Change your encoding, maybe?
00:38:45 <very> `product [0..]`
00:39:26 <dmwit> Dae_: It allocates and frees before it returns? Or it has a statically allocated block? Or what?
00:40:21 <jho> dmwit: The problem is that the files I want to read use different encodings from each other and as they are used by other (legacy) software I dare not to convert them
00:40:26 <othiym23> very: I'm pretty sure Mathematica is smart enough to short-circuit the evaluation of that sequence ;)
00:40:29 * cads would love to understand the filament structure of the bounary of the mandelbrot set
00:40:46 <jho> Mostly ISO-8859-1 and UTF-8 I think
00:41:14 <very> othiym23, mmm.. i will go and ask wolfram alpha
00:41:26 <dmwit> jho: I meant change which encoding the handle-reading functions used.
00:41:30 <cads> it's insane - whole universes of endlessly regressing mandelbrot craziness, all drawn by a single boundary line which never ever self intersects
00:41:45 <dmwit> jho: It's a new thing in recent GHC's -- handles are read in a locale-specific encoding by default.
00:41:46 <very> othiym23, also about `sum [x | x <- [0..], x < 10]`
00:41:49 <Dae_> dmwit, doesn't free. Say I had it return an array of all numbers from 1 to n. This would be a pure function if written in haskell. But I get the feeling I should think this through better
00:42:36 <cads> when god draws something with a pencil he draws a line which is infinitely long between any two points on it as easily as a child draws a stick figure in crayon 
00:43:23 <jho> dmwit: Thanks for the heads up. Does any documentation exist for it?
00:43:49 <very> wolfram akpha says the product doesn't converge..
00:44:04 <dmwit> Oh, yes.
00:44:10 <dmwit> That would be a nice thing to provide, huh?
00:45:25 <othiym23> very: right you are
00:45:34 <dmwit> jho: Well, there's hGetEncoding and hSetEncoding here:
00:45:53 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html
00:45:55 <very> othiym23, that it doesn't converge? or that alpha says it doesn't converge?
00:46:02 <dmwit> jho: And you might be interested in this as well:
00:46:12 <othiym23> very: that Alpha / Mathematica says it doesn't converge
00:46:13 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-IO-Encoding.html
00:46:13 <digitteqnohippie> yeah, it's like my secong bagavad gita. ^_^
00:46:29 <very> heh.. but that's wrong, isn't it?
00:46:30 <othiym23> which surprises me a little, honestly
00:46:31 <digitteqnohippie> oops, thought i was scrolled up... that was replying to stuff aaaaages back. 
00:46:31 <jho> dmwit: Thank you
00:47:47 <very> well, at least GHCi didn't even let me stop the computation.
00:49:55 <othiym23> I'm a number theory newb, but it seems highly unlikely to me that ∏ 0..Infinity would be anything but 0
00:51:55 <dmwit> That's the funny thing about infinite sequences.
00:52:12 <dmwit> Even if every point in the sequence has property P, their limit might not have property P.
00:52:17 <othiym23> yeah, but Peano's first axiom for multiplication is that x * 0 = 0 for all x
00:52:47 <othiym23> so, inductively speaking, you're just going to have an endlessly propagating 0 as you continue to multiply
00:53:09 <dmwit> Depends how you define an infinite product, I guess.
00:53:19 <dmwit> Have you got prod [0..n] = 0 * prod [1..n]?
00:53:44 <dmwit> If so, it's not so clear that 0 * prod [1..n] = 0, since (informally speaking) 0 * infinity is not necessarily 0.
00:54:11 <dmwit> "Even if every point in the sequence has property P, their limit might not have property P."
00:55:09 <othiym23> just thinking out loud, what would be the negative consequences of having a pattern match for prod _ 0 = 0; prod 0 _ = 0?
00:55:22 <dmwit> One of my favorite examples of that property: http://chzmemebase.files.wordpress.com/2010/11/9e7c48aa-1823-4d5f-aa13-40699c72d508.jpg
00:55:32 <Dae_> dmwit, 0*infinity isn't zero? are you suggesting it's 1? :p
00:55:57 <dmwit> othiym23: prod doesn't take two arguments
00:56:08 <dolio> Your favorite example is an informal drawing?
00:56:08 <very> dmwit, i was thinking about the same troll.
00:56:10 <dmwit> Dae_: Sometimes, yup.
00:56:27 <dmwit> dolio: My very favorite, yup.
00:56:33 <othiym23> dmwit: it's a foldl, yup
00:57:03 <othiym23> I'm just gaming it out in my head
00:57:11 <Dae_> dmwit, as much as I love the idea (I routinely set 1m = infinity) , isn't it only true for the limit?
00:57:35 <othiym23> say you see a 0 in the stream, return 0 immediately
00:57:45 <dmwit> I'm not sure what "it" is, Dae_.
00:57:48 <othiym23> if somebody knows a proof relevant to this, I'd love to see it
00:58:01 <Dae_> dmwit, 0*infinity = 1
00:58:02 <dmwit> > product [0..] :: Natural
00:58:03 <lambdabot>   Not in scope: type constructor or class `Natural'
00:58:25 <very> Dae_, you cannot calculate with infinity.. :>
00:58:30 <othiym23> very: I was originally talking about numbers like π or e, though, where you can't represent them in any naturally computable form
00:58:31 <dmwit> othiym23: Well, there's a lazy Natural type that you can probably convince to give you the answer you want.
00:58:52 <dmwit> I thought lambdabot had it, but I don't remember how to coerce her to admit it.
00:59:24 <dolio> Anyhow, infinite products are usually defined to be the limit of the partial products. And every partial product of [0...] is 0.
00:59:25 <dmwit> Dae_: 0*infinity is informal; you can only express what 0*infinity means formally by taking a limit.
00:59:44 <very> dolio, except the first according to wolfram alpha
00:59:56 <dolio> Ah, right.
01:00:10 <Dae_> dmwit, ok. Now the world is right once more
01:00:44 <very> dolio, but i don't know if you can call the empty product a partial product even
01:01:04 <dolio> I don't know if they care about the empty product for the purpose of the definition.
01:01:05 <Dae_> very, I know. I just don't always respect it ;)
01:01:21 <dolio> Every empty product is 1, so it affects every infinite product.
01:01:46 <dmwit> You can tack any finite sequence on to the beginning of an infinite sequence and get the same limit.
01:02:32 <cads> man, dmwit, how does the sequence of jagged circles get smoothed at the limit?
01:02:43 <very> Dae_, and i learnt in my analysis course that 0*infinity=1 when we talked about the δ function
01:02:48 <dmwit> cads, =)
01:02:50 <dolio> It does because the drawing says so.
01:03:14 <Dae_> very, my kind of mathematics :)
01:03:38 <dmwit> dolio: Although the drawing is informal, I think it shouldn't be hard to make a formal sequence that converges pointwise to a circle while having circumference 4 at each stage.
01:03:44 <very> though.. it could as easily have been 2. or 3 maybe
01:03:51 <dolio> Have you done it?
01:03:53 <othiym23> very: then I'd guess ∏ 0..Infinity would be the same, no?
01:04:10 <dmwit> dolio: No. What difficulty do you forsee?
01:04:48 <dmwit> There's nothing inconsistent about having pi be the usual 3.14... and having the sequence have diameter 4 the whole way.
01:04:48 <very> dmwit, what you get is the manhattan distance of a circle.
01:04:50 <cads> dmwit: the sequence of jagged regions does have the circle as its infemum
01:05:06 <dolio> I don't know enough on the subject to intuit whether it's possible or not. But I'm not going to assume it's possible because of the picture.
01:05:43 <dmwit> In fact, yes, I can construct the sequence.
01:05:48 <very> othiym23, i'm not convinced that `product [0..] == 0 * product [1..]` :>
01:05:54 <dmwit> It's even easy.
01:06:06 <othiym23> very: fair enough
01:06:17 <othiym23> I'd grab my copy of baby Rudin, but I'm not even sure where to look
01:06:21 <cads> really easy
01:07:10 <cads> very: if it's an axiom there's no need for convincing
01:07:45 <cads> infininitary products and summations are based on axioms and there are a few systems
01:08:36 <cads> essentially, all convergent products/sums must converge to the same classical result
01:09:13 <cads> while at the same time the classically nonconvergent results can be assigned values according to some theory
01:09:55 <cads> and the whole thing has to be shown to not allow you to derive any inconsistencies, in some way that goes way beyond me
01:10:02 <othiym23> so let's say we're dealing with the naturals and going by Peano's axioms, does that constrain things enough to determine an answer?
01:10:43 <Dae_> very, I thought that was the deffinition?
01:10:59 <cads> no, since peano's axioms only constrain the behavior of finite sequences of arithmetic ops, with finite values
01:11:37 <dolio> If we're talking about Haskell's product function, then product [0..] = 0 * product [1..].
01:11:43 <dmwit> othiym23: It definitely constrains things enough to determine the answer. The answer is then "product [0..n] can't be stated".
01:11:44 <dolio> Both are bottom.
01:12:44 <dolio> Actually, I suppose that isn't true for some numeric instantiations.
01:12:46 <very> Dae_, yes sort of :) but i think i can see clearly that `product[0..]` converges to 0 while `product[1..]` doesn't converge and so `0*product[1..]` doesn't converge. difficult
01:13:11 <dolio> But for the usual ones, it is.
01:13:41 <othiym23> it literally saved me fifty bucks, but I wish that my copy of baby Rudin hadn't been scrawled all over by its previous owners
01:17:01 <Dae_> very, hmm.. couldn't we use l'hospital here?
01:17:06 <dmwit> dolio: I think it is, even for the lazy implementations, because:
01:17:09 <dmwit> ?src product
01:17:09 <lambdabot> product = foldl (*) 1
01:17:14 <dmwit> foldl =)
01:17:24 <dolio> dmwit: The right side might not be bottom.
01:17:35 <Dae_> or not...
01:17:53 <dmwit> > foldl const "the answer" [1..] -- ?
01:17:53 <dolio> The fact that it's not a foldr kills the identity.
01:17:57 <lambdabot>   mueval-core: Time limit exceeded
01:18:20 <Bynbo7> you accidently the whole answer :o
01:18:35 <dmwit> So yeah, doesn't matter how lazy the implementation of (*) is, that fold is bottom.
01:18:36 <othiym23> from Wikipeida: "The product is said to converge when the limit exists and is not zero. Otherwise the product is said to diverge. The value zero is treated specially in order to obtain results analogous to those for infinite sums."
01:19:14 <very> Dae_, sorry i'm not sure. i think i have to look it up again.
01:19:35 <dmwit> othiym23: Man, what a hack. Shame on those mathematicians.
01:19:44 <very> not zero. that's intelligent.
01:19:47 <dolio> dmwit: That fold is bottom, but 0 * product [1..] depends on the laziness of (*).
01:19:51 <dmwit> But I feel somewhat vindicated.
01:20:11 <very> zero is the opposite of infinity. it's the inifine small.
01:20:14 <dmwit> dolio: aaaah, yes
01:20:21 <dmwit> dolio: Now I understand what you mean.
01:20:32 <Dae_> very, only when looking at the limit, right?
01:21:36 <very> mm.. at least it's how l'hospital works, right? sorry, i almost forgot how to math.
01:23:02 <very> somehow you say `oh, i have this inity here. let's put it into the denominator to make it zero.`
01:23:11 <very> infinity*
01:23:35 <Dae_> very, I think I will leave this to the proper math heads. I'm too applied in my math I'm afraid, and thus the problem doesn't really appear
01:24:20 <Dae_> very, but so long since I had to do a proof where I couldn't use physics to justify a math assumption
01:25:03 <very> applied.. yes, that's why i was curious why the expression doesn't return a zero immediately. it's just common sense.
01:25:24 <cads> hmm
01:25:53 <very> but `sin pi` returns 1.2246063538223773e-16. that's weird too.
01:26:15 <Dae_> very, exactly. 
01:26:27 <Bynbo7> > sin pi :: CReal
01:26:30 <cads> log Product_0->Infty a_n = log sum_0->Infty a_n
01:26:30 <lambdabot>   0.0
01:26:47 * hackagebot haskell-src-exts 1.10.2 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.10.2 (NiklasBroberg)
01:27:02 <Dae_> very, ahh, but that's floating point territory. Very dangerous to assume it follows logic
01:27:21 <cads> thus log product [0..] = log 0 + sum (map log [1..]), which is undefined
01:27:26 <very> ah right. maybe there is an analysis addon?
01:27:51 <very> ah wat.. i don't even care :)
01:28:01 <very> it's precise enough
01:28:25 <Dae_> very, welcome to the real world :p
01:28:37 <cads> this would be consistent with either product [0..] = 0, or product [0..] = not defined
01:28:57 <othiym23> baby Rudin, papa Rudin, and _Counterexamples in Analysis_ all shy away from talking about infinite products with 0 as the basis
01:30:06 <othiym23> I guess I'm just gonna have to live with it being undefined
01:30:12 <Dae_> well, clearly lim 0*x, x-> infty = 0, right?
01:30:25 <cads> if we define the infinte product as the limit of the partial products then clearly product [0..] = 0
01:30:35 <othiym23> yes
01:31:01 <othiym23> but by the definition of infinite products, it doesn't converge
01:31:32 <very> othiym23, true.. let's add 1 to both sides.
01:31:37 <othiym23> haha
01:32:29 <othiym23> my classes always spent a lot of time on infinite sums and limits and spent maybe a day talking about infinite products
01:32:32 <very> `lim 0*x+1, x->infty = 1` and subtract the 1 later
01:32:34 <othiym23> also, were 20 years ago
01:32:35 <cads> othiym23: only if your infinite sum lets you write product [a, b..] = a * product [ b..], which we might want as a deduction we can make in our system
01:32:37 <Dae_> so... why isn't infinity products defined as the limit of partial products?
01:32:41 <cads> or we might not :D
01:33:01 <Dae_> *infinite
01:33:20 <dolio> Dae_: It is. But mathematicians apparently define partial products converging to 0 as a divergent product.
01:33:30 <othiym23> by definition
01:33:32 <othiym23> literally
01:33:52 <othiym23> so they can reason about infinite products and infinite sums in similar ways, apparently
01:35:08 <Dae_> hmm... ok. Not sure I like it, but ok
01:35:17 * dmwit likes it
01:35:17 <cads> oh, okay
01:35:49 <cads> if the partial product converges to zero the infinite product does not exist :P
01:36:09 <cads> though I don't think that should be the case
01:36:23 <othiym23> a good chunk of getting better at pure math is knowing when to let go of trying to get everything to make intuitive sense
01:36:28 <othiym23> at least that's been my experience
01:37:51 <cads> suppose you have infinite seq A such that Prod A  converges - then Prod 0:A does not exist, even though Prod 0:A  = 0 * Prod A = 0 by our intuitive notion
01:38:34 <cads> the definitoin I'm using is the from the first and second sentences of http://en.wikipedia.org/wiki/Infinite_product
01:39:03 <cads> which also gives a reason for why zero is treated specailly
01:39:39 <Dae_> othiym23, sadly that's counterproductive if you need to use it applied. I guess it's a case of having your cake and eating it
01:40:09 <othiym23> "pure math" /= "applied" sort of by definition, Dae_
01:40:12 <dmwit> But, I mean, come on. What products could people be interested in that had a 0 in them?
01:40:20 <othiym23> unless you're writing a theorem prover, I guess
01:42:38 <dolio> It also rules out things like product_n 1/n.
01:42:42 <Dae_> othiym23, really? I thought (perhaps wrongly) that most math sooner or later became applied? Not easily applied, but still
01:42:52 <dolio> Although I don't know why you'd necessarily care about those either.
01:43:17 <cads> dae, no, most math is applied only to math
01:43:44 <othiym23> although Haskell will do its damnedest to rope in just about everything it can
01:44:00 <cads> :)
01:44:19 <cads> "you want the kitchen sink too?" "is it monadic?"
01:46:33 <othiym23> a few nights ago I started reading about the intersection between fixed point combinators and monadic bindings and ended up reading about the foundational crisis in mathematics and Gödel
01:46:55 <othiym23> a surprising number of my investigations into math seem to end up with Gödel
01:46:59 <Dae_> cads, hmmm... but isn't applying it the goal? Not right now, obviously, but ultimately. Doing research in the hope that at some point it will prove useful in the "real" world? or am I being too idealistic here? :p
01:47:32 <othiym23> I think a useful way to think about mathematics is that it's trying to extract abstractions from abstractions
01:48:11 <cads> Dae_: I know that lots of mathematicians that only want to do math, and would like others to sort out whether it has wider application
01:48:26 <othiym23> I don't think Yau necessarily expected Calabi-Yau manifolds to end up being useful in string theory, but I don't think he would have been disappointed if they'd never been picked up for a "real world" model
01:48:30 <cads> that there are*
01:50:32 <Dae_> cads, ohh yeah surely. They find pure math far more interresting. But would they do math if the were certain that it wouldn't be "useful" ever?
01:50:49 <othiym23> Dae_: unquestionably
01:51:37 <othiym23> Dae_: I think that's true of a certain class of dedicated scholars in general
01:52:08 <othiym23> my mom has a PhD in mycology and really couldn't give a rat's ass about the real-world implications of a lot of the taxonomic disputes she wades into
01:52:35 <beginer001> hello
01:52:51 <cads> it's worthwhile at least in the same sense that watching a tv show is worthwhile :)
01:52:59 <beginer001> i have a question
01:53:00 <cads> so I don't fault people for being into it
01:53:10 <beginer001> How to display Chinese in haskell
01:54:07 <beginer001> How to use Chinese in haskell
01:54:35 <othiym23> beginer001: encoded as Unicode? or?
01:55:05 <beginer001> UTF-8 or GB2312
01:55:50 <beginer001> 中文
01:56:06 <Dae_> cads, othiym23, I don't fault anyone for being into math or any other scientific topic. In general it's fun and challenging once you get into it. I guess my question was more oneof each science view of itself
01:56:23 <Zao> beginer001: Unicode should work by default in a sufficiently modern GHC.
01:56:26 <Adamant> othiym23: I like "the science of patterns"
01:56:32 <Dae_> cads, othiym23, but let's stop here. After all this is #haskell and not #philosophy
01:56:35 <othiym23> > putStrLn "中文"
01:56:36 <lambdabot>   <IO ()>
01:56:39 <sudonotplease> Funny question, but has haskell been embedded into html?
01:56:50 <Adamant> if the philosophy is CS or math, it's ontopic
01:57:05 <Adamant> sudonotplease: there are templating systems IIRC
01:57:11 <shachaf> > putStrLn " <IO ()>" -- This is how you do IO inside lambdabot!
01:57:12 <lambdabot>   <IO ()>
01:57:18 <Zao> beginer001: Char is a unicode codepoint, String is a list of Char. Data.Text is an efficient string type that uses UTF-16 internally, and which can convert to/from String and sequences of UTF-8 code units.
01:57:20 <beginer001> putStrLen "中文"   but result is ?颼?>
01:57:37 <Zao> beginer001: As for GB2312, you might need to use an iconv binding.
01:57:41 <Zao> beginer001: What GHC version, and what locale?
01:58:16 <beginer001> 6.12.3
01:58:57 <othiym23> > head "中文"
01:58:59 <lambdabot>   '\20013'
01:59:03 <othiym23> (just seeing what lambdabot does)
01:59:20 <Zao> 7.0.1 does The Right Thing on the linux box here.
01:59:31 <othiym23> it does for me as well
01:59:32 <beginer001> yes
01:59:55 <Zao> Also, what operating system?
02:00:03 <beginer001> windows
02:00:41 <quicksilver> beginer001: your source file must be encoded in UTF-8 if you want unicode string literals in your source.
02:00:51 <quicksilver> GHC doesn't support alternative encodings for source files.
02:01:25 <quicksilver> if you want the unicode string to be loaded from a file (or the network, or...) you can use whatever encoding you want but you'll need to decode it correctly, of course.
02:01:26 <beginer001> i'm in ghci
02:01:43 <quicksilver> I wouldn't be entirely surprised if ghci encoding support is broken on windows :)
02:01:46 <othiym23> beginer001: what terminal / shell are you using?
02:02:33 <beginer001> ghci
02:02:40 <beginer001> windows cmd
02:02:43 <othiym23> ah
02:02:59 <beginer001> :)
02:03:52 <beginer001> 有能看到中文的吗? 呵呵
02:04:17 <quicksilver> possibly this bug? http://hackage.haskell.org/trac/ghc/ticket/4471
02:05:08 <othiym23> you could at least try the bit with "chcp 65001" in your cmd before running ghci and see if that fixes it
02:05:40 <othiym23> (I don't have GHC installed in my Windows vm to test for you, sorry)
02:08:07 <beginer001> ok, thanks othiym23
02:09:50 <gienah> beginner001: maybe you could run ghci in rxvt-unicode using cygwin X-Windows
02:10:33 <beginer001> ok
02:11:37 <ruang> hello
02:17:26 <ruang> do you know of any easy to read defenitions for phrazes like 'natural numbers', 'whole numbers', 'rational numbers' etc?
02:17:42 <ruang> *sources for sorry
02:17:45 <Zao> ruang: Wolfram's MathWorld or Wikipedia?
02:17:57 <mjrosenb> wikipedia's simple english entry?
02:18:18 <othiym23> def. start with Wikipedia before MathWorld
02:18:21 <ruang> simple english entry?
02:18:23 <ruang> what that?
02:18:41 <Zao> If your native language is something not english, you can always navigate to the english page on wikipedia and choose your native language if available.
02:18:43 <cads> hey, I was wondering, I want to make a program that takes a list of subsets of the discrete n-dimensional euclidean grid, and determines whether there is a corresponding list of rigid transorms that transform the subsets into an exact cover of the 4^n, the 4x4..x4 unit hypercube..
02:18:47 <ruang> oh... i see.  xie xie ni.
02:18:53 <othiym23> http://simple.wikipedia.org/wiki/Natural_number
02:18:54 <ruang> yes, that is not my language.
02:19:03 <Zao> ruang: Simple English is a variant of the English language that uses a small set of words, with easy grammar.
02:19:11 <cads> but I don't know if I can parameterize a haskell program by n like that so easily
02:19:12 <mjrosenb> ruang: http://simple.wikipedia.org/wiki/Main_Page
02:19:23 <ruang> 3q zao
02:19:48 <cads> what would you guys suggest for writing stuff with a set theory flavor?
02:19:52 <Zao> http://gan.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B8 http://zh-classical.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B8 http://zh-yue.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B8
02:20:00 <Zao> I'm guessing one of those might fit.
02:20:28 <mjrosenb> cads: avoid any set larger than the naturals
02:20:46 <cads> Z^n is as large as the naturals :)
02:20:52 <dmwit> cads: Dunno about set theory, but that kind of parameterization sounds like the kind of thing you want Agda/Coq for.
02:21:12 <Zao> I've got no idea what separates 'gan' from 'zh-yue' from 'zh-classical', heh.
02:21:43 <ruang> Zao++
02:22:02 <ruang> mjrosenb++
02:22:15 <ruang> othiym23++
02:29:53 <othiym23> Someday *I* want to write papers with fancy titles like "Ultrametric Semantics of Reactive Programs" filled with huge sheafs of equations!
02:31:37 <earthy> no you don't
02:32:12 <othiym23> oh yeah, you're right
02:32:25 <othiym23> I could just use that as the title for my next grindcore concept album
02:33:27 <cads> man, if you learn more math it becomes possible to say extremely wordy math statements in short koans of breathtaking simplicity
02:33:40 <cads> which nobody can understand
02:34:22 <zygoloid> monoidal endofunctors on hask \o/
02:34:38 <cads> that's pretty awesome, actually
02:35:01 <cads> it's so damn easy, then
02:38:19 <cads> I think kids need to be taught how to endow shit with monoidal structure
02:39:22 * digitteqnohippie thinks he could do with being taught that too
02:39:35 <othiym23> it's kind of amazing that someone asked a question on Stack Overflow about endofunctors in Haskell and got a cogent response: http://stackoverflow.com/questions/3273373/are-all-haskell-functors-endofunctors
02:39:54 <Adamant> Stack Overflow is remarkably good
02:40:07 <othiym23> I could see it on MathOverflow, but I think I've spent too long dealing with Rails newbs on StackOverflow
02:40:49 <Adamant> it was kinda unsteady at first, but they've committed to keeping it working nicely pretty well.
02:42:03 <jonkri> why do i get an error on line 113 saying "Expected type IO a"? i want to operate in the Step Event IO () context ... http://paste.pocoo.org/show/340740/
02:44:23 <jonkri> aha... withSocketsDo!
02:44:51 <ivanm> dammit, my Text-based version of graphviz is slower than the old String-based version! :(
02:45:06 <jonkri> how can i change my code so that "withSocketsDo" operate in that context too?
02:45:32 <Dae_> ivanm, really? that sounds odd
02:45:55 <ivanm> it's not that much slower, but I'm having trouble tracking down why
02:46:14 <ivanm> e.g. 5s vs 4.5s
02:49:21 <Dae_> ivanm, have you run profiling on it?
02:49:25 <ivanm> yup
02:49:28 <Dae_> both the old and new
02:51:09 <mun> if i want to logically express that every function in a set S are equal to each other, but in FOL rather than HOL, then would I need to explicitly compare each pair? e.g., S = {f,g,h} then it'd be "\forall x. f(x) = g(x) & f(x) = h(x) & g(x) = h(x)"? or is there a prettier way?
02:51:12 <ivanm> Dae_: yup
02:51:32 <Dae_> ivanm, and nothing? no obvious difference?
02:51:40 <ivanm> nope
02:53:49 <Dae_> ivanm, I remember having a similar problem a while ago with reading in text files. Never did figure out the problem though
02:54:05 <ivanm> hmmmm....
02:54:33 <ivanm> I'm reading in text files, parsing them, printing them as input to another command and then parsing back in the result
02:55:37 <mjrosenb> ivanm: does text have all of the laziness of strings?
02:55:48 <ivanm> mjrosenb: I doubt it
02:55:55 <ivanm> I am using lazy Text, but still
02:56:27 <mjrosenb> mun: you can use tuples of functions and inputs
02:56:45 <mjrosenb> \forall (f,g,x). f x = g x
02:56:51 <mjrosenb> mun: possibly?
02:57:10 <mun> mjrosenb, but wouldn't i then be quantifying over functions?
02:57:22 <Dae_> ivanm, are things better with strict text?
02:57:25 <mjrosenb> mun: in know in complexity theory we didn't care about repeating the same quantifier, only changing quantifiers
02:57:40 <mjrosenb> so \forall x. \forall y. \forall z. foobar was cool
02:58:09 <mjrosenb> as was \exists a. \exists b. \exists c. quuxbaz
02:58:44 <mjrosenb> mun: well you are quantifying over the elements of a set, right?
02:59:02 <ivanm> Dae_: the parser and printer both use lazy Text values...
02:59:20 <ivanm> (admittedly, I wrote the printer and am helping out with the parser...)
02:59:21 <mun> mjrosenb, yes, that's what i'd like to do but i'm limited to FOL.
02:59:31 <jonkri> silly question: how can i run a Step Event IO () function from a function operating in the IO context?
02:59:40 <mun> mjrosenb, since the elements here are functions.
03:00:18 * hackagebot Interpolation 0.2.5 - Multiline strings, interpolation and templating.  http://hackage.haskell.org/package/Interpolation-0.2.5 (VilleTirronen)
03:00:20 <Dae_> ivanm, fair enough.... Possibly ghc is just very good at optimizing away the list in String? In my case the performance of haskell reading text files was an order of magnitude below, say, python
03:04:25 <ivanm> admittedly, the Text-based one has a few other changes, but even reverting all those changes doesn't seem to make a difference :s
03:09:48 <ivanm> oh well, the speed difference isn't that much
03:11:01 <xarch> how can I transform a Char to a Word8?
03:13:32 <harlekin> I'm having a Haskell programm which periodically prints a line to stdout. Piping it to less gave 1 line a second as expected. However, after switching to System.Plugins the program still outputs periodically to the console, but piping it to less make less buffer 5 or 6 lines before output.
03:13:49 <harlekin> Is this related to the Haskell program, System.Plugins in particular?
03:15:46 <Dae_> ivanm, still annoying :p
03:16:20 <tab> xarch: you can use fromIntegral . fromEnum
03:16:45 <tab> xarch: only if you char is < 256 though
03:16:50 <xarch> ok, thanks!
03:19:42 <erikl> Hello, is just started looking at haskell an started to wonder the dot in this line does, "tac  = unlines . reverse . lines".
03:19:46 <erikl> Taken of the wiki
03:19:54 <ivanm> @type lines
03:19:56 <lambdabot> String -> [String]
03:19:58 <ivanm> @type unlines
03:19:59 <int-e> @src (.)
03:19:59 <lambdabot> [String] -> String
03:19:59 <lambdabot> (f . g) x = f (g x)
03:19:59 <lambdabot> NB: In lambdabot,  (.) = fmap
03:20:10 <ivanm> erikl: care to guess given these type signatures?
03:26:50 <erikl> ivanm: now I've got it, thanks.
03:35:35 <merijn> Any recommendations for Haskell libraries for parsing/making HTTP requests?
03:36:11 <Schalken> merjjin: Network.HTTP?
03:36:22 <Schalken> merijn: ^
03:37:35 <vegai> Network.HTTP is quite good, yes
03:37:48 <vegai> doesn't do https unfortunately
03:38:31 <merijn> Don't think I really need HTTPS
03:38:58 <vegai> then it's all good
03:40:06 <merijn> Mostly I was inspired by today's XKCD of proxying all reddit/hacker news traffic through a 30s delay proxy to increase productivity. I think I could hack together some similar stuff for my own uses :p
03:41:21 * earthy is a more advanced procrastinator
03:41:41 * earthy has so much stuff to procrastinate with that the constant reloading really doesn't even factor in :)
03:42:14 <merijn> earthy: Its not so much constant reloading, but visiting a lot of times on the day for no apparent reason :p
03:42:32 <Schalken> I often procrastinate in my own procrastinating.
03:42:47 <merijn> Network.HTTP looks like it only implements client side though, which would really help mangling outgoing requests (unless I plan on parsing them with regexes or something ugly)
03:43:07 <merijn> Writing an anti-procrastinator is a form of procrastination, but at least somewhat productive :p
03:43:11 <earthy> merijn: aha. yes. okay. I have enough stuff that I can go for a day *without* having re-checked each particular site. ;)
03:45:15 <ccvx> I've been implementing ICFP Programming Contest 2006 's problem.
03:45:15 <ccvx> my program consumes a lot of memory(about 300-500MB) and is very slow(apparently,freeze).
03:45:15 <ccvx> i can't understand reason. what's wrong?
03:45:15 <ccvx> here is my code: http://hpaste.org/44111/a_lot_of_memory_consuming
03:45:15 <ccvx> (sorry, almost all comments are not written in English,so please ignore.)
03:45:15 <ccvx> profile says that "total alloc: 777,686,388 bytes","parseInst: alloc 20%","setRegVal: alloc 26.1%", "spinCycle-newm(SCC):alloc 17.1%"
03:45:15 <ccvx> I can't understand why such a simple function(parseInst) consumes large memory.
03:45:16 <ccvx> Would anyone give me answer?
03:45:18 <ccvx> (i've already post the question other forum,but i have'nt recieved good answer yet.)
03:46:08 <cheetah2003> i'm new to haskell and i'm attempting to build a project i got from sourceforge and these dependacies are absolutely killing me, i cannot get it to build properly.. can anyone give me hand please?  I've been poking at this for well over 12 hours with no success
03:47:29 <vegai> ccvx: the number of mistake of Haskell, laziness, might be biting you there
03:47:35 <vegai> number one mistake*
03:47:56 <ivanm> cheetah2003: which project?
03:48:05 <ivanm> *wonders which Haskell project uses sourceforge...*
03:48:26 <cheetah2003> its a eclipse plugin called lslplus.. want a url?
03:49:14 <ceii_> cheetah2003: yes, please. also, what's your OS?
03:49:55 <cheetah2003> windows 7.. running with um, haskell platform 2009.2.0.2 (since this appears to be what the original was built with), sec on the url.. fetching it
03:50:37 <cheetah2003> http://lslplus.svn.sourceforge.net/viewvc/lslplus/  if you look in trunk, there's a folder called haskell, and thats what I'm trying to get to build properly
03:52:08 <Dae_> cheetah2003, where is cabal install failing?
03:52:49 <cheetah2003> let me paste bin.. i'm using runhaskell Setup.hs build.. when i use cabal, it fetch an old version of lslplus from the hackagedb, which is highly annoying and not very useful
03:53:39 <cheetah2003> http://pastebin.com/erw4hQqg
03:54:33 <ccvx> vegai: i tried to disable some laziness by adding ! to abstract data type's field, but seemingly have no effect.
03:54:57 <xarch> why does this simple parser (char8 'f' `sepBy` char8 '&') doesn't work (with Attoparsec) ?
03:55:03 <xarch> it produces a Partial
03:56:13 <Dae_> cheetah2003, when you unpack the source, just browse to it and go "cabal install". This should compile and install the code you downloaded
03:56:40 <cheetah2003> ok let me try that.
03:58:16 <cheetah2003> i admitted know NOTHING about haskell or the tools... ok that didnt work, same exact error
04:00:18 <cheetah2003> the changes i need to make are simple, just constants in some of the source to bring the eclipse plugin up-to-date with second life, but apparantly the original developer abandoned the project and no one in SL knows anything about haskell
04:01:16 <ceii_> cheetah2003: I'm trying to build it here, be back in a minute
04:01:25 <dcoutts> cheetah2003: is it lslplus you want to install, or something that depends on it?
04:01:33 <cheetah2003> its lslplus
04:01:41 <cheetah2003> i'm trying to build it from source so i can make changes
04:01:41 <Dae_> cheetah2003, well... without going into too much detail, you could try adding "-fglasgow-exts" to the  Ghc-Options line of the .cabal file
04:02:39 <cheetah2003> i do wanna mention one observation if this helps.. if i keep re-running my 'runhaskell Setup.hs build' line, everytime it fails, it eventually succeeds and i get a lslplus.exe i can use, but its not stable, the eclipse plugin seems to break after a while of usage, so its not making a good build
04:02:41 <dcoutts> Dae_, cheetah2003: ooh I see, it's just that the code is old and needs updating for the newer mtl
04:03:39 <dcoutts> cheetah2003: oh that's very odd, if it gives a compile error it should never get to the state of making any exe at all
04:03:45 <cheetah2003> is that hard?  as i said, this haskell is very foreign to me... i dunno anything about it, and the changes are simple enough that I can muddle my way it make them..
04:04:05 <cheetah2003> er muddle my way to make them
04:04:19 <cheetah2003> so it updating it for this mtl thing hard? i have no idea how to do that
04:04:29 <merijn> cheetah2003: I believe Haskell is very foreign to anyone who has never touched functional programming (i.e. the large majority of people) :p
04:04:56 <cheetah2003> yeah... its definitely not a language i've fidgitted with.. i'm more a C / C++ kind of guy
04:05:14 <dcoutts> cheetah2003: what does cabal install --dry-run say?
04:05:42 <Dae_> cheetah2003, surprisingly you become a better programmer in other languages by learning haskell.... <\advert>
04:05:58 <Eelis> Dae_: not a better HTML programmer it seems
04:06:10 <cheetah2003> it says: in order, the following would be installed (use -v for more details): LslPlus-0.6.1
04:06:27 <ManateeLazyCat> When time release ghc-7.0.2?
04:06:39 <merijn> I agree with Dae_, my C code is so much better now that I know Haskell. After the pain of a mind-controlling martian eating through my skull went away I was fine! *twitch*
04:07:11 <Dae_> Eelis, probably not. I never was a big fan of XML/HTML + javascript. 
04:07:27 <merijn> Javascript is pretty good
04:07:49 <Eelis> Dae_: i was referring to your use of <\advert> instead of </advert>
04:08:02 <ruang> lol
04:08:06 <dcoutts> cheetah2003: hmm, ok, can what about cabal install --dry-run --constraint='mtl < 2'
04:08:20 <Dae_> merijn, I have to disagree. The complete lack of anything to help with error correction is dreadful
04:09:05 <Dae_> Eelis, I know ;)
04:09:09 <cheetah2003> dcoutts: same thing
04:09:41 <merijn> Dae_: I suffer from multiple personality disorder. My one persona loves static typing and wishes dependent typing in practical languages was here, the other is a python/lisp loving hippie who thinks dynamic typing is a way of "sticking it to the man", guess which one likes JS :p
04:09:45 <dcoutts> cheetah2003: try that then, without the --dry-run, ie using the --constraint='mtl < 2'
04:10:20 <cheetah2003> back to the overlapping instances for Monad error
04:10:33 <dcoutts> cheetah2003: ok, wait for ceii_ who's having a look
04:10:47 <merijn> Dae_: Also, I've reached the Zen point in my live where I can program and feel reasonably comfortable in any language without getting worked up about whatever warts exist in that language
04:10:51 <cheetah2003> ok tyvm everyone.. i really appreciate this.. if i can just get it building, then i can learn from it
04:10:56 <dcoutts> cheetah2003: it's due to changes in the libraries that lslplus depends on
04:11:33 <merijn> cheetah2003: If you're going to be looking at Haskell source I recommend you take a look at "Learn You a Haskell", it's great
04:11:38 <merijn> @where lyah
04:11:39 <lambdabot> http://www.learnyouahaskell.com/
04:12:16 <cheetah2003> yeah i figured as much... i was trying to get cabal to only install the correct versions of the libraries, but some libraries requests different versions of things and it just started getting scary from there
04:12:17 <Dae_> merijn, I enjoy python too. I just think that python is a lot better than javascript. It is much easier to debug. Ofcourse haskell always does what you want, once you figured how to tell it
04:13:38 <merijn> Dae_: Oh, I like python more. But for an extremely popular major language javascript is pretty ok. (Compared to, say, Java)
04:13:54 <cheetah2003> merijn: same here... it gets to a point where they're all just programming languages, just gotta understand how they work, then all yer normal programming knowledge comes to bear with the new language
04:14:40 <merijn> cheetah2003: The only problem with haskell is that (if you haven't done any functional programming before) all your normal programming knowledge is basically wrong. Which is why newcomers tend to have a hard time
04:15:09 <Adamant> lies! Blub Paradoxes! my language is more leeter than your language!
04:15:18 <merijn> The upside, once you "get" it, you'll have learned a lot of new insights about programming.
04:15:25 <cheetah2003> what other languages are consider functional ?  not sure if i've worked with one in the past or not, been so many different things i've tinkered with over the years
04:15:28 <Adamant> :P
04:15:30 <merijn> Adamant: That doesn't hold, I didn't say better, I said different
04:15:37 <Adamant> merijn: joking :P
04:16:19 <Dae_> merijn, perhaps it's because I've been forced to work with XUL+javascript, but I think I would even prefer working in java. But now we're talking different levels of hell, obviously
04:16:21 <cheetah2003> actually i can just google that :D
04:16:27 <merijn> cheetah2003: (S/OCa)ML (very similar), lisp/scheme/clojure (very different from haskell) are the most common functional languages
04:16:52 <Adamant> cheetah2003: functional is kinda fuzzy. at a minimum, it treats functions as first class. it can be impure or pure. Haskell is pure.
04:16:53 <cheetah2003> ahhh i have tinkered with lisp (emacs stuff) in the past
04:17:00 <merijn> python/javascript allow *some* things which make functional programming less weird
04:17:20 <cheetah2003> i've messed with python before too
04:17:43 <merijn> cheetah2003: Basically, if you already get the idea of higher order functions (functions which take functions as arguments) you have one of the big basic ideas covered
04:18:09 <cheetah2003> take functions as arguments to functions? whoa.  
04:18:20 <merijn> Lisp and python are of course dynamically typed, Haskell is very much strongly and statically typed
04:18:25 <Adamant> at least declarable TCO or equivalent is a minimum for my definition
04:18:40 <cheetah2003> i have done things like that in forth, i considered it kind of kludgy at the time
04:18:56 <Adamant> Forth is neat for what it is
04:19:13 <Adamant> consider looking at Factor
04:19:20 <merijn> cheetah2003: Consider a "sort" function, basically you want something that takes a comparison function and a list and returns a sorted list, no?
04:19:24 <Adamant> functional stack language
04:19:26 <cheetah2003> i kind of miss it, its really very straight forward and makes a lot of sense when you wrap yer head around it
04:19:35 <merijn> :t sortBy
04:19:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
04:20:01 <cheetah2003> haha thats exactly what i was doing in forth, passing address of a function to a sort routine to use as the sort method
04:20:21 <merijn> Basically sortBy takes one a comparison function and a list of a's (where a can be any type) and returns a sorted list
04:21:17 <merijn> It takes a bit of time to grok haskell's type signatures and the ideas behind it. But they're very nifty and helpful once you do (but most of this stuff is covered in-depth in Learn You a Haskell, so...)
04:22:00 <cheetah2003> well my first objective is to get this thing to build... i work best from examples and need to make something work
04:23:03 <cheetah2003> its like.. i got a goal, haskell is what i need to get working to achieve that goal. but not being able to build this out of the box is frustrating o.o
04:23:38 <_mpu> Goal proved.
04:23:50 <_mpu> oops
04:41:47 <revenantphx> When is HP2k11?
04:42:54 <ccvx> Again, when a program consume large memory and i can't solve the problem, what shoud i do generally? profile says some simple function consume large memory,but i can't understand why do so,and so can't fix.
04:43:53 <parcs> revenantphx: march 1st
04:44:05 <revenantphx> whoo.
04:44:10 <revenantphx> Is it 64bit :|?
04:44:33 <merijn> HP2k11 will support GHC7, right?
04:44:47 <Saizan> ccvx: you could try mentally or manually unfolding its evaluation according to the "outermost first with sharing" rules
04:44:47 <revenantphx> I already have GHC7 anyhow >_>
04:45:05 <silver> merijn, yeah, should be like that
04:45:37 <parcs> here's the staging website for the new HP: http://code.galois.com/darcs/haskell-platform/download-website/
04:46:15 <revenantphx> So... we're not giving the Haskell Platform releases fun names with a recurring theme?
04:46:21 <revenantphx> What kind of modern release system is this? XD
04:46:45 <revenantphx> Also, the blue download link clashes terribly.
04:46:46 <merijn> revenantphx: Like what? "Famous type theorist names"? :p
04:46:49 <revenantphx> Especially with a purple header.
04:46:56 <revenantphx> this one looks good: http://hackage.haskell.org.nyud.net/platform/
04:47:04 <revenantphx> consistent coloring, and the background is unobtrusive but pretty
04:47:22 <revenantphx> The purple needs to move up a few degrees on the new one, and drop the blue.
04:47:29 <revenantphx> I'd venture green would work better as a link color.
04:47:40 <revenantphx> ...to the CSS editor!
04:47:51 <merijn> "Which Haskell Platform are you running?" 'de Bruin...'
04:48:13 <merijn> "Oh, you should totally upgrade to Oleg!"
04:48:18 <revenantphx> :)
04:48:26 <revenantphx> Or worse yet
04:48:34 <revenantphx> "Which Haskell Platform are you using?"
04:48:36 <revenantphx> "Oh, Haskell"
04:48:41 <revenantphx> "Well yeah, I meant which platform release"
04:48:44 <revenantphx> "Yeah. Haskell"
04:48:53 <ocharles> Why on earth does it have a flowery background?
04:49:02 <revenantphx> It doesn't look bad as a background.
04:49:04 <merijn> Or: Haskell Platform -> Haskell Platform' -> Haskell Platform'', etc
04:49:13 <revenantphx> merijn: We already have Haskell'
04:49:14 <ocharles> it doesn't make any sense, imo
04:49:20 <parcs> ocharles: http://www.reddit.com/r/haskell/comments/fkrq7/feedback_on_haskell_platform_site_anything_you/.mobile
04:49:23 <merijn> I bet that gets old after triple prime :p
04:49:25 <Saizan> the compression artifacts puzzle me though
04:49:29 <parcs> (remove the .mobile suffix)
04:49:32 <revenantphx> (haskell prime -> derivative of haskell... -> speed at which haskell develops)
04:49:36 <revenantphx> (ololololol calculus)
04:49:48 <revenantphx> Maybe when I get bored on the plane I'll redo the new release page.
04:50:01 <merijn> The only calculi I know have funny names like lambda, mu and pi :p
04:50:05 <revenantphx> We could just use flower names.
04:50:21 <revenantphx> Except the previous one used sunflowers, daisies and HEXAGONS
04:50:56 <revenantphx> parcs: If I have time, I'll reskin the platform staging site.
04:51:05 <revenantphx> I'm on a plane, so maybe I can do it then.
04:51:36 <vegai> by the way, is the Platform coming this month?
04:51:37 <revenantphx> Oh, one grammar thing.
04:51:40 <revenantphx> No March.
04:51:45 <vegai> ok
04:51:45 <revenantphx> Under the Comprehensive title
04:51:51 <ccvx> Saizan: Why doing so helps me solving the problem?
04:51:52 <revenantphx> s/Think of it like/Think of it as/
04:51:55 <vegai> are they waiting for ghc7.0.2?
04:51:56 <revenantphx> parcs: fix that ^
04:54:16 <revenantphx> Actually the grammar is a bit eh  in Cutting Edge too.
04:54:17 <Saizan> ccvx: because it's a good approximation of what actually happens, so you can see what things are kept around which will be those that are using the memory
04:54:33 <revenantphx> And Robust.
04:56:30 <Saizan> ccvx: if you're stuck you can also paste the code on a pastebin and ask here
04:58:21 <ccvx> Saizan: thx. here: http://codepad.org/WBOniwhN
04:59:15 <ccvx> code is large,but profile says that "parseInst",which is very simple, consume large memory..
04:59:36 <ccvx> so, i want to answer at least about parseInst.
05:01:40 <fram> Hi, I'm learning about the marvels of zippers, I read this article http://en.wikibooks.org/wiki/Haskell/Zippers , in which the formalism "Tree2 = 1 + Tree2 x Tree2" is used to describe a binary tree. I can understand this intuitively, but where can I get more information about the theory behind this?
05:01:43 <ccvx> typo. "i want to get an answer."
05:02:15 <Saizan> ccvx: when you return a "InstNm op (shiftR (shiftL w32 23) 29) (shiftR (shiftL w32 26) 29) (shiftR (shiftL w32 29) 29)" the fields of InstNm will point to thunks that represent the unevaluated shifts, not the Word32 directly, until you actually inspect those fields
05:02:49 <Saizan> ccvx: you should probably use strict fields for Inst
05:02:56 <pacak> I wrote some code using iteratee + iteratee-compress + iteratee-attoparsec. It was behaving fine on uncompressed files, but leaked on compressed ones. So i simplified code down to this - http://paste.pocoo.org/show/340837
05:03:24 <xplat> hm, some discussion above about what functional programming is
05:03:54 <pacak> first argument - gzip compressed file, second - size of block to consume. choose 10-100 to fast leak. larger values - leak slower.
05:04:30 <xplat> i've come to think the minimum bar for being a proper functional-CAPABLE language is the ability to write (.)
05:04:40 <Saizan> ccvx: and maybe {-# UNPACK #-} pragmas, so that the bare 32 bits will be stored directly inside the InstNm and InstSp constructors, rather than referenced through an indirection
05:05:56 <revenantphx> who's in charge of the Haskell Platform site?
05:06:12 <xplat> (.) tests the ability to take functions as arguments, to return functions containing nontrivial runtime information, and that your type system (if any) is flexible enough
05:06:15 <revenantphx> I'm bored and on the plane for a couple hours, so I might redo the CSS/images for fun.
05:06:29 <ccvx> Saizan: i tried to add ! to Inst's fields in order to make it strict, however, it seemes that thay have no effect. still now,consuming memory.
05:06:44 <Saizan> ccvx: http://codepad.org/nVxo9RnR <- try this
05:06:59 <ccvx> Saizan: let me try.
05:07:51 <robryk> xplat: so is c++0x functional-capable?
05:10:28 <Saizan> ccvx: spinCycle is the only place you're using parseInst in all your program?
05:11:51 <Saizan> ccvx: btw, i'd make all the fields of UM strict too
05:13:07 <ccvx> Saizan: yes.
05:13:45 <ccvx> Saizan: Unfortunately, the program you suggested also still consumes a lot of memory.
05:14:29 <xplat> 08:13 < merijn> revenantphx: Like what? "Famous type theorist names"? :p
05:14:32 <ocharles> fram: I really got zippers with the Learn You a Haskell chapter on them
05:14:43 <revenantphx> xplat: ?
05:14:48 <ocharles> fram: I'd suggest a read of that, then another read, to develop more intuition
05:14:54 <xplat> Mysterious Monad, Funky Functor, Amiable Applicative ...
05:15:02 <cheetah2003> yeah that site is very good, giving me a decent understanding of haskell 
05:15:14 <Saizan> ccvx: are you compiling with -O2 btw?
05:16:07 <ccvx> Saizan: sorry i made some mistakes. yes, your program consume less memory.
05:16:12 <ccvx> no, -O.
05:16:14 <merijn> xplat: Pretty Polymorphism? :>
05:16:28 <Saizan> ccvx: -O2 might help
05:16:38 <merijn> Luscious Lambda
05:16:47 <Saizan> ccvx: less memory but still a lot?
05:17:10 <cheetah2003> wierd.. i got it to build with no errors o.O
05:17:31 <cheetah2003> all i did was uninstall haskell and reinstall it, then did 'cabal install' and now it magically works flawlessly
05:19:03 <ccvx> Saizan: hmm, parseInst is not a lot consuming, but other functions still do.
05:19:05 <xplat> robryk: i think functional-capable, but low-level and with a horrid compilation model
05:19:19 <ccvx> Saizan: can i paste profile?
05:19:53 <xplat> merijn: Polymorphism and Lambda aren't typeclasses :)
05:19:59 <Saizan> ccvx: ok
05:20:25 <merijn> xplat: I know, but I didn't see an specification limiting us to that? :p
05:20:30 <cheetah2003> well thanks again for all yer help and the great tutorial site.. im off to tinker.. be well, you guys are great
05:21:05 <fram> thx ocharles, looks good
05:21:30 <xplat> merijn: this is why induction is an unreliable inference method :)
05:21:53 <xplat> (although it's okay when probabilistic)
05:22:26 <merijn> My mental system's inference method is monte carlo :>
05:23:09 <ccvx> Saizan: here: http://pastebin.com/WW6gegKh
05:23:19 <xplat> (or at least it is if you know the Ω for some turing machine, which you don't)
05:23:49 <xplat> merijn: monte carlo only works if you take enough samples ...
05:24:07 <ccvx> Saizan: buildoption: ghc(7.0.1) -O2 -fllvm -rtsopts -prof -auto-all -caf-all
05:24:13 <merijn> xplat: I didn't say my mental inference model was any good :D
05:24:34 <merijn> Why do you think I often make unwarranted assumptions? :p
05:28:02 <Saizan> ccvx: have you added the ! to the fields of UM?
05:28:17 <xplat> an assumption about that would be unwarranted on my part :)
05:28:37 <ccvx> Saizan: no. i'll try.
05:28:53 <Saizan> ccvx: i'd also change setRegVal to "setRegVal m ra !v = m {regs = (Seq.update (fromEnum ra) v (regs m))}"
05:29:42 <Saizan> ccvx: then try if it gets to a good performance when compiled without -prof, since profiling can prevent some optimizations
05:30:25 <ruang> -
05:31:14 <xplat> i think one of the hardest things to get used to when learning haskell is this:
05:32:15 <xplat> in most languages, control flow is mostly a mirror of the shape of the code, but dataflow is often implicit and nonlocal
05:32:26 <Saizan> ccvx: it'll require {-# LANGUAGE BangPatterns #-} at the top of the file
05:32:42 <xplat> in haskell, dataflow is mostly a mirror of the shape of the code, but control flow is often implicit and nonlocal
05:34:09 <xplat> all this ! stuff is used to determine the control flow in a haskell program, and at first it really looks like black magic
05:34:44 <Saizan> ccvx: and this: http://codepad.org/9Ym6vV4w
05:35:35 <merijn> xplat: All this computer and programming business is black magic anyway
05:35:38 <astroboy> How do I convert a lazy ByteString to a strict one?
05:36:05 <Saizan> ccvx: btw, for space usage problems you should use heap profiling, (e.g. run with +RTS -hc), but i guess that's harder to paste  
05:36:10 <xplat> B.concat . L.toChunks?
05:36:21 <Saizan> astroboy: S.concat . L.toChuncks, but it'll be slow
05:36:48 <astroboy> Saizan: I have to generate salts from Ints: http://hackage.haskell.org/packages/archive/pwstore-fast/2.0/doc/html/Crypto-PasswordStore.html#t:Salt
05:36:52 <Saizan> astroboy: in particular all of the lazy bytestring will be evaluated up front
05:37:12 <astroboy> Saizan: so how do I get from an Int to a bytestring?
05:37:57 <Saizan> astroboy: ah, if it's that short it won't matter
05:38:46 <astroboy> actually, I can simply use the "serialize" function
05:38:49 <astroboy> (I'm using happstack)
05:39:24 <astroboy> yeah it seems to work :P
05:39:50 <astroboy> no, it converts it to a lazy bytestring
05:41:27 <ccvx> Saizan: i tried.  but still consuming. and can i paste .ps file by hp2pc?
05:42:02 <Saizan> ccvx: if you find a way to
05:42:45 <Saizan> ccvx: anyhow, it might also be that Data.Seq is not the most appropriate structure here
05:48:10 <ccvx> Saizan: Great! Now, the program only consume about 10M. thank you.
05:49:02 <Saizan> ccvx: np :)
05:49:12 <ccvx> Saizan: what is alternative to Sequence?
05:50:20 <Saizan> ccvx: depending on the length an UArray could be better, it'll do much more copying but it'd keep the Word32 in a continguous chunk of memory
05:51:13 <Saizan> ccvx: while a Seq is implemented as a tree structure
05:52:39 <Saizan> ccvx: maybe a Seq (UArray Int Word32) would be the best of both worlds, but that'd be more complicated to manage
05:55:51 <ccvx> Saizan: Although my program often update element and UArray is immutable, does UArray still fit to the situation?
05:58:47 <Saizan> ccvx: well, the asymptotic performance for updating is better for Seq, but the memory use of UArray is better especially for base types like Word32 (and UArray only supports those), so it's not that easy to judge
06:00:04 <Saizan> ccvx: anyhow, if the memory use is reasonable now you should probably stick to Seq
06:00:16 <robryk> there is also this array
06:00:24 <robryk> which updates in-place and keeps a list of changes
06:00:48 <robryk> so that it is slow only if you look/modify a very `old' state
06:01:10 <Saizan> except that the implementation of DiffArray makes it quite slow in practice
06:01:25 <robryk> oh. why?
06:01:53 <Saizan> i don't know the details, but it's hard to find an use case where DiffArray is a win over plain Array
06:02:06 <ccvx> Saizan: i see. i'll try also UArray. thx. 
06:04:23 <ccvx> bye.
06:06:44 <nanothief> I read an interesting problem for instance declarations in a mailing post ( http://www.mail-archive.com/haskell@haskell.org/msg20536.html ), the goal was to make everything but one type an instance of a class. Is this possible in haskell currently?
06:07:12 <merijn> nanothief: Without explicitly enumerating all but one type? No, I don't think so
06:08:15 <nanothief> pity, it could be useful in a few situations, when you need to customize the behaviour of a typeclass for a single type. 
06:08:24 <hpc> you could be really gross
06:08:33 <hpc> and make a universal instance, then a specific instance for the exception
06:08:39 <hpc> and use a ghc extension
06:09:12 <nanothief> hpc: overlapping instances? I though that would reject such a program.
06:09:30 <taotree> I have something that derives from Num... is there an easy way to convert it to a Double?
06:11:40 <rwbarton> taotree: no, it might be a complex number for example
06:11:55 <rwbarton> :t realToFrac
06:12:01 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
06:12:24 <taotree> ok, thanks
06:12:37 <rwbarton> you need Real I guess
06:17:37 <ksf> \o/
06:17:41 <ksf> http://www.reddit.com/r/haskell/comments/fnc80/type_level_natural_numbers_ready_to_merge_into/
06:18:59 <koala_man> ooh
06:20:32 <hpc> ksf: will it be something like triple :: Vector 3?
06:20:53 <hpc> or triple :: Vector S(S(S(Z)))
06:21:04 <ksf> looks like it.
06:32:00 <ksf> Theorem a * b = b * a. Goddammit. Qed.
06:33:24 <Jafet> @pl \a b -> b * a
06:33:24 <lambdabot> (*)
06:33:50 <ksf> that's not the same.
06:34:18 <ksf> you're saying something (trivial) about lambda calculus, while the above theorem says something about multiplication.
06:40:25 <Jafet> ksf: yeah sorry, I am still rather new to proof by divine subpoena
06:40:50 <merijn> Jafet: Isn't that just a specific form of proof by intimidation?
06:41:07 <ksf> here's an example: http://hackage.haskell.org/trac/ghc/wiki/TypeNats/InductiveDefinitions
06:43:38 <kfr> Hahaha
06:43:42 <kfr> Proof by intimidation
06:44:00 <ksf> there's also reductio ad dementium lectoris.
06:44:36 <ksf> ...which is, stranegly enough, only ever referenced to as a latin term.
06:47:58 <Saizan> i wonder where does it say it's ready to be merged in..
06:48:42 <beegle> hi guys, i'm new to haskell, and i'm trying to create a function that removes the first occurrence of a number from a list, but i'm having some trouble, is it okay if i paste the code so you can see what i'm doing wrong?
06:48:47 <ksf> I think it's said the moment spj didn't tear it apart mid-air.
06:49:00 <ksf> @hpaste
06:49:01 <lambdabot> Haskell pastebin: http://hpaste.org/
06:49:51 <beegle> well it's just one line, so to make it simple i'll just paste it here: let remove xs n = if ((xs !! 0) == n) then return tail xs else return head xs : remove tail xs n
06:50:18 <quicksilver> beegle: you want "remove (tail xs) n" in that final bit
06:50:37 <Saizan> and to avoid the return's
06:50:38 <rwbarton> you don't want return anywhere
06:50:46 <beegle> i've tried that and i'm still getting a type mismatch
06:50:47 <quicksilver> beegle: your version calls remove with 3 arguments "tail","xs","n" where you wanted two "tail xs" and "n"
06:50:53 <quicksilver> yes, and ditch both returns.
06:51:28 <beegle> ah removing the returns did it, thanks. old habits...
06:51:29 <ksf> > let { remove n (x:xs) | n == x = xs ; | | otherwise = x:remove n xs } in remove 1 [1,3,1,4]
06:51:30 <lambdabot>   <no location info>: parse error on input `|'
06:51:37 <ksf> > let { remove n (x:xs) | n == x = xs ; | otherwise = x:remove n xs } in remove 1 [1,3,1,4]
06:51:37 <lambdabot>   <no location info>: parse error on input `|'
06:51:42 <Saizan> no ;
06:51:53 <ksf> > let { remove n (x:xs) | n == x = xs  | otherwise = x:remove n xs } in remove 1 [1,3,1,4]
06:51:53 <lambdabot>   [3,1,4]
06:52:00 <ksf> > let { remove n (x:xs) | n == x = xs  | otherwise = x:remove n xs } in remove 1 [21,3,1,4]
06:52:01 <lambdabot>   [21,3,4]
06:52:47 <ksf> ...someone else do the foldr.
06:53:52 <saml> > let { remove n (x:xs) | n == x = xs  | otherwise = x:remove n xs } in remove 1 [1,3,1,4]
06:53:53 <lambdabot>   [3,1,4]
06:53:59 <saml> that's bug
06:54:08 <saml> you has to remove the second 1 too
06:54:11 <ksf> nope, he said the first occurence.
06:54:24 <ksf> otherwise it's a vanilla filter.
06:54:25 <saml> oh i see 
06:54:33 <saml> why remove? maybe filter?
06:54:43 <saml> @type filter
06:54:43 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:54:51 <mun> is "\forall x y. f(x) = y --> P" equivalent to "\forall x. \exists y. f(x) = y & P"?
06:55:17 <saml> > let {remove n = filter (== n)}   in remove 1 [1,1,1,1,1]
06:55:18 <lambdabot>   [1,1,1,1,1]
06:55:22 <beegle> saml: i'm new to haskell, and i'm just learning; for a start, i'm just trying to make a basic sort algorithm. i've started learning haskell literally one hour ago.
06:55:29 <saml> > let {remove n = filter (~= n)}   in remove 1 [1,1,1,1,1]
06:55:30 <lambdabot>   Not in scope: `~='
06:55:38 <ksf> @slap saml
06:55:38 * lambdabot submits saml's email address to a dozen spam lists
06:55:41 <saml> > let {remove n = filter (/= n)}   in remove 1 [1,1,1,1,1]
06:55:41 <hape01> > 1
06:55:42 <lambdabot>   []
06:55:42 <lambdabot>   1
06:55:55 <ksf> what's that, erlang?
06:56:11 <saml> beegle, wow you are so smart
06:56:12 <hape01> > "erlang"
06:56:13 <lambdabot>   "erlang"
06:56:20 <hape01> :-)
06:56:23 <saml> > ke$ha
06:56:25 <lambdabot>   "ke$ha"
06:56:45 <ruang> "hare krihna"
06:56:53 <beegle> saml: that's not what i'm trying to say; the point is that i'm still learning basic syntax, and i needed help.
06:57:08 <saml> okay. i need help too. thanks
06:58:21 <ksf> beegle, using guards and pattern matching is idiomatic haskell
06:58:29 <ksf> using head/tail and ifthenelse not so much.
06:58:34 <parcs> beegle: which sort are you trying to implement?
06:58:50 <saml> idiomatic means bad?
06:59:03 <ksf> @wn idiomatic
06:59:04 <lambdabot> *** "idiomatic" wn "WordNet (r) 2.0"
06:59:04 <lambdabot> idiomatic
06:59:04 <lambdabot>      adj : of or relating to or conforming to idiom; "idiomatic
06:59:04 <lambdabot>            English" [syn: {idiomatical}]
06:59:11 <ksf> @wn idiom
06:59:11 <lambdabot> *** "idiom" wn "WordNet (r) 2.0"
06:59:11 <lambdabot> idiom
06:59:11 <lambdabot>      n 1: a manner of speaking that is natural to native speakers of a
06:59:11 <lambdabot>           language [syn: {parlance}]
06:59:12 <lambdabot>      2: the usage or vocabulary that is characteristic of a specific
06:59:14 <lambdabot> [8 @more lines]
07:00:10 <saml> i am an idiomatic chatter
07:00:17 <beegle> parcs: well, i guess it's some kind of bubble sort - i'm doing mysort l = minimum l : mysort (l with the first occurrence of the minimum taken out)
07:00:37 <beegle> ksf: okay, i'll look into that.
07:00:58 <hape01> let remove n = filter (/= n) in remove 'c' "abcdef"             I like Haskell
07:01:21 <hape01> > let remove n = filter (/= n) in remove 'c' "abcdef"
07:01:22 <lambdabot>   "abdef"
07:02:08 <saml> > sort "asdf"
07:02:09 <lambdabot>   "adfs"
07:02:19 <saml> @src sort
07:02:19 <lambdabot> sort = sortBy compare
07:02:24 <beegle> hape01: but that removes all the occurrences of the letter from the list, i'm just trying to take the first one out.
07:02:42 <EvanR> im thinking of using dynamically typed data
07:02:44 <hape01> yes you are right
07:02:58 <saml> EvanR, do not.
07:02:59 <EvanR> am i insane
07:03:02 <beegle> saml: i realize there's a built-in sort function, but i'm not doing this to solve a problem quickly, i'm just having fun
07:03:03 <saml> yes you are
07:03:15 <saml> @where sortBy
07:03:16 <lambdabot> I know nothing about sortby.
07:03:42 <EvanR> saml: so you dont think Data.Dynamic is good
07:03:58 <saml> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.3.0.0/src/Data-List.html#sortBy
07:03:58 <ceii_> > uncurry (++) . second tail . splitAt (=='a') $ "bcadada"
07:03:59 <lambdabot>   The section `GHC.Classes.== 'a'' takes one argument,
07:04:00 <lambdabot>  but its type `GHC.Typ...
07:04:14 <ksf> ghc uses a merge-sort whose implementation is only grokkable by whoever spend ages sifting through core.
07:04:26 <ceii_> @t splitAt
07:04:26 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:04:33 <ceii_> @type splitAt
07:04:34 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:04:41 <ceii_> > uncurry (++) . second tail . split (=='a') $ "bcadada"
07:04:42 <lambdabot>   Couldn't match expected type `a -> ([a1], [a1])'
07:04:42 <lambdabot>         against inferred t...
07:04:44 <parcs> beegle: ah, well just so you know, quicksort is the easiest to implement in haskell
07:04:44 <saml> really?
07:04:53 <saml> i find it easy to read those code.. like idiomatic
07:04:58 <hape01> @type uncurry
07:05:00 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:05:22 <saml> insertBy  is good
07:05:51 <saml> > insertBy bottom 3 []
07:05:51 <lambdabot>   Not in scope: `bottom'
07:05:54 <ceii_> > uncurry (++) . second tail . break (=='a') $ "bcadada"
07:05:56 <lambdabot>   "bcdada"
07:06:07 <hape01> bye
07:06:33 <quuuux> uncurry (++) . second tail . break (=='x') $ "bcadada"
07:06:36 <quuuux> > uncurry (++) . second tail . break (=='x') $ "bcadada"
07:06:38 <lambdabot>   "bcadada*Exception: Prelude.tail: empty list
07:07:04 <ceii_> :s
07:07:49 <quuuux> > uncurry (++) . second (drop 1) . break (=='x') $ "bcadada"
07:07:51 <lambdabot>   "bcadada"
07:10:08 <quuuux> @where report
07:10:08 <lambdabot> http://www.haskell.org/onlinereport/
07:11:21 <saml> so is haskell web scale?
07:11:29 <EvanR> yes
07:11:43 <ksf> haskell is fully buzword-compliant.
07:11:48 <quuuux> main = undefined -- infinite requests per second!
07:13:03 <xplat> no, that's one request per infinite seconds :)
07:13:30 <xplat> nice to see TypeNats getting into head
07:14:05 <xplat> makes me want to write a matrix library just to have an excuse to use it :)
07:16:20 <xplat> i feel like cmdargs is being insufficiently clear in its usage messages
07:17:19 <xplat> ‘Requires at least 2 arguments, got 1’ is not especially helpful.  i mean, they're named record fields, it could at least say what they're called ...
07:19:53 <saml> why can't i use filesystem as database?
07:20:04 <saml> as long as i lock the write access?
07:20:13 <xplat> argh, every time i update ubuntu i get stuck with that useless waste of disk lifetime, locate, again
07:20:23 <saml> i mean, only one thing can write to the specific file at a time
07:20:47 <xplat> there's no use having locate if your wide-area finds are rarer than the locatedb updates
07:20:51 <saml> xplat, use a real operating system.. windows or freebsd
07:21:01 <mux> o_O
07:21:22 <mux> I'm happy to read people recommending FreeBSD, but saying Windows next to it seems kinda wrong.
07:21:25 <aristid> saml: you can use the filesystem as a database, it's just not a good idea
07:21:27 <Jafet> saml: why can't you?
07:22:14 <saml> aristid, why is it not a good idea?
07:22:15 <mux> saml: you'd need to also protect the readers from unfinished writes
07:22:21 <xplat> saml: you can do mutual exclusion on a single file pretty easily in the filesystem, but updating more than one file consistently is a bear
07:22:22 <saml> let's say i index all files
07:22:46 <saml> is there a library that does ACID on file system?
07:22:55 <aristid> not really
07:23:03 <ksf> xplat, there's a locate replacement using inotify
07:23:05 <saml> can you write one and commit to github?
07:23:09 <aristid> no
07:23:14 <ksf> ...so it's updated in real-time.
07:23:21 <saml> aristid, i'll give you karma
07:23:25 <saml> @karma aristid ++
07:23:26 <lambdabot> aristid has a karma of 3
07:24:04 * xplat adds a nice 'exit 0' to the top of /etc/cron.daily/mlocate
07:24:20 <aristid> saml: if it relaxes you, actually all databases work on the filesystem, because they typically use a set of files for storage (or a single file, but that also resides on the filesystem)
07:24:26 <xplat> ksf: maybe i'll look at that later on, thanks
07:24:38 <mux> aristid: Oracle can be made to use raw disk space for speed
07:24:44 <xplat> saml: you do it like this
07:24:46 <xplat> ksf++
07:25:16 <EvanR> aristid: screw that, keep it all in memory
07:25:24 <saml> aristid, so why isn't there a ACID library?
07:25:36 <saml> how can i implement ACID? i'm gonna do it because you will not do it
07:25:46 <EvanR> good luck
07:25:56 <aristid> mux: it can be, but if saml prefers the filesystem, oracle supports that.
07:25:56 <saml> EvanR, is it hard?
07:26:02 <mux> saml: this discussion would be both more interesting and more productive if you explain to use what you really want in the end, I think
07:26:03 <EvanR> ....yes. are you joking?
07:26:08 <xplat> saml: i've seen a library in perl of all things that does ACID in-filesystem on posix, but it is not very secure and requires cooperation from concurrent writers (not readers, at least) to maintain true ACID semantics
07:26:11 <mux> s/use/us/
07:26:20 <saml> mux, i want nosql database
07:26:24 <robryk> saml: there are filesystems which have transaction support. they are rare, the only one with real support that i know of is the default one for solaris (the name escapes me now)
07:26:27 <saml> with posix semantics
07:26:31 <EvanR> then you dont want acid do you
07:26:32 <mux> saml: there are plenty of existing software for that
07:26:37 <aristid> robryk: zfs?
07:26:38 <saml> so, i mount the db.. do stuff
07:26:40 <robryk> yes
07:26:41 <ksf> xplat, or just switch to a full-blown desktop search like beagle.
07:26:42 <mux> NoSQL + ACID, uh?
07:26:46 <mux> take a pick.
07:26:52 <anincog> I've just read Conal Elliot's "Fixing lists" (http://conal.net/blog/posts/fixing-lists/), and I feel I've misunderstood something. His type for a vector with a statically typed length is very neat, but I'm left with a feeling of wanting to do similar things while *wrapping other datatypes*.
07:27:25 <saml> windows (NTFS)  has transactional api
07:27:28 <aristid> anincog: what do you mean?
07:27:30 <EvanR> screw 'nosql'
07:27:45 * mux seconds that
07:27:52 <anincog> For example: His Vec is essentially a collection of types Vec n for each natural number n, where each Vec n is essentially built as a list, right?
07:27:59 <ksf> yeah, ntfs is one of the rare things about windows that isn't inherently broken.
07:28:11 <EvanR> debatable, fragmentation
07:28:16 <aristid> anincog: Vec n is built analogously to a list, but not identically
07:28:22 <xplat> posix semantics + ACID is nearly a contradiction, or maybe it's nearly NOT a contradiction
07:28:28 <ksf> the kernel isn't too bad, either, if it just didn't have to provide that utterly broken windows api.
07:28:38 <aristid> anincog: there are crucial differences that make it impractical to implement it in terms of a list
07:28:38 <saml> i mean.. think about it.. http. there are resources.. /foo/bar  this can be posix directory.. when i do POST /foo/bar with x=a&y=b ...   I create  /foo/bar/.x   and /foo/bar/.y     .x and .y are files with contents a and b respectively 
07:28:54 <anincog> aristid: Am I correct to think about it as a collection of types, one for zero-length lists, one for length-1 lists, etc.?
07:29:02 <aristid> xplat: POSIX semantics are messy :(
07:29:05 <EvanR> saml: wouldnt you want PUT?
07:29:15 <aristid> anincog: yes.
07:29:20 <saml> EvanR, i mean.. yah
07:29:24 <ksf> ...and you have to pay $10k for a "server" version just to change a couple of configuration parameters in the scheduler.
07:29:29 <saml> that's why i want filesystem database
07:29:35 <fryguybob> blah?
07:29:37 <EvanR> then just use a filesystem
07:29:39 <saml> it's hierarchical. and acid
07:29:42 <xplat> i mean, from a program's-eye view you can certainly make them consistent, since posix semantics basically says 'if any programs are running then pretty much anything can happen between two system calls, or often in the middle of a system call'
07:29:47 <EvanR> its better than 'nosql'
07:29:49 <anincog> aristid: Good, then I'm not entirely confused. What I'm wondering, though, is there a way to do something similar, except actually storing the elements in some other data structure "behind the scenes"?
07:29:51 <saml> i want to be safe.. and also every write should update index
07:29:55 <ksf> sqlite
07:30:03 <ksf> or happstack-data
07:30:05 <aristid> EvanR: that's good, because 'nosql' is not even well-defined.
07:30:26 <aristid> well, it is, but the definition is nearly meaningless
07:30:41 <mux> xplat: that's not really true; POSIX guarantees for instance that an open() syscall that happens after a close() one on the same file will see all the previously made changes
07:30:43 <anincog> aristid: For example, a silly length-unspecified vector could be simply a list wrapped in a new type... could one wrap a length-unspecified type in something like what Conal makes?
07:30:47 <EvanR> aristid: yes. thats the cornerstone of web technology though. ill definedness
07:31:08 <aristid> EvanR: relax, man :)
07:31:16 <EvanR> im very relaxed
07:31:17 <mux> but this is the least one can expect from a filesystem :-)
07:31:39 * mux decides to drop this and go in week-end
07:31:46 <aristid> anincog: i'm confused as to which direction you want
07:31:50 <EvanR> aristid: necessary considering i do this for a living xD
07:31:51 <robryk> mux: what are `previously made changes' if there are many processes? for me that is a definition of changes
07:31:55 <anincog> aristid: I am too, I'll try to rephrase again :)
07:32:11 <mux> robryk: changes made by the process who did the close() call
07:32:37 <xplat> mux: POSIX may say it guarantees that, but it does not; another program could reopen the file and undo all the changes between close() and open(), then redo them later
07:32:52 <mux> xplat: that doesn't contradict what I just said one bit
07:32:58 <aristid> EvanR: usually web technologies really are ill-defined, but so is most software :)
07:33:15 <EvanR> until now
07:33:17 <anincog> aristid: Now, the way it seems to me that Conal creates his family of list types, i.e. a type for length 0 lists, a type for length 1 lists, etc., is to re-invent lists. It's all simple and nice. But is it possible to *wrap* the already existing type for an unlimited-length list to create such a family?
07:33:35 <xplat> mux: it does show that what you said is essentially meaningless in a multiprocess context, though
07:33:35 <roconnor> why people hatin' haskell's laziness? :(
07:33:49 * roconnor is reading comments in http://www.reddit.com/r/haskell/comments/fmp66/i_have_yet_to_learn_a_functional_programming/
07:33:55 <anincog> aristid: Suppose for example that one wants something like what he has, except one wants O(1) indexing. Then instead of re-inventing arrays, one would wrap the array datatype one already has in something that gives it length type-safety
07:34:19 <aristid> anincog: yes, but it's a bit less elegant.
07:34:20 <mux> xplat: you can have a transaction undoing changes that have been committed by a previous transaction in a database; this is kinda obvious and quite orthogonal to the guarantees of the fs or db
07:34:34 <xplat> the difference between 'can't see my write yet' and 'somebody unwrote my write' is indistinguishable to the process in question
07:34:51 <mux> the guarantees tell you that you'll be able to see changes made by others at some point, there's no discussion about whether you should be able to undo changes
07:34:55 <aristid> conflict resolution!
07:35:11 <mux> xplat: ACID never protected you against that either.
07:35:30 <anincog> aristid: Oh, I agree... but could you still give me a hint on how to do that? Suppose for example that arrays were super-difficult to implement, and that you'd not at all want to reinvent them. How would I go about creating a family of types where there's one type for length 0 arrays, one for length 1 arrays, etc., à la Conal?
07:35:51 * mux &
07:36:02 <xplat> mux: ACID guarantees that you see a consistent snapshot during a transaction (well, somewhat consistent; how consistent depends on isolation level)
07:36:16 <aristid> anincog: newtype LengthArray length a = XLengthArray (Array a)
07:36:42 <aristid> anincog: but there's a twist: you don't expose the XLengthArray constructor, and instead provide only safe "smart" constructors.
07:37:00 <anincog> aristid: Aha! This last sentence seems to be the crux.
07:37:07 <aristid> :)
07:37:22 <xplat> posix semantics makes no guarantees of anything unless concurrently running processes happen to be being particularly cooperative
07:37:27 <anincog> aristid: I've tried what you just wrote, but I felt I painted myself into a corner and couldn't quite figure out how to get something à la Conal's fixed lists out of it :)
07:37:27 <aristid> anincog: it's a cool trick, isn't it? :)
07:37:41 <anincog> but by exposing smart constructors only.. AHA :D
07:37:50 <anincog> aristid: Indeed it is
07:38:16 <xplat> or rather, posix semantics guarantees almost nothing from the process-side view, it guarantees things from the disk-side or VFS-side view
07:39:04 <anincog> aristid: Look who just joined ;)
07:39:21 <aristid> anincog: conal is a regular here :)
07:39:36 <anincog> aristid: Felt like a funny coincidence :)
07:39:41 <conal> what's up?
07:39:42 <aristid> heh
07:39:48 <EvanR> conal: your ears were burning
07:39:54 <anincog> conal: I was just asking some questions regarding you "fixing lists" blog post
07:39:59 <ksf> xplat, http://en.wikipedia.org/wiki/Recoll
07:40:03 * conal checks the irc log
07:40:04 <anincog> conal: Very interesting stuff, thanks a lot for writing it up
07:40:09 <aristid> conal: we were talking about something related to http://conal.net/blog/posts/fixing-lists/
07:40:13 <conal> anincog: :)
07:44:07 <conal> i've seen that technique recently -- making a newtype wrapper around an existing representation to add more static typing. and not exporting the repr. looks like it works out nicely.
07:46:10 <aristid> conal: where did you see it, if i may ask?
07:46:56 <conal> aristid: i'm trying to remember. poking around now.
07:47:35 <aristid> oh, just found this on reddit: http://hackage.haskell.org/trac/ghc/ticket/4385 - that would be especially nice for fixed-size arrays, which we were just talking about :)
07:48:18 <FUZxxl> Is there any good tutorial on FRP?
07:49:26 <conal> FUZxxl: the ideas? or a particular embodiment/system?
07:50:58 <FUZxxl> conal: How to use it in the real world, eg. how to interweave a GUI and an app using FRP?
07:52:03 <conal> FUZxxl: ah. not that i know of. there are some papers that may inspire ideas of how to. but probably not spelled out.
07:52:26 <aristid> somehow i expected conal to just link to a paper or blog post of his.
07:52:45 <conal> aristid: hm. not finding those examples of phantom-wrapping.
07:52:52 <FUZxxl> aristid: me too.
07:53:45 <conal> aristid: ah. i found some. https://github.com/yav/memory-arrays
07:53:47 <FUZxxl> It's just that I've not yet grasped the idea of FRP. I understood the basic principle, but I don't understand how to use it in practise
07:54:03 <ksf> FUZxxl, yes, there's a very good one: http://www.haskell.org/haskellwiki/Reactive/Tutorial/A_FPS_display
07:54:11 <aristid> conal: thanks
07:54:33 <ksf> otoh, though, you won't be able to get that thing running, as reactive seems to be even more broken now than back when I wrote it.
07:54:52 <FUZxxl> what do you mean?
07:55:08 <aristid> conal: oh, that even uses the GHC patch that i linked to :)
07:55:35 <ksf> reactive is notorious for having no side effects except the cpu getting hot when things get a bit more complicated
07:55:46 <FUZxxl> ksf: :D
07:55:49 <ksf> last time I tried, not even my fps display worked.
07:56:26 <ksf> yampa and grapefruit, while not as elegant by far, don't have those problems.
07:56:39 <xplat> is there any clue as to what keeps reactive from working?
07:56:57 <ksf> grapefruit might be a good place to start, just don't let yourself be intimidated by its record system.
07:57:16 <FUZxxl> Is there a tutorial for grapefruit?
07:57:48 <xplat> i always hate compromising on elegance, but there's only so far you can compromise on performance, and 'may or may not terminate' is a bit too far
07:57:50 <ksf> not that I know of, no.
07:57:53 <ksf> but there's examples.
07:58:14 <ksf> well, there's elerea, too, which looks a lot like reactive but uses iorefs under the hood.
07:58:20 <aristid> somehow i don't consider systems that are not reasonably performant to be elegant
07:58:23 <ksf> it's not push/pull, either.
07:58:53 <conal> xplat: there were some ghc run-time system bugs and probably some subtle termination/laziness bugs in my code. and i had a tough time tracking them down and then got on to other things. one of these days i'll get back to it or someone else will help me figure it out.
07:59:39 <ksf> it doesn't help that the reactive code isn't particularily straight-forward
08:00:02 <xplat> it might be better if 'unamb' were a primitive
08:00:11 <conal> xplat: yeah. that'd help.
08:00:21 <conal> xplat: assuming it worked correctly.
08:00:48 <xplat> well, yes, having your primitives work correctly is always a big help :)
08:00:58 <ksf> would unamb be so hard to tack onto ghc, even just a version to experiment with?
08:01:57 <conal> ksf: i doubt it'd be hard for someone who really understands sparks etc.
08:02:51 <aristid> ksf: your fps tutorial deliberately lacks a low-pass filter for the fps display? :)
08:03:35 <conal> ksf: are there parts of the reactive sources that are particularly difficult?
08:03:48 <xplat> aiui ‘unamb’ is basically pretty similar to ‘race’ in promise systems, only the user is required to swear on a stack of bibles that the two sides won't return different answers
08:04:02 <ksf> aristid, kinda, yes. I don't believe in limiting framerate before it annoys me.
08:04:14 <ksf> conal, It's just the general conceptuall wall I hit.
08:04:34 <xplat> (where ‘different’ means ‘lacking a lub in the information order’)
08:04:38 <ksf> that was more than a year ago, things might look different to my eyes now
08:04:39 <aristid> ksf: i don't mean limiting framerate, i mean just the display of the framerate
08:04:54 <aristid> ksf: using only the last frame, the framerate might jigger erratically
08:04:56 <conal> xplat: right -- operationally. and the meaning is very simple: combines information content, ie least upper bound.
08:05:12 <ksf> ah. but that's dampening, not a low-pass.
08:05:18 <conal> xplat: restricted to flat types and information-consistent values
08:05:26 <aristid> ksf: oh, sorry, then i got those confused
08:05:48 <aristid> i liked the sound of the word tho, so i used it
08:06:14 <ksf> hmmm I think my terminology just broke.
08:06:32 <ksf> the thing I'd generally do to make the thing readable is to provide a graph.
08:07:36 <ksf> ...which would also tell you the length of stutters.
08:09:11 <aristid> ksf: a histogram!
08:09:19 <xplat> and it so happens that uncurry unamb . (id &&& id) is a strict function
08:09:24 <ksf> do I look like a statistican?
08:09:32 <aristid> ksf: yeah.
08:10:56 <xplat> (in particular, it is id)
08:12:12 <aristid> @hoogle unamb
08:12:12 <lambdabot> No results found
08:12:20 <xplat> (so i guess that fact isn't particularly interesting :) )
08:13:31 <xplat> aristid: unamb is from the ‘reactive’ library, you can also find information at conal's blog http://conal.net/blog/tag/unamb/
08:13:39 <ksf> I wouldn't call it surprising, no.
08:14:26 <aristid> unamb . (a &&& a) is semantically equivalent to just a, isn't it?
08:14:32 <xplat> yes
08:15:06 <xplat> i'm a little new to analyzing functions for their strictness level, so i guess i can get overexcited sometimes
08:15:23 <hpc> :t unamb
08:15:24 <lambdabot> Not in scope: `unamb'
08:15:29 <ksf> conal, did you consider not using threads and instead run two co-routines manually?
08:16:04 <conal> ksf: i don't think so
08:16:41 <ksf> xplat, well, I'd say it's quite obvious that it's strict becaues unamb is about ensuring that one computation actually finished, then killing the other one.
08:16:49 <ksf> it has to be strict.
08:20:30 <jmcarthur> ksf: data Computation a = Delay | Now a    <-- this is a monad that can express interleaved racing and such. works for amb (forms a MonadPlus with it), but i don't know an elegant way to generalize it to something like lub
08:21:14 <jmcarthur> doh
08:21:15 <byorgey> jmcarthur: do you mean  Delay (Computation a) ?
08:21:18 <jmcarthur> yes
08:21:23 <byorgey> ok, makes more sense =)
08:21:28 <jmcarthur> data Computation a = Delay (Computation a) | Now a
08:22:22 <jmcarthur> Free Identity
08:22:50 <ksf> well, I didn't have any particular model in mind.
08:23:23 <ksf> just the general idea of implementing green "threads" to circumvent all threading pains.
08:23:47 <ksf> inserting yields at the right spots, in existing code, might prove tricky
08:24:04 <jmcarthur> i think if we had hierarchical scheduling (is there a better name?) then unamb's current implementation could work a bit better
08:24:30 <jmcarthur> that is, a child thread steals some time from its parent thread
08:24:46 <jmcarthur> rather than being able to take the exact same time slice as any other thread
08:24:55 <ksf> doing that would of course make reactive essentially single-threaded again, but then I was never thrilled by that kind of multithreading, anyway.
08:25:12 <jmcarthur> it would have to be an alternative scheduler though. sometimes you *want* all threads to have the same shot
08:25:45 <jmcarthur> yeah i think the multithreadedness of reactive is not necessarily a feature
08:25:47 <xplat> ksf: but unamb can't be strict on either argument individually or it won't work, it can only be strict on the two of them as a whole
08:26:08 <ksf> no, it's strict on either one of them.
08:26:13 <ksf> whichever finishes first.
08:26:20 <phrackSipsin> anybody want to help out a noob? Can't work out why i get a "parse error on input `|'" in http://hpaste.org/44112/chaincode
08:26:35 <mauke> phrackSipsin: line 2: =
08:26:45 <phrackSipsin> gah
08:26:46 <phrackSipsin> so simple
08:26:56 <phrackSipsin> thanks
08:27:07 <conal> ksf: there's a simpler way to reach that conclusion, without invoking operational thinking.
08:27:57 <conal> ksf: just noting that _|_ `lub` _|_ = _|_
08:28:07 <xplat> ksf: it can't be strict on whichever finishes first, because whichever finishes first finishes; therefore it is not _|_ and strictness is meaningless
08:28:26 <ksf> .oO( fsvo "simple" )
08:28:27 <jmcarthur> another thing i don't like about the current threaded implementation is that if either argument doesn't allocate then that argument might monopolize the cpu entirely
08:28:57 <conal> jmcarthur: yep.
08:30:18 <conal> and unamb could be (much?) more efficient if we knew how to detect when a value has been whnf'd to bottom.
08:30:47 <jmcarthur> you mean in some way other than catching an exception?
08:31:14 <jmcarthur> oh you mean before even forking a thread
08:31:20 <conal> jmcarthur: right.
08:31:47 <conal> edwardk added code to check already-whnf'd, but we have to treat _|_ and non-_|_ differently in that case.
08:31:53 * ksf senses that could be a job for greenspun's tenth
08:31:54 <xplat> would you ever see a value already known to be bottom as an argument to a pure function?
08:31:59 <jmcarthur> actually, it doesn't even matter if one has been whnf'd to bottom. it only matter if either of them have been whnf'd, doesn't it?
08:32:03 <jmcarthur> *matters
08:32:10 <jmcarthur> whether or not it's actually bottom?
08:32:17 <mun> if i have a theory T with symbols f and c and an axiom "f(c) = 0", then would a theory T' with symbols f, g and c and axioms "f(c) = 0" and "forall x. g(x) = 0" be a conservative extension of T?
08:32:28 <jmcarthur> oh, right, you still have to detect which it is
08:32:54 <xplat> jmcarthur: if one of them is a known bottom you still have to run the other to WHNF unamb
08:33:10 <jmcarthur> either way, you can avoid forking a thread if an argument is in whnf, but you have to know whether it's bottom or not
08:33:13 <conal> jmcarthur: exactly.
08:33:37 <jmcarthur> xplat: yes, but there's no need to forkIO
08:33:46 <byorgey> mun: are you just curious, or is this a homework question?
08:33:51 <xplat> jmcarthur: true
08:34:49 <xplat> i guess you could get a known bottom if another thread or something under an exception handler already forced it due to sharing/laziness
08:35:09 <jmcarthur> conal: well, you could still avoid forking by returning the argument that's in whnf and doing some unsafe exception catching stuff with it
08:35:16 <mun> byorgey, the former -- i'm reading the wikipedia article http://en.wikipedia.org/wiki/Extension_by_definitions and it seems to imply that T' is a definitional extension of T, but the book "Model Theory" by Hodges seems to suggest otherwise.
08:35:53 <byorgey> mun: ok, well, according to the definition of "conservative extension" I know, yes, it would be a conservative extension
08:36:24 <byorgey> mun: every theorem of T is still provable in T', and T' can't prove any extra theorems that are expressible in the language of T
08:36:33 <conal> jmcarthur: oh, hm. sounds right. and fairly simple.
08:36:37 <xplat> mun: i'd say 'not conservative' because the statement ∃x. f(x) != 0 is consistent with the first theory
08:36:46 <jmcarthur> conal: maybe do something with `evaluate' and `catch' or something
08:36:49 <mun> byorgey, "Model theory" says that T' would have to be T U M where M is a set of explicit definitions. but it seems "g(x) = 0" isn't an explicit definition.
08:36:55 <xplat> mun: not every element in your model needs to have a constant symbol
08:37:04 <conal> jmcarthur: yeah.
08:37:40 <mun> xplat, but is "exists x. f(x) != 0" not consistent with T'?
08:38:06 <mun> xplat, I only augment T with a new symbol g
08:38:13 <mun> and an axiom about g.
08:38:18 <xplat> mun: oh, that's with g.  ∃x. g(x) != 0 is consistent with T but not T'
08:38:35 <byorgey> xplat: but ?x. g(x) != 0  cannot be stated in the language of T
08:38:39 <xplat> mun: oh, you originally said that T included g
08:38:41 <mun> xplat, but g wasn't in the language of T
08:39:13 <xplat> oh, or i misread it due to failing to track parallel lines properly :(
08:39:47 <xplat> okay, yeah, i would call that a conservative extension.  after all GNB is considered a conservative extension of ZF
08:40:04 <byorgey> mun: hmm, re: model theory and explicit definitions etc., I don't know, I'm not familiar with that part of the theory
08:40:28 <mun> xplat, byorgey then would T' with another axiom involving both f and g, e.g., \forall x. f(x) + g(x) = 0 still make T' a definitional extension?
08:40:55 <mun> is this axiom "in" the language of T? one symbol is, but one symbol is not...
08:42:13 <xplat> mun: you don't even have + in the language
08:42:40 <mun> xplat, right. let's suppose T has +
08:43:01 <xplat> if you had + in T'' then it would still be a conservative extension, but when you added a cancellation law it would not be
08:43:17 <peoro> What is `-' in `(-3)'? a function? doesn't it conflict with the binary `-' infix function?
08:43:43 <byorgey> peoro: it is unary prefix negation.  it does conflict, which is why you must often put negative numbers in parentheses
08:43:47 <xplat> since then you could cancel out g(x) from the two axioms and get ∀x. f(x) = 0
08:44:00 <byorgey> peoro: in (-3) the - is not a function, just syntax
08:44:17 <peoro> byorgey, ok, got it
08:44:49 <conal> peoro: and binary "-" is the one operator that cannot be used in a right section.
08:45:06 * Twey shudders.
08:45:21 <c_wraith> I wonder if removing the unary - by simply requiring negative numbers to be written as (0 - 5) would have hurt haskell too much
08:45:35 <c_wraith> ...  probably, given how much people complain about silly things
08:45:40 <peoro> conal: yeah, I was exactly wondering about it... weird!
08:45:50 <kulakowski> c_wraith: or doing it ML style
08:46:00 <conal> peoro: yeah. definitely weird. in a language that values consistency.
08:46:12 <peoro> I guess that's why we've got `subtract'
08:46:30 <mun> xplat, alright. so T'' with the cancellation law is not a conservative extension because T'' can prove more theorems about the language of T than T?
08:46:33 <fryguybob> > let a - b = subtract in (-3) 2 -- hehe
08:46:34 <lambdabot>   -3
08:47:01 <xplat> i wonder if writing sections as (_+3) would have ultimately worked better
08:47:11 <c_wraith> fryguybob: all you demonstrated there is the strange function instance for Num in lambdabot :)
08:47:24 <xplat> mun: right
08:47:36 <mun> byorgey, ah ok. i'll keep looking then. FYI, they are defined here: http://books.google.co.uk/books?id=Rf6GWut4D30C&pg=PA60&lpg=PA60&dq=model+theory+explicit+definitions+hodges&source=bl&ots=IbRDSr80OY&sig=OYdP7YWV-hTZ4DezGgGQ_kPCA30&hl=en&ei=6qheTeC-L4as8AOQtbB8&sa=X&oi=book_result&ct=result&resnum=1&ved=0CB8Q6AEwAA#v=onepage&q=model%20theory%20explicit%20definitions%20hodges&f=false
08:47:42 <fryguybob> c_wraith: Yup, though I don't think it is all that strange.
08:47:42 <Twey> c_wraith: Or, heck, just making the spacing of operators mandatory
08:48:32 <xplat> could have allowed arbitrary prefix operators if sections had an explicit placeholder
08:48:40 <c_wraith> I'd be ok with that, but it's yet another tiny thing people would freak out over
08:48:40 <Twey> Yeah
08:48:54 <Twey> Lambdas with anonymous arguments would be cool, too
08:49:06 <Twey> (%2 + %1) = flip (+)
08:49:33 <Twey> Clojure does that, IIRC
08:49:40 <xplat> that's getting a little far from the spirit of haskell though.  more like scala/perl6
08:50:06 <Twey> xplat: Nah, I don't think so
08:50:27 <xplat> the placeholder is just a reskinning of the existing section syntax
08:50:38 <mun> xplat, thanks a lot
08:50:42 <kulakowski> Twey: I would like that. I doubt I'm the only one who would prefer this-name over thisName or this_name or this'name
08:50:55 <Twey> Anonymous arguments are just a reskinning of lambdas
08:51:02 <Twey> kulakowski: Yeah, certainly
08:51:02 <xplat> flip f x = (`f` x)
08:51:21 <peoro> how can `succ' work with Fractional numbers? is Fractional an Enum? Why?
08:51:34 <Twey> peoro: All Nums are Enums, IIRC
08:51:37 <xplat> Twey: yeah, but they raise a scope issue that the section version does not
08:52:18 <c_wraith> peoro: it works...  um...  interestingly
08:52:22 <c_wraith> > succ 3.5
08:52:23 <lambdabot>   4.5
08:52:32 <peoro> Twey, yes, but why?
08:52:42 <c_wraith> > enumFromThenTo 1 1.2 2
08:52:43 <lambdabot>   [1.0,1.2,1.4,1.5999999999999999,1.7999999999999998,1.9999999999999998]
08:53:00 <Twey> Not really sure… Num is a bit weird
08:53:18 <c_wraith> peoro: mostly to allow list syntax to use floating point numbers
08:53:25 <xplat> heh, maybe binary minus should be -- and single -s should be allowed in identifiers or as a prefix operator
08:53:26 <c_wraith> > [1,1.2..2]
08:53:27 <lambdabot>   [1.0,1.2,1.4,1.5999999999999999,1.7999999999999998,1.9999999999999998]
08:53:44 <Twey> xplat: Or you could just make spacing operators mandatory :þ
08:54:01 <xplat> a lot more people want - in identifiers than any other operator/punctuation character
08:54:13 <peoro> c_wraith: oh, list expansion works with Enum? Ok, this makes sense...
08:54:25 <Twey> Yeah, but you get it as a consequence of requiring spacing
08:54:39 <c_wraith> peoro: yes, the various list expansions use enumFrom, enumFromTo, and enumFromThenTo
08:55:04 <Twey> Along with clearer code, unambiguous minus, and a greatly expanded namespace for both operator and non-operator identifiers
08:55:17 <peoro> c_wraith: ok, thanks, wasn't aware of that
08:56:02 <xplat> Twey: requiring extra spacing doesn't seem to me to make clearer code
08:57:19 <xplat> 1 + 3*x + 4*x^2 is a lot easier to read than 1 + 3 * x + 4 * x ^ 2, or even the version with parens
08:57:58 <Twey> xplat: Consistency makes for clearer code
08:58:06 <quicksilver> yes, it is, but of course using whitespace to encode precedence is redundant
08:58:14 <quicksilver> and being redundant, it has the capability to be misleading
08:58:18 <quicksilver> 1+3 * x
08:58:19 <Twey> Yeah
08:58:27 <xplat> Twey: then why infix operators at all?  just use sexprs?
08:58:35 <Twey> xplat: They save on brackets
08:58:47 <Twey> (though I'm not averse to the idea :þ)
08:58:57 <xplat> Twey: do those cost money now?
08:59:00 <quicksilver> I don't really like precedence except for *very* well understood cases.
08:59:05 <quicksilver> I'm happy with + and *
08:59:11 <Twey> Yeah
08:59:14 <quicksilver> and I"m happy with $ which is 'less than everything else'
08:59:30 <quicksilver> for any other pair of binops I'll normally parenthesise.
08:59:45 <kulakowski> quicksilver: I agree.
08:59:49 <quicksilver> in haskell, in particular, precedence is not local
08:59:52 <Twey> I avoid brackets like the plague in Haskell
08:59:53 <xplat> quicksilver: hlint warnings, compiler warnings, or even enforcement, would not be unwelcome to me in the case of spacing-implied precedence conflicting with declared precedence
08:59:54 <quicksilver> (it can be defined in other modules)
08:59:59 <quicksilver> and that's hideous.
09:00:01 <kulakowski> xplat: How often are you writing polynomials in haskell? :)
09:00:01 <fryguybob> > (\x -> 1 + 3*x + 4*x^2) 2
09:00:02 <lambdabot>   23
09:00:07 <Twey> But that doesn't mean I like how I do it, necessarily
09:00:07 <fryguybob> > (1 + (3*) + 4*(^2)) 2
09:00:08 <lambdabot>   23
09:00:10 <quicksilver> xplat: sure. warnings would be a good solution.
09:00:36 <Twey> Bracket-implied precedence is nicer, because it actually means something.
09:01:11 <Twey> 1 + (3 * x) + (4 * (x ^ 2))
09:01:14 <Twey> Is fine
09:01:29 <Twey> (though completely redundant, I'd argue)
09:02:24 <monochrom> draw boxes around subexpressions to show precedence
09:03:35 <xplat> anyway ‘our code is consistent and therefore readable’ is the Deadly Virtue of java and python
09:04:16 <c_wraith> python code consistent?  since when?
09:04:44 <xplat> which makes them attractive nuisances that destroy millions of lifetimes of man-hours
09:05:06 <monochrom> consistent code upon an inconsistent basis
09:05:49 <monochrom> "you can define 'functions' but not 'operators'" alone is already inconsistent enough
09:12:30 <peoro> is it possible to write a function that behaves differently according to its paramaters type?
09:13:24 <c_wraith> peoro: only using type classes.
09:13:38 <c_wraith> peoro: which also allow a function that behaves differently depending on its return type.
09:13:51 <c_wraith> :t read
09:13:52 <lambdabot> forall a. (Read a) => String -> a
09:14:02 <c_wraith> > read 5 :: Int
09:14:02 <peoro> ok, got it
09:14:03 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
09:14:03 <lambdabot>    arising from the literal `...
09:14:09 <c_wraith> > read "5" :: Int
09:14:10 <lambdabot>   5
09:14:13 <c_wraith> > read "5" :: String
09:14:14 <lambdabot>   "*Exception: Prelude.read: no parse
09:14:36 <c_wraith> Same arg, the only difference is the return type.
09:15:10 <peoro> yup, already used type classes (to implement show for a custom Tree type) while reading "learn you a haskell for great good"
09:30:36 <dark> I have a problem. I want to receive a command, an internal state, and return a reply, and a new state. if I model this using the state monad, my "reply" (say, using put inside do { }) would just set a new value for the state. I think I don't want to store my reply (that is a string) in the state
09:30:59 <dark> ocharles, are you here? it's for that mud/interpreter I showed you
09:31:44 <dark> the user types a command, I parse it, then I use both the current state and the command to manufacture a reply (a string) and a new state
09:32:00 <ocharles> dark: sure, what's up
09:32:09 <rwbarton> doSomething :: Command -> State InternalState Reply
09:32:28 <dark> by State you mean Control.Monad.State?
09:32:29 <peoro> I'm trying to build frag ( http://www.haskell.org/haskellwiki/Frag ), but it fails to link: it reports many errors about glut... did anybody manage to build it, or knows why I'm getting these errors?
09:32:32 <ocharles> dark: yes
09:32:51 <xplat> dark: just use do { put newState; return reply }
09:33:10 <dark> aaaah
09:33:14 <dark> interesting õ.o'''
09:33:16 <dark> why not ST?
09:33:42 <ocharles> to turn the question around, why ST?
09:33:55 <dark> I don't know ST and the differences to State
09:33:57 <ocharles> ST is for strict state, do you need that?
09:34:02 <dark> oh no
09:34:21 <xplat> ocharles: actually that's not exactly what ST is for
09:34:37 <dark> I think that eventually I want it to act on its own (without needing a command), so maybe I want something related to IO?
09:34:58 <dark> that is: with a timer, that would check some state and send messages without prior command
09:35:01 <xplat> ST is for using a bunch of state without defining what it all is ahead of time
09:35:25 <xplat> more general, less typesafe
09:35:46 <xplat> also, on the operational level, it lets you use arrays with in-place update
09:36:13 <xplat> which is a large reason why people use it
09:38:14 <dark> also I want to make many users connect to it. like, via tcp. I think I'm going to use some tcp wrapper like ucspi-tcp and write some glue code in another language so that my program would use just stdin/stdout (because I already got it working) to listen to a port and talk to many hosts
09:38:31 <dark> unless I could make it simpler in haskell proper..
09:40:13 <mun> xplat, hi again.
09:41:37 <ksf> whoever wanted to write xapian bindings, I fully suport that. I just installed recoll and that thing is *fast*.
09:43:19 <ocharles> ksf: that's me, I'm working on them atm
09:43:21 <mun> xplat, by the way, again with conservative extensions, according to wiki, if T is consistent, then a conservative extension of T must also be consistent. is it only because an inconsistent extension would be able to prove all sentences, thus it can prove even those about the language of T?
09:43:32 <ocharles> ksf: I'm trying to post my first public api review to haskell cafe atm in fact
09:43:35 <dark> rwbarton, on doSomething :: Command -> State InternalState Reply , can doSomething really do something without receiving, as parameter, the old state? (I'm reading on state monad, but I find this puzzling)
09:44:36 <dark> it is like doSomething had the state inside itself, maybe because doSomething was really created by createDoSomething :: InternalState -> Command -> State InternalState Reply ?
09:44:43 <rwbarton> @src State
09:44:43 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:44:54 <ocharles> told.
09:45:02 <dark> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-State-Lazy.html i'm here
09:45:56 <rwbarton> something of type State InternalState Reply is realy just a function that accepts an InternalState
09:46:19 <dark> o.o
09:46:19 <mun> xplat, but it also says that "conservative extensions do not bear the risk of introducing new inconsistencies." but showing consistency is undecidable, so is showing T' is a conservative extension of T also undecidable?
09:48:43 <ksf> xapian seems the perfect thing to beef up haskell.org. have a search that spans wiki+trac *and* all the source. and the community server.
09:50:10 <ocharles> ksf: well, looking for help on the bindings... if you're interested it's all at http://github.com/ocharles and one other contributor and myself hang out in #xapian
09:51:39 <heatsink> I'm trying to get a stack trace of an exception with the "+RTS -xc" flag.  However, the trace stops at a CAF that is just a wrapper around "error".  I really want the stack trace of where the CAF was called from or where the CAF was forced.  Is there a way to get that?
09:52:20 <rwbarton> dark: I think of it like this: Any monad can be looked at from (at least) two points of view, an external one and an internal one.
09:53:17 <ksf> ocharles, any particular reason why your'e not using c2hs?
09:53:26 <rwbarton> The external one is just whatever the monad is defined as, so here State s a is a function that takes an old state and returns a new state and a result.
09:53:29 <ocharles> ksf: Xapian is C++ so I have to write C bindings
09:53:37 <ksf> (that's not rhetoric, there actually are valid reasons)
09:53:40 <ocharles> ksf: could use c2hs on them, but I'm new to everything
09:53:49 <ocharles> ksf: I just like to start from first principles and see what happens :)
09:53:53 <rwbarton> The internal one is what code inside the monad sees
09:54:19 <ksf> ...because what you have is quite boilerplatey.
09:54:25 <paolino> hello, is ghc runtime system freeing unused memory ?
09:54:33 <dark> rwbarton, so runState just applies the state, ok
09:54:38 <rwbarton> so for State s, we know there is something called the "state" (of type s) which we can get and put
09:54:50 <ocharles> ksf: well, the Search.Xapian.FFI is boilerplatey, the Search.Xapian less so, but yes, still a bit
09:54:51 <dark> rwbarton, but how can a function receive a command, and, without having any prior state, return a state?
09:55:09 <ksf> ...all that withForeignPtr stuff is boilerplate.
09:55:10 <heatsink> paolino: The RTS will garbage-collect memory, but I don't think the heap will shrink
09:55:18 <rwbarton> we don't ask where it is stored, or how it got its initial value
09:55:39 <ocharles> ksf: yes, I don't disagree, but I haven't written enough of it yet to decide on an abstraction
09:56:05 <rwbarton> well, there are two answers
09:56:45 <paolino> heatsink: adding a "last (show (s,vc)) `seq`" reduce memory from 144 meg to 30 meg, after it reached 70 for a while. without it stays at 144 no way it comes down
09:57:22 <dark> rwbarton, but.. if it is functional, a given function that doesn't receive a state always use the same state, and, when created, had to receive it anyway
09:57:24 <rwbarton> the external one is, Command -> State InternalState Reply is really just Command -> InternalState -> (InternalState , Reply)
09:57:36 <dark> ah
09:57:38 <ksf> ocharles, c2hs has the additional advantage that it's type-safe. i.e. if your header files are right, your ffi is good.
09:57:46 <rwbarton> so the old state is passed in
09:58:00 <dark> ah.. the old state will be passed when i run the monad
09:58:04 <rwbarton> The internal one is "using get"
09:58:06 <ksf> I don't know the xapian api, though.
09:58:12 <ocharles> ksf: right, but my ffi is typesafe here too. c2hs just automates this process
09:58:32 <ocharles> it's not like it produces different code. at the end of the day /somewhere/ will need to have a list of foreign imports
09:58:36 <ksf> ocharles, yes, but you can make errors writing it. c2hs typechecks everthyng.
09:58:46 <dark> ..so the function that just receives the command isn't returning the reply, it's returning something that, when given the prior state, will return the next state and reply
09:58:47 <heatsink> paolino: That sounds like a space leak
09:59:01 <ocharles> ksf: understood
09:59:06 <dark> rwbarton, I think it's clearer now, thanks
09:59:20 <ocharles> ksf: I'm learning enough at the moment and this is working out ok for now so I'm just continuing down this path
09:59:21 <ksf> http://hpaste.org/44114/part_of_freetype   as an example
09:59:27 <rwbarton> Yes, that's how it really works
09:59:28 <ksf> I should really finish up those bindings
09:59:37 <ocharles> as the project gets more complex, I'm sure someone or me will change it to use c2hs if it seems appropriate
09:59:43 <ksf> ...or at least clean up what I have and release it to the mob.
09:59:54 <heatsink> paolino: Some programs will save references to unused data, which prevents garbage collection of that data.  If that is the case, using seq to force evaluation of the retainer will solve the problem.
10:00:13 <paolino> heatsink: yes, I'm confused by the fact that it comes down
10:00:13 <heatsink> paolino: Profiling is useful to find space leaks.
10:01:18 <rwbarton> Once you understand that, the internal view becomes a helpful conceptual shortcut
10:01:49 <paolino> heatsink: but maybe it's not ghc, it's hdbc, I should learn profiling anyway
10:02:25 <ksf> ocharles, http://hpaste.org/paste/44114/part_of_freetype_annotation#p44115 is the generated code, to give you a feeling.
10:03:36 <heatsink> paolino: The memory behavior can be affected by any of the places that a variable is used, so it's hard to explain without analyzing the whole code
10:04:42 <heatsink> paolino: In this case, I would guess that "s" or "vc" uses a lot of memory before it is evalauted, and less memory after it is evaluated
10:09:06 <jsgf> morning all!
10:09:12 * ocharles doffs hat
10:09:17 <FUZxxl> good evening.
10:10:00 <jsgf> I'm trying to get the new haskell-platform bootstrapped, and I'm stumbling over protocol-buffers not compiling with ghc 7 (http://hackage.haskell.org/packages/archive/protocol-buffers/1.8.0/logs/failure/ghc-7.0)
10:10:41 <jsgf> I gather from http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7 that should just be a matter of sticking a type signature in there somewhere, but I'm at a loss
10:11:51 <jsgf> any clues about how to solve this?
10:12:29 <Saizan> jsgf: try adding NoMonoLocalBinds as a LANGUAGE extension
10:13:10 <robryk> where are sources for DiffArray? I don't see them in array package, and hackage claims it should be there
10:14:24 <heatsink> jgsf: Just from looking at the error message, I think the functions that need type signatures are the ones listed under "The following variables have types that mention t"
10:14:25 <Saizan> robryk: you've to look at version 0.2 sources
10:14:31 <robryk> oh. thanks.
10:15:02 <robryk> why did it get removed?
10:15:05 <heatsink> jgsf: And you'd need to give it a type signature that's polymorphic in the problematic variable
10:15:09 <jsgf> Saizan: ah, OK.  I had misread the page as suggesting *removing* NoMonoLocalBinds as a suggestion.  But adding it does get the package to build - thanks!
10:15:11 <heatsink> *jsgf
10:15:26 <dark> newtype ListT m a = ListT { runListT :: m [a] }
10:15:26 <jsgf> heatsink: NoMonoLocalBinds got me going
10:15:34 <dark> is this a 'record'?
10:15:35 <heatsink> ok then
10:17:10 <Saizan> dark: yeah, with a single field called runListT
10:18:00 <siracusa> robryk: It's in a separate package now, diffarray.
10:18:30 <robryk> thank you
10:19:51 <dark> is it equivalent to newtype ListT m a = ListT (m [a]) then runListT (ListT v) = v ? (why newtype and not data?)
10:21:05 <Saizan> yes, except that you can't use record syntax that way
10:21:22 <Saizan> and newtype means that the runtime representation is the same as m [a]
10:22:17 <revenantphx> parcs: Hey, I redid the colors slightly on the plane.
10:22:34 <revenantphx> I thought about redoing the background but I don't keep renders handy all the time.
10:22:35 <dark> this is very interesting o.o
10:22:45 <revenantphx> Original: http://code.galois.com/darcs/haskell-platform/download-website/
10:22:46 <revenantphx> New: file:///Users/dlukes/Desktop/HP/Download%20Haskell.html
10:22:49 <revenantphx> er...
10:22:53 <revenantphx> local link isn't very helpful haha
10:23:10 <revenantphx> here we go
10:23:11 <revenantphx> http://cl.ly/4hFM
10:23:43 <revenantphx> It's just CSS change, and some slight changes to the tags in the html
10:24:14 <decaf> can I check equality of two functions some way?     twice f = f . f       twice reverse = id
10:24:39 <revenantphx> You could check if they compute the same results maybe...
10:24:48 <revenantphx> but that's no guarantee of equality by any means.
10:24:56 <revenantphx> Since you can't possibly check all valid inputs (for most functions).
10:24:59 <zygoloid> decaf: in the general case that's undecidable. in some specific cases you can, though :)
10:25:13 <decaf> ok, thanks
10:30:28 <ksf> "some specific" actually being most.
10:30:45 <ksf> ...as most code is, in fact, total.
10:31:30 <robryk> ksf: why does decidability have anything to do with it?
10:31:51 <robryk> comparing two total Integer -> Integer functions is undecidable, isn't it?
10:32:05 <taotree> decaf, I was thinking of a similar thing and I figured I could make a record type: { f :: (whatever->whatever2), uid :: Int } and then compare uid's
10:32:25 * ksf tries to arrange the little he knows about computational theory
10:32:27 <llambda> gr, i have no idea how to prove the equiv of these two things... no law seems to help me here:    (((p || q) && (not (p && q))) && r)  ==  (((p || q) && r) && ((not (p && q)) || (not r)))
10:32:31 <taotree> in other words, decorate the functions
10:32:43 <ksf> I think you're right.
10:33:17 <ksf> it bogs down to deciding whether two automata accept the same string, which iirc is undecidable in general even for pushdown languages.
10:34:53 <robryk> llambda: duplicate &&r ; then apply demorgan to the not p&&q && r part
10:35:15 <beastaugh> llambda: you can do it model-theoretically quite simply, since there are so few variables
10:35:38 <joe6> haskell llvm, how big a deal is to create an 8-bit target?
10:35:43 <llambda> robryk, duplicate &&r? i'm not sure what that means
10:35:50 <robryk> r = r && r
10:35:57 <llambda> Hmmm
10:35:57 <joe6> i want to create the llvm bytecode for an 8-bit target. 
10:36:11 <llambda> okay thanks i think that is what i may have been missing
10:38:37 <beastaugh> llambda: https://gist.github.com/834209
10:38:50 <beastaugh> assuming classical semantics, of course
10:40:11 <joe6> anyone with llvm experience around?
10:40:11 <llambda> beastaugh, yeah, but that isn't much of a challenge for me :P
10:40:28 <llambda> robryk, i'd only need to duplicate the last r, right?
10:40:43 <robryk> yes
10:41:10 <robryk> well, there is only one r there
10:41:13 <dark> http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html what happened to this
10:41:14 <dark> ?
10:41:39 <llambda> robryk, there are two on the RHS aren't there?
10:41:54 <robryk> yes, i was transforming lhs to rhs
10:42:02 <robryk> sorry, should've specified that
10:42:05 <llambda> Ah
10:47:14 <llambda> robryk, i somehow can't seem to figure it out
10:48:11 <llambda> duplicating the r should enable me to do something but i can't see what that is
10:48:51 <robryk> (((p || q) && (not (p && q))) && r) == ((p|q)&r) & (!(p&q)&!(!r))
10:49:35 <hpc> == p `xor` q && r
10:49:50 <robryk> oh, right, that's simpler
10:50:04 <hpc> :P
10:50:57 <robryk> but it isn't simple that rhs is equal to this, as far as i can see
10:51:33 <llambda> robryk, didn't you just demorgan the right side there? i'm trying to figure out how to apply the distributive law with that r somehow, but the negatives keep on getting in the way
10:51:40 <robryk> mine is the resut of duplicating r, permuting and regrouping of elements of the large conjunction and substituting !(!r)
10:51:41 <dark> can { } be used with top level declaration? o.o also imports?
10:52:27 <monochrom> ((p|q)&r) & (!(p&q)&!(!r)) = ((p|q)&r) & (!(p&q)&r) = (p|q) & (!(p&q))  & r = (p xor q) & r
10:52:28 <dark> so where is the contest for obfuscated haskell?
10:53:25 <rothwell> dark: hackage
10:53:27 <llambda> monochrom, ah nice, that helped, thanks
10:53:28 * rothwell sniggers
10:53:29 <monochrom> module X where { import Prelude; f True = False; f x = x; }
10:53:31 <hpc> rothwell++
10:53:39 <ray> obfuscated haskell is unnecessary
10:53:43 <ray> we have @pl
10:54:03 <hpc> an obfuscated types contest might be fun
10:54:06 <hpc> :t (=~)
10:54:07 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
10:54:23 <copumpkin> fucking ridiculous
10:54:57 <ray> that's the perl operator, it sacrifices making any sense for being good at regular expressions
10:55:15 <Twey> > take 4 $ iterate (liftM2 (++) id $ map not) [True]
10:55:17 <lambdabot>   [[True],[True,False],[True,False,False,True],[True,False,False,True,False,T...
10:55:24 * rothwell searches memory
10:55:37 <Twey> ^ I'm having trouble thinking of an algorithm to generate the infinite last element of this sequence
10:55:59 <hpc> Twey: as in, map last $ iterate bigThing
10:56:00 <hpc> ?
10:56:10 <Twey> hpc: No, as in ‘last bigThing’
10:56:12 <ray> he meanst the limit
10:56:14 <hpc> ah
10:56:25 <Twey> The iterate sequence converges on it, if that's the right terminology
10:56:26 <hpc> i expect it would be True:(cycle False)
10:56:37 <Twey> That doesn't even type-check
10:56:46 <hpc> :t cycle
10:56:47 <lambdabot> forall a. [a] -> [a]
10:56:54 <hpc> :t repeat
10:56:54 <lambdabot> forall a. a -> [a]
10:57:01 <hpc> True:(repeat False)
10:57:03 <Twey> It's not True : repeat False
10:57:21 <Twey> Maybe it's clearer to represent it another way, hold on
10:57:27 <hpc> oh, i see
10:57:34 * hpc sucks at reading nested lists
10:57:43 <Twey> @let (y ?? n) p = if p then y else n
10:57:44 <lambdabot>  Defined.
10:57:46 <robryk> isn't that one of those sequences used somewhere in constructing nonrepetitive sequences?
10:58:00 <hpc> @let bigThing = iterate (liftM2 (++) id $ map not) [True]
10:58:01 <lambdabot>  Defined.
10:58:09 <hpc> > bigThing !! 3
10:58:10 <lambdabot>   [True,False,False,True,False,True,True,False]
10:58:15 <hpc> > bigThing !! 4
10:58:17 <lambdabot>   [True,False,False,True,False,True,True,False,False,True,True,False,True,Fal...
10:58:24 <Twey> > unwords . take 5 . map (map ('1' ?? '0')) $ iterate (liftM2 (++) id $ map not) [True]
10:58:25 <lambdabot>   "1 10 1001 10010110 1001011001101001"
10:58:30 <Twey> It goes like that
10:58:36 <Twey> Yes, I think it's non-repeating
10:58:53 <ceii_> Twey, since it grows quickly enough, what about taking the diagonal?
10:58:56 <ray> so it's the sequence where you concatenate the bitwise not of the previous term to the end
10:58:57 <robryk> no, i meant used in generating sequences with no subsequences being squares
10:59:00 <rothwell> ah, got it - :t append
10:59:00 <llambda> monochrom, my problem is that i end up having (~(p & q) & r) on one side and ~((p & q) & r) on the other, and those two don't seem equiv
10:59:09 <Twey> ray: That's about right
10:59:14 <rothwell> vapp :: (Add l1 l2 l3, Append (f1 l1) (f2 l2) (f3 l3)) => f1 l1 a -> f2 l2 a -> f3 l3 a
10:59:15 <ceii_> like limit !! i = (bigThing !! i) !! i
10:59:19 <llambda> Erm
10:59:21 <rothwell> from oleg's dependently typed append paper
10:59:24 <monochrom> they are non-equivalent
10:59:29 <hpc> :t iterate
10:59:30 <Twey> It has the curious property that the bitwise not is the reverse
10:59:30 <lambdabot> forall a. (a -> a) -> a -> [a]
11:00:03 <Twey> ceii_: That's an interesting idea
11:00:35 <ray> well for even terms it is
11:01:04 <hpc> ray: since he wants the final term, the length will be infinite
11:01:13 <hpc> so it will work
11:01:13 <Twey> @let binary = unwords . (map . map) ('1' ?? '0')
11:01:14 <lambdabot>  Defined.
11:01:16 <llambda> i don't understand why i still can't figure this out after two different people helping me
11:01:17 <ray> you can't reverse the final term so that statement can't be about it
11:01:27 <Twey> @let bigThings = iterate (liftM2 (++) id $ map not) [True]
11:01:27 <lambdabot>  Defined.
11:01:28 <ray> well i guess you can if you define it as the neation
11:01:45 <monochrom> you need to make no mistake
11:01:46 <kulakowski> http://oeis.org/A010060
11:01:49 <hpc> > binary bigThings
11:01:50 <lambdabot>   "1 10 1001 10010110 1001011001101001 10010110011010010110100110010110 10010...
11:01:53 <ray> really though just take the odd subsequence
11:02:10 <ClaudiusMaximus> > [ (bigThings !! (ceiling . logBase 2 . fromIntegral $ i)) !! | i <- [1 .. 16] ]
11:02:11 <lambdabot>   A section must be enclosed in parentheses
11:02:11 <lambdabot>    thus: ((bigThings !! (ceiling ...
11:02:17 <Twey> > map (\i -> ((bigThings !! i) !! i)) [0 ..]
11:02:19 <lambdabot>   [True,False,False,True,False,True,True,False,False,True,True,False,True,Fal...
11:02:27 <Twey> > binary $ map (\i -> ((bigThings !! i) !! i)) [0 ..]
11:02:28 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
11:02:28 <lambdabot>         against inferred typ...
11:02:30 <ceii_> > [(bigThings!! i) !! i | i <- [0..]]
11:02:32 <lambdabot>   [True,False,False,True,False,True,True,False,False,True,True,False,True,Fal...
11:02:34 <ClaudiusMaximus> > [ (bigThings !! (ceiling . logBase 2 . fromIntegral $ i)) !! i | i <- [1 .. 16] ]
11:02:35 <lambdabot>   [*Exception: Prelude.(!!): index too large
11:02:53 <Twey> That's neat
11:03:10 <ClaudiusMaximus> probably needs a +1 in there
11:03:18 <hpc> > binary [(bigThings!! i) !! i | i <- [0..]]
11:03:19 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
11:03:19 <lambdabot>         against inferred typ...
11:03:21 <Twey> Though I feel there ought to be a simple definition
11:03:36 <hpc> :t [(bigThings!! i) !! i | i <- [0..]]
11:03:36 <lambdabot> [Bool]
11:03:41 <hpc> :t binary
11:03:42 <lambdabot> [[Bool]] -> String
11:03:53 <hpc> :t [[(bigThings!! i) !! i | i <- [0..]]]
11:03:54 <lambdabot> [[Bool]]
11:03:56 <Twey> hpc: Yeah, sorry, I defined it over [[Bool]] by accident
11:04:08 <hpc> > binary [[(bigThings!! i) !! i | i <- [0..]]]
11:04:10 <lambdabot>   "10010110011010010110100110010110011010011001011010010110011010010110100110...
11:04:41 <hpc> hmm
11:04:46 <Twey> Yeah, that seems right
11:04:52 <hpc> it seems to be a sequence of "1001" and "0110"
11:05:16 <Twey> It's a sequence of any section that's a power of two
11:05:16 <hpc> :t group
11:05:17 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
11:05:37 <ray> i think you can generate it by replacing 1s with 1001s and 0s with 0110s
11:05:42 <Twey> It's a sequence of 0 and 1, a sequence of 01 and 10, a sequence of 1001 and 0110, a sequence of 10010110 and 01101001, &c.
11:05:43 <ray> skipping the pesky odd terms
11:06:09 <ray> 1 -> 1001 -> 1001011001101001 -> ect
11:06:16 <Twey> Hmm, yeah
11:06:37 <Twey> Though I don't think that gives a usefully productive sequence
11:07:01 <llambda> monochrom, http://pdfcast.org/pdf/a-52 do you see an obvious error there? it must be escaping me somehow
11:07:02 <ray> i don't think it helps in generating the limit but i do think it's a better way to generate the original sequence
11:07:20 <Twey> ray: Theoretically
11:07:41 <ray> if you have an infinite stack you can generate the limit recursively
11:07:47 <robryk> Twey: it does
11:07:53 <dark> Twey, does this really converges?
11:07:57 <Twey> Does it?
11:08:08 <robryk> you define beginning, then you define it recursively as ray said
11:08:11 <ray> each term is the previous one with something stuck on the end
11:08:23 <hpc> the recursive pattern is (x++~x)
11:08:27 <monochrom> btw you may like to know the choice of http://mathbin.net/
11:08:33 <ray> this clearly converges
11:08:34 <ceii_> > let t '0' = "0110" ; t '1' = "1001" in iterate (concatMap t) "1"
11:08:35 <lambdabot>   ["1","1001","1001011001101001","1001011001101001011010011001011001101001100...
11:08:52 <hpc> or, x[n] = (x[n-1]++~x[n-1])
11:08:53 <llambda> Oh nice
11:09:10 <Twey> > iterate (>>= ([True, False] ?? [False, True])) [True]
11:09:12 <lambdabot>   [[True],[True,False],[True,False,False,True],[True,False,False,True,False,T...
11:09:19 <Twey> Oh, it is productive
11:10:01 <hpc> i think you can do some zipWith trickery to generate the final term
11:10:05 <llambda> monochrom, http://mathbin.net/59013
11:10:06 <hpc> *final sequence
11:10:10 <ceii_> basically, it seems we can speed up the convergence arbitrarily by getting the nth term, and replicing 1 with it, 0 with its bitwise not on at each step
11:10:18 <llambda> (if you don't mind)
11:11:02 <Twey> ceii_: Yeah
11:11:10 <ceii_> > let t '0' = "0110100110010110" ; t '1' = "1001011001101001" in iterate (concatMap t) "1"
11:11:11 <lambdabot>   ["1","1001011001101001","10010110011010010110100110010110011010011001011010...
11:11:18 <ceii_> this is so fun
11:11:27 <Twey> Hehe
11:11:32 <Twey> It's a really cool sequence
11:11:44 <Twey> It's a representation of this pattern I've had stuck in my head since I was tiny
11:12:06 <Twey> I thought the other day that I would make Haskore play it for me
11:12:12 <zecrazytux> hi
11:12:15 <Twey> But I couldn't work out a way to generate the final term
11:12:16 <ceii_> hi
11:12:18 <Twey> Hi, zecrazytux
11:12:34 <hpc> @let inv = map not
11:12:35 <lambdabot>  Defined.
11:12:41 <hpc> > inf [True, False]
11:12:42 <tromp_> @let cmpl '0'='1'; cmpl '1'='0'
11:12:42 <lambdabot>   Not in scope: `inf'
11:12:43 <lambdabot>  Defined.
11:12:45 <hpc> > inv [True, False]
11:12:47 <lambdabot>   [False,True]
11:12:49 <tromp_> > cmpl '1'
11:12:51 <lambdabot>   '0'
11:12:53 <hpc> oh, ty
11:13:05 <tromp_> @let inter (x:xs) ys = x:inter ys xs
11:13:06 <lambdabot>  Defined.
11:13:13 <zecrazytux> is it possible to install cabal with hugs? I can't use ghc as it is not supported on my platform atm... hugs is
11:13:23 <tromp_> > thue
11:13:24 <lambdabot>   Not in scope: `thue'
11:13:29 <tromp_> @let thue  = '0': fix (inter (map cmpl thue))
11:13:30 <lambdabot>  Defined.
11:14:07 <monochrom> r ∧ ¬(x ∧ r) = r ∧ (¬x ∨ ¬r) = (r ∧ ¬x) ∨ (r ∧ ¬r) = ... = r ∧ ¬x
11:14:44 * hpc really wants to find an expression for the final sequence
11:15:06 <tromp_> >thue
11:15:46 <robryk> hpc: isn't the nth element 0 when binary repr. of n contains odd number of 1s and 1 otherwise?
11:15:46 <tromp_> > thue
11:15:48 <lambdabot>   "01101001100101101001011001101001100101100110100101101001100101101001011001...
11:15:58 <tromp_> yes robryk
11:16:15 <tromp_> unfortunately Data.Bits has no parity function
11:17:01 <aristid> @pl inter (x:xs) ys = x:inter ys xs
11:17:01 <lambdabot> inter = fix ((`ap` tail) . (. head) . flip ((.) . (.) . (:)) . flip)
11:17:03 <ray> hmm i think that's the negation of the sequence we want
11:17:07 <llambda> monochrom, i'm not sure how that helps me
11:17:11 <tromp_> then we would have thue = map parity [0..]
11:17:19 <monochrom> x is p∧q
11:17:31 <aristid> > inter "abc" "def"
11:17:33 <lambdabot>   "adbecf*Exception: <local>:14:0-30: Non-exhaustive patterns in function inter
11:18:25 <aristid> @let inter' xs ys = concat $ zipWith (\x y -> [x, y]) xs ys
11:18:25 <lambdabot>  Defined.
11:18:30 <aristid> > inter' "abc" "def"
11:18:31 <lambdabot>   "adbecf"
11:18:50 <ceii_> @let ok = let t '0' = "0110" ; t '1' = "1001" in [((iterate (concatMap t) "1")!! i)!! i | i <- [0..]]
11:18:51 <lambdabot>  Defined.
11:19:08 <ceii_> > take 1000 ok == take 1000 (map comp thue)
11:19:09 <lambdabot>   Not in scope: `comp'
11:19:18 <ceii_> > take 1000 ok == take 1000 (map cmpl thue)
11:19:20 <lambdabot>   True
11:19:25 <ceii_> nice :)
11:19:58 <monochrom> don't focus on "¬x ∧ r  vs  ¬(x ∧ r)  are they the same?". pseudo question.  focus on "¬x ∧ r  vs  r ∧ ¬(x ∧ r)  are they the same?". they are the same.
11:20:41 <llambda> I don't have a r ∧ ¬(x ∧ r) though
11:20:58 <tromp_> @let parity n = foldl xor 0 (map (testBit n) [0..bitSize n])
11:20:59 <lambdabot>  <local>:18:17:
11:20:59 <lambdabot>      No instance for (Bits Bool)
11:20:59 <lambdabot>        arising from a use of...
11:21:23 <fryguybob> @oeis 1, 12, 1221, 12212112
11:21:23 <lambdabot>  Successive words in the formal D0L language that produces the Thue-Morse seq...
11:21:23 <lambdabot>  [1,12,1221,12212112,1221211221121221,12212112211212212112122112212112,122121...
11:21:46 <Twey> Should've figured someone got there before me ☺
11:22:00 <monochrom> you are trying to prove blah∧r∧¬x∧r = blah∧r∧¬(x∧r) no?
11:22:21 <ray> thue-morse, now you know the name
11:22:28 <tromp_> @let parity n = foldl xor 0 (map (fromEnum . testBit n) [0..bitSize n])
11:22:29 <lambdabot>  Defined.
11:22:39 <kulakowski> ray: I linked the OEIS a while up
11:22:39 <tromp_> > map parity [0..]
11:22:40 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:22:40 <lambdabot>    `Data.Bits.Bits a'
11:22:40 <lambdabot>      ...
11:22:45 <monochrom> which is to say you're trying to prove blah∧¬x∧r = blah∧r∧¬(x∧r) no?
11:22:49 <tromp_> > map parity [0..] :: [Int]
11:22:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:22:50 <lambdabot>    `Data.Bits.Bits a'
11:22:50 <lambdabot>      ...
11:23:13 <tromp_> > map parity ([0..] :: [Int])
11:23:14 <lambdabot>   [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,...
11:23:27 <llambda> monochrom, okay i'm incredibly confused now so i'll take a break and read over everything you've said, lol
11:23:40 <llambda> thanks for the help on the semi-ot stuff all
11:23:46 <monochrom> which could be declared victory if you could prove ¬x∧r = r∧¬(x∧r) no?
11:23:55 <hpc> damn, solved before i could turn my lappy back on
11:24:02 <xarch> why does Parsec (3) says there's no instance for Stream a Identity Char although I imported Text.Parsec.String?
11:24:05 <ray> > parity 2
11:24:05 <lambdabot>   Ambiguous type variable `t' in the constraint:
11:24:06 <lambdabot>    `Data.Bits.Bits t'
11:24:06 <lambdabot>      a...
11:24:06 <monochrom> and there is my r∧¬(x∧r) plain as day
11:24:20 <ray> > parity (2 :: Int)
11:24:23 <lambdabot>   1
11:24:38 <hpc> :t parity
11:24:38 <lambdabot> forall a. (Bits a) => a -> Int
11:25:27 <ray> i think we want the other parity
11:26:00 <ray> well, for the original problem anyway, it's obviously not *really* different
11:26:29 <joe6> there are 2 haskell libraries with the same module structure LLVM/Core.hs in different packages llvm and llvm-ht.
11:26:44 <joe6> Is there a way to just import the Core.hs of llvm-ht?
11:26:58 <joe6> i tried +m LLVM.Core
11:27:06 <joe6> and it gets the core of the first package.
11:27:15 <joe6> ie. the llvm package
11:27:48 <joe6> from the ghci prompt, i mean
11:29:01 <mauke> my program tells me '(¬x ∧ r)  = (¬(x ∧ r))' simplifies to 'r'
11:29:48 <monochrom> that is a good program you have
11:29:59 <pastorn> joe6: you can do someting like 'from "packagename" import Mod.Ule'
11:30:02 <mauke> it's a perl script and uses regexes :-)
11:30:06 <Twey> Haha
11:30:20 <tg_> regexes are the 2nd best feature of perl
11:30:21 <pastorn> joe6: i think the extension name is PackageImports
11:30:28 <monochrom> what? you use regex to parse?
11:30:34 <mauke> the code was originally written to solve http://www.spoj.pl/problems/TAUT/
11:30:58 <monochrom> oh, no wonder regex suffices to parse
11:31:05 <mauke> monochrom: here's the output: http://codepad.org/QiVkoBFw
11:31:08 <joe6> pastorn: thanks a lot.
11:32:55 <pastorn> joe6: you can also do $ ghc-pkg hide packagename
11:33:21 <monochrom> as for perl, I have no complaint. http://www.umsu.de/logik/trees/ does it with javascript. if you can use javascript, you can surely use perl or even cobol.
11:37:40 <monochrom> and to think we scorned at http://groups.google.com/group/comp.lang.functional/browse_thread/thread/5fdbab78759192a0/dc9cf13694290f15?#dc9cf13694290f15
11:39:05 <monochrom> then again "javascript is the only standardised language" is crackpot-ish
11:42:28 <elventear> Hello. I am new to learning Haskell and I am having an issue defining a new Type I am wondering if someone can help me understand why the following syntax is not acceptable http://hpaste.org/44117
11:43:22 <tromp_> what is 3rd constructor?
11:43:29 <ceii_> elventear, your third alternative lacks a constructor
11:44:34 <elventear> ceii_: data Time.LocalTime
11:44:35 <elventear>   = Time.LocalTime {Time.localDay :: Time.Day,
11:44:35 <elventear>                     Time.localTimeOfDay :: Time.TimeOfDay}
11:44:42 <elventear> Time.LocalTime wouldn't be the constructor?
11:45:11 <monochrom> He/She certainly used a more glorified, obfuscating way to say simply "because most computers run javascript readily"
11:45:23 <ceii_> noj, the constructors for a newly defined type are new keywords, which you introduce in the definition
11:45:47 <dark> do I really need to pass ghc --make all my .hs files?
11:45:55 <ceii_> for example, you'd create a value of the first form with "Measurement somestring somestring simetime somedouble"
11:46:26 <ceii_> dark: no, it will follow dependencies on its own
11:47:34 <powersurge> what's the benefit of hand-writing instances versus derriving existing ones? custom functions?
11:47:44 <monochrom> ghc --make the'file'that'has'your'main.hs
11:48:47 <dark> does not work
11:48:50 <elventear> ceii_:  So here are the full declarations http://hpaste.org/44120
11:48:53 <dark> Could not find module `Grammar':
11:49:11 <dark> but if i include grammar.hs it works
11:49:24 <monochrom> Grammar.hs not grammar.hs
11:49:30 <elventear> ceii_: Without the last line it works. I thought about using the constructors again but ghc complained and I used the data type names
11:49:30 <dark> ah
11:49:34 <dark> o.O
11:49:36 <dark> hmm
11:49:48 <monochrom> time to read the ghc user guide cover-to-cover
11:50:02 <elventear> ceii_: Now what I want to add is the Data.Time.LocalTime but as far as I understand the Data.Time.LocalTime would be the constructor also
11:50:07 <dark> so, Main.hs, too?
11:50:17 <monochrom> that one is the exception
11:51:19 <ceii_> elventear, I assume when you write "Measurement String String Time.LocalTime Double" you want that alternative to contain a measurement value?
11:51:34 <powersurge> what's the benefit of hand-writing instances versus derriving existing ones? custom functions?
11:51:42 <powersurge> <- haskell scrub
11:51:42 <elventear> ceii_:  Yes
11:51:51 <monochrom> for the'file'that'has'your'main you can use any filename you want. presumably because you may have several such files in the same directory, even same project, because you may want to produce several executables but they share other modules.
11:52:21 <dark> actually I am using a makefile too, any suggestion on what would be better than it?
11:52:40 <monochrom> cabal
11:52:42 <dark> it says ghc --make substitute a makefile, but then what should I do, put it at a shell script?
11:52:45 <Twey> powersurge: The automatic ‘deriving’ magic works only on a few built-in classes, too
11:52:54 <dark> oh isn't this too complicated?
11:52:57 <ceii_> this isn't what's happening, what you wrote here means "values tagged with the name Measurement, and containing a String, another String, a LocalTime and a Double"
11:53:10 <ceii_> the first uppercase word is the tag for this alternative
11:53:18 <powersurge> Twey: thanks. working my way through Learn You A Haskell
11:53:26 <powersurge> far cry from learning python :<
11:53:26 <ceii_> so you'd need something like FirstCase Measurement String String Time.LocalTime Double
11:53:41 <dark> btw that is my makefile http://paste.pocoo.org/show/341028/ can cabal do that?
11:53:54 <ceii_> or Measurement Measurement String String Time.LocalTime Double, since types and constructors are in different namespaces
11:53:56 <monochrom> I am not sure which one is more complicated, make or cabal
11:54:09 <dark> I have a clause for recompiling the target and running the programming
11:54:18 <dark> the program(
11:54:25 <ceii_> the first Measurement means "this clause is tagged with the name Measuremnet"
11:54:27 <dark> can cabal do that?
11:54:39 <ceii_> the second one means "it contains a value of type Measurement"
11:55:09 <monochrom> cabal doesn't do the "run" part
11:55:31 <monochrom> this makefile is fine.
11:55:41 * FUZxxl 's head exploded.
11:56:01 <elventear> ceii_:  Gotcha
11:56:17 <elventear> ceii_:  I had been reading for a while now and I had not understood that part about the Tag
11:56:34 <elventear> So, LocalTime Time.LocalTime Time.Day Time.TimeOfDay makes sense at the end?
11:56:40 <elventear> At least GHC will process it
11:56:50 <gwern> > 48 / 3
11:56:51 <lambdabot>   16.0
11:57:06 <aristid> > 48 % 3
11:57:07 <lambdabot>   16 % 1
11:57:12 <gwern> GPUs can be pretty impressive
11:57:24 <aristid> > sum . map digitToInteger $ "48"
11:57:25 <lambdabot>   Not in scope: `digitToInteger'
11:57:31 <ceii_> this makes "LocalTime" the tag for this alternative
11:57:31 <aristid> > sum . map digitToInt $ "48"
11:57:33 <lambdabot>   12
11:57:34 <gwern> for bitcoin mining, I am getting a 16000x speedup by using the GPU rather than CPU
11:57:49 <smoge> is there good introdutory video tutorials on the web for haskell?
11:57:53 <powersurge> when defining functors, and implementing fmap, you are actually kind of just doing a partially applied function, yeah? You are defining a function to be partially applied to fmap, right?
11:58:07 <gwern> (it goes from 3,000 hashes per second on the CPU to 49,000,000 hashes per second on the GPU)
11:58:15 <aristid> gwern: but they're only good at some kinds of tasks AFAIK
11:58:39 <gwern> aristid: sure, but they really shine on those tasks. no free lunch
11:58:44 <thoughtpolice> the problem is that any GPU programming seems to require intricate hardware knowledge about the card at hand. arguably, this isn't the level of abstraction people want, but it's the one that matters if you want any sort of reasonable performance - providing your use case can even benefit from in the first place
11:59:07 <thoughtpolice> because man, GPUs are super impressive when they're impressive, but otherwise they tend to tank pretty damn hard
11:59:13 <gwern> thoughtpolice: we should not be unfamiliar with the idea of tradeoffs by now :)
11:59:27 <aristid> cpu programming is the ruby of hardware (just to make a joke about ruby's speed :P)
11:59:50 <monochrom> it used to be s/ruby/java/
12:00:08 <thoughtpolice> sure, I just wish there were better abstractions for it, that didn't require such intricate hardware detail. i hear horror stories about people having to rewrite chunks of code just for slightly different cards, much less rewrite stuff in the first place to work on the GPU at all
12:00:23 <aristid> monochrom: now, java is widely considered a "fast language"
12:00:30 <monochrom> yeah
12:00:45 <gwern> well, jvm has seen a lot of improvement. it places well in the shootout
12:00:47 <thoughtpolice> (because it does well on one card, but tanks hard on a slightly newer/older model, which makes the actual effort required somewhat larger than you might expect)
12:00:48 <powersurge> I was startled about how fast java is
12:00:56 <joe6> Loading package llvm-ht-0.7.0.0 ... can't load .so/.DLL for: LLVMSystem (libLLVMSystem.so: cannot open shared object file: No such file or directory)
12:00:57 <thoughtpolice> the JVM is scary fast
12:01:01 <monochrom> GPUs are pretty new, still changing, no abstraction is stable.
12:01:02 <thoughtpolice> the JVM is also very scary code in general
12:01:04 <dark> haddock says Warning: Command: could not find link destinations for: GHC.Enum.Enum GHC.Read.Read GHC.Show.Show GHC.Base.String GHC.Types.Char
12:01:06 <joe6> i have libLLVMSystem.a
12:01:07 <aristid> i was startled at how fast GHC is
12:01:13 <dark> I'm not sure if this is a problem or not
12:01:13 <aristid> (when fed dons' code)
12:01:17 <joe6> but not .so, any thoughts, please?
12:01:21 <powersurge> I want there to be more mature jvm languages desperately
12:01:21 <thoughtpolice> joe6: you can't use LLVM from ghci, IIRC. it's a linker deficiency
12:01:38 <powersurge> I want to use a boo/python type language on teh JVM without sacrificing speed
12:01:39 <joe6> thoughtpolice, ok, good to know. thanks
12:01:40 <dark> maybe i should just run with --no-warnings
12:01:45 <powersurge> cause it makes me feel dirty to use mono
12:01:53 <thoughtpolice> dark: it's no problem, it just means haddock won't provide hyperlinks to those internal GHC classes
12:02:23 <joe6> thoughtpolice, have you used llvm? do you know if it can generate the llvm bytecode for any target in the Target/ directory, theoretically?
12:02:30 <powersurge> Scala looks fun, but the jury's still out. Maybe I'll splash around in it once I have a fairly solid grasp of Haskell
12:02:40 <powersurge> IE after I relearn to program :<
12:02:41 <thoughtpolice> monochrom: indeed, i hope it will get much better. right now i don't really have a use case and the effort required for actual gains seems extremely high
12:02:45 <thoughtpolice> but i'm sure it will get better
12:03:04 <joe6> i know that the bindings might not support it, but *theoretically*, with a few changes, can it generate the bytecode for MSP430?
12:03:35 <thoughtpolice> joe6: as long as you generate bytecode properly - i.e., bytecode that does not care about things like system endianness - you should be able to then use LLVM to compile the bitcode to whatever platforms it supports
12:04:03 <joe6> thoughtpolice, i am writing a custom llvm backend with the hope that I can use the haskell-llvm bindings to generate code for that target.
12:04:08 <thoughtpolice> in pratice, this doesn't work so much. example: C compiler generates llvm bitcode. but the C compiler had compile-time constants included based on the platform and its endianness for example, and those platform-specific features are reflected in the bytecode
12:04:16 <Eduard_Munteanu> Hrm, Haskell in embedded environments?
12:04:18 <Eduard_Munteanu> Sounds tough.
12:04:29 <thoughtpolice> if you carefully hand craft the bitcode though, you should be able to compile it to lots of architectures with LLVM though
12:04:30 <Eduard_Munteanu> IIRC, MSP430 is a DSP core.
12:04:30 <joe6> thoughtpolice, i have not used the haskell-llvm bindings, but my target is 8-bit
12:04:46 <aristid> Eduard_Munteanu: msp430 is a 16-bit microcontroller
12:04:50 <thoughtpolice> joe6: i don't know if llvm currently supports any 8-bit targets, I know it has a PIC-16 backend or so
12:04:53 <c_wraith> The atomo approach is pretty cool for embedded environments.  a haskell edsl that spits out C code appropriate for embedded use
12:05:07 <joe6> i am writing an 8 bit backend.
12:05:13 <joe6> on the llvm end, i mean.
12:05:17 <thoughtpolice> synthesizing fast code using haskell is popular in places where people want strong guarantees on the things they write
12:05:21 <thoughtpolice> galois does it all the time
12:05:36 <thoughtpolice> joe6: ah, well yes then, if you just make sure the bitcode you generate is relatively 'portable' then it should work fine
12:05:47 <aristid> thoughtpolice: but it must be depressing not to have the full power of haskell at disposal when using haskell :)
12:05:52 <joe6> but, my problem is, I was under the impression that the bytecode is target agnostic. but, it apparently, is not.
12:05:55 <thoughtpolice> you do have the full power of haskell
12:05:58 <thoughtpolice> that's the point of an EDSL
12:06:21 <aristid> well, only in a way
12:06:23 <robryk> joe6: you can always put a 16bit int in memory somewhere and then read first 8 bits
12:06:29 <thoughtpolice> is the final code running on your machine actually written in haskell and compiled by GHC? no, but you still get all the great static guarantees
12:06:29 <aristid> you can use the full power of haskell to generate the code
12:06:37 <aristid> but the code is still stupid microcontroller code
12:06:40 <Eduard_Munteanu> That should be better.
12:07:06 <ceii> you'd better use as much Haskell as you can at compile time, before run time comes and takes it all away
12:07:10 <ceii> :
12:07:10 <joe6> robryk, yes, i can. but my code will not have any 16-bit int's just 8-bit int's.
12:07:37 <joe6> thoughtpolice, so can I generate the bytecode for any target with the haskell-llvm bindings?
12:07:49 <dark> can a function be defined in more than one file? (Like, two files that has the same module X where, and this function has some pattern-matching in one file, some in another)
12:07:52 <joe6> or is the bytecode generated x86 specific (or native)
12:07:57 <thoughtpolice> aristid: you should be able to, yes. you may need to be careful about how you generate it, but it's possible
12:08:00 <thoughtpolice> er
12:08:02 <thoughtpolice> that was meant for joe6 
12:08:06 <monochrom> dark: no
12:08:23 <dark> .-. ok
12:08:28 <thoughtpolice> also, aristid: sure, it would be nice to have GHC run on those platforms too, but that's generally speaking a Really Hard Problem in a lot of cases.
12:08:37 <aristid> thoughtpolice: i know! :)
12:08:48 <aristid> especially given that ghc is no cross-compiler
12:08:50 <robryk> joe6: no, it will have ; your pointers are larger than 8bits surely
12:08:52 <thoughtpolice> i mean, i'd have no idea about how to stick GHC on a 16-bit PIC
12:08:57 <aristid> so it doesn't even run on platforms that are beefy enough
12:09:02 <thoughtpolice> but i have plenty of ideas of how i'd generate code for a 16-bit PIC
12:09:09 <thoughtpolice> aristid: me and a few other people are working on that! (very slowly)
12:09:18 <aristid> thoughtpolice: be faster!
12:09:19 <dark> monochrom, so ghc wants to compile every file separately instead of like every module separately? 
12:09:36 <joe6> robryk, yes, the pointers are larger than 8 bits, but there are no pointers in the code, mostly static labels, where needed. and call and ret instructions.
12:09:40 * dankna is currently hacking GHC to this end, actually
12:09:43 <dankna> cross-compilation that is
12:09:46 <thoughtpolice> aristid: even more than that you have some nontrivial implementation details like the FFI, and the garbage collector
12:09:56 <aristid> dankna: work with thoughtpolice! :)
12:09:58 <thoughtpolice> dankna: i will hopefully have some time this weekend to work with you
12:09:59 <Eduard_Munteanu> GHC should really have cross-compiling support, I can't imagine how they bootstrap it otherwise.
12:10:01 <dankna> I am :)
12:10:09 <thoughtpolice> Eduard_Munteanu: it's brutal. you don't want to do it. i've done it.
12:10:10 <aristid> thoughtpolice: i don't follow
12:10:14 <thoughtpolice> it's brutal.
12:10:27 <Eduard_Munteanu> Metal.
12:10:30 <aristid> thoughtpolice: let's say you have a modern ARM microcontroller with 128 MB of RAM
12:10:35 <dankna> Eduard_Munteanu, bootstrapping is an issue right now - I heard from someone who provides the binaries for some BSD variant or other, to the effect that it's really challenging
12:10:44 <aristid> which is more than enough to _run_ haskell programs, but not to compile them, i think
12:10:47 <thoughtpolice> aristid: for one, the way the FFI is currently implemented it has to generate code at runtime (this is libffi, not GHC fwiw,) and second getting the garbage collector to work on such systems may be a major pain, especially if you need strong guarantees about how long things take to execute
12:10:47 <robryk> joe6: ok, that was an example how it can be platform-specific
12:11:12 <dankna> GHC's FFI doesn't use libffi, although it's linked against it for other purposes.  as far as I can tell at least!
12:11:19 <thoughtpolice> aristid: ARM platforms are more realistic, I was still thinking of the 16-bit PIC for example
12:11:20 <aristid> uh.
12:11:31 <aristid> thoughtpolice: ARM is very important
12:11:36 <thoughtpolice> aristid: I mean, shit, my ARM phone is at 550mHz w/ 256MB of RAM. it could handle GHC generated programs I'm sure
12:11:48 <robryk> thoughpolice: with a software stack or something cleverer?
12:11:49 <Eduard_Munteanu> Anyway, Haskell (GHC or not) probably isn't going to be on barebones stuff any time soon.
12:12:06 <thoughtpolice> dankna: you're right now that I think about it. it uses libffi to generate code for closures in the RTS
12:12:08 <aristid> thoughtpolice: my next ARM phone will be at 1 GHz with 512 MB of RAM. but my current one has pretty much the same specs as yours :)
12:12:11 <thoughtpolice> which is a somewhat scary detail
12:12:32 <aristid> Eduard_Munteanu: but hopefully on phones.
12:12:34 <dankna> thoughtpolice: yes, that was the result of my research, haha.  where were you when I asked #ghc that question two weeks ago? :)
12:12:39 <thoughtpolice> aristid: yeah, ARM platforms are well within the realm of possibility. i'm musing on working on an ARM backend for GHC once we get cross compilation for GHC working (me, dankna, and a friend phunge)
12:12:43 <Eduard_Munteanu> Heck, even mere GC is scary there, despite what research people say.
12:12:49 <Philippa> GHC needs to work well on ARM, including GHCi, yeah
12:13:04 <Philippa> if nothing else, we're looking at a potential shift to ARM on the desktop over the next 5 years
12:13:24 <aristid> Philippa: i don't see that. why change the desktop? intel works fine there
12:13:29 <dankna> I haven't looked - is the ARM instruction-set saner than the Intel one?  I hope I hope?
12:13:33 * Eduard_Munteanu would like an ARM desktop
12:13:39 <thoughtpolice> dankna: playing starcraft 2 is a likely answer
12:13:40 <systemfault> ARM ftw.
12:13:41 * dankna has an ARM picture frame
12:13:44 <aristid> dankna: AFAIK ARM chips are better at saving powers
12:13:47 <aristid> -s
12:13:54 <tibbe> dons: looking into making a release of unordered-containers today
12:13:57 <dankna> aristid: okay, heh
12:14:24 * Eduard_Munteanu thinks of making himself an exotic mini-desktop some time
12:14:45 <Eduard_Munteanu> AVR32 also seems intriguing.
12:14:49 <thoughtpolice> dankna: give me your repository btw! i want to look at the work you've done and maybe ping the simons about what else may be tackl-able
12:15:05 <thoughtpolice> I also need to bug phunge, he needs to get his hsc2hs patch in as well
12:15:17 <Eduard_Munteanu> (Well, not really desktop, but something usable as a computer)
12:15:21 <thoughtpolice> *tackleable - as you can tell, the e and the - on the keyboard are very close together
12:15:25 <dankna> thoughtpolice, http://dankna.com/software/darcs/ghc-darcs-dnk-cross-compilation/ and give me an SSH public key and I'll set you up with write access
12:15:38 <thoughtpolice> dankna: not on my home machine atm, will send later
12:15:41 <dankna> okay, cool
12:15:55 <dankna> I took another look at how to set you up with write access and it was actually nice and easy
12:16:03 <Eduard_Munteanu> dankna: write access? I kinda go nuts when I see people use DVCS'es like that :)
12:16:22 <dankna> Eduard_Munteanu, well, for a repo this big... I don't want a patch in my email!
12:16:36 <thoughtpolice> typically patches for GHC are actually surprisingly small
12:16:41 <thoughtpolice> i was really surprised by that
12:16:42 <Eduard_Munteanu> Has darcs got pull requests?
12:16:59 <Eduard_Munteanu> Ok, I've seen people misuse Git a lot.
12:17:04 <thoughtpolice> (I think the entire .dpatch for the plugins work was like, 600 lines?)
12:17:28 <dankna> well, I've touched 2700 lines just since yesterday
12:18:18 <dankna> no, I'm not sure what pull requests are so I don't think darcs has them
12:18:53 <robryk> is somebody trying to port haskell to PICs?
12:19:05 <Eduard_Munteanu> Git just lets you prepare an e-mail telling someone else "hey, pull this from my repo".
12:19:15 <dankna> that's kind of neat
12:19:35 <dankna> on the other hand, I can do that by hand :)
12:19:46 <siracusa> Do we have a LaTeX parser somewhere that gives you a LaTeX AST (or at least for the math portions)? I've looked at texmath, but it's doing some internal conversions I don't want, e.g. `\varphi' -> `ESymbol Ord "\981"'.
12:20:00 <thoughtpolice> more specifically
12:20:01 <dankna> siracusa, that would be neat, but I am not aware of one
12:20:02 <thoughtpolice> github has pull requests
12:20:04 <thoughtpolice> git does not
12:20:10 <thoughtpolice> in git normally you do the same thing you do in darcs
12:20:16 <thoughtpolice> you send people a patch through email
12:20:19 <thoughtpolice> i.e. git-send-email
12:20:39 <thoughtpolice> it's a slightly modified form of the unified diff format, that mainly just tracks for example, the commit message and the committer identity
12:20:45 <dankna> gotcha
12:20:46 <Eduard_Munteanu> Hrm, I thought there was something like that, OTOH I never used them.
12:21:36 <thoughtpolice> this is how the linux kernel works, for example. most people use git-send-email to send patches to lkml, linus et al pull them in - there's another git command for this, git-am (am stands for 'apply mailbox', the idea being you can actually just take patches out of mbox-formatted dirs etc and apply them)
12:21:43 <Eduard_Munteanu> Ah, there is: git-request-pull(1)
12:21:51 <thoughtpolice> oh really? when was that introduced
12:22:25 <Eduard_Munteanu> Not sure, but I've always thought pull request were kinda standard, moreso since kernel people don't use github generally.
12:22:30 <thoughtpolice> "git-request-pull - Generates a summary of pending changes "
12:22:40 <thoughtpolice> so, doesn't really email you, just outputs a list of changes you perhaps should pull
12:23:40 <thoughtpolice> Eduard_Munteanu: it's more like "Review this code I'm about to email you," and then they git-send-email it. git-send-email is smart enough to make a set of commits all part of the same message thread for your email client for readability, etc
12:24:22 <thoughtpolice> subsystem maintainers apply the patches, and then more general maintainers (like andrew mortin, etc) merge in the branches of the subsystem maintainers
12:24:26 <Eduard_Munteanu> Yeah, git-send-email is great
12:24:33 <thoughtpolice> linux has a pretty well thought-out development model at this point
12:24:38 <thoughtpolice> or workflow, i should say
12:25:56 <thoughtpolice> dankna: i'll check out your work shortly when I get the time, and did we ever come to a conclusion about a wiki page? perhaps we should make one on the trac 'CrossCompilationProgress' or something so we can note down the changes we made, thoughts behind the changes, what needs to be done, etc
12:26:14 <thoughtpolice> don't know if we want to clutter simon's page that outlines his ideas of what it looks like 'from the build system view'
12:26:47 <thoughtpolice> we can fit a bit more reasoning and discussion into a documented wiki page with tracked edits than we can in commit messages :)
12:27:15 <dankna> thoughtpolice: yeah, that sounds good.  one major way you can help me now that I think of it is reviewing my changes and asking me the tough questions about them
12:27:28 <dankna> "Why did you do X, that's kinda stupid?" kind of things
12:27:46 <dankna> since that's exactly the kind of design decision we want to document
12:27:49 <thoughtpolice> right
12:28:14 <dankna> I did give a status report to #ghc at the weekly meeting on Wednesday, btw, I can get you a log of that.  it was short.
12:28:17 <thoughtpolice> i'll check it out a little, i don't have good internets at my new apartment, so I may just reply haphazardly tonight and give you some notes tomorrow if you're available
12:28:24 <dankna> yeah no problem.
12:28:27 <thoughtpolice> dankna: i log everything. :)
12:28:28 <dankna> good :)
12:28:41 <thoughtpolice> dankna: I actually gave phunge a 22mb log of #ghc, because he wanted to read it and figure out where you were with your work
12:28:46 <dankna> hah okay!
12:28:51 <dark> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-State-Lazy.html i don't see get defined here
12:28:57 <shlevy> Hello
12:29:07 <dark> but it is use
12:29:09 <dark> d
12:29:24 <Eduard_Munteanu> dark: see MonadState
12:30:06 <dankna> thoughtpolice: most of my work thus far has been threading Architecture parameters into places where there were none before (which is everywhere, since it's a new type :D)
12:30:16 <dankna> it reaches virtually everything in compiler/ at this point :(
12:30:20 <dankna> that was a lot of work :(
12:30:28 <shlevy> I'm interested in writing a Haskell98 or Haskell' 2010 compiler as a really boneheaded way to learn Haskell. Anyone have resources to recommend beyond the specifications?
12:30:42 <aristid> shlevy: wtf, are you crazy?!
12:30:47 <dark> MonadState s (State s) is a instance. it maybe makes sense, thanks
12:30:53 <Eduard_Munteanu> shlevy: I'd look at EHC or whatsitsname...
12:31:05 <Eduard_Munteanu> That guy documented the process of building a compiler a bit.
12:31:14 <dankna> even LLVM isn't safe, which you'd think it would be because it's inherently platform-agnostic.  but no!  the mangling of labels infects it.
12:31:28 <shlevy> aristid: Yes, absolutely
12:31:58 <aristid> shlevy: sorry :)
12:32:06 <shlevy> Eduard_Munteanu: Thanks!
12:32:07 <robryk> danknaa: could you elaborate?
12:32:20 <dankna> thoughtpolice: I did have everything in a state early yesterday such that I was able to run the testsuite on it, and I found no regressions compared to before I started my work
12:32:28 <Eduard_Munteanu> dark: yes, that functionality is broken into MonadState, that goes for other monads too
12:32:34 <dark> how can I import just get and put? import Control.Monad.State.Class(get, put)? they don't appear to be an exported symbol
12:33:09 <dankna> robryk: sure.  pprCLabel is architecture-dependent.  in HEAD this is expressed with #ifdefs, but since I'm trying to support cross-compilation, I'm making it expressed by a runtime check...
12:33:09 <Eduard_Munteanu> dark: they are exported
12:33:41 <Eduard_Munteanu> dark: Control.Monad.State.Lazy already imports that and exports them
12:33:49 <dankna> robryk: the code in compiler/llvm/ makes extensive use of pprCLabel.  so I need to make my new Architecture type with the relevant information to get it right available to those calls.
12:34:04 <Eduard_Munteanu> So you can basically import them from Control.Monad.State.Lazy directly
12:34:23 <dankna> robryk: the Architecture is available in the dflags, so the top-level llvm code that has access to those has to pull it out of there and pass it down through every intermediate leve.
12:34:34 <dark> oh ok nice
12:34:45 <dankna> robryk: I'm basically done with threading the parameters in at this point, so suggestions for easier ways to do it will be met with dismay :)
12:35:06 <dankna> robryk: does that answer your question?  what's your interest - are you the author of the llvm support by any chance? :)
12:35:28 <gwern> > 10000000000 / 21000000
12:35:30 <lambdabot>   476.1904761904762
12:36:08 <gwern> > 0.01 * 476
12:36:08 <lambdabot>   4.76
12:36:39 <robryk> maybe, i wanted to know why it is arch-dependent; no, i am not, i'm just curious
12:36:58 <Eduard_Munteanu> @vixen Calculate 0.01 * 476
12:36:58 <lambdabot> You complete me
12:37:05 <Eduard_Munteanu> Meh, not that smart.
12:37:08 <dankna> okay.  it's arch-dependent because different platforms have different rules with regard to prepending an underscore to symbol names, and that sort of thing.
12:37:30 <dankna> so it's a genuine issue, not just an accident
12:37:37 <dankna> I did make sure of that before doing all the heavy lifting :)
12:37:45 <robryk> oh, i see
12:37:48 <dankna> yeah
12:38:01 <dark> is this do { (x:xs) <- get } save? what if this pattern match fail, the program stops? (how to this and account for []?)
12:39:02 <accel> i just almost had an heart attack
12:39:07 <accel> ! became intuitive
12:39:11 <accel> i suddenly understood why ! should behave like seq rather than deepseq
12:39:12 <Eduard_Munteanu> dark: you could do stuff like   xss <- get; case xss of [] -> ...; (x:xs) -> ...
12:39:23 <accel> it's as if the designers of haskell understood laziness better than me, all these years
12:39:30 <copumpkin> :)
12:39:54 <Eduard_Munteanu> dark: and yes, a pattern match failure makes your program quit and print an error message
12:40:12 <dark> no syntax sugar for this? maybe do { get <something> [] -> .. | (x:xs) -> .. } would seem useful
12:40:40 <dark> I saw this (x:xs) <- get in a example and i get worried with code like that
12:41:00 <accel> it's called pattern matching
12:41:04 <Eduard_Munteanu> Well using a list as state isn't a major usage pattern.
12:41:11 <accel> the (:) serves as the constructor
12:41:16 <accel> the (x:xs) is really ((:) x xs)
12:41:22 <accel> but the () does magic, splicing I think
12:41:27 <shachaf> accel: It's called evil partial functions.
12:41:39 <accel> Bynbo7: look in awe of my haskell understanding; be proud of my knowledge
12:41:44 <shachaf> I'm pretty sure dark knows what pattern matching is.
12:42:14 <Eduard_Munteanu> dark: you could break up your code so that you have a separate function handling pattern-matching
12:42:37 <Eduard_Munteanu> dark: get >>= f   where f [] = ...    f (x:xs) = ....
12:42:42 * dark comes from ocaml (and repeated this lots of times), there a non-exhaustive match is a warning by default..
12:43:12 <Eduard_Munteanu> dark: yes, at compile-time, that happens with GHC as well with -Wall or a more specific option.
12:43:22 <dark> Eduard_Munteanu, hmm. but then the pattern match for <- construct is less useful. (unless it is for a ADT with just one branch)
12:43:28 <Eduard_Munteanu> But at runtime you can't really get past a pattern-match failure, unless you use exceptions
12:43:39 <thoughtpolice> dankna: touching everything in compiler/ sounds about right, changing GHC to be a cross compiler is going to touch literally almost everything - i speculate just after these threading changes, there will be plenty remaining. the build system (we'll want marlow's help with that, because that one is biiiig,) things like phunge's hsc2hs cross-compile mode, the tools used to build GHC during a build (like genprimopcode,) and the runtime system will 
12:43:52 <dankna> thoughtpolice: yeah, indeed, I agree.
12:44:16 <accel> what's the ghc equiv of "gcc -Wall" ?
12:44:17 <Eduard_Munteanu> dark: I'm not sure what you mean. Lists are ADTs.
12:44:21 <dankna> thoughtpolice: your message was too long for IRC and was cut off at "the runtime system will".
12:44:26 <thoughtpolice> dankna: but we'll get lots of nice things in return. it'll be much more feasible for GHC on other platforms, and we will also probably be able to finally kill the evil mangler, and via-C backend forever
12:44:33 <Eduard_Munteanu> accel: ghc -Wall ?
12:44:35 <thoughtpolice> dankna: " and the runtime system will probably need its share of tweaks"
12:44:40 <dankna> ah, yeah
12:44:49 <dankna> yes, it will be great to have it done
12:44:49 <dark> Eduard_Munteanu, I mean like data A = A int. so a match like (A n) <- get is safe
12:45:06 <thoughtpolice> dankna: so, there are a lot of places we can tackle. just these threading changes for the native code generators is a GREAT start
12:45:14 <dankna> thoughtpolice: indeed :) thanks
12:45:35 <thoughtpolice> (I was reading the x86 code generator code yesterday to help ezyang, and there are some very non-pretty things there in all their macro'd up, preprocessor-glory)
12:45:50 <dankna> there certainly are
12:45:58 <dark> lists would be like data List a = [] | a : List a (or something like that), with two "branches" (not a very good name), so matching for just one case isn't enough
12:46:42 <Eduard_Munteanu> dark: oh, yeah, but most Haskell functions do pattern-match for the empty list and the other case
12:47:08 <Eduard_Munteanu> f [] = ...    f (x:xs) = ...   is pretty common
12:47:36 <dark> yes, haskell lets one define partially a function, and then cover up the other cases latter. but <- wouldn't
12:47:57 <Eduard_Munteanu> This isn't about '<-'
12:48:21 <Eduard_Munteanu> The same thing happens if you use a 'where' clause and use non-exhaustive pattern matches.
12:48:45 <Eduard_Munteanu> Consider f a = x where (x:xs) = g a
12:49:37 <Eduard_Munteanu> Or if you use partial functions like 'head'.
12:49:42 <Eduard_Munteanu> @src head
12:49:42 <lambdabot> head (x:_) = x
12:49:42 <lambdabot> head []    = undefined
12:49:49 <smarmy_> i think dark was very specifically asking about the lack of ability to do exhaustive case analysis in with "<-"
12:49:51 <dark> hm o.o ocaml is even more restrictive, because it doesn't let one do partial function definitions, so often one can't do pattern match on function parameters
12:50:52 <Eduard_Munteanu> Well I'm not sure what counts as partial there... I think something like head [] = error "..."  is still partial
12:51:55 <shachaf> Eduard_Munteanu: Yes, but explicitly so.
12:53:16 <dark> Eduard_Munteanu, in ocaml it would be: let head [] = .. but then one can't define head for other cases (t will forever have this pattern failure)
12:54:12 <Eduard_Munteanu> Really? It sounds a bit odd.
12:54:19 <gaze__> pinging dons! I'm trying to build your Yices-painless package but it's dying at "Yices/Painless/Base/C.hsc:705:28: Malformed entity string"
12:54:42 <dark> if you define head again, the old will be shadowed. so pattern matching on function parameters is less useful (still useful for tuples, records, those types)
12:55:12 <dark> oh, tuples, haskell's <- is useful for (a, b) <- ..
12:55:14 <Eduard_Munteanu> dark: doesn't it depend on how you order those definitions?
12:56:21 <dark> Eduard_Munteanu, no. it doesn't have the concept of partial definition at all. also, the ordering is important, because you can't reference what wasn't defined and maybe because the language is imperative as well o.o
12:57:21 <dark> in fact in haskell I appear to be able to define a class instance before defining the type, this is insane:)
12:57:41 <robryk> dankna: if i may, what do you plan to do with targets lacking access to hardware stack? (all PICs are such, aren't they?)
12:58:25 <Eduard_Munteanu> dark: that's rather how parsing is done
12:59:16 <dankna> robryk: (I believe you're right about that.)  whatever we're currently doing.  I'm not trying to add new backends - at this juncture, at least.  I think that means we aren't supporting them just yet.  maybe in a future development effort.
12:59:57 <robryk> oh; ok
13:00:11 <dankna> sorry to disappoint :)
13:00:22 <thoughtpolice> robryk: given what I know of GHC, i'm not sure how much machinery would need to be put in place to make that even possible
13:02:08 <gaze__> actually, does anyone know what "Malformed entity string" means wrt the haskell FFI?
13:02:14 <Eduard_Munteanu> Lack of a hardware stack is just one problem... do you think the RTS actually fits on a PIC?
13:02:58 <fryguybob> gaze__: What version of GHC are you using?
13:03:13 <gaze__> 6.10.4
13:03:22 <thoughtpolice> robryk: I don't know a lot about PICs though. for one thing, GHC does not use the hardware stack (or what you'd know as the C stack generally) in generated code by the compiler - it has its own stack as part of the STG machine which is pointed to by a register.
13:03:37 <thoughtpolice> so, in that sense, code generated by the compiler doesn't need to worry about the hardware stack too much
13:03:41 <thoughtpolice> but the RTS does
13:03:51 <thoughtpolice> and the RTS is mammoth already in its size - nearly 50k lines of C code
13:04:00 <gaze__> wait does someone wanna run haskell on a PIC?
13:04:02 <thoughtpolice> furthermore it uses lots of GNU extensions
13:04:33 <fryguybob> gaze__: Looking at that C.hsc it does seem a little strange.  I would expect it to be "yices_set_verbosity" instead of "yices yices_set_verbosity"
13:05:02 <fryguybob> gaze__: I've successfully built with 6.12.3.
13:05:04 <Eduard_Munteanu> Unless someone figures out how to deal with GC and all that reasonably in a few KiBs, you ain't gonna see Haskell on PIC.
13:05:29 <Eduard_Munteanu> Maybe something like JHC's region inference might have a chance, though IIRC that really used a lot of memory.
13:05:46 <gaze__> haskell as it stands doesn't have a chance on a PIC
13:05:48 <gaze__> at all
13:05:51 <thoughtpolice> I think that the model GHC uses for imperative code - C minus minus - is in fact quite possible to compile down to a PIC since it's sort of like an SSA form that has 'infinite registers' and you spill out things later, but i don't know how that would look
13:05:52 <Eduard_Munteanu> Yeah.
13:06:01 <thoughtpolice> Eduard_Munteanu: JHC has an actual GC now that's based on a slub-allocator
13:06:16 <thoughtpolice> I don't know about PICs, but the code JHC generates is, for the most part, standard ISO C99
13:06:23 <thoughtpolice> it should run just about anywhere normal C code can
13:06:23 <Eduard_Munteanu> slub as in Linux's SLUB?
13:06:48 <systemfault> slab/sleb/slib/slob/slub
13:06:52 <thoughtpolice> the design is inspired by it and bonwick's slab allocator, yes
13:07:54 <gaze__> the PIC as it stands is already a pretty outdated architecture
13:07:55 <Eduard_Munteanu> Well is it actually GC or just a backend for region inference?
13:07:58 <thoughtpolice> basically JHC has a slab-like allocator for data types - a slab for Char types, a slab for Maybe, etc. JHC also does some sophisticated storage analysis and can for example, represent 'Maybe' as a single word holding a 'Just a' value, or a NULL pointer, without tag bits. this complements the allocator design, so it can maximize the amount of values that will fit in a cache line, for example
13:08:03 <robryk1> oh. i thought it used hardware stack
13:08:08 <thoughtpolice> it has an actual GC
13:08:15 <robryk1> then it shouldn't be problematic
13:08:27 <gaze__> I could potentially see haskell running on some of the lower end cortexes
13:08:43 <thoughtpolice> people have already gotten haskell running on ARM through JHC at least for a while
13:08:53 <thoughtpolice> as far back as several years, people had much success compiling JHC code on nokia phones
13:08:56 <Eduard_Munteanu> ARM is a lot more powerful though
13:09:11 <thoughtpolice> oh i thought when he said 'cortex' he meant like an ARM model
13:09:13 <thoughtpolice> i'm confused
13:09:21 <Eduard_Munteanu> Cortex is an ARM core.
13:09:24 <ddarius> Virgil is an interesting point in the very-small-devices space.
13:09:34 <dark> thoughtpolice, how can one have an allocator for.. char?
13:09:38 * Eduard_Munteanu heard that before, but didn't look into it :/
13:10:05 <gaze__> yes!
13:10:07 <Eduard_Munteanu> dark: an allocator for char would consider an alignment of 1 for instance
13:10:28 <thoughtpolice> dark: if you read up on the design of a SLAB allocator, basically it is a construct that allows you to quickly construct objects of a given type. this sort of design is used in the linux kernel for example, so you can quickly allocate data structures, and also avoid fragmentation in your heap
13:10:38 <gaze__> there's a minimal CLR that can run on certain ARMs
13:10:47 <thoughtpolice> dark: the canonical reference is bonwick's paper from '92, search 'Jeff Bonwick slab allocator'
13:11:13 <thoughtpolice> dark: for example, in linux you may want to have a lot of mutex objects which represent user-space mutexes
13:11:34 <thoughtpolice> so the kernel uses the slab allocator to quickly construct 'mutex' objects whenever your user-land program creates them
13:12:41 <thoughtpolice> it's better to use a specific sort of 'cache' like the SLAB for allocating these mutex objects then kmalloc, because you don't get guarantees on fragmentation for one, while the slab allocator will make sure you use up all the space in the heap. it can also quickly allocate/deallocate these structures from its heap
13:12:50 <Eduard_Munteanu> Also there are considerations like cache-locality and that sort of stuff.
13:12:54 <thoughtpolice> yes
13:13:13 <thoughtpolice> like I said, john designed the SLAB allocator in JHC to work with his storage inference algo, so he could maximize cache line usage
13:13:19 <thoughtpolice> that's actually why JHC generated programs are so fast
13:13:27 <thoughtpolice> john pays much attention to cache resource utilization
13:14:38 <thoughtpolice> he actually departs from the other research on GRIN for example, which normally inlines 'eval/apply' procedures so you can turn foldl into a strict loop without much work on the programmers part. he found for example, just having eval use built-in jump tables for node indirections was way better, because once the jump table is in the cache it killed all the benefit inlining 'eval' gave
13:15:31 <Algo> Why is #haskell blocked from /list?
13:15:32 <thoughtpolice> these were fairly confusing design choices that were very undocumented as far as me and Lemmih were concerned when we started toying around after forking JHC, but they do make sense
13:15:50 <niko> Algo: because it's +s
13:16:19 <niko> Algo: and /msg alis help list is better than list 
13:16:53 <lispy> thoughtpolice: are there lessons there that could be applied to GHC?
13:17:06 <lispy> thoughtpolice: (and have you thought about applying them?)
13:17:37 <gaze__> why fork JHC?
13:17:49 * hackagebot shellish 0.1.4 - shell-/perl- like (systems) programming in Haskell  http://hackage.haskell.org/package/shellish-0.1.4 (PetrRockai)
13:18:03 <thoughtpolice> lispy: I don't know, john has stated that JHC's design is radically different in some spots deliberately so he could depart from GHC's methodology. there are things we could probably learn however, I've been thinking about it as I begin to hack on GHC more and more
13:18:24 <thoughtpolice> lispy: in short, maybe, and yes :)
13:18:29 <lispy> thoughtpolice: that's great!
13:18:38 <robryk> why does ghc use its own stack?
13:18:47 <thoughtpolice> gaze__: we wanted to experiment with whole program optimization, and john did not agree with many of the things we wanted to implement
13:19:16 <thoughtpolice> for one, john detests cabal. he would have never accepted our work for that, although he did take in some of the other patches we did which improved GHC's optimization algorithms and made it much faster in compilation speed
13:19:23 <lispy> robryk: what other stack would/should it use?
13:19:26 <gaze__> does jhc have it's own codegen?
13:19:30 <robryk> hardware stack
13:19:36 <robryk> ie. the call stack
13:19:39 <gaze__> that looks like a HUGE project, is it one person's work?
13:20:06 <thoughtpolice> robryk: it's a hold-over from the old days of the STG machine from what I understand - the STG stack is totally independent of the C stack. many ML implementations actually record things like activation frames on the heap and use the garbage collector to collect them
13:20:19 * Eduard_Munteanu goes watch a movie
13:20:20 <thoughtpolice> GHC has a really good GC now, so that would be interesting, but according to simon, the STG stack is deeply interwoven into GHC
13:20:23 <robryk> what are activation frames?
13:20:25 <Algo> Anyone here use Haskell on the job?
13:20:30 <thoughtpolice> it would be an incredibly mammoth change to remove it - on the order of replacing the Core language
13:20:40 <lispy> Algo: yes, several people
13:20:46 <thoughtpolice> robryk: you can think of them as 'stack frames' basically, they record the information pertinent to a function when you call it
13:21:06 <accel> window 3
13:21:06 <heatsink> It _might_ seriously complicate FFI calls, since right now you can call back and forth between Haskell and C.
13:21:07 <thoughtpolice> like where it's arguments are, and where it returns to, etc..
13:21:12 <heatsink> if you unified the stacks I mean
13:21:15 <thoughtpolice> gaze__: yes, john wrote JHC by himself
13:21:21 <thoughtpolice> over the course of many years
13:21:44 <robryk> oh
13:21:45 <thoughtpolice> according to his notes the initial implementation was so he could teach himself haskell, by writing a haskell compiler. that started around 1999/2000. JHC didn't have a public release until about 2005/2006
13:22:10 <accel> that soudns slightly badass
13:22:13 * lispy never understood the anti-cabal sentiment.  If you like haskell and you think cabal is so broken as to avoid it, then help fix cabal.
13:22:32 <ddarius> lispy: And if cabal is fundamentally broken?
13:22:34 <robryk> okay, it is significantly more complicated than codegen&tc. for combinator calculus
13:22:46 <lispy> ddarius: then fix the specification
13:22:55 <accel> I believe the point is: "don't bitch; if you don't like it, create something better & we'll switch"
13:23:07 <accel> I believe the point is: "don't bitch; if you don't like it, create something better & we'll switch" (i.e. rather than bitching CVS sucks, someone said fuck it, i'll write git)
13:23:17 <thoughtpolice> gaze__: cabalization was one of the main things me and lemmih wanted, and john wouldn't have accepted that. john is also rather spurious in his updates and commits, and me and lemmih wanted to try to make JHC's (admittingly awesome) technology more accessible.
13:23:28 <aristid> ddarius: the question is whether the alternative that you're using is less broken
13:23:28 <thoughtpolice> we inevitably ended up dumping the code base however, it was far too hard to work with
13:23:35 <accel> thoughtpolice: what does jhc provide that ghc does not?
13:23:38 <thoughtpolice> (literally 90% of JHC exists inside IO + IORefs everywhere)
13:23:50 <lispy> thoughtpolice: oh wow.
13:23:52 <thoughtpolice> (which = impossible to reason about)
13:23:55 <gaze__> eeew
13:24:05 <gaze__> sounds like he couldn't drop the imperative part of his brain
13:24:20 <c_wraith> accel: the biggest neat feature of JHC is that it outputs standard C code, which can easily be compiled on multiple different platforms.
13:24:22 <thoughtpolice> there were also magic parts of the compiler that were magic because john didn't think out the design enough in some places, and had to pay for it later
13:24:30 <lispy> thoughtpolice: darcs source is similar in that it's all in IO manipulating files.  Gets hard to reason about too actually.
13:24:34 <gaze__> ohh! so it doesn't have its own codegen
13:24:38 <gaze__> still impressive...
13:24:42 <thoughtpolice> accel: whole program compilation and a radically different compilation model throughout, particularly typeclass implementation
13:25:18 <thoughtpolice> gaze__: yes, it just generates C code. that was one of john's design considerations - having a cross compiler by default means that when you can self-host, you automatically get every platform for free, and optimizing the compiler pays off in making the compiler faster
13:25:22 <lispy> Yeah, I wish ghc had support for outputting clean C and options for lightweight (or improverished) RTSs
13:25:31 <ddarius> accel: John likes franchise, if I understand correctly.
13:25:39 <lispy> ddarius: franchise is dead
13:25:53 <lispy> But he did like it
13:26:19 <lispy> it hasn't been updated since late 2008
13:26:21 <accel> thoughtpolice: ghc doesn't do full program compilation?
13:26:26 <accel> ddarius: what does 'franchise' mean in this context?
13:26:29 <lispy> accel: nope.
13:26:43 <lispy> accel: franchise was a direct competitor to cabal that droundy started
13:26:49 <thoughtpolice> lispy: yeah, me and lemmih (mostly lemmih, bless his amazing work ethic) went through a LOT of work. at one point, we actually had almost 100% of jhc's compilation phases being pure code!
13:26:56 <accel> lispy: ghc optimizes a single module at a time; and doesn't optimize across modules?
13:26:57 <lispy> accel: it's meant to mimic autotools
13:27:00 <gaze__> I'm writing a hardware compiler... debating whether or not to output simulation code LLVM IL or just straight C
13:27:08 <gaze__> kinda leaning towards C haha
13:27:10 <thoughtpolice> accel: GHC will do cross module optimization in some cases
13:27:17 <accel> gaze__: I think you should output bits and atoms
13:27:24 <lispy> accel: you get cross module inlining in GHC
13:27:26 <accel> thoughtpolice: how does that differ from whole program optiziation?
13:27:28 <thoughtpolice> accel: for example, if you mark something as INLINE or INLINABLE, it will stuff the definition for it into the interface files GHC generates
13:27:36 <accel> how does "whole program optimization" and "optimize acrossm odules" differ?
13:27:42 <accel> how does "whole program optimization" and "optimize acrossm odules" differ? (what does the former do that the altter does not)
13:27:44 <ddarius> accel: Technically it's a very minor form of "whole program optimization".
13:27:46 <thoughtpolice> when you compile other modules that use it, the entire definition is available for further optimization
13:27:52 <thoughtpolice> accel: because it doesn't get to view the whole program
13:27:56 <thoughtpolice> GHC still compiles one module at a time
13:27:58 <thoughtpolice> that's all it can see
13:28:03 <lispy> accel: some folks are looking at doing super compilation in GHC
13:28:10 <lispy> accel: so there is active research on this front
13:28:16 <accel> so 'cross module optimization' only gets to view "inlines of am module", and treats the other functions as black boxes?
13:28:26 <ddarius> Supercompilation is not equivalent to whole program optimization.
13:28:27 <thoughtpolice> accel: when JHC compiles a program, it literally sees the ENTIRE program in memory, everything from your code, to every library you use, to the entire standard library
13:28:29 <gaze__> super compilation as in super optimization?
13:28:39 <accel> gaze__: as in super duper optimiation
13:28:41 <gaze__> that thing where you brute force instruction streams?
13:28:46 <accel> gaze__: as in super duper optimiation (with blinking golden stars)
13:28:48 <ddarius> gaze__: No.
13:29:02 <accel> gaze__: I think that's called a superoptimizer, wome work done at stanford with assembly code generation
13:29:07 <thoughtpolice> accel: so when JHC compiles your code, it can do things like eliminate dead-code and do inter-procedural optimization with knowledge of the ENTIRE program, not just the module currently in scope or being compiled
13:29:16 <gaze__> muhh... what was that paper on "quajects"... he called that super optimization
13:29:16 <tibbe> anyone feel like reviewing my API docs before I make a release? http://johantibell.com/files/unordered-containers/
13:29:19 <thoughtpolice> accel: this design is crucial to JHC's implementation of typeclasses which are extremely efficient
13:29:21 <accel> thoughtpolice: is JHC slower than c++ template metaprogramming?
13:29:22 <lispy> ddarius: my naive understanding is that if you have super comp you don't really need whole program stuff.
13:29:34 <accel> JHC actually soudns kinda cool
13:29:37 <thoughtpolice> JHC's typeclass implementation also depends heavily on its core language E, being a variant of a pure type system
13:29:39 <ddarius> lispy: Your naive understanding is incorrect.
13:29:43 <gaze__> ah yeah, massalin's paper
13:29:45 <thoughtpolice> where values can be parts of types
13:29:50 <ddarius> Synthesis OS
13:29:54 <systemfault> accel: C++ metaprogramming is compile-time, I don't think that JHC is
13:30:09 <systemfault> (I might be totally out of track though)
13:30:13 <gaze__> sweet jesus that was a crazy paper.
13:30:16 <thoughtpolice> well, they're fairly incomparable, i don't really know how to answer that question
13:30:25 <thoughtpolice> I can tell you that JHC used to be really, really, *REALLY* bad
13:30:26 <ddarius> gaze__: It was a pretty good paper for the time.
13:30:37 <thoughtpolice> like, i can remember it taking 20min + 1GB of RAM on my old pentium 4
13:30:40 <gaze__> how is it not still a good paper?
13:30:41 <thoughtpolice> to compile "hello world"
13:30:42 <thoughtpolice> (no joke)
13:31:02 <thoughtpolice> now it can compile actually not-totally trivial programs in a few seconds, although it still has tons and tons of rough edges
13:31:02 <accel> gaze__: link"" I can't find he paper
13:31:12 <ddarius> gaze__: It's way out-dated in pretty much every respect now.
13:31:30 <ddarius> gaze__: If it was published today, it would be a pretty crappy paper.
13:31:32 <accel> thoughtpolice: JHC = 20 min + 1 GB RAM to compile main = putStrln "Hello World" ?
13:31:36 <aristid> thoughtpolice: so it still is more of a proof-of-concept?
13:31:39 <thoughtpolice> accel: yes, this was circa 2006
13:31:53 <accel> thoughtpolice: so using moor's laws, this would now be what, 5 mins + 1 GB RAM ?
13:32:07 <accel> thoughtpolice: so using moor's laws, this would now be what, 5 mins + 4 GB RAM (accounting for increased memory inefficiens)
13:32:11 <thoughtpolice> aristid: yes, JHC has an extremely interesting and radically different design from basically every other haskell implementation. it has lots of very, very intriguing ideas
13:32:15 <gaze__> I still wanna believe that runtime code generation is a good idea... I guess you end up rapeing your d-cache
13:32:15 <thoughtpolice> I would also say that when JHC actually works
13:32:18 <thoughtpolice> it regularly kicks ass
13:32:22 <gaze__> err, i-cache
13:32:23 <thoughtpolice> i.e. programs are faster than GHC equivalents
13:32:49 <thoughtpolice> accel: part of it was just due to bad implementations of optimizations and having lazy values stick around, etc.. Many of those issues have since been fixed
13:32:52 <accel> does JHC have a dedicated irc channel? sounds like a small team, maybe I can get ops there
13:33:04 <thoughtpolice> JHC can compile like I said, not totally trivial programs in a few seconds these days
13:33:07 <thoughtpolice> without much RAM at all
13:33:08 <accel> thoughtpolice: is the JHC compiler writter in JHC ?
13:33:11 <thoughtpolice> no
13:33:14 <thoughtpolice> it can't self-compile
13:33:16 <thoughtpolice> nowhere near that yet
13:33:38 <thoughtpolice> when I say 'not totally trivial' I mean 'totally trivial' as in "hello world" - there are tons of real world, small programs it still cannot handle
13:33:39 <accel> so it's still written in GHC
13:33:41 <thoughtpolice> for one reason or another
13:33:48 <thoughtpolice> accel: it's written in haskell and compiled with GHC, yes
13:34:52 <thoughtpolice> aristid: i'd say JHC is definitly a proof of concept still, but it's improving, and even then it's a damn interesting design and implementation of a compiler. i do admire john's work and tenacity, even if the code is hard as hell to grok
13:35:27 <aristid> thoughtpolice: proof-of-concepts exist for a reason: they prove a cool concept :)
13:35:28 <thoughtpolice> like lispy said, we can just steal as many ideas as applicable and put them in GHC in the mean time too. ghc is a research vehicle for many things too, after all.
13:35:54 <accel> how much of GHC"s core is still written in C?
13:36:11 <thoughtpolice> the runtime system is written in C
13:36:13 <thoughtpolice> and there's a lot of it
13:36:16 <thoughtpolice> about 50k LOC
13:36:20 <accel> EWWWWW
13:36:33 <lispy> GHC's RTS can basically act as an OS
13:36:35 <accel> does JHC depend on a C runtime?
13:36:44 <thoughtpolice> lispy speaks the truth.
13:36:48 <accel> i.e. the binary produced by JHC
13:36:49 <ddarius> lispy: Most high-level language run-time systems can.
13:37:04 <thoughtpolice> accel: yes, the binary produced by JHC depends on libc like everything else naturally
13:37:07 <lispy> ddarius: php on bare metal!
13:37:20 <dark> lispy, there are smaller OSes out there
13:37:20 <thoughtpolice> even better, there was that lisp -> php compiler
13:37:24 <thoughtpolice> lisp on php on bare metal
13:37:37 <thoughtpolice> take that, C programmers
13:37:47 <lispy> thoughtpolice: better throw in javascript so we can have node.js !
13:38:02 <thoughtpolice> oops sorry i have to do blocking i/o
13:38:04 <thoughtpolice> :(
13:38:26 <thoughtpolice> seriously though, node.js is probably webscale. i think.
13:38:29 <thoughtpolice> i suck at this meme.
13:38:57 <lispy> We should add sharding to ghc, now that you mention it
13:39:35 <thoughtpolice> i'll also add a nosql implementation in the runtime that will store key-values, mapping GC roots to where values actually live, got it.
13:39:38 <shachaf> lispy: GHC does have pretty good /dev/null support, at least.
13:42:51 <jaj> hi, ghc runs out of memory when I try to compile gtk2hs: http://www.pastie.org/pastes/1580380/text
13:43:13 <jaj> I tried to increased the heap with +RTS -m but it didn't help
13:43:52 <jaj> this is obviously not a physical limitation since I have more than 1G of free RAM
13:44:09 <applicative> tibbe, the haddocked pages seem good.  Not sure why you write "this map" frequently, rather than "the map", as you do "the key", but it doesn't matter.  
13:44:26 <tibbe> applicative: ok thanks, it's by design
13:44:34 <tibbe> applicative: (perhaps not a good design but still)
13:44:43 <applicative> yes it was clear, it was too consistent...
13:44:53 <applicative> I mean, it was clear it was intended. 
13:44:59 <tibbe> right
13:50:17 <joe6> undefined reference to `LLVMAddVerifierPass'
13:50:35 <joe6> i get the above error when trying make in llvm/examples: http://pastebin.com/eUbVuYr3
13:50:40 <joe6> any thoughts, please?
13:53:18 <accel> Is there a book to read on "how to implement a haskell compiler"
13:53:24 <accel> xplat , Bynbo7 : ^ see above, time to sugggest a book
13:53:49 <edwardk> accel: kinda. but it predates haskell. 
13:54:08 <copumpkin> edwardk: you could've snuck in easily
13:54:21 <edwardk> http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
13:54:23 <edwardk> figures
13:55:12 <accel> edwardk += (INT_MAX - edwardk) + 1
13:55:47 <accel> edwardk: what is a good haskell library
13:55:48 <edwardk> also http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
13:55:49 <accel> for outputting binaries
13:56:02 <accel> like if I wanted to write elf binary directly
13:56:24 <thoughtpolice> edwardk: I have that book in hard back! i want spj to sign it if i ever meet him
13:56:36 <accel> will spj ever win teh turing?
13:56:39 <lispy> accel: we have a library for elfs (or was it dwarf?)
13:56:39 <thoughtpolice> (college professor had a copy and i said i was looking for a copy, he said 'lol take this one')
13:56:48 <lispy> accel: Have you seen hackage yet?
13:56:48 <edwardk> ah. i usually reinvent something like binary/cereal
13:57:10 <lispy> accel: elf parser: http://hackage.haskell.org/package/elf
13:57:11 <edwardk> thoughtpolice: nice!
13:57:29 <thoughtpolice> in perfect condition too, even after 20 years
13:57:56 <thoughtpolice> accel: if you use an elf library you will have to manually generate assembly to fit into the binaries text. generally speaking, you don't want to do that
13:58:06 <thoughtpolice> it would be better to just ouput ASM, and then feed it to GNU as or somesuch
13:58:17 <accel> thoughtpolice: hmm; ideally I just want to hook into LLVM
13:58:18 <thoughtpolice> it'll generate the binary for you and you don't need to worry about supporting elf/mach-o/dwarf, etc
13:58:41 <thoughtpolice> accel: that works too, but writing out elf binaries manually is going to be fairly, uh, grueling and likely unneeded work is what I was getting at :)
13:58:51 <edwardk> thoughtpolice: i just ordered a copy through amazon. i figure i've referenced it enough over the years to justify having it in dead tree form
13:59:14 <accel> why are ups delivery always male, never female?
13:59:28 <thoughtpolice> edwardk: yeah, the chapter on actually typechecking programs was what made it somewhat finally 'click' for me
13:59:42 <edwardk> *nods* and wadler's chapter on pattern matching
13:59:44 <accel> edwardk: which book is this?
13:59:47 <joyfulgirl> accel: My local UPS driver is a woman
13:59:56 <thoughtpolice> accel: the SPJ book he linked to
13:59:56 <edwardk> http://www.amazon.com/Implementation-Functional-Programming-Prentice-Hall-International/dp/013453333X
14:00:02 <edwardk> sorry, i bought the last cheap copy ;)
14:00:09 <thoughtpolice> it's fairly old, and doesn't represent what GHC today does, but it's still a great reference for implementation
14:00:17 <accel> edwardk: it's okay; you ran resell it for 0.01; I'll buy it
14:00:23 <thoughtpolice> and describes lots of things that are still crucial to GHC, like lambda lifting and full laziness transformations
14:00:24 <edwardk> it was the second book i linked
14:00:59 <ray> because ups basically just enjoys oppressing women
14:01:03 <thoughtpolice> other things like the G-machine implementation chapter was supersceded by the STG machine work, and it doesn't cover things like the Cmm language which didn't show up until about 10 years later
14:01:12 <thoughtpolice> but it's still a great book
14:02:41 <ray> simon l. peyton jones?
14:02:44 <ray> i didn't know he had an l
14:03:26 <thoughtpolice> peyton-jones is technically his whole last name
14:03:31 <thoughtpolice> lester being the middle name
14:04:02 <ray> if you were spj you could click on that "i own the rights to this title and would like to make it available through amazon" link
14:04:12 <edwardk> =)
14:04:29 <dankna> we've had students here who had four last names, because their parents each had two last names, and all parents and grandparents involved could not reach a decision on whose name to inherit...
14:04:40 <accel> dankna: yay feminism
14:04:48 <dankna> accel: well, yay something, that's for sure
14:04:53 <edwardk> dankna: i feel sorry for the next generation after
14:04:58 <dankna> edwardk: I concur
14:05:02 <shachaf> accel: It has nothing to do with feminism.
14:05:08 <accel> dankna: yay ppl that print names, who chage by the letter
14:05:14 <dankna> accel: haha
14:06:04 <ray> i really think people should take the name of the higher ranked family, too bad that political correctness gone mad prevents that
14:06:34 <dankna> well, there's a definite problem with changing one's name as an adult if one is already a published author
14:06:43 <dankna> it breaks old citations :)
14:06:57 <dankna> and keeps people from recognizing you
14:07:01 <accel> who wants to marry a girl with a PhD anyway?
14:07:07 <ray> the lower ranked spouse joines the higher ranked spouse's family (possibly changing their name), and the children of this union take on the higher ranked name
14:07:08 <enthymeme> a guy with a PhD?
14:07:09 <edwardk> dankna: or with having written stuff under pseudonyms
14:07:10 <dankna> hey, I might be a girl with a PhD, you don't know :)
14:07:14 <ray> it only really matters for children
14:07:21 <accel> dankna: I don't intend in proposing to you
14:07:25 <dankna> bah!
14:07:31 <enthymeme> or a guy who likes highly educated women?
14:07:40 * enthymeme is dating a physics/linguistics double major
14:07:48 <dankna> that's an interesting major
14:07:54 <enthymeme> it's two majors
14:07:56 <accel> physis/linguistics, is that dr hyde/... ?
14:08:08 <enthymeme> I'm comparatively less creative. CS/Math
14:08:41 <dankna> and then of course in some cultures there are multi-part "first" names.  I'm not sure exactly what gives rise to those.
14:08:41 <edwardk> enthymeme: you're in good company around here ;)
14:08:42 <ray> see under my system the phd fetishist is clearly inferior to the phd holder, so the children would have the mother's name and be recognized as the children of the famed dr. whatever, author of 75 books
14:08:53 <ray> in some cultures there are patronymics
14:08:56 <enthymeme> edwardk: haha, yesss, indeed.
14:09:30 <dankna> but what if both parents are phd holders?  do you go by who has more publications?
14:09:44 <ray> you put it up for peer review
14:09:46 <edwardk> dankna: citations clearly
14:09:52 <dankna> edwardk: ha :D
14:09:59 <dankna> or what if they're both phd fetishists lying about the fact that they hold phds, does that change anything
14:10:21 <dankna> for any reasonable solution you can propose, I can propose arbitrary complications!
14:10:27 <ray> their children can swear off both names
14:10:42 <ray> because they have such embarassing parents that never publshed a paper in their lievs
14:10:47 <edwardk> and what if one, like my wife goes for something like a DPT instead?
14:11:20 <ray> that's still doctoral at least
14:11:24 <dankna> and do medical doctors outrank PhDs or vice-versa?
14:11:54 <ray> math phds outrank doctorates in usefulness outrank other phds
14:11:58 <ray> according to me at least
14:12:24 <dankna> oh, so it's the xkcd continuum, math >> physics > chemistry > sociology?
14:12:33 <ray> no no no
14:12:37 <ray> physics is way down there
14:12:46 <edwardk> dankna: and how many masters degrees do i need to trump a ph.d?
14:12:47 <dankna> I suspect partisanship!
14:12:54 <dankna> edwardk: yeah, that's what I want to know :D
14:13:06 <dankna> and how many lines of code to trump a master's
14:13:18 <enthymeme> I'm going on record as saying that this discussion hurts my brain
14:13:25 <dankna> enthymeme, consider it noted
14:13:30 <ray> well of course. you probably only have 2 or 3 doctorates
14:13:40 <enthymeme> dankna: cool
14:13:48 <edwardk> dankna: i'd like to note that lines of code would be a terrible metric for that ;) how many lines saved through refactoring might be better
14:13:57 <dankna> edwardk, hah, true.
14:14:17 <Eduard_Munteanu> Isn't a doctorate the same thing as PhD? :/
14:14:18 <dankna> but you can't easily measure that - you can't go by lines deleted because I can rm -rf gcc all night long.
14:14:41 <ray> you can refactor gcc into printf("use haskell stupid\n");
14:14:59 <dankna> for bonus points you need to add the -fvia-haskell command-line option to gcc
14:15:08 <ray> no a phd is a doctor of philosophy which is different from a doctor of medicine or a doctor of law or a doctor of something else
14:15:25 <robryk> about multipart first names -- there were many St Johns and this gives rise to jean baptise or jan kanty
14:15:37 <Eduard_Munteanu> Well, excluding medicine and law
14:15:39 <edwardk> dankna: hence why i went for refactored. lines removed while retaining equivalent functionality and maintainability, but the latter is a bit subjective
14:15:41 <dankna> robryk, true.
14:15:48 <ray> basically you get a phd for being an academic
14:15:54 <dankna> edwardk: yeah, that makes sense to me then.
14:15:58 <Eduard_Munteanu> I thought for stuff like CS, doctor and PhD were equivalent.
14:16:12 <ray> MDs have to work for a living though
14:16:27 <thoughtpolice> welcome to #haskell, where the actual topic at hand is made up, and the points don't matter
14:16:30 <ray> DDSes sorta have to work for a living
14:16:34 <thoughtpolice> (also known as #haskell-blah ;)
14:16:48 <ray> welcome to #haskell, where the discussion is pointless
14:16:56 <edwardk> ray: pointfree
14:16:57 <companion_cube> pointfree*
14:17:06 <ray> it's not @pf
14:17:07 <ceii> @pl discussion
14:17:08 <lambdabot> discussion
14:17:08 <companion_cube> too slow :/
14:17:28 <dankna> @. pl vixen
14:17:28 <lambdabot> Hmmm
14:17:31 <Eduard_Munteanu> @pl \discussion -> resolution
14:17:31 <lambdabot> const resolution
14:17:38 <dankna> @. pl vixen
14:17:38 <lambdabot> (line 1, column 17):
14:17:38 <lambdabot> unexpected ","
14:17:38 <lambdabot> expecting variable, "(", operator or end of input
14:17:38 <Jesin> lol
14:17:40 <ray> i shouldn't talk i don't even have ONE LOUSY math phd
14:17:44 <ray> have to get on that one of these days
14:18:14 <dankna> @pl @pl
14:18:14 <lambdabot> (line 1, column 1):
14:18:15 <lambdabot> unexpected "@"
14:18:15 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:18:18 <dankna> hmm, okay
14:18:21 <edwardk> Eduard_Munteanu: from your definition, it would seem your problem solving technique doesn't change much from problem to problem
14:18:34 <Eduard_Munteanu> Yeah, that would be a panacea.
14:18:43 * ddarius dismisses everything ray has said due to his low rank.
14:18:47 <Eduard_Munteanu> @pl \problem -> getSolutionTo problem
14:18:48 <lambdabot> getSolutionTo
14:18:53 <ceii> @pl \problem -> solution
14:18:53 <lambdabot> const solution
14:18:57 <ceii> that's the world I want
14:19:14 <ray> zero math phds basically multiplies everything i say by zero
14:19:23 <edwardk> ddarius: you might want to consider the effect of such ranking on your own words ;)
14:20:13 <ddarius> edwardk: Allegedly I outrank a phd fetishist.
14:20:28 <ddarius> Or something.
14:20:43 <shachaf> How are these rankings calculated?
14:20:45 * ddarius has no idea how this works.  We should require emblems to indicate rank.
14:21:13 <edwardk> clearly we need some kind of stackoverflow badge system for degrees
14:22:09 <edwardk> or something more military one, M.S. silver star with two oak leaf clusters
14:22:19 * shachaf might compete for the lowst-ranked in this channel.
14:22:37 <Eduard_Munteanu> @karma Eduard_Munteanu 
14:22:38 <lambdabot> You have a karma of 1
14:22:44 <Eduard_Munteanu> Hrm, when did that happen...
14:23:00 <ray> > minBound
14:23:00 <lambdabot>   ()
14:23:15 <dankna> @karma dankna
14:23:15 <lambdabot> You have a karma of 1
14:23:16 <dankna> cool
14:23:21 <ray> whoever that is, that's the lowest person
14:25:08 * hackagebot sifflet-lib 1.2.3 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-1.2.3 (GregoryWeber)
14:25:11 * hackagebot sifflet 1.2.3 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-1.2.3 (GregoryWeber)
15:06:13 <pedro3005> I'm planning to code a program in haskell where I need to store, between program runs, strings (representing file names). Is JSON a good way to do it? What would be more appropiate within Haskell?
15:08:18 <joe6> pedro3005, memoize?
15:08:43 <joe6> pedro3005, i think you can store haskell data to a file and read it back when running again.
15:08:58 <joe6> in the same format as the haskell data structure.
15:09:07 <pedro3005> how?
15:09:15 <companion_cube> Read and Show typeclasses
15:09:31 <companion_cube> > read (show [1,2,3,4]) :: [Int]
15:09:32 <lambdabot>   [1,2,3,4]
15:09:36 <pedro3005> true!
15:09:38 <companion_cube> show [1..4]
15:09:41 <companion_cube> > show [1..4]
15:09:42 <lambdabot>   "[1,2,3,4]"
15:09:53 <pedro3005> :) I hadn't thought of that
15:10:07 <companion_cube> you just have to know which type you file contains :)
15:10:10 <cizra> pedro3005: Note that nothing in the language itself guarantees unambiguity.
15:10:23 <pedro3005> that might not be the best practice though, is it?
15:10:29 <cizra> pedro3005: If you write read/write serializations yourself, think about that.
15:10:29 <kafee> i cannot understand, why such code does not work: http://hpaste.org/44123/happstack ?
15:12:26 <pedro3005> Also what module of Haskell do I use to make system calls like move a file, get CWD, etc?
15:14:01 <cizra> pedro3005: Do you know about hoogle?
15:15:15 <pedro3005> cizra, i've heard of it
15:16:17 <heatsink> @where hoogle
15:16:17 <lambdabot> http://haskell.org/hoogle
15:17:16 <applicative> pedro4005 http://www.haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/System-Process.html or more crudely http://www.haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/System-Cmd.html
15:22:09 <acowley> Sometimes I have too much tied up in dynamic emacs state
15:22:31 <dankna> yeah, I hate that
15:22:39 <ddarius> Use Smalltalk.
15:22:45 <dankna> although this month I'm on one of my "don't use Emacs" kicks
15:22:51 <dankna> these seldom last, but it's nice to dream
15:23:06 <acowley> I thought it froze just now and had one of those "... and I didn't save my work!" kind fo reactions due to the variety of interesting buffers I have open.
15:23:14 * dankna nods
15:23:21 <acowley> dankna: I tried Squeek before and didn't really enjoy it
15:23:30 <dankna> acowley: you mean ddarius, we're distinct people
15:23:48 <acowley> dankna: Sorry!
15:23:51 <dankna> np
15:23:55 <c_wraith> what. everyone whose name starts with d is the same person!
15:24:01 <ddarius> dankna: How do you know we're distinct people?
15:24:10 <dankna> ddarius, because I don't remember typing that query
15:24:12 <acowley> c_wraith: that is clearly my working hypothesis
15:24:23 <ddarius> dankna: You may just be forgetful.
15:24:24 <acowley> dankna: What do you use when on such a kick?
15:24:43 <dankna> ddarius, you're right - I'd better check for outgoing connections...
15:24:58 <dankna> acowley, right now I'm using TextWrangler, which is the free version of BBEdit, but it's got some drawbacks
15:25:15 <dankna> (drawbacks which, alas, the commercial version does not address)
15:25:17 <acowley> Is there a way to somehow have GHCi pick up Paths_* modules generated by cabal?
15:25:36 <ivanm> acowley: ghci -idist/build
15:25:43 <acowley> dankna: I honestly have some trouble imagining using something other than emacs unless there's a really good reason
15:25:47 <acowley> ivanm: thanks!
15:26:01 <dankna> acowley, well, I agree.  but you'll concede that Emacs is terrible :)
15:26:03 <ivanm> acowley: wait, it's actually ghci -idist/build/autogen
15:26:25 <acowley> ivanm: I just discovered that, too :)
15:26:30 <acowley> dankna: the worst!
15:26:39 * dankna nods sagely
15:28:08 <kulakowski> dankna: It's not that emacs isn't terrible, it's that everything else is more terrible.
15:28:15 <dankna> oh, exactly
15:28:36 <dankna> whatever your killer feature is, Emacs has it - although it will take you a couple weeks to make it work properly
15:28:41 <ddarius> Solution: Throw away your computer.
15:29:05 <dankna> what problem is that the solution to?
15:29:27 <ddarius> dankna: Most problems brought up here.
15:29:45 <dankna> fair.
15:30:12 <acowley> That goes on the #haskell Jeopardy board
15:30:51 <tg_> my computer weighs like 80lbs. Throwing it anyway will be difficult, throwing it *away* will be more difficult.
15:35:27 <kulakowski> dankna: What other editors have you explored in your fleeting emacs-avoidance-modes?
15:36:00 <dino-> I guess it would be neat to be able to use Haskell for Vim scripting. But truth is, I do almost none of that anyway beyond what's in my trusty (and quite old) .vimrc
15:36:02 <roconnor> Hmm, I want to write some fancy client side interactive HTML stuff, but I'm loath to look at javascript.
15:37:16 <ddarius> dino-: That's the difference between vim users and emacs users.
15:38:46 <acowley> I used Textmate for a while some time ago, and it is quite nice
15:38:57 <roconnor>             switch (e.keyCode) {
15:38:58 <roconnor>               case 37: // left arrow
15:39:02 <roconnor> what the hell?
15:39:07 <roconnor> who makes up these keycodes?
15:39:20 <roconnor> It's like I'm programming in 1985
15:39:20 <acowley> roconnor: It's either ddarius or dankna
15:39:36 <ddarius> roconnor: What your keyboard actually produces is far worse than any arbitrary system.
15:39:40 <dino-> I know we'll probably never agree on this, but for me, anything that makes me use the mouse in the editor is FAIL.
15:39:52 <dino-> I don't use gvim, may not even have it installed.
15:40:12 * ddarius only uses gvim at work and then has all the menus and such turned off.
15:40:12 <dino-> If so, only so it can be kicked open by firefox to edit feral edit controls.
15:40:13 <acowley> dino-: I agree on "makes", but being able to use the mouse and menus for discoverability is nice
15:40:33 <Bynbo7> acowley: I'm a big fan of textmate
15:40:34 <kulakowski> Thinking of editors, what sort of state is yi in?
15:40:50 <Bynbo7> i was stuck using vim for the last two and a half months, i wasn't impressed
15:41:00 <dino-> ddarius: ya, set guioptions-=T
15:41:38 <acowley> Bynbo7: The GHCi Inf-Haskell mode in emacs is one of the things that swayed me from Textmate
15:41:42 <dino-> acowley: I understand that, yeah. Vim does have imprssive :help docs.
15:41:45 <dino-> built in
15:41:46 <Eduard_Munteanu> Hrm, now I know where Vimperator got its 'guioptions'
15:42:07 <Bynbo7> i have no problem tabbing to my terminal to run ghci
15:42:14 <companion_cube> vimperator is so cool
15:42:25 <acowley> dino-: I actually really don't like emacs' configuration system
15:42:46 <acowley> dino-: I just hold my breath when using it
15:43:00 <dino-> acowley: I don't know much about it. My wife scared me away from it many years ago with horror-stories about the "emacs clutch" of reaching for that idiotically-placed ctrl key.
15:43:14 <acowley> dino-: which encourages those forays to be quick, and, if they last too long, the memories stand a chance of being erased due to hypoxia!
15:43:19 <dankna> kulakowski, I was actually a vi (Elvis) user for like five years before Emacs.  I've used pretty much everything that runs on a Mac.
15:43:20 <dino-> Which is a different problem actually (map left ctrl to capslock people!)
15:43:26 <kulakowski> acowley: I use it occasionally to discover options, and then manually write things in my .emacs
15:44:19 <acowley> Bynbo7: I agree it's not a high degree of integration, but I think it is somewhat better to tabbing
15:46:35 <kulakowski> dankna: I used vim for a bit. Around when I was curious about vimperator. I'm fairly new to the mac world, and haven't done any editing too far removed from unix land. Curious about textmate, though.
15:46:58 <kulakowski> acowley: That is part of the abstract attraction of emacs, for me. All text I interact with in the same place.
15:47:18 <TomMD> @tell dcoutts will there be a new cabal-install using the latest Cabal soon (usable by ghc 7+)?
15:47:18 <lambdabot> Consider it noted.
15:47:18 <dino-> So TextMate is emacs-like?
15:47:33 <acowley> kulakowski: I agree!
15:48:10 <acowley> dino-: It is reasonably attractive and is reasonably extensible.
15:48:19 <acowley> dino-: But it isn't superficially anything like emacs
15:48:29 <Bynbo7> i would not call textmate emacs like
15:48:35 <ddarius> emacs isn't attractive
15:49:01 <ddarius> (vim isn't attractive either)
15:49:55 <acowley> I suppose I worded that poorly. I meant to say that TM is not at all like emacs superficially, but its attempts at extensability under the hood perhaps derive some inspiration from emacs.
15:51:52 <kulakowski> dino-: Textmate isn't built around a programming language, but it does offer quite a bit of programmability. I think it would move closer to emacsness if MacRuby advanced more.
15:53:19 <ddarius> If it advanced toward Maclisp.
15:55:49 <kulakowski> ddarius: hah
16:02:12 <dino-> I was just curious, not saying that non-emacs-ness is negative at all. I was remembering that Epsilon from way back, a Windows clone of emacs, and wondering if that was happening again.
16:02:49 <acowley> I have no trouble capitalizing "AdditiveGroup" or "VectorSpace," but I always write "Innerspace" and have just realized that this is due to Martin Short.
16:07:27 <kulakowski> dino-: It's definitely not that. Textmate's much more of an effort to make an editor that takes after BBEdit, with the customisations more of a secondary consideration.
16:11:33 <dino-> Well, I can enthusiastically recommend any and all Mac people try Vim. :)  :help vimtutor
16:12:18 <Bynbo7> I've used vim quite a lot, i am not a fan.
16:12:27 <Bynbo7> i like it more than emacs, but that's about it
16:13:55 <kulakowski> Bynbo7: You use textmate, no?
16:13:59 <Bynbo7> yes
16:14:48 <kulakowski> Mind me asking what languages you use it for, and any issues and more positive comments? I'm considering trying it out, once I have the money.
16:15:03 <acowley> What I've always loved about both vim and emacs is that if you have no idea what you're doing, and you start one in a terminal, you can wind up totally stuck without know how to exit.
16:15:47 <acowley> kulakowski: One neat thing it can do is nest different syntax highlighted languages within each other (e.g. HTML, CSS, JavaScript)
16:15:48 <luite> I usually get stuck by entering emacs commands in vim
16:16:11 <Bynbo7> i use it for haskell and C mainly these days. the haskell support isn't as good as some other editors, but I've always thought haskell doesn't need much editor support. ity's also really great for things like Objective-C, Ruby and HTML/PHP/CSS etc.
16:16:49 <acowley> I'm pretty sure on one of the first unix systems I had access to I had to open a second connection to the machine to kill either emacs or vim because I couldn't figure out how to quit
16:17:11 <Bynbo7> if it doesn't currently do something you want it to, it's extremely easy to make it do it with a script written in whatever language you prefer (it uses the #! for scripts)
16:17:20 <ray> i'd pay money for a good editor if i knew of one
16:17:38 <ray> programmers just say "lol, use emacs" or "lol, use vim" and won't hear of anything different
16:17:55 <ray> and i'm not interested in researching it myself ;)
16:18:05 <acowley> ray: Because emacs is awesome!
16:18:14 <ray> that's supposed to be a :), there's nothing to wink about here
16:18:23 <ray> it's tragic all around
16:18:48 <ray> the smile is meant to be a smug one indicating that i am not interested in hearing about how great vimacs really is
16:18:50 <xplat> lol, use emacs in vim-emulation mode
16:18:52 <acowley> Use agda2-mode and imagine doing that in another editor
16:18:55 <ray> that one little typo ruined it
16:19:06 <acowley> ray: You've opened the gates
16:19:09 <acowley> ray: Own it
16:19:12 <acowley> ;)
16:19:16 <ray> they were open already
16:19:23 <ray> anyway i'm just saying
16:19:25 <acowley> they don't actually close
16:19:26 <ray> to haskellers in general
16:19:31 <ray> MONEY
16:19:34 <ray> REAL MONEY
16:19:47 <ray> is in it if you can write me a good editor
16:20:00 <acowley> ray: Have you somehow missed the bazillion threads asking for a GUI binding?
16:20:07 <xplat> yeah, but like a hellmouth, they can be just barely open or WIDE OPEN OMG THEY EAT BABIES OH THE HUMANITY
16:20:20 <acowley> They all go "I use gtk2hs!" "I can't install gtk2hs!" "Is wxHaskell alive?"
16:20:28 <ray> i don't read threads
16:20:41 <acowley> ray: It's a pretty sorry state of affairs
16:20:57 <Eduard_Munteanu> What's wrong with Gtk2Hs?
16:21:08 <dankna> I would not be a fan of any editor written in gtk or wxWindows anyway
16:21:09 <Eduard_Munteanu> I think it's better whan the wx thingy
16:21:09 <acowley> The second quote from my meta-thread
16:21:10 <xplat> it's hard to even think about binding haskell to a gui toolkit
16:21:18 <xplat> they are all so ... so ... so-so
16:21:46 <dankna> I want an editor written against the raw platform GUI API, whatever that may be
16:21:48 <acowley> xplat: I think Racket does a pretty good job with its GUI bindings
16:21:54 <Eduard_Munteanu> To my surprise Gtk can feel functional
16:22:00 <ray> fortunately i use windows which doesn't have this proliferation of bullshit, unfortunately, i am the only haskeller who uses windows and i am not at all interested in writing bindings
16:22:14 <ray> the only one. you can quote me
16:22:14 <Eduard_Munteanu> dankna: X11? Are you masochistic?
16:22:27 <Eduard_Munteanu> Not that WinAPI/GDI is any better
16:22:30 <acowley> I'd be fine doing the actual GUI code in something not-quite-Haskell as long as it is easy to switch back and forth
16:22:51 <xplat> windows has just as much a proliferation of bullshit
16:22:55 <acowley> which is kind of how it works in Racket: The object system is used for the GUI, but you can ignore it, if you'd like, outside of GUI code
16:23:15 <ray> xmonad seemed to be easy enough, but i think it is easier to manage x11 windows than to be one
16:23:24 <dankna> Eduard_Munteanu, well, yes.  I kind of hate gtk and qt :(  fortunately I am a Mac user so I don't have to deal with either.
16:23:24 <xplat> winapi, mfc, afc, winforms, avalon, silverlight
16:23:44 <acowley> dankna: Yes, we can use our rich Cocoa bindings!
16:23:50 <dankna> yes!  ... oh wait.
16:23:56 <xplat> and that's not even getting into directx and such
16:24:24 <dankna> I have an unfinished project to replace hoc, actually.  I hop projects too much and never finish any :(
16:24:25 <Eduard_Munteanu> wxWidgets does seem to be better at looking native, but its internals... ah, it's quirky
16:24:50 <aristid> dankna: Gtk+ IS the raw platform GUI, under Linux.
16:25:08 <dankna> ironically, the only cross-platform library I've seen that does a decent job of not just looking but behaving like native widgets is... tk.  the irony is that it's wedded to tcl, which is such an awful little language.
16:25:18 <xplat> on windows, in fact, you have the choice of 10 gui toolkits, but they all have the same bugs because they are all just wrappers for code written in 1987
16:25:21 <Eduard_Munteanu> Also, wxWidgets is nice for portability, not just GUI, it felt really easy to cross-compile. But since I switched to Haskell & Gtk2Hs, I don't really want to look back. 
16:25:26 <dankna> aristid, depends on which distro you ask
16:25:48 <acowley> I used wxWidgets for one project and it worked quite well.
16:25:52 <aristid> dankna: no. it depends on which desktop environment you use, which is not really dependant on the distro.
16:25:55 <acowley> (in Haskell)
16:25:59 <dankna> well, okay, that's fair
16:26:15 <Eduard_Munteanu> The Linux barebones stuff like X11, Xaw etc. look really really really... fix really $ ugly.
16:26:55 <Eduard_Munteanu> Even Win31 stuff looks better at times.
16:27:29 <aristid> dankna: i think under windows, Qt can be considered native, too.
16:27:33 <acowley> Has anyone here tried using F# with Mono for GUI things?
16:27:42 <acowley> I've been meaning to try MonoMac with F#
16:27:43 <dankna> I actually wrote part of a GUI in Haskell... that was a slow boring month
16:27:44 <dankna> http://dankna.com/himitsu/what-do-we-think-of-these-fonts.png
16:27:49 <xplat> Xaw isn't any more 'barebones' than Gtk, it's just older and crappier
16:27:55 <ray> we're all boycotting .net because there's no h#
16:28:00 <dankna> this is an old screenshot, from before I implemented popup menus
16:28:08 <aristid> dankna: wtf? that's ugly
16:28:14 <Eduard_Munteanu> Hm, yeah, xplat is right.
16:28:14 <dankna> yes, I never claimed to be a graphic designer
16:28:28 <dankna> I subsequently took out the background image, which helped
16:28:35 <dankna> bear in mind that it was for a game
16:28:45 <dankna> so some in-your-face-ness was by design
16:28:51 <Eduard_Munteanu> Ah, that's fine then.
16:28:54 <ray> comic sans visual basic etc
16:28:59 <Eduard_Munteanu> Heh.
16:29:14 <aristid> dankna: but this is too much in-your-face-ness :P
16:29:34 <dankna> aristid: ultimately, I agree and would tone it down if I revisited the project
16:29:39 <dankna> this was all on top of OpenGL, btw
16:29:48 <Eduard_Munteanu> But really, seeing stuff like Motif, Xaw etc. on modern software is killing me.
16:29:48 <aristid> ah, cool
16:30:02 <aristid> Eduard_Munteanu: fortunately it is never on modern software
16:30:19 <Eduard_Munteanu> Well, I mean software that's still maintained.
16:30:28 <Eduard_Munteanu> And mainstream stuff.
16:30:59 <xplat> is even fsfmacs still on that stuff?
16:31:05 <acowley> dankna: Building your own GUI in OpenGL is like a siren call
16:31:21 <dankna> acowley, I agree.  it was kind of a slow month for me :)
16:31:35 <dankna> it's not really a design I would endorse
16:31:54 <Eduard_Munteanu> There are OpenGL-based game GUI builders.
16:31:57 <dankna> it was a thought though that I might do that to figure out what a "pure Haskell" widget library would look like, and then focus on wrapping platform libraries in that interface
16:32:28 <Eduard_Munteanu> Erm, FRP stuff like Grapefruit?
16:32:42 <xplat> yeah, FRP or something like it, definitely
16:32:44 <dankna> well, I never really saw FRP as a "big idea", I have to say
16:32:56 <dankna> it seems to just be saying... you get these events... and you act on them =p
16:33:06 <xplat> no no no, not at all
16:33:12 <dankna> feel free to explain it to me!
16:33:20 <Eduard_Munteanu> Nah, it's more like defining a GUI equationally.
16:33:33 <dankna> see, if I could see how it was declarative, that would be awesome
16:33:41 <xplat> FRP is all about nailing your GUI state to your data model so you can't get wedged
16:33:53 <dankna> hm.
16:34:14 <Eduard_Munteanu> GTK has that nice thing called model-store thingy.
16:34:17 <Eduard_Munteanu> I don't remember.
16:34:50 <Eduard_Munteanu> You basically make controls (e.g. a list) backed by a store, and you can update that store instead. Looks pretty functional when combined with Haskell.
16:35:06 <dankna> sounds a lot like Cocoa bindings, honestly, which I've tried and not liked
16:35:10 <Bynbo7> Cocoa has a very nice thing like that called Core Data
16:35:23 <xplat> you express the feedback between input, model, and widget appearance with, well, functions
16:35:28 <dankna> Core Data goes to another extreme - Core Data is a full object database (on top of a relational database, but it's not an ORM)
16:35:29 <acowley> Silverlight and WPF have it, too, I believe
16:35:44 <dankna> I'm not aware of anything like Core Data from anyone else
16:35:58 <dankna> I'm also not debating its merits right now :)
16:36:11 <dankna> I just wanted to point out that it's not the same thing as Cocoa bindings, although it can be used with them
16:36:50 <dankna> anyway, it's all well and good to say you express feedback like that and it's very pretty, but how does it play out when you need to make a new widget type?
16:37:18 <xplat> that's actually where it shines
16:37:20 <dankna> or when your data type is viewed as multiple widgets - think of a file path that's got a text box to edit it and also a button to pop up a browser window?
16:37:27 <Eduard_Munteanu> Wow, it was so much pain to make a new widget in wxWidgets + C++, not that I remember.
16:37:41 <dankna> do tell, xplat
16:37:41 <Eduard_Munteanu> *now that
16:38:02 <Eduard_Munteanu> BTW, what's *the* FRP GUI toolkit these days?
16:38:13 <xplat> FRP is composable in a similar way to STM, you can build little primitives like ‘isHovering pointer rect’
16:38:21 <dankna> mm
16:38:26 <jmcarthur> dankna: the idea is that you describe the observable state of your program as a function of continuous inputs, and the state will change incrementally as its inputs change incrementally. it sounds like Cocoa bindings until you consider that this program state is *not* in IO. it can perform no side effects. it's kind of like Cocoa bindings "done right", you could say.
16:38:31 <Eduard_Munteanu> And is it anywhere nearly usable?
16:38:45 <jmcarthur> dankna: and taken to further extremes, as well
16:38:57 <dankna> jmcarthur: hmmmmm.  all right.  I'll accept that answer, although I'd have to try it myself.
16:39:32 <xplat> and combine them to build a nice widget, instead of the current way of doing data binding which is to have a big ball of imperative gunk and wrap it with some callbacks that hopefully trigger at the right time
16:39:32 <acowley> done right... soon?
16:39:43 <duckinator> hi
16:40:02 <dankna> the isHovering example strikes me as odd:  the window manager needs to know about hover rectangles for efficiency's sake, they are an explicitly-managed resource that you do not control
16:40:03 <jmcarthur> acowley: "done right" in the sense that it's a clean-slate approach, not in the sense that we have a great implementation already :\
16:40:16 <Eduard_Munteanu> Well, if you're going to sell this, you might as well point at something we can start with ^^ :P
16:40:21 <xplat> currently grapefruit seems to be the recommended FRP for haskell
16:40:26 <Eduard_Munteanu> Ah.
16:40:27 <jmcarthur> really?
16:40:45 <xplat> reactive will likely take over from that if/when it's finished
16:40:48 <acowley> jmcarthur: I know, I was being cheeky. It's just so frustrating at the moment that our community decries the status quo so vehementally yet can't offer a substitute. 
16:40:58 <jmcarthur> first i've heard of grapefruit being the most recommended
16:41:16 <aristid> wasn't yampa relatively popular?
16:41:22 <jmcarthur> acowley: admitting you have a problem is only the first step
16:41:32 <acowley> jmcarthur: A step we love!
16:41:32 <xplat> jmcarthur: i've been going by actually counting recommendations in the channel
16:41:56 <jmcarthur> yampa is probably the most popular FRP library, and the currently most efficient. reactive has a nicer model (IMO), but has some major implementation issues
16:41:57 <Eduard_Munteanu> "There is a first official Grapefruit release which is release 0.0.0.0. "
16:42:01 <xplat> yampa is second, but grapefruit is winning
16:42:06 <jmcarthur> xplat: interesting
16:42:21 <jmcarthur> i didn't even think grapefruit was general enough for non-gui stuff
16:42:24 <Eduard_Munteanu> I thought Yampa was a general-purpose FRP lib, not GUI-focused.
16:42:46 <siracusa> Is (.:) lambdabot only?
16:43:13 <Eduard_Munteanu> @hoogle (.:)
16:43:13 <lambdabot> No results found
16:43:47 * hackagebot smartGroup 0.3.0 - group strings or bytestrings by words in common  http://hackage.haskell.org/package/smartGroup-0.3.0 (SamAnklesaria)
16:43:57 <xplat> dankna: actually as far as hover rectangles go, toolkits have been increasingly refusing to use subwindows inside the root window on both X11 and GDI
16:44:13 <aristid> siracusa: no. you can easily define it yourself. (.:) = fmap . fmap
16:44:26 <xplat> citing excessive overhead
16:44:29 * ddarius has never seen a not-fugly tk interface.
16:44:43 <siracusa> aristid: Ah, thanks.
16:44:43 <dankna> xplat: hm.  I see.
16:44:54 * ddarius makes GUI libraries that stress test the threading system.
16:45:13 <Eduard_Munteanu> > (+1) .: [1,2,3,4]
16:45:13 <lambdabot>   No instance for (GHC.Num.Num (g a))
16:45:13 <lambdabot>    arising from a use of `e_111234' at ...
16:45:27 <shachaf> ddarius: I think the Windows version of Tk at one point looked semi-reasonable/native.
16:45:30 <xplat> they're used a bit more on GDI for the sake of compatibility
16:46:12 <Eduard_Munteanu> > (+1) .: [[1,2],[3,4]]
16:46:14 <lambdabot>   [[2,3],[4,5]]
16:49:48 <xplat> (+1) .: (:3:4) $ 2
16:49:53 <xplat> > (+1) .: (:3:4) $ 2
16:49:53 <lambdabot>   No instance for (GHC.Num.Num [a])
16:49:54 <lambdabot>    arising from a use of `e_11342' at <in...
16:50:49 <xplat> :t (+1) .: (:3:4)
16:50:50 <lambdabot> forall a. (Num a, Num [a]) => a -> [a]
16:52:01 <xplat> > show .: (:3:4) $ 2
16:52:01 <lambdabot>   No instance for (GHC.Num.Num [a])
16:52:01 <lambdabot>    arising from the literal `4' at <inter...
16:52:08 <winxordie> ddarius: you have any examples of these thread-destroying GUIs?
16:52:20 <xplat> ... oh.
16:52:33 <xplat> > (+1) .: (:[3,4]) $ 2
16:52:35 <lambdabot>   [3,4,5]
16:52:44 <Eduard_Munteanu> It's like (map . map) on lists
16:52:53 <Eduard_Munteanu> (of lists)
16:53:09 <tswett> > (map . map) (+1) [[1,2],[3,4]]
16:53:11 <lambdabot>   [[2,3],[4,5]]
16:53:17 * tswett nods solemnly.
16:53:44 <Eduard_Munteanu> Ah-huh.
16:54:17 <Twey> > ((.) (.) (.)) succ [[1, 2], [3, 4]]
16:54:19 <lambdabot>   [[2,3],[4,5]]
16:54:26 <Eduard_Munteanu> Hah.
16:54:26 <xplat> let (*-) = subtract 1 .: (*) in 3 *- 4
16:54:35 <xplat> > let (*-) = subtract 1 .: (*) in 3 *- 4
16:54:37 <lambdabot>   11
16:54:39 <acowley> GHCi is always a pain when developing FFI code
16:54:41 <Eduard_Munteanu> @pl fmap
16:54:42 <lambdabot> fmap
16:55:02 <Eduard_Munteanu> @pl map
16:55:02 <lambdabot> map
16:55:05 <Eduard_Munteanu> Meh.
16:55:07 <tswett> @unpl map
16:55:07 <lambdabot> map
16:55:09 <tswett> Meh.
16:55:18 <Eduard_Munteanu> @unpl ((.) (.))
16:55:18 <lambdabot> (\ b c e f -> b c (e f))
16:55:47 <xplat> @unpl ((.) (.) (.) (.) (.) (.) (.))
16:55:47 <lambdabot> (\ k l q r u -> k l (q r u))
16:55:47 <Eduard_Munteanu> @unpl ((.) (.) (.))
16:55:48 <lambdabot> (\ c e f i -> c (e f i))
16:56:27 <xplat> @unpl ((.) (.) (.) (.) $ (.) (.) (.))
16:56:27 <lambdabot> (\ f i k l u -> f (i (k l) u))
16:56:40 <monochrom> fik lu
16:56:58 <Eduard_Munteanu> Pointfree, but priceless
16:57:56 <Eduard_Munteanu> Haskell people should run a IOCCC spinoff.
16:59:30 <xplat> @unpl (\buffalo -> buffalo buffalo buffalo buffalo buffalo buffalo buffalo) (.)
16:59:30 <lambdabot> (\ buffalo -> buffalo buffalo buffalo buffalo buffalo buffalo buffalo) (\ a b c -> a (b c))
17:01:46 <xplat> @compose @unpl @pl (\buffalo -> buffalo buffalo buffalo buffalo buffalo buffalo buffalo) (.)
17:01:46 <lambdabot> Plugin `compose' failed with: Unknown command: "@unpl"
17:02:16 <xplat> @compose unpl pl (\buffalo -> buffalo buffalo buffalo buffalo buffalo buffalo buffalo) (.)
17:02:16 <lambdabot> (\ g m b c f -> g m (b c f))
17:02:48 <xplat> @compose unpl pl (\buffalo -> buffalo buffalo buffalo buffalo buffalo buffalo buffalo) flip
17:02:48 <lambdabot> (\ c f -> c f (\ g h i -> g i h))
17:02:52 * hackagebot hashable 1.1.0.0 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.1.0.0 (JohanTibell)
17:03:19 <Eduard_Munteanu> @compose vixen unpl pl (\buffalo -> buffalo buffalo buffalo buffalo buffalo buffalo buffalo) (.)
17:03:19 <lambdabot> in to
17:03:27 * ddarius has a "filter" function of which map is a special case.
17:03:49 <Eduard_Munteanu> @compose vixen unpl vixen pl (\buffalo -> buffalo buffalo buffalo buffalo buffalo buffalo buffalo) (.)
17:03:49 <lambdabot> we all have a little vixen in us
17:04:00 <Eduard_Munteanu> Interesting.
17:04:46 <Eduard_Munteanu> ddarius: something where the filtering function is Maybe-based?
17:04:47 <xplat> doesn't compose only work on two commands?
17:05:00 <xplat> if you want more, you need another compose
17:05:14 <ddarius> Eduard_Munteanu: Yep.
17:05:36 <ddarius> Roughly, filter :: (a -> Maybe b) -> [a] -> [b]  only not for lists.
17:05:50 <xplat> (as the second command--putting it first won't work, or at least it probably won't do what you want)
17:05:52 * hackagebot unordered-containers 0.1.0.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.1.0.0 (JohanTibell)
17:05:59 <ClaudiusMaximus> @hoogle mapMaybe
17:05:59 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
17:05:59 <lambdabot> Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
17:05:59 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
17:06:28 <Eduard_Munteanu> I suppose something like filter :: (Monoid m) => (a -> Maybe b) -> m a -> m b
17:06:52 <xplat> if it's a monoid you don't need the maybe
17:06:57 <Eduard_Munteanu> Oh, "only not", not "not only"
17:07:05 <xplat> just return mzero for anything you want to zorch
17:07:31 <xplat> oh, sorry, monoid m, not monoid b
17:07:37 <xplat> but then you need monoid m b
17:08:06 <Eduard_Munteanu> That works too... (Monoid m) => (a -> m b) -> m a -> m b    -- I think
17:08:28 <ddarius> Eduard_Munteanu: That's a kind error.
17:08:29 <xplat> monoid takes a type, not a constructor, no?
17:08:51 <Jesin> [20:33:14]	<lambdabot>	Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
17:09:20 <Jesin> mapMaybe f = concatMap (maybeToList . f)
17:09:30 <Eduard_Munteanu> Hm? Isn't it m = [], a = Int for [Int] ?
17:09:46 <ClaudiusMaximus> @instances Monoid
17:09:46 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
17:09:53 <xplat> :t mappend
17:09:53 <lambdabot> forall a. (Monoid a) => a -> a -> a
17:10:02 <Eduard_Munteanu> Oh, I see now.
17:10:15 <Jesin> @src Maybe mappend
17:10:15 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:11:00 <Eduard_Munteanu> Hrm, could we have my kind of Monoid? :)
17:11:06 <xplat> i can't wait until mappend is replaced with (<>)
17:12:07 <tibbe> yay, just made a pre-release of the new unordered-containers package!
17:12:18 <xplat> probably mzero --> ε would be too much, though
17:13:02 <Jesin> [20:38:21]	<xplat>	i can't wait until mappend is replaced with (<>)
17:13:11 <Jesin> yes please, and
17:13:13 <Eduard_Munteanu> :t (<>)
17:13:14 <lambdabot> Doc -> Doc -> Doc
17:13:20 <Jesin> it needs to be in class Semigroup
17:13:20 <Eduard_Munteanu> WTH?
17:13:44 <Jesin> so we don't have that ugly instance Monoid a => Monoid (Maybe a)
17:13:55 <Jesin> which ignores the underlying mempty
17:14:25 <xplat> (and some people would say it should be ι or something too)
17:15:02 <Eduard_Munteanu> I can barely see that, what is it, iota? delta?
17:15:15 <monochrom> iota
17:15:17 <xplat> iota
17:17:03 <ddarius> ιn. n·n = 9
17:17:24 <Eduard_Munteanu> So is (Monoid m), m :: * -> *  practical?
17:17:36 <ddarius> It's called a monad.
17:17:54 <Eduard_Munteanu> Well, I know you could make it a monad there, but it's too much
17:17:56 <xplat> ddarius: that's even longer than S$S$S$Z
17:18:55 <xplat> Eduard_Munteanu: what would mzero return?  what would mappend take?  m has no inhabitants, not even bottom ...
17:19:14 <xplat> (assuming m :: * -> *)
17:19:49 <xplat> what you're thinking of is more forall a. Monoid (m a)
17:20:05 <xplat> which is completely doable
17:20:11 <ddarius> xplat: It's not that it doesn't have inhabitants, it's that it doesn't even make sense to ask.
17:20:44 <Eduard_Munteanu> instance Monoid [] where mzero = []; mappend = (:)
17:20:47 <djahandarie> This thing I'm writing is getting too long, how do I shorten it? :(
17:20:54 <xplat> ddarius: yeah
17:21:08 <xplat> there's a difference between types and values here
17:21:13 <ddarius> djahandarie: Just throw out the last pages.
17:21:25 <monochrom> use shorter variables
17:21:32 <xplat> an incompletely applied function on values is a value in itself, but an incompletely applied function on types is NOT a type
17:21:33 <luite> djahandarie: try removing the vowels
17:21:41 <djahandarie> ddarius, it least it wasn't "stop writing" this time ;P
17:22:01 <DevHC> foreign export ccall "hs_test_import_dynamic" testImportDynamic :: FunPtr (CInt -> IO ()) -> IO ()
17:22:01 <DevHC> void passed_one(int x) { ... }
17:22:01 <DevHC> int main(void) { ... ; hs_test_import_dynamic(&passed_one); ... }
17:22:01 <DevHC> warning: passing argument 1 of 'hs_test_import_dynamic' from incompatible pointer type
17:22:04 <ddarius> djahandarie: You have been quieter of late.  Or maybe I've just been passed out when you were talking.
17:22:26 <Eduard_Munteanu> xplat: for 'm a', mzero returns an empty "list" of type 'm a', that seems inhabited.
17:22:26 <DevHC> ^ any ideas why this warning is given and how to remove it in the "good way"?
17:22:27 <xplat> Eduard_Munteanu: instance Monoid [a] where { mzero = []; mappend = (++) }
17:22:48 <djahandarie> I've been busy. And also offloading some of the useless stuff onto twitter
17:22:50 <Eduard_Munteanu> Ah, right.
17:22:58 <ddarius> djahandarie: I was going to say "stop writing," but that won't make what you're writing shorter.
17:23:33 <djahandarie> Well it would, because it would never be finished/released that way :P
17:23:39 <xplat> djahandarie: refactor it
17:24:07 <DevHC> on a side note, passing a pointer of type void(*)(void) removes the warning
17:24:39 <djahandarie> xplat, I've tried. I think I might need to just target it at a more knowledgeable audience so I can skip more stuff
17:25:51 <c0dz3r0> hi all. does anybody have a refence to structural operational semantics for the state monad, or preferably the state monad transformer?
17:25:58 <Eduard_Munteanu> xplat: but surely there's way to factor out the 'a' there and make it similar to a monad, no?
17:26:21 <Eduard_Munteanu> Because   instance Monad []   surely does it.
17:26:37 <xplat> Eduard_Munteanu: you'd have to change the type signatures, so it couldn't be the same class
17:26:47 <BMeph> djahandarie: But... if you don't make it shorter, then you're not making it shorter! :S
17:26:48 <Eduard_Munteanu> Yes.
17:27:38 <xplat> class (forall a. Monoid (m a)) => Monoids a, if you could do that :)
17:27:48 <DevHC> who here edits FFI docs?
17:28:01 <xplat> er, Monoids m
17:28:03 <Eduard_Munteanu> xplat: hrm, I don't like it.
17:28:06 <Eduard_Munteanu> Ah.
17:28:25 <Eduard_Munteanu> Yeah, basically, for list-like stuff say, only the container should matter.
17:29:44 <Eduard_Munteanu> OTOH for a mathy monoid you'd have something like instance (Num a) => Monoids a
17:30:09 <Eduard_Munteanu> That should be right, no?
17:30:09 <acowley`> I don't understand what you mean. Doesn't the parametricity of 'a' exhibit the fact that 'a' doesn't matter?
17:30:52 <xplat> class Monoids m where { mszero :: m a ; msappend :: m a -> m a -> m a }
17:31:03 <Eduard_Munteanu> Yep.
17:31:43 <Eduard_Munteanu> For lists, mszero = []; mappend = (++)
17:32:02 <Eduard_Munteanu> acowley`: not if 'a' is restricted to Num
17:34:55 <xplat> there's little use in having a 'monoids'class though since none of the methods use m at multiple types
17:35:25 <Eduard_Munteanu> Ah, I thought it was more intuitive :/
17:36:17 <Eduard_Munteanu> > 3 `mappend` 4
17:36:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:36:18 <lambdabot>    `Data.Monoid.Monoid a'
17:36:19 <lambdabot>  ...
17:36:37 <Eduard_Munteanu> > 3 `mappend` (4 :: Int)
17:36:37 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
17:36:38 <lambdabot>    arising from a use of...
17:36:53 <Eduard_Munteanu> Hrm.
17:36:59 <Eduard_Munteanu> @instances Monoid
17:37:00 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
17:37:13 <Eduard_Munteanu> Ah.
17:38:42 <Eduard_Munteanu> Actually it doesn't make much sense for numbers if you go that way.
17:40:24 <Jesin> any valid instance of Num
17:40:33 <Jesin> is automatically a monoid under (+) and (*)
17:40:37 <Jesin> in the mathematical sense
17:41:16 <Eduard_Munteanu> Well, yeah, but currently we don't have monoids parametrised over the operation too.
17:41:27 <Jesin> hm?
17:41:33 <acowley> We have instances for each
17:41:48 <Jesin> newtype Sum a = {getSum :: a}
17:42:09 <Jesin> instance Num a => Monoid (Sum a) where
17:42:13 <Jesin>   mzero = 0
17:42:18 <Eduard_Munteanu> Hrm, are Product and Sum Caleskell?
17:42:19 <Jesin>   mappend = (+)
17:42:22 <Jesin> no
17:42:22 <ClaudiusMaximus> > (mconcat (map Sum [1,2,3]), mconcat (map Product [1,2,3]))
17:42:23 <lambdabot>   (Sum {getSum = 6},Product {getProduct = 6})
17:42:27 <Jesin> they're in Data.Monoid
17:42:32 <Jesin> http://haskell.org/ghc/docs/latest/html/libraries/
17:43:02 <Jesin> > (mconcat (map Sum [1..5]), mconcat (map Product [1..5]))
17:43:03 <lambdabot>   (Sum {getSum = 15},Product {getProduct = 120})
17:43:39 <djahandarie> I love monoid newtypes with foldmap (especially when you can kill the newtype overhead ;))
17:44:09 <Jesin> I like GeneralizedNewtypeDeriving  :p
17:44:14 <Eduard_Munteanu> Ah, I've been looking at it the wrong/unusual way, thinking a Monoid would take a tuple (set/type, operation)
17:44:48 <Eduard_Munteanu> Jesin: the datatype deriving GHC extensions are neat too
17:44:57 <Jesin> [21:11:30]	<Eduard_Munteanu>	Ah, I've been looking at it the wrong/unusual way, thinking a Monoid would take a tuple (set/type, operation)
17:45:08 <Jesin> that is basically what a typeclass does
17:45:42 <Eduard_Munteanu> Well it does, not in the mathy way though
17:45:53 <Jesin> (set/type, someoperation, identityelement, other operations/values, etc)
17:46:07 <Jesin> umm
17:46:11 <acowley> Eduard_Munteanu: It's just syntax
17:46:14 <Jesin> it's pretty much isomorphic to the mathy way
17:46:15 <Jesin> :p
17:46:20 <Eduard_Munteanu> Yeah, that's true.
17:46:30 <Jesin> nobody ever uses the fact that it's a tuple, in math
17:46:51 * djahandarie thinks the word ismorphism is really overused in this channel
17:46:54 <acowley> You don't unpack your monoid constraints with fst and snd when writing proofs?
17:46:58 <Jesin> except in automated theorem provers, and in writing down "suppose we have a group (S,+,0)" or whatever
17:47:06 <Jesin> [21:14:07]	* djahandarie	thinks the word ismorphism is really overused in this channel
17:47:07 <Jesin> yeah probably
17:47:11 <Jesin> what should we use instead
17:47:17 <Eduard_Munteanu> No not that, I was alluding to something like a monoid is * -> <something for operation> -> *
17:47:28 <olsner> djahandarie: this channel is isomorphic to a sequence of isomorphisms
17:47:31 <lispy_> Jesin: bijection that appears to preserve structure :)
17:47:53 <Jesin> ^that
17:47:55 <djahandarie> Jesin, anything that doesn't carry a technical meaning.
17:48:05 <acowley> Eduard_Munteanu: That would be more like the sometimes-sought-after local instance declarations!
17:48:08 <Jesin> what's the technical meaning of isomorphism
17:48:21 <Jesin> besides what lispy_ just said
17:48:27 <lispy_> Jesin: bijective homomorphism
17:48:51 <lispy_> Jesin: I think the definition of isomorphism depends on the area of math
17:48:53 <Eduard_Munteanu> Well 'homo' isn't warranted though.
17:48:58 <acowley> You're all overlooking that djahandarie commented on the use of "ismorphism" which is lolmath terminology for a function
17:49:08 <Eduard_Munteanu> As you can refer to functions as isos.
17:49:14 <Eduard_Munteanu> *some functions
17:49:40 <lispy_> Eduard_Munteanu: yeah, I guess I'm thinking of group isomorphisms
17:49:46 <lispy_> You can have other types of isomorphisms
17:49:54 <conal> i'm trying to get my user account restored on code.haskell.org. i always get confused about keys. my ~/.ssh has id_rsa.pub, id_dsa.pub, and identity.pub, each having a corresponding private key file. does it matter which one(s) i set up on code.haskell.org?
17:50:03 <Jesin> "In abstract algebra, an isomorphism (Greek: ἴσος isos "equal", and μορφή morphe "shape") is a bijective map f such that both f and its inverse f −1 are homomorphisms, i.e., structure-preserving mappings."
17:50:36 <Eduard_Munteanu> Yeah, there's a wide array of (iso)morphisms really.
17:50:38 <dankna> conal: do you use ssh-agent?
17:50:45 <lispy_> conal: there is a command to do this for you
17:50:52 <djahandarie> Eduard_Munteanu, and that isn't even the category-theory definition. :)
17:50:59 <dankna> wait, silly question.  of course you do, how else could you log in to code.haskell.org.
17:51:01 <lispy_> conal: but, you always want to keep your private keys to yourself.
17:51:11 <conal> dankna: hm. i don't think so. used to on windows maybe. this stuff doesn't stick in my head.
17:51:31 <Eduard_Munteanu> djahandarie: in CT they're epi + mono arrows.
17:51:43 <dankna> conal: I see you're on a Mac?  okay, so you do have one if you use it
17:51:51 <conal> the email about restoring code.haskell.org user accounts says to "Give your real name, your unix
17:51:51 <conal> user name and attach your current ssh public key."
17:51:53 <lispy_> conal: http://linux.die.net/man/1/ssh-copy-id
17:51:55 <Jesin> "category theory, an isomorphism is a morphism f: X → Y in a category for which there exists an "inverse" f −1: Y → X, with the property that both f −1f = idX and f f −1 = idY.
17:52:22 <Jesin> eh
17:52:24 <Eduard_Munteanu> Yeah, you could prove those two are actually equivalent.
17:52:27 <conal> what i'm wondering is *which one* of my already existing keys to send. or whether it matters.
17:52:27 <dankna> conal: the Mac conveniently spawns an ssh-agent process for you, and sets the appropriate SSH_* environment variables so you can find it
17:52:28 <Jesin> I haven't looked very far into category theory
17:52:35 <dankna> conal: try this:  ssh-add -l
17:52:47 <acowley> Using Goldblatt's (and others') CT naming is more fun: epic and monic arrows.
17:52:48 <dankna> that will give you a list of which key(s) are in the agent presently
17:52:59 <dankna> by their fingerprints, and comments if they have comments
17:53:00 <Eduard_Munteanu> Just like bijective <=> injective + surjective <=> invertible is provable.
17:53:06 <Jesin> the idea of an identity morphism that is unique to a particular structure, and is distinct from simply \x -> x
17:53:14 <Jesin> is not something I yet understand
17:53:16 <Jesin> :p
17:53:24 <conal> i think the keys all work fine on my end.
17:53:40 <dankna> well, what I'm trying to determine is whether some of them are unused
17:53:48 <Eduard_Munteanu> Jesin: not identity, it's onto itself.
17:53:51 <dankna> I'm sure they're valid keys as far as that goes
17:53:57 <conal> ah.
17:54:09 <dankna> if you have a script, say in .bashrc or somewhere, that is loading some of them into the agent for you
17:54:13 <djahandarie> Eduard_Munteanu, I think that actually only holds in a balanced category (re: monic + epic => invertible).
17:54:21 <dankna> then you would see results returned by ssh-add -l
17:54:26 <conal> 'ssh-add -l' yields "The agent has no identities."
17:54:30 <dankna> it's also possible, that.... yeah
17:54:42 <conal> and yet i'm able to ssh to my own server
17:54:44 <dankna> how did you access code.haskell.org when it worked?  what programs?
17:54:55 <dankna> well, ssh also looks for files with certain names, if ssh-agent has no identities
17:55:02 <Jesin> newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
17:55:04 <Jesin> instance Monad m => Category (Kleisli m) where
17:55:06 <Jesin>         id = Kleisli return
17:55:08 <Jesin>         (Kleisli f) . (Kleisli g) = Kleisli (\b -> g b >>= f)
17:55:09 <dankna> it's been so long since I've done it the non-agent way that I didn't even remember that fact
17:55:09 <Jesin> ah.
17:55:45 <djahandarie> Eduard_Munteanu, the category of rings being an example of an unbalanced category
17:55:53 <dankna> okay so according to man ssh, conal, ~/.ssh/iidentity is ignored nowadays
17:56:04 <Eduard_Munteanu> djahandarie: erm, I'm not sure about 'invertible' in CT, but I think Awodey defines an iso as epi + mono
17:56:15 <dankna> ~/.ssh/id_dsa and ~/.ssh/id_rsa are the ones that are used.  I think one of those is strictly better encryption but I forget which ><
17:56:35 <acowley> I've never encountered that restriction either djahandarie. How does the unbalanced issue play out?
17:56:41 <djahandarie> Eduard_Munteanu, by invertible I mean isomorphic
17:56:44 <conal> dankna: thanks.
17:56:47 <dankna> I see that my own key is a DSA key so I'm guessing id_dsa.pub is the one you should be sending, conal
17:57:00 <dankna> np
17:57:12 <conal> does anyone else know how dsa & rsa compare? (which is stronger?)
17:57:34 <dankna> (well, they are both families of algorithms parametrized on bit-strength)
17:57:58 <Eduard_Munteanu> IIRC, RSA was slightly slower and tougher, but I could be wrong.
17:58:21 <Eduard_Munteanu> I'd just pick a higher length if I was concerned.
17:58:51 <lispy_> conal: if you scroll down to what unspawn says: http://www.linuxquestions.org/questions/linux-security-4/which-is-better-rsa-or-dsa-public-key-12593/
17:58:54 <Eduard_Munteanu> >1024 should be ok I guess.
17:59:12 <conal> thanks, all.
17:59:19 <lispy_> conal: sounds likee, DSA is kind of better but not like the jump from rsa/dsa to elliptic curve
17:59:22 <dankna> funnily enough I was on that same site
17:59:35 <lispy_> dankna:google :)
17:59:36 <conal> cool.
17:59:39 <dankna> indeed :)
17:59:47 <lispy_> openssh now does ECC
17:59:53 <lispy_> But, it's only in the latest release
17:59:55 <dankna> nice
17:59:57 <dankna> good to know
18:00:46 <lispy_> In a few years, we'll all be using that  I hope
18:00:57 <Adamant> RSA or a sane ECC scheme
18:01:03 <Eduard_Munteanu> With QC coming, yes.
18:01:04 <Adamant> don't bother with DSA at this point
18:01:23 <Eduard_Munteanu> I hear there are a few schemes that aren't breakable by QC.
18:01:28 <Eduard_Munteanu> (that easily)
18:01:34 <Adamant> there's been work on that for a long while
18:01:59 <Adamant> there are decent-ish methods that aren't breakable by known methods
18:02:04 <Adamant> of QC optimization
18:02:25 <Adamant> there are no algorithms with verified properties in the face of QC
18:02:34 <Adamant> all QC
18:02:35 <Eduard_Munteanu> If you take QC into consideration maybe something like a 2048 RSA/DSA might be a better idea.
18:02:45 <djahandarie> acowley, I think it comes down to the fact that you can have a non-surjective bimorphism (epi + mono) 
18:03:05 <Eduard_Munteanu> The question is, how long you want your data to be secret.
18:03:13 <djahandarie> Like in Ring, you have the inclusion Z->Q which is a bimorphism but not an isomorphism
18:04:06 <acowley> djahandarie: Ah, thanks, that makes sense
18:04:07 <djahandarie> I think that would also make Mon unbalanced
18:04:09 <lispy_> This is possibly the nerdiest place on IRC.  In the US it's the friday of a 3 day weekend, and we're on here talking about math :)
18:04:14 <dankna> I think we're also forgetting that we're not actually protecting /data/ with these keys
18:04:18 <lispy_> (I see this as a good thing)
18:04:45 <dankna> we're protecting the ability to log in.  a captured session, even if the attacker broke the key, would not reveal much.  certainly no passwords if you've set things up properly.
18:04:48 <Adamant> lispy_: #math is also talking about math, but there's probably a good deal of whining, bitching, and elitism going on as well
18:04:49 <djahandarie> acowley, take what I say with a grain of salt, I'm not that good at these things :P
18:05:03 <Eduard_Munteanu> Heh.
18:05:07 <djahandarie> If I say enough wrong things I'm sure ddarius will interject and own me though
18:05:13 <dankna> but when we know that a certain key algorithm is broken, we switch to a new one
18:05:27 <Eduard_Munteanu> Yeah, where's ddarius to put our concerns at rest?
18:05:28 <dankna> now, some people do actually encrypt data with their keys
18:05:29 <lispy_> heh, yeah ddarius can't stand for anything wrong/incorrect to be said.  I wouldn't take it personally.
18:05:33 <dankna> or have used their keys to sign things
18:05:49 <dankna> but they're the minority (I /think/ I have, but I'm not totally sure which key the tool used for it!)
18:05:53 <djahandarie> (If he isn't passed out)
18:06:03 <djahandarie> lispy_, I like having him around :D
18:16:59 <dark> @src liftM
18:16:59 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:18:28 <dark> @type liftM
18:18:29 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:18:37 <dark> @type flip (>>=)
18:18:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
18:23:03 <dark> @pl do { x1 <- m1; return (f x1) }
18:23:03 <lambdabot> (line 1, column 4):
18:23:03 <lambdabot> unexpected "{"
18:23:03 <lambdabot> expecting variable, "(", operator or end of input
18:26:01 <Jesin> dark
18:26:04 <Jesin> I think you meant
18:26:18 <Jesin> @undo do { x1 <- m1; return (f x1) }
18:26:18 <lambdabot> m1 >>= \ x1 -> return (f x1)
18:26:26 <Jesin> @. pl undo do { x1 <- m1; return (f x1) }
18:26:26 <lambdabot> f `fmap` m1
18:27:04 <Jesin> basically, any Monad should also be a Functor, and have (fmap f m) equivalent to (m >>= return . f)
18:27:29 <Jesin> (liftM is equivalent to fmap)
18:27:30 <Jesin> also
18:27:59 <Jesin> m1 <*> m2 = m1 >>= (`fmap` m2) -- this is equivalent to (<*>) = ap where fmap == liftM
18:33:54 <Jesin> @src (<**>)
18:33:54 <lambdabot> (<**>) = liftA2 (flip ($))
18:33:59 <Jesin> @src liftA2
18:33:59 <lambdabot> liftA2 f a b = f <$> a <*> b
18:38:52 <dark> @type (<*>)
18:38:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:39:39 <dark> @undo do { x1 <- m1 }
18:39:39 <lambdabot>  Parse error at "}" (column 15)
18:39:52 <dark> @undo do { x1 <- m1; }
18:39:52 <lambdabot>  Parse error at "}" (column 16)
18:40:14 <dark> @undo do { a }
18:40:14 <lambdabot> a
18:40:16 <Maxdamantus> :t m1 >>= \x1 ->
18:40:16 <lambdabot> parse error (possibly incorrect indentation)
18:40:25 <dark> oh :)
18:43:02 <Jesin> @do m1 >>= (`fmap` m2)
18:43:03 <lambdabot> do { a <- m1; (`fmap` m2) a}
18:43:22 <Jesin> @do (>=>)
18:43:22 <lambdabot> (>=>)
18:43:31 <Jesin> @. do unpl (>=>)
18:43:31 <lambdabot> (>=>)
18:43:40 <Jesin> @. do src (>=>)
18:43:40 <lambdabot> ()
18:43:45 <Jesin> @src (>=>)
18:43:45 <lambdabot> Source not found. You type like i drive.
18:44:21 <Jesin> :t State
18:44:22 <lambdabot> Not in scope: data constructor `State'
18:44:25 <Jesin> :t state
18:44:26 <lambdabot> forall s a. (s -> (a, s)) -> State s a
18:55:32 <pedro3005> @src iterate
18:55:32 <lambdabot> iterate f x =  x : iterate f (f x)
18:55:58 <Jesin> @. pl src iterate
18:55:58 <lambdabot> (line 1, column 1):
18:55:58 <lambdabot> unexpected end of input
18:55:58 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:56:14 <Jesin> @pl let iterate f x = x : iterate f (f x) in iterate
18:56:14 <lambdabot> fix ((ap (:) .) . ((.) =<<))
18:56:18 <Jesin> lol
18:56:21 <azaq23> @type let f >=> g = \x -> f x >>= g in (>=>)
18:56:21 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
18:56:32 <Jesin> :t (>=>)
18:56:33 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
18:56:46 <ClaudiusMaximus> > iterate id 0 !! 100000
18:56:47 <lambdabot>   0
18:57:37 <Jesin> :t iterate
18:57:38 <lambdabot> forall a. (a -> a) -> a -> [a]
18:57:59 <Jesin> :t \iterate -> x : iterate f (f x)
18:58:00 <lambdabot> forall a t. (SimpleReflect.FromExpr a, SimpleReflect.FromExpr (Expr -> t)) => (a -> t -> [Expr]) -> [Expr]
18:58:06 <Jesin> :t \iterate f x -> x : iterate f (f x)
18:58:07 <lambdabot> forall a t. ((a -> t) -> t -> [a]) -> (a -> t) -> a -> [a]
18:58:17 <Jesin> :t fix \iterate f x -> x : iterate f (f x)
18:58:17 <lambdabot> parse error on input `\'
18:58:23 <Jesin> :t fix $ \iterate f x -> x : iterate f (f x)
18:58:24 <lambdabot> forall a. (a -> a) -> a -> [a]
18:58:40 <Jesin> :t fix $ \itr f x -> x : itr f (f x)
18:58:40 <lambdabot> forall a. (a -> a) -> a -> [a]
18:58:44 <ClaudiusMaximus> > head $ transpose (repeat (repeat 0)) !! 100000
18:58:45 <lambdabot>   0
18:58:59 <Jesin> lol, wow
18:59:12 <Jesin> lambdabot uses fusion rules, doesn't it
18:59:22 <Jesin> ...
18:59:29 <Jesin> is that with fold/build/augment?
18:59:40 <Jesin> or is there some other fusion stuff going on in there
18:59:56 <Jesin> @src transpose
18:59:56 <lambdabot> transpose []             = []
18:59:56 <lambdabot> transpose ([]   : xss)   = transpose xss
18:59:56 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
19:00:02 <Jesin> @hoogle transpose
19:00:02 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
19:00:02 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
19:00:02 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
19:00:08 <ClaudiusMaximus> i think it's lambdabot / mueval / ghc - whether there is optimization enabled or not i don't know
19:00:11 <djahandarie> @src certainly wouldn't show it
19:00:12 <lambdabot> Source not found. My mind is going. I can feel it.
19:00:24 <Jesin> yeah, I know
19:00:27 <Jesin> I just wondered  :p
19:00:35 <sshc> How do I include modules with "ghc -e ..."?
19:01:06 <djahandarie> Jesin, transpose isn't fused
19:01:46 <Jesin> hmm
19:02:08 <Jesin> I think I heard about something called stream fusion, that's more general than fold/build/augment?
19:02:16 <djahandarie> It isn't more general.
19:02:23 <djahandarie> It's just a different attack.
19:02:30 <djahandarie> s/attack/approach/
19:02:40 <djahandarie> It does better on some functions and worse on others
19:03:27 <Jesin> I don't suppose they can be used together very well?
19:03:43 <djahandarie> Not on the same list.
19:04:10 <djahandarie> Well, not in the same chain of functions on that list
19:04:19 <Jesin> right
19:04:58 <djahandarie> I think transpose could be fused with stream fusion but I'm not sure if it actually is
19:05:14 <Jesin> does GHC use stream fusion?
19:05:21 <djahandarie> Internally?
19:05:22 <Jesin> I know it uses build/augment, those are in the RULES
19:05:39 <Jesin> in GHC.Base and such
19:05:41 <Jesin> but
19:05:54 <djahandarie> Couldn't tell you, I stay away from GHC internals. :P
19:06:03 <Jesin> lol
19:06:25 <Jesin> presumably it has been implemented for GHC?
19:06:48 <djahandarie> For any Haskell compiler that supports the RULES pragma 
19:06:50 <Saizan> there's a package on hackage that provides a version of Data.List that uses stream fusion
19:06:56 <Jesin> hm
19:06:57 <Jesin> http://hackage.haskell.org/package/stream-fusion
19:06:58 <djahandarie> @hackage stream-fusion
19:06:58 <lambdabot> http://hackage.haskell.org/package/stream-fusion
19:07:00 <djahandarie> Yes
19:07:55 <Jesin> hmm
19:07:59 <djahandarie> Jesin, anywhere you can use foldr/build you can use stream fusion
19:08:14 <Jesin>                  -- we just reuse these:
19:08:16 <Jesin>                  foldr, (++), map
19:08:20 <Jesin> it reuses those from GHC.Base
19:08:47 <Jesin> wouldn't importing those like that, also bring in the build/augment rules?
19:08:58 <djahandarie> There are none on those functions.
19:09:50 <djahandarie> I lied
19:11:35 <djahandarie> I guess it just doesn't matter. Because I'm pretty sure it would bring in the rules.
19:12:32 <djahandarie> Or maybe the ones in Data.List.Stream take precedence
19:13:52 <Jesin> ...wow
19:14:07 <Jesin> this looks quite a bit more complicated than build/augment
19:14:21 <djahandarie> Read the paper, it's nicer than just reading the rules :P
19:15:44 <Jesin> probably  :p
19:15:55 <franz_> mfw djahandarie 
19:15:59 <franz_> hi djahandarie!
19:16:22 <djahandarie> Hi.
19:16:41 <djahandarie> How's your Haskell learning going franz_
19:16:58 <franz_> I can do basic math in that browser thing you linked!
19:17:06 <franz_> replaced my solar powered calculator already
19:17:19 <djahandarie> @where lyah
19:17:19 <lambdabot> http://www.learnyouahaskell.com/
19:17:20 <djahandarie> :P
19:17:31 <Jesin> you can do basic math in the google search box too
19:17:31 <Adamant> the internets: replacing solar powered calculators everywhere
19:17:32 <Jesin> :p
19:17:39 <Jesin> and wolframalpha
19:21:44 <acowley> I get too cute with castPtr sometimes. The bites back kind of cute.
19:22:46 <Jesin> @undefine
19:22:49 <Jesin> hmm
19:22:58 <Cale> > showHex 187649984473770 ""
19:22:58 <lambdabot>   "aaaaaaaaaaaa"
19:29:14 <Jesin> ...
19:29:18 <Jesin> {-# INLINE [1] zipWith #-}
19:29:19 <Jesin> --FIXME: If we change the above INLINE to NOINLINE then ghc goes into
19:29:21 <Jesin> --       a loop, why? Do we have some dodgy recursive rules somewhere?
19:29:23 <Jesin> that doesn't sound good
19:29:25 <Jesin> :p
19:29:41 <dankna> any system as big as ghc is held together of necessity with large amounts of hope
19:29:58 <dankna> (you may cut the hope with liquid moonlight if you wish to increase its mimsiness)
19:30:40 * Jesin outgrabes
19:30:43 <dankna> hehe
19:31:36 <Jesin> hm, and then they commented out the unstream rule
19:31:40 <Jesin> -- "zipWith -> unfused" [1]  forall f xs ys.
19:31:42 <Jesin> --     unstream (Stream.zipWith f (stream xs) (stream ys)) = zipWith f xs ys
19:31:59 <acowley> RULES and INLINE are brutally difficult to work with
19:32:00 <dankna> hm
19:32:31 <acowley> we should be thankful the authors included comments about the trickyness
19:32:49 <Jesin> yeah
19:33:10 <Jesin> I can understand why people are reluctant to put stream fusion in the standard library
19:33:51 <Jesin> it's... big
19:33:53 <Jesin> :p
19:34:27 <Jesin> build and augment can at least be reasoned with
19:34:39 <sshc> How do I import modules with "ghc -e ..."?
19:35:04 <acowley> Jesin: what are you looking at that's big?
19:35:21 <Jesin> http://hackage.haskell.org/packages/archive/stream-fusion/0.1.2.2/doc/html/src/Data-Stream.html
19:35:23 <Jesin> and
19:35:24 <Jesin> http://hackage.haskell.org/packages/archive/stream-fusion/0.1.2.2/doc/html/src/Data-List-Stream.html
19:35:47 <shachaf> sshc: ghc -e ":m + Module" -e "...", maybe?
19:36:46 <Jesin> ...
19:36:48 <Jesin> wow
19:36:57 <Jesin> so many of these things are just marked -- TODO fuse
19:38:45 <acowley> Jesin: Well, the beauty of stream fusion is that it supposed to be that it's small. There is just the one rule for stream fusion. Other rules are little conveniences
19:39:04 <Jesin> huh
19:39:07 <Jesin> what is that one rule
19:39:14 <djahandarie> Holy smack, I just came across this: http://unlines.wordpress.com/2009/09/29/squinting-at-fusion/
19:39:18 <djahandarie> I was think about this the other day
19:39:25 <acowley> forall s. stream (unstream s) = s
19:39:27 <djahandarie> Figures that rl has already done it ;)
19:39:42 <Jesin> umm
19:39:46 <Jesin> what about
19:39:55 <Jesin> forall s. unstream (stream s) = s
19:40:43 <acowley> That's not in Data.Stream
19:40:58 <Jesin> yeah, ok...
19:41:03 <djahandarie> koninkje_away, in http://unlines.wordpress.com/2009/09/29/squinting-at-fusion/ you commented "(And I’ve written up a type class for doing generic ana/build fusion for arbitrary mu-recursive types.)" Is this online anywhere?
19:41:09 <Jesin> hm.
19:42:46 <tnks> how do I pronounce <*>?
19:42:53 <aristid> ap
19:43:53 <tnks> okay, so as in a strong abbreviation of applicative/apply?
19:44:03 <djahandarie> "leshanstareatehan"
19:44:16 <stepkut> it's pronounce, "imperial TIE figther" I think..
19:44:35 <tnks> yeah, I've hear that too.
19:45:39 <tnks> djahandarie: Googling for "leshanstareatehan" left me empty
19:45:42 <Jesin> hm
19:45:44 <Jesin> http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion
19:45:58 <Jesin> apparently build/foldr is not always correctness-preserving
19:46:01 * djahandarie attempted smashing "less than star greater than" into one word
19:46:44 <tnks> djahandarie: okay, I  thought it was some obscure C
19:46:50 <djahandarie> :P
19:46:53 <tnks> CT mathemematician.
19:52:47 <tnks> I like the answer for http://stackoverflow.com/questions/3242361/haskell-how-is-pronounced
19:53:28 <tnks> but I'm a little bothered by "I encourage liberal use, and non-pronunciation, of all lifted application operators"
19:54:08 <acowley> Haskellers should be seen, not heard.
19:55:03 <tnks> it seems to me a senseless impediment that confrontationally blocks people that communicate better in different ways.
19:55:49 <Jesin> I might call it "apply"
19:56:18 <tnks> yeah, me too.
19:56:25 <Jesin> though I guess you could also call it cthkt
19:56:27 <Jesin> or whatever
19:57:01 <shachaf> I thought the standard pronunciation for all the Haskell operators is a sort of grunt.
19:57:08 <acowley> tnks: Calling it "ap" or "apply" is fine, but the point of not pronouncing it is provocative specifically to point out that it is whitespace at another type.
19:58:22 <tnks> acowley: that rationale sounds more sane, but I think I need to understand more
19:59:44 <acowley> I don't know how sane, much less helpful, it is, really. I usually just say "map" when dealing with any kind of lifting of functions :/
20:12:01 <sshc> shachaf: Thanks
21:02:18 <tg_> what four word phrase comes to mind when I say "scala"?
21:02:44 <tg_> swear words recommended
21:04:00 <dark> what against?
21:04:53 <tg_> haskell, I suppose
21:05:15 <Adamant> at least it's not java
21:05:20 <tg_> lol
21:05:24 <tg_> that's a good start.
21:05:28 <Adamant> actually this is sorta nice
21:05:43 <Adamant> I can live with this just fine
21:05:53 <Adamant> that was my reaction to it
21:06:19 <tg_> no tail call support = no truly infinite structures, though?
21:06:32 <dark> no
21:06:44 <tg_> no, that's not true?
21:06:45 * hackagebot twine 0.1.1 - very simple template language  http://hackage.haskell.org/package/twine-0.1.1 (JamesSanders)
21:07:05 <dark> no tail call = you have to use imperative loops sometimes
21:07:24 <dark> but this is a issue of the jvm u.u
21:07:30 <tg_> yeah
21:07:37 <Adamant> and specifically the Oracle JVM
21:07:51 <tg_> powered by Oracle
21:08:01 <Adamant> it may be corrected in the next 1-3 years
21:08:19 <Adamant> after the dynamic language support pack for the JVM, TCO instructions are supposedly on Da List
21:08:30 <dark> in any functional language you can simulate truly infinite structures by simulating lazy evaluation (with closures)
21:08:48 <tg_> ok
21:08:53 <tg_> i'll take a deeper look tomorrow then
21:08:53 <accel> are ! & seq matters of haskell or ghc extensions?
21:09:08 <tg_> accel: prelude?
21:09:28 <shachaf> accel: The Report answers that question.
21:09:33 <shachaf> @where report
21:09:33 <lambdabot> http://www.haskell.org/onlinereport/
21:09:46 <Adamant> tg_: it's not as elegant as Haskell, in the same way Clojure is not as elegant as Scheme, but both are plenty nice enough to get things done in.
21:10:12 <accel> shachaf: which section?
21:10:12 <tg_> accel: http://zvon.org/other/haskell/Outputglobal/index.html is an alternative link
21:10:21 <accel> shachaf: c-f seq is not bringing up anything
21:10:31 <tg_> accel: http://zvon.org/other/haskell/Outputprelude/seq_f.html
21:10:32 <accel> shachaf: found it
21:10:35 <shachaf> @google haskell report seq
21:10:35 <accel> tg_: nice; thanks
21:10:35 <lambdabot> http://www.haskell.org/onlinereport/basic.html
21:10:35 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
21:10:42 <accel> tg_ ++
21:11:17 <tg_> Adamant: my interest in haskell is in the evaluation of some fractals and multifractals
21:11:24 <accel> i feel like I am now smart enough
21:11:27 <accel> to read the haskell report
21:11:33 <accel> ladies & gentlemen, wish me luck
21:11:34 <tg_> accel: prepare to be slapped in the face
21:11:54 <Adamant> more like a gentle drubbing.
21:34:18 <Veinor> @quote endo
21:34:18 <lambdabot> stepcut says: endo-hylo-cata-ana-expi-ali-docious!
21:38:11 <djahandarie> Haha
21:38:36 <Veinor> Is Hask a small category?
21:38:56 <djahandarie> Yes
21:39:03 <stepkut> :)
21:42:20 <dark> @undo let (a, s) = runState (mud x) inicial in a : run mud s xs
21:42:20 <lambdabot> let { (a, s) = runState (mud x) inicial} in a : run mud s xs
21:42:26 <dark> @pl let (a, s) = runState (mud x) inicial in a : run mud s xs
21:42:26 <lambdabot> (line 1, column 5):
21:42:26 <lambdabot> unexpected "("
21:42:26 <lambdabot> expecting "()", natural, identifier or "in"
21:43:05 <dark> run mud inicial (x:xs) = let (a, s) = runState (mud x) inicial in a : run mud s xs , i'm trying to beautify this (like, to remove the explicit recursion). doesn't it look like a fold?
21:44:13 <dark> it is walking in a list, and building another list, where elements depend on the current 'state' and the 'next' list element
21:45:14 <conal> dark: if you swap the last two args, i think you can make run a foldr
21:45:15 <dark> ok, it is a foldl
21:45:27 <dark> hm
21:45:53 <conal> run mud = foldr ...
21:46:23 <conal> the trick is that the foldr yields a function.
21:46:33 <dark> but I'm confused. the consumer of this will read the resulting list lazily. because it is infinite (the input list is infinite to begin with)
21:46:42 <accel> what's the best way to start contributing code to GHC (i.e. what are the entry level newb positions?)
21:47:25 <conal> dark: similar to the trick of expressing foldl as a foldr
21:47:43 <dark> so i can't build a list by adding it to the top, because that way there would be no 'first' element... getting an infinite list and outputting an infinite list seems to require a map, not a fold
21:48:15 <dark> but the n-th output depends on all n-1 - th inputs! so the third input depends on both first and second (since both can change state). hence, fold
21:49:10 <dark> if the input list were finite, my resulting list with that algorithm would be reversed (the top would be the last answer) so i would just reverse it again
21:49:27 <dark> so the third output depends on both first and second*
21:49:41 <dark> (on both first and second input)
21:50:31 * Kaidelong wants to get a IO (a -> b) out of an a -> IO b, is this possible?
21:51:05 <dark> (actually, i think i'm wrong on that, and it indeed seems like a foldr, thanks conal)
21:51:26 <conal> dark: (once you swap the 2nd & third arguments)
21:51:30 <dark> but, is foldr tail recursive?
21:51:52 <conal> @src foldr
21:51:52 <lambdabot> foldr f z []     = z
21:51:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:51:57 <Kaidelong> Hoogle turns up nothing
21:52:04 <dark> it does not looks like
21:52:08 <Kaidelong> so I'm starting to fear that it is not possible
21:52:14 <Kaidelong> (which is bad)
21:52:32 <dark> if it isn't tail recursive, how can it be advised for 'infinite lists'?
21:52:44 <Veinor> hm. how do I tell cabal to use something other than ~/.cabal as its directory ?
21:52:52 <conal> dark: the issues are different for lazy languages.
21:52:53 <Kaidelong> I suppose I could use "return . (unsafePerformIO .)"
21:53:19 <conal> Kaidelong: or rethink your way out of wanting what you now want
21:53:48 <Kaidelong> conal: i want to talk about routing services in pure terms but no actual routing service is going to be pure
21:54:12 <dark> conal, so haskell will somehow magically free the stack?
21:54:29 <Kaidelong> class RoutingService s where producesRoute :: s -> (Coordinates,Coordinates) -> Route
21:55:05 <dino-> Veinor: I don't see a switch for that. But I suppose you could make a symlink at ~/.cabal to some other dir.
21:55:26 <conal> dark: hard to answer that question. i don't think "the stack" works the way you're used to.
21:56:02 <dark> so this: <lambdabot> foldr f z (x:xs) = f x (foldr f z xs) doesn't mean it is eating more and more space, continually?
21:56:38 <dark> building the "path" f x (foldr f z xs) => f x (f x' (foldr f z xs'))..
21:57:12 <dark> if not, what really *means* tail recursive in lazy languages?
21:57:16 <conal> dark: right. it doesn't mean that. for instance map is a foldr and can run in constant space
21:57:43 <conal> (with infinite input & output)
21:58:26 <dark> map is a foldr o.o
21:58:48 <dark> @src map
21:58:48 <lambdabot> map _ []     = []
21:58:48 <lambdabot> map f (x:xs) = f x : map f xs
22:00:35 <conal> dark: right. you can compare the definitions of 'map h' & foldr and figure out what the f and z must be in foldr to end up with map.
22:01:24 <conal> dark: it's a valuable technique to learn.
22:02:27 <ClaudiusMaximus> why use runState on each step? i'd compose a larger monadic action and just runState once at the end
22:02:57 <dark> ClaudiusMaximus, I obviously don't understand monads
22:03:00 <ion> kaidelong: Say, you have (\a → if a then getLine else return ""). Coercing it into IO (a → b) would mean an IO action that, when executed, results in a pure function that either takes True and reads a line from the user or takes False and returns "". Oh, wait. That doesn’t sound like a pure function at all. :-)
22:03:09 <dark> i mean
22:03:12 <conal> dark: that same technique will show you how flip (run mud) is a foldr.
22:03:16 <dark> not only monads but also state
22:03:47 <Kaidelong> ion: well I need a second order function to work with an IO action
22:04:00 <Kaidelong> how do I do this?
22:04:16 <ClaudiusMaximus> > let mud = \n -> do { modify (+n) ; chr `fmap` get } in take 11 . fst . runState (mapM mud [1..]) . ord $'$' -- i came up with this
22:04:16 <Kaidelong> mapM is an example that things like that can be accomplished in specific contexts
22:04:18 <lambdabot>   "%'*.39@HQ[f"
22:04:27 <Kaidelong> but mapM is too specific
22:04:43 <Kaidelong> @src mapM
22:04:43 <lambdabot> mapM f as = sequence (map f as)
22:04:50 <Kaidelong> @src sequence
22:04:50 <lambdabot> sequence []     = return []
22:04:50 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:04:50 <lambdabot> --OR
22:04:50 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:04:52 <dark> @src sequence
22:04:52 <lambdabot> sequence []     = return []
22:04:52 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:04:54 <lambdabot> --OR
22:04:56 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:05:05 <dark> lol
22:06:15 <Kaidelong> perhaps what I want is something like "a -> b -> c" to "a -> m b -> m c"
22:06:26 <Kaidelong> err
22:06:39 <Kaidelong> (a -> b) -> c -> (a -> m b) -> m c
22:06:45 <dark> @type (>>=)
22:06:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:06:48 <conal> that last one is lovely, after dropping xs and replacing liftM2 & return with liftA2 & pure.
22:07:19 <dark> it's best to leave it for the international obfuscated haskell code contest
22:07:21 <conal> i like how it poetically weaves the Applicative & Monoid operations.
22:07:53 <conal> and doesn't need Monad at all
22:08:15 <ClaudiusMaximus> :t sequenceA
22:08:15 <lambdabot> Not in scope: `sequenceA'
22:08:49 <conal> and doesn't need lists either
22:08:58 <conal> for the input
22:09:29 <conal> hm. i guess it does.
22:10:43 <Kaidelong> conal: it doesn't need lists I don't think. you could do it for Monoids
22:10:55 <Kaidelong> oh
22:11:05 <Kaidelong> well it needs an input list, done like that
22:11:10 <Kaidelong> but it can output things other than lists
22:11:45 <conal> Kaidelong: i was thinking about the type of sequenceA
22:12:48 <Kaidelong> (MonadPlus m, Applicative f) => [f a] -> f (m a)
22:12:50 <Kaidelong> ?
22:13:11 <Kaidelong> that is about the most general idea I can think of off the cuff
22:15:15 <quuuux> is there a reason beyond the 80% rule why you can't derive Enum for more-than-nullary constructors when all the types satisfy Enum and Bounded?
22:15:27 <Veinor> 80% rule?
22:15:30 <Kaidelong> @ty foldr (<*>) (pure mzero) . fmap (fmap mplus)
22:15:31 <lambdabot> forall (f :: * -> *) (m :: * -> *) a. (Applicative f, MonadPlus m) => [f (m a)] -> f (m a)
22:15:47 <Kaidelong> @ty foldr (<*>) (pure mzero) . fmap (fmap (mplus . return))
22:15:48 <lambdabot> forall (f :: * -> *) (m :: * -> *) a. (Applicative f, MonadPlus m) => [f a] -> f (m a)
22:15:52 <Kaidelong> there we go
22:16:26 <conal> quuuux: i wonder also. would be great to Enum algebraic data types.
22:16:55 <Kaidelong> @ty foldr (<*>) (pure mappend) . fmap (fmap (mempty))
22:16:56 <lambdabot> forall (f :: * -> *) a a1. (Applicative f, Monoid a) => [f a1] -> f (a -> a -> a)
22:17:01 <Kaidelong> no...
22:17:14 <Kaidelong> @ty foldr (<*>) (pure mempty) . fmap (fmap (mappend))
22:17:15 <lambdabot> forall (f :: * -> *) b. (Applicative f, Monoid b) => [f b] -> f b
22:17:19 <Kaidelong> oh right
22:18:30 <Kaidelong> I think the MonadPlus version is one that could actually work as sequenceA
22:20:03 <quuuux> oh well. Ugly explicit enumeration here I come
22:24:42 <lispy> quuuux: enum type class is broken, IMO
22:25:02 <dancor> can't we make a DeriveTH thing for it
22:25:27 <dancor> http://hackage.haskell.org/packages/archive/derive/2.4.2/doc/html/Data-Derive-Enum.html
22:25:33 <lispy> quuuux: for some reason it assumes Int for toEnum/fromEnum
22:25:48 <lispy> quuuux: but it seems like it should assume Integral
22:26:04 <dancor> maybe this has to do with the practical background of enums
22:29:17 <quuuux> lispy: all true, but all I want is to be able to write [maxBound..] :)
22:29:38 <quuuux> er. minBound. It's only a minus sign away
22:29:40 <lispy> dancor: But, the prelude defines an Integer instance for Enum
22:29:47 <dancor> quuuux: have you tried Data.Derive
22:29:56 <dancor> mm
22:29:57 <lispy> dancor: considering that Int is smaller than Integer, how can that work?
22:30:15 <dancor> ha ya
22:30:25 <quuuux> dancor: not yet. The path of least resistance right now is to construct the list of all members of the ADT myself
22:30:31 <dancor> ok
22:30:53 <lispy> > (10^10, toEnum 10^10) :: (Integer, Integer)
22:30:54 <lambdabot>   (10000000000,10000000000)
22:31:03 <lispy> > (10^20, toEnum 10^20) :: (Integer, Integer)
22:31:04 <lambdabot>   (100000000000000000000,100000000000000000000)
22:31:14 <lispy> oh
22:31:19 <dancor> precedence?
22:31:29 <lispy> > (10^20, toEnum (10^20)) :: (Integer, Integer)
22:31:30 <lambdabot>   (100000000000000000000,7766279631452241920)
22:31:55 <dancor> lo
22:32:14 <lispy> > toEnum <$> (10^20, 10^20)
22:32:14 <lambdabot>   (100000000000000000000,*Exception: Prelude.Enum.().toEnum: bad argument
22:33:14 <lispy> > id <$> (10^20, 10^20)
22:33:15 <lambdabot>   (100000000000000000000,100000000000000000000)
22:33:20 <lispy> > show <$> (10^20, 10^20)
22:33:21 <lambdabot>   (100000000000000000000,"100000000000000000000")
22:33:31 <lispy> So, why is that one an exception and the other is fine?
22:33:40 <lispy> > (10^20, toEnum (10^20 :: Int)) :: (Integer, Integer)
22:33:40 <lambdabot>   (100000000000000000000,7766279631452241920)
22:33:45 <lispy> > (10^20, toEnum (10^20 :: Integer)) :: (Integer, Integer)
22:33:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
22:33:45 <lambdabot>         against inferred type ...
22:33:56 <ClaudiusMaximus> > toEnum 0 -- defaulting?
22:33:57 <lambdabot>   ()
22:35:09 <Kaidelong> is implication associative?
22:35:16 <Kaidelong> I'm guessing not
22:35:24 <Kaidelong> or I guess I could just ask Djinn
22:35:38 <Kaidelong> @djinn ((a -> b) -> c) -> (a -> (b -> c))
22:35:38 <lambdabot> f a _ b = a (\ _ -> b)
22:35:43 <conal> Kaidelong: True => (True => False)
22:35:49 <lispy> > toEnum <$> (10^20, 10^20) :: (Integer, Integer)
22:35:50 <lambdabot>   (100000000000000000000,7766279631452241920)
22:36:14 <conal> Kaidelong: hm. bad example
22:36:15 <ClaudiusMaximus> :t ?toEnum 0 :: Int
22:36:16 <lambdabot> forall t. (Num t, ?toEnum::t -> Int) => Int
22:36:19 <Kaidelong> conal: that's not a counterexample
22:36:24 <conal> righ
22:36:25 <conal> t
22:36:37 <ClaudiusMaximus> :t ?toEnum (0 :: Int)
22:36:38 <lambdabot> forall t. (?toEnum::Int -> t) => t
22:37:15 <lispy> :t foldr
22:37:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:37:23 <lispy> :t foldl
22:37:24 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:37:56 <lispy> > foldr (+) 0 [a,b,c]
22:37:56 <lambdabot>   a + (b + (c + 0))
22:38:02 <ClaudiusMaximus> @check (\x -> x == toEnum x)
22:38:03 <lambdabot>   "OK, passed 500 tests."
22:38:40 <lispy> > foldl (+) 0 [a,b,c]
22:38:41 <lambdabot>   0 + a + b + c
22:39:02 <ivanm> what's the best way to make a value an instance of NFData?
22:39:18 <ivanm> does rnf = rnf . show suffice?
22:39:56 <lispy> ivanm: look at RWH they have examples
22:40:26 <ivanm> do you remember which chapter?
22:41:01 <ivanm> oh, looks like it's the bloom filter one
22:41:38 <lispy> ivanm: chapter 25?
22:41:55 <ivanm> yeah, looks like that's it
22:41:55 <ivanm> ta
22:43:32 <ivanm> OK, so just to be able to use criterion I have to suddenly make NFData instances for a whole slew of types... :s
22:43:51 * ivanm might cheat and just use rnf = rnf . show
22:45:23 <lispy> that will ruin your timings but it would be strict
22:48:28 <ivanm> how will it ruin the timings if I'm just using it to compare implementations?
22:48:36 <conal> @check (let a ==> b = b || not a in \ a b c -> (a ==> b) ==> c == a ==> (b ==> c)) -- Kaidelong 
22:48:36 <lambdabot>   "Falsifiable, after 7 tests:\nFalse\nFalse\nFalse\n"
22:49:21 <Kaidelong> that's nice of quickcheck
22:49:35 <conal> yeah
22:49:44 <lispy> ivanm: may be okay in that situation, but it will slow it down
22:49:50 <ivanm> *nod*
22:50:16 <ivanm> well, it's either that or I create NFData instances for every single data type, which I can't be bothered doing atm
22:50:33 <ivanm> especially since my goal with this is to see whether the slowdown is due to I/O or something else
22:52:37 <ClaudiusMaximus> hm, i have about 400k static line segments in 2D that i want to display (zooming/panning/etc), almost all of them will be outside the viewport - are haskell's opengl bindings up to the job? (ie, can i upload all the data to the gpu and just twiddle some matrices each frame?)
22:54:21 <conal> ClaudiusMaximus: i expect a fairly recent graphics card would be up to the job.
22:54:40 <conal> ClaudiusMaximus: i think viewport clipping is pretty efficient
22:55:20 <conal> ClaudiusMaximus: if you have some kind of spatial data structure, you might be able to clip more efficiently yourself. but i'd try letting opengl & the card handle it first.
22:55:30 <ClaudiusMaximus> conal: cool - i'm not sure where to start doing this from Haskell though, never really used vertex buffers (or whatever the name really is) in any language either...
22:55:45 <conal> ClaudiusMaximus: yeah. vertex buffers.
22:55:55 <conal> opengl is a horrific api
22:56:24 <ClaudiusMaximus> conal: getting fed up with this video that i'm rendering slooowly using a 1.1GB ppm image and "pnmcut" taking 1 second per frame...
22:56:41 <ClaudiusMaximus> conal: ...and then looking terrible because of the lack of sub-pixel scrolling
22:57:12 <conal> ClaudiusMaximus: if/when you get it working in opengl, i bet you'll be delighted with the speed.
22:59:04 <nanothief> In a file with one line "import Language.Haskell.Meta.Parse", when I load it in ghc with -v set, I get these errors: http://hpaste.org/44126/shadowed_package_problem . The problem seems to be template-haskell-2.5.0.0-1 is being shadowed by template-haskell-2.5.0.0 . Is there a way to fix this? 
22:59:47 <nanothief> actually I get the error when running "ghc -v" as well
23:01:10 <ClaudiusMaximus> conal: yeah, opengl is a bit head-wrecking :) but it's fast, i particularly like fragment shaders, though i'm curious about vertex shaders+"transform feedback" for some purposes...
23:01:46 <conal> ClaudiusMaximus: "transform feedback"?
23:01:53 * conal is intrigued
23:02:23 <ClaudiusMaximus> conal: lets you capture output of vertex shader (+ optional geometry shader) back into vertex buffers
23:02:47 <conal> oh, neat.
23:02:55 <ClaudiusMaximus> conal: at least that's how i understood it
23:03:24 <nanothief> paste of "ghc -v": http://hpaste.org/44127/ghc_v_output__unusable_packa , it seemed to start happing after I ran "cabal install numeric-prelude" (which failed to install)
23:03:31 <ClaudiusMaximus> conal: http://www.opengl.org/registry/specs/NV/transform_feedback.txt
23:03:44 <conal> ClaudiusMaximus: thx.
23:33:27 <bradleyayers> http://www.haskell.org/tutorial/classes.html says that the reason that elem is used in infix form is defined in section 3.1, but it's actually in section 3.2
23:33:36 <bradleyayers> where should i report this?
23:37:23 <ivanm> bradleyayers: http://www.haskell.org/tutorial/index.html
23:38:07 <bradleyayers> i wan't to report the documentation bug
23:38:16 <bradleyayers> want
23:38:27 <bradleyayers> ... i don't know why i put an apostrophe there
23:41:01 <ivanm> bradleyayers: yeah, but the person who last updated it is listed there
23:41:13 <bradleyayers> ivanm: ahh, thank-you :)
