00:09:41 * hackagebot hbeanstalk 0.2.1 - Client for the beanstalkd workqueue service.  http://hackage.haskell.org/package/hbeanstalk-0.2.1 (GregHeartsfield)
00:09:59 <NemesisD> i'm declaring record types, it seems like a good idea to put one per module so the fields don't clash, but i'm having a hard time naming the module. can a module have the same name as a record type which it exports?
00:11:29 <Bynbo7> yes
00:11:39 <Bynbo7> see Data.Map.Map
00:13:10 <NemesisD> so thats sort of the standard when exporting modules which focus on a record type
00:18:33 <Wooga> hello, can someone help me with iteraties? i am trying to wriate an iteratee, which chomping first three chars from input stream, splited into 2 char blocks, but i am apparently doing something wrong here: http://paste.pocoo.org/show/332026/
00:19:20 <Wooga> because it always returns IE_cont
00:20:09 <Wooga> yet it works well if block size >= 3
00:39:30 <Maxdamantus> @pl \(a, (b, c)) -> (a, b)
00:39:30 <lambdabot> uncurry ((`ap` snd) . (. fst) . (const .) . (,))
00:40:13 <Wooga> ...anyone?
00:40:27 <Baughn> @pl \(d, e, h, l, o, r, w) -> (h, e, l, l, o, w, o, r, l, d)
00:40:27 <lambdabot> (line 1, column 7):
00:40:28 <lambdabot> unexpected ","
00:40:28 <lambdabot> expecting letter or digit, operator or ")"
00:40:28 <lambdabot> ambiguous use of a non associative operator
00:41:43 <Maxdamantus> @pl \a b c d e f g h i j k l m n o p -> p o n m l k j i h g f e d c b a
00:41:46 <lambdabot> flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .)
00:41:46 <lambdabot> .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .)
00:41:46 <lambdabot> .) .) .) . (((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .
00:41:46 <lambdabot> ) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .)
00:41:46 <lambdabot> .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((
00:41:48 <lambdabot> [9 @more lines]
00:41:50 <lambdabot> optimization suspended, use @pl-resume to continue.
00:41:56 <Baughn> @pl \d, e, h, l, o, r, w -> (h, e, l, l, o, w, o, r, l, d)
00:41:57 <lambdabot> (line 1, column 6):
00:41:57 <lambdabot> unexpected ","
00:41:57 <lambdabot> expecting letter or digit, operator, pattern or "->"
00:41:58 <lambdabot> ambiguous use of a non associative operator
00:42:05 <Bynbo7> Baughn: ,
00:42:06 <glguy> Baughn: I suspect that there aren't many point-free functions on more than 2-tuples
00:42:10 <Baughn> @pl \d e h l o r w -> (h, e, l, l, o, w, o, r, l, d)
00:42:12 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip flip id . (liftM2 (flip . ((flip . (flip .) . flip) .)) .) . flip flip id . ((flip . (liftM2 flip .)) .) . flip flip id . (ap .) .
00:42:13 <lambdabot> flip (,,,,,,,,,))
00:42:23 <Baughn> glguy: This one does.
00:42:35 <glguy> that one doesn't have to deconstruct on
00:42:37 <glguy> one*
00:42:48 <Bynbo7> @unpl flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip flip id . (liftM2 (flip .  ((flip . (flip .) . flip) .)) .) . flip flip id . ((flip . (liftM2 flip .)) .) . flip flip id  . (ap .) .
00:42:48 <lambdabot> Unbalanced parentheses
00:42:54 <Bynbo7> @unpl flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip flip id . (liftM2 (flip .  ((flip . (flip .) . flip) .)) .) . flip flip id . ((flip . (liftM2 flip .)) .) . flip flip id  . (ap .) . flip (,,,,,,,,,))
00:42:54 <lambdabot> (\ b c f i l o r -> ((\ bh -> ((((,,,,,,,,,) f c) >>= \ dx -> (\ by -> by) >>= \ dw -> return (dx dw)) bh) >>= \ bj -> (\ be -> be) >>= \ bi -> return (\ bp -> bj bp bi)) >>= \ ae -> (\ ac -> ac) >>=
00:42:54 <lambdabot>  \ ad -> return (\ ak an ar -> ae ak ar an ad)) i l o r b)
00:43:04 <Bynbo7> close enough :P
00:43:17 <Baughn> @pl (\ b c f i l o r -> ((\ bh -> ((((,,,,,,,,,) f c) >>= \ dx -> (\ by  -> by) >>= \ dw -> return (dx dw)) bh) >>= \ bj -> (\ be -> be) >>=  \ bi -> return (\ bp -> bj bp bi)) >>= \ ae -> (\ ac -> ac) >>=
00:43:17 <lambdabot> (line 1, column 202):
00:43:17 <lambdabot> unexpected end of input
00:43:17 <lambdabot> expecting white space or simple term
00:43:22 <glguy> @pl \ (x,y) -> x y
00:43:22 <lambdabot> ap fst snd
00:43:23 <Baughn> @pl (\ b c f i l o r -> ((\ bh -> ((((,,,,,,,,,) f c) >>= \ dx -> (\ by  -> by) >>= \ dw -> return (dx dw)) bh) >>= \ bj -> (\ be -> be) >>=  \ bi -> return (\ bp -> bj bp bi)) >>= \ ae -> (\ ac -> ac) >>= \ ad -> return (\ ak an ar -> ae ak ar an ad)) i l o r b)
00:43:24 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip flip ((`fmap` id) . flip . ((flip . (flip .) . flip) .)) . ((>>=) .) . flip flip ((`fmap` id) . flip) . ((flip . ((>>=) .)) .) .
00:43:25 <lambdabot> flip flip ((id >>=) . (return .)) . ((>>=) .) . flip (,,,,,,,,,))
00:43:29 <glguy> @pl \ (x,y,z) -> x y z
00:43:29 <lambdabot> (line 1, column 7):
00:43:29 <lambdabot> unexpected ","
00:43:29 <lambdabot> expecting letter or digit, operator or ")"
00:43:29 <lambdabot> ambiguous use of a non associative operator
00:43:37 <glguy> This ^
00:43:45 <Bynbo7> heh, that one reads quite nicely, apply the first element to the second
00:43:47 <Maxdamantus> (@unpl . @pl) \a -> a * 2
00:43:51 <Maxdamantus> :(
00:44:03 <Bynbo7> @.unplpl \a -> a * 2
00:44:03 <lambdabot> Unknown command, try @list
00:44:04 <Baughn> @. unpl pl \a -> a * 2
00:44:04 <lambdabot> (\ a -> 2 * a)
00:44:09 <Bynbo7> @. unpl pl \a -> a * 2
00:44:09 <lambdabot> (\ a -> 2 * a)
00:44:12 <glguy> @. unpl pl \ a -> a * 2
00:44:12 <lambdabot> (\ a -> 2 * a)
00:44:12 <Maxdamantus> O_o
00:44:14 <Bynbo7> bloody spacebar
00:44:25 <taotree> Is it possible to have a function that will return true if any length (or a number of finite lengths) of tuple has only Nothing's in it?  http://hpaste.org/43605/nothing_tuple
00:44:31 <Baughn> @. pl . unpl pl \a -> a * 2
00:44:31 <lambdabot> (2 *)
00:45:05 <glguy> taotree: you could write a class
00:45:07 <Bynbo7> taotree: I'm going to say no
00:45:22 <Maxdamantus> I think you'd have to have a separate function for each tuple length.
00:45:26 <Baughn> taotree: Kind of, but you have to explicitly instance every tuple length, which is a pain.
00:45:40 <glguy> He allowed for "a number of finite lengths"
00:45:55 <glguy> and throw in some overlapping instances
00:47:57 <taotree> ok, first I'll try class...
00:49:51 <kfr> That sounds more like a job for a list or some other container
00:49:56 <kfr> taotree why do you wish to do this for tuples?
00:51:51 <taotree> kfr, can't use list, heterogenous types
00:52:37 <kfr> Can you wrap them up in a container which can cover all of those types?
00:53:55 <taotree> kfr, not really, there's no restriction on what types are in there
00:55:11 <kfr> This sounds like you're doing dynamic typing in Haskell or something like that :|
00:55:23 <kfr> taotree what do you use this for really?
00:56:05 <Maxdamantus> @pl \(a, b) -> (b, a)
00:56:05 <lambdabot> uncurry (flip (,))
00:57:07 <taotree> kfr, I have a DAG of processors (like Arrows, maybe they are arrows) that have various numbers of inputs and outputs, and I'm tying their inputs and outputs together.  I was trying to use something else for inputs/outputs but for now just using tuples. This specific isEmpty thing is because if something has nothing but Nothing on it's inputs, it shouldn't run for that timestep.
01:07:46 <jacobian> @unpl flip maybe Right . Left
01:07:46 <lambdabot> (\ f -> maybe ((Left) f) Right)
01:08:33 <taotree> type class worked, thanks.
01:13:02 <kfr> That sounds scarry
01:17:14 <taotree> kfr, it's been a rather curious problem :)
01:17:32 <kfr> Woops, *scary
01:24:59 * hackagebot hamlet 0.7.0 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.7.0 (MichaelSnoyman)
01:25:01 * hackagebot persistent 0.4.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.4.0 (MichaelSnoyman)
01:25:03 * hackagebot persistent-postgresql 0.4.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.4.0 (MichaelSnoyman)
01:25:59 * hackagebot persistent-sqlite 0.4.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.4.0 (MichaelSnoyman)
01:28:00 * hackagebot wai-handler-devel 0.2.0 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.2.0 (MichaelSnoyman)
01:33:03 * quicksilver takes a look at "persistent" 
01:33:10 <quicksilver> interesting but doesn't quite feel right to me
01:34:14 <geheimdienst> why does it say "nonrelational" but then has "postgres" and "sqlite" packages ...
01:34:35 <quicksilver> well you can have a non-relational model and happen to use those backend
01:34:43 <quicksilver> you just choose not to use their relational features.
01:34:48 <quicksilver> i.e. you use them as key-value stores.
01:35:10 <geheimdienst> hm okay, makes sense
01:35:16 <quicksilver> however the docs *do* seem to suggest they expect you to use relations
01:35:20 <quicksilver> it's just they never build joins
01:35:28 <quicksilver> it's "one-object-at-a-time" queries
01:35:42 <quicksilver> which seems like a bad plan ... at least, it will perform poorly for some applications.
01:36:08 <quicksilver> so, it seems quite heavyweight for something which probably isn't as good as a simpler SQL binding.
01:36:12 <quicksilver> probably I've missed the point :)
01:37:21 <geheimdienst> yes, he seems to not follow my big rule of documentation ... explain why, not how
01:40:15 <gienah> quicksilver: I think he said somewhere that he has used haskelldb in some apps which I guess required more complex database data
01:41:40 * quicksilver nods
01:41:54 <quicksilver> geheimdienst: I'm not sure he knows 'why' ; )
01:42:04 <quicksilver> geheimdienst: the package looks to me like an exploration of the design space
01:42:25 <quicksilver> geheimdienst: "how would it turn out if we made a class like this, and associated data to control this, and that would let us have a polymorphic update method like this...."
01:42:38 <quicksilver> such experiments are laudable, certainly :)
01:42:43 <geheimdienst> fair enough
01:42:45 <quicksilver> we don't find out what's good and bad without trying.
01:42:55 <quicksilver> but it doesn't immediately strike me as convincing.
01:43:04 <geheimdienst> it's certainly better to explore in code than to explore in, say, papers ...
01:43:09 <quicksilver> I was hoping it would be a simple transactional persistence model.
01:43:37 <quicksilver> I am becoming increasingly sure that we need to move to using transactional (journalled, probably) "continuously-saved" data models.
01:43:51 <quicksilver> one of the nice things about most web apps and most iOS apps is it's always safe to quit.
01:43:56 <quicksilver> data is always saved and always consistent.
01:44:12 <geheimdienst> yes, absolutely
01:44:18 <quicksilver> in principle such approachs can give you automatic backups and rollbacks.
01:44:22 <geheimdienst> some people call that crash-only software, and i like it
01:44:23 <quicksilver> without ever having to explicitly "save"
01:44:49 <quicksilver> (although none of the apps I've seen actually allow you to do rollbacks beyond some simple undo facility)
01:45:03 <gienah> quicksilver: happstack state I think can save data to a transaction log, more work is being done on this for happstack state v7
01:45:15 <quicksilver> gienah: interesting. good.
01:50:45 <Saizan> that's always been how that part of happstack worked
01:53:23 <jacobian> What does Typeable e do for me? 
01:53:36 <Saizan> ?type cast
01:53:38 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
01:53:42 <Saizan> mostly that ^^^
01:54:10 <Saizan> > cast (1 :: Int) :: Maybe Char
01:54:11 <lambdabot>   Nothing
01:54:15 <Saizan> > cast (1 :: Int) :: Maybe Int
01:54:16 <lambdabot>   Just 1
01:54:36 <Bynbo7> > cast (1::Int) :: Maybe Int64
01:54:36 <lambdabot>   Nothing
01:54:41 <Bynbo7> > cast (1::Int) :: Maybe Int32
01:54:42 <lambdabot>   Nothing
01:54:54 * frerich curses Nike for making me think of shoes whenever somebody works with Maybe a
01:55:07 <shachaf> > typeOf (1 :: Int) -- Also this.
01:55:08 <lambdabot>   Int
01:55:08 <Bynbo7> > cast ([]:: [Int]) :: Maybe String
01:55:09 <lambdabot>   Nothing
01:55:26 <Bynbo7> shachaf: asTypeOf is nothing special
01:55:32 <shachaf> Bynbo7: That's not asTypeOf.
01:55:42 <Bynbo7> oh, sorry, my bad :)
01:56:05 <Bynbo7> :t typeOf (1::Int)
01:56:06 <lambdabot> TypeRep
01:56:16 <shachaf> typeOf is, in fact, the only thing Typeable does for you.
01:58:30 <c_wraith> > typeOf1 (undefined :: Maybe Int)
01:58:31 <lambdabot>   Maybe
01:59:12 <jacobian> I'm trying to sort out how I should structure errors in my program and I'm still a bit lost. 
01:59:35 <jacobian> I think I just want to use Either String a, but I want to keep it as generic as possible in case I have to change things. 
02:00:11 <jacobian> And I'm finding it somewhat annoying to have to switch between Maybe and error types. 
02:00:42 <c_wraith> should just be a single function...
02:01:18 <c_wraith> :t maybe (Left "Got nothing") Right
02:01:19 <lambdabot> forall b. Maybe b -> Either [Char] b
02:03:07 <merijn> Any Yi users here? Do you use it for non-Haskell languages? How does it compare with $previousEditor?
02:05:38 <quicksilver> :t either (const Nothing) Just
02:05:39 <lambdabot> forall a a1. Either a1 a -> Maybe a
02:06:53 <shachaf> You could use MonadError or something of the sort?
02:07:02 <shachaf> Why doesn't it have a Maybe instance, by the way?
02:07:05 <pastorn> merijn: it has a JavaScript-mode
02:07:59 <merijn> pastorn: So the real answer is "not really suited for non-haskell stuff yet"? :p
02:09:32 <jacobian> I guess I might want something like: maybe (fail "dead") return
02:13:04 <c_wraith> you never want fail.
02:13:18 <c_wraith> Even when it's been overridden to do something not-horrible
02:13:21 <c_wraith> it's still horrible
02:13:34 <geheimdienst> > let win = fail in win "Error occurred"
02:13:35 <lambdabot>   No instance for (GHC.Show.Show (m a))
02:13:35 <lambdabot>    arising from a use of `M2158710938...
02:14:36 <jacobian> geheimdienst's example isn't very distressing though, it just didn't know what monad you wanted. 
02:14:49 <jacobian> Why is fail horrible so I can know why I'm not using it. 
02:15:03 <geheimdienst> seriously ... what's an alternative to fail? any web pages detailing the problem?
02:15:10 <geheimdienst> jacobian: i'm wondering the same
02:15:20 <merijn> :t fail
02:15:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
02:15:57 <shachaf> fail is just... Evil.
02:16:16 <merijn> :info Monad
02:16:21 <shachaf> It's almost as bad as unsafeInterleaveIO.
02:16:23 <merijn> @info Monad
02:16:23 <lambdabot> Monad
02:16:29 <shachaf> Also, lambdabot isn't ghci.
02:16:33 <merijn> hmm, now what I was looking for
02:16:37 <merijn> s/now/not
02:16:40 <c_wraith> @src Monad
02:16:40 <lambdabot> class  Monad m  where
02:16:40 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
02:16:40 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
02:16:40 <lambdabot>     return      :: a -> m a
02:16:40 <lambdabot>     fail        :: String -> m a
02:17:01 <c_wraith> The problem with fail is that it's designed to handle pattern-match failures in monadic binding *only*
02:17:07 <merijn> That's the one I wanted :p
02:17:19 <c_wraith> using it for anything else is abusing it.  Nearly as much as its existence is abusing it.
02:18:32 <jacobian> I'm sure it's true, but I'm still not clear as to where it causes you trouble. 
02:18:34 <geheimdienst> oh, you mean fail was designed for «(a,b) <- doodle» when doodle does not return an «(a,b)»?
02:18:51 <c_wraith> well, that one won't typecheck if it doesn't return a typle
02:19:05 <c_wraith> It's designed for cases like [x] <- foo
02:19:15 <c_wraith> Where the pattern match can fail, but still be well-typed
02:19:35 <geheimdienst> okay, supposing foo returns an empty list, fail would occur
02:19:40 <geheimdienst> i see
02:19:43 <c_wraith> or a list containing two elements
02:19:44 <c_wraith> etc
02:19:55 <geheimdienst> good example
02:20:13 <joe6> my code runs with a -fth command line parameter, but not without it. What pragma do I need to add to the file to get it to work.
02:20:14 <jacobian> but isn't fail exactly what I want when I'm going from Nothing -> Error ? 
02:20:29 <Bynbo7> jacobian: TemplateHaskell
02:20:32 <Bynbo7> uh, joe6 
02:20:43 <c_wraith> joe6: {-# LANGUAGE TemplateHaskell #-} ?
02:21:36 <c_wraith> jacobian: you happen to be doing a similar thing to what fail does, but you shouldn't write it in terms of fail.  To be forward compatible with the glorious future in which fail is removed from the monad class :)
02:21:52 <joe6> i had this : {-# LANGUAGE TemplateHaskell, UnicodeSyntax #-}
02:22:03 <joe6> and also {-# OPTIONS_GHC -Wall -XTemplateHaskell -XUnicodeSyntax #-}
02:22:15 <c_wraith> ack.
02:22:21 <c_wraith> don't do both of those.
02:22:24 <joe6> this is the command line that works: runghc -Wall -ddump-rn -ddump-tc -ddump-splices -ddump-types -ddump-deriv -fth 
02:22:28 <joe6> c_wraith: ok.
02:22:42 <c_wraith> not that it shouldn't work
02:22:52 <c_wraith> But language extensions should always be in LANGUAGE pragmas
02:23:00 <Bynbo7> joe6: don't use OPTIOS_GHC when there's a LANGUAGE pragma
02:23:31 <joe6> Bynbo7: oh, ok. How do I add -Wall then? can I add it to the language pragma?
02:23:44 <Bynbo7> use OPTIONS-GHC for that
02:23:46 <c_wraith> No, that one still needs OPTIONS_GHC
02:23:49 <geheimdienst> so the rule of thumb is: don't use fail, write your own fail-ish function of type Something -> WhateverMonad a
02:23:56 <joe6> yes, something is off. it does not work.
02:23:58 <c_wraith> geheimdienst: correct
02:24:12 <joe6> let me try with  OPTIONS-GHC
02:24:19 <geheimdienst> ok cool. thanks for the explanation :)
02:24:22 <Bynbo7> _, not -
02:24:35 <joe6> unknown flag in  {-# OPTIONS_GHC #-} pragma: -GHC
02:25:23 <joe6> when I have this: {-# OPTIONS-GHC -Wall #-}
02:25:31 <Bynbo7> you need _
02:26:26 <joe6> no, this does not work. {-# OPTIONS_GHC -Wall #-} {-# LANGUAGE TemplateHaskell, UnicodeSyntax #-}
02:27:16 <joe6> c_wraith: Bynbo7: any more suggestions, please?
02:27:37 <Bynbo7> are they on different lines, at the top of your file?
02:27:53 <joe6> yes, on different lines
02:28:05 <joe6> I think something more needs to be added to the language pragma
02:28:20 * geheimdienst is learning that you can put multiple things comma-separated in a LANGUAGE line
02:28:23 <joe6> as I removed the options_ghc and still got the same error message
02:28:32 <joe6> about template 
02:28:43 <joe6> haskell expansions not known.
02:30:55 <jacobian> I guess I want: maybe (throwError "dead") return
02:31:05 <Bynbo7> you can't use TH things you've defined in the same file they're defined, you know that right?
02:32:01 <joe6> Bynbo7: the same file runs with this command line "runghc -Wall -ddump-rn -ddump-tc -ddump-splices -ddump-types -ddump-deriv -fth"
02:32:06 <joe6> and the file name
02:32:32 <joe6> Bynbo7: without those parameters, it gets errors in Template Haskell code.
02:33:25 <joe6> and it even works with just "runghc -fth <filename>"
02:43:22 * hackagebot FerryCore 0.4.5.1 - Ferry Core Components  http://hackage.haskell.org/package/FerryCore-0.4.5.1 (JeroenWeijers)
02:45:02 <joe6> here are more details on the behaviour: http://hpaste.org/43608/joe
02:45:22 * hackagebot DSH 0.4.0.1 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.4.0.1 (JeroenWeijers)
02:46:00 <joe6> is there a difference between command line options and specifying them on top of the file?
02:48:23 * hackagebot DSH 0.4.2.1 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.4.2.1 (JeroenWeijers)
02:54:47 <joe6> Bynbo7: c_wraith: any more suggestions, please?
02:56:56 <joe6> there is a difference in how a file works with and without the command line -Wall option. Isn't that weird?
02:57:23 <joe6> i get an error using -Wall and it just seems to run fine without it.
02:57:43 <joe6> Doesn't main not get executed when run without the -Wall?
02:58:45 <joe6> or could it be a bug?
03:00:47 <joe6> "main :: IO ()", the "runghc -Wall -fth <filename>.hs" works but "runghc -fth <filename>.hs" does not show the output of  putStrLn "junk" on the command line terminal
03:01:49 <joe6> that is just too basic to not work, unless I am missing something. BTW, the file has "{-# OPTIONS_GHC -Wall -fth #-}" on the top too.
03:18:04 <joe6> this works too: "runghc -cpp -fth compareTestTT.hs"
03:18:14 <shapr> Any thoughts on the JSON libraries available? Any positive experiences?
03:19:58 <shapr> Hackage UI idea: have an "activity" indicator next to the library name green means the lib has been recently updated, or a recently uploaded lib uses this library.
03:22:39 * shapr tries aeson
03:23:58 <geheimdienst> shapr: good idea. wish they would do that.
03:26:34 <ManDay> Can someone tell me what the => op is called?
03:26:46 <ManDay> I tried googling it but without success
03:28:30 <Kaidelong> ManDay: does not look like people use => as an operator anywhere. Do you mean the type context thing in type signatures?
03:29:04 <Kaidelong> "(Enum a, Bounded a, Num a) =>"
03:29:08 <Kaidelong> is a context
03:29:12 <Kaidelong> for a type signature
03:30:00 <Blkt> good day everyone
03:33:40 <ManDay> Kaidelong: perhaps
03:33:56 <Bynbo7> ManDay: that's the only place it's used in haskell
03:33:58 <ManDay> Kaidelong: http://de.wikipedia.org/wiki/Monade_(Typkonstruktion)#Definition
03:34:44 <Kaidelong> ManDay: They are using is in the context sense, there, yes
03:34:56 <ManDay> what does it mean?
03:35:28 <Kaidelong> "this type is only true if the type variables are instances of these classes"
03:35:43 <Bynbo7> :t (+)
03:35:43 <Twey> It means that the type on the RHS is restricted by the classes on the LHS
03:35:44 <lambdabot> forall a. (Num a) => a -> a -> a
03:35:55 <Twey> LTNS, ManDay
03:36:04 <Kaidelong> IE there is no general type "b a -> a"
03:36:06 <Bynbo7> ManDay: that says that (+) can only add things that are instances of the Num class
03:36:06 <geheimdienst> (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c) means that (>=>) is a function with this type (a -> m b) -> (b -> m c) -> (a -> m c)
03:36:18 <Kaidelong> but you can prove "b a -> a" if b is Copointed
03:36:28 <Kaidelong> so you can make a type "(Copoined b) => b a -> a
03:36:32 <geheimdienst> in this type, m must be an instance of the class Monad. a, b, and c are not restricted in this way
03:37:52 <ManDay> geheimdienst: so if I add a   C b =>   before a type specification that simply resstricts one one of the types?
03:37:58 <ManDay> why does inot say
03:38:03 <geheimdienst> yes
03:38:28 <ManDay>  (>=>) :: (a -> Monad b) -> (b -> Monad c) -> (a -> Monad c) instead of  (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
03:38:36 <geheimdienst> i think you'd have to write it in parens: (C b, Monad m) => ...
03:39:03 <Twey> ManDay: Because that would make Monad a type constructor
03:39:18 <Twey> ‘Monad c’ is a type called ‘Monad’ with one argument, ‘c’
03:39:33 <Twey> Rather than any type that happens to be a monad
03:39:48 <geheimdienst> if you have "class Monad m where ...", put it on the left side of the "=>". if you have "instance Something where ...", put it on the right side of =>
03:39:57 <Bynbo7> data Monad a = One a | Two a a
03:40:07 <Twey> Heh
03:40:14 <ManDay> guess i gotta learn more haskell before i understand that
03:40:21 <Bynbo7> hmmmm, could you actually make that a monad? heh
03:40:34 <Twey> I *think* so
03:40:37 <ManDay> is haskell-platform what I want for programming haskell? or is there a lighter version?
03:40:42 <Bynbo7> i guess so, but you'd have to lsoe information
03:40:43 <Twey> return = One
03:40:44 <Bynbo7> lose*
03:40:46 <Twey> Yeah
03:40:53 <Twey> ManDay: Yeah, the Platform's a good starting point
03:40:55 <vegai> ManDay: platform is ghc + some libs
03:41:04 <vegai> lighter version would be just ghc
03:41:11 <ManDay> I'd start with a lightweight setup not a full fledged environment
03:41:13 <vegai> then again, ghc is probably like 90% of the size
03:41:22 <ManDay> is there no single parser like /usr/bin/python ?
03:41:24 <geheimdienst> ManDay: have a look at tryhaskell
03:41:28 <geheimdienst> @where tryhaskell
03:41:28 <lambdabot> http://tryhaskell.org/
03:41:35 <vegai> ManDay: ghci
03:41:37 <Twey> (One v) >>= f = f v
03:41:43 <Bynbo7> join (One (Two x _) = One x; Join (Two (Two x _) _) = One x; join (Two (One x) _) = One x or something
03:41:49 <geheimdienst> also, you can give commands to lambdabot
03:41:52 <geheimdienst> > 3 + 4
03:41:53 <lambdabot>   7
03:41:56 <Twey> (Two a b) >>= f = f a
03:42:04 <geheimdienst> ... even when talking to lambdabot privately
03:42:06 <Twey> Or, you could use mplus or something
03:42:13 <Bynbo7> yeah, to make it useful you
03:42:26 <Bynbo7> you'd probably need monoid a
03:42:29 <Twey> Yeah
03:42:45 <Twey> (Two a b) >>= f = f $ mappend a b
03:43:00 <Bynbo7> so, you get a choice of from 1 to 4 results combined together
03:43:19 <Twey> FSVO ‘useful’ :þ
03:43:25 <Bynbo7> aye :P
03:43:35 <Bynbo7> fun to think about though
03:43:40 <Twey> Aye
03:43:48 <Bynbo7> I've never really thought about defining my own monad, never really had a need
03:43:57 <dafis> (Two a b) >>= f = join (Two (f a) (f b))
03:44:41 <Twey> dafis: Cheating :þ
03:44:48 <dafis> why?
03:44:54 <Twey> join isn't defined
03:45:00 <Twey> Or are you using Bynbo7's?
03:45:04 <dafis> join (One x) = x
03:45:10 <Bynbo7> don't use mine, it sucks
03:45:19 <Bynbo7> well, it may suck
03:45:24 <dafis> join (Two (One x) (One y)) = Two x y
03:45:31 <cheater00> hey guys
03:45:34 <Bynbo7> that's a much better definition
03:45:47 <dafis> join (Two (One x) (Two y _)) = Two x y
03:46:01 <Twey> Ah, you are going to drop information, then
03:46:11 <dafis> join (Two (Two x _) (One y)) = Two x y
03:46:24 <Twey> extract (One x) = x; extract (Two x _) = x
03:46:30 <dafis> join (Two (Two x _) (Two y _)) = Two x y
03:46:44 <Bynbo7> so, you've defined a monad that prefers One's over Two's, and preferrs the left element of Twos
03:46:48 <Twey> join (One x) = x; join x y = Two (extract x) (extract y)
03:46:52 <Bynbo7> poor right elements :(
03:46:57 <jacobian> ;)
03:46:59 <Twey> Is the way to define that without spamming everyone :þ
03:47:15 <dafis> Twey: you *must* drop information when you join three or four values to two or one
03:47:27 <Bynbo7> dafis: not if you can combine them
03:47:29 <Twey> dafis: Not necessarily (see: Monoid)
03:47:33 <geheimdienst> ManDay: btw, i think that wikipedia page you linked to is not very clear ... there's some links to monad tutorials here: http://stackoverflow.com/questions/2366/can-anyone-explain-monads
03:47:47 <Bynbo7> instance Monoid a => Monad Monad where -- heh
03:47:53 <Twey> Hehe
03:48:04 <dafis> Twey: even then, except in very special circumstances you lose information
03:48:26 <kfr> Unused class constraint? Huh
03:48:30 <ManDay> geheimdienst: wikipedia is never clear. its the in the freaking nature of wikipedia articles that you only understand them if you already know what they say
03:48:33 <dafis> Twey: [1 .. 100] is the reult of a `mappend` b. What was a, what b?
03:48:36 <ManDay> bloody rediculous
03:48:39 <Bynbo7> @src Monad
03:48:40 <lambdabot> class  Monad m  where
03:48:40 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
03:48:40 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
03:48:40 <lambdabot>     return      :: a -> m a
03:48:40 <lambdabot>     fail        :: String -> m a
03:48:40 <kfr> ManDay: Lies
03:48:44 <kfr> Also, it's ridiculous
03:48:45 <geheimdienst> manday: that's true :)
03:48:59 <kfr> No, I learned tons of stuff from Wikipedia
03:49:00 <Twey> dafis: Okay, you do lose that information, but you don't lose any of the data
03:49:04 <kfr> I got my degrees that way
03:49:20 <Twey> dafis: And, well, that's a property of the list monoid, isn't it?
03:49:30 <Twey> With e.g. a tree monoid it would be pretty clear
03:49:45 <geheimdienst> We see here, gentlemen, what prolonged exposure to this "Haskell" substance can do to the brain. Grown men giggling at "instance Monoid a => Monad Monad where".
03:49:47 <geheimdienst> ;)
03:49:55 <Twey> Hahaha
03:49:57 <dafis> ManDay: the German wikipedia is not good, if possible, for stuff related to maths/programming/science, use en.wikipedia.org, it's much much much better
03:50:08 <ManDay> dafis: I know I agree
03:50:17 <ManDay> however for the modas I found both versions pretty confusing
03:50:32 <ManDay> mostly because tehy start making allusions to topology and math from the first sentence on
03:50:34 <ManDay> ...and dont stop
03:51:00 <dafis> Twey: Sum Monoid, Product Monoid, Maybe, you usually lose information, just the amount differs
03:51:04 <geheimdienst> monads are a confusing topic. my advice would be to not worry about the theory and start writing haskell code. the understanding will come gradually.
03:51:19 <kfr> dafis: Oh that's interesting, because I frequently ended up using German math articles instead on some stuff
03:51:24 <Twey> dafis: But Monoid doesn't necessarily lose information, itself
03:51:28 <kfr> Because they simply contained much more information
03:51:34 <Bynbo7> ManDay: monads are much easier to use than fully understand
03:51:42 <Twey> Sure, a lot of instances do, but that's not a property of monoids
03:51:47 <dafis> kfr: Oh, I've never seen that
03:51:50 <kfr> But that was simple stuff, basic linear algebra mostly
03:51:51 <ManDay> Bynbo7: i believe it
03:52:05 <kfr> The German articles on basic algebraic structures seemed much more complete and connected
03:52:26 <kfr> http://en.wikipedia.org/wiki/Magma_%28algebra%29
03:52:32 <kfr> http://de.wikipedia.org/wiki/Magma_%28Mathematik%29
03:52:40 <kfr> Look, they got a fancy menu on the side!
03:52:45 <dafis> kfr: I've never looked at those, so that might be
03:52:53 <kfr> Oh but the English one has grown quite a lot
03:52:54 <geheimdienst> (no one needs to understand set theory and Peano whatnot in order to successfully use integers ...)
03:52:55 <kfr> Since I last checked
03:53:01 <kfr> There's a menu down there and lots of examples now
03:53:07 <Bynbo7> i learnt about magma yesterday, seems like a horrible things to have released on the world
03:53:11 <joe6> guys: can you please help? I am not sure what more I can do. I am using template haskell and "ghci -fth <file.hs>" works and "ghci <file.hs" does not work. In the file.hs, the second line has the language pragma with TemplateHaskell turned on.
03:53:25 <joe6> I cannot seem to find anything on the -fth flag
03:53:27 <Bynbo7> oh, i meant the software magma
03:53:28 <kfr> Bynbo7: Well, it's just a less specialised version
03:53:30 <kfr> Oh.
03:53:52 <joe6> even the manual does not seem to have details on it, unless I am looking in the wrong place.
03:54:00 <joe6> Can anyone please help?
03:54:23 <maxJadi> Hi, I got an error for pattern matching for this recursive function "fun _ [] = False    fun x (x:xs) = true     fun y (x:xs) = fun y xs"  and error is "Conflicting definitions for `x'    Bound at: t.hs:6:4             t.hs:6:7    In the definition of `fun'" any idea? 
03:54:28 <Bynbo7> maybe try #ghc joe6 
03:54:51 <Bynbo7> ManDay: you can't bind the same name twice in your patterns
03:54:51 <geheimdienst> joe6: if nobody in here has any ideas on your problem, try #ghc or emailing haskell-cafe maybe
03:54:57 <dafis> maxJadi: you can use each variable only once in a pattern
03:55:02 <Bynbo7> maxJadi, not ManDay 
03:55:03 <ManDay> Bynbo7: huh?
03:55:07 <ManDay> k
03:55:30 <joe6> geheimdienst: Bynbo7: thanks, guys. That is a very good idea. I was getting desperate.
03:55:43 <geheimdienst> Bynbo7: but technically you were correct. manday won't be able to bind the same name name twice, either
03:55:45 <geheimdienst> ;)
03:55:51 <Bynbo7> sure
03:55:54 <j-invariant> how do I get random sets out of   list?
03:55:59 <dafis> maxJadi: fun x (y:zs) = (x == y) || fun y zs
03:56:14 <Bynbo7> dafis: that's not the same thing...
03:56:19 <Bynbo7> are you trying to use guards?
03:56:20 <j-invariant> e.g. f [1..100] = [2,25,56]
03:56:39 <Bynbo7> j-invariant: you can't get actually random sets from a list i a pure way
03:56:46 <dafis> Bynbo7: I think that is what maxJadi wants to do
03:56:55 * hackagebot snap-server 0.3.1.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.3.1.1 (GregoryCollins)
03:56:58 <j-invariant> how
03:57:15 <Bynbo7> dafis: oh right, forget the first clause
03:57:23 <dafis> at least, usually when people try to bind the same variable twice in a pattern, they want to indicate that those arguments are the same
03:57:53 <ManDay> #gentoo has just proposed me 700 megabytes as the "haskell base package" - do you have any lighter suggestions?
03:58:52 <geheimdienst> manday, you know tryhaskell.org? and lambdabot in this channel
03:59:01 <geheimdienst> for getting your feet wet
03:59:08 <ManDay> geheimdienst: i appreciate it but I think it should be just a little heavier than that
03:59:28 <ManDay> the tryhaskell.org console gives me weird utf-8 characters in the middle of my commands btw
03:59:32 <dafis> ManDay: get a vanilla linux binary of ghc
03:59:53 <ManDay> i d like ghci standalone if thats possible
04:00:03 <ManDay> no libraries needed whatsoever, is that possible?
04:00:11 <dafis> ManDay: no, can't have it without GHC
04:00:21 <ManDay> ok thanks
04:00:32 <dafis> and you need base and a few others anyway
04:00:43 <geheimdienst> but you can have ghc without the rest of the haskell platform
04:00:46 <dafis> ManDay: you could try hugs, much smaller than GHC
04:00:53 <geheimdienst> (ghc includes ghci)
04:00:56 <j-invariant> How do you get random sets of primes
04:01:33 <ManDay> j-invariant: what do you consider randomly distributed primes?
04:01:45 <j-invariant> anything
04:01:52 <ManDay> ok
04:01:55 <dafis> j-invariant: (pseudo) random bases for Miller-Rabin?
04:01:59 <ManDay> 1 5 7 3
04:02:01 <ManDay> your welcome
04:02:09 <dafis> ManDay: 1 is not a prime
04:02:10 <j-invariant> this chan is full of trolls
04:02:14 <ManDay> damn ^^
04:02:23 <ManDay> j-invariant: my original question was meant seriously
04:02:32 <j-invariant> trols
04:02:53 <Bynbo7> j-invariant: if you want help from people, why do you insist on not helping them help you?
04:03:12 <j-invariant> haskell is taking up all my memrory and freezing my computer 
04:03:24 <dafis> j-invariant: get a pseudo-random-generator and generate a number of indices, then pick the primes at those indices
04:03:59 <ManDay> dafis: that would probably not the random distrivbution he needs
04:04:06 <ManDay> given that primes get sparer at higher numbers
04:04:22 <j-invariant> I need haskell to stop taking upp too much memory
04:04:22 <dafis> ManDay: we have absolutely no idea what (s)he needs
04:04:28 <j-invariant> it needs a limit on memory and CPU
04:04:31 <HugoDaniel> i deeply hate cabal :(
04:04:35 <Bynbo7> j-invariant: write programs that don't use so much memory then
04:04:40 <HugoDaniel> i also hate parsec :(
04:04:48 <dafis> j-invariant: +RTS -M2M
04:04:50 <ManDay> dafis: hencei  was asking, but i assume its plausible to expect primes that are randomly distributed throughout the space of natural numbers
04:04:51 <maxJadi> dafis, I am nob in haskell and  I think like Erlang :) thanks it works :D
04:04:56 <j-invariant> dafis: what file can I put that in
04:05:14 <Bynbo7> j-invariant: you call your programs with those flags
04:05:23 <HugoDaniel> ive been doing haskell for 2 years, and parsec and cabal keeps on hurting me...
04:05:24 <Bynbo7> ./foo<args +RTS -M2M
04:05:26 <HugoDaniel> what a fail :/
04:05:27 <dafis> j-invariant: not in a file, on the command line when you run the programme
04:05:30 <cheater00> hey guys, i'm tyring to translate a simple one-liner from python to haskell but i'm having a bit of a problem. i'm not sure why that is. the original python code is: f = lambda l: reduce(lambda z, x: z + [y + [x] for y in z], l, [[]])         and my guess at haskell code is: f l = foldl (\z x -> z ++ [y ++ [x] | y<-z]) [[]] l           however, in python f([1, 1]) ---> [[], [1]]    whereas in haskell f [1, 1] ---> [[], [1], [1], [1, 1]]
04:05:34 <j-invariant> I want it to be permanent
04:05:46 <j-invariant> cant I put in a config file
04:05:47 <dafis> HugoDaniel: what's the problem?
04:05:51 <j-invariant> pleaese
04:06:27 <HugoDaniel> cabal: Codec.Compression.Zlib: premature end of compressed stream
04:06:29 <HugoDaniel> this
04:06:33 <HugoDaniel> i dont even know what this is...
04:06:34 <Bynbo7> cheater00: you'll need to paste that code somewhere where we can read it
04:06:37 <accel> haskell supports prefix + infix; is there a way to make an opeator postfix?
04:06:40 <HugoDaniel> ...the same problems on and on
04:06:52 <dafis> j-invariant: you can alias your programme to proggy +RTS -M16M -RTS
04:06:56 <Bynbo7> accel: google is your friend
04:06:58 <cheater00> Bynbo7: that's all there is
04:07:11 <Bynbo7> cheater00: please paste it so it's easier to read...
04:07:12 <dafis> HugoDaniel: Windows?
04:07:13 <cheater00> Bynbo7: are you saying it's unreadable for you? i can paste it in
04:07:14 <cheater00> ok
04:07:15 <j-invariant> Heap exhausted;
04:07:15 <j-invariant> Current maximum heap size is 15998976 bytes (15 MB);
04:07:15 <j-invariant> use `+RTS -M<size>' to increase it.
04:07:18 <HugoDaniel> dafis, fedora 14
04:07:23 <j-invariant> I dnd't even run a progrm yet LOL
04:07:28 <j-invariant> haskell takes 15 MB to do NOTHING
04:07:38 <Bynbo7> haskell doesn't take anything
04:07:45 <j-invariant> great that works thanks
04:07:59 <j-invariant> how do I set it so that ghci +RTS -M50M -RTS
04:08:02 <j-invariant> always hnappens
04:08:20 <j-invariant> I want to set this as deafult
04:08:29 <dafis> HugoDaniel: hmm, never heard of that on linux yet.
04:08:43 <HugoDaniel> dafis, yeah... :/
04:08:56 <HugoDaniel> makes me wanna try to do a package manager
04:09:22 <cheater00> ah, nm, just figured it out :D
04:09:44 <cheater00> thanks though!
04:10:04 <accel> http://www.haskell.org/ghc/docs/6.12.3/html/users_guide/syntax-extns.html makes no sense; how do I use arbitrary postfix operators?
04:12:20 <Bynbo7> accel: of course it makes sense, people make sense of it all the time
04:12:22 <Maxdamantus> > let (0!) = 1; (n!) = n * ((n-1)!) in (4!)
04:12:23 <lambdabot>   <no location info>: Parse error in pattern
04:12:44 <accel>  /ignore Bynbo7 
04:12:57 <Bynbo7> ouch
04:12:58 <Maxdamantus> > let (!) 0 = 1; (!) n = n * ((n-1)!) in (4!)
04:12:59 <lambdabot>   24
04:13:29 <accel> > let postfix-add x y = x + y; in 2 3 postfix-add
04:13:30 <lambdabot>   <no location info>: Parse error in pattern
04:13:36 <accel> Maxdamantus: is there a way to make the above work ?
04:13:39 <j-invariant> why are peple here so obnoxious
04:13:42 <accel> > let postfix-add x y = x + y; in (2 3 postfix-add)
04:13:43 <lambdabot>   <no location info>: Parse error in pattern
04:13:43 <Maxdamantus> postfix minus add?
04:13:50 <accel> > let postfix_add x y = x + y; in (2 3 postfix-add)
04:13:51 <lambdabot>   Not in scope: `postfix'Not in scope: `add'
04:13:52 <accel> > let postfix_add x y = x + y; in (2 3 postfix_add)
04:13:53 <lambdabot>   2
04:14:02 <accel> wtf, taht is wrong
04:14:14 <Maxdamantus> > 2 3
04:14:14 <lambdabot>   2
04:14:19 <Maxdamantus> > 2 undefined
04:14:20 <lambdabot>   2
04:14:23 <shapr> j-invariant: be nice
04:14:30 <j-invariant> shapr: tell that to the other people
04:14:31 <Maxdamantus> > fix 2
04:14:32 <lambdabot>   2
04:14:46 <shapr> j-invariant: From my viewpoint, it appears that you are the one being difficult.
04:15:01 <ManDay> > let x y padd = x + y in 2 3 padd
04:15:02 <lambdabot>   Not in scope: `padd'
04:15:09 <ManDay> worth a try :P
04:15:17 <j-invariant> shapr: read what happened earleir
04:15:23 <shapr> j-invariant: I did.
04:15:52 <j-invariant> why this channel is so unwelcoming?
04:16:03 <shapr> j-invariant: Because you're trying to get other people to do your work for you.
04:16:11 <j-invariant> such as
04:16:25 <Bynbo7> j-invariant: it's usually very welcoming, but you're acting in a way that is very frustrating to people who are trying to help you
04:16:36 <shapr> """<j-invariant> haskell is taking up all my memrory and freezing my computer """
04:16:48 <Bynbo7> in fact, this channel is known for how helpful it is to people
04:16:56 <j-invariant> so?
04:17:05 * dafis wonders whether j-inv's last name is harrop
04:17:08 <shapr> """ <j-invariant> this chan is full of trolls """
04:17:09 <Bynbo7> accel: what don't you understand about the docs for postfix operators?
04:17:13 <j-invariant> shapr: why did I say that
04:17:23 <ManDay> good question
04:17:24 <accel> Bynbo7: so basically it can only take one argument?
04:17:28 <j-invariant> because everyone is making fun of what I asked
04:17:32 <Bynbo7> accel: yes
04:17:47 <shapr> j-invariant: Have you read the book "Real World Haskell" ?
04:17:51 <j-invariant> no
04:17:52 <ManDay> j-invariant: i for my part asked you as imple question you still havent replied to
04:18:11 <fryguybob> > let postfixadd x = \y -> x + y in (3 `postfixadd`) 2
04:18:12 <lambdabot>   5
04:18:28 <ManDay> fryguybob: that aint postfix eh
04:18:29 <shapr> j-invariant: The book will not sound like a troll: http://book.realworldhaskell.org/
04:19:08 <shapr> j-invariant: The #haskell irc channel is a community that freely shares knowledge when asked answerable and informed questions.
04:19:30 <j-invariant> how do I determine whether a turing machine halts
04:19:32 <shapr> j-invariant: So far, your questions are overly general, highly emotional, and imply that you need novice instruction.
04:19:43 <shapr> j-invariant: Use the Busy Beaver approach, or don't.
04:19:58 <shapr> j-invariant: Read wikipedia's page about the halting problem.
04:20:24 <j-invariant> shapr: is there a computable function which is bigger than busy beaver function?
04:20:29 <shapr> j-invariant: So, you can either be nice, and people will start answering your questions, or you can continue with your current approach and you will be banned.
04:21:09 <j-invariant> shapr: why dont you ban the cause of theproblem instead
04:21:35 --- mode: ChanServ set +o shapr
04:21:40 --- kick: j-invariant was kicked by shapr (Kicked by shapr)
04:21:45 <dafis> ouch
04:21:48 <shapr> bzzt, wrong answer n00b
04:21:54 <fryguybob> shapr++
04:22:02 <Bynbo7> jmvanel: he's been doing it for the past fortnight
04:22:06 * accel didn't realize shapr had ops; updates list of ppl to not annoy
04:22:31 <accel> Bynbo7: do you have ops too?
04:22:38 * fryguybob thinks accel should put everyone on that list.
04:22:39 <Bynbo7> accel: you know, a better approach would be to aim to not annoypeople at all
04:22:44 <quicksilver> you should behave as if everyone is an op ;)
04:22:58 <Bynbo7> all ops are ninjas in here
04:22:59 <dafis> except you
04:23:18 <shapr> but also realize that the ops wish for this community to stay welcoming and helpful
04:23:23 <dafis> that was supposed to be an addendum to quicksilvers remark
04:23:30 <shapr> and people who act like j-invariant will be removed
04:23:33 <ManDay> lol accel Bynbo7 
04:24:50 <Bynbo7> i'm starting to see what channels like C end up they way they have when they're popular enough...
04:26:25 <ManDay> i find ##c quite civilized
04:26:36 <ManDay> as opposed to my impression of #haskell so far ;P
04:26:48 <Bynbo7> there's been quite a few people in here complaining about it recently
04:26:59 <ManDay> about ##c ?
04:27:05 <Bynbo7> ManDay: yeah, you haven't seen a typical #haskell day
04:27:09 <Bynbo7> yes
04:27:13 <ManDay> Bynbo7: it can onyl get better ;>
04:27:21 <accel> all I wish of haskell 
04:27:26 <Bynbo7> it's usually very peaceful, and extremely helpful in here
04:27:29 <accel> is that it remains helpful until I learn haskell; then ti beomes like ##c
04:27:37 <shapr> j-invariant: So, you can see that some behaviour gets you removed from this community.
04:27:45 <j-invariant> shapr: can I show you somethign please
04:27:45 <shapr> j-invariant: a kick is a warning
04:27:50 <cheater00> i like #haskell
04:27:52 <shapr> j-invariant: No, but you can ask questions.
04:28:01 <cheater00> and every time i come here i get help
04:28:06 <j-invariant> shapr can you considre this? http://hpaste.org/43613/j
04:28:07 <Bynbo7> accel: well, you haven't exactly been helping keep it peaceful imo
04:28:09 <cheater00> so, no complaints on my end
04:28:19 <shapr> j-invariant: Before I look at your paste, what is your question?
04:28:36 <j-invariant> do you think that is fair treatment
04:28:43 <accel> Bynbo7: how have my questions been bad?
04:29:09 <shapr> j-invariant: Er, do you have a question about Haskell?
04:29:18 <Bynbo7> j-invariant: you asked a question, and ManDay tried to help you by asking you to give more more information, and you were extremely unhelpful by replying 'anything'. what more do you want in that case?
04:29:41 <accel> Can Haskell GADTs solve NP complete problems at compile time?
04:30:03 <ManDay> jeez could we please get off that emotional whaa-whaa - youre behaving like you have your period j-invariant 
04:30:07 <ManDay> we want to help you
04:30:07 <shapr> j-invariant: I would strongly suggest that you read the free online book "Real World Haskell"
04:30:12 <ManDay> now get to the question already
04:30:16 <shapr> ManDay: Hey, be nice... 
04:30:20 <shapr> We all gotta be nice.
04:30:21 <Bynbo7> accel: well,personally I've been annoyed by you seeming unwillingness to learn the basics of haskell before asking about quite advanced features, and getting annoyed when you don't understand the answers you get, because you don't understand the basics of haskell
04:30:43 <accel> So basically because I'ms tupid.
04:30:44 <Bynbo7> your*
04:30:49 <Bynbo7> so, not at all
04:30:57 <j-invariant> shapr: I don't want to read it
04:31:04 <Bynbo7> in fact, it's probablly annoying me most because eI can tell you're quite intelligent accel 
04:31:18 <j-invariant> it's about JSON and stuff
04:31:38 <Obvious> > let infixl 9 $>; ($>) a b = b a; in [1..5] $> map (1+) $> map (1+)
04:31:38 <lambdabot>   [3,4,5,6,7]
04:31:44 <accel> Bynbo7: silver tongue; you should consider being a politician or a lawyer
04:31:51 <dafis> j-invariant: perhaps learn you a Haskell is more to your taste?
04:32:01 <shapr> j-invariant: It seems to me that you have some reason that you wish to learn Haskell and some programming language theory.
04:32:02 <j-invariant> dafis: yes I have read that bookk
04:32:03 <dafis> j-invariant: or yaht?
04:32:06 <j-invariant> its my favorite
04:32:10 <dafis> @where yaht
04:32:10 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
04:32:30 <Bynbo7> accel: i mean it. if you didn't have brains, you wouldn't be interested in why things don't work like you expect they do. but you need to put some effort in, so that you've got the base level understanding needed for us to answer your questions
04:32:50 <j-invariant> shapr: I just wanted to calculate something on prime numbers I don't awnt programming language theory
04:32:57 * frerich loves it how he read only 4 chapters of RWH and already looks at Python code or C++ code thinking "hmm this would be really easy with Haskell lists"
04:33:00 <j-invariant> shapr: i got it by now
04:33:06 <kfr> 404
04:33:31 <j-invariant> nobody is talking to me in #haskell-ops
04:33:33 <dafis> kfr: on what?
04:33:37 <kfr> dafis: PDF
04:34:02 <dafis> kfr: I think darcs.h.o is down
04:34:03 <Bynbo7> j-invariant: you're talking to a #haskell op
04:34:14 <kfr> frerich: Nice, one year from now you will have lost all interest in actually programming things and you'll just sit on IRC arguing about category theory
04:34:29 <kfr> dafis: It does reply :o
04:34:34 <kfr> It just says 404
04:34:37 <jacobian> kfr: :) 
04:34:39 <koala_man> haha
04:35:03 <accel> frerich: haskell has had a similar effect on me; I have no motivation to code in other langauges; when I'm lookign at haskell, i ask why no macros? when I look at lisp, I think why can't I have types; in the end, I don't code and just annoy ppl on irc
04:35:27 <jacobian> I don't miss macros that much in haskell. 
04:35:30 <kfr> accel huh? Lisp has types
04:35:31 <dafis> kfr: 5 packets transmitted, 0 received, 100% packet loss, time 4014ms
04:35:40 <accel> kfr: err, static type checking I meant
04:35:40 <jacobian> I was trying to make a foreach yesterday though, and name binding looks a bit ugly 
04:35:46 <kfr> dafis: Ping doesn't tell you anything :o
04:35:49 <jacobian> foreach list (\ x -> foo)
04:36:07 <kfr> accel: CL has facilities for statically defining the type of arguments of functions at least
04:36:12 <dafis> jacobian: flip map?
04:36:24 <jacobian> dafis: flip mapM_
04:36:25 <kfr> The requested URL /yaht/yaht.pdf was not found on this server.
04:36:25 <kfr> Apache/2.2.9 (Debian) mod_python/3.3.1 Python/2.5.2 Server at darcs.haskell.org Port 80
04:36:34 <kfr> That's not what you get when a server is down :p
04:36:37 <dafis> jacobian: 'tis forM_
04:36:44 <dafis> from Control.Monad
04:36:49 <jacobian> doh!
04:37:31 <jacobian> Previously I wasn't using an imperative style for my toplevel loop, but it is much more readable with while and foreach
04:37:53 <aavogt> accel: types stop you from doing things (or make for awkward workarounds)
04:37:54 <jacobian> Also, my foreach was more natural with a break, so I added a break function to throw out of the loop
04:38:08 <accel> aavogt: variants solve most of those problems
04:38:21 <accel> aavogt: I feel like when I look at a piece of code, and can't tell the type of the varaibles, it annoys me
04:38:30 <jacobian> foreach l f = mapM_ l f `catch` \ e :: ForBreakException -> return ()
04:38:32 <aavogt> accel: hmm? Heterogenous lists are pretty bad
04:39:09 <accel> aavogt: But I never use arbitrary Heterogenous lists, it's generally lists of a few types
04:39:36 <accel> then I jsut do a data ... = ... | ... | ...
04:39:40 <jacobian> If you are using arbitrary heterogeneous lists, how can you know what you're getting out? 
04:39:53 <aavogt> well it's still awkward because you need to remove the tags
04:39:53 <jacobian> I've found a lot of the type freedom in lisp just ends up being buggy 
04:39:55 <accel> and make a list of that data type
04:40:27 <aavogt> jacobian: when you map functions on the list, all elements need to have instances in class that defines the function you're mapping
04:40:50 <accel> I feel like I would much rather have a type system that defaults to "you can't do shit", then gradually list the valid operators I'm allowed to do (haskell style); rather than the lisp style of allowing anything ... then having lots of checks / unit tests
04:41:11 <aavogt> jacobian: while it's possible to do, it's not very concise
04:41:23 <jacobian> accel: I agree, though I've come around to that position
04:41:30 <aavogt> ordinary functions become a class + instance
04:41:49 <aavogt> or an instance for each type you like to apply it at
04:42:22 <jacobian> Are you thinking of for instance using generic functions over a list? 
04:42:29 <accel> jacobian: beliving types = good thing has been the hardest thing for me to accept; since I've always prefeerred Lisp co C++/Java typing; it's only ocaml/haskell that's amde me realize "oh shit, that's how type systems are supposed to work"
04:42:33 <jacobian> I don't think that saves you much over having a typeclass. 
04:43:08 <jacobian> accel: Same path that I went through it sounds like
04:43:09 <aavogt> jacobian: you have a list like    (a,(b,(c,(d,()))))))
04:43:22 <aavogt> all the letters there may be different types
04:43:27 <aavogt> polymorphic or whatever
04:43:49 <jacobian> polymorphism means ignorance :) 
04:43:50 <kfr> I'm not pleased with the IO thing in Haskell really, I'd prefer it if a () function could perform IO
04:44:15 <accel> anyone interested in applying to YCombinator together?
04:44:15 <frerich> kfr, accel: Hehe, no. I've been programming for 15 years and every now and then something fancy comes around which makes me wonder why things are so difficult in $WHATEVER_IM_USING_RIGHT_NOW. If you allow that something supposedly 'clean' or 'pure' or 'elegant' or whatever to stop you from writing code in 'imperfect' languages, then something went really wrong. The whole purpose of languages is to make computers
04:44:15 <frerich>  do stuff (and in my case, to pay the rent ;-)
04:44:16 <Bynbo7> kfr: () isn't a function... what?
04:44:23 <accel> anyone interested in applying to YCombinator together? I want to build social games.
04:44:28 <kfr> Bynbo7: I'm talking about the return type
04:44:30 <kfr> IO () vs. ()
04:44:38 <aavogt> actually I lied, HList style you write     data F = F; instance Apply F a b where apply F x = y :: b -- obviously y is more complicated
04:44:40 <Bynbo7> kfr: how would that be pure?
04:44:47 <aavogt> then  hMap F list
04:45:06 <kfr> Bynbo7 it wouldn't be :o I don't care about purity
04:45:13 <aavogt> jacobian: I don't understand
04:45:13 <kfr> In my own languages I never made  distinction there
04:45:16 <Botje> HEATHEN!
04:45:16 <Bynbo7> then go use ocaml ;)
04:45:19 <kfr> made a distinction there*
04:45:39 <shapr> kfr: You could use unsafePerformIO, but it will cause you problems at some point down the line.
04:45:43 <jacobian> aavogt: polymorphism in a type means ignorance of what that type is.  You can't look inside it. 
04:45:54 <kfr> shapr yes, you are obviously not supposed to do that in Haskell
04:45:57 <aavogt> no, it means you don't decide exactly what it is at that point
04:45:58 <accel> f :: IO SomeType <-- is this the same as a _pure_ function World -> (World, SomeType) ?
04:46:22 <Bynbo7> accel: you can think of it that way
04:46:28 <kfr> accel in theory yes, but the entire operating system and the hardware would have to be part of it then
04:46:37 <aavogt> but constraints from elsewhere, such as the function consuming that value will pick a concrete type
04:46:49 <kfr> Which is problematic for the semantics of a single program :p
04:47:02 <kfr> Botje: Was that directed at me?
04:47:15 <accel> Bynbo7 , kfr : so I can think of "IO SomeType" functions as _pure_ functions; but can only be applied magical functions that has access to the World function ?
04:47:25 <Botje> yes :P
04:47:47 <dafis> aavogt: without types, isn't there an enormous risk of "I don't know wtf I should do with this kind of value, I'm outta here!"?
04:47:47 <Bynbo7> accel: that's how its modelled in ghc anyway
04:48:28 <aavogt> jacobian: maybe you're confusing the use of -XExistentialQuantification (but even then you can find out what the types are... it's just not distinguished by the ghc)
04:48:38 <aavogt> dafis: head?
04:49:06 <kfr> Botje: Heathen is a pejorative term coined and used by European Christians to refer to non-Judeo-Christians, primarily adherents of pre-Christian Indo-European religions. So you're not only insulting me by basically using a religious N-word but also by implying that I'm a theist :|
04:49:09 <dafis> aavogt: yes, but aren't the possibilities without types infinitely more?
04:49:38 <dafis> kfr: In my book, christians are heathens
04:49:43 <jacobian> aavogt: [a] as a type tells you nothing about a, and you can't do anything with a except that you have things that work with an a.  It means that as the implementor, you are ignorant of a.  
04:49:50 <j-invariant> christianity is a myth
04:49:59 <j-invariant> no evidence for  god exists
04:50:12 <Bynbo7> j-invariant: see, now you're just trolling
04:50:15 <kfr> dafis: Then that is unrelated to the regular use
04:50:57 <dafis> kfr: polytheists, fairly commonly called heathens
04:50:59 <aavogt> jacobian: sure, call that parametricity (but it's somewhat broken considering seq)
04:51:13 <shapr> Religious topics are best moved to #haskell-blah
04:51:16 <kfr> dafis: By whom?
04:51:18 <j-invariant> 13:07 <@shapr> Religious topics are best moved to #haskell-blah
04:51:28 <j-invariant> hes only saying that because I tried to joni in this discussino
04:51:35 * frerich suggests that all the pseudo-philosophical and generic language ranting is moved to #haskell-cafe or so.
04:52:16 <Bynbo7> quicksilver: are you around?
04:52:25 <quicksilver> Bynbo7: no
04:52:45 <quicksilver> ok, maybe a bit ;)
04:52:47 <kfr> Wait, so is it #haskell-cafe or #haskell-blah?
04:52:50 <Bynbo7> :)
04:52:52 <kfr> How confusing!
04:52:57 <dafis> kfr: -blah
04:53:05 <Wooga> am i doing eveyrthing right here: http://paste.pocoo.org/show/332080/ when trying to pass result of first iteratee to the next one ?
04:53:07 <Bynbo7> haskell-café is the mailing list, #haskell-blah is the irc channel
04:53:11 <kfr> Oh, ok
04:53:16 <Wooga> also, how do i combine Iteratee and Maybe monads?
04:53:28 <Wooga> to get Nothing if left iteratee finished with Nothing
05:03:47 <edwardk> preflex: xseen ddarius
05:03:48 <preflex>  ddarius was last seen on freenode/#haskell 5 hours, 20 minutes and 21 seconds ago, saying: ksf_: The only reason it catches the other ones is because it is free to do so.  This feature wasn't added to be helpful.
05:05:02 <j-invariant> why does haskell take 1000MB to produce [(2,1),(2,1),(7,1),(61,1),(2286373,1)] using GCD and prime factors?
05:05:10 <edwardk> wooga: rolling your own iteratee type?
05:05:15 <j-invariant> that seems like a lot to me but I could be wrong
05:05:31 <Wooga> edwardk: no, just trying to understand how iteratee works
05:05:44 <j-invariant> isPrime 2286373 happens almost instantly
05:05:46 <Bynbo7> j-invariant: we'd need to see the code to be able to tell you, could you perhaps paste it on hpaste?
05:05:52 <dafis> j-invariant: that's a lot, probably your code does something unbecoming
05:05:53 <edwardk> wooga: i have some slides on a slight variant on them that might be helpful
05:05:58 <j-invariant> unbecoming?
05:06:04 <j-invariant> yeah
05:06:05 <Bynbo7> @where hpaste
05:06:05 <lambdabot> http://hpaste.org/
05:06:13 <quicksilver> j-invariant: where does the 1000MB come from?
05:06:20 <j-invariant> ghci +RTS -M1000M -RTS
05:06:26 <j-invariant> I have tried smaller sizes
05:06:32 <quicksilver> and with smaller sizes it just dies?
05:06:35 <j-invariant> yes
05:06:40 <quicksilver> that does seem a lot, yes ;)
05:06:41 <Bynbo7> j-invariant: can we see the code?
05:06:46 <dafis> j-invariant: paste the code, please
05:06:59 <quicksilver> seems like you're probably keeping some very large datastructure in memory
05:07:06 <j-invariant> import Data.Numbers.Primes
05:07:08 <j-invariant> I don't trust ^
05:07:13 <Wooga> edwardk: let me guess, http://okmij.org/ftp/Haskell/Iteratee/DEFUN08-talk-notes.pdf ?
05:07:23 <edwardk> wooga: http://comonad.com/reader/2009/iteratees-parsec-and-monoid/ — the second set of slides gives some introductory material on iteratees
05:07:38 <quicksilver> > 2286373 * 24 `div` (1024 * 1024)
05:07:39 <edwardk> and then builds a version using a fingertree to hold all the seen chunks
05:07:39 <lambdabot>   52
05:07:51 <quicksilver> 52 MB for a list from [0..2286373], roughly
05:07:52 <edwardk> wooga: nah, i'm not oleg =)
05:07:56 <quicksilver> that's not a very big chunk of 1000MB
05:08:00 <quicksilver> definitely something odd going on.
05:08:09 <j-invariant> gchi takes 50 MB to just load my program
05:08:11 <Wooga> edwardk: thank you!
05:08:23 <Bynbo7> j-invariant: can we please see your program?
05:08:40 <edwardk> wooga: i think there happens to be a typo in the range of stuff you're interested in so be warned. at least one line there fails to type check ;)
05:08:50 <edwardk> but i think the fix was obvious
05:09:33 <pozic> j-invariant: that by itself is not weird.
05:10:17 <dafis> j-invariant: Data.Numbers.Primes is not particularly efficient (neither time nor memorywise), but I see no reason why it should be so bad
05:10:18 <shapr> Botje: Still interested in lots of Cell processors? for a Haskell-related project prehaps?
05:10:35 <Bynbo7> shapr: i am...
05:11:03 <shapr> Bynbo7: Got an interesting and Haskell-related use for 'em?
05:11:22 <pozic> How much is lots?
05:11:37 <Bynbo7> sure, an accelerated array computation library using LLVM to jit compile operations on arrays
05:12:25 <shapr> pozic: I have a system that can run six QS20 dual-Cell (all 8 SPUs, no hypervisor) blades.
05:13:16 <pozic> shapr: you own that personally?
05:13:17 <shapr> I actually have eight blades, but one or two them are acting weird, and I'd really like to keep two x86 blades active.
05:13:41 <shapr> pozic: yes - http://picasaweb.google.com/shae.erisson/UbuntuOnMyBladeCenter# note the pic of edwardk in that album :-P
05:13:55 <pozic> shapr: that just gets you so many geek points ;)
05:14:15 * shapr grins
05:14:27 <Bynbo7> i dunno, we all know what ubuntu means :P
05:15:06 <maxJadi> Any idea how I can get nth element of list like "[a,b,c,d] getting second element 'b'" I could not find it at Data.List module?
05:15:26 <dafis> maxJadi: (!!)
05:15:31 <dafis> :t (!!)
05:15:32 <lambdabot> forall a. [a] -> Int -> a
05:15:40 <sipa> long answer: (!!)
05:15:42 <dafis> > [1 .. 10] !! 1
05:15:43 <lambdabot>   2
05:15:43 <sipa> short answer: don't
05:15:49 <sipa> oh wait...
05:16:05 <pozic> shapr: http://picasaweb.google.com/shae.erisson/UbuntuOnMyBladeCenter#5337025393003819410
05:16:09 <pozic> shapr: are you that guy?
05:16:38 <shapr> pozic: Yes, that's me.
05:19:02 <maxJadi> dafis, It seems (!!) is on Data.List manual page, thanks :)
05:19:52 <dafis> maxJadi: be aware that indices start from 0
05:20:02 <accel> woot, starting chapter 5 of haskell SOE
05:20:09 <Bynbo7> SOE?
05:20:26 <dafis> School of Expression, Hudak
05:22:02 <Botje> shapr: i don't think it'll be for haskell
05:22:22 <accel> how do I have a module _not_ include Prelude ?
05:22:26 <Botje> shapr: but i can probably persuade the parallel programming guys to sponsor your electricity bill in exchange for access
05:22:50 <Eduard_Munteanu> accel: NoImplicitPrelude extension
05:22:54 <dafis> accel: {-# LANGUAGE NoImplicitPrelude #-} if you're going for extremes
05:23:11 <accel> I stick this in Chap5.hs ? (it shows how to define thigns like length/head/tail)
05:23:30 <Eduard_Munteanu> accel: you should probably just use other names.
05:23:42 <Wooga> like length', head' or tail'
05:23:44 <dafis> accel: for such, it's better to "import Prelude hiding (length, take, tail, head)
05:23:45 <shapr> Botje: I can do that.
05:23:47 <Eduard_Munteanu> Like soeLength, soeTail etc.
05:24:04 <accel> {-# LANGUAGE NoImplicitPrelude #-}
05:24:06 <accel>     Cannot parse LANGUAGE pragma
05:24:06 <accel>     Expecting comma-separated list of language options,
05:24:07 <accel>     each starting with a capital letter
05:24:07 <accel>       E.g. {-# LANGUAGE RecordPuns, Generics #-}
05:24:34 <dafis> accel: huh?
05:24:47 <accel> i'm getting a compile error
05:24:50 <Eduard_Munteanu> What compiler and version is that?
05:24:52 <dafis> what compiler?
05:24:56 <accel> ghc 6.12
05:25:03 <Eduard_Munteanu> Strange.
05:25:07 <dafis> very
05:25:29 <Eduard_Munteanu> accel: does -XNoImplicitPrelude on ghc's cmdline work?
05:25:50 <accel> ah; it works now
05:25:53 <accel> i'm being an idiot :-)
05:26:01 <Eduard_Munteanu> What was wrong?
05:26:28 <accel> Eduard_Munteanu: I stuck it before the module
05:26:37 <accel> whereas it needs to be after eh module (...) where it appears
05:26:37 <earthy> ah
05:27:08 <earthy> that doesn't seem right though
05:27:51 <dafis> accel: language pragmas must go befor the 'module'
05:29:15 <accel> Looking at map; I see the type as: "(a->b)->[a]->[b]"; why does ahskell show it as "forall a b. (a->b)->[a]->[b]"
05:29:42 <quicksilver> the forall a b. part is mathematical notation
05:29:46 <earthy> because the forall is implicit in Haskell'98
05:29:47 <dafis> hmm,  ghc-6.12.3 --supported-languages | grep relude
05:29:47 <dafis> ImplicitPrelude
05:29:47 <quicksilver> which is used by GHC as an extension
05:30:14 <dafis> 6.12 doesn't understand NoImplicitPrelude?
05:30:27 * edwardk looks up at the mention of shapr's homegrown supercomputer.
05:30:38 <Eduard_Munteanu> Isn't the 'No' prefix "special"?
05:30:43 <accel> shapr: you have your own private super compuer?
05:31:17 <dafis> oh, it does, phew
05:31:55 <Eduard_Munteanu> -XNoGADTs also seems to "work" :)
05:32:06 <Eduard_Munteanu> So I guess it's special.
05:32:21 <mm_freak> accel: it doesn't show the "forall", unless you add some certain flags like -fglasgow-exts
05:32:31 <edwardk> > 14*2 + 8*7*2
05:32:32 <lambdabot>   140
05:32:33 <dafis> Eduard_Munteanu: I think it understands -XLanguage and -XNoLanguage for all admissible values of Language
05:32:39 <shapr> accel: Yes, but can't afford to power it.. see the earlier url mentioning "ubuntu on my bladecenter".
05:32:40 <Eduard_Munteanu> Yeah.
05:32:43 <edwardk> accel: 140 cores or so
05:32:49 <dafis> but in contrast to ghc-7, it lists only one form
05:32:52 <edwardk> if you count SPUs ;)
05:33:09 * Eduard_Munteanu wonders about -XRankNTypes -XNoRank2Types combos and such :)
05:33:18 <Eduard_Munteanu> They probably don't work as intended.
05:33:30 <dafis> Eduard_Munteanu: I think that one would be contradictory
05:33:40 <dafis> compile error, hopefully
05:33:47 <edwardk> Eduard_Munteanu: heh you can only issue rank3 types? proper callCC but not runST?
05:34:00 <Eduard_Munteanu> Yeah :)
05:34:10 <Eduard_Munteanu> All N except 2.
05:34:14 <accel> shapr: i think you shoudl donate cores to me until you can afford to power the remaining cores
05:34:37 <shapr> accel: I'll sell it to you for what I paid for it.
05:34:50 <accel> shapr: how much is htat?
05:35:16 <shapr> If you pay me $5000 and shipping, you get the whole collection, including the $5000 PCIe card
05:35:40 <accel> shapr: 5K total? this is 140 cores of what? pentium 1's :-)
05:35:42 <Eduard_Munteanu> shapr: what's that again?
05:35:55 <Eduard_Munteanu> Some FPGA board?
05:35:58 <pozic> An expensive toy.
05:36:46 <Eduard_Munteanu> IIRC, the PCI-SIG specs are around $5000.
05:36:51 <shapr> accel: It's an IBM BladeCenter E chassis, eight QS20 dual-Cell blades, a dual Xeon blade, a quad Xeon blade, various wimpy AMD and Intel blades, two gigabit switch modules, six 2000 watt power supplies... I can go on.
05:37:01 <Eduard_Munteanu> Specs and membership.
05:37:34 <Eduard_Munteanu> Ouch.
05:37:37 <keep_learning> hello all 
05:37:40 <shapr> Eduard_Munteanu: Nah, the PCIe board is an unlocked Cell core with all SPUs, 1GB of XDR, 4GB of DDR2 and an ethernet port... and a big monster blower of a fan.. all in a PCIe form factor.
05:37:42 <keep_learning> http://hpaste.org/43616/rabinmiller_io
05:38:12 <keep_learning> i am trying to get bit familiar with IO 
05:38:24 <edwardk> accel: that stuff was probably 120k new, even given the depreciation on hardware, and the aftermarket effect, its a pretty good deal
05:38:31 <accel> shapr: http://picasaweb.google.com/shae.erisson/UbuntuOnMyBladeCenter# <-- is that the link?
05:38:36 <accel> shapr: do you ahve a list of specs somewhere?
05:38:46 <accel> i'm a student, my dorm does not charge me electricity
05:38:55 <accel> would be interesting to see if their policy is really like that
05:39:25 <edwardk> accel: hahaha
05:39:38 <edwardk> accel: it sounds a bit like a 747 starting up
05:39:54 <accel> quiet hours are set as 11pm on weekdays, 2am on weekends
05:40:02 <edwardk> and you could probably heat your side of the dorm
05:40:17 <Eduard_Munteanu> keep_learning: rabinMiller could easily be a pure function
05:40:19 <shapr> accel: Policies change if your room uses several thousand watts. This E chassis has four 2000W power supplies, and with all blades running full out would probably use five or six thousand watts.
05:40:33 <accel> shapr: does it even take standard wall outlets?
05:40:37 <keep_learning> Eduard_Munteanu, yes 
05:40:40 <Eduard_Munteanu> keep_learning: do you have any specific questions?
05:40:40 <edwardk> shapr: i thought you couldn't get it over a few hundred watts when you tried?
05:40:45 <dafis> keep_learning: I think you got your branches wrong
05:40:49 <shapr> edwardk: I've never powered both halves of the chassis.
05:40:53 <Eduard_Munteanu> Or just looking for tips?
05:40:58 <edwardk> ah
05:41:00 <accel> shapr: more importantly how did you buy this machine w/o powering it on? did you buy all 140 cores, then try to power it
05:41:07 <keep_learning> dafis, i think my algo is wrond 
05:41:16 <keep_learning> dafis, so i am working on this 
05:41:18 <shapr> accel: Nah, the chasis wants C19 plugs @ 220v 15A
05:41:31 * edwardk is stuck at home with an inner ear infection. never had the room flop from side to side like this before.
05:41:33 <shapr> accel: It's a long crazy story that edwardk got to hear as it went on
05:41:34 <keep_learning> dafis, i will post the haskell language problem 
05:41:48 <shapr> I gotta write up that story at some point.
05:41:53 <keep_learning> as soon as my algo is right 
05:41:56 <keep_learning> thank you all
05:42:01 <edwardk> accel: he managed to ebay his way to a supercomputer. ;)
05:42:03 <accel> shapr: does it involve a failed high performance computing sartup?
05:42:09 <edwardk> accel: and yes it does
05:42:14 * shapr laughs
05:42:42 <dafis> keep_learning: yes, if any of the e^(2^k) `mod` n is (n-1), it is a strong probable prime, in which case you start with the next base, if all are (/= n-1), you know it's composite
05:42:48 <j-invariant> is programming a science or math?
05:42:50 <edwardk> accel: he has been able to power it off of wall current though by using a 110-220 converter
05:42:57 <edwardk> j-invariant: yes
05:43:01 <accel> @src foldl
05:43:01 <lambdabot> foldl f z []     = z
05:43:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:43:03 <j-invariant> X_
05:43:04 <j-invariant> X)
05:43:06 <Eduard_Munteanu> Definitely yes.
05:43:06 <dafis> j-invariant: neither, and both
05:43:06 <accel> why can't I get @src in my ghci ?
05:43:16 <kfr> accel it's a lambdabot thing
05:43:22 <kfr> For a select few functions
05:43:25 <edwardk> i would say this, computer science is technically not about computers nor science. ;)
05:43:47 <edwardk> so clearly this is all a liberal art
05:43:50 <keep_learning> dafis, thank you 
05:43:59 <kfr> Computer science is about learning useless things and then getting an unrelated job based on that education
05:44:13 <j-invariant> lol kfr that is so cynical i love it
05:44:18 <kfr> <:
05:44:42 <kfr> j-invariant: I am speaking from experience here, I'm currently finishing my MSc in CS
05:44:42 <accel> I'm looking @ List.hs -- where is foldl defined ? I only see foldl' and foldl1 ...
05:45:06 <edwardk> kfr: depends . i find my cs education to be entirely relevant to my current job
05:45:07 <j-invariant> kfr: is it to do with haskell?
05:45:14 <quicksilver> accel: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#foldl
05:45:19 <kfr> edwardk: Amazing, lucky you
05:45:22 <Eduard_Munteanu> accel: see Prelude and Data.Foldable
05:45:26 <kfr> j-invariant: No, totally unrelated
05:45:28 <quicksilver> accel: (which is got by clicking on the 'source' link from http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html)
05:45:35 <kfr> My stuff is all embedded systems and operating systems
05:45:50 <Eduard_Munteanu> :t foldl
05:45:51 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:45:59 <j-invariant> how can you lean haskell and still underatsnd lowl levels?
05:46:21 <kfr> Although, I saw one slide in an EE lecture which actually had some Haskell quicksort code in it, haha
05:46:23 <edwardk> j-invariant: i oscillate between the two levels. it lets me stay engaged
05:46:29 <kfr> I was quite surprised by that
05:46:36 <j-invariant> maybe thats what i need
05:46:53 <kfr> That was before I even started doing Haskell though
05:46:57 <kfr> But at least I recognised it
05:47:38 <kfr> <j-invariant> how can you lean haskell and still underatsnd lowl levels? <- well, it's not like you need to forget or ignore it
05:47:50 <kfr> And I won't Haskell for things it's clearly not well suited for
05:48:27 <accel>         foldl :: (a →  b →  a) →  a →  t b →  a
05:48:28 <accel>         foldl f z t = appEndo (getDual (foldMap (Dual∘Endo∘flip f) t)) z
05:48:32 <kfr> For example, I intend to write a csrss/cmd replacement for Windows at some point which would involve hooking like 30-50 functions in user32.dll/kernel32.dll and plenty of raw memory operations
05:48:38 <accel> is that the official definition, from class Foldable?
05:48:39 <kfr> I wouldn't dream of using Haskell for that
05:49:00 <kfr> Hah, does your IRC client Unicodify ->? :D
05:49:19 <accel> if you help me pinpoint the source
05:49:21 <accel> i'll tell you :-)
05:49:31 <Wooga> i can tell
05:49:35 <Wooga> this is compose
05:49:40 <paper_cc> accel: the "official" Prelude definition at least is :: (a -> b -> a) -> a -> [b] -> a
05:49:52 <accel> paper_cc: I'm ater the source, not the type
05:50:07 <accel> Prelude.hs doesn't seem to define anything
05:50:10 <accel> and just incldue Data.List
05:50:15 <accel> but I don't see the definition in Data.List either
05:50:24 <dafis> accel: go to the docs (either Data.Foldable or Data.List) and click on the source link
05:50:38 <accel> dafis: I'm looking at both Data.Foldable and Data.List
05:50:45 <accel> Data.List shows foldl' but not foldl
05:50:48 <RichardBarrell> appEndo and getDual? That looks more like Data.Foldable, or maybe it's one of edwardk's packages.
05:51:04 * paper_cc suspects that 'foldl' from Prelude would be defined using something mind-blowing like 'build'
05:51:27 <paper_cc> accel: so it's GHC.List
05:51:36 <paper_cc> accel: http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/src/GHC-List.html#foldl
05:51:37 <dafis> accel: my docs for Data.List have foldl
05:52:05 <accel> dafis: which line of the hs file ?
05:52:07 <dafis> and the source link leads to GHC.List
05:52:31 <paper_cc> (hum, no fusion for Prelude.foldl?)
05:52:43 <dafis> accel: it's defined in GHC.List, it's then re-exported from Data.List
05:52:58 <paper_cc> accel: just follow the link I posted above
05:53:01 <Eduard_Munteanu> paper_cc: foldr is a better producer
05:53:23 <accel> paper_cc: okay; foudn it; thanks
05:53:35 <accel> to answer the earlie question of how my irc unicodes haskell code -- it doesn't; i'm copying/pasting from leksah
05:54:27 <kfr> I see
05:54:28 <Wooga> accel: why not using compose?
05:54:28 <paper_cc> Eduard_Munteanu: I never quite got what stream fusion really does, so... =)
05:54:39 <Wooga> it's much easier and cool
05:54:41 <accel> kfr: yeah, sorry for lame answer
05:54:50 <accel> Wooga: what'scompose?
05:54:51 <Wooga> you just press <Compose Key> + - + >
05:54:56 <Wooga> and getting →
05:55:13 <Wooga> accel: this is input extension in Xorg at least
05:55:24 <Wooga> accel: but also implemented in many other environments
05:55:39 <Wooga> http://en.wikipedia.org/wiki/Compose_key
05:56:11 <edwardk> Data.Foldable uses appEndo and getDual to define foldl in terms of foldMap
05:56:13 <paper_cc> Eduard_Munteanu: (or how it does it)
05:56:28 <accel> question now is -- why can't I find it using leksah
05:56:53 <hape01> on my windows pc hasktags does not append correctly (-a option)  do you use hasktags under windows without cygwin, and use the append option of hasktags? that would be interesting for me...
05:57:14 <Eduard_Munteanu> paper_cc: take 'map' for instance... there's a fusion rule for it:
05:57:27 <Eduard_Munteanu> map f . map g = map (f . g)
05:57:50 <Eduard_Munteanu> Expressed as a RULES pragma.
05:58:16 <Eduard_Munteanu> In other cases this lets you completely eliminate a datastructure, such as a list.
05:58:37 <edwardk> paper_cc: stream fusion is based on the idea that ideally when you compose together a bunch of operations on lists what you really want to do is build one big inner loop that processes data from some source and produces a result.
05:59:08 <Eduard_Munteanu> But it can only work when "good" producers are combined with "good" consumers.
05:59:39 <Eduard_Munteanu> If you used foldl', the whole result is evaluated before any fusion can occur.
05:59:54 <edwardk> so what it does is it tries to find a non-recursive core to iterate with. to that end it defines 'Yield' nodes which correspond to the original list notion, Done nodes which correspond to the original [] at the end, and 'Skip' nodes which are dropped in by things like filter to avoid having to recursively pull the next element. this lets the core loop have simple control flow
06:01:23 <paper_cc> edwardk: umm... nodes?
06:02:56 <edwardk> paper_cc: consider something like: data Step s a = Yield a s | Skip s | Done
06:03:40 <edwardk> then define data Stream s a = forall s. Stream (s -> Step s a) s — which is a seed, and a function for using that seed (the actual type is a bit more complicated to expose things to the optimizer)
06:04:23 <edwardk> so maybe the infinite list of repeated a's sets s = a, the stepper function returns Yield a a 
06:04:46 <Eduard_Munteanu> edwardk: what's with the 'forall' there?
06:04:47 <paper_cc> is "seed" like the accumulator in fold?
06:05:08 <edwardk> er sorry
06:05:19 <edwardk> data Stream a = forall s. Stream (s -> Step s a) s
06:05:24 <edwardk> that is an existential
06:05:44 <paper_cc> mm... or no
06:05:48 <edwardk> it says that the type exists but you don't care about it. all you know about s is that you have a function that can accept it and one lying around
06:05:48 <Eduard_Munteanu> (yeah, I was asking because I didn't know which 's' to look at :D)
06:05:49 <pozic> edwardk: It basically just builds up a first order representation, does some basic reasoning and returns a simpler and faster first-order structure, right? 
06:05:59 <edwardk> paper_cc: its the 'seed' in unfold.
06:06:01 <paper_cc> edwardk, the accumulator un /un/fold
06:06:04 <paper_cc> aha
06:06:09 <edwardk> yeah
06:06:26 <edwardk> the key difference is the addition of Skip 'Step's
06:06:51 <edwardk> now filter, can be defined as a simple transformation on the stepper function which takes some Yield'ed results and turns them into Skips
06:07:14 <edwardk> so if you have a function that recursively applied the stepper, which doesn't internally recurse, it could probably inline the stepper
06:07:37 <edwardk> this lets it 'fuse' the filter into the other stream
06:07:53 <edwardk> similar fusions let you transform more and more list operations into a bigger and bigger loop
06:09:05 <Eduard_Munteanu> Ok, earlier I was talking about deforestation rules, edwardk seems to be discussing those weird stream fusion primitives I haven't had a look at yet, like gmap stuff I guess.
06:09:56 <edwardk> Eduard_Munteanu: yeah they largely subsume the foldr/build fusion or map/map fusion because those unforunately don't compose nicely beyond toy cases
06:10:35 <paper_cc> edwardk: thanks a lot. I should probably look at some real rules to see what they do and if I can understand what they do =)
06:10:49 <paper_cc> edwardk: (or can't I?)
06:11:22 <Eduard_Munteanu> edwardk: so they're somewhat like "trust me, I guarantee I'm okay with the stronger fusion rules they imply"?
06:12:51 <edwardk> paper_cc: there is a paper by duncan, roman and don around here somewhere: http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
06:12:57 <Eduard_Munteanu> *stronger than what map does currently
06:14:06 <edwardk> eduard: well, foldr/build fusion and destroy/unfoldr fusion are both perfectly usable systems of fusion stream fusion os destroy/unfoldr fusion with a couple of tricks because it allows the optimizer to spot more inlining cases than the alternative
06:14:15 <accel> i'm on ubuntu 10.10 with ghc 6.12; is there anything I should be aware of before doing a "cabal install ghc" (to get 7.0)
06:14:22 <edwardk> at least that is if i recall correctly. its been a couple years since i looked at this stuff
06:14:50 <dafis> accel: you don't get ghc via cabal
06:14:53 <edwardk> the addition of 'step' just enables some additional things to be fused
06:15:51 <dafis> accel: if there's no package with ghc-7 for ubuntu, you can either install a vanilla linux binary from the ghc home page or build yourself from source
06:16:32 * dafis loves building from source
06:16:56 * paper_cc hopes he'll understand what "converting structures to co-structures" means
06:17:22 <Eduard_Munteanu> Coinductively defined structures?
06:17:29 <pozic> paper_cc: it basically means "making your structures suitable for lazy computation".
06:18:04 <kfr> This subject is perfect for this channel: "I'm graduating with a Computer Science degree but I don't feel like I know how to program." http://stackoverflow.com/questions/2823571/im-graduating-with-a-computer-science-degree-but-i-dont-feel-like-i-know-how-to
06:20:20 <earthy> kfr: I've been programming for 20 years and still don't feel like I know how to
06:20:21 <Cale> kfr: You think we should answer with a suggestion of learning Haskell?
06:20:48 <Cale> (I feel like it would be a little out of place among the more general advice)
06:21:13 <Eduard_Munteanu> Nah, I think j-invariant brought that up and someone bit.
06:21:18 <edwardk> my best advice for learning to program, is to just program, incessantly, for years
06:21:23 <kfr> The page amazingly enough does not mention Haskell even though it was linked on Hacker News.
06:21:27 <kfr> edwardk yeah
06:21:46 <kfr> Better start early with it, too
06:22:02 <kfr> Around 12-14 is a good age to start
06:22:06 <kfr> Some start earlier
06:22:09 <edwardk> 6-7 ;)
06:22:14 <Eduard_Munteanu> What, is it gymnastics?
06:22:16 <opqdonut> oh my, a _computer_science_ student who is studying algorithms on his free time :D
06:22:20 <kfr> Eduard_Munteanu yes
06:22:20 <accel> you mean you guys didn't climb out of the womb carrying keyboards?
06:22:21 <dafis> kfr: can you lend me a time machine?
06:22:24 <opqdonut> I wonder which school this is
06:22:39 <edwardk> opqdonuts: a number of computer science programs are more or less java trade schools
06:22:44 <kfr> dafis: I can modify the universe to restore a former state, would that count?
06:22:57 <kfr> edwardk nice
06:22:58 * geheimdienst has been a programmer in six previous lives
06:23:01 <accel> use Control.Monad.TimeTravel
06:23:02 <dafis> kfr: cool, can you wind it back 40 years?
06:23:03 <opqdonut> edwardk: indeed
06:23:22 <accel> geheimdienst: given how long programamble machines have existed; those must have been short lives
06:23:34 <accel> geheimdienst: unless you lived those lives in parallel
06:23:35 <geheimdienst> no no, they were all in the future
06:23:39 <kfr> dafis mind you, this involves cloning you and subsequently killing you :| that is my version of time travel.
06:24:00 * dafis ponders
06:24:04 <geheimdienst> accel, yes that too. parallel programming, you might say, hehe
06:24:33 <kfr> This is the only way "time travel into the past" from my perspective, sorry
06:24:39 <kfr> only way to achieve*
06:25:26 <Eduard_Munteanu> Sounds like travelling to parallel universes by quantum suicide.
06:25:27 <edwardk> All you need to do to time travel is use the backward state monad trick on IO, so just rewrite IO, which is State# RealWorld -> (# a , State# RealWorld #) with the wrong bind. I tried that next Tuesday and i'm still getting over the vomiting and disorientation.
06:25:41 <kfr> Oh yeah and people keep on going on about Project Euler
06:25:41 <Eduard_Munteanu> Heh.
06:25:53 <kfr> That is so niche, I'm not sure why people would even recommend that to learn programming
06:26:13 <Kaidelong> kfr: gives people something to do, initiative is often the real problem
06:26:20 <Eduard_Munteanu> Programming isn't just coding algorithms.
06:26:27 <accel> in theory, we can time travel
06:26:27 <kfr> I find it odd enough that any programmer would require others to tell them what to code, basicallhy
06:26:32 <accel> in practice, we can't read and write to the World state
06:26:44 <kfr> I started learning programming languages because I had problems I didn't know how to solve
06:26:54 <accel> i learned programming
06:26:58 <accel> becuase I wanted to script Muds
06:26:58 <geheimdienst> howto learn programming: program a lot and often stop to think about what came back to bite you. i know people who've programmed cheerfully for 10 or 15 years and never noticed it's crap to have a shell script saying "cat source1.pl source2.pl ... source166.pl > everything.pl", then run that
06:27:28 <accel> "kill pig; cast fireball; drink potion" gets tired to type after a while
06:27:28 <Eduard_Munteanu> Well, not really, not having a good, motivating idea is a legitimate reason for asking what to start with.
06:28:13 <edwardk> accel: heh. i learned to program becaise i'd lied and told a kid that i'd written a disassembler, then had to make good on the claim.
06:28:25 <kfr> Some people have been coding for a long time and have terrible habits, yeah
06:28:37 <kfr> There is an amazing amount of copy paste programmers in the IT industry
06:29:00 <accel> edwardk: what crowd did you hang aroudn where coolness was measured in "writing a disassembler"?
06:29:02 <Eduard_Munteanu> Copy & paste is okay, IMHO.
06:29:03 <geheimdienst> edwardk: what, seriously? that's a good story
06:29:21 <kfr> Eduard_Munteanu: I meant this in the sense of not using functions when you should
06:29:33 <Eduard_Munteanu> Just look around at the many innovative, shiny FOSS projects that failed just because of that.
06:29:43 <Eduard_Munteanu> Ah.
06:29:43 <kfr> Eduard_Munteanu when they want to solve something in a slightly different fashion they copy paste their previous code and replace some values
06:29:47 <Eduard_Munteanu> Yeah, that's a point.
06:29:58 <kfr> Instead of making a new function which takes more arguments
06:30:07 <kfr> Or some other appropriate abstraction for that particular probleem
06:30:11 <kfr> problem*, too
06:30:30 <Eduard_Munteanu> I'd say contributing to a FOSS project is a good way to start.
06:30:41 <geheimdienst> kfr, yeah, that's what i'd generally understand by "copy-paste programming"
06:30:51 <edwardk> accel, gehemdienst: when i was a little kid i grew up in the inner city and so my mom didn't want me going outside, so i basically played on the computer all day. i switched schools, and the resident smart kid and i got into it, and then the disassembler thing came up. it escalated from there, before long i had the basic and kernel roms disassembled, and had traced through them, then i started dumping the 1541 roms
06:30:54 <geheimdienst> and it's deeply evil
06:30:55 <j-invariant> copy paste programming
06:30:57 <Eduard_Munteanu> Mainly because most enforce good style, and you also have to sort your way through heaps of unfamiliar code.
06:31:23 <Eduard_Munteanu> So you become a better code reader and writer.
06:32:05 <edwardk> sadly this did not do wonders for my programming style since the largest body of code i had access to was what was on the roms, and those were designed to eke out whatever space they could, i just thought all code was written that way. i didn't really think in terms of variables until my teenage years ;)
06:32:07 <kfr> Understanding other people's code is a science of its own and most FOSS projects deal with stuff which is considerably beyond the scope of a novice
06:32:09 <geheimdienst> edwardk: awesome :)
06:32:33 <kfr> So it's definitely not something I'd recommend to somebody who is just starting out
06:32:33 <accel> edwardk: how old were you when you wrote a disasembler?
06:32:34 <edwardk> just registers and trying to find a place on the 0-page or heaven forbid, main memory, to stash data
06:32:44 <edwardk> accel: 8
06:32:56 <accel> edwardk: did you miss any diits there? like 18?
06:33:03 <accel> edwardk: or 8, as in 100 in binary ?
06:33:04 <edwardk> accel: nah
06:33:10 <accel> edwardk: how old are you rigth now?
06:33:23 <edwardk> accel: 35
06:33:34 * hackagebot hjson 1.3.2 - JSON parsing library  http://hackage.haskell.org/package/hjson-1.3.2 (JaroslavGridin)
06:33:58 <Eduard_Munteanu> Well, yeah, it does require some basic knowledge, but not always a great coding ability.
06:34:07 <pozic> Eduard_Munteanu: 0-page?
06:34:13 <pozic> edwardk: 0-page?
06:34:32 <danharaj> "Parse error (possibly incorrect indentation)" is never an indentation error -.-
06:34:54 <geheimdienst> @quote edwardk i learned to program becaise i'd lied and told a kid that i'd written a disassembler, then had to make good on the claim.
06:34:55 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
06:35:02 <geheimdienst> @remember edwardk i learned to program becaise i'd lied and told a kid that i'd written a disassembler, then had to make good on the claim.
06:35:02 <lambdabot> It is forever etched in my memory.
06:35:18 <edwardk> pozic: The 6510/6502 has special addressing modes that can use the first 256 bytes of memory for indirection like they were slop registers
06:35:36 <Eduard_Munteanu> @quote edwardk.disassembler
06:35:36 <lambdabot> No quotes match. You untyped fool!
06:35:40 <Eduard_Munteanu> @quote edwardk disassembler
06:35:40 <lambdabot> edwardk says: i learned to program becaise i'd lied and told a kid that i'd written a disassembler, then had to make good on the claim.
06:35:43 <j-invariant> can anyone please tell me how to configure ghci
06:35:45 <Eduard_Munteanu> Good :)
06:36:01 <j-invariant> I want to set the default memory limit
06:36:22 <Saizan> i think there's an environment variable for that
06:36:23 <Eduard_Munteanu> Stack, heap or what?
06:36:39 <Saizan> RTSOPT? it should be in the ghc manual
06:37:07 <Eduard_Munteanu> Saizan: hm, does it inherit +RTS ... -RTS stuff?
06:37:15 <j-invariant> thanks
06:37:16 <j-invariant> When the -rtsopts flag is used when linking, RTS options are also taken from the environment variable GHCRTS. For example, to set the maximum heap size to 128M for all GHC-compiled programs (using an sh-like shell):
06:37:20 <Eduard_Munteanu> I mean are those interchangeable?
06:37:21 <j-invariant> GHCRTS='-M128m' export GHCRTS
06:38:35 <Saizan> Eduard_Munteanu: not sure what happens when you've both GHCRTS set and you pass +RTS .. on the cli
06:39:15 <edwardk> gehemdeinst; to be fair i'd had a vic-20 for a couple of years before that point, and had written a bunch of basic programs, mostly by copying from the back of magazines, etc. and had tried to understand the machine language opcodes from the back of the vic-20 programmer's reference guide already, so i had a fair bit og context before i went on the weekend binge to prove the other kid wrong ;)
06:39:41 <accel> woot
06:39:42 <accel> yeah
06:39:44 <accel> fuck yeah
06:39:45 <accel> victory
06:39:50 <edwardk> accel: ?
06:39:52 <accel> I got leksah to display foldl soucce for me
06:39:56 <edwardk> hah
06:39:56 <accel> so happy
06:40:03 <accel> i'm a nerd
06:40:41 <edwardk> that reminds me i should finish up adding Representables and keyed functors to my adjunctions package
06:41:00 <edwardk> (i was just writing 'foldlWithKey' for FoldableWithKey)
06:41:11 <accel> -- We write foldl as a non-recursive thing, so that it
06:41:11 <accel> -- can be inlined, and then (often) strictness-analysed,
06:41:12 <accel> -- and hence the classic space leak on foldl (+) 0 xs
06:41:19 <accel> what? recursive funcs can't be inlined?
06:41:42 <edwardk> if you call yourself you aren't inlineable. what do you do to inline the subsequent call?
06:41:54 <accel> the source code for foldl
06:41:57 <j-invariant> does anyone have an fast low memory factoring algorithm
06:41:57 <accel> just wraps it in a function called "lgo"
06:42:16 <accel> j-invariant: "factor_prime(int p) { return p; }"
06:42:22 <dafis> j-invariant: for how large numbers?
06:42:34 <accel> the source of foldl in List.lhs looks like:
06:42:35 <accel> foldl f z0 xs0 = lgo z0 xs0
06:42:35 <accel>              where
06:42:35 <accel>                 lgo z []     =  z
06:42:36 <accel>                 lgo z (x:xs) = lgo (f z x) xsj
06:42:50 <j-invariant> 20 digits long
06:42:52 <accel> so to 'inline', it just sets up indirection w/ lgo
06:43:01 <accel> j-invariant: build a table of all 10-digit long primes; brute force
06:43:06 <accel> j-invariant: there are some probabilistic algorithms too
06:43:12 <j-invariant>  iwant the code
06:43:12 <dafis> j-invariant: Pollard's rho method should be fine for those
06:43:26 <accel> doesnt the number of primes grow logarithmically ?
06:43:30 <edwardk> odd definition there. must have profiled the best
06:43:30 <j-invariant> no
06:43:32 <accel> why not just build a table of all 20 bit priems?
06:43:41 <accel> edwardk: referring to foldl ?
06:43:42 <j-invariant> I meant base 10
06:43:43 <j-invariant> digits
06:43:46 <edwardk> yeah
06:44:08 <accel> edwardk: weird thign is ... it just introduces an extra layer of indirection
06:44:11 <accel> i.e. lgo is still fucking recursive
06:44:13 <edwardk> yep
06:44:26 <edwardk> usually you would build a 'go' function like that and pass it all the args
06:44:33 <merijn> accel: This sounds like voodoo best asked on the mailing list?
06:44:35 <accel> the whole thing is: we can't ahve foldl be recursive inorder to inline it; so ... let's
06:44:43 <dafis> j-invariant: look it up on wikipedia and write the code yourself, it's asking a bit much here on irc
06:44:46 <accel> build a recursive function ... and then call that 
06:45:02 <edwardk> accel: well, usually the worker for those worker wrapper transforms has an extra argument or two
06:45:04 <j-invariant> dafis: I know the algorishm I expect someone has already wrtten them
06:45:06 <edwardk> not one fewer
06:45:19 <j-invariant> someone hwo knows how to write fast haskell code
06:45:45 <accel> -- We write foldl as a non-recursive thing, so that it
06:45:45 <accel> -- can be inlined, and then (often) strictness-analysed,
06:45:47 <accel> -- and hence the classic space leak on foldl (+) 0 xs
06:45:53 <accel> what is the classical space leak on foldl (+) o xs ?
06:45:56 <edwardk> ad whatever they need they either pull entirely from environment or entirely from local bindings. here its a mixed bag z in args, f from environment
06:46:17 <dafis> j-invariant: search hackage (or wait until I get my arithmoi out, if ever)
06:46:20 <Saizan> z changes though
06:46:26 <j-invariant> What is arithmoi?
06:46:37 <Saizan> edwardk, accel: once you've inlined the call to lgo, 'f' is potentially a known function, so the strictness analyzer might work better?
06:46:41 <edwardk> saizan: oh yeah
06:47:00 <edwardk> saizan: f is held invariant to make it easier for the strictness analyzer to spot it and do its work once
06:47:03 <Saizan> *once you've inlined foldl exposing lgo
06:47:09 <dafis> when I've finished writing it, it will be a package for basic number-theoretic stuff (primes, factoring, ...)
06:47:18 <edwardk> cute
06:47:39 <accel> edwardk / Saizan : you guys are saying somethign smart; I don't understand it. Can you enlighten me?
06:47:39 <edwardk> i may steal that for my foldl variants
06:47:52 <accel> How does this trick make ghc's job easier?
06:48:04 <edwardk> i'll let saizan explain. i'm going to go use that ;)
06:48:08 <lpsmith> accel:  try typing   (foldl (+) 0 [1..10^8]) into ghci
06:48:30 <accel> it's slowish
06:48:31 <accel> still running
06:48:41 <lpsmith> Then try typing  (Data.List.foldl' (+) 0 [1..10^8]) as well
06:48:47 <merijn> You'll probably run out of space soon :p
06:48:51 <merijn> (as in RAM)
06:49:08 <lpsmith> (You might have to experiment with the upper bound to find one that works well with your setup)
06:49:29 <Saizan> accel: since 'f' is not a parameter of lgo, when you inline e.g. foldl (+) 0 xs, ghc transforms that to a call to lgo 0 xs where lgo z [] = z; lgo z (x:xs) = lgo (z + x) xs
06:50:02 <Saizan> accel: so the '+' there is not longer an obscure function parameter, it's the known function (+), enabling more analysis
06:50:42 <Saizan> i'm not 100% sure that's actually what's happening, but it seems to fit :)
06:50:49 <lpsmith> also,  accel,  if you use unix,  I recommend setting a soft ulimit  ("ulimit -S -v number_of_kilobytes")  to prevent GHC from thrashing your virtual memory
06:51:15 <lpsmith> you should put that in your .bashrc or equivalent
06:51:28 <Saizan> accel: though foldl' is better here because you're giving even more hints to GHC about strictness
06:51:49 <accel> lpsmith: for future references, please tell me that is goign to freze up X, and I need to go into a virtual terminal to kill ghc :-)
06:52:09 <lpsmith> that's why I recommend setting a soft ulimit :)
06:52:14 <merijn> Saizan: foldl' isn't really much of a hint and more of an over threat of pain if it is not strictified, isn't it? :>
06:52:20 <ddarius> Saizan: It's not a matter of giving "hints," it's a matter of different semantics.
06:52:51 <edwardk> merijn: more like just strapping it into a chair and forcing it to be strict
06:54:05 <accel> one thing at a time
06:54:16 <accel> it's not clear to me why foldl (+) 0 [1..10&8] need to generate the entire list
06:54:27 <Saizan> it doesn't
06:54:28 <ddarius> It doesn't.
06:54:41 <accel> (foldl (+) 0 [1..10^8]) <-- so why did this kill my machine?
06:54:56 <dafis> accel: it generate a thunk (1+(1+(...(1+0)..))
06:55:08 <accel> then it execs the thunk?
06:55:14 <dafis> it tries to
06:55:24 <dafis> if it ever gets that far
06:55:24 <accel> wait, it _tries_ to generate the thunk
06:55:27 <accel> and dies generating it
06:55:30 <sipa> yes
06:55:48 <Saizan> if it succeeds it usually ends in a stack overflow
06:56:23 <Jesin> huh
06:56:24 <accel> Saizan: cool; thanks; why does lgo know about '+' whereas foldl does not?
06:56:24 <Jesin> [10:12:07]	<accel>	wait, it _tries_ to generate the thunk
06:56:26 <Jesin> [10:12:09]	<accel>	and dies generating it
06:56:44 <Jesin> does foldl' do the same thing?
06:56:45 <merijn> Jesin: What's odd about that?
06:56:52 <merijn> Jesin: No, foldl' is strict
06:57:00 <accel> actually; shy doesn't it generate the thunks on demand?
06:57:03 <merijn> So it doesn't build thunks but computes immediately
06:57:29 <dafis> given an appropriate type
06:57:40 <Saizan> accel: because foldl takes the f as a parameter, while lgo doesn't
06:58:11 <merijn> accel: No, because the outer thunk need the inner thunks as input to the function f. Which means you need to keep all thunks around until you evaluate the last one
06:58:40 <accel> Saizan: lgo z0 xs0
06:58:40 <accel>              where
06:58:40 <accel>                 lgo z []     =  z
06:58:41 <accel>                 lgo z (x:xs) = lgo (f z x) xs
06:58:51 <accel> so basically, in that, the compiler can 'see' the f ?
06:58:57 <Bynbo7> that just stops it passing f around
06:59:02 <Bynbo7> when there's no need to
06:59:13 <Bynbo7> it's a worker wrapper transformation
07:00:04 <sioraiocht> if a Stream is a name for a co-list
07:00:15 <sioraiocht> is there an equally pleasing name for co-trees?
07:00:21 <accel> merijn: foldl (+) 0 [1..10] = lgo 0 [1..10] = lgo (0 + 1) [2..10] = lgo (0 + 1 + 2) [3..10] .... = lgo (0 + 1 + 2 + ... + 10) [] <-- and then it executes the thunk?
07:00:34 <Jesin> wait, stream is co-list, what
07:00:45 <Bynbo7> accel: no, the thunk gets executed when you try to inspect the value of it
07:01:12 <accel> Bynbo7: right, I forgot that part, but when we need to view the value, (i.e. ghci print it) ... then the above happens?
07:01:17 <merijn> accel: Once you try to access the result of lgo, yes. So if the list is long enough the thunk construction will run you out of memory when you try to evaluate
07:01:34 <accel> so what does this comment here mean: ... (I'm utterly confused)
07:01:35 <Bynbo7> so if you never try to find out what value is produced by foldl there, it will get GC'd (though hopefully it would never have got to that point, if would be very strange for it to do so)
07:01:35 <accel> -- We write foldl as a non-recursive thing, so that it
07:01:35 <accel> -- can be inlined, and then (often) strictness-analysed,
07:01:36 <accel> -- and hence the classic space leak on foldl (+) 0 xs
07:02:14 <Saizan> accel: when ghc inlines a call like foldl (+) 0 it has to generate a version of lgo where it substitutes (+) for the f directly in the body, so at that point you get a freshly generated function where (+) appears explicitly
07:02:48 <Jesin> "non-recursive" is wrong and should be fixed
07:02:50 <Jesin> :p
07:02:52 <accel> Saizan: ah, so it generates a lgo_sperialized_for_+ <-- and then ghc optimizes that?
07:02:55 <dafis> accel: that means at the use site, foldl f z xs gets rewritten to lgo z xs where ..., and there, f is hopefully known
07:03:05 <sipa> accel: by showing the compiler more code, it can infer that when evaluating the outer function, the inner will always needs to be evaluated completely, and doesn't need to use thunks
07:03:06 <Bynbo7> lgo literally becomes lgo a (x:xs) = lgo (a+x) xs
07:03:10 <Saizan> accel: yeah
07:03:27 <dafis> and the strictness analyser may know f is strcit and tell the compiler to evaluate immediately
07:03:40 <lpsmith> actually,  i found out that stack overflows can be disabled
07:03:44 <accel> Saizan: thanks; this is insightful :-)
07:03:59 <Bynbo7> accel: but, it's possible the compiler won't see the strictness, so you can get a space leak. if you don't use optimisations, this will cause a space leak
07:03:59 <lpsmith> GHC uses a segmented stack that can grow without bound
07:04:12 <accel> Bynbo7: and ghci does not use optimiations?
07:04:16 <Bynbo7> no
07:04:25 <lpsmith> But by default most versions of GHC set a stack limit,  because that usually means something's gone wrong
07:05:00 <lpsmith> accel, what's important here is the strictness analyzer,  which needs ghc -O 
07:05:00 <Bynbo7> accel: so you may find that if you write a program: main = print $ foldl (+) 0 [1..10E8], without -O it will leak horribly, and should be ok with -O
07:05:02 <Saizan> you can control the limit with +RTS -K
07:05:04 <Bynbo7> or -O2
07:05:15 <lpsmith> If you just compile ghc,   the strictness analyser won't run
07:05:25 <lpsmith> And it's almost always a good idea to run the strictness analyser
07:06:03 <accel> is there a way to step by step through ghc as it executes
07:06:07 <accel> I feel like that would be really insightful
07:06:21 <accel> err, executes my compiled code
07:06:22 <roconnor> how do I make pretty formated latex haskell source code?
07:06:22 * ddarius recommends writing code that doesn't rely on the strictness analyzer to not stack-overflow or use large amounts of heap.
07:06:28 <Bynbo7> accel: it doesn't make much sense to do so in haskell
07:06:29 <accel> i.e. not the actual ghc compilation process
07:06:31 <ddarius> roconnor: Use lhs2TeX
07:06:50 <nostard_> accel: lazy evaluation makes that a lot less interesting
07:06:52 <accel> Bynbo7: why? I feel seeing how haskell expands / decides when/waht to execute is key to all my questions
07:06:54 <lpsmith> there is a new debugger, though I haven't really played with it.  "stepping" through a haskell program is not an easy proposition,  even if you have a good UI  (which I'm not sure we've seen yet).
07:07:20 <lpsmith> accel, playing with Debug.Trace.trace can be very enlightening,  though also very frustrating
07:07:24 <Bynbo7> because it's not so much a matter of this happens then this then this
07:07:43 <Bynbo7> and what you'd see wouldn't be very meaningful
07:08:52 <edwardk> i try to pretend the strictness analyzer doesn't exist, and just do its job for it ;)
07:09:03 <accel> edwardk: I like that philsophy
07:09:27 <paper_cc> accel: because decoding the original Haskell program from GHC's internal representation is even harder than decoding C from asm
07:09:43 <Saizan> yeah, and in that case looking/doing by hand some call-by-need evaluation steps helps a lot for intuition
07:09:51 * Kaidelong thinks, if anything, haskell could be lazier. For example, "if undefined then True else True"
07:10:00 <ddarius> edwardk: I only do that so far as to avoid space leaks.
07:10:04 <kfr> I wonder how hard reverse  engineering commercial Haskell applications is
07:10:10 <edwardk> ddarius: yeah
07:10:12 <Kaidelong> > if undefined then True else True
07:10:14 <lambdabot>   *Exception: Prelude.undefined
07:11:25 <accel> @src seq
07:11:25 <lambdabot> Source not found.
07:11:26 <edwardk> ddarius: i mostly get by with a few !'s and {-# UNPACK #-}'s to avoid paying huge lump sums when forcing thunks for things like size counters, etc.
07:11:29 <ddarius> kfr: Probably rather easy.
07:11:43 <accel> foldl' f z0 xs0 = lgo z0 xs0
07:11:43 <accel>     where lgo z []     = z
07:11:44 <accel>           lgo z (x:xs) = let z' = f z x in z' `seq` lgo z' xs
07:11:47 <accel> why is this "strict" ?
07:11:56 <Saizan> the seq
07:12:22 <edwardk> seq
07:12:24 <ddarius> edwardk: I usually bang accumulation parameters that aren't "obviously" forced with maybe a few extra bangs for symmetry.
07:12:26 <Bynbo7> because seq is magic
07:12:46 <Bynbo7> seq is not really something that's definable in haskell
07:12:53 <Bynbo7> that's not true if you have bang patterns
07:13:11 <accel> ah; so I should stop digging for the source code to 'seq' ?
07:13:25 <Saizan> accel: (x `seq` y) evaluates to y only after x has been evaluated to WHNF
07:13:28 <dafis> accel: yes, it's nowhere to be found
07:13:36 <ddarius> Saizan: Not quite true.
07:13:46 <dafis> accel: it's wired-in compiler magic
07:13:47 <Saizan> ddarius: how so?
07:13:49 <accel> wait
07:13:52 <accel> what does WHNF stand for?
07:13:59 <Kaidelong> weak head normal form
07:14:02 <dafis> weak head normal form
07:14:12 <dafis> kazing
07:14:15 <Bynbo7> accel: are you starting to see what i mean about you not having the foundations of haskell down yet? =)
07:14:22 <ddarius> Saizan: x `seq` y can evaluate y to WHNF first and then x.  In fact, due to this, the definition of foldl' is technically wrong.
07:14:28 <ddarius> Saizan: This is the difference between pseq and seq.
07:14:29 <accel> Bynbo7: yeah; but this stuff is fasicanting
07:14:35 <accel> Bynbo7: and not covered in Haskell SOE afaik
07:14:38 <Bynbo7> accel: indeed it is!
07:14:41 <Bynbo7> i love this stuff
07:14:42 <Saizan> accel: i.e. evaluated enough to expose its toplevel constructor
07:14:42 <lpsmith> Bynbo7, actually,  you can define seq in haskell for specific types
07:14:46 <accel> Bynbo7: or atleast not in the first 5 chapters
07:14:51 <lpsmith> but not the full polymorphic type
07:14:57 <Bynbo7> accel: this stuff is all i real world haskell
07:15:09 <Bynbo7> lpsmith: sore, but not in general
07:15:11 <Bynbo7> sure*
07:15:24 <lpsmith> :)
07:15:24 <Saizan> ddarius: sure, but i said (x `seq` y) evaluates _to_ y :)
07:17:06 <accel> http://zvon.org/other/haskell/Outputprelude/seq_f.html says: "evaluates its first argument before returning the second one. It is usually introduced to improve performance by avoiding unneeded laziness. It forces evaluation of the function " this makes no sense; so seq is "a -> b -> b" ... so what does it do with the "a" ?
07:17:10 <Saizan> WHNF(x) |- (x `seq` y) ~~> y
07:17:42 <Bynbo7> I'm still unsure whether you can define seq as: data Seq s = S !s; seq x y = case S z of S x' -> y
07:18:01 <copumpkin> Bynbo7: !s just means seq the argument before 
07:18:16 <Saizan> so yeah
07:18:20 <ddarius> Bynbo7: That should work, but the ! there is defined in terms of seq, so it doesn't really solve anything.
07:18:36 <Bynbo7> ddarius: sssshhh, don't tell me that! :P
07:18:39 <accel> ! I understand though, I think
07:18:43 <accel> it feels ab ti more intuitive
07:18:49 <zygoloid> it's like "seq !a b = b"
07:18:59 <Bynbo7> accel: ! is just sugar for seq
07:19:41 <lpsmith> zygoloid's explanation might be more helpful though :)
07:19:44 <Bynbo7> i always wondered why foldl' wasn't ... go a (x:xs) = let a' = f x a in go a' xs
07:19:59 <Bynbo7> seems it's slightly more lazy than you might want
07:20:12 <lpsmith> let is lazy
07:20:18 <Bynbo7> sure
07:20:21 <Bynbo7> hmm
07:20:25 <lpsmith> Well,  case is lazy too
07:20:27 <Saizan> forgot a bang there?
07:20:28 <accel> for "lgo a b", in classical foldl, foldl (+) 0 [1..10^8] -> lgo 0 [1..10^8] -> lgo (0+1) [2..10^8] -> lgo (0+1+2) [3..10^8] .... ; "b" is never explicitly constructed, so it's the "a" that stores the thunks and writes out the memory? so the point of using 'seq' is to force the strictness on the 'a' right?
07:20:44 <Bynbo7> Saizan: uh, forgot a seq actually
07:20:48 <accel> an alternative def in List.hs is: foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:20:49 <lpsmith> The difference being that let's patterns are irrefutable,  while case's patterns are not
07:20:59 <Bynbo7> go a (x:xs) = let a' = f x a in a' `seq` go a' xs
07:21:29 <accel> Bynbo7: haskell source appears to agree with you: http://hpaste.org/43621/foldl
07:21:40 <Bynbo7> the other way, forcing the accumulator and passing it to f means that you get a (probably small) thunk back, potentially
07:21:57 <Bynbo7> well, aren't i just a genius then
07:22:20 <accel> Bynbo7: when you took the IQ test, did the counter overflow?
07:22:29 <Bynbo7> yeah man
07:22:41 <Bynbo7> couldn't take more than three digits
07:22:49 <accel> but it turned out positive, becuase after it overflowed, it went through all the negative numbers back into positive too
07:23:13 <j-invariant> I got negative IQ becaus eI think of the answers before reading the question
07:23:15 <geheimdienst> was it three decimal digits?
07:23:16 <Bynbo7> there ar eno negative IQ's
07:23:50 <accel> my IQ isn't a real number; because when I took the test, I communicated with an parallel, orthagonal universe
07:24:15 <geheimdienst> parallel and orthogonal, eh?
07:24:24 <Bynbo7> that sounds unpossible!
07:24:31 <accel> time to sleep :-)
07:24:42 <zygoloid> temporally parallel and spatially orthogonal?
07:24:44 <Bynbo7> where're you?
07:25:02 <accel> i've been up all night
07:25:04 <accel> I'm in the US
07:25:25 <Bynbo7> zygoloid: yeah i can't hear orthogonal without getting apicture of things being at right angles to each other
07:25:26 <Cale> The interesting thing about having a complex number for measuring intelligence would be how multiplication acts on that. Not sure what exactly it would represent. (Some sort of oscillatory behaviour??)
07:25:39 <j-invariant> intelligence is a real number
07:25:40 <dafis> Bynbo7: the zero space is parallel and orthogonal to all subspaces
07:25:44 <Bynbo7> so, my picture of || and _| didn't feel possible
07:25:51 <j-invariant> it's how well you approximate the optimal AI algorithm
07:25:52 <ddarius> j-invariant: Real numbers don't exist.
07:26:06 <j-invariant> ddarius: so do natural numbers
07:26:22 * geheimdienst represents his computer as a complex number with cpu speed in the real part and ram size in the imaginary
07:26:27 <dafis> ddarius: real numbers are imaginary?
07:26:28 <j-invariant> it's defined using  a non trancendental functionbut you can approximate it
07:26:35 <accel> the liens (0, 0, 0) -> (0, 0, 1) and line (1, 1, 0) -> (1, 0, 0) ... are (1) at 90 degree angle and (2) in parallel planes
07:26:48 <zygoloid> dafis: wow, that space meandered a long way to the left!
07:26:50 <geheimdienst> cale: ^^ something like that, for humans?
07:26:52 <ddarius> @google "Imaginary numbers aren't real"
07:26:53 <lambdabot> http://www.madsci.org/posts/archives/2000-12/975852189.Ph.r.html
07:26:53 <lambdabot> Title: Re: Imaginary numbers aren't real, but aren't real numbers imaginary too?
07:26:59 <ddarius> Curses.
07:27:18 <scooty-puff> um this is a joke, yes?
07:27:22 <ddarius> @google "Imaginary numbers aren't real" geometric algebra
07:27:23 <lambdabot> http://mathforum.org/library/drmath/view/55736.html
07:27:23 <lambdabot> Title: Math Forum - Ask Dr. Math
07:27:31 <Cale> geheimdienst: The only point of using complex numbers and not just pairs of real numbers is the multiplication.
07:27:33 * ddarius forgot the exact name of the article.
07:27:42 <Veinor> @google "imaginary numbers are not real" geometric algebra
07:27:43 <lambdabot> http://www.mrao.cam.ac.uk/~clifford/introduction/intro/intro.html
07:27:43 <lambdabot> Title: Imaginary Numbers are not Real - the Geometric Algebra of Spacetime
07:28:02 * geheimdienst multiplies computers all the time
07:28:39 <j-invariant> so called "IQ" is ad-hoc
07:28:48 <ddarius> dafis: The vast majority of "real numbers" aren't even imaginable.
07:29:11 <j-invariant> maintaining crediability in IQ continues to damange the progpress towards an algorithmic theory of intelligence
07:29:18 <dafis> ddarius: I've never come across one I couldn't imagine
07:29:26 <Bynbo7> IQ is a very good measure of how good you are at taking IQ tests, and not a wholelot more
07:29:26 <accel> fa = foldl' foo ; fb = foldl' bar ; x = [1..10^8]; op fa x fb x <-- does stream fusion solve these two problesm simultaneously: (1) we don't want to generate x twice (2) we don't want to explicitly generate x; i.e. stream fusion allows us to only run throgh x once?
07:29:30 <ddarius> dafis: That's because they don't exist.
07:29:49 <dafis> ddarius: are you an intuitionist?
07:30:01 <ddarius> dafis: I'm worse than an intuitionist.
07:30:08 <dafis> ?
07:30:11 <Bynbo7> accel: no, because there's nothing being streamed between the two
07:30:52 <Cale> The vast majority of natural numbers aren't even imaginable.
07:30:54 <EvanR-work> imaginable numbers?
07:30:55 <Bynbo7> stream fusion happens when you compose functions like map, filter, take, drop, and at time foldl/r
07:30:56 <accel> Bynbo7: how does this differ from sum x / length x ?
07:31:05 <ddarius> Cale: Agreed.
07:31:23 <Bynbo7> accel: it doesn't, and what's why sum x / fromIntegral (length x) performs quite badly
07:31:24 <EvanR-work> i can imagine any number, i just cant tell you much about any given one
07:31:28 <j-invariant> why do people study the numbers if they wont even come up in practice?
07:31:29 <geheimdienst> so for something to be "real", it has to be imaginable?
07:31:44 <Cale> Placing a constraint of imaginability on numbers afaict will just result in ugly number systems satisfying few universal properties.
07:31:47 <j-invariant> could there be a very large number whcih has contradictory properties?
07:31:48 <Bynbo7> j-invariant: to see if they're useful i guess
07:32:09 <EvanR-work> can someone clarify, is imaginability a well defined property
07:32:15 <Veinor> j-invariant: yes, but not in the way you think
07:32:20 <Veinor> well, kind of
07:32:29 <Cale> j-invariant: Because excluding "bad" numbers is more awkward than living with them.
07:32:36 <Bynbo7> accel: the thing is, it's much easier to just write code that will perform well there than it is to write an optimisation that can see that pattern and then optimise it
07:32:39 <j-invariant> Veinor: really!?
07:32:48 <ddarius> EvanR-work: You could provide one, e.g. Kolmogorov complexity that will fit in the information capacity of the known universe.
07:32:57 <ddarius> That would be a reasonably safe upper bound.
07:33:01 <EvanR-work> sounds like a finitism thing
07:33:13 <Veinor> j-invariant: you can define cardinal numbers such that their existence requires more axioms than ZFC
07:33:33 <ddarius> As far real numbers, most of them are practically -defined- as unimaginable.
07:33:35 <sepp2k> If I do something like  mapM_ print (take n $ iterate f x)  and f runs in O(1) space, does Haskell guarantee that the whole expression runs in O(1) space? In other words which assumptions am I allowed to make about when the GC runs when reasoning about space?
07:33:53 <accel> ! <- store this thing strictly; is there an anti-! which says: don't expclitly generate this list out & cache it; always store it as a thunk, and re-calculate if necessary on yte fly
07:33:54 <Cale> There are real numbers whose existence depends on the existence of large cardinals.
07:34:05 <Bynbo7> sepp2k: there are no guarantees made about that
07:34:16 <Veinor> well
07:34:22 <Veinor> you're guaranteed that it'll run in O(n) space
07:34:29 <Veinor> ;)
07:34:41 <Bynbo7> accel: no, it doesn't make much sense to, except in quite rare (and easily avoidable) cases
07:34:46 <ddarius> Veinor: Where is that guaranteed?
07:34:48 <sepp2k> Ok and if I remove the take n  I'm not guaranteed that it won't crash?
07:34:55 <accel> Bynbo7: the sum/length example we see above could easily use this
07:35:01 <accel> Bynbo7: as I don't mind running hrough the list twice
07:35:04 <Bynbo7> sepp2k: not guaranteed, but it probably won't
07:35:07 <Veinor> oh, whoops, i misread
07:35:22 <Bynbo7> accel: then you're doing twice the work you need to
07:35:34 <hape01> on my windows pc hasktags does not append correctly (-a option)  do you use hasktags under windows without cygwin, and use the append option of hasktags? that would be interesting for me...
07:35:42 <Cale> For example, Zero sharp can be expressed in the form of a real number (though it's more naturally a set of formulas)
07:36:30 <ddarius> accel: People have suggested such a thing and it may well be added in the not distant future.
07:36:36 <ddarius> (Added to GHC that is.)
07:36:56 * hackagebot pacman-memcache 0.1.0.0 - Read whole Pacman database which pushes it into the memory cache  http://hackage.haskell.org/package/pacman-memcache-0.1.0.0 (KrzysztofSkrzetnicki)
07:37:43 <accel> Bynbo7: twice the work = 2x slow down at worst (if this thing is the most important part of the code); on the other hand, storing this list around ... will cause a crash / program to die / swap out of memory
07:37:48 <Cale> ddarius: What do you think about the continuum hypothesis?
07:37:56 * hackagebot pacman-memcache 0.1.0.1 - Read whole Pacman database which pushes it into the memory cache  http://hackage.haskell.org/package/pacman-memcache-0.1.0.1 (KrzysztofSkrzetnicki)
07:38:13 <Cale> Personally I lean in the direction of not CH.
07:38:18 <j-invariant> Cale: why study numbers in general since we can only ever see a specific finite set
07:38:29 <Cale> (that is, that there is a cardinal between the cardinalities of N and R)
07:38:31 <sepp2k> The reason I ask is that there's a code golf problem asking for O(1) space solutions and I'm trying to figure out whether I can somehow use Haskell anyway.
07:38:40 <Bynbo7> accel: but, writing code that avoids these problems is trivial, and has much greater payoffs than what you're asking for
07:38:42 <j-invariant> who cares that "almost all numbers are normal"?
07:38:44 <ddarius> Cale: I mostly don't think about it.  I say use whichever you want when you need to.  I never need to.
07:38:55 <j-invariant> we only have access to a tiny *exceptional* fraction of the whole 
07:39:08 <accel> Is it possible to write a single function f, s.t. f (1) -> (2); f (1,2) -> (2,4); f(1,2,3)->(2,4,6) ... i.e. it can take a arbitrary-sized tuple of integers; and doubles each of them
07:39:11 <Bynbo7> sepp2k: you can guarantee it if you write things out by hand and use the appropriate strictness
07:39:22 <j-invariant> accel: yes you have to use typeclasses
07:39:24 <quicksilver> accel: what would its type be?
07:39:31 <accel> Bynbo7: I concede that point to you; i'm just lazy and like typing sum / length
07:39:36 <Cale> j-invariant: Because proving things which are true about all the numbers which we actually deal with is simpler if we consider a larger more uniform set of numbers that they belong to.
07:39:39 <accel> Bynbo7: rather than all the refactoring RWH does
07:39:48 <accel> quicksilver: it needs to have an infinite number of types
07:39:56 <quicksilver> accel: and there is your answer.
07:39:57 * hackagebot pacman-memcache 0.1.0.2 - Read whole Pacman database which pushes it into the memory cache  http://hackage.haskell.org/package/pacman-memcache-0.1.0.2 (KrzysztofSkrzetnicki)
07:39:58 <accel> quicksilver: of Int -> Int; (Int, Int) -> (Int, Int), .... 
07:40:04 <Bynbo7> it's hardly a lot of refactoring. the fact you think it is shows you're getting used to how small haskell programs are though :P
07:40:08 <accel> quicksilver: so no ?
07:40:16 <dafis> Cale: have you any reason to lean towards no-CH or is it just a matter of taste/gut-feeling?
07:40:24 <quicksilver> accel: if you want something to have more than one type, you need to use polymorphism.
07:40:38 <accel> quicksilver: so how do I solve this problem?
07:40:40 <Cale> dafis: I have a bit of a reason. Obviously it can't be completely formal :)
07:40:43 <quicksilver> accel: since that doesn't match any parametric scheme (the types don't all have the same form) it will have to be typeclass parametric.
07:40:48 <Kaidelong> how does Haddock interact with lhs2tex?
07:40:53 <hape01> which is the function which returns True?
07:40:54 <quicksilver> accel: which problem?
07:41:00 <Kaidelong> is it feasible to use both or do I have to choose?
07:41:02 <j-invariant> Cale: but it doesn't tell anything! about the numbers we see in day to day
07:41:03 <dafis> Cale can you expand it a bit here?
07:41:06 <quicksilver> hape01: (const True) ?
07:41:08 <accel> quicksilver: the f I described above; what should I be googling/ /reading up on?
07:41:09 <danharaj> :t unfold
07:41:10 <lambdabot> Not in scope: `unfold'
07:41:16 <danharaj> blah where is unfold defined
07:41:23 <quicksilver> accel: that's not a problem that needs to be solved.
07:41:26 <ddarius> Kaidelong: There should be no particular interaction either way.
07:41:28 <quicksilver> accel: that's an artificial construct.
07:41:30 <Bynbo7> :t unfoldr
07:41:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:41:37 <hape01> quicksilver: the const is an reserved haskell word?
07:41:44 <quicksilver> accel: reall programming problems have motivation and context, which helps us find a good solution.
07:41:47 <Bynbo7> hape01: no, it's a function
07:41:47 <danharaj> @src unfoldr
07:41:47 <lambdabot> unfoldr f b  = case f b of
07:41:47 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
07:41:48 <lambdabot>    Nothing        -> []
07:41:48 <quicksilver> hape01: no, it's a normal functin.
07:41:49 <Bynbo7> @src const
07:41:50 <lambdabot> const x _ = x
07:41:54 <hape01> quicksilver: Thank you
07:41:56 <danharaj> @wherethehellis unfoldr
07:41:56 <lambdabot> Unknown command, try @list
07:42:20 <Bynbo7> @wtf unfoldr
07:42:20 <lambdabot> Maybe you meant: bf ft wn
07:42:25 <Kaidelong> ddarius: but the haddock documentation would show in the Latex output, right?
07:42:29 <Kaidelong> I guess that is not a big deal
07:42:36 <danharaj> aha. Data.List.
07:42:44 <Cale> dafis: Okay. So let's start by well-ordering the real numbers using AC.
07:42:47 <quicksilver> accel: class Doubleable x where double :: x->x; instance Doubleble Int where double = (*x); instance Doubleable (Int,Int) where double (a,b) = (a*2,b*2); etc.
07:43:24 <Cale> dafis: We can put R in bijection with the smallest ordinal number with the cardinality of the continuum.
07:43:32 <dafis> Cale yes, sure
07:43:58 <Cale> and then every subset/element of that ordinal is then countable
07:44:07 <dafis> yes
07:44:12 <benedikt> how does haskell check if an atom is in the list. Consider 4 `elem` [x*2 | x <- [1..10]], would it simply check the head and recur on the tail if false?
07:44:17 <Cale> So we've well-ordered R in such a way that the set of predecessors of any real number is countable.
07:44:23 <accel> Bynbo7: abstractly, I feel like (when looking at my code), if I have a lazy list "x"; and all the functions I apply to x are of the form foldl; then ... I should just amke sure they all happen at once, does that generalizes to our discussion
07:44:31 <Cale> Which I feel is already a bit strange.
07:44:32 <dafis> benedikt: yes
07:44:44 <Cale> But maybe not a reason to adopt not CH on its own.
07:44:52 <benedikt> dafis: so the worst case is O(n) where n is the number of atoms in the list?
07:44:59 <accel> quicksilver: got it; thanks
07:45:02 <dafis> Cale: strange, yes, but AC has some strange consequences
07:45:12 <quicksilver> Cale: is that inherently stranger than well-ordering N such that the set of predecessors of any natural number is finite?
07:45:14 <dafis> benedikt: yep
07:45:16 <hape01> quicksilver: But I had not understand completely.... why does the function  (const True)  accepts one parameter? I 
07:45:24 <Cale> quicksilver: I think so.
07:45:37 <quicksilver> Cale: (which is a similar looking statement with uncountable -> countable; countable -> finite)
07:45:38 <benedikt> dafis: nice. thanks. 
07:45:47 <Cale> quicksilver: I'm okay with the cardinality of the set of predecessors being less than the cardinality of R.
07:45:51 <quicksilver> hape01: because that's what const does.
07:46:00 * hackagebot TrieMap 3.0.0 - Automatic type inference of generalized tries with Template Haskell.  http://hackage.haskell.org/package/TrieMap-3.0.0 (LouisWasserman)
07:46:07 <dafis> Cale: what if you leaned towards no-AC instead?
07:46:15 <hape01> quicksilver: it accepts one parameter which it ignores. 
07:46:25 <quicksilver> hape01: right.
07:46:33 <hape01> quicksilver: Is there a const function which does not accept an parameter?
07:46:35 <quicksilver> hape01: const builds functions which take one parameter (and ignore them)
07:46:42 <quicksilver> hape01: that would, then, not be a function.
07:46:56 <Cale> dafis: Without AC, cardinalities are incomparable.
07:46:59 <quicksilver> hape01: (True) is a value which is.. well.. always True, and takes zero parameters.
07:47:02 * hackagebot TrieMap 3.0.1 - Automatic type inference of generalized tries with Template Haskell.  http://hackage.haskell.org/package/TrieMap-3.0.1 (LouisWasserman)
07:47:08 <Cale> dafis: So CH doesn't even make a whole lot of sense :)
07:47:18 <hape01> quicksilver: there is no function which does not accept one parameter?
07:47:21 <Cale> (It does make sense, but it's a bit weirder)
07:47:25 <dafis> Cale: two problems at once ;)
07:47:27 <Veinor> Cale: doesn't |C| < |P(C)| hold?
07:47:37 <edwardk> did ghc 7 fix the     "The current implementation of type families does not
07:47:37 <edwardk>     support equality constraints in superclass contexts." error?
07:47:43 <quicksilver> hape01: functions take parameters, that is why they are functions.
07:47:52 <quicksilver> hape01: if you take 0 parameters you are not a funciotn.
07:48:00 * hackagebot pacman-memcache 0.1.0.3 - Read whole Pacman database which pushes it into the memory cache  http://hackage.haskell.org/package/pacman-memcache-0.1.0.3 (KrzysztofSkrzetnicki)
07:48:17 <hape01> quicksilver: Ok  I see
07:48:23 <ddarius> edwardk: I'm pretty sure it did.
07:48:25 <dafis> Cale: but I must say, not-AC would confuse me madly, how could a product of nonempty spaces be empty?
07:48:25 <hape01> quicksilver: :-) thank you
07:48:27 <edwardk> I want class (TraversableWithKey1 (Trie a), Representable (Trie a), Key (Trie a) ~ a) => HasTrie a where type Trie a :: * -> *
07:48:30 <Cale> Veinor: Normally it does, yes. (And I think it still holds without AC, but I'd have to think about that)
07:48:46 <Veinor> yeah, I meant without AC.
07:48:50 <edwardk> ddarius: k. the next version of adjunctions will apparently be ghc 7.0 only unless i split off the trie code
07:49:01 <accel> mean xs = s / fromIntegral n
07:49:01 <accel>   where
07:49:01 <accel>     (n, s)     = foldl k (0, 0) xs
07:49:02 <accel>     k (n, s) x = (n+1, s+x)
07:49:04 <accel> is so beautiful
07:49:08 <Veinor> also, iirc |3xA| = |3xB| <=> |a| = |B|
07:49:10 <Veinor> even without choice
07:49:12 <accel> the way k is just defined right in the code
07:49:45 <Veinor> http://www.math.dartmouth.edu/~doyle/docs/three/three.pdf yep
07:49:53 <Bynbo7> accel: not at performant as it could be though
07:50:04 <accel> of course
07:50:13 <accel> why is fold' only "outer" strict
07:50:13 <Saizan> edwardk: the message changed :D "Alas, GHC 7.0 still cannot handle equality superclasses: a ~ b"
07:50:15 <accel> this doesn't amke sense to me
07:50:27 <accel> is there no way to make fold' STRONG-headed -normal-form ?
07:50:32 <accel> i.e. make the head fully fully strict
07:50:42 <Bynbo7> you should really check out the vector package, and don stewart's posts on stream fusion... and well anything on his blog 
07:51:21 <quicksilver> accel: well if you choose your own function, then yes.
07:51:35 <edwardk> saizan: shit. there goes my last 2 days work =/
07:51:39 <Bynbo7> accel: it's calles normal form. if you used the deepseq package it could be, but it would perform badly because then the code would keep trying to reevaluate things that are already evaluated
07:52:01 <accel> @src using
07:52:01 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:52:21 <Cale> What do people think about this statement:  for any f: R -> N, (a function from the reals to the naturals), there exist distinct real numbers x,y,z,w such that x + y = z + w and such that f(x) = f(y) = f(z) = f(w).
07:52:33 <accel>  k (!n, !s) x = (n+1, s+x) <-- how does this differ from deepseq ?
07:52:55 <Bynbo7> accel: it depends on the types of the x's there
07:52:57 <quicksilver> foldl'' f a (x:xs) = let v = f x a in v `deepseq` foldl'' f v xs
07:53:12 <quicksilver> accel: like that, although that will put a class constraint on your list.
07:53:32 <Cale> That statement is independent of ZFC :)
07:53:48 <Cale> It is in fact equivalent to not CH.
07:53:48 <Veinor> haha, it is? that's awesome
07:53:58 <Veinor> ...
07:54:00 <accel> Bynbo7 , quicksilver : cool; thanks; I think I finally understand the point of the transforms in chapter 25 now
07:54:01 <Veinor> that's even more awesome
07:54:07 <Cale> http://www.cs.umd.edu/~gasarch/BLOGPAPERS/radozfc.pdf
07:54:41 <Veinor> i love how you can come up with random stuff that's equivalent to CH or AC or their negations
07:55:16 <dafis> Cale: Veinor is right, that's pretty awesome
07:56:14 <Cale> Well, a little bit of exploration of that problem starts to reveal how it really does have the feel of a set theory question. Functions R -> N in general have that sort of subtlety to them, since you can't really get much out of the nice properties of R while studying them.
07:56:16 <Veinor> http://www.xamuel.com/internet-surfing-ordinals/
07:57:23 <hape01> :t 3
07:57:24 <lambdabot> forall t. (Num t) => t
07:57:38 <kulakowski> Cale: Yeah, R isn't a very particularly nice set in this question, just a big one, but _how_ big?
07:57:39 <hape01> :t const 3
07:57:39 <lambdabot> forall t b. (Num t) => b -> t
08:01:12 <tolkad> it would be cool if you could tell ghc to evaluate a thunk at compile time
08:01:24 <quicksilver> you can with TH
08:01:38 <quicksilver> well, an expression rather than a thunk.
08:02:03 <tolkad> wait, sorry expressions are evaluated, thunks are executed?
08:02:10 <tolkad> or are thunks evaluated too?
08:02:16 <tolkad> I'm kind of confused on the terminology
08:02:36 <tolkad> I guess it's not important
08:02:44 <Cale> tolkad: I think of thunks as simply being the machine representation of not-completely-evaluated expressions.
08:03:05 <Cale> I tend not to even use the word "thunk" and instead prefer to just talk about expressions directly.
08:03:46 <jix> How to come up with a good name for a graph data structure? Data.Graph is taken and not very descriptive.
08:04:21 <mux> conal: ping
08:04:32 <conal> mux: hi
08:04:40 <kulakowski> jix: What sort of graphs? What implementation?
08:05:01 <mux> conal: hi there! I just found a new way to encode bounded natural numbers at the type level that allows me to type take :-)
08:05:24 <conal> mux: sweet!
08:05:49 <conal> mux: i've been noodling over similar things.
08:05:54 <tolkad> jix: Data.NodeRelation
08:05:55 <conal> mux: i look forward to seeing yours.
08:06:04 <conal> mux: do you blog?
08:06:12 <mux> conal: I index Fin over its value as well as over the value it's less than
08:06:20 <mux> data Fin m n where FZero :: Fin Z (S n) FSucc :: Fin m n -> Fin (S m) (S n)
08:06:27 <mux> then I can have:
08:06:32 <tolkad> mux: why not just encode them in binary?
08:06:32 <deech> Hi all, is there some elegant way of dealing with lookup in structures like Data.Map which return Maybe values? My code is littered with case statements that do one thing if a value is found and another if it isn't. 
08:06:34 <mux> take :: Fin m n -> Vec n a -> Vec m a
08:06:39 <scooty-puff> does any sort of monad combinator like (>=) :: (a -> m b) -> (a -> m c) -> a -> m c exist?
08:06:40 <tolkad> mux: at the type level that is
08:06:45 <jix> kulakowski: basically I store a map from keys to vertices which store refernces to other vertices...
08:06:46 <scooty-puff> i.e. (a >= b) x = a x >> b x
08:06:54 <mux> tolkad: I haven't found the need for that yet
08:06:59 <accel> Bynbo7: x = [1..10^8]; f x <-- somewhere deep in this, we need to calcualte foldl (+) x; foldl (*) x; in "g x" <-- somewhere we need to calcualte length x; now, we have (f x) / (g x) <-- how do we optimize this? seems like we need to utterly unwrap f & g
08:07:01 <conal> mux: ah. nice.
08:07:03 <mux> conal: nope, I still don't blog
08:07:07 <doserj> :t (>=>)
08:07:07 <jix> kulakowski: and I want to support efficient merging of graphs and nodes
08:07:08 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:07:23 <tolkad> jix: Data.NodeRelation. a perfect description
08:07:26 <scooty-puff> then idea is pipe a
08:07:27 <scooty-puff> not b
08:07:30 <scooty-puff> *the
08:07:39 <scooty-puff> a -> m b, a -> m c
08:07:43 <scooty-puff> sort of a fan?
08:07:56 <doserj> ah
08:07:58 <conal> mux: have you also tried take :: Fin m -> Vec (m :+: n) -> Vec n ?
08:08:05 <jix> tolkad: I don't think so.
08:08:10 <conal> mux: (i haven't tried)
08:08:13 <mux> conal: yeah, with no luck
08:08:14 <Bynbo7> scooty-puff: >=>
08:08:14 <scooty-puff> (>>) <$> a <*> b
08:08:16 <scooty-puff> i think does it
08:08:17 <tolkad> jix: hmm, I have other ideas
08:08:18 <Bynbo7> :t (>=>)
08:08:21 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:08:22 <scooty-puff> Bynbo7, not the right type
08:08:22 <mux> conal: but that's a bit non-sensical
08:08:32 <tolkad> jix: Data.MappingBetweenTwoSetsOfNodes
08:08:36 <conal> mux: oh yeah.  oops.
08:08:46 <tolkad> jix: or I guess that's kind of inaccurate
08:08:47 <scooty-puff> :t (>>) <$> const mempty <*> const mempty
08:08:47 <lambdabot> forall (m :: * -> *) a b b1. (Monad m, Monoid (m a), Monoid (m b)) => b1 -> m b
08:08:52 <scooty-puff> meh
08:08:55 <scooty-puff> ok not that either
08:08:56 <conal> take :: Nat m -> Vec (m :+: n) -> Vec n ?
08:09:01 <mux> I think you meant Fin m -> Vec (m :+: n) a -> Vec m a
08:09:02 <scooty-puff> :t (>>) <$> const mzero <*> const mzero
08:09:03 <lambdabot> forall b (m :: * -> *) a. (MonadPlus m) => b -> m a
08:09:04 <conal> mux: ^^ ?
08:09:15 <Bynbo7> :t \f g -> liftM2 (>>) f g
08:09:16 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
08:09:18 <mux> well both don't really make sense
08:09:26 <tolkad> jix: Data.SetOfAssociationsBetweenTwoNodesInASetOfNodes
08:09:29 <scooty-puff> Bynbo7, for (->), right?
08:09:35 <Bynbo7> scooty-puff: yes
08:09:37 <mux> since when we have a Fin n we know we have a number less than n, but we don't know which
08:09:54 <danharaj> So here's a problem I'm working on. I have a type that represents streams of time-value pairs, event streams if you will.
08:09:57 <jix> tolkad: -_-
08:09:58 <conal> mux: yeah. how about Nat instead?
08:10:08 <dafis> deech: depending on what you want to do when the looked up value isn't present, findWithdefault, Data.Map.! ?
08:10:21 <danharaj> I want event streams to be able to depend on each other. But I need to guarantee that the dependency doesn't break causality (present depending on future)
08:10:25 <mux> conal: you'd return Vec m
08:10:47 <tolkad> jix: Data.GraphCalculus?
08:10:48 <mux> conal: other than that it makes sense, but I don't think you can actually implement that type with GHC
08:10:54 <conal> mux: ah, yeah. :)
08:10:59 <conal> mux: i'm going now to help move a heavy woodstove. will be back in 30-60minutes or so.
08:11:04 <tolkad> jix: Data.GraphOperations
08:11:16 <tolkad> jix: Data.GraphCombinators
08:11:28 <jix> tolkad: I'm really looking for something more specific than graph
08:11:37 <conal> mux: how about drop :: Nat n -> Vec (n :+: m) -> Vec m ?
08:11:48 <mux> conal: alright, have a look at https://bitbucket.org/mumux/stuff/src/d32efd40161b/Vector.hs when you're back, there are a few new other things
08:11:55 <mux> conal: makes sense yeah
08:11:57 <conal> this stuff is too fun. :)
08:12:00 <conal> later.
08:12:03 <kulakowski> jix: Aribtrary graphs? Forests? Directred or not?
08:13:03 <jix> kulakowski: Directed, basically it's like an IntMap CustomTypeContainingInts.
08:13:07 <mux> oh, there's a bug
08:13:41 <jix> kulakowski: but the Type has to implement a typeclass that allows mapping over the stored keys, so graph operations can rename vertices
08:14:18 <mux> or maybe that's a feature
08:14:37 <mux> nah, definitely a bug
08:14:52 <mux> the type of my take function is actually take :: Fin m (S n) -> Vec n a -> Vec m a
08:14:59 <mux> otherwise I can't take the whole list
08:15:16 <kulakowski> jix: I'd just do MergeableGraph or some such, emphasize that.
08:15:24 <jix> my use case for this are control flow graphs... but it's more general than that
08:15:28 <mux> yay, works fine
08:16:39 <tolkad> jix: Data.Graph.KeyStore, Data.MapGraph, Data.Map.Graph?
08:21:08 <zygoloid> Cale: your R -> N question... what happens if you pick a finite codomain? it seems intuitively obvious the property should hold then.
08:22:58 <earthy> mzo. huiswaarts.
08:29:27 <mux> +drop :: Fin m (S n) -> Vec n a -> Vec (n :-: m) a
08:29:31 <mux> ouh yeah
08:32:09 <hape01> can a pure lazy Haskell function call a I/O functions?
08:32:23 <pumpkin> I can't believe http://hpaste.org/43622/overlapping_type_families typechecks
08:32:54 <sipa> hape01: depends on what you call an I/O function
08:33:05 <pozic> hape01: there is no such thing as calling an I/O function in theory.
08:33:05 <jacobian> @pl maybe (throwError e) return x
08:33:05 <lambdabot> maybe (throwError e) return x
08:33:25 <jacobian> @pl \ x e -> maybe (throwError e) return x
08:33:25 <lambdabot> flip (flip maybe return . throwError)
08:33:29 <hape01> sipa, pozic: e.G. doesDirectoryExist in System.Directory
08:33:32 <jacobian> yuck!
08:33:36 <quicksilver> hape01: I think the answer you want is "no"
08:33:37 <pozic> hape01: but if you mean constructing an I/O action which will be run by GHC when you execute the program, then your question is sort of undefined.
08:33:51 <quicksilver> although as pozic and sipa are pointing out, your question is not as simple as it seems.
08:33:55 <hape01> sipa, pozic, quicksilver: thanks
08:34:16 <quicksilver> 'putStrLn' is, in fact, a pure function; you call it like (putStrLn "hello") which produces an IO action - quite purely.
08:34:28 <quicksilver> it doesn't actually *do* anything until you arrange for that IO action to be evaluated.
08:34:40 <sipa> hape01: as quicksilver said, the short answer you want is "no", the longer answer is "yes, but it's dirty", and the correct answer is "you can call function producing IO actions just fine, and combine multiple IO actions is a perfectly pure way... however, that doesn't involve *executing* them"
08:34:42 <zygoloid> pumpkin: that's pretty cool. i wonder if that means they've relaxed the overlap checks
08:34:42 <quicksilver> so, pure functions can quite easily manipulate IO actions, btu they can't actually "do" IO.
08:35:09 <pozic> sipa: the only way in which you do it is completely undefined. 
08:35:10 <zygoloid> pumpkin: actually, i think that should be accepted by the 6.12 rules :)
08:35:20 <hape01> the question given was:   may i construct a function accepting a pure string, and returning a Bool, which decides if the Path specified by the pure string exists or not. Now I feel that i cant do that
08:35:31 <hape01> hape01: sure it does not work
08:35:40 <sipa> hape01: short answer: now, long answer, yes using unsafePerformIO
08:35:43 <hape01> pure functions cannot be influenced by IO
08:35:47 <sipa> but as the name suggests, it's unsafe
08:35:56 <hape01> sipa: ah yes unsafePerformIO
08:36:13 <pozic> But unsafePerformIO has no usable semantics. Go look it up.
08:36:44 <zygoloid> hape01: well, what you're asking for isn't a function (in the mathematical sense) because the result depends on the state of the filesystem, which could change between evaluations.
08:36:45 <jacobian> http://www.haskell.org/haskellwiki/Functor_hierarchy_proposal
08:36:49 <pozic> Unfortunately, that doesn't stop people from using it "because it works".
08:36:49 <jacobian> ^ What do people think of that? 
08:36:54 <sipa> usafePerformIO basically means "i know the world state won't change in a way that influences the outcome of what i ask... honestly, trust me!"
08:37:05 <pozic> sipa: no, it doesn't. 
08:37:18 <pozic> sipa: that is just what you hope it means. 
08:37:23 <pozic> (and often suggested by people)
08:37:28 <sipa> agree
08:37:32 <zygoloid> hape01: your program's semantics would depend on exactly when the filesystem check is performed, which might be quite worrying. fileExists x == fileExists x might sometimes be False!
08:37:36 <kfr> jacobian so at the end of the Functor -> Applicative -> Monad type hierarchy there lies failure
08:37:38 <kfr> Lots of it
08:37:42 <copumpkin> zygoloid: it makes me a little uncomfortable :P not sure if it's just a bug in HEAD (since I'm on it) [not sure if that got through before I got disconnected]
08:37:56 <hape01> zygoloid: now i remember, thank you
08:38:09 <zygoloid> copumpkin: what's wrong with it? the only instances which overlap are the first two, and the result is the same once the variables are unified.
08:38:20 <kulakowski> zygoloid: Do you have anything more than intuition for that R -> n problem?
08:38:32 <copumpkin> zygoloid: oh, I don't have any problem with it, but GHC has in the past, so I'm just worried :P
08:38:38 <jacobian> kfr: Does that mean you're opposed? 
08:39:01 <kfr> jacobian: No, it sounds good, I've heard people complain about this before
08:39:10 <zygoloid> kulakowski: i think i can see a rough sketch of how to prove it for R -> {0,1}
08:39:17 <jacobian> I was just wishing it, and started looking around and found it
08:39:45 <hape01> thank you for helping - bye
08:40:12 <jacobian> I obviously hadn't thought through all of the implications, but I had wanted map to be defined. 
08:42:31 <jonkri> the difference between the state and a reader monads is that a state can be modified?
08:42:57 <Bynbo7> yes
08:43:04 <sipa> modified persistently
08:43:13 <sipa> using reader you can also change it locally
08:43:40 <jonkri> ok
08:45:17 <mm_freak> jonkri: you really should look at the underlying functions
08:45:28 <mm_freak> state:  s -> (a, s)
08:45:32 <mm_freak> reader:  s -> a
08:45:35 <mm_freak> writer:  (a, s)
08:46:01 <Bynbo7> @unmtl RWST a b c d e
08:46:01 <lambdabot> a -> c -> d (e, c, b)
08:47:37 <mm_freak> jonkri: a state computation takes a state and returns a new state…  a reader computation only takes a state…  a writer computation only returns a new state…  of course nothing stops a reader computation from invoking (runReaderT) another reader computation, which is what sipa refers to as a local state change
08:47:43 <Bynbo7> @hoogle RWST
08:47:44 <lambdabot> Control.Monad.RWS.Lazy newtype RWST r w s m a
08:47:44 <lambdabot> Control.Monad.RWS.Lazy RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
08:47:44 <lambdabot> Control.Monad.RWS.Strict newtype RWST r w s m a
08:48:04 <rudi_s> Hi. I'm using QuickCheck to test a function and one possible parameter value should be ignored, in this case Empty (because the function fails for it). At the moment I have prop_test Empty = True ==> True ; prop_test x = .. ==> ... I'm sure there's a better way to handle that. Thanks (I'm a Haskell noob, so I hope this isn't a too stupid question).
08:49:41 <NemesisD> when using records, is there a better way to modify a field than pattern match on all fields and construct a new record? I know i'll have to construct a new record anyways but i was hoping there's some sugar for that
08:50:05 <mm_freak> NemesisD: \record -> record { field = newValue }
08:51:13 <Bynbo7> it would be nice if record fields could be used as an index into records, so you could say have a function: update field func
08:51:29 <mm_freak> yeah, that would be great
08:52:27 <danharaj> I just wrote (first (map $ first f) .) . g
08:52:29 <kfr> My biggest complaint with records is the need to use C style function prefixes because they are just dumped into the global namespace :'(
08:52:33 <danharaj> I feel like a pervert.
08:52:36 <NemesisD> mm_freak: so say i had an items field that was an array of integers, addOne rec i = rec { items = (items ++ i) } ?
08:53:00 <danharaj> :t (first (map $ first f) .) . g
08:53:01 <lambdabot>     Ambiguous occurrence `f'
08:53:01 <lambdabot>     It could refer to either `L.f', defined at <local>:1:0
08:53:01 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
08:53:20 <quicksilver> NemesisD: addOne rec i = rec { items = items rec ++ i }
08:53:25 <Kaidelong> @ty (first (map $ first f) .) . g
08:53:25 <quicksilver> NemesisD: (yes, it's a bit annoying)
08:53:26 <lambdabot>     Ambiguous occurrence `f'
08:53:26 <lambdabot>     It could refer to either `L.f', defined at <local>:1:0
08:53:26 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
08:53:32 <NemesisD> oh yeah
08:53:35 <mm_freak> NemesisD: "items rec", not "items"
08:53:38 <Kaidelong> huh
08:53:43 <Kaidelong> what is local?
08:53:47 <Kaidelong> or L for that matter?
08:53:50 <danharaj> :t (\f g -> (first (map $ first f) .) . g)
08:53:51 <lambdabot> forall b c d d1 (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (b -> c) -> f1 (f ([(b, d)], d1)) -> f1 (f ([(c, d)], d1))
08:54:15 <danharaj> I love how the structure of the type is so plainly obvious from the form.
08:54:21 <mauke> @undefine
08:54:24 <danharaj> (well it's more obvious if you do it by hand)
08:54:26 <NemesisD> i still don't have a great intuition for parentheses in haskell
08:54:29 <mm_freak> kfr: well, they are not dumped to the global namespace, but to the module namespace
08:54:41 <kfr> module-global :p
08:54:41 * Kaidelong dug up a function in his code with type "(Functor f) => f (Maybe a) -> a" and is still trying to figure out what it was for
08:54:46 <mm_freak> kfr: but yes, i agree, it's annoying
08:54:55 <Kaidelong> it was called "cfix"
08:55:13 <Kaidelong> f (Maybe a) -> f a
08:55:15 <Kaidelong> I mean
08:55:18 <kfr> mm_freak has any of this been addressed in Haskell Prime or Haskell 2011?
08:55:18 <danharaj> You can pretty much tell I was writing an fmap instance.
08:55:20 <mm_freak> NemesisD: it never hurts to have too many parentheses…  for some reason many haskellers have the obsession to avoid them where possible
08:55:25 <zygoloid> Bynbo7: would be nice if  data Record = Rec { foo :: Int }  implicitly declared something like  foo :: FieldAccessor (<->) => Record <-> Int  instead of just foo :: Record -> Int :)
08:55:27 <mm_freak> kfr: i don't think so
08:55:39 <kfr> mm_freak: Haha yes, I always try to use $ over ()
08:55:50 <kfr> I will rewrite code to use as few () as possible
08:55:55 <mm_freak> i don't
08:55:58 <mauke> mm_freak: I disagree with "it never hurts"
08:55:58 <mm_freak> print (show 5)
08:56:10 <mm_freak> perfectly readable and IMO better than "print $ show 5"
08:56:27 <Philippa> I don't try to minimise them, but I do try to avoid situations where they're nested enough to make editor paren matching substantially useful and I can't comfortably use whitespace to hint it
08:56:31 <quicksilver> mauke: (perhaps (you've ((seen) (too much) lisp))) (in (your (time)))) ?
08:56:43 <mauke> yes
08:57:00 <mm_freak> mauke: well, once you know the operator priorities better you can start to have less of them
08:57:03 <copumpkin> Saizan: didn't you and pigworker figure out how to translate from psuedo-hoas to de bruijn using funky typeclasses?
08:57:08 <copumpkin> Saizan: I can't remember where I saw that
08:59:34 <copumpkin> oh, epilogue
09:01:27 <mm_freak> quicksilver: your parentheses are not balanced
09:01:37 <quicksilver> mm_freak: that's part of the point, I think ;)
09:01:57 <quicksilver> mm_freak: (that it's hard to correctly balance parens when you have a lot, and hard for readers to instantly see the error)
09:02:11 <quicksilver> obviously editor tools and formatting conventions help.
09:02:54 <mm_freak> yeah…  when coding lisp you really need a good and consistent indentation style
09:03:11 <mm_freak> but it's not that bad, once you get used to it
09:05:21 <jacobian> Is there an fmap for Error monads?
09:05:35 <quicksilver> all monads have fmap
09:05:49 <quicksilver> > fmap (+1) (Right 5)
09:05:50 <lambdabot>   Right 6
09:06:00 <quicksilver> jacobian: but perhaps you wanted something which operates on the error value?
09:06:18 <zygoloid> all Monads have liftM, which is the functorial map
09:08:38 <jonkri> ok. i will look at the underlying functions
09:09:49 <jonkri> is there a nice way to implement something similar to java's parent loggers which pipe library logs into the main application's logging class? like a logger can be configured to log itself, don't log at all or log through some other application's process or something
09:10:20 <jonkri> if they are all using the same logger, that is
09:11:14 <quicksilver> jonkri: http://hackage.haskell.org/package/hslogger-1.1.3 has some log4j-like features
09:11:18 <quicksilver> jonkri: I've never used it though
09:15:01 <jonkri> quicksilver: thanks i know, unacceptable license though
09:15:51 <quicksilver> well, I don't think so, but it's your call.
09:15:59 <c_wraith> LGPL is unacceptable?  It's not even relevant unless you modify the hslogger code
09:16:24 <copumpkin> knee-jerk against substring("GPL", license) = true
09:16:25 <copumpkin> :P
09:16:52 <Philippa> c_wraith: the relinking requirements are relevant still, no?
09:17:11 <stepkut> c_wraith: I heard there are still issues due to GHC static linking
09:17:54 <Philippa> jonkri: you could pull off something like that using a logging framework based around concurrency and Chans
09:19:03 <jonkri> quicksilver, c_wraith: i don't mind the gpl licenses. in fact, i often use them myself. someone told me that linking against lgpl libraries with ghc compiled applications results in pretty much the same terms as if the library was under the gpl
09:19:21 <quicksilver> don't believe everything you hear.
09:19:38 <quicksilver> the linking requirement just requires you to make it possible for people to upgrade the library.
09:20:00 <quicksilver> you can satisfy that by providing source (under any license which makes it usable - not necessarily GPL) 
09:20:12 <quicksilver> or, even, you can provide unlinked .o files, although that doesn't work well with haskell.
09:20:12 <jonkri> Philippa: that is what i had in mind (concurrency, channels)
09:21:16 <jonkri> thanks for the clarification, quicksilver 
09:23:24 <matthiasgorgens> @pl \a -> a
09:23:24 <lambdabot> id
09:23:55 <matthiasgorgens> @pl \xs -> map (f xs) . g)
09:23:55 <lambdabot> (line 1, column 22):
09:23:55 <lambdabot> unexpected ")"
09:23:55 <lambdabot> expecting letter or digit, variable, "(", ".", "`", "!!", operator or end of input
09:24:09 <matthiasgorgens> @pl \xs -> map (f xs) . g
09:24:09 <lambdabot> (. g) . map . f
09:24:31 <matthiasgorgens> @pl \xs -> map (set_carriar xs) . filter_map
09:24:31 <lambdabot> (. filter_map) . map . set_carriar
09:24:43 <matthiasgorgens> @pl \xs -> map (set_carrier xs) . filter_map
09:24:44 <lambdabot> (. filter_map) . map . set_carrier
09:25:45 <matthiasgorgens> @pl f (\xs -> map (set_carrier xs) . filter_map)
09:25:45 <lambdabot> f ((. filter_map) . map . set_carrier)
09:28:40 <Philippa> jonkri: odds are you can implement something faster than you can find it, then :-)
09:29:01 <aristid> @hoogle readHex
09:29:01 <lambdabot> Numeric readHex :: Num a => ReadS a
09:29:01 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
09:29:37 <Philippa> you'll need logToDisk threads, threads that forward from one chan to another, what else?
09:34:02 <jonkri> Philippa: i'm a total newbie, so it will take a while :P i think i will have to start with the data types and just get a simple state/reader monad and logging process working
09:34:07 <accel> Bynbo7: besides chapter 25 of RWH; what's worth reading for haskell perforamnce tweaking
09:34:48 <Philippa> jonkri: fair enough. Control.Concurrent and Control.Concurrent.Chan when you want to start playing with concurrency in the IO monad
09:35:17 <jonkri> does hslogger work with concurrency? (would this logging library actually contribute?)
09:36:15 <lewis> hello I could use some help figuring how to change which folder ghc expects to find my .hs files in
09:36:30 <stepkut> jonkri: hslogger is slow and LGPL encumbered.. something fast and BSD3 would definitely be valuable :)
09:36:34 <jonkri> lewis: the current directory will do fine, i believe
09:36:47 <quicksilver> jonkri: I would guess it must be concurrency safe, because it's used by happstack and other things
09:36:53 <quicksilver> jonkri: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/hslogger-1.1.3
09:38:43 <lewis> I have a shared computer and where ghc naturally looks for the files in in anothers folder
09:38:55 <Philippa> jonkri: if nobody's written it already then putting an official interface to the folklore is definitely a contribution - it gives canonical names, things like that
09:40:14 <jonkri> ok cool
09:40:33 * hackagebot dyre 0.8.6 - Dynamic reconfiguration in Haskell  http://hackage.haskell.org/package/dyre-0.8.6 (WillDonnelly)
09:40:41 <jonkri> i will start with something simple and reader-based, since i need to learn to use monads either way :P
09:41:24 <lewis> maybe i should come back later
09:41:44 <jonkri> lewis: what os are you using?
09:41:50 <lewis> osx
09:41:55 <jonkri> lewis: are you using a terminal?
09:42:01 <lewis> yes
09:42:20 <lewis> and GHHC
09:42:26 <lewis> ghci i mean
09:42:48 <jonkri> lewis: do you understand the concept of file system hierarchies and what the current working directory is?
09:42:55 <lewis> no
09:43:05 <kfr> D:
09:43:30 <jonkri> lewis: the current working directory is the directory that you are "standing in", like the current directory when you are browsing your file system using finder
09:43:49 <jonkri> when you start ghci and tries to load modules using ":l ModuleName", it will look in that directory
09:44:04 <lewis> ok
09:44:11 <jonkri> the directory is shown to the left of the marker when you start your terminal
09:44:20 <jonkri> but it should be your home directory or something
09:44:30 <jonkri> compare it with where you have put your files using finder
09:44:41 <jonkri> and try to find a terminal/unix tutorial online
09:45:44 <jonkri> and you will have to be patient. learning this will have its rewards down the road though
09:47:41 <dahankzter> The actor lib on hackage is marked as experimental. has anyone used it for something other than playing around?
09:47:44 <lewis> what do each of the parts in /usr/local/bin mean?
09:48:42 <jonkri> lewis: i believe those are typically the binaries on your system that are compiled by you. the "official" binaries usually reside in /usr/bin. however, this should not be relevant to your current problem
09:50:14 <lewis> where ghc tries to load modules from on this computer is not an usable place
09:52:40 <jonkri> lewis: you are not giving us (or at least me) enough information to actually help you. perhaps reading http://www.sabi.co.uk/Notes/linuxHelpAsk.html will increase your chances of getting the answers you want
09:53:04 <lewis> i will check it out.
09:54:42 <lewis> when I start GHCi I am staring at the Prelude prompt. It took some time to find a place that I could save a .hs file. this place turned out to be my girlfriends folder and that is no good
09:55:13 <lewis> save an .hs file and then run it easily from the prompt i mean
09:55:59 <jonkri> lewis: you will have to use the "cd" command to change the terminal's current working directory. see if you can find a tutorial about it
09:57:17 <lewis> a tutorial at http://www.sabi.co.uk/Notes/linuxHelpAsk.html will help me?
09:57:37 <ricree> can types be declared in ghci?
09:58:08 <mauke> ricree: no
09:58:10 <jonkri> lewis: try reading at least the main heading before you start to ask about its contents...
09:58:26 <ricree> mauke: thanks
10:01:25 <lewis> thanks for the Jordan Curve
10:01:39 <lewis> ill go hang out outside then
10:07:20 <accel> is there a function of type [IO()] -> IO()
10:07:34 <codolio> Yes.
10:07:42 <ddarius> @hoogle [IO ()] -> IO ()
10:07:42 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
10:07:42 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
10:07:42 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
10:07:51 <ddarius> Thought it would fail to generalize.
10:08:01 <accel> hmm, I don't think there are the ones I want
10:08:13 <accel> i.e. I have a [ IO() ] , I want it to be a single IO() inside a do block
10:08:33 <ddarius> None of them are the type you want.  However there is a more general function that probably does what you want.
10:08:46 <accel> yes; what would this function be? :-)
10:08:51 <c_wraith> sequence_
10:08:53 <ddarius> :t sequence_
10:08:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:08:55 <c_wraith> :t sequence_
10:08:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:09:31 <accel> c_wraith , ddarius : nice, thanks
10:09:56 <c_wraith> however, depending on how you're generating the [IO ()], you might want mapM_ in the first place
10:09:59 <c_wraith> :t mapM_
10:10:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:10:15 <ddarius> @src mapM_
10:10:16 <lambdabot> mapM_ f as = sequence_ (map f as)
10:10:47 <c_wraith> yeah, it's nothing amazing.  It just makes it one step, instead of two :)
10:10:50 <kfr> What does ghci :i do?
10:11:03 <accel> whoa
10:11:05 <accel> that is cool
10:11:28 <c_wraith> kfr: gives "information" about whatever you ask about.
10:11:58 <c_wraith> kfr: For types, it gives the definition and instances in scope.  For classes, it gives the definition and instances in scope
10:12:10 <kfr> Alright
10:12:25 <kfr> I just stumbled upon it in a Happstack tutorial, I had never seen it before
10:12:32 <c_wraith> It's actually really handy
10:13:20 <accel> is there a way to use \ to break up a tuple?
10:13:26 <accel>         \ (x,y,z) -> vertex $ Vertex3 x y z
10:13:27 <accel>         [(1,1,1), (1,1,-1), (1,-1,-1), (1,-1,1),
10:13:50 <accel>       map
10:13:50 <accel>         ( \ (x,y,z) -> vertex $ Vertex3 x y z )
10:13:54 <accel>         [(1,1,1), (1,1,-1), (1,-1,-1), (1,-1,1),
10:14:00 <accel> not sure what is wrong with this block
10:14:43 <opqdonut> what is the error message?
10:14:49 <opqdonut> and please don't pase multi-line stuff here
10:14:56 <opqdonut> use for example hpaste.org
10:15:14 <opqdonut> *paste
10:15:20 <danharaj> Anyone know which class instances there are for []?
10:15:29 <accel> http://hpaste.org/43625/accel
10:15:40 <Twey> danharaj: :i [] in GHCi
10:15:45 <danharaj> thanks
10:15:59 <wto> @seen Tobsan
10:15:59 <lambdabot> Unknown command, try @list
10:15:59 <preflex>  Tobsan was last seen on #haskell 1 year, 31 days, 19 hours, 45 minutes and 32 seconds ago, saying: m0nkfish: nvm what I said. Of course it is flip const
10:16:00 <Twey> (after importing any modules you might find interesting)
10:16:09 <opqdonut> accel: you need to indicate which type you want those numbers to be
10:16:43 <opqdonut> for example writing the first triple as "(1::Float,1,1)" will probably work
10:17:03 <opqdonut> (or GLfloat)
10:17:10 <tolkad> accel: you could do [ vertex $ Vertex3 x y z | x <- [1, -1], y <- [1, -1], z <- [1, -1] ]
10:17:45 <opqdonut> when doing OpenGL I've often found a function like this handy: "f :: GLfloat -> GLfloat; f x = x"
10:17:59 <opqdonut> to force various number literals to have type GLfloat
10:18:12 <accel> yeah; I'm fighting with GLfloat right now
10:18:19 * accel rolls up sleeves
10:18:29 <tolkad> accel: list comphrension would be prettier
10:18:41 <accel> let me get it to compile first
10:18:45 <accel> beauty can come later
10:20:28 <tolkad> opqdonut: why would you write that instead of the more succinct « f = id :: GLfloat -> GLfloat »
10:20:59 <pastorn> accel: actually you can solve most of the GL*-type problems with well chosen top level function definitions
10:21:09 <sproingie> or turning off the monomorphism restriction
10:21:13 <interferon> is there a list of bugs in haskell packages that need contrinbutors?
10:21:20 <sproingie> which doesn't get all of them but it does for the annoying ones
10:21:33 <accel> http://hpaste.org/43627/this_compiles <-- how do we make it prettier?
10:21:33 <pastorn> sproingie: 4 realz?
10:21:59 <tolkad> interferon: you could make sure all the data structures packages are compatible with the latest version of containers!
10:22:12 <sproingie> yep.  i found i had to add very little ':: GLFloat ' with the MR off
10:22:18 <Kaidelong> oooh
10:22:32 <Cale> accel: Try a list comprehension
10:22:33 <Kaidelong> so haskell's view patterns were implemented and inspired by Don Syme's work?
10:22:47 <tolkad> accel: you could do [ vertex $ Vertex3 x y z | x <- [1, -1], y <- [1, -1], z <- [1, -1] ]
10:22:47 <sproingie> mostly just for bindings i'd already used as a non-GLfloat
10:23:02 <accel> tolkad: I don't believe those generate the right indices
10:23:07 <Kaidelong> the current ones, that is
10:23:18 <sproingie> you want to make sure you generate vertices in the proper winding order
10:23:23 <tolkad> accel: oh they need a certain order?
10:23:43 <fryguybob> > sequence $ replicate 3 [1,-1]
10:23:44 <lambdabot>   [[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]]
10:23:51 <interferon> tolkad: that's not false...
10:24:16 <Cale> Note that (1,1,1) occurs multiple times there
10:24:30 <Cale> There's 4 elements for each of the 6 faces of the cube
10:24:43 <Twey> > replicateM 3 [1, -1]
10:24:44 <lambdabot>   [[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]]
10:24:51 <sproingie> your cube is generally made of six quads, so there is repetition in those
10:26:49 <pastorn> accel: http://hpaste.org/paste/43627/this_compiles_annotation#p43628
10:27:15 <pastorn> accel: i didn't try it, but i think it looks better this way
10:30:11 <ddarius> Kaidelong: We'll ignore the fact that view patterns trace back to "transformational patterns" which were introduced in the same paper that introduced pattern guards about a decade ago.  They did change the syntax (and semantics?) some though.
10:30:33 <accel> pastorn: I like the p/n switch
10:30:38 <accel> it makes everything match up vertically
10:30:46 <Kaidelong> ddarius: Looking through it, it looks like view patterns have a long history
10:31:00 <Kaidelong> and a lot of designs that were never implemented
10:31:02 <accel> the where also nicely separates the data & the actual list
10:31:53 <accel> ha, the .0 gets rid of fromIntegral too
10:31:54 <accel> very nice
10:34:02 <dnm> Hi all. Just wondering: Haskell Platform 2011.2.0.0 seems behind schedule, since it's now Feb., but is it likely to drop any day now?
10:34:43 <kulakowski> dnm: I heard the 11th when I asked.
10:34:56 <dnm> kulakowski: OK. Thanks!
10:37:20 <tolkad> > let r = [1.0, -1.0] in [ (x, y, z) | c <- [[1.0], [-1.0]], (xr, yr, zr) <- [(c, r, r), (r, c, r), (r, r, c)], x <- xr, y <- yr, z <- zr ] :: [(Double, Double, Double)]
10:37:21 <lambdabot>   [(1.0,1.0,1.0),(1.0,1.0,-1.0),(1.0,-1.0,1.0),(1.0,-1.0,-1.0),(1.0,1.0,1.0),...
10:37:30 <tolkad> accel: that look right?
10:38:36 <tolkad> accel: anyway, it's something like that
10:38:55 <ddarius> Kaidelong: Views have a very long history.  I think transformational patterns were the first instance of view patterns, though maybe Erwig's "active patterns" proposal came earlier.
10:40:46 <accel> tolkad: your effort is apprecaited
10:40:58 <Kaidelong> ddarius: From what I understand, they were added to Haskell because of them getting added to ML and F#
10:41:00 <accel> tolkad: sadly I'm too sleep deprived (awake 30 hours) to check whether that generates the 6 faces of a cube in clockwise roder
10:41:15 <Kaidelong> well, the modern implementation of them
10:41:32 <Kaidelong> and the implementation is the much same as the implementation in those
10:42:12 <tolkad> accel: I don't think it does.
10:42:59 <tolkad> accel: this is too hard. your implementation is better
10:45:47 * Kaidelong thinks he likes view patterns a lot
10:48:36 <Kaidelong> do I need NoMonoPatBinds for anything if I tell ghci NoMonomorphismRestriction?
10:48:53 <sshc> Is it possible to cause a Haskell exception to be raised in a C function that is imported "unsafe"ly?
10:51:15 <burp> anything may throw an exception
10:51:50 <mrd> but a forward exception may only be thrown once per play and only while behind the line of scrimmage
10:53:50 <Kaidelong> What are incoherent instances?
10:56:42 <sshc> burp: Not anything can throw an exception
10:56:54 <burp> sshc: why not?
10:57:02 <dolio> Suppose you have overlapping instances in scope. C a and C Int...
10:57:04 <burp> sshc: I mean, what not?
10:57:16 <sshc> burp: Many things?
10:57:21 <burp> sshc: for example?
10:57:35 <dolio> Normally if you try to write: 'foo :: a -> ... ; foo x = ... bar x' where bar :: C a => a -> ..., you'll get an error.
10:57:37 <burp> sshc: I mean, even pure code can throw exceptions
10:57:42 <sshc> burp: I have a FunPtr to a function, and I need that function to throw an exception
10:58:00 * hackagebot asn1-data 0.4.3 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.4.3 (VincentHanquez)
10:58:01 <burp> if pure functions can do that, your stuff surely also can :>
10:58:12 <dolio> Because foo is trying to use the 'C a' instance in all cases, even if a = Int, and there's a more specific instance in scope.
10:58:23 <dolio> Incoherent instances remove that error message.
10:58:35 <sshc> burp: The FunPtr is used in a foreign library (written in C) that is imported with "unsafe"
10:58:46 <sshc> burp: How would I throw a Haskell exception in C?
10:58:52 <mauke> you wouldn't
10:58:57 <burp> oh, that is what you mean or want to do
10:59:07 <sshc> Yes
10:59:13 <sshc> mauke: I would, if I could
10:59:17 <Kaidelong> dolio: So it'll use the most polymorphic instance even if there is a more specific one, in that case?
10:59:21 <mauke> why not return a status code?
10:59:30 <Kaidelong> and thus resolves the multiple-inheritance problem that way
11:00:21 <sshc> mauke: Is it impossible to throw a Haskell exception in C?
11:00:26 <dolio> Kaidelong: Yes. Because the type of foo means that it isn't receiving a dictionary for C a.
11:00:35 <dolio> It uses the polymorphic one.
11:00:44 <mauke> well, it's not going to be portable
11:00:58 <mauke> sshc: but why?
11:01:11 <dolio> The thing is, if you break the instances across module boundaries, you can do this even with overlapping instances.
11:01:14 <sshc> mauke: What I'm doing already isn't portable
11:01:19 <djahandarie> Hm, I'm reading that:  C/(-) : C -> Cat is a functor (where C is a category and C/A, E in C is a slice category), but this confuses me. What is (-)? How could a slice category ever be a functor itself?
11:01:29 <Kaidelong> this sounds just like overlapping instances then
11:01:32 <sshc> mauke: Why what?
11:01:33 <dolio> If foo is defined in a place where only the C a instance is in scope, it will type check fine with the same type.
11:01:51 <mauke> sshc: why not throw from haskell space?
11:02:02 <copumpkin> djahandarie: it's a placeholder
11:02:03 <dolio> Then, when you import those into a place where C Int is also defined, foo will have the same behavior it will have if you defined foo locally with incoherent instances.
11:02:07 <sshc> mauke: I can't
11:02:19 <dolio> So overlapping instances are naturally incoherent in a way.
11:02:22 <copumpkin> djahandarie: I assume, like the way people write Hom(A, -)
11:02:25 <djahandarie> copumpkin, oh, so it's saying the "partial function" C/ is actually a functor?
11:02:28 * Kaidelong wonders how IncoherentInstances are different from OverlappingInstances
11:02:39 <djahandarie> Hmm
11:03:02 <dolio> It's like a section.
11:03:23 <sshc> mauke: There's a lot to explain, and I don't think it's worth explaining.  I only need to throw a Haskell exception (preferabbly anything that can include a string) in C, and lack of portability or hackiness isn't a problem.
11:03:52 <dolio> (-)/(=) is the slice operator. C/A is the slice category of C over A. C/(-) is the functor that takes objects to the relevant slice category.
11:03:55 <ddarius> Kaidelong: Specific implementations of ML have had views for a long time.
11:04:03 <djahandarie> dolio, yup I see it now
11:04:07 <djahandarie> Thanks
11:04:35 <jix> sshc: couldn't you longjump to the c entry point, pass a special value back to haskell and there rethrow a haskell exception?
11:04:35 <ddarius> And I'm pretty sure they weren't added just to "keep up with the Joneses."
11:04:39 <dolio> Kaidelong: As I said, to accomplish this with just OverlappingInstances, you have to break the definitions across module boundaries.
11:04:39 <Kaidelong> oh no
11:04:41 <sshc> mauke: (Actually, a FunPtr that throws an exception)
11:04:41 <Kaidelong> I mean
11:04:51 <wolfs> I search a Code snippet in Haskell for the theme "Good code is beautiful"
11:04:53 <dolio> IncoherentInstances let it happen all in one module.
11:04:54 <wolfs> Any ideas?
11:04:56 <Kaidelong> the revelation of how to add them consistently
11:05:13 <Kaidelong> what the implementation would look like
11:05:16 <mauke> sshc: can't you write the function in haskell?
11:05:22 <wolfs> I still like filterM (const [True,False])
11:05:29 <wolfs> but it is pretty short..
11:05:32 <pozic> wolfs: are you making one of those trivial Haskell presentations?
11:05:40 <sshc> mauke: I can't, because the foreign library is imported with "unsafe"
11:05:50 <sshc> jix: The FunPtr is used unpredictabally by the foreign library
11:06:02 <pozic> "Look this incomprehensible one-liner that makes me look smart".
11:06:06 * Kaidelong wasn't trying to imply a value judgement there
11:06:24 <wolfs> No, actually one of my collegues want to give a PechaKucha talk to this theme
11:06:33 <sshc> I'm using a binding that imports many functions from the library "unsafe"ly
11:06:38 <wolfs> And he asked me to provide something for haskell.
11:06:43 <pozic> wolfs: are you going to tell us what PechaKucha is?
11:07:01 <wolfs> http://en.wikipedia.org/wiki/Pecha_Kucha
11:07:11 <monochrom> please kill the bolding
11:07:18 <wolfs> 20 Slides, each slide 20 seconds
11:07:26 <wolfs> sorry, just copy and paste....
11:07:31 <Apocalis_> Int -> (a -> a) -> a -> a
11:07:35 <Apocalis_> have we this?
11:08:03 <mauke> const id
11:08:10 <Apocalis_> haha
11:08:10 * monochrom is really tempted to set channel +c to kill all those bloody colour codes
11:08:22 <pozic> When do we get blinking stuff?
11:08:26 <Kaidelong> @hoogle Int -> (a -> a) -> a -> a
11:08:27 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
11:08:27 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
11:08:27 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
11:08:37 <Zao> monochrom: lambdabot should use coloring to prettify the signatures it spits out.
11:08:40 <pozic> I want my IRC in HD.
11:09:10 <Kaidelong> @hoogle (Endo a) => Int -> a -> a
11:09:10 <lambdabot> Warning: Unknown class Endo
11:09:10 <lambdabot> Text.Regex.Base.RegexLike after :: Extract source => Int -> source -> source
11:09:10 <lambdabot> Text.Regex.Base.RegexLike before :: Extract source => Int -> source -> source
11:09:22 <Apocalis_> @type \n f -> foldr (.) id (repeat n f)
11:09:23 <lambdabot>     Couldn't match expected type `t -> [b -> b]'
11:09:23 <lambdabot>            against inferred type `[a]'
11:09:23 <lambdabot>     In the third argument of `foldr', namely `(repeat n f)'
11:09:33 <Apocalis_> @type repeat
11:09:33 <lambdabot> forall a. a -> [a]
11:09:40 <Kaidelong> @ty replicate
11:09:42 <lambdabot> forall a. Int -> a -> [a]
11:09:47 <Apocalis_> @type \n f -> foldr (.) id (replicate n f)
11:09:47 <lambdabot> forall b. Int -> (b -> b) -> b -> b
11:09:52 <pozic> wolfs: why did he ask you? Do you have any reason to talk about Haskell?
11:10:13 <wolfs> I used it for some algorithmic part of my thesis
11:10:13 <mauke> :t \n f -> (!! n) . iterate f
11:10:14 <lambdabot> forall a. Int -> (a -> a) -> a -> a
11:10:14 <Kaidelong> @ty (foldr (.) id .) . replicate
11:10:15 <lambdabot> forall b. Int -> (b -> b) -> b -> b
11:10:39 <Kaidelong> Apocalis_: I think I got what you needed
11:10:41 <wolfs> Also I like the functional style.
11:10:46 <pozic> wolfs: which algorithm if I may ask?
11:10:56 <wolfs> My own ;)
11:11:20 <wolfs> Doing quiver representations and used it to calculate some combinatorics.
11:11:38 <wolfs> Mainly related to reflection functors...
11:11:40 <pozic> wolfs: what does it compute and how fast?
11:12:19 <Kaidelong> > ((foldr (.) id .) . replicate) 5 ((*) <*> id) 2
11:12:21 <lambdabot>   4294967296
11:12:28 <pozic> wolfs: or just give a link to your thesis...
11:12:46 <wolfs> It calculates some coefficients in the Hall algebra of a quiver.
11:13:03 * hackagebot http-types 0.2.0 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.2.0 (AristidBreitkreuz)
11:13:15 <aristid> hackagebot: yay.
11:13:38 <wolfs> It does it in no time, since it does it quite good.
11:13:55 <wolfs> I also used it to draw some generated graphs via fgl and graphviz
11:14:55 <pozic> wolfs: which field are you in? 
11:15:20 <wolfs> I did my PhD thesis in representation theory (mathematics), but now I'm working in IT.
11:15:21 <djahandarie> wolfs, are you from Paderbourn?
11:15:27 <wolfs> yes!
11:15:42 <pozic> wolfs: that explains the 'quiver' ;)
11:15:44 <djahandarie> I oddly think I've seen or read your thesis
11:15:56 <djahandarie> Or one of your papers
11:16:03 <j-invariant> wolfs: What does a quiver do
11:16:24 <wolfs> It's a directed graph - just at some point someone chose another word for it.
11:16:28 <wolfs> A set of arrows
11:16:44 <opqdonut> heh
11:17:00 <wolfs> djahandarie: in what field are you?
11:17:09 <djahandarie> No field, I'm just a student
11:17:13 <djahandarie> Well, computer science :P
11:17:35 <djahandarie> I'm not actively doing research in computer science though so I wouldn't say that I'm "in the field" :P
11:17:45 <pozic> wolfs: what is the Hall algebra part of it?
11:18:07 <djahandarie> I think I ended up reading something of yours when a professor at my uni (Ralf Schiffler) talked about quivers and their various properties
11:18:12 <wolfs> http://en.wikipedia.org/wiki/Ringel–Hall_algebra
11:18:35 <djahandarie> In fact I had some questions that he never was able to answer
11:18:38 * djahandarie goes to look them up
11:19:27 <wolfs> There is an embedding of the quantized version into quantized enveloping algebra of the Lie algebra of the underlying graph.
11:19:33 <NemesisD> hmm, i installed cabal from my distro's repos, installed hunit with it but i keep getting "Could not find module `HUnit'" errors. any ideas?
11:20:09 <pozic> NemesisD: HUnit does not export HUnit?
11:20:27 <NemesisD> someone should tell the hunit site that
11:20:32 <wolfs> djahandarie: This is possible - at least I met Ralf Schiffler
11:20:55 <NemesisD> oh its Test.Hunit, yeah thats misleading
11:22:22 <pozic> NemesisD: not misleading; you just guessed something.
11:23:01 <NemesisD> pozic: hunit.sourceforge.net literally says "import HUnit"
11:23:19 <NemesisD> must be out of date documentation or just a mistake
11:23:36 <pozic> NemesisD: HUnit 1.0 User's Guide
11:23:43 <pozic> NemesisD: and which version do you have?
11:23:46 <jonkri> how can i assign the result of readChan in a do block of a ReaderT monad on top of the IO monad?
11:24:40 <NemesisD> pozic: i was using http://hunit.sourceforge.net/HUnit-1.0/Guide.html
11:24:49 <pozic> NemesisD: yes, I know.
11:24:54 <pozic> NemesisD: that is why I said that.
11:25:03 <wolfs> The nQueens solution uses MonadPlus, so depending in which Monad you want to have it you get for example a List of all solution or the first one it finds
11:25:05 <wolfs> https://gist.github.com/811612
11:25:28 <djahandarie> wolfs, I recall now -- I saw some method of converting groups into quivers, but the examples that were given were only for abelian groups. When I tried with a nonabelian group, like S_3, I got sorely confused since there are multiple ways to carve the group algebra up into minimal, orthogonal idempotents because of the 2-dimensional representation
11:26:08 <NemesisD> so 1.0's documentation *is* out of date or am i misunderstanding something?
11:26:23 <Kaidelong> wolfs: now just separate the backtracking from the problem
11:26:24 <kalivha> 19:42 < djahandarie> wolfs, I recall now -- I saw some method of converting groups into quivers, but the examples that were given were only for abelian groups. When I tried with a nonabelian group, like S_3, I got sorely confused since  there are multiple ways to carve the group algebra up into minimal, orthogonal idempotents because of the 2-dimensional representation
11:26:29 <djahandarie> It would probably be something like   a   b   c==>d, where a and b are trivial and sign representations, and c and d are the two orthogonal idempotents corresponding to the 2-dimensional representation (that is, two orthogonal projection operators in that space)
11:26:39 <pozic> NemesisD: Haskell is not known for people documenting anything. 
11:26:54 <djahandarie> But I don't really exactly understand why
11:26:59 <NemesisD> pozic: i should be at home then. i come from ruby/javascript
11:26:59 <pozic> NemesisD: just expect everything to be crap and then perhaps you might see something useful someday.
11:27:09 <Kaidelong> pozic: which is a shame because lhs2tex is wonderful
11:27:16 <pafcu> What's the easiest way to do non-blocking IO in Haskell? I want to read from stdin, but only if there is something to read
11:27:26 <kalivha> ah, sorry.
11:27:32 <djahandarie> kalivha, np
11:27:33 <pozic> Kaidelong: I would not say it is wonderful. 
11:27:47 <pozic> Kaidelong: but it is not the worst program around :)
11:28:15 <pozic> lhs2tex only suggests that people want to read texed up Haskell in a paper. 
11:28:23 <pozic> I certainly do not want that. 
11:28:26 <wolfs> djahandarie: It doesn't really matter which idempotents you take, you will end up with some quiver
11:28:35 <monochrom> some haskell libs have very good docs. this happens more often than other language communities.
11:28:38 * Kaidelong likes reading haskell in a paper
11:28:52 <Kaidelong> actually if you have to take in a lot of stuff all at once
11:28:56 <pozic> Kaidelong: yes, Haskell, not texed up Haskell which is not Haskell anymore.
11:28:59 <Kaidelong> reading a paper is better than referring to docs
11:29:13 <wolfs> djahandarie: And at least the algebra will be the same...
11:29:23 <copumpkin> Saizan: you there?
11:29:31 <Philippa> pafcu: going concurrent, throwing read input down a Chan and peeking at the Chan has the advantage of scaling well
11:29:36 <jonkri> how can i do this (do block): liftIO $ (message, level) = readChan channel
11:29:37 <pozic> There are some communities were working programs have to be attached before you can publish.
11:29:48 <monochrom> pafcu: hReady may help
11:29:50 <Saizan> copumpkin: yup
11:29:57 <pafcu> Philippa: I want something easy. Doesn't need to scale well
11:30:05 <pozic> Too bad the vast majority doesn't do this. 
11:30:17 <copumpkin> Saizan: for that "hoas"->debruijn hack, did you think of or try to make it work for n-ary functions?
11:30:23 <copumpkin> it seems like some serious hackery might make that work too
11:30:25 <copumpkin> but maybe not
11:30:33 <Philippa> pafcu: not sure where it is then. If you're happy with complexity equivalent to having a "line-reader" object that you poll once in a while and having to write it, then it's pretty much that level though
11:30:34 <pafcu> monochrom: Looks like pretty much what I want
11:30:35 <jmcarthur> what hack?
11:30:37 <jix> jonkri: do you want (message, level) <- liftIO $ readChan channel
11:30:49 <copumpkin> jmcarthur: http://www.e-pig.org/epilogue/?p=773#more-773
11:31:04 <jmcarthur> oh conor's thing
11:31:28 <Saizan> copumpkin: pigworker tried iirc, he said something about needing universal quantification in typeclass contexts and giving up
11:31:36 <copumpkin> boo
11:31:41 <Saizan> copumpkin: though there might still be a way :)
11:31:45 <copumpkin> I've wanted that a couple of times too
11:31:52 <copumpkin> I wonder if there's any meaningful way to add that
11:32:12 <dark> choice ps           = foldr (<|>) mzero ps -- is choice strict on ps?
11:32:13 <jmcarthur> i still haven't read that post thoroughly
11:32:26 <copumpkin> I have a slightly simpler case of it in something I'm working on
11:32:35 <jmcarthur> i think i am irrationally turned off by the word "hack"
11:32:42 <copumpkin> lol
11:32:44 <dark> maybe choice is strict if <|> is strict?
11:33:05 <copumpkin> jmcarthur: it lets me write
11:33:06 <copumpkin> plusTimesDistrib = forall (\x -> forall (\y -> forall (\z -> x * (y + z) :== x * y + x * z))
11:33:19 <djahandarie> wolfs, hmm, okay. Something else that was mentioned was that there is a way to transform a Dynkin diagram (or any quiver) to a quantum group. Do you know anything about that?
11:33:20 <copumpkin> and have it actually be a concrete, function free datatype
11:33:24 <Saizan> it's quite clean actually, it uses OverlappingInstances but the classes are supposed to be closed anyway
11:33:24 <jonkri> jix: i was 110% convinced i had tried that already, must have forgotten to save or something
11:33:25 <jonkri> thanks
11:33:36 <monochrom> I don't think strictness is the right way to look at it. More relevant is in "x<|>y" does it attempt x first or does it attempt y first.
11:33:55 <jmcarthur> copumpkin: sure. i've seen a lot of ways to translate HOAS into a tangible AST
11:34:14 <wolfs> kaidelong: you mean in the addQueens method?
11:34:15 <monochrom> if "x<|>y" attempts x first, then "(a<|>b)<|>c" is a waste of time, and so is foldl over <|>
11:34:19 <copumpkin> jmcarthur: well, the tricky part here is if you have an index on your type (to represent how many binders are in scope)
11:34:34 <jmcarthur> copumpkin: yup, done that too ;)
11:34:41 <wolfs> djahandarie: This was some of the themes of my thesis.
11:34:42 <copumpkin> jmcarthur: oh?
11:35:20 <Kaidelong> wolfs: Have a typeclass that turns descriptions of problems into MonadPlus instances of that problem, IE "(MonadZero m) => p a -> m a"
11:35:25 <wolfs> So you just take the Hall algebra of the representation category of the quiver...
11:35:28 <Philippa> jmcarthur: the problem with "hack" is that it has at least two meanings and they have a habit of overlapping
11:35:43 <jix> jonkri: also I wouldn't necessarily use pairs for log messages... using a seperate data type is cleaner imho
11:35:56 <Kaidelong> wolfs: it should also allow you to describe the problem in a tree structure, I used a "[p a] -> p a" method for that
11:36:01 * Philippa seconds that - when in doubt, name your tuples and their components
11:36:03 <monochrom> "hack" is a dependently typed word. you need to know the speaker's background.
11:36:15 <Kaidelong> then you'll find you can describe the N-Queens problem independently from how you actually solve it
11:36:18 <jonkri> jix: do you mean a record?
11:36:28 <Philippa> monochrom: the overloading I'm talking about is a risk even in hacker(/=cracker) culture, unfortunately
11:36:39 <jix> jonkri: yeah that'd be the best fit in this case
11:36:40 <jonkri> jix: i mean, could it be something other than a record
11:36:47 <jonkri> ok
11:36:47 <Kaidelong> and write data types that implement backtracking either breadth-first or depth-first (again with no specific need to know about the N-Queens problem)
11:37:05 <monochrom> then again it's a tautology. every word depends on the speaker.
11:37:12 <Philippa> "cool hack" might include a substantial element of "holy fuck how did you make that work?", which has a habit of coupling with brittle code (or code that's rendered brittle by reader/maintainer's lack of understanding)
11:37:12 <dark> all words that are actually used are overloaded
11:37:22 <jmcarthur> copumpkin: you might like this if you haven't seen it before Unembedding Domain-Specific Languages
11:37:31 <jmcarthur> *before:
11:37:41 <Kaidelong> wolfs: I can send you a PDF that shows an implementation of that if you're curious and don't want to figure it out yourself
11:37:44 <jmcarthur> by Robert Atkey
11:37:46 <jmcarthur> Sam Lindley
11:37:47 <jmcarthur> Jeremy Yallop
11:37:50 <jmcarthur> holy crap
11:37:52 <jmcarthur> sorry
11:38:02 <dark> the thing with 'hacker' is that it is politically sensitive. in the sense that one sense is offensive to some committed to another sense
11:38:05 <wolfs> kaidelong: I would like that pdf.
11:38:23 <djahandarie> wolfs, okay, I'll revisit your stuff then
11:38:32 <djahandarie> Thanks for answering my questions :)
11:39:19 <wolfs> djahandarie: http://arxiv.org/abs/0907.1106
11:39:31 <wolfs> Try the introduction and follow the references
11:40:09 <jonkri> jix: why do you prefer a record? isn't it cleaner to just log like ("Log Message", Debug) than to construct a record?
11:40:28 <Philippa> dark: tbh, the false "hacker/engineer" dichotomy is the problematic one
11:40:37 <wolfs> kaidelong: You want my email?
11:42:21 <jmcarthur> copumpkin: they convert HOAS to a typed de bruijn representation that includes not only the number of binders in scope, but the types of each one as well
11:42:33 <wolfs> Any other ideas on beautiful & good code in Haskell
11:42:41 <wolfs> Preferable some short snippets?
11:43:07 <Saizan> jmcarthur: but that conversion is done by traversing the HOAS?
11:43:38 <jmcarthur> Saizan: they use a type class for HOAS, as in Finally Tagless
11:43:53 <jix> jonkri: a tuple doesn't tell you anything about it's intended use. Also you'd have to rewrite a lot of stuff if you decide to extend what information a log message con contain
11:44:26 <jmcarthur> copumpkin: i've tried it myself but found actually working with the de bruijn terms kind of difficult :\
11:44:48 <jix> jonkri: I'd combine a record with "smart constructors" for logging i.e. instead of log ("message", debug) you supply a function logDebug "message" that constructs the record
11:45:00 <sm> is there a flag to make ghc accept ← instead of <- ?
11:45:09 <jmcarthur> sm: UnicodeSyntax maybe?
11:45:15 <jix> jonkri: that way code using your library won't need to be updated when you change the message type
11:45:17 <sm> thanks
11:45:18 <jmcarthur> -XUnicodeSyntax, i mean
11:45:45 <NemesisD> are there any GHC flags (or maybe more standard ways) to add to a module load path? for example if I wanted to import something from src/ when in a test in testsuite/
11:45:47 <sm> that's it
11:46:14 <NemesisD> erm not ghc flags, preprocessor statements rather
11:46:19 <aristid> sm: want to make your code harder to edit for others?
11:46:35 <jonkri> jix: ah, great :)
11:46:42 <jix> NemesisD: have you tried -i ? (I think that's what you want)
11:46:44 <sm> no.. just wondered if it's possible for others to run stuff from https://gist.github.com/811291
11:46:47 <jmcarthur> aristid: not hard to edit with a decent editor ;)
11:46:59 <sm> I just wasted time figuring out why my thing stopped compiling
11:47:20 <dark> Philippa, I think it will eventually be understood as an anthropological term. Because it is a name for several related but distinct human communities, and the associated practices / culture
11:47:35 <jmcarthur> aristid: i've rigged up my haskell-mode in emacs to use the unicode input method that agda-mode uses :D
11:47:42 <marekweb> hi I'm learning haskell; if I have (filter (myfunc) mylist) then how can I change it to the opposite of myfunc, in the sense of (not myfunc) ? do I have to write a lambda?
11:47:44 <NemesisD> jix: i wonder if theres a way to specify it in the source itself to prevent my editor's error checker from freaking out/make it more maintainable, etc
11:47:48 <jmcarthur> so \<- would be enough
11:48:03 <aristid> jmcarthur: as long as you don't expect others to rig up their editor to support the same :)
11:48:08 <jmcarthur> heh no
11:48:15 <azaq23> return \N{EMPTY SET} lol
11:48:20 <jix> NemesisD: This sounds like structuring your code into cabal packages would be the better solution
11:48:33 <wolfs> marekweb: not . myfunc?
11:50:11 <NemesisD> hmm ok, i was using the wiki article http://haskell.org/haskellwiki/Structure_of_a_Haskell_project
11:50:50 <jix> NemesisD: you'll see it contains a .cabal file describing the package (and where the sources are)
11:51:55 <NemesisD> ah yes
11:53:08 <Gracenotes> so! anyone working on a Haskell CORBA interface? being on the cutting edge of legacy systems design?
11:53:26 <aristid> Gracenotes: what?
11:53:36 <aristid> Gracenotes: what's riding you? :)
11:54:12 <Gracenotes> >.>
11:56:14 <Kaidelong> > filter even [1..10]
11:56:15 <lambdabot>   [2,4,6,8,10]
11:56:38 <Kaidelong> > filter (not . even) [1..10] --marekweb
11:56:40 <lambdabot>   [1,3,5,7,9]
11:57:29 <kulakowski> Kaidelong: Is your name intentionally reminiscent of k. d. lang?
11:57:43 <Kaidelong> kulakowski: Not intentionally, but I have been made aware of it
11:57:54 <keep_learning> could some one please tell me how to use filter when a function is returning IO Bool
11:58:07 <pozic> keep_learning: which semantics do you want?
11:58:07 <keep_learning> filter isprime [1..]
11:58:08 <Kaidelong> kulakowski: it was intended to be meaningless and not remniscent of anything
11:58:15 <pozic> keep_learning: there is filterM, but it is not lazy.
11:58:35 <Kaidelong> keep_learning: why IO Bool for isPrime?
11:58:46 <Kaidelong> unless you're using a probablistic primality test
11:58:47 <kulakowski> Kaidelong: I'm not surprised. I misread long as lang, even.
11:59:02 <keep_learning> actually i used RandomR  
11:59:03 <jonkri> if i'm in a function and a do block which "returns" (is of type) ReaderT LoggerState IO () and i want to call a function like logDebug which should be state-aware and takes String and LogLevel arguments, how can i specify it so that haskell knows that function requires the ReaderT LoggerState IO monad?
11:59:04 <Kaidelong> in which case it should still be (MonadRandom m) => m Bool
11:59:08 <Kaidelong> and not IO Bool
11:59:12 <keep_learning> so i am carrying this IO 
11:59:16 <jonkri> s/function and a/function in a
11:59:17 <keep_learning> i will post my code 
11:59:32 <jonkri> in other words, i'm in the monad already
12:01:04 <Kaidelong> @hoogle (a -> IO b) -> IO (a -> b)
12:01:04 <lambdabot> No results found
12:01:35 * Kaidelong wonders if this is possible
12:02:09 <copumpkin> jmcarthur: yeah, I've used the typed de bruijn representation myself too
12:02:24 <copumpkin> I quite like it
12:02:50 <Kaidelong> @hoogle (a -> c b) -> c (a -> b)
12:02:50 <lambdabot> Test.QuickCheck promote :: (a -> Gen b) -> Gen (a -> b)
12:03:36 <keep_learning> http://hpaste.org/43635/rabinmiller_io
12:03:39 <keep_learning> here is my code 
12:03:48 <Kaidelong> ah the rabin-miller test
12:03:49 <keep_learning> which use IO Bool 
12:03:56 <keep_learning> Kaidelong, :) yes
12:04:08 * Kaidelong likes the fermat test better
12:04:12 * Kaidelong hmms
12:04:30 <Kaidelong> let me look over it
12:05:16 <keep_learning> pozic, hey works great 
12:05:17 <Kaidelong> keep_learning: All you're using that IO for seems to be getStdRandom. I'd use MonadRandom instead
12:05:19 <jeffwheeler> gwern: Hey (impressive timing, I just came looking for you seconds ago); you mentioned on the yi mailing list that you didn't like git. What are your feelings on the proposed hg-git mirror setup?
12:05:21 <keep_learning> thank you
12:05:30 <tswett> @type mfix
12:05:31 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
12:05:32 <Kaidelong> that said, that doesn't solve your problem
12:05:38 <Kaidelong> but I wanted to get that out of the way first
12:05:50 <Kaidelong> @ty filterM
12:05:50 <keep_learning> Kaidelong, i haven't learned monads 
12:05:51 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:05:53 <keep_learning> till yet
12:06:27 <Kaidelong> keep_learning: and filterM solves your problem, like pozic suggested. You probably will not care about semantics here
12:06:39 <Kaidelong> actually the semantics might depend on the monad you use
12:07:07 <keep_learning> Kaidelong, yes its working 
12:07:14 <keep_learning> now i am planning for monads 
12:07:18 <Kaidelong> keep_learning: Anyway, take a look at MonadRandom. IO is overkill, you only need to go there at the last moment
12:07:28 <Kaidelong> @ty evalRand
12:07:29 <lambdabot> forall g a. (RandomGen g) => Rand g a -> g -> a
12:07:32 <Kaidelong> @ty evalRandIO
12:07:33 <lambdabot> forall a. Rand StdGen a -> IO a
12:08:50 <Kaidelong> @ty liftM even (getRandomR(-2,10))
12:08:52 <lambdabot> forall (m :: * -> *). (MonadRandom m) => m Bool
12:09:18 <Kaidelong> @ty evalRandIO $ liftM even (getRandomR(-2,10))
12:09:19 <lambdabot> IO Bool
12:13:50 <copumpkin> Saizan: AIEEE
12:13:58 * copumpkin 's head explodes trying to do the n-ary binders
12:14:28 <elliott> Is there a library that defines a nicer quasiquoter way to write multi-line strings?
12:14:30 <elliott> That would be really nice.
12:17:09 <ddarius> @google missing spectral basis
12:17:11 <lambdabot> http://www.garretstar.com/secciones/publications/docs/monthly336-346.pdf
12:17:11 <lambdabot> Title: The Missing Spectral Basis in Algebra and Number Theory
12:17:29 <ddarius> You may find that interesting djahandarie.  I may have pointed you at it before.
12:18:28 <wolfs> Still no ideas about examples of beautiful code in Haskell?
12:18:53 <aristid> wolfs: undefined = undefined
12:19:25 <wolfs> beautiful useful code?
12:19:25 <bitweiler> is haskell simple as scheme to learn?
12:20:03 <elliott> bitweiler: no, if you start with languages unlike haskell
12:20:08 <elliott> but it's not hard
12:20:10 <aristid> bitweiler: it needs less (), therefore it is much simpler. (just kidding)
12:20:39 <bitweiler> lol...
12:20:50 <bitweiler> elliott: i started with scheme
12:21:16 <elliott> bitweiler: well, it's a better start than C++ :-)
12:21:22 <elliott> it's worth the effort, anyway
12:21:40 <bitweiler> huh?
12:21:56 <Kaidelong> bitweiler: Haskell has the same kind of minimalistic beauty scheme does, it's just buried a bit deeper and harder to appreciate
12:22:17 <jmcarthur> its beauty is a little different to me
12:22:32 <Kaidelong> particularly with these weird syntactic things like do syntax and "if-then-else"
12:22:51 <jmcarthur> i don't see those as fundamental to the idea that is "haskell" though :)
12:23:00 <dino-> I tend to very rarely use if in Haskell.
12:23:02 <aristid> Kaidelong: is there a reason why if is not a function anyways?
12:23:27 <Kaidelong> if True = const
12:23:31 <Kaidelong> if False = flip const
12:24:03 <ikeg> worfs: Did you see that the simple quicksort with list comprehension in Haskell  does not have best performance?
12:25:06 <ikeg> worfs: how about tuning quicksort in Haskell? it is easy to understand and give us useful tricks
12:25:28 <Kaidelong> ikeg: I never really thought of the efficient in place quicksort as being easy to understand
12:26:05 <ikeg> Kaidelong: well, it is well written in the page : http://en.literateprograms.org/Quicksort_%28Haskell%29
12:27:33 <Philippa> Kaidelong: it's easy enough if you do it in terms of the dutch national flag algorithm
12:27:52 <Philippa> at which point it's DNF + divide and conquer
12:28:16 <aristid> ikeg: i guess GHC 7 would blow that out of the water :)
12:29:11 <ikeg> aristid: really? I wish to use GHC 7 (not 7.0.1) as soon as possible :)
12:29:27 <azaq23> aristid: http://www.haskell.org/haskellwiki/If-then-else has only one objection, and a pretty weak one, too
12:29:36 <aristid> ikeg: or even 6.12... they used GHC 6.4
12:30:25 <aristid> zipWith3 if' <- cool combinator
12:30:43 <Philippa> Kaidelong: yeah, you can boil all the dynamic aspect of haskell code down to variables, lambda, application, let and case
12:30:58 <Philippa> and let and case can both be simplified substantially
12:32:12 <aristid> azaq23: adding if' to Prelude but keeping if-then-else would probably be the pragmatic solution
12:32:29 <aristid> or even to another module
12:33:57 <ikeg> wolfs: I typo your nick, sorry. please refer the above discussion about quicksort
12:35:52 <wolfs> ikeg: no problem
12:36:45 <ikeg> some Japanese (and me) often speaks EngRish
12:38:02 <gwern> jeffwheeler: I use mercurial even less than git, so I don't think it's a good idea. I dislike git for not being darcs, but that doesn't mean I think it can't do the job
12:38:16 <Kaidelong> ikeg: none of those look like the in-place implementation
12:38:58 <jeffwheeler> gwern: I'm a fan of the github idea, not that I think that there's much hope for yi anyways; but that certainly seems like an okay idea. I don't use mercurial at all, but I'm willing to accept that solution.
12:39:10 <zaphar_ps> gwern: I like darcs interface and useage patterns but it's speed is painfully slow
12:39:32 <zaphar_ps> hg and git both solve the speed problem with hg's UI being a little less painful than git
12:39:51 <zaphar_ps> jeffwheeler: why so down on Yi?
12:40:06 <copumpkin> how can I mark a GADT constructor as infix for autogenerated Show instances?
12:40:14 <jeffwheeler> zaphar_ps: it hasn't had more than a few patches in ages, and I don't think I can even build it right now :)
12:40:29 <luite> byorgey: I'm looking at your new diagrams library, but the diagrams-cairo backend doesn't compile for me
12:40:30 <keep_learning> filterM
12:40:44 <jeffwheeler> zaphar_ps: that's not to say I don't /really/ want to see it succeed, because I do
12:41:23 <zaphar_ps> jeffwheeler: I've been trying to tackle the memory leak issues in it but I'm having trouble getting a profiling build to run
12:41:27 <sm> github is likely to help it most 
12:41:37 <jeffwheeler> sm: that was my thinking
12:41:58 <zaphar_ps> jeffwheeler: github will attract a lot of potential hackers
12:42:08 <aavogt> but is there much haskell on github currently?
12:42:11 <gwern> jeffwheeler: there're so few contributors that a move to github isn't likely to hurt it much, assuming said contributors were not going to spend the effort doing something else other than orchestrating a move to github
12:42:12 <ikeg> Kaidelong: 'not in-place implementation' means not good and should not learn?
12:42:29 <zaphar_ps> but until recently they've had an issue with figuring out which repo is the canonical repo for a project
12:42:31 <jeffwheeler> gwern: I wasn't going to be doing anything else . . . :)
12:42:36 <luite> byorgey: are you still working on it? its in the cairoStyle function, the different handlers have different types, according to my ghc :)
12:42:37 <fryguybob> luite: What error do you get?
12:43:01 <Kaidelong> ikeg: No
12:43:35 <Kaidelong> ikeg: besides, those implementations only really make sense when you have random access, which you do not, for lists
12:44:04 <mm_freak> how can i add record fields in GADT syntax?
12:44:13 <luite> fryguybob: http://hpaste.org/43636/cairodiagrams_error
12:44:20 <copumpkin> mm_freak: it's horrifying
12:44:58 <copumpkin> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/data-type-extensions.html has the synta
12:44:59 <copumpkin> x
12:45:05 <dibblego> I have about 15 haskell projects on bitbucket
12:45:10 <copumpkin> data G a b where { G1 { g1::a, g2::c } :: G a [c] }
12:45:42 <benedikt> Someone here in posession og Knuth's TACP?
12:45:46 <benedikt> s/og/of
12:45:50 <ikeg> Kaidelong: I see
12:46:56 <ikeg> Kaidelong: augustss has an essay about quicksort in Haskell : http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
12:46:58 <Veinor> benedikt: bittorrent is! :D
12:47:26 <mm_freak> copumpkin: ok, i thought it would be worse
12:47:26 <pozic> ikeg: and it only comes close to what quicksort really is. 
12:48:06 <pozic> ikeg: because even though those constructions should have zero overhead, compilers still manage to mess it up to make it slower than C for no reason at all. 
12:48:32 <benedikt> Veinor: i have bittorrented it twice (2nd and 3rd editon) ( I feel somewhat shameful for this, but I have the first volume.. Cant buy all at once :p) but I can't find an algorithm referenced in some code. 
12:49:56 <copumpkin> Saizan: I feel like there must be a cleaner way to do the bla on conor's page (with the Leq constraint), such that it increments it by one each time, rather than generating a general Leq constraint
12:49:58 <azaq23> > let if' True = const; if' False = flip const; xs = [(True, 1), (False, 12), (True, 322), (False, 2342)] in (foldl (flip $ uncurry if') 0 xs, foldr (uncurry if') 0 xs) -- interesting 
12:50:00 <lambdabot>   (322,1)
12:50:43 <aristid> @let if' True = const; if' False = flip const
12:50:44 <lambdabot>  Defined.
12:50:50 <aristid> :t zipWith3 if'
12:50:51 <lambdabot> forall b. [Bool] -> [b] -> [b] -> [b]
12:51:17 <aristid> > zipWith3 if' (cycle [False,True]) [1..] [-1..]
12:51:19 <lambdabot>   [-1,2,1,4,3,6,5,8,7,10,9,12,11,14,13,16,15,18,17,20,19,22,21,24,23,26,25,28...
12:51:19 <dibblego> @google church boolean encoding
12:51:20 <jonkri> @undo logDebug message = do loggerState <- ask; let logChannel = channel loggerState; liftIO $ writeChan logChannel $ LogMessage { message = message, level = Debug }
12:51:20 <lambdabot> http://en.wikipedia.org/wiki/Church_encoding
12:51:20 <lambdabot> Title: Church encoding - Wikipedia, the free encyclopedia
12:51:20 <lambdabot>  Parse error at "=" (column 18)
12:51:27 <aristid> > zipWith3 if' (cycle [False,True]) [1..] [-1,-2..]
12:51:28 <lambdabot>   [-1,2,-3,4,-5,6,-7,8,-9,10,-11,12,-13,14,-15,16,-17,18,-19,20,-21,22,-23,24...
12:51:51 <jonkri> @undo logDebug message = do { loggerState <- ask; let logChannel = channel loggerState; liftIO $ writeChan logChannel $ LogMessage { message = message, level = Debug } }
12:51:51 <lambdabot>  Parse error at "=" (column 18)
12:52:13 <jonkri> @undo do { loggerState <- ask; let logChannel = channel loggerState; liftIO $ writeChan logChannel $ LogMessage { message = message, level = Debug } }
12:52:13 <lambdabot>  Parse error at "}" (column 144)
12:52:56 <dainanaki> Hello everyone, dumb question: How do I get Snap to compile in development mode?
12:53:23 <dainanaki> I tried: cabal install -f=development, but it didn't work.
12:53:47 <aristid> dainanaki: maybe ask in #snapframework ?
12:54:00 <jeffwheeler> gwern, zaphar_ps: I just created a github org; I've added y'all (and a few other people I could find on github) as owners
12:54:07 <dainanaki> Well I know cabal needs the development flag set
12:54:20 <jeffwheeler> I think I'll move my pointedlist package there, too, since it was originally from Yi.
12:55:20 <radarsat1> hello, what's the best way to install ghc on ubuntu so that cabal isn't completely retarded? (not trolling)  just got: "ghc-6.12.1 requires array ==0.3.0.2 however array-0.3.0.2 was excluded because ghc-6.12.1 requires array ==0.3.0.0"
12:55:50 <radarsat1> i'm using the packaged version, but would it be better to install some other way?
12:56:06 <Cale> radarsat1: I usually don't trust ubuntu's packages for anything Haskell-related
12:56:08 <ikeg> pozic: thanks, i agree with you
12:56:30 <doserj> dainanaki: -fdevelpment instead of -f=development?
12:56:32 <Cale> radarsat1: I just install the generic linux binary from the GHC website, and then bootstrap cabal-install using the script that comes with it
12:56:46 <radarsat1> ok, you download the binary and put it on your PATH?
12:56:56 <Cale> radarsat1: make install
12:57:17 <Cale> (I install to /usr/local which is the default anyway)
12:57:26 <radarsat1> ok i'll try that, thanks
12:57:39 <Cale> I then install all cabal packages as user
12:57:40 <radarsat1> should i delete my .cabal folder?
12:57:43 <Cale> which keeps things separate
12:57:51 <radarsat1> i guess i will just in case
12:58:06 <Cale> Yeah, if you want to start over you can blow away .cabal and .ghc
12:58:13 <radarsat1> ok will do
12:58:15 <Cale> (the latter being the more important of the two)
12:59:19 <copumpkin> I love that forall isn't a reserved word in haskell
12:59:19 <copumpkin> despite being syntax
12:59:26 <copumpkin> haskell parser++
12:59:28 <kalivha> Is it possible/reasonable to integrate Haskell code into a Flash application?
13:00:21 <Veinor> Cale: you know that thing you mentioned about not-CH and functions from R to N s.t. f(a)=f(b)=f(c)=f(d) and a+b=c+d ?
13:00:24 <Veinor> does that have a name?
13:00:27 <Cale> kalivha: That would likely be a very difficult project, since it would essentially involve writing a new compiler backend, I suspect.
13:00:43 <Cale> Veinor: I don't know if it has a name
13:00:44 <luite> kalivha: UHC can generate javascript code, you could try to modify that to generate valid actionscript
13:00:59 <Cale> Veinor: I linked to the paper it was from though
13:01:27 <kalivha> Cale: I'm fairly new to all this, and I've got a fairly tight deadline. Thanks for pointing that out.
13:02:09 <Cale> kalivha: You might be able to use Haskell as a metalanguage to generate ActionScript code, but...
13:02:57 <luite> kalivha: there's a way to interact with javascript in flash I believe, so you could possibly use the uhc output directly.
13:03:34 <kalivha> Cale: Basically the problem is that I want to make a differentiation/integration application, but the exam board demands that it is easy to use, and I believe that's a huge chunk of my mark.
13:03:36 <luite> kalivha: but maybe you could evaluate the haskell code on the server (similar to tryhaskell.org)? that would be fairly simple to implement
13:04:12 <kalivha> luite: I don't actually need to have it online, I just don't feel comfortable writing the GUI in Haskell.
13:04:18 <RichardBarrell> luite: embeeded Flash objects can interact with the page that they're planted on iff "allowScriptAccess" is set appropriately.
13:04:37 <Kaidelong> kalivha: what'd you use otherwise?
13:04:44 <kalivha> luite: especially sice it needs to be for Windows, and I currently don't even have a Windows system.
13:05:17 <kalivha> Kaidelong: I just asked if I could somehow integrate it into Flash, because that would make testing easier, I imagine
13:05:18 <luite> kalivha: hmm, I think that all these solutions would probably be more complex than just using gtk2hs
13:05:34 <RichardBarrell> luite: that can be set to always, same-domain, or never. "always" allows the Flash to interact with the page no matter what, "never" always denies it, and same-domain applies roughly the same same-origin check as XHR does. The default is same-domain.
13:05:48 <Kaidelong> Flash is an unpleasant environment to write code in
13:05:51 <Kaidelong> but go for it I guess
13:05:57 <kalivha> luite: I really have no idea at all.
13:05:58 * Kaidelong has to go
13:06:04 <kalivha> Kaidelong: I'm not saying this is a good idea.
13:06:18 <kalivha> I'm just trying to come up with a way to do this reasonably.
13:06:20 <Cale> kalivha: Well, in that case, you might be able to write a completely separate server in Haskell which solves the integration/differentiation problems, and have the flash program interact with it.
13:06:27 <ClaudiusMaximus> > diff (\x -> sqrt x + x^3) x :: Expr
13:06:28 <lambdabot>   Not in scope: `diff'
13:06:32 <luite> kalivha: look at www.tryhaskell.org , the source code is available on github
13:07:02 <kalivha> Cale: Yes, that was what I meant to do. I'm just not sure how complicated the interaction would be.
13:07:11 <kalivha> luite: will do. thank you.
13:07:32 <Cale> kalivha: That itself will be pretty easy.
13:07:47 <luite> kalivha: it's not very difficult, you could extend tryhaskell relatively easily to have "user friendly" input of the equations, and pretty printing
13:08:21 <Cale> kalivha: What's hard is writing Haskell code that would be compiled directly into or included in the SWF itself. :)
13:08:40 <kalivha> luite: To be fair, I'm not sure if I am allowed to extend OOS for this coursework. I imagine I should be allowed to, as we're also allowed to write the whole thing in SQL. 
13:08:54 <kalivha> Cale: Oh, I don't need that... I think
13:09:22 <wires> hi! I suppose all haskell data structure are immutable fully persistant datastructures, unless otherwise stated, right? like clojure's data structures
13:09:29 <kalivha> Cale: I really only write code for my own amusement, really, and this project is a year ahead of what I do in class, so I've effectively never done any GUI work.
13:09:51 <kalivha> Cale: which slightly scares me.
13:09:57 <luite> kalivha: pretty sure that you're going to depend on some open source code at some point :)
13:10:46 <azaq23> wires: all data structures are immutable yes - "unless otherwise stated" only for something which uses the IO monad in some way to accomplish mutability (Data.IORef)
13:10:51 <kalivha> luite: Oh, yeah, definitely. I'm not advanced enough to write everything myself. On the other hand, most projects I've seen seem to be checkout systems for shops and such, so mine is quite off the norm.
13:11:21 <kalivha> luite: so I should be okay.
13:11:23 <wires> azaq23: aha, I see! 
13:11:47 <dibblego> s/monad/value
13:13:17 <azaq23> @google "the IO monad"
13:13:20 <lambdabot> http://www.haskell.org/haskellwiki/IO_inside
13:13:20 <lambdabot> Title: IO inside - HaskellWiki
13:13:38 <dibblego> @hoogle IO
13:13:38 <lambdabot> module Data.Array.IO
13:13:38 <lambdabot> module System.IO
13:13:38 <lambdabot> Prelude data IO a
13:13:39 <azaq23> It is slightly incorrect but accepted colloquially, isn't it
13:13:58 <jix> eh I just noticed that I could also need translatable-intmap ... would have been easier to do that first and then reduce it for intset instead of expanding it now..
13:14:03 <dibblego> azaq23: it is accepted by a lot of people, but it is incorrect and according to some people (me included), causes confusion for beginners
13:14:14 <copumpkin> jix: yep
13:14:31 <copumpkin> type IntSet = IntMap ()
13:14:32 <copumpkin> :P
13:14:46 <dibblego> azaq23: the IO monad is irrelevant to the required answer -- as an anecdote, consider the bollocks that Gilad Bracha recently wrote, which is a symptom of this
13:14:54 <copumpkin> irrelephant
13:15:11 <jix> copumpkin: I think actually special casing the IntSet doesn't hurt (performance)
13:15:17 <wires> lol
13:15:26 <wires> :) what did bracha write?
13:15:28 <copumpkin> jix: I wouldn't expect it to, apart from carrying around an extra pointer
13:15:46 <copumpkin> jix: if you make IntMap a data family you can have the best of both worlds :P
13:15:55 <dibblego> he conflated IO and monads; a common beginner mistake
13:15:59 <copumpkin> but then it won't be fully polymorphic without an additional box
13:16:01 <jix> copumpkin: oh I just assumed that since containers doesn't do that
13:16:15 <jix> copumpkin: eh what? 
13:16:53 <wires> I have a bit of a design question, and i'm not sure if I should go clojure/scala or haskell with my project... Suppose I want to expose an immutable datastructure over a web service. The service has some operations which you can apply  to any version of the data structure. So, say you get a tree of reivisions. How would you approach this?
13:16:57 <copumpkin> jix: which part?
13:18:17 <jix> copumpkin: how to use data families for this
13:18:38 <wires> I'm thinking something along the line of, have the datastructure implement some kind of Hashable class, which gives the (immutable) hash of a specific revision, and then store references to those revisions in a  [(hashcode, value)] map. then you can say apply operation Foo to revision "hashcode"
13:19:12 <dibblego> wires: I use scala and haskell in my work. I only use scala when I have to appease the JVM, java libraries or other programmers. Haskell is superior in every other respect. I wouldn't use clojure for anything at all
13:19:14 <wires> does that sound reasonable?
13:20:24 <copumpkin> you'd make IntMap an associated datatype of some typeclass representing the "basis" methods on your IntMaps (the ones that you can't implement in terms of other methods). The parameter to the data family is the payload, which you basically want two cases for. One is "Box x" and the other is (). The () would be your current IntSet with no extra pointer, and the Box x would carry extra information about x. Then IntMap () would be as efficient mem
13:20:25 <copumpkin> as IntSet,  and IntMap (Box x) can carry anything. You need the box because you can't have overlapping data families :/
13:20:38 <copumpkin> jix: but it's overkill here, I think. Just carry around a pointer to () and save yourself lots of work :P
13:20:51 <jix> copumpkin: doesn't that result in implementing everything twice too?
13:20:56 <copumpkin> oh yes
13:21:09 <copumpkin> I just meant for presenting a homogeneous interface on things
13:21:24 <copumpkin> well, the methods polymorphic in the payload type could be implemented once
13:21:25 <wires> dibblego: good. I'm along similar lines, certainly not too happy about clojure's syntax and lack of typing... I'm happy about the homoiconic nature of it thought
13:22:08 <wires> for instance, It seems quite a bit of work to persist a haskell data structure into different representations. JSON, protocolbuffers, xml...
13:22:33 <wires> this seems much easier with clojure.. 
13:22:44 <dibblego> why does it seem that way?
13:23:11 <wires> you need to implement instance of JSON/protobuff/xml for you class as for as far as I can see?)
13:23:34 <wires> OTOH, i've seen things like RJson which seem to do it automatically using template haskell? which i'm not familiar with...
13:23:56 <wires> sorry, i meant data structure, not class
13:24:33 <dibblego> this seems reasonable to me, I'm not sure what "automatically"means, but I suspect it requires some code introspection, which I wouldn't use, even if given the option
13:24:51 <wires> exactly..
13:25:16 <copumpkin> soon we'll get that in GHC too
13:25:25 <copumpkin> someone's working on extending the deriving mechanism
13:25:34 <copumpkin> to let you write it for arbitrary user-specified classes
13:27:01 <jix> copumpkin: using template haskell?
13:27:06 <copumpkin> no
13:27:06 <wires> But can't you give some general "view" of a value, maybe this is Data.Typeable? I don't really understand that either, yet.. bt from this general interface walk the datastructure and persist it or reconstruct it. Ofcourse this would work only for a limited set of data structures, but it seems suitable enought for moving values from one machine/language to another.
13:27:09 <copumpkin> just a new GHC feature
13:27:21 <sm> oh that sounds good 
13:27:24 <copumpkin> wires: I think you want Data.Data or one of the other generics systems
13:27:32 <copumpkin> (which is conveniently also derivable already)
13:27:35 <jix> copumpkin: how does it work for arbitrary types then?
13:27:40 <copumpkin> Data.Data.Data!
13:27:40 <copumpkin> :P
13:27:45 <wires> Hehe
13:27:47 <copumpkin> jix: I haven't looked at how they'll do it yet
13:28:01 <copumpkin> jix: but I think it magically represents your types as sums and products with more type information available to you
13:28:06 <copumpkin> so you can reason about the structure of the type
13:28:15 <wires> Are there "serialization" libraries that use this approach? 
13:28:19 <jix> copumpkin: but not using template haskell is a good thing imho... it's ok on the user side but horrible on the implementor side
13:28:38 <copumpkin> yeah, SPJ has already said that TH needs a significant overhaul
13:28:42 <copumpkin> in two different directions, possibly
13:29:51 <azaq23> dibblego: You're right, though a beginner may be more confused by a more correct formulation when just about any monad introduction tells them things about "the IO monad". So I'm not sure what approach to choose here.
13:31:13 <lispy> lambdabot is out of control.  I'm taking her offline
13:31:20 <monochrom> I sometimes tell lies to beginners. But I mark it multiple times as "this is a lie".
13:31:57 <monochrom> for example my http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml
13:32:00 <dibblego> azaq23: the IO value
13:32:02 <lispy> ?botsnack
13:32:02 <lambdabot> :)
13:32:05 <lispy> hmm
13:32:11 <dibblego> yes, there are useful lies in teaching, this is not one
13:32:23 <lispy> gwern: there was a mueval-core process taking up 100+% of the CPU and it was running for hours
13:32:33 <lispy> gwern: Do you know how/why that would happen?
13:32:41 <gwern> lispy: nope! should be quite impossible
13:32:56 <lispy> gwern: Your Linode has exceeded the notification threshold (90) for CPU Usage by averaging 100.9% for the last 2 hours.
13:33:12 <lispy> 100.9% does indeed look impossible
13:33:15 <copumpkin> there are ways of pegging the CPU 
13:33:17 <copumpkin> or were in the past
13:33:22 <copumpkin> you can confuse @pl nicely
13:33:35 <copumpkin> lispy: want me to try one of those ways on it and see if it pegs your CPU?
13:33:37 <lispy> copumpkin: but it was a mueval process
13:33:42 <copumpkin> oh, hm
13:34:22 <copumpkin> lispy: want to test the @pl thing anyway, to see if it's been fixed? it used to just kill lambdabot altogether, after a brief period of it being unresponsive
13:34:47 <aristid> @pl \x -> x x
13:34:47 <lambdabot> join id
13:34:59 <aristid> :t join id
13:35:00 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
13:35:00 <lambdabot>     Probable cause: `id' is applied to too few arguments
13:35:00 <lambdabot>     In the first argument of `join', namely `id'
13:35:04 <aristid> oh, lovely.
13:35:59 <mm_freak> can i deinstall a package by removing its corresponding file from ~/.ghc/i386-linux-6.12.3/?
13:36:03 <copumpkin> @pl (\x -> x x) (\x -> x x)
13:36:06 <lambdabot> ap id id (ap id id)
13:36:06 <lambdabot> optimization suspended, use @pl-resume to continue.
13:36:10 <copumpkin> @pl-resume
13:36:16 <lambdabot> ap id id (ap id id)
13:36:16 <lambdabot> optimization suspended, use @pl-resume to continue.
13:36:23 <gwern> lispy: but as I said the last few times, I've implemented all the watchdog methods I know of. at this point the only mechanism left is a reboot, which is a bit beyond mueval's purview
13:36:23 <copumpkin> lispy: how's that?
13:36:52 <lispy> copumpkin: load average: 0.10, 0.41, 0.73
13:37:08 <lispy> copumpkin: in other words, no cpu usage
13:37:40 <aristid> copumpkin: oh, ap id (ap id id) seems to bring it into a funny optimization loop of non-convergence?
13:38:19 <monochrom> mm_freak: deleting files is insufficient and unnecessary. meta-data trumps data. see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
13:39:04 <monochrom> deleting files without updating ghc meta-data leads to strange crashes
13:39:46 <ddarius> aristid: @pl is untyped.
13:39:58 <mm_freak> ok, thanks
13:41:49 <monochrom> oh, you're planning to delete meta-data to begin with. but "ghc-pkg unregister" is better. there is a cache to be updated.
13:41:52 <elliott> is there a way to make haskell-mode not try and parse the contents of quasiquoters?
13:41:53 <mm_freak> can i somehow say that i prefer a certain version of a package over others?
13:41:55 <elliott> it's *really* irritating.
13:42:04 <djahandarie> Why can't we get an actual term-rewriter which has proper rules in it?
13:42:06 <aristid> ddarius: how does it manage to take typed expressions and keep them valid?
13:42:15 <monochrom> you have to "ghc-pkg hide" the packages you don't prefer
13:42:31 <mm_freak> monochrom: great, many thanks
13:42:41 <gwern> mm_freak: cabal install has some sort of preference option
13:42:45 <gwern> saw it in --help today
13:42:45 <mm_freak> does that mean that by default all versions except the latest are hidden?
13:42:57 <monochrom> not hidden
13:43:36 <monochrom> there is already a separate rule to prefer the highest version number
13:43:45 <deech> Is there versions of the IO Monad that only allow reads for example - called an RO monad for example. So if some function was in the RO monad we know that it can only read the filesystem.
13:44:37 <ezyang> deech: In what context? 
13:44:39 <elliott> deech: No.
13:44:45 <elliott> (That's rather ill-defined, anyway.)
13:44:46 <ezyang> For example, I can always unsafePerformIO whatever I want. 
13:44:58 <elliott> Arguably printing to the screen counts as "changing" stdout.
13:45:00 <danharaj> :t (-0)
13:45:01 <lambdabot> forall a. (Num a) => a
13:45:02 <elliott> And so wouldn't be allowed there.
13:45:09 <elliott> But then arguably it doesn't, because it can't "destroy" anything.
13:45:10 <danharaj> blah. How do I get the section (-n)?
13:45:21 <mauke> subtract n
13:45:22 <djahandarie> elliott, except the previous pixels :)
13:45:27 <danharaj> laamee.
13:45:32 <ezyang> elliott: prog > bar :-) 
13:45:46 <elliott> ezyang: wut :)
13:45:58 <elliott> djahandarie: ooh, with subpixel antialiasing it could get REALLY murky :D
13:46:05 <deech> True, printing to the console considered changing the world, but sometimes it's nice to explicitly disallow calling certain functions.
13:46:29 <deech> ezyang: I don't think I can stop a determined user from breaking the type system with unsafePerformIO
13:46:46 <elliott> you can if you just ban importing that module :P
13:46:50 <djahandarie> You don't need to be determined to break it with unsafePerformIO
13:46:53 <elliott> but then make sure to ban all internal GHC modules
13:47:09 <ezyang> I seem to recall there being a "jailed" IO monad 
13:47:14 <ezyang> on Hackage. 
13:47:32 <deech> ezyang : ooh ...that sounds like what I want. Thanks!
13:47:41 <djahandarie> Semi-relevant: http://hackage.haskell.org/trac/ghc/ticket/1380
13:48:27 <djahandarie> That link it linked to in there used to go somewhere
13:48:32 <djahandarie> Not sure what happened to it
13:49:48 <deech> ezyang: The Jailed IO package is exactly what I was looking for. Thanks!
13:49:54 <ezyang> Cool. 
13:50:10 <ezyang> Like most packages on Hackage, I don't know if it *actually* works, but hey :-) 
13:50:40 <deech> ezyang: It's at least nice that someone got me at least part of the way there.
13:50:57 <keep_learning> :t filterM
13:50:57 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:52:38 <mm_freak> > filterM (const [False ..]) "abc"
13:52:39 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
13:53:38 <scooty-puff> stupid question, but why does when return m (), and not m (Maybe a)
13:54:45 <djahandarie> scooty-puff, you kind of lost me there :P
13:54:54 <scooty-puff> :t when
13:54:55 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:55:00 <scooty-puff> why not
13:55:13 <scooty-puff> Monad m => Bool -> m a -> m (Maybe a)
13:55:15 <bitweiler> does haskell run on netbsd?
13:55:29 <scooty-puff> (defining it locally, and just wondering)
13:55:32 <scooty-puff> guess it saves a
13:55:35 <scooty-puff> _ <- when ...
13:57:38 <djahandarie> That type signature doesn't seem "right" when you are working with monads that do stuff besides store a value inside them. For example, IO.
13:58:29 <djahandarie> Bool -> IO a -> IO (Maybe a).   An   IO (Maybe a)   doesn't tell me anything, especially if I'm just ignoring the value
13:59:00 <djahandarie> Maybe (IO a)   would be more telling perhaps, but then the function definition gets pretty trivial
13:59:18 <djahandarie> In reality when is just a convinence function that helps you save a tiny bit of code
13:59:54 <djahandarie> Anything more complicated could be useful but I suppose it'd also be serving a different purpose probably
13:59:59 <danharaj> Question of preference for looking at past: (t0, t] or [t0,t)?
14:00:01 <monochrom> I haven't found Monad m => Bool -> m a -> m (Maybe a) useful.
14:00:45 <monochrom> Since I already have the Bool, I already know whether it is True or False, I don't need the Maybe to tell me again.
14:02:41 <monochrom> If you have been thinking (newWhen b k >>= \m -> case m of Just a -> print a; Nothing -> return ()), well I would rather (when b (k >>= print))
14:02:54 <kyagrd> monochrom: but what about the return type?
14:03:02 <kyagrd> @type when
14:03:03 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:03:14 <monochrom> the return type is ().
14:03:18 <kyagrd> has this type because when if fails it defaults to just ()
14:03:41 <monochrom> the return type of k >>= print is successfully ()
14:03:42 <kyagrd> but if it takes m a it should default to Nothing that seems natural
14:04:27 <MarcWeber> Has soemthing happened to haskell cafe in the past? I just noticed that I'm no longer subscribed (can't post) and maybe didn't receive a mail within the last 3 month?
14:04:33 <monochrom> if I get (Maybe a), I will just ignore it, whether it's Just or Nothing. I am saying it is useless for me.
14:04:50 <djahandarie> I guess the point here is that almost any time you want  when  you want it to be  m ()  anyways 
14:05:05 <djahandarie> I need to unbreak my compose key so I can use << and >> again
14:05:13 * copumpkin is trying to model a theory in haskell such that presburger-solvable relations are marked as such in the type, and more general ones are too
14:05:17 <copumpkin> it's tricky
14:05:25 <kyagrd> danharaj: then one can just use Control.Monad.when
14:05:46 <kyagrd> oops I menat djahandarie
14:06:03 <monochrom> you could argue for (Monad m => Bool -> m a -> m ()) and I would buy it. If you tried to sneak (Maybe a) there I would just treat it like ().
14:06:04 <djahandarie> kyagrd, er, I believe the topic of discussion was why  when  wasn't defined with the Maybe :)
14:06:37 <kyagrd> Well, as you said it is almost always likely to be (m ())
14:07:15 * djahandarie feels like he is walking in circles so he leaves
14:07:48 <monochrom> and if you hoped for (newWhen b k >>= \m -> case m of Just a -> f a; Nothing -> g), I would just go back to (if b then k>>=f else g)
14:08:47 <monochrom> anyway I'm just providing my one data point for the lack of demand for Monad m => Bool -> m a -> m (Maybe a)
14:09:24 <tromp_> :t (++)
14:09:24 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:09:34 <monochrom> people ask "why is there not so-and-so" and it always comes to down lack of supply or lack of demand. in this case I'm providing one data point to suggest lack of demand.
14:11:13 <kyagrd> > True GHC.Base.<$ "hello"
14:11:14 <lambdabot>   Not in scope: `GHC.Base.<$'
14:11:30 <kyagrd> hmm
14:12:01 <kyagrd> I wondered what GHC.Base.<$ is for
14:12:05 <ddarius> aristid: @pl does neither of those things
14:13:09 <monochrom> I do prefer (Monad m => Bool -> m a -> m ()) because I want to (when debug (forkIO (threadDelay 5000000 >> putStrLn "debugging!"))) and I couldn't care less about the threadId.
14:14:15 <nosila> hey
14:14:17 <dafis> Does anybody know how to turn off the call-pattern specialisation in ghc-7? I tried -fno-spec-constr, but it specialised nevertheless and I suspect that plays a role in nearly doubling the allocation and increasing the running time about 25% vs. 6.12.
14:14:43 <kyagrd> monochrom: use void :)
14:14:51 <wires> dibblego: btw. thanks for you help.. Regarding JVM/Haskell; Is there something similar to JMX (application monitoring) for Haskell?
14:15:04 <kyagrd> when b (void somthing)
14:15:17 <nosila> i have a newbie problem, can someone help me with some data structures creating
14:15:40 <nosila> type Some = Int
14:15:48 <sgronblo> What's wrong with my attempt at getting the nth (1-based indexing) element of a list: nth list i = list !! (i + 1)
14:16:00 <kyagrd> void is quite misleading name though
14:16:05 <nosila> type Thing = String    type Something = (Some,Thing)
14:16:10 <monochrom> SML calls it "ignore"
14:16:17 <dafis> sgronblo: shouldn't it be list !! (i-1)?
14:16:20 <nosila> how can i instance Eq on Something??????
14:16:28 <kyagrd> "ignore" makes much more sense
14:16:37 <jix> nosila: type is just used for type aliases
14:16:39 <monochrom> yeah I like it much better
14:16:49 <sgronblo> Is there a bot that can eval haskell here?
14:16:50 <jix> nosila: so Something is really just another name for (Int, String) .. not a new type
14:16:58 <jix> nosila: and there is already an Eq instance for that
14:17:15 <monochrom> nth list i = list !! (i - 1)  ?
14:17:41 <jix> nosila: if you want a new datatype (which you should do, instad of defining an alias for a tuple) you'd have to write data Something = Something Int String
14:17:42 <nosila> but i only want to check the Some Int
14:17:49 <monochrom> > [3, 1, 4] !! 2
14:17:49 <lambdabot>   4
14:17:51 <sgronblo> ah yeah it should of course be i - 1
14:18:07 <jix> nosila: for that you can then define a new Eq instance using: instance Eq Something where ....
14:18:16 <nosila> thats my problem
14:18:19 <sgronblo> however i still get a parse error on input `=' in ghci
14:18:32 <nosila> i was trying that
14:18:44 <jix> nosila: but you haven't defined a datatype, you just defined a type alias
14:18:45 <nosila> (just one thing, how can i write directly to you?? )
14:18:49 <monochrom> enter code into file and load. or write "let f x = x" at the prompt.
14:18:55 <ddarius> > 8.99e-9 / 7.07e-10
14:18:56 <lambdabot>   12.715700141442715
14:18:59 <nosila> @jix sasd
14:18:59 <lambdabot> Maybe you meant: bid id join thx
14:19:06 <jix> nosila: let's keep it here in the channel
14:19:15 <sgronblo> oh you have to use let at the prompt
14:19:16 <wires> nosila: better to say in channel
14:19:17 <nosila> jix: asd
14:19:31 <sgronblo> thanks
14:19:37 <wires> other ppl might answer as well :)
14:19:41 <ddarius> > recip 12
14:19:42 <lambdabot>   8.333333333333333e-2
14:19:44 <wires> twice even :)
14:19:47 <nosila> didnt knew i had just to write the nick lol
14:19:59 <nosila> anw, jix: i've
14:20:37 <ddarius> > 8.85e-12 / 7.07e-10
14:20:38 <lambdabot>   1.2517680339462517e-2
14:20:41 <nosila> jix: type Bla = Int data Wtv = Foo | Bar deriving Show
14:21:05 <nosila> jix: data complex = Complex Bla Wtv
14:21:10 <sgronblo> Are there any generally agreed upon naming conventions in haskell?
14:21:20 <wires> data Wtv = Foo | Bar deriving Show, Eq ?
14:21:36 <sgronblo> camel case? underscores? dashes?
14:21:46 <jix> nosila: you have to capitalize the first letter of complex
14:21:47 <dafis> sgronblo: camel case
14:21:52 <nosila> jix: im doing that to be like a enumerator in C
14:21:57 <sgronblo> dafis: right thanks
14:22:04 <ddarius> > recip 1.25e-2
14:22:04 <lambdabot>   80.0
14:22:16 <nosila> typo ;)
14:22:17 <monochrom> they use camel_case but I reject it because "only marketers think it's cool to put capital letters in the middle of words" - http://uncyclopedia.wikia.com/wiki/ZomboCom
14:22:37 <wires> lol.. true
14:22:49 <nosila> anw, i use Wtv to be like a status checker
14:22:55 <nosila> Wtv can be Foo or Bar
14:23:04 <sgronblo> I can live with any of those naming conventions
14:23:15 <sgronblo> But I can't accept an opening curly brace on a new line!
14:23:24 <nosila> and after that i just have to check wich one is in there
14:23:28 <monochrom> dash is pretty much ruled out by the grammar. a-b is not one identifier.
14:23:37 <radarsat1> hello, i'm still struggling with cabal issues, "ghc-6.12.3 requires array ==0.3.0.2 however array-0.3.0.2 was excluded because ghc-6.12.3 requires array ==0.3.0.1".. any advice?
14:23:44 <nosila> (i'm using it the right way.. right? LOl )
14:24:18 <monochrom> however, ' is accepted in identifiers, so you can do camel'case
14:24:30 <sgronblo> heh well that looks awful :)
14:24:30 <danharaj> gross
14:24:35 <danharaj> those are for mathematical primes of course
14:24:54 * jix realized you could put ' in the middle of an identifier only recently
14:25:10 <monochrom> I think I'll do more camel'case because it is easier to type than camel_case
14:25:19 <kulakowski> I really wish the subtraction sign did not resemble dashes/hyphens.
14:26:01 <wires> nosila: I'm not sure i understand you, but try data Wtv = Foo | Bar deriving Show, Eq
14:26:14 <ddarius> > let ord'x' = ord 'x' in ord'x'
14:26:15 <lambdabot>   120
14:26:17 <nosila> w8 a lilbit
14:26:28 <nosila> i will post the code i want @ pastebin
14:26:29 <nosila> easier that way
14:27:16 <monochrom> paste early. paste often. paste everything.
14:27:53 <sgronblo> Did haskell have this pattern matching for functions?
14:28:14 <wires> radarsat1: not sure if this helps? http://www.haskell.org/cabal/FAQ.html#dependencies-conflict I ran into similar issue once, but cannot remember how I solved it...
14:28:37 <jix> sgronblo: pattern matching for functions? as in having a function as parameter and matching on that?
14:28:42 <radarsat1> thanks, reading that
14:28:55 <dafis> No ghc pros here?
14:29:04 <jix> sgronblo: or just defining functions using pattern matching?
14:29:19 <sgronblo> I think I'm just thinking of the latter
14:29:32 <jix> sgronblo: yeah you do that in haskell
14:29:56 <nosila> jix: http://pastebin.com/z6nV8Upn
14:30:17 <nosila> the "........." is the part i dont know what to do / put
14:30:30 <jix> nosila: (Process id1 _ _) (Process id2 _ _)
14:30:32 <copumpkin> jmcarthur: so did your fancy type-indexed hoas-translator support n-ary binders?
14:30:41 <nosila> gonna try that ;)
14:30:43 <jix> nosila: _ means ignore the value here
14:30:58 <jix> oh you probably know that since you've used that
14:31:13 <nosila> yeah i know but i've been struggling the whole day to put that working, gonna try it again
14:32:01 <radarsat1> wires: thanks, that helped me understand the problem but not how to solve it ;)  cabal's got me going around in circles trying to install yesod properly. currently reinstalling cabal from scratch for the second time..
14:32:05 <jix> nosila: when you define functions you can pattern match but just writing the constructor followed by names that will get bound to the fields .. but you have to put that in parens
14:32:36 <sgronblo> Hmm, can't vim auto-indent haskell code?
14:32:50 <jmcarthur> copumpkin: i'm not actually sure what you mean by n-ary binders
14:33:45 <nosila> jix: didnt understood the last part
14:34:21 <copumpkin> jmcarthur: well, currently I can do forall (\x -> forall (\y -> p x y))
14:34:35 <copumpkin> jmcarthur: I want a nice way to have a fancy typeclass that lets me do forall (\x y -> p x y)
14:34:41 <sgronblo> hmm, should this work somehow? middleChars [firstChar _ lastChar] = _
14:34:56 <copumpkin> jmcarthur: the types in it would be ridiculous though
14:35:04 <nosila> jix: damn it worked
14:35:14 <nosila> jix: now i'm going to replicate it @ my project
14:35:17 <nosila> brb
14:35:18 <jix> nosila: I was just saying you can't write somefunction Process id1 _ _ ... because it will take id1 as the 2nd parameter
14:35:56 <nosila> jix: ooohhh now i get it
14:36:02 <nosila> thaaanks ;)
14:36:06 <nosila> gonna try it
14:36:39 <jmcarthur> copumpkin: oh i see
14:36:50 <sipa> sgronblo: that's not valid code
14:37:02 <copumpkin> jmcarthur: I currently have 
14:37:04 <bitweiler> is haskell platform the same as ghc?
14:37:04 <copumpkin> forall :: ((forall n. S m :<= n => Expr n q) -> Rel (S m) q) -> Rel m q
14:37:05 <jmcarthur> copumpkin: i've only ever defined combinators for that
14:37:11 <ezyang> bitweiler: No. 
14:37:19 <copumpkin> forall2 :: :: (S m :<= n, S (S m) :<= n1) => (Expr n q -> Expr n1 q -> Rel (S (S m)) q) -> Rel m q
14:37:21 <copumpkin> and so on
14:37:24 <jmcarthur> yeah
14:37:35 <copumpkin> it's kind of terrifying
14:37:44 <bitweiler> oh, I see it a platform for windows, mac and linux :(
14:37:48 <sgronblo> Or would you have to do it something like middleChars (firstChar:rest) = init rest ? Btw do you need the parameters for the head and tail construct?
14:37:56 <bitweiler> s/it/it's/
14:38:04 <nosila> jix: just one thing
14:38:16 <nosila> jix: data Process = Process
14:38:20 <nosila> those 2 gotta match???'
14:38:41 <wires> nosila: no
14:38:45 <nosila> kk
14:38:50 <jix> nosila: no, but if you have just one alternative (no |s ) it often makes sense
14:39:00 <nosila> true
14:39:47 <sgronblo> sipa: Can it be made valid somehow?
14:40:18 <sipa> you can use pattern matching to get rid of the first element of a list (assuming you want it to match lists)
14:40:30 <sipa> but not for the last one, you'll need recursion for that
14:40:42 <sipa> unless you know the length of the string beforehand
14:40:43 <ddarius> > cos (pi/6)
14:40:44 <lambdabot>   0.8660254037844387
14:40:57 <jix> sipa: there is init and last defined in Data.List maybe also in Prelude
14:40:59 <sgronblo> So you can't match an input list of size 3 or greater?
14:41:20 <jix> sgronblo: you could, but it's better to use guards or ifs for that
14:41:20 <sipa> of course you can
14:41:39 <sipa> but not on arbitrary-positions in arbitrary-sized lists
14:41:42 <sgronblo> Although I think my function should work even with the (head:tail= version too
14:41:52 <sipa> jix: which use recursion :)
14:42:06 <nosila> jix:     Warning: Pattern match(es) are overlapped              In the definition of `iguala': iguala _ _ = ...
14:42:09 <monochrom> (a:b:c:more) matches a list of size 3 or greater, but you only get hold of the first 3 items.
14:42:11 <nosila> anyway to turn that off??
14:42:30 <ezyang> nosila: You should fix your matches. 
14:42:37 <jix> nosila: have you put iguala _ _ as first line?
14:42:45 <sgronblo> all right so my attempt at (first:_:last) is completely out of the picture?
14:42:48 <nosila> nop
14:42:53 <nosila> is the second like
14:42:59 <jix> nosila: what is the first line?
14:43:02 <nosila> like as i gave it to you
14:43:10 <monochrom> "last" will not be the last item.
14:43:18 <nosila> is the .... =id1 == id2
14:43:23 <jix> nosila: oh, you don't need a second line then because the first line will always match
14:43:34 <monochrom> > case "12345678" of a:b:c:more -> more
14:43:35 <lambdabot>   "45678"
14:43:39 <jix> nosila: ghc is warning you that you have some line that can't be reached...
14:43:51 <jix> nosila: so you can just remove the second line
14:44:25 <nosila> jix: damn, my bad lol
14:44:32 <aavogt> > case "12345678" of a:b:c:(last -> x) -> x
14:44:33 <lambdabot>   '8'
14:44:43 <monochrom> it is unfortunate that ":" is a symmetric glyph and suggests more symmetry than it supports. x:y:more is x:(y:more)
14:45:07 <nosila> jix: this is BS, been trying to solve this out all the day, only 1 word was missing
14:45:14 <nosila> jix: thanks man, appreciated ;)
14:45:17 <aavogt> but you had better use a version of last that doesn't match on an empty list
14:45:28 <monochrom> whereas "," suggests more assymetry than it supports.
14:45:58 <nosila> jix: just one thing, is there any way to do the id1 == id2 check in the instance
14:46:23 <aavogt> > map (\y -> case y of a:b:c:xs@ ~(last -> x) | not (null xs) -> x; _ -> 'a') ["1234","12",""]
14:46:24 <lambdabot>   "4aa"
14:46:26 <nosila> like, in one line, without having to do a function just for that?
14:46:41 <aavogt> > map (\y -> case y of a:b:c:xs@ ~(last -> x) | not (null xs) -> x; _ -> 'a') ["123","12",""]
14:46:42 <lambdabot>   "aaa"
14:46:53 <jix> nosila: yes, (==) (Process id1 _ ... = id1 == id2 would work
14:46:55 <sgronblo> http://pastebin.com/Aqx7a84L would this be a good haskellish implementation of a function which checks if a string is a palindrome or can it still be improved?
14:47:10 <jix> nosila: and there you could even write Process id1 _ _ == Process id2 _ _ = id1 == id2
14:47:10 <nosila> ok, thanks ;)
14:47:20 <aavogt> sgronblo: yes, it's too long
14:47:27 <sgronblo> too long?
14:47:29 <jix> nosila: because with == as operator it can't parse that as multiple parameters
14:47:36 <nosila> jix: gonna try it ;)
14:47:43 <aavogt> sgronblo: and it's probably less efficient that  \x -> x == reverse x
14:48:16 <monochrom> it takes quadratic time
14:48:21 <aavogt> sgronblo: since last theoretically costs as much as reverse does (and you call last many times)
14:49:53 <monochrom> x==reverse x is probably the best you can get, especially since you have to work as hard to find length if you want to
14:49:59 <aavogt> the   if b then False else c   can be written as      not b && c
14:50:02 <edwardk> i'm thinking i'm going to rename the operations on representable functors from rep/unrep to 'tabulate' and 'index'/(!) — that way they provide sort of a clean api with a more intuitive meaning
14:50:03 <jix> sgronblo: that doesn't mean that you can't index fast in haskell, lists are just the wrong data type for that
14:50:27 <edwardk> *and in the process i think i'm splitting out index into a superclass)
14:51:39 <sgronblo> ah I guess I disregarded that because I guess I figured reversing would be expensive
14:52:47 <monochrom> palindrome is expensive on sequential medium and unknown length
14:53:04 <monochrom> but don't make it quadratic :)
14:54:28 <sgronblo> So umm does last have to traverse the whole list to the end?
14:54:36 <monochrom> yes! everytime.
14:55:42 <sgronblo> So it will be quadratic because i have n/2 calls to isPalindrome * n/2 steps to get the last or something
14:56:15 <c_wraith> I'm tempted to use unsafeCoerce again.  Every time this happens, it's because I don't understand the tools at my disposal well enough
14:58:01 <Veinor> you can do palindrome detection in O(n) right?
14:58:08 <monochrom> yes
14:58:20 <sgronblo> Of course
14:58:25 <Veinor> that is, even with a sequential medium of unknown length
14:58:40 <monochrom> yes, but then with extra memory of your own
14:58:48 <Veinor> of course
14:59:04 <jix> also I wouldn't know how to fail early without knowng at least the length
14:59:18 <sgronblo> I wasn't considering unknown lengths
14:59:45 <jix> sgronblo: but if your input type is a list it has unknown length (before traversing it completly)
14:59:47 <Veinor> jix: it's not possible to fail early without knowing the length, yeah
15:00:34 <Veinor> it strikes me that you can do O(n) palindrome detection on linked lists in a fairly simple way
15:00:40 <Veinor> (with O(n) space)
15:00:42 <jix> Veinor: well you could have a fingertree without length annotation (so length is unknown) and still fail early ;)
15:01:21 <sgronblo> Hmm, so I guess reverse also has to start at the beginning and first go to last and then start returning elements the other way?
15:01:24 <aavogt> jix: how do you know you've reached the middle?
15:01:54 <jix> aavogt: your finger tree is empty?
15:01:54 <Veinor> @pl \x -> reverse x == x
15:01:55 <lambdabot> (==) =<< reverse
15:02:06 <Veinor> @unpl reverse >>= (==)
15:02:06 <lambdabot> (reverse >>= (==))
15:02:08 <jix> aavogt: in each recursion step you take one element from the left and one from the right
15:02:14 <jix> aavogt: testing from outside to the middle
15:02:15 <Veinor> bah!
15:02:42 <jix> aavogt: but sure you need to have your string in a finger tree for that
15:02:48 <sgronblo> Haskell has sooo many operators...
15:03:01 <sgronblo> And crazy syntax characters
15:03:10 <aavogt> they are just functions
15:03:47 <kalivha> sgronblo: it's amazing!
15:04:01 <kalivha> (especially for confusing examiners, ha!)
15:04:26 <tg_> anyone know which of the tools which provide "physical units", if any, can be used for dimensional analysis?
15:05:00 <tg_> i mean, that is, I don't need physical units so much as I need detailed dimensional analysis of arbitrary units
15:05:49 <aavogt> @hackage dimensional
15:05:49 <lambdabot> http://hackage.haskell.org/package/dimensional
15:06:03 <tg_> aavogt: I just looked... these docs are better than the Dimensionalized units docs at least
15:06:31 <aavogt> tg_: what is Dimensionalized?
15:06:44 <tg_> http://www.haskell.org/haskellwiki/Dimensionalized_numbers
15:07:30 <aavogt> tg_: maybe you don't want these things at the type level?
15:07:43 <aavogt> it's much easier not to do things at type level
15:07:46 <tg_> aavogt: I don't know what I want
15:08:17 <aavogt> well you're looking to answer,   Pa  * m^3 == J ?
15:08:28 <aavogt> or something else?
15:08:30 <tg_> no
15:08:48 <tg_> i'm looking to apply a dimension to something currently dimensionless (d=1)
15:08:55 <tg_> and see what the ramifications are
15:09:20 <tg_> so i'd rather work in abstract units
15:09:46 <aavogt> @hackage vec
15:09:46 <lambdabot> http://hackage.haskell.org/package/vec
15:09:51 <tg_> [m] = [p] = [e]; [t] = [1/m] or whathaveyou
15:09:53 <aavogt> http://hackage.haskell.org/package/Vec
15:10:17 <djahandarie> I don't like that package
15:10:24 <djahandarie> It tries to do waaayyy too much
15:10:35 <tg_> djahandarie: which? Vec? or Dimensional?
15:10:39 <djahandarie> Vec
15:10:45 <tg_> well I don't think I can use it anyway
15:10:46 <aavogt> I don't mind it
15:11:02 <aavogt> but I guess often efficiency matters
15:11:15 <sgronblo> is this :: sort of a type assignment operator?
15:11:30 <monochrom> type constraint, rather
15:11:37 <tg_> well the structure that I want to analyse is recursive and infinite
15:11:44 <tg_> ... hmm
15:11:50 <djahandarie> Type annotation, technically
15:12:29 <sgronblo> Is it useful for other things than functions?
15:12:42 <monochrom> yes. (5 :: Int) is a fine use
15:12:44 <roconnor> how do you normally write <=< in latex?
15:13:00 <sgronblo> monochrom: But won't that get inferred automatically?
15:13:36 <monochrom> a long story infers 5 to Integer or Double normally
15:14:43 <azaq23> foldl (flip (:)) [] (= reverse) has to be O(n), correct? wheras reverse (x : xs) = reverse xs ++ [x]; reverse [] = [] is O(n^2), since for each (++) is itself O(n), or am I wrong here?
15:15:03 <monochrom> both are right
15:15:05 <tg_> aavogt: more generally, would haskell be appropriate to try to do this kind of dimensional analysis?
15:15:10 <tg_> or should i stick to things like Mathematica?
15:15:42 <aavogt> type information goes both ways, I dunno if mathematica can encode such things as easily
15:15:59 <tg_> aavogt: so you're suggesting it might already be easier in haskell?
15:16:01 <azaq23> monochrom: You meant me?
15:16:03 <tg_> if I encode dimensions in tyes?
15:16:05 <tg_> types?
15:16:06 <monochrom> yes
15:16:10 <jix> tg_: this sounds like something like agda could be even better
15:16:11 <azaq23> ok thanks
15:17:23 <edwardk> @hoogle Int -> [a] -> Maybe a
15:17:24 <lambdabot> Prelude (!!) :: [a] -> Int -> a
15:17:24 <lambdabot> Data.List (!!) :: [a] -> Int -> a
15:17:24 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
15:17:32 <edwardk> blah
15:17:48 <aavogt> @type fmap listToMaybe . drop
15:17:49 <lambdabot> forall a. Int -> [a] -> Maybe a
15:18:04 <edwardk> aavogt: kinda hideous =)
15:18:07 <tg_> jix: I'm really not comfortable with Haskell yet, I presume doing things in agda would entail an even steeper learning curve?
15:18:25 * aavogt can't handle agda
15:18:45 <edwardk> aavogt: k. using that as the definition of Lookup for []
15:18:45 <jix> tg_: could be, but I can imagine encoding dimensions in haskell types is more difficuilt than in agda
15:18:55 <jix> while agda in general is more difficuilt than haskell
15:19:17 <tg_> jix: do you do any group theory work in either?
15:19:32 <jix> hm?
15:19:54 <tg_> jix: the goal is to understand and analyize the properties of a fractal group
15:19:58 <tg_> (for me)
15:20:45 <tg_> that's one side, the other side is to do dimensional analysis on physical systems
15:20:59 <jix> I'm not doing any group theory work... but this really sounds like agda is more suited
15:21:01 <tg_> and to determine if there's a connection
15:21:19 <tg_> ok
15:21:25 <tg_> i'll take a serious look
15:21:29 <wires> tg_ many things which are natural to express in Agda are strange in haskell
15:21:37 <jix> but you might want to talk to someone actually using agda and not someone who just things it's awesome
15:21:48 <jix> *thinks
15:21:54 <aavogt> tg_: if it's something like adding and subtracting dimension as a result of some operations, it's straightforward to encode in haskell
15:22:08 <tg_> wires: this is the haskell's admonishment of dependant types and agda's embrace of that set of problems?
15:22:15 <wires> tg_: haskell is easier I would say and it lays a lot of foundations to step up to Agda
15:22:32 <wires> tg_: i'd say the former
15:23:03 <tg_> aavogt: it will boil down to determining what dimensions commute with each other, which anticommute, and which are really independent
15:23:12 <wires> DTP really help.. syntactically etc Agda is very minimal. "Thinking" in terms of dep. types is much longer process
15:23:26 <Philippa> tg_: I wouldn't say haskell so much admonishes them as doesn't feel it can afford them - which it couldn't at the time, and these days it'd be a total lang redesign so we get totally new langs
15:23:36 <tg_> wires: yes, I need to go through this in a playground kind of approach
15:23:48 <tg_> not in a rigorous proofs kind of approach
15:24:36 <wires> tg_: the tutorials on the Agda wiki are def. a nice start
15:24:42 <danharaj> anyone have any papers or stuff on streams that depend on each other?
15:24:45 <tg_> I mean, I need the proofs eventually, but for now I need to guess and check, a lot
15:24:48 <xplat> there was certainly not a lot understood about how to make dependent types part of a usable system when haskell was being designed.  and a lot still needs to be learned.
15:25:03 <sgronblo> heh these haskell errors are so mysterious for a beginner
15:25:43 <joe6> @hoogle [(a -> b)] -> a -> [b]
15:25:44 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
15:25:44 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
15:25:44 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
15:26:03 <wires> tg_: you'll probably be proving sooner than you think :)
15:26:38 <wires> it's like writing test suites or QuickCheck expressions, except better :)
15:26:45 <joe6> is there a function that is the opposite of map in the sense that has a signature of [(a -> b)] -> a -> [b]
15:26:47 <tg_> wires: given how crazy what I'm trying to do is
15:26:51 <tg_> I don't know about that :)
15:27:20 <jix> joe6: map ($ a) 
15:27:41 <wires> tg_: I suggest start in haskell, once you are familiar with it, go through the agda tutorial and then maybe these assignments http://www.cs.uu.nl/wiki/bin/view/DTP/Assignments
15:27:49 <jix> > map ($ 2) [(+1), (+2), (+3)]
15:27:49 <lambdabot>   [3,4,5]
15:28:09 <tg_> wires: PM for a few?
15:28:20 <shachaf> > sequence [(+1),(+2),(+3)] 2
15:28:21 <lambdabot>   [3,4,5]
15:28:43 <jix> even better :)
15:29:28 * jix has to think more of the reader like monad instance for functions 
15:29:44 <joe6> jix: cool, thanks.
15:30:05 <joe6> shachaf: thanks.
15:30:06 <jix> joe6: use shachaf's solution, it's nicer imho
15:30:54 <shachaf> jix: I think map ($ x) is clearer in some cases, actually. But sequence has the type signature joe6 was asking about. :-)
15:31:25 <joe6> shachaf: sequence type signature has m in it, can i use it for situations without a monad in them?
15:31:34 <joe6> shachaf: just as you did above.
15:31:44 <djahandarie> (r ->) is a monad
15:32:07 <joe6> that is interesting. Thanks, one more thing learnt.
15:32:33 <djahandarie> (And since it's a monad, it's also a functor)
15:32:40 <allbery_b> yeh, the trick is that *lots* of things are secretly monads
15:32:48 <djahandarie> :t (.)
15:32:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:33:07 <djahandarie> Which is why (.) can technically be defined as fmap (as seen in lambdabot)
15:33:24 * shachaf is secretly a monad.
15:33:26 <djahandarie> :t (Prelude..)
15:33:27 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:33:29 <ceii_> what kind of prelude does lambdabot use?
15:33:38 <shachaf> The Cale kind.
15:33:48 <djahandarie> ceii_, normal Prelude with a couple of things overwritten
15:33:56 * shachaf just finished eating a monad, actually.
15:33:59 <ceii_> okay
15:33:59 <shachaf> I mean burrito.
15:34:03 <djahandarie> And a couple strange modules imported
15:34:24 <allbery_b> the advantage is that it's more flexible, the disadvantage is that the error messages can be downright deadly :)
15:46:18 <deech> Looking for advice, I know many non-Haskellers (but functional programmers) who want to understand monads. I think that Applicative is really what they're looking for. How do I explain the differences between monads and applicative?
15:47:28 <sipa> @instances Applicative
15:47:28 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
15:47:33 <sipa> @instances-importing Applicative
15:47:34 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
15:48:04 <conal> deech: one difference: Applicative allows an instance to perform static analysis (as does Arrow), while Monad doesn't. For instance, look-ahead sets for parsing.
15:48:13 <Philippa> deech: 
15:48:34 <conal> deech: thanks to a loss of expressiveness in the Applicative interface relative to Monad.
15:48:36 <Philippa> deech: monads are applicatives with join - which is to say, applicatives that support higher-order programming inside the language they define
15:48:44 <deech> conal: What do you mean by static analysis?
15:49:05 <Philippa> (incidentally that's why I reckon monads have an architectural role in a sense that applicatives don't so often: you don't lose much by being in one)
15:49:21 <conal> deech: i mean the basic composition operator is <*>, which gets to look at the representations of its arguments.
15:49:38 <conal> deech: since neither is a function. (in contrast to >>=).
15:50:37 <conal> deech: for instance an applicative but non-monadic parser type can track look-ahead sets. 
15:51:06 <deech> conal: I see. Then I was on the right path. When people think monads they automatically think of a pipeline of functions - which is not the whole story. 
15:51:06 <conal> deech: i did something analogous with Applicative-based GUIs.
15:51:32 <conal> deech: yeah. it's the function part that thwarts analysis.
15:52:05 <conal> deech: as for expressiveness, i think Monad corresponds to context-sensitive grammars, while Applicative corresponds to context-free grammars.
15:52:13 <conal> deech: (roughly, anyway)
15:52:34 <deech> conal: It seems as though a majority of the non-Haskell world has been sold Applicative under the name of monads.
15:52:44 <conal> deech: hm!
15:52:49 <Philippa> conal: monads get you turing completeness given a turing complete host language - it's trivial, you consume characters and pass them into a 'real' turing machine
15:53:04 <conal> Philippa: yeah.
15:53:35 <Philippa> we describe what >>= buys you as "context-sensitivity", but the class of "context-sensitive grammars" is something else
15:53:39 <conal> while Applicative is merely algebraic. (no functions.)
15:53:56 <conal> Philippa: yeah.
15:54:04 <deech> conal, Philippa: I appreciate your input.
15:54:45 <conal> deech: you might suggest the principle of "the simplest tool for the job". and point out that Monad is more complex than needed for some jobs.
15:55:26 <conal> a sort of occam's for intelligent/tasteful design.
15:55:30 <conal> (occam's razor)
15:56:28 <deech> conal: true and most monads that people implement in Java etc. don't pass the monad laws, but are almost Applicative.
15:56:31 <Philippa> I'm in two minds about that - if you can write the code well locally without using monad and it's not for want of ado then yeah, it's sensible to do so, but constraining to applicatives-that-aren't-monads isn't good if you can avoid it
15:56:47 <conal> deech: wow.
15:56:51 <Philippa> deech: that depends, how do they break the monad laws?
15:57:12 <Philippa> meeting them modulo some concern is rather traditional, for example
15:57:48 <conal> to paraphrase einstein: build your software with abstractions that are as simple as possible and no simpler.
15:59:02 <Philippa> in terms of not getting in the way if you need to start passing in and using stuff from the outside monads are 'simpler' though
15:59:11 <conal> deech: one reason i prefer sticking to the Applicative interface is so that i find out whether i can. which helps me understand my problem and solution. and helps me understand how general it is.
15:59:28 <Philippa> it's a definite trade-off if you're building bits that go in the middle of a system rather than the leaves
16:00:10 <marekweb> is there such a thing as a simple explanation of what a monad is? i still don't get it
16:00:11 <conal> deech: oh! another difference: Applicative is closed under composition, while Monad is not. Hence we don't need Applicative transformers. They're their own transformers.
16:00:29 <Philippa> marekweb: monads are a family of embedded languages with specific properties
16:00:59 <Philippa> yeah, closed under composition's a useful property at least
16:01:15 <deech> Philippa: For the most part they try and do something like: http://stackoverflow.com/questions/4765260/criticize-simple-monad , where people try to have (>>=) do more than just take a value out of a monadic context and hand it off to a function.
16:01:27 <conal> marekweb: i recommend approaching that question in stages. Monoid, then Functor, then Applicative, then Monad. the last step will be easy.
16:01:42 <Zer> Howdy... is the Try Haskell feature properly compatible with Firefox? Figured I'd try it, but when I got to step 4, it sat spinning and never gave a result. Step 6, same thing happens. Have to reload
16:02:03 <Philippa> deech: yeah, that one's an "equality modulo..." case - equal modulo the bind counter
16:02:15 <marekweb> conal ok looks like I have a lot of reading to do. thanks
16:02:23 <conal> :)
16:02:47 <ddarius> marekweb: It's an endofunctor T with two natural transformations η : Id → T and µ : T ∘ T → T such that µ ∘ η_T = id = µ ∘ Tη and µ ∘ µ = µ ∘ Tµ.
16:04:01 <beastaugh> marekweb: I quite like Dan Piponi's article
16:04:03 <beastaugh> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
16:04:18 <deech> Also the Applicative interface is nice because it emphasizes composing. The monad interface, especially the do notation, makes it seems as though you can have mutable state.
16:04:31 <deech> It trips up a lot of people
16:04:39 <conal> marekweb: often i suspect people are looking for something that isn't there when they ask "what are monads?". Monad isn't a kind of thing. it's a pattern that categorizes many kinds of things.
16:04:40 * ddarius doesn't feel like he has mutable state at all using monad notation.
16:05:08 <marekweb> interesting
16:05:13 <ddarius> s/monad notation/do notation/
16:05:23 <copumpkin> it's a thing for sufficiently general values of thing :P
16:05:29 <deech> ddarius: Not even when you look at it from the perspective of an imperative programmer?
16:05:32 <int80_h> @hoogle lookup
16:05:32 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
16:05:33 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
16:05:33 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
16:05:35 <ddarius> deech: No.
16:06:07 <ddarius> deech: It looks imperative, but it doesn't look like it has mutable state.
16:06:07 <int80_h> @hoogle splitON
16:06:08 <lambdabot> No results found
16:06:10 <int80_h> @hoogle splitOm
16:06:11 <lambdabot> No results found
16:06:12 <int80_h> @hoogle splitOn
16:06:13 <lambdabot> No results found
16:06:57 <conal> i think the notation was chosen to suggest sequential imperative (action-oriented) computation, including the choice of the word "do". unfortunately, many people take that suggestion literally, and thing that Monad is somehow imperative.
16:07:22 <fryguybob> @hackage split
16:07:22 <lambdabot> http://hackage.haskell.org/package/split
16:07:27 <j-invariant> why even write progarm
16:07:48 <ddarius> j-invariant: Why do anything at all?
16:07:51 <deech> ddarius: people wonder why when you have {do x <- something; ...; return x} you can't do {do x <- something; x++ ...; return x}
16:07:58 <Twey> Why is babby formed?
16:08:13 <j-invariant> ddarius: I cant answer the difficult question so I try ask an easier versino
16:08:21 <Philippa> conal: yeah. Next thing you know you have people claiming that you lose all of referential transparency even with monads where that's not true (eg Writer where you're RT modulo the order and repetition of the outputs)
16:08:30 <ddarius> j-invariant: I asked the easier question.
16:08:40 <j-invariant> hmm
16:09:16 <ddarius> deech: There is no postfix ++ operator (or postfix operators at all).
16:09:41 <Twey> :t ("abc" !!)
16:09:42 <lambdabot> Int -> Char
16:09:49 <djahandarie> He didn't put a semicolon so I imagine it was suppose to be infix
16:09:57 <Twey> Look, it's a postfix operator that changes a list into a function on ints ;)
16:10:03 <ddarius> djahandarie: Then you can write that.
16:10:12 <pastorn> Do i have any guarantees that unsafeInterleaveIO produces lazy values?
16:10:18 <ddarius> > do x <- [1,2]; x ++ [3]; return x
16:10:19 <lambdabot>   No instance for (GHC.Num.Num [a])
16:10:19 <lambdabot>    arising from a use of `e_1123' at <int...
16:10:26 <conal> Philippa: for instance, [] is a monad. and that realization causes list operations to lose RT.
16:10:31 <ddarius> > do x <- [[1,2]]; x ++ [3]; return x
16:10:32 <lambdabot>   [[1,2],[1,2],[1,2]]
16:10:37 <deech> ddarius: I know, people wonder why. 
16:10:44 <conal> or even the identity functor/applicative/monad
16:10:57 <deech> djahandarie: There was supposed to be a ; after x++
16:11:02 <pastorn> i want to put 'hLookAhead' in unsafeInterleaveIO (after running hReady)
16:11:53 <Philippa> conal: well quite. The Writer case is in some regards more annoying though because it's not as obviously messed up as that and you do get a more subtle property in the embedded language, but it sure as hell isn't as bad as unconstrained imperative programming
16:14:43 <sepp2k> What's the lambdabot command to get the instance definition for a specific class instance?
16:14:44 <luite> has anyone seen this error? it looks like cairo fails to load, but it doesn't say what goes wrong: http://hpaste.org/43641/cabal_install_v_chart___error
16:18:13 <ddarius> deech: People who nothing about Haskell don't need do notation to wonder why they can't write x++.
16:20:57 <Julien> rochebin
16:26:42 <ddarius> Or to put it another way, those people are the same people who are going to wonder why they can't write f(x++) (well, you -can- write that...), print (getArgs!!0), or if null(readFile "foo") then ...
16:26:51 <pedro3005> what is that weird name for :: ?
16:27:10 <monochrom> no other name. just say ::
16:27:19 <pedro3005> there is a name!
16:27:26 <pedro3005> it's like...
16:27:26 <monochrom> or say nothing. you are not a modem. why convert code to voice.
16:27:40 <pedro3005> I'm sure there is a name
16:27:47 <pedro3005> I can't remember it
16:27:56 <pedro3005> because it was weird, big and in some strange language
16:27:56 <int80_h> converting code to voice helps me understand what I am talking about and form useful questions.
16:28:14 <Twey> pedro3005: Haha
16:28:20 <monochrom> just convert code to text. sufficient for irc questions
16:28:24 <ddarius> It's 'squigglypuff'.  You should read f :: Int -> Int as "f squigglypuff Int to Int"
16:28:31 <Twey> pedro3005: Are you thinking of the T_PAAMAYIM_NEKUDOTAYIM?
16:28:32 <Philippa> pedro3005: an annotation? Or do you mean a name for the glyph?
16:28:41 <pedro3005> yup.
16:28:46 <int80_h> if it wasn't before, it's squigglypuff now. Now and forever.
16:28:47 <Twey> That's a PHP craziness :þ
16:28:57 <pedro3005> I thought "learn you a haskell" was fucking with me
16:28:57 <Twey> It just means ‘double colon’ in Hebrew
16:28:59 <pedro3005> but I googled it
16:30:07 <systemfault> Ah PHP... idiot to the core
16:30:20 <monochrom> I can sell you my v.24 modem so you can hear how it pronounces :: and mimic it.
16:30:49 <Julien> is haskell better than c# ?
16:30:55 <pedro3005> yeah
16:30:56 <systemfault> Gotta love the anti-darwinian nature of PHP
16:31:01 <Eelis> Julien: yes, by 16%
16:31:02 <systemfault> pedro3005: Yes and no.
16:31:04 <monochrom> #haskell is better than #c#
16:31:16 <systemfault> Haskell has more letters so it's better.
16:31:20 <Rotaerk> Eelis, 16.502%
16:31:23 <Rotaerk> obviously..
16:31:31 <Eelis> Rotaerk: yeah, i used a c# program to do the rounding :/
16:31:38 <monochrom> hahaha
16:31:38 <Rotaerk> :P
16:32:07 <Rotaerk> it is rather odd how C# is so much more mainstream than haskell
16:32:15 <Rotaerk> yet #haskell has double the members of ##csharp
16:32:28 <Eelis> doesn't strike me as odd at all
16:32:30 <dolio> C# programmers don't have time to chat.
16:32:33 <dolio> They're getting shit done.
16:32:42 <Rotaerk> you calling haskell programmers bums? :P
16:32:58 <monochrom> they are too web-2.0 to irc. find them on forums.
16:33:01 <sm> haskell is a popular teaching language
16:33:01 <dolio> Plus, getting shit done in C# takes so much more effort.
16:33:30 <Rotaerk> does it?
16:33:37 <dolio> More typing, at least.
16:34:02 <Rotaerk> I don't think typing is the bottleneck usually
16:34:42 <Rotaerk> unless maybe you're a terrible typist, and can think about the problem between keystrokes
16:35:05 <dolio> http://hackage.haskell.org/trac/ghc/ticket/4864#comment:1
16:35:09 <edwardk> hah, leibnizian equality for the win! i found a workaround for the lack of equality constraints for superclasses! =)
16:35:15 <dolio> The guy who filed that bug disagrees with you.
16:36:14 <Twey> dolio: Haha
16:36:33 <edwardk> I wanted "class (…, Representable (Trie a), Key (Trie a) ~ a) => HasTrie a where type Trie a :: * -> *"
16:37:12 <edwardk> but was able to at least give class (…, Representable (Trie a)) => HasTrie a where type Trie a :: * -> *; keyRefl :: a := Key (Trie a)
16:37:58 <edwardk> using the leibnizian equality newtype a := b = Refl { subst :: f a -> f b } from 'eq'
16:38:15 <dolio> I do hope they fix up the equality superconstraints soon.
16:38:29 <edwardk> then i can use that to hack around by providing manual equality witnesses as needed
16:38:34 <dolio> They were enabled in a 7 prerelease, and seemed to work, but I guess I was deceived.
16:38:56 <edwardk> i'm not looking forward to fixing up the trie semigroupoid, but the basic HasTrie stuff looks good
16:38:57 <dolio> You could just use an equality GADT, too.
16:39:17 <int80_h> could a [Char] be considered equivilent to a String?
16:39:27 <int80_h> a haskell string I mean.
16:39:30 <edwardk> this has the benefit of having all the stuff to support injectivity witnessing, etc.
16:39:55 <Twey> int80_h: It *is* a String
16:39:56 <edwardk> i could probably get there the other way, but it seems more principled
16:39:56 <dolio> I seem to recall Oleg posting some caveats about that implementation of equality, that were only lifted via some type family addition.
16:40:03 <Rotaerk> int80_h, http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:String
16:40:04 <Twey> int80_h: type String = [Char]
16:40:14 <edwardk> yeah, i provide that in a package (with a cleaner encoding even)
16:40:16 <Twey> > ['a', 'b', 'c']
16:40:16 <lambdabot>   "abc"
16:40:22 <Twey> Just syntax sugar
16:40:23 <edwardk> http://hackage.haskell.org/packages/archive/eq/0.1.3/doc/html/Data-Eq-Type.html
16:40:44 <int80_h> Twey: gotcha
16:43:07 <iago> hi all, I would appreciate some advice about calculation of cyclomatic complexity for Haskell, how should I calculate the CC of an application f x ? Currently I'm using CC(f)*CC(x), the same rule is applied for let-in's (which I treat as applications), I think that's ok though when a function has many local binds which make use of if-then-else, case etc the CC index is very high
16:46:00 <glguy> iago: Out of curiosity, are you using Template Haskell to compute this?
16:46:11 <glguy> or maybe just haskell-src?
16:48:39 <dolio> http://hpaste.org/43642/equality
16:48:46 <dolio> That got a little repetitive.
16:49:40 <j-invariant> data a := b where Refl :: a := a
16:49:45 <edwardk> dolio: =)
16:49:53 <edwardk> but the leibnizian version is so much more fun =)
16:50:14 <edwardk> and its haskell 98 unless you want injectivity
16:50:19 <dolio> Yes. It took me a long time to figure out how to write symm the first time.
16:50:46 <edwardk> i use it over in scala a lot where i can't use the GADT approach
16:50:55 <edwardk> or rather, where the GADT approach doesn't compose =(
16:52:00 <edwardk> i should probably just use the GADT version, less overhead
16:52:04 <jix> Is it correct, that I should be able to to get the largest element of an arbitrarily ordered fingertree with a maximum monoid in O(log n)?
16:52:29 <jix> by just choosing the child digit/subtree/whatever with the largest measured value?
16:52:45 <jix> because I don't see how I can do that with the api exported by the fingertree package
16:52:46 <edwardk> jix: correct
16:53:10 <edwardk> just extract the measure of the fingertree
16:53:13 <iago> glguy, haskell-src-exts
16:53:38 <jix> edwardk: ok, that would work but actually I want to do more
16:53:43 <dolio> edwardk: Is there a type family for each lowerN?
16:54:10 <edwardk> the usual way to get it so you can split there and remove it, is to make a monoid out of Max and Last
16:54:22 <edwardk> dolio: yeah
16:54:30 <dolio> In that case, the GADT seems superior.
16:54:44 <jix> edwardk: ah, that would work, thanks
16:55:24 <jix> edwardk: but wouldn't some functions to recurse on the tree that expose the measurements of inner nodes be usefull anyway?
16:55:25 <edwardk> type family Inj f :: *; type instance Inj (f a) = a; newtype Lower a b = Lower { unlower :: Inj a := Inj b };lower :: f a := f b -> a := b; lower eq = unlower (subst eq (Lower id :: Lower (f a) (f a)))
16:55:47 <jix> that way I wouldn't need Last in addition to Max
16:55:57 <edwardk> dolio: the main difference is that the rest of the equalities are available in haskell 98, unlike the GADT version
16:56:06 <dolio> Yeah.
16:56:39 <dolio> Well, not H98.
16:56:46 <edwardk> oh rank2
16:56:46 <dolio> H98 + Rank2Types?
16:56:48 <edwardk> fark
16:57:54 <edwardk> yeah i guess the true 98 encoding would suck, using all those typeclasses
16:59:41 <jix> Now if I want to get the largest value not larger than a given limit. That would be trivial with recursion, but I don't see how to do it with split (yet).
17:05:38 * hackagebot hbeanstalk 0.2.2 - Client for the beanstalkd workqueue service.  http://hackage.haskell.org/package/hbeanstalk-0.2.2 (GregHeartsfield)
17:11:24 <int80_h> short of using Parsec, is there a simple way to take a String that is a http header file, and split up each \n terminated line into a String and thereby returning a [String]?
17:12:03 <int80_h> or should I just use Parsec? It seems like killing a fly with a nuke though.
17:12:09 <duairc> int80_h: unlines?
17:12:19 <duairc> I mean lines
17:12:20 <duairc> Oops
17:12:21 <ddarius> Or just use a HTTP library that does this for you...
17:13:11 <int80_h> lines was right, thanks
17:13:23 <nosila> hey
17:13:44 <ddarius> "Greg Heartsfield" ...
17:14:02 <nosila> what's the diference between
17:14:04 <nosila> data ZonedTime = ZonedTime { zonedTimeToLocalTime :: LocalTime zonedTimeZone :: TimeZone }
17:14:10 <nosila> anw
17:15:10 <nosila> type zonedTimeToLocalTime = LocalTime    type zonedTimeZone = TimeZone    data  ZonedTime = ZonedTime zonedTimeToLocalTime zonedTimeZone
17:15:11 <nosila> ????
17:15:50 <stepcut> zonedTimeToLocalTime (in the original) as the type, zonedTimeToLocalTime :: ZonedTime -> LocalTime
17:16:50 <stepcut> in the original zonedTimeToLocalTime and zonedTimeZone are both functions.. you are trying to declare them as type alias
17:18:04 <stepcut> well, they are 'special' functions.. they are field labels in a record. So you can also do, let zt = ZonedTime { zonedTimeToLocalTime = someLocalTime, zonedTimeZone = someTimeZone } 
17:24:12 <jix> I have the feeling split is as powerfull as recursion on the tree type itself... if I think a little bit more about it ;) 
17:33:16 <Julien> giiiiix
17:35:47 <int80_h> is it common practice to use Network.HTTP and Network.Curl together? Or do I need to pick one?
17:36:22 <int80_h> Network.HTTP seems to have a richer set of functions for header parsing
17:36:34 <int80_h> but Curl does everything else I need easily.
17:42:46 <int80_h> @hoogle liftIO
17:42:46 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
17:47:02 <int80_h> how would I extract a [Header] from a Network.Stream.Result [Header]
17:47:22 <int80_h> this is from the package Network.HTTP
17:49:10 <roconnor> int80_h: const [] :P
17:49:12 <Eduard_Munteanu> type Result a = Either ConnError a
17:49:48 <Eduard_Munteanu> So you can use something like 'either'
17:50:28 <int80_h> does that mean I need a case statement?
17:50:41 <Eduard_Munteanu> That, or 'either'.
17:51:06 <augustss> howdy
17:51:15 <Eduard_Munteanu> :t either
17:51:16 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
17:51:18 <Eduard_Munteanu> o/
17:51:26 <int80_h> hmm, I get a type error when I do "either pHeaders" where pHeaders is the type I mentioned above
17:52:00 <augustss> int80_h: look at the type
17:52:00 <Eduard_Munteanu> > either (const "Error") id $ Left False
17:52:01 <lambdabot>   "Error"
17:52:02 <Bynbo7> are you giving it three arguments like its type says you must?
17:52:12 <Eduard_Munteanu> > either (const "Error") id $ Right ["foo", "bar"]
17:52:13 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:52:13 <lambdabot>         against inferred type...
17:52:54 <Eduard_Munteanu> > either (const "Error") head $ Right ["foo", "bar"]
17:52:55 <lambdabot>   "foo"
17:53:57 <Eduard_Munteanu> 'either' applies either the first or right argument by pattern-matching the Either there.
17:54:04 <Eduard_Munteanu> *or second
17:54:13 <int80_h> Eduard_Munteanu: I do this "let stripped = either (const pHeaders) id $ Left False" which gives stripped the same type as pHeaders.
17:55:02 <int80_h> not the [Headers] I was looking for
17:55:12 <sipa> move along
17:55:20 <Eduard_Munteanu> Well, maybe it's easier to reason in terms of Maybe.
17:55:50 <Eduard_Munteanu> Something like    either (const Nothing) Just $ ...
17:56:02 <int80_h> in your "foo" "bar" example, it returns the same type as well.
17:56:38 <Eduard_Munteanu> int80_h: well you can't return different types depending on situation in Haskell anyway.
17:56:56 <Eduard_Munteanu> In fact that's what Either makes possible.
17:57:04 <int80_h> When I have  Just a, I can return a
17:57:23 <int80_h> why can't I return [Header] from that above mentioned type
17:57:44 <Eduard_Munteanu> You can. But what do you return in case pHeaders is Left <something> ?
17:58:02 <Eduard_Munteanu> [] ?
17:58:21 <int80_h> [] would work
17:58:33 <Eduard_Munteanu> Then    either (const []) id $ pHeaders
17:59:36 <int80_h> Eduard_Munteanu: that's it!
17:59:45 <int80_h> thanks :)
17:59:47 <Eduard_Munteanu> (However, the main point of Either is just like Maybe except you get some information about errors which have occured; Left ... values are errors here)
18:00:26 <int80_h> Eduard_Munteanu: Well, I'm just playing right now. When it comes time to put this in production I will include Error handling.
18:02:23 <copumpkin> hmm
18:02:31 <copumpkin> do guards desugar to >>= or >> ?
18:02:42 <copumpkin> seems odd, but I can sort of see why
18:03:05 <dolio> List comprehensions don't desugar to monad operations at all.
18:03:10 <dolio> According to the standard, at least.
18:03:27 <copumpkin> I mean guards on function clauses
18:03:55 <edwardk> ok. representable tries work, now to make a semigroupoid out of them
18:04:04 <copumpkin> if I have -XRebindableSyntax turned on, it complains about not having the usual monadish things in scope
18:04:09 <dolio> In that case, I'm even more confused.
18:04:32 <monochrom> f x | x>0 = "haha"  is not desugared
18:04:34 <copumpkin> dolio: I'm guessing it's using a True <- expr
18:04:49 <copumpkin> monochrom: try it, with RebindableSyntax
18:05:36 <copumpkin> I'd like to see a spec for RebindableSyntax
18:06:02 <copumpkin> since we can now rebind guards, if/then/else, and all the stuff we could do with NoImplicitPrelude before
18:07:10 <copumpkin> Philippa: I kind of went overboard but it's starting to come together into something recognizable
18:08:12 <edwardk> copumpkin: list comprehension desugaring is scary stuff in the ghc compiler
18:08:18 <copumpkin> yeah
18:08:21 <copumpkin> but I'm not even using list comps
18:08:44 <copumpkin> I imagine monad comprehensions when they're done will fall under this umbrella too
18:08:48 <edwardk> fair nuff. i misparsed based on the context of the conversation above
18:09:00 <copumpkin> I'm talking about f x | even x = blah
18:09:08 <copumpkin> those seem to require >>=, >>, and fail
18:09:09 <copumpkin> :)
18:09:14 <ddarius> copumpkin: How much money do I owe you by the way?
18:09:21 <Eduard_Munteanu> I wonder how that's even possible.
18:09:49 <copumpkin> ddarius: about 50 I think. The receipt might even be in the bag the bottles were in
18:09:58 <dolio> It might use a monad to desugar pattern guards, and just use the same thing for normal guards.
18:10:04 <dolio> I have no idea what monad it'd be, though.
18:10:25 <dolio> I mean, something Maybe-ish, presumably, but I don't know if it's actually Maybe.
18:10:56 <ddarius> copumpkin: Unless it was in one of the paper bags, it isn't in the plastic bag.
18:11:04 <copumpkin> ddarius: hmm, guess not then
18:12:20 <ddarius> copumpkin: Perhaps pattern guards need them.  Normal guards shouldn't.
18:13:21 <copumpkin> ddarius: normal guards to doo
18:13:22 <copumpkin> too
18:13:23 <copumpkin> lol
18:13:26 <copumpkin> do too
18:13:28 * copumpkin kicks himself
18:13:40 <copumpkin> ddarius: I imagine they simplified the code paths by making normal guards be True <- expr
18:14:21 <copumpkin> what's even odder
18:14:30 <copumpkin> is that even importing (>>) from Prelude, it isn't happy
18:15:04 <copumpkin> oh yeah it is
18:15:11 <copumpkin> but still, I'm still surprised that it wants them
18:16:34 <dolio> Is this not documented in the GHC users' guide?
18:17:00 <copumpkin> I don't see it
18:22:20 <nosila> jix: just saw that now, yep that's what i tought, just asked to really know that those 2 things were diferents
18:22:58 <nosila> jix: because i didnt find anyplace that explained the ZonedTime { ..... } 
18:24:15 <nosila> anw, i need to save the actual time, so i can use it later to see the diference between the begining and the 'actual' time then, what's the easyest way to do that?
18:25:00 <nosila> found the Data.Time.LocalTime data TimeOfDay
18:25:05 <drbean> Say I defined a function for an arbitrary list of args, eg f 1 = 3; f 2 = 5, f 3 = 7, is there a command to get the args for which f is defined, eg args f = [1 .. 3]
18:26:44 <Eduard_Munteanu> I guess it's not documented because it doesn't have definitional-value, it's simply something related to implementation.
18:26:55 <Eduard_Munteanu> s/-//
18:27:27 <Eduard_Munteanu> (erm space)
18:28:07 <drbean> I want to write something like g (args f) = map f (args f)
18:28:22 <Bynbo7> eh?
18:28:44 <Bynbo7> no, there isn't
18:29:52 <drbean> Or g, for the (args f), = map f (args f)
18:30:32 <Bynbo7> no, that would require some fairly hefty introspection
18:30:57 <drbean> Is that something Template Haskell would do?
18:31:11 <Eduard_Munteanu> I'm not sure what you mean by 'args f' :/
18:31:52 <drbean> A function which returns a list of the arguments for which another function is defined.
18:31:52 <nosila> but there isnt any getTimeOfDay.... 
18:32:46 <Bynbo7> drbean: what should the result of args (+1) be?
18:33:33 <drbean> Are the args of (+1) defined?
18:33:50 <roconnor> @hoogle intersperse
18:33:50 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
18:33:50 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
18:33:50 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
18:34:01 <Twey> drbean: A function should be defined for all arguments
18:34:06 <Twey> Generally
18:34:47 <drbean> If a function is defined using pattern matching, it is only defined for some arguments.
18:34:50 <Eduard_Munteanu> So technically he want a function that generates all values of a given type.
18:34:54 <Eduard_Munteanu> *wants
18:35:14 <Twey> drbean: Not really
18:35:16 <Eduard_Munteanu> Oh, you can't distinguish a partial function in haskell.
18:35:38 <Eduard_Munteanu> You can only trip on it by calling it, and the RTS will bail out.
18:35:45 <Twey> f n = 5 -- f is defined for all possible arguments
18:35:54 <Bynbo7> drbean: it's very bad form to define a function only for certain inputs
18:36:23 <Twey> I think you can catch a pattern-match failure using Control.Exception.catch
18:36:44 <Twey> But that's not really the point, and that would be a very slow way to decide :þ
18:38:08 <Eduard_Munteanu> drbean: is this for testing code? If so, maybe you should take a look at QuickCheck
18:40:47 <roconnor> why is my program leaking memory
18:42:02 <drbean> I'm trying to add lots of entries to a 'lexicon' function: http://gist.github.com/812156
18:46:36 <Bynbo7> drbean: a better way to do it would be to define a list [(String, [Cat])], and then use that for both lexicon and men
18:47:22 <drbean> I was going to say: "I guess I need to turn to a vim function to add them in the module...."
18:47:44 <drbean> A list? A list of the args?
18:48:48 <ddarius> Represent your "lexicon" as a data structure like a normal person.
18:49:53 <Bynbo7> drbean: yes, and then you can just make lexicon s = lookup s list
18:56:59 <augur> pahaha
18:57:04 <augur> transformers: monads in disguis
18:57:06 <augur> oh wow
18:57:22 <augur> needs to be in black tho
18:57:24 <djahandarie> Haha
18:57:25 <augur> or grey or some other color
18:57:36 <djahandarie> Where is that quote from?
18:57:44 <gwern> @quote disguise
18:57:44 <lambdabot> No quotes match. It can only be attributed to human error.
18:57:50 <gwern> we'll never know
18:57:57 <Bynbo7> djahandarie: haskellers.com/bling
18:58:08 <djahandarie> Ah, haha
18:58:46 <djahandarie> Erm
18:58:53 <gwern> so I'm guessing transformers is some newfangled feature in some other language?
18:58:54 <djahandarie> Did anyone else's Haskellers account get totally wiped?
18:59:32 <Bynbo7> i think mine did, so i signed up again
18:59:38 <djahandarie> Ugh
18:59:41 <djahandarie> Mine is still there
18:59:48 <djahandarie> But I logged into something else
18:59:51 * djahandarie emails snoyman
19:00:00 <sm> mine worked fine today
19:00:51 <sm> I tell a lie
19:01:09 * hackagebot semigroupoids 1.1.1 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.1.1 (EdwardKmett)
19:01:09 <sm> must stop lying
19:01:25 <djahandarie> Semigroupid theory
19:01:30 <djahandarie> Sounds even scarier
19:02:09 * hackagebot comonad-transformers 1.5.0.4 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.0.4 (EdwardKmett)
19:04:06 <drbean> @src lookup
19:04:06 <lambdabot> lookup _key []          =  Nothing
19:04:06 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
19:04:06 <lambdabot>                         | otherwise = lookup key xys
19:08:21 <gwern> categories sans id?
19:08:33 <gwern> what sort of category doesn't support 'id a = a'?
19:10:39 <Eduard_Munteanu> I think he means without an identity element..
19:11:43 <Eduard_Munteanu> OTOH, I'm not sure about nomenclature here... I know about groupoids and semigroups, but in category theory there may be a beast such as a semigroupoid.
19:12:12 * hackagebot keys 0.1.0 - Keyed functors and containers  http://hackage.haskell.org/package/keys-0.1.0 (EdwardKmett)
19:13:20 <Eduard_Munteanu> Oh, right... http://en.wikipedia.org/wiki/Semigroupoid
19:14:02 <Bynbo7> urgh, wtf, now i have two haskellers accounts?
19:15:17 <Eduard_Munteanu> Hrm, so the composition law isn't unique (though associativity must hold)?
19:16:22 * Eduard_Munteanu misread a bit
19:16:33 <edwardk> gwern: semigroupoids are weaker than categories. they just have the associativity law
19:17:49 <edwardk> gwern: consider the writer monad when you only have a semigroup instead of a monoid.
19:18:03 <gwern> edwardk: ok, I'm considering it...?
19:18:26 <edwardk> gwern: kleisli composition works, but it doesn't offer you return.
19:18:42 <gwern> edwardk: in monoid terms, no mempty?
19:18:48 <edwardk> semigroupoids as a package provides versions of monads without return, applicative without pure, etc.
19:18:58 <Eduard_Munteanu> Nice.
19:19:06 <edwardk> lots of comonads offer the (<*>) part of the applicative to merge them together but can't provide the 'pure'
19:19:13 <edwardk> exactly
19:19:37 <gwern> edwardk: but, if you don't have a base like mempty then what do you start with?
19:20:02 <gwern> my list has to start somewhere with [], or my Product with a 1 or my Sum with 0
19:20:03 <edwardk> an example of things you can do with them that you can't do with Category. the product of two semigroupoids and coproduct of two semigroupoids is always possible to encode in haskell
19:20:06 <Eduard_Munteanu> Well you can pack it beforehand just like with comonads.
19:20:20 <Eduard_Munteanu> (those don't have pure/return either)
19:20:23 <BMeph> edwardk: Like rose trees? ;)
19:20:29 <edwardk> gwern: consider a non-empty list as a comonad it starts with the first element.
19:20:36 <edwardk> Data.Tree always has a first element
19:21:01 <edwardk> gwern: induction can start from 1, not 0 ;)
19:21:14 * BMeph raises his fists in intarweb victory!
19:21:47 <edwardk> you can actually prove almost all the same stuff as you can in category theory using semigroupoids and semifunctors between them
19:21:59 <davekong> Is there a way to compose two IO functions and bind the result to a variable such that the variable won't be IO var?
19:22:02 <edwardk> you lose uniqueness on some things, but semi-cartesian closed categories exist
19:22:07 * Eduard_Munteanu wonders why the restriction to small classes
19:22:16 <edwardk> davekong: effectively, no.
19:22:33 <edwardk> Eduard_Munteanu: ?
19:22:37 <djahandarie> Why did category theory pick categories anyways?
19:22:45 <edwardk> djahandarie: because they are useful =)
19:22:51 <ddarius> id is important
19:22:53 <Eduard_Munteanu> edwardk: I was reading the wikipedia article and Ob(semigroupoid) is a set.
19:23:06 <Eduard_Munteanu> davekong: maybe you mean...
19:23:10 <Eduard_Munteanu> :t (>>>)
19:23:11 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
19:23:19 <edwardk> eduard_munteanu: nothing keeps you from extending the concept to a large semigroupoid made out of classes
19:23:21 <Eduard_Munteanu> :t (>=>)
19:23:21 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:23:26 <Eduard_Munteanu> Ah.
19:24:04 <Eduard_Munteanu> davekong: Kleisli arrow composition ^
19:25:25 <ddarius> edwardk: How does Yoneda go?
19:26:42 <tg_> different time of day: can anyone think how to attach an attribute/system of attributes like abstract dimesions to all haskell functions (functors? something more specific?)
19:28:34 <aavogt> wrap everything in somethinng like   newtype A dimension b = A b
19:28:58 <aavogt> but that only works for things of kind *
19:29:36 <aavogt> (or some other kind if you pass in the right number of type variables)
19:30:19 <edwardk> ddarius: in what sense?
19:31:12 <ddarius> Does Yoneda hold in semigroupoids and what's the proof?
19:31:47 <edwardk> no idea.
19:31:51 <davekong> Eduard_Munteanu: looks like what I wanted was >>=, thanks for the tip, set in the right direction
19:32:03 <edwardk> no identity arrows to use, so it'd be tricky
19:33:09 <Eduard_Munteanu> davekong: ah, I misunderstood you... you probably wanted something like f x >>= g, while I took composition literally as in (f >=> g) x
19:33:56 <djahandarie> Does the set of all semigroupoid morphisms form a semigroupoid under composition?
19:34:28 <Eduard_Munteanu> Do you mean semigroup or groupoid? :)
19:34:41 <edwardk> =P
19:34:54 <Eduard_Munteanu> Because I'm not sure there's such a thing as semigroupoid in group theory.
19:35:08 <djahandarie> What? I mean semigroupoid
19:35:38 <Eduard_Munteanu> (I meant the latter occurence of 'semigroupoid')
19:36:20 <edwardk> djahandarie: a semigroupoid morphism is a 'semifunctor'. there should be a full fledged category of semifunctors
19:37:06 <edwardk> you'd need to enlarge the definition of semigroupoid from that of what wikipedia says (they say its objects are a set), but then you can have a semigroupoid induced by the category of semifunctors between semigroupoids.
19:37:43 <ddarius> You could consider very small semigroupoids.
19:37:52 <edwardk> ah true
19:38:14 <ddarius> Anyway, not having Yoneda would be a serious issue.
19:43:19 <Eduard_Munteanu> Meh, googling semigroupoids yields crap.
19:43:23 <edwardk> going over literature
19:44:40 <Eduard_Munteanu> Is there another name for them? There seems to be some overlapping with group theory and even functional analysis, *sigh*
19:45:13 <tg_> semi-direct product groupid ?
19:46:06 <Eduard_Munteanu> Hah, there are things called monoidoids :)
19:46:22 <Eduard_Munteanu> Lemme see...
19:46:50 <dolio> Monoidoid = category
19:47:01 <Eduard_Munteanu> Heh.
19:48:08 <gwern> categories are monoids over monoids?
19:48:12 <djahandarie> Magmaoid = ???
19:48:17 <edwardk> Eduard_Munteanu: semigroupoid and semicategory are the two names i've seen
19:48:32 <gwern> djahandarie: oh, that's the starter fire type in Pokemon Chrysolite
19:48:35 <edwardk> but semicategory has been used for multiple things
19:48:44 <ddarius> Matroid
19:48:45 <djahandarie> Hahaha
19:49:06 <ddarius> gwern: A groupoid (under one definition) is a "typed" group, much like a category is a "typed" monoid.
19:49:07 <Eduard_Munteanu> edwardk: ah, thanks
19:51:05 <applicative> How do we complete the sentence "a group is a groupoid with one ____"?
19:51:11 <edwardk> ddarius: http://archive.numdam.org/ARCHIVE/CTGDC/CTGDC_2002__43_3/CTGDC_2002__43_3_163_0/CTGDC_2002__43_3_163_0.pdf talks a bit about yoneda and semigroupoids
19:51:23 <ddarius> edwardk: Found numdam I see.
19:51:27 <ddarius> Lots of good old stuff there.
19:51:34 <edwardk> they use the semi-category name
19:52:24 <Eduard_Munteanu> Hrm... odd stuff... this looks like watered-down category theory, with elements of abstract algebra... http://books.google.ro/books?id=4HQUbFX9iWgC&pg=PA74&lpg=PA74&dq=semigroupoid&source=bl&ots=BbUelTb3aJ&sig=mRWs4virJORkEHOwkh7xiIB1V-o&hl=ro&ei=1MtMTZ2tNMyhOtL19NwP&sa=X&oi=book_result&ct=result&resnum=3&ved=0CCkQ6AEwAjge#v=onepage&q=semigroupoid&f=false
19:52:47 <Eduard_Munteanu> Basically monoidoids as categories, but they still use set theory and such.
19:54:25 <edwardk> 'monoidoids' just sound downright silly ;)
19:54:37 <Eduard_Munteanu> Yeah :))
19:55:13 <edwardk> ddarius: anyways, it looks like yoneda working is a pretty good characterization of when one of these things is a category
19:55:19 * Eduard_Munteanu guesses Cat would be monoidoidoid
19:55:49 <edwardk> Eduard_Munteanu: bah, not fond of terminology that doesn't scale like that ;)
19:56:14 <edwardk> you start talking about mon{oid}^6's and stuch ;)
19:56:18 <edwardk> er such
19:57:36 <djahandarie> What could you possibly need mon{oid}^6 for? :P
19:57:50 <Eduard_Munteanu> I prefer semicategories I think.
19:58:04 <Eduard_Munteanu> (for semigroupoid)
19:58:06 <edwardk> Eduard_Munteanu: i'm not in a hurry to rename the package a second time ;)
19:58:33 <Eduard_Munteanu> edwardk: no, it's rather fine, googling semigroupoid points right at your stuff :)
19:58:38 <edwardk> haha
19:59:13 <edwardk> sadly it'll go the way of kan extensions, googling them points right at me. which is really frustrating when you're trying to figure out some fine point or other
20:07:25 <dibblego> @type flip
20:07:26 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
20:09:26 <alexsuraci> jmcarthur: hi, you around?
20:10:18 <edwardk> k:w
20:10:29 <edwardk> wrong window =)
20:16:18 <int80_h> @hoogle Writer
20:16:19 <lambdabot> module Control.Monad.Writer
20:16:19 <lambdabot> Control.Monad.Writer.Lazy newtype Writer w a
20:16:19 <lambdabot> Control.Monad.Writer.Lazy Writer :: (a, w) -> Writer w a
20:18:26 <ddarius> semihemidemicategory
20:23:40 <augur> is there a standard dec-to-bin function?
20:24:19 <int80_h> http://hpaste.org/43644/writer_monad_blues
20:24:31 <copumpkin> :t showIntAtBase
20:24:32 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
20:24:38 <copumpkin> (generalized in all the wrong ways)
20:24:52 <augur> whaa
20:25:18 <Eduard_Munteanu> int80_h: well Writer takes two types.
20:25:31 <copumpkin> :t showIntAtBase 8 intToDigit 12432
20:25:31 <lambdabot> String -> String
20:25:33 <Eduard_Munteanu> int80_h: one is the log type, the other is the return type
20:25:36 <copumpkin> > showIntAtBase 8 intToDigit 12432 ""
20:25:37 <lambdabot>   "30220"
20:25:57 <augur> lame
20:25:59 <copumpkin> > showIntAtBase 16 intToDigit 12432 "0x"
20:26:00 <lambdabot>   "30900x"
20:26:04 <copumpkin> whoops
20:26:07 <copumpkin> > showIntAtBase 16 intToDigit 12432 ""
20:26:07 <int80_h> Eduard_Munteanu : ah, okay what happens if I don't need to log anything? What would a dummy log look like?
20:26:08 <lambdabot>   "3090"
20:26:14 <augur> i wanted to show the haskell version of http://www.reddit.com/r/programming/comments/ff84c/do_i_expect_too_much_from_programmers/
20:26:30 * hackagebot representable-functors 0.1.0 - Adjunctions  http://hackage.haskell.org/package/representable-functors-0.1.0 (EdwardKmett)
20:26:31 <Eduard_Munteanu> int80_h: why use a Writer then?
20:26:36 <augur> numOnes = length . filter ('1'==) . toBinString
20:26:37 <augur> but noooo
20:26:58 <int80_h> Eduard_Munteanu: I need to save a state. I'm going to be collecting cookies
20:27:25 <int80_h> Eduard_Munteanu: dafis recommended Writer
20:27:36 <Eduard_Munteanu> int80_h: say, for a function that return an Int and logs into a string, you have Writer String Int
20:27:40 <jmcarthur> alexsuraci: hey
20:27:40 <lambdabot> jmcarthur: You have 1 new message. '/msg lambdabot @messages' to read it.
20:28:09 <int80_h> Eduard_Munteanu: But Int won't have anything I need in it. Trying to not write superfluous code.
20:28:10 <Eduard_Munteanu> int80_h: then Writer [Cookie] ReturnValue ?
20:28:12 <jmcarthur> alexsuraci: got the message. thanks!
20:28:27 <Eduard_Munteanu> You can use () then.
20:28:36 <alexsuraci> Np
20:29:00 <int80_h> Eduard_Munteanu: so my last line would read "tell fCookies ()"?
20:29:37 <Eduard_Munteanu> int80_h: if fCookies is a single cookie, then you do something like tell [fCookies]
20:30:21 <Eduard_Munteanu> If it's a list of cookies then just 'tell fCookies'
20:31:01 <int80_h> Eduard_Munteanu: fCookies is a single String. WHich is why I did "tell fCookies". Why would tell [fCookies] work when fCookies is a String, and Writer wants two return values?
20:32:03 <Eduard_Munteanu> int80_h: ok so your log is a string. But Writer also produces a return value (just like Reader, ST etc.).
20:32:56 <ddarius> copumpkin: While I don't disagree with your statement, which ways should it have been generalized?
20:33:20 <ddarius> edwardk: Do you have any (co)continuity stuff in adjunctions?
20:33:24 <int80_h> Eduard_Munteanu: Yes, but Writer fCookies () produces the exact same error
20:33:24 <copumpkin> if it's going to be that general, why not let it be (a -> b) and then have it return a list of [b]
20:33:29 <copumpkin> where b could be Char for the current definition
20:33:53 <Eduard_Munteanu> int80_h: erm, don't you mean Writer String () ?
20:33:56 <copumpkin> and [b] -> [b]
20:34:53 <int80_h> Eduard_Munteanu: for the final line in my function?
20:35:02 <Eduard_Munteanu> int80_h: no, for the type of your function.
20:35:11 <ddarius> Hackage should have a source link without needing the haddock.
20:35:11 <int80_h> nothing wrong with my type
20:35:15 <Eduard_Munteanu> findCookies :: String -> Writer String ()
20:35:22 <int80_h> ooh yeah there is
20:35:24 <int80_h> okay I see
20:35:33 <ddarius> edwardk: Not that you control this, but the github link for representable-functors is giving me a 404.
20:35:41 <copumpkin> same for keys
20:35:58 <edwardk> ddarius: i haven't uploaded it yet to github
20:36:05 <edwardk> i was juggling a few of these at the same time
20:36:13 <ddarius> Interesting...
20:36:33 <ddarius> At least the 404 page is deceptively amusing.
20:36:38 <int80_h> Eduard_Munteanu: okay I see what else needs to be fixed. I didn't realize the original error was telling me I had a broken type.
20:37:29 <Eduard_Munteanu> int80_h: also look at your '<-' lines, those functions probably don't live in the Writer monad.
20:37:36 <NemesisD> hi all, trying to set up my first cabal project. i'm writing some tests in hunit but i can't figure out how i can import my package's modules from the test directory
20:37:42 <Eduard_Munteanu> So use 'let' instead.
20:37:46 <int80_h> yup, I just realized that was broken
20:37:49 <edwardk> i have a few packages being broken out so one of the downstream dependencies of the next two isn't ready to be pushed yet, repos going up in probably 20 minutes
20:38:01 <Eduard_Munteanu> int80_h: as a matter of fact it's probably simple enough to rewrite that function without using Writer at all (or any monad)
20:38:22 <int80_h> I'm going to need to collect strings
20:40:58 * ddarius can't help but find "Teach Scheme/Reach Java" haunting.
20:48:45 <adu> i have a question
20:48:47 * ddarius takes drinks from his refridgerator and puts them in front of his partially opened window to chill them.
20:48:53 <ddarius> adu: I don't believe you.
20:49:08 <int80_h> Eduard_Munteanu: Hey thanks for your help. I'm headed home now.
20:49:12 <adu> how do I make parsec's buildExpressionParser only operate on stuff until it gets an error
20:49:25 <Eduard_Munteanu> No problem.
20:50:20 <adu> e.g. x >= y + z { return r; }, how do I make it so that only tokens up until { are consumed by buildExpressionParser?
20:50:23 <ddarius> adu: You could set up your (sub)parsers to succeed in whatever way is appropriate when they would have failed, but it sounds like you're doing something wrong.
20:50:48 <adu> probably :)
20:51:12 <ddarius> adu: You tell buildExpressionParser how to parse the expressions before the { and it will do the right thing.
20:51:25 <adu> ok
20:51:57 <adu> oooo it does
20:52:05 <adu> the problem must be elsewhere :)
20:52:08 <adu> thanks
20:53:38 * hackagebot keys 0.1.0.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-0.1.0.1 (EdwardKmett)
20:53:40 * hackagebot representable-functors 0.1.0.1 - Adjunctions  http://hackage.haskell.org/package/representable-functors-0.1.0.1 (EdwardKmett)
20:54:39 * hackagebot adjunctions 0.7.0 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.7.0 (EdwardKmett)
20:54:39 <tg_> jesus edwardk you're a machine
20:55:06 <ddarius> edwardk: Why a "monad isomorphism"?
20:55:13 <djahandarie> Pale in comparision to when ManateeLazyCat updates something
20:56:19 <tg_> djahandarie: well I meant all the various works he's doing
20:56:28 <tg_> manatee is only working on one thing, afaik, in a sense
20:56:48 <djahandarie> I mean in terms of hackagebot spam, of course
20:56:52 <tg_> yes
20:57:01 <tg_> they are both formidable spammers
20:57:22 <djahandarie> Formidable opponents.
20:57:37 <tg_> i was really wanting to say it
20:57:41 <ddarius> edwardk: tabulateresentable is never going to take off.
20:58:25 <edwardk> ddarius: =) rep/unrep really kinda hurt intuition
20:58:39 * hackagebot representable-tries 0.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.1 (EdwardKmett)
20:58:58 <edwardk> ddarius: as for why, currently i wanted to have access to the monad for the tries i was constructing with them. i may relax that and just require an isomorphism and make the Rep/RepT monads provide the monad
21:00:36 <edwardk> in fact i very likely will make it so that Rep f is a monad, but drop the requirement that f be one, that would let me avoid a few orphans
21:01:40 * hackagebot representable-functors 0.1.0.2 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.1.0.2 (EdwardKmett)
21:04:42 <edwardk> ok. everything should have a repository now
21:05:04 <edwardk> next i need to do a lot of work on representable-tries to add the remaining missing trie types
21:05:41 * hackagebot kan-extensions 0.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-0.1 (EdwardKmett)
21:10:42 * hackagebot representable-functors 0.2.0 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.2.0 (EdwardKmett)
21:11:42 * hackagebot adjunctions 0.8.0 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.8.0 (EdwardKmett)
21:12:43 * hackagebot kan-extensions 0.1.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-0.1.1 (EdwardKmett)
21:16:26 <edwardk> ok. 'monad isomorphism' relaxed. that got rid of the few orphans i had lying around
21:16:44 * hackagebot representable-tries 0.2 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.2 (EdwardKmett)
21:16:48 <mafs> Alright, this "Edward Kmett" guy is making the rest of us look bad. We need to do something about him...
21:16:55 <edwardk> eep!
21:18:13 <ddarius> Not sure if it's worthwhile, but you can define stuff like: phi :: Adjunction f u => (u a, u b) -> u (a,b); phi = leftAdjunct $ \p -> (rightAdjunct fst p, rightAdjunct snd p); phi' :: Adjunction f u => u (a,b) -> (u a, u b); phi' p = (fmap fst p, fmap snd p)
21:18:23 <ddarius> :t fmap fst
21:18:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> f a
21:18:59 <ddarius> Similarly for (), Void, and Either.
21:19:48 <ddarius> And presumably for Kan extensions and, presumably, natural transformations.
21:21:41 <edwardk> hrmm
21:22:10 <edwardk> phi: is basically guaranteed to have zip semantics too
21:22:44 <ddarius> phi and phi' are components of an isomorphism (after covering your ears to many a lie)
21:23:41 <edwardk> *nods*
21:24:24 <ddarius> You can use (***) if you want to make them look slicker.
21:24:39 <ddarius> Or (&&&) I guess.
21:25:17 <ddarius> leftAdjunct (rightAdjunct fst &&& rightAdjunct snd); fmap fst &&& fmap snd
21:26:33 * ddarius doesn't feel like writing ends in terms of limits right now.
21:28:06 <edwardk> what i the Void version you were thinking of?
21:28:41 <edwardk> u Void -> Void ?
21:28:50 <ddarius> It would be f Void -> Void.
21:29:28 <edwardk> rightAdjunct void ?
21:30:01 <ddarius> Yep.
21:31:08 <ddarius> leftAdjunct (const ()) for the opposite.
21:31:25 <edwardk> well, the opposite can just be 'void'
21:31:34 <ddarius> edwardk: Not the inverse.
21:32:14 <edwardk> hrmm
21:32:23 <ddarius> The inverse is just void.
21:32:46 <edwardk> erm isn't that what i said?
21:32:56 <ddarius> leftAdjunct (const ()) shows () -> u () (with inverse const ()).
21:33:10 <edwardk> oh thats what you were talking about. sure
21:33:21 <edwardk> that one i already derived when you mentioned () above
21:35:13 <ddarius> :t fmap Left ||| fmap Right
21:35:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => Either (f a) (f b) -> f (Either a b)
21:35:28 <edwardk> yep
21:35:35 <edwardk> got that
21:36:27 <ddarius> That's the "obvious" direction, though the inverses are also rather obvious.
21:36:33 <edwardk> yeah
21:36:35 <adu> found it!
21:36:42 <edwardk> by that one i meant the inverse =)
21:36:51 <adu> the error is coming from (optionMaybe $ goSemi goSimple)
21:36:55 <copumpkin> lol, http://snapplr.com/0avt
21:36:56 <ddarius> (Which isn't surprising as this is a theorem that should be stated for -all- (co)limits.)
21:37:15 <ddarius> goGoGadget
21:37:43 <edwardk> too bad we can't quite get to a free Traversable that way though
21:39:57 <ddarius> edwardk: You may want to look at "Category Theory as Coherently, Constructive Lattice Theory" (again).  It has some nice theorems relating adjunctions and initial/final (co)algebras.
21:47:54 <ddarius> :t let phi :: Functor u => u (forall a. a) -> u a; phi = fmap id in phi
21:47:55 <lambdabot>     Illegal polymorphic or qualified type: forall a. a
21:47:55 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
21:47:55 <lambdabot>     In the type signature for `phi':
21:48:51 <edwardk> so between the 'cozipping' and Void projections we know that any left adjoint functor has basically exactly one slot for an 'a'.
21:51:28 * ddarius needs explicit type application.
21:52:37 <edwardk> given f -| g : Hask -> Hask,   f has exactly one and only one place for an element to reside. fmapping it will return one element, folding it would return f of that element, etc.
21:53:24 <edwardk> because otherwise we could quantify and use the projection of void to derive bottom, or we would be unable to derive cozip
21:53:40 <edwardk> the former precludes fewer than one holes, the latter precludes more than one
21:55:49 <davekong> I have this function: addBracket (x, y) = (x, (head (words x)) ++ (dropWhile (==' ') y))
21:55:56 <davekong> and it works when I type it into ghci
21:56:56 <ddarius> Okay, so phi :: Functor u => u (forall a. ...) -> u (...); phi = fmap (\(x :: forall a. ...) -> x) works with enough extensions.
21:57:09 <davekong> but but in my program I get a compile error: http://codepad.org/RlpWzH0w
21:57:30 <edwardk> ddarius: erm, with the quantifier there, can't you just say id ?
21:57:56 <ddarius> No.
21:58:06 <ddarius> It's not the id function.
21:58:22 <ddarius> Specifically, the lambda is not the id function.
21:59:21 <edwardk> just thinking that given f (forall a. a) i can relax that to forall a. f a, which is the type you have on the rhs
22:00:01 <davekong> words is not an argument to head -- (words x) is -- so I don't really understand
22:00:03 <edwardk> plus doesn't that need impredicative types and all that? and aren't impredicative types gone now?
22:00:16 <edwardk> davekong:  hrmm
22:00:51 <edwardk> can you paste the code fragment in question from the source?
22:01:03 <Eduard_Munteanu> davekong: head takes a list not a function.
22:01:09 <azaq23> davekong: the error says that you try to apply head to words
22:01:22 <davekong> but I am applying words to x which returns a list
22:01:31 <davekong> and then applying head to that
22:01:51 <azaq23> in the example you gave, you do and it is correct.
22:01:58 <edwardk> @type \ (x, y) -> (x, head (words x) ++ dropWhile (==' ') y)
22:01:59 <lambdabot> (String, [Char]) -> (String, String)
22:02:06 <edwardk> this version is happy
22:02:07 <davekong> I have the same code in my source
22:02:10 <Eduard_Munteanu> 'head words x' won't work, but 'head . words $ x' or 'head (words x)' will.
22:02:20 <davekong> I will paste 
22:02:24 <edwardk> please
22:03:06 <joe6> need some design advice: I have a big blob of microchip pic asm code (~1KLoc'ish) which is a pita to maintain. I checked out atom to see if I could convert it to some form of Haskell-maintenance mode, but I could not make much sense of the atom documentation. Just wanted to check if you have any suggestions..
22:03:32 <ddarius> edwardk: Impredicative types are still in 7.0.1, though I agree, my understanding was that they intended to get rid of them quite a while ago.
22:04:01 <davekong> http://codepad.org/c7voNTrI
22:04:51 <davekong> hmm that worked
22:05:42 <ddarius> This would be easier with explicit type abstraction and application.
22:07:15 <davekong> well I have not idea what is going on, it seems to be working now
22:07:17 <Eduard_Munteanu> joe6: Haskell as a code generator will probably work, but attempting to rewrite that in Haskell won't really do.
22:08:03 <Eduard_Munteanu> Still, 1 kloc-ish asm code is probably a lot smaller in C.
22:08:17 <joe6> Eduard_Munteanu: I am under the impression that atom is also some kind of code generator. Yes, I agree, it would be impossible to put haskell on 1Kbytes of ram, I presume.
22:09:11 <joe6> Eduard_Munteanu: yes, I am still debating why I did not do it in C. But, I was just starting up and I had problems debugging asm created by the C compiler, hence just started off with asm.
22:12:00 <ddarius> Holy crap it worked.
22:12:41 <ddarius> :t let phi' :: (forall a b. ((a -> u b) -> f a -> b, (f a -> b) -> a -> u b)) -> (forall a. u a) -> u (forall a. a); phi' (rightAdjunct, leftAdjunct) = leftAdjunct (rightAdjunct (\(x :: forall a. u a) -> x)) in phi' -- ENOTENUFEXTNS
22:12:42 <lambdabot>     Illegal polymorphic or qualified type: forall a. a
22:12:42 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
22:12:42 <lambdabot>     In the type signature for `phi'':
22:13:23 <edwardk> whoa, nice
22:13:27 <ddarius> So, forall a is a limit (it can be viewed as an infinitary product) and thus is preserved by right adjoints.
22:13:33 <edwardk> yep
22:13:41 <edwardk> i actually got that before you said it =P
22:13:43 <ddarius> The body could be anything, it doesn't have to be forall a. a
22:13:50 <ddarius> edwardk: So did I.
22:14:12 <ddarius> I understood it a while ago (technically years ago) but I'm a little amazed that GHC swallowed it.
22:15:00 <ddarius> I'll leave exists as an exercise (that should, actually, be a bit easier.)
22:15:16 <edwardk> isn't the exists case the f Void -> Void one we did?
22:15:28 <edwardk> oh wait thats non-existence
22:18:34 <ddarius> Everyone can rest easier now that we have a constructive proof that (forall a. r -> T(a)) ~ (r -> forall a. T(a))
22:19:11 <ddarius> Ignore the fact that the result was used to derive the result (that what you get for working in a self-enriched category.)
22:19:46 <edwardk> you can kill the impredicative types with forallR :: Adjunction f u => (forall a. u a) -> u Any
22:20:22 <Eduard_Munteanu> I for one wasn't losing any sleep over that :P
22:20:24 <ddarius> edwardk: It can be forall a. u (T(a)) for any type expression T.
22:20:54 <edwardk> yes. Any is coercible to such. it just let me kill the flaky extension
22:21:12 <ddarius> Do you use unsafeCoerce to get back?
22:22:22 <edwardk> i don't remember what tools were exposed with Any
22:22:24 <edwardk> =)
22:22:48 <edwardk> i just remember it being the only thing you're safely allowed to coerce anything into without fear of it being applied or forced incorrectly
22:24:38 * ddarius should write a paper "When is id not id"
22:25:06 <edwardk> i think i'll stick to the impredicative version
22:26:04 <ddarius> Unfortunately, since there's no convenient way to say forall a. f a where f is an arbitrary type function, this isn't too useful.
22:26:46 <edwardk> one could make a type like the Limit type in category extras, which just takes an f and quantifies its contents
22:27:32 <ddarius> Yes, I did something like that for exists when impredicative types first came out, but it's still unsatisfactory.
22:27:33 <Eduard_Munteanu> Hrm, why nobody suggested "Category Theory As Coherently Constructive Lattice Theory" to me before... looks interesting.
22:27:47 <ddarius> Eduard_Munteanu: You never asked.
22:28:57 <Eduard_Munteanu> Ah, I asked for categorical-oriented Haskell books, but not for category theory books with slight connections to TT and programming.
22:29:00 <Eduard_Munteanu> Fair :).
22:30:41 <edwardk> perhaps something like: limitR :: Adjunction f u => Limit (Compose f u) -> Limit (Compose u f) — or something along those lines
22:30:47 <edwardk> er
22:31:07 <edwardk> limitR :: Adjunction f u => Limit (Compose x u) -> Compose (u x)
22:31:29 <edwardk> s/Compose(u x)/Limit (Compose (u x))
22:32:18 <edwardk> but thats basically Distributive =/
22:32:34 <edwardk> with slightly tighter quantification
22:37:14 <edwardk> nm thats a muddled mess
22:39:06 <ddarius> The problem is you really want to say things like exists a. (a, a -> b) or whatever and needing to make up a type constructor for that is more of a hassle than it's worth.
22:39:33 <edwardk> *nods*
22:40:10 <c_wraith> uh.  Isn't that particular case the same as just saying b?
22:40:15 <ddarius> Perhaps that's something that should be added to SHE.
22:41:19 <ddarius> preflex: seen conor
22:41:19 <preflex>  Sorry, I haven't seen conor
22:43:47 <ddarius> Eduard_Munteanu: There aren't really any category theory oriented Haskell books.
22:44:05 * hackagebot timeplot 0.2.17 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.17 (EugeneKirpichov)
22:45:05 <Tau> hi. can i redefine the -> ?
22:45:09 <ddarius> No.
22:45:26 <NemesisD> is it possible to get the haddock documentation for installed packages? for some reason text.json has disappeared from hackage
22:47:56 * ddarius imagines up some grotesque hackery to implement type functions with simple textual preprocessing and relatively minor explicit isomorphisms.
22:48:48 <bvck> folks, is the (<-) in list comprehension any different from the (<-) in the monad 'do...' haskell syntax sugar?
22:49:28 <c_wraith> it desugars to the same expressions.  It doesn't do the same thing, because (>>=) doesn't do the same thing.
22:50:04 <c_wraith> > do { x <- [1..3] ; y <- [4..6] ; return (x + y) }
22:50:05 <lambdabot>   [5,6,7,6,7,8,7,8,9]
22:50:19 <c_wraith> > do { x <- [1..3] ; y <- [4..6] ; return (x, y) } -- probably more useful
22:50:20 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
22:51:30 <bvck> c_wraith, I get that in a do structure. What about [ x + 2 | x <- [1...8]]?
22:51:46 <bvck> Is the <- in this desugar the same way?
22:51:57 <c_wraith> bvck: list comprehensions are basically the same thing as using the list monad
22:52:51 <bvck> Oh, hell. Of course. Forgot that list is a monad. Thanks.
22:53:13 <saf> Wow guys, nice job on the tryhaskell site.
22:53:18 * Eduard_Munteanu would've rather guessed evince didn't open ps.gz directly, but it does.
22:54:09 <Eduard_Munteanu> NemesisD: cabal haddock
22:54:12 * hackagebot adjunctions 0.8.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.8.1 (EdwardKmett)
22:54:40 <Eduard_Munteanu> Never tried it, but I've seen it there.
22:54:55 <Eduard_Munteanu> (same package as cabal install)
22:58:42 <ddarius> Eduard_Munteanu: evince is pretty nice.
22:59:11 <ddarius> Sometimes it won't do ps.gz because of silly mime-type things.
23:15:12 <Wooga> hello, can someone help me with understanding Data.Enumerator iteratees? how do i use basic `enumList 2 "abcaasdfs"' with basic `consume' ?
23:20:39 <Bynbo7> Wooga: http://docs.yesodweb.com/blog/enumerators-tutorial-part-1/
23:20:54 <Wooga> Bynbo7: yes, i am reading this three parts, but still can't understand
23:21:40 <Wooga> there is nothing like minimal one-string example for ghci
23:24:40 <joe6> evince is slow.
23:26:55 <Wooga> how do i produce `Step a m b' ?
23:27:23 <Wooga> `Yield 123' yields `Yield 123 :: (Num t) => Stream a -> Step a m t'
23:27:36 <Wooga> not just `Step a m b'
23:28:01 <Wooga> which is required by enumList's thirs argument
23:28:12 <Wooga> third*
23:28:55 <geheimdienst> "Stream a -> Step a m t" means this is a function that takes a "Stream a" and gives you a "Step a m t"
23:29:06 <Wooga> ah
23:29:22 <geheimdienst> although i don't know the specifics of iteratees. dunno how you'd make a Stream
23:29:33 <Wooga> i know, thank you very much!
23:29:57 <Wooga> `(Yield "abc") EOF' seems to work
23:38:54 <Wooga> but i still can't understand how to combine enumerator and iteratee
23:40:33 <Wooga> `enumList' takes `Step', not `Iteratee', while `consume' prodices `Iteratee', not `Step'
23:40:41 <Wooga> produces*
23:44:39 <Maxdamantus> @pl flip when
23:44:40 <lambdabot> flip when
23:47:53 * hackagebot language-go 0.7 - A library for analysis and synthesis of Go code.  http://hackage.haskell.org/package/language-go-0.7 (AndrewRobbins)
23:54:41 <taotree> Is there a quick and easy to to export from a module everything in this module and also everything from an imported module?
23:56:01 <azaq23> > let x :: Double; x = -14.857142857142858 in map (\k -> ((x ^^ (k + 1) - 1) / (x - 1)) - (sum $ map (x ^^) [0 .. k])) [10 .. 18] -- (Geometric series identity) Now that is some floating point rounding error
23:56:02 <lambdabot>   [0.0,0.0,0.0,0.25,0.0,0.0,1024.0,16384.0,0.0]
23:56:02 <kfr> Hmm I don't know how to export everything, but you can easily export other modules
23:56:26 <nanothief> taotree: doesn't leaving the export list empty (ie module MyModule where) do this?
23:56:30 <kfr> Oh
23:56:43 <taotree> nanothief, I also want to re-export everything from a single imported module
23:57:05 <kfr> taotree: module Blah(module My.Import(..)) where
23:57:10 <kfr> I think it was something like that
23:59:12 <nanothief> right, didn't read your question right
23:59:16 <taotree> almost...
23:59:33 <taotree> it's module Blah(module Blah, module My.Import) where
23:59:42 <taotree> thanks
