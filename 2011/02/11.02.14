00:14:09 <lewis1711> either I've been doing too much scheme recently, or haskell has *a lot* of syntax
00:18:34 <ddarius> lewis1711: Scheme has a decent amount of syntax too, though Haskell certainly has more from any perspective.
00:18:51 <ddarius> lewis1711: If you want to see languages that actually have pretty minimal syntax, look at Joy or Forth.
00:18:58 <ddarius> (or PostScript)
00:20:18 <Cale> Scheme masquerades its syntax by making it all look the same as function applications.
00:21:33 <lewis1711> but they are all function applications
00:21:34 <Kaidelong> Haskell could probably get by with less syntax
00:22:02 <ddarius> lewis1711: Definitely not.  What is the "lambda" function?
00:22:04 <Kaidelong> if...then...else could definitely go
00:22:16 <ddarius> Most of the syntax for Haskell is pretty superficial.
00:23:04 <Kaidelong> ddarius: dunno about scheme, but I'm not sure how setq/qset/qsetq are functions on LISP.
00:23:09 <ddarius> Kaidelong: And about earlier, byorgey mostly said it.  Monads and comonads are a direct generalization of closure operators and every adjunction gives rise to both.
00:23:09 <lewis1711> lambda :: arguments -> body -> (arguments -> body)
00:23:33 <lewis1711> no that's not it
00:23:34 <Cale> closure operators and interior operators respectively
00:23:41 <ray> yeah but then what's the type of body
00:23:57 <ddarius> lewis1711: From that perspective you can say all of Haskell's syntax is just "function applications" which would be silly.
00:24:36 * Kaidelong doesn't quite understand why Haskell would be different from Scheme, syntax wise. You could certainly write haskell that way if you wanted
00:25:31 <opqdonut> Kaidelong: curried functions don't interact well with parens-is-application
00:25:32 <Cale> lewis1711: Normal function applications (f x y z) in scheme will evaluate each of f, x, y, z, and then apply the function to the arguments. Lambdas don't evaluate their bodies prematurely like that, so right away there's something fishy going on :)
00:25:33 <opqdonut> in my opinion
00:25:50 <Cale> and laziness isn't even enough to account for that sort of thing
00:25:53 <Kaidelong> opqdonut: Why not?
00:25:57 <Cale> because lambda is actually a binding form
00:26:30 <Kaidelong> opqdonut: Actually, it translates naturally, application just becomes left associative
00:26:43 <shachaf> Kaidelong: In this syntax, would x = (x) = ((x))?
00:26:49 <opqdonut> that too
00:27:10 <opqdonut> and ((f x) y z) == (f x y z) == (((f x) y) z) =?= f x y z
00:27:16 <Kaidelong> shachaf: the "syntax" would "look the same"
00:27:17 <Cale> When you write something like (lambda (x) (+ x x)), the variable x is in scope in the body of the lambda because of its occurrence in the parameter list, and x doesn't need to be in scope to occur in the parameter list in the first place.
00:27:28 <Kaidelong> it wouldn't be scheme the language
00:28:06 <ddarius> @tell copumpkin Incidentally, Fokkinga's approach to category theory falls under the "reduce everything to initiality" approach and you can see in his work how this leads to him creating new categories willy-nilly.
00:28:06 <lambdabot> Consider it noted.
00:28:10 * Kaidelong qualified his earier statement that way, for reference
00:28:52 <Kaidelong> Anyway I don't consider Haskell heavy on syntax
00:29:15 <opqdonut> in my opinion haskell syntax is great because everything that looks like a function application is a function application
00:29:26 <opqdonut> and not a "macro" or other built-in
00:29:31 <Kaidelong> Although some things could certainly go
00:29:35 <ddarius> That's because Haskell is tasteful with syntax and most of it is very superficial (but well-motivated.)  The TH AST, for example, is pretty hairy though.
00:29:46 <opqdonut> keeps things pure
00:29:48 <Kaidelong> (if..then..else, do syntax, guards)
00:29:51 <opqdonut> Kaidelong: sure, like if
00:30:01 <Cale> opqdonut: though it's arguable that if/then/else breaks that property
00:30:05 <opqdonut> Cale: indeed
00:30:13 <opqdonut> it "should" go
00:30:15 <Cale> I kinda like if/then/else being there.
00:30:26 <opqdonut> me too, except when I don't
00:30:26 <allbery_b> it's not a macro, it's the ? : operator from C
00:30:28 <ddarius> opqdonut: Actually, that is one of the things that makes me ambivalent about TH (and I think either was changed or at least suggested to be changed recently.)  Splices have an explicit syntax which makes them fugly for some things, but at least you know they're there.
00:30:43 <allbery_b> and you can desugar it into a case if you are really offended by it
00:30:44 <Kaidelong> Cale: the main problem is that it is not a function, but it could be
00:31:04 <Kaidelong> Cale: this results in people using it that way and perhaps not realizing there is a better way
00:31:37 * ddarius is indifferent about if-then-else.
00:32:08 * allbery_b tends to use it as a statement, for the same reason he avoids the ? : in C and Perl
00:32:32 <Kaidelong> allbery_b: ? : is different from if...then..else in those languages
00:32:35 * ddarius tends to use ?: in C# a likely higher than average amount.
00:32:40 <Kaidelong> in haskell this difference does not exist
00:33:12 <Kaidelong> (haskell has no statements in the normal sense of the word, so that follows naturally)
00:33:46 <ddarius> Kaidelong: Actually, the Report identifies two forms as "statements" (or at leasts "stmts.")
00:34:17 <allbery_b> There are other languages in which if-then-else is an expression.  (Perl is actually one of them)
00:34:24 <Kaidelong> ddarius: Yes but from what I remember that is a liberal use of the word "term"
00:35:11 <ddarius> Kaidelong: I wouldn't say so.  I would say uses of the term that rule out the use in Haskell are mixing up levels and overly restrictive.
00:35:21 <allbery_b> Algol did it, most procedural languages which don't changed the default (since most of them are descended from Algol)'
00:35:21 <Kaidelong> "statement"
00:36:25 <Kaidelong> allbery_b: the distinction wouldn't really make sense in perl anyway, would it?
00:36:49 <Kaidelong> actually I suppose it doesn't have to in haskell either
00:36:50 <allbery_b> I'd look at it as being the same kind of nonsense as PROCEDURE vs. FUNCTION in Fortran and derivatives
00:36:58 <Kaidelong> a missing "else" could just be "else undefined"
00:37:15 <Kaidelong> allbery_b: A function is not the same thing as a procedure.
00:37:16 <allbery_b> everything is an expression in Perl, just as it is in Haskell
00:37:34 <allbery_b> sure it is.  a procedure returns void (or in Haskell terms ())
00:37:35 <Kaidelong> allbery_b: That is somewhat missing the point
00:37:42 <Kaidelong> () is not Void
00:38:17 <allbery_b> how not?
00:38:31 <ray> well, procedures certainly don't return _|_
00:38:32 <Kaidelong> allbery_b: a function is something that maps elements of one set to another. It could map elements from a set to the unit set (-> ()) but (-> Void) simply does not exist
00:38:39 <Kaidelong> ray: why not?
00:38:46 <ray> because then they wouldn't return
00:39:02 <Kaidelong> you could have "for(;;) noop();"
00:39:10 <Kaidelong> that'd basically be _|_
00:39:11 <Kaidelong> oh
00:39:13 <Kaidelong> yeah
00:39:14 <ray> therefore it has to be at least ()
00:39:24 <allbery_b> and no, I;'m not missing the point about if-then-else.  the point is that a missing "else" in expression context is often a bug, and in functional context means an unhandled case
00:39:25 <Kaidelong> well "returns _|_" is somewhat of a fuzzy concept
00:40:02 <Kaidelong> allbery_b: If a function does not return anything then it is not a function. Same if its input does not uniquely determine its output.
00:40:04 <allbery_b> if ... else undefined in a functional language is a very different beast from an if without an else in a procedural language
00:40:05 <ddarius> Kaidelong: Not really.
00:40:18 <Kaidelong> ddarius: fuzzy is the wrong word
00:40:35 <Kaidelong> "irrelevant to whether you actually return or not" concept
00:40:50 <ddarius> Kaidelong: Definitely not.
00:40:55 <ray> i think you might mean "it's jargon"
00:41:33 <Kaidelong> ddarius: How would you tell "returning _|_" apart from not returning at all, in general?
00:42:27 <Kaidelong> either way the value of the function would be the same
00:42:34 <Kaidelong> return value
00:42:48 <ddarius> Kaidelong: If the codomain does not include _|_ then you -can't- return at all, you -must- "escape/abort."
00:43:05 <ddarius> for a Void codomain
00:43:21 <Kaidelong> mm, terminology?
00:43:34 <ddarius> It's not a "terminological" thing.
00:44:00 <Kaidelong> okay, so there is actually a way to observe returning bottom?
00:44:06 <Kaidelong> that's interesting
00:44:19 <ddarius> No, there is no bottom in an unlifted Void domain.
00:44:31 <Kaidelong> oh
00:44:35 <Kaidelong> Okay
00:44:47 <Kaidelong> All types in haskell are lifted over bottom, even void
00:44:52 <ddarius> Indeed.
00:44:58 <Kaidelong> I suppose if it isn't, you can't even talk about "returning bottom"
00:45:06 <ddarius> Correct.
00:45:10 <ddarius> And this has significance.
00:45:25 <Kaidelong> but wouldn't languages like Perl effectively have it?
00:45:35 <ddarius> And in most languages the function space A -> B, is defined as A -> B_{_|_}.
00:46:10 <ddarius> Kaidelong: Most Turing complete languages will be required to have bottom in every codomain though that isn't necessary even for Turing complete languages and obviously isn't for sub-Turing complete languages.
00:46:40 <Kaidelong> ddarius: how do turing complete languages avoid it?
00:46:43 <Kaidelong> putting turing complete things in special contexts?
00:47:42 <Kaidelong> also
00:47:47 <Kaidelong> Void -> Void does exist
00:47:56 <Kaidelong> so saying (-> Void) simply does not exist is wrong
00:47:57 <ddarius> Kaidelong: Just don't allow non-terminating computation everywhere.  For example, you could have lambdas that only allow expressions and not have function/procedure invokation in the set of expressions.  lambda terms may then always terminate even though the language as a whole is Turing complete.
00:48:04 <ddarius> Kaidelong: No one has said that.
00:48:12 <Kaidelong> ddarius: I said that
00:48:22 <ddarius> Oh-kay.
00:48:32 * hackagebot hashed-storage 0.5.5 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5.5 (PetrRockai)
00:49:55 * Kaidelong supposes that you could use unsafePerformIO to get ML style "-> ()" statements
00:50:03 <ddarius> As an example of something notable from Void valued functions, if I have a function (A -> Void) -> Void (in an empty context), I -know- it will invoke its parameter.  I don't know that for (A -> Void) -> Void_{_|_}
00:50:57 <ddarius> (This is actually the basis of double negation elimination.)
00:51:32 <Kaidelong> I suppose that is useful
00:51:37 <Kaidelong> but you'd need a total language for that
00:51:51 <Kaidelong> or at least, total with respect to A and Void
00:52:02 <Kaidelong> and functions between them
00:52:07 <ddarius> No, you wouldn't.  You would need to have not -every- domain be lifted.
00:52:14 <ddarius> Which is fairly unusual.
00:52:18 <ivanm> OK, it seems that pretty is the only pretty-printing library for which the empty document is an identity for <+> :s
00:52:21 <ddarius> (well, at least for codomains.)
00:52:32 <ivanm> even though IMHO that makes sense
00:52:32 <ddarius> ivanm: Really?
00:52:40 <ivanm> ddarius: out of all the ones I could find on hackage
00:52:48 <ivanm> OK, I lie: there's also marked-pretty, which is a fork of pretty
00:52:56 <Kaidelong> ivanm: People often write things without designing them first
00:53:00 <ivanm> yeah
00:53:15 <ivanm> so would it make sense to have that in my Text-based variant of wl-pprint?
00:53:49 <ddarius> ivanm: I would say it would make sense to have it in every such pretty-printing library.
00:53:56 <ivanm> yeah
00:57:07 * Kaidelong wonders what a statement in an imperative language even is
00:57:42 <rumbold1> im trying to get my program working under windows. i need to install pthread for that. cabal says i need to specify the folder if its installed in a non-standard location. i could do that but, whats the standard location for libraries under windows?
00:58:34 <mux> there is a working pthread lib under windows? I didn't even know that
00:58:36 <Kaidelong> rumbold1: From what I remember cabal puts it stuff in AppData in your home directory when you do a local install
00:58:41 <allbery_b> there isn't one.  that's the problem...
00:58:52 <mux> I sense rumbold1's future pain
00:59:06 <allbery_b> I think he's looking for native libraries, not Haskell bindings
00:59:15 <mux> *jedi mind trick* this isn't the operating system you are looking for
00:59:38 * Kaidelong thought windows threads were supposed to be nicer anyway
00:59:56 <rumbold1> i hope there is, mux :p
01:00:06 <mux> I sincerely doubt it
01:00:16 <mux> but I wish you the best of luck
01:00:53 <allbery_b> they probably are, actually; pthreads is a lowest common denominator
01:00:53 <Kaidelong> what are you trying to do that needs you to work with OS threads?
01:00:56 <Kaidelong> out of curiousity
01:02:08 <Kaidelong> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#v:forkOS
01:04:37 <rumbold1> im just using codec.image.devil and it need pthread and il
01:06:59 <Kaidelong> oh DLL hell
01:07:22 <Kaidelong> well more just dependencies that probably are unnecessary
01:08:30 <Kaidelong> wait do you really need pthread and IL for that library?
01:08:59 <rumbold1> cabal seems to just ignore my --extra-include-dirs and --extra-lib-dirs D:
01:09:08 <rumbold1> cabal install says so
01:09:36 <Cale> rumbold1: This is while building Codec-Image-DevIL-0.2.3?
01:09:43 <rumbold1> yes
01:09:45 <Cale> hmm
01:09:57 <Cale> The only listed dependencies are array and base
01:10:01 <taotree> I have a fresh ubuntu 10.10 install and need to get ghc 6.12.3 on it, but ubuntu only has 6.12.1. Is it possible to get a 6.12.3 package for ubuntu somewhere?
01:10:01 <Cale> (4.*)
01:10:16 <Cale> taotree: I just use the generic linux binary
01:10:21 <rumbold1> well its a binding for devil so its gonna need that at least
01:10:25 <Cale> taotree: and uninstall ubuntu's GHC stuff
01:10:51 <Cale> rumbold1: But usually cabal doesn't know about C library deps
01:11:30 <rumbold1> "Configuring Codec-Image-DevIL-0.2.3...
01:11:31 <rumbold1> cabal: Missing dependencies on foreign libraries:
01:11:31 <rumbold1> * Missing C libraries: IL, pthread" is what it says
01:11:38 <Cale> interesting
01:11:40 <ivanm> OK, there seem to be a few other slight foibles with using wl-pprint with it inserting useless blank lines...
01:12:12 <mux> omega is really an interesting language
01:12:40 <Wooga> omega マホ〜
01:12:42 <mux> it allows you to do all the type-level hacks we usually do in haskell but in a clean way
01:12:44 <Cale> rumbold1: Try removing the Extra-Libraries line from the .cabal file and see if it helps
01:12:48 <mux> without dependent types
01:13:28 * Wooga just found source of lyrics used by lyah in IO chapter: http://www.youtube.com/watch?v=yHy4n3RWqjk 
01:14:15 <Wooga> *same source
01:14:38 * hackagebot largeword 1.0.0 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.0.0 (DominicSteinitz)
01:15:21 <ddarius> mux: There's definitely benefit Haskell could gain from a more interesting kind language.
01:15:39 <mux> ddarius: yeah, that's what I think as well
01:18:48 <jonkri> what would be a good next step for this very simple logging module? https://patch-tag.com/r/jonkri/HLogger/snapshot/current/content/pretty/HLogger.hs
01:21:38 <Kaidelong> jonkri: Not a new direction, but could you rename "loop" to something less surprising?
01:21:40 <jutaro> anyone knows about the state of code.haskell.org?
01:21:48 <ivanm> jutaro: what in particular?
01:21:53 <jutaro> Our repo has disappeared!?!
01:21:54 <ivanm> last I heard, repos were read-only
01:22:00 <ivanm> no user accounts were back yet
01:22:27 <tab> this is really long maintenance .. :|
01:22:40 <ivanm> *sigh* it seems that pretty had a _lot_ of "common sense" optimisations to deal with various Empty cases that wl-pprint doesn't :s
01:22:46 <ivanm> tab: they're migrating to a new server
01:22:53 <ivanm> completely new version of the distro, etc.
01:22:59 <ivanm> and trying to make sure nothing was compromised
01:23:14 <ivanm> all at a time when no-one was planning on doing it because they're really busy
01:23:14 <tab> that's still really long maintenance
01:23:54 <jonkri> Kaidelong: thanks :) does writeToFile sounds better?
01:24:02 <jutaro> ivanm: still a problem , no notification before, and then the repo is away for weeks
01:24:07 <Kaidelong> jonkri: you may be able to make a monoid instance for HLoggerState that handles more than one channel at once
01:24:19 <Kaidelong> (by composing hloggerstates somehow)
01:24:31 <jutaro> I'm thinking about moving to github...
01:25:00 <Kaidelong> jonkri: that does sound better but what are you writing to file, and why are you forking it?
01:25:01 <tab> at least maintenance there is 10min or so :\
01:25:09 <rumbold1> why is cabal ignoring my extra dirs? D:
01:25:38 <Kaidelong> maybe something like "logger" or "makeLogger" would work
01:25:43 <jonkri> Kaidelong: to abstract it from the developer using the framework
01:26:06 <Kaidelong> jonkri: I dunno how you could encode those reasons into the name though
01:26:11 <jonkri> jutaro: http://patch-tag.com has been working well for me if you want to use darcs
01:26:52 <jutaro> jonkri: I will look it up.
01:26:58 <ivanm> jutaro: there have been notifications...
01:27:06 <Kaidelong> jonkri: I guess a new direction would be handling more than one channel at a time
01:27:15 <ivanm> jonkri: and darcsden
01:27:26 <Kaidelong> and then other operations like filtering by channel and urgency
01:27:27 <jutaro> ivanm: So I missed it, it was in haskell cafe?
01:27:30 <ivanm> yes
01:27:40 <ivanm> and possibly even posted to the haskell reddit
01:27:47 <jonkri> Kaidelong: this is basically how it's used: https://patch-tag.com/r/jonkri/HLogger/snapshot/current/content/pretty/LoggerTest.hs
01:28:05 <jonkri> Kaidelong: it will create a log file called "LoggerTest-YYYYMMDDHHMM.log" and put the messages in there
01:28:17 <jonkri> i don't see what problem multiple channels would solve
01:28:48 <Kaidelong> jonkri: well you were asking where you could go with it. But for example, my logger deamon handles messages from both the kernel and stuff like DHCPCD
01:29:12 <Kaidelong> and it can be configured to do things like "don't show debug messages from the kernel"
01:29:21 <jonkri> Kaidelong: i am grateful, it was meant as more of a question :)
01:29:38 <jonkri> i see
01:30:06 <jonkri> do you have parent loggers too?
01:30:24 * Kaidelong does not know much about how it is implemented. He didn't write it, he just uses it
01:30:42 <Kaidelong> a haskell implementation for it though...
01:31:23 <Kaidelong> well you could have a filter that works on single channels, and then for a union of filters you filter each filter with the filter?
01:32:17 <Kaidelong> basically the whole idea that you have a function a -> a for [a] -> [a]
01:33:16 <Cale> I herd u liek filters
01:33:23 <jonkri> lol
01:33:31 <Kaidelong> also another direction to look at would be using something like WriterT like in the RWH example
01:35:40 <jonkri> Kaidelong: using writers for current logging is bad according to mm_freak
01:35:54 <rumbold1> yay, i think i got pthread to work... at least cabal only complains about il now
01:35:58 <Kaidelong> alright then~
01:36:03 <jonkri> but thanks :)
01:41:37 <rumbold1> huh, did the same thing for il that i did for pthread but it doesnt work D:
01:42:13 <Kaidelong> jonkri: Yet another idea is to parameterize the log messages with something that allows something to call back the sender of the message, potentially just with () if you want to disallow it
01:43:23 <Kaidelong> so that a log reader can interact with the source and then log its own messages
01:44:32 <jonkri> Kaidelong: interesting thought. what would be a use case for that?
01:44:46 <rumbold1> this is quite annoying D:
01:45:30 <Kaidelong> jonkri: say that a machine goes down on a network somewhere and tells the logger about what happened. The logger itself could be set to do some IO action that tries to fix the problem
01:45:45 <Kaidelong> using the callback
01:46:14 <Kaidelong> or something reading the log could be
01:46:31 <Kaidelong> or you could have
01:47:03 <Kaidelong> send "/etc/init.d/wlan0 restart" if the kernel says something containing "on demand firmware reload" on priority "debug"
01:47:41 <jonkri> i see. i think that would be best implemented as a plug-in, or at least after the plug-in system has been implemented (through a typeclass, perhaps?)
01:48:21 <ivanm> ddarius: still around?
01:48:23 <Kaidelong> the trouble is that you'd have to pack the callback information into the string then somehow
01:48:28 <jonkri> i want the framework to be simple and extendable
01:48:31 <ddarius> ivanm: Sure.
01:48:43 <Kaidelong> jonkri: there is a tradeoff there
01:49:05 <ivanm> in your opinion, should the "nest" function for pretty-printing actually indent in the following: (nest 4 empty) <> text "hi"
01:49:07 <jonkri> plug-ins would have some kind of additional input parameters, state and (monadic?) functions
01:49:13 <Kaidelong> for example you could make a logger that works on monoids instead of one that works on strings, and it'd be more polymorphic and perhaps more useful later on
01:49:14 <ivanm> in pretty, it doesn't; in wl-pprint it does
01:49:29 <Kaidelong> but it wouldn't be as simple and perhaps harder to work with in foreign code
01:49:43 <ivanm> I lie, it doesn't in wl-pprint either
01:49:54 <jonkri> what benefit would come from using monoids?
01:49:58 <ddarius> ivanm: That would be my first reaction too.
01:50:00 <jonkri> i mean
01:50:10 <jonkri> can you explain what you mean by polymorphism?
01:50:31 <Watermind> is there an Infinite literal for Int or Integer?
01:50:46 <Watermind> or do you just create your own datatype and Ord instance when you need it?
01:50:52 <Watermind> and Num...
01:51:17 <Kaidelong> jonkri: you could for example change the record type used for log messages so long as your replacement record type is also a monoid
01:52:01 <jonkri> aha ok
01:52:57 <ivanm> *sigh* I should probably go through and more carefully port the various laws, etc. from pretty to wl-pprint...
01:53:07 <ivanm> but I'll probably stick with hodge-podging it for now
01:54:35 <jonkri> thank you so very much for all your suggestions Kaidelong :)
01:54:50 <Kaidelong> making suggestions is easy!
01:54:59 <Kaidelong> but thanks for your thanks
01:56:39 <aleator> Hi, I'm getting a huge speed difference between to vector functions that, in my humble opinion shouldn't exist. http://hpaste.org/43960/huge_vector_speed_difference Anyone care to see if I have done something really wrong?
01:57:11 <ivanm> aleator: which library? vector itself?
01:57:28 <ivanm> I would blindly blame fusion making the first one faster
01:57:29 <Daerim> aleator, assuming f4' is the faster one?
01:57:32 <mux> heh, that reminds me I need to go see why in hell I have this function that gets *slower* when using unsafe functions
01:57:52 <ivanm> mux: it's trying to tell you something!
01:57:54 <Daerim> mux, perhaps your computer gets scared?
01:57:55 <ivanm> unsafeMakeThisGoSlower
01:58:14 <aleator> Daerim: No, the opposite. f4' is way slower
01:58:22 <mux> yeah that must be it; the function names scared my computer to death
01:58:30 <aleator> ivanm: Data.Vector.Unboxed
01:58:53 <ivanm> aleator: :o
01:59:29 <ivanm> does Roman come here?
01:59:38 <ivanm> (seeing as how vector is his...)
01:59:41 <aleator> Is it totally impossible that f4' is 5 times slower than f4, or should I look for a bug elsewhere?
02:00:21 <Daerim> aleator, mind pasting your entire test program?
02:00:56 <aleator> Daerim: Thats bloody large. I haven't yet shortened it down
02:01:04 <mux> I've been meaning to say, Data.Vector is impressively faster than Data.Array
02:01:19 <Daerim> aleator, ok, no problem
02:01:36 <ddarius> mux: What you mean to say is Data.Array is impressively slow.
02:01:43 <Daerim> mux, well... Array isn't exactly -fast-... but yes Vector is a very nice piece of work
02:01:48 * hackagebot yesod-tableview 0.2.1 - Table view for Yesod applications  http://hackage.haskell.org/package/yesod-tableview-0.2.1 (ErtugrulSoeylemez)
02:01:49 <mux> ddarius: maybe that is what I meant to say indeed
02:02:34 <mux> I have this typical quicksort algorithm implemented on Data.Array.MArray mutable arrays and the same implemented over Data.Vector.Mutable.Generic
02:03:03 <mux> the vector version on a *boxed* array is much faster than the array version on an unboxed one (IOUArray)
02:03:09 <aleator> The whole thing popped out when profiling a larger test program. I'm happy that the explicit recursion is fast, but it does lead to indexititis.
02:04:43 <Daerim> mux, well Array needs to redo the indexes, doesn't it? Vector can just use them directly in a C sort of fashion
02:04:54 <HugoDaniel> hello
02:04:56 <HugoDaniel> :)
02:05:06 <HugoDaniel> google trends doesn't quite work as expected for haskell
02:05:22 <mux> Daerim: yeah, probably a fair bit of overhead comes from the abstract indexes - or so I hope, otherwise Data.Array would have no excuse
02:05:51 <mm_freak_> mux: on the other hand my sieve of eratosthenes was faster with STUArray
02:06:00 <mux> mm_freak_: interesting
02:06:05 <Daerim> mux, you could try to do the same test using the direct indexing
02:06:18 <mux> I suppose vector still experiences corner cases where it's not able to fuse loops
02:06:37 <Daerim> mux, sure but why would it ever be -slower- than array?
02:06:40 <mm_freak_> i don't think that Data.Array.* is slow…  in 99% of the cases it's just used wrongly
02:06:45 <mux> Daerim: direct indexing with Data.Array? what do you mean? my test case is already specialized to Int's
02:06:57 <mm_freak_> whenever fusion works you didn't want arrays in the first place
02:07:10 <mux> that's a good point
02:08:54 <ivanm> mm_freak_: did you do the _real_ sieve of eratosthenes or the fake one? :p
02:09:26 <Daerim> mux, yes but using... well... it's not unsafeAt, but there is a function that does 0-based indexes on Arrays
02:09:40 <mm_freak_> ivanm: if i used STUArray, i obviously did the real one ;)
02:09:52 <mux> Daerim: I'd be curious to hear about that function if you ever find out where it is :-P
02:09:55 <mm_freak_> for the fake one you get better performance with lists than with arrays
02:10:50 <mm_freak_> but i also did the semireal infinite SoE using lists…  it was slow as hell
02:15:29 <mm_freak_> > map fst . filter snd . zip [2..] $ fix (\r i (x:xs) -> x : r (i+1) (if x then take (i-1) xs ++ (concatMap (\(_:xs) -> False:xs) . takeWhile (not . null) . map (take i) . iterate (drop i) . drop (i-1)) xs else xs)) 2 (repeat True)
02:15:30 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:16:19 <Daerim> mux, I could have sworn there were two unsafe index operations available. One just not doing boundschecks, and one doing "direct" indexing. But sure can't find it...
02:17:34 <udoprog> When I use createProcess to spawn a simple process e.g. "cat" in a daemonized block (using hdaemonize - System.Posix.Daemonize) the process instantly closes, seems like the related file descriptors (stdin/stdout) are being closed somehow. The same createProcess block runs fine without daemonization. I'm binding std_* to StdStream Handles and Pipes
02:17:34 <mm_freak_> Daerim: what's "direct indexing"?  if you use unboxed arrays, then you do direct memory access
02:17:57 <jonkri> ghci can't find the xml-enumerator modules installed using cabal install. what should i do?:
02:18:12 <mm_freak_> jonkri: install them
02:18:19 <mm_freak_> cabal install xml-enumerator
02:18:29 <jonkri> mm_freak_: i have done that
02:18:45 <Daerim> mm_freak_, but you still recalculate the index, right? Because haskell arrays can have arbitrary bounds?
02:19:24 <mm_freak_> Daerim: you can expect Int to do "direct indexing", if your first index is 0
02:19:43 <mm_freak_> jonkri: error message?
02:20:47 <jonkri> mm_freak_: i had to cabal update, there has been a couple of recent releases :)
02:21:33 <Daerim> mm_freak_, but it can't know if my first index is 0 on compile time, so there would be some overhead?
02:21:52 <mm_freak_> Daerim: probably
02:23:02 <mm_freak_> Daerim: if you want absolute maximum performance, use Ptr
02:23:48 <mm_freak_> but when doing that note that you don't get stuff like tightly packed bit fields and the like
02:24:13 <Daerim> mm_freak_, or I could use the FFI and link to fortran. ;) I always thought it removed the haskell from haskell
02:35:41 <mm_freak_> Daerim: if you have already working fast fortran code, why not?
02:35:52 <mm_freak_> it just makes you depend on an additional compiler
02:36:13 <Jafet> -fvia-f77
02:39:14 <Daerim> mm_freak_, exactly. I guess I just find the low-level haskell code to be hard to read and work with. Ideally I would never have to go down there at all. Thus, Vector
02:41:33 <Daerim> Jafet, well. Sadly f77 isn't exactly blazing fast. To get decent speed out of fortran commercial compilers are needed (sadly)
02:41:59 <mm_freak_> Daerim: i disagree…  haskell is a good language for writing imperative code…  it's just that you probably don't get fortran performance
02:42:07 <mm_freak_> although i found that you can get close to it
02:42:58 * hackagebot gsmenu 2.1 - A visual generic menu  http://hackage.haskell.org/package/gsmenu-2.1 (TroelsHenriksen)
02:44:21 <Daerim> mm_freak_, I agree with the imperative code part. But pointer hacking? I guess I just feel it's a bit unnatural in haskell
02:45:05 <Chaze> can someone help me understand this problem? http://projecteuler.net/index.php?section=problems&id=56
02:45:41 <Chaze> if a,b < 100, the sum of digits of a^b is unbelievably large
02:47:59 <aleator> Anyone have ideas how to make this faster: -#SCC "Generate"#-} VUB.generate l (\i -> if i>=index && i < (index+n) || i < m then a VUB.! i else b VUB.! i )
02:48:10 <aleator> (where VUB = Data.Vector.Unboxed)
02:50:47 <aleator> That specific bloody thing is now eating 50% of my runtime.
02:53:45 <mm_freak_> Daerim: pointer stuff is actually quite easy in haskell, not more difficult than in C
02:53:57 <mm_freak_> often even more convenient, because you have all the monadic stuff you can use
02:55:16 <Daerim> mm_freak_, you might be right. I'm probably just not experienced enough
02:55:26 <Daerim> aleator, you're combining two vectors?
02:58:28 <Daerim> aleator, might be faster if you did it in the ST monad to avoid the boolean operations?
03:00:41 <mm_freak_> Chaze: what's the matter with that?
03:01:20 <Chaze> mm_freak_: if i solve it the way i understand the question, the resulting number is way too large
03:01:28 <Chaze> more than 50 digits itself
03:02:28 <Chaze> argh, no it isn't! damn operator precedence
03:02:42 <Chaze> "dsum a^b" was lacking brackets
03:04:53 <Daerim> speaking of Vector.... any of you have problems with it not linking? It works nicely in ghci, but it keeps giving me linking errors in ghc
03:05:18 <Daerim> had it working earlier, but not on this machine
03:05:55 <Esteth> Hey folks. I'm using parsec and trying to match any series of characters not including a particular substring. How would I do this? :P
03:06:23 <Esteth> s/:P/:s/
03:07:39 * ddarius decides to be more precise in his article.
03:11:11 <Esteth> to rephrase: does anyone know of a parsec function like containingNoneOf ["aa", "d$"]
03:14:28 <alpounet> Daerim, no problem for me using vector
03:14:36 <alpounet> how do you build your project ?
03:18:44 <mm_freak_> > maximumBy (comparing snd) . map (id &&& sum . map (`mod` 10) . takeWhile (> 0) . iterate (`div` 10) . uncurry (^)) $ liftM2 (,) [0..99] [0..99]
03:19:15 <Daerim> alpounet, ghc test.hs
03:19:32 <lambdabot>   ((99,95),972)
03:19:49 <Daerim> poor lambdabot, working so hard
03:20:20 <mm_freak_> hehe
03:24:17 <alpounet> Daerim, have you "cabal install"'ed the 'vector' package ?
03:24:23 <alpounet> you need to do this
03:24:33 <alpounet> then to build your project, ghc --make test.hs
03:24:45 <alpounet> or ghc -package vector test.hs
03:25:33 <mux> or just ghc test.hs if you have GHC 7.x :-)
03:25:41 <mux> --make has been made the default
03:25:47 <alpounet> yeah
03:25:56 <alpounet> but since it's not widely distributed i doubt he has 7.x
03:26:19 <Daerim> arff! --make! I feel like an idiot now
03:26:52 <Daerim> You're gone for a few months and suddenly you do silly stuff like that
03:27:14 <Daerim> alpounet, thanks
03:29:40 <alpounet> np
03:29:43 <udoprog> I can't figure out why the child process doesn't buffer all the input as I would expect, when connecting to it locally it will shutdown almost immediately, can anyone help me out? http://hpaste.org/43961/createprocess_waiting_problem
03:31:20 <udoprog> Same goes if I replace "nc" with a simple "cat" (stdin -> stdout)
03:33:11 <ksf> you're not writing anything to the pipe, are you?
03:33:11 <lambdabot> ksf: You have 1 new message. '/msg lambdabot @messages' to read it.
03:33:27 <ksf> @messages
03:33:27 <lambdabot> xplat asked 11h 25m 42s ago: have you tried implementing chunked iteratees in terms of single-item-per-step iteratees?
03:34:08 <udoprog> ksf: nope, not writing anything
03:34:35 <jonkri> @src rfc822DateFormat
03:34:35 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:34:51 <jonkri> @src System.Locale.rfc822DateFormat
03:34:51 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
03:35:42 <ksf> @tell xplat I could implement head in terms of chunk, which gets you "a single item", yes, but that's a rather minor semantic thing. In general, I don't care about the type that is carried except that I have to have a way to construct empty ones and tell whether it's empty
03:35:43 <lambdabot> Consider it noted.
03:36:18 <ksf> udoprog, when the pipe gets garbage-collected, which is probably happening sometime due to threadDelay, chances are the pipe gets closed
03:36:51 <ksf> you'd have to have a look at the source of createProcess to make sure
03:39:49 <ClaudiusMaximus> argh. my untyped lambda calculus interpreter has a subtle bug - sometimes the lazy evaluation is so lazy that it just sits there doing nothing - adding strictness annotations makes it go.  dunno where to start debugging...
03:41:33 <ksf> @tell xplat if you want, you can even use Bool as chunk type, it's expressive enough for my code. Maybe a is another (saner) option, which would give you the single-item-per step semantics I think you mean.
03:41:33 <lambdabot> Consider it noted.
03:41:37 <syntaxfree> correct me if I'm wrong, but for an iterative algorithm to run in sub-polynomial time, it needs to save information between iterations, right?
03:42:02 <syntaxfree> @tell lambdabot Do you have a fixed point?
03:42:02 <lambdabot> Nice try ;)
03:42:57 <lambdabot>  @tell syntaxfree Try harder!
03:43:42 <ksf> @tell xplat http://hpaste.org/43946/blub . You need Nullable to get basic iteratees, and HasElement and Decons will give you head and similar.
03:43:43 <lambdabot> Consider it noted.
03:44:03 <shapr> ClaudiusMaximus: First, you add a strictness annotation to yourself...
03:46:06 <udoprog> ksf: It would seem as you are correct, invoking the same using "Inherit" seems to fix the issue, is there any way I can prevent the handle from being garbage collected?
03:47:11 <taotree> I'm thinking a heterogenous map is what I need for a certain thing... Is there a standard one to use? I found this one but it doesn't have any docs and I'm having a little difficulty figuring out how to use it.  http://hackage.haskell.org/package/hetero-map
03:47:22 <HugoDaniel> Prelude Crypto.PasswordStore Data.ByteString Data.ByteString.UTF8> 
03:47:26 <HugoDaniel> how do i reduce the ghci prompt ?
03:47:30 <HugoDaniel> this is huge
03:47:31 <HugoDaniel> :/
03:47:38 <kfr> No idea
03:47:55 <Chaze> @pl (\f -> f *** f)
03:47:56 <lambdabot> join (***)
03:48:12 <Botje> HugoDaniel: :set prompt ">"
03:48:53 <kfr> :t (***)
03:48:53 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:49:09 <HugoDaniel> thanks Botje 
03:49:10 <HugoDaniel> :)
03:51:43 <companion_cube> since a signature is like  (assumptions over types) => (type analogous to a formula), would it be possible to reify the assumptions over types and give them as arguments ? like, transform  (Monad m) => m a -> (a -> m b) -> m b into    Monad m -> m a -> (a -> m b) -> m b ?
03:51:54 <companion_cube> like a transformation in sequents
03:51:55 <udoprog> kfr: funny, If i force the function to return the pipe boxed with the monad, it does not seem to be garbage collected.
03:51:56 <jaj> hmm, is there a way to tell cabal-install to run ghc with an increased heap size?
03:52:30 <kfr> udoprog: Amazing, except you meant somebody else
03:52:52 <aavogt> taotree: it puts heavy restrictions on what the keys are
03:53:27 <Kaidelong> companion_cube: I think you could
03:53:35 <udoprog> kfr: hah, sorry, two guys with a three letter combination : )
03:53:40 <Daerim> aleator, you still here?
03:53:45 <Kaidelong> wait
03:53:45 <aavogt> and it seems that if you insert a  (5, 1.0 :: Double)  and a  (5, 10 :: Int), you can get either out (with the right key)
03:53:56 <Kaidelong> kindedness might get in the way there
03:54:11 <companion_cube> it would be nice to have some syntax for this, so that one could change the instance for some applications
03:54:12 <taotree> aavogt, I think that's likely ok, I have a rather limited case... it's a situation where a tuple like structure is possible, but would be very messy.
03:54:16 <Daerim> aleator, I had a look at your code. f4 and f4' don't actually do the same thing
03:54:25 <companion_cube> like providing a different Ord instance on-the-fly
03:54:36 <Kaidelong> companion_cube: why not use newtype?
03:54:39 <aavogt> taotree: what is the situation?
03:54:53 <companion_cube> Kaidelong, it's heavier :)
03:55:02 <Kaidelong> only on syntax
03:55:03 <companion_cube> anyway, i'm just talking about theory
03:55:09 <companion_cube> yes
03:55:47 <Kaidelong> but I'm certain that you could use a parameterized record type to do that, so long as the record constructor is allowed to take an argument of kind (* -> *)
03:55:55 <Kaidelong> which I think it can with a haskell extension
03:56:17 <companion_cube> like a Map taking the comparison operator as an argument ?
03:56:19 <taotree> aavogt, I have a TChan that needs to be able to receive values from multiple places and so different types
03:56:21 <aavogt> taotree: HList seems similar to that hetero-map
03:56:46 <aavogt> why can't you just use some data that's like Either?
03:56:47 <Kaidelong> companion_cube: Then you run into the trouble of comparison operators being values and not type
03:56:49 <Kaidelong> s
03:57:00 <Kaidelong> so the maps will not look like different types
03:57:07 <Kaidelong> (neccessarily)
03:57:11 <taotree> aavogt, because if there are 5 or 8 of them... that gets rather messy, doesn't it?
03:57:28 <Kaidelong> companion_cube: newtype avoids this by making a nominal distinction
03:57:31 <HugoDaniel> i have my datatype in haskell that i want to use has a list of flags to test against, how do i do this efficiently in haskell ? here: http://hpaste.org/43962/how_to_use_haskell_datatype_as 
03:57:32 <HugoDaniel> ?
03:57:43 <companion_cube> that can be the expected behavior, i guess
03:58:03 <aavogt> taotree: do the types have something in common?
03:58:21 <ClaudiusMaximus> shapr: !
03:58:35 <aavogt> such as they all support some common operations
03:58:38 <taotree> aavogt, not necessarily, I have to be able to access all fields in each type separately
03:58:40 <Kaidelong> HugeDaniel: Since there are 8 states, I'd just use a byte. Bad for extensibility though, I guess
03:58:53 <Kaidelong> Data.Word.Word8
03:58:59 <Kaidelong> and then Data.Bits
03:59:01 <Kaidelong> to work bitwise
03:59:06 <HugoDaniel> oh
03:59:17 <HugoDaniel> aint there something that uses typeable to work this out automagically ?
03:59:33 * Kaidelong notes that what he said is probably a terrible idea!
03:59:34 <opqdonut> Data.IntSet is pretty darn fast
04:00:27 <aavogt> there's probably a wrapper of IntSet that can do the fromEnum/toEnum for you
04:01:12 <HugoDaniel> oh hmm
04:01:24 <HugoDaniel> i thought that there was already some kind of package that could sort this out for me
04:01:46 <HugoDaniel> i dont need it to be fast, i just thought about it and how it would be a nice thing to have
04:03:19 <HugoDaniel> maybe ill just do a fast hack on it
04:04:14 <aavogt> taotree: if you use hetero-map you'd need to generate all the keys before forking threads, so you have the Key on both sides of the chan. This gets awkward because the rank2types involved are annoying to take as arguments to functions, since you need to annotate the type (where you define the function)
04:05:00 <aavogt> also I'm not sure if it helps directly, since mvars like to have the same type after being created
04:07:24 <taotree> aavogt, those restrictions are no problem
04:07:32 <aavogt> you're probably best just using, Chan (IO ())  choosing the thing to do to these different types before sending it across the chan
04:08:13 <aavogt> I mean if you look at   "insert :: Key x a -> a -> Map xs -> Map (x :* xs)", this has a different type when you add something new
04:08:17 <taotree> Chan (IO ()) is not going to ork
04:08:26 <taotree> I can create the whole map before forking
04:08:45 <taotree> oh wait... I think I see what you mean...
04:08:57 <aavogt> so to make that  Map, you might store things like      [(k1, Maybe a)]
04:09:15 <aavogt> where the  k1 and a are all different types
04:10:24 <aavogt> so you have a defaultMap which has all the  Maybe a  being Nothing, then replace that with the value you want
04:10:54 <aavogt> and on the other side, scan through all the keys to find something that's not Nothing
04:11:36 <aavogt> this is inefficient in any case because the hetero-map is a linked list as far as I can tell
04:11:54 <taotree> ah, ok... I'll have to think some more
04:12:12 <aavogt> taotree: why doesn't the  (IO ()) option work?
04:12:31 <taotree> The other side of the channel knows nothing of what to do with the data
04:13:04 <aavogt> because there's some data missing?
04:13:13 <aavogt> you could have    Chan (Environment -> IO ())
04:13:25 <aavogt> or  Chan (Env -> IO Env)
04:13:50 <taotree> It's like sensors sending in data asynchronously that then must be handled sequentially (one event from any sensor at a time) through a processing system.
04:16:36 <aavogt> taotree: when you pass an (IO ()) in the Chan it doesn't cause the side effects to happen at that moment
04:16:48 <aavogt> they will happen when the recieving side decides to run it
04:17:27 <taotree> The module that sends the data into the channel should not know anything about how that data is to be processed
04:19:02 <aavogt> that's just how you've decided to split it up
04:20:05 <taotree> it's required to be split up that way for this application since the code is created differently...
04:20:16 <taotree> meaning... the processing code may be regenerated
04:20:23 <taotree> so the other modules could not know anything about it
04:21:03 <aavogt> well there's Data.Dynamic as a last resort
04:21:13 <taotree> yeah, don't want to go there
04:21:22 <taotree> I'd stick with the crazy tuple-like thing if I have to
04:22:27 <aavogt> or slightly safer is to do the same as Dynamic, but have the types in some class for which you can check that you've got only a few specific types in there
04:23:03 <aavogt> basically going down the -XExistentialQuantification route
04:23:07 <taotree> ok
04:23:46 <taotree> How do I get past this?  Trying to install leksah... "setup: The pkg-config package gtksourceview-2.0 version >=2.0.2 is required but it could not be found"
04:24:11 <aavogt> install some gtk libraries that aren't written in haskell
04:24:17 <merijn> Right, so I'm reading up on existential quantification. Someone check my conclusions: "forall a . a" is the intersection of all types (i.e. _|_), now adding additional constraints like "forall a . Show a => a" is the intersection of all types in the Show typeclass (still just _|_).
04:24:19 <merijn> "id :: a -> a" is equivalent to "id :: forall a . a -> a", the reason this works is because when id is actually used ("id 'a'" for example) the type checker tries to unify a with Char and then it becomes (in non-existent syntac) "forall a . aIsAChar => a" which is the intersection of "Char" i.e. all possible chars...
04:25:20 <taotree> aavogt, ah, right. I see now. Thanks!
04:25:32 <aavogt> no,   data S = S (forall a. Show a => a), is more or less  String
04:25:58 <aavogt> but it might take up less space or something
04:26:00 <merijn> aavogt: That doesn't make sense at all
04:28:10 <aavogt> merijn: http://hpaste.org/43963/show_list ?
04:28:46 <aavogt> sList might as well be a list of String because that's all you're going to be able to do to it
04:29:15 <merijn> aavogt: Obviously, but that's just an example, I'm trying to grok the existential quantification stuf
04:29:41 <merijn> aavogt: I was reading: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Explaining_the_term_existential
04:29:46 <aavogt> well   forall a. Show a => ...    doesn't mean the  'a' is bottom
04:30:06 <aavogt> because you can do useful things with methods of the Show class
04:30:32 <merijn> I'm trying to make that list of examples fit my mental model of existential types, but I'm failing. So either I misunderstood or that list is wrong
04:30:45 <aavogt> [forall a. a] is not -XExistentialQuantification
04:30:53 <Younder> Is  not the string monad far faster than  the list implementation that is stock?
04:31:03 <aavogt> ghc wants other extensions
04:31:09 <aavogt> Younder: what is the string monad?
04:31:57 <ivanm> aavogt: the list monad using Heffalump's RMonad to restrict it to Char?
04:32:04 <Younder> aavogt, a monad implementation  of the string library that uses arrays.
04:32:49 * aavogt thought it was common knowledge that String was slow
04:33:03 <Younder> aavogt, I saw some performance specs the other day and wondered if you had any experience with it.
04:33:32 <drbean> n/quit
04:34:53 <ivanm> aavogt: depends on what your'e doing
04:35:07 <ivanm> I just finished converting graphviz from String to Text; there isn't that much of a speedup
04:35:20 <aib> Following the tutorial at http://learnyouahaskell.com/making-our-own-types-and-typeclasses#a-yes-no-typeclass , I wanted to modify it a bit and said "yesno (Just x) = yesno x", which added a type constraint (YesNo a) => YesNo (Maybe a). But then this killed my generic definition of yesno Nothing = False. How could I both define "yesno (Just x) = yesno x" and "yesno Nothing = False" ?
04:36:13 <ivanm> you can only do so if yesno :: (YesNo a) => a -> Bool
04:36:21 <ivanm> (if I get the problem/question correctly)
04:36:53 <Younder> aib: yesno is boolean
04:37:01 <aavogt> you don't know beforehand whether a value of type   (Maybe a)  is going to be Nothing or Just
04:38:00 <Younder> aib: seems your declaration is unnecessary.
04:39:07 <Younder> aib: I realize you have come across a problem with it, But this is the wrong solution.
04:39:12 <aavogt> it's not possible to have    instance YesNo a => YesNo (Maybe a)    and    instance YesNo (Maybe a)      at the same time
04:39:45 <aavogt> at least not with the standardized haskell
04:40:29 <aavogt> and even then you can't write the instances exactly like that to get such behavior
04:41:02 <aib> This is what I have: http://hpaste.org/43964/tutorial_question
04:41:11 <aib> aavogt: hmmm
04:42:00 <aavogt> aib: you can write an overlapping instance like:        instance YesNo a where yesno _ = False
04:42:23 <aavogt> this lets get rid of the last instance, since now every type is an instance
04:43:21 <aavogt> but it probably does the wrong thing, since       yesno (Just x),  with x not in YesNo should be True?
04:43:38 <aib> aavogt: not sure. can I leave it undefined?
04:43:41 <aavogt> hmm, maybe the default should be True
04:44:16 <aavogt> aib: you want your code to have runtime errors?
04:45:21 <taotree> I have a ( Maybe (Maybe a, Maybe b) , Maybe (Maybe c, Maybe d) ) and I want to "flatten" it to a (Maybe a, Maybe b, Maybe c, Maybe d)... is there a general approach to doing something like that?
04:45:49 <aib> I'm just learning. It does have a load of runtime errors. As well as syntax errors. But you're right, it would break strict typing
04:46:20 <aavogt> taotree: would you be satisfied by    (Maybe a, (Maybe b, (Maybe c, ...   instead?
04:46:50 <aavogt> aib: the overlapping instance?
04:46:55 <taotree> well.. primarily what I need is inside the function (mv1, mv2, mv3, mv4) where those values are maybe values...
04:47:25 <taotree> so it's more about how to bind the variables I need
04:47:58 <aib> aavogt: the overlapping instance?
04:48:05 <aib> aavogt: what about something like http://hpaste.org/paste/43964/tutorial_question_annotation#p43965 ?
04:49:11 <aavogt> aib: http://hpaste.org/paste/43964/tutorial_question_annotation#p43966
04:50:07 <aavogt> aib: you have to work around the limitations of type classes if that's actually the  yesno  function you want
04:50:47 <aib> ah, I see.
04:50:48 <aavogt> and the one I posted will work with any type (which probably includes those that you wouldn't want to run yesno on)
04:51:56 <aavogt> but if you write another class, and name that class in the definition of the actual YesNo, you can restrict the types yesno will typecheck with
04:51:58 <aleator> whoa! Data.Vector.Unboxed.modify made my day: Total program runtime from 19s to 4.5s
04:52:07 * aavogt writes the example to clarify
04:52:30 <aib> so it's a limitation of type classes that I cannot define a generic "yesno (Maybe x)" and then a "(Constaint x) => yesno (Maybe x)" for a particular x?
04:52:36 <aleator> I can't even figure out how modify could work as advertised.
04:53:06 * aib waits for the example
04:54:20 <sipa> aib: yes and no
04:56:47 <aavogt> aib: this doesn't really work as I thought was possible http://hpaste.org/paste/43964/tutorial_question_annotation#p43967
04:59:00 <aib> hmm
05:01:30 <taotree> So let me repose my question more accurately: I have as a parameter to a function something like  ( Maybe (Maybe a, Maybe b) , Maybe (Maybe c, Maybe d) )  and I want to pattern match such that I have (ma, mb, mc, md) so then inside the function I can use ma, mb, mc, and md anywhere and they have type Maybe a/b/c/d
05:02:32 <ceii_> taotree: foo (Just (ma, mb), Just (mc,md)) = ...
05:02:52 <aib> I think I'll just leave it at http://hpaste.org/paste/43964/tutorial_question_annotation#p43968 and be grateful for that I've learned enough to know to cast that ambiguous Nothing to a (Maybe x) where (YesNo x) holds true.
05:02:54 <taotree> ceii_, that won't work since the outside Maybe's could be Nothing's
05:03:25 <merijn> taotree: You have to provide alternate matches for those Nothing's, yeah. But maybe you are looking for Pattern Guards?
05:03:31 <ceii_> taotree: ah, if that's what you want you'll need to merge them by hand
05:04:04 <merijn> taotree: http://research.microsoft.com/en-us/um/people/simonpj/Haskell/guards.html
05:04:23 <merijn> I think that's exactly what you want/need
05:06:14 <jonkri> where is the new System.Locale hiding? http://haskell.org/hoogle/?hoogle=Locale
05:08:08 <jonkri> @hoogle System.Locale
05:08:08 <lambdabot> No results found
05:08:57 <jonkri> @hoogle defaultTimeLocale
05:08:57 <lambdabot> No results found
05:09:39 <ceii_> jonkri: oldlocale, according to hayoo
05:09:58 <taotree> merijn, I'll digest that and see. Thanks!
05:10:31 <aavogt> taotree: like http://hpaste.org/43969/maybe_tree_to_tuple ?
05:10:34 <merijn> taotree: Note, that article refers to pattern guards "as not implemented yet", but its old and there is an implementation now
05:11:04 <aavogt> this fails because you've got a restriction on tuple length which is pretty easy to reach
05:11:10 <merijn> There should be some language pragma, but unsure what its called
05:11:16 <aavogt> > logBase 2 63
05:11:17 <lambdabot>   5.977279923499917
05:11:23 <jonkri> ceii_: yeah... i read somewhere that new applicaitons should not use oldlocale
05:11:34 <jonkri> ceii_: yeah, here: http://hackage.haskell.org/package/old-locale
05:12:48 <ceii_> there doesn't seem to be a "new locale library" on hackage though...
05:13:11 <aavogt> pattern guards do nothing you can't by adding another equation, or nesting function, they are just convenient
05:13:35 <aavogt> ceii_: if I recall correctly, it's something of a joke
05:13:38 <taotree> aavogt, looking at your paste, trying to understand it
05:13:53 <taotree> I don't know TH
05:14:03 <aavogt> taotree: look at the generated code
05:14:28 <aavogt> and ignore the fact that the variables have funny names
05:14:37 <Gracenotes> aavogt: no pattern guards can make you do pattern matching twice :/
05:15:19 <taotree> ok, but in the generated code... the variables are not maybe's, right? they are actual values? I need the vars to be maybes
05:15:27 <taotree> since most of them will be Nothing
05:15:37 <aavogt> Gracenotes: you can take care of that by nesting functions
05:15:49 <aavogt> but it gets ugly without the pattern guards
05:16:28 <aavogt> taotree: then change endPattern x = conP 'Just [varP x]   to  just be   varP
05:16:43 <aavogt> template haskell is probably overkill
05:16:58 <Gracenotes> except in cases where you're checking predicates sequentially, instead of simultaneously, that can screw up ordering
05:17:03 <aavogt> but you can't have enough overkill :p
05:19:27 <aavogt> Gracenotes: doesn't ghc take some effort to avoid re-computing guards that are repeated though?
05:20:06 <Gracenotes> repeating guards? D:
05:20:07 <aavogt> they claim something of the sort with view patterns
05:20:34 <aavogt> Gracenotes: like          f x | p x, ...   | p x, ...
05:20:37 <Baughn> Wouldn't the same arguments against CSE apply to guards?
05:20:53 <jonkri> i have a thread which is listening on a channel, processes input and loops. how would you shut down this process when exiting? extending/wrapping the channel type which supports a "stop processing" value?
05:21:00 <Gracenotes> would that it were! would that it were.
05:21:15 <aavogt> Baughn: space is an issue with  Bool?
05:21:35 <Baughn> aavogt: No, but I don't believe that GHC is clever enough to consider this.
05:21:39 <Baughn> But maybe it is.
05:21:50 <Baughn> Then again, that kind of cleverness would be annoying to me
05:22:02 <Gracenotes> jonkri: if you don't care about processing finishing, killThread it. if you want the channel to run its course, you can implement a poison-pill kind of thing
05:22:02 <aavogt> there are other issues with CSE, right?
05:22:14 <Baughn> Other than the space leak?
05:22:20 <merijn> aavogt: "They [pattern guards] don't do anything other then add readability and convenience", isn't that enough? :>
05:22:26 <Baughn> I don't think there should be..
05:22:57 <merijn> jonkri: You can throw exceptions to specific threads, forgot the function, though
05:23:03 <aavogt> some things might be quicker to re calculate than to look up?
05:23:16 <jonkri> Gracenotes: hmm, i do care about processing everything
05:23:16 <merijn> jonkri: Ah, throwTo
05:23:16 <Gracenotes> a stop-processing-value might be as simple as a Nothing.
05:23:26 <jonkri> Gracenotes: wonderful! thanks :D
05:23:30 <aavogt> merijn: I'm not arguing against them
05:23:32 <jonkri> thanks merijn, good to know
05:23:45 <taotree> aavogt, sorry, not sure how to use the treeFlatten
05:23:45 <Gracenotes> or some impossible value within the type you're looking for
05:24:08 <Gracenotes> other languages tend to implement poison pills by reference (using reference, rather than value, equality)
05:24:16 <Gracenotes> haskell doesn't have that
05:24:23 <Gracenotes> ....mostly
05:24:30 <aavogt> merijn: but some points made here apply http://haskell.org/haskellwiki/Syntactic_sugar/Cons
05:24:52 <merijn> Gracenotes: I think (conceptually) just using an exception handler and throwing an exception to a thread is cleaner. (When used with some common sense)
05:25:24 <Baughn> aavogt: ..admittedly. That would be an extreme outlier, though.
05:25:33 <Gracenotes> yeah, depends on how interruptible it is
05:25:54 <aavogt> taotree:  $(treeFlatten 2)  writes a function that takes some nested tuple/Maybe to depth 2 (I think), and gives a  Just (a,b,c,d,e) or a  Nothing
05:26:16 <aavogt> with the annoying constraint that treeFlatten is defined in another module
05:26:29 <Baughn> aavogt: The lookup is a single pointer dereference; usually when you're worrying about recalculation being faster, you're talking a much more complicated lookup
05:27:34 <aavogt> Baughn: it wouldn't be two dereferences? One to the box and another to the actual Bool
05:27:47 <aavogt> not that it really matters
05:28:34 <aavogt> @quote heroin
05:28:34 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
05:29:00 <hpc> XD
05:30:22 <Baughn> aavogt: Right you are. But still, it'd need to be one really cheap calculation.
05:30:23 <Tinned_Tuna> :-D
05:31:54 <Daerim> aleator, why not?
05:32:23 <Younder> rotfl
05:33:20 <Younder> Thue drinking will kill you far faster than Heroin..
05:33:57 <Younder> If... you inject it
05:35:14 <ousado> which leaves the question how to inject drinking
05:35:32 <taotree> aavogt, getting error with:     putStrLn $ show ( $(treeFlatten 1) (Just 1 (Just 2) ) )
05:36:37 <aavogt> taotree: I guess the generated code is not what you expect
05:36:57 * aavogt sees that $(treeFlatten 1) :: Maybe (Maybe t, Maybe t1) -> Maybe (t, t1)
05:36:59 <taotree> figured it out
05:37:00 <Younder> ousado, simple take a syringe pull it full of pure alcohol and inject it. Ligts out for sure.
05:37:09 <taotree> sorry, syntax error on the Just's
05:37:21 <Tinned_Tuna> Younder: brb (maybe...)
05:38:46 <aavogt> if you can have all the types equal, this treeFlatten is close to what sequence does
05:38:50 <taotree> now I have to figure out how to convert it to giving me maybe's instead of justs
05:39:00 <aavogt> or I guess      liftM toList . sequence
05:39:24 <taotree> all types aren't equal, though I do only have to flatten one level
05:40:04 <Younder> don't try this at home..
05:40:24 * aavogt ought to learn metaocaml
05:41:20 <taotree> aavogt, doing what you suggested before:   Couldn't match expected type `PatQ' against inferred type `[PatQ] -> PatQ'
05:42:27 <aavogt> missing arguments?
05:43:09 <taotree> to what? Sorry... I'm lost in this TH stuff. It won't compile treeFlatten
05:43:39 <aavogt> most of the things in that function are ordinary haskell
05:44:17 <aavogt> besides the  [| |], $( ), and 'Name
05:44:32 <ousado> Younder: sure, but the term "drinking" somewhat excludes that procedure
05:46:13 <aavogt> taotree: if you're still interested in learning TH, I can suggest to look at the types of things in ghci. You can ex. write       :t $(treeFlatten 2),  or   :t conP 'Just    etc.
05:46:54 <taotree> ok
05:47:15 <aavogt> or look at the haddocks to see how Exp and Pat and similar data types (or the lowercase versions that are basically liftM versions of the original) correspond to haskell syntax you know
05:47:32 <aavogt> and  :set -ddump-splices   is also very helpful
05:47:42 <aleator> Daerim: How comes it knows when it can modify something inplace?
05:47:47 * aavogt needs to head out, probably other people can help too
05:50:50 <c1de0x> so. haskell/python bridges.
05:51:11 <c1de0x> i'm linking for a bi-directional bridging mechanism.
05:51:12 <merijn> c1de0x: Haskell has FFI to C and accessing C from python is trivial as well
05:51:24 <merijn> So I think using C as a bridging language is simplest
05:51:29 <c1de0x> yeah, but that's one way
05:51:37 <c1de0x> i.e. from haskell to c and from python to c.
05:51:47 <merijn> Why? C can call haskell code...
05:51:53 <c1de0x> i want to be able to callback across the boundaries.
05:51:59 <merijn> and python can also do that
05:52:14 <MasseR> I'm trying to look up on iteratees. I'm using the enumerator package. On my other computer I can do 'liftIO $ foo' in Enumerator Int IO Int, however in my laptop it complains about "No instance for (MonadIO (Iteratee Int IO.."
05:52:15 <Younder> merijn, I would link stdou to the python repl.
05:52:16 <c1de0x> merijn: will i need to host both the python and haskell runtimes?
05:52:25 <merijn> c1de0x: Yes
05:52:27 <Younder> s/stdou/stdout/
05:52:47 <Daerim> aleator, Fusion as far as I can tell. If it's in the middle of doing fusioning the array away anyway, it can do the update in place
05:53:30 * Daerim admits it is very close to magic
05:54:27 <aleator> Daerim: Yeah.. Vector is somewhat complex. BTW. I made a benchmark of the earlier non-fusing case: http://hpaste.org/paste/43960/huge_vector_speed_difference#p43971
05:54:46 <Younder> By running them as separate processes I avoid coupling.
05:55:22 <aleator> Argh. Darn! Thats buggy.
05:56:08 <aleator> And I already rejoiced that I don't need to code in c..
05:56:11 <Daerim> aleator, f4 and f4' do not do the same thing
05:56:15 <Younder> aleator, what is?
05:56:37 <Daerim> f4 is dependent on dim, f4' isn't
05:57:20 <aleator> Younder: I forgot recursion :)
05:57:41 <Daerim> aleator, either dim = length x , or you need to do a slice in f4'
05:57:42 <aleator> That was stupid.
05:57:53 <c1de0x> is there any documetnation of how to host the haskell runtime in a c/c++ app?
05:58:05 <aleator> Daerim: dim = length x. it is there just to make interface interchangeable.
05:58:15 <Daerim> aleator, ahh, ok
05:58:42 <MasseR> http://hpaste.org/43972/enumerators I have this problem with enumerators
05:58:56 <merijn> c1de0x: Compile your haskell code to a shared library with GHC and just link your C code with that
05:59:08 <c1de0x> hrm. ok.
05:59:44 <minn> Is it okay to ask non-Haskell specific lambda-calculus questions here?
06:00:12 <Miki> michpre
06:00:12 <merijn> minn: I do that all the time :p
06:01:22 <Daerim> aleator, tell me whn you have an updated version of your benchmark. I tried to replicate it earlier, but without luck
06:02:29 <aleator> Daerim: I did it, but it is no longer interesting - the sum+map one is faster by small margin as expected
06:02:40 <aleator> Do you want a paste?
06:02:56 <minn> Well, that's a relief :) Okay: suppose I have two small-step evaluation relations ->L and ->G and I want to ->G only to apply at the "outermost level" of evaluation under ->L. I.e., the composition ->G . ->L is unacceptable. What is the best way to define the relation?
06:02:58 <HaudRex> Have you the link to Guy Steele's recent talk where he talks about "the ugliest program he ever wrote?"
06:03:28 <Daerim> aleator, yes please. Just for fun :)
06:03:35 <Younder> c1de0x, I believe it is 0xc1de 
06:04:35 <aleator> Daerim: There it is
06:05:10 <Younder> C1 = ascii(a)
06:06:02 <Daerim> aleator, hmm... don't see it
06:07:13 <Younder> Daerim, think parallel  like map-reduce
06:07:35 <Daerim> Younder, huh?
06:08:01 <Younder> Heard of pipelines in CPU's
06:08:11 <c1de0x> Younder: that is the origin of my nick ;)
06:08:56 <jmcarthur> c1de0x: the haskell ffi supports callbacks both ways
06:09:16 <c1de0x> jmcarthur: oki. will look into thtat.
06:09:38 <aleator> Daerim: http://hpaste.org/43973/huge_vector_speed_difference
06:09:39 <Bynbo7> HaudRex: that's a great talk :)
06:09:47 <HaudRex> http://www.infoq.com/presentations/Thinking-Parallel-Programming
06:09:50 <HaudRex> found it
06:10:38 <aleator> afk.
06:22:49 <Peaker> Ouch, with the OverloadedStrings extensions, one can no longer treat strings as lists without explicitly tagging the type
06:23:20 <Peaker> (the normal type ambiguity that may result is clear, but I wasn't aware of a serious downside till now..)
06:24:10 <Peaker> Maybe if fromIntegral was named "fi" and we had "fs" for fromString, then overloaded literals wouldn't be a big deal
06:24:27 <Lemmih> When do you only treat string literals as lists?
06:24:34 <Jafet> I always define munge=fromIntegral
06:24:34 <Lemmih> length "string"?
06:25:06 <Jafet> If you treat a string literal as a list, won't it get unified to String?
06:25:54 <sipa> if [Int] got an IsString instance, it would be valid
06:25:55 <sipa> so no
06:25:56 <Daerim> aleator, if you switch to unsafeIndex, you'll beat sum.map by about 10%
06:26:27 <Jafet> Ah, insidious
06:30:18 <Jafet> Does ghc ever convert overloaded string literals at compile time?
06:33:25 <Peaker> If we had proper polymorphism of the standard library (fmap in place of map, length and others being defined on Foldable, etc) then we could care less about whether the string type is a list or not
06:33:43 <Peaker> (It would probably be proper for the literal string type to be Text or such)
06:34:43 <Jafet> Still, you could make [Int] strings have different length from [Char] strings (by overloading fromString, or length, or both)
06:36:36 <Jafet> What we need in this case is a many-worlds interpretation of haskell. If defaulting to one instance leads to a bug, the containing universe should be promptly destroyed, and vice versa
06:37:04 <mm_freak_> Jafet: we have that interpretation
06:37:31 <mm_freak_> > do x <- [-5 .. 5]; guard (x /= 0); return (10 / x)
06:37:32 <lambdabot>   [-2.0,-2.5,-3.3333333333333335,-5.0,-10.0,10.0,5.0,3.3333333333333335,2.5,2...
06:37:33 <Peaker> Reading intro to Agda, not having sections sounds bumming
06:38:27 <Peaker> > [10 / x | x <- [-5..5], x/=0]
06:38:28 <lambdabot>   [-2.0,-2.5,-3.3333333333333335,-5.0,-10.0,10.0,5.0,3.3333333333333335,2.5,2...
06:39:04 <Jafet> > [10/x | x <- [-4..5], x/=0]
06:39:05 <lambdabot>   [-2.5,-3.3333333333333335,-5.0,-10.0,10.0,5.0,3.3333333333333335,2.5,2.0]
06:39:23 <Jafet> Why does it cut off something with the same length as the ellipsis?
06:39:59 <zygoloid> Jafet: off-by-one error, i'm guessing
06:43:23 <Gracenotes> Haskell' proposal: changing System.IO.Error.IOErrorType's NoSuchThing to NoSuchThang. .. ... no real reason.
06:44:23 <Cale> Support both spellings *trollface*
06:46:50 <Gracenotes> alt proposal AintNoSuchThang
06:47:36 <Gracenotes> then free lunch to follow? ....
06:47:36 <mm_freak_> just compare levenshtein distance to all identifiers, if the given one doesn't exist
06:47:44 <mm_freak_> if the distance is < 2, accept
06:47:44 <Jafet> You forgot an apostrophe
06:47:47 * Gracenotes needs some tea, with caffeine
06:47:59 <Jafet> mm_freak: if not, throw an exception?
06:48:11 <luite> what if two have the same distance?
06:48:57 <mm_freak_> if not, then emit a warning and take the first identifier found with the smallest levenshtein distance
06:49:00 <chrisdone> > catMaybes . map (uncurry fmap . first (,)) $ [("a",Just "x"),("b",Nothing)] -- sweet
06:49:01 <lambdabot>   [("a","x")]
06:49:02 <Jafet> luite: select exception names so that this cannot happen
06:49:19 <mm_freak_> luite: in that case, create a nondeterministic executable including each variant with a valid type
06:49:43 <chrisdone> @pl catMaybes . map (uncurry fmap . first (,))
06:49:43 <lambdabot> catMaybes . map (uncurry fmap . first (,))
06:49:53 <luite> Jafet: but users can creat their own exceptions
06:50:24 <chrisdone> @pl \xs -> map (\(x,y) -> (x,fromJust y)) . filter (isJust . snd)
06:50:25 <lambdabot> const (map (second fromJust) . filter (isJust . snd))
06:50:53 <Jafet> luite: enforce it in the type system
06:50:55 <Gracenotes> isJust/fromJust? o.o
06:51:42 * hackagebot language-sqlite 1.1 - Full parser and generator for SQL as implemented by SQLite3  http://hackage.haskell.org/package/language-sqlite-1.1 (DanKnapp)
06:51:46 <mosva> Is it a standard/coding convention to specify the types of a function?
06:51:49 <mm_freak_> chrisdone: sounds like you want 'maybe'
06:52:01 <ceii_> mosva: yes
06:52:03 <mm_freak_> or 'catMaybes'
06:52:07 <chrisdone> mm_freak_: as Morpheus said, show me
06:52:17 <chrisdone> mm_freak_: I just used catMaybes. O_ o
06:52:34 <ceii_> mosva: it provides good inline documentation, and often helps the type checker give better error messages
06:52:35 <mm_freak_> chrisdone: yeah, then you somehow went on to isJust/fromJust =)
06:52:47 <FunctorSalad> the emacs and vim modes can insert the type sigs automatically for you =)
06:52:50 <chrisdone> mm_freak_: that is so that pl can reduce it
06:53:00 <mosva> ceii_, Thanks, I did not specify types to make the code look more elegant
06:53:02 <chrisdone> but it kept it as is
06:57:23 <mm_freak_> > catMaybes . map (uncurry $ liftA2 (,) . pure) $ [("a",Just "x"),("b",Nothing)]
06:57:25 <lambdabot>   [("a","x")]
06:58:41 <mm_freak_> > catMaybes . map (uncurry $ fmap . (,)) $ [("a",Just "x"),("b",Nothing)]
06:58:43 <lambdabot>   [("a","x")]
07:01:12 <mm_freak_> > (3,4) { snd = 5 }
07:01:13 <lambdabot>   `Data.Tuple.snd' is not a record selector
07:01:17 <mm_freak_> bad
07:01:37 <mm_freak_> data (,) a b = (,) { fst :: a, snd :: b }
07:02:10 <Jafet> > fst (1,2,3)
07:02:11 <lambdabot>   Couldn't match expected type `(a, b)'
07:02:11 <lambdabot>         against inferred type `(t, t1...
07:02:18 <Jafet> Worse!
07:02:49 <homie> seq ?
07:02:54 <fryguybob> > second (const 5) (3, 4)
07:02:55 <lambdabot>   (3,5)
07:02:55 <homie> force ?
07:06:08 <jonkri> besides using the current time as a seed, is there a seed that you can get from the os (so that you get two layers of security (or would that be redundant?))?
07:07:26 <Jafet> Security from what?
07:08:13 <jonkri> Jafet: someone predicting the values i am going to generate
07:08:42 <Jafet> Eh, who?
07:08:58 <jonkri> Jafet: someone eavesdropping on the xmpp xml stream
07:09:23 <jonkri> all i know is that xmpp core recommends this for generation of ids: http://tools.ietf.org/html/rfc1750
07:09:26 <Jafet> Well, you will need more seed and a better generator.
07:09:27 <dankna> insufficient randomness is a real problem
07:09:41 <dankna> there have been exploits in the wild (I believe against Netscape, for example) of it
07:09:50 <jonkri> more seed than what? that is what my question is about :)
07:09:52 <dankna> Linux-like OSes have /dev/random
07:10:02 <dankna> when in doubt check the source, heh
07:10:16 <haskellnoob> I am trying to debug some code. Is there a way I can put statements in the code that will print out the values of certain variables so that I can see how these values are getting modified?
07:10:18 <jonkri> dankna: this needs to run on windows and mac too
07:10:21 <Jafet> 128 bits of unpredictability is enough for about anything.
07:10:24 <dankna> yeah, I know
07:10:54 <dankna> I would check the source of the base library to see where it currently seeds from
07:11:16 <dankna> and if it's not an acceptable source on all platforms, you might consider writing a trivial portability library that wraps around OS-provided good randomness
07:11:39 <Jafet> You might consider looking for such a library on hackage
07:12:25 <dankna> yes, or that, haha
07:12:53 <kmc> haskellnoob, Debug.Trace
07:12:53 <Jafet> Then look for a suitable generator in a cryptographic library.
07:13:22 <haskellnoob> kmc: let me look up its usage, thanks
07:13:25 <dankna> well, strong randomness has to be OS-provided because only the kernel is in a position to aggregate entropy from lots of sources
07:13:35 <Jafet> haskellnoob: ghci has a debugger, which can print values
07:13:47 <dankna> some hardware also has hardware-based entropy generators, which only the OS interface will get you access to
07:13:48 <Jafet> dankna: that's not the real reason (nor really a reason; see egd)
07:14:00 <dankna> well, I would consider egd part of "the OS"
07:14:08 <dankna> inasmuch as it has tight bindings with lots of other packages
07:14:20 <haskellnoob> Jafet: I'm afraid I don't know how to trace this code to the point I want using ghci. I am trying to debug darcs code, and I don't even know how to load that into ghci.
07:15:03 <dankna> I guess what I really meant though was
07:15:21 <Jafet> Well, trace may overstrictify some code. That's the only possible problem with it, I think.
07:15:25 <dankna> the OS or distribution developer has already put a lot of work into finding the best available source of entropy; it would be best to leverage it
07:15:28 <Jafet> @quote oasis
07:15:28 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
07:15:48 <mm_freak_> jonkri: use your favorite crypto library to generate randomness
07:16:08 <mm_freak_> do NOT use the usual random number generators from System.Random or the mersenne twister packages
07:16:16 <mm_freak_> i believe the AES package has a strong random number generator
07:17:14 <mm_freak_> yes, it has, but you'll need to try it on windows…  it refers to /dev/random
07:17:19 <mm_freak_> in its documentation
07:17:37 <jonkri> thanks :)
07:18:27 <mm_freak_> otherwise there are also bindings to openssl…  you may find strong generators there
07:18:37 <tab> what about crypto-api ? it's portable
07:18:47 <mm_freak_> btw, if you can, avoid generating this stuff yourself…  most crypto packages, which need randomness, generate it by themselves
07:18:56 <mm_freak_> tab: crypto-api is just a framework
07:18:59 <Jafet> Bah, it's just xmpp. How bad can it get!
07:19:12 <tab> mm_freak_: no there's system randomness stuff as well
07:19:25 <tab> which source /dev/random on linux, and the appropriate things on windows
07:19:44 <tab> System.Crypto.Random
07:19:49 <mm_freak_> oh, indeed
07:19:51 <mm_freak_> good to know
07:19:58 <mm_freak_> thanks
07:20:02 <rumbold1> i wonder how cabal dtermines that a c library is missing. it has to look for the files it needs, but how does it know where to look? i added include-dirs and extra-lib-dirs to the .cabal, which works for pthread, but doesnt work for il. but how does it knowwhere to look for which library? i dont get it.
07:20:21 <mm_freak_> tab: on the other hand the system sources are meant to be used as seed sources
07:20:28 <rumbold1> i also asked my question here: http://stackoverflow.com/questions/4991093/trying-to-install-image-codec-devil-under-windows-needs-pthread-and-il-cant-ge in case you dont remember what my problem was :p
07:20:35 <dcoutts> rumbold1: it just asks the C compiler
07:20:39 <Jafet> The usual directories for C libraries on your system, probably
07:20:50 <Jafet> Or that
07:21:11 <dcoutts> rumbold1: and the include-dirs and extra-lib-dirs in the .cabal file and on the command line are taken into account
07:21:30 <haskellnoob> kmc: I guess I should use the putTraceMsg function. I am not at all sure what a monad is, but I have a feeling that this function won't work in a context where IO() is not the expected type.
07:21:52 <rumbold1> okay, but how does it know which folder is supposed to be which library? i mean if two libraries had files with the same names, it couldnt tell them apart... i think
07:22:03 <Daerim> rumbold1, note that getting C dependencies for haskell packages to work can be EXTREMELY frustrating work. Often the easiest way is to compile everything from source
07:22:12 <Daerim> under windows, that is
07:22:39 <dcoutts> rumbold1: indeed, it's important that C lib names do not clash
07:22:41 <haskellnoob> (I guess I will try fiddling with it and see, though.)
07:22:44 <rumbold1> yeah, i got it to work on linux easily
07:24:33 <dcoutts> rumbold1: you said you tried --extra-include-dirs and --extra-lib-dirs and it didn't work. That should work.
07:25:09 <tab> mm_freak_: they always are indeed
07:25:18 <dcoutts> it's perhaps worth double checking, it should be the same as editing the .cabal file. It should be unnecessary to edit the .cabal file.
07:26:18 <Daerim> rumbold1, actually... doesn't it just check the dirs listed in your PATH?
07:26:20 <rumbold1> i just went back to the old ocmmand i executed in my cmd window and it looks like i had forgotten a \lib.... D:
07:26:40 <ocharles> Hey, asked last night but I guess most people were sleeping :) Trying to use parsec to turn ":foo:bar:baz:" into ["foo","bar","baz"] but I can't quite get it to work. I was trying to use a combination of between and sepBy1, but sepBy1 ends up consuming the trailing ':'
07:26:41 <ocharles> any ideas?
07:27:01 <rumbold1> but it still wont work for il
07:27:02 <haskellnoob> The code I want to debug is a function which starts off like the following:
07:27:04 <haskellnoob> filterPatchesByNames maxcount fs ((Sealed2 hp):ps) | Just p <- hopefullyM hp = case lookTouch fs (invert p) of
07:27:12 <ocharles> I can't quite see a nice way to factor that grammar
07:27:26 <haskellnoob> (I guess I should paste it instead ...)
07:28:24 <dcoutts> rumbold1: if you're sure it's there, run with -v3, it'll display the error that gcc reports when trying to link to IL
07:28:42 <haskellnoob> The function I want to debug starts of like here in this paste:  http://hpaste.org/43974/using_debugtrace
07:29:16 <haskellnoob> I would like to print the value of "fs" at the start of the function, before the case statement starts
07:29:25 <haskellnoob> How do I do this?
07:31:05 <haskellnoob> (As far as I can figure out, this "fs" is a Maybe [String] )
07:31:13 <rumbold1> i just tried undoing my changes to the .cabal file and using the extra dirs flags for pthread, but it still doesnt work
07:33:01 <dcoutts> rumbold1: run with -v3, it'll display the error that gcc reports when trying to link to IL
07:33:19 <rumbold1> yeah i did, still reading the output now
07:33:20 <dcoutts> rumbold1: or indeed for pthread
07:33:38 <rumbold1> looks like it only gives an error for il and none for pthread
07:34:02 <dcoutts> rumbold1: it may well stop at the first error, I forget
07:34:14 <dcoutts> since libraries can depend on each other
07:34:58 <rumbold1> oh tere's a pthread error later
07:37:26 <haskellnoob> I figured out how to use it, thanks :)
07:40:56 <kmc> haskellnoob, understanding monads is neither necessary nor sufficient for understanding IO
07:41:04 <kmc> haskellnoob, see http://www.haskell.org/haskellwiki/Introduction_to_IO
07:41:14 <haskellnoob> kmc: thanks
07:41:20 <rumbold1> so how does the c compiler figure out whether a library is there or not? :) i get errors like "C:\Program Files (x86)\Haskell Platform\2010.2.0.0\mingw\bin\ld.exe: cannot find -lpthread", how does it know which files are needed for lpthread? does it have a database for every library ever saying which files need to be present for them? ;)
07:41:22 <kmc> haskellnoob, anyway the point of Debug.Trace is that "trace" function, which lets you "bend the rules"
07:41:31 <kmc> haskellnoob, normally a function evaluation can't perform I/O
07:41:33 <haskellnoob> I can use just trace to do what I want, thanks
07:41:40 <kmc> only the execution of IO actions (values of a particular type) can
07:41:49 <kmc> but the "trace" function lets you break this rule
07:41:52 <kmc> for debugging purposes
07:41:59 <kmc> the caveat is that you may not see the output when you expect to see it
07:42:03 <haskellnoob> kmc: which is such a relief :)
07:42:03 <allbery_b> "IO is a sewer, we wrap it in a monad to try to keep it from spreading"
07:42:20 <kmc> the one-way-ness of the IO type is not really related to the fact that it's a monad
07:42:23 <kmc> most monads aren't like that
07:42:24 <kmc> anyway
07:42:35 <haskellnoob> I am ok with seeing the output in aggregate, so this is just fine
07:42:38 <kmc> cool
07:43:00 <kmc> you will see the output whenever the runtime system decides to actually evaluate that expression, which could be later than you expect due to laziness
07:43:26 <kmc> that's why we usually don't drive IO from evaluation
07:43:47 <kmc> brb
07:46:34 <rumbold1> huh, thats odd
07:46:46 <rumbold1> if i just add the folders for pthread, it only says il is missinh
07:46:48 <rumbold1> missing
07:46:58 <rumbold1> but when i add the il folders, it says both are missing
07:48:37 <navaati> hello
07:49:08 <rumbold1> my command currently looks like this:
07:49:10 <rumbold1> cabal --extra-include-dirs=C:\Users\Rumbold\Documents\libs\pthread\include,C:\Users\Rumbold\Documents\libs\IL\include --extra-lib-dirs=C:\Users\Rumbold\Documents\libs\pthread\lib,C:\Users\Rumbold\Documents\libs\IL\lib install codec-image-devil
07:49:18 <rumbold1> am i too dumb to add multiple folders?
07:49:48 <dcoutts> rumbold1: specify the flag multiple times, rather than using ,
07:50:56 <rumbold1> okay, pthread works again
07:51:16 <rumbold1> so i guess there must be something wrong with my il "installation"
07:54:30 <rumbold1> hm, maybe im using the wrong version of il
07:54:45 <rumbold1> how do i know which version codec.image.devil wants?
07:56:50 <navaati> I have an action like this :
07:56:51 <navaati> mapM_ (\p -> (regionPointIn region p) >>= (flip when $ drawPoint d (f p) p)) $
07:56:51 <navaati>     liftM2 (,) (sizedRange boxX width) (sizedRange boxY height)
07:56:51 <navaati>  where sizedRange start size = enumFromTo start  (start+size)
07:56:51 <navaati> it runs in linear (or whataver, but growing) space, however i guess it could be done in constant space (generate a point, draw it, generate the following point…), how can I achieve this ?
07:58:14 <navaati> (I used filterM_ before, with the "regionPointIn" action, but it used hundreds of megabytes)
08:00:22 <rumbold1> hm, codec.image.devil is from 2010 and the newest devil version is from mid 2009. i guess i can assume that its using the newest D:
08:01:02 <Jafet> navaati: which monad is that?
08:01:07 <navaati> IO
08:01:27 <navaati> the liftM2 at the end is for the list monad
08:02:14 <ClaudiusMaximus> i'm guessing it would keep the whole of the first list in memory, to traverse it multiple times?
08:03:02 <navaati> but it *doesn't* traverse it multiple times, well, I hope so
08:03:09 <Jafet> I don't see a strictness problem there, then
08:03:17 <ClaudiusMaximus> > liftM2 (,) "abc" "def"
08:03:18 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
08:03:44 <Jafet> Well, not a big strictness problem
08:03:54 <ClaudiusMaximus> oops, traverse second list multiple times
08:04:18 <navaati> which second list ? "sizedRange boxY height" ?
08:04:24 <ClaudiusMaximus> yes
08:06:14 <ClaudiusMaximus> i had some problems like this once, was very annoying (i think i was using list comprehensions - can't remember how i fixed it, possibly i resorted to one list with divMod or so)
08:06:27 <navaati> isn't it possible to generate [(x,y) | x <- sizedRange boxX width, y <- sizedRange boxY height] (this is what the liftM2 does) in constant space ?
08:06:53 <Jafet> Are you sure that's the part that uses "hundreds of megabytes"?
08:07:02 <Jafet> Oh, that's for another version
08:07:11 <jaj> hmm /w 3
08:07:14 <jaj> fail
08:08:02 <ClaudiusMaximus> sure, if you recompute Y for each X - if it's shared (as it might be with some optimizations i believe) then you have space issues - it's a tradeoff whether recomputation is cheaper than sharing
08:09:56 <navaati> in fact i want to use fusing technics
08:10:14 <navaati> so that i never construct the lists
08:10:44 <Jafet> That improves speed, not space
08:10:54 <Jafet> Not by much, at least
08:11:54 <navaati> > mapM_ print [0..10000]
08:11:55 <lambdabot>   <IO ()>
08:12:02 <hpc> actually
08:12:19 <hpc> i assume sizedRange ends up being a list [n..m]
08:12:21 <hpc> yes?
08:12:34 <navaati> this one should consume the space of "[0..10000]" without fusing, and only the size of an Int with fusing, right ?
08:12:38 <hpc> if so, you can use ST to build the list, like you would in an imperative program
08:12:42 <hpc> with two nested loops
08:13:39 <hpc> navaati: that example is garbage collection, not fusing
08:13:53 <hpc> (i think; i don't fully get fusion rules)
08:14:09 <ClaudiusMaximus> i remember what i did now
08:14:37 <ClaudiusMaximus> something like [(x,y) | x <- [1 .. 1000], y <- [x+1-x .. 1000]]
08:15:08 <hpc> ClaudiusMaximus: ew!
08:15:37 <hpc> although i suppose that's less ugly than using ST
08:16:05 <navaati> hpc, you mean that in pure haskell this runs in constant space ? so mapM_ can consume the list as it's builded only using lazyness ?
08:17:24 <hpc> navaati: yep
08:17:33 <hpc> and it discards elements as it finishes using them
08:17:50 <hpc> (assuming the list [0..100000] isn't bound to a name and used elsewhere)
08:18:14 <rumbold1> okay i got it to work... had to rename DevIL.lib and DevIL.dll to libIL.lib and libIL.dll (not sure which)
08:18:28 <navaati> hum… so i don't see the utility of fusing
08:19:13 <hpc> navaati: it saves CPU according to Jafet
08:19:28 <hpc> and he left, so he can't clarify :(
08:21:15 <adamc> Hi all. When I use shiftL x y, and my y is of type Int32 instead of Int, I get a type error. How might I resolve this?
08:21:50 <Jafet> Has anyone used the new ncurses package?
08:22:08 <Jafet> adamc: convert it to Int?
08:22:14 <Jafet> @hackage ncurses
08:22:14 <lambdabot> http://hackage.haskell.org/package/ncurses
08:22:35 <Tomsik> only a tiny bit
08:22:42 <adamc> Jafet: How do I go about doing that?
08:22:52 <Tomsik> It was a lot better than the old one
08:23:05 <adamc> I don't plan on using unsafeCoerce.
08:23:07 <Tomsik> except there's still no "putGlyph" primitive
08:23:08 <navaati> ok, i think i'll try the ST way, as i don't understand the ClaudiusMaximus's trick
08:23:12 <Jafet> It looks simpler. Hopefully not excessively simpler
08:23:23 <Jafet> @type fromIntegral -- adamc
08:23:24 <lambdabot> forall a b. (Integral a, Num b) => a -> b
08:23:34 <adamc> aha
08:23:53 <Jafet> unsafeCoerce isn't a conversion, it's a coercion
08:24:08 <navaati> but ST can produce a lazy list ?
08:24:43 <adamc> Thanks Jafet :)
08:24:57 <Jafet> Tomsik: so, were you able to put Glyphs?
08:25:25 <Tomsik> Yeah, I just drew lines with length of 1
08:26:03 <Jafet> Oh, thanks in advance then
08:26:44 <Tomsik> It's a big improvement over the last library, that you can store characters together with attributes by default :p
08:27:24 <Jafet> Well, even ncurses let you do that
08:27:31 <jedai> @type shiftL
08:27:32 <Jafet> Doesn't seem to store colors, though
08:27:33 <lambdabot> forall a. (Bits a) => a -> Int -> a
08:28:01 <Tomsik> hmm, haven't messed with the colors, to be honest
08:28:53 <rumbold1> okay, this is strange. leksah under windows complains that main isnt exported by the main module. but its the same code i used under linux and it worked fine there
08:28:53 <ClaudiusMaximus> navaati: http://hpaste.org/43986/ew_fix_mem_leak
08:28:55 <Jafet> I hear that rxvt supports 1024 colors. Never tried, or ever come across a program that tried
08:29:25 <Jafet> Oh, 256.
08:31:57 <rumbold1> looks like now, it doesnt like my libHSCodec-Image-DevIL-0.2.3.a; lots of undefined references D:
08:36:09 <navaati> ClaudiusMaximus: pretty strange stuff… ok, i'll give it a try
08:37:57 <ClaudiusMaximus> navaati: what it does is 'trick' the optimiser into thinking 'y' depends on 'x', so it has to recompute it - this trick will fail when ghc learns that x+1-x = 1 :)
08:38:32 <Jafet> Tomsik: by the way, did you have to sprinkle liftIO?
08:38:56 <Tomsik> I think you're supposed to runCurses once, but not sure
08:39:11 <Tomsik> and I didn't do any IO besides Curses, so nope, no lifting
08:40:18 <Jafet> Ugh, this just feels a little too functional
08:40:47 <djahandarie> @tell copumpkin What do you think about http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf / http://hackage.haskell.org/package/invertible-syntax
08:40:47 <lambdabot> Consider it noted.
08:43:09 <Jafet> Hm, ghci segfaults
08:43:48 <Tomsik> I don't think you're supposed to write over terminal using a console application like ghci :p
08:44:01 <Jafet> Well, that's just dandy!
08:44:13 <Jafet> I don't see why that would cause a segfault, though
08:44:38 <tg_> me neither
08:44:41 <ClaudiusMaximus> maybe -threaded issues?
08:44:41 <tg_> and I'm just listening
08:45:02 * ClaudiusMaximus guesses wildly
08:47:23 <Jafet> I suppose this just goes to show that you can never truly tame ncurses. Now I'll go atone with an offering of burnt shadow masks.
08:49:22 <djahandarie> Hm, so what do you do when neither of two packages want to depend on each other but you want an instance that mixes both of them (i.e., typeclass from one, type from the other)?
08:49:37 <Tomsik> I wonder if writing a more modern library for such ASCII work, disregarding old and quirky terminals' legacy would, would be a lot of work
08:50:19 <Jafet> Like what, libcaca?
08:50:58 <systemfault> That's a winning name for a library.. :/
08:51:04 <systemfault> (libshit)
08:51:11 <monochrom> libkekekekeke
08:51:17 <djahandarie> lol
08:51:37 <Jafet> libcaca is conveniently licensed under the what-the-fuck public license
08:52:30 <Jafet> I consider all terminals quirky and legacy. In-band control signalling is broken by design
08:54:38 <HugoDaniel> hi
08:54:53 <HugoDaniel> how do i convert a bytestring that is in iso-8859 to utf8 ?
08:57:09 <HugoDaniel> im going to try iconv (it works nicely on the terminal)
08:58:36 <jmcarthur> Peaker: huh, i've been using that extension in my .ghci for a long time and never even noticed that (OverloadedStrings)
08:59:01 <jmcarthur> Peaker: i guess that just shows how rarely i use the list representation of strings, at least in ghci
09:07:38 <comex> Why is http://projects.haskell.org/haskellmode-vim/ empty?
09:07:57 <comex> or is there something better I could use
09:08:00 <comex> (other than emacs :)
09:08:30 <hpc> more relevantly, why is projects.haskell.org using mod_python and mod_perl?
09:09:19 <tab> comex: seems that every projects on p.h.o is empty (probably related to the server moving)
09:09:32 <comex> ah
09:17:37 <seydar> blackdog: are you awake yet?
09:17:50 <seydar> no, you're not
09:19:28 <HugoDaniel> its really a pain that http://hackage.haskell.org/packages/ doesn't redirect to http://hackage.haskell.org/packages/archive/pkg-list.html
09:19:45 <HugoDaniel> overall i tend to find the urls of hackage quite misleading 
09:23:35 <seydar> so according to this: http://hackage.haskell.org/trac/ghc/wiki/Platforms
09:23:42 <seydar> GHC can't do dynamic libraries ever
09:23:53 <seydar> on x86_64
09:24:05 <seydar> slash x86
09:25:20 <HugoDaniel> how do i "convert" from lazy bytestring to strict ?
09:25:28 <tab> HugoDaniel: toChunks
09:25:34 <HugoDaniel> thanks
09:25:34 <HugoDaniel> :)
09:27:00 <Jafet> Hm, NCurses segfaults anyway
09:27:14 <Jafet> Probably something wrong with the installation
09:31:05 <HugoDaniel> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.9/doc/html/Data-ByteString-Internal.html
09:31:11 <HugoDaniel> not working
09:40:32 <rumbold1> i'm getting error messages like this: libHSCodec-Image-DevIL-0.2.3.a(DevIL.o):fake:(.text+0x2379): undefined reference to `ilGetInteger@4'
09:40:59 <rumbold1> whats does the (DevIL.o) part mean? which files is broken, the .a or the .o?
09:43:04 <koki_> hey! how can I look in haskell how the function is defined?
09:45:10 <Lemmih> koki_: What function?
09:45:25 <koki_> Lemmih: foldr1 for example
09:45:45 <Lemmih> ?src foldr1
09:45:45 <lambdabot> foldr1 _ [x]    = x
09:45:45 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
09:45:45 <lambdabot> foldr1 _ []     = undefined
09:45:52 <HugoDaniel> how do i convert from Data.ByteString.Internal.ByteString to Data.ByteString ?
09:46:00 <koki_> thanks!
09:46:08 <Lemmih> HugoDaniel: Same thing.
09:46:17 <HugoDaniel> cool
09:46:52 <Lemmih> koki_: You can also find the haddock documentation and click on "source".
09:49:53 <HugoDaniel> Lemmih, apparently there is no toChunk in ByteString Internal
09:50:14 <Lemmih> HugoDaniel: It's from Data.ByteString.Lazy.
09:50:43 <Lemmih> HugoDaniel: It takes a lazy bytestrings and gives you a list of strict ones.
09:51:27 <Lemmih> HugoDaniel: So, 'Strict.concat . Lazy.toChunks' will turn a lazy bytestring into a strict one.
09:52:05 <Jafet> NCurses won't work on this system, but HSCurses does. My penance is complete.
09:53:52 <koki_> ?src map
09:53:53 <lambdabot> map _ []     = []
09:53:53 <lambdabot> map f (x:xs) = f x : map f xs
09:56:59 <koki_> ?src filter
09:56:59 <lambdabot> filter _ []     = []
09:56:59 <lambdabot> filter p (x:xs)
09:57:00 <lambdabot>     | p x       = x : filter p xs
09:57:00 <lambdabot>     | otherwise = filter p xs
09:58:06 <HRuivo> Hi all, I'm having some problems using time in Haskell. I can use getClockTime on anything because it returns IO ClockTime and not ClockTime
09:58:25 <HRuivo> what should be the best way to get the current hour and minutes?
09:58:34 <Jafet> Well, obviously it would return IO ClockTime ... the time changes all the time!
09:58:47 <Jafet> @hoogle now
09:58:48 <lambdabot> Text.Html nowrap :: HtmlAttr
09:58:48 <lambdabot> Text.XHtml.Transitional nowrap :: HtmlAttr
09:58:48 <lambdabot> Text.Parsec.Error errorIsUnknown :: ParseError -> Bool
10:05:16 <iago> hi, what is the way to convert a lazy bytestring to an strict one ?
10:05:39 <roconnor> @hoogle chunks
10:05:39 <lambdabot> Data.ByteString.Lazy.Internal defaultChunkSize :: Int
10:05:39 <lambdabot> Data.ByteString.Lazy.Internal foldlChunks :: (a -> ByteString -> a) -> a -> ByteString -> a
10:05:40 <lambdabot> Data.ByteString.Lazy.Internal foldrChunks :: (ByteString -> a -> a) -> a -> ByteString -> a
10:05:46 <roconnor> @hoogle fromChunks
10:05:46 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
10:05:46 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
10:05:51 <roconnor> hmm
10:06:09 <Lemmih> iago: Strict.concat . Lazy.toChunks
10:06:52 <iago> Lemmih, thanks
10:10:28 <ksf> roconnor, what are you looking for?
10:11:01 <roconnor> I was trying to help iago
10:11:40 <ksf> oh. the answer is you don't want to, you want to convert it to multiple.
10:11:47 <ksf> @hoogle toChunks
10:11:47 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
10:11:48 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
10:12:13 <ksf> you can then just append them, but that's a lot of copying.
10:18:50 <dcoutts> iago: right, as ksf says, converting to a strict one is not good for performance
10:18:57 <dcoutts> perhaps that doesn't matter in your use case
10:21:55 <iago> dcoutts, I'm forced to do that, I'm just using file content from a hashed-storage Tree (lazy bytestring) to generate a Darcs Hunk (strict bytestring)
10:23:31 <Jesin> hmm
10:23:34 <dcoutts> iago: well, it should be a concious resource/performance design decision that your hunks are going to be all in memory at once and will not be processed incrementally.
10:23:57 <Jesin> we are cautioned to use foldl' instead of foldl in implementing factorial/product
10:24:04 <Jesin> in order to avoid stack overflow
10:24:05 <dcoutts> iago: e.g. it implies things like if you add a new file (i.e. all one hunk), then it will be fully in memory
10:24:07 <Saizan> in the cases where you know what the final length will be it'd be a huge win to have a function that just allocates a large enough chunk of memory from the start, and puts the chunks from the lazy bytestring into that lazily
10:24:19 <HugoDaniel> i got it working, thanks for the support
10:24:21 <Jesin> but GHC defined product as http://haskell.org/ghc/docs/latest/html/libraries/base-4.3.0.0/src/Data-List.html#product
10:24:23 <HugoDaniel> :)
10:24:25 <HugoDaniel> haskell rocks
10:24:33 <mrd> Jesin: it's a mistake from the original Report
10:24:34 <Jesin> does this avoid stack overflow?
10:24:36 <dcoutts> Saizan: yeah, we could do that using a builder
10:24:45 <Jesin> no, I meant the #else part
10:24:55 <Jesin> product l       = prod l 1
10:24:56 <Jesin>   where
10:24:58 <Jesin>     prod []     a = a
10:24:59 <Jesin>     prod (x:xs) a = prod xs (a*x)
10:25:02 <dcoutts> Jesin: Haskell98 does not have foldl'
10:25:46 <Jesin> yes, but this is in a version of GHC that uses Haskell2010
10:25:55 <dcoutts> it was not redefined in H2010
10:25:59 <Jesin> and furthermore this is a "fixed" version
10:26:13 <dcoutts> no, it's not "fixed" it's faithful to the spec
10:26:18 <Jesin> as in, it's in the #else clause of #ifdef USE_REPORT_PRELUDE
10:26:28 <dcoutts> different definitions, same function
10:26:48 <Jesin> same *results*, except possibly stack overflow
10:26:49 <Jesin> :p
10:26:51 <dcoutts> no
10:27:05 <Jesin> what is the point of using different definitions here, then?
10:27:18 <dcoutts> Jesin: if the #else part used foldl' or equivalent then there are examples where you could distinguish
10:27:36 <Jesin> well then why even HAVE a non-report version
10:27:36 <dcoutts> for slightly odd Num instances
10:28:17 <Jesin> also
10:28:22 <monochrom> eh? the #else code seems to be merely inlining foldl
10:28:27 <Jesin> #ifdef USE_REPORT_PRELUDE
10:28:29 <Jesin> and                     =  foldr (&&) True
10:28:31 <Jesin> #else
10:28:33 <Jesin> and []          =  True
10:28:34 <Jesin> and (x:xs)      =  x && and xs
10:28:35 <dcoutts> Jesin: in many cases one can implement it faster or with better code duplication or something, by using a definition different from the report
10:28:50 <dcoutts> monochrom: ghc used not to inline foldl
10:28:54 <Jesin> hmm, wait that actually does work, doesn't it
10:29:02 <aristid> dcoutts: but it can do so now, i hope?
10:29:10 <Jesin> I was wondering whether they would give different results for, for example
10:29:16 <Jesin> (True:True:False:True:undefined)
10:29:25 <dcoutts> aristid: ghc's definition of foldl was changed to allow it, yes
10:29:34 <dcoutts> aristid: ghc refuses to inline recursive functions
10:29:58 <aristid> dcoutts: how did they change it?
10:30:11 <monochrom> heh it's a bit more than inlining actually.
10:30:36 <dcoutts> aristid: factoring into non-recursive wrapper and recursive worker
10:30:44 <Jesin> foldl f z0 xs0 = lgo z0 xs0
10:30:46 <Jesin>              where
10:30:47 <Jesin>                 lgo z []     =  z
10:30:49 <Jesin>                 lgo z (x:xs) = lgo (f z x) xs
10:30:56 <Jesin> why not just
10:31:05 <Jesin> foldl f = lgo where [etc]
10:31:17 <aristid> Jesin: because then the recursion cannot be expressed
10:31:27 <Jesin> umm
10:31:29 <Jesin> yes it can?
10:31:33 <aristid> how?
10:31:52 <Jesin> foldl f = lgo
10:31:53 <Jesin>              where
10:31:55 <Jesin>                 lgo z []     =  z
10:31:56 <Jesin>                 lgo z (x:xs) = lgo (f z x) xs
10:32:27 <Jesin> in fact, isn't that inlined earlier?
10:32:51 <Jesin> (I have written a function that uses this sort of pattern before, it does work)
10:33:03 <dcoutts> it's known as the static argument transformation
10:33:10 <dcoutts> it's sometimes a win, sometimes a loss
10:33:18 <ksf> semantically, it's the same, practically it looks different in STG
10:33:43 <dcoutts> it can be a loss if it means allocating more closures
10:33:52 <Jesin> which it does in this case?
10:34:34 <dcoutts> Jesin: well, if you can inline foldl with a known function then it's fine
10:35:35 <Jesin> can't you do that in almost every case?
10:35:48 <Jesin> I mean, how often is foldl used with no arguments?
10:35:50 <Jesin> :p
10:36:18 * ksf long ago decided that it's best to leave the prelude to the ghc authors
10:36:29 <ksf> they know what magic ghc does and doesn't do.
10:36:51 <dcoutts> Jesin: right, almost every case. It can be used with unknown args however, i.e. a function passed in as an arg.
10:37:04 <Jesin> yes, it *can*
10:37:09 <ksf> and while the report prelude is didactically excellent, it's apparrantly also dead slow.
10:37:13 <Jesin> but these are optimizations we're talking about
10:37:24 <dcoutts> Jesin: and that's why foldl is defined with a worker
10:37:55 <monochrom> are we done yet?
10:37:59 <dcoutts> Jesin: you're talking about changing the result of the function, not just the definition.
10:37:59 <ksf> http://www.haskell.org/haskellwiki/Worker_wrapper
10:38:08 <Jesin> wait, what
10:38:22 <Jesin> how does factoring out the extra args change the result?
10:38:52 <ksf> well, no actually I meant http://www.ittc.ku.edu/csdl/fpg/Research/WorkerWrapper
10:38:58 <dcoutts> Jesin: it doesn't but you want a version of product that uses a foldl'
10:39:16 <dcoutts> and  foldl (*) 1 /= foldl' (*) 1   for some Num instances
10:39:37 <ksf> ...for ones in which * isn't strict, to be precise.
10:39:58 <ksf> which, on the top of my head, are all except Natural
10:40:44 <remy_o> oin ##windows
10:42:10 <ocharles> Hmmm, another quick Parsec question. I have a parser for ":foo:bar:baz:" now, but I need to parse it at the end of a line, for example "This is some text :foo:bar:". I'm currently parsing the text part with "anyChar", which of course ends up consuming the tags at the end too
10:42:31 <ocharles> I can't use many1 (noneOf ":") though, because that would stop me using ':' within the text, which is valid
10:43:01 <ksf> ocharles, what you are looking for is called "try"
10:43:12 <ocharles> ksf: yes, that sounds right, but I can't see how back tracking helps here
10:43:22 <remy_o> or you could also use manyTill (...) (notFollowedBy ...)
10:43:41 <ocharles> remy_o: doesn't notFollowedBy consume input though?
10:44:00 <remy_o> you could use not followedBy $ try ...
10:44:02 <ksf> ocharles, it allows parsec to build the match starting at the end of the string.
10:44:18 <remy_o> but I think notFollowedBy has a try inside it
10:45:04 <remy_o> said the doc : "notFollowedBy [...] This parser does not consume any input"
10:45:09 <ksf> anyChar `notFollowedBy` foo $> foo is a good idea
10:45:21 <ocharles> hrm, I'm not quite following, but my haskellfu is weak :)
10:45:23 <ocharles> https://gist.github.com/826365 is what I have so far
10:45:34 <ksf> at least it's short and sweet. never mind performance, you're using parsec, after all.
10:45:45 * hackagebot uAgda 1.1.0.0 - A simplistic dependently-typed language with parametricity.  http://hackage.haskell.org/package/uAgda-1.1.0.0 (JeanPhilippeBernardy)
10:46:06 <ksf> ugh, tuples.
10:46:12 <ksf> and the monadic interface
10:46:29 <ocharles> I plan to move stuff into proper types later
10:46:35 <ksf> data Node = Int (Maybe String) String [String]
10:46:39 <ocharles> yes, I'm going to do that
10:46:41 <ocharles> one step at a time.
10:46:51 <ocharles> lets get it parsing first
10:47:20 <ksf> node = Node <$> (many1 (char '*') <$ many1 space) <*> optionMaby keyword <*> ...
10:47:45 <ocharles> right, I'll be getting onto refactoring like that later. but I don't see the need to start doing stuff like that when it doesn't even work yet
10:48:38 <ksf> well, you're not using any monad features so I'd argue you should've written it applicatively, in the first place...
10:48:41 <ksf> but I see your point.
10:48:44 <Twey> 190954 < ksf> data Node = Int (Maybe String) String [String]
10:48:46 <Twey> Wha'?
10:48:57 <ksf> well, almost.
10:49:18 <Twey> That's a strange type.
10:49:27 <ksf> add another "Node", in there.
10:49:40 <Twey> Ah, I see
10:51:31 <ksf> ...you don't want notFollowedBy
10:55:29 <ocharles> no, it seems like I want manyTill, and then to backtrack from the manyTill
10:55:53 <ksf> :t manyTill
10:55:53 <lambdabot> Not in scope: `manyTill'
10:55:57 <ksf> @hoogle manyTill
10:55:57 <lambdabot> Text.Parsec.Combinator manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
10:55:57 <lambdabot> Text.ParserCombinators.ReadP manyTill :: ReadP a -> ReadP end -> ReadP [a]
10:55:57 <lambdabot> Text.ParserCombinators.Parsec.Combinator manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
10:57:41 <byorgey> preflex: seen Cale
10:57:41 <preflex>  Cale was last seen on #haskell 4 hours, 13 minutes and 25 seconds ago, saying: Support both spellings *trollface*
10:57:41 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
10:58:22 <ksf> yep. or, even better, look at the source of manyTill and return both the list and the result of "end"
10:58:25 <dons> 735
10:58:29 <dons> huh. prob. a record!
10:58:29 <byorgey> @ask Cale is your "how to use monad transformers" article available anywhere?
10:58:29 <lambdabot> Consider it noted.
10:58:42 <byorgey> dons: =D
10:59:18 <byorgey> and amazingly, it's still a useful, friendly place
10:59:20 <ocharles> ksf: will do then
10:59:22 <byorgey> although a bit noisy at times =)
11:01:10 <dcoutts> hia dons 
11:01:33 <dons> strangely, not showing up in  http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
11:01:37 <dons> yo dcoutts 
11:01:42 <dcoutts> dons: the hackathon looked fun :-)
11:03:12 <djahandarie> dons, it's because the +s mode somehow got on the channel
11:03:41 <djahandarie> I think it was added on during a spam attack or something (don't ask me why)
11:04:52 <ksf> it's because the haskell cabal is a secret society, of course.
11:05:01 <dons> djahandarie: hmm
11:05:10 <dons> lets reverse the +s then
11:05:32 <djahandarie> Maybe we finally got sick of those people randomly stumbling in here because the word 'Programming' was in the topic and asking for Java help ;)
11:06:52 * hackagebot crypto-api 0.5 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.5 (ThomasDuBuisson)
11:07:13 <gwern> @quote fluffable
11:07:13 <lambdabot> gwern says: [regarding the naming of Monoids] we will call them CuteFluffableThings, since you can put more fluff into them, but no one would remove fluff from a cute thing
11:07:25 <aristid> preflex: seen Cale
11:07:25 <preflex>  Cale was last seen on #haskell 4 hours, 23 minutes and 9 seconds ago, saying: Support both spellings *trollface*
11:07:28 <ray> my favorite channel mode is +n
11:09:24 <Twey> -n can be amusing
11:09:47 <Twey> Confused the heck out of me the first time I saw someone talk in a channel to which they weren't joined
11:11:06 <revenantphx> ugh
11:11:12 <revenantphx> having some issues here with GHC 7
11:11:18 <revenantphx> (first ones I've had)
11:11:21 <revenantphx> https://gist.github.com/826399
11:11:28 <revenantphx> The "can't find ghci lib" is normal though.
11:11:36 <revenantphx> ghc-pkg check just says that, but ghci's able to find them.
11:17:58 <cdsmithus> So I'm ignorant about macintoshes... but I just tried to install the Haskell platform on a Mac, and ran into a problem.  Right before the installation step, the "Continue" button is disabled.  Any ideas?
11:18:43 <revenantphx> Hm?
11:18:53 <revenantphx> On which page?
11:19:00 <revenantphx> The "choose an installation destination" page?
11:19:03 <c_wraith> cdsmithus: actually, gcollins is the one who does the platform packaging for osx.  ask him about it :)
11:19:43 <cdsmithus> It's the page right after I chose "Install for All Users"... sorry I don't remember the details; but I don't have IRC at the school where I was doing the installation, and I just got home
11:19:54 <revenantphx> Oh hm.
11:20:03 <revenantphx> Well, I've never really had that issue.
11:20:12 <revenantphx> The installer's usually pretty straight forward :\
11:20:28 <revenantphx> Stupid cabal.
11:20:43 <cdsmithus> This is while installing GHC, by the way
11:23:53 <ulfdoz> Blau ist USB 3.0
11:23:58 <ulfdoz> ewin.
11:24:59 <seydar> ghc 7.0.1 took an hour for me to install on my macbook pro 2.4ghz
11:25:03 <seydar> it broke my balls
11:25:12 <seydar> had to carry my laptop open on the bus while it installed
11:25:48 <pastorn> seydar: ehm... you compiled from source?
11:26:43 <revenantphx> seydar: wtf?
11:26:50 <revenantphx> It took like 40 minutes for me, tops.
11:27:00 <revenantphx> I compiled it from source though.
11:27:08 <revenantphx> also
11:27:09 <revenantphx> https://gist.github.com/826399
11:27:10 <revenantphx> halp
11:27:11 <remy_o> maybe you chose wrong options
11:27:26 <revenantphx> THIS JUST IN
11:27:32 <revenantphx> THE GHC-PKG CONSTRAINT SOLVER KIND OF FAILS.
11:27:34 <revenantphx> >_>
11:27:34 <remy_o> it looks like it's looking for split-objects
11:27:52 <remy_o> and where did you find cabal-install ? it's not released
11:28:01 <revenantphx> what?
11:28:45 <revenantphx> http://darcs.haskell.org/cabal-install/
11:28:45 <Zao> That is, there's no released version of cabal-install that works with GHC7 yet. It's all just in trunk.
11:28:58 <Saizan> revenantphx: looks like that version of agda won't build with your version of ghc.
11:28:59 <revenantphx> Worked for me.
11:29:07 <Zao> revenantphx: Apparently it didn't.
11:29:25 <Zao> revenantphx: Or are you saying that you built it from source as well?
11:29:38 <dcoutts> revenantphx: the problem there is that agda requires base 4.2, but you've only got version 4.3 installed.
11:29:48 <Zao> In any way, I wouldn't be surprised if misc packages fail to build with 7.
11:29:51 <dcoutts> ie agda needs patching to work with ghc 7
11:29:54 <Zao> Many don't.
11:30:13 <Saizan> revenantphx: the darcs version of agda probably works on ghc 7
11:30:21 <revenantphx> dcoutts: but it says I have 4.2... derp
11:30:59 <revenantphx> oh, I guess I do have 4.3
11:31:02 <revenantphx> well, off to darcs then
11:31:04 <dcoutts> revenantphx: no it doesn't it says it cannot install 4.2.0.0, 4.2.0.1, 4.2.0.2 etc
11:31:08 <revenantphx> mm
11:31:12 <dcoutts> the error message about why the various versions of base were excluded is a bit misleading however
11:31:15 <revenantphx> where is the darcs repo?
11:31:20 <revenantphx> darcs.haskell?
11:31:58 <dcoutts> the real reason it cannot install any older version of base is because it requires an installed version, source versions are not ok (since base cannot actually be installed via cabal)
11:32:14 <revenantphx> Yeah, it fails with error "impossible" I think.
11:32:24 <dcoutts> if you try to install base itself, yes
11:32:52 <dcoutts> revenantphx: the source repo for agda you mean? see cabal info agda
11:33:08 <Saizan> http://www.cse.chalmers.se/~nad/repos/Agda/ <- until the one on c.h.o gets restored
11:33:15 <revenantphx> http://code.haskell.org/Agda/ ...
11:33:18 <revenantphx> not a repository
11:33:22 <revenantphx> ah, okay
11:33:33 <revenantphx> Saizan: is that one up to date though?
11:33:35 <dcoutts> ah, it's one of the repos that has been held back for checking
11:33:57 <Saizan> revenantphx: yep
11:35:45 <revenantphx> goddamn queued number keeps going up D:
11:35:55 <Saizan> dcoutts: should the maintainers contact the haskell.org team?
11:36:03 <revenantphx> "15 queued"? I meant 50.
11:36:13 <revenantphx> also, wtf is "danger_do_not_open_until.eps"
11:36:44 <dcoutts> Saizan: depends how desperate they are. We're going to set up a procedure for all users with accounts to get them reactivated.
11:36:58 <revenantphx> dcoutts: Saizan: what happened?
11:37:04 <dcoutts> Saizan: we can do some ad-hoc stuff, but that takes time away from doing it comprehensively
11:38:03 <Saizan> dcoutts: ah, ok, i think this other repo is fine then
11:38:30 <Saizan> revenantphx: c.h.o got hacked
11:38:35 <revenantphx> D:
11:38:41 <revenantphx> who would want to do that anyways.
11:38:55 <revenantphx> I blame Oracle.
11:38:57 <revenantphx> (and Java)
11:39:11 <Twey> Well that's not good publicity for Haskell, is it :þ
11:39:28 <revenantphx> cho isn't on happstack or anything is it?
11:39:43 <Saizan> no
11:39:49 <Saizan> just an old debian
11:39:49 <revenantphx> Yeah, so you can't blame haskell itself.
11:39:55 <revenantphx> Blame GNU then :D
11:40:05 <monochrom> no, blame "old"
11:40:07 <revenantphx> True.
11:40:09 <Twey> Ah, fair 'nough
11:40:18 <revenantphx> Can we have a world in which Fox News blames Oracle for everything?
11:40:22 <new2haskell> how can I use foldr and a list [1,2,3,4,5] to produce the list [ [1,2,3], [2,3,4], [3,4,5] ]?
11:40:22 <revenantphx> Just for once day?
11:40:28 <revenantphx> I feel like it'd be amusing.
11:40:37 <Twey> I'd be more likely to blame Debian — they patch everything to oblivion, so you can hardly blame the upstream :þ
11:40:42 <monochrom> I don't have enough Fox stocks to cause that.
11:40:44 <revenantphx> new2haskell: That's a bit vague.
11:40:51 <revenantphx> Should each list contain an element and the two after it,
11:40:59 <revenantphx> or an element and the two numbers greater than it by one?
11:40:59 <Twey> monochrom: You have Fox stocks?
11:41:04 <monochrom> I don't.
11:41:18 <Twey> (sounds a bit like a Dr. Seuss invention…)
11:41:35 <monochrom> {0} ⊆ "not enough"
11:41:48 <new2haskell> @revenantphx: the final list contain all 3-gram of the given list
11:41:48 <lambdabot> Unknown command, try @list
11:42:07 <tswett> new2haskell: why do you want to use foldr to do that?
11:42:08 <new2haskell> revenantphx: the final list contain all 3-gram of the given list
11:42:14 <revenantphx> yeah, I see that now.
11:42:29 <revenantphx> I think I have a vague idea, I'll try it out.
11:42:39 <new2haskell> tswett: I don't know. I just have a feeling that fold would do the trick
11:42:43 * tswett nods.
11:43:16 <revenantphx> new2haskell: I think you're right.
11:43:19 <revenantphx> I know how to do it in my head.
11:43:48 <revenantphx> The only issue I see is that a fold can't look ahead or behind in the list,
11:43:50 <tswett> new2haskell: well, you could just define it recursively.  What do you want the function to return for a list of length less than 3?  What do you want to do with each element of the list before that?
11:43:57 <remy_o> @pl \l -> let f (a:b:c:ls) = [a,b,c]:(f ls) in f l
11:44:00 <lambdabot> fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip (flip . ((flip . (((.) . (:)) .)
11:44:00 <lambdabot> ) .) . (. ((. return) . (:))) . (.) . (:)))
11:44:01 <revenantphx> so the only "state" you have is the accumulator itself.
11:44:04 <remy_o> lol
11:44:13 <revenantphx> g2g
11:44:18 <hpc> remy_o: damn, well done
11:44:45 <tswett> > (\l -> let f (a:b:c:ls) = [a,b,c]:(f ls)) in f [1,2,3,4,5]
11:44:46 <lambdabot>   <no location info>: parse error on input `)'
11:44:50 <new2haskell> tswett: the list will always be > 3
11:45:12 <remy_o> > (\l -> let f (a:b:c:ls) = [a,b,c]:(f ls))  [1,2,3,4,5]
11:45:13 <lambdabot>   <no location info>: parse error on input `)'
11:45:24 <remy_o> > (\l -> let f (a:b:c:ls) = [a,b,c]:(f ls) in  f l )  [1,2,3,4,5]
11:45:25 <lambdabot>   [[1,2,3]*Exception: <interactive>:3:11-39: Non-exhaustive patterns in funct...
11:45:32 <remy_o> yes I cheated a bit
11:45:38 <tswett> new2haskell: yes, but the way Haskell works is that you state how to solve a big problem in terms of smaller problems.
11:46:07 <tswett> new2haskell: if you want to perform your operation on [1,2,3,4,5], it will help if you perform it on [2,3,4,5]; and if you want to perform it on [2,3,4,5]; it will be useful to perform it on [3,4,5].
11:46:12 <xplat> 21:14 < dankna> look at it this way.  Haskell is better for many purposes than  C, Perl, and several other ancient languages.  it doesn't get  away from the problem of legacy code, no, but nothing yet does.
11:46:12 <lambdabot> xplat: You have 4 new messages. '/msg lambdabot @messages' to read them.
11:46:16 <remy_o> new2haskell: another way to succeed is to think by pattern matching
11:46:21 <tswett> new2haskell: because then you're breaking the problem down into smaller and smaller ones.
11:46:34 <tswett> new2haskell: eventually, though, you'll get down to [4,5].  What do you want to do in that case?
11:47:02 <new2haskell> tswett: then the [4,5, 0]
11:47:06 <xplat> the problem with a language that actually supports reuse is you get serious migration issues with backwards-incompatible changes in a record low number of man-years
11:47:08 <remy_o> > (\l -> let f (a:b:c:ls) = [a,b,c]:(f ls) ; f _ = [] in  f l )  [1,2,3,4,5]
11:47:08 <lambdabot>   [[1,2,3]]
11:47:25 <remy_o> > (\l -> let f (a:b:c:ls) = [a,b,c]:(f b:c:ls) ; f _ = [] in  f l )  [1,2,3,4,5]
11:47:26 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
11:47:31 <xplat> of course there's less places to fix, too, so it's probably an even trade
11:47:32 <remy_o> > (\l -> let f (a:b:c:ls) = [a,b,c]:(f $ b:c:ls) ; f _ = [] in  f l )  [1,2,3,4,5]
11:47:33 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
11:47:42 <tswett> new2haskell: if that's how the function behaves for [4,5], does that help it behave correctly for [3,4,5]?
11:47:46 <new2haskell> remy_o: I want abc, bcd, cde, not abc, def ...
11:48:42 <tswett> new2haskell: your function outputs triplets of elements until it runs out of elements.  So, when it runs out of elements, you want it to stop outputting triplets.
11:48:43 <remy_o> @pl \l -> let f (a:b:c:ls) = [a,b,c]:(f $ b:c:ls) ; f _ = [] in  f l
11:48:45 <lambdabot> ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . ap (ap . (liftM2 ((.) . (:)) .) . (. ((. return) . (:))) . (.) . (:)) ((. ((. (:)) . (.) . (:))) . (.) . (.)) . head)
11:48:45 <lambdabot>  tail
11:48:59 <hpc> @quote aztec
11:48:59 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
11:49:40 <new2haskell> i think remy_o function did it
11:49:49 <tswett> new2haskell: indeed, I think it did.
11:49:58 <new2haskell> thanks all
11:50:24 <pastorn> remy_o: that look like a task for iterate
11:50:48 <navaati> wow, what did lambdabot here oO
11:50:48 <remy_o> but as said, \l -> zip l (tail l) (tail $ tail l ) look better
11:51:04 <remy_o> @pl \l -> zip3 l (tail l) (tail $ tail l) 
11:51:04 <lambdabot> ap (ap zip3 tail) (tail . tail)
11:51:15 <navaati> :t ap
11:51:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:51:37 <hpc> ap = (<*>)
11:52:04 <hpc> the latter being the more popular synonym
11:52:38 <pastorn> remy_o: takeWhile ((3==) . length) . map (take 3) . iterate (drop 1)
11:53:18 <pastorn> > takeWhile ((3==) . length) . map (take 3) . iterate (drop 1) $ "1234567890abcd"
11:53:19 <lambdabot>   ["123","234","345","456","567","678","789","890","90a","0ab","abc","bcd"]
11:53:56 <remy_o> isn't this quadratic in the length of the list ? 
11:54:09 <MHD0> does a Handle close when it is garbage collected?
11:54:14 <remy_o> hum, maybe not
11:54:28 <hpc> MHD0: it should, theoretically
11:54:39 <hpc> MHD0: theoretically, you have already closed it before then
11:54:44 <hpc> :P
11:54:57 <MHD0> hpc: Why, thank you for that </sarcasm>
11:55:05 <pastorn> hpc: well, one could suddenly start to ignore a handle...
11:55:12 <pastorn> hoping it gets collected
11:55:22 <hpc> this calls for an experiment!
11:55:26 <MHD0> hpc: For real though, I am using the NOINLINE/unsafePerformIO hack for some debugging...
11:55:33 <hpc> oh, eek
11:56:04 <monochrom> don't wait for garbage collection
11:56:22 <MHD0> monchrom: No, let me rephrase
11:56:29 <pastorn> take command! make it collect!
11:56:45 <MHD0> monochrom: If my program ends without me closing a handle, does it close?
11:57:06 <hpc> command : mmand :: collect : llect?
11:57:11 <MHD0> pastorn: <facepalm />
11:57:24 <monochrom> that one is tricky. closed, but some buffer not flushed.
11:57:30 <pastorn> well, there's a performGC function
11:57:31 <hpc> MHD0: when put that way, it definitely will
11:57:46 <hpc> that's the OS doing the closing afaik though
11:57:57 <hpc> if that's good enough, yay
11:58:02 <rumbold1> when im running ghc on a 64bit windows and dont explicitly tell it anything, is it making 32bit or 64bit programs?
11:58:07 <MHD0> So, if I set it to line buffering, and all my calls are putStrLn i will have no problem?
11:58:22 <hpc> MHD0: indeed, no problem
11:58:38 <MHD0> An is there something equivalent to the C/C++ on exit utility?
11:59:01 <bos> MHD0: your file should be completely written out
11:59:08 <hpc> MHD0: would handling sigterm count?
11:59:41 <MHD0> Nah, I was just making sure.
12:00:05 <MHD0> It's like 10 lines of code for the entire utility, I was just thinking if it was safe to remove "debugEnd"
12:00:20 <cizra> Hi. When is unsafePerformIO really unsafe to use? For example, I want to match a string against a regex-pcre. This stuff happens in IO monad. Can I stuff compiling and executing the regex into one IO action and just unsafePerformIO it?
12:00:27 <cizra> I just tested it, and it sure seems to work fine.
12:00:54 <MHD0> cizra: unsafePerformIO should be avoided like the plague
12:00:57 <hpc> why would a regex be compiled in IO...
12:01:05 <MHD0> cizra: Use another monad
12:01:14 <parcs> @hoogle (Eq a) => [a] -> [a] -> Bool
12:01:14 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
12:01:14 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
12:01:14 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
12:01:25 <MHD0> cizra: Or change your code
12:01:32 <cizra> MHD0: I've seen it recommended in FFI
12:01:39 <cizra> hpc: Dunno, ask regex-pcre authors
12:01:41 <kmc> yes, that's where it's originally from
12:01:46 <bos> cizra: consider using pcre-light instead
12:01:49 <sproingie> it's not unsafe as in "causes segfaults" randomly, it's unsafe in that it could error out and break things that are pure
12:01:53 <cizra> bos: hmm!
12:02:02 <sproingie> to say nothing of it breaking purity in the first place
12:02:07 <bos> there's no good reason for regex code to be in IO
12:02:08 <kmc> actually, it can cause segfaults randomly, if you combine it with certain funny uses of polymorphic IORefs
12:02:24 <cizra> Okay, big thanks!
12:02:30 <sproingie> well yah, but that's not a general case
12:02:33 <MHD0> kmc: Lol
12:02:34 <kmc> right
12:02:35 <monochrom> unsafePerformIO is unsafe iff it breaks referential transparency.
12:02:41 <bos> also, the regex-pcre API is insanely overcomplicated
12:02:48 <hpc> for extra fun, let unsafePerformIO = unsafeCoerce :: IO a -> a
12:02:52 <kmc> regex in Haskell is generally a trainwreck
12:02:54 <cizra> bos: Truly!
12:03:00 <kmc> hpc, haha, that's... not likely to work
12:03:01 <kmc> in GHC
12:03:04 <hpc> :D
12:03:11 <MHD0> cizra: Forget about regexes, look into something like "Attoparsec"
12:03:12 <monochrom> unfortunately I don't know enough of regex-pcre to say whether your use breaks.
12:03:31 <cizra> MHD0: I just need to get dates and stuff out of strings. Whatever the package.
12:03:49 <kmc> the most legit use case of unsafePerformIO is that you're importing side-effectful C functions but exposing an overall combination of them which is side-effect-free and deterministic
12:04:01 <rumbold1> guys, check out my problem please: http://stackoverflow.com/questions/4991093/trying-to-install-image-codec-devil-under-windows-needs-pthread-and-il-cant-ge (read edit3)
12:04:08 <kmc> (for single pure C functions, no need; just omit the "IO" from the foreign import type)
12:04:40 <kmc> some other uses are "morally equivalent"
12:04:51 <tswett> @unpl ap zip tail
12:04:51 <lambdabot> (zip >>= \ b -> tail >>= \ a -> return (b a))
12:05:03 <kmc> rather than importing low-level C you might be importing low-level Haskell which uses Foreign, etc
12:05:35 <MHD0> cizra: Attoparsec parses bytestrings, and is exceptionally good for data-mining
12:05:57 <MHD0> cizra: If speed is not a problem look into regular, vanilla "Parsec"
12:05:59 * tswett performs some cargo cult Haskell:
12:06:00 <tswett> @type (zip3 >>= \ c -> (tail . tail) >>= \ b -> tail >>= \ a -> return (c b a))
12:06:01 <lambdabot> forall a. [a] -> [(a, a, a)]
12:06:09 <tswett> Yay.
12:06:11 <hpc> tswett: lol
12:06:22 <tswett> @pl (zip >>= \ b -> tail >>= \ a -> return (b a))
12:06:22 <lambdabot> (tail >>=) . (return .) =<< zip
12:06:23 <monochrom> but what does it do?
12:06:42 <tswett> > (zip3 >>= \ c -> (tail . tail) >>= \ b -> tail >>= \ a -> return (c b a)) "War! What is it good for?"
12:06:43 <lambdabot>   [('W','r','a'),('a','!','r'),('r',' ','!'),('!','W',' '),(' ','h','W'),('W'...
12:06:49 <cizra> MHD0: Big thanks. I think I've done something some time ago with Parsec, so I think I'll manage.
12:06:51 <tswett> Yay.  :P
12:07:10 <monochrom> most bizarre
12:07:17 <hpc> tswett: you forgot "HUH!"
12:07:18 <Jesin> Prelude> Unsafe.Coerce.unsafeCoerce (return "blah" :: IO String) :: String
12:07:19 <Jesin> ""
12:07:40 <tswett> > (zip3 >>= \ c -> tail >>= \ b -> (tail . tail) >>= \ a -> return (c b a)) "War! HUH! What is it good for?"
12:07:41 <lambdabot>   [('W','a','r'),('a','r','!'),('r','!',' '),('!',' ','H'),(' ','H','U'),('H'...
12:07:48 <hpc> :D
12:08:14 <monochrom> also try Unsafe.Coerce.unsafeCoerce (return 34 :: IO Int) :: String  some time
12:08:26 <Jesin> ap zip tail = zip >>= (`fmap` tail)
12:08:54 <tswett> monochrom: it seems to be empty.
12:08:56 <hpc> monochrom: i just got "" again
12:09:04 <Jesin> @src (->) (>>=)
12:09:04 <lambdabot> f >>= k = \ r -> k (f r) r
12:09:13 <monochrom> you see it has nothing to do with "IO String".
12:09:20 <Jesin> @unpl (`fmap` tail)
12:09:20 <lambdabot> (\ a -> fmap a tail)
12:09:40 <Jesin> @unpl (\ a -> (.) a tail)
12:09:41 <lambdabot> (\ a d -> a (tail d))
12:09:52 <Kaidelong> @hoogle unsafeCoerce
12:09:52 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:09:53 <hpc> ghci> Unsafe.Coerce.unsafeCoerce (return "five" :: IO String) :: Int
12:09:55 <hpc> 16777480
12:10:27 <Jesin> @unpl (\ f k r -> k (f r) r) zip (\ a d -> a (tail d))
12:10:27 <lambdabot> (\ r -> zip r (tail r))
12:10:29 <Kaidelong> hpc: is the Int uniquely determined by the string?
12:10:32 <hpc> as :: Integer, i get a fault
12:10:33 <Kaidelong> if so, that could be useful
12:10:38 <monochrom> also try Unsafe.Coerce.unsafeCoerce (return undefined :: IO (whatever you like here)) :: String
12:10:41 <hpc> Kaidelong: no, it's the same for all IO objects it seems
12:10:48 <Kaidelong> okaay
12:10:56 <Jesin> > ap zip tail [1..5]
12:10:56 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
12:11:11 <Jesin> > (\ r -> zip r (tail r)) [1..5]
12:11:11 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
12:11:18 <Kaidelong> zip`ap`tail
12:11:38 <Jesin> @src (->) (<*>)
12:11:38 <lambdabot> (<*>) f g x = f x (g x)
12:11:43 <Jesin> wow, that would've been a shortcut
12:11:48 <tswett> Hey, Just Nothing is different every time.
12:11:52 <Jesin> ?
12:12:07 <monochrom> "different" = ?
12:12:33 <tswett> Unsafe.Coerce.unsafeCoerce (Just Nothing) :: Int evaluates differently every time.
12:12:45 <monochrom> interesting
12:12:54 <remy_o> maybe because it's a pointer
12:13:05 <tswett> Apparently, read :: String -> Int is the same value as IO actions, but tail is something else.
12:13:15 <monochrom> ah, yes, pointer
12:13:17 <hpc> this is fun
12:13:17 <tswett> tail is 4, in fact, the same as Just.
12:13:31 <tswett> I'm guessing 4 is not a pointer.  :)
12:13:43 <tswett> And I'm guessing there isn't a single data structure serving as both tail and Just.  :P
12:13:58 <remy_o> tail is zero here
12:14:01 <tswett> head is also 4.  :P
12:14:02 <remy_o> and map is 280253865984
12:14:11 <hpc> on mine, tail == Just == 2
12:14:13 <monochrom> haha
12:14:32 <monochrom> soon we will spot UFOs too
12:14:43 <hpc> but coercing unsafeCoerce yields 262
12:15:08 <hpc> (:) == 0
12:15:17 <tswett> 1 is 1, 5 is 5, and 1000000000000000000000000000000 is different every time.
12:15:24 <tswett> hpc has found the root of Haskell!
12:16:09 <hpc> coercing bottom yields bottom :(
12:16:31 <monochrom> they told you. it's bottoms all the way down...
12:16:44 <Jesin> Unsafe.Coerce.unsafeCoerce undefined :: Int
12:16:45 <Jesin> *** Exception: Prelude.undefined
12:16:51 <Philippa> hpc: bottom's the fixpoint of coercion? There's a shock :p
12:16:58 <hpc> Philippa: shush you
12:17:14 <remy_o> bottom mapping to bottom is an axiom of Haskell isn't it ? 
12:17:15 <Jesin> a fixpoint of coercion, anyway
12:17:31 <Egbert9e9> guys, there's this bit on lyah, it says on the calculator's screen: "5318008"
12:17:35 <tswett> let treacherous :: a -> a; treacherous x = Unsafe.Coerce.unsafeCoerce (Unsafe.Coerce.unsafeCoerce x :: Int) in treacherous (:) 1 [2,3]
12:17:54 <tswett> remy_o: yes, but so is the absence of unsafePerformIO.
12:17:55 <Jesin> > fix unsafeCoerce
12:17:56 <lambdabot>   Not in scope: `unsafeCoerce'
12:17:58 <hpc> tswett: s/treacherous/id/ for great good
12:18:01 <Jesin> > fix Unsafe.Coerce.unsafeCoerce
12:18:01 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
12:18:02 <Philippa> remy_o: no actually, it specifically isn't
12:18:06 <Egbert9e9> it made me lol
12:18:15 <Philippa> avoiding that's haskell's original raison d'etre
12:18:30 <Jesin> lol, wow
12:18:31 <Jesin> > let treacherous :: a -> a; treacherous x = Unsafe.Coerce.unsafeCoerce (Unsafe.Coerce.unsafeCoerce x :: Int) in treacherous (:) 1 [2,3]
12:18:32 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'Not in scope: `Unsafe.Coerce.unsa...
12:18:34 <Jesin> eh
12:18:36 <Jesin> =/
12:18:57 <hpc> @let unsafeCoerce = fix ($)
12:18:57 <Philippa> > (const 1) undefined
12:18:58 <lambdabot>  Defined.
12:18:58 <lambdabot>   1
12:19:02 <hpc> :t unsafeCoerce
12:19:03 <lambdabot> forall a b. a -> b
12:19:04 <siracusa> Any ideas what might cause `internal error: evacuate: strange closure type' errors? I'm getting this in GHCi 6.10.4 when loading modules every now and then.
12:19:06 <Jesin> Prelude> let {treacherous :: a -> a; treacherous x = Unsafe.Coerce.unsafeCoerce (Unsafe.Coerce.unsafeCoerce x :: Int)} in treacherous (:) 1 [2,3]
12:19:07 <Jesin> [1,2,3]
12:19:20 <tswett> treacherous seems to always return what it got.
12:19:47 <Jesin> wow
12:20:22 <Jesin> Prelude> let {treacherous :: a -> a; treacherous x = Unsafe.Coerce.unsafeCoerce (Unsafe.Coerce.unsafeCoerce x :: Int)} in ($!) (flip ($)) treacherous (:) 1 [2,3]
12:20:24 <Jesin> [1,2,3]
12:20:30 <Jesin> wait
12:20:32 <Jesin> nvm
12:20:46 <Jesin> I didn't run the last one yet
12:20:54 <Jesin> sorry, type error
12:22:10 <Jesin> :t ($!)
12:22:11 <lambdabot> forall a b. (a -> b) -> a -> b
12:22:16 <Egbert9e9> :t (.)
12:22:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:22:33 <Egbert9e9> aww, i can't apply (.) to itself
12:22:39 <Jesin> yes you can
12:22:42 <Egbert9e9> O_O
12:22:50 <Egbert9e9> :t (.)(.)
12:22:51 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
12:22:53 <Jesin> @src (.)
12:22:53 <lambdabot> (f . g) x = f (g x)
12:22:53 <lambdabot> NB: In lambdabot,  (.) = fmap
12:22:54 <Egbert9e9> WOW
12:22:59 <Egbert9e9> i see
12:23:15 <Egbert9e9> > "hello channel"
12:23:15 <Jesin> that's because
12:23:16 <lambdabot>   "hello channel"
12:23:29 <Jesin> instance Functor ((->) r) where fmap = (.)
12:23:45 <Egbert9e9> > let S318008 = (.)(.)
12:23:46 <lambdabot>   not an expression: `let S318008 = (.)(.)'
12:23:49 <Egbert9e9> dang
12:23:59 <Jesin> @let S318008 = (.)(.)
12:24:00 <lambdabot>  <local>:5:0: Not in scope: data constructor `S318008'
12:24:00 <tswett> @let S318008 = (.)(.)
12:24:01 <lambdabot>  <local>:5:0: Not in scope: data constructor `S318008'
12:24:05 <kmc> tswett, in GHC Haskell, 4 is internally a pointer
12:24:06 <Jesin> @let s318008 = (.)(.)
12:24:07 <lambdabot>  Defined.
12:24:12 <Jesin> you need to lowercase it
12:24:21 <Egbert9e9> ohoh, that's a type name
12:24:36 <tswett> It looks like coercing an Integer to an Int and back fails if you wait in between.  :P
12:24:49 <Jesin> :t fmap fmap
12:24:50 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
12:24:51 <Egbert9e9> Jesin, thanks :-D
12:24:54 <kmc> tswett, to a heap-allocated cell that consists of: [info pointer for GHC.Num.Int] [unboxed value 4#]
12:24:57 <Jesin> of course, the real type of (.)(.)
12:24:58 <Jesin> is
12:25:00 <Jesin> (.)(.) :: (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
12:25:07 <kmc> tswett, it's important for polymorphism to work that all types have uniform representation
12:25:21 <kmc> which in the case of GHC is "pointer to heap-allocated cell with an info ptr as the first word"
12:25:27 <kmc> @src Int
12:25:27 <lambdabot> data Int = I# Int#
12:25:28 <kmc> @src Integer
12:25:28 <lambdabot> data Integer = S# Int#
12:25:29 <lambdabot>              | J# Int# ByteArray#
12:25:31 <Egbert9e9> thanks, i'm just not here right now
12:25:50 <kmc> so unsafeCoerce between Int and Integer is somewhat likely to work for small numbers
12:25:55 <Egbert9e9> just wanted to write obsceneties in haskell :-p
12:26:02 <kmc> because they both have a first constructor with an Int# field
12:26:13 <kmc> but who knows what optimizations get in your way
12:26:22 <tswett> Prelude Unsafe.Coerce> unsafeCoerce x :: Int
12:26:22 <tswett> 33751207
12:26:22 <tswett> Prelude Unsafe.Coerce> unsafeCoerce (33751207 :: Int) :: Integer
12:26:22 <tswett> 33751207
12:26:22 <tswett> Prelude Unsafe.Coerce> unsafeCoerce (unsafeCoerce x :: Int) :: Integer
12:26:24 <tswett> 50000000000000
12:26:36 <tswett> ¿Por queeeeeeeéeeeeeeeeeeeee?
12:26:41 <kmc> how did you define x?
12:26:54 <tswett> kmc: let x = 50000000000000 :: Integer
12:27:00 <kmc> well that's probably bigger than Int
12:27:03 <kmc> so the result is just garbage
12:27:07 <hpc> tswett: rewrite rules!
12:27:18 <tswett> Rewrite rules?
12:27:24 <kmc> you're coercing a value which uses the second constructor to a type which has no second constructor
12:27:44 <hpc> @src Integer
12:27:44 <lambdabot> data Integer = S# Int#
12:27:44 <lambdabot>              | J# Int# ByteArray#
12:28:02 <hpc> @src Int
12:28:02 <lambdabot> data Int = I# Int#
12:28:09 <tswett> kmc: 33751207 sometimes coerces to itself and sometimes to 50000000000000.
12:28:26 <tswett> Hm, what does the first Int# in J# represent?  The length of the ByteArray#?
12:28:41 <NemesisD> hi all. for some reason i get an error with the GHCi runtime linker: "I found duplicate definition for symbol __hscore_localtime_r" in the old-time library. the ghc faq says to use the -x flag with ld, but i'm not calling ld directly anywhere
12:28:42 <dolio> I'm surprised that 'unsafeCoerce x :: Int' doesn't crash.
12:28:45 <hpc> tswett: probably, since the array is unboxed
12:28:55 <hpc> @src ByteString
12:28:55 <lambdabot> Source not found. Maybe you made a typo?
12:29:00 <hpc> @src ByteArray
12:29:00 <lambdabot> Source not found. My mind is going. I can feel it.
12:29:34 <hpc> NemesisD: ghc can send flags to ld, i think
12:29:41 <hpc> the man should explain more
12:30:58 <dolio> Actually, perhaps I'm not.
12:31:30 <NemesisD> hpc: ill check into it. its very odd that this happened out of nowhere and only on my machine
12:41:04 <Younder> One of the most annoying features of UBUNTU is that it takes5 minutes to go into screen save mode. How to I increase it? (To say 20 minutes)
12:41:27 <mrd> I think you have your channels mixed up.
12:41:53 <Younder> sorry
12:42:39 <augur> anyone know any from-lithuania lithuanians?
12:42:47 <keep_learning> http://hpaste.org/43989/baby_step_giant_step
12:42:50 <keep_learning> hello all 
12:43:04 <keep_learning> i am trying to use Data.IntMap 
12:43:21 <keep_learning> but getting some compilation error which i am not able to correct 
12:43:43 <keep_learning> actually it my first time encounter with Data.IntMap 
12:43:45 <Lemmih> Younder: System->Preferences->Screensaver.
12:44:02 <keep_learning> so could any one please have a look on my code 
12:45:01 <Younder> Yeah, I've fixed it.
12:45:20 <kmc> ghc --make
12:45:27 * kmc puts $5 on it
12:45:32 <mrd> keep_learning: just as a side note, there isn't a shortage of space characters.  feel free to insert them to make code easier to read.
12:46:09 <keep_learning> mrd, sure from next time i will keep in mind 
12:46:24 <mrd> keep_learning: it would also help if you put the error on hpaste too
12:46:35 <Younder> Lemmih, Thanks anyway.
12:46:40 <keep_learning> mrd, sure 
12:46:47 <hpc> mrd: you never know; they thought we would never hit peak oil too
12:47:35 * mrd hugs his spacebar
12:47:39 <kmc> i see my ancestors spend with careless abandon, assuming eternal supply
12:47:48 <keep_learning> http://hpaste.org/43990/baby_step_giant_step_annotati
12:48:20 <mrd> keep_learning: Ints aren't Integers
12:48:28 <Younder> kmc: The current economic system is based on growth.
12:48:37 <keep_learning> mrd, k
12:48:52 <Younder> kmc: How could it be otherwise?
12:48:55 <mrd> keep_learning: either you need to convert using "fromIntegral" or switch to using Ints.  obvious you must watch out for overflow.
12:48:55 <keep_learning> mrd, i think i paste errors on my previous code 
12:49:15 <keep_learning> mrd, k
12:50:09 <Younder> kmc: Now you find a solution to THAT and it might make a difference.
12:51:09 <thamster> anybody have trouble installing haskell-platform via macports using x86_64 kernel?
12:53:55 <Younder> kmc; I'll give you a hint. Socialism and derivatives
12:54:18 <dolio> Here's another hint: this is off topic.
12:54:31 <monochrom> haha
12:54:43 <keep_learning> mrd, thank you 
12:54:56 <keep_learning> mrd, its working now :)
12:55:07 <mrd> good to hear
12:55:31 <keep_learning> mrd, could you tell me if i should go for IntMap aur HashMap for this algorithm 
12:55:48 <keep_learning> mrd, http://en.wikipedia.org/wiki/Baby-step_giant-step
12:56:08 <keep_learning> this article says that Hash is fine 
12:56:22 <keep_learning> but haskell HashMap is slow 
12:56:40 <mrd> IntMap is nice.  If your keys always fit in an Int, then use it.
12:57:07 <gwern> 'Oh, and if you’d like to work for us, you should probably be sending me an email. No, I’m not going to list the address here on this blog post. If you can’t figure it out, I don’t want to hear from you <grin>'
12:57:32 <monochrom> is it easy to figure out?
12:58:37 <gwern> I dunno. that's what I'm asking
12:58:41 <gwern> whois seems too easy
12:59:32 <Younder> That would just show freenode .net
12:59:42 <monochrom> google search "email address of <his/her name>"
12:59:52 <Younder> Lets's to a tracerote
13:00:18 <monochrom> @google haskell monochrom
13:00:19 <lambdabot> http://ircarchive.info/haskell/2007/2/23/1.html
13:00:20 <lambdabot> Title: haskell monochrom: and the latter has the benefit of actually being useful in a  ...
13:00:25 <Younder> s/sote/route
13:00:26 <gwern> Younder: it's a blog post, not a irc user
13:01:08 <monochrom> haha nice hit
13:01:13 <Younder> makes no difference, he has to access it doesn't he
13:01:41 <gwern> monochrom: it'd be kind of insulting if only the former had the benefit of actually being useful
13:01:42 <monochrom> but somewhere on the blog has his/her email address; or the blog url hints at his/her email address
13:02:07 <gwern> monochrom: fine, you look: http://changelog.complete.org/archives/6119-how-do-you-hire-programmers-and-sysadmins-how-should-employers-evaluate-you/
13:02:18 <Younder> phony gmail shit
13:02:30 <gwern> oh sure you can cheat and look at http://changelog.complete.org/about
13:02:51 <monochrom> I think the intention is too look at "about"
13:02:59 <gwern> no, that's way too easy
13:03:12 <monochrom> how do you know?
13:03:16 <Younder> Not all users are as true and blue as you and me
13:03:35 <gwern> monochrom: I don't, I just want it to be a little more challenging that that
13:04:04 <aavogt> preflex seen CosmicRay
13:04:05 <preflex>  CosmicRay was last seen on #haskell 59 days, 6 hours, 51 minutes and 18 seconds ago, saying: the right people?
13:04:42 <monochrom> there are multiple references to "jgoerzen" on that blog page in side panes etc.
13:05:41 <monochrom> they are twitter links. so I decide to stalk jgoerzen on twitter
13:06:01 <aavogt> they call it 'follow'
13:06:25 <Younder> I call it hate (twitter) ;)
13:06:35 <monochrom> doesn't give an email address. well, silly me, twitter doesn't give out email addresses like that
13:06:54 <schwadri> hey has anyone experience with ffi?
13:07:01 <Younder> No hacker are you
13:08:10 <monochrom> there also exists "sequence.complete.org" which seems unrelated
13:08:58 <monochrom> ah, "http://complete.org/" states John Goerzen runs it.
13:09:00 <schwadri> i am trying to import a c function that returns a struct by value, but i cannot figure out how i can choose the right return type in haskell. any suggestions?
13:09:45 <Younder> let it tell you (if you are using GHC)
13:09:49 <djahandarie> gwern, you ought to make your content pages have a max-width, its hard to read your site with big monitors
13:11:29 <monochrom> gandi.net does not seem to be run by him. I would not think any "blah@contact.gandi.net" would reach him.
13:11:57 <sipa> schwadri: i believe many c compilers turn a struct returned by value into a copy operation + return by reference actually
13:12:17 <monochrom> oh, maybe it would, but not the only way and not the only correct answer
13:12:42 <Younder> No that is never the case
13:12:47 <ousado> c compilers do not return structs by value
13:13:08 <Younder> They return a pointer
13:13:26 <ousado> unless they're equal to some primitive
13:13:28 <monochrom> djahandarie: IIRC lispy would complain about the opposite. (he did to my page)
13:13:45 <schwadri> so i should say something like "foreign import ccall my_func :: Ptr MyStruct" ?
13:14:01 <monochrom> he said my page (I set a width) wastes his screen space with blank space
13:14:39 <monochrom> my only uncertainty is whether it was lispy or someone else. someone here complained.
13:15:04 <Younder> Vaues in C are a problem. Are they static and need to be copied. Dynamic and need to be freed. I don't know. Hopefully the documentation of thet functin helps
13:15:22 <schwadri> i wrote the function myself
13:16:09 <sipa> change it into one that takes a pointer to a struct, and overwrites the data in there
13:16:14 <schwadri> its quite simple: "struct x { unsigned short a, b; }; struct x my_func() { struct x r = {0, 0}; return r; }"
13:16:15 <sipa> instead of returning a struct
13:16:22 <lispy> monochrom: what do I complain about?
13:16:27 <djahandarie> monochrom, I'm sure no one would argue for a full screen of useless stuff compared to half a screen of useful stuff ;)
13:16:40 <lispy> oh yeah, max width of text is bad
13:16:48 <lispy> But, I doubt I was the one that complained?
13:17:47 <ousado> schwadri: is that the actual implementation?
13:17:50 <lispy> I kind of like 66 characters per line a la latex, but I can usually get that on the client side
13:18:15 <djahandarie> lispy, it's kind of a problem when you get >300 characters a line because of a big screen
13:18:15 <schwadri> ousado: yes
13:18:51 <ousado> schwadri: you know that the struct is stack allocated, right?
13:19:01 <Younder> I only use half of my 22 inch W screen for output
13:19:12 <ousado> it'll be gone once you return
13:19:22 <Younder> The rest of input (an editor)
13:19:43 <schwadri> ousado: hm. so this actually is wrong c code?
13:19:45 <lispy> djahandarie: So make the window narrower or use one of those client side CSS hacks :)
13:20:00 <ousado> schwadri: well, it's a common source of errors
13:20:02 <monochrom> I admit uncertainty of who complained about mine. But I am happy that people from both sides of the debate are easy to find. :)
13:20:11 <lispy> djahandarie: I use XMonad and the way it splits screens is perfect for webpages on my 22inch monitor
13:20:13 <schwadri> ousado: i thought it will get copied
13:20:48 <lispy> djahandarie: and back before chrome I had some thing in FF (a bookmarklet) that would make webpages more readable
13:21:03 <monochrom> Also, I have removed my width setting (of my content pane). I set a small width of my table-of-content pane instead.
13:21:07 <ousado> schwadri: nope, in general it won't 
13:21:22 <ousado> schwadri: C has explicit memory menagement
13:21:29 <ousado> sheesh
13:21:36 <comex> it will get copied
13:21:47 <djahandarie> lispy, if you're already constraining the width clientside then what would be the problem with that constraint already being there?
13:21:47 <comex> it would go away if you were returning a pointer to that local
13:21:50 <monadic_kid> ousado: what are you talking that code is valid, and of-course you can return structs by value
13:22:05 <sipa> semantically you can return structs by value
13:22:06 <lispy> djahandarie: conflicting constraints
13:22:28 * monochrom should start a match-maker service, but not for romance or marriage. for debates!
13:22:34 <schwadri> well i'm not sure about c. in c++ this works
13:22:41 <lispy> djahandarie: the client side hacks are more flexible when I zoom in (to avoid eye strain)
13:22:41 <monochrom> (fine Valentine activity!)
13:22:46 <comex> it's possible in C.
13:22:54 <monadic_kid> schwadri: it's no different, POD-types
13:23:06 <lispy> a lot of websites use tiny or ugly fonts :(
13:23:09 <schwadri> thx
13:23:17 <monochrom> ObHaskell: I wish browsers supported "haskellscript" :)
13:23:20 <djahandarie> lispy, in that case, I say it's better to optimize for the general case rather than try to make it possible for everyone but a poor experience for most people. I can tell you that most people don't go resizing their browser for each type of site content.
13:23:25 <lispy> (my own blog is guilty of ugly fonts....)
13:23:40 <djahandarie> And with proper CSS, text zooming should work fine.
13:23:45 <monochrom> wait, maybe I should write a haskellscript interpreter in javascript...
13:23:56 <schwadri> so is it somehow possible to load this into haskell? if i define data x = x { a :: CUShort; b :: CUShort } i cannot use this as return type. ghc complains
13:24:01 <lispy> monochrom: so you can be turtles all the way down?
13:24:12 <monochrom> and turtle-slow too :)
13:24:22 <schwadri> so i looked at the ffi spec but couldn't figure out why x is not a valid foreign result type
13:24:27 <djahandarie> edwardk, did you see that parser/pretty-printer paper which introduced an algebra for partial isomorphisms?
13:24:45 <Younder> monochrom, Why? Javascript is slow enough as it is.
13:24:46 <djahandarie> They managed to find a neat use for CFunctor :P
13:25:14 <monochrom> yeah, it's unrealistic, just call it a Valentine's Day wish
13:25:21 <ousado> monadic_kid: valid in what way? in that compilers don't complain?
13:25:24 <luite> hmm, javascript isn't terribly slow anymore in recent browsers
13:25:33 <Jesin> what's CFunctor
13:25:45 <djahandarie> An actual functor, rather than an endofunctor over hask
13:26:05 <Jesin> I can't find it on hackage
13:26:07 <Jesin> :p
13:26:19 <djahandarie> It's in category-extras, but that is being slowly deprecated
13:26:34 <djahandarie> I don't recall seeing it in the new stuff edwardk has been making
13:26:34 <Jesin> ?
13:26:39 <Younder> djahandarie, why?
13:26:45 <djahandarie> Why what?
13:26:58 <Younder> djahandarie, why is being daprecated?
13:27:06 <monadic_kid> schwadri: as far as I'm aware i don't think you can define a type signature like that in haskell, what is typically done is a C function returns or takes a pointer to the the struct, in haskell you recreate the struct with a record, define an instance of Storable. For function's which take pointer arguments you can use the function Foreign.Marshal.Utils.with which will temporary allocate a block of memory on the stack an give you a Ptr type
13:27:06 <monadic_kid>  which you can pass the ffi import function
13:27:15 <djahandarie> Re: category-extras, it's because it is monolithic and no one wants to depend on it
13:27:21 <interferon> would there be any value to my contributing a "cabal rebuild" command, which would be equivalent to "cabal clean && cabal configure && cabal build"
13:27:28 <djahandarie> So it is being split apart / being rewritten into smaller packages
13:27:54 <Jesin> ok, umm
13:28:01 <Jesin> are they breaking the dependency tree?
13:28:17 <djahandarie> Jesin, huh?
13:28:18 <Jesin> err, class hierarchy
13:28:20 <Jesin> whatever you call that
13:28:22 <Jesin> :p
13:28:33 * djahandarie isn't sure what Jesin is asking
13:28:40 <djahandarie> What is "they"?
13:28:54 <Jesin> the people who are splitting apart category-extras into smaller packages
13:29:00 <djahandarie> It's one person, edwardk.
13:29:06 <Jesin> ok
13:29:07 <schwadri> monadic_kid: oh i see, so i can only have primitive types or pointers as return values?
13:29:10 <djahandarie> Who also is the maintainer of category-extras.
13:29:13 <Jesin> well
13:29:17 <Jesin> right, ok
13:29:29 <djahandarie> I'm pretty sure nothing depends on category-extras at all actually
13:29:39 <djahandarie> But the old version will still be there if someone is depending on it.
13:29:40 <Jesin> he can probably be trusted to not do anything like Monads not being Functors
13:29:50 <djahandarie> Oh, that's what you're asking about.
13:30:09 <schwadri> monadic_kid: so in my case i could just put both shorts into an int and then use some bitmagic on haskells side to reconstruct the struct?
13:30:16 <Jesin> also, we should have Semigroup in the main library as a superclass of Monoid
13:30:26 <djahandarie> He can't fix the problems of the standard library, but for the more general stuff he writes he can fix it.
13:30:53 <djahandarie> One of the goals of the new 'category theory packages' is to less scary though, so I don't know how general it's going to get.
13:31:06 <djahandarie> I just thought I would mention CFunctor in case edwardk was planning on killing it :)
13:32:05 <Jesin> the current "instance Monoid a => Monoid (Maybe a)" is really broken
13:32:13 <Jesin> it should be instance Semigroup a
13:32:25 <Jesin> err, sorry
13:32:32 <Jesin> instance Semigroup a => Monoid (Maybe a)
13:32:40 <djahandarie> It isn't 'broken'
13:32:45 <djahandarie> Just not as general as it could be
13:32:55 <Jesin> ok fine :p
13:33:00 <monadic_kid> schwadri: what you could do is leave as it is and make the c-function take a pointer-to-struct, then in Haskell define a record that approximates the struct, then define a storable instance, import the C function with FFI, write a wrapper function which uses the haskell "with" action
13:33:28 <djahandarie> a.k.a it isn't undefined on one of the monoid operations or failing one of the laws or something 
13:33:45 <djahandarie> It's just the semigroup lifted into a monoid, which is fine, besides how it isn't as general as it could be
13:34:22 <navaati> this category-extras stuff is a piece of dread
13:34:32 <djahandarie> navaati, which is why it's being rewritten :)
13:34:39 <djahandarie> There is a lot of neat stuff in there but it's scary as a whole
13:35:02 <djahandarie> For example, the cofree comonad represents CPS transforming code and can make stuff asymptotically faster
13:35:24 <dolio> Nope.
13:35:29 <monadic_kid> schwadri: did that make sense?
13:35:31 <djahandarie> It isn't?
13:35:32 <djahandarie> Hmm
13:35:36 <djahandarie> Was I thinking of something else?
13:35:43 <dolio> Codensity monad is probably what you're thinking of.
13:35:49 <djahandarie> Ah, right, yeah
13:36:06 <ousado> monadic_kid: so you really think it's fine to return a stack allocated struct from a C function?
13:36:36 <navaati> djahandarie: really ? i'm just looking at small pieces, and it's as scary as the whole stuff
13:36:40 <monadic_kid> ousado: he is returning by value, it will be copied
13:36:43 <monadic_kid> ousado: he is returning by value, it will be copied
13:36:55 <monadic_kid> ousado: it is perfectly valid C code
13:36:58 <djahandarie> navaati, well, it's a bunch of strange terms and stuff, but most of it isn't that scary
13:37:11 <djahandarie> You can definitely find scary parts that are small though :P
13:37:19 <djahandarie> (i.e., some of the recursion schemas)
13:37:45 <schwadri> monadic_kid: it made sense apart from the with function.
13:37:50 <djahandarie> schemes*
13:38:34 <djahandarie> navaati, http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html here is a nice article on one type of abstraction that is done in there
13:38:44 <monadic_kid> schwadri: the with function will alloca a Ptr of T on the stack so you can pass it to the FFI imported function that takes a pointer argument
13:38:58 <edwardk> djahandarie: actually there are probably 20 or so packages by others that depend on category-extras
13:38:59 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
13:39:09 <djahandarie> edwardk, wow, really? :P
13:39:09 <monadic_kid> schwadri: it's a scoped resource
13:39:31 <schwadri> monadic_kid: ah, so i don't have to make a detour over the heap. that is great ;-) thx
13:39:38 <djahandarie> edwardk, have you ported CFunctor somewhere yet?
13:39:51 <monadic_kid> schwadri: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Marshal-Utils.html
13:40:07 <monadic_kid> schwadri: but you need to make instace of the Storable class for your record
13:40:48 <schwadri> monadic_kid: maybe a little bit more context: i want to parse extended display identification data which is just a binary string, and at the moment i do this in c, but maybe it would be easier to just load the whole thing into haskell and do the parsing stuff there?
13:41:18 <edwardk> @tell byorgey consider the use of fmapDefault in Data.Traversable if you try to define your traversable in terms of sequenceA. the same thing happens.
13:41:19 <lambdabot> Consider it noted.
13:41:24 <schwadri> monadic_kid: i already have a Storable instance
13:41:38 <schwadri> monadic_kid: just need to do the "with" stuff
13:42:59 <monadic_kid> schwadri: sounds reasonable if parsing is non-trivial
13:43:02 <edwardk> @tell byorgey you could make up some kind of distributive (or traversable) for non-functors, but i don't particularly care about them. ;) ideally the fmapDefault in Data.Traversable would come with the same caveat.
13:43:02 <lambdabot> Consider it noted.
13:43:59 <edwardk> djahandarie: i think its in categories under Control.Functor.Categorical
13:45:05 <djahandarie> Ah bingo, Control.Categorical.Functor
13:45:07 <djahandarie> Thanks
13:45:25 <edwardk> djahandarie: there are apparently only 16 reverse dependencies still alive for category-extras: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/category-extras-0.53.5#direct which is an impressive number for a package that doesn't at last check build ;)
13:45:43 <CosmicRay> aavogt: I am here now
13:45:46 <djahandarie> Heh
13:46:36 <edwardk> djahandarie: also, semigroupoid-extras provides semifunctor, which is much nicer than Control.Functor.Categorical ;)
13:46:48 <schwadri> monadic_kid: thx. alot for your help.
13:47:11 <djahandarie> edwardk, reason I'm semi-interested in the better Functor definition is because it was mentioned in a paper I just read: http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf
13:47:21 <edwardk> http://hackage.haskell.org/packages/archive/semigroupoid-extras/0.2/doc/html/Data-Semifunctor.html
13:48:07 <djahandarie> Maybe I'll write an instance for them, try to get your package adopted ;)
13:48:07 <edwardk> the problem i have with the 'generic' functor class is its not generic enough to be able to make functor coproducts and products or functors to/from categories that are not enlarged to have at least one object for every type in the category of haskell types.
13:48:45 <djahandarie> How would you make it generic enough?
13:49:27 <edwardk> djahandarie: thats what semifunctor does, it weakens the requirements from category to semigroupoid so you can have product semigroupoids or coproduct semigroupoids as source or destination
13:49:38 <edwardk> those (with GADTs) can deal with smaller indexing sets
13:50:04 <djahandarie> You made it sound like it'd be possible to do that without dropping identity arrows
13:50:29 <edwardk> for instance data Prod j k x y  where Pair :: j a b -> k c d -> Prod j k (a,c) (b,d)
13:51:11 <CosmicRay> monochrom, gwern: yes it is easy to figure out.
13:51:15 <edwardk> those have identity arrows, just not for every haskell type.
13:51:30 <CosmicRay> monochrom, gwern: my email address has been publicly known on the net for 15 years now.  it's a very low bar ;-)
13:51:41 <monochrom> \∩/
13:52:25 <corpumpkin> greetings!
13:52:35 <corpumpkin> edwardk: fancy seeing you here
13:52:36 <djahandarie> Greetings!
13:53:04 <edwardk> corpumpkin: likewise
13:53:10 <djahandarie> I left you a message on copumpkin, which I also just mentioned to edwardk. Though you might be more interested in it
13:53:22 <corpumpkin> djahandarie: yeah but today I'm corpumpkin
13:53:25 <corpumpkin> sorry
13:53:57 <djahandarie> Is there some obscure category theory joke in 'cor-' or am I thinking too hard? :P
13:54:13 <corpumpkin> nah, being on the top of a high-rise makes me feel corporate
13:54:22 <djahandarie> Haha
13:54:32 <djahandarie> Are you wearing a suit?
13:54:36 <corpumpkin> hell no
13:54:38 <schwadri> monadic_kid: hm, with is not what i want, after using it, i'm only left with the result type and i have no chance to read out the Ptr before it is destroyed :-(
13:54:42 <djahandarie> Hah
13:54:43 <edwardk> ah fair enough, i was thinking more dangermouse myself.
13:54:52 <edwardk> corpumpkin as penfold.
13:55:03 * corpumpkin hasn't seen much dangermouse :(
13:55:10 * corpumpkin had a deprived childhood!
13:55:18 * djahandarie hasn't even heard of it
13:55:39 <edwardk> the sidekick was fond of exclaiming "Cor!"
13:55:48 <corpumpkin> cor blimey
13:55:58 <gwern> > 2011 - 1929
13:55:59 <lambdabot>   82
13:56:05 <monadic_kid> schwadri: I'm not sure what you're trying to say
13:57:32 <schwadri> monadic_kid: with creates internally a ptr to my struct and sends calls the c function with that, but after the call returns, the ptr is released, before i can read the changed data that it points to
13:59:33 <monochrom> that's the job of "with". read the data before you allow "with" to finish.
13:59:53 <copumpkin> @messages
13:59:53 <lambdabot> seydar said 4d 17h 34m 40s ago: awesomesauce
13:59:54 <lambdabot> ddarius said 13h 32m 11s ago: Incidentally, Fokkinga's approach to category theory falls under the "reduce everything to initiality" approach and you can see in his work how this leads to him
13:59:54 <lambdabot> creating new categories willy-nilly.
13:59:54 <lambdabot> djahandarie said 5h 19m 15s ago: What do you think about http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf / http://hackage.haskell.org/package/invertible-syntax
14:00:11 <copumpkin> I like invertible syntax :)
14:00:29 <monochrom> I love the haskell-cafe thread on invertible syntax.
14:00:31 <copumpkin> I still want to do it myself, and better
14:00:40 <copumpkin> for binary formats
14:00:46 <copumpkin> anyway, leaving now
14:00:53 <djahandarie> Bye copumpkin!
14:01:08 <djahandarie> Ah
14:01:29 <monochrom> <X> "hi, how could I unify parser and printer?" <Y0> invertible syntax <Y1> invertible syntax <Y2> invertible syntax
14:02:14 <djahandarie> @tell copumpkin Mind if I transform your explaination of de brujin indexes & that agda code into an article?
14:02:14 <lambdabot> Consider it noted.
14:02:45 <monochrom> I also agree that Fokkinga overuses initiality. it doesn't abstract anything away.
14:02:55 <joe6> i am looking for a simple llvm backend. i know that language.C can read C code into haskell. I have 2 options: 1. write the llvm backend using the llvm templates and C++ or, 2. use haskell to read the C generated by the llvm C backend and manipulate that in haskell. Any suggestions on which could be the better approach, please?
14:03:25 <kmc> what are you trying to do?
14:03:30 <monochrom> But I love the formal logic replacing the diagrams. So much more powerful.
14:03:34 <kmc> "llvm backend" for what?
14:03:46 <monadic_kid> schwadri: couldn't you just do with x (myFFI >>= peek)?
14:04:07 <kmc> if you're trying to convert C into LLVM bytecode then llvm-gcc and clang will both do that for you
14:04:10 <kmc> where does Haskell come in?
14:04:15 <Jesin> > fix $ (1:) . (1:) . (zipWith (+) <*> tail)
14:04:16 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
14:04:29 <Jesin> sorry just playing around with <*>
14:05:11 <monadic_kid> schwadri: k <- with x (\ptr -> myFFI ptr >>= peek ptr) ?
14:06:52 <schwadri> monadic_kid: hey thx, i figured it out. and it works. thx alot
14:07:53 <joe6> kmc: i need some asm for which there is no llvm backend. llvm -> asm is what I want. and i am not that keen on writing a C++ backend for llvm. I know that haskell can read C code, and as llvm can spit out C too. I could do the C -> asm in haskell, but I am not sure how complicated language.C is.
14:08:37 <monochrom> llvm->C->asm seems counterproductive
14:09:08 <joe6> but, atleast i get the llvm optimizations and can use the llvm high-level bindings.
14:09:37 <joe6> the C -> asm is more a literal translator compared to all the functions that a C compiler normally does.
14:10:00 <monadic_kid> schwadri: actually just using alloca would be better, then you don't need to make a random haskell value of the record
14:10:10 <kmc> joe6, many LLVM features can not be represented cleanly in C
14:10:19 <kmc> joe6, aren't there Haskell modules for loading LLVM bytecode?
14:10:28 <kmc> then you could write the translation directly
14:10:30 <joe6> kmc, oh, ok. that was the input i was looking for.
14:10:47 <monadic_kid> schwadri: k <- alloca (\ptr -> myFFI ptr >>= peek ptr)
14:10:48 <kmc> will the 'llvm' package do what you want?
14:10:58 <lysgaard> In ghci, how do i load two files and have both their functions accessible at the same time. When i try "$ :l File1.hs File2.hs" only the definition from the first one is visible. What am i doing wrong?
14:11:29 <ben> :m?
14:11:45 <joe6> yes, the catch is llvm bytecode -> asm (there is no backend currently that does this for the asm that I am looking for) and hence want to see how I can reduce my efforts from having to create a full-sized llvm backend.
14:11:57 <monochrom> :m + File1 File2
14:12:10 <monochrom> or whatever module names you picked
14:12:11 <joe6> llvm package can get the stuff to llvm bytecode. My issue is from that bytecode to asm.
14:12:38 <joe6> joe6: are there haskell modules for loading the llvm bytecode?
14:12:46 <m3ga> joe6: doesn't llc (part of the llvm tools) do byecode to asm?
14:12:49 <monochrom> more in http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-scope
14:13:12 <monadic_kid> schwadri: Foreign.Marshal.Alloc.alloca
14:13:16 <lysgaard> ben and monochrom, ah! Saved my day =) Thanks.
14:13:25 <joe6> kmc, llc does certain dialects but not for the target architecture that i am looking for.
14:13:40 <joe6> m3ga, llc does certain dialects but not for the target architecture that i am looking for.
14:13:56 <m3ga> oh, right. then you either need to hack llc or do it yourself by hand.
14:14:47 <joe6> yes, that is the decision point where I am at
14:15:54 <m3ga> joe6: it sould be useful to have a pure haskell module for reading and writing llvm bytecode if you're interested in taking on that task.
14:16:44 <joe6> that portion of llc that generates the asm is called the llvm backend and that requires C++ code. llc generates C code already. I am wondering if I could use language.c to read in that C code and output asm from haskell, instead of having to much around with C++. But, I am not sure how complicated/easy language.C is.
14:17:33 <m3ga> joe6: i'd be worried about how much is lost in the llvm bc -> C translation.
14:18:03 <joe6> m3ga: the llc already generates gcc code and the language.C can read C code (supposedly gcc code).
14:18:28 <joe6> m3ga: the C code was pretty good with a lot of hints.
14:18:51 <joe6> m3ga: have you used language.C?
14:19:03 <m3ga> joe6: yeah, but ..... i think thats a rather long winded way to a solution.
14:19:22 <m3ga> i've used language.c just a bit. i'm working on the llvm backend for the ddc compiler.
14:20:13 <joe6> m3ga: oh, cool. Was it hard to understand/get language.C?
14:20:33 <joe6> it is definitely a long winded way. But, if it works, would save a lot of time.
14:20:46 <joe6> learning C++, learning llvm and all that.
14:21:03 <m3ga> joe6: its just compilicated. a single line of C code and end up with a really complicated ASt
14:22:09 <joe6> oh, ok. so, you think I will be spending more time trying to use Language.C than just picking up a little bit of C++ and writing the asm generator as an llvm backend?
14:22:10 <m3ga> i've been thinking about doing an LLVM AST (the one used in GHC and DDC) to LLVM bytecode for some time. i'm just a bit too busy.
14:22:35 <joe6> m3ga: something like llc? why?
14:22:56 <joe6> or, doy mean the haskell llvm bidings?
14:22:57 <m3ga> joe6: if you are already comfortable with writing C then yes.
14:23:37 <m3ga> joe6: doing soemthing like llc, because currently ghc/ddc write out LLVM text and then use llc to assemble it.
14:23:39 <joe6> oh, ok. cool. that was the input I was looking for. Thanks a lot.
14:24:09 <m3ga> pretty printing the llvm text assembler only to run it through llc is silly
14:24:19 <revenantphx> One question,
14:24:26 <revenantphx> eh, nevermind
14:25:26 <joe6> m3ga: i did not understand what you said "pretty printing the llvm text assembler only to run it through llc is silly"
14:26:22 <monadic_kid> schwadri: by the way your record type doesn't have to use foreign C types, you can use fromIntegral in poke/peek
14:26:33 <joe6> oh, ok. so you want to directly write out llvm bytecode?
14:26:39 <joe6> to llc?
14:27:10 <m3ga> joe6: ghc and ddc do not use the llvm bindings that are on hackage. instead they use an AST representation which is then pretty printed as text. that text gets run through llc.
14:27:26 <gwern> that sounds kind of odd
14:27:29 <joe6> m3ga: oh, ok.
14:27:34 <m3ga> joe6: it would be nice to go from the AST directly to bytecode.
14:27:35 <gwern> text is the intermediate format?
14:27:44 <m3ga> yes
14:28:38 <m3ga> gwern: there is an example of the text intermediate format here http://www.mega-nerd.com/erikd/Blog/CodeHacking/DDC/llvm_milestone1.html
14:29:17 <gwern> I guess it works, but still seems a bit of kludge
14:29:55 <m3ga> it is. it helps for debugging, but converting directly to bytecode would be nice.
14:30:14 <m3ga> ghc is currently doing this when compiling via llvm.
14:30:59 <m3ga> really nice thng is that if someone does the AST -> bytecode thing, then both ghc and ddc benefit
14:32:01 <micahjohnston> is anyone interested in temporal/reactive functional programming stuff?
14:32:41 <revenantphx> Why didn't anyone tell me about cabal init earlier >:(
14:32:55 <monadic_kid> micahjohnston: interested but still seems like experimental research at the moment
14:32:57 <monochrom> because docs are poor
14:32:58 <djahandarie> I usually don't use it anyways
14:33:10 <micahjohnston> monadic_kid: I'm trying to design a language based on it
14:33:16 <monochrom> there are a million other undocumented features of cabal
14:33:22 <revenantphx> ...it fails with:
14:33:23 <revenantphx> cabal: /Users/dlukes/benchmark/Agda: does not exist
14:33:25 <revenantphx> what.
14:33:27 <schwadri> monadic_kid: oh, thx for the hint. i guess with uses alloca internally. so how would i use fromIntegral in my setting? i mean somehow i have to retreive the Ptr values. or you mean i should use WordPtr?
14:33:31 <revenantphx> how is that, at all, relevant.
14:33:39 <joe6> m3ga: i am going through the llvm.org tutorials about the backends. Any suggestions/experiences that might help with the learning curve?
14:34:04 <revenantphx> joe6: I'm doing that stuff myself at the moment.
14:34:05 <micahjohnston> monadic_kid: would you be interested in talking about it?
14:34:15 <revenantphx> I'm toying with doign the Kaleidoscope tutorial in haskell.
14:34:26 <ezyang> Hey, anyone know how to make GHC emit a call to stg_gc_l1? 
14:34:42 <copumpkin> djahandarie: not at all!
14:34:43 <Cale> micahjohnston: Many of us here are quite interested. I'm fairly busy at the moment though, working on our iPhone game which happens to use FRP extensively :)
14:34:43 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:34:43 <m3ga> joe6: sorry, only looked very briefly at the llvm code. from what little i've seen, its better than most C++ code bases, but that is faint praise :-)
14:34:56 <monadic_kid> schwadri: in your instance of Storable, your definitions of poke, peek
14:34:58 <micahjohnston> Cale: oh, that's awesome :D
14:35:04 <revenantphx> This is actually annoying. It keeps failing with "cabal: /Users/dlukes/benchmark/Agda: does not exist"
14:35:09 <revenantphx> when I try to do cabal init.
14:35:15 <revenantphx> I don't think that's... at all relevant though.
14:35:29 <monochrom> are you doing "cabal init" in an empty directory?
14:35:47 <schwadri> monadic_kid:   peek p = do
14:35:47 <schwadri>     w <- peekByteOff p 0
14:35:47 <schwadri>     h <- peekByteOff p 2
14:35:47 <schwadri>     return (Size w h)
14:35:57 <monadic_kid> micahjohnston: in terms of programming language design I probably work be useful to you
14:36:06 <revenantphx> monochrom: oh... no >_>
14:36:12 <monochrom> could you try?
14:36:22 <joe6> revenantphx, that would be awesome. Isn't that the frontend portion of llvm though?
14:36:37 <revenantphx> joe6: Haskell has codegen bindings.
14:36:44 <Cale> @tell byorgey I hope to be able to recover it from the hard drive in my old computer, but haven't gone through the hassle of trying to recover it yet, since I think the hard drive is failing and the machine is failing to boot.
14:36:44 <lambdabot> Consider it noted.
14:36:45 <copumpkin> @tell djahandarie go ahead (in case you didn't get my actual approval message in the channel)
14:36:45 <lambdabot> Consider it noted.
14:37:03 <revenantphx> or am I misunderstanding what you're saying?
14:37:06 <revenantphx> Oh, you're looking at backend stuff.
14:37:08 <revenantphx> my bad.
14:37:36 <monadic_kid> schwadri: so if you wanted to do your definition of Size could use say Int16, then you can say e.g. w <- fromIntegral `liftM` peekByteOff ....
14:38:21 <joe6> revenantphx, yes, i need a backend. i want to use the haskell llvm module and get it flow through the llvm life-cycle, except for the last part where I need some custom asm.
14:38:38 <monadic_kid> schwadri: *so if you wanted to do change your definition of Size to could use say Int16 instead of Foreign C data types
14:38:40 <micahjohnston> so, if anyone's interested… I have a channel for it, ##tempus
14:38:55 <monadic_kid> schwadri: it's upto you
14:39:23 <dainanaki> Hello all, I'm getting a weird linker error building the highlighting-kate package. It's saying "ld: scattered reloc r_address too large for inferred architecture i386"
14:39:29 <m3ga> joe6: the llvm AST used in GHC and ddc allows the insertion of chunks of custom asm
14:40:51 <joe6> m3ga, but then i do not want to start coding in asm. I already have the app in asm and I am thinking of moving away from asm to some higher-level language. I could do it in C, but just like haskell so much that I want to do it in haskell.
14:40:55 <revenantphx> Erp.
14:41:05 <revenantphx> So, one question to anyone who could answer.
14:41:18 <revenantphx> If I felt like writing a demo implementation of say ObjC w/ haskell,
14:41:22 <revenantphx> using LLVM as output.
14:41:32 <schwadri> monadic_kid: ah i see what you mean. thx again, and good night. bb
14:41:37 <revenantphx> I should be able to get it to link into existing binaries for X platform yes?
14:41:39 <m3ga> joe6: now i'm confused about what you are trying to do
14:42:17 <revenantphx> meh, I'll do parsing as an exercise before any of that.
14:42:55 <joe6> m3ga: i have an asm app. I want to get away from writing it manually and want to generate it from some higher-level language. I am thinking of using haskell and have the llvm bindings generate the asm, ideally.
14:43:14 <joe6> m3ga, does that make sense?
14:43:38 <joe6> basically, generate asm code.
14:43:58 <m3ga> joe6: ok, so how does generating C code from llvm and reading it with language.c come into it?
14:45:49 <joe6> m3ga, I need something to take llvm bytecode -> asm (for my target). llc takes llvm bytecode -> C -> Language.C -> haskell c2asm pretty printer was an option that i was wondering about.
14:46:09 <ezyang> Can I give GHC STG and make it compile it? 
14:46:27 <joe6> if the chain works, then I would just be coding in haskell
14:46:39 <joe6> and not have to worry about C++ templates and all that.
14:46:51 <m3ga> joe6: ah right, so llc doesn't support your target but haskell does? what's the target?
14:47:10 <joe6> m3ga, both do not support my target.
14:47:19 <joe6> m3ga, but I know haskell but not C++
14:47:25 <joe6> s/but/and/
14:47:50 <m3ga> joe6: what's the target?
14:47:59 <joe6> pic18asm
14:48:26 <thoughtpolice> ezyang: no, i don't think so atm. what do you need to write in STG?
14:49:10 <ezyang> I'm trying to make GHC emit a call to stg_gc_l1, but I'm having difficulty making it happen. I wonder if STG would make it easier. 
14:49:20 <m3ga> joe6: there's a haskell EDSL for that sort of embedded stuff isn't there? forget the name.
14:49:22 <thoughtpolice> revenantphx: yes, providing you tell LLVM what the calling convention of the function is it should work
14:49:33 <revenantphx> thoughtpolice: intereting.
14:50:24 <joe6> m3ga: atom? it is different, though.
14:50:42 <m3ga> joe6: yeah, atom
14:50:57 <thoughtpolice> revenantphx: AFAIK, objective C uses the regular C calling convention like pretty much everything, so you should just be able to emit 'call' instructions using llvm, and the ASM generated by the llc tool will correctly match the calling convention
14:51:09 <Saizan> there's no C to pic18asm compiler?
14:51:13 <joe6> atom is for constant time /memory asm generator.
14:51:23 <revenantphx> thoughtpolice: yep, it does.
14:51:25 <m3ga> right, yeah
14:51:25 <joe6> Saizan: there are, but not from gcc
14:51:29 <thoughtpolice> revenantphx: http://llvm.org/docs/LangRef.html#callingconv
14:51:42 <thoughtpolice> revenantphx: the C calling convention is the default
14:51:51 <joe6> Saizan, and the mplab c compiler is $
14:51:59 <Saizan> joe6: i see
14:52:20 <thoughtpolice> so you should just be able to generate 'call' instructions, provided you just make the function you're calling known to LLVM (basically by giving it a prototype like you would in C)
14:52:34 <joe6> Saizan, there is sdcc and cpik, but they do not handle gcc conventions.
14:53:07 <joe6> and llc generates gcc C
14:53:09 <m3ga> so why noy just code in whatever C the pic16 compiler requires
14:53:36 <Saizan> or emit that C from your haskell
14:54:15 <joe6> because, the C compilers are not as good as the llvm optimizer and I would rather do haskell -> llvm rather than haskell -> C.
14:54:44 <joe6> the C compilers are very rudimentary and I doubt their capabilities compared to what llvm provides.
14:55:07 <m3ga> joe6: your idea of  "haskell -> llvm bytecode -> C -> Language.C -> haskell c2asm" will cause you way more pain than writing your code in C to begin with.
14:55:30 <Jesin> hmm
14:55:37 <Jesin> where would I find Control.Monad.State ?
14:55:41 <Saizan> joe6: maybe you can use the llvm optimizer and then convert the optimized bytecode directly to asm without going via C
14:55:54 <m3ga> joe6: you should also be worrying about how optimal the code is after you have soemthing that works. just me 2 cents worth.
14:56:01 <thoughtpolice> Jesin: it exists in both mtl and the transformers library, IIRC
14:56:20 <joe6> Saizan, yes, that is what I am doing now. But, am just curious of the other ways I could possibly have done the same.
14:56:38 <m3ga> joe6: llc can also write back the text IR format after optimisation.
14:56:53 <m3ga> joe6: you can parse that text and then generate asm for your target
14:57:07 <joe6> m3ga, i have something that works already. I have it in asm. I am trying to optimize not in terms of speed but in terms of maintainability.
14:57:24 <Jesin> hmm
14:57:31 <monadic_kid> Jesin: mtl/transformers package, mtl2 == transformers + monads-tc
14:57:32 <Jesin> what are the differences between mtl and transformers?
14:57:46 <Jesin> ok, what's monads-tc
14:57:54 <joe6> m3ga: thatis the whole llvm backend process, correct?
14:57:57 <monadic_kid> Jesin: type-classes, there is monads-fd as well
14:58:20 <monadic_kid> Jesin: which stands for type families
14:58:38 <Jesin> ...ok, then
14:58:41 <monadic_kid> Jesin: sorry I'm tired, abrevations are wrong
14:58:42 <m3ga> joe6: yes, as I understand it.  'opt -std-compile-opts <input> -S -o <output>'
14:59:46 <joe6> Saizan, this is what i have: haskell (custom) -> llvm bindings -> llvm -> (pic18 backend, custom) -> assembler
14:59:59 <monadic_kid> Jesin: monads-fd which is type-classes with functional depedancies, and monads-tf which is type-classes using type families
15:00:04 <dainanaki> Anyone here used Yesod?
15:00:05 <joe6> i am just looking at ways that I can minimise the work involved.
15:00:43 <Jesin> monadic_kid: so they are different implementations of the same thing?
15:00:50 <joe6> and, hopefully, getting as much as I can into haskell.
15:01:09 <monadic_kid> Jesin: yes, they are seperate pakcages because monads-fd/tf use haskell extensions and transformers can be used with just haskell98
15:01:49 <Jesin> k
15:02:07 <Jesin> so
15:02:25 <Jesin> mtl is transformers plus monads-fd?
15:03:02 <Jesin> also, do monads-tf and monads-fd implement the same things using two different extensions?
15:03:58 <monadic_kid> Jesin: mtl version 2.* is, the versions before that is pretty much the same but it's own implementation. Yes they pretty much implement the same thing with different extensions
15:05:23 <Jesin> ok, what about all 3?
15:05:31 <Jesin> does that cause collision issues, or what
15:06:00 <monadic_kid> Jesin: probably, if you import modules from both monads-tf & fd
15:06:15 <monadic_kid> Jesin: there is no reason to use both
15:12:07 <monadic_kid> Control.Monad.Trans.RWS more efficent implementation of monad transformer stack of reader, writer, state or just convenience module?
15:14:03 <hpc> monadic_kid: i assume it's more efficient, due to the transformations being "flattened"
15:14:26 <monadic_kid> hpc: that is what i'm assuming
15:14:47 <monadic_kid> which is quite cool and I didn't notice that module
15:18:13 <ocharles> Ok! Got my initial Parsec stuff working completely, and it's golf time now! Any tips on https://github.com/ocharles/Orgdex/blob/master/Orgdex.hs ?
15:18:55 <ocharles> I'm quite confused as to why this works actually - mostly the level bit, because from what I gather <$> and <*> is for combining data in a common Functor, but length is just Int, and not in a functor at all
15:18:59 <ocharles> but hey, it does work :)
15:19:45 <ivanm> @type (<$>)
15:19:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:19:52 <ivanm> @type (<*>)
15:19:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:20:11 <ivanm> <*> isn't for "common" functors
15:20:18 <ivanm> though <$> is just fmap
15:20:43 <jix_> @type fmap
15:20:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:20:45 <ocharles> by common I meant functors of the same type
15:21:00 <ivanm> and in this case it's in the (->r) functor
15:21:08 <ivanm> * ((->)r)
15:21:45 <gwern> > 2^16
15:21:46 <lambdabot>   65536
15:22:00 <ocharles> ivanm: hrm, how did you figure out it's the ((->) r) functor?
15:22:02 <ocharles> the/a
15:22:20 <augustss> gwern: testing the bot's sanity?
15:22:36 <ivanm> ocharles: no, wait, I mis-read
15:22:48 <ivanm> ocharles: length <$> ... = fmap length ...
15:22:54 <gwern> augustss: no, I just don't have powers of 2 memorized
15:22:55 <ivanm> you're just fmap'ing in the parsing monad
15:22:59 <ivanm> gwern: :o
15:23:04 <gwern> easier to switch to IRC and find out
15:23:04 <ocharles> ivanm: right, but the end result is an Integer there though
15:23:13 <ocharles> ivanm: or am I wrong?
15:23:20 <ivanm> ocharles: it'd be Parser Int or something
15:23:25 <ivanm> whatever parsec's monad is called
15:23:30 <ocharles> oh, so it does 'move' it into parsecs monad
15:23:37 <gwern> I'd ask my own ghci, but my ubuntu's ghc is hosed, something about UTF in the package.conf
15:23:40 <ocharles> lift?
15:23:46 <ivanm> yeah
15:23:51 <ivanm> that's the whole point of Functor
15:23:55 <ocharles> good, getting to grips with these terms
15:23:57 <ivanm> @src (<$>)
15:23:57 <lambdabot> f <$> a = fmap f a
15:24:12 <ocharles> ivanm: right I thought it was the point of lifting the function, the penny hadn't quite dropped that the result would be too
15:24:22 <ocharles> but that makes more sense now
15:31:12 <shamster> What can I use to do the following: groupList :: Int -> [a] -> [[a]]... where groupList takes a number and a list, and then produces a list of lists where the sublists are the original elements, but grouped into lists of the given size?
15:33:18 <ivanm> shamster: repeated splitAt
15:33:21 <ivanm> @type splitAt
15:33:22 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:33:53 <luite> shamster: the package split on hackage has the module Data.List.Split with the function splitEvery
15:33:58 <luite> which does what you want
15:34:04 <ivanm> also see http://www.holumbus.org/hayoo/hayoo.html?query=Int+-%3E+[a]+-%3E+[[a]]
15:34:20 <ivanm> luite: *facepalm* forgot about split :s
15:34:28 <shamster> luite: thanks!
15:34:34 <shamster> ivanm: thanks 2
15:35:37 <Page15> Is it possible to use filter to find a string? If not what would I be looking at?
15:36:02 <luite> Page15: isInfixOf
15:36:08 <Page15> Thanks
15:39:46 <shamster> is I have a function 'f :: a -> a -> a -> g' and a list of something like [[a1,a2,a3], [aa,ab,ac], ...], how do I get back a list of [g1,g2,...] where f is applied to the first list taking each triplet as the arguments?
15:40:46 <shamster> s/^is/if/
15:40:57 <hpc> :t uncurry3
15:40:58 <lambdabot> Not in scope: `uncurry3'
15:41:26 <hpc> shamster: i suppose write an uncurry function for triples
15:41:37 <shamster> hpc: yes... that looks about right
15:41:37 <hpc> then map . uncurry3
15:41:50 <hpc> or something like that
15:42:13 <hpc> btw, your inner lists will have to be tuples
15:42:21 <hpc> (for my thing to work)
15:42:25 <shamster> hpc: yeah, I think I'll just write one for lists
15:43:44 <Page15> Is there a way to count the number of isInfixOf in a string?
15:44:31 <Page15> I've got my haskell code working to find if it exists using isInfixOf
15:44:39 <luite> Page15: length . filter (`isPrefixOf` xs) . tails
15:44:59 <Page15> Thanks
15:45:20 <luite> Page15: but that will report overlapping strings 
15:45:50 <Page15> E.g at if your looking for at would report it twice?
15:46:52 <luite> if you're looking for the string "aa" it would count four occurences in "aaaaa"
15:47:07 <Page15> I see
15:48:49 <Page15> "= length . filter('isPrefixOf' "data" xs) . tails" Have I got something wrong?
15:49:09 <Bynbo7> where is xs coming from?
15:49:17 <hpc> also, backticks
15:49:40 <Bynbo7> ('isPrefixOf' "data" xs) should be ("data" `isPrefixOf`)
15:49:45 <Page15> ah
15:49:51 <Bynbo7> or just isPrefixOf "data"
15:50:25 <hpc> Bynbo7: no, here it needs to be flip isPrefixOf
15:50:26 <shachaf> Bynbo7: That's just confusing. That function is meant to be used with backticks.
15:50:28 <hpc> or just a section
15:51:04 <Page15> countDatas s = length . filter (isPrefixOf "data") . tails
15:51:45 <Page15> * "data" s)
15:52:05 <luite> Page15: countDatas s = length . filter (`isPrefixOf` "data") . tails $ s
15:52:12 <luite> you can simplify that to
15:52:19 <luite> Page15: countDatas = length . filter (`isPrefixOf` "data") . tails
15:53:50 <Page15> It reports 1 data when there is none
15:54:49 <luite> oh I got something the wrong way around
15:55:21 <hpc> is "data" what you are counting instances of?
15:55:23 <luite> Page15: countDatas = length . filter ("data" `isPrefixOf`) . tails
15:56:43 <Page15> luite: Thanks. Is the order of operations there? tails -> filter -> length?
15:57:04 <Page15> luite: Ah wait nvm, lol
15:57:53 <micahjohnston> so is anyone interested in working on my temporal/reactive functional programming language project, in ##tempus ?
15:59:19 <luite> Page15: yes you could say that's the order. (f.g) x = f (g x), so it applies g first
16:03:54 <Page15> luite: Thanks - I can see how that comes together
16:03:54 <tg_> micahjohnston: what is it?
16:04:08 <Page15> tg_ +1
16:04:52 <tg_> micahjohnston: I have an interest in reformulating some of the concepts of FRP
16:05:05 <micahjohnston> tg_: cool
16:05:08 <Page15> FRP ?
16:05:20 <tg_> but not enough hubris to claim that I know better than conal (at anything) until I can demonstrate it
16:05:24 <micahjohnston> Page15: functional reactive programming
16:05:28 <Page15> Ta
16:05:32 <micahjohnston> tg_: let's work together and show them all
16:05:45 <micahjohnston> :P
16:05:47 <tg_> what are you trying to accomplish? i'll join #tempus I suppsoe to talk about it
16:05:58 <micahjohnston> tg_: ##tempus, not #tempus
16:06:04 <phrackSipsin> Anybody know a very basic overview of FRP, preferably for idiots?
16:06:08 <tg_> what is with the ##
16:06:12 <tg_> phrackSipsin: conal's blog
16:06:16 <micahjohnston> phrackSipsin: I can give one right now
16:06:16 <tg_> and he has two video talks about it
16:06:21 <phrackSipsin> ah, excellent
16:06:27 <ocharles> tg_: where is conas'l blog?
16:06:27 <Page15> Link?
16:06:32 <micahjohnston> conal's blog has a lot of good stuff but it's kind of impenetrable if you haven't read other stuff about it
16:06:33 <micahjohnston> conal.net/blog
16:06:36 <ocharles> thanks
16:06:38 <theorbtwo> freenode convention.  #foo is an offical channel.  ##foo isn't.
16:06:47 <tg_> oh. ok
16:06:48 <theorbtwo> That is, offically blessed by the "foo" people.
16:07:00 <tg_> oh. so it's inappropriate in this case
16:07:06 <tg_> as i presume micah invented tempus?
16:07:22 <micahjohnston> basically, where purely functional programming has “timeless” values, that are the same forever, functional reactive/temporal functional programming extends these values through time
16:07:44 <micahjohnston> tg_: well it's basically the only thing about the language so far, and there are a few other things that have tempus in the name, so I'm just being safe for now
16:07:45 <parcs> > let const x y = x in const 5 undefined
16:07:46 <lambdabot>   5
16:08:11 * dankna hilariously misinterpreted "values" there
16:08:18 <Page15> Wouldn't that open up haskell to allowing it to have state?
16:08:23 <phrackSipsin> micahjohnston, thanks for the overview
16:08:27 <dankna> I read "timeless values" and I thought, "yeah, well-factored code is timeless"
16:08:29 <tg_> Page15: in a very, very specific way
16:08:30 <micahjohnston> so, the values can be different throughout time, which makes it so that you can model a game as a function from keypresses to images/sounds
16:08:33 <parcs> is there a difference in using _ instead of a quanitifier like x in the definition of const? anywhere?
16:08:41 <ocharles> oh, frp is functional reactive, not functional relational
16:08:43 <micahjohnston> phrackSipsin: no problem
16:08:44 <Page15> tg_: I see
16:08:50 <micahjohnston> ocharles: yeah, big difference, heh
16:08:54 <ocharles> yea :)
16:09:06 <ocharles> i'm more interested in relational stuff atm, there's a thesis somewhere that I was scanning
16:09:43 <micahjohnston> was it that one paper… “out of the tar pit”?
16:09:57 <Page15> Does there not exist a library for input and possibly a protect state import that only allows states within this import being used? Well like limited registers
16:10:10 <shamster> if I've got a variable 'v :: IO String', why can't I do something like 'lines v' without doing it like 'fmap lines v'?
16:10:26 <seydar> ooh ooh!
16:10:27 <seydar> call on me!
16:10:38 <shamster> I end up have to do 'fmap concat $ fmap (fmap words) $ fmap lines vec' with lots of fmaps
16:10:44 <mm_freak_> shamster: because 'lines' expects String, not IO String
16:10:46 <shamster> seydar... I see your hand up
16:10:54 <mm_freak_> :t lines
16:10:55 <lambdabot> String -> [String]
16:10:56 <seydar> hey mm_freak_ SHUT UP
16:10:58 <hpc> lol
16:11:00 <seydar> i got this shit
16:11:01 <micahjohnston> shamster: just like you can't do lines [String], etc.
16:11:10 <seydar> micahjohnston what the fuck did i just say
16:11:19 <micahjohnston> or lines (Maybe String)
16:11:20 <seydar> shamster: it's because the string is wrapped in saran wrap
16:11:23 <seydar> aka, a monad
16:11:35 <seydar> lines is expecting a string
16:11:38 <shamster> yes, I understand it's an IO String, but once I've used fmap once, why the extra fmaps for everything else I do on it?
16:11:38 <copumpkin> it isn't really because it's a monad
16:11:38 <seydar> but it's getting io string
16:11:42 <copumpkin> it's just because it isn't a string
16:11:46 <seydar> so you need to use fmap
16:11:46 <micahjohnston> seydar: it's irrelevant that it's a monad
16:11:51 <seydar> because fmap is like your mom
16:11:54 <mm_freak_> shamster: look at the types
16:11:59 <seydar> and it unwraps the sandwich
16:12:05 <seydar> so you can get to the tasty string
16:12:09 <mm_freak_> copumpkin: could you please clean up the dirt?
16:12:09 <shamster> yes, the types say it all...
16:12:31 <copumpkin> seydar: hey, don't be abusive :)
16:12:37 <seydar> copumpkin: i'll cut you
16:12:41 <shamster> isn't there some sugared way to avoid using all those fmaps?
16:12:42 <copumpkin> seydar: I'm serious :P
16:12:57 <shamster> so I can just get a String to work with instead of an IO String?
16:13:02 <copumpkin> shamster: do notation, or combine them yourself
16:13:10 <copumpkin> fmap f . fmap g = fmap (f . g)
16:13:15 <mm_freak_> shamster: an IO String is a computation, which returns a string…  it's not a string by itself…  but even then you shouldn't need too many fmaps
16:13:17 <copumpkin> you should only ever need to fmap once
16:13:17 <micahjohnston> there is the <*> opereator in Control.Applicative, which looks nicer
16:13:24 <hpc> shamster: (<$>) = fmap is defined in Functor, too
16:13:50 <Page15> If I had a long line (which is a file) how would I extract the 'data = ...' parts (including the bits after) ? I thought about filtering out all 'data' (e.g. isPrefixOf) and then getting the stuff after from the .tail 
16:13:54 <Page15> Is there a better way?
16:13:57 <shamster> copumpkin: so doing a whole string of compositions with an fmap in the front would clear it up?
16:14:11 <copumpkin> shamster: depends whether you consider that clearer :P
16:14:19 <copumpkin> shamster: but it's not bad, in my opinion
16:14:31 <copumpkin> depending on the specific case, it might be possible to make it cleaner
16:14:44 <micahjohnston> Cale: hey, you came up with the name for one of my favorite posts on frp!
16:15:10 <shamster> for example: fmap concat $ fmap (fmap words) $ fmap lines vec
16:15:14 <shamster> 3 fmaps in that
16:15:19 <shamster> it works as written
16:15:31 <shamster> and vec :: IO String
16:15:46 <copumpkin> fmap (concat . words . lines) vec ?
16:15:53 <seydar> copumpkin: hold on, so if i give you fmap and v :: IO String, can you get all macgyver on us and get us the string?
16:16:03 <copumpkin> no, definitely not
16:16:20 <shamster> copumpkin: that misses one step, I think
16:16:26 <copumpkin> oh fine
16:16:35 <copumpkin> fmap (concat . map words . lines) vec
16:16:45 <mm_freak_> concat . fmap words . lines <$> vec
16:17:14 <shamster> copumpkin: that works
16:17:26 <seydar> is there a less algorithmically evil way to do it?
16:17:40 <copumpkin> why is that evil?
16:17:46 <shamster> mm_freak_: <$> isn't in scope... where should it be?
16:17:51 <copumpkin> Data.Functor
16:18:05 <mm_freak_> Control.Applicative would be my choice
16:18:07 <c_wraith> It's also in Control.Applicative
16:18:20 <copumpkin> I think Control.Applicative just re-exports it these days
16:18:35 <seydar> copumpkin: because... it's not constant time when it can be?
16:18:45 <copumpkin> seydar: why is it not? :O
16:19:13 <seydar> copumpkin: because... lines O(m) for string of length m?
16:19:26 <seydar> same with words?
16:19:32 <copumpkin> that's part of his algorithm
16:19:34 <copumpkin> not what I did
16:19:43 <copumpkin> you have m bytes of input, you can't ignore any of it
16:19:50 <copumpkin> so O(m) is pretty much your lower bound there
16:20:09 <Page15> Is http://learnyouahaskell.com/input-and-output the best thing to read for file manipulation?
16:20:24 <hpc> Page15: it's a good place to start
16:20:31 <Page15> hpc: thanks
16:20:40 * hpc reads and sees how much it covers
16:21:06 <ocharles> Page15: what you want to do is not just about reading files
16:21:17 <ocharles> sounds like you want to do parsing too
16:21:20 <hpc> yeah, it's pretty good
16:21:26 <Page15> ocharles: True
16:21:30 <hpc> it covers file handles, even
16:21:34 <Page15> hpc: Ok, ill trundle through it
16:21:48 <ocharles> Page15: while your format seems simple, you might also want to check out the parsec chapter in real world haskell
16:21:53 <ocharles> probably overkill though
16:22:08 <mm_freak_> copumpkin: using Data.Functor i'd end up rewriting it to Control.Applicative all the time anyway
16:22:27 <seydar> copumpkin: well i was just hoping for like a secret pointer switch that somehow didn't violate any laws
16:22:51 <copumpkin> seydar: there's no getting around traversing the entire list :)
16:23:42 <Page15> ocharles: Where is that one?
16:24:01 <ocharles> book.realworldhaskell.org/read/using-parsec.html
16:24:10 <Page15> ocharles: ta
16:24:33 <ocharles> You'll want a good understanding of functors (and applicative functors) to really get the most, and I found learn you a haskell clearer for explaining that
16:24:40 <ocharles> if you decide to persue this line anyway
16:24:49 <Page15> Yep i've got my head around functors
16:25:15 <Page15> And your quite right that site did help alot for that
16:29:41 <hpc> Page15: http://hyperboleandahalf.blogspot.com/2010/04/alot-is-better-than-you-at-everything.html
16:29:45 <hpc> :D
16:30:16 <Page15> haha point taken :)
16:30:53 <Page15> But the first line of that link is missing a word - quite ironic
16:32:54 <Page15> *a lot
16:32:56 <Page15> :D
16:34:10 <int80_h> I'm looking for simple usage examples of System.Posix.Signals. Something that catches a signal and prints out an acknowledgement. Google isn't helping too much. Anyone know of anythign out there?
16:34:46 <Page15> If Google doesnt have the answer - my brain is broken for a result....
16:35:15 <Page15> Tried google.de?
16:35:24 <int80_h> I'm sure has the answer, as it always does. But it's hiding the answer. Prolly due to me not asking the right question.
16:36:05 <Page15> Come sooner the day I compete the project whereby you select your input data, output data and BANG out comes a program...
16:36:16 <Page15> *complete
16:36:33 <Page15> ...*thinks* isnt that a function ?
16:37:20 <Page15> Nothing useful on http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.4.1.0/System-Posix-Signals.html ?
16:37:43 <int80_h> oh I'm looking here right now http://www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/System-Posix-Signals.html
16:37:49 <int80_h> oops
16:38:02 <Page15> :D
16:38:20 <Page15> Same page
16:40:10 <monochrom> int80_h: http://hpaste.org/43991/signals  give it SIGUSR1 to get "xxx"
16:40:27 <int80_h> monochrom: thanks!
16:40:43 <Page15> example: ""my left foot" =~ "foo" :: Bool
16:40:43 <Page15> " doesnt work in my ghci. Error: "unable to load package array-0.3.0.1". Ideas?
16:41:14 <int80_h> I considered using C for this part of my project, but I think I'll keep going with haskell.
16:45:07 <Page15> Is there a way to update ghci in windows?
16:48:40 <Page15> How do I install the package to use "regex-posix-0.94.2" ?
16:55:04 <Jesin> I wrote the State monad in terms of fmap, join, and return in an attempt to understand how it works.  Did I get it right?
16:55:07 <Jesin> http://hpaste.org/43992/fmap_join_return_of_state
16:55:34 <shachaf> Jesin: If the types work out then yes.
16:55:47 <Jesin> no
16:56:19 <Jesin> I don't think so...
16:57:23 <Jesin> I think there are at least two different joins that satisfy the types and compile with no errors
16:57:27 <Jesin> join m1 = State $ \s1 -> let (m2,s2) = runState m1 s1 in runState m2 s2
16:57:31 <Jesin> is the correct one, I think
16:57:37 <Jesin> but, this would also compile:
16:57:42 <Jesin> join m1 = State $ \s1 -> let (m2,s2) = runState m1 s1 in runState m2 s1
16:57:46 <Page15> Whats the main haskell regex module to use?
16:57:53 <shachaf> True.
17:00:36 <shachaf> Guest23063: ?
17:09:48 <shamster> can someone explain a nuance of haskell Re: composition vs application? what is the difference between 'f $ g a' and '(f . g) a' ??
17:10:15 <shamster> or are they the same but different in syntax?
17:10:25 <kmc> effectively the same
17:10:27 <dolio> Those are the same expression.
17:10:33 <kmc> much as (2+2) and (1+3) are the same
17:10:44 <kmc> or indeed (2+2) and (2*2)
17:10:49 <kmc> the same answer arrived at by a different means
17:10:58 <almostsix> I think they *might* be lazy in different ways. But they're certainly the same besides that
17:11:05 <shamster> kmc: well, maybe more analogous would be 2+(4+5) and (2+4)+5
17:11:23 <kmc> maybe, but that only involves one operator whereas ($) and (.) are different operators
17:11:28 <shachaf> shamster: No, that would be (f . g) . h and f . (g . h).
17:11:41 <shamster> shachaf: oh, true
17:11:49 <luite> shamster: the important thing to realize is that (f . g) is a function, but (f $ g) isn't
17:11:52 <shachaf> Anyway, ($) = id.
17:11:56 <kmc> it is hard to say whether two functions are "the same", but if you use the definition "same answer on same input" then (f . g) and (\x -> f $ g x) are the same
17:12:09 <nosila> hey
17:12:13 <kmc> (f $ g) could be a function, but not in general
17:12:14 <shachaf> kmc: Except in lambdabot. :-)
17:12:17 <kmc> ;P
17:12:18 <nosila> if i have a TimeDiff
17:12:25 <nosila> from Time
17:12:26 <nosila> http://zvon.org/other/haskell/Outputtime/TimeDiffQ_d.html
17:12:35 <nosila> how can i get the values inside of it???
17:12:39 <shamster> kmc: if f $ g is a partial application of a function...
17:12:48 <kmc> right
17:12:52 <kmc> if f is a function that returns another function
17:12:58 <kmc> which colloquially we'd call a "two argument function"
17:13:05 <kmc> then (f $ g) will be a function
17:13:12 <kmc> like (map $ succ) is a function
17:13:16 <kmc> but you might as well write (map succ)
17:13:17 <luite> shamster: so if you use function composition with (.), you have functions that you can factor out, so that you can reuse them, while with ($) you'd have to restructure first
17:13:42 <kmc> nosila, http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/haskell98-1.1.0.0/Time.html
17:13:46 <shamster> I think 'partially applied function' may work
17:13:47 <kmc> the zvon site is.... weird
17:13:56 <shamster> anyway, thanks!
17:13:58 <kmc> it can be helpful, but i mostly recommend you look at http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
17:14:18 <kmc> nosila, anyway, both of them give a definition of TimeDiff as a record type
17:14:24 <kmc> so you can either pattern-match or use the record accessors
17:14:40 <nosila> how?
17:15:02 <nosila> like, i have a TimeDiff, i just want to acess to tdYear :: InttdMonth :: InttdDay :: InttdHour :: InttdMin :: InttdSec :: Int
17:15:12 <nosila> dont know the sintax to do that =S
17:15:28 <kmc> you could read a Haskell tutorial / reference
17:15:30 <kmc> but it goes like this
17:15:43 <kmc> case myTimeDiff of TimeDiff { tdYear = yr, tdSec = sec } -> ...
17:15:54 <kmc> or if you're defining a function,   f (TimeDiff { tdYear = yr, tdSec = sec }) = ...
17:16:02 <kmc> would define yr and sec locally
17:16:10 <kmc> of course you can pick whichever fields you care about
17:16:13 <kmc> that's the pattern-matching option
17:16:27 <kmc> but also the field names act like functions from the record type to that field
17:16:36 <kmc> tdYear :: TimeDiff -> Int, tdPicosec :: TimeDiff -> Integer
17:16:41 <kmc> so you could just say (tdYear myTimeDiff)
17:17:52 <nosila> didnt understood the last one
17:18:23 <kmc> could you elaborate?
17:18:37 <nosila> (tdYear myTimeDiff)
17:18:47 <kmc> record fields act like accessor functions
17:18:51 <nosila> that, didnt understood the context of that,
17:18:53 <kmc> when you use them outside of record syntax
17:18:58 <accel> silly question: is a there a Haskell DSL that _only_ outputs valid LaTeX files?
17:19:05 <kmc> so tdYear is a function of type TimeDiff -> Int
17:19:09 <accel> silly question: is a there a Haskell DSL that _only_ outputs valid LaTeX files? (through the magic of typing / getting various math/text modes right)
17:19:15 <kmc> which gets the year out of a TimeDiff structure
17:19:28 <nosila> really? gonna try that
17:19:28 <nosila> ;9
17:20:37 <kmc> accel, for a strong definition of "valid LaTeX file" the problem is uncomputable, so it would have to be incomplete / conservative
17:20:44 <kmc> however there's probably a useful weak definition
17:20:55 <kmc> most languages have decidable syntactic correctness
17:21:20 <kmc> (Perl and C++ excluded and i'm not surprised if TeX is included too)
17:21:32 <kmc> TeX doesn't really have structured syntax, just a stream of macros that can redefine each other
17:22:08 <accel> silly question: is a there a Haskell DSL that _only_ outputs valid LaTeX files? (through the magic of typing / getting various math/text modes right) [alright, in practice; I realize TeX is turing complete; and thus, by the halting problem, ... ]
17:22:20 <accel> kmc: in practice is there something semi-usable?
17:22:32 <kmc> i don't know
17:22:35 <accel> okay
17:22:45 <accel> you remind me of someone
17:22:54 <accel> that likes to show off technical knowledge in the absence of content ...
17:22:55 <accel> i.e. myself
17:23:01 <kmc> thanks
17:23:18 <accel> i think it would be nice
17:23:24 <accel> if all my TeX math formulas were generated from Haskell
17:23:26 <accel> the one day, I can turn around
17:23:34 <accel> and feed those haskell structures into a theorem prover
17:23:54 <kmc> accel did you try going to hackage and searching for "LaTeX"?
17:23:54 <accel> i.e. math formulas --> expressed in some haskell data structure --> one printer gnerates LaTEx, another format sends it to logic verificer
17:24:03 <nosila> kmc: thanks, think i got it now, just have to test this
17:24:08 <accel> nah; I used google
17:24:27 <accel> HaTex
17:24:39 <kmc> if you want to know if a haskell library exists, go to http://hackage.haskell.org/packages/archive/pkg-list.html
17:24:44 <kmc> and use Ctrl-F or maybe their search box
17:24:53 <accel> kmc: do you see anything interesting besides HaTeX/
17:25:01 <kmc> i didn't look
17:25:07 <accel> http://www.haskell.org/haskellwiki/HaTeX
17:25:10 <accel> is almost word for word what I want
17:25:19 <accel> kmc++
17:25:26 <accel> oh wait, this is haskell, can't modify; too bad
17:25:32 <kmc> @karma accel
17:25:32 <lambdabot> accel has a karma of 0
17:25:38 <int80_h> exit
17:25:58 <accel> @karma kmc
17:25:58 <lambdabot> kmc has a karma of 8
17:26:07 <accel> help karma
17:26:09 <accel> @help karma
17:26:09 <lambdabot> karma <polynick>. Return a person's karma value
17:26:12 <kmc> accel, clearly karma is stored in an IORef ;P
17:26:17 <accel> @bless kmc
17:26:17 <lambdabot> Unknown command, try @list
17:26:19 <accel> @list
17:26:20 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:26:37 <accel> @karma+ kmc
17:26:38 <lambdabot> kmc's karma raised to 9.
17:26:48 <accel> @karma+ kmc
17:26:49 <lambdabot> kmc's karma raised to 10.
17:26:55 <accel> @karma+ kmc
17:26:56 <lambdabot> kmc's karma raised to 11.
17:26:56 <accel> @karma+ kmc
17:26:57 <lambdabot> kmc's karma raised to 12.
17:26:58 <accel> @karma+ kmc
17:26:58 <lambdabot> kmc's karma raised to 13.
17:26:59 <accel> @karma+ kmc
17:26:59 <lambdabot> kmc's karma raised to 14.
17:27:03 <accel> hmm; there's no limit?
17:27:05 <accel> @karma+ accel
17:27:06 <lambdabot> You can't change your own karma, silly.
17:27:18 <kmc> accel, you can play with the bot in private message
17:27:19 <shachaf> accel: It's presumed that people won't abuse it.
17:27:26 <kmc> it's presumed that people won't use it, empirically
17:27:31 <accel_> @karma+ accel
17:27:31 <lambdabot> accel's karma raised to 1.
17:27:36 <accel> lol
17:27:37 <shachaf> Except for Perl 6 people.
17:27:48 <accel> silly lambdabot; needs better identity checking
17:28:12 <shachaf> Hooray, you've found a back door in our otherwise perfect security.
17:28:26 <shachaf> Feel free to submit a patch.
17:28:31 <accel> yeah; I can arbitrarily manipulate karma now
17:28:31 <accel> woot
17:28:46 <nosila> @karma+ kmc
17:28:47 <lambdabot> kmc's karma raised to 15.
17:28:49 <accel> i'm going to go sit on the side and wait for my nobel prize to arrive int he mail
17:29:46 <shachaf> accel: Or you could just not abuse lambdabot.
17:29:53 <nosila> omfgLOOL
17:31:34 <accel> shachaf: do you have ops?
17:32:03 <accel> iw sumpus any good?
17:32:11 <accel> *wumpus* the postscript/svg generation library
17:35:44 <Veinor> hm.
17:36:10 <Veinor> so how exactly do functors in haskell relate to category theory functors?
17:36:26 <Veinor> i mean i get that fmap is the part of the functor that associates morphisms to morphisms
17:38:00 <Veinor> oh, are they endofunctors in Hask?
17:38:19 <kmc> yes
17:38:25 <kmc> that is, that's what Prelude.Functor models
17:38:35 <kmc> you'll find more general functor classes in category-extras
17:38:40 <Veinor> right, right
17:39:24 <kmc> class Functor (~>) (~~>) s t where { fmap :: (s a ~> s b) -> (t a ~~> t b) }
17:39:25 <kmc> or something
17:40:58 <Page15> Ok, ok getting annoyed with modules. Is there a prelude or a default package that will remove white space and defined string from a given string?
17:41:40 <Cale> Page15: I don't understand what you're looking for
17:41:57 <Cale> > filter (not . isSpace) "this   string has\n some \t whitespace in it"
17:41:58 <lambdabot>   "thisstringhassomewhitespaceinit"
17:42:00 <Page15> e.g. replace " " with "." in "My String"
17:42:25 <Cale> > map (\x -> if isSpace x then "." else x) "this   string has\n some \t whitespace in it"
17:42:26 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:42:26 <lambdabot>         against inferred ty...
17:42:28 <Cale> oops
17:42:32 <Cale> > map (\x -> if isSpace x then '.' else x) "this   string has\n some \t whitespace in it"
17:42:33 <lambdabot>   "this...string.has..some...whitespace.in.it"
17:43:29 <Page15> Thanks. (finds what package .isSpace is in)
17:43:54 <Cale> Data.Char
17:44:18 <Page15> Thanks
17:44:43 <luite> Page15: you can use hoogle,  http://www.haskell.org/hoogle/ to easily find these things
17:45:03 <Page15> Ah cool thanks
17:45:17 <luite> but I'm not sure how much of hackage is indexed by hoogle
17:45:47 <RyanN_> Hi all.  Quick question -- if my cabal package wants to import PART of a package and hide another part (to avoid conflicts/ambiguous imports) -- can that be done? 
17:47:49 <luite> RyanN_: you can use both, either import only the functions you need. import A.B.Module (funtion1, function2), or import A.B.Module hiding (...). You can use more than one import if necessary
17:48:13 <luite> RyanN_: another way is importing qualified
17:48:48 <kmc> RyanN_, my rule of thumb is to do an open import for "standard stuff" (Data.Maybe, Control.Monad, etc) and to import anything else qualified mostly
17:48:49 <luite> oh oops
17:48:51 <RyanN_> Ah thanks luite, but my quetsion is not what to write in the haskell code but what to write in the .cabal file or what args to pass to ghc.  GHC exposes the --hide-package option.
17:48:59 <luite> yeah I realize
17:49:17 <kmc> oh, for that you can use package-qualified imports
17:49:17 <RyanN_> Ok, maybe I'm missing something in your answer then, luite.
17:49:18 <kmc> a GHC extension
17:49:23 <RyanN_> Yay!
17:49:23 <kmc> kind of a hack though
17:49:33 <RyanN_> Package qualified imports would do it.
17:49:47 <kmc> it's not really intended as an end-user feature, but it's probably the easiest solution here
17:49:47 <RyanN_> There's two packages, Foo and Bar that both provide module Quux
17:49:54 <RyanN_> I can't think of any other way t o manage it.
17:50:01 <kmc> the other way is to create multiple packages yourself :/
17:50:04 <luite> RyanN_: no I saw too late what you wanted
17:50:13 <RyanN_> Because I need part of foo (but not the Quux part)  and Quux from package bar.
17:50:18 <luite> yeah package qualified imports are rather ugly
17:50:41 <kmc> hmmm.... i wonder if you could use {-# OPTIONS_GHC -package foo #-}
17:50:45 <kmc> probably a bad idea that will confuse cabal
17:51:08 <kmc> haha @ Watson_tied_1st_
17:51:48 <RyanN_> Ah, kmc, if I'm following you by using the OPTIONS_GHC on a per-file basis... then I could on a file-by-file basis decide whether foo or bar is visible
17:51:49 <RyanN_> ?
17:52:04 <kmc> right
17:52:05 <dino-> Watson had some confused periods, but was kicking ass in places.
17:52:11 <kmc> but i expect it will break somewhere RyanN_
17:52:33 <kmc> watson dominated the easy questions due to being the fastest at the buzzer
17:52:45 <kmc> and he knew this and picked the easy questions, rather than clearing a column as humans often do
17:52:53 <RyanN_> (This is Data.LargeWord btw... which has just been factored into its own package, but still exists inside crypto-api as well.)
17:55:02 <copumpkin> Data.Word.Bird
17:56:18 <Kaidelong> curses
17:57:45 <kmc> bird is the word
18:01:21 <Jesin> @src runcurry
18:01:21 <lambdabot> Source not found. Sorry.
18:01:26 <Jesin> @src uncurry
18:01:27 <lambdabot> uncurry f p = f (fst p) (snd p)
18:01:30 <Jesin> :p
18:01:38 <Jesin> eh.
18:02:31 <latros> how do I remove monads-fd
18:02:53 <latros> I removed it from my .cabal, and my package manager doesn't seem to have been the mechanism by which I installed it
18:03:15 <latros> waaaaaait
18:03:16 <latros> sec
18:03:33 <latros> nope that didn't do it either
18:07:46 <luite> RyanN_: it seems to have been removed in crypto-api 0.5, so I'd just bump the dependency to crypto-api >= 0.5 in this case :)
18:08:45 <luite> (probably best to have an upper bound as well)
18:12:11 <RyanN_> (Thanks luite, good catch.)
18:13:53 * hackagebot intel-aes 0.1.2.2 - Hardware accelerated AES encryption and RNG.  http://hackage.haskell.org/package/intel-aes-0.1.2.2 (RyanNewton)
18:16:59 <kmc> latros, ghc-pkg unregister ?
18:17:39 * mjrosenb tries to never install anything not by my package manager
18:22:10 <duckinator> hi
18:25:55 <Page15> Is it possible to split up a string by a '\n' and '=' ?
18:26:15 <kmc> http://hackage.haskell.org/package/split
18:26:22 <kmc> for the former you might want "lines"
18:26:31 <kmc> but the split functions in the stdlib are limited
18:26:49 <Page15> I'm having trouble using another but the stblib
18:26:55 <Page15> *anything
18:27:11 <luite> have you installed the haskell platform?
18:27:17 <Page15> ghci
18:27:29 <Page15> So yes
18:27:38 <luite> but did you use the ghc installer or the platform installer?
18:28:06 <Page15> http://www.haskell.org/ghc/download_ghc_622 The Windows one there
18:28:15 <Page15> ghc-6-2-2.msi
18:28:17 <luite> there's a difference, ghc is just the compiler with basic libraries, the platform contains additional tools and libraries
18:29:05 <Page15> Which do I have from that link?
18:29:13 <luite> ghc
18:29:28 <luite> what you really downloaded ghc 6.2.2
18:29:38 <copumpkin> o.O
18:29:39 <copumpkin> wow
18:30:02 <Page15> ?
18:30:25 <luite> Page15: that version is very old, many packages will not work with it anymore. it's best to uninstall ghc and download the haskell platform from here: http://hackage.haskell.org/platform/
18:30:46 <Page15> Ok
18:31:44 <luite> Page15: after you have installed the haskell platform, it's very easy to install packages. you need the split package, right? then just open a command prompt and enter > cabal update   followed by > cabal install split
18:31:59 <Page15> And this can be done in windows?
18:32:01 <luite> you only have to run cabal update once
18:32:14 <luite> yes
18:32:21 <Page15> ok
18:34:29 <Page15> I don't think it was right I got a read error upon extracting starting :s
18:35:33 <luite> maybe the download was not complete, try to download it again, or try the torrent 
18:35:47 <Page15> It continued once I pressed ignore
18:36:02 <Page15> But it was ghc.exe which slightly concerned me, lol
18:39:08 <Page15> Well the one I downloaded was all the stuff I already had
18:39:27 <Page15> So how do I run cabal update?
18:39:56 <luite> first check that you have the right ghc version installed, open a command prompt and type ghc --version
18:40:26 <Page15> 6.12.3
18:41:33 <luite> ok, yes, then the two commands that I just mentioned, cabal update, cabal install split
18:42:53 <Page15> All done.
18:43:14 <luite> ok, you should now be able to import Data.List.Split in ghci or your .hs files
18:43:38 <Page15> wow virus scanner just went crazy
18:44:10 <Page15> Interesting...
18:44:36 <Page15> Yep works now
18:44:38 <Page15> Thanks
18:45:39 <Bynbo7> copumpkin: you about?
18:45:42 <Page15> Not sure why my virus kicked off though - but ohwell...
18:45:48 <copumpkin> Bynbo7: yep
18:45:57 <Page15> *scanner
18:46:07 <luite> as far as I know, the split package doesn't contain viruses :)
18:46:42 <Bynbo7> copumpkin: i don't suppose there's a video to go along with those agda slides is there? they don't make much sense to me without explanation
18:46:43 <Page15> I don't imagine it would have but some temp file the haskell platform created was picked up
18:46:57 <Page15> Welcome to learning Agda :D
18:47:31 <copumpkin> Bynbo7: there is, but I don't think it worked very well. The camera wasn't really pointing in the right direction, and apart from that, I'm not actually very good at giving talks :P either way, you'd have to ask edwardk since the camera was his
18:47:49 <copumpkin> Bynbo7: there's always the #agda channel though
18:47:51 <Bynbo7> ah righto
18:47:54 <Page15> Indeed
18:48:07 <Bynbo7> not sure agda is for me, but it does look interesting
18:48:26 <copumpkin> if you have any specific questions about slides, I can elaborate
18:48:30 <Page15> I gave up learning Agda because of the lack of interest it in, but I know why and when it would be useful
18:48:34 <copumpkin> would probably be more appropriate in there
18:48:52 <Bynbo7> if i can think of anything, I'll ask
18:49:08 <copumpkin> ok :)
18:49:26 <Bynbo7> does agda not install with ghc7?
18:49:41 <copumpkin> not sure, I've never really used the cabal version
18:49:46 <copumpkin> or the hackage version, I should say
18:50:06 <Bynbo7> says it needs base ==4.2.*
18:50:39 <Page15> I believe there is windows version, but the only way I got it to work was via that and it used emacs
18:51:31 <Page15> But I find it much easier to load up a virtual machine with linux on
18:51:36 <Page15> *found
19:04:51 <jcullen> l
19:05:16 <Page15> 2
19:05:27 <drhodes> k, 3
19:05:47 <Page15> (k+1), 4
19:05:57 <monochrom> > ['l', 'k' ..]
19:05:58 <lambdabot>   "lkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$...
19:06:19 <Page15> [1,2,3.. 10]
19:07:02 <monochrom> > [1,2,3 .. 10]
19:07:03 <lambdabot>   <no location info>: parse error on input `..'
19:07:32 <Page15> Fair enough, lol
19:07:46 <Page15> sum [1,2,3 .. 10]
19:07:55 <latros> it's arithmetic, so you're not really allowed to have three things at the head
19:08:01 <Page15> sum [1,2 .. 10]
19:08:10 <latros> > sum [1,2..10]
19:08:11 <lambdabot>   55
19:08:16 <Page15> sum [1,2.. 10]
19:08:27 <Page15> sum [1,2..10]
19:08:32 <drhodes> >
19:08:33 <Page15> > sum [1,2..10]
19:08:33 <lambdabot>   55
19:08:36 <latros> you need the >
19:08:36 <Page15> Ah :)
19:08:44 <Page15> > sum [1,2,3..10]
19:08:45 <lambdabot>   <no location info>: parse error on input `..'
19:08:47 <monochrom> (It was so obvious...)
19:08:50 <Page15> > sum [1,2,3 ..10]
19:08:51 <lambdabot>   <no location info>: parse error on input `..'
19:08:51 <Page15> haha
19:09:03 <Page15> > sum [1,2 .. 10]
19:09:04 <lambdabot>   55
19:09:09 <Page15> > sum [1,2 .. 100]
19:09:10 <lambdabot>   5050
19:09:12 <Page15> > sum [1,2 .. 1000]
19:09:13 <lambdabot>   500500
19:09:15 <Page15> > sum [1,2 .. 10000]
19:09:16 <lambdabot>   50005000
19:09:18 <Page15> > sum [1,2 .. 100000]
19:09:19 <lambdabot>   5000050000
19:09:40 <Page15> Interesting pattern
19:09:46 <latros> easy enough to prove
19:09:55 <latros> sum(i=1 to n) i = n(n+1)/2
19:10:02 <latros> make n a power of 10, and magic ensues
19:10:43 <Page15> hmmm ok
19:10:50 <Page15> Prove that :p
19:10:52 <latros> the sum can be done like this:
19:10:59 <latros> S = 1 + 2 + ... + n
19:11:05 <latros> S = n + (n-1) + ... + 1
19:11:14 <latros> 2S = (n+1) + (n+1) + ... + (n+1)
19:11:17 <latros> (n of them)
19:11:22 <latros> 2S = n(n+1)
19:11:25 <latros> S = n(n+1)/2
19:11:36 <latros> Gauss supposedly did this in elementary school to get out of manually doing sum(i=1 to 100) i
19:11:51 <Page15> Yep I heard that story too
19:12:02 <Page15> He was asked to go add up the numbers 1 to 10 to be kept busy
19:12:04 <Page15> Then 1 to 100
19:12:08 <Page15> Then 1 to 1000
19:12:13 <latros> 1000, really?
19:12:16 <Page15> He kept coming back in less than a couple of minutes
19:12:17 <latros> never heard that part of the story
19:12:29 <Page15> Teacher was amazed
19:14:08 <dankna> the way I heard it the teacher was annoyed because he himself had worked it out the hard way :)
19:14:12 <latros> anyway, you want to show that 10^n(10^n+1)/2 = 5*10^(2n-1) + 5*10^(n-1)
19:14:18 <latros> to make the pattern work
19:14:46 <Kaidelong> Page15: the story I heard was that the teacher was upset
19:14:56 <luite> hmm, I only know the version with 100, and that gauss presumably found the answer by pairing 1 with 100, 2 with 99 etc
19:15:36 <latros> 10^n(10^n+1) = 10^(2n)+10^n
19:15:41 <monochrom> I was that teacher. I was not upset. I decided to switch to CS instead.
19:15:46 <Page15> Haha
19:15:50 <latros> 10^n(10^n+1)/2 = 5*10^(2n-1) + 5*10^(n-1)
19:15:51 <latros> done
19:15:53 <latros> :p
19:26:32 <xiackok> hi everyone, is there any functional performance tricks?
19:26:53 <sm-afk> here ya go: http://johantibell.com/files/slides.pdf
19:27:20 <opengeard> Find all integers in an array divisible by 3.  filter (`mod` 3 == 0) [1..30]  ... seems to be missing something.
19:27:31 <mauke> yeah, the array
19:27:57 <mauke> ((== 0) . (`mod` 3))
19:28:05 <shachaf> opengeard: Try writing it out explicitly first, rather than using sections.
19:28:09 <opengeard> ??
19:28:11 <xiackok> sm: thanks
19:28:34 <opengeard> is there a map missing?
19:29:20 <nosila> Hey
19:29:22 <opengeard> Disregard previous.
19:29:36 <nosila> anyway to have maybe function
19:30:11 <nosila> do the Just function with more arguments apart from the return of the "main" function?
19:30:12 <nosila> ??
19:30:23 <latros> what?
19:30:45 <nosila> i have users in a BSTree
19:30:55 <nosila> have a function that return Maybe User
19:30:59 <nosila> then i use
19:31:01 <monochrom> yeah, not sure what you mean, and not sure where "most arguments" come from in the first place.
19:31:07 <monochrom> s/most/more/
19:31:53 <nosila> maybe userNotFound userFoundDoSomething (findUser user)
19:32:02 <latros> ok?
19:32:04 <nosila> BUT, in userFoundDoSomething
19:32:33 <opengeard> filter (expression) [N..M]    # correct?
19:32:35 <nosila> i want a function that receives the user and a string
19:32:45 <monochrom> maybe userNotFound (\x -> whatever you say x is a cool user and you can use x several times too x x x) (findUser user)
19:32:56 <latros> umm
19:33:09 <latros> if you want to use "maybe" with different types from its actual type
19:33:17 <latros> maybe it'll help to actually see the definition of "maybe"?
19:33:19 <latros> and then change it?
19:33:33 <monochrom> maybe userNotFound (\x -> whatever x x x x "hello" x "hi") (findUser user)
19:33:34 <latros> maybe x _ Nothing = x
19:33:44 <latros> maybe _ f (Just x) = Just (f x)
19:33:57 <latros> er
19:33:58 <latros> sorry
19:33:59 <latros> no Just
19:34:02 <latros> in the output
19:34:05 <nosila> yeap i know ;)
19:34:07 <latros> maybe _ f (Just x) = x
19:34:08 <latros> er
19:34:09 <latros> dammit
19:34:13 <latros> maybe _ f (Just x) = f x
19:34:14 <mauke> @src maybe
19:34:15 <lambdabot> maybe n _ Nothing  = n
19:34:15 <lambdabot> maybe _ f (Just x) = f x
19:34:15 <latros> there we go
19:34:22 <accel> window 3
19:34:23 <latros> or I could've done that
19:34:24 <nosila> apart from creating a "new" maybe
19:34:33 <latros> maybe has the type it has :P
19:34:39 <nosila> let me think about monochrom one
19:35:04 <latros> but, if the string is something you already have defined or something then it could work
19:35:09 <monochrom> > maybe "" (\x -> "have " ++ x ++ " and " ++ x ++ " again") (Just "hi")
19:35:11 <lambdabot>   "have hi and hi again"
19:35:12 <latros> I dunno how exactly you want to call this
19:35:58 <latros> where does the string come in, in the context of the call to this function?
19:36:12 <monochrom> it doesn't matter, just use a lambda
19:36:28 <latros> depends, if he wants the string to be an arg
19:36:30 <latros> it won't work
19:36:35 <monochrom> (but of course presumably the string is already in scope)
19:37:11 <monochrom> defining a new maybe doesn't change anything
19:37:28 <latros> it would if you want to pass it more args
19:37:39 <monochrom> and conversely if the string is not already in scope there is no way to obtain it
19:38:17 <latros> well yeah, of course it's in scope overall, but is it something that you're plopping directly into the function definition, or is it passed as an argument
19:38:21 <monochrom> new'maybe a b c = maybe a f c
19:38:40 <nosila> the lambda should work fine
19:38:42 <nosila> buuut
19:38:49 <nosila> i'm having some problems, trying to solve
19:39:10 <nosila> but the lambda idea was nice, thanks, gonna try to solve this out ;)
19:39:18 <nosila> i'm using this
19:39:30 <nosila> (\user-> doSomethingFancy user string)
19:39:34 <monochrom> typo, but nevermind
19:43:26 <opengeard> interesting... map (mod 3) [1..30]   # => [0,1,0,3,3 ... 3]
19:43:53 <copumpkin> not sure I'd call that interesting :P
19:44:20 <opengeard> Well it doesn't make sense from any normal paradigm.
19:44:24 <monochrom> numerology interests a lot of people
19:44:28 <latros> wait, 3?
19:44:30 <copumpkin> you have it backwards
19:44:34 <latros> how do you get 3 out of that
19:44:36 <copumpkin> > map (mod 3) [1..30]
19:44:37 <lambdabot>   [0,1,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]
19:44:40 <copumpkin> > map (`mod` 3) [1..30]
19:44:41 <lambdabot>   [1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0]
19:44:44 <monochrom> > 3 `mod` 10
19:44:44 <lambdabot>   3
19:44:45 <latros> oh, right
19:44:51 <kulakowski> > map (flip mod 3) [1..10]
19:44:52 <opengeard> infix vs prefix
19:44:52 <lambdabot>   [1,2,0,1,2,0,1,2,0,1]
19:44:54 <latros> 3 mod blah = 3 for sufficiently large blah
19:45:10 <parcs> @src mod
19:45:10 <latros> (in non-haskell notation)
19:45:10 <lambdabot> Source not found. That's something I cannot allow to happen.
19:45:23 <latros> mod is probably internal
19:45:29 <latros> involves how it does division, which is primitive
19:45:37 <latros> or at least relatively so
19:46:00 <opengeard> Makes more sense now.
19:46:11 <nosila> think i got it to work, thanks  for the tip monochrom: ;)
19:46:44 <monochrom> you're welcome
19:46:48 <nosila> working
19:46:49 <nosila> ;)
19:47:14 <nosila> btw
19:47:15 <opengeard> what's the easiest way to pick elements divisible by 3?
19:47:30 <nosila> any way to pause the program without using system "pause" ??
19:47:42 <copumpkin> nosila: threadDelay
19:47:43 <monochrom> > filter (\x -> x `mod` 3 == 0) [3,1,4,1,5,9]
19:47:44 <lambdabot>   [3,9]
19:47:45 <copumpkin> @hoogle threadDelay
19:47:46 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
19:48:13 <monochrom> beware that threadDelay 1000000 delays 1 second.
19:48:14 <opengeard> ahhh that's how to grab that implicit index var. :D
19:48:21 <parcs> > [3,6..]
19:48:22 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
19:48:31 <opengeard> ty, ty!
19:49:05 <opengeard> ... and there was much rejoicing
19:49:36 <monochrom> the power of lambda
19:50:45 <nosila> something like system "cls" ???
19:50:48 <opengeard> just coming from py w/ 4-5 chains of list comprehensions
19:51:12 <nosila> copumpkin thanks but i dont want to delay it, want to wait for user input but i was being stupid, gonna test it with a simple getLine
19:51:27 <copumpkin> oh yeah
19:51:32 <copumpkin> getLine >> return ()
19:51:40 <monochrom> user input is an MSc project
19:51:53 <opengeard> besides the web interface, is there a worksheet oriented haskell expression evaluator environment like reinteract?
19:52:11 <parcs> nosila: the package ansi-terminal contains screen-clearing functions
19:52:42 <nosila> yep, getline does what i want ;9
19:52:43 <nosila> ;)
19:53:25 <nosila> parcs: anything that is "default" in haskell?
19:53:42 <parcs> don't think so
19:53:42 <nosila> this is for a school project and i didnt want to use 'extra' stuff
19:53:53 <nosila> ok thanks for all the help ;)
20:13:21 * hackagebot vector-buffer 0.2 - A buffer compatible with Data.Vector.Storable  http://hackage.haskell.org/package/vector-buffer-0.2 (VivianMcPhail)
20:22:37 <lispy> GHC's core is lazy but all the pattern matches in it are strict, right?
20:23:51 <copumpkin> yeah, pattern matches have to be strict for it to know what to do next
20:24:24 * hackagebot hamlet 0.7.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.7.1 (MichaelSnoyman)
20:25:26 * hackagebot json-enumerator 0.0.1 - Pure-Haskell utilities for dealing with JSON with the enumerator package.  http://hackage.haskell.org/package/json-enumerator-0.0.1 (MichaelSnoyman)
20:37:19 <lispy> copumpkin: right, but everything else is still lazy?
20:38:30 * hackagebot persistent 0.4.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.4.1 (MichaelSnoyman)
20:38:32 * hackagebot yesod-persistent 0.0.0.1 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-0.0.0.1 (MichaelSnoyman)
20:39:05 <latros> /everything/? no, not quite everything...
20:39:21 <latros> oh wait
20:39:22 <latros> core
20:39:28 <latros> as in, how the compiler works
20:39:30 <latros> ignore me
20:40:07 <accel> cabal install is way too fucking cool
20:40:10 <accel> it's like in the matrix
20:40:22 <accel> where trinity goes "download helicopter control brain"
20:40:26 <accel> awio;jfakl;sdjfaskl;jdfl;asdjfkl;sjdfklasdf
20:40:30 <accel> and then she can fly the helicopter
20:40:33 <accel> that ... is cabal install
20:41:23 <mauke> > "\e"
20:41:24 <lambdabot>   <no location info>:
20:41:24 <lambdabot>      lexical error in string/character literal at chara...
20:42:25 <lispy> accel: heh, just wait until it corrupts your pkg db.  Then you'll want to try 'cabal-dev' :)
20:42:43 * stepcut tried cabal-dev but was too dumb to figure it out 
20:43:54 <lispy> accel: cabal-dev stores the pkg db in your current directory so you can have a different one for each project
20:43:54 <lispy> stepcut: It's pretty easy actually.  check out some code into Foo; cd Foo; cabal-dev install
20:43:55 <lispy> stepcut: Did you have a specific thing you were trying (and failing at?)
20:44:03 <accel> lispy: whoa
20:44:44 <accel> lispy: so project matrix1 can have "plot-version-awesome"; and proect matrix2 can have "plot-version-sucky" ?
20:45:05 <lispy> accel: As I recall, that's how it happened, yes :)
20:45:14 <accel> how do I tell cabal to load up the src of package "hatex" in the given directory?
20:45:18 <accel> i tried cabal fetch hatex
20:45:23 <accel> but it just said "shit is up to date, dumbass"
20:45:27 * BMeph now knows Kung Fu!
20:45:35 <lispy> accel: unpack
20:45:43 <stepcut> lispy: and then what happens ?
20:45:44 <accel> @karma+ lispy
20:45:44 <lambdabot> lispy's karma raised to 16.
20:46:02 <lispy> accel: fetch makes it store the package under ~/.cabal, unpack tells it to look in ~/.cabal and unzip the contents of Foo
20:46:07 <mauke> @karma- lispy
20:46:07 <lambdabot> lispy's karma lowered to 15.
20:46:09 <mauke> lispy++
20:46:17 <stepcut> lispy: I tried to use it to build happstack-util.. but I couldn't figure out how it was any different from a normal install of happstack-util
20:46:37 <accel> lispy: is there a way after I modify HaTeX to tell cabal "install this HaTex into `/.cabal" ?
20:46:43 <accel> @karam+ lispy
20:46:46 <lambdabot> Maybe you meant: karma karma+
20:46:50 <accel> @karma_ lispy
20:46:52 <lambdabot> Maybe you meant: karma karma+ karma-
20:46:53 <accel> @karma+ lispy
20:46:54 <lambdabot> lispy's karma raised to 17.
20:47:09 <lispy> stepcut: the main difference is that all the deps and hapstack-util itself get installed in your current directory.  So if the deps of happstack-util conflict with the deps of anything else that you try to install later they will be isolated from eachother
20:47:48 <stepcut> lispy: yeah.. I could see that actually happening..
20:48:15 <mauke> accel: wtf?
20:48:16 <lispy> stepcut: plain cabal-install has an issue where you install Y that depends on X.  Then later you install X', this will break your install of Y.
20:48:24 <accel> mauke: ?
20:48:30 <mauke> accel: what are you doing?
20:48:42 <lispy> mauke: trolling you! ;)
20:48:42 <stepcut> lispy: I would like to use it to check that happstack installs against hackage on a clean system, ignoring what i already have installed.. but maybe it is not supposed to do that..
20:48:51 <mauke> looks like it
20:48:52 <accel> mauke: trying to make changes to HaTeX
20:48:59 <lispy> HaTeX?
20:49:05 <accel> mauke: waht does it look like I'm doing?
20:49:05 <mauke> accel: ... with @karma?
20:49:20 <accel> mauke: oh, taht's just because lispy is answering my qeustions
20:49:25 <lispy> stepcut: Yes, it should work swimmingly for that.  It was designed to work as part of a continuous integration system
20:49:39 <accel> mauke: am I doing somethign wroht with @karma?
20:49:45 <stepcut> lispy: well, like I said, I am just to dumb to figure out how to use it :)
20:50:01 <mauke> accel: why do you use @karma+ instead of just "lispy++"?
20:50:11 <accel> lispy++
20:50:15 <accel> @karma lispy
20:50:16 <lambdabot> lispy has a karma of 18
20:50:19 <stepcut> lispy: I'll ask about it another time when I am actually prepared to do something about it
20:50:19 <accel> oh; that works too?
20:50:23 <accel> isn't ++ c++ style?
20:50:46 <lispy> stepcut: I think you get it actually.  You would get the version of the happstack source that you care about, then run 'cabal-dev install' in that directory. It will build only in the context of the global pkg db, not your user db.
20:50:47 <mauke> accel: no, that works, period. @karma+ is lambdabot only
20:51:03 <accel> lispy++ does what then?
20:51:12 <lispy> java++
20:51:14 <lispy> ?karma
20:51:15 <lambdabot> You have a karma of 18
20:51:20 <lispy> java++
20:51:20 <mauke> preflex: karma lispy 
20:51:20 <preflex>  lispy: 12
20:51:23 <lispy> ?karma
20:51:23 <lambdabot> You have a karma of 17
20:51:28 <accel> ah
20:51:34 <accel> mauke: so i'm screwing up the two bots
20:51:42 <accel> mauke: they now have different versions of the universe
20:51:42 <mauke> preflex: karma java
20:51:42 <preflex>  java: -32
20:51:44 <stepcut> lispy: I guess the problem is that I have everything in my global package db already
20:51:59 <mauke> accel: they started out different :-)
20:52:07 <lispy> stepcut: ah.  Yeah, I would not recommend using the global pkg db.
20:52:23 <accel> mauke: what can I do to fix this horrible injustice?
20:52:31 <accel> mauke: what if lambdabot ane preflex ever got together and compared notes?
20:52:37 <accel> would #haskell explode?
20:52:41 <lispy> Yes
20:52:59 <lispy> ?vixen would you like to compare notes with preflex?
20:52:59 <lambdabot> the question isn't would i, but should i
20:53:13 <stepcut> lispy: well, it is the easiest way I have found so far to ensure that everyone on the project team is developing for the same versions of the libraries, and to patch libraries that are busted.. we just debianized and build everything and apt-get install the packages
20:53:15 <lispy> ?vixen Either way, happy valentines day!
20:53:15 <lambdabot> tell me more about yourself.
20:53:22 <mauke> oh ghc, you're so silly: http://p3rl.org/8803MHXK
20:53:27 <stepcut> lispy: which, of course, makes cabal install pretty useless
20:54:09 <lispy> stepcut: interesting.  That's the opposite approach that we took.  We setup a continuous integration build server and expect people to stay up to date on their local libs.
20:54:27 <stepcut> lispy: how do you deal with broken packages on hackage ?
20:54:57 <gaze__> what's considered the most mature gui library for haskell?
20:55:02 <lispy> stepcut: maintain patched versions locally until we can get the patches accepted on hackage
20:55:02 <gaze__> probably gtk2hs, yeah?
20:55:03 <stepcut> lispy: we expect people to stay up-to-date as well with their debian packages, but we have a buffer so that we are not pulling straight from hackage
20:55:29 <stepcut> lispy: how do people get those versions installed instead of the hackage versions?
20:55:47 <lispy> gaze__: yeah probably.  wxHaskell used to be a good option too but I don't know what the current state is like
20:56:04 <lispy> stepcut: well when you're behind the corporate firewall you put a note on the wiki and tell your team about it in a meeting.
20:56:09 <stepcut> lispy: or perhaps a better question is, how do people know they should be using the locally patched versions instead of the hackage version ?
20:56:31 <stepcut> lispy: how many packages from hackage do you use ?
20:56:31 <lispy> stepcut: it sounds like you need this for debian
20:56:47 <lispy> stepcut: the better question is, how often do I need to patch them
20:57:01 <lispy> stepcut: usually 1-2 need patches out of every, I don't know, 10?
21:05:47 <lispy> stepcut: in general, I think there is a need for a blessed versions of packages
21:05:57 <lispy> stepcut: I think the Haskell-Platform has this in mind
21:06:05 <lispy> stepcut: But, it's maybe not agressive enough?
21:06:15 <lispy> Not decentralized enough?
21:06:29 <lispy> We still don't have the hackage2 rolled out, and I've been told it would address a lot of the need
21:09:50 <ksf> date
21:10:05 <ksf> whoops
21:11:18 <shapr> ksf: Sorry, already have a Valentine.
21:11:49 <shapr> gwern: I think there's more info to be gotten from your SoC retrospective.
21:11:54 <lispy> shapr: with a picture of a train that says, "I cho-cho-choose you!"
21:12:26 * shapr checks the picture
21:13:00 <shapr> lispy: Are you stalking my ravelry profile?
21:13:37 <lispy> heh
21:18:44 <ksf> bah. no, I was looking, tiredly, at my one monitor, seeing a shell.
21:18:56 <ksf> focus is a bitch.
21:22:29 <shapr> lispy: Any idea why hackage2 is not deployed?
21:22:37 <shapr> not that I have spare time or energy to fix it...
21:24:18 <accel> anyone mind explaining to me what this here means: ? 
21:24:19 <accel> pt :: Monad m => Int -> LaTeX m
21:24:20 <accel> pt = (>>"pt") . lxany 
21:24:41 <ivanm> preflex: seen malcolmw
21:24:41 <preflex>  malcolmw was last seen on #haskell 59 days, 11 hours, 46 minutes and 11 seconds ago, saying: John Peterson is trying to get Yale to give him back his old email address, just so he can officially hand over the domain...
21:24:58 <lispy> shapr: I can honestly say, I do not understand the situation despite trying to talk to people about it.
21:26:13 <lispy> shapr: It's not at all clear to me that the issue is one of needing people to do the transition.
21:26:13 <ivanm> shapr: I would randomly guess time constraints
21:26:13 <lispy> accel: what is HaTeX?
21:26:47 <accel> lispy: it's a Haskell DSL for generating LaTeX code
21:27:17 <lispy> accel: hmm....weird.  So, that pt function should probably specify a unit given a magnitude (as an Int)
21:31:07 <accel> lispy: whoa ; taht's why it does
21:31:09 <accel> but how?
21:31:52 <lispy> accel: that I don't know.  I would need to understand lxany and I would need to know the LaTeX type
21:32:14 <lispy> accel: I assume that the LaTeX type is some sort of embedding (an AST?) for LaTeX
21:32:25 <lispy> I don't really know why m is a monad
21:32:37 <lispy> I would have expected LaTeX to be a monad
21:33:31 <lispy> accel: are you new to Haskell?
21:35:43 <lispy> oh, that's clever.  LaTeX is a monad transformer
21:36:20 <lispy> and lxany just uses the show instance to write something
21:36:30 <lispy> and >> is concatenation here
21:36:44 <accel> hmm
21:36:46 <lispy> ?unpl pt = (>>"pt") . lxany
21:36:46 <lambdabot> pt d = (lxany d) >> "pt"
21:36:50 <accel> looks like I need to read chapter 19 of RWH
21:37:01 <lispy> accel: is that form more readable/
21:37:20 <accel> @src lxany
21:37:20 <lambdabot> Source not found. My pet ferret can type better than you!
21:37:28 <lispy> It converts the Int into a string using show.  Then it concatenates that with "pt"
21:37:45 <lispy> accel: http://ddiaz.asofilak.es/packages/HaTeX/doc/src/Text-LaTeX-Monad.html#lxany
21:38:28 <accel> why does this need monad transformers?
21:38:47 <lispy> I don't think it needs them, and certainly this example does not
21:39:13 <lispy> I suspect they use monad transformers for forward flexibility and it's probably a lot more complicated than they needed
21:39:39 <accel> so basically mental masturbation?
21:41:32 <lispy> accel: possibly.  I really haven't spent enough time understanding their design to know for user.
21:41:35 <lispy> sure*
21:42:10 <lispy> It's easy to be very abstract in haskell
21:42:14 <lispy> Sometimes too easy
21:42:33 <accel> yeah; being abstract in haskell
21:42:38 <accel> is like having ()'s in lisp
21:44:10 <lispy> some of their definitions bother me.  Like genlx
21:44:18 <sproingie> it's abstract turtles all the way down
21:44:56 <lispy> genlx = (>> return undefined)  -- This seems wrong to me
21:45:21 <lispy> Introducing undefineds in your code seems wrong to me
21:45:49 <NihilistDandy> sproingie: You're my favorite for that comment
21:46:34 <sproingie> :)
21:48:42 <Veinor> lispy: i've used undefined to specify the initial state in state-y code
21:49:25 <lispy> Veinor: because you assign before initial use?
21:49:33 <Veinor> yeah.
21:49:44 <lispy> Veinor: I guess it can have valid uses, but without a link to a proof I hate seeing it in code :)
21:49:51 <ddarius> What isn't normally revealed is that it is Cantor's grandmother who made that statement.
21:50:26 <lispy> ddarius: said what?  abstract turtles?
22:11:34 <c1de0x> if I have a number of Enum types, and I want a new type which may be one of those Enum types, how can i say that
22:11:36 <c1de0x> ?
22:12:37 <NihilistDandy> Sigh. ghc-mtl :/
22:13:10 <btubbs> hiya, I'm working my way through Real World Haskell and came up with two different ways of doing the exercise to "write a function that determines if a list is a palindrome".  (See http://pastebin.com/raw.php?i=gLcrDgVu) I think the second solution is more efficient because it recurses half as many times, but I wonder if I'm just missing some overhead that comes from using 'tail' and 'init'.  Thoughts?
22:13:57 <ddarius> btubbs: Here's an exercise.  Implement head/tail/last/init.
22:14:09 <Veinor> init and last are very expensive
22:15:10 <ivanm> Veinor: well, wouldn't init be relatively lazy?
22:15:19 <Veinor> @src init
22:15:20 <lambdabot> init [x]    = []
22:15:20 <lambdabot> init (x:xs) = x : init xs
22:15:20 <lambdabot> init []     = undefined
22:15:26 <ivanm> so something like take 5 . init wouldn't be too bad?
22:15:32 <Veinor> true.
22:15:51 * hackagebot yesod 0.7.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.7.1 (MichaelSnoyman)
22:16:19 <bob_loblaw> what does the type "(# Foo, Bar #)" mean? an unboxed tuple?
22:16:32 <NihilistDandy> btubbs: I'd say go with the recursive option
22:16:42 <pikhq> NihilistDandy: They both recurse.
22:16:52 <btubbs> pikhq beat me to it :)
22:17:00 <dolio> Yes, unboxed tuple.
22:17:04 <pikhq> Erm, no.
22:17:05 <NihilistDandy> Oh, so they do.
22:17:07 <Veinor> i'm pretty sure isPal will wind up being faster
22:17:18 <pikhq> The first does go into a recursive function, though. :P
22:17:23 <bob_loblaw> dolio: how does one access the contents of an unboxed tuple? fst and snd don't work
22:17:25 <NihilistDandy> Point being, I was referring to the first one :D
22:17:27 <pikhq> ... No. They both do.
22:17:29 <pikhq> Bleck.
22:17:35 <dolio> Pattern matching.
22:17:36 <pikhq> Think, pikhq, think.
22:17:46 <dolio> case p of (# f, b #) -> ...
22:17:48 <bob_loblaw> dolio: hm, that didn't seem to work either
22:17:55 <bob_loblaw> oh, duh
22:17:58 <bob_loblaw> I forgot the hashes
22:18:04 <ddarius> bob_loblaw: Where are you seeing an unboxed tuple and why do you need to manipulate it?
22:18:27 <bob_loblaw> ddarius: I'm just messing around :)
22:19:12 <ddarius> bob_loblaw: There's very rarely any reason to deal with unboxed values nowadays (and, of course, they're GHC specific.)
22:19:15 <btubbs> @src reverse
22:19:15 <lambdabot> reverse = foldl (flip (:)) []
22:19:24 <bob_loblaw> ddarius: I know
22:20:12 <bob_loblaw> ddarius: I was just experimenting with the fact that IO is a wrapper around RealWorld -> (RealWorld, a)
22:20:48 <ddarius> That's even less useful and more GHC specific than unboxed values in general.
22:20:57 <bob_loblaw> > let test x = case getLine of (GHC.Types.IO f) -> f x
22:20:58 <lambdabot>   not an expression: `let test x = case getLine of (GHC.Types.IO f) -> f x'
22:21:15 <bob_loblaw> @let test x = case getLine of (GHC.Types.IO f) -> f x
22:21:16 <lambdabot>  <local>:6:26: Not in scope: data constructor `GHC.Types.IO'
22:21:21 <bob_loblaw> hehe
22:21:39 <bob_loblaw> it doesn't need to be impressed upon me that this is not useful
22:22:26 <pikhq> bob_loblaw: It's useless by Haskell standards. :P
22:26:14 <accel> why doesn't this code compile:
22:26:15 <accel> main = do temph <- openFile "ignore/out.tex" hPutStr temph "Hello World" hClose temph
22:27:22 <c_wraith> well, given that you've stripped out the formatting and neglected the compiler error, that's awfully hard to say
22:28:20 <accel> because I'm missing a WriteMode
22:28:23 <accel> after the filename
22:29:13 <nosila> hey
22:29:30 <nosila> what is the logic char for 'oposite'
22:29:33 <nosila> in haskell?
22:29:39 <accel> not ?
22:29:41 <nosila> (equivalent to ! in C)
22:29:42 <nosila> ??
22:29:56 <nosila> really? lol *facepalm*
22:30:03 <nosila> >not True
22:30:08 <nosila> > not True
22:30:08 <accel> > not True
22:30:09 <lambdabot>   False
22:30:09 <lambdabot>   False
22:30:16 <nosila> FUUU
22:30:19 <accel> wait
22:30:19 <nosila> well, thanks ;)
22:30:24 <accel> you should type in @karma+ accel
22:30:29 <accel> as a token of thanks
22:30:41 <nosila> looooooool
22:30:43 <nosila> @karma+ accel
22:30:43 <lambdabot> accel's karma raised to 2.
22:30:47 <accel> thanks :-)
22:30:49 <sproingie> @karma+ nosila
22:30:50 <lambdabot> nosila's karma raised to 1.
22:30:54 <nosila> no prob
22:31:03 <bob_loblaw> what's the point of karma?
22:31:08 <accel> ego
22:31:11 <nosila> dont know dont care
22:31:12 <sproingie> bob_loblaw: ask a buddhist
22:31:12 <bob_loblaw> can I level up?
22:31:18 <accel> no
22:31:24 <accel> I don't think so
22:31:27 <bob_loblaw> wield a sword of a thousand truths?
22:31:32 <accel> maybe
22:31:34 <nosila> but you can be supersayen
22:31:37 <sproingie> it's ironic since the idea is to have no karma
22:31:38 <accel> you can use two monads at the same time
22:31:49 <bob_loblaw> accel: anyone can do that :P
22:32:08 <sproingie> someone gave me a sanskrit word that was closer to what irc "karma" is about, but i can't remember it
22:36:36 <nosila> if not ( functionX bla bla) then do bla bla
22:36:40 <nosila> this works??
22:37:38 <solrize> Page semi-protected
22:37:39 <solrize> Karma (Sanskrit: कर्म IPA: [ˈkərmə]  ( listen);[1] Pali: kamma) in Indian religions is the concept of "action" or "deed", understood as that which causes the entire cycle of cause and effect (i.e., the cycle called saṃsāra) originating in ancient India and treated in Hindu, Jain, Buddhist and Sikh philosophies.[2]
22:37:54 <ddarius> Buggardly flip-flopping in the curry/uncurry adjunction.
22:40:15 <nosila> this is supposed to work right? getting parse error... .if not ( functionX bla bla) then do
22:40:53 <sproingie> solrize: right, but in those traditions, even "good karma" gets in the way of transcendance
22:40:57 <mauke> nosila: where's the else?
22:41:12 <sproingie> ... transcendence
22:41:12 <nosila> is there
22:41:12 <nosila> lol
22:41:21 <nosila> i have
22:41:29 <nosila> w8 2 secs
22:42:13 <nosila> i have
22:42:27 <nosila> let status = functionReturningBool
22:42:28 <nosila> then
22:42:35 <nosila> if status
22:42:35 <nosila> then do .....
22:42:38 <nosila> else do .....
22:44:11 <nosila> bah
22:44:27 <nosila> just needed to put then and else with a "tab" <_<
22:44:32 <nosila> thanks anw
22:45:42 <accel> is there a document that's "Learn Monads the Hardway" or "Monads for ppl with PhDs" or "Everything you ever fucking want to know about monads" ?
22:46:11 <accel> I want the most fucking comprehensive and intense documentation on monads every
22:46:20 <accel> from basic shit like Maybe to monad transfer super duper ubers
22:46:24 <accel> *transformer*
22:46:26 <bob_loblaw> accel: read a book on category theory
22:48:07 <accel> http://members.chello.nl/hjgtuyl/tourdemonad.html is nice
22:48:08 <accel> but not enlugh
22:50:41 <minn> I'd suggest reading Wadler's papers on monads in functional programming and Meijer's paper on combining monads and folds. Also, Bird's "The Algebra of Programming" has a great, pragmatic introduction to the basic of category theory. If you feel conversant with the langauge and concepts, take up Pierce's monograph and Moggi's papers.
22:51:26 <bob_loblaw> pierce's CT book doesn't really get into monads
22:52:33 <bob_loblaw> I highly recommend the typeclassopedia
22:52:55 <c1de0x> bob_loblaw:link?
22:52:59 <bob_loblaw> http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf
22:53:01 <minn> There's no point in reading a category-theoretic introduction to monads, specifically, if you don't understand the basics of category theory. That is, are at least conversant in the language. Pierce's book provides this and is directed towards functional programming.
22:53:54 <minn> I'm working through Pierce at the moment, and it certainly clarifies discussions about monads. Of course, you can always ignore me :)
22:55:04 <bob_loblaw> minn: another good basic CT text is "Conceptual Mathematics" by Lawvere and Schanuel
22:55:38 <dolio> Pierce's category theory book isn't that great.
22:57:05 <bob_loblaw> yeah, I think Awodey's CT book is better for a CS-oriented perspective
22:57:12 <dolio> Yeah.
22:58:14 <minn> I'll have to check that out, then. Thanks for the recommendation. I wish there were more books like "The Algebra of Programming," too.
22:58:49 <dolio> I don't think Awodey is that CS-oriented, but it's just a better introduction to category theory.
22:59:23 <dolio> I guess it's got less of the wild mathematical examples than, say, Categories for the Working Mathematician.
22:59:30 <ddarius> My impression from skimming Pierce's CT book was that it was a bit mediocre.
23:00:30 <ddarius> dolio: It's mostly less dense.  CftWM doesn't have too many "wild" examples.
23:01:04 <minn> I thought Pierce was straightforward, and like that he spends time easing the reader into the subject. In particular, readers with less algebra would have an easier time with it.
23:01:31 <ddarius> I recommend Barr's and Wells' ESSLLI lecture notes for a short, online, but reasonably good, CS-oriented CT introduction.
23:01:44 <bob_loblaw> minn: "Conceptual Mathematics" is in that vein... very approachable for a non-mathematician
23:02:05 <dolio> Yes, Conceptual Mathematics starts very basic.
23:02:07 <ddarius> The problem with "Conceptual Mathematics," from what I can tell, is that it doesn't teach you anything.
23:02:44 <bob_loblaw> ddarius: I disagree, I think it gives you a very good basic understanding of what "morphisms" in general are about
23:03:08 <bob_loblaw> it develops an intuition
23:03:43 <bob_loblaw> but it doesn't go all that deep, certainly
23:06:32 * ddarius should write these equations as equations between proof terms rather than equations between derivations, though the latter is technically more accurate.
23:14:47 <mzero> I just wasted two hours writing a brainf**k interpreter in Haskell... for codegolf
23:14:51 <mzero> silly me!
23:16:30 <ddarius> You should have spent that hour writing a codegolf program writing program.
23:20:18 <mzero> true enough
23:20:42 <mzero> sometimes, though, I feel like coding - but am too brain dead from the dayjob to really do anything serious
23:20:53 <mzero> so - a little codegolf is sort of an enjoyable diversion
23:21:12 <mzero> besides, now looking at the hackage BF implementation - mine is quite different: it compiles to an IO action!
23:21:20 <mzero> rather than interprets
23:40:20 <minn> Is there an implementation of Haskell with subtyping? I'm working through TAPL for a class, and was wondering if there's something other than the ML implementation provided with the book to play around with.
23:44:00 <ddarius> minn: There's O'Haskell.
23:59:55 <wagle> minn: i was going to suggest maybe timber (newer version of ohaskell)
