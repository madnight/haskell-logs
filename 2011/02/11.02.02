00:00:07 * glguy is diving down the template haskell hole...
00:00:23 <Axman6> glguy: know any nice tutorials?
00:00:24 <glguy> good byyeeee.....
00:00:35 <shapr> o hai glguy, long time no see
00:00:41 <glguy> Axman6: I do not :), but I've got it doing what I had in mind
00:01:06 <glguy> automatically generating a data type and the corresponding Get a and a->Put methods
00:01:25 <bvck> Hi folks, can someone please look at this and tell me what I am doing wrong? http://codepad.org/nHnhR61R
00:02:13 <glguy>   (_, (b, q1, q2)) <- get
00:02:17 <Axman6> glguy: i would love it if you could add that to the binary package. deriving binary is something that's supposed to work, but i've got no idea how
00:02:18 <glguy> try getting rid of the _,
00:02:47 <glguy> Axman6: this is what I'm doing: https://github.com/glguy/minecraft-proxy/blob/template-haskell/Protocol.hs#L178
00:02:51 <glguy> this protocol uses a tagged union
00:03:03 <Axman6> jesus...
00:03:05 <Axman6> haha
00:04:20 <glguy> I just started figuring out how to do this in TH tonight... so there are some "rough edges" !
00:04:45 <Axman6> so basically this is a way to specify datatypes for a binary protocol?
00:04:50 <glguy> yeah
00:04:52 <Axman6> if so, that's pretty cool :)
00:05:13 <glguy> if you look at my master branch you can see the version that doesn't use TH 
00:05:53 <Axman6> where's JavaBinary come from?
00:06:02 <glguy> this project
00:06:08 <Axman6> righto =)
00:06:29 <Axman6> ha, i love the BlockId instance
00:06:44 <glguy> yup, keep scrolling
00:07:11 <Axman6> ok, I think you need to make this a package, it looks extremely useful
00:07:35 <Axman6> i could definitely see it being used in jlewis' combinatorrent
00:07:39 <glguy> I'm going to attempt to make it pretty for this one use-case before I do anything crazy
00:07:48 <Axman6> yeah, good plan
00:08:09 <glguy> eventually there shouldn't be any "Field" constructors poking out
00:08:30 <Axman6> bloody hell, that code just keeps going doesn't it!
00:08:42 <glguy> There is a lot of protocol to encode!
00:08:46 <Axman6> i can imagine that would be a nightmare to keep up to date if the protocol changed
00:08:48 <edwardk> Axman6:  ?
00:08:54 <edwardk> Axman6: which package?
00:08:59 <Axman6> https://github.com/glguy/minecraft-proxy/blob/master/Protocol.hs
00:09:19 <Axman6> edwardk: compared to https://github.com/glguy/minecraft-proxy/blob/template-haskell/Protocol.hs
00:09:31 <edwardk> yeow
00:09:47 <glguy> How do I write a function:   makeCustomField :: (Get a, a -> Put) -> Field
00:09:59 <glguy> where field is the type in that project defined in Generator.hs
00:10:11 <edwardk> sweet. i just realized my traversable zipper is a comonad store instance!
00:10:15 <glguy> instead of manually constructing values of field?
00:11:03 <glguy> do scoped type variables with with template haskell?
00:11:26 <Axman6> oh no, you accidently the verb!
00:11:55 <glguy> work
00:13:48 <glguy> well, they certainly appear to )
00:13:49 <glguy> :)
00:13:50 <joe6> isn't function application recursive lambda?
00:14:20 <joe6> internally, I mean?
00:14:29 <opqdonut> what?
00:14:42 <Axman6> joe6: huh?
00:15:28 <glguy>     Lexically scoped type variables are not supported by Template Haskell
00:15:30 <glguy> boo
00:15:40 <Axman6> :(
00:15:42 <opqdonut> :(
00:15:57 <shapr> :-?
00:15:59 <glguy> it seemed like such a good idea :)
00:16:26 <shapr> joe6: question not understood
00:20:57 <jtummond> @pl  f hs = map (\x -> sum (map (*x) hs))        
00:20:57 <lambdabot> f = map . (sum .) . flip (map . (*))
00:23:27 * hackagebot comonad 1.0.1 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-1.0.1 (EdwardKmett)
00:33:22 <djahandarie> :t (.) . sum .: flip ((.) . (*))
00:33:23 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => [a] -> f a -> f a
00:33:30 <djahandarie> :t map . (sum .) . flip (map . (*))
00:33:31 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
00:39:25 <Ferdirand> :t (.:)
00:39:26 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
00:39:49 <mandras> hi guys. quick question:
00:40:33 <mandras> I'm looking for a simple example or tutorial or suchlike for how to call a Haskell function from C or C++ code -- is there anything like that?
00:40:44 <kfr> Yeah I've seen such a tutorial, mandras
00:40:49 <kfr> But I didn't bookmark it unluckily
00:40:56 <mandras> Main shall be in Haskell, then I need to call to C/C++, which then calls back
00:41:12 <mandras> I remember seeing something too, but can't find it anymore
00:42:29 <FauxFaux> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Calling_Haskell_from_C
00:43:04 <mandras> FauxFaux: thanks, will look that up
00:43:25 <tengen> is it possible to extend a generic reader (extR in syb) with a type class? for example, instead of using extR with type Int, I want to use it with typeclass Integral
00:47:19 <djahandarie> :t ((. flip ((.) . (*))) . (.) .: (.)) sum
00:47:20 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => [a] -> f a -> f a
00:48:25 <djahandarie> @pl lambdabot
00:48:25 <lambdabot> lambdabot
00:48:30 <djahandarie> :(
00:48:38 <Axman6> hey...
00:48:42 <djahandarie> Lambdabot is as pointless as it gets
00:48:44 <shapr> djahandarie: Should be total source of lambdabot after going through @pl?
00:48:48 <shapr> argh!
00:48:54 <Axman6> @pl preflex: seen Axman6
00:48:55 <lambdabot> preflex : seen Axman6
00:48:59 <Axman6> weak
00:49:03 <Axman6> @pl preflex seen Axman6
00:49:03 <lambdabot> preflex seen Axman6
00:49:04 <preflex>  Axman6 was last seen on #haskell 0 seconds ago, saying: @pl preflex seen Axman6
00:49:08 <Axman6> =D
00:49:09 <djahandarie> Heh
00:49:17 * djahandarie stops wasting time here and goes to sleep
00:49:18 <Axman6> preflex: help
00:49:18 <preflex>  try 'help help' or see 'list' for available commands
00:49:23 <Axman6> preflex: help help
00:49:23 <preflex>  help COMMAND - show help for a command
00:49:29 <Axman6> preflex: help eval
00:49:29 <preflex>  unknown command: eval
00:49:35 <Axman6> preflex: list
00:49:37 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
00:49:37 <preflex>  ZCode: [zdec, zenc]
00:50:00 <kfr> Why isn't there a botloop command?
00:51:00 <shapr> kfr: What would that do?
00:51:14 <kfr> > text "Check this out:\npreflex: list"
00:51:15 <lambdabot>   Check this out:
00:51:15 <lambdabot>  preflex: list
00:51:24 <kfr> Aww preflex ignores lambdabot
00:51:25 <kfr> Harsh
00:51:44 <djahandarie> It clearly doesn't judging by what Axman6 just did. :P You just have an extra space
00:52:17 <Axman6> now i just need a way to make preflex talk to lambdabot 
00:53:18 <joe6> i want to generate a list of arguments from TemplateHaskell. Is that possible? not the function, and not all the arguments either.
00:53:53 <joe6> such as f a b c d e g h ; and I want to generate b c d e f g from TH.
00:54:08 <joe6> shapr: any thoughts, please?
00:55:24 <shachaf> joe6: Template Haskell is probably not what you want.
00:55:45 <Axman6> wouldn't you create a list of *P values?
00:56:05 <Axman6> my knowledge of TH is very basic, so I have no idea...
00:56:57 <joe6> Axman6: will check up on *P values. Thanks.
00:57:11 <Axman6> they're patterns
00:57:28 <Axman6> ghci> runQ [| \x -> 1 |]
00:57:29 <Axman6> LamE [VarP x_0] (LitE (IntegerL 1))
00:59:35 * hackagebot comonad-transformers 1.5.0.1 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.0.1 (EdwardKmett)
00:59:42 <edwardk> joe6: technically patterns are included in TH, in practice i don't know that they are supported
01:00:03 <Axman6> edwardk: you'll kill us all if you don;t stop uploading, hackage can't cope D:
01:00:08 <Axman6> she'll asplode!
01:00:17 <edwardk> Axman6: trying to get comonad-extras up there ;)
01:00:31 <ski> Eduard_Munteanu : i don't see how `forall a. Class a => a -> b' and `forall a. C a -> b' would be comparable .. the former could be comparable to `forall a. C a -> a -> b', though
01:00:35 <edwardk> sadly fragmenting things into multiple packages makes me upload more due to cross-dependencies
01:00:36 <ski> joe6 : look up "inductive logic programming"
01:00:44 <ski> > seq (seq undefined) ()
01:00:45 <lambdabot>   ()
01:00:51 <ski> Jesin,monochrom : `seq !x = id' is incorrect
01:01:08 <ski> @tell Jesin `seq !x = id' is incorrect, try `seq (seq undefined) ()'
01:01:08 <lambdabot> Consider it noted.
01:01:15 <ski> Axman6,accel : rather `Eq :: Eq a => Expr a -> Expr a -> Expr Bool', no ?
01:01:20 <Axman6> > let s !x = id in s undefined 1
01:01:21 <lambdabot>   *Exception: Prelude.undefined
01:01:24 <ski> shachaf : as in "Restricted type synonyms" <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> ?
01:01:28 <ski> (shachaf : more like s/#define/typedef/, no ?)
01:01:41 <Axman6> > let s !x = id in s (s undefined) 1
01:01:42 <lambdabot>   *Exception: Prelude.undefined
01:02:01 <Axman6> ski: did you just have massive lag or what? :P
01:02:07 <shachaf> ski: Yes, type is more like typedef. But I was referring to GHC's #define. :-)
01:02:15 <ski> Axman6 : sortof .. i just finished the backlog :)
01:02:16 <glguy> Axman6: https://github.com/glguy/minecraft-proxy/blob/template-haskell/ProtocolHelper.hs#L28
01:02:20 <Axman6> heh :)
01:02:35 * hackagebot comonads-fd 1.5.0.1 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-1.5.0.1 (EdwardKmett)
01:02:51 <ski> (Axman6 : for some reason, people seem not to like if you send away the comments directly, but don't look if they answer, for quite a while)
01:03:23 <Axman6> ski: you're right about the Eq thing, Eq a => should definitely be there
01:03:29 <ski> shachaf : you mean s/GHC/CPP/ :)
01:03:50 <shachaf> ski: I mean GHC -XCPP. :-)
01:04:08 <shachaf> ski: And it's not *quite* a #define because GHC irregularly remembers type synonym information.
01:04:18 * ski would like to be able to say `data Foo a = F0 (Blah a) | Eq a => F1 (Bleh a)'
01:04:56 <ski> @type "" ++ ""
01:04:57 <lambdabot> [Char]
01:05:00 <Axman6> glguy: so, Q [Dec] is a list of declarations right?
01:05:03 <ski> @type "" `mappend` ""
01:05:04 <lambdabot> [Char]
01:05:18 <kevinburke> how would you do an nxn matrix in haskell?
01:05:18 <Axman6> in this case top level declarations
01:05:33 <Axman6> kevinburke: take a look at hmatrix
01:05:46 <glguy> Axman6: yeah, its a think that makes a list ofdeclarations when you run it
01:05:50 <glguy> thing*
01:06:05 <kevinburke> axman6: ok - i don't need to do any operations on it just store a bunch of edge weights
01:06:14 <glguy> Axman6: at the top level the $() is optional
01:06:25 <Axman6> ah i see
01:06:28 <Axman6> how confusing :)
01:06:39 * ski . o O ( think : thing :: thunk : thung ? )
01:06:49 <shachaf> ski: You can say that.
01:06:59 <Axman6> ski: a thung is an evaluates think
01:07:00 <glguy> you can pretend like you are defining new keywords alongside "data" :)
01:07:04 <Axman6> thunk*
01:07:17 * ski grins
01:07:36 <joe6> ski: just checked on "inductive logic programming", but nothing specific to haskell came up.
01:07:39 <Axman6> and a thing is an evaluated think  =D
01:07:44 <shachaf> ski: (I mean, the "data Foo" thing.)
01:07:59 <Axman6> http://imgur.com/hd2d7
01:08:10 <ski> glguy : it would be better to have a special way to define "macro"/syntax keywords, instead of having that optional, imo
01:08:11 <joe6> edwardk: I see the patterns, but there do not seem to be any patterns for function parameters.
01:08:36 * hackagebot comonad-extras 0.1 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-0.1 (EdwardKmett)
01:08:44 <edwardk> joe6: function parameters in TH are bound as patterns.
01:08:47 <ski> shachaf : .. oh. and here i thought you was agreeing with "thung" :/
01:09:11 <shachaf> ski: I haven't evaluated that proposal yet.
01:09:26 <Axman6> glguy: what do ' and '' do?
01:09:27 <glguy> The biggest problem with TH so far has been that I've needed to split my module in 3 parts due to staging and top-level declarations
01:09:44 <edwardk> yay, now you can take a traversable and create a zipper to walk around in it as a store, then spit out the resulting traversable after you mutate it with a bunch of comonadic actions
01:10:13 <joe6> edwardk: ok, thanks
01:10:21 <glguy> edwardk: do you ever use these abstractions as more than abstrations?
01:10:31 <shachaf> glguy: Don't be silly.
01:10:33 <edwardk> glguy: yes, this was motivated by an actual use =)
01:11:02 <edwardk> glguy: often i use one or two of the combinators out of each library ;)
01:11:08 <glguy> were you implementing abstractions at the time?
01:11:16 <edwardk> i plead the 5th
01:11:32 <shachaf> glguy: (Hmm, weren't you gone from IRC for a couple of years, or something of the sort?)
01:11:43 <glguy> couple of years?
01:11:44 * ski plaids the firths
01:11:46 <glguy> maybe not that long :)
01:12:18 --- mode: ChanServ set +o glguy
01:12:24 --- mode: glguy set -o glguy
01:12:29 <glguy> same old glguy :)
01:12:58 <Axman6> glguy: any chance i could persuade you to write some sort of tutorial about using TH for this sort of thing?
01:13:13 <shachaf> And when will emertens be back?
01:13:18 <edwardk> i rather like these two comonads, they are rather on the practical end of things, the zipper comonad lets you take some traversable, like a tree, then walk around inside of it with logarithmic seek times, mutating the whole traversable with the ability to view relative positions, etc. then spit it back out. the pointer comonad lets you do things like image blurs, by defining how the kernel of the function looks at one point.
01:13:30 <glguy> shachaf: when I'm logged on in three locations
01:13:37 <glguy> glguy -> glguy_ -> emertens
01:13:47 <edwardk> they just relied on a couple of extensions i wasn't willing to admit to comonad-transformers =/
01:13:48 <yitz> edwardk: aren't you from britain?
01:14:03 <edwardk> yitz: nope. american through and through, why?
01:14:11 <Axman6> > unzip $ map (pred &&& succ) "glguy"
01:14:12 <lambdabot>   ("fkftx","hmhvz")
01:14:22 <yitz> oh ok. i was wondering about you "pleading the 5th".
01:14:38 * hackagebot hscurses 1.4.0.0 - NCurses bindings for Haskell  http://hackage.haskell.org/package/hscurses-1.4.0.0 (StefanWehr)
01:14:55 <edwardk> ah wondered if i spelled something with the wrong localization or some such ;)
01:15:12 <Axman6> you just spelt localisation wrong >_>
01:15:17 <glguy> wroung*
01:15:20 <yitz> i say, those brits watch entirely too much telly these day. plead the 5th, indeed.
01:15:34 <shachaf> glguy: He meant to say incourrectly.
01:15:47 <edwardk> Axman6: spoken like a brit ;)
01:16:01 <shachaf> Axman6 is Australian.
01:16:05 <Axman6> damn right
01:16:07 <shachaf> Bynbo7 is the British one.
01:16:09 <edwardk> meh, hey all sound alike
01:16:13 <glguy> I heard that the English couldn't teach their children how to speak.
01:16:14 <edwardk> they even
01:16:50 <Axman6> hmm, so, i think i should head back to the hotel, and pick up a small bottle of scotch on the way
01:16:56 <edwardk> its only when you get to internationalization that you can even tell them apart ;)
01:17:19 <glguy> Axman6: we'll see about the template haskell tutorial
01:17:39 <Axman6> I would be very thankful if you would, this seems like a great use of it :)
01:17:40 <glguy> I'd have to believe that a good one didn't already exist
01:17:46 <kfr> ;t unzip
01:17:50 <kfr> :t unzip
01:17:51 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
01:19:21 <edwardk> the only problem i have now is trying to find what package i put something in. this is why category-extras was nice ;)
01:19:47 <edwardk> ah Supply went in Streams
01:20:04 <glguy> good night, moon
01:20:38 <shachaf> > map rot13 "glguy"
01:20:39 <lambdabot>   "tythl"
01:20:48 <edwardk> ransacking the other comonad transformers for places to inject memoization
01:21:22 <edwardk> what libraries provides a memo trie for a given data type
01:21:31 <edwardk> something conalish i presume
01:23:23 <edwardk> woot, MemoTrie is surprisingly lightweight
01:23:39 <edwardk> @tell conal MemoTrie rocks =)
01:23:39 <lambdabot> Consider it noted.
01:28:04 <yitz> > map rot13 "shachaf"
01:28:05 <lambdabot>   Not in scope: `rot13'
01:28:36 <shachaf> yitz: It's "funpuns", of course. :-)
01:30:30 <yitz> > map (toEnum.(+fromEnum 'a').(`mod`26).(+13).(subtract$fromEnum 'a').fromEnum) "shachaf"
01:30:32 <lambdabot>   [*Exception: Prelude.Enum.().toEnum: bad argument
01:31:16 <shachaf> Ha, defaulting.
01:31:26 <yitz> oh
01:32:01 <yitz> > map (chr.(+ord 'a').(`mod`26).(+13).(subtract$ord 'a').ord) "shachaf"
01:32:03 <lambdabot>   "funpuns"
01:32:08 <yitz> so it is
01:32:33 <yitz> > map (chr.(+ord 'a').(`mod`26).(+13).(subtract$ord 'a').ord) "yitz"
01:32:35 <lambdabot>   "lvgm"
01:32:56 <edwardk> @tell conal would it be possible to change the class signature of HasTrie to  class Functor ((:->:) a) => HasTrie a ? — i have a number of these that i plan to spend a lot of time mapping over, and indexing pointwise would be rather suboptimal
01:32:56 <lambdabot> Consider it noted.
01:38:07 <Tinned_Tuna> Morning, I have a brief question
01:38:21 <kfr> Shoot, I'm wearing a kevlar vest.
01:38:27 <Tinned_Tuna> I have a function which is String -> Bool called convertToBool
01:38:35 <Tinned_Tuna> *String -> [Bool]
01:38:47 <Tinned_Tuna> and I am trying to do stream <- readFile file1
01:38:49 <kfr> Multiple boolean values :o
01:39:01 <kfr> readFile doesn't return a stream does it?
01:39:02 <Tinned_Tuna> then bits <- convertToBool stream
01:39:04 <kfr> :t readFile
01:39:05 <lambdabot> FilePath -> IO String
01:39:14 <kfr> :t withFile
01:39:15 <lambdabot> Not in scope: `withFile'
01:39:15 <ski>   stream :: String
01:39:21 <kfr> ski yeah
01:39:33 <Tinned_Tuna> yea, I'm trying to read a file in (it's 1s and 0s)
01:39:42 <Tinned_Tuna> and convert them all to [Bool]
01:39:53 <Tinned_Tuna> so 1 => True, 0 => Flase, otherwise skip
01:39:54 <edwardk> @tell conal prepping a patch. figured i should put the burden on me
01:39:54 <lambdabot> Consider it noted.
01:40:31 <Tinned_Tuna> basically, GHC is (reasonably) having a wobbly about sending an IO String to my String->[Bool] function
01:40:42 <Tinned_Tuna> and I was wondering what my options/best course of action is
01:42:05 <shachaf> Tinned_Tuna: Just apply the function.
01:42:12 <shachaf> Tinned_Tuna: let bits = convertToBool stream
01:42:14 <kfr> > map ((==1) . read . (:[])) "100110100" :: [Bool]
01:42:16 <lambdabot>   [True,False,False,True,True,False,True,False,False]
01:42:18 <kfr> That is so bad though ^
01:42:22 <Tinned_Tuna> in the do construct?
01:42:29 <kfr> It sucks how Haskell doesn't come with a readMaybe by default
01:42:30 <Tinned_Tuna> kfr: this code is one use only :-p
01:42:44 <shachaf> Tinned_Tuna: Yes.
01:43:01 <shachaf> Or bits <- convertToBool <$> readFile file1
01:44:18 <shachaf> Tinned_Tuna: In general, if you have a value :: a and a function :: a -> b, you can make a value :: b by applying the function to the value. :-)
01:44:23 <kfr> > map (\x -> case x of {'1' -> Just True; '0' -> Just False; _ -> Nothing}) "100110100"
01:44:24 <lambdabot>   [Just True,Just False,Just False,Just True,Just True,Just False,Just True,J...
01:44:36 * kfr shrugs
01:45:00 <shachaf> You only need special things like >>=/<-/<$>/etc. when you're dealing with actions like IO String.
01:45:16 <Tinned_Tuna> shachaf: yea, but GHC was having an impure-based-wobbly :-p
01:45:30 <shachaf> Tinned_Tuna: This has nothing to do with pure/impure.
01:45:46 <shachaf> It's just a mismatched type thing.
01:46:39 <kfr> Tinned_Tuna: Usually you simply use a do block with <- to get the String out of the IO String and to bind it to some name
01:46:50 <kfr> And then you can pass it to the pure function with the correct type
01:47:03 <kfr> test <- readFile "some file"
01:47:08 <kfr> readFile returns an IO string
01:47:16 <kfr> But test is a String, it's "unwrapped"
01:47:49 <kfr> You might want to learn about how to express do-blocks using >>= and lambdas first though
01:48:11 * shachaf grumbles at "unwrapped".
01:48:14 <kfr> Because it's important to know what they actually mean when you use them
01:48:24 <kfr> shachaf what terminology would you prefer?
01:48:33 <shachaf> I don't know. "executed"?
01:48:35 <Tinned_Tuna> I really need to go off and fully understand monads
01:48:36 <kfr> What is it called? The opposite of lifting?
01:48:52 <shachaf> The point is that there's no String in an IO String.
01:49:02 <kfr> Getting the "a" out of the "m a"
01:49:03 <Tinned_Tuna> at first I was lead to believe that monoids (as of, groups, rings, etc.) would be useful, but they're not quite the same thing ¬.¬
01:49:13 <shachaf> kfr: There *is* no "a" in the "m a".
01:49:49 <kfr> If there weren't then it wouldn't have anything to pass on to the lambda on the RHS of >>= :(
01:49:59 <kfr> >>=(
01:50:06 <kfr> Bind smiley!
01:50:32 <shachaf> data Null a = Null deriving Monad
01:51:20 <kfr> Food for thought
01:51:51 <kfr> Alright, you are right
01:53:20 <yitz> kfr: but it's frowning. perhaps you meant (=<<
01:53:41 <kfr> yitz of course it is frowning, Haskell causes nothing but suffering
01:54:31 <yitz> kfr: you're starting to sound like gwern
01:54:57 <shachaf> @get-gwern
01:54:58 <lambdabot> Unknown command, try @list
01:55:16 <kfr> "You know how they say that when you have a problem and you decide to use regular expressions to solve it, you now have two problems? Well, Haskell is the opposite in that regard. You start out with a problem, then you go through a lot of trouble to actually learn the language and then you no longer have the problem in the first place because you have lost interest in programming." - by Philip Wadler, from "Faith, Evolution, and Programming Languages", April 
01:55:16 <kfr> 2007
01:55:23 <kfr> Or like Wadler!
01:56:59 <kfr> So the >>= of IO performs the actual output, right?
01:57:14 <kfr> Or input, as in this case
01:57:32 <yitz> kfr: no it just combines two IO operations
01:58:13 <kfr> You can pass around IO actions without actually execution them, right?
01:58:14 <Tinned_Tuna> Well I seem to have caused a fuss about types
01:58:22 <kfr> *executing
01:58:23 <yitz> kfr: yes
01:58:25 <sipa> kfr: yes
01:59:03 <kfr> Then when are they actually executed?
01:59:23 <yitz> kfr: it's magic
01:59:44 <kfr> That doesn't sound helpful :[
01:59:54 <yitz> kfr: after computing the value of the magic name "main", the runtime executes it
02:01:29 <kfr> How do I pass around the IO action putStrLn "blah" as opposed to executing it?
02:01:56 * hackagebot wai-extra 0.3.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.3.1 (MichaelSnoyman)
02:02:07 <kfr> Hmm it's all based on the lazy evaluation of main basically?
02:02:23 <kfr> I've seen a multi threaded example for this where an IO action was passed from one thread to another
02:02:27 <kfr> Without being executed
02:02:31 <kfr> Some TVar action
02:02:52 <kfr> It greatly confused me in the beginning because I expected the IO to be performed when it was just an argument to another function
02:03:12 <Bynbo7> go lord no :O
02:03:17 <Bynbo7> good*
02:03:22 <kfr> What?
02:03:28 <Bynbo7> :P
02:03:31 <aleator> If I use lots of flexibleContexts and FlexibleInstances what evil visits me later?
02:03:35 <yitz> kfr: you are always passing it around without executing. then, when the magic happens in the end, that action will actually be executed if it is needed when unraveling laziness.
02:03:43 <Bynbo7> aleator: death
02:03:55 <shachaf> kfr: It has nothing to do with lazy evaluation.
02:04:01 <aleator> Bynbo7: Death by FlexibleContexts?
02:04:12 <Bynbo7> indeed
02:04:24 <Bynbo7> which translates to you not knowing where it'll happen
02:04:30 <Bynbo7> it could happen in any ocntext!
02:04:36 <Bynbo7> context*
02:05:22 <yitz> Bynbo7: except that the runtime guarantees a will happen before b when evaluating a >> b
02:05:41 <Bynbo7> ?
02:06:05 <Bynbo7> yitz: i think we're having different conversations
02:06:21 <yitz> Bynbo7: ha. i was following up on kfr
02:06:30 <kfr> Yeah he already stopped talking to me
02:06:34 <kfr> I was not worthy of his attention
02:09:11 <aleator> Anyways, My LANGUAGE pragma is almost three lines already..
02:10:16 <kosmikus> aleator: only? ;)
02:11:31 <aleator> kosmikus: oh dear, oh dear, it gets bigger? 
02:12:24 <ski> kfr : the only way to execute an `IO'-action is to have it be `main', or put it as part of an action which will end up in `main'
02:12:27 <ski> aleator : the `Flexible' ones aren't *that* bad, i think
02:12:28 <ski> the bad ones are `OverlappingInstances',`IncoherentInstances' and to some extent `UndecidableInstances' .. did i forget any ?
02:12:57 <aleator> ski: thanks. I luckily don't have any of those.
02:21:09 * kfr has a bizarre idea about automatically assisted Python/Ruby to Haskell conversion
02:21:28 <Blkt> good morning everyone
02:21:41 <kfr> Ciao bello
02:21:58 * shachaf still awake. :-(
02:22:03 <Blkt> lol, italiano? :D
02:22:08 <kfr> Nope
02:22:08 <edwardk> UndecidableInstances isn't bad, just takes a little manual deciding ;)
02:22:21 <Blkt> good italian :D
02:22:33 <kfr> Close to non-existent
02:22:45 <kfr> Automatically converting dynamically typed language source code to a statically typed language must be very challenging
02:22:49 <edwardk> FlexibleFoo is just relaxing annoying restrictions of Haskell 98. heck it wasn't long before Haskell 98 that type classes on higher kinds were a radical extension ;)
02:23:07 <kfr> For example, a function can return nil and 1 in such a language
02:23:21 <kfr> And you need to figure that out somehow and turn that into a Maybe return type
02:23:28 <kfr> Which in return affects the rest of the program, too
02:24:09 <ski> edwardk : yeah, hence the "to some extent" .. to the extent that one (or one's clients) can't make sure it terminates
02:24:43 <ski> (Mercury has multi-parameter type-classes, but not constructor classes ..)
02:24:52 <edwardk> =)
02:35:39 <okp> is it possible to kill a thread that's in a foreign call, interrupting the foreign call?
02:35:51 <okp> killThread waits until the foreign call finishes
02:38:37 <kfr> okp you can use another FFI call to kill the thread forcefully but that would leak memory
02:38:39 <jacobian> I've been noticing that it can be quite handy to keep my monads 'generic' such that I can change the underlying monad easily. 
02:38:48 <jacobian> This has come in handy using non-determinism especially
02:39:11 <jacobian> However, when I'm transforming from one monad to another, it's hard to keep it generic, are there strategies to deal with this?  
02:40:44 <okp> kfr: thanks. maybe I'll have to find some other way around this
02:43:56 <aristid> jacobian: use the classes from mtl and if necessary add your own? you may have to write a quadratic amount of class instances.
02:50:52 <edwardk> okp: you probably need to deal with it yourself, ffi out to something that can communicate with the stuck thread
02:51:36 <edwardk> jacobian: +1 for aristid's notion of leaning on the mtl for that
02:52:07 <edwardk> makes it easy to mix in a bit of state, a bit of environment, a lot, some io if need be, etc.
02:52:45 <jacobian> Excellent, thanks for the advice folks
02:52:46 <edwardk> then you can decouple your methods from your monad choice by just saying what the functions need, this one needs an environment that provides xyz, that one needs some mutable state, etc.
02:53:31 <hvr> ...how do I convert from lazy bytestring to strict bytestring?
02:54:54 <aristid> B.concat . L.toChunks or so
02:55:16 <hvr> ...oh, there isn't a single function for that?
02:55:30 <aristid> maybe there is. look at the docs
02:55:41 <hvr> Im looking at them but couldn't find it :)
02:56:02 <hvr> I thought, I've overlooked
02:57:43 <lostman> I don't think there is... B.concat . L.toChunks is the efficient version and you can do B.pack . L.unpack; I think that is much slower though
02:58:04 <aristid> hvr: i'm not aware of such a function either. i remember that i was once pissed about its non-existence
02:58:10 <aristid> i think it was the other direction tho
02:58:22 <aristid> which i solved with L.fromChunks [x]
02:58:46 <lostman> yeah, the other direction is L.fromChunks . (:[])
02:59:05 <lostman> or L.fromChunks . return if you don't like the robot monkey operator
02:59:26 <aristid> lostman: i used the pointful version i think. oh well.
02:59:46 <aristid> i think Data.List should contain a singleton function for aesthetic reasons :)
03:00:40 <lostman> aristid: be fancy, use return!
03:01:02 <okp> edwardk: yeah, seems a bit complicated. I'm trying a different approach which doesn't require killing the thread at all. thanks
03:01:04 <aristid> lostman: certainly possible, but it somehow feels less clean
03:02:22 <aristid> hmm, is it possible to avoid orphan instances while retaining modularity?
03:02:44 <dibblego> sure
03:02:44 <aristid> let's say you have 2 packages with monad transformers and classes
03:02:57 <aristid> now you want instances for each other
03:03:13 <aristid> the easiest way to avoid orphan instances would be to merge the 2 packages
03:03:22 <edwardk> okp: good idea. killing threads generally leaves you in a bad state anyways
03:03:23 <hvr> aristid: you could be 'pure' :)
03:04:34 <aristid> dibblego: see my problem?
03:04:45 <dibblego> aristid: yes, I would use newtype
03:04:56 <aristid> dibblego: please explain
03:05:24 <dibblego> newtype T = T OutsideType deriving OutsideClass
03:06:03 <aristid> dibblego: you mean re-defining the transformers in a new package that has dependencies on both original packages?
03:06:11 <dibblego> aristid: yes
03:06:35 <aristid> interesting.
03:06:57 <aristid> dibblego: would you REALLY do it, or would you accept orphan instances? :)
03:07:20 <dibblego> I'd work out the return on investment of effort versus the hack
03:07:50 <aristid> coming up with new module names would be the hardest part :D
03:07:57 <dibblego> yes
03:08:00 <edwardk> aristid: look at Control.Applciative it provides WrappedMonad
03:08:19 * hackagebot comonad-extras 0.1.1 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-0.1.1 (EdwardKmett)
03:08:21 <aristid> edwardk: that's a bit of a different situation :)
03:08:27 <edwardk> aristid: i have one orphan instance in all of the packages i've built in the last 3 months
03:08:49 <edwardk> aristid: mostly by dint of leaning on said 'WrappedFoo' patterns where forced
03:10:19 <aristid> Control.Monad.Instances is chock-full of orphan instances (in fact, its only purposes is to contain orphan instances). yet it does not seem to cause problems
03:10:26 <edwardk> also regarding transformers and classes, set up your packages in a directed acyclic graph, then just provide the instance in whichever module wins the dependency war. . given that the types involved in an instance for orphan resolution are the class and the instance head, just put it in whichever wins
03:10:35 <aristid> maybe because C.M.I is the "canonical" place to look for these instances?
03:10:44 <edwardk> Control.Monad.Instances is a wart. caused by the fact that the Prelude is specified by Haskell 98
03:10:53 <edwardk> so adding instances to prelude types for prelude classes is illdefined
03:11:10 <edwardk> so to work around it, those are placed in a single canonical location.
03:11:19 <edwardk> ideally haskell 2012 would just add those to the language spec
03:11:23 <edwardk> and CMI could go away
03:11:53 <aristid> edwardk: your approach would imply setting up an artificial package dependency between A and B (A and B are the two packages with transformers)
03:11:55 <edwardk> when working with say, my comonad package, i put the instances directly in with the Comonad class, _because the prelude doesn't say anything about Comonad_
03:12:12 <aristid> oh, sure.
03:12:13 <edwardk> aristid: correct. sadly, hackage works like an onion. later packages are second class citizens
03:12:38 <edwardk> they are outer layers of the onion and have to depend on whatever it makes sense for them to provide instances for
03:12:51 <edwardk> or you can make the package super tiny and appeal to get it dropped in base if you can make it haskell 98 ;)
03:12:55 <edwardk> or close thereto
03:13:27 <aristid> edwardk: what if the two packages are not your own? say, logict and, uh, ExceptionT
03:13:29 <edwardk> i've been trying this divide and conquer approach lately. tiny core packages, and then larger packages that provide the major members. its not perfect
03:13:42 <edwardk> then you make wrapper types if you really need to use classes with them
03:14:05 <edwardk> or you make a tiny foo-instances package if you really really have to then harass the author to get them added ;)
03:14:17 <edwardk> i did that with vector, fat lot of good it did me
03:14:49 <aristid> i don't see a "clean" solution to this problem at all
03:14:53 <edwardk> there isn't
03:14:55 <aristid> all possible solutions have ugly warts
03:14:55 <edwardk> its a language problem
03:15:15 <aristid> could the language somehow evolve to not have this problem?
03:15:22 <aristid> i have no idea hiw
03:15:24 <aristid> *how
03:15:42 <edwardk> ideally you'd be able to build mixin packages that got included when all of their 'parent' packages were included, which just sprinkled instances into scope
03:15:54 <edwardk> aristid: yes. thats the model i use in kata actually ;)
03:16:12 <aristid> edwardk: mixin modules/packages? interesting.
03:16:13 <edwardk> but its likely to get far worse before it gets better
03:16:30 <aristid> edwardk: cabal/hackage could support that, in theory
03:16:58 <edwardk> good luck getting the bandwidth out of its maintainer though, and it'd require some invasive changes to ghc most likely
03:17:15 <aristid> yeah, the GHC changes are probably big too
03:17:45 <aristid> edwardk: but i guess once the problem is bad enough, somebody will step up and volunteer :D
03:18:11 <aristid> or is that wishful thinking? hm
03:18:39 <edwardk> well, first folks have to acknowledge it as a problem, that needs more folks that write lots of packages to spot it
03:19:02 <edwardk> crap like this is why category-extras was 118 modules
03:19:20 <aristid> to avoid the problem entirely?
03:19:25 <edwardk> yeah
03:19:28 <edwardk> made other problems
03:19:54 <edwardk> but it mitigated this one from _my_ perspective. but then other folks who wanted something small had to layer themselves outside of a huge layer of onion ;)
03:20:54 <aristid> edwardk: another option might be automatic derival of instances from some kind of rules
03:21:10 <edwardk> tricky that
03:21:20 <edwardk> i'm less optimistic there
03:21:41 <aristid> edwardk: monadLib has plenty of derive_* that need nothing more than an isomorphism
03:22:16 <aristid> hmm, i guess you need to get the isomorphism from somewhere
03:22:29 <aristid> and it also does not work in all cases
03:22:40 <edwardk> sure, but you still need to use em
03:22:43 <edwardk> i typically provide lowerFoo's and liftBars and blahDefaults, etc. 
03:24:51 <aristid> that reminds me of another problem, which i can only illustrate with an example. say, you had class Applicative m => Monad m, then for every Monad you would need to manually write down Applicative and Functor instances. but they could be derived automatically, could they not?
03:25:37 <edwardk> the problem is that what happens i they would come into scope by other means?
03:25:44 <edwardk> er if
03:25:53 <edwardk> with template haskell etc it can be tricky to determine that
03:26:07 <edwardk> but to be fair TH currently requires that they be resolved before the instance for the Monad would be anywyas
03:27:37 <aristid> edwardk: how about this? in order to define a different fmap than liftM, you would have to do this: instance Monad Foo where fmap = blah
03:27:58 <dibblego> I wish we called it (.) and not everything else
03:28:22 <edwardk> aristid there are a dozen variations on the theme in various proposals. i eagerly await someone committing us to one of them 
03:29:29 * hackagebot comonad-extras 0.1.2 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-0.1.2 (EdwardKmett)
03:30:00 <aristid> oh, comonad-extras is so new that none of the versions has haddock :D
03:30:01 <edwardk> i'd forgotten a couple of comonads-fd instances =)
03:30:19 <edwardk> you can explore here https://github.com/ekmett/comonad-extras
03:30:54 <edwardk> right now it just contains 3 'structured stores'
03:31:09 <edwardk> you can make a store comonad out of a memo trie, an array, or a traversable container.
03:31:33 <aristid> Zipper uses Seq?
03:31:36 <edwardk> yeah
03:31:50 <edwardk> moves the head logarithmically rather than linearly
03:31:52 <mm_freak> edwardk: don't you use type families?
03:32:03 <edwardk> mm_freak; i do here and there where they help
03:32:06 <aristid> zipper :: Traversable t => t a -> Maybe (Zipper t a)
03:32:13 <aristid> edwardk: wouldn't Foldable suffice?
03:32:19 <mm_freak> edwardk: because you mentioned "-fd"
03:32:24 <edwardk> aristid: no, coz i put it back together with unzipper
03:32:50 <edwardk> mm_freak: comonads-fd is to match up roughly with mtl the former monads-fd
03:33:02 <edwardk> comonad-transformers is the analogue of transformers
03:33:17 <aristid> edwardk: i don't see the Traversable function in refill. where does it hide?
03:33:19 <edwardk> while comonad would be a viable candidate for prelude inclusion
03:33:26 <mm_freak> ah, ok
03:33:28 <edwardk> mapAccumL
03:33:43 <aristid> oh.
03:33:48 <aristid> edwardk: sneaky.
03:33:49 <edwardk> basically it relies on the ability to take the contents out of the traversable then sneak them back in because i didn't change its shape
03:34:16 <edwardk> so it knows it has something the right size to refill the original traversable, since i never provide any operations that change the size of the Seq.
03:34:52 <edwardk> and it works as a comonad because the zipper is never empty.
03:34:58 <aristid> is Seq the best data structure for Zipper?
03:35:15 <edwardk> for this use case. comonadStore lets you seek arbitrarily far
03:35:36 <edwardk> you might do a bit better if you preserved the three finger structure and added left and right movement operations, etc.
03:36:24 <edwardk> http://hackage.haskell.org/packages/archive/comonads-fd/1.5.0/doc/html/Control-Comonad-Store-Class.html is the api its providing
03:37:05 <edwardk> i now have like 6 different store comonads
03:37:33 <aristid> hah, seek s = peek s . duplicate
03:38:03 <edwardk> strict and lazy versions, a memoizing one that memoizes the result of the function at the current location to better support multiple extracts, the memo trie version, the array backed one and the traversable zipper
03:38:07 <aristid> @pl seek s = peek s . duplicate
03:38:08 <lambdabot> seek = (. duplicate) . peek
03:38:32 <edwardk> i use a little bit of pointfree to make things clearer, but i don't go religious about it ;)
03:38:58 <aristid> @let result = (.)
03:38:58 <lambdabot>  Defined.
03:39:04 <aristid> @let argument = flip (.)
03:39:05 <lambdabot>  Defined.
03:39:38 <aristid> :t \peek duplicate -> (argument.result) duplicate peek
03:39:39 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => (f b1 -> b) -> (a -> b1) -> f a -> b
03:39:42 <edwardk> fmap duplicate . peek is less pleasing to me than peek s . duplicate because it appears backwards
03:40:02 <Twey> peek >>> fmap duplicate
03:40:02 <aristid> edwardk: you need a flip there somewhere
03:40:04 <Twey> ☺
03:40:05 <edwardk> i don't buy into the cult of conal's semantic editor combinators ;)
03:40:17 <edwardk> nah you write it above
03:40:23 <edwardk> @pl seek s = peek s . duplicate
03:40:23 <lambdabot> seek = (. duplicate) . peek
03:40:29 <edwardk> oh
03:40:39 <edwardk> seek = (`fmap` duplicate) . peek
03:40:40 <edwardk> blech
03:40:46 <Twey> Yeah
03:40:50 <edwardk> i'll stick to mine =)
03:40:52 <aristid> edwardk: that's why i introduced argument, but failed to use it properly
03:41:28 <edwardk> i find a few points help people keep their compass bearings
03:41:42 <aristid> haha
03:41:55 <edwardk> given the generally crazy higher order nature of my code thats not a bad thing ;)
03:42:08 <edwardk> i string together stuff with dots usually when i can make a single pipeline out of it
03:42:15 <aristid> edwardk: but once you repeat a pattern very often, you may want to introduce a point-free combinator
03:42:21 <edwardk> especially if the dual case is symmetrical
03:42:28 <aristid> (.:) is pretty handy
03:42:36 <edwardk> rarely, i find it often gets in the way of readability
03:43:01 <ray> what's a (.:) now
03:43:04 <dafis> aristid: (.:) is (.) . (.) ?
03:43:07 <aristid> (.:) = fmap.fmap
03:43:10 <aristid> in my book
03:43:20 <edwardk> if i need fmap fmap fmap i fmap fmap fmap =)
03:43:23 <ray> haha, silly
03:43:49 <aristid> edwardk: it's fmap.fmap for me, not fmap fmap fmap, because the first fmap is needlessly generic :P
03:44:08 <edwardk> meh, i find it easier to remember them in odd increments ;)
03:44:13 <edwardk> :t fmap `fmap` fmap
03:44:14 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:44:20 <aristid> :t fmap . fmap
03:44:21 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:44:21 <edwardk> :t fmap `fmap` fmap `fmap` fmap
03:44:22 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
03:44:47 <aristid> edwardk: fmap chains make pretty beautiful types IMO :)
03:45:02 <aristid> this looks nice: (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
03:45:06 <edwardk> sometimes useful, dangerously obfuscatory =)
03:45:38 <dibblego> @type fmap fmap fmap fmap fmap
03:45:38 <edwardk> most of the time i even apply 2 fmaps i tend to go pointful and make one a <$>
03:45:39 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
03:45:42 <aristid> edwardk: it's not very abstract, so you can look it up and understand it immediately :P
03:45:43 <edwardk> fmap f <$> b
03:45:47 <dibblego> @type fmap fmap fmap
03:45:48 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:46:20 <edwardk> dibblego infix every other one and odd numbers add functor layers
03:47:11 <edwardk> evens mix in that function composition aspect
03:47:19 <dibblego> @type fmap fmap (fmap fmap fmap)
03:47:19 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
03:47:43 <aristid> dibblego: that's a pretty ridiculous way to write fmap.fmap.fmap
03:48:03 <dibblego> heh, because writing fmap.fmap.fmap is totally not ridiculous!
03:48:17 <aristid> it's not :P
03:48:18 <edwardk> i should probably get a couple hours of sleep
03:48:38 <aristid> dibblego: do you never have "deep" functors?
03:48:39 <dibblego> same, except my brother is currently right here http://www.bom.gov.au/products/IDQ65002.shtml
03:48:59 <dibblego> aristid: I use monad transformers before that degree of ridiculosity
03:49:27 <aristid> dibblego: trading a bit of obfuscation for a lot of it? :P
03:49:42 <dibblego> the contrary
03:49:55 <edwardk> dibblego: suck
03:50:06 <dibblego> suck?
03:50:18 <edwardk> dibblego: as in that sucks
03:50:27 <dibblego> oh yes, that does suck
03:50:30 <edwardk> dibblego: not your day is it? =)
03:50:36 <dibblego> nup :)
03:51:09 <dibblego> that cyclone is more intense than Katrina
03:51:30 <edwardk> so how did the damn fool get himself caught in it?
03:52:03 <dibblego> I told him to evacuate yesterday, but he was convinced to go to a cyclone shelter instead
03:52:16 <dibblego> he lives in an area expected (certain) to storm surge flood
03:52:18 <edwardk> coz thats always fun
03:53:28 <aristid> dibblego: let's say you have [[a]] and want to apply (a -> b) to yield [[b]]? would you not use fmap.fmap or map.map?
03:53:44 <dibblego> aristid: sure, but it's very rare that's all I want
03:53:57 <dibblego> why am I doing that in the first place?
03:54:00 <edwardk> getCompose.fmap.Compose — clearly ;)
03:54:22 <edwardk> though in practice i tend towards map f <$> b — in that case
03:54:40 <aristid> dibblego: now, granted, instead of toLower .: x (where x is Maybe String), i could have found a cleaner solution, but that would have been more effort :P
03:54:42 <edwardk> a little bit more pointful and i can typically unpack more of the expression on the rhs of the <$>
03:55:36 <edwardk> fmap toLower <$> x — keeps folks in first order thoughts and gives the parts different names ;)
03:55:53 <aristid> edwardk: you want to avoid using map?
03:56:06 <edwardk> map toLower <$> x is even better ;)
03:56:24 <dibblego> @type fmap . fmap -- Scalaz calls it ∘∘
03:56:25 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:56:33 * edwardk doesn't mean to sound like a luddite today
03:56:36 <aristid> i do not think there is anything confusing about fmap.fmap other than having to know the name.
03:56:54 <edwardk> i just don't want to waste the line importing it
03:57:33 <edwardk> or the three defining it and making people think through it to understand it before reading the rest of my code
03:58:01 <edwardk> i have enough essential complexity that i try to eschew incidental complexity where possible ;)
03:58:41 <aristid> i don't have much essential complexity at all :)
03:59:29 <edwardk> i'd just as soon have someone look at a line and be able to figure out what it is with as little context as possible
03:59:44 <edwardk> i suck at doing that but its a nice goal =)
04:00:11 <aristid> edwardk: i don't even understand most of your tutorials :/
04:00:30 <edwardk> speaking of which i need to do a comonad transformer one soon
04:01:05 <aristid> please make it readable for people who do NOT know what a yoneda lemma or a kan extension is :)
04:01:10 <edwardk> hah
04:01:37 <edwardk> thats one of the reasons why so much of my code right now is haskell 98
04:01:44 <edwardk> trying to get back to the essential complexity
04:02:11 <edwardk> rather than 'what crazy stuff i can encode in the type system to make my life easier and if its hard to write it should be hard to read!' like i used to be. ;)
04:02:27 <edwardk> those were my perl roots showing ;)
04:02:41 <aristid> perl ruins your soul :D
04:02:45 <aristid> i love it anyways
04:04:36 <edwardk> ok. nap time. then i get to see if i'm willing to face the mountain of snow outside to tromp to work
04:30:14 <ddarius> Yoneda or Kan extensions restricted to Haskell are relatively straightforward to represent.
04:30:23 <edwardk> yeah
04:30:50 <dafis> edwardk: I thought you were going to sleep?
04:31:29 <edwardk> yeah
04:31:33 <edwardk> i am i guess =)
04:32:02 <edwardk> got stuck answering email ;)
04:43:37 <etpace> Does anyone have a mirror for vims haskell-mode? projects.haskell.org seems to have nuked it
04:46:51 <dafis> etpace: projects is offline atm, it should be back up in a couple of days
04:47:30 <dafis> etpace: http://www.haskell.org/pipermail/haskell-cafe/2011-February/088829.html
04:48:22 <etpace> ok, thanks
04:59:45 <dafis> quit
05:08:22 <etpace> can anyone upload the haskell-moe vimball in the meantime?
05:23:01 <parcs> > let x@((+5) -> y) = 10 in (x, y)
05:23:02 <lambdabot>   (10,15)
05:25:49 <parcs> let ((+5) -> x)@y = 10 in (x, y)
05:25:55 <parcs> > let ((+5) -> x)@y = 10 in (x, y)
05:25:56 <lambdabot>   <no location info>: parse error on input `@'
05:27:17 <Twey> Name has to come first in an @-pattern
05:44:30 <aristid> dibblego: look at the commit message :D https://github.com/aristidb/aws/commit/d8f2f131fc3232b891d24a30f28615bf4d924693
05:49:44 <earthy> etpace: vim comes with haskell highlighting built in, so while haskell-mode does allow a few extra niceties, you may be able to do without
05:50:20 <etpace> I know earthy, but the indenting and so on I miss
05:50:32 <etpace> as well as haddock lookup etc
05:50:39 <earthy> hm.
05:51:43 <earthy> istr the indenting plugin should be standard as well
05:52:09 <earthy> hm. isn't.
05:55:06 <earthy> http://webcache.googleusercontent.com/search?q=cache:zugzhbRbr34J:projects.haskell.org/haskellmode-vim/vimfiles/haskellmode-20101118.vba+http://projects.haskell.org/haskellmode-vim/&hl=en&client=safari&strip=0 has the vimball
05:59:40 <mm_freak> i found that serious haskell development is almost only possible in emacs
06:00:28 <accel> is there a haskell -> flash compiler?
06:00:30 <mm_freak> i'm using emacs together with ecb
06:00:33 <accel> or a dsl in haskell for writing flash apps?
06:00:50 <mm_freak> accel: there is a library for generating flash apps, but not a haskell compiler
06:02:06 <earthy> mm_freak: but you know haskell, right?
06:02:11 <earthy> err... emacs.
06:02:28 <earthy> I've found vim to be perfectly adequate
06:03:00 <mm_freak> earthy: i know emacs and vim…  the latter has a great editor, but that's about it…  also emacs' haskell-mode understands haskell better
06:03:34 <mm_freak> earthy: vim is certainly "adequate" for everything related to text editing, but it's not always the best solution
06:04:15 <earthy> still, I'm interested in what you think is so indispensable that you state 'almost only possible'
06:04:55 <zygoloid> mm_freak: the latter /is/ a great editor, and that's all it tries to be ;)
06:05:24 <mm_freak> earthy: haskell-mode + ECB make emacs a great development environment…  also if you really miss vim, there is a vim minor mode =)
06:06:36 <earthy> hm. right. I get enough of ECB with minibufexplorer and an appropriate find when firing up vim
06:07:16 <accel> mm_freak: what library is that?
06:07:23 <earthy> plus, the completion support happens to Just Work across the open buffers...
06:07:35 <accel> mm_freak: are you thinking of HaXe (i.e. with ocaml) or SWFmill (which isn't even written in haskell afaik)
06:07:45 <earthy> that leaves jumping to the correct tags, but that's what we've got ctags for
06:08:04 <accel> mm_freak: none of the things on http://www.haskell.org/haskellwiki/Hajax seem all that haskell-ish
06:08:05 <mm_freak> earthy: ECB is still more and it works quite out of the box
06:08:11 <earthy> yah, I see
06:08:23 <mm_freak> accel: 'swf'
06:08:30 <mm_freak> accel: but i'd use haxe to develop flash apps
06:08:38 <mm_freak> you won't be happy with haskell
06:08:39 <accel> mm_freak: how is haxe?
06:08:49 <mm_freak> haxe is great…  i'm using it at work
06:08:54 <accel> mm_freak: why not?
06:08:57 <earthy> it's just that I don't see the 'more' being enough of a pull to invest in learning emacs
06:09:10 <earthy> otoh, I hadn't heard about ECB at all before
06:09:12 <mm_freak> accel: because you can't use haskell for flash development
06:09:19 <accel> mm_freak: out of courisity, where do you work that uses not yet mature tech like haxe?
06:09:42 <mm_freak> earthy: probably not…  if you're happy with what vim provides, then it's not worth learning
06:09:46 <accel> mm_freak: Currently the assembly language portion is best supported, with many other features missing, such as images, sounds, and much more.  <-- from swf on hackage .... out
06:09:49 <accel> *ouch*
06:10:06 <mm_freak> after all vim has a great editor, which is better than emacs in some respects
06:10:33 <mm_freak> accel: well, it was my own decision =)
06:11:10 <mm_freak> accel: i just told my superior that haxe is free, while adobe stuff would cost a life
06:11:14 <mm_freak> =)
06:11:32 <earthy> it's kinda interesting though. I've often had the idea that maybe learning emacs would improve things, but I've never been brave enough to just try
06:11:47 <earthy> plus, I have like 18 years experience with vim
06:12:00 <mm_freak> earthy: well, emacs is very different…  i think it's like the CL vs. haskell discussion
06:14:49 * earthy nods
06:16:03 <mm_freak> earthy: learning emacs might even frustrate you, when you use vim, just like learning vim frustrates me sometimes, when i use emacs
06:16:45 <mm_freak> (and like learning haskell frustrates me, when i have to use…  well…  any other language)
06:17:27 <earthy> ah. yes.
06:17:39 <earthy> I've switched languages enough that that doesn't bother me much anymore
06:18:47 <accel> If I don't care about laziness; what advantage does haskell provide over ocaml?
06:19:03 <earthy> syntax
06:19:10 <mm_freak> accel: syntax, concurrency
06:19:18 <accel> p4 takes care of syntax
06:19:40 <mm_freak> also haskell has many advanced type system features, which ocaml lacks
06:19:44 <earthy> I think hackage provides somewhat more libraries
06:19:59 <mm_freak> earthy: well, that's not really related to the language
06:20:01 <earthy> ocaml has modules though
06:20:10 <accel> mm_freak: I have a favor to ask you. Can you convert haxe into haskell? :-)
06:20:14 <earthy> mm_freak: tell that to the java lovers. ;)
06:20:30 <mm_freak> accel: i don't understand your question ;)
06:20:41 <accel> mm_freak: i mean rewrite haxe in haskell :-)
06:21:03 <mm_freak> accel: i still don't understand it
06:21:12 <accel> haxe is written in ocaml
06:21:21 <accel> if it were written in haskell, i'd be much happier
06:21:23 <mm_freak> no, it isn't…  it's compiler is written in ocaml
06:21:31 <mm_freak> and of course you can write a haxe compiler in haskell
06:21:41 <mm_freak> why would you be happier?
06:21:54 <mm_freak> are you a haxe compiler developer?
06:23:36 <accel> i'm about a couple orders of magnitude
06:23:44 <accel> too ignorant to be able to develop haxe
06:25:05 <mm_freak> feel free to write a haxe compiler in haskell…  and on your way, please add TCO and a better type parameter syntax ;)
06:25:23 <accel> haxe doesn't have tail call optimization?
06:25:31 <mm_freak> nope
06:25:55 <mm_freak> it also has this ugly C++/java/C# type parameter syntax x<A>
06:26:17 <accel> perhaps one needs a haskell DSL that compiles down to haxe
06:27:40 <EvanR-work> @src groupBy
06:27:40 <lambdabot> groupBy _  []       =  []
06:27:40 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
06:27:40 <lambdabot>     where (ys,zs) = span (eq x) xs
06:28:07 <EvanR-work> @src span
06:28:07 <lambdabot> span _ xs@[]                     =  (xs, xs)
06:28:08 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
06:28:08 <lambdabot>                   | otherwise    =  ([],xs)
06:28:13 <mm_freak> (i don't understand why almost all languages insist on mentioning type parameters explicitly at all)
06:28:45 <mm_freak> (after all, just like haskell, haxe requires all types to be written capitalized)
06:28:49 <dafis> mm_freak: what do you mean?
06:29:13 <dafis> mm_freak: would you like [] instead of [a]?
06:29:19 <mm_freak> dafis: function id<A>(A x) : A { return x; }
06:29:25 <mm_freak> uhm
06:29:30 <mm_freak> dafis: function id<A>(x : A) : A { return x; }
06:29:38 <dafis> mm_freak: okay, that's not pretty
06:29:54 <dafis> what language?
06:29:58 <mm_freak> haxe
06:30:24 <EvanR-work> c++script
06:30:42 <mm_freak> it has so many goodies from ocaml/haskell, but it keeps this ugly ECMA syntax
06:34:10 <dafis> mm_freak: but I just saw, if you pass a function as argument, you write function blah(fun :: Int -> Int), so they're halfway to a sane type notation, why didn't they go all the way??
06:34:37 <CrazyThinker> Does haskell compile directly to machine langauge?
06:34:54 <dafis> (fun : Int -> Int), too used to haskell
06:35:15 <dafis> CrazyThinker: no, there are intermediate representations
06:35:51 <dafis> but it compiles down to machine language
06:36:01 <CrazyThinker> dafis, how does it work? Is there a runtime/VM ?
06:37:11 <dafis> CrazyThinker: no (well, you can run it interpreted [compiled to bytecode]), it compiles down to machine language (but you can stop before), just not *directly*
06:37:40 <dafis> CrazyThinker: Haskell -> Core -> Stg -> Cmm -> assembly -> machine code
06:37:56 <dafis> (I think that's all)
06:37:58 <CrazyThinker> :O
06:38:24 <dafis> CrazyThinker: any other compiled language compiles via intermediate languages too
06:38:35 <kfr> Haskell -> losing interest in programming -> depression -> eating disorder -> drug addiction
06:38:48 <CrazyThinker> -> death?
06:38:52 <dafis> kfr: the first step is WRONG
06:39:02 <kfr> Yes, you should never learn Haskell!
06:39:19 <kfr> Is there such a thing as a "compiled language"?
06:39:21 <dafis> Haskell -> finding joy in programming (at least, that was my way)
06:39:46 <CrazyThinker> kfr, then I take stupid -> moron -> eating disorder -> drugs -> death
06:39:49 <Younder> Sounds like God forbidding Man to eat the apple..
06:39:53 <kfr> A programming language is just an abstract concept, it does not inherently dictate the way you use it, does it now?
06:39:56 <dafis> kfr: any language produced by a compiler?
06:40:18 <Younder> Ah a satanic language :) rotfl
06:40:22 <kfr> Also, pretty much every language is compiled in one way or the other, no?
06:40:26 <dafis> kfr: I admit to using inaccurate language again
06:40:28 <kfr> Ruby, Perl, Python
06:40:47 <kfr> Even assembly
06:40:49 <CrazyThinker> But those are interpreted at runtime
06:41:07 <kfr> Compilation just means translating source code to some other format
06:41:12 <kfr> May it be a hidden internal representation
06:41:17 <kfr> An AMD64 ELF
06:41:17 <mm_freak> dafis: i don't know…  haxe borrows a lot from haskell and ocaml, including even algebraic data types and pattern matching, but its syntax tries to match ECMA, which is a decision i don't understand
06:41:26 <kfr> Or a Java class file
06:42:19 <CrazyThinker> kfr, you are talking like a saint
06:42:58 <mm_freak> haskell → euphoria → having to use another language → depression → aggression → arguments with colleagues
06:42:58 <Younder> kfr: you should distinguish between compilers, byte code compilers and JIT compilers. Each with different performance characteristics.
06:43:01 <kfr> CrazyThinker: That is odd, considering I'm an atheist
06:43:18 <kfr> Younder: Agreed
06:43:27 <dafis> kfr: true, but habit has it that people speak of 'compiled languages' meaning languages which are usually compiled to native code vs. 'interpreted languages' which may be compiled to bytecode and are run in an interpreter; VMs with JIT-compiling make that distinction even less rigid than it was before, but old habits die hard
06:43:27 <CrazyThinker> Younder, Thats the reason I asked this
06:43:28 <kfr> However, those are still not properties of a programming language
06:43:48 <kfr> There are plenty of languages for which software exists which can do either]
06:43:50 <ddarius> mm_freak: Euphoria seems like an uninteresting language that's only notable by the gall of the creators to attempt to sell it.
06:44:43 <mm_freak> haskell → euphoria (psychological condition) → having to use another language → depression → aggression → arguments with colleagues
06:44:48 <dafis> mm_freak: I don't understand that either, perhaps they thought to reach a larger audience with a syntax more resembling the well-known Algol-derivates
06:45:09 <cuzzie> Can someone please explain to me why the definition of function take is take      ::        Int -> [a] -> [a] ?
06:45:37 <Botje> what is unclear about it?
06:45:42 <mm_freak> dafis: they specifically wanted to resemble ECMA to appeal to actionscript developers…  originally it's a reincarnation of the actionscript compiler 'mtasc'
06:45:44 <Bynbo7> cuzzie: that's not the definition of the function
06:45:50 <Bynbo7> that's its type
06:46:10 <cuzzie> Bynbo7: I see.. 
06:46:15 <dafis> cuzzie: because a general Integral type would have worse performance, if you need, there's genericTake in Data.List
06:46:26 <mm_freak> cuzzie: it takes an Int and an [a] and results in an [a]
06:46:36 <Bynbo7> cuzzie: i think you need to expand on your question
06:46:46 <mm_freak> dafis: the question doesn't seem to go that far =)
06:47:16 <cuzzie> I don't understand why is the type of the function like that...
06:47:30 <dafis> cuzzie: what would you expect?
06:47:47 <mm_freak> cuzzie: why not?  'take' takes an Int (the number of elements to take), the original list and results in a changed list
06:47:58 <mm_freak> > take 3 "abcde"
06:47:59 <lambdabot>   "abc"
06:48:07 <dafis> > take 17 "abcde"
06:48:08 <lambdabot>   "abcde"
06:48:20 <ddarius> > take (-3) "abc"
06:48:20 <lambdabot>   ""
06:48:26 <cuzzie> But then, why isn't it Int -> [a] ?
06:48:32 <cuzzie> Why is there another set of -> [a] behind?
06:48:44 <dafis> cuzzie: it takes two arguments and has a result
06:48:54 <mm_freak> cuzzie: where would the input list come from, if it had the type you suggest?
06:49:13 <mm_freak> cuzzie: note that the type includes its result, too, not only its argument types
06:49:17 <mm_freak> :t id
06:49:17 <lambdabot> forall a. a -> a
06:49:19 <dafis> take :: Int {- first arg -} -> [a] {- second arg -} -> [a] {- result -}
06:50:32 <mm_freak> cuzzie: a value of type 'Int' is not a function taking an Int…  it's simply an Int value, while a value of type 'Int -> Int' is a function taking an Int and resulting in an Int
06:52:11 <dafis> if mm_freak would close his eyes for a moment,
06:52:16 <dafis> cuzzie: List<A> take(int n, List<A> xs)
06:52:23 <mm_freak> hehe
06:52:38 <dafis> mm_freak: you looked!
06:52:46 <mm_freak> sorry for that…  i couldn't resist
06:53:12 <cuzzie> Thanks guys.. I'll try to understand your explanations. :)
06:53:17 <magthe> dcoutts: I saw your announcement about community.haskell.org, but it didn't mention anything about user accounts... something has happened because I no longer get prompted for a password, but I still can't log in
06:53:36 <magthe> should I just wait for another announcement? :)
06:53:48 <dafis> magthe: We have not yet re-enabled user login accounts,
06:53:52 <dcoutts> magthe: it did mention something about user accounts :-)
06:53:58 <mm_freak> oh, btw
06:54:01 <Bynbo7> cuzzie: a function a -> b -> c is actually a function which takes an a and returns a function which takes a b and returns a c: a -> (b -> c)
06:54:07 <mm_freak> % ssh hs
06:54:18 <mm_freak> @       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @
06:54:24 <mm_freak> is that legitimate?
06:54:27 <dcoutts> magthe: "We have not yet re-enabled user login accounts, nor re-enabled access to code repositories."
06:54:42 <dcoutts> magthe: "We will send a further update when these are re-enabled, or procedures for people to re-enable them are finalised."
06:55:07 <mm_freak> Bynbo7: better don't go that far now…  you can explain currying once the haskell newbie has understood type signatures
06:55:23 <cuzzie> Bynbo7: So, Int -> [a] -> [a] is Int -> ([a] -> [a]) ?
06:55:30 <mm_freak> cuzzie: yes
06:55:51 <Bynbo7> cuzzie: yep, so take takes an int, and returns a function which takes a list, and returns another list
06:55:52 <mm_freak> cuzzie: 'take' takes an Int and results in a function, which takes a list and results in a list
06:56:00 <Bynbo7> jynx
06:56:54 <mm_freak> cuzzie: that's haskell's way of expressing multi-arg functions, and it gives you one of the greater language features: currying
06:59:28 <andres_> hello everybody
07:00:05 <joe6> isn't foldl' preferred over foldl? or, is it foldl1
07:00:06 <dafis> hello
07:00:15 <dafis> joe6: foldl'
07:00:21 <joe6> i cannot seem to find a foldl'
07:00:26 <dafis> joe6: Data.List
07:00:31 <joe6> ok, thanks.
07:00:38 <andres_> anyone knows why when I try to create an existencial datatype like this "data Obj = forall a. (Show a) => Obj a" is doesnt compile?
07:00:44 <dafis> joe6: foldl is pretty useless most of the time
07:00:54 <copumpkin> andres_: you have to turn on ExistentialQuantification
07:01:03 <copumpkin> stick {-# LANGUAGE ExistentialQuantification #-} at the top of your file
07:01:07 <dafis> andres_: because you need a language extension
07:01:08 <cuzzie> Oh okay guys.. I get it now! :D
07:01:08 <magthe> dcoutts: ah yes, look at that... I should learn to read :)
07:01:19 <cuzzie> Thanks dafis, mm_freak and Bynbo7! :)
07:01:25 <dafis> {-# LANGUAGE ExistentialQuantification #-}
07:01:55 <andres_> thanks for the help
07:02:03 * dafis pretends copumpkin wasn't faster
07:02:06 <dcoutts> magthe: np, we're all guilty of speed reading, I shouldn't stick the most useful info in the middle of the email :-)
07:02:09 <andres_> it work
07:04:13 <mm_freak> is there a good german introduction into haskell?
07:04:41 <dafis> mm_freak: I have never seen one
07:04:42 <mm_freak> a yes/no answer suffices, because i'm thinking of writing one
07:04:49 <copumpkin> nein
07:05:09 <ddarius> mm_freak: There are probably a few introductions.
07:05:20 <magthe> dcoutts: thanks for keeping even me informed ;-)
07:05:25 <andres_> copumpkin: is there anyway of not loading this everytime in my *.hs, something like in the default modules? 
07:05:32 <dafis> mm_freak: there's a german (austrian) tutorial linked from Lerning, but I found it less than stellar
07:05:40 <magthe> dcoutts: I'll just wait for another announcement then
07:05:40 <mm_freak> andres_: you can specify 'Extensions' in your cabal file
07:05:42 <copumpkin> andres_: not that I know of
07:05:47 <sipa> you can pass it as an argument to ghc
07:05:53 <mm_freak> andres_: those are then global to all your source files
07:05:54 <copumpkin> a cabal file makes it package-wide
07:06:25 <mm_freak> ok, good to know
07:06:31 <dafis> mm_freak: when you write one, I can offer proofreading assistance
07:06:39 <parcs> when duplicating a TChan, does the current queue also get duplicated?
07:06:43 <mm_freak> dafis: yeah, that would be great
07:07:11 <dafis> mm_freak: just send me a note when you have a chapter
07:07:26 <mm_freak> dafis: alright, thanks =)
07:08:15 <parcs> wait, nevermind. it says it right in the docs that the duplicated TChan begins empty
07:10:03 <mm_freak> is there any markup language, which can syntax-highlight haskell?  i think pandoc (the command line utility) supports it, but i don't know how
07:13:39 <fryguybob> mm_freak: pandoc built with highlighting flag?
07:13:54 <mm_freak> hmm, good idea
07:14:05 <gwern> it's good highlighting, IMO
07:14:21 <gwern> you can see some in http://www.gwern.net/haskell/Wikipedia%20RSS%20Archive%20Bot.html
07:17:30 <mm_freak> isn't that even the same highlighting as on haskellwiki?
07:17:44 <gwern> no
07:18:08 <gwern> hawiki uses the mediawiki plugin to GeNSHi, pandoc uses highlighting-kate (the kate editor's schemes)
07:18:45 <gwern> highlighting-kate seems to be superior to genshi - iirc, it doesn't make mistakes on operators like -->, interpreting that as a comment
07:18:52 <gwern> (an issue with xmoand configs)
07:19:16 <mm_freak> ok
07:19:17 <mm_freak> thanks
07:19:21 <Gulanzon> Hello everyone :)
07:19:29 <gwern> GREETINGS FELLOW HUMAN
07:20:05 <Gulanzon> Hmm, utilitarian language, all caps... you're sure you're a H. sapiens??
07:20:25 <Gulanzon> you sounds like you could perhaps be a troll!!!!!
07:20:48 <dafis> Gulanzon: only at full moon
07:21:26 <Gulanzon> Such a majestic creature you must be :)
07:21:42 <gwern> i wish to enter into mutually utility-improving transactions with you
07:21:42 <dafis> he is indeed
07:22:02 <gwern> please send me your uniquely identifying description
07:22:28 <Gulanzon> What's that?
07:23:27 <Bynbo7> Gulanzon: heh, do you have a question? :)
07:23:37 <Gulanzon> Ah, maybe.
07:23:55 <Gulanzon> I'll keep at it for a bit before I resort to asking.
07:23:56 <lpsmith> "i wish to enter into mutually utility-improving transactions with you"  <-- sounds like a geeky pick-up line
07:24:27 <Gulanzon> I think ym favourite is "I'm collecting random seeds for my pseudorandom number generator, care to contribute with your phone number?"
07:25:05 <jacobian> LOL
07:25:34 <parcs> how can i fork a ReaderT r IO ()?
07:26:02 <lpsmith> forkIO (runReaderT m state)
07:27:07 <Bynbo7> if you're in the ReaderT: stats <- ask; liftIO $ forkIO $ runReaderT m state
07:27:16 <Bynbo7> state*
07:35:08 <Egbert9e9> putStr "" >>= (\a -> putStrLn $ show a) -- prints "()\n" O_O
07:35:25 <mux> Egbert9e9: that's completely normal
07:35:28 <mux> :t putStr
07:35:29 <lambdabot> String -> IO ()
07:35:29 <Egbert9e9> mux, i know
07:35:51 <parcs> thanks lpsmith and Bynbo7 
07:36:13 <Egbert9e9> i think i'm slowly starting to have a very fuzzy idea about what's going on with these monad guys
07:38:08 <Gulanzon> Okay, functional programming languages don't work like... I can't say take a variable, do something with it, then do something with another variable that I provide later. I'd have to set up a function to take two variables and do something with them.
07:38:34 <Gulanzon> My programming background is 0 btw, I come purely from the land of maths, and I come in peace!
07:38:46 <byorgey> =)
07:38:57 <byorgey> Gulanzon: well, it's functions all the way down
07:39:04 <dafis> Gulanzon: maths is a good background for Haskell, Haskell is a good language for mathy people
07:39:05 <byorgey> so if you want to do anything at all, you have to create a function to do it.
07:39:46 <Gulanzon> Yup.
07:40:10 <Gulanzon> Well, to be more specific, I'm trying to make a function that takes all the factorials up to a certain limit and puts them in a list.
07:41:06 <dafis> > scanl (*) 1 [1 .. 10]
07:41:07 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800]
07:41:15 <dafis> Gulanzon: ^^
07:41:38 <ddarius> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs -- no function being defined
07:41:39 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
07:41:48 <Gulanzon> Well, I'm doing it learn me a good haskell, so that doesn't really count.
07:43:25 <Gulanzon> what does the (+) mean?
07:43:33 <kfr> It's the addition operator
07:43:35 <kfr> :t (+)
07:43:36 <lambdabot> forall a. (Num a) => a -> a -> a
07:43:48 <kfr> Gulanzon: Functions with () around them are inline functions
07:43:59 <Gulanzon> ah, cheers :)
07:44:13 <dafis> infix functions*
07:44:13 <kfr> ERR
07:44:15 <kfr> Infix
07:44:17 <kfr> yeah wtf
07:44:21 <kfr> Sorry I was just reading C++ code
07:44:30 <kfr> With the inline keyword
07:44:33 <dafis> commiserations, kfr
07:44:48 <kfr> Every function in Haskell can be used as an infix
07:45:22 <dafis> > 273 `mod` 23
07:45:23 <lambdabot>   20
07:45:34 <byorgey> actually, functions with () around them are prefix.
07:45:38 <byorgey> > (+) 3 5
07:45:39 <lambdabot>   8
07:45:40 <ddarius> Fixity is a property of syntax.
07:47:06 <kfr> > let f x y = x + y in (f 1 1, 1 `f` 1)
07:47:07 <lambdabot>   (2,2)
07:47:13 <kfr> It's the same thing
07:48:50 <Gulanzon> This is all a bit over my head, so I think I'll keep reading :)
07:49:12 <Gulanzon> Thanks though!
07:49:41 <ddarius> Reading is always a good idea.
07:49:56 <ddarius> Well, maybe not if you are being shot at.
07:50:11 <copumpkin> run for cover, then read
07:50:52 <Gulanzon> Not necessarily.
07:50:59 <Gulanzon> What if you're armed with the world's most deadly joke?
07:51:01 <dafis> ddarius: according to Hitchcock's 39 steps, reading can be good when you're being shot at (keep the book in your breast pocket)
07:51:14 <Gulanzon> You definitely want to be out in the open to maximise casualties with that one.
07:51:27 <Egbert9e9> one of my biffs with haskell is that it imports directly into root namespace, making it hard to read if i am not familiar with the modules already
07:51:34 <Egbert9e9> is there a solution?
07:52:17 <mm_freak> Egbert9e9: qualified imports
07:52:26 <mm_freak> import qualified Data.Set as S
07:52:33 <Egbert9e9> when i'm reading other people's code, that is
07:52:43 <Egbert9e9> mm_freak, qualified is pretty cool
07:57:41 <dschoepe> v
07:57:50 <dafis> w
08:02:34 <andres_> hello everydoby
08:02:46 <dafis> hello andres_ 
08:03:02 <andres_> is there a special place for the extension inside a module?
08:03:20 <dafis> at the top, before the "module ..." line
08:03:48 <dafis> andres_: you may put comments before it, but no code
08:04:37 <dafis> "{-# LANGUAGE Foo #-}\n{-# OPTIONS_HADDOCK hide #-}\nmodule Bar where"
08:06:40 <andres_> ok thanks, is there a special extension for datatype empty
08:06:41 <andres_> ???
08:07:10 <dafis> andres_: EmptyDataDecls, iirc
08:07:15 <sipa> {-# LANGUAGE EmptyDataDecls #-}
08:07:45 <dafis> andres_: you can ask $ ghc --supportted-languages to find out how it's spelled
08:07:58 <Mathnerd314> which distribution is best for Haskell? Arch?
08:08:21 <Zao> Mathnerd314: Depends on if you can stomach the general retardedness of Arch :D
08:08:29 <Zao> All distros suck, in different ways.
08:08:29 <artagnon> I read numbers from the command line, but I need a [Char] -> Int to convert the numbers for processing. Example: "34" -> 34. I can't find any such function on Hoogle.
08:08:44 <Zao> > read "9001" :: Int
08:08:45 <lambdabot>   9001
08:08:59 <artagnon> Ah :)
08:09:00 <artagnon> Thanks
08:09:34 <dafis> > read "9001" :: Double
08:09:35 <lambdabot>   9001.0
08:10:04 <artagnon> I just looked up the Read class; thanks.
08:10:26 <CrazyThinker> Zao, Which distribution do you use?
08:10:40 <Zao> CrazyThinker: Depends. Debian mostly.
08:10:56 <Zao> Fedora works nicely too, as they have a reasonably recent GHC in repositories.
08:11:28 <CrazyThinker> Zao, are you using any IDE for haskell or vim?
08:22:56 <andres_> dafi: thanks
08:23:02 <andres_> sipa: thanks
08:24:51 <Zao> CrazyThinker: Mostly vim, and waiting for Phyx-'s Visual Haskell.
08:26:09 <CrazyThinker> Zao, won't that be a windows-only software?
08:26:23 <dafis> just what I wanted to ask
08:27:27 <CrazyThinker> Also, I think that project was dropped by the student who was intern in Microsoft
08:27:49 <Zao> CrazyThinker: There has been several projects with similar names.
08:27:59 <CrazyThinker> oh 
08:28:01 <Zao> CrazyThinker: Christina is currently working hard on it, and it seems that it will be awesome.
08:28:14 <CrazyThinker> any links/articles?
08:28:21 <Zao> http://mistuke.wordpress.com/
08:28:35 <Zao> And yes, it's Windows-only, which doesn't bother me a bit.
08:29:11 <CrazyThinker> Cool, I love open minded guys like that
08:29:16 <dafis> Zao: well, I got the impression you were on linux
08:29:31 <dafis> Zao: so, would you run it under wine?
08:29:32 <Zao> dafis: I use any OS that gets the particular job done.
08:29:43 * hvr just 'cabal install'ed threadscope... and when I try to run it, it only tells me: "threadscope: Most RTS options are disabled. Link with -rtsopts to enable them."
08:29:54 <Zao> FreeBSD, Linux, Solaris, Windows.
08:30:03 <dafis> hvr: use 6.12 ;)
08:30:12 <hvr> dafis: so it's a known bug? :)
08:30:13 <Zao> dafis: If I want to do graphics development, I sure as heck won't do it on a platform that doesn't do Direct3D.
08:30:17 <dcoutts> hvr: hmm, odd
08:30:26 <dafis> hvr: not a bug, an intentional feature
08:30:35 <Mathnerd314> Zao: OpenGL?
08:30:53 <dafis> hvr: I suppose threadscope hasn't yet been brought up to 7
08:30:56 <Zao> Mathnerd314: I do not particularly want to reinvent all of D3DX and XNAMath.
08:31:03 <hvr> dafis: I'm just confused why it says that... cause I didn't give it any RTS-options
08:31:04 <ManDay> hello haskell
08:31:36 <kfr> Hello C
08:31:37 <dafis> hvr: in GHC 7, +RTS options have been mostly disabled for security reasons
08:31:52 <hvr> dafis: yeah, I know.. but I'm calling it w/o any options on the commandline :)
08:32:21 <dafis> hvr: you have to link the executable with the -rtsopts to enable +RTS options; my guess is that that's not yet in threadscopes .cabal
08:32:39 <dcoutts> but it's unclear why it thinks it needs it
08:32:44 <JaffaCake> ah, I see
08:32:49 <dafis> hvr: methinks, threadscope adds rts options on its own
08:32:50 <dcoutts> since hvr is not calling threadscope with +RTS
08:32:54 <JaffaCake> it has a ghc_rts_opts setting
08:33:02 <dcoutts> ah in a .c file
08:33:08 <ManDay> coud you explain why it is    let f x = x * x in f 13      but   let abc = filter (==5) in abc [1,2,5]     and not   let abc x = filter (==5) x in abc [1,2,3]    as I would deduce from the first example?
08:33:08 <JaffaCake> but that shouldn't require -rtsopts
08:33:15 <ManDay> (currently doing the web tut)
08:33:18 <ManDay> *could
08:33:35 <dcoutts> JaffaCake: perhaps the check is in the wrong location
08:33:47 <hvr> JaffaCake: so just updating the .cabal file might fix it?
08:33:51 <dafis> ManDay: you can define a function with or without arguments, as you please
08:34:04 <ManDay> dafis: so its equivalent?
08:34:17 <Zao> Mathnerd314: Same there, the "best" API for the job, which in my currently is Direct3D, as my current tasks do not involve portability.
08:34:20 <dafis> ManDay: yes
08:34:36 <Zao> Mathnerd314: I prefer rapid prototype development and personal education over "lol, it runs on a toaster" :)
08:34:42 <dafis> ManDay: except there are some finer issues regarding monomorphism
08:34:43 <ManDay> if i dont define any arguments and pass arguments to it nonetheless, the function is simply "substituted" i see
08:34:58 <kfr> ManDay: Ah that is partial application/pointfree style
08:35:24 <kfr> ManDay: Haskellers will frequently omit arguments on the right side because they are lazy
08:35:57 <JaffaCake> hvr: yes, just add -rtopts in the .cabal file
08:36:03 <ManDay> i see, the tutorial is prolly not the right approach to haskell :D
08:36:07 <ManDay> thanks guys
08:36:22 <kfr> Let's say you have f :: a -> a -> a; f x y = 1, then f 1 is a function a -> a
08:36:27 <kfr> f is a -> a -> a
08:36:31 <kfr> f 1 is a -> a
08:36:37 <kfr> f 1 2 is a
08:36:48 <ManDay> give me a second to parse that
08:36:54 <ManDay> i m really new to haskell
08:36:56 <kfr> That's partial application, that's also why the Haskell type notation makes perfect sense (not at first though)
08:37:01 <ManDay> all i know about lambda is a wiki article
08:37:06 <aristid> ManDay: the second is over :)
08:37:10 <kfr> That's no lambda
08:37:20 <ManDay> i see, you are not only lazy, you are impatien AND exactp :P
08:37:32 <hvr> JaffaCake: btw, the about-splash-screen says threadscope 0.1.1, while the .cabal version is 0.1.2...
08:37:33 <kfr> Lambda would be \x y -> 1
08:37:50 <dcoutts> hvr: send a patch! :-) make it use the version provided by the cabal file
08:37:56 <ManDay> is that "->" an actual syntax in haskell?
08:38:06 <aristid> yes
08:38:06 <Zao> Mathnerd314: Part of lambda functions.
08:38:10 * roconnor was about to give ManDay a link to eta-conversion on wikipedia, but the section on eta-conversion is both terrible and wrong.
08:38:12 <Zao> \bindings -> body
08:38:15 <dafis> or type signatures
08:38:16 <kfr> ManDay yes, that is how you describe types
08:38:16 <dcoutts> kfr: it's not because we're lazy! It's because it makes them feel superior ;-)
08:38:18 <aristid> damn my internet is laggy
08:38:20 <zygoloid> > (\a b -> a + b) 5 7
08:38:20 <lambdabot>   12
08:38:23 <kfr> And the -> is also used in lambdas
08:38:28 <kfr> dcoutts lol
08:38:36 <Zao> Oh, it's part of type declarations too.
08:38:37 <Mathnerd314> Zao: was that last to ManDay?
08:38:41 <JaffaCake> hvr: thanks, I'll fix that
08:38:42 <aristid> :t (+) :: Int -> Int -> Int
08:38:43 <lambdabot> Int -> Int -> Int
08:38:52 <Zao> Mathnerd314: Yup. Typing more than one character before completing is for the weak.
08:39:23 <Mathnerd314> Zao: then your autocomplete should be more intelligent
08:39:42 <hvr> dcoutts: ...seems I don't need to... even though it would have been easy :)
08:39:48 <Zao> Mathnerd314: I'm accustomed to it being intelligent enough to Do What I Mean.
08:40:14 <Mathnerd314> Zao: but it failed...
08:40:26 <Zao> Mathnerd314: Hush now :D
08:40:28 <Mathnerd314> Zao: rewrite your irc client in Haskell!
08:40:43 <aristid> Zao: with supper intelligent auto complete
08:40:44 <ManDay> is there any difference between [a,b,c] and a:b:c:[] ?
08:40:48 <sipa> no
08:40:54 <aristid> (the "supper" was totally intentional)
08:40:57 <kfr> Yes, the former is shorter!
08:41:07 <dafis> ManDay: readability
08:41:23 <ManDay> dafis: which is considered more readable?
08:41:37 <dafis> ManDay: depends on who you ask ;)
08:41:44 <ManDay> im asking you haskell coders
08:41:58 <dafis> ManDay: usually, most prefer [a,b,c]
08:42:05 <ManDay> ok
08:42:10 <ManDay> i d agree
08:42:36 <aristid> but it's good to know they are equivalent
08:44:24 <ManDay> is there a difference between   let (_,x:_) ....  and   let (_,(x:_)) ?
08:44:41 <sipa> no
08:44:47 <ManDay> (the tutorial rejects the former solution hence i ask)
08:44:49 <ManDay> thanks
08:45:08 <dafis> ManDay: what do you mean 'rejects'
08:45:34 <ManDay> dafis: it has these tests every n steps and i gave it former solution to the question and it didnt say okay
08:45:41 <dafis> if it doesn't pass you to the next lecture, it's because it wants the input exactly as given, I think
08:45:47 <ManDay> yes
08:45:57 <ManDay> but i wasnt sure whether it was that or actual a difference
08:46:29 <dafis> ManDay: it's hard to find whether two expressions are equivalent in general
08:46:35 <aristid> ManDay: which tutorial do you use?
08:46:58 <dafis> so the author went for textual equality (perhaps disregarding whitespace)
08:47:00 <ManDay> dafis: i would have assumed it could have hooked the haskell interpreter and check for the correct return value
08:47:05 <ManDay> like a unit test
08:47:30 * edwardk waves hello.
08:47:36 <dafis> aristid: I believe tryhaskell
08:47:44 <dafis> edwardk: slept well?
08:48:08 <edwardk> quite
08:48:18 <dafis> good
08:48:23 <ManDay> is there a more general version of  fst  which can return the first value of any tuple?
08:48:27 <aristid> hi edwardk
08:48:30 <edwardk> trying to cobble together a memoized traced comonad
08:48:31 <ManDay> aristid: dafis indeed
08:48:32 <dafis> ManDay: no
08:48:43 <ManDay> dafis: weird...
08:48:49 <edwardk> rather a memotrie based traced comonad, which is a bit confusing given the memoized traced comonad =)
08:49:04 <aristid> edwardk: you inspired me to make my code more pointful, and eliminate all uses of (.:)=fmap.fmap. :D
08:49:16 <dafis> ManDay: what type would it have?
08:49:27 <edwardk> aristid: yes, i have accomplished something in the world! =)
08:49:28 <ManDay> dafis: come again?
08:49:38 <dafis> :t fst
08:49:39 <lambdabot> forall a b. (a, b) -> a
08:49:40 <ManDay> dafis im refering to the size of the tuple
08:49:51 <aristid> edwardk: yeah, usually you just produce abstract fluff, but this is REAL :p
08:49:53 <ManDay> fst on anything that is not a 2-tuple fails
08:49:54 <edwardk> aristid: i used to be on the other side of that debate
08:50:10 <aristid> how long ago?
08:50:19 <edwardk> maybe a year and a half
08:50:31 <dafis> ManDay: to get the first component out of every tuple, you'd need fun :: (a,b) -> a; fun :: (a,b,c) -> a etc.
08:50:53 <dafis> ManDay: one could write a type class
08:51:09 <ManDay> dafis: so its not possible in general to have a function that operates on an arbitaily sized tuple?
08:51:16 <dafis> class Firstable tup comp where frst :: tup -> comp
08:51:20 <zygoloid> class HasFst t where type Fst t :: *; fst :: t -> Fst t
08:51:21 <ManDay> but its possible for lists - like map does?
08:51:48 <dafis> ManDay: lists are homogeneous
08:51:59 <dafis> all elements have the same type
08:52:07 <dafis> so you need not know how many there are
08:52:07 <ManDay> yes, why does that matter?
08:52:12 <ManDay> hm
08:52:14 <ManDay> i see
08:52:31 <ManDay> but haskell is not c++ - data size is handled transparently no?
08:52:35 <ManDay> s/c++/c
08:53:06 <dafis> but tuples' components have different types in general, so you need to know which type at what position
08:53:18 <ManDay> why?
08:53:26 <ManDay> the fst function doesnt know either
08:53:30 <ManDay> it just returns the first element
08:53:37 <ManDay> regardless of type
08:53:49 <ManDay> but why can it only do so for 2 tuples
08:54:01 <azaq23> @type fst
08:54:02 <dafis> ManDay: it can be polymorphic, like fst, but then all possible argument types need to have the same structure
08:54:02 <lambdabot> forall a b. (a, b) -> a
08:54:12 <augur> anyone have any pointers to parametricity in explicit (martin-löf style) types?
08:54:33 <dafis> ManDay: have to leave now
08:54:43 <azaq23> > let fst3 (x, _, _) = x in fst3 (1,"d", "g")
08:54:44 <ManDay> thanks
08:54:44 <lambdabot>   1
08:54:56 <azaq23> :t let fst3 (x, _, _) = x in fst3
08:54:56 <lambdabot> forall t t1 t2. (t, t1, t2) -> t
08:56:31 <augur> i suppose it could be that you have rules like   t : type   =>   [] : List t,    x : t   xs : List t   =>   Cons x xs : List t
08:56:35 <ManDay> i did not understand the reason
08:56:44 <augur> i suppose thats a way to get List as a parametric type
08:57:06 <augur> along with the ADT for it
08:57:12 <augur> maybe t : type => List t : type
08:57:25 <augur> in the type domain, strictly speaking
08:57:34 <azaq23> ManDay: A list is not really a type like a tuple in haskell
08:57:56 <azaq23> ManDay: It is an inductive datatype, defined by data List t = Nil | Cons t (List t)
08:58:03 <augur> azaq23: sure it is, it's just a tuple with a type constraint, surely
08:58:07 <augur> maybe
08:58:16 <ManDay> hrm
08:58:47 <augur> i mean, isnt it possible to say    data List t = Nil | Cons (t, List t)
08:59:25 <augur> so that the only purpose of the Cons there is to convey that it's a tuple of a certain sort
08:59:47 <augur> data List t = Nil () | Cons (t, List t)
08:59:53 <augur> to symmetrize this
09:00:27 <azaq23> augur: Yes, you could argue that a list is like (1, (2, (3, (4, NullType)))), then define head = fst and tail = snd and give other primitive functions based on that
09:00:57 <augur> azaq23: but you'd need the Nil/Cons constructors, at least in haskell, i think
09:01:10 <augur> cause data List t = () | (t, List t) just doesnt work
09:01:19 <augur> oh, but
09:01:32 <augur> data List t = Either () (t, List t)
09:01:37 <azaq23> ManDay, augur: Point is, lists seem superficially like tuples (and are basically the same in languages like python) with just one type, but lists are defined inductively using little tuples (product types)
09:01:41 <augur> that works if Either is * -> * -> *
09:01:50 <augur> meta-Either
09:02:21 <azaq23> ManDay augur: Or data constructors, in haskell, and tuples are more primitive types
09:02:23 <ManDay> azaq23: I see, like vectors are to arrays in c++
09:02:33 <ManDay> sorta at least
09:02:39 <ManDay> one is artificial
09:02:42 <augur> cause it the species L = mu x.1 + X*x
09:03:53 <augur> yes yes so because lists are essentially disjoint unions, and because in haskell only data can behave as a disjoint union, you must have constructors
09:04:05 <azaq23> augur: An algebraic datatype is a sum type of product types, so it can be represented using Either and tuples
09:04:06 <augur> because constructors convey the disjoint origin
09:04:12 <augur> hmm yes
09:05:00 <ManDay> In the tutorial it says that multiple arrows can be intrepreted as     a -> b -> c   that   a -> (b -> c)     but that would imply that   map :: (a -> b) -> [a] -> [b]   is a function   "Taking a function from type a to b as input and returning a function from list of type a to type b" which apprently is not true, since map takes a function and a list and makes .... argh, i get it, godamn functional 
09:05:01 <ManDay> programming
09:05:33 <monochrom> both are true :)
09:05:56 <ManDay> yes, i see, former is just the formulation of a function with multiple parameters to the concepts of application and currying
09:06:33 <azaq23> ManDay: Arrays are blocks in memory, vectors in C++ are OO things to represent lists with. Yes, in the "artificial" sense, a list type is "artificial" in haskell and a tuple is more primitive. You can build many things out of tuples, and lists are one part. The whole point of the stuff above was
09:06:37 <ManDay> i somehow get the feeling that the only purpose of functional theory is confusing people
09:06:47 <azaq23> ManDay: To illustrate that [1, 2, 3] doesn't mean "something like a tuple but with only one type"
09:07:21 <ManDay> so functions are applied from left to right
09:07:23 <azaq23> ManDay: But that it means Cons 1 (Cons 2 (Cons 3 Nil))) (using the definition I gave above)
09:07:39 <ManDay> the tutorial should mention  that fnc a b   is actually (fnc a) b
09:08:12 <monochrom> I have a math degree. The biggest lesson I learned from all those math courses is that viewing the same thing from different perspectives helps solve more problems.
09:09:02 <ManDay> monochrom: that is not ultimately true
09:09:12 <ManDay> i can contrive arbitrarily complicated perspectives
09:09:21 <ManDay> yet, they dont necessarily help you understanding an issue
09:09:24 * copumpkin agrees with monochrom 
09:09:28 <jmcarthur> monochrom didn't say *all* perspectives solve problems
09:09:38 <ManDay> jmcarthur: who says function theory is one?
09:09:48 <ManDay> his point might be true but does not adress my argument
09:09:51 <jmcarthur> what is "function theory"?
09:09:53 <monochrom> I say so.
09:10:10 <ManDay> jmcarthur: lambda calculus, functional programming
09:10:34 <ManDay> monochrom: ok.
09:10:38 <jmcarthur> ManDay: i saw you complain about the equivalence of ((a -> b) -> [a] -> [b]) and ((a -> b) -> ([a] -> [b])). i would say this is a *very* useful equivalence
09:10:53 <ManDay> i did not mean to complain about this at all
09:11:02 <jmcarthur> then i guess i don't understand
09:11:06 <ManDay> i was just puzzled about it for a second due to my lack of practice in fnc programming
09:11:10 <jmcarthur> okay
09:11:24 <aristid> jmcarthur: huh? the equivalence is even necessary, because (->) has to have some associativity
09:11:34 <jmcarthur> aristid: (yes)
09:11:35 <monochrom> since you lack practice, you do not know what is useful yet.
09:11:46 <jmcarthur> ^^ was about to say what monochrom said
09:11:48 <ManDay> monochrom: i do not claim to
09:12:02 <ManDay> my point was purely unserious btw
09:12:14 <ManDay> i do not suggest that functional programming exists for the sake of complicity
09:12:27 <monochrom> and then even people with 100 years of experience still fail to recognize useful things
09:12:29 <jmcarthur> bah! you (inadvertent?) troll! :P
09:12:31 <ManDay> er 
09:12:35 <ManDay> not complicity
09:12:44 <ManDay> complexity :D
09:13:04 * hackagebot comonad-extras 0.1.3 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-0.1.3 (EdwardKmett)
09:13:38 <ManDay> jmcarthur: i take that as a compliment assuming it was directed at me :D
09:14:15 <edwardk> added the memotrie-backed traced comonad
09:14:16 <jmcarthur> okay, well, hopefully with experience you will see some of the immense value of this stuff. i feel like i have a much stronger grasp on programming and understanding now that i have integrated it into my thought process
09:14:42 <ManDay> jmcarthur: that could become somewhat of a haskell motto
09:14:49 <ManDay> everyone i ve met having used haskell says that
09:14:59 <jmcarthur> ManDay: it was directed at you, and i did not intend any offense :)
09:15:00 <ManDay> i think i got the hang of currying by now
09:15:20 <ManDay> i still dont think its exactly useful but i already deem it very elegant
09:15:25 <glguy> i feel like i have a much stronger grasp on programming and understanding now that i have integrated it into my thought process
09:15:32 <jmcarthur> oh boy
09:15:57 <azaq23> ManDay: If you come from a language like python, you typically view the function map as taking a function (a -> b) and a list and applying the function to all elements of the list
09:15:58 <ManDay> (by "i still dont think" i suggest that I will come to that point sometime in the future ;))
09:16:29 <azaq23> ManDay: If you see the type of map as (a -> b) -> ([a] -> [b]), you can view it as a function which takes a function f _into_ the list type
09:16:35 <ManDay> azaq23: yes, i already smell that haskell has a superious consistency as opposed to other languages
09:16:42 <jmcarthur> ManDay: the elegance is part of the usefulness, actually. once you realize how simple it actually is (especially compared to imperative, stateful languages), reasoning about your code becomes very easy
09:16:42 <monochrom> there is not much supply of contrived useless equivalences or perspectives --- our society simply suppresses it by way of economics. contrived useless things are your least worry.
09:16:58 <ManDay> thank you
09:17:21 <jmcarthur> *very easy, relatively
09:17:23 <ManDay> is there a usefull haskell compiler that creates bytecode?
09:17:35 <ManDay> maybe a function cpu architecture even? :D
09:17:36 <jmcarthur> ghci makes bytecode, but doesn't save it
09:17:39 <ManDay> *functional
09:17:47 <jmcarthur> there is the latter
09:17:54 <ManDay> really!
09:17:57 <jmcarthur> a few. the most interesting right now i think is the reduceron
09:18:02 <jmcarthur> still a research project
09:18:06 <ManDay> amazing
09:18:17 <jmcarthur> btw, GPU architecture is quite functional
09:18:19 <ManDay> sounds very progressive, if one might say that
09:18:28 <absentia> n/c
09:18:40 <edwardk> the reduceron is a functional cpu architecture
09:19:03 <absentia> running ghc code on a gpu ?
09:19:04 <edwardk> plus there are a number of haskell compilers (nhc, yhc, what have you that create and operate on bytecode reps)
09:19:40 <jmcarthur> the core idea behind GPUs is that you have some operations that are guaranteed to be isolated from other operations happening in parallel. i kind of purity, you could say. it allows the GPU to have the kind of massive parallelism you expect
09:19:51 <ManDay> interesting, haskell has gotten the potential to become my favorite programming language, and that after knowing it for less than an hour, fantastic!
09:20:04 <jmcarthur> absentia: there are embedded languages for generating programs for the gpu within haskell
09:20:14 <edwardk> manday: i came in here to ask a question 5 years ago, and got stuck. ;)
09:20:25 <ManDay> edwardk: i feel ya' :>
09:20:50 <jmcarthur> s/i kind/a kind/
09:21:21 <edwardk> the community was just so _nice_ about everything, and then the language was basically everything I had wanted to build into my toy languages with a cleaner meta-theory than what I'd been able to come up with to that point, so I gave up and became a Haskell guy.
09:21:41 <jmcarthur> the community is one of haskell's best features
09:22:21 <monochrom> instead, most people tend to deny the usefulness of useful alternative perspectives --- their entrenched vested interests demand it. as they grow older they also have more influence and power over "the state of the art" to preserve their self-fulfilling prophecy that "the alternative is useless" --- by controlling what practice looks like, they can control what looks useless.
09:23:04 <edwardk> i freely admit haskell isn't perfect and there are a number of things I'd like to paint differently on the bikeshed, but it's the best thing going atm. ;)
09:23:16 <jmcarthur> @remember monochrom most people tend to deny the usefulness of useful alternative perspectives --- their entrenched vested interests demand it. as they grow older they also have more influence and power over "the state of the art" to preserve their self-fulfilling prophecy that "the alternative is useless" --- by controlling what practice looks like, they can control what looks useless.
09:23:16 <lambdabot> It is stored.
09:23:18 <Palmik> hmm, weird... if I replace string with symbol, I get complaints about 
09:23:20 <Palmik>     Couldn't match expected type `TokenParser st'
09:23:21 <Palmik>            against inferred type `[Char]'
09:23:23 <Palmik>     In the first argument of `symbol', namely `"("'
09:23:46 <Palmik> but  according to this http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-ParserCombinators-Parsec-Token.html#v:symbol the signature of symbol is identical to that of string
09:23:50 <aristid> edwardk: somehow your method of getting into haskell reminds me of how you made ad/rad as a comprehensive way to answer a SO question
09:24:01 <edwardk> aristid: =)
09:24:16 <edwardk> aristid: i feel that question was thoroughly answered at that point =)
09:24:27 <aristid> indeed
09:24:34 <edwardk> now someone just needs to ask a stack overflow question about kata ;)
09:24:46 <absentia> my issue is that I'm required to produce and produce quickly... and i'm working with a system that's primarily locked into another primary language (family) -- so I just don't get a chance to work with (and thus learn) Haskell.  :-<
09:25:38 <edwardk> absentia: i feel your pain. i do a lot of development in scala, c++ and c# as well.
09:27:33 <andres_> how I can find the cabal file for inserting a specifical extension?
09:27:34 <edwardk> hrmm. i think i can make a semigroupoid out of memo-tries, but i'd need to change the api from what conal offers a bit.
09:27:46 <edwardk> that would get me trie composition
09:27:56 <sm> absentia: maybe you can get a foot in the door by using haskell as notation for documenting your system types
09:28:38 <edwardk> sm: thats basically how haskell found its way where i am now. it was sort of the lingua franca for the functional developers
09:28:57 <aristid> was? it is not anymore?
09:29:05 <sm> I used it that way with a rails project, was helpful
09:29:23 <edwardk> now the whireboards are about 50% haskell/50% scala, now that everyone here speaks both
09:30:03 * fryguybob uses haskell for education at work.
09:31:18 <aristid> edwardk: isn't haskell's syntax a bit better for whiteboarding?
09:31:24 <sm> absentia: other ideas: use it for test tools, documentation (pandoc/hakyll/gitit), daemon control (angel project on github)...
09:32:08 <edwardk> aristid; thats why it gets half =)
09:32:27 <dcoutts> andres_: I'm not sure it's clear what you're asking exactly
09:33:10 <aristid> edwardk: would be 0 otherwise? :D
09:37:26 <TheKingsRaven> Hello, I've got a quick question. How can I join two lists so each element is combined with it's equivilent number. E.G. ["foo","bar"] ["foo","bar"] becomes ["foofoo","barbar"]?
09:38:00 <hvr> edwardk: what is scala better for (compared to haskell)?
09:38:05 <jmcarthur> > zipWith (++) ["foo", "bar"] ["foo", "bar"]
09:38:07 <lambdabot>   ["foofoo","barbar"]
09:38:16 <edwardk> hvr: java interop. drawing in java programmers
09:38:31 <edwardk> hvr: also subtyping lets it encode some things I can't say in haskell
09:38:47 <edwardk> hvr: the power to weight ratio is a bit lower though
09:38:56 <TheKingsRaven> Thank you :)
09:39:53 <edwardk> hvr: plus, in the form of scalaz, we largely have carte blanche to design a proper class hierarchy for things like monads and applicatives with no burden of historical mistakes
09:41:10 <edwardk> and with implicits rather than typeclasses its trivial to define members of superclasses. you can use white box inheritance as a code-reuse mechanism as opposed to haskell where black box inheritance is used all the way down, making you pay a complexity tax for the depth of your class hierarchy.
09:41:27 <edwardk> as a result haskell favors the choice of a few good abstractions, over accuracy
09:42:34 <edwardk> but then implicits lose the confluence guarantees you get out of typeclasses, so its not a panacea. haskell's Set for instance can use efficient hedge unions, etc. because it knows the sets are ordered the same way, while the scala equivalent has to insert ont into the other pointwise.
09:42:59 <edwardk> er insert one
09:44:17 <roconnor> edwardk: hi
09:44:35 <edwardk> yo
09:44:39 <edwardk> i added some stores for yoy
09:44:41 <edwardk> er you
09:44:59 <roconnor> oh?
09:45:04 <edwardk> http://hackage.haskell.org/package/comonad-extras-0.1.3
09:45:24 <edwardk> a memotrie backed store, an array backed store, and a zipper into any traversable store
09:45:42 <roconnor> a zipper into any traversable store?
09:46:12 <edwardk> https://github.com/ekmett/comonad-extras/blob/master/Control/Comonad/Store/Zipper.hs
09:47:13 <edwardk> it takes a traversable and builds a comonad out of it, where you can move around in the traversable's contents, and use comonadic store actions to rewrite it, then you can unzipper and obtain the new traversable
09:47:45 <edwardk> gives logarithmic time store actions
09:47:59 <edwardk> (except for the comonadic ones which are of course linear
09:48:08 <edwardk> er except for the extend based ones i mean
09:48:38 <roconnor> interesting
09:48:49 <edwardk> i came up with it a few days ago
09:49:35 <edwardk> it relies on the fact that  i never let you change the shape of the sequence so i can refill the traversable with it
09:50:25 <edwardk> but the rank 2 type kicks it into an -extras package
09:50:37 <shamster> hey folks, here's a problem I'm sure someone has done before: given two lists of objects, where each object has an ID, and the lists are not sorted, how does one create a single list of pairs of one object from the first and one from the second list that both share the same ID. IDs are unique.
09:51:24 <Botje> sort both first, then join them by ID
09:52:09 <roconnor> edwardk: comonads aren't very good at changeing shapes
09:52:16 <jeffwheeler> Duncan sent out an email yesterday about code.haskell.org and others returning soon; does anybody know the status of this?
09:52:21 <shamster> Botje: that makes sense, thanks
09:52:23 <roconnor> edwardk: the zipper is a little 1-dimensional :D
09:52:30 <Botje> alternatively, use a Map (Either a (a,b))
09:52:41 <dcoutts> jeffwheeler: what more info are you after?
09:52:49 <Botje> err, Map ID (Either a (a,b))
09:52:54 <jeffwheeler> Yi is waiting on it; it doesn't seem like anybody has the full, non-lazy repo.
09:52:54 <roconnor> jeffwheeler: Hi!
09:53:01 <edwardk> roconnor: as it should be =) traversables linearize structure =)
09:53:01 <yitz> shamster: or possibly make one list into a map with ID as key, then search for each item from the second list.
09:53:07 <Botje> yeah, that
09:53:09 <jeffwheeler> dcolish: I'm just wondering when our repo might go back online.
09:53:12 <roconnor> edwardk: that is true
09:53:24 <jeffwheeler> Oops, dcoutts.
09:53:32 <shamster> yitz: yes, but I feel that would perform a lot of extra passes through the second list
09:53:52 <edwardk> roconnor: i wonder if there is a similar comonad for zappable functors
09:53:55 <yitz> shamster: why? go through it once
09:54:11 <edwardk> hrmm there is
09:54:21 <roconnor> jeffwheeler: I modified your pointed list package, but I see that you updated it to use the latest fclabels
09:54:32 <dcoutts> jeffwheeler: the main thing we're worrying about is account security, we might be able to get read-only repos back sooner.
09:54:43 <dcoutts> jeffwheeler: would that be useful to you?
09:54:48 <dcoutts> yitz: what do you reckon? ^^
09:55:01 <edwardk> Control.Comonad.Store.Zapper ?
09:55:08 <jeffwheeler> dcoutts: it would; we're actually considering migrating to github, so I just need to be able to run darcs-fastconvert
09:55:26 <roconnor> what is a zapper?
09:55:34 <edwardk> a name i just made up =)
09:55:35 <yitz> dcoutts: i believe we can get jeffwheeler a repo already now, can't we?
09:55:39 <jeffwheeler> roconnor: oh, I saw the update; did I mangle your changes? Somebody sent me an update on github that I used.
09:55:57 <dcoutts> jeffwheeler: ooi, because you're migrating to git or because the service on code.h.o has been shoddy?
09:56:07 * dcoutts notes that one can use git on code.h.o too
09:56:11 <edwardk> roconnor: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Zap.html is how i used to represent them in category-extras
09:56:13 <edwardk> lets start there
09:56:19 <roconnor> jeffwheeler: IIRC all I did was add a constraint to fclabels < 0.5
09:56:28 <gwern> @wn snide
09:56:29 <jeffwheeler> dcoutts: we considered it because it makes the project more "accessible," not because of the downtime
09:56:31 <lambdabot> *** "snide" wn "WordNet (r) 2.0"
09:56:31 <lambdabot> snide
09:56:31 <lambdabot>      adj : expressive of contempt; "curled his lip in a supercilious
09:56:31 <lambdabot>            smile"; "spoke in a sneering jeering manner"; "makes
09:56:31 <lambdabot>            many a sharp comparison but never a mean or snide one"
09:56:31 <dcoutts> yitz: I mean put all the repos up, before we do accounts
09:56:33 <lambdabot>            [syn: {supercilious}, {sneering}]
09:56:33 <shamster> yitz: I see now. I misread that
09:56:35 <edwardk> two functors 'zap' if one has a product everywhere the other has a sum, and vice versa
09:56:46 <roconnor> jeffwheeler: because otherwise cabal was trying to use the latest fclabels
09:56:48 <edwardk> so one describes a 'path' in the other
09:57:00 <edwardk> roconnor: with me?
09:57:01 <jeffwheeler> roconnor: I'll check on that; thanks
09:57:06 <yitz> dcoutts: i think that should be fine now, as long as the server seems to be humming along
09:57:24 <edwardk> my more modern implementation is in the adjunctions package: http://hackage.haskell.org/packages/archive/adjunctions/0.5.2.1/doc/html/Data-Functor-Zap.html
09:57:38 <yitz> dcoutts: there were those mrtg things
09:57:39 <edwardk> which reifies it as a data type, since zapping functors aren't unique
09:57:46 <edwardk> this lets me compose them
09:57:50 <roconnor> edwardk: duality?
09:57:59 <edwardk> roconnor: exactly. i blogged it at one point
09:58:17 <edwardk> http://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/
09:58:51 <edwardk> but note i don't require the functors to be dual, i can zap lots of things. like f -| g gives me that f zaps g
09:59:10 <edwardk> and also that g zaps f, since its a symmetric relationship that is weaker than adjunction
09:59:48 <edwardk> roconnor: so far so good?
10:00:06 <roconnor> kinda
10:00:44 <edwardk> data Zapper f g s a = Zapper (forall a b c. (a -> b -> c) -> f a -> g b -> c) (f a) (g s)
10:00:50 <edwardk> now, make a store out of that ;)
10:01:04 <edwardk> with state g s
10:01:41 <roconnor> that doesn't look like a store
10:01:55 <edwardk> er g () i guess
10:02:32 <roconnor> that looks less like a store
10:02:35 <edwardk> data Zapper f g a = Zapper (forall a b c. (a -> b -> c) -> f a -> g b -> c) (f a) (g ())
10:02:40 <edwardk> bear with me =P
10:02:56 <roconnor> :)
10:03:01 <edwardk> instance ComonadStore (g ()) (Zapper f g) where
10:03:11 <roconnor> oh
10:03:22 <edwardk> the g () describes a path into the f
10:03:29 * roconnor isn't used to thinking of abstract stores
10:03:41 <edwardk> np
10:03:49 <edwardk> =)
10:04:57 <copumpkin> preflex: seen _y_
10:04:57 <preflex>  _y_ was last seen on #haskell 86 days, 21 hours, 18 minutes and 20 seconds ago, saying: I seem to remember some blog entry written in the past year about writing a Haskell DSL lexer/parser for the PDF specification, and then parsing the specification directly, and how the author had revealed a number of inconsistencies in the format in such a way ... but my google-fu is failing me ... figured
10:04:58 <preflex>  I'd ask in the Haskell nexus on IRC
10:05:16 <edwardk> roconnor: there is a connection to representability as well
10:05:29 <aristid> copumpkin: 86 days? you unlucky fool
10:05:42 <edwardk> roconnor: note the data type for Representation: http://hackage.haskell.org/packages/archive/adjunctions/0.5.2.1/doc/html/Data-Functor-Adjunction.html
10:06:05 <edwardk> every right adjoint can be represented by its left adjoint applied to ()
10:06:40 <edwardk> rep and unrep should make the relationship pretty explicit
10:07:04 <roconnor> I don't understand Nat a
10:07:28 <roconnor> or rather I don't understand the Nat a / Stream anhilation
10:07:48 <roconnor> oh
10:07:51 <roconnor> I see now
10:08:05 <edwardk> you grok Identity annihilates Identity right? then.. ah you got it
10:08:32 <roconnor> I was wondering what we were going to do with the value held by Nat
10:08:35 <roconnor> but the value was id
10:08:46 <roconnor> So it was really Nat (Int -> Int) / Stream Int anhilation
10:08:53 <edwardk> yeah
10:09:13 <roconnor> But I don't see what this has to do with the expression problem
10:09:45 <edwardk> i don't recall any more =)
10:10:03 <roconnor> hah
10:10:10 <edwardk> look in the comments
10:10:14 <roconnor> you were supposed to be solving the expression problem
10:10:15 <edwardk> i think i gave an example
10:10:25 <roconnor> the biggest problem in Computer Science other than P = NP
10:10:35 <edwardk> i wasn't i was commenting on wouter's solution, and how you can encode something slightly richer using his machinery
10:10:48 <roconnor> that's what you seemed to be implying
10:11:13 <edwardk> mayhap it was a bit more grandiose than warranted =P
10:11:30 <roconnor> :D
10:11:51 <edwardk> at the time i was doing a lot of work with variant/record duality
10:12:00 <roconnor> :)
10:12:14 <edwardk> so extensible cases are just a record of continuations to go with the variant of constructors
10:12:24 <edwardk> so in this sense it does tackle the expression problem
10:12:43 <edwardk> since extensible cases are a core issue there.
10:13:45 <edwardk> on the other hand extensible records, let you perform field access with extensible variants, so the application to the expression problem requires you to use the extensible sums from wouter's paper.
10:14:12 <edwardk> but rather than encode everything as some ad hoc typeclass you can zap to perform the elimination/case directly
10:14:33 <jeffwheeler> yitz, dcoutts: so, do you think it's possible to get the read-only copy? It'd be very greatly appreciated.
10:14:59 <edwardk> so lets play with Representation =P
10:15:04 <roconnor> okay
10:15:11 <roconnor> I didn't understand representation
10:15:15 <edwardk> http://hackage.haskell.org/packages/archive/adjunctions/0.5.2.1/doc/html/Data-Functor-Adjunction.html
10:15:42 <roconnor> edwardk: I kinda feel your explainations are lacking motivation
10:15:47 <edwardk> a representable functor is isomorphic to Hom(X,-) for some X.
10:15:49 <roconnor> through examples
10:16:00 <edwardk> think of f a as memoizing functions from (X -> a)
10:16:13 <roconnor> ok
10:16:19 <roconnor> so like (a,a)
10:16:26 <roconnor> represents Bool -> a
10:16:44 <aristid> Adjunction ((,) e) ((->) e)
10:16:44 <aristid> this one is curry/uncurry?
10:16:49 <edwardk> technically Bool -> a represents (a,a) =)
10:16:52 <edwardk> but yeah
10:16:57 <roconnor> oh
10:17:10 <roconnor> okay and how X -> a represents (X ->) a
10:17:20 <edwardk> exactly
10:17:29 <roconnor> that verb represents seems to be going backwards
10:17:40 <roconnor> if our goal is to memoize functions
10:17:41 <edwardk> now given a representable functor, we can build a store out of it, by using the representation as an explicit memoization technique
10:18:15 <roconnor> sure, ((x -> a), x) is a store
10:18:27 <roconnor> and (x->a) can be replaced by any isomorphic type
10:18:35 <edwardk> exactly
10:18:56 <edwardk> just playing with 'generalized abstract nonsense' seeking efficient representations for these things
10:19:10 <edwardk> the nice thing is the representable version unlike the pointer or traversable version is total
10:19:41 <roconnor> ya, the partiality of your so called "pointer" store is distrubing
10:20:00 <aristid> it's not just disturbing. it is distrubing.
10:20:06 <edwardk> close your eyes and wish it away ;)
10:20:45 <kevinburke> hey, i'm pretty new to functional programming
10:21:03 <edwardk> i still need to find a nice name for the other 2 modify and put operations that are possible. they make more sense on the indexed store though
10:21:04 <kevinburke> how well does it work to write a solution to a problem in an imperative language and then try and convert that to haskell?
10:21:30 <yitz> jeffwheeler: right now we're thinking through how to make sure that there wasn't any hidden damage to those repos
10:21:52 <roconnor> kevinburke: you can either convert it directly, but there isn't much point in that, or you can totally rework the entire solution into a haskelly one.
10:22:03 <yitz> jeffwheeler: do you have a fairly recent version of your repo anywhere that you can compare it to?
10:22:07 <aristid> kevinburke: it is perfectly possible to program imperatively in haskell, the question is if you want it
10:22:14 <kevinburke> Ok
10:22:16 <jeffwheeler> yitz: I do, but I think it's a lazy repo
10:22:23 <jeffwheeler> zitz: (hence the problem)
10:22:44 <yitz> jeffwheeler: meaning that many of the files will be missing?
10:23:11 <jeffwheeler> yitz: meaning that old patches aren't there, I think; the current version is totally fine
10:23:25 <yitz> jeffwheeler: that's what's most important i think
10:23:37 <jeffwheeler> zitz: I think so
10:23:56 <roconnor> edwardk: don't leave me hanging
10:24:09 <edwardk> hahaha
10:24:10 <edwardk> one se
10:24:13 <edwardk> @hpaste
10:24:13 <lambdabot> Haskell pastebin: http://hpaste.org/
10:25:16 <edwardk> http://hpaste.org/43557/some_indexed_comonads
10:25:30 <edwardk> see 'delay'
10:25:44 <edwardk> i used the indexed version here to make it explicit which states were which
10:26:43 <edwardk> i haven't found a good name for that operation yet
10:27:38 <edwardk> if we view the store as a trifunctor on Hask * Hask^op * Hask -> Hask its the contramap on the second argument
10:27:51 <tengen> is it possible to extend a generic reader (extR / ext1R) with a type class?
10:28:24 <mauke> augur: sorry
10:28:34 <augur> mauke: you better be!
10:28:46 <mauke> also, my client segfaulted after that for some reason
10:28:57 <augur> haha
10:29:03 <augur> crazy
10:29:32 <roconnor> edwardk: ok
10:30:49 <roconnor> edwardk: do we need a delay function on Stores?
10:31:11 <edwardk> it is an operation admitted by the types. i'm just trying to understand it =)
10:31:46 <roconnor> if it is type correct, it must be useful
10:31:51 <edwardk> exactly =)
10:32:26 <edwardk> it lets you play games with the index coming into the function/function representation
10:33:30 <edwardk> effectively with a non-injective function it should let you 'unify cells in the store' in some sense
10:33:44 <Adamant> edwardk: thanks to you, I now kinda-sorta understand morphisms!
10:33:50 <Adamant> thanks!
10:33:55 <edwardk> Adamant: great! =)
10:33:55 <roconnor> edwardk: your get and put functions (I forget what you call them now) are essentially the first and second projection functions, right?
10:34:07 <edwardk> pos and peek?
10:34:11 <roconnor> ya
10:34:35 <edwardk> more or less, peek is flipped around arg wise to make it come into the form of a cokleisli arrow
10:34:46 <roconnor> I mean peek isn't quite the second projection, but it is for the Store comonad.
10:36:03 <roconnor> edwardk: maybe in my paper I will define data Store b a = Store { peek :: b -> a, pos : b }
10:36:37 <edwardk> the only problem i have with that is that peek now has the wrong form w a -> b -> a rather than b -> w a -> a — that latter form is more cleanly extendable
10:36:48 <roconnor> oh right
10:36:57 <roconnor> heh
10:37:02 <roconnor> why would you want to extend peek :P
10:37:12 <edwardk> to get a total store =)
10:37:32 <edwardk> er to get one filled with the same value ;)
10:37:32 <roconnor> edwardk: but it doesn't give you seek
10:37:40 <roconnor> ;)
10:37:45 <edwardk> =P
10:38:16 <edwardk> i knew there was SOME way to get it from mine, i had just assumed it extend ;)
10:38:39 * edwardk <- revisionist ;)
10:38:49 <roconnor> it typechecked!
10:38:55 <roconnor> hard to believe it was wrong
10:39:00 <edwardk> clearly, so it just be correct
10:39:15 <edwardk> you and your pesky logic are at fault. messing up a good thing for no real reason
10:39:55 <edwardk> btw- i'm adding the Apply and Applicative instance to Store.
10:40:52 <edwardk> gluing together states with the semigroup and monoid respectively
10:40:52 <roconnor> AFAIK Store isn't Applicative
10:41:09 <edwardk> Store is the composition of two applicative functors =P
10:41:36 <edwardk> when you have a monoid for your state, its applicative
10:41:43 <roconnor> oh sure
10:41:52 <roconnor> if the state is monoid
10:41:55 <edwardk> yes
10:41:55 <roconnor> interesting
10:42:00 <roconnor> I hadn't considered that
10:42:16 <copumpkin> omg harrop is on twitter
10:42:28 <edwardk> whats nice is its consistent with my symmetric monoidal condition for what was 'ComonadApply'
10:42:30 <roconnor> edwardk: my cartesian store is applicative
10:42:36 <edwardk> so i'm willing to add the Applicative here
10:42:38 <mauke> augur: so I think what happened is that my script thought you'd highlighted ski_impl_em_ve (and one other nick I can't find now)
10:42:41 <edwardk> yep
10:43:23 <roconnor> so I guess where the location type is a monoid then a cartesian store is applicative in two different ways :O
10:43:37 <edwardk> ick
10:44:02 <aristid> :t (+++)
10:44:03 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
10:44:04 <edwardk> for that you'll need to check if one or both is symmetric to see which is desirable
10:44:22 <roconnor> symmetric?
10:44:49 <roconnor> half the point of my cartesian store is that it is applicative 
10:45:09 <aristid> :t \a b -> runKleisli $ Kleisli a +++ Kleisli b
10:45:10 <lambdabot> forall (m :: * -> *) b c b' c'. (Monad m) => (b -> m c) -> (b' -> m c') -> Either b b' -> m (Either c c')
10:45:46 <edwardk> 'essence of dataflow programming'. you can _always_ give a comonad Apply, but its kinda pointless unless that operation is both symmetric and provides you a semimonoidal comonad.
10:46:28 <edwardk> (i can just extract one comonad or the other, then map it over the other, to get a valid signature for (<*>) / (<.>)
10:46:31 <roconnor> edwardk: I'm talking about applicative
10:46:35 <edwardk> yes
10:46:52 <edwardk> then you probably want to keep the applicative you have ;)
10:47:00 <aristid> edwardk: do you have Cokleisli Arrows?
10:47:12 <roconnor> if I have <*> and pure is it symmetric?
10:47:18 <edwardk> aristid: in Control.Comonad from the 'comonad' package
10:47:21 <roconnor> (and satifying the applicative laws)
10:47:29 <edwardk> roconnor: not necessarily
10:47:38 <roconnor> what is the symmetric laws?
10:47:45 <edwardk> EODP provides them look for comonadzip
10:48:06 <roconnor> what is EODP?
10:48:18 <edwardk> essence of dataflow programming a paper by uustalu and vene
10:48:39 <edwardk> a good short read and a nice motivation for using comonads
10:48:41 <aristid>  :t \a b -> runCokleisli $ Cokleisli a +++ Cokleisli b => (w a -> b) -> (w c -> d) -> w (Either a c) -> Either (b d)
10:48:46 <xplat> that was a pretty cool paper, yet somehow i'd expected it to be more profound
10:48:48 <roconnor> I'm to lazy to look them up
10:49:01 <roconnor> so the must not be important
10:49:04 <roconnor> :)
10:49:05 <edwardk> xplat: its not super deep. but keep in mind at the time nobody was using a comonad for ANYTHING
10:49:16 <xplat> hm, good point
10:49:19 <edwardk> (except in linear logic, where (!) is a comonad used everywhere)
10:50:04 <roconnor> hopefully Store and Lenses will invigorate research into comonads
10:50:23 <edwardk> thats one reason why i'm trying to give you so many store variants ;)
10:50:32 <roconnor> :D
10:51:35 <xplat> i'm still waiting for the comonad that is not a pointed container, or else the proof that any comonad can be seen as a pointed container
10:52:16 <edwardk> xplat: lots of them are 'infinite containers' in that sense dealing with functions for the index, etc.
10:52:44 <roconnor> xplat: funny, the pointed container is what helped me really understand what the store comonad was.
10:53:10 <xplat> btw, i wish hoogle did a better job of handling class constraints, or i wouldn't ask this:
10:54:24 <xplat> is there any nice function Alternative f => f (Maybe a) -> f a, or MonadPlus m => m (Maybe a) -> m a
10:54:34 <xplat> sort of a generalized catMaybes
10:55:11 * roconnor adds a comment to his paper that duplicate for store is a lens.
10:55:42 * hackagebot comonad-transformers 1.5.0.2 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.0.2 (EdwardKmett)
10:55:58 <edwardk> added the Apply/Applicative instances
10:56:25 <xplat> it seems like 'lens' is a bit too much of an overloaded term in FP
10:56:34 <roconnor> xplat: I agree
10:56:56 <roconnor> xplat: the other choice for me is to use the term "function reference"
10:57:03 <roconnor> but that gets tiresome after a while.
10:57:10 <roconnor> especially for a paper on the topic
10:57:19 <roconnor> *"functional reference"
10:57:24 <xplat> what are you using 'lens' for again?
10:57:40 <roconnor> "functional references"
10:57:46 <edwardk> xplat: (a -> s -> a, a -> s)
10:57:56 <roconnor> fclables / data.accessor
10:58:00 <roconnor> *fclabels
10:58:12 <stepkut> does anyway understand how to use cabal-dev? I don't get it :(
10:58:54 <xplat> ah, right, that kind.  i like it best for the 'invertible function equipped with inverse' sense
10:59:17 <edwardk> the invertible function case is a special case of the more general lens concept
10:59:34 <edwardk> thats where benjamin pierce borrowed it from
10:59:58 <roconnor> if I were to redesign haskell I would make field labels generate lenses instead of projection functions.
11:00:03 <xplat> ah, right, where the update member is of the form 'const f'
11:01:03 <xplat> yes, that would be a much better use for field labels.  and then the update syntax could desugar in a way that would work on any lens.
11:01:31 <roconnor> xplat: I hadn't even considered that
11:01:32 <edwardk> roconnor: yeah
11:02:07 <sproingie> sounds reasonable to implement and propose as a language extension
11:02:19 <sproingie> no one's really satisfied with the status quo after all
11:02:23 <roconnor> sproingie: I don't think it is that simple
11:02:43 <roconnor> sproingie: whatever it is that I'm thinking of,  I doubt it is backwards compatible
11:02:45 <xplat> the problem is it's not backward-compatible with (non pattern-matching) read access
11:03:51 <xplat> you'd need to have an extra function or operator or bit of syntax in there that isn't now, or else you'd need to open the can of worms marked 'overloaded apply'
11:04:20 <sproingie> yay overloaded whitespace
11:04:41 <yitz> non-compatible syntax changes can be managed with LANGUAGE pragmas. there has to be some way to move forward.
11:04:47 <sproingie> (yah i know it doesnt require whitespace)
11:05:09 <sproingie> extra bit o syntax might work.  what looks nice?
11:05:13 <roconnor> sproingie: I was helping explain lambda calculus to a confused fellow.  When I said that whitespace was left associative he practically stormed out in frustration. :D
11:05:27 <ruks> hi
11:05:50 <roconnor> sproingie: I like data accessors ^. operator
11:06:06 <roconnor> good ol' pascal
11:06:17 <ruks> ok so im using haskell for the first time anyone got any tips
11:06:40 <xplat> heh, that brings back memories
11:06:41 <sproingie> really cumbersome to type.  but i'm not sure there's much punctuation left that isn't
11:07:50 <xplat> sproingie: €
11:10:18 <sproingie> you and yer furriner money
11:10:47 <yitz> just got the bulletin - no leap second this june.
11:11:14 <gwern> drat. I had a bet on that
11:11:24 <gwern> now the whole neighborhood leap second pool will be laughing at me
11:11:34 <gwern> how can I face them at the watering hole?
11:11:56 <xplat> by shaving a face into the back of your head
11:11:59 <Dae_> Is there any status on when code.haskell.org sites will be back?
11:12:06 <Botje> proclaim a leap second anyway!
11:15:35 <Dae_> That's a no then.... :S
11:16:48 <gwern> @wn roof-rabbit
11:16:49 <lambdabot> No match for "roof-rabbit".
11:16:56 <gwern> pfft. wordnet is overrated
11:17:06 <roconnor> Dae_: http://www.haskell.org/pipermail/haskell-cafe/2011-February/088829.html
11:18:07 <elliott> What's the shortest way to repeat a list N times? concat (replicate n xs)?
11:18:34 <monochrom> I think so.
11:18:55 <xplat> @hoogle Map Char a -> Parser a
11:18:55 <lambdabot> No results found
11:19:15 <elliott> right
11:19:32 <edwardk> you could swap join in for concat to get it shorter ;)
11:19:42 <Wooga> hello, can i somehow use List monad inside of IO monad?
11:19:47 <Dae_> Why would anyone hack haskell.org??  Well, whoever he is, he stopped me from installing hmatrix this evening
11:20:01 <edwardk> wooga: of course, just pass around lists
11:20:18 <edwardk> wooga: if and you can sequence actions over finite lists using mapM, etc
11:20:23 <burp> Dae_: works for me
11:20:27 <roconnor> Wooga: somewhere there is a proper listT transformer floating around
11:20:29 <burp> Dae_: http://hackage.haskell.org/package/hmatrix-0.11.0.0
11:20:31 <Wooga> thanks
11:21:02 <Dae_> burp, ahh yes. Cabal can fetch it quite nicely. I'm on windows and need the GSL+LAPACK package hosted on code.haskell.org
11:21:08 <xplat> there's not a proper ListT anywhere since it's not self-applicable, but there are proper-ish ones here and there
11:21:35 <edwardk> xplat: there is a proper one, you just need to interleave the actions with each cons-cell
11:21:42 <Dae_> burp, you're allowed to laugh
11:21:44 <edwardk> which makes it not the one in transformers
11:22:11 <burp> uh, ok
11:22:12 <olsner> elliott: [1..n] >> xs
11:22:21 <elliott> olsner: heh nice
11:22:27 <elliott> olsner: this program is pointfree though
11:24:07 <aristid> edwardk: hmm, i just thought: if kleisli arrows are a -> m b and cokleisli arrows are w a -> b, then maybe w a -> m b might make some sense too. does it? :)
11:24:16 <edwardk> aristid: they do
11:24:24 <edwardk> aristid: they go by 'bikleisli' arrows
11:24:29 <edwardk> but in general i find them useless ;)
11:24:49 <olsner> elliott: hmm, pointfree... ((>>) . enumFromTo 1) maybe, or just (join .: replicate)
11:24:50 <edwardk> they tend to build up a lot of monadic side-effects, you need a distributive law between w and m to use them
11:25:05 <elliott> olsner: ouch
11:25:08 <elliott> :t (.:)
11:25:08 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
11:25:09 <edwardk> so to apply one you need to run all the monadic side-effects forward from the start.
11:25:11 <xplat> @type flip (>>=) . replicate
11:25:12 <lambdabot> forall b. Int -> [b] -> [b]
11:25:12 <elliott> is that in prelude?
11:25:25 <olsner> elliott: nope
11:25:28 <aristid> elliott: (.:) = fmap.fmap and is NOT in prelude
11:25:30 <elliott> the program in question is
11:25:31 <edwardk> in practice i find its better to talk instead about comonads over a kleisli category or monads over a cokleisli category
11:25:31 <elliott> main=interact$unwords.(`replicate`"yes").(`div`2).length
11:25:32 <elliott> aristid: right
11:25:36 <Wooga> thanks
11:25:38 <Wooga> oh, sorry
11:25:44 <Wooga> wrong terminal to up+enter
11:26:12 <aristid> edwardk: huh? isn't that just different words for the same thing? it's all w a -> m b, right?
11:26:18 <edwardk> that gives you w a -> m a as extract for the comonad, but w a -> m (w a) — as the extended form. this avoids unnecessary monadic side-effects
11:26:22 <aristid> edwardk: do Bimonads exist? :>
11:26:37 <edwardk> aristid: they are called dyads. sadly fokkinga published a paper on them
11:26:43 <alpounet> edwardk, no i don't just run away crying when i see you saying such stuffs, i actually understand them
11:26:50 <alpounet> that'll be one of my victories in life
11:26:54 <alpounet> s/no/now/
11:27:00 <edwardk> but i later proved that there aren't any that aren't either a comonad or monad. the laws he put on them were too tight
11:27:45 <elliott> edwardk: haha
11:27:47 <edwardk> aristid: its a subtle shift in semantics as to how you glue together those w a -> m a arrows
11:28:37 <edwardk> i included them in category-extras before i did the proof that there aren't any dyads where one or the other of the two sides isn't Identity ;)
11:28:54 <xplat> is there a standard name for (maybe mzero return)?
11:28:59 <edwardk> if i can find it i have that lying around in agda
11:29:05 <starclouded> yo creo q voy a tener un encontron con el profesor
11:29:20 <edwardk> xplat: not afaik
11:29:35 <roconnor> edwardk: all of fokkinga's examples had one or the other the idenitity?
11:29:40 <roconnor> edwardk: sounds like a lame paper
11:29:46 <edwardk> roconnor: he didn't provide _any_ examples
11:29:48 <edwardk> merely laws
11:30:03 <roconnor> who publishes such nonsense?
11:30:22 <ddarius> roconnor: You can get anything published.
11:30:24 <xplat> always dangerous to write about things where you don't include a constructive proof of existence
11:30:24 <edwardk> http://doc.utwente.nl/66623/1/db-utwente-4061421C.pdf
11:30:25 <starclouded> hello everybody
11:30:27 <roconnor> :)
11:31:01 <xplat> outside of set theory and topology, anyways
11:31:22 <edwardk> IIRC it was his eta-law that destroyed their usability
11:31:28 <roconnor> US Letter is wider than A4?
11:31:43 <xplat> in set theory it's more like if you can provide a constructive proof of existence it must be too boring to publish about
11:32:32 <roconnor> xplat: :)
11:33:09 <edwardk> anyways, he did call it the 'least common generalization of a monad and a comonad' he just didn't say that the set wasn't exactly the same size as the set of the union of all monads and comonads ;)
11:33:12 <roconnor> ACM 2 column conference format is retarded
11:33:42 <xplat> heh, when you think about it that way it's kind of brilliant
11:33:48 <edwardk> a shame. i found the paper after reading his dissertation. i loved his dissertation.
11:34:31 <xplat> a characterization of exactly the monads and comonads through a common set of laws, no explicit disjunction
11:35:00 <xplat> would have been more brilliant if he'd done it on purpose, though
11:35:05 <edwardk> yeah
11:35:47 <edwardk> to be fair it was 1993 ;)
11:35:55 <byorgey> hi starclouded 
11:36:02 <edwardk> folks were still kicking the tires on monads for computation at the time
11:36:09 <edwardk> and arrows had just popped up
11:36:28 <edwardk> its easy to poke fun with 18 years of additional context
11:38:00 <xplat> just think of all the fun we can have with aristotle
11:39:10 <roconnor> what does a nine-point font on a ten-point baseline mean?
11:42:44 <xplat> nine pounds of shit in a ten-pound sack?
11:45:28 <jmcarthur> roconnor: it means the font is actually nine points but the lines are spaced enough for a ten point font
11:45:30 <allbery_b> "extra spacing between lines"
11:45:38 <augur> mauke: whats ski_impl_em_ve
11:45:38 <allbery_b> by 1pt
11:45:42 <jmcarthur> roconnor: and those numbers sound cramped
11:45:57 <roconnor> jmcarthur: they are the retarded values for ICFP sumbissions
11:46:01 <mauke> augur: nicks (separated by _ to avoid accidental highlighting)
11:46:02 <jmcarthur> 9/9 would mean that the lines are practically touching
11:46:09 <jmcarthur> ew
11:46:47 <augur> mauke: oic
11:47:16 <augur> so you mean it kicks people if you highlight 4+ people at once?
11:47:33 <mauke> silences, 5, but yes
11:48:03 <augur> hm!
11:55:48 <starclouded> someone knows something about interface datatype?
11:56:01 <Botje> "interface datatype"?
11:56:03 <jmcarthur> starclouded: what's an interface datatype?
11:56:05 <Botje> there's no such thing in haskell
11:56:37 <jmcarthur> well there may be such a thing, but if there is it's not commonly called that, for sure
11:57:00 <Botje> did you mean a typeclass? which is kind of like java interfaces..
11:57:12 <jmcarthur> it's pretty different from java interfaces
11:57:22 <jmcarthur> :t (+)
11:57:22 <lambdabot> forall a. (Num a) => a -> a -> a
11:58:06 <jmcarthur> you can do a few similar things though
11:59:01 <chrisdone> I am so sick of segmentation faults.
11:59:01 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:59:09 <chrisdone> @messages
11:59:09 <lambdabot> scatman said 2m 7d 15m 43s ago: I'm the scatman. Ski bi di bi di do bap do Do bam do Bada bwi ba ba bada bo Baba ba da bo Bwi ba ba ba do.
11:59:09 <lambdabot> copumpkin asked 13d 17h 41m 38s ago: what happened to your IRC log search engine btw?
11:59:24 <jmcarthur> wtf
11:59:27 <chrisdone> Uh, ok.
11:59:35 <copumpkin> lol
12:00:31 <chrisdone> https://github.com/chrisdone/hulk <- I have three branches, one implementing plugins for the server, one implementing hint, and another openssl. All three segfault. Worst. Week. Ever.
12:00:36 <roconnor> jmcarthur: so what is the standard basline for a 9-point font?
12:00:47 <djahandarie> Haha hey chrisdone, how's it going
12:00:56 <starclouded> the interface datatype was something that a read in a paper
12:01:15 <chrisdone> djahandarie: Right now? Crap. :-P
12:01:20 <starclouded> i was hopping that someone knew something about it
12:01:23 <djahandarie> lol :(
12:03:03 <chrisdone> So here's my patch converting my *very simple* socket connections to using the HsOpenSSL library: https://github.com/chrisdone/hulk/commit/6faaab5e4f510387187ab8586065f67775300c24 Can anyone experienced with this library see any obvious mistakes? The library doesn't say what I should initialise in the context so I've done the private key and the certificate. The SSL.accept line causes the crash.
12:03:08 <aristid> @hoogle IsString
12:03:08 <lambdabot> Data.String class IsString a
12:03:31 <jmcarthur> roconnor: normally it would be 9/11 or so
12:03:41 <jmcarthur> roconnor: 9/10 isn't *too* bad
12:04:19 <EvanR-work> two outta three aint bad
12:05:23 <jmcarthur> 9/11, 10/12, 11/13, and 12/15 are probably the most common ones
12:08:34 <jmcarthur> roconnor: is this by chance a two column layout?
12:08:53 <Palmik> Hmm... which one should one use? Text.ParserCombinators.Parsec or Text.Parsec? Or are they the same?
12:09:09 <jmcarthur> roconnor: if so, the 9/10 is probably actually good, since the lines are also narrow, so my critiques are unwarranted
12:09:28 <jmcarthur> s/critiques/criticism/
12:09:47 <monochrom> Text.Parsec is more modern and general.
12:09:52 <gwern> http://hpaste.org/43559/random_issue <-- thoughts? sprinkling in ::Ints doesn't seem to fix it but simple cause a 'no instance for (RandomGen Int)'
12:09:56 <gwern> *simply
12:10:00 <chrisdone> My crappy internet went off. Did anyone answer my cry for help or did it bathe in silence as per?
12:10:03 <Palmik> monochrom, ah, I see, thanks :)
12:10:32 <jmcarthur> :t getStdRandom
12:10:33 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
12:11:06 <monochrom> :t randomR
12:11:07 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
12:11:18 <cuzzie> > [1,2] ++ [3,4]
12:11:19 <lambdabot>   [1,2,3,4]
12:11:23 * roconnor wishes Texmacs wasn't so terrible
12:11:46 <monochrom> :t next
12:11:47 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
12:11:58 <jmcarthur> gwern: you're not getting a gen on that line. you're getting some random value
12:12:08 <Palmik> weird, "cabal install Parsec" says that I already have it but when I try to import Text.Parsec.* instead of Text.ParserCombinators.Parsec. I get "could not find the module" error :/
12:12:24 <dcoutts> Palmik: version 2 vs version 3
12:12:36 <dcoutts> default version is v2, but perhaps you want v3
12:12:42 <monochrom> ah, indeed, gen::Int, next gen :: What?
12:12:52 <gwern> jmcarthur: ...I see
12:13:10 <gwern> I guess I could just call getStdRandom twice for x and y
12:13:19 <jmcarthur> it looks like getStdRandom should really be called withStdGen
12:13:20 <Palmik> dcoutts, hmm, I do not get what you mean :/
12:13:48 <monochrom> Text.Parsec is in parsec version 3 only.
12:13:53 <dcoutts> Palmik: the version you have installed is version 2, but it sounds like what you want is version 3
12:13:58 <jmcarthur> gwern: isn't there a getStdGen you could use?
12:13:59 <gwern> jmcarthur: and I could also learn to more carefully read type sigs rather than go by names and examples
12:14:16 <dcoutts> Palmik: the default version that comes with the haskell platform (or if you cabal install with no version constraint) is version 2
12:14:27 <Palmik> ok, thanks :)
12:14:30 <jmcarthur> heh
12:14:38 <dcoutts> Palmik: cabal install 'parsec >= 3'
12:15:13 <Palmik> yep, got it :)
12:15:15 <Palmik> thanks :)
12:15:16 <tibbe> dcolish: how goes 1.10?
12:15:17 <djahandarie> When does attoparsec result in a partial result?
12:15:27 <tibbe> djahandarie: when it needs more input
12:15:30 <djahandarie> Because I keep on getting one no matter what I do
12:15:50 <djahandarie> Even manyTill anyChar endOfInput
12:15:54 <tibbe> djahandarie: do you parse possible infinite series of stuff?
12:16:11 <tibbe> djahandarie: you need to feed it an empty input (IIRC) to indicate EOF
12:16:39 <monochrom> perhaps manyTill does not mean what you think.
12:16:49 <djahandarie> It did what I wanted in Parsec
12:18:52 <Veinor> what's the name for (λx. x x)?
12:18:57 <monochrom> id
12:19:05 <Veinor> er, (λx. x x) (λx. x x)
12:19:09 <monochrom> oh oops, not id.
12:19:12 <companion_cube> omega
12:21:33 <roderyk> I've got a couple questions about gtk2hs on MacOSX. Just starting off fresh, should I install ghc 7.0.1 (e.g. one of the x64 contrib builds or the official x32?) and cabal install gtk2hs-buildtools and gtk? Will this setup run? Does it support Cairo? Glade?
12:22:32 <roderyk> Or should I install the haskell-platform from Homebrew? It sounds like ghc 6.x won't build gtk2hs 0.12 from hackage... right?
12:23:24 <monochrom> eh? most people built gtk2hs 0.12 by ghc 6.12.3.
12:23:25 <roderyk> Or is the entire setup currently borked? (just like the gtk2hs sounds to be down for over a month... :/)
12:24:13 <monochrom> the website is an unrelated story
12:24:24 <roderyk> monochrom: ah, ok. great! so no real reason to try to run ghc 7 on a mac? Just stick to haskell-platform for the time being?
12:24:39 <monochrom> I don't know about that.
12:25:09 <roderyk> I'm mainly interested in getting it up and running; Cairo is a must, but glade would be nice too. I used to play with it on Linux, but I'm completely new to ghc on a mac
12:25:24 <Eduard_Munteanu> Hm, is there a HP for GHC 7 yet?
12:25:30 <monochrom> I am scared of mac.
12:25:41 <Eduard_Munteanu> You could stick to GHC 6.12, though.
12:26:19 <roderyk> Eduard_Mu: there's no link on the main website; but the release was supposed to be yesterday...? Or has 2011.2.0 been pushed back?
12:26:50 <lysgaard> Anyone have experience with concurrent state, MState?
12:26:53 <monochrom> there is some probability that new haskell platform surrounding ghc 7 will be Feb 11
12:26:58 <Eduard_Munteanu> I don't know about that, I only use the platform under Wine here, and haven't updated in a while.
12:27:15 <smiley325> hi
12:27:22 <Eduard_Munteanu> (especially since only an older gtk2hs worked for me under Wine)
12:27:28 <Eduard_Munteanu> Hi, smiley325 
12:27:37 <smiley325> is anyone else having trouble with code.haskell.org?
12:27:48 <smiley325> darcs can't seem to find any repos
12:27:53 <monochrom> everyone is. down.
12:28:13 <roderyk> great, thanks for the comments.. guess I'll try to go get a hello world running :)
12:29:35 <smiley325> does anyone know how to get a Table from a Database in haskelldb?
12:30:09 <monochrom> assuming you already have gtk+ lib and dev files (*.h, *.so, *.a): cabal install gtk2hs-buildtools, then cabal install gtk (this includes cairo), then cabal install glade
12:30:37 <monochrom> but I have only done it on linux. I fear mac.
12:31:49 <tibbe> dcoutts: how goes 1.10?
12:31:54 <roderyk> monochrom: I don't have the gtk+ libs ready yet; I'm also struggling if I should stick to the X11 version or if the aqua port of gtk will work (which would be most preferable)
12:32:41 <Eduard_Munteanu> IIRC, the developer of Gtk2Hs is a Mac user, so it should work.
12:37:57 * roconnor thinks he more or less has figureout the ICFP formating
12:41:32 <Eduard_Munteanu> roconnor: well don't they publish some LaTeX document classes or something?
12:41:43 <Eduard_Munteanu> Like AMS does?
12:43:37 <roconnor> Eduard_Munteanu: I don't know LaTeX
12:43:42 <roconnor> and I dislike LaTex
12:44:54 <monochrom> finally, someone who has taste :)
12:45:11 <roconnor> monochrom: I use TeXmacs
12:45:23 <roconnor> which I also don't like.
12:45:37 <Eduard_Munteanu> I have my quarrels with it too, but I couldn't point my finger to a better alternative.
12:45:53 <Eduard_Munteanu> There's 'lout' but it doesn't seem to be anywhere near.
12:45:55 <kmc> TeX is terrible except that it produces beautiful output
12:45:56 <roconnor> mostly because it is kinda buggy
12:46:15 <Eduard_Munteanu> I use 'latex' with vim, plainly.
12:46:34 <roconnor> TeXmacs has the best mathematics entry system I've encountered
12:47:01 <roconnor> I kinda want to rewrite TeXmacs from scheme into Haskell ... and remove all the emacsisms
12:47:06 <monochrom> I use Roland Backhouse's http://www.cs.nott.ac.uk/~rcb/mathspad/
12:47:56 <roconnor> monochrom: screenshots?
12:48:07 <Eduard_Munteanu> I agree it's a kinda crappy language.
12:48:24 <Eduard_Munteanu> Now I wonder if there is any typesetting Haskell EDSL :)
12:48:38 <monochrom> I'll have to make my own screenshots after half an hour.
12:51:05 <monochrom> well it seems I have a screenshot now
12:51:15 <stulli> I'm getting weird behaviour when writing to a socket handle. Could that be because of lazy evaluation?
12:51:51 <mauke> stulli: unlikely
12:52:10 <monochrom> http://www.vex.net/~trebla/tmp/mathspad-shot.png
12:52:40 <monochrom> But a screenshot doesn't do it justice. A screencast is better but I don't know how to make screencasts.
12:52:45 * roconnor updates texmacs
12:53:33 <Eduard_Munteanu> Looks interesting, except the damned X11 widgets look.
12:53:40 <Eduard_Munteanu> Which is horrible :)
12:54:20 <monochrom> Anyway you see one operand of a 5-term conjunction is the current selection. when I use the left-right arrow keys, it goes to the other operands of the same conjunction. if I press the up arrow key, it goes to the whole conjunction. Yes this is expression-tree editing and navigation.
12:55:47 <monochrom> There is also automatic parenthesizing. There is also proportional spacing: a deep subexpression gets more space on the left and the right.
12:57:06 <roderyk> monochrom: jeez, no wonder you're scared of macs! No matter how spiffy the expression-tree editing may be, I wouldn't be able to actually think with that thing staring back at me. Emacs24 -cocoa FTW
12:57:13 <monochrom> Err that is not an accurate description of proportional spacing. if all operands are shallow trees, they are kept tight together like "a+b+c". if some operand is a deep tree, they are spread apart like "a + b*b + c"
12:57:34 <copumpkin> omg it's kermit
12:57:43 <kulakowski> roderyk: How has 24 been for you? I haven't yet made the switch (also running -cocoa, though)
12:57:51 <roconnor> monochrom: how do I write an alpha?
12:58:23 <monochrom> there is some other window you can open and pick α from there
12:58:24 * copumpkin writes his TeX using ed
12:58:39 <Eduard_Munteanu> Heh.
12:58:43 <roconnor> monochrom: ugh
12:58:45 <monochrom> and now I really have to go for half an hour
12:58:46 <roconnor> no sale
12:58:50 <roconnor> monochrom: thanks
13:00:11 <roderyk> kulakowsk: I can't complain; no real bugs to speak of. Although I'm rather new to macs in general, so can't say I have really pushed my emacs24 a lot to the edges. (As part of the exercise, though, I did switch over to a barebones .emacs with elpa and package.el)
13:01:16 <Eduard_Munteanu> I'm thinking giving 'lout' a try some time.
13:02:22 <kulakowski> roderyk: Yeah, I was curious about that (elpa included by default) (what do you have installed with it? I have no sense of what is available, or how easy or not it is to wrap something up as a package for it), and about bugs.
13:06:48 <roderyk> kulakowsk: hasn't crashed on me yet; but I did go through an BankruptEmacs cleansing, so I can't say how well it interops with everything. I've mainly been busy with python and ruby lately, so just got the basics from elpa (ruby, python, magit, etc). No slime, ecb, or other bigger packages yet.
13:08:32 <roderyk> Although I used to work from a forked emacs-starter-kit (which used lots of elpa back when it wasn't cool) and it did the job just fine; so I don't think there should be any real issues. Not sure how much work it is to package something in the current workflow.
13:13:22 <Younder> slime, auctex and nxml are soe of the reasons I still use emacs
13:13:50 <Younder> And what does that have to do with Haskell?
13:14:26 <roderyk> Younder: just OT banter :)
13:17:08 <monochrom> ha I'm back
13:17:16 <dafis> from where?
13:17:31 <maurer_> Are there instructions anywhere for running a hackage like repo for personal stuff that really doesn't belong on hackage proper?
13:18:45 <parcs> maurer_: yackage is supposed to accomplish just that
13:20:24 <maurer_> parcs: I don't suppose there's some way of doing it where I could dump it on a colo box I have? The issue I'm seeing with yackage is that it can't be integrated with apache or similar.
13:20:59 <maurer_> And they don't let random ports go through, so actually serving it along with my site would be ideal.
13:24:21 <monochrom> roconnor: This is exactly why a screenshot doesn't do it justice. The majority of expressions are in calculational proofs. The major activity in calculational proofs is you have an expression on one line, and the next line is the same expression again except some subexpression (f α + f β) is mutilated. That means I clone the line above, then delete (f α + f β), and enter (g α * g β) there.
13:24:52 <monochrom> Even then, you see the mutilation could use a lot of copying.
13:25:10 <parcs> maurer_: you can set up a reverse proxy to point to yackage's http server
13:25:46 <monochrom> So if a proof has 20 α's, I probably enter 2 of them by hand, the rest are obtained by cloning expressions wholesale. No, entering α by mousy thingies is not a concern.
13:25:59 <parcs> if you are using nginx, it is a very simple process :)
13:26:08 <monochrom> And I just press alt-ctrl-c for cloning.
13:26:31 <kulakowski> monochrom: Not that I have used this, but isn't entering an alpha via the keyboard orthogonal to cloning one?
13:27:34 <copumpkin> jix: you should've posted this in here :P 
13:27:36 <copumpkin> http://www.theclerics.com/images/Middle%20Finger%20Tree.jpg
13:27:52 <opqdonut> I have tons of prop_* scattered in my code, and am using "quickCheck *hs" to run tests
13:27:53 <jix> also http://www.technovelgy.com/graphics/content05/bush-robot-fingers.jpg
13:27:56 <mauke> that's not how finger trees
13:27:57 <Twey> I thought that was going to be some clever data-structure pun
13:27:57 <monochrom> kulakowski, this software doesn't let me enter α by keyboard at all, so people cry "heresy", and I have to explain why I don't care, it is not part of the tight loop hotspot, nothing to optimize.
13:28:03 <opqdonut> now I finally cabalized the project, any tips?
13:29:16 <monochrom> My tight loop hotspot and my biggest concern is selecting a subexpression to be deleted properly, and when I enter another subexpression in its place, parentheses are correctly inserted if necessary.
13:29:45 <copumpkin> opqdonut: the new cabal test machinery
13:31:32 <monochrom> I don't know how texmacs displays expressions, but with raw LaTeX you miss the tree for the characters. You tend to replace the wrong string of characters and you tend to forget parentheses. If texmacs displays math symbols as math symbols not as code, perhaps it's better, but still not as nice as computer-aided tree navigation.
13:31:37 <saml> @google haskell
13:31:38 <lambdabot> http://www.haskell.org/
13:31:51 <saml> @google TLB
13:31:52 <lambdabot> [];google.dlj=function(b){window.setTimeout(function(){var a=document.createElement("script");a.src=b;document.getElementById("xjsd").appendChild(a)},0)};
13:31:52 <lambdabot> if(google.y)google.y.first=[];if(!google.xjs){google.dstr=[];google.rein=[];if(google.timers&&google.timers.load.t){google.timers.load.t.xjsls=new Date().getTime();}google.dlj('/extern_js/f/CgJlbhICdX
13:31:52 <lambdabot> MgACswRTgALCswWjgALCswDjgALCswFzgALCswJzgALCswPDgALCswUTgALCswCjgAQC8sKzAWOAAsKzAlOM-IASwrMEA4ACwrMEE4ACwrME04ACwrME44ACwrMFQ4ACwrMGk4ACwrMBg4ACwrMCY4ACyAAiiQAi4/punwlAOKLZY.js');google.xjs=1}google.
13:31:52 <lambdabot> drhs=1;var oldElement=document.getElementById('tbt3');if(oldElement){oldElement.parentNode.removeChild(oldElement);}delete google.ww;google.mc = [];google.mc = google.mc.concat([[14,{}],[81,{}],[78,{
13:31:52 <lambdabot> }],[64,{}],[105,{}],[22,{"m_error":"\u003Cfont color=red\u003EError:\u003C/font\u003E The server could not complete your request.  Try again in 30 seconds.","m_tip":"Click for more information"}],[
13:31:54 <lambdabot> [15 @more lines]
13:31:56 <lambdabot> http://en.wikipedia.org/wiki/Translation_lookaside_buffer
13:31:57 <saml> what's going on?
13:31:58 <lambdabot> Title: Translation lookaside buffer - Wikipedia, the free encyclopedia
13:32:08 <saml> WHAT IS GOING ON WITH LAMBDABOT?
13:32:14 <opqdonut> copumpkin: do you have a pointer?
13:32:36 <opqdonut> the manual I guess
13:33:20 <copumpkin> opqdonut: it's still experimental
13:33:38 <copumpkin> but with the latest cabal and cabal-install, you can do some neat stuff
13:33:52 <opqdonut> indeed, I can't find anything in the manual
13:34:26 <kulakowski> monochrom: I agree that tree navigation is good. But I think that a lot of people do actually care about not having to use the mouse for something like that, and I don't see how it would affect your workflow.
13:34:53 <kmc> it's cool how Optimized Best Practices Javascript looks the same as obfuscated malware javascript
13:35:32 <gwern> kmc: that's true of pretty much every lang. take dons's highest performance haskell, run it through a reformatter...
13:36:40 <ddarius> Interesting...
13:37:07 <systemfault> Well, javascript is plenty fast on chrome.. I don't know why anyone would sacrifice code clarity for performance..
13:37:21 <monochrom> roderyk: I fear mac because of incompatibilities and mutual-exclusive choices such as "should I use macports or should I use <I forgot the name of the other choice>" and more recently your "should I use x11 gtk+ or should I use aqua gtk+". I couldn't care less what widgets look like, this is why I can bear mathspad's archaeological look.
13:37:57 <elliott> there's more than two choices now
13:38:02 <elliott> it used to be macports and frink, but frink is pretty objectively bad
13:38:09 <kulakowski> s/frink/fink
13:38:17 <djahandarie> Is it possible to make attoparsec backtrack even if it succeeds on something?
13:38:21 <djahandarie> Like lookAhead in parsec
13:38:27 <elliott> kulakowski: erm yes
13:38:31 <monochrom> to put things into perspective, I use ubuntu linux and its default gnome desktop, and I am not a terminal lover.
13:38:32 <elliott> typo
13:38:51 <dented42_> when I am in my terminal, GHCi has no problem outputting unicode characters, but when I am inside emacs instead of printing the characters it escapes them. Presumably this is because emacs is not properly notifying GHCi that it supports unicode. How can I fix this?
13:41:14 <ddarius> monochrom: Do you use NetworkManager?
13:41:58 <kulakowski> monochrom: How is macports vs homebrew different from kde vs gnome or one linux package distro format vs another?
13:41:59 <roderyk> monochrom: to put things into perspective, I am a terminal lover.. just prefer the terminal to look nice. :) Anywho, I'm new to the mac thing which is why I was asking around; precisely because my googling has turned up a plethora of incompatible and mutually-exclusive choices as you mentioned.
13:41:59 <monochrom> Yes too.
13:42:03 <systemfault> Ubuntu will soon be fragmenting the linux desktop market even more...
13:42:16 <saml> i found the bug for @google
13:42:17 * ddarius is amazed monochrom is on the internet.
13:42:23 <ddarius> He probably uses a hard line.
13:42:25 <roderyk> I am trying to stick with Homebrew as much as possible; hopefully it will give me enough runway so I can avoid macports, fink, etc
13:42:27 <saml> you google for falling stock, and it's crazy
13:42:37 <saml> @google NASDAQ:acls
13:42:38 <lambdabot> [];google.dlj=function(b){window.setTimeout(function(){var a=document.createElement("script");a.src=b;document.getElementById("xjsd").appendChild(a)},0)};
13:42:39 <lambdabot> if(google.y)google.y.first=[];if(!google.xjs){google.dstr=[];google.rein=[];if(google.timers&&google.timers.load.t){google.timers.load.t.xjsls=new Date().getTime();}google.dlj('/extern_js/f/CgJlbhICdX
13:42:39 <lambdabot> MgACswRTgALCswWjgALCswDjgALCswFzgALCswJzgALCswPDgALCswUTgALCswCjgAQC8sKzAWOAAsKzAlOM-IASwrMEA4ACwrMEE4ACwrME04ACwrME44ACwrMFQ4ACwrMGk4ACwrMBg4ACwrMCY4ACyAAiiQAi4/punwlAOKLZY.js');google.xjs=1}google.
13:42:39 <lambdabot> drhs=1;var oldElement=document.getElementById('tbt3');if(oldElement){oldElement.parentNode.removeChild(oldElement);}delete google.ww;google.mc = [];google.mc = google.mc.concat([[14,{}],[81,{}],[78,{
13:42:39 <lambdabot> }],[64,{}],[105,{}],[22,{"m_error":"\u003Cfont color=red\u003EError:\u003C/font\u003E The server could not complete your request.  Try again in 30 seconds.","m_tip":"Click for more information"}],[
13:42:40 <lambdabot> [16 @more lines]
13:42:42 <lambdabot> http://www.google.com/finance?q=NASDAQ:ACLS
13:42:44 <lambdabot> Title: Axcelis Technologies, Inc.: NASDAQ:ACLS quotes & news - Google Finance
13:42:51 <saml> can i be official haskell QA?
13:43:06 <copumpkin> o.O
13:43:56 <ddarius> There's an easy fix for that.  Just remove the expression support (or make it smarter.)
13:43:59 <ddarius> @google 1+1
13:43:59 <lambdabot> 2
13:44:21 <monochrom> ddarius: what hard line? my laptop goes through wifi to my wifi router (and from there adsl, which is a hard line I suppose)
13:45:02 * ddarius can never manage to get NetworkManager to work consistently or reliably.
13:46:47 <Eduard_Munteanu> I dislike the way wifi and 3G stuff through NetworkManager kinda sidesteps distro scripts.
13:47:15 <ddarius> Ignoring you is one of the design goals of NetworkManager.
13:48:14 <sipa> i hate that program
13:48:39 <Eduard_Munteanu> Unfortunately it was the only way I could get my 3G stick working.
13:48:45 <sipa> i want a text config file like wpa supplicant
13:49:00 <sipa> and maybe a gui for editing that
13:49:25 <sipa> not something that tries to do everything behind your back
13:49:38 <horms> not at all haskell related, but I have had good luck in getting USB HSDPA modems working using /etc/ppp
13:50:26 <Eduard_Munteanu> Well I suppose I could look at modemmanager scripts from NM and hack something up for /etc/ppp
13:51:33 <roderyk> I seemed to cabal install gtk2hs-buildtools and gtk without any fatal errors; but compiling a gtk helloworld dies terribly:
13:51:56 <roderyk> Undefined symbols:
13:51:58 <roderyk>   "___stginit_gtkzm0zi12zi0_GraphicsziUIziGtk_", referenced from:
13:51:59 <roderyk>       ___stginit_Main_ in foo.o
13:52:10 <monochrom> ghc --make yourprogram.hs
13:54:28 <roderyk> monochrom: thanks; got it linking but it just sits there: "Linking foo..."
13:54:46 <hpc> there's also ghc yourprogram.hs -o yourprogram(.exe)
13:54:51 <hpc> (if on windows...)
13:54:56 <monochrom> kulakowski: gnome vs kde doesn't pose me a dilemma: I can randomly choose one and it fulfills all my needs. the way I faintly understand macports vs homebrew, they pose a dilemma because each misses something, especially when it comes to ghc. But I only gather this impression from #haskell and haskell-cafe horror stories. if there is really no such problems, I'm glad to know.
13:55:27 <monochrom> linking takes a long time and a lot of memory, unless you try the experimental "gold linker".
13:56:07 <kulakowski> monochrom: That's fair. I suppose I don't think of it much, as I essentially manage ghc/haskell platform/cabal separately. Mostly because of cabal.
13:56:21 <dafis> roderyk: linking gtk2hs programmes may take some time, does top report activity of ld?
13:56:34 <hpc> linking can be made shorter through intermediate out files, i think
13:56:57 <hpc> so ghc foo.hs bar.hs -o dll1.out
13:57:25 * hpc hasn't benchmarked, but has observed a trend with his own programs
13:58:30 <roderyk> yea, ld is maxing out the cpu. Is it static linking the entire ghc environment into the binary? (this is just a 3 line helloworld from the wiki)
13:58:36 <monochrom> yes!
13:59:25 <hpc> o.O how does hello world lock up on compilation?
13:59:37 <monochrom> not compilation. linking.
13:59:42 <monochrom> linkalation :)
13:59:48 <hpc> :D
13:59:57 <hpc> @quote add monochrom linkalation
13:59:57 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
14:00:06 <hpc> :(
14:00:14 <hpc> @remember monochrom linkalation
14:00:14 <lambdabot> Good to know.
14:00:27 <Apocalisp> > hello #realWorld
14:00:28 <lambdabot>   Not in scope: `hello'Not in scope: `realWorld'Not in scope: `#'
14:00:36 <horms> Eduard_Munteanu: http://pastebin.com/5vSP0inV http://pastebin.com/ffFUQdQx
14:00:37 <Kaidelong> @ty let boolean x y b = if b then x else y in (flip .) . (curry .) . (flip . uncurry) $ boolean
14:00:38 <lambdabot> forall a. Bool -> a -> a -> a
14:01:26 <roderyk> yep, linkalation died... looks like an issue with i386. I suspect some of my libs are x64; will look into this later. *sigh*
14:01:32 <Kaidelong> @ty let (?) cond x y = if cond then x else y in (flip .) . flip $ (?)
14:01:32 <lambdabot> forall b. b -> b -> Bool -> b
14:01:34 <roderyk> thanks for the help and see you later! :)
14:02:08 * Kaidelong thinks (?) is nicer to defined than if'/boolean
14:02:21 <gwern> linking is a real bitch when you're trying to get gitit with highlighting-kate
14:02:22 <Eduard_Munteanu> horms: ah thanks.
14:02:24 <gwern> 3 gigs is not enough
14:02:28 <monochrom> decades later, when I die, the legacy I leave will be coining the term "linkalation" and it will be a popular term by then
14:02:29 <Eduard_Munteanu> It does look complicated though.,
14:02:29 <augur> copumpkin: smt?
14:02:51 <Eduard_Munteanu> Maybe this should be an independent library that worked with PPP out of the box.
14:02:59 <horms> Eduard_Munteanu: those scripts were working for me as recently as last week. but yes, it is a bit of a pain.
14:03:24 <Eduard_Munteanu> There might be differences depending on the modem.
14:03:34 <Eduard_Munteanu> But I'll remember that.
14:03:34 <horms> actually, I think most of the chat script is unnecessary, but I don't have a working SIM to test with today
14:03:51 <copumpkin> augur: satisfiability modulo theories. like SAT on steroids
14:05:32 <augur> copumpkin: more info plox
14:06:33 <copumpkin> augur: hmm, well you can layer satisfiability on top of integers, or reals, or abstract functions, or arrays (basically abstract functions)
14:06:51 <monochrom> combine SAT solver with other decision procedures
14:06:58 <copumpkin> and ask the solver whether it's satisfiable and for a model if it is
14:07:16 <copumpkin> and I'm trying to find one with a theory of finite sets
14:07:29 <copumpkin> http://www.cprover.org/SMT-LIB-LSM/ talks about adapting the language to talk about them
14:07:32 <augur> copumpkin: ok, so its sat with non-boolean values
14:07:33 <augur> ?
14:07:36 <monochrom> yeah, the other decision procedures also say "unsatisfiable" or "satisfiable, here is an example"
14:07:40 <copumpkin> yeah
14:08:28 <augur> brb
14:08:43 * hackagebot SHA2 0.2.3 - Fast, incremental SHA hashing for bytestrings  http://hackage.haskell.org/package/SHA2-0.2.3 (SveinOveAas)
14:09:29 <monochrom> smt used to mean "surface mount technology", the way chips are soldered onto circuit boards today in mass production.
14:18:02 <datakid> I was looking for some cabal help - is this the right place?
14:18:24 <tg_> datakid: here or #cabal
14:18:26 <edwardk> most likely
14:20:47 <frederik> i'm new to haskell, and i have a question: in the type definition of a function how do i write that a function takes a list as a parameter, but the elements of the list must all be a part of Num?
14:21:02 <hpc> frederik: Num a => [a]
14:21:29 <hpc> frederik: for more detail, some other functions
14:21:31 <hpc> :t head
14:21:32 <lambdabot> forall a. [a] -> a
14:21:33 <hpc> :t tail
14:21:34 <lambdabot> forall a. [a] -> [a]
14:21:35 <Saizan> there's a #cabal?
14:21:42 <hpc> :t map
14:21:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:21:44 <lispy1> Saizan: yeah
14:21:45 <hpc> er
14:21:49 <hpc> :t map (+1)
14:21:50 <lispy1> Saizan: and a #hackage
14:21:50 <lambdabot> forall a. (Num a) => [a] -> [a]
14:21:53 <frederik> thanks :)
14:22:06 <Saizan> lispy1: i only knew of the latter
14:22:41 <lispy1> Saizan: I don't really know what value #cabal provides, but it does exist.  I usually pester dcoutts directly :)
14:22:51 <lispy1> (a habit I should probably break)
14:24:05 <copumpkin> #cabal isn't the haskell one
14:24:11 <copumpkin> as far as I can see
14:24:22 <copumpkin> maybe it is?
14:24:24 <copumpkin> I dunno
14:24:28 <copumpkin> the topic seems unrelated
14:24:53 <Twey> frederik: (note: that's not *quite* what you asked: the signature hpc gave you indicates that the elements of the list are all of a particular type ‘a’ that is part of Num)
14:25:46 <Twey> frederik: (that's usually how we do things in Haskell, and the alternative is complicated and you don't need to know about it yet, but be aware that it doesn't allow you to put elements of different types in there)
14:26:23 <frederik> so in the list, i can't have both doubles, integers and float, but only 1 type?
14:26:52 <lispy1> copumpkin: oh.  I never even realized that #cabal was for something besides the haskell cabal.  I just answered someone's question there about upgrading pandoc and gitit :)
14:27:08 * ddarius needs to shovel his car out but has no place to put the snow.
14:27:22 <dafis> ddarius: in the car?
14:27:30 <ddarius> dafis: Too much snow.
14:27:55 <dafis> ddarius: wait until it melts
14:28:04 <ddarius> dafis: That will be in like a month.
14:28:27 <baguasquirrel> lol!
14:29:05 <dafis> ddarius: seriously, is it too much to spread on the road?
14:29:27 <monochrom> it is too much to spread on the road. and the road already has just as much snow
14:29:35 <ddarius> It's illegal to shovel into the road.
14:30:11 <monochrom> this snow storm is so bad that even illegal things are impractical
14:30:24 <lispy1> The amount of snow on the east coast is crazy.  I heard spring break will get canceled due to snow
14:30:25 <dafis> oh
14:31:26 <gwern> man. we're luck on LI - it's basically cold rain
14:31:49 <lispy1> It's 45 F here and sunny.
14:32:08 * ddarius is sure it's above 65F in Hawaii.
14:34:06 * ddarius needs like a laundry cart.
14:35:43 <lispy1> So yeah, #cabal is not about the Haskell cabal.
14:35:49 <lispy1> Oops :)
14:36:10 <monochrom> heh interesting
14:36:29 <dafis> lispy1: did you find out what it's about or was that all Garthe said?
14:36:41 <dafis> Gareth*
14:37:29 <gwern> dafis: it's about nothing. There Is No Cabal
14:37:55 <dafis> gwern: ghc-pkg says otherwise
14:38:11 <gwern> ghc-pkg is part of the cabal, so of course it would lie to you
14:38:26 * dafis ponders
14:39:45 <monochrom> that is a twisted lie
14:40:32 <lispy1> dafis: I left too when you did
14:42:42 <dafis> seems there's some online game called Cabal: http://forum.cabalonline.com/showthread.php?t=56238
14:51:58 <gwern> there is no cabal!
14:53:08 <dixie> @type map . map . map . map . map . map . map . map
14:53:09 <lambdabot> forall a b. (a -> b) -> [[[[[[[[a]]]]]]]] -> [[[[[[[[b]]]]]]]]
14:54:56 <dafis> gwern: look in ~/.cabal/bin
14:55:01 <djahandarie> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
14:55:02 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f1, Functor f, Functor f2) => f1 (a -> b) -> f1 (f (f2 a) -> f (f2 b))
14:55:27 <mercury^> That does not look right.
14:55:49 <Philonous> Is there an ETA of the 2011 platform?
14:56:01 <dafis> Philonous: 11th
14:56:07 <dafis> or thereabouts
14:56:19 <Philonous> dafis:  Ok, thanks
14:56:29 <dafis> de nada
14:56:31 <jonkri> what logging frameworks for haskell that are NOT gpl/lgpl are there? :P seems that both system.log.logger and hslogger are lgpl
14:56:43 <gwern> djahandarie: that is a surprisingly short type signature
14:56:44 <jonkri> can you recommend something?
14:57:50 <mm_freak> jonkri: what about hsyslog?
14:57:53 <mm_freak> it's BSD
14:58:01 <djahandarie> gwern, they tend to do that after awhile iirc
14:58:15 <djahandarie> I remember someone posted about the pattern on -cafe though I don't really remember any details
14:58:50 <jonkri> mm_freak: i need something that doesn't require posix
14:59:28 <jonkri> basically, i want to have a queue of log items and be able to filter it simply based on priorities and also be able to pipe it to syslog or whatever
14:59:49 <jonkri> are people not logging their haskell applications? :P
14:59:57 * gwern doesn't
15:00:32 <Philippa> jonkri: the usual answer is to start with a Writer and work from there
15:00:47 <Philippa> it has the advantage that most of the interesting stuff can be controlled by the caller
15:01:45 <mm_freak> jonkri: i do, but usually i write my loggers myself
15:01:53 <Philippa> (and for bonus points, with the obvious log type your filter is... filter)
15:02:42 <mm_freak> i never liked Writer for logging…  it's too unpredictable
15:03:06 <Philippa> how so?
15:03:33 <dobblego> @type mapAccumL_
15:03:34 <lambdabot> Not in scope: `mapAccumL_'
15:03:51 <mm_freak> Philippa: that's my experience with WriterT
15:04:13 <Philippa> mmm, did you work out in what ways it was unpredictable? Where was WriterT on the transformer stack?
15:04:32 <Philippa> (WriterT at the top of the stack with anything but state-like stuff below it's going to do weird stuff, sure)
15:05:27 <edwardk> neat. mealy machines have a monad
15:07:25 <copumpkin> what does it do?
15:07:56 <jonkri> what other than writers can you use in a monad (stack)?
15:08:29 <edwardk> its a diagonalization monad like stream
15:08:49 <edwardk> so you get the nth message returned by the nth monad
15:09:12 <edwardk> so its a pretty slow monad, but its a valid one ;)
15:09:33 <jonkri> edwardk: WriterT?
15:09:53 <edwardk> jonkri: Mealy
15:10:05 <Philippa> jonkri: anything you try to do for logging is going to be close enough to Writer(T) as makes little difference, I suspect. You can use State if you want to have slightly more control, I guess
15:11:10 <edwardk> jonkri: state gives you a little more control like philippa says, but that comes at a cost, namely productivity, writer monads can often start producing results that can be interrogated before the computation is done, implementing writer with state effectively removes this 'productivity'
15:11:31 <mm_freak> Philippa: http://hpaste.org/43564/writert_not_suitable_for_loggi
15:11:45 <mm_freak> Philippa: also my loggers are anything but similar to WriterT
15:11:51 <dobblego> @hoogle iterateM
15:11:51 <lambdabot> No results found
15:11:52 <mm_freak> i use a concurrent logging thread
15:12:05 <jonkri> mm_freak: channels?
15:12:10 <edwardk> i don't use writerT for logging critical IO or similar
15:12:11 <mm_freak> jonkri: MVars
15:12:19 <jonkri> mm_freak: doesn't that force you to use io?
15:12:26 <Eduard_Munteanu> edwardk: intriguing, where did you find the Mealy monad?
15:12:28 <mm_freak> jonkri: sure
15:12:31 <aculich> I'm going to guess the answer is 'no', but is there a way to import something from a module that is not exported from said module? I tried looking up various ghc (6.1.21) pragmas like PackageImports, but I don't see anything that will do what I want (which is purely for doing some quick & dirty testing without compiling; i don't actually want to write code this way)?
15:12:46 <edwardk> Eduard_Munteanu: invented it 20 minutes ago?
15:12:48 <mm_freak> jonkri: logging is an IO operation after all =)
15:12:52 <Eduard_Munteanu> Heh.
15:13:01 <Philippa> mm_freak: from the user's POV that's still "shit data out down a stateful channel" though :p
15:13:09 <jonkri> yeah ok, that's true :)
15:13:13 <Eduard_Munteanu> So what do they look like?
15:13:18 <edwardk> Eduard_Munteanu: i have a lively debate going on observables vs. mealy with a coworker, and i sat down to prove mealy didn't exist, and proved the opposite =)
15:13:25 * jonkri starts to realize that logging is different with functional languages
15:13:27 <edwardk> er that mealy's monad didn't
15:13:43 <mm_freak> if anything, i'd use a state monad for logging, but not a WriterT
15:13:43 <edwardk> newtype Mealy a b = Mealy { runMealy :: a -> (b, Mealy a b) }
15:13:46 <Philippa> mm_freak: is that a lazy writer by default? If so yeah, that'd be problematic
15:14:00 <mm_freak> Philippa: yes, it's the lazy version i believe
15:14:02 <Eduard_Munteanu> Hrm, that looks State-y
15:14:03 <Philippa> (I'm assuming the problem is you get "abc" with no delay, then it exits after the delays run?)
15:14:20 <mm_freak> Philippa: just tested with the strict variant, which didn't change anything
15:14:26 <edwardk> eduard: its sort of a fixed point _through_ the state parameter of state ;)
15:14:39 <Philippa> yeah. If you demanded the results of the delays I'd expect that to be different
15:14:41 <mm_freak> Philippa: no, i get "abc" after all delays, just as i expect
15:14:51 <edwardk> instead of s -> (a, s) its s -> (a, s -> (a, ….
15:14:54 <mm_freak> Philippa: you can't use WriterT for logging over IO without unsafeInterleaveIO
15:15:09 <Eduard_Munteanu> I see.
15:15:21 <jonkri> interesting discussion :)
15:15:24 <edwardk> so you receive 'states' as messages.
15:15:25 <Philippa> mm_freak: ah, I thought putStr was lazy enough
15:15:52 <romanandreg_> guys, quick question, does Data.Vector ((!)) execute in O(1) or O(n)?
15:16:16 <mm_freak> Philippa: putStr must not be lazy…  the problem here is that (>>=) runs actions in order…  by the time putStr receives the log, the whole WriterT action has already completed
15:16:18 <Philippa> but yeah, fair enough. I think I have a habit of mentally assuming it's not over IO :-)
15:17:01 <mm_freak> WriterT would work with a nonstrict (>>=), but most of the time, when you want to log, you have IO somewhere on your monad stack
15:17:11 <Philippa> MMV, but sure
15:17:47 <roconnor> mm_freak: can you wrap IO and implement the Writer class to get logging?
15:18:00 <Philippa> if you're working within IO then yeah, sending it down a chan to a logging thread seems like the right thing
15:18:10 <mm_freak> roconnor: that would be WriterT, wouldn't it?
15:18:15 <Philippa> mm_freak: no, it wouldn't
15:18:21 <roconnor> mm_freak: that's what I'd be inclined to try
15:18:38 <Philippa> you can implement it such that it does roughly what you're doing already, for example
15:18:43 <roconnor> mm_freak: er misunderstood you
15:18:46 <Philippa> (except I suspect you can't because of the run-time dependence on a logging chan)
15:18:51 <roconnor> mm_freak: I don't think it would be
15:19:18 <Philippa> roconnor: the chan bit's a shame, otherwise it'd be a nice use of polymorphism when not all your code requires IO
15:19:40 <roconnor> WriterT String IO a is IO (a,String).  But what I'm suggesting is newtype LoggingIO a = LoggingIO (IO a)
15:20:08 <edwardk> roconnor: have you explored what connection there is from moore machines to store comonads?
15:20:10 <roconnor> and instantiate MonadWriter String with hputString stderr
15:20:11 <mm_freak> well, my logger usually looks like this:  withFileLogger :: MonadIO m => FilePath -> (forall s. LoggerT s m a) -> m a
15:20:19 <roconnor> edwardk: what is a moore machine
15:20:34 <edwardk> data Moore a b = Moore b (a -> Moore a b)
15:20:54 <edwardk> it is a state machine with 'labeled states'
15:21:05 <roconnor> edwardk: it is a fixedpoint of store
15:21:22 <mm_freak> roconnor: that makes the logging quite implicit
15:21:24 <edwardk> as opposed to a mealy machine with labeled edges: newtype Mealy a b = Mealy (a -> (b, Mealy a b))
15:21:35 <edwardk> roconnor: sure. just thought i'd bring it to your attention
15:22:02 <edwardk> roconnor: i write up some code on them a couple years back for copumpkin and i think conal wrote about them at some point
15:22:03 <roconnor> edwardk: actually the type is quite diferent from store
15:22:07 <Philippa> edwardk: I have lots of time stuck on trains tomorrow, so might have stuff to tell you about in the evening or on friday
15:22:12 <Philippa> (I should also be going to bed shortly)
15:22:21 <edwardk> roconnor: its more connected to indexed store
15:22:39 <edwardk> philippa: sounds good to me
15:22:51 <conal> http://conal.net/blog/tag/bot/ -- edwardk, roconnor
15:22:51 <lambdabot> conal: You have 3 new messages. '/msg lambdabot @messages' to read them.
15:23:02 <mm_freak> (i'm not a devotee of the "be as pure as possible" religion…  GHC/haskell has such a great RTS, and i make use of it)
15:23:04 <edwardk> conal: yeah thats the one =)
15:23:20 <edwardk> conal: that is probably spam from me re MemoTrie ;)
15:23:30 <conal> yep.
15:23:44 <conal> edwardk: did you get my email reply?
15:24:05 <jonkri> mm_freak: what does "s" mean in your withFileLogger?
15:24:07 <Philippa> mm_freak: I'm far from that or I wouldn't be recommending Writer in the first place :-) But I am in favour of knowing which bits are intrinsically IO-bound and which are only coincidentally because I chose to use IO in the surrounding context
15:24:42 <edwardk> conal: yeah. sadly i think functor-combo is a bit big of a dependency for me to drag in for this purpose, which is one reason why i liked MemoTrie, it was simple.
15:24:52 <mm_freak> jonkri: it guarantees that you can't log without a logger…  look at runST from Control.Monad.ST
15:25:21 <jonkri> so writers are no good for logging. when is a state monad implementation preferable to another thread then?
15:25:30 <conal> edwardk: ah, yeah. maybe time for me to break up functor-combo.
15:26:02 <edwardk> it would kind of tie the top of my package tree to the top of your package tree. thats a lot of packages =)
15:26:14 <mm_freak> jonkri: state monads are pure loggers
15:26:52 <mm_freak> jonkri: in other words, you have the same "problem" as with WriterT
15:27:04 <edwardk> conal: anyways regarding the different asymptotics. consider that if i'm looking over at a memo tree i need to walk down into it to find my answer. because my focus is at the root.
15:27:14 <jonkri> ah
15:27:49 <mm_freak> jonkri: the writer monad is just a state monad, but without an initial state
15:28:01 <mm_freak> writer:  (a, s)
15:28:05 <mm_freak> state:  s -> (a, s)
15:28:16 <pumpkin> reader: s -> 
15:28:31 <jonkri> interesting
15:28:46 <edwardk> and i need to pay that (worst case) for every node in the tree, so the cost of producing the new tree is at best bounded above by the length of paths in the source tree * the number of nodes in the target tree.
15:29:11 <shachaf> mm_freak: Well, with the initial state being mempty, and with the only operation being modify (mappend ...).
15:29:39 <shachaf> So not really that much like the state monad in general. :-)
15:30:01 <pumpkin> shachaf: you don't get the intial state at _each_ action
15:30:05 <mm_freak> shachaf: it's a state monad without access to the current state =)
15:30:37 <shachaf> mm_freak: There's also no "put", only a very particular modify operation.
15:30:37 <conal> edwardk: would you mind putting your thoughts in an email? i'm focusing on something else right now, and i'd really like to get what you've realized.
15:30:41 <edwardk> so i go from something like n log n to n (log n)^2
15:30:46 <edwardk> sure
15:30:53 <mm_freak> anyway, i think i can write a writer monad, which is predictable
15:30:56 <mm_freak> let me try something
15:31:16 <pumpkin> mm_freak: predictable?
15:31:18 <jonkri> mm_freak: what problem would that solve? (i'm still not getting what the problem is with using states)
15:31:37 <edwardk> i alo realized i should be able to tweak the applicative and monad instances the same way but this makes my case worse because there is more boilerplate to use it
15:31:47 <edwardk> i'll email when i have something more coherent
15:32:14 <edwardk> er not the monad, just the applicative, my mistake
15:32:55 <mm_freak> pumpkin: WriterT is not suitable as a logger
15:33:00 <mm_freak> most of the time at least
15:33:10 <pumpkin> mm_freak: why not?
15:33:20 <mm_freak> pumpkin: http://hpaste.org/43564/writert_not_suitable_for_loggi
15:33:47 <mm_freak> jonkri: see the paste and perhaps try out the code
15:33:48 <Philippa> pumpkin: mm_freak's "most of the time" is really "when IO is involved"
15:33:49 <pumpkin> mm_freak: why are you using Strings?
15:34:04 <mm_freak> pumpkin: what would you use?
15:34:14 <pumpkin> something with a reasonable monoid instance :P
15:34:17 <pumpkin> but I guess that isn't the issue here
15:34:19 <Philippa> [String] would make a good starting point
15:34:26 <Philippa> (so you can tell messages apart)
15:34:27 <mm_freak> pumpkin: yes =)
15:35:04 <rribeiro> @src transpose
15:35:04 <lambdabot> transpose []             = []
15:35:04 <lambdabot> transpose ([]   : xss)   = transpose xss
15:35:04 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
15:35:07 <Philippa> pumpkin: IO strictifies
15:35:10 <pumpkin> yeah
15:35:10 <Philippa> that's the problem
15:35:25 <Philippa> Writer(T) as log only works well in lazy monads or if you don't care when you get the log
15:35:40 <jmcarthur> for Writer, DList is reasonable, as is Data.Sequence
15:35:47 <jmcarthur> or just use a list and reverse it at the end
15:36:04 <jmcarthur> well, you *may* be able to do that
15:37:01 <pumpkin> not really
15:37:07 <jmcarthur> not in this case, for sure
15:37:28 <jmcarthur> dlist is probably most reasonable here
15:37:28 <kulakowski> So I've been wanting to poke around at ghc 7. I'm on a mac. And I see there are two binary packages with identical descriptions. What, if any, is the difference?
15:37:29 <Philippa> mm_freak: when you're talking about this, could you please use the more accurate qualifier re IO? Some people do have pure logging concerns
15:37:43 <jmcarthur> actually... is it?
15:37:48 <jonkri> a slightly off-topic question: when you use the code at for example http://hpaste.org/43564/writert_not_suitable_for_loggi , does your ide have some kind of feature for automatically adding the appropriate imports?
15:37:50 <pumpkin> mm_freak, Philippa: so you want some form of unsafeInterleaveIO'd WriterT
15:37:55 <jonkri> i use haskell-mode
15:37:58 <jmcarthur> yeah i looked at the code after all i said and realized IO was involved :P
15:38:16 <Philippa> pumpkin: *I* don't want shit right now :-) But if we're IO-bound anyway, may as well spit it out down a Chan
15:38:29 <pumpkin> :P
15:38:33 <jonkri> (in eclipse and java i could just right click on the class and it would have searched the classpath for all classes with that name)
15:39:04 <Philippa> (in my use case, the code being logged isn't doing any IO in and of itself - forking a thread to demand-and-write the log would work fine)
15:43:46 <mm_freak> pumpkin: i thought, maybe i can exploit CPS to get interleaved logging without unsafeInterleaveIO
15:44:35 <mm_freak> jonkri: no, you'll have to figure that out by yourself, but hoogle and hayoo can help you
15:44:45 <mm_freak> (what a rhyme)
15:46:14 <jmcarthur> mm_freak: will you always have IO at the bottom of the stack? if so, you could just use it
15:46:29 <mm_freak> jmcarthur: yes, that's my current approach
15:46:32 <jmcarthur> mm_freak: if not then maybe you could use MonadPrompt or something
15:46:44 <mm_freak> mostly with a concurrent logger, since most of my apps, which require logging, are concurrent anyway
15:46:48 <jmcarthur> ah
15:47:05 <mm_freak> if not, i usually use a state monad to pass around a logging function
16:03:34 <ikeg> community.haskell.org seems out of services now. someone knows when it's up?
16:11:56 <lispy1> ikeg: Not for a while
16:12:31 <lispy1> ikeg: The machine was brought after it was compromised.  People are working towards repairing it and verifying that it has been cleaned up
16:12:38 <lispy1> "brought down"
16:17:58 <diffy_> hi
16:18:02 <jonkri> <mm_freak> if not, i usually use a state monad to pass around a logging function <-- could this result in the "abc" problem you mentioned above?
16:18:33 <ikeg> lispy1: thanks :)
16:19:31 <ikeg> i want to refer that nobody in Grasgow has an account at community.haskell.org (while looking Google maps)
16:19:53 <ikeg> Glasgow
16:19:59 <O1athe> Grasskow
16:20:25 <lispy1> ikeg: sorry, what is your question?
16:21:49 <ikeg> no question but why could not I see people in Glasgow at the portal community.haskell.org by Google maps
16:22:10 <ikeg> you know, the top page, there is the world map when haskellers live in
16:22:13 <ikeg> where
16:22:43 <lispy1> ikeg: when I browse to community.haskell.org I just see the text: It works!
16:22:50 <lispy1> ikeg: so I'm not sure what you're referring to
16:24:08 <ikeg> yep, few month ago, the page was worth seeing
16:27:27 <ikeg> it is not annoying, just a topic
16:41:30 <jonkri> mm_freak: ah, i get you... only concurrency causes problems with this approach
16:42:26 <jonkri> anyway, it would be great to have a state monad with a logging functions whether the application is concurrent or not
16:52:41 <lewis1711> with haskells type inference, when it checks for an integer type, does it have *one* kind of int (4 bytes maybe?), or does does it assign separate size ints depending on the code?
16:53:46 <sproingie> it infers the widest type available which is often Num
16:54:06 <sproingie> if it's Integer than it's just the Integer type, no machine words involved
16:54:23 <sproingie> what the compiler produces as an optimization is a different story that i dont know
16:55:07 <lewis1711> I see. I suppose in a language like haskell the gulf between machine types and program types is quite wide
16:55:20 <O1athe> Int is the machine-size integer (usually 4 or 8 bytes), but there's also the arbitrarily large Integer (which is the default, I think), Int8, Int16, Int32, Int64, and all the Words.
16:55:38 <hpc> Word being unsigned Int iirc
16:57:16 <lewis1711> which is what the type inference infers?
16:57:19 <lewis1711> clever
16:59:30 <Cale> The machine itself doesn't have much notion of a type of course.
16:59:31 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
17:02:05 <Cale> An Int is usually expected to be (something which evaluates to) a machine word (32 or 64 bits depending on architecture -- it's formally required to be at least 30 bits)
17:02:33 * hackagebot data-category 0.3.1 - Restricted categories  http://hackage.haskell.org/package/data-category-0.3.1 (SjoerdVisscher)
17:03:40 <Cale> There's also the matter of boxing to think about. All ordinary Haskell values are boxed (GHC supports unboxed types, but you're not likely to bump into those too often), which in GHC's implementation means that they're pointers to code which when executed will push the actual value on the stack.
17:04:01 <Cale> This is how lazy evaluation and parametric polymorphism are implemented.
17:04:42 <mm_freak> jonkri: i use a state monad in any case, but not to hold the actual log data, but just a logging function
17:05:03 <mm_freak> that logging function is either just some variant of putStrLn or it talks to a concurrent logger thread
17:05:05 <lewis1711> that must leave a lot til run time
17:05:31 <Cale> Since the code might either immediately return an already evaluated value, or do a bunch of work (the first time) to evaluate the value, you can have the value only be computed when its value is demanded. Since code pointers are all the same size, parametric polymorphism can ignore the problem of how to deal with values of different sizes.
17:06:33 <Cale> (You don't have to compile a whole bunch of different versions of the length function at every conceivable type, for example)
17:06:35 <jonkri> i see. thanks :)
17:06:54 <xplat> lewis1711: it kind of does, which is why inlining and certain other optimizations are very important in haskell implementation
17:07:56 <mm_freak> jonkri: as one hint on how to do that:  data AppConfig = AppConfig { logStr :: String -> IO (), config1 :: Int, config2 :: Float, … }
17:08:15 <mm_freak> type AppT = StateT AppConfig
17:08:36 <mm_freak> runAppT :: MonadIO m => AppT m a -> m a
17:08:39 <mm_freak> etc.
17:08:54 <xplat> not really more so than for a lot of other languages, though, like common lisp or java
17:08:55 <Cale> lewis1711: Well, what I'm describing is the basic implementation of this stuff before optimisations.
17:09:10 <mm_freak> at least that's the simple variant
17:11:23 <jonkri> mm_freak: nice, will try that tomorrow :) will you be looking at a way to get an unsafeInterleaveIO'd writer?
17:12:01 <lewis1711> xplat: well CL Is dynamically typed, but I'm not sure how much modern java does at run time.
17:12:13 <lewis1711> then of course it also compares on the CL implementation...but that's getting a bit beside the point:)
17:12:33 <Jesin> hmm
17:12:34 <lambdabot> Jesin: You have 1 new message. '/msg lambdabot @messages' to read it.
17:14:13 <xplat> lewis1711: the commonality is that the default way to compile all these things leaves a lot to runtime but they all have compilers available that do extra work to get your code closer to the metal without messing up the semantics
17:17:51 <jonkri> got to go, good night all
17:18:01 <davekong> Is there some way to make GHC compile in parallel on multicore systems? (e.g. ghc --make -j2 myapp.hs)?
17:18:30 <Bynbo7> no
17:18:35 <Bynbo7> not yet anyway
17:18:42 <Page15> If you have say 'type theTypeList = A | B' how to do I go about making a function that then tells that A will be an integer in this function?
17:19:02 <Bynbo7> you can'tdo that
17:19:03 <Jesin> umm
17:19:08 <Jesin> "type" doesn't do that
17:19:10 <Eduard_Munteanu> If you use Makefiles then yes.
17:19:11 <Bynbo7> data TheTypeList would work
17:19:20 <Jesin> but then A is a constant value
17:19:27 <Jesin> it can't be an Integer
17:19:34 <Bynbo7> Page15: i think you're very confused :\
17:19:40 <Page15> Ah  sorry yes I did mean 'data theTypeList = A | B'
17:19:45 <Jesin> well
17:19:47 <kmc> then A and B are both values of type TheTypeList
17:19:52 <kmc> [it has to start with an uppercase letter]
17:19:52 <Jesin> ^ that
17:20:05 <Page15> *TheTypeList
17:20:10 <kmc> and so, why would you expect one to be an Int?
17:20:17 <Jesin> TheTypeList isn't actually a list of types, by the way
17:20:17 <Eduard_Munteanu> Page15: either of those variants can't hold an integer.
17:20:32 <Jesin> it's a type, A and B are data constructors with no arguments
17:20:34 <xplat> it seems like this is one of these questions that just can't be answered at face value.
17:20:44 <Page15> I see
17:20:53 <Jesin> (True and False are also data constructors with no arguments)
17:21:05 <Page15> But 'data TheTypeList = A Int | B String' would be fine?
17:21:14 <Eduard_Munteanu> Yes.
17:21:15 <Jesin> yes, it would
17:21:35 <O1athe> Page15: You can have data TheTypeList = A Int | B Integer or something.
17:21:36 <Jesin> in that case, you would just do something like
17:21:44 <xplat> it's valid syntax, but it's still hard to tell if it does what you want.  it's definitely closer.
17:21:47 <Jesin> f (A a) = defnition
17:22:12 <Jesin> and it would pattern-match on the constructor
17:22:42 <xplat> in f (A a) = definition, 'a' is of type Int
17:23:09 <xplat> and A is of type (Int -> TheTypeList), not just there but everywhere
17:23:18 <Page15> Let me try something and ill be back in 5 mins :)
17:23:29 <Page15> Ah ok
17:29:41 <mm_freak> @tell jonkri no, i won't consider an unsafeInterleaveIO-ed WriterT, because that's, as its name states, unsafe ;)  it will run into the same problems as lazy IO in general, which also includes unpredictability
17:29:41 <lambdabot> Consider it noted.
17:30:10 <xplat> i've decided it's safe to stop hating parser combinators.
17:30:44 <xplat> instead of comparing them to parser generators, i'm going to compare them to handrolled parsers, in which case they look good instead of bad
17:31:12 <xplat> straightforward to translate, 1/10 the code size, what's not to like?
17:33:53 <gwern> huh. my new shell script worked the first time. what an unexpected and pleasant surprise
17:34:44 <monochrom> write a blog "I don't need type system to help get my shell script work the first time"
17:35:24 <gwern> haha. fortunately, the troll disappeared in me a long time ago
17:36:28 <monochrom> or even better, hunt down every blog that says "haskell help me write programs that work the first time" and add comment "my shell scripts work the first time too"
17:36:58 <gwern> 'if your scripts don
17:37:06 <gwern> 't work the first time, it's because you're a bad coder'
17:39:01 <kmc> i wrote hello world in C and it worked the first time
17:39:04 <kmc> C is the best language ever
17:39:19 <monochrom> but here is what really happened. a long time ago, you were an undisciplined programmer, you emit code randomly, nothing worked the first time or even the tenth time.
17:40:09 <monochrom> then a type system disciplined you by telling you how wrong you are early. alternatively a comprehensive anal test suite would do, too.
17:41:14 <monochrom> after much punishment, you become a disciplined programmer, you don't emit code randomly, when you emit code you already have its proof of correctness in your head.
17:41:59 <monochrom> then you are released into an unchecked environment like shell scripting again, but now you only know how to write correct code, it has to work the first time.
17:42:45 <xplat> unless you typo!
17:43:07 <xplat> typos can do very strange things in shell code ...
17:44:20 <xplat> people say that it's okay for a shell to be untyped because most of the stuff you are doing in it is short
17:44:44 <xplat> i on the other hand think shell code should be typed because you REALLY want it to work the first time
17:45:18 <monochrom> those who say "it is short" are short. sighted.
17:46:16 <dobblego> I am trying to alleviate this short-sightedness around 'ere
17:46:32 <aavogt> how?
17:46:43 <dobblego> lots and lots of teaching
17:46:48 <dobblego> in particular, the value of types
17:47:02 <dobblego> and also demonstration
17:48:31 <dobblego> I have an exercise where I ask to write an API for tic-tac-toe, such that it is impossible (type-error) for me to make a move on a completed game, and to ask whoWon on a game still in-play
17:49:11 <monochrom> if a language gains traction, people will write longer and longer programs in it. there is no hope of "people will only write short ones", unless you simultaneously hope "this language will die soon". clearly, no one hoped shell scripting would die soon.
17:52:14 <gwern> man, I should've written this script ages
17:52:19 <gwern> I've wasted so much time
17:54:23 <monochrom> the_only_way_to_win_is_not_to_play :: Game_state -> Optimal_end_of_game
17:54:50 <hpc> :t howAboutANiceGameOfChess
17:54:51 <lambdabot> Not in scope: `howAboutANiceGameOfChess'
17:55:46 <monochrom> "Only marketers think it's cool to put capital letters in the middle of words"  http://uncyclopedia.wikia.com/wiki/ZomboCom
17:56:14 <monochrom> that is now my official reason for refusing camel_case
17:56:25 <drhodes> Is there a fancy Applicative function that does this:
17:56:26 <drhodes> \f xs -> [f x1 x2 | (x1, x2) <- zip xs (drop 1 xs)]
17:56:41 <hpc> :t \f xs -> [f x1 x2 | (x1, x2) <- zip xs (drop 1 xs)]
17:56:42 <lambdabot> forall a t. (a -> a -> t) -> [a] -> [t]
17:56:58 <hpc> @hoogle (a -> a -> t) -> [a] -> [t]
17:56:58 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
17:56:58 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
17:56:58 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
17:57:12 <dobblego> :t zip <*> drop 1
17:57:12 <lambdabot> forall b. [b] -> [(b, b)]
17:57:40 <rothwell> http://imagebin.org/135903
17:57:47 <drhodes> that looks like it, thanks guys.
18:05:34 <joe6> hello, I am using TemplateHaskell to generate a function and the first 7 of its' parameters. I just want to create the parameters without the function call in TH. Is that possible?
18:05:38 <joe6> http://hpaste.org/43566/joe
18:05:58 <joe6> yesterday, I think edwardk suggested that I check out *P functions
18:06:14 <joe6> but, I did not have much luck with them. Wondering if anyone has any suggestions?
18:07:09 <revenantphx> Cell *(^World_locationOfAnt)(int ant) = ^(int antID){
18:07:09 <revenantphx>         return &(this->cells[ants[antID].location]);
18:07:09 <revenantphx>     };
18:07:10 <revenantphx> derp.
18:07:19 <joe6> mainly, because I was not able to figure how to test such functions (*P).
18:07:51 * monochrom wonders what is ^ there
18:07:52 <Axman6> you can do most of your testing in ghci no?
18:08:05 <Axman6> monochrom: block syntax
18:08:15 <Axman6> Apple's closures in C
18:08:28 <Axman6> i believe anyway
18:12:31 <revenantphx> Yeah, it's apples closures.
18:12:37 <revenantphx> I find new uses for them every day.
18:12:41 <revenantphx> Such as building objects :3
18:13:03 <revenantphx> (having them close around a pointer to the struct when it is initialized so they have an implicit "this")
18:13:05 <revenantphx> (fun stuff)
18:13:22 <revenantphx> They're supported in clang too, I hope they'll become more wide spread.
18:13:37 <revenantphx> lets you write code like
18:13:38 <revenantphx> printf("location: %d\n", world->locationOfAnt(0)->index);
18:13:46 <revenantphx> (with a little bit of work ;) )
18:15:52 <revenantphx> What's the algorithm for a weighted choice between two items?
18:15:54 <revenantphx> (simplest one)
18:16:11 <revenantphx> I'm not confident in mine as I was getting thoroughly biased results.
18:16:34 <monochrom> what is weighted choice?
18:16:45 <aavogt> @hoogle choice
18:16:45 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
18:16:45 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
18:16:45 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
18:16:51 <revenantphx> Not in haskell...
18:16:55 <revenantphx> Eh, like
18:17:05 <revenantphx> "cell to the left of me has 3.49 pheromone, cell to the right had 9.58"
18:17:06 <gwern> revenantphx: create a repeated list and then pick a random index?
18:17:16 <monochrom> "randomly pick True with probability p, False with probability 1-p"?
18:17:19 <revenantphx> so the chance of me going either way is 3.49/(3.49+9.58)
18:17:37 <revenantphx> I was just picking a random number under the sum of the two.
18:17:52 <revenantphx> And if it falls under the first number, then it goes that way
18:17:55 <revenantphx> if it doesnt it goes the other.
18:18:10 <monochrom> x<-get random number between 0,1; if x<p then return True else return False
18:18:27 <aavogt> redundancy :)
18:18:30 <revenantphx> But I keep seeing algorithms with the treshhold being decreased and weird stuff.
18:18:35 <revenantphx> threshhold*
18:18:43 <monochrom> return (x<p)
18:18:54 <jmcarthur> threshold
18:18:56 <revenantphx> Oh, they're comparing to zero here.
18:18:58 <monochrom> (thanks for turning on -O on me :) )
18:19:05 <Axman6> revenantphx: doing things in parallel with blocks is lots of fun
18:19:13 <revenantphx> Axman6: yep.
18:19:28 <Axman6> gcd is awesome :)
18:19:29 <revenantphx> libdispatch helps my sim speed ridiculously.
18:19:33 <revenantphx> mmhm.
18:19:38 <Olathe> random >>= return . (<p)
18:19:42 <revenantphx> It runs 13 sims in parallel.
18:19:47 <magicman> fmap (<p) random
18:19:55 <Olathe> Ooh
18:19:56 <Axman6> (<p) <*> random
18:19:59 <Olathe> fmap!
18:20:03 <monochrom> @type random
18:20:04 <revenantphx> As soon as GCD can automatically convert C programs to OpenCL kernels and run them on other GPGPU decides, Axman6...
18:20:04 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
18:20:15 <magicman> (or liftM, or <$>, or whichever)
18:20:19 <Axman6> revenantphx: amen
18:20:26 <revenantphx> then someone will have invented the C semi-panacea to scaling across cores..
18:20:45 <Axman6> indeed
18:20:46 <revenantphx> It would be so beautiful TT_TT
18:20:52 <Axman6> :D
18:21:15 <revenantphx> automatically scaling from humble Pentium III to eight core dual processor rig with 2 parallel GPU's with 180 cores each.
18:21:20 <revenantphx> Magic.
18:21:27 <revenantphx> I really really want to play with the Cell BE.
18:21:37 <revenantphx> That's on my list of stuff to do when I have time.
18:21:45 <revenantphx> I'd rather not mess up my PS3 though, so we'll see.
18:21:53 <Axman6> me too
18:21:57 <magicman> Is there a way to merge two "Chan"s, such that anything written to either of them ends up in the "merged" version?
18:22:15 <Olathe> I wonder if the wonderful Haskell GPU computation library will work on my machine.
18:22:17 <Axman6> magicman: fork two threads to do it
18:22:44 <magicman> Right, each thread reading from either chan, and writing to the merged one?
18:22:50 <Axman6> yup
18:23:06 <magicman> Cool, thanks :)
18:23:46 <monochrom> with STM it may be unnecessary to merge. just listen to both. readTChan x `orElse` readTChan y
18:24:25 <revenantphx> Axman6: dispatch_once is a miracle btw.
18:25:02 <magicman> Oooh, good one.
18:25:17 <revenantphx> Have you ever tried to write a threadsafe singleton method Axman6 ?
18:25:33 <Olathe> Does orElse prioritize one side over the other?
18:25:48 <Axman6> nope
18:26:00 <Axman6> i haven't played with gcd much, just enough to know it's awesome
18:26:11 <revenantphx> okay so
18:26:16 <revenantphx> you know how singletons work right?
18:26:16 <Axman6> Olathe: if the first failes, it tries the second
18:26:33 <revenantphx> class method returns the same instance every time.
18:26:35 <monochrom> prioritizes to the first one. written in the doc.
18:26:35 <Axman6> fails*
18:26:40 <revenantphx> And the first time it's called it creates the instance.
18:26:43 <Olathe> Ahh, OK.
18:26:44 <Axman6> revenantphx: yeah
18:26:55 <revenantphx> You can see that it would be an issue if two threads both called at once, and they both made it...
18:27:02 <revenantphx> so you end up with a classic MT problem.
18:27:10 <Axman6> oh no D:
18:27:15 <revenantphx> https://gist.github.com/808945
18:27:19 <revenantphx> libdispatch to the rescue
18:27:45 <revenantphx> dispatch_once takes a predicate it uses and somehow, MAGICALLY, only gets called once...
18:27:48 <revenantphx> *without locks*
18:27:51 <Axman6> oh nice
18:28:02 <revenantphx> (I believe it ensures atomicity and some other low level stuff)
18:28:11 <revenantphx> (OSAtomic is the other option for easy singletons)
18:28:17 <revenantphx> it doesn't even incur memory barriers.
18:28:24 <revenantphx> So it's fast, easy and safe :).
18:28:33 <Axman6> looks good :)
18:28:40 <kmc> no memory barriers eh
18:28:44 <Axman6> should be as easy as a CAS no?
18:29:03 <Axman6> if the pred is false, make it true, then run the action. if it's true, don't run the action
18:29:07 <revenantphx> kmc: It's a miracle worker.
18:29:09 <john_r_watson> Does (liftM2 (&&) (>= 1) (<= 8)) lose the short-circuiting in the equivalent (\x -> (x >= 1) && (x <= 8)) ?
18:29:19 <Axman6> john_r_watson: no
18:29:24 <revenantphx> Axman6: yeah, but it somehow maintains atomicity and prevents other threads from screwing up the check.
18:29:34 <Axman6> revenantphx: hence the CAS
18:29:35 <kmc> john_r_watson, all of Haskell short-circuits, essentially
18:29:38 <revenantphx> there's a low level syscall called OSAtomicCompareandSwap
18:29:39 <revenantphx> yeah,
18:29:42 <azaq23> (&&) short circuits due to laziness
18:29:42 <revenantphx> but it doesn't do the same thing.
18:29:47 <revenantphx> I forget, but it has some magic.
18:29:50 <revenantphx> The source is open.
18:29:56 <kmc> yeah, a syscall will be much more expensive than an atomic CAS instruction
18:30:18 <john_r_watson> I was looking at the desugaring which fooled me I suppose:(>= 1) >>= (\x -> (<= 8) >>= (\y -> return $ x && y))
18:30:28 <kmc> anyway i guess memory barriers aren't necessary because it's a single instruction
18:30:42 <revenantphx> kmc: I don't believe it is though
18:30:53 <revenantphx> since it actually allows you to execute an entire block once, atomically.
18:30:59 <john_r_watson> but I guess laziness solves the problem more or less.  I would imagine the "thunk" wouldn't get created in the first place in the straightforward lambda though
18:31:01 <Olathe> @src liftM2
18:31:02 <revenantphx> andi t prevents other threads from messing it up
18:31:02 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:32:01 <revenantphx> http://libdispatch.macosforge.org/trac/browser/trunk/dispatch/once.h
18:32:04 <revenantphx> oh god its a macro 
18:32:19 <Axman6> ha
18:32:44 <kmc> that's not the interesting bit anyway
18:32:47 <revenantphx> yeah
18:32:57 <kmc> john_r_watson, thunk for which?
18:33:04 <john_r_watson> (>= 8)
18:33:09 <john_r_watson> kmc: (>= 8)
18:33:17 <revenantphx> http://libdispatch.macosforge.org/trac/browser/trunk/src/once.c
18:33:21 <kmc> well that's a partial application
18:33:31 <kmc> in some sense it's not a thunk, because not much happens if you force it by itself
18:34:17 <kmc> there's kind of three levels here: the Haskell Report, the semantics provided by most Haskell compilers, and the implementation used by good Haskell compilers
18:34:24 <john_r_watson> kmc: yeah
18:34:35 <kmc> (a) says nothing about thunks; the Report doesn't guarantee lazy evaluation and allows substantial work to be duplicated
18:34:35 <Axman6> revenantphx: i guess dispatch_atomic_cmpxchg will be where the CAS happens
18:34:58 <revenantphx> compare and exchange
18:35:08 <revenantphx> so eah
18:35:08 <kmc> by (b) i mean performance with respect to sharing and there it's pretty much "thunks are always created"
18:35:26 <kmc> but compilers are free to do strictness analysis and avoid creating thunks which will always be forced immediately
18:35:34 <kmc> with GHC you can read the Core output to see if this has occurred
18:35:56 <john_r_watson> kmc: that soudns interesting - mind telling me how to do that?
18:35:59 <john_r_watson> kmc: read coreoutput
18:36:14 <kmc> the easy way is to get the "ghc-core" app from hackage
18:36:18 <kmc> and then run "ghc-core" instead of "ghc"
18:36:27 <john_r_watson> kmc: neato
18:36:28 <kmc> the raw ghc option is -ddump-simpl
18:36:31 <kmc> but ghc-core will clean it up, etc.
18:36:36 <kmc> beware, Core is pretty hard to read
18:36:43 <kmc> i think there's some guides online to reading it, but i don't have a link atm
18:37:01 <Axman6> tibbe has a talk which shows you how to do it
18:37:04 <kmc> the language is basically desugared Haskell with explicit type abstraction/application, but it's very *ugly* desugared Haskell
18:37:04 <john_r_watson> kmc: I'm sure it's findable via (G|H)oogel
18:37:07 <Axman6> on a basic level anyway
18:37:23 <john_r_watson> Axman6: I'll look for it
18:37:36 <maurer_> Does -fglasgow-exts no longer work? When trying to install some packages via cabal, I first see a warning that glasgow-exts is deprecated, followed by errors due to it using some extensions...
18:37:40 <Axman6> the easiest way to read it is to stick it in a text editor, and delete all the stuff you're not interested in
18:38:13 <john_r_watson> Axman6: this http://www.slideshare.net/tibbe/highperformance-haskell ?
18:38:33 <Axman6> yup
18:39:47 <kmc> maurer_, perhaps the problem is fglasgow-exts => GADTs => MonoLocalBinds?
18:40:01 <kmc> basically turning on extensions can break some H98 code and moreso in GHC7
18:53:32 <maurer_> kmc: The problem I'm running into is that a hojillion packages use BangPatterns
18:53:41 <maurer_> It appears fglasgow-exts used to imply it, and no longer does
18:54:09 <maurer_> So a lot of important stuff suddently fails to install under GHC7. It's easy to fix via manually adding extensions to all the packages, but...
18:55:20 * maurer_ is almost considering aliasing ghc to ghc -XBangPatterns -XTypeSynonymInstances to get all the packages working again
18:55:25 <kmc> hehe
18:55:29 <monochrom> bang pattern appeared after the LANGUAGE pragma. no one should use -fglasgow-exts for it.
18:55:30 <kmc> maybe you can do something in ~/.cabal
18:55:55 <gwern> maurer_: I'm heartened to see you following in my footsteps!
18:55:57 <kmc> but yeah, Hackage doesn't have a great way to deal with build breakage on packages with absent maintainers
18:56:04 <gwern> thanklessly tweaking countless cabal files
18:56:09 <maurer_> monochrom: They _shouldn't_ but try installing yesod with GHC7. At least 4 separate dependencies of it use bang patterns without enabling the extension
18:56:18 <dcoutts> maurer_: ah yes, it was a ghc bug, it incorrectly accepted ! patterns in some places even when the BangPatterns extension was not in use
18:56:26 <maurer_> Ah :/
18:56:31 <dcoutts> maurer_: the bug was fixed in ghc-7, so that's why you see it now
18:56:37 <kmc> too bad we don't define the language as whatever the compiler accepts
18:56:42 <djahandarie> Is there an extremely simple package that handles making the main thread wait for its children threads? I've gotten sick of rolling this code myself every time, and all the packages I've seen look like they do too much
18:56:46 <dcoutts> mauke: same with NonIncreacingIndentation
18:56:56 <dcoutts> oops, maurer_ 
18:56:57 <maurer_> Makes sense. Hopefully the maintainers with that bug will fix upstream soon so I don't have to keep switching it locally.
18:57:05 <monochrom> oh god, this gets uglier than I thought
18:57:05 <kmc> have i got a deal for you djahandarie!
18:57:06 <kmc> http://hackage.haskell.org/packages/archive/spawn/0.2/doc/html/Control-Concurrent-Spawn.html
18:57:14 <kmc> a magical and revolutionary library at an unbeatable price
18:57:21 <djahandarie> Hahaha nice
18:57:39 <dcoutts> so it's nothing to do with -fglasgow-exts
18:58:58 <xplat> it's more 'how do i turn this thing off?!'
19:00:00 <Axman6> damn, sage looks awesome!
19:01:21 <Eduard_Munteanu> Axman6: sagemath thingy?
19:01:25 <Axman6> yeah
19:01:46 <Axman6> lets you do things like embed sage stuff in LaTeX
19:02:34 <Eduard_Munteanu> Damn, if only FOSS control theory software didn't suck so much.
19:03:02 <Eduard_Munteanu> Then again, it's hard to find anything free on that subject.
19:04:51 <joe6> i asked this earlier but got no response, so trying again: http://hpaste.org/43566/joe
19:05:06 <joe6> I am trying to generate the function parameters without the function call from TH
19:05:28 <revenantphx> Hrm.
19:05:36 <joe6> edwardk suggested using *P functions, but I could not figure how they work as I could not test them from ghci
19:05:40 <revenantphx> Technically if you consider the strting time as "input" to the program,
19:05:49 <revenantphx> then a program using random numbers can easily be pure.
19:05:57 <revenantphx> Just a pain in the ass passing around generators.
19:06:05 <joe6> any suggestions, please?
19:06:14 <revenantphx> Anyone recommend a simple generator monad that hides the passing of the gen?
19:06:18 <revenantphx> (basically Reader-lite)
19:06:29 <Axman6> joe6: i think it was me who suggested that. can't you just create a list of patterns?
19:06:55 <monochrom> (actually it's State-lite. there are a bunch of random number monads.)
19:07:25 <revenantphx> monochrom: I guess yeah.
19:07:38 <revenantphx> Axman6: A student at the lab I intern in uses sage
19:07:51 <revenantphx> since it bundles python, numpy, scipy, matplotlib and so on.
19:07:59 <revenantphx> I just have them installed through brew/easy_install >_>
19:08:04 <revenantphx> So I didn't bother with sage.
19:08:28 <Axman6> sage seems to give you a nice interface to it all
19:08:39 <revenantphx> Well, I'm writing sims.
19:08:43 <revenantphx> And the last week has shown,
19:08:52 <revenantphx> while it's clean, python will not be my sim-writing language.
19:08:54 <revenantphx> Back to C we go.
19:09:00 <revenantphx> GIL vs libdispatch ;)
19:09:03 <revenantphx> hard choice, huh.
19:09:22 <Axman6> well, if it were me, i'd use C because i know it
19:09:26 <revenantphx> mmhm.
19:09:39 <revenantphx> They just suggested "use python since the C sim has broken rand stuff"
19:09:47 <revenantphx> so I tried it, it worked fine, but it was slow as fuck.
19:10:00 <revenantphx> And well, that wont fly.
19:10:25 <revenantphx> A simulation that takes 11ms in C shouldn't take 5:30 in Python.
19:10:31 <monochrom> heh
19:10:54 <Rotaerk> probably just don't know how to optimize properly in that language or something
19:10:54 <lambdabot> Rotaerk: You have 1 new message. '/msg lambdabot @messages' to read it.
19:11:04 <Rotaerk> I find that difference hard to believe
19:11:26 <monochrom> heh heh
19:11:30 <Axman6> yeah, i did a couse on high performance computation and our maine project was to write a a cloth sim in python, then make it faster using C
19:11:33 <joe6> Axman6: thanks, sorry I forgot that.
19:11:38 <revenantphx> Rotaerk: well, thats not a fair comparison to be honest
19:11:46 <revenantphx> the first was 10 sims, not 1
19:11:53 <joe6> Axman6: let me try with ListP
19:12:01 <revenantphx> and the latter was supposed to be 1000000, but it hadnt even finished one after 5:30 so I cancelled it.
19:12:08 <revenantphx> (minutes, not hours)
19:12:12 <Rotaerk> I suspect you did it wrong
19:12:15 <Axman6> joe6: wouldn't that just be a pattern matching things like [a,b,d]?
19:12:29 <revenantphx> knock yourself out
19:12:32 <revenantphx> https://gist.github.com/809002
19:12:37 <revenantphx> try running this.
19:12:43 <Rotaerk> otherwise put, "ur doing it rong"
19:12:53 <revenantphx> ...just try running it yourself.
19:13:02 <revenantphx> I reduced sims to 500 there.
19:13:03 <joe6> Axman6: the function call is like this: f a b c d e f, and I have a few such function calls where f is different but a b c d e are the same
19:13:22 <joe6> Axman6: would a list pattern suffice?
19:13:26 <revenantphx> I can run 500 sims in under 5 seconds in the C version.
19:13:29 <joe6> in such a scenario.
19:13:30 <revenantphx> roughly speaking.
19:13:38 <revenantphx> So if you can get that to even 15 seconds, i'll be impressed.
19:13:48 <Rotaerk> I don't know python :P
19:13:55 <Rotaerk> don't have it installed either
19:14:17 <Axman6> joe6: from what i understand, f a b c d e f = ... becomes: Clause [VarP a_1, VarP b_1 ...] 
19:14:17 <joe6> Axman6: I currently have a macro that takes f as a parameter and generates the f a b c d e, but am curious if I can make it to just generate the a b c d e.
19:14:21 <revenantphx> One thing to note is that python uses a global interpreter lock...
19:14:36 <Axman6> so all you need to so is make the list of VarP
19:14:37 <revenantphx> and the interpreter is single core.
19:14:39 <revenantphx> while in C I'm just running 10+ sims at once across all cores.
19:14:48 <Axman6> joe6: last thing on http://www.hyperedsoftware.com/blog/entries/first-stab-th.html
19:14:51 <joe6> Axman6: ok, thanks. will check it out
19:15:07 <Rotaerk> revenantphx, regardless, that's no excuse for it taking 5 minutes for one
19:15:13 <revenantphx> agreed.
19:15:21 <Rotaerk> are you sure it even *would* have finished? there were no bugs?
19:15:23 <revenantphx> er, one set of values mind you.
19:15:30 <revenantphx> as in, one set of 0-10
19:15:33 <revenantphx> the inner loop there
19:15:36 <revenantphx> it finishes sims yes.
19:15:39 <revenantphx> they just go slowly.
19:15:58 <revenantphx> each one is running 10000 timesteps over 200 ants and 153 cells
19:16:26 <revenantphx> It seems python's comparison is slow or something silly like that,
19:16:31 <revenantphx> since most of this is just if stattements
19:16:43 <revenantphx> (it's a pseudo-CA)
19:22:04 <joe6> @hoogle Pat -> Exp
19:22:04 <lambdabot> Language.Haskell.TH LamE :: [Pat] -> Exp -> Exp
19:22:04 <lambdabot> Language.Haskell.TH.Syntax LamE :: [Pat] -> Exp -> Exp
19:22:04 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:24:46 <jamii>  seems that my hotel in shanghai block outgoing ssh, even on port 80
19:24:49 <Page15> "tofoldC (n, ts) = map (\t -> tofoldT t ++ "_ -> _") ts" Is there something obvious wrong there?
19:24:52 <joe6> Axman6: are you aware of a function that can convert Pat to Exp.
19:25:00 <jamii> not sure where to go from there
19:25:16 <joe6> i tried $( return $  ListP [ WildP, WildP])
19:25:20 <revenantphx> jamii: HTTP proxy?
19:25:35 <joe6> it appears that the splice expression only takes QExp
19:25:46 <revenantphx> (TCP packets wrapped in HTTP headers to pass through firewall)
19:25:54 <revenantphx> also, I'm surprised IRC works... or are you using qweb?
19:26:54 <revenantphx> The hard part here is you need an HTTP proxy available to you.
19:27:08 <joe6> @hoogle PatQ -> ExpQ
19:27:08 <lambdabot> Language.Haskell.TH lam1E :: PatQ -> ExpQ -> ExpQ
19:27:08 <lambdabot> Language.Haskell.TH.Lib lam1E :: PatQ -> ExpQ -> ExpQ
19:27:08 <lambdabot> Language.Haskell.TH lamE :: [PatQ] -> ExpQ -> ExpQ
19:27:09 <Axman6> Page15: i have no idea what that code's supposed to do
19:27:25 <revenantphx> alternatively, you could use an in-browser ssh, but I'm not sure how much I trust that ;)
19:27:48 <revenantphx> it would work though
19:28:06 <joe6> all the Pat -> Exp functions seem to be tied with the lambda functions.
19:28:33 <revenantphx> @hoogle * -> ExpQ
19:28:33 <lambdabot> Parse error:
19:28:33 <lambdabot>   --count=20 "* -> ExpQ"
19:28:33 <lambdabot>              ^
19:28:44 <revenantphx> @hoogle ? -> Exp
19:28:44 <lambdabot> Parse error:
19:28:44 <lambdabot>   --count=20 "? -> Exp"
19:28:44 <lambdabot>              ^
19:28:48 <revenantphx> whic hwas it ._.
19:29:05 <Axman6> @hoogle -> ExpQ
19:29:06 <lambdabot> Parse error:
19:29:06 <lambdabot>   --count=20 "-> ExpQ"
19:29:06 <lambdabot>              ^
19:29:08 <Axman6> :(
19:29:34 <revenantphx> @hoogle _ -> Exp
19:29:34 <lambdabot> Prelude id :: a -> a
19:29:35 <lambdabot> Data.Function id :: a -> a
19:29:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:29:39 <revenantphx> @hoogle _ -> ExpQ
19:29:39 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
19:29:40 <lambdabot> Language.Haskell.TH.Syntax returnQ :: a -> Q a
19:29:40 <lambdabot> Language.Haskell.TH litE :: Lit -> ExpQ
19:29:59 <revenantphx> @hoogle PatQ -> _
19:29:59 <lambdabot> Language.Haskell.TH runQ :: Quasi m => Q a -> m a
19:29:59 <lambdabot> Language.Haskell.TH.Syntax runQ :: Quasi m => Q a -> m a
19:29:59 <lambdabot> Language.Haskell.TH tildeP :: PatQ -> PatQ
19:30:10 <revenantphx> @hoogle PatQ -> _ -> ExpQ
19:30:10 <lambdabot> Language.Haskell.TH lam1E :: PatQ -> ExpQ -> ExpQ
19:30:10 <lambdabot> Language.Haskell.TH.Lib lam1E :: PatQ -> ExpQ -> ExpQ
19:30:10 <lambdabot> Language.Haskell.TH lamE :: [PatQ] -> ExpQ -> ExpQ
19:30:24 <revenantphx> @hoogle PatQ -> _ -> _-> ExpQ
19:30:24 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
19:30:25 <lambdabot> Control.Monad liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
19:30:25 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
19:30:30 <revenantphx> ...right
19:30:31 <revenantphx> anyways
19:30:32 <revenantphx> good night folks
19:30:52 <Axman6> o/
19:31:43 <joe6> revenantphx: were you trying to help me?
19:31:45 <revenantphx> I'm sorry, that STILL looks like "heil hitler" to me.
19:31:48 <revenantphx> joe6: kind of.
19:31:55 <revenantphx> I think the PatQ -> results were more useful?
19:32:15 <joe6> none of the above seems useful.
19:32:44 <jamii> revenantphx: im not after a proxy, i actually need to ssh in and fix a server
19:33:23 <Axman6> jamii: he way suggesting using a http proxy to tunnel your ssh connection
19:36:01 <jamii> Axman6: how would I do that?
19:36:21 <Axman6> i don't know, but google does
19:37:11 <adu> hi Axman6 
19:37:25 <Axman6> o/
19:39:24 <Page15> Axman6: http://pastebin.com/a5uAGg4V
19:39:39 <Page15> Axman6: Thats what I am aiming for
19:40:05 <Axman6> were you using a different name yesterday?
19:40:43 <Page15> Random Name bank :) I think it was Jotta
19:40:46 <Axman6> what's the n given to tofoldC for?
19:41:10 <Axman6> ok, please pick a name and stick to it, constantly changing names is very annoying and unhelpful
19:41:21 <Page15> *Name = String. For constructors it needs a name
19:41:25 <Page15> Which is a String
19:41:26 <Axman6> you should probably use contatMap there
19:41:51 <Page15> What does that do?
19:42:06 <Axman6> or, better yet, you intervalate " -> " . map tofoldC $ ts
19:42:26 <Axman6> well, map maps things, concat concats things, so concat maps and then concats things ;)
19:42:33 <joe6> is it wrong to use language extensions, such as -XScopedTypeVariables
19:42:34 <Page15> Nah dont jump too far ahead. I can handle ContatMap :)
19:42:37 <Axman6> concatMap f xs = concat (map f xs)
19:42:58 <Axman6> Page15: not using intercalate will result in an extra -> at the end of your expression
19:43:09 <Axman6> this can't be avoided using concatMap
19:43:26 <Page15> Thats fine for now
19:43:30 <Axman6> > intercalaye " -> " ["Int","String","Bool"]
19:43:31 <lambdabot>   Not in scope: `intercalaye'
19:43:35 <Axman6> > intercalate " -> " ["Int","String","Bool"]
19:43:36 <lambdabot>   "Int -> String -> Bool"
19:43:49 <Axman6> > text $ intercalate " -> " ["Int","String","Bool"]
19:43:50 <lambdabot>   Int -> String -> Bool
19:44:08 <Page15> Ok, but what have I done wrong in my code?
19:44:24 <Axman6> concat map doesn't make any sense
19:44:46 <Axman6> you need concat (map (\t ->...) ts) ++ "x"
19:45:05 <Axman6> or, just use concatMap (\t -> ...) ts ++ "x"
19:45:45 <Page15> Ok
19:46:15 <Page15> I was so close, lol
19:46:53 <Page15> *looks at intercalaye*
19:47:01 <Page15> *t
19:47:09 <Axman6> :t intercalate
19:47:10 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:47:31 <Axman6> it just sticks the first list between each list in the second list, and concats them
19:47:42 <Axman6> > intersperse 1 [1..10]
19:47:43 <lambdabot>   [1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10]
19:47:48 <Axman6> another useful function
19:47:54 <Page15> I see that
19:48:19 <Axman6> @let toTroll = text . intercalate "\n" . map toUpper
19:48:20 <lambdabot>  <local>:3:40:
19:48:20 <lambdabot>      Couldn't match expected type `[Char]' against inferred ty...
19:48:33 <Axman6> @let toTroll = text . intercalate "\n" . words . map toUpper
19:48:34 <lambdabot>  Defined.
19:48:46 <Axman6> > toTroll "testing 3 2 1 lololol?"
19:48:48 <lambdabot>   TESTING
19:48:48 <lambdabot>  3
19:48:48 <lambdabot>  2
19:48:48 <lambdabot>  1
19:48:48 <lambdabot>  LOLOLOL?
19:48:51 <Axman6> XD
19:49:33 <Axman6> uh, intercalate "\n" == unlines, my bad
19:49:47 <Axman6> @src unlines
19:49:47 <lambdabot> unlines = concatMap (++ "\n")
19:49:52 <Axman6> almost
19:49:59 <Page15> My ghci doesnt pick up":t intercalate" :s
19:50:26 <Page15> :t intercalate
19:50:26 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:50:37 <Axman6> it's in Data.List
19:50:38 <jmcarthur> Page15: :m + Data.List
19:51:40 <Page15> ta
19:53:01 <Page15> "tofoldC (n, ts) = intercalate ts" that it?
19:53:20 <Page15> or "tofoldC (_, ts) =intercalate ts"
19:54:15 <Axman6> no
19:54:30 <Page15> Ah forgot ++ "->x" at the end
19:54:35 <Axman6> intercalate tyakes a list of things you want to pur between the lists in its second argument
19:55:10 <Axman6> you need tofoldC (_,ts) = intercalate " -> " ts ++ " -> x"
19:55:18 <Page15> lol yeh just saw that
19:55:24 <Page15> Need the filler :)
19:55:49 <Axman6> uh, you need a map there too i think
19:56:00 <Page15> Why?
19:56:15 <Axman6> so, intercalte " -> " (map tofoldT ts) ++ " -> x"
19:56:21 <Axman6> a*
19:56:34 <Page15> Ah yeh I see
19:56:40 <Page15> Need to translate them first
19:57:35 <Page15> I think im starting to get a grip on this whole Haskell thing ;)
19:59:22 <Page15> Axman6: Thanks
19:59:56 <tengen> what's a nicer way to count the number of arguments in a data constructor than "sum . gmapQ (const 1)" ?
20:00:24 <Axman6> can you just get the length?
20:01:05 <tengen> well, right. I could replace sum with length, but that's not much better
20:03:18 <Page15> Would "tofoldC (n, ts) = concatMap (\t -> tofoldT t ++ " -> ") ts ++ " -> x"" have resulted in a "-> -> x" at the end?
20:04:02 <tengen> > length . gmapQ (const 1) $ (1,2,3,4)
20:04:04 <lambdabot>   4
20:04:35 <Page15> Axman6: Would "tofoldC (n, ts) = concatMap (\t -> tofoldT t ++ " -> ") ts ++ " -> x"" have resulted in a "-> -> x" at the end?
20:04:54 <Axman6> yes
20:05:17 <Axman6> but, if you get rid of the -> in " -> x" you'd end up with the same result
20:05:47 <Page15> Ah yeh was just thinking that myself :)
20:07:54 <Page15> Axman6: Thanks
20:08:37 <tengen> Axman6: were you referring to something else when you said "can you just get the length?"
20:09:01 <Axman6> yes
20:09:14 <tengen> what?
20:09:22 <Axman6> uh, no, sorry.
20:09:29 <Axman6> i didn;t know what gmapQ did
20:09:43 <Axman6> what's its type?
20:09:51 <tengen> :t gmapQ
20:09:52 <lambdabot> forall u a. (Data a) => (forall d. (Data d) => d -> u) -> a -> [u]
20:10:08 <Axman6> can't you just do length . gmapQ id?
20:10:40 <tengen> actually
20:10:48 <tengen> there's a glength built-in
20:10:51 <tengen> :t glength
20:10:52 <lambdabot> forall a. (Data a) => a -> Int
20:11:08 <tengen> and apparently it's implemented the same way
20:11:12 <tengen> glength = length . gmapQ (const ())
20:28:04 <Olathe> @type gmapQ
20:28:05 <lambdabot> forall u a. (Data a) => (forall d. (Data d) => d -> u) -> a -> [u]
20:47:53 <int80_h> Hiya, trying to explore what is wrong with my code with hlint. I get this error message
20:47:56 <int80_h> hlint: In file HtmlParsing.lhs at line 1: comment line before program line.
20:48:16 <int80_h> But all lines begin with <, so any ideas what's wrong?
20:48:45 <int80_h> I installed an old version of hlint, b ut then did cabal update and did "cabal install" again.
20:48:52 <int80_h> still, same problem
20:50:42 <int80_h> I meant to say all lines begin with a >. oops
20:52:22 <mzero> if ALL lines have > at the start, why not remove all that and make 'em .hs files?
20:52:34 <mzero> alternatively, did you try putting a line w/o > at the very start
20:52:40 * hackagebot enumerator 0.4.6 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.6 (JohnMillikin)
20:57:41 * hackagebot AttoJson 0.5.10 - Simple lightweight JSON parser, generator & manipulator based on ByteString  http://hackage.haskell.org/package/AttoJson-0.5.10 (HiromiIshii)
20:59:58 <int80_h> mzero: thanks. Having first line blank did it
21:00:13 <mzero> yay
21:00:42 <mzero> having a literate haskell file with no "literature" is, I suspect, unexpected
21:01:04 <int80_h> it will one day!
21:01:14 <int80_h> hlint loves lisp style
21:01:21 <int80_h> wants () everywhere
21:01:27 <int80_h> instead of $
21:02:57 <int80_h> useful info, will help me with style. But no clue as to what is wrong.
21:06:33 <adu> i have a question
21:06:56 <adu> how do I get the haddoc documentation to show up in hackage?
21:15:16 <joe6> i am trying to get this, but the url is not working: darcs get http://code.haskell.org/~basvandijk/code/usb-safe-examples 
21:15:21 <Axman6> adu: you wait
21:15:27 <adu> Axman6: ?
21:15:27 <Axman6> it gets done every few hours
21:15:33 <joe6> Does anyone know if the link might be hosted anywhere else?
21:15:41 <adu> o
21:15:48 <adu> Axman6: ok
21:16:03 <Axman6> i think it can take up to 6 hours. i gets done in batches
21:16:10 <adu> I thought it might be something like I have to put the filenames in the cabal file
21:16:26 <adu> or supports-haddoc: true or something
21:16:51 <adu> I also didn't use haddoc in the previous version, so maybe that's why
21:29:32 <joe6> @hoogle usb-safe-examples
21:29:32 <lambdabot> No results found
21:47:58 * hackagebot time 1.2.0.4 - A time library  http://hackage.haskell.org/package/time-1.2.0.4 (AshleyYakeley)
21:50:32 <fusss> are there any WinHugs developers around? I have a throw-away bug report to make
21:52:29 <fusss> I can't be bothered to signup for trac for one issue. I am on WinXP and WinHugs has this nasty bug of changing the keyboard setting from English to Arabic. I have a two language setting but I want it to use the one I chose (English). As is, I can't have Arabic enabled on my machine and use WinHugs, I have to disable Arabic altogether before I launch WinHugs. Doesn't happen with other langs; tried Amharic, Armenian, Bosnian, etc. (thinking it sorts by language na
21:53:11 <kfr> Cut off after "(thinking it sorts by language na"
21:53:20 <kfr> fusss that sounds pretty annoying, I'd trac that
21:53:55 <fusss> (thinking it sorts by language name)
21:54:03 <fusss> thanks kfr
21:54:58 <fusss> kfr: did you mean you will report it, or do you think I should do it? I don't mind doing it, just needed to get a feel for the community first and see if the WinHugs Language Issue is well known
21:55:10 <kfr> You should do it
21:55:14 <kfr> I don'\t even use Hugs
21:55:25 <kfr> Most people use ghc only in here really
22:07:34 <fusss> ticket created, http://hackage.haskell.org/trac/hugs/ticket/101
22:07:41 <kfr> Good man
22:07:44 <kfr> Wow only 101 tickets
22:08:13 <kfr> fusss btw, why do you use hugs over ghc?
22:08:34 <kfr> Can Hugs even deal with all the Haskell packages?
22:08:38 <kfr> From HackageDB?
22:09:38 <fusss> kfr: I'm on very limited resources (1GB RAM, 3GB disk, expensive 3G internet) and hack in ungodly number of languages. I pretty much use minimal-footprint stuff. Aside from Emacs, everything I run I sub 100 megs.
22:10:03 <kfr> :O
22:10:04 <fusss> kfr: my haskell is limited to theorem proving and writing type-checkers; I'm a Lisper by profession
22:10:13 <kfr> Curious
22:10:44 <kfr> How do you use Haskell to prove theorems?
22:11:14 <djahandarie> @djinn a -> a
22:11:15 <lambdabot> f a = a
22:11:17 <djahandarie> Proved
22:11:22 <fusss> kfr: not prove theorems; i go through a lot of type theory papers and half of them use haskell examples. just test things out.
22:11:35 <kfr> Oh, ok.
22:11:50 <fusss> alright, thanks for your time
22:11:52 <fusss> cheers!
22:11:55 <djahandarie> @djinn ((((a, b) -> f) -> Either (a -> f) (b -> f)) -> f) -> f
22:11:56 <lambdabot> f a = a (\ b -> Left (\ c -> a (\ _ -> Right (\ d -> b (c, d)))))
22:12:07 <djahandarie> Aw he missed me proving CPS of demorgans law
22:12:42 <kfr> CPS = ?
22:13:05 <djahandarie> Continuation passing style
22:14:58 <djahandarie> @djinn ((a->b)->a)->a
22:14:58 <lambdabot> -- f cannot be realized.
22:15:19 <djahandarie> @djinn Not (Not (((a->b)->a)->a))
22:15:19 <lambdabot> f a =
22:15:19 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
22:15:24 <lispy> I just learned that node.js is server side, and it's based on a paradigm of non-blocking IO.  We could immitate that pretty easily in Haskell using GHC's cheap threads.
22:15:30 <lispy> Has anyone done that yet?
22:15:38 <djahandarie> Yes, iirc
22:15:56 <kfr> Isn't that more of a question of proper API use?
22:16:10 <kfr> For large scale async IO you use IOCP/kqueue/epoll
22:16:14 <kfr> If I'm not mistaken
22:16:36 <lispy> djahandarie: do you have a link?
22:16:39 <djahandarie> But I can't find the blog post
22:16:42 <djahandarie> Sadly no :(
22:16:48 <djahandarie> It was on reddit at one point I think
22:16:52 <lispy> kfr: newer ghc does use kqueue/epoll
22:17:01 <lispy> kfr: Not sure if it's been released yet
22:17:12 <taotree> Question about this code: http://hpaste.org/43570/ignore_type_params_annotation
22:17:28 <djahandarie> Snap outperforms node.js by quite a bit though
22:17:49 <lispy> djahandarie: cool
22:17:52 <taotree> The last L _1 _2 has to be an End, so I don't care about _1 _2, so don't want to mess around with them... is there some way to do so?
22:18:06 <djahandarie> And yesod's server outperforms Snap IIRC, though that may have changed by now
22:18:22 <djahandarie> "Warp" being the name
22:18:25 <lispy> djahandarie: is this what you were thinking of? http://stackoverflow.com/questions/3847108/what-is-the-haskell-response-to-node-js
22:18:52 <djahandarie> No, I remember someone making something similar to node.js in Haskell in a blog post
22:22:05 <lispy> I wanted the snap framework but I ended up here: http://www.snapnetwork.org/  oops!
22:22:50 <ksf> did anyone try out uhc's javascript backend?
22:23:11 <lispy> WHat is libev?
22:23:20 <lispy> ksf: uhc?  I thought that was YHC?
22:23:22 <ksf> it's a c lib that wraps epoll and similar
22:23:28 <ksf> the yhc one bitrotted afaik
22:23:39 <ksf> there's also ghcjs
22:23:41 <lispy> I want backends for GHC anyway
22:23:51 <lispy> ghcjs?  hrm..../me googles
22:23:54 <ksf> ...but that won't work with ghc 7 and I don't wanna downgrade just to try
22:24:32 <ksf> and uhc might not be vastly popular, but those people are professional+convicted.
22:25:30 <lispy> those people?
22:26:01 <smarmy> there's a compiler used exclusively by convicts?
22:26:02 <lispy> I think GHC has reached a point where being more modular would be nice.
22:26:18 <ksf> well, uhc *already is* more modular.
22:26:35 <lispy> Creating an LLVM, js, .net, etc backend should be easier than this
22:26:35 <ksf> its design is suspiciously non-ad-hoc.
22:27:52 <ksf> it's a gazillion compilers in one, uhc is just the default configuration, which gives you haskell.
22:29:05 <lispy> taotree: Well you have to put something there the way it's written
22:29:23 <lispy> taotree: You could imagine hiding them in an existential wrapper type though
22:29:53 <lispy> taotree: and there should be something with recursive types that hides them
22:30:59 <lispy> taotree: I think End needs to be a different type
22:32:06 <jmcarthur> ghc 7 uses epoll
22:32:43 <ksf> or select. or kqueue. whatever it can get.
22:34:11 <taotree> lispy, thanks for the comments. Why do you think End needs to be a different type?
22:35:29 <lispy> taotree: To have the types work the way you want it would need to be separate.  There may be other ways of rewriting it though
22:35:45 <taotree> thanks, I'll explore that.
22:35:46 <taotree> I just tried just throwing stuff in there: type TwoDoubleProps = L Double (L Double (L Double Double))  and it compiled and ran fine, so... since it doesn't matter, apparently I can put anything there.
22:36:26 <lispy> type TwoDoubleProps = forall a b.  L Double (L Double (L a b))
22:37:13 <lispy> taotree: does that work?
22:37:19 <taotree> yes
22:37:25 <taotree> thanks
22:37:47 <lispy> you're welcome, although I'm not 100% sure it's what you want :)
22:38:06 <lispy> It might work for now but when you do something more complex it may mean the wrong thing
22:38:24 <taotree> ok. I'm not quite sure how End could be a different type.
22:38:51 <taotree> and still be able to be chained together with absent and present
22:40:49 <joe6> anyone with experience with "monadic regions"?
22:42:10 <lispy> joe6: you might have better luck if you ask a more specific question
22:42:28 <lispy> joe6: for example, if you stuck give a concrete example of the problem
22:42:35 <lispy> you're*
22:43:33 <taotree> Though the End here might look weird. It might be left over from the more complex form: http://hpaste.org/43571/pae    That form was so that we could force in the type system that there must be at least one thing Present for it to be a valid type.
22:44:14 <taotree> But that more complex form... I was running into problems generating values for it, so... I'll figured maybe I'd try again later.
22:44:18 <lispy> oh
22:44:41 <joe6> lispy: i am trying to understand usb-safe and it uses monadic regions, so trying to get the hang of it.
22:44:48 <lispy> taotree: Types like this get pretty unwieldy even in Haskell :(
22:44:54 <joe6> The usb-safe-examples link does not seem to work.
22:45:09 <lispy> joe6: have you ever looked at the monadic regions paper?
22:45:38 <lispy> (if you say "yes but it's incomprehensible" then I would understand :)
22:46:23 <taotree> lispy, yeah, the simpler form isn't bad at this point. But it doesn't give me the safety of ensuring one Present which I hope to do
22:46:54 <taotree> Now I'm trying to figure out how to use this in arrows... :)
22:47:30 <lispy> taotree: sometimes it helps to separate the enforcement from the representation.  Correct by construction is of course always ideal, but sometimes it's just a lot more practical to use things like smart constructors.
22:47:59 <lispy> taotree: are you familiar with smart constructors?
22:48:30 <taotree> do you mean just using a function to create?
22:48:57 <taotree> Right. even that other form didn't stop you from creating an invalid type, but it did make it so it would be invalid to call any function with an invalid type.
22:49:04 <lispy> yeah, and hiding the normal data constructor.
22:49:21 <taotree> right, thought of that. Maybe will have to go with that
22:50:00 <lispy> taotree: in the more complex form, I wonder if Absent should really return x in both places: L x a (L x b c)
22:50:26 <lispy> taotree: The problem there is that End has x = Invalid
22:50:38 <lispy> taotree: but I assume that you want x = OK
22:51:05 <taotree> Present "injects" an OK in the system which then is carried on by any absents.
22:51:36 <taotree> So if there are no Present's present, it all stays Invalid
22:52:10 <lispy> hmm
22:52:20 <taotree> That's why this: Absent (Absent (Absent (Absent End)))  is creatable, but no function would ever accept it
22:52:32 <taotree> so it still has compile time checking there if you try to use it
22:52:41 * lispy nods
22:53:19 <taotree> not quite what I wanted, but... and the problem is now when I go to try to generate these things... that extra param in there is making a mess, so... I think I may have to punt on that
22:53:46 <lispy> taotree: oh, it just hit me.  In that previous type synonym example, you could use () for the a and b that don't matter
22:54:12 <taotree> ah, right, that makes sense. Though the forall thing that you gave makes the most sense to me
22:55:22 <lispy> It makes good sense, but it may make it harder to deconstruct one of those values.
22:55:42 <lispy> You may get errors about escaping type variables
22:56:18 <joe6> lispy: yes, tried the paper and the talk. I understand the concept, but am not sure how that fits in with the usb-safe code.
22:57:03 <lispy> joe6: I wish I could help more.  I read the monadic regions paper several years ago and I didn't have an immediate need so the knowledge has brainrotted :(
22:57:40 <mbuf> In ghci, if I use :type variable, it prints its type; how can this be done programmatically from a .hs file?
22:58:49 <lispy> mbuf: I guess it depends on how you want to use the type
22:59:55 <lispy> mbuf: Data.Typeable lets you get at the type of something.  Template Haskell let's you manipulate the abstract syntax of your program, and there are probably other things for other uses.
23:00:57 <Axman6> heeeyyyy, i could use templat haskell to find the type of this function!
23:01:06 <Axman6> template too!
23:01:15 <lispy> templeat!
23:01:26 <lispy> templeat haskul!
23:02:50 * Axman6 laughs a bit at boost's optional type
23:03:20 <Axman6> there's like 10 pages of documentation for what in haskell would be... data Maybe a = Nothing | Just a
23:04:24 <c_wraith> in what now?
23:04:28 <Eduard_Munteanu> Heh.
23:04:47 <Axman6> http://www.boost.org/doc/libs/release/libs/optional/index.html
23:04:48 <Eduard_Munteanu> C++
23:05:11 <c_wraith> that's a bit unfair.  Haskell also has a bunch of one-line instance declarations for Maybe :)
23:05:30 <Axman6> eh?
23:05:46 <Eduard_Munteanu> And various tutorials explaining the Maybe monad at length :P
23:05:53 <Axman6> sure
23:05:54 <Eduard_Munteanu> But Axman6 has a point.
23:06:01 <Axman6> but the basic idea is very simple
23:06:06 <c_wraith> a said "a bit".  Not "completely" :)
23:06:19 <Axman6> and optional doesn't even seem to be a monad! :O
23:07:17 <Eduard_Munteanu> I'm not sure how templates stack against functors.
23:07:37 <lispy> The mouse hover text on that page really bothers me
23:07:43 <Eduard_Munteanu> I'd expect some similarity to exist.
23:08:03 <lispy> No matter where you put the mouse on that page it has to make a popup covering part of the text.  Who's idea was that?
23:08:48 <Eduard_Munteanu> A spammer's.
23:08:50 <Axman6> it's a feature, not a bug
23:09:12 * Eduard_Munteanu has to go...
23:09:17 <Eduard_Munteanu> o/
23:09:18 <Axman6> o/
23:09:19 * lispy has to go too
23:09:25 <lispy> \o
23:09:30 <Eduard_Munteanu> \o to you too
23:09:36 <Axman6> \o/
23:09:55 <Axman6> double wave, not celebration at Eduard_Munteanu leaving
23:09:58 <lispy> \_/  <-- headless lispy
23:10:03 <Axman6> D:
23:10:10 <Axman6> i found it!
23:10:11 <Axman6> heh
23:11:13 <joe6> mbuf: check typeOf of Data.Typeable
23:11:23 <joe6> @hoogle typeOf
23:11:23 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
23:11:23 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
23:11:23 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
23:11:44 * Axman6 is considering learning some C++
23:26:05 <ddarius> Axman6: Why?
23:26:15 <Axman6> seems like a language i should like
23:26:28 <ddarius> Okay.  I like it.
23:26:29 <Axman6> i kinda like low level programming
23:27:26 <medfly> I have done some low level programming lately and it wasn't so much fun to need to use such basic components
23:27:50 <medfly> I feel detached from how bigger things are done
23:33:52 <ddarius> Axman6: I presume you are already familiar with an assembly language.
23:34:21 <Axman6> it's been a while, i learnt sparc assembly two years ago
23:35:18 <Axman6> i haven't taken the time to learn how to read x86 assembly, i should probably do that at some point
23:46:25 <Apes> Is leksah a good tool for someone new to haskell?
23:49:09 <Axman6> Apes: i'm not sure it's stable enough. a simple text editor is all you need
23:52:24 <taotree> Apes, I have been using Leksah for a little while and it works for me
