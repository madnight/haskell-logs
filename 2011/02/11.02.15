00:01:21 <minn> Thanks for the suggestions ddarius and wagle. I was Timber linked on the haskell.org page for O'Haskell. I'm not sure they are exactly what I'm looking for, but I'll try them out. Thanks.
00:01:32 <minn> *linked to Timber by
00:02:29 <wagle> apparently people have come up with ways to simulate subtypes in haskell..
00:03:30 <minn> Yeah. In particular, Oleg's paper on object-oriented programming in Haskell using HList.
00:05:34 <wagle> some of the dimensional analysis stuff does it
00:06:13 <wagle> any moment now I'll actually work through it
00:09:02 <gaze__> hey what's this syntax called "class (Eq a, Ord a, EqE a) => OrdE a"
00:09:11 <gaze__> instance xyz, etc.
00:09:57 <gaze__> I haven't see class xyz without the where clause... not too sure where to go looking
00:14:11 <ddarius> gaze__: It's just equivalent to an empty where clause.
00:23:37 <Garfunkel> when will the next haskell platform be out?
00:24:02 <Garfunkel> because I have borked my current setup by trying to upgrade manually
00:25:06 <udoprog> how about a reinstall?
00:25:28 <udoprog> just as an alternative to waiting for the next version
00:25:36 <Garfunkel> but
00:25:45 <Garfunkel> is there a release time set?
00:25:57 <udoprog> http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
00:28:51 <triyo> What is the best way to benchmark the time it takes for a function to execute, preferable at the GHC Interpreter level? For instance, in Clojure I have the "time" function.
00:29:33 <opqdonut> that's a hard question actually, due to laziness
00:29:41 <opqdonut> criterion is a nice benchmarking suite
00:30:23 <opqdonut> but there's no function like time in the Prelude, I'm not sure about hackage
00:31:04 <triyo> opqdonut: I understand the complexity though that in pure functional space its not an easy task.
00:31:15 <triyo> I'll have a look at hackage for anything
00:31:40 <ddarius> Just use criterion.  A "time" function often isn't adequate anyway.
00:31:45 <triyo> For instance I'm writing some algorithms in pure fashion and need to find out how they compare 
00:32:04 <opqdonut> use criterion, you'll get nice plots too
00:32:22 <opqdonut> and statistic analysis of the results
00:33:25 <opqdonut> hmm, QuickCheck has something that checks that a certain tests executes in under a certain time
00:34:21 <triyo> criterion looks pretty cool
00:35:20 <triyo> Seems comprehensive  
00:35:48 <opqdonut> it is
00:37:08 <gaze__> Say I'm writing some sorta DSL... and I have a GADT set up to represent the AST... for instance, const :: a -> Ea and add :: E a -> E a -> E a
00:37:26 <gaze__> how would I set it up such that I can have 3 .+ 3 or (3 .+ 3) .+ 3
00:37:50 <gaze__> in other words, wrap the 3 with a const
00:38:11 <opqdonut> define a num instance "Num a => Num (E a)"
00:38:32 <opqdonut> :t 3
00:38:33 <lambdabot> forall t. (Num t) => t
00:38:41 <opqdonut> literals are overloaded on Num
00:40:00 <gaze__> where does the const constructor come in?
00:43:49 <gaze__> ahh! fromInteger
00:43:50 <gaze__> neat
00:43:54 <Garfunkel> is it safe to remove everything in %appdata%/cabal ?
00:44:28 <accel> haskell: making it popular to write code on paper again
00:45:17 <triyo> because "substitution model" applies again? :)
00:45:38 <accel> because i can't understnd shit w/o drawing littles boxes/arrows
00:45:43 <accel> and I can't draw those in ascii
00:49:49 <shapr> Botje: Any word on academically funded Haskell-oriented BladeCenter discussion?
00:57:03 <triyo> opqdonut: do you have any examples of Criterion. Do I have to provide a Benchmarkable for a function I which ti benchmark?
00:57:09 <gwern> shapr: feel free to email me about my SoC retrospective, but I'm leaving now for my SF flight and won't have internet for like the next 9 or 10 hours
00:57:15 <triyo> *wish to
00:57:18 <ivanm> would it be better to use StateT over the parsing monad or to have a parsing monad with in-built state?
00:57:28 <shapr> gwern: Have fun flying! what's your email?
00:57:38 <rkrzr> hi haskell, I have a little parsec question: how do you succeed at the the end of input?
00:58:03 <shapr> rkrzr: Do you have some code you could hpaste?
00:58:09 <companion_cube> rkrzr, eof
00:58:11 <shapr> rkrzr: Because I don't understand your question exactly.
00:58:13 <rkrzr> one sec
00:58:14 <shapr> oh
00:58:35 <gwern> shapr: same as it always has been, gwern0@gmail.com, or you can leave disqus comments on the page
00:58:41 <rkrzr> companion_cube, eof returns () but I'd like to return a string
00:58:51 <companion_cube> rkrzr, eof is not a string
00:59:07 <Garfunkel> I got this error: cabal: dependencies conflict: ghc-7.0.1 requires bytestring ==0.9.1.8 however bytestring-0.9.1.8 was excluded because ghc-7.0.1 requires bytestring==0.9.1.9
00:59:11 <companion_cube> however, if you have matched something before the eof, you can do     someParser >>= \s -> eof >> return s
00:59:13 <shapr> gwern: thanks!
00:59:25 <ivanm> Garfunkel: methinks you've screwed up your pkg-db
00:59:28 <companion_cube> or, with Control.Applicative,  someParser <* eof
00:59:32 <Garfunkel> oh right
00:59:56 <Garfunkel> ivanm: what do I do?
01:00:10 <rkrzr> I'll try that, one sec
01:01:44 <shapr> Garfunkel: You could blow it away with mv ~/.ghc /tmp/
01:02:21 <Garfunkel> shapr: I'm on windows, I think I'll just reinstall
01:05:19 <shapr> Garfunkel: I know there's a more general solution to that sort of problem, but I've forgotten it.
01:19:08 <ivanm> State monads perform better if you specialise them to the state type, right?
01:19:13 <ivanm> (i.e. don't have the state type be a variable)
01:19:55 * hackagebot TicTacToe 0.0.1 - A sub-project (exercise) for a functional programming course  http://hackage.haskell.org/package/TicTacToe-0.0.1 (TonyMorris)
01:21:40 <mm_freak> ivanm: they might, but you need to benchmark to find this out for sure
01:21:52 <ivanm> *nod*
01:21:53 <mm_freak> intuitively i would say it doesn't make a difference most of the time
01:22:30 <ivanm> I just seemed to recall reading that on -cafe a while back, that's all
01:31:46 <gaze__> what is the "t" for when I go
01:31:49 <gaze__> :t 3
01:31:50 <lambdabot> forall t. (Num t) => t
01:32:54 <dibblego> gaze__: it's short for "type"
01:33:19 <dibblego> unless you mean the t in "forall t."
01:33:29 <dibblego> that's a type variable denoting a polymorphic value
01:33:58 <gaze__> yeah but what is it polymorphic over, typically? Let's say I'm defining an instance of the num class
01:34:17 <mauke> then it is the type you're defining the instance for
01:34:52 <gaze__> data Exp = Const Int | add Exp Exp... instance (Num a) => Num (Exp ???) where ...
01:35:03 <gaze__> I'm not too sure what I'm supposed to be doing with the a
01:35:05 <ivanm> gaze__: no polymorphism needed then
01:35:26 <ivanm> for your example above, that's because Haskell uses fromIntegral for all literal integer values
01:35:45 <mauke> gaze__: instance Num Exp where ...
01:36:41 <gaze__> ahh! Okay, thanks
01:37:37 <mauke> btw, a type like that is in scope in lambdabot
01:37:52 <mauke> > var "foo" + var "bar"
01:37:53 <lambdabot>   foo+bar
01:38:16 <mauke> it's called Expr and has instances for Show and Num
01:38:58 <gaze__> Oh! Thanks :D
01:39:31 <mauke> > (1 + x) * 2
01:39:31 <lambdabot>   (1 + x) * 2
01:44:41 <ivanm> dammit, I now have to choose between orphan instances or cyclic module imports :s
01:45:00 <mjrosenb> :t var
01:45:01 <lambdabot> forall a. String -> Sym a
01:45:10 <mjrosenb> ivanm: why not both?
01:50:52 <ivanm> mjrosenb: aren't they _both_ bad?
01:51:49 <mjrosenb> ivanm: exactly.  the more hacks you have, the better, right?
01:51:52 <mjrosenb> ivanm: iirc, ghc --make handles cyclic module imports by default and is not that bad
01:52:02 <ivanm> you need .ghc-boot files
01:53:34 <Garfunkel> ok, I think I have really broken my installation
01:54:55 <mjrosenb> my bad, i thought ghc resolved that auto-magically 
02:19:00 <absz> Is there a convenient way to bundle Haskell libraries with the source code of an application so that the recipient of the source can compile it without having to install said libraries?
02:19:13 <absz> I'm thinking something like a per-project .cabal directory or something.
02:21:19 <Zao> absz: I believe Galois released some kind of local package system recently.
02:21:37 <Zao> Unsure how deployable that is though.
02:22:10 <absz> @Zao: This needs to hold for about one compile (it's for a homework assignment) :-)
02:22:10 <lambdabot> Unknown command, try @list
02:22:19 <absz> (sorry, lambdabot)
02:22:25 <absz> Thanks for the tip
02:23:19 <Chaze> @pl curry $ join (***)
02:23:19 <lambdabot> curry (join (***))
02:23:32 <Zao> absz: If the libraries are not overly complex, maybe you can just unpack them under your directory structure?
02:23:37 <Chaze> @pl curry $ join (***) length
02:23:37 <lambdabot> curry (join (***) length)
02:24:52 <absz> Zao: I thought about that, but needing to do so for Parsec scared me off :)  Still, that may be simpler.
02:27:16 <shapr> alexj made something like that as well, though I forget the name.
02:28:41 <absz> shapr: I came across http://www.haskell.org/haskellwiki/Capri, which might be what you're thinking of (I don't know the author), but I couldn't get it to work
02:28:54 <Chaze> sometimes i don't get the type system
02:28:56 <Chaze> :t Int
02:28:57 <lambdabot> Not in scope: data constructor `Int'
02:29:01 <Chaze> :t length
02:29:02 <lambdabot> forall a. [a] -> Int
02:29:12 <Chaze> why is this Int and not (Num a) => a
02:29:20 <absz> :t genericLength
02:29:21 <lambdabot> forall b i. (Num i) => [b] -> i
02:29:24 <Twey> Chaze: Because™
02:29:36 <absz> Chaze: You can find genericLength in Data.List
02:29:39 <Twey> It got standardised that way and now we're stuck with it
02:29:46 <Chaze> absz: thx
02:29:50 <Twey> But there's genericLength if you need another type
02:30:11 <absz> Chaze: Data.List has a handful of generic* functions
02:30:13 <absz> :t genericDrop
02:30:14 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
02:30:18 <absz> :t genericIndex
02:30:19 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
02:30:22 <absz> etc.
02:32:18 <absz> Zao: Galois's cabal-dev is looking perfect.  Thank you so much!
02:47:59 <Chaze> is there a (take n *** drop n) kind of function?
02:48:09 <Saizan> ?ty splitAt
02:48:10 <lambdabot> forall a. Int -> [a] -> ([a], [a])
02:48:16 <Chaze> yep, thanks
02:56:06 <zumu> Hello. Anyone knows where I can get haskellmode-vim? The folder on projects.haskell.org is empty :(
02:57:54 <rikshot> noob question: ordering function in a guard gives an error, what?
02:59:04 <rikshot> oh, nevermind
03:22:57 <jonkri> if i have a type between -128 and 127, how should i represent it?
03:23:10 <ddarius> @hoogle Int8
03:23:11 <lambdabot> Data.Int data Int8
03:23:42 <jonkri> thanks
03:35:30 <ivanm> there's an Int8 type? :o
03:35:35 <ivanm> how does that differ from Word8?
03:35:39 <ivanm> @hoogle Word8
03:35:39 <lambdabot> Data.Word data Word8
03:35:40 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
03:35:46 <mux> Word* types are unsigned
03:35:55 <ivanm> *facepalm* doh
03:36:17 <ManateeLazyCat> ivanm: Hi, long time no see. :)
03:36:23 <ivanm> hey ManateeLazyCat 
03:36:39 <ManateeLazyCat> ivanm: How are you?
03:36:42 <flamingspinach> shouldn't http://hackage.haskell.org/platform/ state "March 2011" as the release date of the next version of the haskell platform?
03:36:48 <ivanm> not bad, yourself?
03:36:54 <ivanm> flamingspinach: it might be released this month!
03:36:59 <ManateeLazyCat> ivanm: Yeap, not bad. :)
03:37:08 <flamingspinach> ivanm: http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable says otherwise :)
03:37:36 <ivanm> well, we'll see ;-)
03:37:39 <pastorn> > ((minBound::Int8,maxBound::Int8), (minBound::Word8,maxBound::Word8))
03:37:40 <lambdabot>   ((-128,127),(0,255))
03:41:39 <saml> hey, using 7.0.1 binary, how can I install cabal-install?
03:41:54 <saml> i changed bootstrap.sh so dependencies are met except for Cabal 1.8==
03:41:57 <Zao> saml: Check it out from darcs.
03:42:04 <saml> Zao, ah thanks
03:42:29 <saml> is this recommended if i want to use 7.0.1? or should i wait until haskell platform updates?
03:42:50 <saml> i don't like haskell platform because i have to go through package manager... i usually install stuff on ~/opt/ghc
03:43:21 <Zao> Well, the usual recommendation would be "don't use 7 yet".
03:43:49 <ManateeLazyCat> saml: Wait next HP release! 
03:44:07 <saml> oh i see
03:44:11 * saml uninstalls
03:44:31 <saml> is t here a way to use HP "portable" way?  without root access
03:52:55 <ivanm> saml: install it into your user directory
03:54:17 <saml> ivanm, thanks.   i'm building from source
03:54:21 <saml> HP that is
03:54:34 <plopez> hi! i want to modify an application in java, so that it adds some custom code at the beginning of the Swing GUI handlers
03:54:38 <saml> does ghc do multicore building?
03:54:44 <saml> like make -j 12
03:54:51 <plopez> my idea is to use a lexer/parser, but maybe it's not the best
03:55:10 <saml> plopez, maybe use cpp?  C pre processor
03:55:10 <plopez> does anybody come up with a better idea?
03:55:16 <saml> or m4 or something along those lines?
03:55:31 <plopez> it would be better in haskell, but i can try
03:58:26 <plopez> thanks, saml
03:59:12 <saml> or did you want to generate java code from  haskell?
03:59:16 <saml> DO IT !
03:59:23 <saml> Language.Java.CodeGen
03:59:49 <companion_cube> oO
04:00:15 <saml> is yesod better than snap?
04:05:06 <haskellnoob> I have two lists of numbers, named divisors and inputNumbers . I want to construct a list of all the elements of inputNumbers which are _not_ divisible by some element of divisors. I can think of one way of doing this, by explicitly recursing over divisors. Is there an idiom for doing this? Something like a "filter with recursion"?
04:10:02 <saml> hey can i install haskell platform without opengl and stuff?
04:15:24 <pastorn> saml: install only GHC?
04:15:43 <pastorn> saml: then get any extra packages with cabal-install
04:15:52 <saml> can cabal-install. thanks. HP sucks lol
04:16:45 <plopez> (thanks again, saml, but i did not want to generate java code from haskell, i'm checking m4 now)
04:17:34 <saml> why not ship cabal-install along with ghc? it would be nice
04:17:50 <saml> i mean as vanilla binary release
04:18:13 <saml> merge both projects!
04:49:07 <Garfunkel> how does readLn differ from getLine ?
04:49:17 <sipa> :t readLn
04:49:18 <lambdabot> forall a. (Read a) => IO a
04:49:26 <sipa> :t getLine
04:49:27 <lambdabot> IO String
04:49:42 <Garfunkel> so when would you use readLn?
04:49:44 <sipa> can you derive the difference by just looking at the types?
04:49:48 <xarch> hi
04:50:00 <xarch> is there a good way to embed prolog in Haskell?
04:50:03 <Garfunkel> I cn tell the difference
04:50:15 <xarch> or should I implement one?
04:50:43 <mauke> @src readLn
04:50:43 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
04:50:49 <mauke> @src readIO
04:50:49 <lambdabot> Source not found. Wrong!  You cheating scum!
04:51:03 <Garfunkel> :t readIO
04:51:04 <lambdabot> forall a. (Read a) => String -> IO a
04:51:18 <sipa> that's just read lifted to the IO monad
04:51:45 <mauke> not quite
04:51:52 <mauke> it also raises read errors as IO exceptions
04:51:54 <hvr> what's wrong with http://hpaste.org/43995/nonobvious_nonexhaustivepat ?
04:51:59 <sipa> ah i see
04:52:03 <sipa> good to know
04:52:58 <zygoloid> hvr: change your last guard to 'otherwise'
04:54:19 <hvr> zygoloid: thx... so it's just ghc not being smart enough?
04:54:45 <mauke> hvr: how do you know i0 /= i1 will always be true?
04:55:09 <hvr> can't ghc prove that (i0 == i1 || i0 /= i1) is always true?
04:55:12 <sipa> no
04:55:15 <sipa> because it isn't
04:55:20 <zygoloid> hvr: no. normEvs [(NaN, undefined), (NaN, undefined)] is not covered by your patterns.
04:55:22 <sipa> or at least isn't necessarily
04:55:50 <mauke> instance Eq LolWut where { _ == _ = False; _ /= _ = False }
04:56:05 <hvr> ic :-)
04:56:24 <zygoloid> hmm, ghci says  nan /= _ = True
04:56:42 <frerich> sipa: but ghc is aware of the Eq instance being used, since it knows the types of i0 and i1, no?
04:57:05 <mauke> it doesn't, actually
05:01:08 <frerich> mauka: Sorry, I'm rather new at Haskell so I guess my ignorance is showing - it doesn't know what Eq instance is being used, or it doesn't know the types if i0 and i1 - or both?
05:01:31 <frerich> I guess it only knows the type when evaluating the expression - so it can only be proved at that moment, too?
05:01:58 <sipa> there are cases where the compiler knows the concrete types
05:02:22 <sipa> but still the actual definition of the relevant instance can be in another module
05:02:59 <frerich> sipa: I see, so the implementation of the relevant instance might be opaque to the compiler.
05:04:25 <frerich> I wonder whether, for a similiar reason, something like 'length([1..]) > 3' won't terminate.
05:04:27 <Toxaris_> frerich: even with all code known, it is still hard to figure out what something evaluates too. The only general way to do that, is to actually evaluate it. Unfortunately, this might not terminate :(
05:06:29 <Toxaris_> frerich: it is possible to implement numbers and write Ord and Num instances so that '(genericLength [1..] > 3) == True'
05:07:12 <Toxaris_> frerich: But while that would be cool for this kind of code, it is rather slow for most other kinds of code, so it is rather a bad idea.
05:07:59 <sipa> the basic problem is that integers as a primitive type are not as lazy as they could be
05:09:24 <mauke> frerich: doesn't your irc client have tab completion?
05:09:51 <frerich> mauke: Euhm, it does - but why do you ask?
05:10:14 * frerich notes it's a pain to use though, since it actually only pops up a listbox in which suggested completions have to be confirmed with <Space>
05:12:46 <mauke> frerich: because you misspelled my name, so at first I didn't notice you were talking to me :-)
05:13:10 <frerich> mauke: Oooops. Sorry. Glad that you still noticed it though. :-)
05:15:37 <artagnon> What's wrong with http://pastie.org/1566335 -- Why the restriction on m being []?
05:17:55 <mauke> the problem is that you can't write a function of type (Monad m) => m a -> a; it's impossible
05:18:09 <artagnon> mauke: Why not?
05:18:42 <artagnon> ie. What is conceptually wrong with it?
05:18:46 <mauke> artagnon: because the available functions don't allow you to reach that type, no matter how you combine them
05:18:51 <mauke> oh, conceptually
05:18:55 * artagnon nods
05:19:07 <mauke> artagnon: 'm a' doesn't have anything to do with 'a'
05:19:18 <mauke> well, it usually does, but not necessarily
05:19:24 <artagnon> Right, so?
05:19:30 <sipa> you can simplify it
05:19:34 <mauke> so where are you going to get an 'a' from?
05:19:45 <sipa> write me a function (Maybe a -> a)
05:19:59 <sipa> if it's a Just x, it's trivial
05:20:01 <mauke> data Hole a = Hole
05:20:01 <artagnon> What is fromJust?
05:20:09 <mauke> write me a function Hole a -> a
05:20:14 <ceii> fromJust raises a runtime error on Nothing
05:21:07 <ceii> but the bigger problem is, fromJust uses operations that are specific to Maybe
05:21:35 <ceii> you couldn't do the same with only what the Monad  class provides
05:21:36 <artagnon> mauke: Hm, I'm not sure what that means in your example.
05:21:38 * artagnon thinks
05:21:44 <sipa> but even for Maybe a you are unable to turn it into an a, in the general case
05:22:21 <artagnon> sipa: Ok, assuming that I have a way to handle the other states that IO a can represent (like exceptions), can I convert it?
05:22:37 <sipa> convert what?
05:22:42 <mauke> potentially confusing reuse of names; let's use "data Hole a = H" instead
05:23:05 <mauke> artagnon: similar to 'Hole a', 'IO a' doesn't contain an 'a' either
05:23:14 <mauke> there's nothing to "extract" here
05:23:17 <artagnon> I see :)
05:23:29 <sipa> a monad is not just a container of data
05:24:16 <artagnon> sipa: It's just one of the interpretations, right?
05:24:31 <artagnon> So, can I handle it in more specific cases?
05:24:45 * Dae_ thinks there are more interpreations of monads than of quantum mechanics
05:24:53 * artagnon smiles
05:24:56 <sipa> artagnon: for the Identity monad it's possible :)
05:25:14 <artagnon> So Maybe is actually a "container" monad?
05:25:28 <sipa> that's a possible interpretation
05:26:05 <artagnon> Okay -- what about this? IO String -> String.
05:26:13 <artagnon> I know that the IO contains a String in this case.
05:26:27 <artagnon> ie. I know for a fact that there is some information to be extracted.
05:26:31 <sipa> it does not contain a String
05:26:36 <artagnon> It doesn't?
05:26:47 <artagnon> What does moo <- getLine do then?
05:26:49 <sipa> it is some representation of a computation that produces a string
05:27:05 <fryguybob> artagnon: Think of it as a promise to compute a string.
05:27:12 <artagnon> Hm.
05:27:35 <artagnon> So where can I go from there?
05:27:38 <sipa> "moo <- getLine; putStrLn moo" is syntactic sugar for "getLine >>= \moo -> putStrLn moo"
05:27:39 <fryguybob> artagnon: In the case of IO it may or may not be the same string.
05:27:56 <fryguybob> artagnon: IO String -> String would break referential transparency.
05:28:10 <sipa> which you can see as a getLine with a callback attached to it, which will print out the read string again
05:28:12 <artagnon> sipa: Right. So what's the type signature of moo here?
05:28:20 <sipa> String
05:28:22 <artagnon> Er, the lambda function with argument moo
05:28:38 <sipa> but the (\moo -> putStrLn moo) has type String -> IO ()
05:28:46 <sipa> and that's all you can do with monads
05:28:53 <sipa> combine them into bigger monads
05:29:11 <artagnon> sipa: I see. That's interesting.
05:29:23 <sipa> so once it's IO, it is what you can call an imperative program
05:29:28 <artagnon> fryguybob: Where can I read more about referential transparency?
05:29:40 <sipa> you can combine pieces of imperative code together into bigger pieces
05:29:48 <sipa> but you can't ask them to execute in pure code
05:30:30 <artagnon> sipa: I can have pure functions operating on it though, right? Like pureChars <- getLine; print $ textTransform pureChars
05:30:43 <artagnon> Here textTransform :: [Char] -> [Char]
05:30:45 <artagnon> A pure function.
05:30:48 <sipa> absolutelyt
05:31:03 <sipa> but only when reusing it in an action
05:31:23 <fryguybob> artagnon: http://en.wikipedia.org/wiki/Referential_transparency_(computer_science)
05:31:25 <sipa> as i've said, it's like a callback
05:31:38 <hpc> there's an exception to the "only making a bigger action" rule
05:31:40 <hpc> :t join
05:31:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:31:58 <sipa> @src join
05:31:58 <lambdabot> join x =  x >>= id
05:32:00 <hpc> join takes a nested monad and squishes it into one layer
05:32:04 <artagnon> fryguybob: Anything more specific to referential transparency in Haskell?
05:32:08 <hpc> so it concatenates lists, etc
05:32:26 <fryguybob> artagnon: Not that I know of.  Others might have better links.
05:32:35 <artagnon> fryguybob: Ok, cool. Thanks anyway :)
05:32:41 <artagnon> So where does "join" fit into all this?
05:32:55 <artagnon> How does seem to unwrap things?
05:33:07 <hpc> artagnon: the trick is that it's still inside a monad at the end
05:33:26 <hpc> so consider this version of join
05:33:28 <artagnon> Ah.
05:33:33 <artagnon> I can't have m a -> m
05:33:38 <artagnon> Just m m a -> a
05:33:41 <sipa> no
05:33:41 <hpc> join x = do {v <- x; v}
05:33:53 <sipa> you can't have m a -> a, but you can have m (m a) -> m a
05:34:05 <sipa> "m a -> m" isn't meaningful
05:34:09 <hpc> so in the definition i gave above
05:34:12 <artagnon> Sorry, that was a typo.
05:34:14 <hpc> x :: m (m a)
05:34:32 <hpc> when we pull a value out of it like that in a do block, v :: theInside
05:34:35 <hpc> v :: m a
05:34:41 <hpc> because v is still an action in m
05:34:47 <hpc> we can perform it in the do block
05:34:53 <artagnon> hpc: Although it's not explicitly mentioned, the do block implicitly means that it returns a monad?
05:35:01 <hpc> so the v at the end makes join return an m a
05:35:07 <hpc> artagnon: yeah
05:35:12 * artagnon smiles
05:35:16 <artagnon> I think I got it finally :)
05:35:22 <artagnon> One last question: fromJust.
05:35:24 <artagnon> :t fromJust
05:35:25 <lambdabot> forall a. Maybe a -> a
05:35:25 <sipa> a do block is syntactic sugar for writing monadic actions
05:35:43 <hpc> fromJust (Just a) = a
05:35:50 <hpc> fromJust Nothing = error "oh crap!"
05:36:06 <hpc> > fromJust Nothing
05:36:07 <lambdabot>   *Exception: Maybe.fromJust: Nothing
05:36:19 <artagnon> hpc: It pattern matches.
05:36:24 <hpc> yep
05:36:32 <sipa> artagnon: the trick here is that error can have any type
05:36:36 <artagnon> ... so there are more monads for which I can use this trick?
05:36:43 <hpc> there's no polymorphic way to pull things out of monads
05:36:54 <sipa> and if you use that, you can in fact write something of type m a -> a
05:37:00 <sipa> unMonad :: m a -> a
05:37:03 <hpc> so fromJust only works on Maybe
05:37:08 <sipa> unMonad _ = error "gotcha!"
05:37:08 <hpc> head only works on []
05:37:17 <fryguybob> artagnon: fromJust it has nothing to do with the monad instance for Maybe
05:37:18 <hpc> fromLeft only works on Either, etc
05:37:19 <sipa> but that's not "extracting"
05:37:39 <artagnon> fryguybob: How so?
05:37:51 <sipa> he's right
05:37:58 <artagnon> sipa: What should I replace "extracting" with? How do I best describe this behavior?
05:38:07 <fryguybob> artagnon: You can write fromJust and not have an instance for the Monad typeclass for Maybe.
05:38:09 <artagnon> It's pattern matching and returning a pure value in one case.
05:38:27 <mauke> artagnon: btw, do you happen to know javascript?
05:38:37 <artagnon> mauke: Yes, why?
05:38:44 <artagnon> Not very well though.
05:38:51 <mauke> artagnon: how do you sleep() in javascript?
05:39:14 * artagnon thinks
05:39:27 <hpc> setTimeout(int) iirc
05:39:49 <artagnon> I don't think it's possible to just hang in mid-air.
05:39:54 <mauke> hpc: setTimeout takes two arguments
05:40:02 <artagnon> It's possible to make a closure though.
05:40:02 <flux> it is, infact, by busy looping. but don't :)
05:40:10 <sipa> artagnon: bingo
05:40:14 * Maxdamantus wonders whether when he needs uint32_t[]s in the FFI, he should make a simple uint32_t array wrapper interface in C, or hope that unsigned int is equivalent to uint32_t.
05:40:43 <mauke> artagnon: the answer is: you can't "sleep" directly; you wrap the entire rest of the code and pass it to setTimeout
05:40:50 <mauke> er, wrap it in a function
05:40:52 <Maxdamantus> (and use Ptr CUint, allocArray, ..)
05:41:00 <artagnon> Right.
05:41:09 <mauke> and this is how you get String from IO String
05:41:15 <artagnon> I'm not sure I understand what the ramifications of that are though at a conceptual level.
05:41:18 <artagnon> Oh!
05:41:30 <mauke> you can't do it directly; instead you write a callback and attach yourself to the IO String action
05:41:31 <Dae_> Maxdamantus, sounds dangerous?
05:41:40 <Maxdamantus> It does.
05:41:50 <mauke> not entirely unlike async XmlHttpRequest, actually
05:41:58 <artagnon> mauke: Awesome! I think I get it now :D
05:42:01 <Maxdamantus> Well, the first bit doesn't .. making the uint32_t array wrapper in C.
05:42:16 * Maxdamantus wonders why a library would use uint32_t.
05:42:19 <Dae_> nope, that sounds ok
05:42:32 <Dae_> if it's very important that it's 32bits long?
05:42:41 * Dae_ has written a library using  uint32_t
05:42:53 <artagnon> Maxdamantus: ... because it probably relies on that for some magic.
05:42:54 <Maxdamantus> Hm. So there's no included uint32_t C type somewhere in GHC? It is specified in POSIX at least.
05:43:06 <artagnon> Example: See Fibonacci Hashing Function.
05:43:14 <sipa> artagnon: ok, now that you get it, there is one trick which actually does allow you to do IO a -> a, but don't use it unless you really need it and understand what you're doing
05:43:19 <artagnon> So many examples where fixed/ known word sizes are required.
05:43:32 <artagnon> sipa: Ok, cool :)
05:43:35 <sipa> unsafePerformIO
05:43:43 <artagnon> I've earned the knowledge now :D
05:43:51 <sipa> the name is warning though
05:44:03 <artagnon> "unsafe". Yes :)
05:44:07 <Dae_> Maxdamantus, remember that the FFI demon needs a sacrifice before doing stuff like this. It sound pretty simple, so I think a goat might do
05:44:13 <artagnon> :t unsafePerformIO
05:44:14 <lambdabot> Not in scope: `unsafePerformIO'
05:44:24 <fryguybob> @hoogle unsafe
05:44:24 <lambdabot> Language.Haskell.TH unsafe :: Safety
05:44:25 <lambdabot> Language.Haskell.TH.Lib unsafe :: Safety
05:44:25 <lambdabot> module Data.ByteString.Unsafe
05:44:31 <Maxdamantus> Dae_: stuff like what?
05:44:31 <fryguybob> @hoogle unsafePerformIo
05:44:31 <lambdabot> Foreign unsafePerformIO :: IO a -> a
05:44:31 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
05:44:53 <Dae_> Maxdamantus, well... anything really ;)
05:45:10 <Maxdamantus> Heh.
05:45:41 <artagnon> Well, that seals it then. Thanks for everything, everyone.
05:45:54 <Dae_> Speaking of FFI.... anyone has any experience with using it with Fortran?
05:46:18 <artagnon> The Javascript analogy REALLY helped :)
05:46:25 <mauke> Maxdamantus: I thought it would be Word32
05:46:40 * artagnon goes off to get some dinner
05:46:59 <mauke> nice; I think this is the first time I've successfully explained IO with javascript
05:47:04 <Maxdamantus> mauke: hm .. perhaps .. didn't realise you'd be able to use the Word* types with FFI.
05:47:28 <sipa> mauke: i think you should write a monad tutorial using it!
05:47:36 <Maxdamantus> I reckon it'd probably be safe enough to assume it is, if you can use it like that.
05:48:08 <Maxdamantus> Since uint32_t would be the most optimal C type for operating on a Word32.
05:48:35 <Maxdamantus> (well, not neccessarily, meh I dunno)
05:48:50 <Maxdamantus> It'd definitely be the most optimal space-wise.
05:51:06 * Maxdamantus wonders how architecture-specific the FFI is specifically.
05:51:19 <Maxdamantus> or C-platform-specific.
05:51:59 <Maxdamantus> uint32_t isn't required to exist in C, and it can only ever exist if CHAR_BIT divides into 32.
05:52:30 <flux> "only"
05:52:42 <Maxdamantus> only.
05:53:18 <flux> does ghc run on any such platform?
05:53:24 <Maxdamantus> It just so happens that CHAR_BIT is 8 on many platforms .. including all POSIX ones.
05:53:30 <flux> or any implementation of haskell whatsoever
05:53:40 <Maxdamantus> (and POSIX requires uint32_t to exist too anyway)
05:54:52 <Dae_> flux, doesn't FFI require ghc?
05:55:09 <Maxdamantus> FFI is meant to be part of Haskell 2010
05:55:15 <zygoloid> no, other haskell implementations do ffi too
05:56:19 <Dae_> ohh, ok
06:08:30 <cizra> What's the easiest way to download a web page? Must support SSL. The result could either go into a string or a file, I don't care much.
06:09:09 <silver> curl?
06:09:16 <zygoloid> wget?
06:10:24 <cizra> I tried http-wget, but it just .. hangs. Wireshark says it created some traffic, though.
06:10:29 <Maxdamantus> Firefox?
06:11:06 * sipa points at channel name
06:11:35 <cizra> um, I need a Haskell library (=
06:12:03 <cizra> download-curl looks easy enough
06:12:03 <dankna> HTTP-4000 module is what cabal-install uses
06:12:18 <dankna> (hence, even if it might be ugly, at least we know it works)
06:12:48 <dankna> oh, but I don't know whether it supports ssl.
06:13:00 <cizra> Lemme try download-curl.
06:13:51 <Younder> Try some of this for inspiration by two of the greatest perfectinit os all times: http://www.youtube.com/watch?v=Zd_oIFy1mxM&feature=related
06:14:15 <Younder> perfectionists
06:15:31 <cizra> Yay! Seems download-curl works.
06:15:43 <dankna> excellent
06:16:56 <Younder> I love Bach's oragan sonata's.
06:17:54 <Younder> I choose to share it because it is so close to mathematics.My second love.
06:18:42 <Younder> The production, by the way,s possible the best ever.
06:18:50 <Younder> play loud
06:20:39 <ddddddd> hello
06:20:48 <Younder> hi
06:21:41 <ddddddd> my first with haskell
06:22:11 <ddddddd> What is the difference hashkell and lisp  
06:22:32 <mauke> ddddddd: what's lisp?
06:23:09 <companion_cube> ddddddd, they are different languages
06:23:28 <ddddddd> haskell
06:23:45 <ddddddd> fp language
06:24:09 <Younder> mauke, You might want to ask that at #lisp. But basically it s a LISt Processing languaguage. Develeopedin the 1950's bu John Mc Carthy, Google this by the way.
06:24:24 <mauke> Younder: but I asked ddddddd 
06:24:30 <Maxdamantus> I don't think Lisp is really a language.
06:24:38 <dankna> I believe that was Mauke's way of refusing to answer an ill-considered question
06:25:08 <mauke> by presenting his idea of lisp I might actually come up with a useful comparison to haskell
06:25:19 <Younder> mauke, true, but I am the Lisp programmer. So  I cut in. 
06:25:31 <Maxdamantus> Which dialect of Lisp do you program in?
06:25:38 <mauke> otherwise I could just say the major difference is that haskell programs don't contain ")))))))))))"
06:25:42 <Younder> Common Lisp
06:25:50 <Maxdamantus> imo "Lisp programmer" is ambiguous as "assembly programmer"
06:26:00 <Maxdamantus> as ambiguous*
06:26:01 <mauke> or ... we don't have an uppercasing reader
06:26:07 <Younder> not even close
06:27:18 <Younder> I also program elisp and scheeme.
06:28:08 <Younder> LISP CAN BE NETERD IN LOWERCASE THESE DAYS (sorry for shouting)
06:28:24 <mauke> yes, because of the uppercasing reader :-(
06:28:40 <mauke> have I mentioned that CL is my mortal enemy?
06:29:28 <Younder> You can even make it case sensitive. (not recommended as it might break old libraries.(
06:29:39 <Younder> mauke, No explain..
06:31:20 <mauke> I think Lisp is an overhyped and overall pretty horrible language, so I like to rant about it at the slightest provocation
06:31:43 <mauke> this stems from my one attempt to learn Common Lisp
06:32:44 <Younder> I am currently prototyping  a Assembler in Common Lisp which I will later write in ML once the specs are clear. (build one to throw away.)
06:33:18 <dankna> I used CL (mostly OpenMCL and later SBCL) for about five years
06:33:26 <dankna> I liked it at the time, but Haskell offers huge benefits
06:33:38 <dankna> if my program compiles with ghc, it probably does something pretty similar to what I intended :)
06:34:05 <Younder> mauke, Well It took me 10 years to learn to use Lisp to my advantage. Then again I could say the same about C++.
06:34:24 <Younder> C++ then Lisp..
06:34:24 <dankna> I do consider CL to be a language that there are things we could learn from.  The object system is great, although it wouldn't be appropriate for Haskell.  And the exceptions system is something we should imitate someday.
06:34:58 <dankna> CL is the only language I've seen where multiple inheritance is occasionally a valid design decision
06:35:12 <Maxdamantus> :t first
06:35:13 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
06:35:16 <Younder> Yes. The exception system is great.
06:35:21 <mauke> Younder: I was hugely disappointed because CL seemed like a badly designed Perl
06:35:27 <revenantphx> Quick question, if I'm trying to represent an AST with an ADT
06:35:27 <revenantphx> https://gist.github.com/827615
06:35:38 <mauke> Younder: apart from the macro system, of course
06:35:40 <Younder> mauke, It is NOTHING like Perl
06:35:44 <mauke> Younder: bullshit
06:35:45 <revenantphx> Notice line 8 doesn't work, since I'm using data constructor instead of type constructor...
06:35:47 <mauke> I know Perl
06:35:53 <revenantphx> Is there any way to constrain it to a prototypeAST?
06:35:57 <Younder> mauke, So do I.
06:36:05 <revenantphx> Or should I just do the constraints in the evaluation or parsing?
06:36:05 <dankna> revenantphx, yes, you want GADTs
06:36:15 <dankna> revenantphx, but they do make things more complicated
06:36:16 <revenantphx> sounds fancy.
06:36:21 <dankna> generalized ADTs :)
06:36:32 <mauke> Younder: so ... how about special variables and lexical scopes and function/value cells?
06:36:39 <revenantphx> I'll take a look at the wikibooks/haskell page on them
06:36:42 <revenantphx> thanks, dankna
06:36:44 <dankna> okay, sure thing
06:36:54 <revenantphx> I'm going to rewrite the LLVM "Kaleidoscope" tutorial for Haskell.
06:36:58 <dankna> oh cool!
06:37:08 <Younder> mauke, The only thing they have in common is that they don't have static types.
06:37:15 <mauke> Younder: wrong
06:37:47 <mauke> see the list above
06:38:11 <dankna> the most fundamental difference is that Perl is ad-hoc whereas CL has a well-written standard
06:38:11 <mauke> oh, and multiple values correspond to Perl lists if you squint very hard
06:38:25 <mauke> dankna: the HyperSpec isn't exactly "well-written"
06:38:29 <dankna> I find it so
06:38:35 <mauke> give me the Haskell Report any day
06:38:41 <dankna> well, I like the Haskell Report too :)
06:38:43 <dankna> I can like both :)
06:39:01 <dankna> I am many, I contain multitudes
06:39:46 <mauke> I think I gave up somewhere around trying to understand the difference between DECLARE/DECLAIM/PROCLAIM
06:39:52 <Younder> Lexical scope is common among programming languages. Lisp first had dynamic (special) variables. In scheme and later in CL lexical scope was introduced.
06:40:05 <dankna> oh that's simple... it's just.... *cough* yeah, anyway, I agree, that's a sticky bit
06:40:16 <mauke> Younder: just like Perl (which introduced lexical scope in Perl5)
06:40:49 <Younder> mauke, bullshit
06:40:55 <mauke> [citation needed]
06:41:28 <mauke> or rather, which part do you agree with? that Perl only had dynamic variables in version 4?
06:41:31 <mauke> er, disagree
06:41:43 <hvr> is there a commonly used unicode symbol for '>>=' or '=<<'?
06:42:02 <dankna> hvr: not that I'm aware of but somebody did make a Unicode version of the prelude, it's on hackage somewhere
06:43:07 <hvr> thx for the pointer... http://hackage.haskell.org/package/base-unicode-symbols looks interesting
06:43:14 <dankna> np
06:43:20 <Younder> mauke, There is nothing wrong with dynamic variables. Provided you declare them at the same time you assign them a value. That is what Lisp got right and Perl got wrong. 
06:43:42 <mauke> what
06:43:47 <mauke> lisp doesn't even have "use strict"
06:43:54 <dankna> I do think dynamics are good for what they're meant to be, which is a migration path forward from globals
06:44:09 <mauke> dynamics are globals (in my world view)
06:44:22 <dankna> the reason they're distinct is that dynamics can shadow other dynamics
06:44:34 <dankna> so you can always override them in a given context
06:44:48 <Younder> mauke, Default values and automatic conversions are what make Perl unsafe. And yes CL is per default 'strict'
06:44:54 <zygoloid> is lisp versus perl really a discussion for #haskell?
06:44:57 <mauke> all those cryptic interpreter variables, like $/, $\, $+? they're perl's "special variables"
06:45:01 <dankna> it's more of a discussion for -blah I guess
06:45:12 <sipa> is there a #flamewar ?
06:45:21 <mauke> dankna: agreed
06:45:37 <zygoloid> at least tell me where you're going, i've not seen this flamewar before! :)
06:45:42 <ezyang> #haskell-blah folks 
06:45:49 <Younder> sorry, yes this is a flame-war. I will stop.
06:45:57 <fram> hi, I'm developing a toy window manager in haskell for learning purposes (and cuz I love xmonad). The core of the program is a loop that handles X events. I'd like to be able to send commands to my program to inspect some internal state or run specific actions. What do you think would be the best / most elegant way to communicate with the program? Reading commands from a file, having a prompt (but it would mean a separate thread)... ?
06:46:06 <dankna> well, it's a flamewar between educated people, so it's interesting in its way
06:46:13 <dankna> but it's off-topic in this particular channel
06:46:29 <mauke> Younder: so you're not coming?
06:47:25 <dankna> fram: Unix-domain socket?  TCP socket (but security implications)?
06:48:53 <fram> I'll check that out thanks!
06:49:13 <dankna> sure
06:57:16 <kulakowski> CJ#agda
06:59:25 <rumbold> ghc just said "compilation IS NOT required"... what does that mean?
07:00:34 <dankna> that your source file is older than your object/binary file
07:00:36 <Maxdamantus> Something like, the current compiler output is newer than the sources.
07:01:06 <rumbold> does that mean it skipped the compilation? because i just activated -O to see if it goes faster
07:01:31 <dankna> yes it does.  remove the stale object file if you want that.
07:03:11 <rumbold> huh, went from 100s to 15s... and the result looks different (im writing a raytracer)
07:03:55 <dankna> result shouldn't look different, hm
07:04:20 <quicksilver> well some floating point optimisations change results 'slightly'
07:04:25 <quicksilver> can be critical to a raytracer
07:04:52 <dankna> ah - yes, there's a potential issue with 80-bit versus 64-bit doubles, in fact
07:05:01 <rumbold> my planes are still buggy, getting lots of funky stuff there. i think there are lots of NaNs and infs involved :D
07:05:06 <Dae_> 80bit doubles??
07:05:16 <mm_freak> Dae_: internal representation
07:05:20 <mm_freak> in the processor
07:05:29 <quicksilver> yeah, if there are lots of NaN and Infs you might be subject to 80/64 bit bugs.
07:05:31 <dankna> affects x86 only
07:05:47 <Zao> dankna: x87, you mean? :D
07:05:51 * Dae_ thought doubles were 64bit on the processor too
07:05:53 <ClaudiusMaximus> rumbold: ghc's -fforce-recomp is useful there
07:05:55 <dankna> er, yes, I suppose I do
07:06:05 <dankna> x87 is the fpu?
07:06:07 <quicksilver> dankna: the x87 is a 80bit FPU.
07:06:10 <dankna> gotcha
07:06:20 <Jafet> If the result looks different, it's a bug in your program! Even if it's the fault of the computer.
07:06:24 <quicksilver> modern (post P-IV) CPUs also have 64 bit floating on the main chip
07:06:28 <Zao> Dae_: The FPU registers are wider than a double, so if you don't spill, you get bonus precision.
07:06:29 <mm_freak> technically x87 is long gone…  it's part of the x86 now
07:06:30 <rumbold> thanks, ClaudiusMaximus
07:06:54 <Zao> I'm of course referring to the instruction set, not distinct chips.
07:07:14 <Dae_> Zao, hmm... ok. Would this also apply to GPU calculations?
07:07:17 <mm_freak> those are x86 instructions =)
07:07:30 <dankna> no, the GPU has its own thing
07:07:41 <quicksilver> GPUs are 32-bit.
07:07:52 <quicksilver> well, a few very high-end ones have some 64-bit math
07:07:57 <quicksilver> but the bulk of them are 32-bit.
07:07:58 <Zao> It would not affect SSE2 and up either, I believe.
07:08:14 <ClaudiusMaximus> -fno-excess-precision should try to avoid the bonus precision
07:08:14 <Jafet> quicksilver: that statement is five minutes obsolete!
07:08:15 <quicksilver> Zao: yeah, that's what my 'P-IV and later' comment refers to.
07:08:26 <mm_freak> anyway, there is a switch to force GHC to use 64 bit doubles, though that's not recommended
07:08:31 <mm_freak> slower and less precision
07:08:46 <quicksilver> the x86_64 port only uses the SSE2 stuff.
07:08:47 <mm_freak> yes, ClaudiusMaximus mentioned it
07:08:51 <Dae_> quicksilver, that's what I thought.
07:09:15 <Dae_> but... why not just store the damn things as 80bits then? keep the extra precision
07:09:15 <quicksilver> I think I heard somewhere that GHC has been changed (very recently) to use SSE2 in preference to x87 as well in its native codegen
07:09:30 <quicksilver> but I wasn't able to confirm that.
07:09:39 <Zao> Dae_: Some algorithms assume a fixed known precision.
07:09:48 <Zao> Dae_: See the recent PHP infinite loop bug.
07:10:21 <quicksilver> are there even opcodes to store 80bit floats in memory?
07:10:23 <ClaudiusMaximus> the bonus precision isn't always good - because you could have something like "x == 1" -> False with 80 bits, but later "x == 1" -> True with 64 bits
07:10:33 <mm_freak> PHP is broken in so many other ways, the loop bug doesn't really make a big deal =)
07:10:48 <Jafet> Dae: because Intel didn't write the floating point standard. Although they probably tried to.
07:11:19 <Zao> mm_freak: Considering how you can have 'long double', there's most probably a way.
07:11:29 <Zao> Err, quicksilver ^
07:12:14 <erwin234> Hello everyone
07:12:16 <Jafet> Also, it's technically 79-bit
07:13:05 <Dae_> hmmm... so in fact a 64bit GPU calculation will be less accurate than a normal CPU one?
07:13:34 <sipa> possibly
07:14:04 <erwin234> I am a beginner and I have difficulty to understand why it's not possible to perform a foldl on infinite lists, whereas a foldr is possible
07:14:40 <sipa> a list [1,2,3,...] is actually 1:(2:(3:(4:...)))
07:15:00 <sipa> if you want to do an operation that first combines the last two elements
07:15:02 <Jafet> That is assured, seeing as GPUs often don't adhere to the arithmetic ulps required by IEEE
07:15:04 <mm_freak> erwin234: look at the defintion of foldl
07:15:05 <sipa> which is what foldl does
07:15:06 <mm_freak> @src foldl
07:15:07 <lambdabot> foldl f z []     = z
07:15:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:15:17 * Dae_ frequently hits his head on the double precision barrier and wonders if this has any significance
07:15:19 <sipa> wait
07:15:29 <erwin234> ok
07:15:34 <mm_freak> erwin234: as you see, foldl cannot give you a result without evaluating the whole list up to []
07:15:45 <mm_freak> as sipa said, a list is x:y:z:…:[]
07:15:57 <mm_freak> an infinite list never reaches this []
07:15:57 <zenzike> @src foldr
07:15:57 <lambdabot> foldr f z []     = z
07:15:58 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:16:19 <udoprog> Just wondering, are there any de facto library for (typed) ipc communication in Haskell? or network for that matter?
07:16:23 <erwin234> mm_freak: that's what I read to, but it seems the opposite when I try to understand!
07:16:38 <zenzike> if f can return a result without looking at its second argument, you won't need to evaulate the rest of xs
07:16:43 <mm_freak> erwin234: take a piece of paper and do the evaluation manually…  it helps
07:16:50 <Jafet> udoprog: read and show?
07:17:07 <erwin234> mm_freak : I'll try again, taking the definition provided by the bot
07:17:15 <mm_freak> erwin234: the result of the foldl is the result of the recursive foldl call, which is the last operation in foldl (hence it's tail-recursive)
07:17:29 <Jafet> > foldl f 0 [1,2,3]
07:17:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:17:30 <lambdabot>    `GHC.Num.Num a'
07:17:30 <lambdabot>      ari...
07:17:32 <mm_freak> erwin234: the result of that recursive foldl call is again dependent on another recursive call
07:17:37 <Jafet> > foldl f 0 [1,2,3] :: Expr
07:17:38 <lambdabot>   f (f (f 0 1) 2) 3
07:17:44 <mm_freak> since the [] case is never reached, you'll end up calling recursively forever
07:17:48 <mm_freak> without ever getting a result
07:18:03 <kniu> @hoogle NaN
07:18:03 <lambdabot> Prelude isNaN :: RealFloat a => a -> Bool
07:18:05 <erwin234> Thanks, I'm going to try and unroll that on a paper
07:18:11 <mm_freak> have fun =)
07:18:16 <Dae_> Jafet, I thought the difference between the GPU and IEEE floating points was that IEEE defines very clearly how things go wrong, whereas the GPU is more unreliable. But with similar accuracy from a user point of view
07:19:02 <mm_freak> udoprog: there are many libraries for network communication on hackage…  for inter-thread communication the base libraries work very well, but if you need more, you'll also find a lot of stuff on hackage
07:19:22 <mm_freak> i think there isn't so much sophisticated stuff for inter-process communication
07:19:32 <mm_freak> but again, look on hackage…  there are lots of libraries there
07:20:09 <udoprog> mm_freak: yeah, been browsing around a while, loads of stuff that has questionable maintenence and such, that's why I asked
07:20:43 <mm_freak> udoprog: not updated libraries aren't necessarily evil in haskell
07:21:04 <xiaoxiao> good evening
07:21:05 <mm_freak> look whether they have a maintainer and whether the last revision is newer than one or two years…  that should be enough
07:21:14 <mm_freak> hello xiaoxiao 
07:21:28 <xiaoxiao> hello mm_freak
07:22:22 <xiaoxiao> I have question
07:23:11 <udoprog> mm_freak: that makes sense, I was just hoping for a more ovious solution seeing that it's a pretty common problem - but thanks for the insight
07:23:42 <udoprog> I usually scope libraries by the amount of documentation available as well, most I'
07:23:47 <udoprog> ve found have been lacking
07:24:04 <mm_freak> udoprog: well, you won't suffer from lack of networking/concurrency libraries, but IPC isn't something done in regular haskell, unless you really need to communicate with a non-haskell program
07:25:08 <mm_freak> udoprog: yes, documentation is a good indicator, though most packages document themselves by the types they use, so often you find only short comments in the haddock docs
07:25:32 <xiaoxiao> hi ccasin
07:25:50 <mm_freak> xiaoxiao: don't wait, just ask ;)
07:25:56 <xiaoxiao> oh, ok
07:26:46 <xiaoxiao> re: comparing stuff in GHCI
07:26:58 <xiaoxiao> when comparing lists
07:26:58 * Maxdamantus wonders if xiaoxiao is that guy that made those stick figure animations.
07:27:13 <xiaoxiao> no, that's not me
07:27:31 <xiaoxiao> when comparing lists, does the GHCI only compare the head?
07:27:41 <ClaudiusMaximus> Dae_: "double precision barrier"? if that means you need more precision, you might like the bindings to libqd that i've been working on [/advert]
07:27:45 <mm_freak> xiaoxiao: no, the whole list
07:27:50 <mm_freak> > [1,1] == [1,2]
07:27:51 <lambdabot>   False
07:27:52 <cizra> I'm using AttoJSON. I deserialized a Google custom search API result into a JSValue tree. Now I want to get the array of search results out of it. Do I need to create a structure of Haskell types for that? Like [Map String (somethingelse)]
07:28:02 <Jafet> MOAR PRECISION
07:28:02 <xiaoxiao> let me try that
07:28:30 <xiaoxiao> yes, I get the same result
07:28:33 <Dae_> ClaudiusMaximus, I need more precision. Sadly I also need speed ;)
07:28:50 <xiaoxiao> but when using "<" or ">" it is odd
07:29:01 <ClaudiusMaximus> Dae_: hehe, yes - it's about 100x slower than double...
07:29:09 <mm_freak> cizra: pattern-match against the JSValue tree
07:29:35 <Jafet> Dae: no, your algorithm is just inferior
07:29:47 <Maxdamantus> > [[1,2] > [1,1], [2,1] > [1,2]]
07:29:48 <lambdabot>   [True,True]
07:30:09 <Dae_> ClaudiusMaximus, and this is stuff that easily has a couple of hours runtime already. I think the current fix is, like Jafet suggests, to improve the algorithm
07:30:10 <cizra> mm_freak: Can I make some kind of wildcard to discard noninteresting branches?
07:30:38 <Jafet> _ is the wildcard
07:31:05 <cizra> hm, yes
07:31:07 * cizra blushes
07:31:11 <xiaoxiao> ghci> [3,2,1] > [2,10,100]   True 
07:31:13 <Jafet> ViewPatterns is the wild wildcard
07:31:16 <xiaoxiao> how can it be?
07:31:17 <mm_freak> xiaoxiao: with (>) and (<) you're doing lexical string comparison…  given an Ord element type, (>) on a list of that type determines, which list comes first in the dictionary
07:31:29 <mm_freak> > "abc" < "def"
07:31:30 <lambdabot>   True
07:31:31 <xiaoxiao> en
07:31:34 <xiaoxiao> yes
07:31:38 <mm_freak> same for numbers
07:31:42 <Jafet> xiaoxiao: what do you expect < to mean for lists?
07:31:49 <xiaoxiao> but... 2 is less than 10
07:31:50 <mm_freak> > [0,1,2] < [5,4,3]
07:31:51 <lambdabot>   True
07:31:53 <xiaoxiao> and 1 is less than 100
07:32:21 <mm_freak> the first head is greater than the second head
07:32:28 <mm_freak> so the first list comes first in the dictionary
07:32:28 <zenzike> > [2] < [10]
07:32:29 <lambdabot>   True
07:32:31 <Dae_> Jafet, seriously though, sometimes there are problems where you need MOAR PRECISION for intermediate calculations, though not in the result
07:32:33 <zenzike> > [2] < [1,0]
07:32:34 <mm_freak> so you get True
07:32:35 <lambdabot>   False
07:32:46 <mm_freak> you're NOT comparing the greatest values
07:32:50 <Jafet> Dae: nope, you cleverly rearrange the intermediate calculations
07:33:35 <Maxdamantus> "1" < "100"
07:33:39 <Maxdamantus> > "1" < "100"
07:33:39 <lambdabot>   True
07:33:47 <Maxdamantus> > "foo" < "foobar"
07:33:48 <lambdabot>   True
07:33:51 <Maxdamantus> Makes sense.
07:34:06 <Jafet> > "2" < "100"
07:34:07 <lambdabot>   False
07:34:11 <Dae_> Jafet, not always possible in simulations. Though I admit it's possible far more often than people give it credit for
07:34:24 <mm_freak> xiaoxiao: if you were comparing the greatest values, then "cac" would come before "aea" in the dictionary
07:34:34 <xiaoxiao> I thought I was submitting two lists and it checks the 1st indexed element in the 1st list against the 1st in the 2nd list etc...
07:34:41 <mm_freak> yes
07:34:43 <mm_freak> it does
07:34:46 <xiaoxiao> ok, talking only of numbers
07:34:53 <Jafet> > pi :: CReal
07:34:54 <lambdabot>   3.1415926535897932384626433832795028841972
07:35:08 <mm_freak> if they are equal, then it compares the second elements, then the third, until one inequal pair is found
07:35:16 <xiaoxiao> in the case of [3,2,1] > [2,10,100] , how is 2 greater than 10 and 1 greater than 100?
07:35:27 <Maxdamantus> s/2$/1693993751058279/
07:35:30 <Jafet> > showCReal 100 pi
07:35:31 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
07:35:49 <mm_freak> xiaoxiao: the truth is already determined by comparing the heads
07:35:59 <mm_freak> 3 is greater than 2, so the first list is greater than the second
07:36:21 <xiaoxiao> oh...so.. it DOES only work off the head?
07:36:33 <xiaoxiao> i guess i dont know what lexicographical order is...
07:36:34 <ClaudiusMaximus> Jafet, Dae_ : a while ago i analysed the actual decay time of a recursive band-pass filter when implemented with 32bit float vs 64bit double http://markmail.org/download.xqy?id=ke7tvfn43emkr32b&number=2
07:36:40 <mm_freak> xiaoxiao: no, but the heads already determine your result, so the other elements are disregarded
07:36:50 <mm_freak> xiaoxiao: if the heads are equal, then the second elements are compared
07:37:05 <mm_freak> xiaoxiao: just think of dictionaries, but with numbers instead of characters
07:37:20 <mm_freak> > [0,1] > [0,2]
07:37:21 <lambdabot>   False
07:37:26 <xiaoxiao> yes, but the heads aren't equal in the case [3,2,1] > [2,10,100] 
07:37:34 <mm_freak> because [0,2] comes later in the dictionary (i.e. is greater)
07:37:54 <mm_freak> the heads are equal here, so the second elements (1,2) are compared
07:38:03 <mm_freak> in your list the heads are not equal, so they determine the result
07:38:03 <xiaoxiao> yes
07:38:12 <Bynbo7> xiaoxiao: in the dictionary, Apple comes before Banana right?
07:38:30 <xiaoxiao> but... shouldn't it then go on to check that the others are also not equal?
07:38:33 <Dae_> Jafet, sure. The solution so far has been using double doubles. But the performance hit is NASTY
07:38:44 <xiaoxiao> yes, apples before Bananas
07:38:51 <Dae_> ClaudiusMaximus, that's quite a difference
07:39:03 <Bynbo7> ok, Apples comes before bananas because A > B
07:39:06 <doserj> xiaoxiao: in short, order is defined by the first pair of non-equal elements
07:39:23 <Bynbo7> Apple comes before Application because e > i
07:39:34 <mm_freak> xiaoxiao: no, why…  if the first character of a word is already smaller than the first of another word, why would you compare the remaining characters?
07:39:36 <ion> >?
07:39:43 * Jafet pushes Bynbo7 into a sharp corner
07:39:48 <xiaoxiao> oh.... i think i get it
07:39:54 <Bynbo7> don't push me you jerk, I'm drunk!
07:40:00 <Bynbo7> it's my last night in tokyo!
07:40:07 <xiaoxiao> its as if its made the elements in the list into one big number
07:40:15 <Bynbo7> @src [] compare
07:40:16 <lambdabot> Source not found. Maybe you made a typo?
07:40:20 <Bynbo7> bah
07:41:30 <mm_freak> xiaoxiao: a word would be more appropriate
07:41:37 <mm_freak> you're comparing words
07:41:41 <xiaoxiao> ok
07:41:54 <Jafet> ClaudiusMaximus: was the 64-bit version correct?
07:41:57 <Bynbo7> the source for compare on lists is something like: compare (x:xs) (y:ys) = case compare x y of { GT -> GT; LT -> LT; EQ -> compare xs ys }
07:42:27 <Maxdamantus> > let lcomp (a:as) (b:bs) = if a == b then lcomp as bs else a > b in [lcomp "foo" "bar", lcomp "foo" "foobar", lcomp "abc" "abd"]
07:42:28 <lambdabot>   [True,*Exception: <interactive>:3:4-62: Non-exhaustive patterns in function...
07:42:34 <mm_freak> Bynbo7: just that this will result in a non-exhaustive pattern
07:42:35 <Bynbo7> hmm, ok, my drunk mind has realised that my >'s above should be <'s
07:42:37 <xiaoxiao> so i'm not really comparing individual elements in the lists, but rather, one list against the other list
07:42:50 <Bynbo7> mm_freak: i only wrote the important part
07:42:59 <Bynbo7> xiaoxiao: exactly
07:43:07 <xiaoxiao> ok, thanks all
07:43:14 <mm_freak> xiaoxiao: well, you are comparing individual elements, but your interpretation of this comparison may be different from what it really does
07:43:22 <Bynbo7> xiaoxiao: if you weren't, what order would [0,2] and [2,0] come in?
07:43:23 <ClaudiusMaximus> Jafet: well, more correct!
07:43:43 <Maxdamantus> > let lcomp _ [] = True; lcomp (a:as) (b:bs) = if a == b then lcomp as bs else a > b; lcomp _ _ = False; in [lcomp "foo" "bar", lcomp "foo" "foobar", lcomp "abc" "abd"]
07:43:44 <lambdabot>   [True,False,False]
07:44:05 <cizra> mm_freak, Jafet: There's a dictionary mapping string values to differently typed objects in the JSON. How to go around that? The data in it is not interesting, by the way
07:45:04 <mm_freak> cizra: oh, sorry, overlooked your question:  sure, wildcards are just variables (or _, if they are uninteresting)
07:45:09 <Jafet> cizra: go around... what?
07:45:10 <mm_freak> f x = …
07:45:16 <mm_freak> x is a wildcard, because it matches anything
07:45:48 <mm_freak> cizra: about mapping, just use regular Data.Map functions
07:46:58 <cizra> I have a map mapping some keys to strings, and some other keys to weird types -- how do I declare it?
07:47:04 <revenantphx> dankna: so, how exactly do I do this with GADT's https://gist.github.com/827615
07:47:04 * cizra is thoroughly confused
07:47:20 <mm_freak> cizra: you know how to use Maps, don't you?
07:47:22 <revenantphx> as I said before, the last line doesn't work since it doesn't recognize a data constructor as a type constructor
07:47:33 <Jafet> Well, you would make a type with alternatives for each of those JSON types.
07:47:49 <cizra> mm_freak: Well, I haven't used them much, but I'd hope I manage
07:47:52 <cizra> Jafet: ahh!
07:47:52 <Jafet> Or you would use the one already probably written for you in the JSON library
07:48:19 <xiaoxiao> 88
07:48:33 <mm_freak> cizra: http://hackage.haskell.org/packages/archive/containers/0.4.0.0/doc/html/Data-Map.html
07:48:39 <mm_freak> it's really simple
07:48:45 <mm_freak> the types tell almost the full story
07:48:53 <mm_freak> if not, read the function names in addition =)
07:49:42 <cizra> mm_freak: You can't do [(1, "the meaning of life"), (2, 42)]. But I think Jafet already suggested a good way.
07:49:55 <mm_freak> ah, yes, then listen to Jafet =)
07:50:19 <mm_freak> but there is actually really little reason to do that
07:50:34 <mm_freak> JSValue already does what you need, unless you need less obvious types
07:50:52 <mm_freak> note that each element of the map is another JSValue
07:50:54 <Jesin> hmm
07:51:10 <Jesin> do the lazy and strict versions of the State monad exhibit different semantics?
07:51:39 <Jafet> One is lazy and the other is... strict?
07:52:00 <Jesin> yeah, I'm just wondering about when they actually produce different results
07:52:07 <Jesin> I guess this would probably be an example?
07:52:41 <Jesin> do {put undefined; put "well-defined"; get}
07:52:49 <revenantphx> il bbl
07:53:12 <Jesin> I'll test that, I guess
07:54:45 <Jafet> It would
07:54:48 <cizra> mm_freak: This works: JSON.lookup (BS.pack "items") json
07:54:53 <cizra> mm_freak: oops, wrong window
07:55:19 <cizra> mm_freak: This works: JSON.lookup (BS.pack "stringkey") json :: Maybe String
07:55:33 <cizra> mm_freak: Notice that I have to provide a concrete type for it. No JSValues anywhere.
07:58:12 <Jafet> Actually, it wouldn't
08:01:20 <erwin234> mm_freak: I understand now the foldl/foldr issue. Especially, it is the fact that foldl is tail recursive that made me understand.
08:03:23 <dankna> revenantphx: sorry, still there?
08:04:16 <erwin234> mm_freak: for foldr, taking the "identity" transformation 'foldr (:) [] [1..]' it is clear that by looking at the definition, we get  1:(foldr (:) [] [2..])
08:04:51 <erwin234> mm_freak: so ghci can begin to display the infinite list. 
08:05:32 <erwin234> mm_freak: Thank you. I think I just need to train my brain to think recursively.
08:05:38 <erwin234> Bye!
08:07:54 <dankna> @tell revenantphx What GADTs let you do is give a separate type to each constructor, as in http://dankna.com/himitsu/GADTs.hs (please let me know when you've read this so I can delete the file)
08:07:54 <lambdabot> Consider it noted.
08:08:23 <Jafet> Jesin: there's a cute example involving lazy STRefs here http://okmij.org/ftp/Haskell/Fix.hs
08:08:34 <Jafet> I can't come up with an example for State though
08:08:53 <Jesin> hmm
08:09:00 <Jesin> I hope there is one, even if it's contrived
08:09:37 <Jesin> or, maybe the difference shows up with StateT InsertNonIdentityMonad
08:11:40 <Jafet> It's trivial to construct lazy space leaks, of course
08:12:05 <Jesin> yeah
08:12:25 <Jesin> because of the space leaks thing, I was just wondering
08:12:44 <Jesin> isn't the strict version of State almost always better?
08:13:11 <Jesin> so I was looking for a place where the strict version results in _|_ but lazy does not
08:13:16 <Jesin> as a counterexample
08:13:38 <ClaudiusMaximus> Jesin: maybe something like this?  Prelude Control.Monad.State.Lazy> runState (do { put undefined ; put 1 ; undefined ; put 2 ; get } :: State Int Int) 0
08:14:11 <rumbold> is control.paralell part normally installed when i have the haskell platform or do i have to install it myself?
08:14:22 <Jesin> hmm, I'll test that
08:14:51 <ClaudiusMaximus> Jesin: i tested it here, "works" with Lazy, but "undefined" with Strict
08:15:04 <ClaudiusMaximus> could probably be simplified ;)
08:17:08 <Jesin> hmm
08:17:34 <Jesin> also, would an alternate definition of put as
08:17:50 <Jesin> put x = state $ \s -> (s,x)
08:17:55 <Jesin> break anything?
08:18:13 <Jesin> well
08:18:23 <Jesin> it would make the name unsuitable
08:18:33 <Jesin> and it might break things that declare put's type signature
08:21:03 <Jafet> I expect that it's the strictness of State that matters
08:22:31 <Jafet> Or the strictness of runState -- either way, nothing that can be changed by redefining put
08:23:33 <Jesin> well, yeah, I know
08:24:05 <Jesin> the difference between Control.Monad.Trans.State.Lazy and Control.Monad.Trans.State.Strict
08:24:19 <Bynbo7> rumbold: it should be installed
08:24:46 <Jesin> is that Lazy uses ~ on a lot of its tuple matches
08:24:53 <Jesin> :p
08:25:05 <Jesin> their put definitions are the same
08:26:46 <Botje> [6~[6~[6~[6~usgh	 none :(
08:27:46 <Jesin> hmm
08:28:11 <Jesin> I don't suppose (<*>)/ap would ever get used much with State
08:28:28 <rumbold> i couldnt find it (possibly because i was spelling parallel wrong) so i just reinstalled it.
08:28:54 <rumbold> i must be doing this all wrong because i alwaus end u having to manually pass the paths to the .o-files to the linker
08:29:13 <aavogt> Jesin: parsers?
08:30:07 <aavogt> @src ReadP
08:30:07 <lambdabot> Source not found. There are some things that I just don't know.
08:30:30 <aww> dirty liar. Everything that's worth knowing, he knows.
08:30:52 <Jafet> @vixen do you know?
08:30:52 <lambdabot> yup, i know
08:32:04 <haskellnoob> If I have a predicate p, is there a way to express "filter (not p) xs" in a compact way? This doesn't work as it is because p is of type a -> Bool and "not" takes a Bool as argument.
08:32:22 <Jesin> filter (not . p) xs
08:32:37 <mauke> @src (.)
08:32:37 <lambdabot> (f . g) x = f (g x)
08:32:37 <lambdabot> NB: In lambdabot,  (.) = fmap
08:32:52 <haskellnoob> Jesin: Thank you.
08:33:05 <Jesin> you're welcome
08:33:10 <Jafet> @pl (\x -> not (p x))
08:33:10 <lambdabot> not . p
08:33:41 <Jafet> @pl (\x y z -> f (g x y z))
08:33:41 <lambdabot> ((f .) .) . g
08:33:44 <mauke> @pl \p xs -> filter (\x -> not (p x)) xs
08:33:44 <lambdabot> filter . (not .)
08:34:07 <int-e> > snd . partition odd $ [1..10] -- not serious
08:34:09 <lambdabot>   [2,4,6,8,10]
08:34:19 <Jesin> gets f = do
08:34:21 <Jesin>     s <- get
08:34:22 <Jesin>     return (f s)
08:34:24 <Jesin> can be reexpressed as
08:34:28 <Jesin> gets f = fmap f get
08:34:43 <Jesin> which I think is nice
08:35:05 <Jesin> gets = (`fmap` get) -- is also valid, but mean
08:35:07 <Jesin> :p
08:35:10 <mauke> @undo gets f = do s <- get; return (f s)
08:35:10 <lambdabot> gets f = get >>= \ s -> return (f s)
08:35:14 <mauke> @. pl undo gets f = do s <- get; return (f s)
08:35:15 <lambdabot> gets = (get >>=) . (return .)
08:35:27 <Jesin> @pl liftM
08:35:27 <lambdabot> fmap
08:35:30 <Jesin> @src liftM
08:35:31 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:35:43 <Jesin> @. undo src liftM
08:35:43 <lambdabot> ()
08:35:45 <Jesin> ...
08:35:47 <Jesin> blah
08:35:49 <int-e> or  f <$> get  ... what's the banana bracket version? (| <should there be a symbol here?>f get |)
08:35:58 <Jesin> @undo do { x1 <- m1; return (f x1) }
08:35:58 <lambdabot> m1 >>= \ x1 -> return (f x1)
08:36:24 <Jesin> well
08:36:28 <Jesin> gets = (<$> get)
08:36:30 <Jesin> also works
08:36:46 <Jesin> also
08:36:48 <Jesin> @src ap
08:36:48 <lambdabot> ap = liftM2 id
08:36:52 <Jesin> @src liftM2
08:36:52 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:37:01 <int-e> @src liftA2
08:37:01 <lambdabot> liftA2 f a b = f <$> a <*> b
08:37:12 <Jesin> ap m1 m2 = m1 >>= (`liftM` m2)
08:37:36 <Jesin> liftM == fmap for any decent monad
08:38:35 <int-e> mm.  m1 >>= (`liftM` m2) is not very symmetric.
08:39:21 <Jesin> application isn't symmetric
08:39:24 <Jesin> :p
08:40:45 <conal> <*> is semi-symmetric
08:40:45 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
08:41:03 <Jesin> well, yeah, but I consider
08:41:12 <int-e> but of course <*> = ap, so there's an egg and hen problem there.
08:41:17 <Jesin> m1 >>= (`fmap` m2)
08:41:24 <Jesin> to be semi-symmetric
08:41:27 <Jesin> in the same way
08:42:19 <Jesin> when my expression for fmap is simpler than my expression for (>>=), I like to define
08:42:26 <Jesin> m1 <*> m2 = m1 >>= (`fmap` m2)
08:42:33 <Jesin> to remove the indirection and complication
08:42:35 <Jesin> sometimes
08:43:49 <Jesin> I dunno if the computation is ever actually faster that way
08:43:56 <Jesin> significantly, that is
08:44:01 <Jesin> but, yeah  :p
08:46:17 <int-e> @pl \f g -> join (fmap (flip fmap g) f)
08:46:17 <lambdabot> (join .) . flip (fmap . flip fmap)
08:46:48 <Aristid-andro> oO
08:47:51 <Jesin> hmm
08:47:54 <Jesin> \f g -> join (fmap (flip fmap g) f)
08:48:17 <int-e> it's ap again.
08:48:18 <Jesin> \f g -> f >>= (flip fmap g)
08:48:28 <Jesin> :t \f g -> join (fmap (flip fmap g) f)
08:48:29 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => m (a -> a1) -> m a -> m a1
08:48:38 <Jesin> yeah
08:48:40 <Jesin> it is
08:48:53 <Jesin> @pl join (fmap f m)
08:48:53 <lambdabot> f =<< m
08:49:26 <Jesin> @pl \f g -> join (fmap (`fmap` g) f)
08:49:26 <lambdabot> (join .) . flip (fmap . flip fmap)
08:50:02 <Jesin> @pl m1 >>= (`fmap` m2)
08:50:02 <lambdabot> m1 `ap` m2
08:50:06 <Jesin> lol!
08:50:09 <Jesin> it recognizes that
08:50:11 <Jesin> nice
08:50:20 <Jesin> @pl (<*>)
08:50:20 <lambdabot> (<*>)
08:50:37 <Jesin> @pl liftA2 id
08:50:37 <lambdabot> liftA2 id
08:50:40 <Jesin> @pl liftM2 id
08:50:40 <lambdabot> ap
08:50:58 <Jesin> lambdabot's @pl needs better applicative support
08:51:18 <int-e> @type \f g -> join (fmap (flip fmap f . flip id) g)
08:51:19 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => m (a1 -> a) -> m a1 -> m a
08:51:24 <int-e> not ap :-)
08:51:58 <Jesin> yes it is
08:52:13 <accel> does haskell provide anywhere really long, uninterpreted strings? like <<< <<<EOF in Perl, or [[ ]] in lua ?
08:52:15 <Jesin> @type ap
08:52:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:52:18 <Jesin> @type (<*>)
08:52:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:52:26 <mauke> accel: not by default
08:52:33 <accel> mauke: what extension do I want?
08:52:39 <Jesin> int-e: it is ap
08:52:45 <mauke> uh, what was it called?
08:52:46 <zygoloid> accel: QuasiQuotes :)
08:52:48 <Jesin> because Applicative is a superclass of Monad
08:52:50 <mauke> right!
08:52:53 <Jesin> >:(
08:53:29 <hpc> quasiquotes </3
08:53:36 <mauke> Jesin: how is Applicative involved?
08:53:53 <Jesin> Functor is a superclass of Applicative
08:53:56 <accel> is there a concat w/ "\n", or if I want to do that I need to map first?
08:54:16 <mauke> ah
08:54:24 <zygoloid> here = QuasiQuoter stringE (litP . stringL)
08:54:37 <mauke> accel: unlines
08:54:44 <Jesin> the hierarchy goes Functor => Applicative => Monad, and I refuse to believe that this has not been implemented yet, no matter what GHC or the documentation says otherwise
08:54:45 <zygoloid> [$here| ... arbitrary text ... |]
08:54:48 <int-e> > let ap' = (\f g -> join (fmap (flip fmap f . flip id) g)); t ap = runWriter $ap (tell "1" >> return id) (tell "2") in (t ap, t ap')
08:54:49 <Jesin> :p
08:54:50 <lambdabot>   (((),"12"),((),"21"))
08:54:57 <int-e> Jesin: not ap.
08:55:01 <accel> > unlines ["Hello", "Mauke"]
08:55:02 <lambdabot>   "Hello\nMauke\n"
08:55:07 <accel> @karma+ mauke 
08:55:08 <lambdabot> mauke's karma raised to 27.
08:55:23 <Jesin> wait, what
08:55:24 <Jesin> ...
08:55:26 <Jesin> let's try my version
08:55:30 <mauke> accel--  # stop using @karma
08:55:35 <Jesin> \m1 m2 -> m1 >>= (`fmap` m2)
08:55:39 <accel> ouch
08:55:42 <accel> @karma accel
08:55:42 <lambdabot> You have a karma of 1
08:55:55 <accel> mauke++ # repay evil with good
08:56:02 <Jesin> > let ap' = (\a b -> a >>= (`fmap b)); t ap = runWriter $ap (tell "1" >> return id) (tell "2") in (t ap, t ap')
08:56:03 <lambdabot>   <no location info>: parse error on input `b'
08:56:10 <Jesin> > let ap' = (\a b -> a >>= (`fmap` b)); t ap = runWriter $ap (tell "1" >> return id) (tell "2") in (t ap, t ap')
08:56:11 <lambdabot>   (((),"12"),((),"12"))
08:56:15 <mauke> accel++  # I'm not that evil
08:56:24 <Jesin> int-e: you messed that one up, not me
08:56:26 <Jesin> :p
08:56:43 <accel> so I wrote my first monad last night
08:56:50 <accel> it's really weird, realizing that monads don't necessairly ahve to hae side effects
08:56:53 <int-e> Jesin: I didn't mess up at all. I designed that version to get the evaluation order different.
08:56:54 <Jesin> I guess it was the composition with flip id
08:56:55 <accel> it's basically just one longass computation
08:56:57 <Jesin> right, ok
08:57:09 <accel> (basically, it's a modification of the Logger Monad, instead it writes out LaTeX expressions)
08:57:19 <Jesin> > let ap' = (<**>); t ap = runWriter $ap (tell "1" >> return id) (tell "2") in (t ap, t ap')
08:57:20 <lambdabot>   Couldn't match expected type `()'
08:57:20 <lambdabot>         against inferred type `(a -> a) -...
08:57:25 <Jesin> blah
08:57:57 <int-e> Jesin: flip (<**>)
08:59:59 <Jesin> > let ap' = flip (<**>); t ap = runWriter $ap (tell "1" >> return id) (tell "2") in (t ap, t ap')
09:00:00 <lambdabot>   (((),"12"),((),"21"))
09:00:05 <Jesin> wow
09:02:25 <Jesin> huh
09:02:40 <Jesin> for a while I had thought (<**>) was flip (<*>)
09:02:57 <Jesin> I guess liftA2 (flip id) makes more sense
09:03:05 <Jesin> :t flip ($)
09:03:06 <lambdabot> forall a b. a -> (a -> b) -> b
09:03:07 <Jesin> :t flip id
09:03:07 <lambdabot> forall a b. a -> (a -> b) -> b
09:03:13 <azaq23> @src (<**>)
09:03:13 <lambdabot> (<**>) = liftA2 (flip ($))
09:03:26 <Jesin> @src ($)
09:03:27 <lambdabot> f $ x = f x
09:03:36 <Jesin> I still think that should be written ($) f = f
09:04:42 <augur> conal: any suggestions for reading on the relationship between denotational semantics and type theory?
09:04:57 <azaq23> > let ($$) :: (a -> b) -> (a -> b); ($$) = id in (* 2) $$ 2
09:04:58 <lambdabot>   4
09:05:29 <conal> augur: hm. nothing comes to mind. they have interesting relationships, though.
09:05:31 <Jesin> :t flip
09:05:32 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:05:37 <Jesin> the flip in lambdabot is horrible
09:05:39 <Jesin> :p
09:05:48 <Jesin> (.) = fmap -- in lambdabot
09:05:50 <Jesin> and
09:06:03 <Jesin> flip f x = fmap ($ x) f
09:06:03 <conal> augur: for instance, DS applies usefully to types, not just "languages". 
09:06:11 <Jesin> :t fmap ($ x) f
09:06:12 <lambdabot> forall b (f :: * -> *). (SimpleReflect.FromExpr (f (Expr -> b)), Functor f) => f b
09:06:21 <Jesin> blah
09:06:30 <Jesin> :t \f x -> fmap ($ x) f
09:06:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
09:06:36 <conal> augur: also, originally DS mapped to the untyped lambda calculus, but typed calculi work also, and are often a better fit.
09:06:51 * ski wondered the other day about example of non-compositional semantics ..
09:07:22 <conal> i think of every abstraction as non-compositional semantics (and vice versa)
09:07:36 <Jesin> one of the applicative laws, interchange
09:07:38 <accel> conal++
09:07:39 <ski> Jesin : blame me for `flip'
09:07:46 <conal> :) thx.
09:07:47 <accel> conal++ # (for tutorial on FRP)
09:07:54 <accel> yeah; big fan of FRP
09:08:07 <accel> sad I don't see it used more in the animation literature
09:08:08 <Jesin> interchange:  u <*> pure y = pure ($ y) <*> u 
09:08:26 <ski> (pure elements are central)
09:08:44 <Jesin> fmap f x = pure f <*> x
09:09:47 <Jesin> hmm, are any of the applicative laws redundant?
09:10:07 <conal> does anyone else have suggestions for augur (sources that relate denotational semantics & type theory)?
09:11:18 <Raelifin> Hey, I'm a Haskell newbie who needs help with what would be "generic interfaces" in Java (not sure if that terminology applies in Haskell).
09:11:50 <accel> in a function signature, is ti possible to add in variable names instead of jsut types? i.e. instead of: "writeDoc :: String -> IO()", I'd like "writeDoc :: String fileName -> IO()"
09:12:08 <Veinor> accel: no, it's not
09:12:24 <accel> Veinor: how do you handle 20 argument functions then?
09:12:32 <Veinor> you don't write 20-argument functions :)
09:12:47 <Veinor> Raelifin: what exactly do you mean?
09:12:49 <drhodes> Raelifin: if you haven't checked out chapter 6 of real world haskell on typeclasses, that would probably be a good start
09:13:05 <ray> i am not sure how many people in here would know what a generic interface is
09:13:32 <ray> we are all ivory tower academics who don't know a java from a cup of coffee
09:13:34 <Raelifin> I'm trying to make a module that has functions which rely on functions that aren't in the module.
09:13:35 <newsham> ?type id
09:13:36 <lambdabot> forall a. a -> a
09:13:45 <Raelifin> They'd be defined wherever the module is called.
09:13:48 <quicksilver> accel: haddock comments can help. But probably don't write 20-arg functions.
09:13:50 <conal> augur: about your earlier question (what operations are likely to be supported, given a meaning/model): i look at the model/meaning and ask what classes it inhabits. for instance, animation (in the general sense of dynamic info) and images have functions as meaning (from R and R^2 respectively). and "functions from" inhabits Functor, Applicative, and Monad (and sometimes Monoid). so i know to look for corresponding instances for animation
09:13:50 <conal> image. and i know what those instances must mean.
09:14:57 <augur> conal: abstraction steps in the LC are definitely non-compositional, but thats ok, since denotational semantics doesn't actually need abstraction :p
09:15:00 <Raelifin> Originally I thought that a typeclass would work, but I'm having trouble convincing the interpreter that the generic parameters match up with the parameter types in the specific instance.
09:15:32 <Raelifin> (I think typeclass is the right word. I mean the construct that is defined with the "class" keyword)
09:15:49 <augur> also, conal, if DS is well suited for type systems too, can you point me to a paper on that?
09:16:18 <conal> augur: in what sense "well suited for type systems"?
09:16:33 <Raelifin> Veinor: Does that make any sense?
09:16:38 * ksf_ wonders whether he can add exceptions to exception-less iteratees by stacking another exception-less iteratee onto it, or whether he's going to be short-changed by one lambda doing that.
09:16:45 <augur> conal: in the sense that "conal: augur: for instance, DS applies usefully to types, not just "languages"."
09:16:50 <augur> :p
09:17:01 <Veinor> typeclasses are i think the analogous concept for generic interfaces, yeah
09:17:01 <conal> augur: ah, you were paraphrasing. got it.
09:17:12 <augur> :p
09:18:12 <fryguybob> Raelifin: Can you paste an example of the issue you are running into? hpaste.org
09:18:26 <conal> augur: i meant DS for meanings of data types, rather than for "languages". (language is a special case of data type.) as in http://conal.net/papers/type-class-morphisms/
09:18:31 <Raelifin> fryguybob: ok
09:18:45 <augur> conal: languages are data types? :o
09:18:46 <ksf_> that would finally reduce iteratees to ContT on steroids.
09:18:47 <augur> do explain
09:18:58 <conal> augur: and as in http://conal.net/papers/push-pull-frp/
09:19:07 <saml> launguage =  recursive on alphabet
09:19:31 <augur> oh you and your FRP :|
09:19:38 <saml> augur, read it and tl;tr
09:20:33 <dorchard> hi all- sorry to butt in like a crazed madman: need a bit of help getting ghc-7.01 to play nice. getting problems with -fno-stack-protector, anyone well versed in this kind of thing?
09:20:53 <saml> dorchard, why use 7.0.1? it's for experts only
09:20:57 <conal> augur: a language's abstract syntax can be thought of and written as an algebraic data type. so can an abstract data type's *interface*.
09:21:23 <dorchard> well I've been using 6.13.blah for a while, but I need to test out a new version of a package with one of my own
09:21:23 <ksf_> @tell xplat I fear I only now understand what you meant with single-chunk-mode, so the answer might be "no". but getting rid of what's essentially a second parameter of return (the ramaining chunk) is well worth mulling over.
09:21:23 <lambdabot> Consider it noted.
09:21:32 <augur> oh, sure, conal.
09:21:50 <saml> algebraic data type is like Foo 2 3 "adf"  right?
09:22:04 <ray> use the version in the current haskell platform unless required otherwise
09:22:04 <saml> i mean, type is   Foo Int Int String | Bar Int Int Int Int
09:22:12 <ksf_> yep.
09:22:15 <augur> i suppose then you think of the denotations of the expressions of a language as being the value it computes which seems obvious enough
09:22:35 <ksf_> or rather, kinda. you have sums and products, but are lacking any kind of recursion
09:23:00 <saml> so how can language be algebraic type?
09:23:18 <ray> the standard data Tree = etc etc
09:23:19 <dorchard> I need at least 6.13 for various things, not 6.12, so I thought I'd go up to 7.01
09:23:24 <saml> or do you mean, you can encode a language using algebraic type just like you can encode a language with xml?
09:23:33 <ksf_> saml, I don't think augur was talking to you
09:23:50 <saml> augur always talks to me. he's my friend
09:24:02 <ksf_> he's talking to conal, which also goes by his native name of never-satisfied-with-semantics around here.
09:24:15 <ksf_> *who
09:24:19 <ksf_> I'm never going to learn that.
09:24:24 <ray> i think they made me study conal sections in high school
09:24:37 <sm> ooh, hspec
09:25:05 <ray> but they never told anyone the equation for a cone so it was stupid
09:25:13 <saml> can semantics coded in xml?
09:26:51 <augur> saml: sure, why not
09:27:02 <saml> augur, give me example
09:27:53 <augur> <application><function>f</function> <argument>x</argument></application>
09:28:03 <saml> what's that meaning?
09:28:44 <augur> f x
09:29:27 <augur> i mean, if you want to talk about denotations in XML you need to be able to either describe infinite sets, or deal with only finite sets
09:29:53 <walt> anyone using vim for haskell and know if there is an omnicompletion plugin? There seems to be a vimball, but all the pages referring to it I find are 404
09:30:12 <dankna> what is with all the vim questions lately?
09:30:45 <saml> walt, i use vim. i don't use that
09:30:53 <Jesin> [12:52:42]	<augur>	<application><function>f</function> <argument>x</argument></application>
09:30:56 <saml> i just use word complete 
09:31:02 <Jesin> if you're going to write out the parse tree
09:31:08 <Jesin> PLEASE use S-expressions
09:31:11 <walt> saml: do you have anything for getting the type inferred for an iderntifier?
09:31:14 <Jesin> ...
09:31:14 <augur> Jesin: he asked for XML.
09:31:20 <Jesin> =/
09:31:20 <Jesin> yeah
09:31:22 <Jesin> I got it
09:31:22 <saml> walt, i use ghci for that
09:31:23 <Jesin> xml is ugly though.
09:31:27 <saml> :t identifier
09:31:28 <augur> no shit, Jesin
09:31:28 <lambdabot> Not in scope: `identifier'
09:31:31 <Zao> I don't have it locally sadly, as the site encourages to :source over netrw.
09:31:46 <Jesin> :p
09:31:46 <saml> fuck
09:31:46 <saml> fuck
09:31:46 <saml> fuck
09:31:46 <augur> whoaaaa
09:31:46 <saml> gigigty
09:31:50 <dorchard> yay
09:31:51 <walt> saml: I see. I guess I'll hack something up then interfacing with ghci
09:31:52 * ksf_ doesnt' use any completition, he would have painful java flashbacks, then.
09:31:52 <Zao> haskell-mode is quite nice.
09:31:56 <augur> holy moley
09:31:59 <saml> walt, why?
09:32:02 <jystic> @pl \x -> [x]
09:32:02 <lambdabot> return
09:32:02 <Zao> saml: It's much more handy having it integrated into the editor, as well as being able to insert type signatures, etc.
09:32:11 <Zao> saml: Chill down the language?
09:32:22 <Veinor> i just use M-/
09:32:31 <ksf_> vimscript is the work of the devil
09:32:34 <saml> sorry i was excitied to see people split
09:32:35 <Veinor> i'd really like a type-aware M-/
09:32:47 <Ptival> walt > I downloaded it a few weeks ago, but now the page is empty yeah :\
09:32:57 <saml> maybe try leksah walt 
09:32:57 <ksf_> I'd rather suffer the agony of using emacs than learning it...
09:33:03 <ksf_> ...and you know that's no idle talk.
09:33:04 <walt> Ptival: is it working for you? Could you share it if so?
09:33:28 <Ptival> walt: lemme check
09:33:28 <azaq23> > let f = (: []) in f 10 -- jystic
09:33:31 <lambdabot>   [10]
09:33:39 <walt> saml: no I like vim :)
09:34:07 <Zao> Seriously... I thought that #haskell was above editor wars...
09:34:08 <ksf_> leksah+yi+hare
09:34:08 <walt> Zao: are we having an editor war?
09:34:17 <Zao> Some are.
09:34:22 <ksf_> ...with hare working with ghc-haskell.
09:34:31 <mjrosenb> Zao: *no* channel is above an editor war
09:34:35 <Zao> Somehow, the discussion about vim's haskell-mode turned into emacs fellatio.
09:34:59 <saml> i program on paper, scan to my ipad, and connect to ghci server, compile, run, debug
09:35:20 <silver> > ipad
09:35:20 <dorchard> is there any way to find out where cabal is getting its gcc from, i.e. what path to gcc it is using? 
09:35:21 <lambdabot>   Not in scope: `ipad'
09:35:28 <silver> ohh you
09:37:38 <Saizan> dorchard: run it with -v
09:38:28 <Ptival> walt: last version I have http://seborga1.free.fr/haskellmode-20101118.vba
09:38:33 <dorchard> thanks Saizan, couldn't see anything about gcc in there, other than the error I am getting from cc!
09:38:51 <maltem> dorchard, there's also  cabal configure --with-compiler=  to point it to another compiler
09:38:59 <dorchard> ooh that might help me 
09:39:14 <walt> Ptival: that's great, thanks :)
09:39:17 <walt> I hope it works nicely
09:39:22 <maltem> You may also need to cabal clean before
09:39:38 <Ptival> walt: you'll need a little set up too iirc
09:39:59 <walt> Ptival: I am hoping there is documentation
09:40:19 <maltem> (otherwise funky linker errors are to be anticipated)
09:40:55 <Saizan> --with-compiler is for the haskell compiler
09:40:55 <dorchard> hm
09:40:56 <maltem> oh, this was about gcc
09:40:58 <dorchard> yes that doesn't seem to work- it complains about the ghc version neededing to be >=6.4
09:41:03 <Saizan> --with-gcc=
09:41:06 <dorchard> sorry yes
09:41:06 <dorchard> okay
09:41:26 <dorchard> blargh
09:41:32 <augur> @tell conal do you know of any good papers discussing how to convert properties/laws into aspects of the data type?
09:41:32 <lambdabot> Consider it noted.
09:41:41 <dorchard> this makes no sense
09:42:13 <augur> oh, there you go conal
09:42:13 <dorchard> bash-3.2$ cabal configure --with-gcc=/usr/bin/cc Resolving dependencies... Configuring transformers-0.2.2.0... cc1: error: unrecognized command line option "-fno-stack-protector"  
09:42:14 <augur> (from a @tell) conal do you know of any good papers discussing how to convert properties/laws into aspects of the data type?
09:42:14 <Saizan> dorchard: with cabal install -v i get a line like "Using gcc version 4.5.2 found on system at: /usr/bin/gcc"
09:42:48 <dorchard> my gcc does support -fno-stack-protector
09:42:49 <dorchard> so I don't know what it is doing
09:43:43 <Ptival> walt: basically you want to put this in your .vimrc
09:43:43 <Ptival> au Bufenter *.hs compiler ghc
09:43:43 <Ptival> au Bufenter *.lhs compiler ghc
09:43:43 <Ptival> let g:haddock_browser = "/path/to/your/web/browser"
09:44:16 <Ptival> walt: and if you need help just ask
09:44:19 <Saizan> dorchard: there's also -v2 and -v3 (even if the latter gives way too much info..)
09:44:20 <dorchard> if I try /usr/bin/cc foo.c -fno-stack-protector is a-ok (for some foo.c)
09:44:48 <mjrosenb> Saizan: isn't -vv and -vvv standard?
09:45:54 --- mode: holmes.freenode.net set +o ChanServ
09:46:15 <Saizan> mjrosenb: never seen -vv and -vvv anywhere actually, but i don't know
09:46:34 <dorchard> well -v3 gives me a lot more info
09:46:42 <dorchard> but it doesn't tell me what version of gcc is being poked
09:46:42 <walt> Ptival: this works great :)
09:47:01 <walt> Ptival: basically what I wanted the most is getting type info of an identifier
09:47:01 <walt> thanks
09:47:05 <dorchard> but I do see that ghc is being called with some c file- perhaps ghc is picking the wrong gcc
09:47:06 <conal> augur: "aspects"?
09:47:07 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
09:47:35 <Saizan> dorchard: have you trying grepping for /usr/bin/cc or gcc?
09:48:00 <Saizan> dorchard: that's possible
09:48:34 <dorchard> thanks- yes I see it now, gcc 4.3.0 being used, and that supports -fno-stack-protector
09:48:43 <dorchard> so.. ghc is using the wrong cc compiler perhaps
09:49:30 <dorchard> how to see which gcc compiler ghc uses I wonder
09:50:44 <dorchard> you'd think ghc would be getting told by cabal which cc compiler to use, but I could be wrong
09:52:08 <Lemmih> dorchard: cabal install -v
09:52:29 <ksf_> ghc -opc=--version ?
09:52:36 <ksf_> *optc
09:52:48 <dorchard> ksf_ how do I tell cabal that?
09:53:12 <ksf_> no, that's not it.
09:53:35 <dorchard> cabal is reporting with -v3 that it has the right version of gcc I am trying to point to
09:53:41 <Saizan> dorchard: -v3 should also make ghc print out the command invocations it makes
09:54:14 <ksf_> ghc -fvia-c -optc=--version
09:54:19 <ksf_> ...you need a dummy file, too.
09:54:29 <dorchard> it does thanks
09:54:31 <dorchard> ("/local/scratch/dao29/local/bin/ghc",["-c","/tmp/27007.c","-o","/tmp/27007.o"])
09:54:31 <dorchard> cc1: error: unrecognized command line option "-fno-stack-protector"
09:54:31 <dorchard>  
09:58:09 --- mode: holmes.freenode.net set +o ChanServ
09:58:59 <Saizan> that's the cabal call to ghc, ghc should also print its call to cc1 or whatever it is, it does so on stderr though i think
09:59:00 <raelifin_> Well, you can't do the first one. It throws a compiler error.
09:59:20 <fryguybob> raelifin_: I'm not familiar with all the details of Java generics but that would be valid C#
10:00:44 <raelifin_> fryguybob: The generic "U" would be rejected as unknown, but the second one would work... until you try and implement This, at which point you'd have to cast the inputs to f1 and f2.
10:01:25 <dorchard> Saizan: I don't have the call to cc 
10:01:25 <dorchard> hm
10:02:19 <dorchard> it doesn't show it
10:02:54 <DrSyzygy> dcoutts: Ping?
10:02:55 <fryguybob> raelifin_: Exactly.
10:03:38 <raelifin_> fryguybob: So, it looks like Type Families are what I want. They'll let me parameratize the data for my type classes.
10:05:10 <fryguybob> raelifin_: Well for the Java interface you gave I think that would be fine with a normal type class.
10:05:49 <raelifin_> fryguybob: Do you think you could give an instance of it working?
10:06:13 <fryguybob> raelifin_: Yeah, just a second.
10:07:39 <joevandyk> I'm looking to build some haskell json webservices (that work with a Rails app).  What do you guys recommend as far as libraries / frameworks?  Also, I'm curious as to how a haskell webservice is typically deployed.
10:08:45 <augur> conal: well, given some type T, that satisfies some laws L by convention (like monads in haskell(, is there a way to get data type T' that is like T except it satisfies L by necessity not by convention?
10:09:30 <j-invariant> Any haskell library that does fast arithmetic with checking prime numbers? and generating primes?
10:09:39 <periodic> joevandyk: the json library should get you the jaxon stuff.
10:09:46 <accel> this is an attempt at a LaTeX DSl in Haskell. Besides the HLint errors , any idea what I can do to simplify? http://hpaste.org/44009/latex
10:09:54 <fryguybob> raelifin_: http://hpaste.org/paste/44007/generic_interface_annotation#p44010
10:10:07 <periodic> joevandyk: As for the web frameworks, there is sort of a whole stack.  The main thing is the Web Application Interface (WAI)
10:10:15 <accel> this is an attempt at a LaTeX DSl in Haskell. Besides the HLint errors , any idea what I can do to simplify? http://hpaste.org/44009/latex (in particular, I don't like the fact those bmatrix/omaths are running off the side of the screen)
10:11:29 <conal> augur: i don't know. maybe. easy with dependent types. maybe not so easy without.
10:11:30 <accel> this is an attempt at a LaTeX DSl in Haskell. Besides the HLint errors , any idea what I can do to simplify? http://hpaste.org/44009/latex (in particular, I don't like the fact those bmatrix/omaths are running off the side of the screen); also I feel like I have too many "$ do"'s lying around
10:11:30 <periodic> joevandyk: there are ways to use WAI apps with stand-alone web services or as CGI.  It's pretty generic and can mix-and-match with many things.
10:11:31 <joevandyk> periodic: is "Web Application Interface" the name of a project?
10:11:35 <Guest24255> http://docs.yesodweb.com/
10:11:37 <periodic> joevandyk: if you want something that's pretty simple and stand alone, look at Yesod or HappStack for things like routing and dealing with headers.
10:14:04 <periodic> joevandyk: It's the name of the interface convention.  WAI is an interface between haskell web apps and the haskell-based web servers
10:14:04 <augur> conal: easy with dt's ey?
10:14:04 <joevandyk> thanks.  i also found snap.  how are those projects typically deployed?
10:14:04 <conal> augur: if you use the discipline of type class morphisms, the laws are guaranteed to hold. but i don't think that's quite what you're asking.
10:14:05 <Guest24255> joevandyk, http://docs.yesodweb.com/book/deploying
10:14:07 <periodic> joevandyk: I think Snap, Warp, etc are all stand-alone web services.
10:14:11 <augur> im reading the tcm paper now :)
10:14:14 <raelifin_> fryguybob: Ah, that's much nicer than what I wrote, but I was specifically trying to put the composition step inside that.hs
10:14:15 <periodic> joevandyk: I set up a simple JSON service I connected to Rails via ActiveResource that was built on Happstack.
10:14:15 <conal> augur: yeah. you extend the class to included methods that represent proofs that the laws hold.
10:14:18 <raelifin_> fryguybob: Because that's the stand-in for more complex functions which I'm trying to work into a module.
10:14:21 <joevandyk> Is WAI like Ruby's Rack?
10:14:21 <dorchard> thanks for the help all. I don't really have time for this so will just figure out how to do it with 6.12l
10:14:21 <dorchard> thanks
10:14:21 <dorchard> adios
10:14:21 <periodic> joevandyk: Happstack and Yesod are the two web service frameworks I have any experience with.  Happstack is less of a framework, making it fairly easy to just plug in some code.  Yesod is a whole framework with HTML and CSS generation libraries and a persistance engine.
10:14:24 <periodic> joevandyk: I think so.  I'm not too familiar with rack.
10:14:26 <raelifin_> fryguybob: Oh, but I have an idea...
10:15:26 <dcoutts> DrSyzygy: sorry, got disconnected, didn't see any replies
10:15:29 <raelifin_> fryguybob: Aha! Yes.
10:15:43 <DrSyzygy> dcoutts: Don't worry, I didn't say anything more than ping yet.
10:15:45 <DrSyzygy> Query ok?
10:15:53 <raelifin_> fryguybob: I can move the composition function into the typeclass and it works!
10:16:11 <fryguybob> raelifin_: Excellent.  Sorry, I'm in and out with lunch.
10:16:33 <raelifin_> fryguybob: No need to be sorry! You just solved my problem. :D
10:16:47 <raelifin_> fryguybob: Thanks a bundle!
10:19:49 <augur> see ya
10:19:52 <augur> woops wrong place :D
10:19:57 <dcoutts> DrSyzygy: did you want to talk to me about something?
10:21:01 <DrSyzygy> Yes.
10:21:37 <accel> is it possible, to have multiple IO()'s on a single line in a do block, yet not have to put ">>" in between them?
10:21:58 <accel> I don't get why I need to separate them with \n
10:22:04 <monochrom> use ;
10:22:17 <monochrom> > do { [1]; [2]; [3] }
10:22:18 <lambdabot>   [3]
10:22:20 <accel> i'm building a DSL
10:22:26 <accel> i'd really like to just separte them with ' '
10:23:04 <monochrom> but I prefer '*' more
10:23:38 <accel> man, buidling a DSL in haskell has been an uter nightmare so far
10:24:04 <monochrom> yeah, generally all dive-in projects are nightmares
10:24:12 <accel> dive-in projects?
10:24:15 <accel> what's a dive-in project
10:24:54 <ocharles> How do I find out what version of a package I have installed?
10:24:58 <monochrom> such as "hi, I'm new to haskell, I plan to learn it by diving in and write a word processor in haskell"
10:25:06 <Jesin> lol
10:25:27 <byorgey> ocharles: ghc-pkg list package-name
10:25:27 <lambdabot> byorgey: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:25:28 <Jesin> yes, word processor
10:25:29 <Jesin> awesome idea
10:25:29 <Jesin> :p
10:25:49 <ocharles> byorgey: thank you :)
10:26:02 <accel> I sense mockery
10:26:38 <Jesin> e.
10:26:40 <djahandarie> accel, have you seen the BASIC edsl?
10:26:40 <ocharles> My first haskell project looks like it's going to require me writing a haskell interface to xapian
10:26:40 <ocharles> yay for starting way out of my depth :)
10:26:40 <Jesin> *eh.  writing a DSL
10:26:41 <accel> djahandarie: no
10:26:45 <djahandarie> It does some pretty tricky shit, but it's a nice outcome.
10:26:48 <Jesin> is not nearly as bad as a word processor
10:26:54 <Jesin> I think
10:27:29 <Jesin> but, what are you writing a DSL for?
10:27:30 <ocharles> a dsl for dsls
10:27:30 <ocharles> of course
10:27:48 <djahandarie> accel, http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
10:28:08 <djahandarie> accel, http://hackage.haskell.org/package/BASIC
10:28:11 <Jesin> XD
10:28:12 <Jesin> wooow
10:28:15 * waern may be able to offer a Haskell internship in the south of France (the proposal seems to be on it's way to being accepted...)
10:28:33 <accel> djahandarie: nice; tanks
10:28:42 <accel> djahandarie++
10:28:54 <Jesin> djahandarie: that's awesome
10:29:00 <djahandarie> accel, warning though, that has some serious hackery in it that I wouldn't consider putting in any production code
10:29:00 <Jesin>   where awesome = horrible
10:29:11 <Jesin> :p
10:29:15 <j-invariant> Can  haskell to fast prime numbers librarly?
10:29:33 <djahandarie> accel, but it's what is required to get some of the syntax needed
10:29:49 * djahandarie gets back to work
10:30:04 <j-invariant> I can't be bothered learning a new langauge but this haskell crashes my computer
10:30:08 <Jesin> Can anyone to that setnence j-invariant correctly?
10:30:57 <Jesin> basically
10:31:03 <Jesin> [13:54:06]	<j-invariant>	Can haskell to fast prime numbers librarly?
10:31:08 <Jesin> I'm getting a parse error on this
10:31:13 <Jesin> :p
10:31:26 <j-invariant> I need fast prime number generating and testing
10:31:55 <Jesin> @hoogle prime
10:31:55 <lambdabot> Data.HashTable prime :: Int32
10:31:55 <lambdabot> Text.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
10:31:55 <lambdabot> Text.ParserCombinators.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m
10:31:55 <lambdabot> a
10:31:55 <j-invariant> factoring etc.
10:31:56 <homie> i compiled the last version of ghc, and it works, but many tests failed
10:31:56 <Jesin> hmm
10:31:58 <Jesin> http://hackage.haskell.org/package/primes
10:32:00 <j-invariant> don't search for it
10:32:08 <j-invariant> I want a good library
10:33:07 <mm_freak> j-invariant: the RSA package can do that, but i don't know the quality
10:34:02 <j-invariant> thanks mm_freak 
10:36:58 <corpumpkin> quiet in here
10:39:32 <pesco> ahoj
10:39:41 <pesco> alios: hey ;)
10:41:06 <accel> in haskell, waht does : a b c d e f g mean?
10:41:16 <accel> is it a ( b ( c ( d ( e ( f g ) ) ) ) ) ?
10:41:36 <corpumpkin> (((((a b) c) d) e) f) g)
10:41:38 <pesco> the other way
10:41:46 <augur> conal: this is all very interesting...
10:41:55 <augur> corpumpkin!
10:42:22 <lpsmith> corepumpkin!
10:42:30 <corpumpkin> :)
10:42:46 * augur flops on corpumpkin
10:42:55 <conal> accel: because juxtaposition (denoting application) is left-associative
10:43:26 <accel> conal: got it; thanks
10:43:26 <accel> conal: thanks
10:43:41 <corpumpkin> accel: you forgot to thank him
10:43:42 <pesco> poor conal
10:43:47 <accel> corpumpkin: thanks
10:43:55 <corpumpkin> accel: nah, I'm fine
10:44:02 <corpumpkin> but you didn't think conal enough
10:44:03 <accel> corpumpkin: I meant to thank you on the second "thanks"; but auto completion screwed up
10:44:13 <corpumpkin> oh :)
10:44:31 <accel> corpumpkin: you need to change your nick if you want to win the co<TAB> war
10:44:36 <lpsmith> "cabal register" doesn't seem to work...
10:45:18 <lpsmith> either that or I really don't understand how it's supposed to work
10:46:07 <lpsmith> Ok,  I have a parsec-3 versus parsec-2 problem,   I've been able to build the package via  "cabal configure && cabal build",  but then cabal install complains
10:46:34 <monochrom> if you do configure and build, then the next two steps are copy and register, not just register.
10:46:46 <monochrom> and before copy, may I recommend haddock.
10:47:38 <lpsmith> ahh, thanks monochrom!
10:47:56 <accel> is it possible 
10:47:59 <accel> to create a function
10:48:01 <accel> with an infinitely long type?
10:48:25 <monochrom> not unless you go through a newtype
10:48:37 <accel> monochrom: can you give me an example using newtype?
10:48:50 <corpumpkin> you can hide an infinite type behind a type family
10:48:55 <monochrom> newtype US'economy money = Ctor (money -> US'economy)
10:48:57 <corpumpkin> as max bolingbroke did on haskell-cafe a while back
10:49:05 <monochrom> oops typo
10:49:08 <monochrom> newtype US'economy money = Ctor (money -> US'economy money)
10:50:31 <dankna> be realistic.  newtype US'economy money = Ctor (money -> US'economy ())
10:50:38 <dcoutts> lpsmith: you can direct it to use one or the other with --constraint='parsec > 3' or whatever
10:51:02 <lpsmith> dcoutts, good to know.  But why does cabal install have a different dependency resolution than cabal configure && cabal build && cabal copy && cabal register?
10:51:11 <monochrom> there is also no need to split "is it possible to create a function with an infinitely long type?" into 3 lines
10:51:26 <corpumpkin> monochrom: I
10:51:27 <corpumpkin> dunno
10:51:30 <corpumpkin> it seems
10:51:31 <corpumpkin> reasonable to me
10:52:21 <dcoutts> lpsmith: it doesn't
10:53:01 <dcoutts> lpsmith: you can use --constraint for cabal configure too. But note that when you do cabal configure, it has fewer options, it cannot install or reinstall dependencies.
10:55:26 <dcoutts> lpsmith: so that's why it may be forced to make difference decisions
10:55:31 <lpsmith> hmm
10:55:36 <lpsmith> dcoutts, well,  I find it somewhat counterintuitive that if I already have the dependencies installed,  that the string of commands would work when cabal install doesn't
10:55:49 <monochrom> the semantics of "cabal configure; cabal build; cabal install" is not clear to me
10:55:49 <lpsmith> well, that too
10:56:10 <monochrom> but "cabal install" at the onset should work
10:56:18 <dcoutts> lpsmith: constraining the search space can help the solver. It's not that smart.
10:56:31 <augur> conal: theres a typo on p5 of TCM
10:57:09 <conal> augur: super. would you please email the typo to me. i'll get it fixed that way.
10:57:36 <augur> conal@conal.net?
10:57:47 <dcoutts> monochrom: there's certainly a meaning clash for cabal install, it's a "do everything" command, where people also want a "just install" command
10:58:00 <conal> augur: yep
10:58:11 <corpumpkin> cabal stage!
10:58:19 <augur> conal: sent
10:58:49 <conal> augur: thx!
10:59:51 <dcoutts> lpsmith: and there's also the issue that "having the dependencies installed" is rather a simplification of the situation
11:00:00 <shamster> has anyone run into the problem of missing dependencies (i.e. time ==1.1.*) when trying to install cabal-install?
11:01:26 <monochrom> "ghc-pkg list -v" and "ghc -v" may show much corruption and cause
11:02:11 <donri> Are quasiquotes just multiline string literals?
11:02:14 <augur> conal: so when you say something like
11:02:24 <augur> [[fmap f m]] = fmap f [[m]]   or   [[-]] . fmap f = fmap f . [[-]]
11:03:13 <augur> what you mean is that the haskell definitions of fmap f, then denotation, yield the same thing as the denotation then the DS meanings of fmap f
11:03:15 <augur> yeah?
11:03:27 <lpsmith> dcoutts, so basically what  you are saying is that cabal install is closer to  "cabal build-dependencies && cabal configure && cabal build && cabal copy && cabal register",  and (for whatever reason) the hypothetical build-dependencies is getting hung up even though I already have the dependencies installed...
11:03:52 <augur> like, [[fmap f m]] = [[fmap]] [[f]] [[m]]
11:04:48 <lpsmith> I suppose that makes some sense
11:04:49 <conal> augur: that's the general idea. 
11:05:17 <augur> ok, so its two different fmap f's on the L/RHS of [[-]] . fmap f = fmap f . [[-]]
11:05:24 <conal> augur: not that i'm not addressing the semantics of haskell, though.
11:05:27 <augur> like when we do   f . id = id . f
11:05:34 <mrsolo> so... i need to put up a high performance webapp...
11:05:35 <conal> augur: right! two different fmaps
11:05:37 <augur> what we mean is f . id_A = id_B = f
11:05:45 <augur> er, id_B . f
11:05:51 <mrsolo> which haskell webkit should i use?  i see few competing ones.
11:06:01 <conal> augur: yeah.
11:06:57 <dcoutts> lpsmith: yes
11:07:32 <conal> augur: the trick here is to determine the instances on the data types being defined by translating over the instances on the meanings of the data types.
11:07:34 <lpsmith> I definitely think we need some kind of delineation between "internal" and "external" dependencies though...  I'm definitely tired of network depending on parsec-2 causing headaches
11:08:15 <lpsmith> and I think making an actual build-dependencies command (maybe with a shorter name) would be helpful
11:08:33 <dcoutts> lpsmith: we're working on it for the IHG
11:08:33 <conal> augur: this design methodology gives rise to leak-proof abstractions and guarantees that class laws hold.
11:09:12 <dcoutts> lpsmith: oh, for build dependencies there's a new (in the next release) cabal install --only-dependencies [targets]
11:09:12 <lpsmith> dcoutts, "it" meaning internal dependencies?
11:09:25 <lpsmith> dcoutts, nice.
11:09:30 <dcoutts> lpsmith: right
11:09:30 <augur_> sorry, network issues
11:09:32 <PatrickM> hello all...I'm new to this channel...I joined the channel because I require some help with a couple haskell function...also it is logical that since there is a high number of member activity is high an if you start all taking invetiably it will create confusion..if I share what I have to accomplish and the progress that I've made will someone be wiiling to sacrifice his time for some advice 
11:09:34 <PatrickM> in private.Thank you in advance
11:09:48 <dcoutts> lpsmith: we were thinking about it today, it's surprisingly subtle in its full generality.
11:10:30 <lpsmith> that doesn't surprise me too much,  that there is a few surprises lurking :)
11:11:22 <dcoutts> lpsmith: particularly if you privately depend on something, but also indirectly publicly depend on the same.
11:11:42 <sm> dcoutts: should there be a cabal install --not-dependencies also ?
11:12:07 <dcoutts> lpsmith: this will also necessitate a new solver, so we'll hopefully be able to make it a little smarter at the same time.
11:12:07 <conal> augur: oh, dear. that typo you found is a bug in my type-setting. the latex source says mu (fmap f m) = \ k -> f (mu m k). i have to fix the mu typesetting rules so that the parens don't get lost. wow. i wonder how many places this bug shows up and confused readers. oops.
11:12:14 <sm> or --only-target
11:12:18 <dcoutts> sm: you mean use only installed versions, yes that would make sense too.
11:12:51 <dcoutts> it's in the TODO list
11:13:19 <dcoutts> along with per-package installed constraints
11:13:48 <sm> great to see cabal improving
11:14:13 <sm> is there any target date for a release ?
11:14:22 * dcoutts is pleased to have a bit of time to work on it recently
11:14:26 <augur> conal: do you have an arrow diagram for fmap f . [[-]] = [[-]] . fmap f ?
11:15:19 <conal> augur: i do. but not online. that property is called "naturality" of [[-]]. there are probably scads of pictures on line.
11:16:21 <augur> ok
11:16:22 <conal> augur: it's the most common kind of commuting diagram. 
11:17:02 <conal> augur: you could google for "natural transformation" and "commuting diagram"
11:18:38 <ski>   fmap f . eta_A = eta_B . fmap f
11:19:04 <ski> augur : `fmap f . eta_A = eta_B . fmap f', where `f : A >-> B'
11:19:08 <augur> conal: its not the F(X) --F(f)--> F(Y) ; G(X) --G(g)--> G(Y) diagram is it?
11:19:17 <dcoutts> sm: I need to get a cabal-install release out soonish for the next HP
11:19:32 <sm> cool
11:22:59 <shamster> can anyone diagnose a cabal message from 'cabal update' that reads: cabal: openTCPConnection: host lookup failure for ""
11:23:41 <augur> stupid network >_<
11:23:42 <shamster> I'm guessing I need to set a value for a host or repository somewhere
11:23:45 <augur> conal: i dont really understand this TCM paper :\
11:24:05 <dcoutts> shamster: check your proxy settings
11:24:58 <shamster> dcoutts: I'm not behind a firewall or using any particular proxy
11:25:08 <conal> augur: bummer. maybe i could make it more accessible. it's the paper that most directly tries to convey my software design methodology.
11:25:21 <dcoutts> shamster: check your http proxy env var is not set to ""
11:25:51 <augur> i just dont get how the laws are just guaranteed to be obeyed. it looks like you're just defining type classes and proving the laws are obeyed by some instances
11:26:04 <shamster> dcoutts: what's the name of the var? is it $HTTP_PROXY?
11:26:43 <dcoutts> shamster: or $http_proxy, if that's not it, try cabal update -v3 and see if it has any hints
11:27:13 <shamster> dcoutts: is there a particular way to set $http_proxy?
11:27:15 * hackagebot web-routes 0.23.4 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.23.4 (JeremyShaw)
11:27:40 <shamster> dcoutts: I mean, a particular setting to use?
11:27:48 <dcoutts> shamster: if you don't expect to be using a proxy then neither var should be set
11:29:20 <shamster> dcoutts: thanks! unset http_proxy did the trick
11:30:39 <dcoutts> shamster: ok, thanks, I'll make it report a better error
11:34:37 <Vizard_> hello everybody, i've a question about lazy evaluation. let's say i've this function: {{ head $ map (6 `div`) [6,5..0] }} is "map" only evaluated once? i think yes, isnt it?
11:35:18 <shamster>  Vizard_ my guess is yes
11:35:49 <shamster> Vizard_: but I'd like to hear what others say.
11:36:03 <mauke> > head $ map (6 `div`) (6 : error "bam!")
11:36:03 <lambdabot>   1
11:36:05 <monochrom> yes
11:36:11 <Vizard_> otherwise we would 6 `div` 0 exception
11:36:18 <mauke> > take 2 $ map (6 `div`) (6 : error "bam!")
11:36:19 <lambdabot>   [1*Exception: bam!
11:36:22 <Vizard_> okay thank you :)
11:37:01 <shamster> head $ map (6 `div`) [6,5..0]
11:37:13 <shamster> > head $ map (6 `div`) [6,5..0]
11:37:14 <lambdabot>   1
11:37:45 <homie> is there a git or cvs branch to ghc ?
11:37:56 <homie> i only saw tar.gz packaging
11:38:04 <monochrom> though "is map only evaluated once" is not quite how to phrase the question.
11:40:03 <blueonyx> hi, why does cabal install (in a source dir) reinstall packages i already have with the same version?
11:40:11 <dmead> hi channel
11:40:22 <monochrom> the only cons cell produced is (6 `div` 6 : another unevaluated expression). the only div ever evaluated (even created) is 6 `div` 6. that is the correct way to put it.
11:40:30 <dmead> where would i ask about how ghc desugars things before compilation?
11:40:40 <dcoutts> blueonyx: it's a bug in cabal. It gets confused when the same version of a package is installed multiple times.
11:41:10 <blueonyx> dcoutts: okay i try unregistering multiple version?
11:42:09 <dcoutts> blueonyx: yes
11:42:22 <Vizard_> monochrom: thank you making me this more clear i understand now
11:44:14 <corpumpkin> omg a jmcarthur 
11:47:03 <pastorn> corpumpkin: hide yo wife, hide yo kidz
11:47:20 <jmcarthur> huh didn't realize i was cut off
11:47:23 <monochrom> hide yo self too
11:47:44 <monochrom> hide those that can't be hid
11:47:45 <pastorn> cause jmcarthur be snatchin everybody up here in linkin park
11:47:53 * corpumpkin hides yo self
11:48:45 <jmcarthur> lincoln park
11:48:53 <pastorn> waddevva
11:50:47 <jmcarthur> the location in question is in my city :P
11:50:47 <corpumpkin> jmcarthur: it aint yours, yo
11:52:29 <blueonyx> do even parsec-2.1.0.1 and parsec-3.1.0 trigger this cabal bug?
11:52:51 <dcoutts> blueonyx: no, only the same version installed multiple times
11:53:45 <blueonyx> dcoutts: do they show up twice in ghc-pkg list?
11:55:20 <dcoutts> yes
11:55:32 <dcoutts> blueonyx: usually once in the global section and once in the user section
11:59:59 <blueonyx> dcoutts: thanks so far, will look deeper into it tomorrow
12:10:48 <remy_o> #windows
12:10:53 <jmcarthur> ew
12:11:02 <remy_o> sorry
12:11:05 <jmcarthur> :P
12:11:31 <tg__> burn the witch!
12:11:51 <dcoutts> jmcarthur: now now, we have to be nice to our windows users, even if they're misguided :-)
12:12:39 * fryguybob Wonders if he should stop to ask for directions...
12:12:55 <Eduard_Munteanu> I think they have souls... I think :P
12:13:08 <shachaf> dcoutts: UNIX users are misguided too.
12:15:15 <Elbar> unix belongs to sco ;)
12:15:22 <Elbar> maybe...
12:17:17 <accel> on a single line, can blank spaces mean anthin other than (1) identation or (2) function application?
12:17:58 <byorgey> accel: sometimes they are meaningless, as in the spaces surrounding an =
12:18:08 <mauke> string literal, char literal, comment
12:18:29 <corpumpkin> also, the one thing that has higher precedence than application
12:18:43 <byorgey> record update!
12:18:48 <corpumpkin> yes!
12:20:01 <byorgey>     x = f r { g = ' ' : " " } --    comment
12:20:21 <byorgey> there, that code has at least 7 or 8 different kinds of spaces =)
12:20:34 <saml> that's weird
12:20:39 <saml> what's ' ' : " "
12:20:43 <saml> > ' ' : " "
12:20:44 <lambdabot>   "  "
12:20:55 <accel> noted; thanks :-)
12:20:56 <saml> oh cons. crap haven't used haskell in a while
12:21:07 <shachaf> @let cons = (:)
12:21:07 <mvoelske> Hi all. I'm playing around with composition, and can't figure out why the interpreter rejects the following: (map (\(x,y) -> x+y)) . zip -- any pointers
12:21:08 <lambdabot>  Defined.
12:21:10 <mvoelske> ?
12:21:12 <dcoutts> byorgey: I count 7 I think, if you're counting the space after the --
12:21:25 <jmcarthur> :t (map (\(x,y) -> x+y)) . zip
12:21:26 <lambdabot>     Couldn't match expected type `[(t, t)]'
12:21:26 <lambdabot>            against inferred type `[b] -> [(a, b)]'
12:21:26 <lambdabot>     Probable cause: `zip' is applied to too few arguments
12:21:31 <shachaf> mvoelske: zip is a function of two arguments.
12:21:32 <corpumpkin> mvoelske: you want two parameters to zip
12:21:40 <accel> can = be redefined in haskell?
12:21:43 <mauke> mvoelske: inline (.), see what happens
12:21:46 <jmcarthur> :t \xs -> (map (\(x,y) -> x+y)) . zip xs
12:21:46 <byorgey> accel: no
12:21:47 <lambdabot> forall t. (Num t) => [t] -> [t] -> [t]
12:21:52 <shachaf> @ty (map (\(x,y) -> x + y)) . zip [1,2,3]
12:21:53 <lambdabot> forall t. (Num t) => [t] -> [t]
12:21:54 <saml> mvoelske, you can't do that. that's why
12:21:59 <jmcarthur> :t \xs ys -> (map (\(x,y) -> x+y)) $ zip xs ys
12:22:00 <lambdabot> forall t. (Num t) => [t] -> [t] -> [t]
12:22:01 <mvoelske> ah, of course! thanks!
12:22:04 <byorgey> accel: == can though.
12:22:06 <saml> you're welcome
12:22:18 <shachaf> mvoelske: By the way, there's zipWith.
12:22:22 <shachaf> @ty zipWith
12:22:22 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:22:38 <byorgey> > zipWith (+) [1,2,3] [4,6]
12:22:38 <lambdabot>   [5,8]
12:22:40 <shachaf> > uncurry (+) (1,2) -- Also there's uncurry.
12:22:41 <lambdabot>   3
12:22:48 <accel> > x = 3
12:22:48 <lambdabot>   <no location info>: parse error on input `='
12:22:51 <accel> > let x = 3
12:22:52 <lambdabot>   not an expression: `let x = 3'
12:23:06 <accel> > \x -> x + 3 $ 2
12:23:07 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> b)
12:23:07 <lambdabot>    arising from a u...
12:23:12 <byorgey> > let x = 3 in x + 1
12:23:13 <lambdabot>   4
12:23:20 <accel> byorgey++
12:23:23 <byorgey> > (\x -> x + 3) $ 2
12:23:24 <lambdabot>   5
12:23:25 <accel> > let _X = 3 in _X + 1
12:23:26 <lambdabot>   4
12:23:49 * Eduard_Munteanu wonders if there's an arrow version of WriterT, one that works with HXT
12:24:03 <accel> which standard deines valid haskell varaible names?
12:24:04 * Eduard_Munteanu never looked into arrow transformers though...
12:24:11 <shachaf> accel: The Report.
12:24:17 <drbair_work> my god, there's a lambdabot
12:24:26 <byorgey> Eduard_Munteanu: http://hackage.haskell.org/packages/archive/arrows/0.4.4.0/doc/html/Control-Arrow-Transformer-Writer.html ?
12:24:30 <shachaf> accel: If you're trying to figure out lambdabot's behavior, you might want to use /msg. :-)
12:24:45 <drbair_work> you should get him on twitter for entertainment
12:24:51 <Eduard_Munteanu> byorgey: ah thanks. I wondered because HXT seemingly had its own Arrow implementation.
12:25:16 <byorgey> drbair_work: having her in #haskell seems quite entertaining enough. =)
12:25:30 <byorgey> Eduard_Munteanu: ok, I don't know anything about HXT.
12:25:30 <accel> shachaf: no; I'm trying to figure out what are valid haskell variabla names
12:25:40 <accel> shachaf: contrary to my actions in the past; i'm not trying to abuse lambdabot
12:25:45 <mauke> accel: read the report
12:25:48 <saml> > functional programming
12:25:49 <Eduard_Munteanu> @vixen drbair_work thinks you should be tweeting
12:25:49 <lambdabot> i could really use a backrub
12:25:50 <lambdabot>   "can do"
12:25:56 <accel> mauke++
12:26:03 <saml> @mauke++
12:26:03 <lambdabot> Unknown command, try @list
12:26:04 <accel> mauke: http://www.haskell.org/onlinereport/ ?
12:26:08 <mauke> accel: yeah
12:26:17 <Eduard_Munteanu> saml: @karma ?
12:26:22 <mauke> accel: lexical structure
12:26:36 <Eduard_Munteanu> @karma mauke
12:26:36 <lambdabot> mauke has a karma of 29
12:26:40 <saml> are you interested in embeddable purely functional programming language that interfaces with C well?
12:26:46 <accel> mauke: http://www.haskell.org/onlinereport/syntax-iso.html ?
12:26:49 <accel> mauke: oh, wrong section
12:27:07 <mauke> preflex: karma mauke
12:27:07 <preflex>  mauke: 546
12:27:16 <mauke> preflex: karma C
12:27:16 <preflex>  C: 162450
12:27:23 <saml> preflex, karma java
12:27:23 <preflex>  java: -32
12:27:26 <Eduard_Munteanu> mauke: hm, lambdabot thinks less of you
12:27:48 <mauke> lambdabot is forgetful
12:27:57 <shachaf> @flush
12:27:58 <lambdabot> Not enough privileges
12:27:58 <ddarius> @karma lwall
12:27:58 <lambdabot> lwall has a karma of 530
12:28:00 <mauke> also, shares fewer channels with me
12:28:10 <Eduard_Munteanu> Not enough minerals
12:28:16 <accel> need mroe vespene gas
12:28:21 <mauke> @flosh
12:28:21 <lambdabot> Not enough privileges
12:28:25 <Eduard_Munteanu> :)
12:28:33 <accel> is <*> considred a variable or a function name?
12:28:46 <mauke> @flosh
12:28:47 <monadic_kid> :t (<*>)
12:28:47 <Eduard_Munteanu> accel: it's a function
12:28:48 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:28:53 <mauke> fixed.
12:28:54 <shachaf> accel: You should read the report, as was suggested. :-)
12:29:04 <Eduard_Munteanu> accel: it's not special syntax
12:29:12 <accel> shachaf: I am reading it
12:29:13 <byorgey> accel: there is no dichotomy between 'variables' and 'functions'
12:29:18 <shachaf> accel: "variable name" and "function name" aren't mutually exclusive; names /= values.
12:29:23 <accel> shachaf: http://www.haskell.org/onlinereport/syntax-iso.html in paritcular
12:29:29 * hackagebot vacuum-cairo 0.5 - Visualize live Haskell data structures using vacuum, graphviz and cairo  http://hackage.haskell.org/package/vacuum-cairo-0.5 (DonaldStewart)
12:29:33 <accel> however, I can't find a cfg or regex
12:29:37 <accel> describing all valid varaiblenames
12:29:45 <accel> the closest I have is this:
12:29:47 <accel> varid  ->  (small {small | large | digit | ' })<reservedid>
12:29:50 <Eduard_Munteanu> Erm, EBNF description?
12:29:56 <accel> which doesn't explain to me how <*> is a valid variable name
12:30:03 <byorgey> accel: it is an operator
12:30:05 <accel> thus the question on separation of variablefunction names
12:30:51 <Eduard_Munteanu> '<' is a "small" symbol
12:31:02 <byorgey> Eduard_Munteanu: no it isn't.
12:31:13 <byorgey> there is a separate production somewhere defining valid operator names.
12:31:23 <accel> question: what EBNF on that page ends up getting matched to <*> ?
12:31:33 <saml> what page?
12:31:35 <Eduard_Munteanu> Oh so for infixes you can have capital symbols?
12:31:41 <ddarius> Eduard_Munteanu: Yes.
12:31:43 <saml> <*> should be operator
12:31:45 <accel> http://www.haskell.org/onlinereport/lexemes.html
12:31:51 <ddarius> Eduard_Munteanu: (:) is an example.
12:32:27 <parcs> @hoogle (a -> Bool) -> [a] -> ([a],[a])
12:32:27 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
12:32:28 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
12:32:28 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
12:32:36 <saml> why is syntax so complicated?  can't it be whitespace deliminated tokens? except for string literal
12:32:46 <drbair_work> Would haskell be suitable for writing a (educational) distributed DBMS? 
12:32:57 <mauke> saml: enjoy your ( + )
12:33:05 <shepheb> does anyone know of an attempt to compile GHC itself into an LLVM binary? or at least the RTS?
12:34:13 <saml> a + b    Vs.    a+b   I think a+b should be an identifier
12:34:18 <Eduard_Munteanu> I kinda get they wanted type variables, types and functions to be readily-visible, but yeah, it kinda gets complicated
12:34:35 <mauke> saml: I think [a] shouldn't
12:35:01 <saml> [ a ]   looks more professional and web scale
12:35:24 <byorgey> needs more gradients
12:35:42 <mauke> f ( x @ Foo { bar = baz } ) = wat
12:35:56 <ocharles> Hrm, is the state of the art with respect to C++ FFI still to write a C adapter first?
12:40:15 <hpc> ocharles: it seems, if you can interface with it from C, you can interface with it from the rest of the worls
12:40:21 <hpc> *world, so yes
12:41:01 <ocharles> right
12:41:13 <ocharles> I just wondered if the cplusplus calling directive had been implemented by anything yet
12:42:01 <systemfault> ocharles: The problem with C++... the conventions differ from compiler to compiler
12:42:03 <monadic_kid> ocharles: SWIG could automate the C++ to C interface
12:42:34 <ocharles> monadic_kid: oh? I've only heard the name, never really tried using it
12:43:11 <ocharles> I might start 'simple' by rolling my own, and when I start to get the feel of things, maybe investigate SWIG
12:46:39 <kelvie_> is it normal for HXT to eat 3.5 gigs of memory just printing out children nodes of a 13 meg XML file?
12:48:59 <Eduard_Munteanu> HXT seemed kinda slow to me too.
12:49:24 <Eduard_Munteanu> I'm considering switching over to plain Tagsoup or something like that.
12:49:30 <kelvie_> Yeah, I just found a 3 year old thread on haskell-cafe that said it's cause it's not incremental
12:49:48 <kelvie_> Which is a shame, I was looking forward to playing with arrows
12:50:08 <Eduard_Munteanu> I think it builds a complete tree-like representation of the document before even doing any user work.
12:50:26 <kelvie_> At first glance, it seems that 4 gigs for a 30M file is a bit excessive
12:50:27 * Eduard_Munteanu could be wrong though
12:50:34 <kelvie_> But yeah, I could be wrong too
12:50:43 <Eduard_Munteanu> kelvie_: are you sure you're not running it in strict mode?
12:50:50 <hpc> 4 gigs is a shitload of overhead, even for must making the whole tree to start
12:50:55 <hpc> *just
12:51:10 <kelvie_> Sorry, the file's not even 20MB
12:51:12 <kelvie_> Hmm
12:51:20 <kelvie_> http://www.mail-archive.com/haskell-cafe@haskell.org/msg36798.html
12:51:35 <kelvie_> ^ a three year old thread, I wonder if it's still relevant
12:51:57 <Eduard_Munteanu> kelvie_: is the program actually eating that much at any instant, or is it some random stat from '+RTS -s'?
12:52:13 <kelvie_> Eduard_Munteanu: Yeah, from what htop is telling me
12:52:35 <kelvie_> Haxml's Xtract tool seems to have similar memory usage stats
12:52:38 <Eduard_Munteanu> kelvie_: could you profile it?
12:52:49 <Eduard_Munteanu> Maybe you did something wrong there.
12:53:24 <kelvie_> My own program? :P
12:53:31 <malcolmw> There is an Xtract-lazy tool in HaXml
12:53:37 <kelvie_> malcolmw: Yeah, they don't differ by much
12:53:49 <Eduard_Munteanu> Yes. You'll need profiling enabled in the libs build though, if you got them through Cabal
12:53:59 <kelvie_> Thankfully I build all my libs with profiling
12:54:35 <Eduard_Munteanu> kelvie_: just ghc -O --make [whatever] -prof -auto-all -caf-all   then start the program with '+RTS -p'
12:54:46 <kelvie_> Eduard_Munteanu: thanks, was just trying to look up the flags :P
12:55:12 <Eduard_Munteanu> It'll then output profiling info into a .prof file
12:55:15 <saml> is there programming language channle?
12:56:00 <Eduard_Munteanu> saml: what do you mean, a general (non-specific) channel for programming languages?
12:56:15 <kelvie_> It ran out of memory profiling and I think the kernel killed it
12:56:26 <Eduard_Munteanu> Did you get a profile?
12:56:35 <kelvie_> Just an empty file :/
12:56:37 <saml> Eduard_Munteanu, yah and compiler writing
12:56:41 <kelvie_> I'll try a smaller XML
12:56:59 <kelvie_> I have 8G of RAM too
12:58:02 <j-invariant> Is there an optimized librarly on hackage for generating testing primes and factoring into primes?
12:58:04 <Eduard_Munteanu> kelvie_: or maybe killing it yourself with ctrl+c does it
12:58:09 <j-invariant> I need the fast algorithms
12:58:34 <kelvie_> http://hpaste.org/44016/hxt_parsing_a_5mb_xml_file
12:59:41 <Eduard_Munteanu> kelvie_: what's your SysConfig or options passed to HXT?
12:59:53 <shamster> is there an easy way to get a copy of a record type but change one of the values? (i.e. data RecordType = RecordType { a :: Int, b :: Double, c :: String })
13:00:01 <kelvie_> Eduard_Munteanu:  withValidate no, withCanonicalize no
13:00:11 <remy_o> x -> x{a = 3}
13:00:12 <kelvie_> It doesn't differ much if I use no options
13:00:17 <Eduard_Munteanu> kelvie_: hrm, that looks fine.
13:00:25 <kelvie_> I'll post my code
13:00:41 <kelvie_> It's absurdly simple
13:00:55 <kelvie_> http://hpaste.org/44017/hxt_code
13:00:57 <shamster> remy_o: thanks
13:00:59 <remy_o> > let x = Record { a = 1, b = 2 } :: Record {a :: Int, b :: Int} in x { a = 2}
13:00:59 <lambdabot>   Not in scope: type constructor or class `Record'Not in scope: `a'Not in sco...
13:01:40 <kelvie_> Oh well, I guess the solution is to use tagsoup or something
13:02:26 <monochrom> how large is your xml file? should work for small files
13:02:34 <kelvie_> monochrom: from 5MB to 20MB
13:03:00 <kelvie_> I'm trying to generate haskell bindings to Qt Declarative
13:03:04 <monochrom> I see, that may count as large. hxt doesn't use a very compact data structure.
13:03:09 <kelvie_> So I used gcc_xml to dump the AST into xml
13:03:16 <kelvie_> Yeah, I think it would qualify as large :P
13:04:06 <monochrom> in particular [Char] for tag names isn't very compact. also hxt doesn't try to reuse common tag names.
13:04:15 <j-invariant> What's the best lib for factoring numbers and generating primes and testing if a number is prime?
13:04:33 <Eduard_Munteanu> BTW, any alternative to HXT? I'm mainly interested in fast XPath lookups.
13:04:51 <Eduard_Munteanu> Tagsoup could do, but an XPath interface would be sweeter.
13:04:54 <kelvie_> Yeah, same
13:04:59 <monochrom> so one million <xxx/>'s will faithfully become one million copies of "xxx" which kills memory quickly
13:05:20 <kelvie_> I wonder how well the python xml parser performs for this task..
13:06:23 <monochrom> well first of all one million pointers to one singleton of "xxx" already improves drastically, and much do-able in imperative settings such as python.
13:06:58 <monochrom> secondly python's string is probably more compact than haskell's string
13:07:06 <kelvie_> I just need to quickly visualize this XML structure, so I figured a quick tool in HXT would do the job
13:07:12 <kelvie_> At least it was easy to write :P
13:07:20 <kelvie_> And it does do the job, in fact
13:07:27 <kelvie_> It's just that using 4G of memory scares me a little
13:08:36 <Eduard_Munteanu> The arrow-y thingy is cute, though it kinda bugs me since I haven't had a serious look at those.
13:08:38 <monochrom> probably modifying HXT to s/String/Text/ solves it.
13:09:56 <kelvie_> Interesting.
13:10:04 <kelvie_> Should this be discussed elsewhere? On the list?
13:11:34 <monochrom> Text is essentially 2 bytes per character plus O(1) overhead for each long chunk. String is 4 bytes (for real data) plus 1-4 bytes (for "I am a cons cell") plus 1 or 2 pointers (1 to point to real data, 1 to point to next cons cell or nil cell) per character.
13:12:34 <c_wraith> that doesn't match what I've heard for String from Simon M
13:13:06 <c_wraith> all Char values are shared.  Somehow.
13:14:00 <c_wraith> That leaves one word for the constructor tag for the cons cell, one word for the pointer to the Char, one word for the pointer to the tail of the list
13:14:42 <monochrom> literals sure. I'm skeptic that characters obtained from runtime user are also shared.
13:15:11 <c_wraith> So, three words per character...  12 bytes on a 32-bit ghc, 24 bytes on 64-bit ghc
13:15:24 <c_wraith> four words per character if they aren't shared
13:16:22 <c_wraith> In other words...  String is not only not memory efficient, it's so far from it that it doesn't understand the concept
13:16:41 <monochrom> @quote anthropo
13:16:41 <lambdabot> Aaron_Denney says: "Don't anthropomorphize computers.  They hate it when you do that."
13:16:45 <monochrom> hehe
13:17:01 <j-invariant> Anyone know a good lib for factoring into primes and generating primes?
13:17:01 <c_wraith> They'll just have to put up with it
13:17:10 * ClaudiusMaximus fairly sure that [Int] is around 40 bytes * length of list on 64bit, given the heap profile output from a test program
13:18:46 <shamster> if I have 'a :: Integer', is there a way to use 'drop (a*3) list' without the compiler complaining about the Int/Integer inference/expectation?
13:19:29 <luite_> shamster: Data.List.genericDrop
13:19:35 <Eridius> shamster: what if you use (fromInteger (a*3)) instead?
13:19:39 <shamster> luite_: thanks
13:19:47 <shamster> Eridius: I'm not sure, let's see!
13:19:52 <luite_> shamster: there are more generic functions in Data.List that take any Integral, instead of Int
13:20:15 <shamster> luite_: that's what I was looking for, thanks
13:21:43 <ClaudiusMaximus> > take ((maxBound`div`2) * 3) [1 ..]
13:21:44 <lambdabot>   []
13:30:39 <j-invariant> Anyone know a good lib for factoring into primes and generating primes?
13:32:24 <Tomsik> Well, generating primes isn't that hard I think, you just pick number randomly and then check if it's prime
13:32:27 <Tomsik> until it is
13:32:30 <j-invariant> I want a library
13:32:58 <j-invariant> I don't find any efficecint code
13:33:35 <kulakowski> j-invariant: How large of primes?
13:33:41 <j-invariant> all of them
13:35:41 <siracusa> @hackage primes
13:35:41 <lambdabot> http://hackage.haskell.org/package/primes
13:35:51 <siracusa> j-invariant: ^^
13:36:55 <roconnor_> @free foo :: F a -> G a
13:36:55 <lambdabot> $map_G f . foo = foo . $map_F f
13:39:56 <benny99> probably a dumb question, but what's wrong with the code ?  data NatN = Zero | Succ NatN \\ type One = Succ Zero
13:40:16 <remy_o> you don't do type One = Succ Zero
13:40:23 <remy_o> you just do One = Succ Zero
13:40:33 <j-invariant> no you don't 
13:40:34 <remy_o> One is not a type
13:40:38 <j-invariant> One is not a value
13:41:10 <roconnor_> Zero is a constructor
13:41:16 <roconnor_> Succ is a constructor
13:41:30 <acowley> More specifically, they are data constructors
13:41:38 <corpumpkin> one = Succ Zero
13:42:30 <benny99> thanks :)
13:43:18 <corpumpkin> @free moo :: a -> f a
13:43:19 <lambdabot> Extra stuff at end of line
13:43:21 <corpumpkin> @free moo :: a -> F a
13:43:22 <lambdabot> $map_F f . moo = moo . f
13:44:47 <shepheb> has anyone ever tried to build GHC itself with the LLVM backend, or at least to port the RTS?
13:45:41 * roconnor_ finds it difficult to come up with good naming conventions for sorts of variables.
13:49:55 <monochrom> > let self = const True self in self
13:49:55 <lambdabot>   True
13:50:45 * monochrom 's first suggestion to roconnor_ : use oleg'case :)
13:51:24 <Ptival> @pl \x y -> (x, y)
13:51:24 <lambdabot> (,)
13:51:35 <Ptival> @pl \x y -> (x, x+1)
13:51:36 <lambdabot> const . ap (,) (1 +)
13:51:36 <saml> > (,) "you" "me"
13:51:37 <lambdabot>   ("you","me")
13:51:49 <Ptival> @pl \x -> (x, x+1)
13:51:49 <lambdabot> ap (,) (1 +)
13:59:26 <saml> > (,) . .
13:59:27 <lambdabot>   <no location info>: parse error on input `.'
14:00:49 <powersurge> hi guys. Haskell scrub here. Can anyone tell me what the issue is with this simple function? http://pastebin.com/L1Pmp1iG
14:01:28 <powersurge> I can get it to work with addNumbers [] = errors "Nothing to add!" but I thought I could do it without throwing an exception. Am I mistaken?
14:01:57 <mauke> addNumbers [] = 0
14:02:02 <mauke> and remove line 3
14:02:02 <powersurge> oh wait, is it because I'm recursing and it can potentially have an empty list?
14:02:06 <powersurge> yeah :>
14:02:19 <powersurge> the light bulb turned on just as you replied, thanks
14:02:23 <mauke> addNumbers = sum
14:02:25 <mauke> BAM
14:02:41 <powersurge> I know the function probably already exists
14:02:42 <roconnor_> using the free theorem of a natural transformation for reasoning about code feels like cheating
14:02:53 <powersurge> I'm still in the early stages of learning the language though
14:02:57 <powersurge> learning syntax and stuff
14:03:14 <roconnor_> Swapping eta . fmap g into fmap g . eta feels so wong
14:03:15 <Eridius> powersurge: the "obvious" error in your code is the first case (addNumbers [] = []) doesn't match the type of the function
14:04:20 <powersurge> Haskells weird man
14:04:25 <saml> powersurge, i'm a woman
14:04:32 <saml> addNumbers [] = 0
14:04:53 <powersurge> whereas most programming languages are like driving instructions, Haskell's like mathematical proof writing
14:04:57 <powersurge> I know now :>, thanks
14:05:08 <saml> addNumbers (x:xs) = x + addNumbers xs     -- will this be tail call optimized in haskell?
14:05:16 <roconnor_> I'm also using a strange lemma that states that x = y iff forall f g. f (g x) = f (g y)
14:05:22 <saml> like transform that to tail recursion using accumulator...etc
14:05:29 <corpumpkin> saml: no
14:05:35 <powersurge> yeah, I could use a fold
14:05:37 <corpumpkin> it can't do magic :P
14:05:40 <saml> can all recursion be transfromed to tail call?
14:05:45 <roconnor_> no
14:05:56 <corpumpkin> roconnor_: why f AND g?
14:06:23 <corpumpkin> roconnor_: also, = using itself recursively?
14:06:24 <corpumpkin> :P
14:06:57 <corpumpkin> so f (g x) = f (g y) iff forall a b. a (b (f (g x))) = a (b (f (g y)))
14:07:07 <roconnor_> corpumpkin: cause my eventually goal is to prove something of the form (expr1 = expr2 iff forall f g. expr3 = expr4) and I need a way of introducing the quantification over f and g, and this is how I've ended up doing it
14:07:33 <lowasser> What is proper procedure if -fllvm results in a segfaulting program and -fasm doesn't?  (A bug report?  Where?)
14:07:50 <corpumpkin> lowasser: the ghc bugtracker?
14:07:50 <powersurge> well, thanks for the help you guys (and girls) so long
14:07:53 <roconnor_> corpumpkin: one direction is easy, and the other direction is easy by setting f and g to id.
14:08:00 <lowasser> mkay
14:08:15 <lowasser> I suppose first I have to isolate the bug from this huge program  -_-
14:08:33 <corpumpkin> you don't have to, but there's a higher likelihood of it getting fixed if you do
14:10:23 <sgronblo> I seem to be getting this "occurs check: can't construct the infinite type" all the time
14:10:51 <mauke> that probably means you're confusing a list with a list element
14:11:03 <corpumpkin> sgronblo: don't construct infinite types and you won't get it!
14:11:48 <sgronblo> Somehow I just can't stop doing it
14:11:53 <mauke> > let xs = [xs] in 42
14:11:54 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
14:12:08 <corpumpkin> sgronblo: find your local Infinite Typists Anonymous
14:12:14 <saml> roconnor_, do you have an example of recursion that cannot be transformed to tail call?
14:12:16 <Eduard_Munteanu> > let f a b = id in 42
14:12:17 <lambdabot>   42
14:12:18 <saml> mutual recursive?
14:12:47 <mauke> saml: tree walk
14:12:59 <Eduard_Munteanu> Anyway, it can happen when mixing up arguments too, IIRC.
14:13:37 <fryguybob> > let f = f f in 42
14:13:38 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t
14:13:47 <saml> mauke, thanks
14:13:57 * saml converts tree walk to tail call
14:14:13 <sgronblo> I'm sure a more skilled haskell programmer could tell what's wrong with my function in seconds, but I'd like to learn how to debug these infinte type errors by myself.
14:14:15 <roconnor_> saml: any operation on an infinite list
14:14:35 <saml> i dn't get it... that's just loop
14:14:49 <saml> you can walk tree or work on infinite list in a loop..
14:15:21 <corpumpkin> saml: (for the tree) not without emulating the stack 
14:15:24 <remy_o> saml : let f n = (f (n-1) + f (n-2)) in f 5
14:15:26 <Eduard_Munteanu> Well it doesn't mean it's tail-call recursive.
14:16:00 <Eduard_Munteanu> TCO turns recursion into iteration, but you don't have to have a TC-recursive function to start with
14:16:33 <saml> so can every recursion be transformed to loop?
14:16:41 <Eduard_Munteanu> Yeah.
14:16:46 <saml> can compiler do that? every recursion to loop.
14:16:48 <corpumpkin> sure, you just introduce a stack-like thing to simulate your stack
14:16:51 <saml> for fast execution
14:16:55 <roconnor_> saml: what do you think GHC does :P
14:17:03 <remy_o> saml: transforming recursion to iteration is what compilers do all the time
14:17:18 <saml> then why do i get stack overflow sometimes?
14:17:28 <saml> because stack simulation overflows?
14:17:42 <Eduard_Munteanu> Because you'd need some sort of stack anyway
14:17:43 <remy_o> because memory is not infinite
14:17:47 <Eduard_Munteanu> Or that.
14:17:52 <saml> hrm..
14:17:54 <roconnor_> saml: tail recursion doesn't cause stack overflows in Haskell IMHO (though others disagree with me)
14:18:14 <corpumpkin> strict tail recursion
14:18:20 <saml> i should think about this
14:18:21 <saml> thanks
14:18:31 <Eduard_Munteanu> I suppose thunks can still build up in the non-strict case.
14:18:46 <roconnor_> saml: In haskell there is no stack push upon entering a function
14:19:02 <corpumpkin> non-strict tail recursion does cause stack overflows, and you can argue it doesn't, but it's like setting up a huge house of cards next to someone's door
14:19:07 <corpumpkin> and claiming it's not your fault when it falls over
14:19:09 <roconnor_> so "tail-recursion" is something we don't care about since there is no stack push there.
14:19:13 <j-invariant> correct
14:19:32 <saml> oh
14:19:40 <saml> ok i'll think about it on my way home
14:19:50 <roconnor_> in GHC a stack push is done upon entering a case expression
14:20:15 <roconnor_> now, often the first thing  a function does is enter a case expression (usually implictly through a pattern match) but not always
14:21:36 <sgronblo> What's haskell doing when it's generalising types?
14:22:02 <roconnor_> principle type inference?
14:22:09 <mauke> principal
14:22:13 <Clex> Can someone explain to me what's wrong with something like that http://hpaste.org/44020/tuple ?
14:22:14 <roconnor_> ah
14:22:28 <mauke> Clex: the 0 makes no sense
14:22:36 <mauke> Clex: getStr has the wrong type
14:22:48 <mauke> Clex: what is that supposed to do?
14:23:00 <remy_o> Clex: you seem to be confusing with imperative programming
14:23:08 <Eduard_Munteanu> That should be a let, not a '<-' statement
14:23:12 <Clex> I'd just like to return a tuple from a function a read its content.
14:23:25 <remy_o> Clex: you have no function here
14:23:27 <Eduard_Munteanu> Then getStr = return ...
14:23:30 <mauke> let (str1, str2) = getStr
14:23:39 <monochrom> type inference just solves constraints without extra specialization.
14:23:49 <remy_o> no need for a return in functions
14:24:01 <remy_o> you just put the value on the right hand side
14:24:31 <Clex> let (str1, str2) = getStr
14:24:36 <Clex> It's better like that. =)
14:24:47 <Clex> Sorry I'm beginning with Haskell.
14:24:56 <Eduard_Munteanu> That won't do if getStr becomes monadic in future.
14:25:34 <Eduard_Munteanu> Clex: you should try writing type sigs in your code
14:25:36 <monochrom> how about getStr = return ("toto", "titi"). then you can <- getStr
14:26:22 <sgronblo> Are the line numbers for the infinite type errors reliable?
14:26:23 <Clex> Oh, to use a "<-" a need a "return"?
14:26:49 <monochrom> this also scales well later when getStr becomes getStr = do { x<-getLine; y<-getLine; return (x,y) }, you won't need to change main.
14:26:55 <Eduard_Munteanu> Clex: you should be aware how do notation is desugared.
14:26:58 <mauke> Clex: well, "<-" is a kind of "extract" operation, and return is a "wrap"
14:27:22 <Eduard_Munteanu> a <- foo; f a   becomes  foo >>= \a -> f a
14:27:41 <Eduard_Munteanu> So it works only with monadic values
14:27:55 <Eduard_Munteanu> In your case IO (String, String)
14:28:15 <Clex> Ok, ok.
14:28:30 <remy_o> Clex: maybe you should begin with "main = print result" and work with pure functions first, to get a grip
14:28:50 <shachaf> Yes; IO is evil.
14:28:59 <shachaf> Just use ghci. :-)
14:29:11 <Eduard_Munteanu> Meh in this case it sounds like arguing monads are evil :P
14:29:17 <Clex> shachaf: then why do you use IRC? :p
14:29:24 <shachaf> Eduard_Munteanu: Monads are great!
14:29:30 <shachaf> Eduard_Munteanu: Just IO is the problem.
14:29:30 <monochrom> shachaf is also evil.
14:29:55 * shachaf has been found out.
14:30:07 <Eduard_Munteanu> http://lcamtuf.coredump.cx/evilfinder/ef.cgi?said=shachaf
14:30:24 <monochrom> "I once was lost, and now am found" :)
14:30:38 <monochrom> "was bind, but now, return"
14:31:31 <sgronblo> http://pastebin.com/zkH3mBn0 all right I give up, why is there an infinite type on line 5...
14:32:21 <shachaf> sgronblo: Because the function should take three arguments but only takes two.
14:32:30 <shachaf> Er, never mind.
14:32:49 <mauke> sgronblo: leftList ++ rightHead makes no sense
14:32:59 <lowasser> augh this is so weird
14:33:03 * shachaf apparently can't read today.
14:33:13 <shachaf> What mauke said.
14:33:24 <lowasser> when compiling with -fllvm, adding a traceShow and nothing else stops my program from segfaulting
14:34:59 <Eduard_Munteanu> lowasser: that's not uncommon in case pointers go awry or the compiler makes mistakes.
14:35:33 <lowasser> I mean, sure, case 2, but case 1?
14:35:38 <lowasser> it doesn't segfault with -fasm
14:35:47 <lowasser> and adding the traceShow with -fllvm makes it work,  correctly
14:36:35 <sgronblo> mauke: thanks
14:37:09 <sgronblo> but then that line number for the error message was completely unreliable, haskell was saying the first definition of mysplit' had the error
14:37:29 <mauke> s/haskell/ghc/
14:37:46 <mauke> what was the exact error message?
14:38:16 <sgronblo> haskell-99.hs|7 error|  Occurs check: cannot construct the infinite type: a = [a]
14:38:19 <sgronblo> ||     When generalising the type(s) for `mysplit''
14:38:48 <mauke> |7 error|?
14:38:54 <mauke> that doesn't look like a ghc message to me
14:39:09 <sgronblo> Well it's actually from vim's errorformat
14:39:22 <mauke> ...
14:39:35 <sgronblo> But ghci says the same thing
14:39:39 <mauke> it probably refers to the entire function definition
14:39:40 <McManiaC> parallel/zip statements for monad comprehensions: http://npaste.de/xn/
14:39:41 <McManiaC> :)
14:39:45 <sgronblo> the location is just formatted differently
14:40:06 <mauke> it's generalizing the type, i.e. trying to unify all equations and computing the most general shared type
14:40:56 <sgronblo> but shouldn't this be a type error ++ doesn't work for [a] and a?
14:41:25 <Eduard_Munteanu> McManiaC: aren't those plain list comprehensions?
14:41:30 <mauke> my guess is that it doesn't know the types are [a] and a at that point
14:41:37 <Eduard_Munteanu> They don't seem to be generalized monad comprehensions to me.
14:42:06 <McManiaC> Eduard_Munteanu: since I use lists for my example - yes
14:42:06 <McManiaC> :P
14:42:11 <Eduard_Munteanu> Ah.
14:42:17 <McManiaC> but the whole compiler backend is differently
14:42:25 <McManiaC> "backend"
14:42:33 <McManiaC> typechecking/desugaring/functions used etc.
14:42:48 <sgronblo> mauke: Shouldn't ghc be able to figure out from mylist's type constraint that leftList is [a] and rightHead is a?
14:43:01 <Eduard_Munteanu> I would've suspected the list comprehension thingy was merely a restriction, since monad comprehensions are kinda old in GHC.
14:43:15 <mauke> I don't know in which order the constraints are applied
14:43:17 <McManiaC> Eduard_Munteanu: it isn't
14:43:32 <shachaf> sgronblo: Unless it tries a = [a], which is an infinite type.
14:43:35 <McManiaC> GHC is using cons/nil etc
14:43:40 <McManiaC> for list comprehensions
14:43:41 <Eduard_Munteanu> Hm.
14:44:00 <McManiaC> and is always assuming list type constructors etc
14:44:01 <Eduard_Munteanu> But didn't a very old GHC have monad comprehensions too?
14:44:08 <shachaf> McManiaC: We're getting monad comprehensions back?
14:44:12 <Eduard_Munteanu> I thought it was removed at some point.
14:44:16 <monochrom> bear in mind that GHC assumes you are a pro
14:44:17 <McManiaC> Eduard_Munteanu: yes, it got removed
14:44:24 <mauke> Captain America is coming back to earth?!
14:44:27 <sgronblo> urhrm? well thanks anyway. gotta go to bed.
14:44:30 <Clex> \o/ I finally managed to do something that kinda works.
14:44:33 <Eduard_Munteanu> Ah I assumed "removed" meant it was merely a restriction, a check.
14:44:45 <shachaf> McManiaC: What does the parallel/zip syntax mean in a general monad context?
14:44:47 <sgronblo> I guess I should start double checking my use of ++ in the future
14:44:47 <McManiaC> shachaf: http://hackage.haskell.org/trac/ghc/ticket/4370
14:45:06 <Eduard_Munteanu> I wonder what SQL-like comprehensions mean in the context of general monad comprehensions :P
14:45:15 <Eduard_Munteanu> (yes, we have SQL-like comprehensions :D)
14:45:33 <McManiaC> shachaf: there's a new typeclass "MonadZip" which defines a "zipM :: m a -> m b -> m (a,b)" function. so if your monad is instance of MonadZip you can use parallel comprehension
14:45:34 <hpc> wait, what?
14:45:42 <hpc> SQL has comprehensions?
14:45:55 <Eduard_Munteanu> hpc: read "comprehensions that look like SQL queries"
14:45:59 <hpc> ah
14:46:06 <monochrom> ama-zing Do, how sweet, the form; that lets, me write, like C; I once, was lost, but now, am found; was bind, but now, I <-
14:46:26 <hpc> i think SQL is a nice model for pulling data from arbitrary data structures
14:46:46 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html   -- grep for 'SQL'
14:46:48 <ocharles> Alright! My little Xapian C wrapper/FFI in Haskell works! Could I get some feedback on both the API, and my general code here - https://gist.github.com/828484 ?
14:46:51 <McManiaC> hpc: my colleagues and I are working on it :)
14:46:59 <ocharles> I'm mostly just copying the style from Real World Haskell's FFI chapter
14:47:23 <ocharles> it's all horribly stuck in the IO monad with nothing pure, which is a real shame
14:47:44 <ocharles> but I guess that's just how it is when you're wrapping something that's all about getters/setters and mutable state
14:48:08 <hpc> ocharles: if all you need is refs, ST might be worth a look
14:48:20 <ocharles> hpc: what/where is ST?
14:48:25 <ocharles> the ST monad is that?
14:48:27 <hpc> (i don't suggest changing all those types now, but it would be good to learn)
14:48:30 <Eduard_Munteanu> Yes.
14:48:37 <ezyang> remind me: what was the way to look at the type signature of a non-top-level binding? 
14:48:48 <ocharles> Ah, I saw that somewhere in the wiki as an alternative to unsafeIO or whatever that function is called
14:48:52 <hpc> ST is kind of like IO that you can pull a final value out of
14:48:59 <Eduard_Munteanu> @hoogle runST
14:48:59 <lambdabot> Control.Monad.ST runST :: ST s a -> a
14:48:59 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
14:48:59 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
14:49:03 <hpc> you mutate within the ST monad
14:49:08 <hpc> then pull the final pure value out
14:49:19 <Eduard_Munteanu> And you also need Data.STRef
14:49:20 <lowasser1> http://www.haskell.org/haskellwiki/Monad/ST
14:49:29 <Eduard_Munteanu> @hoogle readSTRef
14:49:30 <lambdabot> Data.STRef readSTRef :: STRef s a -> ST s a
14:49:30 <lambdabot> Data.STRef.Lazy readSTRef :: STRef s a -> ST s a
14:49:33 <ocharles> Hrm. so newDocument and addPosting would happen within the ST monad, and then I pull the final document out or something?
14:50:29 <Eduard_Munteanu> ocharles: yes, you manipulate state then you can extract a final value
14:50:32 <Clex> Is it possible to split long constant strings on many lines?
14:50:35 <ocharles> stuff like addDocument I see needing to be in the IO monad because that does real I/O
14:50:49 <Eduard_Munteanu> Clex: ++ ?
14:50:52 <ocharles> Eduard_Munteanu: interesting. it makes me feel a little uneasy, but I will have to do some reading about it
14:50:55 <Clex> With ++, yes. =)
14:51:07 <Eduard_Munteanu> ocharles: it's just like IO wrt Refs
14:51:24 <ocharles> Eduard_Munteanu: right, I guess it's the whole extracting a value thing that feels a bit weird
14:51:35 <ocharles> just once I was getting used to how io sequencing happened
14:51:43 <lowasser1> it's the same kind of sequenciing
14:51:48 <Clex> Thanks Eduard_Munteanu.
14:51:48 <ocharles> right
14:51:50 <hpc> ST is the same concept as IO
14:51:53 <lowasser1> just with type system magic that lets you say "this is actually pure"
14:52:03 <lowasser1> and have it be provably true
14:52:26 <ocharles> but this isn't really pure. In C++ it's: document->add_posting("posting here"). should that be treated as pure?
14:52:36 <Eduard_Munteanu> > print (runST $ do x <- newSTRef 5; modifySTRef x (+1); readSTRef x >>= return)
14:52:38 <lambdabot>   <IO ()>
14:52:53 <ocharles> it changes the document, it seems like it would be right to have my haskell code return a new document, even if it was just faking it and refering to the same pointer
14:52:54 <monochrom> > runST (return ())
14:52:55 <lambdabot>   ()
14:53:08 <monochrom> > (runST $ do x <- newSTRef 5; modifySTRef x (+1); readSTRef x >>= return)
14:53:09 <Eduard_Munteanu> > print (runST $ do (x <- newSTRef 5; modifySTRef x (+1); readSTRef x >>= return))
14:53:09 <lambdabot>   6
14:53:10 <lambdabot>   <no location info>: parse error on input `<-'
14:53:28 <Eduard_Munteanu> Ah, it didn't like print?
14:53:44 <monochrom> it likes print
14:53:49 <Eduard_Munteanu> > print 6
14:53:50 <lambdabot>   <IO ()>
14:53:51 <monochrom> > print "<IO ()>"
14:53:52 <lambdabot>   <IO ()>
14:53:53 <Eduard_Munteanu> Ah.
14:53:54 <monochrom> works
14:54:18 <ocharles> likewise, newDocument returns different documents on each invocation, so treating it as pure doesn't seem right either
14:54:24 * Eduard_Munteanu thought it was simply putStrLn . show
14:54:36 <monochrom> it is
14:54:40 <ion> > putStrLn . show $ 42
14:54:43 <lambdabot>   <IO ()>
14:54:49 <Eduard_Munteanu> Hrm.
14:54:49 <monochrom> > (putStrLn . show) "<IO ()>"
14:54:51 <lambdabot>   <IO ()>
14:54:53 <monochrom> works
14:54:56 <Eduard_Munteanu> :))
14:55:08 <lowasser1> I should point out, though
14:55:22 <shachaf> monochrom: It's missing the quotation marks, though.
14:55:22 <Eduard_Munteanu> > (putStrLn . show) "<Yo ()>"
14:55:24 <lambdabot>   <IO ()>
14:55:31 <shachaf> > putStrLn "<IO ()>"
14:55:31 <lowasser1> if it isn't really pure, then ST won't work, in the sense that your code won't compile for one reason or another
14:55:31 <monochrom> I'm cheating.
14:55:32 <lambdabot>   <IO ()>
14:55:37 <Saizan> > fix (putStrLn . show)
14:55:39 <lambdabot>   <IO ()>
14:55:55 <ion> > break (putStrLn . show)
14:55:56 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:55:56 <lambdabot>         against inferred type ...
14:56:10 <shachaf> > putStrLn (fix show)
14:56:10 <Eduard_Munteanu> You broke it.
14:56:11 <lambdabot>   <IO ()>
14:56:32 <int80_h> how do I unhide a hidden package via command line?
14:56:43 <Saizan> expose
14:56:52 <monochrom> ghc-pkg expose naked-babe
14:57:42 <shachaf> > fiх (putStrLn . show)
14:57:44 <lambdabot>   <you broke lambdabot ()>
14:57:59 <Eduard_Munteanu> Hah.
14:58:20 <int80_h> I get a complaint "could not find module foo" it is member of hidden package bar. Now, I did ghc-pkg expose bar, but get the same error. What's the next step?
14:58:57 <gwern> wait, what? where did you broke lambdabot come from?
14:59:05 <Eduard_Munteanu> Private message I guess.
14:59:07 <shachaf> gwern: I guess I broke it.
14:59:16 <shachaf> s/it/her/
14:59:24 <shachaf> @vixen Are you broken?
14:59:24 <lambdabot> whoa whoa whoa, one question at a time!
14:59:46 <int80_h> @vixen can you fix my haskell?
14:59:46 <lambdabot> Ooh, functional programmers are so hot!
14:59:55 <int80_h> that's besides the point!
15:01:04 <ion> I take it unfunctional programmers write PHP?
15:01:11 <shachaf> @vixen How does it feel being stuck in a monad all day?
15:01:12 <lambdabot> it does
15:01:26 <int80_h> http://hpaste.org/44022/fun_with_yesod
15:01:27 <shachaf> I knew it.
15:02:00 <revenantphx> @vixen What monad are you in?
15:02:01 <Eduard_Munteanu> Aren't we all...
15:02:01 <lambdabot> yes, i am
15:02:08 <revenantphx> the "Yes" monad :|
15:02:26 <shachaf> yes = fix ("y\n"++)
15:02:28 <int80_h> ghc is tormenting me :)
15:04:04 <int80_h> I think the problem here is I'm getting claims that a certain package is hidden, and using expose doesn't alter that claim. Any ideas on where an investigation should take me?
15:04:17 <Eduard_Munteanu> I imagine PHP programmers think GHC is fascist with all that typechecking
15:04:43 <int80_h> Haskell programmers think the same thing sometimes :)
15:04:54 * int80_h is being oppressed by the type checker.
15:05:22 <Eduard_Munteanu> unsafePerformIO is the Final solution
15:05:25 <Saizan> int80_h: are you building with cabal?
15:05:41 <int80_h> Saizan: right now I'm just trying ghc --make
15:05:42 <hpc> Eduard_Munteanu: PHP programmers have no time for correct code! they have to make webscale 2.0 app framework layers!
15:06:02 <int80_h> Saizan: I'm installing with cabal
15:06:16 <Saizan> int80_h: then maybe it's the module you're trying to import that's hidden, rather than the package?
15:06:22 <Saizan> int80_h: can you paste the log?
15:06:48 <int80_h> Saizan: what log?
15:07:28 <int80_h> Saizan: the output generated by ghc -v?
15:08:56 <Saizan> int80_h: no, i've seen your hpaste now, 
15:09:51 <Saizan> int80_h: ghc-pkg list wai-extra ?
15:10:49 <int80_h> Saizan: http://hpaste.org/paste/44022/fun_with_yesod_annotation#p44023
15:11:13 <int80_h> Saizan: should I remove the old one?
15:11:49 <Saizan> shouldn't matter
15:12:09 <int80_h> hmm
15:12:23 <Saizan> do you have more than one installation of ghc, perhaps?
15:12:34 <int80_h> prolly. I used one to compile the other
15:12:46 <int80_h> Should I remove one?
15:12:54 * roconnor_ needs to learn 2-category theory
15:12:54 <Saizan> maybe you're using the ghc-pkg of one and the ghc of the other
15:13:05 <int80_h> ah!
15:14:58 <int80_h> Saizan: I just removed one version of ghc, still same problem
15:15:21 <int80_h> ghc-pkg list wai-extra yields same info
15:15:41 <int80_h> Can I conclude I am still using the same ghc-pkg and ghc as I was before?
15:15:51 <int80_h> or do I need more info?
15:17:27 <revenantphx> 1) Convert merge sort from recursive to iterative
15:17:33 <revenantphx> 2) Experience huge speedup
15:17:35 <Saizan> check the versions
15:17:44 <roconnor_> ah my star operation works on more than just coalgebras.  It works on any natural transformation.
15:17:45 <revenantphx> sort 10000000 elements in under 2 seconds >_>
15:17:51 <int80_h> Saizan: of what?
15:18:05 <Saizan> int80_h: of ghc-pkg and ghc ?
15:18:05 <revenantphx> I run out of heap space before my merge sort takes over 2 seconds :3
15:18:28 <roconnor_> er
15:18:30 <accel> what's a good parsec tutorial?
15:18:31 <roconnor_> wait that isn't quite true
15:18:44 <roconnor_> @type \f g -> fmap g . f
15:18:45 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (f a) -> (a -> b) -> f1 (f b)
15:18:55 <roconnor_> @type \f g -> fmap g Preludel.. f
15:18:56 <lambdabot> Couldn't find qualified module.
15:18:57 <roconnor_> @type \f g -> fmap g Prelude.. f
15:18:58 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> f a) -> (a -> b) -> a1 -> f b
15:19:55 <int80_h> Saizan: I don't see the obvious way of checking the version of ghc-pkg
15:20:34 <int80_h> I tried ghc-pkg dump | grep ghc-pkg and ghc-pkg -v
15:20:46 <Saizan> int80_h: ghc-pkg --version
15:20:54 <Saizan> it's in the --help
15:21:08 <int80_h> Saizan: oops got it. Okay both are 6.12.3
15:21:51 <Saizan> then i don't know
15:22:22 <int80_h> Saizan: no worries. Thanks. I think it's a trip to the mailing list for me. I may have discovered a bug?
15:22:39 <int80_h> I don't recall this being a problem on my other server though
15:25:15 <roconnor_> @type \f g -> fmap g `Prelude..` f
15:25:16 <lambdabot> parse error on input `Prelude..'
15:25:28 <roconnor_> @type \f g -> (Prelude..) (fmap g) f
15:25:29 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> f a) -> (a -> b) -> a1 -> f b
15:28:55 <int80_h> how do I remove a cabal package?
15:29:01 <int80_h> cleanly?
15:29:26 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
15:30:13 <int80_h> thanks!
15:32:29 <accel> crap ... from cabal, do I want parsec, parse1, parsec2, or parsec3 ?
15:34:39 <int80_h> Saizan: do you think using GHC 7.0.1 will solve this problem?
15:38:35 <markus3> hi! i'm having a problem: i'm logged in to a gentoo machine from cygwin from windows, but having trouble with ghci -- it errors out, when printing umlaut characters in my identifiers and types. I have set my linux environment to use utf8 (I think) and compiling/interpreting sourcefiles with "õäöü" works fine, only ghci stops outputting, when encountering one of them... any pointers?
15:38:57 <markus3> accel: what do you want to parse?
15:39:56 <monochrom> what is the exact error message?
15:41:01 <accel> http://www.haskell.org/pipermail/haskell-cafe/2006-January/013903.html <-- how the hell does expand work?
15:41:11 <markus3> its like this: Main> <whatever>*** Exception: <stdout>: hPutChar: invalid argument (Invalid or incom plete multibyte or wide character)
15:41:12 <augur> along the way towards solving a certain problem (ask me if you want) i figured that there are probably some inferences that can be made about code
15:41:43 <augur> like, if   length xs == length ys,   then   (xs,ys) ~ zip xs ys
15:42:06 <markus3> ghci starts to tell me something and errors out when the umlaut comes
15:42:46 <augur> and   all p xs && all q ys ~ all (uncurry (&&) . (p × q)) (zip xs ys)
15:42:55 <markus3> and if I enter an umlaut in ghci, it exits with "<stdin>: hWaitForInput: invalid argument (Invalid or incomplete multibyte or wide character)"
15:43:06 <monochrom> (source code file not utf8) xor (ghci not run in utf8 locale)
15:43:13 <augur> im working on finding some set of laws that lets the last one be proven
15:43:40 <augur> one of them is certainly the law for currying, and the law for function pairs
15:44:01 <markus3> source should be utf8, at least that what Notepad++ tells me
15:45:27 <monochrom> my LANG is en_CA.UTF-8 and I have no other locale variables. and I don't know gentoo. I'm on ubuntu.
15:46:01 <monochrom> I also assume your ghc version is 6.12.x
15:47:47 <markus3> yes
15:47:49 <bvck> accel, on expand..., look up template haskell
15:49:06 <shamster> I come from a strong c/c++ background and I'm struggling with a data structure issue in FP. For instance - I have a system that models the interactions of particles, and thus imperatively I would create a particle class that has a particle's name, charge, mass, and position. Given a group of particles I have a system, and the only thing changing over time are the positions. Can anyone shed some light on how the position (a dynamic value that is updated duri
15:49:45 <monochrom> just s/class/record/
15:50:01 <hpc> shamster: consider this
15:50:06 <hpc> you have a list of all your particles
15:50:18 <hpc> and you have your time dimension
15:50:27 <hpc> which is really a function from one state to another
15:50:27 <conal> augur: you want to prove the part with uncurry (&&) and zip?
15:50:38 <hpc> so instead of thinking of it as "change things from one value to another"
15:50:42 <monochrom> look for "Jackson structured design" for FP-friendly design.
15:50:49 <hpc> think of it as "make a list, where each value is a function of the value before"
15:50:54 <shamster> monochrom: I'll check it out, thanks
15:50:58 <hpc> where "value" == "simulation state"
15:51:00 <augur> conal: yeah. i'd like to figure out the relevant laws for that
15:51:19 <conal> augur: you mean the laws that suffice to prove it?
15:51:21 <augur> to push the conjunction inside, and maybe eliminate it entirely
15:51:24 <hpc> shamster: also i think your message got cut off
15:51:28 <augur> yes, the laws sufficient to prove it
15:51:30 <hpc> "(a dynamic value that is updated duri"
15:51:34 <shamster> hpc: I'm almost following - but to clarify, I've got all the positions already recorded in a large data file...
15:51:39 <shamster> hpc: oh... that's unfortunate
15:51:51 <shamster> hpc: what's the last part you see?
15:52:01 <hpc> i just pasted it
15:52:14 <shamster> ... that is updated during analysis) can be bundled with other (static) properties?
15:52:29 <conal> augur: i'd do some inlining/unlinining with the defns of all, ×, and uncurry
15:52:35 <hpc> ah
15:52:56 <augur> conal: ??
15:53:00 <monochrom> data Particle = Particle { name::String, ... Position:: IORef (Double,Double,Double) } is a first attempt.
15:53:14 <shamster> monochrom: could you explain the IORef part?
15:53:20 <monochrom> mutable variable
15:53:27 <dankna> if you have a great many particles, it may be advantageous to use an unboxed array, but that's not a beginner's topic
15:53:28 * hackagebot iteratee 0.8.0.2 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.0.2 (JohnLato)
15:53:50 <hpc> shamster: an IORef is a pointer to a thing; the IORef is what is mutable; you change where it points to
15:54:04 <shamster> dankna: I've got to be able to run code at least 90% the speed of what I was crunching out of C... which is already pretty fast
15:54:05 <conal> augur: and maybe use a simpler form: all (zipWith (&&) (map p xs) (map q ys))
15:54:12 <dankna> (it has to be an unboxed array because putting a record in an array will do things you don't really intend, like incur a large expense of garbage collection)
15:54:23 <dankna> yes, it's for performance's sake that I suggested arrays
15:54:34 <shamster> dankna: I'll have to look into it
15:54:37 <conal> augur: play around with some simple variations of zipWith and map, seeing what you can prove.
15:55:15 <shamster> hpc: I guess I don't understand how mutable values fit into haskell
15:56:17 <shamster> hpc: I'm parsing data from a file, and forming a list of data points for positions. How could I reference a constantly changing piece of a file stream?
15:56:29 <augur> conal: ya
15:56:40 <conal> augur: there are lots of papers with similar equational proofs. for instance, richard bird. also the "fold/unfold" style of program derivation written about by rod burstall & john darlington
15:56:53 <augur> ill check it out
15:57:37 <conal> augur: a general strategy: find a similar but simpler derivation/proof to tackle first.
15:57:49 <augur> yeah
15:57:55 <augur> im working on figuring out what that would be :)
15:58:18 <conal> augur: which may be directly applicable to your original goal, or just practice (a warm-up exercise)
15:58:35 <conal> "If you can't solve a problem, then there's an easier problem you can solve: find it." - Polya
15:58:43 <augur> :)
15:59:01 <conal> augur: for instance, eliminate p & q, and let xs, ys :: [Bool]
15:59:09 <markus3> monochrom: i got it working! (noob mistake: as I'm not too experienced I followed a guide from gentoo.org to set my locale, put played around with the settings and left stuff commented out... I don't know how ghci knew how to read my sources correctly, but the LANG wasn't actually set. anyway looked at my `env`, reread the guide and uncommented the lines and now all works :-)
16:01:13 <augur> so...   foldr (&&) True xs && fold (&&) True ys   ~   foldr (&&) True $ map (uncurry (&&)) (zip xs ys)
16:01:30 * hackagebot iteratee 0.8.0.3 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.0.3 (JohnLato)
16:01:39 <conal> augur: looks right. and use 'and' for 'foldr (&&) True'.
16:01:47 <augur> hmm ok
16:01:59 <conal> augur: also, zipWith in place of map + uncurry + zip
16:02:25 <augur> true
16:03:20 <augur> (foldr and True xs) and (foldr and True ys)   ==   foldr and True (zipWith and xs ys)
16:04:09 <tengen> is it common to write String and ByteString variants of the same parser? if so, how are the two parsers arranged as modules?
16:04:35 <augur> er no obviously im not reading x3
16:05:29 <aavogt> even if you do the zip right, it might give the wrong answer since you may drop something off the shorter list
16:05:35 <augur> (foldr (&&) True xs) && (foldr (&&) True ys) == foldr (&&) True (zipWith (&&) xs ys)   -->   (and xs) && (and ys) == and (zipwith (&&) xs ys)
16:06:28 <conal> augur: you could first try to prove that last piece: (and xs) && (and ys) == and (zipwith (&&) xs ys)
16:06:37 <augur> ya
16:06:42 <aavogt> > let xs = []; ys = [False] in (and xs && and ys, and (zipWith (&&) xs ys))
16:06:43 <lambdabot>   (False,True)
16:06:58 <aavogt> proof isn't necessary
16:07:00 <augur> aavogt: it depends on length xs == length ys
16:07:16 <augur> its conditional on that.
16:07:24 <conal> augur: oh, yeah. relies on same length.
16:08:45 <augur> itll come down to something like and [] = True; and (True:xs) = and xs; and (False:_) = False 
16:09:10 <aavogt> proof by inliner
16:09:14 <augur> which lets you know that if and xs, then xs some number of Trues
16:10:02 <augur> and eventually, each True ~ p xs
16:10:28 <conal> augur: i doubt you need to specialize to True vs False. you can use (&&) for (x:xs)
16:11:40 <augur_> i think. so that the expanding of each True into a true predicate then pushes back to each true resolving to (a,b)
16:13:10 <augur_> and something like turning the length equality constraint into a recursive test or something?
16:13:41 <aavogt> > let xs = [True,undefined]; ys = [False,True]; a = and xs && and ys; b = and (zipWith (&&) xs ys) in (b,a)
16:13:42 <lambdabot>   (False,*Exception: Prelude.undefined
16:14:17 <aavogt> your world probably has no bottom :p
16:14:18 <augur_> hm, but to get it to be more like S -> e | aSb, itll need to work with the reverse of the bs list
16:14:27 <augur_> aavogt: no, ofcourse not.
16:14:35 <aavogt> too bad
16:14:40 <augur_> not really.
16:14:56 <augur_> im trying to find techniques to turn constraints into constructive proof rules
16:17:02 <augur_> f (x:xs) (y:ys) ~ (x, f xs ys, y)
16:18:09 <augur_> s == as ++ bs ~ flatten (f as (reverse bs))
16:19:26 <augur_> hmm. s == as ++ bs && length as == length bs ~ s == flatten (f as (reverse bs))
16:28:35 <siracusa> What would be a good way to traverse two ASTs in parallel and compare if their structure is equivalent? I need to specify some special rules for a few cases and all other cases should be treated like in a derived Eq instance.
16:29:29 <aavogt> are these special cases different by type?
16:30:28 <siracusa> No
16:30:32 <aavogt> syb-with-class is more appropriate, but syb will work too if you don't mind re-writing the geq
16:30:39 <aavogt> @ty geq
16:30:40 <lambdabot> forall a. (Data a) => a -> a -> Bool
16:31:23 <siracusa> Ok, I'll have a look at that.
16:38:54 <Peaker> I think use of "syb" is a bad sign and the code should be refactored :)  Solve the problem at its root --> simplify the semantics.  Don't cut down on the large amount of syntax required to deal with the complex semantics
16:39:15 <Peaker> (I prefer "semantic solution" over a syntactic one.. which also means I don't like Lisp macros very much...)
16:53:32 <xplat> :t (<*> snd) . (<$> fst)
16:53:32 <lambdabot> xplat: You have 5 new messages. '/msg lambdabot @messages' to read them.
16:53:33 <lambdabot> forall b a b1. (a -> b1 -> b) -> (a, b1) -> b
16:54:24 <Peaker> @type uncurry
16:54:25 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:57:25 <parcs> @hoogle isDirectory
16:57:25 <lambdabot> No results found
16:57:30 <parcs> any help here?
17:01:24 <siracusa> aavogt: Can you point me to an example? These SYB modules look rather complicated.
17:03:48 * hackagebot kit 0.6.6 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.6.6 (NickPartridge)
17:13:48 <monochrom> parcs: there are two options. use a combination of doesFileExist and doesDirectoryExist from System.Directory (more portable). use System.Posix.Files.isDirectory (less portable).
17:14:18 <xplat> :t (==) <*> reverse
17:14:19 <lambdabot> forall a. (Eq a) => [a] -> Bool
17:16:23 <parcs> monochrom: thanks!
17:32:10 <xplat> :t sequence . flip (:) . map guard
17:32:11 <lambdabot>     Couldn't match expected type `[a1 -> m a]'
17:32:11 <lambdabot>            against inferred type `a2 -> [a2] -> [a2]'
17:32:11 <lambdabot>     In the first argument of `flip', namely `(:)'
17:38:20 <BMeph> parcs, monochrom: Isn't that (determining if something is a dir) what the 'searchable' item in the 'permissions' record is for? :)
17:49:55 <walt> Why do I get "not in scope: 'unless'" from this? http://tinyurl.com/wdrop/Pastes/main.hs_0.html
17:51:15 <luite_> you need to import Control.Monad
17:51:57 <walt> luite_: thanks
17:53:04 <tibbe> dons: argh, flight delayed
17:54:21 <nich> \quit zzzz
17:54:23 <nich> woops
17:54:25 <nich> >_>
17:57:05 <monochrom> searchable is still False if a directory gives you no permission
18:02:24 <tibbe> dons: 1.5h delay!
18:04:24 <BMeph> monochrom: Ah, I did not know that. Thank you.
18:23:29 <gwern> hm
18:23:47 <gwern> shapr: weren't you going to complain about my Summer of Code page or something?
18:25:14 <copumpkin> gwern: I thought sclv's suggestion on reddit was pretty good
18:25:27 <gwern> copumpkin: well yeah except it would have at least tripled the time it took to write it
18:25:43 <gwern> copumpkin: and it already took a danged long time to write
18:26:55 <gwern> copumpkin: I mean, look up every single SoC student's prior and succeeding contributions to haskell?
18:28:12 <shapr> gwern: Yah, but sleep got in the way.
18:29:28 <gwern> copumpkin: and that's even more of a tarpit than judging individual SoCs. how do I judge spencer janssen? sure, he wrote xmonad, but he stopped contributing to, like, anything a year or three ago
18:33:20 <gwern> copumpkin: go on, how do I judge spencer? he was contributing before, he was contributing after and then apparently quit. was his SoC, on the metric of increasing involvement, a success or failure? 
18:33:37 <copumpkin> definitely a success
18:33:54 <copumpkin> people's lives change, but the point is that his GSOC led to more contributions
18:34:33 <shachaf> preflex: seen sjanssen
18:34:33 <preflex>  sjanssen was last seen on #haskell 258 days, 23 hours, 5 minutes and 5 seconds ago, saying: jbapple: I'm not familiar with any of those packages, so I really don't know
18:34:42 <shachaf> He *has* been gone for a while, hasn't he.
18:34:44 <shapr> I'd suggest two thirds 'core' projects that are low risk and directly beneficial (hackage/cabal/ghc) and one third high risk projects that may end up being exciting
18:35:01 <shapr> Yah, but people go in and out of the community lots...
18:35:26 <shapr> TheHunter was prolific, ddarius was prolific and then disappeared for years and is now back...
18:35:42 <djahandarie> ddarius disappeared for years?
18:35:58 <shapr> Yup, he had a military career in the meantime.
18:36:06 <shachaf> Which years?
18:36:06 <djahandarie> Ah, so he was here before that
18:36:14 <djahandarie> He has been around for awhile huh...
18:36:17 <shapr> djahandarie: iirc, ddarius first showed up on #haskell before he left high school.
18:36:29 <djahandarie> Heh
18:36:45 <djahandarie> I think that's about when I showed up (except like 10 years later)
18:36:56 <shapr> I dropped out of #haskell for the past few years, I'd very much like to apply as a student to do an SoC project, but my skills are so rusty :-/
18:37:28 * shachaf is around this channel but doesn't actually do a whole lot of Haskelling nowadays.
18:37:33 <shapr> Oh hey, I could propose finishing Fermat's Last Margin.. that is, a distributed decentralized CiteSeer that's based on gitit?
18:37:51 * shachaf should do more Haskelling.
18:38:02 * djahandarie should do more Haskelling too
18:38:05 <litb> who is the most haskell major in the channel?
18:38:07 <shapr> Ok, I've convinced myself to propose FLM for a GSoC project.
18:38:31 <stepkut> shapr: awesome!
18:38:33 <shapr> litb: You are! But that's just me reading the future.. Where do you think you'll start?
18:38:33 <djahandarie> Most of my Haskelling time goes to other stuff now, like Agda or just reading cs/ct/stuff :P
18:38:39 <litb> is Cale the most knowledgable?
18:38:45 * stepkut needs to propose some MACID stuff for GSoC
18:38:52 <shapr> litb: For what subject?
18:38:58 <djahandarie> litb, we are a single mind
18:39:02 <shachaf> litb: Is there really that much of a point in trying to put a total ordering on that sort of thing?
18:39:02 <litb> shapr: for general haskell?
18:39:03 <shapr> litb: I'm the most knowledgable if you want Haskell community gossip...
18:39:10 <djahandarie> #haskell is most knowledgable!
18:39:24 <shachaf> shapr: Let's have some #haskell gossip!
18:39:36 <djahandarie> shachaf, yes, and we should come up with a ranking system and certfications for it
18:39:45 <djahandarie> Level 5 #haskeller
18:39:59 <shapr> djahandarie: We had martial arts belt colors on the wiki for awhile :-)
18:40:07 <shapr> BUT! Have you guys seen khanacademy.org?
18:40:24 <shapr> Something like that for Haskell would be both incredible, and years of work.
18:40:28 <djahandarie> I have now
18:40:34 <shapr> litb: Do you have any specific questions?
18:41:00 <litb> i would like to have the haskell
18:41:00 <shapr> litb: I'm likely most knowledgable on who to ask about a specific subject, even when I can't answer the question myself :-)
18:41:13 * shapr gives The Haskell to litb via http://www.haskell.org/
18:41:38 <litb> but now I can't eat it :(
18:41:59 <shapr> litb: Don't worry, your brain may be full now, but it will get hungry again.
18:42:10 <litb> ohh nice
18:43:13 <shapr> shachaf: Eh, the reason I hear #haskell gossip is that I never repeat any of what I hear :-)
18:44:02 <shachaf> shapr: Some gossipist you are.
18:44:19 <xplat> :t foldr (filter . (0 ==) .: flip (%))
18:44:20 <lambdabot> forall a. (Integral a) => [a] -> [a] -> [a]
18:44:20 * shapr shrugs
18:44:48 <shapr> Let's see, last I heard there are two companies hiring Haskellers in Boston.
18:44:54 <shapr> Oh, Well-Typed is hiring as of today.
18:45:03 <xplat> > (foldr (filter . (0 ==) .: flip (%))) [1..60] [2,3,5]
18:45:05 <lambdabot>   []
18:45:16 <xplat> > (foldr (filter . (0 /=) .: flip (%))) [1..60] [2,3,5]
18:45:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:45:31 * xplat sighs
18:45:54 <shapr> shachaf: I heard that some UK universities are looking for FP grad students.
18:46:22 <shapr> I haven't heard anything recently from the PDXers though, maybe lispy would know?
18:46:36 <lispy> shapr: hi
18:46:46 <lispy> shapr: what exactly is the question? 
18:46:52 <shachaf> shapr: Is that the sort of gossip you meant?
18:47:02 <lispy> FP jobs or grad student positions?
18:47:04 <shapr> shachaf: No, but that's the sort of gossip I would happily relay :-)
18:47:11 <shapr> lispy: and recent research
18:47:37 <lispy> There are several current FP grad students at PSU
18:47:46 <kulakowski> shapr: What companies in Boston?
18:47:50 <lispy> But, I'm not very well connected with them
18:48:15 <shapr> kulakowski: S&P and Clarifi last I heard. Though I suspect positions could be found with BlueSpec and some other chip companies if you know the right people.
18:48:43 <copumpkin> S&P and ClariFi are the same thing, and you only get to do FP at Clarifi
18:48:44 <dons> shapr: there's 2 or more banks in london hiring atm. 
18:48:48 <shapr> oh awesome!
18:48:49 <lispy> my impression of google is that they are slowly increasing the amount of FP they do
18:48:51 <litb> can you work with haskell for a living?
18:48:59 <lispy> litb: yeah
18:49:02 <shapr> litb: Yes, several people here do that.
18:49:06 <shapr> dons: Which banks?
18:49:13 <litb> oh
18:49:13 <dons> hmm. googling...
18:49:21 <copumpkin> standard chartered
18:49:23 <shapr> And like I said, well-typed is hiring a consultant: http://www.well-typed.com/blog/50
18:49:32 <litb> it's probably mainly in math?
18:49:36 <copumpkin> I'd imagine deutsche bank
18:49:38 <copumpkin> litb: no
18:49:44 <litb> oh
18:49:45 <xplat> oh, righ
18:49:50 <dons> http://www.njobster.com/job/235954-haskell-developer-london-investment-banking.shtml 
18:49:54 <xplat> > (foldr (filter . (0 /=) .: flip mod)) [1..60] [2,3,5]
18:49:56 <lambdabot>   [1,7,11,13,17,19,23,29,31,37,41,43,47,49,53,59]
18:50:01 <litb> oh it's banking
18:50:16 <lispy> :t (.:)
18:50:17 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
18:50:32 <dons> and this looks like ocaml  (but they're hunting for haskellers)  http://www.biz-bee.com/recruitment_details?NI=65818_SB/HaskOcamlTL/Lon&position%20type=Permanent&job%20sector=IT 
18:51:03 <lispy> dons: I convinced brian h. to upload his theories, so that's one less hurdle down :)
18:51:12 <dons> good
18:51:22 <dons> now you can subscribe to his theories
18:51:27 <lispy> heh
18:51:31 <shapr> His theories have an RSS feed?
18:51:33 <xplat> > fix (flip (foldr (filter . (0 /=) .: flip mod))) [2..]
18:51:34 <lambdabot>   Couldn't match expected type `[a]'
18:51:34 <lambdabot>         against inferred type `[a] -> [a]'
18:51:36 <lispy> Something about gravity fields?
18:51:41 <litb> but it's probably all research field
18:51:54 <xplat> :t flip (foldr (filter . (0 /=) .: flip mod))
18:51:54 <copumpkin> litb: stop it
18:51:55 <litb> deep science
18:51:55 <lambdabot> forall a. (Integral a) => [a] -> [a] -> [a]
18:52:01 <litb> copumpkin: oh :(
18:52:03 <lispy> http://crazytalk.com/theories.rss
18:52:22 <copumpkin> litb: you're just stereotyping. If you have a question to ask (which it looked like before), ask it, but don't just make silly assumptions
18:52:32 <shapr> litb: What have you written in Haskell?
18:52:39 <shachaf> Did anyone here happen to read Tim's post on -cafe@ about monad-embed?
18:52:44 <shapr> shachaf: Got a link?
18:52:50 <xplat> > fix $ (foldr (filter . (0 /=) .: flip mod)) [2..]
18:52:51 <shapr> Is that Tim Chevalier?
18:52:53 * djahandarie should get around to actually subscribing to that thing
18:52:54 <lambdabot>   mueval-core: Time limit exceeded
18:53:07 <litb> shapr: i've written a silly automatic differentiation calculator
18:53:09 <xplat> :(
18:53:23 <shachaf> shapr: http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/86281
18:53:30 <djahandarie> litb, have you seen the 'ad' package on hackage?
18:53:42 <litb> but i've mostly written a copy of that one blog post
18:53:44 <shapr> litb: Have you uploaded it?
18:53:49 <litb> djahandarie: it was all for fun. not for real use
18:53:55 <xplat> > fix $ (2:) . (foldr (filter . (0 /=) .: flip mod)) [3..]
18:53:55 <walt> Is it possible to define only some types in a function declaration? and have the rest still be inferred?
18:53:56 <shapr> litb: oh, what's the link to your blog post?
18:53:59 <lambdabot>   mueval-core: Time limit exceeded
18:54:23 <litb> it's not my blog post. it's someone else's
18:54:37 <shapr> walt: Sure, just give them type variables, right?
18:54:39 <litb> shapr: i wrote it some years ago
18:54:46 <luite_> walt: you can use scoped type varibles, like   f (x::Int) y = 
18:55:01 <xplat> oh, i see why it's not being productive ... unfortunately not so easy to fix ... :(
18:55:28 <walt> luite_: hm, that seems to be an extension?
18:55:40 <luite_> actually not type variables, but I think that you need that extension to enable the syntax :)
18:55:50 <walt> I see
18:55:51 <luite_> walt: yes
18:55:56 <walt> thanks
18:56:11 <luite_> hmm, not sure though, first try without :)
18:56:24 <walt> didnt work
18:56:26 <walt> said I needed an extension :)
18:56:41 <walt> I am not too fond of using extensions though.
18:56:48 <walt> so I'll live without until I really need it
18:56:50 <xplat> i mean i could 'fix' it but it would really be taking a kind of different approach, and it's not like i don't already know successful ways to write primes :)
18:59:29 <litb> shapr: this was the code: http://codepad.org/gSK4D1yZ
19:00:24 <shapr> litb: So, what do you think about that? How would you improve it?
19:00:44 <litb> it's dead. I have no use for it anymore
19:01:05 <litb> i wrote it for school to show off mwaha
19:04:38 <shapr> litb: Have you written any Haskell recently? or is there something you'd like to write in Haskell?
19:04:48 <lispy> litb: oh, did you base that on Conal Elliot's work?
19:05:17 <djahandarie> Lots of lifting going on in there :P
19:07:08 <litb> djahandarie: i tried to get the hang of lifting. I failed :(
19:08:06 <djahandarie> Looks like you have it down pretty well in there :P
19:08:46 <litb> lispy: dunno. was some two-parts blog post called something like "numerics foo with haskell" or something
19:09:21 <litb> djahandarie: i just bugged the channel until it worked xD
19:10:00 <shapr> litb: So, got any new Haskell projects starting up?
19:10:40 * lispy never tires of the enthusiasms inherent in the shapr 
19:10:59 <shapr> kulakowski: Last I heard the creator of the lambda calculus playground is in your area: http://homepages.cwi.nl/~tromp/cl/cl.html
19:11:30 <kulakowski> 'haskell ind' does not complete to 'haskell industy' or anything like that on google instant :(
19:11:34 <kulakowski> shapr: thanks, taking a look now
19:14:02 <shapr> wagle: och det finns #haskell.se oxa
19:14:19 <shapr> ahem, fail
19:14:21 <luite_> oxa
19:14:22 <shapr> walt: 
19:14:22 <luite_> hmm
19:14:35 <shapr> luite_: What, you don't like swedish lolspeak?
19:14:44 <luite_> making the swedish harder to read for foreigners innit?
19:14:56 <shapr> luite_: You mean, like me?
19:14:59 <luite_> no me
19:15:09 <shapr> You're not Swedish?
19:15:45 <shapr> luite_: Could be worse, I was born in raised in Alabama, USA. I just tell people I come from the Swedish speaking part of Alabama.
19:16:46 <copumpkin> kulakowski: you in boston?
19:16:46 <luite_> shapr: no I'm Dutch, but I'm not from the Swedish speaking part of the Netherlands ;)
19:17:20 <shapr> Ok, random question... how many people here are actually interested in Kolmogorov complexity and other areas of "shortest program length" ?
19:18:02 <shapr> luite_: Funny, I recently ran across another .nl born and raised who spoke Swedish. But he does Asterisk.
19:18:12 <luite_> how interested is "actually interested" :p
19:18:42 <kulakowski> copumpkin: providence. boston is doable as a commute.
19:19:09 <copumpkin> kulakowski: you should come to the boston haskell meetups :)
19:19:20 <luite_> shapr: oh I don't really speak swedish, but reading swedish is usually not too difficult
19:19:40 * djahandarie wouldn't want to commute to boston for work, definitely no
19:19:54 <kulakowski> copumpkin: How often/when/where?
19:20:15 <copumpkin> kulakowski: usually about once a month, at MIT, not sure yet about the next one, but there's a mailing list
19:20:16 <djahandarie> Every hour on opposite ends of boston
19:21:03 <kulakowski> I should get on that. and haskell-cafe.
19:21:57 <copumpkin> http://groups.google.com/group/bostonhaskell?pli=1
19:40:13 <badkins> Having trouble with the restriction on not using the same record attribute name in multiple places.
19:40:16 <badkins> http://hpaste.org/44027/mario_kart_example
19:40:57 <badkins> I'd simply like to extract the "speed" from w/in Driver and Vehicle, but the record attr name restriction seems to be a problem (as is my lack of Haskell knowledge)
19:41:31 <badkins> It seems both Driver and Vehicle would need to be derived from a common ancester to satisfy the type system also.
19:41:42 <c_wraith> common ancestor?
19:41:50 <badkins> to be polymorphic
19:41:50 <c_wraith> That phrase doesn't really mean anything in haskell
19:42:05 <badkins> c_wraith: Haskell has the concept I think
19:42:09 <badkins> derived types
19:42:28 <NemesisD> anyone have any idea how i'd go about gettimg my CLI haskell app to intelligently tab complete?
19:42:44 <badkins> both Driver and Vehicle contain an Entity, but I had to give it different names dEntity and vEntity :(
19:42:52 <lispy> NemesisD: where are you stuck at the moment?
19:43:02 <lispy> NemesisD: what things do you want to tab complete?
19:43:09 <badkins> otherwise, I expect I could write a function to retrieve an Entity and then drill down
19:43:16 <lispy> NemesisD: do you use any sort of readline/editline or haskeline library?
19:43:28 <Jafet> Since Haskell doesn't let you refer to a Driver as a Vehicle, or vice versa, that design does not make sense.
19:43:33 <badkins> actually, I'd need speed from Combo also
19:43:37 * lispy disappears
19:43:57 <badkins> Jafet: I don't want to refer to a Driver as a Vehicle or vice versa
19:43:58 <Jafet> You can accomplish those things with a typeclass, but you seem to have a purely stylistic complaint.
19:44:02 <NemesisD> lispy: i do my command line parsing with the cmdargs package, id like to complete using data that would be available within the app
19:44:10 <badkins> Jafet: hardly stylistic
19:44:25 <Jafet> class HasSpeed a where speed :: a -> Double
19:44:27 <badkins> the question is how to write a single function to extract the speed attribute from Driver, Vehicle and Combo
19:44:46 <NemesisD> its more or less a to-do list so for example i'd want to do myapp delete ^T and be able to tab complete an item name
19:45:22 <Jafet> Haskell does not have anything resembling an object system, but there are some extensions you can try.
19:45:23 <lispy> NemesisD: for that you need to cooperate with the shell.  IIRC, bash has a defined API for this
19:45:46 <badkins> Jafet: I'm actually not trying to get Haskell to fit an OO mold, I'm trying to get myself out of the OO mold :)
19:46:05 <badkins> so, I guess I'm looking for the "proper" way to reuse some things
19:46:18 <NemesisD> lispy: ah i see, hopefully thatll play nice with my hacked together cmdargs, i'm okay with tying my app to bash/zsh for this fancy feature
19:46:37 <badkins> ignoring Combo for the time being, if the record naming restriction didn't exist, then:
19:47:00 <badkins> speed (entity X)  where X is Driver or Vehicle
19:47:15 <lispy> NemesisD: I think this SO question should be similar to your question: http://stackoverflow.com/questions/3520936/accesssing-bash-completions-for-specific-commands-programmatically
19:47:33 <Jafet> Well, you can use (comparing (speed . attributes . vEntity)) for Vehicles, chaining accessors to get the desired member
19:48:20 <Jafet> Note that your design has a diamond error: Combo has two Entities, and thus two speeds.
19:48:22 <badkins> yes, it's having to use vEntity and dEntity that's causing me pain
19:48:38 <NemesisD> lispy: cool. thanks!
19:48:52 <badkins> Jafet: my bad in communication actually. Combo does not have any Entities
19:48:55 <badkins> just Attributes
19:49:11 <badkins> speed is a "member" of Attributes
19:49:19 <badkins> Entities contain an Attributes
19:49:20 <Jafet> Oh, ok.
19:49:51 <Jafet> A little typing is "causing you pain"? That sounds very stylistic to me
19:50:17 <badkins> "style" seems superficial to me, I'm trying to get fundamental concepts
19:50:19 <aavogt> everything is just "a little typing"
19:50:22 <Jafet> If you want to avoid even that, use the HasSpeed class to get a polymorphic speed (and anything else you need).
19:50:27 <badkins> I think it's more of a dynamic vs. static problem than OO vs. other
19:50:57 <Jafet> Dynamic binding is called polymorphism, and polymorphism is done with type classes.
19:51:12 <aavogt> the issue is that haskell named fields are horrible
19:51:36 <lispy> aavogt: only in that they polute the module name space.  Otherwise, they seem fine to me
19:51:43 <badkins> in a nutshell, I'd like to be able to sort a list of Drivers or a list of Vehicles by any one of the 7 attributes without a proliferation of functions
19:52:47 <badkins> with dynamic typing and named fields i.e. Hashes, I could just ask the list element for its Attributes and then extract speed from that
19:52:54 <badkins> obviously, that's not the static typing way
19:53:08 <badkins> I'll look at typeclasses
19:53:13 <drhodes> badkins: one of the hurdles when picking up haskell is using pattern matching effectively.  With smaller types it might not be necessary to have accessor functions at all.
19:53:19 <Jafet> badkins: so pass the attribute selector as a parameter. Eg. sortDriversBy ds field = sortBy (comparing (field . driverAttributes)) ds
19:53:26 <Jafet> badkins: that's the functional style.
19:53:39 <lispy> :t on
19:53:40 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:53:50 <lispy> I bet sortBy + on would be deadly here
19:53:50 <badkins> drhodes: I started out with just Tuples and got schooled by some knowledgeable folks here and ended up with what's in the paste
19:54:11 <Jafet> (comparing f = compare `on` f)
19:54:22 <badkins> Jafet: so have a duplicate set - one for Driver and one for Vehicle ?
19:54:29 <lispy> Jafet: ah
19:54:37 <badkins> i.e. sortDriversBy and sortVehiclesBy ?
19:54:52 <badkins> that's a shame because they're very similar
19:54:56 <lispy> badkins: duplicate set/
19:54:58 <lispy> ?
19:55:22 <badkins> lispy: of functions
19:55:23 <Jafet> badkins: they have unrelated types, so they're different. If you think they should be related, you can relate Driver and Vehicle with a typeclass
19:55:53 <badkins> Jafet: gotcha. I think they share much conceptually and should be related.
19:55:56 <Jafet> Haskell can't magically figure out that Driver and Vehicle are supposed to be similar, even if you think they should be.
19:56:13 <badkins> the *only* difference is that Vehicles also have a VehicleType
19:56:50 <badkins> as an aside, is there any way to not have "deriving (Show)" repeated so many times with some sort of scope maybe?
19:57:33 <badkins> BTW I do appreciate the help. This is basically my first Haskell program apart from exercise examples while working through books.
19:57:47 <lispy> badkins: When you sort them, typically you sort them based on one attribute each.  You can use some higher order functions + an accessor (we would say projection) to then build the per-type sorting with very little duplication
19:57:53 <accel> the difference between sepBy and endBy -- sepBy ends on a token, endBy ends on a separator?
19:57:58 <accel> the difference between sepBy and endBy -- sepBy ends on a token, endBy ends on a separator? (in the context of parsec)
19:58:23 <aavogt> badkins: if you wrote the data in a template haskell quote like:    f [d| data X = X; data Y = Y |], you can make the f add Show to the deriving
19:58:31 <byorgey> accel: yes
19:58:44 <accel> byorgey+=
19:58:46 <accel> byorgey++
19:59:06 <Jafet> Being a beginner, I think badkins should type a little more before he finds out all these esoteric ways of typing less
19:59:07 <aavogt> badkins: you probably don't want that as it makes you ghc-only. Using a preprocessor (the C one is popular) is probably better
19:59:33 <badkins> aavogt: thanks, but I'd like to stick with core Haskell for a while :) Template Haskell scares me and seems like a hack to get Lisp macros.
19:59:56 <Jafet> In the context of that kart racer, those Show derivations look like they're for show, anyway
19:59:59 <lispy> badkins: sticking to core Haskell is wise.  TH is only superficially a hack to get lisp macros.
20:00:12 <badkins> ok, so in a nutshell, relate Driver and Vehicle with a type class and write a "speed" accessor for each of them.
20:00:19 <lispy> badkins: TH is actually very deep and safe (and thus not a hack at all).  It could use some polish though
20:00:42 <badkins> lispy: ok, I recant :)
20:01:01 <Jafet> badkins: you can try it, but it probably adds up to more typing than just giving them different names.
20:01:06 <badkins> Jafet: the Show was just to spit stuff out in ghci
20:01:27 <kulakowski> lispy: I parsed polish as Polish as in (reverse) polish notation...
20:02:01 <Jafet> As long as it doesn't become hungarian
20:02:14 <aavogt> lispy: what do you mean by deep?
20:02:14 <accel> http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html <-- is the final source code to this available somewherE?
20:03:17 <lispy> aavogt: the principles it's founded on are sound
20:04:03 <lispy> aavogt: for example, they carefully analyzed which stages of computation/compilation it could be performed at and it still gets type checked
20:04:35 <aavogt> it's still inconvenient
20:04:46 <aavogt> stage restrictions and such
20:04:48 <lispy> aavogt: But, the top level splice restriction is a bit of a UI infidelity that could use polish
20:05:20 <lispy> I think that rough edge gives people the impression it's less rigorous than it really is
20:05:49 <aavogt> lispy: "top level splice restriction" is that splices are expanded in order? Or that you have to import things?
20:07:18 <lispy> aavogt: It's been a while since I looked at it, I forgot exactly but I Think it's the way things get expanded
20:08:41 <aavogt> I dunno what's special about top-level then
20:08:59 <lispy> I don't either, TBH
20:09:08 <aavogt> lispy: also, splices are typechecked as a group, which leads to odd type errors sometimes
20:09:14 <lispy> IIRC, it was one of those simplifying assumptions that helped get the initial version done
20:09:15 <aavogt> inline splices
20:09:31 <lispy> But not related to a fundamental issue
20:09:41 <aavogt> so if you ex. try to write      $(liftA n) inline, in several places, it doesn't work very well
20:10:26 <aavogt> because the type variables attached to the function produced by liftA are more connected than they are normally
20:11:19 <lispy> aavogt: so don't make type errors ;)
20:12:04 <aavogt> lispy: it's not about type errors, it's about needing more annotations, or doing the $( ) at top-level instead
20:12:23 <aavogt> in which case you give up the freedom to order things as you please
20:13:06 <bvck> Hi folks, the following from the Haskell 2010 language report: "Patterns are matched against values. Attempting to match a pattern can have one of three results: it may fail;
20:13:08 <bvck> it may succeed, returning a binding for each variable in the pattern; or it may diverge (i.e. return )."
20:13:19 <bvck> Can someone please explain what 'diverge' here means?
20:13:36 <lispy> aavogt: that's interesting.  It sounds like you use TH quite a bit.  Have you thought about trying to hack on GHC to improve it?
20:13:52 <aavogt> lispy: maybe it is wonderful that generated code is type checked and if you're careful you can be hygenic. But there are issues.
20:14:11 <aavogt> lispy: no, it's difficult stuff. Saizan would be more appropriate.
20:15:03 <lispy> bvck: That sentence seems malformed, but usually when a computation diverges it means that it is essentially undefined.  It could mean it goes into a never ending loop or that it's an exception.
20:15:37 <byorgey> lispy: what's malformed about it?
20:15:41 <bvck> lispy: the return actually has the symbol for 'bottom'. Thanks for explaining that.
20:15:50 <lispy> byorgey: "(ie. return )."
20:16:01 <byorgey> oh, yeah, I assumed there was a missing _|_ there
20:16:05 <bvck> Cut & paste did not do a good job.
20:16:13 <bvck> byorgey, Yup, that is the one.
20:17:26 <bvck> I am going to regret asking this, but is there an easy place I can look at Haskell implementation of pattern matching?...:)
20:18:52 <byorgey> you mean you want to see some nice code demonstrating the concept?  or you want to see what a compiler actually does?
20:19:15 <bvck> byorgey, how the compiler actually does it.
20:20:01 <lispy> bvck: you could emulate it in C with structs that have a 'tag' field.  Then you'd check that tag to see which constructor you have
20:21:21 <byorgey> bvck: yeesh.  well, the GHC source code is at http://darcs.haskell.org/ghc.git/, be my guest.  Good luck finding/understanding the pattern matching part though.
20:22:15 <bvck> byorgey, hence my hesitation in asking (hoping against hope)...:)
20:22:54 <aavogt> there are simpler haskell implementations you might look at
20:23:04 <aavogt> maybe  uhc?
20:23:07 <bvck> aavogt, for example?
20:23:22 <bvck> Ah, okay. Will take a look.
20:25:46 <aavogt> bvck: but you can probably look at it as two different steps: (1) translate to single parameter matching like 'case', (2) actually evaluate the simpler language (which I have no idea of how that happens)
20:27:29 <aavogt> as an extreme to suggest you have to stop somewhere: you would study semiconductor physics to program?
20:27:48 <dcolish> stepcut: Hey, I'm working through your guide on building C++ FFI and I'm having some issues generating the object names from a compiled library
20:28:56 <dcolish> i'm on osx and i'm not getting namespaces like your sample output shows
20:29:05 <revenantphx> quick challenge for you guys
20:29:12 <revenantphx> Say I have 
20:29:15 <revenantphx> Saying "X, when appropriate, is never optional", when appropriate, is never optional.
20:29:30 <revenantphx> How could I write out a haskell expression that produces an infinite recursion of the statement.
20:29:35 <revenantphx> Saying "Saying "X, when appropriate, is never optional", when appropriate, is never optional., when appropriate, is never optional", when appropriate, is never optional.
20:29:36 <revenantphx> etc
20:31:44 <aavogt> revenantphx: how do the " work?
20:32:17 <aavogt> > "X," ++ cycle " when appropriate, is never optional.,"
20:32:18 <lambdabot>   "X, when appropriate, is never optional., when appropriate, is never option...
20:32:40 <aavogt> also your . is kind of weird after the middle optional
20:38:13 <Thamster_> sup room, is it safe to ask basic questions about monads functors etc here?
20:38:46 <shachaf> Thamster_: Only minor injuries have been known to occur as a result of such questions.
20:38:47 <JoeyA> Yup
20:38:50 <JoeyA> lol
20:39:02 <Thamster_> cool
20:39:34 <JoeyA> Functor: a box of something you can drop a function into without unwrapping it.
20:39:39 <Thamster_> is the following statement true 
20:39:40 <JoeyA> > (+3) <$> [5]
20:39:41 <lambdabot>   [8]
20:39:58 <JoeyA> go ahead
20:39:59 <Thamster_> #monads can be instances of both functors and applicative functors <*> spaceship
20:40:12 <JoeyA> Yes.
20:40:27 <JoeyA> (though if they aren't members, you'll have to implement the functionality yourself.
20:40:43 <shachaf> Thamster_: Every monad is also a Functor and an Applicative, with fmap = liftM, pure = return, (<*>) = ap
20:41:05 <Thamster_> is <*> a synonim for fmap?
20:41:15 <shachaf> Thamster_: No, that's (<$>).
20:41:36 <shachaf> (<*>) is like ap, except for Applicatives instead of just Monads:
20:41:39 <shachaf> @ty (<*>)
20:41:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
20:42:36 <Thamster_> hmm
20:43:14 <Thamster_> so Applicatives are?
20:43:50 <shachaf> Thamster_: Anything Functor that has pure (:: a -> f a) and (<*>), satisfying the Applicative laws. :-)
20:44:00 <shachaf> Some Applicatives aren't Monads, e.g. ZipList.
20:45:48 <Thamster_> k thanks its a place to start
20:45:56 <Thamster_> i found a good site for method definitions
20:45:56 <Thamster_> http://zvon.org/other/haskell/Outputglobal/
20:45:56 <monochrom> > text (fix ("it is never optional to say: \" ++))
20:45:57 <lambdabot>   <no location info>:
20:45:58 <lambdabot>      lexical error in string/character literal at end o...
20:46:03 <monochrom> > text (fix ("it is never optional to say: \"" ++))
20:46:13 <Thamster_> is there another site for imported stuff from standard libs
20:46:17 <lambdabot>   mueval: ExitFailure 1
20:46:23 <shapr> JoeyA: Where do you learn all this stuff?
20:46:28 <monochrom> I guess text is pretty strict
20:46:48 <monochrom> > fix ("it is never optional to say: " ++)
20:46:50 <lambdabot>   "it is never optional to say: it is never optional to say: it is never opti...
20:47:25 <shachaf> > cycle ("Saying \"")
20:47:26 <lambdabot>   "Saying \"Saying \"Saying \"Saying \"Saying \"Saying \"Saying \"Saying \"Sa...
20:47:36 <Thamster_> so :
20:47:46 <Thamster_> (<*>) :: f (a -> b) -> f a -> f b  
20:47:48 <sproingie> > fix ("buffalo " ++)
20:47:51 <lambdabot>   "buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo bu...
20:47:55 <JoeyA> lol
20:48:06 <shachaf> > iterate (\x -> "Saying \"" ++ x ++ ", when appropriate, is never optional.") "X"
20:48:08 <lambdabot>   ["X","Saying \"X, when appropriate, is never optional.","Saying \"Saying \"...
20:48:10 <ray> > fix (++ "\" cannot be proved in system H")
20:48:13 <JoeyA> shapr: Was that meant for me?
20:48:14 <lambdabot>   mueval-core: Time limit exceeded
20:48:28 <Thamster_> fmap :: (a -> b) -> f a -> f b  
20:48:39 <Thamster_> looks similar
20:48:48 * hackagebot vector-buffer 0.3 - A buffer compatible with Data.Vector.Storable  http://hackage.haskell.org/package/vector-buffer-0.3 (VivianMcPhail)
20:48:52 <shachaf> Thamster_: Except for the f, yes. :-)
20:49:18 <Thamster_> so <*> is a functiful version of fmap?
20:50:10 <shapr> JoeyA: Yah, just curious where you learned about applicative vs monads and that sort of thing.
20:50:29 <JoeyA> Programming in Haskell and thinking about it for way too long.
20:50:41 <shachaf> shapr: Mostly #haskell.
20:50:42 <JoeyA> and, mainly (I think) asking in this channel
20:50:43 <JoeyA> Right
20:50:46 <shapr> How long have you been writing Haskell?
20:51:02 <JoeyA> A few months, but I haven't done much of it lately.
20:56:35 <Thamster_> so in your example
20:56:36 <Thamster_> (+3) <$> [5]
20:56:46 <ray> [8]
20:56:51 <Thamster_> this part is the "Functor": <$> [5]
20:56:54 <Thamster_> ?
20:56:58 <Thamster_> the box
20:57:01 <Thamster_> of something
20:57:05 <shachaf> Thamster_: The "Functor" is [].
20:57:18 <shachaf> Thamster_: Thinking of them as boxes is probably not that helpful.
20:57:22 <Thamster_> so the function i'm dropping is in fact
20:57:30 <Thamster_> (+3) <$>
20:57:33 <Thamster_> equiv to 
20:57:36 <Thamster_> fmap (+3)
20:57:39 <JoeyA> Yes
20:57:44 <shachaf> @src <$>
20:57:44 <lambdabot> f <$> a = fmap f a
20:58:12 <shachaf> E.g. (Char -> Int) isn't "a box with an Int inside", but it is a functor ((->) Char) Int.
20:59:24 <ray> well if you like torturing analogies, it's the type of vending machines with ints inside that drop one depending on what char you put in the slot
20:59:32 <shachaf> ray: Not really.
20:59:44 <shachaf> data Null a = Null is a Functor too.
21:00:05 <shachaf> It's just not a helpful analogy.
21:00:11 <aavogt> empty box!
21:00:14 <ray> that's different, that's the type of boxes with no interior
21:00:19 <shachaf> getLine :: IO String doesn't "contain" a String, etc.
21:00:30 <shachaf> Fine, you can stretch it. But it's not helpful.
21:00:47 <JoeyA> f :: OfficeChair -> Bobcat
21:04:17 <Thamster_> zip returns a list of tuples
21:04:29 <Thamster_> ziplist returns a cartesian product of combinations?
21:04:36 <Thamster_> all possible combinations?
21:08:20 <JoeyA> > zip "ABC" [1,2,3]
21:08:21 <lambdabot>   [('A',1),('B',2),('C',3)]
21:08:53 <JoeyA> > [(a,n) | a <- "ABC", n <- [1,2,3]]
21:08:54 <lambdabot>   [('A',1),('A',2),('A',3),('B',1),('B',2),('B',3),('C',1),('C',2),('C',3)]
21:10:22 <JoeyA> > [(a,n) | a <- "ABC" | n <- [1,2,3]] -- parallel list comprehension (requires an extension)
21:10:23 <lambdabot>   [('A',1),('B',2),('C',3)]
21:16:54 <gwern> > 2011 - 1983
21:16:55 <lambdabot>   28
21:17:13 <shachaf> gwern: What happened in 1983?
21:17:18 <shapr> gwern: So, how old are you? :-)
21:17:24 <shapr> > 2011 - 1971
21:17:25 <lambdabot>   40
21:17:29 <shapr> urk
21:18:11 <ray> > 2011 - 1549
21:18:12 <lambdabot>   462
21:18:38 <kulakowski> > 2011 - 711
21:18:39 <lambdabot>   1300
21:19:08 <gwern> shachaf: the NES was released
21:19:29 <JoeyA> > 2011 - 0
21:19:30 <lambdabot>   2011
21:19:34 <JoeyA> Wow, that's a long time ago.
21:20:37 <Rotaerk> > 1 + 1 = 5
21:20:38 <lambdabot>   <no location info>: parse error on input `='
21:20:56 <Rotaerk> oh right.. double equals..
21:21:30 <JoeyA> > 2+2 ===================================== 4
21:21:31 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
21:21:31 <lambdabot>    arising from the literal `2'...
21:22:53 <JoeyA> > (2+2) ===================================== 4
21:22:55 <lambdabot>   True
21:23:32 <monochrom> what are you people doing with =====?
21:24:11 <monochrom> "my equal sign is longer than yours"?
21:24:15 <shachaf> monochrom: It's ported over from JavaScript.
21:24:34 <monochrom> I thought Javascript had only == and ===
21:24:43 <ray> i will sette as i doe often in worke use a pair of paralleles or gemowe lines of one lengthe, thus: ========= bicause noe 2 thynges can be moare equalle
21:25:05 <ray> i had to look most of that up :(
21:25:13 <monochrom> hahaha
21:27:03 <luite_> Orwell would disagree
21:28:45 <allbery_b> if you say so, Chaucer
21:31:43 <blackdog> here's a fun task: develop something on i386, and fail to notice that you haven't included a header file. still links ok, but your friendly neighbourhood c compiler has decided that it's a signed, 32 bit int.
21:31:47 <blackdog> now, port to 64 bit, and wonder what the hell is happening to your top 32 bits...
21:32:02 <stepkut> you lost me at 'c' compiler
21:32:10 <blackdog> still, it explains why i was having trouble with bigints
21:32:19 <blackdog> stepkut: it's a haskell project, if that helps.
21:32:34 <shachaf> blackdog: Doesn't -Wall catch that?
21:32:37 <stepkut> blackdog: :)
21:33:25 <blackdog> shachaf: it was buried many levels deep. i think I had -Werror on at one stage, but it's difficult to make generated code warning-free
21:34:01 <shachaf> blackdog: It's probably worthwhile to disable generated-code-irrelevant warnings individually.
21:35:33 <thatBlueThing> Hey there, I'm relatively new to haskell: is there any way to test whether something is a certain (algebraic data) type vs. another?
21:35:49 <shachaf> thatBlueThing: Test in what context?
21:36:04 <blackdog> thatBlueThing: generally you call it a compiler
21:36:08 <thatBlueThing> shachaf: programmatically; essentialy a -> Bool
21:36:15 <thatBlueThing> something like isTypeX
21:36:16 <shachaf> thatBlueThing: You can use e.g. Data.Typeable.typeOf and so on, but it's usually not a good idea.
21:36:37 <shachaf> thatBlueThing: There's also cast :: (Typeable a, Typeable b) => a -> Maybe b.
21:36:43 <blackdog> you'd actually have to go out of your way to get a situation where it's not caught at compile time
21:37:05 <thatBlueThing> let me clarify why I want it; perhaps there's a better pattern for what I'm looking to do
21:37:22 <thatBlueThing> i've written a scanner + parser in haskell, where the scanner outputs [Token]
21:37:37 <thatBlueThing> where Token :: (startPos, endPos, TokenADT)
21:37:49 <thatBlueThing> I want to be able to count the number of occurrences of the various TokenADT
21:37:54 <thatBlueThing> for a frequency table of tokens
21:38:01 <thatBlueThing> in the language I've written the scanner/parser for
21:38:15 <blackdog> thatBlueThing: so they're of the same type - you just want to count how many times each constructor is used
21:38:19 <thatBlueThing> correct
21:38:33 <shachaf> Oh. That's a completely different question.
21:38:38 <shachaf> Just pattern match.
21:39:06 <thatBlueThing> shachaf: that does make more sense
21:39:15 <thatBlueThing> as you can tell, I'm *incredibly* new
21:39:20 <thatBlueThing> to FP as well
21:40:24 <thatBlueThing> thanks
21:55:31 <Ptival> @pl do return x
21:55:31 <lambdabot> do return x
21:55:51 <Ptival> hum
21:55:51 <shachaf> @undo do return x
21:55:52 <lambdabot> return x
21:56:00 <Ptival> no need for do?
21:56:13 <shachaf> Nope. do { x } === x
21:56:32 <Ptival> ok thanks
22:42:22 * hackagebot sbv 0.9.10 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.10 (LeventErkok)
23:15:29 <c_wraith> aaargh.  I just spent an hour trying to track down how a massive, but conceptually simple, refactoring could have possibly broken my application.  Turns out, I was testing it wrong.
23:29:22 <othiym23> hey all, does anyone know why this happens? http://hpaste.org/44029/weird_precision_error
23:29:38 <c_wraith> you're on OS X?
23:29:44 <othiym23> yes, 10.6.5
23:29:57 <othiym23> haskell-dist installed via MacPorts
23:30:06 <c_wraith> yeah, that's a known bug in the version of GHCi in the macports installer
23:30:15 <c_wraith> it segfaults in all kinds of situations
23:30:27 <NihilistDandy> Use brew
23:30:35 <othiym23> sweet, am I better off nuking the macports dist and installing the binary installer?
23:30:50 <c_wraith> I'd probably use the haskell platform installer, as a beginner...
23:31:00 <othiym23> I will do that, then
23:31:18 <othiym23> NihilistDandy: I don't want to install yet another package manager on top of an already kinda rickety system, but thanks for the pointer
23:31:27 <NihilistDandy> lol
23:31:37 <NihilistDandy> Just sayin'. :D
23:32:01 <aleator> NihilistDandy is probably right. macports has been a pain.
23:32:29 <othiym23> eh, I'm fine using the binary installer now that it comes with an uninstaller
23:32:32 <NihilistDandy> brew's much more convenient than ports. I never like sudo :/
23:32:44 <NihilistDandy> But yeah, the binary's good
23:32:59 <NihilistDandy> Actually, there's a 7.01 binary out there, if you're feeling adventurous
23:33:09 <othiym23> sure! why not!
23:33:13 <NihilistDandy> No Platform, but that just a couple of cabal's anyway
23:33:22 <aleator> NihilistDandy: Brew seems ok. Macports is broken with the iconv, fink I never got to work, but there was another alternative that I can't remember right now
23:33:36 <NihilistDandy> Hang on, I'll look up the link, othiym23 
23:33:51 <NihilistDandy> aleator: The active development on brew is what makes it for me, really
23:34:15 <othiym23> NihilistDandy: I have the package off haskell.org (taken from the /topic)
23:34:26 <NihilistDandy> Ah, yeah, that'd be it, I think
23:34:32 <NihilistDandy> 64-bit, hurrah
23:34:42 <othiym23> NihilistDandy: ports was a huge improvement (as an ex-FreeBSD admin) over fink, but yeah, its freshness is highly variable
23:35:00 <blueonyx> hi, on archlinux should i rather use the aur instead of cabal?
23:35:15 <NihilistDandy> Yeah. I used fink years ago, went to ports for a bit, then found brew and fell in love
23:36:00 <othiym23> moving all my random crud from /usr/local into being ports-managed was enough of an undertaking, I'll stick with ports for now
23:36:09 <othiym23> anything that keeps me from having to recompile Boost make me happier
23:40:32 <NihilistDandy>  /usr/local's there for a reason :D
23:41:25 <othiym23> ffmpeg, random PostgreSQL and MySQL builds, and MacFUSE extensions?
23:41:27 <othiym23> that's what's in mine
23:41:36 <othiym23> brb
23:48:43 <jonkri> there is an "old-locale" package in http://hackage.haskell.org/packages/archive/pkg-list.html referencing to a "new" locale package. however, i can't find one through hoogle [ http://haskell.org/hoogle/?hoogle=System.Locale ]. does it exist? where is it?
23:51:54 <blueonyx> jonkri: i couldn't find it either, so i sticked with the old one, works too :)
23:52:55 <othiym23> how well does cabal work with Haskell 7?
23:53:15 <c_wraith> hard to build with GHC 7, last I checked
23:53:20 <NihilistDandy> othiym23: It's been working fine for me
23:53:34 <NihilistDandy> Took me a bit to get all the right packages, but no problem since then
23:54:05 <NihilistDandy> Maybe an hour or so of dependency chasing, total, and I'm fairly distractable
23:54:23 <othiym23> sounds like I can handle it, then
23:55:32 <NihilistDandy> I kind of prefer building by hand, but cabal's nice when I'm feeling lazy
23:56:53 <jonkri> how do i know which version of dependencies i should put in my .package file? i guess i want a feature to investigate what versions of dependencies we can set without the build breaking
