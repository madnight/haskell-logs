00:14:26 <abrag> hi
00:14:37 <abrag> how to star learning haskell?
00:14:52 <abrag> any good tutorial?
00:14:58 <sipa> @where lyah
00:14:59 <lambdabot> http://www.learnyouahaskell.com/
00:15:10 <sipa> start there :)
00:15:13 <abrag> thank you
00:15:44 <jaj> abrag: there is also this book which is very nice: http://www.realworldhaskell.org/
00:16:01 <abrag> aha !
00:22:44 <hpaste> jaj pasted "dbus Reader"  http://hpaste.org/44388
00:23:09 <jaj> more specifically, I'd like to get the "onFoo" function inside the Reader monad
00:28:41 <jaj> HLint on hpaste is great :)
00:51:54 <hpaste> aperiodic pasted "Foldr groupBy"  http://hpaste.org/44389
00:53:20 <aperiodic> i'm having trouble understanding why the function i pasted doesn't properly lazily evaluate
00:53:41 <aperiodic> i don't see where evaluation of all of xs happens
00:54:44 <augustss> what's an example of where it's not lazy enough?
00:55:24 <augustss> But it's probably g.  It evaluates its second argument.
00:56:29 <aperiodic> head $ grpBy (==) [1..large_number]
00:56:47 <hymnusalae> Excuse me, while -> is already an instance of Arrow, and Arrow is a class instance of Category, why still need to define -> as an instance of Category? What's it for?
00:56:57 <aperiodic> how do i get the head of a list lazily, then?
00:57:04 <jaj> (what I needed was mapReader)
00:57:06 <augustss> aperiodic: do you mean: head $ head $ grpBy ...
00:57:41 <aperiodic> augustss: the prelude groupBy immediately returns [1] for head $ groupBy (==) [1..large_number]
00:57:46 <aperiodic> whereas mine hangs
00:57:59 <augustss> right
00:58:42 <augustss> aperiodic: it's because foldr is strict is xs, and g is strict in its second argument
00:59:04 <augustss> you can rewrite g to be a little lazier
00:59:13 <aperiodic> how would I do that?
00:59:41 <augustss> it always puts x at the beginning of the first list, so it needs to do that without examining the second argument
01:00:07 <mux> the "low level behavior of lazy functional programs" paper has a very nice schema on the stages of compilation in GHC, page 6
01:00:25 <mux> I've been looking for something like this for some time
01:00:30 <aperiodic> someone posted a solution using foldr that works lazily, so i don't think it's foldr that's causing it to hang
01:00:50 <augustss> aperiodic: no, it's the combination of foldr and g
01:01:19 <aperiodic> when you say it "examines the second argument", what exactly do you mean?
01:02:04 <augustss> aperiodic: i mean it's strict in its second argument
01:02:18 <augustss> aperiodic: it need to look at it for the pattern match
01:02:23 <aperiodic> sorry, I don't think I understand the term "strict"
01:02:35 <aperiodic> ah, so the pattern matching is what's causing the evaluation?
01:03:03 <augustss> aperiodic: yes.  to determine which clause to use g needs to evaluate the second argument
01:03:31 <aperiodic> so, if I rewrite it without pattern matching, using lazy predicates and guards, it should behave lazily?
01:04:03 <augustss> aperiodic: depends on how you rewrite, but yes, it's possible to rewrite it
01:04:36 <augustss> aperiodic: the important thing is that you need to be able to get at the x in the first list without evaluating the second argument
01:05:11 <augustss> aperiodic: the definition of strict is easy.  the function f is strict iff  f _|_ = _|_
01:07:06 <aperiodic> what does the "_|_" notation signify?
01:07:41 <companion_cube> it's the element that belongs to all types
01:07:57 <augustss> Botton.  Something non-terminating (or an error).
01:07:59 <companion_cube> and which does not terminate
01:08:07 <companion_cube> :t undefined
01:08:08 <lambdabot> forall a. a
01:08:10 <augustss> Bottom, even
01:08:14 <companion_cube> ↑ like this one
01:08:54 <augustss> In Haskell you can use, e.g., 'undefined'
01:10:54 <augustss> The definition of strictness is easy, but a little more subtle than one might first think.
01:13:05 <aperiodic> I'm not sure I understand the implications
01:14:23 <aperiodic> I've found a page on the haskell wiki about stack overflows that seems to address the problem I'm having
01:30:06 <aperiodic> I don't get how to evaluate whether or not some function is "strict"
01:31:39 * hackagebot piki 0.5.1 - Yet another Wiki format converter  http://hackage.haskell.org/package/piki-0.5.1 (KazuYamamoto)
01:33:10 <aperiodic> do I need to make my function return without ever having to use its second argument to decide how to return?
01:34:35 <augustss> aperiodic: not without ever looking at the second argument.  But you can see that g returns (x: ...) : ... regardless of the second argument
01:35:07 <augustss> So you need to make sure the rhs of g looks like that.  with the appropriate things filled in for ...
01:35:19 <dankna> aperiodic: in general, things in Haskell are actually evaluated at the time you pattern-match against them; before that, they're represented as thunks
01:35:57 <dankna> aperiodic: so to the extent that you don't pattern-match, you're lazy
01:36:18 <dankna> aperiodic: for example, if you pattern-match on the "spine" of a list but not on its elements, the list is forced but the elements aren't.
01:36:33 <dankna> does that help?
01:38:24 <aperiodic> so a pattern like (x:xs) evaluates the thunk representing the list, but not the thunks representing the elements of the list?
01:38:45 <dankna> correct
01:39:27 <dankna> it can be difficult to reason about without seeing the definition of a function, so if you find it confusing, you're not alone.  but that's the rule to keep in mind.
01:39:50 <aperiodic> so if I had the list [undefined, undefined], then i can match against (x:xs), but I would get an error if I later caused x to be evaluated?
01:39:55 <dankna> exactly so
01:40:23 <dolio> > case (undefined:undefined) of (x:xs) -> 5
01:40:24 <lambdabot>   5
01:40:41 <dankna> > length [undefined, undefined]
01:40:42 <lambdabot>   2
01:40:52 <aperiodic> whereas trying to pattern match [1...] against (x:xs) will result in bottom?
01:40:54 <dankna> > foldl (+) 0 [undefined, undefined]
01:40:55 <lambdabot>   *Exception: Prelude.undefined
01:41:01 <dankna> correct
01:41:21 <aperiodic> okay, that makes sense to me
01:41:28 <dankna> great
01:41:49 <aperiodic> let me see if i can figure out how to make g non-strict now
01:41:55 <aperiodic> thanks for the help!
01:41:58 <dankna> sure!
01:43:49 <frank00> Good morning haskellers!
01:44:30 <augustss> aperiodic: pattern matching [1...] against (x:xs) should not be bottom
01:44:39 <frank00> |\|003 question: I am "cabal installing" a program in winXP and get a "pkg-config version >=0.9.0 is required but it could not be found."
01:45:01 <frank00> ^-- but when I "cabal install pkg-config" it says me there's no such thing
01:45:19 <frank00> I'm sure I'm overlooking something simple, but don't know what
01:45:34 <dcoutts_> frank00: pkg-config is not a Haskell package, it's a program used to manage C libs
01:46:23 <aperiodic> augustss: why not?
01:47:22 <dcoutts_> frank00: whatever Haskell package you're installing relies on some C lib, that C lib provides info via pkg-config, cabal is looking for pkg-config so that it can work out what flags to use for that C lib
01:47:24 <augustss> Well, I'm not sure what you mean by [1...] exactly, but anything of the form (a:b) will succed.  Only undefined will result in bottom
01:47:43 <augustss> > case [1..] of (x:xs) -> x
01:47:44 <lambdabot>   1
01:48:12 <frank00> thanks dcoutts_, I thought cabal would auto install that. I'll fiddle with it and tell the result!
01:48:17 <dankna> augustss: I believe you're reading him backwards
01:48:33 <aperiodic> augustss: i meant for [1...] is equivalent the positive integers
01:48:39 <dcoutts_> frank00: it's not something cabal can install, you need the C libs (and associated config utils) on your system
01:48:49 <augustss> aperiodic: So [1..] in Haskell
01:49:09 <dankna> dcoutts_: btw while you're here and I'm thinking of it!
01:49:09 <aperiodic> yes
01:49:26 <dcoutts_> frank00: take a look at the package you're installing, see what C lib it is after (the .cabal file says) and see if it's possible to get that installed on windows (it may not be)
01:49:51 <dankna> dcoutts_: some time ago I had written a patch to support self-hosting preprocessors by putting their output in a new directory preprocessed/something/ instead of dist/
01:50:11 <dankna> dcoutts_: I think you gave me some cleanup work to do before the patch was acceptable, and I never did it.  do you remember what it was? :)
01:50:13 <dcoutts_> dankna: yes, we never finished reviewing and applying it did we
01:50:24 <dankna> dcoutts_: yeah, we never did
01:50:34 <dcoutts_> gimme a sec...
01:50:37 <dankna> great, thanks
01:53:34 <dcoutts_> dankna: should probably start by reviewing the email discussion, my first reply was 16 June 2010 15:08
01:53:48 <dankna> I've got that open now, I'm rereading it
01:54:37 <dankna> Do you still feel that we shouldn't write into preprocessed/ except when doing sdist?
01:54:54 <vegai> anyone got an example of using the Network.FastIRC library?
01:55:04 <vegai> the api confuses me
01:55:26 <dcoutts_> dankna: yes, I think that makes sense
01:55:48 <dcoutts_> dankna: I recall thinking that the specialisations scheme was rather too complex
01:56:04 <dcoutts_> dankna: I don't think it should need any extensions of the user hooks
01:56:09 <dankna> I tend to agree that the specializations scheme is not great.
01:56:36 <dankna> but we don't have a use-case for specializations yet, so it's hard to deal with
01:56:56 <dankna> well, I guess we have Happy - it generates code depending on whether the compiler is GHC, but doesn't care about the version thereof
01:57:42 <dcoutts_> dankna: right
01:58:07 <dcoutts_> dankna: we also in principle can have platform specific things like c2hs
01:58:43 <dankna> I don't see how we can know what to specialize on without being told by the .cabal file or the user hooks
01:58:59 <dankna> would you be happier if it were made declarative rather than imperative and put in the .cabal file?
01:59:34 <dcoutts_> dankna: for using specialisations it's easy. The only bit that needs input from the user perhaps is which specialisations to generate.
01:59:44 <dcoutts_> dankna: and the latter happens during cabal sdist
02:00:00 <dankna> well, I see two separate issues
02:00:26 <dankna> one issue is which specializations to generate and to look for preexisting copies of when compiling
02:00:44 <dankna> the other is whether to use the specializations system at all, or whether to use dist/ as normal
02:01:03 <dankna> the latter is what you seem to be talking about
02:02:17 <dankna> by the way, my thoughts on making it happen during sdist are that that's all well and good but it seems like there should be (I know you aren't going to like this ^_^) a top-level command to just do the preprocessing, putting the output into preprocessed/
02:02:28 <dankna> that way you can conveniently get the output for adding to the version-control repository
02:02:41 <dankna> otherwise you would have to do sdist and then unpack the file from the tarball
02:02:55 <dcoutts_> dankna: well there should be a flag to sdist to not make a tarball, just prep a sdist tree
02:03:03 <dcoutts_> we need that anyway
02:03:11 <dankna> okay, if that's your preference, that does meet this need
02:03:39 <aperiodic> augustss: that makes sense to me, because lists must be built up out of lots of thunks of the ":" operator, so you would only need to evaluate one of those thunks to pattern match against (x:xs)
02:03:41 <dankna> but we do need input from, not the user, but the library author, to determine which specialization to use
02:04:02 <augustss> aperiodic: exactly
02:04:08 <dcoutts_> dankna: so when building a package, we decide which of the specialisations to use, then we form a search path: most specialised to least. We do pre-processing and any files we generate go into dist/ and the dist location appears last on the search path when we come to compile.
02:04:35 <dankna> so we never produce output in preprocessed/ except when doing sdist.  right, okay.
02:04:41 <aperiodic> augustss: but, if that's the case (which it does seem to be), then I still don't understand where g is causing all of the thunks making up ys to be evaluated
02:04:56 <dcoutts_> dankna: why do we need input from the lib author? Surely we just look at what platform we are on now and use the appropriate specialisations.
02:05:19 <dankna> dcoutts_: because there are several (an infinity of) possible destinations for the preprocessed file
02:05:31 <dankna> in the case of Happy, we want the compiler name but not its version to be specialized on
02:05:39 <dankna> note that specializations do not form a total ordering
02:05:55 <dankna> in the case of c2hs we want, potentially, much more - compiler name, version, OS, ...
02:06:07 <augustss> because the thunk for (y:ys) is built by the recursive call to foldr.  Which in turn needs to pattern match on xs.  And so on until you reach the end of the list.
02:06:26 <dankna> in the case of my yet-unreleased Joy we want nothing at all, because its output is generic
02:06:45 <dcoutts_> dankna: ok, so we look first in $compilername-$compilerversion and then $compilername
02:06:48 <dankna> (it still needs this feature, but the output needs to go in the "generic" specialization)
02:07:09 <dankna> yes, but we're not talking about looking here.  we're talking about generating.
02:07:51 <dankna> self-hosting code is hard :)
02:07:59 <dcoutts_> dankna: no, we're talking at the moment about simply using the specialisations that are available, not about the user deciding at sdist time which ones to generate
02:08:29 <frank00> dcoutts_ : I am installing GTK, let's see if this works
02:08:38 <dankna> oh, sorry.  I didn't say explicitly enough that I agree that we've solved that bit
02:08:55 <dankna> wait - no.  we've solved it as long as there exists a total ordering of specializations.
02:09:01 <dcoutts_> dankna: so how about we make an arbitrary ordering on the variables for the cases where there is not an obvious "more specialised than" relationship
02:09:09 <dankna> right, okay
02:09:42 <dcoutts_> dankna: e.g. compiler name and version is clearly more specialised than just compiler name, but there's no particular ordering between arch and os, so we just fix an arbitrary ordering.
02:09:49 <aperiodic> augustss: ah, i see what's happening now
02:09:54 <dankna> in practice that will never bite us (ha ha), because no package will want more than one specialization strategy
02:11:38 <dcoutts_> dankna: ok, so for generating specialisations, in many cases we can probably just do it automatically, e.g. for happy, generate ghc specific and generic
02:12:04 <dankna> so yeah, I'm looking at my list of what my three patches did, and it looks like the one for including preexisting files in preprocessed/ in sdist can stay as it is; the one for the user hook needs to come out to be replaced by something we still need to talk about; and the patch against Happy is irrelevant here
02:12:13 <dcoutts_> dankna: for platform-specific it's not obvious that you want to generate specialisations by default
02:12:25 <dankna> dcoutts_: hmm.... well, yeah, it's not obvious
02:12:57 <dcoutts_> dankna: right, so for those ones we need to think about who should specify it and where
02:13:12 <dankna> I believe it should be the library author
02:13:23 <dcoutts_> dankna: and a lightweight approach might just be to specify on the command line at sdist time
02:13:38 <dcoutts_> so no code in Setup.hs, nothing in the .cabal file
02:13:43 <dankna> well, I guess that's fine for now
02:13:56 <dankna> when we have a bunch of packages using this facility we can revisit streamlining it
02:14:00 <dcoutts_> right
02:14:48 <dcoutts_> what specialisations are possible is also a property of the pre-processor
02:14:53 <dankna> yes
02:15:11 <dankna> so you'd like a command-line option like --specialized-directory=ghc-blahblahblah
02:15:20 <dankna> where the user explicitly passes in the complete string
02:15:25 <dcoutts_> dankna: the pre-processor info currently has just a Bool to say if it's totally platform independent or not
02:15:38 <dankna> dcoutts_: hmmm okay.  that doesn't thrill me.
02:16:18 <dcoutts_> dankna: what about instead, the user says which pre-processors or kinds of source they want to pre-process and we generate the specialisation string based on info we know about the preprocessor
02:16:34 <dankna> yeah hm
02:16:45 <dankna> (passing the complete string, I was about to say, is bad)
02:17:02 <dankna> well, can't we just assume they want all or none
02:17:12 <dcoutts_> e.g. for happy we declare somehow that it can generate source that is totally independent, but it can also generate ghc-specific code
02:17:19 <dankna> and we generate the specialization string based on our hardcoded information about the preprocessor
02:17:26 <dcoutts_> right
02:17:40 <dankna> right - the same information as I as putting in the user hook, just a list like [CompilerVar]
02:17:50 <dcoutts_> dankna: note that users can declare pre-processors in the Setup.hs, so it's somewhat extensible
02:17:54 <dankna> oh, good
02:18:17 <dankna> is there an existing variable name that means "compiler name and not version" or should I add one?
02:18:43 <dcoutts_> dankna: I'm not sure, check the InstallPaths module
02:18:51 <dankna> I will do so and add it if it doesn't already exist
02:18:53 <dcoutts_> make that a separate patch
02:18:56 <dankna> okay
02:20:20 <dankna> okay, so I had originally written, "There are three main pieces to the patch, as the commit messages will
02:20:20 <dankna> explain.  Briefly, the first piece simply redirects the output, the
02:20:20 <dankna> second piece makes sure the output is included in the sdist tarball,
02:20:20 <dankna> and the third piece adds a user hook to implement the
02:20:20 <dankna> subdirectory-naming policy we discussed."
02:20:27 <dankna> oops, bad line-wrapping in paste, but you get the idea
02:20:42 <dankna> the part that redirects the output needs to be changed to only do it at sdist time
02:20:52 <dankna> the part that makes sure it's included in sdist can stay the same
02:20:53 <dcoutts_> dankna: another useful preparatory patch would be to add an sdist flag to specify a target source dist directory, and  not make a tarball.
02:20:57 <dankna> the part that adds the user hook is going away
02:21:07 <dankna> dcoutts_: right, thanks.  I was about to forget to mention that.
02:22:10 <dankna> so I have one patch to change, one to keep, one to remove, and two new patches to write:  one adding an sdist flag (what would you like it called?) as you just said, and one implementing the rest of what we discussed.
02:22:14 <dcoutts_> dankna: get the early bits in, reviewed and applied rather than trying to make it all work in one go
02:22:19 <dankna> okay.
02:22:24 <dcoutts_> there's plenty of useful intermediate stages
02:24:19 <dankna> okay.  I think I know what to work on.  direct email to you is the best way to send patches when I have some?
02:25:30 <dcoutts_> dankna: if you can cc cabal-devel that'd be great, helps me keep track of patches and gives other people an opportunity to comment
02:25:41 <dankna> oh, sure thing
02:25:45 <dcoutts_> dankna: I presume you're subscribed already
02:25:47 <dankna> I believe I'm on the list, yes
02:26:05 <dankna> yes, I am, good
02:26:11 <dcoutts_> I've been trying to get contributors to talk to each other more, not just to email me directly
02:26:18 <dankna> that's a good practice
02:26:59 <dankna> by the way, I updated the bootstrap script in my private copy to work on GHC HEAD, I'm sure it's nothing you couldn't do yourself and it only took a few minutes, but let me know if you need that at any point
02:27:40 <dankna> I forget now what happened exactly, I think some packages merged or split or possibly both :)
02:28:32 <dankna> thanks for your input, and hopefully I won't drop the ball this time :)
02:28:52 * hackagebot hakyll 3.0.0.2 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.0.0.2 (JasperVanDerJeugt)
02:29:09 <bla123> can i do things like fmap with lenses (fclabels) or do i have to use sec for that?
02:30:56 <dcoutts_> dankna: I updated the cabal-install bootstrap script to work with ghc-7.0.x yesterday, I've not checked ghc HEAD
02:31:30 <dankna> oh, great
02:32:17 <frank00> dcoutts_ , if i may bother you for some minutes more... I've found a bin of pkg-config and placed it under minGW/bin/ <-- is that the correct thing to do?
02:33:17 <frank00> (I'm a bit new to compiling, sorry if my qs are naive)
02:33:18 <dcoutts_> frank00: no, the pkg-config that comes with the gtk+ C libs should stay where it is, you should put the gtk bin dir on the %PATH% and then cabal will find it.
02:33:50 <dcoutts_> frank00: it has to stay where it is so that pkg-config can find the .pc files that live in the gtk+ libs dir tree
02:34:02 <aperiodic> wow, so even though foldr is not tail-recursive, it can still run in constant stack space under some situations.
02:34:12 <aperiodic> lazy evaluation is pretty neat
02:34:23 <dankna> aperiodic: yep!
02:34:41 <maxJadi> Is there any static code analysis tool for testing on haskell code? 
02:35:01 <aperiodic> with that realization, i'm gonna head to bed
02:35:19 <aperiodic> thanks again for the help, dankna and augustss 
02:36:13 <dankna> np
02:37:26 <frank00> dcoutts_ : silly me I downloaded GTK /runtime/ (facepalms)
02:41:30 <mun> hi
02:41:34 <mun> can HOL be considered as a metalogic?
02:44:33 <Jonno_FTW> when will the next haskell platform be out?
02:46:22 <vegai> Jonno_FTW: the current schedule is early march
02:46:31 <Jonno_FTW> how early?
02:46:35 <Jonno_FTW> this weekend early?
02:47:00 * hackagebot clash 0.1.2.4 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.2.4 (ChristiaanBaaij)
02:57:15 <taotree> If I have: newtype Time = Time Word64 deriving (Eq, Ord, Num)   to make this an Integral, would you use a deriving instance declaration?
02:57:34 <quicksilver> just put Integral inside those () next to NUm
02:58:25 <taotree> ah, need Real in there, too
02:58:31 <taotree> and Enum
02:58:47 <taotree> so this works: newtype Time = Time Word64 deriving (Eq, Ord, Num, Enum, Real, Integral)
02:58:48 <taotree> thanks
03:03:05 <frank00> argh, dcoutts_ : one more small thing <- I've succesfully installed gtk and modified PATH (trid gtkdemo and it works), unfortunately, when I try "cabal install glib-0.12.0" in the middle of the process it throws a ""cpp" is not rcognised a an internal or external command". What is cpp, and hw do I install it?
03:04:15 <dcoutts_> hmm, that's probably c2hs calling cpp
03:04:30 <dcoutts_> cpp should be on your %PATH%, it comes with mingw
03:05:04 <frank00> I willp ut in PATH the mingw\bin folder
03:05:21 <frank00> (which is currently in code blocks)
03:12:30 <hpaste> MigMit pasted "Levels problem"  http://hpaste.org/44391
03:14:03 <vigosun> Hi! I am new to haskell and trying to understand this expression. Can someone give details what's going on here:
03:14:06 <vigosun> take 10 $ fix ((1:) . (2:) . drop 2 . concat . flip (zipWith replicate) [1..])
03:14:57 <Entroacceptor> someone made that just to annoy you
03:15:00 <frank00> :P quite a monster vigosun 
03:15:24 <dankna> @unpl take 10 $ fix ((1:) . (2:) . drop 2 . concat . flip (zipWith replicate) [1..])
03:15:25 <lambdabot> (take 10 (fix (\ j -> 1 : (2 : (drop 2 (concat (zipWith replicate j [1 ..])))))))
03:16:19 <dankna> vigosun: this is homework, yes? :)
03:16:37 <vigosun> nop just trying to learn a bit of haskell
03:16:47 <taotree> Is there something like an IntMap but that isn't limited to the size of an Int?
03:17:08 <dankna> not that I'd be unwilling to help if it were, but I don't think deciphering this expression is a good place to start with the language if you don't /have/ to.
03:17:36 <dankna> taotree: I don't believe so, but see the unordered-containers package perhaps?
03:18:17 <Maxdamantus> @src flip
03:18:18 <lambdabot> flip f x y = f y x
03:18:33 * Maxdamantus wonders how to write flip in point-free style.
03:18:47 <vigosun> danka: Well I learnt the basics up to chapter 6 on http://learnyouahaskell.com
03:18:50 <dankna> @pl flip
03:18:50 <lambdabot> flip
03:19:04 <taotree> dankna, thanks
03:19:04 <Maxdamantus> (from S, K)
03:19:14 <dankna> taotree: sure, hope it helps
03:20:10 <dankna> vigosun: this expression you have shown - and I'm very curious where it came from? - is kinda a puzzle-box, deliberately constructed to be hard to understand.  I see no educational value to deciphering it, not for a beginner.
03:21:14 <aristid> @pl flip a b = fmap ($ b) a
03:21:14 <lambdabot> flip = fix (flip . (fmap .) . ($ id))
03:21:27 <vigosun> dankna: I found it on the irc log. Not long time ago when I was trying to find to solition to  Golomb's sequence
03:21:34 <dankna> ahhh okay
03:21:46 <aristid> @pl flip' a b = fmap ($ b) a
03:21:46 <lambdabot> flip' = flip (fmap . flip id)
03:22:11 <taotree> dankna, that doesn't look helpful. The size function returns an Int, which wouldn't work if there were more than Int entries in it. So... I think I'll have to go to Map, or somehow restrict the number of items
03:22:21 <dankna> taotree: oh - yeah, hmmm.
03:22:22 <aristid> :t curry (const id)
03:22:23 <lambdabot> forall a a1 b. a1 -> b -> a -> a
03:23:00 <taotree> hmm... Map has same problem... this is odd
03:23:05 <aristid> :t (snd *** fst)
03:23:05 <lambdabot> forall a c a1 b. ((a, c), (a1, b)) -> (c, a1)
03:23:34 <aristid> :t uncurry id . (snd &&& fst)
03:23:35 <lambdabot> forall c a. (a, a -> c) -> c
03:23:51 <taotree> Int might be big enough. I didn't realize it was 2^29. That's pretty big
03:23:54 <aristid> :t fmap (uncurry id . (snd &&& fst)) . curry
03:23:55 <lambdabot>     Couldn't match expected type `(a, a -> c)'
03:23:55 <lambdabot>            against inferred type `b -> c1'
03:23:55 <lambdabot>     Probable cause: `curry' is applied to too few arguments
03:24:42 <aristid> :t curry
03:24:42 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
03:24:53 <aristid> :t curry (uncurry id . (snd &&& fst))
03:24:54 <lambdabot> forall c a. a -> (a -> c) -> c
03:25:06 <aristid> maxJadi: i think i got a point-free flip without flip :)
03:25:18 <aristid> oh wait, that's flip ($)
03:25:31 <taotree> erg, oops, 2 not 10^29th. oh well... I'll search for a BigMap :)
03:25:37 <aristid> also i meant Maxdamantus
03:50:39 * hackagebot hmpfr 0.3.2 - Haskell binding to the MPFR library  http://hackage.haskell.org/package/hmpfr-0.3.2 (MichalKonecny)
03:53:12 <frank00> dcoutts_ : after a long long compile, the linker threw me a " C:\Programs\Haskell Platform\2010.2.0.0\lib\extralibs\regex-posix-0.94.2\ghc-612.3/libHSregex-posix-0.94.2.a(Wrap.o):fake (.text+0x44a1): undefined reference to `regexec' "
03:54:31 <frank00> which left me puzzled
03:55:09 <dcoutts_> hmm, wonder if the mingw C libs are getting in the way
03:57:26 <frank00> by the way, all this is to play LambaHack (so I can understand the code underneath)
03:58:01 <dcoutts_> frank00: if possible, I'd suggest using the pre-built gtk2hs installer
04:00:31 <frank00> dcoutts_ do you know where tog get it?
04:00:46 <dcoutts_> http://sourceforge.net/projects/gtk2hs/files
04:00:56 <frank00> http://haskell.org/gtk2hs/ <- not f_ ok
04:02:43 <dcoutts_> frank00: but note that older installers also need older ghc version
04:03:14 <frank00> I'll grab the last one
04:04:05 <vigosun> Please suggest how to trace value of j in the following: (take 6 (fix (\j -> 1 : (concat (zipWith replicate j [1 ..])))))
04:09:05 <dcoutts_> vigosun: List.iterate
04:12:52 <revenantphx> Skipping school. Reading Category Theory by Awodey.
04:12:59 <revenantphx> I'm the worst vagrant in the history of school.
04:13:06 <revenantphx> ahem, truant
04:13:13 <revenantphx> (no wonder I have a B in english)
04:14:10 <frank00> dcoutts_ ouch i will have to download 6.10 then :( I will do that after eating, thanks for all the pointers, even though I didn't manage t get a working version of LambdaHack (someone should make binaries for that!) I still learned a lot. Thanks again
04:14:49 <vigosun> dcoutss_: Did I understand right? ...zipWith replicate List.iterate(j) [1 ..]... - doesn't work
04:14:51 <kosmikus> frank00: what's the problem with LambdaHack?
04:16:02 <frank00> I cannot compile it kosmikus (and I don't find a binary either :P). GTK problems I sp'ose. Last the linker comlained "undefined reference to `regexec'"
04:16:11 <frank00> I would like to play it so to understand the code
04:16:32 <kosmikus> and you're on Windows?
04:17:35 <tromp_> @pl \k->[k,2*k+1]
04:17:36 <lambdabot> ap (:) (return . (1 +) . (2 *))
04:18:08 <frank00> kosmikus: yes (will switch to arch in one month, and hopefully get less compile headaches)
04:18:26 <hymnusalae> Excuse me, while -> is already an instance of Arrow, and Arrow is a class instance of Category, why still need to define -> as an instance of Category? What's it for?
04:18:40 <kosmikus> frank00: LambdaHack has three frontends (vty, hscurses, gtk2hs). I'm afraid the gtk one is the only one that runs on Windows, though.
04:19:29 <frank00> kosmikus: no worries, the more I fail the more I learn, but maybe for naive users like me you should have a .exe ready (given the gtk runtime installed)
04:19:36 <quicksilver> hymnusalae: there is no such thing as a "class instance".
04:19:41 <kosmikus> frank00: so if you don't get gtk2hs running, then you're probably out of luck while on Windows.
04:19:43 <tromp_> @hoogle [a] -> [a] -> [a]
04:19:43 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
04:19:43 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
04:19:43 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
04:20:08 <hymnusalae> quicksilver, sorry, i dunno how to express it
04:20:16 <kosmikus> frank00: I try to avoid Windows as much as possible (and don't have any running install of it), so it's not easy for me to produce binaries ...
04:20:20 <quicksilver> hymnusalae: Category is a superclass of Arrow, but this does not stop you having to write the category instance.
04:20:21 <frank00> kosmikus: what are you running as an OS?
04:20:34 <kosmikus> frank00: Linux (NixOS)
04:20:40 <quicksilver> hymnusalae: it says "every Arrow must also be a Category" but the programmer still has to write the implementaiton.
04:20:49 <revenantphx> hymnusalae: Category being a superclass of Arrow just means you have to implement all of the functions for 
04:20:49 <revenantphx> c
04:20:53 <revenantphx> Category as WELL as Arrow.
04:21:23 <hymnusalae> quicksilver, revenantphx, I misunderstood the superclass. Thank you very much.
04:21:24 <frank00> kosmikus: I ask because once upon a time I ran FreeBSD and compliling there was a breeze (really, hardly ever any problem). I hope to get a similar deal with Arch.
04:21:49 <kosmikus> I've been using Arch for a while, it's fine.
04:21:53 <jonkri> what's the ^D character you sometimes get when you paste in ghci in emacs?
04:23:02 <revenantphx> ^D = control-D = EOF
04:23:24 <revenantphx> (= logout on many shells)
04:25:17 <jonkri> thanks revenantphx 
04:25:55 <jonkri> i was chasing a bug for hours before i detected that little character in xemacs, i got the proper paste when pasting into terminal > ghci :)
04:26:55 <frank00> pizza time, see you in a bit
04:29:28 <illissius`> hmm... what am I doing wrong here? http://codepad.org/kKACeHSL
04:29:44 <illissius`> I get the same error whether or not I add ScopedTypeVariables
04:30:18 <illissius`> I get an error locally as well, with 6.12.1, not sure what codepad uses, in that case it's "Could not deduce (Bounded a1) from the context ()"
04:31:24 <illissius`> (and yeah, I know that example would work if I just remove the type annotations, I'm trying to figure out why ScopedTypeVariables isn't having the desired effect in a larger less trivial example -- presumably I'm doing something really dumb)
04:32:43 <Saizan> illissius`: you're forgetting the forall a.
04:33:23 <illissius`> Saizan: yeah, there's nothing like asking on IRC to make you immediately realize your error
04:33:28 <illissius`> as I did right after I had finished typing :-)
04:34:22 <Saizan> yeah, thinking is just a bad approximation of talking to yourself :)
04:34:32 <hpc> :D
04:35:52 * hackagebot svg2q 0.3.2 - Code generation tool for Quartz code from a SVG.  http://hackage.haskell.org/package/svg2q-0.3.2 (JanGreve)
04:38:02 <illissius`> it's uncanny how this always happens though -- troubleshoot fruitlessly for hours, give up, ask on IRC, and immediately the answer springs forth, as if intentionally to embarrass you
04:38:27 <illissius`> I wonder if there've been any srs psychological inquiries into the cause of this
04:39:36 <DevHC> there has been
04:39:52 <DevHC> when u generally explain something to someone else, u see it though in a different way
04:40:17 <Boxo> Some people explain their problems to a rubber duck
04:41:50 <Saizan> i think it might even be a neurological matter, getting information as an external input might simply trigger different cognitive processes
04:43:19 <quicksilver> I suspect it's more to do with being forced to put it into words for consumption by another human being forces you to lay out the problem more carefully
04:44:49 <DevHC> maybe
04:45:07 <jacobian> Those two explanations sound compatible to me
04:45:15 <tab> quicksilver: it doesn't have to be another human, it can be a teddy bear actually ;)
04:45:46 <tab> (aka the Bell lab teddy bear)
04:46:16 <illissius`> hmm
04:47:02 <illissius`> so apparently just asking the question, even if you know the whole thing is silly and don't expect an answer, is enough to trigger it?
04:48:34 <tab> illissius`: apparently
04:48:41 <tab> illissius`: i wonder if you have to believe in it or not ..
04:48:50 <illissius`> yeah, that's what I was wondering too
04:52:03 <illissius`> whether it's like God, who knows when you're trying to manipulate Him intentionally and stops doing whatever it was He was previously doing in response to that same thought/action, or if it really is something more weird and primitive
04:52:33 <confound> it doesn't even seem very weird to me. what quicksilver said makes sense and isn't weird or primitive
04:53:14 <Philippa> yeah. Having to lay it out for someone/thing who doesn't have the same knowledge and intuitions as you is what matters
04:53:42 <illissius`> maybe
04:53:53 <DevHC> of course this is us just being a bunch of smartasses in trying to guess the actual reason
04:53:55 <Philippa> it makes you face the fact that your usual way of thinking about something's full of handwaves that you personally know approximately how to interpret
04:53:57 <illissius`> guess i'll have to self-observe/experiment more to be semi-certain :)
04:54:27 <confound> as far as the teddy bear thing goes, people practice saying things in front of a mirror all the time :)
04:55:03 <illissius`> I don't
04:55:06 <illissius`> feels super awkward
04:55:58 <aristid> illissius`: how about trying a dishwasher or something else?
04:56:03 <illissius`> asking yourself something on IRC (or in a text editor at that point...) isn't as bad, but still weird
04:56:15 <illissius`> anyway, I'll have to try it
04:56:29 <DevHC> try /query lambdabot :]
04:56:31 <lunaris> Hi all; despite what http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html#th-quasiquotation says, it seems you can't use user-defined quasiquoters in types. Is this correct?
04:56:41 <illissius`> aristid: thankfully I don't have to practice saying things much :)
04:57:21 <aristid> illissius`: last time i had to do a presentation, my clothes drier learned a lot about the topic :D
04:58:38 <illissius`> heh
04:58:39 <flippo> illissius`, if you ask the question by email, then you never have to send it
04:58:41 <illissius`> oh yeah
04:58:53 <illissius`> thesis-defending in summertime, at latest :d
04:59:06 <illissius`> guess I'll have to acquire a dishwasher or clothes dryer before then
04:59:09 <aavogt> lunaris: no you can here http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH-Quote.html
04:59:22 <int-e> flippo: in theory, you don't have to press the enter key on IRC either :)
04:59:41 <aavogt> earlier versions didn't have quoteDec and quoteType
05:00:24 <lunaris> aavogt: Of the docs or the code? The docs have it, but the code doesn't.
05:00:32 <DevHC> how recent is the syntax of ":: forall a. InsertClassHere a => a"? because my version of ghc[i] gives a parse error
05:00:34 <lunaris> I figured it's just a case of the docs being wrong.
05:00:42 <aavogt> lunaris: you're using ghc-7.0.1?
05:00:49 <lunaris> aavogt: 6.12 atm I think.
05:01:02 <lunaris> Yep.
05:01:03 <lunaris> 6.12.3
05:01:04 <int-e> flippo: of course, even with e-mail, at least in my experience, it happens that you press Send, and then, pressure suddenly relieved, one realises what the problem is.
05:01:11 <aavogt> lunaris: the docs are wrong because you are looking at the wrong docs
05:01:38 <confound> Correct action proceeds from correct docs.
05:02:02 <lunaris> God I'm a moron.
05:02:03 <aavogt> http://www.haskell.org/ghc/docs/6.12.3/html/users_guide/template-haskell.html#th-quasiquotation
05:02:07 <lunaris> aavogt: Got it.
05:02:10 <lunaris> Still a moron though.
05:02:32 * lunaris hangs head in shame and waits to be clouded by the shadows.
05:03:50 <flippo> int-e, email often seems to benefit from a little rest before sending.
05:05:21 <xplat> DevHC: you need a language extension like ExplicitForalls enabled
05:05:42 <aavogt> you can :set -XExp...  or other extensions there (tab-complete)
05:07:12 <DevHC> ghc --supported-languages | grep -i forall
05:07:15 <DevHC> nothing
05:07:33 <DevHC> ghc --version
05:07:33 <DevHC> The Glorious Glasgow Haskell Compilation System, version 6.10.4
05:08:17 <xplat> well, some other good ones to try are ScopedTypeVariables and RankNTypes
05:08:41 <aavogt> or -fglasgow-exts until you look through the manual
05:08:48 <xplat> at least one of those should work ...
05:08:58 <aristid> DevHC: 6.10 is pretty old :)
05:09:09 <DevHC> lol
05:09:53 <aristid> there are two major releases since then: 6.12 and 7.0
05:10:07 <DevHC> "major"
05:10:37 <xplat> 6.12 is now 'stable stable' and 7.0 is 'leading but not quite bleeding edge'
05:11:00 <aristid> and 6.10 is "very old version"
05:11:10 <xplat> another couple of point releases and everyone serious will be on 7
05:11:46 <Saizan> 7.0.2 will be in the HP
05:12:31 <xplat> yeah, 7.0.2/HP2011 will start the mass migration, 7.0.3 will collect most of the stragglers
05:13:15 <xplat> most likely, anyway
05:14:45 <aristid> well, it also depends on what ubuntu et al put in the package systems
05:14:51 <manizzle> hm, there is some similiar syntax between haskell and erlang
05:17:58 <manizzle> what sort of networking does haskell have:
05:18:04 <shlevy> Does anyone know if the CONTRACT pragma in GHC actually does anything yet, or is it just a recognized then ignored pragma? I'm looking at using the tool described in http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-737.pdf
05:18:11 <DevHC> apparently the freebsd d00ds r not "serious" about ghc
05:18:32 <xplat> aristid: i agree if there weren't too many problems with distro packages to make them suitable for serious use (even setting versions aside)
05:19:05 <Philonous1> DevHC: There is a 6.12 package, it's just not in the ports
05:19:15 <DevHC> :O
05:19:26 <DevHC> how the fuck r the ports not up to date
05:19:41 <Zao> DevHC: Because you curse too much, and use 'r'.
05:19:49 <DevHC> lol
05:20:00 <Philonous1> DevHC: Ports are a pita, quite frankly, that's why I changed to arch. 
05:20:04 <DevHC> Zao learn to use capitalized, full sentences
05:20:09 <DevHC> learned*
05:20:31 <Zao> DevHC: Did you perhaps mean 'learnt'?
05:20:38 <DevHC> no
05:20:39 * Zao is, however, learned
05:21:03 * shlevy compiles his system from scratch
05:21:04 <McManiaC> lol
05:21:13 <xplat> there is a god who punishes bad english by delaying ports?  i guess that would explain some things ...
05:21:25 <Zao> Philonous1: Yeah, I much prefer having a poorly maintained and often broken package repository (AUR).
05:21:57 <DevHC> Philonous1: why r the ports a pita?
05:24:01 <xplat> oh god this is becoming a distro flamewar.  this is #haskell, given the all around ghc situation, can't we all just agree to hate all distros equally?  ;)
05:24:23 <hpc> xplat: we should make a distro!
05:24:28 <Philonous1> Zao: Wow, I didn't mean to start a flame war about this. All I can say is that arch packages worked quite well for me until this point, whereas ports where a major hassle to keep updated, not only because it took more than a day to recompile them, but also they regularly just broke. 
05:24:36 <hpc> it's only fair that the whole world can hate us too :P
05:24:36 <shlevy> hpc: Written all in Haskell
05:24:53 <shlevy> hpc: who's up for rewriting the kernel?
05:25:05 <hpc> shlevy: then it wouldn't be a distro :P
05:25:07 <Zao> Philonous1: Just poking fun at you for recommending something that tends to be as broken as ports :)
05:25:16 <hpc> a distro is kernel + stuff
05:25:23 <shlevy> hpc: sure it would, just not a Linux distro :D
05:25:32 <hpc> we would use cabal as the package manager
05:25:35 <shlevy> Windows 7 is an NT distro
05:25:36 <hpc> or something like that
05:25:41 <Zao> Did the Arch Haskell users solve how haskell package versioning was all horrible and broken?
05:26:24 <hpc> xmonad for the wm/de
05:26:39 <ceii> Zao: most arch users solve it by not using arch packages for haskell I think
05:26:47 <Zao> Last I read about it on the lists, it was rather impossible to get the right set of packages installed to build anything, as the AUR didn't really do side-by-side versions.
05:26:50 <mun_> hi
05:26:53 <ceii> just get a recent GHC and cabal-install from the repos
05:27:02 <Zao> ceii: I thought that was one of the big selling points of using Arch for Haskell.
05:27:03 <ceii> and get the rest with cabal-install
05:27:09 <mun_> would one say that HOL is a weaker or stronger logic than FOL?
05:27:10 <Zao> I guess it was abandoned.
05:27:38 <xplat> hpc: we can call it NIHOS ... short for New Integrated Haskell Operating System!
05:27:44 <ceii> Zao: the effort still exists, in that almost all of hackage is packages for arch
05:27:48 <dolio> xplat: The official haskell distro is source mage. Everyone knows that.
05:27:59 <ceii> Zao: but I never understood how that was supposed to be useful
05:28:16 <ceii> packaged*
05:28:21 <DevHC> Philonous1: u moved to arch and started using arch PACKAGES, because u hated freebsd PORTS? what about freebsd PACKAGES?
05:29:10 <Philonous1> DevHC: They are utterly outdated. 
05:29:13 <xplat> mun_: HOL is not just one logic, but any meaningful HOL is stronger than FOL.  until you add axioms, anyway
05:29:42 * shlevy is learning about Source Mage and thinks its origins lie in some geeks who wanted to use magic metaphors in their everyday
05:29:53 <Zao> I hear that the optimal way to run Haskell is on bare metal under Xen :)
05:29:56 <o^_^o> What was the definition monad in term of monoids ?
05:30:22 <Saizan> monoid object in the category of endofunctors
05:30:35 <hpc> what was the category one?
05:30:46 <hpc> er, morphism one?
05:30:52 <shlevy> Zao: I've actually been contemplating a Haskell -> EFI Bytecode compiler
05:31:05 <Saizan> @quote 2-category
05:31:05 <lambdabot> dolio says: Monad are just monads in the 2-category of categories.
05:31:20 <mun_> xplat, right. so a logic can be embedded in one that's stronger than it, right?
05:31:28 <Saizan> i miss the morphism one..
05:32:01 <Zao> http://halvm.org/wiki/ , for anyone thinking I joked :)
05:32:47 <xplat> mun_: for the right definition of embedded.  a 'stronger' logic means your axioms have more implications, and/or your theories have fewer models ...
05:33:42 <DevHC> reading the description for the ghc port
05:33:45 <xplat> @quote moarphism
05:33:45 <lambdabot> tensorpudding says: lolcategory demands moarphisms
05:34:03 <DevHC> "GHC is a state-of-the-art programming suite for Haskell". ORLY!
05:34:23 <DevHC> "GHC comes with a generational garbage collector". omfg that's so fucking awesome!
05:35:00 <shlevy> DevHC: That's good information for anyone who needs to read the description before deciding to install it
05:35:02 <xplat> it probably was fucking awesome back in 1999 when somebody wrote that description
05:35:28 <DevHC> yeah pretty much
05:35:35 <Zao> xplat: It's been discussed a lot on -cafe, I believe.
05:35:39 <Zao> Lots of bikesheds.
05:35:52 <DevHC> i agree that it is good for marketing and stuff, but otherwise it's not "epic"
05:37:52 <xplat> if you just wait long enough nostalgia will set in and generational garbage collectors will sound all retro-cool
05:38:22 <DevHC> does "The current language version is Haskell 98, agreed in December 1998, with a revised version published in January 2003." in the description imply that 6.10 came before that published revision in 2010?
05:38:29 <manizzle> which HP has ghc 7?
05:38:47 <shlevy> Anyone have any good resources for learning about the Haskell runtime? Right now it's just some magical floaty thing that makes stuff work in my head
05:39:16 <xplat> DevHC: given how much people keep descriptions current, no, but it's true anyway
05:39:38 <fryguybob> manizzle: HP with GHC 7 isn't out yet.
05:39:56 <manizzle> so ghc 6.12 is alright?
05:40:48 <xplat> 6.12.3 is preferred unless you need something that requires 7
05:41:16 <xplat> 6.12.1 can be used but its ghc-pkg is buggy so i wouldn't recommend it
05:44:28 <confound> hey, thanks, that explains why I had problems with ghc-pkg
05:45:48 <xplat> that's not the only reason you might have problems (distro packages integrating badly with ghc-pkg is another) but it does make problems more common and harder to deal with
05:46:52 <confound> it was a utf8-related bug with something I'd installed via cabal, iirc
05:47:47 <xplat> that's not the problem that usually gets people, but it's probably been fixed too
05:48:00 <confound> I meant with the metadata
05:48:11 <confound> it was pretty easy to google for so I suppose it's bitten a few people.
05:48:21 <shlevy> The description on this page makes Haskell seem like its almost a compiled interpreted language http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts
05:48:31 <confound> (ghc-pkg blew up every time someone's name had an ö in it)
05:48:31 <xplat> (the problem that usually gets people is 6.12.1 can get mixed up between a global and local package with the same version)
05:48:37 <confound> oh
05:52:10 <int-e> McManiaC: for what it's worth, I could build ghc head successfully on amd64/linux, using ghc 7.0.1 and gcc 4.4.5. Another thing that occurred to me: are the dph subrepository and the ghc one in sync? (i.e., did you use ./darcs-all pull to update or get a fresh tree?)
05:53:44 <xplat> the Commentary on STM seems very informative >_>
05:54:11 <zygoloid> shlevy: well, haskell's execution model isn't often very much like that of the machine it's running on (unless you have a Reduceron), so it's natural that compiled code reads a bit like the output of the first futamura projection
05:54:36 <shlevy> I don't get that reference
05:54:54 <hpc> shlevy: "futamura" not "futurama"
05:55:08 <xplat> first futamura projection == partly evaluate an interpreter to get compiled code
05:55:14 <xplat> *partially
05:55:31 <zygoloid> it's like taking bytecode and replacing each op with the interpreter code which implements it
05:55:31 <confound> bite my shiny metal projection
05:56:18 <shlevy> hpc: Heh. Definitely misread that
05:56:28 * hpc does that all the time
05:56:34 * zygoloid does that on purpose
05:56:35 <xplat> shlevy: don't worry, everybody does
05:57:17 <shlevy> Has anyone ever tried writing a compiler that doesn't require an independent runtime?
05:57:26 * xplat imagines futamura shaking a fist at the sky and yelling "GROENING!!!!!!!!"
05:57:57 <saml> so i was thinking that all pure functions should be executed during compilation type
05:58:01 <Botje> shlevy: is glibc an acceptable runtime?
05:58:01 <saml> then we have dependant type
05:58:07 <xplat> shlevy: even a C compiler needs a runtime these days, to do the usual things
05:58:58 <shlevy> Botje: On a workstation, sure. On an embedded device, not so much
05:59:36 <hpc> shlevy: how embedded? haskell runs on iphones now
05:59:48 <xplat> admittedly more of the C runtime is written in C than the haskell one is in haskell, but some of your libc is still in assembly
05:59:50 <zygoloid> shlevy: does a statically-linked runtime count?
06:00:25 <shlevy> hpc: think custom-engineered implanted biomedical devices
06:00:52 <shlevy> Is the RTS comparable to glibc?
06:01:03 <Saizan> shlevy: nhc98 specifically targets embedded systems, iirc
06:01:06 <shlevy> zygoloid: Depends on how bloated the resultant executable is
06:01:29 <zygoloid> not really. glibc has an interface layer for the kernel, whereas the RTS (iiuc) uses libc for that
06:02:11 <zygoloid> shlevy: ok, so you want something like the minimal subset of the RTS which your program actually uses?
06:02:16 <Philippa> xplat: I'm just waiting to see them actually do an episode about the Projections
06:02:24 <xplat> haskell's runtime falls somewhere between C++ and java in weight, closer to the C++ size (especially if you strip out the GHCI stuff)
06:02:30 <shlevy> zygoloid: Yeah, basically
06:03:04 <shlevy> zygoloid: preferably in a non-generalizde form. I don't need my executable to have code that could theoretically run any compiled haskell program, just that one
06:05:23 <jonkri> how do you recommend me to debug a function in a library that i'm using? i would like to insert breakpoints. i'm using emacs/ghc
06:05:27 <xplat> (GHC's runtime has most of the stuff Java's (minimal) one does, and a few things it doesn't, but getting to leave out the JIT is a big advantage)
06:07:38 <mapreduce> > do x <- [3,4,5]; return 2 * x
06:07:39 <lambdabot>   No instance for (GHC.Num.Num [b])
06:07:39 <lambdabot>    arising from a use of `e_13452' at <in...
06:07:44 <mapreduce> What's that about?
06:08:08 <bd_> > do x <- [3,4,5]; return $ 2 * x
06:08:09 <lambdabot>   [6,8,10]
06:08:15 <bd_> !undo do x <- [3,4,5]; return $ 2 * x
06:08:25 <bd_> .undo do x <- [3,4,5]; return $ 2 * x
06:08:33 <bd_> ... how did lambdabot's commands work again? >_>
06:08:39 <ion> @
06:08:40 <fryguybob> @undo do x <- [3,4,5]; return $ 2 * x
06:08:41 <lambdabot> [3, 4, 5] >>= \ x -> return $ 2 * x
06:08:45 <bd_> ah yes
06:08:50 <bd_> @undo do x <- [3,4,5]; return 2 * x
06:08:50 <lambdabot> [3, 4, 5] >>= \ x -> return 2 * x
06:08:56 <ion> @pl . undo do x <- [3,4,5]; return $ 2 * x
06:08:56 <lambdabot> (line 1, column 1):
06:08:56 <lambdabot> unexpected "."
06:08:57 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
06:09:00 <ion> @. pl undo do x <- [3,4,5]; return $ 2 * x
06:09:01 <lambdabot> [6, 8, 10]
06:09:07 <ion> d’oh
06:09:11 <bd_> well, that doesn't clear anything up much, but basically, you end up with (return 2) * x, I think
06:09:15 <ion> @. pl undo do x <- xs; return $ 2 * x
06:09:16 <lambdabot> (2 *) `fmap` xs
06:09:22 <bd_> @. pl undo do x <- [3,4,5]; return 2 * x
06:09:23 <lambdabot> (return 2 *) =<< [3, 4, 5]
06:09:47 <ion> That’s (return 2) * x
06:10:01 <mapreduce> Oh, I see.  Thank you.
06:10:33 <ion> return . (2*) =<< [3,4,5]  i think. Or simply the fmap version.
06:13:29 <augur> byorgey: i think i have an idea for a blog post thanks to you! :o
06:18:04 <manizzle> guys, how do i get haskell-mode installed?
06:18:56 <stianhj> manizzle, in what?
06:19:04 <manizzle> emacs
06:19:23 <stianhj> i meant what OS.. in ubuntu you can do sudo apt-get install haskell-mode
06:19:35 <manizzle> archlinux
06:19:41 <stianhj> else just install it like you install any other emacs package
06:21:13 <Ke> other distros have package managers too =oP
06:22:24 <stianhj> manizzle, archlinux has a emacs-haskell-mode package
06:22:42 <manizzle> stianhj, yeah i installed it. dont know how to load it into emacs
06:24:23 <Saizan> manizzle: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
06:30:11 <revenantphx> so, is there any way to do something like this?
06:30:12 <revenantphx> https://gist.github.com/847423
06:30:33 <revenantphx> Or is that jut crossing the type/data constructor boundary in a way that can't be done?
06:32:07 <Saizan> you want SHE
06:32:50 <revenantphx> ...SHE?
06:33:38 <fryguybob> @where she
06:33:39 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
06:33:40 <Saizan> http://personal.cis.strath.ac.uk/~conor/pub/she/ 
06:34:57 <revenantphx> ...what is it 0.
06:35:00 <revenantphx> o.o*
06:35:48 <revenantphx> I'd prefer to keep it to straight haskell, sadly.
06:35:52 <revenantphx> or rather, straight + extensions
06:35:55 <revenantphx> (this isn't for me)
06:36:22 <wagle> xplat: thanks!
06:37:34 <Silex> SHE thinks you're not so straight, after all you don't want HER :)
06:37:41 <Saizan> then you've to do the transformation yourself
06:37:55 <revenantphx> I have a girlfriend, I'm not cheating on her for SHE.
06:38:09 <revenantphx> anyways, what transformation?
06:38:22 <revenantphx> I was thinking of just using more GADT's to add more restrictiveness to the type >_>
06:39:46 <Saizan> https://gist.github.com/847437#comments
06:40:03 <revenantphx> well yeah...
06:40:09 <revenantphx> I was just hoping there was a cleaner way to do it >_>
06:40:15 <revenantphx> Guess not... oh well
06:40:41 <medfly> I didn't expect it to be so extrmee, but I really miss most of what is on Haskell.
06:40:43 <Saizan> haskell doesn't have dependent types, it's just quite good at faking them :)
06:40:53 * medfly has to use matlab right now
06:41:02 <medfly> </vent>
06:41:25 <revenantphx> Oh I didn't know you could have empty, parameterized type constructors
06:41:27 <revenantphx> :|
06:41:30 <revenantphx> data Operator a b
06:41:33 <revenantphx> that's new.
06:42:02 <quicksilver> don't think it's any newer than empty data types.
06:42:08 <revenantphx> I just never noticed XD.
06:42:13 <revenantphx> So, what would dependent types entail?
06:42:33 <revenantphx> (I get the basic idea, just wondering why haskell couldn't have them)
06:42:37 <revenantphx> (some low level shenanigans?)
06:43:09 <Philippa> revenantphx: doing a good job would entail a subtle but complete redesign
06:43:24 <revenantphx> ...Haskell 2012 :D?
06:43:35 <Philippa> a mediocre job'd merely have turing complete compilation
06:43:40 <revenantphx> Hm.
06:43:45 <revenantphx> Do you think it'd ever happen?
06:43:52 <Saizan> type inference and typeclass instance resolution are the most likely to suffer
06:43:52 <revenantphx> It certainly is a useful feature.
06:43:57 <Philippa> oh, and not be any good at optimising compared to a good dependently-typed language
06:43:58 <jonkri> when i try to add a break point according to ghci's :h output (:break [<mod>] <l> [<col>]) with ":break Main 55" or ":break 55" i get "no breakpoints found at that location. anyone knows what's up with that?
06:44:20 <Philippa> revenantphx: nope. It's a job for another, newer language
06:44:27 <jonkri> when i try ":break add Main 2" as found on the wiki it just says that "add" is not in scope
06:44:33 <revenantphx> Philippa: Go write it :D.
06:44:43 <Philippa> Saizan: yeah, especially as type classes really want to look somewhat different in a dependently-typed language anyway
06:45:13 <Philippa> no point in me starting, there's already Agda exploring approximately the chunk of design space I'd aim at
06:45:17 <Philippa> well, Agda and Idris
06:45:41 <quicksilver> GHC will take some baby steps with datakinds
06:45:48 <quicksilver> and it will be interesting to see where that leads.
06:46:04 <Philippa> approximately into Haskell's version of C++ :p
06:46:05 <revenantphx> Agda really seems experimental though.
06:46:06 <Philippa> but yeah
06:46:08 <quicksilver> it's surprisingly hard to guess how this stuff works out without trying it.
06:46:10 <Saizan> Philippa: more different than being able to be parameterized by values too?
06:46:11 <revenantphx> Not very useful for actually doing anything.
06:46:48 <Saizan> you can even use gtk2hs from agda
06:46:53 <revenantphx> Saizan: https://gist.github.com/847450 looks fine :\
06:46:57 <wagle> revenantphx: how so?  (curious)
06:47:10 <Philippa> Saizan: yeah, you start to find yourself with questions about what you want the type-to-instance mapping for anyway, and what range of proof mechanisms are really useful. Typeclasses're just a particular hard-wired tactic plus a fundep from type tuple to instance
06:47:12 <dcoutts> Saizan: cool :-) didn't know that
06:47:21 <revenantphx> wagle: I'm just making a frivolous umbrella statement based on a couple hours of experience. Disregard me >_>.
06:47:54 <wagle> revenantphx: ah..  no worries, you have more experience than i so far
06:48:02 <revenantphx> Barely.
06:48:06 <revenantphx> I couldn't write a single program.
06:48:13 <Philippa> revenantphx: you want to learn the agda way of doing things. Ultimately, the haskell way extended to agda's level of power is likely to turn into approximately the class of mess that C++ is compared to C
06:48:20 <xplat> Philippa: heh, quite true.  it is a very useful tactic, though, within its limits.
06:48:31 <revenantphx> Philippa: I should learn some agda at some point >_>
06:49:00 <Philippa> so should I :p
06:49:12 <tawe> There's any difference in how it's evaluated: filter (<10) [1..], and takeWhile (<10) [1..] ?
06:49:13 <Philippa> (but I know enough to know why I hold that opinion)
06:49:27 <revenantphx> So, now I have another question >_>
06:49:35 <revenantphx> So I have this now right?
06:49:36 <revenantphx> https://gist.github.com/847450
06:49:37 <xplat> the fundep is the real issue, though
06:49:46 <revenantphx> How could I have a function (I'm sure this goes into fundeps)...
06:49:59 <Saizan> it's a bit annoying that reflection is not nearly enough for typeclasses, you also need some kind of global registry
06:50:06 <revenantphx> that resolves to a 2-ary function for binary operators, a double for a Val, etc
06:50:06 <Philippa> xplat: more or less, yeah. And if you remove it, you have a whole new can of worms re datatypes and things-that-are-currently-instances
06:50:13 <revenantphx> in other words, an arbitrary fundep :|
06:50:27 <Saizan> revenantphx: type families?
06:50:33 <revenantphx> Saizan: excuse me?
06:50:55 <revenantphx> Basically I want evaluation of an Expr Operator ... to result in a function (of varying arity)
06:51:10 <revenantphx> Expr Paren ... should not be defined (or cause errors)
06:51:17 <revenantphx> and Expr Double produces a Double >_>
06:51:25 <revenantphx> (this is for after the infix is resolved into RPN)
06:51:59 <Saizan> revenantphx: with {-# LANGUAGE TypeFamilies #-} you can write type family Type a :: *; type instance Type Double = Double; type instance (Operator Binary a) = Double -> Double -> Double ...
06:52:26 <xplat> Philippa: scala's implicits-as-typeclasses do a surprisingly good job handling the can of worms, but i'm not sure it's quite good enough
06:52:28 <revenantphx> Haskell extensions... are like little bundles of joy, aren't they >_>.
06:52:32 <Saizan> then you'd have eval :: Expr t -> Type t
06:52:42 <Saizan> of course, you could also use a class with a fundep
06:52:49 <revenantphx> Saizan: looks fun, I'll try it heh.
06:53:07 <revenantphx> Oh god the haskellwiki page is huge.
06:53:37 <jonkri> i had to add a space between ":" and "break" for some reason. however, i'm getting an error saying "GHC.List is not interpreted". is it not possible to debug my code while using binaries?
06:53:55 <Philippa> xplat: do you at least get eg ordered trees that stick to the same ordering?
06:54:11 <Philippa> (and know which that is when you want to paste bits of them together?)
06:54:26 <Saizan> jonkri: compiled code can't be traced
06:54:58 <Philippa> (if you /don't/ get that in the type system, fundamentally it's broken and in a big enough system it /will/ cause problems - haskell gets it for free of course)
06:55:00 <jonkri> Saizan: i don't want to trace it, i want to trace the code that is in the current module
06:55:31 <xplat> Philippa: in practice you do because when you accept an implicit argument it appears in your scope and gets passed to your callees, the problem is it's still easy to break it on purpose
06:55:40 <taotree> Is there some way to keep type information around at runtime? I don't need to do dynamic typing. I just need to know the type of a function at runtime. I could create my own datastructure, but that would be redundant (at least at compile time)
06:55:53 <Saizan> jonkri: well, i'd expect you can't even place a breakpoint inside it
06:56:20 <roconnor> taotree: not really.  Half the point of types is that they are erased
06:56:23 <xplat> Philippa: and although the discipline is easy to follow it's hard to see if it could get baked into the type system or not
06:56:35 <roconnor> taotree: of course Typable does what you want
06:57:00 <roconnor> taotree: or at least Typable does what you are asking.
06:57:01 <jonkri> Saizan: hmm... so what can i do, then? do i need to get all the source files for all the libraries that i'm using in order to debug a function in my module?
06:57:18 <Philippa> xplat: yeah. So a sufficiently 'freeform' polymorphic system can fuck it up sooner or later
06:57:19 <roconnor> taotree: I doubt you really want what you are asking for ;)
06:57:21 <taotree> roconnor, right, but... if there was some way to say at compile time: go put the type of that function over in this variable over here.
06:57:41 <roconnor> taotree: variables don't hold types.
06:57:42 <Philippa> (you need Tree Int < to be a different type to Tree Int >, ultimately)
06:57:45 <revenantphx> wait.
06:57:52 <revenantphx> Saizan this may come off as silly but
06:57:58 <Saizan> jonkri: i've never used the ghci debugger, i tend to just test small enough portions of my code in isolation
06:58:01 <revenantphx> How would I pattern match my GADT "Val"
06:58:04 <taotree> roconnor, yes, I mean a description of the type
06:58:10 <revenantphx> of type Expr (Double)
06:58:15 <revenantphx> how can I get the double out >_>
06:58:15 <roconnor> taotree: you can do that with Typable I'm told
06:58:58 <Saizan> revenantphx: well, your Expr does look a bit silly, you'd normally put a Double inside it
06:59:05 <revenantphx> Yeah, I just noticed that now.
06:59:06 <revenantphx> heh.
06:59:14 <revenantphx> should be Double -> Expr (Double)
06:59:22 <Saizan> and the operators would have Expr fields
06:59:23 <revenantphx> there we go
06:59:32 <revenantphx> No, I'm not using them to form an AST.
06:59:42 <revenantphx> This is an extension of my homework >_>.
06:59:52 <revenantphx> We had to do an infix calculator, and hpc mentioned shunting-yard
06:59:59 <revenantphx> so I'm doing something similar in haskell for fun.
07:00:07 <revenantphx> And I wanted to see just how much shit I could cram into the types :D
07:00:16 <Saizan> i see
07:00:22 <jonkri> Saizan: what debugger do you use?
07:00:38 <Saizan> jonkri: no debugger
07:01:10 <Saizan> though you could also limit yourself to putting breakpoints into your own code
07:01:29 <revenantphx> Saizan: Type families and GADTs... yeah... really looks like it's faking dependent typing.
07:01:32 <revenantphx> XD.
07:01:46 <jonkri> Saizan: that's what i want to do, but even when i put a breakpoint in my main function i get that error complaining about GHC.List
07:03:10 <revenantphx> The type families basically providing a mapping from input to output types for the eval function. interesting :|
07:03:14 <Saizan> the error seems to say otherwise, so maybe there's some miscommunication between you and ghci? anyhow i don't have any working knowledge of it, just tried it once when it came out
07:03:43 <revenantphx> I think shunting yard could be represented as a fold.
07:04:56 <revenantphx> ...stupid numbers
07:12:50 <revenantphx> what
07:12:51 <revenantphx> https://gist.github.com/847490
07:12:56 <revenantphx> this type error is confusing me >_<
07:13:07 <revenantphx> that should be fine for the fold.
07:13:33 <Saizan> you should put the error there too
07:13:37 <revenantphx> It is.
07:13:48 <revenantphx> It's as a comment, but it's there.
07:14:23 <Saizan> i guess i clicked too soon on the link
07:14:31 <revenantphx> w/e
07:14:44 <revenantphx> anyways, it's probably something silly, but I'm not sure why isn't complaining.
07:14:49 <Saizan> ?type foldl1
07:14:50 <revenantphx> :t foldl
07:14:51 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:14:51 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:15:00 <Saizan> foldl1 /= foldl
07:15:00 <revenantphx> oh shit
07:15:01 <revenantphx> foldl1
07:15:02 <revenantphx> fff
07:15:08 <revenantphx> told you ^_^
07:15:23 <revenantphx> I'm blind apparently.
07:17:02 <wagle> we created ##categorytheory last night, by the way..  fyi
07:17:07 <revenantphx> heh
07:17:12 <revenantphx> so what's the deal with ## vs #?
07:17:21 <Philippa> # is for organisations, roughly speaking
07:17:38 <wagle> ## is allegedly for topics (the thinking at the time)
07:17:52 <Philippa> there's some grandfathered stuff and there're pseudo-organisations sprung up purely for namespace purposes, but nevertheless
07:17:53 <Zao> # is supposed to be held by the official entity.
07:18:23 <Zao> Freenode has a tendency to be for FL/OSS projects, so the rules are bent in that direction.
07:20:13 <roconnor> dont' let Freenode know about #constructive-math :)
07:20:24 <copumpkin> onoes
07:20:30 <copumpkin> ##destructive-math
07:20:47 <roconnor> copumpkin: I think you mean ##paraconsistent-math
07:20:53 <copumpkin> oh ok
07:21:18 <Saizan> how many spin-off channels about math are we going to have?:)
07:22:08 <copumpkin> over 9000, I'd wager
07:22:37 * Saizan checks if irssi supports that many
07:22:38 <Philippa> Saizan: having a general maths channel often has unpleasant results unfortunately
07:22:58 <Saizan> Philippa: yeah, i've seen
07:22:58 <Philippa> especially if the first people to grab it aren't particularly... culturally enlightened, the way #haskell tends towards
07:22:58 <copumpkin> yeah, attracting mathematicians has its downsides
07:23:16 <Saizan> #thy-olde-haskell
07:23:37 <Ke> if it would be maths, people would mostly show up for help in solving high school homework
07:23:42 <Ke> "#maths"
07:24:10 <roconnor> Saizan: how many spin-off channels about programming are there?
07:25:14 <Saizan> roconnor: from #haskell? i'm aware only of ones about specific programs/libs
07:33:21 <sm> morning gwern.. we're discussing Monadius in #haskell-game and I saw you did a bunch of work on it - maybe you could join us briefly ?
07:34:09 * sm thinks gwern should be in that channel anyway
07:51:53 <byorgey> @tell augur excellent, a blog post about what?
07:51:53 <lambdabot> Consider it noted.
07:56:42 <hymnusalae> Excuse me, the example of foldl's strictness analysis in HaskellWiki/Performance/Strictness confused me. While fac has "if n<=1" which always need n's value, what does lgo have to make z strict?
07:56:46 <hymnusalae> Thank you very much.
07:57:23 <hymnusalae> For wiki address: http://www.haskell.org/haskellwiki/Performance/Strictness
07:58:50 <revenantphx> Hm.
07:59:31 <rwbarton> hymnusalae: lgo isn't strict in z, by itself.
08:00:23 <hymnusalae> rwbarton, You mean together with f?
08:01:30 <hymnusalae> and in that example f = (+), which need the value of z from last recursion. Seems I got it wrong.
08:01:39 <rwbarton> hymnusalae: but when used in the context "foldl (+) 0 [1..1000000]", GHC knows that f = (+) is strict, and therefore it can prove that z will be needed to compute f z x
08:01:42 <revenantphx> hm, so this won't be so simple after all
08:02:02 <Saizan> when foldl (+) is inlined a version of lgo specialized to (+) is generated, in that case the strictness of (+) implies the one of lgo
08:03:09 <revenantphx> Saizan: So, with this reduced example, https://gist.github.com/847574, I need to have a parse function from [Char] -> [Expr a]
08:03:19 <hymnusalae> rwbarton, Saizan, thank you. Strictness of (+)?
08:03:26 <revenantphx> however, the produced stack of expressions has to be heterogenous.
08:03:38 <revenantphx> (I can't do [Add, Mul, Lpr]
08:03:39 <revenantphx> )
08:03:50 <rwbarton> GHC knows (+) is strict on Integer because it is a builtin
08:03:52 <revenantphx> I had this issue before, I recall it involved existentials >_>.
08:03:53 <hymnusalae> I see. Thank you.
08:04:01 <hymnusalae> rwbarton, Thanks a lot.
08:04:57 <revenantphx> Is there an easy(ish) way to work with a list of Expr, where they can be any of the listed values?
08:05:22 <roconnor> @ask dcoutts terminfo's cabal package comes with a configure file.  How do I run cabal install to tell it to pass a flag (specifically --with-curses-libraries) to ./configure?
08:05:22 <lambdabot> Consider it noted.
08:05:27 <revenantphx> lemme repaste slightly modified
08:05:44 <dcoutts> roconnor: there's a flag for it, see --help
08:05:44 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
08:06:04 <dcoutts> roconnor: but better would be to eliminate the configure script! :-)
08:06:36 <roconnor> oh?
08:06:44 <roconnor> I don't know anything about terminfo and curses
08:06:59 <Saizan> revenantphx: yeah, you've to wrap Expr in an existential, or figure out another list-like type specific to your needs (maybe the types of the Expr's are predictably related?)
08:07:15 <revenantphx> Saizan: How would I wrap it in an existential?
08:07:25 <revenantphx> I'm looking for minimal complication, but ease of use is always preferable.
08:07:47 <roconnor> dcoutts: --configure-option=OPT  Thanks.  I didn't see it the first pass through the help.
08:07:48 <Saizan> revenantphx: data SomeExpr where SomeExpr :: Expr a -> SomeExpr
08:08:20 <Saizan> then [Char] -> [SomeExpr] should be possible
08:08:41 <revenantphx> That always seemed a bit annoying.
08:08:43 <revenantphx> Anyways, thanks.
08:09:25 <revenantphx> so is that equivalent to data SomeExpr = forall a. Expr a
08:11:18 <paolino> hello, I'm having a problem with dependencies http://hpaste.org/44396/cabal_recursive. Can someone explain what is wrong in my module database ?
08:11:19 <quicksilver> Saizan: I quite like "data AnyExpr where SomeExpr :: Expr a -> AnyExpr" as an idiomatic way to name constructor/type.
08:11:48 <jho> Seeing how [0.1, 0.2 .. 10] stumbles to precision errors, is there a faster way of doing what it should do other than typing all of the elements by hand?
08:12:47 <revenantphx> quicksilver: that looks nice.
08:12:58 <Saizan> quicksilver++
08:13:24 <sipa> jho: is map (*0.1) [1..10] better maybe>
08:13:30 <sipa> > map (*0.1) [1..10]
08:13:31 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4,0.5,0.6000000000000001,0.7000000000000001,...
08:13:44 <sipa> > [0.1 .. 10]
08:13:45 <lambdabot>   [0.1,1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1]
08:13:55 <sipa> > [0.1, 0.2 .. 10]
08:13:57 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600000...
08:14:06 <rwbarton> > [0.1, 0.2 .. 10] :: [Rational]
08:14:07 <lambdabot>   [1 % 10,1 % 5,3 % 10,2 % 5,1 % 2,3 % 5,7 % 10,4 % 5,9 % 10,1 % 1,11 % 10,6 ...
08:14:19 <jho> Kind of answering my own question, but map (/10) [1 .. 100] seems to work
08:14:31 <jho> Thanks anyways :p
08:14:46 <rwbarton> I'm a little surprised the difference between [0.1, 0.2 .. 10] and map (/10) [1 .. 100] matters
08:15:13 <sipa> 0.1 isn't representable exactly
08:15:35 <paolino> what is the meaning of those hashes attached to the package names? dependency tree ?
08:15:37 <sipa> so if the increment isn't representable, i suppose you can get an accumulating error
08:15:38 <monochrom> don't allow a lot of 0.1s to accumulate.
08:15:40 <rwbarton> well sure, they won't be exactly equal, but they should be close enough for most purposes
08:15:57 <Saizan> paolino: it's the hash of the abi
08:16:18 <rwbarton> we're talking 100 0.1s, and Double has 53 bits of mantissa
08:16:26 <Saizan> paolino: compiling the same package won't always give you the same abi
08:16:27 <rwbarton> > last [0.1, 0.2 .. 10]
08:16:28 <lambdabot>   10.000000000000053
08:16:42 <rwbarton> that's pretty close to 10 IMO
08:16:46 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml explains the hashes
08:16:57 <jho> rwbarton: True, but it looks quite ugly if you print it
08:17:06 <rwbarton> that is true
08:17:16 <theorbtwo> I wonder if it'd actually break anything to change the definition of .. slightly to fix that problem.
08:17:22 <sipa> > (0.1 * 100)
08:17:23 <lambdabot>   10.0
08:17:38 <theorbtwo> That is, make it give "10" when the computed value is >= 10.
08:17:53 <djahandarie> > 0.1 + 0.1 + 0.1 + 0.1
08:17:53 <lambdabot>   0.4
08:17:58 <paolino> Saizan, depending on the choosen version of dependencies ?
08:18:10 <djahandarie> > [0.1 .. 0.4]
08:18:10 <lambdabot>   [0.1]
08:18:16 <djahandarie> > [0.1, 0.2 .. 0.4]
08:18:17 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4000000000000001]
08:18:26 <quicksilver> > [1,6 .. 23]
08:18:26 <revenantphx> I really never use guards.
08:18:27 <lambdabot>   [1,6,11,16,21]
08:18:28 <revenantphx> huh.
08:18:39 <quicksilver> ^^ theorbtwo expression is not supposed to include 23.
08:18:48 <Saizan> paolino: and optimization level and other things too i suspect, but i'm not sure
08:18:50 <quicksilver> your heuristic would have to avoid correcting that 21 to 23.
08:18:56 <quicksilver> basically .. tries to do a bit too much.
08:19:00 <Saizan> paolino: see monochrom's link btw
08:19:33 <djahandarie> > last [0.00001, 0.00002, 1]
08:19:34 <lambdabot>   1.0
08:19:34 <rwbarton> ideally [1, 6 .. 23] should be an error, IMO
08:19:40 <theorbtwo> quicksilver: Yes, thus calling it a change.  The question is if anybody uses ranges like that on purpose.
08:20:02 <quicksilver> Personally I'd be quite content to permit ranges only for integral types.
08:20:05 <byorgey> rwbarton: yuck, why?  it would have to be a runtime error, you know.
08:20:11 <Gracenotes> @botsnap
08:20:12 <lambdabot> :)
08:20:19 <quicksilver> discrete enumerables like [Monday..Friday] too, perhaps.
08:20:30 <rwbarton> because if you wrote that literally in a program, you've definitely made an error
08:20:49 <quicksilver> rwbarton: but what if you'd written [1,6 .. maxx]
08:20:49 <theorbtwo> You could take the middle ground and make it a pragma, or just write a function that does the same thing and loose the convient syntax.
08:20:57 <quicksilver> where maxx is only knowable at runtime.
08:21:11 <rwbarton> quicksilver: (all still IMO) You shouldn't write that; instead you should write what you meant
08:21:18 <rwbarton> takeWhile (<= maxx) [1, 6..] or whatever
08:21:48 <rwbarton> doesn't the semantics of [1,6 .. maxx] depend totally on whether it's at type [Integer] or [Double] for example
08:22:02 <quicksilver> rwbarton: I understand that. I don't understand how you plan to forbid it?
08:22:02 <augur> yo peeps
08:22:02 <lambdabot> augur: You have 1 new message. '/msg lambdabot @messages' to read it.
08:22:13 <quicksilver> rwbarton: what aspect of [1,6 .. maxx] do you consider illegla?
08:22:14 <rwbarton> quicksilver: Neither do I, that's why I wrote "ideally"
08:22:20 <quicksilver> ah, ok ;)_
08:22:27 <rwbarton> :)
08:22:28 <augur> byorgey: a subclass of the enumerating-lambda-terms problem
08:22:42 <byorgey> augur: cool
08:23:37 <augur> byorgey: basically, where you eliminate all the terms of the form \... -> M, where M contains only applications and variables bound by the whole expression
08:23:48 <paolino> monochrom: thanks
08:23:51 <rwbarton> quicksilver: it might be feasible to disallow the [a, b .. c] syntax unless the compiler can prove that c is actually in the sequence [a, b ..]
08:23:53 <augur> and where we consider \x y -> M ~ \y x -> M
08:24:04 <rwbarton> which would basically mean a, b, c must be constants
08:24:40 <revenantphx> Why I love Haskell: https://gist.github.com/847617
08:24:51 <rwbarton> Anyways, the only real reason I want this is so that people stop having silly discussion about what things like [1, 6 .. 23] "should" mean :P
08:24:55 <revenantphx> So much prettier than my java version >.>
08:25:02 <rwbarton> so I don't really care that much about it
08:25:09 <revenantphx> > [1, 6 .. 23]
08:25:10 <lambdabot>   [1,6,11,16,21]
08:25:17 <revenantphx> ...right.
08:25:19 <revenantphx> okay then.
08:25:47 <revenantphx> As far as I see, the c in [a, b..c] is just a suggestion.
08:25:53 <revenantphx> Or at least, an ending point.
08:26:07 <revenantphx> It's not guaranteed to be in the series, but nothing greater than it should be either.
08:26:17 <paolino> can I unregister HTTP and CGI from global ?
08:26:22 <augur> byorgey: which is i guess another way of saying all the linear applications possible build from some set of typed lambda terms
08:26:56 <maiqkl> Is this a good place to ask newb questions are is there a better channel?
08:26:56 <revenantphx> @hoogle Char -> Double
08:26:57 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:26:57 <lambdabot> Prelude error :: [Char] -> a
08:26:57 <lambdabot> Prelude read :: Read a => String -> a
08:27:02 <maiqkl> or*
08:27:08 <byorgey> maiqkl: this is the right place!
08:27:14 <maiqkl> Thank you!
08:28:17 <monochrom> ghc-pkg --global --no-user-package-conf unregister CGI
08:28:40 <monochrom> that's right, for some reason --global is not enough
08:28:57 <revenantphx> gogo derplexer
08:29:29 <byorgey> maiqkl: so do you have some questions?
08:30:02 <paolino> monochrome: is it a way to eliminate problems or else ?
08:30:13 <djahandarie> revenantphx, will you be going to hacphi? :)
08:30:13 <maiqkl> It's quite a simple one, what is the best way to define long strings that will spread across multiple lines. My aim is to create a function where you give it a term eg "ghc" and outpops the definition.
08:30:28 <monochrom> I don't know. looks like a bug.
08:30:31 <revenantphx> djahandarie: what?
08:30:48 <monochrom> actually I don't know what is your "this".
08:30:49 <byorgey> maiqkl: if you put \ as the last character on a line you can continue the string on the next line
08:30:52 <paolino> I mean unregistering globals
08:31:10 <maiqkl> "So this\
08:31:13 <djahandarie> revenantphx, http://www.haskell.org/haskellwiki/Hac_φ
08:31:18 <revenantphx> Interesting.
08:31:21 <maiqkl> I think I have got it!
08:31:24 <revenantphx> That's during my Spring Break!
08:31:25 <djahandarie> I can't find the mailing list post for the one this year
08:31:26 <revenantphx> so maybe :).
08:31:26 <byorgey> maiqkl: yup!
08:31:28 <maiqkl> Thank you.
08:31:39 <byorgey> revenantphx: that page is old, this year's will be July 29-31
08:31:40 <revenantphx> My parents probably wouldn't like the idea though.
08:31:42 <revenantphx> Oh.
08:31:49 <byorgey> I really ought to update that page
08:31:55 <revenantphx> heh, I'll be out of the country then probably ^_^
08:32:08 <djahandarie> Where are you going?
08:32:08 <revenantphx> Either out of the country, or Massachusetts (same thing really)
08:32:19 <revenantphx> I go to Greece every other summer.
08:32:26 <revenantphx> To visit step-family.
08:32:33 <djahandarie> If you're in Boston then you can go to Boston Haskell instead ;)
08:32:41 <revenantphx> I will be right outside Boston :P
08:32:44 <revenantphx> well, 2 hours
08:32:51 <monochrom> alright, I don't know what you mean. unregistering a package may add or reduce problems depending on context.
08:32:55 <djahandarie> It's at MIT to be specific
08:32:59 <revenantphx> Oh, huh.
08:33:05 <augur> byorgey: i think its a good problem to investigation, because then we can ask questions like, how can we add on top of that the some simple constraints
08:33:10 <revenantphx> I could tell my parents "I'm interested in going to look at the campus"
08:33:19 <djahandarie> I don't know when the next one is though
08:33:20 <revenantphx> and then be like "oh look a haskell thing"
08:33:35 <revenantphx> There's no Pittsburgh Haskell thing is there :\?
08:33:56 <revenantphx> Someone should arrange something at CMU.
08:33:57 <djahandarie> A user group? I don't think so, but I don't live in PA. :P Ask byorgey
08:34:03 <augur> like say, if x : b, g : a -> b, x' : a, and f : b -> b -> c, we get f x (g x') and f (g x') x as terms, and we might add some constraint that pushes applications as far down as possible
08:34:15 <augur> so that we filter-in f (g x') x but filter-out f x (g x')
08:34:43 <aristid> is there a list of upcoming hackathons?
08:34:48 <revenantphx> I looked up Portland and there was something back in 2009... they had Hot Lips Pizza >_>
08:34:51 <revenantphx> brings back memories.
08:34:57 <revenantphx> And Taco Del Mar hehe.
08:35:04 <djahandarie> aristid, all day, every day, everywhere
08:35:14 <revenantphx> I went through too many of their Buy 10 Get 1 Free cards :3
08:35:27 <aristid> djahandarie: thank you for this incredibly helpful answer
08:35:38 <djahandarie> :P
08:35:55 <revenantphx> I really do want to move back to Portland >_>. 
08:36:01 <revenantphx> A lot more fun than Pittsburgh.
08:36:09 <revenantphx> (also, Portland > Seattle)
08:36:19 <augur> which is i suppose a way of saying we want to keep the terms that can be described maximally tacitly -- \{x,x',f,g} -> f (g x') x ~ \f g -> f . g, but \{x,x',f,g} -> f x (g x') ~ \f g -> flip f . g
08:36:46 <augur> or at least its one kind of maximally tacit
08:37:00 <augur> byorgey: does that make some amount of sense?
08:37:17 <xplat> revenantphx: Pittsburgh isn't that bad, as long as you're sure to live there from 1990 to 1992
08:37:24 <revenantphx> >_>
08:37:27 <xplat> after 1993 it starts to suck :P
08:37:27 <aristid> djahandarie: haskell.org only mentions 3rd Summerschool on Applied Functional Programming" in upcoming events
08:37:28 <revenantphx> Thanks, that's helpful.
08:37:52 <djahandarie> Bah, $400 dollars for a ticket to PA.
08:38:03 <djahandarie> I don't have this sort of money!
08:38:11 <revenantphx> You know, you guys ought to be proud to be in the top 10 freenode channels, and still manage to never degrade in terms of conversation.
08:38:20 <revenantphx> Even when this channel goes off-topic, it's always still interesting :P.
08:38:21 <djahandarie> I think we are pretty degraded right now
08:38:24 <djahandarie> lol
08:38:47 <revenantphx> anyways, Portland > Seattle, never forget.
08:39:01 <Veinor> xplat: brb buying time machine
08:39:28 <augur> Veinor: why buy when you can steal!
08:39:36 <aristid> revenantphx: i wonder which percentage of people on the #haskell user list actually ever say anything
08:39:41 <augur> theres an old unused one around here somewhere
08:39:44 <shachaf> djahandarie: A ticket from where?
08:39:46 <revenantphx> aristid: that's a good point.
08:39:49 <augur> you could steal that one
08:39:56 <djahandarie> shachaf, Connecticut
08:40:09 <revenantphx> aristid: It wouldn't be hard to have a bot observe for a couple days and rank people by activity.
08:40:13 <djahandarie> BDL to PHL
08:40:22 <aristid> i want to know if there's upcoming stuff in yurop
08:40:30 <augur> Veinor: it can shape shift, too. blend into its surroundings
08:40:42 <augur> does all sorts of shapes! ionic column, police box, ...
08:41:11 <aristid> revenantphx: you just got a nice haskell project!
08:41:18 <revenantphx> aristid: I'm writing a calculator >_
08:41:19 <revenantphx> >_>*
08:41:25 <aristid> revenantphx: you don't even need your own bot. just download the logfiles
08:41:30 <revenantphx> :|
08:41:31 <revenantphx> touche.
08:41:35 <siracusa> Is there a better way of storing the output of a handle in a String than writing a temp file and reading it afterwards?
08:41:39 <revenantphx> data crunching heh.
08:41:45 <monochrom> just use a regex
08:41:57 <revenantphx> I want... to write this calculator.
08:42:09 <revenantphx> see, I finished the lexer: https://gist.github.com/847617
08:42:09 <revenantphx> >_>
08:42:44 <revenantphx> feck. I forgot precedence.
08:42:58 <revenantphx> can GADT's derive?
08:43:06 <revenantphx> derive Ord, etc
08:43:15 <monochrom> I heard no.
08:43:24 <Saizan> in some cases yes
08:43:27 <aristid> revenantphx: a lexer does not need to know about precedence
08:43:33 <revenantphx> aristid: No but the parser will >_>
08:43:44 <revenantphx> parser will remangle the tokens into RPN order.
08:43:50 <revenantphx> (shunting yard)
08:43:58 <aristid> sounds overly complicated
08:44:00 <revenantphx> I'm trying to prove to my teacher that Haskell is prettier than Java.
08:44:04 <revenantphx> (for the identical task)
08:44:04 <monochrom> be a pervert and use no precedence. force user to add parentheses.
08:44:12 <aristid> why not just build an ADT instead of a stream of RPN tokens?
08:44:20 <revenantphx> aristid: Because I'm making it analogous.
08:44:25 <revenantphx> Besides, that'd be too easy ;D
08:44:36 <monochrom> because the ADT is fused away
08:44:42 <aristid> revenantphx: it would make the haskell code shorter, more readable, and more impressive :)
08:44:49 <revenantphx> aristid: I'll do that afterwards >_>
08:44:52 <revenantphx> I really want to see this work.
08:45:11 <paolino> derive Typeable works
08:45:14 <aristid> ok. should not be very hard if you use parsec, either way :)
08:45:23 <aristid> but i guess you don't use parsec?
08:45:34 <revenantphx> Last time I tried to use Parsec with a calculator type syntax... whee recursion
08:45:36 <monochrom> but actually, in many cases, using the exact same algorithm makes haskell look worse not better.
08:45:39 <revenantphx> and for this no, since each token is one character.
08:45:43 <revenantphx> monochrom: Oh I'm sure.
08:45:53 <revenantphx> But there's no way it can look worse than the Java... trust me >_>
08:46:08 <revenantphx> besides, I thought about it, and the shunting yard algorithm could be expressed as a fold.
08:48:08 <Gracenotes> @botsnack
08:48:09 <lambdabot> :)
08:48:17 <aristid> the HDBC interface seems pretty ugly
08:49:12 <aristid> :t StateT
08:49:13 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
08:49:14 <monochrom> I don't know whether your teacher can be reasoned with or not. Take that into account, i.e., if a person can't be reasoned with, don't bother demonstrating anything, in fact don't bother speaking at all.
08:49:22 <djahandarie> monochrom, lol
08:49:31 <djahandarie> revenantphx, I think LYAH does shunting yard
08:49:38 <djahandarie> Or something does, I don't remember
08:49:45 <revenantphx> djahandarie: It does an RPN calculator
08:49:47 <revenantphx> but that's boring >_>
08:49:48 <aristid> monochrom: i think if he learns something by writing the haskell code, all effort was not wasted ;)
08:50:03 <djahandarie> Maybe it was SICP that did it
08:50:12 <revenantphx> I think aristid's got the idea more. It's fun for learning, heh.
08:50:18 <revenantphx> I'll rewrite it to use a proper AST afterwards.
08:50:49 <revenantphx> Besides, I need more practice solving problems functionally.
08:51:10 <aristid> HSQL seems to have a slightly better interface than HDBC
08:51:23 <aristid> Takusen is scary because Oleg is involved :D
08:51:57 <djahandarie> Here is an attoparsec version of a calculator http://stackoverflow.com/questions/4559399/can-parser-combinators-be-made-efficient/4560629#4560629
08:53:05 <revenantphx> djahandarie: I'll look through that.
08:53:37 <djahandarie> I had to write a strict chainl1 inline though since attoparsec doesn't have one
08:53:50 <xplat> revenantphx: you might be interested in the GADT paper from a while back that built an applicative-style -> stack-machine translator where the types proved the equivalence of the forms
08:54:00 <revenantphx> ...what?
08:54:00 <revenantphx> XD
08:54:04 <revenantphx> jargon overload, I'm sorry.
08:54:34 <djahandarie> I had to hinjink the combabulator with the monkeywrench zapziper
08:54:57 <Saizan> xplat: in haskell?
08:55:07 <MHD0> Anyone here familiar with HOpenGL?
08:55:11 <quicksilver> djahandarie: careful, The Thermal Recalibration Lens cannae take anymore!
08:58:23 <tawe> Does WinHugs have a command similar to the one used here in the haskell bot, to show the implementation of a prelude function?
08:58:32 <xplat> er, my mistake, it was actually in Coq :-7
08:58:39 <monochrom> no, winhugs doesn't
08:58:54 <djahandarie> xplat, they're basically the same anyways. ... ;)
08:58:56 <xplat> some of the techniques might still be useful though
08:59:18 <xplat> http://adam.chlipala.net/cpdt/html/StackMachine.html
08:59:22 <tawe> monochorm, thanks
08:59:49 <djahandarie> I haven't tried learning Coq yet
08:59:51 <Saizan> i think in haskell you might at best prove that the types match, and that you don't run out of stack
09:00:06 <xplat> and i've seen some blog posts about typing Forth words
09:00:46 <ClaudiusMaximus> MHD0: i've used it a little; but maybe ask your real question first :)
09:01:43 <xplat> i think to get the most out of the type system in Haskell you'd want to have a cons that carries a phantom stack type with the list and makes sure it's consistent with the new latest op
09:01:50 <MHD0> ClaudiusMaximus: Why does ModelView take an argument?
09:02:03 <MHD0> Modelview*
09:03:21 <monochrom> use foldl' for Lebesgue integrals over domains with discrete measures and compact supports.
09:03:37 <monochrom> (that is, "sum")
09:03:52 <monochrom> ("finite sum" actually)
09:04:00 <quicksilver> MHD0: I don't know, but you always use "Modelview 0"
09:04:11 <ClaudiusMaximus> MHD0: looking at the documentation, it seems there can be more than one modelview matrix stack
09:04:29 <MHD0> That's what I thought.
09:04:37 <MHD0> So I can use one for HUD rendering?
09:04:52 <MHD0> Without disrupting the one for scene rendering?
09:05:36 <tawe> :?
09:05:44 <tawe> :t lines
09:05:45 <lambdabot> String -> [String]
09:06:06 <quicksilver> MHD0: no. Always use (ModelView 0)
09:06:12 <quicksilver> although feel free to change it for the HUD
09:06:19 <quicksilver> (and change it back for the scene)
09:06:24 <ClaudiusMaximus> preservingMatrix might be useful
09:06:41 <MHD0> I was just wondering
09:07:01 <MHD0> And yes, I use perservingmatrix and loadIdentities all over the place
09:07:54 <MHD0> ClaudiusMaximus, quicksilver: Then, next question, can lookAt be used for "after the face" camera placement?
09:08:04 <MHD0> "after the fact"
09:11:10 <ClaudiusMaximus> MHD0: no clue - my use of hopengl has mostly been non-standard (visualizing 4d shapes, zooming 2d quad-trees, ..)
09:17:02 <MHD0> ClaudiusMaximus: Ok, thanks.
09:18:22 <HugoDaniel> heya
09:19:08 <stepkut`> heya!
09:20:11 <HugoDaniel> i cant compile cabal-install from darcs it asks me for Cabal >=1.10.1 && <1.11
09:20:26 <HugoDaniel> and cabal from darcs is 1.11 and cabal from hackage is 1.10.0
09:20:45 <HugoDaniel> was 1.10.1 really released ?
09:26:33 <completehaskelln> why is haskell awesome?
09:26:51 <hpc> completehaskelln: because we said so? :P
09:27:25 <completehaskelln> what?
09:28:21 <hpc> completehaskelln: for me, it's the combination of immutable values, lazy evaluation, and strong static typing
09:28:32 <hpc> it's like math, the programming language
09:29:33 <hpc> completehaskelln: once you know what you are doing, you can do crazy things in the language that wouldn't be nearly as elegant anywhere else
09:29:44 <hpc> completehaskelln: for example, http://98.169.17.243:8000/blog/view.cgi?id=5
09:29:52 <hpc> (sorry for not having a domain name atm)
09:31:51 <hpc> (still there?)
09:32:10 <completehaskelln> do you have lamda?
09:32:53 <hpc> yes
09:33:04 <hpc> > (\x -> x + x) 5
09:33:05 <lambdabot>   10
09:33:13 <aristid> hpc: get a domain name, man!
09:33:32 <hpc> aristid: i know! it's currently on my craptop at home, and i don't have a static ip :/
09:33:52 <hpc> i might persuade my boss into letting me install the haskell platform on our devel server
09:34:03 <revenantphx> :t (<$)
09:34:04 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
09:34:24 <hpc> 5 <$ [1..]
09:34:24 <revenantphx> :t ($>)
09:34:25 <lambdabot> Not in scope: `$>'
09:34:31 <hpc> > 5 <$ [1..]
09:34:32 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
09:35:09 <revenantphx> > Just 10 <$ Nothing
09:35:10 <lambdabot>   Nothing
09:35:16 <manizzle> hpc, that would be much win
09:35:17 <revenantphx> > Nothing <$ Just 10
09:35:18 <lambdabot>   Just Nothing
09:35:25 <revenantphx> oh shit.
09:35:27 <revenantphx> XD
09:35:58 <revenantphx> > 9 <$ Just 10
09:35:59 <lambdabot>   Just 9
09:36:06 <revenantphx> So it discards whatever's "inside" the functor and replaces it with what's on the left?
09:36:07 <revenantphx> 0.o
09:36:08 <revenantphx> ?
09:36:42 <hpc> revenantphx: indeed
09:36:43 <burp> :t (<$)
09:36:44 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
09:37:04 <hpc> i think that's the free function for that type, in fact
09:37:32 <sproingie> that's a weird function
09:38:34 <aristid> :t ($>)
09:38:34 <lambdabot> Not in scope: `$>'
09:38:48 <hpc> aristid: flip (<$) i would assume
09:38:55 <MHD0> wouldn't (<$) just be equivalent to const . pure ? (or return in stead of pure)
09:39:07 <aristid> hpc: yeah
09:39:07 <hpc> :t const . pure
09:39:08 <lambdabot> forall b a (f :: * -> *). (Applicative f) => a -> b -> f a
09:39:11 <aristid> :t flip ($>)
09:39:12 <lambdabot> Not in scope: `$>'
09:39:21 <aristid> :t flip (<$)
09:39:22 <lambdabot> forall a (f :: * -> *) b. (Functor f) => f b -> a -> f a
09:39:24 <hpc> @src (<$)
09:39:24 <lambdabot> (<$) = (<$>) . const
09:39:50 <aristid> hpc: pretty trivial, ain't it?
09:40:08 <hpc> it's cool
09:41:39 <revenantphx> @src flip
09:41:39 <lambdabot> flip f x y = f y x
09:41:41 <revenantphx> derp
09:41:46 <hpc> lol
09:41:58 <hpc> bonus point: the source for cale-flip
09:42:02 <hpc> :t flip
09:42:03 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:42:11 <revenantphx> hpc: what?
09:42:22 <hpc> :t \f x y -> f y z
09:42:23 <lambdabot> forall t t1 t2. (t1 -> Expr -> t2) -> t -> t1 -> t2
09:42:25 <hpc> :t \f x y -> f y x
09:42:26 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> t -> t1 -> t2
09:43:05 <hpc> hmm...
09:43:09 <hpc> :t fmap
09:43:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:43:30 <hpc> :t \f x -> fmap ($x) f
09:43:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
09:43:34 <hpc> aha!
09:43:58 <xplat> triple bonus points: a language where you can write caleflip as flip f x y = f y x
09:44:20 <hpc> xplat: ooh, i wish
09:47:10 <Brechreiz> @pl \xs \ys -> encode (zipWith (||) (decode xs) (decode ys))
09:47:11 <lambdabot> (line 1, column 5):
09:47:11 <lambdabot> unexpected "\\"
09:47:11 <lambdabot> expecting operator, pattern or "->"
09:47:24 <Brechreiz> @pl \xs \ys encode (zipWith (||) (decode xs) (decode ys))
09:47:25 <lambdabot> (line 1, column 5):
09:47:25 <lambdabot> unexpected "\\"
09:47:25 <lambdabot> expecting operator, pattern or "->"
09:48:25 <Brechreiz> @pl \xs ys -> encode (zipWith (||) (decode xs) (decode ys))
09:48:25 <lambdabot> (encode .) . (. decode) . zipWith (||) . decode
09:49:16 <Brechreiz> \f a b -> f (g a) (g b)
09:49:19 <Brechreiz> @pl \f a b -> f (g a) (g b)
09:49:20 <lambdabot> flip flip g . ((.) .) . (. g)
09:49:37 <Brechreiz> @pl a b -> (g a) (g b)
09:49:37 <lambdabot> (line 1, column 5):
09:49:37 <lambdabot> unexpected ">" or "-"
09:49:38 <lambdabot> expecting variable, "(", operator or end of input
09:49:41 <Brechreiz> @pl \a b -> (g a) (g b)
09:49:42 <lambdabot> (. g) . g
09:49:51 <hpc> @src on
09:49:51 <lambdabot> (*) `on` f = \x y -> f x * f y
09:50:13 <hpc> so yours == on ($)
09:53:38 <FUZxxl> Hi all! I still don't get applicative style. How to formulate parseLocSymDef =  digit >>= \d -> char 'H' >> return (localSymbolsH !! (ord d - 0x30)) in applicative style?
09:54:23 * hackagebot husk-scheme 2.2 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-2.2 (JustinEthier)
09:55:07 <Brechreiz> hpc: Can \f a b -> f (g a) (g b) be simplified further?
09:55:47 <FUZxxl> @hoogle on
09:55:48 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:55:48 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
09:55:48 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
09:56:22 <FUZxxl> @pl \f a b -> f (g a) (g b)
09:56:23 <lambdabot> flip flip g . ((.) .) . (. g)
09:57:03 <FUZxxl> Please help me.
09:57:15 <FUZxxl> @pl parseLocSymDef = digit >>= \d -> char 'H' >> return (localSymbolsH !! (ord d - 0x30))
09:57:16 <lambdabot> parseLocSymDef = (char 'H' >>) . return . (localSymbolsH !!) . subtract 48 . ord =<< digit
09:58:26 <FUZxxl> Is my term equivalent to parseLocSymDef = digit >>= \d -> (localSymbolsH !! (ord d - 0x30)) <$ char 'H'
09:58:43 <FUZxxl> @pldigit >>= \d -> (localSymbolsH !! (ord d - 0x30)) <$ char 'H'
09:58:44 <lambdabot> Unknown command, try @list
09:58:49 <FUZxxl> @pl digit >>= \d -> (localSymbolsH !! (ord d - 0x30)) <$ char 'H'
09:58:50 <lambdabot> (<$ char 'H') . (localSymbolsH !!) . subtract 48 . ord =<< digit
10:00:25 <byorgey> djahandarie: I live in Philadelphia, which is an 8 hour drive away from Pittsburgh.  I have no idea whether there is a Haskell user group there. =)
10:01:28 <byorgey> also, the Hac phi page is now updated
10:06:33 <xplat> encode . (zipWith (||) `on` decode)
10:10:47 <xplat> or (decode ~> decode ~> encode) . zipWith $ (||)
10:10:53 <xplat> if you have ~>
10:11:07 <hpc> what would (~>) be?
10:11:32 <Brechreiz> @pl (== True)
10:11:33 <lambdabot> (True ==)
10:12:26 <xplat> f ~> g = (g .) . (. f) -- infixr
10:12:40 <Brechreiz> @pl \temp -> length (fst temp) : encodE (snd temp)
10:12:41 <lambdabot> ap ((:) . length . fst) (encodE . snd)
10:12:43 <tawe> @src takeWhile
10:12:44 <lambdabot> takeWhile _ []                 =  []
10:12:44 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
10:12:44 <lambdabot>                    | otherwise =  []
10:12:52 <mauke> @unpl (g .) . (. f)
10:12:53 <hpc> :t \f g -> (g .) . (. f)
10:12:54 <lambdabot> (\ e j -> g (e (f j)))
10:12:54 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => f a -> (b1 -> b) -> (a -> b1) -> f b
10:13:02 <xplat> usually works better if it has lower precedence than . and higher than $
10:13:04 <hpc> oh cool
10:13:10 <tawe> @src filter
10:13:11 <lambdabot> filter _ []     = []
10:13:11 <lambdabot> filter p (x:xs)
10:13:11 <lambdabot>     | p x       = x : filter p xs
10:13:11 <lambdabot>     | otherwise = filter p xs
10:14:21 <byorgey> @type let argument = flip (.); result = (.) in \f g -> argument f . result g
10:14:22 <xplat> i think Control.Category would be the best place to put it, ideally
10:14:22 <lambdabot> forall (f :: * -> *) a b a1. (Functor f) => f a -> (a1 -> b) -> (a -> a1) -> f b
10:14:39 <xplat> and the best . to use in the definition
10:14:48 <byorgey> google for semantic editor combinators
10:14:49 <paolino> Ok, it's impossible to install hakyll. How can one simple man resolve things like 
10:14:51 <paolino> There are problems in package process-1.0.1.4:
10:14:53 <paolino>   dependency "filepath-1.2.0.0-50902b229d4e2a4a8bf52a4ce3239630" doesn't exist
10:15:04 <xplat> indeed, that's where i got it
10:15:17 <byorgey> xplat: right, I was telling hpc to google =)
10:15:21 <xplat> well, from Pointless Fun via SECs
10:16:15 <xplat> byorgey: yeah, i was just making clear i wasn't claiming authorship
10:16:49 <xplat> (and getting pwned :)
10:17:19 <byorgey> hehe =)
10:17:29 <byorgey> is (~>) in a package on Hackage anywhere?
10:17:51 <xplat> you'd have to ask hayoo
10:18:01 <hpc> @hoogle (~>)
10:18:02 <lambdabot> No results found
10:18:20 <frank00> nice symbol though
10:18:21 <paolino> some categories ?
10:18:21 <byorgey> Control.Concurrent.Session.~>
10:18:26 <byorgey> I don't think that's the same thing...
10:18:26 <xplat> the public hoogles don't cover enough packages
10:18:52 <mun_> xplat, hi again. so if I understand correctly, a stronger logic can be embedded in a weaker one. so since HOL is a stronger logic than FOL, then HOL can be embedded in FOL?
10:20:05 <ClaudiusMaximus> hm, my haskell program with +RTS -N -RTS (on a two core machine) has pushed my load average to 40+ :/  i do do a lot of forkIO of long-running FFI computations, but that's a bit insane..
10:20:17 <ClaudiusMaximus> (ghc 6.12.3, fwiw)
10:20:27 <xplat> mun_: i won't say the term 'embedded' is too ambiguous here in general, but it's too ambiguous for most non-logicians (and technically i'm not logician either)
10:20:48 <Brechreiz> @src foldr
10:20:49 <lambdabot> foldr f z []     = z
10:20:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:25:42 <aristid> ClaudiusMaximus: -N tells ghc not to limit OS threads?
10:26:14 <hpc> aristid: i don't see -N in my ghc man page
10:26:17 <ClaudiusMaximus> aristid: i thought -N was "choose base on number of available cpu cores" ?
10:26:25 <c_wraith> aristid: No, as of new-enough version of GHC (6.12+), -N is "set to the number of cores"
10:26:33 <c_wraith> *versions
10:26:47 <lpsmith> Brechreiz, I think the actual definition that GHC uses has the static argument transformation applied.
10:27:07 <lpsmith> (definition of foldr, that is)
10:27:19 <aristid> c_wraith: then it should not bring load to 40+, no?
10:27:39 <c_wraith> aristid: it can if it schedules enough IO.  in my experience, CPU use doesn't push load..  IO does
10:27:40 <aristid> Brechreiz: your nickname is a bit disgusting :P
10:27:58 <djahandarie> byorgey, oh whoops. :P I guess that would be like me knowing if there are any user groups in Montreal
10:28:13 <byorgey> djahandarie: no worries =)
10:28:31 <Brechreiz> aristid: It reminds me to end my switch cases with breaks ;)
10:28:39 <byorgey> actually I have never even been to Pittsburgh
10:28:43 <byorgey> although I would like to visit someday
10:29:21 <aristid> Brechreiz: which is not necessary in haskell!
10:30:16 <Brechreiz> aristid: Of course, but I don't have a separate nickname in every channel :)
10:32:30 <sunfun> good evening
10:33:35 <sunfun> whi  if i do   length [1..10] + 3.2 i get an error and i have to use  fromIntegral (length [1..10])+3.2  to let it work?
10:33:39 <ClaudiusMaximus> interesting: watch pstree (pid of my program)  shows number of threads increasing, starting at 3 after first launch, after some time it's now at 12, when the load went to 40+ there were 71
10:33:45 <lpsmith> sunfun:
10:33:50 <lpsmith> :t length [1..10]
10:33:52 <lambdabot> Int
10:33:57 <lpsmith> :t 3.2
10:33:59 <lambdabot> forall t. (Fractional t) => t
10:34:08 <lpsmith> and Int is not a fractional type
10:34:24 <sunfun> oh ok... sorry i'm new 
10:34:29 <sunfun> ok so
10:34:30 <lpsmith> sunfun, that's ok :)
10:34:36 <c_wraith> sunfun: And haskell has no automatic conversion between types
10:34:41 <sunfun> :t sum
10:34:42 <lambdabot> forall a. (Num a) => [a] -> a
10:34:54 <lpsmith> > sum [1..10] + 3.2
10:34:55 <lambdabot>   58.2
10:35:17 <lpsmith> :t 1
10:35:18 <lambdabot> forall t. (Num t) => t
10:35:21 <sunfun> yes  oh so Num is a number type uesd by fromIntegral then
10:35:43 <lpsmith> integer literals are polymorphic
10:35:55 <hpc> :t 5
10:35:56 <lambdabot> forall t. (Num t) => t
10:35:59 <lpsmith> but as c_wraith pointed out, there is no automatic conversion
10:36:11 <lpsmith> :t fromIntegral
10:36:12 <lambdabot> forall a b. (Integral a, Num b) => a -> b
10:36:16 <hpc> > (5, 5, 5) :: (Int, Float, Rational)
10:36:17 <lambdabot>   (5,5.0,5 % 1)
10:36:24 <sunfun> right
10:36:28 <sunfun> thanks guys 
10:36:41 <hpc> > (pi, pi, pi) :: (Float, Rational, CReal)
10:36:42 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
10:36:42 <lambdabot>    arising from a us...
10:36:51 <hpc> humbug
10:37:10 <sunfun> funny bot, so i could use prelude here?
10:37:27 <hpc> :t (Prelude..)
10:37:28 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:37:30 <hpc> yes
10:37:36 <sunfun> :D
10:37:57 <hpc> the λbot definitions are more fun though
10:38:13 <sunfun> hpc why Prelude with .. ?
10:38:25 <lpsmith> > (pi, pi, pi) :: (Float, Double, CReal)
10:38:26 <lambdabot>   (3.1415927,3.141592653589793,3.1415926535897932384626433832795028841972)
10:38:32 <lpsmith> :)
10:39:06 <hpc> sunfun: (.)
10:39:08 <lpsmith> kind of too bad we don't have a rational instance for pi... but pi isn't rational,  and it's hard to say how much precision an instance *should* have
10:39:15 <hpc> but you have to put the parens outside the module qualifier
10:39:25 <hpc> :t Prelude.id
10:39:26 <lambdabot> forall a. a -> a
10:39:30 <hpc> :t (Prelude.$)
10:39:31 <lambdabot> forall a b. (a -> b) -> a -> b
10:39:34 <hpc> :P
10:39:39 <sunfun> :D
10:39:43 <sunfun> right
10:44:04 <Younder> Just ordered Algebraic Topology by Alan Hatcher and Topoi the categorial analysis over logic by Goldbalt. Any good?
10:44:43 <Younder> s/goldbalt/Goldblatt/
10:45:38 <Younder> A bit ahead of myself here really. Studying Category theory.
10:45:51 <rwbarton> Hatcher is a good introductory book and quite comprehensive
10:46:31 <rwbarton> it's more geared for, well, mathematicians rather than category theorists, if I may be crude
10:48:39 <Younder> The plan though is a topology of types for my language Formula. My knowlege is insufficient for McClane's Algebra, but I hope to fix that. (A couple of years..)
10:49:15 <Younder> To then McClanes Algebra is my Mount Everest.
10:51:57 <rwbarton> Well, I do recommend Hatcher, but it may not be what you're looking for
10:52:09 <rwbarton> btw it's also freely available online
10:55:23 <Younder> rwbarton, I want to learn algebraic topology primarily because that is where McLane first applied category theory.
10:55:54 <Younder> rwbarton, I feel It will provide me with background.
10:58:18 <hpaste> anonimous pasted "no"  http://hpaste.org/44398
10:58:57 <hpaste> anonimous pasted "no"  http://hpaste.org/44399
10:59:09 <Runar> shlevy: Oh, you're here already :)
11:01:56 <xplat> lpsmith: Rational is an exact type, and it doesn't include the exact value of pi
11:02:41 <lpsmith> xplat, I am aware
11:02:43 <Younder> What's this main = do
11:02:43 <Younder>        print maxn     print $ length p132      print $ sum p133      print p132
11:02:56 <maurer_> xplat: To be fair, we allow the use of pi in anything which is Floating, and that doesn't gaurantee an exact value either.
11:03:07 <Younder> This should be in monadic notation
11:03:20 <aristid> Younder: you cannot just remove the newlines
11:03:53 <Younder> aristid, No, but the don't appear as newlines in this channel
11:03:56 <xplat> maurer_: yes, but inexact values are appropriate for types like Float and Double.  they are not appropriate for Rational.
11:04:16 <aristid> Younder: http://hpaste.org :)
11:05:06 <xplat> an inexact pi wouldn't be appropriate for CReal either, but luckily the exact value of pi *is* in CReal
11:05:56 <hpaste> ClaudiusMaximus pasted "too many workers?"  http://hpaste.org/44401
11:06:17 <ClaudiusMaximus> why are there so many??
11:07:56 <ClaudiusMaximus> if i just start my program and exit it, there are 4 workers, which is reasonable...
11:08:06 <gwern> out of curiosity, does darcs-graph generate enormous whitespace for anyone else?
11:09:00 <lpsmith> rwbarton, insinuating that category theorists aren't mathematicians,  are we?  :)
11:09:33 <lpsmith> I've had real difficulty learning category theory because there are *so many definitions* before there is a theorem I can really latch onto
11:09:45 <revenantphx> hm :|
11:11:08 <rwbarton> lpsmith: what I meant by that is that Hatcher assumes some modest familiarity with linear algebra, real analysis, etc. and not so much with category theory
11:11:16 <hpc> lpsmith: i have a link that will at least get you started on what a category is, but i am on my phone atm and cannot copy it
11:11:31 <rwbarton> lpsmith: I would venture that there are many people here with more background in category theory than linear algebra, which is not the case for the majority of mathematicians
11:11:51 <lpsmith> hpc,  I have some kind of start in category theory,  but I'm much stronger with linear algebra :)
11:12:31 <Younder> lpsmith, Category theory is giving me a real 'run for my money', but I CAN see the use. I am having troubles with it though.
11:12:41 * hackagebot hakyll 3.0.0.3 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.0.0.3 (JasperVanDerJeugt)
11:12:49 <McManiaC> meh, why wont this apply? :S http://npaste.de/yv/
11:12:54 <McManiaC> any ideas?
11:13:37 <ClaudiusMaximus> hmm, probably this one - guess i better use that 'spawn' package... http://hackage.haskell.org/trac/ghc/ticket/4262
11:14:20 <Younder> rwbarton,  No, I came from theoretical Physics.
11:15:18 <hpc> lpsmith: http://98.169.17.243:8000/blog/view.cgi?id=8
11:15:23 <lpsmith> Actually I have a BS in math,  but my department didn't really have any category theorists around.  Although I did find out after I graduated that there was a category theorist in the philosophy dept.
11:15:47 <hpc> also Younder ^
11:16:06 <rwbarton> Younder: That's probably a good background to read Hatcher then.
11:16:22 <gwern> lpsmith: interesting. I've always wondered how I could use category theory in philosophy
11:16:32 <Younder> rwbarton,  One day I got tired of ramming my head against the wall. The I started with AI and programming languages. Which I have been doing ever since (20 years)
11:16:59 <Cale> That's actually my main criticism of Hatcher's book, that if he took a relatively small amount of time developing a few category theoretic concepts, his presentation of a lot of stuff would improve a good deal.
11:17:37 <Cale> In particular, the Seifert-van Kampen theorem is much more natural to state and prove with a few extra concepts.
11:19:19 <lpsmith> gwern, well,  some philosophy profs are really logicians,  more math than liberal-arts type of philosophy
11:19:30 <revenantphx> I'm having a bit of a mental flop :\
11:19:36 <revenantphx> eugh.
11:19:39 <Younder> Cale: Cool where will I find the theorems that need improvement?
11:20:01 <Cale> You can break it down into the fundamental groupoid functor preserving pushouts, and a few other details which relate things back to groups (including a characterisation of pushouts in groupoids/groups)
11:20:01 <gwern> lpsmith: yes, obviously, but I was wondering more specifically. did he work on outright logic stuff or had he found more interesting applications of category theory?
11:20:18 <Cale> Younder: I'm not actually sure, since my AT course didn't actually have a textbook.
11:20:24 <Younder> sorry Seifert-van Kampen theorem. You beet me to it.
11:20:35 <Cale> oh, well, yeah
11:20:40 <lpsmith> gwern, it was Colin Mclarty,  you've probably at least heard of him if you've studied Category Theory much
11:20:46 <Cale> I don't have a source for the better version, but I could state it myself.
11:20:57 <lpsmith> err, McLarty
11:21:35 <gwern> lpsmith: I hadn't, because I'm too lazy to study CT without a compelling interest and CT doesn't enter into my haskell enough to count
11:21:56 <lpsmith> lol,  basically same here
11:22:07 <Cale> For any topological space, we can define the fundamental groupoid as the category whose objects are the points in the space, and where the arrows x -> y are the homotopy classes of paths from x to y. Composition is concatenation of paths, and the identity is the obvious thing.
11:22:45 <gwern> lpsmith: hah, his CV is the same format as my resume - we must've stolen from the same latex example resume
11:22:52 <Younder> Adowey's book on Category theory is much recommended. The one I am working on right now. I still 'loose it' a few times though. 
11:23:40 <Cale> In any category, if we have objects and arrows B <- A -> C, the pushout of this diagram, if it exists, is an object P and arrows B -> P <- C such that the square commutes, and for any other object and arrows B -> Q <- C for which the square commutes, there is a unique arrow P -> Q making the whole diagram commute
11:24:30 <Cale> In topological spaces, the pushout of B <- A -> C is the disjoint union of B and C modulo the relation that glues together points in B and C which are the image of the same point in A.
11:24:35 <revenantphx> I have Awodey's book sitting right here >.>
11:24:44 <revenantphx> I'm planning on getting to reading it as soon as I finish this damn calculator.
11:24:46 <Younder> Cale, Yes, I can see THAT.
11:25:03 <gwern> lpsmith: I'll have to look through http://philpapers.org/s/Colin%20Mclarty later
11:25:08 <Cale> The Seifert van Kampen theorem "really" says that the fundamental groupoid functor preserves pushouts.
11:25:19 <revenantphx> One question :|
11:25:36 <revenantphx> where can I find something like the hackage pages,
11:25:38 <revenantphx> but for Prelude etc
11:25:45 <Cale> So if you have a pushout of topological spaces, and you apply the fundamental groupoid functor to all the spaces and maps, you get a pushout of groupoids.
11:25:48 <revenantphx> I sometimes stumble on one randomly, but it'd be nice.
11:26:27 <Cale> and then all that's left is to characterise what pushouts of groupoids look like, and then some details about how to compute the endomorphism group of an object in a groupoid.
11:26:36 <hpc> revenantphx: http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/Prelude.html
11:26:39 <hpc> ?
11:26:39 <revenantphx> ah okay
11:26:42 <Cale> But that sort of splits the work up nicely.
11:26:44 <revenantphx> just wanting to strip spaces here XD.
11:26:56 <xplat> gwern: you should also have heard of colin mclarty if you browsed the fom-list archives
11:27:13 <Cale> If I recall correctly, this version of the theorem also often has Brown's name attached to it.
11:27:15 <gwern> xplat: fom-list? new to me
11:27:47 <revenantphx> What's the fastest/cleanest way to strip spaces?
11:27:55 <revenantphx> even just a replace function :|
11:27:59 <revenantphx> I'm surprised this isn't in the stdlib.
11:28:03 <revenantphx> er, Prelude
11:28:10 <mauke> filter (not . isSpace)
11:28:16 <revenantphx> ah, thanks
11:28:51 <revenantphx> error is bizzare...
11:29:01 <revenantphx> eh, I guess that's just ghci being lazy
11:29:03 <revenantphx> funny though
11:29:13 <revenantphx> it doesn't print the error till it reaches the place in the list where there is an error
11:29:19 <revenantphx> [1,2,3ERROR
11:29:31 <xplat> gwern: foundations of mathematics mailing list
11:29:45 <Cale> revenantphx: Well, of course it does that :)
11:29:51 <revenantphx> Just kind of amusing XD.
11:30:00 <revenantphx> now to get over this mind flop
11:30:11 <Cale> revenantphx: Being able to tell ahead of time that there's an error is equivalent to the halting problem :)
11:30:13 <hpc> "ghci being lazy" lol
11:30:17 <hpc> :P
11:30:31 <revenantphx> I'm suffering from a block, wherein I can't think of what the type signature for this would be :|
11:30:33 <xplat> revenantphx: do a mind flip
11:30:45 <revenantphx> for the parse portion of the shunting yard algorithm >_>
11:30:58 <revenantphx> Takes in an ExprStack, and then uses one intermediate while producing a new one.
11:31:15 <revenantphx> I guess a hidden or nested recursive function would work >_>.
11:31:22 <revenantphx> But... I was sure you could scan/map/fold
11:31:24 <revenantphx> hm.
11:33:00 <hpc> revenantphx: you have your output, your input, and a stack
11:33:12 <revenantphx> Well, all three are stacks/lists :P
11:33:16 <hpc> the output you build from the front, so you can build that list like this:
11:33:25 <xplat> you can't just use the list functions if you want to get extra mojo out of the type system
11:33:36 <hpc> f bigThing = x:(shrink bigThing)
11:33:58 <revenantphx> hpc: Yeah I know.
11:33:58 <hpc> the other stack you have to pass around each step
11:34:10 <hpc> and the input, you fold over
11:34:31 <revenantphx> :t (foldl)
11:34:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:34:49 <revenantphx> @hoogle ([a] -> [b] -> [a]) -> [a] -> [b] -> [a]
11:34:49 <lambdabot> No results found
11:34:54 <revenantphx> anyways, yeah
11:35:11 <hpc> :t foldr -- what you probably want
11:35:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:35:19 <hpc> and let b = [somethingElse]
11:36:10 <revenantphx> but foldr goes from the end >_>.. hm
11:36:22 <hpc> revenantphx: not necessarily
11:36:54 * hpc brainfarts, can't come up with an example
11:37:24 <hpc> @src foldr
11:37:24 <lambdabot> foldr f z []     = z
11:37:25 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:38:12 <hpc> foldr (\x xs -> x++xs) "123"
11:38:13 <paolino> why cabal decide to reinstall a package and move it to a newer version, breaking everything ....
11:38:16 <hpc> > foldr (\x xs -> x++xs) "123"
11:38:17 <lambdabot>   Overlapping instances for GHC.Show.Show
11:38:17 <lambdabot>                              ([[GHC...
11:38:27 <hpc> > foldr (\x xs -> x++xs) "123" "456"
11:38:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:38:27 <lambdabot>         against inferred ty...
11:38:29 <hpc> humbug
11:38:41 <hpc> :t foldr (\x xs -> x++xs)
11:38:42 <lambdabot> forall b. (Monoid b) => b -> [b] -> b
11:38:51 <mauke> :t foldr (++)
11:38:52 <lambdabot> forall a. (Monoid a) => a -> [a] -> a
11:38:59 <mauke> :t foldr (++) "123"
11:39:00 <hpc> :t foldr (\x xs -> x++xs) "123" ["123","456","789"]
11:39:00 <lambdabot> [[Char]] -> [Char]
11:39:01 <lambdabot> [Char]
11:39:03 <manizzle> how can i time haskell command execution?>
11:39:06 <hpc> > foldr (\x xs -> x++xs) "123" ["123","456","789"]
11:39:06 <revenantphx> hpc: btw, trying to redo shunting-yard in haskell
11:39:06 <revenantphx> lemme paste what I already have >_>
11:39:07 <lambdabot>   "123456789123"
11:39:31 <revenantphx> https://gist.github.com/847950
11:40:21 <hpc> so setting aside folds and crap...
11:40:57 <hpc> you want a helper function :: input -> stack -> output
11:40:58 <ClaudiusMaximus> after further pondering, it seems i had wrong assumptions: ie, i assumed +RTS -N2 -RTS would use at most 2 OS threads in total, when in fact it uses 2 OS threads to execute haskell threads, with additional threads as needed when the haskell threads make 'safe' foreign calls)
11:41:05 <revenantphx> hpc: that's what I was thinking earlier >_>
11:41:17 <hpc> which would be ExprStack -> ExprStack -> ExprStack
11:41:26 <revenantphx> yep
11:41:50 <hpc> which i will pretend is [Double] for the moment
11:41:53 <hpc> it helps my weak brain
11:41:56 <revenantphx> ...heh
11:42:02 <revenantphx> that might not help
11:42:04 <revenantphx> but okay
11:42:54 <hpc> so when we have an input symbol...
11:43:07 <hpc> helper (x:xs) stack = x:(helper xs stack)
11:43:17 <hpc> ie, push the symbol straight to output
11:43:32 <FUZxxl> I want to write a parser (attoparsec), that parses a string like "foobar", beginning and ending with a quote ", which must not contain any newlines. How is that possible?
11:43:35 <revenantphx> yep :|
11:43:44 <hpc> when we have no more output
11:43:49 <hpc> er, no more input
11:43:53 <revenantphx> helper [] stack = ...
11:43:58 <hpc> helper [] stack = stack
11:43:59 <xplat> > foldr (:) undefined "this starts from the start"
11:44:00 <lambdabot>   "this starts from the start*Exception: Prelude.undefined
11:44:16 <revenantphx> rename 'stack' as 'out'
11:44:20 <revenantphx> or 'rpn'
11:45:17 <hpc> then if the front of input is an operator
11:45:34 <hpc> you want to check the top of the stack
11:45:51 <revenantphx> yessir.
11:45:57 <hpc> helper (x:xs) (op:ops) | something = stuff
11:45:58 <revenantphx> well, technically
11:46:02 <revenantphx> imperatively its
11:46:05 <hpc> | otherwise = other stuff
11:46:22 <xplat> > foldr (:) undefined $ foldr (:) (undefined:" not the end") "this starts from the start"
11:46:24 <lambdabot>   "this starts from the start*Exception: Prelude.undefined
11:46:30 <revenantphx> while(stack.isNotEmpty() & op.prec > stack.peek.prec)...
11:46:38 <revenantphx> and for right associative operators, >=
11:47:23 <xplat> (just in case it looked like the undefined might be the only thing not forced early)
11:47:54 * hpc implemented shunting-yard at one point and iirc it was horribly broken
11:48:19 <spetrea-home> anyone from .de here ?
11:49:14 <revenantphx> Works fine imperative style
11:49:18 <revenantphx> just trying to do it functionally for fun
11:49:55 <uber_mor2> If I'm implementing an instance of a class, do functions that are defined before the instance declaration remain hidden when later importing that module?
11:50:47 <hpc> uber_mor2: no; it's impossible to change the meaning of a program by changing the order in which you declare functions
11:50:58 <hpc> (except for pathological let-ing)
11:51:21 <uber_mort> hpc: Hmmm, can you think of any reason my functions defined before the instance declaration are not in scope when I try to import my module in another program?
11:51:46 <hpc> uber_mort: export list?
11:52:24 <uber_mort> hpc: I exporting everything
11:52:35 <uber_mort> hpc: err I am
11:52:41 <uber_mort> hpc: I'll pastebin real quick
11:53:12 <revenantphx> so hpc, given my Expr GADT
11:53:17 * hpc needs to fix his shuntingyard, actually
11:53:21 <revenantphx> would it be possible to pattern match against ?
11:53:27 <hpc> against ^H?
11:53:37 <xplat> revenantphx: you can't spell 'functional' without 'fun'
11:53:41 <uber_mort> hpc: http://pastebin.com/B7BaWtwk for some reason the fifoFromList and fifoToList aren't visible when I import FifoQueue
11:53:52 * hackagebot SHA2 0.2.4 - Fast, incremental SHA hashing for bytestrings  http://hackage.haskell.org/package/SHA2-0.2.4 (SveinOveAas)
11:53:57 <xplat> or 'unction', but i don't like to think about that
11:54:08 <revenantphx> hpc: I mean, to match any Operator Binary Left
11:54:11 <revenantphx> or something like that
11:54:11 <hpc> uber_mort: your export list contains only FifoQueue
11:54:16 <revenantphx> it'd be a messy match, but might be neat.
11:54:22 <hpc> you want module FifoQueue where ...
11:54:23 <uber_mort> hpc: I thought that would export everything? :-/
11:54:41 <hpc> no parens is no export list, which is everything
11:54:46 <hpc> () is export nothing
11:54:55 <hpc> (BlahBlah) is export just BlahBlah
11:54:56 <uber_mort> hpc: Ooooh, thank you :P
11:55:39 <hpc> revenantphx: retype "would it be possible..." again?
11:55:43 <hpc> i think i missed part of it
11:55:47 <revenantphx> would it be possible to pattern match against?
11:55:52 * hackagebot SHA2 0.2.5 - Fast, incremental SHA hashing for bytestrings  http://hackage.haskell.org/package/SHA2-0.2.5 (SveinOveAas)
11:55:55 <revenantphx> and before that "so member:hpc, given my Expr GADT"
11:55:59 <hpc> oh, derp
11:56:22 <hpc> yeah, it can be matched against
11:56:30 <revenantphx> I also have to unbox out of the SomeExpr
11:56:32 <revenantphx> but eh
11:56:54 <revenantphx> but it says for instance that this is invalid
11:57:00 <revenantphx> test :: SomeExpr -> Int
11:57:01 <revenantphx> test (SomeExpr (Expr (Operator Binary Left))) = 0
11:57:08 <revenantphx> because Operator Binary and Left aren't data constructors.
11:57:32 <hpc> revenantphx: but Add, Sub... are
11:57:36 <revenantphx> Well yes.
11:57:45 <revenantphx> but I'm wondering if I can pattern match againt specific parts such as associativity
11:57:52 <hpc> so you match against those, or write isOp :: Expr a -> Bool
11:58:12 * hpc doesn't GADT
11:59:14 <revenantphx> hm
11:59:43 <revenantphx> well, I'm still curious how I'd write out an AST using GADTs
11:59:51 <revenantphx> Where Add would be Add :: Expr -> Expr -> Expr (...)
11:59:56 <revenantphx> Before I had some issues.
12:00:03 <revenantphx> I wasn't sure how to tag them. :\
12:00:04 <revenantphx> anyways
12:00:22 <rwbarton> revenantphx: what's the AST?
12:00:37 <revenantphx> rwbarton: +, -, *, /, ^, (, )
12:00:39 <revenantphx> and numbers
12:02:13 <hpc> revenantphx: my current shuntingyard is kinda shit, but here it is:
12:02:15 <hpc> http://dl.dropbox.com/u/37707/Data/Math/MathUtil.hs
12:02:33 <revenantphx> reverseParse Optimus = return "Optimus Prime"
12:02:35 <revenantphx> Should I ask?
12:02:40 <hpc> it's from an irc bot
12:02:46 <hpc> my first ever program
12:02:50 <revenantphx> heh
12:02:55 <hpc> oh, the bot does differentiation
12:02:59 <hpc> >diff x == 1
12:03:07 <hpc> >diff Optimus == Optimus Prime
12:03:14 <revenantphx> ah.
12:03:17 <hpc> :P
12:03:19 <revenantphx> >.>
12:03:19 <revenantphx> nice.
12:03:23 <tawe> Question. I'm reading a book of Haskell (The Craft) and in some chapters mentions an operator \\ to do the difference of two lists. It seems that doesn't exists :/
12:03:27 <tawe> @src (\\)
12:03:28 <lambdabot> (\\) = foldl (flip delete)
12:03:33 <revenantphx> :t (\\)
12:03:34 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
12:03:36 <revenantphx> seems to exist.
12:03:40 <tawe> winhugs sucks then
12:03:48 <hpc> @hoogle (\\)
12:03:48 <lambdabot> Data.IntMap (\\) :: IntMap a -> IntMap b -> IntMap a
12:03:48 <lambdabot> Data.IntSet (\\) :: IntSet -> IntSet -> IntSet
12:03:48 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
12:04:01 <hpc> import Data.List :P
12:04:02 <bluej774> Can anyone link me to an example of filterByte?
12:04:16 <bluej774> I can't wrap my head around it.
12:05:05 <tawe> @src delete
12:05:06 <lambdabot> delete = deleteBy (==)
12:05:17 <bluej774> @hoogle filterByte
12:05:17 <lambdabot> No results found
12:05:22 <tawe> @src deleteBy
12:05:22 <lambdabot> deleteBy eq x []        = []
12:05:22 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
12:05:30 <revenantphx> so lets see
12:05:38 <revenantphx> im thinking about how math statements would look as trees
12:05:46 <revenantphx> each node = operator, leaf = literal value?
12:06:04 <revenantphx> and then I suppose you could evaluate from the bottom upwards :\
12:06:05 <hpc> revenantphx: yep
12:06:38 <revenantphx> but what about parentheses >.>
12:06:56 <revenantphx> would they really just affect the generation of the tree?
12:07:05 <rwbarton> you don't need parentheses if you have a tree
12:07:32 <revenantphx> I mean from a list of infix style tokens
12:07:35 <revenantphx> to generate the tre
12:07:48 <hpc> oh right, parens
12:07:56 <revenantphx> do parentheses only serve to override the usual rules when it's building the tree?
12:08:06 <rwbarton> yes
12:08:33 <hpc> huh, it seems i did finish shuntingyard...
12:08:51 <xplat> parentheses tell you 'everything between these parentheses is a single branch'
12:09:03 <revenantphx> xplat: ah! thanks.
12:09:22 <xplat> it doesn't tell you which thing inside the parens is the stem of that branch, though
12:09:41 <xplat> you figure that out with your usual precedence rules
12:09:43 <hpc> parens are explained on the shuntingyard wiki page
12:09:55 <revenantphx> Not trying shunting yard right now hpc :|
12:09:59 <hpc> :P
12:10:01 <revenantphx> I know how they work in shuntingyard.
12:12:05 <revenantphx> lol
12:12:10 <revenantphx> I wrote out
12:12:11 <revenantphx> data ExprAST = Operation ExprAST ExprAST
12:12:11 <revenantphx>              | Value Double
12:12:18 <revenantphx> and then toyed with it in ghci for a second before thinking
12:12:23 <revenantphx> "this looks like lisp >.>"
12:12:30 <revenantphx> clichés abound...
12:16:19 <monochrom> not exactly lisp because lisp is not so big about binary operators i.e. Operation ExprAST ExprAST
12:16:35 <revenantphx> True
12:16:37 <revenantphx> I quickly changed it to
12:16:38 <revenantphx> data ExprAST = BinaryOp Operator ExprAST ExprAST
12:16:38 <revenantphx>              | UnaryOp Operator ExprAST
12:16:38 <revenantphx>              | Value Double
12:16:56 <revenantphx> Maybe I should just make it Operation Operator [ExprAST]
12:17:04 <revenantphx> ALL OPERATORS INFIN-ARY
12:17:07 <revenantphx> >.>
12:17:12 <monochrom> for now it doesn't matter either way
12:17:13 <revenantphx> nah, wouldn't work for infix.
12:17:38 <monochrom> play with both choices when you have time
12:17:43 <revenantphx> hm yeah
12:17:50 <revenantphx> parsing stuff is really fun :)
12:21:19 <Blazemore> Sorry if this is a stupid question, but would you recommend an IDE for light, toy project development?
12:21:30 <Blazemore> At the moment I just use Notepad++ on Windows, with GHC
12:21:47 <revenantphx> Now how do I parse into a tree ...
12:21:48 <revenantphx> hm
12:21:49 <Blazemore> I'd like it to be cross-platform if possible. Just after some recommendations
12:21:50 <revenantphx> food for thought.
12:22:05 <revenantphx> Without doing recursive descent and getting stuck in the goddamn LL recursion stuff.
12:22:12 <revenantphx> >:|
12:23:05 <Blazemore> Why do you want to avoid recursion?
12:23:16 <Blazemore> It's pretty much the only way to operate on trees
12:23:25 <revenantphx> try parsing "(1 + 3) + 5" recursively >_>
12:23:26 <revenantphx> have fun.
12:23:29 <Saizan> revenantphx: there are mechanical transformations to remove left-recursion
12:23:32 <aristid> !cal fix ("I want to avoid recursion because " ++)
12:23:37 <aristid> > fix ("I want to avoid recursion because " ++)
12:23:39 <lambdabot>   "I want to avoid recursion because I want to avoid recursion because I want...
12:23:42 <Saizan> revenantphx: or just use chainl from parsec :)
12:23:50 <revenantphx> hm yeah... something like that.
12:24:01 <revenantphx> well I need to stop coding for today and get some work done.
12:26:32 <pedro3005> How do I restrict a type variable to a certain type? Like if I'm making data Type a = Type a deriving Show, but a must be a string, how do I indicate that?
12:27:24 <Saizan> why do you want to do that?
12:28:08 <pedro3005> I, uhm... no particular reason I guess
12:28:20 <pedro3005> is it something that shouldn't be done?
12:28:48 <Saizan> well, if you want to use it with only a particular type you could just define data Type = Type String
12:29:59 <Saizan> there's also "data Type a where Type :: String -> Type String" but i suspect that's not what you want
12:30:43 <mauke> data Type a = Type String  -- :-)
12:39:07 <tawe> Any short way of making a function that gives all the sublists of a list?
12:39:28 <mauke> filterM (return [True, False])
12:40:03 <Younder> What kinda sublist do you want?
12:40:22 <mauke> > filterM (return [True, False]) "sublist"
12:40:24 <lambdabot>   ["sublist","sublis","sublit","subli","sublst","subls","sublt","subl","subis...
12:40:47 <revenantphx> Question: Why are humans so good at coming up with (and using) ambiguous grammars?
12:41:02 <tawe> > filterM (return [True, False]) [1,2,3,4,5]
12:41:03 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1...
12:41:08 <tawe> > filterM (return [True, False]) [1,2,3]
12:41:10 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:42:44 <c_wraith> revenantphx: all evidence we have supports the conclusion that handling natural language requires the full range of human brainpower.  As in, language is what the brain has evolved to handle.  It's optimized for it.
12:43:00 <revenantphx> optimized for ambiguous grammar :P
12:43:15 <c_wraith> sure.  natural language is full of ambiguous grammar
12:43:24 <mauke> no, you're full of it
12:43:26 <c_wraith> ambiguity also allows concise encoding.
12:43:32 <revenantphx> c_wraith: that's true.
12:43:33 * mauke runs away
12:43:39 <monochrom> ambiguous grammar is no big deal for a highly parallel computer
12:43:40 <revenantphx> Assuming you have rules to resolve the ambiguities.
12:43:47 <pozic> The value of ambiguity is that you can make people with a differing opinion happy with what you said.
12:44:16 <ddarius> Computers are rarely given even a fraction of the context humans have in resolving such ambiguities.
12:44:27 <revenantphx> ddarius: Ah, that's true.
12:44:38 <pozic> Yeah, now you are just discriminating the computers.
12:44:59 <monochrom> ambiguous grammar is not the hardest part of natural languages. context is. including ambiguous context. but context is still no big deal for a computer with petabytes of O(1) memory.
12:47:26 <monochrom> how mathematicians write/speak illustrates natural languages at its finest. "for every x, P x y, for some y". this is ambiguous as in "is that (∀x∃y P x y)? is that (∃y∀x P x y)?"
12:48:31 <pozic> monochrom: I only see (∀x∃y P x y) there.
12:49:06 <monochrom> here is how mathematicians disambiguate secretly. under the contextual assumption that when a mathematician makes (bothers to make) a statement, the intention is a statement both true and non-trivial to prove using the mathematical knowledge in context.
12:49:15 <pozic> Otherwise it should have been (for every x, P x y), for some y.
12:49:25 <bla123> is there a kind of lambda for types? e.g. lam a b. Either b a
12:49:32 <monochrom> (∃y∀x P x y) = ((for every x, P x y), for some y)
12:49:51 <mauke> bla123: no
12:50:11 <bla123> mauke: ok :(
12:50:13 <pozic> monochrom: ok, good point ;)
12:50:23 <monochrom> So, to disambiguate, you attempt to prove and disprove both statements. if one of them is trivially true, it is not intended; or, if one of them is false, it is not intended.
12:51:00 <monochrom> Parsing a mathematician's statement requires a Gödel-complete theorem prover.
12:51:11 <pozic> monochrom: or the paper has a bug..
12:51:22 <bla123> mauke: is there a good reason for not having type lambdas or is there simply no such feature?
12:51:46 <Kaidelong> if I have something that lifts a second order pure function to a second order impure function (ie ((a -> b) -> r) -> ((a -> m b) -> m r)) do I also have the ability to lift things to higher orders IE (((a -> b) -> c) -> r) -> (((a -> m b) -> m c) -> m r)
12:51:47 <pozic> monochrom: I prefer my mathematics in a Coq proof-script with a natural language version going with it.  
12:51:52 <Gentoolx> I think that the very good resource about processing natural languages is here: http://panlingua.net/
12:52:39 <ddarius> bla123: In general that would require higher-order unification which is undecidable.  Though, it would be possible to do it with higher order pattern unification.  This is not, however, factoring in how the various extensions would interact with this extension.
12:54:04 <bla123> ddarius: well, i guess with some extensions you already give up on decidability, but i can see that it may also be difficult to implement
12:54:34 <Kaidelong> also is it safe to make a function that does ((a -> b) -> r) -> ((a -> m b) -> m r) using unsafePerformIO?
12:54:49 <rwbarton> bla123: it's basically incompatible with type classes
12:55:08 <ddarius> Actually, excepting bugs, there is only one GHC extension that make type checking undecidable.
12:55:12 <Kaidelong> well IO for m in that case
12:55:18 <rwbarton> or at least, you couldn't make type lambdas instances of type classes
12:55:24 <Kaidelong> or is there some subtle difficulty with evaluation order that will throw me off?
12:55:37 <bla123> rwbarton: why not?
12:56:11 <Kaidelong> return . (unsafePerformIO .)
12:56:16 <Kaidelong> to be exact
12:56:49 <rwbarton> bla123: consider return :: a -> m a
12:57:06 <rwbarton> if m could be a type lambda, you'd have no way to infer what it was from any use of return
12:57:20 <Saizan> Kaidelong: the execution of the effects of the callback will depend entirely on evaluation order
12:57:38 <bla123> ddarius: would it really be that bad if the type system was undecidable? it sometimes had to give up on type checking, but would it reject any practically relevant programs or is it a purely theoretical issue?
12:58:44 <Kaidelong> Saizan: the intention would be to lift second order functions into the context of a pipeline/do-block, will it cause problems in that case?
12:58:48 <bla123> rwbarton: ok, thanks for the illustration
13:00:02 <Saizan> Kaidelong: that additional info doesn't help clarifying the matter
13:02:14 <Saizan> if you did something like that to e.g. map, you'd basically get \f -> mapM (unsafeInterleaveIO . f), unless GHC is feeling like being very creative on reordering evaluation :)
13:03:15 <Kaidelong> that does not sound like what I want
13:06:37 <djahandarie> @tell edwardk Submit that GSOC stuff!
13:06:37 <lambdabot> Consider it noted.
13:07:38 <Blazemore> Is there a library function to determine if every element of a list is a particular value?
13:07:50 <Blazemore> IE you have a list of Ints, and you want True if they are all 4
13:07:52 <mauke> :t all
13:07:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:08:10 <Blazemore> ty
13:08:17 <Blazemore> wait what
13:08:29 <Blazemore> 1 sec, Hoogle
13:08:43 <Kaidelong> :t all . (==)
13:08:45 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
13:08:59 <Kaidelong> > (all . (==)) 5 [5,5,5,5,5,5,5,5]
13:09:01 <lambdabot>   True
13:09:05 <Kaidelong> > (all . (==)) 5 [5,5,5,5,5,5,5,3]
13:09:07 <lambdabot>   False
13:09:20 <ddarius> bla123: You definitely don't want your compiler to try for a while and then give up if it hasn't yet found a suitable type, because that means whether your program type-checks becomes fragile and arbitrary.
13:09:22 <Kaidelong> for Blazemore
13:09:27 <Blazemore> Oh I see
13:09:35 <Blazemore> Thanks
13:09:40 <Blazemore> Kaidelong++
13:09:42 <Blazemore> ...?
13:09:47 <ddarius> bla123: On the other hand, it's not all that bad to have the compiler loop forever.
13:09:59 <Kaidelong> does lambdabot even do karma?
13:10:04 <ddarius> Yes.
13:10:10 <Blazemore> What's the syntax?
13:10:15 <mauke> what you did
13:10:19 <Blazemore> It worked?
13:10:32 <djahandarie> ala' All foldMap :: (Foldable t) => (a -> Bool) -> t a -> Bool
13:10:34 <Kaidelong> doesn't give feedback I suppose
13:10:39 <Blazemore> Nevermind
13:10:43 <Blazemore> *Never mind
13:10:44 <djahandarie> ala' Any foldMap :: (Foldable t) => (a -> Bool) -> t a -> Bool
13:11:32 <bla123> ddarius: well, it wouldn't be that bad if practical programs do not trigger it. hm type inference can be O(exp), but have you ever seen a practical program that really takes that long?
13:12:03 <aristid> djahandarie: i've got an idea! it is always confusing which of the ala functions to use. maybe you could just make functions like foldMapAla x = ala' x foldMap
13:13:00 <djahandarie> ala' is only useful if you want an extra map
13:13:23 <djahandarie> It's really not neccessary since with -O2 the program will just be rewritten into it if you compose with fmap
13:13:34 <djahandarie> I just used it because it was shorter ;)
13:14:02 <djahandarie> ala Any foldMap . fmap (==4) $ [1,2,3,4]
13:14:16 <djahandarie> ala' Any foldMap (==4) [1,2,3,4]
13:14:45 <djahandarie> (Of course this wouldn't be a fmap in the case that you are using something other than a foldMap)
13:15:09 <Blazemore> If I have a 2 dimensional list [[a]], how do I "transpose" it? IE rows become columns, and vice versa?
13:15:22 <mauke> :t transpose
13:15:23 <lambdabot> forall a. [[a]] -> [[a]]
13:16:02 <Blazemore> Really? Transpose? Haskell has thought of everything
13:16:10 <aristid> hahaha
13:16:20 <c_wraith> :t doMyJobForMe
13:16:21 <lambdabot> Not in scope: `doMyJobForMe'
13:16:23 <c_wraith> darn
13:16:27 <aristid> stupid haskell!
13:16:35 <djahandarie> > ala ZipList traverse $ [[1,2,3,4],[5,6,7,8]]
13:16:36 <lambdabot>   Not in scope: `ala'Not in scope: `traverse'
13:16:37 <djahandarie> [[1,5],[2,6],[3,7],[4,8]]
13:16:38 <aristid> it can transpose lists, but it can't do useful stuff
13:16:54 <aristid> djahandarie: did you somehow get your newtype package into lambdabot?
13:17:01 <mauke> > nubBy(((>1).).gcd)[2..]
13:17:01 <djahandarie> Clearly not
13:17:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:17:27 <djahandarie> I don't think Cale would be against it
13:17:32 <hpc> :t gcd
13:17:33 <lambdabot> forall a. (Integral a) => a -> a -> a
13:17:44 <aristid> djahandarie: oh, i just saw that there was an answer, but not that it was not by lambdabot
13:18:26 <aristid> > nubBy (fmap (== 0) . mod) [2..]
13:18:28 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:18:45 <aristid> mauke: i think mine is slightly less inefficient :D
13:18:47 <djahandarie> @tell Cale Thoughts on putting http://hackage.haskell.org/packages/archive/newtype/0.1/doc/html/Control-Newtype.html in lambdabot?
13:18:47 <lambdabot> Consider it noted.
13:19:43 <djahandarie> I should come up with better names for ala/ala' but they are so similar that it's hard
13:20:07 <djahandarie> But only using ala' with id gets pretty redundnant
13:21:29 <EvanR> religious variable names
13:22:34 <monochrom> ana and the king
13:24:59 <djahandarie> Maybe I should provide 'lift' also, to lift a function into a newtype
13:30:31 <djahandarie> mapM = ala' WrapMonad traverse
13:30:42 <djahandarie> sequence = ala WrapMonad traverse
13:35:52 <shlevy> Runar: Yup. Had some good help here so far :)
13:36:04 <Runar> splendid
13:36:19 <djahandarie> When you have WrapMonad in your function, you know that something has gone wrong
13:36:37 <shlevy> :t WrapMonad
13:36:38 <lambdabot> forall (m :: * -> *) a. m a -> WrappedMonad m a
13:36:53 <djahandarie> It basically is just a Monad with the proper instances
13:37:35 <uber_mort> I'm calling a function that accepts a list as a parameter. I'm using [0..1000] as my list, but i'm getting a type error, No instance for (Num Char) arising from the literal `1000' at queuedriver.hs:7:27-30
13:39:28 <mauke> uber_mort: your function only accepts Strings
13:40:24 * hackagebot Hsed 0.2 - Stream Editor in Haskell  http://hackage.haskell.org/package/Hsed-0.2 (VitaliyRukavishnikov)
13:40:24 <uber_mort> mauke: Hrm, the definition is fifoFromList :: [a] -> FifoQueue a
13:40:28 <bla123> can i make every type that supports function composition and identity an instance of the Category type class?
13:40:46 <uber_mort> mauke: Ahhh!  It was inferring the wrong type from a print statement that came later I think
13:41:00 <uber_mort> mauke: I did ([1..1000] :: [Int]) and it worked 
13:41:18 <mrshoe> http://pastebin.com/PqM5i1pb
13:41:45 <mrshoe> can anyone suggest a better pattern here, so i can avoid that algebraic type that basically just glues together a bunch of other instances of my typeclass
13:41:48 <mrshoe> ?
13:42:32 <xplat> so a while back i made a crappy little dsl in perl for munging html 
13:43:18 <xplat> recently it has gained id, uncurry, and tuple
13:43:24 * hackagebot cuda 0.3.2.1 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.3.2.1 (TrevorMcDonell)
13:43:46 <monochrom> perhaps existential type. no, perhaps eliminate the three types Sphere, Triangle, Box altogther, use only ScenePrimitive.
13:44:01 <hpc> xplat: fun
13:44:13 <hpc> :t uncurry
13:44:14 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:44:26 <hpc> wouldn't uncurry be id?
13:44:31 <mrshoe> monochrom: i've thought about that.. but if each of those types is going to end up owning a couple hundred lines of code, i'd like to have Triangle.hs, Sphere.hs, etc.. not group them all in one type
13:44:38 <xplat_> in perl?  normally
13:44:41 <hpc> &foo($arg[0], $arg[1]) == &foo(@arg)
13:44:58 <hpc> but?
13:44:59 <ddarius> :t uncurry id
13:45:00 <lambdabot> forall b c. (b -> c, b) -> c
13:45:27 <xplat_> but there are curried functions in this dsl, whose first arglist comes from direct perl code, then they return a sub that gets another arg fed in through the DSL mini-interpreter
13:45:43 <hpc> oh
13:45:54 <xplat_> so uncurry lets them get a tuple from the DSL
13:45:54 <mauke> hpc: why are you calling subs with & :-(
13:45:58 <hpc> makes more sense when things are actually CURRIED lol
13:46:07 <hpc> mauke: because perl example?
13:46:21 <xplat_> so i end up using it for late-binding-y stuff
13:46:21 <mauke> hpc: perl5, not perl4
13:46:48 <hpc> ah
13:46:49 <mauke> hpc: that syntax has been obsolete since 1995
13:46:56 <hpc> well i learned perl on very old code
13:46:57 <mauke> welcome to the 90s
13:47:05 <hpc> VERY old
13:47:20 <ddarius> Back in the days of the Great War.
13:47:51 <xplat_> the only times you usually still use & with perl subs are when taking refs and when writing an AUTOLOAD method
13:50:11 <aristid> xplat_: i think you can also use it to ignore the prototype
13:50:36 <xplat_> well, yes
13:50:42 <xplat_> but don't do that!  :)
13:50:51 <aristid> heh, true
13:51:03 <aristid> xplat_: perl 5 prototypes are a joke, tho
13:51:38 <xplat_> aristid: they're seldom useful, but in the rare case that they are you should usually not try to get around them
13:52:44 <xplat_> although there was like one time i really had to do that, to wrap something
13:53:12 <ksf> isn't & supposed to signify functions?
13:53:18 <xplat_> well, not technically had to, it was just easier since i barely touched the arguments first
13:53:37 <xplat_> ksf: it does, but functions seldom need signification
13:53:44 <mauke> aristid: they're not a joke, they're parser hints
13:53:49 <shlevy> I need to write the Haskell equivalent of a subset of http://developer.android.com/reference/android/content/ContentValues.html . Essentially, I need a Map that can hold values that are either Strings or Integers. What's available?
13:53:57 <ksf> yep.
13:53:59 <ksf> indeed, it does.
13:54:11 <ksf> just checked the only half-way serious perl prog I ever wrote.
13:54:23 <mauke> shlevy: Map k (Either String Integer)
13:54:40 <ksf> xplat_, I used & everywhere.
13:54:53 <xplat_> ksf: perl4 or perl5?
13:54:58 <shlevy> mauke: Brilliant, thanks 
13:54:59 <ksf> 5
13:55:08 <ksf> I also seem to have understood references, back then.
13:55:25 <xplat_> ksf: using all that & was incorrect
13:56:01 <ksf> THE CODE RAN AND WAS THE FASTER THAN ANYONE ELSES
13:56:04 <ksf> I rest my case.
13:56:06 <xplat_> well, not technically incorrect, but far from idiomatic
13:56:52 <xplat_> i could make code that runs and goes faster than other people's and name all my variables with different casings of the word 'himalaya'
13:57:24 <xplat_> that doesn't make it the right way to write a program ...
13:59:18 <xplat_> if (himalaya($hiMalaya,$hImaLAya,$hiMAlaya) > $hiMalaya->himalaya) {
13:59:50 <augur> O_O
14:00:48 <ksf> hmmm. I always wanted to implement the discordian calendar in haskell.
14:01:02 <ksf> I could use different casings of fnord for everything.
14:01:16 <ksf> > 2^4
14:01:17 <lambdabot>   16
14:01:40 <ksf> well, that should be enough, taking hiding bindings in account.
14:01:45 <blackdog> ksf: you'd have to use a lot of modules
14:01:52 <blackdog> or bindings, yeah. point-free, maybe?
14:02:14 <ksf> well, only for the internal code, not for the API.
14:02:29 <ksf> ddate gets insane only if you look at the innards, too.
14:09:27 <maurer_>  Does anyone know if GHC monomorphizes when possible?
14:09:58 <thoughtpolice> maurer_: ? do you mean specialize a polymorphic function to the types for which it is used?
14:10:14 <maurer_> Yeah, to prevent typeclass dictionaries from being hauled around.
14:10:57 <byorgey> maurer_: not "when possible", it does in two specific situations.
14:11:03 <thoughtpolice> maurer_: not in general no
14:11:11 <maurer_> What are those situations? I'm curious.
14:11:17 <thoughtpolice> you can tell GHC to specialize polymorphic functions using a SPECIALIZE pragma
14:11:23 <byorgey> 1. if the MonomorphismRestriction is turned on (as it is by default), it will monomorphize any type-class-polymorphic definitions which have no parameters
14:11:33 <byorgey> i.e. that looks like   f = ...
14:12:45 <byorgey> 2. in GHC >= 7, any local function definitions (i.e. in a let or where) are monomorphic unless given an explicit polymorphic type signature
14:13:00 <maurer_> OK.
14:13:06 <thoughtpolice> maurer_: if you instruct ghc to SPECIALIZE a function, it will create copies of it and then generate rewrite-rules to be used by the simplifier, rewriting the occurrences to the specialized types. you can also tell GHC to INLINE the resulting specialized function too
14:13:13 <thoughtpolice> by saying {-# SPECIALIZE INLINE ... #-}
14:14:17 <thoughtpolice> although it would probably be a better thing to say 'SPECIALIZE INLINEABLE' so that inlining isn't forced, but instead considered at the call site itself
14:14:32 <thoughtpolice> (don't know if GHC 7 supports SPECIALIZE INLINEABLE, although I'd think it would)
14:15:04 <maurer_> Is there any reason why it doesn't simply specialize all occurrences?
14:15:16 <shlevy> If I need to create a Map with three elements, is it better to use fromList or build up from the singleton/empty map?
14:17:57 <thoughtpolice> maurer_: ISTR that GHC HQ wrote a paper and did some research and found that passing the dictionary around actually helped performance in some instances due to having nice cache effects. also, SPECIALIZE in this case only creates a single specialized instance of some polymorphic function; it does not specialize it to every type
14:18:05 <thoughtpolice> to do so could potentially result in an incredibly massive amount of code bloat
14:18:11 <shlevy> Also... When should you use a Map over a list of tuples?
14:18:29 <thoughtpolice> (using INLINE gratuitously can also result in code bloat and significant slow-downs, for example. hence why INLINEABLE is now so nice to have)
14:19:16 <maurer_> thoughtpolice: I think I understand what SPECIALIZE is doing here, I was more curious why we didn't just use the "if used this way, a copy is specialized for it". The cache effect thing explains that though. Do you happen to have the paper?
14:21:33 * hackagebot riak 0.2.0.0 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.2.0.0 (BryanOSullivan)
14:21:37 <thoughtpolice> maurer_: let me see if I can find it
14:21:42 <maurer_> Thanks :)
14:22:08 <thoughtpolice> maurer_: also in general, it's code bloat. GHC is very careful about specializing things sometimes unless you explicitly cajole it into doing so (INLINEABLE, SPECIALIZE, etc)
14:22:16 <thoughtpolice> at least, that's my understanding
14:22:19 * thoughtpolice starts digging through papers
14:22:54 <maurer_> thoughtpolice: Sure, it's code bloat, but I thought our icaches were big enough these days that code bloat was not as much of an issue. I could very well be wrong though.
14:23:18 <hpc> maurer_: caches are still only a kilobyte or two, i thought
14:23:25 <hpc> plus... ARM
14:24:00 <shlevy> Is there a generalized form of Either? Can you even have a type constructor that takes an arbitrary number of types?
14:24:05 <thoughtpolice> L2 is pretty big these days
14:24:08 <thoughtpolice> L1 is still way too small
14:24:21 <hpc> shlevy: TH could potentially make it arbitrary
14:24:26 <maurer_> The k8 series had 64k, and that was a while ago
14:24:33 <hpc> but not like list arbitrary
14:24:38 <shlevy> hpc: TH?
14:24:43 <hpc> template haskell
14:24:48 <maurer_> thoughtpolice: That's data cache. What matters is instruction cache, yes?
14:24:54 <hpc> it's like the C preprocessor
14:24:57 <hpc> kind of
14:25:11 <thoughtpolice> maurer_: there's also L1i/L1d as well as L2i/L2d, is there not?
14:25:26 <maurer_> thoughtpolice: That's certainly possible. I didn't realize we did L2i
14:25:29 * maurer_ googles
14:25:40 <thoughtpolice> i could be wrong, my memory be hazy sometimes
14:26:55 <maurer_> You're right, it seems to be a thing.
14:28:13 <thoughtpolice> maurer_: also I'd say the code bloat thing is a real problem, ISTR someone had some significant slowdowns when upgrading GHC, because prior GHC's needed INLINE to help direct the simplifier, but newer GHC's were smarter - the resulting code duplication from INLINE everywhere caused magnitudes of slowdown because of the bloat, so it can be a problem
14:28:40 <maurer_> OK.
14:28:45 <danharaj_> Get kited :O
14:28:48 <thoughtpolice> (this is why INLINEABLE was invented, to make sure it can still happen, but it's not forced: INLINEABLE things are checked by the simplifier at all call sites to see if inlining is appropriate, as opposed to blindly doing it)
14:29:57 <bos> preflex: seen sclv
14:29:57 <preflex>  sclv was last seen on #haskell-blah 143 days, 8 hours, 9 minutes and 42 seconds ago, saying: i think its a bit more straightforward still
14:30:27 <maurer_> Ah, now I see why I'm confused. Modern CPUs use L1i, L1d, and then a unified L2 for both instructions and data.
14:30:41 <thoughtpolice> ah, i was wrong then.
14:33:27 <monochrom> it saddens me that "modern CPU" unambiguously refers to modern x86
14:34:14 <monochrom> but yes, essentially the L1d is x86's answer to "risc has a hundred registers"
14:34:51 <thoughtpolice> and like I said, L1 is still excruciatingly small sometimes. cache can be a brutal factor :(
14:35:01 <thoughtpolice> at least x86_64 isn't completely and utterly register starved to hell
14:35:39 * hackagebot blaze-html 0.4.1.0 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.4.1.0 (JasperVanDerJeugt)
14:37:54 <shlevy> Note to self: If you use dates before the epoch in your tests, the timestamps will be negative
14:38:40 <thoughtpolice> just reading the GHC source the other day for the x86 register allocator made me a sad panda, since vanilla x86 is so register starved
14:39:19 <thoughtpolice> (the x86 reg. alloc code for the FP stack is rather, uh, not pretty)
14:39:40 * hackagebot criterion 0.5.0.7 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.0.7 (BryanOSullivan)
14:40:26 <monochrom> I wrote multi-precision division in x86 assembly. the algorithm is 3 nested loops, that is 3 counters. I quit writing x86 assembly ever since.
14:40:42 <uber_mor2> I'm trying to do some basic time tests on a haskell program I wrote. I'd like to avoid printing anything as that skews the numbers, but I am not sure if my computation is being evaluated or not when I don't print. Is there a way to ensure this? I'm using seq, is that enough?
14:41:07 <rwbarton> depends on what kind of thing you are computing
14:41:14 <rwbarton> like an int vs. a list
14:41:26 <uber_mor2> rwbarton: I have a basic queue class, I'm pushing ints onto the queue and then popping them back off
14:41:45 <uber_mor2> rwbarton: Its for a basic comparison between a haskell implementation and a c implementation for a class
14:42:12 <c_wraith> uber_mor2: look at the criterion library.  There seems to have just been a new release of it.
14:42:26 <monochrom> you likely should write a routine to step through the queue and seq every number
14:42:30 <rwbarton> uber_mor2: hmm.  It's probably best if your test case consumes the entire queue at the end, say by adding up all its elements.
14:42:33 <thoughtpolice> maurer_: ah, apparently I was slightly misinformed on the prior note about keeping dictionaries around, I was thinking of the work GHC did on pointer-tagging, making the STG not so tagless after all. my mistake
14:42:45 <maurer_> Ah, OK.
14:42:53 <c_wraith> thoughtpolice: is GHC is spineless?
14:43:13 <uber_mor2> rwbarton: But then I've got added time for the addition, I guess I could do the same addition in C to even it out
14:43:13 <thoughtpolice> i actually don't think so, no, but I forget what the 'spineless' referred to in the original paper
14:43:23 * thoughtpolice reads right fast
14:43:25 <c_wraith> ...  I never was clear what that spineless meant either.
14:43:32 <rwbarton> uber_mor2: You could use seq instead like monochrom suggested
14:43:39 <rwbarton> it's just a little tricky to tell whether you have got it right
14:43:50 <monochrom> seq every number and give back the last one
14:44:07 <uber_mor2> monochrom: not sure I follow
14:44:50 <Heffalump> uber_mor2: seq will be enough for the numbers. If you want to benchmark a whole series of operations where you just look at the final results and not the intermediate state of the queue, that should be fine.
14:45:03 <Heffalump> if the results are correct, then the queue must have done _something_
14:45:49 <uber_mor2> Heffalump: yes, I'm just concerned with the end speed, I don't need to benchmark individual functions or anything, just the total time to enqueue and dequeue n numbers
14:46:10 <monochrom> I'll do it with a list.  walk [] = 0; walk (x:xs) = seq x (walk xs).  I lied, I do not return the last number. But I still seq everything.
14:46:20 <pedro3005> is there a better way to write (\a b -> b : a) ?
14:46:41 <c_wraith> @pl (\a b -> b : a)
14:47:00 <c_wraith> ...  you know, we used to have this bot...
14:47:10 <c_wraith> That's flip (:)
14:47:16 <c_wraith> It's arguable whether that's better.
14:47:57 <monochrom> main = do { start <- get'time; xs <- construct'xs; stop <- seq (walk xs) get'time; now you have pretty good start time and stop time }
14:49:31 <thoughtpolice> c_wraith: so, I would look at the papers about the notions of 'spineless', but they cannot be found and/or behind ACM paywall. :(
14:50:00 <thoughtpolice> c_wraith: the original paper was by peyton jones titled 'the g-machine', followed by 'the spineless g-machine' and finally 'the spineless tagless g-machine' which we know and love today
14:50:27 <thoughtpolice> the abstract for the spineless g-machine paper is thus: "we introduce an optimised method of performing graph reduction, which does not need to build the spine of the express being reduced"
14:50:52 <thoughtpolice> "this spineless g-machine only updates shared expressions, and then only when they have been reduced to weak-head normal form. it is thus more efficient than the standard method of performing graph reduction"
14:51:31 <thoughtpolice> this info doesn't seem to really be highlighted in the STG paper - the STG paper was really the transformation it seems from the G-machine being an abstract assembly language, to actually instead being a small functional core language that can be efficiently compiled
14:52:04 <c_wraith> yeah, I read the STG paper.  Not the other two.
14:52:22 <uber_mor2> monochrom: thank you :)
14:52:44 <thoughtpolice> although I believe many have said that ghc is really no longer spineless (the context I am not sure, perhaps someone can elaborate) and since pointer tagging, it is no longer tagless either
14:53:13 <monochrom> spineful tagful g machine
14:53:31 <ddarius> spiteful nagful g machine
14:56:31 <ddarius> c_wraith: Cale can bring back MegaMonad if you like.  With almost ten years rather than merely a few, MegaMonad may be a useful contributor.
14:56:42 <Cale> what?
14:56:44 <Cale> I can?
14:56:50 <c_wraith> I'm quite confused now.
14:57:29 <ddarius> Cale: I thought MegaMonad was yours?
14:57:41 <monochrom> what is MegaMonad?
15:00:01 <c_wraith> What does any of that have to do with me?
15:00:08 <ddarius> Ah, it was CosmicRay's.
15:00:23 <ddarius> Whose actually here!
15:00:28 <Eduard_Munteanu> Something RWSSICME-like?
15:00:42 <Eduard_Munteanu> perhaps even a transformer variant
15:01:19 <Eduard_Munteanu> (that is, Reader + Writer + State + ST + IO + Cont + Maybe + Error + ...)
15:01:44 <c_wraith> ST and IO, together at last!
15:02:00 <monochrom> please add STM to the mix
15:02:00 <ddarius> @hackage STT
15:02:22 <Eduard_Munteanu> There was a STT somewhere.
15:02:23 <c_wraith> > 1
15:02:29 <c_wraith> yep, \bot's dead
15:02:35 <monochrom> @bots
15:04:37 * ddarius wish he knew what he knew.
15:06:29 <Heffalump> Eduard_Munteanu: it's broken on single-threaded underlying monads, though
15:07:30 <polm_> I'm doing something stupid with types.
15:07:33 <Heffalump> non-single-threaded, I mean
15:07:50 <polm_> totalprob r (h:t) = (totalprob r t) + log( ((mapcount r h) + 1) / ((length r) + (length $ nub r)))
15:08:07 <polm_> That won't run because the second argument to the first + is having its type inferred as Int.
15:08:13 <ddarius> Holy superfluous parentheses, Batman!
15:08:34 <polm> ddarius: Yes, they were because I thought I screwed something up.
15:09:37 <Saizan> ?type length
15:09:42 <c_wraith> polm: (/) doesn't work with Int, but length returns Int
15:09:55 <polm> Aaaah.
15:10:00 <monochrom> Batparentheses
15:10:13 <hpc> polm: to fix this, you want either div or fromIntegral
15:10:15 <hpc> :t div
15:10:17 <hpc> :t fromIntegral
15:10:23 <hpc> ...
15:10:23 <c_wraith> ...  still no bot, people :)
15:10:30 <hpc> div is division for integral types
15:10:39 <hpc> fromIntegral converts from an integral to a num
15:10:53 <c_wraith> given that there's a log in there, I'm pretty sure it's not intended to be an integer result
15:10:55 <polm> OK, looks like I want fromIntegral.
15:10:59 <polm> Good bet.
15:11:15 <monochrom> example. log (fromIntegral (length xs) + 4)
15:11:20 <rwbarton> also, you can write this function out of a map and a sum
15:11:37 <polm> Ah, right!
15:14:58 <mathijs> Hi all, I'm looking for something that does "IO a -> SomeStrangeID" and "SomeStrangeID -> IO a". I compile 1 binary, install it on multiple machines, the instances of the program start talking to each other and need to RPC. At the moment, every remotely-callable IO action is identified by some name, and I have a big "case" statement to map name -> action.
15:16:14 <mathijs> This is a lot of boilerplate, so I was hoping for a way to get a pointer (or ELF address or something) that identifies the function in the binary. 
15:16:34 <rwbarton> can you use something like a Map String (IO a)?
15:16:46 <rwbarton> might be tricky if 'a' varies
15:18:14 <mathijs> rwbarton: yeah that's a bit like my case statement at the momet. I'm not looking for a map structure, I want to get rid of the naming altogether. Since everything runs in a trusted environment, I don't mind every function to become callable.
15:19:07 <rwbarton> oh
15:19:22 <rwbarton> basically you want to serialize the IO action automatically
15:19:35 <rwbarton> which you ought to be able to do because there's a matching IO action on the receiver?
15:19:56 <mathijs> indeed, the receiver is exactly the same code
15:20:08 <aavogt> can other people ssh to code.haskell.org?
15:20:19 <Saizan> that seems to fall under the realm of eden
15:20:45 <aavogt> hmm, http doesn't work for there either
15:20:58 <mathijs> So I don't need to serialize the IO action (because that's already known at the receiver's side), I just need some pointer/address that the receiver will know to map to the real action again
15:21:05 <Saizan> or maybe not
15:21:25 <Saizan> aavogt: i can't
15:21:44 <mathijs> rwbarton: but serializing the whole action sounds cool too, but I don't think that's possible
15:21:44 <Eduard_Munteanu> I can't either (no login prompt, I don't have an account)
15:22:24 <Eduard_Munteanu> mathijs: as far as I remember somebody else asking, function serialization isn't done yet.
15:23:51 <mathijs> Eduard_Munteanu: nope, thought so. But that's not really what I'm after. I just want to get some pointer address to the function. In that case, if I run the same binary on a different machine, serializing the pointer, deserializing on the other and, needs to resolve to the same function.
15:24:56 <Eduard_Munteanu> Might be doable going through C code.
15:25:08 <mathijs> the nice thing is that all those remotely-called functions are IO a (or even IO ()). so they don't need to get any input (input is handled via sockets, those IO actions setup a socket and begin executing)
15:25:10 <Eduard_Munteanu> But it's probably not what you want.
15:26:32 <mathijs> Eduard_Munteanu: yeah, I was afraid of that. But I know I'm crossing some logic-line here. Because those addresses are not known at compile time, probably only linktime. I thought maybe the RTS might still be able to do something like it
15:26:58 <kafee> people, I've the task to analyse a piece of text and determine what kind of feelings it express. Could you point me to resource?
15:27:09 <monochrom> http://code.haskell.org is not responding to me either
15:27:39 <Saizan> mathijs: there's addrToHValue# there might be the inverse too
15:28:27 <Saizan> could be unpackClosure#
15:28:27 <mathijs> Saizan: that sounds a bit like it indeed.
15:28:52 <Saizan> no idea how well that'd work between different processes
15:29:18 <mathijs> can't find those on hoogle. what package are they in?
15:29:21 <Saizan> in GHC.Prim
15:29:51 <_man> mathijs: sorry to interrupt, but: why not use a map in each side, and send the (just the) key to the correct IO action over the network?
15:30:03 <mathijs> can those be imported in normal source code?
15:30:13 <Saizan> yes
15:30:25 <Saizan> you need {-# LANGUAGE MagicHash #-}
15:30:40 <mathijs> _man: that's what I'm doing now. it works, but it's tedious. Every time I add a function, I have to change the map (I'm using a big case statement now)
15:30:57 <_man> mathijs: I understand.
15:31:11 <mathijs> Saizan: thanks, I'll have a look at that
15:31:14 <shlevy> Is there any chance of being able to end a comma separated list (tuples, lists, etc.) with a comma in future versions of Haskell/with the right pragma?
15:31:41 <shlevy> Or start it with one, really.
15:31:42 <aavogt> shlevy: you can already do that with export lists!
15:32:16 <monochrom> do { ; x ; y ; return () ; }  also works
15:32:37 <aavogt> somewhat related is the -XTupleSections extension, which gives a better use for those excess commas
15:32:49 <monochrom> but yeah, I would love [,0,1,] and (,0,'x',) too
15:32:58 <shlevy> aavogt: Sweet! That's part of my goal
15:33:21 <shlevy> monochrom: Will that work in tuples, lists, etc.?
15:33:26 <monochrom> not yet
15:33:32 <aavogt> monochrom: as abbreviations for \x y -> [x,0,1,y] ?
15:33:54 <aavogt>  -XListSections doesn't exist
15:34:10 <tawe> > filterM (return [True, False]) [1,2,3]
15:34:16 <monochrom> I would also love [ f z | , x<-xs, y<-g x, y<0, z<-h y , ]
15:34:35 <monochrom> no, [,0,1,] is abbreviation for [0,1]
15:34:41 <tawe> > 1
15:34:56 <aavogt> monochrom: what's the benefit?
15:36:16 <monochrom> a left-endian would write [ newline ,0 newline ,1 newline ]. adding and removing items does not require fixing up commas. every item is written ,i
15:36:47 <monochrom> a right-endian would write [ newline 0, newline 1, newline ]. adding and removing items does not require fixing up commas. every item is written i,
15:36:54 <shlevy> monochrom: Exactly the application I want
15:37:17 <monochrom> consistent syntax is consistent
15:37:52 <shlevy> monochrom: Currently a left-endian because I only need to fix commas when adding to the top, but I'd probably prefer right-endian otherwise
15:39:03 <shlevy> monochrom: Hmm, how would that mesh with TupleSections?
15:39:32 <shlevy> monochrom: perhaps require two commas for a tuple section at the beginning or end?
15:39:37 <monochrom> would mesh disastrously
15:41:20 <shlevy> For functions on datatypes defined with record syntax, is there any reason to prefer pattern-matching over the auto-generated functions, or vice versa?
15:41:58 <xplat> yeah, itś mesh like fingers and shears
15:42:02 <xplat> it'd
15:43:31 <xplat> shlevy: if you need to match deeply, you probably want pattern matching
15:44:35 <xplat> otoh, if you have a single-constructor type, it's probably better to use the functions
15:44:45 <xplat> (in most cases)
15:45:35 <xplat> in, between, well, as they say, go with your heart
15:45:41 <shlevy> xplat: Any reason why?
15:53:01 <xplat> shlevy: when a function and a pattern match involve equal amounts of raw syntax, a function is usually easier to work with
15:53:24 <xplat> because functions are first class, pattern matches are not
15:53:30 <shlevy> xplat: Ah, alright. Thanks
15:54:09 <mathijs> Saizan: I'm trying out unpackClosure# but I'm new to the scary hash. I didn't know there was a # kind.  Can you tell me how to get x to some "normal" value in my example http://hpaste.org/44406/addr ?
15:55:06 <xplat> @kind (->)
15:55:13 <xplat> ... still gone :(
15:55:27 <kamaji> Is there something like "mapUntil"?
15:55:35 <mathijs> I just need to check if the output is the same between runs (and on different machines). If it is, I know this is probably the way to go and I will need to learn more about the # stuff
15:56:30 <Eduard_Munteanu> kamaji: map f . takeWhile cond ?
15:57:06 <Eduard_Munteanu> Or do you need something monadic?
15:57:27 <conal> is there a handy function that finds an occurrence of a list within another? like isSuffixOf but says where when found?
15:57:40 <Saizan> mathijs: it's not an instance of Show anyway
15:58:02 <mathijs> Saizan: so not serializable either probably?
15:58:10 <xplat> kamaji: that depends.  what does "mapUntil" do?
15:58:12 <djahandarie> conal, you mean like isInfixOf?
15:58:14 <kamaji> Eduard_Munteanu: I guess I need more like "take first of"
15:58:42 <conal> djahandarie: oh yeah. i mean like isInfixOf, not isSuffixOf.
15:58:46 <Eduard_Munteanu> head . filter cond ?
15:58:51 <conal> djahandarie: but telling where.
15:58:56 <rwbarton> mathijs: you're probably best off putting all the functions that can be called in a module and using TH to generate the map you're currently using
15:59:21 <mathijs> Saizan: but anyway, I found http://ghcmutterings.wordpress.com/2009/02/12/53 talking about it a bit. A commenter mentions that GC tends to change the addresses of objects. So it becomes a bit more difficult and slippery for my taste.
15:59:30 <conal> otherwise, i guess i'll use tails, isPrefixOf, and findIndex
15:59:40 <kamaji> Eduard_Munteanu: oh yeah, looks like that can work, hehe
15:59:42 <kamaji> thanks
15:59:54 <xplat> mathijs: you could create stable pointers
15:59:56 <Eduard_Munteanu> Note 'head' will fail if 'filter' returns []
16:00:02 <mathijs> rwbarton: that sounds reasonable. 
16:00:11 <xplat> mathijs: but they probably wouldn't be the same on both sides
16:00:22 <conal> hoping for something more elegant. and more efficient as a bonus.
16:00:23 <mathijs> xplat: really? that's what I'm after.
16:00:36 <mathijs> xplat: not if I use the same binary?
16:00:37 <kamaji> Eduard_Munteanu: oh ok. How do you deal with that?
16:01:11 <Saizan> mathijs: http://hpaste.org/paste/44406/addr_annotation#p44407
16:01:24 <mathijs> Saizan: I'll have a look, thanks!
16:01:31 <xplat> mathijs: stable pointers get created at runtime afaik.  which means you might get by, but it would be incredibly fragile, AND you would have to loop through all the functions you want which is about as bad as making a map
16:01:38 <Eduard_Munteanu> kamaji: you can break the 'head' functionality into another function that handles failure as you like.
16:01:46 <Eduard_Munteanu> It depends on what you really want.
16:01:50 <Saizan> mathijs: well, for statically built functions you shouldn't have to worry about the GC
16:01:54 <djahandarie> conal, isInfixOf is implemented with isPrefixOf and tails itself
16:02:03 <Saizan> mathijs: only runtime generated closures live on the heap
16:02:13 <djahandarie> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
16:02:43 <conal> djahandarie: oh, sure.
16:02:43 <mathijs> Saizan: so this might be safe?
16:03:10 <Saizan> mathijs: yes, though very implementation specific
16:03:13 <conal> djahandarie: could be made more efficient (though wouldn't help me here).
16:04:00 <Eduard_Munteanu> Guys, isn't there a standard ABI and mangling convention for Haskell stuff?
16:04:10 <Eduard_Munteanu> If so, something like dlopen() would do.
16:04:26 <Saizan> heh
16:04:28 <mathijs> Saizan: Yeah, thought so. but probably OK for some testing. I like the TH suggestion as well, which sounds more long-term.
16:05:05 <Saizan> mathijs: ah, i was going to suggest some kind of preprocessor myself
16:05:06 <copumpkin> Eduard_Munteanu: no, not really
16:05:11 <copumpkin> Eduard_Munteanu: use foreign export
16:05:42 <Eduard_Munteanu> Hrm, so that might help mathijs.
16:05:59 <Eduard_Munteanu> even if ghc-specific
16:06:39 <mathijs> Saizan: rwbarton suggested it. It sounds a bit more steady indeed, but since I've never tried TH yet, a quick-and-dirty solution might temporarily be OK as well.
16:06:39 <copumpkin> preflex: seen kmc
16:06:39 <preflex>  kmc was last seen on #haskell-blah 3 days, 17 hours, 42 minutes and 14 seconds ago, saying: (to the extent classes even exist in JavaScript)
16:07:06 <copumpkin> @tell kmc people asking on reddit about haskell/GHC on android. Seems like you might have something to say about that
16:07:35 <Saizan> mathijs: it seems addrToHValue# doesn't like the first output of unpackClosure# though :)
16:07:59 <Saizan> maybe x is the pointer to the info table there
16:08:14 <mathijs> Eduard_Munteanu: didn't catch that. are you talking about dynamically loading a shared object lib or something?
16:08:22 <Saizan> copumpkin: do you know if there's a primop to get the Addr# of a value?
16:08:36 <hpc> @hoogle a -> Addr#
16:08:41 <hpc> :(
16:08:49 <Eduard_Munteanu> mathijs: yes, in C you can obtain a similar reflection capability using dlopen() (POSIX)
16:09:03 <Eduard_Munteanu> dlopen() and dlsym() that is
16:09:16 <shlevy> How do you get the integral part of a Num/Real?
16:09:27 <Eduard_Munteanu> There are ways to do it in Windows too I suppose.
16:09:58 <Eduard_Munteanu> @hoogle floor
16:10:25 <mathijs> Eduard_Munteanu: yeah I think I've read about dlopen a few times. But does that mean I need to compile my code as a shared library, and export the functions I'm after?
16:10:45 <Eduard_Munteanu> No, IIRC it just works to dlopen an executable.
16:10:48 <Eduard_Munteanu> i.e. itself
16:10:57 <mathijs> ah
16:11:20 <kniu> I've been trying to use Control.Parallel.Strategies
16:11:42 <kniu> I got this list of pretty hefty ray tracing calculations to do,
16:11:45 <shlevy> Eduard_Munteanu if my type is Real and Fractional will I have to manually make it an instance of RealFrac?
16:12:06 <kniu> so I did a (parList rseq list)
16:12:09 <shlevy> Eduard_Munteanu: Never mind, found the RealFrac instance
16:12:23 <copumpkin> Saizan: don't think so, although I have no idea why there's one going the other way
16:12:28 <kniu> thing is, it uses up both my cores for the first 10 seconds or so,
16:12:51 <copumpkin> Addr# is "An arbitrary machine address assumed to point outside the garbage-collected heap."
16:12:51 <kniu> but afterwards, CPU thrashing happens and utilization drops heavily.
16:13:18 * shlevy notes to self: If you know the mathematical function name, you probably know the Haskell function name
16:13:31 <kniu> Same things happened when I tried parListChunk 2 instead.
16:13:45 <Eduard_Munteanu> kniu: thrashing? Are you sure there isn't something memory-related? It might be worth to run with '+RTS -s' and see
16:14:24 <kniu> Eduard_Munteanu, the computations are all independent, so I don't see how it could be a memory problem.
16:14:55 <kniu> By "thrashing" I mean that when looking at my CPU monitor,
16:15:08 <kniu> one core goes to 100% for a second or so,
16:15:26 <kniu> then it drops to 0% while the other core goes to 100%.
16:15:41 <kniu> the cores aren't being used in parallel like they're supposed to.
16:15:58 <blackdog> kniu: isn't thrashing where you're continually paging in memory?
16:16:05 <kniu> I misused the term.
16:16:10 <kniu> Disregard that.
16:16:13 <monochrom> rebindable "thrashing"
16:16:26 * monochrom dreams of rebindable function application!
16:16:53 <kniu> My question is just
16:17:00 <Eduard_Munteanu> I think jmcarthur experimented with something like that, but I don't remember the details.
16:17:18 <kniu> if I have a list of values that all require hefty computation to get, what's the best way to parallelize them?
16:18:15 <monochrom> parListN or partListChunk
16:18:25 <mathijs> Saizan, Eduard_Munteanu, rwbarton: thanks for the advice. I will probably look at TH for my problem. it's a pity rfork() never got popular.
16:18:26 <Eduard_Munteanu> s/part/par/ ?
16:18:29 <kniu> Tried it, same problem.
16:18:45 <monochrom> yeah, s/part/par/
16:19:02 <monochrom> do you have +RTS -N 2 ?
16:19:05 <kniu> yes
16:19:15 <monochrom> alright, I admit the end of my knowledge
16:20:10 <kniu> You know that old joke about trying to get help in #linux?
16:20:23 <kniu> Don't ask the question. Just state that it's impossible to do X in Linux.
16:20:29 <kniu> So here's where I go:
16:20:39 <kniu> I GUESS HASKELL'S NOT GOOD FOR PARALLEL AFTER ALL
16:20:41 <blackdog> kniu: careful, you might summon dons
16:20:46 <monochrom> won't work here
16:21:01 <rwbarton> kniu: how long does the one-processor computation last
16:21:08 <kniu> 130 seconds or so.
16:21:11 <monochrom> my knowledge is exhausted so no provocation will magically create knowledge
16:21:19 <kniu> Attempting to parallelize it drives it up to 160 seconds.
16:21:33 <Eduard_Munteanu> Not if you're not looking in the mirror while chanting the name!
16:21:35 <rwbarton> oh, I meant how long does the part of the computation that's only using one processor last
16:21:39 <rwbarton> but I guess ~120 seconds
16:22:43 <uber_mor2> monochrom: Sorry to bug ya again. I used the walk function you suggested earlier which seqs every number in my list. I'm getting similar run times to those that I was getting before, I don't think that the walk is actually working :(
16:23:04 <monochrom> that also exhausts my knowledge
16:23:26 <ddarius> monochrom's knowledge has had a long day.
16:23:30 <mathijs> kniu: the grain size might be too small. my first parallel attempt did that too, I processed a list and par mapped over the elements. but since the map function was very fast to complete, scheduling to other cores just created an overhead. I switched to some strategy that sent 1000 items to 1 core to map over, next 1000 to another... and so on. that made it quicker than the 1-core result
16:24:33 <kniu> oh my
16:24:36 <kniu> I might have done it.
16:25:03 <kniu> parListChunk (length l / 2) rdeepseq l
16:25:08 <Eduard_Munteanu> Summoned dons? :P
16:25:16 <kniu> No, achieved 200% utilization.
16:25:52 <kniu> But it's rather distasteful that I had to tailor this specifically for two cores.
16:26:09 <monochrom> I guess the #linux old joke is true after all, except for a different reason.
16:26:38 <kniu> what if I want to run this on a 8 core machine?
16:26:47 <rwbarton> how long is the list?
16:26:58 <kniu> 102400
16:27:01 <Eduard_Munteanu> Like in most cases, it's machine-specific.
16:27:03 <kniu> 320 x 320 image.
16:27:08 <rwbarton> you can probably just do parListChunk 100 then
16:27:10 <Eduard_Munteanu> So you do have to know how many cores the machine has.
16:27:19 <rwbarton> er, parListChunk (length l / 100)
16:27:25 <mathijs> kniu: you can find the number of cores at runtime and use that if you want, but it's not very nice indeed
16:27:34 <kniu> 100 seems kind of "magic".
16:27:39 <rwbarton> not really
16:27:44 <Eduard_Munteanu> Just figure it out at runtime
16:27:49 <Eduard_Munteanu> Or ask the user.
16:27:50 <rwbarton> try it
16:27:57 <kniu> k.
16:28:05 <Eduard_Munteanu> e.g. like make -jN
16:28:16 <kniu> Eduard_Munteanu, what's that do?
16:28:19 <monochrom> GHC.Conc.numCapabilities tells you how many cores you get to use
16:28:33 <Eduard_Munteanu> kniu: no, it's just an example where the user supplies how many threads he wants.
16:28:37 <kniu> h
16:28:40 <kniu> oh
16:28:50 <kamaji> How can I check if a list is not empty without evaluating the full list?
16:28:54 <btutt> You could always try to dynamically size it based on the estimated cost of running say 10 of them or something....
16:29:13 <Eduard_Munteanu> kamaji: 'null'?
16:29:16 <Eduard_Munteanu> :t null
16:29:20 <kniu> @hoogle numCapabilities
16:29:31 <Eduard_Munteanu> @vixen Come back!
16:29:43 <kniu> numCapabilities :: Int
16:29:43 <kniu> the value passed to the +RTS -N flag. This is the number of Haskell threads that can run truly simultaneously at any given time, and is typically set to the number of physical CPU cores on the machine.
16:29:44 <btutt> i.e. dynamically size the transition point to winning the overhead battle based on some heurtisitc knowledge of the work item type (or something)
16:29:50 <kamaji> Eduard_Munteanu: cheers
16:29:59 <monochrom> GHC.Conc.numCapabilities :: Int
16:30:09 * shlevy thinks it's probably a bad sign if you keep switching $ and . until the function typechecks
16:30:11 <kniu> oh god what the hell
16:30:18 <monochrom> a bit scary that it is not IO Int :)
16:30:32 <Eduard_Munteanu> kamaji: well, it's merely checking if it's [].
16:30:33 <kniu> 200% utilization gave me 510 seconds of computation
16:30:38 <ben> @check (.) == ($)
16:30:42 <kniu> It got slower.
16:30:52 <ben> Whe-where
16:30:56 <jmcarthur> monochrom: i have a preprocessor for overloading function application
16:30:59 <Eduard_Munteanu> kamaji: you don't need anything special to avoid going through the whole list
16:31:09 <jmcarthur> Eduard_Munteanu: is that what you were referring to? ^^
16:31:14 <Eduard_Munteanu> Yes.
16:31:18 <kamaji> Eduard_Munteanu: but surely it needs to evaluate the whole list before it knows it's equal to []?
16:31:23 <kamaji> oh
16:31:26 <kamaji> unless it has an element
16:31:27 <kamaji> herp derp :\
16:31:42 <shlevy> ^ "Am I dead?"
16:31:46 <jmcarthur> i also had a type class for it
16:31:53 <monochrom> not (null (undefined : undefined))  works just fine
16:32:05 <Eduard_Munteanu> kamaji: yes, think in terms of proofs. In order to prove a list is non-empty, all you need to provide is an element of that list.
16:32:05 <kamaji> shlevy: Apparently my brain is at least
16:32:28 <shlevy> ben: Are they different except for precedence?
16:32:33 <shlevy> ben: erm, the same?
16:33:25 <shlevy> ben: Their types are different but I can't quite figure out when to use which
16:33:35 <kamaji> Is it a good idea to use Just/Nothing?
16:34:06 * shlevy wonders how you recussitate LambdaBot
16:34:12 <Eduard_Munteanu> monochrom: why? It's already known after the RTS starts, in most cases. I suppose it'd break CPU hotplug though.
16:34:26 <Eduard_Munteanu> (yeah, I just answered my "why" :)) 
16:34:55 <Eduard_Munteanu> kamaji: depends what for.
16:36:00 <kamaji> Eduard_Munteanu: well at the moment i'm either returning a list of 1 item or an empty list
16:36:12 <kamaji> but I don't really understand Just/Nothing
16:36:14 <Eduard_Munteanu> kamaji: ah, then it's a good idea.
16:36:30 <kamaji> also, I can't load haskell.org :_
16:36:32 <ben> shlevy: no, i am just confusing myself now
16:36:40 <Eduard_Munteanu> @where isitdown
16:36:44 <Eduard_Munteanu> Duh.
16:37:01 <Eduard_Munteanu> kamaji: what is it you don't understand?
16:37:20 <monochrom> http://downforeveryoneorjustme.com/
16:37:35 <monochrom> but haskell.org works for me
16:37:47 <Eduard_Munteanu> Hrm, it works for me too.
16:38:41 <kamaji> huh, I wonder what's going on
16:39:43 <kamaji> I don't really get how to extract the type 
16:39:57 <kamaji> if it's "Just Integer" does that mean I can't use it elsewhere?
16:40:15 <kleinucopia> I am trying to use Text.HTML.TagSoup with Network.Curl.Download and have some kind of version mismatch.
16:40:17 <Eduard_Munteanu> kamaji: you can't use it directly, no.
16:40:25 <monochrom> "Just Integer" is not a type. "Maybe Integer" is a type. "Just 3" is a value of that type.
16:40:33 <Eduard_Munteanu> kamaji: just like you can't use a list instead of an Integer.
16:40:50 <kleinucopia> Network.Curl.Download is using TagSoup-0.10.1 and I am using TagSoup 0.12
16:40:58 <Eduard_Munteanu> data Maybe a = Nothing | Just a
16:41:10 <kleinucopia> is there something I can tell cabal to make it force Curl.Download to use the correct version?
16:42:16 <dcoutts__> kleinucopia: --constraint=TagSoup==0.12
16:43:08 <dcoutts_> kleinucopia: of course that will not help if curl really does require the earlier version
16:43:19 <kleinucopia> which apparently it does.
16:43:42 <btutt> I started off using Network.Curl.Download but ended up just using Network.Curl with TagSoup
16:44:20 <shlevy> As a followup to an earlier question (can't remember who answered it): If I have a binding like this
16:44:26 <shlevy> eventStart@ZonedTime{ zonedTimeZone = TimeZone{ timeZoneName = zoneName } }
16:44:36 <monochrom> tagsoup (≥0.8 & <0.11) heh
16:44:39 <shlevy> I probably shouldn't try to convert it to using the record syntax functions, right?
16:44:40 <xplat> what module is Mu in again?
16:45:53 <shlevy> Actually, that's a deep pattern-match but there's only one path. Hmmm
16:46:35 <monochrom> I think that pattern is fine
16:47:03 <comex> so copumpkin
16:47:10 <copumpkin> greetings comex
16:47:12 * comex likes picking on you
16:47:19 <copumpkin> I've noticed :o
16:47:26 <hpaste> shlevy pasted "Deep Pattern"  http://hpaste.org/44408
16:47:33 <shlevy> Oh, actually the pattern is even deeper
16:47:36 <comex> now projects.haskell.org is down, as opposed to just empty
16:47:54 <monochrom> it's up to you. if you go for short code, timeZoneName (zonedTimeZone eventStart) is shorter.
16:47:55 <kamaji> if I want to filter out Nothings from a list, is there a function like a "not" for Maybe types?
16:48:12 <kamaji> or should I just do (\x -> x != Nothing)
16:48:21 <comex> isNothing
16:48:22 <copumpkin> comex: yeah, not sure what the status is on those servers
16:48:22 <copumpkin> kamaji: catMaybes
16:48:32 <copumpkin> or [x | Just x <- xs]
16:48:45 <kamaji> I mean \=
16:48:48 <siracusa> xplat: Generics.Pointless.Functors of package pointless-haskell
16:48:55 <kamaji> copumpkin: oh cheers
16:48:59 <monochrom> don't use /= so readily
16:49:08 <kamaji> monochrom: really? what's wrong with it?
16:49:15 <comex> what's wrong with it is that it's not !=
16:49:19 <monochrom> requires dubious Eq instance
16:49:28 <monochrom> or rather, requires Eq instance dubiously
16:49:37 * shlevy loves that there's a package called pointless-haskell
16:49:42 <copumpkin> if you're just asking about the structure of a type in a way that doesn't care about elements
16:49:45 <copumpkin> avoid /= or ==
16:49:57 <Maxdamantus> > (False < True) <= True
16:49:57 <comex> copumpkin: so I still don't have a way to indent code properly
16:49:57 <kleinucopia> btutt: I'm not so good with using all these monads together at once, but I'm trying.
16:50:21 <heatsink> comex: I would suggest emacs
16:50:31 <btutt> I understand. I switched over so I could more easily access Curl option setting stuff
16:50:38 <comex> heatsink: I don't like Haskell enough to learn a new editor for it.
16:50:40 * shlevy whispers *vim* under his breath
16:50:50 * comex uses vim
16:51:04 <kamaji> monochrom: I don't really follow tbh, but i'll take your advice :D
16:51:05 <Eduard_Munteanu> Vim is alright too
16:51:06 <monochrom> vim works fine although I only know this from hearsay here
16:51:12 <copumpkin> comex: I dunno, indentation doesn't seem like that big a deal
16:51:17 <heatsink> Does vi have a haskell indent mode?
16:51:29 <comex> no; and I don't know whether http://projects.haskell.org/haskellmode-vim/ has what I want, but it's not accessible
16:51:39 <Eduard_Munteanu> Dunno, I do my indentation just like in any other language.
16:51:49 <Eduard_Munteanu> (I mean with Vim)
16:51:49 <copumpkin> comex: dcoutts might know
16:51:52 <copumpkin> but he's probably asleep
16:52:00 <dcoutts_> @arr!
16:52:07 * dcoutts_ should be asleep
16:52:16 * hackagebot TrieMap 4.0.1 - Automatic type inference of generalized tries with Template Haskell.  http://hackage.haskell.org/package/TrieMap-4.0.1 (LouisWasserman)
16:52:34 <copumpkin> dcoutts_: oh no!
16:52:41 <copumpkin> dcoutts_: any word on projects.haskell.org?
16:52:41 <Eduard_Munteanu> You've awakened him!
16:53:00 <monochrom> expect some manual indentation for haskell no matter which editor you use. because several different indentations are valid and just differ in your intention.
16:53:35 <ddarius> monochrom: If your editor is a human, you won't need to manually indent.
16:53:36 <monochrom> the only advanced technology that can automate haskell indentation is to replace the human programmer altogether.
16:53:51 <dcoutts_> copumpkin: server appears inaccessible or under heavy load, can't ssh in
16:53:56 <Eduard_Munteanu> ddarius: except if his idea of an indentation is different.
16:54:03 <dcoutts_> physical host is ok, just the VM
16:54:13 <copumpkin> dcoutts_: ah, so it isn't part of the c.h.o move?
16:54:18 <comex> I guess http://code.google.com/p/sean-leather/source/browse/homedir/vimfiles/vimballs/haskellmode-20090410.vba?r=35
16:54:18 <copumpkin> or what?
16:54:20 <comex> is an older version of it
16:54:43 <comex> oh, look, http://code.google.com/p/sean-leather/source/browse/homedir/vimfiles/indent/haskell.vim
16:54:46 <xplat> siracusa++
16:54:58 <dcoutts_> copumpkin: projects.h.o is the same VM as code, planet, rt, community
16:55:03 <copumpkin> ah okay
16:55:05 <copumpkin> hmm
16:55:32 <Eduard_Munteanu> xplat: is Mu actually defined in any basic GHC/platform packages? oO
16:55:41 <copumpkin> no
16:55:44 <Eduard_Munteanu> I've seen variants of it in category-extras and such.
16:55:53 <Eduard_Munteanu> I mostly define it myself.
16:55:59 <monochrom> Mu is not in basic or platform packages
16:57:33 <monochrom> my vapourware Prelude.Twitter has found a sequel! Prelude.Twitter.Types - every data type definable in 140 words or less!
16:58:46 <copumpkin> yet you don't have a twitter account!
16:58:49 <copumpkin> for shame!
16:59:05 <xplat> hm, i thought there was a simpler version of Mu, although this one is kind of nice too
16:59:10 <copumpkin> Moo
16:59:18 <monochrom> I'm using lazy I/O to open my twitter account
16:59:32 * heatsink has a question about http://hackage.haskell.org/packages/archive/lattices/1.2.1/doc/html/Algebra-Lattice.html#g:2
16:59:38 * copumpkin forces monochrom's twitter account
17:00:01 <copumpkin> heatsink: yes?
17:00:03 <heatsink> According to the package, a BoundedJoinSemiLattice has a bottom element such that forall x. x `join` bottom == x
17:00:19 <heatsink> Acutally that part's fine
17:00:28 <heatsink> It says that join approaches bottom
17:00:49 <xplat> no, meet approaches bottom
17:00:52 <heatsink> But according to wikipedia, join x y is the least upper bound of x and y, which means that join approaches top
17:00:54 <xplat> join flees bottom
17:01:07 <copumpkin> heatsink: probably just a typo
17:01:07 <Eduard_Munteanu> I always confuse join/meet, I should find a mnemonic :/
17:01:17 <copumpkin> I don't like those names
17:01:21 <xplat> if join approached bottom, then x `join` bottom == bottom
17:01:30 <Eduard_Munteanu> sup/inf is better, IMHO
17:01:43 <xplat> yeah, i hate those names too
17:01:44 <monochrom> foldl join ? [] = ?   solve for the question mark. answer: bottom.  this is why you want bottom when you have join.
17:02:16 <Eduard_Munteanu> Well, /\ and \/ if I don't need to pronounce it.
17:02:19 <monochrom> see also my http://www.vex.net/~trebla/homework/empty.html
17:02:26 <xplat> monochrome: anything would solve that equation
17:02:36 <Eduard_Munteanu> (though those are kinda backwards too, somehow)
17:02:50 <djahandarie> monochrom, I used that notation and confused my teacher by accident :P
17:02:52 <xplat> monochrom: you want foldl ? [x] = ? for all x
17:02:57 <xplat> er, == x
17:03:19 <monochrom> well, with the constraint of foldl join ? (xs++ys) = foldl join ? xs `join` foldl join ? ys
17:03:26 <heatsink> Also, I've never heard 'flee' used in a mathematical context before
17:03:30 <monochrom> perhaps should have used that equation instead
17:03:43 <djahandarie> I also used x : \mathbb{N}, making things more confusing
17:03:48 <djahandarie> (Not actually latex)
17:03:59 <hpaste> Bill pasted "Network.Curl/TagSoup example"  http://hpaste.org/44410
17:04:01 <heatsink> If it's just a typo in the description, then I'm satisfied.
17:04:42 <monochrom> bottoms want to be free
17:05:05 <ddarius> Eduard_Munteanu: "meet" suggests intersection, and "join" suggests union.
17:05:27 <Eduard_Munteanu> Ah, thanks, that's workable.
17:06:17 <Eduard_Munteanu> For \/ and /\ I just think they're backwards or they look like a text selection cursor >---< (at 90 deg)
17:06:47 <Eduard_Munteanu> (since \/ is the *upper* bound)
17:06:57 <copumpkin> To go downstairs and get corn nuts or not to go downstairs and get corn nuts: that is the question
17:07:07 * monochrom (trebla@toronto-hs-216-138-220-146.s-ip.magma.ca) has met #haskell
17:07:20 <ddarius> (In fact, in projective geometry, meet is intersection and join union (of sorts.))
17:07:23 <Eduard_Munteanu> Heh.
17:07:34 <ddarius> copumpkin: Why do you want corn nuts?
17:07:43 <copumpkin> ddarius: greed/craving
17:07:44 <kamaji> thanks for all the help everyone
17:07:49 <xplat> how does 'meet' suggest intersection?
17:08:01 <kamaji> one more problem from project euler done :D
17:08:05 <Eduard_Munteanu> @bot
17:08:21 * hackagebot JSONb 1.0.3 - JSON parser that uses byte strings.  http://hackage.haskell.org/package/JSONb-1.0.3 (JasonDusek)
17:08:22 <monochrom> "find out where this sphere meets this plane" = find intersection
17:08:25 <Eduard_Munteanu> xplat: you run across somebody!
17:08:34 <copumpkin> comex: so why so much haskell these days?
17:08:39 <copumpkin> comex: getting tired of go?
17:08:48 <monochrom> you run across somebody. the two of you kiss. that's where the two of you meet.
17:08:49 <xplat> mmnn, mnemonics
17:08:58 <comex> let's just say I like pattern matching.
17:09:22 <copumpkin> comex: when GHC 7.0.2 is released I'm gonna resume work on the libopcodes binding and other related stuff. Got put off by the 32-bit-only GHC on mac os
17:09:29 <copumpkin> which is changing in a few days I hope
17:09:30 <xplat> if you need mnemonics to remember the name, you have failed at naming
17:09:46 <copumpkin> or as some people pronounce it, pneumonics ;)
17:09:49 <monochrom> and then you play http://www.hynam.org/HY/kis.html
17:09:53 <comex> cool, but it shouldn't be hard to compile libopcodes as universal
17:10:08 <xplat> noe that they're a bad way to deal with the mess that is lattice theory today
17:10:11 <btutt> copumpkin: Have this burning desire to use 64bit worth of machine memory on your mac?
17:10:14 <xplat> *not
17:10:14 <copumpkin> comex: it was more of a pain than I expected it to be
17:10:21 <monochrom> I like pattern-matching too. can't stand the scheme way.
17:10:30 <copumpkin> btutt: no, just to link to 64-bit libraries, which is the default compilation mode these days
17:10:39 <xplat> i am drawing a blank on what i'm doing wrong here
17:10:52 <xplat> let kmp w = wt where { wt = w `zip` map InF t; t = wt:wt:(foldl' (\a b -> if (fst . head $ a) == b then tail a else wt) wt $ tail w) }
17:11:07 <copumpkin> comex: so I got frustrated and moved to less machine-aware pursuits :)
17:11:33 <btutt> It should't be. 32 bit code is faster than 64bit apps. That's why those silly people are doing the x32 ABI on 64bit OSs. 32 bit pointers but amd64 register set
17:11:46 <btutt> (as long as you don't need 64bits worth of memory)
17:11:53 <comex> x32 ABI?
17:11:57 <copumpkin> you get way more registers
17:11:59 <comex> the one that uses the stack for function arguments?
17:12:19 <Eduard_Munteanu> Register pressure is quite important in x86-32 code.
17:12:34 <comex> binutils has no variants
17:12:35 <comex> yuck
17:12:38 <btutt> copumpkin: but the extra pointer width eats through CPU caches....
17:12:40 <copumpkin> comex: :P
17:12:48 <copumpkin> btutt: assuming you work with lots of pointers
17:12:58 <copumpkin> which is true in haskell :)
17:13:05 <copumpkin> but not necessarily in other code (which is what we were talking about)
17:13:10 <polm> If I'm running code from ghci, how do I pipe a file to stdin?
17:13:15 <btutt> x32: amd64 register set, but 32 bit wide pointers
17:13:24 <ddarius> xplat: Just use category theory instead.  Then meet and join are product and coproduct.
17:13:25 <copumpkin> either way, it's the way it is
17:13:32 <copumpkin> and I want to link with it
17:13:47 <btutt> copumpkin: Ah.
17:14:21 <btutt> x32 abi: https://sites.google.com/site/x32abi/
17:14:26 <btutt> its still a work in progress
17:14:30 <xplat> ddarius: i actually find that easier to remember
17:14:38 <btutt> HJ Lu is working on it for Intel
17:15:35 <ddarius> xplat: So do I (though at this point I have meet and join fixed in my head.)
17:16:39 <ion> polm: Do you mean read from stdin and write that to a file?
17:17:01 <polm> No, just how to redirect stdin from a file at the ghci prompt 
17:17:19 <Eduard_Munteanu> btutt: that's probably going to be a bit messy since a few basic instructions don't take 32-bit operands in long mode
17:17:30 <Eduard_Munteanu> Plus I'm not sure it's worth it.
17:17:30 <ddarius> monochrom: That's simultaneously awesome and insane.
17:18:06 <monochrom> hahaha yeah!
17:18:08 <Eduard_Munteanu> You can cope with larger pointer sizes using other addressing modes and such, if you really want it.
17:20:29 <justin-kp> where does cabal install stick the source files it downloads?
17:20:51 <Eduard_Munteanu> I also wonder how easy it is to get a multilib build of that, since you probably don't want your whole system x32.
17:20:58 <dcoutts_> justin-kp: ~/.cabal/packages/$server/
17:21:10 <ddarius> $server is new
17:21:15 <dcoutts_> nope
17:21:24 <dcoutts_> justin-kp: but perhaps you're looking for the "cabal unpack" command?
17:21:39 <btutt> Eduard: The perf #s are pretty interesting
17:21:48 <ddarius> Yeah, I just checked.
17:21:51 <justin-kp> dcoutts_: cabal unpack?
17:22:51 <dcoutts_> justin-kp: cabal unpack the-pkg-name
17:23:03 <btutt> x32 would be a multilib scenario on a x64 os, yes.
17:24:12 <jkr> is there any consensus library for parsing email headers?
17:24:17 <jkr> hsemail seems the most actively developed of the ones I saw, but it's so by-the-RFC that it can't deal with half of my emails for one reason or another.
17:24:29 <justin-kp> dcoutts_: that just downloads the package and sticks it in whatever directory you invoked it from
17:24:30 <justin-kp> ?
17:24:44 <jkr> (and that's after taking care of line endings.)
17:25:37 <dcoutts_> justin-kp: well perhaps that's not what you're after, I was just guessing
17:25:47 <xplat> <interactive>:1:41: Failed to load interface for `InF': locations searched: InF.hs InF.lhs
17:25:50 <xplat> :(
17:25:59 <dcoutts_> justin-kp: most people ask where the downloaded packages are kept because they want to untar one of them
17:27:41 <xplat> hiding package base-3.0.3.2 to avoid conflict with later version base-4.2.0.0
17:27:54 <xplat> ^ that might be bad ...
17:28:03 <justin-kp> dcoutts_: okay, yes I think that is helpful... if I then make local changes to that, how do I 'install' it?
17:28:04 <Eduard_Munteanu> btutt: hm, I'm looking further into it.
17:28:17 <dcoutts_> justin-kp: cabal install
17:28:22 <Eduard_Munteanu> I'm curious what sorts of applications benefit from it.
17:28:35 <dcoutts_> xplat: it's not bad
17:28:45 <justin-kp> dcoutts_: oh okay nice
17:28:50 <btutt> Eduard: I'm guessing UI applications that don't need server amounts of memory but benefit from extra registers
17:29:02 <xplat> hm, something's bad, though, since it can't load up InF
17:29:05 <btutt> or even command line applications
17:30:32 <Eduard_Munteanu> Yeah, though that unfortunately breaks large file mmap-ing. I was rather thinking of intensive scientific applications not requiring lots of data.
17:30:49 <xplat> the x86 instruction set is like having a high-performance turbocharged v10 engine and using a coffee stirrer as a fuel line
17:31:49 <Eduard_Munteanu> (io-bound but using reasonable data sets)
17:31:53 <wagle_> how complete is hxt, the xml library compated to haxml?
17:32:03 <wagle_> how complete is hxt, the xml library, compared to haxml?
17:32:16 <xplat> Eduard_Munteanu: back in the day i forked a variant of xlife which ran way faster on sparc compared to x86 than it should have because of register pressure on the latter
17:32:21 <xplat> (it was bit-parallel)
17:32:50 <Eduard_Munteanu> Yeah, x86-32 suffered a lot from register pressure.
17:33:12 <Eduard_Munteanu> (and not so smart ELFs)
17:33:43 <btutt> Eduard: Large file mmapping would have to be pretty large if you need more than a 32bit process can give you. :)
17:34:23 <Eduard_Munteanu> A few gigs ain't that large. :)
17:34:24 <xplat> btutt: you can't even mmap a dvd image on 32 bits
17:35:00 <btutt> Why not? (Not that I'd want to)
17:35:10 <wagle_> 2G is 32 bits
17:35:14 <btutt> oh dvd image, duh. 
17:35:26 <Eduard_Munteanu> 4GiB
17:35:28 <btutt> Again, not sure why I'd want to. Sounds painful
17:35:45 <Eduard_Munteanu> Though note a large part of the virtual address space is already used.
17:35:49 <wagle_> Eduard_Munteanu: i musta been ignoring the sign bit
17:36:55 <btutt> anyway, bottom line is if you're not using >2gig than odds are good that you should consider running perf #s on a 32bit version
17:37:19 <justin-kp> hmm i am trying to cabal install utf8-light, and am getting the following error - ghc: could not execute: /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.3/ghc-asm
17:37:31 <justin-kp> what does this mean?
17:37:44 <dcoutts_> it's a perl script, for some reason it cannot run it
17:38:01 <justin-kp> a perl script ???
17:38:30 <dcoutts_> perhaps the file is not set executable
17:38:33 <justin-kp> hmm let me check permissions on it
17:39:05 <btutt> missing +x or no /usr/bin/perl would do it
17:39:36 <monochrom> http://www.vex.net/~trebla/tmp/join-meet-alpha.png  :)
17:40:56 <Eduard_Munteanu> Oh, #math fun
17:41:15 <monochrom> actually, I'm showing the join and meet symbols :)
17:41:34 <monochrom> and don't forget alpha-conversion :)
17:41:51 <kniu> I'm about to give up.
17:42:08 <kniu> No matter what I do, I can't get my program to run faster on two cores than on one.
17:42:45 <levifikri> Hi, what is the most efficient way to append bytestrings?
17:42:52 <btutt> Sullivan was complaining that generics are slow at http://www.serpentine.com/blog/2011/02/25/faster-better-cleaner-new-aeson-and-attoparsec-releases/ What is the reason behind that?
17:42:52 <Eduard_Munteanu> Ah, I missed those.
17:43:00 <justin-kp> i figured it out, it was executable, but was getting /ghc-asm: /opt/local/bin/perl: bad interpreter: No such file or directory
17:43:01 <monochrom> the append function in the bytestring lib
17:43:12 <levifikri> monochrom append :: ByteString -> ByteString -> ByteString
17:43:18 <justin-kp> for some reason it was looking in /opt instead of /usr/bin/perl
17:43:20 <monochrom> yes that one. I used it recently
17:43:22 <levifikri> it took O(n\c)/ 
17:43:30 <levifikri> doesn't it too high?
17:43:42 <monochrom> I think it's good enough and can't be better.
17:43:43 <levifikri> btw what's the meaning of O(n\c)/ ?
17:43:45 <levifikri> what is c?
17:43:51 <Eduard_Munteanu> Chunk size, IIRC.
17:43:57 <wagle_> justin-kp: lots of things like depending on macports perl
17:44:30 <Saizan> btutt: they have the bad habit of deciding at runtime what could be determined statically
17:44:39 <justin-kp> wagle_: including apparently the haskell platform
17:44:48 <monochrom> I used lazy bytestring and I did (short `append` long) so I hope it is good
17:44:50 <levifikri> if I were using Lazy ByteString, and combined thousands of ByteString using append function, would it be still effective?
17:45:07 <Saizan> btutt: a better way to avoid that kind of boilerplate is TemplateHaskell imo
17:45:19 <btutt> Ah.
17:46:48 <btutt> Yeah, TH is always better than runtime decision making :) 
17:47:00 <Bfig_> question about hugs for windows: is there any problem with literal scripts and spaces between > and the actual code? just started toying around with a script i downloaded from the web and the only way my functions get recognized as correct code is if i copy paste the '>     '
17:47:27 <justin-kp> when you say cabal unpack foo , does it unpack the locally installed version of package foo, or does it fetch foo from hackage and unpack that
17:49:02 <dcoutts_> justin-kp: the hackage one, it's for unpacking source tarballs, installed ones don't necessarily have a saved source tarball
17:49:40 * dcoutts_ notes cabal-install-0.10 can also unpack local and remote tarballs, not just named packages from hackage
17:50:19 <Eduard_Munteanu> Well isn't it like it unpacks the latest version, which in some cases implies fetching it?
17:50:25 <Eduard_Munteanu> (unless you also specify a version number)
17:50:33 <justin-kp> dcoutts: ok nice
17:50:37 <monochrom> the bytestring doc has a typo or haddock has a bug. it wants to say O(n/c). if you have a lot of bytestrings to combine, try concat.
17:50:43 <Eduard_Munteanu> e.g. if you 'cabal update'd in the meanwhile.
17:52:17 <dcoutts_> Eduard_Munteanu: right
17:52:19 <justin-kp> this is a great irc channel i am very impressed with how friendly everybody is so far :)
17:52:20 <kleinucopia> Monad-illiterate with a monad question: I want to construct a type such as S Polarity Intensity, where Intensity is returned from some webpage scraping
17:52:38 <kleinucopia> so I have a function called doQ :: String -> IO Int
17:54:12 <kleinucopia> how can I write something like mkS with that Intensity trapped in IO?
17:56:19 <Saizan> Intensity = Int?
17:57:20 <Saizan> anyhow, it'd look like "do i <- doQ ..; ...; return (S .. i)" if i'm guessing correctly
17:58:22 <kleinucopia> Saizan: if I wrapped just that in a function, it would be something like f :: IO Int -> IO S ?
17:59:33 <kleinucopia> Intensity is not an int, but rather a ternary type, like Intensity = None | Strong | Stronger
17:59:54 <kniu> what about Strongest?
17:59:59 <kniu> or Strongerer?
18:00:04 <Saizan> then how does it relate to doQ which returns an Int?
18:00:05 <kleinucopia> kniu: want to leave myself some room.
18:00:06 <kniu> or MostStrong?
18:00:22 <kleinucopia> Saizan: woah, I am telling you the wrong thing.
18:00:31 <kleinucopia> s/Intensity/Polarity
18:00:57 <kleinucopia> Polarity is chosen based on a balance of two doQ results.
18:01:03 <kniu> SoStrongItsRidiculousGoodLordHaveMercyItsStrong
18:01:16 <Saizan> anyhow, the important part is that you can access whatever doQ is supposed to produce when executed by using do-notation like above
18:01:30 <Eduard_Munteanu> Tensorial strength must be the uber duper thingy.
18:02:12 <kleinucopia> Saizan: so essentially whenever I instantiate an S, I'll be in IO
18:02:15 <Saizan> which is 'i' in the code above
18:02:32 <Saizan> kleinucopia: if you build it like that, yes
18:02:55 <kleinucopia> Saizan: ok, that's what I thought would happen and I'm not sure if that's what I want.
18:03:03 <kleinucopia> but it doesn't look like there's a way around it.
18:03:54 <Saizan> no
18:13:31 <kleinucopia> Saizan: next question. If score :: String -> IO Polarity, and hides all of the doQ stuff, can I go from having to make S (IO Polarity) Intensity to IO S Polarity Intensity?
18:14:51 <Saizan> i don't understand
18:15:10 <Saizan> you're mixing S as a type and S as a data constructor, it seems
18:15:15 <Saizan> they are two separate things
18:15:36 <Saizan> how is your S type defined?
18:16:04 <kleinucopia> data S = S Polarity Intensity
18:17:17 <Saizan> ok
18:18:23 <Saizan> so you just have to "do p <- score "foo"; return (S p theIntensity)"
18:18:31 <Saizan> and it'd be of type IO S
18:21:12 <kleinucopia> Saizan: you just taught me more about monads than any tutorial I've read.
18:21:47 <kleinucopia> I mean my code is probably horrible at this point, but at least I understand what's going on. Thanks.
18:23:17 <Saizan> heh
18:25:18 <Saizan> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html <- this is good if you just want to know how to use IO
18:25:36 <Saizan> http://www.haskell.org/haskellwiki/Monads_as_computation <- this one is good in general
18:33:40 <napping> I guess the IO tutorial seems to be what's in order
18:33:45 * hackagebot concurrent-barrier 0.1 - Simple thread barriers  http://hackage.haskell.org/package/concurrent-barrier-0.1 (JeremyFitzhardinge)
18:50:35 <hpaste> aavogt pasted "killallcopies"  http://hpaste.org/44411
18:50:48 <aavogt> hmm, wrong chan
18:53:04 <scooty-puff> is there a good way, using alex, to parse a double-quote enclosed string, including escape sequences?
18:53:11 <scooty-puff> i had intended to use different start codes
18:53:20 <scooty-puff> but unless i put it all in a writer monad
18:53:26 <scooty-puff> i am not sure how to go about it
18:54:15 <SoleSoul> excuse me for the simple question. I'm new. Is there a standard stack implementation ready for use in haskell like the std in C++?
18:54:45 <blackdog> SoleSoul: could just use a list...
18:54:59 <blackdog> same performance characteristics etc
18:55:20 <SoleSoul> fine. Then there is no such thing and no need for it?
18:55:29 <ddarius> A list is exactly an immutable stack.
18:57:32 <SoleSoul> Left side of the list will be the topmost value of the stack, right?
18:58:19 * ddarius recommends using less terminology based on convention.
18:59:30 <SoleSoul> OK. Would the equivalent of pushing be performed on the first value of the list?
19:00:23 <blackdog> yep. remember it's immutable, so your notional function will have the type a -> [a] -> [a] - it doesn't change the original list.
19:03:02 <SoleSoul> I understand. It will return the new list.
19:03:17 <SoleSoul> Thank you.
19:03:32 <SoleSoul> Both
19:04:03 <blackdog> no worries. go have fun.
19:04:26 <lpsmith> Ok, the documentation for System.Process.waitForProcess says:  GHC Note: in order to call waitForProcess without blocking all the other threads in the system, you must compile the program with -threaded.
19:04:57 <lpsmith> does that mean I have to compile the module that the call is located in -threaded,  or do I need to compile everything -threaded?
19:05:18 <ddarius> lpsmith: -threaded says to link in the threaded runtime.
19:05:23 <lpsmith> ahh
19:05:31 <lpsmith> that makes sense
19:05:51 <scooty-puff> so any way to have state with alex short of writing a new template?
19:06:19 <scooty-puff> wait, maybe the alex doc i was using was for an older version
19:06:40 <heatsink> scooty-puff: I never figured out how to use the alex templates, I write my own loop around its entry routine
19:06:59 <scooty-puff> ok
19:07:18 <scooty-puff> using the monad version, and looks like theres a monadUser template that i can copy for a bytestring version
19:08:12 <scooty-puff> though perhaps i could just produce a double quote token, etc., handling codes appropriately
19:16:50 <scooty-puff> anyone know about parser performance?
19:17:10 <scooty-puff> not sure if i should have a single lexer, with multiple int states (i.e. alex) and a single parser
19:17:21 <scooty-puff> or a lexer (single state) and multiple specific parsers
19:17:39 <napping> Do you expect performance to be a problem?
19:17:41 <scooty-puff> these are bottom-up parsers
19:17:54 <scooty-puff> no, but would require a large rewrite if one shows up
19:17:59 <scooty-puff> and partly just to know
19:19:29 <napping> If you are parsing less than megabytes of input, it probably doesn't matter
19:21:03 <scooty-puff> ok
19:21:17 <napping> I expect you could parse a quoted string as a single token
19:21:22 <scooty-puff> maybe just from a style perspective: this has to do with parsing a language, and parsing character escapes in the language
19:21:34 <scooty-puff> i know how i would with lex/flex
19:21:46 <napping> I would probably try to process the escapes in the lexer
19:21:54 <scooty-puff> ok
19:28:56 <napping> What are you trying to parse anyway?
19:33:30 <itsnotvalid> any thoughts on aeson and json-enumerator?
19:39:37 <SoleSoul> Is there a preference regarding whether to use arrays or lists to implement a stack?
19:40:00 <Makoryu> What kind of stack might that be?
19:40:17 <SoleSoul> I don't know. The simplest?
19:40:25 <Makoryu> I mean
19:40:29 <napping> lists are probably best
19:40:54 <napping> An array version that has any chance of being efficient would only be usable in IO
19:41:39 <Makoryu> SoleSoul: Do you expect to only use this stack in IO (or ST) actions?
19:42:16 <napping> lists are already provided
19:42:39 <Makoryu> SoleSoul: Or are you perhaps referring to the execution stack? (Those are a bit complicated in Haskell and most people don't understand them.... including me)
19:43:04 <SoleSoul> I have an exercise to create a VirtualMachine code to asm translator. I have to use a stack for the VM operations. I am very new to haskell and now I'm considering my options.
19:43:11 <Makoryu> Ahh
19:43:53 <Makoryu> SoleSoul: That sounds like a job for lists!
19:44:16 <SoleSoul> Great. I found something then! I'll show you.
19:44:27 <SoleSoul> http://www.syntaxpolice.org/lectures/haskellTalk/slides/x133.html
19:44:35 <SoleSoul> Is this the right direction?
19:45:57 <SoleSoul> I only need the basic functions from there. I think it's good.
19:46:18 <siracusa> itsnotvalid: Personally, I prefer json2 due to its simple API. Considering performance it might not be the best choice because it uses Strings instead of ByteStrings.
19:46:51 <Makoryu> SoleSoul: I'd say so. Your main concern will be deciding how to interface with the stack in your own code.
19:48:23 <SoleSoul> Thank you! both. I'll continue my little research :)
19:51:24 <shlevy> I can't remember if I've asked this here before: has anyone used lambdavm?
19:54:12 <mun_> does anyone know how the HOL semantics could be aligned to FOL semantics? Is, e.g., quantification over functions or polymorphism equivalent to any feature of FOL?
20:07:48 * roconnor wonders if the ||- occuring in Well-Typed is on purpose.
20:10:45 <napping> The logo suggests so
20:11:44 <roconnor> indeed
20:14:32 <napping> We$\Vdash$Typed has some promise
20:15:31 <copumpkin> subtle
20:19:17 <Gracenotes> oh wow, it's the last day of february
20:19:28 <Gracenotes> at least in America, still
20:20:35 <roconnor> 5 minutes untill I switch ISPs
20:22:03 <lpsmith> roconnor, a better ISP?
20:22:16 <roconnor> no caps, no throttling
20:22:23 <lpsmith> sweet
20:23:45 <copumpkin> preflex: seen dolio
20:23:45 <preflex>  dolio was last seen on #haskell 14 hours, 56 minutes and 24 seconds ago, saying: xplat: The official haskell distro is source mage. Everyone knows that.
20:32:06 <haxwell> hey, I'm new to haskell and would like some help with quicksorting in haskell
20:37:48 <Gracenotes> o.o
20:41:25 <applicative> haxwell, what's the trouble? 
20:41:39 <napping> having quite already?
20:41:47 <napping> quit
20:42:55 <applicative> my policy of looking for the last unanswered simple question is a bit error prone.
20:43:14 <napping> you don't autocomplete nicks?
20:44:50 <applicative> no.  sounds like an excellent idea.  like western civilization.
21:04:19 * hackagebot ghci-diagrams 0.1 - Display simple diagrams from ghci  http://hackage.haskell.org/package/ghci-diagrams-0.1 (PeterDivianszky)
21:13:38 <Gracenotes> western civilization isn't all it's cracked up to be.
21:22:03 <tg_> Gracenotes: for reference, that's a joke reference from http://www.quotationspage.com/quote/1038.html
21:22:06 <tg_> from Ghandi
21:23:18 <Gracenotes> yup, ghandi, what a comedian he was
21:24:03 <tg_> one of my favorite stories about Ghandi is from here: http://sites.google.com/site/qitranscripts/transcripts/2x09
21:24:08 <tg_> search for Ghandi
21:24:08 <Gracenotes> he left a salty taste in some people's mouths though
21:24:27 <tg_> gandhi, it's spelled, in that docu
21:24:45 <rwbarton> as in most
21:25:11 * tg_ realizes he's been misspelling it
21:25:16 <rwbarton> :)
21:25:26 <Gracenotes> and you were propagating your misspelling onto me!
21:26:07 <Gracenotes> but, yeah, QI! I remember that episode. even the weird way John Sessions said it
21:26:47 <tg_> Gracenotes: yeah hehe
21:27:15 <SoleSoul> <preflex>  dolio was last seen on #haskell 14 hours, 56 minutes and 24 seconds ago, saying: xplat: The official haskell distro is source mage. Everyone knows that. <- This wasn't serious, right?
22:22:41 * hackagebot riak-protobuf 0.14.0.0 - Haskell types for the Riak protocol buffer API  http://hackage.haskell.org/package/riak-protobuf-0.14.0.0 (BryanOSullivan)
22:29:39 * hackagebot riak 0.3.0.0 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.3.0.0 (BryanOSullivan)
22:35:38 <shapr> preflex: seen edwardk
22:35:38 <preflex>  edwardk was last seen on #haskell 3 days, 6 hours, 44 minutes and 44 seconds ago, saying: thats not that bad i guess
23:32:36 <frank00> Question for windwser haskeller: I am using notepad++ to edit my prgrams, but I see I am wrong: ther are indentation problems (i.e. the tab problem). What's a god editor for win?
23:37:34 <ehamberg> frank00: emacs? vim?
23:42:03 <frank00> thanks I'll download them
23:43:04 <jonkri> when will http://planet.haskell.org/ be back up?
